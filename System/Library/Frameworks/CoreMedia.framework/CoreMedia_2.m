uint64_t hevcbridgeUPull(uint64_t a1, int a2, _DWORD *a3)
{
  int v4;
  uint64_t result;

  if (*(unsigned char *)(a1 + 41) || a2 <= 0 || a2 >= 0x1A)
  {
    result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 80) >> -(char)a2;
    result = hevcbridgeAdvanceInBitstream(a1, a2);
  }
  *a3 = v4;
  return result;
}

uint64_t hevcbridgeUPullFlagAlways(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, unsigned char *a5)
{
  int v13 = 0;
  uint64_t result = hevcbridgeUPull(a1, 1, &v13);
  if (!result)
  {
    unsigned __int8 v10 = v13;
    *a5 = v13;
    if (a3)
    {
      uint64_t v11 = *a2;
      v12 = (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[1];
      return v12(v11, a4, v10, 0xFFFFFFFFLL);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t hevcbridgeUPullFlagIfRequested(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  if (a3)
  {
    int v10 = 0;
    uint64_t result = hevcbridgeUPull(a1, 1, &v10);
    if (!result)
    {
      uint64_t v7 = *a2;
      v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))a2[1];
      uint64_t v9 = v10;
      return v8(v7, a4, v9, 0xFFFFFFFFLL);
    }
  }
  else
  {
    return hevcbridgeUSkip(a1, 1);
  }
  return result;
}

uint64_t hevcbridgeUSkip(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 41) || a2 < 0) {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  else {
    return hevcbridgeAdvanceInBitstream(a1, a2);
  }
}

uint64_t hevcbridgeParseProfileTierLevel(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  unsigned int v42 = 0;
  unsigned int v41 = 0;
  *(_DWORD *)((char *)v40 + 3) = 0;
  v40[0] = 0;
  *(_DWORD *)((char *)v39 + 3) = 0;
  v39[0] = 0;
  if (a4 >= 7)
  {
    uint64_t v7 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return v7;
  }
  if (a3)
  {
    uint64_t v7 = hevcbridgeUPullIfRequested(a1, a2, *((_DWORD *)a2 + 15) & 1, 308, 2);
    if (v7) {
      return v7;
    }
    uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 60) >> 1) & 1, 309);
    if (v7) {
      return v7;
    }
    int v8 = *((_DWORD *)a2 + 15);
    uint64_t v9 = hevcbridgeUPullLong(a1, 5, &v42);
    uint64_t v7 = v9;
    if ((v8 & 4) != 0 && !v9) {
      uint64_t v7 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 310, v42, 0xFFFFFFFFLL);
    }
    if (v7) {
      return v7;
    }
    int v10 = *((_DWORD *)a2 + 15);
    uint64_t v11 = hevcbridgeUPullLong(a1, 32, &v41);
    uint64_t v7 = v11;
    if ((v10 & 8) != 0 && !v11) {
      uint64_t v7 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 311, v41, 0xFFFFFFFFLL);
    }
    if (v7) {
      return v7;
    }
    unsigned int v12 = *((_DWORD *)a2 + 15);
    if ((v12 & 0x30) != 0)
    {
      uint64_t v7 = hevcbridgeUPullIfRequested(a1, a2, (v12 >> 4) & 1, 312, 16);
      if (v7) {
        return v7;
      }
      uint64_t v13 = hevcbridgeUPullIfRequested(a1, a2, (*((unsigned __int8 *)a2 + 60) >> 5) & 1, 313, 32);
    }
    else
    {
      v25 = (const float *)&v41;
      float32x4_t v26 = vld1q_dup_f32(v25);
      int8x16_t v36 = (int8x16_t)v26;
      uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (v12 >> 6) & 1, 314);
      if (v7) {
        return v7;
      }
      uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, *((unsigned __int8 *)a2 + 60) >> 7, 315);
      if (v7) {
        return v7;
      }
      uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 8) & 1, 316);
      if (v7) {
        return v7;
      }
      uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 9) & 1, 317);
      if (v7) {
        return v7;
      }
      v27.i64[0] = 0x101010101010101;
      v27.i64[1] = 0x101010101010101;
      int8x16_t v34 = vbicq_s8(v27, vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18FE96700)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18FE96710))), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18FE96720)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18FE96730)))));
      v28.i16[0] = v34.u8[4];
      v28.i16[1] = v34.u8[5];
      v28.i16[2] = v34.u8[6];
      v28.i16[3] = v34.u8[7];
      uint16x4_t v29 = (uint16x4_t)vtst_s16(v28, v28);
      v37.i32[0] = v29.i32[0];
      unsigned int v35 = v42;
      if ((vmaxv_u16(v29) & 1) != 0 || v42 - 4 <= 3)
      {
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 10) & 1, 318);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 11) & 1, 319);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 12) & 1, 320);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 13) & 1, 321);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 14) & 1, 322);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 15) & 1, 323);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, HIWORD(*((_DWORD *)a2 + 15)) & 1, 324);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 17) & 1, 325);
        if (v7) {
          return v7;
        }
        uint64_t v7 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 18) & 1, 326);
        if (v7) {
          return v7;
        }
        uint64_t v30 = a1;
        int v31 = 34;
      }
      else
      {
        uint64_t v30 = a1;
        int v31 = 43;
      }
      uint64_t v7 = hevcbridgeUSkip(v30, v31);
      if (v7) {
        return v7;
      }
      if (v35 - 1 < 5
        || (!v34.i8[1] ? (BOOL v32 = v34.u8[2] == 0) : (BOOL v32 = 0),
            v32 ? (BOOL v33 = v34.u8[3] == 0) : (BOOL v33 = 0),
            !v33 || (v37.i8[0] & 1) != 0 || (v37.i8[2] & 1) != 0))
      {
        uint64_t v13 = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 19) & 1, 327);
      }
      else
      {
        uint64_t v13 = hevcbridgeUSkip(a1, 1);
      }
    }
    uint64_t v7 = v13;
    if (v13) {
      return v7;
    }
  }
  uint64_t v7 = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 15) >> 20) & 1, 328, 8);
  if (!v7)
  {
    if (a4)
    {
      uint64_t v14 = a4;
      v15 = v40;
      v16 = v39;
      uint64_t v17 = a4;
      while (1)
      {
        int v38 = 0;
        uint64_t v18 = hevcbridgeUPull(a1, 1, &v38);
        unsigned char *v15 = v38;
        if (v18) {
          break;
        }
        int v38 = 0;
        uint64_t v18 = hevcbridgeUPull(a1, 1, &v38);
        unsigned char *v16 = v38;
        if (v18) {
          break;
        }
        ++v15;
        ++v16;
        if (!--v17)
        {
          unsigned int v19 = a4 - 8;
          while (1)
          {
            uint64_t v18 = hevcbridgeUSkip(a1, 2);
            if (v18) {
              break;
            }
            if (__CFADD__(v19++, 1))
            {
              v21 = (unsigned __int8 *)v40;
              for (i = v39; ; ++i)
              {
                if (*v21++)
                {
                  uint64_t v18 = hevcbridgeUSkip(a1, 88);
                  if (v18) {
                    break;
                  }
                }
                if (*i)
                {
                  uint64_t v18 = hevcbridgeUSkip(a1, 8);
                  if (v18) {
                    break;
                  }
                }
                uint64_t v7 = 0;
                if (!--v14) {
                  return v7;
                }
              }
              return v18;
            }
          }
          return v18;
        }
      }
      return v18;
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t hevcbridgeUESkip(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 41)) {
    goto LABEL_14;
  }
  uint64_t v1 = a1;
  unsigned int v2 = *(_DWORD *)(a1 + 80);
  if (v2 >= 0x80)
  {
    unsigned int v3 = (2 * __clz(v2)) | 1;
LABEL_10:
    return hevcbridgeAdvanceInBitstream(a1, v3);
  }
  int v6 = 0;
  hevcbridgeUPull(a1, 1, &v6);
  if (v6)
  {
LABEL_14:
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v4 = 0;
  while (1)
  {
    uint64_t result = hevcbridgeUPull(v1, 1, &v6);
    if (result) {
      return result;
    }
    ++v4;
    if (v6)
    {
      if (v4 >= 0x20) {
        goto LABEL_14;
      }
      a1 = v1;
      unsigned int v3 = v4;
      goto LABEL_10;
    }
  }
}

uint64_t hevcbridgeUEPullAlways(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, unsigned int *a5)
{
  uint64_t result = hevcbridgeUEPullLong(a1, a5);
  if (a3 && !result)
  {
    int v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))a2[2];
    uint64_t v11 = *a2;
    uint64_t v12 = *a5;
    return v10(v11, a4, v12, 0xFFFFFFFFLL);
  }
  return result;
}

uint64_t hevcbridgeUPullIfRequested(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, int a5)
{
  if (a3)
  {
    unsigned int v11 = 0;
    uint64_t result = hevcbridgeUPullLong(a1, a5, &v11);
    if (!result)
    {
      int v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))a2[2];
      uint64_t v9 = *a2;
      uint64_t v10 = v11;
      return v8(v9, a4, v10, 0xFFFFFFFFLL);
    }
  }
  else
  {
    return hevcbridgeUSkip(a1, a5);
  }
  return result;
}

uint64_t hevcbridgeUEPullIfRequested(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  if (a3)
  {
    unsigned int v10 = 0;
    uint64_t result = hevcbridgeUEPullLong(a1, &v10);
    if (!result)
    {
      uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))a2[2];
      uint64_t v8 = *a2;
      uint64_t v9 = v10;
      return v7(v8, a4, v9, 0xFFFFFFFFLL);
    }
  }
  else
  {
    return hevcbridgeUESkip(a1);
  }
  return result;
}

uint64_t hevcbridgeParseHRDParameters(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  __int16 v18 = 0;
  unsigned __int8 v17 = 0;
  if (!a3) {
    goto LABEL_20;
  }
  uint64_t result = hevcbridgeUPullFlagAlways(a1, (uint64_t *)a2, *(_WORD *)(a2 + 64) & 1, 329, (unsigned char *)&v18 + 1);
  if (result) {
    return result;
  }
  uint64_t result = hevcbridgeUPullFlagAlways(a1, (uint64_t *)a2, (*(unsigned __int8 *)(a2 + 64) >> 1) & 1, 330, &v18);
  if (result) {
    return result;
  }
  int v8 = HIBYTE(v18);
  int v9 = v18;
  if (!(HIBYTE(v18) | v18))
  {
LABEL_20:
    int v9 = 0;
    int v10 = 0;
    int v8 = 0;
LABEL_21:
    int v11 = 0;
    while (1)
    {
      int v15 = 0;
      unsigned int v16 = 0;
      uint64_t result = hevcbridgeUPull(a1, 1, &v15);
      if (result) {
        return result;
      }
      if ((_BYTE)v15) {
        goto LABEL_26;
      }
      int v15 = 0;
      uint64_t result = hevcbridgeUPull(a1, 1, &v15);
      if (result) {
        return result;
      }
      if ((_BYTE)v15)
      {
LABEL_26:
        uint64_t result = hevcbridgeUESkip(a1);
        if (result) {
          return result;
        }
      }
      else
      {
        int v15 = 0;
        uint64_t result = hevcbridgeUPull(a1, 1, &v15);
        if (result) {
          return result;
        }
        if ((_BYTE)v15)
        {
          unsigned int v12 = 0;
          if (v8) {
            goto LABEL_29;
          }
          goto LABEL_41;
        }
      }
      uint64_t result = hevcbridgeUEPullLong(a1, &v16);
      if (result) {
        return result;
      }
      unsigned int v12 = v16;
      if (v8)
      {
LABEL_29:
        int v13 = 0;
        do
        {
          uint64_t result = hevcbridgeUESkip(a1);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUESkip(a1);
          if (result) {
            return result;
          }
          if (v10)
          {
            uint64_t result = hevcbridgeUESkip(a1);
            if (result) {
              return result;
            }
            uint64_t result = hevcbridgeUESkip(a1);
            if (result) {
              return result;
            }
          }
          uint64_t result = hevcbridgeUSkip(a1, 1);
          if (result) {
            return result;
          }
        }
        while (++v13 <= v12);
      }
LABEL_41:
      if (v9)
      {
        int v14 = 0;
        do
        {
          uint64_t result = hevcbridgeUESkip(a1);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUESkip(a1);
          if (result) {
            return result;
          }
          if (v10)
          {
            uint64_t result = hevcbridgeUESkip(a1);
            if (result) {
              return result;
            }
            uint64_t result = hevcbridgeUESkip(a1);
            if (result) {
              return result;
            }
          }
          uint64_t result = hevcbridgeUSkip(a1, 1);
          if (result) {
            return result;
          }
        }
        while (++v14 <= v12);
      }
      uint64_t result = 0;
      if (++v11 > a4) {
        return result;
      }
    }
  }
  uint64_t result = hevcbridgeUPullFlagAlways(a1, (uint64_t *)a2, (*(unsigned __int8 *)(a2 + 64) >> 2) & 1, 331, &v17);
  if (!result)
  {
    int v10 = v17;
    if (!v17
      || (uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(unsigned __int8 *)(a2 + 64) >> 3) & 1, 332, 8),
          !result)
      && (uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(unsigned __int8 *)(a2 + 64) >> 4) & 1, 333, 5),
          !result)
      && (uint64_t result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t *)a2, (*(unsigned __int8 *)(a2 + 64) >> 5) & 1, 334),
          !result)
      && (uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(unsigned __int8 *)(a2 + 64) >> 6) & 1, 335, 5),
          !result))
    {
      uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, *(unsigned __int8 *)(a2 + 64) >> 7, 336, 4);
      if (!result)
      {
        uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, *(unsigned char *)(a2 + 65) & 1, 337, 4);
        if (!result)
        {
          if (!v10
            || (uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(unsigned __int16 *)(a2 + 64) >> 9) & 1, 338, 4), !result))
          {
            uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(unsigned __int16 *)(a2 + 64) >> 10) & 1, 339, 5);
            if (!result)
            {
              uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(unsigned __int16 *)(a2 + 64) >> 11) & 1, 340, 5);
              if (!result)
              {
                uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(unsigned __int16 *)(a2 + 64) >> 12) & 1, 341, 5);
                if (!result) {
                  goto LABEL_21;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeParseVPSExtension(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned char *a9, unsigned char *a10)
{
  uint64_t v10 = MEMORY[0x1F4188790]();
  __int16 v18 = v11;
  v322[2] = *MEMORY[0x1E4F143B8];
  __int16 v295 = 0;
  v322[0] = 0;
  v322[1] = 0;
  memset(v321, 0, 64);
  if (v14 >= 0x3E) {
    uint64_t v19 = 62;
  }
  else {
    uint64_t v19 = v14;
  }
  v319[0] = 0;
  v319[1] = 0;
  char v320 = 0;
  int v294 = 0;
  memset(v318, 0, sizeof(v318));
  unsigned int v293 = 0;
  __int16 v292 = 0;
  uint64_t v290 = 0;
  uint64_t v291 = 0;
  memset(v317, 0, sizeof(v317));
  __int16 v289 = 0;
  char v288 = 0;
  if (v12 != 1 || v13 != 1) {
    goto LABEL_171;
  }
  unsigned int v20 = v16;
  unsigned int v21 = v15;
  unsigned int v22 = v14;
  uint64_t v23 = v10;
  int v275 = v17;
  if (v14)
  {
    uint64_t v24 = hevcbridgeParseProfileTierLevel(v10, v11, 0, v15);
    if (v24) {
      goto LABEL_9;
    }
  }
  uint64_t v24 = hevcbridgeUPullFlagAlways(v23, v18, (*((_DWORD *)v18 + 11) >> 18) & 1, 21, (unsigned char *)&v295 + 1);
  if (v24) {
    goto LABEL_9;
  }
  unsigned int v271 = v20;
  unsigned int v268 = v21;
  uint64_t v38 = 0;
  uint64_t v39 = v19;
  LODWORD(v19) = 0;
  v269 = a10;
  __src = a9;
  uint64_t v272 = v39;
  size_t count = (v39 + 2);
  do
  {
    LOBYTE(v301) = 0;
    uint64_t v24 = hevcbridgeUPullFlagAlways(v23, v18, (*((_DWORD *)v18 + 11) >> 19) & 1, 22, &v301);
    if (v24) {
      goto LABEL_9;
    }
    int v40 = v301;
    *((unsigned char *)v322 + v38) = v301;
    uint64_t v19 = (v19 + v40);
    ++v38;
  }
  while (v38 != 16);
  int v286 = HIBYTE(v295);
  unsigned int v41 = v19 - HIBYTE(v295);
  if (v19 > HIBYTE(v295))
  {
    if (v41 <= 1) {
      uint64_t v42 = 1;
    }
    else {
      uint64_t v42 = v41;
    }
    v43 = v321;
    while (1)
    {
      LODWORD(v301) = 0;
      uint64_t v44 = *(uint64_t *)((char *)v18 + 44);
      uint64_t v45 = hevcbridgeUPullLong(v23, 3, &v301);
      uint64_t v25 = v45;
      if ((v44 & 0x100000) != 0 && !v45) {
        uint64_t v25 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v18[2])(*v18, 23, v301, 0xFFFFFFFFLL);
      }
      if (v25) {
        break;
      }
      *v43++ = v301 + 1;
      if (!--v42) {
        goto LABEL_30;
      }
    }
LABEL_10:
    float32x4_t v26 = 0;
LABEL_11:
    v280 = 0;
    v283 = 0;
    v277 = 0;
    v285 = 0;
    int8x16_t v27 = 0;
    int16x4_t v28 = 0;
    uint16x4_t v29 = 0;
    uint64_t v30 = 0;
    int v31 = 0;
    BOOL v32 = 0;
    BOOL v33 = 0;
    int8x16_t v34 = 0;
    goto LABEL_12;
  }
LABEL_30:
  if (v286 && v19)
  {
    if (v19 < 2)
    {
      uint64_t v51 = 1;
    }
    else
    {
      int v46 = 0;
      v47 = (char *)v319 + 1;
      uint64_t v48 = v19 - 1;
      v49 = (unsigned __int8 *)v321;
      do
      {
        int v50 = *v49;
        v49 += 4;
        v46 += v50;
        *v47++ = v46;
        --v48;
      }
      while (v48);
      uint64_t v51 = v19;
    }
    unsigned int v52 = *((unsigned __int8 *)v319 + (v19 - 1));
    v321[(v19 - 1)] = 6 - v52;
    *((unsigned char *)v319 + v51) = 6;
    if (v52 >= 6)
    {
LABEL_171:
      uint64_t v25 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_10;
    }
  }
  uint64_t v24 = hevcbridgeUPullFlagAlways(v23, v18, (*((_DWORD *)v18 + 11) >> 21) & 1, 24, &v295);
  if (v24)
  {
LABEL_9:
    uint64_t v25 = v24;
    goto LABEL_10;
  }
  unsigned int v258 = v22;
  *(void *)&long long v53 = -1;
  *((void *)&v53 + 1) = -1;
  v318[15] = v53;
  *(_OWORD *)((char *)&v318[14] + 4) = v53;
  *(_OWORD *)((char *)&v318[13] + 4) = v53;
  *(_OWORD *)((char *)&v318[12] + 4) = v53;
  *(_OWORD *)((char *)&v318[11] + 4) = v53;
  *(_OWORD *)((char *)&v318[10] + 4) = v53;
  *(_OWORD *)((char *)&v318[9] + 4) = v53;
  *(_OWORD *)((char *)&v318[8] + 4) = v53;
  *(_OWORD *)((char *)&v318[7] + 4) = v53;
  *(_OWORD *)((char *)&v318[6] + 4) = v53;
  *(_OWORD *)((char *)&v318[5] + 4) = v53;
  *(_OWORD *)((char *)&v318[4] + 4) = v53;
  *(_OWORD *)((char *)&v318[3] + 4) = v53;
  *(_OWORD *)((char *)&v318[2] + 4) = v53;
  *(_OWORD *)((char *)&v318[1] + 4) = v53;
  *(_OWORD *)((char *)v318 + 4) = v53;
  LODWORD(v318[0]) = 0;
  if (v272)
  {
    uint64_t v54 = 1;
    float32x4_t v26 = (char *)malloc_type_calloc(count, 1uLL, 0x100004077774924uLL);
    v55 = 0;
    unsigned __int8 v56 = 0;
    int v263 = v295;
    v261 = v26 + 1;
    int v57 = 1;
    v265 = v26;
    do
    {
      v284 = v55;
      unsigned int v287 = 0;
      long long v301 = 0uLL;
      if (v263)
      {
        v58 = v26;
        uint64_t v59 = *(uint64_t *)((char *)v18 + 44);
        uint64_t v60 = hevcbridgeUPullLong(v23, 6, &v287);
        uint64_t v25 = v60;
        if ((v59 & 0x400000) != 0 && !v60) {
          uint64_t v25 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v18[2])(*v18, 25, v287, 0xFFFFFFFFLL);
        }
        float32x4_t v26 = v58;
        if (v25) {
          goto LABEL_11;
        }
        unsigned int v61 = v287;
      }
      else
      {
        unsigned int v287 = v54;
        unsigned int v61 = v54;
      }
      int v281 = v57;
      v26[v54] = v61;
      unint64_t v266 = v54;
      v317[v61] = v54;
      unsigned __int8 v62 = v56;
      if (v61 > v56) {
        unsigned __int8 v62 = v61;
      }
      unsigned __int8 v278 = v62;
      if (v286)
      {
        if (v19)
        {
          char v63 = 0;
          v64 = &v301;
          v65 = (char *)v319 + 1;
          uint64_t v66 = v19;
          do
          {
            char v67 = *v65++;
            unsigned int v68 = (v61 & ~(-1 << v67)) >> v63;
            char v63 = v67;
            *(unsigned char *)v64 = v68;
            v64 = (long long *)((char *)v64 + 1);
            --v66;
          }
          while (v66);
        }
      }
      else if (v19)
      {
        v69 = v321;
        v70 = &v301;
        for (uint64_t i = v19; i; --i)
        {
          LODWORD(v297[0]) = 0;
          v72 = v18;
          uint64_t v73 = *(uint64_t *)((char *)v18 + 44);
          int v74 = *v69++;
          uint64_t v75 = hevcbridgeUPullLong(v23, v74, v297);
          uint64_t v25 = v75;
          if ((v73 & 0x800000) != 0)
          {
            __int16 v18 = v72;
            if (!v75) {
              uint64_t v25 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v72[2])(*v72, 26, LODWORD(v297[0]), 0xFFFFFFFFLL);
            }
            if (v25)
            {
LABEL_78:
              float32x4_t v26 = v265;
              goto LABEL_11;
            }
          }
          else
          {
            __int16 v18 = v72;
            if (v75) {
              goto LABEL_78;
            }
          }
          *(unsigned char *)v70 = v297[0];
          v70 = (long long *)((char *)v70 + 1);
        }
      }
      uint64_t v76 = 0;
      unsigned int v77 = 0;
      v297[0] = 0uLL;
      float32x4_t v26 = v265;
      do
      {
        if (*((unsigned char *)v322 + v76))
        {
          char v78 = *((unsigned char *)&v301 + v77++);
          *((unsigned char *)v297 + v76) = v78;
        }
        ++v76;
      }
      while (v76 != 16);
      int v79 = BYTE1(v297[0]);
      *((_DWORD *)v318 + v61) = BYTE1(v297[0]);
      if (*((_DWORD *)v318 + *v265) == v79)
      {
        BOOL v80 = 0;
      }
      else
      {
        v81 = 0;
        do
        {
          v82 = v81;
          if (v284 == v81) {
            break;
          }
          int v83 = *((_DWORD *)v318 + (v81++)[(void)v261]);
        }
        while (v83 != v79);
        BOOL v80 = (unint64_t)(v82 + 1) >= v266;
      }
      unsigned __int8 v56 = v278;
      if (*((unsigned char *)v18 + 47))
      {
        uint64_t v25 = ((uint64_t (*)(uint64_t, uint64_t, void, void))v18[2])(*v18, 27, BYTE3(v297[0]) | (v61 << 8), (v266 - 1));
        float32x4_t v26 = v265;
        if (v25) {
          goto LABEL_11;
        }
      }
      int v57 = v281 + v80;
      uint64_t v54 = v266 + 1;
      v55 = v284 + 1;
    }
    while (v266 + 1 != v272 + 1);
  }
  else
  {
    v265 = 0;
    unsigned __int8 v56 = 0;
    int v57 = 1;
  }
  uint64_t v84 = hevcbridgeUPullAlways(v23, v18, (*((_DWORD *)v18 + 11) >> 25) & 1, 28, &v294, 4);
  if (v84) {
    goto LABEL_81;
  }
  unsigned __int8 v279 = v56;
  int v85 = v294;
  v86 = v265;
  if (v294 && v57)
  {
    int v87 = 0;
    unint64_t v88 = ((unint64_t)v56 << 16) + 0x10000;
    int v282 = v57;
    while (1)
    {
      LODWORD(v301) = 0;
      v89 = v18;
      uint64_t v90 = *(uint64_t *)((char *)v18 + 44);
      uint64_t v91 = hevcbridgeUPullLong(v23, v85, &v301);
      uint64_t v25 = v91;
      if ((v90 & 0x4000000) != 0)
      {
        __int16 v18 = v89;
        if (!v91) {
          uint64_t v25 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v89[2])(*v89, 29, v301, 0xFFFFFFFFLL);
        }
      }
      else
      {
        __int16 v18 = v89;
      }
      if (v25) {
        goto LABEL_82;
      }
      if ((*((unsigned char *)v18 + 47) & 8) != 0) {
        break;
      }
LABEL_97:
      ++v87;
      v86 = v265;
      if (v87 == v282) {
        goto LABEL_98;
      }
    }
    uint64_t v92 = 0;
    v93 = (int *)v318;
    int v94 = v301;
    while (1)
    {
      int v95 = *v93++;
      if (v95 == v87)
      {
        uint64_t v84 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v18[2])(*v18, 30, v94 | v92, 0xFFFFFFFFLL);
        if (v84) {
          break;
        }
      }
      v92 += 0x10000;
      if (v88 == v92) {
        goto LABEL_97;
      }
    }
LABEL_81:
    uint64_t v25 = v84;
LABEL_82:
    v280 = 0;
    v283 = 0;
LABEL_83:
    v277 = 0;
    v285 = 0;
    int8x16_t v27 = 0;
    int16x4_t v28 = 0;
    uint16x4_t v29 = 0;
    uint64_t v30 = 0;
    int v31 = 0;
    BOOL v32 = 0;
    BOOL v33 = 0;
    int8x16_t v34 = 0;
    float32x4_t v26 = v265;
    goto LABEL_12;
  }
LABEL_98:
  v265 = v86;
  uint64_t v274 = v23;
  if (!v272)
  {
    v149 = 0;
    v259 = 0;
    v150 = 0;
    v151 = 0;
    v152 = 0;
    v257 = 0;
    v285 = 0;
    v153 = 0;
    v154 = 0;
    v155 = 0;
LABEL_163:
    v277 = v153;
    v280 = v154;
    v283 = v155;
    v260 = v151;
    v262 = v150;
    v267 = v149;
    v264 = v152;
    v156 = 0;
    v157 = 0;
    int v158 = 0;
    unsigned int v159 = v271 + 1;
    goto LABEL_164;
  }
  size_t v96 = v279 + 1;
  v97 = (char *)malloc_type_calloc(count, count, 0x100004077774924uLL);
  v280 = malloc_type_calloc(count, count, 0x100004077774924uLL);
  v283 = v97;
  uint64_t v98 = (v272 + 1);
  v99 = &v97[count];
  uint64_t v100 = 1;
  do
  {
    uint64_t v101 = 0;
    do
    {
      LOBYTE(v301) = 0;
      uint64_t v102 = hevcbridgeUPullFlagAlways(v274, v18, (*((_DWORD *)v18 + 11) >> 28) & 1, 31, &v301);
      if (v102)
      {
        uint64_t v25 = v102;
        goto LABEL_83;
      }
      v99[v101++] = v301;
    }
    while (v100 != v101);
    ++v100;
    v99 += count;
  }
  while (v100 != v98);
  v251 = v18;
  v103 = &v283[count];
  uint64_t v104 = 1;
  do
  {
    uint64_t v105 = 0;
    size_t v106 = v104 * count;
    v107 = v280;
    do
    {
      uint64_t v108 = 0;
      v280[v106 + v105] = v283[v106 + v105];
      v109 = v107;
      do
      {
        if (v103[v108] && *v109) {
          v280[v106 + v105] = 1;
        }
        ++v108;
        v109 += count;
      }
      while (v104 != v108);
      ++v105;
      ++v107;
    }
    while (v105 != v272);
    ++v104;
    v103 += count;
  }
  while (v104 != v98);
  uint64_t v110 = 0;
  uint64_t v111 = 0;
  LOBYTE(v112) = 0;
  LOBYTE(v113) = 0;
  LOBYTE(v114) = 0;
  do
  {
    unsigned __int8 v115 = 0;
    unsigned __int8 v116 = 0;
    unsigned __int8 v117 = 0;
    uint64_t v118 = (v272 + 1);
    uint64_t v119 = v111;
    uint64_t v120 = v110;
    do
    {
      if (v283[v120]) {
        ++v117;
      }
      if (v280[v120]) {
        ++v116;
      }
      if (v280[v119]) {
        ++v115;
      }
      ++v120;
      v119 += count;
      --v118;
    }
    while (v118);
    if (v114 <= v117) {
      size_t v114 = v117;
    }
    else {
      size_t v114 = v114;
    }
    if (v113 <= v116) {
      size_t v113 = v116;
    }
    else {
      size_t v113 = v113;
    }
    if (v112 <= v115) {
      size_t v112 = v115;
    }
    else {
      size_t v112 = v112;
    }
    ++v111;
    v110 += count;
  }
  while (v111 != v98);
  v121 = (unsigned __int8 *)malloc_type_calloc(v96, v114, 0x100004077774924uLL);
  v285 = malloc_type_calloc(v96, v113, 0x100004077774924uLL);
  v122 = malloc_type_calloc(v96, v112, 0x100004077774924uLL);
  v264 = malloc_type_calloc(v96, 1uLL, 0x100004077774924uLL);
  v123 = malloc_type_calloc(v96, 1uLL, 0x100004077774924uLL);
  v124 = malloc_type_calloc(v96, 1uLL, 0x100004077774924uLL);
  uint64_t v125 = 0;
  uint64_t v126 = 0;
  do
  {
    uint64_t v127 = 0;
    unsigned __int8 v128 = 0;
    unsigned __int8 v129 = 0;
    unsigned __int8 v130 = 0;
    uint64_t v131 = v265[v126];
    uint64_t v132 = v126;
    do
    {
      unsigned __int8 v133 = v265[v127];
      if (v283[v125 + v127]) {
        v121[v131 * v114 + v130++] = v133;
      }
      if (v280[v125 + v127]) {
        v285[v131 * v113 + v129++] = v133;
      }
      if (v280[v132]) {
        v122[v131 * v112 + v128++] = v133;
      }
      ++v127;
      v132 += count;
    }
    while (v98 != v127);
    v264[v131] = v130;
    v123[v131] = v129;
    v124[v131] = v128;
    ++v126;
    v125 += count;
  }
  while (v126 != v98);
  v260 = v123;
  v262 = v124;
  v277 = v121;
  uint64_t v134 = 0;
  int v135 = 0;
  long long v303 = 0u;
  long long v304 = 0u;
  long long v301 = 0u;
  long long v302 = 0u;
  do
  {
    if (!v264[v265[v134]]) {
      ++v135;
    }
    ++v134;
  }
  while (v98 != v134);
  v136 = malloc_type_calloc(v135, (v112 + 1), 0x100004077774924uLL);
  uint64_t v244 = v135;
  v137 = (unsigned __int8 *)malloc_type_calloc(v135, 1uLL, 0x100004077774924uLL);
  uint64_t v138 = 0;
  unsigned __int8 v139 = 0;
  do
  {
    uint64_t v140 = v265[v138];
    if (!v264[v140])
    {
      uint64_t v141 = v139;
      unint64_t v142 = v139 * (unint64_t)(v112 + 1);
      v136[v142] = v140;
      unsigned __int8 v143 = v262[v140];
      if (v143)
      {
        unint64_t v144 = 0;
        unsigned __int8 v145 = 1;
        do
        {
          uint64_t v146 = v122[v140 * (unint64_t)v112 + v144];
          if (!*((unsigned char *)&v301 + v146))
          {
            v136[v142 + v145++] = v146;
            *((unsigned char *)&v301 + v146) = 1;
            unsigned __int8 v143 = v262[v140];
          }
          ++v144;
        }
        while (v144 < v143);
      }
      else
      {
        unsigned __int8 v145 = 1;
      }
      ++v139;
      v137[v141] = v145;
    }
    ++v138;
  }
  while (v138 != v98);
  v267 = v137;
  v259 = v136;
  v257 = v122;
  if (v135 < 2u)
  {
    __int16 v18 = v251;
    v154 = v280;
    v155 = v283;
    v153 = v277;
    v150 = v262;
    v152 = v264;
    v151 = v260;
    v149 = v137;
    goto LABEL_163;
  }
  uint64_t v147 = (v112 + 1);
  uint64_t v148 = hevcbridgeUEPullAlways(v274, v251, (*((_DWORD *)v251 + 11) >> 29) & 1, 32, &v293);
  if (v148)
  {
    uint64_t v25 = v148;
LABEL_160:
    BOOL v33 = 0;
    int8x16_t v34 = 0;
    __int16 v18 = v251;
    int16x4_t v28 = v264;
    float32x4_t v26 = v265;
    int8x16_t v27 = v257;
    goto LABEL_184;
  }
  uint64_t v255 = v293;
  if (v293 >= 0x400)
  {
    uint64_t v25 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_160;
  }
  unsigned int v172 = v271 + 1;
  size_t v248 = v293 + v271 + 1;
  if (!v293)
  {
    v156 = 0;
    v157 = 0;
    int v158 = 0;
    __int16 v18 = v251;
    unsigned int v159 = v293 + v271 + 1;
    goto LABEL_164;
  }
  v250 = malloc_type_calloc(v248, 1uLL, 0x100004077774924uLL);
  int v243 = v275 + 1;
  __dst = malloc_type_calloc(v248, (v275 + 1), 0x100004077774924uLL);
  if (a9) {
    memcpy(__dst, a9, v243 * v172);
  }
  unsigned char *v250 = 1;
  if (v271)
  {
    if (v172 <= 2) {
      uint64_t v173 = 2;
    }
    else {
      uint64_t v173 = v172;
    }
    v174 = a10 + 1;
    v175 = v250 + 1;
    uint64_t v176 = v173 - 1;
    do
    {
      char v177 = *v174++;
      *v175++ = v177;
      --v176;
    }
    while (v176);
  }
  else
  {
    unsigned int v172 = 1;
  }
  uint64_t v181 = 0;
  do
  {
    uint64_t v316 = 0;
    long long v314 = 0u;
    long long v315 = 0u;
    long long v312 = 0u;
    long long v313 = 0u;
    long long v310 = 0u;
    long long v311 = 0u;
    long long v308 = 0u;
    long long v309 = 0u;
    long long v306 = 0u;
    long long v307 = 0u;
    long long v304 = 0u;
    long long v305 = 0u;
    long long v302 = 0u;
    long long v303 = 0u;
    uint64_t v182 = 1;
    long long v301 = 0u;
    __int16 v18 = v251;
    v183 = v267;
    do
    {
      double v184 = log2((double)(v183[v182] + 1));
      LODWORD(v297[0]) = 0;
      uint64_t v185 = *(uint64_t *)((char *)v18 + 44);
      uint64_t v186 = hevcbridgeUPullLong(v274, vcvtpd_s64_f64(v184), v297);
      uint64_t v25 = v186;
      if ((v185 & 0x40000000) != 0)
      {
        __int16 v18 = v251;
        if (!v186) {
          uint64_t v25 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v251[2])(*v251, 33, LODWORD(v297[0]), 0xFFFFFFFFLL);
        }
      }
      else
      {
        __int16 v18 = v251;
      }
      if (v25) {
        goto LABEL_189;
      }
      v183 = v267;
      if (LODWORD(v297[0]) > v267[v182])
      {
        uint64_t v25 = 4294954582;
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        goto LABEL_189;
      }
      *((_DWORD *)&v301 + v182++) = v297[0];
    }
    while (v244 != v182);
    unsigned __int8 v187 = 0;
    uint64_t v188 = 1;
    do
    {
      unsigned int v189 = *((_DWORD *)&v301 + v188);
      if (v189)
      {
        int v190 = 0;
        do
          *((unsigned char *)__dst + (v172 + v181) * v243 + v187++) = v259[v188 * v147 + v190++];
        while (v189 > v190);
      }
      ++v188;
    }
    while (v188 != v244);
    v250[v172 + v181++] = v187;
  }
  while (v181 != v255);
  v156 = __dst;
  unsigned int v159 = v248;
  v157 = v250;
  __int16 v18 = v251;
  v269 = v250;
  __src = __dst;
  int v158 = v255;
LABEL_164:
  uint64_t v160 = hevcbridgeUPullFlagAlways(v274, v18, *((_DWORD *)v18 + 11) >> 31, 34, (unsigned char *)&v292 + 1);
  if (v160)
  {
LABEL_170:
    uint64_t v25 = v160;
    int8x16_t v27 = v257;
    BOOL v33 = v157;
    uint64_t v30 = v262;
    int16x4_t v28 = v264;
    int8x16_t v34 = v156;
    int v31 = v259;
    uint16x4_t v29 = v260;
    float32x4_t v26 = v265;
    BOOL v32 = v267;
    goto LABEL_12;
  }
  int v254 = v158;
  memset(v300, 0, sizeof(v300));
  if (HIBYTE(v292))
  {
    uint64_t v161 = (v272 + 1);
    v162 = v300;
    do
    {
      LODWORD(v301) = 0;
      uint64_t v160 = hevcbridgeUPullAlways(v274, v18, v18[6] & 1, 35, &v301, 3);
      if (v160) {
        goto LABEL_170;
      }
      *v162++ = v301;
    }
    while (--v161);
  }
  uint64_t v160 = hevcbridgeUPullFlagAlways(v274, v18, (*(unint64_t *)((char *)v18 + 44) >> 33) & 1, 36, &v292);
  if (v160) {
    goto LABEL_170;
  }
  unsigned int v247 = v159;
  bzero(&v298, 0x1000uLL);
  if (!(_BYTE)v292 || !v272)
  {
LABEL_181:
    __dst = v156;
    v250 = v157;
    uint64_t v170 = hevcbridgeUPullFlagAlways(v274, v18, (*(unint64_t *)((char *)v18 + 44) >> 35) & 1, 38, &v289);
    if (v170)
    {
      uint64_t v25 = v170;
LABEL_189:
      int16x4_t v28 = v264;
      float32x4_t v26 = v265;
      int8x16_t v27 = v257;
      uint16x4_t v29 = v260;
      uint64_t v30 = v262;
      int v31 = v259;
      BOOL v32 = v267;
      BOOL v33 = v250;
      int8x16_t v34 = __dst;
      goto LABEL_12;
    }
    v253 = v18;
    uint64_t v171 = hevcbridgeUEPullAlways(v274, v18, (*(unint64_t *)((char *)v18 + 44) >> 36) & 1, 39, (unsigned int *)&v291 + 1);
    if (v171) {
      goto LABEL_187;
    }
    unsigned int v178 = HIDWORD(v291);
    if (HIDWORD(v291) >= 2)
    {
      int v180 = 2;
      do
      {
        LOBYTE(v301) = 0;
        uint64_t v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 37) & 1, 40, &v301);
        if (v171) {
          goto LABEL_187;
        }
        uint64_t v25 = hevcbridgeParseProfileTierLevel(v274, v253, v301, v268);
        if (v25) {
          goto LABEL_188;
        }
      }
      while (++v180 <= v178);
    }
    if (v247 < 2)
    {
      int v179 = 0;
      unsigned int v245 = 0;
    }
    else
    {
      uint64_t v171 = hevcbridgeUEPullAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 38) & 1, 41, (unsigned int *)&v291);
      if (v171) {
        goto LABEL_187;
      }
      int v179 = v291;
      if (v291 >= 0x400) {
        goto LABEL_342;
      }
      uint64_t v171 = hevcbridgeUPullAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 39) & 1, 42, (_DWORD *)&v290 + 1, 2);
      if (v171)
      {
LABEL_187:
        uint64_t v25 = v171;
LABEL_188:
        __int16 v18 = v253;
        goto LABEL_189;
      }
      unsigned int v245 = HIDWORD(v290);
    }
    if (v245 >= 2) {
      int v191 = 2;
    }
    else {
      int v191 = v245;
    }
    int v242 = v191;
    if (*((unsigned char *)v253 + 152))
    {
LABEL_235:
      uint64_t v25 = 1;
      goto LABEL_188;
    }
    int v241 = v179 + v247;
    if (v179 + v247 >= 2)
    {
      int v239 = vcvtpd_s64_f64(log2((double)(v254 + v271)));
      int v240 = v275 + 1;
      int v276 = vcvtpd_s64_f64(log2((double)(v178 + 1)));
      for (unsigned int j = 1; j != v241; ++j)
      {
        unsigned int v192 = 0;
        unsigned int v287 = 0;
        long long v303 = 0u;
        long long v304 = 0u;
        long long v301 = 0u;
        long long v302 = 0u;
        if (v247 >= 3 && j >= v247)
        {
          uint64_t v171 = hevcbridgeUPullAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 40) & 1, 43, &v287, v239);
          if (v171) {
            goto LABEL_187;
          }
          unsigned int v192 = v287;
          if (v287 > v247 - 2) {
            goto LABEL_342;
          }
        }
        if (j >= v247) {
          uint64_t v193 = v192 + 1;
        }
        else {
          uint64_t v193 = j;
        }
        uint64_t v194 = v193;
        unint64_t v195 = v269[v193];
        if (j > v271 || v245 == 2)
        {
          if (v269[v193])
          {
            unint64_t v201 = 0;
            while (1)
            {
              LOBYTE(v297[0]) = 0;
              uint64_t v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 41) & 1, 44, v297);
              if (v171) {
                goto LABEL_187;
              }
              *((unsigned char *)&v301 + v201++) = v297[0];
              unint64_t v195 = v269[v194];
              if (v201 >= v195) {
                goto LABEL_266;
              }
            }
          }
        }
        else
        {
          if (v242)
          {
            if (v269[v193])
            {
              uint64_t v196 = 0;
              unsigned __int8 v197 = 0;
              unsigned __int8 v198 = 0;
              do
              {
                unsigned int v199 = __src[(v194 * v240 + v196)];
                BOOL v200 = v199 >= v198;
                if (v199 > v198) {
                  unsigned __int8 v198 = __src[(v194 * v240 + v196)];
                }
                if (v200) {
                  unsigned __int8 v197 = v196;
                }
                ++v196;
              }
              while (v195 != v196);
            }
            else
            {
              unsigned __int8 v197 = 0;
            }
            *((unsigned char *)&v301 + v197) = 1;
LABEL_266:
            if (!v195) {
              continue;
            }
          }
          else
          {
            if (!v269[v193]) {
              continue;
            }
            memset(&v301, 1, v269[v193]);
          }
          uint64_t v202 = 0;
          uint64_t v203 = 0;
          char v204 = 0;
          do
          {
            if (*((unsigned char *)&v301 + v202))
            {
              ++v204;
              uint64_t v203 = __src[v202];
            }
            ++v202;
          }
          while (v195 != v202);
          uint64_t v205 = 0;
          int v206 = v194 * v240;
          memset(v297, 0, sizeof(v297));
          do
          {
            if (*((unsigned char *)&v301 + v205))
            {
              *((unsigned char *)v297 + v205) = 1;
              if (v205)
              {
                uint64_t v207 = 0;
                unint64_t v208 = v317[__src[(v206 + v205)]]
                     * (unint64_t)count;
                do
                {
                  if (v280[v208 + v317[__src[(v206 + v207)]]]) {
                    *((unsigned char *)v297 + v207) = 1;
                  }
                  ++v207;
                }
                while (v205 != v207);
              }
            }
            ++v205;
          }
          while (v205 != v195);
          unint64_t v209 = 0;
          do
          {
            if (v178 && *((unsigned char *)v297 + v209))
            {
              uint64_t v171 = hevcbridgeUPullIfRequested(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 42) & 1, 45, v276);
              if (v171) {
                goto LABEL_187;
              }
              LODWORD(v195) = v269[v194];
            }
            ++v209;
          }
          while (v209 < v195);
          if (v204 == 1)
          {
            if (v264[v203])
            {
              uint64_t v171 = hevcbridgeUPullFlagIfRequested(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 43) & 1, 46);
              if (v171) {
                goto LABEL_187;
              }
            }
          }
        }
      }
    }
    uint64_t v171 = hevcbridgeUEPullAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 44) & 1, 47, (unsigned int *)&v290);
    if (!v171)
    {
      unsigned int v210 = v290;
      if (v290 < 0x100)
      {
        if (v253[18])
        {
          *(void *)v253[18] = malloc_type_calloc(1uLL, 16 * v290 + 4512, 0x70669407uLL);
          uint64_t v211 = *(void *)v253[18];
          if (!v211)
          {
            uint64_t v25 = 4294954583;
            goto LABEL_188;
          }
          *(_DWORD *)(v211 + 8) = v210;
          uint64_t v212 = v211 + 8;
          *(unsigned char *)(v211 + 204) = v289;
          if (v272)
          {
            uint64_t v213 = 0;
            do
            {
              uint64_t v214 = v265[v213];
              v215 = (unsigned char *)(v211 + v214);
              v215[76] = v264[v214];
              v215[334] = v317[v214];
              if (v264[v214])
              {
                unint64_t v216 = 0;
                v217 = v215 + 206;
                do
                {
                  uint64_t v218 = v317[v277[v214 + v216]];
                  unsigned char *v217 = v218;
                  *(unsigned char *)(v211 + v218 + 270) = v300[v218];
                  ++v216;
                }
                while (v216 < v264[v214]);
              }
              ++v213;
            }
            while (v213 != v272 + 1);
            v219 = v299;
            v220 = (char *)(v211 + 399);
            uint64_t v221 = v272;
            do
            {
              memcpy(v220, v219, --v221 + 1);
              v219 += 65;
              v220 += 65;
            }
            while (v221);
          }
          *(unsigned char *)(v211 + 4494) = v268;
        }
        else
        {
          uint64_t v212 = 0;
        }
        int v222 = 0;
        while (1)
        {
          uint64_t v171 = hevcbridgeParseRepFormat(v274, v253, v222, v212);
          if (v171) {
            goto LABEL_187;
          }
          if (++v222 > v210)
          {
            if (v210)
            {
              uint64_t v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 45) & 1, 48, (unsigned char *)&v289 + 1);
              if (v171) {
                goto LABEL_187;
              }
            }
            memset(v296, 0, sizeof(v296));
            if (HIBYTE(v289))
            {
              if (v272)
              {
                int v223 = vcvtpd_s64_f64(log2((double)(v210 + 1)));
                v224 = (char *)v296 + 1;
                if (v258 >= 0x3EuLL) {
                  uint64_t v225 = 62;
                }
                else {
                  uint64_t v225 = v258;
                }
                do
                {
                  LODWORD(v301) = 0;
                  uint64_t v171 = hevcbridgeUPullAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 46) & 1, 49, &v301, v223);
                  if (v171) {
                    goto LABEL_187;
                  }
                  *v224++ = v301;
                }
                while (--v225);
              }
            }
            else
            {
              uint64_t v226 = (v272 + 2) & 0xFE;
              uint64x2_t v227 = (uint64x2_t)vdupq_n_s64((unint64_t)(v272 + 1) - 1);
              uint32x2_t v228 = (uint32x2_t)vdup_n_s32(v210);
              int32x2_t v229 = (int32x2_t)0x100000000;
              int64x2_t v230 = (int64x2_t)xmmword_18FE96740;
              v231 = (char *)v296 + 1;
              int64x2_t v232 = vdupq_n_s64(2uLL);
              do
              {
                int32x2_t v233 = vmovn_s64((int64x2_t)vcgeq_u64(v227, (uint64x2_t)v230));
                uint32x2_t v234 = vmin_u32((uint32x2_t)v229, v228);
                if (v233.i8[0]) {
                  *(v231 - 1) = v234.i8[0];
                }
                if (v233.i8[4]) {
                  unsigned char *v231 = v234.i8[4];
                }
                int64x2_t v230 = vaddq_s64(v230, v232);
                int32x2_t v229 = vadd_s32(v229, (int32x2_t)0x200000002);
                v231 += 2;
                v226 -= 2;
              }
              while (v226);
            }
            if (v212)
            {
              for (uint64_t k = 0; k != 64; ++k)
                *(unsigned char *)(v212 + 4 + k) = *((unsigned char *)v296 + v317[k]);
            }
            uint64_t v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 47) & 1, 50, &v288);
            if (v171) {
              goto LABEL_187;
            }
            if (v212) {
              *(unsigned char *)(v212 + 197) = v288;
            }
            uint64_t v171 = hevcbridgeUPullFlagIfRequested(v274, v253, *((_WORD *)v253 + 25) & 1, 51);
            if (v171) {
              goto LABEL_187;
            }
            if (!v272) {
              goto LABEL_235;
            }
            uint64_t v236 = 0;
            if (v258 >= 0x3EuLL) {
              uint64_t v237 = 62;
            }
            else {
              uint64_t v237 = v258;
            }
            do
            {
              if (!v264[v265[v236 + 1]])
              {
                LOBYTE(v301) = 0;
                uint64_t v238 = hevcbridgeUPullFlagAlways(v274, v253, (*(unint64_t *)((char *)v253 + 44) >> 49) & 1, 52, &v301);
                uint64_t v25 = v238;
                if (!v212 || v238)
                {
                  if (v238) {
                    goto LABEL_188;
                  }
                }
                else
                {
                  *(unsigned char *)(v212 + v317[v236 + 1] + 132) = v301;
                }
              }
              ++v236;
              uint64_t v25 = 1;
            }
            while (v237 != v236);
            goto LABEL_188;
          }
        }
      }
LABEL_342:
      uint64_t v25 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_188;
    }
    goto LABEL_187;
  }
  uint64_t v163 = 0;
  uint64_t v165 = v272;
  size_t v164 = count;
  v166 = v299;
  while (2)
  {
    uint64_t v249 = v165;
    uint64_t v252 = v163 + 1;
    v167 = v166;
    size_t v168 = v164;
LABEL_176:
    if (!v283[v164])
    {
LABEL_179:
      v164 += count;
      ++v166;
      if (!--v165)
      {
        size_t v164 = v168 + v272 + 3;
        v166 = v167 + 65;
        uint64_t v163 = v252;
        uint64_t v165 = v249 - 1;
        if (v252 == v272) {
          goto LABEL_181;
        }
        continue;
      }
      goto LABEL_176;
    }
    break;
  }
  LODWORD(v301) = 0;
  uint64_t v169 = hevcbridgeUPullAlways(v274, v18, (*(unint64_t *)((char *)v18 + 44) >> 34) & 1, 37, &v301, 3);
  if (!v169)
  {
    unsigned char *v166 = v301;
    goto LABEL_179;
  }
  uint64_t v25 = v169;
  int8x16_t v27 = v257;
  BOOL v33 = v157;
  int16x4_t v28 = v264;
  float32x4_t v26 = v265;
  int8x16_t v34 = v156;
LABEL_184:
  uint16x4_t v29 = v260;
  uint64_t v30 = v262;
  int v31 = v259;
  BOOL v32 = v267;
LABEL_12:
  free(v26);
  free(v283);
  free(v280);
  free(v277);
  free(v285);
  free(v27);
  free(v28);
  free(v29);
  free(v30);
  free(v31);
  free(v32);
  free(v33);
  free(v34);
  if (v25 >= 2)
  {
    unsigned int v35 = (void **)v18[18];
    if (v35)
    {
      int8x16_t v36 = *v35;
      if (*v35)
      {
        *unsigned int v35 = 0;
        free(v36);
      }
    }
  }
  return v25;
}

uint64_t hevcbridgeUEPullLong(uint64_t a1, unsigned int *a2)
{
  int v11 = 0;
  if (*(unsigned char *)(a1 + 41)) {
    goto LABEL_13;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 80);
  if (v4 < 0x80000)
  {
    int v10 = 0;
    hevcbridgeUPull(a1, 1, &v10);
    if (!v10)
    {
      unsigned int v9 = 0;
      while (1)
      {
        uint64_t result = hevcbridgeUPull(a1, 1, &v10);
        if (result) {
          goto LABEL_14;
        }
        ++v9;
        if (v10)
        {
          if (v9 >= 0x20) {
            break;
          }
          uint64_t result = hevcbridgeUPullLong(a1, v9, &v11);
          unsigned int v7 = v11 + ~(-1 << v9);
          goto LABEL_12;
        }
      }
    }
LABEL_13:
    uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_14:
    unsigned int v7 = 0;
    goto LABEL_12;
  }
  unsigned int v5 = __clz(v4);
  unsigned int v6 = v4 << (v5 + 1) >> -(char)v5;
  if (!v5) {
    unsigned int v6 = 0;
  }
  *(_DWORD *)(a1 + 80) = v6;
  unsigned int v7 = v6 + ~(-1 << v5);
  uint64_t result = hevcbridgeAdvanceInBitstream(a1, v5 + 1 + v5);
LABEL_12:
  *a2 = v7;
  return result;
}

uint64_t hevcbridgeParseRepFormat(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  uint64_t v17 = 0;
  char v16 = 0;
  unsigned int v15 = 0;
  char v14 = 0;
  uint64_t v8 = *(uint64_t *)((char *)a2 + 44);
  uint64_t result = hevcbridgeUPullLong(a1, 16, (_DWORD *)&v17 + 1);
  if ((v8 & 0x4000000000000) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 53, HIDWORD(v17), 0xFFFFFFFFLL);
  }
  if (!result)
  {
    uint64_t v10 = *(uint64_t *)((char *)a2 + 44);
    uint64_t result = hevcbridgeUPullLong(a1, 16, &v17);
    if ((v10 & 0x8000000000000) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 54, v17, 0xFFFFFFFFLL);
    }
    if (!result)
    {
      uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 52) & 1, 55, &v16);
      if (!result)
      {
        if (v16)
        {
          uint64_t v11 = *(uint64_t *)((char *)a2 + 44);
          uint64_t result = hevcbridgeUPullLong(a1, 2, &v15);
          if ((v11 & 0x20000000000000) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 56, v15, 0xFFFFFFFFLL);
          }
          if (result) {
            return result;
          }
          unsigned int v12 = v15;
          if (v15 == 3)
          {
            uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 54) & 1, 57);
            if (result) {
              return result;
            }
          }
          uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(unint64_t *)((char *)a2 + 44) >> 55) & 1, 58, 4);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullIfRequested(a1, a2, *((unsigned char *)a2 + 51) & 1, 59, 4);
          if (result) {
            return result;
          }
        }
        else
        {
          unsigned int v12 = 0;
        }
        uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(uint64_t *)((char *)a2 + 44) & 0x200000000000000) != 0, 60, &v14);
        if (result) {
          return result;
        }
        if (v14)
        {
          uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*(uint64_t *)((char *)a2 + 44) & 0x400000000000000) != 0, 61);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*(uint64_t *)((char *)a2 + 44) & 0x800000000000000) != 0, 62);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*(uint64_t *)((char *)a2 + 44) & 0x1000000000000000) != 0, 63);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*(uint64_t *)((char *)a2 + 44) & 0x2000000000000000) != 0, 64);
          if (!a4 || result) {
            return result;
          }
        }
        else if (!a4)
        {
          return 0;
        }
        uint64_t result = 0;
        uint64_t v13 = a4 + 16 * a3;
        *(_DWORD *)(v13 + 4488) = HIDWORD(v17);
        *(_DWORD *)(v13 + 4492) = v17;
        *(_DWORD *)(v13 + 4496) = v12;
        *(unsigned char *)(v13 + 4500) = 0;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeParseScalingListData(uint64_t a1)
{
  unsigned int v2 = 0;
LABEL_2:
  unsigned int v3 = 0;
  unsigned int v4 = 16 << (2 * v2);
  if (v4 >= 0x40) {
    unsigned int v4 = 64;
  }
  if (v2 == 3) {
    int v5 = 3;
  }
  else {
    int v5 = 1;
  }
  if (v4 <= 1) {
    int v6 = 1;
  }
  else {
    int v6 = v4;
  }
  while (1)
  {
    int v9 = 0;
    uint64_t result = hevcbridgeUPull(a1, 1, &v9);
    if (result) {
      return result;
    }
    if ((_BYTE)v9)
    {
      int v8 = v6;
      if (v2 < 2 || (uint64_t result = hevcbridgeSESkip(a1), v8 = v6, !result))
      {
        while (1)
        {
          uint64_t result = hevcbridgeSESkip(a1);
          if (result) {
            break;
          }
          if (!--v8) {
            goto LABEL_18;
          }
        }
      }
      return result;
    }
    uint64_t result = hevcbridgeUESkip(a1);
    if (result) {
      return result;
    }
LABEL_18:
    v3 += v5;
    if (v3 >= 6)
    {
      if (++v2 != 4) {
        goto LABEL_2;
      }
      return 0;
    }
  }
}

uint64_t hevcbridgeParseSTRefPicSet(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  v61[2] = *MEMORY[0x1E4F143B8];
  uint64_t v59 = 0;
  if (!a2) {
    goto LABEL_24;
  }
  LODWORD(v61[0]) = 0;
  uint64_t v10 = hevcbridgeUPull(a1, 1, v61);
  if (v10) {
    return v10;
  }
  if (LOBYTE(v61[0]))
  {
    int v11 = 0;
    uint64_t v58 = 0;
    unsigned int v57 = 0;
    v61[0] = 0;
    v61[1] = 0;
    v60[0] = 0;
    v60[1] = 0;
    if (a2 == a3)
    {
      uint64_t v10 = hevcbridgeUEPullLong(a1, (unsigned int *)&v58 + 1);
      if (v10) {
        return v10;
      }
      int v11 = HIDWORD(v58);
      if (HIDWORD(v58) > a2 - 1) {
        goto LABEL_79;
      }
    }
    uint64_t v10 = hevcbridgeUPullLong(a1, 1, &v58);
    if (!v10)
    {
      uint64_t v10 = hevcbridgeUEPullLong(a1, &v57);
      if (!v10)
      {
        if (v57 < 0x8000)
        {
          unsigned int v12 = ~v11 + a2;
          uint64_t v13 = a4 + 164 * v12;
          uint64_t v14 = *(unsigned __int8 *)(v13 + 160);
          v55 = (unsigned __int8 *)(v13 + 160);
          char v16 = (unsigned char *)(v13 + 161);
          uint64_t v15 = *(unsigned __int8 *)(v13 + 161);
          uint64_t v54 = v16;
          if ((v15 + v14) <= 0xF)
          {
            int v17 = v57 + 1 - 2 * v58 * (v57 + 1);
            uint64_t v52 = v15 + v14;
            unsigned int v53 = v12;
            uint64_t v18 = a4 + 164 * v12;
            uint64_t v19 = (v15 + v14 + 1);
            unsigned int v20 = v60;
            unsigned int v21 = v61;
            while (1)
            {
              int v56 = 0;
              uint64_t v22 = hevcbridgeUPull(a1, 1, &v56);
              char v23 = v56;
              unsigned char *v21 = v56;
              if (v22) {
                return v22;
              }
              if (v23)
              {
                *unsigned int v20 = 1;
              }
              else
              {
                int v56 = 0;
                uint64_t v22 = hevcbridgeUPull(a1, 1, &v56);
                *unsigned int v20 = v56;
                if (v22) {
                  return v22;
                }
              }
              ++v20;
              ++v21;
              if (!--v19)
              {
                uint64_t v24 = *v54;
                if (*v54)
                {
                  unsigned int v25 = 0;
                  uint64_t v27 = v52;
                  unsigned int v26 = v53;
                  int16x4_t v28 = v55;
                  do
                  {
                    int v29 = *(_DWORD *)(a4 + 164 * v53 + 60 + 4 * v24) + v17;
                    if (v29 < 0)
                    {
                      uint64_t v30 = v24 + *v55 - 1;
                      if (*((unsigned char *)v60 + v30))
                      {
                        *(_DWORD *)(a5 + 4 * v25) = v29;
                        *(unsigned char *)(a5 + v25++ + 128) = *((unsigned char *)v61 + v30);
                      }
                    }
                    --v24;
                  }
                  while ((unint64_t)(v24 + 1) > 1);
                }
                else
                {
                  unsigned int v25 = 0;
                  int16x4_t v28 = v55;
                  uint64_t v27 = v52;
                  unsigned int v26 = v53;
                }
                if (v17 < 0 && *((unsigned char *)v60 + v27))
                {
                  *(_DWORD *)(a5 + 4 * v25) = v17;
                  *(unsigned char *)(a5 + v25++ + 128) = *((unsigned char *)v61 + v27);
                }
                unsigned int v39 = *v28;
                if (!*v28) {
                  goto LABEL_66;
                }
                unint64_t v40 = 0;
                do
                {
                  int v41 = *(_DWORD *)(v18 + 4 * v40) + v17;
                  if (v41 < 0 && *((unsigned char *)v60 + v40))
                  {
                    *(_DWORD *)(a5 + 4 * v25) = v41;
                    *(unsigned char *)(a5 + v25++ + 128) = *((unsigned char *)v61 + v40);
                    unsigned int v39 = *v28;
                  }
                  ++v40;
                }
                while (v40 < v39);
                if (v39)
                {
                  unsigned int v42 = 0;
                  uint64_t v43 = v39 - 1;
                  do
                  {
                    int v44 = *(_DWORD *)(v18 + 4 * v43) + v17;
                    if (v44 >= 1 && *((unsigned char *)v60 + v43))
                    {
                      *(_DWORD *)(a5 + 4 * v42 + 64) = v44;
                      *(unsigned char *)(a5 + v42++ + 144) = *((unsigned char *)v61 + v43);
                    }
                    unint64_t v45 = v43-- + 1;
                  }
                  while (v45 > 1);
                }
                else
                {
LABEL_66:
                  unsigned int v42 = 0;
                }
                if (v17 >= 1 && *((unsigned char *)v60 + v27))
                {
                  *(_DWORD *)(a5 + 4 * v42 + 64) = v17;
                  *(unsigned char *)(a5 + v42++ + 144) = *((unsigned char *)v61 + v27);
                }
                unsigned int v46 = *v54;
                if (*v54)
                {
                  unint64_t v47 = 0;
                  uint64_t v48 = a4 + 164 * v26 + 64;
                  do
                  {
                    int v49 = *(_DWORD *)(v48 + 4 * v47) + v17;
                    if (v49 >= 1)
                    {
                      uint64_t v50 = *v28;
                      if (*((unsigned char *)v60 + v50 + v47))
                      {
                        *(_DWORD *)(a5 + 4 * v42 + 64) = v49;
                        *(unsigned char *)(a5 + v42++ + 144) = *((unsigned char *)v61 + v50 + v47);
                        unsigned int v46 = *v54;
                      }
                    }
                    ++v47;
                  }
                  while (v47 < v46);
                }
                if (v42 + v25 < 0x10)
                {
                  uint64_t v10 = 0;
                  *(unsigned char *)(a5 + 160) = v25;
                  *(unsigned char *)(a5 + 161) = v42;
                  return v10;
                }
                goto LABEL_79;
              }
            }
          }
        }
        goto LABEL_79;
      }
    }
  }
  else
  {
LABEL_24:
    uint64_t v10 = hevcbridgeUEPullLong(a1, (unsigned int *)&v59 + 1);
    if (!v10)
    {
      uint64_t v10 = hevcbridgeUEPullLong(a1, (unsigned int *)&v59);
      if (!v10)
      {
        uint64_t v31 = HIDWORD(v59);
        if (HIDWORD(v59) < 0x10)
        {
          uint64_t v32 = v59;
          if (v59 < 0x10 && (v59 + HIDWORD(v59)) < 0x10)
          {
            *(unsigned char *)(a5 + 160) = BYTE4(v59);
            *(unsigned char *)(a5 + 161) = v32;
            if (v31)
            {
              uint64_t v33 = 0;
              while (1)
              {
                LODWORD(v61[0]) = 0;
                uint64_t v22 = hevcbridgeUEPullLong(a1, (unsigned int *)v61);
                if (v22) {
                  break;
                }
                LODWORD(v60[0]) = 0;
                uint64_t v22 = hevcbridgeUPull(a1, 1, v60);
                if (v22) {
                  break;
                }
                int v34 = v61[0];
                if (LODWORD(v61[0]) >= 0x8000) {
                  goto LABEL_79;
                }
                *(unsigned char *)(a5 + v33 + 128) = v60[0];
                if (v33) {
                  int v35 = *(_DWORD *)(a5 + 4 * v33 - 4) + ~v34;
                }
                else {
                  int v35 = ~v34;
                }
                *(_DWORD *)(a5 + 4 * v33++) = v35;
                if (v31 == v33) {
                  goto LABEL_38;
                }
              }
            }
            else
            {
LABEL_38:
              if (!v32) {
                return 0;
              }
              uint64_t v36 = 0;
              uint64_t v37 = a5 + 144;
              while (1)
              {
                LODWORD(v61[0]) = 0;
                uint64_t v22 = hevcbridgeUEPullLong(a1, (unsigned int *)v61);
                if (v22) {
                  break;
                }
                LODWORD(v60[0]) = 0;
                uint64_t v22 = hevcbridgeUPull(a1, 1, v60);
                if (v22) {
                  break;
                }
                int v38 = v61[0];
                if (LODWORD(v61[0]) >= 0x8000) {
                  goto LABEL_79;
                }
                *(unsigned char *)(v37 + v36) = v60[0];
                if (v36) {
                  v38 += *(_DWORD *)(v37 + 4 * v36 - 84);
                }
                uint64_t v10 = 0;
                *(_DWORD *)(v37 + 4 * v36++ - 80) = v38 + 1;
                if (v32 == v36) {
                  return v10;
                }
              }
            }
            return v22;
          }
        }
LABEL_79:
        uint64_t v10 = 4294954582;
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return v10;
}

uint64_t hevcbridgeParseVUIParameters(uint64_t a1, void *a2, unsigned int a3)
{
  __int16 v16 = 0;
  __int16 v15 = 0;
  __int16 v14 = 0;
  char v13 = 0;
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 44) & 1, 109, (unsigned char *)&v16 + 1);
  if (!result)
  {
    if (!HIBYTE(v16)) {
      goto LABEL_11;
    }
    unsigned int v12 = 0;
    uint64_t v7 = *(void *)((char *)a2 + 44);
    uint64_t result = hevcbridgeUPullLong(a1, 8, &v12);
    if ((v7 & 0x200000000000) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 110, v12, 0xFFFFFFFFLL);
    }
    if (!result)
    {
      if (v12 != 255
        || (uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 46) & 1, 111, 16),
            !result)
        && (uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 47) & 1, 112, 16),
            !result))
      {
LABEL_11:
        uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, *(_DWORD *)((unsigned char *)a2 + 50) & 1, 113, &v16);
        if (!result)
        {
          if (!(_BYTE)v16
            || (uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 49) & 1, 114),
                !result))
          {
            uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 50) & 1, 115, (unsigned char *)&v15 + 1);
            if (!result)
            {
              if (!HIBYTE(v15)
                || (char v11 = 0,
                    uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 51) & 1, 116, 3),
                    !result)
                && (uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 52) & 1, 117),
                    !result)
                && (uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 53) & 1, 118, &v11),
                    !result)
                && (!v11
                 || (uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 54) & 1, 119, 8),
                     !result)
                 && (uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 55) & 1, 120, 8),
                     !result)
                 && (uint64_t result = hevcbridgeUPullIfRequested(a1, a2, *(_DWORD *)((unsigned char *)a2 + 51) & 1, 121, 8),
                     !result)))
              {
                uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) & 0x200000000000000) != 0, 122, &v15);
                if (!result)
                {
                  if (!(_BYTE)v15
                    || (uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x400000000000000) != 0, 123), !result)&& (uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x800000000000000) != 0, 124), !result))
                  {
                    uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x1000000000000000) != 0, 125);
                    if (!result)
                    {
                      uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x2000000000000000) != 0, 126);
                      if (!result)
                      {
                        uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x4000000000000000) != 0, 127);
                        if (!result)
                        {
                          uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, *(void *)((char *)a2 + 44) >> 63, 128, (unsigned char *)&v14 + 1);
                          if (!result)
                          {
                            if (!HIBYTE(v14)
                              || (uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, *((_DWORD *)a2 + 13) & 1, 129),
                                  !result)
                              && (uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 1) & 1, 130),
                                  !result)
                              && (uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 2) & 1, 131),
                                  !result)
                              && (uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 3) & 1, 132),
                                  !result))
                            {
                              uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 4) & 1, 133, &v14);
                              if (!result)
                              {
                                if (!(_BYTE)v14) {
                                  goto LABEL_46;
                                }
                                char v10 = 0;
                                char v9 = 0;
                                uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 5) & 1, 134, 32);
                                if (!result)
                                {
                                  uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 6) & 1, 135, 32);
                                  if (!result)
                                  {
                                    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 7) & 1, 136, &v10);
                                    if (!result)
                                    {
                                      if (!v10
                                        || (uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, *(_DWORD *)((unsigned char *)a2 + 53) & 1, 137), !result))
                                      {
                                        uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 9) & 1, 138, &v9);
                                        if (!result)
                                        {
                                          if (!v9
                                            || (uint64_t result = hevcbridgeParseHRDParameters(a1, (uint64_t)a2, 1, a3),
                                                !result))
                                          {
LABEL_46:
                                            uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 10) & 1, 139, &v13);
                                            if (!result)
                                            {
                                              if (v13)
                                              {
                                                uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 11) & 1, 140);
                                                if (!result)
                                                {
                                                  uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 12) & 1, 141);
                                                  if (!result)
                                                  {
                                                    uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 13) & 1, 142);
                                                    if (!result)
                                                    {
                                                      uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 14) & 1, 143);
                                                      if (!result)
                                                      {
                                                        uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 15) & 1, 144);
                                                        if (!result)
                                                        {
                                                          uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, *(_DWORD *)((unsigned char *)a2 + 54) & 1, 145);
                                                          if (!result)
                                                          {
                                                            uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 17) & 1, 146);
                                                            if (!result)
                                                            {
                                                              int v8 = (*((_DWORD *)a2 + 13) >> 18) & 1;
                                                              return hevcbridgeUEPullIfRequested(a1, a2, v8, 147);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeSESkip(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 41)) {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  else {
    return hevcbridgeUESkip(a1);
  }
}

uint64_t hevcbridgeSEPullIfRequested(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  if (a3)
  {
    unsigned int v10 = 0;
    uint64_t result = hevcbridgeSEPullLong(a1, &v10);
    if (!result)
    {
      uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))a2[3];
      uint64_t v8 = *a2;
      uint64_t v9 = v10;
      return v7(v8, a4, v9, 0xFFFFFFFFLL);
    }
  }
  else
  {
    return hevcbridgeSESkip(a1);
  }
  return result;
}

uint64_t hevcbridgeParsePictureParameterSetMultilayerExtension(uint64_t a1, void *a2)
{
  char v20 = 0;
  unsigned int v19 = 0;
  __int16 v18 = 0;
  __int16 v17 = 0;
  unsigned int v16 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 49) & 1, 212);
  if (result) {
    return result;
  }
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 50) & 1, 213, &v20);
  if (result) {
    return result;
  }
  if (v20)
  {
    uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 51) & 1, 214, 6);
    if (result) {
      return result;
    }
  }
  uint64_t v5 = *(void *)((char *)a2 + 44);
  uint64_t result = hevcbridgeUEPullLong(a1, &v19);
  if ((v5 & 0x10000000000000) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 215, v19, 0xFFFFFFFFLL);
  }
  if (result) {
    return result;
  }
  unsigned int v6 = v19;
  if (v19 > 0x400) {
    goto LABEL_51;
  }
  if (!v19)
  {
LABEL_32:
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 5) & 1, 232, &v17);
    if (result) {
      return result;
    }
    if (!(_BYTE)v17) {
      return result;
    }
    uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 6) & 1, 233, &v16);
    if (result) {
      return result;
    }
    unsigned int v7 = v16;
    if (v16 <= 0x3D)
    {
      if (v16)
      {
        while (1)
        {
          uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 7) & 1, 234, 6);
          if (result) {
            break;
          }
          if (!--v7) {
            goto LABEL_39;
          }
        }
      }
      else
      {
LABEL_39:
        uint64_t result = hevcbridgeUPullAlways(a1, a2, *(_DWORD *)((unsigned char *)a2 + 53) & 1, 235, (_DWORD *)&v15 + 1, 2);
        if (!result)
        {
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 9) & 1, 236, &v15, 2);
          if (!result)
          {
            uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 10) & 1, 237, (unsigned int *)&v14 + 1);
            if (!result)
            {
              uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 11) & 1, 238);
              if (!result)
              {
                uint64_t result = hevcbridgeUEPullAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 12) & 1, 239, (unsigned int *)&v14);
                if (!result)
                {
                  uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 13) & 1, 240);
                  if (!result)
                  {
                    uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 14) & 1, 241, (_DWORD *)&v13 + 1, 2);
                    if (!result)
                    {
                      uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 15) & 1, 242, &v13, 2);
                      if (!result)
                      {
                        int v9 = v14;
                        int v8 = HIDWORD(v14);
                        int v11 = v13;
                        int v10 = HIDWORD(v13);
                        uint64_t v12 = HIDWORD(v15);
                        if (HIDWORD(v15) != 1
                          || (uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, *(_DWORD *)((unsigned char *)a2 + 54) & 1, 243),
                              !result)
                          && (uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 17) & 1, 244),
                              !result))
                        {
                          hevcBridgeParseColourMappingOctants(a1, a2, v12, v15, (v8 - (v9 + v10) + ~v11 + 10), 0, 0, 0, 0, 1 << v12);
                          return 0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
LABEL_51:
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return 4294954582;
  }
  while (1)
  {
    uint64_t result = hevcbridgeUPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 53) & 1, 216, 6);
    if (result) {
      return result;
    }
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) >> 54) & 1, 217, (unsigned char *)&v18 + 1);
    if (result) {
      return result;
    }
    if (HIBYTE(v18))
    {
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) >> 55) & 1, 218);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, *(_DWORD *)((unsigned char *)a2 + 51) & 1, 219);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x200000000000000) != 0, 220);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x400000000000000) != 0, 221);
      if (result) {
        return result;
      }
    }
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*(void *)((char *)a2 + 44) & 0x800000000000000) != 0, 222, &v18);
    if (result) {
      return result;
    }
    if ((_BYTE)v18)
    {
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x1000000000000000) != 0, 223);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x2000000000000000) != 0, 224);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, (*(void *)((char *)a2 + 44) & 0x4000000000000000) != 0, 225);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeSEPullIfRequested(a1, a2, *(void *)((char *)a2 + 44) >> 63, 226);
      if (result) {
        return result;
      }
    }
    uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, *((_DWORD *)a2 + 13) & 1, 227, (unsigned char *)&v17 + 1);
    if (result) {
      return result;
    }
    if (HIBYTE(v17))
    {
      uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 1) & 1, 228);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 2) & 1, 229);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 3) & 1, 230);
      if (result) {
        return result;
      }
      uint64_t result = hevcbridgeUEPullIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 4) & 1, 231);
      if (result) {
        return result;
      }
    }
    if (!--v6) {
      goto LABEL_32;
    }
  }
}

uint64_t hevcbridgeParsePictureParameterSetSCCExtension(uint64_t a1, uint64_t a2)
{
  __int16 v20 = 0;
  char v19 = 0;
  unsigned int v18 = 0;
  char v17 = 0;
  unsigned int v4 = *(uint64_t **)(a2 + 144);
  if (v4)
  {
    uint64_t v5 = *v4;
    if (!v5) {
      return 4294954583;
    }
    uint64_t v6 = v5 + 8;
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t result = hevcbridgeUPullFlagAlways(a1, (uint64_t *)a2, (*(_DWORD *)(a2 + 52) >> 23) & 1, 250, (unsigned char *)&v20 + 1);
  if (!result)
  {
    uint64_t result = hevcbridgeUPullFlagAlways(a1, (uint64_t *)a2, *(_DWORD *)(a2 + 55) & 1, 251, &v20);
    if (!result)
    {
      if (!(_BYTE)v20
        || (uint64_t result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t *)a2, (*(_DWORD *)(a2 + 52) >> 25) & 1, 252),
            !result)
        && (uint64_t result = hevcbridgeSEPullIfRequested(a1, (uint64_t *)a2, (*(_DWORD *)(a2 + 52) >> 26) & 1, 253),
            !result)
        && (uint64_t result = hevcbridgeSEPullIfRequested(a1, (uint64_t *)a2, (*(_DWORD *)(a2 + 52) >> 27) & 1, 254),
            !result)
        && (uint64_t result = hevcbridgeSEPullIfRequested(a1, (uint64_t *)a2, (*(_DWORD *)(a2 + 52) >> 28) & 1, 255),
            !result))
      {
        uint64_t result = hevcbridgeUPullFlagAlways(a1, (uint64_t *)a2, (*(_DWORD *)(a2 + 52) >> 29) & 1, 256, &v19);
        if (!result)
        {
          if (!v19) {
            goto LABEL_28;
          }
          unsigned int v15 = 0;
          unsigned int v16 = 0;
          uint64_t result = hevcbridgeUEPullAlways(a1, (uint64_t *)a2, (*(_DWORD *)(a2 + 52) >> 30) & 1, 257, &v18);
          if (result) {
            return result;
          }
          unsigned int v8 = v18;
          if (v18)
          {
            uint64_t result = hevcbridgeUPullFlagAlways(a1, (uint64_t *)a2, *(_DWORD *)(a2 + 52) >> 31, 258, &v17);
            if (!result)
            {
              uint64_t result = hevcbridgeUEPullAlways(a1, (uint64_t *)a2, *(_DWORD *)(a2 + 56) & 1, 259, &v16);
              if (!result)
              {
                if (v17)
                {
                  int v9 = 1;
                  int v10 = 8;
                }
                else
                {
                  uint64_t result = hevcbridgeUEPullAlways(a1, (uint64_t *)a2, (*(void *)(a2 + 52) >> 33) & 1, 260, &v15);
                  if (result) {
                    return result;
                  }
                  int v10 = v15 + 8;
                  int v9 = 3;
                }
                int v11 = 0;
                int v12 = v16 + 8;
LABEL_21:
                unsigned int v13 = v8;
                while (1)
                {
                  int v14 = v11 ? v10 : v12;
                  uint64_t result = hevcbridgeUPullIfRequested(a1, (uint64_t *)a2, (*(void *)(a2 + 52) >> 34) & 1, 261, v14);
                  if (result) {
                    break;
                  }
                  if (!--v13)
                  {
                    if (++v11 != v9) {
                      goto LABEL_21;
                    }
                    goto LABEL_28;
                  }
                }
              }
            }
          }
          else
          {
LABEL_28:
            uint64_t result = 0;
            if (v6) {
              *(unsigned char *)(v6 + 30) = HIBYTE(v20);
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL hevcbridgeMoreRBSPData(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v1 = *(_OWORD *)(a1 + 80);
  long long v12 = *(_OWORD *)(a1 + 64);
  long long v13 = v1;
  uint64_t v14 = *(void *)(a1 + 96);
  long long v2 = *(_OWORD *)(a1 + 48);
  long long v10 = *(_OWORD *)(a1 + 32);
  long long v11 = v2;
  long long v3 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v3;
  if (!BYTE9(v10) && !hevcbridgeUPull((uint64_t)v9, 1, &v8))
  {
    while (!BYTE9(v10))
    {
      int v7 = 0;
      int v5 = hevcbridgeUPull((uint64_t)v9, 8 - HIDWORD(v12), &v7);
      int v6 = v7 != 0;
      if (v5) {
        int v6 = 4;
      }
      if (v6) {
        return v6 != 4;
      }
    }
  }
  return 0;
}

uint64_t hevcbridgeSEPullLong(uint64_t a1, unsigned int *a2)
{
  unsigned int v5 = 0;
  if (*(unsigned char *)(a1 + 41))
  {
    uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    unsigned int v4 = 0;
  }
  else
  {
    uint64_t result = hevcbridgeUEPullLong(a1, &v5);
    unsigned int v4 = ((v5 + 1) >> 1) - ((v5 + 1) >> 1) * 2 * ((v5 + 1) & 1);
  }
  *a2 = v4;
  return result;
}

uint64_t hevcBridgeParseColourMappingOctants(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6, int a7, int a8, int a9, unsigned int a10)
{
  char v43 = 0;
  if (a6 >= a3) {
    goto LABEL_13;
  }
  uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 18) & 1, 245, &v43);
  if (result) {
    return result;
  }
  if (v43)
  {
    int v18 = 0;
    uint64_t v19 = a6 + 1;
    char v20 = 1;
    int v37 = a8;
    int v35 = a7;
LABEL_6:
    int v21 = 0;
    char v36 = v20;
    uint64_t v22 = a7 + (((v18 << a4) * a10) >> 1);
    char v23 = 1;
LABEL_7:
    int v24 = 0;
    char v38 = v23;
    uint64_t v25 = a8 + ((v21 * a10) >> 1);
    char v26 = 1;
    while (1)
    {
      char v27 = v26;
      LODWORD(v34) = a9 + ((v24 * a10) >> 1);
      HIDWORD(v34) = a10 >> 1;
      uint64_t result = hevcBridgeParseColourMappingOctants(a1, a2, a3, a4, a5, v19, v22, v25, v34);
      if (result) {
        break;
      }
      char v26 = 0;
      int v24 = 1;
      if ((v27 & 1) == 0)
      {
        char v23 = 0;
        int v21 = 1;
        a8 = v37;
        if (v38) {
          goto LABEL_7;
        }
        char v20 = 0;
        uint64_t result = 0;
        int v18 = 1;
        a7 = v35;
        if (v36) {
          goto LABEL_6;
        }
        return result;
      }
    }
  }
  else
  {
LABEL_13:
    int v28 = 0;
LABEL_14:
    int v29 = 0;
    while (1)
    {
      char v42 = 0;
      uint64_t result = hevcbridgeUPullFlagAlways(a1, a2, (*((_DWORD *)a2 + 13) >> 19) & 1, 246, &v42);
      if (result) {
        break;
      }
      if (v42)
      {
        int v30 = 3;
        do
        {
          unsigned int v40 = 0;
          unsigned int v41 = 0;
          uint64_t v31 = *(uint64_t *)((char *)a2 + 52);
          uint64_t result = hevcbridgeUEPullLong(a1, &v41);
          if ((v31 & 0x100000) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 247, v41, 0xFFFFFFFFLL);
          }
          if (result) {
            return result;
          }
          if (a5)
          {
            uint64_t v32 = *(uint64_t *)((char *)a2 + 52);
            uint64_t result = hevcbridgeUPullLong(a1, a5, &v40);
            if ((v32 & 0x200000) != 0 && !result) {
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 248, v40, 0xFFFFFFFFLL);
            }
            if (result) {
              return result;
            }
            unsigned int v33 = v40;
          }
          else
          {
            unsigned int v33 = 0;
          }
          if (v41 | v33)
          {
            uint64_t result = hevcbridgeUPullFlagIfRequested(a1, a2, (*((_DWORD *)a2 + 13) >> 22) & 1, 249);
            if (result) {
              return result;
            }
          }
        }
        while (--v30);
      }
      if (++v29 == 4)
      {
        uint64_t result = 0;
        if (!(++v28 >> a4)) {
          goto LABEL_14;
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeParseVPSForHVCCCallbackFlag(uint64_t a1, int a2, char a3)
{
  if (a2 == 309)
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 33) = a3;
  }
  else if (a2 == 8)
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 32) = a3;
  }
  else
  {
    return 4294954584;
  }
  return result;
}

uint64_t hevcbridgeParseVPSForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t v3 = 4294954584;
  if (a2 <= 307)
  {
    if (a2)
    {
      if (a2 != 3)
      {
        if (a2 != 7) {
          return v3;
        }
        ++a1;
      }
LABEL_14:
      *a1 = a3;
    }
    else if (a3 != 32)
    {
      return v3;
    }
    return 0;
  }
  switch(a2)
  {
    case 308:
      a1 += 2;
      goto LABEL_14;
    case 309:
      return v3;
    case 310:
      a1 += 3;
      goto LABEL_14;
    case 311:
      a1 += 4;
      goto LABEL_14;
    case 312:
      a1 += 5;
      goto LABEL_14;
    case 313:
      a1 += 6;
      goto LABEL_14;
    default:
      if (a2 == 328)
      {
        a1[7] = a3;
        uint64_t v3 = 1;
      }
      break;
  }
  return v3;
}

uint64_t hevcbridgeParseSPSForHVCCCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 139 || a2 == 108) {
    return a3 == 0;
  }
  else {
    return 4294954584;
  }
}

uint64_t hevcbridgeParseSPSForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t v3 = 4294954584;
  if (a2 <= 68)
  {
    if (a2)
    {
      if (a2 != 1) {
        return v3;
      }
LABEL_20:
      *a1 = a3;
    }
    else if (a3 != 33)
    {
      return v3;
    }
    return 0;
  }
  else
  {
    switch(a2)
    {
      case 'E':
        a1[1] = a3;
        if (!*a1) {
          return 0;
        }
        goto LABEL_10;
      case 'F':
      case 'G':
      case 'I':
      case 'L':
        return v3;
      case 'H':
        a1 += 2;
        goto LABEL_20;
      case 'J':
        a1 += 6;
        goto LABEL_20;
      case 'K':
        a1 += 7;
        goto LABEL_20;
      case 'M':
        a1 += 8;
        goto LABEL_20;
      case 'N':
        a1 += 9;
        goto LABEL_20;
      case 'O':
        a1 += 10;
        goto LABEL_20;
      case 'P':
        a1 += 11;
        goto LABEL_20;
      case 'Q':
        a1 += 3;
        goto LABEL_20;
      case 'R':
        a1 += 4;
        goto LABEL_20;
      default:
        if (a2 != 143) {
          return v3;
        }
        a1[5] = a3;
LABEL_10:
        uint64_t v3 = 1;
        break;
    }
  }
  return v3;
}

uint64_t hevcbridgeParsePPSForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  if (a2 == 163)
  {
    *a1 = a3;
    return 1;
  }
  else
  {
    if (a3 == 34) {
      unsigned int v3 = 0;
    }
    else {
      unsigned int v3 = -12712;
    }
    if (a2) {
      return 4294954584;
    }
    else {
      return v3;
    }
  }
}

uint64_t hevcbridgeParseSEIForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  if (a2 == 344)
  {
    *a1 = a3;
    return 1;
  }
  else
  {
    if ((a3 - 41) >= 0xFFFFFFFE) {
      unsigned int v3 = 0;
    }
    else {
      unsigned int v3 = -12712;
    }
    if (a2) {
      return 4294954584;
    }
    else {
      return v3;
    }
  }
}

uint64_t hevcbridgeParseSEIPayloadData(uint64_t a1, int a2, CFTypeRef cf)
{
  if (a2 != 347) {
    return 4294954584;
  }
  unsigned int v3 = *(const void **)(a1 + 16);
  *(void *)(a1 + 16) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v3) {
    CFRelease(v3);
  }
  return 1;
}

__CFData *hevcbridge_copyPatchedParameterSet(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int a5)
{
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFDataAppendBytes(Mutable, (const UInt8 *)(a1 + a2), a3);
  *(_WORD *)newBytes = bswap32(a4 & 0xFFFFFE07 | (8 * a5)) >> 16;
  v13.location = 0;
  v13.length = 2;
  CFDataReplaceBytes(Mutable, v13, newBytes, 2);
  return Mutable;
}

uint64_t hevcbridgeParseVDRRPUDataPayload(uint64_t a1, void *a2, unsigned int a3, unsigned int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10, uint64_t a11, uint64_t a12)
{
  int v18 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x1000040265AC83CuLL);
  uint64_t v19 = v18;
  if (!v18)
  {
    uint64_t v80 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_196:
    uint64_t v31 = v80;
    goto LABEL_197;
  }
  int v84 = 0;
  unsigned int v96 = 0;
  if (a5) {
    int v20 = 32;
  }
  else {
    int v20 = a6;
  }
  int v103 = v20;
  uint64_t v95 = a12 + 408;
  int v85 = a8;
  if (a8) {
    BOOL v21 = (a7 & 0x700) == 0;
  }
  else {
    BOOL v21 = 0;
  }
  if (a9) {
    BOOL v22 = (a7 & 0x700) == 0;
  }
  else {
    BOOL v22 = 0;
  }
  BOOL v88 = v22;
  BOOL v89 = v21;
  int v87 = a7 & 0x700 | a10;
  v93 = v18;
LABEL_12:
  int v94 = 0;
LABEL_13:
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  unsigned __int8 v105 = 0;
  unsigned int v100 = v96++;
  uint64_t v25 = (_DWORD *)(a12 + 420);
  uint64_t v26 = a12;
  while (2)
  {
    if (*(_DWORD *)(a11 + 4 * v24) > 0xFu)
    {
LABEL_192:
      uint64_t v81 = 4294954584;
LABEL_189:
      uint64_t v34 = FigSignalErrorAt(v81, 0, 0, 0, 0, 0, 0);
LABEL_190:
      uint64_t v31 = v34;
      if (!v34) {
        goto LABEL_178;
      }
      goto LABEL_197;
    }
    unint64_t v27 = 0;
    uint64_t v91 = v25;
    uint64_t v102 = v25;
    uint64_t v90 = v26;
    uint64_t v101 = v26;
    uint64_t v99 = v24;
LABEL_16:
    uint64_t v28 = v23;
    uint64_t v104 = 0;
    char v29 = *((unsigned char *)a2 + 100);
    uint64_t v30 = hevcbridgeUEPullLong(a1, (unsigned int *)&v104 + 1);
    uint64_t v31 = v30;
    if ((v29 & 1) != 0 && !v30) {
      uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 496, HIDWORD(v104), 0xFFFFFFFFLL);
    }
    if (v31) {
      goto LABEL_177;
    }
    int v32 = HIDWORD(v104);
    if (HIDWORD(v104) >= 0x10) {
      goto LABEL_192;
    }
    if (a12) {
      *(unsigned char *)(a12 + 316 - v24 + 16 * v24 + v27) = BYTE4(v104);
    }
    switch(v32)
    {
      case 0:
        unsigned int v33 = &v19[16 * v24 + v27];
        if (*v33)
        {
          uint64_t v34 = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 100) >> 1) & 1, 497, &v105);
          if (v34) {
            goto LABEL_190;
          }
          uint64_t v28 = v105;
          if (a12) {
            *(unsigned char *)(a12 - v24 + 16 * v24 + v27 + 361) = v105;
          }
          if (!v28) {
            goto LABEL_56;
          }
          if (*v33 < 2u)
          {
LABEL_51:
            unsigned int v37 = v19[16 * v24 + 48 + v27];
          }
          else
          {
            char v35 = *((unsigned char *)a2 + 100);
            uint64_t v36 = hevcbridgeUEPullLong(a1, (unsigned int *)&v104);
            uint64_t v31 = v36;
            if ((v35 & 4) != 0 && !v36) {
              uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 498, v104, 0xFFFFFFFFLL);
            }
            if (v31) {
              goto LABEL_177;
            }
            unsigned int v37 = v100 - v104 + 1;
            if (a12) {
              *(unsigned char *)(a12 - v24 + 16 * v24 + v27 + 24984) = v104;
            }
          }
LABEL_52:
          uint64_t v31 = 0;
          if ((v37 & 0x80000000) != 0) {
            goto LABEL_177;
          }
          uint64_t v23 = v28;
          if (v37 >= v100) {
            goto LABEL_177;
          }
LABEL_142:
          ++v27;
          v101 += 180;
          v102 += 13;
          if (v27 >= (*(_DWORD *)(a11 + 4 * v24) + 1))
          {
            ++v24;
            uint64_t v26 = v90 + 2700;
            uint64_t v25 = v91 + 195;
            if (v24 == 3) {
              goto LABEL_178;
            }
            continue;
          }
          goto LABEL_16;
        }
        unsigned __int8 v105 = 0;
LABEL_56:
        v97 = &v19[16 * v24 + v27];
        uint64_t v42 = *(unsigned int *)(a11 + 4 * v24);
        LODWORD(v107[1]) = 0;
        BYTE4(v106) = 0;
        __int16 v43 = *((_WORD *)a2 + 52);
        uint64_t v44 = hevcbridgeUEPullLong(a1, (unsigned int *)&v107[1]);
        uint64_t v31 = v44;
        if ((v43 & 1) != 0 && !v44) {
          uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 499, LODWORD(v107[1]), 0xFFFFFFFFLL);
        }
        if (v31) {
          goto LABEL_177;
        }
        int v45 = v107[1];
        if (a12) {
          *(unsigned char *)(v95 + 780 * v24 + 52 * v27) = v107[1];
        }
        if (!v45)
        {
          uint64_t v34 = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 104) >> 1) & 1, 500, (unsigned char *)&v106 + 4);
          if (!v34)
          {
            int v60 = BYTE4(v106);
            if (a12) {
              *(unsigned char *)(v95 + 780 * v24 + 52 * v27 + 1) = BYTE4(v106);
            }
            if (v60)
            {
              v107[0] = 0;
              if (!a5)
              {
                __int16 v74 = *((_WORD *)a2 + 52);
                uint64_t v75 = hevcbridgeUEPullLong(a1, (unsigned int *)v107);
                uint64_t v31 = v75;
                if ((v74 & 4) != 0)
                {
                  unsigned int v53 = &v19[16 * v24 + v27];
                  if (!v75) {
                    uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 501, LODWORD(v107[0]), 0xFFFFFFFFLL);
                  }
                  if (v31) {
                    goto LABEL_85;
                  }
                }
                else
                {
                  unsigned int v53 = &v19[16 * v24 + v27];
                  if (v75) {
                    goto LABEL_85;
                  }
                }
                if (a12) {
                  *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 4) = v107[0];
                }
              }
              __int16 v61 = *((_WORD *)a2 + 52);
              uint64_t v62 = hevcbridgeUPullLong(a1, v103, (_DWORD *)v107 + 1);
              uint64_t v31 = v62;
              if ((v61 & 8) != 0)
              {
                unsigned int v53 = &v19[16 * v24 + v27];
                if (!v62) {
                  uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 502, HIDWORD(v107[0]), 0xFFFFFFFFLL);
                }
                if (v31) {
                  goto LABEL_85;
                }
              }
              else
              {
                unsigned int v53 = &v19[16 * v24 + v27];
                if (v62) {
                  goto LABEL_85;
                }
              }
              if (a12) {
                *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 8) = HIDWORD(v107[0]);
              }
              if (v27 != v42)
              {
                uint64_t v31 = 0;
                goto LABEL_85;
              }
              if (!a5)
              {
                __int16 v78 = *((_WORD *)a2 + 52);
                uint64_t v79 = hevcbridgeUEPullLong(a1, (unsigned int *)v107);
                uint64_t v31 = v79;
                if ((v78 & 4) != 0)
                {
                  unsigned int v53 = &v19[16 * v24 + v27];
                  if (!v79) {
                    uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 501, LODWORD(v107[0]), 0xFFFFFFFFLL);
                  }
                  if (v31) {
                    goto LABEL_85;
                  }
                }
                else
                {
                  unsigned int v53 = &v19[16 * v24 + v27];
                  if (v79) {
                    goto LABEL_85;
                  }
                }
                if (a12) {
                  *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 4) = v107[0];
                }
              }
              __int16 v76 = *((_WORD *)a2 + 52);
              uint64_t v77 = hevcbridgeUPullLong(a1, v103, (_DWORD *)v107 + 1);
              uint64_t v31 = v77;
              if ((v76 & 8) != 0 && !v77) {
                uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 502, HIDWORD(v107[0]), 0xFFFFFFFFLL);
              }
              unsigned int v53 = &v19[16 * v24 + v27];
              if (a12 && !v31) {
                *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 8) = HIDWORD(v107[0]);
              }
              goto LABEL_85;
            }
            goto LABEL_63;
          }
          goto LABEL_190;
        }
LABEL_63:
        int v46 = 0;
        v107[0] = 0;
        uint64_t v47 = (v45 + 2);
        uint64_t v48 = v102;
        while (1)
        {
          __int16 v49 = *((_WORD *)a2 + 52);
          if (a5)
          {
            uint64_t v50 = hevcbridgeUPullLong(a1, 32, v107);
            uint64_t v31 = v50;
            if ((v49 & 0x20) != 0 && !v50) {
              uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 504, LODWORD(v107[0]), 0xFFFFFFFFLL);
            }
            if (v31) {
              goto LABEL_84;
            }
            if (!a12) {
              goto LABEL_82;
            }
            goto LABEL_81;
          }
          if ((v49 & 0x10) != 0) {
            break;
          }
LABEL_75:
          uint64_t v52 = hevcbridgeUPullLong(a1, a6, v107);
          uint64_t v31 = v52;
          if ((v49 & 0x20) != 0 && !v52) {
            uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 504, LODWORD(v107[0]), 0xFFFFFFFFLL);
          }
          if (v31) {
            goto LABEL_84;
          }
          if (!a12) {
            goto LABEL_82;
          }
          *uint64_t v48 = v46;
LABEL_81:
          v48[5] = v107[0];
LABEL_82:
          ++v48;
          if (!--v47)
          {
            uint64_t v31 = 0;
            goto LABEL_84;
          }
        }
        uint64_t v51 = hevcbridgeSEPullLong(a1, (unsigned int *)v107 + 1);
        if (!v51)
        {
          int v46 = HIDWORD(v107[0]);
          uint64_t v51 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[3])(*a2, 503, HIDWORD(v107[0]), 0xFFFFFFFFLL);
          if (!v51)
          {
            __int16 v49 = *((_WORD *)a2 + 52);
            goto LABEL_75;
          }
        }
        uint64_t v31 = v51;
LABEL_84:
        uint64_t v19 = v93;
        unsigned int v53 = v97;
        uint64_t v24 = v99;
LABEL_85:
        if (!v31)
        {
          uint64_t v54 = &v19[16 * v24 + v27];
          int v56 = v54[48];
          v55 = v54 + 48;
          if (!v56) {
LABEL_140:
          }
            unsigned char *v55 = v100;
          goto LABEL_141;
        }
LABEL_177:
        if (!v31)
        {
LABEL_178:
          if (v89)
          {
            uint64_t v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
            if (v80) {
              goto LABEL_196;
            }
          }
          if (v88)
          {
            uint64_t v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
            if (v80) {
              goto LABEL_196;
            }
          }
          if (!v87)
          {
            uint64_t v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
            if (v80) {
              goto LABEL_196;
            }
            if (v85)
            {
              uint64_t v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
              if (v80) {
                goto LABEL_196;
              }
            }
          }
          if (++v94 > a3)
          {
            if (++v84 > a4)
            {
              uint64_t v31 = 0;
              goto LABEL_197;
            }
            goto LABEL_12;
          }
          goto LABEL_13;
        }
LABEL_197:
        free(v19);
        return v31;
      case 1:
        char v38 = &v19[16 * v24 + v27];
        if (!*v38)
        {
          unsigned __int8 v105 = 0;
LABEL_89:
          uint64_t v98 = &v19[16 * v24 + v27];
          memset(v107, 0, 12);
          __int16 v57 = *((_WORD *)a2 + 52);
          uint64_t v58 = hevcbridgeUPullLong(a1, 2, &v107[1]);
          uint64_t v31 = v58;
          if ((v57 & 0x40) != 0 && !v58) {
            uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 505, LODWORD(v107[1]), 0xFFFFFFFFLL);
          }
          if (v31) {
            goto LABEL_176;
          }
          if (a12) {
            *(unsigned char *)(v95 + 2700 * v99 + 180 * v27) = v107[1];
          }
          if (!a5)
          {
            if ((a2[13] & 0x80) != 0)
            {
              uint64_t v63 = hevcbridgeSEPullLong(a1, (unsigned int *)v107 + 1);
              if (v63
                || (int v59 = HIDWORD(v107[0]),
                    uint64_t v63 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[3])(*a2, 506, HIDWORD(v107[0]), 0xFFFFFFFFLL), v63))
              {
LABEL_175:
                uint64_t v31 = v63;
LABEL_176:
                uint64_t v19 = v93;
                goto LABEL_177;
              }
            }
            else
            {
              int v59 = 0;
            }
            if (a12) {
              *(_DWORD *)(v95 + 2700 * v99 + 180 * v27 + 4) = v59;
            }
          }
          __int16 v64 = *((_WORD *)a2 + 52);
          uint64_t v65 = hevcbridgeUPullLong(a1, v103, v107);
          uint64_t v31 = v65;
          if ((v64 & 0x100) != 0 && !v65) {
            uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 507, LODWORD(v107[0]), 0xFFFFFFFFLL);
          }
          if (v31) {
            goto LABEL_176;
          }
          if (a12) {
            *(_DWORD *)(v95 + 2700 * v99 + 180 * v27 + 8) = v107[0];
          }
          if (LODWORD(v107[1]) != -1)
          {
            uint64_t v92 = (LODWORD(v107[1]) + 2);
            uint64_t v66 = v101;
            uint64_t v67 = 1;
            do
            {
              for (uint64_t i = 0; i != 28; i += 4)
              {
                uint64_t v106 = 0;
                if (!a5)
                {
                  if ((a2[13] & 0x200) != 0)
                  {
                    uint64_t v63 = hevcbridgeSEPullLong(a1, (unsigned int *)&v106 + 1);
                    if (v63) {
                      goto LABEL_175;
                    }
                    int v69 = HIDWORD(v106);
                    uint64_t v63 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[3])(*a2, 508, HIDWORD(v106), 0xFFFFFFFFLL);
                    if (v63) {
                      goto LABEL_175;
                    }
                  }
                  else
                  {
                    int v69 = 0;
                  }
                  if (a12) {
                    *(_DWORD *)(v66 + i + 448) = v69;
                  }
                }
                __int16 v70 = *((_WORD *)a2 + 52);
                uint64_t v71 = hevcbridgeUPullLong(a1, v103, &v106);
                uint64_t v31 = v71;
                if ((v70 & 0x400) != 0 && !v71) {
                  uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 509, v106, 0xFFFFFFFFLL);
                }
                if (!a12 || v31)
                {
                  if (v31) {
                    goto LABEL_176;
                  }
                }
                else
                {
                  *(_DWORD *)(v66 + i + 532) = v106;
                }
              }
              ++v67;
              v66 += 28;
            }
            while (v67 != v92);
          }
          uint64_t v19 = v93;
          uint64_t v24 = v99;
          unint64_t v72 = (unint64_t)&v93[16 * v99 + v27];
          int v73 = *(unsigned __int8 *)(v72 + 48);
          v55 = (unsigned char *)(v72 + 48);
          if (!v73)
          {
            unsigned int v53 = v98;
            goto LABEL_140;
          }
          unsigned int v53 = v98;
LABEL_141:
          uint64_t v23 = 0;
          ++*v53;
          goto LABEL_142;
        }
        uint64_t v34 = hevcbridgeUPullFlagAlways(a1, a2, (*((unsigned __int8 *)a2 + 100) >> 1) & 1, 497, &v105);
        if (v34) {
          goto LABEL_190;
        }
        uint64_t v28 = v105;
        if (a12) {
          *(unsigned char *)(a12 - v24 + 16 * v24 + v27 + 361) = v105;
        }
        if (!v28) {
          goto LABEL_89;
        }
        if (*v38 < 2u) {
          goto LABEL_51;
        }
        char v39 = *((unsigned char *)a2 + 100);
        uint64_t v40 = hevcbridgeUEPullLong(a1, (unsigned int *)&v104);
        uint64_t v31 = v40;
        if ((v39 & 4) != 0 && !v40) {
          uint64_t v31 = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 498, v104, 0xFFFFFFFFLL);
        }
        if (v31) {
          goto LABEL_177;
        }
        int v41 = v104;
        if (a12) {
          *(unsigned char *)(a12 - v24 + 16 * v24 + v27 + 24984) = v104;
        }
        unsigned int v37 = v96 - v41;
        goto LABEL_52;
      case 2:
      case 3:
        uint64_t v81 = 4294954579;
        goto LABEL_189;
      default:
        unsigned int v37 = 0;
        uint64_t v23 = 0;
        if (!v28) {
          goto LABEL_142;
        }
        goto LABEL_52;
    }
  }
}

uint64_t hevcbridgeParseVdrDmDataPayload(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  uint64_t v42 = 0;
  uint64_t v8 = *(uint64_t *)((char *)a2 + 92);
  uint64_t result = hevcbridgeUEPullLong(a1, (unsigned int *)&v42);
  if ((v8 & 1) != 0 && !result) {
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 460, v42, 0xFFFFFFFFLL);
  }
  if (!result)
  {
    unsigned int v41 = 0;
    uint64_t v10 = *(uint64_t *)((char *)a2 + 92);
    uint64_t result = hevcbridgeUEPullLong(a1, &v41);
    if ((v10 & 2) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 461, v41, 0xFFFFFFFFLL);
    }
    if (!result)
    {
      unsigned int v40 = 0;
      uint64_t v11 = *(uint64_t *)((char *)a2 + 92);
      uint64_t result = hevcbridgeUEPullLong(a1, &v40);
      if ((v11 & 4) != 0 && !result) {
        uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 462, v40, 0xFFFFFFFFLL);
      }
      if (!result)
      {
        if (!a3)
        {
          uint64_t v38 = 0;
          uint64_t v39 = 0;
          uint64_t v36 = 0;
          uint64_t v37 = 0;
          int v35 = 0;
          int v34 = 0;
          uint64_t v32 = 0;
          uint64_t v33 = 0;
          uint64_t v30 = 0;
          uint64_t v31 = 0;
          uint64_t v28 = 0;
          uint64_t v29 = 0;
          uint64_t v27 = 0;
          int v14 = (*((unsigned __int8 *)a2 + 92) >> 3) & 1;
          int v26 = 0;
          uint64_t result = hevcbridgeSPullAlways(a1, a2, v14, 463, (int *)&v39 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((unsigned __int8 *)a2 + 92) >> 4) & 1, 464, (int *)&v39, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((unsigned __int8 *)a2 + 92) >> 5) & 1, 465, (int *)&v38 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((unsigned __int8 *)a2 + 92) >> 6) & 1, 466, (int *)&v38, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, *((unsigned __int8 *)a2 + 92) >> 7, 467, (int *)&v37 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 8) & 1, 468, (int *)&v37, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 9) & 1, 469, (int *)&v36 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 10) & 1, 470, (int *)&v36, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 11) & 1, 471, &v35, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 12) & 1, 472, &v34, 32);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 13) & 1, 473, (_DWORD *)&v33 + 1, 32);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 14) & 1, 474, &v33, 32);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 15) & 1, 475, (int *)&v32 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, HIWORD(*((_DWORD *)a2 + 23)) & 1, 476, (int *)&v32, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 17) & 1, 477, (int *)&v31 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 18) & 1, 478, (int *)&v31, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 19) & 1, 479, (int *)&v30 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 20) & 1, 480, (int *)&v30, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 21) & 1, 481, (int *)&v29 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 22) & 1, 482, (int *)&v29, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeSPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 23) & 1, 483, (int *)&v28 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, HIBYTE(*((_DWORD *)a2 + 23)) & 1, 484, &v28, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 25) & 1, 485, (_DWORD *)&v27 + 1, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 26) & 1, 486, &v27, 16);
          if (result) {
            return result;
          }
          uint64_t result = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 27) & 1, 487, &v26, 32);
          if (result) {
            return result;
          }
          int v25 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          uint64_t v22 = 0;
          uint64_t v15 = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 28) & 1, 488, &v25, 5);
          if (v15) {
            return v15;
          }
          char v16 = v25;
          uint64_t v15 = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 29) & 1, 489, (_DWORD *)&v24 + 1, 2);
          if (v15) {
            return v15;
          }
          uint64_t v15 = hevcbridgeUPullAlways(a1, a2, (*((_DWORD *)a2 + 23) >> 30) & 1, 490, &v24, 2);
          if (v15) {
            return v15;
          }
          uint64_t v15 = hevcbridgeUPullAlways(a1, a2, *((_DWORD *)a2 + 23) >> 31, 491, (_DWORD *)&v23 + 1, 2);
          if (v15) {
            return v15;
          }
          uint64_t v15 = hevcbridgeUPullAlways(a1, a2, a2[12] & 1, 492, &v23, 12);
          if (v15) {
            return v15;
          }
          uint64_t v15 = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 92) >> 33) & 1, 493, (_DWORD *)&v22 + 1, 12);
          if (v15) {
            return v15;
          }
          uint64_t v15 = hevcbridgeUPullAlways(a1, a2, (*(unint64_t *)((char *)a2 + 92) >> 34) & 1, 494, &v22, 10);
          if (v15) {
            return v15;
          }
          if (a4)
          {
            *(_WORD *)(a4 + 29048) = WORD2(v39);
            *(_WORD *)(a4 + 29050) = v39;
            *(_WORD *)(a4 + 29052) = WORD2(v38);
            *(_WORD *)(a4 + 29054) = v38;
            *(_WORD *)(a4 + 29056) = WORD2(v37);
            *(_WORD *)(a4 + 29058) = v37;
            *(_WORD *)(a4 + 29060) = WORD2(v36);
            *(_WORD *)(a4 + 29062) = v36;
            *(_WORD *)(a4 + 29064) = v35;
            int v19 = HIDWORD(v33);
            *(_DWORD *)(a4 + 29068) = v34;
            *(_DWORD *)(a4 + 29072) = v19;
            *(_DWORD *)(a4 + 29076) = v33;
            *(_WORD *)(a4 + 29080) = WORD2(v32);
            *(_WORD *)(a4 + 29082) = v32;
            *(_WORD *)(a4 + 29084) = WORD2(v31);
            *(_WORD *)(a4 + 29086) = v31;
            *(_WORD *)(a4 + 29088) = WORD2(v30);
            *(_WORD *)(a4 + 29090) = v30;
            *(_WORD *)(a4 + 29092) = WORD2(v29);
            *(_WORD *)(a4 + 29094) = v29;
            *(_WORD *)(a4 + 29096) = WORD2(v28);
            *(_WORD *)(a4 + 29098) = v28;
            *(_WORD *)(a4 + 29100) = WORD2(v27);
            *(_WORD *)(a4 + 29102) = v27;
            *(_DWORD *)(a4 + 29104) = v26;
            *(unsigned char *)(a4 + 29108) = v16;
            *(unsigned char *)(a4 + 29109) = BYTE4(v24);
            *(unsigned char *)(a4 + 29110) = v24;
            *(unsigned char *)(a4 + 29111) = BYTE4(v23);
            *(_WORD *)(a4 + 29112) = v23;
            *(_WORD *)(a4 + 29114) = WORD2(v22);
            *(_WORD *)(a4 + 29116) = v22;
          }
        }
        uint64_t v12 = *(uint64_t *)((char *)a2 + 92);
        uint64_t result = hevcbridgeUEPullLong(a1, (unsigned int *)&v42 + 1);
        if ((v12 & 0x800000000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t))a2[2])(*a2, 495, HIDWORD(v42), 0xFFFFFFFFLL);
        }
        if (!result)
        {
          int v13 = HIDWORD(v42);
          if (HIDWORD(v42) < 0xFF)
          {
            if (a4)
            {
              *(unsigned char *)(a4 + 29118) = BYTE4(v42);
              *(unsigned char *)(a4 + 29044) = v42;
              *(unsigned char *)(a4 + 29045) = v41;
              *(unsigned char *)(a4 + 29046) = v40;
            }
            int v21 = 0;
            if (v13)
            {
              while (*(_DWORD *)(a1 + 76))
              {
                uint64_t result = hevcbridgeUPullLong(a1, 1, &v21);
                if (result) {
                  return result;
                }
                if (v21)
                {
LABEL_26:
                  FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                  return 4294954582;
                }
              }
              int v17 = v13;
              do
              {
                uint64_t result = hevcbridgeParseVdrDmDataPayloadExMetadatatBlocks((void *)a1, a2, 1, a4);
                if (result) {
                  return result;
                }
              }
              while (--v17);
            }
            uint64_t result = 0;
            unsigned int v20 = 0;
            if (*(void *)(a1 + 8) + *(void *)a1 - *(void *)(a1 + 56) < 6uLL) {
              return result;
            }
            uint64_t result = hevcbridgeUEPullAlways(a1, a2, *((unsigned char *)a2 + 124) & 1, 591, &v20);
            if (result) {
              return result;
            }
            unsigned int v18 = v20;
            if (v20 < 0xFF)
            {
              if (!v20) {
                return 0;
              }
              while (*(_DWORD *)(a1 + 76))
              {
                uint64_t result = hevcbridgeUPullLong(a1, 1, &v21);
                if (result) {
                  return result;
                }
                if (v21) {
                  goto LABEL_26;
                }
              }
              if (v18 + v13 <= 0xFF)
              {
                do
                {
                  uint64_t result = hevcbridgeParseVdrDmDataPayloadExMetadatatBlocks((void *)a1, a2, 2, a4);
                  if (result) {
                    break;
                  }
                  --v18;
                }
                while (v18);
                return result;
              }
            }
          }
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeSPullAlways(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, int *a5, int a6)
{
  if (*(unsigned char *)(a1 + 41))
  {
    uint64_t result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    int v14 = 0;
  }
  else
  {
    char v10 = a6;
    int v11 = *(_DWORD *)(a1 + 80);
    unsigned int v12 = v11 >> -(char)a6;
    uint64_t result = hevcbridgeAdvanceInBitstream(a1, a6);
    if (v11 >= 0) {
      int v14 = v12 & 0x7FFFFFF;
    }
    else {
      int v14 = v12 | (-1 << v10);
    }
  }
  *a5 = v14;
  if (a3 && !result)
  {
    uint64_t v15 = (uint64_t (*)(uint64_t, uint64_t))a2[3];
    uint64_t v16 = *a2;
    return v15(v16, a4);
  }
  return result;
}

uint64_t hevcbridgeParseVdrDmDataPayloadExMetadatatBlocks(void *a1, void *a2, int a3, uint64_t a4)
{
  if (a3 == 1)
  {
    uint64_t v55 = 0;
    char v7 = *((unsigned char *)a2 + 120);
    uint64_t result = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v55 + 1);
    if ((v7 & 1) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 512, HIDWORD(v55), 0xFFFFFFFFLL);
    }
    if (result) {
      return result;
    }
    char v9 = *((unsigned char *)a2 + 120);
    uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, &v55);
    if ((v9 & 2) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 513, v55, 0xFFFFFFFFLL);
    }
  }
  else
  {
    uint64_t v55 = 0;
    char v10 = *((unsigned char *)a2 + 124);
    uint64_t result = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v55 + 1);
    if ((v10 & 2) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 592, HIDWORD(v55), 0xFFFFFFFFLL);
    }
    if (result) {
      return result;
    }
    char v11 = *((unsigned char *)a2 + 124);
    uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, &v55);
    if ((v11 & 4) != 0 && !result) {
      uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 593, v55, 0xFFFFFFFFLL);
    }
  }
  if (result) {
    return result;
  }
  unsigned int v12 = HIDWORD(v55);
  if (HIDWORD(v55) >= 0x101 || v55 >= 0x100 || a1[1] + *a1 - a1[7] < (unint64_t)HIDWORD(v55))
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    unsigned int v13 = 0;
    switch((int)v55)
    {
      case 1:
        uint64_t v55 = 0;
        HIDWORD(v54) = 0;
        uint64_t v14 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
        if ((v14 & 1) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 514, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (!result)
        {
          uint64_t v15 = *(void *)((char *)a2 + 108);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
          if ((v15 & 2) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 515, v55, 0xFFFFFFFFLL);
          }
          if (!result)
          {
            uint64_t v16 = *(void *)((char *)a2 + 108);
            uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v54 + 1);
            if ((v16 & 4) != 0 && !result) {
              uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 516, HIDWORD(v54), 0xFFFFFFFFLL);
            }
            if (!result)
            {
              if (a4)
              {
                *(unsigned char *)(a4 + 29120) = 1;
                *(_WORD *)(a4 + 29132) = WORD2(v55);
                *(_WORD *)(a4 + 29134) = v55;
                *(_WORD *)(a4 + 29136) = WORD2(v54);
              }
              goto LABEL_115;
            }
          }
        }
        return result;
      case 2:
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        uint64_t v53 = 0;
        HIDWORD(v52) = 0;
        if (a4) {
          ++*(_DWORD *)(a4 + 29140);
        }
        uint64_t v26 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
        if ((v26 & 8) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 517, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (!result)
        {
          uint64_t v27 = *(void *)((char *)a2 + 108);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
          if ((v27 & 0x10) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 518, v55, 0xFFFFFFFFLL);
          }
          if (!result)
          {
            uint64_t v28 = *(void *)((char *)a2 + 108);
            uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v54 + 1);
            if ((v28 & 0x20) != 0 && !result) {
              uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 519, HIDWORD(v54), 0xFFFFFFFFLL);
            }
            if (!result)
            {
              uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int8 *)a2 + 108) >> 6) & 1, 520, &v54, 12);
              if (!result)
              {
                uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, *((unsigned __int8 *)a2 + 108) >> 7, 521, (_DWORD *)&v53 + 1, 12);
                if (!result)
                {
                  uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 8) & 1, 522, &v53, 12);
                  if (!result)
                  {
                    uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 9) & 1, 523, (int *)&v52 + 1, 13);
                    if (!result)
                    {
                      if (a4)
                      {
                        unsigned int v29 = *(_DWORD *)(a4 + 29140);
                        *(unsigned char *)(a4 + 29121) = 1;
                        uint64_t v30 = (_WORD *)(a4 + 14 * (int)(v29 - 1) + 29144);
                        *uint64_t v30 = WORD2(v55);
                        v30[1] = v55;
                        v30[2] = WORD2(v54);
                        v30[3] = v54;
                        v30[4] = WORD2(v53);
                        v30[5] = v53;
                        v30[6] = WORD2(v52);
                        if (v29 >= 8) {
                          unsigned int v29 = 8;
                        }
                        *(_DWORD *)(a4 + 29140) = v29;
                      }
                      unsigned int v13 = 85;
                      goto LABEL_194;
                    }
                  }
                }
              }
            }
          }
        }
        return result;
      case 3:
        uint64_t v55 = 0;
        HIDWORD(v54) = 0;
        uint64_t v31 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
        if ((v31 & 0x400) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 524, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (!result)
        {
          uint64_t v32 = *(void *)((char *)a2 + 108);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
          if ((v32 & 0x800) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 525, v55, 0xFFFFFFFFLL);
          }
          if (!result)
          {
            uint64_t v33 = *(void *)((char *)a2 + 108);
            uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v54 + 1);
            if ((v33 & 0x1000) != 0 && !result) {
              uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 526, HIDWORD(v54), 0xFFFFFFFFLL);
            }
            if (!result)
            {
              if (a4)
              {
                *(unsigned char *)(a4 + 29122) = 1;
                *(_WORD *)(a4 + 29256) = WORD2(v55);
                *(_WORD *)(a4 + 29258) = v55;
                *(_WORD *)(a4 + 29260) = WORD2(v54);
              }
LABEL_115:
              unsigned int v13 = 36;
              goto LABEL_194;
            }
          }
        }
        return result;
      case 4:
        uint64_t v55 = 0;
        uint64_t v24 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
        if ((v24 & 0x2000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 527, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (!result)
        {
          uint64_t v25 = *(void *)((char *)a2 + 108);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
          if ((v25 & 0x4000) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 528, v55, 0xFFFFFFFFLL);
          }
          if (!result)
          {
            if (a4)
            {
              *(unsigned char *)(a4 + 29123) = 1;
              *(_WORD *)(a4 + 29262) = WORD2(v55);
              *(_WORD *)(a4 + 29264) = v55;
            }
            unsigned int v13 = 24;
            goto LABEL_194;
          }
        }
        return result;
      case 5:
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        uint64_t v34 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 13, (_DWORD *)&v55 + 1);
        if ((v34 & 0x8000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 529, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (!result)
        {
          uint64_t v35 = *(void *)((char *)a2 + 108);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 13, &v55);
          if ((v35 & 0x10000) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 530, v55, 0xFFFFFFFFLL);
          }
          if (!result)
          {
            uint64_t v36 = *(void *)((char *)a2 + 108);
            uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 13, (_DWORD *)&v54 + 1);
            if ((v36 & 0x20000) != 0 && !result) {
              uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 531, HIDWORD(v54), 0xFFFFFFFFLL);
            }
            if (!result)
            {
              uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 18) & 1, 532, &v54, 13);
              if (!result)
              {
                if (a4)
                {
                  *(unsigned char *)(a4 + 29124) = 1;
                  *(_WORD *)(a4 + 29266) = WORD2(v55);
                  *(_WORD *)(a4 + 29268) = v55;
                  *(_WORD *)(a4 + 29270) = WORD2(v54);
                  *(_WORD *)(a4 + 29272) = v54;
                }
                unsigned int v13 = 52;
                goto LABEL_194;
              }
            }
          }
        }
        return result;
      case 6:
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        uint64_t v41 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 16, (_DWORD *)&v55 + 1);
        if ((v41 & 0x80000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 533, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (!result)
        {
          uint64_t v42 = *(void *)((char *)a2 + 108);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 16, &v55);
          if ((v42 & 0x100000) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 534, v55, 0xFFFFFFFFLL);
          }
          if (!result)
          {
            uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 21) & 1, 535, (_DWORD *)&v54 + 1, 16);
            if (!result)
            {
              uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 22) & 1, 536, &v54, 16);
              if (!result)
              {
                if (a4)
                {
                  *(unsigned char *)(a4 + 29125) = 1;
                  *(_WORD *)(a4 + 29274) = WORD2(v55);
                  *(_WORD *)(a4 + 29276) = v55;
                  *(_WORD *)(a4 + 29278) = WORD2(v54);
                  *(_WORD *)(a4 + 29280) = v54;
                }
                unsigned int v13 = 64;
                goto LABEL_194;
              }
            }
          }
        }
        return result;
      case 7:
        goto LABEL_194;
      case 8:
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        uint64_t v53 = 0;
        HIDWORD(v52) = 0;
        uint64_t v37 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
        if ((v37 & 0x800000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 537, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (result) {
          return result;
        }
        uint64_t v38 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
        if ((v38 & 0x1000000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 538, v55, 0xFFFFFFFFLL);
        }
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 25) & 1, 539, (_DWORD *)&v54 + 1, 12);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 26) & 1, 540, &v54, 12);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 27) & 1, 541, (_DWORD *)&v53 + 1, 12);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 28) & 1, 542, &v53, 12);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 29) & 1, 543, (_DWORD *)&v52 + 1, 12);
        if (result) {
          return result;
        }
        if (a4)
        {
          *(unsigned char *)(a4 + 29126) = 1;
          unsigned int v39 = *(_DWORD *)(a4 + 29284);
          uint64_t v40 = a4 + 36 * v39 + 29288;
          *(unsigned char *)(v40 + 4) = BYTE4(v55);
          *(_WORD *)(v40 + 6) = v55;
          *(_WORD *)(v40 + 8) = WORD2(v54);
          *(_WORD *)(v40 + 10) = v54;
          *(_WORD *)(v40 + 12) = WORD2(v53);
          *(_WORD *)(v40 + 14) = v53;
          *(_WORD *)(v40 + 16) = WORD2(v52);
          *(_DWORD *)uint64_t v40 = v12;
          if (v39 <= 4) {
            *(_DWORD *)(a4 + 29284) = v39 + 1;
          }
        }
        else
        {
          unsigned int v39 = 0;
        }
        if (v12 < 0xB)
        {
          unsigned int v13 = 80;
          goto LABEL_194;
        }
        LODWORD(v52) = 0;
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((_DWORD *)a2 + 27) >> 30) & 1, 544, &v52, 12);
        if (result) {
          return result;
        }
        if (a4) {
          *(_WORD *)(a4 + 36 * v39 + 29306) = v52;
        }
        if (v12 < 0xD)
        {
          unsigned int v13 = 92;
          goto LABEL_194;
        }
        LODWORD(v52) = 0;
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, *((_DWORD *)a2 + 27) >> 31, 545, &v52, 12);
        if (result) {
          return result;
        }
        if (a4) {
          *(_WORD *)(a4 + 36 * v39 + 29308) = v52;
        }
        if (v12 < 0xE)
        {
          unsigned int v13 = 104;
          goto LABEL_194;
        }
        LODWORD(v52) = 0;
        uint64_t v50 = 0;
        uint64_t v51 = 0;
        int v49 = 0;
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, a2[14] & 1, 546, &v52, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 33) & 1, 547, (_DWORD *)&v51 + 1, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 34) & 1, 548, &v51, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 35) & 1, 549, (_DWORD *)&v50 + 1, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 36) & 1, 550, &v50, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 37) & 1, 551, &v49, 8);
        if (result) {
          return result;
        }
        if (a4)
        {
          uint64_t v47 = (unsigned char *)(a4 + 36 * v39 + 29288);
          v47[22] = v52;
          v47[23] = BYTE4(v51);
          v47[24] = v51;
          v47[25] = BYTE4(v50);
          v47[26] = v50;
          v47[27] = v49;
        }
        if (v12 < 0x14)
        {
          unsigned int v13 = 152;
          goto LABEL_194;
        }
        LODWORD(v52) = 0;
        uint64_t v50 = 0;
        uint64_t v51 = 0;
        int v49 = 0;
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 38) & 1, 552, &v52, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 39) & 1, 553, (_DWORD *)&v51 + 1, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, *(_DWORD *)((unsigned char *)a2 + 113) & 1, 554, &v51, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 41) & 1, 555, (_DWORD *)&v50 + 1, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 42) & 1, 556, &v50, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 43) & 1, 557, &v49, 8);
        if (result) {
          return result;
        }
        if (a4)
        {
          uint64_t v48 = (unsigned char *)(a4 + 36 * v39 + 29288);
          v48[28] = v52;
          v48[29] = BYTE4(v51);
          v48[30] = v51;
          v48[31] = BYTE4(v50);
          v48[32] = v50;
          v48[33] = v49;
        }
        unsigned int v13 = 200;
        goto LABEL_194;
      case 9:
        HIDWORD(v55) = 0;
        uint64_t v18 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
        if ((v18 & 0x100000000000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 558, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (result) {
          return result;
        }
        if (a4)
        {
          *(unsigned char *)(a4 + 29127) = 1;
          unsigned int v19 = HIDWORD(v55);
          *(unsigned char *)(a4 + 29468) = BYTE4(v55);
        }
        else
        {
          unsigned int v19 = HIDWORD(v55);
        }
        if (v19 < 0x13)
        {
          unsigned int v13 = 8;
          goto LABEL_194;
        }
        LODWORD(v55) = 0;
        uint64_t v53 = 0;
        uint64_t v54 = 0;
        uint64_t v52 = 0;
        HIDWORD(v51) = 0;
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 45) & 1, 559, (int *)&v55, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 46) & 1, 560, (int *)&v54 + 1, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 47) & 1, 561, (int *)&v54, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, *(_DWORD *)((unsigned char *)a2 + 114) & 1, 562, (int *)&v53 + 1, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 49) & 1, 563, (int *)&v53, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 50) & 1, 564, (int *)&v52 + 1, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 51) & 1, 565, (int *)&v52, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 52) & 1, 566, (int *)&v51 + 1, 16);
        if (result) {
          return result;
        }
        if (a4)
        {
          *(_WORD *)(a4 + 29470) = v55;
          *(_WORD *)(a4 + 29472) = WORD2(v54);
          *(_WORD *)(a4 + 29474) = v54;
          *(_WORD *)(a4 + 29476) = WORD2(v53);
          *(_WORD *)(a4 + 29478) = v53;
          *(_WORD *)(a4 + 29480) = WORD2(v52);
          *(_WORD *)(a4 + 29482) = v52;
          *(_WORD *)(a4 + 29484) = WORD2(v51);
        }
        unsigned int v13 = 136;
        goto LABEL_194;
      case 10:
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        uint64_t v20 = *(void *)((char *)a2 + 108);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
        if ((v20 & 0x20000000000000) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 567, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 54) & 1, 568, &v55, 12);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) >> 55) & 1, 569, (_DWORD *)&v54 + 1, 12);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, *((unsigned char *)a2 + 115) & 1, 570, &v54, 8);
        if (result) {
          return result;
        }
        if (a4)
        {
          *(unsigned char *)(a4 + 29128) = 1;
          unsigned int v21 = *(_DWORD *)(a4 + 29488);
          if (v21 <= 3) {
            *(_DWORD *)(a4 + 29488) = v21 + 1;
          }
          uint64_t v22 = a4 + 28 * v21 + 29492;
          *(unsigned char *)(v22 + 4) = BYTE4(v55);
          *(_WORD *)(v22 + 6) = v55;
          *(_WORD *)(v22 + 8) = WORD2(v54);
          unsigned int v23 = v54;
          *(unsigned char *)(v22 + 10) = v54;
        }
        else
        {
          unsigned int v21 = 0;
          unsigned int v23 = v54;
        }
        if (v23 < 0x13)
        {
          unsigned int v13 = 40;
          goto LABEL_194;
        }
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        uint64_t v50 = 0;
        uint64_t v51 = 0;
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) & 0x200000000000000) != 0, 571, (int *)&v53 + 1, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) & 0x400000000000000) != 0, 572, (int *)&v53, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) & 0x800000000000000) != 0, 573, (int *)&v52 + 1, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) & 0x1000000000000000) != 0, 574, (int *)&v52, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) & 0x2000000000000000) != 0, 575, (int *)&v51 + 1, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, (*(void *)((char *)a2 + 108) & 0x4000000000000000) != 0, 576, (int *)&v51, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, *(void *)((char *)a2 + 108) >> 63, 577, (int *)&v50 + 1, 16);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeSPullAlways((uint64_t)a1, a2, *((_WORD *)a2 + 58) & 1, 578, (int *)&v50, 16);
        if (result) {
          return result;
        }
        if (a4)
        {
          int v46 = (_WORD *)(a4 + 28 * v21 + 29492);
          v46[6] = WORD2(v53);
          v46[7] = v53;
          v46[8] = WORD2(v52);
          v46[9] = v52;
          v46[10] = WORD2(v51);
          v46[11] = v51;
          v46[12] = WORD2(v50);
          v46[13] = v50;
        }
        unsigned int v13 = 168;
        goto LABEL_194;
      case 11:
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        __int16 v43 = *((_WORD *)a2 + 58);
        uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
        if ((v43 & 2) != 0 && !result) {
          uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 579, HIDWORD(v55), 0xFFFFFFFFLL);
        }
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 2) & 1, 580, &v55, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 3) & 1, 581, (_DWORD *)&v54 + 1, 8);
        if (result) {
          return result;
        }
        uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 4) & 1, 582, &v54, 8);
        if (result) {
          return result;
        }
        if (a4)
        {
          *(unsigned char *)(a4 + 29129) = 1;
          *(unsigned char *)(a4 + 29604) = BYTE4(v55);
          *(unsigned char *)(a4 + 29605) = v55;
          *(unsigned char *)(a4 + 29606) = BYTE4(v54);
          *(unsigned char *)(a4 + 29607) = v54;
        }
        unsigned int v13 = 32;
        goto LABEL_194;
      default:
        if (v55 == 254)
        {
          uint64_t v55 = 0;
          __int16 v44 = *((_WORD *)a2 + 58);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
          if ((v44 & 0x20) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 583, HIDWORD(v55), 0xFFFFFFFFLL);
          }
          if (!result)
          {
            uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 6) & 1, 584, &v55, 8);
            if (!result)
            {
              if (a4)
              {
                *(unsigned char *)(a4 + 29130) = 1;
                *(unsigned char *)(a4 + 29608) = BYTE4(v55);
                int v45 = v55;
                *(unsigned char *)(a4 + 29609) = v55;
                if (v45 == 2) {
                  *(unsigned char *)(a4 + 4) = 1;
                }
              }
              unsigned int v13 = 16;
              goto LABEL_194;
            }
          }
        }
        else
        {
          if (v55 != 255)
          {
LABEL_194:
            if (8 * v12 <= v13) {
              return 0;
            }
            return hevcbridgeUSkip((uint64_t)a1, 8 * v12 - v13);
          }
          uint64_t v54 = 0;
          uint64_t v55 = 0;
          uint64_t v53 = 0;
          __int16 v17 = *((_WORD *)a2 + 58);
          uint64_t result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
          if ((v17 & 0x80) != 0 && !result) {
            uint64_t result = ((uint64_t (*)(void, uint64_t, void, uint64_t))a2[2])(*a2, 585, HIDWORD(v55), 0xFFFFFFFFLL);
          }
          if (!result)
          {
            uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, *((unsigned char *)a2 + 117) & 1, 586, &v55, 8);
            if (!result)
            {
              uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 9) & 1, 587, (_DWORD *)&v54 + 1, 8);
              if (!result)
              {
                uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 10) & 1, 588, &v54, 8);
                if (!result)
                {
                  uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 11) & 1, 589, (_DWORD *)&v53 + 1, 8);
                  if (!result)
                  {
                    uint64_t result = hevcbridgeUPullAlways((uint64_t)a1, a2, (*((unsigned __int16 *)a2 + 58) >> 12) & 1, 590, &v53, 8);
                    if (!result)
                    {
                      if (a4)
                      {
                        *(unsigned char *)(a4 + 29131) = 1;
                        *(unsigned char *)(a4 + 29610) = BYTE4(v55);
                        *(unsigned char *)(a4 + 29611) = v55;
                        *(unsigned char *)(a4 + 29612) = BYTE4(v54);
                        *(unsigned char *)(a4 + 29613) = v54;
                        *(unsigned char *)(a4 + 29614) = BYTE4(v53);
                        *(unsigned char *)(a4 + 29615) = v53;
                      }
                      unsigned int v13 = 48;
                      goto LABEL_194;
                    }
                  }
                }
              }
            }
          }
        }
        break;
    }
  }
  return result;
}

uint64_t hevcbridgeSEPush(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 41))
  {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    BOOL v3 = a2 < 1;
    if (a2 >= 0) {
      int v4 = a2;
    }
    else {
      int v4 = -a2;
    }
    int v5 = 0;
    if (a2)
    {
      unsigned int v6 = v4;
      do
      {
        unsigned int v7 = v5++;
        if (v7 > 0x1D) {
          break;
        }
        BOOL v8 = v6 > 1;
        v6 >>= 1;
      }
      while (v8);
    }
    uint64_t result = hevcbridgeUPush((uint64_t *)a1, v5 + 1, 1);
    if (v5 && !result)
    {
      return hevcbridgeUPush((uint64_t *)a1, v5, (((2 * v4) | v3) - (1 << v5)) & ((1 << v5) - 1));
    }
  }
  return result;
}

uint64_t hevcbridgeIPush(uint64_t a1, char a2, int a3)
{
  if (*(unsigned char *)(a1 + 41) || 1 << (a2 - 1) <= a3 || -1 << (a2 - 1) > a3) {
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  else {
    return hevcbridgeUPush((uint64_t *)a1, a2, a3 & ~(-1 << a2));
  }
}

uint64_t hevcBridgeAlignToByte(uint64_t result)
{
  if (*(_DWORD *)(result + 76))
  {
    uint64_t v1 = result;
    do
      uint64_t result = hevcbridgeUPush((uint64_t *)v1, 1, 0);
    while (!result && *(_DWORD *)(v1 + 76));
  }
  return result;
}

CC_MD5_CTX *FigDigestMD5Create()
{
  v0 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x100004034A301B9uLL);
  uint64_t v1 = v0;
  if (v0) {
    CC_MD5_Init(v0);
  }
  return v1;
}

uint64_t FigDigestMD5GetDigest(CC_MD5_CTX *c, unsigned __int8 *md)
{
  return CC_MD5_Final(md, c);
}

CC_SHA1_CTX *FigDigestSHA1Create()
{
  v0 = (CC_SHA1_CTX *)malloc_type_malloc(0x60uLL, 0x1000040565EDBD2uLL);
  uint64_t v1 = v0;
  if (v0) {
    CC_SHA1_Init(v0);
  }
  return v1;
}

uint64_t FigDigestSHA1GetDigest(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  return CC_SHA1_Final(md, c);
}

uint64_t FigOSEventLinkRemoteCreateFromXPCObject(int a1, void *a2, const void *a3, const void *a4, uint64_t *a5)
{
  uint64_t v21 = 0;
  CFTypeRef cf = 0;
  if (!a2)
  {
    uint64_t v19 = 4294947875;
    goto LABEL_26;
  }
  if (!a3) {
    goto LABEL_21;
  }
  unsigned int v6 = a4;
  if (!a4)
  {
    uint64_t v17 = FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  if (MEMORY[0x192FC6B30](a2) != MEMORY[0x1E4F14590])
  {
LABEL_21:
    uint64_t v19 = 4294947875;
LABEL_26:
    uint64_t v17 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    LODWORD(v6) = 0;
    goto LABEL_15;
  }
  xpc_object_t value = xpc_dictionary_get_value(a2, "RemoteEventLinkCreationInfo");
  if (figOSEventLinkRemote_GetTypeID_sRegisterFigOSEventLinkRemoteTypeOnce != -1) {
    dispatch_once(&figOSEventLinkRemote_GetTypeID_sRegisterFigOSEventLinkRemoteTypeOnce, &__block_literal_global_37);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v19 = 4294947876;
    goto LABEL_26;
  }
  uint64_t v12 = Instance;
  uint64_t v13 = FigXPCMessageCopyBlockBufferUsingMemoryRecipient((const __CFAllocator *)*MEMORY[0x1E4F1CF80], value, "BlockBuffer", (uint64_t)v6, (CMBlockBufferRef *)&cf);
  if (v13
    || (uint64_t v13 = figOSEventLinkMemoryObjects_createInternal(a1, a3, v6, (CMBlockBufferRef)cf, &v21), v13))
  {
    uint64_t v17 = v13;
    uint64_t v15 = 0;
    LODWORD(v6) = 0;
    goto LABEL_31;
  }
  *(void *)(v12 + 16) = v21;
  LODWORD(v6) = xpc_dictionary_copy_mach_send();
  if (!v6)
  {
    uint64_t v20 = 4294947871;
LABEL_29:
    uint64_t v17 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    uint64_t v15 = 0;
    goto LABEL_31;
  }
  xpc_dictionary_get_string(value, "EventLinkIdentifier");
  uint64_t v14 = os_eventlink_create_with_port();
  if (!v14)
  {
    uint64_t v20 = 4294947873;
    goto LABEL_29;
  }
  uint64_t v15 = (void *)v14;
  uint64_t v16 = os_eventlink_activate();
  if (v16)
  {
    uint64_t v17 = v16;
  }
  else
  {
    uint64_t v17 = os_eventlink_associate();
    if (!v17)
    {
      *(void *)(v12 + 24) = v15;
      *(void *)(v12 + 32) = 0;
      *(_DWORD *)(v12 + 40) = 5;
      *a5 = v12;
LABEL_15:
      FigMachPortReleaseSendRight_((mach_port_name_t)v6, 0, 0, 0, 0);
      uint64_t v15 = 0;
      goto LABEL_16;
    }
  }
LABEL_31:
  FigMachPortReleaseSendRight_((mach_port_name_t)v6, 0, 0, 0, 0);
  CFRelease((CFTypeRef)v12);
LABEL_16:
  if (cf) {
    CFRelease(cf);
  }
  if (v15) {
    os_release(v15);
  }
  return v17;
}

uint64_t figOSEventLinkMemoryObjects_createInternal(int a1, const void *a2, const void *a3, CMBlockBufferRef theBuffer, uint64_t *a5)
{
  if (theBuffer)
  {
    size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (DataLength % *MEMORY[0x1E4F14B00])
    {
      uint64_t v19 = 4294947875;
    }
    else
    {
      size_t v10 = DataLength;
      if (figOSEventLinkMemoryObjects_GetTypeID_sRegisterFigOSEventLinkMemoryObjectsTypeOnce != -1) {
        dispatch_once(&figOSEventLinkMemoryObjects_GetTypeID_sRegisterFigOSEventLinkMemoryObjectsTypeOnce, &__block_literal_global_12_1);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v12 = Instance;
        if (a2) {
          CFTypeRef v13 = CFRetain(a2);
        }
        else {
          CFTypeRef v13 = 0;
        }
        *(void *)(v12 + 16) = v13;
        if (a3) {
          CFTypeRef v14 = CFRetain(a3);
        }
        else {
          CFTypeRef v14 = 0;
        }
        *(void *)(v12 + 24) = v14;
        uint64_t v15 = CMBlockBufferCreateWithBufferReference(0, theBuffer, 0, 0x20uLL, 0, (CMBlockBufferRef *)(v12 + 32));
        if (v15
          || (size_t v16 = (v10 - 32) >> 1,
              uint64_t v15 = CMBlockBufferCreateWithBufferReference(0, theBuffer, 0x20uLL, v16, 0, (CMBlockBufferRef *)(v12 + 40)), v15))
        {
          uint64_t v17 = v15;
        }
        else
        {
          uint64_t v17 = CMBlockBufferCreateWithBufferReference(0, theBuffer, v16 + 32, v16, 0, (CMBlockBufferRef *)(v12 + 48));
          if (!v17)
          {
            *a5 = v12;
            return v17;
          }
        }
        CFRelease((CFTypeRef)v12);
        return v17;
      }
      uint64_t v19 = 4294947876;
    }
  }
  else
  {
    uint64_t v19 = 4294947875;
  }

  return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
}

uint64_t FigOSEventLinkRemoteFillMessageBufferThenSendItAndHandleReply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dataPointerOut = 0;
  BOOL v13 = 0;
  FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt();
  if (*(unsigned char *)(a1 + 44))
  {
    uint64_t v12 = 4294947867;
    goto LABEL_19;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(*(void *)(a1 + 16) + 32), 0, 0, 0, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_20;
  }
  uint64_t DataPointer = (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, *(void *)(*(void *)(a1 + 16) + 40));
  if (DataPointer) {
    goto LABEL_20;
  }
  if (!FigAtomicCompareAndSwap32(0, 1u, (atomic_uint *)dataPointerOut + 3)) {
    goto LABEL_17;
  }
  *(_DWORD *)dataPointerOut = 1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(void *)(dataPointerOut + 4) = *(void *)(a1 + 36);
  *(void *)(a1 + 36) = 0x500000000;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  unsigned int v7 = os_eventlink_signal_and_wait();
  if (v7 == 89) {
    uint64_t v8 = 4294947868;
  }
  else {
    uint64_t v8 = v7;
  }
  if (v8) {
    goto LABEL_21;
  }
  uint64_t v9 = figOSEventLinkResolveMessageStatus((atomic_uint *)dataPointerOut + 3, &v13);
  BOOL v10 = v13;
  if (v9)
  {
    uint64_t v8 = v9;
    goto LABEL_16;
  }
  if (!v13)
  {
LABEL_17:
    uint64_t v12 = 4294947872;
LABEL_19:
    uint64_t DataPointer = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
LABEL_20:
    uint64_t v8 = DataPointer;
LABEL_21:
    BOOL v10 = 0;
    goto LABEL_16;
  }
  if (FigAtomicCompareAndSwap32(1, 2u, (atomic_uint *)dataPointerOut + 5))
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(a3 + 16))(a3, *(void *)(*(void *)(a1 + 16) + 48));
    if (!v8) {
      uint64_t v8 = *((unsigned int *)dataPointerOut + 4);
    }
    *((_DWORD *)dataPointerOut + 3) = 0;
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
  }
  BOOL v10 = 1;
LABEL_16:
  FigMemoryOriginCompleteTransaction(!v10);
  return v8;
}

uint64_t figOSEventLinkResolveMessageStatus(atomic_uint *a1, BOOL *a2)
{
  while (1)
  {
    BOOL v4 = FigAtomicCompareAndSwap32(2, 2u, a1);
    BOOL v5 = v4;
    if (v4)
    {
LABEL_4:
      uint64_t result = 0;
      goto LABEL_6;
    }
    if ((*a1 - 1) >= 2) {
      break;
    }
    if (FigAtomicCompareAndSwap32(1, 3u, a1)) {
      goto LABEL_4;
    }
  }
  uint64_t result = FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
LABEL_6:
  *a2 = v5;
  return result;
}

uint64_t FigOSEventLinkRemoteInvalidate(uint64_t a1)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 44))
    {
      *(unsigned char *)(a1 + 44) = 1;
      os_eventlink_cancel();
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigOSEventLinkRemoteSetMessageHandlingThreadMachThreadPriority(os_unfair_lock_s *a1, uint32_t a2)
{
  if (a1 && a2 - 98 > 0xFFFFFF9E)
  {
    BOOL v4 = a1 + 8;
    os_unfair_lock_lock(a1 + 8);
    a1[9]._os_unfair_lock_opaque = a2;
    a1[10]._os_unfair_lock_opaque = 5;
    os_unfair_lock_unlock(v4);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigOSEventLinkRemoteSetMessageHandlingThreadFigThreadPriority(os_unfair_lock_s *a1, unsigned int a2)
{
  if (!a1 || a2 == 5 || a2 >= 0x31)
  {
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    BOOL v4 = a1 + 8;
    os_unfair_lock_lock(a1 + 8);
    a1[9]._os_unfair_lock_opaque = 0;
    a1[10]._os_unfair_lock_opaque = a2;
    os_unfair_lock_unlock(v4);
    return 0;
  }
}

uint64_t FigOSEventLinkServerCreate(int a1, unsigned int a2, int a3, const __CFString *a4, uint64_t a5, const void *a6, const void *a7, const void *a8, void *a9)
{
  CFTypeRef cf = 0;
  pthread_t v30 = 0;
  uint64_t v28 = 0;
  if (!a7)
  {
    uint64_t v27 = 4294947875;
    goto LABEL_28;
  }
  if (!a8 || !a6) {
    goto LABEL_24;
  }
  CFStringRef v11 = a4;
  if (!a4)
  {
    uint64_t v25 = FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  if (a2 == 5 && !a3)
  {
LABEL_24:
    uint64_t v27 = 4294947875;
LABEL_28:
    uint64_t v25 = FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
    CFStringRef v11 = 0;
    goto LABEL_19;
  }
  if (figOSEventLinkServer_GetTypeID_sRegisterFigOSEventLinkServerTypeOnce != -1) {
    dispatch_once(&figOSEventLinkServer_GetTypeID_sRegisterFigOSEventLinkServerTypeOnce, &__block_literal_global_19_0);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v27 = 4294947876;
    goto LABEL_28;
  }
  uint64_t v18 = (void *)Instance;
  uint64_t BlockBuffer = (uint64_t)FigMemoryPoolCreateBlockBuffer((uint64_t)a6, *MEMORY[0x1E4F14B00], (CMBlockBufferRef *)&cf, v17);
  if (!BlockBuffer)
  {
    uint64_t BlockBuffer = figOSEventLinkMemoryObjects_createInternal(a1, a7, a8, (CMBlockBufferRef)cf, &v28);
    if (!BlockBuffer)
    {
      v18[3] = v28;
      uint64_t v28 = 0;
      CFTypeRef v20 = CFRetain(a6);
      v18[4] = cf;
      v18[5] = v20;
      CFTypeRef cf = 0;
      v18[10] = CFRetain(v11);
      CFStringGetCStringPtr(v11, 0x8000100u);
      uint64_t v21 = os_eventlink_create();
      if (v21)
      {
        uint64_t v22 = v21;
        uint64_t BlockBuffer = os_eventlink_activate();
        if (!BlockBuffer)
        {
          v18[6] = v22;
          CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFStringRef v11 = CFStringCreateWithFormat(v23, 0, @"%@.%p", v11, v22);
          CFDictionarySetValue(Mutable, @"com.apple.fig.ThreadCreateKey_Identifier", v11);
          if (a3) {
            FigCFDictionarySetInt32(Mutable, @"com.apple.fig.ThreadCreateKey_MachThreadPriority", a3);
          }
          uint64_t v25 = FigThreadCreate((uint64_t)FigOSEventLinkServerMain, (uint64_t)v18, a2, 0, Mutable, &v30);
          if (!v25)
          {
            CFRetain(v18);
            *a9 = v18;
            if (!Mutable) {
              goto LABEL_19;
            }
            goto LABEL_18;
          }
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t BlockBuffer = FigSignalErrorAt(4294947873, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  uint64_t v25 = BlockBuffer;
  Mutable = 0;
  CFStringRef v11 = 0;
LABEL_31:
  CFRelease(v18);
  if (Mutable) {
LABEL_18:
  }
    CFRelease(Mutable);
LABEL_19:
  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v25;
}

uint64_t FigOSEventLinkServerMain(void *a1)
{
  uint64_t v19 = 0;
  if (!os_eventlink_associate()
    && !os_eventlink_wait()
    && !CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1[3] + 32), 0, 0, 0, &v19))
  {
    int v2 = 0;
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      if (v2) {
        goto LABEL_37;
      }
      if (!a1[8])
      {
        FigSignalErrorAt(4294947871, 0, 0, 0, 0, 0, 0);
        goto LABEL_37;
      }
      BOOL v4 = v19;
      if (*(_DWORD *)v19 == 1) {
        break;
      }
      if (*(_DWORD *)v19)
      {
        int v14 = 0;
LABEL_28:
        int v2 = 0;
        if (v14) {
          goto LABEL_37;
        }
      }
      else
      {
        *((_DWORD *)v19 + 4) = 0;
        int v5 = os_eventlink_signal();
        int v2 = 1;
        if (v5) {
          goto LABEL_37;
        }
      }
    }
    if (FigAtomicCompareAndSwap32(1, 2u, (atomic_uint *)v19 + 3))
    {
      int v6 = *((_DWORD *)v4 + 1);
      if (v6 > 0) {
        goto LABEL_13;
      }
      if (*((_DWORD *)v4 + 2) != 5)
      {
        if (!v6)
        {
          CFNumberRef UInt32 = FigCFNumberCreateUInt32(v3, *((_DWORD *)v4 + 2));
          uint64_t v8 = (const void **)&kFigThreadPropertyKey_Priority;
          goto LABEL_14;
        }
LABEL_13:
        CFNumberRef UInt32 = FigCFNumberCreateSInt32(v3, v6);
        uint64_t v8 = (const void **)&kFigThreadPropertyKey_MachThreadPriority;
LABEL_14:
        uint64_t v9 = *v8;
        Current = FigThreadGetCurrent();
        FigThreadSetProperty(Current, v9, UInt32);
        if (UInt32) {
          CFRelease(UInt32);
        }
        *(void *)(v4 + 4) = 0x500000000;
      }
    }
    else
    {
      FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
    }
    CFStringRef v11 = v19;
    FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt();
    if (!FigAtomicCompareAndSwap32(0, 1u, (atomic_uint *)v11 + 5)) {
      FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v12 = v19;
    if (*((_DWORD *)v19 + 3) == 2) {
      int v13 = ((uint64_t (*)(void *, void, void, void))a1[8])(a1, 0, *(void *)(a1[3] + 40), *(void *)(a1[3] + 48));
    }
    else {
      int v13 = FigSignalErrorAt(4294947870, 0, 0, 0, 0, 0, 0);
    }
    int v14 = v13;
    *((_DWORD *)v12 + 4) = v13;
    if (!v13) {
      int v14 = os_eventlink_signal_and_wait();
    }
    BOOL v20 = 0;
    uint64_t v15 = v19 + 20;
    int v16 = figOSEventLinkResolveMessageStatus((atomic_uint *)v19 + 5, &v20);
    BOOL v17 = v20;
    if (!v16)
    {
      if (v20) {
        *(_DWORD *)uint64_t v15 = 0;
      }
      else {
        FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
      }
    }
    FigMemoryOriginCompleteTransaction(!v17);
    goto LABEL_28;
  }
LABEL_37:
  os_eventlink_cancel();
  CFRelease(a1);
  return 0;
}

uint64_t FigOSEventLinkServerCopyRemoteCreationInfoXPCObject(uint64_t a1, void *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  uint64_t v5 = FigMemoryOriginSetBlockBufferInXPCMessage(*(void *)(*(void *)(a1 + 24) + 16), v4, "BlockBuffer", *(OpaqueCMBlockBuffer **)(a1 + 32));
  if (v5)
  {
    uint64_t remote_port = v5;
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 80), 0x8000100u);
    xpc_dictionary_set_string(v4, "EventLinkIdentifier", CStringPtr);
    uint64_t remote_port = os_eventlink_extract_remote_port();
    if (!remote_port)
    {
      xpc_dictionary_set_mach_send();
      *a2 = v4;
      xpc_object_t v4 = 0;
    }
  }
  FigMachPortReleaseSendRight_(0, 0, 0, 0, 0);
  FigXPCRelease(v4);
  return remote_port;
}

uint64_t FigOSEventLinkServerSetCallbacks(void *a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    a1[7] = *a3;
    a1[8] = a3[1];
    int v6 = (const void *)a1[9];
    if (v6)
    {
      CFRelease(v6);
      a1[9] = 0;
    }
    if (a2) {
      a1[9] = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigOSEventLinkServerSetAssociatedFigXPCServerXPCConnection(uint64_t a1, void *a2)
{
  if (a1)
  {
    if (a2)
    {
      if (!*(void *)(a1 + 16))
      {
        *(void *)(a1 + 16) = FigXPCRetain(a2);
        return 0;
      }
      uint64_t v3 = 4294947872;
    }
    else
    {
      uint64_t v3 = 4294947875;
    }
  }
  else
  {
    uint64_t v3 = 4294947875;
  }

  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

uint64_t FigOSEventLinkServerGetAssociatedFigXPCServerXPCConnection(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 16);
  }
  FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  return 0;
}

double figOSEventLinkRemote_Init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figOSEventLinkRemote_Finalize(uint64_t a1)
{
  dataPointerOut = 0;
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 && (uint64_t v3 = *(OpaqueCMBlockBuffer **)(v2 + 32)) != 0 && *(void *)(a1 + 24))
  {
    if (!CMBlockBufferGetDataPointer(v3, 0, 0, 0, &dataPointerOut))
    {
      *(_DWORD *)dataPointerOut = 0;
      os_eventlink_signal_and_wait();
    }
  }
  else
  {
    FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
  }
  xpc_object_t v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16) = 0;
  }
  if (*(void *)(a1 + 24))
  {
    os_eventlink_cancel();
    uint64_t v5 = *(void **)(a1 + 24);
    if (v5)
    {
      os_release(v5);
      *(void *)(a1 + 24) = 0;
    }
  }
}

__CFString *figOSEventLinkRemote_CopyDebugDesc(uint64_t a1)
{
  Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = *(OpaqueCMBlockBuffer **)(*(void *)(a1 + 16) + 40);
  size_t DataLength = CMBlockBufferGetDataLength(v3);
  uint64_t v5 = *(OpaqueCMBlockBuffer **)(*(void *)(a1 + 16) + 48);
  size_t v6 = CMBlockBufferGetDataLength(v5);
  CFStringAppendFormat(Mutable, 0, @"<FigOSEventLinkRemote %p sharedMessageBBuf %p (size %zu) sharedReplyBBuf %p (size %zu)>", a1, v3, DataLength, v5, v6);
  return Mutable;
}

double figOSEventLinkMemoryObjects_Init(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figOSEventLinkMemoryObjects_Finalize(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  xpc_object_t v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  uint64_t v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
  size_t v6 = (const void *)a1[6];
  if (v6)
  {
    CFRelease(v6);
    a1[6] = 0;
  }
}

__CFString *figOSEventLinkMemoryObjects_CopyDebugDesc(uint64_t a1)
{
  Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = *(OpaqueCMBlockBuffer **)(a1 + 40);
  size_t DataLength = CMBlockBufferGetDataLength(v3);
  uint64_t v5 = *(OpaqueCMBlockBuffer **)(a1 + 48);
  size_t v6 = CMBlockBufferGetDataLength(v5);
  CFStringAppendFormat(Mutable, 0, @"<FigOSEventLinkMemoryObjects %p sharedMessageBBuf %p (size %zu) sharedReplyBBuf %p (size %zu)>", a1, v3, DataLength, v5, v6);
  return Mutable;
}

double figOSEventLinkServer_Init(uint64_t a1)
{
  *(void *)(a1 + 80) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figOSEventLinkServer_Finalize(void *a1)
{
  uint64_t v2 = (const void *)a1[5];
  if (v2)
  {
    CFRelease(v2);
    a1[5] = 0;
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  xpc_object_t v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
    a1[3] = 0;
  }
  uint64_t v5 = (void *)a1[6];
  if (v5)
  {
    os_release(v5);
    a1[6] = 0;
  }
  size_t v6 = (void *)a1[2];
  if (v6)
  {
    os_release(v6);
    a1[2] = 0;
  }
  unsigned int v7 = (const void *)a1[9];
  if (v7)
  {
    CFRelease(v7);
    a1[9] = 0;
  }
  uint64_t v8 = (const void *)a1[10];
  if (v8)
  {
    CFRelease(v8);
    a1[10] = 0;
  }
}

__CFString *figOSEventLinkServer_CopyDebugDesc(uint64_t a1)
{
  Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = *(OpaqueCMBlockBuffer **)(*(void *)(a1 + 24) + 40);
  size_t DataLength = CMBlockBufferGetDataLength(v3);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v5 + 48);
  size_t v7 = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(v5 + 40));
  CFStringAppendFormat(Mutable, 0, @"<FigOSEventLinkServer %p sharedMessageBBuf %p (size %zu) sharedReplyBBuf %p (size %zu)>", a1, v3, DataLength, v6, v7);
  return Mutable;
}

uint64_t FigPreferAudioSessionOverCMSession()
{
  if (FigPreferAudioSessionOverCMSession_onceToken != -1) {
    dispatch_once(&FigPreferAudioSessionOverCMSession_onceToken, &__block_literal_global_38);
  }
  return 1;
}

uint64_t __FigPreferAudioSessionOverCMSession_block_invoke()
{
  return _os_feature_enabled_impl();
}

uint64_t FigCaptionGroupFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigCaptionGroupFormatDescriptionRegisterOnce, (void (*)(void))FigCaptionGroupFormatDescriptionRegisterOnce);
}

uint64_t FigCaptionGroupFormatDescriptionRegisterOnce()
{
  int v1 = 0;
  uint64_t v5 = figCaptionGroupFormatDescriptionFinalize;
  xpc_object_t v4 = figCaptionGroupFormatDescriptionCopyDebugDesc;
  uint64_t v2 = 4;
  uint64_t v3 = figCaptionGroupFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x63706772u, (long long *)&v1);
}

uint64_t FigCaptionGroupFormatDescriptionCreate(const __CFAllocator *a1, int a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a3)
  {
    FigThreadRunOnce(&sFigCaptionGroupFormatDescriptionRegisterOnce, (void (*)(void))FigCaptionGroupFormatDescriptionRegisterOnce);
    uint64_t v6 = FigDerivedFormatDescriptionCreate(a1, (void *)0x63706772, a2, 0, (uint64_t *)&cf);
    if (v6)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf) = a2;
      *a3 = cf;
    }
    return v6;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

__CFString *figCaptionGroupFormatDescriptionCopyDebugDesc(const void *a1)
{
  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, @"\t\tsubType: '%c%c%c%c'", HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  return Mutable;
}

BOOL figCaptionGroupFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a1);
  return *DerivedStorage == *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a2);
}

uint64_t FigTaggedBufferGroupGetTypeID()
{
  if (CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce != -1) {
    dispatch_once(&CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce, &__block_literal_global_39);
  }
  return CMTaggedBufferGroupGetTypeID_sTaggedBufferGroupTypeID;
}

CFTypeID CMTaggedBufferGroupGetTypeID(void)
{
  if (CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce != -1) {
    dispatch_once(&CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce, &__block_literal_global_39);
  }
  return CMTaggedBufferGroupGetTypeID_sTaggedBufferGroupTypeID;
}

uint64_t __CMTaggedBufferGroupGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CMTaggedBufferGroupGetTypeID_sTaggedBufferGroupTypeID = result;
  return result;
}

uint64_t taggedBufferGroup_init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void taggedBufferGroup_finalize(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 16) >= 1)
  {
    uint64_t v2 = 0;
    CFAllocatorRef v3 = (CFTypeRef *)(a1 + 32);
    do
    {
      xpc_object_t v4 = *(v3 - 1);
      if (v4)
      {
        CFRelease(v4);
        *(v3 - 1) = 0;
      }
      if (*v3)
      {
        CFRelease(*v3);
        *CFAllocatorRef v3 = 0;
      }
      ++v2;
      v3 += 2;
    }
    while (v2 < *(void *)(a1 + 16));
  }
}

uint64_t taggedBufferGroup_equal(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (v3 < 1) {
    return 1;
  }
  uint64_t v4 = 0;
  uint64_t v5 = (CFTypeRef *)(a1 + 32);
  for (uint64_t i = (CFTypeRef *)(a2 + 32); ; i += 2)
  {
    uint64_t result = CFEqual(*(v5 - 1), *(i - 1));
    if (!result) {
      break;
    }
    uint64_t result = CFEqual(*v5, *i);
    if (!result) {
      break;
    }
    ++v4;
    v5 += 2;
    if (v4 >= *(void *)(a1 + 16)) {
      return 1;
    }
  }
  return result;
}

CFHashCode taggedBufferGroup_hash(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 16) < 1) {
    return 0;
  }
  CFHashCode v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = (const void **)(a1 + 32);
  do
  {
    CFHashCode v5 = ((v2 << 6) + 2654435769u + (v2 >> 2) + CFHash(*(v4 - 1))) ^ v2;
    uint64_t v6 = *v4;
    v4 += 2;
    CFHashCode v2 = (CFHash(v6) + 2654435769u + (v5 << 6) + (v5 >> 2)) ^ v5;
    ++v3;
  }
  while (v3 < *(void *)(a1 + 16));
  return v2;
}

uint64_t taggedBufferGroup_createCommon(int a1, const __CFArray *a2, CFArrayRef theArray, uint64_t *a4)
{
  if (a2)
  {
    if (theArray && (CFIndex Count = CFArrayGetCount(theArray), Count == CFArrayGetCount(a2)) && a4)
    {
      if (CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce != -1) {
        dispatch_once(&CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce, &__block_literal_global_39);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v9 = Instance;
        *(void *)(Instance + 16) = Count;
        if (Count >= 1)
        {
          CFIndex v10 = 0;
          CFStringRef v11 = (CFTypeRef *)(Instance + 32);
          do
          {
            ValueAtIndex = CFArrayGetValueAtIndex(theArray, v10);
            *(v11 - 1) = CFRetain(ValueAtIndex);
            int v13 = CFArrayGetValueAtIndex(a2, v10);
            *CFStringRef v11 = CFRetain(v13);
            v11 += 2;
            ++v10;
          }
          while (v10 < *(void *)(v9 + 16));
        }
        *a4 = v9;
        return 0;
      }
      uint64_t v15 = 4294951515;
    }
    else
    {
      uint64_t v15 = 4294951516;
    }
  }
  else
  {
    uint64_t v15 = 4294951516;
  }

  return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTaggedBufferGroupCreateCombined(CFAllocatorRef allocator, CFArrayRef taggedBufferGroups, CMTaggedBufferGroupRef *groupOut)
{
  CFTypeRef cf = 0;
  if (!taggedBufferGroups || (CFIndex Count = CFArrayGetCount(taggedBufferGroups), Count <= 0) || !groupOut)
  {
    uint64_t v20 = 4294951516;
LABEL_16:
    OSStatus Common = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }
  CFIndex v7 = Count;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v20 = 4294951515;
    goto LABEL_16;
  }
  uint64_t v9 = Mutable;
  CFMutableArrayRef v10 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
  if (v10)
  {
    CFStringRef v11 = v10;
    for (CFIndex i = 0; i != v7; ++i)
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(taggedBufferGroups, i);
      if (*((uint64_t *)ValueAtIndex + 2) >= 1)
      {
        int v14 = ValueAtIndex;
        uint64_t v15 = 0;
        int v16 = (const void **)(ValueAtIndex + 32);
        do
        {
          CFArrayAppendValue(v11, *(v16 - 1));
          BOOL v17 = *v16;
          v16 += 2;
          CFArrayAppendValue(v9, v17);
          ++v15;
        }
        while (v15 < *((void *)v14 + 2));
      }
    }
    OSStatus Common = taggedBufferGroup_createCommon((int)allocator, v9, v11, (uint64_t *)&cf);
    if (!Common)
    {
      *groupOut = (CMTaggedBufferGroupRef)cf;
      CFTypeRef cf = 0;
    }
    CFRelease(v9);
    uint64_t v19 = v11;
  }
  else
  {
    OSStatus Common = FigSignalErrorAt(4294951515, 0, 0, 0, 0, 0, 0);
    uint64_t v19 = v9;
  }
  CFRelease(v19);
LABEL_17:
  if (cf) {
    CFRelease(cf);
  }
  return Common;
}

CMItemCount CMTaggedBufferGroupGetCount(CMTaggedBufferGroupRef group)
{
  if (group) {
    return *((void *)group + 2);
  }
  FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
  return 0;
}

CMTagCollectionRef CMTaggedBufferGroupGetTagCollectionAtIndex(CMTaggedBufferGroupRef group, CFIndex index)
{
  if (group && (index & 0x8000000000000000) == 0 && *((void *)group + 2) > index) {
    return (CMTagCollectionRef)*((void *)group + 2 * index + 4);
  }
  FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigTaggedBufferGroupGetCVPixelBufferAtIndex(uint64_t a1, uint64_t a2)
{
  CFTypeID TypeID = CVPixelBufferGetTypeID();

  return taggedBufferGroup_getBufferAtIndexWithTypeCheck(a1, a2, TypeID);
}

CVPixelBufferRef CMTaggedBufferGroupGetCVPixelBufferAtIndex(CMTaggedBufferGroupRef group, CFIndex index)
{
  CFTypeID TypeID = CVPixelBufferGetTypeID();

  return (CVPixelBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, index, TypeID);
}

uint64_t taggedBufferGroup_getBufferAtIndexWithTypeCheck(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 || a2 < 0 || *(void *)(a1 + 16) <= a2)
  {
    FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v3 = a1 + 16 * a2;
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4) {
    return 0;
  }
  if (CFGetTypeID(*(CFTypeRef *)(v3 + 24)) == a3) {
    return v4;
  }
  else {
    return 0;
  }
}

CVPixelBufferRef CMTaggedBufferGroupGetCVPixelBufferForTag(CMTaggedBufferGroupRef group, CMTag tag, CFIndex *indexOut)
{
  CMTag tags = tag;
  CMTagCollectionRef tagCollection = 0;
  CFIndex indexOuta = -1;
  if (CMTagCollectionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &tags, 1, &tagCollection))
  {
    uint64_t v6 = 0;
  }
  else
  {
    CVPixelBufferRef CVPixelBufferForTagCollection = CMTaggedBufferGroupGetCVPixelBufferForTagCollection(group, tagCollection, &indexOuta);
    uint64_t v6 = CVPixelBufferForTagCollection;
    if (indexOut && CVPixelBufferForTagCollection) {
      *indexOut = indexOuta;
    }
  }
  if (tagCollection) {
    CFRelease(tagCollection);
  }
  return v6;
}

CVPixelBufferRef CMTaggedBufferGroupGetCVPixelBufferForTagCollection(CMTaggedBufferGroupRef group, CMTagCollectionRef tagCollection, CFIndex *indexOut)
{
  CFIndex v10 = -1;
  uint64_t CountAndLastIndexForMatchedTagCollection = taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection((uint64_t)group, tagCollection, &v10);
  uint64_t v6 = v10;
  if (CountAndLastIndexForMatchedTagCollection != 1 || v10 == -1) {
    return 0;
  }
  CFTypeID TypeID = CVPixelBufferGetTypeID();
  CVPixelBufferRef result = (CVPixelBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, v6, TypeID);
  if (indexOut)
  {
    if (result) {
      *indexOut = v10;
    }
  }
  return result;
}

uint64_t taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection(uint64_t a1, CMTagCollectionRef containedTagCollection, uint64_t *a3)
{
  if (!a1 || !containedTagCollection)
  {
    FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*(uint64_t *)(a1 + 16) < 1)
  {
    uint64_t v6 = 0;
    uint64_t v9 = -1;
    if (!a3) {
      return v6;
    }
LABEL_11:
    *a3 = v9;
    return v6;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = (const OpaqueCMTagCollection **)(a1 + 32);
  uint64_t v9 = -1;
  do
  {
    CFIndex v10 = *v8;
    v8 += 2;
    if (CMTagCollectionContainsTagsOfCollection(v10, containedTagCollection))
    {
      uint64_t v9 = v7;
      ++v6;
    }
    ++v7;
  }
  while (v7 < *(void *)(a1 + 16));
  if (a3) {
    goto LABEL_11;
  }
  return v6;
}

uint64_t FigTaggedBufferGroupGetCMSampleBufferAtIndex(uint64_t a1, uint64_t a2)
{
  CFTypeID TypeID = CMSampleBufferGetTypeID();

  return taggedBufferGroup_getBufferAtIndexWithTypeCheck(a1, a2, TypeID);
}

CMSampleBufferRef CMTaggedBufferGroupGetCMSampleBufferAtIndex(CMTaggedBufferGroupRef group, CFIndex index)
{
  CFTypeID TypeID = CMSampleBufferGetTypeID();

  return (CMSampleBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, index, TypeID);
}

CMSampleBufferRef CMTaggedBufferGroupGetCMSampleBufferForTag(CMTaggedBufferGroupRef group, CMTag tag, CFIndex *indexOut)
{
  CMTag tags = tag;
  CMTagCollectionRef tagCollection = 0;
  CFIndex indexOuta = -1;
  if (CMTagCollectionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &tags, 1, &tagCollection))
  {
    uint64_t v6 = 0;
  }
  else
  {
    CMSampleBufferRef CMSampleBufferForTagCollection = CMTaggedBufferGroupGetCMSampleBufferForTagCollection(group, tagCollection, &indexOuta);
    uint64_t v6 = CMSampleBufferForTagCollection;
    if (indexOut && CMSampleBufferForTagCollection) {
      *indexOut = indexOuta;
    }
  }
  if (tagCollection) {
    CFRelease(tagCollection);
  }
  return v6;
}

CMSampleBufferRef CMTaggedBufferGroupGetCMSampleBufferForTagCollection(CMTaggedBufferGroupRef group, CMTagCollectionRef tagCollection, CFIndex *indexOut)
{
  CFIndex v10 = -1;
  uint64_t CountAndLastIndexForMatchedTagCollection = taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection((uint64_t)group, tagCollection, &v10);
  uint64_t v6 = v10;
  if (CountAndLastIndexForMatchedTagCollection != 1 || v10 == -1) {
    return 0;
  }
  CFTypeID TypeID = CMSampleBufferGetTypeID();
  CMSampleBufferRef result = (CMSampleBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, v6, TypeID);
  if (indexOut)
  {
    if (result) {
      *indexOut = v10;
    }
  }
  return result;
}

uint64_t FigTaggedBufferGroupGetNumberOfMatchesForTagCollection(uint64_t a1, const OpaqueCMTagCollection *a2)
{
  return taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection(a1, a2, 0);
}

CMItemCount CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(CMTaggedBufferGroupRef group, CMTagCollectionRef tagCollection)
{
  return taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection((uint64_t)group, tagCollection, 0);
}

__CFString *taggedBufferGroup_copyDesc(const void **a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  if (Mutable)
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    CFMutableArrayRef v5 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
    if (v5)
    {
      uint64_t v6 = v5;
      if ((uint64_t)a1[2] >= 1)
      {
        uint64_t v7 = 0;
        uint64_t v8 = a1 + 4;
        do
        {
          CFArrayAppendValue(v6, *(v8 - 1));
          uint64_t v9 = *v8;
          v8 += 2;
          CFArrayAppendValue(v6, v9);
          ++v7;
        }
        while (v7 < (uint64_t)a1[2]);
      }
      CFIndex v10 = FigCFCopyCompactDescription(v6);
      CFStringAppendFormat(Mutable, 0, @"<CMTaggedBufferGroup %p>: TaggedBuffers %@", a1, v10);
      if (v10) {
        CFRelease(v10);
      }
      CFRelease(v6);
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, @"<CMTaggedBufferGroup %p>: TaggedBuffers %@", a1, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294951515, 0, 0, 0, 0, 0, 0);
  }
  return Mutable;
}

uint64_t FigRegistryItemGetTypeID()
{
  return sFigRegistryItemID;
}

uint64_t registerFigRegistryItem()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigRegistryItemID = result;
  return result;
}

uint64_t FigRegistryItemCreateCopy2(void *a1, CFDictionaryRef theDict, void *a3)
{
  *a3 = 0;
  uint64_t result = 4294954602;
  if (a1 && theDict)
  {
    Value = CFDictionaryGetValue(theDict, @"CMClassID");
    if (Value
      && (v8 = Value, (uint64_t v9 = CFDictionaryGetValue(theDict, @"CMClassImplementationName")) != 0)
      && (CFIndex v10 = v9,
          (CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"CMClassImplementationVersion")) != 0)
      && (CFNumberRef SInt64 = FigCFNumberGetSInt64(v11), CFDictionaryGetValue(theDict, @"CMClassImplementationID"))
      && (int v13 = CFDictionaryGetValue(theDict, @"CMMatchingInfo")) != 0)
    {
      int v14 = v13;
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      FigThreadRunOnce(&FigRegistryItemGetTypeID_registerOnce, (void (*)(void))registerFigRegistryItem);
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        BOOL v17 = (void *)Instance;
        CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(v15, theDict);
        v17[2] = MutableCopy;
        if (MutableCopy)
        {
          v17[3] = a1[3];
          uint64_t v19 = a1[3];
          if (v19)
          {
            FigAtomicIncrement32((atomic_uint *)(v19 + 16));
            uint64_t v20 = *(const void **)(a1[3] + 8);
            if (v20) {
              CFRetain(v20);
            }
          }
          v17[4] = CFRetain(v8);
          v17[5] = CFRetain(v10);
          v17[7] = CFRetain(v14);
          v17[8] = SInt64;
          uint64_t v21 = (const void *)a1[6];
          if (v21) {
            CFTypeRef v22 = CFRetain(v21);
          }
          else {
            CFTypeRef v22 = 0;
          }
          uint64_t result = 0;
          v17[6] = v22;
          v17[9] = a1[9];
          *a3 = v17;
        }
        else
        {
          uint64_t v23 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
          CFRelease(v17);
          return v23;
        }
      }
      else
      {
        return 4294954603;
      }
    }
    else
    {
      return 4294954602;
    }
  }
  return result;
}

uint64_t FigRegistryItemCreateCopy(uint64_t a1, uint64_t a2, const void *a3, void *a4)
{
  uint64_t Copy2 = 4294954602;
  if (!a3 || !a1 || !a4) {
    return Copy2;
  }
  *a4 = 0;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(CFDictionaryRef *)(a1 + 16));
  if (MutableCopy)
  {
    CFNumberRef v11 = MutableCopy;
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"CMClassImplementationID");
    if (a2)
    {
      int v13 = CFStringCreateMutableCopy(v9, 0, Value);
      CFStringAppendFormat(v13, 0, @".%@", a2);
      CFDictionarySetValue(v11, @"CMClassImplementationID", v13);
    }
    else
    {
      int v13 = 0;
    }
    CFDictionarySetValue(v11, @"CMMatchingInfo", a3);
    uint64_t Copy2 = FigRegistryItemCreateCopy2((void *)a1, v11, a4);
    if (v13) {
      CFRelease(v13);
    }
    CFRelease(v11);
    return Copy2;
  }

  return FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRegistryItemCopyDescription(uint64_t a1, void *a2)
{
  CFAllocatorRef v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRetain(v4);
    uint64_t v5 = *(void *)(a1 + 16);
  }
  else
  {
    uint64_t v5 = 0;
  }
  *a2 = v5;
  return 0;
}

uint64_t FigRegistryItemCopyMatchingInfo(uint64_t a1, void *a2)
{
  CFAllocatorRef v4 = *(const void **)(a1 + 56);
  if (v4)
  {
    CFRetain(v4);
    uint64_t v5 = *(void *)(a1 + 56);
  }
  else
  {
    uint64_t v5 = 0;
  }
  *a2 = v5;
  return 0;
}

uint64_t FigRegistryItemCopyBundle(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3)
  {
    CFRetain(*(CFTypeRef *)(v3 + 8));
    uint64_t v4 = *(void *)(v3 + 8);
  }
  else
  {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  return 0;
}

uint64_t FigRegistryItemGetFactory(uint64_t a1, int a2, void *a3)
{
  uint64_t result = 0;
  uint64_t v6 = *(void *)(a1 + 72);
  if (a2 && !v6)
  {
    uint64_t v7 = *(void *)(a1 + 24);
    FigSimpleMutexLock(*(pthread_mutex_t **)v7);
    if (!*(void *)(a1 + 72)) {
      *(void *)(a1 + 72) = CFBundleGetFunctionPointerForName(*(CFBundleRef *)(v7 + 8), *(CFStringRef *)(a1 + 48));
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)v7);
    uint64_t v6 = *(void *)(a1 + 72);
    if (v6)
    {
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = FigSignalErrorAt(4294954604, 0, 0, 0, 0, 0, 0);
      uint64_t v6 = *(void *)(a1 + 72);
    }
  }
  *a3 = v6;
  return result;
}

uint64_t FigRegistryItemGetVersion(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t FigRegistryGetTypeID()
{
  return sFigRegistryID;
}

uint64_t registerFigRegistry()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigRegistryID = result;
  return result;
}

uint64_t FigRegistryCreate(const __CFAllocator *a1, const __CFString *a2, void *a3)
{
  FigThreadRunOnce(&FigRegistryGetTypeID_registerOnce, (void (*)(void))registerFigRegistry);
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v7 = (const CFSetCallBacks *)MEMORY[0x1E4F1D548];
    Instance[3] = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
    Instance[4] = CFArrayCreateMutable(a1, 0, 0);
    Instance[5] = CFSetCreateMutable(a1, 0, v7);
    Instance[6] = FigReentrantMutexCreate();
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    Instance[7] = Mutable;
    if (Instance[3] && Instance[4] && Instance[5] && (Instance[6] ? (BOOL v9 = Mutable == 0) : (BOOL v9 = 1), !v9))
    {
      CFStringRef Copy = CFStringCreateCopy(a1, a2);
      uint64_t v12 = 0;
      Instance[2] = Copy;
    }
    else
    {
      uint64_t v12 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
      if (v12)
      {
        CFRelease(Instance);
        uint64_t Instance = 0;
      }
    }
  }
  else
  {
    uint64_t v12 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
  }
  *a3 = Instance;
  return v12;
}

uint64_t FigRegistryAddSearchPathWithOptions(uint64_t a1, const void *a2, int a3)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 48));
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 24), a2))
  {
    uint64_t v6 = 0;
  }
  else
  {
    xpc_object_t value = 0;
    uint64_t v6 = registryCacheAddPath(a2, 0, a3, (pthread_mutex_t ***)&value);
    if (!v6)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), value);
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 24), a2);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
  return v6;
}

uint64_t registryCacheAddPath(const void *a1, int a2, int a3, pthread_mutex_t ***a4)
{
  FigThreadRunOnce(&stru_1E9271320, (void (*)(void))registryCacheInitOnce);
  if (qword_1E9271318)
  {
    FigSimpleMutexLock((pthread_mutex_t *)qword_1E9271318);
    CFStringRef Value = (pthread_mutex_t **)CFDictionaryGetValue((CFDictionaryRef)sRegistryCache, a1);
    if (Value)
    {
LABEL_3:
      FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9271318);
      FigSimpleMutexLock(Value[1]);
      int v9 = *((_DWORD *)Value + 5);
      if (a2 || !v9)
      {
        if (v9) {
          CFDictionaryApplyFunction((CFDictionaryRef)*Value, (CFDictionaryApplierFunction)registryCacheClearClass, 0);
        }
        CFArrayRef BundlesFromDirectory = CFBundleCreateBundlesFromDirectory((CFAllocatorRef)qword_1E9271310, (CFURLRef)a1, @"bundle");
        if (BundlesFromDirectory)
        {
          CFArrayRef v11 = BundlesFromDirectory;
          v16.length = CFArrayGetCount(BundlesFromDirectory);
          v16.location = 0;
          CFArrayApplyFunction(v11, v16, (CFArrayApplierFunction)registryCacheProcessBundle, Value);
          CFRelease(v11);
LABEL_9:
          ++*((_DWORD *)Value + 5);
          goto LABEL_17;
        }
        if (!FigSignalErrorAt(4294954605, 0, 0, 0, 0, 0, 0)) {
          goto LABEL_9;
        }
      }
LABEL_17:
      FigSimpleMutexUnlock(Value[1]);
      uint64_t result = 0;
      if (!a4) {
        return result;
      }
      goto LABEL_18;
    }
    int v13 = (pthread_mutex_t **)malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
    if (v13)
    {
      CFStringRef Value = v13;
      *((_DWORD *)v13 + 4) = a3;
      *((_DWORD *)v13 + 5) = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)qword_1E9271310, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      const void *Value = (pthread_mutex_t *)Mutable;
      if (Mutable)
      {
        CFAllocatorRef v15 = FigSimpleMutexCreate();
        Value[1] = v15;
        if (v15)
        {
          CFDictionaryAddValue((CFMutableDictionaryRef)sRegistryCache, a1, Value);
          goto LABEL_3;
        }
      }
      FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
      if (*Value) {
        CFRelease(*Value);
      }
      free(Value);
    }
    else
    {
      FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9271318);
    CFStringRef Value = 0;
    uint64_t result = 4294954603;
    if (!a4) {
      return result;
    }
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
    CFStringRef Value = 0;
    if (!a4) {
      return result;
    }
  }
LABEL_18:
  *a4 = Value;
  return result;
}

uint64_t FigRegistryAddSearchPath(uint64_t a1, const void *a2)
{
  return FigRegistryAddSearchPathWithOptions(a1, a2, 0);
}

uint64_t FigRegistryAddItem(uint64_t a1, CFDictionaryRef theDict, uint64_t a3)
{
  CFTypeRef cf = 0;
  CFStringRef Value = CFDictionaryGetValue(theDict, @"CMClassID");
  if (Value && CFEqual(Value, *(CFTypeRef *)(a1 + 16)))
  {
    CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v8 = figRegistryItemCreate(v7, 0, a3, theDict, &cf);
    if (v8)
    {
      CFTypeRef v9 = cf;
      if (!cf) {
        return v8;
      }
    }
    else
    {
      FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 48));
      CFTypeRef v9 = cf;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), cf);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
      if (!v9) {
        return v8;
      }
    }
    CFRelease(v9);
    return v8;
  }

  return FigSignalErrorAt(4294954606, 0, 0, 0, 0, 0, 0);
}

uint64_t figRegistryItemCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict, void *a5)
{
  uint64_t v7 = 4294954606;
  if (a2 | a3)
  {
    CFDictionaryRef v8 = theDict;
    if (theDict)
    {
      uint64_t valuePtr = 0;
      if (CFDictionaryGetValue(theDict, @"CMClassImplementationID"))
      {
        CFArrayRef v11 = 0;
        goto LABEL_12;
      }
      if (a2)
      {
        uint64_t v12 = *(__CFBundle **)(a2 + 8);
        if (v12)
        {
          CFURLRef v13 = CFBundleCopyBundleURL(v12);
          if (v13) {
            CFRelease(v13);
          }
        }
      }
      CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(a1, v8);
      if (MutableCopy)
      {
        CFArrayRef v11 = MutableCopy;
        uint64_t v15 = FigAtomicIncrement32(figRegistryItemCreate_sNextMadeUpNumber);
        CFStringRef v16 = CFStringCreateWithFormat(a1, 0, @"anon-%d", v15);
        if (!v16)
        {
          uint64_t v30 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
          *a5 = 0;
          goto LABEL_31;
        }
        CFStringRef v17 = v16;
        CFDictionarySetValue(v11, @"CMClassImplementationID", v16);
        CFRelease(v17);
        CFDictionaryRef v8 = v11;
LABEL_12:
        CFStringRef Value = CFDictionaryGetValue(v8, @"CMClassID");
        uint64_t v19 = CFDictionaryGetValue(v8, @"CMClassImplementationName");
        CFTypeRef v37 = CFDictionaryGetValue(v8, @"CMFactoryFunction");
        uint64_t v20 = CFDictionaryGetValue(v8, @"CMClassImplementationVersion");
        uint64_t v21 = CFDictionaryGetValue(v8, @"CMClassImplementationID");
        CFTypeRef cf = CFDictionaryGetValue(v8, @"CMMatchingInfo");
        if (!Value) {
          goto LABEL_29;
        }
        if (!v19) {
          goto LABEL_29;
        }
        if (!v20) {
          goto LABEL_29;
        }
        if (!cf) {
          goto LABEL_29;
        }
        if (!v21) {
          goto LABEL_29;
        }
        CFTypeRef v22 = a5;
        CFTypeID v23 = CFGetTypeID(Value);
        BOOL v24 = v23 == CFStringGetTypeID();
        a5 = v22;
        if (!v24) {
          goto LABEL_29;
        }
        CFTypeID v25 = CFGetTypeID(v19);
        BOOL v24 = v25 == CFStringGetTypeID();
        a5 = v22;
        if (!v24) {
          goto LABEL_29;
        }
        CFTypeID v26 = CFGetTypeID(v20);
        BOOL v24 = v26 == CFNumberGetTypeID();
        a5 = v22;
        if (!v24) {
          goto LABEL_29;
        }
        CFTypeID v27 = CFGetTypeID(cf);
        BOOL v24 = v27 == CFDictionaryGetTypeID();
        a5 = v22;
        if (!v24) {
          goto LABEL_29;
        }
        CFTypeID v28 = CFGetTypeID(v21);
        if (v28 != CFStringGetTypeID() || !CFNumberGetValue((CFNumberRef)v20, kCFNumberSInt64Type, &valuePtr)) {
          goto LABEL_29;
        }
        if (v37)
        {
          CFTypeID v29 = CFGetTypeID(v37);
          if (v29 != CFStringGetTypeID())
          {
LABEL_29:
            uint64_t v30 = FigSignalErrorAt(4294954606, 0, 0, 0, 0, 0, 0);
            uint64_t Instance = 0;
            goto LABEL_30;
          }
        }
        else if (!a3)
        {
          goto LABEL_29;
        }
        FigThreadRunOnce(&FigRegistryItemGetTypeID_registerOnce, (void (*)(void))registerFigRegistryItem);
        uint64_t Instance = (void *)_CFRuntimeCreateInstance();
        if (Instance)
        {
          Instance[2] = CFRetain(v8);
          Instance[3] = a2;
          if (a2)
          {
            FigAtomicIncrement32((atomic_uint *)(a2 + 16));
            uint64_t v33 = *(const void **)(a2 + 8);
            if (v33) {
              CFRetain(v33);
            }
          }
          Instance[4] = CFRetain(Value);
          Instance[5] = CFRetain(v19);
          CFTypeRef v34 = v37;
          if (v37) {
            CFTypeRef v34 = CFRetain(v37);
          }
          Instance[6] = v34;
          CFTypeRef v35 = CFRetain(cf);
          uint64_t v30 = 0;
          uint64_t v36 = valuePtr;
          Instance[7] = v35;
          Instance[8] = v36;
          Instance[9] = a3;
        }
        else
        {
          uint64_t v30 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
        }
LABEL_30:
        *a5 = Instance;
        if (!v11) {
          return v30;
        }
LABEL_31:
        CFRelease(v11);
        return v30;
      }
      uint64_t v7 = 4294954603;
    }
  }
  uint64_t result = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  *a5 = 0;
  return result;
}

uint64_t FigRegistryRemoveItem(uint64_t a1, const void *a2)
{
  return 0;
}

uint64_t FigRegistryRescan(uint64_t a1)
{
  return 0;
}

uint64_t figRegistryRescanDirectory(const void *a1)
{
  return registryCacheAddPath(a1, 1, 0, 0);
}

uint64_t FigRegistrySetIORegistryEntryArray()
{
  return 0;
}

uint64_t FigRegistryCopyItemList(const void *a1, CFMutableArrayRef *a2, _DWORD *a3)
{
  return FigRegistryCopyFilteredItemList(a1, 0, 0, a2, a3);
}

uint64_t FigRegistryCopyFilteredItemList(CFTypeRef cf, uint64_t a2, uint64_t a3, CFMutableArrayRef *a4, _DWORD *a5)
{
  context[0] = cf;
  context[1] = a2;
  context[2] = a3;
  if (a4)
  {
    CFAllocatorRef v8 = CFGetAllocator(cf);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
    if (!Mutable)
    {
      uint64_t v10 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
      int Count = 0;
      goto LABEL_15;
    }
  }
  else
  {
    CFMutableArrayRef Mutable = 0;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)cf + 6));
  int Count = CFSetGetCount(*((CFSetRef *)cf + 5));
  if (a4) {
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)cf + 7));
  }
  CFIndex v12 = CFArrayGetCount(*((CFArrayRef *)cf + 4));
  if (v12 >= 1)
  {
    CFIndex v13 = v12;
    for (CFIndex i = 0; i != v13; ++i)
    {
      ValueAtIndex = (pthread_mutex_t **)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 4), i);
      FigSimpleMutexLock(ValueAtIndex[1]);
      int v16 = *((_DWORD *)ValueAtIndex + 5);
      if (a4)
      {
        CFSetRef Value = (const __CFSet *)CFDictionaryGetValue((CFDictionaryRef)*ValueAtIndex, *((const void **)cf + 2));
        if (Value) {
          CFSetApplyFunction(Value, (CFSetApplierFunction)figRegistryAddResultItem, context);
        }
      }
      Count += v16;
      FigSimpleMutexUnlock(ValueAtIndex[1]);
    }
  }
  if (a4)
  {
    CFSetApplyFunction(*((CFSetRef *)cf + 5), (CFSetApplierFunction)figRegistryAddResultItem, context);
    CFDictionaryApplyFunction(*((CFDictionaryRef *)cf + 7), (CFDictionaryApplierFunction)figRegistryAddItemsToResult, Mutable);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)cf + 6));
    uint64_t v10 = 0;
LABEL_15:
    *a4 = Mutable;
    CFMutableArrayRef Mutable = 0;
    if (!a5) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  FigReentrantMutexUnlock(*((pthread_mutex_t **)cf + 6));
  uint64_t v10 = 0;
  if (a5) {
LABEL_16:
  }
    *a5 = Count;
LABEL_17:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v10;
}

void figRegistryAddResultItem(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(CFDictionaryRef **)a2;
  uint64_t v3 = *(unsigned int (**)(void, uint64_t))(a2 + 8);
  if (!v3 || v3(*(void *)(a2 + 16), a1))
  {
    CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"CMClassImplementationID");
    CFArrayRef v6 = (const __CFArray *)CFDictionaryGetValue(v4[7], Value);
    if (v6)
    {
      CFArrayRef v7 = v6;
      CFIndex Count = CFArrayGetCount(v6);
      if (Count < 1)
      {
        CFIndex v9 = 0;
      }
      else
      {
        CFIndex v9 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v7, v9);
          uint64_t v11 = *(void *)(a1 + 64);
          uint64_t v12 = ValueAtIndex[8];
          if (v11 > v12) {
            break;
          }
          if (v11 == v12) {
            goto LABEL_15;
          }
          if (Count == ++v9) {
            goto LABEL_16;
          }
        }
        CFArrayInsertValueAtIndex(v7, v9, (const void *)a1);
      }
LABEL_15:
      if (v9 == Count)
      {
LABEL_16:
        CFArrayAppendValue(v7, (const void *)a1);
      }
    }
    else
    {
      CFAllocatorRef v13 = CFGetAllocator(v4);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
      CFArrayAppendValue(Mutable, (const void *)a1);
      CFDictionarySetValue(v4[7], Value, Mutable);
      CFRelease(Mutable);
    }
  }
}

void figRegistryAddItemsToResult(int a1, const __CFArray *a2, CFMutableArrayRef theArray)
{
  v4.location = 0;
  v4.length = 1;
  CFArrayAppendArray(theArray, a2, v4);
}

double figRegistryItemInit(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

double figRegistryItemFinalize(void *a1)
{
  uint64_t v3 = a1 + 2;
  CFAllocatorRef v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v4 = a1[3];
  if (v4)
  {
    if (!CFBundleIsExecutableLoaded(*(CFBundleRef *)(v4 + 8)) || CFGetRetainCount(*(CFTypeRef *)(v4 + 8)) >= 2) {
      CFRelease(*(CFTypeRef *)(v4 + 8));
    }
    if (!FigAtomicDecrement32((atomic_uint *)(v4 + 16)))
    {
      FigSimpleMutexDestroy(*(void *)v4);
      free((void *)v4);
    }
  }
  uint64_t v5 = (const void *)a1[4];
  if (v5) {
    CFRelease(v5);
  }
  CFArrayRef v6 = (const void *)a1[5];
  if (v6) {
    CFRelease(v6);
  }
  CFArrayRef v7 = (const void *)a1[6];
  if (v7) {
    CFRelease(v7);
  }
  CFAllocatorRef v8 = (const void *)a1[7];
  if (v8) {
    CFRelease(v8);
  }
  double result = 0.0;
  v3[2] = 0u;
  v3[3] = 0u;
  *uint64_t v3 = 0u;
  v3[1] = 0u;
  return result;
}

uint64_t figRegistryItemEqual(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 64) != *(void *)(a2 + 64)) {
    return 0;
  }
  CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"CMClassImplementationID");
  uint64_t v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), @"CMClassImplementationID");
  uint64_t result = CFEqual(Value, v5);
  if (result) {
    return CFEqual(*(CFTypeRef *)(a1 + 32), *(CFTypeRef *)(a2 + 32)) != 0;
  }
  return result;
}

CFHashCode figRegistryItemHash(uint64_t a1)
{
  CFHashCode v2 = CFHash(*(CFTypeRef *)(a1 + 32));
  CFHashCode v3 = CFHash(*(CFTypeRef *)(a1 + 40));
  uint64_t v4 = *(void *)(a1 + 64);
  double v5 = -(double)v4;
  if (v4 >= 0) {
    double v5 = (double)v4;
  }
  long double v6 = floor(v5 + 0.5);
  double v7 = (v5 - v6) * 1.84467441e19;
  double v8 = fmod(v6, 1.84467441e19);
  unint64_t v9 = 2654435761u * (unint64_t)v8;
  unint64_t v10 = v9 + (unint64_t)v7;
  if (v7 <= 0.0) {
    unint64_t v10 = 2654435761u * (unint64_t)v8;
  }
  unint64_t v11 = v9 - (unint64_t)fabs(v7);
  if (v7 >= 0.0) {
    unint64_t v11 = v10;
  }
  return v3 ^ v2 ^ v11;
}

CFStringRef figRegistryItemCopyDebugDesc(CFTypeRef cf)
{
  uint64_t v2 = *((void *)cf + 3);
  if (v2 && (CFHashCode v3 = *(__CFBundle **)(v2 + 8)) != 0)
  {
    CFURLRef v4 = CFBundleCopyBundleURL(*(CFBundleRef *)(v2 + 8));
    CFAllocatorRef v5 = CFGetAllocator(cf);
    if (CFBundleIsExecutableLoaded(v3)) {
      long double v6 = @" (loaded)";
    }
    else {
      long double v6 = &stru_1EDF73CD0;
    }
    if (v4)
    {
      CFStringRef v7 = CFURLGetString(v4);
      char v8 = 0;
    }
    else
    {
      CFStringRef v7 = @"none";
      char v8 = 1;
    }
  }
  else
  {
    CFAllocatorRef v5 = CFGetAllocator(cf);
    CFHashCode v3 = 0;
    CFURLRef v4 = 0;
    CFStringRef v7 = @"none";
    char v8 = 1;
    long double v6 = &stru_1EDF73CD0;
  }
  uint64_t v9 = *((void *)cf + 4);
  CFSetRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)cf + 2), @"CMClassImplementationID");
  unint64_t v11 = (__CFString *)*((void *)cf + 6);
  if (!v11) {
    unint64_t v11 = &stru_1EDF73CD0;
  }
  CFStringRef v12 = CFStringCreateWithFormat(v5, 0, @"<FigRegistryItem %p> {\n\tBundle: %p%@\n\tBundle URL: %@\n\tClass ID: %@\n\tClass Implementation ID: %@\n\tObject name: %@\n\tVersion: %lld\n\tFactory function name: %@\n\tFactory function: %p\n}", cf, v3, v6, v7, v9, Value, *((void *)cf + 5), *((void *)cf + 8), v11, *((void *)cf + 9));
  if ((v8 & 1) == 0) {
    CFRelease(v4);
  }
  return v12;
}

double figRegistryInit(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

double figRegistryFinalize(void *a1)
{
  CFHashCode v3 = a1 + 2;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  CFURLRef v4 = (const void *)a1[3];
  if (v4) {
    CFRelease(v4);
  }
  CFAllocatorRef v5 = (const void *)a1[4];
  if (v5) {
    CFRelease(v5);
  }
  long double v6 = (const void *)a1[5];
  if (v6) {
    CFRelease(v6);
  }
  CFStringRef v7 = (const void *)a1[7];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = a1[6];
  if (v8) {
    FigReentrantMutexDestroy(v8);
  }
  double result = 0.0;
  v3[1] = 0u;
  v3[2] = 0u;
  *CFHashCode v3 = 0u;
  return result;
}

CFStringRef figRegistryCopyDebugDesc(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<FigRegistry %p> {\n\tClass ID: %@\n}", a1, a1[2]);
}

uint64_t registryCacheInitOnce()
{
  sRegistryCache = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)qword_1E9271310, 0, MEMORY[0x1E4F1D530], 0);
  if (sRegistryCache)
  {
    qword_1E9271318 = (uint64_t)FigSimpleMutexCreate();
    if (qword_1E9271318) {
      return 0;
    }
  }
  uint64_t v0 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
  if (v0 && sRegistryCache)
  {
    CFRelease((CFTypeRef)sRegistryCache);
    sRegistryCache = 0;
  }
  return v0;
}

void registryCacheClearClass(int a1, CFMutableSetRef theSet)
{
}

void registryCacheProcessBundle(__CFBundle *a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  CFArrayRef ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(a1, @"CMClassImplementations");
  if (ValueForInfoDictionaryKey)
  {
    CFArrayRef v6 = ValueForInfoDictionaryKey;
    CFTypeID v7 = CFGetTypeID(ValueForInfoDictionaryKey);
    if (v7 == CFArrayGetTypeID())
    {
      CFTypeID v29 = (CFDictionaryRef *)a2;
      CFIndex Count = CFArrayGetCount(v6);
      uint64_t v9 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x10200404B2C534EuLL);
      *((void *)v9 + 1) = a1;
      v9[20] = v4 & 1;
      *((_DWORD *)v9 + 4) = 1;
      CFTypeID v28 = (atomic_uint *)(v9 + 16);
      uint64_t v31 = (uint64_t *)v9;
      *(void *)uint64_t v9 = FigSimpleMutexCreate();
      if (Count >= 1)
      {
        CFIndex v10 = 0;
        uint64_t v30 = (const void *)*MEMORY[0x1E4F1CFD0];
        while (1)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(v6, v10);
          CFTypeID v12 = CFGetTypeID(ValueAtIndex);
          if (v12 == CFDictionaryGetTypeID()) {
            break;
          }
LABEL_33:
          if (Count == ++v10) {
            goto LABEL_39;
          }
        }
        if ((((v4 >> 1) | (v4 >> 2) | (v4 >> 3)) & 1) == 0
          || (CFSetRef Value = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"CMMatchingInfo")) == 0
          || (int v14 = Value, v15 = CFGetTypeID(Value), v15 != CFDictionaryGetTypeID()))
        {
          uint64_t v20 = 0;
          goto LABEL_17;
        }
        CFAllocatorRef v16 = CFGetAllocator(ValueAtIndex);
        ValueAtIndex = FigCFDictionaryCreateMutableCopy(v16, (CFDictionaryRef)ValueAtIndex);
        CFAllocatorRef v17 = CFGetAllocator(v14);
        CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(v17, (CFDictionaryRef)v14);
        CFMutableDictionaryRef v19 = MutableCopy;
        if ((v4 & 2) != 0)
        {
          FigCFDictionarySetValue(MutableCopy, @"IsProWorkflowPlugin", v30);
          if ((v4 & 4) == 0)
          {
LABEL_11:
            if ((v4 & 8) == 0)
            {
LABEL_13:
              FigCFDictionarySetValue(ValueAtIndex, @"CMMatchingInfo", v19);
              if (v19) {
                CFRelease(v19);
              }
              uint64_t v20 = ValueAtIndex;
LABEL_17:
              CFTypeRef cf = 0;
              CFArrayRef v21 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"CMExecutableArchitectures");
              if (!v21
                || (CFArrayRef v22 = v21, v23 = CFGetTypeID(v21), v23 != CFArrayGetTypeID())
                || !FigCFArrayContainsValue(v22, @"arm64e")
                && (!CFEqual(@"arm64e", @"arm64e")
                 || !FigCFArrayContainsValue(v22, @"arm64")))
              {
LABEL_31:
                if (v20) {
                  CFRelease(v20);
                }
                goto LABEL_33;
              }
              int v24 = figRegistryItemCreate((const __CFAllocator *)qword_1E9271310, (uint64_t)v31, 0, (CFDictionaryRef)ValueAtIndex, &cf);
              CFTypeID v25 = (const void **)cf;
              if (v24)
              {
                if (!cf) {
                  goto LABEL_31;
                }
              }
              else
              {
                CFTypeID v26 = (void *)CFDictionaryGetValue(*v29, *((const void **)cf + 4));
                if (!v26)
                {
                  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)qword_1E9271310, 0, MEMORY[0x1E4F1D548]);
                  if (!Mutable)
                  {
                    FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
                    goto LABEL_30;
                  }
                  CFTypeID v26 = Mutable;
                  CFDictionaryAddValue(*v29, v25[4], Mutable);
                  CFRelease(v26);
                }
                CFSetAddValue((CFMutableSetRef)v26, v25);
              }
LABEL_30:
              CFRelease(v25);
              goto LABEL_31;
            }
LABEL_12:
            FigCFDictionarySetValue(v19, @"IsPreferredInternalPlugin", v30);
            goto LABEL_13;
          }
        }
        else if ((v4 & 4) == 0)
        {
          goto LABEL_11;
        }
        FigCFDictionarySetValue(v19, @"IsAppExclusivePlugin", v30);
        if ((v4 & 8) == 0) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
LABEL_39:
      if (!FigAtomicDecrement32(v28))
      {
        FigSimpleMutexDestroy(*v31);
        free(v31);
      }
    }
  }

  CFRelease(a1);
}

uint64_t FigEndpointGetClassID()
{
  if (FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce, &FigEndpointGetClassID_sFigEndpointClassID, (dispatch_function_t)FigEndpointGetClassIDCallback);
  }
  return FigEndpointGetClassID_sFigEndpointClassID;
}

uint64_t FigEndpointGetClassIDCallback(void *a1)
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigEndpointGetClassIDCallback_sFigEndpointClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointGetTypeID()
{
  if (FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce, &FigEndpointGetClassID_sFigEndpointClassID, (dispatch_function_t)FigEndpointGetClassIDCallback);
  }
  uint64_t v0 = (void *)FigEndpointGetClassID_sFigEndpointClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef FigEndpointBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpoint %p]", a1);
}

uint64_t FigHALAudioConduitDeviceGetTypeID()
{
  return sFigHALAudioConduitDeviceID;
}

uint64_t registerFigHALAudioConduitDevice()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigHALAudioConduitDeviceID = result;
  return result;
}

uint64_t FigHALAudioConduitDeviceCreate(uint64_t a1, const void *a2, const void *a3, uint64_t *a4)
{
  unsigned int v7 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigHALAudioConduitDeviceTrace[1], @"fhacd_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v7, 0, gFigHALAudioConduitDeviceTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigHALAudioConduitDeviceTrace[3], @"fhacd_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &gFigHALAudioConduitDeviceTrace[2]);
  if (a2 && a4)
  {
    FigThreadRunOnce(&FigHALAudioConduitDeviceGetTypeID_sRegisterFigHALAudioConduitDeviceOnce, (void (*)(void))registerFigHALAudioConduitDevice);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v9 = Instance;
      CFIndex v10 = FigSimpleMutexCreate();
      *(void *)(v9 + 168) = v10;
      if (v10)
      {
        unint64_t v11 = FigSimpleMutexCreate();
        *(void *)(v9 + 80) = v11;
        if (v11)
        {
          *(_WORD *)(v9 + 128) = 0;
          CFTypeID v12 = (const void *)*MEMORY[0x1E4F1CFD0];
          *(unsigned char *)(v9 + 130) = v12 == FigCFDictionaryGetBooleanValue(a3, @"ForTest");
          *(void *)(v9 + 136) = CFRetain(a2);
          StringCFSetRef Value = FigCFDictionaryGetStringValue(a3, @"DeviceName");
          if (StringValue) {
            StringCFSetRef Value = CFRetain(StringValue);
          }
          *(void *)(v9 + 144) = StringValue;
          int v14 = FigCFDictionaryGetStringValue(a3, @"DeviceUID");
          if (v14) {
            int v14 = CFRetain(v14);
          }
          *(void *)(v9 + 160) = v14;
          CFTypeID v15 = FigCFDictionaryGetStringValue(a3, @"ModelUID");
          if (v15) {
            CFTypeRef v16 = CFRetain(v15);
          }
          else {
            CFTypeRef v16 = 0;
          }
          uint64_t result = 0;
          *(void *)(v9 + 152) = v16;
          *a4 = v9;
          return result;
        }
      }
      CFRelease((CFTypeRef)v9);
    }
    return 4294954510;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHALAudioConduitDeviceSetClientReceiveAudioIODelegate(uint64_t a1, long long *a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(unsigned char *)(a1 + 129))
  {
    uint64_t v7 = 4294954514;
  }
  else
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 80));
    if (a2)
    {
      long long v4 = *a2;
      long long v5 = a2[1];
      long long v6 = a2[2];
      *(_OWORD *)(a1 + 60) = *(long long *)((char *)a2 + 44);
      *(_OWORD *)(a1 + 32) = v5;
      *(_OWORD *)(a1 + 48) = v6;
    }
    else
    {
      long long v4 = 0uLL;
      *(_OWORD *)(a1 + 60) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
    }
    *(_OWORD *)(a1 + 16) = v4;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 80));
    uint64_t v7 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  return v7;
}

uint64_t FigHALAudioConduitDeviceSetClientControlIODelegate(uint64_t a1, long long *a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(unsigned char *)(a1 + 129))
  {
    uint64_t v4 = 4294954514;
  }
  else
  {
    uint64_t v4 = 0;
    if (a2)
    {
      long long v5 = *a2;
      long long v6 = a2[1];
      *(void *)(a1 + 120) = *((void *)a2 + 4);
      *(_OWORD *)(a1 + 104) = v6;
    }
    else
    {
      *(void *)(a1 + 120) = 0;
      long long v5 = 0uLL;
      *(_OWORD *)(a1 + 104) = 0u;
    }
    *(_OWORD *)(a1 + 88) = v5;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  return v4;
}

uint64_t FigHALAudioConduitDeviceResume(uint64_t a1)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(unsigned char *)(a1 + 128))
  {
    uint64_t v7 = 4294954514;
    goto LABEL_16;
  }
  CFTypeRef cf = 0;
  if (*(unsigned char *)(a1 + 130)) {
    goto LABEL_15;
  }
  CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, @"ConduitDeviceOption_Conduit", (const void *)a1);
  FigHALAudioDeviceBrokerCopy(*(const void **)(a1 + 136), &cf);
  CFTypeRef v3 = cf;
  if (cf)
  {
    uint64_t v4 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 16);
    if (v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    long long v6 = *(uint64_t (**)(CFTypeRef, void, void, void, __CFDictionary *))(v5 + 8);
    if (v6)
    {
      uint64_t v7 = v6(v3, 0, 0, 0, Mutable);
      if (!Mutable) {
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v7 = 4294954514;
      if (!Mutable) {
        goto LABEL_12;
      }
    }
LABEL_11:
    CFRelease(Mutable);
    goto LABEL_12;
  }
  uint64_t v7 = 4294949690;
  if (Mutable) {
    goto LABEL_11;
  }
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  if (!v7)
  {
LABEL_15:
    uint64_t v7 = 0;
    *(unsigned char *)(a1 + 128) = 1;
  }
LABEL_16:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  return v7;
}

uint64_t FigHALAudioConduitDeviceSuspendAndInvalidate(uint64_t a1)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(unsigned char *)(a1 + 129))
  {
    uint64_t v3 = 0;
LABEL_7:
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
    return v3;
  }
  *(unsigned char *)(a1 + 129) = 1;
  if (*(unsigned char *)(a1 + 128) != 1)
  {
    uint64_t v3 = 4294954514;
    goto LABEL_7;
  }
  *(unsigned char *)(a1 + 128) = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, @"Suspended", (const void *)a1, 0);
  return 0;
}

uint64_t FigHALAudioConduitDeviceHALSendAudio(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (FigSimpleMutexTryLock(*(pthread_mutex_t **)(a1 + 168)))
  {
    if (*(unsigned char *)(a1 + 128) && !*(unsigned char *)(a1 + 129) && FigSimpleMutexTryLock(*(pthread_mutex_t **)(a1 + 80)))
    {
      CFIndex v10 = *(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 60);
      if (v10) {
        v10(*(void *)(a1 + 68), a2, a3, a4, a5);
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 80));
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  }
  return 0;
}

uint64_t FigHALAudioConduitDeviceCopyProperty(uint64_t a1, CFTypeRef cf1, const __CFAllocator *a3, void *a4)
{
  if (!cf1 || !a4)
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (!CFEqual(cf1, @"HALSendAudioFormat"))
  {
    if (CFEqual(cf1, @"HALSendDesiredNumberPackets"))
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 80));
      CFNumberRef SInt32 = FigCFNumberCreateSInt32(a3, *(_DWORD *)(a1 + 56));
      goto LABEL_7;
    }
    if (CFEqual(cf1, @"DeviceName"))
    {
      unint64_t v11 = *(const void **)(a1 + 144);
      if (v11) {
        goto LABEL_11;
      }
    }
    else if (CFEqual(cf1, @"DeviceUID"))
    {
      unint64_t v11 = *(const void **)(a1 + 160);
      if (v11) {
        goto LABEL_11;
      }
    }
    else
    {
      if (!CFEqual(cf1, @"ModelUID")) {
        return 4294954512;
      }
      unint64_t v11 = *(const void **)(a1 + 152);
      if (v11)
      {
LABEL_11:
        CFTypeRef v9 = CFRetain(v11);
        goto LABEL_8;
      }
    }
    CFTypeRef v9 = 0;
    goto LABEL_8;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 80));
  CFNumberRef SInt32 = CFDataCreate(a3, (const UInt8 *)(a1 + 16), 40);
LABEL_7:
  CFTypeRef v9 = SInt32;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 80));
  if (v9)
  {
LABEL_8:
    uint64_t result = 0;
    *a4 = v9;
    return result;
  }
  return 4294954510;
}

uint64_t FigHALAudioConduitDeviceHALStartIO(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t figHALAudioConduitDeviceCallControlIODelegate(uint64_t a1, int a2, uint64_t a3)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(unsigned char *)(a1 + 128) && !*(unsigned char *)(a1 + 129))
  {
    switch(a2)
    {
      case 1:
        long long v6 = *(void (**)(void, uint64_t))(a1 + 88);
        if (v6) {
          goto LABEL_11;
        }
        break;
      case 2:
        long long v6 = *(void (**)(void, uint64_t))(a1 + 96);
        if (v6) {
          goto LABEL_11;
        }
        break;
      case 3:
        long long v6 = *(void (**)(void, uint64_t))(a1 + 104);
        if (v6) {
          goto LABEL_11;
        }
        break;
      case 4:
        long long v6 = *(void (**)(void, uint64_t))(a1 + 112);
        if (v6) {
LABEL_11:
        }
          v6(*(void *)(a1 + 120), a3);
        break;
      default:
        break;
    }
  }
  uint64_t v7 = *(pthread_mutex_t **)(a1 + 168);

  return FigSimpleMutexUnlock(v7);
}

uint64_t FigHALAudioConduitDeviceHALStopIO(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t FigHALAudioConduitDeviceHALStartStream(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t FigHALAudioConduitDeviceHALStopStream(uint64_t a1, uint64_t a2)
{
  return 0;
}

double FigHALAudioConduitDeviceInit(_OWORD *a1)
{
  double result = 0.0;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void FigHALAudioConduitDeviceFinalize(uint64_t *a1)
{
  FigSimpleMutexDestroy(a1[10]);
  FigSimpleMutexDestroy(a1[21]);
  CFAllocatorRef v2 = (const void *)a1[17];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[20];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[18];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[19];
  if (v5)
  {
    CFRelease(v5);
  }
}

__CFString *FigHALAudioConduitDeviceCopyDebugDesc(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);
  CFMutableSetRef Mutable = CFStringCreateMutable(v1, 0);
  CFStringAppendFormat(Mutable, 0, @"FigHALAudioConduitDevice");
  return Mutable;
}

uint64_t FigGeometryMappingGetTypeID()
{
  if (sRegisterFigGeometryMappingTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
  }
  return sFigGeometryMappingID;
}

uint64_t RegisterFigGeometryMappingType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigGeometryMappingID = result;
  return result;
}

uint64_t FigGeometryMappingGetSourceUnits(uint64_t a1, _OWORD *a2)
{
  if (!a1) {
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
  if (a2)
  {
    long long v2 = *(_OWORD *)(a1 + 72);
    *a2 = *(_OWORD *)(a1 + 56);
    a2[1] = v2;
  }
  return 0;
}

uint64_t FigGeometryMappingGetDestinationUnits(uint64_t a1, _OWORD *a2)
{
  if (!a1) {
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
  if (a2)
  {
    long long v2 = *(_OWORD *)(a1 + 104);
    *a2 = *(_OWORD *)(a1 + 88);
    a2[1] = v2;
  }
  return 0;
}

uint64_t FigGeometryMappingCreate(uint64_t a1, const void *a2, int a3, const void *a4, int a5, uint64_t *a6)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  long long v73 = 0u;
  long long v74 = 0u;
  uint64_t v75 = 0;
  uint64_t v71 = 0;
  int v72 = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  uint64_t v70 = 0;
  uint64_t v66 = 0;
  int v67 = 0;
  if (!a2 || !a4 || (a3 - 3) <= 0xFFFFFFFD || (a5 - 3) <= 0xFFFFFFFD || !a6)
  {
    uint64_t v20 = 4294949966;
    goto LABEL_17;
  }
  *a6 = 0;
  if (sRegisterFigGeometryMappingTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v20 = 4294949965;
LABEL_17:
    return FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v12 = Instance;
  memset(__src, 0, sizeof(__src));
  *(void *)(Instance + 16) = 0x16D617070;
  *(void *)(Instance + 128) = CFRetain(a2);
  *(void *)(v12 + 136) = CFRetain(a4);
  *(unsigned char *)(v12 + 120) = 0;
  *(_OWORD *)(v12 + 24) = kFigGeometryAffineTransform1DIdentity;
  *(_OWORD *)(v12 + 40) = kFigGeometryAffineTransform1DIdentity;
  *(_OWORD *)(v12 + 56) = kFigGeometrySizeZero;
  *(_OWORD *)(v12 + 72) = unk_18FE95618;
  *(_OWORD *)(v12 + 88) = kFigGeometrySizeZero;
  *(_OWORD *)(v12 + 104) = unk_18FE95618;
  if (_figUpdateCoordinateSpaceGeometryCache((uint64_t)a2, (uint64_t)__src))
  {
    memset(v64, 0, sizeof(v64));
    if (_figUpdateCoordinateSpaceGeometryCache((uint64_t)a4, (uint64_t)v64))
    {
      memcpy((void *)(v12 + 144), __src, 0x160uLL);
      memcpy((void *)(v12 + 496), v64, 0x160uLL);
      *(_DWORD *)(v12 + 848) = a3;
      *(_DWORD *)(v12 + 852) = a5;
      if (a3 == 2)
      {
        if (a5 == 2)
        {
          long long v73 = __src[0];
          long long v74 = __src[1];
          uint64_t v75 = *(void *)&__src[2];
          uint64_t v71 = *(void *)((char *)&__src[2] + 12);
          int v13 = DWORD2(__src[2]);
          int v72 = DWORD1(__src[3]);
          uint64_t v22 = *((void *)&__src[3] + 1);
          uint64_t v70 = *(void *)&v64[2];
          long long v68 = v64[0];
          long long v69 = v64[1];
          int v23 = DWORD2(v64[2]);
          int v67 = DWORD1(v64[3]);
          uint64_t v66 = *(void *)((char *)&v64[2] + 12);
          uint64_t v24 = *((void *)&v64[3] + 1);
          goto LABEL_27;
        }
        if (a5 == 1)
        {
          long long v53 = __src[16];
          long long v54 = __src[17];
          long long v55 = __src[18];
          long long v56 = __src[19];
          _figApplyNormalizedCGRectToFigGeometryRect(&v53, (uint64_t)&v57, *(double *)&v64[20], *((double *)&v64[20] + 1), *(double *)&v64[21], *((double *)&v64[21] + 1));
          long long v73 = v57;
          long long v74 = v58;
          uint64_t v75 = v59;
          int v13 = v60;
          uint64_t v71 = v61;
          int v72 = v62;
          uint64_t v22 = v63;
          long long v68 = v64[12];
          long long v69 = v64[13];
          uint64_t v70 = *(void *)&v64[14];
          int v23 = DWORD2(v64[14]);
          int v67 = DWORD1(v64[15]);
          uint64_t v66 = *(void *)((char *)&v64[14] + 12);
          uint64_t v24 = *((void *)&v64[15] + 1);
LABEL_27:
          int v50 = v22;
          uint64_t v51 = v24;
          long long v57 = v73;
          long long v58 = v74;
          uint64_t v59 = v75;
          int v60 = v13;
          uint64_t v61 = v71;
          int v62 = v72;
          uint64_t v63 = v22;
          double v25 = FigGeometryRectGetCGRect((uint64_t)&v57);
          CGFloat v27 = v26;
          CGFloat v48 = v26;
          CGFloat v29 = v28;
          CGFloat v31 = v30;
          long long v57 = v68;
          long long v58 = v69;
          uint64_t v59 = v70;
          int v60 = v23;
          uint64_t v61 = v66;
          int v62 = v67;
          uint64_t v63 = v51;
          double v32 = FigGeometryRectGetCGRect((uint64_t)&v57);
          CGFloat v52 = v33;
          CGFloat v35 = v34;
          CGFloat v37 = v36;
          v78.origin.x = v25;
          v78.origin.y = v27;
          v78.size.width = v29;
          v78.size.height = v31;
          double MinX = CGRectGetMinX(v78);
          v79.origin.x = v25;
          v79.origin.y = v27;
          v79.size.width = v29;
          v79.size.height = v31;
          double MaxX = CGRectGetMaxX(v79);
          v80.origin.x = v32;
          v80.origin.y = v52;
          v80.size.width = v35;
          v80.size.height = v37;
          double v39 = CGRectGetMinX(v80);
          v81.origin.x = v32;
          v81.origin.y = v52;
          v81.size.width = v35;
          v81.size.height = v37;
          CGFloat v40 = (CGRectGetMaxX(v81) - v39) / (MaxX - MinX);
          *(CGFloat *)(v12 + 24) = v40;
          *(double *)(v12 + 32) = v39 - MinX * v40;
          CGFloat v41 = v25;
          v82.origin.x = v25;
          v82.origin.y = v48;
          v82.size.width = v29;
          v82.size.height = v31;
          double MinY = CGRectGetMinY(v82);
          v83.origin.x = v41;
          v83.origin.y = v48;
          v83.size.width = v29;
          v83.size.height = v31;
          double MaxY = CGRectGetMaxY(v83);
          v84.origin.x = v32;
          v84.origin.y = v52;
          v84.size.width = v35;
          v84.size.height = v37;
          double v44 = CGRectGetMinY(v84);
          v85.origin.x = v32;
          v85.origin.y = v52;
          v85.size.width = v35;
          v85.size.height = v37;
          CGFloat v45 = (CGRectGetMaxY(v85) - v44) / (MaxY - MinY);
          *(CGFloat *)(v12 + 40) = v45;
          *(double *)(v12 + 48) = v44 - MinY * v45;
          *(_DWORD *)(v12 + 64) = v13;
          *(_DWORD *)(v12 + 80) = v50;
          *(_DWORD *)(v12 + 96) = v23;
          *(_DWORD *)(v12 + 112) = v51;
          *a6 = v12;
          return 0;
        }
      }
      else if (a3 == 1)
      {
        if (a5 == 2)
        {
          long long v73 = __src[12];
          long long v74 = __src[13];
          uint64_t v75 = *(void *)&__src[14];
          uint64_t v71 = *(void *)((char *)&__src[14] + 12);
          int v13 = DWORD2(__src[14]);
          int v72 = DWORD1(__src[15]);
          uint64_t v49 = *((void *)&__src[15] + 1);
          double v15 = *((double *)&__src[20] + 1);
          double v14 = *(double *)&__src[20];
          double v17 = *((double *)&__src[21] + 1);
          double v16 = *(double *)&__src[21];
          long long v53 = v64[0];
          long long v54 = v64[1];
          long long v18 = v64[2];
          long long v19 = v64[3];
          goto LABEL_25;
        }
        if (a5 == 1)
        {
          long long v73 = __src[12];
          long long v74 = __src[13];
          uint64_t v75 = *(void *)&__src[14];
          uint64_t v71 = *(void *)((char *)&__src[14] + 12);
          int v13 = DWORD2(__src[14]);
          int v72 = DWORD1(__src[15]);
          uint64_t v49 = *((void *)&__src[15] + 1);
          double v15 = *((double *)&__src[20] + 1);
          double v14 = *(double *)&__src[20];
          double v17 = *((double *)&__src[21] + 1);
          double v16 = *(double *)&__src[21];
          long long v53 = v64[16];
          long long v54 = v64[17];
          long long v18 = v64[18];
          long long v19 = v64[19];
LABEL_25:
          long long v55 = v18;
          long long v56 = v19;
          _figApplyNormalizedCGRectToFigGeometryRect(&v53, (uint64_t)&v57, v14, v15, v16, v17);
          uint64_t v22 = v49;
          long long v68 = v57;
          long long v69 = v58;
          uint64_t v70 = v59;
          int v23 = v60;
          uint64_t v66 = v61;
          int v67 = v62;
          uint64_t v24 = v63;
          goto LABEL_27;
        }
      }
      int v23 = 0;
      int v13 = 0;
      uint64_t v22 = 0;
      uint64_t v24 = 0;
      goto LABEL_27;
    }
  }
  uint64_t v46 = FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  CFRelease((CFTypeRef)v12);
  return v46;
}

uint64_t _figUpdateCoordinateSpaceGeometryCache(uint64_t a1, uint64_t a2)
{
  uint64_t v250 = *MEMORY[0x1E4F143B8];
  uint64_t v248 = 0;
  int v249 = 0;
  uint64_t v246 = 0;
  int v247 = 0;
  uint64_t v244 = 0;
  int v245 = 0;
  uint64_t v242 = 0;
  int v243 = 0;
  uint64_t v240 = 0;
  int v241 = 0;
  uint64_t v238 = 0;
  int v239 = 0;
  long long v209 = 0u;
  long long v210 = 0u;
  long long v211 = 0u;
  long long v212 = 0u;
  long long v207 = 0u;
  long long v208 = 0u;
  long long v205 = 0u;
  long long v206 = 0u;
  int v2 = *(_DWORD *)(a1 + 16);
  uint64_t v224 = 0;
  int v225 = 0;
  uint64_t v222 = 0;
  int v223 = 0;
  uint64_t v220 = 0;
  int v221 = 0;
  if ((v2 & 1) == 0) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = (uint64_t *)(a1 + 68);
  uint64_t v6 = *(void *)(a1 + 68);
  uint64_t v7 = (uint64_t *)(a1 + 36);
  uint64_t v248 = *(void *)(a1 + 36);
  int v8 = *(_DWORD *)(a1 + 48);
  int v249 = *(_DWORD *)(a1 + 44);
  CFTypeRef v9 = (uint64_t *)(a1 + 52);
  uint64_t v246 = *(void *)(a1 + 52);
  int v10 = *(_DWORD *)(a1 + 64);
  int v247 = *(_DWORD *)(a1 + 60);
  uint64_t v192 = *(void *)(a1 + 24);
  uint64_t v244 = v6;
  int v245 = *(_DWORD *)(a1 + 76);
  int v11 = *(_DWORD *)(a1 + 32);
  if (v11 != v10 || v8 != *(_DWORD *)(a1 + 80)) {
    return result;
  }
  int v13 = *(_DWORD *)(a1 + 84);
  uint64_t v236 = *v7;
  int v237 = *(_DWORD *)(a1 + 44);
  uint64_t v234 = *v9;
  int v235 = *(_DWORD *)(a1 + 60);
  uint64_t v232 = *v5;
  int v233 = *(_DWORD *)(a1 + 76);
  int v188 = v8;
  int v189 = v11;
  if ((v2 & 2) == 0)
  {
    int v14 = v8;
    uint64_t v15 = v192;
    int v16 = v11;
    int v17 = v11;
    int v18 = v8;
    int v19 = v13;
    goto LABEL_37;
  }
  double v20 = *(double *)(a1 + 88);
  int v21 = *(_DWORD *)(a1 + 96);
  int v22 = v13;
  int v190 = *(_DWORD *)(a1 + 100);
  double v23 = *(double *)(a1 + 104);
  int v24 = *(_DWORD *)(a1 + 112);
  int v185 = *(_DWORD *)(a1 + 116);
  double v25 = *(double *)(a1 + 120);
  int v27 = *(_DWORD *)(a1 + 128);
  int v26 = *(_DWORD *)(a1 + 132);
  double v28 = *(double *)(a1 + 136);
  int v29 = *(_DWORD *)(a1 + 144);
  int v183 = *(_DWORD *)(a1 + 148);
  *(void *)uint64_t v213 = v192;
  *(void *)&v213[12] = *v7;
  int v30 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)&v213[8] = v11;
  *(_DWORD *)&v213[20] = v30;
  *(void *)&v213[28] = *v9;
  int v31 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)&v213[24] = v8;
  *(_DWORD *)&v213[36] = v31;
  *(void *)&v213[44] = *v5;
  int v32 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)&v213[40] = v11;
  *(_DWORD *)&v213[52] = v32;
  *(_DWORD *)&v213[56] = v8;
  int v33 = v22;
  *(_DWORD *)&v213[60] = v22;
  v251.origin.double x = FigGeometryRectGetCGRect((uint64_t)v213);
  double x = v251.origin.x;
  double y = v251.origin.y;
  double width = v251.size.width;
  double height = v251.size.height;
  double MaxX = CGRectGetMaxX(v251);
  v252.origin.double x = x;
  v252.origin.double y = y;
  v252.size.double width = width;
  v252.size.double height = height;
  double MaxY = CGRectGetMaxY(v252);
  if (v21 != v189 && v21 != 622862368) {
    return 0;
  }
  if (v27 != v188 && v27 != 622862368 || v24 != v189 && v24 != 622862368) {
    return 0;
  }
  uint64_t result = 0;
  BOOL v39 = v29 == 622862368 || v29 == v188;
  if (!v39 || (v190 & 0x1D) != 1 || (v26 & 0x1D) != 1 || (v185 & 0x1D) != 1 || (v183 & 0x1D) != 1) {
    return result;
  }
  int v13 = v33;
  if (v21 == 622862368 && v189 != 622862368) {
    double v20 = v20 * width / 100.0;
  }
  double v40 = v25;
  if (v27 == 622862368)
  {
    double v40 = v25;
    if (v188 != 622862368) {
      double v40 = v25 * height / 100.0;
    }
  }
  if (v24 == 622862368 && v189 != 622862368) {
    double v23 = v23 * width / 100.0;
  }
  if (v29 == v188) {
    double v41 = v25;
  }
  else {
    double v41 = v28;
  }
  if (v29 == 622862368 && v188 != 622862368) {
    double v41 = v28 * height / 100.0;
  }
  uint64_t v193 = v192;
  int v194 = v189;
  uint64_t v195 = v236;
  int v196 = v237;
  int v197 = v188;
  uint64_t v198 = v234;
  int v199 = v235;
  int v200 = v189;
  uint64_t v201 = v232;
  int v202 = v233;
  int v203 = v188;
  int v204 = v33;
  FigGeometryRectMakeFromCGRectAndReferenceUnits(&v193, (uint64_t)v213, x + v20, y + v40, MaxX - v23 - (x + v20), MaxY - v41 - (y + v40));
  int v8 = v188;
  int v11 = v189;
  uint64_t v15 = *(void *)v213;
  uint64_t v236 = *(void *)&v213[12];
  int v16 = *(_DWORD *)&v213[8];
  int v237 = *(_DWORD *)&v213[20];
  uint64_t v234 = *(void *)&v213[28];
  int v14 = *(_DWORD *)&v213[24];
  int v235 = *(_DWORD *)&v213[36];
  uint64_t v232 = *(void *)&v213[44];
  int v17 = *(_DWORD *)&v213[40];
  int v233 = *(_DWORD *)&v213[52];
  uint64_t v5 = &v232;
  CFTypeRef v9 = &v234;
  uint64_t v7 = &v236;
  int v18 = *(_DWORD *)&v213[56];
  int v19 = *(_DWORD *)&v213[60];
LABEL_37:
  uint64_t v230 = *v7;
  int v231 = *((_DWORD *)v7 + 2);
  uint64_t v228 = *v9;
  int v229 = *((_DWORD *)v9 + 2);
  int v227 = *((_DWORD *)v5 + 2);
  uint64_t v226 = *v5;
  uint64_t v242 = v230;
  int v243 = v231;
  int v241 = v229;
  uint64_t v42 = v15;
  uint64_t v240 = v228;
  int v43 = v16;
  int v44 = v14;
  uint64_t v238 = v226;
  int v45 = v17;
  int v46 = v17;
  int v47 = v18;
  int v48 = v19;
  int v239 = v227;
  uint64_t v186 = v15;
  int v191 = v18;
  int v187 = v13;
  if ((v2 & 8) != 0)
  {
    int v49 = v19;
    uint64_t v50 = *(void *)(a1 + 280);
    if ((v2 & 0x10) != 0) {
      int v51 = *(_DWORD *)(a1 + 288);
    }
    else {
      int v51 = 0;
    }
    uint64_t v218 = v236;
    int v219 = v237;
    uint64_t v216 = v234;
    int v217 = v235;
    uint64_t v214 = v232;
    int v215 = v233;
    uint64_t v195 = v236;
    uint64_t v193 = v15;
    int v194 = v16;
    uint64_t v198 = v234;
    int v196 = v237;
    int v197 = v14;
    int v199 = v235;
    int v200 = v46;
    uint64_t v201 = v232;
    int v202 = v233;
    int v203 = v18;
    int v204 = v49;
    *(void *)uint64_t v213 = v15;
    *(void *)&v213[12] = v236;
    *(_DWORD *)&v213[8] = v16;
    *(_DWORD *)&v213[20] = v237;
    *(void *)&v213[28] = v234;
    *(_DWORD *)&v213[24] = v14;
    *(_DWORD *)&v213[36] = v235;
    *(void *)&v213[44] = v232;
    *(_DWORD *)&v213[40] = v46;
    *(_DWORD *)&v213[52] = v233;
    *(_DWORD *)&v213[56] = v18;
    *(_DWORD *)&v213[60] = v49;
    v253.origin.double x = FigGeometryRectGetCGRect((uint64_t)v213);
    double v52 = v253.origin.x;
    double v53 = v253.origin.y;
    CGFloat v54 = v253.size.width;
    CGFloat v55 = v253.size.height;
    CGRect v254 = CGRectOffset(v253, -v253.origin.x, -v253.origin.y);
    double v56 = v254.origin.x;
    double v57 = v254.origin.y;
    double v58 = v254.size.height;
    double v59 = (double)(int)v50;
    double v60 = (double)SHIDWORD(v50);
    double v61 = v254.size.height * (double)(int)v50 / (double)SHIDWORD(v50);
    if (v61 > v254.size.width)
    {
      CGFloat v62 = v254.size.width * v60;
      double v58 = v62 / v59;
      double v61 = v62 / v59 * v59 / v60;
    }
    if (v51 > 1918989157)
    {
      int v19 = v49;
      if (v51 <= 1920166265)
      {
        CGFloat recta = v55;
        if (v51 == 1918989158 || v51 == 1918989168)
        {
          v273.origin.double x = v56;
          double v92 = v56;
          v273.origin.double y = v57;
          v273.size.double width = v61;
          v273.size.double height = v58;
          CGFloat v93 = v57;
          double v162 = v57;
          double v160 = CGRectGetWidth(v273);
          v274.origin.double x = v92;
          v274.origin.double y = v93;
          v274.size.double width = v61;
          v274.size.double height = v58;
          double v94 = CGRectGetHeight(v274);
          v275.origin.double x = v52;
          v275.origin.double y = v53;
          v275.size.double width = v54;
          v275.size.double height = recta;
          double v95 = CGRectGetWidth(v275);
          v276.origin.double x = v52;
          v276.origin.double y = v53;
          v276.size.double width = v54;
          v276.size.double height = recta;
          double v96 = CGRectGetHeight(v276) / v94;
          if (v95 / v160 >= v96) {
            double v97 = v96;
          }
          else {
            double v97 = v95 / v160;
          }
          if (v95 / v160 > v96) {
            double v96 = v95 / v160;
          }
          if (v51 != 1918989158) {
            double v96 = v97;
          }
          CGFloat v159 = v94 * v96;
          CGFloat v98 = v160 * v96;
          CGFloat v99 = v52 + v92;
          v277.origin.double x = v52;
          v277.origin.double y = v53;
          v277.size.double width = v54;
          v277.size.double height = recta;
          double v100 = CGRectGetMaxX(v277);
          v278.origin.double x = v99;
          v278.origin.double y = v53 + v162;
          v278.size.double width = v98;
          v278.size.double height = v159;
          double v178 = v100 - CGRectGetMaxX(v278);
          v279.origin.double x = v52;
          v279.origin.double y = v53;
          v279.size.double width = v54;
          v279.size.double height = recta;
          double v101 = CGRectGetMaxY(v279);
          v280.origin.double x = v99;
          v280.origin.double y = v53 + v162;
          v280.size.double width = v98;
          v280.size.double height = v159;
          double v102 = v101 - CGRectGetMaxY(v280);
          uint64_t v15 = v186;
          double v81 = v178 * 0.5;
          double v76 = v102 * 0.5;
          CGFloat v77 = v99;
          double v78 = v53 + v162;
          CGFloat v79 = v98;
          CGFloat v80 = v159;
        }
        else
        {
          if (v51 != 1919510376) {
            goto LABEL_87;
          }
          v261.origin.double x = v52;
          v261.origin.double y = v53;
          v261.size.double width = v54;
          v261.size.double height = v55;
          CGFloat v176 = v56;
          CGFloat v71 = v57;
          double v72 = CGRectGetMaxX(v261);
          v262.origin.double x = v56;
          v262.origin.double y = v71;
          CGFloat v73 = v71;
          v262.size.double width = v61;
          v262.size.double height = v58;
          double v74 = v72 - CGRectGetMaxX(v262);
          v263.origin.double x = v52;
          v263.origin.double y = v53;
          v263.size.double width = v54;
          v263.size.double height = recta;
          double v75 = CGRectGetMaxY(v263);
          v264.origin.double x = v176;
          v264.origin.double y = v73;
          v264.size.double width = v61;
          v264.size.double height = v58;
          double v76 = (v75 - CGRectGetMaxY(v264)) * 0.5;
          CGFloat v77 = v176;
          double v78 = v73;
          CGFloat v79 = v61;
          CGFloat v80 = v58;
          double v81 = v74;
          uint64_t v15 = v186;
        }
        CGRect v281 = CGRectOffset(*(CGRect *)&v77, v81, v76);
        double v56 = v281.origin.x;
        double v57 = v281.origin.y;
        double v61 = v281.size.width;
        double v58 = v281.size.height;
        goto LABEL_87;
      }
      if (v51 > 1953460255)
      {
        CGFloat v177 = v56;
        if (v51 == 1953460256)
        {
          v293.origin.double x = v52;
          v293.origin.double y = v53;
          v293.size.double width = v54;
          v293.size.double height = v55;
          CGFloat v113 = v57;
          rectCFIndex i = CGRectGetMaxX(v293);
          v294.origin.double x = v177;
          v294.origin.double y = v113;
          v294.size.double width = v61;
          v294.size.double height = v58;
          rectunsigned int j = recti - CGRectGetMaxX(v294);
          v295.origin.double x = v52;
          v295.origin.double y = v53;
          v295.size.double width = v54;
          v295.size.double height = v55;
          double MinY = CGRectGetMinY(v295);
          v296.origin.double x = v177;
          v296.origin.double y = v113;
          v296.size.double width = v61;
          v296.size.double height = v58;
          double v86 = MinY - CGRectGetMinY(v296);
          double v91 = rectj * 0.5;
          CGFloat v87 = v177;
          CGFloat v88 = v113;
          double v89 = v61;
          double v90 = v58;
          goto LABEL_86;
        }
        if (v51 == 1953655143)
        {
          v269.origin.double x = v52;
          v269.origin.double y = v53;
          v269.size.double width = v54;
          v269.size.double height = v55;
          CGFloat v63 = v57;
          double rect = CGRectGetMaxX(v269);
          CGFloat v64 = v177;
          v270.origin.double x = v177;
          v270.origin.double y = v63;
          v270.size.double width = v61;
          v270.size.double height = v58;
          double MinX = CGRectGetMaxX(v270);
          goto LABEL_65;
        }
      }
      else if (v51 == 1920166266)
      {
        double v58 = v55;
        double v61 = v54;
        double v57 = v53;
        double v56 = v52;
      }
      else if (v51 == 1953260902)
      {
        v255.origin.double x = v52;
        v255.origin.double y = v53;
        v255.size.double width = v54;
        v255.size.double height = v55;
        CGFloat v174 = v56;
        CGFloat v63 = v57;
        double rect = CGRectGetMinX(v255);
        CGFloat v64 = v174;
        v256.origin.double x = v174;
        v256.origin.double y = v63;
        v256.size.double width = v61;
        v256.size.double height = v58;
        double MinX = CGRectGetMinX(v256);
LABEL_65:
        double rectg = rect - MinX;
        v271.origin.double x = v52;
        v271.origin.double y = v53;
        v271.size.double width = v54;
        v271.size.double height = v55;
        double v85 = CGRectGetMinY(v271);
        v272.origin.double x = v64;
        v272.origin.double y = v63;
        v272.size.double width = v61;
        v272.size.double height = v58;
        double v86 = v85 - CGRectGetMinY(v272);
        CGFloat v87 = v64;
        CGFloat v88 = v63;
        double v89 = v61;
        double v90 = v58;
        double v91 = rectg;
        uint64_t v15 = v186;
LABEL_86:
        CGRect v297 = CGRectOffset(*(CGRect *)&v87, v91, v86);
        double v56 = v297.origin.x;
        double v57 = v297.origin.y;
        double v61 = v297.size.width;
        double v58 = v297.size.height;
      }
LABEL_87:
      *(void *)uint64_t v213 = v15;
      *(void *)&v213[12] = v218;
      *(_DWORD *)&v213[8] = v16;
      *(_DWORD *)&v213[20] = v219;
      *(void *)&v213[28] = v216;
      *(_DWORD *)&v213[24] = v14;
      *(_DWORD *)&v213[36] = v217;
      *(void *)&v213[44] = v214;
      *(_DWORD *)&v213[40] = v46;
      *(_DWORD *)&v213[52] = v215;
      *(_DWORD *)&v213[56] = v18;
      *(_DWORD *)&v213[60] = v19;
      FigGeometryRectMakeFromCGRectAndReferenceUnits(v213, (uint64_t)&v193, v56, v57, v61, v58);
      uint64_t v42 = v193;
      uint64_t v224 = v195;
      int v225 = v196;
      int v43 = v194;
      int v44 = v197;
      uint64_t v222 = v198;
      int v223 = v199;
      int v221 = v202;
      uint64_t v220 = v201;
      int v45 = v200;
      int v47 = v203;
      int v48 = v204;
      int v237 = v196;
      uint64_t v236 = v195;
      int v235 = v199;
      uint64_t v234 = v198;
      int v233 = v202;
      uint64_t v232 = v201;
      int v8 = v188;
      int v11 = v189;
      goto LABEL_88;
    }
    int v19 = v49;
    CGFloat v175 = v56;
    if (v51 > 1651665254)
    {
      if (v51 == 1651665255)
      {
        v288.origin.double x = v52;
        v288.origin.double y = v53;
        v288.size.double width = v54;
        v288.size.double height = v55;
        CGFloat v82 = v57;
        double rectc = CGRectGetMaxX(v288);
        CGFloat v83 = v175;
        v289.origin.double x = v175;
        v289.origin.double y = v82;
        v289.size.double width = v61;
        v289.size.double height = v58;
        double v111 = CGRectGetMaxX(v289);
LABEL_81:
        double rectb = rectc - v111;
        v290.origin.double x = v52;
        v290.origin.double y = v53;
        v290.size.double width = v54;
        v290.size.double height = v55;
        double v112 = CGRectGetMaxY(v290);
        v291.origin.double x = v83;
        v291.origin.double y = v82;
        v291.size.double width = v61;
        v291.size.double height = v58;
        double v69 = v112 - CGRectGetMaxY(v291);
LABEL_82:
        CGFloat v107 = v83;
        CGFloat v108 = v82;
        double v109 = v61;
        double v110 = v58;
        double v70 = rectb;
        uint64_t v15 = v186;
        goto LABEL_83;
      }
      if (v51 != 1667591796)
      {
        if (v51 != 1818584692) {
          goto LABEL_87;
        }
        v265.origin.double x = v52;
        v265.origin.double y = v53;
        v265.size.double width = v54;
        v265.size.double height = v55;
        CGFloat v82 = v57;
        double rectf = CGRectGetMinX(v265);
        CGFloat v83 = v175;
        v266.origin.double x = v175;
        v266.origin.double y = v82;
        v266.size.double width = v61;
        v266.size.double height = v58;
        double rectb = rectf - CGRectGetMinX(v266);
        v267.origin.double x = v52;
        v267.origin.double y = v53;
        v267.size.double width = v54;
        v267.size.double height = v55;
        double v84 = CGRectGetMaxY(v267);
        v268.origin.double x = v175;
        v268.origin.double y = v82;
        v268.size.double width = v61;
        v268.size.double height = v58;
        double v69 = (v84 - CGRectGetMaxY(v268)) * 0.5;
        goto LABEL_82;
      }
    }
    else if (v51)
    {
      if (v51 != 1651271014)
      {
        if (v51 != 1651471476) {
          goto LABEL_87;
        }
        v257.origin.double x = v52;
        v257.origin.double y = v53;
        v257.size.double width = v54;
        v257.size.double height = v55;
        CGFloat v66 = v57;
        double rectd = CGRectGetMaxX(v257);
        v258.origin.double x = v175;
        v258.origin.double y = v66;
        v258.size.double width = v61;
        v258.size.double height = v58;
        double recte = rectd - CGRectGetMaxX(v258);
        v259.origin.double x = v52;
        v259.origin.double y = v53;
        v259.size.double width = v54;
        v259.size.double height = v55;
        double v67 = CGRectGetMaxY(v259);
        CGFloat v68 = v175;
        v260.origin.double x = v175;
        v260.origin.double y = v66;
        v260.size.double width = v61;
        v260.size.double height = v58;
        double v69 = v67 - CGRectGetMaxY(v260);
        double v70 = recte * 0.5;
        goto LABEL_77;
      }
      v286.origin.double x = v52;
      v286.origin.double y = v53;
      v286.size.double width = v54;
      v286.size.double height = v55;
      CGFloat v82 = v57;
      double rectc = CGRectGetMinX(v286);
      CGFloat v83 = v175;
      v287.origin.double x = v175;
      v287.origin.double y = v82;
      v287.size.double width = v61;
      v287.size.double height = v58;
      double v111 = CGRectGetMinX(v287);
      goto LABEL_81;
    }
    v282.origin.double x = v52;
    v282.origin.double y = v53;
    v282.size.double width = v54;
    v282.size.double height = v55;
    CGFloat v161 = v54;
    CGFloat v103 = v57;
    double v104 = CGRectGetMaxX(v282);
    v283.origin.double x = v56;
    v283.origin.double y = v103;
    CGFloat v66 = v103;
    v283.size.double width = v61;
    v283.size.double height = v58;
    double recth = v104 - CGRectGetMaxX(v283);
    v284.origin.double x = v52;
    v284.origin.double y = v53;
    v284.size.double width = v161;
    v284.size.double height = v55;
    double v105 = CGRectGetMaxY(v284);
    CGFloat v68 = v175;
    v285.origin.double x = v175;
    v285.origin.double y = v66;
    v285.size.double width = v61;
    v285.size.double height = v58;
    double v106 = v105 - CGRectGetMaxY(v285);
    uint64_t v15 = v186;
    double v70 = recth * 0.5;
    double v69 = v106 * 0.5;
LABEL_77:
    CGFloat v107 = v68;
    CGFloat v108 = v66;
    double v109 = v61;
    double v110 = v58;
LABEL_83:
    CGRect v292 = CGRectOffset(*(CGRect *)&v107, v70, v69);
    double v56 = v292.origin.x;
    double v57 = v292.origin.y;
    double v61 = v292.size.width;
    double v58 = v292.size.height;
    goto LABEL_87;
  }
LABEL_88:
  uint64_t v179 = v42;
  int v180 = v16;
  int v182 = v46;
  int v184 = v14;
  long long v115 = *(_OWORD *)(a1 + 232);
  long long v209 = *(_OWORD *)(a1 + 216);
  long long v210 = v115;
  long long v116 = *(_OWORD *)(a1 + 264);
  long long v211 = *(_OWORD *)(a1 + 248);
  long long v212 = v116;
  *(void *)uint64_t v213 = v192;
  *(void *)&v213[12] = v248;
  *(_DWORD *)&v213[8] = v11;
  *(_DWORD *)&v213[20] = v249;
  *(void *)&v213[28] = v246;
  *(_DWORD *)&v213[24] = v8;
  *(_DWORD *)&v213[36] = v247;
  *(void *)&v213[44] = v244;
  *(_DWORD *)&v213[40] = v11;
  *(_DWORD *)&v213[52] = v245;
  *(_DWORD *)&v213[56] = v8;
  *(_DWORD *)&v213[60] = v13;
  int v117 = v45;
  int v118 = v8;
  int v119 = v11;
  int v120 = v44;
  int v121 = v43;
  int v122 = v47;
  int v123 = v48;
  double v124 = FigGeometryRectGetCGRect((uint64_t)v213);
  double v126 = v125;
  double v128 = v127;
  double v130 = v129;
  *(void *)uint64_t v213 = v42;
  *(void *)&v213[12] = v236;
  *(_DWORD *)&v213[8] = v121;
  *(_DWORD *)&v213[20] = v237;
  *(void *)&v213[28] = v234;
  *(_DWORD *)&v213[24] = v120;
  *(_DWORD *)&v213[36] = v235;
  *(void *)&v213[44] = v232;
  *(_DWORD *)&v213[40] = v117;
  *(_DWORD *)&v213[52] = v233;
  *(_DWORD *)&v213[56] = v122;
  *(_DWORD *)&v213[60] = v123;
  double v131 = FigGeometryRectGetCGRect((uint64_t)v213);
  double v133 = v132;
  double v135 = v134;
  double v137 = v136;
  *(_OWORD *)uint64_t v213 = v209;
  *(_OWORD *)&v213[16] = v210;
  *(_OWORD *)&v213[32] = v211;
  *(_OWORD *)&v213[48] = v212;
  FigGeometryRectGetCGRect((uint64_t)v213);
  double v139 = v138 / v135;
  double v141 = v140 / v137;
  double v142 = v133 - v126;
  double v143 = -((v131 - v124) * v139);
  double v144 = 0.0;
  if (v131 - v124 == 0.0) {
    double v143 = 0.0;
  }
  if (v142 != 0.0) {
    double v144 = -(v142 * v141);
  }
  double v145 = (v131 - v124) / v128;
  double v146 = v142 / v130;
  *(_OWORD *)uint64_t v213 = v209;
  *(_OWORD *)&v213[16] = v210;
  *(_OWORD *)&v213[32] = v211;
  *(_OWORD *)&v213[48] = v212;
  FigGeometryRectMakeFromCGRectAndReferenceUnits(v213, (uint64_t)&v205, v143, v144, v128 * v139, v130 * v141);
  *(void *)a2 = v192;
  *(_DWORD *)(a2 + 8) = v119;
  *(void *)(a2 + 12) = v248;
  *(_DWORD *)(a2 + 20) = v249;
  *(_DWORD *)(a2 + 24) = v118;
  *(void *)(a2 + 28) = v246;
  *(_DWORD *)(a2 + 36) = v247;
  *(_DWORD *)(a2 + 40) = v119;
  *(void *)(a2 + 44) = v244;
  *(_DWORD *)(a2 + 52) = v245;
  *(_DWORD *)(a2 + 56) = v118;
  *(_DWORD *)(a2 + 60) = v187;
  *(void *)(a2 + 64) = v186;
  *(_DWORD *)(a2 + 72) = v180;
  int v147 = v243;
  *(void *)(a2 + 76) = v242;
  *(_DWORD *)(a2 + 84) = v147;
  *(_DWORD *)(a2 + 88) = v184;
  int v148 = v241;
  *(void *)(a2 + 92) = v240;
  *(_DWORD *)(a2 + 100) = v148;
  *(_DWORD *)(a2 + 104) = v182;
  int v149 = v239;
  *(void *)(a2 + 108) = v238;
  *(_DWORD *)(a2 + 116) = v149;
  *(_DWORD *)(a2 + 120) = v191;
  *(_DWORD *)(a2 + 124) = v19;
  *(void *)(a2 + 128) = v179;
  *(_DWORD *)(a2 + 136) = v121;
  int v150 = v237;
  *(void *)(a2 + 140) = v236;
  *(_DWORD *)(a2 + 148) = v150;
  *(_DWORD *)(a2 + 152) = v120;
  int v151 = v235;
  *(void *)(a2 + 156) = v234;
  *(_DWORD *)(a2 + 164) = v151;
  *(_DWORD *)(a2 + 168) = v117;
  int v152 = v233;
  *(void *)(a2 + 172) = v232;
  *(_DWORD *)(a2 + 180) = v152;
  *(_DWORD *)(a2 + 184) = v122;
  *(_DWORD *)(a2 + 188) = v123;
  long long v153 = v209;
  long long v154 = v210;
  long long v155 = v212;
  *(_OWORD *)(a2 + 224) = v211;
  *(_OWORD *)(a2 + 240) = v155;
  *(_OWORD *)(a2 + 192) = v153;
  *(_OWORD *)(a2 + 208) = v154;
  long long v156 = v205;
  long long v157 = v206;
  long long v158 = v208;
  *(_OWORD *)(a2 + 288) = v207;
  *(_OWORD *)(a2 + 304) = v158;
  *(_OWORD *)(a2 + 256) = v156;
  *(_OWORD *)(a2 + 272) = v157;
  *(double *)(a2 + 320) = v145;
  *(double *)(a2 + 328) = v146;
  uint64_t result = 1;
  *(double *)(a2 + 336) = v135 / v128;
  *(double *)(a2 + 344) = v137 / v130;
  return result;
}

_DWORD *_figApplyNormalizedCGRectToFigGeometryRect@<X0>(long long *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  long long v12 = a1[1];
  long long v21 = *a1;
  long long v22 = v12;
  long long v13 = a1[3];
  long long v23 = a1[2];
  long long v24 = v13;
  double CGRect = FigGeometryRectGetCGRect((uint64_t)&v21);
  long long v18 = a1[1];
  long long v21 = *a1;
  long long v22 = v18;
  long long v19 = a1[3];
  long long v23 = a1[2];
  long long v24 = v19;
  return FigGeometryRectMakeFromCGRectAndReferenceUnits(&v21, a2, CGRect + v15 * a3, v16 + v17 * a4, a5 * v15, a6 * v17);
}

uint64_t FigGeometryMappingCreateInverseMapping(uint64_t a1, uint64_t *a2)
{
  if (!a1 || !a2) {
    goto LABEL_19;
  }
  CFTypeID v4 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFigGeometryMappingTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
  }
  if (v4 == sFigGeometryMappingID && *(_DWORD *)(a1 + 20) == 1)
  {
    *a2 = 0;
    CFGetAllocator((CFTypeRef)a1);
    if (sRegisterFigGeometryMappingTypeOnce != -1) {
      dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v6 = Instance;
      memcpy((void *)(Instance + 16), (const void *)(a1 + 16), 0x348uLL);
      uint64_t v7 = *(const void **)(v6 + 128);
      if (v7) {
        CFRetain(v7);
      }
      int v8 = *(const void **)(v6 + 136);
      if (v8) {
        CFRetain(v8);
      }
      *(_DWORD *)(v6 + 16) = 1835102313;
      *(unsigned char *)(v6 + 120) = 1;
      double v9 = *(double *)(a1 + 24);
      double v10 = 1.0 / v9;
      double v11 = -*(double *)(a1 + 32) / v9;
      *(double *)(v6 + 24) = v10;
      *(double *)(v6 + 32) = v11;
      double v12 = *(double *)(a1 + 40);
      double v13 = 1.0 / v12;
      double v14 = -*(double *)(a1 + 48) / v12;
      *(double *)(v6 + 40) = v13;
      *(double *)(v6 + 48) = v14;
      long long v15 = *(_OWORD *)(a1 + 88);
      *(_OWORD *)(v6 + 72) = *(_OWORD *)(a1 + 104);
      *(_OWORD *)(v6 + 56) = v15;
      long long v16 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)(v6 + 104) = *(_OWORD *)(a1 + 72);
      *(_OWORD *)(v6 + 88) = v16;
      memcpy((void *)(v6 + 144), (const void *)(a1 + 496), 0x160uLL);
      memcpy((void *)(v6 + 496), (const void *)(a1 + 144), 0x160uLL);
      *(_DWORD *)(v6 + 848) = *(_DWORD *)(a1 + 852);
      *(_DWORD *)(v6 + 852) = *(_DWORD *)(a1 + 848);
      *a2 = v6;
      return 0;
    }
    uint64_t v18 = 4294949965;
  }
  else
  {
LABEL_19:
    uint64_t v18 = 4294949966;
  }

  return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
}

uint64_t FigGeometryMappingCreateCEA608Mappings(uint64_t a1, uint64_t *a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  CFTypeRef v82 = 0;
  uint64_t v83 = a3;
  CFTypeRef v80 = 0;
  CFTypeRef v81 = 0;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  memset(v75, 0, sizeof(v75));
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  memset(v70, 0, sizeof(v70));
  CFTypeRef v68 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v67 = 0;
  if (a4 && a5 && a6 && *((_DWORD *)a2 + 2) == 1886679840 && *((_DWORD *)a2 + 6) == 1886679840)
  {
    FigGeometryDimensionMake();
    uint64_t v12 = v11;
    uint64_t v14 = v13;
    FigGeometryDimensionMake();
    FigGeometryPointMake(v12, v14, v15, v16, v66);
    FigGeometryRectMake(v66[0], v66[1], v66[2], v66[3], *a2, a2[1], a2[2], a2[3], &v76);
    FigGeometryDimensionMake();
    uint64_t v18 = v17;
    uint64_t v20 = v19;
    FigGeometryDimensionMake();
    uint64_t v22 = v21;
    uint64_t v24 = v23;
    FigGeometryDimensionMake();
    uint64_t v26 = v25;
    uint64_t v28 = v27;
    FigGeometryDimensionMake();
    FigGeometryRectMake(v22, v24, v26, v28, v18, v20, v29, v30, v75);
    FigGeometryDimensionMake();
    uint64_t v32 = v31;
    uint64_t v34 = v33;
    FigGeometryDimensionMake();
    uint64_t v36 = v35;
    uint64_t v38 = v37;
    FigGeometryDimensionMake();
    uint64_t v40 = v39;
    uint64_t v42 = v41;
    FigGeometryDimensionMake();
    FigGeometryRectMake(v32, v34, v36, v38, v40, v42, v43, v44, &v71);
    FigGeometryDimensionMake();
    uint64_t v46 = v45;
    uint64_t v48 = v47;
    FigGeometryDimensionMake();
    uint64_t v50 = v49;
    uint64_t v52 = v51;
    FigGeometryDimensionMake();
    uint64_t v54 = v53;
    uint64_t v56 = v55;
    FigGeometryDimensionMake();
    FigGeometryMarginsMake(v46, v48, v50, v52, v54, v56, v57, v58, v70);
    long long v62 = v76;
    long long v63 = v77;
    long long v64 = v78;
    long long v65 = v79;
    uint64_t v59 = FigGeometryCoordinateSpaceCreate(a1, (uint64_t)&v62, v70, (uint64_t)v75, (uint64_t)&v83, 1918989168, (uint64_t *)&cf);
    if (v59) {
      goto LABEL_26;
    }
    long long v62 = v71;
    long long v63 = v72;
    long long v64 = v73;
    long long v65 = v74;
    uint64_t v59 = FigGeometryCoordinateSpaceCreate(a1, (uint64_t)&v62, 0, 0, 0, 0, (uint64_t *)&v67);
    if (v59
      || (long long v62 = v76,
          long long v63 = v77,
          long long v64 = v78,
          long long v65 = v79,
          uint64_t v59 = FigGeometryCoordinateSpaceCreate(a1, (uint64_t)&v62, 0, 0, 0, 0, (uint64_t *)&v68),
          v59)
      || (uint64_t v59 = FigGeometryMappingCreate(a1, cf, 1, v68, 1, (uint64_t *)&v82), v59)
      || (uint64_t v59 = FigGeometryMappingCreate(a1, cf, 1, v67, 1, (uint64_t *)&v81), v59))
    {
LABEL_26:
      uint64_t v60 = v59;
    }
    else
    {
      uint64_t v60 = FigGeometryMappingCreate(a1, v67, 1, v68, 1, (uint64_t *)&v80);
      if (!v60)
      {
        *a4 = v82;
        *a5 = v81;
        CFTypeRef v81 = 0;
        CFTypeRef v82 = 0;
        *a6 = v80;
        CFTypeRef v80 = 0;
        goto LABEL_13;
      }
    }
    FigSignalErrorAt(v60, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v60 = FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
LABEL_13:
  if (v82) {
    CFRelease(v82);
  }
  if (v81) {
    CFRelease(v81);
  }
  if (v80) {
    CFRelease(v80);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v68) {
    CFRelease(v68);
  }
  if (v67) {
    CFRelease(v67);
  }
  return v60;
}

uint64_t FigGeometryMappingConvertDimensionToDimension(double *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  double v5 = 0.0;
  if (!a1)
  {
    FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
    return *(void *)&v5;
  }
  if ((BYTE4(a3) & 0x1D) == 1)
  {
    if (a5 == 1)
    {
      int v8 = a1 + 3;
      double v9 = a1 + 4;
    }
    else
    {
      double v6 = 0.0;
      double v7 = 0.0;
      if (a5 != 2) {
        goto LABEL_11;
      }
      int v8 = a1 + 5;
      double v9 = a1 + 6;
    }
    double v6 = *v8;
    double v7 = *v9;
LABEL_11:
    if (a4) {
      double v5 = v6 * *(double *)&a2;
    }
    else {
      double v5 = v7 + *(double *)&a2 * v6;
    }
    return *(void *)&v5;
  }
  if ((~HIDWORD(a3) & 0x11) == 0) {
    double v5 = *(double *)&a2;
  }
  return *(void *)&v5;
}

uint64_t FigGeometryMappingConvertPointToPoint@<X0>(double *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = kFigGeometryPointInvalid;
  *(_OWORD *)(a3 + 16) = unk_18FE956A8;
  if (a1)
  {
    *(void *)a3 = FigGeometryMappingConvertDimensionToDimension(a1, *a2, a2[1], 0, 1);
    *(void *)(a3 + 8) = v6;
    uint64_t result = FigGeometryMappingConvertDimensionToDimension(a1, a2[2], a2[3], 0, 2);
    *(void *)(a3 + 16) = result;
    *(void *)(a3 + 24) = v8;
  }
  else
  {
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigGeometryMappingConvertSizeToSize@<X0>(double *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = kFigGeometrySizeInvalid;
  *(_OWORD *)(a3 + 16) = unk_18FE956C8;
  if (a1)
  {
    *(void *)a3 = FigGeometryMappingConvertDimensionToDimension(a1, *a2, a2[1], 1, 1);
    *(void *)(a3 + 8) = v6;
    uint64_t result = FigGeometryMappingConvertDimensionToDimension(a1, a2[2], a2[3], 1, 2);
    *(void *)(a3 + 16) = result;
    *(void *)(a3 + 24) = v8;
  }
  else
  {
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigGeometryMappingConvertVectorToVector@<X0>(double *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = kFigGeometryVectorInvalid;
  *(_OWORD *)(a3 + 16) = unk_18FE956E8;
  if (a1)
  {
    *(void *)a3 = FigGeometryMappingConvertDimensionToDimension(a1, *a2, a2[1], 1, 1);
    *(void *)(a3 + 8) = v6;
    uint64_t result = FigGeometryMappingConvertDimensionToDimension(a1, a2[2], a2[3], 1, 2);
    *(void *)(a3 + 16) = result;
    *(void *)(a3 + 24) = v8;
  }
  else
  {
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigGeometryMappingConvertRectToRect@<X0>(double *a1@<X0>, long long *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = kFigGeometryRectInvalid;
  a3[1] = unk_18FE95708;
  a3[2] = xmmword_18FE95718;
  a3[3] = unk_18FE95728;
  if (a1)
  {
    long long v6 = a2[1];
    long long v9 = *a2;
    long long v10 = v6;
    FigGeometryMappingConvertPointToPoint(a1, (uint64_t *)&v9, (uint64_t)a3);
    long long v7 = a2[3];
    long long v9 = a2[2];
    long long v10 = v7;
    return FigGeometryMappingConvertSizeToSize(a1, (uint64_t *)&v9, (uint64_t)(a3 + 2));
  }
  else
  {
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
}

void fgInit_Mapping(uint64_t a1)
{
}

void fgFinalize_Mapping(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 128);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 128) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 136);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 136) = 0;
  }
}

__CFString *fgCopyDesc_Mapping(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableSetRef Mutable = CFStringCreateMutable(v2, 0);
  CFTypeID v4 = Mutable;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 20) == 1) {
      CFStringAppendFormat(Mutable, 0, @"<FigGeometryMappingRef %p> srcSpace:%p srcPart:%d, destSpace: %p, destPart:%d", a1, *(void *)(a1 + 128), *(unsigned int *)(a1 + 848), *(void *)(a1 + 136), *(unsigned int *)(a1 + 852));
    }
    else {
      CFStringAppendFormat(Mutable, 0, @"<FigGeometryMappingRef %p> [UNKNOWN MAPPING TYPE]", a1);
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"<FigGeometryMappingRef %p>", 0);
  }
  return v4;
}

CFDictionaryRef FigCaptionGeometryCopyCellBasedDimensionAsDictionary(const __CFAllocator *a1, double a2)
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  double valuePtr = a2;
  int v9 = 1667591276;
  keys[0] = @"value";
  keys[1] = @"units";
  int v8 = 0;
  keys[2] = @"flags";
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCGFloatType, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, &v9);
  values[2] = CFNumberCreate(v3, kCFNumberSInt32Type, &v8);
  CFDictionaryRef v4 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = 0; i != 3; ++i)
  {
    long long v6 = values[i];
    if (v6) {
      CFRelease(v6);
    }
  }
  return v4;
}

uint64_t FigCaptionGeometryGetCellBasedDimensionFromDictionary(const void *a1, double *a2)
{
  double v3 = 0.0;
  if (!a1 || (CFTypeID v5 = CFGetTypeID(a1), v5 != CFDictionaryGetTypeID()))
  {
    uint64_t v6 = 4294950501;
    if (!a2) {
      return v6;
    }
    goto LABEL_11;
  }
  double v11 = 0.0;
  int v10 = 0;
  uint64_t v6 = 4294950501;
  if (FigCFDictionaryGetCGFloatIfPresent((uint64_t)a1, @"value", &v11))
  {
    BOOL v7 = FigCFDictionaryGetInt32IfPresent((uint64_t)a1, @"units", &v10) != 0;
    BOOL v8 = v10 == 1667591276;
    if (v7 && v8) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = 4294950501;
    }
    if (v7 && v8) {
      double v3 = v11;
    }
    else {
      double v3 = 0.0;
    }
  }
  if (a2) {
LABEL_11:
  }
    *a2 = v3;
  return v6;
}

CFDictionaryRef FigCaptionGeometryCopyCellBasedPointAsDictionary(const __CFAllocator *a1, double a2, double a3)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  CFDictionaryRef v5 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a2);
  CFDictionaryRef v6 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a3);
  CFDictionaryRef v7 = v6;
  if (v5 && v6)
  {
    keys[0] = @"x";
    keys[1] = @"y";
    values[0] = v5;
    values[1] = v6;
    CFDictionaryRef v8 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v8 = 0;
    CFDictionaryRef v9 = 0;
    if (!v5) {
      goto LABEL_6;
    }
  }
  CFRelease(v5);
  CFDictionaryRef v9 = v8;
LABEL_6:
  if (v7) {
    CFRelease(v7);
  }
  return v9;
}

uint64_t FigCaptionGeometryGetCellBasedPointFromDictionary(const void *a1, _OWORD *a2)
{
  long long v11 = *MEMORY[0x1E4F1DAD8];
  CFTypeRef cf = 0;
  xpc_object_t value = 0;
  if (!a1
    || (CFTypeID v4 = CFGetTypeID(a1), v4 != CFDictionaryGetTypeID())
    || !CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, @"x", (const void **)&value)
    || (CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, @"y", &cf) ? (BOOL v5 = value == 0) : (BOOL v5 = 1),
        v5
     || (CFTypeID v7 = CFGetTypeID(value), v7 != CFDictionaryGetTypeID())
     || !cf
     || (CFTypeID v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID())))
  {
    uint64_t result = 4294950501;
    if (!a2) {
      return result;
    }
    goto LABEL_10;
  }
  uint64_t result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(value, (double *)&v11);
  if (!result)
  {
    uint64_t result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(cf, (double *)&v11 + 1);
    if (a2)
    {
      if (!result) {
LABEL_10:
      }
        *a2 = v11;
    }
  }
  return result;
}

__CFDictionary *FigCaptionGeometryCopyCellBasedSizeAsDictionary(const __CFAllocator *a1, double a2, double a3)
{
  CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef v7 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a2);
  CFDictionaryRef v8 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a3);
  CFDictionaryAddValue(Mutable, @"width", v7);
  CFDictionaryAddValue(Mutable, @"height", v8);
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  return Mutable;
}

uint64_t FigCaptionGeometryGetCellBasedSizeFromDictionary(const __CFDictionary *a1, _OWORD *a2)
{
  long long v11 = *MEMORY[0x1E4F1DB30];
  if (a1 && a2)
  {
    CFSetRef Value = CFDictionaryGetValue(a1, @"width");
    BOOL v5 = CFDictionaryGetValue(a1, @"height");
    if (Value)
    {
      CFDictionaryRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFDictionaryGetTypeID())
      {
        if (v6)
        {
          CFTypeID v8 = CFGetTypeID(v6);
          if (v8 == CFDictionaryGetTypeID())
          {
            uint64_t result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(Value, (double *)&v11);
            if (!result)
            {
              uint64_t result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(v6, (double *)&v11 + 1);
              if (!result) {
                *a2 = v11;
              }
            }
            return result;
          }
        }
      }
    }
    uint64_t v10 = 4294950501;
  }
  else
  {
    uint64_t v10 = 4294954516;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

__CFArray *FigEndpointUtility_CopyMatchingStreamsFromEndpoint(uint64_t a1, unsigned int (*a2)(const void *, uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  theArradouble y = 0;
  if (!a1) {
    return 0;
  }
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  uint64_t v9 = v8 ? v8 : 0;
  uint64_t v10 = *(void (**)(uint64_t, __CFString *, void, CFArrayRef *))(v9 + 48);
  if (!v10) {
    return 0;
  }
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v10(CMBaseObject, @"Streams", *MEMORY[0x1E4F1CF80], &theArray);
  if (!theArray) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    CFMutableSetRef Mutable = 0;
  }
  else
  {
    CFIndex v13 = Count;
    CFIndex v14 = 0;
    CFMutableSetRef Mutable = 0;
    unsigned int v16 = 1;
    uint64_t v17 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    do
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex(theArray, v14);
      if (ValueAtIndex)
      {
        uint64_t v19 = ValueAtIndex;
        if (!a2 || a2(ValueAtIndex, a3, a4))
        {
          if (!Mutable) {
            CFMutableSetRef Mutable = CFArrayCreateMutable(v11, v13, v17);
          }
          CFArrayAppendValue(Mutable, v19);
        }
      }
      CFIndex v14 = v16;
    }
    while (v13 > v16++);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  return Mutable;
}

uint64_t FigEndpointActivate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(v7 + 8);
  if (!v8) {
    return 4294954514;
  }

  return v8(a1, a2, a3, 0, 0);
}

uint64_t FigEndpointActivateSync(const void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = dispatch_semaphore_create(0);
  if (a4) {
    dispatch_time_t v9 = dispatch_time(0, 1000000 * a4);
  }
  else {
    dispatch_time_t v9 = -1;
  }
  CFTypeRef cf = 0;
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  CFIndex v13 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v12 + 48);
  if (!v13)
  {
    CFMutableArrayRef Mutable = 0;
    goto LABEL_15;
  }
  unsigned int valuePtr = v13(CMBaseObject, @"IsActivated", *MEMORY[0x1E4F1CF80], &cf);
  if (valuePtr)
  {
    CFMutableArrayRef Mutable = 0;
    goto LABEL_17;
  }
  CFTypeRef v14 = cf;
  if (cf != (CFTypeRef)*MEMORY[0x1E4F1CFD0])
  {
    CFAllocatorRef v15 = CFGetAllocator(a1);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v15, 0, MEMORY[0x1E4F1D510]);
    if (!Mutable || (uint64_t v17 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL)) == 0)
    {
      FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
      goto LABEL_17;
    }
    uint64_t v18 = v17;
    *uint64_t v17 = v8;
    dispatch_retain(v8);
    v18[1] = CFRetain(Mutable);
    uint64_t v19 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 16);
    if (v19) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v23 = *(uint64_t (**)(const void *, uint64_t, uint64_t, void, void *))(v20 + 8);
    if (v23)
    {
      unsigned int valuePtr = v23(a1, a2, a3, endpointUtil_activationCallback, v18);
      if (valuePtr) {
        goto LABEL_17;
      }
      if (!dispatch_semaphore_wait(v8, v9))
      {
        if (CFArrayGetCount(Mutable) >= 1)
        {
          ValueAtIndedouble x = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, 0);
          CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
        }
LABEL_17:
        CFTypeRef v14 = cf;
        if (!cf) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
      int v21 = -16724;
LABEL_16:
      unsigned int valuePtr = v21;
      goto LABEL_17;
    }
LABEL_15:
    int v21 = -12782;
    goto LABEL_16;
  }
  CFMutableArrayRef Mutable = 0;
  if (cf) {
LABEL_18:
  }
    CFRelease(v14);
LABEL_19:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v8) {
    dispatch_release(v8);
  }
  return valuePtr;
}

void endpointUtil_activationCallback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  int valuePtr = a4;
  CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a5 + 8), v6);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)a5);
  if (*(void *)a5) {
    dispatch_release(*(dispatch_object_t *)a5);
  }
  uint64_t v7 = *(const void **)(a5 + 8);
  if (v7) {
    CFRelease(v7);
  }
  free((void *)a5);
  if (v6) {
    CFRelease(v6);
  }
}

uint64_t FigEndpointDeactivate(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  CFNumberRef v6 = *(uint64_t (**)(uint64_t, uint64_t, void, void))(v5 + 16);
  if (!v6) {
    return 4294954514;
  }

  return v6(a1, a2, 0, 0);
}

uint64_t FigEndpointGetSupportedFeatures(uint64_t a1)
{
  CFNumberRef number = 0;
  uint64_t valuePtr = 0;
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, __CFString *, void, CFNumberRef *))(v3 + 48);
  if (v4)
  {
    int v5 = v4(CMBaseObject, @"SupportedFeatures", 0, &number);
    CFNumberRef v6 = number;
    if (v5) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = number == 0;
    }
    if (!v7)
    {
      CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
      CFNumberRef v6 = number;
    }
    if (v6) {
      CFRelease(v6);
    }
  }
  return valuePtr;
}

uint64_t FigEndpointUtility_CopyEndpointType(uint64_t result)
{
  uint64_t v5 = 0;
  if (result)
  {
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject(result);
    uint64_t v2 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v2) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v4 = *(unsigned int (**)(uint64_t, __CFString *, void, uint64_t *))(v3 + 48);
    if (v4)
    {
      if (v4(CMBaseObject, @"Type", *MEMORY[0x1E4F1CF80], &v5)) {
        return 0;
      }
      else {
        return v5;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FigEndpointUtility_CopyEndpointTransportType(uint64_t result)
{
  uint64_t v5 = 0;
  if (result)
  {
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject(result);
    uint64_t v2 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v2) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v4 = *(unsigned int (**)(uint64_t, __CFString *, void, uint64_t *))(v3 + 48);
    if (v4)
    {
      if (v4(CMBaseObject, @"TransportType", *MEMORY[0x1E4F1CF80], &v5)) {
        return 0;
      }
      else {
        return v5;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void FigEndpointUtility_SetPropertyOnEndpointStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 && a3 && a4)
  {
    char v6 = a2;
    if ((a2 & 2) != 0)
    {
      theArradouble y = 0;
      FigEndpointCopyStreamsForTypeAndSubType(a1, a2, @"Audio", 0, &theArray);
      CFArrayRef v8 = theArray;
      if (theArray)
      {
        if (CFArrayGetCount(theArray) >= 1)
        {
          ValueAtIndedouble x = CFArrayGetValueAtIndex(v8, 0);
          uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject(ValueAtIndex);
          uint64_t v11 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
          uint64_t v12 = v11 ? v11 : 0;
          CFIndex v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 56);
          if (v13) {
            v13(CMBaseObject, a3, a4);
          }
        }
        CFRelease(v8);
      }
    }
    if ((v6 & 8) != 0)
    {
      theArradouble y = 0;
      FigEndpointCopyStreamsForTypeAndSubType(a1, a2, @"BufferedAudio", 0, &theArray);
      CFArrayRef v14 = theArray;
      if (theArray)
      {
        if (CFArrayGetCount(theArray) >= 1)
        {
          CFAllocatorRef v15 = CFArrayGetValueAtIndex(v14, 0);
          uint64_t v16 = FigEndpointStreamGetCMBaseObject(v15);
          uint64_t v17 = *(void *)(CMBaseObjectGetVTable(v16) + 8);
          uint64_t v18 = v17 ? v17 : 0;
          uint64_t v19 = *(void (**)(uint64_t, uint64_t, uint64_t))(v18 + 56);
          if (v19) {
            v19(v16, a3, a4);
          }
        }
        CFRelease(v14);
      }
    }
    if (v6)
    {
      theArradouble y = 0;
      FigEndpointCopyStreamsForTypeAndSubType(a1, a2, @"Screen", 0, &theArray);
      CFArrayRef v20 = theArray;
      if (theArray)
      {
        if (CFArrayGetCount(theArray) >= 1)
        {
          int v21 = CFArrayGetValueAtIndex(v20, 0);
          uint64_t v22 = FigEndpointStreamGetCMBaseObject(v21);
          uint64_t v23 = *(void *)(CMBaseObjectGetVTable(v22) + 8);
          if (v23) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = 0;
          }
          uint64_t v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v24 + 56);
          if (v25) {
            v25(v22, a3, a4);
          }
        }
        CFRelease(v20);
      }
    }
  }
}

uint64_t FigEndpointCopyStreamsForTypeAndSubType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFArray **a5)
{
  if (a1) {
    *a5 = FigEndpointUtility_CopyMatchingStreamsFromEndpoint(a1, (unsigned int (*)(const void *, uint64_t, uint64_t))FigEndpointUtility_StreamPredicate_IsOfTypeAndSubType, a3, a4);
  }
  else {
    FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

BOOL FigEndpointUtility_EndpointPredicate_ContainsID(uint64_t a1, const __CFString *a2)
{
  CFStringRef theString = 0;
  if (!a1) {
    return 0;
  }
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  uint64_t v5 = v4 ? v4 : 0;
  char v6 = *(void (**)(uint64_t, __CFString *, void, CFStringRef *))(v5 + 48);
  if (!v6) {
    return 0;
  }
  v6(CMBaseObject, @"ID", *MEMORY[0x1E4F1CF80], &theString);
  BOOL v7 = 0;
  CFStringRef v8 = theString;
  if (a2 && theString)
  {
    CFRange v9 = CFStringFind(theString, a2, 1uLL);
    BOOL v7 = v9.length > 0 && v9.location == 0;
    CFStringRef v8 = theString;
  }
  if (v8) {
    CFRelease(v8);
  }
  return v7;
}

uint64_t FigEndpointUtility_EndpointPredicate_EqualsAudioStreamID(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  theArradouble y = 0;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  CFStringRef v8 = *(void (**)(uint64_t, __CFString *, const __CFAllocator *, CFArrayRef *))(v6 + 48);
  if (v8 && (v8(CMBaseObject, @"Streams", v3, &theArray), theArray))
  {
    CFIndex Count = CFArrayGetCount(theArray);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex(theArray, i);
        CFIndex v13 = ValueAtIndex;
        CFTypeRef cf = 0;
        if (ValueAtIndex)
        {
          uint64_t v14 = FigEndpointStreamGetCMBaseObject(ValueAtIndex);
          uint64_t v15 = *(void *)(CMBaseObjectGetVTable(v14) + 8);
          uint64_t v16 = v15 ? v15 : 0;
          uint64_t v17 = *(void (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v16 + 48);
          if (v17) {
            v17(v14, @"Type", v3, &cf);
          }
        }
        if (FigCFEqual(cf, @"Audio") || FigCFEqual(cf, @"LowLatencyAudio")) {
          CFArrayAppendValue(Mutable, v13);
        }
        if (cf) {
          CFRelease(cf);
        }
      }
    }
    if (Mutable) {
      goto LABEL_23;
    }
  }
  else
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
LABEL_23:
      CFIndex v18 = CFArrayGetCount(Mutable);
      if (v18 < 1)
      {
LABEL_35:
        uint64_t v7 = 0;
      }
      else
      {
        CFIndex v19 = v18;
        CFIndex v20 = 0;
        while (1)
        {
          CFTypeRef cf = 0;
          int v21 = CFArrayGetValueAtIndex(Mutable, v20);
          if (v21)
          {
            uint64_t v22 = FigEndpointStreamGetCMBaseObject(v21);
            uint64_t v23 = *(void *)(CMBaseObjectGetVTable(v22) + 8);
            uint64_t v24 = v23 ? v23 : 0;
            uint64_t v25 = *(void (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v24 + 48);
            if (v25) {
              v25(v22, @"ID", v3, &cf);
            }
          }
          if (FigCFEqual(cf, a2)) {
            break;
          }
          if (cf) {
            CFRelease(cf);
          }
          if (v19 == ++v20) {
            goto LABEL_35;
          }
        }
        if (cf) {
          CFRelease(cf);
        }
        uint64_t v7 = 1;
      }
      CFRelease(Mutable);
      goto LABEL_42;
    }
  }
  uint64_t v7 = 0;
LABEL_42:
  if (theArray) {
    CFRelease(theArray);
  }
  return v7;
}

BOOL FigEndpointUtility_EndpointPredicate_IsPropertyTrue(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void (**)(uint64_t, uint64_t, void, CFTypeRef *))(v5 + 48);
  if (v6)
  {
    v6(CMBaseObject, a2, *MEMORY[0x1E4F1CF80], &cf);
    CFTypeRef v7 = cf;
    CFTypeRef v8 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    CFTypeRef v7 = 0;
    CFTypeRef v8 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  }
  return v7 == v8;
}

uint64_t FigEndpointCopyFirstStreamOfType(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (!a1)
  {
    FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v5 = FigEndpointUtility_CopyMatchingStreamsFromEndpoint(a1, (unsigned int (*)(const void *, uint64_t, uint64_t))FigEndpointUtility_StreamPredicate_IsOfTypeAndSubType, a3, 0);
  if (v5)
  {
    CFArrayRef v6 = v5;
    if (CFArrayGetCount(v5))
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex(v6, 0);
      if (ValueAtIndex) {
        ValueAtIndedouble x = CFRetain(ValueAtIndex);
      }
      *a4 = ValueAtIndex;
    }
    CFRelease(v6);
    return 0;
  }
  return 4294950571;
}

uint64_t FigEndpointUtility_StreamPredicate_IsOfTypeAndSubType(uint64_t a1, const void *a2, const void *a3)
{
  if (!a1) {
    return 0;
  }
  CFTypeRef v21 = 0;
  uint64_t v6 = *MEMORY[0x1E4F1CF80];
  uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject(a1);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v9 + 48);
  if (v10)
  {
    v10(CMBaseObject, @"Type", v6, &v21);
    CFTypeRef v11 = v21;
  }
  else
  {
    CFTypeRef v11 = 0;
  }
  uint64_t v12 = FigCFEqual(v11, a2);
  uint64_t v13 = v12;
  if (a3 && v12)
  {
    CFTypeRef cf = 0;
    uint64_t v14 = FigEndpointStreamGetCMBaseObject(a1);
    uint64_t v15 = *(void *)(CMBaseObjectGetVTable(v14) + 8);
    uint64_t v16 = v15 ? v15 : 0;
    uint64_t v17 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v16 + 48);
    if (v17)
    {
      v17(v14, @"SubType", v6, &cf);
      CFTypeRef v18 = cf;
    }
    else
    {
      CFTypeRef v18 = 0;
    }
    uint64_t v13 = FigCFEqual(v18, a3);
    if (cf) {
      CFRelease(cf);
    }
  }
  if (v21) {
    CFRelease(v21);
  }
  return v13;
}

BOOL FigEndpointUtility_IsSubTypeThirdPartyTVFamily(const void *a1)
{
  return FigCFEqual(a1, @"EndpointSubType_ThirdPartyTV")
      || FigCFEqual(a1, @"EndpointSubType_ThirdPartySetTopBox")
      || FigCFEqual(a1, @"EndpointSubType_ThirdPartyTVStick") != 0;
}

BOOL FigEndpointUtility_IsEndpointThirdPartyTVFamily(uint64_t a1)
{
  CFTypeRef cf = 0;
  if (!a1) {
    return 0;
  }
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v5 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v3 + 48);
  if (v5)
  {
    v5(CMBaseObject, @"SubType", *MEMORY[0x1E4F1CF80], &cf);
    CFTypeRef v6 = cf;
  }
  else
  {
    CFTypeRef v6 = 0;
  }
  IsSubTypeThirdPartyTVFamildouble y = FigEndpointUtility_IsSubTypeThirdPartyTVFamily(v6);
  if (cf) {
    CFRelease(cf);
  }
  return IsSubTypeThirdPartyTVFamily;
}

CFArrayRef FigEndpointContainsStream(uint64_t a1, const void *a2)
{
  CFArrayRef v2 = 0;
  theArradouble y = 0;
  if (a1 && a2)
  {
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    CFTypeRef v7 = *(void (**)(uint64_t, __CFString *, void, CFArrayRef *))(v6 + 48);
    if (v7)
    {
      v7(CMBaseObject, @"Streams", *MEMORY[0x1E4F1CF80], &theArray);
      CFArrayRef v2 = theArray;
      if (theArray)
      {
        v10.length = CFArrayGetCount(theArray);
        v10.location = 0;
        CFArrayRef v2 = (const __CFArray *)CFArrayContainsValue(v2, v10, a2);
        if (theArray) {
          CFRelease(theArray);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t FigEndpointAcquireAndCopyStreamResource(char *a1, const void *a2, uint64_t a3)
{
  uint64_t v3 = 4294950576;
  if (a1 && a2 && a3)
  {
    ClassID = (void *)FigEndpointExtendedGetClassID();
    if (CMBaseObjectIsMemberOfClass(a1, ClassID))
    {
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        uint64_t v9 = Mutable;
        CFDictionarySetValue(Mutable, @"endpointStreamType", a2);
        uint64_t v10 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
        if (v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v12 = *(uint64_t (**)(char *, __CFString *, __CFDictionary *, uint64_t))(v11 + 128);
        if (v12) {
          uint64_t v3 = v12(a1, @"endpointStream", v9, a3);
        }
        else {
          uint64_t v3 = 4294954514;
        }
        CFRelease(v9);
      }
      else
      {
        return 4294950575;
      }
    }
    else
    {
      return 4294950570;
    }
  }
  return v3;
}

uint64_t FigEndpointRelinquishStreamResource(char *a1, uint64_t a2)
{
  uint64_t result = 4294950576;
  if (a1 && a2)
  {
    ClassID = (void *)FigEndpointExtendedGetClassID();
    if (CMBaseObjectIsMemberOfClass(a1, ClassID))
    {
      uint64_t v6 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
      if (v6) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t v8 = *(uint64_t (**)(char *, __CFString *, uint64_t))(v7 + 136);
      if (v8)
      {
        return v8(a1, @"endpointStream", a2);
      }
      else
      {
        return 4294954514;
      }
    }
    else
    {
      return 4294950570;
    }
  }
  return result;
}

uint64_t FigCFWeakReferenceTableAddValueAndGetKey(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(unsigned char *)(a1 + 36))
  {
    uint64_t v11 = 4294955228;
  }
  else
  {
    if (a3)
    {
      *a3 = 0;
      if (a2)
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
        uint64_t v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040FBFA920DuLL);
        if (v6)
        {
          uint64_t v7 = v6;
          uint64_t v8 = *(void *)(a1 + 24);
          *(void *)(a1 + 24) = v8 + 1;
          *(void *)uint64_t v6 = v8;
          if (*(unsigned char *)(a1 + 37))
          {
            uint64_t v8 = v8;
            *(void *)uint64_t v6 = v8;
          }
          *a3 = v8;
          FigCFWeakReferenceInit((id *)v6 + 1, (id)a2);
          v7[2] = -a2;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v7, v7);
          uint64_t v9 = 0;
        }
        else
        {
          uint64_t v9 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
        return v9;
      }
    }
    uint64_t v11 = 4294955231;
  }

  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFWeakReferenceTableAddValueAssociatedWithKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  key[1] = 0;
  key[2] = 0;
  if (a3)
  {
    if (a1 && a2)
    {
      if (*(unsigned char *)(a1 + 36) == 1)
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
        key[0] = a3;
        CFSetRef Value = (id *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
        if (Value)
        {
          uint64_t v7 = Value;
          uint64_t v8 = Value + 1;
          id v9 = FigCFWeakReferenceLoadAndRetain(Value + 1);
          if (v9)
          {
            uint64_t v10 = v9;
            uint64_t v11 = FigSignalErrorAt(4294955227, 0, 0, 0, 0, 0, 0);
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
            CFRelease(v10);
            return v11;
          }
          FigCFWeakReferenceStore(v8, (id)a2);
          uint64_t v11 = 0;
          v7[2] = (id)-a2;
        }
        else
        {
          uint64_t v12 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040FBFA920DuLL);
          if (v12)
          {
            uint64_t v13 = v12;
            *(void *)uint64_t v12 = a3;
            FigCFWeakReferenceInit((id *)v12 + 1, (id)a2);
            v13[2] = -a2;
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v13, v13);
            uint64_t v11 = 0;
          }
          else
          {
            uint64_t v11 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
          }
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
        return v11;
      }
      uint64_t v15 = 4294955228;
    }
    else
    {
      uint64_t v15 = 4294955231;
    }
  }
  else
  {
    uint64_t v15 = 4294955231;
  }

  return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFWeakReferenceTableRemoveValue(uint64_t a1, uint64_t a2)
{
  key[1] = 0;
  key[2] = 0;
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
    key[0] = a2;
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), key))
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), key);
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v4 = 4294955229;
    }
    figCFWeakReferenceTablePeriodicallyCleanUp(a1);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
    return v4;
  }
  else
  {
    return FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
  }
}

void figCFWeakReferenceTablePeriodicallyCleanUp(uint64_t a1)
{
  CFArrayRef context = 0;
  int v1 = *(_DWORD *)(a1 + 32) + 1;
  *(_DWORD *)(a1 + 32) = v1;
  if (v1 == 100)
  {
    *(_DWORD *)(a1 + 32) = 0;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTableCleanup_ifValueIsNULLAppendToKeyValueEntriesToRemove, &context);
    if (context)
    {
      v4.length = CFArrayGetCount(context);
      v4.location = 0;
      CFArrayApplyFunction(context, v4, (CFArrayApplierFunction)figCFWeakReferenceTableCleanup_removeKeyValueEntries, *(void **)(a1 + 16));
      CFRelease(context);
    }
  }
}

id FigCFWeakReferenceTableCopyValue(uint64_t a1, void *a2)
{
  key[1] = 0;
  key[2] = 0;
  if (a1)
  {
    id v2 = a2;
    if (a2)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
      key[0] = v2;
      CFSetRef Value = (id *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
      if (Value) {
        id v2 = FigCFWeakReferenceLoadAndRetain(Value + 1);
      }
      else {
        id v2 = 0;
      }
      figCFWeakReferenceTablePeriodicallyCleanUp(a1);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
    }
    else
    {
      FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v2;
}

uint64_t FigCFWeakReferenceTableGetKey(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v7 = 0;
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
    context[0] = a2;
    context[1] = -a2;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTable_searchForDisguisedValue, context);
    uint64_t v2 = v7;
    figCFWeakReferenceTablePeriodicallyCleanUp(a1);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
  }
  return v2;
}

void figCFWeakReferenceTable_searchForDisguisedValue(uint64_t a1, id *a2, id *a3)
{
  if (a2[2] == a3[1])
  {
    id v5 = FigCFWeakReferenceLoadAndRetain(a2 + 1);
    if (v5 == *a3)
    {
      a3[2] = *a2;
      if (!v5) {
        return;
      }
    }
    else if (!v5)
    {
      return;
    }
    CFRelease(v5);
  }
}

uint64_t FigCFWeakReferenceTableCopyValues(uint64_t a1, CFMutableDictionaryRef *a2)
{
  CFMutableDictionaryRef v9 = 0;
  uint64_t v10 = 0;
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
    uint64_t Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v6 = Mutable;
      if (Count >= 1)
      {
        CFMutableDictionaryRef v9 = Mutable;
        uint64_t v10 = 0;
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTableCopyCopiedEntriesApplier, &v9);
      }
      figCFWeakReferenceTablePeriodicallyCleanUp(a1);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
      *a2 = v6;
      return 0;
    }
    else
    {
      uint64_t v8 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
      return v8;
    }
  }
  else
  {
    return FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
  }
}

void figCFWeakReferenceTableCopyCopiedEntriesApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = FigCFWeakReferenceLoadAndRetain((id *)(a2 + 8));
  if (v5)
  {
    CFMutableDictionaryRef v6 = v5;
    CFNumberRef UInt64 = FigCFNumberCreateUInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)a2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)a3, UInt64, v6);
    if (UInt64) {
      CFRelease(UInt64);
    }
    CFRelease(v6);
  }
  ++*(void *)(a3 + 8);
}

uint64_t FigCFWeakReferenceTableApplyFunction(uint64_t a1, void (*a2)(void, CFTypeRef, uint64_t), uint64_t a3)
{
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
    if (Count)
    {
      uint64_t v7 = Count;
      uint64_t v8 = (CFTypeRef *)malloc_type_malloc(16 * Count, 0x10C004003E0BC0AuLL);
      if (v8)
      {
        CFMutableDictionaryRef v9 = v8;
        v13[0] = v8;
        v13[1] = 0;
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTableCopiedEntriesApplier, v13);
        figCFWeakReferenceTablePeriodicallyCleanUp(a1);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
        if (v7 >= 1)
        {
          uint64_t v10 = v9 + 1;
          do
          {
            if (*v10)
            {
              a2(*(v10 - 1), *v10, a3);
              CFRelease(*v10);
            }
            v10 += 2;
            --v7;
          }
          while (v7);
        }
        free(v9);
        return 0;
      }
      uint64_t v11 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
    return v11;
  }

  return FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
}

id figCFWeakReferenceTableCopiedEntriesApplier(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = (void *)(*a3 + 16 * a3[1]);
  id result = FigCFWeakReferenceLoadAndRetain((id *)(a2 + 8));
  *id v5 = *(void *)a2;
  v5[1] = result;
  ++a3[1];
  return result;
}

uint64_t FigCFWeakReferenceTableGetTypeID()
{
  if (sRegisterFigCFWeakReferenceTableTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigCFWeakReferenceTableTypeOnce, 0, (dispatch_function_t)RegisterFigCFWeakReferenceTableType);
  }
  return sFigCFWeakReferenceTableID;
}

uint64_t RegisterFigCFWeakReferenceTableType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCFWeakReferenceTableID = result;
  return result;
}

uint64_t FigCFWeakReferenceTableCreate(const __CFAllocator *a1, char a2, uint64_t *a3)
{
  if (!a3)
  {
    uint64_t v13 = 4294955231;
LABEL_16:
    return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  }
  if (sRegisterFigCFWeakReferenceTableTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigCFWeakReferenceTableTypeOnce, 0, (dispatch_function_t)RegisterFigCFWeakReferenceTableType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v13 = 4294955230;
    goto LABEL_16;
  }
  uint64_t v7 = Instance;
  uint64_t v8 = FigSimpleMutexCreateWithFlags(a1);
  *(void *)(v7 + 40) = v8;
  if (v8)
  {
    if (a2) {
      *(unsigned char *)(v7 + 36) = 1;
    }
    if ((a2 & 2) != 0) {
      *(unsigned char *)(v7 + 37) = 1;
    }
    pid_t v9 = getpid();
    unint64_t v10 = v9;
    if (*(unsigned char *)(v7 + 37)) {
      unint64_t v10 = v9 % 0x10C6uLL;
    }
    *(void *)(v7 + 24) = 1000000 * v10
                         + (int)(10000 * FigAtomicIncrement32(FigCFWeakReferenceTableCreate_sTableCount));
    *(_DWORD *)(v7 + 32) = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &figCFWeakReferenceTableKeyCallbacks, &figCFWeakReferenceTableValueCallbacks);
    *(void *)(v7 + 16) = Mutable;
    if (Mutable)
    {
      *a3 = v7;
      return 0;
    }
    uint64_t v14 = 4294955230;
  }
  else
  {
    uint64_t v14 = 4294954510;
  }
  uint64_t v15 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  CFRelease((CFTypeRef)v7);
  return v15;
}

void figCFWeakReferenceTableCleanup_ifValueIsNULLAppendToKeyValueEntriesToRemove(int a1, void *value, __CFArray **a3)
{
  if (!*((void *)value + 1))
  {
    CFMutableDictionaryRef Mutable = *a3;
    if (*a3 || (CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0), (*a3 = Mutable) != 0))
    {
      CFArrayAppendValue(Mutable, value);
    }
    else
    {
      FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
    }
  }
}

void figCFWeakReferenceTableCleanup_removeKeyValueEntries(void *key, CFMutableDictionaryRef theDict)
{
}

double figCFWeakReferenceTableInit(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

CFAllocatorRef figCFWeakReferenceTableFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(void *)(a1 + 40);

  return FigSimpleMutexDestroy(v3);
}

__CFString *figCFWeakReferenceTableCopyDesc(unsigned char *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFRange v4 = Mutable;
  if (a1[36]) {
    id v5 = "Client provides keys ";
  }
  else {
    id v5 = "";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigCFWeakReferenceTable %s%p>", v5, a1);
  return v4;
}

BOOL figCFWeakReferenceTableKeyEqual(void *a1, void *a2)
{
  return *a1 == *a2;
}

uint64_t figCFWeakReferenceTableKeyHash(uint64_t a1)
{
  return *(void *)a1;
}

void figCFWeakReferenceTableValueDestroy(uint64_t a1, id *a2)
{
  FigCFWeakReferenceDestroy(a2 + 1);

  free(a2);
}

BOOL figCFWeakReferenceTableValueEqual(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 16) == *(void *)(a2 + 16);
}

pthread_mutex_t **FigReadWriteLockCreate(int a1)
{
  return FigReadWriteLockCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1);
}

pthread_mutex_t **FigReadWriteLockCreateWithFlags(const __CFAllocator *a1, int a2)
{
  CFRange v4 = (pthread_mutex_t **)CFAllocatorAllocate(a1, 40, 0);
  id v5 = v4;
  if (v4)
  {
    v4[4] = 0;
    *(_OWORD *)CFRange v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    CFMutableDictionaryRef v6 = FigSimpleMutexCreateWithFlags(a1);
    *id v5 = v6;
    if (v6)
    {
      uint64_t v7 = (pthread_mutex_t *)FigSemaphoreCreateWithFlags(a1, 0, 1);
      v5[1] = v7;
      if (v7)
      {
        *((_DWORD *)v5 + 4) = a2;
        if (a1) {
          uint64_t v8 = (pthread_mutex_t *)CFRetain(a1);
        }
        else {
          uint64_t v8 = 0;
        }
        pid_t v9 = 0;
        v5[4] = v8;
        goto LABEL_8;
      }
      FigSimpleMutexDestroy((uint64_t)*v5);
    }
    pid_t v9 = v5;
    id v5 = 0;
LABEL_8:
    CFAllocatorDeallocate(a1, v9);
  }
  return v5;
}

CFAllocatorRef FigReadWriteLockDestroy(uint64_t *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = (uint64_t)FigSimpleMutexDestroy(*a1);
  if (!v2)
  {
    *a1 = 0;
    uint64_t v2 = FigSemaphoreDestroy(a1[1]);
    if (!v2)
    {
      CFAllocatorRef v3 = (const __CFAllocator *)a1[4];
      a1[1] = 0;
      CFAllocatorDeallocate(v3, a1);
      if (!v3) {
        return v3;
      }
      CFRelease(v3);
      return 0;
    }
  }
  CFAllocatorRef v3 = (const __CFAllocator *)v2;
  FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  return v3;
}

uint64_t FigReadWriteLockLockForRead(uint64_t a1)
{
  uint64_t result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!result)
  {
    while (*(_DWORD *)(a1 + 24) || *(_DWORD *)(a1 + 28))
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
      FigSemaphoreWaitRelative(*(void *)(a1 + 8), -1);
      uint64_t result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
      if (result) {
        return result;
      }
      if (*(_DWORD *)(a1 + 28)) {
        FigSemaphoreSignal(*(void *)(a1 + 8));
      }
    }
    ++*(_DWORD *)(a1 + 20);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
    return 0;
  }
  return result;
}

uint64_t FigReadWriteLockLockForWrite(uint64_t a1)
{
  uint64_t result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!result)
  {
    if (*(unsigned char *)(a1 + 16)) {
      ++*(_DWORD *)(a1 + 28);
    }
    while (*(_DWORD *)(a1 + 24) || *(_DWORD *)(a1 + 20))
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
      FigSemaphoreWaitRelative(*(void *)(a1 + 8), -1);
      uint64_t result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
      if (result) {
        return result;
      }
    }
    *(_DWORD *)(a1 + 24) = 1;
    if (*(unsigned char *)(a1 + 16)) {
      --*(_DWORD *)(a1 + 28);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
    return 0;
  }
  return result;
}

uint64_t FigReadWriteLockUnlockForRead(uint64_t a1)
{
  uint64_t v2 = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!v2)
  {
    int v3 = *(_DWORD *)(a1 + 20);
    if (v3)
    {
      int v4 = v3 - 1;
      *(_DWORD *)(a1 + 20) = v4;
      if (!v4) {
        FigSemaphoreSignal(*(void *)(a1 + 8));
      }
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
  }
  return v2;
}

uint64_t FigReadWriteLockUnlockForWrite(uint64_t a1)
{
  uint64_t v2 = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!v2)
  {
    if (*(_DWORD *)(a1 + 24))
    {
      *(_DWORD *)(a1 + 24) = 0;
      FigSemaphoreSignal(*(void *)(a1 + 8));
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
  }
  return v2;
}

BOOL _FigIsCurrentDispatchQueue(NSObject *a1)
{
  return dispatch_get_current_queue() == a1;
}

BOOL _FigIsNotCurrentDispatchQueue(NSObject *a1)
{
  return dispatch_get_current_queue() != a1;
}

uint64_t FigConcurrentAccessDetectorCreate()
{
  return 0;
}

dispatch_queue_t FigReadWriteQueue_Create(const char *a1)
{
  uint64_t v2 = dispatch_queue_attr_make_with_overcommit();

  return dispatch_queue_create(a1, v2);
}

uint64_t NeroTransportStartAcceptingConnections(uint64_t a1)
{
  uint64_t CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(void *)(a1 + 80));
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  id v5 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v4 + 56);
  if (!v5) {
    return 4294954514;
  }
  uint64_t result = v5(CMBaseObject, @"ConnectionMode", @"Server");
  if (result) {
    return result;
  }
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(v7) + 16);
  uint64_t v9 = v8 ? v8 : 0;
  unint64_t v10 = *(uint64_t (**)(uint64_t))(v9 + 16);
  if (!v10) {
    return 4294954514;
  }

  return v10(v7);
}

uint64_t NeroTransportStopAcceptingConnections(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(v1) + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void (**)(uint64_t))(v3 + 24);
  if (v4) {
    v4(v1);
  }
  return 0;
}

uint64_t NeroTransportConnectToReceiver(uint64_t a1, const void *a2)
{
  Boolean keyExistsAndHasValidFormat = 0;
  AppIntegerCFSetRef Value = CFPreferencesGetAppIntegerValue(@"transport_reply_timeout", @"com.apple.coremedia", &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    *(void *)(a1 + 64) = 1000000000 * AppIntegerValue;
  }
  uint64_t CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(void *)(a1 + 80));
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(v7 + 56);
  if (v8)
  {
    uint64_t result = v8(CMBaseObject, @"ConnectionMode", @"Client");
    if (result) {
      return result;
    }
    if (a2)
    {
      CFTypeID v10 = CFGetTypeID(a2);
      if (v10 != FigCFIOKitObjectGetTypeID()) {
        return 4294955259;
      }
      uint64_t v11 = NeroTransportConnectionGetCMBaseObject(*(void *)(a1 + 80));
      uint64_t v12 = *(void *)(CMBaseObjectGetVTable(v11) + 8);
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v14 = *(uint64_t (**)(uint64_t, __CFString *, const void *))(v13 + 56);
      if (!v14) {
        return 4294954514;
      }
      uint64_t result = v14(v11, @"Service", a2);
      if (result) {
        return result;
      }
    }
    uint64_t v15 = *(void *)(a1 + 80);
    uint64_t v16 = *(void *)(CMBaseObjectGetVTable(v15) + 16);
    if (v16) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = 0;
    }
    CFTypeRef v18 = *(uint64_t (**)(uint64_t))(v17 + 16);
    if (v18) {
      return v18(v15);
    }
  }
  return 4294954514;
}

uint64_t NeroTransportDisconnectFromReceiver(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(v1) + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void (**)(uint64_t))(v3 + 24);
  if (v4) {
    v4(v1);
  }
  return 0;
}

uint64_t NeroTransportSetAsConnected(uint64_t a1)
{
  *(unsigned char *)(a1 + 72) = 1;
  return FigTransportConnectionUSBSetAsConnected(*(void *)(a1 + 80));
}

uint64_t NeroTransportIsConnected(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

BOOL NeroTransportIsHiSpeed(uint64_t a1)
{
  CFTypeRef cf = 0;
  uint64_t CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(void *)(a1 + 80));
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v3 + 48);
  if (v4)
  {
    v4(CMBaseObject, @"IsHiSpeed", *MEMORY[0x1E4F1CF80], &cf);
    CFTypeRef v5 = cf;
    CFTypeRef v6 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    CFTypeRef v5 = 0;
    CFTypeRef v6 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  }
  return v5 == v6;
}

uint64_t FigTransportGetLocalRootObject()
{
  return 0;
}

uint64_t FigTransportGetRemoteRootObject()
{
  return 1;
}

uint64_t NeroTransportRegisterObjectWithFlags(uint64_t a1, const void *a2, char a3, void *a4, NSObject *a5, const void *a6, const void *a7)
{
  if (!a1) {
    return 4294955265;
  }
  if (a6)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (!*(unsigned char *)(a1 + 16))
    {
      if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), a2))
      {
        uint64_t v16 = 4294955262;
LABEL_14:
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        return v16;
      }
      uint64_t v7 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A004007F56D72uLL);
      *(_DWORD *)uint64_t v7 = FigAtomicIncrement32(ft_createObjectRecord_sIdentifier);
      v7[1] = a5;
      dispatch_retain(a5);
      v7[2] = _Block_copy(a6);
      if (a7) {
        v7[3] = _Block_copy(a7);
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, v7);
      if (a4) {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), (const void *)*(unsigned int *)v7, a2);
      }
      if ((a3 & 1) != 0 && *(unsigned char *)(a1 + 72))
      {
        CFRetain((CFTypeRef)a1);
        uint64_t v15 = v7[1];
        v18[0] = MEMORY[0x1E4F143A8];
        v18[1] = 0x40000000;
        v18[2] = __NeroTransportRegisterObjectWithFlags_block_invoke;
        v18[3] = &__block_descriptor_tmp_49;
        v18[4] = v7;
        v18[5] = a1;
        dispatch_async(v15, v18);
      }
    }
    uint64_t v16 = 0;
    if (a4) {
      *a4 = *(unsigned int *)v7;
    }
    goto LABEL_14;
  }

  return FigSignalErrorAt(4294955259, 0, 0, 0, 0, 0, 0);
}

void __NeroTransportRegisterObjectWithFlags_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 16) + 16))();
  uint64_t v2 = *(const void **)(a1 + 40);

  CFRelease(v2);
}

uint64_t NeroTransportRegisterObject(uint64_t a1, const void *a2, NSObject *a3, const void *a4, const void *a5)
{
  return NeroTransportRegisterObjectWithFlags(a1, a2, 0, 0, a3, a4, a5);
}

uint64_t NeroTransportUnregisterObject(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 4294955265;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  if (!*(unsigned char *)(a1 + 16))
  {
    CFSetRef Value = (unsigned int *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
    if (!Value)
    {
      uint64_t v6 = 4294955263;
      goto LABEL_6;
    }
    CFTypeRef v5 = Value;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), a2);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 40), (const void *)*v5);
    ft_destroyObjectRecord((uint64_t)v5);
  }
  uint64_t v6 = 0;
LABEL_6:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return v6;
}

void ft_destroyObjectRecord(uint64_t a1)
{
  if (a1)
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 8));
    _Block_release(*(const void **)(a1 + 16));
    _Block_release(*(const void **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t NeroTransportCopyRegisteredObject(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  if (!a1) {
    return 4294955265;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (Value)
  {
    uint64_t v7 = 0;
    *a3 = CFRetain(Value);
  }
  else
  {
    uint64_t v7 = 4294955263;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return v7;
}

uint64_t NeroTransportSendAsyncMessage(uint64_t a1, uint64_t a2, int a3, CMBlockBufferRef theBuffer)
{
  if (!a1) {
    return 4294955265;
  }
  if (!*(unsigned char *)(a1 + 72)) {
    return 4294955265;
  }
  v13[0] = CMBlockBufferGetDataLength(theBuffer) + 20;
  v13[1] = 1634957678;
  uint64_t v14 = a2;
  int v15 = a3;
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable(v8) + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(void (**)(uint64_t, _DWORD *, CMBlockBufferRef, uint64_t))(v10 + 32);
  if (v11) {
    v11(v8, v13, theBuffer, 2);
  }
  return 0;
}

uint64_t NeroTransportSendSyncMessageCreatingReply(uint64_t a1, uint64_t a2, int a3, OpaqueCMBlockBuffer *a4, void *a5)
{
  dispatch_semaphore_t v10 = dispatch_semaphore_create(0);
  if (a1 && *(unsigned char *)(a1 + 72))
  {
    v21[0] = CMBlockBufferGetDataLength(a4) + 28;
    v21[1] = 1937337955;
    uint64_t v22 = a2;
    int v23 = a3;
    dispatch_semaphore_t v24 = v10;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 48));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), v10, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
    uint64_t v11 = *(void *)(a1 + 80);
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable(v11) + 16);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = *(void (**)(uint64_t, _DWORD *, OpaqueCMBlockBuffer *, uint64_t))(v13 + 32);
    if (v14) {
      v14(v11, v21, a4, 2);
    }
    int64_t v15 = *(void *)(a1 + 64);
    if (v15) {
      dispatch_time_t v16 = dispatch_time(0, v15);
    }
    else {
      dispatch_time_t v16 = -1;
    }
    dispatch_semaphore_wait(v10, v16);
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 48));
    CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v10);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 56), v10);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
    if (Value)
    {
      uint64_t v18 = *(unsigned int *)Value;
      if (a5 && !v18)
      {
        CFTypeRef v19 = (CFTypeRef)Value[1];
        if (v19) {
          CFTypeRef v19 = CFRetain(v19);
        }
        uint64_t v18 = 0;
        *a5 = v19;
      }
    }
    else
    {
      uint64_t v18 = 4294955261;
    }
  }
  else
  {
    CFSetRef Value = 0;
    uint64_t v18 = 4294955265;
  }
  if (v10) {
    dispatch_release(v10);
  }
  ft_destroyReplyRecord(Value);
  return v18;
}

void ft_destroyReplyRecord(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[1];
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

uint64_t NeroTransportGetTypeID()
{
  if (NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce != -1) {
    dispatch_once(&NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce, &__block_literal_global_40);
  }
  return NeroTransportGetTypeID_sNeroTransportTypeID;
}

double neroTransport_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void neroTransport_Finalize(uint64_t *a1)
{
  uint64_t v2 = (const void *)a1[10];
  if (v2)
  {
    CFRelease(v2);
    a1[10] = 0;
  }
  FigSimpleMutexDestroy(a1[3]);
  FigSimpleMutexDestroy(a1[6]);
  uint64_t v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  CFTypeRef v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
  uint64_t v6 = (const void *)a1[11];
  if (v6)
  {
    CFRelease(v6);
    a1[11] = 0;
  }
}

CFTypeRef neroTransport_CopyFormattingDesc()
{
  return CFRetain(@"[NeroTransport]");
}

__CFString *neroTransport_CopyDebugDesc(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"[NeroTransport %p retainCount:%d]", a1, v4);
  return Mutable;
}

uint64_t __NeroTransportGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  NeroTransportGetTypeID_sNeroTransportCFTypeID TypeID = result;
  return result;
}

uint64_t NeroTransportCreate(uint64_t a1, const void *a2, uint64_t *a3)
{
  CFTypeRef cf = 0;
  int v33 = 1;
  if (!a3)
  {
    uint64_t v17 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    uint64_t Instance = 0;
    goto LABEL_40;
  }
  if (NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce != -1) {
    dispatch_once(&NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce, &__block_literal_global_40);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v16 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  uint64_t v6 = FigSimpleMutexCreate();
  *(void *)(Instance + 24) = v6;
  if (!v6) {
    goto LABEL_45;
  }
  uint64_t v7 = FigSimpleMutexCreate();
  *(void *)(Instance + 48) = v7;
  if (!v7
    || (CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0),
        (*(void *)(Instance + 32) = Mutable) == 0)
    || (CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(v8, 0, 0, 0), (*(void *)(Instance + 40) = v10) == 0)
    || (CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(v8, 0, 0, 0), (*(void *)(Instance + 56) = v11) == 0))
  {
LABEL_45:
    uint64_t v17 = 4294955266;
    goto LABEL_40;
  }
  *(void *)(Instance + 64) = 3000000000;
  if (a2)
  {
    CFTypeRef v12 = CFRetain(a2);
    *(void *)(Instance + 80) = v12;
    goto LABEL_12;
  }
  uint64_t v16 = FigTransportConnectionUSBCreate((uint64_t)v8, (CFTypeRef *)(Instance + 80));
  if (v16)
  {
LABEL_15:
    uint64_t v17 = v16;
    goto LABEL_40;
  }
  CFTypeRef v12 = *(CFTypeRef *)(Instance + 80);
LABEL_12:
  uint64_t CMBaseObject = NeroTransportConnectionGetCMBaseObject(v12);
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v18 = *(unsigned int (**)(uint64_t, __CFString *, const __CFAllocator *, CFTypeRef *))(v15 + 48);
  if (v18)
  {
    if (!v18(CMBaseObject, @"ReplyTimeout", v8, &cf))
    {
      if (cf)
      {
        CFTypeID v19 = CFGetTypeID(cf);
        if (v19 == CFNumberGetTypeID())
        {
          int valuePtr = 0;
          CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
          *(void *)(Instance + 64) = 1000000000 * valuePtr;
        }
      }
    }
  }
  CFNumberRef v20 = CFNumberCreate(v8, kCFNumberSInt32Type, &v33);
  uint64_t v21 = NeroTransportConnectionGetCMBaseObject(*(void *)(Instance + 80));
  uint64_t v22 = *(void *)(CMBaseObjectGetVTable(v21) + 8);
  if (v22) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 0;
  }
  dispatch_semaphore_t v24 = *(uint64_t (**)(uint64_t, __CFString *, CFNumberRef))(v23 + 56);
  if (v24)
  {
    uint64_t v25 = v24(v21, @"Version", v20);
    if (v25)
    {
LABEL_27:
      uint64_t v17 = v25;
      goto LABEL_38;
    }
    uint64_t v26 = *(void *)(Instance + 80);
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 0x40000000;
    v31[2] = __NeroTransportCreate_block_invoke;
    v31[3] = &__block_descriptor_tmp_4_3;
    v31[4] = Instance;
    uint64_t v27 = *(void *)(CMBaseObjectGetVTable(v26) + 16);
    if (v27) {
      uint64_t v28 = v27;
    }
    else {
      uint64_t v28 = 0;
    }
    uint64_t v29 = *(uint64_t (**)(uint64_t, void, void *))(v28 + 8);
    if (v29)
    {
      uint64_t v25 = v29(v26, 0, v31);
      if (!v25)
      {
        if (!a2) {
          FigTransportConnectionXPCSetCurrentConnection(*(void *)(Instance + 80));
        }
        uint64_t v17 = 0;
        *a3 = Instance;
        uint64_t Instance = 0;
        goto LABEL_38;
      }
      goto LABEL_27;
    }
  }
  uint64_t v17 = 4294954514;
LABEL_38:
  if (v20) {
    CFRelease(v20);
  }
LABEL_40:
  if (cf) {
    CFRelease(cf);
  }
  if (Instance) {
    CFRelease((CFTypeRef)Instance);
  }
  return v17;
}

void __NeroTransportCreate_block_invoke(uint64_t a1, int a2, CMBlockBufferRef theBuffer)
{
  switch(a2)
  {
    case 2:
      FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = *(const void **)(v16 + 88);
      if (v17)
      {
        CFRelease(v17);
        *(void *)(*(void *)(a1 + 32) + 88) = 0;
        uint64_t v16 = *(void *)(a1 + 32);
      }
      *(unsigned char *)(v16 + 72) = 0;
      uint64_t context = 1684628836;
      uint64_t v40 = v16;
      uint64_t v41 = 0;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v16 + 32), (CFDictionaryApplierFunction)ft_callAsyncHandlerForObjectRecordApplier, &context);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
      FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 48));
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 56), (CFDictionaryApplierFunction)ft_signalReplySemaphoreApplier, *(void **)(a1 + 32));
      uint64_t v18 = *(pthread_mutex_t **)(*(void *)(a1 + 32) + 48);
      goto LABEL_26;
    case 1:
      FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
      if (theBuffer) {
        CFTypeRef v19 = CFRetain(theBuffer);
      }
      else {
        CFTypeRef v19 = 0;
      }
      *(void *)(*(void *)(a1 + 32) + 88) = v19;
      uint64_t v20 = *(void *)(a1 + 32);
      *(unsigned char *)(v20 + 72) = 1;
      uint64_t context = 1651470958;
      uint64_t v40 = v20;
      uint64_t v41 = (void (*)(uint64_t))theBuffer;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v20 + 32), (CFDictionaryApplierFunction)ft_callAsyncHandlerForObjectRecordApplier, &context);
      uint64_t v18 = *(pthread_mutex_t **)(*(void *)(a1 + 32) + 24);
LABEL_26:
      FigSimpleMutexUnlock(v18);
      return;
    case 0:
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v38 = 0;
      if (CMBlockBufferGetDataLength(theBuffer) >= 8)
      {
        size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
        if (CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength))
        {
          if (!CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &v38))
          {
            size_t v7 = CMBlockBufferGetDataLength(theBuffer);
            CFAllocatorRef v8 = v38;
            if (v7 == *(_DWORD *)v38)
            {
              int v9 = *((_DWORD *)v38 + 1);
              if (v9 == 1937337955)
              {
                if (*((void *)v38 + 1) == 1) {
                  uint64_t v21 = 0;
                }
                else {
                  uint64_t v21 = (const void *)*((void *)v38 + 1);
                }
                int v22 = *((_DWORD *)v38 + 4);
                unint64_t v23 = *(void *)(v38 + 20);
                CMBlockBufferRef blockBufferOut = 0;
                size_t v24 = CMBlockBufferGetDataLength(theBuffer);
                FigSimpleMutexLock(*(pthread_mutex_t **)(v5 + 24));
                CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 32), v21);
                if (Value)
                {
                  uint64_t v26 = Value;
                  if (Value[3])
                  {
                    if (v24 == 28
                      || !CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, 0x1CuLL, v24 - 28, 0, &blockBufferOut))
                    {
                      CFRetain((CFTypeRef)v5);
                      if (blockBufferOut)
                      {
                        CFRetain(blockBufferOut);
                        CMBlockBufferRef v27 = blockBufferOut;
                      }
                      else
                      {
                        CMBlockBufferRef v27 = 0;
                      }
                      int v36 = *(_DWORD *)v26;
                      uint64_t v35 = v26[1];
                      uint64_t context = MEMORY[0x1E4F143A8];
                      uint64_t v40 = 0x40000000;
                      uint64_t v41 = __ft_didReceiveSyncPackage_block_invoke;
                      uint64_t v42 = &__block_descriptor_tmp_24_2;
                      uint64_t v43 = v5;
                      uint64_t v44 = v21;
                      int v48 = v36;
                      int v49 = v22;
                      uint64_t v45 = v26;
                      CMBlockBufferRef v46 = v27;
                      unint64_t v47 = v23;
                      goto LABEL_47;
                    }
                  }
                }
LABEL_48:
                FigSimpleMutexUnlock(*(pthread_mutex_t **)(v5 + 24));
                CMBlockBufferRef v37 = blockBufferOut;
                if (!blockBufferOut) {
                  return;
                }
LABEL_53:
                CFRelease(v37);
                return;
              }
              if (v9 != 1919970425)
              {
                if (v9 != 1634957678) {
                  return;
                }
                if (*((void *)v38 + 1) == 1) {
                  CFMutableDictionaryRef v10 = 0;
                }
                else {
                  CFMutableDictionaryRef v10 = (const void *)*((void *)v38 + 1);
                }
                unsigned int v11 = *((_DWORD *)v38 + 4);
                CMBlockBufferRef blockBufferOut = 0;
                size_t v12 = CMBlockBufferGetDataLength(theBuffer);
                FigSimpleMutexLock(*(pthread_mutex_t **)(v5 + 24));
                uint64_t v13 = (unsigned int *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 32), v10);
                if (v13)
                {
                  uint64_t v14 = v13;
                  if (v12 == 20
                    || !CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, 0x14uLL, v12 - 20, 0, &blockBufferOut))
                  {
                    CFRetain((CFTypeRef)v5);
                    if (blockBufferOut)
                    {
                      CFRetain(blockBufferOut);
                      CMBlockBufferRef v15 = blockBufferOut;
                    }
                    else
                    {
                      CMBlockBufferRef v15 = 0;
                    }
                    unsigned int v34 = *v14;
                    uint64_t v35 = *((void *)v14 + 1);
                    uint64_t context = MEMORY[0x1E4F143A8];
                    uint64_t v40 = 0x40000000;
                    uint64_t v41 = __ft_didReceiveAsyncPackage_block_invoke;
                    uint64_t v42 = &__block_descriptor_tmp_22_0;
                    uint64_t v43 = v5;
                    uint64_t v44 = v10;
                    unint64_t v47 = __PAIR64__(v11, v34);
                    uint64_t v45 = v14;
                    CMBlockBufferRef v46 = v15;
LABEL_47:
                    dispatch_async(v35, &context);
                    goto LABEL_48;
                  }
                }
                goto LABEL_48;
              }
              uint64_t v28 = *((void *)v38 + 1);
              uint64_t context = 0;
              size_t v29 = CMBlockBufferGetDataLength(theBuffer);
              CMBlockBufferRef blockBufferOut = 0;
              if (v29 == 20
                || !CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, 0x14uLL, v29 - 20, 0, (CMBlockBufferRef *)&context))
              {
                FigSimpleMutexLock(*(pthread_mutex_t **)(v5 + 48));
                if (!CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(v5 + 56), v28, (const void **)&blockBufferOut)
                  || blockBufferOut)
                {
                  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v5 + 48));
                }
                else
                {
                  int v30 = *((_DWORD *)v8 + 4);
                  CMBlockBufferRef v31 = (CMBlockBufferRef)context;
                  uint64_t v32 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
                  *(_DWORD *)uint64_t v32 = v30;
                  if (v31) {
                    CFTypeRef v33 = CFRetain(v31);
                  }
                  else {
                    CFTypeRef v33 = 0;
                  }
                  v32[1] = v33;
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 56), v28, v32);
                  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v5 + 48));
                  dispatch_semaphore_signal(v28);
                }
              }
              CMBlockBufferRef v37 = (CMBlockBufferRef)context;
              if (context) {
                goto LABEL_53;
              }
            }
          }
        }
      }
      break;
  }
}

uint64_t NeroTransportCreateWithNTCXPCConnection(uint64_t a1, void *a2)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __NeroTransportCreateWithNTCXPCConnection_block_invoke;
  block[3] = &__block_descriptor_tmp_5_1;
  block[4] = a1;
  if (NeroTransportCreateWithNTCXPCConnection_once != -1) {
    dispatch_once(&NeroTransportCreateWithNTCXPCConnection_once, block);
  }
  CFTypeRef v3 = (CFTypeRef)NeroTransportCreateWithNTCXPCConnection_transport;
  if (NeroTransportCreateWithNTCXPCConnection_transport) {
    CFTypeRef v3 = CFRetain((CFTypeRef)NeroTransportCreateWithNTCXPCConnection_transport);
  }
  *a2 = v3;
  return NeroTransportCreateWithNTCXPCConnection_err;
}

void __NeroTransportCreateWithNTCXPCConnection_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  NeroTransportCreateWithNTCXPCConnection_err = FigTransportConnectionXPCClientCreate(*(void *)(a1 + 32), &cf);
  if (!NeroTransportCreateWithNTCXPCConnection_err)
  {
    NeroTransportCreateWithNTCXPCConnection_err = NeroTransportCreate(*(void *)(a1 + 32), cf, &NeroTransportCreateWithNTCXPCConnection_transport);
    if (!NeroTransportCreateWithNTCXPCConnection_err)
    {
      *(unsigned char *)(NeroTransportCreateWithNTCXPCConnection_transport + 72) = 1;
      int v8 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v8, &type);
      int v3 = v8;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v5 = v3;
      }
      else {
        unsigned int v5 = v3 & 0xFFFFFFFE;
      }
      if (v5)
      {
        int v10 = 136315138;
        unsigned int v11 = "NeroTransportCreateWithNTCXPCConnection_block_invoke";
        uint64_t v6 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v8;
      }
      else
      {
        uint64_t v6 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v6, v6 != &v12, v3, 0, v4);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t NeroTransportInvalidate(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 16))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    *(unsigned char *)(a1 + 16) = 1;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)ft_sendPendingMessagesObjectRecordApplier, 0);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)ft_destroyObjectRecordApplier, 0);
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 40));
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 48));
    CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 56));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 56), (CFDictionaryApplierFunction)ft_destroyReplyRecordApplier, 0);
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 56));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
    uint64_t v2 = *(void *)(a1 + 80);
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable(v2) + 16);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    unsigned int v5 = *(void (**)(uint64_t, void, void))(v4 + 8);
    if (v5) {
      v5(v2, 0, 0);
    }
    *(unsigned char *)(a1 + 72) = 0;
    uint64_t CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(void *)(a1 + 80));
    if (CMBaseObject)
    {
      uint64_t v7 = CMBaseObject;
      uint64_t v8 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
      uint64_t v9 = v8 ? v8 : 0;
      int v10 = *(void (**)(uint64_t))(v9 + 24);
      if (v10) {
        v10(v7);
      }
    }
    unsigned int v11 = *(const void **)(a1 + 80);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 80) = 0;
    }
  }
  return 0;
}

void ft_sendPendingMessagesObjectRecordApplier(uint64_t a1, uint64_t a2)
{
}

void ft_destroyObjectRecordApplier(uint64_t a1, uint64_t a2)
{
}

void ft_destroyReplyRecordApplier(NSObject *a1, void *a2)
{
  if (a1) {
    dispatch_semaphore_signal(a1);
  }

  ft_destroyReplyRecord(a2);
}

void FigTransportSetSharedTransport(uint64_t a1)
{
  if (FigTransportSetSharedTransport_sTransportQueueCreateOnce != -1) {
    dispatch_once(&FigTransportSetSharedTransport_sTransportQueueCreateOnce, &__block_literal_global_8_0);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigTransportSetSharedTransport_block_invoke_2;
  block[3] = &__block_descriptor_tmp_10_3;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)sTransportQueue, block);
}

dispatch_queue_t __FigTransportSetSharedTransport_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.coremedia.transport.init", 0);
  sTransportQueue = (uint64_t)result;
  sTransportUsageCFIndex Count = 0;
  sTransport = 0;
  return result;
}

void __FigTransportSetSharedTransport_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = (const void *)sTransport;
  uint64_t v2 = *(const void **)(a1 + 32);
  sTransport = (uint64_t)v2;
  if (v2) {
    CFRetain(v2);
  }
  if (v1)
  {
    CFRelease(v1);
  }
}

uint64_t FigTransportInitializeWithConnection(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  int v8 = 0;
  FigTransportSetSharedTransport(0);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = __FigTransportInitializeWithConnection_block_invoke;
  v4[3] = &unk_1E567C9F0;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync((dispatch_queue_t)sTransportQueue, v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __FigTransportInitializeWithConnection_block_invoke(uint64_t result)
{
  if (sTransport)
  {
    ++sTransportUsageCount;
  }
  else
  {
    uint64_t v1 = result;
    sTransportUsageCFIndex Count = 1;
    dispatch_queue_t result = NeroTransportCreate(*MEMORY[0x1E4F1CF80], *(const void **)(result + 40), &sTransport);
    *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t FigTransportInitialize()
{
  return FigTransportInitializeWithConnection(0);
}

BOOL FigTransportIsHiSpeed()
{
  uint64_t v0 = (const void *)ft_copySharedTransport();
  BOOL IsHiSpeed = NeroTransportIsHiSpeed((uint64_t)v0);
  if (v0) {
    CFRelease(v0);
  }
  return IsHiSpeed;
}

uint64_t ft_copySharedTransport()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __ft_copySharedTransport_block_invoke;
  block[3] = &unk_1E567CAB8;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)sTransportQueue, block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigTransportCopyRegisteredObject(const void *a1, CFTypeRef *a2)
{
  uint64_t v4 = (const void *)ft_copySharedTransport();
  uint64_t v5 = NeroTransportCopyRegisteredObject((uint64_t)v4, a1, a2);
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

uint64_t FigTransportSendSyncMessageCreatingReply(uint64_t a1, int a2, OpaqueCMBlockBuffer *a3, void *a4)
{
  int v8 = (const void *)ft_copySharedTransport();
  uint64_t v9 = NeroTransportSendSyncMessageCreatingReply((uint64_t)v8, a1, a2, a3, a4);
  if (v8) {
    CFRelease(v8);
  }
  return v9;
}

void __ft_didReceiveAsyncPackage_block_invoke(uint64_t a1)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
  CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 32), *(const void **)(a1 + 40));
  if (Value && *Value == *(_DWORD *)(a1 + 64)) {
    uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 16);
  }
  else {
    uint64_t v3 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
  if (v3) {
    (*(void (**)(uint64_t, void, void))(v3 + 16))(v3, *(unsigned int *)(a1 + 68), *(void *)(a1 + 56));
  }
  uint64_t v4 = *(const void **)(a1 + 56);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 32);

  CFRelease(v5);
}

void __ft_didReceiveSyncPackage_block_invoke(uint64_t a1)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
  CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 32), *(const void **)(a1 + 40));
  if (Value && *Value == *(_DWORD *)(a1 + 72)) {
    uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 24);
  }
  else {
    uint64_t v3 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
  if (v3)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 76);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    v8[2] = __ft_didReceiveSyncPackage_block_invoke_2;
    v8[3] = &__block_descriptor_tmp_23_1;
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v6 = *(void *)(a1 + 64);
    v8[4] = *(void *)(a1 + 32);
    v8[5] = v6;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(v3 + 16))(v3, v4, v5, v8);
  }
  uint64_t v7 = *(const void **)(a1 + 56);
  if (v7) {
    CFRelease(v7);
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t __ft_didReceiveSyncPackage_block_invoke_2(uint64_t result, int a2, CMBlockBufferRef theBuffer)
{
  uint64_t v3 = *(void *)(result + 32);
  if (*(unsigned char *)(v3 + 72))
  {
    uint64_t v6 = *(void *)(result + 40);
    v17[0] = CMBlockBufferGetDataLength(theBuffer) + 20;
    v17[1] = 1919970425;
    uint64_t v18 = v6;
    int v19 = a2;
    uint64_t v7 = *(void *)(v3 + 80);
    uint64_t v8 = *(void *)(CMBaseObjectGetVTable(v7) + 16);
    if (v8) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 0;
    }
    int v10 = *(void (**)(uint64_t, _DWORD *, CMBlockBufferRef, uint64_t))(v9 + 32);
    if (v10) {
      v10(v7, v17, theBuffer, 1);
    }
    uint64_t v11 = *(void *)(v3 + 80);
    uint64_t VTable = CMBaseObjectGetVTable(v11);
    uint64_t v14 = *(void *)(VTable + 16);
    dispatch_queue_t result = VTable + 16;
    uint64_t v13 = v14;
    if (v14) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t))(v15 + 40);
    if (v16) {
      return v16(v11, 1);
    }
  }
  return result;
}

void ft_callAsyncHandlerForObjectRecordApplier(uint64_t a1, uint64_t a2, int *a3)
{
  int v5 = *a3;
  uint64_t v7 = (unsigned char *)*((void *)a3 + 1);
  uint64_t v6 = (const void *)*((void *)a3 + 2);
  if (v6)
  {
    CFTypeRef v8 = CFRetain(v6);
    if (!v7) {
      return;
    }
  }
  else
  {
    CFTypeRef v8 = 0;
    if (!v7) {
      return;
    }
  }
  if (!v7[16])
  {
    CFRetain(v7);
    uint64_t v9 = *(NSObject **)(a2 + 8);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __ft_callAsyncHandlerForObjectRecordApplier_block_invoke;
    block[3] = &__block_descriptor_tmp_25_0;
    block[4] = v7;
    void block[5] = a1;
    int v11 = v5;
    block[6] = a2;
    block[7] = v8;
    dispatch_async(v9, block);
  }
}

void __ft_callAsyncHandlerForObjectRecordApplier_block_invoke(uint64_t a1)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 32), *(const void **)(a1 + 40))) {
    uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 16);
  }
  else {
    uint64_t v2 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 24));
  if (v2) {
    (*(void (**)(uint64_t, void, void))(v2 + 16))(v2, *(unsigned int *)(a1 + 64), *(void *)(a1 + 56));
  }
  uint64_t v3 = *(const void **)(a1 + 56);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 32);

  CFRelease(v4);
}

CFTypeRef __ft_copySharedTransport_block_invoke(uint64_t a1)
{
  CFTypeRef result = (CFTypeRef)sTransport;
  if (sTransport) {
    CFTypeRef result = CFRetain((CFTypeRef)sTransport);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t CMTimeSyncTimeOfDayClockGetTypeID()
{
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  }
  return sFigTimeSyncTimeOfDayClockID;
}

uint64_t RegisterFigTimeSyncTimeOfDayClockIDType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigTimeSyncTimeOfDayClockID = result;
  return result;
}

uint64_t CMTimeSyncTimeOfDayClockCreate(uint64_t a1, uint64_t *a2)
{
  if (sTimeSyncFunctionsLoadedOnce_0 != -1)
  {
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_0, 0, (dispatch_function_t)LoadTimeSyncFunctions_0);
    if (a2) {
      goto LABEL_3;
    }
LABEL_9:
    uint64_t v5 = 4294951466;
    goto LABEL_10;
  }
  if (!a2) {
    goto LABEL_9;
  }
LABEL_3:
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v4 = Instance;
    FigNTPClientCreate(*MEMORY[0x1E4F1CF80], (uint64_t *)(Instance + 32));
    goto LABEL_12;
  }
  uint64_t v5 = 4294951465;
LABEL_10:
  uint64_t result = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  if (result) {
    return result;
  }
  uint64_t v4 = 0;
LABEL_12:
  uint64_t result = 0;
  *a2 = v4;
  return result;
}

void *LoadTimeSyncFunctions_0()
{
  unsigned int v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimeSyncTimeOfDayClockTrace[1], @"ts_tod_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigTimeSyncTimeOfDayClockTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimeSyncTimeOfDayClockTrace[3], @"ts_tod_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &gFigTimeSyncTimeOfDayClockTrace[2]);
  uint64_t v1 = dlopen("/System/Library/PrivateFrameworks/TimeSync.framework/TimeSync", 4);
  if (!v1) {
    goto LABEL_10;
  }
  uint64_t v2 = v1;
  sTimeSyncClockDispose_0 = (uint64_t (*)(void))dlsym(v1, "TimeSyncClockDispose");
  if (!sTimeSyncClockDispose_0) {
    goto LABEL_10;
  }
  sTimeSyncAddgPTPServices = (uint64_t)dlsym(v2, "TimeSyncAddgPTPServices");
  if (!sTimeSyncAddgPTPServices
    || (sTimeSyncgPTPManagerNotifyWhenAvailable = (uint64_t)dlsym(v2, "TimeSyncgPTPManagerNotifyWhenAvailable")) == 0
    || (f7037e1403bc4fedb8e5d76c00b0b80a = (uint64_t)dlsym(v2, "TimeSyncAddCopresencePTPInstnce")) == 0
    || (sTimeSyncClockCreateWithClockIdentifer_0 = (uint64_t)dlsym(v2, "TimeSyncClockCreateWithClockIdentifer")) == 0
    || (sTimeSyncClockGetClockTimeForHostTime = (uint64_t (*)(void, void))dlsym(v2, "TimeSyncClockGetClockTimeForHostTime")) == 0|| (sTimeSyncClockGetHostTimeForClockTime = (uint64_t (*)(void, void))dlsym(v2, "TimeSyncClockGetHostTimeForClockTime")) == 0|| (uint64_t result = dlsym(v2, "TimeSyncClockCreateAudioClockDeviceUID"), (sTimeSyncClockCreateAudioClockDeviceUID = result) == 0))
  {
LABEL_10:
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t CMTimeSyncTimeOfDayClockGetClockTimeForHostTime(void *a1, uint64_t a2, CMTime *a3)
{
  memset(&v15, 0, sizeof(v15));
  if (!a1) {
    goto LABEL_12;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  }
  if (v6 == sFigTimeSyncTimeOfDayClockID)
  {
    if (*(unsigned char *)(a2 + 12))
    {
      if (a1[3])
      {
        CMTime hostTime = *(CMTime *)a2;
        uint64_t v7 = CMClockConvertHostTimeToSystemUnits(&hostTime);
        int64_t ClockTimeForHostTime = sTimeSyncClockGetClockTimeForHostTime(a1[3], v7);
        CMTimeMake(&v15, ClockTimeForHostTime, 1000000000);
        if (!a3) {
          return 0;
        }
      }
      else
      {
        memset(&hostTime, 0, sizeof(hostTime));
        memset(&v13, 0, sizeof(v13));
        memset(&v12, 0, sizeof(v12));
        uint64_t result = figTimeSyncTimeOfDayClock_GetTimeOfDayAnchorTime(a1[4], &v13, &hostTime);
        if (result) {
          return result;
        }
        CMTime lhs = hostTime;
        CMTime v10 = *(CMTime *)a2;
        CMTimeSubtract(&v12, &lhs, &v10);
        CMTime lhs = v13;
        CMTime v10 = v12;
        CMTimeSubtract(&v15, &lhs, &v10);
        if (!a3) {
          return 0;
        }
      }
      uint64_t result = 0;
      *a3 = v15;
      return result;
    }
  }
  else
  {
LABEL_12:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t figTimeSyncTimeOfDayClock_GetTimeOfDayAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  long long v12 = 0uLL;
  memset(&v11, 0, sizeof(v11));
  memset(&v10, 0, sizeof(v10));
  uint64_t v5 = FigNTPGetTimeOfDay(a1, &v12);
  uint64_t UpTime = FigGetUpTime();
  if (!v5)
  {
    int64_t v7 = UpTime;
    CMTimeMake(&v11, (uint64_t)(((double)*((uint64_t *)&v12 + 1) / 1000000000.0 + (double)(uint64_t)v12) * 1000000.0), 1000000);
    int64_t v8 = FigHostTimeToNanoseconds(v7);
    CMTimeMake(&v10, v8, 1000000000);
    *a2 = v11;
    *a3 = v10;
  }
  return v5;
}

uint64_t CMTimeSyncTimeOfDayClockGetHostTimeForClockTime(void *a1, uint64_t a2, CMTime *a3)
{
  memset(&v15, 0, sizeof(v15));
  if (!a1) {
    goto LABEL_12;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  }
  if (v6 == sFigTimeSyncTimeOfDayClockID)
  {
    if (*(unsigned char *)(a2 + 12))
    {
      if (a1[3])
      {
        CMTime time = *(CMTime *)a2;
        CMTimeConvertScale(&v14, &time, 1000000000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
        uint64_t HostTimeForClockTime = sTimeSyncClockGetHostTimeForClockTime(a1[3], v14.value);
        CMClockMakeHostTimeFromSystemUnits(&v15, HostTimeForClockTime);
        if (!a3) {
          return 0;
        }
      }
      else
      {
        memset(&time, 0, sizeof(time));
        memset(&v12, 0, sizeof(v12));
        memset(&v11, 0, sizeof(v11));
        uint64_t result = figTimeSyncTimeOfDayClock_GetTimeOfDayAnchorTime(a1[4], &v12, &time);
        if (result) {
          return result;
        }
        CMTime lhs = v12;
        CMTime v9 = *(CMTime *)a2;
        CMTimeSubtract(&v11, &lhs, &v9);
        CMTime lhs = time;
        CMTime v9 = v11;
        CMTimeSubtract(&v15, &lhs, &v9);
        if (!a3) {
          return 0;
        }
      }
      uint64_t result = 0;
      *a3 = v15;
      return result;
    }
  }
  else
  {
LABEL_12:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

BOOL CMTimeSyncTimeOfDayClockIsUsingTimeSync(uint64_t a1)
{
  return *(void *)(a1 + 24) != 0;
}

uint64_t CMTimeSyncTimeOfDayClockCopyDeviceIdentifier(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 24))
  {
    *a2 = sTimeSyncClockCreateAudioClockDeviceUID();
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951464, 0, 0, 0, 0, 0, 0);
  }
}

void *figTimeSyncTimeOfDayClock_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void figTimeSyncTimeOfDayClock_Finalize(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sTimeSyncClockDispose_0();
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }
}

CFStringRef figTimeSyncTimeOfDayClock_CopyFormattingDesc(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"CMTimeSyncTimeOfDayClock");
}

CFStringRef figTimeSyncTimeOfDayClock_CopyDebugDesc(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"CMTimeSyncTimeOfDayClock");
}

CFArrayRef FigTextMarkupCreateARGBColorArrayFromCGColor(CGColor *a1)
{
  size_t NumberOfComponents = CGColorGetNumberOfComponents(a1);
  ColorSpace = CGColorGetColorSpace(a1);
  if (CGColorSpaceGetModel(ColorSpace) != kCGColorSpaceModelRGB) {
    return 0;
  }
  Components = CGColorGetComponents(a1);
  if (NumberOfComponents != 4) {
    return 0;
  }
  double v5 = *Components;
  double v6 = Components[1];
  double v8 = Components[2];
  double v7 = Components[3];

  return createARGBColorArrayFromComponents(v7, v5, v6, v8);
}

CFArrayRef createARGBColorArrayFromComponents(double a1, double a2, double a3, double a4)
{
  values[4] = *(void **)MEMORY[0x1E4F143B8];
  double v13 = a2;
  double valuePtr = a1;
  double v11 = a4;
  double v12 = a3;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCGFloatType, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(v4, kCFNumberCGFloatType, &v13);
  CFNumberRef v7 = CFNumberCreate(v4, kCFNumberCGFloatType, &v12);
  CFNumberRef v8 = CFNumberCreate(v4, kCFNumberCGFloatType, &v11);
  values[0] = v5;
  values[1] = v6;
  values[2] = v7;
  values[3] = v8;
  CFArrayRef v9 = CFArrayCreate(v4, (const void **)values, 4, MEMORY[0x1E4F1D510]);
  CFRelease(v5);
  CFRelease(v6);
  CFRelease(v7);
  CFRelease(v8);
  return v9;
}

CFTypeRef FigTextMarkupCreateBlackARGBColorArray()
{
  if (FigTextMarkupCreateBlackARGBColorArray_sBlackOnce != -1) {
    dispatch_once_f(&FigTextMarkupCreateBlackARGBColorArray_sBlackOnce, &FigTextMarkupCreateBlackARGBColorArray_sBlackColor, (dispatch_function_t)figTextMarkupCreateBlackARGBColorArrayAndStoreInContextPtr);
  }
  unsigned int v0 = (const void *)FigTextMarkupCreateBlackARGBColorArray_sBlackColor;

  return CFRetain(v0);
}

CFArrayRef figTextMarkupCreateBlackARGBColorArrayAndStoreInContextPtr(CFArrayRef *a1)
{
  CFArrayRef result = createARGBColorArrayFromComponents(1.0, 0.0, 0.0, 0.0);
  *a1 = result;
  return result;
}

CFTypeRef FigTextMarkupCreateWhiteARGBColorArray()
{
  if (FigTextMarkupCreateWhiteARGBColorArray_sWhiteOnce != -1) {
    dispatch_once_f(&FigTextMarkupCreateWhiteARGBColorArray_sWhiteOnce, &FigTextMarkupCreateWhiteARGBColorArray_sWhiteColor, (dispatch_function_t)figTextMarkupCreateWhiteARGBColorArrayAndStoreInContextPtr);
  }
  unsigned int v0 = (const void *)FigTextMarkupCreateWhiteARGBColorArray_sWhiteColor;

  return CFRetain(v0);
}

CFArrayRef figTextMarkupCreateWhiteARGBColorArrayAndStoreInContextPtr(CFArrayRef *a1)
{
  CFArrayRef result = createARGBColorArrayFromComponents(1.0, 1.0, 1.0, 1.0);
  *a1 = result;
  return result;
}

CFTypeRef FigTextMarkupCreateClearARGBColorArray()
{
  if (FigTextMarkupCreateClearARGBColorArray_sClearOnce != -1) {
    dispatch_once_f(&FigTextMarkupCreateClearARGBColorArray_sClearOnce, &FigTextMarkupCreateClearARGBColorArray_sClearColor, (dispatch_function_t)figTextMarkupCreateClearARGBColorArrayAndStoreInContextPtr);
  }
  unsigned int v0 = (const void *)FigTextMarkupCreateClearARGBColorArray_sClearColor;

  return CFRetain(v0);
}

CFArrayRef figTextMarkupCreateClearARGBColorArrayAndStoreInContextPtr(CFArrayRef *a1)
{
  CFArrayRef result = createARGBColorArrayFromComponents(0.0, 0.0, 0.0, 0.0);
  *a1 = result;
  return result;
}

CFDictionaryRef FigTextMarkupDimensionCopyAsSimplifiedDictionary(uint64_t a1, uint64_t a2, const __CFAllocator *a3)
{
  CFDictionaryRef v3 = 0;
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a1;
  uint64_t v14 = a2;
  *(_OWORD *)keys = xmmword_1E567D0F0;
  int v19 = @"isReversed";
  values = 0;
  CFTypeRef v16 = 0;
  CFTypeRef v17 = 0;
  if ((a2 & 0x100000000) == 0) {
    goto LABEL_33;
  }
  CFDictionaryRef v3 = 0;
  if ((int)a2 > 1886920735)
  {
    if ((int)a2 <= 1986879863)
    {
      if (a2 == 1886920736)
      {
        CFNumberRef v5 = @"px";
      }
      else
      {
        if (a2 != 1986535456) {
          goto LABEL_33;
        }
        CFNumberRef v5 = @"vh";
      }
    }
    else
    {
      switch(a2)
      {
        case 0x766D6178:
          CFNumberRef v5 = @"vmax";
          break;
        case 0x766D696E:
          CFNumberRef v5 = @"vmin";
          break;
        case 0x76772020:
          CFNumberRef v5 = @"vw";
          break;
        default:
          goto LABEL_33;
      }
    }
  }
  else if ((int)a2 <= 1701650463)
  {
    if (a2 == 622862368)
    {
      CFNumberRef v5 = @"%";
    }
    else
    {
      if (a2 != 1667591276) {
        goto LABEL_33;
      }
      CFNumberRef v5 = @"c";
    }
  }
  else
  {
    switch(a2)
    {
      case 0x656D2020:
        CFNumberRef v5 = @"em";
        break;
      case 0x6C696E65:
        CFNumberRef v5 = @"li";
        break;
      case 0x70747320:
        CFNumberRef v5 = @"pt";
        break;
      default:
        goto LABEL_33;
    }
  }
  CFTypeRef v6 = CFRetain(v5);
  if (v6)
  {
    CFNumberRef v7 = v6;
    values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCGFloatType, &valuePtr);
    CFTypeRef v16 = CFRetain(v7);
    if ((~HIDWORD(v14) & 0x21) != 0)
    {
      CFIndex v9 = 2;
    }
    else
    {
      CFTypeRef v8 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
      if (*MEMORY[0x1E4F1CFD0]) {
        CFTypeRef v8 = CFRetain(v8);
      }
      CFTypeRef v17 = v8;
      CFIndex v9 = 3;
    }
    CFDictionaryRef v3 = CFDictionaryCreate(a3, (const void **)keys, (const void **)&values, v9, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRelease(v7);
  }
  else
  {
    CFDictionaryRef v3 = 0;
  }
LABEL_33:
  for (uint64_t i = 0; i != 24; i += 8)
  {
    double v11 = *(void **)((char *)&values + i);
    if (v11) {
      CFRelease(v11);
    }
  }
  return v3;
}

uint64_t FigTextMarkupDimensionMakeFromSimplifiedDictionary(const void *a1)
{
  uint64_t v1 = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFDictionaryGetTypeID())
    {
      uint64_t v8 = 0;
      if (FigCFDictionaryGetCGFloatIfPresent((uint64_t)a1, @"value", &v8))
      {
        CFSetRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"units");
        Boolean v7 = 0;
        FigCFDictionaryGetBooleanIfPresent((uint64_t)a1, @"isReversed", &v7);
        if (Value)
        {
          CFTypeID v5 = CFGetTypeID(Value);
          if (v5 == CFStringGetTypeID()
            && (CFEqual(Value, @"%")
             || CFEqual(Value, @"pt")
             || CFEqual(Value, @"px")
             || CFEqual(Value, @"c")
             || CFEqual(Value, @"li")
             || CFEqual(Value, @"vw")
             || CFEqual(Value, @"vh")
             || CFEqual(Value, @"vmin")
             || CFEqual(Value, @"vmax")
             || CFEqual(Value, @"em")))
          {
            return v8;
          }
        }
      }
    }
  }
  return v1;
}

CFDictionaryRef FigTextMarkupSizeCopyAsSimplifiedDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = FigTextMarkupDimensionCopyAsSimplifiedDictionary(*a1, a1[1], a2);
  CFDictionaryRef v5 = FigTextMarkupDimensionCopyAsSimplifiedDictionary(a1[2], a1[3], a2);
  CFDictionaryRef v6 = v5;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E567D108;
    v11[0] = v4;
    v11[1] = v5;
    CFDictionaryRef v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_10;
  }
  CFDictionaryRef v10 = 0;
  CFDictionaryRef v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    CFDictionaryRef v8 = v10;
    if (!v6) {
      return v8;
    }
    goto LABEL_8;
  }
  if (v5) {
LABEL_8:
  }
    CFRelease(v6);
  return v8;
}

uint64_t FigTextMarkupSizeMakeFromSimplifiedDictionary@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = kFigGeometrySizeInvalid;
  *(_OWORD *)(a2 + 16) = unk_18FE956C8;
  CFTypeRef cf = 0;
  xpc_object_t value = 0;
  if (result)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    CFArrayRef result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      CFArrayRef result = CFDictionaryGetValueIfPresent(v3, @"width", (const void **)&value);
      if (result)
      {
        CFArrayRef result = CFDictionaryGetValueIfPresent(v3, @"height", &cf);
        if (result)
        {
          CFArrayRef result = (uint64_t)value;
          if (value)
          {
            CFTypeID v5 = CFGetTypeID(value);
            CFArrayRef result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              CFArrayRef result = (uint64_t)cf;
              if (cf)
              {
                CFTypeID v6 = CFGetTypeID(cf);
                CFArrayRef result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  uint64_t v7 = FigTextMarkupDimensionMakeFromSimplifiedDictionary(value);
                  uint64_t v9 = v8;
                  uint64_t v10 = FigTextMarkupDimensionMakeFromSimplifiedDictionary(cf);
                  return FigGeometrySizeMake(v7, v9, v10, v11, (void *)a2);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigTextMarkupAspectRatioCopyAsSimplifiedDictionary(uint64_t a1, const __CFAllocator *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a1;
  *(_OWORD *)keys = xmmword_1E567D118;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFDictionaryRef v4 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v5 = 0;
  char v6 = 1;
  do
  {
    char v7 = v6;
    uint64_t v8 = values[v5];
    if (v8) {
      CFRelease(v8);
    }
    char v6 = 0;
    uint64_t v5 = 1;
  }
  while ((v7 & 1) != 0);
  return v4;
}

unint64_t FigTextMarkupAspectRatioMakeFromSimplifiedDictionary(const void *a1)
{
  uint64_t v1 = 0;
  unsigned int v5 = 1;
  unsigned int v6 = 1;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFDictionaryGetTypeID()
      && FigCFDictionaryGetInt32IfPresent((uint64_t)a1, @"horizontal", &v6)
      && FigCFDictionaryGetInt32IfPresent((uint64_t)a1, @"vertical", &v5))
    {
      return FigGeometryAspectRatioMake(v6, v5);
    }
  }
  return v1;
}

uint64_t FigTextMarkupCreateTextMarkupFromRubyReserve(const void *a1, const __CFAllocator *a2, __CFDictionary **a3)
{
  if (!a1 || !a3 || (CFTypeID v6 = CFGetTypeID(a1), v6 != FigCaptionRubyReserveGetTypeID()))
  {
    uint64_t v16 = 4294950506;
LABEL_19:
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_19;
  }
  uint64_t v8 = Mutable;
  RubyPosition = (const void *)FigCaptionRubyReserveGetRubyPosition((uint64_t)a1);
  uint64_t Length = FigCaptionRubyReserveGetLength((uint64_t)a1);
  CFDictionaryRef v12 = FigGeometryDimensionCopyAsDictionary(Length, v11, a2);
  if (v12)
  {
    CFDictionaryRef v13 = v12;
    if (RubyPosition)
    {
      if (FigCFEqual(RubyPosition, @"RubyPositionBefore"))
      {
        uint64_t v14 = @"CMRubyPosition_Before";
LABEL_15:
        CFDictionarySetValue(v8, @"CMRubyReservePosition", v14);
        goto LABEL_16;
      }
      if (FigCFEqual(RubyPosition, @"RubyPositionAfter"))
      {
        uint64_t v14 = @"CMRubyPosition_After";
        goto LABEL_15;
      }
      if (FigCFEqual(RubyPosition, @"RubyPositionOutside"))
      {
        uint64_t v14 = @"CMRubyPosition_Outside";
        goto LABEL_15;
      }
      if (FigCFEqual(RubyPosition, @"RubyPositionBoth"))
      {
        uint64_t v14 = @"CMRubyPosition_Both";
        goto LABEL_15;
      }
    }
LABEL_16:
    CFDictionarySetValue(v8, @"CMRubyReserveLength", v13);
    *a3 = v8;
    CFRelease(v13);
    return 0;
  }
  uint64_t v17 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
  CFRelease(v8);
  return v17;
}

uint64_t FigTextMarkupCreateRubyReserveFromTextMarkup(const void *a1, uint64_t a2, void *a3)
{
  uint64_t v16 = 0;
  if (a1
    && a3
    && (CFTypeID v6 = CFGetTypeID(a1), v6 == CFDictionaryGetTypeID())
    && (CFSetRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"CMRubyReservePosition")) != 0
    && (v8 = Value, CFTypeID v9 = CFGetTypeID(Value), v9 == CFStringGetTypeID())
    && (uint64_t v10 = CFDictionaryGetValue((CFDictionaryRef)a1, @"CMRubyReserveLength")) != 0
    && (uint64_t v11 = v10, v12 = CFGetTypeID(v10), v12 == CFDictionaryGetTypeID()))
  {
    CFDictionaryRef v13 = FigGeometryDimensionMakeFromDictionary(v11);
    uint64_t result = FigCaptionRubyReserveCreate(a2, v8, (uint64_t)v13, v14, &v16);
    *a3 = v16;
  }
  else
  {
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigTextMarkupCreateTextMarkupFromTextEmphasis(const void *a1, const __CFAllocator *a2, __CFDictionary **a3)
{
  if (!a1 || !a3 || (CFTypeID v6 = CFGetTypeID(a1), v6 != FigCaptionTextEmphasisGetTypeID()))
  {
    uint64_t v24 = 4294950506;
LABEL_40:
    return FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    uint64_t v24 = 0xFFFFFFFFLL;
    goto LABEL_40;
  }
  uint64_t v8 = Mutable;
  int EmphasisStyle = FigCaptionTextEmphasisGetEmphasisStyle((uint64_t)a1);
  Color = (CGColor *)FigCaptionTextEmphasisGetColor((uint64_t)a1);
  RubyPosition = (const void *)FigCaptionTextEmphasisGetRubyPosition((uint64_t)a1);
  CFTypeID v12 = @"None";
  switch(EmphasisStyle)
  {
    case 0:
      goto LABEL_7;
    case 1:
      CFTypeID v12 = @"Auto";
LABEL_7:
      CFDictionaryRef v13 = @"CMTextEmphasisType";
      goto LABEL_13;
    case 2:
      CFDictionarySetValue(v8, @"CMTextEmphasisType", @"Predefined");
      int MarkingStyle = FigCaptionTextEmphasisGetMarkingStyle((uint64_t)a1);
      PredefinedMaruint64_t k = FigCaptionTextEmphasisGetPredefinedMark((uint64_t)a1);
      int v16 = PredefinedMark;
      if (MarkingStyle == 2)
      {
        char v17 = 0;
        uint64_t v18 = @"Stroked";
      }
      else if (MarkingStyle == 1)
      {
        char v17 = 0;
        uint64_t v18 = @"Filled";
      }
      else
      {
        uint64_t v18 = 0;
        char v17 = 1;
      }
      if ((PredefinedMark - 1) > 2)
      {
        unint64_t v23 = 0;
        if (v17) {
          goto LABEL_36;
        }
      }
      else
      {
        unint64_t v23 = off_1E567D188[PredefinedMark - 1];
        if (v17) {
          goto LABEL_36;
        }
      }
      CFDictionarySetValue(v8, @"CMTextEmphasisMarkingStyle", v18);
LABEL_36:
      if (v16)
      {
        CFDictionaryRef v13 = @"CMTextEmphasisMarkType";
        uint64_t v20 = v8;
        CFTypeID v12 = v23;
LABEL_14:
        CFDictionarySetValue(v20, v13, v12);
      }
LABEL_15:
      if (Color)
      {
        Color = FigTextMarkupCreateARGBColorArrayFromCGColor(Color);
        if (Color) {
          CFDictionarySetValue(v8, @"CMTextEmphasisColor", Color);
        }
      }
      if (FigCFEqual(RubyPosition, @"RubyPositionAfter"))
      {
        uint64_t v21 = @"CMRubyPosition_After";
        if (!RubyPosition) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
      if (FigCFEqual(RubyPosition, @"RubyPositionOutside")) {
        uint64_t v21 = @"CMRubyPosition_Outside";
      }
      else {
        uint64_t v21 = @"CMRubyPosition_Before";
      }
      if (RubyPosition) {
LABEL_20:
      }
        CFDictionarySetValue(v8, @"CMTextEmphasisPosition", v21);
LABEL_21:
      *a3 = v8;
      if (Color) {
        CFRelease(Color);
      }
      uint64_t result = 0;
      break;
    case 3:
      CFDictionarySetValue(v8, @"CMTextEmphasisType", @"Custom");
      CustomMaruint64_t k = FigCaptionTextEmphasisGetCustomMark((uint64_t)a1);
      if (!CustomMark) {
        goto LABEL_15;
      }
      CFTypeID v12 = (__CFString *)CustomMark;
      CFDictionaryRef v13 = @"CMTextEmphasisCustomMark";
LABEL_13:
      uint64_t v20 = v8;
      goto LABEL_14;
    default:
      goto LABEL_15;
  }
  return result;
}

uint64_t FigTextMarkupCreateTextMarkupFromAbstractPosition(const void *a1, const __CFAllocator *a2, CFMutableDictionaryRef *a3)
{
  if (a1 && a3 && (CFTypeID v6 = CFGetTypeID(a1), v6 == FigCaptionPositionGetTypeID()))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v8 = Mutable;
      int HorizontalEdgeReference = FigCaptionPositionGetHorizontalEdgeReference((uint64_t)a1);
      int VerticalEdgeReference = FigCaptionPositionGetVerticalEdgeReference((uint64_t)a1);
      uint64_t HorizontalEdgeOffset = FigCaptionPositionGetHorizontalEdgeOffset((uint64_t)a1);
      uint64_t v13 = v12;
      uint64_t VerticalEdgeOffset = FigCaptionPositionGetVerticalEdgeOffset((uint64_t)a1);
      if ((v13 & 0x1D00000000) == 0x100000000)
      {
        uint64_t v16 = VerticalEdgeOffset;
        uint64_t v17 = v15;
        CFDictionaryRef v18 = FigGeometryDimensionCopyAsDictionary(HorizontalEdgeOffset, v13, a2);
        if (!v18 || (CFDictionaryRef v19 = FigGeometryDimensionCopyAsDictionary(v16, v17, a2)) == 0)
        {
          uint64_t v23 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
          CFRelease(v8);
          CFDictionaryRef v20 = 0;
          if (!v18) {
            goto LABEL_20;
          }
          goto LABEL_19;
        }
        CFDictionaryRef v20 = v19;
      }
      else
      {
        CFDictionaryRef v18 = 0;
        CFDictionaryRef v20 = 0;
      }
      EdgeReferenceMarkupAttributeCFSetRef Value = ftmarkup_getEdgeReferenceMarkupAttributeValue(HorizontalEdgeReference);
      int v22 = ftmarkup_getEdgeReferenceMarkupAttributeValue(VerticalEdgeReference);
      if (EdgeReferenceMarkupAttributeValue) {
        CFDictionarySetValue(v8, @"CMHorizontalEdgeReference", EdgeReferenceMarkupAttributeValue);
      }
      if (v22) {
        CFDictionarySetValue(v8, @"CMVerticalEdgeReference", v22);
      }
      if (v18) {
        CFDictionarySetValue(v8, @"CMHorizontalEdgeOffset", v18);
      }
      if (v20) {
        CFDictionarySetValue(v8, @"CMVerticalEdgeOffset", v20);
      }
      uint64_t v23 = 0;
      *a3 = v8;
      if (!v18) {
        goto LABEL_20;
      }
LABEL_19:
      CFRelease(v18);
LABEL_20:
      if (v20) {
        CFRelease(v20);
      }
      return v23;
    }
    uint64_t v25 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v25 = 4294950506;
  }

  return FigSignalErrorAt(v25, 0, 0, 0, 0, 0, 0);
}

__CFString *ftmarkup_getEdgeReferenceMarkupAttributeValue(int a1)
{
  if (a1 > 1701999214)
  {
    if (a1 > 1919510375)
    {
      if (a1 == 1919510376) {
        return @"CMEdgeReference_Right";
      }
      if (a1 == 1953460256) {
        return @"CMEdgeReference_Top";
      }
      goto LABEL_14;
    }
    if (a1 != 1701999215)
    {
      if (a1 == 1818584692) {
        return @"CMEdgeReference_Left";
      }
LABEL_14:
      FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  if (!a1) {
    return 0;
  }
  if (a1 != 1651471476)
  {
    if (a1 == 1667591796) {
      return @"CMEdgeReference_Center";
    }
    goto LABEL_14;
  }
  return @"CMEdgeReference_Bottom";
}

uint64_t FigTextMarkupCreateTextMarkupFromTextShadowList(const void *a1, const __CFAllocator *a2, __CFDictionary **a3)
{
  if (a1 && (CFTypeID v3 = a3) != 0 && (v5 = CFGetTypeID(a1), v5 == FigCaptionTextShadowListGetTypeID()))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      char v7 = Mutable;
      TextShadowArradouble y = (const __CFArray *)FigCaptionTextShadowListGetTextShadowArray((uint64_t)a1);
      CFArrayRef v9 = TextShadowArray;
      if (TextShadowArray)
      {
        if (CFArrayGetCount(TextShadowArray))
        {
          if (CFArrayGetCount(v9) < 1)
          {
            uint64_t v11 = 0;
            uint64_t v12 = 0;
            Color = 0;
            CFDictionaryRef v14 = 0;
            CFDictionaryRef v15 = 0;
            CFDictionaryRef v16 = 0;
LABEL_35:
            CFArrayRef v9 = 0;
            *CFTypeID v3 = v7;
            char v7 = 0;
            if (v16) {
LABEL_36:
            }
              CFRelease(v16);
          }
          else
          {
            CFTypeRef v33 = v3;
            theDict = v7;
            CFIndex v10 = 0;
            uint64_t v11 = 0;
            uint64_t v12 = 0;
            Color = 0;
            CFDictionaryRef v14 = 0;
            CFDictionaryRef v15 = 0;
            CFDictionaryRef v16 = 0;
            CFAllocatorRef v35 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFArrayRef v36 = v9;
            while (1)
            {
              if (v11) {
                CFRelease(v11);
              }
              if (v16) {
                CFRelease(v16);
              }
              if (v15) {
                CFRelease(v15);
              }
              if (v14) {
                CFRelease(v14);
              }
              if (Color) {
                CFRelease(Color);
              }
              ValueAtIndedouble x = CFArrayGetValueAtIndex(v9, v10);
              if (!ValueAtIndex
                || (uint64_t v18 = (uint64_t)ValueAtIndex, v19 = CFGetTypeID(ValueAtIndex), v19 != FigCaptionTextShadowGetTypeID()))
              {
                CFArrayRef v9 = (const __CFArray *)FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
                char v7 = theDict;
                if (v12) {
                  goto LABEL_46;
                }
                goto LABEL_47;
              }
              theArradouble y = v12;
              CFDictionaryRef v20 = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              uint64_t HorizontalAxisOffset = FigCaptionTextShadowGetHorizontalAxisOffset(v18);
              uint64_t v23 = v22;
              uint64_t VerticalAxisOffset = FigCaptionTextShadowGetVerticalAxisOffset(v18);
              uint64_t v26 = v25;
              uint64_t BlurRadius = FigCaptionTextShadowGetBlurRadius(v18);
              uint64_t v29 = v28;
              Color = (void *)FigCaptionTextShadowGetColor(v18);
              CFDictionaryRef v16 = FigGeometryDimensionCopyAsDictionary(HorizontalAxisOffset, v23, v35);
              CFDictionaryRef v15 = FigGeometryDimensionCopyAsDictionary(VerticalAxisOffset, v26, v35);
              uint64_t v30 = v29;
              uint64_t v11 = v20;
              CFDictionaryRef v14 = FigGeometryDimensionCopyAsDictionary(BlurRadius, v30, v35);
              if (v16) {
                CFDictionarySetValue(v20, @"CMTextShadowHorizontalAxisOffset", v16);
              }
              if (v15) {
                CFDictionarySetValue(v20, @"CMTextShadowVerticalAxisOffset", v15);
              }
              uint64_t v12 = theArray;
              CFArrayRef v9 = v36;
              if (v14) {
                CFDictionarySetValue(v20, @"CMTextShadowBlurRadius", v14);
              }
              if (Color)
              {
                Color = FigTextMarkupCreateARGBColorArrayFromCGColor((CGColor *)Color);
                if (Color) {
                  CFDictionarySetValue(v20, @"CMTextShadowColor", Color);
                }
              }
              if (!theArray)
              {
                uint64_t v12 = CFArrayCreateMutable(a2, 0, MEMORY[0x1E4F1D510]);
                if (!v12) {
                  break;
                }
              }
              CFArrayAppendValue(v12, v20);
              if (++v10 >= CFArrayGetCount(v36))
              {
                char v7 = theDict;
                CFDictionarySetValue(theDict, @"CMTextShadowList", v12);
                CFTypeID v3 = v33;
                goto LABEL_35;
              }
            }
            CFArrayRef v9 = (const __CFArray *)FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
            char v7 = theDict;
            if (v16) {
              goto LABEL_36;
            }
          }
          if (v15) {
            CFRelease(v15);
          }
          if (v14) {
            CFRelease(v14);
          }
          if (Color) {
            CFRelease(Color);
          }
          if (v11) {
            CFRelease(v11);
          }
          if (v12) {
LABEL_46:
          }
            CFRelease(v12);
LABEL_47:
          if (!v7) {
            return (uint64_t)v9;
          }
        }
        else
        {
          CFArrayRef v9 = 0;
        }
      }
      CFRelease(v7);
      return (uint64_t)v9;
    }
    uint64_t v32 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v32 = 4294950506;
  }

  return FigSignalErrorAt(v32, 0, 0, 0, 0, 0, 0);
}

BOOL FigTextMarkupMapGenericFontFamilyToMACaptionAppearanceFontStyle(const void *a1, void *a2)
{
  int valuePtr = 0;
  FigThreadRunOnce(&gCreateGenericFontNameToMACaptionAppearanceFontStyleMappingDictOnce, figtextmarkup_setUpGenericFontNameToMACaptionAppearanceFontStyleMapping);
  if (!a1)
  {
    LODWORD(Value) = FigSignalErrorAt(4294967246, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)gGenericFontNameToMACaptionAppearanceFontStyleMappingDict, a1);
  if (!Value)
  {
LABEL_8:
    uint64_t v8 = 0;
LABEL_9:
    BOOL v7 = 0;
    if (!a2) {
      return !Value && v7;
    }
    goto LABEL_10;
  }
  CFNumberRef v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFNumberGetTypeID())
  {
    uint64_t v8 = 0;
    LODWORD(Value) = 0;
    goto LABEL_9;
  }
  CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
  LODWORD(Value) = 0;
  BOOL v7 = valuePtr >= 0;
  uint64_t v8 = valuePtr & ~(valuePtr >> 31);
  if (a2) {
LABEL_10:
  }
    *a2 = v8;
  return !Value && v7;
}

void figtextmarkup_setUpGenericFontNameToMACaptionAppearanceFontStyleMapping()
{
  uint64_t v0 = 0;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v10 = xmmword_1E567D148;
  long long v11 = *(_OWORD *)&off_1E567D158;
  long long v12 = xmmword_1E567D168;
  long long v13 = *(_OWORD *)off_1E567D178;
  *(_OWORD *)keys = xmmword_1E567D128;
  long long v9 = *(_OWORD *)&off_1E567D138;
  valuePtr[0] = xmmword_18FE96B98;
  valuePtr[1] = unk_18FE96BA8;
  valuePtr[2] = xmmword_18FE96BB8;
  memset(v6, 0, sizeof(v6));
  uint64_t v1 = valuePtr;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    *(void *)((char *)v6 + v0) = CFNumberCreate(v2, kCFNumberSInt32Type, v1);
    v0 += 8;
    uint64_t v1 = (_OWORD *)((char *)v1 + 4);
  }
  while (v0 != 96);
  CFDictionaryRef v3 = CFDictionaryCreate(v2, (const void **)keys, (const void **)v6, 12, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v4 = 0;
  gGenericFontNameToMACaptionAppearanceFontStyleMappingDict = (uint64_t)v3;
  do
  {
    CFNumberRef v5 = *(const void **)((char *)v6 + v4);
    if (v5)
    {
      CFRelease(v5);
      *(void *)((char *)v6 + v4) = 0;
    }
    v4 += 8;
  }
  while (v4 != 96);
}

uint64_t FigEndpointAggregateGetClassID()
{
  if (FigEndpointAggregateGetClassID_sRegisterFigEndpointAggregateBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointAggregateGetClassID_sRegisterFigEndpointAggregateBaseTypeOnce, &FigEndpointAggregateGetClassID_sFigEndpointAggregateClassID, (dispatch_function_t)FigEndpointAggregateGetClassIDCallback);
  }
  return FigEndpointAggregateGetClassID_sFigEndpointAggregateClassID;
}

uint64_t FigEndpointAggregateGetClassIDCallback(void *a1)
{
  ClassID = (void *)FigEndpointExtendedGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigEndpointAggregateGetClassIDCallback_sFigEndpointAggregateClassDesc, ClassID, 0, a1);
}

CFStringRef FigEndpointAggregateBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointAggregate %p]", a1);
}

CFIndex FigPixelBufferOriginAppendPixelBufferToIPCMessageData(uint64_t a1, CVPixelBufferRef pixelBuffer, int a3, uint64_t a4, uint64_t a5, unint64_t a6, size_t *a7)
{
  if (a5)
  {
    if (!pixelBuffer) {
      goto LABEL_25;
    }
    uint64_t v11 = 4294951703;
    if (a6 >= 0x2C && a1)
    {
      IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
      if (IOSurface)
      {
        CFDictionaryRef v16 = IOSurface;
        pixelBufferOrigin_registerPixelBuffer(a1, pixelBuffer);
        *(void *)a5 = *(void *)(a1 + 32);
        *(_DWORD *)(a5 + 8) = IOSurfaceGetID(v16);
        long long extraColumnsOnRight = 0uLL;
        size_t v25 = 0;
        size_t extraRowsOnTop = 0;
        CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&extraColumnsOnRight + 1, (size_t *)&extraColumnsOnRight, &extraRowsOnTop, &v25);
        *(void *)(a5 + 12) = *((void *)&extraColumnsOnRight + 1);
        *(void *)(a5 + 20) = extraColumnsOnRight;
        *(void *)(a5 + 28) = extraRowsOnTop;
        *(void *)(a5 + 36) = v25;
        long long extraColumnsOnRight = 0uLL;
        size_t extraRowsOnTop = 0;
        pixelBufferSharing_copyPixelBufferAttachments(pixelBuffer, a3, (const __CFDictionary **)&extraColumnsOnRight + 1, (CFDictionaryRef *)&extraColumnsOnRight);
        uint64_t v17 = (__CFString *)*((void *)&extraColumnsOnRight + 1);
        if (extraColumnsOnRight != 0)
        {
          unint64_t v18 = a6 - 60;
          *(void *)(a5 + 44) = 0;
          CFIndex appended = FigInMemorySerializerAppendCFDictionary(a5 + 60, a6 - 60, (uint64_t *)&extraRowsOnTop, v17, 0, a4, *(void *)(a1 + 40));
          size_t v20 = extraRowsOnTop;
          if (!appended)
          {
            *(void *)(a5 + 44) = extraRowsOnTop;
            *(void *)(a5 + 52) = 0;
            if (FigInMemorySerializerAppendCFDictionary(a5 + 60 + v20, v18 - v20, (uint64_t *)&extraRowsOnTop, (__CFString *)extraColumnsOnRight, 0, a4, *(void *)(a1 + 40)))
            {
              size_t v21 = *(void *)(a5 + 52);
            }
            else
            {
              size_t v21 = extraRowsOnTop;
              *(void *)(a5 + 52) = extraRowsOnTop;
            }
            size_t v22 = *(void *)(a5 + 44) + v21;
            size_t extraRowsOnTop = v22;
            if (v22)
            {
              size_t v20 = v22 + 16;
              size_t extraRowsOnTop = v22 + 16;
            }
            else
            {
              size_t v20 = 0;
            }
          }
          if (*((void *)&extraColumnsOnRight + 1)) {
            CFRelease(*((CFTypeRef *)&extraColumnsOnRight + 1));
          }
          if ((void)extraColumnsOnRight) {
            CFRelease((CFTypeRef)extraColumnsOnRight);
          }
          if (appended)
          {
            pixelBufferOrigin_unregisterPixelBuffer(a1);
            return appended;
          }
          goto LABEL_26;
        }
LABEL_25:
        size_t v20 = 0;
LABEL_26:
        if (!a7) {
          return 0;
        }
        goto LABEL_27;
      }
      uint64_t v11 = 4294951700;
    }
LABEL_24:
    CFIndex appended = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
    if (appended) {
      return appended;
    }
    goto LABEL_25;
  }
  if (!a7)
  {
    uint64_t v11 = 4294951703;
    goto LABEL_24;
  }
  size_t v20 = 0;
LABEL_27:
  CFIndex appended = 0;
  size_t v23 = v20 + 44;
  if (!pixelBuffer) {
    size_t v23 = 0;
  }
  *a7 = v23;
  return appended;
}

uint64_t pixelBufferOrigin_registerPixelBuffer(uint64_t a1, __CVBuffer *a2)
{
  uint64_t BufferBacking = CVPixelBufferGetBufferBacking();
  IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 24), (const void *)-BufferBacking))
  {
    CFTypeID v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    v6[1] = FigCFWeakReferenceHolderCreateWithReferencedObject(BufferBacking);
    if (IOSurface) {
      CFTypeRef v7 = CFRetain(IOSurface);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *CFTypeID v6 = v7;
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(LocalCenter, (const void *)a1, (CFNotificationCallback)pixelBufferOrigin_backingNotificationListener, (CFStringRef)*MEMORY[0x1E4F24978], (const void *)BufferBacking, (CFNotificationSuspensionBehavior)1028);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)-BufferBacking, v6);
  }
  long long v9 = *(pthread_mutex_t **)(a1 + 16);

  return FigSimpleMutexUnlock(v9);
}

void pixelBufferOrigin_unregisterPixelBuffer(uint64_t a1)
{
  uint64_t BufferBacking = CVPixelBufferGetBufferBacking();
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  CFNumberRef Value = (CFTypeRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), (const void *)-BufferBacking);
  if (Value)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)-BufferBacking);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a1, (CFNotificationName)*MEMORY[0x1E4F24978], (const void *)BufferBacking);
  }
  else
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }

  pixelBufferOrigin_disposeBufferBackingEntry(Value);
}

void *FigPixelBufferOriginSetPixelBufferInXPCMessage(uint64_t a1, void *a2, const char *a3, CVPixelBufferRef pixelBuffer, int a5)
{
  if (!pixelBuffer)
  {
    xpc_object_t v13 = 0;
    IOSurfaceRef IOSurface = 0;
    long long v12 = 0;
    uint64_t v17 = 0;
    goto LABEL_28;
  }
  if (!a1)
  {
    uint64_t v17 = (void *)FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    xpc_object_t v13 = 0;
    IOSurfaceRef IOSurface = 0;
LABEL_32:
    long long v12 = 0;
    goto LABEL_28;
  }
  IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
  if (!IOSurface)
  {
    uint64_t v17 = (void *)FigSignalErrorAt(4294951700, 0, 0, 0, 0, 0, 0);
    xpc_object_t v13 = 0;
    goto LABEL_32;
  }
  pixelBufferOrigin_registerPixelBuffer(a1, pixelBuffer);
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  long long v12 = v11;
  if (!v11)
  {
    xpc_object_t v13 = 0;
    goto LABEL_34;
  }
  xpc_dictionary_set_uint64(v11, ".objectID", *(void *)(a1 + 32));
  xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
  if (!v13 || (XPCObject = (__IOSurface *)IOSurfaceCreateXPCObject(IOSurface)) == 0)
  {
LABEL_34:
    uint64_t v17 = (void *)FigSignalErrorAt(4294951705, 0, 0, 0, 0, 0, 0);
    IOSurfaceRef IOSurface = 0;
    if (!v17) {
      goto LABEL_28;
    }
LABEL_35:
    pixelBufferOrigin_unregisterPixelBuffer(a1);
    goto LABEL_28;
  }
  IOSurfaceRef IOSurface = XPCObject;
  xpc_dictionary_set_value(v13, "IOSurface", XPCObject);
  size_t extraColumnsOnRight = 0;
  size_t extraColumnsOnLeft = 0;
  int64_t value = 0;
  size_t extraRowsOnTop = 0;
  CVPixelBufferGetExtendedPixels(pixelBuffer, &extraColumnsOnLeft, &extraColumnsOnRight, &extraRowsOnTop, (size_t *)&value);
  if (extraColumnsOnLeft) {
    xpc_dictionary_set_int64(v13, "ExtendedPixelsLeft", extraColumnsOnLeft);
  }
  if (extraColumnsOnRight) {
    xpc_dictionary_set_int64(v13, "ExtendedPixelsRight", extraColumnsOnRight);
  }
  if (extraRowsOnTop) {
    xpc_dictionary_set_int64(v13, "ExtendedPixelsTop", extraRowsOnTop);
  }
  if (value) {
    xpc_dictionary_set_int64(v13, "ExtendedPixelsBottom", value);
  }
  size_t extraColumnsOnRight = 0;
  size_t extraColumnsOnLeft = 0;
  pixelBufferSharing_copyPixelBufferAttachments(pixelBuffer, a5, (const __CFDictionary **)&extraColumnsOnLeft, (CFDictionaryRef *)&extraColumnsOnRight);
  if ((uint64_t)FigCFDictionaryGetCount((CFDictionaryRef)extraColumnsOnLeft) >= 1)
  {
    CFDictionaryRef v15 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (!v15)
    {
      uint64_t v17 = (void *)FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
      goto LABEL_22;
    }
    CFDictionaryRef v16 = v15;
    xpc_dictionary_set_value(v13, "PropagatedAttachments", v15);
    xpc_release(v16);
  }
  if ((uint64_t)FigCFDictionaryGetCount((CFDictionaryRef)extraColumnsOnRight) >= 1)
  {
    uint64_t v17 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (!v17) {
      goto LABEL_22;
    }
    xpc_dictionary_set_value(v13, "NonPropagatedAttachments", v17);
    xpc_release(v17);
  }
  uint64_t v17 = 0;
LABEL_22:
  if (extraColumnsOnLeft) {
    CFRelease((CFTypeRef)extraColumnsOnLeft);
  }
  if (extraColumnsOnRight) {
    CFRelease((CFTypeRef)extraColumnsOnRight);
  }
  if (v17) {
    goto LABEL_35;
  }
  xpc_dictionary_set_value(v12, "PixelBufferComponents", v13);
  xpc_dictionary_set_value(a2, a3, v12);
LABEL_28:
  FigXPCRelease(IOSurface);
  FigXPCRelease(v12);
  FigXPCRelease(v13);
  return v17;
}

uint64_t FigPixelBufferOriginSetTaggedBufferGroupInXPCMessage(uint64_t a1, void *a2, const char *a3, uint64_t a4, int a5)
{
  emptdouble y = xpc_array_create_empty();
  uint64_t Count = FigTaggedBufferGroupGetCount(a4);
  if (Count < 1)
  {
LABEL_11:
    xpc_dictionary_set_value(a2, a3, empty);
    uint64_t v18 = 0;
    CFDictionaryRef v16 = 0;
    xpc_object_t v12 = 0;
  }
  else
  {
    uint64_t v9 = Count;
    uint64_t v10 = 0;
    uint64_t v11 = *MEMORY[0x1E4F1CF80];
    while (1)
    {
      xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
      CVPixelBufferAtIndedouble x = FigTaggedBufferGroupGetCVPixelBufferAtIndex(a4, v10);
      if (!CVPixelBufferAtIndex) {
        break;
      }
      uint64_t v14 = (__CVBuffer *)CVPixelBufferAtIndex;
      TagCollectionAtIndedouble x = FigTaggedBufferGroupGetTagCollectionAtIndex(a4, v10);
      CFDictionaryRef v16 = (const void *)FigTagCollectionCopyAsData(TagCollectionAtIndex, v11);
      uint64_t v17 = FigXPCMessageSetCFData(v12, "EntryTagCollection", v16);
      if (v17
        || (uint64_t v17 = (uint64_t)FigPixelBufferOriginSetPixelBufferInXPCMessage(a1, v12, "EntryPixelBuffer", v14, a5),
            v17))
      {
        uint64_t v18 = v17;
        goto LABEL_12;
      }
      xpc_array_append_value(empty, v12);
      if (v12) {
        xpc_release(v12);
      }
      if (v16) {
        CFRelease(v16);
      }
      if (v9 == ++v10) {
        goto LABEL_11;
      }
    }
    uint64_t v18 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef v16 = 0;
  }
LABEL_12:
  FigXPCRelease(empty);
  FigXPCRelease(v12);
  if (v16) {
    CFRelease(v16);
  }
  return v18;
}

uint64_t FigPixelBufferOriginBeginEstablishingPixelBufferRecipientByFillingInXPCMessage1(void *a1)
{
  xpc_object_t value = 0;
  if (EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartOnce != -1) {
    dispatch_once(&EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartOnce, &__block_literal_global_41);
  }
  uint64_t v2 = EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartError;
  if (EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartError)
  {
    xpc_object_t v3 = 0;
  }
  else
  {
    uint64_t v2 = FigXPCServerCopyXPCEndpoint(gPixelBufferOriginServer, &value);
    xpc_object_t v3 = value;
    if (!v2)
    {
      xpc_dictionary_set_value(a1, "PixelBufferOriginEndpoint", value);
      xpc_object_t v3 = value;
    }
  }
  FigXPCRelease(v3);
  return v2;
}

uint64_t FigPixelBufferOriginCompleteEstablishingPixelBufferRecipientUsingXPCMessage2(void *a1, void *a2)
{
  uint64 = (void *)xpc_dictionary_get_uint64(a1, ".objectID");
  uint64_t v4 = (uint64_t *)gPixelBufferOriginServer;

  return FigXPCServerRetainNeighborObjectFromID(v4, uint64, a2);
}

uint64_t FigPixelBufferOriginGetObjectID(uint64_t a1, void *a2)
{
  if (!a1 || !a2) {
    return FigSignalErrorAt(4294951706, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *(void *)(a1 + 32);
  return 0;
}

uint64_t FigPixelBufferOriginServerCopyPixelBufferOriginForObjectID(void *a1, void *a2)
{
  uint64_t v5 = 0;
  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      if (gPixelBufferOriginServer)
      {
        uint64_t result = FigXPCServerRetainNeighborObjectFromID((uint64_t *)gPixelBufferOriginServer, a1, &v5);
        *a2 = v5;
        return result;
      }
      uint64_t v4 = 4294951704;
    }
    else
    {
      uint64_t v4 = 4294951706;
    }
  }
  else
  {
    uint64_t v4 = 4294951706;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPixelBufferRecipientCopyPixelBufferFromXPCMessage(uint64_t a1, xpc_object_t xdict, char *key, __CVBuffer **a4)
{
  CFTypeRef cf = 0;
  if (a4)
  {
    if (!a1) {
      goto LABEL_22;
    }
    xpc_object_t value = xpc_dictionary_get_value(xdict, key);
    if (!value)
    {
      uint64_t v15 = 0;
      goto LABEL_19;
    }
    CFTypeRef v7 = value;
    xpc_object_t v8 = xpc_dictionary_get_value(value, "PixelBufferComponents");
    if (xpc_dictionary_get_uint64(v7, ".objectID") != *(void *)(a1 + 16)
      || (xpc_object_t v9 = xpc_dictionary_get_value(v8, "IOSurface")) == 0)
    {
LABEL_22:
      uint64_t v15 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
      goto LABEL_19;
    }
    uint64_t v10 = IOSurfaceLookupFromXPCObject(v9);
    IOSurfaceID ID = IOSurfaceGetID(v10);
    uint64_t v12 = pixelBufferRecipient_createRecipientPixelBuffer(a1, ID, (uint64_t (*)(uint64_t, uint64_t, CFTypeRef *))pixelBufferRecipient_copyCVPixelBufferFromXPCComponents, (uint64_t)v8, &cf);
    if (v12
      || (xpc_object_t v13 = (__CVBuffer *)cf,
          CFDictionaryRef theAttachments = 0,
          uint64_t v12 = FigXPCMessageCopyCFDictionary(v8, "PropagatedAttachments", &theAttachments),
          v12))
    {
      uint64_t v15 = v12;
      if (!v10) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    if (theAttachments)
    {
      CVBufferSetAttachments(v13, theAttachments, kCVAttachmentMode_ShouldPropagate);
      if (theAttachments)
      {
        CFRelease(theAttachments);
        CFDictionaryRef theAttachments = 0;
      }
    }
    uint64_t v14 = FigXPCMessageCopyCFDictionary(v8, "NonPropagatedAttachments", &theAttachments);
    uint64_t v15 = v14;
    if (v14 || !theAttachments)
    {
      if (v14) {
        goto LABEL_17;
      }
    }
    else
    {
      CVBufferSetAttachments(v13, theAttachments, kCVAttachmentMode_ShouldNotPropagate);
      if (theAttachments) {
        CFRelease(theAttachments);
      }
    }
    uint64_t v15 = 0;
    *a4 = v13;
    CFTypeRef cf = 0;
LABEL_17:
    if (!v10)
    {
LABEL_19:
      if (cf) {
        CFRelease(cf);
      }
      return v15;
    }
LABEL_18:
    CFRelease(v10);
    goto LABEL_19;
  }

  return FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
}

uint64_t pixelBufferRecipient_createRecipientPixelBuffer(uint64_t a1, unsigned int a2, uint64_t (*a3)(uint64_t, uint64_t, CFTypeRef *), uint64_t a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  unint64_t v9 = a2;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), (const void *)v9))
  {
    uint64_t v10 = CVPixelBufferCreateWithBufferBacking();
    if (v10) {
      goto LABEL_12;
    }
LABEL_7:
    uint64_t v12 = 0;
    *a5 = cf;
    CFTypeRef cf = 0;
    goto LABEL_8;
  }
  uint64_t v10 = a3(a1, a4, &cf);
  if (!v10)
  {
    uint64_t BufferBacking = (const void *)CVPixelBufferGetBufferBacking();
    if (BufferBacking)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), (const void *)v9, BufferBacking);
      goto LABEL_7;
    }
    uint64_t v10 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
  }
LABEL_12:
  uint64_t v12 = v10;
LABEL_8:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

uint64_t pixelBufferRecipient_copyCVPixelBufferFromXPCComponents(uint64_t a1, void *a2, CVPixelBufferRef *a3)
{
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  int64_t int64 = xpc_dictionary_get_int64(a2, "ExtendedPixelsLeft");
  if (int64) {
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CE0], int64);
  }
  int64_t v8 = xpc_dictionary_get_int64(a2, "ExtendedPixelsRight");
  if (v8) {
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CE8], v8);
  }
  int64_t v9 = xpc_dictionary_get_int64(a2, "ExtendedPixelsTop");
  if (v9) {
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CF0], v9);
  }
  int64_t v10 = xpc_dictionary_get_int64(a2, "ExtendedPixelsBottom");
  if (v10) {
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CD0], v10);
  }
  xpc_object_t value = xpc_dictionary_get_value(a2, "IOSurface");
  if (value)
  {
    uint64_t v12 = IOSurfaceLookupFromXPCObject(value);
    if (v12)
    {
      uint64_t v13 = CVPixelBufferCreateWithIOSurface(v5, v12, Mutable, &pixelBufferOut);
      if (!v13)
      {
        *a3 = pixelBufferOut;
        CVPixelBufferRef pixelBufferOut = 0;
      }
    }
    else
    {
      uint64_t v13 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    uint64_t v13 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    uint64_t v12 = 0;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (pixelBufferOut) {
    CFRelease(pixelBufferOut);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v13;
}

uint64_t FigPixelBufferRecipientCopyPixelBufferFromIPCMessageData(uint64_t a1, uint64_t a2, uint64_t a3, __CVBuffer **a4)
{
  CFTypeRef v17 = 0;
  if (a4 && a1 && *(void *)a2 == *(void *)(a1 + 16))
  {
    uint64_t v8 = pixelBufferRecipient_createRecipientPixelBuffer(a1, *(_DWORD *)(a2 + 8), (uint64_t (*)(uint64_t, uint64_t, CFTypeRef *))pixelBufferRecipient_copyCVPixelBufferFromSerializedPixelBufferDescription, a2, &v17);
    int64_t v9 = (__CVBuffer *)v17;
    if (v8) {
      goto LABEL_33;
    }
    CFTypeRef cf = 0;
    CFDictionaryRef theAttachments = 0;
    if (a3 == 44 || !v17) {
      goto LABEL_28;
    }
    if ((unint64_t)(a3 - 44) <= 0xF
      || (uint64_t v10 = *(void *)(a2 + 44), v11 = *(void *)(a2 + 52), v11 >= ~v10)
      || v11 + v10 > a3 - 60)
    {
      uint64_t v12 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      uint64_t v12 = FigXPCRemoteClientCopyMemoryRecipient(*(void *)(a1 + 40), &cf);
      if (!v12)
      {
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v14 = FigInMemoryDeserializerCopyCFDictionary((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2 + 60, *(void *)(a2 + 44), (uint64_t)cf, &theAttachments);
        CFDictionaryRef v15 = theAttachments;
        if (v14)
        {
          uint64_t v8 = v14;
        }
        else
        {
          if (theAttachments)
          {
            CVBufferSetAttachments(v9, theAttachments, kCVAttachmentMode_ShouldPropagate);
            if (theAttachments)
            {
              CFRelease(theAttachments);
              CFDictionaryRef theAttachments = 0;
            }
          }
          uint64_t v8 = FigInMemoryDeserializerCopyCFDictionary(v13, a2 + 60 + *(void *)(a2 + 44), *(void *)(a2 + 52), (uint64_t)cf, &theAttachments);
          CFDictionaryRef v15 = theAttachments;
          if (!v8 && theAttachments)
          {
            CVBufferSetAttachments(v9, theAttachments, kCVAttachmentMode_ShouldNotPropagate);
            if (theAttachments)
            {
              CFRelease(theAttachments);
              uint64_t v8 = 0;
              CFDictionaryRef theAttachments = 0;
            }
            else
            {
              uint64_t v8 = 0;
            }
            goto LABEL_28;
          }
        }
        if (v15) {
          CFRelease(v15);
        }
LABEL_28:
        if (cf) {
          CFRelease(cf);
        }
        if (!v8)
        {
          *a4 = v9;
          return v8;
        }
LABEL_33:
        if (v9) {
          CFRelease(v9);
        }
        return v8;
      }
    }
    uint64_t v8 = v12;
    goto LABEL_28;
  }

  return FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
}

uint64_t pixelBufferRecipient_copyCVPixelBufferFromSerializedPixelBufferDescription(uint64_t a1, uint64_t a2, CVPixelBufferRef *a3)
{
  xpc_object_t xdict = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  xpc_object_t v17 = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  uint64_t v8 = FigXPCCreateBasicMessage(0x696D7073u, 0, &xdict);
  if (v8) {
    goto LABEL_23;
  }
  xpc_dictionary_set_int64(xdict, "IOSurfaceID", *(unsigned int *)(a2 + 8));
  uint64_t v8 = FigXPCRemoteClientSendSyncMessageCreatingReply(*(void *)(a1 + 40), (uint64_t)xdict, &v17);
  if (v8) {
    goto LABEL_23;
  }
  xpc_object_t value = xpc_dictionary_get_value(v17, "IOSurface");
  if (!value)
  {
    uint64_t v8 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
LABEL_23:
    uint64_t v15 = v8;
    uint64_t v10 = 0;
    goto LABEL_15;
  }
  uint64_t v10 = IOSurfaceLookupFromXPCObject(value);
  if (v10)
  {
    uint64_t v11 = *(void *)(a2 + 12);
    if (v11) {
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CE0], v11);
    }
    uint64_t v12 = *(void *)(a2 + 20);
    if (v12) {
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CE8], v12);
    }
    uint64_t v13 = *(void *)(a2 + 28);
    if (v13) {
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CF0], v13);
    }
    uint64_t v14 = *(void *)(a2 + 36);
    if (v14) {
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E4F24CD0], v14);
    }
    uint64_t v15 = CVPixelBufferCreateWithIOSurface(v6, v10, Mutable, &pixelBufferOut);
    if (!v15)
    {
      *a3 = pixelBufferOut;
      CVPixelBufferRef pixelBufferOut = 0;
    }
  }
  else
  {
    uint64_t v15 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
  }
LABEL_15:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (pixelBufferOut) {
    CFRelease(pixelBufferOut);
  }
  if (v10) {
    CFRelease(v10);
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v17);
  return v15;
}

uint64_t FigPixelBufferRecipientCopyTaggedBufferGroupFromXPCMessage(uint64_t a1, xpc_object_t xdict, char *key, __CFArray *a4)
{
  CFMutableDictionaryRef Mutable = a4;
  xpc_object_t value = 0;
  CFTypeRef cf = 0;
  CFTypeRef v19 = 0;
  CFTypeRef v20 = 0;
  if (!a4)
  {
    uint64_t v16 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
LABEL_38:
    uint64_t v11 = 0;
    goto LABEL_19;
  }
  *(void *)a4 = 0;
  if (!a1)
  {
    uint64_t v16 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
LABEL_37:
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_38;
  }
  xpc_object_t v6 = xpc_dictionary_get_value(xdict, key);
  if (!v6)
  {
    uint64_t v16 = 0;
    goto LABEL_37;
  }
  CFTypeRef v7 = v6;
  uint64_t v18 = Mutable;
  int64_t count = xpc_array_get_count(v6);
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], count, MEMORY[0x1E4F1D510]);
  uint64_t v11 = CFArrayCreateMutable(v9, count, v10);
  if (count < 1)
  {
LABEL_17:
    uint64_t v16 = FigTaggedBufferGroupCreate(v9, Mutable, v11, &v19);
    if (!v16)
    {
      *uint64_t v18 = v19;
      CFTypeRef v19 = 0;
    }
  }
  else
  {
    size_t v12 = 0;
    while (1)
    {
      dictionardouble y = xpc_array_get_dictionary(v7, v12);
      if (!dictionary) {
        break;
      }
      uint64_t v14 = dictionary;
      uint64_t v15 = FigXPCMessageCopyCFData(dictionary, "EntryTagCollection", &cf);
      if (v15) {
        goto LABEL_33;
      }
      uint64_t v15 = FigTagCollectionCreateFromData(cf, v9, &value);
      if (v15) {
        goto LABEL_33;
      }
      uint64_t v15 = FigPixelBufferRecipientCopyPixelBufferFromXPCMessage(a1, v14, "EntryPixelBuffer", (__CVBuffer **)&v20);
      if (v15) {
        goto LABEL_33;
      }
      CFArrayAppendValue(Mutable, value);
      CFArrayAppendValue(v11, v20);
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
      if (value)
      {
        CFRelease(value);
        xpc_object_t value = 0;
      }
      if (v20)
      {
        CFRelease(v20);
        CFTypeRef v20 = 0;
      }
      if (count == ++v12) {
        goto LABEL_17;
      }
    }
    uint64_t v15 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
LABEL_33:
    uint64_t v16 = v15;
  }
LABEL_19:
  if (cf) {
    CFRelease(cf);
  }
  if (value) {
    CFRelease(value);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v19) {
    CFRelease(v19);
  }
  return v16;
}

uint64_t FigPixelBufferRecipientFlushPixelBufferBackings(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 32))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    FigCFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigPixelBufferRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(void *a1, void *a2, uint64_t **a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v17 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "PixelBufferOriginEndpoint");
  if (!value || (uint64_t v6 = (uint64_t)value, MEMORY[0x192FC6B30]() != MEMORY[0x1E4F145A0]))
  {
    uint64_t v9 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
    CFTypeRef v10 = 0;
    goto LABEL_16;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_DeathNoticeName", @"ServerConnectionDied");
  if (!FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"FigPixelBufferOriginRemote", v6, (uint64_t)&PixelBufferRecipientRemoteClientCreateWithXPCEndpoint_sPixelBufferRecipientRemoteClientCallbacks, (uint64_t)Mutable, (uint64_t)&v17))
  {
    uint64_t v9 = 0;
    if (!Mutable) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v9 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
  if (Mutable) {
LABEL_5:
  }
    CFRelease(Mutable);
LABEL_6:
  CFTypeRef v10 = v17;
  if (v9)
  {
LABEL_16:
    FigXPCRemoteClientDispose(v10);
    goto LABEL_17;
  }
  uint64_t v11 = FigXPCRemoteClientCopyMemoryRecipient((uint64_t)v17, &cf);
  CFTypeRef v10 = v17;
  if (v11)
  {
    uint64_t v9 = v11;
    goto LABEL_16;
  }
  xpc_object_t xdict = 0;
  xpc_object_t v19 = 0;
  uint64_t v12 = FigXPCCreateBasicMessage(0x63726538u, 0, &v19);
  if (v12
    || (uint64_t v12 = FigXPCRemoteClientSendSyncMessageCreatingReply((uint64_t)v10, (uint64_t)v19, &xdict), v12))
  {
    uint64_t v9 = v12;
  }
  else
  {
    if (pixelBufferRecipient_GetTypeID_sRegisterPixelBufferRecipientTypeOnce != -1) {
      dispatch_once(&pixelBufferRecipient_GetTypeID_sRegisterPixelBufferRecipientTypeOnce, &__block_literal_global_43);
    }
    uint64_t Instance = (uint64_t *)_CFRuntimeCreateInstance();
    if (!Instance)
    {
      uint64_t v9 = FigSignalErrorAt(4294951702, 0, 0, 0, 0, 0, 0);
      goto LABEL_14;
    }
    Instance[3] = (uint64_t)FigSimpleMutexCreate();
    Instance[4] = (uint64_t)CFDictionaryCreateMutable(v7, 0, 0, MEMORY[0x1E4F1D540]);
    uint64_t int64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
    Instance[2] = (uint64_t)uint64;
    Instance[5] = (uint64_t)v10;
    uint64_t v9 = FigXPCRemoteClientAssociateObject((uint64_t)v10, (uint64_t)Instance, uint64);
    if (!v9) {
      goto LABEL_14;
    }
    CFRelease(Instance);
  }
  uint64_t Instance = 0;
LABEL_14:
  FigXPCRelease(v19);
  FigXPCRelease(xdict);
  if (!v9)
  {
    CFTypeRef v17 = 0;
    xpc_dictionary_set_uint64(a2, ".objectID", Instance[2]);
    *a3 = Instance;
    CFTypeRef v10 = v17;
    goto LABEL_16;
  }
  FigXPCRemoteClientDispose(v17);
  if (Instance) {
    CFRelease(Instance);
  }
LABEL_17:
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t pixelBufferOrigin_backingNotificationListener(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4)
{
  CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F24978];
  uint64_t result = CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F24978]);
  if (result)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 16));
    CFNumberRef Value = (IOSurfaceRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 24), (const void *)-a4);
    if (Value)
    {
      uint64_t v9 = (uint64_t)Value;
      IOSurfaceID ID = IOSurfaceGetID(*Value);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      FigCFDictionarySetInt64(Mutable, @"IOSurfaceID", ID);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 24), (const void *)-a4);
      LocalCenter = CFNotificationCenterGetLocalCenter();
      CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a2, v6, (const void *)a4);
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification(DefaultLocalCenter, @"ForgetBacking", (const void *)a2, Mutable);
      if (Mutable) {
        CFRelease(Mutable);
      }
      pixelBufferOrigin_disposeOriginEntry((const void *)a2, v9);
    }
    uint64_t v14 = *(pthread_mutex_t **)(a2 + 16);
    return FigSimpleMutexUnlock(v14);
  }
  return result;
}

void pixelBufferOrigin_disposeBufferBackingEntry(CFTypeRef *a1)
{
  if (a1)
  {
    CFTypeRef v2 = a1[1];
    if (v2) {
      CFRelease(v2);
    }
    if (*a1) {
      CFRelease(*a1);
    }
    free(a1);
  }
}

void pixelBufferOrigin_disposeOriginEntry(const void *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a2 + 8));
    if (v4)
    {
      CFAllocatorRef v5 = v4;
      LocalCenter = CFNotificationCenterGetLocalCenter();
      CFNotificationCenterRemoveObserver(LocalCenter, a1, (CFNotificationName)*MEMORY[0x1E4F24978], v5);
      CFRelease(v5);
    }
    pixelBufferOrigin_disposeBufferBackingEntry((CFTypeRef *)a2);
  }
}

void pixelBufferSharing_copyPixelBufferAttachments(CVBufferRef buffer, int a2, const __CFDictionary **a3, CFDictionaryRef *a4)
{
  uint64_t v4 = a4;
  CFAllocatorRef v5 = a3;
  if (a2)
  {
    CFDictionaryRef v7 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldPropagate);
    CFDictionaryRef v8 = v7;
    if (v7)
    {
      uint64_t v9 = (const void *)*MEMORY[0x1E4F24A00];
      if (CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E4F24A00]))
      {
        CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v8);
        CFDictionaryRemoveValue(MutableCopy, v9);
        CFRelease(v8);
        CFDictionaryRef v8 = MutableCopy;
      }
    }
    CFDictionaryRef v11 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldNotPropagate);
    if (!v5) {
      goto LABEL_7;
    }
LABEL_6:
    *CFAllocatorRef v5 = v8;
    CFDictionaryRef v8 = 0;
    goto LABEL_7;
  }
  uint64_t v12 = 0;
  CFDictionaryRef v11 = 0;
  CFDictionaryRef v8 = 0;
  CVAttachmentMode attachmentMode = kCVAttachmentMode_ShouldNotPropagate;
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v14 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v15 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  while (1)
  {
    CFStringRef v16 = gCVPixelBufferAttachmentKeysToAlwaysSerialize[v12];
    CFTypeRef v17 = CVBufferCopyAttachment(buffer, v16, &attachmentMode);
    if (v17) {
      break;
    }
LABEL_26:
    if (++v12 == 4) {
      goto LABEL_27;
    }
  }
  uint64_t v18 = v17;
  if (attachmentMode == kCVAttachmentMode_ShouldPropagate)
  {
    if (v8)
    {
      CFMutableDictionaryRef Mutable = v8;
    }
    else
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v13, 0, v14, v15);
      if (!Mutable)
      {
        FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
        CFDictionaryRef v8 = v11;
        if (!v11) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
      CFDictionaryRef v8 = Mutable;
    }
    goto LABEL_25;
  }
  if (v11)
  {
    CFMutableDictionaryRef Mutable = v11;
LABEL_25:
    FigCFDictionarySetValue(Mutable, v16, v18);
    CFRelease(v18);
    goto LABEL_26;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v13, 0, v14, v15);
  if (Mutable)
  {
    CFDictionaryRef v11 = Mutable;
    goto LABEL_25;
  }
  FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
  if (!v8) {
    goto LABEL_33;
  }
LABEL_32:
  CFRelease(v8);
LABEL_33:
  CFRelease(v18);
  CFDictionaryRef v8 = 0;
  CFDictionaryRef v11 = 0;
LABEL_27:
  CFAllocatorRef v5 = a3;
  uint64_t v4 = a4;
  if (a3) {
    goto LABEL_6;
  }
LABEL_7:
  if (v4)
  {
    *uint64_t v4 = v11;
    CFDictionaryRef v11 = 0;
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v11) {
    CFRelease(v11);
  }
}

uint64_t __EnsurePixelBufferOriginServerStarted_block_invoke()
{
  uint64_t result = FigXPCServerStartWithNewXPCEndpoint((uint64_t)"PixelBufferOriginServer", PixelBufferOriginServerStart_callbacks, 0, &gPixelBufferOriginServer);
  EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartError = result;
  return result;
}

uint64_t pixelBufferOriginServer_handleRemoteMessageWithReply(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v18 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v18);
  if (OpCode) {
    return OpCode;
  }
  if (v18 != 1768779891)
  {
    if (v18 == 1668441400)
    {
      uint64_t value = 0;
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (pixelBufferOrigin_GetTypeID_sRegisterPixelBufferOriginTypeOnce != -1) {
        dispatch_once(&pixelBufferOrigin_GetTypeID_sRegisterPixelBufferOriginTypeOnce, &__block_literal_global_34_0);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v9 = Instance;
        CFTypeRef v10 = FigSimpleMutexCreate();
        *(void *)(v9 + 16) = v10;
        if (v10)
        {
          *(void *)(v9 + 24) = CFDictionaryCreateMutable(v7, 0, 0, 0);
          goto LABEL_9;
        }
        uint64_t v12 = FigSignalErrorAt(4294951705, 0, 0, 0, 0, 0, 0);
        CFRelease((CFTypeRef)v9);
      }
      else
      {
        uint64_t v12 = FigSignalErrorAt(4294951705, 0, 0, 0, 0, 0, 0);
      }
      if (v12) {
        return v12;
      }
      uint64_t v9 = 0;
LABEL_9:
      uint64_t v11 = FigXPCServerAssociateObjectWithConnection(a1, (const void *)v9, 0, 0, 0, &value);
      if (v11)
      {
        uint64_t v12 = v11;
      }
      else
      {
        uint64_t v12 = FigXPCServerCopyMemoryOrigin(a1, (CFTypeRef *)(v9 + 40));
        if (!v12)
        {
          xpc_dictionary_set_uint64(a3, ".objectID", value);
          *(void *)(v9 + 32) = value;
LABEL_12:
          CFRelease((CFTypeRef)v9);
          return v12;
        }
      }
      if (!v9) {
        return v12;
      }
      goto LABEL_12;
    }
    return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
  }
  IOSurfaceID int64 = xpc_dictionary_get_int64(a2, "IOSurfaceID");
  uint64_t v14 = IOSurfaceLookup(int64);
  if (v14)
  {
    uint64_t v15 = v14;
    xpc_object_t XPCObject = IOSurfaceCreateXPCObject(v14);
    if (XPCObject)
    {
      xpc_dictionary_set_value(a3, "IOSurface", XPCObject);
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v12 = FigSignalErrorAt(4294951704, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v15);
  }
  else
  {
    uint64_t v12 = FigSignalErrorAt(4294951706, 0, 0, 0, 0, 0, 0);
    xpc_object_t XPCObject = 0;
  }
  FigXPCRelease(XPCObject);
  return v12;
}

uint64_t pixelBufferOriginServer_handleRemoteMessageNoReply(uint64_t a1, void *a2)
{
  int v3 = 0;
  uint64_t result = FigXPCMessageGetOpCode(a2, &v3);
  if (!result) {
    return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

double pixelBufferOrigin_Init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void pixelBufferOrigin_Finalize(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 24), (CFDictionaryApplierFunction)pixelBufferOrigin_disposeEachOriginEntry, (void *)a1);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    CFTypeRef v2 = *(const void **)(a1 + 24);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(a1 + 24) = 0;
    }
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 16));
  int v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFRelease(v3);
  }
}

__CFString *pixelBufferOrigin_CopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, @"FigPixelBufferOrigin %p ObjectID %016llx", a1, *(void *)(a1 + 32));
  return Mutable;
}

void pixelBufferOrigin_disposeEachOriginEntry(uint64_t a1, uint64_t a2, const void *a3)
{
}

uint64_t pixelBufferRecipient_NotificationFilter(uint64_t a1, CFTypeRef cf1, uint64_t a3, uint64_t a4)
{
  if (CFEqual(cf1, @"ForgetBacking"))
  {
    CFDictionaryRef v8 = 0;
    if (FigCFDictionaryGetInt64IfPresent(a4, @"IOSurfaceID", &v8))
    {
      CFStringRef v6 = v8;
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v6)) {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v6);
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    }
  }
  return 1;
}

double pixelBufferRecipient_Init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void pixelBufferRecipient_Finalize(uint64_t a1)
{
  CFTypeRef v2 = *(pthread_mutex_t **)(a1 + 24);
  if (v2)
  {
    FigSimpleMutexLock(v2);
    int v3 = *(const void **)(a1 + 32);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 32) = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    FigSimpleMutexDestroy(*(void *)(a1 + 24));
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 40);

  FigXPCRemoteClientDispose(v4);
}

__CFString *pixelBufferRecipient_CopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 32));
  CFStringAppendFormat(Mutable, 0, @"FigPixelBufferRecipient %p ObjectID %016llx %ld memory blocks", a1, *(void *)(a1 + 16), Count);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return Mutable;
}

uint64_t FigGeometryMarginsMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, void *a9@<X8>)
{
  *a9 = result;
  a9[1] = a2;
  a9[2] = a3;
  a9[3] = a4;
  a9[4] = a5;
  a9[5] = a6;
  a9[6] = a7;
  a9[7] = a8;
  return result;
}

BOOL FigGeometryMarginsEqualToMargins(uint64_t *a1, uint64_t *a2)
{
  BOOL result = FigGeometryDimensionEqualToDimension(*a1, a1[1], *a2, a2[1]);
  if (result)
  {
    BOOL result = FigGeometryDimensionEqualToDimension(a1[2], a1[3], a2[2], a2[3]);
    if (result)
    {
      BOOL result = FigGeometryDimensionEqualToDimension(a1[4], a1[5], a2[4], a2[5]);
      if (result) {
        return FigGeometryDimensionEqualToDimension(a1[6], a1[7], a2[6], a2[7]);
      }
    }
  }
  return result;
}

unint64_t FigGeometryAspectRatioMake(unsigned int a1, uint64_t a2)
{
  if (a2) {
    BOOL v2 = a1 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return 0;
  }
  else {
    return a1 | (unint64_t)(a2 << 32);
  }
}

BOOL FigGeometryAspectRatioIsValid(uint64_t a1)
{
  return (int)a1 > 0 && SHIDWORD(a1) > 0;
}

uint64_t FigGeometryAspectRatioEqualToAspectRatio(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL v4 = (int)a1 < 1 || SHIDWORD(a1) < 1;
  BOOL v5 = (int)a2 < 1 || SHIDWORD(a2) < 1;
  char v6 = v5;
  BOOL v7 = v5 && v4;
  if (v6) {
    BOOL v8 = v7;
  }
  else {
    BOOL v8 = (int)a1 * (uint64_t)SHIDWORD(a2) == (int)a2 * (uint64_t)SHIDWORD(a1);
  }
  if (v4) {
    return v7;
  }
  else {
    return v8;
  }
}

uint64_t FigGeometryDimensionHash(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1;
  uint64_t v6 = a2;
  if ((a2 & 0x100000000) != 0)
  {
    if ((a2 & 0x1C00000000) != 0)
    {
      if ((a2 & 0x400000000) != 0) {
        unint64_t v2 = 11141290;
      }
      else {
        unint64_t v2 = 13369548;
      }
    }
    else
    {
      unint64_t v2 = _CMTagCFHashBytes((uint64_t)&v5, 8);
    }
  }
  else
  {
    unint64_t v2 = 0x1000000;
  }
  unint64_t v3 = (_CMTagCFHashBytes((uint64_t)&v6 + 4, 4) + (v2 << 6) + (v2 >> 2) + 2654435769u) ^ v2;
  return (_CMTagCFHashBytes((uint64_t)&v6, 4) + (v3 << 6) + (v3 >> 2) + 2654435769u) ^ v3;
}

uint64_t FigGeometryPointHash(uint64_t *a1)
{
  unint64_t v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  return ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
}

uint64_t FigGeometrySizeHash(uint64_t *a1)
{
  unint64_t v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  return ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
}

uint64_t FigGeometryVectorHash(uint64_t *a1)
{
  unint64_t v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  return ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
}

uint64_t FigGeometryRectHash(long long *a1)
{
  long long v2 = a1[1];
  long long v6 = *a1;
  long long v7 = v2;
  unint64_t v3 = FigGeometryPointHash((uint64_t *)&v6) + 2654435769;
  long long v4 = a1[3];
  long long v6 = a1[2];
  long long v7 = v4;
  return ((v3 << 6) + (v3 >> 2) + FigGeometrySizeHash((uint64_t *)&v6) + 2654435769) ^ v3;
}

uint64_t FigGeometryMarginsHash(uint64_t *a1)
{
  unint64_t v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  unint64_t v3 = ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
  unint64_t v4 = (FigGeometryDimensionHash(a1[4], a1[5]) + (v3 << 6) + (v3 >> 2) + 2654435769u) ^ v3;
  return (FigGeometryDimensionHash(a1[6], a1[7]) + (v4 << 6) + (v4 >> 2) + 2654435769u) ^ v4;
}

unint64_t FigGeometryAspectRatioHash(uint64_t a1)
{
  return ((a1 >> 32) + ((uint64_t)(int)a1 << 6) + ((unint64_t)(int)a1 >> 2) + 2654435769u) ^ (int)a1;
}

uint64_t FigGeometryCoordinateSpaceGetTypeID()
{
  if (sRegisterFigGeometryCoordinateSpaceTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigGeometryCoordinateSpaceTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryCoordinateSpaceType);
  }
  return sFigGeometryCoordinateSpaceID;
}

uint64_t RegisterFigGeometryCoordinateSpaceType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigGeometryCoordinateSpaceIOSurfaceID ID = result;
  return result;
}

uint64_t FigGeometryCoordinateSpaceCreate(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5, int a6, uint64_t *a7)
{
  if ((*(_DWORD *)(a2 + 12) & 0x1D) == 1
    && (long long v7 = (long long *)a2, (*(_DWORD *)(a2 + 28) & 0x1D) == 1)
    && (*(_DWORD *)(a2 + 44) & 0x1D) == 1
    && (*(_DWORD *)(a2 + 60) & 0x1D) == 1
    && *(double *)(a2 + 32) != 0.0
    && *(double *)(a2 + 48) != 0.0
    && a7)
  {
    if (sRegisterFigGeometryCoordinateSpaceTypeOnce != -1) {
      dispatch_once_f(&sRegisterFigGeometryCoordinateSpaceTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryCoordinateSpaceType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v14 = (const void *)Instance;
      long long v15 = *v7;
      long long v16 = v7[1];
      long long v17 = v7[2];
      *(_OWORD *)(Instance + 72) = v7[3];
      *(_OWORD *)(Instance + 56) = v17;
      *(_OWORD *)(Instance + 40) = v16;
      *(_OWORD *)(Instance + 24) = v15;
      int v18 = *(_DWORD *)(Instance + 16);
      int v19 = v18 | 1;
      *(_DWORD *)(Instance + 16) = v18 | 1;
      if (a3)
      {
        if ((*((_DWORD *)a3 + 3) & 0x1D) != 1
          || (*((_DWORD *)a3 + 11) & 0x1D) != 1
          || (*((_DWORD *)a3 + 7) & 0x1D) != 1
          || (*((_DWORD *)a3 + 15) & 0x1D) != 1)
        {
          goto LABEL_51;
        }
        long long v20 = *a3;
        long long v21 = a3[1];
        long long v22 = a3[2];
        *(_OWORD *)(Instance + 136) = a3[3];
        *(_OWORD *)(Instance + 120) = v22;
        *(_OWORD *)(Instance + 104) = v21;
        *(_OWORD *)(Instance + 88) = v20;
        int v19 = v18 | 3;
        *(_DWORD *)(Instance + 16) = v18 | 3;
        if (a4) {
          goto LABEL_17;
        }
      }
      else
      {
        *(_OWORD *)(Instance + 88) = kFigGeometryMarginsZero;
        *(_OWORD *)(Instance + 104) = unk_18FE96BD8;
        *(_OWORD *)(Instance + 120) = xmmword_18FE96BE8;
        *(_OWORD *)(Instance + 136) = unk_18FE96BF8;
        if (a4)
        {
LABEL_17:
          if ((*(_DWORD *)(a4 + 12) & 0x1D) != 1
            || (*(_DWORD *)(a4 + 28) & 0x1D) != 1
            || (*(_DWORD *)(a4 + 44) & 0x1D) != 1
            || (*(_DWORD *)(a4 + 60) & 0x1D) != 1
            || *(double *)(a4 + 32) == 0.0
            || *(double *)(a4 + 48) == 0.0)
          {
            goto LABEL_51;
          }
          int v23 = 4;
          long long v7 = (long long *)a4;
LABEL_26:
          long long v24 = *v7;
          long long v25 = v7[1];
          long long v26 = v7[2];
          *(_OWORD *)(Instance + 264) = v7[3];
          *(_OWORD *)(Instance + 248) = v26;
          *(_OWORD *)(Instance + 232) = v25;
          *(_OWORD *)(Instance + 216) = v24;
          int v27 = v19 | v23;
          *(_DWORD *)(Instance + 16) = v27;
          if (!a5)
          {
            *(void *)(Instance + 280) = 0;
LABEL_31:
            *(_DWORD *)(Instance + 288) = a6;
            if (a6 <= 1918989157)
            {
              if (a6 > 1651665254)
              {
                if (a6 == 1651665255 || a6 == 1667591796) {
                  goto LABEL_49;
                }
                int v28 = 1818584692;
              }
              else
              {
                if (!a6)
                {
LABEL_50:
                  *a7 = Instance;
                  return 0;
                }
                if (a6 == 1651271014) {
                  goto LABEL_49;
                }
                int v28 = 1651471476;
              }
            }
            else if (a6 <= 1920166265)
            {
              if (a6 == 1918989158 || a6 == 1918989168) {
                goto LABEL_49;
              }
              int v28 = 1919510376;
            }
            else
            {
              if (a6 <= 1953460255)
              {
                if (a6 != 1920166266)
                {
                  int v28 = 1953260902;
                  goto LABEL_48;
                }
LABEL_49:
                *(_DWORD *)(Instance + 16) = v27 | 0x10;
                goto LABEL_50;
              }
              if (a6 == 1953655143) {
                goto LABEL_49;
              }
              int v28 = 1953460256;
            }
LABEL_48:
            if (a6 == v28) {
              goto LABEL_49;
            }
            goto LABEL_51;
          }
          if (*(_DWORD *)a5 && *(_DWORD *)(a5 + 4))
          {
            *(void *)(Instance + 280) = *(void *)a5;
            v27 |= 8u;
            *(_DWORD *)(Instance + 16) = v27;
            goto LABEL_31;
          }
LABEL_51:
          uint64_t v30 = FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
          CFRelease(v14);
          return v30;
        }
      }
      int v23 = 256;
      goto LABEL_26;
    }
    uint64_t v31 = 4294949965;
  }
  else
  {
    uint64_t v31 = 4294949966;
  }

  return FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
}

CFDictionaryRef FigGeometryCoordinateSpaceCopyAsDictionary(uint64_t a1, const __CFAllocator *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  int valuePtr = *(_DWORD *)(a1 + 16);
  keys[0] = @"flags";
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  keys[1] = @"bounds";
  long long v5 = *(_OWORD *)(a1 + 40);
  long long v18 = *(_OWORD *)(a1 + 24);
  long long v19 = v5;
  long long v6 = *(_OWORD *)(a1 + 72);
  long long v20 = *(_OWORD *)(a1 + 56);
  long long v21 = v6;
  values[1] = FigGeometryRectCopyAsDictionary(&v18, a2);
  char v7 = valuePtr;
  if ((valuePtr & 4) != 0)
  {
    *(void *)&long long v29 = @"contentBounds";
    long long v9 = *(_OWORD *)(a1 + 232);
    long long v18 = *(_OWORD *)(a1 + 216);
    long long v19 = v9;
    long long v10 = *(_OWORD *)(a1 + 264);
    long long v20 = *(_OWORD *)(a1 + 248);
    long long v21 = v10;
    *(void *)&long long v24 = FigGeometryRectCopyAsDictionary(&v18, a2);
    CFIndex v8 = 3;
    char v7 = valuePtr;
    if ((valuePtr & 2) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  CFIndex v8 = 2;
  if ((valuePtr & 2) != 0)
  {
LABEL_5:
    keys[v8] = @"innerMargins";
    long long v11 = *(_OWORD *)(a1 + 104);
    long long v18 = *(_OWORD *)(a1 + 88);
    long long v19 = v11;
    long long v12 = *(_OWORD *)(a1 + 136);
    long long v20 = *(_OWORD *)(a1 + 120);
    long long v21 = v12;
    values[v8++] = FigGeometryMarginsCopyAsDictionary((uint64_t *)&v18, a2);
    char v7 = valuePtr;
  }
LABEL_6:
  if ((v7 & 8) != 0)
  {
    keys[v8] = @"contentAspectRatio";
    values[v8++] = FigGeometryAspectRatioCopyAsDictionary(*(void *)(a1 + 280), a2);
    if ((valuePtr & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if ((v7 & 0x10) != 0)
  {
LABEL_8:
    keys[v8] = @"contentGravity";
    LODWORD(v18) = *(_DWORD *)(a1 + 288);
    values[v8++] = CFNumberCreate(v4, kCFNumberSInt32Type, &v18);
  }
LABEL_9:
  CFDictionaryRef v13 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, v8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  unint64_t v14 = 0;
  uint64_t v15 = 8 * v8;
  do
  {
    long long v16 = values[v14 / 8];
    if (v16) {
      CFRelease(v16);
    }
    v14 += 8;
  }
  while (v15 != v14);
  return v13;
}

CFDictionaryRef FigGeometryMarginsCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  CFDictionaryRef v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  CFDictionaryRef v6 = FigGeometryDimensionCopyAsDictionary(a1[4], a1[5], a2);
  CFDictionaryRef v7 = FigGeometryDimensionCopyAsDictionary(a1[6], a1[7], a2);
  CFDictionaryRef v8 = v7;
  *(_OWORD *)keys = xmmword_1E567D298;
  long long v17 = *(_OWORD *)&off_1E567D2A8;
  v15[0] = v4;
  v15[1] = v5;
  v15[2] = v6;
  v15[3] = v7;
  if (v4 && v6 && v5 && v7)
  {
    CFTypeID v9 = CFGetTypeID(v4);
    if (v9 == CFDictionaryGetTypeID()
      && (CFTypeID v10 = CFGetTypeID(v5), v10 == CFDictionaryGetTypeID())
      && (CFTypeID v11 = CFGetTypeID(v6), v11 == CFDictionaryGetTypeID())
      && (CFTypeID v12 = CFGetTypeID(v8), v12 == CFDictionaryGetTypeID()))
    {
      CFDictionaryRef v13 = CFDictionaryCreate(a2, (const void **)keys, v15, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    else
    {
      CFDictionaryRef v13 = 0;
    }
    goto LABEL_10;
  }
  FigSignalErrorAt(4294949965, 0, 0, 0, 0, 0, 0);
  CFDictionaryRef v13 = 0;
  if (v4) {
LABEL_10:
  }
    CFRelease(v4);
  if (v6) {
    CFRelease(v6);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v13;
}

CFDictionaryRef FigGeometryAspectRatioCopyAsDictionary(uint64_t a1, const __CFAllocator *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a1;
  *(_OWORD *)keys = xmmword_1E567D2B8;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFDictionaryRef v4 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v5 = 0;
  char v6 = 1;
  do
  {
    char v7 = v6;
    CFDictionaryRef v8 = values[v5];
    if (v8) {
      CFRelease(v8);
    }
    char v6 = 0;
    uint64_t v5 = 1;
  }
  while ((v7 & 1) != 0);
  return v4;
}

CFNumberRef FigGeometryCoordinateGravityTypeCopyAsCFType(int a1)
{
  int valuePtr = a1;
  return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
}

CFDictionaryRef FigGeometryCoordinateSpaceMakeFromDictionary(const __CFDictionary *result, uint64_t a2)
{
  uint64_t value = 0;
  CFDictionaryRef v27 = 0;
  long long v24 = 0;
  long long v25 = 0;
  long long v22 = 0;
  int v23 = 0;
  int v21 = 0;
  if (result)
  {
    CFDictionaryRef v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 != CFDictionaryGetTypeID()
      || !FigCFDictionaryGetInt32IfPresent((uint64_t)v3, @"flags", &v21)
      || !CFDictionaryGetValueIfPresent(v3, @"bounds", (const void **)&value))
    {
      return 0;
    }
    long long v17 = kFigGeometryRectZero;
    long long v18 = unk_18FE95658;
    long long v19 = xmmword_18FE95668;
    long long v20 = unk_18FE95678;
    memset(v16, 0, sizeof(v16));
    uint64_t v15 = 0;
    memset(v14, 0, sizeof(v14));
    if ((v21 & 1) != 0 && CFDictionaryGetValueIfPresent(v3, @"bounds", (const void **)&value)) {
      FigGeometryRectMakeFromDictionary(value, &v17);
    }
    if ((v21 & 4) != 0 && CFDictionaryGetValueIfPresent(v3, @"contentBounds", (const void **)&v25))
    {
      FigGeometryRectMakeFromDictionary(v25, v14);
      int v5 = 0;
    }
    else
    {
      int v5 = 1;
    }
    if ((v21 & 2) != 0 && CFDictionaryGetValueIfPresent(v3, @"innerMargins", (const void **)&v24))
    {
      FigGeometryMarginsMakeFromDictionary((CFTypeID)v24, (uint64_t)v16);
      int v6 = 0;
    }
    else
    {
      int v6 = 1;
    }
    if ((v21 & 8) != 0 && CFDictionaryGetValueIfPresent(v3, @"contentAspectRatio", (const void **)&v23))
    {
      int v7 = 0;
      uint64_t v15 = FigGeometryAspectRatioMakeFromDictionary(v23);
    }
    else
    {
      int v7 = 1;
    }
    if ((v21 & 0x10) != 0 && CFDictionaryGetValueIfPresent(v3, @"contentGravity", (const void **)&v22)) {
      int v8 = FigGeometryCoordinateGravityTypeMakeFromCFType((const __CFNumber *)v22);
    }
    else {
      int v8 = 0;
    }
    if (v6) {
      CFTypeID v9 = 0;
    }
    else {
      CFTypeID v9 = v16;
    }
    if (v5) {
      CFTypeID v10 = 0;
    }
    else {
      CFTypeID v10 = v14;
    }
    if (v7) {
      CFTypeID v11 = 0;
    }
    else {
      CFTypeID v11 = &v15;
    }
    v13[0] = v17;
    v13[1] = v18;
    _DWORD v13[2] = v19;
    v13[3] = v20;
    uint64_t v12 = FigGeometryCoordinateSpaceCreate(a2, (uint64_t)v13, v9, (uint64_t)v10, (uint64_t)v11, v8, (uint64_t *)&v27);
    if (!v12) {
      return v27;
    }
    FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    uint64_t result = v27;
    if (v27)
    {
      CFRelease(v27);
      return 0;
    }
  }
  return result;
}

CFTypeID FigGeometryMarginsMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 44) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_DWORD *)(a2 + 12) = 1;
  *(_DWORD *)(a2 + 28) = 1;
  *(_DWORD *)(a2 + 44) = 1;
  *(_DWORD *)(a2 + 60) = 1;
  CFTypeRef v21 = 0;
  uint64_t value = 0;
  CFTypeRef v19 = 0;
  CFTypeRef cf = 0;
  if (result)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      uint64_t result = CFDictionaryGetValueIfPresent(v3, @"left", (const void **)&value);
      if (result)
      {
        uint64_t result = CFDictionaryGetValueIfPresent(v3, @"right", &cf);
        if (result)
        {
          uint64_t result = CFDictionaryGetValueIfPresent(v3, @"top", &v21);
          if (result)
          {
            uint64_t result = CFDictionaryGetValueIfPresent(v3, @"bottom", &v19);
            if (result)
            {
              uint64_t result = (CFTypeID)value;
              if (value)
              {
                CFTypeID v5 = CFGetTypeID(value);
                uint64_t result = CFDictionaryGetTypeID();
                if (v5 == result)
                {
                  uint64_t result = (CFTypeID)cf;
                  if (cf)
                  {
                    CFTypeID v6 = CFGetTypeID(cf);
                    uint64_t result = CFDictionaryGetTypeID();
                    if (v6 == result)
                    {
                      uint64_t result = (CFTypeID)v21;
                      if (v21)
                      {
                        CFTypeID v7 = CFGetTypeID(v21);
                        uint64_t result = CFDictionaryGetTypeID();
                        if (v7 == result)
                        {
                          uint64_t result = (CFTypeID)v19;
                          if (v19)
                          {
                            CFTypeID v8 = CFGetTypeID(v19);
                            uint64_t result = CFDictionaryGetTypeID();
                            if (v8 == result)
                            {
                              CFTypeID v9 = FigGeometryDimensionMakeFromDictionary(value);
                              uint64_t v11 = v10;
                              uint64_t v12 = FigGeometryDimensionMakeFromDictionary(cf);
                              uint64_t v14 = v13;
                              uint64_t v15 = FigGeometryDimensionMakeFromDictionary(v21);
                              uint64_t v17 = v16;
                              uint64_t result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(v19);
                              *(void *)a2 = v9;
                              *(void *)(a2 + 8) = v11;
                              *(void *)(a2 + 16) = v12;
                              *(void *)(a2 + 24) = v14;
                              *(void *)(a2 + 32) = v15;
                              *(void *)(a2 + 40) = v17;
                              *(void *)(a2 + 48) = result;
                              *(void *)(a2 + 56) = v18;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

const void *FigGeometryAspectRatioMakeFromDictionary(const void *result)
{
  unsigned int v4 = 1;
  unsigned int v5 = 1;
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFDictionaryGetTypeID()
      && FigCFDictionaryGetInt32IfPresent(v1, @"horizontal", &v5)
      && FigCFDictionaryGetInt32IfPresent(v1, @"vertical", &v4))
    {
      if (v4) {
        BOOL v3 = v5 == 0;
      }
      else {
        BOOL v3 = 1;
      }
      if (v3) {
        return 0;
      }
      else {
        return (const void *)(v5 | ((unint64_t)v4 << 32));
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFNumberRef FigGeometryCoordinateGravityTypeMakeFromCFType(const __CFNumber *result)
{
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      unsigned int valuePtr = 0;
      CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFMutableStringRef FigGeometryMarginsCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0);
  unsigned int v5 = FigGeometryDimensionCopyDescription(a1, *(void *)a2, *(void *)(a2 + 8));
  CFTypeID v6 = FigGeometryDimensionCopyDescription(a1, *(void *)(a2 + 32), *(void *)(a2 + 40));
  CFTypeID v7 = FigGeometryDimensionCopyDescription(a1, *(void *)(a2 + 16), *(void *)(a2 + 24));
  CFTypeID v8 = FigGeometryDimensionCopyDescription(a1, *(void *)(a2 + 48), *(void *)(a2 + 56));
  CFTypeID v9 = v8;
  if (Mutable)
  {
LABEL_7:
    if (!v5) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (!v5 || !v6 || !v7 || !v8)
  {
    CFStringAppendFormat(0, 0, @"{leftMargin:%@,topMargin:%@,rightMargin:%@,bottomMargin:%@}", v5, v6, v7, v8);
    goto LABEL_7;
  }
LABEL_8:
  CFRelease(v5);
LABEL_9:
  if (v6) {
    CFRelease(v6);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  return Mutable;
}

CFMutableStringRef FigGeometryAspectRatioCopyDescription(const __CFAllocator *a1, unint64_t a2)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0);
  if (!Mutable) {
    CFStringAppendFormat(0, 0, @"%d:%d", a2, HIDWORD(a2));
  }
  return Mutable;
}

CFStringRef FigGeometryCoordinateGravityTypeCopyDescription(const __CFAllocator *a1, int a2)
{
  if (a2 <= 1918989157)
  {
    if (a2 > 1651665254)
    {
      switch(a2)
      {
        case 1651665255:
          CFStringRef v2 = @"bottomRight";
          return CFStringCreateCopy(a1, v2);
        case 1667591796:
          CFStringRef v2 = @"center";
          return CFStringCreateCopy(a1, v2);
        case 1818584692:
          CFStringRef v2 = @"left";
          return CFStringCreateCopy(a1, v2);
      }
    }
    else
    {
      switch(a2)
      {
        case 0:
          CFStringRef v2 = @"<unspecified>";
          return CFStringCreateCopy(a1, v2);
        case 1651271014:
          CFStringRef v2 = @"bottomLeft";
          return CFStringCreateCopy(a1, v2);
        case 1651471476:
          CFStringRef v2 = @"bottom";
          return CFStringCreateCopy(a1, v2);
      }
    }
  }
  else if (a2 <= 1920166265)
  {
    switch(a2)
    {
      case 1918989158:
        CFStringRef v2 = @"resizeAspectFill";
        return CFStringCreateCopy(a1, v2);
      case 1918989168:
        CFStringRef v2 = @"resizeAspect";
        return CFStringCreateCopy(a1, v2);
      case 1919510376:
        CFStringRef v2 = @"right";
        return CFStringCreateCopy(a1, v2);
    }
  }
  else if (a2 > 1953460255)
  {
    if (a2 == 1953460256)
    {
      CFStringRef v2 = @"top";
      return CFStringCreateCopy(a1, v2);
    }
    if (a2 == 1953655143)
    {
      CFStringRef v2 = @"topRight";
      return CFStringCreateCopy(a1, v2);
    }
  }
  else
  {
    if (a2 == 1920166266)
    {
      CFStringRef v2 = @"resize";
      return CFStringCreateCopy(a1, v2);
    }
    if (a2 == 1953260902)
    {
      CFStringRef v2 = @"topLeft";
      return CFStringCreateCopy(a1, v2);
    }
  }
  return 0;
}

double fgInit_CoordinateSpace(uint64_t a1)
{
  *(void *)(a1 + 288) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t fgEqual_CoordinateSpace(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v34 = v2;
  uint64_t v35 = v3;
  uint64_t result = 0;
  if (a1 && a2)
  {
    int v7 = *(_DWORD *)(a1 + 16);
    int v8 = *(_DWORD *)(a2 + 16);
    if (v7 != v8 || (*(_DWORD *)(a1 + 16) & 0x10) == 0)
    {
      if (v7 != v8) {
        return 0;
      }
    }
    else if (*(_DWORD *)(a1 + 288) != *(_DWORD *)(a2 + 288))
    {
      return 0;
    }
    if (v7)
    {
      long long v10 = *(_OWORD *)(a1 + 40);
      long long v30 = *(_OWORD *)(a1 + 24);
      long long v31 = v10;
      long long v11 = *(_OWORD *)(a1 + 72);
      long long v32 = *(_OWORD *)(a1 + 56);
      long long v33 = v11;
      long long v12 = *(_OWORD *)(a2 + 40);
      long long v26 = *(_OWORD *)(a2 + 24);
      long long v27 = v12;
      long long v13 = *(_OWORD *)(a2 + 72);
      long long v28 = *(_OWORD *)(a2 + 56);
      long long v29 = v13;
      uint64_t result = FigGeometryRectEqualToRect((uint64_t)&v30, (uint64_t)&v26);
      if (!result) {
        return result;
      }
      int v7 = *(_DWORD *)(a1 + 16);
    }
    if ((v7 & 4) != 0)
    {
      long long v14 = *(_OWORD *)(a1 + 232);
      long long v30 = *(_OWORD *)(a1 + 216);
      long long v31 = v14;
      long long v15 = *(_OWORD *)(a1 + 264);
      long long v32 = *(_OWORD *)(a1 + 248);
      long long v33 = v15;
      long long v16 = *(_OWORD *)(a2 + 232);
      long long v26 = *(_OWORD *)(a2 + 216);
      long long v27 = v16;
      long long v17 = *(_OWORD *)(a2 + 264);
      long long v28 = *(_OWORD *)(a2 + 248);
      long long v29 = v17;
      uint64_t result = FigGeometryRectEqualToRect((uint64_t)&v30, (uint64_t)&v26);
      if (!result) {
        return result;
      }
      int v7 = *(_DWORD *)(a1 + 16);
    }
    if ((v7 & 8) == 0
      || (uint64_t result = FigGeometryAspectRatioEqualToAspectRatio(*(void *)(a1 + 280), *(void *)(a2 + 280)), result))
    {
      if ((v7 & 2) != 0)
      {
        long long v18 = *(_OWORD *)(a1 + 104);
        long long v30 = *(_OWORD *)(a1 + 88);
        long long v31 = v18;
        long long v19 = *(_OWORD *)(a1 + 136);
        long long v32 = *(_OWORD *)(a1 + 120);
        long long v33 = v19;
        long long v20 = *(_OWORD *)(a2 + 104);
        long long v26 = *(_OWORD *)(a2 + 88);
        long long v27 = v20;
        long long v21 = *(_OWORD *)(a2 + 136);
        long long v28 = *(_OWORD *)(a2 + 120);
        long long v29 = v21;
        uint64_t result = FigGeometryMarginsEqualToMargins((uint64_t *)&v30, (uint64_t *)&v26);
        if (!result) {
          return result;
        }
        int v7 = *(_DWORD *)(a1 + 16);
      }
      if ((v7 & 0x20) != 0)
      {
        long long v22 = *(_OWORD *)(a1 + 168);
        long long v30 = *(_OWORD *)(a1 + 152);
        long long v31 = v22;
        long long v23 = *(_OWORD *)(a1 + 200);
        long long v32 = *(_OWORD *)(a1 + 184);
        long long v33 = v23;
        long long v24 = *(_OWORD *)(a2 + 168);
        long long v26 = *(_OWORD *)(a2 + 152);
        long long v27 = v24;
        long long v25 = *(_OWORD *)(a2 + 200);
        long long v28 = *(_OWORD *)(a2 + 184);
        long long v29 = v25;
        return FigGeometryRectEqualToRect((uint64_t)&v30, (uint64_t)&v26);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t fgHash_CoordinateSpace(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFigGeometryCoordinateSpaceTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigGeometryCoordinateSpaceTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryCoordinateSpaceType);
  }
  if (v2 != sFigGeometryCoordinateSpaceID) {
    return 0;
  }
  unint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = v3;
  if (v3)
  {
    long long v5 = *(_OWORD *)(a1 + 40);
    long long v15 = *(_OWORD *)(a1 + 24);
    long long v16 = v5;
    long long v6 = *(_OWORD *)(a1 + 72);
    long long v17 = *(_OWORD *)(a1 + 56);
    long long v18 = v6;
    unint64_t v4 = ((v3 << 6) + 2654435769u + (v3 >> 2) + FigGeometryRectHash(&v15)) ^ v3;
    if ((v3 & 2) == 0)
    {
LABEL_7:
      if ((v3 & 0x20) == 0) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
  }
  else if ((v3 & 2) == 0)
  {
    goto LABEL_7;
  }
  long long v7 = *(_OWORD *)(a1 + 104);
  long long v15 = *(_OWORD *)(a1 + 88);
  long long v16 = v7;
  long long v8 = *(_OWORD *)(a1 + 136);
  long long v17 = *(_OWORD *)(a1 + 120);
  long long v18 = v8;
  v4 ^= (v4 << 6) + 2654435769u + (v4 >> 2) + FigGeometryMarginsHash((uint64_t *)&v15);
  if ((v3 & 0x20) == 0)
  {
LABEL_8:
    if ((v3 & 4) == 0) {
      goto LABEL_9;
    }
    goto LABEL_14;
  }
LABEL_13:
  long long v9 = *(_OWORD *)(a1 + 168);
  long long v15 = *(_OWORD *)(a1 + 152);
  long long v16 = v9;
  long long v10 = *(_OWORD *)(a1 + 200);
  long long v17 = *(_OWORD *)(a1 + 184);
  long long v18 = v10;
  v4 ^= (v4 << 6) + 2654435769u + (v4 >> 2) + FigGeometryRectHash(&v15);
  if ((v3 & 4) == 0)
  {
LABEL_9:
    if ((v3 & 8) == 0) {
      return v4;
    }
    goto LABEL_15;
  }
LABEL_14:
  long long v11 = *(_OWORD *)(a1 + 232);
  long long v15 = *(_OWORD *)(a1 + 216);
  long long v16 = v11;
  long long v12 = *(_OWORD *)(a1 + 264);
  long long v17 = *(_OWORD *)(a1 + 248);
  long long v18 = v12;
  v4 ^= (v4 << 6) + 2654435769u + (v4 >> 2) + FigGeometryRectHash(&v15);
  if ((v3 & 8) != 0)
  {
LABEL_15:
    unint64_t v13 = ((v4 << 6)
         + 2654435769u
         + (v4 >> 2)
         + (((*(uint64_t *)(a1 + 280) >> 32)
           + 2654435769
           + ((uint64_t)(int)*(void *)(a1 + 280) << 6)
           + ((unint64_t)(int)*(void *)(a1 + 280) >> 2)) ^ (int)*(void *)(a1 + 280))) ^ v4;
    return (*(unsigned int *)(a1 + 288) + 2654435769 + (v13 << 6) + (v13 >> 2)) ^ v13;
  }
  return v4;
}

__CFString *fgCopyDesc_CoordinateSpace(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0);
  unint64_t v4 = Mutable;
  if (a1)
  {
    CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
    long long v6 = *(_OWORD *)(a1 + 40);
    v10[0] = *(_OWORD *)(a1 + 24);
    v10[1] = v6;
    long long v7 = *(_OWORD *)(a1 + 72);
    v10[2] = *(_OWORD *)(a1 + 56);
    v10[3] = v7;
    long long v8 = FigGeometryRectCopyDescription(v5, v10);
    CFStringAppendFormat(v4, 0, @"<FigGeometryCoordinateSpaceRef %p> bounds:%@", a1, v8);
    if (v8) {
      CFRelease(v8);
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"<FigGeometryCoordinateSpaceRef %p>", 0);
  }
  return v4;
}

uint64_t FigRPCCreateRemoteClient(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (!a1)
  {
    uint64_t v11 = FigSignalErrorAt(4294955066, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  long long v8 = malloc_type_calloc(1uLL, 0x38uLL, 0x10F00409625AC60uLL);
  long long v9 = v8;
  if (!v8)
  {
    uint64_t v11 = FigSignalErrorAt(4294955065, 0, 0, 0, 0, 0, 0);
    goto LABEL_5;
  }
  v8[4] = a3;
  *long long v8 = a1;
  v8[1] = a2;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  v9[6] = Mutable;
  if (!Mutable)
  {
    uint64_t v11 = FigSignalErrorAt(4294955065, 0, 0, 0, 0, 0, 0);
    if (!v11) {
      goto LABEL_5;
    }
    unint64_t v13 = (const void *)v9[6];
    if (v13) {
      CFRelease(v13);
    }
    long long v14 = v9[5];
    if (v14) {
      dispatch_release(v14);
    }
    mach_port_name_t v15 = *((_DWORD *)v9 + 6);
    if (v15) {
      FigMachPortReleaseSendRight_(v15, 0, 0, 0, 0);
    }
    FigSimpleMutexDestroy(v9[2]);
    free(v9);
LABEL_16:
    long long v9 = 0;
    goto LABEL_5;
  }
  v9[5] = dispatch_queue_create("FigRPCServerConnectionQueue", 0);
  uint64_t v11 = 0;
  _OWORD v9[2] = FigSimpleMutexCreate();
LABEL_5:
  *a4 = v9;
  return v11;
}

uint64_t FigRPCCreateServerConnectionForObject(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return figrpc_createServerConnectionForObjectCommon(a1, a2, a3, 0, 0, 0, a4);
}

uint64_t figrpc_createServerConnectionForObjectCommon(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, void *a7)
{
  long long v9 = 0;
  mach_msg_type_number_t port_info_outCnt = 1;
  integer_t port_info_out = 0;
  mach_port_name_t name = 0;
  uint64_t v51 = 0;
  uint64_t v52 = &v51;
  uint64_t v53 = 0x2000000000;
  uint64_t v54 = 0;
  uint64_t v10 = 4294955066;
  if (!a1 || !a2 || !a3 || !a7 || a4 && ((long long v9 = 0, !a5) || a6 < 1))
  {
LABEL_31:
    uint64_t v26 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    mach_port_name_t v18 = 0;
    uint64_t v30 = 0;
    if (v26) {
      goto LABEL_32;
    }
    goto LABEL_44;
  }
  long long v16 = (unsigned int *)malloc_type_calloc(1uLL, 0x50uLL, 0x10E00405D5CAF00uLL);
  long long v9 = v16;
  if (!v16)
  {
    uint64_t v10 = 4294955065;
    goto LABEL_31;
  }
  *((void *)v16 + 7) = a2;
  long long v17 = (ipc_space_read_t *)MEMORY[0x1E4F14960];
  if (mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name)
    || mach_port_get_attributes(*v17, name, 1, &port_info_out, &port_info_outCnt)
    || (port_info_out += 10, MEMORY[0x192FC5B00](*v17, name, 1, &port_info_out, port_info_outCnt))
    || mach_port_insert_right(*v17, name, name, 0x14u))
  {
    uint64_t v10 = 4294955062;
    goto LABEL_31;
  }
  mach_port_name_t v18 = name;
  long long v19 = dispatch_queue_create("RemoteClientNotifyQueue", 0);
  *((void *)v9 + 4) = v19;
  if (a4)
  {
    uint64_t v41 = MEMORY[0x1E4F143A8];
    uint64_t v42 = 0x40000000;
    uint64_t v43 = __figrpc_createServerConnectionForObjectCommon_block_invoke;
    uint64_t v44 = &unk_1E567D2F8;
    CMBlockBufferRef v46 = v9;
    uint64_t v47 = a5;
    int v48 = a6;
    mach_port_name_t v49 = name;
    mach_port_name_t v50 = v18;
    uint64_t v45 = &v51;
    uint64_t v20 = dispatch_mach_create();
    v52[3] = v20;
    *((void *)v9 + 3) = v20;
    v9[3] = name;
    dispatch_mach_connect();
    long long v21 = 0;
  }
  else
  {
    long long v21 = dispatch_source_create(MEMORY[0x1E4F14458], name, 0, v19);
    mach_port_name_t v22 = name;
    v9[3] = name;
    *((void *)v9 + 2) = v21;
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_2;
    handler[3] = &__block_descriptor_tmp_7_8;
    mach_port_name_t v39 = v22;
    mach_port_name_t v40 = v18;
    handler[4] = v21;
    dispatch_source_set_cancel_handler(v21, handler);
    v37[0] = MEMORY[0x1E4F143A8];
    v37[1] = 0x40000000;
    v37[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_3;
    v37[3] = &__block_descriptor_tmp_8_1;
    v37[4] = a1;
    v37[5] = v21;
    dispatch_source_set_event_handler(v21, v37);
    dispatch_resume(v21);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  long long v24 = (mach_port_name_t *)(a1 + 24);
  uint64_t v23 = *(unsigned int *)(a1 + 24);
  if (!v23) {
    goto LABEL_21;
  }
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned int *, unsigned int *, unsigned int *))(a3 + 16))(a3, v23, name, v9 + 2, v9 + 12, v9 + 16);
  if (v25 == -308 || (uint64_t v26 = v25, v25 == 268435459) || v25 == -303)
  {
    FigMachPortReleaseSendRight_(*v24, 0, 0, 0, 0);
    *long long v24 = 0;
LABEL_21:
    uint64_t v27 = bootstrap_look_up(*MEMORY[0x1E4F14638], *(const char **)a1, (mach_port_t *)(a1 + 24));
    if (v27)
    {
      uint64_t v26 = v27;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      goto LABEL_23;
    }
    FigRemote_LookUpServerTimeoutPort();
    uint64_t v26 = (*(uint64_t (**)(uint64_t, void, void, unsigned int *, unsigned int *, unsigned int *))(a3 + 16))(a3, *v24, name, v9 + 2, v9 + 12, v9 + 16);
    goto LABEL_27;
  }
  if (!*v24) {
    goto LABEL_21;
  }
LABEL_27:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (v26)
  {
LABEL_23:
    if (v21)
    {
      dispatch_source_cancel(v21);
LABEL_39:
      mach_port_name_t v31 = v9[2];
      if (v31) {
        FigMachPortReleaseSendRight_(v31, 0, 0, 0, 0);
      }
      long long v32 = *((void *)v9 + 4);
      if (v32) {
        dispatch_release(v32);
      }
LABEL_43:
      free(v9);
      long long v9 = 0;
      uint64_t v30 = v26;
      goto LABEL_44;
    }
LABEL_32:
    if (v52[3])
    {
      dispatch_mach_cancel();
    }
    else
    {
      if (name) {
        FigMachPortReleaseReceiveRight_(name, 0, 0, 0, 0);
      }
      if (v18) {
        FigMachPortReleaseSendRight_(v18, 0, 0, 0, 0);
      }
    }
    if (!v9) {
      goto LABEL_43;
    }
    goto LABEL_39;
  }
  long long v28 = dispatch_source_create(MEMORY[0x1E4F14460], v9[2], 1uLL, *(dispatch_queue_t *)(a1 + 40));
  *((void *)v9 + 5) = v28;
  long long v29 = *(NSObject **)(a1 + 40);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_4;
  block[3] = &__block_descriptor_tmp_9_3;
  block[4] = a1;
  void block[5] = v9;
  dispatch_sync(v29, block);
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 0x40000000;
  v35[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_5;
  v35[3] = &__block_descriptor_tmp_10_4;
  v35[4] = v28;
  dispatch_source_set_cancel_handler(v28, v35);
  v34[0] = MEMORY[0x1E4F143A8];
  v34[1] = 0x40000000;
  v34[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_6;
  v34[3] = &__block_descriptor_tmp_12_1;
  v34[4] = a1;
  v34[5] = v9;
  v34[6] = v28;
  dispatch_source_set_event_handler(v28, v34);
  dispatch_resume(v28);
  uint64_t v30 = 0;
LABEL_44:
  *a7 = v9;
  _Block_object_dispose(&v51, 8);
  return v30;
}

uint64_t FigRPCCreateServerConnectionForObjectUsingMachChannel(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, void *a6)
{
  return figrpc_createServerConnectionForObjectCommon(a1, a2, a5, 1, a3, a4, a6);
}

uint64_t FigRPCGetServerConnectionInfo(uint64_t a1, _DWORD *a2, void *a3, void *a4)
{
  if (!a1)
  {
    uint64_t v5 = 4294955066;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v5 = 4294955061;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 8);
  }
  if (a3) {
    *a3 = *(void *)(a1 + 48);
  }
  if (a4) {
    *a4 = *(void *)(a1 + 64);
  }
  return 0;
}

uint64_t FigRPCDisposeServerConnection(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      unint64_t v4 = *(NSObject **)(a1 + 40);
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 0x40000000;
      v7[2] = __FigRPCDisposeServerConnection_block_invoke;
      v7[3] = &__block_descriptor_tmp_51;
      v7[4] = a1;
      v7[5] = a2;
      dispatch_sync(v4, v7);
      uint64_t v5 = *(NSObject **)(a2 + 16);
      if (v5) {
        dispatch_source_cancel(v5);
      }
      if (*(void *)(a2 + 24)) {
        dispatch_mach_cancel();
      }
      dispatch_release(*(dispatch_object_t *)(a2 + 32));
      free((void *)a2);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294955066, 0, 0, 0, 0, 0, 0);
  }
}

void __FigRPCDisposeServerConnection_block_invoke(uint64_t a1)
{
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 32) + 48), (const void *)*(unsigned int *)(*(void *)(a1 + 40) + 8));
  uint64_t v2 = *(NSObject **)(*(void *)(a1 + 40) + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    *(void *)(*(void *)(a1 + 40) + 40) = 0;
  }
}

void FigRPCKillServerOnTimeout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2) {
    a2 = *(void *)(a2 + 64);
  }
  FigRemote_InterpretMachErrorForTimeout(a3, a2, a4, a5);
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke(uint64_t a1, uint64_t a2, dispatch_object_t object)
{
  if (a2 == 8)
  {
    long long v6 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    if (!v6) {
      return;
    }
    goto LABEL_8;
  }
  if (a2 != 7)
  {
    if (a2 != 2) {
      return;
    }
    dispatch_retain(object);
    if ((dispatch_mach_mig_demux() & 1) == 0)
    {
      msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
      mach_msg_destroy(msg);
    }
    long long v6 = object;
LABEL_8:
    dispatch_release(v6);
    return;
  }
  FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 60), 0, 0, 0, 0);
  mach_port_name_t v7 = *(_DWORD *)(a1 + 64);

  FigMachPortReleaseSendRight_(v7, 0, 0, 0, 0);
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_2(uint64_t a1)
{
  FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 44), 0, 0, 0, 0);
  uint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

uint64_t __figrpc_createServerConnectionForObjectCommon_block_invoke_3(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(void *)(v1 + 32)) {
    return MEMORY[0x1F40CBB78](*(void *)(result + 40), *(void *)(v1 + 8));
  }
  return result;
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_4(uint64_t a1)
{
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_5(uint64_t a1)
{
  mach_port_name_t handle = dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  FigMachPortReleaseSendRight_(handle, 0, 0, 0, 0);
  unint64_t v3 = *(NSObject **)(a1 + 32);

  dispatch_release(v3);
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_6(uint64_t a1)
{
  uint64_t value = 0;
  if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 48), (const void *)*(unsigned int *)(*(void *)(a1 + 40) + 8), (const void **)&value))
  {
    uint64_t v2 = value;
    *((unsigned char *)value + 72) = 1;
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_7;
    block[3] = &__block_descriptor_tmp_11_2;
    uint64_t v4 = *(void *)(a1 + 48);
    block[4] = v2;
    void block[5] = v4;
    dispatch_async(global_queue, block);
    *((void *)value + 5) = 0;
  }
  else
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
  }
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_7(uint64_t a1)
{
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, @"rpcNotice_ServerConnectionDied", *(const void **)(a1 + 32), 0);
  unint64_t v3 = *(NSObject **)(a1 + 40);

  dispatch_source_cancel(v3);
}

uint64_t CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionData(CFAllocatorRef alloc, unsigned int *a2, unint64_t a3, int a4, CMFormatDescriptionRef *formatDescriptionOut)
{
  if (!a2)
  {
    uint64_t v27 = 4294954584;
    goto LABEL_45;
  }
  if (a3 <= 0xF || (uint64_t v5 = formatDescriptionOut) == 0)
  {
    uint64_t v27 = 4294954584;
LABEL_45:
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  signed int v6 = bswap32(*a2);
  if (v6 < 0x10 || v6 > a3)
  {
    uint64_t v27 = 4294954582;
    goto LABEL_45;
  }
  unsigned int v9 = a2[1];
  unint64_t v10 = v6 - 16;
  CFMutableDictionaryRef theDict = 0;
  if (v10 < 8)
  {
    CFDictionaryRef v21 = 0;
    goto LABEL_34;
  }
  unsigned int v28 = v9;
  CFMutableDictionaryRef Mutable = 0;
  long long v12 = a2 + 4;
  unint64_t v13 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  long long v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  do
  {
    unsigned int v16 = *v12;
    unsigned int v15 = v12[1];
    *(_DWORD *)bytes = v15;
    signed int v17 = bswap32(v16);
    uint64_t v18 = v17;
    if (v17 < 8 || v10 < v17)
    {
      CFStringRef v24 = 0;
      CFDataRef v25 = 0;
      uint64_t v26 = 4294954582;
      goto LABEL_40;
    }
    if (v15 != 1701147238)
    {
      CFStringRef v24 = CFStringCreateWithBytes(alloc, bytes, 4, 0, 0);
      if (!v24)
      {
        CFDataRef v25 = 0;
LABEL_39:
        uint64_t v26 = 4294954583;
LABEL_40:
        uint64_t v5 = formatDescriptionOut;
        unsigned int v9 = v28;
        goto LABEL_41;
      }
      CFDataRef v25 = CFDataCreate(alloc, (const UInt8 *)v12 + 8, v18 - 8);
      if (!v25) {
        goto LABEL_39;
      }
      CFMutableDictionaryRef Mutable = theDict;
      if (!theDict)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, v13, v14);
        CFMutableDictionaryRef theDict = Mutable;
        if (!Mutable) {
          goto LABEL_39;
        }
      }
      CFDictionarySetValue(Mutable, v24, v25);
      CFRelease(v25);
      CFRelease(v24);
    }
    long long v12 = (unsigned int *)((char *)v12 + v18);
    v10 -= v18;
  }
  while (v10 > 7);
  if (!Mutable)
  {
    CFDictionaryRef v21 = 0;
    uint64_t v22 = 0;
    CFStringRef v24 = 0;
    CFDataRef v25 = 0;
    uint64_t v5 = formatDescriptionOut;
    unsigned int v9 = v28;
    goto LABEL_27;
  }
  CFDictionaryRef v20 = CFDictionaryCreate(alloc, (const void **)&kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, (const void **)&theDict, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v24 = 0;
  unsigned int v9 = v28;
  if (v20)
  {
    CFDictionaryRef v21 = v20;
    uint64_t v22 = 0;
    CFDataRef v25 = 0;
    uint64_t v5 = formatDescriptionOut;
    goto LABEL_27;
  }
  uint64_t v26 = 4294954583;
  CFDataRef v25 = 0;
  uint64_t v5 = formatDescriptionOut;
LABEL_41:
  uint64_t v22 = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
  CFDictionaryRef v21 = 0;
LABEL_27:
  if (theDict) {
    CFRelease(theDict);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (!v22) {
LABEL_34:
  }
    uint64_t v22 = CMFormatDescriptionCreate(alloc, 0x68617074u, bswap32(v9), v21, v5);
  if (v21) {
    CFRelease(v21);
  }
  return v22;
}

uint64_t CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, uint64_t a3, CMFormatDescriptionRef *a4)
{
  *(void *)long long v12 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  if (theBuffer && a4)
  {
    uint64_t v5 = theBuffer;
    size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (!CMBlockBufferIsRangeContiguous(v5, 0, 0))
    {
      uint64_t DataPointer = CMBlockBufferCreateContiguous(a1, v5, a1, 0, 0, 0, 0, &blockBufferOut);
      if (DataPointer) {
        goto LABEL_8;
      }
      uint64_t v5 = blockBufferOut;
    }
    uint64_t DataPointer = CMBlockBufferGetDataPointer(v5, 0, 0, 0, (char **)v12);
    if (!DataPointer) {
      uint64_t DataPointer = CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionData(a1, *(unsigned int **)v12, DataLength, v9, a4);
    }
  }
  else
  {
    uint64_t DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
LABEL_8:
  uint64_t v10 = DataPointer;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v10;
}

uint64_t CMHapticFormatDescriptionCopyAsBigEndianHapticDescriptionBlockBuffer(const __CFAllocator *a1, CFTypeRef cf, uint64_t a3, CMBlockBufferRef *a4)
{
  unint64_t sourceBytes = 0;
  unint64_t v19 = 0;
  CMBlockBufferRef destinationBuffer = 0;
  if (cf)
  {
    if (a4)
    {
      CFTypeID v7 = CFGetTypeID(cf);
      if (v7 == CMFormatDescriptionGetTypeID()
        && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)cf) == 1751216244)
      {
        CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions((CMFormatDescriptionRef)cf);
        if (!Extensions)
        {
          CFNumberRef Value = 0;
          size_t v12 = 0;
          goto LABEL_13;
        }
        CMBlockBufferRef blockBufferOut = 0;
        CFNumberRef Value = (OpaqueCMBlockBuffer *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
        if (!Value)
        {
LABEL_10:
          size_t DataLength = CMBlockBufferGetDataLength(Value);
          if (DataLength >= 0x7FFFFFF0)
          {
            uint64_t DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_32:
            uint64_t v14 = DataPointer;
LABEL_33:
            if (destinationBuffer) {
              CFRelease(destinationBuffer);
            }
            goto LABEL_19;
          }
          size_t v12 = DataLength;
LABEL_13:
          unint64_t sourceBytes = _byteswap_uint64(__PAIR64__((int)v12 + 16, CMFormatDescriptionGetMediaSubType((CMFormatDescriptionRef)cf)));
          unint64_t v19 = 0xFFFF000000000000;
          uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a1, 0, (v12 + 16), a1, 0, 0, (v12 + 16), 1u, &destinationBuffer);
          if (!DataPointer)
          {
            uint64_t DataPointer = CMBlockBufferReplaceDataBytes(&sourceBytes, destinationBuffer, 0, 0x10uLL);
            if (!DataPointer)
            {
              if (!Value
                || (*(void *)&context[0] = 0,
                    uint64_t DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, 0x10uLL, 0, 0, (char **)context),
                    !DataPointer)
                && (uint64_t DataPointer = CMBlockBufferCopyDataBytes(Value, 0, v12, *(void **)&context[0]),
                    !DataPointer))
              {
                uint64_t v14 = 0;
                *a4 = destinationBuffer;
                CMBlockBufferRef destinationBuffer = 0;
LABEL_19:
                if (Value) {
                  CFRelease(Value);
                }
                return v14;
              }
            }
          }
          goto LABEL_32;
        }
        uint64_t v21 = 0;
        memset(context, 0, sizeof(context));
        uint64_t v10 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
        if (!v10)
        {
          uint64_t v10 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)context);
          if (!v10)
          {
            CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)hapticBridgeAppendExtensionsFunc, context);
            CFNumberRef Value = blockBufferOut;
            goto LABEL_10;
          }
        }
        uint64_t v14 = v10;
        if (blockBufferOut) {
          CFRelease(blockBufferOut);
        }
LABEL_28:
        CFNumberRef Value = 0;
        goto LABEL_33;
      }
      uint64_t v16 = 4294954581;
    }
    else
    {
      uint64_t v16 = 4294954584;
    }
    uint64_t v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t hapticBridgeAppendExtensionsFunc(const __CFString *a1, const __CFData *a2, uint64_t a3)
{
  unsigned int v11 = 0;
  if (a1
    && (CFTypeID v6 = CFGetTypeID(a1), v6 == CFStringGetTypeID())
    && a2
    && (CFTypeID v7 = CFGetTypeID(a2), v7 == CFDataGetTypeID())
    && FigCFStringGetOSTypeValue(a1, (int *)&v11))
  {
    if (!FigAtomWriterBeginAtom(a3, v11, 0))
    {
      BytePtr = CFDataGetBytePtr(a2);
      CFIndex Length = CFDataGetLength(a2);
      FigAtomWriterAppendData(a3, (uint64_t)BytePtr, Length);
    }
  }
  else
  {
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  return FigAtomWriterEndAtom(a3);
}

uint64_t FigRPCFetchNextPendingNotificationPackagedForMIG(uint64_t a1, _DWORD *a2, void *a3, char *a4, vm_address_t *a5, unsigned int *a6)
{
  uint64_t v28 = 0;
  long long v29 = &v28;
  uint64_t v30 = 0x2000000000;
  uint64_t v31 = 0;
  uint64_t v24 = 0;
  CFDataRef v25 = &v24;
  uint64_t v26 = 0x2000000000;
  int v27 = 0;
  if (a1 && a2 && a3 && a4 && a5 && a6)
  {
    size_t v12 = *(NSObject **)(a1 + 104);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigRPCFetchNextPendingNotificationPackagedForMIG_block_invoke;
    block[3] = &unk_1E567D3E0;
    block[4] = &v28;
    void block[5] = &v24;
    void block[6] = a1;
    dispatch_sync(v12, block);
    uint64_t v13 = v29[3];
    if (v13)
    {
      *a3 = *(void *)(a1 + 32);
      CFStringGetCString(*(CFStringRef *)(v13 + 8), a4, 512, 0);
      *a5 = 0;
      *a6 = 0;
      uint64_t v14 = (void *)v29[3];
      uint64_t v15 = v14[2];
      if (v15)
      {
        CFDataRef theData = 0;
        if (FigRemote_CreateBinaryPListData(v15, *MEMORY[0x1E4F1CF80], &theData))
        {
          uint64_t v16 = 0;
        }
        else
        {
          signed int v17 = *(const void **)(v29[3] + 16);
          if (v17)
          {
            CFRelease(v17);
            *(void *)(v29[3] + 16) = 0;
          }
          unsigned int Length = CFDataGetLength(theData);
          *a6 = Length;
          uint64_t v16 = vm_allocate(*MEMORY[0x1E4F14960], a5, Length, 1560281089);
          if (!v16)
          {
            unint64_t v19 = (void *)*a5;
            BytePtr = CFDataGetBytePtr(theData);
            memcpy(v19, BytePtr, *a6);
          }
          CFRelease(theData);
        }
        uint64_t v14 = (void *)v29[3];
      }
      else
      {
        uint64_t v16 = 0;
      }
      *a2 = *((_DWORD *)v25 + 6);
      figrpc_freeQueuedNotification(v14);
    }
    else
    {
      uint64_t v16 = 4294955056;
    }
  }
  else
  {
    uint64_t v16 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  }
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);
  return v16;
}

void *__FigRPCFetchNextPendingNotificationPackagedForMIG_block_invoke(void *result)
{
  uint64_t v1 = result[6];
  unint64_t v3 = (uint64_t *)(v1 + 80);
  uint64_t v2 = *(uint64_t **)(v1 + 80);
  if (v2)
  {
    uint64_t v4 = *(void *)(result[5] + 8);
    uint64_t v5 = *v2;
    *unint64_t v3 = *v2;
    if (!v5)
    {
      *(void *)(v1 + 88) = v3;
      *(unsigned char *)(v1 + 96) = 0;
    }
    *(_DWORD *)(v4 + 24) = v5 != 0;
  }
  *(void *)(*(void *)(result[4] + 8) + 24) = v2;
  return result;
}

void figrpc_freeQueuedNotification(void *a1)
{
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  unint64_t v3 = (const void *)a1[2];
  if (v3) {
    CFRelease(v3);
  }

  free(a1);
}

uint64_t FigRPCFetchNextPendingNotification(uint64_t a1, _DWORD *a2, void *a3, void *a4, void *a5)
{
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  int v20 = 0;
  if (a1 && a2 && a3 && a4 && a5)
  {
    uint64_t v10 = *(NSObject **)(a1 + 104);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigRPCFetchNextPendingNotification_block_invoke;
    block[3] = &unk_1E567D408;
    block[4] = &v21;
    void block[5] = &v17;
    void block[6] = a1;
    dispatch_sync(v10, block);
    unsigned int v11 = v22;
    uint64_t v12 = v22[3];
    if (v12)
    {
      *a3 = *(void *)(a1 + 32);
      *a4 = *(void *)(v12 + 8);
      *(void *)(v11[3] + 8) = 0;
      uint64_t v13 = v22;
      *a5 = *(void *)(v22[3] + 16);
      *(void *)(v13[3] + 16) = 0;
      *a2 = *((_DWORD *)v18 + 6);
      figrpc_freeQueuedNotification((void *)v13[3]);
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v14 = 4294955056;
    }
  }
  else
  {
    uint64_t v14 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  }
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v14;
}

void *__FigRPCFetchNextPendingNotification_block_invoke(void *result)
{
  uint64_t v1 = result[6];
  unint64_t v3 = (uint64_t *)(v1 + 80);
  uint64_t v2 = *(uint64_t **)(v1 + 80);
  if (v2)
  {
    uint64_t v4 = *(void *)(result[5] + 8);
    uint64_t v5 = *v2;
    *unint64_t v3 = *v2;
    if (!v5)
    {
      *(void *)(v1 + 88) = v3;
      *(unsigned char *)(v1 + 96) = 0;
    }
    *(_DWORD *)(v4 + 24) = v5 != 0;
  }
  *(void *)(*(void *)(result[4] + 8) + 24) = v2;
  return result;
}

uint64_t FigRPCStartServerUsingMachChannel(const char *a1, uint64_t a2, int a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, long long *a7, mach_port_name_t **a8)
{
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigRPCServerTrace[1], @"RPCServerTrace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigRPCServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1E9272F98, @"RPCServerTrace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1E9272F90);
  if (a1 && a2 && a6 && a8)
  {
    uint64_t v13 = (mach_port_name_t *)malloc_type_calloc(1uLL, 0x80uLL, 0x10F00407292CEEDuLL);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = v13 + 2;
      if (bootstrap_check_in(*MEMORY[0x1E4F14638], a1, v13 + 2))
      {
        uint64_t v16 = 4294955054;
      }
      else
      {
        *(void *)uint64_t v14 = a1;
        *((void *)v14 + 7) = a2;
        *((void *)v14 + 9) = a6;
        *((void *)v14 + 8) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
        *((void *)v14 + 5) = a4;
        v14[12] = a5;
        *((unsigned char *)v14 + 88) = a3;
        if (a7)
        {
          long long v18 = *a7;
          *((void *)v14 + 15) = *((void *)a7 + 2);
          *(_OWORD *)(v14 + 26) = v18;
        }
        initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
        int v20 = dispatch_queue_create(a1, initially_inactive);
        *((void *)v14 + 2) = v20;
        dispatch_set_qos_class_floor(v20, QOS_CLASS_DEFAULT, 0);
        dispatch_activate(*((dispatch_object_t *)v14 + 2));
        if (*((void *)v14 + 2))
        {
          if (a3)
          {
            if (figrpc_getCommonServerTimeoutQueue_once != -1) {
              dispatch_once(&figrpc_getCommonServerTimeoutQueue_once, &__block_literal_global_21);
            }
            *((void *)v14 + 12) = figrpc_createRPCTimeoutDetector(figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue, (uint64_t)a1, (uint64_t)v14);
          }
          *((void *)v14 + 4) = dispatch_mach_create();
          *a8 = v14;
          dispatch_mach_connect();
          return 0;
        }
        uint64_t v16 = 4294955053;
      }
      uint64_t v17 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      if (*((void *)v14 + 4))
      {
        dispatch_mach_cancel();
      }
      else
      {
        FigMachPortReleaseReceiveRight_(*v15, 0, 0, 0, 0);
        FigMachPortReleaseSendRight_(*v15, 0, 0, 0, 0);
      }
      uint64_t v21 = *((void *)v14 + 2);
      if (v21) {
        dispatch_release(v21);
      }
      free(v14);
      return v17;
    }
    uint64_t v23 = 4294955055;
  }
  else
  {
    uint64_t v23 = 4294955056;
  }

  return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
}

uint64_t figrpc_createRPCTimeoutDetector(NSObject *a1, uint64_t a2, uint64_t a3)
{
  if (figRPCTimeoutDetector_GetTypeID_sRegisterFigRPCTimeoutDetectorTypeOnce != -1) {
    dispatch_once(&figRPCTimeoutDetector_GetTypeID_sRegisterFigRPCTimeoutDetectorTypeOnce, &__block_literal_global_42);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(void *)(Instance + 16) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, a1);
    CFTypeRef v7 = FigCFWeakReferenceHolderCreateWithReferencedObject(Instance);
    *(void *)(Instance + 560) = a3;
    long long v8 = *(NSObject **)(Instance + 16);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __figrpc_createRPCTimeoutDetector_block_invoke;
    handler[3] = &__block_descriptor_tmp_14_3;
    handler[4] = v7;
    void handler[5] = Instance;
    handler[6] = a3;
    handler[7] = a2;
    dispatch_source_set_event_handler(v8, handler);
    int v9 = *(NSObject **)(Instance + 16);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    v11[2] = __figrpc_createRPCTimeoutDetector_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_15_2;
    v11[4] = v7;
    dispatch_source_set_cancel_handler(v9, v11);
    dispatch_resume(*(dispatch_object_t *)(Instance + 16));
  }
  else
  {
    FigSignalErrorAt(4294955055, 0, 0, 0, 0, 0, 0);
  }
  return Instance;
}

void __FigRPCStartServerUsingMachChannel_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2 == 7)
  {
    FigMachPortReleaseReceiveRight_(*(_DWORD *)(*(void *)(a1 + 32) + 8), 0, 0, 0, 0);
    mach_port_name_t v6 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
    FigMachPortReleaseSendRight_(v6, 0, 0, 0, 0);
  }
  else if (a2 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (*(void *)(v3 + 96)) {
      figRPCTimeoutDetector_setTimer(*(void *)(v3 + 96), *(const char **)v3, 0);
    }
    char v4 = dispatch_mach_mig_demux();
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 96);
    if (v5) {
      figRPCTimeoutDetector_unsetTimer(v5);
    }
    if ((v4 & 1) == 0)
    {
      msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
      mach_msg_destroy(msg);
    }
  }
}

void figRPCTimeoutDetector_setTimer(uint64_t a1, const char *a2, int a3)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t TimeoutNanoseconds = FigRPCServer_GetTimeoutNanoseconds();
    *(_DWORD *)(a1 + 540) = a3;
    *(unsigned char *)(a1 + 544) = 0;
    if (TimeoutNanoseconds)
    {
      unint64_t v7 = FigRPCServer_PickRPCTimeoutForCurrentThread(TimeoutNanoseconds, 90000000000);
      uint64_t msg = dispatch_mach_msg_get_msg();
      snprintf((char *)(a1 + 25), 0x200uLL, "(%s:msgh_id: %d) (timeout: %lld sec)", a2, *(_DWORD *)(msg + 20), v7 / 0x3B9ACA00);
      int v9 = *(NSObject **)(a1 + 16);
      dispatch_time_t v10 = dispatch_time(0, v7);
      dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
      *(unsigned char *)(a1 + 24) = 1;
    }
  }
}

void figRPCTimeoutDetector_unsetTimer(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    *(unsigned char *)(a1 + 24) = 0;
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 16), 0xFFFFFFFFFFFFFFFFLL, 0, 0x1DCD6500uLL);
    if (figrpc_getCommonServerTimeoutQueue_once != -1) {
      dispatch_once(&figrpc_getCommonServerTimeoutQueue_once, &__block_literal_global_21);
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __figRPCTimeoutDetector_unsetTimer_block_invoke;
    block[3] = &__block_descriptor_tmp_24_3;
    block[4] = a1;
    dispatch_sync((dispatch_queue_t)figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue, block);
  }
}

uint64_t FigRPCStartServer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, mach_port_name_t **a5)
{
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigRPCServerTrace[1], @"RPCServerTrace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigRPCServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1E9272F98, @"RPCServerTrace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1E9272F90);
  if (a1 && a2 && a3 && a4 && a5)
  {
    dispatch_time_t v10 = (mach_port_name_t *)malloc_type_calloc(1uLL, 0x80uLL, 0x10F00407292CEEDuLL);
    if (v10)
    {
      unsigned int v11 = v10;
      uint64_t v12 = v10 + 2;
      if (bootstrap_check_in(*MEMORY[0x1E4F14638], a1, v10 + 2))
      {
        uint64_t v13 = 4294955054;
      }
      else
      {
        *(void *)unsigned int v11 = a1;
        *((void *)v11 + 7) = a2;
        *((void *)v11 + 9) = a4;
        *((void *)v11 + 10) = a3;
        *((void *)v11 + 8) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
        uint64_t v16 = dispatch_queue_create(a1, 0);
        *((void *)v11 + 2) = v16;
        if (v16)
        {
          uint64_t v17 = dispatch_source_create(MEMORY[0x1E4F14458], v11[2], 0, v16);
          *((void *)v11 + 3) = v17;
          if (v17)
          {
            handler[0] = MEMORY[0x1E4F143A8];
            handler[1] = 0x40000000;
            handler[2] = __FigRPCStartServer_block_invoke;
            handler[3] = &__block_descriptor_tmp_10_5;
            handler[4] = v11;
            dispatch_source_set_cancel_handler(v17, handler);
            long long v18 = *((void *)v11 + 3);
            v22[0] = MEMORY[0x1E4F143A8];
            v22[1] = 0x40000000;
            v22[2] = __FigRPCStartServer_block_invoke_2;
            v22[3] = &__block_descriptor_tmp_11_3;
            v22[4] = v11;
            v22[5] = a2;
            v22[6] = a3;
            dispatch_source_set_event_handler(v18, v22);
            *a5 = v11;
            dispatch_resume(*((dispatch_object_t *)v11 + 3));
            return 0;
          }
        }
        uint64_t v13 = 4294955053;
      }
      uint64_t v14 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
      uint64_t v15 = *((void *)v11 + 3);
      if (v15) {
        dispatch_source_cancel(v15);
      }
      else {
        FigMachPortReleaseReceiveRight_(*v12, 0, 0, 0, 0);
      }
      uint64_t v19 = *((void *)v11 + 2);
      if (v19) {
        dispatch_release(v19);
      }
      if (*v12)
      {
        FigMachPortReleaseReceiveRight_(*v12, 0, 0, 0, 0);
        FigMachPortReleaseSendRight_(*v12, 0, 0, 0, 0);
      }
      free(v11);
      return v14;
    }
    uint64_t v21 = 4294955055;
  }
  else
  {
    uint64_t v21 = 4294955056;
  }

  return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
}

void __FigRPCStartServer_block_invoke(uint64_t a1)
{
  FigMachPortReleaseReceiveRight_(*(_DWORD *)(*(void *)(a1 + 32) + 8), 0, 0, 0, 0);
  FigMachPortReleaseSendRight_(*(_DWORD *)(*(void *)(a1 + 32) + 8), 0, 0, 0, 0);
  uint64_t v2 = *(NSObject **)(*(void *)(a1 + 32) + 24);

  dispatch_release(v2);
}

uint64_t __FigRPCStartServer_block_invoke_2(uint64_t a1)
{
  return MEMORY[0x1F40CBB78](*(void *)(*(void *)(a1 + 32) + 24), *(void *)(a1 + 40));
}

uint64_t FigRPCCreateClientConnection(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, void *a7)
{
  return figrpc_createClientCommon(a1, a2, a3, a4, a5, a6, 0, a7);
}

uint64_t figrpc_createClientCommon(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, int a7, void *a8)
{
  mach_port_name_t name = 0;
  CFStringRef v48 = 0;
  if (a1 && a3 && a4 && a5 + 1 > 1 && a8)
  {
    int v14 = a2;
    FigServer_CopyProcessName(a2, &v48);
    uint64_t v16 = malloc_type_calloc(1uLL, 0x78uLL, 0x10A0040BCFFF8B3uLL);
    uint64_t v17 = v16;
    if (v16)
    {
      *(void *)uint64_t v16 = a1;
      v16[3] = a5;
      _OWORD v16[4] = v14;
      *((void *)v16 + 3) = CFRetain(a3);
      *((void *)v17 + 4) = a4;
      *((void *)v17 + 5) = a6;
      long long v18 = (ipc_space_t *)MEMORY[0x1E4F14960];
      if (!mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name))
      {
        mach_port_name_t v19 = name;
        _DWORD v17[2] = name;
        if (!a7)
        {
          char v20 = 0;
          goto LABEL_12;
        }
        if (!mach_port_insert_right(*v18, v19, v19, 0x14u))
        {
          char v20 = 1;
LABEL_12:
          if (*(void *)(a1 + 32))
          {
            uint64_t v44 = 0;
            uint64_t v45 = &v44;
            uint64_t v46 = 0x2000000000;
            uint64_t v47 = 0;
            if (*(unsigned char *)(a1 + 88))
            {
              if (figrpc_getCommonServerTimeoutQueue_once != -1) {
                dispatch_once(&figrpc_getCommonServerTimeoutQueue_once, &__block_literal_global_21);
              }
              *((void *)v17 + 14) = figrpc_createRPCTimeoutDetector(figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue, **(void **)v17, a1);
            }
            uint64_t v36 = MEMORY[0x1E4F143A8];
            uint64_t v37 = 0x40000000;
            uint64_t v38 = __figrpc_createClientCommon_block_invoke;
            mach_port_name_t v39 = &unk_1E567D558;
            mach_port_name_t v42 = name;
            char v43 = v20;
            mach_port_name_t v40 = &v44;
            uint64_t v41 = v17;
            uint64_t v21 = dispatch_mach_create();
            *((void *)v17 + 7) = v21;
            v45[3] = v21;
            dispatch_mach_connect();
            _Block_object_dispose(&v44, 8);
          }
          else
          {
            uint64_t v22 = dispatch_source_create(MEMORY[0x1E4F14458], v17[2], 0, *(dispatch_queue_t *)(a1 + 16));
            *((void *)v17 + 6) = v22;
            handler[0] = MEMORY[0x1E4F143A8];
            handler[1] = 0x40000000;
            handler[2] = __figrpc_createClientCommon_block_invoke_2;
            handler[3] = &__block_descriptor_tmp_26_4;
            mach_port_name_t v34 = name;
            char v35 = v20;
            handler[4] = v22;
            dispatch_source_set_cancel_handler(v22, handler);
            v32[0] = MEMORY[0x1E4F143A8];
            v32[1] = 0x40000000;
            v32[2] = __figrpc_createClientCommon_block_invoke_3;
            v32[3] = &__block_descriptor_tmp_27_1;
            v32[4] = v22;
            v32[5] = a1;
            dispatch_source_set_event_handler(v22, v32);
            dispatch_resume(*((dispatch_object_t *)v17 + 6));
          }
          uint64_t v23 = dispatch_source_create(MEMORY[0x1E4F14460], v17[3], 1uLL, *(dispatch_queue_t *)(a1 + 16));
          *((void *)v17 + 8) = v23;
          v30[0] = MEMORY[0x1E4F143A8];
          v30[1] = 0x40000000;
          v30[2] = __figrpc_createClientCommon_block_invoke_4;
          v30[3] = &__block_descriptor_tmp_28_2;
          mach_port_name_t v31 = a5;
          v30[4] = v23;
          dispatch_source_set_cancel_handler(v23, v30);
          v27[0] = MEMORY[0x1E4F143A8];
          v27[1] = 0x40000000;
          v27[2] = __figrpc_createClientCommon_block_invoke_5;
          v27[3] = &__block_descriptor_tmp_29_2;
          int v28 = v14;
          mach_port_name_t v29 = name;
          v27[4] = a1;
          v27[5] = v23;
          dispatch_source_set_event_handler(v23, v27);
          dispatch_resume(v23);
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 64), (const void *)v17[2], v17);
          uint64_t v24 = 0;
          goto LABEL_20;
        }
      }
      uint64_t v26 = 4294955052;
    }
    else
    {
      uint64_t v26 = 4294955055;
    }
    uint64_t v24 = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v24 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
    uint64_t v17 = 0;
  }
  if (v24)
  {
    if (a5 - 1 <= 0xFFFFFFFD) {
      FigMachPortReleaseSendRight_(a5, 0, 0, 0, 0);
    }
    if (v17 && *((void *)v17 + 7))
    {
      dispatch_mach_cancel();
    }
    else if (name - 1 <= 0xFFFFFFFD)
    {
      FigMachPortReleaseReceiveRight_(name, 0, 0, 0, 0);
    }
    free(v17);
    uint64_t v17 = 0;
  }
LABEL_20:
  *a8 = v17;
  if (v48) {
    CFRelease(v48);
  }
  return v24;
}

uint64_t FigRPCCreateClientConnectionWithManualCommandPortSendRightInsertion(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, void *a7)
{
  return figrpc_createClientCommon(a1, a2, a3, a4, a5, a6, 1, a7);
}

uint64_t FigRPCCreateClientConnectionWithNotifications(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  char v20 = 0;
  if (!a1)
  {
    uint64_t v16 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  if (!a3) {
    goto LABEL_13;
  }
  if (!a4)
  {
    uint64_t v19 = 4294955056;
    goto LABEL_17;
  }
  if (a5 && a7 && a8)
  {
    uint64_t v12 = figrpc_createClientCommon(a1, a2, a3, a4, a5, a6, 0, &v20);
    if (v12) {
      goto LABEL_10;
    }
    uint64_t v13 = v20;
    v20[10] = 0;
    v13 += 10;
    v13[1] = v13;
    *(v13 - 1) = a7;
    dispatch_queue_t v14 = dispatch_queue_create("FigRPCClientConnectionNotifications", 0);
    v20[13] = v14;
    if (v14)
    {
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      uint64_t v12 = CMNotificationCenterAddListener(DefaultLocalCenter, v20, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))figrpc_reflectServedObjectNotificationToClient, 0, (unint64_t)a3);
      goto LABEL_10;
    }
    uint64_t v19 = 4294955055;
  }
  else
  {
LABEL_13:
    uint64_t v19 = 4294955056;
  }
LABEL_17:
  uint64_t v12 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
LABEL_10:
  uint64_t v16 = v12;
  uint64_t v17 = v20;
  if (!v20)
  {
LABEL_11:
    FigMachPortReleaseSendRight_(a5, 0, 0, 0, 0);
    uint64_t v17 = v20;
  }
  *a8 = v17;
  return v16;
}

void figrpc_reflectServedObjectNotificationToClient(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5)
{
  long long v8 = malloc_type_calloc(1uLL, 0x18uLL, 0xE00406B48E91AuLL);
  if (v8)
  {
    int v9 = v8;
    v8[1] = a3;
    CFRetain(a3);
    if (a5) {
      _OWORD v9[2] = CFRetain(a5);
    }
    uint64_t v12 = 0;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2000000000;
    char v15 = 0;
    dispatch_time_t v10 = *(NSObject **)(a2 + 104);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __figrpc_enqueueNotificationInternal_block_invoke;
    block[3] = &unk_1E567D600;
    void block[5] = v9;
    void block[6] = a2;
    block[4] = &v12;
    dispatch_sync(v10, block);
    if (*((unsigned char *)v13 + 24)) {
      (*(void (**)(void, void))(a2 + 72))(*(unsigned int *)(a2 + 12), *(void *)(a2 + 32));
    }
    _Block_object_dispose(&v12, 8);
  }
  else
  {
    FigSignalErrorAt(4294955055, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigRPCDisposeClientConnection(uint64_t a1, unsigned int *value)
{
  if (a1)
  {
    if (!value) {
      return 0;
    }
    if (CFDictionaryContainsValue(*(CFDictionaryRef *)(a1 + 64), value))
    {
      if (*((void *)value + 9))
      {
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(DefaultLocalCenter, value, (int)figrpc_reflectServedObjectNotificationToClient, 0, *((void **)value + 3));
        uint64_t v4 = *((void *)value + 3);
        uint64_t v5 = *(void **)(CMBaseObjectGetVTable(v4) + 8);
        if (v5) {
          mach_port_name_t v6 = v5;
        }
        else {
          mach_port_name_t v6 = 0;
        }
        if (*v6 >= 2uLL)
        {
          unint64_t v7 = (void (*)(uint64_t))v6[8];
          if (v7) {
            v7(v4);
          }
        }
        long long v8 = *((void *)value + 13);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = __figrpc_cancelQueuedNotifications_block_invoke;
        block[3] = &__block_descriptor_tmp_32_0;
        block[4] = value;
        dispatch_sync(v8, block);
        dispatch_release(*((dispatch_object_t *)value + 13));
        *((void *)value + 13) = 0;
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(void *)value + 64), (const void *)value[2]);
      int v9 = *((void *)value + 6);
      if (v9) {
        dispatch_source_cancel(v9);
      }
      if (*((void *)value + 7)) {
        dispatch_mach_cancel();
      }
      dispatch_time_t v10 = (const void *)*((void *)value + 3);
      if (v10) {
        CFRelease(v10);
      }
      unsigned int v11 = *((void *)value + 8);
      if (v11) {
        dispatch_source_cancel(v11);
      }
      uint64_t v12 = (const void *)*((void *)value + 14);
      if (v12) {
        CFRelease(v12);
      }
      *((void *)value + 14) = 0;
      *((_OWORD *)value + 5) = 0u;
      *((_OWORD *)value + 6) = 0u;
      *((_OWORD *)value + 3) = 0u;
      *((_OWORD *)value + 4) = 0u;
      *((_OWORD *)value + 1) = 0u;
      *((_OWORD *)value + 2) = 0u;
      *(_OWORD *)uint64_t value = 0u;
      free(value);
      return 0;
    }
    uint64_t v14 = 4294955051;
  }
  else
  {
    uint64_t v14 = 4294955056;
  }

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRPCLookupClientConnection(uint64_t a1, void *key, void *a3)
{
  uint64_t v5 = 4294955056;
  if (!a1 || !a3 || (key + 1) < 2) {
    goto LABEL_8;
  }
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), (const void *)key);
  if (!Value)
  {
    uint64_t v5 = 4294955051;
LABEL_8:
    uint64_t v7 = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
    CFNumberRef Value = 0;
    goto LABEL_6;
  }
  uint64_t v7 = 0;
LABEL_6:
  *a3 = Value;
  return v7;
}

uint64_t FigRPCGetConnectionInfo(uint64_t a1, _DWORD *a2, void *a3, void *a4)
{
  if (a1)
  {
    if (a2) {
      *a2 = *(_DWORD *)(a1 + 8);
    }
    if (a3) {
      *a3 = *(void *)(a1 + 40);
    }
    if (a4)
    {
      CFTypeRef v6 = *(CFTypeRef *)(a1 + 24);
      if (v6) {
        CFTypeRef v6 = CFRetain(v6);
      }
      *a4 = v6;
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigRPCRetainServedObjectOfConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  long long v8 = &v7;
  uint64_t v9 = 0x2000000000;
  int v10 = 0;
  if (a1 && a2 && a3)
  {
    uint64_t v3 = *(NSObject **)(a1 + 16);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __FigRPCRetainServedObjectOfConnection_block_invoke;
    v6[3] = &unk_1E567D490;
    _OWORD v6[6] = a2;
    v6[7] = a3;
    v6[4] = &v7;
    v6[5] = a1;
    dispatch_sync(v3, v6);
    uint64_t v4 = *((unsigned int *)v8 + 6);
  }
  else
  {
    uint64_t v4 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v8 + 6) = v4;
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

const void *__FigRPCRetainServedObjectOfConnection_block_invoke(uint64_t a1)
{
  if (CFDictionaryContainsValue(*(CFDictionaryRef *)(*(void *)(a1 + 40) + 64), *(const void **)(a1 + 48)))
  {
    uint64_t result = *(const void **)(*(void *)(a1 + 48) + 24);
    if (result) {
      uint64_t result = CFRetain(result);
    }
    **(void **)(a1 + 56) = result;
  }
  else
  {
    uint64_t result = (const void *)FigSignalErrorAt(4294955051, 0, 0, 0, 0, 0, 0);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t FigRPCExecuteByServerSync(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    dispatch_sync(*(dispatch_queue_t *)(a1 + 16), a2);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigRPCExecuteByServerAsync(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    dispatch_async(*(dispatch_queue_t *)(a1 + 16), a2);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  }
}

void __figrpc_createRPCTimeoutDetector_block_invoke(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t context = dispatch_get_context(*(dispatch_object_t *)(v3 + 16));
  if (v2)
  {
    if (*(unsigned char *)(v3 + 544))
    {
      uint64_t v7 = *(void (**)(void *, char *, uint64_t))(*(void *)(a1 + 48) + 120);
      if (v7)
      {
        v7(context, buffer, 256);
        strnlen((const char *)v2 + 25, 0x200uLL);
        __strncat_chk();
      }
      uint64_t v8 = *((unsigned int *)v2 + 135);
      uint64_t v9 = (char *)v2 + 25;
      FigRPCServer_TimeoutCrashReport(v8, v9);
      pid_t v10 = getpid();
      memset(v53, 0, sizeof(v53));
      long long v52 = 0u;
      long long v51 = 0u;
      long long v50 = 0u;
      long long v49 = 0u;
      long long v48 = 0u;
      *(_OWORD *)&v47[3] = 0u;
      memset(v47, 63, 3);
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      memset(buffer, 0, sizeof(buffer));
      proc_name(v10, v47, 0x80u);
      snprintf(buffer, 0x200uLL, "%s: Self-aborting on connection death timeout with reason: %s", v47, v9);
      v17[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272F90, 0, v17, &type);
      int v12 = v17[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v14 = v12;
      }
      else {
        unsigned int v14 = v12 & 0xFFFFFFFE;
      }
      if (v14)
      {
        v17[1] = 136315394;
        long long v18 = "figrpc_selfAbortDueToTimeout";
        __int16 v19 = 2082;
        char v20 = buffer;
        char v15 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v12) = v17[0];
      }
      else
      {
        char v15 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272F90, 0, 1, v15, v15 != &v21, v12, 0, v13);
      qword_1E9271400 = (uint64_t)buffer;
      abort();
    }
    uint64_t v5 = *((unsigned int *)v2 + 135);
    pid_t v6 = getpid();
    memset(&buffer[3], 0, 125);
    memset(buffer, 63, 3);
    *(void *)uint64_t v47 = 0;
    proc_name(v6, buffer, 0x80u);
    FigServer_CopyProcessName(v5, (CFStringRef *)v47);
    FigRPCServer_TimeoutCrashReport(v5, (const char *)v2 + 25);
    if (*(void *)v47) {
      CFRelease(*(CFTypeRef *)v47);
    }
    kill(v6, 9);
    CFRelease(v2);
  }
}

void __figrpc_createRPCTimeoutDetector_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void figRPCTimeoutDetector_Init(uint64_t a1)
{
}

void figRPCTimeoutDetector_Finalize(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3)
    {
      dispatch_release(v3);
      *(void *)(a1 + 16) = 0;
    }
  }
  *(unsigned char *)(a1 + 25) = 0;
}

dispatch_queue_t __figrpc_getCommonServerTimeoutQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("FigRPCServerCommonTimeoutQueue", 0);
  figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue = (uint64_t)result;
  return result;
}

void __figRPCTimeoutDetector_unsetTimer_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 25) = 0;
  uint64_t v2 = *(void *)(a1 + 32);
  *(_DWORD *)(v2 + 540) = 0;
  uint64_t v3 = *(NSObject **)(v2 + 16);
  if (dispatch_get_context(v3))
  {
    uint64_t v4 = *(void (**)(void))(*(void *)(v2 + 560) + 112);
    if (v4)
    {
      v4();
      uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 16);
    }
    dispatch_set_context(v3, 0);
  }
}

void __figrpc_createClientCommon_block_invoke(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 8:
      pid_t v6 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (v6)
      {
        dispatch_release(v6);
      }
      break;
    case 7:
      FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 48), 0, 0, 0, 0);
      if (*(unsigned char *)(a1 + 52))
      {
        mach_port_name_t v7 = *(_DWORD *)(a1 + 48);
        FigMachPortReleaseSendRight_(v7, 0, 0, 0, 0);
      }
      break;
    case 2:
      uint64_t v3 = *(void *)(a1 + 40);
      if (*(void *)(v3 + 112) && (CFTypeRef v4 = CFRetain(*(CFTypeRef *)(v3 + 112))) != 0)
      {
        figRPCTimeoutDetector_setTimer((uint64_t)v4, ***(const char ****)(a1 + 40), *(_DWORD *)(*(void *)(a1 + 40) + 16));
        char v5 = dispatch_mach_mig_demux();
        figRPCTimeoutDetector_unsetTimer((uint64_t)v4);
        CFRelease(v4);
        if (v5) {
          return;
        }
      }
      else if (dispatch_mach_mig_demux())
      {
        return;
      }
      uint64_t msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
      mach_msg_destroy(msg);
      break;
    default:
      return;
  }
}

void __figrpc_createClientCommon_block_invoke_2(uint64_t a1)
{
  FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  if (*(unsigned char *)(a1 + 44)) {
    FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  }
  uint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

uint64_t __figrpc_createClientCommon_block_invoke_3(uint64_t a1)
{
  return MEMORY[0x1F40CBB78](*(void *)(a1 + 32), *(void *)(*(void *)(a1 + 40) + 56));
}

void __figrpc_createClientCommon_block_invoke_4(uint64_t a1)
{
  FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  uint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

void __figrpc_createClientCommon_block_invoke_5(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(const void **)(v2 + 96);
  if (!v3) {
    goto LABEL_11;
  }
  CFTypeRef v4 = CFRetain(v3);
  if (!v4)
  {
    uint64_t v2 = *(void *)(a1 + 32);
LABEL_11:
    (*(void (**)(void))(v2 + 72))(*(unsigned int *)(a1 + 52));
    goto LABEL_12;
  }
  uint64_t v5 = (uint64_t)v4;
  uint64_t v6 = *(unsigned int *)(a1 + 52);
  if (*((void *)v4 + 2))
  {
    uint64_t v7 = *(unsigned int *)(a1 + 48);
    uint64_t v8 = **(const char ***)(a1 + 32);
    v4[135] = v7;
    *((unsigned char *)v4 + 544) = 1;
    CFTypeRef cf = 0;
    memset(v15, 0, sizeof(v15));
    FigServer_CopyProcessName(v7, (CFStringRef *)&cf);
    CStringPtrMaybeUsingPreallocatedBuffer = FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)cf, (char *)v15, 128, 0x600u);
    snprintf((char *)(v5 + 25), 0x200uLL, "(%s:ConnectionDeath: %s PID:%d) ", v8, CStringPtrMaybeUsingPreallocatedBuffer, v7);
    if (cf) {
      CFRelease(cf);
    }
    pid_t v10 = *(uint64_t (**)(uint64_t))(*(void *)(v5 + 560) + 104);
    if (v10)
    {
      unsigned int v11 = (void *)v10(v6);
      dispatch_set_context(*(dispatch_object_t *)(v5 + 16), v11);
    }
    int v12 = *(NSObject **)(v5 + 16);
    dispatch_time_t v13 = dispatch_time(0, 30000000000);
    dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
    *(unsigned char *)(v5 + 24) = 1;
    uint64_t v6 = *(unsigned int *)(a1 + 52);
  }
  (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 72))(v6);
  figRPCTimeoutDetector_unsetTimer(v5);
  CFRelease((CFTypeRef)v5);
LABEL_12:
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
}

uint64_t __figrpc_enqueueNotificationInternal_block_invoke(uint64_t result)
{
  **(void **)(result + 40) = 0;
  **(void **)(*(void *)(result + 48) + 88) = *(void *)(result + 40);
  *(void *)(*(void *)(result + 48) + 88) = *(void *)(result + 40);
  if (!*(unsigned char *)(*(void *)(result + 48) + 96))
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *(unsigned char *)(*(void *)(result + 48) + 96) = 1;
  }
  return result;
}

uint64_t *__figrpc_cancelQueuedNotifications_block_invoke(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 32); ; uint64_t i = *(void *)(a1 + 32))
  {
    dispatch_queue_t result = *(uint64_t **)(i + 80);
    if (!result) {
      break;
    }
    uint64_t v4 = *result;
    *(void *)(i + 80) = *result;
    if (!v4)
    {
      *(void *)(i + 88) = i + 80;
      *(unsigned char *)(i + 96) = 0;
    }
    figrpc_freeQueuedNotification(result);
  }
  return result;
}

CFIndex FigRemote_CreateVMBufferFromPropertyList(CFTypeRef a1, vm_address_t *a2, _DWORD *a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    CFIndex CFDataFromCFPropertyList = FigCreateCFDataFromCFPropertyList(a1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFDataRef *)&cf);
    if (CFDataFromCFPropertyList) {
      goto LABEL_5;
    }
    a1 = cf;
  }
  CFIndex CFDataFromCFPropertyList = FigRemote_CreateVMBufferFromBinaryPListData((const __CFData *)a1, a2, a3);
LABEL_5:
  CFIndex v6 = CFDataFromCFPropertyList;
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t FigRemote_CreateVMBufferFromBinaryPListData(const __CFData *a1, vm_address_t *a2, _DWORD *a3)
{
  if (a1 && (vm_size_t Length = CFDataGetLength(a1)) != 0)
  {
    size_t v7 = Length;
    uint64_t result = vm_allocate(*MEMORY[0x1E4F14960], a2, Length, 1560281089);
    if (result) {
      return result;
    }
    uint64_t v9 = (void *)*a2;
    BytePtr = CFDataGetBytePtr(a1);
    memcpy(v9, BytePtr, v7);
  }
  else
  {
    LODWORD(v7) = 0;
    *a2 = 0;
  }
  uint64_t result = 0;
  *a3 = v7;
  return result;
}

uint64_t FigRemote_CreateSerializableDictionaryForFormatDescription(const __CFAllocator *a1, CMFormatDescriptionRef desc, CFDictionaryRef *a3)
{
  CFIndex v3 = (CFIndex)desc;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  CMMediaType valuePtr = 0;
  size_t totalLengthOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  dataPointerOut = 0;
  keys = 0;
  long long v25 = 0;
  long long v26 = 0;
  values = 0;
  CFNumberRef v22 = 0;
  CFTypeRef v23 = 0;
  if (!desc)
  {
    uint64_t v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    CFStringRef v8 = 0;
    goto LABEL_47;
  }
  if (!a3)
  {
    uint64_t v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    CFStringRef v8 = 0;
    goto LABEL_61;
  }
  signed int MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType <= 1935832171)
  {
    if (MediaType <= 1835365472)
    {
      if (MediaType != 1635088502)
      {
        if (MediaType == 1668047728)
        {
          uint64_t v7 = CMClosedCaptionFormatDescriptionCopyAsBigEndianClosedCaptionDescriptionBlockBuffer(a1, (CMClosedCaptionFormatDescriptionRef)v3, 0, &blockBufferOut);
          goto LABEL_37;
        }
        if (MediaType == 1751216244)
        {
          uint64_t v7 = CMHapticFormatDescriptionCopyAsBigEndianHapticDescriptionBlockBuffer(a1, (CFTypeRef)v3, 0, &blockBufferOut);
LABEL_37:
          uint64_t v12 = v7;
          CFStringRef v8 = 0;
          goto LABEL_38;
        }
LABEL_36:
        uint64_t v7 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        goto LABEL_37;
      }
      goto LABEL_24;
    }
    if (MediaType == 1835365473)
    {
      uint64_t v7 = CMMetadataFormatDescriptionCopyAsBigEndianMetadataDescriptionBlockBuffer(a1, (CMMetadataFormatDescriptionRef)v3, 0, &blockBufferOut);
      goto LABEL_37;
    }
    if (MediaType == 1885564004)
    {
      uint64_t v7 = CMPointCloudFormatDescriptionCopyAsBigEndianPointCloudDescriptionBlockBuffer(a1, (CFTypeRef)v3, 0, &blockBufferOut);
      goto LABEL_37;
    }
    int v10 = 1885954932;
LABEL_23:
    if (MediaType != v10) {
      goto LABEL_36;
    }
LABEL_24:
    if (CMFormatDescriptionGetExtension((CMFormatDescriptionRef)v3, @"VerbatimISOSampleEntry")) {
      CFStringRef v8 = @"ISOFamily";
    }
    else {
      CFStringRef v8 = 0;
    }
    CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
    uint64_t v9 = CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(a1, (CMVideoFormatDescriptionRef)v3, SystemEncoding, v8, &blockBufferOut);
    goto LABEL_28;
  }
  if (MediaType > 1952807027)
  {
    if (MediaType != 1952807028)
    {
      if (MediaType == 1953325924)
      {
        uint64_t v7 = CMTimeCodeFormatDescriptionCopyAsBigEndianTimeCodeDescriptionBlockBuffer(a1, (CMTimeCodeFormatDescriptionRef)v3, 0, &blockBufferOut);
        goto LABEL_37;
      }
      int v10 = 1986618469;
      goto LABEL_23;
    }
LABEL_30:
    uint64_t v7 = CMTextFormatDescriptionCopyAsBigEndianTextDescriptionBlockBuffer(a1, (CMTextFormatDescriptionRef)v3, 0, &blockBufferOut);
    goto LABEL_37;
  }
  if (MediaType == 1935832172) {
    goto LABEL_30;
  }
  if (MediaType == 1935893870)
  {
    uint64_t v7 = CMSceneFormatDescriptionCopyAsBigEndianSceneDescriptionBlockBuffer(a1, (CFTypeRef)v3, 0, &blockBufferOut);
    goto LABEL_37;
  }
  if (MediaType != 1936684398) {
    goto LABEL_36;
  }
  if (CMFormatDescriptionGetExtension((CMFormatDescriptionRef)v3, @"VerbatimISOSampleEntry")) {
    CFStringRef v8 = @"ISOFamily";
  }
  else {
    CFStringRef v8 = 0;
  }
  uint64_t v9 = CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer(a1, (CMAudioFormatDescriptionRef)v3, v8, &blockBufferOut);
LABEL_28:
  uint64_t v12 = v9;
  if (v8) {
    CFStringRef v8 = (const __CFString *)CFRetain(v8);
  }
LABEL_38:
  if (v12)
  {
LABEL_61:
    CFIndex v3 = 0;
    goto LABEL_47;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, &totalLengthOut, &dataPointerOut);
  if (DataPointer)
  {
LABEL_60:
    uint64_t v12 = DataPointer;
    goto LABEL_61;
  }
  values = CFDataCreate(a1, (const UInt8 *)dataPointerOut, totalLengthOut);
  if (!values)
  {
    uint64_t DataPointer = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_60;
  }
  keys = @"FormatDescriptionData";
  CMMediaType valuePtr = CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)v3);
  CFNumberRef v22 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  if (v22)
  {
    long long v25 = @"MediaType";
    if (v8)
    {
      CFTypeRef v23 = CFRetain(v8);
      long long v26 = @"SampleDescriptionFlavor";
      CFIndex v3 = 3;
    }
    else
    {
      CFIndex v3 = 2;
    }
    CFDictionaryRef v14 = CFDictionaryCreate(a1, (const void **)&keys, (const void **)&values, v3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v14)
    {
      uint64_t v12 = 0;
      *a3 = v14;
    }
    else
    {
      uint64_t v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    uint64_t v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    CFIndex v3 = 1;
  }
LABEL_47:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v3)
  {
    p_values = &values;
    do
    {
      if (*p_values) {
        CFRelease(*p_values);
      }
      ++p_values;
      --v3;
    }
    while (v3);
  }
  return v12;
}

uint64_t FigRemote_CreateFormatDescriptionFromSerializedDictionary(const __CFAllocator *a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  signed int valuePtr = 0;
  CFTypeRef cf = 0;
  if (theDict)
  {
    if (a3)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MediaType");
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
        CFDataRef v7 = (const __CFData *)CFDictionaryGetValue(theDict, @"FormatDescriptionData");
        if (!v7) {
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        }
        CFDataRef v8 = v7;
        CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(theDict, @"SampleDescriptionFlavor");
        signed int v10 = valuePtr;
        BytePtr = (uint8_t *)CFDataGetBytePtr(v8);
        size_t Length = CFDataGetLength(v8);
        if (v10 <= 1935832171)
        {
          if (v10 <= 1835365472)
          {
            if (v10 != 1635088502)
            {
              if (v10 == 1668047728)
              {
                uint64_t v13 = CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(a1, BytePtr, Length, v9, (CMClosedCaptionFormatDescriptionRef *)&cf);
                goto LABEL_31;
              }
              if (v10 == 1751216244)
              {
                uint64_t v13 = CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionData(a1, (unsigned int *)BytePtr, Length, (int)v9, (CMFormatDescriptionRef *)&cf);
                goto LABEL_31;
              }
              goto LABEL_30;
            }
            goto LABEL_23;
          }
          if (v10 == 1835365473)
          {
            uint64_t v13 = CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionData(a1, BytePtr, Length, v9, (CMMetadataFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          if (v10 == 1885564004)
          {
            uint64_t v13 = CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionData(a1, (unsigned int *)BytePtr, Length, 0x70636C64u, (CMFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          int v14 = 1885954932;
LABEL_22:
          if (v10 != v14)
          {
LABEL_30:
            uint64_t v13 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_31:
            uint64_t v16 = v13;
            if (v13)
            {
              if (cf) {
                CFRelease(cf);
              }
            }
            else
            {
              *a3 = cf;
            }
            return v16;
          }
LABEL_23:
          CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
          uint64_t v13 = CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(a1, BytePtr, Length, SystemEncoding, v9, (CMVideoFormatDescriptionRef *)&cf);
          goto LABEL_31;
        }
        if (v10 > 1952807027)
        {
          if (v10 != 1952807028)
          {
            if (v10 == 1953325924)
            {
              uint64_t v13 = CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(a1, BytePtr, Length, v9, (CMTimeCodeFormatDescriptionRef *)&cf);
              goto LABEL_31;
            }
            int v14 = 1986618469;
            goto LABEL_22;
          }
        }
        else if (v10 != 1935832172)
        {
          if (v10 == 1935893870)
          {
            uint64_t v13 = CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionData(a1, (unsigned int *)BytePtr, Length, (int)v9, (CMFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          if (v10 == 1936684398)
          {
            uint64_t v13 = CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionData(a1, BytePtr, Length, v9, (CMAudioFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          goto LABEL_30;
        }
        uint64_t v13 = CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(a1, BytePtr, Length, v9, v10, (CMTextFormatDescriptionRef *)&cf);
        goto LABEL_31;
      }
    }
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRemote_CreatePListFromFormatDescriptionCollection(const __CFAllocator *a1, CFTypeRef cf, CFArrayRef *a3)
{
  if (!cf) {
    goto LABEL_15;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID())
  {
    char v20 = a3;
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFDataRef v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    CFStringRef v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v21.location = 0;
    v21.length = Count;
    CFArrayGetValues((CFArrayRef)cf, v21, v8);
    signed int v10 = 0;
    goto LABEL_6;
  }
  if (v6 != CFDictionaryGetTypeID())
  {
LABEL_15:
    uint64_t v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    CFStringRef v9 = 0;
    CFDataRef v8 = 0;
    signed int v10 = 0;
    goto LABEL_22;
  }
  char v20 = a3;
  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  signed int v10 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  CFDataRef v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  CFStringRef v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v10, v8);
LABEL_6:
  if (Count >= 1)
  {
    unsigned int v11 = (CMFormatDescriptionRef *)v8;
    uint64_t v12 = (CFDictionaryRef *)v9;
    CFIndex v13 = Count;
    while (1)
    {
      uint64_t SerializableDictionaryForFormatDescription = FigRemote_CreateSerializableDictionaryForFormatDescription(a1, *v11, v12);
      if (SerializableDictionaryForFormatDescription) {
        break;
      }
      ++v12;
      ++v11;
      if (!--v13) {
        goto LABEL_10;
      }
    }
    uint64_t v16 = SerializableDictionaryForFormatDescription;
    goto LABEL_17;
  }
LABEL_10:
  if (v6 == CFArrayGetTypeID())
  {
    CFArrayRef v15 = CFArrayCreate(a1, v9, Count, MEMORY[0x1E4F1D510]);
LABEL_14:
    uint64_t v16 = 0;
    *char v20 = v15;
    goto LABEL_17;
  }
  if (v6 == CFDictionaryGetTypeID())
  {
    CFArrayRef v15 = CFDictionaryCreate(a1, v10, v9, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_14;
  }
  uint64_t v16 = 0;
LABEL_17:
  if (Count >= 1)
  {
    for (uint64_t i = 0; i != Count; ++i)
    {
      long long v18 = v9[i];
      if (v18) {
        CFRelease(v18);
      }
    }
  }
LABEL_22:
  free(v10);
  free(v8);
  free(v9);
  return v16;
}

uint64_t FigRemote_CreateFormatDescriptionCollectionFromPList(const __CFAllocator *a1, CFTypeRef cf, CFArrayRef *a3)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID())
  {
    char v20 = a3;
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFDataRef v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    CFStringRef v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v21.location = 0;
    v21.length = Count;
    CFArrayGetValues((CFArrayRef)cf, v21, v8);
    signed int v10 = 0;
  }
  else
  {
    if (v6 != CFDictionaryGetTypeID())
    {
      uint64_t v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      CFStringRef v9 = 0;
      CFDataRef v8 = 0;
      signed int v10 = 0;
      goto LABEL_21;
    }
    char v20 = a3;
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)cf);
    signed int v10 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    CFDataRef v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    CFStringRef v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v10, v8);
  }
  if (Count >= 1)
  {
    unsigned int v11 = (CFDictionaryRef *)v8;
    uint64_t v12 = v9;
    CFIndex v13 = Count;
    while (1)
    {
      FormatDescriptionFromSerializedDictionardouble y = FigRemote_CreateFormatDescriptionFromSerializedDictionary(a1, *v11, v12);
      if (FormatDescriptionFromSerializedDictionary) {
        break;
      }
      ++v12;
      ++v11;
      if (!--v13) {
        goto LABEL_9;
      }
    }
    uint64_t v16 = FormatDescriptionFromSerializedDictionary;
    goto LABEL_16;
  }
LABEL_9:
  if (v6 == CFArrayGetTypeID())
  {
    CFArrayRef v15 = CFArrayCreate(a1, v9, Count, MEMORY[0x1E4F1D510]);
LABEL_13:
    uint64_t v16 = 0;
    *char v20 = v15;
    goto LABEL_16;
  }
  if (v6 == CFDictionaryGetTypeID())
  {
    CFArrayRef v15 = CFDictionaryCreate(a1, v10, v9, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_13;
  }
  uint64_t v16 = 0;
LABEL_16:
  if (Count >= 1)
  {
    for (uint64_t i = 0; i != Count; ++i)
    {
      long long v18 = v9[i];
      if (v18) {
        CFRelease(v18);
      }
    }
  }
LABEL_21:
  free(v10);
  free(v8);
  free(v9);
  return v16;
}

uint64_t FigServer_GetEnvironment()
{
  return gServerEnvironment;
}

__CFString *FigServer_GetEnvironmentName()
{
  if (gServerEnvironment > 0xA) {
    return @"Unknown";
  }
  else {
    return (__CFString *)*((void *)&off_1E567D760 + gServerEnvironment);
  }
}

void FigServer_InitializeWithEnvironment(int a1)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigServer_InitializeWithEnvironment_block_invoke;
  block[3] = &__block_descriptor_tmp_53;
  int v2 = a1;
  if (FigServer_InitializeWithEnvironment_once != -1) {
    dispatch_once(&FigServer_InitializeWithEnvironment_once, block);
  }
}

void FigServer_Initialize()
{
}

void FigCommonMediaProcessInitialization(int a1)
{
  if (a1 == 10)
  {
    if (in_audio_mx_server_process() && _os_feature_enabled_impl())
    {
      FigServer_InitializeWithEnvironment(6);
      goto LABEL_12;
    }
    FigServer_InitializeWithEnvironment(10);
  }
  else
  {
    FigServer_InitializeWithEnvironment(a1);
    if (a1 == 6) {
      goto LABEL_12;
    }
  }
  if (feServer_SetupTERMSignalHandler_onceToken != -1) {
    dispatch_once(&feServer_SetupTERMSignalHandler_onceToken, &__block_literal_global_57);
  }
  if ((a1 & 0xFFFFFFFE) == 2) {
    gFigServer_AllowProcName = 1;
  }
LABEL_12:
  signal(30, (void (__cdecl *)(int))1);
  signal(31, (void (__cdecl *)(int))1);
  FigNote_OneTimeInitializationForMediaServerd();
  FigSysdiagnoseBlock_OneTimeInitializationForMediaserverd();

  FigKTraceInit();
}

uint64_t FigServer_SetAllowProcName(uint64_t result)
{
  gFigServer_AllowProcName = result;
  return result;
}

BOOL FigServer_IsServerProcess()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment != 0;
}

BOOL FigServer_ShouldLogFigErrorsAsErrorsInThisProcess()
{
  return gServerEnvironment != 0;
}

BOOL FigServer_IsMediaserverd()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment == 1;
}

BOOL FigServer_IsMediaparserd()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment == 3;
}

uint64_t FigRemote_ShouldConnectToMediaparserdForFileParsing()
{
  return 1;
}

uint64_t FigRemote_ShouldConnectToMediaparserdFile_OptIn()
{
  return 1;
}

BOOL FigServer_IsVideocodecd()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment == 4;
}

BOOL FigServer_IsVideoDecodeService()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment == 5;
}

BOOL FigServer_IsCameracaptured()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment == 7;
}

BOOL FigServer_IsMediaplaybackd()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment == 2;
}

uint64_t FigRemote_ShouldConnectToMediaplaybackd()
{
  return 1;
}

uint64_t FigRemote_ShouldConnectToAirplayd()
{
  return 1;
}

BOOL FigServer_IsAirplayd()
{
  if (checkFigRemotePrivTrace_onceToken != -1) {
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  }
  return gServerEnvironment == 8;
}

BOOL FigServer_IsWritableFileOpeningOrCreationPermittedForAuditToken(long long *a1, CFURLRef url)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v4 = CFURLStartAccessingSecurityScopedResource(url);
  if (checkFigRemotePrivTrace_onceToken == -1)
  {
    if (url) {
      goto LABEL_3;
    }
LABEL_23:
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_54);
  if (!url) {
    goto LABEL_23;
  }
LABEL_3:
  long long v5 = a1[1];
  long long v14 = *a1;
  long long v15 = v5;
  if (CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
  {
    *(_OWORD *)&v13.st_dev = v14;
    *(_OWORD *)&v13.st_uid = v15;
    if (!sandbox_check_by_audit_token())
    {
LABEL_11:
      BOOL v9 = 1;
      if (!v4) {
        return v9;
      }
      goto LABEL_15;
    }
  }
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024)) {
    goto LABEL_14;
  }
  CFTypeID v6 = (void *)sandbox_extension_issue_file_to_self();
  if (!v6)
  {
    CFTypeID v6 = (void *)sandbox_extension_issue_file_to_self();
    if (!v6) {
      goto LABEL_14;
    }
  }
  memset(&v13, 0, sizeof(v13));
  *__error() = 0;
  if (!stat((const char *)buffer, &v13))
  {
    free(v6);
    goto LABEL_14;
  }
  int v7 = *__error();
  free(v6);
  if (v7 != 2) {
    goto LABEL_14;
  }
  long long v8 = a1[1];
  long long v14 = *a1;
  long long v15 = v8;
  if (FigFileIsFileOnExternalStorageDevice(url)) {
    goto LABEL_11;
  }
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], url);
  if (!PathComponent)
  {
LABEL_14:
    BOOL v9 = 0;
    if (!v4) {
      return v9;
    }
LABEL_15:
    MEMORY[0x192FC4880](url);
    return v9;
  }
  CFURLRef v12 = PathComponent;
  if (CFURLGetFileSystemRepresentation(PathComponent, 1u, buffer, 1024))
  {
    *(_OWORD *)&v13.st_dev = v14;
    *(_OWORD *)&v13.st_uid = v15;
    BOOL v9 = sandbox_check_by_audit_token() == 0;
  }
  else
  {
    BOOL v9 = 0;
  }
  CFRelease(v12);
  if (v4) {
    goto LABEL_15;
  }
  return v9;
}

uint64_t FigServer_GetClientPIDFromAuditToken(_OWORD *a1)
{
  pid_t pidp = 0;
  long long v1 = a1[1];
  *(_OWORD *)atoken.val = *a1;
  *(_OWORD *)&atoken.val[4] = v1;
  audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
  return pidp;
}

uint64_t FigProcessInfoCreateWithDetails(uint64_t a1, int a2, const void *a3, void *a4)
{
  if (a3)
  {
    if (FigProcessInfoCreateWithDetails_once != -1) {
      dispatch_once(&FigProcessInfoCreateWithDetails_once, &__block_literal_global_43);
    }
    if (getProcNameWeakTable_once != -1) {
      dispatch_once(&getProcNameWeakTable_once, &__block_literal_global_67);
    }
    uint64_t v8 = getProcNameWeakTable_weakTable;
    FigSimpleMutexLock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
    uint64_t v9 = a2;
    id v10 = FigCFWeakReferenceTableCopyValue(v8, (void *)a2);
    if (v10)
    {
      uint64_t Instance = v10;
      if (!FigCFEqual(a3, *((CFTypeRef *)v10 + 2)))
      {
        CFURLRef v12 = (const void *)Instance[2];
        Instance[2] = a3;
        CFRetain(a3);
        if (v12) {
          CFRelease(v12);
        }
      }
      FigSimpleMutexUnlock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
    }
    else
    {
      if (figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce != -1) {
        dispatch_once(&figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce, &__block_literal_global_71);
      }
      uint64_t Instance = (void *)_CFRuntimeCreateInstance();
      if (!Instance)
      {
        uint64_t v15 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        if (v15)
        {
          uint64_t v13 = v15;
          FigSimpleMutexUnlock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
          return v13;
        }
      }
      Instance[2] = CFRetain(a3);
      uint64_t v13 = FigCFWeakReferenceTableAddValueAssociatedWithKey(v8, (uint64_t)Instance, v9);
      FigSimpleMutexUnlock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
      if (v13) {
        goto LABEL_18;
      }
    }
    uint64_t v13 = 0;
    if (a4)
    {
      *a4 = Instance;
      return v13;
    }
LABEL_18:
    CFRelease(Instance);
    return v13;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

pthread_mutex_t *__FigProcessInfoCreateWithDetails_block_invoke()
{
  uint64_t result = FigSimpleMutexCreate();
  FigProcessInfoCreateWithDetails_mutedouble x = (uint64_t)result;
  return result;
}

uint64_t FigServer_CopyProcessName(uint64_t a1, CFStringRef *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  char v10 = 0;
  memset(v9, 0, sizeof(v9));
  if (!a2) {
    return 0;
  }
  uint64_t v3 = a1;
  if (!a1)
  {
    *a2 = (CFStringRef)CFRetain(@"<UNKNOWN>");
    return v3;
  }
  if (getProcNameWeakTable_once != -1) {
    dispatch_once(&getProcNameWeakTable_once, &__block_literal_global_67);
  }
  id v4 = FigCFWeakReferenceTableCopyValue(getProcNameWeakTable_weakTable, (void *)(int)v3);
  long long v5 = v4;
  if (v4)
  {
    CFTypeID v6 = (const void *)*((void *)v4 + 2);
    if (v6)
    {
      *a2 = (CFStringRef)CFRetain(v6);
      uint64_t v3 = 1;
      goto LABEL_16;
    }
  }
  if (gFigServer_AllowProcName && proc_name(v3, v9, 0x21u) >= 1)
  {
    CFStringRef v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v9, 0x8000100u);
    uint64_t v3 = 1;
  }
  else
  {
    FigApplicationStateMonitorCopyProcessNameIfAvailable(v3, a2);
    if (*a2)
    {
      uint64_t v3 = 0;
      if (!v5) {
        return v3;
      }
      goto LABEL_16;
    }
    CFStringRef v7 = (const __CFString *)CFRetain(@"<UNKNOWN>");
    uint64_t v3 = 0;
  }
  *a2 = v7;
  if (v5) {
LABEL_16:
  }
    CFRelease(v5);
  return v3;
}

void FigServer_RememberProcessInfoForAFewSeconds(CFTypeRef cf)
{
  if (cf)
  {
    if (FigServer_RememberProcessInfoForAFewSeconds_once != -1) {
      dispatch_once(&FigServer_RememberProcessInfoForAFewSeconds_once, &__block_literal_global_49);
    }
    CFRetain(cf);
    dispatch_time_t v2 = dispatch_time(0, 10000000000);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigServer_RememberProcessInfoForAFewSeconds_block_invoke_2;
    block[3] = &__block_descriptor_tmp_51;
    void block[4] = cf;
    dispatch_after(v2, (dispatch_queue_t)FigServer_RememberProcessInfoForAFewSeconds_queue, block);
  }
}

uint64_t __getProcNameWeakTable_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  pid_t v0 = getpid();
  char v8 = 0;
  memset(v7, 0, sizeof(v7));
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  FigCFWeakReferenceTableCreate(AllocatorForPermanentAllocations, 1, &getProcNameWeakTable_weakTable);
  FigGetAllocatorForPermanentAllocations();
  if (figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce != -1) {
    dispatch_once(&figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce, &__block_literal_global_71);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance) {
    getProcNameWeakTable_currentProcessInfo = Instance;
  }
  else {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  proc_name(v0, v7, 0x21u);
  CFAllocatorRef v3 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  CFStringRef v4 = CFStringCreateWithCString(v3, (const char *)v7, 0x8000100u);
  uint64_t v5 = getProcNameWeakTable_currentProcessInfo;
  *(void *)(getProcNameWeakTable_currentProcessInfo + 16) = v4;
  return FigCFWeakReferenceTableAddValueAssociatedWithKey(getProcNameWeakTable_weakTable, v5, v0);
}

uint64_t figProcessInfo_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void figProcessInfo_Finalize(uint64_t a1)
{
  dispatch_time_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

CFTypeRef figProcessInfo_CopyDebugDesc(uint64_t a1)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t FigTransportGetClassID()
{
  if (FigTransportGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportGetClassID_sRegisterOnce, &FigTransportGetClassID_sClassID, (dispatch_function_t)transport_getClassID);
  }
  return FigTransportGetClassID_sClassID;
}

uint64_t transport_getClassID(void *a1)
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&transport_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportGetTypeID()
{
  if (FigTransportGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigTransportGetClassID_sRegisterOnce, &FigTransportGetClassID_sClassID, (dispatch_function_t)transport_getClassID);
  }
  pid_t v0 = (void *)FigTransportGetClassID_sClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef transport_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTransport %p]", a1);
}

uint64_t FigTimelineCoordinatorGetTypeID()
{
  if (FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce != -1) {
    dispatch_once_f(&FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorType);
  }
  return sFigTimelineCoordinatorID;
}

uint64_t registerFigTimelineCoordinatorType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinatorIOSurfaceID ID = result;
  return result;
}

uint64_t FigTimelineCoordinatorMakeHostTimeFromNetworkTimeDictionary(void *a1, CFDictionaryRef theDict, CMTime *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (theDict && a3)
  {
    value[0] = 0;
    v18[0] = 0;
    if (CFDictionaryGetValueIfPresent(theDict, @"Seconds", (const void **)value)
      && CFDictionaryGetValueIfPresent(theDict, @"Subsecs", (const void **)v18))
    {
      unsigned int UInt64 = FigCFNumberGetUInt64((const __CFNumber *)value[0]);
      unint64_t v7 = UInt64 | ((unint64_t)FigCFNumberGetUInt64((const __CFNumber *)v18[0]) << 32);
    }
    else
    {
      uint64_t v10 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
      unint64_t v7 = 0;
      if (v10) {
        return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
      }
    }
    v18[0] = 0;
    v18[1] = 0;
    uint64_t v19 = 0;
    FigTimeOfDayTimeFromNTPTimestamp(v7, (uint64_t)v18);
    *(_OWORD *)uint64_t value = *(_OWORD *)v18;
    uint64_t v25 = v19;
    uint64_t HostTimeForClockTime = CMTimeSyncTimeOfDayClockGetHostTimeForClockTime(a1, (uint64_t)value, a3);
    if (HostTimeForClockTime)
    {
      int v17 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 0, &v17, &type);
      int v12 = v17;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v14 = v12;
      }
      else {
        unsigned int v14 = v12 & 0xFFFFFFFE;
      }
      if (v14)
      {
        int v20 = 136315394;
        CFRange v21 = "FigTimelineCoordinatorMakeHostTimeFromNetworkTimeDictionary";
        __int16 v22 = 1024;
        int v23 = HostTimeForClockTime;
        uint64_t v15 = (void **)_os_log_send_and_compose_impl();
        LOBYTE(v12) = v17;
      }
      else
      {
        uint64_t v15 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 0, 1, v15, v15 != value, v12, 0, v13);
    }
    return HostTimeForClockTime;
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime(void *a1, CMTime *a2, CFDictionaryRef *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  memset(&v26, 0, sizeof(v26));
  if (a3)
  {
    v31[0] = *a2;
    uint64_t ClockTimeForHostTime = CMTimeSyncTimeOfDayClockGetClockTimeForHostTime(a1, (uint64_t)v31, &v26);
    if (ClockTimeForHostTime)
    {
      uint64_t v17 = ClockTimeForHostTime;
      int v25 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 0, &v25, &type);
      int v20 = v25;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v22 = v20;
      }
      else {
        unsigned int v22 = v20 & 0xFFFFFFFE;
      }
      if (v22)
      {
        int v27 = 136315394;
        long long v28 = "FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime";
        __int16 v29 = 1024;
        int v30 = v17;
        int v23 = (CMTime *)_os_log_send_and_compose_impl();
        LOBYTE(v20) = v25;
      }
      else
      {
        int v23 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 0, 1, v23, v23 != v31, v20, 0, v21);
      return v17;
    }
    v31[0] = v26;
    unint64_t v5 = FigNTPTimestampFromTimeOfDayTime(v31);
    unsigned int v6 = v5;
    unint64_t v7 = HIDWORD(v5);
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFNumberRef UInt32 = FigCFNumberCreateUInt32(v8, v6);
    CFNumberRef v11 = FigCFNumberCreateUInt32(v8, v7);
    CFNumberRef v12 = v11;
    if (Mutable) {
      BOOL v13 = UInt32 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13 || v11 == 0)
    {
      uint64_t v16 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
      if (!Mutable) {
        goto LABEL_13;
      }
    }
    else
    {
      CFDictionarySetValue(Mutable, @"Seconds", UInt32);
      CFDictionarySetValue(Mutable, @"Subsecs", v12);
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v8, Mutable);
      *a3 = Copy;
      if (Copy) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
      }
    }
    CFRelease(Mutable);
LABEL_13:
    if (UInt32) {
      CFRelease(UInt32);
    }
    if (v12) {
      CFRelease(v12);
    }
    if (v16) {
      return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    }
    else {
      return 0;
    }
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorSuspensionGetTypeID()
{
  if (FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce != -1) {
    dispatch_once_f(&FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorSuspensionType);
  }
  return sFigTimelineCoordinatorSuspensionID;
}

uint64_t registerFigTimelineCoordinatorSuspensionType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinatorSuspensionIOSurfaceID ID = result;
  return result;
}

CFTypeRef FigTimelineCoordinatorSuspensionCopyReason(uint64_t a1, void *a2)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *a2 = result;
  return result;
}

uint64_t FigTimelineCoordinatorSuspensionCreate(uint64_t a1, const void *a2, uint64_t *a3)
{
  if (a3)
  {
    if (a2)
    {
      if (FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce != -1) {
        dispatch_once_f(&FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorSuspensionType);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v6 = Instance;
        *(void *)(Instance + 16) = CFRetain(a2);
        *a3 = v6;
        return 0;
      }
      uint64_t v8 = 4294951586;
    }
    else
    {
      uint64_t v8 = 4294951585;
    }
  }
  else
  {
    uint64_t v8 = 4294951585;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorTimelineStateGetTypeID()
{
  if (FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce != -1) {
    dispatch_once_f(&FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorTimelineStateType);
  }
  return sFigTimelineCoordinatorTimelineStateID;
}

uint64_t registerFigTimelineCoordinatorTimelineStateType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinatorTimelineStateIOSurfaceID ID = result;
  return result;
}

uint64_t FigTimelineCoordinationParticipantSnapshotGetTypeID()
{
  if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1) {
    dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
  }
  return sFigTimelineCoordinationParticipantSnapshotID;
}

uint64_t registerFigTimelineCoordinationParticipantSnapshotType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinationParticipantSnapshotIOSurfaceID ID = result;
  return result;
}

uint64_t FigTimelineCoordinationParticipantSnapshotGetUUID(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

const void *FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  Boolean v6 = 0;
  FigCFDictionaryGetBooleanIfPresent(v2, @"ReadyToSetNonZeroRate", &v6);
  if (!v6) {
    return 0;
  }
  uint64_t result = participantState_timelineIdentifier(*(const __CFDictionary **)(a1 + 16));
  if (!result) {
    return result;
  }
  if (participantState_isSuspended(*(const __CFDictionary **)(a1 + 16))) {
    return 0;
  }
  CFStringRef v4 = *(const void **)(a1 + 24);
  unint64_t v5 = participantState_timelineIdentifier(*(const __CFDictionary **)(a1 + 16));
  return (const void *)(FigCFEqual(v4, v5) != 0);
}

const void *participantState_timelineIdentifier(const __CFDictionary *a1)
{
  uint64_t result = CFDictionaryGetValue(a1, @"CurrentIdentifier");
  if (result)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFStringGetTypeID()) {
      return v2;
    }
    else {
      return 0;
    }
  }
  return result;
}

CFArrayRef participantState_isSuspended(const __CFDictionary *a1)
{
  CFArrayRef result = (const __CFArray *)CFDictionaryGetValue(a1, @"SuspensionReasons");
  if (result)
  {
    CFArrayRef v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFArrayGetTypeID()) {
      return (const __CFArray *)(CFArrayGetCount(v2) > 0);
    }
    else {
      return 0;
    }
  }
  return result;
}

CFTypeRef FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(uint64_t a1)
{
  CFArrayRef Mutable = *(const __CFArray **)(a1 + 40);
  if (!Mutable)
  {
    CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"SuspensionReasons");
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Value)
    {
      CFTypeID v4 = CFGetTypeID(Value);
      if (v4 == CFArrayGetTypeID())
      {
        if (CFArrayGetCount((CFArrayRef)Value) >= 1)
        {
          CFIndex v5 = 0;
          do
          {
            ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)Value, v5);
            if (ValueAtIndex)
            {
              unint64_t v7 = ValueAtIndex;
              CFTypeID v8 = CFGetTypeID(ValueAtIndex);
              if (v8 == CFStringGetTypeID())
              {
                v11.length = CFArrayGetCount(Mutable);
                v11.location = 0;
                if (!CFArrayContainsValue(Mutable, v11, v7)) {
                  CFArrayAppendValue(Mutable, v7);
                }
              }
            }
            ++v5;
          }
          while (v5 < CFArrayGetCount((CFArrayRef)Value));
        }
        v12.length = CFArrayGetCount(Mutable);
        v12.location = 0;
        CFArraySortValues(Mutable, v12, MEMORY[0x1E4F1C2A8], 0);
      }
    }
    *(void *)(a1 + 40) = Mutable;
    if (!Mutable) {
      return 0;
    }
  }

  return CFRetain(Mutable);
}

uint64_t FigTimelineCoordinatorHandleUpdatedTimelineStateFromMedium(uint64_t a1, const void *a2)
{
  if (a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v4 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v4 + 1;
    CFIndex v5 = malloc_type_malloc(0x18uLL, 0x1060040E60A0C5AuLL);
    *CFIndex v5 = CFRetain((CFTypeRef)a1);
    v5[1] = CFRetain(a2);
    v5[2] = v4;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v5, (dispatch_function_t)figTimelineCoordinator_applyRemoteTimelineStateOnQueue);
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v6;
}

void figTimelineCoordinator_applyRemoteTimelineStateOnQueue(uint64_t *a1)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  CFArrayRef v2 = (const void *)a1[1];
  uint64_t v4 = a1[2];
  uint64_t v60 = 0;
  CFTypeRef cf = 0;
  uint64_t value = 0;
  Float64 seconds = 0.0;
  memset(&v64, 0, sizeof(v64));
  memset(&v62, 0, sizeof(v62));
  int v56 = -1;
  unsigned int v57 = 0;
  char v55 = 0;
  if (!v2) {
    goto LABEL_92;
  }
  CFTypeID v5 = CFGetTypeID(v2);
  if (v5 != CFDictionaryGetTypeID()) {
    goto LABEL_92;
  }
  CFStringRef v6 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v2, @"Identifier");
  if (!v6) {
    goto LABEL_92;
  }
  CFStringRef v7 = v6;
  CFTypeID v8 = CFGetTypeID(v6);
  if (v8 != CFStringGetTypeID()
    || !FigCFDictionaryGetFloat32IfPresent((uint64_t)v2, @"Rate", (char *)&v60 + 4)
    || !FigCFDictionaryGetDoubleIfPresent((uint64_t)v2, @"Time", &seconds))
  {
    goto LABEL_92;
  }
  CMTimeMakeWithSeconds(&v64, seconds, 1000000);
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v2, @"NetworkTime", (const void **)&value))
  {
    if (value)
    {
      CFTypeID v9 = CFGetTypeID(value);
      if (v9 == CFDictionaryGetTypeID())
      {
        if (FigTimelineCoordinatorMakeHostTimeFromNetworkTimeDictionary(*(void **)(v3 + 176), (CFDictionaryRef)value, &v62))goto LABEL_87; {
      }
        }
    }
  }
  if (FigCFDictionaryGetInt32IfPresent((uint64_t)v2, @"SeekPrecision", &v57) && v57 >= 2) {
    unsigned int v57 = 0;
  }
  FigCFDictionaryGetFloat32IfPresent((uint64_t)v2, @"PrerollRate", &v60);
  FigCFDictionaryGetBooleanIfPresent((uint64_t)v2, @"IsAuthoritative", (Boolean *)&v55);
  if (FigCFDictionaryGetInt32IfPresent((uint64_t)v2, @"LamportTimestamp", &v56)
    && v55
    && CFEqual(v7, *(CFStringRef *)(v3 + 352)))
  {
    int v10 = v56;
    *(_DWORD *)(v3 + 456) = v56;
    FigCFDictionarySetInt32(*(void **)(v3 + 464), *(const void **)(v3 + 352), v10);
  }
  CFStringRef v11 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v2, @"OriginatorUUID");
  if (!v11
    || (v12 = v11, CFTypeID v13 = CFGetTypeID(v11), v13 != CFStringGetTypeID())
    || (uint64_t v14 = *MEMORY[0x1E4F1CF80], (v15 = CFUUIDCreateFromString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v12)) == 0))
  {
LABEL_92:
    FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    goto LABEL_87;
  }
  CFUUIDRef v16 = v15;
  CMTime v54 = v64;
  CMTime type = v62;
  int Internal = figTimelineCoordinatorTimelineStateCreateInternal(*(float *)&v60, *((float *)&v60 + 1), v14, v7, (long long *)&v54.value, (long long *)&type.value, v57, v15, v4, v56, v55, 1, (uint64_t *)&cf);
  if (Internal)
  {
    CFTypeRef v19 = 0;
  }
  else
  {
    StateLoggingIdentifier = FigTimelineStateDictionaryGetStateLoggingIdentifier((const __CFDictionary *)v2);
    CFTypeRef v19 = cf;
    *((void *)cf + 14) = StateLoggingIdentifier;
    if (StateLoggingIdentifier)
    {
      CFRetain(StateLoggingIdentifier);
      CFTypeRef v19 = cf;
    }
    CFTypeRef cf = 0;
  }
  CFRelease(v16);
  if (cf) {
    CFRelease(cf);
  }
  if (!Internal && v19)
  {
    uint64_t v20 = *a1;
    uint64_t v21 = *(void *)(*a1 + 288);
    if (v21)
    {
      if (FigCFEqual(*(CFTypeRef *)(v21 + 88), *((CFTypeRef *)v19 + 11)))
      {
        unsigned int v22 = *(const void **)(v20 + 288);
        if (v22)
        {
          CFRelease(v22);
          *(void *)(v20 + 288) = 0;
        }
      }
    }
    if (FigCFEqual(*(CFTypeRef *)(v20 + 352), *((CFTypeRef *)v19 + 11)))
    {
      LOBYTE(type.value) = 0;
      if (figTimelineCoordinator_newTimelineStateShouldOverrideExistingState(v20, *(void *)(v20 + 200), (uint64_t)v19))
      {
        int v23 = *((_DWORD *)v19 + 25);
        *(_DWORD *)(v20 + 456) = v23;
        FigCFDictionarySetInt32(*(void **)(v20 + 464), *((const void **)v19 + 11), v23);
        long long v24 = *(const void **)(v20 + 208);
        if (v24)
        {
          CFRelease(v24);
          *(void *)(v20 + 208) = 0;
        }
        if (*(void *)(v20 + 224))
        {
          char v25 = 0;
          char v26 = 0;
          float v27 = *((float *)v19 + 9);
        }
        else
        {
          memset(&v64, 0, sizeof(v64));
          CMTimeMake(&v64, 1, 10);
          uint64_t v40 = *(void *)(v20 + 200);
          if (v40 && *(float *)(v40 + 36) != 0.0 && *((float *)v19 + 9) == 0.0 && *((_DWORD *)v19 + 24) == 1)
          {
            CMTimeMake(&v62, 5, 1);
            CMTime v64 = v62;
          }
          uint64_t v41 = *(void *)(v20 + 192);
          CMTime v62 = v64;
          figTimelineCoordinator_timelinesMatch((uint64_t)v19, v41, &v62, &type);
          char v26 = type.value;
          float v27 = *((float *)v19 + 9);
          char v25 = *(float *)(*(void *)(v20 + 192) + 36) == v27;
        }
        if (v27 == 0.0) {
          float v27 = *((float *)v19 + 8);
        }
        uint64_t v42 = *(void *)(v20 + 192);
        float v43 = *(float *)(v42 + 36);
        if (v43 == 0.0) {
          float v43 = *(float *)(v42 + 32);
        }
        figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v20, (uint64_t)v19, 0, 1, 1, v26, v25, v43 == v27);
        if (!*(unsigned char *)(v20 + 280))
        {
          if (dword_1E9272FB8)
          {
            LODWORD(v54.value) = 0;
            LOBYTE(cf) = 0;
            os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v54, &cf);
            unsigned int v45 = v54.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, (os_log_type_t)cf)) {
              unsigned int v47 = v45;
            }
            else {
              unsigned int v47 = v45 & 0xFFFFFFFE;
            }
            if (v47)
            {
              long long v48 = (__CFString *)*((void *)v19 + 11);
              LODWORD(v62.value) = 136315650;
              *(CMTimeValue *)((char *)&v62.value + 4) = (CMTimeValue)"figTimelineCoordinator_applyRemoteTimelineStateOnQueueInternal";
              LOWORD(v62.flags) = 2112;
              *(void *)((char *)&v62.flags + 2) = v20;
              HIWORD(v62.epoch) = 2114;
              long long v63 = v48;
              long long v49 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v45) = v54.value;
            }
            else
            {
              long long v49 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v49, v49 != &v64, v45, 0, v46);
          }
          *(unsigned char *)(v20 + 280) = 1;
        }
      }
      else if (dword_1E9272FB8)
      {
        long long v34 = FigCFCopyCompactDescription((const __CFSet *)v19);
        if (dword_1E9272FB8)
        {
          LODWORD(v54.value) = 0;
          LOBYTE(cf) = 0;
          long long v35 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v54, &cf);
          unsigned int v36 = v54.value;
          if (os_log_type_enabled(v35, (os_log_type_t)cf)) {
            unsigned int v38 = v36;
          }
          else {
            unsigned int v38 = v36 & 0xFFFFFFFE;
          }
          if (v38)
          {
            LODWORD(v62.value) = 136315650;
            *(CMTimeValue *)((char *)&v62.value + 4) = (CMTimeValue)"figTimelineCoordinator_applyRemoteTimelineStateOnQueueInternal";
            LOWORD(v62.flags) = 2112;
            *(void *)((char *)&v62.flags + 2) = v20;
            HIWORD(v62.epoch) = 2114;
            long long v63 = v34;
            long long v39 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(v36) = v54.value;
          }
          else
          {
            long long v39 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v39, v39 != &v64, v36, 0, v37);
        }
        if (v34) {
          CFRelease(v34);
        }
      }
    }
    else
    {
      if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(v20 + 216), *((const void **)v19 + 11)))
      {
        long long v28 = FigCFCopyCompactDescription((const __CFSet *)v19);
        if (dword_1E9272FB8)
        {
          LODWORD(v54.value) = 0;
          LOBYTE(type.value) = 0;
          __int16 v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v54, &type);
          unsigned int v30 = v54.value;
          if (os_log_type_enabled(v29, type.value)) {
            unsigned int v32 = v30;
          }
          else {
            unsigned int v32 = v30 & 0xFFFFFFFE;
          }
          if (v32)
          {
            LODWORD(v62.value) = 136315650;
            *(CMTimeValue *)((char *)&v62.value + 4) = (CMTimeValue)"figTimelineCoordinator_applyRemoteTimelineStateOnQueueInternal";
            LOWORD(v62.flags) = 2112;
            *(void *)((char *)&v62.flags + 2) = v20;
            HIWORD(v62.epoch) = 2114;
            long long v63 = v28;
            long long v33 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(v30) = v54.value;
          }
          else
          {
            long long v33 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v33, v33 != &v64, v30, 0, v31);
        }
        if (v28) {
          CFRelease(v28);
        }
      }
      CFDictionaryRef v50 = *(const __CFDictionary **)(v20 + 216);
      long long v51 = CFDictionaryGetValue(v50, *((const void **)v19 + 11));
      if (!v51 || figTimelineCoordinator_newTimelineStateShouldOverrideExistingState(v20, (uint64_t)v51, (uint64_t)v19))
      {
        CFDictionarySetValue(v50, *((const void **)v19 + 11), v19);
        FigCFDictionarySetInt32(*(void **)(v20 + 464), *((const void **)v19 + 11), *((_DWORD *)v19 + 25));
      }
    }
    goto LABEL_86;
  }
  if (v19) {
LABEL_86:
  }
    CFRelease(v19);
LABEL_87:
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  long long v52 = (const void *)a1[1];
  if (v52) {
    CFRelease(v52);
  }
  free(a1);
}

uint64_t FigTimelineCoordinatorHandleUpdatedParticipantStateFromMedium(dispatch_queue_t *a1, const void *a2)
{
  if (a2)
  {
    CFTypeID v5 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
    if (a1) {
      CFTypeRef v6 = CFRetain(a1);
    }
    else {
      CFTypeRef v6 = 0;
    }
    *CFTypeID v5 = v6;
    v5[1] = CFRetain(a2);
    dispatch_async_f(a1[11], v5, (dispatch_function_t)figTimelineCoordinator_handleUpdatedParticipantStateFromMediumOnQueue);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

void figTimelineCoordinator_handleUpdatedParticipantStateFromMediumOnQueue(CFDictionaryRef *a1)
{
  char v5 = 0;
  CFTypeRef cf = 0;
  uint64_t v2 = (const __CFDictionary **)*a1;
  if (!figTimelineCoordinatorParticipantCreateFromDictionary(*MEMORY[0x1E4F1CF80], a1[1], *((const void **)*a1 + 44), (uint64_t *)&cf))
  {
    figTimelineCoordinator_integrateParticipantStateOnQueue((uint64_t)v2, (uint64_t)cf, &v5);
    if (v5)
    {
      figTimelineCoordinator_postParticipantsDidChange(v2);
      figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue((uint64_t)v2);
    }
  }
  CFDictionaryRef v3 = a1[1];
  if (v3) {
    CFRelease(v3);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  if (cf) {
    CFRelease(cf);
  }
  free(a1);
}

uint64_t FigTimelineCoordinatorHandleReplacementOfAllParticipantStatesFromMedium(dispatch_queue_t *a1, const void *a2)
{
  uint64_t v4 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
  if (a2)
  {
    char v5 = v4;
    if (a1) {
      CFTypeRef v6 = CFRetain(a1);
    }
    else {
      CFTypeRef v6 = 0;
    }
    *char v5 = v6;
    v5[1] = CFRetain(a2);
    dispatch_async_f(a1[11], v5, (dispatch_function_t)figTimelineCoordinator_replaceParticipantStatesOnQueue);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

void figTimelineCoordinator_replaceParticipantStatesOnQueue(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v5 = FigCFDictionaryCopyArrayOfKeys(*((const __CFDictionary **)v2 + 41));
  CFArrayRef MutableCopy = FigCFArrayCreateMutableCopy(v3, v5);
  for (CFIndex i = 0; ; ++i)
  {
    CFArrayRef Count = *(const __CFArray **)(a1 + 8);
    if (Count) {
      CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
    }
    if (i >= (uint64_t)Count) {
      break;
    }
    char v16 = 0;
    CFTypeRef cf = 0;
    ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), i);
    if (!figTimelineCoordinatorParticipantCreateFromDictionary((int)v3, ValueAtIndex, *((const void **)v2 + 44), (uint64_t *)&cf))
    {
      int v10 = (const void *)*((void *)cf + 4);
      figTimelineCoordinator_integrateParticipantStateOnQueue((uint64_t)v2, (uint64_t)cf, &v16);
      if (v16) {
        CFArrayAppendValue(Mutable, v10);
      }
      v17.length = CFArrayGetCount(MutableCopy);
      v17.location = 0;
      FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(MutableCopy, v17, v10);
      if (FirstIndexOfValue != -1) {
        CFArrayRemoveValueAtIndex(MutableCopy, FirstIndexOfValue);
      }
      if (cf) {
        CFRelease(cf);
      }
    }
  }
  FigSimpleMutexLock(*((pthread_mutex_t **)v2 + 40));
  if (CFArrayGetCount(MutableCopy) >= 1)
  {
    CFIndex v12 = 0;
    do
    {
      CFTypeID v13 = CFArrayGetValueAtIndex(MutableCopy, v12);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)v2 + 41), v13);
      ++v12;
    }
    while (v12 < CFArrayGetCount(MutableCopy));
  }
  FigSimpleMutexUnlock(*((pthread_mutex_t **)v2 + 40));
  if (Mutable && CFArrayGetCount(Mutable) > 0 || MutableCopy && CFArrayGetCount(MutableCopy) >= 1)
  {
    figTimelineCoordinator_postParticipantsDidChange((const __CFDictionary **)v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue((uint64_t)v2);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  uint64_t v14 = *(const void **)(a1 + 8);
  if (v14) {
    CFRelease(v14);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  free((void *)a1);
}

uint64_t FigTimelineCoordinatorCoordinateRateChange(uint64_t a1, void *a2, const void *a3, float a4)
{
  CFTypeID v8 = (float *)malloc_type_malloc(0x20uLL, 0x106004058A0E50EuLL);
  if (a1) {
    CFTypeRef v9 = CFRetain((CFTypeRef)a1);
  }
  else {
    CFTypeRef v9 = 0;
  }
  *(void *)CFTypeID v8 = v9;
  if (a3) {
    CFTypeRef v10 = CFRetain(a3);
  }
  else {
    CFTypeRef v10 = 0;
  }
  *((void *)v8 + 2) = v10;
  v8[2] = a4;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v11 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v11 + 1;
  *((void *)v8 + 3) = v11;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v8, (dispatch_function_t)figTimelineCoordinator_coordinateRateChangeOnQueue);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (a2) {
    *a2 = v11;
  }
  return 0;
}

void figTimelineCoordinator_coordinateRateChangeOnQueue(char *a1)
{
  uint64_t v2 = *(void *)a1;
  CFTypeRef v30 = 0;
  __int16 v29 = 0;
  memset(&v28, 0, sizeof(v28));
  Boolean v27 = 0;
  memset(&v26, 0, sizeof(v26));
  if (!*(void *)(v2 + 352)) {
    goto LABEL_45;
  }
  FigCFDictionaryGetBooleanIfPresent(*((void *)a1 + 2), @"AlreadyPaused", (Boolean *)&v29 + 1);
  if (HIBYTE(v29)) {
    FigCFDictionaryGetCMTimeIfPresent(*((void *)a1 + 2), @"StopTime", &v26);
  }
  FigCFDictionaryGetBooleanIfPresent(*((void *)a1 + 2), @"AlreadyPrepared", (Boolean *)&v29);
  FigCFDictionaryGetBooleanIfPresent(*((void *)a1 + 2), @"SetRateImmediately", &v27);
  char v3 = v27 == 0;
  uint64_t v4 = *(void *)(v2 + 192);
  float v5 = *(float *)(v4 + 36);
  if (v5 == 0.0)
  {
    HIBYTE(v29) = 1;
    CFTypeRef v6 = (float *)(a1 + 8);
    float v7 = *((float *)a1 + 2);
    if (v7 != 0.0 && !(_BYTE)v29) {
      LOBYTE(v29) = *(float *)(v4 + 32) == v7;
    }
  }
  else
  {
    CFTypeRef v6 = (float *)(a1 + 8);
    float v7 = *((float *)a1 + 2);
  }
  int v8 = *(unsigned __int8 *)(v2 + 304);
  if (!*(unsigned char *)(v2 + 304)) {
    __int16 v29 = 0;
  }
  if (v26.flags)
  {
    *(_OWORD *)&v28.uint64_t value = *(_OWORD *)&v26.value;
    CMTimeEpoch epoch = v26.epoch;
LABEL_19:
    v28.CMTimeEpoch epoch = epoch;
    goto LABEL_20;
  }
  if (!*(void *)(v4 + 88) || v5 != 0.0 && (*(_DWORD *)(v4 + 76) & 0x1D) != 1 || (*(_DWORD *)(v4 + 52) & 0x1D) != 1)
  {
    *(_OWORD *)&v28.uint64_t value = *(_OWORD *)(v4 + 40);
    CMTimeEpoch epoch = *(void *)(v4 + 56);
    goto LABEL_19;
  }
  figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v4, (CMTime *)&kCMTimeInvalid, &v28);
  float v7 = *v6;
LABEL_20:
  if (v7 == 0.0 || (uint64_t v10 = *(void *)(v2 + 200)) != 0 && *(float *)(v10 + 36) != 0.0)
  {
    if (v7 == 0.0 && (uint64_t v14 = *(void *)(v2 + 200)) != 0 && *(float *)(v14 + 36) != 0.0)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 392));
      int v15 = *(unsigned __int8 *)(v2 + 408);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 392));
      BOOL v13 = v15 == 0;
    }
    else
    {
      BOOL v13 = 0;
    }
    char v11 = 1;
    float v12 = v7;
    float v7 = 0.0;
  }
  else
  {
    char v11 = 1;
    float v12 = 0.0;
    BOOL v13 = 0;
    if (!*(unsigned char *)(v2 + 360))
    {
      *(unsigned char *)(v2 + 360) = 1;
      char v11 = 0;
    }
  }
  uint64_t v16 = *MEMORY[0x1E4F1CF80];
  long long v18 = *(const void **)(v2 + 344);
  CFRange v17 = *(const void **)(v2 + 352);
  uint64_t v19 = *((void *)a1 + 3);
  CMTime v25 = v28;
  long long v23 = *(_OWORD *)&kCMTimeInvalid.value;
  uint64_t v24 = 0;
  if (!figTimelineCoordinatorTimelineStateCreateInternal(v7, v12, v16, v17, (long long *)&v25.value, &v23, v13, v18, v19, -1, 0, 0, (uint64_t *)&v30))
  {
    if (v12 == 0.0 && (v29 || *(float *)(*(void *)(v2 + 192) + 36) == 0.0))
    {
      int v20 = v29 != 0;
      char v21 = 1;
    }
    else
    {
      char v21 = 0;
      int v20 = 0;
    }
    if (v20 == *(_DWORD *)(v2 + 340))
    {
      if (v11) {
        goto LABEL_42;
      }
    }
    else
    {
      *(_DWORD *)(v2 + 340) = v20;
    }
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
LABEL_42:
    if (CFArrayGetCount(*(CFArrayRef *)(v2 + 432)) <= 0) {
      figTimelineCoordinator_postDidIssueSetRateCommandNotification((const void *)v2, 0, *v6);
    }
    figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v2, (uint64_t)v30, 1u, v3, 0, v8 != 0, v21, 1);
  }
LABEL_45:
  if (v30) {
    CFRelease(v30);
  }
  unsigned int v22 = (const void *)*((void *)a1 + 2);
  if (v22) {
    CFRelease(v22);
  }
  CFRelease((CFTypeRef)v2);
  free(a1);
}

uint64_t FigTimelineCoordinatorCoordinateJumpToTime(uint64_t a1, long long *a2, void *a3, const void *a4)
{
  int v8 = (char *)malloc_type_malloc(0x40uLL, 0x1060040C2398F4EuLL);
  if (a1) {
    CFTypeRef v9 = CFRetain((CFTypeRef)a1);
  }
  else {
    CFTypeRef v9 = 0;
  }
  *(void *)int v8 = v9;
  if (a4) {
    CFTypeRef v10 = CFRetain(a4);
  }
  else {
    CFTypeRef v10 = 0;
  }
  *((void *)v8 + 4) = v10;
  long long v11 = *a2;
  *((void *)v8 + 3) = *((void *)a2 + 2);
  *(_OWORD *)(v8 + 8) = v11;
  v8[48] = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v12 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v12 + 1;
  *((void *)v8 + 5) = v12;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v8, (dispatch_function_t)figTimelineCoordinator_coordinateTimeJumpDispatch);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (a3) {
    *a3 = v12;
  }
  return 0;
}

void figTimelineCoordinator_coordinateTimeJumpDispatch(char *a1)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (!a1[48])
  {
    uint64_t v4 = 0;
    goto LABEL_5;
  }
  uint64_t v3 = *((void *)a1 + 7);
  if (v3)
  {
    v2[96] = 1;
    figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue((uint64_t)v2);
    uint64_t v4 = (void *)(v3 + 8);
    *(void *)uint64_t v3 = CFRetain(v2);
    *(unsigned char *)(v3 + 20) = 1;
LABEL_5:
    uint64_t v5 = *((void *)a1 + 4);
    uint64_t v6 = *((void *)a1 + 5);
    CMTime v8 = *(CMTime *)(a1 + 8);
    figTimelineCoordinator_coordinateTimeJumpOnQueue((uint64_t)v2, &v8, 0, v5, v6, v4);
    goto LABEL_6;
  }
  FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
LABEL_6:
  float v7 = (const void *)*((void *)a1 + 4);
  if (v7) {
    CFRelease(v7);
  }
  if (v2) {
    CFRelease(v2);
  }

  free(a1);
}

uint64_t FigTimelineCoordinatorCoordinateJumpToTime2(uint64_t a1, long long *a2, void *a3, const void *a4, void *a5, void *a6)
{
  uint64_t v12 = (char *)malloc_type_malloc(0x40uLL, 0x1060040C2398F4EuLL);
  if (a1) {
    CFTypeRef v13 = CFRetain((CFTypeRef)a1);
  }
  else {
    CFTypeRef v13 = 0;
  }
  *(void *)uint64_t v12 = v13;
  long long v14 = *a2;
  *((void *)v12 + 3) = *((void *)a2 + 2);
  *(_OWORD *)(v12 + 8) = v14;
  if (a5 && a6)
  {
    int v15 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
    v15[4] = *(_DWORD *)(a1 + 100);
    v12[48] = 1;
    *((void *)v12 + 4) = 0;
    *((void *)v12 + 7) = v15;
    *a5 = figTimelineCoordinator_timelineControlCommandCompletion;
    *a6 = v15;
  }
  else
  {
    v12[48] = 0;
    if (a4) {
      CFTypeRef v16 = CFRetain(a4);
    }
    else {
      CFTypeRef v16 = 0;
    }
    *((void *)v12 + 4) = v16;
    *((void *)v12 + 7) = 0;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v17 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v17 + 1;
  *((void *)v12 + 5) = v17;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v12, (dispatch_function_t)figTimelineCoordinator_coordinateTimeJumpDispatch);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (a3) {
    *a3 = v17;
  }
  return 0;
}

void figTimelineCoordinator_timelineControlCommandCompletion(void *context, OpaqueCMTimebase *a2)
{
  if (context)
  {
    uint64_t v6 = 0;
    uint64_t v3 = *context;
    if (*context)
    {
      if (a2)
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 16));
        uint64_t v5 = *(void *)(v3 + 24);
        *(void *)(v3 + 24) = v5 + 1;
        figTimelineCoordinatorTimelineStateCreateFromTimebase(*MEMORY[0x1E4F1CF80], *(const void **)(context[1] + 88), a2, v5, &v6);
        _OWORD context[3] = v6;
        dispatch_async_f(*(dispatch_queue_t *)(*context + 88), context, (dispatch_function_t)figTimelineCoordinator_timelineControlCommandCompletionOnQueue);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 16));
      }
      else
      {
        _OWORD context[3] = 0;
        dispatch_async_f(*(dispatch_queue_t *)(v3 + 88), context, (dispatch_function_t)figTimelineCoordinator_timelineControlCommandCompletionOnQueue);
      }
    }
  }
}

uint64_t FigTimelineCoordinatorCopyParticipantSnapshotForUUID(uint64_t a1, const void *a2, void *a3)
{
  if (a1 && a2 && a3)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
    CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), a2);
    if (Value)
    {
      float v7 = Value;
      CFRetain(Value);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
      *a3 = v7;
      return 0;
    }
    else
    {
      uint64_t v9 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
      return v9;
    }
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigTimelineCoordinatorCopyParticipantSnapshots(uint64_t a1, CFArrayRef *a2)
{
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
    CFArrayRef v4 = FigCFDictionaryCopyArrayOfValues(*(const __CFDictionary **)(a1 + 328));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
    *a2 = v4;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigTimelineCoordinatorHandleRemovalOfParticipantStateFromMedium(dispatch_queue_t *a1, const void *a2)
{
  CFArrayRef v4 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
  if (a1 && a2)
  {
    uint64_t v5 = v4;
    *CFArrayRef v4 = CFRetain(a1);
    v5[1] = CFRetain(a2);
    dispatch_async_f(a1[11], v5, (dispatch_function_t)figTimelineCoordinator_removeParticipantStateOnQueue);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

void figTimelineCoordinator_removeParticipantStateOnQueue(CFTypeRef *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (uint64_t)*a1;
  if (CFDictionaryContainsKey(*((CFDictionaryRef *)*a1 + 41), a1[1]))
  {
    if (dword_1E9272FB8)
    {
      CFNumberRef Value = (const __CFSet **)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 328), a1[1]);
      CFArrayRef v4 = FigCFCopyCompactDescription(Value[2]);
      if (dword_1E9272FB8)
      {
        v12[0] = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, v12, &type);
        int v6 = v12[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v8 = v6;
        }
        else {
          unsigned int v8 = v6 & 0xFFFFFFFE;
        }
        if (v8)
        {
          v12[1] = 136315650;
          CFTypeRef v13 = "figTimelineCoordinator_removeParticipantStateOnQueue";
          __int16 v14 = 2112;
          uint64_t v15 = v2;
          __int16 v16 = 2114;
          uint64_t v17 = v4;
          uint64_t v9 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v6) = v12[0];
        }
        else
        {
          uint64_t v9 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v9, v9 != &v18, v6, 0, v7);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 320));
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 328), a1[1]);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 320));
    figTimelineCoordinator_postParticipantsDidChange((const __CFDictionary **)v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(v2);
  }
  CFTypeRef v10 = a1[1];
  if (v10) {
    CFRelease(v10);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  free(a1);
}

uint64_t FigTimelineCoordinatorCopyActiveSuspensionReasons(uint64_t a1, const __CFArray **a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFArrayRef v5 = Mutable;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 424));
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
      {
        ValueAtIndedouble x = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 424), i);
        v12.length = CFArrayGetCount(v5);
        v12.location = 0;
        if (CFArrayGetFirstIndexOfValue(v5, v12, ValueAtIndex[2]) == -1) {
          CFArrayAppendValue(v5, ValueAtIndex[2]);
        }
      }
    }
    uint64_t v10 = 0;
    if (a2) {
      *a2 = v5;
    }
  }
  else
  {
    uint64_t v10 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v10;
}

BOOL FigTimelineCoordinatorIsSuspended(uint64_t a1)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  BOOL v2 = CFArrayGetCount(*(CFArrayRef *)(a1 + 424)) > 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v2;
}

uint64_t FigTimelineCoordinatorBeginSuspension(uint64_t a1, const void *a2)
{
  return FigTimelineCoordinatorBeginSuspensionProposingTime(a1, a2, (long long *)&kCMTimeInvalid.value);
}

uint64_t FigTimelineCoordinatorBeginSuspensionProposingTime(uint64_t a1, const void *a2, long long *a3)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 424), a2);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  int v6 = malloc_type_malloc(0x30uLL, 0x10200401705F15EuLL);
  *int v6 = CFRetain((CFTypeRef)a1);
  if (a2) {
    CFTypeRef v7 = CFRetain(a2);
  }
  else {
    CFTypeRef v7 = 0;
  }
  v6[1] = v7;
  long long v8 = *a3;
  v6[4] = *((void *)a3 + 2);
  *((_OWORD *)v6 + 1) = v8;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v9 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v9 + 1;
  v6[5] = v9;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v6, (dispatch_function_t)figTimelineCoordinator_beginSuspensionOnQueue);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));

  return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
}

void figTimelineCoordinator_beginSuspensionOnQueue(uint64_t *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  BOOL v2 = (const void *)a1[1];
  CFTypeRef cf = 0;
  CFTypeRef v31 = 0;
  if (dword_1E9272FB8)
  {
    int v29 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v29, &type);
    int v5 = v29;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      uint64_t v8 = *(void *)(a1[1] + 16);
      LODWORD(time2.value) = 136315650;
      *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimelineCoordinator_beginSuspensionOnQueue";
      LOWORD(time2.flags) = 2112;
      *(void *)((char *)&time2.flags + 2) = v3;
      HIWORD(time2.epoch) = 2114;
      uint64_t v33 = v8;
      uint64_t v9 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v29;
    }
    else
    {
      uint64_t v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v9, v9 != &time1, v5, 0, v6);
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 432), v2);
  if (!*(void *)(v3 + 200)) {
    goto LABEL_28;
  }
  if (!figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(v3, (const __CFArray **)&cf)
    && !figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E4F1CF80], *(void *)(v3 + 200), &v31))
  {
    uint64_t v10 = *(CMTime **)(v3 + 200);
    long long v11 = (char *)v31;
    *((_DWORD *)v31 + 8) = v10[1].flags;
    *((_DWORD *)v11 + 9) = 0;
    CFRange v12 = (CMTime *)(v11 + 40);
    if ((*((_DWORD *)a1 + 7) & 0x1D) == 1)
    {
      long long v13 = *((_OWORD *)a1 + 1);
      *((void *)v11 + 7) = a1[4];
      *(_OWORD *)&v12->uint64_t value = v13;
    }
    else
    {
      figTimelineCoordinator_timelineTimeAtHostTime(v10, (CMTime *)&kCMTimeInvalid, &time1);
      *CFRange v12 = time1;
      long long v11 = (char *)v31;
    }
    CMTime time1 = *(CMTime *)(v11 + 40);
    *(_OWORD *)&time2.uint64_t value = *(_OWORD *)&kCMTimeZero.value;
    time2.CMTimeEpoch epoch = 0;
    int32_t v14 = CMTimeCompare(&time1, &time2);
    uint64_t v15 = v31;
    if (v14 == -1)
    {
      *(_OWORD *)((char *)v31 + 40) = *(_OWORD *)&kCMTimeZero.value;
      v15[7] = 0;
    }
    *((_OWORD *)v15 + 4) = *(_OWORD *)&kCMTimeInvalid.value;
    v15[10] = 0;
    if ((figTimelineCoordinator_everyoneIsSuspended(v3)
       || figTimelineCoordinator_groupShouldWaitForAllSuspensions(v3, (CFArrayRef)cf))
      && !figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(v3, (CFArrayRef)cf))
    {
      if (*(float *)(*(void *)(v3 + 200) + 36) != 0.0)
      {
        *(unsigned char *)(v3 + 360) = 1;
        __int16 v16 = (float *)v31;
        uint64_t v17 = v3;
        unsigned int v18 = 7;
        char v19 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      if ((!figTimelineCoordinator_everyoneIsSuspended(v3)
         || figTimelineCoordinator_groupShouldWaitForAllSuspensions(v3, (CFArrayRef)cf))
        && !figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(v3, (CFArrayRef)cf))
      {
        __int16 v16 = *(float **)(v3 + 200);
        if (v16[9] == 0.0) {
          goto LABEL_24;
        }
        if ((*((_DWORD *)a1 + 7) & 0x1D) == 1)
        {
          int v20 = *(const void **)(v3 + 208);
          CFTypeRef v21 = v31;
          *(void *)(v3 + 208) = v31;
          if (v21) {
            CFRetain(v21);
          }
          if (v20) {
            CFRelease(v20);
          }
          if (dword_1E9272FB8)
          {
            int v29 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            unsigned int v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v29, &type);
            int v23 = v29;
            if (os_log_type_enabled(v22, type)) {
              unsigned int v25 = v23;
            }
            else {
              unsigned int v25 = v23 & 0xFFFFFFFE;
            }
            if (v25)
            {
              uint64_t v26 = *(void *)(v3 + 208);
              LODWORD(time2.value) = 136315650;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimelineCoordinator_beginSuspensionOnQueue";
              LOWORD(time2.flags) = 2112;
              *(void *)((char *)&time2.flags + 2) = v3;
              HIWORD(time2.epoch) = 2112;
              uint64_t v33 = v26;
              Boolean v27 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v23) = v29;
            }
            else
            {
              Boolean v27 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v27, v27 != &time1, v23, 0, v24);
          }
        }
      }
      __int16 v16 = *(float **)(v3 + 200);
      if (v16)
      {
LABEL_24:
        uint64_t v17 = v3;
        unsigned int v18 = 2;
        char v19 = 1;
LABEL_27:
        figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v17, (uint64_t)v16, v18, 1, v19, 1, 1, 1);
      }
    }
LABEL_28:
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v3);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v31) {
    CFRelease(v31);
  }
  CFRelease((CFTypeRef)v3);
  if (v2) {
    CFRelease(v2);
  }
  free(a1);
}

uint64_t figTimelineCoordinator_postSuspensionReasonsChangedNotification(const void *a1)
{
  uint64_t value = 0;
  uint64_t active = FigTimelineCoordinatorCopyActiveSuspensionReasons((uint64_t)a1, (const __CFArray **)&value);
  if (!active)
  {
    if (figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons((uint64_t)a1, (CFArrayRef)value))
    {
      uint64_t v6 = 0;
      goto LABEL_5;
    }
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFDictionaryRef v4 = Mutable;
      CFDictionarySetValue(Mutable, @"SuspensionReasons", value);
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      uint64_t v6 = CMNotificationCenterPostNotification(DefaultLocalCenter, @"SuspensionReasonsChanged", a1, v4);
      CFRelease(v4);
      goto LABEL_5;
    }
    uint64_t active = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v6 = active;
LABEL_5:
  if (value) {
    CFRelease(value);
  }
  return v6;
}

uint64_t FigTimelineCoordinatorEndSuspensionReApplyingGroupStateOnlyIfNeeded(uint64_t a1, void *a2, char a3)
{
  values = a2;
  uint64_t result = figTimelineCoordinator_removeSuspension(a1, a2);
  if (!result)
  {
    uint64_t v6 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1) {
      CFTypeRef v7 = CFRetain((CFTypeRef)a1);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *(void *)uint64_t v6 = v7;
    *((void *)v6 + 1) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    *(_OWORD *)(v6 + 20) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(v6 + 36) = 0;
    *((_DWORD *)v6 + 11) = 2139095039;
    v6[16] = 0;
    v6[48] = a3;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v8 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v8 + 1;
    *((void *)v6 + 7) = v8;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v6, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t figTimelineCoordinator_removeSuspension(uint64_t a1, const void *a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  uint64_t v4 = figTimelineCoordinatorRemoveSuspensionInternal(a1, a2);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v4;
}

void figTimelineCoordinator_endSuspensionOnQueue(char *a1)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)a1;
  CFTypeRef cf = 0;
  uint64_t v3 = &sLoadBrowserFrameworkOnce;
  if (dword_1E9272FB8)
  {
    CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFStringAppend(Mutable, @"[");
    CFIndex v5 = 0;
    char v6 = 0;
    while (1)
    {
      CFArrayRef Count = (const __CFArray *)*((void *)a1 + 1);
      if (Count) {
        CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
      }
      if (v5 >= (uint64_t)Count) {
        break;
      }
      ValueAtIndedouble x = (CFStringRef *)CFArrayGetValueAtIndex(*((CFArrayRef *)a1 + 1), v5);
      if (CFEqual(@"PlayingInterstitial", ValueAtIndex[2])) {
        char v6 = 1;
      }
      if (v5) {
        uint64_t v9 = ", ";
      }
      else {
        uint64_t v9 = "";
      }
      CFStringAppendFormat(Mutable, 0, @"%s'%@'", v9, ValueAtIndex[2]);
      ++v5;
    }
    CFStringAppend(Mutable, @"]");
    uint64_t v3 = &sLoadBrowserFrameworkOnce;
  }
  else
  {
    char v6 = 0;
    CFMutableArrayRef Mutable = 0;
  }
  CFArrayRef v10 = (const __CFArray *)*((void *)a1 + 1);
  if (v10)
  {
    CFIndex v11 = CFArrayGetCount(*((CFArrayRef *)a1 + 1));
    if (v11 >= 1)
    {
      CFIndex v12 = v11;
      for (CFIndex i = 0; v12 != i; ++i)
      {
        int32_t v14 = CFArrayGetValueAtIndex(v10, i);
        CFArrayRef v15 = *(const __CFArray **)(v2 + 432);
        v60.length = CFArrayGetCount(v15);
        v60.location = 0;
        FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v15, v60, v14);
        if (FirstIndexOfValue == -1)
        {
          if (FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0)) {
            break;
          }
        }
        else
        {
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 432), FirstIndexOfValue);
        }
      }
    }
  }
  uint64_t v17 = a1 + 20;
  int v18 = *((_DWORD *)v3 + 1006);
  if ((*((_DWORD *)a1 + 8) & 0x1D) == 1)
  {
    if (!v18) {
      goto LABEL_43;
    }
    LODWORD(v49) = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v49, &type);
    LODWORD(v20) = v49;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v22 = v20;
    }
    else {
      unsigned int v22 = v20 & 0xFFFFFFFE;
    }
    if (v22)
    {
      if (CFArrayGetCount(*(CFArrayRef *)(v2 + 432)) >= 1) {
        int v20 = "discarding proposed";
      }
      else {
        int v20 = "proposing";
      }
      *(_OWORD *)&time.uint64_t value = *v17;
      time.CMTimeEpoch epoch = *(void *)(a1 + 36);
      Float64 Seconds = CMTimeGetSeconds(&time);
      *(_DWORD *)long long v52 = 136316162;
      *(void *)&v52[4] = "figTimelineCoordinator_endSuspensionOnQueue";
      *(_WORD *)&v52[12] = 2112;
      *(void *)&v52[14] = v2;
      *(_WORD *)&v52[22] = 2114;
      uint64_t v53 = Mutable;
      __int16 v54 = 2080;
      char v55 = v20;
      __int16 v56 = 2048;
      Float64 v57 = Seconds;
      uint64_t v24 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v20) = v49;
    }
    else
    {
      uint64_t v24 = 0;
    }
    CMTime v28 = (uint64_t *)qword_1E9272FB0;
    BOOL v29 = v24 != &time;
    char v30 = (char)v20;
  }
  else
  {
    if (!v18) {
      goto LABEL_43;
    }
    LODWORD(v49) = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    unsigned int v25 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v49, &type);
    unsigned int v26 = v49;
    if (os_log_type_enabled(v25, type)) {
      unsigned int v27 = v26;
    }
    else {
      unsigned int v27 = v26 & 0xFFFFFFFE;
    }
    if (v27)
    {
      *(_DWORD *)long long v52 = 136315650;
      *(void *)&v52[4] = "figTimelineCoordinator_endSuspensionOnQueue";
      *(_WORD *)&v52[12] = 2112;
      *(void *)&v52[14] = v2;
      *(_WORD *)&v52[22] = 2114;
      uint64_t v53 = Mutable;
      uint64_t v24 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v26) = v49;
    }
    else
    {
      uint64_t v24 = 0;
    }
    CMTime v28 = (uint64_t *)qword_1E9272FB0;
    BOOL v29 = v24 != &time;
    char v30 = v26;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(v28, 1u, 1, v24, v29, v30, 0, v21);
LABEL_43:
  if (CFArrayGetCount(*(CFArrayRef *)(v2 + 432)) > 0
    || *(unsigned char *)(v2 + 440) && !FigCFDictionaryGetCount(*(CFDictionaryRef *)(v2 + 328)))
  {
    goto LABEL_44;
  }
  uint64_t v33 = *(const void **)(v2 + 352);
  if (!v33) {
    goto LABEL_44;
  }
  float v34 = *((float *)a1 + 11);
  int v35 = *((_DWORD *)a1 + 8) & 0x1D;
  if (v34 == 3.4028e38 || v35 != 1)
  {
    if (v35 == 1)
    {
      if (!*(void *)(v2 + 200)) {
        figTimelineCoordinator_issueProposeTimelineForIdentifierOnQueue(v2);
      }
      if (!v6 || figTimelineCoordinator_othersAreSuspended(v2) || !*(void *)(v2 + 200))
      {
        uint64_t v44 = *((void *)a1 + 7);
        *(_OWORD *)&time.uint64_t value = *v17;
        time.CMTimeEpoch epoch = *(void *)(a1 + 36);
        figTimelineCoordinator_coordinateTimeJumpOnQueue(v2, &time, 1, 0, v44, 0);
LABEL_44:
        figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
        CFTypeRef v31 = cf;
        goto LABEL_45;
      }
    }
    else if (!a1[48] {
           && (*(void *)(v2 + 200) || !*(unsigned char *)(v2 + 281))
    }
           && figTimelineCoordinator_othersAreSuspended(v2))
    {
      if (figTimelineCoordinator_othersAreSuspended(v2)) {
        *(unsigned char *)(v2 + 360) = 1;
      }
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v49 = 0;
    if (!*(void *)(v2 + 200) || !a1[16]) {
      goto LABEL_61;
    }
    if (figTimelineCoordinator_othersAreSuspended(v2))
    {
      uint64_t v33 = *(const void **)(v2 + 352);
      float v34 = *((float *)a1 + 11);
LABEL_61:
      uint64_t v36 = *MEMORY[0x1E4F1CF80];
      uint64_t v37 = *(const void **)(v2 + 344);
      uint64_t v38 = *((void *)a1 + 7);
      *(_OWORD *)&time.uint64_t value = *v17;
      time.CMTimeEpoch epoch = *(void *)(a1 + 36);
      memset(v52, 0, sizeof(v52));
      if (figTimelineCoordinatorTimelineStateCreateInternal(v34, 0.0, v36, v33, (long long *)&time.value, (long long *)v52, 0, v37, v38, -1, 0, 0, &v49))goto LABEL_47; {
      *(unsigned char *)(v2 + 360) = 1;
      }
      figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
      uint64_t v39 = v49;
      uint64_t v40 = v2;
      unsigned int v41 = 8;
      char v42 = 0;
      char v43 = 1;
LABEL_78:
      figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v40, v39, v41, 1, v42, 0, v43, 1);
      goto LABEL_44;
    }
  }
  uint64_t v45 = *(void *)(v2 + 200);
  if (!v45)
  {
    if (*(void *)(v2 + 352)) {
      figTimelineCoordinator_issueProposeTimelineForIdentifierOnQueue(v2);
    }
    goto LABEL_44;
  }
  int v46 = figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E4F1CF80], v45, &cf);
  CFTypeRef v31 = cf;
  if (!v46)
  {
    *((void *)cf + 2) = *((void *)a1 + 7);
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 184));
    unsigned int v47 = *(const void **)(v2 + 200);
    CFTypeRef v48 = cf;
    *(void *)(v2 + 200) = cf;
    if (v48) {
      CFRetain(v48);
    }
    if (v47) {
      CFRelease(v47);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 184));
    uint64_t v39 = *(void *)(v2 + 200);
    if (!v39) {
      goto LABEL_44;
    }
    uint64_t v40 = v2;
    unsigned int v41 = 5;
    char v42 = 1;
    char v43 = 0;
    goto LABEL_78;
  }
LABEL_45:
  if (v31) {
    CFRelease(v31);
  }
LABEL_47:
  CFRelease((CFTypeRef)v2);
  unsigned int v32 = (const void *)*((void *)a1 + 1);
  if (v32) {
    CFRelease(v32);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  free(a1);
}

uint64_t FigTimelineCoordinatorEndSuspensionProposingNewTime(uint64_t a1, void *a2, uint64_t a3)
{
  values = a2;
  uint64_t result = figTimelineCoordinator_removeSuspension(a1, a2);
  if (!result)
  {
    char v6 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1) {
      CFTypeRef v7 = CFRetain((CFTypeRef)a1);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *(void *)char v6 = v7;
    *((void *)v6 + 1) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    uint64_t v8 = *(void *)(a3 + 16);
    *(_OWORD *)(v6 + 20) = *(_OWORD *)a3;
    *(void *)(v6 + 36) = v8;
    *((_DWORD *)v6 + 11) = 2139095039;
    v6[16] = 0;
    v6[48] = 1;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v9 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v9 + 1;
    *((void *)v6 + 7) = v9;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v6, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t FigTimelineCoordinatorEndSuspensionWeaklyIfNeededProposingNewRateAndTime(uint64_t a1, const void **a2, uint64_t a3, float a4)
{
  values = a2;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
  CFNumberRef Value = FigCFDictionaryGetValue(*(const void **)(a1 + 400), a2[2]);
  uint64_t v9 = FigCFDictionaryGetValue(Value, @"ShouldWait");
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
  uint64_t result = figTimelineCoordinator_removeSuspension(a1, a2);
  if (!result)
  {
    BOOL v11 = v9 != (const void *)*MEMORY[0x1E4F1CFD0];
    CFIndex v12 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    *(void *)CFIndex v12 = CFRetain((CFTypeRef)a1);
    *((void *)v12 + 1) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    uint64_t v13 = *(void *)(a3 + 16);
    *(_OWORD *)(v12 + 20) = *(_OWORD *)a3;
    *(void *)(v12 + 36) = v13;
    *((float *)v12 + 11) = a4;
    v12[16] = v11;
    v12[48] = 1;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v14 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v14 + 1;
    *((void *)v12 + 7) = v14;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v12, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t FigTimelineCoordinatorEndSuspension(uint64_t a1, void *a2)
{
  return FigTimelineCoordinatorEndSuspensionProposingNewTime(a1, a2, (uint64_t)&kCMTimeInvalid);
}

uint64_t FigTimelineCoordinatorEndSuspensionsProposingNewTime(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  if (!theArray || CFArrayGetCount(theArray) < 1) {
    return 0;
  }
  uint64_t result = figTimelineCoordinator_removeSuspensions(a1, theArray);
  if (!result)
  {
    CFTypeRef v7 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1) {
      CFTypeRef v8 = CFRetain((CFTypeRef)a1);
    }
    else {
      CFTypeRef v8 = 0;
    }
    *(void *)CFTypeRef v7 = v8;
    *((void *)v7 + 1) = CFRetain(theArray);
    uint64_t v9 = *(void *)(a3 + 16);
    *(_OWORD *)(v7 + 20) = *(_OWORD *)a3;
    *(void *)(v7 + 36) = v9;
    *((_DWORD *)v7 + 11) = 2139095039;
    v7[16] = 0;
    v7[48] = 1;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v10 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v10 + 1;
    *((void *)v7 + 7) = v10;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v7, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t figTimelineCoordinator_removeSuspensions(uint64_t a1, const __CFArray *a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  if (a2 && (CFIndex Count = CFArrayGetCount(a2), Count >= 1))
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    while (1)
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex(a2, v6);
      uint64_t v8 = figTimelineCoordinatorRemoveSuspensionInternal(a1, ValueAtIndex);
      if (v8) {
        break;
      }
      if (v5 == ++v6) {
        goto LABEL_6;
      }
    }
    uint64_t v9 = v8;
  }
  else
  {
LABEL_6:
    uint64_t v9 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v9;
}

uint64_t FigTimelineCoordinatorEndSuspensions(uint64_t a1, CFArrayRef theArray)
{
  if (!theArray || CFArrayGetCount(theArray) < 1) {
    return 0;
  }
  uint64_t result = figTimelineCoordinator_removeSuspensions(a1, theArray);
  if (!result)
  {
    CFIndex v5 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1) {
      CFTypeRef v6 = CFRetain((CFTypeRef)a1);
    }
    else {
      CFTypeRef v6 = 0;
    }
    *(void *)CFIndex v5 = v6;
    *((void *)v5 + 1) = CFRetain(theArray);
    *(_OWORD *)(v5 + 20) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(v5 + 36) = 0;
    *((_DWORD *)v5 + 11) = 2139095039;
    v5[16] = 0;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v7 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v7 + 1;
    *((void *)v5 + 7) = v7;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v5, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t FigTimelineCoordinatorGetExpectedGroupTimeForIdentifier(uint64_t a1, const void *a2, CMTime *a3)
{
  theArradouble y = 0;
  if (a1)
  {
    if (a2 && a3)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
      CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 216), a2);
      if (Value) {
        uint64_t v7 = (CMTime *)CFRetain(Value);
      }
      else {
        uint64_t v7 = 0;
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
      uint64_t v8 = FigTimelineCoordinatorCopyParticipantSnapshots(a1, &theArray);
      if (v8)
      {
        uint64_t v13 = v8;
        if (!v7) {
          goto LABEL_21;
        }
      }
      else
      {
        CFIndex v9 = 0;
        while (1)
        {
          CFIndex Count = (CFIndex)theArray;
          if (theArray) {
            CFIndex Count = CFArrayGetCount(theArray);
          }
          if (v9 >= Count) {
            break;
          }
          ValueAtIndedouble x = (const __CFDictionary **)CFArrayGetValueAtIndex(theArray, v9);
          CFIndex v12 = participantState_timelineIdentifier(ValueAtIndex[2]);
          ++v9;
          if (FigCFEqual(a2, v12))
          {
            if (v7
              && v7[3].epoch
              && (*(float *)&v7[1].flags == 0.0 || (HIDWORD(v7[3].value) & 0x1D) == 1)
              && (HIDWORD(v7[2].value) & 0x1D) == 1)
            {
              figTimelineCoordinator_timelineTimeAtHostTime(v7, (CMTime *)&kCMTimeInvalid, &v15);
              uint64_t v13 = 0;
              *a3 = v15;
              goto LABEL_20;
            }
            break;
          }
        }
        uint64_t v13 = 0;
        *(_OWORD *)&a3->uint64_t value = *(_OWORD *)&kCMTimeInvalid.value;
        a3->CMTimeEpoch epoch = 0;
        if (!v7) {
          goto LABEL_21;
        }
      }
LABEL_20:
      CFRelease(v7);
    }
    else
    {
      uint64_t v13 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    }
LABEL_21:
    if (theArray) {
      CFRelease(theArray);
    }
    return v13;
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorGetExpectedTimeAtHostTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  memset(&v9, 0, sizeof(v9));
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
  CFTypeRef v6 = *(CMTime **)(a1 + 200);
  if (v6)
  {
    CFRetain(*(CFTypeRef *)(a1 + 200));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
    CMTime v8 = *a2;
    figTimelineCoordinator_timelineTimeAtHostTime(v6, &v8, &v9);
    if (!a3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
  if (a3) {
LABEL_3:
  }
    *a3 = v9;
LABEL_4:
  if (v6) {
    CFRelease(v6);
  }
  return 0;
}

CMTime *figTimelineCoordinator_timelineTimeAtHostTime@<X0>(CMTime *result@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  *(_OWORD *)&a3->uint64_t value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->CMTimeEpoch epoch = 0;
  if (result[3].epoch)
  {
    uint64_t v4 = result;
    float v5 = *(float *)&result[1].flags;
    if ((v5 == 0.0 || (HIDWORD(result[3].value) & 0x1D) == 1) && (HIDWORD(result[2].value) & 0x1D) == 1)
    {
      *(_OWORD *)&a3->uint64_t value = *(_OWORD *)&result[1].epoch;
      a3->CMTimeEpoch epoch = *(void *)&result[2].timescale;
      if (v5 != 0.0)
      {
        p_CMTimeEpoch epoch = &result[1].epoch;
        memset(&v12, 0, sizeof(v12));
        if ((a2->flags & 0x1D) == 1)
        {
          CMTime v12 = *a2;
        }
        else
        {
          HostTimeClocuint64_t k = CMClockGetHostTimeClock();
          CMClockGetTime(&v12, HostTimeClock);
        }
        CMTime lhs = v12;
        CMTime v8 = *(CMTime *)((char *)v4 + 64);
        CMTimeSubtract(&time, &lhs, &v8);
        CMTimeMultiplyByFloat64(&rhs, &time, *(float *)&v4[1].flags);
        *(_OWORD *)&lhs.uint64_t value = *(_OWORD *)p_epoch;
        lhs.CMTimeEpoch epoch = *(void *)&v4[2].timescale;
        return CMTimeAdd(a3, &lhs, &rhs);
      }
    }
  }
  return result;
}

uint64_t FigTimelineCoordinatorResetGroupTimelineExpectations(uint64_t a1)
{
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 216));
  uint64_t v2 = *(const void **)(a1 + 200);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 200) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 208);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 208) = 0;
  }
  *(unsigned char *)(a1 + 281) = 1;
  return 0;
}

uint64_t FigTimelineCoordinatorSetWeakMediumAndCallbacks(dispatch_queue_t *a1, uint64_t a2, void *a3)
{
  if (!*a3 && a3[4] && a3[2] && a3[3])
  {
    CFTypeRef v6 = malloc_type_malloc(0x38uLL, 0x10A004042A389E2uLL);
    if (a1) {
      CFTypeRef v7 = CFRetain(a1);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *CFTypeRef v6 = v7;
    __copy_assignment_8_8_t0w16_pa0_12868_16_pa0_63777_24_pa0_904_32((uint64_t)(v6 + 1), (uint64_t)a3);
    _OWORD v6[6] = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
    dispatch_async_f(a1[11], v6, (dispatch_function_t)figTimelineCoordinator_setMediumCallbacksOnQueue);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t __copy_assignment_8_8_t0w16_pa0_12868_16_pa0_63777_24_pa0_904_32(uint64_t result, uint64_t a2)
{
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

void figTimelineCoordinator_setMediumCallbacksOnQueue(void *a1)
{
  uint64_t v2 = (void *)*a1;
  __copy_assignment_8_8_t0w16_pa0_12868_16_pa0_63777_24_pa0_904_32(*a1 + 120, (uint64_t)(a1 + 1));
  uint64_t v3 = (const void *)v2[20];
  uint64_t v4 = (const void *)a1[6];
  v2[20] = v4;
  if (v4) {
    CFRetain(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
  figTimelineCoordinator_resetGroupExpectationsOnQueue((uint64_t)v2);
  CFRelease(v2);
  float v5 = (const void *)a1[6];
  if (v5) {
    CFRelease(v5);
  }

  free(a1);
}

uint64_t FigTimelineCoordinatorHandleAssignmentOfUUIDToLocalParticipantByMedium(dispatch_queue_t *a1, const void *a2)
{
  uint64_t v4 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
  if (a1) {
    CFTypeRef v5 = CFRetain(a1);
  }
  else {
    CFTypeRef v5 = 0;
  }
  *uint64_t v4 = v5;
  if (a2) {
    CFTypeRef v6 = CFRetain(a2);
  }
  else {
    CFTypeRef v6 = 0;
  }
  v4[1] = v6;
  dispatch_async_f(a1[11], v4, (dispatch_function_t)figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue);
  return 0;
}

void figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue(uint64_t *a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (*(void *)(*a1 + 344))
  {
    if (!v2)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 168));
      uint64_t v4 = *(const void **)(v3 + 176);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(v3 + 176) = 0;
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 168));
    }
  }
  else if (v2)
  {
    if (!*(void *)(v3 + 176))
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 504));
      int v5 = figTimelineCoordinator_setNetworkToHostTimeOffset(v3);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 504));
      if (v5 || !*(void *)(v3 + 176))
      {
        int v22 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 0, &v22, &type);
        int v7 = v22;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v9 = v7;
        }
        else {
          unsigned int v9 = v7 & 0xFFFFFFFE;
        }
        if (v9)
        {
          int v23 = 136315394;
          uint64_t v24 = "figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue";
          __int16 v25 = 1024;
          int v26 = v5;
          uint64_t v10 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v7) = v22;
        }
        else
        {
          uint64_t v10 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 0, 1, v10, v10 != v27, v7, 0, v8);
      }
    }
  }
  BOOL v11 = *(const void **)(v3 + 344);
  CMTime v12 = (const void *)a1[1];
  *(void *)(v3 + 344) = v12;
  if (v12) {
    CFRetain(v12);
  }
  if (v11) {
    CFRelease(v11);
  }
  int v13 = figTimelineCoordinator_resetGroupExpectationsOnQueue(v3);
  if (v13)
  {
    int v14 = v13;
    int v22 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    CMTime v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 0, &v22, &type);
    int v16 = v22;
    if (os_log_type_enabled(v15, type)) {
      unsigned int v18 = v16;
    }
    else {
      unsigned int v18 = v16 & 0xFFFFFFFE;
    }
    if (v18)
    {
      int v23 = 136315394;
      uint64_t v24 = "figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue";
      __int16 v25 = 1024;
      int v26 = v14;
      char v19 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v16) = v22;
    }
    else
    {
      char v19 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 0, 1, v19, v19 != v27, v16, 0, v17);
  }
  CFRelease((CFTypeRef)v3);
  int v20 = (const void *)a1[1];
  if (v20) {
    CFRelease(v20);
  }
  free(a1);
}

uint64_t FigTimelineCoordinatorDisconnectFromMedium()
{
  return 0;
}

uint64_t FigTimelineCoordinatorReapplyGroupStateViaTimelineControl(dispatch_queue_t *a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x10200405F07FB98uLL);
  if (a1) {
    CFTypeRef v3 = CFRetain(a1);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *(void *)uint64_t v2 = v3;
  v2[8] = 1;
  dispatch_async_f(a1[11], v2, (dispatch_function_t)figTimelineCoordinator_reapplyExpectedTimelineDispatch);
  return 0;
}

void figTimelineCoordinator_reapplyExpectedTimelineDispatch(uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  figTimelineCoordinator_reapplyExpectedTimelineOnQueue(*(void *)a1, *(unsigned __int8 *)(a1 + 8), 2u);
  if (v2) {
    CFRelease(v2);
  }

  free((void *)a1);
}

uint64_t FigTimelineCoordinatorHandleTransitionToNewTimelineFromTimelineControl(uint64_t a1, const void *a2, OpaqueCMTimebase *a3)
{
  CFTypeRef cf = 0;
  if (!a2)
  {
    uint64_t v10 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
    int v11 = 0;
    if (!a1)
    {
      CFTypeRef v12 = 0;
      goto LABEL_8;
    }
LABEL_7:
    CFTypeRef v12 = CFRetain((CFTypeRef)a1);
LABEL_8:
    *uint64_t v10 = v12;
    CFTypeRef v9 = cf;
    if (cf) {
      CFTypeRef v13 = CFRetain(cf);
    }
    else {
      CFTypeRef v13 = 0;
    }
    v10[1] = v13;
    *((unsigned char *)v10 + 16) = 0;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v10, (dispatch_function_t)figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue);
    uint64_t v8 = 0;
    uint64_t v14 = 0;
    if (!v11) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v6 + 1;
  uint64_t v7 = figTimelineCoordinatorTimelineStateCreateFromTimebase(*MEMORY[0x1E4F1CF80], a2, a3, v6, &cf);
  if (!v7)
  {
    uint64_t v10 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
    int v11 = 1;
    goto LABEL_7;
  }
  uint64_t v8 = v7;
  CFTypeRef v9 = cf;
LABEL_12:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v14 = v8;
LABEL_13:
  if (v9) {
    CFRelease(v9);
  }
  return v14;
}

uint64_t figTimelineCoordinatorTimelineStateCreateFromTimebase(uint64_t a1, const void *a2, CMTimebaseRef timebase, uint64_t a4, void *a5)
{
  CFTypeRef v19 = 0;
  memset(&v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  float Rate = 0.0;
  if (a2)
  {
    if (timebase)
    {
      float Rate = CMTimebaseGetRate(timebase);
      if (CMTimebaseGetEffectiveRate(timebase) == 0.0)
      {
        CMTimebaseGetTime(&v18, timebase);
      }
      else
      {
        HostTimeClocuint64_t k = CMClockGetHostTimeClock();
        CMClockGetTime(&v17, HostTimeClock);
        CMClockRef v12 = CMClockGetHostTimeClock();
        CMTime time = v17;
        CMSyncConvertTime(&v18, &time, v12, timebase);
      }
    }
    else
    {
      *(_OWORD *)&v18.uint64_t value = *(_OWORD *)&kCMTimeZero.value;
      v18.CMTimeEpoch epoch = 0;
      memset(&v17, 0, sizeof(v17));
    }
  }
  CMTime time = v18;
  CMTime v15 = v17;
  uint64_t Internal = figTimelineCoordinatorTimelineStateCreateInternal(0.0, Rate, a1, a2, (long long *)&time.value, (long long *)&v15.value, 0, 0, a4, -1, 0, 1, (uint64_t *)&v19);
  if (Internal)
  {
    if (v19) {
      CFRelease(v19);
    }
  }
  else
  {
    *a5 = v19;
  }
  return Internal;
}

void figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue(uint64_t *a1)
{
  long long v1 = a1;
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  CFTypeRef v3 = (void *)a1[1];
  char v86 = 0;
  char v4 = *(unsigned char *)(v2 + 360);
  CFTypeRef v85 = 0;
  char v79 = v4;
  if (v3) {
    CFStringRef v5 = (const __CFString *)v3[11];
  }
  else {
    CFStringRef v5 = 0;
  }
  if (dword_1E9272FB8)
  {
    int v88 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v88, &type);
    int v7 = v88;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v9 = v7;
    }
    else {
      unsigned int v9 = v7 & 0xFFFFFFFE;
    }
    if (v9)
    {
      int v89 = 136315650;
      double v90 = "figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue";
      __int16 v91 = 2112;
      uint64_t v92 = v2;
      __int16 v93 = 2114;
      CFStringRef v94 = v5;
      uint64_t v10 = (const __CFString **)_os_log_send_and_compose_impl();
      LOBYTE(v7) = v88;
    }
    else
    {
      uint64_t v10 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v10, v10 != &context, v7, 0, v8);
  }
  int v82 = FigCFEqual(v5, *(CFTypeRef *)(v2 + 352));
  int v11 = *(const void **)(v2 + 296);
  *(void *)(v2 + 296) = v3;
  if (v3) {
    CFRetain(v3);
  }
  if (v11) {
    CFRelease(v11);
  }
  *(void *)(v2 + 336) = 0;
  *(unsigned char *)(v2 + 360) = 0;
  CMClockRef v12 = *(const void **)(v2 + 368);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(v2 + 368) = 0;
  }
  CFTypeRef v13 = *(const void **)(v2 + 352);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(v2 + 352) = 0;
  }
  uint64_t v81 = (uint64_t)v3;
  figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(v2, (const __CFArray **)&v85);
  if (figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(v2, (CFArrayRef)v85))
  {
    if (dword_1E9272FB8)
    {
      int v88 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v88, &type);
      int v15 = v88;
      if (os_log_type_enabled(v14, type)) {
        unsigned int v17 = v15;
      }
      else {
        unsigned int v17 = v15 & 0xFFFFFFFE;
      }
      if (v17)
      {
        int v89 = 136315394;
        double v90 = "figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue";
        __int16 v91 = 2112;
        uint64_t v92 = v2;
        CMTime v18 = (const __CFString **)_os_log_send_and_compose_impl();
        LOBYTE(v15) = v88;
      }
      else
      {
        CMTime v18 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v18, v18 != &context, v15, 0, v16);
    }
  }
  else
  {
    long long v76 = v1;
    CFStringRef v77 = v5;
    CFArrayRef cf = FigCFDictionaryCopyArrayOfKeys(*(const __CFDictionary **)(v2 + 216));
    CFArrayRef MutableCopy = FigCFArrayCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], cf);
    CFArrayRef v20 = FigCFDictionaryCopyArrayOfValues(*(const __CFDictionary **)(v2 + 328));
    figTimelineCoordinator_removeValueFromArray(MutableCopy, *(const void **)(v2 + 352));
    CFIndex v21 = 0;
    do
    {
      if (v20) {
        CFIndex Count = CFArrayGetCount(v20);
      }
      else {
        CFIndex Count = 0;
      }
      if (v21 >= Count) {
        break;
      }
      ValueAtIndedouble x = (const __CFDictionary **)CFArrayGetValueAtIndex(v20, v21);
      uint64_t v24 = participantState_timelineIdentifier(ValueAtIndex[2]);
      if (figTimelineCoordinator_removeValueFromArray(MutableCopy, v24)) {
        BOOL v25 = dword_1E9272FB8 == 0;
      }
      else {
        BOOL v25 = 1;
      }
      if (!v25)
      {
        int v88 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        int v26 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v88, &type);
        int v27 = v88;
        if (os_log_type_enabled(v26, type)) {
          unsigned int v29 = v27;
        }
        else {
          unsigned int v29 = v27 & 0xFFFFFFFE;
        }
        if (v29)
        {
          CFStringRef StateLoggingIdentifier = (const __CFString *)FigParticipantStateDictionaryGetStateLoggingIdentifier(ValueAtIndex[2]);
          int v89 = 136315906;
          double v90 = "figTimelineCoordinator_removeUnusedExpectations";
          __int16 v91 = 2112;
          uint64_t v92 = v2;
          __int16 v93 = 2112;
          CFStringRef v94 = StateLoggingIdentifier;
          __int16 v95 = 2112;
          double v96 = v24;
          CFTypeRef v31 = (const __CFString **)_os_log_send_and_compose_impl();
          LOBYTE(v27) = v88;
        }
        else
        {
          CFTypeRef v31 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v31, v31 != &context, v27, 0, v28);
      }
      if (!MutableCopy) {
        break;
      }
      ++v21;
    }
    while (CFArrayGetCount(MutableCopy));
    CFIndex v32 = 0;
    if (!MutableCopy) {
      goto LABEL_47;
    }
LABEL_46:
    for (CFIndex i = CFArrayGetCount(MutableCopy); v32 < i; CFIndex i = 0)
    {
      CFStringRef v34 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v32);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 216), v34);
      if (dword_1E9272FB8)
      {
        int v88 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        int v35 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v88, &type);
        int v36 = v88;
        if (os_log_type_enabled(v35, type)) {
          unsigned int v38 = v36;
        }
        else {
          unsigned int v38 = v36 & 0xFFFFFFFE;
        }
        if (v38)
        {
          int v89 = 136315650;
          double v90 = "figTimelineCoordinator_removeUnusedExpectations";
          __int16 v91 = 2112;
          uint64_t v92 = v2;
          __int16 v93 = 2112;
          CFStringRef v94 = v34;
          uint64_t v39 = (const __CFString **)_os_log_send_and_compose_impl();
          LOBYTE(v36) = v88;
        }
        else
        {
          uint64_t v39 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v39, v39 != &context, v36, 0, v37);
      }
      ++v32;
      if (MutableCopy) {
        goto LABEL_46;
      }
LABEL_47:
      ;
    }
    if (cf) {
      CFRelease(cf);
    }
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    long long v1 = v76;
    CFStringRef v5 = v77;
    if (v20) {
      CFRelease(v20);
    }
  }
  uint64_t v40 = *(const void **)(v2 + 352);
  *(void *)(v2 + 352) = v5;
  if (v5) {
    CFRetain(v5);
  }
  unsigned int v41 = (const void *)v81;
  if (v40) {
    CFRelease(v40);
  }
  if (!v5 || (CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 216), v5)) == 0)
  {
    if (!v82)
    {
      *(unsigned char *)(v2 + 280) = *(unsigned char *)(v2 + 281) != 0;
      LODWORD(context) = 0;
      if (v5)
      {
        CFArrayRef v55 = FigCFDictionaryCopyArrayOfValues(*(const __CFDictionary **)(v2 + 328));
        if (v55)
        {
          CFArrayRef v56 = v55;
          if (CFArrayGetCount(v55) < 1)
          {
LABEL_91:
            CFRelease(v56);
          }
          else
          {
            CFIndex v57 = 0;
            while (1)
            {
              uint64_t v58 = (const __CFDictionary **)CFArrayGetValueAtIndex(v56, v57);
              CFStringRef v59 = (const __CFString *)participantState_timelineIdentifier(v58[2]);
              if (v59)
              {
                if (CFEqual(v5, v59)) {
                  break;
                }
              }
              if (++v57 >= CFArrayGetCount(v56)) {
                goto LABEL_91;
              }
            }
            CFRelease(v56);
            if (CFDictionaryContainsKey(*(CFDictionaryRef *)(v2 + 464), v5)) {
              FigCFDictionaryGetInt32IfPresent(*(void *)(v2 + 464), v5, &context);
            }
          }
        }
      }
      int v60 = (int)context;
      *(_DWORD *)(v2 + 456) = context;
      if (v81 && *(float *)(v81 + 32) != 0.0)
      {
        *(_DWORD *)(v2 + 456) = v60 + 1;
        FigCFDictionarySetInt32(*(void **)(v2 + 464), v5, v60 + 1);
      }
    }
    char v51 = 1;
    *(unsigned char *)(v2 + 304) = 1;
    char v86 = 1;
    if (v81)
    {
      char v43 = 0;
      if (*(float *)(v81 + 32) != 0.0)
      {
        char v47 = 0;
        char v53 = 0;
        char v54 = 1;
        char v50 = 1;
        uint64_t v52 = v81;
        BOOL v46 = 1;
        BOOL v49 = 1;
        if (*(float *)(v81 + 36) != 0.0) {
          goto LABEL_98;
        }
        goto LABEL_83;
      }
      char v53 = 0;
      uint64_t v52 = v81;
    }
    else
    {
      char v43 = 0;
      uint64_t v52 = 0;
      char v53 = 0;
    }
    BOOL v46 = 1;
    BOOL v49 = 1;
    goto LABEL_98;
  }
  char v43 = Value;
  *((void *)Value + 2) = *(void *)(v81 + 16);
  float v44 = *((float *)Value + 9);
  float v45 = *(float *)(v81 + 36);
  if (v44 == 0.0) {
    float v44 = *((float *)Value + 8);
  }
  if (v45 == 0.0) {
    float v45 = *(float *)(v81 + 32);
  }
  BOOL v46 = v45 == v44;
  char v47 = 1;
  *(unsigned char *)(v2 + 280) = 1;
  int v48 = *((_DWORD *)Value + 25);
  *(_DWORD *)(v2 + 456) = v48;
  FigCFDictionarySetInt32(*(void **)(v2 + 464), *((const void **)Value + 11), v48);
  CMTimeMake(&v84, 1, 10);
  BOOL v49 = figTimelineCoordinator_timelinesMatch(v81, (uint64_t)v43, &v84, &v86);
  char v50 = 0;
  char v51 = 0;
  *(unsigned char *)(v2 + 304) = v49;
  uint64_t v52 = (uint64_t)v43;
  char v53 = 1;
  char v54 = v79;
  if (v82)
  {
LABEL_83:
    *(unsigned char *)(v2 + 360) = v54;
    char v51 = v50;
    char v53 = v47;
  }
LABEL_98:
  if (*((unsigned char *)v1 + 16)) {
    *(_DWORD *)(v2 + 340) = 1;
  }
  if (v52)
  {
    char v80 = v49;
    char v83 = v46;
    CFIndex v61 = CFArrayGetCount(*(CFArrayRef *)(v2 + 432));
    if (v61 >= 1 && dword_1E9272FB8)
    {
      CFStringRef v78 = v5;
      int v88 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      CMTime v62 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v88, &type);
      int v63 = v88;
      if (os_log_type_enabled(v62, type)) {
        unsigned int v65 = v63;
      }
      else {
        unsigned int v65 = v63 & 0xFFFFFFFE;
      }
      if (v65)
      {
        int v89 = 136315394;
        double v90 = "figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue";
        __int16 v91 = 2112;
        uint64_t v92 = v2;
        CGFloat v66 = (const __CFString **)_os_log_send_and_compose_impl();
        LOBYTE(v63) = v88;
      }
      else
      {
        CGFloat v66 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v66, v66 != &context, v63, 0, v64);
      CFStringRef v5 = v78;
      unsigned int v41 = (const void *)v81;
    }
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 184));
    double v70 = *(const void **)(v2 + 192);
    *(void *)(v2 + 192) = v41;
    if (v41) {
      CFRetain(v41);
    }
    if (v70) {
      CFRelease(v70);
    }
    long long v71 = *(const void **)(v2 + 200);
    *(void *)(v2 + 200) = v43;
    if ((v51 & 1) == 0) {
      CFRetain(v43);
    }
    if (v71) {
      CFRelease(v71);
    }
    long long v72 = *(const void **)(v2 + 208);
    if (v72)
    {
      CFRelease(v72);
      *(void *)(v2 + 208) = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 184));
    if (v61 <= 0) {
      figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v2, v52, 6u, 1, v53, v86, v80, v83);
    }
  }
  else
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 184));
    CFTypeRef v67 = *(const void **)(v2 + 200);
    if (v67)
    {
      CFRelease(v67);
      *(void *)(v2 + 200) = 0;
    }
    CFTypeRef v68 = *(const void **)(v2 + 192);
    if (v68)
    {
      CFRelease(v68);
      *(void *)(v2 + 192) = 0;
    }
    double v69 = *(const void **)(v2 + 208);
    if (v69)
    {
      CFRelease(v69);
      *(void *)(v2 + 208) = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 184));
  }
  if (!v82)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFStringRef context = v5;
    uint64_t v98 = 0;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(v2 + 328), (CFDictionaryApplierFunction)figTimelineCoordinator_updateParticipantsWithNewLocalIdentifierApply, &context);
    if ((_BYTE)v98) {
      figTimelineCoordinator_postParticipantsDidChange((const __CFDictionary **)v2);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
  }
  if (*v1) {
    CFRelease((CFTypeRef)*v1);
  }
  long long v74 = (const void *)v1[1];
  if (v74) {
    CFRelease(v74);
  }
  if (v85) {
    CFRelease(v85);
  }
  free(v1);
}

uint64_t FigTimelineCoordinatorHandleTransitionToNewTimelineFromTimelineControlProposingTimeAndPrerollRate(uint64_t a1, const void *a2, uint64_t a3, char a4, float a5)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    uint64_t v10 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v10 + 1;
    uint64_t v11 = *MEMORY[0x1E4F1CF80];
    CMClockRef v12 = *(const void **)(a1 + 344);
    long long v20 = *(_OWORD *)a3;
    uint64_t v21 = *(void *)(a3 + 16);
    long long v18 = *(_OWORD *)&kCMTimeInvalid.value;
    uint64_t v19 = 0;
    uint64_t v13 = figTimelineCoordinatorTimelineStateCreateInternal(a5, 0.0, v11, a2, &v20, &v18, 0, v12, v10, -1, 0, 1, (uint64_t *)&cf);
    uint64_t v14 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
LABEL_4:
    CFTypeRef v15 = CFRetain((CFTypeRef)a1);
    goto LABEL_5;
  }
  uint64_t v14 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
  uint64_t v13 = 0;
  if (a1) {
    goto LABEL_4;
  }
  CFTypeRef v15 = 0;
LABEL_5:
  *uint64_t v14 = v15;
  CFTypeRef v16 = cf;
  if (cf) {
    CFTypeRef v16 = CFRetain(cf);
  }
  v14[1] = v16;
  *((unsigned char *)v14 + 16) = a4;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v14, (dispatch_function_t)figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue);
  if (a2) {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }
  if (cf) {
    CFRelease(cf);
  }
  return v13;
}

uint64_t figTimelineCoordinatorTimelineStateCreateInternal(float a1, float a2, uint64_t a3, const void *a4, long long *a5, long long *a6, int a7, const void *a8, uint64_t a9, int a10, char a11, char a12, uint64_t *a13)
{
  if (!a13) {
    goto LABEL_19;
  }
  if (a4)
  {
    if (a2 == 0.0)
    {
      if (*((unsigned char *)a6 + 12))
      {
        *a6 = *(_OWORD *)&kCMTimeInvalid.value;
        *((void *)a6 + 2) = 0;
      }
      goto LABEL_9;
    }
    if (a12 && ((*((_DWORD *)a6 + 3) & 0x1D) != 1 || (*((_DWORD *)a5 + 3) & 0x1D) != 1))
    {
LABEL_19:
      uint64_t v29 = 4294951585;
      goto LABEL_21;
    }
  }
LABEL_9:
  if (FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce != -1) {
    dispatch_once_f(&FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorTimelineStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v23 = Instance;
    *(float *)(Instance + 32) = a1;
    *(float *)(Instance + 36) = a2;
    long long v24 = *a5;
    *(void *)(Instance + 56) = *((void *)a5 + 2);
    *(_OWORD *)(Instance + 40) = v24;
    long long v25 = *a6;
    *(void *)(Instance + 80) = *((void *)a6 + 2);
    *(_OWORD *)(Instance + 64) = v25;
    if (a4) {
      CFTypeRef v26 = CFRetain(a4);
    }
    else {
      CFTypeRef v26 = 0;
    }
    *(void *)(v23 + 88) = v26;
    if (a8) {
      CFTypeRef v27 = CFRetain(a8);
    }
    else {
      CFTypeRef v27 = 0;
    }
    *(void *)(v23 + 16) = a9;
    *(void *)(v23 + 24) = v27;
    *(_DWORD *)(v23 + 96) = a7;
    *(_DWORD *)(v23 + 100) = a10;
    *(unsigned char *)(v23 + 104) = a11;
    *a13 = v23;
    return 0;
  }
  uint64_t v29 = 4294951586;
LABEL_21:

  return FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorExpectTransitionToNewTimelineFromTimelineControl()
{
  return 0;
}

uint64_t FigTimelineCoordinatorSetReadinessHintFromTimelineControl(dispatch_queue_t *a1, int a2)
{
  char v4 = malloc_type_malloc(0x10uLL, 0x10200403A5D3213uLL);
  if (a1) {
    CFTypeRef v5 = CFRetain(a1);
  }
  else {
    CFTypeRef v5 = 0;
  }
  *(void *)char v4 = v5;
  v4[2] = a2;
  dispatch_async_f(a1[11], v4, (dispatch_function_t)figTimelineCoordinator_setReadinessHintFromTimelineControlOnQueue);
  return 0;
}

void figTimelineCoordinator_setReadinessHintFromTimelineControlOnQueue(_DWORD *a1)
{
  uint64_t v2 = *(_DWORD **)a1;
  int v3 = a1[2];
  if (v2[84] != v3) {
    v2[84] = v3;
  }
  CFRelease(v2);

  free(a1);
}

uint64_t FigTimelineCoordinatorSetProperty(uint64_t a1, CFTypeRef cf1, const __CFArray *a3)
{
  if (a1 && cf1)
  {
    if (FigCFEqual(cf1, @"SuspensionWaitingPolicies"))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFIndex Count = CFArrayGetCount(a3);
      if (Count < 1)
      {
LABEL_11:
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
        CFTypeRef v16 = *(const void **)(a1 + 400);
        *(void *)(a1 + 400) = Mutable;
        if (Mutable) {
          CFRetain(Mutable);
        }
        if (v16) {
          CFRelease(v16);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        unsigned int v17 = malloc_type_malloc(0x10uLL, 0x10200405F07FB98uLL);
        *(void *)unsigned int v17 = CFRetain((CFTypeRef)a1);
        v17[8] = 0;
        dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v17, (dispatch_function_t)figTimelineCoordinator_reapplyExpectedTimelineDispatch);
        uint64_t v18 = 0;
        if (!Mutable) {
          return v18;
        }
      }
      else
      {
        CFIndex v8 = Count;
        CFIndex v9 = 0;
        while (1)
        {
          ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v9);
          if (!ValueAtIndex) {
            break;
          }
          CFDictionaryRef v11 = ValueAtIndex;
          CFTypeID v12 = CFGetTypeID(ValueAtIndex);
          if (v12 != CFDictionaryGetTypeID()) {
            break;
          }
          CFNumberRef Value = CFDictionaryGetValue(v11, @"SuspensionReason");
          if (!Value) {
            break;
          }
          uint64_t v14 = Value;
          CFTypeID v15 = CFGetTypeID(Value);
          if (v15 != CFStringGetTypeID()) {
            break;
          }
          CFDictionarySetValue(Mutable, v14, v11);
          if (v8 == ++v9) {
            goto LABEL_11;
          }
        }
        uint64_t v18 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
        if (!Mutable) {
          return v18;
        }
      }
      CFRelease(Mutable);
      return v18;
    }
    if (!FigCFEqual(cf1, @"PauseSnapsToMediaTimeOfOriginator"))
    {
      if (!FigCFEqual(cf1, @"InternalSuspensionReasons")) {
        return 4294954512;
      }
      FigCFArrayAppendArray(*(__CFArray **)(a1 + 448), a3);
      return 0;
    }
    if (a3)
    {
      CFTypeID v19 = CFGetTypeID(a3);
      if (v19 == CFBooleanGetTypeID())
      {
        BOOL v20 = *MEMORY[0x1E4F1CFD0] == (void)a3;
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
        *(unsigned char *)(a1 + 408) = v20;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        return 0;
      }
    }
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorCopyProperty(uint64_t a1, CFTypeRef cf1, uint64_t a3, CFArrayRef *a4)
{
  if (a1 && cf1 && a4)
  {
    if (FigCFEqual(cf1, @"SuspensionWaitingPolicies"))
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
      *a4 = FigCFDictionaryCopyArrayOfValues(*(const __CFDictionary **)(a1 + 400));
      int v7 = *(pthread_mutex_t **)(a1 + 392);
    }
    else
    {
      if (FigCFEqual(cf1, @"PauseSnapsToMediaTimeOfOriginator"))
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
        int v9 = *(unsigned __int8 *)(a1 + 408);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        uint64_t v8 = 0;
        uint64_t v10 = (CFArrayRef *)MEMORY[0x1E4F1CFD0];
        if (!v9) {
          uint64_t v10 = (CFArrayRef *)MEMORY[0x1E4F1CFC8];
        }
        *a4 = *v10;
        return v8;
      }
      if (FigCFEqual(cf1, @"PreferredAudioClockDeviceUID"))
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
        uint64_t v11 = *(void *)(a1 + 176);
        if (v11) {
          uint64_t v8 = CMTimeSyncTimeOfDayClockCopyDeviceIdentifier(v11, a4);
        }
        else {
          uint64_t v8 = 4294954513;
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
        return v8;
      }
      if (!FigCFEqual(cf1, @"NetworkToHostTimeOffset")) {
        return 4294954512;
      }
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 504));
      if ((*(unsigned char *)(a1 + 488) & 1) == 0) {
        figTimelineCoordinator_setNetworkToHostTimeOffset(a1);
      }
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CMTime v14 = *(CMTime *)(a1 + 476);
      *a4 = CMTimeCopyAsDictionary(&v14, v13);
      int v7 = *(pthread_mutex_t **)(a1 + 504);
    }
    FigSimpleMutexUnlock(v7);
    return 0;
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t figTimelineCoordinator_setNetworkToHostTimeOffset(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  memset(&v14, 0, sizeof(v14));
  int v3 = (uint64_t *)(a1 + 176);
  uint64_t v2 = *(void **)(a1 + 176);
  if (!v2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
    CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
    uint64_t HostTimeForClockTime = CMTimeSyncTimeOfDayClockCreate((uint64_t)v4, v3);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
    if (HostTimeForClockTime) {
      return HostTimeForClockTime;
    }
    uint64_t v2 = (void *)*v3;
  }
  *(_OWORD *)&v16.unsigned int value = *(_OWORD *)&kCMTimeZero.value;
  v16.CMTimeEpoch epoch = 0;
  uint64_t HostTimeForClockTime = CMTimeSyncTimeOfDayClockGetHostTimeForClockTime(v2, (uint64_t)&v16, &v14);
  if (HostTimeForClockTime)
  {
    LODWORD(rhs.value) = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 0, (int *)&rhs, &type);
    unsigned int value = rhs.value;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v10 = value;
    }
    else {
      unsigned int v10 = value & 0xFFFFFFFE;
    }
    if (v10)
    {
      LODWORD(lhs.value) = 136315394;
      *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"figTimelineCoordinator_setNetworkToHostTimeOffset";
      LOWORD(lhs.flags) = 1024;
      *(CMTimeFlags *)((char *)&lhs.flags + 2) = HostTimeForClockTime;
      uint64_t v11 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(value) = rhs.value;
    }
    else
    {
      uint64_t v11 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 0, 1, v11, v11 != &v16, value, 0, v9);
  }
  else
  {
    CMTime lhs = v14;
    *(_OWORD *)&rhs.unsigned int value = *(_OWORD *)&kCMTimeZero.value;
    rhs.CMTimeEpoch epoch = 0;
    CMTimeSubtract(&v16, &lhs, &rhs);
    *(CMTime *)(a1 + 476) = v16;
  }
  return HostTimeForClockTime;
}

uint64_t FigTimelineCoordinatorCreate(const __CFAllocator *a1, uint64_t a2, void *a3, NSObject *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unsigned int v11 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimelineCoordinatorTrace[1], @"timelinecoordinator_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v11, 0, gFigTimelineCoordinatorTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272FB8, @"timelinecoordinator_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272FB0);
  if (FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce != -1) {
    dispatch_once_f(&FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v13 = Instance;
  if (*a3 || !a3[1] || !a3[4] || !a3[2] || !a3[3])
  {
    uint64_t v14 = 4294951585;
LABEL_31:
    FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    CFRelease((CFTypeRef)v13);
    return 0;
  }
  uint64_t v14 = 4294951585;
  if (!a2 || !a4) {
    goto LABEL_31;
  }
  *(unsigned char *)(v13 + 104) = 1;
  FigCFDictionaryGetBooleanIfPresent(a5, @"OnlySendFullyDefinedCommands", (Boolean *)(v13 + 104));
  FigCFDictionaryGetBooleanIfPresent(a5, @"SkipEndSuspensionCommandsWhenAlone", (Boolean *)(v13 + 440));
  FigCFDictionaryGetBooleanIfPresent(a5, @"IsInterstitialTimelineCoordinator", (Boolean *)(v13 + 472));
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(v13 + 216) = Mutable;
  if (!Mutable) {
    goto LABEL_36;
  }
  CMTime v16 = FigSimpleMutexCreate();
  *(void *)(v13 + 184) = v16;
  if (!v16) {
    goto LABEL_36;
  }
  CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef v18 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(v13 + 328) = v18;
  if (!v18) {
    goto LABEL_36;
  }
  CFTypeID v19 = FigSimpleMutexCreate();
  *(void *)(v13 + 320) = v19;
  if (!v19) {
    goto LABEL_36;
  }
  CFMutableArrayRef v20 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E4F1D510]);
  *(void *)(v13 + 424) = v20;
  if (!v20) {
    goto LABEL_36;
  }
  CFMutableArrayRef v21 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E4F1D510]);
  *(void *)(v13 + 432) = v21;
  if (!v21) {
    goto LABEL_36;
  }
  CFMutableArrayRef v22 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E4F1D510]);
  *(void *)(v13 + 448) = v22;
  if (!v22) {
    goto LABEL_36;
  }
  uint64_t v23 = FigSimpleMutexCreate();
  *(void *)(v13 + 416) = v23;
  if (!v23) {
    goto LABEL_36;
  }
  long long v24 = FigSimpleMutexCreate();
  *(void *)(v13 + 16) = v24;
  if (!v24) {
    goto LABEL_36;
  }
  long long v25 = FigSimpleMutexCreate();
  *(void *)(v13 + 392) = v25;
  if (!v25) {
    goto LABEL_36;
  }
  CFTypeRef v26 = FigSimpleMutexCreate();
  *(void *)(v13 + 168) = v26;
  if (!v26
    || (CFTypeRef v27 = FigSimpleMutexCreate(), (*(void *)(v13 + 504) = v27) == 0)
    || (*(void *)(v13 + 24) = 1,
        *(_DWORD *)(v13 + 456) = 0,
        CFMutableDictionaryRef v28 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
        (*(void *)(v13 + 464) = v28) == 0))
  {
LABEL_36:
    uint64_t v14 = 4294951586;
    goto LABEL_31;
  }
  *(unsigned char *)(v13 + 281) = 0;
  uint64_t v29 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v13);
  char v30 = (const dispatch_source_type_s *)MEMORY[0x1E4F14490];
  CFTypeRef v31 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, a4);
  *(void *)(v13 + 376) = v31;
  dispatch_source_set_timer(v31, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  dispatch_set_context(*(dispatch_object_t *)(v13 + 376), v29);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v13 + 376), (dispatch_function_t)figTimelineCoordinator_didFireAdvanceToNextCommandSource);
  dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(v13 + 376), (dispatch_function_t)figTimelineCoordinator_cancelAdvanceToNextCommandSource);
  dispatch_resume(*(dispatch_object_t *)(v13 + 376));
  CFIndex v32 = dispatch_source_create(v30, 0, 0, a4);
  *(void *)(v13 + 112) = v32;
  dispatch_source_set_timer(v32, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v13 + 112), (dispatch_function_t)figTimelineCoordinator_handleMissedControlCallbackCompletionOnQueue);
  dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(v13 + 112), (dispatch_function_t)figTimelineCoordinator_cancelTimelineControlCommandCompletionTimer);
  uint64_t v33 = *(NSObject **)(v13 + 112);
  CFStringRef v34 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v13);
  dispatch_set_context(v33, v34);
  dispatch_resume(*(dispatch_object_t *)(v13 + 112));
  __copy_assignment_8_8_t0w8_pa0_17997_8_pa0_38372_16_pa0_19900_24_pa0_16123_32_pa0_58861_40((void *)(v13 + 32), a3);
  *(void *)(v13 + 88) = a4;
  dispatch_retain(a4);
  *(void *)(v13 + 80) = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
  if (dword_1E9272FB8)
  {
    v44[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, v44, &type);
    int v36 = v44[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v38 = v36;
    }
    else {
      unsigned int v38 = v36 & 0xFFFFFFFE;
    }
    if (v38)
    {
      int v39 = *(unsigned __int8 *)(v13 + 472);
      v44[1] = 136315650;
      float v45 = "FigTimelineCoordinatorCreate";
      __int16 v46 = 2048;
      uint64_t v47 = v13;
      __int16 v48 = 1024;
      int v49 = v39;
      uint64_t v40 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v36) = v44[0];
    }
    else
    {
      uint64_t v40 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v40, v40 != &v50, v36, 0, v37);
  }
  *a6 = v13;
  return 0;
}

void figTimelineCoordinator_didFireAdvanceToNextCommandSource(id *a1)
{
  long long v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    *((unsigned char *)v1 + 361) = 1;
    if (v1[28])
    {
      figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue((uint64_t)v1);
    }
    else if (!figTimelineCoordinator_anyParticipantIsSuspendedWithOnlyReasonsThatTriggerWaiting((uint64_t)v1))
    {
      theArradouble y = 0;
      figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue((uint64_t)v2, &theArray);
      if (!theArray) {
        goto LABEL_14;
      }
      int v3 = CFArrayGetCount(theArray) < 1
         ? 0
         : figTimelineCoordinator_groupShouldWaitForAllSuspensions((uint64_t)v2, theArray);
      if (theArray) {
        CFRelease(theArray);
      }
      if (!v3)
      {
LABEL_14:
        uint64_t v4 = (uint64_t)v2[25];
        if (v4) {
          figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue((uint64_t)v2, v4, 4u, 1, 1, 1, 1, 1);
        }
      }
    }
    CFRelease(v2);
  }
}

void figTimelineCoordinator_cancelAdvanceToNextCommandSource(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void figTimelineCoordinator_handleMissedControlCallbackCompletionOnQueue(id *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    uint64_t v2 = (uint64_t)v1;
    figTimelineCoordinator_suspendTimelineControlCommandCompletionTimer((uint64_t)v1);
    ++*(_DWORD *)(v2 + 100);
    *(unsigned char *)(v2 + 96) = 0;
    v9[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 0, v9, &type);
    int v4 = v9[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v6 = v4;
    }
    else {
      unsigned int v6 = v4 & 0xFFFFFFFE;
    }
    if (v6)
    {
      v9[1] = 136315138;
      unsigned int v10 = "figTimelineCoordinator_handleMissedControlCallbackCompletionOnQueue";
      int v7 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v4) = v9[0];
    }
    else
    {
      int v7 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 0, 1, v7, v7 != &v11, v4, 0, v5);
    figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(v2);
    CFRelease((CFTypeRef)v2);
  }
}

void figTimelineCoordinator_cancelTimelineControlCommandCompletionTimer(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void *__copy_assignment_8_8_t0w8_pa0_17997_8_pa0_38372_16_pa0_19900_24_pa0_16123_32_pa0_58861_40(void *result, void *a2)
{
  *uint64_t result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  result[3] = a2[3];
  result[4] = a2[4];
  result[5] = a2[5];
  return result;
}

const void *FigTimelineStateDictionaryGetStateLoggingIdentifier(const __CFDictionary *a1)
{
  if (!a1) {
    return 0;
  }
  CFNumberRef Value = CFDictionaryGetValue(a1, @"DebugInfo");
  if (!Value) {
    return 0;
  }
  uint64_t v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFStringGetTypeID()) {
    return 0;
  }
  return v2;
}

const void *FigParticipantStateDictionaryGetStateLoggingIdentifier(const __CFDictionary *a1)
{
  if (!a1) {
    return 0;
  }
  CFNumberRef Value = CFDictionaryGetValue(a1, @"DebugInfo");
  if (!Value) {
    return 0;
  }
  uint64_t v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFStringGetTypeID()) {
    return 0;
  }
  return v2;
}

uint64_t FigXPCMessageSetTimelineCoordinatorSuspension(void *a1, const char *a2, uint64_t a3)
{
  if (a3) {
    return FigXPCMessageSetCFString(a1, a2, *(CFTypeRef *)(a3 + 16));
  }
  else {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCMessageCopyTimelineCoordinatorSuspension(void *a1, const char *a2, uint64_t *a3)
{
  CFTypeRef cf = 0;
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFString(a1, a2, &cf);
    CFTypeRef v5 = cf;
    if (v4)
    {
      uint64_t v6 = v4;
      if (!cf) {
        return v6;
      }
    }
    else
    {
      uint64_t v6 = FigTimelineCoordinatorSuspensionCreate(*MEMORY[0x1E4F1CF80], cf, a3);
      CFTypeRef v5 = cf;
      if (!cf) {
        return v6;
      }
    }
    CFRelease(v5);
    return v6;
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetTimelineCoordinatorParticipantSnapshot(void *a1, const char *a2, uint64_t a3)
{
  if (a3)
  {
    xpc_object_t XPCDictionaryFromParticipantSnapshot = createXPCDictionaryFromParticipantSnapshot(a3);
    xpc_dictionary_set_value(a1, a2, XPCDictionaryFromParticipantSnapshot);
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    xpc_object_t XPCDictionaryFromParticipantSnapshot = 0;
  }
  FigXPCRelease(XPCDictionaryFromParticipantSnapshot);
  return v6;
}

xpc_object_t createXPCDictionaryFromParticipantSnapshot(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  if (*(void *)(a1 + 24))
  {
    CFTypeID v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(v2, "LocalTimeline", v3);
    FigXPCRelease(v3);
  }
  uint64_t v4 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  xpc_dictionary_set_value(v2, "SourceState", v4);
  FigXPCRelease(v4);
  return v2;
}

uint64_t FigXPCMessageCopyTimelineCoordinatorParticipantSnapshot(void *a1, const char *a2, uint64_t *a3)
{
  if (a3)
  {
    xpc_object_t value = xpc_dictionary_get_value(a1, a2);
    return figTimelineCoordinatorParticipantCreateFromXPCDictionary(value, a3);
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figTimelineCoordinatorParticipantCreateFromXPCDictionary(void *a1, uint64_t *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "LocalTimeline");
  CFDictionaryRef v5 = (const __CFDictionary *)xpc_dictionary_get_value(a1, "SourceState");
  if (value) {
    xpc_object_t value = (const void *)_CFXPCCreateCFObjectFromXPCObject();
  }
  if (v5) {
    CFDictionaryRef v5 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
  }
  uint64_t v6 = figTimelineCoordinatorParticipantCreateFromDictionary(*MEMORY[0x1E4F1CF80], v5, value, a2);
  if (value) {
    CFRelease(value);
  }
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t FigXPCMessageSetTimelineCoordinatorParticipantSnapshots(void *a1, const char *a2, const __CFArray *a3)
{
  if (a3)
  {
    xpc_object_t v6 = xpc_array_create(0, 0);
    if (CFArrayGetCount(a3) < 1)
    {
LABEL_9:
      xpc_dictionary_set_value(a1, a2, v6);
      uint64_t v12 = 0;
    }
    else
    {
      CFIndex v7 = 0;
      while (1)
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex(a3, v7);
        if (!ValueAtIndex) {
          break;
        }
        uint64_t v9 = (uint64_t)ValueAtIndex;
        CFTypeID v10 = CFGetTypeID(ValueAtIndex);
        if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1) {
          dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
        }
        if (v10 != sFigTimelineCoordinationParticipantSnapshotID) {
          break;
        }
        xpc_object_t XPCDictionaryFromParticipantSnapshot = createXPCDictionaryFromParticipantSnapshot(v9);
        xpc_array_append_value(v6, XPCDictionaryFromParticipantSnapshot);
        xpc_release(XPCDictionaryFromParticipantSnapshot);
        if (++v7 >= CFArrayGetCount(a3)) {
          goto LABEL_9;
        }
      }
      uint64_t v12 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    uint64_t v12 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    xpc_object_t v6 = 0;
  }
  FigXPCRelease(v6);
  return v12;
}

uint64_t FigXPCMessageCopyTimelineCoordinatorParticipantSnapshots(void *a1, const char *a2, __CFArray **a3)
{
  if (a3 && (arradouble y = xpc_dictionary_get_array(a1, a2)) != 0)
  {
    CFDictionaryRef v5 = array;
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (xpc_array_get_count(v5))
    {
      size_t v7 = 0;
      while (1)
      {
        xpc_object_t value = 0;
        dictionardouble y = xpc_array_get_dictionary(v5, v7);
        if (!dictionary) {
          break;
        }
        uint64_t v9 = figTimelineCoordinatorParticipantCreateFromXPCDictionary(dictionary, (uint64_t *)&value);
        if (v9) {
          goto LABEL_13;
        }
        CFArrayAppendValue(Mutable, value);
        if (value) {
          CFRelease(value);
        }
        if (++v7 >= xpc_array_get_count(v5)) {
          goto LABEL_10;
        }
      }
      uint64_t v9 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
LABEL_13:
      uint64_t v10 = v9;
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
    else
    {
LABEL_10:
      uint64_t v10 = 0;
      *a3 = Mutable;
    }
    return v10;
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

double FigTimelineCoordinator_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

CFAllocatorRef FigTimelineCoordinator_Finalize(uint64_t a1)
{
  xpc_object_t v2 = *(const void **)(a1 + 296);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 296) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 200);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 200) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 192);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 192) = 0;
  }
  CFDictionaryRef v5 = *(const void **)(a1 + 216);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 216) = 0;
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 184));
  *(void *)(a1 + 184) = 0;
  xpc_object_t v6 = *(NSObject **)(a1 + 88);
  if (v6) {
    dispatch_release(v6);
  }
  size_t v7 = *(const void **)(a1 + 328);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 328) = 0;
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 320));
  *(void *)(a1 + 320) = 0;
  uint64_t v8 = *(const void **)(a1 + 272);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 272) = 0;
  }
  uint64_t v9 = *(const void **)(a1 + 288);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 288) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 344);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 344) = 0;
  }
  char v11 = *(const void **)(a1 + 352);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 352) = 0;
  }
  uint64_t v12 = *(const void **)(a1 + 368);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 368) = 0;
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 376));
  uint64_t v13 = *(NSObject **)(a1 + 376);
  if (v13)
  {
    dispatch_release(v13);
    *(void *)(a1 + 376) = 0;
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 112));
  uint64_t v14 = *(NSObject **)(a1 + 112);
  if (v14)
  {
    dispatch_release(v14);
    *(void *)(a1 + 112) = 0;
  }
  CFTypeID v15 = *(const void **)(a1 + 80);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 80) = 0;
  }
  CMTime v16 = *(const void **)(a1 + 160);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 160) = 0;
  }
  CFAllocatorRef v17 = *(const void **)(a1 + 176);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 176) = 0;
  }
  CFMutableDictionaryRef v18 = *(const void **)(a1 + 224);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 224) = 0;
  }
  CFTypeID v19 = *(const void **)(a1 + 464);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 464) = 0;
  }
  CFMutableArrayRef v20 = *(const void **)(a1 + 424);
  if (v20)
  {
    CFRelease(v20);
    *(void *)(a1 + 424) = 0;
  }
  CFMutableArrayRef v21 = *(const void **)(a1 + 432);
  if (v21)
  {
    CFRelease(v21);
    *(void *)(a1 + 432) = 0;
  }
  CFMutableArrayRef v22 = *(const void **)(a1 + 448);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 448) = 0;
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 416));
  *(void *)(a1 + 416) = 0;
  uint64_t v23 = *(const void **)(a1 + 400);
  if (v23)
  {
    CFRelease(v23);
    *(void *)(a1 + 400) = 0;
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 392));
  *(void *)(a1 + 392) = 0;
  FigSimpleMutexDestroy(*(void *)(a1 + 168));
  *(void *)(a1 + 168) = 0;
  FigSimpleMutexDestroy(*(void *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  CFAllocatorRef result = FigSimpleMutexDestroy(*(void *)(a1 + 504));
  *(void *)(a1 + 504) = 0;
  return result;
}

__CFString *FigTimelineCoordinator_CopyDescription(unsigned __int8 *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigTimelineCoordinator %p, Type %d>", a1, a1[472]);
  return Mutable;
}

uint64_t FigTimelineCoordinatorSuspension_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void FigTimelineCoordinatorSuspension_Finalize(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

__CFString *FigTimelineCoordinatorSuspension_CopyDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigTimelineCoordinatorSuspension %p, Reason %@>", a1, a1[2]);
  return Mutable;
}

double FigTimelineCoordinatorTimelineState_Init(uint64_t a1)
{
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigTimelineCoordinatorTimelineState_Finalize(void *a1)
{
  CFAllocatorRef v2 = (const void *)a1[11];
  if (v2)
  {
    CFRelease(v2);
    a1[11] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  uint64_t v4 = (const void *)a1[14];
  if (v4)
  {
    CFRelease(v4);
    a1[14] = 0;
  }
}

__CFString *FigTimelineCoordinatorTimelineState_CopyFormattingDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  uint64_t v4 = Mutable;
  if (*(void *)(a1 + 112))
  {
    CFStringAppendFormat(Mutable, 0, @"[%@] ", *(void *)(a1 + 112));
  }
  else
  {
    CFUUIDRef v5 = *(const __CFUUID **)(a1 + 24);
    if (v5)
    {
      CFStringRef v6 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5);
      OriginatorLoggingIdentifier = figTimelineCoordinator_createOriginatorLoggingIdentifier(v6);
      CFStringAppendFormat(v4, 0, @"[%@] ", OriginatorLoggingIdentifier);
      if (v6) {
        CFRelease(v6);
      }
      if (OriginatorLoggingIdentifier) {
        CFRelease(OriginatorLoggingIdentifier);
      }
    }
  }
  CFStringAppendFormat(v4, 0, @"pr: %g r:%g", *(float *)(a1 + 32), *(float *)(a1 + 36));
  if (*(unsigned char *)(a1 + 52))
  {
    CMTime time = *(CMTime *)(a1 + 40);
    Float64 Seconds = CMTimeGetSeconds(&time);
    CFStringAppendFormat(v4, 0, @" t:%.3f", *(void *)&Seconds);
  }
  else
  {
    CFStringAppend(v4, @" t:<INV>");
  }
  if (*(unsigned char *)(a1 + 76))
  {
    memset(&time, 0, sizeof(time));
    HostTimeClocuint64_t k = CMClockGetHostTimeClock();
    CMClockGetTime(&time, HostTimeClock);
    CMTime lhs = *(CMTime *)(a1 + 64);
    CMTime rhs = time;
    CMTimeSubtract(&v16, &lhs, &rhs);
    Float64 v10 = CMTimeGetSeconds(&v16);
    CMTime lhs = *(CMTime *)(a1 + 64);
    Float64 v11 = CMTimeGetSeconds(&lhs);
    CFStringAppendFormat(v4, 0, @" ht:<NOW>%+.3f (%.3f)", *(void *)&v10, *(void *)&v11);
  }
  else
  {
    CFStringAppend(v4, @" ht:<INV>");
  }
  uint64_t v12 = "<A>";
  if (!*(_DWORD *)(a1 + 96)) {
    uint64_t v12 = "<E>";
  }
  CFStringAppendFormat(v4, 0, @" sp:%s id: [%@]", v12, *(void *)(a1 + 88));
  return v4;
}

CFStringRef FigTimelineCoordinatorTimelineState_CopyDebugDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<FigTimelineCoordinatorTimelineState %p - %@>", a1, a1);
}

__CFString *figTimelineCoordinator_createOriginatorLoggingIdentifier(const void *a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFHashCode v3 = CFHash(a1);
  CFStringAppendFormat(Mutable, 0, @"%c%c%c%c", (v3 % 0x1A) + 65, (v3 / 0x1A) - 26 * ((v3 / 0x1A * (unsigned __int128)0x9D89D89D89D89D9uLL) >> 64) + 65, (v3 / 0x2A4) - 26 * ((v3 / 0x2A4 * (unsigned __int128)0x9D89D89D89D89D9uLL) >> 64) + 65, (v3 / 0x44A8)- 26 * ((v3 / 0x44A8 * (unsigned __int128)0x9D89D89D89D89D9uLL) >> 64)+ 65);
  return Mutable;
}

double FigTimelineCoordinationParticipantSnapshot_Init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigTimelineCoordinationParticipantSnapshot_Finalize(void *a1)
{
  CFAllocatorRef v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  CFHashCode v3 = (const void *)a1[2];
  if (v3)
  {
    CFRelease(v3);
    a1[2] = 0;
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  CFUUIDRef v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
}

BOOL FigTimelineCoordinationParticipantSnapshot_Equal(int a1, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(cf);
  if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1) {
    dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
  }
  return v2 == sFigTimelineCoordinationParticipantSnapshotID;
}

CFHashCode FigTimelineCoordinationParticipantSnapshot_Hash(uint64_t a1)
{
  CFTypeRef v2 = FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(a1);
  CFHashCode v3 = CFHash(v2);
  CFHashCode v4 = CFHash(*(CFTypeRef *)(a1 + 32));
  unsigned int v5 = FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(a1);
  if (v2) {
    CFRelease(v2);
  }
  return v4 | v3 | v5;
}

__CFString *FigTimelineCoordinationParticipantSnapshot_CopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigTimelineCoordinationParticipantSnapshot %p>", a1);
  return Mutable;
}

BOOL figTimelineCoordinator_newTimelineStateShouldOverrideExistingState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    return 1;
  }
  if (*(unsigned char *)(a3 + 104) || FigCFEqual(*(CFTypeRef *)(a1 + 272), *(CFTypeRef *)(a3 + 88))) {
    return 1;
  }
  int v7 = *(_DWORD *)(a2 + 100);
  int v8 = *(_DWORD *)(a3 + 100);
  if (v7 > v8) {
    return 0;
  }
  if (v7 < v8) {
    return 1;
  }
  uint64_t v9 = figTimelineCoordinator_compareUUIDs(*(const __CFUUID **)(a2 + 24), *(const __CFUUID **)(a3 + 24));
  if (v9 == 1) {
    return 0;
  }
  if (v9) {
    return 1;
  }
  return FigCFEqual(*(CFTypeRef *)(a3 + 24), *(CFTypeRef *)(a1 + 344)) != 0;
}

BOOL figTimelineCoordinator_timelinesMatch(uint64_t a1, uint64_t a2, CMTime *a3, unsigned char *a4)
{
  BOOL result = 0;
  memset(&v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  if (a1 && a2)
  {
    if (!FigCFEqual(*(CFTypeRef *)(a1 + 88), *(CFTypeRef *)(a2 + 88)))
    {
      if (a4)
      {
        BOOL result = 0;
        *a4 = 0;
        return result;
      }
      return 0;
    }
    uint64_t v9 = *(void *)(a1 + 88);
    if (v9) {
      LOBYTE(v9) = (*(float *)(a1 + 36) == 0.0 || (*(_DWORD *)(a1 + 76) & 0x1D) == 1)
    }
                && (*(_DWORD *)(a1 + 52) & 0x1D) == 1;
    if (*(void *)(a2 + 88) && (*(float *)(a2 + 36) == 0.0 || (*(_DWORD *)(a2 + 76) & 0x1D) == 1)) {
      LOBYTE(v9) = v9 ^ ((*(_DWORD *)(a2 + 52) & 0x1D) == 1);
    }
    if (v9) {
      return 0;
    }
    figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)a1, (CMTime *)&kCMTimeInvalid, &v18);
    figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)a2, (CMTime *)&kCMTimeInvalid, &v17);
    CMTime v16 = v18;
    CMTime v15 = v17;
    CMTime v14 = *a3;
    BOOL IsWithinTolerance = CMTimeDifferenceIsWithinTolerance(&v16, &v15, &v14);
    if (a4) {
      *a4 = IsWithinTolerance;
    }
    float v11 = *(float *)(a1 + 36);
    float v12 = *(float *)(a2 + 36);
    if (v11 == 0.0 && v11 == v12 && *(float *)(a1 + 32) != *(float *)(a2 + 32)) {
      return 0;
    }
    return v11 == v12 && IsWithinTolerance;
  }
  return result;
}

void figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(uint64_t a1, uint64_t a2, unsigned int a3, char a4, char a5, char a6, char a7, char a8)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (a3) {
    BOOL v52 = 0;
  }
  else {
    BOOL v52 = FigCFEqual(*(CFTypeRef *)(a1 + 272), *(CFTypeRef *)(a1 + 352)) == 0;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 432));
  BOOL v14 = Count > 0 && a3 == 1;
  BOOL v15 = a3 != 1 && Count > 0;
  BOOL v19 = a3 == 1
     && ((v16 = *(void *)(a1 + 200)) == 0 ? (BOOL v17 = 0) : (BOOL v17 = *(float *)(v16 + 36) != 0.0),
         (CFDictionaryRef v18 = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328)), v17)
      || !v18
      || CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1)
     && *(unsigned char *)(a1 + 104) == 0;
  uint64_t v20 = *(void *)(a1 + 200);
  if (v20 && *(float *)(v20 + 36) == 0.0)
  {
    figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v20, (CMTime *)&kCMTimeInvalid, &v61);
    CMTimeMake(&v60, 1, 10);
    CMTime time = *(CMTime *)(a2 + 40);
    BOOL IsWithinTolerance = CMTimeDifferenceIsWithinTolerance(&v61, &time, &v60);
  }
  else
  {
    BOOL IsWithinTolerance = 0;
  }
  if ((*(float *)(a2 + 32) == 0.0 || *(float *)(a2 + 36) != 0.0) && *(unsigned char *)(a1 + 360))
  {
    *(unsigned char *)(a1 + 360) = 0;
    CFMutableArrayRef v22 = *(const void **)(a1 + 368);
    if (v22)
    {
      CFRelease(v22);
      *(void *)(a1 + 368) = 0;
    }
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
  }
  uint64_t v23 = *(const void **)(a1 + 224);
  *(void *)(a1 + 224) = a2;
  CFRetain((CFTypeRef)a2);
  if (v23) {
    CFRelease(v23);
  }
  *(unsigned char *)(a1 + 261) = a5;
  *(unsigned char *)(a1 + 263) = IsWithinTolerance;
  *(unsigned char *)(a1 + 257) = a7;
  *(unsigned char *)(a1 + 256) = a6;
  figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)a2, (CMTime *)&kCMTimeInvalid, &lhs);
  figTimelineCoordinator_timelineTimeAtHostTime(*(CMTime **)(a1 + 192), (CMTime *)&kCMTimeInvalid, &rhs);
  CMTimeSubtract(&time, &lhs, &rhs);
  *(CMTime *)(a1 + 232) = time;
  *(unsigned char *)(a1 + 258) = a8;
  *(unsigned char *)(a1 + 262) = v52;
  *(unsigned char *)(a1 + 265) = v19;
  *(unsigned char *)(a1 + 259) = v14;
  *(unsigned char *)(a1 + 260) = v15;
  *(unsigned char *)(a1 + 264) = a4;
  *(_DWORD *)(a1 + 268) = a3;
  if (dword_1E9272FB8)
  {
    long long v24 = FigCFCopyCompactDescription((const __CFSet *)a2);
    if (a3 > 7) {
      long long v25 = "Unknown";
    }
    else {
      long long v25 = off_1E567D9A0[a3];
    }
    if (dword_1E9272FB8)
    {
      int v57 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v57, &type);
      int v27 = v57;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v29 = v27;
      }
      else {
        unsigned int v29 = v27 & 0xFFFFFFFE;
      }
      if (v29)
      {
        if (*(unsigned char *)(a1 + 261)) {
          char v30 = "Yes";
        }
        else {
          char v30 = "No";
        }
        if (*(unsigned char *)(a1 + 263)) {
          CFTypeRef v31 = "Match";
        }
        else {
          CFTypeRef v31 = "Mismatch";
        }
        if (*(unsigned char *)(a1 + 258)) {
          CFIndex v32 = "No";
        }
        else {
          CFIndex v32 = "Yes";
        }
        if (*(unsigned char *)(a1 + 257)) {
          uint64_t v33 = "No";
        }
        else {
          uint64_t v33 = "Yes";
        }
        if (*(unsigned char *)(a1 + 256)) {
          CFStringRef v34 = "No";
        }
        else {
          CFStringRef v34 = "Yes";
        }
        if (*(unsigned char *)(a1 + 256))
        {
          double Seconds = NAN;
        }
        else
        {
          CMTime time = *(CMTime *)(a1 + 232);
          char v53 = v33;
          uint64_t v51 = v25;
          uint64_t v37 = v31;
          unsigned int v38 = v32;
          int v39 = v34;
          double Seconds = CMTimeGetSeconds(&time);
          CFStringRef v34 = v39;
          CFIndex v32 = v38;
          CFTypeRef v31 = v37;
          long long v25 = v51;
          uint64_t v33 = v53;
        }
        uint64_t v40 = "Politely";
        int v41 = *(unsigned __int8 *)(a1 + 259);
        int v42 = *(unsigned __int8 *)(a1 + 260);
        char v43 = " Group";
        int v44 = *(unsigned __int8 *)(a1 + 262);
        if (!*(unsigned char *)(a1 + 264)) {
          uint64_t v40 = "Asap";
        }
        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"figTimelineCoordinator_transitionToNewExpectedTimelineI"
                                                                 "ssuingCommandsWhenAppropriateOnQueue";
        LOWORD(time.flags) = 2112;
        float v45 = "";
        LODWORD(time.value) = 136318722;
        if (!v41) {
          char v43 = "";
        }
        int v46 = v42 | v41;
        *(void *)((char *)&time.flags + 2) = a1;
        BOOL v47 = v42 == 0;
        HIWORD(time.epoch) = 2114;
        __int16 v48 = " Local";
        int v63 = v24;
        if (v47) {
          __int16 v48 = "";
        }
        __int16 v64 = 2082;
        unsigned int v65 = v25;
        if (!v46) {
          float v45 = " No";
        }
        __int16 v66 = 2082;
        if (v44) {
          int v49 = "Yes";
        }
        else {
          int v49 = "No";
        }
        CFTypeRef v67 = v30;
        __int16 v68 = 2082;
        double v69 = v31;
        __int16 v70 = 2082;
        long long v71 = v32;
        __int16 v72 = 2082;
        long long v73 = v33;
        __int16 v74 = 2082;
        double v75 = v34;
        __int16 v76 = 2048;
        double v77 = Seconds;
        __int16 v78 = 2082;
        char v79 = v40;
        __int16 v80 = 2082;
        uint64_t v81 = v43;
        __int16 v82 = 2082;
        char v83 = v48;
        __int16 v84 = 2082;
        CFTypeRef v85 = v45;
        __int16 v86 = 2082;
        CGFloat v87 = v49;
        int v36 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v27) = v57;
      }
      else
      {
        int v36 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v36, v36 != &v88, v27, 0, v28);
    }
    if (v24) {
      CFRelease(v24);
    }
  }
  figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(a1);
}

uint64_t figTimelineCoordinator_compareUUIDs(const __CFUUID *a1, const __CFUUID *a2)
{
  CFUUIDBytes uu1 = CFUUIDGetUUIDBytes(a1);
  CFUUIDBytes v4 = CFUUIDGetUUIDBytes(a2);
  return uuid_compare(&uu1.byte0, &v4.byte0);
}

BOOL CMTimeDifferenceIsWithinTolerance(CMTime *a1, CMTime *a2, CMTime *a3)
{
  CMTime lhs = *a1;
  CMTime v5 = *a2;
  CMTimeSubtract(&time, &lhs, &v5);
  CMTimeAbsoluteValue(&time1, &time);
  CMTime lhs = *a3;
  return CMTimeCompare(&time1, &lhs) < 1;
}

void figTimelineCoordinator_sendParticipantStateToGroupOnQueue(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  theArradouble y = 0;
  if (!*(void *)(a1 + 344)) {
    return;
  }
  if (!*(void *)(a1 + 160)
    || figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, &theArray)
    || figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(a1, theArray))
  {
    CFMutableDictionaryRef Mutable = 0;
    CFStringRef StateLoggingIdentifier = 0;
    CFAllocatorRef v2 = 0;
  }
  else
  {
    CFAllocatorRef v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 160));
    if (v2)
    {
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFStringRef v5 = CFUUIDCreateString(v3, *(CFUUIDRef *)(a1 + 344));
      CFDictionarySetValue(Mutable, @"UUID", v5);
      FigCFDictionarySetInt32(Mutable, @"ProtocolVersion", 0);
      if (*(void *)(a1 + 352))
      {
        BOOL v6 = CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) > 0 || (*(_DWORD *)(a1 + 340) & 1) == 0;
        CFDictionarySetValue(Mutable, @"CurrentIdentifier", *(const void **)(a1 + 352));
        int v7 = (const void *)*MEMORY[0x1E4F1CFD0];
        int v8 = (const void *)*MEMORY[0x1E4F1CFC8];
        if (v6) {
          uint64_t v9 = (const void *)*MEMORY[0x1E4F1CFC8];
        }
        else {
          uint64_t v9 = (const void *)*MEMORY[0x1E4F1CFD0];
        }
        CFDictionarySetValue(Mutable, @"ReadyToSetNonZeroRate", v9);
        if (*(unsigned char *)(a1 + 360)) {
          Float64 v10 = v7;
        }
        else {
          Float64 v10 = v8;
        }
        CFDictionarySetValue(Mutable, @"CoordinatingStart", v10);
      }
      if (theArray && CFArrayGetCount(theArray) >= 1) {
        CFDictionarySetValue(Mutable, @"SuspensionReasons", theArray);
      }
      if (FigDebugIsInternalBuild())
      {
        CFStringRef StateLoggingIdentifier = figTimelineCoordinator_createStateLoggingIdentifier(@"Pa/", v5, *(unsigned int *)(a1 + 384));
        FigCFDictionarySetValue(Mutable, @"DebugInfo", StateLoggingIdentifier);
      }
      else
      {
        CFStringRef StateLoggingIdentifier = 0;
      }
      if (dword_1E9272FB8)
      {
        float v12 = FigCFCopyCompactDescription(Mutable);
        if (dword_1E9272FB8)
        {
          int v19 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v19, &type);
          int v14 = v19;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v16 = v14;
          }
          else {
            unsigned int v16 = v14 & 0xFFFFFFFE;
          }
          if (v16)
          {
            int v21 = 136315650;
            CFMutableArrayRef v22 = "figTimelineCoordinator_sendParticipantStateToGroupOnQueue";
            __int16 v23 = 2112;
            uint64_t v24 = a1;
            __int16 v25 = 2114;
            CFTypeRef v26 = v12;
            BOOL v17 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v14) = v19;
          }
          else
          {
            BOOL v17 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v17, v17 != &v27, v14, 0, v15);
        }
        if (v12) {
          CFRelease(v12);
        }
      }
      (*(void (**)(id *, __CFDictionary *))(a1 + 144))(v2, Mutable);
      ++*(_DWORD *)(a1 + 384);
      goto LABEL_35;
    }
    FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    CFMutableDictionaryRef Mutable = 0;
    CFStringRef StateLoggingIdentifier = 0;
  }
  CFStringRef v5 = 0;
LABEL_35:
  if (theArray) {
    CFRelease(theArray);
  }
  if (v2) {
    CFRelease(v2);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (StateLoggingIdentifier) {
    CFRelease(StateLoggingIdentifier);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(uint64_t a1)
{
  uint64_t v135 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Count = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328));
  CFTypeRef cf = 0;
  uint64_t v3 = *(void *)(a1 + 224);
  if (v3)
  {
    BOOL v4 = Count
      || *(unsigned char *)(a1 + 104)
      || *(float *)(v3 + 36) != 0.0
      && *(void *)(v3 + 88)
      && (*(_DWORD *)(v3 + 76) & 0x1D) == 1
      && (*(_DWORD *)(v3 + 52) & 0x1D) == 1;
    int v5 = 1718185504;
    if (!*(unsigned char *)(a1 + 360) || *(unsigned char *)(a1 + 259) || figTimelineCoordinator_everyoneIsSuspended(a1))
    {
      if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1 && !*(unsigned char *)(a1 + 259)) {
        goto LABEL_71;
      }
      if (!*(unsigned char *)(a1 + 256))
      {
        int v9 = 1786080624;
        if (v4 && *(float *)(*(void *)(a1 + 224) + 36) != 0.0) {
          int v9 = 1918989413;
        }
        goto LABEL_66;
      }
      uint64_t v6 = *(void *)(a1 + 224);
      float v7 = *(float *)(v6 + 36);
      if (*(unsigned char *)(a1 + 257))
      {
        if (v7 != 0.0) {
          goto LABEL_71;
        }
        float v8 = *(float *)(v6 + 32);
        if (v8 != 0.0 && (*(unsigned char *)(a1 + 340) & 1) == 0)
        {
          int v9 = 1886545264;
          goto LABEL_66;
        }
        if (v8 != 0.0 || (*(unsigned char *)(a1 + 340) & 1) == 0) {
          goto LABEL_71;
        }
      }
      else if (v7 != 0.0)
      {
        int v9 = 1918989413;
        if ((*(unsigned char *)(v6 + 76) & 1) == 0 && *(unsigned char *)(a1 + 104))
        {
          if (figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E4F1CF80], v6, &cf)) {
            goto LABEL_239;
          }
          Float64 v10 = (char *)cf;
          figTimelineCoordinator_pickHostTimeForCoordinatedStart(a1, theArray);
          *(CMTime *)(v10 + 64) = theArray[0];
          float v11 = *(const void **)(a1 + 224);
          CFTypeRef v12 = cf;
          *(void *)(a1 + 224) = cf;
          if (v12) {
            CFRetain(v12);
          }
          if (v11) {
            CFRelease(v11);
          }
        }
        goto LABEL_66;
      }
      int v9 = 1885435251;
LABEL_66:
      if (v9 == 1718185504)
      {
        int v5 = 1718185504;
      }
      else
      {
        int v5 = v9;
        if (*(unsigned char *)(a1 + 96))
        {
          int v5 = 2002872692;
          if (*(_DWORD *)(a1 + 268) == 1)
          {
            *(_WORD *)(a1 + 256) = 257;
            *(unsigned char *)(a1 + 258) = 1;
          }
        }
      }
LABEL_71:
      if (dword_1E9272FB8)
      {
        __int16 v23 = FigCFCopyCompactDescription(*(const __CFSet **)(a1 + 224));
        if (dword_1E9272FB8)
        {
          LODWORD(v123.value) = 0;
          LOBYTE(type.value) = 0;
          os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v123, &type);
          unsigned int value = v123.value;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value)) {
            unsigned int v27 = value;
          }
          else {
            unsigned int v27 = value & 0xFFFFFFFE;
          }
          if (v27)
          {
            int v28 = HIBYTE(v5);
            uint64_t v29 = MEMORY[0x1E4F14390];
            if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * HIBYTE(v5) + 60) & 0x40000) == 0) {
              int v28 = 46;
            }
            int v118 = v28;
            if (BYTE2(v5) > 0x7Fu) {
              int v30 = __maskrune(BYTE2(v5), 0x40000uLL);
            }
            else {
              int v30 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * BYTE2(v5) + 60) & 0x40000;
            }
            if (v30) {
              int v32 = BYTE2(v5);
            }
            else {
              int v32 = 46;
            }
            if (BYTE1(v5) > 0x7Fu) {
              int v33 = __maskrune(BYTE1(v5), 0x40000uLL);
            }
            else {
              int v33 = *(_DWORD *)(v29 + 4 * BYTE1(v5) + 60) & 0x40000;
            }
            if (v33) {
              int v34 = BYTE1(v5);
            }
            else {
              int v34 = 46;
            }
            if (v5 > 0x7Fu) {
              int v35 = __maskrune(v5, 0x40000uLL);
            }
            else {
              int v35 = *(_DWORD *)(v29 + 4 * v5 + 60) & 0x40000;
            }
            *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"figTimelineCoordinator_issueAppropriateCommandsToM"
                                                                      "atchInProgressTimelineOnQueue";
            LODWORD(time1.value) = 136316674;
            if (v35) {
              int v36 = v5;
            }
            else {
              int v36 = 46;
            }
            LOWORD(time1.flags) = 2112;
            *(void *)((char *)&time1.flags + 2) = a1;
            HIWORD(time1.epoch) = 1024;
            int v125 = v118;
            __int16 v126 = 1024;
            int v127 = v32;
            __int16 v128 = 1024;
            int v129 = v34;
            __int16 v130 = 1024;
            int v131 = v36;
            __int16 v132 = 2114;
            double v133 = v23;
            int v117 = 56;
            p_CMTime time1 = &time1;
            CFTypeRef v31 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(value) = v123.value;
          }
          else
          {
            CFTypeRef v31 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v31, v31 != theArray, value, 0, v26);
        }
        if (v23) {
          CFRelease(v23);
        }
      }
      uint64_t v37 = *(void *)(a1 + 224);
      if (*(void *)(v37 + 88))
      {
        float v38 = *(float *)(v37 + 36);
        if ((v38 == 0.0 || (*(_DWORD *)(v37 + 76) & 0x1D) == 1)
          && (*(_DWORD *)(v37 + 52) & 0x1D) == 1
          && v37 != *(void *)(a1 + 200)
          && !*(unsigned char *)(a1 + 259))
        {
          int v39 = *(unsigned __int8 *)(a1 + 261);
          if (v38 == 0.0 || (*(_DWORD *)(v37 + 76) & 0x1D) == 1)
          {
            FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
            uint64_t v40 = *(const void **)(a1 + 200);
            int v41 = *(const void **)(a1 + 224);
            *(void *)(a1 + 200) = v41;
            if (v41) {
              CFRetain(v41);
            }
            if (v40) {
              CFRelease(v40);
            }
            int v42 = *(const void **)(a1 + 208);
            if (v42)
            {
              CFRelease(v42);
              *(void *)(a1 + 208) = 0;
            }
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 216), *(const void **)(*(void *)(a1 + 224) + 88), *(const void **)(a1 + 224));
            if (!v39) {
              figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(a1);
            }
          }
          *(unsigned char *)(a1 + 261) = 1;
        }
      }
      if (!*(unsigned char *)(a1 + 260))
      {
        char v43 = *(const void **)(a1 + 192);
        int v44 = *(const void **)(a1 + 224);
        *(void *)(a1 + 192) = v44;
        if (v44) {
          CFRetain(v44);
        }
        if (v43) {
          CFRelease(v43);
        }
      }
      *(_DWORD *)(a1 + 336) = 0;
      float v45 = *(const void **)(a1 + 208);
      if (v45)
      {
        CFRelease(v45);
        *(void *)(a1 + 208) = 0;
      }
      if (v5 > 1885435250)
      {
        if (v5 == 1885435251)
        {
          uint64_t v57 = *(void *)(a1 + 368);
          uint64_t v58 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
          CFStringRef v59 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
          if (v59)
          {
            CMTime v60 = v59;
            int v61 = *(_DWORD *)(a1 + 100);
            uint64_t v62 = *(void *)(a1 + 224);
            if (*(unsigned char *)(a1 + 262) && (CFUUIDRef v63 = *(const __CFUUID **)(v62 + 24)) != 0)
            {
              CFStringRef v64 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v63);
              uint64_t v62 = *(void *)(a1 + 224);
            }
            else
            {
              CFStringRef v64 = 0;
            }
            float v95 = *(float *)(v62 + 32);
            if (v95 == 0.0) {
              float v96 = 0.0;
            }
            else {
              float v96 = *(float *)(v62 + 32);
            }
            if (*(_DWORD *)(a1 + 340))
            {
              *(_DWORD *)(a1 + 340) = 0;
              figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
            }
            figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
            CFTypeRef v97 = *(CFTypeRef *)(a1 + 224);
            if (v97) {
              CFTypeRef v97 = CFRetain(v97);
            }
            v58[1] = v97;
            void *v58 = CFRetain((CFTypeRef)a1);
            *((_DWORD *)v58 + 4) = v61;
            *((unsigned char *)v58 + 20) = v95 != 0.0;
            uint64_t v98 = *(void (**)(id *, void, void, BOOL, CFStringRef, uint64_t, void, void *, float, void (*)(void *, OpaqueCMTimebase *), int))(a1 + 56);
            *(unsigned char *)(a1 + 96) = 1;
            if (v95 == 0.0) {
              uint64_t v99 = 0;
            }
            else {
              uint64_t v99 = v57;
            }
            v98(v60, *(void *)(*(void *)(a1 + 224) + 88), *(void *)(*(void *)(a1 + 224) + 16), v95 != 0.0, v64, v99, *(unsigned int *)(a1 + 268), v58, v96, figTimelineCoordinator_timelineControlCommandCompletion, v117);
            if (v64)
            {
              if (!*(unsigned char *)(a1 + 258)) {
                figTimelineCoordinator_postDidIssueSetRateCommandNotification((const void *)a1, v64, v96);
              }
              CFRelease(v64);
            }
            CFRelease(v60);
            uint64_t v58 = 0;
          }
          else
          {
            FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
          }
          free(v58);
          *(unsigned char *)(a1 + 304) = 0;
          *(_WORD *)(a1 + 257) = 257;
          goto LABEL_239;
        }
        if (v5 == 1886545264)
        {
          uint64_t v65 = *(void *)(a1 + 368);
          __int16 v66 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
          CFTypeRef v67 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
          if (v67)
          {
            __int16 v68 = v67;
            uint64_t v69 = *(void *)(a1 + 224);
            if (*(float *)(v69 + 32) != 0.0)
            {
              int v70 = *(_DWORD *)(a1 + 100);
              if (*(unsigned char *)(a1 + 262) && (CFUUIDRef v71 = *(const __CFUUID **)(v69 + 24)) != 0) {
                CFStringRef v72 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v71);
              }
              else {
                CFStringRef v72 = 0;
              }
              if (*(_DWORD *)(a1 + 340))
              {
                *(_DWORD *)(a1 + 340) = 0;
                figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
              }
              figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
              CFTypeRef v100 = *(CFTypeRef *)(a1 + 224);
              if (v100) {
                CFTypeRef v100 = CFRetain(v100);
              }
              v66[1] = v100;
              *__int16 v66 = CFRetain((CFTypeRef)a1);
              *((_DWORD *)v66 + 4) = v70;
              *((unsigned char *)v66 + 20) = 1;
              double v101 = *(void (**)(id *, void, void, CFStringRef, uint64_t, void, void *, void (*)(void *, OpaqueCMTimebase *), float, CMTime *, int))(a1 + 64);
              *(unsigned char *)(a1 + 96) = 1;
              v101(v68, *(void *)(*(void *)(a1 + 224) + 88), *(void *)(*(void *)(a1 + 224) + 16), v72, v65, *(unsigned int *)(a1 + 268), v66, figTimelineCoordinator_timelineControlCommandCompletion, *(float *)(*(void *)(a1 + 224) + 32), p_time1, v117);
              if (v72)
              {
                if (!*(unsigned char *)(a1 + 258)) {
                  figTimelineCoordinator_postDidIssueSetRateCommandNotification((const void *)a1, v72, *(float *)(*(void *)(a1 + 224) + 32));
                }
                CFRelease(v72);
              }
              __int16 v66 = 0;
            }
            CFRelease(v68);
          }
          else
          {
            FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
          }
          free(v66);
          *(unsigned char *)(a1 + 304) = 0;
          goto LABEL_238;
        }
        if (v5 != 1918989413) {
          goto LABEL_239;
        }
        int v46 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
        BOOL v47 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
        memset(theArray, 0, 24);
        memset(&time1, 0, sizeof(time1));
        int v48 = *(_DWORD *)(a1 + 100);
        memset(&v123, 0, sizeof(v123));
        HostTimeClocuint64_t k = CMClockGetHostTimeClock();
        CMClockGetTime(&v123, HostTimeClock);
        if (v47)
        {
          if (*(unsigned char *)(a1 + 262) && (CFUUIDRef v50 = *(const __CFUUID **)(*(void *)(a1 + 224) + 24)) != 0) {
            CFStringRef v51 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v50);
          }
          else {
            CFStringRef v51 = 0;
          }
          if (*(_DWORD *)(a1 + 340))
          {
            *(_DWORD *)(a1 + 340) = 0;
            figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
          }
          figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
          __int16 v74 = *(char **)(a1 + 224);
          if ((v74[52] & 1) == 0 || (v74[76] & 1) == 0) {
            goto LABEL_158;
          }
          theArray[0] = *(CMTime *)(v74 + 40);
          CMTime time1 = *(CMTime *)(v74 + 64);
          CMTime type = *(CMTime *)(v74 + 64);
          CMTime time2 = v123;
          int32_t v75 = CMTimeCompare(&type, &time2);
          __int16 v74 = *(char **)(a1 + 224);
          if (v75 < 0)
          {
            CMTime time1 = v123;
            CMTime type = v123;
            figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v74, &type, theArray);
            __int16 v74 = *(char **)(a1 + 224);
          }
          if (v74) {
LABEL_158:
          }
            __int16 v74 = (char *)CFRetain(v74);
          v46[1] = v74;
          *int v46 = CFRetain((CFTypeRef)a1);
          *((_DWORD *)v46 + 4) = v48;
          *((unsigned char *)v46 + 20) = 0;
          __int16 v76 = *(void (**)(id *, uint64_t, uint64_t, CMTime *, CMTime *, CFStringRef, void, uint64_t, float, void *, void (*)(void *, OpaqueCMTimebase *)))(a1 + 40);
          *(unsigned char *)(a1 + 96) = 1;
          uint64_t v77 = *(void *)(a1 + 352);
          uint64_t v78 = *(void *)(a1 + 224);
          uint64_t v79 = *(void *)(v78 + 16);
          float v80 = *(float *)(v78 + 36);
          uint64_t v81 = *(unsigned int *)(a1 + 268);
          CMTime type = theArray[0];
          CMTime time2 = time1;
          v76(v47, v77, v79, &type, &time2, v51, 0, v81, v80, v46, figTimelineCoordinator_timelineControlCommandCompletion);
          if (!v51) {
            goto LABEL_236;
          }
          if (*(unsigned char *)(a1 + 256))
          {
            BOOL v82 = 0;
          }
          else
          {
            CMTime time2 = *(CMTime *)(a1 + 232);
            CMTimeAbsoluteValue(&type, &time2);
            CMTimeMake(&time2, 1, 1);
            BOOL v82 = CMTimeCompare(&type, &time2) >= 0;
          }
          float v102 = *(float *)(*(void *)(a1 + 224) + 36);
          BOOL v104 = v102 != 0.0
              && (uint64_t v103 = *(void *)(a1 + 192), *(float *)(v103 + 36) == 0.0)
              && v102 == *(float *)(v103 + 32);
          if (!*(unsigned char *)(a1 + 258) && v82)
          {
            CMTime v120 = theArray[0];
            double v105 = &v120;
            double v106 = (const void *)a1;
            CFStringRef v107 = v51;
LABEL_217:
            figTimelineCoordinator_postDidIssueSetRateAndTimeCommandNotification(v106, v107, v105, v102);
LABEL_235:
            CFRelease(v51);
LABEL_236:
            CFRelease(v47);
            int v46 = 0;
LABEL_237:
            free(v46);
            *(unsigned char *)(a1 + 304) = 0;
            *(_WORD *)(a1 + 256) = 257;
LABEL_238:
            *(unsigned char *)(a1 + 258) = 1;
            goto LABEL_239;
          }
          if (*(unsigned char *)(a1 + 258))
          {
            char v108 = !v82 || v104;
            if (v108) {
              goto LABEL_235;
            }
            CMTime v120 = theArray[0];
            p_CMTime time2 = &v120;
LABEL_229:
            figTimelineCoordinator_postDidIssueSetTimeCommandNotification((const void *)a1, v51, p_time2);
            goto LABEL_235;
          }
          double v111 = (const void *)a1;
          CFStringRef v112 = v51;
LABEL_234:
          figTimelineCoordinator_postDidIssueSetRateCommandNotification(v111, v112, v102);
          goto LABEL_235;
        }
LABEL_249:
        FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
        goto LABEL_237;
      }
      if (v5 == 1718185504)
      {
        long long v73 = *(const void **)(a1 + 224);
        if (v73)
        {
          CFRelease(v73);
          *(void *)(a1 + 224) = 0;
        }
        goto LABEL_239;
      }
      uint64_t v52 = *(void *)(a1 + 368);
      int v46 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
      char v53 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
      if (!v53) {
        goto LABEL_249;
      }
      BOOL v47 = v53;
      int v54 = *(_DWORD *)(a1 + 100);
      uint64_t v55 = *(void *)(a1 + 224);
      if (*(unsigned char *)(a1 + 262) && (CFUUIDRef v56 = *(const __CFUUID **)(v55 + 24)) != 0)
      {
        CFStringRef v51 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v56);
        uint64_t v55 = *(void *)(a1 + 224);
      }
      else
      {
        CFStringRef v51 = 0;
      }
      BOOL v83 = *(unsigned char *)(a1 + 265) == 0;
      float v84 = *(float *)(v55 + 32);
      if (v84 == 0.0) {
        float v85 = 0.0;
      }
      else {
        float v85 = *(float *)(v55 + 32);
      }
      if (*(_DWORD *)(a1 + 340))
      {
        *(_DWORD *)(a1 + 340) = 0;
        figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
        uint64_t v55 = *(void *)(a1 + 224);
      }
      theArray[0] = *(CMTime *)(v55 + 40);
      if (*(float *)(v55 + 36) != 0.0 && (*(unsigned char *)(v55 + 76) & 1) != 0)
      {
        __int16 v86 = CMClockGetHostTimeClock();
        CMClockGetTime(&v123, v86);
        figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v55, &v123, &time1);
        theArray[0] = time1;
      }
      figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
      CFTypeRef v87 = *(CFTypeRef *)(a1 + 224);
      if (v87) {
        CFTypeRef v87 = CFRetain(v87);
      }
      v46[1] = v87;
      *int v46 = CFRetain((CFTypeRef)a1);
      *((_DWORD *)v46 + 4) = v54;
      *((unsigned char *)v46 + 20) = v84 != 0.0;
      char v88 = *(void (**)(id *, uint64_t, uint64_t, CMTime *, BOOL, BOOL, CFStringRef, uint64_t, float, CMTime *, void *, void (*)(void *, OpaqueCMTimebase *)))(a1 + 48);
      *(unsigned char *)(a1 + 96) = 1;
      uint64_t v89 = *(void *)(a1 + 224);
      uint64_t v90 = *(void *)(v89 + 88);
      uint64_t v91 = *(void *)(v89 + 16);
      if (v84 == 0.0) {
        uint64_t v92 = 0;
      }
      else {
        uint64_t v92 = v52;
      }
      int v93 = *(_DWORD *)(a1 + 268);
      CMTime time1 = theArray[0];
      LODWORD(p_time1) = v93;
      v88(v47, v90, v91, &time1, v83, v84 != 0.0, v51, v92, v85, p_time1, v46, figTimelineCoordinator_timelineControlCommandCompletion);
      if (!v51) {
        goto LABEL_236;
      }
      if (*(unsigned char *)(a1 + 256))
      {
        if (*(unsigned char *)(a1 + 258))
        {
          BOOL v94 = 0;
          goto LABEL_226;
        }
      }
      else
      {
        CMTime type = *(CMTime *)(a1 + 232);
        CMTimeAbsoluteValue(&time1, &type);
        CMTimeMake(&type, 1, 1);
        int32_t v110 = CMTimeCompare(&time1, &type);
        if (*(unsigned char *)(a1 + 258))
        {
          BOOL v94 = v110 >= 0;
LABEL_226:
          if (!*(unsigned char *)(a1 + 257) && !v94) {
            goto LABEL_235;
          }
          CMTime time2 = theArray[0];
          p_CMTime time2 = &time2;
          goto LABEL_229;
        }
        if ((v110 & 0x80000000) == 0)
        {
          CMTime time2 = theArray[0];
          double v105 = &time2;
          double v106 = (const void *)a1;
          CFStringRef v107 = v51;
          float v102 = v85;
          goto LABEL_217;
        }
      }
      double v111 = (const void *)a1;
      CFStringRef v112 = v51;
      float v102 = v85;
      goto LABEL_234;
    }
    if (*(unsigned char *)(a1 + 256))
    {
      if (v4)
      {
        if (!*(unsigned char *)(a1 + 257))
        {
          int v9 = 1885435251;
          goto LABEL_48;
        }
        if (figTimelineCoordinator_timelineControlMustPrepareForCoordinatedStart(a1))
        {
          int v9 = 1886545264;
LABEL_48:
          theArray[0].unsigned int value = 0;
          figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, (const __CFArray **)theArray);
          if ((!theArray[0].value
             || CFArrayGetCount((CFArrayRef)theArray[0].value) != 1
             || !figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(a1, (CFArrayRef)theArray[0].value))&& (!*(void *)(a1 + 368) || *(unsigned char *)(a1 + 361)))
          {
            if (FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328))) {
              double v16 = 5.0;
            }
            else {
              double v16 = 10.0;
            }
            if (v16 + -1.0 <= v16 * 0.5) {
              double v17 = v16 * 0.5;
            }
            else {
              double v17 = v16 + -1.0;
            }
            CFDictionaryRef v18 = *(const void **)(a1 + 368);
            if (v18)
            {
              CFRelease(v18);
              *(void *)(a1 + 368) = 0;
            }
            CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            *(void *)(a1 + 368) = CFDateCreate(v19, v17 + Current);
            int v21 = *(NSObject **)(a1 + 376);
            dispatch_time_t v22 = dispatch_time(0, (uint64_t)(v16 * 1000000000.0));
            dispatch_source_set_timer(v21, v22, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
          }
          if (theArray[0].value) {
            CFRelease((CFTypeRef)theArray[0].value);
          }
LABEL_64:
          if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1) {
            int v9 = 1718185504;
          }
          goto LABEL_66;
        }
        int v9 = 1718185504;
        if (!figTimelineCoordinator_isReadyToPickAnchorTimeForInProgressOnQueue(a1)) {
          goto LABEL_48;
        }
        if (figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E4F1CF80], *(void *)(a1 + 224), &cf))
        {
LABEL_239:
          if (cf) {
            CFRelease(cf);
          }
          return;
        }
        CGFloat v113 = (char *)cf;
        *((_DWORD *)cf + 9) = *(_DWORD *)(*(void *)(a1 + 224) + 32);
        figTimelineCoordinator_pickHostTimeForCoordinatedStart(a1, theArray);
        *(CMTime *)(v113 + 64) = theArray[0];
        size_t v114 = *(const void **)(a1 + 224);
        CFTypeRef v115 = cf;
        *(void *)(a1 + 224) = cf;
        if (v115) {
          CFRetain(v115);
        }
        if (v114) {
          CFRelease(v114);
        }
        *(unsigned char *)(a1 + 257) = 0;
        *(unsigned char *)(a1 + 261) = 0;
      }
      else
      {
        if (figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E4F1CF80], *(void *)(a1 + 224), &cf)) {
          goto LABEL_239;
        }
        uint64_t v13 = *(_DWORD **)(a1 + 224);
        CFTypeRef v14 = cf;
        *((_DWORD *)cf + 9) = v13[8];
        *(void *)(a1 + 224) = v14;
        CFRetain(v14);
        CFRelease(v13);
        *(unsigned char *)(a1 + 261) = 0;
        *(unsigned char *)(a1 + 257) = 0;
      }
      *(unsigned char *)(a1 + 360) = 0;
      uint64_t v15 = *(const void **)(a1 + 368);
      if (v15)
      {
        CFRelease(v15);
        *(void *)(a1 + 368) = 0;
      }
      int v9 = 1918989413;
      figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 376), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
      goto LABEL_64;
    }
    int v9 = 1786080624;
    *(unsigned char *)(a1 + 263) = 1;
    goto LABEL_48;
  }
}

uint64_t figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(uint64_t a1, const __CFArray **a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFArrayRef v5 = Mutable;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 432));
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
      {
        ValueAtIndedouble x = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 432), i);
        v12.length = CFArrayGetCount(v5);
        v12.location = 0;
        if (CFArrayGetFirstIndexOfValue(v5, v12, ValueAtIndex[2]) == -1) {
          CFArrayAppendValue(v5, ValueAtIndex[2]);
        }
      }
    }
    if (a2) {
      *a2 = v5;
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(uint64_t a1, CFArrayRef theArray)
{
  CFIndex v4 = 0;
  while (1)
  {
    CFIndex v5 = theArray ? CFArrayGetCount(theArray) : 0;
    if (v4 >= v5) {
      break;
    }
    ValueAtIndedouble x = CFArrayGetValueAtIndex(theArray, v4++);
    if (FigCFArrayContainsValue(*(const __CFArray **)(a1 + 448), ValueAtIndex)) {
      return 1;
    }
  }
  return 0;
}

__CFString *figTimelineCoordinator_createStateLoggingIdentifier(uint64_t a1, const void *a2, uint64_t a3)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  OriginatorLoggingIdentifier = figTimelineCoordinator_createOriginatorLoggingIdentifier(a2);
  CFStringAppendFormat(Mutable, 0, @"%@%@-%d", a1, OriginatorLoggingIdentifier, a3);
  if (OriginatorLoggingIdentifier) {
    CFRelease(OriginatorLoggingIdentifier);
  }
  return Mutable;
}

BOOL figTimelineCoordinator_everyoneIsSuspended(uint64_t a1)
{
  return CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1
      && figTimelineCoordinator_othersAreSuspended(a1) != 0;
}

uint64_t figTimelineCoordinatorTimelineStateCopy(uint64_t a1, uint64_t a2, void *a3)
{
  CFTypeRef v15 = 0;
  if (a3)
  {
    float v4 = *(float *)(a2 + 32);
    float v5 = *(float *)(a2 + 36);
    int v6 = *(_DWORD *)(a2 + 96);
    uint64_t v7 = *(void *)(a2 + 16);
    long long v13 = *(_OWORD *)(a2 + 40);
    uint64_t v14 = *(void *)(a2 + 56);
    long long v11 = *(_OWORD *)(a2 + 64);
    float v8 = *(const void **)(a2 + 88);
    uint64_t v12 = *(void *)(a2 + 80);
    uint64_t v9 = figTimelineCoordinatorTimelineStateCreateInternal(v4, v5, a1, v8, &v13, &v11, v6, 0, v7, -1, 0, 0, (uint64_t *)&v15);
    if (v9)
    {
      if (v15) {
        CFRelease(v15);
      }
    }
    else
    {
      *a3 = v15;
    }
    return v9;
  }
  else
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
}

BOOL figTimelineCoordinator_timelineControlMustPrepareForCoordinatedStart(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 340) & 1) != 0 || figTimelineCoordinator_havePassedReadinessDeadline(a1)) {
    return 0;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) < 1) {
    return 1;
  }
  return *(unsigned char *)(a1 + 259) != 0;
}

uint64_t figTimelineCoordinator_isReadyToPickAnchorTimeForInProgressOnQueue(uint64_t a1)
{
  CFDictionaryRef Count = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328));
  if (!*(unsigned char *)(a1 + 264)) {
    return 1;
  }
  CFDictionaryRef v3 = Count;
  if (figTimelineCoordinator_anyParticipantIsSuspendedWithOnlyReasonsThatTriggerWaiting(a1)
    || !figTimelineCoordinator_havePassedReadinessDeadline(a1))
  {
    if (!v3) {
      return 0;
    }
  }
  else
  {
    uint64_t result = figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart(a1);
    if (result || !v3) {
      return result;
    }
  }
  if (!*(unsigned char *)(a1 + 263)) {
    return 0;
  }

  return figTimelineCoordinator_isReadyToPickAnchorTimeOnQueue(a1);
}

CMTime *figTimelineCoordinator_pickHostTimeForCoordinatedStart@<X0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  if (FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328)) && !*(unsigned char *)(a1 + 259))
  {
    HostTimeClocuint64_t k = CMClockGetHostTimeClock();
    CMClockGetTime(&lhs, HostTimeClock);
    CMTimeMake(&v9, 1, 1);
    p_CMTime lhs = &lhs;
    int v6 = &v9;
  }
  else
  {
    float v4 = CMClockGetHostTimeClock();
    CMClockGetTime(&v12, v4);
    CMTimeMake(&v11, 1, 10);
    p_CMTime lhs = &v12;
    int v6 = &v11;
  }
  return CMTimeAdd(a2, p_lhs, v6);
}

uint64_t figTimelineCoordinator_othersAreSuspended(uint64_t a1)
{
  CFArrayRef v1 = FigCFDictionaryCopyArrayOfValues(*(const __CFDictionary **)(a1 + 328));
  CFIndex v2 = 0;
  while (1)
  {
    CFIndex v3 = v1 ? CFArrayGetCount(v1) : 0;
    if (v2 >= v3) {
      break;
    }
    ValueAtIndedouble x = (const __CFDictionary **)CFArrayGetValueAtIndex(v1, v2++);
    if (!participantState_isSuspended(ValueAtIndex[2]))
    {
      uint64_t v5 = 0;
      if (!v1) {
        return v5;
      }
      goto LABEL_10;
    }
  }
  uint64_t v5 = 1;
  if (!v1) {
    return v5;
  }
LABEL_10:
  CFRelease(v1);
  return v5;
}

BOOL figTimelineCoordinator_havePassedReadinessDeadline(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v4 = CFDateCreate(v2, Current);
  CFDateRef v5 = v4;
  CFDateRef v6 = *(const __CFDate **)(a1 + 368);
  if (!v6)
  {
    BOOL v7 = 0;
    if (!v4) {
      return v7;
    }
    goto LABEL_3;
  }
  BOOL v7 = CFDateGetTimeIntervalSinceDate(v4, v6) > 0.0;
  if (v5) {
LABEL_3:
  }
    CFRelease(v5);
  return v7;
}

uint64_t figTimelineCoordinator_anyParticipantIsSuspendedWithOnlyReasonsThatTriggerWaiting(uint64_t a1)
{
  CFArrayRef v2 = FigCFDictionaryCopyArrayOfKeys(*(const __CFDictionary **)(a1 + 328));
  CFIndex v3 = 0;
  if (!v2) {
    goto LABEL_3;
  }
LABEL_2:
  for (CFIndex i = CFArrayGetCount(v2); ; CFIndex i = 0)
  {
    if (v3 >= i)
    {
      CFArrayRef v8 = 0;
      uint64_t v9 = 0;
      if (!v2) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    ValueAtIndedouble x = CFArrayGetValueAtIndex(v2, v3);
    CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), ValueAtIndex);
    CFArrayRef v7 = (const __CFArray *)FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons((uint64_t)Value);
    if (!v7) {
      goto LABEL_9;
    }
    CFArrayRef v8 = v7;
    if (CFArrayGetCount(v7) >= 1)
    {
      if (figTimelineCoordinator_groupShouldWaitForAllSuspensions(a1, v8)) {
        break;
      }
    }
    CFRelease(v8);
LABEL_9:
    ++v3;
    if (v2) {
      goto LABEL_2;
    }
LABEL_3:
    ;
  }
  uint64_t v9 = 1;
  if (v2) {
LABEL_12:
  }
    CFRelease(v2);
LABEL_13:
  if (v8) {
    CFRelease(v8);
  }
  return v9;
}

uint64_t figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 360)) {
    return 0;
  }
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v4 = FigCFDictionaryCopyArrayOfValues(*(const __CFDictionary **)(a1 + 328));
  if (v4)
  {
    CFArrayRef v5 = v4;
    if (CFArrayGetCount(v4) >= 1)
    {
      CFIndex v6 = 0;
      do
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex(v5, v6);
        uint64_t v8 = *((void *)ValueAtIndex + 2);
        v27[0] = 0;
        FigCFDictionaryGetBooleanIfPresent(v8, @"CoordinatingStart", v27);
        if (v27[0]) {
          CFArrayAppendValue(Mutable, *((const void **)ValueAtIndex + 4));
        }
        ++v6;
      }
      while (v6 < CFArrayGetCount(v5));
    }
    CFRelease(v5);
  }
  CFIndex v9 = 0;
  do
  {
    if (Mutable) {
      CFIndex Count = CFArrayGetCount(Mutable);
    }
    else {
      CFIndex Count = 0;
    }
    if (v9 >= Count)
    {
      uint64_t v18 = 1;
      if (!Mutable) {
        return v18;
      }
      goto LABEL_23;
    }
    CFUUIDRef v11 = (const __CFUUID *)CFArrayGetValueAtIndex(Mutable, v9++);
  }
  while (figTimelineCoordinator_compareUUIDs(v11, *(const __CFUUID **)(a1 + 344)) != 1);
  CFStringRef v12 = CFUUIDCreateString(v2, v11);
  if (dword_1E9272FB8)
  {
    v21[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, v21, &type);
    int v14 = v21[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v16 = v14;
    }
    else {
      unsigned int v16 = v14 & 0xFFFFFFFE;
    }
    if (v16)
    {
      v21[1] = 136315650;
      dispatch_time_t v22 = "figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart";
      __int16 v23 = 2112;
      uint64_t v24 = a1;
      __int16 v25 = 2112;
      CFStringRef v26 = v12;
      double v17 = (Boolean *)_os_log_send_and_compose_impl();
      LOBYTE(v14) = v21[0];
    }
    else
    {
      double v17 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v17, v17 != v27, v14, 0, v15);
  }
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v18 = 0;
  if (Mutable) {
LABEL_23:
  }
    CFRelease(Mutable);
  return v18;
}

uint64_t figTimelineCoordinator_isReadyToPickAnchorTimeOnQueue(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart(a1)) {
    return 0;
  }
  CFArrayRef v2 = FigCFDictionaryCopyArrayOfKeys(*(const __CFDictionary **)(a1 + 328));
  if (v2)
  {
    CFArrayRef v3 = v2;
    if (CFArrayGetCount(v2) < 1)
    {
      int v5 = 0;
    }
    else
    {
      CFIndex v4 = 0;
      int v5 = 0;
      CFIndex v6 = &sLoadBrowserFrameworkOnce;
      do
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex(v3, v4);
        CFNumberRef Value = (const __CFDictionary **)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), ValueAtIndex);
        if (FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate((uint64_t)Value))
        {
          ++v5;
        }
        else
        {
          CFArrayRef v9 = (const __CFArray *)FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons((uint64_t)Value);
          if (v9)
          {
            CFSetRef v10 = v9;
            if (CFArrayGetCount(v9) >= 1)
            {
              if (figTimelineCoordinator_groupShouldWaitForAllSuspensions(a1, v10))
              {
                if (*((_DWORD *)v6 + 1006))
                {
                  CFUUIDRef v11 = FigCFCopyCompactDescription(v10);
                  if (*((_DWORD *)v6 + 1006))
                  {
                    v23[0] = 0;
                    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, v23, &type);
                    int v13 = v23[0];
                    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
                      unsigned int v15 = v13;
                    }
                    else {
                      unsigned int v15 = v13 & 0xFFFFFFFE;
                    }
                    if (v15)
                    {
                      CFStringRef StateLoggingIdentifier = FigParticipantStateDictionaryGetStateLoggingIdentifier(Value[2]);
                      v23[1] = 136315906;
                      uint64_t v24 = "figTimelineCoordinator_areAllOtherParticipantsReady";
                      __int16 v25 = 2112;
                      uint64_t v26 = a1;
                      __int16 v27 = 2114;
                      uint64_t v28 = v11;
                      __int16 v29 = 2114;
                      int v30 = StateLoggingIdentifier;
                      double v17 = (char *)_os_log_send_and_compose_impl();
                      LOBYTE(v13) = v23[0];
                    }
                    else
                    {
                      double v17 = 0;
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v17, v17 != &v31, v13, 0, v14);
                    CFIndex v6 = &sLoadBrowserFrameworkOnce;
                  }
                  if (v11) {
                    CFRelease(v11);
                  }
                }
              }
              else
              {
                ++v5;
              }
            }
            CFRelease(v10);
          }
        }
        ++v4;
      }
      while (v4 < CFArrayGetCount(v3));
    }
    CFIndex Count = CFArrayGetCount(v3);
    CFRelease(v3);
    if (Count != v5) {
      goto LABEL_31;
    }
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1
    && ((figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, (const __CFArray **)&cf),
         figTimelineCoordinator_groupShouldWaitForAllSuspensions(a1, (CFArrayRef)cf))
     || figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(a1, (CFArrayRef)cf)))
  {
LABEL_31:
    uint64_t v18 = 0;
  }
  else
  {
    uint64_t v18 = 1;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v18;
}

uint64_t figTimelineCoordinator_groupShouldWaitForAllSuspensions(uint64_t a1, CFArrayRef theArray)
{
  if (!theArray) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    CFArrayRef v7 = (const void *)*MEMORY[0x1E4F1CFD0];
    while (1)
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex(theArray, v6);
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
      CFNumberRef Value = FigCFDictionaryGetValue(*(const void **)(a1 + 400), ValueAtIndex);
      if (FigCFDictionaryGetValue(Value, @"ShouldWait") != v7) {
        break;
      }
      int v13 = 0;
      if (FigCFDictionaryGetInt32IfPresent((uint64_t)Value, @"ParticipantLimit", &v13))
      {
        CFDictionaryRef v10 = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328));
        uint64_t v11 = v13;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        if ((uint64_t)v10 >= v11) {
          return 0;
        }
      }
      else
      {
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
      }
      if (v5 == ++v6) {
        return 1;
      }
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
  }
  return 0;
}

uint64_t figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 200);
  if (v1
    && *(void *)(v1 + 88)
    && (*(float *)(v1 + 36) == 0.0 || (*(_DWORD *)(v1 + 76) & 0x1D) == 1)
    && (*(_DWORD *)(v1 + 52) & 0x1D) == 1
    && *(void *)(a1 + 352))
  {
    CFArrayRef v3 = *(id **)(a1 + 160);
    if (!v3) {
      return 0;
    }
    CFIndex v4 = FigCFWeakReferenceHolderCopyReferencedObject(v3);
    if (v4)
    {
      CFIndex v5 = v4;
      CFIndex v6 = *(const void **)(a1 + 344);
      if (v6)
      {
        if (*(unsigned char *)(a1 + 280))
        {
          uint64_t v7 = *(void *)(a1 + 200);
          if (!*(void *)(v7 + 24))
          {
            *(void *)(v7 + 24) = v6;
            CFRetain(v6);
            uint64_t v7 = *(void *)(a1 + 200);
          }
          int v51 = 0;
          if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 464), *(const void **)(v7 + 88)))
          {
            FigCFDictionaryGetInt32IfPresent(*(void *)(a1 + 464), *(const void **)(*(void *)(a1 + 200) + 88), &v51);
            int v8 = v51;
          }
          else
          {
            int v8 = 0;
          }
          int v16 = v8 + 1;
          *(_DWORD *)(a1 + 456) = v8 + 1;
          uint64_t v17 = *(void *)(a1 + 200);
          *(_DWORD *)(v17 + 100) = v16;
          FigCFDictionarySetInt32(*(void **)(a1 + 464), *(const void **)(v17 + 88), v16);
          uint64_t v18 = *(void *)(a1 + 200);
          CFTypeRef cf = 0;
          if (!v18)
          {
            uint64_t v29 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
            CFMutableDictionaryRef Mutable = 0;
            if (v29)
            {
LABEL_74:
              CFRelease(v5);
              if (Mutable) {
                CFRelease(Mutable);
              }
              return v29;
            }
LABEL_46:
            if (dword_1E9272FB8)
            {
              int v30 = FigCFCopyCompactDescription(Mutable);
              if (dword_1E9272FB8)
              {
                LODWORD(v54.value) = 0;
                LOBYTE(type.value) = 0;
                os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v54, &type);
                unsigned int value = v54.value;
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value)) {
                  unsigned int v34 = value;
                }
                else {
                  unsigned int v34 = value & 0xFFFFFFFE;
                }
                if (v34)
                {
                  LODWORD(v56.value) = 136315650;
                  *(CMTimeValue *)((char *)&v56.value + 4) = (CMTimeValue)"figTimelineCoordinator_sendExpectedTimelineSta"
                                                                          "teToGroupOnQueue";
                  LOWORD(v56.flags) = 2112;
                  *(void *)((char *)&v56.flags + 2) = a1;
                  HIWORD(v56.epoch) = 2114;
                  uint64_t v57 = v30;
                  int v35 = (CMTime *)_os_log_send_and_compose_impl();
                  LOBYTE(value) = v54.value;
                }
                else
                {
                  int v35 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v35, v35 != &time, value, 0, v33);
              }
              if (v30) {
                CFRelease(v30);
              }
            }
            int v48 = *(void (**)(id *, CFMutableDictionaryRef))(a1 + 136);
            *(unsigned char *)(a1 + 281) = 0;
            v48(v5, Mutable);
            goto LABEL_74;
          }
          CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(Mutable, @"Identifier", *(const void **)(v18 + 88));
          CFStringRef v21 = CFUUIDCreateString(v19, *(CFUUIDRef *)(v18 + 24));
          CFDictionarySetValue(Mutable, @"OriginatorUUID", v21);
          FigCFDictionarySetFloat32(Mutable, @"Rate", *(float *)(v18 + 36));
          FigCFDictionarySetInt32(Mutable, @"LamportTimestamp", *(_DWORD *)(v18 + 100));
          if (*(float *)(v18 + 36) == 0.0)
          {
            FigCFDictionarySetInt32(Mutable, @"SeekPrecision", *(_DWORD *)(v18 + 96));
            FigCFDictionarySetInt32(Mutable, @"PrerollRate", (int)*(float *)(v18 + 32));
            CMTime time = *(CMTime *)(v18 + 40);
            double Seconds = CMTimeGetSeconds(&time);
            FigCFDictionarySetDouble(Mutable, @"Time", Seconds);
          }
          else
          {
            CMTime time = *(CMTime *)(v18 + 40);
            CMTime v56 = *(CMTime *)(v18 + 64);
            memset(&v54, 0, sizeof(v54));
            dispatch_time_t v22 = *(void **)(a1 + 176);
            CMTime type = *(CMTime *)(v18 + 64);
            uint64_t v23 = FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime(v22, &type, (CFDictionaryRef *)&cf);
            if (v23) {
              goto LABEL_90;
            }
            HostTimeClocuint64_t k = CMClockGetHostTimeClock();
            CMClockGetTime(&v54, HostTimeClock);
            CMTime type = v56;
            CMTime time2 = v54;
            if (CMTimeCompare(&type, &time2) < 0)
            {
              CMTime v56 = v54;
              CMTime type = v54;
              figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v18, &type, &time);
              if (cf)
              {
                CFRelease(cf);
                CFTypeRef cf = 0;
              }
              __int16 v25 = *(void **)(a1 + 176);
              CMTime type = v56;
              uint64_t v23 = FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime(v25, &type, (CFDictionaryRef *)&cf);
              if (v23)
              {
LABEL_90:
                uint64_t v29 = FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
                if (Mutable)
                {
                  CFRelease(Mutable);
                  CFMutableDictionaryRef Mutable = 0;
                }
                CFStringRef StateLoggingIdentifier = 0;
LABEL_39:
                if (cf) {
                  CFRelease(cf);
                }
                if (StateLoggingIdentifier) {
                  CFRelease(StateLoggingIdentifier);
                }
                if (v21) {
                  CFRelease(v21);
                }
                if (v29) {
                  goto LABEL_74;
                }
                goto LABEL_46;
              }
            }
            CMTime type = time;
            double v26 = CMTimeGetSeconds(&type);
            FigCFDictionarySetDouble(Mutable, @"Time", v26);
            CFDictionarySetValue(Mutable, @"NetworkTime", cf);
          }
          if (FigDebugIsInternalBuild())
          {
            CFStringRef StateLoggingIdentifier = figTimelineCoordinator_createStateLoggingIdentifier(@"T/", v21, *(unsigned int *)(a1 + 384));
            FigCFDictionarySetValue(Mutable, @"DebugInfo", StateLoggingIdentifier);
          }
          else
          {
            CFStringRef StateLoggingIdentifier = 0;
          }
          uint64_t v29 = 0;
          ++*(_DWORD *)(a1 + 384);
          goto LABEL_39;
        }
        if (FigCFEqual(*(CFTypeRef *)(a1 + 352), *(CFTypeRef *)(a1 + 272)))
        {
          if (dword_1E9272FB8)
          {
            LODWORD(v54.value) = 0;
            LOBYTE(type.value) = 0;
            CFDictionaryRef v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v54, &type);
            unsigned int v11 = v54.value;
            if (os_log_type_enabled(v10, type.value)) {
              unsigned int v13 = v11;
            }
            else {
              unsigned int v13 = v11 & 0xFFFFFFFE;
            }
            if (v13)
            {
              uint64_t v14 = *(__CFString **)(a1 + 352);
              LODWORD(v56.value) = 136315650;
              *(CMTimeValue *)((char *)&v56.value + 4) = (CMTimeValue)"figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue";
              LOWORD(v56.flags) = 2112;
              *(void *)((char *)&v56.flags + 2) = a1;
              HIWORD(v56.epoch) = 2114;
              uint64_t v57 = v14;
              unsigned int v15 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v11) = v54.value;
            }
            else
            {
              unsigned int v15 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v15, v15 != &time, v11, 0, v12);
          }
          int v49 = *(const void **)(a1 + 288);
          CFUUIDRef v50 = *(const void **)(a1 + 200);
          *(void *)(a1 + 288) = v50;
          if (v50) {
            CFRetain(v50);
          }
          if (v49) {
            CFRelease(v49);
          }
        }
        else
        {
          int v36 = *(const void **)(a1 + 272);
          uint64_t v37 = *(const void **)(a1 + 352);
          *(void *)(a1 + 272) = v37;
          if (v37) {
            CFRetain(v37);
          }
          if (v36) {
            CFRelease(v36);
          }
          float v38 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
          *float v38 = CFRetain((CFTypeRef)a1);
          CFTypeRef v39 = *(CFTypeRef *)(a1 + 352);
          if (v39) {
            CFTypeRef v39 = CFRetain(v39);
          }
          v38[1] = v39;
          uint64_t v40 = *(const void **)(a1 + 288);
          int v41 = *(const void **)(a1 + 200);
          *(void *)(a1 + 288) = v41;
          if (v41) {
            CFRetain(v41);
          }
          if (v40) {
            CFRelease(v40);
          }
          if (dword_1E9272FB8)
          {
            LODWORD(v54.value) = 0;
            LOBYTE(type.value) = 0;
            int v42 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v54, &type);
            unsigned int v43 = v54.value;
            if (os_log_type_enabled(v42, type.value)) {
              unsigned int v45 = v43;
            }
            else {
              unsigned int v45 = v43 & 0xFFFFFFFE;
            }
            if (v45)
            {
              int v46 = *(__CFString **)(a1 + 352);
              LODWORD(v56.value) = 136315650;
              *(CMTimeValue *)((char *)&v56.value + 4) = (CMTimeValue)"figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue";
              LOWORD(v56.flags) = 2112;
              *(void *)((char *)&v56.flags + 2) = a1;
              HIWORD(v56.epoch) = 2114;
              uint64_t v57 = v46;
              BOOL v47 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v43) = v54.value;
            }
            else
            {
              BOOL v47 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v47, v47 != &time, v43, 0, v44);
          }
          (*(void (**)(id *, void, void *, void (*)(void *)))(a1 + 152))(v5, *(void *)(a1 + 352), v38, figTimelineCoordinator_reloadCompleteCallback);
        }
      }
      CFRelease(v5);
      return 0;
    }
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

void figTimelineCoordinator_reloadCompleteCallback(void *context)
{
}

void figTimelineCoordinator_fetchCompleteCallbackOnQueue(CFTypeRef *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFTypeRef v2 = *a1;
  if (FigCFEqual(a1[1], *((CFTypeRef *)*a1 + 44)))
  {
    if (dword_1E9272FB8)
    {
      int v22 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v22, &type);
      int v4 = v22;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v6 = v4;
      }
      else {
        unsigned int v6 = v4 & 0xFFFFFFFE;
      }
      if (v6)
      {
        uint64_t v7 = *((void *)v2 + 44);
        if (*((void *)v2 + 36)) {
          int v8 = "Did NOT";
        }
        else {
          int v8 = "Did";
        }
        int v23 = 136315906;
        uint64_t v24 = "figTimelineCoordinator_fetchCompleteCallbackOnQueue";
        __int16 v25 = 2112;
        CFTypeRef v26 = v2;
        __int16 v27 = 2114;
        uint64_t v28 = v7;
        __int16 v29 = 2082;
        int v30 = v8;
        CFArrayRef v9 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v22;
      }
      else
      {
        CFArrayRef v9 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v9, v9 != v31, v4, 0, v5);
    }
    *((unsigned char *)v2 + 280) = 1;
    int v16 = (const void *)*((void *)v2 + 34);
    if (v16)
    {
      CFRelease(v16);
      *((void *)v2 + 34) = 0;
    }
  }
  else if (dword_1E9272FB8)
  {
    int v22 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    CFDictionaryRef v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, &v22, &type);
    int v11 = v22;
    if (os_log_type_enabled(v10, type)) {
      unsigned int v13 = v11;
    }
    else {
      unsigned int v13 = v11 & 0xFFFFFFFE;
    }
    if (v13)
    {
      uint64_t v14 = *((void *)v2 + 44);
      int v23 = 136315650;
      uint64_t v24 = "figTimelineCoordinator_fetchCompleteCallbackOnQueue";
      __int16 v25 = 2112;
      CFTypeRef v26 = v2;
      __int16 v27 = 2114;
      uint64_t v28 = v14;
      unsigned int v15 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v11) = v22;
    }
    else
    {
      unsigned int v15 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v15, v15 != v31, v11, 0, v12);
  }
  if (FigCFEqual(a1[1], *((CFTypeRef *)v2 + 34)))
  {
    uint64_t v17 = (const void *)*((void *)v2 + 34);
    if (v17)
    {
      CFRelease(v17);
      *((void *)v2 + 34) = 0;
    }
  }
  uint64_t v18 = *((void *)v2 + 36);
  if (v18)
  {
    if (v18 == *((void *)v2 + 25))
    {
      if (FigCFEqual(a1[1], *(CFTypeRef *)(v18 + 88)))
      {
        figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(v2);
        uint64_t v20 = (const void *)*((void *)v2 + 36);
        if (v20)
        {
          CFRelease(v20);
          *((void *)v2 + 36) = 0;
        }
      }
    }
  }
  CFTypeRef v19 = a1[1];
  if (v19) {
    CFRelease(v19);
  }
  CFRelease(v2);
  free(a1);
}

void figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 112);
  if (v1)
  {
    dispatch_time_t v2 = dispatch_time(0, 60000000000);
    dispatch_source_set_timer(v1, v2, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

void figTimelineCoordinator_postDidIssueSetRateAndTimeCommandNotification(const void *a1, const void *a2, CMTime *a3, float a4)
{
  CFTypeRef cf = 0;
  int DidIssueCommandNotificationPayload = figTimelineCoordinator_createDidIssueCommandNotificationPayload(@"SetRateAndTime", a2, (__CFDictionary **)&cf);
  CFDictionaryRef v8 = (const __CFDictionary *)cf;
  if (!DidIssueCommandNotificationPayload && !FigCFDictionarySetFloat32((void *)cf, @"Rate", a4))
  {
    CMTime v9 = *a3;
    if (!FigCFDictionarySetCMTime(v8, @"Time", &v9)) {
      figTimelineCoordinator_postDidIssueCommandNotification(a1, v8);
    }
  }
  if (v8) {
    CFRelease(v8);
  }
}

void figTimelineCoordinator_postDidIssueSetRateCommandNotification(const void *a1, const void *a2, float a3)
{
  CFTypeRef cf = 0;
  int DidIssueCommandNotificationPayload = figTimelineCoordinator_createDidIssueCommandNotificationPayload(@"SetRate", a2, (__CFDictionary **)&cf);
  CFDictionaryRef v6 = (const __CFDictionary *)cf;
  if (!DidIssueCommandNotificationPayload && !FigCFDictionarySetFloat32((void *)cf, @"Rate", a3)) {
    figTimelineCoordinator_postDidIssueCommandNotification(a1, v6);
  }
  if (v6)
  {
    CFRelease(v6);
  }
}

void figTimelineCoordinator_postDidIssueSetTimeCommandNotification(const void *a1, const void *a2, CMTime *a3)
{
  CFTypeRef cf = 0;
  int DidIssueCommandNotificationPayload = figTimelineCoordinator_createDidIssueCommandNotificationPayload(@"SetTime", a2, (__CFDictionary **)&cf);
  CFDictionaryRef v6 = (const __CFDictionary *)cf;
  if (!DidIssueCommandNotificationPayload)
  {
    CMTime v7 = *a3;
    if (!FigCFDictionarySetCMTime((void *)cf, @"Time", &v7)) {
      figTimelineCoordinator_postDidIssueCommandNotification(a1, v6);
    }
  }
  if (v6) {
    CFRelease(v6);
  }
}

uint64_t figTimelineCoordinator_createDidIssueCommandNotificationPayload(const void *a1, const void *a2, __CFDictionary **a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CMTime v7 = Mutable;
    CFDictionarySetValue(Mutable, @"Command", a1);
    if (a2) {
      CFDictionarySetValue(v7, @"ParticipantUUID", a2);
    }
    *a3 = v7;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figTimelineCoordinator_postDidIssueCommandNotification(const void *a1, const __CFDictionary *a2)
{
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  uint64_t result = CMNotificationCenterPostNotification(DefaultLocalCenter, @"DidIssueCommandToTimelineControl", a1, a2);
  if (result)
  {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t figTimelineCoordinatorParticipantCreateFromDictionary(int a1, CFDictionaryRef theDict, const void *a3, uint64_t *a4)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"UUID");
  CFStringRef v8 = Value;
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFStringGetTypeID()) {
      CFStringRef v8 = (const __CFString *)CFUUIDCreateFromString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8);
    }
    else {
      CFStringRef v8 = 0;
    }
  }
  if (!a4 || !theDict)
  {
    uint64_t v13 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    if (!v8) {
      return v13;
    }
    goto LABEL_15;
  }
  if (v8)
  {
    if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1) {
      dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v11 = Instance;
      *(void *)(Instance + 16) = CFRetain(theDict);
      if (a3) {
        CFTypeRef v12 = CFRetain(a3);
      }
      else {
        CFTypeRef v12 = 0;
      }
      *(void *)(v11 + 24) = v12;
      uint64_t v13 = 0;
      *(void *)(v11 + 32) = CFRetain(v8);
      *a4 = v11;
    }
    else
    {
      uint64_t v13 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
    }
LABEL_15:
    CFRelease(v8);
    return v13;
  }

  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

void figTimelineCoordinator_integrateParticipantStateOnQueue(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  CFArrayRef v3 = *(const void **)(a2 + 32);
  CFTypeRef cf = 0;
  if (v3)
  {
    if (FigCFEqual(*(CFTypeRef *)(a1 + 344), v3))
    {
      uint64_t v7 = *(void *)(a2 + 16);
      LOBYTE(v64) = 0;
      FigCFDictionaryGetBooleanIfPresent(v7, @"CoordinatingStart", (Boolean *)&v64);
      if ((_BYTE)v64) {
        *(unsigned char *)(a1 + 360) = 1;
      }
      goto LABEL_64;
    }
    CFStringRef Value = (CFTypeRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), v3);
    uint64_t v9 = (uint64_t)Value;
    if (Value)
    {
      CFDictionaryRef v10 = a3;
      int v11 = FigCFEqual(Value[4], *(CFTypeRef *)(a2 + 32));
      CFTypeRef v12 = FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(v9);
      CFTypeRef v13 = FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(a2);
      int v14 = FigCFEqual(v12, v13);
      unsigned int v15 = FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(v9);
      BOOL v16 = v15 == FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(a2);
      BOOL v53 = v14 != 0;
      if (v14) {
        BOOL v17 = v16;
      }
      else {
        BOOL v17 = 0;
      }
      if (v11) {
        BOOL v18 = v17;
      }
      else {
        BOOL v18 = 0;
      }
      if (v12) {
        CFRelease(v12);
      }
      if (v13) {
        CFRelease(v13);
      }
      a3 = v10;
      if (v18)
      {
        char v19 = 0;
        goto LABEL_35;
      }
    }
    else
    {
      BOOL v16 = 0;
      BOOL v53 = 0;
    }
    if (dword_1E9272FB8)
    {
      uint64_t v20 = FigCFCopyCompactDescription(*(const __CFSet **)(a2 + 16));
      if (dword_1E9272FB8)
      {
        uint64_t v52 = a3;
        LODWORD(v56) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v56, type);
        unsigned int v22 = v56;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
          unsigned int v24 = v22;
        }
        else {
          unsigned int v24 = v22 & 0xFFFFFFFE;
        }
        if (v24)
        {
          __int16 v25 = " [Suspensions]";
          *(void *)&v58[4] = "figTimelineCoordinator_integrateParticipantStateOnQueue";
          CFTypeRef v26 = "";
          *(_DWORD *)uint64_t v58 = 136316162;
          if (v53) {
            __int16 v25 = "";
          }
          *(_WORD *)&v58[12] = 2112;
          *(void *)&v58[14] = a1;
          uint64_t v59 = v25;
          *(_WORD *)&v58[22] = 2082;
          if (!v16) {
            CFTypeRef v26 = " [Readiness]";
          }
          __int16 v60 = 2082;
          int v61 = v26;
          __int16 v62 = 2114;
          CFUUIDRef v63 = v20;
          __int16 v27 = (long long *)_os_log_send_and_compose_impl();
          LOBYTE(v22) = v56;
        }
        else
        {
          __int16 v27 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v27, v27 != &v64, v22, 0, v23);
        a3 = v52;
      }
      if (v20) {
        CFRelease(v20);
      }
    }
    char v19 = 1;
    if (!v9)
    {
LABEL_36:
      if (participantState_isSuspended(*(const __CFDictionary **)(a2 + 16)))
      {
        if (dword_1E9272FB8)
        {
          LODWORD(v56) = 0;
          type[0] = OS_LOG_TYPE_DEFAULT;
          uint64_t v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)&v56, type);
          unsigned int v29 = v56;
          if (os_log_type_enabled(v28, type[0])) {
            unsigned int v31 = v29;
          }
          else {
            unsigned int v31 = v29 & 0xFFFFFFFE;
          }
          if (v31)
          {
            *(_DWORD *)uint64_t v58 = 136315394;
            *(void *)&v58[4] = "figTimelineCoordinator_integrateParticipantStateOnQueue";
            *(_WORD *)&v58[12] = 2112;
            *(void *)&v58[14] = a1;
            uint64_t v32 = (long long *)_os_log_send_and_compose_impl();
            LOBYTE(v29) = v56;
          }
          else
          {
            uint64_t v32 = 0;
          }
          int v33 = 1;
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v32, v32 != &v64, v29, 0, v30);
        }
        else
        {
          int v33 = 1;
        }
        goto LABEL_47;
      }
LABEL_43:
      int v33 = 0;
LABEL_47:
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 328), v3, (const void *)a2);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
      figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, (const __CFArray **)&cf);
      BOOL IsSuspended = figTimelineCoordinator_everyoneIsSuspended(a1);
      if (v33)
      {
        if (IsSuspended)
        {
          if (*(void *)(a1 + 208))
          {
            uint64_t v35 = *(void *)(a1 + 200);
            if (!v35 || *(float *)(v35 + 36) != 0.0)
            {
              uint64_t v56 = 0;
              if (dword_1E9272FB8)
              {
                *(_DWORD *)os_log_type_t type = 0;
                os_log_type_t v54 = OS_LOG_TYPE_DEFAULT;
                int v36 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FB0, 1, (int *)type, &v54);
                unsigned int v37 = *(_DWORD *)type;
                if (os_log_type_enabled(v36, v54)) {
                  unsigned int v39 = v37;
                }
                else {
                  unsigned int v39 = v37 & 0xFFFFFFFE;
                }
                if (v39)
                {
                  uint64_t v40 = *(const char **)(a1 + 200);
                  int v41 = *(const char **)(a1 + 208);
                  *(_DWORD *)uint64_t v58 = 136315906;
                  *(void *)&v58[4] = "figTimelineCoordinator_integrateParticipantStateOnQueue";
                  *(_WORD *)&v58[12] = 2112;
                  *(void *)&v58[14] = a1;
                  *(_WORD *)&v58[22] = 2112;
                  uint64_t v59 = v40;
                  __int16 v60 = 2112;
                  int v61 = v41;
                  int v42 = (long long *)_os_log_send_and_compose_impl();
                  LOBYTE(v37) = type[0];
                }
                else
                {
                  int v42 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FB0, 1u, 1, v42, v42 != &v64, v37, 0, v38);
              }
              FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
              unsigned int v43 = *(pthread_mutex_t **)(a1 + 16);
              uint64_t v44 = *(void *)(a1 + 24);
              *(void *)(a1 + 24) = v44 + 1;
              FigSimpleMutexUnlock(v43);
              uint64_t v45 = *MEMORY[0x1E4F1CF80];
              uint64_t v46 = *(void *)(a1 + 208);
              float v47 = *(float *)(v46 + 32);
              float v48 = *(float *)(v46 + 36);
              CFUUIDRef v50 = *(const void **)(a1 + 344);
              int v49 = *(const void **)(a1 + 352);
              long long v64 = *(_OWORD *)(v46 + 40);
              uint64_t v65 = *(void *)(v46 + 56);
              memset(v58, 0, sizeof(v58));
              if (figTimelineCoordinatorTimelineStateCreateInternal(v47, v48, v45, v49, &v64, (long long *)v58, 0, v50, v44, -1, 0, 0, &v56))goto LABEL_64; {
              *(unsigned char *)(a1 + 360) = 1;
              }
              figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(a1, v56, 7u, 1, 0, 1, 1, 1);
              int v51 = *(const void **)(a1 + 208);
              if (v51)
              {
                CFRelease(v51);
                *(void *)(a1 + 208) = 0;
              }
            }
          }
        }
      }
      *a3 = v19;
LABEL_64:
      if (cf) {
        CFRelease(cf);
      }
      return;
    }
LABEL_35:
    if (participantState_isSuspended(*(const __CFDictionary **)(v9 + 16))) {
      goto LABEL_43;
    }
    goto LABEL_36;
  }

  FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

void figTimelineCoordinator_postParticipantsDidChange(const __CFDictionary **a1)
{
  CFArrayRef v2 = FigCFDictionaryCopyArrayOfKeys(a1[41]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef v4 = Mutable;
  if (Mutable)
  {
    if (v2) {
      CFDictionarySetValue(Mutable, @"ParticipantUUIDs", v2);
    }
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, @"ParticipantsDidChange", a1, v4);
    if (v2) {
      goto LABEL_5;
    }
  }
  else
  {
    FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
    if (v2) {
LABEL_5:
    }
      CFRelease(v2);
  }
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(uint64_t result)
{
  if (!*(unsigned char *)(result + 96))
  {
    uint64_t v1 = result;
    uint64_t result = figTimelineCoordinator_isReadyToPickAnchorTimeOnQueue(result);
    if (result)
    {
      if (*(void *)(v1 + 200))
      {
        return figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v1);
      }
    }
  }
  return result;
}

void figTimelineCoordinator_reapplyExpectedTimelineOnQueue(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4 = *(void *)(a1 + 200);
  if (v4) {
    figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(a1, v4, a3, 1, 1, a2 == 0, a2 == 0, 1);
  }
}

void figTimelineCoordinator_coordinateTimeJumpOnQueue(uint64_t a1, CMTime *a2, int a3, uint64_t a4, uint64_t a5, void *a6)
{
  Boolean v32 = 0;
  float v31 = 0.0;
  CFTypeRef cf = 0;
  char v29 = 0;
  if (!*(void *)(a1 + 352)) {
    goto LABEL_33;
  }
  FigCFDictionaryGetBooleanIfPresent(a4, @"AlreadyCompletedJump", (Boolean *)&v29);
  FigCFDictionaryGetBooleanIfPresent(a4, @"ResumeImmediately", &v32);
  int Float32IfPresent = FigCFDictionaryGetFloat32IfPresent(a4, @"AlreadyPreparedForRate", &v31);
  char v13 = v32 == 0;
  if (a3 && (uint64_t v14 = *(void *)(a1 + 200)) != 0)
  {
    float v15 = *(float *)(v14 + 36);
    int v16 = 1;
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 192);
    if (!v14)
    {
      int v16 = 0;
      float v15 = 0.0;
      goto LABEL_10;
    }
    int v16 = 0;
    float v15 = *(float *)(v14 + 36);
  }
  if (v15 == 0.0) {
    float v15 = *(float *)(v14 + 32);
  }
LABEL_10:
  int v18 = v15 == v31 && Float32IfPresent != 0;
  if (!*(unsigned char *)(a1 + 304))
  {
    int v18 = 0;
    char v29 = 0;
    int v16 = 1;
  }
  float v19 = 0.0;
  if (v15 == 0.0 || CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) > 0)
  {
    int v18 = 0;
LABEL_21:
    if (v18 == *(_DWORD *)(a1 + 340)) {
      goto LABEL_25;
    }
    uint64_t v20 = (_DWORD *)(a1 + 340);
    float v21 = v15;
    float v15 = v19;
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 360))
  {
    float v19 = v15;
    float v15 = 0.0;
    goto LABEL_21;
  }
  *(unsigned char *)(a1 + 360) = 1;
  float v21 = 0.0;
  if (v18 == *(_DWORD *)(a1 + 340)) {
    goto LABEL_24;
  }
  uint64_t v20 = (_DWORD *)(a1 + 340);
LABEL_23:
  *uint64_t v20 = v18;
LABEL_24:
  float v19 = v15;
  figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
  float v15 = v21;
LABEL_25:
  uint64_t v22 = *MEMORY[0x1E4F1CF80];
  unsigned int v24 = *(const void **)(a1 + 344);
  uint64_t v23 = *(const void **)(a1 + 352);
  CMTime v28 = *a2;
  long long v26 = *(_OWORD *)&kCMTimeInvalid.value;
  uint64_t v27 = 0;
  if (!figTimelineCoordinatorTimelineStateCreateInternal(v19, v15, v22, v23, (long long *)&v28.value, &v26, 0, v24, a5, -1, 0, 0, (uint64_t *)&cf))
  {
    if (a6)
    {
      CFTypeRef v25 = cf;
      if (cf) {
        CFTypeRef v25 = CFRetain(cf);
      }
      *a6 = v25;
    }
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) <= 0)
    {
      CMTime v28 = *a2;
      figTimelineCoordinator_postDidIssueSetTimeCommandNotification((const void *)a1, 0, &v28);
    }
    figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(a1, (uint64_t)cf, 1u, v13, 0, v29, v16 == 0, 1);
  }
LABEL_33:
  if (cf) {
    CFRelease(cf);
  }
}

void figTimelineCoordinator_timelineControlCommandCompletionOnQueue(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  figTimelineCoordinator_suspendTimelineControlCommandCompletionTimer(*(void *)a1);
  *(unsigned char *)(*(void *)a1 + 96) = 0;
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 != *(_DWORD *)(v2 + 100))
  {
    uint64_t v4 = *(const void **)(a1 + 24);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 24) = 0;
    }
    int v3 = *(_DWORD *)(v2 + 100);
  }
  *(_DWORD *)(v2 + 100) = v3 + 1;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(v2 + 224);
  if (v5 != v6)
  {
    if (v5 && v6 && FigCFEqual(*(CFTypeRef *)(v6 + 88), *(CFTypeRef *)(v5 + 88)))
    {
      uint64_t v7 = *(void *)(v6 + 88);
      if (v7) {
        LOBYTE(v7) = (*(float *)(v6 + 36) == 0.0 || (*(_DWORD *)(v6 + 76) & 0x1D) == 1)
      }
                  && (*(_DWORD *)(v6 + 52) & 0x1D) == 1;
      if (*(void *)(v5 + 88) && (*(float *)(v5 + 36) == 0.0 || (*(_DWORD *)(v5 + 76) & 0x1D) == 1)) {
        LOBYTE(v7) = v7 ^ ((*(_DWORD *)(v5 + 52) & 0x1D) == 1);
      }
      if ((v7 & 1) == 0)
      {
        CMTime time1 = *(CMTime *)(v6 + 40);
        CMTime time2 = *(CMTime *)(v5 + 40);
        if (!CMTimeCompare(&time1, &time2)
          && *(_DWORD *)(v6 + 100) - *(_DWORD *)(v5 + 100) == 1
          && *(float *)(v6 + 36) == *(float *)(v5 + 32)
          && (*(unsigned char *)(v6 + 76) & 1) != 0)
        {
          *(_WORD *)(v2 + 256) = 0;
          *(unsigned char *)(v2 + 258) = 0;
        }
      }
    }
LABEL_51:
    figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(v2);
    goto LABEL_52;
  }
  CFStringRef v8 = *(const void **)(v2 + 296);
  uint64_t v9 = *(const void **)(a1 + 24);
  *(void *)(v2 + 296) = v9;
  if (v9) {
    CFRetain(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v10 = *(void *)(v2 + 296);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    if (*(void *)(v11 + 88)
      && (*(float *)(v11 + 36) == 0.0 || (*(_DWORD *)(v11 + 76) & 0x1D) == 1)
      && (*(_DWORD *)(v11 + 52) & 0x1D) == 1)
    {
      CMTimeMake(&v24, 5, 1);
      if (!figTimelineCoordinator_timelinesMatch(v10, v11, &v24, 0))
      {
        memset(&time1, 0, sizeof(time1));
        HostTimeClocuint64_t k = CMClockGetHostTimeClock();
        CMClockGetTime(&time1, HostTimeClock);
      }
    }
    uint64_t v13 = *(void *)(v2 + 224);
    if (!*(void *)(v13 + 88)
      || *(float *)(v13 + 36) != 0.0 && (*(_DWORD *)(v13 + 76) & 0x1D) != 1
      || (*(_DWORD *)(v13 + 52) & 0x1D) != 1)
    {
      uint64_t v14 = *(void *)(v2 + 296);
      *(_DWORD *)(v13 + 36) = *(_DWORD *)(v14 + 36);
      long long v15 = *(_OWORD *)(v14 + 40);
      *(void *)(v13 + 56) = *(void *)(v14 + 56);
      *(_OWORD *)(v13 + 40) = v15;
      uint64_t v16 = *(void *)(v2 + 224);
      uint64_t v17 = *(void *)(v2 + 296);
      long long v18 = *(_OWORD *)(v17 + 64);
      *(void *)(v16 + 80) = *(void *)(v17 + 80);
      *(_OWORD *)(v16 + 64) = v18;
    }
    *(unsigned char *)(v2 + 304) = 1;
  }
  else if (!*(unsigned char *)(v2 + 104))
  {
    float v19 = *(const void **)(v2 + 224);
    if (v19)
    {
      CFRelease(v19);
      *(void *)(v2 + 224) = 0;
    }
  }
  if (!*(unsigned char *)(a1 + 20)) {
    goto LABEL_51;
  }
  int v20 = *(_DWORD *)(v2 + 336);
  if ((v20 & 2) != 0) {
    int v21 = 2;
  }
  else {
    int v21 = 1;
  }
  if (v21 != *(_DWORD *)(v2 + 340))
  {
    *(_DWORD *)(v2 + 340) = v21;
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
  }
  if ((v20 & 2) == 0) {
    goto LABEL_51;
  }
LABEL_52:
  uint64_t v22 = *(const void **)(a1 + 24);
  if (v22) {
    CFRelease(v22);
  }
  uint64_t v23 = *(const void **)(a1 + 8);
  if (v23) {
    CFRelease(v23);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  free((void *)a1);
}

void figTimelineCoordinator_suspendTimelineControlCommandCompletionTimer(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 112);
  if (v1) {
    dispatch_source_set_timer(v1, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
  }
  else {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figTimelineCoordinatorRemoveSuspensionInternal(uint64_t a1, const void *a2)
{
  CFArrayRef v4 = *(const __CFArray **)(a1 + 424);
  v8.length = CFArrayGetCount(v4);
  v8.location = 0;
  FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v4, v8, a2);
  if (FirstIndexOfValue == -1)
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 424), FirstIndexOfValue);
    return 0;
  }
}

void figTimelineCoordinator_issueProposeTimelineForIdentifierOnQueue(uint64_t a1)
{
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
  int v3 = v2;
  CFArrayRef v4 = *(void (**)(id *, void))(a1 + 72);
  if (!v4)
  {
    if (!v2) {
      return;
    }
    goto LABEL_5;
  }
  if (v2)
  {
    v4(v2, *(void *)(a1 + 352));
LABEL_5:
    CFRelease(v3);
    return;
  }

  FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
}

uint64_t figTimelineCoordinator_resetGroupExpectationsOnQueue(uint64_t a1)
{
  *(unsigned char *)(a1 + 280) = 0;
  uint64_t v2 = *(const void **)(a1 + 272);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 272) = 0;
  }
  if (FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328)))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 328));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
    figTimelineCoordinator_postParticipantsDidChange((const __CFDictionary **)a1);
  }
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 216));
  figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
  uint64_t v3 = *(void *)(a1 + 200);
  if (!v3) {
    return 0;
  }
  if (*(void *)(v3 + 24))
  {
    CFTypeRef cf = 0;
    uint64_t result = figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E4F1CF80], v3, &cf);
    if (result) {
      return result;
    }
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
    uint64_t v5 = *(const void **)(a1 + 200);
    CFTypeRef v6 = cf;
    *(void *)(a1 + 200) = cf;
    if (v6) {
      CFRetain(v6);
    }
    if (v5) {
      CFRelease(v5);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v3 = *(void *)(a1 + 200);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 216), *(const void **)(v3 + 88), (const void *)v3);
  return figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(a1);
}

uint64_t figTimelineCoordinator_removeValueFromArray(CFArrayRef theArray, const void *a2)
{
  uint64_t result = 0;
  if (theArray && a2)
  {
    v6.length = CFArrayGetCount(theArray);
    v6.location = 0;
    FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(theArray, v6, a2);
    if (FirstIndexOfValue == -1)
    {
      return 0;
    }
    else
    {
      CFArrayRemoveValueAtIndex(theArray, FirstIndexOfValue);
      return 1;
    }
  }
  return result;
}

void figTimelineCoordinator_updateParticipantsWithNewLocalIdentifierApply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(const void **)a3;
  CFRange v6 = participantState_timelineIdentifier(*(const __CFDictionary **)(a2 + 16));
  if (!FigCFEqual(v5, *(CFTypeRef *)(a2 + 24)))
  {
    uint64_t v7 = *(void *)(a2 + 16);
    Boolean v10 = 0;
    FigCFDictionaryGetBooleanIfPresent(v7, @"ReadyToSetNonZeroRate", &v10);
    if (v10)
    {
      if (FigCFEqual(v5, v6)) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = FigCFEqual(*(CFTypeRef *)(a2 + 24), v6) != 0;
      }
    }
    else
    {
      BOOL v8 = 0;
    }
    uint64_t v9 = *(const void **)(a2 + 24);
    *(void *)(a2 + 24) = v5;
    if (v5) {
      CFRetain(v5);
    }
    if (v9) {
      CFRelease(v9);
    }
    if (v8) {
      *(unsigned char *)(a3 + 8) = 1;
    }
  }
}

uint64_t FigBBMessageCreate(const __CFAllocator *a1, CMBlockBufferRef *a2)
{
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v4 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
  if (v4)
  {
    CFMutableDictionaryRef Mutable = blockBufferOut;
    if (!blockBufferOut) {
      return v4;
    }
    goto LABEL_3;
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 0);
  CFDataSetLength(Mutable, 456);
  *(_DWORD *)CFDataGetBytePtr(Mutable) = 8;
  CMSetAttachment(blockBufferOut, @"MessageLayout", Mutable, 0);
  *a2 = blockBufferOut;
  CMBlockBufferRef blockBufferOut = 0;
  if (Mutable) {
LABEL_3:
  }
    CFRelease(Mutable);
  return v4;
}

uint64_t FigBBMessageSetInt64(const void *a1, int a2, uint64_t a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 32) = a3;
  *(void *)(v6 + 40) = 8;
  *(void *)(v6 + 8) = bbmsg_CopyInt64;
  return result;
}

uint64_t AcquireLayoutEntry(const __CFData *a1, int a2)
{
  BytePtr = (UInt8 *)CFDataGetBytePtr(a1);
  int v5 = *((_DWORD *)BytePtr + 1);
  if (v5 < 1)
  {
LABEL_5:
    if (v5 == *(_DWORD *)BytePtr)
    {
      int v8 = v5 + 4;
      CFDataSetLength(a1, 56 * v5 + 232);
      BytePtr = (UInt8 *)CFDataGetBytePtr(a1);
      *(_DWORD *)BytePtr = v8;
      int v5 = *((_DWORD *)BytePtr + 1);
    }
    uint64_t v6 = (uint64_t)&BytePtr[56 * v5 + 8];
    *((_DWORD *)BytePtr + 1) = v5 + 1;
  }
  else
  {
    uint64_t v6 = (uint64_t)(BytePtr + 8);
    uint64_t v7 = *((unsigned int *)BytePtr + 1);
    while (*(_DWORD *)v6 != a2)
    {
      v6 += 56;
      if (!--v7) {
        goto LABEL_5;
      }
    }
  }
  *(void *)(v6 + 48) = 0;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  return v6;
}

void *bbmsg_CopyInt64(void *result, uint64_t a2, uint64_t a3)
{
  if (a2 == 8) {
    *uint64_t result = *(void *)(a3 + 32);
  }
  return result;
}

uint64_t FigBBMessageSetFloat32(const void *a1, int a2, float a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 40) = 4;
  *(float *)(v6 + 32) = a3;
  *(void *)(v6 + 8) = bbmsg_CopyFloat32;
  return result;
}

_DWORD *bbmsg_CopyFloat32(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (a2 == 4) {
    *uint64_t result = *(_DWORD *)(a3 + 32);
  }
  return result;
}

uint64_t FigBBMessageSetDataPtr(const void *a1, int a2, uint64_t a3, uint64_t a4)
{
  CFDataRef v7 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v7) {
    return 4294950414;
  }
  uint64_t v8 = AcquireLayoutEntry(v7, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v8 = a2;
  *(void *)(v8 + 24) = a3;
  *(void *)(v8 + 40) = a4;
  return result;
}

uint64_t FigBBMessageSetCString(const void *a1, int a2, uint64_t a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 16) = DL_CStringSizer;
  *(void *)(v6 + 24) = a3;
  return result;
}

const char *DL_CStringSizer(uint64_t a1)
{
  uint64_t result = *(const char **)(a1 + 24);
  if (result) {
    return (const char *)(strlen(result) + 1);
  }
  return result;
}

uint64_t FigBBMessageSetCFData(const void *a1, int a2, uint64_t a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 16) = DL_CFDataSizer;
  *(void *)(v6 + 24) = a3;
  *(void *)(v6 + 8) = DL_CFDataCopier;
  return result;
}

CFIndex DL_CFDataSizer(uint64_t a1)
{
  CFDataRef v1 = *(const __CFData **)(a1 + 24);
  if (!v1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(*(CFTypeRef *)(a1 + 24));
  if (v2 != CFDataGetTypeID()) {
    return 0;
  }

  return CFDataGetLength(v1);
}

void *DL_CFDataCopier(void *a1, size_t a2, uint64_t a3)
{
  CFDataRef v5 = *(const __CFData **)(a3 + 24);
  unint64_t Length = CFDataGetLength(v5);
  uint64_t result = (void *)CFDataGetBytePtr(v5);
  if (v5)
  {
    uint64_t v8 = result;
    CFTypeID v9 = CFGetTypeID(v5);
    uint64_t result = (void *)CFDataGetTypeID();
    if ((void *)v9 == result)
    {
      if (Length >= a2) {
        size_t v10 = a2;
      }
      else {
        size_t v10 = Length;
      }
      return memcpy(a1, v8, v10);
    }
  }
  return result;
}

uint64_t FigBBMessageSetCFString(const void *a1, int a2, uint64_t a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 16) = DL_CFStringSizer;
  *(void *)(v6 + 24) = a3;
  *(void *)(v6 + 8) = DL_CFStringCopier;
  return result;
}

CFIndex DL_CFStringSizer(uint64_t a1)
{
  CFStringRef v1 = *(const __CFString **)(a1 + 24);
  if (!v1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(*(CFTypeRef *)(a1 + 24));
  if (v2 != CFStringGetTypeID()) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(v1);
  return CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
}

CFTypeID DL_CFStringCopier(CFTypeID result, CFIndex a2, uint64_t a3)
{
  CFStringRef v3 = *(const __CFString **)(a3 + 24);
  if (v3)
  {
    CFDataRef v5 = (char *)result;
    CFTypeID v6 = CFGetTypeID(*(CFTypeRef *)(a3 + 24));
    uint64_t result = CFStringGetTypeID();
    if (v6 == result)
    {
      return CFStringGetCString(v3, v5, a2, 0x8000100u);
    }
  }
  return result;
}

uint64_t FigBBMessageSetCFDictionary(const void *a1, int a2, uint64_t a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 16) = DL_CFDictSizer;
  *(void *)(v6 + 24) = a3;
  *(void *)(v6 + 8) = DL_CFDictCopier;
  return result;
}

CFIndex DL_CFDictSizer(uint64_t a1)
{
  CFStringRef v1 = *(const void **)(a1 + 24);
  CFErrorRef error = 0;
  if (!v1) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(v1);
  if (v3 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFDataRef v4 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  CFErrorRef v5 = error;
  if (!error)
  {
    if (!v4) {
      return 0;
    }
    CFIndex result = CFDataGetLength(v4);
    if (result)
    {
      *(void *)(a1 + 48) = v4;
      return result;
    }
    CFErrorRef v5 = v4;
  }
  CFRelease(v5);
  return 0;
}

void DL_CFDictCopier(void *a1, size_t a2, uint64_t a3)
{
  CFDataRef v6 = *(const __CFData **)(a3 + 48);
  unint64_t Length = CFDataGetLength(v6);
  BytePtr = CFDataGetBytePtr(v6);
  if (v6)
  {
    CFTypeID v9 = BytePtr;
    CFTypeID v10 = CFGetTypeID(v6);
    if (v10 == CFDataGetTypeID())
    {
      if (Length >= a2) {
        size_t v11 = a2;
      }
      else {
        size_t v11 = Length;
      }
      memcpy(a1, v9, v11);
    }
    CFRelease(v6);
    *(void *)(a3 + 48) = 0;
  }
}

uint64_t FigBBMessageSetCFArray(const void *a1, int a2, uint64_t a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 16) = DL_CFArraySizer;
  *(void *)(v6 + 24) = a3;
  *(void *)(v6 + 8) = DL_CFArrayCopier;
  return result;
}

CFIndex DL_CFArraySizer(uint64_t a1)
{
  CFStringRef v1 = *(const void **)(a1 + 24);
  CFErrorRef error = 0;
  if (!v1) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(v1);
  if (v3 != CFArrayGetTypeID()) {
    return 0;
  }
  CFDataRef v4 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  CFErrorRef v5 = error;
  if (!error)
  {
    if (!v4) {
      return 0;
    }
    CFIndex result = CFDataGetLength(v4);
    if (result)
    {
      *(void *)(a1 + 48) = v4;
      return result;
    }
    CFErrorRef v5 = v4;
  }
  CFRelease(v5);
  return 0;
}

void DL_CFArrayCopier(void *a1, size_t a2, uint64_t a3)
{
  CFDataRef v6 = *(const __CFData **)(a3 + 48);
  unint64_t Length = CFDataGetLength(v6);
  BytePtr = CFDataGetBytePtr(v6);
  if (v6)
  {
    CFTypeID v9 = BytePtr;
    CFTypeID v10 = CFGetTypeID(v6);
    if (v10 == CFDataGetTypeID())
    {
      if (Length >= a2) {
        size_t v11 = a2;
      }
      else {
        size_t v11 = Length;
      }
      memcpy(a1, v9, v11);
    }
    CFRelease(v6);
    *(void *)(a3 + 48) = 0;
  }
}

uint64_t FigBBMessageSetBlockBuffer(const void *a1, int a2, uint64_t a3)
{
  CFDataRef v5 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v5) {
    return 4294950414;
  }
  uint64_t v6 = AcquireLayoutEntry(v5, a2);
  uint64_t result = 0;
  *(_DWORD *)uint64_t v6 = a2;
  *(void *)(v6 + 16) = DL_BlockBufferSizer;
  *(void *)(v6 + 24) = a3;
  *(void *)(v6 + 8) = DL_BlockBufferCopier;
  return result;
}

size_t DL_BlockBufferSizer(uint64_t a1)
{
  CFStringRef v1 = *(OpaqueCMBlockBuffer **)(a1 + 24);
  if (!v1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(*(CFTypeRef *)(a1 + 24));
  if (v2 != CMBlockBufferGetTypeID()) {
    return 0;
  }

  return CMBlockBufferGetDataLength(v1);
}

CFTypeID DL_BlockBufferCopier(CFTypeID result, size_t a2, uint64_t a3)
{
  CFTypeID v3 = *(OpaqueCMBlockBuffer **)(a3 + 24);
  if (v3)
  {
    CFDataRef v5 = (void *)result;
    CFTypeID v6 = CFGetTypeID(*(CFTypeRef *)(a3 + 24));
    uint64_t result = CMBlockBufferGetTypeID();
    if (v6 == result)
    {
      return CMBlockBufferCopyDataBytes(v3, 0, a2, v5);
    }
  }
  return result;
}

uint64_t FigBBMessageCommit(void *a1)
{
  CFDataRef v2 = (const __CFData *)CMGetAttachment(a1, @"MessageLayout", 0);
  if (!v2) {
    return 4294950414;
  }
  BytePtr = CFDataGetBytePtr(v2);
  if (!BytePtr) {
    return 4294950414;
  }
  ProcessDataLayoutEntries((OpaqueCMBlockBuffer *)a1, *((_DWORD *)BytePtr + 1), (uint64_t)(BytePtr + 8), 0);
  CMRemoveAttachment(a1, @"MessageLayout");
  return 0;
}

char *ProcessDataLayoutEntries(OpaqueCMBlockBuffer *a1, int a2, uint64_t a3, size_t a4)
{
  if (a2)
  {
    uint64_t v8 = *(uint64_t (**)(uint64_t))(a3 + 16);
    if (v8) {
      size_t v9 = v8(a3);
    }
    else {
      size_t v9 = *(void *)(a3 + 40);
    }
    uint64_t v12 = (int)v9 + 8;
    if (!v9) {
      uint64_t v12 = 0;
    }
    uint64_t result = (char *)ProcessDataLayoutEntries(a1, (a2 - 1), a3 + 56, v12 + a4);
    if (v9)
    {
      dataPointerOut = 0;
      CMBlockBufferGetDataPointer(a1, a4, 0, 0, &dataPointerOut);
      uint64_t v13 = dataPointerOut;
      uint64_t result = dataPointerOut + 8;
      uint64_t v14 = *(uint64_t (**)(char *, size_t, uint64_t))(a3 + 8);
      if (v14)
      {
        uint64_t result = (char *)v14(result, v9, a3);
      }
      else
      {
        long long v15 = *(const void **)(a3 + 24);
        if (v15) {
          uint64_t result = (char *)memcpy(result, v15, v9);
        }
      }
      unsigned int v16 = bswap32(*(_DWORD *)a3);
      *(_DWORD *)uint64_t v13 = bswap32(v9 + 8);
      *((_DWORD *)v13 + 1) = v16;
    }
  }
  else
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    return (char *)CMBlockBufferAppendMemoryBlock(a1, 0, a4, v10, 0, 0, a4, 1u);
  }
  return result;
}

uint64_t FigBBMessageGetInt64(OpaqueCMBlockBuffer *a1, int a2, _DWORD *a3)
{
  int v7 = 0;
  size_t v6 = 0;
  CFDataRef v4 = AccessDataForTag(a1, a2, &v6, &v7);
  uint64_t result = 0;
  if (v4 && v6 == 8) {
    uint64_t result = *(void *)v4;
  }
  if (a3) {
    *a3 = v7;
  }
  return result;
}

char *AccessDataForTag(OpaqueCMBlockBuffer *a1, int a2, size_t *a3, _DWORD *a4)
{
  size_t v12 = 0;
  size_t offset = 0;
  CFAllocatorRef v10 = 0;
  size_t lengthAtOffsetOut = 0;
  int DataPointer = LocateParameterTag(a1, a2, &offset, &v12);
  if (DataPointer || (int DataPointer = CMBlockBufferGetDataPointer(a1, offset, &lengthAtOffsetOut, 0, &v10)) != 0)
  {
LABEL_10:
    uint64_t v8 = 0;
    if (!a4) {
      return v8;
    }
    goto LABEL_7;
  }
  if (lengthAtOffsetOut < v12)
  {
    int DataPointer = 0;
    goto LABEL_10;
  }
  uint64_t v8 = v10;
  int DataPointer = 0;
  if (a3) {
    *a3 = v12;
  }
  if (a4) {
LABEL_7:
  }
    *a4 = DataPointer;
  return v8;
}

char *FigBBMessageGetFloat32(OpaqueCMBlockBuffer *a1, int a2, _DWORD *a3)
{
  int v6 = 0;
  size_t v5 = 0;
  uint64_t result = AccessDataForTag(a1, a2, &v5, &v6);
  if (a3) {
    *a3 = v6;
  }
  return result;
}

char *FigBBMessageGetCString(OpaqueCMBlockBuffer *a1, int a2, int *a3)
{
  int v7 = 0;
  size_t v6 = 0;
  uint64_t result = AccessDataForTag(a1, a2, &v6, &v7);
  int v5 = v7;
  if (!v7)
  {
    if (result[v6]) {
      int v5 = -16884;
    }
    else {
      int v5 = 0;
    }
  }
  if (a3) {
    *a3 = v5;
  }
  return result;
}

uint64_t FigBBMessageCopyCFData(OpaqueCMBlockBuffer *a1, int a2, CFDataRef *a3)
{
  unint64_t v6 = 0;
  size_t v7 = 0;
  uint64_t result = LocateParameterTag(a1, a2, &v7, &v6);
  if (!result) {
    return FigCreateCFDataWithBlockBufferNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1, v7, v6, a3);
  }
  return result;
}

uint64_t LocateParameterTag(OpaqueCMBlockBuffer *a1, int a2, void *a3, void *a4)
{
  memset(v10, 0, sizeof(v10));
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = FigAtomStreamInitWithBBuf(a1, 0, 0, (uint64_t)v10);
  if (!result)
  {
    if (FigAtomStreamPositionAtFirstAtomWithType((uint64_t)v10, a2)) {
      return 4294950413;
    }
    if (a3)
    {
      uint64_t result = FigAtomStreamGetCurrentAtomDataGlobalOffset((uint64_t)v10, 0, &v8);
      if (result) {
        return result;
      }
      *a3 = v8;
    }
    if (a4)
    {
      uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v10, 0, &v9);
      if (!result) {
        *a4 = v9;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FigBBMessageCopyBlockBuffer(OpaqueCMBlockBuffer *a1, int a2, CMBlockBufferRef *a3)
{
  size_t v6 = 0;
  size_t v7 = 0;
  uint64_t result = LocateParameterTag(a1, a2, &v7, &v6);
  if (!result) {
    return CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v7, v6, 0, a3);
  }
  return result;
}

uint64_t FigBBMessageCopyCFString(OpaqueCMBlockBuffer *a1, int a2, CFStringRef *a3)
{
  unsigned int v7 = 0;
  CFDataRef v4 = AccessDataForTag(a1, a2, 0, &v7);
  if (!v4) {
    return 4294950415;
  }
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 0x8000100u);
  if (!v5) {
    return 4294950415;
  }
  *a3 = v5;
  return v7;
}

uint64_t FigBBMessageCopyCFDictionary(OpaqueCMBlockBuffer *a1, int a2, void *a3)
{
  CFDataRef data = 0;
  uint64_t v4 = FigBBMessageCopyCFData(a1, a2, &data);
  if (v4)
  {
    uint64_t v6 = v4;
  }
  else
  {
    CFPropertyListRef v5 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], data, 0, 0, 0);
    if (v5)
    {
      uint64_t v6 = 0;
      *a3 = v5;
    }
    else
    {
      uint64_t v6 = 4294950415;
    }
  }
  if (data) {
    CFRelease(data);
  }
  return v6;
}

uint64_t FigBBMessageCopyCFArray(OpaqueCMBlockBuffer *a1, int a2, void *a3)
{
  CFDataRef data = 0;
  uint64_t v4 = FigBBMessageCopyCFData(a1, a2, &data);
  if (v4)
  {
    uint64_t v6 = v4;
  }
  else
  {
    CFPropertyListRef v5 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], data, 0, 0, 0);
    if (v5)
    {
      uint64_t v6 = 0;
      *a3 = v5;
    }
    else
    {
      uint64_t v6 = 4294950415;
    }
  }
  if (data) {
    CFRelease(data);
  }
  return v6;
}

uint64_t FigCaptionGroupGetTypeID()
{
  return sFigCaptionGroupID;
}

uint64_t RegisterFigCaptionGroupType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionGroupIOSurfaceID ID = result;
  return result;
}

uint64_t FigCaptionGroupCreate(const __CFAllocator *a1, CFArrayRef theArray, CMTime *a3, CMTime *a4, uint64_t *a5)
{
  if (theArray && a5)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    unint64_t v9 = Count;
    if (Count < 1)
    {
LABEL_10:
      FigThreadRunOnce(&sRegisterFigCaptionGroupTypeOnce, (void (*)(void))RegisterFigCaptionGroupType);
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v14 = Instance;
        *(void *)(Instance + 16) = CFArrayCreateCopy(a1, theArray);
        if (v9)
        {
          if (v9 <= 0xAAAAAAAAAAAAAAALL && 24 * v9)
          {
            *(void *)(v14 + 24) = malloc_type_malloc(24 * v9, 0xD1AAB5CuLL);
            long long v15 = malloc_type_malloc(24 * v9, 0xD1AAB5CuLL);
            unsigned int v16 = *(void **)(v14 + 24);
          }
          else
          {
            unsigned int v16 = 0;
            long long v15 = 0;
            *(void *)(v14 + 24) = 0;
          }
          *(void *)(v14 + 32) = v15;
          if (v9 <= 0xAAAAAAAAAAAAAAALL) {
            size_t v18 = 24 * v9;
          }
          else {
            size_t v18 = 0;
          }
          memcpy(v16, a3, v18);
          memcpy(*(void **)(v14 + 32), a4, v18);
        }
        uint64_t result = 0;
        *a5 = v14;
      }
      else
      {
        FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        return 0;
      }
    }
    else
    {
      size_t v11 = a3;
      CFAllocatorRef v10 = a4;
      CFIndex v12 = Count;
      while ((v11->flags & 0x1D) == 1)
      {
        CMTime time1 = *v11;
        *(_OWORD *)&time2.unsigned int value = *(_OWORD *)&kCMTimeZero.value;
        time2.CMTimeEpoch epoch = 0;
        if (CMTimeCompare(&time1, &time2) < 0) {
          break;
        }
        if ((v10->flags & 0x1D) != 1) {
          break;
        }
        CMTime time1 = *v10;
        *(_OWORD *)&time2.unsigned int value = *(_OWORD *)&kCMTimeZero.value;
        time2.CMTimeEpoch epoch = 0;
        if (CMTimeCompare(&time1, &time2) < 0) {
          break;
        }
        ++v10;
        ++v11;
        if (!--v12) {
          goto LABEL_10;
        }
      }
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCaptionGroupCreateEmpty(const __CFAllocator *a1, uint64_t *a2)
{
  CFArrayRef v4 = CFArrayCreate(a1, 0, 0, MEMORY[0x1E4F1D510]);
  uint64_t v5 = FigCaptionGroupCreate(a1, v4, (CMTime *)&kCMTimeZero, (CMTime *)&kCMTimeZero, a2);
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

CFIndex FigCaptionGroupGetSliceCount(uint64_t a1)
{
  if (a1)
  {
    CFArrayRef v1 = *(const __CFArray **)(a1 + 16);
    return CFArrayGetCount(v1);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

const void *FigCaptionGroupGetCaptionData(uint64_t a1, CFIndex a2)
{
  if (a1)
  {
    CFArrayRef v2 = *(const __CFArray **)(a1 + 16);
    return CFArrayGetValueAtIndex(v2, a2);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

CFIndex FigCaptionGroupGetDurationBeforeSlice@<X0>(uint64_t a1@<X0>, CFIndex a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = *(_OWORD *)&kCMTimeInvalid.value;
  *(void *)(a3 + 16) = 0;
  if (a1 && (CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 16)), result > a2))
  {
    uint64_t v7 = *(void *)(a1 + 24) + 24 * a2;
    *(_OWORD *)a3 = *(_OWORD *)v7;
    *(void *)(a3 + 16) = *(void *)(v7 + 16);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

CFIndex FigCaptionGroupGetDurationAfterSlice@<X0>(uint64_t a1@<X0>, CFIndex a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = *(_OWORD *)&kCMTimeInvalid.value;
  *(void *)(a3 + 16) = 0;
  if (a1 && (CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 16)), result > a2))
  {
    uint64_t v7 = *(void *)(a1 + 32) + 24 * a2;
    *(_OWORD *)a3 = *(_OWORD *)v7;
    *(void *)(a3 + 16) = *(void *)(v7 + 16);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void *CaptionGroupInit(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void CaptionGroupFinalize(uint64_t a1)
{
  CFArrayRef v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  free(*(void **)(a1 + 24));
  CFTypeID v3 = *(void **)(a1 + 32);

  free(v3);
}

CFStringRef CaptionGroupCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionGroup %p]", a1);
}

__CFString *CaptionGroupCopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  CFStringAppendFormat(Mutable, 0, @"FigCaptionGroup (number of captions = %ld)\n", Count);
  if (Count)
  {
    CFIndex v4 = 0;
    CFStringRef v5 = 0;
    do
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v4);
      if (v5) {
        CFRelease(v5);
      }
      CFStringRef v5 = CFCopyDescription(ValueAtIndex);
      FigCaptionGroupGetDurationBeforeSlice(a1, v4, (uint64_t)&time);
      Float64 Seconds = CMTimeGetSeconds(&time);
      FigCaptionGroupGetDurationAfterSlice(a1, v4, (uint64_t)&v10);
      Float64 v8 = CMTimeGetSeconds(&v10);
      CFStringAppendFormat(Mutable, 0, @"BeforeSlice<%4.2f> AfterSlice<%4.2f> %@\n", *(void *)&Seconds, *(void *)&v8, v5);
      ++v4;
    }
    while (Count != v4);
    if (v5) {
      CFRelease(v5);
    }
  }
  return Mutable;
}

uint64_t FigEndpointAudioSinkGetClassID()
{
  if (FigEndpointAudioSinkGetClassID_sRegisterOnce != -1) {
    dispatch_once(&FigEndpointAudioSinkGetClassID_sRegisterOnce, &__block_literal_global_44);
  }
  return FigEndpointAudioSinkGetClassID_sClassID;
}

CFStringRef Sink_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointAudioSink %p]", a1);
}

uint64_t __FigEndpointAudioSinkGetClassID_block_invoke()
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigEndpointAudioSinkGetClassID_sClassDesc, ClassID, 1, &FigEndpointAudioSinkGetClassID_sClassID);
}

uint64_t FigEndpointAudioSinkGetTypeID()
{
  if (FigEndpointAudioSinkGetClassID_sRegisterOnce != -1) {
    dispatch_once(&FigEndpointAudioSinkGetClassID_sRegisterOnce, &__block_literal_global_44);
  }
  pid_t v0 = (void *)FigEndpointAudioSinkGetClassID_sClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigRemote_GetServerTimeoutToken()
{
  return getpid();
}

uint64_t FigRemote_GetServerPid()
{
  return gServerPid;
}

uint64_t FigRemote_SetServerPid(uint64_t result)
{
  gServerPid = result;
  return result;
}

uint64_t FigRemote_GetRPCTimeoutListenerPort()
{
  return dword_1EB28BC10;
}

uint64_t FigRemote_LookUpServerTimeoutPort()
{
  if (gServerRPCTimeoutListener != -1) {
    dispatch_once(&gServerRPCTimeoutListener, &__block_literal_global_45);
  }
  FigSimpleMutexLock((pthread_mutex_t *)qword_1EB28BC08);
  FigMachPortReleaseSendRight_(dword_1EB28BC10, 0, 0, 0, 0);
  dword_1EB28BC10 = 0;
  bootstrap_look_up(*MEMORY[0x1E4F14638], "com.apple.coremedia.admin", (mach_port_t *)&dword_1EB28BC10);
  pid_t v0 = (pthread_mutex_t *)qword_1EB28BC08;

  return FigSimpleMutexUnlock(v0);
}

uint64_t FigRPCServer_SetTimeoutNanoseconds(uint64_t result)
{
  gFigServerSideRPCuint64_t TimeoutNanoseconds = result;
  return result;
}

uint64_t FigRPCServer_GetTimeoutNanoseconds()
{
  return gFigServerSideRPCTimeoutNanoseconds;
}

uint64_t FigRPCServer_PickRPCTimeoutForCurrentThread(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  CFTypeRef cf = 0;
  if (a1 && a2)
  {
    HIDWORD(v5) = qos_class_self() - 9;
    LODWORD(v5) = HIDWORD(v5);
    unsigned int v4 = v5 >> 2;
    if (v4 <= 6)
    {
      int v6 = 1 << v4;
      if ((v6 & 0xD) != 0)
      {
        v2 += a2;
        return v2;
      }
      if ((v6 & 0x50) != 0) {
        return v2;
      }
    }
    if (FigServer_IsServerProcess())
    {
      CFAbsoluteTime Current = FigThreadGetCurrent();
      int v9 = FigThreadCopyProperty(Current, @"com.apple.fig.ThreadPropKey_MachThreadPriority", *MEMORY[0x1E4F1CF80], &cf);
      CFTypeRef v10 = cf;
      if (!v9)
      {
        if ((int)FigCFNumberGetSInt32((const __CFNumber *)cf) >= 32) {
          uint64_t v11 = 0;
        }
        else {
          uint64_t v11 = a2;
        }
        v2 += v11;
        CFTypeRef v10 = cf;
      }
      if (v10) {
        CFRelease(v10);
      }
    }
  }
  return v2;
}

uint64_t fpServer_CreateRPCTimeoutThread()
{
  if (fpServer_CreateRPCTimeoutThread_sFigRPCTimeoutServer != -1) {
    dispatch_once(&fpServer_CreateRPCTimeoutThread_sFigRPCTimeoutServer, &__block_literal_global_10_0);
  }
  return 0;
}

void FigRPCServer_TimeoutCrashReport(uint64_t a1, const char *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = getpid();
  memset(v26, 0, sizeof(v26));
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  memset(buffer, 63, sizeof(buffer));
  pid_t v5 = getpid();
  proc_name(v5, buffer, 0x80u);
  if (in_audio_mx_server_process()) {
    LogACQEvents();
  }
  CFStringRef v6 = (const __CFString *)CFPreferencesCopyValue(@"rpc_timeout_method", @"com.apple.coremedia", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (!v6)
  {
    int v9 = 1;
    int v10 = 1;
    goto LABEL_13;
  }
  CFStringRef v7 = v6;
  CFTypeID v8 = CFGetTypeID(v6);
  if (v8 != CFStringGetTypeID())
  {
    int v9 = 1;
    int v10 = 1;
    goto LABEL_12;
  }
  if (CFStringCompare(v7, @"SimulateCrash", 1uLL) == kCFCompareEqualTo)
  {
    int v9 = 0;
    goto LABEL_11;
  }
  int v9 = 1;
  if (CFStringCompare(v7, @"Stackshot", 1uLL) == kCFCompareEqualTo)
  {
LABEL_11:
    int v10 = 0;
    goto LABEL_12;
  }
  int v10 = 1;
  CFStringCompare(v7, @"Tailspin", 1uLL);
  int v9 = 1;
LABEL_12:
  CFRelease(v7);
LABEL_13:
  uint64_t v11 = "<unspecified>";
  if (a2) {
    uint64_t v11 = a2;
  }
  CFIndex v12 = " stackshot taken";
  if (!v9) {
    CFIndex v12 = "";
  }
  CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s: RPCTimeout terminating %d for %d (%@) with reason '%s'%s", buffer, v4, a1, 0, v11, v12);
  global_queue = dispatch_get_global_queue(2, 0);
  long long v15 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, global_queue);
  if (v13) {
    CFRetain(v13);
  }
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 0x40000000;
  handler[2] = __FigRPCServer_TimeoutCrashReport_block_invoke;
  handler[3] = &__block_descriptor_tmp_35;
  int v18 = v4;
  handler[4] = v13;
  dispatch_source_set_event_handler(v15, handler);
  dispatch_time_t v16 = dispatch_time(0, 10000000000);
  dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(v15);
  if (v10) {
    FigUserTailspinWithMessage();
  }
  if (v9)
  {
    FigUserStackshotWithMessage(3189297646, (uint64_t)v13);
    if (!v13) {
      return;
    }
  }
  else
  {
    FigUserFaultWithMessage(3189297646, (uint64_t)v13);
    if (!v13) {
      return;
    }
  }
  CFRelease(v13);
}

uint64_t FigRPCTimeoutServer_KillAndForceCrashReport(uint64_t a1, uint64_t a2, const char *a3, _OWORD *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  pid_t v7 = getpid();
  pid_t v8 = getpid();
  if (gFigServerSideRPCTimeoutNanoseconds)
  {
    if (a2 && v8 != a2) {
      return 4294950775;
    }
    long long v10 = a4[1];
    v22[0] = *a4;
    v22[1] = v10;
    uint64_t ClientPIDFromAuditToken = FigServer_GetClientPIDFromAuditToken(v22);
    FigRPCServer_TimeoutCrashReport(ClientPIDFromAuditToken, a3);
    v18[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B628, 0, v18, &type);
    int v13 = v18[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v15 = v13;
    }
    else {
      unsigned int v15 = v13 & 0xFFFFFFFE;
    }
    if (v15)
    {
      v18[1] = 136315394;
      float v19 = "FigRPCTimeoutServer_KillAndForceCrashReport";
      __int16 v20 = 1024;
      pid_t v21 = v7;
      dispatch_time_t v16 = (_OWORD *)_os_log_send_and_compose_impl();
      LOBYTE(v13) = v18[0];
    }
    else
    {
      dispatch_time_t v16 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B628, 0, 1, v16, v16 != v22, v13, 0, v14);
    kill(v7, 9);
  }
  return 0;
}

uint64_t FigRPCTimeout_KillAndForceCrashReport(mach_port_name_t a1, unsigned int a2, char *a3)
{
  return FigRPCTimeoutRemote_KillAndForceCrashReport(a1, a2, a3);
}

uint64_t FigRPCTimeoutServer_ResetFigNotePreset(uint64_t a1, uint64_t a2, int a3)
{
  if (a2 && a3) {
    MEMORY[0x192FC66D0](*MEMORY[0x1E4F14960]);
  }
  return 0;
}

uint64_t FigRPCTimeoutServer_SetFigNotePreferences(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7)
{
  uint64_t v11 = (unsigned int *)MEMORY[0x1E4F14960];
  if (a2 && a3) {
    MEMORY[0x192FC66D0](*MEMORY[0x1E4F14960]);
  }
  if (a4 && a5) {
    MEMORY[0x192FC66D0](*v11, a4, a5);
  }
  if (a6 && a7) {
    MEMORY[0x192FC66D0](*v11, a6, a7);
  }
  return 0;
}

void FigRemote_InterpretMachErrorForTimeout(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sSetupRPCTimeoutOnce != -1) {
    dispatch_once(&sSetupRPCTimeoutOnce, &__block_literal_global_38);
  }
  if (a1 == 268451843 || a1 == 268435460)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigRemote_InterpretMachErrorForTimeout_block_invoke_2;
    block[3] = &__block_descriptor_tmp_40_0;
    void block[4] = a2;
    void block[5] = a3;
    void block[6] = a4;
    dispatch_sync((dispatch_queue_t)sServerKillingQueue, block);
  }
  else if (!a1)
  {
    if (a2) {
      sSuccessfulMessageServerToken = a2;
    }
    if (FigAtomicCompareAndSwap32(0, 1u, &sMessageSentSuccessfully)) {
      gFigRemoteCommonTimeout = sTimeoutValueFromPreference;
    }
  }
}

uint64_t FigRemote_HandleServerTimeout_WithExtraInfo(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  __strlcpy_chk();
  if (a3)
  {
    __strlcat_chk();
    size_t v5 = strlen(__s);
    CFStringGetCString(a3, &__s[v5], 511 - v5, 0);
    __strlcat_chk();
  }
  if (!dword_1EB28BC10) {
    return 4294950776;
  }
  memcpy(__dst, "fig rpc timeout -- ", sizeof(__dst));
  strlen(__dst);
  __strncat_chk();
  return FigRPCTimeoutRemote_KillAndForceCrashReport(dword_1EB28BC10, a1, __dst);
}

uint64_t FigRemote_CreateSerializedAtomDataForFormatDescriptions(const __CFArray *a1, uint64_t *a2, vm_size_t a3, vm_size_t *a4)
{
  uint64_t v15 = 0;
  vm_size_t size = 0;
  if (!a1 || !a2 || !a4)
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v8 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v8) {
    return v8;
  }
  char v9 = 1;
  long long v10 = (vm_map_t *)MEMORY[0x1E4F14960];
  while (1)
  {
    char v11 = v9;
    if (a3)
    {
      vm_size_t size = a3;
      vm_size_t v12 = a3;
    }
    else
    {
      uint64_t v8 = fdescAtom_createSerializedDataForFormatDescriptionArray(a1, 0, 0, &size);
      if (v8) {
        return v8;
      }
      vm_size_t v12 = size;
      if (!size)
      {
        SerializedDataForFormatDescriptionArradouble y = 0;
        goto LABEL_18;
      }
    }
    SerializedDataForFormatDescriptionArradouble y = vm_allocate(*v10, (vm_address_t *)&v15, v12, 1543503873);
    if (!SerializedDataForFormatDescriptionArray)
    {
      SerializedDataForFormatDescriptionArradouble y = fdescAtom_createSerializedDataForFormatDescriptionArray(a1, v15, size, 0);
      if (!SerializedDataForFormatDescriptionArray) {
        break;
      }
    }
    vm_size_t v12 = size;
    if (v15 && size)
    {
      MEMORY[0x192FC66D0](*v10);
      vm_size_t v12 = 0;
      uint64_t v15 = 0;
      vm_size_t size = 0;
    }
    if (!a3 || SerializedDataForFormatDescriptionArray != -12572) {
      goto LABEL_22;
    }
    SerializedDataForFormatDescriptionArradouble y = 4294954724;
LABEL_18:
    char v9 = 0;
    a3 = 0;
    if ((v11 & 1) == 0) {
      goto LABEL_22;
    }
  }
  vm_size_t v12 = size;
LABEL_22:
  *a4 = v12;
  *a2 = v15;
  return SerializedDataForFormatDescriptionArray;
}

void sbufAtom_InitializeKnownKeys()
{
  uint64_t v293 = *MEMORY[0x1E4F143B8];
  values[0] = @"NotSync";
  values[1] = @"PartialSync";
  values[2] = @"HasRedundantCoding";
  values[3] = @"IsDependedOnByOthers";
  values[4] = @"DependsOnOthers";
  values[5] = @"EarlierDisplayTimesAllowed";
  values[6] = @"DisplayImmediately";
  values[7] = @"DoNotDisplay";
  values[8] = @"BytesOfClearDataCount";
  values[9] = @"CryptorIV";
  values[10] = @"ResetDecoderBeforeDecoding";
  values[11] = @"DrainAfterDecoding";
  values[12] = @"PostNotificationWhenConsumed";
  values[13] = @"ResumeOutput";
  values[14] = @"TrimDurationAtStart";
  values[15] = @"TrimDurationAtEnd";
  values[16] = @"SpeedMultiplier";
  values[17] = @"Reverse";
  values[18] = @"FillDiscontinuitiesWithSilence";
  values[19] = @"EmptyMedia";
  values[20] = @"PermanentEmptyMedia";
  values[21] = @"DisplayEmptyMediaImmediately";
  values[22] = @"EndsPreviousSampleDuration";
  values[23] = @"SampleReferenceURL";
  values[24] = @"SampleReferenceByteOffset";
  values[25] = @"GradualDecoderRefresh";
  values[26] = @"SourceRect";
  values[27] = @"DestRect";
  values[28] = @"VirtualDisplaySizeForDestRect";
  values[29] = @"SymmetricTransform";
  values[30] = @"LoudnessInfo";
  values[31] = @"TransitionID";
  values[32] = @"StartPresentationTimesStamp";
  values[33] = @"EndPresentationTimesStamp";
  values[34] = @"EditBoundary";
  values[35] = @"EmptyMediaBeforeBeginning";
  values[36] = @"ClientTimingInfo";
  values[37] = @"ReferenceWasRefreshed";
  values[38] = @"EncoderRetryCount";
  values[39] = @"RequireAcknowledgementToken";
  values[40] = @"value";
  values[41] = @"timescale";
  values[42] = @"epoch";
  values[43] = @"flags";
  values[44] = @"X";
  values[45] = @"Y";
  values[46] = @"Width";
  values[47] = @"Height";
  values[48] = @"com.apple.fig.format_description.original_compression_settings";
  values[49] = @"SampleDescriptionExtensionAtoms";
  values[50] = @"VerbatimSampleDescription";
  values[51] = @"VerbatimISOSampleEntry";
  values[52] = @"FormatName";
  values[53] = @"Depth";
  pid_t v0 = (void *)*MEMORY[0x1E4F24A88];
  values[54] = *(void **)MEMORY[0x1E4F24A78];
  values[55] = v0;
  CFArrayRef v1 = (void *)*MEMORY[0x1E4F24A70];
  values[56] = *(void **)MEMORY[0x1E4F24A68];
  values[57] = v1;
  values[58] = *(void **)MEMORY[0x1E4F24A80];
  values[59] = @"HeightAsRational";
  values[60] = @"HorizontalOffsetAsRational";
  values[61] = @"VerticalOffsetAsRational";
  uint64_t v2 = (void *)*MEMORY[0x1E4F24B00];
  values[62] = *(void **)MEMORY[0x1E4F24AF8];
  values[63] = v2;
  values[64] = *(void **)MEMORY[0x1E4F24B20];
  values[65] = *(void **)MEMORY[0x1E4F24B18];
  values[66] = *(void **)MEMORY[0x1E4F24B08];
  values[67] = *(void **)MEMORY[0x1E4F24B10];
  values[68] = *(void **)MEMORY[0x1E4F24B98];
  values[69] = *(void **)MEMORY[0x1E4F24B90];
  values[70] = *(void **)MEMORY[0x1E4F24BA0];
  uint64_t v12 = *MEMORY[0x1E4F24A90];
  uint64_t v13 = *MEMORY[0x1E4F24AB0];
  uint64_t v14 = *MEMORY[0x1E4F24AA0];
  uint64_t v15 = *MEMORY[0x1E4F24AC8];
  uint64_t v16 = *MEMORY[0x1E4F24BC8];
  uint64_t v17 = *MEMORY[0x1E4F24BE0];
  uint64_t v18 = *MEMORY[0x1E4F24BF0];
  uint64_t v19 = *MEMORY[0x1E4F24C08];
  uint64_t v20 = *MEMORY[0x1E4F24B28];
  uint64_t v21 = *MEMORY[0x1E4F24C18];
  uint64_t v22 = *MEMORY[0x1E4F24C48];
  uint64_t v23 = *MEMORY[0x1E4F24C40];
  uint64_t v24 = *MEMORY[0x1E4F24C60];
  long long v25 = @"FullRangeVideo";
  long long v26 = @"CVImageBufferICCProfile";
  uint64_t v27 = @"CVBytesPerRow";
  uint64_t v28 = *MEMORY[0x1E4F24A10];
  uint64_t v29 = *MEMORY[0x1E4F24A08];
  uint64_t v30 = *MEMORY[0x1E4F24A38];
  uint64_t v31 = *MEMORY[0x1E4F24A28];
  uint64_t v32 = *MEMORY[0x1E4F24A48];
  uint64_t v33 = *MEMORY[0x1E4F24A40];
  uint64_t v34 = *MEMORY[0x1E4F24A20];
  uint64_t v35 = *MEMORY[0x1E4F24A18];
  uint64_t v36 = *MEMORY[0x1E4F24A30];
  unsigned int v37 = @"TemporalQuality";
  uint64_t v38 = @"SpatialQuality";
  unsigned int v39 = @"Version";
  uint64_t v40 = @"RevisionLevel";
  int v41 = @"Vendor";
  int v42 = @"CommonEncryptionProtected";
  unsigned int v43 = @"CommonEncryptionTrackEncryptionBox";
  uint64_t v44 = @"CommonEncryptionOriginalFormat";
  uint64_t v45 = @"FieldsPerSample";
  uint64_t v46 = @"avcC";
  float v47 = @"d263";
  float v48 = @"uuid";
  int v49 = @"UUID";
  CFUUIDRef v50 = @"sinf";
  int v51 = @"pinf";
  uint64_t v52 = @"CryptorSubsampleAuxiliaryData";
  BOOL v53 = @"hvcC";
  os_log_type_t v54 = @"MetadataKeyTable";
  uint64_t v55 = @"MetadataKeyNamespace";
  uint64_t v56 = @"MetadataKeyValue";
  uint64_t v57 = @"MetadataKeyLocalID";
  uint64_t v58 = @"MetadataKeyDataTypeNameSpace";
  uint64_t v59 = @"MetadataKeyDataType";
  __int16 v60 = @"MetadataKeyConformingDataTypes";
  int v61 = @"MetadataPrimaryLocalIDs";
  __int16 v62 = @"MetadataLocalIDDependencyLists";
  CFUUIDRef v63 = @"BitsPerComponent";
  long long v64 = @"MetadataKeyStructuralDependency";
  uint64_t v65 = @"StructuralDependencyIsInvalidFlag";
  uint64_t v66 = @"MetadataKeySetupData";
  CFTypeRef v67 = @"DisplayFlags";
  __int16 v68 = @"BackgroundColor";
  uint64_t v69 = @"Red";
  int v70 = @"Green";
  CFUUIDRef v71 = @"Blue";
  CFStringRef v72 = @"Alpha";
  long long v73 = @"DefaultTextBox";
  __int16 v74 = @"Top";
  int32_t v75 = @"Left";
  __int16 v76 = @"Bottom";
  uint64_t v77 = @"Right";
  uint64_t v78 = @"DefaultStyle";
  uint64_t v79 = @"StartChar";
  float v80 = @"Font";
  uint64_t v81 = @"FontFace";
  BOOL v82 = @"ForegroundColor";
  BOOL v83 = @"FontSize";
  float v84 = @"HorizontalJustification";
  __int16 v86 = @"EndChar";
  CFTypeRef v87 = @"FontTable";
  char v88 = @"TextJustification";
  uint64_t v89 = @"Height";
  float v85 = @"VerticalJustification";
  uint64_t v90 = @"Ascent";
  uint64_t v91 = @"DefaultFontName";
  uint64_t v92 = @"HorizontalJustification";
  int v93 = @"VerticalJustification";
  BOOL v94 = @"TimeCode_SourceReferenceName";
  float v95 = @"TimeCode_SourceReferenceName_Value";
  float v96 = @"TimeCode_SourceReferenceName_LangCode";
  CFTypeRef v97 = @"Linear";
  uint64_t v98 = @"SMPTE_ST_428_1";
  uint64_t v99 = @"SMPTE_ST_2084_PQ";
  CFTypeRef v100 = @"ITU_R_2100_HLG";
  double v101 = @"IEC_sRGB";
  float v102 = @"AlphaChannelIsOpaque";
  uint64_t v103 = *MEMORY[0x1E4F24A00];
  uint64_t v104 = *MEMORY[0x1E4F24B70];
  uint64_t v105 = v12;
  uint64_t v106 = v16;
  uint64_t v107 = v21;
  char v108 = @"ColorInfoGuessedBy";
  uint64_t v109 = *MEMORY[0x1E4F24980];
  uint64_t v110 = *MEMORY[0x1E4F249A0];
  uint64_t v111 = *MEMORY[0x1E4F24998];
  CFStringRef v112 = @"SceneReferredExtendedLinear";
  CGFloat v113 = @"SourceTrackID";
  size_t v114 = @"CameraIntrinsicMatrix";
  CFTypeRef v115 = @"DroppedFrameReason";
  long long v116 = @"DroppedFrameReasonInfo";
  int v117 = @"StillImageLensStabilizationInfo";
  int v118 = @"HEVCSyncSampleNALUnitType";
  int v119 = @"AmbientViewingEnvironment";
  CMTime v120 = @"auxi";
  int v121 = @"ccst";
  int v122 = @"slmC";
  CMTime v123 = @"IsGradualDecoderRefreshAuthoritative";
  double v124 = @"EndOfSiriTTSUtterance";
  int v125 = @"FECGroupID";
  __int16 v126 = @"FECLastFrameInGroup";
  int v127 = @"FECLevelOfProtection";
  __int16 v128 = @"QualityMetrics";
  int v129 = @"EncodedFrameAvgQP";
  __int16 v130 = @"PadByteCount";
  int v131 = @"VRAWidth";
  __int16 v132 = @"VRAHeight";
  uint64_t v133 = *MEMORY[0x1E4F24A50];
  double v134 = @"dvvC";
  uint64_t v135 = @"disc";
  double v136 = @"TierFlag";
  double v137 = @"ProfileCompatibilityFlags";
  double v138 = @"ProfileSpace";
  double v139 = @"TemporalLevel";
  double v140 = @"ConstraintIndicatorFlags";
  double v141 = @"LevelIndex";
  double v142 = @"ProfileIndex";
  double v143 = @"HEVCTemporalLevelInfo";
  double v144 = @"HEVCTemporalSubLayerAccess";
  double v145 = @"HEVCStepwiseTemporalSubLayerAccess";
  double v146 = @"HEVCSyncSampleNALUnitType";
  int v147 = @"AudioIndependentSampleDecoderRefreshCount";
  int v148 = @"LayerSelector";
  int v149 = @"OperatingPointSelector";
  int v150 = @"IncompleteSample";
  int v151 = @"av1C";
  uint64_t v152 = *MEMORY[0x1E4F24B88];
  uint64_t v153 = *MEMORY[0x1E4F24AD0];
  long long v154 = @"HDR10PlusPerFrameData";
  uint64_t v155 = *MEMORY[0x1E4F24B30];
  uint64_t v156 = *MEMORY[0x1E4F24AF0];
  long long v157 = @"RequestNonReferenceFrame";
  long long v158 = @"CryptKeyParsedIndex";
  CGFloat v159 = @"MediaParsedIndex";
  double v160 = @"PartMediaParsedIndex";
  CGFloat v161 = @"FigAlternates";
  double v162 = @"AudioGroups";
  uint64_t v163 = @"VideoGroups";
  size_t v164 = @"SubtitleGroups";
  uint64_t v165 = @"ClosedCaptionGroups";
  v166 = @"PersistentID";
  v167 = @"GroupID";
  size_t v168 = @"MultivariantPlaylistVariables";
  uint64_t v169 = @"MediaSelectionArray";
  uint64_t v170 = @"SteeringServerURI";
  uint64_t v171 = @"InitPathwayID";
  unsigned int v172 = @"DateEntryArray";
  uint64_t v173 = @"PlaylistActiveDurationSecs";
  CGFloat v174 = @"TargetDuration";
  CGFloat v175 = @"PartTargetDuration";
  CGFloat v176 = @"HoldBackDuration";
  CGFloat v177 = @"PartHoldBackDuration";
  double v178 = @"SkipDeltaBoundary";
  uint64_t v179 = @"PlaylistType";
  int v180 = @"HasEndTag";
  uint64_t v181 = @"HasMediaSequence";
  int v182 = @"HasOnlyIFrames";
  int v183 = @"HasStartTime";
  int v184 = @"StartTimeIsPrecise";
  int v185 = @"SpecifiesIndependentSegments";
  uint64_t v186 = @"HasIndependentParts";
  int v187 = @"HasDiscontinuitySequence";
  int v188 = @"HasPartTag";
  int v189 = @"SupportsBlockingReload";
  int v190 = @"CanSkipDATERANGES";
  int v191 = @"VersionNum";
  uint64_t v192 = @"StartTimeValue";
  uint64_t v193 = @"DateStampCount";
  int v194 = @"AvgSegmentDuration";
  uint64_t v195 = @"MaxSegmentDuration";
  int v196 = @"ParseDate";
  int v197 = @"ParsedURL";
  uint64_t v198 = @"MapEntryURL";
  int v199 = @"PartialEntries";
  int v200 = @"MediaSequence";
  uint64_t v201 = @"DiscontinuityDomain";
  int v202 = @"StartOffset";
  int v203 = @"BytesToRead";
  int v204 = @"TimeInSeconds";
  long long v205 = @"BitRate";
  long long v206 = @"IV";
  long long v207 = @"DateStamp";
  long long v208 = @"ImputedDate";
  long long v209 = @"Type";
  long long v210 = @"MarkedIndependent";
  long long v211 = @"IsDiscontinuity";
  long long v212 = @"MarkedAsGap";
  uint64_t v213 = @"Fragment";
  uint64_t v214 = @"FragmentsExpired";
  int v215 = @"MediaParsedIndexForMap";
  uint64_t v216 = @"KeySystem";
  int v217 = @"EncryptionMethod";
  uint64_t v218 = @"CryptKeyURL";
  int v219 = @"SupportedProtocolVersions";
  uint64_t v220 = @"PrefetchKey";
  int v221 = @"CryptKeyParsed";
  uint64_t v222 = @"SessionDataIdentifier";
  int v223 = @"PlistURL";
  uint64_t v224 = @"SessionDataValue";
  int v225 = @"SessionDataLanguage";
  uint64_t v226 = @"SessionDataFormat";
  int v227 = @"RenditionURL";
  uint64_t v228 = @"LastMediaSequenceNumber";
  int v229 = @"LastIndependentMediaSequenceNumber";
  uint64_t v230 = @"LastPart";
  int v231 = @"LastIndependentPart";
  uint64_t v232 = @"GapAtLive";
  int v233 = @"ReadInCurrent";
  uint64_t v234 = @"TaggedRangeMetadata";
  int v235 = @"TaggedRangeID";
  uint64_t v236 = @"TaggedRangeClass";
  int v237 = @"TaggedRangeLine";
  uint64_t v238 = @"TaggedRangeCue";
  int v239 = @"StartDate";
  uint64_t v240 = @"EndDate";
  int v241 = @"EndOnNext";
  uint64_t v242 = @"EndOnNextSet";
  int v243 = @"scte35cmd";
  uint64_t v244 = @"scte35in";
  int v245 = @"scte35out";
  uint64_t v246 = @"Duration";
  int v247 = @"PlannedDuration";
  uint64_t v248 = @"TagsFirstFoundDateDict";
  int v249 = @"DiscoveryTimestamp";
  uint64_t v250 = @"ModificationTimestamp";
  CGRect v251 = @"PreloadHint";
  CGRect v252 = @"PreloadMapHint";
  CGRect v253 = @"MediaFileEntries";
  CGRect v254 = @"MapFileEntries";
  CGRect v255 = @"CryptKeyEntries";
  CGRect v256 = @"SessionDataEntries";
  CGRect v257 = @"RenditionReportEntries";
  CGRect v258 = @"DateEntries";
  CGRect v259 = @"ReadInCurrentMediaEntriesArray";
  CGRect v260 = @"ReadInCurrentCryptKeyEntriesArray";
  CGRect v261 = @"TransportStreamEncryptionInitData";
  CGRect v262 = @"FrameChecksum";
  CGRect v263 = @"CalculateYUVChecksum";
  CGRect v264 = @"ExtraInLoopChromaFilter";
  CGRect v265 = @"ActiveVideoResolution";
  CGRect v266 = @"HasLeftStereoEyeView";
  CGRect v267 = @"HasRightStereoEyeView";
  CGRect v268 = @"ViewPackingKind";
  CGRect v269 = @"SCStreamUpdateFrameStatus";
  CGRect v270 = @"SCStreamUpdateFrameDisplayTime";
  CGRect v271 = @"SCStreamUpdateFrameDisplayResolution";
  CGRect v272 = @"SCStreamUpdateFrameContentRect";
  CGRect v273 = @"SCStreamUpdateFrameContentRectX";
  CGRect v274 = @"SCStreamUpdateFrameContentRectY";
  CGRect v275 = @"SCStreamUpdateFrameContentRectWidth";
  CGRect v276 = @"SCStreamUpdateFrameContentRectHeight";
  CGRect v277 = @"SCStreamUpdateFrameBoundingRect";
  CGRect v278 = @"SCStreamUpdateFrameContentScale";
  CGRect v279 = @"SCStreamUpdateFrameIOSurface";
  CGRect v280 = @"SCStreamUpdateStreamID";
  CGRect v281 = @"SCStreamUpdateCompositeMode";
  CGRect v282 = @"SCStreamUpdateFrameDirtyRect";
  CGRect v283 = @"SCStreamUpdateFrameDirtyRectY";
  CGRect v284 = @"SCStreamUpdateFrameDirtyRectX";
  CGRect v285 = @"SCStreamUpdateFrameDirtyRectHeight";
  CGRect v286 = @"SCStreamUpdateFrameDirtyRectWidth";
  CGRect v287 = @"SCStreamUpdateFrameScreenRect";
  CGRect v288 = @"SCStreamUpdateFrameNormalizedNewsroomFrameROI";
  CGRect v289 = @"SCStreamUpdateFramePresenterOverlayContentRect";
  CGRect v290 = @"SCStreamMetricCaptureLatencyTime";
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CGRect v291 = @"SCStreamMetricCaptureLatencyTimeAudio";
  CGRect v292 = @"SCStreamMetricCaptureTimeMicrophone";
  uint64_t v4 = 0;
  sKnownSBufKeysDictionardouble y = (uint64_t)CFDictionaryCreateMutable(v3, 352, MEMORY[0x1E4F1D530], 0);
  do
  {
    CFDictionaryAddValue((CFMutableDictionaryRef)sKnownSBufKeysDictionary, values[(void)v4], v4);
    uint64_t v4 = (char *)v4 + 1;
  }
  while (v4 != (const void *)352);
  sKnownSBufKeysArradouble y = (uint64_t)CFArrayCreate(v3, (const void **)values, 352, MEMORY[0x1E4F1D510]);
  if (MEMORY[0x1E4F52858])
  {
    CFArrayRef v5 = (const __CFArray *)FigCaptureCopySerializableKeys();
    sKnownCaptureKeysArradouble y = (uint64_t)v5;
    if (v5)
    {
      CFIndex Count = CFArrayGetCount(v5);
      if (Count)
      {
        CFIndex v7 = Count;
        for (CFIndex i = 0; i != v7; ++i)
        {
          char v9 = (__CFDictionary *)sKnownSBufKeysDictionary;
          ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)sKnownCaptureKeysArray, i);
          CFDictionaryAddValue(v9, ValueAtIndex, (const void *)(i + 0x7FFF));
        }
      }
    }
  }
}

uint64_t fdescAtom_createSerializedDataForFormatDescriptionArray(const __CFArray *a1, uint64_t a2, uint64_t a3, void *a4)
{
  CFIndex Count = CFArrayGetCount(a1);
  long long v18 = 0u;
  long long v19 = 0u;
  int v20 = 0;
  *(void *)&long long v17 = a2;
  *((void *)&v17 + 1) = a3;
  uint64_t result = FigNEAtomWriterBeginAtom((uint64_t)&v17, 1718776441);
  if (!result)
  {
    if (Count < 1)
    {
LABEL_8:
      uint64_t result = FigNEAtomWriterEndAtom((uint64_t)&v17);
      if (a4 && !result)
      {
        uint64_t v12 = *((void *)&v19 + 1);
        if (*((void *)&v19 + 1) == 8) {
          uint64_t v12 = 0;
        }
        *a4 = v12;
      }
    }
    else
    {
      CFIndex v10 = 0;
      while (1)
      {
        int v16 = 0;
        long long v14 = 0u;
        long long v15 = 0u;
        long long v13 = 0u;
        ValueAtIndedouble x = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(a1, v10);
        long long v15 = 0uLL;
        int v16 = 0;
        long long v13 = v17;
        *(void *)&long long v14 = &v17;
        *((void *)&v14 + 1) = *((void *)&v19 + 1) + *((void *)&v18 + 1);
        uint64_t result = FigNEAtomWriterBeginAtom((uint64_t)&v13, 1717859171);
        if (result) {
          break;
        }
        uint64_t result = (uint64_t)sbufAtom_appendFormatDescriptionAtomGuts(ValueAtIndex, (uint64_t *)&v13);
        if (result) {
          break;
        }
        uint64_t result = FigNEAtomWriterEndAtom((uint64_t)&v13);
        if (result) {
          break;
        }
        if (Count == ++v10) {
          goto LABEL_8;
        }
      }
    }
  }
  return result;
}

uint64_t FigRemote_CreateFormatDescriptionArrayFromSerializedAtomData(uint64_t a1, unint64_t a2, __CFArray **a3)
{
  CFAllocatorRef v3 = a3;
  uint64_t v18 = 0;
  unsigned int value = 0;
  if (!a3 || !a1 || !a2)
  {
    uint64_t v14 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_22;
  }
  uint64_t v6 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v6)
  {
    uint64_t v14 = v6;
    CFMutableDictionaryRef Mutable = 0;
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (!Mutable)
    {
      uint64_t v16 = 4294954510;
LABEL_32:
      uint64_t v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_22:
      if (!v14) {
        goto LABEL_19;
      }
      goto LABEL_23;
    }
    uint64_t v9 = figReadNEAtomHeader(a1, 0, a2, (_DWORD *)&v18 + 1, &v18);
    if (!v9)
    {
      if (HIDWORD(v18) == 1718776441)
      {
        unint64_t v10 = v18;
        if (v18 <= a2)
        {
          if (v18 < 9)
          {
            uint64_t v14 = 0;
            goto LABEL_19;
          }
          long long v17 = v3;
          unint64_t v11 = 8;
          while (1)
          {
            uint64_t v12 = figReadNEAtomHeader(a1, v11, v10, (_DWORD *)&v18 + 1, &v18);
            if (v12)
            {
LABEL_20:
              uint64_t v14 = v12;
              CFAllocatorRef v3 = v17;
              goto LABEL_23;
            }
            if (HIDWORD(v18) != 1717859171) {
              break;
            }
            uint64_t v13 = v18;
            uint64_t v12 = sbufAtom_copyFormatDescriptionFromAtom(v7, a1 + 8 + v11, v18 - 8, (CFTypeRef *)&value);
            if (v12) {
              goto LABEL_20;
            }
            CFArrayAppendValue(Mutable, value);
            if (value)
            {
              CFRelease(value);
              unsigned int value = 0;
            }
            v11 += v13;
            if (v11 >= v10)
            {
              uint64_t v14 = 0;
              CFAllocatorRef v3 = v17;
              goto LABEL_19;
            }
          }
          uint64_t v14 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
          CFAllocatorRef v3 = v17;
          goto LABEL_22;
        }
      }
      uint64_t v16 = 4294954516;
      goto LABEL_32;
    }
    uint64_t v14 = v9;
  }
LABEL_23:
  if (value)
  {
    CFRelease(value);
    unsigned int value = 0;
  }
  if (Mutable)
  {
    CFRelease(Mutable);
    CFMutableDictionaryRef Mutable = 0;
  }
LABEL_19:
  *CFAllocatorRef v3 = Mutable;
  return v14;
}

uint64_t figReadNEAtomHeader(uint64_t a1, uint64_t a2, unint64_t a3, _DWORD *a4, _DWORD *a5)
{
  if (a2 + 8 > a3) {
    return 4294954405;
  }
  uint64_t v6 = a1 + a2;
  unint64_t v7 = *(unsigned int *)(a1 + a2);
  if (v7 <= 7 || a3 - a2 < v7) {
    return FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
  }
  uint64_t result = 0;
  *a4 = *(_DWORD *)(v6 + 4);
  *a5 = v7;
  return result;
}

uint64_t sbufAtom_copyFormatDescriptionFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, CFTypeRef *a4)
{
  uint64_t v4 = (CMFormatDescriptionRef *)a4;
  uint64_t v32 = 0;
  memset(&asbd, 0, sizeof(asbd));
  memset(v30, 0, 32);
  if (!a3)
  {
    FourCharCode v13 = 0;
    CMMediaType v12 = 0;
LABEL_62:
    CFDictionaryRef v14 = v32;
    CFAllocatorRef v15 = a1;
    goto LABEL_63;
  }
  int v20 = 0;
  unint64_t v7 = 0;
  uint32_t frameQuanta = 0;
  uint64_t magicCookieSize = 0;
  *(void *)double height = 0;
  uint64_t v26 = 0;
  *(void *)mediaSubType = 0;
  size_t v21 = 0;
  magicCookie = 0;
  uint64_t v8 = a2 + 8;
  do
  {
    uint64_t NEAtomHeader = figReadNEAtomHeader(a2, v7, a3, (_DWORD *)v30 + 1, v30);
    if (NEAtomHeader) {
      goto LABEL_64;
    }
    if (SHIDWORD(v30[0]) <= 1717859697)
    {
      if (SHIDWORD(v30[0]) <= 1668244578)
      {
        if (HIDWORD(v30[0]) == 1634951780)
        {
          if (LODWORD(v30[0]) != 48)
          {
LABEL_80:
            uint64_t NEAtomHeader = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
            goto LABEL_64;
          }
          long long v11 = *(_OWORD *)(v8 + v7 + 16);
          *(_OWORD *)&asbd.mSamplefloat Rate = *(_OWORD *)(v8 + v7);
          *(_OWORD *)&asbd.mBytesPerPacket = v11;
          *(void *)&asbd.mBitsPerChannel = *(void *)(v8 + v7 + 32);
          uint64_t v10 = 48;
        }
        else
        {
          if (HIDWORD(v30[0]) != 1667788396) {
            goto LABEL_44;
          }
          uint64_t v10 = LODWORD(v30[0]);
          if (LODWORD(v30[0]) <= 8) {
            goto LABEL_80;
          }
          int v20 = (const AudioChannelLayout *)(v8 + v7);
          size_t v21 = LODWORD(v30[0]) - 8;
        }
      }
      else
      {
        switch(HIDWORD(v30[0]))
        {
          case 0x636F6463:
            if (LODWORD(v30[0]) != 12) {
              goto LABEL_80;
            }
            HIDWORD(v26) = *(_DWORD *)(v8 + v7);
            goto LABEL_39;
          case 0x63756B69:
            uint64_t v10 = LODWORD(v30[0]);
            if (LODWORD(v30[0]) <= 8) {
              goto LABEL_80;
            }
            uint64_t magicCookieSize = LODWORD(v30[0]) - 8;
            magicCookie = (void *)(v8 + v7);
            break;
          case 0x6578746E:
            uint64_t v10 = LODWORD(v30[0]);
            if (LODWORD(v30[0]) <= 8) {
              goto LABEL_80;
            }
            uint64_t NEAtomHeader = sbufAtom_copyDictionaryFromAtom(a1, v8 + v7, LODWORD(v30[0]) - 8, &v32);
            if (NEAtomHeader) {
              goto LABEL_64;
            }
            break;
          default:
            goto LABEL_44;
        }
      }
    }
    else if (SHIDWORD(v30[0]) > 1903518061)
    {
      if (HIDWORD(v30[0]) == 1903518062)
      {
        if (LODWORD(v30[0]) != 12) {
          goto LABEL_80;
        }
        uint32_t frameQuanta = *(_DWORD *)(v8 + v7);
        goto LABEL_39;
      }
      if (HIDWORD(v30[0]) == 1952671335)
      {
        if (LODWORD(v30[0]) != 12) {
          goto LABEL_80;
        }
        height[0] = *(_DWORD *)(v8 + v7);
        goto LABEL_39;
      }
      if (HIDWORD(v30[0]) != 1986292077) {
        goto LABEL_44;
      }
      if (LODWORD(v30[0]) != 16) {
        goto LABEL_80;
      }
      height[1] = *(_DWORD *)(a2 + v7 + 12);
      LODWORD(v26) = *(_DWORD *)(a2 + v7 + 8);
      uint64_t v10 = 16;
    }
    else
    {
      if (HIDWORD(v30[0]) != 1717859698)
      {
        if (HIDWORD(v30[0]) == 1835297121)
        {
          if (LODWORD(v30[0]) != 12) {
            goto LABEL_80;
          }
          mediaSubType[1] = *(_DWORD *)(v8 + v7);
          goto LABEL_39;
        }
        if (HIDWORD(v30[0]) == 1836283234)
        {
          if (LODWORD(v30[0]) != 12) {
            goto LABEL_80;
          }
          mediaSubType[0] = *(_DWORD *)(v8 + v7);
LABEL_39:
          uint64_t v10 = 12;
          goto LABEL_40;
        }
LABEL_44:
        uint64_t v10 = LODWORD(v30[0]);
        goto LABEL_40;
      }
      if (LODWORD(v30[0]) != 32) {
        goto LABEL_80;
      }
      *(CMTime *)&v30[1] = *(CMTime *)(v8 + v7);
      uint64_t v10 = 32;
    }
LABEL_40:
    v7 += v10;
  }
  while (v7 < a3);
  CMMediaType v12 = mediaSubType[1];
  if ((int)mediaSubType[1] > 1935832171)
  {
    if ((int)mediaSubType[1] > 1952606065)
    {
      FourCharCode v13 = mediaSubType[0];
      if ((int)mediaSubType[1] <= 1953325923)
      {
        uint64_t v4 = (CMFormatDescriptionRef *)a4;
        if (mediaSubType[1] != 1952606066) {
          goto LABEL_62;
        }
        uint64_t NEAtomHeader = FigTaggedBufferGroupFormatDescriptionCreate(a1, mediaSubType[0], a4);
        goto LABEL_64;
      }
      uint64_t v4 = (CMFormatDescriptionRef *)a4;
      if (mediaSubType[1] == 1953325924)
      {
        CMTime frameDuration = *(CMTime *)&v30[1];
        uint64_t NEAtomHeader = CMTimeCodeFormatDescriptionCreate(a1, mediaSubType[0], &frameDuration, frameQuanta, height[0], v32, (CMTimeCodeFormatDescriptionRef *)a4);
        goto LABEL_64;
      }
      int v18 = 1986618469;
LABEL_73:
      if (mediaSubType[1] != v18) {
        goto LABEL_62;
      }
      goto LABEL_74;
    }
    FourCharCode v13 = mediaSubType[0];
    if ((int)mediaSubType[1] <= 1935962988)
    {
      uint64_t v4 = (CMFormatDescriptionRef *)a4;
      goto LABEL_62;
    }
    uint64_t v4 = (CMFormatDescriptionRef *)a4;
    if (mediaSubType[1] == 1936684398)
    {
      uint64_t NEAtomHeader = CMAudioFormatDescriptionCreate(a1, &asbd, v21, v20, magicCookieSize, magicCookie, v32, (CMAudioFormatDescriptionRef *)a4);
      goto LABEL_64;
    }
    goto LABEL_62;
  }
  if ((int)mediaSubType[1] > 1835365472)
  {
    FourCharCode v13 = mediaSubType[0];
    if ((int)mediaSubType[1] <= 1885564003)
    {
      uint64_t v4 = (CMFormatDescriptionRef *)a4;
      if (mediaSubType[1] != 1835365473) {
        goto LABEL_62;
      }
      uint64_t NEAtomHeader = FigMetadataFormatDescriptionCreateWithExtensions(a1, mediaSubType[0], v32, (uint64_t *)a4);
      goto LABEL_64;
    }
    uint64_t v4 = (CMFormatDescriptionRef *)a4;
    if (mediaSubType[1] != 1885564004)
    {
      int v18 = 1885954932;
      goto LABEL_73;
    }
    CFDictionaryRef v14 = v32;
    CFAllocatorRef v15 = a1;
    CMMediaType v12 = 1885564004;
LABEL_63:
    uint64_t NEAtomHeader = CMFormatDescriptionCreate(v15, v12, v13, v14, v4);
    goto LABEL_64;
  }
  FourCharCode v13 = mediaSubType[0];
  if ((int)mediaSubType[1] <= 1668310897)
  {
    uint64_t v4 = (CMFormatDescriptionRef *)a4;
    if (mediaSubType[1] != 1635088502)
    {
      if (mediaSubType[1] != 1668047728) {
        goto LABEL_62;
      }
      CFDictionaryRef v14 = v32;
      CFAllocatorRef v15 = a1;
      CMMediaType v12 = 1668047728;
      goto LABEL_63;
    }
LABEL_74:
    uint64_t NEAtomHeader = CMVideoFormatDescriptionCreate(a1, HIDWORD(v26), v26, height[1], v32, v4);
    goto LABEL_64;
  }
  uint64_t v4 = (CMFormatDescriptionRef *)a4;
  if (mediaSubType[1] != 1668310898) {
    goto LABEL_62;
  }
  uint64_t NEAtomHeader = FigCaptionGroupFormatDescriptionCreate(a1, mediaSubType[0], a4);
LABEL_64:
  uint64_t v16 = NEAtomHeader;
  if (v32) {
    CFRelease(v32);
  }
  return v16;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  size_t v16 = 0;
  CFDictionaryRef v14 = 0;
  if (!a2 || !a3)
  {
    uint64_t v6 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  uint64_t v6 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v6)
  {
LABEL_9:
    uint64_t v11 = v6;
    uint64_t v8 = 0;
    goto LABEL_7;
  }
  size_t v15 = 0;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  _DWORD v13[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription_block_invoke;
  v13[3] = &__block_descriptor_tmp_56;
  _OWORD v13[4] = a2;
  uint64_t v7 = sbufAtom_createSerializedDataUsingSerializer(0x400uLL, &v14, &v16, &v15, (uint64_t)v13);
  uint64_t v8 = v14;
  if (v7)
  {
    uint64_t v11 = v7;
  }
  else
  {
    size_t v9 = v16;
    CFAllocatorRef GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    uint64_t v11 = CMBlockBufferCreateWithMemoryBlock(a1, v8, v9, GlobalCFAllocatorFigMalloc, 0, 0, v15, 0, a3);
    if (!v11) {
      uint64_t v8 = 0;
    }
  }
LABEL_7:
  free(v8);
  return v11;
}

uint64_t sbufAtom_createSerializedDataUsingSerializer(size_t a1, void *a2, size_t *a3, void *a4, uint64_t a5)
{
  uint64_t v19 = 0;
  size_t size = 0;
  char v10 = 1;
  while (1)
  {
    char v11 = v10;
    if (a1)
    {
      size_t size = a1;
      size_t v12 = a1;
    }
    else
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t, void, void, size_t *))(a5 + 16))(a5, 0, 0, &size);
      if (v13) {
        return v13;
      }
      size_t v12 = size;
      if (!size)
      {
        uint64_t v16 = 0;
        goto LABEL_11;
      }
    }
    CFDictionaryRef v14 = malloc_type_malloc(v12, 0x4F643828uLL);
    if (!v14) {
      return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    size_t v15 = v14;
    uint64_t v16 = (*(uint64_t (**)(uint64_t, void *, size_t, uint64_t *))(a5 + 16))(a5, v14, size, &v19);
    if (!v16)
    {
      size_t v17 = size;
      goto LABEL_15;
    }
    free(v15);
    size_t size = 0;
    if (!a1 || v16 != -12572) {
      return v16;
    }
    uint64_t v16 = 4294954724;
LABEL_11:
    char v10 = 0;
    a1 = 0;
    if ((v11 & 1) == 0)
    {
      size_t v17 = 0;
      size_t v15 = 0;
LABEL_15:
      *a2 = v15;
      *a3 = v17;
      *a4 = v19;
      return v16;
    }
  }
}

uint64_t FigRemote_CreateFormatDescriptionFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, void *a4)
{
  uint64_t v15 = 0;
  CFTypeRef cf = 0;
  if (!a4) {
    goto LABEL_14;
  }
  if (!theBuffer) {
    goto LABEL_14;
  }
  if (!CMBlockBufferGetDataLength(theBuffer)) {
    goto LABEL_14;
  }
  size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength)) {
    goto LABEL_14;
  }
  size_t v13 = 0;
  dataPointerOut = 0;
  CMBlockBufferGetDataPointer(theBuffer, a3, &v13, 0, &dataPointerOut);
  uint64_t v9 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v9) {
    goto LABEL_15;
  }
  uint64_t v9 = figReadNEAtomHeader((uint64_t)dataPointerOut, 0, v13, (_DWORD *)&v15 + 1, &v15);
  if (v9) {
    goto LABEL_15;
  }
  if (HIDWORD(v15) != 1717859171 || v13 < v15)
  {
LABEL_14:
    uint64_t v9 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_15:
    uint64_t v10 = v9;
    goto LABEL_12;
  }
  uint64_t v10 = sbufAtom_copyFormatDescriptionFromAtom(a1, (uint64_t)(dataPointerOut + 8), v15 - 8, &cf);
  CFTypeRef v11 = cf;
  if (v10 && cf)
  {
    CFRelease(cf);
LABEL_12:
    CFTypeRef v11 = 0;
  }
  *a4 = v11;
  return v10;
}

uint64_t FigRemote_CopyReplacementAttachmentsForSampleBuffer(const void *a1, CFArrayRef theArray, __CFDictionary **a3, __CFDictionary **a4)
{
  CMAttachmentMode attachmentModeOut = 1;
  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    CFIndex v10 = 0;
    while (1)
    {
      ValueAtIndedouble x = (const __CFString *)CFArrayGetValueAtIndex(theArray, v10);
      if (CMGetAttachment(a1, ValueAtIndex, &attachmentModeOut)) {
        break;
      }
LABEL_15:
      if (CFArrayGetCount(theArray) <= ++v10) {
        goto LABEL_18;
      }
    }
    if (attachmentModeOut)
    {
      if (attachmentModeOut != 1) {
        goto LABEL_20;
      }
      if (v8)
      {
        size_t v12 = v8;
LABEL_14:
        CFDictionaryRemoveValue(v12, ValueAtIndex);
        goto LABEL_15;
      }
      size_t v12 = figRemote_copyMutableDictionaryOfAttachments(a1, 1u);
      uint64_t v8 = v12;
    }
    else
    {
      if (v9)
      {
        size_t v12 = v9;
        goto LABEL_14;
      }
      size_t v12 = figRemote_copyMutableDictionaryOfAttachments(a1, 0);
      uint64_t v9 = v12;
    }
    if (!v12)
    {
LABEL_20:
      uint64_t v13 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      if (v8) {
        CFRelease(v8);
      }
      if (v9) {
        CFRelease(v9);
      }
      return v13;
    }
    goto LABEL_14;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
LABEL_18:
  uint64_t v13 = 0;
  *a3 = v8;
  *a4 = v9;
  return v13;
}

CFMutableDictionaryRef figRemote_copyMutableDictionaryOfAttachments(CMAttachmentBearerRef target, CMAttachmentMode attachmentMode)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v3 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], target, attachmentMode);
  CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(v2, v3);
  if (v3) {
    CFRelease(v3);
  }
  return MutableCopy;
}

uint64_t FigRemote_CreateSerializedAtomDataForSampleBufferWithOptions(opaqueCMSampleBuffer *a1, char a2, const __CFDictionary *a3, const __CFDictionary *a4, mach_port_t *a5, vm_address_t *a6, uint64_t a7, void *a8, const opaqueCMFormatDescription **a9, uint64_t *a10)
{
  IOSurfaceRef buffer = 0;
  if (a5) {
    p_IOSurfaceRef buffer = &buffer;
  }
  else {
    p_IOSurfaceRef buffer = 0;
  }
  uint64_t result = FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBufferWithOptions(0, a1, a2, a3, a4, p_buffer, a6, a7, a8, a9, a10);
  if (a5 && !result)
  {
    uint64_t result = (uint64_t)buffer;
    if (buffer)
    {
      mach_port_t MachPort = IOSurfaceCreateMachPort(buffer);
      *a5 = MachPort;
      if (MachPort) {
        return 0;
      }
      else {
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      *a5 = 0;
    }
  }
  return result;
}

uint64_t FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBufferWithOptions(const __CFAllocator *a1, opaqueCMSampleBuffer *a2, char a3, const __CFDictionary *a4, const __CFDictionary *a5, void *a6, vm_address_t *a7, uint64_t a8, void *a9, const opaqueCMFormatDescription **a10, uint64_t *a11)
{
  vm_address_t address = 0;
  uint64_t v46 = 0;
  uint64_t v44 = 0;
  if (!a2 || !a7 || !a9)
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (a10) {
    otherFormatDescription = *a10;
  }
  else {
    otherFormatDescription = 0;
  }
  if (a11) {
    uint64_t v16 = *a11;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v17) {
    return v17;
  }
  unsigned int v18 = 4 * (a3 & 3);
  uint64_t v34 = a6;
  if (a6) {
    uint64_t v19 = &v44;
  }
  else {
    uint64_t v19 = 0;
  }
  int v20 = &v43;
  if (!a10) {
    int v20 = 0;
  }
  unsigned int v37 = v20;
  uint64_t v38 = v19;
  p_CFTypeRef cf = &cf;
  if (!a11) {
    p_CFTypeRef cf = 0;
  }
  uint64_t v36 = p_cf;
  char v22 = 1;
  while (1)
  {
    char v23 = v22;
    if (a8)
    {
      uint64_t v46 = a8;
      uint64_t v24 = a8;
    }
    else
    {
      uint64_t v17 = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a2, v18, a4, 0, a5, 0, 0, 0, &v46, otherFormatDescription, v16, 0, 0, 0);
      if (v17) {
        return v17;
      }
      uint64_t v24 = v46;
      if (!v46)
      {
        uint64_t v27 = 0;
        goto LABEL_56;
      }
    }
    if (a1) {
      break;
    }
    uint64_t v32 = vm_allocate(*MEMORY[0x1E4F14960], &address, v24, 1543503873);
    vm_address_t v25 = address;
    if (v32)
    {
      uint64_t v27 = v32;
      if (!address || !v46) {
        goto LABEL_53;
      }
LABEL_51:
      MEMORY[0x192FC66D0](*MEMORY[0x1E4F14960], v25);
      goto LABEL_52;
    }
LABEL_25:
    CFTypeRef v43 = 0;
    CFTypeRef cf = 0;
    uint64_t SerializedDataAndSurfaceForSampleBuffer = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a2, v18, a4, 0, a5, v38, v25, v46, 0, otherFormatDescription, v16, 0, v37, v36);
    uint64_t v27 = SerializedDataAndSurfaceForSampleBuffer;
    if (a10 && !SerializedDataAndSurfaceForSampleBuffer)
    {
      uint64_t v28 = *a10;
      CFTypeRef v29 = v43;
      *a10 = (const opaqueCMFormatDescription *)v43;
      if (v29) {
        CFRetain(v29);
      }
      if (v28) {
        CFRelease(v28);
      }
    }
    if (a11 && !v27)
    {
      uint64_t v30 = (const void *)*a11;
      CFTypeRef v31 = cf;
      *a11 = (uint64_t)cf;
      if (v31) {
        CFRetain(v31);
      }
      if (v30) {
        CFRelease(v30);
      }
    }
    if (v43) {
      CFRelease(v43);
    }
    if (cf) {
      CFRelease(cf);
    }
    if (!v27 && gGMFigKTraceEnabled == 1)
    {
      kdebug_trace();
      uint64_t v27 = 0;
      goto LABEL_61;
    }
    if (!v27) {
      goto LABEL_61;
    }
    vm_address_t v25 = address;
    if (!address || !v46) {
      goto LABEL_53;
    }
    if (!a1) {
      goto LABEL_51;
    }
    CFAllocatorDeallocate(a1, (void *)address);
LABEL_52:
    vm_address_t address = 0;
    uint64_t v46 = 0;
LABEL_53:
    if (!a8 || v27 != -12572) {
      goto LABEL_61;
    }
    uint64_t v27 = 4294954724;
LABEL_56:
    char v22 = 0;
    a8 = 0;
    if ((v23 & 1) == 0) {
      goto LABEL_61;
    }
  }
  vm_address_t v25 = (vm_address_t)CFAllocatorAllocate(a1, v24, 0);
  vm_address_t address = v25;
  if (v25) {
    goto LABEL_25;
  }
  uint64_t v27 = 4294954510;
LABEL_61:
  *a9 = v46;
  *a7 = address;
  if (v34) {
    *uint64_t v34 = v44;
  }
  return v27;
}

uint64_t FigRemote_CreateSerializedAtomDataForSampleBuffer(opaqueCMSampleBuffer *a1, const __CFDictionary *a2, const __CFDictionary *a3, mach_port_t *a4, vm_address_t *a5, uint64_t a6, void *a7, const opaqueCMFormatDescription **a8, uint64_t *a9)
{
  return FigRemote_CreateSerializedAtomDataForSampleBufferWithOptions(a1, 0, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(opaqueCMSampleBuffer *a1, unsigned int a2, const __CFDictionary *a3, const __CFDictionary *a4, const __CFDictionary *a5, void *a6, uint64_t a7, uint64_t a8, void *a9, CMFormatDescriptionRef otherFormatDescription, uint64_t a11, int a12, void *a13, void *a14)
{
  CFTypeRef v83 = 0;
  CFTypeRef cf = 0;
  desc = CMSampleBufferGetFormatDescription(a1);
  CVImageBufferRef ImageBuffer = CMSampleBufferGetImageBuffer(a1);
  uint64_t TaggedBufferGroup = FigSampleBufferGetTaggedBufferGroup((uint64_t)a1);
  size_t v21 = 0;
  CFTypeRef v22 = 0;
  if (!((unint64_t)ImageBuffer | TaggedBufferGroup))
  {
    CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(a1);
    if (DataBuffer)
    {
      uint64_t v24 = DataBuffer;
      CFTypeRef v22 = CMGetAttachment(DataBuffer, @"CVDataBuffer", 0);
      if (v22) {
        size_t v21 = 0;
      }
      else {
        size_t v21 = v24;
      }
    }
    else
    {
      size_t v21 = 0;
      CFTypeRef v22 = 0;
    }
  }
  int v82 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v79 = 0u;
  if (CMFormatDescriptionGetMediaType(desc) == 1668310898)
  {
    uint64_t CFDataFromCaptionGroup = FigCaptionSerializerCreate(*MEMORY[0x1E4F1CF80], (void ***)&cf);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
    uint64_t CaptionGroup = FigSampleBufferGetCaptionGroup((uint64_t)a1);
    uint64_t CFDataFromCaptionGroup = FigCaptionSerializerCreateCFDataFromCaptionGroup((uint64_t)cf, CaptionGroup, (CFMutableDataRef *)&v83);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
  }
  int v82 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  *(void *)&long long v79 = a7;
  *((void *)&v79 + 1) = a8;
  uint64_t CFDataFromCaptionGroup = FigNEAtomWriterBeginAtom((uint64_t)&v79, 1935832422);
  if (CFDataFromCaptionGroup) {
    goto LABEL_92;
  }
  memset(&v85, 0, 24);
  CMSampleBufferGetOutputPresentationTimeStamp(&v85.duration, a1);
  if (v85.duration.flags)
  {
    uint64_t CFDataFromCaptionGroup = sbufAtom_appendAtomWithMemoryBlock(&v85, 0x18uLL, 1869640819, (uint64_t *)&v79);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
  }
  memset(&v85, 0, sizeof(v85));
  timingArrayEntriesNeededOut[0] = 0;
  SampleTimingInfoArradouble y = CMSampleBufferGetSampleTimingInfoArray(a1, 0, 0, timingArrayEntriesNeededOut);
  if (SampleTimingInfoArray == -12736) {
    goto LABEL_27;
  }
  uint64_t appended = SampleTimingInfoArray;
  CFTypeRef v29 = 0;
  if (!timingArrayEntriesNeededOut[0] || !(void)v79) {
    goto LABEL_18;
  }
  if (timingArrayEntriesNeededOut[0] == 1)
  {
    CFTypeRef v29 = &v85;
    uint64_t appended = CMSampleBufferGetSampleTimingInfoArray(a1, 1, &v85, timingArrayEntriesNeededOut);
LABEL_18:
    uint64_t v30 = 0;
    if (appended)
    {
LABEL_19:
      free(v30);
      goto LABEL_133;
    }
    goto LABEL_25;
  }
  if (timingArrayEntriesNeededOut[0] > 0x38E38E38E38E38EuLL
    || (CFTypeRef v31 = (CMSampleTimingInfo *)malloc_type_malloc(72 * timingArrayEntriesNeededOut[0], 0xD1AAB5CuLL)) == 0)
  {
    uint64_t appended = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    uint64_t v30 = 0;
    goto LABEL_26;
  }
  uint64_t v30 = v31;
  uint64_t v32 = CMSampleBufferGetSampleTimingInfoArray(a1, timingArrayEntriesNeededOut[0], v31, timingArrayEntriesNeededOut);
  if (v32)
  {
    uint64_t appended = v32;
    goto LABEL_19;
  }
  CFTypeRef v29 = v30;
LABEL_25:
  uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(v29, 72 * timingArrayEntriesNeededOut[0], 1937008993, (uint64_t *)&v79);
LABEL_26:
  free(v30);
  if (appended) {
    goto LABEL_133;
  }
LABEL_27:
  if (ImageBuffer)
  {
    if (!a6 || (IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(ImageBuffer), (*a6 = IOSurface) != 0))
    {
      uint64_t v34 = desc;
      if (a5)
      {
        CFDictionaryRef v35 = a5;
        uint64_t v36 = 1767994484;
        goto LABEL_37;
      }
      CFDictionaryRef v38 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ImageBuffer, 1u);
      if (!v38) {
        goto LABEL_52;
      }
      CFDictionaryRef v39 = v38;
      uint64_t v40 = 1767994484;
      goto LABEL_51;
    }
    goto LABEL_157;
  }
  if (v22)
  {
    uint64_t v34 = desc;
    if (!a6 || (uint64_t v37 = CVDataBufferGetIOSurface(), (*a6 = v37) != 0))
    {
      LOBYTE(v85.duration.value) = CFBooleanGetValue((CFBooleanRef)*MEMORY[0x1E4F1CFD0]);
      sbufAtom_appendAtomWithMemoryBlock(&v85, 1uLL, 1768911716, (uint64_t *)&v79);
      if (a5)
      {
        CFDictionaryRef v35 = a5;
        uint64_t v36 = 1684108404;
LABEL_37:
        uint64_t CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(v35, 1, v36, &v79);
        if (CFDataFromCaptionGroup) {
          goto LABEL_92;
        }
LABEL_52:
        BOOL v43 = ((unint64_t)ImageBuffer | TaggedBufferGroup) == 0;
        if (!v34) {
          BOOL v43 = 0;
        }
        if (v43 && (!otherFormatDescription || !CMFormatDescriptionEqual(v34, otherFormatDescription)))
        {
          memset(&v85.presentationTimeStamp.timescale, 0, 20);
          *(_OWORD *)&v85.duration.unsigned int value = v79;
          v85.duration.CMTimeEpoch epoch = (CMTimeEpoch)&v79;
          v85.presentationTimeStamp.unsigned int value = *((void *)&v81 + 1) + *((void *)&v80 + 1);
          uint64_t CFDataFromCaptionGroup = FigNEAtomWriterBeginAtom((uint64_t)&v85, 1717859171);
          if (CFDataFromCaptionGroup) {
            goto LABEL_92;
          }
          uint64_t CFDataFromCaptionGroup = (uint64_t)sbufAtom_appendFormatDescriptionAtomGuts(v34, &v85.duration.value);
          if (CFDataFromCaptionGroup) {
            goto LABEL_92;
          }
          uint64_t CFDataFromCaptionGroup = FigNEAtomWriterEndAtom((uint64_t)&v85);
          if (CFDataFromCaptionGroup) {
            goto LABEL_92;
          }
        }
        uint64_t Decryptor = FigSampleBufferGetDecryptor((uint64_t)a1);
        uint64_t v45 = (const void *)Decryptor;
        if (!(a11 | Decryptor) || FigCFEqual((CFTypeRef)Decryptor, (CFTypeRef)a11)) {
          goto LABEL_100;
        }
        if ((a2 & 4) == 0)
        {
          v85.duration.unsigned int value = 0;
          if (!v45)
          {
            size_t v53 = 0;
LABEL_98:
            uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(&v85, v53, 1668310371, (uint64_t *)&v79);
            goto LABEL_99;
          }
          uint64_t v46 = *(void **)(CMBaseObjectGetVTable((uint64_t)v45) + 16);
          if (v46) {
            float v47 = v46;
          }
          else {
            float v47 = 0;
          }
          if (*v47 < 4uLL
            || (os_log_type_t v54 = (uint64_t (*)(const void *, CMSampleTimingInfo *))v47[13]) == 0
            || (uint64_t appended = v54(v45, &v85), appended == -12782))
          {
            if (!a12)
            {
LABEL_90:
              uint64_t appended = 0;
              goto LABEL_99;
            }
            if (!(void)v79)
            {
LABEL_97:
              size_t v53 = 8;
              goto LABEL_98;
            }
            uint64_t appended = FigCPECryptorServerGetIDForCryptorByAssociatingWithClientPID(v45, a12, &v85);
            if (appended == -17575) {
              goto LABEL_90;
            }
          }
          if (appended) {
            goto LABEL_99;
          }
          goto LABEL_97;
        }
        v85.duration.unsigned int value = 0;
        if (v45)
        {
          float v48 = *(void **)(CMBaseObjectGetVTable((uint64_t)v45) + 16);
          if (*v48 < 8uLL || (int v49 = (uint64_t (*)(const void *, CMSampleTimingInfo *))v48[33]) == 0)
          {
            uint64_t appended = 4294954514;
            goto LABEL_99;
          }
          uint64_t appended = v49(v45, &v85);
          unsigned int value = (const void *)v85.duration.value;
          if (appended) {
            goto LABEL_78;
          }
          BytePtr = CFDataGetBytePtr((CFDataRef)v85.duration.value);
          size_t Length = CFDataGetLength((CFDataRef)v85.duration.value);
        }
        else
        {
          size_t Length = 0;
          BytePtr = 0;
        }
        uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(BytePtr, Length, 1935897200, (uint64_t *)&v79);
        unsigned int value = (const void *)v85.duration.value;
LABEL_78:
        if (value) {
          CFRelease(value);
        }
LABEL_99:
        if (appended) {
          goto LABEL_133;
        }
LABEL_100:
        if (a3)
        {
          uint64_t CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(a3, 1, 1935766644, &v79);
          if (CFDataFromCaptionGroup) {
            goto LABEL_92;
          }
        }
        else
        {
          CFDictionaryRef v58 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 1u);
          if (v58)
          {
            CFDictionaryRef v59 = v58;
            uint64_t appended = sbufAtom_appendDictionaryAtom(v58, 1, 1935766644, &v79);
            CFRelease(v59);
            if (appended) {
              goto LABEL_133;
            }
          }
        }
        if (a4)
        {
          uint64_t CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(a4, 1, 1935766578, &v79);
          __int16 v60 = desc;
          if (CFDataFromCaptionGroup) {
            goto LABEL_92;
          }
        }
        else
        {
          CFDictionaryRef v61 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0);
          __int16 v60 = desc;
          if (v61)
          {
            CFDictionaryRef v62 = v61;
            uint64_t appended = sbufAtom_appendDictionaryAtom(v61, 1, 1935766578, &v79);
            CFRelease(v62);
            if (appended) {
              goto LABEL_133;
            }
          }
        }
        SampleAttachmentsArradouble y = CMSampleBufferGetSampleAttachmentsArray(a1, 0);
        if (!SampleAttachmentsArray) {
          goto LABEL_161;
        }
        CFArrayRef v64 = SampleAttachmentsArray;
        memset(&v85.presentationTimeStamp.timescale, 0, 20);
        *(_OWORD *)&v85.duration.unsigned int value = v79;
        v85.duration.CMTimeEpoch epoch = (CMTimeEpoch)&v79;
        v85.presentationTimeStamp.unsigned int value = *((void *)&v81 + 1) + *((void *)&v80 + 1);
        uint64_t CFDataFromCaptionGroup = FigNEAtomWriterBeginAtom((uint64_t)&v85, 1935766137);
        if (!CFDataFromCaptionGroup)
        {
          CFIndex Count = CFArrayGetCount(v64);
          if (Count >= 1)
          {
            CFIndex v66 = Count;
            CFIndex v67 = 0;
            do
            {
              ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(v64, v67);
              uint64_t CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(ValueAtIndex, a2 & 2 ^ 3, 1684628340, &v85);
              if (CFDataFromCaptionGroup) {
                goto LABEL_92;
              }
            }
            while (v66 != ++v67);
          }
          uint64_t CFDataFromCaptionGroup = FigNEAtomWriterEndAtom((uint64_t)&v85);
          if (!CFDataFromCaptionGroup)
          {
LABEL_161:
            uint64_t CFDataFromCaptionGroup = FigNEAtomWriterEndAtom((uint64_t)&v79);
            if (!CFDataFromCaptionGroup)
            {
              if (a9)
              {
                uint64_t v69 = *((void *)&v81 + 1);
                if (*((void *)&v81 + 1) == 8) {
                  uint64_t v69 = 0;
                }
                *a9 = v69;
              }
              if (a13)
              {
                if (v60) {
                  CFTypeRef v70 = CFRetain(v60);
                }
                else {
                  CFTypeRef v70 = 0;
                }
                *a13 = v70;
              }
              if (a14)
              {
                if (v45) {
                  CFTypeRef v71 = CFRetain(v45);
                }
                else {
                  CFTypeRef v71 = 0;
                }
                uint64_t appended = 0;
                *a14 = v71;
              }
              else
              {
                uint64_t appended = 0;
              }
              goto LABEL_133;
            }
          }
        }
LABEL_92:
        uint64_t appended = CFDataFromCaptionGroup;
        goto LABEL_133;
      }
      CFDictionaryRef v38 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v22, 1u);
      if (!v38) {
        goto LABEL_52;
      }
      CFDictionaryRef v39 = v38;
      uint64_t v40 = 1684108404;
LABEL_51:
      uint64_t appended = sbufAtom_appendDictionaryAtom(v38, 1, v40, &v79);
      CFRelease(v39);
      if (appended) {
        goto LABEL_133;
      }
      goto LABEL_52;
    }
LABEL_157:
    uint64_t CFDataFromCaptionGroup = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_92;
  }
  if ((a2 & 1) != 0 || !v21)
  {
    if (v83)
    {
      uint64_t CFDataFromCaptionGroup = sbufAtom_appendDataAtom((const __CFData *)v83, 1667330151, (uint64_t *)&v79);
      uint64_t v34 = desc;
      if (CFDataFromCaptionGroup) {
        goto LABEL_92;
      }
      goto LABEL_52;
    }
    uint64_t v34 = desc;
    if (TaggedBufferGroup)
    {
      uint64_t CFDataFromCaptionGroup = sbufAtom_appendTagCollection(TaggedBufferGroup, a2, &v79);
      if (CFDataFromCaptionGroup) {
        goto LABEL_92;
      }
      goto LABEL_52;
    }
    v85.duration.unsigned int value = 0;
    uint64_t CFDataFromCaptionGroup = sbufAtom_appendNumSamples(a1, (uint64_t *)&v79);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
    uint64_t CFDataFromCaptionGroup = sbufAtom_appendSampleSizes(a1, 0, (uint64_t *)&v79, &v85.duration.value);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
    if (CMSampleBufferGetNumSamples(a1) < 1
      || CMFormatDescriptionGetMediaType(desc) != 1936684398
      || v85.duration.value)
    {
      goto LABEL_52;
    }
LABEL_149:
    uint64_t CFDataFromCaptionGroup = sbufAtom_appendPacketDescriptions(a1, (uint64_t *)&v79);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
    goto LABEL_52;
  }
  CMItemCount v78 = 0;
  unint64_t v41 = (*((void *)&v81 + 1) + 127) & 0xFFFFFFFFFFFFFF80;
  unint64_t v42 = v41 - 8 - *((void *)&v81 + 1);
  if (v41 - 8 != *((void *)&v81 + 1))
  {
    if (v41 - 8 > *((void *)&v81 + 1)) {
      size_t v55 = v42 >= 8 ? v41 - 8 - *((void *)&v81 + 1) : v42 + 128;
    }
    else {
      size_t v55 = *((void *)&v81 + 1) - v41 + 136;
    }
    uint64_t CFDataFromCaptionGroup = sbufAtom_appendAtomWithMemoryBlock(0, v55, 1718773093, (uint64_t *)&v79);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
  }
  v85.duration.unsigned int value = 0;
  timingArrayEntriesNeededOut[0] = 0;
  size_t DataLength = CMBlockBufferGetDataLength(v21);
  if (!(void)v79) {
    goto LABEL_141;
  }
  if (CMBlockBufferIsRangeContiguous(v21, 0, DataLength))
  {
    uint64_t v57 = v21;
  }
  else
  {
    uint64_t Contiguous = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v21, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, DataLength, 1u, (CMBlockBufferRef *)&v85);
    if (Contiguous) {
      goto LABEL_142;
    }
    uint64_t v57 = (OpaqueCMBlockBuffer *)v85.duration.value;
  }
  uint64_t Contiguous = CMBlockBufferGetDataPointer(v57, 0, 0, 0, (char **)timingArrayEntriesNeededOut);
  if (!Contiguous) {
LABEL_141:
  }
    uint64_t Contiguous = sbufAtom_appendAtomWithMemoryBlock((const void *)timingArrayEntriesNeededOut[0], DataLength, 1935958388, (uint64_t *)&v79);
LABEL_142:
  uint64_t appended = Contiguous;
  uint64_t v34 = desc;
  if (v85.duration.value) {
    CFRelease((CFTypeRef)v85.duration.value);
  }
  if (!appended)
  {
    uint64_t CFDataFromCaptionGroup = sbufAtom_appendNumSamples(a1, (uint64_t *)&v79);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
    uint64_t CFDataFromCaptionGroup = sbufAtom_appendSampleSizes(a1, (a2 >> 3) & 1, (uint64_t *)&v79, &v78);
    if (CFDataFromCaptionGroup) {
      goto LABEL_92;
    }
    if (CMFormatDescriptionGetMediaType(desc) != 1936684398 || v78) {
      goto LABEL_52;
    }
    goto LABEL_149;
  }
LABEL_133:
  if (cf) {
    CFRelease(cf);
  }
  if (v83) {
    CFRelease(v83);
  }
  return appended;
}

uint64_t FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBuffer(const __CFAllocator *a1, opaqueCMSampleBuffer *a2, const __CFDictionary *a3, const __CFDictionary *a4, void *a5, vm_address_t *a6, uint64_t a7, void *a8, const opaqueCMFormatDescription **a9, uint64_t *a10)
{
  return FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBufferWithOptions(a1, a2, 0, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForSampleBuffer(const __CFAllocator *a1, const __CFAllocator *a2, opaqueCMSampleBuffer *a3, uint64_t a4, CMBlockBufferRef *a5, const opaqueCMFormatDescription **a6, uint64_t *a7)
{
  return FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForSampleBuffer(a1, a2, a3, a4, 0, a5, a6, a7);
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForSampleBuffer(const __CFAllocator *a1, const __CFAllocator *a2, opaqueCMSampleBuffer *a3, uint64_t a4, char a5, CMBlockBufferRef *a6, const opaqueCMFormatDescription **a7, uint64_t *a8)
{
  size_t v42 = 0;
  uint64_t v43 = 0;
  if (!a3)
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (!a7)
  {
    otherFormatDescription = 0;
    if (a8) {
      goto LABEL_4;
    }
LABEL_6:
    uint64_t v15 = 0;
    goto LABEL_7;
  }
  otherFormatDescription = *a7;
  if (!a8) {
    goto LABEL_6;
  }
LABEL_4:
  uint64_t v15 = *a8;
LABEL_7:
  uint64_t v16 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v16) {
    return v16;
  }
  CFAllocatorRef v34 = a1;
  CMBlockBufferRef blockBufferOut = a6;
  uint64_t v17 = 0;
  unsigned int v18 = 2 * (a5 & 1);
  if (a7) {
    p_CFTypeRef cf = &cf;
  }
  else {
    p_CFTypeRef cf = 0;
  }
  int v20 = &v40;
  if (!a8) {
    int v20 = 0;
  }
  uint64_t v36 = v20;
  uint64_t v37 = p_cf;
  char v21 = 1;
  do
  {
    char v22 = v21;
    if (a4)
    {
      uint64_t v43 = a4;
      CFIndex v23 = a4;
    }
    else
    {
      uint64_t v24 = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a3, v18, 0, 0, 0, 0, 0, 0, &v43, otherFormatDescription, v15, 0, 0, 0);
      if (v24) {
        goto LABEL_43;
      }
      CFIndex v23 = v43;
      if (!v43) {
        goto LABEL_40;
      }
    }
    uint64_t v17 = CFAllocatorAllocate(a2, v23, 0);
    size_t v25 = v43;
    if (!v17) {
      break;
    }
    CFAllocatorRef v26 = a2;
    CFTypeRef v40 = 0;
    CFTypeRef cf = 0;
    uint64_t v27 = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a3, v18, 0, 0, 0, 0, (uint64_t)v17, v43, &v42, otherFormatDescription, v15, 0, v37, v36);
    uint64_t v28 = v27;
    if (a7 && !v27)
    {
      CFTypeRef v29 = *a7;
      CFTypeRef v30 = cf;
      *a7 = (const opaqueCMFormatDescription *)cf;
      if (v30) {
        CFRetain(v30);
      }
      if (v29) {
        CFRelease(v29);
      }
    }
    if (a8 && !v28)
    {
      CFTypeRef v31 = (const void *)*a8;
      CFTypeRef v32 = v40;
      *a8 = (uint64_t)v40;
      if (v32) {
        CFRetain(v32);
      }
      if (v31) {
        CFRelease(v31);
      }
    }
    if (cf) {
      CFRelease(cf);
    }
    a2 = v26;
    if (v40) {
      CFRelease(v40);
    }
    size_t v25 = v43;
    if (!v28) {
      break;
    }
    if (v43)
    {
      CFAllocatorDeallocate(v26, v17);
      uint64_t v17 = 0;
      uint64_t v43 = 0;
    }
    if (!a4 || v28 != -12572) {
      goto LABEL_44;
    }
LABEL_40:
    char v21 = 0;
    a4 = 0;
    size_t v25 = 0;
  }
  while ((v22 & 1) != 0);
  uint64_t v24 = CMBlockBufferCreateWithMemoryBlock(v34, v17, v25, a2, 0, 0, v42, 0, blockBufferOut);
  uint64_t v28 = 0;
  if (!v24) {
    return v28;
  }
LABEL_43:
  uint64_t v28 = v24;
LABEL_44:
  if (v17) {
    CFAllocatorDeallocate(a2, v17);
  }
  return v28;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomData(mach_port_t a1, void *a2, size_t dataLength, const opaqueCMFormatDescription **a4, CFTypeRef *a5, CMSampleBufferRef *a6)
{
  HIDWORD(customBlockSource.AllocateBlock) = 0;
  customBlockSource.refCon = 0;
  CMBlockBufferRef theBuffer = 0;
  *(void *)&customBlockSource.version = 0;
  customBlockSource.FreeBlocuint64_t k = (void (__cdecl *)(void *, void *, size_t))_bbufBlockSourceFree;
  uint64_t v12 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, dataLength, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], &customBlockSource, 0, dataLength, 0, &theBuffer);
  if (!v12)
  {
    if (a1)
    {
      uint64_t v13 = IOSurfaceLookupFromMachPort(a1);
      if (v13)
      {
        CFDictionaryRef v14 = v13;
        uint64_t SampleBufferFromSerializedAtomBlockBufferAndSurface = FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurface(v13, theBuffer, a4, a5, a6);
        CFRelease(v14);
        goto LABEL_7;
      }
      uint64_t v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      uint64_t v12 = FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurface(0, theBuffer, a4, a5, a6);
    }
  }
  uint64_t SampleBufferFromSerializedAtomBlockBufferAndSurface = v12;
LABEL_7:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  else {
    MEMORY[0x192FC66D0](*MEMORY[0x1E4F14960], a2, dataLength);
  }
  return SampleBufferFromSerializedAtomBlockBufferAndSurface;
}

void _bbufBlockSourceFree(uint64_t a1, uint64_t a2)
{
  if (a2) {
    JUMPOUT(0x192FC66D0);
  }
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurface(__IOSurface *a1, CMBlockBufferRef theBuffer, const opaqueCMFormatDescription **a3, CFTypeRef *a4, CMSampleBufferRef *a5)
{
  char v19 = 0;
  size_t v17 = 0;
  size_t v18 = 0;
  size_t lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  size_t totalLengthOut = 0;
  uint64_t result = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (!result)
  {
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t result = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1, dataPointerOut, (const __CFAllocator *)lengthAtOffsetOut, 0, a3, a4, &v19, &v18, (uint64_t *)&v17, a5);
    if (!result && v19 != 0)
    {
      CMBlockBufferRef blockBufferOut = 0;
      uint64_t result = CMBlockBufferCreateWithBufferReference(v11, theBuffer, v18, v17, 0, &blockBufferOut);
      if (!result)
      {
        CMSampleBufferSetDataBuffer(*a5, blockBufferOut);
        if (blockBufferOut) {
          CFRelease(blockBufferOut);
        }
        return CMSampleBufferSetDataReady(*a5);
      }
    }
  }
  return result;
}

uint64_t sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(const __CFAllocator *a1, __IOSurface *a2, char *a3, const __CFAllocator *a4, char a5, const opaqueCMFormatDescription **a6, CFTypeRef *a7, unsigned char *a8, void *a9, uint64_t *a10, CMSampleBufferRef *a11)
{
  CMVideoFormatDescriptionRef formatDescriptionOut = 0;
  CMSampleBufferRef sampleBufferOut = 0;
  size_t v114 = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  char v113 = 0;
  CVPixelBufferRef v112 = 0;
  memset((char *)&v111[1] + 4, 0, 12);
  CFTypeRef v110 = 0;
  v111[0] = 0;
  CFDictionaryRef theAttachments = 0;
  CFDictionaryRef v109 = 0;
  CFTypeRef v107 = 0;
  memset(v106, 0, sizeof(v106));
  if (!a11) {
    goto LABEL_275;
  }
  CFAllocatorRef v11 = a3;
  if (a3)
  {
    CFAllocatorRef v12 = a4;
    if (!a4)
    {
      uint64_t CaptionGroupFromCFData = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      CFTypeRef v20 = 0;
      CFTypeRef v94 = 0;
      CFArrayRef v19 = 0;
LABEL_278:
      CFAllocatorRef v11 = 0;
      goto LABEL_219;
    }
    if (a6)
    {
      uint64_t v99 = *a6;
      if (a7)
      {
LABEL_6:
        CFTypeRef cf = *a7;
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t v99 = 0;
      if (a7) {
        goto LABEL_6;
      }
    }
    CFTypeRef cf = 0;
LABEL_9:
    uint64_t NEAtomHeader = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
    if (NEAtomHeader
      || (CFTypeRef v87 = a8,
          uint64_t NEAtomHeader = figReadNEAtomHeader((uint64_t)v11, 0, (unint64_t)v12, (_DWORD *)v106 + 1, v106),
          NEAtomHeader))
    {
LABEL_276:
      uint64_t CaptionGroupFromCFData = NEAtomHeader;
      CFTypeRef v20 = 0;
      CFTypeRef v94 = 0;
      CFArrayRef v19 = 0;
LABEL_277:
      CFAllocatorRef v12 = 0;
      goto LABEL_278;
    }
    if (HIDWORD(v106[0]) == 1935832422)
    {
      __int16 v86 = (const void **)a6;
      unint64_t v18 = LODWORD(v106[0]);
      if (LODWORD(v106[0]) <= (unint64_t)v12)
      {
        CFAllocatorRef allocator = a1;
        CMSampleTimingInfo v85 = a7;
        if (LODWORD(v106[0]) >= 9)
        {
          uint64_t v91 = 0;
          uint64_t v92 = 0;
          unint64_t v81 = 0;
          int v82 = 0;
          CMItemCount v83 = 0;
          packetDescriptions = 0;
          uint64_t v98 = 0;
          unint64_t v90 = 0;
          sampleTiming = 0;
          CFTypeRef v94 = 0;
          int v97 = 0;
          CFArrayRef v19 = 0;
          CFTypeRef v20 = 0;
          uint64_t v104 = v11 + 8;
          CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          unint64_t v21 = 8;
          while (1)
          {
            uint64_t v22 = figReadNEAtomHeader((uint64_t)v11, v21, v18, (_DWORD *)v106 + 1, v106);
            if (v22) {
              goto LABEL_272;
            }
            CFIndex v23 = v11;
            uint64_t v24 = (void **)&v104[v21];
            unint64_t v25 = LODWORD(v106[0]) - 8;
            if (SHIDWORD(v106[0]) > 1885631330)
            {
              if (SHIDWORD(v106[0]) <= 1935897199)
              {
                if (SHIDWORD(v106[0]) <= 1935766577)
                {
                  if (HIDWORD(v106[0]) == 1885631331)
                  {
                    if (!HIDWORD(v111[1]) || ((16 * HIDWORD(v111[1])) | 8uLL) > LODWORD(v106[0]))
                    {
LABEL_271:
                      uint64_t v22 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
                      goto LABEL_272;
                    }
                    packetDescriptions = (AudioStreamPacketDescription *)&v104[v21];
                    unint64_t v81 = LODWORD(v106[0]) - 8;
                  }
                  else if (HIDWORD(v106[0]) == 1935766137)
                  {
                    uint64_t v22 = sbufAtom_copyArrayFromAtom(allocator, (uint64_t)&v104[v21], LODWORD(v106[0]) - 8, (CFMutableArrayRef *)&v107);
                    if (v22) {
                      goto LABEL_272;
                    }
                  }
                  goto LABEL_104;
                }
                if (HIDWORD(v106[0]) == 1935766578)
                {
                  p_CFDictionaryRef theAttachments = (__CFDictionary **)&v110;
                }
                else
                {
                  if (HIDWORD(v106[0]) != 1935766644) {
                    goto LABEL_104;
                  }
                  p_CFDictionaryRef theAttachments = (__CFDictionary **)v111;
                }
LABEL_103:
                uint64_t v22 = sbufAtom_copyDictionaryFromAtom(allocator, (uint64_t)&v104[v21], LODWORD(v106[0]) - 8, p_theAttachments);
                if (v22) {
                  goto LABEL_272;
                }
                goto LABEL_104;
              }
              if (SHIDWORD(v106[0]) > 1936943481)
              {
                switch(HIDWORD(v106[0]))
                {
                  case 0x7373697A:
                    if (LODWORD(v106[0]) <= 0xB) {
                      goto LABEL_271;
                    }
                    if (v98) {
                      free(v98);
                    }
                    unint64_t v90 = v25 >> 2;
                    if (v25 > 3)
                    {
                      uint64_t v44 = (const size_t *)malloc_type_malloc(8 * (v25 >> 2), 0xD1AAB5CuLL);
                      if (!v44)
                      {
LABEL_287:
                        uint64_t CaptionGroupFromCFData = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                        goto LABEL_277;
                      }
                      uint64_t v46 = 0;
                      uint64_t v47 = v25 >> 2;
                      if (v90 <= 1) {
                        uint64_t v47 = 1;
                      }
                      do
                      {
                        v44[v46] = *((unsigned int *)v24 + v46);
                        ++v46;
                      }
                      while (v47 != v46);
                    }
                    else
                    {
                      uint64_t v44 = (const size_t *)malloc_type_malloc(0, 0x2CFEBD2BuLL);
                      if (!v44) {
                        goto LABEL_287;
                      }
                    }
                    int v82 = v44;
                    uint64_t v98 = (size_t *)v44;
                    break;
                  case 0x73746961:
                    if (LODWORD(v106[0]) <= 0x4F) {
                      goto LABEL_271;
                    }
                    CMItemCount v83 = v25 / 0x48;
                    sampleTiming = (CMSampleTimingInfo *)&v104[v21];
                    break;
                  case 0x74636F6C:
                    outputPresentationTimeStamp.CMTimeValue value = 0;
                    *(void *)&long long v123 = 0;
                    uint64_t v26 = sbufAtom_copyArrayFromAtom(allocator, (uint64_t)&v104[v21], LODWORD(v106[0]) - 8, (CFMutableArrayRef *)&v123);
                    if (v26)
                    {
                      uint64_t CaptionGroupFromCFData = v26;
                      CFMutableDictionaryRef Mutable = 0;
                    }
                    else
                    {
                      if ((void)v123 && (uint64_t Count = CFArrayGetCount((CFArrayRef)v123), Count >= 1))
                      {
                        uint64_t v28 = Count;
                        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v12, Count, MEMORY[0x1E4F1D510]);
                        if (Mutable)
                        {
                          CFTypeRef v95 = v20;
                          CFIndex v30 = 0;
                          while (1)
                          {
                            ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)v123, v30);
                            if (!ValueAtIndex) {
                              break;
                            }
                            uint64_t v32 = FigTagCollectionCreateFromData(ValueAtIndex, v12, &outputPresentationTimeStamp);
                            if (v32)
                            {
                              uint64_t CaptionGroupFromCFData = v32;
                              goto LABEL_40;
                            }
                            CFArrayAppendValue(Mutable, (const void *)outputPresentationTimeStamp.value);
                            if (outputPresentationTimeStamp.value)
                            {
                              CFRelease((CFTypeRef)outputPresentationTimeStamp.value);
                              outputPresentationTimeStamp.CMTimeValue value = 0;
                            }
                            if (v28 == ++v30)
                            {
                              uint64_t CaptionGroupFromCFData = 0;
                              CFArrayRef v19 = Mutable;
                              CFMutableDictionaryRef Mutable = 0;
LABEL_40:
                              CFTypeRef v20 = v95;
                              goto LABEL_128;
                            }
                          }
                          uint64_t v48 = 4294954516;
                          CFTypeRef v20 = v95;
                        }
                        else
                        {
                          uint64_t v48 = 4294954510;
                        }
                      }
                      else
                      {
                        CFMutableDictionaryRef Mutable = 0;
                        uint64_t v48 = 4294954516;
                      }
                      uint64_t CaptionGroupFromCFData = FigSignalErrorAt(v48, 0, 0, 0, 0, 0, 0);
                    }
LABEL_128:
                    if (outputPresentationTimeStamp.value) {
                      CFRelease((CFTypeRef)outputPresentationTimeStamp.value);
                    }
                    if (Mutable) {
                      CFRelease(Mutable);
                    }
                    uint64_t v43 = (const void *)v123;
                    if (!(void)v123)
                    {
LABEL_85:
                      if (CaptionGroupFromCFData) {
                        goto LABEL_273;
                      }
                      break;
                    }
LABEL_84:
                    CFRelease(v43);
                    goto LABEL_85;
                }
LABEL_104:
                CFAllocatorRef v11 = v23;
                goto LABEL_105;
              }
              if (HIDWORD(v106[0]) != 1935897200)
              {
                if (HIDWORD(v106[0]) == 1935958388)
                {
                  int v97 = 1;
                  if (!HIDWORD(v111[1])) {
                    HIDWORD(v111[1]) = 1;
                  }
                  uint64_t v91 = &v104[v21];
                  uint64_t v92 = LODWORD(v106[0]) - 8;
                }
                goto LABEL_104;
              }
            }
            else
            {
              if (SHIDWORD(v106[0]) <= 1767994483)
              {
                if (SHIDWORD(v106[0]) <= 1684108403)
                {
                  if (HIDWORD(v106[0]) != 1667330151)
                  {
                    if (HIDWORD(v106[0]) == 1668310371)
                    {
                      CMTimeValue value = 0;
                      outputPresentationTimeStamp.CMTimeValue value = 0;
                      if (LODWORD(v106[0]) != 8)
                      {
                        if (LODWORD(v106[0]) != 16)
                        {
                          uint64_t CaptionGroupFromCFData = 4294966630;
                          CFAllocatorRef v11 = (char *)v98;
                          goto LABEL_263;
                        }
                        uint64_t v35 = FigCPECopyCryptorForSerializationToken(*v24, &outputPresentationTimeStamp);
                        CMTimeValue value = outputPresentationTimeStamp.value;
                        if (v35)
                        {
                          uint64_t CaptionGroupFromCFData = v35;
                          CFAllocatorRef v11 = (char *)v98;
                          if (outputPresentationTimeStamp.value) {
                            CFRelease((CFTypeRef)outputPresentationTimeStamp.value);
                          }
                          goto LABEL_263;
                        }
                      }
                      CFTypeRef cf = (CFTypeRef)value;
                      CFTypeRef v20 = (CFTypeRef)value;
                    }
                    goto LABEL_104;
                  }
                  outputPresentationTimeStamp.CMTimeValue value = 0;
                  *(void *)&long long v123 = 0;
                  uint64_t v41 = FigCaptionSerializerCreate((uint64_t)v12, (void ***)&v123);
                  if (v41)
                  {
                    uint64_t CaptionGroupFromCFData = v41;
                    CFDataRef v42 = 0;
                  }
                  else
                  {
                    CFDataRef v42 = CFDataCreate(allocator, (const UInt8 *)v24, v25);
                    uint64_t CaptionGroupFromCFData = FigCaptionSerializerCreateCaptionGroupFromCFData((void **)v123, v42, (CFTypeRef *)&outputPresentationTimeStamp);
                    if (!CaptionGroupFromCFData)
                    {
                      CFTypeRef v94 = (CFTypeRef)outputPresentationTimeStamp.value;
                      outputPresentationTimeStamp.CMTimeValue value = 0;
                    }
                  }
                  if ((void)v123) {
                    CFRelease((CFTypeRef)v123);
                  }
                  if (v42) {
                    CFRelease(v42);
                  }
                  uint64_t v43 = (const void *)outputPresentationTimeStamp.value;
                  if (!outputPresentationTimeStamp.value) {
                    goto LABEL_85;
                  }
                  goto LABEL_84;
                }
                if (HIDWORD(v106[0]) != 1684108404)
                {
                  if (HIDWORD(v106[0]) == 1717859171)
                  {
                    uint64_t v22 = sbufAtom_copyFormatDescriptionFromAtom(allocator, (uint64_t)&v104[v21], LODWORD(v106[0]) - 8, (CFTypeRef *)&formatDescriptionOut);
                    if (v22) {
                      goto LABEL_272;
                    }
                    uint64_t v99 = formatDescriptionOut;
                  }
                  goto LABEL_104;
                }
                p_CFDictionaryRef theAttachments = &theAttachments;
                goto LABEL_103;
              }
              if (SHIDWORD(v106[0]) <= 1818456687)
              {
                if (HIDWORD(v106[0]) == 1767994484)
                {
                  p_CFDictionaryRef theAttachments = &v109;
                  goto LABEL_103;
                }
                if (HIDWORD(v106[0]) != 1768911716) {
                  goto LABEL_104;
                }
                if (LODWORD(v106[0]) != 9) {
                  goto LABEL_271;
                }
LABEL_93:
                __memcpy_chk();
                goto LABEL_104;
              }
              if (HIDWORD(v106[0]) != 1818456688)
              {
                if (HIDWORD(v106[0]) == 1853058416)
                {
                  if (LODWORD(v106[0]) != 12) {
                    goto LABEL_271;
                  }
                }
                else
                {
                  if (HIDWORD(v106[0]) != 1869640819) {
                    goto LABEL_104;
                  }
                  if (LODWORD(v106[0]) != 32) {
                    goto LABEL_271;
                  }
                }
                goto LABEL_93;
              }
            }
            CFTypeRef v119 = 0;
            char v118 = 0;
            if (LODWORD(v106[0]) == 8)
            {
              CFTypeRef v20 = 0;
              CFDataRef v37 = 0;
            }
            else
            {
              CFDataRef v37 = CFDataCreate(v12, (const UInt8 *)v24, v25);
              if (!cf) {
                goto LABEL_110;
              }
              CFDictionaryRef v38 = *(void **)(CMBaseObjectGetVTable((uint64_t)cf) + 16);
              if (*v38 < 8uLL || (CFDictionaryRef v39 = (uint64_t (*)(CFTypeRef, CFDataRef, char *))v38[34]) == 0)
              {
                uint64_t CaptionGroupFromCFData = 4294954514;
                if (!v37) {
                  goto LABEL_117;
                }
                goto LABEL_116;
              }
              uint64_t v40 = v39(cf, v37, &v118);
              if (v40) {
                goto LABEL_139;
              }
              if (v118 == 1)
              {
                CFTypeRef v20 = CFRetain(cf);
              }
              else
              {
LABEL_110:
                *(void *)&long long v123 = 0;
                *((void *)&v123 + 1) = &v123;
                uint64_t epoch = 0x2000000000;
                uint64_t v45 = (uint64_t (*)(const __CFAllocator *, CFDataRef, CFTypeRef *))getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr;
                int v125 = getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr;
                if (!getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr)
                {
                  outputPresentationTimeStamp.CMTimeValue value = MEMORY[0x1E4F143A8];
                  *(void *)&outputPresentationTimeStamp.timescale = 0x40000000;
                  outputPresentationTimeStamp.uint64_t epoch = (CMTimeEpoch)__getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_block_invoke;
                  int v121 = &unk_1E567DBB8;
                  int v122 = &v123;
                  __getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_block_invoke((uint64_t)&outputPresentationTimeStamp);
                  uint64_t v45 = *(uint64_t (**)(const __CFAllocator *, CFDataRef, CFTypeRef *))(*((void *)&v123 + 1)
                                                                                                + 24);
                }
                _Block_object_dispose(&v123, 8);
                if (!v45)
                {
                  sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface_cold_1();
                  goto LABEL_285;
                }
                uint64_t v40 = v45(allocator, v37, &v119);
                if (v40)
                {
LABEL_139:
                  uint64_t CaptionGroupFromCFData = v40;
                  if (!v37) {
                    goto LABEL_117;
                  }
LABEL_116:
                  CFRelease(v37);
                  goto LABEL_117;
                }
                CFTypeRef v20 = v119;
              }
            }
            uint64_t CaptionGroupFromCFData = 0;
            CFTypeRef v119 = 0;
            if (v37) {
              goto LABEL_116;
            }
LABEL_117:
            if (v119) {
              CFRelease(v119);
            }
            if (CaptionGroupFromCFData) {
              goto LABEL_273;
            }
            CFAllocatorRef v11 = v23;
            CFTypeRef cf = v20;
LABEL_105:
            v21 += LODWORD(v106[0]);
            if (v21 >= v18) {
              goto LABEL_142;
            }
          }
        }
        CFTypeRef v20 = 0;
        sampleTiming = 0;
        CFTypeRef v94 = 0;
        CFArrayRef v19 = 0;
        int v97 = 0;
        int v82 = 0;
        CMItemCount v83 = 0;
        unint64_t v90 = 0;
        uint64_t v91 = 0;
        uint64_t v98 = 0;
        packetDescriptions = 0;
        unint64_t v81 = 0;
        uint64_t v92 = 0;
LABEL_142:
        if (!a2)
        {
          FormatDescription = v99;
          int v50 = v97;
          goto LABEL_163;
        }
        FormatDescription = v99;
        int v50 = v97;
        if (v113)
        {
          uint64_t v22 = CVDataBufferCreateWithIOSurface();
          if (!v22)
          {
            if (theAttachments) {
              CVBufferSetAttachments(v114, theAttachments, kCVAttachmentMode_ShouldPropagate);
            }
            if (!v99)
            {
              uint64_t CaptionGroupFromCFData = 0;
LABEL_273:
              CFAllocatorRef v12 = 0;
              goto LABEL_274;
            }
LABEL_163:
            if (v19 && (uint64_t v52 = CFArrayGetCount(v19), v52 >= 1))
            {
              uint64_t v53 = v52;
              CFAllocatorRef v12 = CFArrayCreateMutable(allocator, v52, MEMORY[0x1E4F1D510]);
              if (!v12 || (CVPixelBufferCreate(allocator, 0x10uLL, 0x10uLL, 0x20u, 0, &v112), !v112))
              {
                uint64_t v77 = 4294954510;
                goto LABEL_282;
              }
              do
              {
                CFArrayAppendValue(v12, v112);
                --v53;
              }
              while (v53);
              if (v112)
              {
                CFRelease(v112);
                CVPixelBufferRef v112 = 0;
              }
              uint64_t v54 = FigTaggedBufferGroupCreate(allocator, v19, v12, &v111[2]);
              if (v54) {
                goto LABEL_283;
              }
              if (!FormatDescription)
              {
                if (formatDescriptionOut)
                {
                  CFRelease(formatDescriptionOut);
                  CMVideoFormatDescriptionRef formatDescriptionOut = 0;
                }
                uint64_t v54 = FigTaggedBufferGroupFormatDescriptionCreate(allocator, 1952606066, (CFTypeRef *)&formatDescriptionOut);
                if (v54) {
                  goto LABEL_283;
                }
                FormatDescription = formatDescriptionOut;
              }
            }
            else
            {
              CFAllocatorRef v12 = 0;
            }
            if (!pixelBufferOut || !v111[2])
            {
              Boolean v55 = (a5 & 1) == 0;
              if (pixelBufferOut)
              {
                uint64_t v56 = CMSampleBufferCreateForImageBuffer(allocator, pixelBufferOut, v55, 0, 0, FormatDescription, sampleTiming, &sampleBufferOut);
                goto LABEL_185;
              }
              if (v111[2])
              {
                CMTime outputPresentationTimeStamp = sampleTiming->presentationTimeStamp;
                long long v57 = *(_OWORD *)&sampleTiming->duration.value;
                uint64_t epoch = sampleTiming->duration.epoch;
                long long v123 = v57;
                uint64_t v56 = FigSampleBufferCreateForTaggedBufferGroup(allocator, v111[2], (long long *)&outputPresentationTimeStamp.value, (uint64_t)&v123, &sampleBufferOut);
                goto LABEL_185;
              }
              if (v114)
              {
                uint64_t v56 = CMSampleBufferCreateReadyForCVDataBuffer(allocator, v114, FormatDescription, (uint64_t)sampleTiming, &sampleBufferOut);
                goto LABEL_185;
              }
              if (!v94)
              {
                if (packetDescriptions && v83 >= 1)
                {
                  if (!HIDWORD(v111[1]) || v81 < 16 * (unint64_t)HIDWORD(v111[1]))
                  {
                    uint64_t CaptionGroupFromCFData = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
                    CFTypeRef v94 = 0;
                    goto LABEL_274;
                  }
                  CMTime outputPresentationTimeStamp = sampleTiming->presentationTimeStamp;
                  uint64_t v56 = CMAudioSampleBufferCreateWithPacketDescriptions(allocator, 0, (a5 & 1 | v50) == 0, 0, 0, FormatDescription, HIDWORD(v111[1]), &outputPresentationTimeStamp, packetDescriptions, &sampleBufferOut);
                }
                else
                {
                  CMItemCount v78 = v90;
                  if (!HIDWORD(v111[1])) {
                    CMItemCount v78 = 0;
                  }
                  sampleSizeArradouble y = v82;
                  if (!HIDWORD(v111[1])) {
                    sampleSizeArradouble y = 0;
                  }
                  uint64_t v56 = CMSampleBufferCreate(allocator, 0, v55, 0, 0, FormatDescription, HIDWORD(v111[1]), v83, sampleTiming, v78, sampleSizeArray, &sampleBufferOut);
                }
LABEL_185:
                uint64_t CaptionGroupFromCFData = v56;
                CFDictionaryRef v58 = cf;
                if (v56)
                {
LABEL_274:
                  CFAllocatorRef v11 = (char *)v98;
                  goto LABEL_219;
                }
LABEL_186:
                CFTypeRef v100 = FormatDescription;
                CFAllocatorRef allocatora = (CFAllocatorRef)v11;
                CFArrayRef v105 = v19;
                CFTypeRef v96 = v20;
                FigSampleBufferSetDecryptor((uint64_t)sampleBufferOut, v58);
                if (BYTE4(v106[2]))
                {
                  CMTime outputPresentationTimeStamp = *(CMTime *)&v106[1];
                  CMSampleBufferSetOutputPresentationTimeStamp(sampleBufferOut, &outputPresentationTimeStamp);
                }
                CMSampleBufferRef v59 = sampleBufferOut;
                CFDictionaryRef v60 = (const __CFDictionary *)v110;
                CFDictionaryRef v61 = (const __CFDictionary *)v111[0];
                CFArrayRef v62 = (const __CFArray *)v107;
                if (v107)
                {
                  SampleAttachmentsArradouble y = CMSampleBufferGetSampleAttachmentsArray(sampleBufferOut, 1u);
                  CFIndex v64 = CFArrayGetCount(v62);
                  if (SampleAttachmentsArray) {
                    CFIndex v65 = CFArrayGetCount(SampleAttachmentsArray);
                  }
                  else {
                    CFIndex v65 = 0;
                  }
                  if (v64 != v65) {
                    goto LABEL_269;
                  }
                  if (v64 >= 1)
                  {
                    CFIndex v66 = 0;
                    while (1)
                    {
                      CFDictionaryRef v67 = (const __CFDictionary *)CFArrayGetValueAtIndex(v62, v66);
                      if (!v67) {
                        break;
                      }
                      CFDictionaryRef v68 = v67;
                      CFTypeID v69 = CFGetTypeID(v67);
                      if (v69 != CFDictionaryGetTypeID()) {
                        break;
                      }
                      CFTypeRef v70 = (void *)CFArrayGetValueAtIndex(SampleAttachmentsArray, v66);
                      CFDictionaryApplyFunction(v68, (CFDictionaryApplierFunction)CopyEntry, v70);
                      if (v64 == ++v66) {
                        goto LABEL_198;
                      }
                    }
LABEL_269:
                    uint64_t v80 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
                    CFTypeRef v20 = v96;
                    CFAllocatorRef v11 = (char *)v98;
                    CFTypeRef v71 = v85;
                    CFAllocatorRef v72 = allocatora;
                    if (v80)
                    {
                      uint64_t CaptionGroupFromCFData = v80;
                      CFArrayRef v19 = v105;
                      goto LABEL_219;
                    }
                    goto LABEL_202;
                  }
                }
LABEL_198:
                CFTypeRef v20 = v96;
                CFAllocatorRef v11 = (char *)v98;
                CFTypeRef v71 = v85;
                CFAllocatorRef v72 = allocatora;
                if (v61) {
                  CMSetAttachments(v59, v61, 1u);
                }
                if (v60) {
                  CMSetAttachments(v59, v60, 0);
                }
LABEL_202:
                if (v87) {
                  *CFTypeRef v87 = v97;
                }
                if (a9) {
                  *a9 = v91 - (char *)v72;
                }
                if (a10) {
                  *a10 = v92;
                }
                *a11 = sampleBufferOut;
                CMSampleBufferRef sampleBufferOut = 0;
                CFArrayRef v19 = v105;
                if (v86)
                {
                  long long v73 = *v86;
                  __CFString *v86 = v100;
                  if (v100) {
                    CFRetain(v100);
                  }
                  if (v73) {
                    CFRelease(v73);
                  }
                }
                if (v71)
                {
                  __int16 v74 = *v71;
                  *CFTypeRef v71 = cf;
                  if (cf) {
                    CFRetain(cf);
                  }
                  if (v74) {
                    CFRelease(v74);
                  }
                }
                uint64_t CaptionGroupFromCFData = 0;
                goto LABEL_219;
              }
              CFDictionaryRef v58 = cf;
              if (!sampleTiming)
              {
LABEL_285:
                uint64_t v77 = 4294954565;
                goto LABEL_282;
              }
              CMTime outputPresentationTimeStamp = sampleTiming->presentationTimeStamp;
              long long v76 = *(_OWORD *)&sampleTiming->duration.value;
              uint64_t epoch = sampleTiming->duration.epoch;
              long long v123 = v76;
              uint64_t v54 = FigSampleBufferCreateForCaptionGroup(allocator, v94, (long long *)&outputPresentationTimeStamp.value, (uint64_t)&v123, &sampleBufferOut);
              if (v54)
              {
LABEL_283:
                uint64_t CaptionGroupFromCFData = v54;
                goto LABEL_274;
              }
              FormatDescription = CMSampleBufferGetFormatDescription(sampleBufferOut);
              if (FormatDescription) {
                goto LABEL_186;
              }
            }
            uint64_t v77 = 4294954516;
LABEL_282:
            uint64_t v54 = FigSignalErrorAt(v77, 0, 0, 0, 0, 0, 0);
            goto LABEL_283;
          }
        }
        else
        {
          if (IOSurfaceGetProhibitUseCount())
          {
            int v51 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFDictionarySetValue(v51, (const void *)*MEMORY[0x1E4F24CC0], (const void *)*MEMORY[0x1E4F1CFD0]);
            uint64_t CaptionGroupFromCFData = CVPixelBufferCreateWithIOSurface(allocator, a2, v51, &pixelBufferOut);
            if (v51) {
              CFRelease(v51);
            }
          }
          else
          {
            uint64_t CaptionGroupFromCFData = CVPixelBufferCreateWithIOSurface(allocator, a2, 0, &pixelBufferOut);
          }
          if (CaptionGroupFromCFData) {
            goto LABEL_273;
          }
          if (v109) {
            CVBufferSetAttachments(pixelBufferOut, v109, kCVAttachmentMode_ShouldPropagate);
          }
          if (v99 && CMVideoFormatDescriptionMatchesImageBuffer(v99, pixelBufferOut)) {
            goto LABEL_163;
          }
          if (formatDescriptionOut)
          {
            CFRelease(formatDescriptionOut);
            CMVideoFormatDescriptionRef formatDescriptionOut = 0;
          }
          uint64_t v22 = CMVideoFormatDescriptionCreateForImageBuffer(allocator, pixelBufferOut, &formatDescriptionOut);
          if (!v22)
          {
            FormatDescription = formatDescriptionOut;
            goto LABEL_163;
          }
        }
LABEL_272:
        uint64_t CaptionGroupFromCFData = v22;
        goto LABEL_273;
      }
    }
LABEL_275:
    uint64_t NEAtomHeader = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_276;
  }
  uint64_t CaptionGroupFromCFData = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  CFTypeRef v20 = 0;
  CFTypeRef v94 = 0;
  CFArrayRef v19 = 0;
LABEL_263:
  CFAllocatorRef v12 = 0;
LABEL_219:
  if (sampleBufferOut) {
    CFRelease(sampleBufferOut);
  }
  if (v107) {
    CFRelease(v107);
  }
  if (pixelBufferOut) {
    CFRelease(pixelBufferOut);
  }
  if (v114) {
    CFRelease(v114);
  }
  if (v94) {
    CFRelease(v94);
  }
  if (v112) {
    CFRelease(v112);
  }
  if (v111[2]) {
    CFRelease(v111[2]);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v111[0]) {
    CFRelease(v111[0]);
  }
  if (v110) {
    CFRelease(v110);
  }
  if (v109) {
    CFRelease(v109);
  }
  if (theAttachments) {
    CFRelease(theAttachments);
  }
  if (formatDescriptionOut) {
    CFRelease(formatDescriptionOut);
  }
  if (v20) {
    CFRelease(v20);
  }
  free(v11);
  return CaptionGroupFromCFData;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurfaceArray(const __CFArray *a1, CMBlockBufferRef theBuffer, const opaqueCMFormatDescription **a3, CFTypeRef *a4, CMSampleBufferRef *a5)
{
  char v33 = 0;
  size_t v31 = 0;
  size_t v32 = 0;
  size_t lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  size_t totalLengthOut = 0;
  uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (DataPointer) {
    return DataPointer;
  }
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v13 = (const __CFAllocator *)lengthAtOffsetOut;
  CFAllocatorRef v12 = dataPointerOut;
  CVPixelBufferRef pixelBufferOut = 0;
  CFDictionaryRef v39 = 0;
  CMSampleBufferRef v36 = 0;
  CFTypeRef v37 = 0;
  if (!a1 || (CFIndex Count = CFArrayGetCount(a1), Count <= 0))
  {
    uint64_t v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  CFIndex v15 = Count;
  uint64_t v16 = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(v11, 0, v12, v13, 0, a3, a4, &v33, &v32, (uint64_t *)&v31, &v36);
  if (v16)
  {
LABEL_19:
    uint64_t v25 = v16;
    unint64_t v18 = 0;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_20;
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v11, v15, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v25 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    unint64_t v18 = 0;
    goto LABEL_20;
  }
  unint64_t v18 = CFArrayCreateMutable(v11, v15, MEMORY[0x1E4F1D510]);
  if (!v18)
  {
    uint64_t v27 = 4294954510;
    goto LABEL_45;
  }
  uint64_t TaggedBufferGroup = FigSampleBufferGetTaggedBufferGroup((uint64_t)v36);
  if (!TaggedBufferGroup)
  {
    uint64_t v27 = 4294954516;
LABEL_45:
    ValueAtIndedouble x = 0;
LABEL_40:
    uint64_t v23 = FigSignalErrorAt(v27, (uint64_t)ValueAtIndex, 0, 0, 0, 0, 0);
LABEL_41:
    uint64_t v25 = v23;
    goto LABEL_20;
  }
  uint64_t v20 = TaggedBufferGroup;
  for (CFIndex i = 0; i != v15; ++i)
  {
    ValueAtIndedouble x = (__IOSurface *)CFArrayGetValueAtIndex(a1, i);
    if (!ValueAtIndex)
    {
LABEL_38:
      uint64_t v27 = 4294954516;
      goto LABEL_40;
    }
    CVPixelBufferCreateWithIOSurface(v11, ValueAtIndex, 0, &pixelBufferOut);
    ValueAtIndedouble x = pixelBufferOut;
    if (!pixelBufferOut)
    {
      uint64_t v27 = 4294954510;
      goto LABEL_40;
    }
    CFArrayAppendValue(Mutable, pixelBufferOut);
    ValueAtIndedouble x = (__IOSurface *)FigTaggedBufferGroupGetTagCollectionAtIndex(v20, i);
    if (!ValueAtIndex) {
      goto LABEL_38;
    }
    CFArrayAppendValue(v18, ValueAtIndex);
    if (pixelBufferOut)
    {
      CFRelease(pixelBufferOut);
      CVPixelBufferRef pixelBufferOut = 0;
    }
  }
  uint64_t v23 = FigTaggedBufferGroupCreate(v11, v18, Mutable, &v37);
  if (v23) {
    goto LABEL_41;
  }
  CFTypeRef v24 = v37;
  CMSampleBufferGetPresentationTimeStamp(&v35, v36);
  CMSampleBufferGetDuration(&v34, v36);
  uint64_t v25 = FigSampleBufferCreateForTaggedBufferGroup(v11, v24, (long long *)&v35.value, (uint64_t)&v34, &v39);
  if (!v25)
  {
    *a5 = v39;
    CFDictionaryRef v39 = 0;
  }
LABEL_20:
  if (v36) {
    CFRelease(v36);
  }
  if (pixelBufferOut) {
    CFRelease(pixelBufferOut);
  }
  if (v37) {
    CFRelease(v37);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!v25 && v33)
  {
    v35.CMTimeValue value = 0;
    uint64_t DataPointer = CMBlockBufferCreateWithBufferReference(v11, theBuffer, v32, v31, 0, (CMBlockBufferRef *)&v35);
    if (!DataPointer)
    {
      CMSampleBufferSetDataBuffer(*a5, (CMBlockBufferRef)v35.value);
      if (v35.value) {
        CFRelease((CFTypeRef)v35.value);
      }
      return CMSampleBufferSetDataReady(*a5);
    }
    return DataPointer;
  }
  return v25;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, const opaqueCMFormatDescription **a4, CFTypeRef *a5, CMSampleBufferRef *a6)
{
  dataPointerOut = 0;
  char v19 = 0;
  size_t v17 = 0;
  uint64_t v18 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  size_t lengthAtOffsetOut = 0;
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, 0)) {
    return 4294954516;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, a3, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_8;
  }
  uint64_t v13 = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(a1, 0, dataPointerOut, (const __CFAllocator *)lengthAtOffsetOut, 0, a4, a5, &v19, &v18, (uint64_t *)&v17, a6);
  if (!v13 && v19)
  {
    uint64_t DataPointer = CMBlockBufferCreateWithBufferReference(a1, theBuffer, v18 + a3, v17, 0, &blockBufferOut);
    if (!DataPointer)
    {
      uint64_t DataPointer = CMSampleBufferSetDataBuffer(*a6, blockBufferOut);
      if (!DataPointer) {
        uint64_t DataPointer = CMSampleBufferSetDataReady(*a6);
      }
    }
LABEL_8:
    uint64_t v13 = DataPointer;
  }
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v13;
}

uint64_t FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID(opaqueCMSampleBuffer *a1, const __CFDictionary *a2, const __CFDictionary *a3, unsigned int a4, uint64_t a5, uint64_t a6, void *a7, const opaqueCMFormatDescription *a8, void *a9, int a10)
{
  if (a4) {
    int v10 = 5;
  }
  else {
    int v10 = 1;
  }
  if (a1)
  {
    uint64_t result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
    if (!result)
    {
      unsigned int v20 = v10 & 0xFFFFFFF7 | (8 * ((a4 >> 1) & 1));
      if (!a7
        || (uint64_t result = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a1, v20, a2, a3, 0, 0, 0, 0, a7, a8, 0, a10, 0, 0), !result))
      {
        uint64_t result = 0;
        if (a5)
        {
          if (a6) {
            return sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a1, v20, a2, a3, 0, 0, a5, a6, 0, a8, 0, a10, a9, 0);
          }
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptions(opaqueCMSampleBuffer *a1, unsigned int a2, uint64_t a3, uint64_t a4, void *a5, const opaqueCMFormatDescription *a6, void *a7)
{
  return FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID(a1, 0, 0, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBuffer(opaqueCMSampleBuffer *a1, uint64_t a2, uint64_t a3, void *a4, const opaqueCMFormatDescription *a5, void *a6)
{
  return FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID(a1, 0, 0, 0, a2, a3, a4, a5, a6, 0);
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(const __CFAllocator *a1, char *a2, const __CFAllocator *a3, int a4, OpaqueCMBlockBuffer *a5, const opaqueCMFormatDescription **a6, CFTypeRef *a7, CMSampleBufferRef *a8)
{
  CMSampleBufferRef sbuf = 0;
  uint64_t v11 = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(a1, 0, a2, a3, 1, a6, a7, 0, 0, 0, &sbuf);
  if (v11) {
    goto LABEL_16;
  }
  if (!a5) {
    goto LABEL_10;
  }
  uint64_t v11 = CMSampleBufferSetDataBuffer(sbuf, a5);
  if (v11)
  {
LABEL_16:
    SampleSizeArradouble y = v11;
    goto LABEL_17;
  }
  FormatDescription = CMSampleBufferGetFormatDescription(sbuf);
  SampleSizeArradouble y = (uint64_t)FormatDescription;
  if (!FormatDescription)
  {
LABEL_11:
    if (!a4)
    {
LABEL_14:
      *a8 = sbuf;
      return SampleSizeArray;
    }
    uint64_t v14 = CMSampleBufferSetDataReady(sbuf);
    goto LABEL_13;
  }
  if (CMFormatDescriptionGetMediaType(FormatDescription) != 1986618469
    && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)SampleSizeArray) != 1635088502
    && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)SampleSizeArray) != 1885954932)
  {
LABEL_10:
    SampleSizeArradouble y = 0;
    goto LABEL_11;
  }
  SampleSizeArradouble y = CMSampleBufferGetSampleSizeArray(sbuf, 0, 0, 0);
  if (SampleSizeArray != -12735) {
    goto LABEL_11;
  }
  size_t DataLength = CMBlockBufferGetDataLength(a5);
  uint64_t v14 = CMSampleBufferSetDataReadyWithNewSize((uint64_t)sbuf, 1, &DataLength);
LABEL_13:
  SampleSizeArradouble y = v14;
  if (!v14) {
    goto LABEL_14;
  }
LABEL_17:
  if (sbuf) {
    CFRelease(sbuf);
  }
  return SampleSizeArray;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBuffer(const __CFAllocator *a1, char *a2, const __CFAllocator *a3, int a4, OpaqueCMBlockBuffer *a5, const opaqueCMFormatDescription **a6, CMSampleBufferRef *a7)
{
  return FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(a1, a2, a3, a4, a5, a6, 0, a7);
}

uint64_t FigRemote_CreateSerializedAtomDataForPixelBuffer(void *a1, mach_port_t *a2, vm_address_t *a3, vm_size_t a4, vm_size_t *a5)
{
  IOSurfaceRef buffer = 0;
  uint64_t result = FigRemote_CreateSerializedAtomDataAndSurfaceForPixelBuffer(a1, (CFTypeRef *)&buffer, a3, a4, a5);
  if (!result)
  {
    uint64_t result = (uint64_t)buffer;
    if (buffer)
    {
      mach_port_t MachPort = IOSurfaceCreateMachPort(buffer);
      if (MachPort)
      {
        mach_port_t v8 = MachPort;
        if (a2)
        {
          uint64_t result = 0;
          *a2 = v8;
        }
        else
        {
          FigMachPortReleaseSendRight_(MachPort, 0, 0, 0, 0);
          return 0;
        }
      }
      else
      {
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return result;
}

uint64_t FigRemote_CreateSerializedAtomDataAndSurfaceForPixelBuffer(void *a1, CFTypeRef *a2, vm_address_t *a3, vm_size_t a4, vm_size_t *a5)
{
  vm_address_t address = 0;
  CFTypeRef cf = 0;
  vm_size_t size = 0;
  if (!a1 || (CFTypeID v10 = CFGetTypeID(a1), v10 != CVPixelBufferGetTypeID()) || !a3 || !a5)
  {
    uint64_t v11 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  uint64_t v11 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v11)
  {
LABEL_22:
    uint64_t SerializedDataForPixelBuffer = v11;
    goto LABEL_26;
  }
  *a5 = 0;
  char v12 = 1;
  uint64_t v13 = (vm_map_t *)MEMORY[0x1E4F14960];
  do
  {
    vm_size_t v14 = a4;
    if (a4)
    {
      vm_size_t size = a4;
      vm_size_t v15 = a4;
    }
    else
    {
      uint64_t v11 = sbufAtom_createSerializedDataForPixelBuffer(a1, 0, 1, 0, 0, &size);
      if (v11) {
        goto LABEL_22;
      }
      vm_size_t v15 = size;
      if (!size)
      {
        vm_size_t v16 = 0;
        goto LABEL_13;
      }
    }
    uint64_t v11 = vm_allocate(*v13, &address, v15, 1543503873);
    if (v11) {
      goto LABEL_22;
    }
    vm_size_t v16 = size;
LABEL_13:
    uint64_t SerializedDataForPixelBuffer = sbufAtom_createSerializedDataForPixelBuffer(a1, (IOSurfaceRef *)&cf, 1, address, v16, 0);
    if (!SerializedDataForPixelBuffer) {
      break;
    }
    if (address && size)
    {
      MEMORY[0x192FC66D0](*v13);
      vm_size_t size = 0;
      vm_address_t address = 0;
    }
    if (SerializedDataForPixelBuffer != -12572 || (v12 & 1) == 0) {
      break;
    }
    char v12 = 0;
    a4 = 0;
  }
  while (v14);
  if (a2)
  {
    *a2 = cf;
    CFTypeRef cf = 0;
  }
  *a3 = address;
  *a5 = size;
  vm_size_t size = 0;
LABEL_26:
  if (cf) {
    CFRelease(cf);
  }
  if (address && size) {
    MEMORY[0x192FC66D0](*MEMORY[0x1E4F14960]);
  }
  return SerializedDataForPixelBuffer;
}

uint64_t sbufAtom_createSerializedDataForPixelBuffer(void *a1, IOSurfaceRef *a2, int a3, uint64_t a4, uint64_t a5, void *a6)
{
  int v28 = 0;
  long long v27 = 0u;
  long long v26 = 0u;
  v25[0] = a4;
  v25[1] = a5;
  uint64_t appended = FigNEAtomWriterBeginAtom((uint64_t)v25, 1885500774);
  if (appended) {
    return appended;
  }
  CFDictionaryRef v11 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 1u);
  if (!v11
    || (v12 = v11, uint64_t v13 = sbufAtom_appendDictionaryAtom(v11, 1, 1767994484, v25), CFRelease(v12), !v13))
  {
    if (!a3) {
      goto LABEL_8;
    }
    IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface((CVPixelBufferRef)a1);
    if (a2) {
      *a2 = IOSurface;
    }
    if (!IOSurface)
    {
LABEL_8:
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)a1);
      uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(&PixelFormatType, 4uLL, 1885762157, v25);
      if (appended) {
        return appended;
      }
      int Width = CVPixelBufferGetWidth((CVPixelBufferRef)a1);
      uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1886873956, v25);
      if (appended) {
        return appended;
      }
      int Width = CVPixelBufferGetHeight((CVPixelBufferRef)a1);
      uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1885889897, v25);
      if (appended) {
        return appended;
      }
      int Width = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)a1);
      uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1885499506, v25);
      if (appended) {
        return appended;
      }
      int Width = CVPixelBufferGetPlaneCount((CVPixelBufferRef)a1);
      uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1886415971, v25);
      if (appended) {
        return appended;
      }
      unint64_t v15 = (*((void *)&v27 + 1) + 127) & 0xFFFFFFFFFFFFFF80;
      unint64_t v16 = v15 - 8 - *((void *)&v27 + 1);
      if (v15 - 8 != *((void *)&v27 + 1))
      {
        if (v15 - 8 > *((void *)&v27 + 1)) {
          size_t v17 = v16 >= 8 ? v15 - 8 - *((void *)&v27 + 1) : v16 + 128;
        }
        else {
          size_t v17 = *((void *)&v27 + 1) - v15 + 136;
        }
        uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(0, v17, 1718773093, v25);
        if (appended) {
          return appended;
        }
      }
      CVPixelBufferLockBaseAddress((CVPixelBufferRef)a1, 0);
      size_t DataSize = CVPixelBufferGetDataSize((CVPixelBufferRef)a1);
      BaseAddress = CVPixelBufferGetBaseAddress((CVPixelBufferRef)a1);
      uint64_t v13 = sbufAtom_appendAtomWithMemoryBlock(BaseAddress, DataSize, 1885626740, v25);
      CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)a1, 0);
      if (v13) {
        return v13;
      }
    }
    uint64_t v20 = FigNEAtomWriterEndAtom((uint64_t)v25);
    uint64_t v13 = v20;
    if (a6 && !v20)
    {
      uint64_t v21 = *((void *)&v27 + 1);
      if (*((void *)&v27 + 1) == 8) {
        uint64_t v21 = 0;
      }
      *a6 = v21;
    }
  }
  return v13;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForPixelBuffer(const __CFAllocator *a1, CFTypeRef cf, CMBlockBufferRef *a3)
{
  size_t v17 = 0;
  unint64_t v15 = 0;
  if (!cf || (CFTypeID v6 = CFGetTypeID(cf), v6 != CVPixelBufferGetTypeID()) || !a3)
  {
    uint64_t v7 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  uint64_t v7 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v7)
  {
LABEL_10:
    uint64_t v12 = v7;
    uint64_t v9 = 0;
    goto LABEL_8;
  }
  size_t v16 = 0;
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 0x40000000;
  v14[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForPixelBuffer_block_invoke;
  v14[3] = &__block_descriptor_tmp_1_3;
  _OWORD v14[4] = cf;
  uint64_t v8 = sbufAtom_createSerializedDataUsingSerializer(0x19000uLL, &v15, &v17, &v16, (uint64_t)v14);
  uint64_t v9 = v15;
  if (v8)
  {
    uint64_t v12 = v8;
  }
  else
  {
    size_t v10 = v17;
    CFAllocatorRef GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    uint64_t v12 = CMBlockBufferCreateWithMemoryBlock(a1, v9, v10, GlobalCFAllocatorFigMalloc, 0, 0, v16, 0, a3);
    if (!v12) {
      uint64_t v9 = 0;
    }
  }
LABEL_8:
  free(v9);
  return v12;
}

uint64_t FigRemote_CreatePixelBufferFromSerializedAtomData(mach_port_t a1, void *a2, size_t a3, CVPixelBufferRef *a4)
{
  CMBlockBufferRef blockBufferOut = 0;
  HIDWORD(customBlockSource.AllocateBlock) = 0;
  customBlockSource.refCon = 0;
  *(void *)&customBlockSource.version = 0;
  customBlockSource.FreeBlocuint64_t k = (void (__cdecl *)(void *, void *, size_t))_bbufBlockSourceFree;
  if (a1)
  {
    uint64_t v7 = IOSurfaceLookupFromMachPort(a1);
    if (!v7)
    {
      uint64_t v10 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      goto LABEL_11;
    }
    if (a3) {
      goto LABEL_4;
    }
LABEL_7:
    uint64_t v9 = 0;
    goto LABEL_8;
  }
  uint64_t v7 = 0;
  if (!a3) {
    goto LABEL_7;
  }
LABEL_4:
  uint64_t PixelBufferFromSerializedAtomDataAndSurface = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], &customBlockSource, 0, a3, 0, &blockBufferOut);
  if (PixelBufferFromSerializedAtomDataAndSurface) {
    goto LABEL_9;
  }
  uint64_t v9 = blockBufferOut;
LABEL_8:
  uint64_t PixelBufferFromSerializedAtomDataAndSurface = FigRemote_CreatePixelBufferFromSerializedAtomDataAndSurface(v7, v9, a4);
LABEL_9:
  uint64_t v10 = PixelBufferFromSerializedAtomDataAndSurface;
  if (v7) {
    CFRelease(v7);
  }
LABEL_11:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v10;
}

uint64_t FigRemote_CreatePixelBufferFromSerializedAtomDataAndSurface(__IOSurface *a1, OpaqueCMBlockBuffer *a2, CVPixelBufferRef *a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  char v30 = 0;
  unint64_t v28 = 0;
  uint64_t v29 = 0;
  size_t bytesPerRow = 0;
  *(void *)pixelFormatType = 0;
  unsigned int v25 = 0;
  dataPointerOut = 0;
  CFDictionaryRef theAttachments = 0;
  size_t totalLengthOut = 0;
  size_t lengthAtOffsetOut = 0;
  if (!a3)
  {
    uint64_t v19 = 4294954516;
    goto LABEL_23;
  }
  uint64_t DataPointer = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (DataPointer) {
    goto LABEL_24;
  }
  if (a2)
  {
    uint64_t DataLength = CMBlockBufferGetDataLength(a2);
    if (DataLength)
    {
      uint64_t DataPointer = CMBlockBufferGetDataPointer(a2, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
      if (DataPointer) {
        goto LABEL_24;
      }
      size_t v8 = lengthAtOffsetOut;
      uint64_t DataLength = (uint64_t)dataPointerOut;
    }
    else
    {
      size_t v8 = 0;
    }
  }
  else
  {
    size_t v8 = 0;
    uint64_t DataLength = 0;
  }
  uint64_t DataPointer = sbufAtom_createPixelBufferAttachmentsFromSerializedAtomData(DataLength, v8, &v30, &v29, (uint64_t *)&v28, pixelFormatType, (_DWORD *)&bytesPerRow + 1, &pixelFormatType[1], &bytesPerRow, &v25, (CFTypeRef *)&theAttachments);
  if (DataPointer) {
    goto LABEL_24;
  }
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!a1)
  {
    if (v30)
    {
      uint64_t v13 = &dataPointerOut[v29];
      if (a2) {
        a2 = (OpaqueCMBlockBuffer *)CFRetain(a2);
      }
      size_t v14 = v25;
      if (v25 < 2)
      {
        uint64_t v19 = CVPixelBufferCreateWithBytes(v9, pixelFormatType[0], HIDWORD(bytesPerRow), pixelFormatType[1], v13, bytesPerRow, (CVPixelBufferReleaseBytesCallback)_pixelbufferreleasecallback, a2, 0, a3);
LABEL_28:
        if (!v19)
        {
          CFDictionaryRef v11 = theAttachments;
          if (!theAttachments) {
            return 0;
          }
          goto LABEL_30;
        }
        goto LABEL_23;
      }
      *(_OWORD *)planeBaseAddress = 0u;
      long long v35 = 0u;
      size_t v15 = v28;
      size_t v17 = pixelFormatType[0];
      OSType v16 = pixelFormatType[1];
      size_t v18 = HIDWORD(bytesPerRow);
      uint64_t DataPointer = figReconstructPixelBufferPlaneInfo((uint64_t)v13, v28, v25, pixelFormatType[1], pixelFormatType[0], HIDWORD(bytesPerRow), (uint64_t)planeBaseAddress, (uint64_t)planeWidth, (uint64_t)planeHeight, (uint64_t)planeBytesPerRow);
      if (!DataPointer)
      {
        uint64_t v19 = CVPixelBufferCreateWithPlanarBytes(v9, v17, v18, v16, v13, v15, v14, planeBaseAddress, planeWidth, planeHeight, planeBytesPerRow, (CVPixelBufferReleasePlanarBytesCallback)_pixelbufferreleaseplanarcallback, a2, 0, a3);
        goto LABEL_28;
      }
LABEL_24:
      uint64_t v10 = DataPointer;
      CFDictionaryRef v11 = theAttachments;
      goto LABEL_25;
    }
    uint64_t v19 = 4294954516;
LABEL_23:
    uint64_t DataPointer = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  uint64_t v10 = CVPixelBufferCreateWithIOSurface((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0, a3);
  CFDictionaryRef v11 = theAttachments;
  if (v10) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = theAttachments == 0;
  }
  if (v12)
  {
LABEL_25:
    if (!v11) {
      return v10;
    }
    goto LABEL_31;
  }
LABEL_30:
  CVBufferSetAttachments(*a3, v11, kCVAttachmentMode_ShouldPropagate);
  uint64_t v10 = 0;
LABEL_31:
  CFRelease(v11);
  return v10;
}

uint64_t sbufAtom_createPixelBufferAttachmentsFromSerializedAtomData(uint64_t a1, unint64_t a2, unsigned char *a3, void *a4, uint64_t *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, CFTypeRef *a11)
{
  uint64_t v33 = 0;
  CFTypeRef cf = 0;
  uint64_t v32 = 0;
  int v31 = 0;
  uint64_t v30 = 0;
  if (a2)
  {
    uint64_t v29 = a3;
    uint64_t v16 = figReadNEAtomHeader(a1, 0, a2, (_DWORD *)&v30 + 1, &v30);
    if (!v16)
    {
      if (HIDWORD(v30) == 1885500774)
      {
        unint64_t v17 = v30;
        if (v30 <= a2)
        {
          a3 = v29;
          if (v30 >= 9)
          {
            unsigned int v25 = a7;
            uint64_t v18 = 0;
            unint64_t v19 = 0;
            CFAllocatorRef v28 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            unint64_t v20 = 8;
            while (1)
            {
              uint64_t v16 = figReadNEAtomHeader(a1, v20, v17, (_DWORD *)&v30 + 1, &v30);
              if (v16) {
                goto LABEL_39;
              }
              uint64_t v21 = v30;
              if (SHIDWORD(v30) <= 1885762156)
              {
                if (HIDWORD(v30) == 1767994484)
                {
                  uint64_t v16 = sbufAtom_copyDictionaryFromAtom(v28, a1 + 8 + v20, v30 - 8, (__CFDictionary **)&cf);
                  if (v16) {
                    goto LABEL_39;
                  }
                  goto LABEL_31;
                }
                if (HIDWORD(v30) != 1885499506)
                {
                  if (HIDWORD(v30) == 1885626740)
                  {
                    unint64_t v19 = a1 + 8 + v20;
                    uint64_t v18 = v30 - 8;
                  }
                  goto LABEL_31;
                }
                if (v30 != 12) {
                  goto LABEL_38;
                }
                goto LABEL_30;
              }
              if (SHIDWORD(v30) > 1886415970)
              {
                if (HIDWORD(v30) == 1886415971)
                {
                  if (v30 != 12) {
                    goto LABEL_38;
                  }
                  goto LABEL_30;
                }
                if (HIDWORD(v30) == 1886873956)
                {
                  if (v30 != 12) {
                    goto LABEL_38;
                  }
                  goto LABEL_30;
                }
              }
              else
              {
                if (HIDWORD(v30) == 1885762157)
                {
                  if (v30 != 12) {
                    goto LABEL_38;
                  }
                  goto LABEL_30;
                }
                if (HIDWORD(v30) == 1885889897)
                {
                  if (v30 != 12) {
                    goto LABEL_38;
                  }
LABEL_30:
                  __memcpy_chk();
                }
              }
LABEL_31:
              v20 += v21;
              if (v20 >= v17)
              {
                a7 = v25;
                a3 = v29;
                if (v19 && v18)
                {
                  *uint64_t v29 = 1;
                  *a4 = v19 - a1;
                  *a5 = v18;
                  goto LABEL_36;
                }
                goto LABEL_35;
              }
            }
          }
          goto LABEL_35;
        }
      }
LABEL_38:
      uint64_t v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
LABEL_39:
    uint64_t v22 = v16;
    if (cf) {
      CFRelease(cf);
    }
    return v22;
  }
LABEL_35:
  *a3 = 0;
LABEL_36:
  uint64_t v22 = 0;
  int v23 = HIDWORD(v32);
  *a6 = v33;
  *a7 = v23;
  *a8 = HIDWORD(v33);
  *a9 = v32;
  *a10 = v31;
  *a11 = cf;
  return v22;
}

uint64_t figReconstructPixelBufferPlaneInfo(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(void *)&v39[28] = *MEMORY[0x1E4F143B8];
  DescriptionWithOSType PixelFormatType = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  if (a3 > 4) {
    return 4294954516;
  }
  CFDictionaryRef v13 = (const __CFDictionary *)DescriptionWithPixelFormatType;
  uint64_t result = 4294954516;
  if (8 * a3 > a2 || !v13) {
    return result;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v13, (const void *)*MEMORY[0x1E4F24EE0]);
  if (!Value) {
    return 4294954516;
  }
  CFArrayRef v16 = Value;
  CFTypeID v17 = CFGetTypeID(Value);
  if (v17 != CFArrayGetTypeID() || CFArrayGetCount(v16) < a3) {
    return 4294954516;
  }
  __memcpy_chk();
  if (a3)
  {
    CFIndex v18 = 0;
    kedouble y = (void *)*MEMORY[0x1E4F24ED0];
    uint64_t v30 = (void *)*MEMORY[0x1E4F24EE8];
    for (CFIndex i = (unsigned int *)v39; ; i += 2)
    {
      ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, v18);
      int v37 = 1;
      int valuePtr = 1;
      uint64_t v21 = CFDictionaryGetValue(ValueAtIndex, key);
      uint64_t v22 = CFDictionaryGetValue(ValueAtIndex, v30);
      if (v21)
      {
        CFArrayRef v23 = v16;
        unint64_t v24 = a3;
        CFTypeID v25 = CFGetTypeID(v21);
        BOOL v26 = v25 == CFNumberGetTypeID();
        a3 = v24;
        CFArrayRef v16 = v23;
        if (v26) {
          CFNumberGetValue((CFNumberRef)v21, kCFNumberIntType, &valuePtr);
        }
      }
      if (v22)
      {
        CFTypeID v27 = CFGetTypeID(v22);
        if (v27 == CFNumberGetTypeID()) {
          CFNumberGetValue((CFNumberRef)v22, kCFNumberIntType, &v37);
        }
      }
      signed int v28 = bswap32(*(i - 1));
      if (v28 + 4 > a2) {
        break;
      }
      *(void *)(a7 + 8 * v18) = a1 + v28;
      *(void *)(a10 + 8 * v18) = bswap32(*i);
      *(void *)(a8 + 8 * v18) = a5 / valuePtr;
      unint64_t v29 = a6 / v37;
      *(void *)(a9 + 8 * v18) = v29;
      if (v28 + *(void *)(a10 + 8 * v18) * v29 > a2) {
        break;
      }
      if (a3 == ++v18) {
        return 0;
      }
    }
    return 4294954516;
  }
  return 0;
}

void _pixelbufferreleaseplanarcallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void _pixelbufferreleasecallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigRemote_CreatePixelBufferFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, CVPixelBufferRef *a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  dataPointerOut = 0;
  size_t v8 = CMBlockBufferGetDataLength(theBuffer);
  char v28 = 0;
  datasize_t Length = 0;
  uint64_t v27 = 0;
  size_t bytesPerRow = 0;
  *(void *)pixelFormatType = 0;
  unsigned int v23 = 0;
  size_t v21 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  if (!a4) {
    goto LABEL_12;
  }
  unint64_t v9 = v8;
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, v8))
  {
    uint64_t v18 = 4294954516;
    goto LABEL_19;
  }
  uint64_t DataPointer = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (DataPointer) {
    goto LABEL_14;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, a3, 0, 0, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_14;
  }
  uint64_t DataPointer = sbufAtom_createPixelBufferAttachmentsFromSerializedAtomData((uint64_t)dataPointerOut, v9, &v28, &v27, (uint64_t *)&dataLength, pixelFormatType, (_DWORD *)&bytesPerRow + 1, &pixelFormatType[1], &bytesPerRow, &v23, (CFTypeRef *)&v21);
  if (DataPointer) {
    goto LABEL_14;
  }
  if (!v28)
  {
LABEL_12:
    uint64_t v17 = 4294954516;
    goto LABEL_13;
  }
  unint64_t v20 = 0;
  size_t v11 = v27 + a3;
  size_t v12 = dataLength;
  uint64_t DataPointer = CMBlockBufferCreateWithBufferReference(a1, theBuffer, v11, dataLength, 0, &blockBufferOut);
  if (DataPointer) {
    goto LABEL_14;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v20);
  if (DataPointer) {
    goto LABEL_14;
  }
  size_t v13 = v23;
  if (v23 < 2)
  {
    uint64_t v17 = CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], pixelFormatType[0], HIDWORD(bytesPerRow), pixelFormatType[1], v20, bytesPerRow, (CVPixelBufferReleaseBytesCallback)_pixelbufferreleasebbufcallback, blockBufferOut, 0, a4);
  }
  else
  {
    *(_OWORD *)planeBaseAddress = 0u;
    long long v34 = 0u;
    size_t v15 = pixelFormatType[0];
    OSType v14 = pixelFormatType[1];
    size_t v16 = HIDWORD(bytesPerRow);
    uint64_t DataPointer = figReconstructPixelBufferPlaneInfo((uint64_t)v20, v12, v23, pixelFormatType[1], pixelFormatType[0], HIDWORD(bytesPerRow), (uint64_t)planeBaseAddress, (uint64_t)planeWidth, (uint64_t)planeHeight, (uint64_t)planeBytesPerRow);
    if (DataPointer)
    {
LABEL_14:
      uint64_t v18 = DataPointer;
      goto LABEL_19;
    }
    uint64_t v17 = CVPixelBufferCreateWithPlanarBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15, v16, v14, v20, v12, v13, planeBaseAddress, planeWidth, planeHeight, planeBytesPerRow, (CVPixelBufferReleasePlanarBytesCallback)_pixelbufferreleaseplanarbbufcallback, blockBufferOut, 0, a4);
  }
  if (v17)
  {
LABEL_13:
    uint64_t DataPointer = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  CMBlockBufferRef blockBufferOut = 0;
  if (!v21) {
    return 0;
  }
  CVBufferSetAttachments(*a4, (CFDictionaryRef)v21, kCVAttachmentMode_ShouldPropagate);
  uint64_t v18 = 0;
LABEL_19:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (v21) {
    CFRelease((CFTypeRef)v21);
  }
  return v18;
}

void _pixelbufferreleaseplanarbbufcallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void _pixelbufferreleasebbufcallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForKeyValuePair(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CMBlockBufferRef *a4)
{
  size_t v15 = 0;
  size_t v13 = 0;
  if (a2 && a3 && a4)
  {
    size_t v14 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    int v12[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForKeyValuePair_block_invoke;
    v12[3] = &__block_descriptor_tmp_2_4;
    v12[4] = a2;
    v12[5] = a3;
    uint64_t v6 = sbufAtom_createSerializedDataUsingSerializer(0x80uLL, &v13, &v15, &v14, (uint64_t)v12);
    uint64_t v7 = v13;
    if (v6)
    {
      uint64_t v10 = v6;
    }
    else
    {
      size_t v8 = v15;
      CFAllocatorRef GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
      uint64_t v10 = CMBlockBufferCreateWithMemoryBlock(a1, v7, v8, GlobalCFAllocatorFigMalloc, 0, 0, v14, 0, a4);
      if (!v10) {
        uint64_t v7 = 0;
      }
    }
  }
  else
  {
    uint64_t v10 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    uint64_t v7 = 0;
  }
  free(v7);
  return v10;
}

uint64_t FigRemote_CreateKeyValuePairFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, void *a3, void *a4)
{
  uint64_t v12 = 0;
  if (a3
    && a4
    && theBuffer
    && CMBlockBufferGetDataLength(theBuffer)
    && (size_t DataLength = CMBlockBufferGetDataLength(theBuffer), CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength)))
  {
    size_t lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    uint64_t result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
    if (!result)
    {
      uint64_t result = figReadNEAtomHeader((uint64_t)dataPointerOut, 0, lengthAtOffsetOut, (_DWORD *)&v12 + 1, &v12);
      if (!result)
      {
        if (HIDWORD(v12) == 1801812342 && lengthAtOffsetOut >= v12) {
          return sbufAtom_copyKeyValuePairFromAtom(a1, (uint64_t)(dataPointerOut + 8), v12 - 8, a3, a4);
        }
        else {
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t sbufAtom_copyKeyValuePairFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, void *a4, void *a5)
{
  CFTypeRef cf = 0;
  if (!a4)
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (!a5)
  {
    uint64_t v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_32;
  }
  if (!a3)
  {
    CFTypeRef v21 = 0;
    ValueAtIndedouble x = 0;
LABEL_26:
    uint64_t v16 = 0;
    *a4 = ValueAtIndex;
    *a5 = v21;
    return v16;
  }
  unsigned int v23 = a4;
  unint64_t v24 = a5;
  uint64_t v8 = 0;
  ValueAtIndedouble x = 0;
  uint64_t v10 = a2 + 8;
  *(void *)BOOL v26 = 0;
  while (1)
  {
    uint64_t NEAtomHeader = figReadNEAtomHeader(a2, v8, a3, &v26[1], v26);
    if (NEAtomHeader) {
      break;
    }
    unint64_t v12 = v8 + v26[0];
    if (v12 > a3)
    {
      uint64_t NEAtomHeader = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      break;
    }
    size_t v13 = (UInt8 *)(v10 + v8);
    uint64_t v14 = v26[0] - 8;
    if (ValueAtIndex)
    {
      uint64_t v15 = sbufAtom_copyCFTypeFromAtom(a1, v26[1], v13, v14, (CFMutableArrayRef *)&cf);
    }
    else
    {
      if (v26[1] == 1768192107)
      {
        if (v26[0] != 10)
        {
          uint64_t v16 = 4294954516;
          goto LABEL_32;
        }
        unsigned int v17 = *(unsigned __int16 *)v13;
        uint64_t v18 = &sKnownCaptureKeysArray;
        if (v17 <= 0x7FFE) {
          uint64_t v18 = &sKnownSBufKeysArray;
        }
        CFArrayRef v19 = (const __CFArray *)*v18;
        if (!*v18 || (v17 <= 0x7FFE ? (unsigned __int16 v20 = *(_WORD *)v13) : (unsigned __int16 v20 = v17 - 0x7FFF), CFArrayGetCount(v19) <= v20))
        {
          uint64_t v16 = 4294954513;
          goto LABEL_32;
        }
        ValueAtIndedouble x = CFArrayGetValueAtIndex(v19, v20);
        CFRetain(ValueAtIndex);
        goto LABEL_10;
      }
      if (v26[1] == 1937011307)
      {
        ValueAtIndedouble x = CFStringCreateWithBytes(a1, (const UInt8 *)(v10 + v8), v14, 0x8000100u, 0);
        goto LABEL_10;
      }
      uint64_t v15 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v16 = v15;
    if (v15) {
      goto LABEL_30;
    }
LABEL_10:
    uint64_t v8 = v12;
    if (v12 >= a3)
    {
      a5 = v24;
      CFTypeRef v21 = cf;
      a4 = v23;
      goto LABEL_26;
    }
  }
  uint64_t v16 = NEAtomHeader;
LABEL_30:
  if (ValueAtIndex) {
    CFRelease(ValueAtIndex);
  }
LABEL_32:
  if (cf) {
    CFRelease(cf);
  }
  return v16;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForCFType(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  size_t v16 = 0;
  uint64_t v14 = 0;
  if (!a2 || !a3)
  {
    uint64_t v6 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  uint64_t v6 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v6)
  {
LABEL_9:
    uint64_t v11 = v6;
    uint64_t v8 = 0;
    goto LABEL_7;
  }
  size_t v15 = 0;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  _DWORD v13[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForCFType_block_invoke;
  v13[3] = &__block_descriptor_tmp_3_4;
  _OWORD v13[4] = a2;
  uint64_t v7 = sbufAtom_createSerializedDataUsingSerializer(0x80uLL, &v14, &v16, &v15, (uint64_t)v13);
  uint64_t v8 = v14;
  if (v7)
  {
    uint64_t v11 = v7;
  }
  else
  {
    size_t v9 = v16;
    CFAllocatorRef GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    uint64_t v11 = CMBlockBufferCreateWithMemoryBlock(a1, v8, v9, GlobalCFAllocatorFigMalloc, 0, 0, v15, 0, a3);
    if (!v11) {
      uint64_t v8 = 0;
    }
  }
LABEL_7:
  free(v8);
  return v11;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType(const __CFAllocator *a1, uint64_t a2, int a3, CMBlockBufferRef *a4)
{
  size_t v19 = 0;
  unsigned int v17 = 0;
  if (!a2 || !a4)
  {
    uint64_t v8 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  uint64_t v8 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (v8)
  {
LABEL_9:
    uint64_t v13 = v8;
    uint64_t v10 = 0;
    goto LABEL_7;
  }
  datasize_t Length = 0;
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  v15[2] = __FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType_block_invoke;
  v15[3] = &__block_descriptor_tmp_4_4;
  v15[4] = a2;
  int v16 = a3;
  uint64_t v9 = sbufAtom_createSerializedDataUsingSerializer(0x80uLL, &v17, &v19, &dataLength, (uint64_t)v15);
  uint64_t v10 = v17;
  if (v9)
  {
    uint64_t v13 = v9;
  }
  else
  {
    size_t v11 = v19;
    CFAllocatorRef GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    uint64_t v13 = CMBlockBufferCreateWithMemoryBlock(a1, v10, v11, GlobalCFAllocatorFigMalloc, 0, 0, dataLength, 0, a4);
    if (!v13) {
      uint64_t v10 = 0;
    }
  }
LABEL_7:
  free(v10);
  return v13;
}

CFIndex sbufAtom_createSerializedDataWithFlagsForCFType(__CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  int v17 = 0;
  long long v16 = 0u;
  long long v15 = 0u;
  v14[0] = a3;
  v14[1] = a4;
  CFIndex appended = sbufAtom_appendCFTypeAtom(a1, a2, v14);
  CFIndex v8 = appended;
  if (appended != -12572 && a5 != 0 && appended == 0)
  {
    uint64_t v11 = *((void *)&v16 + 1);
    *a5 = *((void *)&v16 + 1);
    if (v11 == 8)
    {
      if (!a1 || (CFTypeID v12 = CFGetTypeID(a1), v12 != CFNullGetTypeID())) {
        *a5 = 0;
      }
    }
  }
  return v8;
}

uint64_t FigRemote_CreateCFTypeFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, CFMutableArrayRef *a4)
{
  *(void *)CFTypeID v12 = 0;
  if (a4
    && theBuffer
    && CMBlockBufferGetDataLength(theBuffer)
    && (size_t DataLength = CMBlockBufferGetDataLength(theBuffer), CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength)))
  {
    size_t lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    CMBlockBufferGetDataPointer(theBuffer, a3, &lengthAtOffsetOut, 0, &dataPointerOut);
    uint64_t result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
    if (!result)
    {
      uint64_t result = figReadNEAtomHeader((uint64_t)dataPointerOut, 0, lengthAtOffsetOut, &v12[1], v12);
      if (!result)
      {
        if (lengthAtOffsetOut < v12[0]) {
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        }
        else {
          return sbufAtom_copyCFTypeFromAtom(a1, v12[1], (UInt8 *)dataPointerOut + 8, v12[0] - 8, a4);
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t sbufAtom_copyCFTypeFromAtom(CFAllocatorRef alloc, int a2, UInt8 *bytes, unint64_t numBytes, CFMutableArrayRef *a5)
{
  plist[1] = *(CFPropertyListRef *)MEMORY[0x1E4F143B8];
  if (a2 <= 1685349749)
  {
    if (a2 > 1668051570)
    {
      if (a2 == 1668051571)
      {
        plist[0] = 0;
        if (a5)
        {
          CFDataRef v14 = CFDataCreate(alloc, bytes, numBytes);
          if (v14)
          {
            CFDataRef v15 = v14;
            BytePtr = (UInt8 *)CFDataGetBytePtr(v14);
            CFIndex Length = CFDataGetLength(v15);
            CFIndex CFPropertyListFromData = FigCreateCFPropertyListFromData(BytePtr, Length, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], plist);
            if (!CFPropertyListFromData)
            {
              CGColorSpaceRef v18 = (CGColorSpaceRef)plist[0];
              if (plist[0]) {
                CGColorSpaceRef v18 = CGColorSpaceCreateWithPropertyList(plist[0]);
              }
              *a5 = v18;
            }
            CFRelease(v15);
            if (plist[0]) {
              CFRelease(plist[0]);
            }
          }
          else
          {
            CFIndex CFPropertyListFromData = 0;
            *a5 = 0;
          }
          return CFPropertyListFromData;
        }
        return 4294954516;
      }
      if (a2 != 1684108406)
      {
        if (a2 == 1684628340)
        {
          return sbufAtom_copyDictionaryFromAtom(alloc, bytes, numBytes, a5);
        }
        goto LABEL_56;
      }
      if (!a5) {
        return 4294954516;
      }
      uint64_t v9 = CFDataCreate(alloc, bytes, numBytes);
      goto LABEL_51;
    }
    if (a2 == 1634886009)
    {
      return sbufAtom_copyArrayFromAtom(alloc, (uint64_t)bytes, numBytes, a5);
    }
    if (a2 != 1651862646) {
      goto LABEL_56;
    }
    CFIndex CFPropertyListFromData = 4294954516;
    if (numBytes != 1 || !a5) {
      return CFPropertyListFromData;
    }
    uint64_t v13 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    if (!*bytes) {
      uint64_t v13 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    }
LABEL_48:
    uint64_t v9 = (__CFArray *)CFRetain(*v13);
    goto LABEL_51;
  }
  if (a2 > 1853189227)
  {
    if (a2 != 1853189228)
    {
      if (a2 != 1937011318)
      {
        if (a2 == 1970433142)
        {
          if (a5)
          {
            CFStringRef v11 = CFStringCreateWithBytes(alloc, bytes, numBytes, 0x8000100u, 0);
            if (v11)
            {
              CFStringRef v12 = v11;
              *a5 = CFURLCreateWithString(alloc, v11, 0);
              CFRelease(v12);
              return 0;
            }
            uint64_t v19 = 4294954510;
            goto LABEL_57;
          }
          return 4294954516;
        }
LABEL_56:
        uint64_t v19 = 4294954516;
LABEL_57:
        return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
      }
      if (!a5) {
        return 4294954516;
      }
      uint64_t v9 = (__CFArray *)CFStringCreateWithBytes(alloc, bytes, numBytes, 0x8000100u, 0);
LABEL_51:
      CFIndex CFPropertyListFromData = 0;
      *a5 = v9;
      return CFPropertyListFromData;
    }
    uint64_t v13 = (CFTypeRef *)MEMORY[0x1E4F1D260];
    goto LABEL_48;
  }
  if (a2 == 1685349750)
  {
    CFIndex CFPropertyListFromData = 4294954516;
    if (numBytes != 8 || !a5) {
      return CFPropertyListFromData;
    }
    uint64_t v9 = CFDateCreate(alloc, *(CFAbsoluteTime *)bytes);
    goto LABEL_51;
  }
  if (a2 != 1717859171)
  {
    if (a2 == 1852662390)
    {
      CFIndex CFPropertyListFromData = 4294954516;
      if (!numBytes || !a5) {
        return CFPropertyListFromData;
      }
      if (numBytes >= 0xA) {
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      }
      CFNumberType v8 = (unint64_t)*bytes;
      if ((v8 - 18) <= 0xFFFFFFEE) {
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      }
      __memcpy_chk();
      uint64_t v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, plist);
      goto LABEL_51;
    }
    goto LABEL_56;
  }

  return sbufAtom_copyFormatDescriptionFromAtom(alloc, bytes, numBytes, a5);
}

uint64_t FigRemote_GetKnownNeroKeysForLightningAdapters()
{
  if (FigRemote_GetKnownNeroKeysForLightningAdapters_onceToken != -1) {
    dispatch_once(&FigRemote_GetKnownNeroKeysForLightningAdapters_onceToken, &__block_literal_global_46);
  }
  return FigRemote_GetKnownNeroKeysForLightningAdapters_neroKeys;
}

uint64_t FigRemote_GetAllKnownSerializationKeys()
{
  return sKnownSBufKeysArray;
}

CFIndex FigRemote_WriteSerializedAtomDataForCFType(__CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (!a1) {
    return 4294954516;
  }
  CFIndex result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (!result)
  {
    return sbufAtom_createSerializedDataWithFlagsForCFType(a1, a2, a3, a4, a5);
  }
  return result;
}

uint64_t FigRemote_CreateCFTypeFromSerializedAtomData(const __CFAllocator *a1, uint64_t a2, unint64_t a3, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  uint64_t v4 = 4294954516;
  if (!a2 || !a4) {
    return v4;
  }
  uint64_t NEAtomHeader = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (NEAtomHeader) {
    return NEAtomHeader;
  }
  *(void *)CFStringRef v12 = 0;
  uint64_t NEAtomHeader = figReadNEAtomHeader(a2, 0, a3, &v12[1], v12);
  if (NEAtomHeader) {
    return NEAtomHeader;
  }
  if (v12[0] <= a3)
  {
    uint64_t v4 = sbufAtom_copyCFTypeFromAtom(a1, v12[1], (UInt8 *)(a2 + 8), a3 - 8, (CFMutableArrayRef *)&cf);
    if (v4)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *a4 = cf;
    }
    return v4;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigNEAtomWriterBeginAtom(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 48))
  {
    if (*(void *)a1)
    {
      uint64_t v2 = *(void *)(a1 + 24);
      if ((unint64_t)(v2 + 8) > *(void *)(a1 + 8)) {
        return 4294954724;
      }
      *(void *)(*(void *)a1 + v2) = a2 << 32;
    }
    uint64_t v3 = 0;
    *(void *)(a1 + 32) = *(void *)(a1 + 24) + 8;
    *(void *)(a1 + 40) = 8;
    *(unsigned char *)(a1 + 48) = 1;
    return v3;
  }
  return FigSignalErrorAt(4294954725, 0, 0, 0, 0, 0, 0);
}

CFDictionaryRef sbufAtom_appendFormatDescriptionAtomGuts(const opaqueCMFormatDescription *a1, uint64_t *a2)
{
  CMVideoDimensions Dimensions = 0;
  FourCharCode MediaSubType = 0;
  size_t v15 = 0;
  size_t sizeOut = 0;
  uint64_t v14 = 0;
  uint32_t FrameQuanta = 0;
  memset(&v12, 0, sizeof(v12));
  signed int MediaType = CMFormatDescriptionGetMediaType(a1);
  CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&MediaType, 4uLL, 1835297121, a2);
  if (!result)
  {
    if (MediaType <= 1935832171)
    {
      if (MediaType <= 1835365472)
      {
        if (MediaType <= 1668310897)
        {
          if (MediaType != 1635088502) {
            goto LABEL_15;
          }
          goto LABEL_27;
        }
        if (MediaType == 1668310898)
        {
          HIDWORD(v14) = CMFormatDescriptionGetMediaSubType(a1);
          p_FourCharCode MediaSubType = (FourCharCode *)&v14 + 1;
          size_t v6 = 4;
          uint64_t v7 = 1667330151;
          goto LABEL_34;
        }
        goto LABEL_15;
      }
      if (MediaType <= 1885564004) {
        goto LABEL_15;
      }
      int v11 = 1885954932;
LABEL_26:
      if (MediaType == v11)
      {
LABEL_27:
        CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
        FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
        CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&Dimensions, 8uLL, 1986292077, a2);
        if (result) {
          return result;
        }
        p_FourCharCode MediaSubType = &MediaSubType;
        size_t v6 = 4;
        uint64_t v7 = 1668244579;
        goto LABEL_34;
      }
LABEL_15:
      HIDWORD(v14) = CMFormatDescriptionGetMediaSubType(a1);
      p_FourCharCode MediaSubType = (FourCharCode *)&v14 + 1;
      size_t v6 = 4;
      uint64_t v7 = 1836283234;
      goto LABEL_34;
    }
    if (MediaType > 1952606065)
    {
      if (MediaType <= 1953325923) {
        goto LABEL_15;
      }
      if (MediaType != 1953325924)
      {
        int v11 = 1986618469;
        goto LABEL_26;
      }
      HIDWORD(v14) = CMFormatDescriptionGetMediaSubType(a1);
      LODWORD(v14) = CMTimeCodeFormatDescriptionGetTimeCodeFlags(a1);
      uint32_t FrameQuanta = CMTimeCodeFormatDescriptionGetFrameQuanta(a1);
      CMTimeCodeFormatDescriptionGetFrameDuration(&v12, a1);
      CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock((char *)&v14 + 4, 4uLL, 1836283234, a2);
      if (!result)
      {
        CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&v14, 4uLL, 1952671335, a2);
        if (!result)
        {
          CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&FrameQuanta, 4uLL, 1903518062, a2);
          if (!result)
          {
            p_FourCharCode MediaSubType = (FourCharCode *)&v12;
            size_t v6 = 24;
            uint64_t v7 = 1717859698;
            goto LABEL_34;
          }
        }
      }
    }
    else
    {
      if (MediaType != 1936684398) {
        goto LABEL_15;
      }
      StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
      ChannelLayout = CMAudioFormatDescriptionGetChannelLayout(a1, &sizeOut);
      MagicCookie = (FourCharCode *)CMAudioFormatDescriptionGetMagicCookie(a1, &v15);
      CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(StreamBasicDescription, 0x28uLL, 1634951780, a2);
      if (!result)
      {
        if (!ChannelLayout
          || !sizeOut
          || (CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(ChannelLayout, sizeOut, 1667788396, a2), !result))
        {
          if (!MagicCookie || (size_t v6 = v15) == 0)
          {
LABEL_35:
            CFDictionaryRef result = CMFormatDescriptionGetExtensions(a1);
            if (result) {
              return (const __CFDictionary *)sbufAtom_appendDictionaryAtom(result, 1, 1702392942, a2);
            }
            return result;
          }
          p_FourCharCode MediaSubType = MagicCookie;
          uint64_t v7 = 1668639593;
LABEL_34:
          CFDictionaryRef result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(p_MediaSubType, v6, v7, a2);
          if (result) {
            return result;
          }
          goto LABEL_35;
        }
      }
    }
  }
  return result;
}

uint64_t FigNEAtomWriterEndAtom(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    unint64_t v2 = *(void *)(a1 + 40);
    if (HIDWORD(v2))
    {
      uint64_t result = FigSignalErrorAt(4294954724, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      if (*(void *)a1)
      {
        *(_DWORD *)(*(void *)a1 + *(void *)(a1 + 24)) = v2;
        unint64_t v2 = *(void *)(a1 + 40);
      }
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        *(void *)(v4 + 40) += v2;
        unint64_t v2 = *(void *)(a1 + 40);
      }
      uint64_t result = 0;
      *(void *)(a1 + 24) += v2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(unsigned char *)(a1 + 48) = 0;
  return result;
}

uint64_t sbufAtom_appendAtomWithMemoryBlock(const void *a1, size_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = a4[1];
  v9.i64[0] = *a4;
  v9.i64[1] = v6;
  uint64_t v7 = a4[5] + a4[3];
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v10 = a4;
  uint64_t v11 = v7;
  uint64_t result = FigNEAtomWriterBeginAtom((uint64_t)&v9, a3);
  if (!result)
  {
    uint64_t result = FigNEAtomWriterAppendData(&v9, a1, a2);
    if (!result) {
      return FigNEAtomWriterEndAtom((uint64_t)&v9);
    }
  }
  return result;
}

uint64_t sbufAtom_appendDictionaryAtom(const __CFDictionary *a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v23 = 0u;
  CFIndex Count = CFDictionaryGetCount(a1);
  uint64_t v9 = Count;
  if ((a2 & 2) != 0 || Count >= 1)
  {
    long long v25 = 0uLL;
    int v26 = 0;
    uint64_t v13 = a4[1];
    *(void *)&long long v23 = *a4;
    *((void *)&v23 + 1) = v13;
    uint64_t v14 = a4[5] + a4[3];
    *(void *)&long long v24 = a4;
    *((void *)&v24 + 1) = v14;
    uint64_t v15 = FigNEAtomWriterBeginAtom((uint64_t)&v23, a3);
    if (v15)
    {
      uint64_t v10 = v15;
      goto LABEL_4;
    }
    if (v9 < 1)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
LABEL_19:
      uint64_t appended = FigNEAtomWriterEndAtom((uint64_t)&v23);
      goto LABEL_20;
    }
    if ((unint64_t)v9 >> 61)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v11 = (const void **)malloc_type_malloc(8 * v9, 0xD1AAB5CuLL);
      CGColorSpaceRef v18 = (const void **)malloc_type_malloc(8 * v9, 0xD1AAB5CuLL);
      uint64_t v12 = (__CFString **)v18;
      if (v11 && v18)
      {
        CFDictionaryGetKeysAndValues(a1, v11, v18);
        uint64_t v19 = 0;
        while (1)
        {
          CFStringRef v20 = (const __CFString *)v11[v19];
          if (!v20) {
            break;
          }
          CFTypeID v21 = CFGetTypeID(v11[v19]);
          if (v21 != CFStringGetTypeID()) {
            break;
          }
          uint64_t appended = sbufAtom_appendKeyValuePairAtom(v20, a2, v12[v19], (uint64_t *)&v23);
          if (appended) {
            goto LABEL_20;
          }
          if (v9 == ++v19) {
            goto LABEL_19;
          }
        }
        uint64_t v16 = 4294954516;
        goto LABEL_10;
      }
    }
    uint64_t v16 = 4294954510;
LABEL_10:
    uint64_t appended = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_20:
    uint64_t v10 = appended;
    goto LABEL_21;
  }
  uint64_t v10 = 0;
LABEL_4:
  uint64_t v11 = 0;
  uint64_t v12 = 0;
LABEL_21:
  free(v11);
  free(v12);
  return v10;
}

uint64_t FigNEAtomWriterAppendData(int64x2_t *a1, const void *a2, size_t __n)
{
  if (a1[3].i8[0])
  {
    if (__n)
    {
      unint64_t v5 = a1->u64[1];
      if (v5)
      {
        uint64_t v6 = a1[2].i64[0];
        if (v6 + __n > v5) {
          return 4294954724;
        }
        if (a2) {
          memcpy((void *)(a1->i64[0] + v6), a2, __n);
        }
      }
      uint64_t result = 0;
      a1[2] = vaddq_s64(a1[2], vdupq_n_s64(__n));
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t sbufAtom_appendKeyValuePairAtom(const __CFString *a1, uint64_t a2, __CFString *a3, uint64_t *a4)
{
  uint64_t v7 = a4[1];
  v11[0] = *a4;
  v11[1] = v7;
  uint64_t v8 = a4[5] + a4[3];
  uint64_t v10 = 0;
  v11[4] = 0;
  void v11[5] = 0;
  int v12 = 0;
  v11[2] = (uint64_t)a4;
  v11[3] = v8;
  uint64_t result = FigNEAtomWriterBeginAtom((uint64_t)v11, 1801812342);
  if (!result)
  {
    if ((a2 & 1) != 0
      && CFDictionaryGetValueIfPresent((CFDictionaryRef)sKnownSBufKeysDictionary, a1, &v10)
      && v10 != (const void *)-1)
    {
      __int16 v13 = (__int16)v10;
      uint64_t result = sbufAtom_appendAtomWithMemoryBlock(&v13, 2uLL, 1768192107, v11);
      if (result) {
        return result;
      }
    }
    else
    {
      uint64_t result = sbufAtom_appendStringAtom(a1, 1937011307, v11);
      if (result) {
        return result;
      }
    }
    uint64_t result = sbufAtom_appendCFTypeAtom(a3, a2, v11);
    if (!result) {
      return FigNEAtomWriterEndAtom((uint64_t)v11);
    }
  }
  return result;
}

uint64_t sbufAtom_appendStringAtom(const __CFString *a1, uint64_t a2, uint64_t *a3)
{
  CFIndex maxBufLen = 0;
  if (a1)
  {
    CFIndex Length = CFStringGetLength(a1);
    v12.location = 0;
    v12.length = Length;
    CFStringGetBytes(a1, v12, 0x8000100u, 0x3Fu, 0, 0, 0, &maxBufLen);
    if (*a3)
    {
      uint64_t v7 = malloc_type_malloc(maxBufLen, 0xFF95AB25uLL);
      if (!v7)
      {
        uint64_t appended = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        goto LABEL_9;
      }
      v13.location = 0;
      v13.length = Length;
      if (CFStringGetBytes(a1, v13, 0x8000100u, 0x3Fu, 0, (UInt8 *)v7, maxBufLen, &maxBufLen) != Length)
      {
        uint64_t v8 = 4294954724;
LABEL_10:
        free(v7);
        return v8;
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
    uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(v7, maxBufLen, a2, a3);
LABEL_9:
    uint64_t v8 = appended;
    goto LABEL_10;
  }
  return 0;
}

CFIndex sbufAtom_appendCFTypeAtom(__CFString *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFArrayGetTypeID())
  {
    return sbufAtom_appendArrayAtom((const __CFArray *)a1, a2, 1634886009, a3);
  }
  else if (v6 == CFDictionaryGetTypeID())
  {
    return sbufAtom_appendDictionaryAtom(a1, a2, 1684628340, a3);
  }
  else if (v6 == CFNumberGetTypeID())
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    int v18 = 0;
    uint64_t v8 = a3[1];
    v13.i64[0] = *a3;
    v13.i64[1] = v8;
    uint64_t v9 = a3[5] + a3[3];
    uint64_t v14 = a3;
    uint64_t v15 = v9;
    CFIndex result = FigNEAtomWriterBeginAtom((uint64_t)&v13, 1852662390);
    if (!result)
    {
      CFNumberType Type = CFNumberGetType((CFNumberRef)a1);
      size_t ByteSize = CFNumberGetByteSize((CFNumberRef)a1);
      if (*a3) {
        CFNumberGetValue((CFNumberRef)a1, Type, valuePtr);
      }
      char v12 = Type;
      CFIndex result = FigNEAtomWriterAppendData(&v13, &v12, 1uLL);
      if (!result)
      {
        CFIndex result = FigNEAtomWriterAppendData(&v13, valuePtr, ByteSize);
        if (!result) {
          return FigNEAtomWriterEndAtom((uint64_t)&v13);
        }
      }
    }
  }
  else if (v6 == CFBooleanGetTypeID())
  {
    v13.i8[0] = CFBooleanGetValue((CFBooleanRef)a1);
    return sbufAtom_appendAtomWithMemoryBlock(&v13, 1uLL, 1651862646, a3);
  }
  else if (v6 == CFStringGetTypeID())
  {
    return sbufAtom_appendStringAtom(a1, 1937011318, a3);
  }
  else if (v6 == CFDataGetTypeID())
  {
    return sbufAtom_appendDataAtom((const __CFData *)a1, 1684108406, a3);
  }
  else if (v6 == CFDateGetTypeID())
  {
    return sbufAtom_appendDateAtom((uint64_t)a1, a3);
  }
  else if (v6 == CGColorSpaceGetTypeID())
  {
    return sbufAtom_appendColorSpaceAtom((CGColorSpace *)a1, a3);
  }
  else if (v6 == CFURLGetTypeID())
  {
    return sbufAtom_appendURLAtom((const __CFURL *)a1, a3);
  }
  else if (v6 == CMFormatDescriptionGetTypeID())
  {
    return sbufAtom_appendFormatDescriptionAtom((uint64_t)a1, a3);
  }
  else if (v6 == CFNullGetTypeID())
  {
    return sbufAtom_appendAtomWithMemoryBlock(0, 0, 1853189228, a3);
  }
  else
  {
    return 4294954516;
  }
  return result;
}

uint64_t sbufAtom_appendArrayAtom(const __CFArray *a1, uint64_t a2, uint64_t a3, void *a4)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v9 = Count;
  v15[4] = 0;
  void v15[5] = 0;
  int v16 = 0;
  uint64_t v10 = a4[1];
  v15[0] = *a4;
  v15[1] = v10;
  uint64_t v11 = a4[5] + a4[3];
  v15[2] = a4;
  v15[3] = v11;
  uint64_t result = FigNEAtomWriterBeginAtom((uint64_t)v15, a3);
  if (!result)
  {
    CFIndex v13 = 0;
    while (1)
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex(a1, v13);
      uint64_t result = sbufAtom_appendCFTypeAtom(ValueAtIndex, a2, v15);
      if (result) {
        break;
      }
      if (v9 == ++v13) {
        return FigNEAtomWriterEndAtom((uint64_t)v15);
      }
    }
  }
  return result;
}

uint64_t sbufAtom_appendDataAtom(const __CFData *a1, uint64_t a2, uint64_t *a3)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length >= 1)
  {
    size_t v7 = Length;
    if (*a3)
    {
      BytePtr = CFDataGetBytePtr(a1);
      if (!BytePtr)
      {
        char v12 = (UInt8 *)malloc_type_malloc(v7, 0xAF00F099uLL);
        if (!v12)
        {
          uint64_t appended = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          uint64_t v10 = 0;
          goto LABEL_11;
        }
        CFIndex v9 = v12;
        v14.location = 0;
        v14.length = v7;
        CFDataGetBytes(a1, v14, v12);
        uint64_t v10 = v9;
        goto LABEL_10;
      }
      CFIndex v9 = (void *)BytePtr;
    }
    else
    {
      CFIndex v9 = 0;
    }
    uint64_t v10 = 0;
LABEL_10:
    uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(v9, v7, a2, a3);
    goto LABEL_11;
  }
  uint64_t v10 = 0;
  uint64_t appended = 0;
LABEL_11:
  free(v10);
  return appended;
}

uint64_t sbufAtom_appendDateAtom(uint64_t a1, uint64_t *a2)
{
  double v4 = MEMORY[0x192FC3EB0]();
  return sbufAtom_appendAtomWithMemoryBlock(&v4, 8uLL, 1685349750, a2);
}

CFIndex sbufAtom_appendColorSpaceAtom(CGColorSpace *a1, uint64_t *a2)
{
  CFTypeRef cf = 0;
  CFPropertyListRef v3 = CGColorSpaceCopyPropertyList(a1);
  CFIndex CFDataFromCFPropertyList = FigCreateCFDataFromCFPropertyList(v3, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFDataRef *)&cf);
  if (CFDataFromCFPropertyList) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = cf == 0;
  }
  if (!v5) {
    CFIndex CFDataFromCFPropertyList = sbufAtom_appendDataAtom((const __CFData *)cf, 1668051571, a2);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (cf) {
    CFRelease(cf);
  }
  return CFDataFromCFPropertyList;
}

uint64_t sbufAtom_appendURLAtom(const __CFURL *a1, uint64_t *a2)
{
  CFURLRef v3 = CFURLCopyAbsoluteURL(a1);
  if (v3)
  {
    CFURLRef v4 = v3;
    CFStringRef v5 = CFURLGetString(v3);
    if (v5) {
      uint64_t appended = sbufAtom_appendStringAtom(v5, 1970433142, a2);
    }
    else {
      uint64_t appended = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v7 = appended;
    CFRelease(v4);
    return v7;
  }
  else
  {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t sbufAtom_appendFormatDescriptionAtom(uint64_t a1, void *a2)
{
  v6[4] = 0;
  v6[5] = 0;
  int v7 = 0;
  uint64_t v3 = a2[1];
  v6[0] = *a2;
  v6[1] = v3;
  uint64_t v4 = a2[5] + a2[3];
  v6[2] = a2;
  v6[3] = v4;
  uint64_t result = FigNEAtomWriterBeginAtom((uint64_t)v6, 1717859171);
  if (!result)
  {
    uint64_t result = sbufAtom_appendFormatDescriptionAtomGuts(a1, v6);
    if (!result) {
      return FigNEAtomWriterEndAtom((uint64_t)v6);
    }
  }
  return result;
}

uint64_t sbufAtom_copyDictionaryFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, __CFDictionary **a4)
{
  if (!a4)
  {
    uint64_t v22 = 4294954516;
LABEL_30:
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v25 = 0;
  CFIndex v8 = 0;
  if (a3)
  {
    unint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = figReadNEAtomHeader(a2, v9, a3, (_DWORD *)&v25 + 1, &v25);
      if (v10) {
        return v10;
      }
      if (HIDWORD(v25) != 1801812342) {
        break;
      }
      ++v8;
      v9 += v25;
      if (v9 >= a3) {
        goto LABEL_7;
      }
    }
    uint64_t v22 = 4294954516;
    goto LABEL_30;
  }
LABEL_7:
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    uint64_t v22 = 4294954510;
    goto LABEL_30;
  }
  char v12 = Mutable;
  if (v8 && a3)
  {
    unint64_t v13 = 0;
    while (1)
    {
      CFTypeRef cf = 0;
      long long v24 = 0;
      uint64_t v14 = figReadNEAtomHeader(a2, v13, a3, (_DWORD *)&v25 + 1, &v25);
      if (v14) {
        break;
      }
      uint64_t v15 = v25;
      int v16 = sbufAtom_copyKeyValuePairFromAtom(a1, a2 + 8 + v13, v25 - 8, &v24, &cf);
      uint64_t v17 = v24;
      if (v24) {
        BOOL v18 = cf == 0;
      }
      else {
        BOOL v18 = 1;
      }
      if (!v18 && v16 == 0)
      {
        CFDictionaryAddValue(v12, v24, cf);
        uint64_t v17 = v24;
      }
      if (v17) {
        CFRelease(v17);
      }
      if (cf) {
        CFRelease(cf);
      }
      v13 += v15;
      if (v13 >= a3) {
        goto LABEL_26;
      }
    }
    uint64_t v20 = v14;
    CFRelease(v12);
  }
  else
  {
LABEL_26:
    uint64_t v20 = 0;
    *a4 = v12;
  }
  return v20;
}

CMItemCount sbufAtom_appendNumSamples(opaqueCMSampleBuffer *a1, uint64_t *a2)
{
  CMItemCount result = CMSampleBufferGetNumSamples(a1);
  int v4 = result;
  if (result) {
    return sbufAtom_appendAtomWithMemoryBlock(&v4, 4uLL, 1853058416, a2);
  }
  return result;
}

uint64_t sbufAtom_appendSampleSizes(opaqueCMSampleBuffer *a1, int a2, uint64_t *a3, CMItemCount *a4)
{
  size_t DataLength = 0;
  CMItemCount sizeArrayEntriesNeededOut = 0;
  SampleSizeArradouble y = CMSampleBufferGetSampleSizeArray(a1, 0, 0, &sizeArrayEntriesNeededOut);
  if (SampleSizeArray != -12735)
  {
    if (SampleSizeArray)
    {
LABEL_31:
      uint64_t appended = FigSignalErrorAt(SampleSizeArray, 0, 0, 0, 0, 0, 0);
      goto LABEL_26;
    }
    char v16 = 1;
LABEL_14:
    unint64_t v17 = sizeArrayEntriesNeededOut;
    if (a4) {
      *a4 = sizeArrayEntriesNeededOut;
    }
    if (!v17 || !*a3)
    {
      uint64_t v11 = 0;
      unint64_t v13 = 0;
      goto LABEL_24;
    }
    if (v17 == 1)
    {
      if (v16)
      {
        BOOL v18 = &DataLength;
        uint64_t v19 = CMSampleBufferGetSampleSizeArray(a1, 1, &DataLength, &sizeArrayEntriesNeededOut);
        uint64_t v11 = 0;
        if (v19)
        {
          uint64_t appended = v19;
          goto LABEL_22;
        }
      }
      else
      {
        uint64_t v11 = 0;
        BOOL v18 = &DataLength;
      }
LABEL_36:
      if (sizeArrayEntriesNeededOut)
      {
        if ((unint64_t)sizeArrayEntriesNeededOut >> 62)
        {
LABEL_38:
          uint64_t v22 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          goto LABEL_39;
        }
        size_t v23 = 4 * sizeArrayEntriesNeededOut;
        malloc_type_id_t v24 = 219851612;
      }
      else
      {
        size_t v23 = 0;
        malloc_type_id_t v24 = 754892075;
      }
      uint64_t v25 = malloc_type_malloc(v23, v24);
      unint64_t v13 = v25;
      if (!v25) {
        goto LABEL_38;
      }
      unint64_t v17 = sizeArrayEntriesNeededOut;
      if (sizeArrayEntriesNeededOut >= 1)
      {
        uint64_t v26 = 0;
        do
        {
          *((_DWORD *)v25 + v26) = v18[v26];
          ++v26;
        }
        while (v17 != v26);
      }
LABEL_24:
      uint64_t appended = sbufAtom_appendAtomWithMemoryBlock(v13, 4 * v17, 1936943482, a3);
      goto LABEL_28;
    }
    if (!(v17 >> 61))
    {
      CFTypeID v21 = (size_t *)malloc_type_malloc(8 * v17, 0xD1AAB5CuLL);
      if (v21)
      {
        uint64_t v11 = v21;
        uint64_t v22 = CMSampleBufferGetSampleSizeArray(a1, sizeArrayEntriesNeededOut, v21, &sizeArrayEntriesNeededOut);
        if (v22)
        {
LABEL_39:
          uint64_t appended = v22;
          goto LABEL_27;
        }
        BOOL v18 = v11;
        goto LABEL_36;
      }
    }
    SampleSizeArradouble y = 4294954510;
    goto LABEL_31;
  }
  if (!a2)
  {
LABEL_25:
    uint64_t appended = 0;
LABEL_26:
    uint64_t v11 = 0;
LABEL_27:
    unint64_t v13 = 0;
    goto LABEL_28;
  }
  CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(a1);
  CMItemCount NumSamples = CMSampleBufferGetNumSamples(a1);
  uint64_t v11 = 0;
  uint64_t appended = 0;
  if (!DataBuffer)
  {
LABEL_22:
    unint64_t v13 = 0;
    goto LABEL_28;
  }
  unint64_t v13 = 0;
  if (NumSamples == 1)
  {
    FormatDescription = CMSampleBufferGetFormatDescription(a1);
    if (FormatDescription)
    {
      CMMediaType MediaType = CMFormatDescriptionGetMediaType(FormatDescription);
      if (MediaType == 1635088502 || MediaType == 1986618469 || MediaType == 1885954932)
      {
        size_t DataLength = CMBlockBufferGetDataLength(DataBuffer);
        CMItemCount sizeArrayEntriesNeededOut = 1;
        if (sbufAtom_appendSampleSizes_sSBufAtomAppendSampleSizes_MissingSampleSizeForVideo_InitOnce != -1) {
          dispatch_once_f(&sbufAtom_appendSampleSizes_sSBufAtomAppendSampleSizes_MissingSampleSizeForVideo_InitOnce, 0, (dispatch_function_t)sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce);
        }
        char v16 = 0;
        goto LABEL_14;
      }
    }
    goto LABEL_25;
  }
LABEL_28:
  free(v11);
  free(v13);
  return appended;
}

uint64_t sbufAtom_appendPacketDescriptions(opaqueCMSampleBuffer *a1, uint64_t *a2)
{
  size_t v6 = 0;
  packetDescriptionsPointerOut = 0;
  uint64_t result = CMSampleBufferGetAudioStreamPacketDescriptionsPtr(a1, (const AudioStreamPacketDescription **)&packetDescriptionsPointerOut, &v6);
  if (!result && v6)
  {
    CMItemCount NumSamples = CMSampleBufferGetNumSamples(a1);
    if (NumSamples == v6 >> 4) {
      return sbufAtom_appendAtomWithMemoryBlock(packetDescriptionsPointerOut, v6, 1885631331, a2);
    }
    else {
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t sbufAtom_appendTagCollection(uint64_t a1, uint64_t a2, void *a3)
{
  CFIndex Count = FigTaggedBufferGroupGetCount();
  if (Count <= 0)
  {
    uint64_t v18 = 4294954516;
LABEL_12:
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  CFIndex v7 = Count;
  uint64_t v8 = *MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v18 = 4294954510;
    goto LABEL_12;
  }
  uint64_t v10 = Mutable;
  uint64_t v11 = 0;
  while (1)
  {
    TagCollectionAtIndedouble x = FigTaggedBufferGroupGetTagCollectionAtIndex(a1, v11);
    if (!TagCollectionAtIndex) {
      break;
    }
    unint64_t v13 = (const void *)FigTagCollectionCopyAsData(TagCollectionAtIndex, v8);
    if (!v13) {
      break;
    }
    uint64_t v14 = v13;
    CFArrayAppendValue(v10, v13);
    CFRelease(v14);
    if (v7 == ++v11)
    {
      uint64_t appended = sbufAtom_appendArrayAtom(v10, a2, 1952673644, a3);
      goto LABEL_8;
    }
  }
  uint64_t appended = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_8:
  uint64_t v16 = appended;
  CFRelease(v10);
  return v16;
}

void sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)) {
    sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce_cold_1();
  }
  FigLogBacktrace();
}

uint64_t sbufAtom_copyArrayFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, CFMutableArrayRef *a4)
{
  if (!a4) {
    return 4294954516;
  }
  if (a3)
  {
    CFIndex v8 = 0;
    unint64_t v9 = 0;
    *(void *)unint64_t v17 = 0;
    do
    {
      uint64_t NEAtomHeader = figReadNEAtomHeader(a2, v9, a3, &v17[1], v17);
      if (NEAtomHeader) {
        return NEAtomHeader;
      }
      ++v8;
      v9 += v17[0];
    }
    while (v9 < a3);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, v8, MEMORY[0x1E4F1D510]);
    uint64_t v12 = 0;
    while (1)
    {
      uint64_t v13 = figReadNEAtomHeader(a2, v12, a3, &v17[1], v17);
      if (v13) {
        break;
      }
      unint64_t v14 = v12 + v17[0];
      if (v14 > a3)
      {
        uint64_t v13 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        break;
      }
      uint64_t v13 = sbufAtom_copyCFTypeFromAtom(a1, v17[1], (UInt8 *)(a2 + 8 + v12), v17[0] - 8);
      if (v13) {
        break;
      }
      uint64_t v12 = v14;
      if (v14 >= a3) {
        goto LABEL_13;
      }
    }
    uint64_t v15 = v13;
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    CFMutableArrayRef Mutable = 0;
LABEL_13:
    uint64_t v15 = 0;
    *a4 = Mutable;
  }
  return v15;
}

void *__getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!MediaToolboxLibraryCore_frameworkLibrary_1)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = __MediaToolboxLibraryCore_block_invoke_1;
    v5[4] = &__block_descriptor_tmp_197;
    v5[5] = v5;
    long long v6 = xmmword_1E567DBD8;
    uint64_t v7 = 0;
    MediaToolboxLibraryCore_frameworkLibrary_1 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    unint64_t v2 = (void *)MediaToolboxLibraryCore_frameworkLibrary_1;
    if (MediaToolboxLibraryCore_frameworkLibrary_1)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  unint64_t v2 = (void *)MediaToolboxLibraryCore_frameworkLibrary_1;
LABEL_5:
  uint64_t result = dlsym(v2, "FigCPECryptorCreateCryptorFromSerializedRecipe");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                + 24);
  return result;
}

uint64_t __MediaToolboxLibraryCore_block_invoke_1()
{
  uint64_t result = _sl_dlopen();
  MediaToolboxLibraryCore_frameworkLibrary_1 = result;
  return result;
}

void CopyEntry(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t FigVirtualCaptureCardGetClassID()
{
  return sFigVirtualCaptureCardClassID;
}

uint64_t RegisterFigVirtualCaptureCardBaseType()
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigVirtualCaptureCardClassDesc, ClassID, 1, &sFigVirtualCaptureCardClassID);
}

uint64_t FigVirtualCaptureCardGetTypeID()
{
  FigThreadRunOnce(&FigVirtualCaptureCardGetClassID_sRegisterFigVirtualCaptureCardBaseTypeOnce, (void (*)(void))RegisterFigVirtualCaptureCardBaseType);
  pid_t v0 = (void *)sFigVirtualCaptureCardClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef FigVirtualCaptureCardCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigVirtualCaptureCard %p]", a1);
}

uint64_t FigTaggedBufferGroupFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigTaggedBufferGroupFormatDescriptionRegisterOnce, (void (*)(void))FigTaggedBufferGroupFormatDescriptionRegisterOnce);
}

uint64_t FigTaggedBufferGroupFormatDescriptionRegisterOnce()
{
  int v1 = 0;
  CFStringRef v5 = figTaggedBufferGroupFormatDescriptionFinalize;
  int v4 = figTaggedBufferGroupFormatDescriptionCopyDebugDesc;
  uint64_t v2 = 16;
  uint64_t v3 = figTaggedBufferGroupFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x74626772u, (long long *)&v1);
}

uint64_t FigTaggedBufferGroupFormatDescriptionCreate(const __CFAllocator *a1, int a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a3)
  {
    FigThreadRunOnce(&sFigTaggedBufferGroupFormatDescriptionRegisterOnce, (void (*)(void))FigTaggedBufferGroupFormatDescriptionRegisterOnce);
    uint64_t v6 = FigDerivedFormatDescriptionCreate(a1, (void *)0x74626772, a2, 0, (uint64_t *)&cf);
    if (v6)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf) = a2;
      *a3 = cf;
    }
    return v6;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(CFAllocatorRef allocator, CMTaggedBufferGroupRef taggedBufferGroup, CMTaggedBufferGroupFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  if (formatDescriptionOut)
  {
    FigThreadRunOnce(&sFigTaggedBufferGroupFormatDescriptionRegisterOnce, (void (*)(void))FigTaggedBufferGroupFormatDescriptionRegisterOnce);
    OSStatus v6 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x74626772, 1952606066, 0, (uint64_t *)&cf);
    if (!v6)
    {
      uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
      *(_DWORD *)uint64_t DerivedStorage = 1952606066;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
      if (Mutable)
      {
        unint64_t v9 = Mutable;
        if (CMTaggedBufferGroupGetCount(taggedBufferGroup) >= 1)
        {
          CMItemCount v10 = 0;
          do
          {
            TagCollectionAtIndedouble x = CMTaggedBufferGroupGetTagCollectionAtIndex(taggedBufferGroup, v10);
            CFArrayAppendValue(v9, TagCollectionAtIndex);
            ++v10;
          }
          while (v10 < CMTaggedBufferGroupGetCount(taggedBufferGroup));
        }
        *(void *)(DerivedStorage + 8) = CFRetain(v9);
        *CMVideoFormatDescriptionRef formatDescriptionOut = (CMTaggedBufferGroupFormatDescriptionRef)cf;
        CFTypeRef cf = 0;
        CFRelease(v9);
        OSStatus v12 = 0;
        goto LABEL_8;
      }
      OSStatus v6 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    OSStatus v12 = v6;
LABEL_8:
    if (cf) {
      CFRelease(cf);
    }
    return v12;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

Boolean CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(CMTaggedBufferGroupFormatDescriptionRef desc, CMTaggedBufferGroupRef taggedBufferGroup)
{
  CMTaggedBufferGroupFormatDescriptionRef v2 = desc;
  if (!desc)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return v2;
  }
  if (!taggedBufferGroup)
  {
    uint64_t v9 = 4294954586;
LABEL_11:
    FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    LOBYTE(v2) = 0;
    return v2;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v9 = 4294954510;
    goto LABEL_11;
  }
  CFStringRef v5 = Mutable;
  if (CMTaggedBufferGroupGetCount(taggedBufferGroup) >= 1)
  {
    CMItemCount v6 = 0;
    do
    {
      TagCollectionAtIndedouble x = CMTaggedBufferGroupGetTagCollectionAtIndex(taggedBufferGroup, v6);
      CFArrayAppendValue(v5, TagCollectionAtIndex);
      ++v6;
    }
    while (v6 < CMTaggedBufferGroupGetCount(taggedBufferGroup));
  }
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)v2);
  LOBYTE(v2) = *(_DWORD *)DerivedStorage == 1952606066
            && compareTagCollections(v5, *(const __CFArray **)(DerivedStorage + 8)) != 0;
  CFRelease(v5);
  return v2;
}

uint64_t compareTagCollections(CFArrayRef theArray, const __CFArray *a2)
{
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (a2)
    {
LABEL_3:
      CFIndex v5 = CFArrayGetCount(a2);
      goto LABEL_6;
    }
  }
  else
  {
    CFIndex Count = 0;
    if (a2) {
      goto LABEL_3;
    }
  }
  CFIndex v5 = 0;
LABEL_6:
  if (Count != v5) {
    return 0;
  }
  for (CFIndex i = 0; ; ++i)
  {
    CFIndex v7 = theArray ? CFArrayGetCount(theArray) : 0;
    if (i >= v7) {
      break;
    }
    ValueAtIndedouble x = FigCFArrayGetValueAtIndex(theArray, i);
    CFIndex v9 = 0;
    if (a2)
    {
LABEL_13:
      CFIndex v10 = CFArrayGetCount(a2);
      goto LABEL_15;
    }
    while (1)
    {
      CFIndex v10 = 0;
LABEL_15:
      if (v9 >= v10) {
        break;
      }
      uint64_t v11 = FigCFArrayGetValueAtIndex(a2, v9);
      if (CFEqual(ValueAtIndex, v11)) {
        break;
      }
      ++v9;
      if (a2) {
        goto LABEL_13;
      }
    }
    if (a2) {
      CFIndex v12 = CFArrayGetCount(a2);
    }
    else {
      CFIndex v12 = 0;
    }
    if (v12 == v9) {
      return 0;
    }
  }
  return 1;
}

void figTaggedBufferGroupFormatDescriptionFinalize(uint64_t a1)
{
  int v1 = *(const void **)(FigDerivedFormatDescriptionGetDerivedStorage(a1) + 8);
  if (v1)
  {
    CFRelease(v1);
  }
}

__CFString *figTaggedBufferGroupFormatDescriptionCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, @"\t\tsubType: '%c%c%c%c'", HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  return Mutable;
}

BOOL figTaggedBufferGroupFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage(a1);
  uint64_t v4 = FigDerivedFormatDescriptionGetDerivedStorage(a2);
  return *(_DWORD *)DerivedStorage == *(_DWORD *)v4
      && compareTagCollections(*(CFArrayRef *)(DerivedStorage + 8), *(const __CFArray **)(v4 + 8));
}

uint64_t FigEndpointRemoteControlSessionStartServer()
{
  v3[0] = 1;
  v3[1] = HandleEndpointRemoteControlSessionRemoteMessage;
  long long v4 = 0u;
  long long v5 = 0u;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32(Mutable, @"xpcServerOption_SelfTerminationTimeout", 30);
  uint64_t v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointremotecontrolsession.xpc", v3, (uint64_t)Mutable, &gEndpointRemoteControlSessionServer);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v1;
}

uint64_t HandleEndpointRemoteControlSessionRemoteMessage(_xpc_connection_s *a1, void *a2)
{
  int v36 = 0;
  uint64_t v35 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v36);
  if (OpCode) {
    return OpCode;
  }
  uIOSurfaceID int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  CFTypeRef cf = 0;
  uint64_t v6 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v35);
  if (!v6)
  {
    if (cf)
    {
      CFTypeID v7 = CFGetTypeID(cf);
      if (v7 == FigEndpointRemoteControlSessionGetTypeID())
      {
        CFTypeRef v8 = cf;
        goto LABEL_6;
      }
    }
    uint64_t v6 = FigSignalErrorAt(4294949866, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v9 = v6;
  if (cf) {
    CFRelease(cf);
  }
  if (!v9)
  {
    CFTypeRef v8 = 0;
LABEL_6:
    uint64_t v9 = 4294949866;
    if (v36 <= 1936614508)
    {
      switch(v36)
      {
        case 1667593832:
          uint64_t v15 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 16);
          if (v15) {
            uint64_t v16 = v15;
          }
          else {
            uint64_t v16 = 0;
          }
          char v28 = *(uint64_t (**)(CFTypeRef, void (*)(uint64_t, const void *, const void *, uint64_t), uint64_t))(v16 + 16);
          if (v28)
          {
            CFTypeRef v30 = v8;
            unint64_t v29 = 0;
            uint64_t v31 = 0;
            goto LABEL_36;
          }
          break;
        case 1685024621:
          uint64_t v17 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_40:
          uint64_t v9 = v17;
          goto LABEL_50;
        case 1936029288:
          uint64_t v10 = v35;
          *(void *)(v10 + 24) = xpc_dictionary_get_uint64(a2, ".objectID");
          FigXPCRelease(*(xpc_object_t *)(v10 + 32));
          *(void *)(v10 + 32) = FigXPCRetain(a1);
          uint64_t v11 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 16);
          if (v11) {
            uint64_t v12 = v11;
          }
          else {
            uint64_t v12 = 0;
          }
          char v28 = *(uint64_t (**)(CFTypeRef, void (*)(uint64_t, const void *, const void *, uint64_t), uint64_t))(v12 + 16);
          if (v28)
          {
            unint64_t v29 = HandleEventCallback_0;
            CFTypeRef v30 = v8;
            uint64_t v31 = v10;
LABEL_36:
            uint64_t v17 = v28(v30, v29, v31);
            goto LABEL_40;
          }
          break;
        default:
          goto LABEL_50;
      }
LABEL_41:
      uint64_t v9 = 4294954514;
LABEL_50:
      if (v8) {
        CFRelease(v8);
      }
      return v9;
    }
    if (v36 != 1936614509)
    {
      if (v36 == 1937011316)
      {
        uint64_t v26 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 16);
        if (v26) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = 0;
        }
        uint64_t v32 = *(uint64_t (**)(CFTypeRef))(v27 + 32);
        if (!v32) {
          goto LABEL_41;
        }
      }
      else
      {
        if (v36 != 1953653870) {
          goto LABEL_50;
        }
        uint64_t v13 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 16);
        if (v13) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v32 = *(uint64_t (**)(CFTypeRef))(v14 + 24);
        if (!v32) {
          goto LABEL_41;
        }
      }
      uint64_t v17 = v32(v8);
      goto LABEL_40;
    }
    CFTypeRef cf = 0;
    uint64_t v18 = FigXPCMessageCopyCFData(a2, "Params", &cf);
    if (v18) {
      goto LABEL_46;
    }
    uint64_t v19 = xpc_dictionary_get_uint64(a2, "CompletionID");
    if (!v19)
    {
      uint64_t v9 = 4294949865;
      goto LABEL_48;
    }
    uint64_t v20 = v19;
    CFTypeID v21 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
    if (v21)
    {
      uint64_t v22 = v21;
      void *v21 = v20;
      v21[1] = xpc_dictionary_get_uint64(a2, ".objectID");
      v22[2] = FigXPCRetain(a1);
      CFTypeRef v23 = cf;
      uint64_t v24 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 16);
      if (v24) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = 0;
      }
      uint64_t v33 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, const void *, uint64_t), void *))(v25 + 8);
      if (v33)
      {
        uint64_t v18 = v33(v8, v23, SendMessageCompletionCallback, v22);
LABEL_46:
        uint64_t v9 = v18;
        goto LABEL_48;
      }
      uint64_t v9 = 4294954514;
    }
    else
    {
      uint64_t v9 = 4294949865;
      FigSignalErrorAt(4294949865, 0, 0, 0, 0, 0, 0);
    }
LABEL_48:
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_50;
  }
  return v9;
}

uint64_t FigXPCEndpointRemoteControlSessionServerAssociateNeighborFigEndpointRemoteControlSession(_xpc_connection_s *a1, const void *a2, void *a3)
{
  uint64_t v10 = 0;
  uint64_t SessionEventHandlerState = CreateSessionEventHandlerState(a2, (uint64_t *)&v10);
  CFTypeID v7 = v10;
  if (SessionEventHandlerState)
  {
    uint64_t v8 = SessionEventHandlerState;
    goto LABEL_3;
  }
  uint64_t v8 = FigXPCServerAssociateObjectWithNeighborProcess(gEndpointRemoteControlSessionServer, a1, a2, (uint64_t)v10, (uint64_t)DisposeSessionEventHandlerState_0, 0, a3);
  if (v8) {
LABEL_3:
  }
    DisposeSessionEventHandlerState_0(v7);
  return v8;
}

uint64_t CreateSessionEventHandlerState(const void *a1, uint64_t *a2)
{
  if (sRegisterFigEndpointRemoteControlSessionEventHandlerStateTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigEndpointRemoteControlSessionEventHandlerStateTypeOnce, 0, (dispatch_function_t)RegisterFigEndpointRemoteControlSessionEventHandlerStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = a1;
    if (a1) {
      CFRetain(a1);
    }
    uint64_t result = 0;
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  *a2 = v5;
  return result;
}

void DisposeSessionEventHandlerState_0(void *cf)
{
  if (cf)
  {
    uint64_t v2 = cf[2];
    if (v2)
    {
      uint64_t v3 = *(void *)(CMBaseObjectGetVTable(cf[2]) + 16);
      uint64_t v4 = v3 ? v3 : 0;
      uint64_t v5 = *(void (**)(uint64_t, void, void))(v4 + 16);
      if (v5) {
        v5(v2, 0, 0);
      }
    }
    CFRelease(cf);
  }
}

uint64_t FigXPCEndpointRemoteControlSessionServerAssociateCopiedNeighborRemoteControlSession(_xpc_connection_s *a1, const void *a2, void *a3)
{
  uint64_t v10 = 0;
  uint64_t SessionEventHandlerState = CreateSessionEventHandlerState(a2, (uint64_t *)&v10);
  CFTypeID v7 = v10;
  if (SessionEventHandlerState)
  {
    uint64_t v8 = SessionEventHandlerState;
    goto LABEL_3;
  }
  uint64_t v8 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointRemoteControlSessionServer, a1, a2, (uint64_t)v10, (uint64_t)DisposeSessionEventHandlerState_0, 0, a3);
  if (v8) {
LABEL_3:
  }
    DisposeSessionEventHandlerState_0(v7);
  return v8;
}

void SendMessageCompletionCallback(int a1, const void *a2, uint64_t a3)
{
  xpc_object_t xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a3);
    xpc_dictionary_set_int64(xdict, "ResponseStatus", a1);
    FigXPCMessageSetCFObject(xdict, "ResponseParams", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void HandleEventCallback_0(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
  xpc_object_t message = 0;
  if (a4)
  {
    int v7 = FigXPCCreateBasicMessage(0x65686362u, *(void *)(a4 + 24), &message);
    xpc_object_t v8 = message;
    if (!v7)
    {
      FigXPCMessageSetCFString(message, "EventType", a2);
      FigXPCMessageSetCFData(message, "EventPayload", a3);
      xpc_connection_send_message(*(xpc_connection_t *)(a4 + 32), message);
      xpc_object_t v8 = message;
    }
  }
  else
  {
    xpc_object_t v8 = 0;
  }
  FigXPCRelease(v8);
}

uint64_t RegisterFigEndpointRemoteControlSessionEventHandlerStateType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigEndpointRemoteControlSessionEventHandlerStateIOSurfaceID ID = result;
  return result;
}

void *figEndpointRemoteControlSessionEventHandlerStateInit(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void figEndpointRemoteControlSessionEventHandlerStateFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  FigXPCRelease(*(xpc_object_t *)(a1 + 32));
  *(void *)(a1 + 32) = 0;
}

__CFString *figEndpointRemoteControlSessionEventHandlerStateCopyFormattingDesc()
{
  return @"[FigEndpointRemoteControlSessionEventHandlerState]";
}

__CFString *figEndpointRemoteControlSessionEventHandlerStateCopyDebugDesc(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigEndpointRemoteControlSessionEventHandlerState %p> for objectID %16llx", a1, a1[3]);
  return Mutable;
}

void *FigCopyCommonMemoryPool()
{
  if (sFigCommonMemoryPool != -1) {
    dispatch_once_f(&sFigCommonMemoryPool, 0, (dispatch_function_t)fig_initializeCommonMemoryPoolManagement);
  }
  FigSimpleMutexLock((pthread_mutex_t *)qword_1EB28BC60);
  pid_t v0 = FigCFWeakReferenceLoadAndRetain(&qword_1EB28BC68);
  if (!v0)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(Mutable, @"FigMemoryPool_LoggingName", @"CommonMemoryPool");
    pid_t v0 = CMMemoryPoolCreate(Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    FigCFWeakReferenceStore(&qword_1EB28BC68, v0);
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EB28BC60);
  return v0;
}

pthread_mutex_t *fig_initializeCommonMemoryPoolManagement()
{
  uint64_t result = FigSimpleMutexCreate();
  qword_1EB28BC60 = (uint64_t)result;
  return result;
}

void FigCommonMemoryPoolReleaseAndClear(const void **a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0;
    }
  }
}

uint64_t FigCustomURLHandlerServerEnsure()
{
  if (FigCustomURLHandlerServerEnsure_sFigCustomURLHandlerServerOnce != -1) {
    dispatch_once(&FigCustomURLHandlerServerEnsure_sFigCustomURLHandlerServerOnce, &__block_literal_global_47);
  }
  return FigCustomURLHandlerServerEnsure_sFigCustomURLHandlerStartError;
}

dispatch_queue_t __FigCustomURLHandlerServerEnsure_block_invoke()
{
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigCustomURLHandler2RemoteNote[1], @"customurlhandler_xpc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigCustomURLHandler2RemoteNote);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EB28B650, @"customurlhandler_xpc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1EB28B648);
  FigCustomURLHandlerServerEnsure_sFigCustomURLHandlerStartError = FigXPCServerStartWithNewXPCEndpoint((uint64_t)"com.apple.coremedia.customurlhandler.xpc", figCustomURLHandlerServerStart_callbacks, 0, &gFigCustomURLHandlerServer);
  dispatch_queue_t result = dispatch_queue_create("com.apple.coremedia.customurlhandlerserver.data", 0);
  gFigCustomURLHandlerServerCallbackQueue = (uint64_t)result;
  return result;
}

uint64_t FigCustomURLHandlerServerCopyXPCEndpoint(void *a1)
{
  return FigXPCServerCopyXPCEndpoint(gFigCustomURLHandlerServer, a1);
}

uint64_t FigCustomURLHandlerConfirmNeighborProcessByPID(int a1)
{
  return FigXPCServerConfirmNeighborProcessByPID(gFigCustomURLHandlerServer, a1);
}

uint64_t FigCustomURLHandlerServerAssociateObjectByPID(int a1, const void *a2, void *a3)
{
  return FigCustomURLHandlerServerAssociateObjectAndContentKeySessionByPID(a1, a2, 0, a3);
}

uint64_t FigCustomURLHandlerServerAssociateObjectAndContentKeySessionByPID(int a1, const void *a2, const void *a3, void *a4)
{
  uint64_t v13 = 0;
  xpc_object_t v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  v8[1] = FigOSTransactionCreate("FigCustomURLHandler", 0, 0, 0);
  if (!a3)
  {
LABEL_5:
    uint64_t v11 = FigXPCServerAssociateObjectWithNeighborProcessByPID(gFigCustomURLHandlerServer, a1, a2, (uint64_t)v8, (uint64_t)figCustomURLHandlerServer_disposeCompanion, 0, &v13);
    if (!v11) {
      *a4 = v13;
    }
    if (a3) {
      CFRelease(a3);
    }
    return v11;
  }
  CFTypeRef v9 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)a3);
  if (v9)
  {
    a3 = v9;
    uint64_t v10 = (const void *)v8[2];
    v8[2] = v9;
    CFRetain(v9);
    if (v10) {
      CFRelease(v10);
    }
    goto LABEL_5;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

void figCustomURLHandlerServer_disposeCompanion(const void **a1)
{
  CFAllocatorRef v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
    *a1 = 0;
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    os_release(v3);
    a1[1] = 0;
  }
  uint64_t v4 = a1[2];
  if (v4) {
    CFRelease(v4);
  }

  free(a1);
}

uint64_t figCustomURLHandlerServer_handleRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  v48[16] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  int v42 = 0;
  uint64_t v40 = 0;
  CFTypeRef cf = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v42);
  if (OpCode) {
    goto LABEL_64;
  }
  uIOSurfaceID int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  uint64_t OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v40);
  if (OpCode) {
    goto LABEL_64;
  }
  if (!cf || (CFTypeID v8 = CFGetTypeID(cf), v8 != FigCustomURLHandlerGetTypeID()))
  {
    uint64_t OpCode = FigSignalErrorAt(4294949926, 0, 0, 0, 0, 0, 0);
LABEL_64:
    uint64_t v24 = OpCode;
    goto LABEL_60;
  }
  if (!*v40)
  {
    uint64_t OpCode = FigCustomURLHandlerServerRequestingClientCreate(a1, uint64, v40);
    if (OpCode) {
      goto LABEL_64;
    }
  }
  if (v42 == 1667778642)
  {
    uint64_t v10 = v40;
    CFTypeRef v9 = cf;
    uint64_t v11 = xpc_dictionary_get_uint64(a2, "CustomURLHandler_RequestID");
    *(void *)os_log_type_t type = 0;
    CFTypeRef v44 = 0;
    uint64_t MutableCopy = FigXPCMessageCopyCFDictionary(a2, "CustomURLHandler_RequestInfo", &v44);
    uint64_t v13 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (!MutableCopy)
    {
      if (v44)
      {
        uint64_t v14 = *MEMORY[0x1E4F1CF80];
        uint64_t MutableCopy = FigCustomURLRequestInfoCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (CFDictionaryRef)v44, (CFTypeRef *)type);
        if (!MutableCopy)
        {
          uint64_t v15 = (id *)v10[2];
          if (v15) {
            uint64_t v16 = FigCFWeakReferenceHolderCopyReferencedObject(v15);
          }
          else {
            uint64_t v16 = 0;
          }
          uint64_t v22 = *(void **)type;
          v48[0] = 0;
          *(void *)uint64_t v45 = 0;
          CryptorIOSurfaceID ID = FigCustomURLRequestInfoGetCryptorID(*(uint64_t *)type, v45);
          if (CryptorID == -17360)
          {
            uint64_t v24 = 0;
          }
          else
          {
            uint64_t v24 = CryptorID;
            if (!CryptorID)
            {
              uint64_t v25 = FigCPECryptorRemoteRetainCopiedCryptor(v14, *(const void **)v45, v48);
              if (v25
                || (uint64_t v25 = FigCustomURLRequestInfoSetCryptor((__CFDictionary *)v22, (void *)v48[0]), v25))
              {
                uint64_t v24 = v25;
              }
              else
              {
                uint64_t v24 = FigCustomURLRequestInfoSetCryptorID(v22, 0);
                if (!v24) {
                  goto LABEL_26;
                }
              }
              FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
            }
          }
LABEL_26:
          if (v48[0]) {
            CFRelease(v48[0]);
          }
          if (!v24)
          {
            uint64_t v24 = FigCustomURLRequestInfoDeserializeNSSecureCodingTypes(*(const __CFDictionary **)type);
            if (!v24)
            {
              uint64_t v26 = *(const void **)type;
              *(void *)os_log_type_t type = 0;
              if (!v16) {
                goto LABEL_32;
              }
              goto LABEL_31;
            }
          }
          uint64_t v26 = 0;
          if (v16) {
LABEL_31:
          }
            CFRelease(v16);
LABEL_32:
          if (v44) {
            CFRelease(v44);
          }
          if (*(void *)type) {
            CFRelease(*(CFTypeRef *)type);
          }
          if (v24 == -17378)
          {
            int v27 = 0;
LABEL_56:
            xpc_dictionary_set_BOOL(a3, "CustomURLHandler_CanHandleResult", v27 != 0);
LABEL_57:
            uint64_t v24 = 0;
            goto LABEL_58;
          }
          if (v24) {
            goto LABEL_58;
          }
          uint64_t v28 = *v10;
          if (!*v10) {
            goto LABEL_57;
          }
          uint64_t v29 = gFigCustomURLHandlerServerCallbackQueue;
          if (handlerServerShimCompletionRec_getCFAllocator_sOnceToken != -1) {
            dispatch_once_f(&handlerServerShimCompletionRec_getCFAllocator_sOnceToken, &handlerServerShimCompletionRec_getCFAllocator_sAllocator, (dispatch_function_t)handlerServerShimCompletionRec_initializeCFAllocatorOnce);
          }
          CFAllocatorRef v30 = (const __CFAllocator *)handlerServerShimCompletionRec_getCFAllocator_sAllocator;
          if (!handlerServerShimCompletionRec_getCFAllocator_sAllocator)
          {
            uint64_t v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
            if (v24) {
              goto LABEL_58;
            }
          }
          uint64_t v31 = (const UInt8 *)malloc_type_calloc(1uLL, 0x10uLL, 0x102004075F474C6uLL);
          if (v31)
          {
            uint64_t v32 = (UInt8 *)v31;
            CFDataRef v33 = CFDataCreateWithBytesNoCopy(*v13, v31, 16, v30);
            if (v33)
            {
              CFDataRef v34 = v33;
              *(void *)uint64_t v32 = dispatch_semaphore_create(0);
              v32[8] = 0;
              *((_DWORD *)v32 + 3) = 0;
              uint64_t v35 = *(void *)(CMBaseObjectGetVTable((uint64_t)v9) + 16);
              if (v35) {
                uint64_t v36 = v35;
              }
              else {
                uint64_t v36 = 0;
              }
              int v37 = *(uint64_t (**)(CFTypeRef, const void *, uint64_t, uint64_t, uint64_t, void (*)(uint64_t, uint64_t, const __CFDictionary *, OpaqueCMBlockBuffer *, unsigned int, __CFError *, const void *), intptr_t (*)(const __CFData *, char, int), CFDataRef))(v36 + 32);
              if (v37)
              {
                uint64_t v38 = v37(v9, v26, v11, v28, v29, figCustomURLHandlerServer_shimDataCallback, figCustomURLHandlerServer_handleRequestShimCompletionHandler, v34);
                if (v38)
                {
                  uint64_t v24 = v38;
                  int v27 = 0;
                }
                else
                {
                  dispatch_semaphore_wait(*(dispatch_semaphore_t *)v32, 0xFFFFFFFFFFFFFFFFLL);
                  int v27 = v32[8];
                  uint64_t v24 = *((unsigned int *)v32 + 3);
                }
              }
              else
              {
                int v27 = 0;
                uint64_t v24 = 4294954514;
              }
              CFRelease(v34);
              if (!v24) {
                goto LABEL_56;
              }
              goto LABEL_58;
            }
            free(v32);
          }
          uint64_t v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          int v27 = 0;
          if (!v24) {
            goto LABEL_56;
          }
LABEL_58:
          if (v26) {
            CFRelease(v26);
          }
          goto LABEL_60;
        }
      }
      else
      {
        uint64_t MutableCopy = FigSignalErrorAt(4294949926, 0, 0, 0, 0, 0, 0);
      }
    }
    uint64_t v24 = MutableCopy;
    uint64_t v26 = 0;
    goto LABEL_32;
  }
  if (dword_1EB28B650)
  {
    LODWORD(v44) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B648, 1, (int *)&v44, type);
    unsigned int v18 = v44;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
      unsigned int v20 = v18;
    }
    else {
      unsigned int v20 = v18 & 0xFFFFFFFE;
    }
    if (v20)
    {
      *(_DWORD *)uint64_t v45 = 136315394;
      *(void *)&v45[4] = "figCustomURLHandlerServer_handleRemoteMessage";
      __int16 v46 = 1024;
      int v47 = v42;
      CFTypeID v21 = (CFTypeRef *)_os_log_send_and_compose_impl();
      LOBYTE(v18) = (_BYTE)v44;
    }
    else
    {
      CFTypeID v21 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B648, 1u, 1, v21, v21 != v48, v18, 0, v19);
  }
  uint64_t v24 = 0;
LABEL_60:
  if (cf) {
    CFRelease(cf);
  }
  return v24;
}

uint64_t figCustomURLHandlerServer_handleRemoteMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  int v16 = 0;
  uint64_t v14 = 0;
  CFTypeRef cf = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v16);
  if (OpCode) {
    goto LABEL_16;
  }
  uIOSurfaceID int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  uint64_t OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v14);
  if (OpCode) {
    goto LABEL_16;
  }
  if (!cf || (CFTypeID v6 = CFGetTypeID(cf), v6 != FigCustomURLHandlerGetTypeID()))
  {
    uint64_t OpCode = FigSignalErrorAt(4294949926, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  if (!*v14)
  {
    uint64_t OpCode = FigCustomURLHandlerServerRequestingClientCreate(a1, uint64, v14);
    if (OpCode) {
      goto LABEL_16;
    }
  }
  if (v16 == 1667777641)
  {
    uint64_t OpCode = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_16:
    uint64_t v11 = OpCode;
    goto LABEL_18;
  }
  if (v16 != 1667777362)
  {
    uint64_t v11 = 0;
    goto LABEL_18;
  }
  CFTypeRef v7 = cf;
  uint64_t v8 = xpc_dictionary_get_uint64(a2, "CustomURLHandler_RequestID");
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable((uint64_t)v7) + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(CFTypeRef, uint64_t))(v10 + 40);
  if (v12)
  {
    uint64_t OpCode = v12(v7, v8);
    goto LABEL_16;
  }
  uint64_t v11 = 4294954514;
LABEL_18:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t FigCustomURLHandlerServerRequestingClientCreate(void *a1, uint64_t a2, uint64_t *a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (FigCustomURLHandlerServerRequestingClientGetTypeID_sFigCustomURLHandlerServerRequestingClientRegisterOnce != -1) {
    dispatch_once(&FigCustomURLHandlerServerRequestingClientGetTypeID_sFigCustomURLHandlerServerRequestingClientRegisterOnce, &__block_literal_global_23_0);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v8 = Instance;
    *(void *)(Instance + 16) = FigXPCRetain(a1);
    *(void *)(v8 + 24) = a2;
    *(void *)(v8 + 32) = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *a3 = v8;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

double figCustomURLHandlerServerRequestingClient_init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figCustomURLHandlerServerRequestingClient_finalize(void *a1)
{
  CFAllocatorRef v2 = (void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    xpc_release(v2);
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
}

uint64_t __FigCustomURLHandlerServerRequestingClientGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  FigCustomURLHandlerServerRequestingClientGetTypeID_sFigCustomURLHandlerServerRequestingClientCFTypeID TypeID = result;
  return result;
}

void figCustomURLHandlerServer_shimDataCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, OpaqueCMBlockBuffer *a4, unsigned int a5, __CFError *a6, const void *a7)
{
  xpc_object_t xdict = 0;
  uint64_t valuePtr = a2;
  Boolean v19 = 0;
  if (FigXPCCreateBasicMessage(0x63684443u, *(void *)(a1 + 24), &xdict)) {
    goto LABEL_34;
  }
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (!v14)
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_34:
    FigXPCRelease(xdict);
    return;
  }
  CFNumberRef v15 = v14;
  xpc_dictionary_set_uint64(xdict, "CustomURLHandler_RequestID", valuePtr);
  FigCFDictionaryGetBooleanIfPresent(*(void *)(a1 + 32), v15, &v19);
  if (v19)
  {
    CFTypeRef v16 = 0;
    goto LABEL_21;
  }
  CFTypeRef v23 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v22 = 0;
  int v17 = FigCustomURLResponseInfoCopyRequestInfo(a3, &cf);
  if (v17
    || (int v17 = FigCustomURLRequestInfoCreateMutableCopy(v13, (CFDictionaryRef)cf, &v23)) != 0
    || (int v17 = FigCustomURLRequestInfoSetCryptor((__CFDictionary *)v23, 0)) != 0
    || (int v17 = FigCustomURLResponseInfoCreateMutable(v13, v23, &v22)) != 0
    || (int v17 = FigCustomURLResponseInfoSetAllValuesFromResponseInfo((void *)v22, a3)) != 0)
  {
    int NSSecureCodingTypesSerializable = v17;
    goto LABEL_32;
  }
  int NSSecureCodingTypesSerializable = FigCustomURLResponseInfoMakeNSSecureCodingTypesSerializable((void *)v22);
  if (NSSecureCodingTypesSerializable)
  {
LABEL_32:
    CFTypeRef v16 = 0;
    goto LABEL_12;
  }
  CFTypeRef v16 = v22;
  CFTypeRef v22 = 0;
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (NSSecureCodingTypesSerializable
    || FigXPCMessageSetCFDictionary(xdict, "CustomURLHandler_ResponseInfo", v16))
  {
    goto LABEL_27;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v15, (const void *)*MEMORY[0x1E4F1CFD0]);
LABEL_21:
  if ((a5 & 3) != 0) {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v15);
  }
  if (!FigXPCMessageSetBlockBuffer(xdict, "CustomURLHandler_BlockBuffer", a4))
  {
    xpc_dictionary_set_uint64(xdict, "CustomURLHandler_CallbackFlags", a5);
    if (!FigXPCMessageSetCFError(xdict, "CustomURLHandler_Error", a6)
      && !FigXPCMessageSetCFDictionary(xdict, "CustomURLHandler_FinalReport", a7))
    {
      xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), xdict);
    }
  }
LABEL_27:
  FigXPCRelease(xdict);
  if (v16) {
    CFRelease(v16);
  }
  CFRelease(v15);
}

intptr_t figCustomURLHandlerServer_handleRequestShimCompletionHandler(const __CFData *a1, char a2, int a3)
{
  BytePtr = CFDataGetBytePtr(a1);
  *((unsigned char *)BytePtr + 8) = a2;
  *((_DWORD *)BytePtr + 3) = a3;
  CFAllocatorRef v6 = *(NSObject **)BytePtr;

  return dispatch_semaphore_signal(v6);
}

uint64_t handlerServerShimCompletionRec_initializeCFAllocatorOnce(void *a1)
{
  CFTypeRef v3 = 0;
  uint64_t result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))handlerServerShimCompletionRec_dealloc, &v3);
  if (!result) {
    *a1 = v3;
  }
  return result;
}

void handlerServerShimCompletionRec_dealloc(NSObject **a1)
{
  CFAllocatorRef v2 = *a1;
  if (v2) {
    dispatch_release(v2);
  }

  free(a1);
}

uint64_t FigEndpointExtendedGetClassID()
{
  if (FigEndpointExtendedGetClassID_sRegisterFigEndpointExtendedBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointExtendedGetClassID_sRegisterFigEndpointExtendedBaseTypeOnce, &FigEndpointExtendedGetClassID_sFigEndpointExtendedClassID, (dispatch_function_t)FigEndpointExtendedGetClassIDCallback);
  }
  return FigEndpointExtendedGetClassID_sFigEndpointExtendedClassID;
}

uint64_t FigEndpointExtendedGetClassIDCallback(void *a1)
{
  ClassIOSurfaceID ID = (void *)FigEndpointGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigEndpointExtendedGetClassIDCallback_sFigEndpointExtendedClassDesc, ClassID, 0, a1);
}

CFStringRef FigEndpointExtendedBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointExtended %p]", a1);
}

uint64_t FigCaptionSerializerGetTypeID()
{
  return sFigCaptionSerializerID;
}

uint64_t RegisterFigCaptionSerializerType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionSerializerIOSurfaceID ID = result;
  return result;
}

uint64_t FigCaptionSerializerCreate(uint64_t a1, void ***a2)
{
  if (a2)
  {
    FigThreadRunOnce(&sRegisterFigCaptionSerializerTypeOnce, (void (*)(void))RegisterFigCaptionSerializerType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (!Instance)
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    uint64_t v5 = (void **)Instance;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    v5[2] = Mutable;
    if (Mutable)
    {
      uint64_t v7 = FigCFDictionarySetInt32(Mutable, @"FigCaptionSerializerVersion", 1);
      if (!v7)
      {
        uint64_t v8 = FigCFDictionarySetInt32(v5[2], @"FigCaptionSerializerFormat", 1);
        if (!v8)
        {
          *a2 = v5;
          return v8;
        }
LABEL_14:
        CFRelease(v5);
        return v8;
      }
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v8 = v7;
    goto LABEL_14;
  }
  return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionSerializerCopyProperty(uint64_t a1, CFTypeRef cf1, uint64_t a3, void *a4)
{
  if (a1
    && cf1
    && a4
    && (CFEqual(cf1, @"FigCaptionSerializerVersion") || CFEqual(cf1, @"FigCaptionSerializerFormat")))
  {
    CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), cf1);
    uint64_t v8 = Value;
    if (Value) {
      CFRetain(Value);
    }
    *a4 = v8;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionSerializerSetProperty(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  if (a1
    && cf1
    && a3
    && (CFEqual(cf1, @"FigCaptionSerializerVersion") || CFEqual(cf1, @"FigCaptionSerializerFormat")))
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), cf1, a3);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionSerializerCreateCFDataFromCaptionGroup(uint64_t a1, uint64_t a2, CFMutableDataRef *a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (!a2 || !a3)
    {
      uint64_t Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
      CFMutableDictionaryRef Mutable = 0;
      goto LABEL_66;
    }
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (!Mutable)
    {
      uint64_t v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_82:
      uint64_t Code = v16;
      goto LABEL_66;
    }
    CFAllocatorRef v30 = a3;
    SliceCFIndex Count = FigCaptionGroupGetSliceCount(a2);
    if (SliceCount)
    {
      CFIndex v10 = SliceCount;
      CFIndex v11 = 0;
      CFMutableArrayRef v12 = 0;
      CFAllocatorRef v13 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      while (1)
      {
        if (v12) {
          CFRelease(v12);
        }
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0;
        }
        CFMutableArrayRef v12 = CFArrayCreateMutable(v6, 0, v13);
        if (v12)
        {
          FigCaptionGroupGetDurationBeforeSlice(a2, v11, (uint64_t)error);
          *(_OWORD *)CFNumberRef number = *(_OWORD *)error;
          *(void *)&long long v36 = v40;
          uint64_t appended = FigCFArrayAppendCMTime(v12, (CMTime *)number);
          if (appended
            || (FigCaptionGroupGetDurationAfterSlice(a2, v11, (uint64_t)number),
                *(_OWORD *)CFErrorRef error = *(_OWORD *)number,
                *(void *)&long long v40 = v36,
                uint64_t appended = FigCFArrayAppendCMTime(v12, (CMTime *)number),
                appended))
          {
            uint64_t Code = appended;
            goto LABEL_65;
          }
        }
        else
        {
          uint64_t v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
          if (v16) {
            goto LABEL_82;
          }
        }
        CaptionCFDataRef Data = FigCaptionGroupGetCaptionData(a2, v11);
        if (!CaptionData) {
          break;
        }
        fcs_copyCaptionDataAsDictionary(CaptionData, (__CFDictionary **)&cf);
        CFDictionarySetValue((CFMutableDictionaryRef)cf, @"Durations", v12);
        CFArrayAppendValue(Mutable, cf);
        if (v10 == ++v11) {
          goto LABEL_20;
        }
      }
      uint64_t Code = 0;
      if (!v12) {
        goto LABEL_66;
      }
LABEL_65:
      CFRelease(v12);
LABEL_66:
      if (cf) {
        CFRelease(cf);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      return Code;
    }
    CFMutableArrayRef v12 = 0;
LABEL_20:
    error[0] = 0;
    number[0] = 0;
    LODWORD(valuePtr[0]) = 0;
    uint64_t v17 = FigCaptionSerializerCopyProperty(a1, @"FigCaptionSerializerFormat", v9, number);
    if (v17)
    {
      uint64_t Code = v17;
      CFDataRef Data = 0;
    }
    else
    {
      CFNumberGetValue(number[0], kCFNumberSInt32Type, valuePtr);
      if (LODWORD(valuePtr[0]) == 2) {
        CFPropertyListFormat v18 = kCFPropertyListBinaryFormat_v1_0;
      }
      else {
        CFPropertyListFormat v18 = kCFPropertyListXMLFormat_v1_0;
      }
      CFDataRef Data = CFPropertyListCreateData(v6, Mutable, v18, 0, error);
      if (Data)
      {
        if (!error[0])
        {
          uint64_t Code = 0;
          goto LABEL_33;
        }
        CFStringRef v20 = CFErrorCopyFailureReason(error[0]);
        uint64_t Code = CFErrorGetCode(error[0]);
        if (v20) {
          CFRelease(v20);
        }
      }
      else
      {
        uint64_t Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      }
    }
    if (error[0]) {
      CFRelease(error[0]);
    }
    if (Data)
    {
      CFRelease(Data);
      CFDataRef Data = 0;
    }
LABEL_33:
    if (number[0]) {
      CFRelease(number[0]);
    }
    if (Code) {
      goto LABEL_59;
    }
    valuePtr[0] = 0;
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    *(_OWORD *)CFErrorRef error = 0u;
    uint64_t v38 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    *(_OWORD *)CFNumberRef number = 0u;
    CFNumberRef v33 = 0;
    uint64_t v34 = 0;
    CFNumberRef v32 = 0;
    if (Data)
    {
      CFMutableDataRef v22 = CFDataCreateMutable(v6, 0);
      CFMutableDataRef v23 = v22;
      if (!v22)
      {
        uint64_t Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
        goto LABEL_51;
      }
      WritableWithCFMutableCFDataRef Data = FigByteStreamCreateWritableWithCFMutableData(v22, 0, (uint64_t)v6, valuePtr);
      if (WritableWithCFMutableData) {
        goto LABEL_74;
      }
      WritableWithCFMutableCFDataRef Data = FigAtomWriterInitWithByteStream((uint64_t)valuePtr[0], (uint64_t)error);
      if (WritableWithCFMutableData) {
        goto LABEL_74;
      }
      WritableWithCFMutableCFDataRef Data = FigAtomWriterBeginAtom((uint64_t)error, 0x66637367u, 0);
      if (WritableWithCFMutableData) {
        goto LABEL_74;
      }
      WritableWithCFMutableCFDataRef Data = FigAtomWriterInitWithParent((uint64_t)error, (uint64_t)number);
      if (WritableWithCFMutableData) {
        goto LABEL_74;
      }
      WritableWithCFMutableCFDataRef Data = FigCaptionSerializerCopyProperty(a1, @"FigCaptionSerializerVersion", v25, &v33);
      if (WritableWithCFMutableData) {
        goto LABEL_74;
      }
      WritableWithCFMutableCFDataRef Data = FigCaptionSerializerCopyProperty(a1, @"FigCaptionSerializerFormat", v26, &v32);
      if (WritableWithCFMutableData) {
        goto LABEL_74;
      }
      CFNumberGetValue(v33, kCFNumberSInt32Type, &v34);
      CFNumberGetValue(v32, kCFNumberSInt32Type, (char *)&v34 + 4);
      WritableWithCFMutableCFDataRef Data = FigAtomWriterBeginAtom((uint64_t)number, 0x66637369u, 0);
      if (WritableWithCFMutableData
        || (WritableWithCFMutableCFDataRef Data = FigAtomWriterAppendData((uint64_t)number, (uint64_t)&v34, 8),
            WritableWithCFMutableData)
        || (WritableWithCFMutableCFDataRef Data = FigAtomWriterEndAtom((uint64_t)number), WritableWithCFMutableData)
        || (WritableWithCFMutableCFDataRef Data = FigAtomWriterBeginAtom((uint64_t)number, 0x66637364u, 0),
            WritableWithCFMutableData)
        || (BytePtr = CFDataGetBytePtr(Data),
            CFIndex Length = CFDataGetLength(Data),
            WritableWithCFMutableCFDataRef Data = FigAtomWriterAppendData((uint64_t)number, (uint64_t)BytePtr, Length),
            WritableWithCFMutableData)
        || (WritableWithCFMutableCFDataRef Data = FigAtomWriterEndAtom((uint64_t)number), WritableWithCFMutableData))
      {
LABEL_74:
        uint64_t Code = WritableWithCFMutableData;
      }
      else
      {
        uint64_t Code = FigAtomWriterEndAtom((uint64_t)error);
        if (!Code)
        {
LABEL_51:
          if (v32) {
            CFRelease(v32);
          }
          if (v33) {
            CFRelease(v33);
          }
          if (valuePtr[0]) {
            CFRelease(valuePtr[0]);
          }
          if (Code)
          {
LABEL_60:
            if (Data) {
              CFRelease(Data);
            }
            if (v23) {
              CFRelease(v23);
            }
            if (!v12) {
              goto LABEL_66;
            }
            goto LABEL_65;
          }
          *CFAllocatorRef v30 = v23;
LABEL_59:
          CFMutableDataRef v23 = 0;
          goto LABEL_60;
        }
      }
      CFRelease(v23);
    }
    else
    {
      uint64_t Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    }
    CFMutableDataRef v23 = 0;
    goto LABEL_51;
  }

  return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
}

uint64_t fcs_copyCaptionDataAsDictionary(const void *a1, __CFDictionary **a2)
{
  CMTimeValue value = 0;
  if (!a1)
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v2 = a2;
  if (!a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    goto LABEL_110;
  }
  uint64_t v3 = (uint64_t)a1;
  uint64_t v4 = fcs_copyCaptionPropertiesAsDictionary(a1, (__CFArray *)&value);
  if (v4)
  {
LABEL_110:
    uint64_t v16 = v4;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_39;
  }
  CFMutableDictionaryRef v62 = 0;
  CFTypeRef v63 = 0;
  uint64_t v60 = 0;
  theArradouble y = 0;
  CFTypeRef cf = 0;
  uint64_t v59 = 0;
  double v57 = 0.0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    uint64_t v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    CFIndex Count = 0;
    CFMutableDictionaryRef v14 = 0;
    CFMutableArrayRef v15 = 0;
    CFMutableDictionaryRef v17 = 0;
    goto LABEL_14;
  }
  uint64_t CMBaseObject = FigCaptionDataGetCMBaseObject(v3);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFArrayRef *))(v8 + 48);
  if (!v9)
  {
    CFIndex Count = 0;
    CFMutableDictionaryRef v14 = 0;
    CFMutableArrayRef v15 = 0;
    uint64_t v16 = 4294954514;
LABEL_13:
    CFMutableDictionaryRef v17 = Mutable;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_14;
  }
  uint64_t v10 = v9(CMBaseObject, @"StylePropertyKeysInUse", allocator, &theArray);
  if (v10)
  {
LABEL_115:
    uint64_t v16 = v10;
    CFIndex Count = 0;
    CFMutableDictionaryRef v14 = 0;
    CFMutableArrayRef v15 = 0;
    goto LABEL_13;
  }
  CFIndex Count = (const void *)CFArrayGetCount(theArray);
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable(v3) + 16);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v25 = *(uint64_t (**)(uint64_t))(v13 + 8);
  if (v25)
  {
    CFStringRef v26 = (const __CFString *)v25(v3);
    if (!v26)
    {
      CFIndex Count = 0;
      CFMutableDictionaryRef v14 = 0;
      CFMutableArrayRef v15 = 0;
      uint64_t v16 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    CFStringRef v26 = &stru_1EDF73CD0;
  }
  FigThreadRunOnce(&fcs_getCaptionInfoToPListableMappingDictionary_sInitializeCaptionPropertyToPListableMappingOnce, fcs_initializeCaptionPropertyToPListableMappingDictionary);
  CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sCaptionInfoToPListableMappingDictionary, @"StyleProperty");
  if (!v27)
  {
    uint64_t v10 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_115;
  }
  CFDictionaryRef v28 = v27;
  CFIndex Length = CFStringGetLength(v26);
  if (!Count)
  {
    CFMutableDictionaryRef v14 = 0;
    CFMutableArrayRef v15 = 0;
    CFMutableDictionaryRef v17 = 0;
    uint64_t v16 = 0;
    goto LABEL_14;
  }
  uint64_t v48 = v2;
  int v49 = Count;
  CFIndex v29 = 0;
  CFIndex Count = 0;
  CFMutableDictionaryRef v14 = 0;
  CFMutableArrayRef v15 = 0;
  uint64_t v52 = v3;
  CFAllocatorRef v30 = allocator;
  CFMutableDictionaryRef theDict = Mutable;
  while (1)
  {
    CFIndex v51 = v29;
    ValueAtIndedouble x = CFArrayGetValueAtIndex(theArray, v29);
    CFNumberRef v32 = Count;
    CFNumberRef v33 = ValueAtIndex;
    if (v32) {
      CFRelease(v32);
    }
    CFMutableArrayRef v53 = CFArrayCreateMutable(v30, 0, MEMORY[0x1E4F1D510]);
    if (!v53)
    {
      uint64_t v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      CFIndex Count = 0;
      CFMutableDictionaryRef v17 = Mutable;
      CFMutableDictionaryRef Mutable = 0;
      goto LABEL_95;
    }
    if (Length) {
      break;
    }
LABEL_93:
    CFMutableDictionaryRef Mutable = theDict;
    int v47 = v33;
    CFIndex Count = v53;
    CFDictionarySetValue(theDict, v47, v53);
    CFIndex v29 = v51 + 1;
    if ((const void *)(v51 + 1) == v49)
    {
      CFMutableDictionaryRef v17 = 0;
      uint64_t v16 = 0;
LABEL_95:
      uint64_t v2 = v48;
      goto LABEL_14;
    }
  }
  uint64_t v34 = 0;
  while (1)
  {
    if (v63)
    {
      CFRelease(v63);
      CFTypeRef v63 = 0;
    }
    uint64_t v35 = *(void *)(CMBaseObjectGetVTable(v3) + 16);
    if (v35) {
      uint64_t v36 = v35;
    }
    else {
      uint64_t v36 = 0;
    }
    long long v37 = *(uint64_t (**)(uint64_t, uint64_t, const void *, const __CFAllocator *, CFTypeRef *, uint64_t *))(v36 + 24);
    if (!v37)
    {
      uint64_t v16 = 4294954514;
LABEL_98:
      CFMutableDictionaryRef v17 = theDict;
      CFMutableDictionaryRef Mutable = 0;
      uint64_t v2 = v48;
      CFIndex Count = v53;
      goto LABEL_14;
    }
    uint64_t v38 = v37(v3, v34, v33, v30, &v63, &v59);
    if (v38) {
      goto LABEL_105;
    }
    if (!v63) {
      goto LABEL_92;
    }
    if (v14) {
      CFRelease(v14);
    }
    if (v15) {
      CFRelease(v15);
    }
    CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(v30, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!v14)
    {
      uint64_t v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      CFMutableArrayRef v15 = 0;
      goto LABEL_98;
    }
    CFMutableArrayRef v15 = CFArrayCreateMutable(v30, 0, MEMORY[0x1E4F1D510]);
    if (!v15)
    {
      uint64_t v38 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_105:
      uint64_t v16 = v38;
      goto LABEL_98;
    }
    if (!v63 || (CFTypeID v39 = CFGetTypeID(v63), v39 != FigCaptionDynamicStyleGetTypeID()))
    {
      KeyFrameCFIndex Count = 1;
LABEL_76:
      CFIndex v41 = 0;
      while (1)
      {
        if (v62)
        {
          CFRelease(v62);
          CFMutableDictionaryRef v62 = 0;
        }
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0;
        }
        double v57 = 0.0;
        if (CFEqual(v33, @"Ruby"))
        {
          uint64_t v42 = fcs_copyCaptionDataAsDictionary(v63, &v62);
          if (v42) {
            goto LABEL_99;
          }
        }
        else
        {
          uint64_t v42 = FigCaptionDynamicStyleCopyKeyFrameValueAtIndex((CFIndex)v63, v41, &v57, &cf);
          if (v42 || (uint64_t v42 = fcs_copyCaptionStyleAsDictionary(v33, (uint64_t)cf, v28, &v62), v42))
          {
LABEL_99:
            uint64_t v16 = v42;
            goto LABEL_102;
          }
        }
        uint64_t v42 = FigCFDictionarySetDouble(v62, @"RelativeTime", v57);
        if (v42) {
          goto LABEL_99;
        }
        CFArrayAppendValue(v15, v62);
        if (KeyFrameCount == ++v41) {
          goto LABEL_88;
        }
      }
    }
    KeyFrameCFIndex Count = FigCaptionDynamicStyleGetKeyFrameCount((CFIndex)v63);
    if (KeyFrameCount) {
      goto LABEL_76;
    }
LABEL_88:
    uint64_t v44 = v59;
    uint64_t v43 = v60;
    CFMutableDictionaryRef v45 = CFDictionaryCreateMutable(allocator, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!v45) {
      goto LABEL_101;
    }
    CFMutableDictionaryRef v46 = v45;
    if (FigCFDictionarySetCFIndex(v45, @"RangeLocation", v44)
      || FigCFDictionarySetCFIndex(v46, @"RangeLength", v43))
    {
      break;
    }
    CFDictionarySetValue(v14, @"PropertyRange", v46);
    CFDictionarySetValue(v14, @"DynamicStyleValue", v15);
    CFArrayAppendValue(v53, v14);
    CFRelease(v46);
    uint64_t v3 = v52;
    CFAllocatorRef v30 = allocator;
LABEL_92:
    v34 += v60;
    if (v34 == Length) {
      goto LABEL_93;
    }
  }
  CFRelease(v46);
LABEL_101:
  uint64_t v16 = 0;
LABEL_102:
  CFMutableDictionaryRef v17 = theDict;
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v2 = v48;
  uint64_t v3 = v52;
  CFIndex Count = v53;
LABEL_14:
  if (v63) {
    CFRelease(v63);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (Count) {
    CFRelease(Count);
  }
  if (v62) {
    CFRelease(v62);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (!v16)
  {
    CFMutableDictionaryRef v18 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v18)
    {
      Boolean v19 = v18;
      uint64_t v20 = *(void *)(CMBaseObjectGetVTable(v3) + 16);
      if (v20) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
      CFMutableDataRef v22 = *(uint64_t (**)(uint64_t))(v21 + 8);
      if (v22) {
        CFMutableDataRef v23 = (__CFString *)v22(v3);
      }
      else {
        CFMutableDataRef v23 = &stru_1EDF73CD0;
      }
      CFDictionarySetValue(v19, @"Text", v23);
      CFDictionarySetValue(v19, @"Properties", value);
      CFDictionarySetValue(v19, @"StyleProperties", Mutable);
      uint64_t v16 = 0;
      *uint64_t v2 = v19;
    }
    else
    {
      uint64_t v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    }
  }
LABEL_39:
  if (value) {
    CFRelease(value);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v16;
}

uint64_t FigCaptionSerializerCreateCaptionGroupFromCFData(void **a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v3 = a1;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  CFTypeRef v33 = 0;
  CFTypeRef v34 = 0;
  CFErrorRef error = 0;
  if (!a1)
  {
    uint64_t Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
LABEL_77:
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v16 = 0;
    CFMutableDictionaryRef v17 = 0;
    CFPropertyListRef v13 = 0;
LABEL_84:
    CFStringRef v14 = 0;
    goto LABEL_48;
  }
  if (!a2 || !a3)
  {
    uint64_t Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    uint64_t v3 = 0;
    goto LABEL_77;
  }
  memset(v39, 0, sizeof(v39));
  memset(v38, 0, sizeof(v38));
  CFTypeRef cf = 0;
  int v36 = 0;
  size_t size = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v6 = FigByteStreamCreateWithCFData(a2, 0, *MEMORY[0x1E4F1CF80], &cf);
  if (v6
    || (uint64_t v6 = FigAtomStreamInitWithByteStream((uint64_t)cf, 0, 0, (uint64_t)v39), v6)
    || (uint64_t v6 = FigAtomStreamInitWithParent((uint64_t)v39, 0, (uint64_t)v38), v6))
  {
    uint64_t Code = v6;
    uint64_t v3 = 0;
  }
  else
  {
    CFDataRef v7 = 0;
    do
    {
      CurrentAtomTypeAndsize_t DataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v38, &v36, &size);
      if (CurrentAtomTypeAndDataLength) {
        goto LABEL_69;
      }
      uint64_t v9 = (UInt8 *)malloc_type_malloc(size, 0x6D42286BuLL);
      if (!v9) {
        goto LABEL_67;
      }
      uint64_t v10 = v9;
      CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)v38, 0, size, (uint64_t)v9);
      if (CurrentAtomTypeAndDataLength) {
        goto LABEL_69;
      }
      if (v36 == 1717793636)
      {
        if (v7) {
          CFRelease(v7);
        }
        CFDataRef v7 = CFDataCreate(v5, v10, size);
        if (!v7)
        {
LABEL_67:
          uint64_t v29 = 4294949616;
LABEL_68:
          CurrentAtomTypeAndsize_t DataLength = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
LABEL_69:
          uint64_t Code = CurrentAtomTypeAndDataLength;
          uint64_t v3 = 0;
          goto LABEL_25;
        }
      }
      else if (v36 == 1717793641)
      {
        if (size != 8)
        {
          uint64_t v29 = 4294949615;
          goto LABEL_68;
        }
        CurrentAtomTypeAndsize_t DataLength = FigCFDictionarySetInt32(v3[2], @"FigCaptionSerializerVersion", *v10);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_69;
        }
        CurrentAtomTypeAndsize_t DataLength = FigCFDictionarySetInt32(v3[2], @"FigCaptionSerializerFormat", v10[4]);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_69;
        }
      }
      free(v10);
      uint64_t Atom = FigAtomStreamAdvanceToNextAtom(v38);
    }
    while (!Atom);
    uint64_t Code = Atom;
    if (Atom == -12890) {
      uint64_t Code = 0;
    }
    uint64_t v3 = (void **)v7;
  }
  CFDataRef v7 = 0;
LABEL_25:
  if (cf) {
    CFRelease(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (Code) {
    goto LABEL_77;
  }
  CFPropertyListRef v13 = CFPropertyListCreateWithData(v5, (CFDataRef)v3, 0, 0, &error);
  if (!v13)
  {
    uint64_t Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_80:
    CFMutableDictionaryRef Mutable = 0;
LABEL_82:
    uint64_t v16 = 0;
LABEL_83:
    CFMutableDictionaryRef v17 = 0;
    goto LABEL_84;
  }
  if (error)
  {
    CFStringRef v14 = CFErrorCopyFailureReason(error);
    uint64_t Code = CFErrorGetCode(error);
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v16 = 0;
    CFMutableDictionaryRef v17 = 0;
    goto LABEL_48;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v13))
  {
    FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    uint64_t Code = 0;
    goto LABEL_80;
  }
  CFAllocatorRef v19 = v5;
  CFIndex Count = CFArrayGetCount((CFArrayRef)v13);
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v19, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_82;
  }
  uint64_t v16 = CFDataCreateMutable(v19, 0);
  if (!v16)
  {
    uint64_t Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_83;
  }
  CFAllocatorRef v31 = v19;
  CFMutableDictionaryRef v17 = CFDataCreateMutable(v19, 0);
  if (!v17)
  {
    uint64_t Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_84;
  }
  CFAllocatorRef v30 = a3;
  if (Count)
  {
    CFIndex v21 = 0;
    while (1)
    {
      if (v33)
      {
        CFRelease(v33);
        CFTypeRef v33 = 0;
      }
      ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v13, v21);
      if (!ValueAtIndex)
      {
        uint64_t Code = 0;
        goto LABEL_72;
      }
      CFDictionaryRef v23 = ValueAtIndex;
      uint64_t v24 = fcs_deserializeAndCreateFigCaptionData(ValueAtIndex, &v33);
      if (v24) {
        break;
      }
      CFArrayRef Value = CFDictionaryGetValue(v23, @"Durations");
      if (FigCFArrayGetCMTimeAtIndex(Value, 0, &bytes)) {
        FigCFArrayGetCMTimeAtIndex(Value, 1, &v41);
      }
      CFArrayAppendValue(Mutable, v33);
      CFDataAppendBytes(v16, (const UInt8 *)&bytes, 24);
      CFDataAppendBytes(v17, (const UInt8 *)&v41, 24);
      if (Count == ++v21) {
        goto LABEL_46;
      }
    }
    uint64_t Code = v24;
  }
  else
  {
LABEL_46:
    MutableBytePtr = (CMTime *)CFDataGetMutableBytePtr(v16);
    CFDictionaryRef v27 = (CMTime *)CFDataGetMutableBytePtr(v17);
    uint64_t Code = FigCaptionGroupCreate(v31, Mutable, MutableBytePtr, v27, (uint64_t *)&v34);
    if (!Code)
    {
      CFStringRef v14 = 0;
      *CFAllocatorRef v30 = v34;
      CFTypeRef v34 = 0;
      goto LABEL_48;
    }
  }
LABEL_72:
  CFStringRef v14 = 0;
LABEL_48:
  if (error) {
    CFRelease(error);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v13) {
    CFRelease(v13);
  }
  return Code;
}

uint64_t fcs_deserializeAndCreateFigCaptionData(const void *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (!a2) {
      goto LABEL_20;
    }
    uint64_t v4 = FigCaptionDataCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80], &cf);
    if (v4)
    {
LABEL_23:
      uint64_t v13 = v4;
      goto LABEL_17;
    }
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFDictionaryGetTypeID())
    {
      CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"Text");
      if (Value)
      {
        CFDataRef v7 = Value;
        CFTypeRef v8 = cf;
        uint64_t v9 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 16);
        if (v9) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = 0;
        }
        CFIndex v11 = *(uint64_t (**)(CFTypeRef, const void *))(v10 + 16);
        if (!v11)
        {
          uint64_t v13 = 4294954514;
          goto LABEL_17;
        }
        uint64_t v4 = v11(v8, v7);
        if (v4) {
          goto LABEL_23;
        }
        context[0] = 0;
        context[1] = cf;
        CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a1, @"Properties");
        if (v12)
        {
          CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)fcs_deserializeCaptionPropertyApplier, context);
          uint64_t v13 = LODWORD(context[0]);
          if (LODWORD(context[0])) {
            goto LABEL_17;
          }
          CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a1, @"StyleProperties");
          if (v14)
          {
            CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)fcs_deserializeCaptionStyleApplier, context);
            uint64_t v13 = LODWORD(context[0]);
            if (!LODWORD(context[0]))
            {
              *a2 = cf;
              return v13;
            }
LABEL_17:
            if (cf) {
              CFRelease(cf);
            }
            return v13;
          }
        }
      }
      uint64_t v16 = 4294954513;
    }
    else
    {
LABEL_20:
      uint64_t v16 = 4294949615;
    }
    uint64_t v4 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_23;
  }

  return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionSerializerInit(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void FigCaptionSerializerFinalize(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

CFStringRef FigCaptionSerializerCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionSerializer %p]", a1);
}

__CFString *FigCaptionSerializerCopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"FigCaptionSerializerVersion");
  uint64_t v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"FigCaptionSerializerFormat");
  CFStringAppendFormat(Mutable, 0, @"FigCaptionSerializer (version=%@, format=%@)\n", Value, v4);
  return Mutable;
}

uint64_t fcs_copyCaptionPropertiesAsDictionary(const void *a1, __CFArray *a2)
{
  CFTypeRef v37 = 0;
  CFTypeRef cf = 0;
  theArradouble y = 0;
  CFTypeRef v36 = 0;
  double v34 = 0.0;
  if (!a1)
  {
    uint64_t v30 = 4294949615;
    goto LABEL_77;
  }
  CFMutableDictionaryRef Mutable = a2;
  if (a2)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (theDict)
    {
      CFTypeID v5 = CFGetTypeID(a1);
      if (v5 == FigCaptionDataGetTypeID())
      {
        uint64_t v6 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 8);
        if (v6) {
          uint64_t v7 = v6;
        }
        else {
          uint64_t v7 = 0;
        }
        uint64_t v10 = *(uint64_t (**)(const void *, __CFString *, const __CFAllocator *, CFArrayRef *))(v7 + 48);
        if (v10) {
          uint64_t v11 = v10(a1, @"CaptionPropertyKeysInUse", v4, &theArray);
        }
        else {
          uint64_t v11 = 4294954514;
        }
        CFDictionaryRef v12 = @"CaptionProperty";
      }
      else
      {
        uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 8);
        if (v8) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v13 = *(uint64_t (**)(const void *, __CFString *, const __CFAllocator *, CFArrayRef *))(v9 + 48);
        if (v13) {
          uint64_t v11 = v13(a1, @"CMCaptionRegionPropertyKeysInUse", v4, &theArray);
        }
        else {
          uint64_t v11 = 4294954514;
        }
        CFDictionaryRef v12 = @"RegionProperty";
      }
      FigThreadRunOnce(&fcs_getCaptionInfoToPListableMappingDictionary_sInitializeCaptionPropertyToPListableMappingOnce, fcs_initializeCaptionPropertyToPListableMappingDictionary);
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sCaptionInfoToPListableMappingDictionary, v12);
      if (v11) {
        goto LABEL_78;
      }
      CFDictionaryRef v15 = Value;
      if (Value)
      {
        CFAllocatorRef v31 = Mutable;
        CFIndex Count = CFArrayGetCount(theArray);
        if (!Count)
        {
LABEL_59:
          uint64_t v11 = 0;
          CFMutableDictionaryRef Mutable = 0;
          *CFAllocatorRef v31 = theDict;
          goto LABEL_61;
        }
        CFIndex v16 = 0;
        while (1)
        {
          if (cf)
          {
            CFRelease(cf);
            CFTypeRef cf = 0;
          }
          CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
          if (!Mutable) {
            break;
          }
          ValueAtIndedouble x = CFArrayGetValueAtIndex(theArray, v16);
          uint64_t v18 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 8);
          if (v18) {
            uint64_t v19 = v18;
          }
          else {
            uint64_t v19 = 0;
          }
          uint64_t v20 = *(uint64_t (**)(const void *, const void *, const __CFAllocator *, CFTypeRef *))(v19 + 48);
          if (!v20)
          {
            uint64_t v11 = 4294954514;
            goto LABEL_61;
          }
          uint64_t v21 = v20(a1, ValueAtIndex, v4, &cf);
          if (v21) {
            goto LABEL_74;
          }
          double v34 = 0.0;
          if (CFEqual(ValueAtIndex, @"Region") || CFEqual(ValueAtIndex, @"CMCaptionRegionContainerRegion"))
          {
            if (v37)
            {
              CFRelease(v37);
              CFTypeRef v37 = 0;
            }
            uint64_t v21 = fcs_copyCaptionPropertiesAsDictionary(cf, &v37);
            if (v21) {
              goto LABEL_74;
            }
            CFArrayAppendValue(Mutable, v37);
          }
          else
          {
            if (!cf || (CFTypeID v22 = CFGetTypeID(cf), v22 != FigCaptionDynamicStyleGetTypeID()))
            {
              KeyFrameCFIndex Count = 1;
LABEL_44:
              CFIndex v24 = 0;
              while (2)
              {
                if (v37)
                {
                  CFRelease(v37);
                  CFTypeRef v37 = 0;
                }
                if (v36)
                {
                  CFRelease(v36);
                  CFTypeRef v36 = 0;
                }
                if (cf)
                {
                  CFTypeID v25 = CFGetTypeID(cf);
                  uint64_t TypeID = FigCaptionDynamicStyleGetTypeID();
                  CFTypeRef v27 = cf;
                  if (v25 == TypeID)
                  {
                    uint64_t v21 = FigCaptionDynamicStyleCopyKeyFrameValueAtIndex((CFIndex)cf, v24, &v34, &v36);
                    if (v21) {
                      goto LABEL_74;
                    }
                    CFTypeRef v27 = v36;
                    goto LABEL_55;
                  }
                }
                else
                {
                  CFTypeRef v27 = 0;
                }
                double v34 = -1.0;
LABEL_55:
                uint64_t v21 = fcs_copyCaptionStyleAsDictionary(ValueAtIndex, (uint64_t)v27, v15, (CFMutableDictionaryRef *)&v37);
                if (v21) {
                  goto LABEL_74;
                }
                uint64_t v21 = FigCFDictionarySetDouble((void *)v37, @"RelativeTime", v34);
                if (v21) {
                  goto LABEL_74;
                }
                CFArrayAppendValue(Mutable, v37);
                if (KeyFrameCount == ++v24) {
                  goto LABEL_37;
                }
                continue;
              }
            }
            KeyFrameCFIndex Count = FigCaptionDynamicStyleGetKeyFrameCount((CFIndex)cf);
            if (KeyFrameCount) {
              goto LABEL_44;
            }
          }
LABEL_37:
          CFDictionarySetValue(theDict, ValueAtIndex, Mutable);
          CFRelease(Mutable);
          if (++v16 == Count) {
            goto LABEL_59;
          }
        }
        uint64_t v29 = 4294949616;
        goto LABEL_73;
      }
    }
    uint64_t v30 = 4294949616;
LABEL_77:
    uint64_t v11 = FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
LABEL_78:
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_61;
  }
  uint64_t v29 = 4294949615;
LABEL_73:
  uint64_t v21 = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
LABEL_74:
  uint64_t v11 = v21;
LABEL_61:
  if (theArray) {
    CFRelease(theArray);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v37) {
    CFRelease(v37);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t fcs_copyCaptionStyleAsDictionary(const void *a1, uint64_t a2, const __CFDictionary *a3, CFMutableDictionaryRef *a4)
{
  if (a1 && a2 && a3 && a4)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v9 = Mutable;
      CFDictionaryRef Value = (uint64_t (*)(CFMutableDictionaryRef, __CFString *, uint64_t))CFDictionaryGetValue(a3, a1);
      if (Value)
      {
        uint64_t v11 = Value(v9, @"PropertyValue", a2);
        if (!v11)
        {
          *a4 = v9;
          return v11;
        }
      }
      else
      {
        uint64_t v11 = FigSignalErrorAt(4294954513, 0, 0, 0, 0, 0, 0);
      }
      CFRelease(v9);
      return v11;
    }
    uint64_t v13 = 4294949616;
  }
  else
  {
    uint64_t v13 = 4294949615;
  }

  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

void fcs_initializeCaptionPropertyToPListableMappingDictionary()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFMutableDictionaryRef v2 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E4F1D530], 0);
    if (v2)
    {
      uint64_t v3 = v2;
      CFMutableDictionaryRef v4 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E4F1D530], 0);
      if (v4)
      {
        CFTypeID v5 = v4;
        CFMutableDictionaryRef v6 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E4F1D530], 0);
        if (v6)
        {
          uint64_t v7 = v6;
          CFDictionaryAddValue(v3, @"Animation", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"TextAlign", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"MultiRowAlign", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"RubyAlign", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"RubyPosition", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionIdentifier", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionShowbackground", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionWritingMode", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionDisplayAlign", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionPadding", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionAnimation", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"FontWeight", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"FontStyle", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"TextCombine", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"TextShear", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"EdgeStyle", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"LineHeight", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"LinePadding", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"SourceInformation", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionCellResolution", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionPosition", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionWidth", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionHeight", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionDisplayAspectRatio", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionActiveArea", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionAnchor", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"FontSize", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"LineHeight", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionStereoDisparity", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionZIndex", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionOpacity", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"Decoration", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionLuminanceGain", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"FillLineGap", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"Hidden", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionClipOverflow", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionInvisible", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionForcedDisplay", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionHidden", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionExplicitRegion", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"Hidden", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"Invisible", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"ForcedDisplay", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"PreventLineWrapping", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, @"WritingDirection", fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, @"BackgroundColor", fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v5, @"CMCaptionRegionBackgroundColor", fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v7, @"TextColor", fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v7, @"BackgroundColor", fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v7, @"FontFamily", fcs_setDictionaryFromPropertyFontFamily);
          CFDictionaryAddValue(v7, @"TextOutline", fcs_setDictionaryFromPropertyTextOutline);
          CFDictionaryAddValue(v7, @"TextEmphasis", fcs_setDictionaryFromPropertyTextEmphasis);
          CFDictionaryAddValue(v7, @"TextShadow", fcs_setDictionaryFromPropertyTextShadow);
          CFDictionaryAddValue(v3, @"RubyReserve", fcs_setDictionaryFromPropertyRubyReserve);
          CFDictionaryAddValue(v5, @"CMCaptionRegionAbstractPosition", fcs_setDictionaryFromPropertyCaptionPosition);
          CFDictionaryAddValue(Mutable, @"CaptionProperty", v3);
          CFDictionaryAddValue(Mutable, @"RegionProperty", v5);
          CFDictionaryAddValue(Mutable, @"StyleProperty", v7);
          CFRelease(v3);
          uint64_t v3 = v5;
          CFTypeID v5 = v7;
        }
        CFRelease(v3);
        uint64_t v3 = v5;
      }
      CFRelease(v3);
    }
  }
  sCaptionInfoToPListableMappingDictionardouble y = (uint64_t)Mutable;
}

uint64_t fcs_setDictionaryFromPropertyCFType(__CFDictionary *a1, const void *a2, const void *a3)
{
  if (a1 && a2 && a3)
  {
    CFDictionarySetValue(a1, a2, a3);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t fcs_setDictionaryFromPropertyColor(__CFDictionary *a1, const void *a2, void *cf)
{
  if (a1 && a2 && cf && (CFTypeID v6 = CFGetTypeID(cf), v6 == CGColorGetTypeID()))
  {
    CFMutableArrayRef v7 = FigCopyCGColorSRGBAsArray(cf);
    if (v7)
    {
      CFMutableArrayRef v8 = v7;
      CFDictionarySetValue(a1, a2, v7);
      CFRelease(v8);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t fcs_setDictionaryFromPropertyFontFamily(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (!a2 || !a3)
    {
      uint64_t v16 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
      CFMutableArrayRef Mutable = 0;
      goto LABEL_13;
    }
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      uint64_t v18 = a1;
      CFIndex Count = FigCaptionFontFamilyNameListGetCount(a3);
      if (!Count)
      {
LABEL_12:
        CFDictionarySetValue(v18, a2, Mutable);
        uint64_t v16 = 0;
LABEL_13:
        if (cf) {
          CFRelease(cf);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        return v16;
      }
      CFIndex v9 = Count;
      CFIndex v10 = 0;
      uint64_t v11 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      CFDictionaryRef v12 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      while (1)
      {
        int v19 = 0;
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0;
        }
        uint64_t v13 = FigCaptionFontFamilyNameListCopyFamilyKindAndNameAtIndex(a3, v10, &v19, &cf);
        if (v13) {
          break;
        }
        CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(v6, 0, v11, v12);
        if (!v14) {
          goto LABEL_18;
        }
        CFMutableDictionaryRef v15 = v14;
        FigCFDictionarySetInt32(v14, @"FontFamilyKind", v19);
        FigCFDictionarySetValue(v15, @"FontFamilyName", cf);
        CFArrayAppendValue(Mutable, v15);
        CFRelease(v15);
        if (v9 == ++v10) {
          goto LABEL_12;
        }
      }
    }
    else
    {
LABEL_18:
      uint64_t v13 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v16 = v13;
    goto LABEL_13;
  }

  return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
}

uint64_t fcs_setDictionaryFromPropertyTextOutline(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  if (a1 && a2 && a3)
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableArrayRef v8 = Mutable;
      Color = (void *)FigCaptionTextOutlineGetColor(a3);
      CFMutableArrayRef v10 = FigCopyCGColorSRGBAsArray(Color);
      if (v10)
      {
        CFMutableArrayRef v11 = v10;
        uint64_t Thickness = FigCaptionTextOutlineGetThickness(a3);
        CFDictionaryRef v14 = FigGeometryDimensionCopyAsDictionary(Thickness, v13, v6);
        if (v14)
        {
          CFDictionaryRef v15 = v14;
          CFDictionarySetValue(v8, @"TextOutlineColor", v11);
          CFDictionarySetValue(v8, @"TextOutlineThickness", v15);
          CFDictionarySetValue(a1, a2, v8);
          CFRelease(v15);
        }
        CFRelease(v11);
      }
      CFRelease(v8);
      return 0;
    }
    uint64_t v17 = 4294949616;
  }
  else
  {
    uint64_t v17 = 4294949615;
  }

  return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
}

uint64_t fcs_setDictionaryFromPropertyTextEmphasis(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  if (a1 && a2 && cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == FigCaptionTextEmphasisGetTypeID())
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFMutableDictionaryRef v9 = Mutable;
        unsigned int EmphasisStyle = FigCaptionTextEmphasisGetEmphasisStyle((uint64_t)cf);
        if (EmphasisStyle > 3)
        {
          uint64_t v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_33:
          CFRelease(v9);
          return v16;
        }
        unsigned int v11 = EmphasisStyle;
        CFNumberRef UInt32 = FigCFNumberCreateUInt32(v7, EmphasisStyle);
        CFDictionarySetValue(v9, @"TextEmphasisStyle", UInt32);
        if (v11 == 2)
        {
          unsigned int MarkingStyle = FigCaptionTextEmphasisGetMarkingStyle((uint64_t)cf);
          PredefinedMaruint64_t k = FigCaptionTextEmphasisGetPredefinedMark((uint64_t)cf);
          CFNumberRef v14 = FigCFNumberCreateUInt32(v7, MarkingStyle);
          CFNumberRef v15 = FigCFNumberCreateUInt32(v7, PredefinedMark);
          if (v14) {
            CFDictionarySetValue(v9, @"TextEmphasisCustomMarkingStyle", v14);
          }
          if (v15) {
            CFDictionarySetValue(v9, @"TextEmphasisPredefinedMark", v15);
          }
        }
        else
        {
          if (v11 == 3)
          {
            CustomMaruint64_t k = (const void *)FigCaptionTextEmphasisGetCustomMark((uint64_t)cf);
            if (CustomMark) {
              CFDictionarySetValue(v9, @"TextEmphasisCustomMark", CustomMark);
            }
          }
          CFNumberRef v14 = 0;
          CFNumberRef v15 = 0;
        }
        Color = (void *)FigCaptionTextEmphasisGetColor((uint64_t)cf);
        if (Color)
        {
          CFMutableArrayRef v20 = FigCopyCGColorSRGBAsArray(Color);
          if (!v20)
          {
LABEL_24:
            if (UInt32) {
              CFRelease(UInt32);
            }
            if (v14) {
              CFRelease(v14);
            }
            if (v15) {
              CFRelease(v15);
            }
            if (v20) {
              CFRelease(v20);
            }
            uint64_t v16 = 0;
            goto LABEL_33;
          }
          CFDictionarySetValue(v9, @"TextEmphasisColor", v20);
        }
        else
        {
          CFMutableArrayRef v20 = 0;
        }
        RubyPosition = (const void *)FigCaptionTextEmphasisGetRubyPosition((uint64_t)cf);
        if (RubyPosition) {
          CFDictionarySetValue(v9, @"TextEmphasisRubyPosition", RubyPosition);
        }
        CFDictionarySetValue(a1, a2, v9);
        goto LABEL_24;
      }
    }
    uint64_t v23 = 4294949616;
  }
  else
  {
    uint64_t v23 = 4294949615;
  }

  return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
}

uint64_t fcs_setDictionaryFromPropertyTextShadow(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  if (!a1 || !a2 || !cf || (CFTypeID v6 = CFGetTypeID(cf), v6 != FigCaptionTextShadowListGetTypeID()))
  {
    uint64_t v35 = 4294949615;
LABEL_58:
    return FigSignalErrorAt(v35, 0, 0, 0, 0, 0, 0);
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!theDict)
  {
    uint64_t v35 = 4294949616;
    goto LABEL_58;
  }
  CFTypeRef v36 = a1;
  CFTypeRef v37 = a2;
  TextShadowArradouble y = (const __CFArray *)FigCaptionTextShadowListGetTextShadowArray((uint64_t)cf);
  CFMutableDictionaryRef v9 = 0;
  CFMutableArrayRef v10 = 0;
  CFDictionaryRef v11 = 0;
  CFDictionaryRef v12 = 0;
  CFDictionaryRef v13 = 0;
  CFMutableArrayRef v14 = 0;
  CFIndex v15 = 0;
  CFArrayRef v39 = TextShadowArray;
  if (!TextShadowArray) {
    goto LABEL_8;
  }
LABEL_7:
  for (CFIndex i = CFArrayGetCount(TextShadowArray); v15 < i; CFIndex i = 0)
  {
    if (v11) {
      CFRelease(v11);
    }
    if (v12) {
      CFRelease(v12);
    }
    if (v13) {
      CFRelease(v13);
    }
    if (v14) {
      CFRelease(v14);
    }
    ValueAtIndedouble x = CFArrayGetValueAtIndex(TextShadowArray, v15);
    if (!ValueAtIndex
      || (uint64_t v18 = (uint64_t)ValueAtIndex, v19 = CFGetTypeID(ValueAtIndex), v19 != FigCaptionTextShadowGetTypeID()))
    {
      uint64_t v33 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
      if (!v9) {
        goto LABEL_48;
      }
LABEL_47:
      CFRelease(v9);
      goto LABEL_48;
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable)
    {
      uint64_t v33 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      goto LABEL_48;
    }
    CFIndex v40 = v15;
    CFMutableDictionaryRef v9 = Mutable;
    uint64_t v21 = v10;
    uint64_t HorizontalAxisOffset = FigCaptionTextShadowGetHorizontalAxisOffset(v18);
    uint64_t v24 = v23;
    uint64_t VerticalAxisOffset = FigCaptionTextShadowGetVerticalAxisOffset(v18);
    uint64_t v27 = v26;
    uint64_t BlurRadius = FigCaptionTextShadowGetBlurRadius(v18);
    uint64_t v30 = v29;
    CFDictionaryRef v11 = FigGeometryDimensionCopyAsDictionary(HorizontalAxisOffset, v24, v7);
    CFDictionaryRef v12 = FigGeometryDimensionCopyAsDictionary(VerticalAxisOffset, v27, v7);
    CFDictionaryRef v13 = FigGeometryDimensionCopyAsDictionary(BlurRadius, v30, v7);
    if (v11) {
      CFDictionarySetValue(v9, @"TextShadowHorizontalAxisOffset", v11);
    }
    if (v12) {
      CFDictionarySetValue(v9, @"TextShadowVerticalAxisOffset", v12);
    }
    CFMutableArrayRef v10 = v21;
    TextShadowArradouble y = v39;
    if (v13) {
      CFDictionarySetValue(v9, @"TextShadowBlurRadius", v13);
    }
    Color = (void *)FigCaptionTextShadowGetColor(v18);
    if (Color)
    {
      CFMutableArrayRef v14 = FigCopyCGColorSRGBAsArray(Color);
      if (!v14) {
        goto LABEL_38;
      }
      CFDictionarySetValue(v9, @"TextShadowColor", v14);
      if (v21)
      {
LABEL_30:
        CFNumberRef v32 = v21;
        goto LABEL_33;
      }
    }
    else
    {
      CFMutableArrayRef v14 = 0;
      if (v21) {
        goto LABEL_30;
      }
    }
    CFNumberRef v32 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
    if (!v32)
    {
      uint64_t v33 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      if (!v11) {
        goto LABEL_40;
      }
LABEL_39:
      CFRelease(v11);
      goto LABEL_40;
    }
LABEL_33:
    CFArrayAppendValue(v32, v9);
    CFIndex v15 = v40 + 1;
    CFMutableArrayRef v10 = v32;
    if (v39) {
      goto LABEL_7;
    }
LABEL_8:
    ;
  }
  if (v10) {
    CFDictionarySetValue(theDict, @"TextShadowList", v10);
  }
  CFDictionarySetValue(v36, v37, theDict);
LABEL_38:
  uint64_t v33 = 0;
  if (v11) {
    goto LABEL_39;
  }
LABEL_40:
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v9) {
    goto LABEL_47;
  }
LABEL_48:
  if (v10) {
    CFRelease(v10);
  }
  return v33;
}

uint64_t fcs_setDictionaryFromPropertyRubyReserve(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  if (a1 && a2 && cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == FigCaptionRubyReserveGetTypeID())
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFMutableDictionaryRef v9 = Mutable;
        RubyPosition = (const void *)FigCaptionRubyReserveGetRubyPosition((uint64_t)cf);
        uint64_t Length = FigCaptionRubyReserveGetLength((uint64_t)cf);
        CFDictionaryRef v13 = FigGeometryDimensionCopyAsDictionary(Length, v12, v7);
        if (v13)
        {
          CFDictionaryRef v14 = v13;
          if (RubyPosition) {
            CFDictionarySetValue(v9, @"RubyReserveRubyPosition", RubyPosition);
          }
          CFDictionarySetValue(v9, @"RubyReserveLength", v14);
          CFDictionarySetValue(a1, a2, v9);
          CFRelease(v14);
          uint64_t v15 = 0;
        }
        else
        {
          uint64_t v15 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
        }
        CFRelease(v9);
        return v15;
      }
    }
    uint64_t v17 = 4294949616;
  }
  else
  {
    uint64_t v17 = 4294949615;
  }

  return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
}

uint64_t fcs_setDictionaryFromPropertyCaptionPosition(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  if (a1 && a2 && cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == FigCaptionRubyReserveGetTypeID())
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFMutableDictionaryRef v9 = Mutable;
        int HorizontalEdgeReference = FigCaptionPositionGetHorizontalEdgeReference((uint64_t)cf);
        int VerticalEdgeReference = FigCaptionPositionGetVerticalEdgeReference((uint64_t)cf);
        uint64_t HorizontalEdgeOffset = FigCaptionPositionGetHorizontalEdgeOffset((uint64_t)cf);
        uint64_t v14 = v13;
        uint64_t VerticalEdgeOffset = FigCaptionPositionGetVerticalEdgeOffset((uint64_t)cf);
        if (HorizontalEdgeReference <= 1818584691)
        {
          if (HorizontalEdgeReference == 1651471476)
          {
            char v30 = 0;
            uint64_t v17 = @"Bottom";
            goto LABEL_18;
          }
          if (HorizontalEdgeReference == 1667591796)
          {
            char v30 = 0;
            uint64_t v17 = @"Center";
            goto LABEL_18;
          }
        }
        else
        {
          switch(HorizontalEdgeReference)
          {
            case 1818584692:
              char v30 = 0;
              uint64_t v17 = @"Left";
              goto LABEL_18;
            case 1919510376:
              char v30 = 0;
              uint64_t v17 = @"Right";
              goto LABEL_18;
            case 1953460256:
              char v30 = 0;
              uint64_t v17 = @"Top";
              goto LABEL_18;
          }
        }
        uint64_t v17 = 0;
        char v30 = 1;
LABEL_18:
        if (VerticalEdgeReference <= 1818584691)
        {
          if (VerticalEdgeReference == 1651471476)
          {
            char v18 = 0;
            CFTypeID v19 = @"Bottom";
            goto LABEL_30;
          }
          if (VerticalEdgeReference == 1667591796)
          {
            char v18 = 0;
            CFTypeID v19 = @"Center";
            goto LABEL_30;
          }
        }
        else
        {
          switch(VerticalEdgeReference)
          {
            case 1818584692:
              char v18 = 0;
              CFTypeID v19 = @"Left";
              goto LABEL_30;
            case 1919510376:
              char v18 = 0;
              CFTypeID v19 = @"Right";
              goto LABEL_30;
            case 1953460256:
              char v18 = 0;
              CFTypeID v19 = @"Top";
              goto LABEL_30;
          }
        }
        CFTypeID v19 = 0;
        char v18 = 1;
LABEL_30:
        if ((v14 & 0x1D00000000) == 0x100000000)
        {
          CFMutableArrayRef v20 = v17;
          uint64_t v21 = VerticalEdgeOffset;
          uint64_t v22 = HorizontalEdgeOffset;
          uint64_t v23 = v16;
          CFDictionaryRef v24 = FigGeometryDimensionCopyAsDictionary(v22, v14, v7);
          uint64_t v16 = v23;
          CFDictionaryRef v25 = v24;
          uint64_t VerticalEdgeOffset = v21;
          uint64_t v17 = v20;
          if (!v25)
          {
            uint64_t v26 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_49:
            CFRelease(v9);
            return v26;
          }
        }
        else
        {
          CFDictionaryRef v25 = 0;
        }
        if ((v16 & 0x1D00000000) == 0x100000000)
        {
          CFDictionaryRef v27 = FigGeometryDimensionCopyAsDictionary(VerticalEdgeOffset, v16, v7);
          if (!v27)
          {
            uint64_t v26 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_45:
            if (v25) {
              CFRelease(v25);
            }
            if (v27) {
              CFRelease(v27);
            }
            goto LABEL_49;
          }
        }
        else
        {
          CFDictionaryRef v27 = 0;
        }
        if (v30)
        {
          if (v18) {
            goto LABEL_40;
          }
        }
        else
        {
          CFDictionarySetValue(v9, @"HorizontalEdge", v17);
          if (v18)
          {
LABEL_40:
            if (!v25)
            {
LABEL_42:
              if (v27) {
                CFDictionarySetValue(v9, @"VerticalOffset", v27);
              }
              CFDictionarySetValue(a1, a2, v9);
              uint64_t v26 = 0;
              goto LABEL_45;
            }
LABEL_41:
            CFDictionarySetValue(v9, @"HorizontalOffset", v25);
            goto LABEL_42;
          }
        }
        CFDictionarySetValue(v9, @"VerticalEdge", v19);
        if (!v25) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
    }
    uint64_t v29 = 4294949616;
  }
  else
  {
    uint64_t v29 = 4294949615;
  }

  return FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
}

void fcs_deserializeCaptionPropertyApplier(const void *a1, CFArrayRef theArray, uint64_t a3)
{
  CFTypeRef cf = 0;
  double v17 = 0.0;
  ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
  if (!CFEqual(a1, @"Region") && !CFEqual(a1, @"CMCaptionRegionContainerRegion"))
  {
    if (FigCFDictionaryGetDoubleIfPresent((uint64_t)ValueAtIndex, @"RelativeTime", &v17))
    {
      if (v17 < 0.0)
      {
        CFDictionaryRef Value = CFDictionaryGetValue(ValueAtIndex, @"PropertyValue");
        uint64_t v8 = *(void *)(a3 + 8);
        goto LABEL_5;
      }
      FigThreadRunOnce(&fcs_getPListableToCaptionInfoMappingDictionary_sInitializePListableToCaptionPropertyMappingOnce, fcs_initializePListableToCaptionPropertyMappingDictionary);
      CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sPListableToCaptionInfoMappingDictionary, @"CaptionProperty");
      if (v14)
      {
        int v7 = fcs_createDynamicStyleFromPListable(a1, theArray, v14, &cf);
        if (v7) {
          goto LABEL_11;
        }
        goto LABEL_4;
      }
      uint64_t v15 = 4294949616;
    }
    else
    {
      uint64_t v15 = 4294954513;
    }
    int v7 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  int v7 = fcs_deserializeAndSetRegionProperty(ValueAtIndex, &cf);
  if (v7) {
    goto LABEL_11;
  }
LABEL_4:
  uint64_t v8 = *(void *)(a3 + 8);
  CFDictionaryRef Value = cf;
LABEL_5:
  uint64_t CMBaseObject = FigCaptionDataGetCMBaseObject(v8);
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(uint64_t, const void *, const void *))(v12 + 56);
  if (v13) {
    int v7 = v13(CMBaseObject, a1, Value);
  }
  else {
    int v7 = -12782;
  }
LABEL_11:
  *(_DWORD *)a3 = v7;
  if (cf) {
    CFRelease(cf);
  }
}

void fcs_deserializeCaptionStyleApplier(__CFString *a1, CFArrayRef theArray, uint64_t a3)
{
  CFTypeRef v31 = 0;
  CFTypeRef cf = 0;
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count)
  {
    *(_DWORD *)a3 = 0;
    return;
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  while (1)
  {
    ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v8);
    CFDictionaryRef Value = CFDictionaryGetValue(ValueAtIndex, @"PropertyRange");
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    if (Value && (uint64_t v11 = (uint64_t)Value, v12 = CFGetTypeID(Value), v12 == CFDictionaryGetTypeID()))
    {
      if (FigCFDictionaryGetCFIndexIfPresent(v11, @"RangeLocation", &v33)) {
        FigCFDictionaryGetCFIndexIfPresent(v11, @"RangeLength", &v34);
      }
    }
    else
    {
      FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v14 = v33;
    uint64_t v13 = v34;
    CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, @"DynamicStyleValue");
    if (!CFEqual(a1, @"Ruby")) {
      break;
    }
    uint64_t v16 = (int *)a3;
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    double v17 = CFArrayGetValueAtIndex(v15, 0);
    int v18 = fcs_deserializeAndCreateFigCaptionData(v17, &cf);
    if (v18) {
      goto LABEL_32;
    }
    uint64_t v19 = *(void *)(a3 + 8);
    CFTypeRef v20 = cf;
    uint64_t v21 = *(void *)(CMBaseObjectGetVTable(v19) + 16);
    if (v21) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = 0;
    }
    CFDictionaryRef v27 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef, uint64_t, uint64_t))(v22 + 32);
    if (!v27)
    {
LABEL_30:
      int v18 = -12782;
      goto LABEL_31;
    }
    uint64_t v28 = v19;
    uint64_t v29 = @"Ruby";
LABEL_25:
    int v18 = v27(v28, v29, v20, v14, v13);
    if (v18) {
      goto LABEL_31;
    }
    if (v7 == ++v8)
    {
      int v18 = 0;
LABEL_31:
      uint64_t v16 = (int *)a3;
      goto LABEL_32;
    }
  }
  uint64_t v16 = (int *)a3;
  if (v31)
  {
    CFRelease(v31);
    CFTypeRef v31 = 0;
  }
  FigThreadRunOnce(&fcs_getPListableToCaptionInfoMappingDictionary_sInitializePListableToCaptionPropertyMappingOnce, fcs_initializePListableToCaptionPropertyMappingDictionary);
  CFDictionaryRef v23 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sPListableToCaptionInfoMappingDictionary, @"StyleProperty");
  if (v23)
  {
    int v18 = fcs_createDynamicStyleFromPListable(a1, v15, v23, &v31);
    if (v18) {
      goto LABEL_32;
    }
    uint64_t v24 = *(void *)(a3 + 8);
    CFTypeRef v20 = v31;
    uint64_t v25 = *(void *)(CMBaseObjectGetVTable(v24) + 16);
    if (v25) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = 0;
    }
    CFDictionaryRef v27 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef, uint64_t, uint64_t))(v26 + 32);
    if (!v27) {
      goto LABEL_30;
    }
    uint64_t v28 = v24;
    uint64_t v29 = a1;
    goto LABEL_25;
  }
  int v18 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_32:
  CFTypeRef v30 = cf;
  int *v16 = v18;
  if (v30) {
    CFRelease(v30);
  }
  if (v31) {
    CFRelease(v31);
  }
}

uint64_t fcs_deserializeAndSetRegionProperty(const __CFDictionary *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a1 && a2)
  {
    uint64_t v4 = FigCaptionRegionCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80], &cf);
    CFTypeRef v5 = cf;
    if (v4
      || (context[0] = 0,
          context[1] = cf,
          CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)fcs_deserializeRegionPropertyApplier, context),
          uint64_t v4 = LODWORD(context[0]),
          CFTypeRef v5 = cf,
          LODWORD(context[0])))
    {
      if (v5) {
        CFRelease(v5);
      }
    }
    else
    {
      *a2 = cf;
    }
    return v4;
  }
  else
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t fcs_createDynamicStyleFromPListable(const void *a1, CFArrayRef theArray, const __CFDictionary *a3, void *a4)
{
  double v19 = 0.0;
  CFTypeRef cf = 0;
  if (!a1 || !theArray || !a3 || !a4)
  {
    uint64_t v16 = 4294949615;
LABEL_14:
    uint64_t v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_15:
    uint64_t v17 = v14;
    if (cf) {
      CFRelease(cf);
    }
    return v17;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  CFDictionaryRef Value = (uint64_t (*)(const void *, CFTypeRef *, double))CFDictionaryGetValue(a3, a1);
  if (!Value)
  {
LABEL_13:
    uint64_t v16 = 4294954513;
    goto LABEL_14;
  }
  if (Count)
  {
    CFMutableArrayRef v10 = Value;
    CFIndex v11 = 0;
    while (1)
    {
      ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v11);
      if (!FigCFDictionaryGetDoubleIfPresent((uint64_t)ValueAtIndex, @"RelativeTime", &v19)) {
        goto LABEL_13;
      }
      uint64_t v13 = CFDictionaryGetValue(ValueAtIndex, @"PropertyValue");
      if (!v13) {
        goto LABEL_13;
      }
      uint64_t v14 = v10(v13, &cf, v19);
      if (v14) {
        goto LABEL_15;
      }
      if (Count == ++v11)
      {
        CFTypeRef v15 = cf;
        goto LABEL_18;
      }
    }
  }
  CFTypeRef v15 = 0;
LABEL_18:
  uint64_t v17 = 0;
  *a4 = v15;
  return v17;
}

void fcs_deserializeRegionPropertyApplier(const void *a1, const __CFArray *a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  double v19 = 0.0;
  CFTypeRef v17 = 0;
  FigThreadRunOnce(&fcs_getPListableToCaptionInfoMappingDictionary_sInitializePListableToCaptionPropertyMappingOnce, fcs_initializePListableToCaptionPropertyMappingDictionary);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sPListableToCaptionInfoMappingDictionary, @"RegionProperty");
  if (!Value)
  {
    uint64_t v16 = 4294949616;
    goto LABEL_23;
  }
  CFDictionaryRef v7 = Value;
  ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, 0);
  if (!CFEqual(a1, @"CMCaptionRegionContainerRegion"))
  {
    if (FigCFDictionaryGetDoubleIfPresent((uint64_t)ValueAtIndex, @"RelativeTime", &v19))
    {
      if (v19 >= 0.0)
      {
        int v9 = fcs_createDynamicStyleFromPListable(a1, a2, v7, &v17);
        if (v9) {
          goto LABEL_16;
        }
        uint64_t v10 = *(void *)(a3 + 8);
        CFTypeRef v11 = v17;
      }
      else
      {
        CFTypeRef v11 = CFDictionaryGetValue(ValueAtIndex, @"PropertyValue");
        uint64_t v10 = *(void *)(a3 + 8);
      }
      goto LABEL_10;
    }
    uint64_t v16 = 4294954513;
LABEL_23:
    int v9 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  int v9 = fcs_deserializeAndSetRegionProperty(ValueAtIndex, &cf);
  if (v9) {
    goto LABEL_16;
  }
  uint64_t v10 = *(void *)(a3 + 8);
  CFTypeRef v11 = cf;
LABEL_10:
  uint64_t CMBaseObject = FigCaptionRegionGetCMBaseObject(v10);
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  CFTypeRef v15 = *(uint64_t (**)(uint64_t, const void *, CFTypeRef))(v14 + 56);
  if (v15) {
    int v9 = v15(CMBaseObject, a1, v11);
  }
  else {
    int v9 = -12782;
  }
LABEL_16:
  *(_DWORD *)a3 = v9;
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    CFRelease(v17);
  }
}

void fcs_initializePListableToCaptionPropertyMappingDictionary()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFMutableDictionaryRef v2 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E4F1D530], 0);
    if (v2)
    {
      uint64_t v3 = v2;
      CFMutableDictionaryRef v4 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E4F1D530], 0);
      if (v4)
      {
        CFTypeRef v5 = v4;
        CFMutableDictionaryRef v6 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E4F1D530], 0);
        if (v6)
        {
          CFDictionaryRef v7 = v6;
          CFDictionaryAddValue(v3, @"Animation", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"TextAlign", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"MultiRowAlign", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"RubyAlign", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"RubyPosition", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionIdentifier", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionShowbackground", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionWritingMode", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionDisplayAlign", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionPadding", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionAnimation", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"FontWeight", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"FontStyle", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"Ruby", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"TextCombine", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"TextShear", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"EdgeStyle", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"LineHeight", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"LinePadding", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"SourceInformation", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionCellResolution", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionPosition", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionWidth", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionHeight", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionDisplayAspectRatio", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionActiveArea", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionAnchor", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"FontSize", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"LineHeight", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionStereoDisparity", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionZIndex", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionOpacity", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"Decoration", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionLuminanceGain", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"FillLineGap", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"Hidden", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionClipOverflow", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionInvisible", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionForcedDisplay", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionHidden", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, @"CMCaptionRegionExplicitRegion", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"Hidden", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"Invisible", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"ForcedDisplay", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"PreventLineWrapping", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, @"WritingDirection", fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, @"BackgroundColor", fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v5, @"CMCaptionRegionBackgroundColor", fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v7, @"TextColor", fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v7, @"BackgroundColor", fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v7, @"FontFamily", fcs_createDynamicStyleFromPListFontFamily);
          CFDictionaryAddValue(v7, @"TextOutline", fcs_createDynamicStyleFromPListTextOutline);
          CFDictionaryAddValue(v7, @"TextEmphasis", fcs_createDynamicStyleFromPListTextEmphasis);
          CFDictionaryAddValue(v7, @"TextShadow", fcs_createDynamicStyleFromPListTextShadow);
          CFDictionaryAddValue(v3, @"RubyReserve", fcs_createDynamicStyleFromPListRubyReserve);
          CFDictionaryAddValue(v5, @"CMCaptionRegionAbstractPosition", fcs_createDynamicStyleFromPListAbstractPosition);
          CFDictionaryAddValue(Mutable, @"CaptionProperty", v3);
          CFDictionaryAddValue(Mutable, @"RegionProperty", v5);
          CFDictionaryAddValue(Mutable, @"StyleProperty", v7);
          CFRelease(v3);
          uint64_t v3 = v5;
          CFTypeRef v5 = v7;
        }
        CFRelease(v3);
        uint64_t v3 = v5;
      }
      CFRelease(v3);
    }
  }
  sPListableToCaptionInfoMappingDictionardouble y = (uint64_t)Mutable;
}

uint64_t fcs_createDynamicStyleFromPListCFType(const void *a1, uint64_t *a2, double a3)
{
  if (!a1 || !a2) {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  if (*a2) {
    return FigCaptionDynamicStyleAddKeyFrameValue(*a2, a1, a3);
  }
  return FigCaptionDynamicStyleCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1, a2);
}

uint64_t fcs_createDynamicStyleFromPListColor(const void *a1, uint64_t *a2, double a3)
{
  if (a1 && a2)
  {
    CGColorSRGBFromArradouble y = FigCreateCGColorSRGBFromArray(a1);
    if (CGColorSRGBFromArray)
    {
      if (*a2) {
        uint64_t Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, CGColorSRGBFromArray, a3);
      }
      else {
        uint64_t Mutable = FigCaptionDynamicStyleCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80], CGColorSRGBFromArray, a2);
      }
      uint64_t v7 = Mutable;
    }
    else
    {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    CGColorSRGBFromArradouble y = 0;
  }
  CGColorRelease(CGColorSRGBFromArray);
  return v7;
}

uint64_t fcs_createDynamicStyleFromPListFontFamily(const __CFArray *a1, uint64_t *a2, double a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (a2)
    {
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t Mutable = FigCaptionFontFamilyNameListCreateMutable((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t *)&cf);
      if (!Mutable)
      {
        CFIndex Count = CFArrayGetCount(a1);
        if (Count)
        {
          CFIndex v9 = Count;
          CFIndex v10 = 0;
          while (1)
          {
            unsigned int v15 = 0;
            ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v10);
            if (!FigCFDictionaryGetInt32IfPresent((uint64_t)ValueAtIndex, @"FontFamilyKind", &v15)) {
              break;
            }
            CFDictionaryRef Value = CFDictionaryGetValue(ValueAtIndex, @"FontFamilyName");
            if (!Value) {
              break;
            }
            uint64_t Mutable = FigCaptionFontFamilyNameListAppend((uint64_t)cf, v15, Value);
            if (Mutable) {
              goto LABEL_13;
            }
            if (v9 == ++v10) {
              goto LABEL_10;
            }
          }
          uint64_t v13 = 0;
          goto LABEL_14;
        }
LABEL_10:
        if (*a2) {
          uint64_t Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
        }
        else {
          uint64_t Mutable = FigCaptionDynamicStyleCreateMutable(v6, cf, a2);
        }
      }
    }
    else
    {
      uint64_t Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    }
LABEL_13:
    uint64_t v13 = Mutable;
LABEL_14:
    if (cf) {
      CFRelease(cf);
    }
    return v13;
  }

  return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
}

uint64_t fcs_createDynamicStyleFromPListTextOutline(CFDictionaryRef theDict, uint64_t *a2, double a3)
{
  CGColorSRGBFromArradouble y = theDict;
  CFTypeRef cf = 0;
  if (!theDict)
  {
    uint64_t Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
LABEL_8:
    uint64_t v12 = Mutable;
    goto LABEL_9;
  }
  if (a2)
  {
    CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"TextOutlineColor");
    uint64_t v7 = CFDictionaryGetValue(CGColorSRGBFromArray, @"TextOutlineThickness");
    CGColorSRGBFromArradouble y = FigCreateCGColorSRGBFromArray(Value);
    if (CGColorSRGBFromArray)
    {
      CFIndex v8 = FigGeometryDimensionMakeFromDictionary(v7);
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t Mutable = FigCaptionTextOutlineCreate(*MEMORY[0x1E4F1CF80], (uint64_t)v8, v10, CGColorSRGBFromArray, &cf);
      if (!Mutable)
      {
        if (*a2) {
          uint64_t Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
        }
        else {
          uint64_t Mutable = FigCaptionDynamicStyleCreateMutable(v9, cf, a2);
        }
      }
      goto LABEL_8;
    }
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    CGColorSRGBFromArradouble y = 0;
  }
LABEL_9:
  CGColorRelease(CGColorSRGBFromArray);
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

uint64_t fcs_createDynamicStyleFromPListTextEmphasis(CFDictionaryRef theDict, uint64_t *a2, double a3)
{
  CGColorSRGBFromArradouble y = theDict;
  CFTypeRef cf = 0;
  if (!theDict)
  {
    uint64_t Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
LABEL_16:
    uint64_t v15 = Mutable;
    goto LABEL_17;
  }
  if (a2)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"TextEmphasisStyle");
    int valuePtr = 0;
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    int v7 = valuePtr;
    if (valuePtr == 2)
    {
      CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(CGColorSRGBFromArray, @"TextEmphasisCustomMarkingStyle");
      CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(CGColorSRGBFromArray, @"TextEmphasisPredefinedMark");
      int v20 = 0;
      CFNumberGetValue(v11, kCFNumberSInt32Type, &v20);
      int v9 = v20;
      int v19 = 0;
      CFNumberGetValue(v12, kCFNumberSInt32Type, &v19);
      CFIndex v8 = 0;
      int v10 = v19;
    }
    else if (valuePtr == 3)
    {
      CFIndex v8 = CFDictionaryGetValue(CGColorSRGBFromArray, @"TextEmphasisCustomMark");
      int v9 = 0;
      int v10 = 0;
    }
    else
    {
      int v9 = 0;
      int v10 = 0;
      CFIndex v8 = 0;
    }
    uint64_t v13 = CFDictionaryGetValue(CGColorSRGBFromArray, @"TextEmphasisColor");
    uint64_t v14 = CFDictionaryGetValue(CGColorSRGBFromArray, @"TextEmphasisRubyPosition");
    if (v13)
    {
      CGColorSRGBFromArradouble y = FigCreateCGColorSRGBFromArray(v13);
      if (!CGColorSRGBFromArray)
      {
        uint64_t v15 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      CGColorSRGBFromArradouble y = 0;
    }
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t Mutable = FigCaptionTextEmphasisCreate(*MEMORY[0x1E4F1CF80], v7, v9, v10, v8, CGColorSRGBFromArray, v14, &cf);
    if (!Mutable)
    {
      if (*a2) {
        uint64_t Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
      }
      else {
        uint64_t Mutable = FigCaptionDynamicStyleCreateMutable(v16, cf, a2);
      }
    }
    goto LABEL_16;
  }
  uint64_t v15 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  CGColorSRGBFromArradouble y = 0;
LABEL_17:
  CGColorRelease(CGColorSRGBFromArray);
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

uint64_t fcs_createDynamicStyleFromPListTextShadow(const void *a1, uint64_t *a2, double a3)
{
  CFTypeRef v36 = 0;
  CFTypeRef v37 = 0;
  if (!a1 || !a2)
  {
    uint64_t v29 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    CFArrayRef Mutable = 0;
LABEL_45:
    CGColorSRGBFromArradouble y = 0;
    goto LABEL_31;
  }
  CFAllocatorRef v34 = CFGetAllocator(a1);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, @"TextShadowList");
  CFNumberRef v32 = a2;
  if (Value)
  {
    CFArrayRef v6 = Value;
    if (CFArrayGetCount(Value) >= 1)
    {
      CGColorSRGBFromArradouble y = 0;
      CFIndex v8 = 0;
      CFArrayRef Mutable = 0;
      while (1)
      {
        if (v36)
        {
          CFRelease(v36);
          CFTypeRef v36 = 0;
        }
        if (CGColorSRGBFromArray) {
          CFRelease(CGColorSRGBFromArray);
        }
        ValueAtIndedouble x = (void *)CFArrayGetValueAtIndex(v6, v8);
        CGColorSRGBFromArradouble y = ValueAtIndex;
        if (!ValueAtIndex)
        {
          uint64_t v28 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
          goto LABEL_30;
        }
        CFTypeID v11 = CFGetTypeID(ValueAtIndex);
        if (v11 != CFDictionaryGetTypeID())
        {
          uint64_t v31 = 0xFFFFFFFFLL;
          goto LABEL_44;
        }
        CFNumberRef v12 = CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, @"TextShadowHorizontalAxisOffset");
        uint64_t v13 = CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, @"TextShadowVerticalAxisOffset");
        uint64_t v14 = CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, @"TextShadowBlurRadius");
        CGColorSRGBFromArradouble y = (void *)CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, @"TextShadowColor");
        if (!Mutable)
        {
          CFAllocatorRef v15 = CFGetAllocator(a1);
          CFArrayRef Mutable = CFArrayCreateMutable(v15, 0, MEMORY[0x1E4F1D510]);
          if (!Mutable) {
            break;
          }
        }
        theArradouble y = Mutable;
        uint64_t v17 = 0x100000000;
        CFAllocatorRef v16 = 0;
        if (v12)
        {
          CFAllocatorRef v16 = FigGeometryDimensionMakeFromDictionary(v12);
          uint64_t v17 = v18;
        }
        CFArrayRef v19 = v6;
        uint64_t v21 = 0x100000000;
        int v20 = 0;
        if (v13)
        {
          int v20 = FigGeometryDimensionMakeFromDictionary(v13);
          uint64_t v21 = v22;
        }
        uint64_t v23 = 0x100000000;
        uint64_t v24 = 0;
        if (v14)
        {
          uint64_t v24 = FigGeometryDimensionMakeFromDictionary(v14);
          uint64_t v23 = v25;
        }
        if (CGColorSRGBFromArray)
        {
          CGColorSRGBFromArradouble y = FigCreateCGColorSRGBFromArray(CGColorSRGBFromArray);
          if (!CGColorSRGBFromArray)
          {
            uint64_t v29 = 0;
            goto LABEL_42;
          }
        }
        uint64_t v26 = FigCaptionTextShadowCreate((uint64_t)v34, (uint64_t)v16, v17, (uint64_t)v20, v21, (uint64_t)v24, v23, (CGColor *)CGColorSRGBFromArray, &v36);
        if (v26)
        {
          uint64_t v29 = v26;
LABEL_42:
          CFArrayRef Mutable = theArray;
          goto LABEL_31;
        }
        CFArrayRef Mutable = theArray;
        CFArrayAppendValue(theArray, v36);
        ++v8;
        CFArrayRef v6 = v19;
        if (v8 >= CFArrayGetCount(v19)) {
          goto LABEL_26;
        }
      }
      uint64_t v31 = 4294949616;
LABEL_44:
      uint64_t v29 = FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
      goto LABEL_45;
    }
  }
  CFArrayRef Mutable = 0;
  CGColorSRGBFromArradouble y = 0;
LABEL_26:
  CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v28 = FigCaptionTextShadowListCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], Mutable, (uint64_t *)&v37);
  if (!v28)
  {
    if (*v32) {
      uint64_t v28 = FigCaptionDynamicStyleAddKeyFrameValue(*v32, v37, a3);
    }
    else {
      uint64_t v28 = FigCaptionDynamicStyleCreateMutable(v27, v37, v32);
    }
  }
LABEL_30:
  uint64_t v29 = v28;
LABEL_31:
  CGColorRelease((CGColorRef)CGColorSRGBFromArray);
  if (v36) {
    CFRelease(v36);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v37) {
    CFRelease(v37);
  }
  return v29;
}

uint64_t fcs_createDynamicStyleFromPListRubyReserve(const __CFDictionary *a1, uint64_t *a2, double a3)
{
  CFTypeRef cf = 0;
  if (a1 && a2)
  {
    CFArrayRef Value = CFDictionaryGetValue(a1, @"RubyReserveRubyPosition");
    int v7 = CFDictionaryGetValue(a1, @"RubyReserveLength");
    if (v7)
    {
      CFIndex v8 = FigGeometryDimensionMakeFromDictionary(v7);
      uint64_t v10 = v9;
    }
    else
    {
      CFIndex v8 = 0;
      uint64_t v10 = 0;
    }
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t Mutable = FigCaptionRubyReserveCreate(*MEMORY[0x1E4F1CF80], Value, (uint64_t)v8, v10, &cf);
    if (!Mutable)
    {
      if (*a2) {
        uint64_t Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
      }
      else {
        uint64_t Mutable = FigCaptionDynamicStyleCreateMutable(v11, cf, a2);
      }
    }
  }
  else
  {
    uint64_t Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v13 = Mutable;
  if (cf) {
    CFRelease(cf);
  }
  return v13;
}

uint64_t fcs_createDynamicStyleFromPListAbstractPosition(const __CFDictionary *a1, uint64_t *a2, double a3)
{
  CFTypeRef cf = 0;
  if (a1 && a2)
  {
    CFArrayRef Value = CFDictionaryGetValue(a1, @"HorizontalEdge");
    int v7 = CFDictionaryGetValue(a1, @"VerticalEdge");
    CFIndex v8 = CFDictionaryGetValue(a1, @"HorizontalOffset");
    uint64_t v9 = CFDictionaryGetValue(a1, @"VerticalOffset");
    if (Value) {
      CaptionPositionEdgeReferenceForEdgeReferenceSerializedCFArrayRef Value = fcs_getCaptionPositionEdgeReferenceForEdgeReferenceSerializedValue(Value);
    }
    else {
      CaptionPositionEdgeReferenceForEdgeReferenceSerializedCFArrayRef Value = 0;
    }
    CFAllocatorRef v11 = 0;
    uint64_t v12 = 0;
    if (v7) {
      LODWORD(v7) = fcs_getCaptionPositionEdgeReferenceForEdgeReferenceSerializedValue(v7);
    }
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    if (v8)
    {
      uint64_t v14 = FigGeometryDimensionMakeFromDictionary(v8);
      uint64_t v13 = v15;
    }
    if (v9)
    {
      CFAllocatorRef v11 = FigGeometryDimensionMakeFromDictionary(v9);
      uint64_t v12 = v16;
    }
    CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t Mutable = FigCaptionPositionCreate(*MEMORY[0x1E4F1CF80], CaptionPositionEdgeReferenceForEdgeReferenceSerializedValue, (uint64_t)v14, v13, (int)v7, (uint64_t)v11, v12, (uint64_t *)&cf);
    if (!Mutable)
    {
      if (*a2) {
        uint64_t Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
      }
      else {
        uint64_t Mutable = FigCaptionDynamicStyleCreateMutable(v17, cf, a2);
      }
    }
  }
  else
  {
    uint64_t Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v19 = Mutable;
  if (cf) {
    CFRelease(cf);
  }
  return v19;
}

uint64_t fcs_getCaptionPositionEdgeReferenceForEdgeReferenceSerializedValue(const void *a1)
{
  if (CFEqual(a1, @"Bottom")) {
    return 1651471476;
  }
  if (CFEqual(a1, @"Center")) {
    return 1667591796;
  }
  if (CFEqual(a1, @"Left")) {
    return 1818584692;
  }
  if (CFEqual(a1, @"Right")) {
    return 1919510376;
  }
  if (CFEqual(a1, @"Top")) {
    return 1953460256;
  }
  return 0;
}

uint64_t FigCPECryptorStartServer()
{
  uint64_t v3 = 0;
  CFMutableDictionaryRef v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigCPECryptorStartServer_block_invoke;
  block[3] = &unk_1E567DEC0;
  void block[4] = &v3;
  if (FigCPECryptorStartServer_sFigCPECryptorServerSetupOnce != -1) {
    dispatch_once(&FigCPECryptorStartServer_sFigCPECryptorServerSetupOnce, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t __FigCPECryptorStartServer_block_invoke(uint64_t a1)
{
  v4[0] = 2;
  v4[1] = cryptorServer_HandleRemoteSyncMessage;
  v4[2] = cryptorServer_HandleRemoteAsyncMessage;
  v4[3] = 0;
  v4[4] = cryptorServer_NoteEnqueueDecisionFunction;
  v4[5] = 0;
  if (FigServer_IsMediaparserd())
  {
    uint64_t result = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    if (FigServer_IsMediaplaybackd()) {
      uint64_t v3 = "com.apple.coremedia.mediaplaybackd.figcpecryptor.xpc";
    }
    else {
      uint64_t v3 = "com.apple.coremedia.figcpecryptor";
    }
    uint64_t result = FigXPCServerStart((uint64_t)v3, v4, 0, &gFigCPECryptorServer);
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t cryptorServer_HandleRemoteSyncMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  v109[16] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  int v102 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v102);
  if (OpCode) {
    return OpCode;
  }
  uint64_t v7 = 4294951138;
  if (v102 <= 1768125048)
  {
    if (v102 <= 1667981679)
    {
      if (v102 == 778268793)
      {
        v109[0] = 0;
        uint64_t v75 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, v109);
        CFTypeRef v76 = v109[0];
        if (!v75) {
          uint64_t v75 = FigXPCHandleStdCopyPropertyMessage((uint64_t)v109[0], a2, a3);
        }
        uint64_t v7 = v75;
        if (!v76) {
          return v7;
        }
        CFTypeRef v77 = v76;
LABEL_190:
        CFRelease(v77);
        return v7;
      }
      if (v102 == 779314548)
      {
        v109[0] = 0;
        uint64_t v58 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, v109);
        CFTypeRef v59 = v109[0];
        if (!v58) {
          uint64_t v58 = FigXPCHandleStdSetPropertyMessage((uint64_t)v109[0], a2);
        }
        uint64_t v7 = v58;
        if (!v59) {
          return v7;
        }
LABEL_179:
        CFTypeRef v77 = v59;
        goto LABEL_190;
      }
      if (v102 != 1634431587) {
        return v7;
      }
      v109[0] = 0;
      *(void *)CFTypeRef cf = 0;
      uint64_t v17 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, v109);
      if (v17) {
        goto LABEL_126;
      }
      uint64_t int64 = xpc_dictionary_get_uint64(a2, "FromCryptorID");
      uint64_t v17 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, cf, 0);
      if (v17) {
        goto LABEL_126;
      }
      if (*(void *)cf)
      {
        CFTypeID v23 = CFGetTypeID(*(CFTypeRef *)cf);
        if (v23 == FigCPECryptorGetTypeID())
        {
          CFTypeRef v24 = v109[0];
          uint64_t v25 = *(void *)cf;
          uint64_t v26 = *(void **)(CMBaseObjectGetVTable((uint64_t)v109[0]) + 16);
          if (v26) {
            CFAllocatorRef v27 = v26;
          }
          else {
            CFAllocatorRef v27 = 0;
          }
          if (*v27 >= 6uLL)
          {
            CFTypeRef v94 = (uint64_t (*)(CFTypeRef, uint64_t))v27[22];
            if (v94)
            {
              uint64_t v17 = v94(v24, v25);
              goto LABEL_126;
            }
          }
          goto LABEL_160;
        }
        uint64_t v101 = 4294949726;
      }
      else
      {
        uint64_t v101 = 4294951144;
      }
      uint64_t v17 = FigSignalErrorAt(v101, 0, 0, 0, 0, 0, 0);
      goto LABEL_126;
    }
    if (v102 <= 1668310629)
    {
      if (v102 != 1667981680)
      {
        if (v102 != 1667982713) {
          return v7;
        }
        v109[0] = 0;
        *(void *)CFTypeRef cf = 0;
        CFTypeRef v104 = 0;
        uint64_t v12 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v104);
        if (v12) {
          goto LABEL_148;
        }
        uint64_t v12 = FigXPCMessageCopyCFDictionary(a2, "KeyRequestData", v109);
        if (v12) {
          goto LABEL_148;
        }
        CFTypeRef v13 = v104;
        CFTypeRef v14 = v109[0];
        uint64_t v15 = *(void **)(CMBaseObjectGetVTable((uint64_t)v104) + 16);
        if (v15) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = 0;
        }
        if (*v16 >= 4uLL)
        {
          float v84 = (uint64_t (*)(CFTypeRef, CFTypeRef, void, unsigned char *))v16[11];
          if (v84)
          {
            uint64_t v12 = v84(v13, v14, *MEMORY[0x1E4F1CF80], cf);
            if (!v12) {
              uint64_t v12 = FigXPCMessageSetCFData(a3, "SPCBytes", *(CFTypeRef *)cf);
            }
            goto LABEL_148;
          }
        }
        goto LABEL_149;
      }
      v109[0] = 0;
      *(void *)CFTypeRef cf = 0;
      CFTypeRef v104 = 0;
      uint64_t v46 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)cf);
      if (v46
        || (uint64_t v47 = xpc_dictionary_get_uint64(a2, "SessionID"),
            uint64_t v46 = FigXPCMessageCopyCFData(a2, "ReceiverContext", &v104),
            v46))
      {
        uint64_t v7 = v46;
      }
      else
      {
        uint64_t v48 = *(void *)cf;
        CFTypeRef v49 = v104;
        int v50 = *(void **)(CMBaseObjectGetVTable(*(uint64_t *)cf) + 16);
        if (v50) {
          CFIndex v51 = v50;
        }
        else {
          CFIndex v51 = 0;
        }
        if (*v51 >= 8uLL && (CFTypeRef v87 = (uint64_t (*)(uint64_t, uint64_t, CFTypeRef, CFTypeRef *))v51[27]) != 0)
        {
          uint64_t v88 = v87(v48, v47, v49, v109);
          CFTypeRef v89 = v109[0];
          if (!v88)
          {
            uint64_t v7 = FigXPCMessageSetCFData(a3, "KeyRequestResponse", v109[0]);
            CFTypeRef v89 = v109[0];
            if (!v109[0]) {
              goto LABEL_117;
            }
            goto LABEL_115;
          }
          uint64_t v7 = v88;
          if (v109[0]) {
LABEL_115:
          }
            CFRelease(v89);
        }
        else
        {
          uint64_t v7 = 4294954514;
        }
      }
LABEL_117:
      CFTypeRef v90 = v104;
      if (!v104)
      {
LABEL_163:
        CFTypeRef v77 = *(CFTypeRef *)cf;
        if (!*(void *)cf) {
          return v7;
        }
        goto LABEL_190;
      }
LABEL_162:
      CFRelease(v90);
      goto LABEL_163;
    }
    if (v102 != 1668310630)
    {
      if (v102 != 1684632432) {
        return v7;
      }
      uint64_t v28 = xpc_dictionary_get_uint64(a2, ".objectID");
      if (!v28) {
        return 4294949726;
      }
      uint64_t v29 = v28;
      if (dword_1E9272FD8)
      {
        LODWORD(v104) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FD0, 1, (int *)&v104, type);
        unsigned int v31 = v104;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
          unsigned int v33 = v31;
        }
        else {
          unsigned int v33 = v31 & 0xFFFFFFFE;
        }
        if (v33)
        {
          *(_DWORD *)CFTypeRef cf = 136315138;
          *(void *)&cf[4] = "cryptorServer_Dispose";
          CFAllocatorRef v34 = (CFTypeRef *)_os_log_send_and_compose_impl();
          LOBYTE(v31) = (_BYTE)v104;
        }
        else
        {
          CFAllocatorRef v34 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FD0, 1u, 1, v34, v34 != v109, v31, 0, v32);
      }
      return FigXPCServerDisassociateObjectWithConnection(a1, v29);
    }
    v109[0] = 0;
    *(void *)CFTypeRef cf = 0;
    CFTypeRef v104 = 0;
    uint64_t v52 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v104);
    if (!v52)
    {
      uint64_t v52 = FigXPCMessageCopyCFString(a2, ".PropertyName", v109);
      if (!v52)
      {
        if (v109[0])
        {
          uint64_t UInt32 = FigXPCMessageGetUInt32(a2, "Format");
          CFTypeRef v54 = v104;
          CFTypeRef v55 = v109[0];
          uint64_t v56 = *(void **)(CMBaseObjectGetVTable((uint64_t)v104) + 16);
          if (v56) {
            double v57 = v56;
          }
          else {
            double v57 = 0;
          }
          if (*v57 < 6uLL
            || (uint64_t v92 = (uint64_t (*)(CFTypeRef, CFTypeRef, uint64_t, void, unsigned char *))v57[19]) == 0)
          {
            uint64_t v7 = 4294954514;
LABEL_138:
            if (v104) {
              CFRelease(v104);
            }
            if (*(void *)cf) {
              CFRelease(*(CFTypeRef *)cf);
            }
            CFTypeRef v77 = v109[0];
            if (v109[0]) {
              goto LABEL_190;
            }
            return v7;
          }
          uint64_t v52 = v92(v54, v55, UInt32, *MEMORY[0x1E4F1CF80], cf);
          if (!v52) {
            uint64_t v52 = FigXPCMessageSetCFObject(a3, ".Value", *(CFTypeRef *)cf);
          }
        }
        else
        {
          uint64_t v52 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
        }
      }
    }
    uint64_t v7 = v52;
    goto LABEL_138;
  }
  if (v102 <= 1936418168)
  {
    if (v102 <= 1936092531)
    {
      if (v102 != 1768125049)
      {
        if (v102 != 1853058420) {
          return v7;
        }
        v109[0] = 0;
        *(void *)CFTypeRef cf = 0;
        LODWORD(v104) = 0;
        *(_DWORD *)os_log_type_t type = 0;
        uint64_t v8 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, v109);
        CFTypeRef v9 = v109[0];
        if (!v8)
        {
          uint64_t v10 = *(void *)(CMBaseObjectGetVTable((uint64_t)v109[0]) + 16);
          if (v10) {
            uint64_t v11 = v10;
          }
          else {
            uint64_t v11 = 0;
          }
          CMItemCount v78 = *(uint64_t (**)(CFTypeRef, unsigned char *))(v11 + 8);
          if (!v78) {
            goto LABEL_187;
          }
          uint64_t v8 = v78(v9, cf);
          if (!v8)
          {
            uint64_t v79 = *(void *)(CMBaseObjectGetVTable((uint64_t)v9) + 16);
            if (v79) {
              uint64_t v80 = v79;
            }
            else {
              uint64_t v80 = 0;
            }
            uint64_t v98 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(v80 + 16);
            if (v98)
            {
              uint64_t v8 = v98(v9, &v104);
              if (!v8)
              {
                uint64_t v99 = *(uint64_t (**)(CFTypeRef, os_log_type_t *))(*(void *)(CMBaseObjectGetVTable((uint64_t)v9)
                                                                                       + 16)
                                                                           + 280);
                if (v99)
                {
                  uint64_t v7 = v99(v9, type);
                  if (v7) {
                    goto LABEL_188;
                  }
                  xpc_dictionary_set_uint64(a3, "NativeSession", *(uint64_t *)cf);
                  xpc_dictionary_set_uint64(a3, "ExternalProtectionMethods", v104);
                  uint64_t v82 = *(int *)type;
                  CMItemCount v83 = "CryptorType";
                  goto LABEL_186;
                }
                goto LABEL_187;
              }
              goto LABEL_193;
            }
LABEL_187:
            uint64_t v7 = 4294954514;
            goto LABEL_188;
          }
        }
LABEL_193:
        uint64_t v7 = v8;
        goto LABEL_188;
      }
      CFTypeRef v104 = 0;
      uint64_t v60 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v104);
      if (v60)
      {
        uint64_t v7 = v60;
        CFTypeRef v59 = v104;
        if (!v104) {
          return v7;
        }
      }
      else
      {
        if (dword_1E9272FD8)
        {
          *(_DWORD *)os_log_type_t type = 0;
          os_log_type_t v103 = OS_LOG_TYPE_DEFAULT;
          CFDictionaryRef v61 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FD0, 1, (int *)type, &v103);
          unsigned int v62 = *(_DWORD *)type;
          if (os_log_type_enabled(v61, v103)) {
            unsigned int v64 = v62;
          }
          else {
            unsigned int v64 = v62 & 0xFFFFFFFE;
          }
          if (v64)
          {
            *(_DWORD *)CFTypeRef cf = 136315394;
            *(void *)&cf[4] = "cryptorServer_Invalidate";
            __int16 v107 = 2048;
            CFTypeRef v108 = v104;
            CFIndex v65 = (CFTypeRef *)_os_log_send_and_compose_impl();
            LOBYTE(v62) = type[0];
          }
          else
          {
            CFIndex v65 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FD0, 1u, 1, v65, v65 != v109, v62, 0, v63);
        }
        CFTypeRef v59 = v104;
        if (!v104) {
          return 4294954516;
        }
        uint64_t v95 = *(void *)(CMBaseObjectGetVTable((uint64_t)v104) + 8);
        if (v95) {
          uint64_t v96 = v95;
        }
        else {
          uint64_t v96 = 0;
        }
        int v97 = *(uint64_t (**)(CFTypeRef))(v96 + 24);
        if (v97) {
          uint64_t v7 = v97(v59);
        }
        else {
          uint64_t v7 = 4294954514;
        }
      }
      goto LABEL_179;
    }
    if (v102 != 1936092532)
    {
      if (v102 != 1936417136) {
        return v7;
      }
      v109[0] = 0;
      *(void *)CFTypeRef cf = 0;
      CFTypeRef v104 = 0;
      uint64_t v12 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v104);
      if (v12) {
        goto LABEL_148;
      }
      uint64_t v35 = xpc_dictionary_get_uint64(a2, "SessionID");
      uint64_t v12 = FigXPCMessageCopyCFData(a2, "KeyRequestResponse", v109);
      if (v12) {
        goto LABEL_148;
      }
      uint64_t v12 = FigXPCMessageCopyCFDictionary(a2, "KeyResponseOptionsDictionary", cf);
      if (v12) {
        goto LABEL_148;
      }
      CFTypeRef v36 = v104;
      CFTypeRef v37 = v109[0];
      uint64_t v38 = *(void *)cf;
      CFArrayRef v39 = *(void **)(CMBaseObjectGetVTable((uint64_t)v104) + 16);
      if (v39) {
        CFIndex v40 = v39;
      }
      else {
        CFIndex v40 = 0;
      }
      if (*v40 >= 8uLL)
      {
        uint64_t v91 = (uint64_t (*)(CFTypeRef, uint64_t, CFTypeRef, uint64_t))v40[28];
        if (v91)
        {
          uint64_t v12 = v91(v36, v35, v37, v38);
LABEL_148:
          uint64_t v7 = v12;
          goto LABEL_150;
        }
      }
      goto LABEL_149;
    }
    v109[0] = 0;
    *(void *)CFTypeRef cf = 0;
    uint64_t v17 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)cf);
    if (v17) {
      goto LABEL_126;
    }
    uint64_t v17 = FigXPCMessageCopyFormatDescription(a2, "FormatDescription", v109);
    if (v17) {
      goto LABEL_126;
    }
    uint64_t v18 = *(void *)cf;
    CFTypeRef v19 = v109[0];
    uint64_t v71 = *(void *)(CMBaseObjectGetVTable(*(uint64_t *)cf) + 8);
    if (v71) {
      uint64_t v72 = v71;
    }
    else {
      uint64_t v72 = 0;
    }
    CMSampleTimingInfo v85 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef))(v72 + 56);
    if (v85)
    {
      __int16 v86 = kFigCPEBasicAESCryptorProperty_VideoFormatDescription;
      goto LABEL_125;
    }
    goto LABEL_160;
  }
  if (v102 <= 1936941411)
  {
    if (v102 == 1936418169)
    {
      v109[0] = 0;
      *(void *)CFTypeRef cf = 0;
      CFTypeRef v104 = 0;
      uint64_t v12 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v104);
      if (v12) {
        goto LABEL_148;
      }
      uint64_t v12 = FigXPCMessageCopyCFData(a2, "KeyRequestResponse", cf);
      if (v12) {
        goto LABEL_148;
      }
      uint64_t v12 = FigXPCMessageCopyCFDictionary(a2, "KeyResponseOptionsDictionary", v109);
      if (v12) {
        goto LABEL_148;
      }
      CFTypeRef v66 = v104;
      uint64_t v67 = *(void *)cf;
      CFTypeRef v68 = v109[0];
      CFTypeID v69 = *(void **)(CMBaseObjectGetVTable((uint64_t)v104) + 16);
      if (v69) {
        CFTypeRef v70 = v69;
      }
      else {
        CFTypeRef v70 = 0;
      }
      if (*v70 >= 4uLL)
      {
        int v93 = (uint64_t (*)(CFTypeRef, uint64_t, CFTypeRef))v70[12];
        if (v93)
        {
          uint64_t v12 = v93(v66, v67, v68);
          goto LABEL_148;
        }
      }
LABEL_149:
      uint64_t v7 = 4294954514;
LABEL_150:
      if (v109[0]) {
        CFRelease(v109[0]);
      }
      if (*(void *)cf) {
        CFRelease(*(CFTypeRef *)cf);
      }
      CFTypeRef v77 = v104;
      if (v104) {
        goto LABEL_190;
      }
      return v7;
    }
    if (v102 != 1936421490) {
      return v7;
    }
    v109[0] = 0;
    *(void *)CFTypeRef cf = 0;
    uint64_t v17 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)cf);
    if (v17) {
      goto LABEL_126;
    }
    uint64_t v17 = FigXPCMessageCopyCFError(a2, "KeyRequestError", (const __CFDictionary **)v109);
    if (v17) {
      goto LABEL_126;
    }
    uint64_t v18 = *(void *)cf;
    CFTypeRef v19 = v109[0];
    uint64_t v20 = *(void *)(CMBaseObjectGetVTable(*(uint64_t *)cf) + 8);
    if (v20) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = 0;
    }
    CMSampleTimingInfo v85 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef))(v21 + 56);
    if (v85)
    {
      __int16 v86 = kFigCPECryptorProperty_KeyRequestError;
LABEL_125:
      uint64_t v17 = v85(v18, *v86, v19);
LABEL_126:
      uint64_t v7 = v17;
      goto LABEL_161;
    }
LABEL_160:
    uint64_t v7 = 4294954514;
LABEL_161:
    CFTypeRef v90 = v109[0];
    if (!v109[0]) {
      goto LABEL_163;
    }
    goto LABEL_162;
  }
  if (v102 == 1936941412)
  {
    v109[0] = 0;
    *(void *)CFTypeRef cf = 0;
    uint64_t v17 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)cf);
    if (v17) {
      goto LABEL_126;
    }
    uint64_t v17 = FigXPCMessageCopyCFData(a2, "SubsampleAuxiliaryData", v109);
    if (v17) {
      goto LABEL_126;
    }
    uint64_t v18 = *(void *)cf;
    CFTypeRef v19 = v109[0];
    uint64_t v73 = *(void *)(CMBaseObjectGetVTable(*(uint64_t *)cf) + 8);
    if (v73) {
      uint64_t v74 = v73;
    }
    else {
      uint64_t v74 = 0;
    }
    CMSampleTimingInfo v85 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef))(v74 + 56);
    if (v85)
    {
      __int16 v86 = &kFigCPEBasicAESCryptorProperty_SubsampleAuxiliaryData;
      goto LABEL_125;
    }
    goto LABEL_160;
  }
  if (v102 != 1952543603) {
    return v7;
  }
  v109[0] = 0;
  LOBYTE(v104) = 0;
  *(void *)CFTypeRef cf = 0;
  uint64_t v41 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, v109);
  if (!v41)
  {
    int64_t int64 = xpc_dictionary_get_int64(a2, "ExpectedState");
    int64_t v43 = xpc_dictionary_get_int64(a2, "NewState");
    CFTypeRef v9 = v109[0];
    uint64_t v44 = *(void **)(CMBaseObjectGetVTable((uint64_t)v109[0]) + 16);
    if (v44) {
      CFMutableDictionaryRef v45 = v44;
    }
    else {
      CFMutableDictionaryRef v45 = 0;
    }
    if (*v45 >= 6uLL)
    {
      unint64_t v81 = (uint64_t (*)(CFTypeRef, int64_t, int64_t, CFTypeRef *, unsigned char *))v45[20];
      if (v81)
      {
        uint64_t v7 = v81(v9, int64, v43, &v104, cf);
        if (v7) {
          goto LABEL_188;
        }
        xpc_dictionary_set_BOOL(a3, "WasSetOutFlag", (_BYTE)v104 != 0);
        uint64_t v82 = *(void *)cf;
        CMItemCount v83 = "KeyRequestIDOut";
LABEL_186:
        xpc_dictionary_set_uint64(a3, v83, v82);
        goto LABEL_188;
      }
    }
    goto LABEL_187;
  }
  uint64_t v7 = v41;
  CFTypeRef v9 = v109[0];
LABEL_188:
  if (v9)
  {
    CFTypeRef v77 = v9;
    goto LABEL_190;
  }
  return v7;
}

uint64_t cryptorServer_HandleRemoteAsyncMessage(_xpc_connection_s *a1, void *a2)
{
  return cryptorServer_HandleRemoteSyncMessage(a1, a2, 0);
}

uint64_t cryptorServer_NoteEnqueueDecisionFunction(const void *a1)
{
  if (CFEqual(a1, @"264E32A6-4322-4670-8D0F-96A237DA6D06")) {
    return 3;
  }
  if (CFEqual(a1, @"KeyResponseErrorOccurred")) {
    return 3;
  }
  uint64_t result = CFEqual(a1, @"KeyRequestErrorOccurred");
  if (result) {
    return 3;
  }
  return result;
}

uint64_t FigCPECryptorServerGetIDForCryptorByAssociatingWithClientPID(const void *a1, int a2, void *a3)
{
  if (a1 && a2 && a3) {
    return FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(gFigCPECryptorServer, a2, a1, 0, 0, (uint64_t)cryptorServer_NotificationFilter, a3);
  }
  else {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
}

BOOL cryptorServer_NotificationFilter(int a1, int a2, CFTypeRef cf1)
{
  return FigCFEqual(cf1, @"264E32A6-4322-4670-8D0F-96A237DA6D06")
      || FigCFEqual(cf1, @"KeyResponseErrorOccurred")
      || FigCFEqual(cf1, @"KeyRequestErrorOccurred") != 0;
}

uint64_t FigCPECryptorServerGetIDForCryptorByAssociatingWithClientConnection(const void *a1, _xpc_connection_s *a2, void *a3)
{
  if (!gFigCPECryptorServer) {
    return 4294949721;
  }
  if (a1 && a2 && a3) {
    return FigXPCServerAssociateCopiedObjectWithNeighborProcess(gFigCPECryptorServer, a2, a1, 0, 0, (uint64_t)cryptorServer_NotificationFilter, a3);
  }
  return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCPECryptorServerDisassociateCryptorWithClientPID(uint64_t a1, int a2)
{
  if (a1 && a2) {
    return FigXPCServerDisassociateObjectWithNeighborClientPID(gFigCPECryptorServer, a2, a1);
  }
  else {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCPECryptorServerDisassociateCryptorWithClientConnection(uint64_t a1, _xpc_connection_s *a2)
{
  if (a1 && a2) {
    return FigXPCServerDisassociateObjectWithNeighborClientConnection(gFigCPECryptorServer, a2, a1);
  }
  else {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCPECryptorServerCopyCryptorForID(void *a1, void *a2)
{
  if (gFigCPECryptorServer) {
    return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gFigCPECryptorServer, a1, a2);
  }
  else {
    return FigSignalErrorAt(4294949721, 0, 0, 0, 0, 0, 0);
  }
}

BOOL FigCPECryptorServerExistsInProcess()
{
  return gFigCPECryptorServer != 0;
}

uint64_t cryptorServer_CopyCryptorByObjectIDForConnection(_xpc_connection_s *a1, xpc_object_t xdict, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, ".objectID");
  if (!uint64) {
    return 4294949726;
  }
  uint64_t v6 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, 0);
  if (!v6)
  {
    if (cf)
    {
      CFTypeID v7 = CFGetTypeID(cf);
      if (v7 == FigCPECryptorGetTypeID())
      {
        uint64_t v8 = 0;
        *a3 = CFRetain(cf);
        goto LABEL_6;
      }
      uint64_t v10 = 4294949726;
    }
    else
    {
      uint64_t v10 = 4294951144;
    }
    uint64_t v6 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v8 = v6;
LABEL_6:
  if (cf) {
    CFRelease(cf);
  }
  return v8;
}

void fsbxpc_sandboxClientReset(int a1)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __fsbxpc_sandboxClientReset_block_invoke;
  block[3] = &__block_descriptor_tmp_59;
  int v2 = a1;
  dispatch_async((dispatch_queue_t)gFigSandboxRemoteXPCClient, block);
}

void __fsbxpc_sandboxClientReset_block_invoke(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 32);
  int v2 = &qword_1EB28BCC0;
  if (v1 != 2) {
    int v2 = 0;
  }
  if (v1 == 1) {
    uint64_t v3 = &qword_1EB28BCA8;
  }
  else {
    uint64_t v3 = v2;
  }
  if (byte_1EB28BCD8) {
    CFMutableDictionaryRef v4 = &qword_1EB28BCA8;
  }
  else {
    CFMutableDictionaryRef v4 = v3;
  }
  if (v4)
  {
    CFDictionaryRemoveAllValues((CFMutableDictionaryRef)*v4);
    CFDictionaryRemoveAllValues((CFMutableDictionaryRef)v4[1]);
    uint64_t v5 = (__CFSet *)v4[2];
    CFSetRemoveAllValues(v5);
  }
}

uint64_t FigSandboxRegisterURLWithProcess(const __CFURL *a1, unsigned int a2, int a3)
{
  return FigSandboxRegisterURLWithProcessAndCopyRegistration(a1, a2, a3, 0);
}

uint64_t FigSandboxRegisterURLWithProcessAndCopyRegistration(const __CFURL *a1, unsigned int a2, int a3, uint64_t a4)
{
  if (FigFileIsFileOnExternalStorageDevice(a1)
    || (uint64_t result = fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 1, 1, a2, a3, a4), result))
  {
    return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 1, 0, a2, a3, a4);
  }
  return result;
}

uint64_t fsbxpc_sandboxRegisterURLWithProcessCommon(CFURLRef anURL, int a2, int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v32 = 0;
  unsigned int v33 = &v32;
  uint64_t v34 = 0x2000000000;
  int v35 = 0;
  if (anURL && a4 <= 1)
  {
    CFURLRef v11 = anURL;
    if (fsbxpc_sandboxClientOneTimeInitialization_static_init != -1) {
      dispatch_once(&fsbxpc_sandboxClientOneTimeInitialization_static_init, &__block_literal_global_48);
    }
    CFStringRef v12 = CFURLCopyScheme(v11);
    CFStringRef v13 = v12;
    if (v12)
    {
      if (CFStringCompare(v12, @"file", 1uLL))
      {
LABEL_22:
        CFRelease(v13);
        goto LABEL_23;
      }
      CFURLRef v14 = 0;
    }
    else
    {
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v16 = CFURLGetString(v11);
      CFURLRef v11 = CFURLCreateWithFileSystemPath(v15, v16, kCFURLPOSIXPathStyle, a2 == 0);
      CFURLRef v14 = v11;
      if (!v11)
      {
        int v24 = FigSignalErrorAt(4294949791, 0, 0, 0, 0, 0, 0);
        *((_DWORD *)v33 + 6) = v24;
        goto LABEL_23;
      }
    }
    uint64_t v25 = a6;
    CFURLRef v17 = CFURLCopyAbsoluteURL(v11);
    CFURLRef v18 = v17;
    if (a2 && a3)
    {
      CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v17);
      CFStringRef v20 = CFURLCopyFileSystemPath(PathComponent, kCFURLPOSIXPathStyle);
      BOOL v21 = 1;
    }
    else
    {
      BOOL v21 = a2 == 0;
      CFStringRef v20 = CFURLCopyFileSystemPath(v17, kCFURLPOSIXPathStyle);
      CFURLRef PathComponent = 0;
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __fsbxpc_sandboxRegisterURLWithProcessCommon_block_invoke;
    block[3] = &unk_1E567DF08;
    void block[4] = &v32;
    void block[5] = v20;
    BOOL v29 = v21;
    unsigned int v27 = a4;
    int v28 = a5;
    char v30 = a2;
    char v31 = a3;
    void block[6] = v25;
    dispatch_sync((dispatch_queue_t)gFigSandboxRemoteXPCClient, block);
    if (v14) {
      CFRelease(v14);
    }
    if (v18) {
      CFRelease(v18);
    }
    if (PathComponent) {
      CFRelease(PathComponent);
    }
    if (v20) {
      CFRelease(v20);
    }
    if (v13) {
      goto LABEL_22;
    }
  }
LABEL_23:
  uint64_t v22 = *((unsigned int *)v33 + 6);
  _Block_object_dispose(&v32, 8);
  return v22;
}

uint64_t FigSandboxRegisterDirectoryURLWithProcess(const __CFURL *a1, unsigned int a2, int a3)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, a3, 0);
}

uint64_t FigSandboxRegisterDirectoryURLWithProcessAndCopyRegistration(const __CFURL *a1, unsigned int a2, int a3, uint64_t a4)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, a3, a4);
}

uint64_t FigSandboxRegisterURLAndCopyRegistration(const __CFURL *a1, unsigned int a2, uint64_t a3)
{
  return FigSandboxRegisterURLWithProcessAndCopyRegistration(a1, a2, 2, a3);
}

uint64_t FigSandboxRegisterURL(const __CFURL *a1, unsigned int a2)
{
  return FigSandboxRegisterURLWithProcessAndCopyRegistration(a1, a2, 2, 0);
}

uint64_t FigSandboxRegisterDirectoryURLAndCopyRegistration(const __CFURL *a1, unsigned int a2, uint64_t a3)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, 2, a3);
}

uint64_t FigSandboxRegisterDirectoryURL(const __CFURL *a1, unsigned int a2)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, 2, 0);
}

uint64_t FigSandboxAssertionGetTypeID()
{
  if (sRegisterFigSandboxAssertionTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigSandboxAssertionTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxAssertionType);
  }
  return sFigSandboxAssertionID;
}

uint64_t RegisterFigSandboxAssertionType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigSandboxAssertionIOSurfaceID ID = result;
  return result;
}

uint64_t FigSandboxAssertionCreateForPID(int a1, uint64_t a2, uint64_t *a3)
{
  if (sRegisterFigSandboxAssertionTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigSandboxAssertionTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxAssertionType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v7 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = a1;
    *(void *)(Instance + 24) = a2;
    FigSandboxServerXPC_AddAssertionForPID(a1, a2);
    uint64_t result = 0;
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  *a3 = v7;
  return result;
}

void __fsbxpc_sandboxRegisterURLWithProcessCommon_block_invoke(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = *(const __CFString **)(a1 + 40);
  Boolean v3 = *(unsigned char *)(a1 + 64);
  if (*(unsigned char *)(a1 + 65)) {
    BOOL v4 = *(unsigned char *)(a1 + 66) != 0;
  }
  else {
    BOOL v4 = 0;
  }
  int v6 = *(_DWORD *)(a1 + 56);
  int v5 = *(_DWORD *)(a1 + 60);
  uint64_t v7 = *(void **)(a1 + 48);
  CMTimeValue value = 0;
  CFTypeRef v39 = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, kCFURLPOSIXPathStyle, v3);
  if (!v9)
  {
    int v18 = FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
    CFURLRef v17 = 0;
    goto LABEL_72;
  }
  CFURLRef v10 = v9;
  CFTypeRef v37 = v7;
  CFURLRef v11 = &qword_1EB28BCC0;
  if (v5 != 2) {
    CFURLRef v11 = 0;
  }
  if (v5 == 1) {
    CFStringRef v12 = &qword_1EB28BCA8;
  }
  else {
    CFStringRef v12 = v11;
  }
  if (byte_1EB28BCD8) {
    CFStringRef v13 = (__CFDictionary **)&qword_1EB28BCA8;
  }
  else {
    CFStringRef v13 = (__CFDictionary **)v12;
  }
  if (!v13) {
    goto LABEL_26;
  }
  if (v6) {
    ++v13;
  }
  CFURLRef v14 = *v13;
  if (!*v13) {
    goto LABEL_26;
  }
  if (CFDictionaryGetValueIfPresent(v14, v2, (const void **)&value))
  {
    CFAllocatorRef v15 = FigCFWeakReferenceHolderCopyReferencedObject((id *)value);
    if (v15)
    {
      CFStringRef v16 = v15;
      if (v37)
      {
        CFURLRef v17 = 0;
        int v18 = 0;
        *CFTypeRef v37 = v15;
      }
      else
      {
        if (byte_1EB28BCD8) {
          unsigned int v27 = &qword_1EB28BCA8;
        }
        else {
          unsigned int v27 = v12;
        }
        if (v27) {
          CFSetSetValue((CFMutableSetRef)v27[2], v15);
        }
        CFRelease(v16);
        CFURLRef v17 = 0;
        int v18 = 0;
      }
      goto LABEL_28;
    }
    CFDictionaryRemoveValue(v14, v2);
  }
  if (CFStringGetFileSystemRepresentation(v2, buffer, 1024) != 1)
  {
LABEL_26:
    uint64_t v19 = 4294949791;
    goto LABEL_27;
  }
  if (v4 && access(buffer, 4))
  {
    CFURLRef v17 = 0;
    int v18 = -17509;
LABEL_28:
    CFRelease(v10);
    goto LABEL_72;
  }
  if (!FigFileIsFileOnExternalStorageDevice(v10))
  {
    if (fsbxpc_open(buffer, 0, (uint64_t)v41)) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  bzero(v43, 0x400uLL);
  CFIndex v40 = 0;
  CFURLRef url = CFURLCopyAbsoluteURL(v10);
  CFURLRef cf = CFURLCreateCopyDeletingLastPathComponent(v8, url);
  CFStringRef v20 = CFURLCopyFileSystemPath(cf, kCFURLPOSIXPathStyle);
  if (CFStringGetFileSystemRepresentation(v20, v43, 1024) != 1)
  {
    BOOL v21 = 0;
    goto LABEL_46;
  }
  BOOL v21 = (char *)fsbxpc_open(v43, 1074790400, (uint64_t)v41);
  if (!v21)
  {
LABEL_46:
    CFStringRef v23 = 0;
    goto LABEL_47;
  }
  CFStringRef v34 = v20;
  CFStringRef PathComponent = CFURLCopyLastPathComponent(url);
  CFStringRef v23 = PathComponent;
  if (PathComponent)
  {
    CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(PathComponent, 0x8000100u, (char **)&v40);
    if (CStringPtrAndBufferToFree)
    {
      uint64_t v25 = CStringPtrAndBufferToFree;
      *(_WORD *)&v21[strlen(v21)] = 47;
      size_t v26 = strlen(v25);
      strncat(v21, v25, v26);
    }
  }
  CFStringRef v20 = v34;
LABEL_47:
  if (url) {
    CFRelease(url);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v23) {
    CFRelease(v23);
  }
  free(v40);
  if (!v21)
  {
LABEL_56:
    if (realpath_DARWIN_EXTSN(buffer, v41)) {
      goto LABEL_57;
    }
    uint64_t v19 = 4294949788;
LABEL_27:
    int v18 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    CFURLRef v17 = 0;
    goto LABEL_28;
  }
LABEL_57:
  CFURLRef v17 = (char *)sandbox_extension_issue_file();
  if (!v17)
  {
    uint64_t v33 = 4294949789;
    goto LABEL_79;
  }
  uint64_t v28 = FigSandboxRegistrationRemoteCreate(v5, v17, v2, v14, gFigSandboxRemoteXPCClient, &v39);
  if (v28)
  {
    int v18 = v28;
    FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  if (!v39 || (CFTypeRef v29 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v39)) == 0)
  {
    uint64_t v33 = 4294949790;
LABEL_79:
    int v18 = FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  char v30 = v29;
  CFDictionarySetValue(v14, v2, v29);
  CFTypeRef v31 = v39;
  if (v37)
  {
    *CFTypeRef v37 = v39;
  }
  else
  {
    if (byte_1EB28BCD8) {
      uint64_t v32 = &qword_1EB28BCA8;
    }
    else {
      uint64_t v32 = v12;
    }
    if (v32)
    {
      CFSetSetValue((CFMutableSetRef)v32[2], v39);
      CFTypeRef v31 = v39;
    }
    if (!v31) {
      goto LABEL_71;
    }
    CFRelease(v31);
  }
  CFTypeRef v39 = 0;
LABEL_71:
  CFRelease(v10);
  CFRelease(v30);
  int v18 = 0;
LABEL_72:
  if (v39) {
    CFRelease(v39);
  }
  if (v17) {
    free(v17);
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v18;
}

uint64_t __fsbxpc_sandboxClientOneTimeInitialization_block_invoke()
{
  gFigSandboxRemoteXPCClient = (uint64_t)dispatch_queue_create("FigSandboxRemoteClientQueue", 0);
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFStringRef v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  qword_1EB28BCB0 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  qword_1EB28BCA8 = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, v2);
  qword_1EB28BCB8 = (uint64_t)CFSetCreateMutable(v0, 0, MEMORY[0x1E4F1D548]);
  uint64_t result = FigRemote_ShouldConnectToMediaplaybackd();
  if (result)
  {
    qword_1EB28BCC8 = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, v2);
    qword_1EB28BCC0 = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, v2);
    uint64_t result = (uint64_t)CFSetCreateMutable(v0, 0, MEMORY[0x1E4F1D548]);
    char v4 = 0;
    qword_1EB28BCD0 = result;
  }
  else
  {
    char v4 = 1;
  }
  byte_1EB28BCD8 = v4;
  return result;
}

uint64_t fsbxpc_open(const char *a1, int a2, uint64_t a3)
{
  int v4 = open(a1, a2);
  if (v4 == -1) {
    return 0;
  }
  int v5 = v4;
  if (fcntl(v4, 50, a3) == -1) {
    a3 = 0;
  }
  close(v5);
  return a3;
}

uint64_t figSandboxAssertionInit(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

void figSandboxAssertionFinalize(uint64_t a1)
{
}

__CFString *figSandboxAssertionCopyFormattingDesc()
{
  return @"[FigSandboxAssertion]";
}

__CFString *figSandboxAssertionCopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigSandboxAssertion %p pid: %d server: %s>", a1, *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
  return Mutable;
}

uint64_t CM8021ASClockGetTypeID()
{
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  return sFig8021ASClockID;
}

uint64_t RegisterFig8021ASClockIDType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFig8021ASClockIOSurfaceID ID = result;
  return result;
}

uint64_t _CM8021ASClock_ExchangeTimeSyncFunctions(uint64_t a1)
{
  if (!qword_1E9272B78)
  {
    uint64_t result = 0;
    if (a1) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v3 = 0;
    goto LABEL_6;
  }
  uint64_t result = qword_1E9272B78;
  if (!a1) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v3 = a1;
LABEL_6:
  qword_1E9272B78 = v3;
  return result;
}

uint64_t CM8021ASClockCreate(const __CFAllocator *a1, uint64_t *a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (sTimeSyncFunctionsLoadedOnce_1 != -1) {
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_1, 0, (dispatch_function_t)LoadTimeSyncFunctions_1);
  }
  if (dword_1E9272FF8)
  {
    int v46 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v46, &type);
    int v5 = v46;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      int v47 = 136315138;
      uint64_t v48 = "CM8021ASClockCreate";
      CFAllocatorRef v8 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v46;
    }
    else
    {
      CFAllocatorRef v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v8, v8 != v55, v5, 0, v6);
  }
  if (a2)
  {
    if (CM8021ASClockEnsureTimeSyncServices())
    {
      uint64_t Instance = 0;
LABEL_14:
      uint64_t v10 = 4294951236;
      goto LABEL_17;
    }
    if (sRegisterFig8021ASClockTypeOnce != -1) {
      dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      CFUUIDRef v13 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      *(void *)(Instance + 112) = v13;
      if (v13)
      {
        CFURLRef v14 = FigSimpleMutexCreate();
        *(void *)(Instance + 64) = v14;
        if (!v14
          || (*(unsigned char *)(Instance + 96) = 0, CFAllocatorRef v15 = FigSimpleMutexCreate(), (*(void *)(Instance + 32) = v15) == 0))
        {
          uint64_t v12 = 4294951231;
          goto LABEL_19;
        }
        *(void *)(Instance + 24) = FigCFWeakReferenceHolderCreateWithReferencedObject(Instance);
        CFStringRef v16 = FigReadWriteLockCreate(0);
        *(void *)(Instance + 16) = v16;
        if (qword_1E9272B78) {
          uint64_t v18 = qword_1E9272B78;
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (*(uint64_t (**)(pthread_mutex_t **, uint64_t))(v18 + 88))(v16, v17);
        if (v19 == **(void **)qword_1E9272B78) {
          goto LABEL_14;
        }
        uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(qword_1E9272B78 + 32))(v19, v20);
        *(void *)(Instance + 48) = v21;
        if (!v21) {
          goto LABEL_14;
        }
        FigSimpleMutexLock(*(pthread_mutex_t **)(Instance + 32));
        if (qword_1E9272B78) {
          uint64_t v22 = qword_1E9272B78;
        }
        else {
          uint64_t v22 = 0;
        }
        (*(void (**)(void, void (*)(uint64_t, id *), void))(v22 + 104))(*(void *)(Instance + 48), fig8021ASClock_GrandmasterDidChange, *(void *)(Instance + 24));
        if (qword_1E9272B78) {
          uint64_t v23 = qword_1E9272B78;
        }
        else {
          uint64_t v23 = 0;
        }
        (*(void (**)(void, void, void))(v23 + 96))(*(void *)(Instance + 48), fig8021ASClock_LockStateDidChange, *(void *)(Instance + 24));
        if (qword_1E9272B78) {
          uint64_t v24 = qword_1E9272B78;
        }
        else {
          uint64_t v24 = 0;
        }
        int v25 = (*(uint64_t (**)(void))(v24 + 72))(*(void *)(Instance + 48));
        *(_DWORD *)(Instance + 40) = v25;
        if (v25 == 2)
        {
          if (qword_1E9272B78) {
            uint64_t v26 = qword_1E9272B78;
          }
          else {
            uint64_t v26 = 0;
          }
          uint64_t v27 = (*(uint64_t (**)(void))(v26 + 80))(*(void *)(Instance + 48));
        }
        else
        {
          uint64_t v27 = **(void **)(qword_1E9272B78 + 8);
        }
        *(void *)(Instance + 56) = v27;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(Instance + 32));
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(void *)(Instance + 72) = Mutable;
        if (Mutable)
        {
          CFMutableDictionaryRef v29 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], &sFig8021ASClockPortsDictionaryValueCallBacks);
          *(void *)(Instance + 80) = v29;
          if (v29)
          {
            CFMutableSetRef v30 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
            *(void *)(Instance + 88) = v30;
            if (v30)
            {
              CFMutableDictionaryRef v31 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              *(void *)(Instance + 104) = v31;
              if (v31)
              {
                if (!dword_1E9272FF8)
                {
LABEL_68:
                  uint64_t v12 = 0;
                  *a2 = Instance;
                  return v12;
                }
                int v46 = 0;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                uint64_t v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v46, &type);
                int v33 = v46;
                if (os_log_type_enabled(v32, type)) {
                  unsigned int v35 = v33;
                }
                else {
                  unsigned int v35 = v33 & 0xFFFFFFFE;
                }
                if (v35)
                {
                  CFTypeRef v36 = "not locked";
                  uint64_t v37 = *(void *)(Instance + 56);
                  if (*(_DWORD *)(Instance + 40) == 2) {
                    CFTypeRef v36 = "locked";
                  }
                  int v47 = 136315906;
                  uint64_t v48 = "CM8021ASClockCreate";
                  __int16 v49 = 2048;
                  uint64_t v50 = Instance;
                  __int16 v51 = 2080;
                  uint64_t v52 = v36;
                  __int16 v53 = 2048;
                  uint64_t v54 = v37;
                  uint64_t v38 = (unsigned char *)_os_log_send_and_compose_impl();
                  LOBYTE(v33) = v46;
                }
                else
                {
                  uint64_t v38 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v38, v38 != v55, v33, 0, v34);
LABEL_60:
                if (dword_1E9272FF8)
                {
                  int v46 = 0;
                  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                  CFTypeRef v39 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v46, &type);
                  int v40 = v46;
                  if (os_log_type_enabled(v39, type)) {
                    unsigned int v42 = v40;
                  }
                  else {
                    unsigned int v42 = v40 & 0xFFFFFFFE;
                  }
                  if (v42)
                  {
                    int v47 = 136315394;
                    uint64_t v48 = "CM8021ASClockCreate";
                    __int16 v49 = 2048;
                    uint64_t v50 = Instance;
                    int64_t v43 = (unsigned char *)_os_log_send_and_compose_impl();
                    LOBYTE(v40) = v46;
                  }
                  else
                  {
                    int64_t v43 = 0;
                  }
                  fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v43, v43 != v55, v40, 0, v41);
                }
                goto LABEL_68;
              }
            }
          }
        }
      }
      uint64_t v12 = 4294954549;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t Instance = 0;
  }
  uint64_t v10 = 4294951233;
LABEL_17:
  uint64_t v11 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  if (!v11) {
    goto LABEL_60;
  }
  uint64_t v12 = v11;
  if (Instance) {
LABEL_19:
  }
    CFRelease((CFTypeRef)Instance);
  return v12;
}

void *LoadTimeSyncFunctions_1()
{
  unsigned int v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFig8021ASClockTrace[1], @"8021as_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFig8021ASClockTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272FF8, @"8021as_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272FF0);
  qword_1E9272B58 = (uint64_t)timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval;
  qword_1E9272B78 = (uint64_t)&gFTable;
  int v1 = dlopen("/System/Library/PrivateFrameworks/TimeSync.framework/TimeSync", 4);
  if (v1)
  {
    CFAllocatorRef v2 = v1;
    gFTable = (uint64_t)dlsym(v1, "TSNullClockIdentifier");
    if (gFTable)
    {
      qword_1E9272A70 = (uint64_t)dlsym(v2, "TSNullgPTPClockIdentity");
      if (qword_1E9272A70)
      {
        uint64_t v3 = dlsym(v2, "TimeSyncAddgPTPServicesSync");
        int v4 = &qword_1E9272A78;
        if (v3)
        {
          qword_1E9272A78 = (uint64_t)v3;
          int v5 = dlsym(v2, "TimeSyncRemovegPTPServices");
          int v4 = &qword_1E9272A80;
          if (v5)
          {
            qword_1E9272A80 = (uint64_t)v5;
            uint64_t v6 = dlsym(v2, "TimeSyncClockCreateWithClockIdentifer");
            int v4 = &qword_1E9272A88;
            if (v6)
            {
              qword_1E9272A88 = (uint64_t)v6;
              unsigned int v7 = dlsym(v2, "TimeSyncClockDispose");
              int v4 = &qword_1E9272A90;
              if (v7)
              {
                qword_1E9272A90 = (uint64_t)v7;
                CFAllocatorRef v8 = dlsym(v2, "TimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime");
                int v4 = &qword_1E9272A98;
                if (v8)
                {
                  qword_1E9272A98 = (uint64_t)v8;
                  CFURLRef v9 = dlsym(v2, "TimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime");
                  int v4 = &qword_1E9272AA0;
                  if (v9)
                  {
                    qword_1E9272AA0 = (uint64_t)v9;
                    uint64_t v10 = dlsym(v2, "TimeSyncClockGetClockRate");
                    int v4 = &qword_1E9272AA8;
                    if (v10)
                    {
                      qword_1E9272AA8 = (uint64_t)v10;
                      uint64_t v11 = dlsym(v2, "TimeSyncClockGetLockState");
                      int v4 = &qword_1E9272AB0;
                      if (v11)
                      {
                        qword_1E9272AB0 = (uint64_t)v11;
                        uint64_t v12 = dlsym(v2, "TimeSyncClockGetgPTPGrandmasterIdentity");
                        int v4 = &qword_1E9272AB8;
                        if (v12)
                        {
                          qword_1E9272AB8 = (uint64_t)v12;
                          CFUUIDRef v13 = dlsym(v2, "TimeSyncSystemDomainClockIdentifier");
                          int v4 = &qword_1E9272AC0;
                          if (v13)
                          {
                            qword_1E9272AC0 = (uint64_t)v13;
                            CFURLRef v14 = dlsym(v2, "TimeSyncClockSetLockStateChangeCallback");
                            int v4 = &qword_1E9272AC8;
                            if (v14)
                            {
                              qword_1E9272AC8 = (uint64_t)v14;
                              CFAllocatorRef v15 = dlsym(v2, "TimeSyncClockSetgPTPGrandmasterChangeCallback");
                              int v4 = &qword_1E9272AD0;
                              if (v15)
                              {
                                qword_1E9272AD0 = (uint64_t)v15;
                                CFStringRef v16 = dlsym(v2, "TimeSyncClockAddUDPv4EndToEndPort");
                                int v4 = &qword_1E9272AD8;
                                if (v16)
                                {
                                  qword_1E9272AD8 = (uint64_t)v16;
                                  uint64_t v17 = dlsym(v2, "TimeSyncClockAddUDPv4EndToEndPortAndGetIdentity");
                                  int v4 = &qword_1E9272AE0;
                                  if (v17)
                                  {
                                    qword_1E9272AE0 = (uint64_t)v17;
                                    uint64_t v18 = dlsym(v2, "TimeSyncClockRemoveUDPv4EndToEndPort");
                                    int v4 = &qword_1E9272AE8;
                                    if (v18)
                                    {
                                      qword_1E9272AE8 = (uint64_t)v18;
                                      uint64_t v19 = dlsym(v2, "TimeSyncClockAddUDPv6EndToEndPort");
                                      int v4 = &qword_1E9272AF0;
                                      if (v19)
                                      {
                                        qword_1E9272AF0 = (uint64_t)v19;
                                        uint64_t v20 = dlsym(v2, "TimeSyncClockAddUDPv6EndToEndPortAndGetIdentity");
                                        int v4 = &qword_1E9272AF8;
                                        if (v20)
                                        {
                                          qword_1E9272AF8 = (uint64_t)v20;
                                          uint64_t v21 = dlsym(v2, "TimeSyncClockRemoveUDPv6EndToEndPort");
                                          int v4 = &qword_1E9272B00;
                                          if (v21)
                                          {
                                            qword_1E9272B00 = (uint64_t)v21;
                                            uint64_t v22 = dlsym(v2, "TimeSyncClockAddAWDLPort");
                                            int v4 = &qword_1E9272B08;
                                            if (v22)
                                            {
                                              qword_1E9272B08 = (uint64_t)v22;
                                              uint64_t v23 = dlsym(v2, "TimeSyncClockRemoveAWDLPort");
                                              int v4 = &qword_1E9272B10;
                                              if (v23)
                                              {
                                                qword_1E9272B10 = (uint64_t)v23;
                                                uint64_t v24 = dlsym(v2, "TimeSyncClockOverridePortReceiveMatching");
                                                int v4 = &qword_1E9272B18;
                                                if (v24)
                                                {
                                                  qword_1E9272B18 = (uint64_t)v24;
                                                  int v25 = dlsym(v2, "TimeSyncClockRestorePortReceiveMatching");
                                                  int v4 = &qword_1E9272B20;
                                                  if (v25)
                                                  {
                                                    qword_1E9272B20 = (uint64_t)v25;
                                                    uint64_t v26 = dlsym(v2, "TimeSyncPortCreateFromClock");
                                                    int v4 = &qword_1E9272B28;
                                                    if (v26)
                                                    {
                                                      qword_1E9272B28 = (uint64_t)v26;
                                                      uint64_t v27 = dlsym(v2, "TimeSyncPortDispose");
                                                      int v4 = &qword_1E9272B30;
                                                      if (v27)
                                                      {
                                                        qword_1E9272B30 = (uint64_t)v27;
                                                        uint64_t v28 = dlsym(v2, "TimeSyncPortEnable");
                                                        int v4 = &qword_1E9272B38;
                                                        if (v28)
                                                        {
                                                          qword_1E9272B38 = (uint64_t)v28;
                                                          CFMutableDictionaryRef v29 = dlsym(v2, "TimeSyncPortDisable");
                                                          int v4 = &qword_1E9272B40;
                                                          if (v29)
                                                          {
                                                            qword_1E9272B40 = (uint64_t)v29;
                                                            CFMutableSetRef v30 = dlsym(v2, "TimeSyncPortSetRemoteSyncMessageIntervals");
                                                            int v4 = &qword_1E9272B60;
                                                            if (v30)
                                                            {
                                                              qword_1E9272B60 = (uint64_t)v30;
                                                              CFMutableDictionaryRef v31 = dlsym(v2, "TimeSyncClockGetClockRateAnchorsAndGrandmasterIdentity");
                                                              int v4 = &qword_1E9272B48;
                                                              if (v31)
                                                              {
                                                                qword_1E9272B48 = (uint64_t)v31;
                                                                uint64_t v32 = dlsym(v2, "TimeSyncClockSetAllPortRemoteSyncMessageIntervals");
                                                                int v4 = &qword_1E9272B50;
                                                                if (v32)
                                                                {
                                                                  qword_1E9272B50 = (uint64_t)v32;
                                                                  int v33 = dlsym(v2, "TimeSyncGetClockMetricsWithSize");
                                                                  int v4 = &qword_1E9272B68;
                                                                  if (v33)
                                                                  {
                                                                    qword_1E9272B68 = (uint64_t)v33;
                                                                    uint64_t result = dlsym(v2, "TimeSyncGetPortMetricsWithSize");
                                                                    int v4 = &qword_1E9272B70;
                                                                    if (result)
                                                                    {
                                                                      qword_1E9272B70 = (uint64_t)result;
                                                                      return result;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        *int v4 = 0;
      }
    }
  }

  return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
}

uint64_t CM8021ASClockEnsureTimeSyncServices()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (sTimeSyncFunctionsLoadedOnce_1 != -1) {
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_1, 0, (dispatch_function_t)LoadTimeSyncFunctions_1);
  }
  int v0 = 0;
  while (1)
  {
    uint64_t v1 = qword_1E9272B78 ? qword_1E9272B78 : 0;
    if ((*(uint64_t (**)(uint64_t))(v1 + 16))(1000)) {
      break;
    }
    if (dword_1E9272FF8)
    {
      v9[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v9, &type);
      int v3 = v9[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v5 = v3;
      }
      else {
        unsigned int v5 = v3 & 0xFFFFFFFE;
      }
      if (v5)
      {
        v9[1] = 136315394;
        uint64_t v10 = "CM8021ASClockEnsureTimeSyncServices";
        __int16 v11 = 1024;
        int v12 = v0;
        uint64_t v6 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v9[0];
      }
      else
      {
        uint64_t v6 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v6, v6 != &v13, v3, 0, v4);
    }
    if (++v0 == 9) {
      return 4294951236;
    }
  }
  return 0;
}

void fig8021ASClock_GrandmasterDidChange(uint64_t a1, id *a2)
{
  CFAllocatorRef v2 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  int v3 = (uint64_t *)v2;
  if (v2)
  {
    FigReadWriteLockLockForRead((uint64_t)v2[2]);
    global_queue = dispatch_get_global_queue(0, 0);
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigDispatchAsyncPostNotification(global_queue, DefaultLocalCenter, @"CM8021ASClockGrandmasterDidChange", v3, 0, 0);
    FigReadWriteLockUnlockForRead(v3[2]);
  }
  else
  {
    global_queue = dispatch_get_global_queue(0, 0);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __fig8021ASClock_GrandmasterDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_121;
  void block[4] = v3;
  dispatch_async(global_queue, block);
}

void fig8021ASClock_LockStateDidChange(id a1, id *a2, int a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  uint64_t v6 = v5;
  if (v5)
  {
    if (v5[6] == a1)
    {
      if (dword_1E9272FF8)
      {
        int v28 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v28, &type);
        int v8 = v28;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v10 = v8;
        }
        else {
          unsigned int v10 = v8 & 0xFFFFFFFE;
        }
        if (v10)
        {
          int v29 = 136315650;
          CFMutableSetRef v30 = "fig8021ASClock_LockStateDidChange";
          __int16 v31 = 2048;
          uint64_t v32 = v6;
          __int16 v33 = 1024;
          LODWORD(v34) = a3;
          __int16 v11 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v8) = v28;
        }
        else
        {
          __int16 v11 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v11, v11 != v39, v8, 0, v9);
      }
      FigSimpleMutexLock((pthread_mutex_t *)v6[4]);
      id v12 = v6[7];
      if (qword_1E9272B78) {
        uint64_t v13 = qword_1E9272B78;
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v14 = (*(uint64_t (**)(id))(v13 + 80))(v6[6]);
      *((_DWORD *)v6 + 10) = a3;
      uint64_t v15 = v14;
      if (a3 != 2) {
        uint64_t v15 = **(void **)(qword_1E9272B78 + 8);
      }
      v6[7] = (id)v15;
      FigSimpleMutexUnlock((pthread_mutex_t *)v6[4]);
      if (dword_1E9272FF8)
      {
        int v28 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        CFStringRef v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v28, &type);
        int v17 = v28;
        if (os_log_type_enabled(v16, type)) {
          unsigned int v19 = v17;
        }
        else {
          unsigned int v19 = v17 & 0xFFFFFFFE;
        }
        if (v19)
        {
          int v20 = *((_DWORD *)v6 + 10);
          uint64_t v21 = "not locked";
          CFMutableSetRef v30 = "fig8021ASClock_LockStateDidChange";
          int v29 = 136316162;
          __int16 v31 = 2048;
          if (v20 == 2) {
            uint64_t v21 = "locked";
          }
          uint64_t v32 = v6;
          __int16 v33 = 2048;
          id v34 = v12;
          __int16 v35 = 2080;
          CFTypeRef v36 = v21;
          __int16 v37 = 2048;
          uint64_t v38 = v14;
          uint64_t v22 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v17) = v28;
        }
        else
        {
          uint64_t v22 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v22, v22 != v39, v17, 0, v18);
      }
      if (a3 != 1)
      {
        FigReadWriteLockLockForRead((uint64_t)v6[2]);
        global_queue = dispatch_get_global_queue(0, 0);
        CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        FigDispatchAsyncPostNotification(global_queue, DefaultLocalCenter, @"CM8021ASClockLockStateDidChange", v6, 0, 0);
        FigReadWriteLockUnlockForRead((uint64_t)v6[2]);
      }
    }
    else
    {
      FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    }
  }
  int v25 = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __fig8021ASClock_LockStateDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_122;
  void block[4] = v6;
  dispatch_async(v25, block);
}

uint64_t CM8021ASClockAddIPv4Port(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    goto LABEL_13;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v6 == sFig8021ASClockID)
  {
    if (a3 == 2130706433)
    {
      return 0;
    }
    else
    {
      if (qword_1E9272B78) {
        uint64_t v8 = qword_1E9272B78;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 112);
      uint64_t v10 = a1[6];
      return v9(v10, a2, a3);
    }
  }
  else
  {
LABEL_13:
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CM8021ASClockAddIPv4PortAndGetIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5)
{
  *(_DWORD *)CMTime bytes = a3;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  CFTypeID v10 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v10 != sFig8021ASClockID)
  {
    uint64_t v13 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = v13;
    goto LABEL_12;
  }
  if (a3 != 2130706433)
  {
    if (qword_1E9272B78) {
      uint64_t v12 = qword_1E9272B78;
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, unsigned __int16 *))(v12 + 120))(*(void *)(a1 + 48), a2, a3, a4, a5);
    if (!v13) {
      uint64_t v13 = fig8021ASClock_addPortNumberForAddress(a1, bytes, 2, *a5);
    }
    goto LABEL_11;
  }
  uint64_t v11 = 0;
LABEL_12:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v11;
}

uint64_t fig8021ASClock_addPortNumberForAddress(uint64_t a1, UInt8 *bytes, int a3, uint64_t a4)
{
  kedouble y = 0;
  uint64_t v6 = fig8021ASClock_copyCFTypeRepresentationOfAddress(bytes, a3, (CFDataRef *)&key);
  if (v6)
  {
    uint64_t v10 = v6;
    CFNumberRef UInt16 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    CFNumberRef UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a4);
    if (UInt16)
    {
      if (qword_1E9272B78) {
        uint64_t v8 = qword_1E9272B78;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v9 = (const void *)(*(uint64_t (**)(void, uint64_t))(v8 + 192))(*(void *)(a1 + 48), a4);
      if (v9)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), key, UInt16);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 80), UInt16, v9);
        uint64_t v10 = 0;
      }
      else
      {
        uint64_t v10 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v10 = 4294954549;
    }
  }
  if (key) {
    CFRelease(key);
  }
  if (UInt16) {
    CFRelease(UInt16);
  }
  if (v10 && v9)
  {
    if (qword_1E9272B78) {
      uint64_t v11 = qword_1E9272B78;
    }
    else {
      uint64_t v11 = 0;
    }
    (*(void (**)(const void *))(v11 + 200))(v9);
  }
  return v10;
}

uint64_t CM8021ASClockRemoveIPv4Port(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)CMTime bytes = a3;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  CFTypeID v6 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v6 != sFig8021ASClockID)
  {
    uint64_t v8 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
LABEL_12:
    uint64_t v7 = v8;
    goto LABEL_13;
  }
  if (a3 != 2130706433)
  {
    uint64_t v8 = fig8021ASClock_addPortMetricsToMetricsDictForAddress(a1, bytes, 2);
    if (!v8)
    {
      if (qword_1E9272B78) {
        uint64_t v9 = qword_1E9272B78;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v8 = (*(uint64_t (**)(void, uint64_t, void))(v9 + 128))(*(void *)(a1 + 48), a2, *(unsigned int *)bytes);
      if (!v8) {
        uint64_t v8 = fig8021ASClock_clearPortStateForAddress((CFDictionaryRef *)a1, bytes, 2);
      }
    }
    goto LABEL_12;
  }
  uint64_t v7 = 0;
LABEL_13:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v7;
}

uint64_t fig8021ASClock_addPortMetricsToMetricsDictForAddress(uint64_t a1, UInt8 *bytes, int a3)
{
  CFTypeRef cf = 0;
  kedouble y = 0;
  uint64_t v4 = fig8021ASClock_copyCFTypeRepresentationOfAddress(bytes, a3, (CFDataRef *)&key);
  if (v4)
  {
    uint64_t v8 = v4;
  }
  else
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), key);
    if (Value)
    {
      CFNumberRef v6 = Value;
      uint64_t UInt16 = FigCFNumberGetUInt16(Value);
      uint64_t v8 = fig8021ASClock_copyPortMetricsForPortIfValid(a1, UInt16, &cf);
      if (!v8) {
        FigCFDictionarySetValue(*(void **)(a1 + 104), v6, cf);
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
  }
  if (key) {
    CFRelease(key);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v8;
}

uint64_t fig8021ASClock_clearPortStateForAddress(CFDictionaryRef *a1, UInt8 *bytes, int a3)
{
  kedouble y = 0;
  uint64_t v4 = fig8021ASClock_copyCFTypeRepresentationOfAddress(bytes, a3, (CFDataRef *)&key);
  if (!v4)
  {
    CFNumberRef Value = CFDictionaryGetValue(a1[9], key);
    if (Value)
    {
      CFNumberRef v6 = Value;
      CFSetRemoveValue(a1[11], Value);
      CFDictionaryRemoveValue(a1[10], v6);
      CFDictionaryRemoveValue(a1[9], key);
    }
  }
  if (key) {
    CFRelease(key);
  }
  return v4;
}

uint64_t CM8021ASClockAddIPv6Port(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  uint64_t v11 = a4;
  if (!a1) {
    goto LABEL_14;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v6 == sFig8021ASClockID)
  {
    if (v10 == *MEMORY[0x1E4F148D0] && v11 == *(void *)(MEMORY[0x1E4F148D0] + 8))
    {
      return 0;
    }
    else
    {
      if (qword_1E9272B78) {
        uint64_t v8 = qword_1E9272B78;
      }
      else {
        uint64_t v8 = 0;
      }
      return (*(uint64_t (**)(void, uint64_t, uint64_t *))(v8 + 136))(a1[6], a2, &v10);
    }
  }
  else
  {
LABEL_14:
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CM8021ASClockAddIPv6PortAndGetIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6)
{
  uint64_t v16 = a3;
  uint64_t v17 = a4;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  CFTypeID v10 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v10 != sFig8021ASClockID)
  {
    uint64_t v14 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
LABEL_14:
    uint64_t v13 = v14;
    goto LABEL_15;
  }
  if (v16 != *MEMORY[0x1E4F148D0] || v17 != *(void *)(MEMORY[0x1E4F148D0] + 8))
  {
    if (qword_1E9272B78) {
      uint64_t v12 = qword_1E9272B78;
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t, unsigned __int16 *))(v12 + 144))(*(void *)(a1 + 48), a2, &v16, a5, a6);
    if (!v14) {
      uint64_t v14 = fig8021ASClock_addPortNumberForAddress(a1, (UInt8 *)&v16, 30, *a6);
    }
    goto LABEL_14;
  }
  uint64_t v13 = 0;
LABEL_15:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v13;
}

uint64_t CM8021ASClockRemoveIPv6Port(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a3;
  uint64_t v13 = a4;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  CFTypeID v6 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v6 != sFig8021ASClockID)
  {
    uint64_t v8 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
LABEL_15:
    uint64_t v10 = v8;
    goto LABEL_16;
  }
  if (v12 != *MEMORY[0x1E4F148D0] || v13 != *(void *)(MEMORY[0x1E4F148D0] + 8))
  {
    uint64_t v8 = fig8021ASClock_addPortMetricsToMetricsDictForAddress(a1, (UInt8 *)&v12, 30);
    if (!v8)
    {
      if (qword_1E9272B78) {
        uint64_t v9 = qword_1E9272B78;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v8 = (*(uint64_t (**)(void, uint64_t, uint64_t *))(v9 + 152))(*(void *)(a1 + 48), a2, &v12);
      if (!v8) {
        uint64_t v8 = fig8021ASClock_clearPortStateForAddress((CFDictionaryRef *)a1, (UInt8 *)&v12, 30);
      }
    }
    goto LABEL_15;
  }
  uint64_t v10 = 0;
LABEL_16:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v10;
}

uint64_t CM8021ASClockAddAWDLPort(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    goto LABEL_9;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v6 == sFig8021ASClockID)
  {
    if (qword_1E9272B78) {
      uint64_t v7 = qword_1E9272B78;
    }
    else {
      uint64_t v7 = 0;
    }
    (*(void (**)(void, uint64_t, uint64_t))(v7 + 160))(a1[6], a2, a3);
    return 0;
  }
  else
  {
LABEL_9:
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CM8021ASClockRemoveAWDLPort(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    goto LABEL_9;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v6 == sFig8021ASClockID)
  {
    if (qword_1E9272B78) {
      uint64_t v7 = qword_1E9272B78;
    }
    else {
      uint64_t v7 = 0;
    }
    (*(void (**)(void, uint64_t, uint64_t))(v7 + 168))(a1[6], a2, a3);
    return 0;
  }
  else
  {
LABEL_9:
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CM8021ASClockOverridePortReceiveMatching(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    goto LABEL_11;
  }
  CFTypeID v8 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v8 == sFig8021ASClockID)
  {
    if (qword_1E9272B78) {
      uint64_t v9 = qword_1E9272B78;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 176);
    uint64_t v11 = a1[6];
    return v10(v11, a2, a3, a4);
  }
  else
  {
LABEL_11:
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CM8021ASClockRestorePortReceiveMatching(void *a1, uint64_t a2)
{
  if (!a1) {
    goto LABEL_11;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v4 == sFig8021ASClockID)
  {
    if (qword_1E9272B78) {
      uint64_t v5 = qword_1E9272B78;
    }
    else {
      uint64_t v5 = 0;
    }
    CFTypeID v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 184);
    uint64_t v7 = a1[6];
    return v6(v7, a2);
  }
  else
  {
LABEL_11:
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CM8021ASClockEnablePort(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFNumberRef UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  CFTypeID v4 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v4 == sFig8021ASClockID)
  {
    if (!UInt16)
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
      return 4294954549;
    }
    if (CFSetContainsValue(*(CFSetRef *)(a1 + 88), UInt16))
    {
      CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), UInt16);
      if (Value)
      {
        CFTypeID v6 = Value;
        if (dword_1E9272FF8)
        {
          v16[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v16, &type);
          int v8 = v16[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v10 = v8;
          }
          else {
            unsigned int v10 = v8 & 0xFFFFFFFE;
          }
          if (v10)
          {
            v16[1] = 136315138;
            uint64_t v17 = "CM8021ASClockEnablePort";
            uint64_t v11 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v8) = v16[0];
          }
          else
          {
            uint64_t v11 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v11, v11 != &v18, v8, 0, v9);
        }
        if (qword_1E9272B78) {
          uint64_t v12 = qword_1E9272B78;
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = (*(uint64_t (**)(const void *))(v12 + 208))(v6);
        if (!v13) {
          CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 88), UInt16);
        }
      }
      else
      {
        uint64_t v13 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  }
  else
  {
    uint64_t v13 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    if (!UInt16) {
      return v13;
    }
  }
  CFRelease(UInt16);
  return v13;
}

uint64_t CM8021ASClockDisablePort(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFNumberRef UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  CFTypeID v4 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v4 == sFig8021ASClockID)
  {
    if (!UInt16)
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
      return 4294954549;
    }
    if (CFSetContainsValue(*(CFSetRef *)(a1 + 88), UInt16))
    {
      uint64_t v13 = 0;
    }
    else
    {
      CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), UInt16);
      if (Value)
      {
        CFTypeID v6 = Value;
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 88), UInt16);
        if (dword_1E9272FF8)
        {
          v16[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v16, &type);
          int v8 = v16[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v10 = v8;
          }
          else {
            unsigned int v10 = v8 & 0xFFFFFFFE;
          }
          if (v10)
          {
            v16[1] = 136315138;
            uint64_t v17 = "CM8021ASClockDisablePort";
            uint64_t v11 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v8) = v16[0];
          }
          else
          {
            uint64_t v11 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v11, v11 != &v18, v8, 0, v9);
        }
        if (qword_1E9272B78) {
          uint64_t v12 = qword_1E9272B78;
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = (*(uint64_t (**)(const void *))(v12 + 216))(v6);
        if (v13) {
          CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 88), UInt16);
        }
      }
      else
      {
        uint64_t v13 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
      }
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  }
  else
  {
    uint64_t v13 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    if (!UInt16) {
      return v13;
    }
  }
  CFRelease(UInt16);
  return v13;
}

uint64_t CM8021ASClockSetAllPortRemoteSyncMessageIntervals(uint64_t a1, CMTime *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CMTime time = *a2;
  long double Seconds = CMTimeGetSeconds(&time);
  double v5 = log10(Seconds);
  if (!a1) {
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  double v6 = v5;
  CFTypeID v7 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v7 != sFig8021ASClockID) {
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  if ((a2->flags & 0x1D) != 1) {
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  CMTimeMakeWithSeconds(&time2, 0.125, 1000);
  CMTime time = *a2;
  if (CMTimeCompare(&time, &time2) < 0) {
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  if (dword_1E9272FF8)
  {
    int v15 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v15, &type);
    int v9 = v15;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v11 = v9;
    }
    else {
      unsigned int v11 = v9 & 0xFFFFFFFE;
    }
    if (v11)
    {
      int v17 = 136315650;
      char v18 = "CM8021ASClockSetAllPortRemoteSyncMessageIntervals";
      __int16 v19 = 2048;
      uint64_t v20 = a1;
      __int16 v21 = 1024;
      int v22 = (int)(v6 / 0.301029996);
      uint64_t v12 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v9) = v15;
    }
    else
    {
      uint64_t v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v12, v12 != &time, v9, 0, v10);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  if (!*(unsigned char *)(a1 + 96))
  {
    if (timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_onceToken != -1) {
      dispatch_once(&timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_onceToken, &__block_literal_global_125);
    }
    dispatch_async_f((dispatch_queue_t)gLogMeanIntervalApplier, 0, (dispatch_function_t)timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal);
    *(unsigned char *)(a1 + 96) = 1;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  time.CMTimeValue value = MEMORY[0x1E4F143A8];
  *(void *)&time.timescale = 0x40000000;
  time.uint64_t epoch = (CMTimeEpoch)__timesyncLogMeanIntervalApplier_setIntervalAndApplyIfDifferent_block_invoke;
  uint64_t v24 = &__block_descriptor_tmp_139;
  char v25 = (int)(v6 / 0.301029996);
  dispatch_async((dispatch_queue_t)gLogMeanIntervalApplier, &time);
  return 0;
}

uint64_t CM8021ASClockSetPortRemoteSyncMessageIntervals(uint64_t a1, int a2, CMTime *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  CMTime time = *a3;
  long double Seconds = CMTimeGetSeconds(&time);
  double v7 = log10(Seconds);
  CFNumberRef UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  CFTypeID v9 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v9 != sFig8021ASClockID)
  {
    uint64_t v24 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    if (!UInt16) {
      return v24;
    }
    goto LABEL_30;
  }
  if (!UInt16)
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    return 4294954549;
  }
  if ((a3->flags & 0x1D) != 1
    || (CMTimeMakeWithSeconds(&time2, 0.125, 1000), CMTime time = *a3, CMTimeCompare(&time, &time2) < 0))
  {
    uint64_t v26 = 4294954550;
  }
  else
  {
    if (dword_1E9272FF8)
    {
      int v28 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v28, &type);
      int v11 = v28;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v13 = v11;
      }
      else {
        unsigned int v13 = v11 & 0xFFFFFFFE;
      }
      if (v13)
      {
        int v30 = 136315906;
        __int16 v31 = "CM8021ASClockSetPortRemoteSyncMessageIntervals";
        __int16 v32 = 2048;
        uint64_t v33 = a1;
        __int16 v34 = 1024;
        int v35 = a2;
        __int16 v36 = 1024;
        int v37 = (int)(v7 / 0.301029996);
        uint64_t v14 = (CMTime *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v28;
      }
      else
      {
        uint64_t v14 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v14, v14 != &time, v11, 0, v12);
    }
    if (*(unsigned char *)(a1 + 96))
    {
      uint64_t v26 = 4294954540;
    }
    else
    {
      CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), UInt16);
      if (Value)
      {
        uint64_t v16 = Value;
        if (dword_1E9272FF8)
        {
          int v28 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          int v17 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v28, &type);
          int v18 = v28;
          if (os_log_type_enabled(v17, type)) {
            unsigned int v20 = v18;
          }
          else {
            unsigned int v20 = v18 & 0xFFFFFFFE;
          }
          if (v20)
          {
            int v30 = 136315138;
            __int16 v31 = "CM8021ASClockSetPortRemoteSyncMessageIntervals";
            __int16 v21 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(v18) = v28;
          }
          else
          {
            __int16 v21 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v21, v21 != &time, v18, 0, v19);
        }
        if (qword_1E9272B78) {
          uint64_t v22 = qword_1E9272B78;
        }
        else {
          uint64_t v22 = 0;
        }
        uint64_t v23 = (*(uint64_t (**)(const void *, void))(v22 + 248))(v16, (int)(v7 / 0.301029996));
        goto LABEL_29;
      }
      uint64_t v26 = 4294954549;
    }
  }
  uint64_t v23 = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
LABEL_29:
  uint64_t v24 = v23;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
LABEL_30:
  CFRelease(UInt16);
  return v24;
}

void CM8021ASClockGetClockTimeForHostTime(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, CMTime *a4@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = **(void **)(qword_1E9272B78 + 8);
  *(_OWORD *)&a4->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->uint64_t epoch = 0;
  if (!a1) {
    goto LABEL_22;
  }
  CFTypeID v8 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v8 == sFig8021ASClockID && (*(unsigned char *)(a2 + 12) & 1) != 0)
  {
    if (qword_1E9272B78) {
      uint64_t v9 = qword_1E9272B78;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(v9 + 56);
    uint64_t v11 = *(void *)(a1 + 48);
    CMTime hostTime = *(CMTime *)a2;
    uint64_t v12 = CMClockConvertHostTimeToSystemUnits(&hostTime);
    int64_t v13 = v10(v11, v12, &v25);
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    uint64_t v14 = v25;
    uint64_t v15 = *(void *)(a1 + 56);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
    if (v14 == v15 && v13 != -1)
    {
      CMTimeMake(a4, v13, 1000000000);
      if (a3) {
        *a3 = v25;
      }
    }
    if (dword_1E9272FF8 >= 2)
    {
      int v24 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v24, &type);
      int v17 = v24;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v19 = v17;
      }
      else {
        unsigned int v19 = v17 & 0xFFFFFFFE;
      }
      if (v19)
      {
        CMTime hostTime = *(CMTime *)a2;
        Float64 Seconds = CMTimeGetSeconds(&hostTime);
        CMTime hostTime = *a4;
        Float64 v21 = CMTimeGetSeconds(&hostTime);
        int v26 = 136316162;
        uint64_t v27 = "CM8021ASClockGetClockTimeForHostTime";
        __int16 v28 = 2048;
        uint64_t v29 = a1;
        __int16 v30 = 2048;
        Float64 v31 = Seconds;
        __int16 v32 = 2048;
        Float64 v33 = v21;
        __int16 v34 = 2048;
        uint64_t v35 = v25;
        uint64_t v22 = (CMTime *)_os_log_send_and_compose_impl();
        LOBYTE(v17) = v24;
      }
      else
      {
        uint64_t v22 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v22, v22 != &hostTime, v17, 0, v18);
    }
  }
  else
  {
LABEL_22:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

CMTime *CM8021ASClockGetHostTimeForClockTime@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, CMTime *a4@<X8>)
{
  uint64_t v18 = **(void **)(qword_1E9272B78 + 8);
  *(_OWORD *)&a4->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->uint64_t epoch = 0;
  if (!a1) {
    goto LABEL_14;
  }
  CFTypeID v8 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v8 == sFig8021ASClockID && (*(unsigned char *)(a2 + 12) & 1) != 0)
  {
    if (qword_1E9272B78) {
      uint64_t v9 = qword_1E9272B78;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *))(v9 + 48);
    uint64_t v11 = *(void *)(a1 + 48);
    CMTime v17 = *(CMTime *)a2;
    Float64 Seconds = CMTimeGetSeconds(&v17);
    uint64_t v13 = v10(v11, (unint64_t)(Seconds * 1000000000.0), &v18);
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    uint64_t v14 = v18;
    uint64_t v15 = *(void *)(a1 + 56);
    uint64_t result = (CMTime *)FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
    if (v14 == v15 && v13 != -1)
    {
      uint64_t result = CMClockMakeHostTimeFromSystemUnits(a4, v13);
      if (a3) {
        *a3 = v18;
      }
    }
  }
  else
  {
LABEL_14:
    return (CMTime *)FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

CFStringRef CM8021ASClockCopySystemClockIdentifier()
{
  if (sTimeSyncFunctionsLoadedOnce_1 != -1) {
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_1, 0, (dispatch_function_t)LoadTimeSyncFunctions_1);
  }
  if (qword_1E9272B78) {
    uint64_t v0 = qword_1E9272B78;
  }
  else {
    uint64_t v0 = 0;
  }
  uint64_t v1 = (*(uint64_t (**)(void))(v0 + 88))();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"ATSAC:%016llx", v1);
}

BOOL CM8021ASClockIsLocked(uint64_t a1)
{
  return *(_DWORD *)(a1 + 40) == 2;
}

uint64_t CM8021ASClockCopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, void *a4)
{
  v65[16] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    goto LABEL_72;
  }
  CFTypeID v8 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1) {
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  }
  if (v8 != sFig8021ASClockID)
  {
LABEL_72:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v9 = 4294951233;
  if (!a2 || !a4) {
    return v9;
  }
  if (!CFEqual(a2, @"CM8021ASClockDiagnosticString"))
  {
    if (!CFEqual(a2, @"CM8021ASClockMetrics")) {
      return 4294951232;
    }
    if (qword_1E9272B78) {
      uint64_t v13 = qword_1E9272B78;
    }
    else {
      uint64_t v13 = 0;
    }
    if (!*(void *)(v13 + 256)) {
      goto LABEL_31;
    }
    if (qword_1E9272B78) {
      uint64_t v17 = qword_1E9272B78;
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v55 = 0;
    long long v53 = 0u;
    long long v54 = 0u;
    if ((*(unsigned int (**)(void, long long *, uint64_t, void))(v17 + 256))(*(void *)(a1 + 48), &v53, 40, 0))
    {
      uint64_t v18 = 4294951233;
LABEL_30:
      uint64_t v9 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
      goto LABEL_31;
    }
    if (dword_1E9272FF8)
    {
      LODWORD(v50) = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, (int *)&v50, &type);
      unsigned int v20 = v50;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v22 = v20;
      }
      else {
        unsigned int v22 = v20 & 0xFFFFFFFE;
      }
      if (v22)
      {
        *(_DWORD *)uint64_t v56 = 136316162;
        *(void *)&v56[4] = "fig8021ASClock_copyClockMetricsForClock";
        __int16 v57 = 2048;
        uint64_t v58 = v55;
        __int16 v59 = 2048;
        uint64_t v60 = *((void *)&v53 + 1);
        __int16 v61 = 2048;
        uint64_t v62 = v54;
        __int16 v63 = 2048;
        uint64_t v64 = *((void *)&v54 + 1);
        uint64_t v23 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(v20) = v50;
      }
      else
      {
        uint64_t v23 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v23, v23 != v65, v20, 0, v21);
    }
    CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable)
    {
      uint64_t v18 = 4294951231;
      goto LABEL_30;
    }
    int v26 = Mutable;
    CFNumberRef value = FigCFNumberCreateUInt64(v24, v55);
    if (!value)
    {
      uint64_t v9 = FigSignalErrorAt(4294951233, 0, 0, 0, 0, 0, 0);
      goto LABEL_83;
    }
    CFNumberRef cf = FigCFNumberCreateUInt64(v24, *((uint64_t *)&v53 + 1));
    if (cf)
    {
      CFNumberRef UInt64 = FigCFNumberCreateUInt64(v24, v54);
      if (UInt64 && (CFNumberRef v28 = FigCFNumberCreateUInt64(v24, *((uint64_t *)&v54 + 1))) != 0)
      {
        CFNumberRef v29 = v28;
        CFStringRef v30 = CFUUIDCreateString(v24, *(CFUUIDRef *)(a1 + 112));
        CFNumberRef v47 = v29;
        if (v30)
        {
          CFDictionarySetValue(v26, @"CoreAudioReanchors", value);
          CFDictionarySetValue(v26, @"GMChangesCount", cf);
          CFDictionarySetValue(v26, @"TimeToChangeGM", UInt64);
          CFDictionarySetValue(v26, @"TimeToLock", v29);
          CFDictionarySetValue(v26, @"ClockUUID", v30);
          CFDictionaryRef Copy = CFDictionaryCreateCopy(v24, v26);
          if (Copy)
          {
            CFDictionaryRef v32 = Copy;
            if (dword_1E9272FF8 >= 2)
            {
              CFNumberRef v46 = UInt64;
              LODWORD(v50) = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              Float64 v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, (int *)&v50, &type);
              unsigned int v34 = v50;
              if (os_log_type_enabled(v33, type)) {
                unsigned int v36 = v34;
              }
              else {
                unsigned int v36 = v34 & 0xFFFFFFFE;
              }
              if (v36)
              {
                *(_DWORD *)uint64_t v56 = 136315394;
                *(void *)&v56[4] = "fig8021ASClock_copyClockMetricsForClock";
                __int16 v57 = 2112;
                uint64_t v58 = (uint64_t)v32;
                uint64_t v37 = (void *)_os_log_send_and_compose_impl();
                LOBYTE(v34) = v50;
              }
              else
              {
                uint64_t v37 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v37, v37 != v65, v34, 0, v35);
              CFNumberRef UInt64 = v46;
            }
            uint64_t v38 = (__CFDictionary *)CFRetain(v32);
            CFRelease(v26);
            CFRelease(v32);
            CFRelease(value);
            uint64_t v9 = 0;
            goto LABEL_57;
          }
          uint64_t v45 = 4294951231;
LABEL_80:
          uint64_t v9 = FigSignalErrorAt(v45, 0, 0, 0, 0, 0, 0);
          CFRelease(v26);
          CFRelease(value);
          uint64_t v38 = 0;
          int v26 = 0;
          if (!cf)
          {
LABEL_58:
            if (UInt64) {
              CFRelease(UInt64);
            }
            if (v47) {
              CFRelease(v47);
            }
            if (v30) {
              CFRelease(v30);
            }
            if (v9 || !v26)
            {
              if (!v26)
              {
LABEL_31:
                if (v9) {
                  return v9;
                }
                goto LABEL_68;
              }
            }
            else
            {
              CFNumberRef UInt16 = FigCFNumberCreateUInt16(v24, 0);
              if (UInt16)
              {
                CFNumberRef v40 = UInt16;
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), UInt16, v26);
                CFDictionaryRef v41 = *(const __CFDictionary **)(a1 + 72);
                context[0] = MEMORY[0x1E4F143A8];
                context[1] = 0x40000000;
                void context[2] = __fig8021ASClock_getMetricsForClockAndAllPorts_block_invoke;
                _OWORD context[3] = &__block_descriptor_tmp_156;
                context[4] = a1;
                FigCFDictionaryApplyBlock(v41, context);
                CFRelease(v26);
                CFRelease(v40);
LABEL_68:
                CFDictionaryRef v42 = CFDictionaryCreateCopy(a3, *(CFDictionaryRef *)(a1 + 104));
                if (!v42) {
                  return FigSignalErrorAt(4294951231, 0, 0, 0, 0, 0, 0);
                }
                CFDictionaryRef v43 = v42;
                CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 104));
                *a4 = CFRetain(v43);
                CFRelease(v43);
                return 0;
              }
              uint64_t v9 = 0;
            }
LABEL_83:
            CFRelease(v26);
            goto LABEL_31;
          }
LABEL_57:
          CFRelease(cf);
          int v26 = v38;
          goto LABEL_58;
        }
      }
      else
      {
        CFStringRef v30 = 0;
        CFNumberRef v47 = 0;
      }
    }
    else
    {
      CFStringRef v30 = 0;
      CFNumberRef v47 = 0;
      CFNumberRef UInt64 = 0;
    }
    uint64_t v45 = 4294951233;
    goto LABEL_80;
  }
  v65[0] = 0;
  *(void *)uint64_t v56 = 0;
  *(void *)&long long v53 = 0;
  uint64_t v50 = -1;
  context[0] = 0;
  uint64_t v10 = CFStringCreateMutable(a3, 0);
  if (!v10) {
    return 4294951231;
  }
  uint64_t v11 = v10;
  CFStringAppendFormat(v10, 0, @"CM8021ASClock diags: %p\n", a1);
  CFStringAppendFormat(v11, 0, @"CM8021ASClock diags:    timeSyncClock: %p\n", *(void *)(a1 + 48));
  if (qword_1E9272B78) {
    uint64_t v12 = qword_1E9272B78;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v14 = (*(uint64_t (**)(void))(v12 + 88))();
  CFStringAppendFormat(v11, 0, @"CM8021ASClock diags:    ATSAC: %016llx\n", v14);
  if (qword_1E9272B78) {
    uint64_t v15 = qword_1E9272B78;
  }
  else {
    uint64_t v15 = 0;
  }
  if (*(void *)(v15 + 224))
  {
    uint64_t v16 = (*(uint64_t (**)(void, void *, unsigned char *, long long *, void *, uint64_t *))(qword_1E9272B78 + 224))(*(void *)(a1 + 48), v65, v56, &v53, context, &v50);
    CFStringAppendFormat(v11, 0, @"CM8021ASClock diags:     RateAndIdentity: err: %u; numerator: %llu; denominator: %llu; machAnchor: %llu; domainAnchor: %llu; gm: %llu\n",
      v16,
      v65[0],
      *(void *)v56,
      (void)v53,
      context[0],
      v50);
  }
  else
  {
    CFStringAppend(v11, @"CM8021ASClock diags      err: gFTable.functions->pTimeSyncClockGetClockRateAnchorsAndGrandmasterIdentity is NULL\n");
  }
  uint64_t v9 = 0;
  *a4 = v11;
  return v9;
}

double fig8021ASClock_Init(uint64_t a1)
{
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

CFAllocatorRef fig8021ASClock_Finalize(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (dword_1E9272FF8)
  {
    v22[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v22, &type);
    int v3 = v22[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = v3 & 0xFFFFFFFE;
    }
    if (v5)
    {
      v22[1] = 136315394;
      uint64_t v23 = "fig8021ASClock_Finalize";
      __int16 v24 = 2048;
      uint64_t v25 = a1;
      double v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v22[0];
    }
    else
    {
      double v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v6, v6 != &v26, v3, 0, v4);
  }
  uint64_t v7 = *(void *)(a1 + 48);
  if (v7)
  {
    if (qword_1E9272B78) {
      uint64_t v8 = qword_1E9272B78;
    }
    else {
      uint64_t v8 = 0;
    }
    (*(void (**)(uint64_t, void))(v8 + 104))(v7, 0);
    if (qword_1E9272B78) {
      uint64_t v9 = qword_1E9272B78;
    }
    else {
      uint64_t v9 = 0;
    }
    (*(void (**)(void, void, void))(v9 + 96))(*(void *)(a1 + 48), 0, 0);
    if (qword_1E9272B78) {
      uint64_t v10 = qword_1E9272B78;
    }
    else {
      uint64_t v10 = 0;
    }
    (*(void (**)(void))(v10 + 40))(*(void *)(a1 + 48));
  }
  uint64_t v11 = *(pthread_mutex_t **)(a1 + 64);
  if (v11) {
    FigSimpleMutexLock(v11);
  }
  if (*(unsigned char *)(a1 + 96))
  {
    dispatch_async((dispatch_queue_t)gLogMeanIntervalApplier, &__block_literal_global_49);
    *(unsigned char *)(a1 + 96) = 0;
  }
  uint64_t v12 = *(pthread_mutex_t **)(a1 + 64);
  if (v12) {
    FigSimpleMutexUnlock(v12);
  }
  uint64_t v13 = *(const void **)(a1 + 24);
  if (v13) {
    CFRelease(v13);
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 64));
  uint64_t v14 = *(const void **)(a1 + 72);
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = *(const void **)(a1 + 80);
  if (v15) {
    CFRelease(v15);
  }
  uint64_t v16 = *(const void **)(a1 + 88);
  if (v16) {
    CFRelease(v16);
  }
  uint64_t v17 = *(const void **)(a1 + 104);
  if (v17) {
    CFRelease(v17);
  }
  uint64_t v18 = *(const void **)(a1 + 112);
  if (v18) {
    CFRelease(v18);
  }
  unsigned int v19 = *(pthread_mutex_t **)(a1 + 32);
  if (v19)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    FigSimpleMutexUnlock(v19);
  }
  CFAllocatorRef result = *(const __CFAllocator **)(a1 + 16);
  if (result)
  {
    CFAllocatorRef result = FigReadWriteLockDestroy((uint64_t *)result);
    *(void *)(a1 + 16) = 0;
  }
  if (v19) {
    return FigSimpleMutexDestroy((uint64_t)v19);
  }
  return result;
}

uint64_t __timesyncLogMeanIntervalApplier_unregisterClientAndDisposeClockIfNecessary_block_invoke()
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v0 = --dword_1E9272B98;
  if (dword_1E9272FF8 >= 2)
  {
    int v16 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v16, &type);
    int v2 = v16;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v4 = v2;
    }
    else {
      unsigned int v4 = v2 & 0xFFFFFFFE;
    }
    if (v4)
    {
      int v17 = 136315394;
      uint64_t v18 = "timesyncLogMeanIntervalApplier_unregisterClientAndDisposeClockIfNecessary_block_invoke";
      __int16 v19 = 1024;
      LODWORD(v20) = dword_1E9272B98;
      unsigned int v5 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v2) = v16;
    }
    else
    {
      unsigned int v5 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v5, v5 != v21, v2, 0, v3);
    int v0 = dword_1E9272B98;
  }
  uint64_t result = qword_1E9272BA0;
  if (v0 <= 0 && qword_1E9272BA0 != 0)
  {
    if (qword_1E9272B78) {
      uint64_t v8 = qword_1E9272B78;
    }
    else {
      uint64_t v8 = 0;
    }
    (*(void (**)(uint64_t, void))(v8 + 96))(qword_1E9272BA0, 0);
    if (dword_1E9272FF8)
    {
      int v16 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v16, &type);
      int v10 = v16;
      if (os_log_type_enabled(v9, type)) {
        unsigned int v12 = v10;
      }
      else {
        unsigned int v12 = v10 & 0xFFFFFFFE;
      }
      if (v12)
      {
        int v17 = 136315394;
        uint64_t v18 = "timesyncLogMeanIntervalApplier_unregisterClientAndDisposeClockIfNecessary_block_invoke";
        __int16 v19 = 2048;
        uint64_t v20 = qword_1E9272BA0;
        uint64_t v13 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v10) = v16;
      }
      else
      {
        uint64_t v13 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v13, v13 != v21, v10, 0, v11);
    }
    if (qword_1E9272B78) {
      uint64_t v14 = qword_1E9272B78;
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))(v14 + 40))(qword_1E9272BA0);
    qword_1E9272BA0 = 0;
    int v0 = dword_1E9272B98;
  }
  if (v0 < 0) {
    dword_1E9272B98 = 0;
  }
  return result;
}

CFStringRef fig8021ASClock_CopyDesc(uint64_t a1)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = **(void **)(qword_1E9272B78 + 8);
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  if (v2 == v3)
  {
    uint64_t v5 = 0;
    double v6 = "not locked";
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 56);
    double v6 = "locked";
  }
  CFStringRef v7 = CFStringCreateWithFormat(v4, 0, @"CM8021ASClock %s, GM=0x%016llx"), v6, v5);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  return v7;
}

uint64_t timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval(uint64_t a1, int a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  io_iterator_t iterator = 0;
  MEMORY[0x192FC4E00](a1, "IOService", &iterator);
  if (iterator)
  {
    io_object_t v2 = IOIteratorNext(iterator);
    if (v2)
    {
      io_object_t v3 = v2;
      unsigned __int8 v4 = 1;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        if (!IOObjectConformsTo(v3, "IOTimeSyncUnicastUDPv4EtEPort")
          && !IOObjectConformsTo(v3, "IOTimeSyncUnicastUDPv6EtEPort"))
        {
          goto LABEL_60;
        }
        int valuePtr = 0;
        CFPropertdouble y = (const __CFNumber *)IORegistryEntryCreateCFProperty(v3, @"PortRole", v5, 0);
        if (CFProperty) {
          break;
        }
        FigSignalErrorAt(4294954540, 0, 0, 0, 0, 0, 0);
        unsigned __int8 v4 = 0;
LABEL_61:
        io_object_t v3 = IOIteratorNext(iterator);
        if (!v3) {
          goto LABEL_65;
        }
      }
      CFNumberRef v7 = CFProperty;
      CFNumberGetValue(CFProperty, kCFNumberIntType, &valuePtr);
      if ((valuePtr - 1) > 1)
      {
        if (valuePtr == 3 || !valuePtr)
        {
          if (dword_1E9272FF8)
          {
            int v36 = 0;
            os_log_type_t v37 = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v36, &v37);
            int v15 = v36;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v37)) {
              unsigned int v17 = v15;
            }
            else {
              unsigned int v17 = v15 & 0xFFFFFFFE;
            }
            if (v17)
            {
              uint64_t v18 = "disabled";
              if (valuePtr == 3) {
                uint64_t v18 = "master";
              }
              int v40 = 136315650;
              CFDictionaryRef v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
              __int16 v42 = 2048;
              uint64_t v43 = qword_1E9272BA0;
              __int16 v44 = 2080;
              *(void *)uint64_t v45 = v18;
              __int16 v19 = (unsigned char *)_os_log_send_and_compose_impl();
              LOBYTE(v15) = v36;
            }
            else
            {
              __int16 v19 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v19, v19 != v48, v15, 0, v16);
          }
          goto LABEL_59;
        }
      }
      else
      {
        CFNumberRef v8 = (const __CFNumber *)IORegistryEntryCreateCFProperty(v3, @"RemoteSyncLogMeanInterval", v5, 0);
        if (v8)
        {
          CFNumberRef v9 = v8;
          os_log_type_t v37 = OS_LOG_TYPE_DEFAULT;
          CFNumberGetValue(v8, kCFNumberCharType, &v37);
          if (v37 == a2)
          {
            if (dword_1E9272FF8)
            {
              int v36 = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              int v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v36, &type);
              int v11 = v36;
              if (os_log_type_enabled(v10, type)) {
                unsigned int v13 = v11;
              }
              else {
                unsigned int v13 = v11 & 0xFFFFFFFE;
              }
              if (v13)
              {
                int v40 = 136316162;
                CFDictionaryRef v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
                __int16 v42 = 2048;
                uint64_t v43 = qword_1E9272BA0;
                __int16 v44 = 1024;
                *(_DWORD *)uint64_t v45 = v3;
                *(_WORD *)&v45[4] = 1024;
                *(_DWORD *)&v45[6] = valuePtr;
                __int16 v46 = 1024;
                int v47 = a2;
LABEL_41:
                uint64_t v27 = (unsigned char *)_os_log_send_and_compose_impl();
                LOBYTE(v11) = v36;
LABEL_51:
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v27, v27 != v48, v11, 0, v12);
                goto LABEL_58;
              }
              goto LABEL_50;
            }
          }
          else
          {
            if ((char)v37 > a2 || (char)v37 <= OS_LOG_TYPE_DEBUG)
            {
              if (dword_1E9272FF8)
              {
                int v36 = 0;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                CFNumberRef v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v36, &type);
                int v29 = v36;
                if (os_log_type_enabled(v28, type)) {
                  unsigned int v31 = v29;
                }
                else {
                  unsigned int v31 = v29 & 0xFFFFFFFE;
                }
                if (v31)
                {
                  int v40 = 136315906;
                  CFDictionaryRef v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
                  __int16 v42 = 2048;
                  uint64_t v43 = qword_1E9272BA0;
                  __int16 v44 = 1024;
                  *(_DWORD *)uint64_t v45 = (char)v37;
                  *(_WORD *)&v45[4] = 1024;
                  *(_DWORD *)&v45[6] = a2;
                  CFDictionaryRef v32 = (unsigned char *)_os_log_send_and_compose_impl();
                  LOBYTE(v29) = v36;
                }
                else
                {
                  CFDictionaryRef v32 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v32, v32 != v48, v29, 0, v30);
              }
              unsigned __int8 v4 = 0;
              goto LABEL_58;
            }
            if (dword_1E9272FF8)
            {
              int v36 = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              uint64_t v25 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v36, &type);
              int v11 = v36;
              if (os_log_type_enabled(v25, type)) {
                unsigned int v26 = v11;
              }
              else {
                unsigned int v26 = v11 & 0xFFFFFFFE;
              }
              if (v26)
              {
                int v40 = 136316162;
                CFDictionaryRef v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
                __int16 v42 = 2048;
                uint64_t v43 = qword_1E9272BA0;
                __int16 v44 = 1024;
                *(_DWORD *)uint64_t v45 = v3;
                *(_WORD *)&v45[4] = 1024;
                *(_DWORD *)&v45[6] = valuePtr;
                __int16 v46 = 1024;
                int v47 = 3;
                goto LABEL_41;
              }
LABEL_50:
              uint64_t v27 = 0;
              goto LABEL_51;
            }
          }
LABEL_58:
          CFRelease(v9);
          goto LABEL_59;
        }
        if (dword_1E9272FF8)
        {
          int v36 = 0;
          os_log_type_t v37 = OS_LOG_TYPE_DEFAULT;
          uint64_t v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v36, &v37);
          int v21 = v36;
          if (os_log_type_enabled(v20, v37)) {
            unsigned int v23 = v21;
          }
          else {
            unsigned int v23 = v21 & 0xFFFFFFFE;
          }
          if (v23)
          {
            int v40 = 136316162;
            CFDictionaryRef v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
            __int16 v42 = 2048;
            uint64_t v43 = qword_1E9272BA0;
            __int16 v44 = 1024;
            *(_DWORD *)uint64_t v45 = v3;
            *(_WORD *)&v45[4] = 1024;
            *(_DWORD *)&v45[6] = valuePtr;
            __int16 v46 = 1024;
            int v47 = a2;
            __int16 v24 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v21) = v36;
          }
          else
          {
            __int16 v24 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v24, v24 != v48, v21, 0, v22);
        }
      }
      unsigned __int8 v4 = 0;
LABEL_59:
      CFRelease(v7);
LABEL_60:
      IOObjectRelease(v3);
      goto LABEL_61;
    }
    unsigned __int8 v4 = 1;
LABEL_65:
    IOObjectRelease(iterator);
  }
  else
  {
    FigSignalErrorAt(4294954540, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v4;
}

uint64_t fig8021ASClock_portsDictionaryValueReleaseCallback(uint64_t a1, uint64_t a2)
{
  if (qword_1E9272B78) {
    uint64_t v3 = qword_1E9272B78;
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(uint64_t))(v3 + 200))(a2);
}

uint64_t fig8021ASClock_copyCFTypeRepresentationOfAddress(UInt8 *bytes, int a2, CFDataRef *a3)
{
  uint64_t result = 4294954550;
  if (bytes && a3)
  {
    if (a2 == 30)
    {
      CFDataRef UInt32 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 16);
      if (!UInt32) {
        return 4294954549;
      }
    }
    else
    {
      if (a2 != 2)
      {
        CFDataRef v7 = 0;
        uint64_t result = 4294954550;
        goto LABEL_10;
      }
      CFDataRef UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(_DWORD *)bytes);
      if (!UInt32) {
        return 4294954549;
      }
    }
    CFDataRef v7 = UInt32;
    uint64_t result = 0;
LABEL_10:
    *a3 = v7;
  }
  return result;
}

uint64_t fig8021ASClock_copyPortMetricsForPortIfValid(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(qword_1E9272B78 + 264)) {
    return 4294951233;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  if (UInt16)
  {
    CFNumberRef v8 = UInt16;
    memset(v50, 0, 138);
    if ((*(unsigned int (**)(void, uint64_t, int64x2_t *, uint64_t, void))(qword_1E9272B78 + 264))(*(void *)(a1 + 48), a2, v50, 138, 0))
    {
      uint64_t v9 = 4294951233;
LABEL_5:
      uint64_t v10 = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
LABEL_6:
      CFNumberRef v11 = v8;
LABEL_59:
      CFRelease(v11);
      return v10;
    }
    v12.i64[1] = *(uint64_t *)((char *)&v50[6].i64[1] + 2);
    v13.i64[0] = *(uint64_t *)((char *)v50[6].i64 + 2);
    v13.i64[1] = *(uint64_t *)((char *)&v50[7].i64[1] + 2);
    v12.i64[0] = *(uint64_t *)((char *)v50[7].i64 + 2);
    v14.i64[0] = *(uint64_t *)((char *)&v50[5].i64[1] + 2);
    v14.i64[1] = *(uint64_t *)((char *)&v50[0].i64[1] + 2);
    if ((vmaxv_u8((uint8x8_t)vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64(v12), (int32x4_t)vceqzq_s64(v13)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64(v14), (int32x4_t)vceqzq_s64(*(int64x2_t *)((char *)&v50[1] + 2))))))) & 1) == 0&& !*(uint64_t *)((char *)v50[8].i64 + 2)&& !*(uint64_t *)((char *)v50[0].i64 + 2))
    {
      uint64_t v10 = 0;
      goto LABEL_6;
    }
    if (dword_1E9272FF8)
    {
      int v49 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v49, &type);
      int v16 = v49;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v18 = v16;
      }
      else {
        unsigned int v18 = v16 & 0xFFFFFFFE;
      }
      if (v18)
      {
        int v51 = 136317954;
        uint64_t v52 = "fig8021ASClock_copyPortMetricsForPortIfValid";
        __int16 v53 = 2048;
        CFDictionaryRef v54 = *(CFDictionaryRef *)((char *)&v50[6].i64[1] + 2);
        __int16 v55 = 2048;
        uint64_t v56 = *(uint64_t *)((char *)v50[7].i64 + 2);
        __int16 v57 = 2048;
        uint64_t v58 = *(uint64_t *)((char *)v50[6].i64 + 2);
        __int16 v59 = 2048;
        uint64_t v60 = *(uint64_t *)((char *)&v50[7].i64[1] + 2);
        __int16 v61 = 2048;
        uint64_t v62 = *(uint64_t *)((char *)&v50[5].i64[1] + 2);
        __int16 v63 = 2048;
        uint64_t v64 = *(uint64_t *)((char *)&v50[0].i64[1] + 2);
        __int16 v65 = 2048;
        uint64_t v66 = *(uint64_t *)((char *)v50[1].i64 + 2);
        __int16 v67 = 2048;
        uint64_t v68 = *(uint64_t *)((char *)&v50[1].i64[1] + 2);
        __int16 v69 = 1024;
        int v70 = v50[0].u16[0];
        __int16 v71 = 2048;
        uint64_t v72 = *(uint64_t *)((char *)v50[8].i64 + 2);
        __int16 v73 = 2048;
        uint64_t v74 = *(uint64_t *)((char *)v50[0].i64 + 2);
        __int16 v19 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v16) = v49;
      }
      else
      {
        __int16 v19 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v19, v19 != v75, v16, 0, v17);
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable)
    {
      uint64_t v9 = 4294951231;
      goto LABEL_5;
    }
    CFMutableDictionaryRef v21 = Mutable;
    CFNumberRef value = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v50[6].i64[1] + 2));
    if (!value)
    {
      uint64_t v10 = FigSignalErrorAt(4294951233, 0, 0, 0, 0, 0, 0);
      CFRelease(v21);
      goto LABEL_6;
    }
    CFNumberRef cf = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v50[7].i64 + 2));
    if (!cf)
    {
      CFNumberRef v23 = 0;
      CFNumberRef v24 = 0;
      CFNumberRef v27 = 0;
      CFNumberRef v35 = 0;
      CFNumberRef v36 = 0;
      CFNumberRef v37 = 0;
      CFNumberRef v45 = 0;
      CFStringRef v40 = 0;
      CFNumberRef UInt64 = 0;
LABEL_70:
      uint64_t v39 = 4294951233;
      goto LABEL_79;
    }
    CFNumberRef UInt64 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v50[6].i64 + 2));
    if (UInt64)
    {
      CFNumberRef v23 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v50[7].i64[1] + 2));
      if (v23)
      {
        CFNumberRef v24 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v50[5].i64[1] + 2));
        if (v24)
        {
          CFNumberRef v41 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v50[0].i64[1] + 2));
          if (v41)
          {
            CFNumberRef v44 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v50[1].i64 + 2));
            if (!v44)
            {
              CFNumberRef v35 = 0;
              CFNumberRef v36 = 0;
              CFNumberRef v37 = 0;
              CFNumberRef v45 = 0;
              CFStringRef v40 = 0;
              uint64_t v39 = 4294951233;
              CFNumberRef v27 = v41;
              goto LABEL_79;
            }
            CFNumberRef v43 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v50[1].i64[1] + 2));
            if (!v43)
            {
              CFNumberRef v36 = 0;
              CFNumberRef v37 = 0;
              CFNumberRef v45 = 0;
              CFStringRef v40 = 0;
              uint64_t v39 = 4294951233;
              CFNumberRef v27 = v41;
              CFNumberRef v35 = v44;
              goto LABEL_79;
            }
            CFNumberRef v42 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v50[8].i64 + 2));
            if (!v42)
            {
              CFNumberRef v37 = 0;
              CFNumberRef v45 = 0;
              CFStringRef v40 = 0;
              uint64_t v39 = 4294951233;
              CFNumberRef v27 = v41;
              CFNumberRef v36 = v43;
              CFNumberRef v35 = v44;
              goto LABEL_79;
            }
            CFNumberRef v45 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v50[0].i64 + 2));
            if (v45)
            {
              CFStringRef v25 = CFUUIDCreateString(v6, *(CFUUIDRef *)(a1 + 112));
              if (v25)
              {
                CFStringRef v26 = v25;
                CFDictionarySetValue(v21, @"DiscardedDelayLimitExceededPercentage", value);
                CFDictionarySetValue(v21, @"DiscardedOutOfBoundsPercentage", cf);
                CFDictionarySetValue(v21, @"DiscardedPpmLimitPercentage", UInt64);
                CFDictionarySetValue(v21, @"DiscardedTimestampsOutOfOrderPercentage", v23);
                CFDictionarySetValue(v21, @"DroppedPercentage", v24);
                CFNumberRef v27 = v41;
                CFDictionarySetValue(v21, @"FilterResetsDroppedLimit", v41);
                CFDictionarySetValue(v21, @"FilterResetsOutOfBounds", v44);
                CFDictionarySetValue(v21, @"MeanDelayTime", v43);
                CFDictionarySetValue(v21, @"SuccessfulPercentage", v42);
                CFDictionarySetValue(v21, @"SyncTimeouts", v45);
                CFStringRef v40 = v26;
                CFDictionarySetValue(v21, @"ClockUUID", v26);
                CFDictionaryRef Copy = CFDictionaryCreateCopy(v6, v21);
                if (Copy)
                {
                  CFDictionaryRef v29 = Copy;
                  if (dword_1E9272FF8 >= 2)
                  {
                    int v49 = 0;
                    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                    uint64_t v30 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v49, &type);
                    int v31 = v49;
                    if (os_log_type_enabled(v30, type)) {
                      unsigned int v33 = v31;
                    }
                    else {
                      unsigned int v33 = v31 & 0xFFFFFFFE;
                    }
                    if (v33)
                    {
                      int v51 = 136315394;
                      uint64_t v52 = "fig8021ASClock_copyPortMetricsForPortIfValid";
                      __int16 v53 = 2112;
                      CFDictionaryRef v54 = v29;
                      unsigned int v34 = (unsigned char *)_os_log_send_and_compose_impl();
                      LOBYTE(v31) = v49;
                    }
                    else
                    {
                      unsigned int v34 = 0;
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v34, v34 != v75, v31, 0, v32);
                    CFNumberRef v27 = v41;
                  }
                  *a3 = CFRetain(v29);
                  CFRelease(v21);
                  CFRelease(v29);
                  CFRelease(value);
                  uint64_t v10 = 0;
                  CFNumberRef v36 = v43;
                  CFNumberRef v35 = v44;
                  CFNumberRef v37 = v42;
                  goto LABEL_41;
                }
                uint64_t v39 = 4294951231;
                goto LABEL_78;
              }
            }
            else
            {
              CFNumberRef v45 = 0;
            }
            CFStringRef v40 = 0;
            uint64_t v39 = 4294951233;
            CFNumberRef v27 = v41;
LABEL_78:
            CFNumberRef v36 = v43;
            CFNumberRef v35 = v44;
            CFNumberRef v37 = v42;
LABEL_79:
            uint64_t v10 = FigSignalErrorAt(v39, 0, 0, 0, 0, 0, 0);
            CFRelease(v21);
            CFRelease(value);
            if (!cf)
            {
LABEL_42:
              if (UInt64) {
                CFRelease(UInt64);
              }
              if (v23) {
                CFRelease(v23);
              }
              if (v24) {
                CFRelease(v24);
              }
              if (v27) {
                CFRelease(v27);
              }
              if (v35) {
                CFRelease(v35);
              }
              if (v36) {
                CFRelease(v36);
              }
              if (v37) {
                CFRelease(v37);
              }
              if (v45) {
                CFRelease(v45);
              }
              CFRelease(v8);
              CFNumberRef v11 = (CFNumberRef)v40;
              if (!v40) {
                return v10;
              }
              goto LABEL_59;
            }
LABEL_41:
            CFRelease(cf);
            goto LABEL_42;
          }
        }
        goto LABEL_69;
      }
    }
    else
    {
      CFNumberRef v23 = 0;
    }
    CFNumberRef v24 = 0;
LABEL_69:
    CFNumberRef v27 = 0;
    CFNumberRef v35 = 0;
    CFNumberRef v36 = 0;
    CFNumberRef v37 = 0;
    CFNumberRef v45 = 0;
    CFStringRef v40 = 0;
    goto LABEL_70;
  }

  return FigSignalErrorAt(4294951233, 0, 0, 0, 0, 0, 0);
}

void __timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  gLogMeanIntervalApplier = (uint64_t)FigDispatchQueueCreateWithPriority("com.apple.coremedia.8021as.gLogMeanIntervalApplier.applierQueue", 0, 0x27u);
  if (gLogMeanIntervalApplier)
  {
    byte_1E9272B90 = -3;
    *(void *)&dword_1E9272B94 = 0xFFFFFFFFLL;
    word_1E9272BA8 = 0;
    if (dword_1E9272FF8)
    {
      v6[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v6, &type);
      int v1 = v6[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v3 = v1;
      }
      else {
        unsigned int v3 = v1 & 0xFFFFFFFE;
      }
      if (v3)
      {
        v6[1] = 136315138;
        CFDataRef v7 = "timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_block_invoke";
        unsigned __int8 v4 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v1) = v6[0];
      }
      else
      {
        unsigned __int8 v4 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v4, v4 != &v8, v1, 0, v2);
    }
  }
}

void timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  ++dword_1E9272B98;
  if (dword_1E9272FF8 >= 2)
  {
    int v18 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v18, &type);
    int v3 = v18;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = v3 & 0xFFFFFFFE;
    }
    if (v5)
    {
      int v19 = 136315394;
      uint64_t v20 = "timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal";
      __int16 v21 = 1024;
      LODWORD(v22) = dword_1E9272B98;
      CFAllocatorRef v6 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v18;
    }
    else
    {
      CFAllocatorRef v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v6, v6 != v23, v3, 0, v4);
  }
  if (!qword_1E9272BA0)
  {
    if (qword_1E9272B78) {
      uint64_t v7 = qword_1E9272B78;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 88))(a1, a2);
    if (v8 == **(void **)qword_1E9272B78
      || (uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(qword_1E9272B78 + 32))(v8, v9),
          (qword_1E9272BA0 = v10) == 0))
    {
      FigSignalErrorAt(4294951236, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      if (qword_1E9272B78) {
        uint64_t v11 = qword_1E9272B78;
      }
      else {
        uint64_t v11 = 0;
      }
      (*(void (**)(uint64_t, void, uint64_t))(v11 + 96))(v10, timesyncLogMeanIntervalApplier_lockStateChangedCallback, v10);
      byte_1E9272B90 = -3;
      dword_1E9272B94 = -1;
      if (dword_1E9272FF8)
      {
        int v18 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        int64x2_t v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, &v18, &type);
        int v13 = v18;
        if (os_log_type_enabled(v12, type)) {
          unsigned int v15 = v13;
        }
        else {
          unsigned int v15 = v13 & 0xFFFFFFFE;
        }
        if (v15)
        {
          int v19 = 136315394;
          uint64_t v20 = "timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal";
          __int16 v21 = 2048;
          uint64_t v22 = qword_1E9272BA0;
          int v16 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v13) = v18;
        }
        else
        {
          int v16 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v16, v16 != v23, v13, 0, v14);
      }
    }
  }
}

void timesyncLogMeanIntervalApplier_lockStateChangedCallback(uint64_t a1, uint64_t a2, int a3)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __timesyncLogMeanIntervalApplier_lockStateChangedCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_127;
  void block[4] = a2;
  void block[5] = a1;
  int v4 = a3;
  dispatch_async((dispatch_queue_t)gLogMeanIntervalApplier, block);
}

void __timesyncLogMeanIntervalApplier_lockStateChangedCallback_block_invoke(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (qword_1E9272BA0 && *(void *)(a1 + 32) == qword_1E9272BA0)
  {
    if (dword_1E9272FF8)
    {
      v10[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v10, &type);
      int v3 = v10[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v5 = v3;
      }
      else {
        unsigned int v5 = v3 & 0xFFFFFFFE;
      }
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        int v7 = *(_DWORD *)(a1 + 48);
        v10[1] = 136315906;
        uint64_t v11 = "timesyncLogMeanIntervalApplier_lockStateChangedCallback_block_invoke";
        __int16 v12 = 2048;
        uint64_t v13 = v6;
        __int16 v14 = 1024;
        int v15 = v7;
        __int16 v16 = 1024;
        int v17 = dword_1E9272B94;
        uint64_t v8 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v10[0];
      }
      else
      {
        uint64_t v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v8, v8 != &v18, v3, 0, v4);
    }
    if (dword_1E9272B94 != *(_DWORD *)(a1 + 48))
    {
      dword_1E9272B94 = *(_DWORD *)(a1 + 48);
      timesyncLogMeanIntervalApplier_restartIntervalApplierInternal();
    }
  }
}

void timesyncLogMeanIntervalApplier_restartIntervalApplierInternal()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (word_1E9272BA8 <= 0)
  {
    if (dword_1E9272FF8 >= 2)
    {
      v6[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v6, &type);
      int v1 = v6[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v3 = v1;
      }
      else {
        unsigned int v3 = v1 & 0xFFFFFFFE;
      }
      if (v3)
      {
        v6[1] = 136315138;
        int v7 = "timesyncLogMeanIntervalApplier_restartIntervalApplierInternal";
        uint64_t v4 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v1) = v6[0];
      }
      else
      {
        uint64_t v4 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v4, v4 != &v8, v1, 0, v2);
    }
    dispatch_async_f((dispatch_queue_t)gLogMeanIntervalApplier, 0, (dispatch_function_t)timesyncLogMeanIntervalApplier_applyIntervalInternal);
  }
  word_1E9272BA8 = 100;
}

void timesyncLogMeanIntervalApplier_applyIntervalInternal()
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  int v0 = &sLoadBrowserFrameworkOnce;
  if (!qword_1E9272BA0) {
    goto LABEL_82;
  }
  char v1 = byte_1E9272B90;
  if (dword_1E9272B94 != 2) {
    char v1 = -3;
  }
  unsigned int v47 = v1;
  if (dword_1E9272FF8)
  {
    io_iterator_t iterator = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, (int *)&iterator, type);
    io_iterator_t v3 = iterator;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = v3 & 0xFFFFFFFE;
    }
    if (v5)
    {
      uint64_t v6 = "not locked";
      if (dword_1E9272B94 == 2) {
        uint64_t v6 = "locked";
      }
      int v51 = 136316418;
      uint64_t v52 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
      __int16 v53 = 2048;
      uint64_t v54 = qword_1E9272BA0;
      __int16 v55 = 2080;
      uint64_t v56 = v6;
      __int16 v57 = 1024;
      int v58 = dword_1E9272B94;
      __int16 v59 = 1024;
      unsigned int v60 = v47;
      __int16 v61 = 1024;
      int v62 = word_1E9272BA8;
      int v7 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = iterator;
    }
    else
    {
      int v7 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v7, v7 != v63, v3, 0, v4);
  }
  mach_port_t v8 = dword_1E9272BAC;
  if (!dword_1E9272BAC)
  {
    if (qword_1E9272B78) {
      uint64_t v9 = qword_1E9272B78;
    }
    else {
      uint64_t v9 = 0;
    }
    (*(void (**)(uint64_t, void))(v9 + 232))(qword_1E9272BA0, v47);
    if (MEMORY[0x192FC4D70](*MEMORY[0x1E4F14960], &dword_1E9272BAC)) {
      goto LABEL_82;
    }
    mach_port_t v8 = dword_1E9272BAC;
  }
  CFDictionaryRef v10 = IOServiceMatching("IOTimeSyncgPTPManager");
  uint64_t MatchingService = IOServiceGetMatchingService(v8, v10);
  if (MatchingService)
  {
    uint64_t v12 = MatchingService;
    io_iterator_t iterator = 0;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFPropertdouble y = IORegistryEntryCreateCFProperty(MatchingService, @"SystemDomainIdentifier", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    MEMORY[0x192FC4E00](v12, "IOService", &iterator);
    int v15 = 0;
    if (iterator && CFProperty)
    {
      uint64_t v16 = IOIteratorNext(iterator);
      if (v16)
      {
        uint64_t v17 = v16;
        int v15 = 0;
        while (!IOObjectConformsTo(v17, "IOTimeSyncDomain"))
        {
LABEL_62:
          IOObjectRelease(v17);
          uint64_t v17 = IOIteratorNext(iterator);
          if (!v17) {
            goto LABEL_71;
          }
        }
        CFTypeRef v18 = IORegistryEntryCreateCFProperty(v17, @"ClockIdentifier", v13, 0);
        if (FigCFEqual(v18, CFProperty))
        {
          CFTypeRef v19 = IORegistryEntryCreateCFProperty(v17, @"GrandmasterID", v13, 0);
          if (FigCFEqual(CFProperty, v19) && dword_1E9272B94 == 2)
          {
            if (*((_DWORD *)v0 + 1022))
            {
              *(_DWORD *)os_log_type_t type = 0;
              os_log_type_t v48 = OS_LOG_TYPE_DEFAULT;
              uint64_t v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, (int *)type, &v48);
              unsigned int v21 = *(_DWORD *)type;
              if (os_log_type_enabled(v20, v48)) {
                unsigned int v23 = v21;
              }
              else {
                unsigned int v23 = v21 & 0xFFFFFFFE;
              }
              if (v23)
              {
                int v51 = 136315394;
                uint64_t v52 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
                __int16 v53 = 2048;
                uint64_t v54 = qword_1E9272BA0;
                uint64_t v24 = (unsigned char *)_os_log_send_and_compose_impl();
                LOBYTE(v21) = type[0];
              }
              else
              {
                uint64_t v24 = 0;
              }
              int v15 = 1;
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v24, v24 != v63, v21, 0, v22);
              int v0 = &sLoadBrowserFrameworkOnce;
              if (!v19) {
                goto LABEL_60;
              }
            }
            else
            {
              int v15 = 1;
              if (!v19) {
                goto LABEL_60;
              }
            }
          }
          else
          {
            if (qword_1E9272B78) {
              uint64_t v25 = qword_1E9272B78;
            }
            else {
              uint64_t v25 = 0;
            }
            int v26 = (*(uint64_t (**)(uint64_t, void))(v25 + 240))(v17, v47);
            int v27 = *((_DWORD *)v0 + 1022);
            if (v26)
            {
              int v15 = v26;
              if (v27)
              {
                *(_DWORD *)os_log_type_t type = 0;
                os_log_type_t v48 = OS_LOG_TYPE_DEFAULT;
                CFNumberRef v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, (int *)type, &v48);
                unsigned int v29 = *(_DWORD *)type;
                if (os_log_type_enabled(v28, v48)) {
                  unsigned int v31 = v29;
                }
                else {
                  unsigned int v31 = v29 & 0xFFFFFFFE;
                }
                if (v31)
                {
                  int v51 = 136315394;
                  uint64_t v52 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
                  __int16 v53 = 2048;
                  uint64_t v54 = qword_1E9272BA0;
                  uint64_t v32 = (unsigned char *)_os_log_send_and_compose_impl();
                  LOBYTE(v29) = type[0];
                }
                else
                {
                  uint64_t v32 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v32, v32 != v63, v29, 0, v30);
                int v0 = &sLoadBrowserFrameworkOnce;
              }
              if (!v19) {
                goto LABEL_60;
              }
            }
            else
            {
              if (v27)
              {
                *(_DWORD *)os_log_type_t type = 0;
                os_log_type_t v48 = OS_LOG_TYPE_DEFAULT;
                unsigned int v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, (int *)type, &v48);
                unsigned int v34 = *(_DWORD *)type;
                if (os_log_type_enabled(v33, v48)) {
                  unsigned int v36 = v34;
                }
                else {
                  unsigned int v36 = v34 & 0xFFFFFFFE;
                }
                if (v36)
                {
                  int v51 = 136315650;
                  uint64_t v52 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
                  __int16 v53 = 2048;
                  uint64_t v54 = qword_1E9272BA0;
                  __int16 v55 = 1024;
                  LODWORD(v56) = v47;
                  CFNumberRef v37 = (unsigned char *)_os_log_send_and_compose_impl();
                  LOBYTE(v34) = type[0];
                }
                else
                {
                  CFNumberRef v37 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v37, v37 != v63, v34, 0, v35);
                int v0 = &sLoadBrowserFrameworkOnce;
              }
              if (qword_1E9272B78) {
                uint64_t v38 = qword_1E9272B78;
              }
              else {
                uint64_t v38 = 0;
              }
              (*(void (**)(uint64_t, void))(v38 + 232))(qword_1E9272BA0, v47);
              int v15 = 0;
              if (!v19) {
                goto LABEL_60;
              }
            }
          }
          CFRelease(v19);
        }
LABEL_60:
        if (v18) {
          CFRelease(v18);
        }
        goto LABEL_62;
      }
      int v15 = 0;
    }
    else
    {
LABEL_71:
      if (!CFProperty) {
        goto LABEL_76;
      }
    }
    CFRelease(CFProperty);
LABEL_76:
    if (iterator) {
      IOObjectRelease(iterator);
    }
    IOObjectRelease(v12);
    goto LABEL_79;
  }
  int v15 = 0;
LABEL_79:
  __int16 v39 = --word_1E9272BA8;
  if (v15 || v39 < 1) {
    goto LABEL_83;
  }
  dispatch_time_t v40 = dispatch_time(0, 1000000000);
  dispatch_after_f(v40, (dispatch_queue_t)gLogMeanIntervalApplier, 0, (dispatch_function_t)timesyncLogMeanIntervalApplier_applyIntervalInternal);
LABEL_82:
  int v15 = 0;
LABEL_83:
  if (v15 || (qword_1E9272BA0 ? (BOOL v41 = word_1E9272BA8 <= 0) : (BOOL v41 = 1), v41))
  {
    if (*((_DWORD *)v0 + 1022) >= 2u)
    {
      io_iterator_t iterator = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      CFNumberRef v42 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, (int *)&iterator, type);
      io_iterator_t v43 = iterator;
      if (os_log_type_enabled(v42, type[0])) {
        unsigned int v45 = v43;
      }
      else {
        unsigned int v45 = v43 & 0xFFFFFFFE;
      }
      if (v45)
      {
        int v51 = 136315138;
        uint64_t v52 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
        __int16 v46 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v43) = iterator;
      }
      else
      {
        __int16 v46 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v46, v46 != v63, v43, 0, v44);
    }
    word_1E9272BA8 = 0;
    if (dword_1E9272BAC)
    {
      IOObjectRelease(dword_1E9272BAC);
      dword_1E9272BAC = 0;
    }
  }
}

void __timesyncLogMeanIntervalApplier_setIntervalAndApplyIfDifferent_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (qword_1E9272BA0)
  {
    if (dword_1E9272FF8)
    {
      v9[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272FF0, 1, v9, &type);
      int v3 = v9[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v5 = v3;
      }
      else {
        unsigned int v5 = v3 & 0xFFFFFFFE;
      }
      if (v5)
      {
        int v6 = *(char *)(a1 + 32);
        v9[1] = 136315650;
        CFDictionaryRef v10 = "timesyncLogMeanIntervalApplier_setIntervalAndApplyIfDifferent_block_invoke";
        __int16 v11 = 1024;
        int v12 = v6;
        __int16 v13 = 1024;
        int v14 = byte_1E9272B90;
        int v7 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v9[0];
      }
      else
      {
        int v7 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272FF0, 1u, 1, v7, v7 != &v15, v3, 0, v4);
    }
    if (byte_1E9272B90 != *(unsigned char *)(a1 + 32))
    {
      byte_1E9272B90 = *(unsigned char *)(a1 + 32);
      timesyncLogMeanIntervalApplier_restartIntervalApplierInternal();
    }
  }
}

void __fig8021ASClock_getMetricsForClockAndAllPorts_block_invoke(uint64_t a1, uint64_t a2, const __CFNumber *a3)
{
  CFTypeRef v9 = 0;
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t UInt16 = FigCFNumberGetUInt16(a3);
  fig8021ASClock_copyPortMetricsForPortIfValid(v5, UInt16, &v9);
  int v7 = *(void **)(*(void *)(a1 + 32) + 104);
  CFTypeRef v8 = v9;
  FigCFDictionarySetValue(v7, a3, v9);
  if (v8)
  {
    CFRelease(v8);
  }
}

uint64_t FigTransportDiscoveryGetTypeID()
{
  if (FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryInitOnce != -1) {
    dispatch_once(&FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryInitOnce, &__block_literal_global_50);
  }
  return FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryTypeID;
}

uint64_t __FigTransportDiscoveryGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryuint64_t TypeID = result;
  return result;
}

uint64_t FigTransportDiscoveryGetSharedDiscovery()
{
  if (FigTransportDiscoveryGetSharedDiscovery_sCreateSharedDiscoveryOnce != -1) {
    dispatch_once(&FigTransportDiscoveryGetSharedDiscovery_sCreateSharedDiscoveryOnce, &__block_literal_global_10_1);
  }
  return FigTransportDiscoveryGetSharedDiscovery_sSharedDiscovery;
}

CFMutableArrayRef __FigTransportDiscoveryGetSharedDiscovery_block_invoke()
{
  if (FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryInitOnce != -1) {
    dispatch_once(&FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryInitOnce, &__block_literal_global_50);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = dispatch_queue_create("com.apple.coremedia.transportdiscovery", 0);
  CFMutableArrayRef result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  *(void *)(Instance + 32) = result;
  FigTransportDiscoveryGetSharedDiscovery_sSharedDiscoverdouble y = Instance;
  return result;
}

void *FigTransportDiscoveryAddEventHandler(void *a1, NSObject *a2, const void *a3)
{
  int v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10A0040FC6C5850uLL);
  if (!a2) {
    a2 = MEMORY[0x1E4F14428];
  }
  *(_DWORD *)int v6 = FigAtomicIncrement32(ftd_MakeHandler_sIdentifier);
  v6[1] = a2;
  dispatch_retain(a2);
  int v6[2] = _Block_copy(a3);
  CFRetain(a1);
  int v7 = a1[2];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  int v9[2] = __FigTransportDiscoveryAddEventHandler_block_invoke;
  v9[3] = &__block_descriptor_tmp_12_3;
  v9[4] = a1;
  v9[5] = v6;
  dispatch_async(v7, v9);
  return v6;
}

void __FigTransportDiscoveryAddEventHandler_block_invoke(uint64_t a1)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(a1 + 32) + 32), *(const void **)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 32);
  int v3 = (void *)v2[7];
  if (v3)
  {
    do
    {
      ftd_PostEvent(*(const void **)(a1 + 32), *(int **)(a1 + 40), 1, (uint64_t)v3);
      int v3 = (void *)*v3;
    }
    while (v3);
    uint64_t v2 = *(void **)(a1 + 32);
  }

  CFRelease(v2);
}

uint64_t ftd_PostEvent(const void *a1, int *a2, int a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)IOSurfaceRef buffer = 0u;
  long long v22 = 0u;
  CFIndex usedBufLen = 0;
  if (a4)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable) {
      return 4294955254;
    }
    CFTypeRef v9 = Mutable;
    CFDictionarySetValue(Mutable, @"deviceID", *(const void **)(a4 + 32));
    CFDictionarySetValue(v9, @"deviceRef", *(const void **)(a4 + 16));
    CFIndex usedBufLen = 0;
    uint64_t Length = CFStringGetLength(*(CFStringRef *)(a4 + 32));
    if (Length >= 8) {
      v11.length = 8;
    }
    else {
      v11.length = Length;
    }
    v11.location = 0;
    CFStringGetBytes(*(CFStringRef *)(a4 + 32), v11, 0x8000100u, 0, 0, buffer, 128, &usedBufLen);
    buffer[usedBufLen] = 0;
    CFStringRef v12 = CFStringCreateWithCString(0, (const char *)buffer, 0x8000100u);
    if (v12)
    {
      CFStringRef v13 = v12;
      CFDictionarySetValue(v9, @"deviceName", v12);
      CFRelease(v13);
    }
  }
  else
  {
    CFTypeRef v9 = 0;
  }
  CFRetain(a1);
  int v14 = *a2;
  char v15 = *((void *)a2 + 1);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __ftd_PostEvent_block_invoke;
  block[3] = &__block_descriptor_tmp_43_1;
  void block[4] = a1;
  void block[5] = a2;
  int v18 = v14;
  int v19 = a3;
  void block[6] = v9;
  dispatch_async(v15, block);
  return 0;
}

void FigTransportDiscoveryRemoveEventHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  void v3[2] = __FigTransportDiscoveryRemoveEventHandler_block_invoke;
  v3[3] = &__block_descriptor_tmp_13_6;
  v3[4] = a1;
  v3[5] = a2;
  dispatch_sync(v2, v3);
}

void __FigTransportDiscoveryRemoveEventHandler_block_invoke(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(*(void *)(a1 + 32) + 32);
  v7.length = CFArrayGetCount(v2);
  v7.location = 0;
  FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v2, v7, *(const void **)(a1 + 40));
  if (FirstIndexOfValue != -1)
  {
    CFIndex v4 = FirstIndexOfValue;
    ftd_FreeHandler(*(void **)(a1 + 40));
    uint64_t v5 = *(__CFArray **)(*(void *)(a1 + 32) + 32);
    CFArrayRemoveValueAtIndex(v5, v4);
  }
}

void ftd_FreeHandler(void *a1)
{
  if (a1)
  {
    *(_DWORD *)a1 = 0;
    dispatch_release(*((dispatch_object_t *)a1 + 1));
    _Block_release(*((const void **)a1 + 2));
    free(a1);
  }
}

void FigTransportDiscoveryStart(void *a1)
{
  CFRetain(a1);
  CFArrayRef v2 = a1[2];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigTransportDiscoveryStart_block_invoke;
  block[3] = &__block_descriptor_tmp_14_4;
  void block[4] = a1;
  dispatch_async(v2, block);
}

void __FigTransportDiscoveryStart_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 24);
  if (v3 < 1)
  {
    v15[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v15, &type);
    int v5 = v15[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      v15[1] = 136315138;
      uint64_t v16 = "ftd_Start";
      CFTypeRef v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v15[0];
    }
    else
    {
      CFTypeRef v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v8, v8 != &v17, v5, 0, v6);
    CFMutableDictionaryRef v9 = IOServiceMatching("IOUSBInterface");
    if (v9)
    {
      CFDictionaryRef v10 = v9;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!Mutable) {
        goto LABEL_15;
      }
      CFStringRef v12 = Mutable;
      CFDictionarySetInt64(Mutable, @"idVendor", 1452);
      CFDictionarySetInt64(v12, @"bInterfaceClass", 255);
      CFDictionarySetInt64(v12, @"bInterfaceSubClass", 42);
      CFDictionarySetInt64(v12, @"bInterfaceProtocol", 255);
      CFDictionarySetValue(v10, @"IOPropertyMatch", v12);
      CFRelease(v12);
      CFStringRef v13 = IONotificationPortCreate(*MEMORY[0x1E4F2EEF0]);
      *(void *)(v2 + 40) = v13;
      if (v13)
      {
        IONotificationPortSetDispatchQueue(v13, *(dispatch_queue_t *)(v2 + 16));
        if (!IOServiceAddMatchingNotification(*(IONotificationPortRef *)(v2 + 40), "IOServiceFirstMatch", v10, (IOServiceMatchingCallback)ftd_Attached, (void *)v2, (io_iterator_t *)(v2 + 48)))
        {
          CFRetain((CFTypeRef)v2);
          ++*(_DWORD *)(v2 + 24);
          ftd_Attached(v2, *(_DWORD *)(v2 + 48));
          goto LABEL_14;
        }
      }
      else
      {
LABEL_15:
        CFRelease(v10);
      }
    }
    ftd_Stop(v2);
    goto LABEL_14;
  }
  *(_DWORD *)(v2 + 24) = v3 + 1;
LABEL_14:
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void FigTransportDiscoveryStop(void *a1)
{
  CFRetain(a1);
  uint64_t v2 = a1[2];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigTransportDiscoveryStop_block_invoke;
  block[3] = &__block_descriptor_tmp_15_4;
  void block[4] = a1;
  dispatch_async(v2, block);
}

void __FigTransportDiscoveryStop_block_invoke(uint64_t a1)
{
  ftd_Stop(*(void *)(a1 + 32));
  uint64_t v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

void ftd_Stop(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v13[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v13, &type);
  int v3 = v13[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v5 = v3;
  }
  else {
    unsigned int v5 = v3 & 0xFFFFFFFE;
  }
  if (v5)
  {
    v13[1] = 136315138;
    int v14 = "ftd_Stop";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v3) = v13[0];
  }
  else
  {
    uint64_t v6 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v6, v6 != &v15, v3, 0, v4);
  int v7 = *(_DWORD *)(a1 + 24);
  BOOL v8 = __OFSUB__(v7--, 1);
  *(_DWORD *)(a1 + 24) = v7;
  if ((v7 < 0) ^ v8 | (v7 == 0))
  {
    while (1)
    {
      CFMutableDictionaryRef v9 = *(void **)(a1 + 56);
      if (!v9) {
        break;
      }
      *(void *)(a1 + 56) = *v9;
      ftd_FreeDevice(v9);
    }
    io_object_t v10 = *(_DWORD *)(a1 + 48);
    if (v10)
    {
      IOObjectRelease(v10);
      *(_DWORD *)(a1 + 48) = 0;
      CFRelease((CFTypeRef)a1);
    }
    CFRange v11 = *(IONotificationPort **)(a1 + 40);
    if (v11)
    {
      IONotificationPortDestroy(v11);
      *(void *)(a1 + 40) = 0;
    }
    ftd_PostEventOnAllHandlers((CFArrayRef *)a1, 3, 0);
  }
}

double ftd_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void ftd_Finalize(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 32)) >= 1)
  {
    CFIndex v3 = 0;
    do
    {
      ValueAtIndedouble x = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), v3);
      ftd_FreeHandler(ValueAtIndex);
      ++v3;
    }
    while (CFArrayGetCount(*(CFArrayRef *)(a1 + 32)) > v3);
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 32));
  unsigned int v5 = *(const void **)(a1 + 32);
  if (v5)
  {
    CFRelease(v5);
  }
}

void CFDictionarySetInt64(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  char v11 = 0;
  __int16 v10 = 0;
  int v9 = 0;
  if (a3 == (char)a3)
  {
    char v11 = a3;
    p_uint64_t valuePtr = (uint64_t *)&v11;
    CFNumberType v6 = kCFNumberSInt8Type;
  }
  else
  {
    p_uint64_t valuePtr = &valuePtr;
    CFNumberType v6 = kCFNumberSInt64Type;
  }
  CFNumberRef v7 = CFNumberCreate(0, v6, p_valuePtr);
  if (v7)
  {
    CFNumberRef v8 = v7;
    CFDictionarySetValue(a1, a2, v7);
    CFRelease(v8);
  }
}

uint64_t ftd_Attached(uint64_t a1, io_iterator_t iterator)
{
  uint64_t result = IOIteratorNext(iterator);
  if (result)
  {
    io_registry_entry_t v5 = result;
    while (1)
    {
      int valuePtr = 0;
      CFPropertdouble y = (const __CFNumber *)IORegistryEntryCreateCFProperty(v5, @"idProduct", 0, 0);
      CFNumberGetValue(CFProperty, kCFNumberIntType, &valuePtr);
      if (CFProperty) {
        CFRelease(CFProperty);
      }
      if ((valuePtr & 0xFFF0u) - 4752 > 0x20 || ((1 << ((valuePtr & 0xF0u) + 112)) & 0x100010001) == 0) {
        goto LABEL_16;
      }
      io_registry_entry_t parent = 0;
      if (IORegistryEntryGetParentEntry(v5, "IOService", &parent)) {
        break;
      }
      CFNumberRef v8 = malloc_type_calloc(1uLL, 0x28uLL, 0x1060040EFD7669EuLL);
      int v9 = (io_object_t *)v8;
      if (!v8) {
        goto LABEL_19;
      }
      if (FigCFIOKitObjectCreate(v8 + 2, v5)) {
        goto LABEL_19;
      }
      *((void *)v9 + 4) = IORegistryEntryCreateCFProperty(parent, @"kUSBSerialNumberString", 0, 0);
      IOObjectRelease(parent);
      __int16 v10 = (const void *)*((void *)v9 + 4);
      if (!v10) {
        goto LABEL_19;
      }
      CFTypeID v11 = CFGetTypeID(v10);
      if (v11 != CFStringGetTypeID()
        || IOServiceAddInterestNotification(*(IONotificationPortRef *)(a1 + 40), v5, "IOGeneralInterest", (IOServiceInterestCallback)ftd_Detached, v9, v9 + 6))
      {
        goto LABEL_19;
      }
      CFRetain((CFTypeRef)a1);
      *(void *)int v9 = *(void *)(a1 + 56);
      *((void *)v9 + 1) = a1;
      *(void *)(a1 + 56) = v9;
      ftd_FreeDevice(0);
      ftd_PostEventOnAllHandlers((CFArrayRef *)a1, 1, (uint64_t)v9);
LABEL_16:
      IOObjectRelease(v5);
      uint64_t result = IOIteratorNext(iterator);
      io_registry_entry_t v5 = result;
      if (!result) {
        return result;
      }
    }
    int v9 = 0;
LABEL_19:
    ftd_FreeDevice(v9);
    goto LABEL_16;
  }
  return result;
}

CFIndex ftd_PostEventOnAllHandlers(CFArrayRef *a1, int a2, uint64_t a3)
{
  CFIndex result = CFArrayGetCount(a1[4]);
  if (result >= 1)
  {
    for (CFIndex i = 0; i < result; ++i)
    {
      ValueAtIndedouble x = (int *)CFArrayGetValueAtIndex(a1[4], i);
      CFIndex result = ftd_PostEvent(a1, ValueAtIndex, a2, a3);
      if (result) {
        break;
      }
      CFIndex result = CFArrayGetCount(a1[4]);
    }
  }
  return result;
}

void ftd_Detached(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -536870896)
  {
    uint64_t v4 = (void *)(*(void *)(a1 + 8) + 56);
    while (1)
    {
      io_registry_entry_t v5 = v4;
      uint64_t v4 = (void *)*v4;
      if (!v4) {
        break;
      }
      if (v4 == (void *)a1)
      {
        *io_registry_entry_t v5 = *(void *)a1;
        ftd_PostEventOnAllHandlers(*(CFArrayRef **)(a1 + 8), 2, a1);
        ftd_FreeDevice((void *)a1);
        return;
      }
    }
  }
}

void ftd_FreeDevice(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[4];
    if (v2)
    {
      CFRelease(v2);
      a1[4] = 0;
    }
    io_object_t v3 = *((_DWORD *)a1 + 6);
    if (v3)
    {
      IOObjectRelease(v3);
      *((_DWORD *)a1 + 6) = 0;
    }
    uint64_t v4 = (const void *)a1[2];
    if (v4)
    {
      CFRelease(v4);
      a1[2] = 0;
    }
    io_registry_entry_t v5 = (const void *)a1[1];
    if (v5) {
      CFRelease(v5);
    }
    free(a1);
  }
}

uint64_t FigTransportCreateBBufFromPointer(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  uint64_t v4 = a2;
  return FigCreateBlockBufferCopyingMemoryBlock(a1, &v4, 8uLL, a3);
}

uint64_t FigTransportCreateCFNumberFromRemoteObjectRef(uint64_t a1, uint64_t a2, CFNumberRef *a3)
{
  uint64_t valuePtr = a2;
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (!v4) {
    return 4294955266;
  }
  CFNumberRef v5 = v4;
  uint64_t result = 0;
  *a3 = v5;
  return result;
}

uint64_t FigTransportGetRemoteObjectRefFromCFNumber(const void *a1, void *a2)
{
  if (!a1) {
    return 4294955259;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  uint64_t v5 = 4294955259;
  if (v4 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, a2)) {
      return 0;
    }
    else {
      return 4294955259;
    }
  }
  return v5;
}

uint64_t FigTransportCreateCFNumberFromLocalObjectRef(uint64_t a1, uint64_t a2, CFNumberRef *a3)
{
  uint64_t valuePtr = a2;
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (!v4) {
    return 4294955266;
  }
  CFNumberRef v5 = v4;
  uint64_t result = 0;
  *a3 = v5;
  return result;
}

uint64_t FigTransportGetLocalObjectRefFromCFNumber(const void *a1, void *a2)
{
  uint64_t valuePtr = 0;
  if (!a1) {
    return 4294955259;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, &valuePtr)) {
    return 4294955259;
  }
  uint64_t result = 0;
  *a2 = valuePtr;
  return result;
}

uint64_t FigTransportCreateBBufFromRemoteObjectRef(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  uint64_t v4 = a2;
  return FigCreateBlockBufferCopyingMemoryBlock(a1, &v4, 8uLL, a3);
}

uint64_t FigTransportGetRemoteObjectRefFromBBuf(OpaqueCMBlockBuffer *a1, void *destination)
{
  return CMBlockBufferCopyDataBytes(a1, 0, 8uLL, destination);
}

uint64_t FigJSONObjectCreateWithData(uint64_t a1, unsigned int a2, CFTypeRef *a3)
{
  CFErrorRef err = 0;
  uint64_t v3 = 4294949992;
  if (a1 && a3)
  {
    Class Class = objc_getClass("NSJSONSerialization");
    if (Class && (v8 = Class, (SEL v9 = sel_registerName("JSONObjectWithData:options:error:")) != 0))
    {
      __int16 v10 = v9;
      uint64_t v11 = a2;
      CFStringRef v12 = (void *)MEMORY[0x192FC5D30]();
      id v13 = objc_msgSend(v8, v10, a1, v11, &err);
      if (v13)
      {
        uint64_t v3 = 0;
        *a3 = CFRetain(v13);
      }
      else
      {
        uint64_t v3 = 4294949991;
        if (err)
        {
          CFIndex Code = CFErrorGetCode(err);
          if (Code == (int)Code) {
            uint64_t v3 = Code;
          }
          else {
            uint64_t v3 = 4294949991;
          }
        }
      }
      if (v12) {
    }
      }
    else
    {
      return 4294949991;
    }
  }
  return v3;
}

id FigIsValidJSONObject(uint64_t a1)
{
  Class Class = objc_getClass("NSJSONSerialization");
  if (!Class) {
    return 0;
  }
  Class v3 = Class;
  SEL v4 = sel_registerName("isValidJSONObject:");
  if (!v4) {
    return 0;
  }
  CFNumberRef v5 = v4;
  CFNumberType v6 = (void *)MEMORY[0x192FC5D30]();
  id v7 = objc_msgSend(v3, v5, a1);
  if (v6) {
  return v7;
  }
}

uint64_t FigCFDataCreateWithJSONObject(uint64_t a1, unsigned int a2, CFTypeRef *a3)
{
  CFErrorRef err = 0;
  uint64_t v3 = 4294949992;
  if (a1 && a3)
  {
    Class Class = objc_getClass("NSJSONSerialization");
    if (Class && (v8 = Class, (SEL v9 = sel_registerName("dataWithJSONObject:options:error:")) != 0))
    {
      __int16 v10 = v9;
      uint64_t v11 = (void *)MEMORY[0x192FC5D30]();
      id v12 = objc_msgSend(v8, v10, a1, a2, &err);
      if (v12)
      {
        uint64_t v3 = 0;
        *a3 = CFRetain(v12);
      }
      else
      {
        uint64_t v3 = 4294949991;
        if (err)
        {
          CFIndex Code = CFErrorGetCode(err);
          if (Code == (int)Code) {
            uint64_t v3 = Code;
          }
          else {
            uint64_t v3 = 4294949991;
          }
        }
      }
      if (v11) {
    }
      }
    else
    {
      return 4294949991;
    }
  }
  return v3;
}

uint64_t FigEndpointStreamGetClassID()
{
  if (FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce, &FigEndpointStreamGetClassID_sFigEndpointStreamClassID, (dispatch_function_t)stream_getClassID_0);
  }
  return FigEndpointStreamGetClassID_sFigEndpointStreamClassID;
}

uint64_t stream_getClassID_0(void *a1)
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&stream_getClassID_sFigEndpointStreamClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointStreamGetTypeID()
{
  if (FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce, &FigEndpointStreamGetClassID_sFigEndpointStreamClassID, (dispatch_function_t)stream_getClassID_0);
  }
  int v0 = (void *)FigEndpointStreamGetClassID_sFigEndpointStreamClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef stream_copyFormattingDesc_0(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointStream %p]", a1);
}

uint64_t FigCPEFairPlayCryptorGetClassID()
{
  return sFigCPEFairPlayCryptorClassID;
}

uint64_t RegisterFigFairPlayCPECryptorType()
{
  ClassIOSurfaceID ID = (void *)FigCPECryptorGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigCPEFairPlayCryptorClassDesc, ClassID, 0, &sFigCPEFairPlayCryptorClassID);
}

CFTypeRef FigCPEFairPlayCryptorCopyFormattingDesc()
{
  return CFRetain(@"[FigCPEFPCryptor]");
}

uint64_t FigByteStreamCreateWithIOSurface(IOSurfaceRef buffer, size_t a2, char a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  return _createByteStreamWithIOSurface(a5, buffer, a2, 0, a3, a4, a6);
}

uint64_t _createByteStreamWithIOSurface(uint64_t a1, IOSurfaceRef buffer, size_t a3, int a4, char a5, uint64_t a6, CFTypeRef *a7)
{
  CFTypeRef cf = 0;
  IOSurfaceLockOptions v7 = a4 == 0;
  if (a6 || !buffer || (char v11 = a4, IOSurfaceGetAllocSize(buffer) < a3))
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    if (IOSurfaceLock(buffer, v7, 0)) {
      return 4294954422;
    }
    ClassIOSurfaceID ID = (void *)CMByteStreamGetClassID();
    uint64_t v15 = CMDerivedObjectCreate(a1, (uint64_t)&kFigIOSurfaceByteStreamVTable, ClassID, &cf);
    if (v15)
    {
      uint64_t v18 = v15;
      IOSurfaceUnlock(buffer, v7, 0);
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      char v17 = (__IOSurface *)CFRetain(buffer);
      *(void *)uint64_t DerivedStorage = v17;
      *(void *)(DerivedStorage + 8) = a3;
      if (a5)
      {
        *(void *)(DerivedStorage + 8) = IOSurfaceGetAllocSize(buffer);
        char v17 = *(__IOSurface **)DerivedStorage;
      }
      *(unsigned char *)(DerivedStorage + 16) = v11;
      IOSurfaceIncrementUseCount(v17);
      uint64_t v18 = 0;
      *a7 = cf;
    }
    return v18;
  }
}

uint64_t FigByteStreamCreateWritableWithIOSurface(IOSurfaceRef buffer, size_t a2, char a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  return _createByteStreamWithIOSurface(a5, buffer, a2, 1, a3, a4, a6);
}

BOOL FigIOSurfaceByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  return *DerivedStorage == *(void *)CMBaseObjectGetDerivedStorage(a2);
}

void FigIOSurfaceByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(void *)DerivedStorage)
  {
    IOSurfaceUnlock(*(IOSurfaceRef *)DerivedStorage, *(unsigned char *)(DerivedStorage + 16) == 0, 0);
    IOSurfaceDecrementUseCount(*(IOSurfaceRef *)DerivedStorage);
    if (*(void *)DerivedStorage) {
      CFRelease(*(CFTypeRef *)DerivedStorage);
    }
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 24);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(DerivedStorage + 32);
  if (v3) {
    CFRelease(v3);
  }
  SEL v4 = *(const void **)(DerivedStorage + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t FigIOSurfaceByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"FBS_EntireLength") || CFEqual(a2, @"FBS_AvailableLength"))
  {
    CFNumberRef SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)(DerivedStorage + 8));
LABEL_4:
    Class v8 = SInt64;
LABEL_5:
    uint64_t result = 0;
    *a4 = v8;
    return result;
  }
  if (CFEqual(a2, @"FBS_EntireLengthAvailableOnDemand"))
  {
    __int16 v10 = (const void *)*MEMORY[0x1E4F1CFD0];
LABEL_8:
    CFNumberRef SInt64 = (void *)CFRetain(v10);
    goto LABEL_4;
  }
  if (CFEqual(a2, @"FBS_URL"))
  {
    __int16 v10 = *(const void **)(DerivedStorage + 24);
    if (v10) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_FileType"))
  {
    __int16 v10 = *(const void **)(DerivedStorage + 40);
    if (v10) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_MIMEType"))
  {
    __int16 v10 = *(const void **)(DerivedStorage + 32);
    if (v10) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_ReadSupported"))
  {
    char v11 = (const void **)MEMORY[0x1E4F1CFD0];
    goto LABEL_23;
  }
  if (CFEqual(a2, @"FBS_WriteSupported"))
  {
    char v11 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!*(unsigned char *)(DerivedStorage + 16)) {
      char v11 = (const void **)MEMORY[0x1E4F1CFC8];
    }
LABEL_23:
    __int16 v10 = *v11;
    if (!*v11)
    {
      Class v8 = 0;
      goto LABEL_5;
    }
    goto LABEL_8;
  }

  return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
}

uint64_t FigIOSurfaceByteStreamSetProperty(const void *a1, const void *a2, const __CFString *a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (CFEqual(a2, @"FBS_URL"))
  {
    if (a3)
    {
      CFTypeID v7 = CFGetTypeID(a3);
      if (v7 == CFURLGetTypeID())
      {
        Class v8 = (const void *)DerivedStorage[3];
        DerivedStorage[3] = a3;
        goto LABEL_9;
      }
      goto LABEL_27;
    }
    Class v8 = (const void *)DerivedStorage[3];
    DerivedStorage[3] = 0;
    if (!v8) {
      return 0;
    }
LABEL_21:
    CFRelease(v8);
    return 0;
  }
  if (CFEqual(a2, @"FBS_FileType"))
  {
    if (a3)
    {
      CFTypeID v9 = CFGetTypeID(a3);
      if (v9 == CFNumberGetTypeID())
      {
        Class v8 = (const void *)DerivedStorage[5];
        DerivedStorage[5] = a3;
LABEL_9:
        CFRetain(a3);
        if (!v8) {
          return 0;
        }
        goto LABEL_21;
      }
      goto LABEL_27;
    }
    Class v8 = (const void *)DerivedStorage[5];
    DerivedStorage[5] = 0;
    if (!v8) {
      return 0;
    }
    goto LABEL_21;
  }
  if (CFEqual(a2, @"FBS_MIMEType"))
  {
    if (!a3 || (CFTypeID v10 = CFGetTypeID(a3), v10 == CFStringGetTypeID()))
    {
      char v11 = (const void *)DerivedStorage[4];
      if (v11)
      {
        CFRelease(v11);
        DerivedStorage[4] = 0;
      }
      if (a3)
      {
        CFAllocatorRef v12 = CFGetAllocator(a1);
        DerivedStorage[4] = CFStringCreateCopy(v12, a3);
      }
      return 0;
    }
LABEL_27:
    uint64_t v14 = 4294954424;
    goto LABEL_24;
  }
  uint64_t v14 = 4294954512;
LABEL_24:

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigIOSurfaceByteStreamRead(uint64_t a1, size_t a2, uint64_t a3, void *a4, size_t *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (a2)
  {
    if (a3 < 0)
    {
      uint64_t result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
      a2 = 0;
      if (!a5) {
        return result;
      }
      goto LABEL_9;
    }
    uint64_t v11 = *(void *)(DerivedStorage + 8);
    BOOL v12 = v11 <= a3;
    size_t v13 = v11 - a3;
    if (v12) {
      return 4294954423;
    }
    if (v13 < a2) {
      a2 = v13;
    }
    if (a2)
    {
      BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)DerivedStorage);
      memcpy(a4, &BaseAddress[a3], a2);
    }
  }
  uint64_t result = 0;
  if (!a5) {
    return result;
  }
LABEL_9:
  if (!result) {
    *a5 = a2;
  }
  return result;
}

uint64_t FigIOSurfaceByteStreamWrite(uint64_t a1, size_t a2, uint64_t a3, const void *a4, size_t *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (!*(unsigned char *)(DerivedStorage + 16))
  {
    uint64_t v16 = 4294954419;
    goto LABEL_17;
  }
  if (!a4 || a3 < 0)
  {
    uint64_t v16 = 4294954424;
LABEL_17:
    uint64_t result = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  if (a2)
  {
    uint64_t v11 = DerivedStorage;
    size_t AllocSize = IOSurfaceGetAllocSize(*(IOSurfaceRef *)DerivedStorage);
    if (((AllocSize - a3) & ~((uint64_t)(AllocSize - a3) >> 63)) < a2) {
      a2 = (AllocSize - a3) & ~((uint64_t)(AllocSize - a3) >> 63);
    }
    if (!a2) {
      return 4294954423;
    }
    BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)v11);
    memcpy(&BaseAddress[a3], a4, a2);
    uint64_t result = 0;
    size_t v15 = *(void *)(v11 + 8);
    if (v15 <= a2 + a3) {
      size_t v15 = a2 + a3;
    }
    *(void *)(v11 + 8) = v15;
  }
  else
  {
    uint64_t result = 0;
  }
LABEL_11:
  if (a5)
  {
    if (!result) {
      *a5 = a2;
    }
  }
  return result;
}

uint64_t FigIOSurfaceByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (a3)
  {
    *a3 = (*(void *)(DerivedStorage + 8) - a2) & ~((*(void *)(DerivedStorage + 8) - a2) >> 63);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigIOSurfaceByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, uint64_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  CFAllocatorRef v10 = CFGetAllocator(a1);

  return CMCreateContiguousBlockBufferFromStream((uint64_t)a1, v10, a2, a3, a4, a5);
}

uint64_t FigHALAudioPluginGetClassID()
{
  if (FigHALAudioPluginGetClassID_sRegisterFigHALAudioPluginClassOnce != -1) {
    dispatch_once(&FigHALAudioPluginGetClassID_sRegisterFigHALAudioPluginClassOnce, &__block_literal_global_51);
  }
  return FigHALAudioPluginGetClassID_sFigHALAudioPluginClassID;
}

uint64_t __FigHALAudioPluginGetClassID_block_invoke()
{
  ClassIOSurfaceID ID = (void *)FigHALAudioObjectGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigHALAudioPluginGetClassID_sFigHALAudioPluginClassDesc, ClassID, 0, &FigHALAudioPluginGetClassID_sFigHALAudioPluginClassID);
}

uint64_t FigCaptionPositionGetTypeID()
{
  return sFigCaptionPositionID;
}

uint64_t RegisterFigCaptionPositionType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionPositionIOSurfaceID ID = result;
  return result;
}

uint64_t FigCaptionPositionGetHorizontalEdgeReference(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 16);
  }
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetHorizontalEdgeOffset(uint64_t a1)
{
  if (a1)
  {
    char v1 = (uint64_t *)(a1 + 24);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    char v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionPositionGetVerticalEdgeReference(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 20);
  }
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetVerticalEdgeOffset(uint64_t a1)
{
  if (a1)
  {
    char v1 = (uint64_t *)(a1 + 40);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    char v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionPositionGetEffectiveHorizontalEdgeReference(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 56);
  }
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetEffectiveHorizontalEdgeOffset(uint64_t a1)
{
  if (a1)
  {
    char v1 = (uint64_t *)(a1 + 64);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    char v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionPositionGetEffectiveVerticalEdgeReference(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 60);
  }
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetEffectiveVerticalEdgeOffset(uint64_t a1)
{
  if (a1)
  {
    char v1 = (uint64_t *)(a1 + 80);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    char v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionAbstractPositionEqualToAbstractPosition(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v4 = 0;
  if (!a1 || !a2) {
    return v4;
  }
  if (a3) {
    char v6 = a3;
  }
  else {
    char v6 = 27;
  }
  if (v6)
  {
    uint64_t v4 = *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16);
    if ((v6 & 2) != 0)
    {
LABEL_9:
      if (*(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20)) {
        uint64_t v4 = v4;
      }
      else {
        uint64_t v4 = 0;
      }
    }
  }
  else
  {
    uint64_t v4 = 1;
    if ((v6 & 2) != 0) {
      goto LABEL_9;
    }
  }
  if ((v6 & 8) == 0)
  {
    if ((v6 & 0x10) == 0) {
      return v4;
    }
    goto LABEL_22;
  }
  if (FigGeometryDimensionEqualToDimension(*(void *)(a1 + 24), *(void *)(a1 + 32), *(void *)(a2 + 24), *(void *)(a2 + 32)))
  {
    uint64_t v4 = v4;
  }
  else
  {
    uint64_t v4 = 0;
  }
  if ((v6 & 0x10) != 0)
  {
LABEL_22:
    if (FigGeometryDimensionEqualToDimension(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a2 + 40), *(void *)(a2 + 48)))
    {
      return v4;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t FigCaptionPositionCreate(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  if (a8)
  {
    FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (!Instance)
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    uint64_t v17 = Instance;
    *(void *)(Instance + 24) = a3;
    *(void *)(Instance + 32) = a4;
    uint64_t v18 = (_OWORD *)(Instance + 24);
    *(void *)(Instance + 40) = a6;
    int v19 = (_OWORD *)(Instance + 40);
    *(_DWORD *)(Instance + 16) = a2;
    *(_DWORD *)(Instance + 20) = a5;
    *(void *)(Instance + 48) = a7;
    *(_OWORD *)(Instance + 64) = *(_OWORD *)(Instance + 24);
    *(_DWORD *)(Instance + 56) = a2;
    *(_DWORD *)(Instance + 60) = a5;
    *(_OWORD *)(Instance + 80) = *(_OWORD *)(Instance + 40);
    int v20 = a2 != 0;
    if (a2) {
      int v21 = 2;
    }
    else {
      int v21 = 1;
    }
    if ((a4 & 0x1D00000000) == 0x100000000) {
      int v20 = v21;
    }
    if (a5) {
      ++v20;
    }
    if ((a7 & 0x1D00000000) == 0x100000000) {
      int v22 = v20 + 1;
    }
    else {
      int v22 = v20;
    }
    *(unsigned char *)(Instance + 96) = v22;
    long long v23 = (_OWORD *)(Instance + 64);
    switch(v22)
    {
      case 0:
        goto LABEL_107;
      case 1:
        if (a2)
        {
          int v24 = 1919510376;
          if (a2 == 1919510376 || (int v24 = 1818584692, a2 == 1818584692))
          {
            *(_DWORD *)(Instance + 56) = v24;
LABEL_18:
            int v25 = 1667591796;
LABEL_19:
            *(_DWORD *)(Instance + 60) = v25;
            goto LABEL_107;
          }
        }
        else if (a5 > 1667591795)
        {
          int v25 = 1667591796;
          if (a5 == 1667591796)
          {
            *(_DWORD *)(Instance + 56) = 1667591796;
            goto LABEL_19;
          }
          if (a5 == 1953460256)
          {
            *(_DWORD *)(Instance + 56) = 1667591796;
            int v25 = 1953460256;
            goto LABEL_19;
          }
        }
        else
        {
          if (!a5)
          {
            *long long v23 = *v18;
            goto LABEL_18;
          }
          if (a5 == 1651471476)
          {
            *(_DWORD *)(Instance + 56) = 1667591796;
            int v25 = 1651471476;
            goto LABEL_19;
          }
        }
        goto LABEL_107;
      case 2:
        FigGeometryDimensionMake();
        uint64_t v29 = v28;
        uint64_t v31 = v30;
        FigGeometryDimensionMake();
        uint64_t v33 = v32;
        uint64_t v35 = v34;
        FigGeometryDimensionMake();
        *(void *)(v17 + 56) = 0x746F70206C656674;
        int v38 = *(_DWORD *)(v17 + 16);
        if (v38 <= 1818584691)
        {
          if (!v38)
          {
            int v45 = *(_DWORD *)(v17 + 20);
            if (v45 > 1667591795) {
              goto LABEL_60;
            }
            if (v45)
            {
              int v49 = 1651471476;
              goto LABEL_62;
            }
            goto LABEL_52;
          }
          if (v38 != 1667591796) {
            goto LABEL_107;
          }
          int v39 = *(_DWORD *)(v17 + 20);
          if (v39 > 1667591795)
          {
            if (v39 == 1667591796) {
              goto LABEL_100;
            }
            if (v39 == 1953460256)
            {
              *(void *)(v17 + 64) = v33;
              *(void *)(v17 + 72) = v35;
              goto LABEL_73;
            }
            goto LABEL_107;
          }
          if (!v39)
          {
            *(void *)(v17 + 64) = v33;
            *(void *)(v17 + 72) = v35;
            goto LABEL_104;
          }
          if (v39 != 1651471476) {
            goto LABEL_107;
          }
          *(void *)(v17 + 64) = v33;
          *(void *)(v17 + 72) = v35;
          goto LABEL_98;
        }
        if (v38 != 1919510376)
        {
          if (v38 != 1818584692) {
            goto LABEL_107;
          }
          int v47 = *(_DWORD *)(v17 + 20);
          if (v47 <= 1667591795)
          {
            if (!v47) {
              goto LABEL_76;
            }
            if (v47 == 1651471476)
            {
              *(void *)(v17 + 64) = v29;
              *(void *)(v17 + 72) = v31;
              goto LABEL_98;
            }
            goto LABEL_107;
          }
          if (v47 == 1667591796)
          {
            *(void *)(v17 + 64) = v29;
            *(void *)(v17 + 72) = v31;
            goto LABEL_106;
          }
          if (v47 != 1953460256) {
            goto LABEL_107;
          }
          *(void *)(v17 + 64) = v29;
          *(void *)(v17 + 72) = v31;
          goto LABEL_73;
        }
        int v50 = *(_DWORD *)(v17 + 20);
        if (v50 > 1667591795)
        {
          if (v50 == 1667591796) {
            goto LABEL_100;
          }
          if (v50 == 1953460256)
          {
            *(void *)(v17 + 64) = v36;
            *(void *)(v17 + 72) = v37;
            goto LABEL_73;
          }
        }
        else
        {
          if (!v50) {
            goto LABEL_79;
          }
          if (v50 == 1651471476) {
            goto LABEL_97;
          }
        }
        goto LABEL_107;
      case 3:
        FigGeometryDimensionMake();
        uint64_t v29 = v40;
        uint64_t v31 = v41;
        FigGeometryDimensionMake();
        uint64_t v33 = v42;
        uint64_t v35 = v43;
        FigGeometryDimensionMake();
        *(void *)(v17 + 56) = 0x746F70206C656674;
        int v44 = *(_DWORD *)(v17 + 16);
        if ((*(_DWORD *)(v17 + 36) & 0x1D) == 1)
        {
          if (v44 == 1919510376)
          {
            int v51 = *(_DWORD *)(v17 + 20);
            if (v51 == 1651471476)
            {
              *(_DWORD *)(v17 + 56) = 1919510376;
LABEL_97:
              *(void *)(v17 + 64) = v36;
              *(void *)(v17 + 72) = v37;
              goto LABEL_98;
            }
            if (v51 != 1667591796)
            {
              if (v51 != 1953460256) {
                goto LABEL_107;
              }
              *(_DWORD *)(v17 + 56) = 1919510376;
              goto LABEL_72;
            }
            *(_DWORD *)(v17 + 56) = 1919510376;
LABEL_100:
            *(void *)(v17 + 64) = v33;
            *(void *)(v17 + 72) = v35;
          }
          else
          {
            if (v44 != 1818584692) {
              goto LABEL_107;
            }
            int v45 = *(_DWORD *)(v17 + 20);
            if (v45 == 1651471476)
            {
              *long long v23 = *v18;
LABEL_98:
              *(void *)(v17 + 80) = v36;
              *(void *)(v17 + 88) = v37;
              goto LABEL_107;
            }
LABEL_60:
            if (v45 != 1667591796)
            {
              int v49 = 1953460256;
LABEL_62:
              if (v45 != v49) {
                goto LABEL_107;
              }
LABEL_72:
              *long long v23 = *v18;
LABEL_73:
              *(void *)(v17 + 80) = v29;
              *(void *)(v17 + 88) = v31;
              goto LABEL_107;
            }
            *long long v23 = *v18;
          }
LABEL_106:
          *(void *)(v17 + 80) = v33;
          *(void *)(v17 + 88) = v35;
LABEL_107:
          uint64_t v27 = 0;
          *a8 = v17;
          return v27;
        }
        switch(v44)
        {
          case 1667591796:
            int v48 = *(_DWORD *)(v17 + 20);
            if (v48 == 1651471476)
            {
              *(void *)(v17 + 64) = v29;
              *(void *)(v17 + 72) = v31;
              goto LABEL_102;
            }
            break;
          case 1919510376:
            int v52 = *(_DWORD *)(v17 + 20);
            if (v52 != 1651471476)
            {
              if (v52 != 1953460256) {
                goto LABEL_107;
              }
LABEL_79:
              *(void *)(v17 + 64) = v36;
              *(void *)(v17 + 72) = v37;
              goto LABEL_104;
            }
            goto LABEL_92;
          case 1818584692:
            int v48 = *(_DWORD *)(v17 + 20);
            if (v48 == 1651471476)
            {
LABEL_92:
              *(void *)(v17 + 64) = v36;
              *(void *)(v17 + 72) = v37;
LABEL_102:
              *(_DWORD *)(v17 + 60) = 1651471476;
LABEL_104:
              *(_OWORD *)((char *)v18 + 56) = *v19;
              goto LABEL_107;
            }
            break;
          default:
            goto LABEL_107;
        }
        if (v48 != 1953460256) {
          goto LABEL_107;
        }
LABEL_76:
        *(void *)(v17 + 64) = v29;
        *(void *)(v17 + 72) = v31;
        goto LABEL_104;
      case 4:
        *(void *)(Instance + 56) = 0x746F70206C656674;
        if (a2 == 1919510376)
        {
          if (a5 == 1953460256) {
            goto LABEL_52;
          }
          int v46 = 1651471476;
        }
        else
        {
          if (a2 != 1818584692) {
            goto LABEL_107;
          }
          if (a5 == 1651471476) {
            goto LABEL_52;
          }
          int v46 = 1953460256;
        }
        if (a5 != v46) {
          goto LABEL_107;
        }
LABEL_52:
        *long long v23 = *v18;
        goto LABEL_104;
      default:
        uint64_t v26 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        if (!v26) {
          goto LABEL_107;
        }
        uint64_t v27 = v26;
        CFRelease((CFTypeRef)v17);
        return v27;
    }
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

double fcpos_Init(uint64_t a1)
{
  *(void *)(a1 + 96) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

BOOL fcpos_Equal(BOOL result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
    double result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionPositionID)
      {
        CFTypeID v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
        if (v5 == sFigCaptionPositionID
          && *(_DWORD *)(v3 + 16) == *(_DWORD *)(a2 + 16)
          && *(_DWORD *)(v3 + 20) == *(_DWORD *)(a2 + 20))
        {
          double result = FigGeometryDimensionEqualToDimension(*(void *)(v3 + 24), *(void *)(v3 + 32), *(void *)(a2 + 24), *(void *)(a2 + 32));
          if (result) {
            return FigGeometryDimensionEqualToDimension(*(void *)(v3 + 40), *(void *)(v3 + 48), *(void *)(a2 + 40), *(void *)(a2 + 48));
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

const void *fcpos_Hash(const void *result)
{
  if (result)
  {
    char v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
    if (v2 == sFigCaptionPositionID)
    {
      uint64_t v3 = (*((_DWORD *)v1 + 5) ^ *((_DWORD *)v1 + 4));
      uint64_t v4 = FigGeometryDimensionHash(*((void *)v1 + 3), *((void *)v1 + 4));
      return (const void *)(v4 ^ FigGeometryDimensionHash(*((void *)v1 + 5), *((void *)v1 + 6)) ^ v3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFStringRef fcpos_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionPosition %p]", a1);
}

CFStringRef fcpos_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFStringRef v3 = fcpos_CopyEdgeReferenceDescription(v2, *(_DWORD *)(a1 + 16));
  CFStringRef v4 = fcpos_CopyEdgeReferenceDescription(v2, *(_DWORD *)(a1 + 20));
  if ((*(_DWORD *)(a1 + 36) & 0x1D) == 1) {
    CFTypeID v5 = FigGeometryDimensionCopyDescription(v2, *(void *)(a1 + 24), *(void *)(a1 + 32));
  }
  else {
    CFTypeID v5 = 0;
  }
  if ((*(_DWORD *)(a1 + 52) & 0x1D) == 1) {
    char v6 = FigGeometryDimensionCopyDescription(v2, *(void *)(a1 + 40), *(void *)(a1 + 48));
  }
  else {
    char v6 = 0;
  }
  CFTypeID v7 = @"N/A";
  if (v5) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = @"N/A";
  }
  if (v6) {
    CFTypeID v7 = v6;
  }
  CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionPosition %p] < horizontal:(%@, %@) vertical:(%@, %@) >", a1, v3, v8, v4, v7);
  if (v6) {
    CFRelease(v6);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
  return v9;
}

CFStringRef fcpos_CopyEdgeReferenceDescription(const __CFAllocator *a1, signed int a2)
{
  if (a2 <= 1701999214)
  {
    switch(a2)
    {
      case 0:
        CFStringRef v4 = @"<N/A>";
        return (CFStringRef)CFRetain(v4);
      case 1651471476:
        CFStringRef v4 = @"bottom";
        return (CFStringRef)CFRetain(v4);
      case 1667591796:
        CFStringRef v4 = @"center";
        return (CFStringRef)CFRetain(v4);
    }
  }
  else if (a2 > 1919510375)
  {
    if (a2 == 1919510376)
    {
      CFStringRef v4 = @"right";
      return (CFStringRef)CFRetain(v4);
    }
    if (a2 == 1953460256)
    {
      CFStringRef v4 = @"top";
      return (CFStringRef)CFRetain(v4);
    }
  }
  else
  {
    if (a2 == 1701999215)
    {
      CFStringRef v4 = @"<error>";
      return (CFStringRef)CFRetain(v4);
    }
    if (a2 == 1818584692)
    {
      CFStringRef v4 = @"left";
      return (CFStringRef)CFRetain(v4);
    }
  }
  uint64_t v8 = v2;
  uint64_t v9 = v3;
  unsigned int v6 = bswap32(a2);
  char v7 = 0;
  return CFStringCreateWithFormat(a1, 0, @"unknown(%.4s)", &v6);
}

uint64_t remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished()
{
  uint64_t v3 = 0;
  CFStringRef v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E567E450;
  void block[4] = &v3;
  if (remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished_sFigEndpointPlaybackSessionRemoteClientSetupOnce != -1) {
    dispatch_once(&remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished_sFigEndpointPlaybackSessionRemoteClientSetupOnce, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointPlaybackSessionXPCRemoteCreateWithObjectID(const void *a1, void *a2)
{
  if (a1 && a2)
  {
    uint64_t result = remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished();
    if (!result)
    {
      uint64_t v11 = 0;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      ClassIOSurfaceID ID = (void *)FigEndpointPlaybackSessionGetClassID();
      uint64_t result = CMDerivedObjectCreate((uint64_t)v5, (uint64_t)&kFigEndpointPlaybackSessionRemoteXPC_EndpointPlaybackSessionVTable, ClassID, &v11);
      if (!result)
      {
        uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(v11);
        DerivedStorage[1] = a1;
        DerivedStorage[7] = 1;
        v10.version = 0;
        v10.retain = (CFDictionaryRetainCallBack)remoteXPCEndpointPlaybackSession_cloneCompletionCallback;
        v10.release = (CFDictionaryReleaseCallBack)remoteXPCEndpointPlaybackSession_freeCompletionCallback;
        v10.copyDescription = 0;
        v10.equal = 0;
        CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(v5, 0, 0, &v10);
        DerivedStorage[3] = v8;
        if (v8
          && (dispatch_queue_t v9 = dispatch_queue_create("com.apple.coremedia.endpointplaybacksession.callbacks", 0),
              (DerivedStorage[2] = v9) != 0))
        {
          FigXPCRemoteClientAssociateObject(gFigEndpointPlaybackSessionRemoteClient, v11, a1);
          uint64_t result = 0;
        }
        else
        {
          uint64_t result = FigSignalErrorAt(4294950555, 0, 0, 0, 0, 0, 0);
        }
      }
      *a2 = v11;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void remoteXPCEndpointPlaybackSessionClient_DeadConnectionCallback(uint64_t a1)
{
  *(unsigned char *)(CMBaseObjectGetDerivedStorage(a1) + 1) = 1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v8 = 0;
  dispatch_queue_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  int context = -16722;
  uint64_t v3 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigEndpointPlaybackSessionRemoteXPC_runAllCallbacks_block_invoke;
  block[3] = &unk_1E567E478;
  void block[4] = &v8;
  void block[5] = DerivedStorage;
  dispatch_sync(v3, block);
  CFDictionaryRef v4 = (const __CFDictionary *)v9[3];
  if (v4)
  {
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)FigEndpointPlaybackSessionRemoteXPC_runOneCallback, &context);
    CFAllocatorRef v5 = (const void *)v9[3];
    if (v5) {
      CFRelease(v5);
    }
  }
  _Block_object_dispose(&v8, 8);
}

uint64_t remoteXPCEndpointPlaybackSessionClient_HandleClientMessage(uint64_t a1, void *a2)
{
  int v16 = 0;
  uint64_t result = FigXPCMessageGetOpCode(a2, &v16);
  if (!result)
  {
    if (v16 == 1701340002)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      uint64_t v11 = *(NSObject **)(DerivedStorage + 16);
      blocuint64_t k = MEMORY[0x1E4F143A8];
      uint64_t v26 = 0x40000000;
      uint64_t v27 = __remoteXPCEndpointPlaybackSessionClient_eventHandlerCallback_block_invoke;
      uint64_t v28 = &__block_descriptor_tmp_5_2;
      uint64_t v29 = (uint64_t *)DerivedStorage;
      uint64_t v30 = (uint64_t)a2;
      uint64_t v31 = a1;
      dispatch_sync(v11, &block);
      return 0;
    }
    if (v16 != 1667329122) {
      return 4294966630;
    }
    uint64_t v19 = 0;
    int v20 = &v19;
    uint64_t v21 = 0x3000000000;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    uint64_t v5 = CMBaseObjectGetDerivedStorage(a1);
    uint64_t int64 = xpc_dictionary_get_uint64(a2, "CompletionID");
    int64_t OSStatus = FigXPCMessageGetOSStatus(a2, "CompletionStatus");
    uint64_t v8 = *(NSObject **)(v5 + 16);
    blocuint64_t k = MEMORY[0x1E4F143A8];
    uint64_t v26 = 0x40000000;
    uint64_t v27 = __remoteXPCEndpointPlaybackSessionClient_handleCompletionCallback_block_invoke;
    uint64_t v28 = &unk_1E567E4A0;
    uint64_t v30 = v5;
    uint64_t v31 = uint64;
    uint64_t v29 = &v19;
    dispatch_sync(v8, &block);
    uint64_t v9 = v20[3];
    if (v9 > 1886545248)
    {
      if (v9 <= 1936028776)
      {
        if (v9 == 1886545249)
        {
          CFTypeRef cf = 0;
          int64_t v14 = FigXPCMessageGetOSStatus(a2, "ResponseStatus");
          FigXPCMessageCopyCFObject(a2, "ResponseParams", (__CFDictionary **)&cf);
          ((void (*)(int64_t, CFTypeRef, uint64_t))v20[5])(v14, cf, v20[4]);
LABEL_27:
          size_t v15 = (__CFDictionary *)cf;
          if (cf) {
LABEL_28:
          }
            CFRelease(v15);
LABEL_29:
          _Block_object_dispose(&v19, 8);
          return 0;
        }
        if (v9 != 1919971689)
        {
          if (v9 != 1936024673) {
            goto LABEL_29;
          }
          goto LABEL_24;
        }
        goto LABEL_20;
      }
      if (v9 == 1936028777)
      {
LABEL_24:
        CFTypeRef cf = 0;
        size_t v13 = "SeekResponseInfo";
LABEL_25:
        FigXPCMessageCopyCFDictionary(a2, v13, &cf);
        ((void (*)(CFTypeRef, int64_t, uint64_t))v20[5])(cf, OSStatus, v20[4]);
        goto LABEL_27;
      }
      if (v9 == 1936875892)
      {
LABEL_20:
        ((void (*)(int64_t, uint64_t))v20[5])(OSStatus, v20[4]);
        goto LABEL_29;
      }
      uint64_t v12 = 1937010544;
LABEL_19:
      if (v9 != v12) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }
    if (v9 <= 1735422065)
    {
      if (v9 != 1635018857)
      {
        if (v9 != 1735421033) {
          goto LABEL_29;
        }
        CFTypeRef cf = 0;
        size_t v13 = "PlaybackInfo";
        goto LABEL_25;
      }
      uint64_t v17 = 0;
      CFTypeRef cf = 0;
      FigXPCMessageCopyCFData(a2, "PicData", &cf);
      FigXPCMessageCopyCFString(a2, "PlayerGUID", &v17);
      ((void (*)(CFTypeRef, __CFDictionary *, int64_t, uint64_t))v20[5])(cf, v17, OSStatus, v20[4]);
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      if (v9 != 1735422066)
      {
        if (v9 == 1768976745) {
          goto LABEL_20;
        }
        uint64_t v12 = 1886151033;
        goto LABEL_19;
      }
      uint64_t v17 = 0;
      CFTypeRef cf = 0;
      FigXPCMessageCopyCFString(a2, "PropertyKey", &cf);
      FigXPCMessageCopyCFObject(a2, "PropertyValue", &v17);
      ((void (*)(CFTypeRef, __CFDictionary *, int64_t, uint64_t))v20[5])(cf, v17, OSStatus, v20[4]);
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
    }
    size_t v15 = v17;
    if (!v17) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_runOneCallback(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = *(void *)a2;
  if (*(uint64_t *)a2 <= 1886545248)
  {
    if (v3 <= 1735422065)
    {
      if (v3 != 1635018857)
      {
        uint64_t v4 = 1735421033;
LABEL_19:
        if (v3 != v4) {
          return result;
        }
        return (*(uint64_t (**)(void, void, void))(a2 + 16))(0, *a3, *(void *)(a2 + 8));
      }
    }
    else if (v3 != 1735422066)
    {
      BOOL v5 = v3 == 1768976745;
      uint64_t v6 = 1886151033;
      goto LABEL_11;
    }
    return (*(uint64_t (**)(void, void, void, void))(a2 + 16))(0, 0, *a3, *(void *)(a2 + 8));
  }
  if (v3 > 1936028776)
  {
    if (v3 == 1936028777) {
      return (*(uint64_t (**)(void, void, void))(a2 + 16))(0, *a3, *(void *)(a2 + 8));
    }
    BOOL v5 = v3 == 1936875892;
    uint64_t v6 = 1937010544;
LABEL_11:
    if (v5 || v3 == v6) {
      return (*(uint64_t (**)(void, void))(a2 + 16))(*a3, *(void *)(a2 + 8));
    }
    return result;
  }
  if (v3 != 1886545249)
  {
    if (v3 != 1919971689)
    {
      uint64_t v4 = 1936024673;
      goto LABEL_19;
    }
    return (*(uint64_t (**)(void, void))(a2 + 16))(*a3, *(void *)(a2 + 8));
  }
  return (*(uint64_t (**)(void, void, void))(a2 + 16))(*a3, 0, *(void *)(a2 + 8));
}

void __remoteXPCEndpointPlaybackSessionClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(*(void *)(a1 + 40) + 24);
  if (v2)
  {
    CFNumberRef Value = CFDictionaryGetValue(v2, *(const void **)(a1 + 48));
    if (Value)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
      long long v5 = *(_OWORD *)Value;
      *(void *)(v4 + 40) = Value[2];
      *(_OWORD *)(v4 + 24) = v5;
    }
    uint64_t v6 = *(const void **)(a1 + 48);
    char v7 = *(__CFDictionary **)(*(void *)(a1 + 40) + 24);
    CFDictionaryRemoveValue(v7, v6);
  }
}

void __remoteXPCEndpointPlaybackSessionClient_eventHandlerCallback_block_invoke(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 40))
  {
    CFTypeRef cf = 0;
    FigXPCMessageCopyCFDictionary(*(void **)(a1 + 40), "EventInfo", &cf);
    (*(void (**)(void, CFTypeRef, void, void))(*(void *)(a1 + 32) + 40))(*(void *)(a1 + 48), cf, *(void *)(*(void *)(a1 + 32) + 32), *(void *)(*(void *)(a1 + 32) + 48));
    if (cf) {
      CFRelease(cf);
    }
  }
}

__n128 remoteXPCEndpointPlaybackSession_cloneCompletionCallback(const __CFAllocator *a1, __n128 *a2)
{
  uint64_t v3 = (__n128 *)CFAllocatorAllocate(a1, 24, 0);
  unint64_t v4 = a2[1].n128_u64[0];
  __n128 result = *a2;
  *uint64_t v3 = *a2;
  v3[1].n128_u64[0] = v4;
  return result;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_Invalidate(uint64_t a1)
{
  uint64_t v6 = 0;
  char v7 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v6);
  if (ObjectID)
  {
    uint64_t v4 = ObjectID;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v2 = FigXPCCreateBasicMessage(0x696E766Cu, v6, &v7);
    uint64_t v3 = v7;
    if (v2)
    {
      uint64_t v4 = v2;
    }
    else
    {
      uint64_t v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)v7);
      uint64_t v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

void FigEndpointPlaybackSessionRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v3 = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = v3;
  xpc_object_t v9 = 0;
  if (!*(unsigned char *)v3)
  {
    long long v5 = *(const void **)(v3 + 8);
    *(unsigned char *)uint64_t v3 = 1;
    FigXPCRemoteClientDisassociateObject(gFigEndpointPlaybackSessionRemoteClient, v5);
    if (!*(unsigned char *)(v4 + 1) && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v5, &v9)) {
      FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)v9);
    }
  }
  uint64_t v6 = *(const void **)(v4 + 24);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(v4 + 24) = 0;
  }
  FigXPCRelease(v9);
  char v7 = *(NSObject **)(DerivedStorage + 16);
  if (v7) {
    dispatch_release(v7);
  }
  uint64_t v8 = *(const void **)(DerivedStorage + 48);
  if (v8) {
    CFRelease(v8);
  }
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  uint64_t v10 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v10);
  if (!ObjectID) {
    ObjectIOSurfaceID ID = FigXPCSendStdCopyPropertyMessage(gFigEndpointPlaybackSessionRemoteClient, v10, a2, &cf);
  }
  uint64_t v7 = ObjectID;
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v7;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v8 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v8);
  if (!ObjectID) {
    ObjectIOSurfaceID ID = FigXPCSendStdSetPropertyMessage(gFigEndpointPlaybackSessionRemoteClient, v8, a2, a3);
  }
  uint64_t v6 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointPlaybackSessionRemoteClient, ObjectID, "FigEndpointPlaybackSessionRemoteXPC_SetProperty", a2);
  return v6;
}

uint64_t remoteXPCEndpointPlaybackSession_GetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v5 = 4294954511;
  }
  else
  {
    if (!*(unsigned char *)(DerivedStorage + 1))
    {
      *a2 = *(void *)(DerivedStorage + 8);
      return 0;
    }
    uint64_t v5 = 4294950574;
  }

  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_AuthorizeItem(uint64_t a1, const void *a2, const void *a3, void (*a4)(void, void, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v14 = 0;
  *(void *)size_t v15 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x61746869u, v14, v15), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a4) {
      a4(0, 0, ObjectID, a5);
    }
    uint64_t v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFData(*(void **)v15, "PicRequest", a2);
    FigXPCMessageSetCFString(*(void **)v15, "ItemUUID", a3);
    if (a4)
    {
      uint64_t v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *uint64_t v11 = 1635018857;
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    uint64_t v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_Play(uint64_t a1, const void *a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v12 = 0;
  *(void *)size_t v13 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v12);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x706C6179u, v12, v13), ObjectID))
  {
    uint64_t v10 = ObjectID;
    if (a3) {
      a3(ObjectID, a4);
    }
    xpc_object_t v9 = 0;
  }
  else
  {
    FigXPCMessageSetCFDictionary(*(void **)v13, "Params", a2);
    remoteXPCEndpointPlaybackSession_generateSandboxTokenForFilePath(*(void **)v13, (const __CFDictionary *)a2);
    if (a3)
    {
      xpc_object_t v9 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v9[1] = a4;
      int v9[2] = a3;
      *xpc_object_t v9 = 1886151033;
    }
    else
    {
      xpc_object_t v9 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, (uint64_t)v9);
    uint64_t v10 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v13);
  free(v9);
  return v10;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_InsertPlayQueueItem(uint64_t a1, const void *a2, const void *a3, void (*a4)(uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v14 = 0;
  *(void *)size_t v15 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x69707169u, v14, v15), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a4) {
      a4(ObjectID, a5);
    }
    uint64_t v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFDictionary(*(void **)v15, "Item", a2);
    FigXPCMessageSetCFDictionary(*(void **)v15, "AfterItem", a3);
    remoteXPCEndpointPlaybackSession_generateSandboxTokenForFilePath(*(void **)v15, (const __CFDictionary *)a2);
    if (a4)
    {
      uint64_t v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *uint64_t v11 = 1768976745;
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    uint64_t v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_RemovePlayQueueItem(uint64_t a1, const void *a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v12 = 0;
  *(void *)size_t v13 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v12);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x72707169u, v12, v13), ObjectID))
  {
    uint64_t v10 = ObjectID;
    if (a3) {
      a3(ObjectID, a4);
    }
    xpc_object_t v9 = 0;
  }
  else
  {
    FigXPCMessageSetCFDictionary(*(void **)v13, "Item", a2);
    if (a3)
    {
      xpc_object_t v9 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v9[1] = a4;
      int v9[2] = a3;
      *xpc_object_t v9 = 1919971689;
    }
    else
    {
      xpc_object_t v9 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, (uint64_t)v9);
    uint64_t v10 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v13);
  free(v9);
  return v10;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_Stop(uint64_t a1, void (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v10);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x73746F70u, v10, &v11), ObjectID))
  {
    uint64_t v8 = ObjectID;
    if (a2) {
      a2(ObjectID, a3);
    }
    uint64_t v7 = 0;
  }
  else
  {
    if (a2)
    {
      uint64_t v7 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v7[1] = a3;
      _OWORD v7[2] = a2;
      *uint64_t v7 = 1937010544;
    }
    else
    {
      uint64_t v7 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, v11, (uint64_t)v7);
    uint64_t v8 = 0;
  }
  FigXPCRelease(v11);
  free(v7);
  return v8;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_GetPlaybackInfo(uint64_t a1, void (*a2)(void, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v10);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x67706C69u, v10, &v11), ObjectID))
  {
    uint64_t v8 = ObjectID;
    if (a2) {
      a2(0, ObjectID, a3);
    }
    uint64_t v7 = 0;
  }
  else
  {
    if (a2)
    {
      uint64_t v7 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v7[1] = a3;
      _OWORD v7[2] = a2;
      *uint64_t v7 = 1735421033;
    }
    else
    {
      uint64_t v7 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, v11, (uint64_t)v7);
    uint64_t v8 = 0;
  }
  FigXPCRelease(v11);
  free(v7);
  return v8;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SeekToTime(uint64_t a1, long long *a2, const void *a3, void (*a4)(void, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v16 = 0;
  *(void *)uint64_t v17 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v16);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x73657469u, v16, v17), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a4) {
      a4(0, ObjectID, a5);
    }
    uint64_t v11 = 0;
  }
  else
  {
    long long v14 = *a2;
    uint64_t v15 = *((void *)a2 + 2);
    FigXPCMessageSetCMTime(*(void **)v17, "Time", &v14);
    FigXPCMessageSetCFDictionary(*(void **)v17, "Options", a3);
    if (a4)
    {
      uint64_t v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *uint64_t v11 = 1936028777;
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v17, (uint64_t)v11);
    uint64_t v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v17);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SeekToDate(uint64_t a1, const void *a2, const void *a3, void (*a4)(void, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v14 = 0;
  *(void *)uint64_t v15 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x73656461u, v14, v15), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a4) {
      a4(0, ObjectID, a5);
    }
    uint64_t v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFDate(*(void **)v15, "Date", a2);
    FigXPCMessageSetCFDictionary(*(void **)v15, "Options", a3);
    if (a4)
    {
      uint64_t v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *uint64_t v11 = 1936024673;
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    uint64_t v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetRate(uint64_t a1, const void *a2, void (*a3)(uint64_t, uint64_t), uint64_t a4, float a5)
{
  uint64_t v14 = 0;
  xpc_object_t xdict = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x73726174u, v14, &xdict), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a3) {
      a3(ObjectID, a4);
    }
    uint64_t v11 = 0;
  }
  else
  {
    xpc_dictionary_set_double(xdict, "Rate", a5);
    FigXPCMessageSetCFDictionary(xdict, "Params", a2);
    if (a3)
    {
      uint64_t v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a4;
      v11[2] = a3;
      *uint64_t v11 = 1936875892;
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, xdict, (uint64_t)v11);
    uint64_t v12 = 0;
  }
  FigXPCRelease(xdict);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_GetProxiedProperty(uint64_t a1, const void *a2, const void *a3, void (*a4)(void, void, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v14 = 0;
  *(void *)uint64_t v15 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x67707072u, v14, v15), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a4) {
      a4(0, 0, ObjectID, a5);
    }
    uint64_t v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v15, "PropertyKey", a2);
    FigXPCMessageSetCFDictionary(*(void **)v15, "Params", a3);
    if (a4)
    {
      uint64_t v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *uint64_t v11 = 1735422066;
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    uint64_t v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetProxiedProperty(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t v11 = 0;
  *(void *)uint64_t v12 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v11);
  if (ObjectID)
  {
    uint64_t v8 = ObjectID;
    xpc_object_t v9 = 0;
  }
  else
  {
    uint64_t v8 = FigXPCCreateBasicMessage(0x73707072u, v11, v12);
    xpc_object_t v9 = *(void **)v12;
    if (!v8)
    {
      FigXPCMessageSetCFString(*(void **)v12, "PropertyKey", a2);
      FigXPCMessageSetCFDictionary(*(void **)v12, "Params", a3);
      FigXPCMessageSetCFObject(*(void **)v12, "PropertyValue", a4);
      uint64_t v8 = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, *(uint64_t *)v12);
      xpc_object_t v9 = *(void **)v12;
    }
  }
  FigXPCRelease(v9);
  return v8;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_PerformRemoteAction(uint64_t a1, const void *a2, const void *a3, void (*a4)(uint64_t, void, uint64_t), uint64_t a5)
{
  uint64_t v14 = 0;
  *(void *)uint64_t v15 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x70726561u, v14, v15), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a4) {
      a4(ObjectID, 0, a5);
    }
    uint64_t v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v15, "Type", a2);
    FigXPCMessageSetCFObject(*(void **)v15, "Params", a3);
    if (a4)
    {
      uint64_t v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *uint64_t v11 = 1886545249;
    }
    else
    {
      uint64_t v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    uint64_t v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetEventHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t v16 = 0;
  uint64_t v15 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v15);
  if (!ObjectID)
  {
    if (a2) {
      unsigned int v9 = 1936029288;
    }
    else {
      unsigned int v9 = 1667593832;
    }
    ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(v9, v15, &v16);
    if (!ObjectID)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      uint64_t v11 = *(NSObject **)(DerivedStorage + 16);
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 0x40000000;
      uint64_t v14[2] = __FigEndpointPlaybackSessionRemoteXPC_SetEventHandler_block_invoke;
      v14[3] = &__block_descriptor_tmp_10_6;
      _OWORD v14[4] = DerivedStorage;
      void v14[5] = a2;
      v14[6] = a3;
      v14[7] = a4;
      dispatch_sync(v11, v14);
      ObjectIOSurfaceID ID = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)v16);
    }
  }
  uint64_t v12 = ObjectID;
  FigXPCRelease(v16);
  return v12;
}

void FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v7 = DerivedStorage;
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  uint64_t v23 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  char v19 = 0;
  if (a3)
  {
    uint64_t v8 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
    block[3] = &unk_1E567E4E8;
    void block[4] = &v20;
    void block[5] = a1;
    void block[6] = v7;
    void block[7] = a3;
    dispatch_sync(v8, block);
    xpc_dictionary_set_uint64(a2, "CompletionID", v21[3]);
  }
  uint64_t v9 = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)a2);
  uint64_t v10 = v9;
  if (a3)
  {
    if (v9)
    {
      uint64_t v11 = *(NSObject **)(v7 + 16);
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 0x40000000;
      uint64_t v14[2] = __FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke_2;
      v14[3] = &unk_1E567E510;
      _OWORD v14[4] = &v20;
      void v14[5] = &v16;
      v14[6] = v7;
      dispatch_sync(v11, v14);
      if (*((unsigned char *)v17 + 24))
      {
        unsigned int v13 = v10;
        FigEndpointPlaybackSessionRemoteXPC_runOneCallback(v12, a3, &v13);
      }
    }
  }
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointPlaybackSessionRemoteClient, v10, "FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
}

void remoteXPCEndpointPlaybackSession_generateSandboxTokenForFilePath(void *a1, const __CFDictionary *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  bzero(v10, 0x400uLL);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"movPkgPath");
  if (Value || (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"path")) != 0)
  {
    if (CFStringGetCString(Value, buffer, 1024, 0x8000100u))
    {
      if ((v5 = open(buffer, 0), v5 != -1) && (v6 = v5, int v7 = fcntl(v5, 50, v10), close(v6), v7 != -1)
        || realpath_DARWIN_EXTSN(buffer, v10)
        || !*__error())
      {
        uint64_t v8 = (const char *)sandbox_extension_issue_file();
        if (v8)
        {
          uint64_t v9 = (char *)v8;
          xpc_dictionary_set_string(a1, "SExtToken", v8);
          free(v9);
        }
      }
    }
  }
}

void *FigHALPluginDriverGetInterface()
{
  return &gAudioServerPlugInDriverInterface;
}

uint64_t figHALDriver_QueryInterface(uint64_t a1, CFUUIDBytes a2, void *a3)
{
  if (a3)
  {
    CFUUIDRef v5 = CFUUIDCreateFromUUIDBytes(0, a2);
    if (v5)
    {
      CFUUIDRef v6 = v5;
      CFUUIDRef v7 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], 0, 0, 0, 0, 0, 0, 0, 0, 0xC0u, 0, 0, 0, 0, 0, 0, 0x46u);
      if (CFEqual(v6, v7)
        || (CFUUIDRef v8 = CFUUIDGetConstantUUIDWithBytes(0, 0xEEu, 0xA5u, 0x77u, 0x3Du, 0xCCu, 0x43u, 0x49u, 0xF1u, 0x8Eu, 0, 0x8Fu, 0x96u, 0xE7u, 0xD2u, 0x3Bu, 0x17u), CFEqual(v6, v8)))
      {
        FigAtomicIncrement32((atomic_uint *)(a1 + 8));
        uint64_t v9 = 0;
        *a3 = a1;
      }
      else
      {
        uint64_t v9 = 2147483652;
      }
      CFRelease(v6);
      return v9;
    }
    uint64_t v11 = 4294950406;
  }
  else
  {
    uint64_t v11 = 1852797029;
  }

  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t figHALDriver_AddRef(uint64_t a1)
{
  return FigAtomicIncrement32((atomic_uint *)(a1 + 8));
}

uint64_t figHALDriver_Release(uint64_t a1)
{
  return FigAtomicDecrement32((atomic_uint *)(a1 + 8));
}

uint64_t figHALDriver_Initialize(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 20);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(v3) + 24);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  CFUUIDRef v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 8);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t figHALDriver_CreateDevice()
{
  return 1970171760;
}

uint64_t figHALDriver_DestroyDevice()
{
  return 1970171760;
}

uint64_t figHALDriver_AddDeviceClient()
{
  return 0;
}

uint64_t figHALDriver_RemoveDeviceClient()
{
  return 0;
}

uint64_t figHALDriver_PerformDeviceConfigurationChange(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  uint64_t v6 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v7 = cf;
  if (v6)
  {
LABEL_7:
    uint64_t v11 = v6;
    if (!v7) {
      return v11;
    }
    goto LABEL_10;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t))(v9 + 16);
  if (v10)
  {
    uint64_t v6 = v10(v7, a3, a4);
    goto LABEL_7;
  }
  uint64_t v11 = 4294954514;
  if (v7) {
LABEL_10:
  }
    CFRelease(v7);
  return v11;
}

uint64_t figHALDriver_AbortDeviceConfigurationChange(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  uint64_t v6 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v7 = cf;
  if (v6)
  {
LABEL_7:
    uint64_t v11 = v6;
    if (!v7) {
      return v11;
    }
    goto LABEL_10;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t))(v9 + 24);
  if (v10)
  {
    uint64_t v6 = v10(v7, a3, a4);
    goto LABEL_7;
  }
  uint64_t v11 = 4294954514;
  if (v7) {
LABEL_10:
  }
    CFRelease(v7);
  return v11;
}

uint64_t figHALDriver_HasProperty(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = 0;
  int v5 = driver_CopyObjectForID(a1, a2, &v12);
  uint64_t v6 = v12;
  if (!v5)
  {
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable((uint64_t)v12) + 16);
    uint64_t v8 = v7 ? v7 : 0;
    uint64_t v9 = *(uint64_t (**)(const void *, uint64_t))(v8 + 16);
    if (v9)
    {
      uint64_t v10 = v9(v6, a4);
      if (!v6) {
        return v10;
      }
      goto LABEL_9;
    }
  }
  uint64_t v10 = 0;
  if (v6) {
LABEL_9:
  }
    CFRelease(v6);
  return v10;
}

uint64_t figHALDriver_IsPropertySettable(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  uint64_t v18 = 0;
  uint64_t v7 = driver_CopyObjectForID(a1, a2, &v18);
  uint64_t v8 = v18;
  if (v7)
  {
    uint64_t v11 = v7;
    if (!v18) {
      return v11;
    }
    goto LABEL_15;
  }
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable((uint64_t)v18) + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = 2003332927;
  uint64_t v12 = *(unsigned int (**)(const void *, uint64_t))(v10 + 16);
  if (v12 && v12(v8, a4))
  {
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = *(uint64_t (**)(const void *, uint64_t))(v14 + 24);
    if (v15) {
      char v16 = v15(v8, a4);
    }
    else {
      char v16 = 0;
    }
    uint64_t v11 = 0;
    *a5 = v16;
  }
  if (v8) {
LABEL_15:
  }
    CFRelease(v8);
  return v11;
}

uint64_t figHALDriver_GetPropertyDataSize(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v22 = 0;
  uint64_t v11 = driver_CopyObjectForID(a1, a2, &v22);
  uint64_t v12 = v22;
  if (v11)
  {
    uint64_t v15 = v11;
    if (!v22) {
      return v15;
    }
    goto LABEL_15;
  }
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable((uint64_t)v22) + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = 2003332927;
  char v16 = *(unsigned int (**)(const void *, uint64_t))(v14 + 16);
  if (v16 && v16(v12, a4))
  {
    uint64_t v17 = *(void *)(CMBaseObjectGetVTable((uint64_t)v12) + 16);
    if (v17) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = 0;
    }
    char v19 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t))(v18 + 32);
    if (v19) {
      int v20 = v19(v12, a4, a5, a6);
    }
    else {
      int v20 = 0;
    }
    uint64_t v15 = 0;
    *a7 = v20;
  }
  if (v12) {
LABEL_15:
  }
    CFRelease(v12);
  return v15;
}

uint64_t figHALDriver_GetPropertyData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v24 = 0;
  uint64_t v14 = driver_CopyObjectForID(a1, a2, &v24);
  uint64_t v15 = v24;
  if (v14) {
    goto LABEL_12;
  }
  uint64_t v16 = *(void *)(CMBaseObjectGetVTable((uint64_t)v24) + 16);
  if (v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = 2003332927;
  char v19 = *(unsigned int (**)(const void *, uint64_t))(v17 + 16);
  if (!v19 || !v19(v15, a4)) {
    goto LABEL_14;
  }
  uint64_t v20 = *(void *)(CMBaseObjectGetVTable((uint64_t)v15) + 16);
  if (v20) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v21 + 40);
  if (v22)
  {
    uint64_t v14 = v22(v15, a4, a5, a6, a7, a8, a9);
LABEL_12:
    uint64_t v18 = v14;
    goto LABEL_14;
  }
  uint64_t v18 = 4294954514;
LABEL_14:
  if (v15) {
    CFRelease(v15);
  }
  return v18;
}

uint64_t figHALDriver_SetPropertyData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = 0;
  uint64_t v13 = driver_CopyObjectForID(a1, a2, &v23);
  uint64_t v14 = v23;
  if (v13) {
    goto LABEL_12;
  }
  uint64_t v15 = *(void *)(CMBaseObjectGetVTable((uint64_t)v23) + 16);
  if (v15) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = 2003332927;
  uint64_t v18 = *(unsigned int (**)(const void *, uint64_t))(v16 + 16);
  if (!v18 || !v18(v14, a4)) {
    goto LABEL_14;
  }
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable((uint64_t)v14) + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v20 + 48);
  if (v21)
  {
    uint64_t v13 = v21(v14, a4, a5, a6, a7, a8);
LABEL_12:
    uint64_t v17 = v13;
    goto LABEL_14;
  }
  uint64_t v17 = 4294954514;
LABEL_14:
  if (v14) {
    CFRelease(v14);
  }
  return v17;
}

uint64_t figHALDriver_StartIO(uint64_t a1, unsigned int a2)
{
  CFTypeRef cf = 0;
  uint64_t v2 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v3 = cf;
  if (v2)
  {
LABEL_7:
    uint64_t v7 = v2;
    if (!v3) {
      return v7;
    }
    goto LABEL_10;
  }
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(CFTypeRef))(v5 + 32);
  if (v6)
  {
    uint64_t v2 = v6(v3);
    goto LABEL_7;
  }
  uint64_t v7 = 4294954514;
  if (v3) {
LABEL_10:
  }
    CFRelease(v3);
  return v7;
}

uint64_t figHALDriver_StopIO(uint64_t a1, unsigned int a2)
{
  CFTypeRef cf = 0;
  uint64_t v2 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v3 = cf;
  if (v2)
  {
LABEL_7:
    uint64_t v7 = v2;
    if (!v3) {
      return v7;
    }
    goto LABEL_10;
  }
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(CFTypeRef))(v5 + 40);
  if (v6)
  {
    uint64_t v2 = v6(v3);
    goto LABEL_7;
  }
  uint64_t v7 = 4294954514;
  if (v3) {
LABEL_10:
  }
    CFRelease(v3);
  return v7;
}

uint64_t figHALDriver_GetZeroTimeStamp(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  uint64_t v9 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v10 = cf;
  if (v9)
  {
LABEL_7:
    uint64_t v14 = v9;
    if (!v10) {
      return v14;
    }
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(v12 + 48);
  if (v13)
  {
    uint64_t v9 = v13(v10, a4, a5, a6);
    goto LABEL_7;
  }
  uint64_t v14 = 4294954514;
  if (v10) {
LABEL_10:
  }
    CFRelease(v10);
  return v14;
}

uint64_t figHALDriver_WillDoIOOperation(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  uint64_t v9 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v10 = cf;
  if (v9)
  {
LABEL_7:
    uint64_t v14 = v9;
    if (!v10) {
      return v14;
    }
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(v12 + 56);
  if (v13)
  {
    uint64_t v9 = v13(v10, a4, a5, a6);
    goto LABEL_7;
  }
  uint64_t v14 = 4294954514;
  if (v10) {
LABEL_10:
  }
    CFRelease(v10);
  return v14;
}

uint64_t figHALDriver_BeginIOOperation(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  uint64_t v9 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v10 = cf;
  if (v9)
  {
LABEL_7:
    uint64_t v14 = v9;
    if (!v10) {
      return v14;
    }
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(v12 + 64);
  if (v13)
  {
    uint64_t v9 = v13(v10, a4, a5, a6);
    goto LABEL_7;
  }
  uint64_t v14 = 4294954514;
  if (v10) {
LABEL_10:
  }
    CFRelease(v10);
  return v14;
}

uint64_t figHALDriver_DoIOOperation(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFTypeRef cf = 0;
  unsigned int v13 = driver_CopyObjectForID(a1, a3, &cf);
  if (v13 == 560947818) {
    uint64_t v14 = 561214578;
  }
  else {
    uint64_t v14 = v13;
  }
  if (v14)
  {
    CFTypeRef v16 = cf;
  }
  else
  {
    ClassIOSurfaceID ID = FigHALAudioStreamGetClassID();
    CFTypeRef v16 = cf;
    if (ClassID == CMBaseObjectGetClassID((uint64_t)cf)) {
      goto LABEL_6;
    }
    uint64_t v14 = FigSignalErrorAt(561214578, 0, 0, 0, 0, 0, 0);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v14) {
    return v14;
  }
  CFTypeRef v16 = 0;
LABEL_6:
  uint64_t v17 = *(void *)(CMBaseObjectGetVTable((uint64_t)v16) + 32);
  if (v17) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = 0;
  }
  uint64_t v19 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 8);
  if (v19)
  {
    uint64_t v14 = v19(v16, a5, a6, a7, a8, a9);
    if (!v16) {
      return v14;
    }
    goto LABEL_13;
  }
  uint64_t v14 = 4294954514;
  if (v16) {
LABEL_13:
  }
    CFRelease(v16);
  return v14;
}

uint64_t figHALDriver_EndIOOperation(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  uint64_t v9 = driver_CopyDeviceForID(a1, a2, &cf);
  CFTypeRef v10 = cf;
  if (v9)
  {
LABEL_7:
    uint64_t v14 = v9;
    if (!v10) {
      return v14;
    }
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 24);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  unsigned int v13 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(v12 + 72);
  if (v13)
  {
    uint64_t v9 = v13(v10, a4, a5, a6);
    goto LABEL_7;
  }
  uint64_t v14 = 4294954514;
  if (v10) {
LABEL_10:
  }
    CFRelease(v10);
  return v14;
}

uint64_t driver_CopyDeviceForID(uint64_t a1, unsigned int a2, void *a3)
{
  CFTypeRef cf = 0;
  unsigned int v4 = driver_CopyObjectForID(a1, a2, &cf);
  if (v4 == 560947818) {
    uint64_t v5 = 560227702;
  }
  else {
    uint64_t v5 = v4;
  }
  if (v5)
  {
    CFTypeRef v7 = cf;
  }
  else
  {
    ClassIOSurfaceID ID = FigHALAudioDeviceGetClassID();
    CFTypeRef v7 = cf;
    if (ClassID == CMBaseObjectGetClassID((uint64_t)cf))
    {
      uint64_t v5 = 0;
      *a3 = v7;
      return v5;
    }
    uint64_t v5 = FigSignalErrorAt(560227702, 0, 0, 0, 0, 0, 0);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v5;
}

uint64_t driver_CopyObjectForID(uint64_t a1, unsigned int a2, void *a3)
{
  if (a2)
  {
    id v5 = FigHALAudioObjectMapperCopyObjectForID(*(uint64_t **)(a1 + 12), a2);
    if (v5)
    {
      id v6 = v5;
      uint64_t result = 0;
      *a3 = v6;
    }
    else
    {
      return 560947818;
    }
  }
  else
  {
    return FigSignalErrorAt(4294950405, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

CFArrayRef FigCopyProcessNamesForGatheringDiagnosticsWithCoreMediaDiagnosticExtension()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1[0] = xmmword_1E567E558;
  v1[1] = *(_OWORD *)&off_1E567E568;
  v1[2] = xmmword_1E567E578;
  return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v1, 6, MEMORY[0x1E4F1D510]);
}

uint64_t FigEndpointStreamAudioFormatDescriptionGetTypeID()
{
  if (FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce != -1) {
    dispatch_once_f(&FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce, &FigEndpointStreamAudioFormatDescriptionGetTypeID_sTypeID, (dispatch_function_t)_FigEndpointStreamAudioFormatDescriptionRegisterClass);
  }
  return FigEndpointStreamAudioFormatDescriptionGetTypeID_sTypeID;
}

uint64_t _FigEndpointStreamAudioFormatDescriptionRegisterClass(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigEndpointStreamAudioFormatDescriptionCreate(uint64_t a1, long long *a2, int a3, uint64_t *a4)
{
  if (a2)
  {
    if (a4)
    {
      if (FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce != -1) {
        dispatch_once_f(&FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce, &FigEndpointStreamAudioFormatDescriptionGetTypeID_sTypeID, (dispatch_function_t)_FigEndpointStreamAudioFormatDescriptionRegisterClass);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        long long v8 = *a2;
        long long v9 = a2[1];
        *(void *)(Instance + 48) = *((void *)a2 + 4);
        *(_OWORD *)(Instance + 16) = v8;
        *(_OWORD *)(Instance + 32) = v9;
        *(_DWORD *)(Instance + 56) = a3;
        *a4 = Instance;
        return 0;
      }
      uint64_t v11 = 4294954510;
    }
    else
    {
      uint64_t v11 = 4294954516;
    }
  }
  else
  {
    uint64_t v11 = 4294954516;
  }

  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointStreamAudioFormatDescriptionGetASBD(uint64_t a1)
{
  if (a1) {
    return a1 + 16;
  }
  else {
    return 0;
  }
}

uint64_t FigEndpointStreamAudioFormatDescriptionGetChannelLayoutTag(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 56);
  }
  else {
    return 4294901760;
  }
}

uint64_t FigEndpointStreamAudioFormatDescriptionCreateWithCMFormatDescription(uint64_t a1, CMFormatDescriptionRef desc, uint64_t *a3)
{
  uint64_t v12 = 0;
  StreamBasicDescription = 0;
  size_t sizeOut = 0;
  int v10 = -65536;
  int v9 = 4;
  if (desc && CMFormatDescriptionGetMediaType(desc) == 1936684398 && a3)
  {
    CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(desc, (const AudioFormatListItem **)&StreamBasicDescription, &sizeOut, &v12);
    if (StreamBasicDescription)
    {
      ChannelLayout = v12;
    }
    else
    {
      StreamBasicDescription = (AudioFormatListItem *)CMAudioFormatDescriptionGetStreamBasicDescription(desc);
      ChannelLayout = CMAudioFormatDescriptionGetChannelLayout(desc, &sizeOut);
      uint64_t v12 = ChannelLayout;
    }
    if (AudioToolbox_AudioFormatGetProperty(1668116596, sizeOut, (uint64_t)ChannelLayout, (uint64_t)&v9, (uint64_t)&v10))
    {
      int v7 = -65536;
      int v10 = -65536;
    }
    else
    {
      int v7 = v10;
    }
    return FigEndpointStreamAudioFormatDescriptionCreate(a1, (long long *)StreamBasicDescription, v7, a3);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

BOOL _FigEndpointStreamAudioFormatDescriptionIsEqual(uint64_t a1, uint64_t a2)
{
  return !memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x24uLL)
      && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a2 + 56);
}

CFStringRef _FigEndpointStreamAudioFormatDescriptionCopyDebugDesc(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 24);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<FigEndpointStreamAudioFormatDescription %p> {\n\tmSampleRate: %f\n\tmFormatID: '%c%c%c%c'\n\tmFormatFlags: 0x%x\n\tmBytesPerPacket: %u\n\tmFramesPerPacket: %u\n\tmBytesPerFrame: %u\n\tmChannelsPerFrame: %u\n\tmBitsPerChannel: %u\n\tmChannelLayoutTag: 0x%08x\n}", a1, *(void *)(a1 + 16), HIBYTE(v1), BYTE2(v1), BYTE1(v1), v1, *(unsigned int *)(a1 + 28), *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 36), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 56));
}

uint64_t FigEndpointRemoteControlSessionXPCRemotePing()
{
  id v5 = 0;
  uint64_t v0 = remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished();
  if (v0)
  {
    uint64_t v3 = v0;
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v5);
    uint64_t v2 = v5;
    if (v1)
    {
      uint64_t v3 = v1;
    }
    else
    {
      uint64_t v3 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v5);
      uint64_t v2 = v5;
    }
  }
  FigXPCRelease(v2);
  return v3;
}

uint64_t remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished()
{
  uint64_t v3 = 0;
  unsigned int v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E567E598;
  void block[4] = &v3;
  if (remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished_sFigEndpointRemoteControlSessionRemoteClientSetupOnce != -1) {
    dispatch_once(&remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished_sFigEndpointRemoteControlSessionRemoteClientSetupOnce, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointRemoteControlSessionXPCRemoteCreateWithObjectID(const void *a1, void *a2)
{
  if (a1 && a2)
  {
    uint64_t result = remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished();
    if (!result)
    {
      return remoteXPCEndpointRemoteControlSession_CreateInternal(a1, a2);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t remoteXPCEndpointRemoteControlSession_CreateInternal(const void *a1, void *a2)
{
  uint64_t v11 = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  ClassIOSurfaceID ID = (void *)FigEndpointRemoteControlSessionGetClassID();
  uint64_t result = CMDerivedObjectCreate((uint64_t)v4, (uint64_t)&kFigEndpointRemoteControlSessionRemoteXPC_EndpointRemoteControlSessionVTable, ClassID, &v11);
  if (!result)
  {
    uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(v11);
    DerivedStorage[1] = a1;
    DerivedStorage[6] = 1;
    v10.version = 0;
    v10.retain = (CFDictionaryRetainCallBack)remoteXPCEndpointRemoteControlSession_cloneCompletionCallback;
    v10.release = (CFDictionaryReleaseCallBack)remoteXPCEndpointRemoteControlSession_freeCompletionCallback;
    v10.copyDescription = 0;
    v10.equal = 0;
    CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(v4, 0, 0, &v10);
    DerivedStorage[3] = v8;
    if (v8
      && (dispatch_queue_t v9 = dispatch_queue_create("com.apple.coremedia.endpointremotecontrolsession.callbacks", 0),
          (DerivedStorage[2] = v9) != 0))
    {
      FigXPCRemoteClientAssociateObject(gFigEndpointRemoteControlSessionRemoteClient, v11, a1);
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = FigSignalErrorAt(4294949865, 0, 0, 0, 0, 0, 0);
    }
  }
  *a2 = v11;
  return result;
}

void remoteXPCEndpointRemoteControlSessionClient_DeadConnectionCallback(uint64_t a1)
{
  *(unsigned char *)(CMBaseObjectGetDerivedStorage(a1) + 1) = 1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2000000000;
  uint64_t v25 = 0;
  LODWORD(context) = -16722;
  uint64_t v3 = *(NSObject **)(DerivedStorage + 16);
  blocuint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v12 = 0x40000000;
  unsigned int v13 = __FigEndpointRemoteControlSessionRemoteXPC_runAllCallbacks_block_invoke;
  uint64_t v14 = &unk_1E567E5C0;
  uint64_t v15 = &v22;
  CFTypeRef v16 = (uint64_t *)DerivedStorage;
  dispatch_sync(v3, &block);
  CFDictionaryRef v4 = (const __CFDictionary *)v23[3];
  if (v4)
  {
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)FigEndpointRemoteControlSessionRemoteXPC_runOneCallback, &context);
    uint64_t v5 = (const void *)v23[3];
    if (v5) {
      CFRelease(v5);
    }
  }
  _Block_object_dispose(&v22, 8);
  uint64_t v6 = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2000000000;
  uint64_t v25 = 0;
  uint64_t context = 0;
  p_uint64_t context = &context;
  uint64_t v20 = 0x2000000000;
  uint64_t v21 = 0;
  int v7 = *(NSObject **)(v6 + 16);
  blocuint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v12 = 0x40000000;
  unsigned int v13 = __FigEndpointRemoteControlSessionRemoteXPC_postInvalidated_block_invoke;
  uint64_t v14 = &unk_1E567E5E8;
  CFTypeRef v16 = &v22;
  uint64_t v17 = v6;
  uint64_t v15 = &context;
  dispatch_sync(v7, &block);
  CFMutableDictionaryRef v8 = (void (*)(uint64_t, __CFString *, void))v23[3];
  dispatch_queue_t v9 = p_context;
  if (v8 && p_context[3])
  {
    v8(a1, @"Invalidated", 0);
    dispatch_queue_t v9 = p_context;
  }
  CFDictionaryValueCallBacks v10 = (const void *)v9[3];
  if (v10) {
    CFRelease(v10);
  }
  _Block_object_dispose(&context, 8);
  _Block_object_dispose(&v22, 8);
}

uint64_t remoteXPCEndpointRemoteControlSessionClient_HandleClientMessage(uint64_t a1, void *a2)
{
  int v12 = 0;
  uint64_t result = FigXPCMessageGetOpCode(a2, &v12);
  if (!result)
  {
    if (v12 == 1701340002)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      CFTypeRef v30 = 0;
      CFTypeRef v31 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = &v13;
      uint64_t v15 = 0x2000000000;
      uint64_t v16 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = &v26;
      uint64_t v28 = 0x2000000000;
      uint64_t v29 = 0;
      CFDictionaryValueCallBacks v10 = *(NSObject **)(DerivedStorage + 16);
      blocuint64_t k = MEMORY[0x1E4F143A8];
      uint64_t v20 = 0x40000000;
      uint64_t v21 = __remoteXPCEndpointRemoteControlSessionClient_eventHandlerCallback_block_invoke;
      uint64_t v22 = &unk_1E567E638;
      uint64_t v24 = &v26;
      uint64_t v25 = DerivedStorage;
      uint64_t v23 = &v13;
      dispatch_sync(v10, &block);
      if (v27[3])
      {
        FigXPCMessageCopyCFString(a2, "EventType", &v31);
        FigXPCMessageCopyCFData(a2, "EventPayload", &v30);
        if (v14[3]) {
          ((void (*)(uint64_t, CFTypeRef, CFTypeRef))v27[3])(a1, v31, v30);
        }
      }
      uint64_t v11 = (const void *)v14[3];
      if (v11) {
        CFRelease(v11);
      }
      if (v31) {
        CFRelease(v31);
      }
      if (v30) {
        CFRelease(v30);
      }
      _Block_object_dispose(&v26, 8);
      goto LABEL_17;
    }
    if (v12 == 1667329122)
    {
      uint64_t v13 = 0;
      uint64_t v14 = &v13;
      uint64_t v15 = 0x3000000000;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v16 = 0;
      uint64_t v5 = CMBaseObjectGetDerivedStorage(a1);
      uint64_t int64 = xpc_dictionary_get_uint64(a2, "CompletionID");
      int v7 = *(NSObject **)(v5 + 16);
      blocuint64_t k = MEMORY[0x1E4F143A8];
      uint64_t v20 = 0x40000000;
      uint64_t v21 = __remoteXPCEndpointRemoteControlSessionClient_handleCompletionCallback_block_invoke;
      uint64_t v22 = &unk_1E567E610;
      uint64_t v24 = (__CFDictionary **)v5;
      uint64_t v25 = uint64;
      uint64_t v23 = &v13;
      dispatch_sync(v7, &block);
      if (v14[3] == 1936614509)
      {
        uint64_t v26 = 0;
        int64_t int64 = xpc_dictionary_get_int64(a2, "ResponseStatus");
        FigXPCMessageCopyCFObject(a2, "ResponseParams", &v26);
        ((void (*)(int64_t, __CFDictionary *, uint64_t))v14[5])(int64, v26, v14[4]);
        if (v26) {
          CFRelease(v26);
        }
      }
LABEL_17:
      _Block_object_dispose(&v13, 8);
      return 0;
    }
    return 4294951138;
  }
  return result;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_runOneCallback(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  if (*(void *)a2 == 1936614509) {
    return (*(uint64_t (**)(void, void, void))(a2 + 16))(*a3, 0, *(void *)(a2 + 8));
  }
  return result;
}

void __remoteXPCEndpointRemoteControlSessionClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(*(void *)(a1 + 40) + 24);
  if (v2)
  {
    CFStringRef Value = CFDictionaryGetValue(v2, *(const void **)(a1 + 48));
    if (Value)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
      long long v5 = *(_OWORD *)Value;
      *(void *)(v4 + 40) = Value[2];
      *(_OWORD *)(v4 + 24) = v5;
    }
    uint64_t v6 = *(const void **)(a1 + 48);
    int v7 = *(__CFDictionary **)(*(void *)(a1 + 40) + 24);
    CFDictionaryRemoveValue(v7, v6);
  }
}

void *__remoteXPCEndpointRemoteControlSessionClient_eventHandlerCallback_block_invoke(void *result)
{
  uint64_t v1 = result[6];
  if (*(void *)(v1 + 32))
  {
    CFDictionaryRef v2 = result;
    uint64_t result = FigCFWeakReferenceLoadAndRetain((id *)(v1 + 40));
    *(void *)(*(void *)(v2[4] + 8) + 24) = result;
    *(void *)(*(void *)(v2[5] + 8) + 24) = *(void *)(v2[6] + 32);
  }
  return result;
}

__n128 remoteXPCEndpointRemoteControlSession_cloneCompletionCallback(const __CFAllocator *a1, __n128 *a2)
{
  uint64_t v3 = (__n128 *)CFAllocatorAllocate(a1, 24, 0);
  unint64_t v4 = a2[1].n128_u64[0];
  __n128 result = *a2;
  *uint64_t v3 = *a2;
  v3[1].n128_u64[0] = v4;
  return result;
}

void FigEndpointRemoteControlSessionRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v3 = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = v3;
  xpc_object_t v8 = 0;
  if (!*(unsigned char *)v3)
  {
    long long v5 = *(const void **)(v3 + 8);
    *(unsigned char *)uint64_t v3 = 1;
    FigXPCRemoteClientDisassociateObject(gFigEndpointRemoteControlSessionRemoteClient, v5);
    if (!*(unsigned char *)(v4 + 1) && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v5, &v8)) {
      FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v8);
    }
  }
  uint64_t v6 = *(const void **)(v4 + 24);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(v4 + 24) = 0;
  }
  FigXPCRelease(v8);
  int v7 = *(NSObject **)(DerivedStorage + 16);
  if (v7) {
    dispatch_release(v7);
  }
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_SendMessage(uint64_t a1, const void *a2, void (*a3)(uint64_t, void, uint64_t), uint64_t a4)
{
  uint64_t v17 = 0;
  *(void *)uint64_t v18 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  if (a2
    && !remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v17)
    && !FigXPCCreateBasicMessage(0x736E646Du, v17, v18))
  {
    FigXPCMessageSetCFData(*(void **)v18, "Params", a2);
  }
  if (a3)
  {
    uint64_t v15 = a4;
    uint64_t v16 = a3;
    uint64_t v14 = 1936614509;
  }
  xpc_object_t v8 = *(void **)v18;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000;
  uint64_t v28 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000;
  char v24 = 0;
  CFDictionaryValueCallBacks v10 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigEndpointRemoteControlSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
  block[3] = &unk_1E567E660;
  void block[4] = &v25;
  void block[5] = a1;
  void block[6] = DerivedStorage;
  void block[7] = &v14;
  dispatch_sync(v10, block);
  if (v8)
  {
    xpc_dictionary_set_uint64(v8, "CompletionID", v26[3]);
    uint64_t v11 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v8);
    if (!v11) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v11 = 4294949866;
  }
  int v12 = *(NSObject **)(DerivedStorage + 16);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 0x40000000;
  v19[2] = __FigEndpointRemoteControlSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke_2;
  v19[3] = &unk_1E567E688;
  v19[5] = &v21;
  v19[6] = DerivedStorage;
  v19[4] = &v25;
  dispatch_sync(v12, v19);
  if (*((unsigned char *)v22 + 24) && v14 == 1936614509) {
    v16(v11, 0, v15);
  }
LABEL_13:
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointRemoteControlSessionRemoteClient, v11, "FigEndpointRemoteControlSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  FigXPCRelease(*(xpc_object_t *)v18);
  return v11;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_SetEventHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = 0;
  xpc_object_t v14 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v13);
  if (!ObjectID)
  {
    if (a2) {
      unsigned int v7 = 1936029288;
    }
    else {
      unsigned int v7 = 1667593832;
    }
    ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(v7, v13, &v14);
    if (!ObjectID)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      dispatch_queue_t v9 = *(NSObject **)(DerivedStorage + 16);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteControlSessionRemoteXPC_SetEventHandler_block_invoke;
      block[3] = &__block_descriptor_tmp_10_7;
      void block[4] = DerivedStorage;
      void block[5] = a2;
      void block[6] = a3;
      dispatch_sync(v9, block);
      ObjectIOSurfaceID ID = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v14);
    }
  }
  uint64_t v10 = ObjectID;
  FigXPCRelease(v14);
  return v10;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_TeardownSession(uint64_t a1)
{
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v6);
  if (ObjectID)
  {
    uint64_t v4 = ObjectID;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v2 = FigXPCCreateBasicMessage(0x7472646Eu, v6, &v7);
    uint64_t v3 = v7;
    if (v2)
    {
      uint64_t v4 = v2;
    }
    else
    {
      uint64_t v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v7);
      uint64_t v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_Start(uint64_t a1)
{
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  ObjectIOSurfaceID ID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v6);
  if (ObjectID)
  {
    uint64_t v4 = ObjectID;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v2 = FigXPCCreateBasicMessage(0x73747274u, v6, &v7);
    uint64_t v3 = v7;
    if (v2)
    {
      uint64_t v4 = v2;
    }
    else
    {
      uint64_t v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v7);
      uint64_t v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

uint64_t FigTransportConnectionTCPCreate(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    ClassIOSurfaceID ID = (void *)NeroTransportConnectionGetClassID();
    uint64_t v5 = CMDerivedObjectCreate(a1, (uint64_t)&kFigTransportConnectionUSBVTable_0, ClassID, &cf);
    if (!v5)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *(void *)(DerivedStorage + 88) = -1;
      *(_DWORD *)(DerivedStorage + 96) = -1;
      *(_DWORD *)(DerivedStorage + 104) = -1;
      dispatch_queue_t v7 = FigDispatchQueueCreateWithPriority("FigTransportConnectionTCP", 0, 0x1Cu);
      *(void *)(DerivedStorage + 8) = v7;
      if (v7)
      {
        dispatch_queue_t v8 = FigDispatchQueueCreateWithPriority("FigTransportConnectionTCP.data", 0, 0x1Cu);
        *(void *)(DerivedStorage + 16) = v8;
        if (v8)
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(Mutable, @"FigMemoryPool_LoggingName", @"TransportConnectionTCP");
          uint64_t v10 = CMMemoryPoolCreate(Mutable);
          *(void *)(DerivedStorage + 72) = v10;
          if (Mutable)
          {
            CFRelease(Mutable);
            uint64_t v10 = *(OpaqueCMMemoryPool **)(DerivedStorage + 72);
          }
          if (v10)
          {
            CFAllocatorRef Allocator = CMMemoryPoolGetAllocator(v10);
            *(void *)(DerivedStorage + 80) = Allocator;
            if (Allocator) {
              CFRetain(Allocator);
            }
            uint64_t v5 = 0;
            *(_DWORD *)(DerivedStorage + 40) = 29888;
            *a2 = cf;
            return v5;
          }
        }
      }
      uint64_t v5 = 4294955245;
    }
    if (cf) {
      CFRelease(cf);
    }
    return v5;
  }

  return FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
}

uint64_t tcp_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(unsigned char *)DerivedStorage)
  {
    uint64_t v2 = DerivedStorage;
    *(unsigned char *)uint64_t DerivedStorage = 1;
    uint64_t v3 = *(NSObject **)(DerivedStorage + 64);
    if (v3)
    {
      dispatch_release(v3);
      *(void *)(v2 + 64) = 0;
    }
    uint64_t v4 = *(const void **)(v2 + 56);
    if (v4)
    {
      _Block_release(v4);
      *(void *)(v2 + 56) = 0;
    }
  }
  return 0;
}

void tcp_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  tcp_Invalidate(a1);
  tcp_CleanupFileDescriptors(a1);
  uint64_t v3 = DerivedStorage[1];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[1] = 0;
  }
  uint64_t v4 = DerivedStorage[2];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[2] = 0;
  }
  uint64_t v5 = (const void *)DerivedStorage[3];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[3] = 0;
  }
  uint64_t v6 = (const void *)DerivedStorage[4];
  if (v6)
  {
    CFRelease(v6);
    DerivedStorage[4] = 0;
  }
  dispatch_queue_t v7 = DerivedStorage[8];
  if (v7)
  {
    dispatch_release(v7);
    DerivedStorage[8] = 0;
  }
  dispatch_queue_t v8 = (const void *)DerivedStorage[7];
  if (v8)
  {
    _Block_release(v8);
    DerivedStorage[7] = 0;
  }
  dispatch_queue_t v9 = (const void *)DerivedStorage[9];
  if (v9)
  {
    CFRelease(v9);
    DerivedStorage[9] = 0;
  }
  uint64_t v10 = (const void *)DerivedStorage[10];
  if (v10)
  {
    CFRelease(v10);
    DerivedStorage[10] = 0;
  }
}

__CFString *tcp_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigTransportConnectionUSB %p>", a1);
  return Mutable;
}

uint64_t tcp_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  dispatch_queue_t v7 = DerivedStorage;
  if (CFEqual(a2, @"ConnectionMode"))
  {
    dispatch_queue_t v8 = (const void *)v7[3];
    if (!v8) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if (CFEqual(a2, @"IPAddress"))
  {
    dispatch_queue_t v8 = (const void *)v7[4];
    if (v8) {
LABEL_7:
    }
      dispatch_queue_t v8 = CFRetain(v8);
  }
  else
  {
    if (!CFEqual(a2, @"Version")) {
      return 4294954512;
    }
    dispatch_queue_t v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (char *)v7 + 44);
  }
LABEL_8:
  uint64_t v9 = 0;
  *a4 = v8;
  return v9;
}

uint64_t tcp_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  uint64_t v6 = DerivedStorage;
  if (CFEqual(a2, @"ConnectionMode"))
  {
    uint64_t v7 = v6[3];
    v6[3] = a3;
    if (!a3) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (CFEqual(a2, @"IPAddress"))
  {
    uint64_t v7 = v6[4];
    v6[4] = a3;
    if (!a3)
    {
LABEL_5:
      if (v7)
      {
        CFRelease((CFTypeRef)v7);
        return 0;
      }
      return v7;
    }
LABEL_4:
    CFRetain(a3);
    goto LABEL_5;
  }
  if (CFEqual(a2, @"Port"))
  {
    CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v6 + 5);
    return 0;
  }
  if (!CFEqual(a2, @"Version")) {
    return 4294954512;
  }
  if (!a3) {
    return 4294954516;
  }
  CFTypeID v9 = CFGetTypeID(a3);
  uint64_t v7 = 4294954516;
  if (v9 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (char *)v6 + 44)) {
      return 0;
    }
    else {
      return 4294954516;
    }
  }
  return v7;
}

uint64_t tcp_CleanupFileDescriptors(uint64_t a1)
{
  uint64_t DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage(a1);
  int v2 = DerivedStorage[22];
  if ((v2 & 0x80000000) == 0)
  {
    close(v2);
    DerivedStorage[22] = -1;
  }
  int v3 = DerivedStorage[23];
  if ((v3 & 0x80000000) == 0)
  {
    close(v3);
    DerivedStorage[23] = -1;
  }
  int v4 = DerivedStorage[24];
  if ((v4 & 0x80000000) == 0)
  {
    close(v4);
    DerivedStorage[24] = -1;
  }
  uint64_t result = DerivedStorage[26];
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = close(result);
    DerivedStorage[26] = -1;
  }
  return result;
}

uint64_t tcp_SetEventHandler(uint64_t a1, NSObject *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  uint64_t v6 = DerivedStorage;
  uint64_t v7 = *(NSObject **)(DerivedStorage + 64);
  if (v7)
  {
    dispatch_release(v7);
    *(void *)(v6 + 64) = 0;
  }
  if (a2)
  {
    *(void *)(v6 + 64) = a2;
    dispatch_retain(a2);
  }
  else
  {
    *(void *)(v6 + 64) = FigDispatchQueueCreateWithPriority("FigTransportConnectionEvent", 0, 0x1Cu);
  }
  dispatch_queue_t v8 = *(const void **)(v6 + 56);
  if (v8)
  {
    _Block_release(v8);
    *(void *)(v6 + 56) = 0;
  }
  if (!a3) {
    return 0;
  }
  CFTypeID v9 = _Block_copy(a3);
  uint64_t result = 0;
  *(void *)(v6 + 56) = v9;
  return result;
}

uint64_t tcp_Start(uint64_t a1)
{
  uint64_t v7 = 0;
  dispatch_queue_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  int v10 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v4 = 4294955241;
    *((_DWORD *)v8 + 6) = -12055;
  }
  else
  {
    int v3 = *(NSObject **)(DerivedStorage + 8);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __tcp_Start_block_invoke;
    block[3] = &unk_1E567E6E0;
    void block[4] = &v7;
    void block[5] = DerivedStorage;
    void block[6] = a1;
    dispatch_sync(v3, block);
    uint64_t v4 = *((unsigned int *)v8 + 6);
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t tcp_Stop(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  int v3 = *(NSObject **)(DerivedStorage + 8);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __tcp_Stop_block_invoke;
  v5[3] = &__block_descriptor_tmp_28_3;
  v5[4] = DerivedStorage;
  v5[5] = a1;
  dispatch_sync(v3, v5);
  return 0;
}

uint64_t tcp_EnqueuePackageWithPriority(const void *a1, unsigned int *a2, OpaqueCMBlockBuffer *a3, int a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v9 = *a2;
  size_t DataLength = CMBlockBufferGetDataLength(a3);
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v12 = 4294955241;
    goto LABEL_11;
  }
  if (a2[1] == 1885957735) {
    goto LABEL_15;
  }
  if (!*(unsigned char *)(DerivedStorage + 121))
  {
    uint64_t v16 = 4294955244;
    goto LABEL_18;
  }
  if ((a4 - 3) <= 0xFFFFFFFD || (size_t v11 = v9 - DataLength, v11 <= 7))
  {
LABEL_15:
    uint64_t v16 = 4294955246;
LABEL_18:
    uint64_t v12 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  CMBlockBufferRef blockBufferOut = 0;
  if (CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v11, (CFAllocatorRef)*MEMORY[0x1E4F1CF90], 0, 0, v11, 1u, &blockBufferOut)|| CMBlockBufferReplaceDataBytes(a2, blockBufferOut, 0, v11)|| a3 && CMBlockBufferAppendBufferReference(blockBufferOut, a3, 0, 0, 0))
  {
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
    uint64_t v12 = 4294955245;
  }
  else
  {
    xpc_object_t v14 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    v14[1] = blockBufferOut;
    CFRetain(a1);
    uint64_t v15 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __tcp_EnqueuePackageWithPriority_block_invoke;
    block[3] = &__block_descriptor_tmp_30_0;
    void block[4] = v14;
    void block[5] = DerivedStorage;
    int v18 = a4;
    void block[6] = a1;
    dispatch_async(v15, block);
    uint64_t v12 = 0;
  }
LABEL_11:
  tcp_destroyPackageRecord(0);
  return v12;
}

uint64_t tcp_FlushPendingPackagesWithPriority(uint64_t a1, int a2)
{
  if (*(unsigned char *)CMBaseObjectGetDerivedStorage(a1)) {
    return 4294955241;
  }
  tcp_sendDataToSocket(a1, a2);
  return 0;
}

uint64_t tcp_clientThreadMain(const void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(unsigned char *)(DerivedStorage + 120))
  {
    uint64_t v4 = DerivedStorage;
    do
    {
      uint64_t v5 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      int v6 = socket(2, 1, 6);
      *(_DWORD *)(v5 + 88) = v6;
      if ((v6 & 0x80000000) == 0)
      {
        *(_DWORD *)&v16.sa_data[10] = 0;
        *(void *)&v16.sa_data[2] = 0;
        *(_WORD *)&v16.sa_len = 528;
        *(_WORD *)v16.sa_CFDataRef data = bswap32(*(unsigned __int16 *)(v5 + 40)) >> 16;
        CFStringRef v7 = *(const __CFString **)(v5 + 32);
        if (v7)
        {
          uint64_t v13 = 0;
          CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v7, 0x600u, (char **)&v13);
          in_addr_t v9 = inet_addr(CStringPtrAndBufferToFree);
          if (v9 == -1)
          {
            xpc_object_t v14 = 0;
            memset(&v15, 0, sizeof(v15));
            *(void *)&v15.ai_famildouble y = 0x100000002;
            if (getaddrinfo(CStringPtrAndBufferToFree, 0, &v15, &v14) || !v14)
            {
              int v10 = -1;
            }
            else
            {
              int v10 = *(_DWORD *)&v14->ai_addr->sa_data[2];
              freeaddrinfo(v14);
            }
          }
          else
          {
            int v10 = v9;
          }
          *(_DWORD *)&v16.sa_data[2] = v10;
          free(v13);
          int v6 = *(_DWORD *)(v5 + 88);
        }
        if (!connect(v6, &v16, 0x10u))
        {
          *(_DWORD *)(v5 + 96) = *(_DWORD *)(v5 + 88);
          *(_DWORD *)(v5 + 88) = -1;
          tcp_sendAndReceiveData(a1);
        }
      }
      int v11 = *(_DWORD *)(v5 + 96);
      if ((v11 & 0x80000000) == 0)
      {
        close(v11);
        *(_DWORD *)(v5 + 96) = -1;
      }
      int v12 = *(_DWORD *)(v5 + 88);
      if ((v12 & 0x80000000) == 0)
      {
        close(v12);
        *(_DWORD *)(v5 + 88) = -1;
      }
      sleep(5u);
    }
    while (!*(unsigned char *)(v4 + 120));
  }
  return 0;
}

void tcp_sendAndReceiveData(const void *a1)
{
  v27[8] = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFRetain(a1);
  int v3 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __tcp_sendAndReceiveData_block_invoke;
  block[3] = &__block_descriptor_tmp_18_3;
  void block[4] = DerivedStorage;
  void block[5] = a1;
  dispatch_async(v3, block);
  uint64_t v4 = (pollfd *)(DerivedStorage + 96);
  if (!fcntl(*(_DWORD *)(DerivedStorage + 96), 4, 4) && !fcntl(*(_DWORD *)(DerivedStorage + 104), 4, 4))
  {
    *(_WORD *)(DerivedStorage + 100) = 5;
    *(_WORD *)(DerivedStorage + 108) = 1;
    while (!*(unsigned char *)(DerivedStorage + 120))
    {
      if (poll(v4, 2u, -1) < 0) {
        break;
      }
      if ((*(_WORD *)(DerivedStorage + 110) & 0x19) != 0)
      {
        while ((int)read(*(_DWORD *)(DerivedStorage + 104), v27, 0x40uLL) > 0)
          ;
        if (*(unsigned char *)(DerivedStorage + 120)) {
          break;
        }
      }
      __int16 v6 = *(_WORD *)(DerivedStorage + 102);
      if ((v6 & 0x18) != 0) {
        break;
      }
      if (v6)
      {
        uint64_t v7 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
        uint64_t v23 = 0;
        char v24 = &v23;
        uint64_t v25 = 0x2000000000;
        char v26 = 1;
        uint64_t v8 = MEMORY[0x1E4F143A8];
        do
        {
          uint64_t v19 = 0;
          uint64_t v20 = &v19;
          uint64_t v21 = 0x2000000000;
          uint64_t v22 = 0;
          in_addr_t v9 = *(NSObject **)(v7 + 16);
          v18[0] = v8;
          v18[1] = 0x40000000;
          int v18[2] = __tcp_readDataFromSocket_block_invoke;
          v18[3] = &unk_1E567E7A8;
          v18[5] = &v19;
          void v18[6] = a1;
          v18[4] = &v23;
          dispatch_sync(v9, v18);
          int v10 = (const void *)v20[3];
          if (v10)
          {
            uint64_t v11 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
            if (*(void *)(v11 + 56))
            {
              uint64_t v12 = v11;
              CFRetain(v10);
              CFRetain(a1);
              uint64_t v13 = *(NSObject **)(v12 + 64);
              v27[0] = MEMORY[0x1E4F143A8];
              v27[1] = 0x40000000;
              v27[2] = __tcp_didReceivePackage_block_invoke;
              v27[3] = &__block_descriptor_tmp_23_2;
              v27[4] = v12;
              v27[5] = v10;
              void v27[6] = a1;
              dispatch_async(v13, v27);
            }
            CFRelease((CFTypeRef)v20[3]);
          }
          _Block_object_dispose(&v19, 8);
        }
        while (*((unsigned char *)v24 + 24));
        _Block_object_dispose(&v23, 8);
        __int16 v6 = *(_WORD *)(DerivedStorage + 102);
        uint64_t v4 = (pollfd *)(DerivedStorage + 96);
      }
      if ((v6 & 4) != 0) {
        tcp_sendDataToSocket((uint64_t)a1, 0);
      }
      xpc_object_t v14 = *(NSObject **)(DerivedStorage + 16);
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 0x40000000;
      int v16[2] = __tcp_sendAndReceiveData_block_invoke_3;
      v16[3] = &__block_descriptor_tmp_19_1;
      _OWORD v16[4] = DerivedStorage;
      dispatch_sync(v14, v16);
    }
  }
  CFRetain(a1);
  uint64_t v5 = *(NSObject **)(DerivedStorage + 16);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  int v15[2] = __tcp_sendAndReceiveData_block_invoke_4;
  v15[3] = &__block_descriptor_tmp_21_2;
  v15[4] = DerivedStorage;
  void v15[5] = a1;
  dispatch_async(v5, v15);
}

void __tcp_sendAndReceiveData_block_invoke(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = *(void *)(a1 + 32);
  do
  {
    *(void *)(v3 + v2 + 152) = 0;
    *(void *)(*(void *)(a1 + 32) + v2 + 160) = *(void *)(a1 + 32) + v2 + 152;
    uint64_t v3 = *(void *)(a1 + 32);
    *(void *)(v3 + v2 + 168) = 0;
    v2 += 24;
  }
  while (v2 != 48);
  *(void *)(v3 + 200) = 0;
  *(_DWORD *)(v3 + 208) = 0;
  *(void *)(v3 + 216) = 0;
  uint64_t v4 = *(void *)(a1 + 32);
  *(unsigned char *)(v4 + 121) = 1;
  if (*(void *)(v4 + 56))
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = __tcp_sendAndReceiveData_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_17_6;
    long long v6 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v6 + 64), v5);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __tcp_sendAndReceiveData_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 56) + 16))();
  uint64_t v2 = *(const void **)(a1 + 40);

  CFRelease(v2);
}

void tcp_sendDataToSocket(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v5 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __tcp_sendDataToSocket_block_invoke;
  block[3] = &__block_descriptor_tmp_24_4;
  void block[4] = DerivedStorage;
  void block[5] = a1;
  int v7 = a2;
  dispatch_sync(v5, block);
}

uint64_t __tcp_sendAndReceiveData_block_invoke_3(uint64_t result)
{
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)(result + 32);
  *(_WORD *)(v2 + 100) = 1;
  *(_WORD *)(v2 + 108) = 1;
  while (!*(void *)(v2 + 152 + v1))
  {
    v1 += 24;
    if (v1 == 48) {
      return result;
    }
  }
  *(_WORD *)(v2 + 100) = 5;
  return result;
}

void __tcp_sendAndReceiveData_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(unsigned char *)(v2 + 121) = 0;
  if (*(void *)(v2 + 56))
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    int v10[2] = __tcp_sendAndReceiveData_block_invoke_5;
    v10[3] = &__block_descriptor_tmp_20_0;
    long long v11 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v11 + 64), v10);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  uint64_t v3 = *(const void **)(v2 + 216);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(*(void *)(a1 + 32) + 216) = 0;
    uint64_t v2 = *(void *)(a1 + 32);
  }
  *(_DWORD *)(v2 + 208) = 0;
  *(void *)(v2 + 200) = 0;
  for (uint64_t i = 1; i != 3; ++i)
  {
    while (1)
    {
      uint64_t v5 = v2 + 24 * i;
      uint64_t v8 = *(CFTypeRef **)(v5 + 128);
      long long v6 = (CFTypeRef *)(v5 + 128);
      int v7 = v8;
      if (!v8) {
        break;
      }
      CFTypeRef v9 = *v7;
      *long long v6 = *v7;
      if (!v9) {
        *(void *)(*(void *)(a1 + 32) + 24 * i + 136) = *(void *)(a1 + 32) + 24 * i + 128;
      }
      CFRelease(v7[1]);
      free(v7);
      uint64_t v2 = *(void *)(a1 + 32);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __tcp_sendAndReceiveData_block_invoke_5(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 56) + 16))();
  uint64_t v2 = *(const void **)(a1 + 40);

  CFRelease(v2);
}

void tcp_destroyPackageRecord(CFTypeRef *a1)
{
  if (a1)
  {
    CFRelease(a1[1]);
    free(a1);
  }
}

uint64_t __tcp_readDataFromSocket_block_invoke(void *a1)
{
  uint64_t v2 = *(void *)(a1[5] + 8);
  uint64_t result = CMBaseObjectGetDerivedStorage(a1[6]);
  uint64_t v4 = result;
  size_t v5 = *(void *)(result + 200);
  if (v5 <= 3)
  {
    uint64_t v6 = result + 208;
    while (1)
    {
      int v7 = (char *)(v6 + v5);
      size_t v8 = 4 - v5;
      uint64_t result = read(*(_DWORD *)(v4 + 96), (void *)(v6 + v5), 4 - v5);
      if (result < 1) {
        break;
      }
      size_t v5 = *(void *)(v4 + 200) + result;
      *(void *)(v4 + 200) = v5;
      if (v5 >= 4) {
        goto LABEL_7;
      }
    }
LABEL_15:
    char v10 = 0;
    goto LABEL_16;
  }
  size_t v8 = 0;
  int v7 = 0;
LABEL_7:
  size_t lengthAtOffsetOut = v8;
  dataPointerOut = v7;
  CFTypeRef v9 = (CMBlockBufferRef *)(v4 + 216);
  if (*(void *)(v4 + 216)) {
    goto LABEL_8;
  }
  uint64_t result = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(unsigned int *)(v4 + 208), *(CFAllocatorRef *)(v4 + 80), 0, 0, *(unsigned int *)(v4 + 208), 1u, (CMBlockBufferRef *)(v4 + 216));
  if (result) {
    goto LABEL_15;
  }
  uint64_t result = CMBlockBufferReplaceDataBytes((const void *)(v4 + 208), *v9, 0, 4uLL);
  if (result) {
    goto LABEL_15;
  }
  size_t v5 = *(void *)(v4 + 200);
LABEL_8:
  while (v5 < *(unsigned int *)(v4 + 208))
  {
    uint64_t result = CMBlockBufferGetDataPointer(*v9, v5, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (result) {
      goto LABEL_15;
    }
    uint64_t result = read(*(_DWORD *)(v4 + 96), dataPointerOut, lengthAtOffsetOut);
    if (result < 1) {
      goto LABEL_15;
    }
    size_t v5 = *(void *)(v4 + 200) + result;
    *(void *)(v4 + 200) = v5;
  }
  *(void *)(v2 + 24) = *(void *)(v4 + 216);
  *(void *)(v4 + 216) = 0;
  *(_DWORD *)(v4 + 208) = 0;
  *(void *)(v4 + 200) = 0;
  char v10 = 1;
LABEL_16:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v10;
  return result;
}

void __tcp_didReceivePackage_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 56) + 16))();
  CFRelease(*(CFTypeRef *)(a1 + 40));
  uint64_t v2 = *(const void **)(a1 + 48);

  CFRelease(v2);
}

void __tcp_sendDataToSocket_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  for (uint64_t i = 152; i != 200; i += 24)
  {
    size_t v4 = *(void *)(v2 + i + 16);
    if (v4)
    {
      uint64_t v5 = *(void *)(v2 + i);
      uint64_t v6 = tcp_sendPackageToSocket(*(void *)(a1 + 40), *(CMBlockBufferRef *)(v5 + 8), v4);
      uint64_t v7 = *(void *)(a1 + 32) + i;
      size_t v8 = *(void *)(v7 + 16) + v6;
      *(void *)(v7 + 16) = v8;
      if (v8 < CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(v5 + 8))) {
        return;
      }
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = **(void **)(v9 + i);
      *(void *)(v9 + i) = v10;
      if (!v10) {
        *(void *)(*(void *)(a1 + 32) + i + 8) = *(void *)(a1 + 32) + i;
      }
      tcp_destroyPackageRecord((CFTypeRef *)v5);
      uint64_t v2 = *(void *)(a1 + 32);
      *(void *)(v2 + i + 16) = 0;
    }
  }
  int v11 = *(_DWORD *)(a1 + 48);
  if (v11)
  {
    uint64_t v12 = *(CMBlockBufferRef **)(v2 + 24 * v11 + 128);
    if (!v12) {
      return;
    }
    while (1)
    {
      unint64_t v13 = tcp_sendPackageToSocket(*(void *)(a1 + 40), v12[1], 0);
      size_t DataLength = CMBlockBufferGetDataLength(v12[1]);
      uint64_t v15 = *(void *)(a1 + 32);
      int v16 = *(_DWORD *)(a1 + 48);
      if (v13 < DataLength) {
        break;
      }
      uint64_t v17 = v15 + 24 * v16;
      uint64_t v18 = **(void **)(v17 + 128);
      *(void *)(v17 + 128) = v18;
      if (!v18)
      {
        uint64_t v19 = *(void *)(a1 + 32) + 24 * v16;
        *(void *)(v19 + 136) = v19 + 128;
      }
      CFRelease(v12[1]);
      free(v12);
      uint64_t v12 = *(CMBlockBufferRef **)(*(void *)(a1 + 32) + 24 * *(int *)(a1 + 48) + 128);
      if (!v12) {
        return;
      }
    }
    uint64_t v26 = v15 + 24 * v16;
  }
  else
  {
    uint64_t v20 = 1;
    while (1)
    {
      while (1)
      {
        uint64_t v21 = *(CMBlockBufferRef **)(v2 + 24 * v20 + 128);
        if (v21) {
          break;
        }
        if (++v20 == 3) {
          return;
        }
      }
      unint64_t v13 = tcp_sendPackageToSocket(*(void *)(a1 + 40), v21[1], 0);
      size_t v22 = CMBlockBufferGetDataLength(v21[1]);
      uint64_t v23 = *(void *)(a1 + 32);
      if (v13 < v22) {
        break;
      }
      uint64_t v24 = v23 + 24 * v20;
      uint64_t v25 = **(void **)(v24 + 128);
      *(void *)(v24 + 128) = v25;
      if (!v25) {
        *(void *)(*(void *)(a1 + 32) + 24 * v20 + 136) = *(void *)(a1 + 32) + 24 * v20 + 128;
      }
      CFRelease(v21[1]);
      free(v21);
      uint64_t v2 = *(void *)(a1 + 32);
    }
    uint64_t v26 = v23 + 24 * v20;
  }
  *(void *)(v26 + 144) = v13;
}

uint64_t tcp_sendPackageToSocket(uint64_t a1, CMBlockBufferRef theBuffer, size_t a3)
{
  size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
  uint64_t v7 = 0;
  while (a3 < DataLength)
  {
    uint64_t v15 = 0;
    size_t lengthAtOffsetOut = 0;
    if (CMBlockBufferGetDataPointer(theBuffer, a3, &lengthAtOffsetOut, 0, &v15)) {
      break;
    }
    size_t v8 = v15;
    size_t v9 = lengthAtOffsetOut;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    size_t v11 = 0;
    do
    {
      size_t v12 = v11;
      if (v9 <= v11) {
        break;
      }
      ssize_t v13 = write(*(_DWORD *)(DerivedStorage + 96), &v8[v11], v9 - v11);
      size_t v11 = v13 + v12;
    }
    while (v13 > 0);
    v7 += v12;
    if (v12 != lengthAtOffsetOut) {
      break;
    }
    a3 += v12;
  }
  return v7;
}

uint64_t tcp_serverThreadMain(const void *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(unsigned char *)(DerivedStorage + 120))
  {
    uint64_t v3 = DerivedStorage;
    do
    {
      uint64_t v4 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      int v5 = socket(2, 1, 6);
      *(_DWORD *)(v4 + 88) = v5;
      if ((v5 & 0x80000000) == 0)
      {
        int v12 = 1;
        if (!setsockopt(v5, 0xFFFF, 4, &v12, 4u))
        {
          *(_DWORD *)&v13.sa_data[10] = 0;
          *(void *)&v13.sa_data[2] = 0;
          *(_WORD *)&v13.sa_len = 528;
          *(_WORD *)v13.sa_CFDataRef data = bswap32(*(unsigned __int16 *)(v4 + 40)) >> 16;
          CFStringRef v6 = *(const __CFString **)(v4 + 32);
          if (v6)
          {
            *(void *)size_t v11 = 0;
            CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v6, 0x600u, (char **)v11);
            *(_DWORD *)&v13.sa_data[2] = inet_addr(CStringPtrAndBufferToFree);
            free(*(void **)v11);
          }
          if (!bind(*(_DWORD *)(v4 + 88), &v13, 0x10u) && !listen(*(_DWORD *)(v4 + 88), 5))
          {
            v11[0] = 16;
            *(_DWORD *)(v4 + 96) = accept(*(_DWORD *)(v4 + 88), &v13, v11);
            tcp_sendAndReceiveData(a1);
          }
        }
      }
      int v8 = *(_DWORD *)(v4 + 96);
      if ((v8 & 0x80000000) == 0)
      {
        close(v8);
        *(_DWORD *)(v4 + 96) = -1;
      }
      int v9 = *(_DWORD *)(v4 + 88);
      if ((v9 & 0x80000000) == 0)
      {
        close(v9);
        *(_DWORD *)(v4 + 88) = -1;
      }
    }
    while (!*(unsigned char *)(v3 + 120));
  }
  return 0;
}

dispatch_queue_t FigDispatchQueueCreateWithPriority(const char *a1, NSObject *a2, unsigned int a3)
{
  if (FigGetQualityOfServiceClassForFigThreadPriority(a3))
  {
    if (a2 != MEMORY[0x1E4F14430]) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (a3 - 41 < 2)
  {
    if (figDispatch_shouldUseWorkloopForFigThreadPriority_onceToken != -1) {
      dispatch_once_f(&figDispatch_shouldUseWorkloopForFigThreadPriority_onceToken, &figDispatch_shouldUseWorkloopForFigThreadPriority_shouldUseWorkloopForAssetQueues, (dispatch_function_t)figDispatch_shouldUseWorkloopQueuesForAssetPrioritiesOnce);
    }
    int v6 = figDispatch_shouldUseWorkloopForFigThreadPriority_shouldUseWorkloopForAssetQueues;
  }
  else if (a3 == 4)
  {
    int v6 = 1;
  }
  else
  {
    int v6 = a3 == 44 && FigServer_IsServerProcess();
  }
  if (a2 == MEMORY[0x1E4F14430])
  {
LABEL_18:
    FigDebugIsInternalBuild();
LABEL_19:
    if (a3 == 39)
    {
      return FigDispatchQueueCreateStandardDispatchQueue(a1, a2, 9, QOS_CLASS_BACKGROUND);
    }
    else
    {
      return FigDispatchQueueCreateTargetingPThreadRootQueueWithPriority(a1, a2, a3);
    }
  }
  if (!v6) {
    goto LABEL_19;
  }

  return FigDispatchQueueCreateTargetingWorkloopWithPriority(a1, a2, a3);
}

uint64_t FigGetQualityOfServiceClassForFigThreadPriority(int a1)
{
  uint64_t result = 0;
  if (a1 <= 30)
  {
    if (a1 != 8)
    {
      if (a1 == 25) {
        return 9;
      }
      if (a1 != 30) {
        return result;
      }
      return 25;
    }
    return 17;
  }
  switch(a1)
  {
    case 46:
      return 25;
    case 38:
      return 33;
    case 31:
      return 17;
  }
  return result;
}

dispatch_queue_t FigDispatchQueueCreateTargetingWorkloopWithPriority(const char *a1, NSObject *a2, unsigned int a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)__str = 0u;
  long long v11 = 0u;
  if (a1) {
    snprintf(__str, 0x100uLL, "%s.workloop(%d)");
  }
  else {
    snprintf(__str, 0x100uLL, "com.apple.coremedia.unknown.workloop(%d)");
  }
  WorkloopWithPrioritdouble y = FigDispatchCreateWorkloopWithPriority(__str, a3);
  if (!WorkloopWithPriority) {
    return 0;
  }
  uint64_t v7 = WorkloopWithPriority;
  dispatch_queue_t v8 = dispatch_queue_create_with_target_V2(a1, a2, WorkloopWithPriority);
  if (gGMFigKTraceEnabled == 1)
  {
    FigThreadGetMachThreadPriorityValue(a3);
    kdebug_trace();
  }
  dispatch_release(v7);
  return v8;
}

NSObject *FigDispatchQueueCreateTargetingPThreadRootQueueWithPriority(const char *a1, NSObject *a2, unsigned int a3)
{
  RootQueueWithPrioritdouble y = figDispatch_getRootQueueWithPriority(a3);
  uint64_t v7 = dispatch_queue_create(a1, a2);
  if (gGMFigKTraceEnabled == 1)
  {
    FigThreadGetMachThreadPriorityValue(a3);
    kdebug_trace();
  }
  if (v7 && RootQueueWithPriority) {
    dispatch_set_target_queue(v7, RootQueueWithPriority);
  }
  return v7;
}

NSObject *FigDispatchQueueCreateStandardDispatchQueue(const char *a1, dispatch_queue_attr_t attr, int a3, dispatch_qos_class_t a4)
{
  initially_inuint64_t active = dispatch_queue_attr_make_initially_inactive(attr);
  dispatch_queue_t v8 = dispatch_queue_create(a1, initially_inactive);
  if (v8)
  {
    if (a3) {
      dispatch_set_qos_class_fallback();
    }
    if (a4) {
      dispatch_set_qos_class_floor(v8, a4, 0);
    }
    dispatch_activate(v8);
    if (gGMFigKTraceEnabled == 1) {
      kdebug_trace();
    }
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return v8;
}

dispatch_queue_t FigDispatchQueueCreateWithPriorityAndClientPID(const char *a1, NSObject *a2, uint64_t a3, uint64_t a4)
{
  QualityOfServiceClassForFigThreadPrioritdouble y = FigGetQualityOfServiceClassForFigThreadPriority(a3);
  int v9 = dispatch_queue_attr_make_with_qos_class(a2, QualityOfServiceClassForFigThreadPriority, 0);
  if (a4)
  {
    uint64_t v10 = dispatch_queue_create(a1, v9);
    if (v10)
    {
      long long v11 = figDispatch_copyRootQueueWithPriorityAndClientPID(a3, a4);
      if (v11)
      {
        long long v12 = v11;
        dispatch_set_target_queue(v10, v11);
        dispatch_release(v12);
      }
    }
    return v10;
  }
  else
  {
    return FigDispatchQueueCreateWithPriority(a1, v9, a3);
  }
}

NSObject *figDispatch_copyRootQueueWithPriorityAndClientPID(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (figDispatch_copyRootQueueWithPriorityAndClientPID_initQueuesDictOnce != -1) {
    dispatch_once(&figDispatch_copyRootQueueWithPriorityAndClientPID_initQueuesDictOnce, &__block_literal_global_52);
  }
  uint64_t v4 = (__CFString *)CFStringCreateWithFormat(0, 0, @"%d_%02d", a2, a1);
  FigSimpleMutexLock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);
  CFStringRef Value = (id *)CFDictionaryGetValue((CFDictionaryRef)sFigDispatchQueuesForPID_0, v4);
  if (Value)
  {
    int v6 = Value;
    RootQueueWithMachPrioritdouble y = FigCFWeakReferenceLoadAndRetain(Value);
    if (RootQueueWithMachPriority) {
      goto LABEL_11;
    }
    FigCFWeakReferenceStore(v6, 0);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigDispatchQueuesForPID_0, v4);
    free(v6);
  }
  dispatch_queue_t v8 = (id *)malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  if (v8)
  {
    int v9 = v8;
    QualityOfServiceClassForFigThreadPrioritdouble y = FigGetQualityOfServiceClassForFigThreadPriority(a1);
    MachThreadPriorityCFStringRef Value = FigThreadGetMachThreadPriorityValue(a1);
    snprintf(__str, 0x40uLL, "com.apple.coremedia.rootQueueForPID.%d_%02d", a2, a1);
    RootQueueWithMachPrioritdouble y = figDispatch_createRootQueueWithMachPriority((uint64_t)__str, MachThreadPriorityValue, QualityOfServiceClassForFigThreadPriority);
    if (RootQueueWithMachPriority)
    {
      CFRetain(v4);
      dispatch_queue_set_specific(RootQueueWithMachPriority, &figDispatch_copyRootQueueWithPriorityAndClientPID_sFigDispatchRootQueueContextKey, v4, (dispatch_function_t)figDispatch_rootQueueDestructor);
      FigCFWeakReferenceStore(v9, RootQueueWithMachPriority);
      CFDictionarySetValue((CFMutableDictionaryRef)sFigDispatchQueuesForPID_0, v4, v9);
    }
    else
    {
      free(v9);
    }
  }
  else
  {
    RootQueueWithMachPrioritdouble y = 0;
  }
LABEL_11:
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);
  CFRelease(v4);
  return RootQueueWithMachPriority;
}

uint64_t figDispatch_getRootQueueWithPriority(unsigned int a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = &sRootQueuesIndexedByFigThreadPriority[2 * a1];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figDispatch_getRootQueueWithPriority_block_invoke;
  block[3] = &__block_descriptor_tmp_10_8;
  unsigned int v6 = a1;
  if (*v3 != -1) {
    dispatch_once(v3, block);
  }
  return sRootQueuesIndexedByFigThreadPriority[2 * v2 + 1];
}

NSObject *FigDispatchCreateWorkloopWithPriority(const char *a1, unsigned int a2)
{
  inuint64_t active = dispatch_workloop_create_inactive(a1);
  FigThreadGetMachThreadPriorityValue(a2);
  dispatch_workloop_set_scheduler_priority();
  dispatch_activate(inactive);
  return inactive;
}

uint64_t FigDispatchQueueSetPriorityAndClientPID(NSObject *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (a3)
    {
      uint64_t v4 = figDispatch_copyRootQueueWithPriorityAndClientPID(a2, a3);
      if (v4)
      {
        int v5 = v4;
        dispatch_set_target_queue(a1, v4);
        dispatch_release(v5);
        return 0;
      }
      uint64_t v8 = 4294954510;
    }
    else
    {
      RootQueueWithPrioritdouble y = figDispatch_getRootQueueWithPriority(a2);
      if (RootQueueWithPriority)
      {
        dispatch_set_target_queue(a1, RootQueueWithPriority);
        return 0;
      }
      uint64_t v8 = 4294954510;
    }
  }
  else
  {
    uint64_t v8 = 4294954516;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

void FigDispatchOnceInitWithinObject(void *a1)
{
  *a1 = 0;
  FigMemoryBarrier();
}

void FigDeferCFRelease(void *context)
{
  if (context)
  {
    if (FigDeferCFRelease_deferredReleaseQueueOnce != -1) {
      dispatch_once_f(&FigDeferCFRelease_deferredReleaseQueueOnce, &FigDeferCFRelease_deferredReleaseQueue, (dispatch_function_t)figDispatch_initDeferredReleaseQueue);
    }
    uint64_t v2 = FigDeferCFRelease_deferredReleaseQueue;
    dispatch_async_f(v2, context, (dispatch_function_t)figDispatch_releaseResourceOnQueue);
  }
}

uint64_t figDispatch_initDeferredReleaseQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.coremedia.dispatchUtil.serialReleaseQueue", 0);
  *a1 = v2;

  return FigWatchdogMonitorDispatchQueue((uint64_t)v2);
}

uint64_t FigDispatchSyncCopyPropertyImplementation(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v8 = 0;
  if (a1 && a2 && a3 && a4 && a6)
  {
    context[0] = &v8;
    context[1] = a3;
    void context[2] = a4;
    _OWORD context[3] = a2;
    context[4] = a6;
    void context[5] = a5;
    dispatch_sync_f(a1, context, (dispatch_function_t)figPropertyCopyCallback);
    return v8;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figPropertyCopyCallback(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void, void, void, void))(a1 + 24))(*(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 40), *(void *)(a1 + 32));
  **(_DWORD **)a1 = result;
  return result;
}

uint64_t FigDispatchAsyncSetPropertyImplementation(NSObject *a1, uint64_t a2, const void *a3, const void *a4, const void *a5)
{
  if (a4 && a1 && a2 && a3)
  {
    uint64_t v10 = malloc_type_malloc(0x30uLL, 0xF20408A8E6B83uLL);
    if (v10)
    {
      long long v11 = v10;
      v10[1] = CFRetain(a3);
      socklen_t v11[2] = CFRetain(a4);
      if (a5) {
        CFTypeRef v12 = CFRetain(a5);
      }
      else {
        CFTypeRef v12 = 0;
      }
      v11[3] = a2;
      v11[4] = v12;
      dispatch_async_f(a1, v11, (dispatch_function_t)figPropertySetCallback);
      return 0;
    }
    uint64_t v14 = 4294954510;
  }
  else
  {
    uint64_t v14 = 4294954516;
  }

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

void figPropertySetCallback(uint64_t a1)
{
  (*(void (**)(void, void, void))(a1 + 24))(*(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 32));
  dispatch_queue_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4) {
    CFRelease(v4);
  }

  free((void *)a1);
}

dispatch_block_t FigDispatchCreateDispatchSourceBlock(dispatch_block_t block)
{
  return dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, block);
}

intptr_t FigDispatchAsyncAndWaitWithTimeout_f(NSObject *a1, uint64_t a2, uint64_t a3, dispatch_time_t a4)
{
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  int v9[2] = __FigDispatchAsyncAndWaitWithTimeout_f_block_invoke;
  v9[3] = &__block_descriptor_tmp_66;
  v9[4] = a3;
  v9[5] = a2;
  dispatch_block_t v6 = dispatch_block_create(DISPATCH_BLOCK_NO_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, v9);
  dispatch_async(a1, v6);
  intptr_t v7 = dispatch_block_wait(v6, a4);
  _Block_release(v6);
  return v7;
}

uint64_t FigDispatchQueueHolderGetTypeID()
{
  if (FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce != -1) {
    dispatch_once_f(&FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce, 0, (dispatch_function_t)registerFigDispatchQueueHolderType);
  }
  return sFigDispatchQueueHolderID;
}

uint64_t registerFigDispatchQueueHolderType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigDispatchQueueHolderIOSurfaceID ID = result;
  return result;
}

uint64_t FigDispatchQueueHolderGetDispatchQueue(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t FigDispatchQueueHolderCreateWithDispatchQueue(uint64_t a1, NSObject *a2, uint64_t *a3)
{
  if (a2)
  {
    if (a3)
    {
      if (FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce != -1) {
        dispatch_once_f(&FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce, 0, (dispatch_function_t)registerFigDispatchQueueHolderType);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v6 = Instance;
        *(void *)(Instance + 16) = a2;
        dispatch_retain(a2);
        *a3 = v6;
        return 0;
      }
      uint64_t v8 = 4294954510;
    }
    else
    {
      uint64_t v8 = 4294954516;
    }
  }
  else
  {
    uint64_t v8 = 4294954516;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

unsigned char *figDispatch_shouldUseWorkloopQueuesForAssetPrioritiesOnce(unsigned char *result)
{
  *uint64_t result = 0;
  return result;
}

pthread_mutex_t *__figDispatch_copyRootQueueWithPriorityAndClientPID_block_invoke()
{
  sFigDispatchQueuesForPID_0 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  sFigDispatchQueuesForPID_1 = (uint64_t)result;
  return result;
}

uint64_t figDispatch_createRootQueueWithMachPriority(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(&v9, 0, sizeof(v9));
  sched_param v8 = 0;
  if (pthread_attr_init(&v9)) {
    return 0;
  }
  if (a3)
  {
    uint64_t global_queue = (uint64_t)dispatch_get_global_queue(a3, 0);
  }
  else
  {
    pthread_attr_setschedpolicy(&v9, 4);
    if (pthread_attr_getschedparam(&v9, &v8) || (v8.sched_prioritdouble y = a2, pthread_attr_setschedparam(&v9, &v8)))
    {
      uint64_t v6 = 0;
      goto LABEL_8;
    }
    uint64_t global_queue = dispatch_pthread_root_queue_create();
  }
  uint64_t v6 = global_queue;
LABEL_8:
  pthread_attr_destroy(&v9);
  return v6;
}

uint64_t __figDispatch_copyRootQueueWithPriorityAndClientPID_block_invoke_2(uint64_t a1)
{
  dispatch_queue_t v2 = pthread_self();
  thread_act_t v3 = pthread_mach_thread_np(v2);
  figSetMachThreadPriority(v3, *(_DWORD *)(a1 + 32));
  uint64_t v4 = pthread_self();
  __uint64_t v6 = 0;
  uint64_t result = pthread_threadid_np(v4, &v6);
  if (!result) {
    return proc_pidbind();
  }
  return result;
}

void figDispatch_rootQueueDestructor(const void *a1)
{
  FigSimpleMutexLock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);
  CFStringRef Value = (id *)CFDictionaryGetValue((CFDictionaryRef)sFigDispatchQueuesForPID_0, a1);
  if (Value)
  {
    thread_act_t v3 = Value;
    id v4 = FigCFWeakReferenceLoadAndRetain(Value);
    if (v4)
    {
      CFRelease(v4);
    }
    else
    {
      FigCFWeakReferenceStore(v3, 0);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigDispatchQueuesForPID_0, a1);
      free(v3);
    }
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);

  CFRelease(a1);
}

void __figDispatch_getRootQueueWithPriority_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)(a1 + 32);
  unsigned int v2 = v3;
  if ((v3 - 45) >= 4)
  {
    QualityOfServiceClassForFigThreadPrioritdouble y = FigGetQualityOfServiceClassForFigThreadPriority(v3);
    MachThreadPriorityCFStringRef Value = FigThreadGetMachThreadPriorityValue(v2);
    uint64_t v8 = MachThreadPriorityValue;
    pthread_attr_t v9 = &sRootQueuesIndexedByMachPriority[2 * MachThreadPriorityValue];
    *(void *)__str = MEMORY[0x1E4F143A8];
    uint64_t v11 = 0x40000000;
    CFTypeRef v12 = __figDispatch_getSharedPerMachPriorityRootQueueWithPriority_block_invoke;
    long long v13 = &__block_descriptor_tmp_13_7;
    int v14 = MachThreadPriorityValue;
    int v15 = QualityOfServiceClassForFigThreadPriority;
    if (*v9 != -1) {
      dispatch_once(v9, __str);
    }
    sRootQueuesIndexedByFigThreadPriority[2 * *(unsigned int *)(a1 + 32) + 1] = sRootQueuesIndexedByMachPriority[2 * v8 + 1];
  }
  else
  {
    unsigned int v4 = FigGetQualityOfServiceClassForFigThreadPriority(v3);
    int v5 = FigThreadGetMachThreadPriorityValue(v2);
    snprintf(__str, 0x40uLL, "com.apple.coremedia.rootQueue.fP-%02d.mP-%02d", *(_DWORD *)(a1 + 32), v5);
    sRootQueuesIndexedByFigThreadPriority[2 * *(unsigned int *)(a1 + 32) + 1] = figDispatch_createRootQueueWithMachPriority((uint64_t)__str, v5, v4);
  }
}

uint64_t __figDispatch_getRootQueueWithPriority_block_invoke_2(uint64_t a1)
{
  unsigned int v2 = pthread_self();
  thread_act_t v3 = pthread_mach_thread_np(v2);
  int v4 = *(_DWORD *)(a1 + 32);

  return figSetMachThreadPriority(v3, v4);
}

uint64_t __figDispatch_getSharedPerMachPriorityRootQueueWithPriority_block_invoke(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x40uLL, "com.apple.coremedia.sharedRootQueue.%02d", *(_DWORD *)(a1 + 32));
  uint64_t result = figDispatch_createRootQueueWithMachPriority((uint64_t)__str, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36));
  sRootQueuesIndexedByMachPriority[2 * *(int *)(a1 + 32) + 1] = result;
  return result;
}

uint64_t __figDispatch_getSharedPerMachPriorityRootQueueWithPriority_block_invoke_2(uint64_t a1)
{
  unsigned int v2 = pthread_self();
  thread_act_t v3 = pthread_mach_thread_np(v2);
  int v4 = *(_DWORD *)(a1 + 32);

  return figSetMachThreadPriority(v3, v4);
}

uint64_t FigDispatchQueueHolder_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void FigDispatchQueueHolder_Finalize(uint64_t a1)
{
  unsigned int v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + 16) = 0;
  }
}

__CFString *FigDispatchQueueHolder_CopyDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  int v4 = a1[2];
  label = dispatch_queue_get_label(v4);
  CFStringAppendFormat(Mutable, 0, @"<FigDispatchQueueHolder %p> %p (%s)", a1, v4, label);
  return Mutable;
}

uint64_t FigProcessStateMonitorRemoteResetPurgeEvents()
{
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  gLastPurgeEvent = 0;
  if ([(id)gRemotesSupportingPurge count])
  {
    unint64_t v0 = 0;
    do
    {
      uint64_t v1 = (unsigned char *)[(id)gRemotesSupportingPurge pointerAtIndex:v0];
      if (v1)
      {
        CFAllocatorRef v2 = v1;
        CFRetain(v1);
        if (v2[24] == 1 || *((void *)v2 + 10)) {
          [(id)gRemotesSupportingPurge replacePointerAtIndex:v0 withPointer:0];
        }
        CFRelease(v2);
      }
      ++v0;
    }
    while (v0 < [(id)gRemotesSupportingPurge count]);
  }
  [(id)gRemotesSupportingPurge compact];
  thread_act_t v3 = (pthread_mutex_t *)gStateMonitorMutex;

  return FigReentrantMutexUnlock(v3);
}

uint64_t FigProcessStateMonitorGetServerPurgeState(uint64_t *a1)
{
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  uint64_t v2 = gLastPurgeEvent;
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  if (a1)
  {
    if (gEnrollEligibleRemotesInPurge != 1) {
      return 0;
    }
    uint64_t v3 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
    if (v3) {
      return v3;
    }
    FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
    if ([(id)gRemotesSupportingPurge count])
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      while (1)
      {
        intptr_t v7 = (unsigned __int8 *)[(id)gRemotesSupportingPurge pointerAtIndex:v4];
        if (v7) {
          break;
        }
LABEL_21:
        if (++v4 >= (unint64_t)[(id)gRemotesSupportingPurge count]) {
          goto LABEL_30;
        }
      }
      uint64_t v8 = v7;
      CFRetain(v7);
      int v9 = v8[24];
      if (v9 == 1)
      {
        [(id)gRemotesSupportingPurge replacePointerAtIndex:v4 withPointer:0];
LABEL_20:
        CFRelease(v8);
        goto LABEL_21;
      }
      long long v17 = 0;
      dataPointerOut = 0;
      xpc_object_t v16 = 0;
      if (v9)
      {
        uint64_t v14 = 4294947859;
      }
      else
      {
        unsigned int DataPointer = CMBlockBufferGetDataPointer(*((CMBlockBufferRef *)v8 + 8), 0, 0, 0, &dataPointerOut);
        if (DataPointer)
        {
LABEL_26:
          unsigned int v12 = DataPointer;
          long long v13 = 0;
          goto LABEL_27;
        }
        if ((dataPointerOut & 0xF) == 0)
        {
          uint64_t v11 = *(void *)dataPointerOut;
          if (*(uint64_t *)dataPointerOut > 0)
          {
            long long v13 = 0;
            unsigned int v12 = 0;
LABEL_15:
            FigXPCRelease(v13);
            FigXPCRelease(v16);
            if (v12) {
              uint64_t v6 = v12;
            }
            else {
              uint64_t v6 = v6;
            }
            if (v11 > v5) {
              uint64_t v5 = v11;
            }
            goto LABEL_20;
          }
          unsigned int v12 = FigXPCCreateBasicMessage(0x646F7063u, *((void *)v8 + 5), &v17);
          long long v13 = v17;
          if (!v12)
          {
            FigXPCRemoteClientSendSyncMessageCreatingReply(*((void *)v8 + 2), (uint64_t)v17, &v16);
            long long v13 = v17;
            uint64_t v11 = *(void *)dataPointerOut;
            goto LABEL_15;
          }
LABEL_27:
          uint64_t v11 = 0;
          goto LABEL_15;
        }
        uint64_t v14 = 4294947862;
      }
      unsigned int DataPointer = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
      goto LABEL_26;
    }
    uint64_t v6 = 0;
    uint64_t v5 = 0;
LABEL_30:
    if (v2 <= v5)
    {
      figProcessStateMonitor_updateLastPurgeEventIfNecessary(v5);
      uint64_t v2 = v5;
    }
    [(id)gRemotesSupportingPurge compact];
    *a1 = v2;
    FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
    return v6;
  }
  else
  {
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t remoteFigProcessStateMonitor_EnsureInternalStateSetup()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __remoteFigProcessStateMonitor_EnsureInternalStateSetup_block_invoke;
  block[3] = &unk_1E5677820;
  void block[4] = &v3;
  if (remoteFigProcessStateMonitor_EnsureInternalStateSetup_gFigProcessStateMonitorRemoteSetupOnce != -1) {
    dispatch_once(&remoteFigProcessStateMonitor_EnsureInternalStateSetup_gFigProcessStateMonitorRemoteSetupOnce, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t figProcessStateMonitor_updateLastPurgeEventIfNecessary(uint64_t a1)
{
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (gLastPurgeEvent < a1) {
    gLastPurgeEvent = a1;
  }
  uint64_t v2 = (pthread_mutex_t *)gStateMonitorMutex;

  return FigReentrantMutexUnlock(v2);
}

uint64_t FigProcessStateMonitorMayPurgeClientObjects(const void *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if (v2) {
    return v2;
  }
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if ([(id)gRemotesSupportingPurge count])
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = (unsigned __int8 *)[(id)gRemotesSupportingPurge pointerAtIndex:v3];
      if (v5) {
        break;
      }
LABEL_32:
      if (++v3 >= (unint64_t)objc_msgSend((id)gRemotesSupportingPurge, "count", v24, v25)) {
        goto LABEL_41;
      }
    }
    int v6 = v5;
    CFRetain(v5);
    int v7 = v6[24];
    if (v7 == 1)
    {
      [(id)gRemotesSupportingPurge replacePointerAtIndex:v3 withPointer:0];
      goto LABEL_30;
    }
    *(void *)uint64_t v28 = 0;
    if (a1)
    {
      if (v7)
      {
        uint64_t v22 = 4294947859;
      }
      else
      {
        if (dword_1EB28B670 >= 2)
        {
          int v27 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v27, &type);
          int v9 = v27;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v11 = v9;
          }
          else {
            unsigned int v11 = v9 & 0xFFFFFFFE;
          }
          if (v11)
          {
            int v29 = 136315650;
            CFTypeRef v30 = "figProcessStateMonitorRemote_mayPurge";
            __int16 v31 = 2114;
            uint64_t v32 = v6;
            __int16 v33 = 2114;
            uint64_t v34 = a1;
            LODWORD(v25) = 32;
            long long v24 = &v29;
            unsigned int v12 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v9) = v27;
          }
          else
          {
            unsigned int v12 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v12, v12 != v35, v9, 0, v10);
        }
        if (FigCFArrayContainsValue(*((const __CFArray **)v6 + 9), a1))
        {
          CFArrayRef v13 = (const __CFArray *)*((void *)v6 + 9);
          FirstIndexOfCFStringRef Value = FigCFArrayGetFirstIndexOfValue(v13, a1);
          CFArrayRemoveValueAtIndex(v13, FirstIndexOfValue);
          uint64_t v15 = FigXPCCreateBasicMessage(0x6D70636Fu, *((void *)v6 + 5), v28);
          if (v15
            || (uint64_t v15 = FigXPCMessageSetCFString(*(void **)v28, "ProcessStateMonitorAssertion", a1), v15)
            || (uint64_t v15 = FigXPCRemoteClientSendAsyncMessage(*((void *)v6 + 2), *(void **)v28), v15))
          {
            uint64_t v21 = v15;
            FigXPCRelease(*(xpc_object_t *)v28);
            goto LABEL_31;
          }
          v6[89] = CFArrayGetCount(*((CFArrayRef *)v6 + 9)) == 0;
          if (dword_1EB28B670)
          {
            int v27 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            xpc_object_t v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v27, &type);
            int v17 = v27;
            if (os_log_type_enabled(v16, type)) {
              unsigned int v19 = v17;
            }
            else {
              unsigned int v19 = v17 & 0xFFFFFFFE;
            }
            if (v19)
            {
              int v29 = 136315650;
              CFTypeRef v30 = "figProcessStateMonitorRemote_mayPurge";
              __int16 v31 = 2114;
              uint64_t v32 = a1;
              __int16 v33 = 2114;
              uint64_t v34 = v6;
              LODWORD(v25) = 32;
              long long v24 = &v29;
              long long v20 = (unsigned char *)_os_log_send_and_compose_impl();
              LOBYTE(v17) = v27;
            }
            else
            {
              long long v20 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v20, v20 != v35, v17, 0, v18);
          }
          FigXPCRelease(*(xpc_object_t *)v28);
LABEL_30:
          uint64_t v21 = v4;
LABEL_31:
          CFRelease(v6);
          uint64_t v4 = v21;
          goto LABEL_32;
        }
        uint64_t v22 = 4294947863;
      }
    }
    else
    {
      uint64_t v22 = 4294947866;
    }
    uint64_t v21 = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
    FigXPCRelease(*(xpc_object_t *)v28);
    if (v21) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v4 = 0;
LABEL_41:
  [(id)gRemotesSupportingPurge compact];
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return v4;
}

uint64_t FigProcessStateMonitorMustNotPurgeClientObjects(const void *a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if (v2) {
    return v2;
  }
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if ([(id)gRemotesSupportingPurge count])
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = (unsigned __int8 *)[(id)gRemotesSupportingPurge pointerAtIndex:v3];
      if (v5) {
        break;
      }
LABEL_31:
      if (++v3 >= (unint64_t)objc_msgSend((id)gRemotesSupportingPurge, "count", v22, v23)) {
        goto LABEL_39;
      }
    }
    int v6 = v5;
    CFRetain(v5);
    int v7 = v6[24];
    if (v7 == 1)
    {
      [(id)gRemotesSupportingPurge replacePointerAtIndex:v3 withPointer:0];
      goto LABEL_29;
    }
    *(void *)uint64_t v26 = 0;
    if (a1)
    {
      if (!v7)
      {
        if (dword_1EB28B670 >= 2)
        {
          int v25 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v25, &type);
          int v9 = v25;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v11 = v9;
          }
          else {
            unsigned int v11 = v9 & 0xFFFFFFFE;
          }
          if (v11)
          {
            int v27 = 136315650;
            uint64_t v28 = "figProcessStateMonitorRemote_mustNotPurge";
            __int16 v29 = 2114;
            CFTypeRef v30 = v6;
            __int16 v31 = 2114;
            uint64_t v32 = a1;
            LODWORD(v23) = 32;
            uint64_t v22 = &v27;
            unsigned int v12 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v9) = v25;
          }
          else
          {
            unsigned int v12 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v12, v12 != v33, v9, 0, v10);
        }
        uint64_t v13 = FigXPCCreateBasicMessage(0x6D6E706Fu, *((void *)v6 + 5), v26);
        if (v13
          || (uint64_t v13 = FigXPCMessageSetCFString(*(void **)v26, "ProcessStateMonitorAssertion", a1), v13)
          || (uint64_t v13 = FigXPCRemoteClientSendSyncMessage(*((void *)v6 + 2), *(uint64_t *)v26), v13))
        {
          uint64_t v19 = v13;
          FigXPCRelease(*(xpc_object_t *)v26);
          goto LABEL_30;
        }
        CFArrayAppendValue(*((CFMutableArrayRef *)v6 + 9), a1);
        v6[89] = 0;
        if (dword_1EB28B670)
        {
          int v25 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          uint64_t v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v25, &type);
          int v15 = v25;
          if (os_log_type_enabled(v14, type)) {
            unsigned int v17 = v15;
          }
          else {
            unsigned int v17 = v15 & 0xFFFFFFFE;
          }
          if (v17)
          {
            int v27 = 136315650;
            uint64_t v28 = "figProcessStateMonitorRemote_mustNotPurge";
            __int16 v29 = 2114;
            CFTypeRef v30 = a1;
            __int16 v31 = 2114;
            uint64_t v32 = v6;
            LODWORD(v23) = 32;
            uint64_t v22 = &v27;
            uint64_t v18 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v15) = v25;
          }
          else
          {
            uint64_t v18 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v18, v18 != v33, v15, 0, v16);
        }
        FigXPCRelease(*(xpc_object_t *)v26);
LABEL_29:
        uint64_t v19 = v4;
LABEL_30:
        CFRelease(v6);
        uint64_t v4 = v19;
        goto LABEL_31;
      }
      uint64_t v20 = 4294947859;
    }
    else
    {
      uint64_t v20 = 4294947866;
    }
    uint64_t v19 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    FigXPCRelease(*(xpc_object_t *)v26);
    if (v19) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  uint64_t v4 = 0;
LABEL_39:
  [(id)gRemotesSupportingPurge compact];
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return v4;
}

uint64_t FigProcessStateMonitorEnrollEligibleConnectionsInPurge()
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if (v0) {
    return v0;
  }
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  gEnrollEligibleRemotesInPurge = 1;
  uint64_t v1 = 0;
  if ([(id)gRemotesSupportingPurge count])
  {
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = (const void *)[(id)gRemotesSupportingPurge pointerAtIndex:v2];
      if (v3) {
        break;
      }
LABEL_31:
      if (++v2 >= (unint64_t)objc_msgSend((id)gRemotesSupportingPurge, "count", v21, v22)) {
        goto LABEL_36;
      }
    }
    uint64_t v4 = (uint64_t)v3;
    CFRetain(v3);
    if (*(unsigned char *)(v4 + 24) == 1)
    {
      [(id)gRemotesSupportingPurge replacePointerAtIndex:v2 withPointer:0];
LABEL_30:
      CFRelease((CFTypeRef)v4);
      goto LABEL_31;
    }
    if (*(unsigned char *)(v4 + 88)) {
      goto LABEL_30;
    }
    int v25 = 0;
    uint64_t v5 = FigCopyCommonMemoryPool();
    int v7 = v5;
    if (!*(unsigned char *)(v4 + 88))
    {
      if (*(unsigned char *)(v4 + 24))
      {
        unsigned int BlockBuffer = FigSignalErrorAt(4294947859, 0, 0, 0, 0, 0, 0);
      }
      else if ((*(void *)(v4 + 64) {
              || (unsigned int BlockBuffer = FigMemoryPoolCreateBlockBuffer((uint64_t)v5, 8uLL, (CMBlockBufferRef *)(v4 + 64), v6)) == 0)&& (*(void *)(v4 + 56)|| (unsigned int BlockBuffer = FigXPCRemoteClientCopyMemoryOrigin(*(void *)(v4 + 16), (CFTypeRef *)(v4 + 56))) == 0))
      }
      {
        unsigned int BlockBuffer = FigXPCCreateBasicMessage(0x65697075u, *(void *)(v4 + 40), &v25);
        if (!BlockBuffer)
        {
          unsigned int BlockBuffer = FigMemoryOriginSetBlockBufferInXPCMessage(*(void *)(v4 + 56), v25, "ProcessStateMonitorShmem", *(OpaqueCMBlockBuffer **)(v4 + 64));
          if (!BlockBuffer)
          {
            unsigned int BlockBuffer = FigXPCRemoteClientSendSyncMessage(*(void *)(v4 + 16), (uint64_t)v25);
            if (!BlockBuffer)
            {
              *(_WORD *)(v4 + 88) = 257;
              if (dword_1EB28B670)
              {
                *(_DWORD *)long long v24 = 0;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, (int *)v24, &type);
                unsigned int v10 = *(_DWORD *)v24;
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
                  unsigned int v12 = v10;
                }
                else {
                  unsigned int v12 = v10 & 0xFFFFFFFE;
                }
                if (v12)
                {
                  int v26 = 136315394;
                  int v27 = "figProcessStateMonitorRemote_enrollInPurge";
                  __int16 v28 = 2114;
                  uint64_t v29 = v4;
                  LODWORD(v22) = 22;
                  uint64_t v21 = &v26;
                  uint64_t v13 = (unsigned char *)_os_log_send_and_compose_impl();
                  LOBYTE(v10) = v24[0];
                }
                else
                {
                  uint64_t v13 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v13, v13 != v30, v10, 0, v11);
              }
              goto LABEL_25;
            }
          }
        }
      }
      unsigned int v14 = BlockBuffer;
      if (!v7)
      {
LABEL_27:
        FigXPCRelease(v25);
        if (v14) {
          uint64_t v1 = v14;
        }
        else {
          uint64_t v1 = v1;
        }
        goto LABEL_30;
      }
LABEL_26:
      CFRelease(v7);
      goto LABEL_27;
    }
LABEL_25:
    unsigned int v14 = 0;
    if (!v7) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
LABEL_36:
  [(id)gRemotesSupportingPurge compact];
  if (dword_1EB28B670)
  {
    LODWORD(v25) = 0;
    v24[0] = OS_LOG_TYPE_DEFAULT;
    int v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, (int *)&v25, v24);
    unsigned int v16 = v25;
    if (os_log_type_enabled(v15, v24[0])) {
      unsigned int v18 = v16;
    }
    else {
      unsigned int v18 = v16 & 0xFFFFFFFE;
    }
    if (v18)
    {
      int v26 = 136315394;
      int v27 = "FigProcessStateMonitorEnrollEligibleConnectionsInPurge";
      __int16 v28 = 2112;
      uint64_t v29 = gRemotesSupportingPurge;
      uint64_t v19 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v16) = (_BYTE)v25;
    }
    else
    {
      uint64_t v19 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v19, v19 != v30, v16, 0, v17);
  }
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return v1;
}

uint64_t FigProcessStateMonitorCopyRemoteStateMonitor(void *a1, int a2, int a3, uint64_t *a4)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = 0x1EB28B000uLL;
  if (in_audio_mx_server_process())
  {
    uint64_t v44 = 0;
    goto LABEL_88;
  }
  if (!a2 || !a4)
  {
    uint64_t v15 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
LABEL_98:
    uint64_t v44 = v15;
    goto LABEL_88;
  }
  if (dword_1EB28B670 >= 2)
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, (int *)&cf, type);
    unsigned int v10 = cf;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
      unsigned int v12 = v10;
    }
    else {
      unsigned int v12 = v10 & 0xFFFFFFFE;
    }
    if (v12)
    {
      uint64_t v13 = "is";
      __int16 v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
      int v64 = 136315650;
      if (!a3) {
        uint64_t v13 = "is not";
      }
      __int16 v66 = 1024;
      *(_DWORD *)__int16 v67 = a2;
      *(_WORD *)&v67[4] = 2080;
      *(void *)&v67[6] = v13;
      unsigned int v14 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v10) = (_BYTE)cf;
    }
    else
    {
      unsigned int v14 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v14, v14 != v68, v10, 0, v11);
  }
  uint64_t v15 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if (v15) {
    goto LABEL_98;
  }
  uint64_t v15 = FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (v15) {
    goto LABEL_98;
  }
  uint64_t v16 = a2;
  uint64_t v17 = (unsigned __int8 *)FigCFWeakReferenceTableCopyValue(gStateMonitorPerPID, (void *)a2);
  if (v17)
  {
    uint64_t int64 = v17;
    if (v17[89] != a3)
    {
      v17[89] = 1;
      [(id)gRemotesSupportingPurge addPointer:v17];
    }
    if (dword_1EB28B670 >= 2)
    {
      LODWORD(cf) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      uint64_t v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, (int *)&cf, type);
      unsigned int v20 = cf;
      if (os_log_type_enabled(v19, type[0])) {
        unsigned int v22 = v20;
      }
      else {
        unsigned int v22 = v20 & 0xFFFFFFFE;
      }
      if (v22)
      {
        int v64 = 136315650;
        __int16 v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
        __int16 v66 = 2114;
        *(void *)__int16 v67 = uint64;
        *(_WORD *)&v67[8] = 1024;
        *(_DWORD *)&v67[10] = a2;
        uint64_t v23 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v20) = (_BYTE)cf;
      }
      else
      {
        uint64_t v23 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v23, v23 != v68, v20, 0, v21);
    }
LABEL_82:
    if (!remoteFigProcessStateMonitor_EnsureInternalStateSetup()
      && gEnrollEligibleRemotesInPurge
      && !FigServer_IsServerProcess())
    {
      FigProcessStateMonitorEnrollEligibleConnectionsInPurge();
    }
    uint64_t v44 = 0;
    *a4 = (uint64_t)uint64;
    goto LABEL_87;
  }
  if (!a1)
  {
    uint64_t v44 = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
LABEL_87:
    FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
    goto LABEL_88;
  }
  if (dword_1EB28B670 <= 1)
  {
    *(void *)os_log_type_t type = 0;
    CFTypeRef cf = 0;
    xpc_object_t xdict = 0;
  }
  else
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    long long v24 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, (int *)&cf, type);
    unsigned int v25 = cf;
    if (os_log_type_enabled(v24, type[0])) {
      unsigned int v27 = v25;
    }
    else {
      unsigned int v27 = v25 & 0xFFFFFFFE;
    }
    if (v27)
    {
      int v64 = 136315650;
      __int16 v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
      __int16 v66 = 2048;
      *(void *)__int16 v67 = a1;
      *(_WORD *)&v67[8] = 1024;
      *(_DWORD *)&v67[10] = a2;
      __int16 v28 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v25) = (_BYTE)cf;
    }
    else
    {
      __int16 v28 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v28, v28 != v68, v25, 0, v26);
    *(void *)os_log_type_t type = 0;
    CFTypeRef cf = 0;
    xpc_object_t xdict = 0;
    if (dword_1EB28B670 >= 2)
    {
      int v63 = 0;
      os_log_type_t v62 = OS_LOG_TYPE_DEFAULT;
      uint64_t v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v63, &v62);
      int v30 = v63;
      if (os_log_type_enabled(v29, v62)) {
        unsigned int v32 = v30;
      }
      else {
        unsigned int v32 = v30 & 0xFFFFFFFE;
      }
      if (v32)
      {
        int v64 = 136315650;
        __int16 v65 = "figProcessStateMonitorRemote_establishInitialConnection";
        __int16 v66 = 2048;
        *(void *)__int16 v67 = a1;
        *(_WORD *)&v67[8] = 1024;
        *(_DWORD *)&v67[10] = a2;
        __int16 v33 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v30) = v63;
      }
      else
      {
        __int16 v33 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v33, v33 != v68, v30, 0, v31);
    }
  }
  CFAllocatorRef v34 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetValue(Mutable, @"xpcRemoteClientOption_DoNotMonitorConnection", (const void *)*MEMORY[0x1E4F1CFD0]);
  uint64_t v36 = FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"monitorRemote", (uint64_t)a1, (uint64_t)&figProcessStateMonitorRemote_establishInitialConnection_sFigProcessStateMonitorRemoteClientCallbacks, (uint64_t)Mutable, (uint64_t)&cf);
  if (v36
    || (uint64_t v36 = FigXPCCreateBasicMessage(0x63726574u, 0, type), v36)
    || (uint64_t v36 = FigXPCRemoteClientSendSyncMessageCreatingReply((uint64_t)cf, *(uint64_t *)type, &xdict), v36))
  {
    uint64_t v44 = v36;
LABEL_103:
    uint64_t int64 = 0;
    goto LABEL_71;
  }
  uint64_t int64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
  if (!uint64)
  {
    uint64_t v44 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
    goto LABEL_71;
  }
  CFTypeRef v37 = cf;
  if (figProcessStateMonitorRemote_GetTypeID_sRegisterFigProcessStateMonitorRemoteTypeOnce != -1) {
    dispatch_once(&figProcessStateMonitorRemote_GetTypeID_sRegisterFigProcessStateMonitorRemoteTypeOnce, &__block_literal_global_53);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (v37) {
    CFTypeRef v39 = CFRetain(v37);
  }
  else {
    CFTypeRef v39 = 0;
  }
  *(void *)(Instance + 16) = v39;
  xpc_object_t v40 = FigXPCRetain(a1);
  *(unsigned char *)(Instance + 24) = 0;
  *(void *)(Instance + 32) = v40;
  *(void *)(Instance + 40) = uint64;
  *(void *)(Instance + 80) = 0;
  *(unsigned char *)(Instance + 88) = 0;
  CFMutableSetRef v41 = CFSetCreateMutable(v34, 0, 0);
  *(void *)(Instance + 96) = v41;
  if (!v41)
  {
    uint64_t v44 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
    CFRelease((CFTypeRef)Instance);
    uint64_t int64 = 0;
    if (v44)
    {
      uint64_t Instance = 0;
      unint64_t v8 = 0x1EB28B000;
      goto LABEL_72;
    }
    uint64_t Instance = 0;
    goto LABEL_68;
  }
  *(unsigned char *)(Instance + 104) = 0;
  ServerPIOSurfaceID ID = FigXPCRemoteClientGetServerPID((uint64_t)v37, (_DWORD *)(Instance + 48));
  if (ServerPID
    || (ServerPIOSurfaceID ID = FigXPCRemoteClientAssociateObject((uint64_t)v37, Instance, uint64), ServerPID))
  {
    uint64_t v44 = ServerPID;
    unint64_t v8 = 0x1EB28B000;
LABEL_102:
    CFRelease((CFTypeRef)Instance);
    goto LABEL_103;
  }
  if (FigServer_IsServerProcess()) {
    uint64_t started = FigStartMonitoringMediaServicesProcessDeathWithCallback((void *)Instance, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))figProcessStateMonitorRemote_propagateMediaServicesDeathNotificationCallback);
  }
  else {
    uint64_t started = FigStartMonitoringMediaServicesProcessDeath((void *)Instance);
  }
  uint64_t v44 = started;
  unint64_t v8 = 0x1EB28B000uLL;
  if (started) {
    goto LABEL_102;
  }
  if (dword_1EB28B670)
  {
    int v63 = 0;
    os_log_type_t v62 = OS_LOG_TYPE_DEFAULT;
    int v45 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v63, &v62);
    int v46 = v63;
    if (os_log_type_enabled(v45, v62)) {
      unsigned int v48 = v46;
    }
    else {
      unsigned int v48 = v46 & 0xFFFFFFFE;
    }
    if (v48)
    {
      int v64 = 136315394;
      __int16 v65 = "figProcessStateMonitor_createRemoteFromObjectID";
      __int16 v66 = 2114;
      *(void *)__int16 v67 = Instance;
      int v49 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v46) = v63;
    }
    else
    {
      int v49 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v49, v49 != v68, v46, 0, v47);
LABEL_68:
    unint64_t v8 = 0x1EB28B000uLL;
  }
  CFMutableArrayRef v50 = CFArrayCreateMutable(v34, 0, MEMORY[0x1E4F1D510]);
  *(void *)(Instance + 72) = v50;
  if (!v50)
  {
    uint64_t v44 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
    uint64_t int64 = 0;
    goto LABEL_72;
  }
  uint64_t v44 = 0;
  uint64_t int64 = (const void *)Instance;
LABEL_71:
  uint64_t Instance = 0;
LABEL_72:
  FigXPCRelease(*(xpc_object_t *)type);
  FigXPCRelease(xdict);
  if (cf) {
    CFRelease(cf);
  }
  if (Instance) {
    CFRelease((CFTypeRef)Instance);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!v44)
  {
    uint64_t v51 = FigCFWeakReferenceTableAddValueAssociatedWithKey(gStateMonitorPerPID, (uint64_t)uint64, v16);
    if (!v51)
    {
      if (a3) {
        [(id)gRemotesSupportingPurge addPointer:uint64];
      }
      goto LABEL_82;
    }
    uint64_t v44 = v51;
  }
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  if (uint64) {
    CFRelease(uint64);
  }
LABEL_88:
  if (*(_DWORD *)(v8 + 1648))
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    int v52 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, (int *)&cf, type);
    unsigned int v53 = cf;
    if (os_log_type_enabled(v52, type[0])) {
      unsigned int v55 = v53;
    }
    else {
      unsigned int v55 = v53 & 0xFFFFFFFE;
    }
    if (v55)
    {
      uint64_t v56 = *a4;
      int v64 = 136315650;
      __int16 v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
      __int16 v66 = 2114;
      *(void *)__int16 v67 = v56;
      *(_WORD *)&v67[8] = 1024;
      *(_DWORD *)&v67[10] = v44;
      __int16 v57 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v53) = (_BYTE)cf;
    }
    else
    {
      __int16 v57 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v57, v57 != v68, v53, 0, v54);
  }
  return v44;
}

uint64_t FigProcessStateMonitorRemoteAssociateObject(uint64_t a1, const void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
    if (*(const void **)(a1 + 40) != a2)
    {
      *(unsigned char *)(a1 + 104) = 1;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 96), a2);
      if (dword_1EB28B670 >= 2)
      {
        v11[0] = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, v11, &type);
        int v5 = v11[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v7 = v5;
        }
        else {
          unsigned int v7 = v5 & 0xFFFFFFFE;
        }
        if (v7)
        {
          v11[1] = 136315650;
          unsigned int v12 = "FigProcessStateMonitorRemoteAssociateObject";
          __int16 v13 = 2114;
          uint64_t v14 = a1;
          __int16 v15 = 2048;
          uint64_t v16 = a2;
          unint64_t v8 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v5) = v11[0];
        }
        else
        {
          unint64_t v8 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v8, v8 != &v17, v5, 0, v6);
      }
    }
    FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigProcessStateMonitorRemoteDisassociateObject(uint64_t a1, const void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
    if (*(const void **)(a1 + 40) != a2)
    {
      CFSetRef v4 = *(const __CFSet **)(a1 + 96);
      if (!v4)
      {
        CFGetRetainCount((CFTypeRef)a1);
        FigUserCrashWithMessage("monitor->associatedObjects == NULL! Monitor = %p; RC = %zu; serverObjectIOSurfaceID ID = %llu; targetObjectIOSurfaceID ID = %llu",
          v5,
          v6,
          v7,
          v8,
          v9,
          v10,
          v11,
          a1);
      }
      if (CFSetContainsValue(v4, a2))
      {
        CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 96), a2);
        if (dword_1EB28B670 >= 2)
        {
          v19[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, v19, &type);
          int v13 = v19[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v15 = v13;
          }
          else {
            unsigned int v15 = v13 & 0xFFFFFFFE;
          }
          if (v15)
          {
            v19[1] = 136315650;
            unsigned int v20 = "FigProcessStateMonitorRemoteDisassociateObject";
            __int16 v21 = 2114;
            uint64_t v22 = a1;
            __int16 v23 = 2048;
            long long v24 = a2;
            uint64_t v16 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v13) = v19[0];
          }
          else
          {
            uint64_t v16 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v16, v16 != &v25, v13, 0, v14);
        }
      }
    }
    return FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  }
  else
  {
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  }
}

void figProcessStateMonitorRemote_deadConnectionCallback(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 24) = 1;
  if (dword_1EB28B670)
  {
    v8[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, v8, &type);
    int v3 = v8[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = v3 & 0xFFFFFFFE;
    }
    if (v5)
    {
      v8[1] = 136315394;
      uint64_t v9 = "figProcessStateMonitorRemote_deadConnectionCallback";
      __int16 v10 = 2114;
      uint64_t v11 = a1;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v8[0];
    }
    else
    {
      uint64_t v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v6, v6 != &v12, v3, 0, v4);
  }
}

void figProcessStateMonitorRemote_serverPurgeCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  dataPointerOut = 0;
  if (CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 64), 0, 0, 0, &dataPointerOut)) {
    return;
  }
  if ((dataPointerOut & 0xF) != 0)
  {
    FigSignalErrorAt(4294947862, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (dword_1EB28B670)
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, (int *)&cf, type);
    unsigned int v5 = cf;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      uint64_t v8 = *(const void **)dataPointerOut;
      int v22 = 136315906;
      __int16 v23 = "figProcessStateMonitorRemote_serverPurgeCallback";
      __int16 v24 = 2114;
      uint64_t v25 = a1;
      __int16 v26 = 2048;
      unsigned int v27 = v8;
      __int16 v28 = 2048;
      uint64_t v29 = a2;
      uint64_t v9 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = (_BYTE)cf;
    }
    else
    {
      uint64_t v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v9, v9 != v30, v5, 0, v6);
  }
  *(void *)(a1 + 80) = a2;
  *(unsigned char *)(a1 + 88) = 0;
  figProcessStateMonitor_updateLastPurgeEventIfNecessary(a2);
  *(void *)os_log_type_t type = 0;
  CFTypeRef cf = 0;
  if (!FigXPCCreateBasicMessage(0x63726574u, 0, &cf)
    && !FigXPCRemoteClientSendSyncMessageCreatingReply(*(void *)(a1 + 16), (uint64_t)cf, (xpc_object_t *)type))
  {
    uint64_t int64 = (const void *)xpc_dictionary_get_uint64(*(xpc_object_t *)type, ".objectID");
    if (uint64)
    {
      uint64_t v11 = *(const void **)(a1 + 40);
      *(void *)(a1 + 40) = uint64;
      if (!FigXPCRemoteClientAssociateObject(*(void *)(a1 + 16), a1, uint64)
        && !FigXPCRemoteClientDisassociateObject(*(void *)(a1 + 16), v11))
      {
        FigProcessStateMonitorEnrollEligibleConnectionsInPurge();
      }
      goto LABEL_17;
    }
    FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v11 = 0;
LABEL_17:
  if (dword_1EB28B670)
  {
    int v19 = 0;
    os_log_type_t v18 = OS_LOG_TYPE_DEFAULT;
    char v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v19, &v18);
    int v13 = v19;
    if (os_log_type_enabled(v12, v18)) {
      unsigned int v15 = v13;
    }
    else {
      unsigned int v15 = v13 & 0xFFFFFFFE;
    }
    if (v15)
    {
      int v22 = 136315650;
      __int16 v23 = "figProcessStateMonitorRemote_refreshObjectAfterPurge";
      __int16 v24 = 2112;
      uint64_t v25 = a1;
      __int16 v26 = 2048;
      unsigned int v27 = v11;
      uint64_t v16 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v13) = v19;
    }
    else
    {
      uint64_t v16 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v16, v16 != v30, v13, 0, v14);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (*(void *)type) {
    CFRelease(*(CFTypeRef *)type);
  }
}

uint64_t figProcessStateMonitorRemote_propagateMediaServicesDeathNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  FigStopMonitoringMediaServicesProcessDeath((const void *)a2);
  if (!*(unsigned char *)(a2 + 104) || CFSetGetCount(*(CFSetRef *)(a2 + 96)) >= 1)
  {
    if (dword_1EB28B670 >= 2)
    {
      v14[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, v14, &type);
      int v8 = v14[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v10 = v8;
      }
      else {
        unsigned int v10 = v8 & 0xFFFFFFFE;
      }
      if (v10)
      {
        v14[1] = 136315650;
        unsigned int v15 = "figProcessStateMonitorRemote_propagateMediaServicesDeathNotificationCallback";
        __int16 v16 = 2112;
        uint64_t v17 = a2;
        __int16 v18 = 2112;
        uint64_t v19 = a5;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v8) = v14[0];
      }
      else
      {
        uint64_t v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v11, v11 != &v20, v8, 0, v9);
    }
    FigProcessStateMonitorInformRemotesOfIndirectDependencyDeath(a5);
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
}

double figProcessStateMonitorRemote_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figProcessStateMonitorRemote_Finalize(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 0;
  if (dword_1EB28B670)
  {
    int v13 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B668, 1, &v13, &type);
    int v3 = v13;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = v3 & 0xFFFFFFFE;
    }
    if (v5)
    {
      int v15 = 136315394;
      __int16 v16 = "figProcessStateMonitorRemote_Finalize";
      __int16 v17 = 2114;
      uint64_t v18 = a1;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v13;
    }
    else
    {
      uint64_t v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B668, 1u, 1, v6, v6 != &v19, v3, 0, v4);
  }
  FigStopMonitoringMediaServicesProcessDeath((const void *)a1);
  FigXPCRemoteClientDisassociateObject(*(void *)(a1 + 16), *(const void **)(a1 + 40));
  if (!*(unsigned char *)(a1 + 24) && !FigXPCCreateBasicMessage(0x64697370u, *(void *)(a1 + 40), &v14)) {
    FigXPCRemoteClientSendAsyncMessage(*(void *)(a1 + 16), v14);
  }
  unsigned int v7 = *(const void **)(a1 + 16);
  if (v7) {
    CFRelease(v7);
  }
  FigXPCRelease(*(xpc_object_t *)(a1 + 32));
  int v8 = *(const void **)(a1 + 72);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(const void **)(a1 + 56);
  if (v9) {
    CFRelease(v9);
  }
  unsigned int v10 = *(const void **)(a1 + 64);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = *(const void **)(a1 + 96);
  if (v11) {
    CFRelease(v11);
  }
  FigXPCRelease(v14);
}

__CFString *figProcessStateMonitorRemote_CopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  int v3 = Mutable;
  uint64_t v4 = "YES";
  if (*(unsigned char *)(a1 + 24)) {
    unsigned int v5 = "YES";
  }
  else {
    unsigned int v5 = "NO";
  }
  if (!*(unsigned char *)(a1 + 88)) {
    uint64_t v4 = "NO";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigProcessStateMonitorRemoteRef %p %@ %d OID: %016llx, serverDied: %s, enrolledInPurge: %s, lastPurgeID: %lld>", a1, *(void *)(a1 + 16), *(unsigned int *)(a1 + 48), *(void *)(a1 + 40), v5, v4, *(void *)(a1 + 80));
  return v3;
}

uint64_t FigEndpointManagerGetClassID()
{
  if (FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce, &FigEndpointManagerGetClassID_sFigEndpointManagerClassID, (dispatch_function_t)manager_getClassID);
  }
  return FigEndpointManagerGetClassID_sFigEndpointManagerClassID;
}

uint64_t manager_getClassID(void *a1)
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&manager_getClassID_sFigEndpointManagerClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointManagerGetTypeID()
{
  if (FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce, &FigEndpointManagerGetClassID_sFigEndpointManagerClassID, (dispatch_function_t)manager_getClassID);
  }
  uint64_t v0 = (void *)FigEndpointManagerGetClassID_sFigEndpointManagerClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigEndpointManagerGetSupportedFeatures(CFTypeRef cf1, int a2, uint64_t *a3)
{
  uint64_t result = 4294950586;
  if (cf1 && a3)
  {
    if (CFEqual(cf1, @"AirPlay"))
    {
      uint64_t result = 0;
      uint64_t v7 = 63;
      if (!a2) {
        uint64_t v7 = 31;
      }
    }
    else if (CFEqual(cf1, @"CarPlay") || CFEqual(cf1, @"Nero/Stevenote"))
    {
      uint64_t result = 0;
      uint64_t v7 = 3;
    }
    else
    {
      int v8 = CFEqual(cf1, @"SidePlay");
      BOOL v9 = v8 != 0;
      if (v8) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = 4294950583;
      }
      uint64_t v7 = 8 * v9;
    }
    *a3 = v7;
  }
  return result;
}

uint64_t FigEndpointManagerGetSupportedDiscoveryFeatures(CFTypeRef cf1, uint64_t *a2)
{
  uint64_t result = 4294950586;
  if (cf1 && a2)
  {
    int v5 = CFEqual(cf1, @"AirPlay");
    uint64_t result = 0;
    BOOL v6 = v5 == 0;
    uint64_t v7 = 7;
    if (v6) {
      uint64_t v7 = 5;
    }
    *a2 = v7;
  }
  return result;
}

CFStringRef manager_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointManager %p]", a1);
}

uint64_t NeroTransportConnectionGetClassID()
{
  if (NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce != -1) {
    dispatch_once(&NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce, &__block_literal_global_54);
  }
  return NeroTransportConnectionGetClassID_sFigTransportConnectionClassID;
}

CFStringRef FigTransportConnectionBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigTransportConnection %p]", a1);
}

uint64_t __NeroTransportConnectionGetClassID_block_invoke()
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&NeroTransportConnectionGetClassID_sFigTransportConnectionClassDesc, ClassID, 1, &NeroTransportConnectionGetClassID_sFigTransportConnectionClassID);
}

uint64_t NeroTransportConnectionGetTypeID()
{
  if (NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce != -1) {
    dispatch_once(&NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce, &__block_literal_global_54);
  }
  uint64_t v0 = (void *)NeroTransportConnectionGetClassID_sFigTransportConnectionClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionData(CFAllocatorRef alloc, unsigned int *a2, unint64_t a3, int a4, CMFormatDescriptionRef *formatDescriptionOut)
{
  if (!a2)
  {
    uint64_t v27 = 4294954584;
    goto LABEL_45;
  }
  if (a3 <= 0xF || (int v5 = formatDescriptionOut) == 0)
  {
    uint64_t v27 = 4294954584;
LABEL_45:
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  signed int v6 = bswap32(*a2);
  if (v6 < 0x10 || v6 > a3)
  {
    uint64_t v27 = 4294954582;
    goto LABEL_45;
  }
  unsigned int v9 = a2[1];
  unint64_t v10 = v6 - 16;
  CFMutableDictionaryRef theDict = 0;
  if (v10 < 8)
  {
    CFDictionaryRef v21 = 0;
    goto LABEL_34;
  }
  unsigned int v28 = v9;
  CFMutableDictionaryRef Mutable = 0;
  char v12 = a2 + 4;
  int v13 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  do
  {
    unsigned int v16 = *v12;
    unsigned int v15 = v12[1];
    *(_DWORD *)CMTime bytes = v15;
    signed int v17 = bswap32(v16);
    uint64_t v18 = v17;
    if (v17 < 8 || v10 < v17)
    {
      CFStringRef v24 = 0;
      CFDataRef v25 = 0;
      uint64_t v26 = 4294954582;
      goto LABEL_40;
    }
    if (v15 != 1701147238)
    {
      CFStringRef v24 = CFStringCreateWithBytes(alloc, bytes, 4, 0, 0);
      if (!v24)
      {
        CFDataRef v25 = 0;
LABEL_39:
        uint64_t v26 = 4294954583;
LABEL_40:
        int v5 = formatDescriptionOut;
        unsigned int v9 = v28;
        goto LABEL_41;
      }
      CFDataRef v25 = CFDataCreate(alloc, (const UInt8 *)v12 + 8, v18 - 8);
      if (!v25) {
        goto LABEL_39;
      }
      CFMutableDictionaryRef Mutable = theDict;
      if (!theDict)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, v13, v14);
        CFMutableDictionaryRef theDict = Mutable;
        if (!Mutable) {
          goto LABEL_39;
        }
      }
      CFDictionarySetValue(Mutable, v24, v25);
      CFRelease(v25);
      CFRelease(v24);
    }
    char v12 = (unsigned int *)((char *)v12 + v18);
    v10 -= v18;
  }
  while (v10 > 7);
  if (!Mutable)
  {
    CFDictionaryRef v21 = 0;
    uint64_t v22 = 0;
    CFStringRef v24 = 0;
    CFDataRef v25 = 0;
    int v5 = formatDescriptionOut;
    unsigned int v9 = v28;
    goto LABEL_27;
  }
  CFDictionaryRef v20 = CFDictionaryCreate(alloc, (const void **)&kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, (const void **)&theDict, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v24 = 0;
  unsigned int v9 = v28;
  if (v20)
  {
    CFDictionaryRef v21 = v20;
    uint64_t v22 = 0;
    CFDataRef v25 = 0;
    int v5 = formatDescriptionOut;
    goto LABEL_27;
  }
  uint64_t v26 = 4294954583;
  CFDataRef v25 = 0;
  int v5 = formatDescriptionOut;
LABEL_41:
  uint64_t v22 = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
  CFDictionaryRef v21 = 0;
LABEL_27:
  if (theDict) {
    CFRelease(theDict);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (!v22) {
LABEL_34:
  }
    uint64_t v22 = CMFormatDescriptionCreate(alloc, 0x7363656Eu, bswap32(v9), v21, v5);
  if (v21) {
    CFRelease(v21);
  }
  return v22;
}

uint64_t CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, uint64_t a3, CMFormatDescriptionRef *a4)
{
  *(void *)char v12 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  if (theBuffer && a4)
  {
    int v5 = theBuffer;
    size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (!CMBlockBufferIsRangeContiguous(v5, 0, 0))
    {
      uint64_t DataPointer = CMBlockBufferCreateContiguous(a1, v5, a1, 0, 0, 0, 0, &blockBufferOut);
      if (DataPointer) {
        goto LABEL_8;
      }
      int v5 = blockBufferOut;
    }
    uint64_t DataPointer = CMBlockBufferGetDataPointer(v5, 0, 0, 0, (char **)v12);
    if (!DataPointer) {
      uint64_t DataPointer = CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionData(a1, *(unsigned int **)v12, DataLength, v9, a4);
    }
  }
  else
  {
    uint64_t DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
LABEL_8:
  uint64_t v10 = DataPointer;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v10;
}

uint64_t CMSceneFormatDescriptionCopyAsBigEndianSceneDescriptionBlockBuffer(const __CFAllocator *a1, CFTypeRef cf, uint64_t a3, CMBlockBufferRef *a4)
{
  unint64_t sourceBytes = 0;
  unint64_t v19 = 0;
  CMBlockBufferRef destinationBuffer = 0;
  if (cf)
  {
    if (a4)
    {
      CFTypeID v7 = CFGetTypeID(cf);
      if (v7 == CMFormatDescriptionGetTypeID()
        && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)cf) == 1935893870)
      {
        CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions((CMFormatDescriptionRef)cf);
        if (!Extensions)
        {
          CFStringRef Value = 0;
          size_t v12 = 0;
          goto LABEL_13;
        }
        CMBlockBufferRef blockBufferOut = 0;
        CFStringRef Value = (OpaqueCMBlockBuffer *)CFDictionaryGetValue(Extensions, @"SampleDescriptionExtensionAtoms");
        if (!Value)
        {
LABEL_10:
          size_t DataLength = CMBlockBufferGetDataLength(Value);
          if (DataLength >= 0x7FFFFFF0)
          {
            uint64_t DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_32:
            uint64_t v14 = DataPointer;
LABEL_33:
            if (destinationBuffer) {
              CFRelease(destinationBuffer);
            }
            goto LABEL_19;
          }
          size_t v12 = DataLength;
LABEL_13:
          unint64_t sourceBytes = _byteswap_uint64(__PAIR64__((int)v12 + 16, CMFormatDescriptionGetMediaSubType((CMFormatDescriptionRef)cf)));
          unint64_t v19 = 0xFFFF000000000000;
          uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a1, 0, (v12 + 16), a1, 0, 0, (v12 + 16), 1u, &destinationBuffer);
          if (!DataPointer)
          {
            uint64_t DataPointer = CMBlockBufferReplaceDataBytes(&sourceBytes, destinationBuffer, 0, 0x10uLL);
            if (!DataPointer)
            {
              if (!Value
                || (*(void *)&context[0] = 0,
                    uint64_t DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, 0x10uLL, 0, 0, (char **)context),
                    !DataPointer)
                && (uint64_t DataPointer = CMBlockBufferCopyDataBytes(Value, 0, v12, *(void **)&context[0]),
                    !DataPointer))
              {
                uint64_t v14 = 0;
                *a4 = destinationBuffer;
                CMBlockBufferRef destinationBuffer = 0;
LABEL_19:
                if (Value) {
                  CFRelease(Value);
                }
                return v14;
              }
            }
          }
          goto LABEL_32;
        }
        uint64_t v21 = 0;
        memset(context, 0, sizeof(context));
        uint64_t v10 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
        if (!v10)
        {
          uint64_t v10 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)context);
          if (!v10)
          {
            CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)sceneBridgeAppendExtensionsFunc, context);
            CFStringRef Value = blockBufferOut;
            goto LABEL_10;
          }
        }
        uint64_t v14 = v10;
        if (blockBufferOut) {
          CFRelease(blockBufferOut);
        }
LABEL_28:
        CFStringRef Value = 0;
        goto LABEL_33;
      }
      uint64_t v16 = 4294954581;
    }
    else
    {
      uint64_t v16 = 4294954584;
    }
    uint64_t v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t sceneBridgeAppendExtensionsFunc(const __CFString *a1, const __CFData *a2, uint64_t a3)
{
  unsigned int v11 = 0;
  if (a1
    && (CFTypeID v6 = CFGetTypeID(a1), v6 == CFStringGetTypeID())
    && a2
    && (CFTypeID v7 = CFGetTypeID(a2), v7 == CFDataGetTypeID())
    && FigCFStringGetOSTypeValue(a1, (int *)&v11))
  {
    if (!FigAtomWriterBeginAtom(a3, v11, 0))
    {
      BytePtr = CFDataGetBytePtr(a2);
      CFIndex Length = CFDataGetLength(a2);
      FigAtomWriterAppendData(a3, (uint64_t)BytePtr, Length);
    }
  }
  else
  {
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  return FigAtomWriterEndAtom(a3);
}

uint64_t FigBridgeGetCommonEncryptionScheme(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      int v11 = 1935894637;
      unint64_t v9 = 0;
      uint64_t v10 = 0;
      figBridge_GetSinfChildDataWithPath(a1, a2, &v11, 1, &v10, &v9);
      int v5 = v4;
      uint64_t result = 0;
      if (!v5 && v9 >= 0xC)
      {
        int v6 = *(_DWORD *)(v10 + 4);
        int v7 = *(_DWORD *)(v10 + 8);
        if (v6 == 1668179299 && v7 == 256)
        {
          return 1667591779;
        }
        else
        {
          uint64_t result = 1667392306;
          if (v6 != 845374051 || v7 != 256)
          {
            if (v7 == 256 && v6 == 1935893091) {
              return 1667392371;
            }
            else {
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

void figBridge_GetSinfChildDataWithPath(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, void *a5, void *a6)
{
  memset(v14, 0, sizeof(v14));
  if (a1)
  {
    if (a3)
    {
      if (!FigAtomStreamInitWithMemoryBlock(a1, a2, 0, 1, (uint64_t)v14))
      {
        FigAtomStreamPositionViaAtomPath((uint64_t)v14, a4, a3);
        if (!v11)
        {
          uint64_t v12 = 0;
          uint64_t v13 = 0;
          if (!FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v14, 0, &v12)
            && !FigAtomStreamGetCurrentAtomDataGlobalOffset((uint64_t)v14, 0, &v13))
          {
            if (a5) {
              *a5 = a1 + v13;
            }
            if (a6) {
              *a6 = v12;
            }
          }
        }
      }
    }
  }
}

uint64_t FigBridgeGetOriginalFormatFromSinf(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      int v8 = 1718775137;
      uint64_t v6 = 0;
      int v7 = 0;
      figBridge_GetSinfChildDataWithPath(a1, a2, &v8, 1, &v7, &v6);
      int v5 = v4;
      uint64_t result = 0;
      if (!v5 && v6 == 4) {
        return bswap32(*v7);
      }
    }
  }
  return result;
}

uint64_t FigBridgeExtractCommonEncryptionTrackEncryptionExtension(const __CFAllocator *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  unsigned int v15 = 0;
  v16[0] = 0x74656E6373636869;
  unint64_t v14 = 0;
  figBridge_GetSinfChildDataWithPath(a5, a6, v16, 2, &v15, &v14);
  if (v10) {
    return 0;
  }
  if (!v15 || v14 < 0x18) {
    return 0;
  }
  if (a2) {
    *(void *)(a2 + 8 * *a4) = CFRetain(@"CommonEncryptionTrackEncryptionBox");
  }
  if (a3 && (CFDataRef v13 = CFDataCreate(a1, v15, v14), (*(void *)(a3 + 8 * *a4) = v13) == 0)) {
    uint64_t result = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
  else {
    uint64_t result = 0;
  }
  ++*a4;
  return result;
}

uint64_t FigTransportConnectionUSBCreate(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    ClassIOSurfaceID ID = (void *)NeroTransportConnectionGetClassID();
    uint64_t v5 = CMDerivedObjectCreate(a1, (uint64_t)&kFigTransportConnectionUSBVTable_1, ClassID, &cf);
    if (!v5)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      dispatch_queue_t v7 = FigDispatchQueueCreateWithPriority("FigTransportConnection", 0, 0x1Cu);
      DerivedStorage[1] = v7;
      if (!v7) {
        goto LABEL_16;
      }
      dispatch_queue_t v8 = FigDispatchQueueCreateWithPriority("FigTransportConnection.data", 0, 0x1Cu);
      DerivedStorage[2] = v8;
      if (!v8) {
        goto LABEL_16;
      }
      unint64_t v9 = FigSimpleMutexCreate();
      DerivedStorage[26] = v9;
      if (!v9) {
        goto LABEL_16;
      }
      int v10 = FigSimpleMutexCreate();
      DerivedStorage[20] = v10;
      if (!v10) {
        goto LABEL_16;
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(Mutable, @"FigMemoryPool_LoggingName", @"TransportConnectionUSB");
      uint64_t v12 = CMMemoryPoolCreate(Mutable);
      DerivedStorage[14] = v12;
      if (Mutable)
      {
        CFRelease(Mutable);
        uint64_t v12 = (OpaqueCMMemoryPool *)DerivedStorage[14];
      }
      if (v12)
      {
        CFAllocatorRef Allocator = CMMemoryPoolGetAllocator(v12);
        DerivedStorage[15] = Allocator;
        if (Allocator) {
          CFRetain(Allocator);
        }
        DerivedStorage[4] = CFRetain(@"Nero");
        *a2 = cf;
        CFTypeRef cf = 0;
        FigAtomicIncrement32(&sInstanceCount);
        uint64_t v5 = 0;
      }
      else
      {
LABEL_16:
        uint64_t v5 = 4294955245;
      }
    }
    if (cf) {
      CFRelease(cf);
    }
    return v5;
  }
  else
  {
    return FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
  }
}

void *FigTransportConnectionUSBCopyEventHandler(uint64_t a1)
{
  uint64_t result = *(void **)(CMBaseObjectGetDerivedStorage(a1) + 96);
  if (result)
  {
    return _Block_copy(result);
  }
  return result;
}

uint64_t FigTransportConnectionUSBSetAsConnected(uint64_t a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage(a1);
  *(unsigned char *)(result + 25) = 1;
  return result;
}

uint64_t usb_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (!*DerivedStorage)
  {
    unsigned char *DerivedStorage = 1;
    usb_stopMessageSendingAndReceivingThreads(a1);
  }
  return 0;
}

uint64_t usb_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  usb_Invalidate(a1);
  int v3 = DerivedStorage[1];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[1] = 0;
  }
  int v4 = DerivedStorage[2];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[2] = 0;
  }
  uint64_t v5 = (const void *)DerivedStorage[9];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[9] = 0;
  }
  uint64_t v6 = (const void *)DerivedStorage[12];
  if (v6)
  {
    _Block_release(v6);
    DerivedStorage[12] = 0;
  }
  dispatch_queue_t v7 = DerivedStorage[13];
  if (v7)
  {
    dispatch_release(v7);
    DerivedStorage[13] = 0;
  }
  dispatch_queue_t v8 = (const void *)DerivedStorage[14];
  if (v8)
  {
    CFRelease(v8);
    DerivedStorage[14] = 0;
  }
  unint64_t v9 = (const void *)DerivedStorage[15];
  if (v9)
  {
    CFRelease(v9);
    DerivedStorage[15] = 0;
  }
  int v10 = (const void *)DerivedStorage[4];
  if (v10)
  {
    CFRelease(v10);
    DerivedStorage[4] = 0;
  }
  FigSimpleMutexDestroy(DerivedStorage[26]);
  FigSimpleMutexDestroy(DerivedStorage[20]);

  return FigAtomicDecrement32(&sInstanceCount);
}

__CFString *usb_CopyDebugDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<FigTransportConnectionUSB %p>", a1);
  return Mutable;
}

uint64_t usb_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  dispatch_queue_t v7 = DerivedStorage;
  if (CFEqual(a2, @"ConnectionMode"))
  {
    dispatch_queue_t v8 = (const void *)v7[9];
    if (!v8) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (CFEqual(a2, @"Service"))
  {
    dispatch_queue_t v8 = (const void *)v7[10];
    if (!v8) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (CFEqual(a2, @"IsHiSpeed"))
  {
    unint64_t v9 = (const void **)MEMORY[0x1E4F1CFD0];
    if (v7[31] != 512) {
      unint64_t v9 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    dispatch_queue_t v8 = *v9;
LABEL_12:
    dispatch_queue_t v8 = CFRetain(v8);
    goto LABEL_13;
  }
  if (CFEqual(a2, @"Version"))
  {
    dispatch_queue_t v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (char *)v7 + 28);
    goto LABEL_13;
  }
  if (!CFEqual(a2, @"USBInterfaceName")) {
    return 4294954512;
  }
  dispatch_queue_t v8 = (const void *)v7[4];
  if (v8) {
    goto LABEL_12;
  }
LABEL_13:
  uint64_t v10 = 0;
  *a4 = v8;
  return v10;
}

uint64_t usb_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  uint64_t v6 = DerivedStorage;
  if (CFEqual(a2, @"ConnectionMode"))
  {
    uint64_t v7 = v6[9];
    v6[9] = a3;
    if (!a3) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (CFEqual(a2, @"Service"))
  {
    uint64_t v7 = v6[10];
    v6[10] = a3;
    if (!a3)
    {
LABEL_5:
      if (v7)
      {
        CFRelease((CFTypeRef)v7);
        return 0;
      }
      return v7;
    }
LABEL_4:
    CFRetain(a3);
    goto LABEL_5;
  }
  if (!CFEqual(a2, @"Version"))
  {
    if (!CFEqual(a2, @"USBInterfaceName")) {
      return 4294954512;
    }
    uint64_t v7 = v6[4];
    v6[4] = a3;
    if (!a3) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (!a3) {
    return 4294954516;
  }
  CFTypeID v9 = CFGetTypeID(a3);
  uint64_t v7 = 4294954516;
  if (v9 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (char *)v6 + 28)) {
      return 0;
    }
    else {
      return 4294954516;
    }
  }
  return v7;
}

_opaque_pthread_t *usb_stopMessageSendingAndReceivingThreads(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = DerivedStorage;
  *(unsigned char *)(DerivedStorage + 24) = 1;
  int v3 = (void *)(DerivedStorage + 192);
  if (*(void *)(DerivedStorage + 192))
  {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 200));
    FigThreadJoin(*(pthread_t *)(v2 + 192), 0);
    dispatch_sync(*(dispatch_queue_t *)(v2 + 16), &__block_literal_global_55);
    dispatch_release(*(dispatch_object_t *)(v2 + 200));
    *int v3 = 0;
    v3[1] = 0;
  }
  uint64_t result = *(_opaque_pthread_t **)(v2 + 128);
  if (result)
  {
    if (*(void *)(v2 + 136))
    {
      CFRunLoopStop(*(CFRunLoopRef *)(v2 + 136));
      uint64_t result = *(_opaque_pthread_t **)(v2 + 128);
    }
    uint64_t result = (_opaque_pthread_t *)FigThreadJoin(result, 0);
    *(void *)(v2 + 128) = 0;
  }
  return result;
}

uint64_t usb_SetEventHandler(uint64_t a1, NSObject *a2, unint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  uint64_t v6 = DerivedStorage;
  uint64_t v7 = *(NSObject **)(DerivedStorage + 104);
  if ((unint64_t)a2 | a3)
  {
    if (v7)
    {
      dispatch_release(v7);
      *(void *)(v6 + 104) = 0;
    }
    if (a2)
    {
      *(void *)(v6 + 104) = a2;
      dispatch_retain(a2);
    }
    else
    {
      *(void *)(v6 + 104) = FigDispatchQueueCreateWithPriority("FigTransportConnectionEvent", 0, 0x1Cu);
    }
    dispatch_queue_t v8 = *(const void **)(v6 + 96);
    if (v8)
    {
      _Block_release(v8);
      *(void *)(v6 + 96) = 0;
    }
    if (a3)
    {
      CFTypeID v9 = _Block_copy((const void *)a3);
      uint64_t result = 0;
      *(void *)(v6 + 96) = v9;
      return result;
    }
  }
  else
  {
    if (!v7) {
      return 4294955240;
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __usb_SetEventHandler_block_invoke;
    block[3] = &__block_descriptor_tmp_22_2;
    void block[4] = v6;
    dispatch_sync(v7, block);
  }
  return 0;
}

uint64_t usb_Start(uint64_t a1)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v7 = 4294955241;
    *((_DWORD *)v10 + 6) = -12055;
  }
  else
  {
    uint64_t v3 = DerivedStorage;
    if (CFEqual(*(CFTypeRef *)(DerivedStorage + 72), @"Server")) {
      BOOL v4 = sInstanceCount == 1;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      uint64_t v5 = *(NSObject **)(v3 + 8);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __usb_Start_block_invoke;
      block[3] = &unk_1E567EAC0;
      void block[4] = &v9;
      void block[5] = v3;
      void block[6] = a1;
      dispatch_sync(v5, block);
      uint64_t v7 = *((unsigned int *)v10 + 6);
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
      *((_DWORD *)v10 + 6) = v7;
    }
  }
  _Block_object_dispose(&v9, 8);
  return v7;
}

uint64_t usb_Stop(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)DerivedStorage) {
    return 4294955241;
  }
  uint64_t v3 = *(NSObject **)(DerivedStorage + 8);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __usb_Stop_block_invoke;
  v5[3] = &__block_descriptor_tmp_55_0;
  void v5[4] = DerivedStorage;
  v5[5] = a1;
  dispatch_sync(v3, v5);
  return 0;
}

uint64_t usb_EnqueuePackageWithPriority(const void *a1, _DWORD *a2, OpaqueCMBlockBuffer *a3, int a4)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*DerivedStorage) {
    return 4294955241;
  }
  if (a2[1] != 1885957735)
  {
    if (!DerivedStorage[25])
    {
      uint64_t v17 = 4294955244;
      goto LABEL_24;
    }
    if ((a4 - 3) > 0xFFFFFFFD)
    {
      destinationBuffer[0] = 0;
      if (*a2 <= 7u)
      {
        FigSignalErrorAt(4294955242, 0, 0, 0, 0, 0, 0);
        return 0;
      }
      size_t v9 = *a2 - CMBlockBufferGetDataLength(a3);
      OSStatus appended = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v9, (CFAllocatorRef)*MEMORY[0x1E4F1CF90], 0, 0, v9, 1u, destinationBuffer);
      CMBlockBufferRef v11 = destinationBuffer[0];
      if (!appended)
      {
        OSStatus appended = CMBlockBufferReplaceDataBytes(a2, destinationBuffer[0], 0, v9);
        CMBlockBufferRef v11 = destinationBuffer[0];
        if (a3)
        {
          if (!appended)
          {
            OSStatus appended = CMBlockBufferAppendBufferReference(destinationBuffer[0], a3, 0, 0, 0);
            CMBlockBufferRef v11 = destinationBuffer[0];
          }
        }
      }
      if (appended) {
        BOOL v12 = v11 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12)
      {
        if (!v11) {
          return 0;
        }
        CFDataRef v13 = (OpaqueCMBlockBuffer *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
        if (!*(unsigned char *)v13)
        {
          unint64_t v14 = v13;
          CFRetain(v11);
          CFRetain(a1);
          unsigned int v15 = *((void *)v14 + 2);
          destinationBuffer[0] = (CMBlockBufferRef)MEMORY[0x1E4F143A8];
          destinationBuffer[1] = (CMBlockBufferRef)0x40000000;
          destinationBuffer[2] = (CMBlockBufferRef)__usb_enqueuePackageWithPriority_block_invoke;
          destinationBuffer[3] = (CMBlockBufferRef)&__block_descriptor_tmp_56;
          int v19 = a4;
          destinationBuffer[4] = v14;
          destinationBuffer[5] = v11;
          destinationBuffer[6] = (CMBlockBufferRef)a1;
          dispatch_async(v15, destinationBuffer);
        }
      }
      CFRelease(v11);
      return 0;
    }
  }
  uint64_t v17 = 4294955246;
LABEL_24:

  return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
}

uint64_t usb_FlushPendingPackagesWithPriority(const void *a1, int a2)
{
  if (*(unsigned char *)CMBaseObjectGetDerivedStorage((uint64_t)a1)) {
    return 4294955241;
  }
  usb_sendDataViaUSB(a1, a2);
  return 0;
}

uint64_t usb_messageSendingThreadMain(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v3 = DerivedStorage;
    do
    {
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v3 + 200), 0xFFFFFFFFFFFFFFFFLL);
      usb_sendDataViaUSB(a1, 0);
    }
    while (!*(unsigned char *)(v3 + 24));
  }
  return 0;
}

uint64_t usb_clientThreadMain(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  SInt32 theScore = 0;
  uint64_t v25 = 0;
  theInterface = 0;
  __int16 v24 = 0;
  __int16 v23 = 0;
  char v22 = 0;
  unsigned __int16 v21 = 0;
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  *(void *)(DerivedStorage + 136) = Current;
  if (!Current) {
    goto LABEL_7;
  }
  *(void *)(DerivedStorage + 288) = a1;
  *(void *)(DerivedStorage + 296) = 0;
  *(void *)(DerivedStorage + 304) = malloc_type_malloc(0x10000uLL, 0xDFD76604uLL);
  uint64_t v4 = *(void *)(DerivedStorage + 80);
  if (!v4) {
    goto LABEL_7;
  }
  io_service_t IOKitObject = FigCFIOKitObjectGetIOKitObject(v4);
  CFUUIDRef v6 = CFUUIDGetConstantUUIDWithBytes(0, 0x2Du, 0x97u, 0x86u, 0xC6u, 0x9Eu, 0xF3u, 0x11u, 0xD4u, 0xADu, 0x51u, 0, 0xAu, 0x27u, 5u, 0x28u, 0x61u);
  CFUUIDRef v7 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  if (IOCreatePlugInInterfaceForService(IOKitObject, v6, v7, &theInterface, &theScore)) {
    goto LABEL_7;
  }
  dispatch_queue_t v8 = theInterface;
  *(void *)(DerivedStorage + 256) = theInterface;
  QueryInterface = (*v8)->QueryInterface;
  CFUUIDRef v10 = CFUUIDGetConstantUUIDWithBytes(0, 0x8Fu, 0xDBu, 0x84u, 0x55u, 0x74u, 0xA6u, 0x11u, 0xD6u, 0x97u, 0xB1u, 0, 0x30u, 0x65u, 0xD3u, 0x60u, 0x8Eu);
  CFUUIDBytes v11 = CFUUIDGetUUIDBytes(v10);
  if (((unsigned int (*)(IOCFPlugInInterface **, void, void, uint64_t *))QueryInterface)(v8, *(void *)&v11.byte0, *(void *)&v11.byte8, &v25))
  {
    goto LABEL_7;
  }
  uint64_t v12 = v25;
  *(void *)(DerivedStorage + 264) = v25;
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 64))(v12)) {
    goto LABEL_7;
  }
  *(unsigned char *)(DerivedStorage + 272) = 1;
  if ((*(unsigned int (**)(uint64_t, char *))(*(void *)v25 + 152))(v25, (char *)&v24 + 1)) {
    goto LABEL_7;
  }
  if (HIBYTE(v24))
  {
    unsigned __int8 v14 = 1;
    while (!(*(unsigned int (**)(uint64_t, void, __int16 *, char *, __int16 *, unsigned __int16 *, char *))(*(void *)v25 + 208))(v25, v14, &v24, (char *)&v23 + 1, &v23, &v21, &v22)&& !(*(unsigned int (**)(uint64_t, void))(*(void *)v25 + 360))(v25, v14))
    {
      if (v23 == 2 && v24 == 1)
      {
        if (!*(unsigned char *)(DerivedStorage + 273)) {
          *(unsigned char *)(DerivedStorage + 273) = v14;
        }
      }
      else
      {
        BOOL v16 = v23 == 2 && v24 == 0;
        if (v16 && !*(unsigned char *)(DerivedStorage + 274))
        {
          *(unsigned char *)(DerivedStorage + 274) = v14;
          *(void *)(DerivedStorage + 248) = v21;
        }
      }
      if (HIBYTE(v24) < ++v14) {
        goto LABEL_27;
      }
    }
    goto LABEL_7;
  }
LABEL_27:
  if (!*(unsigned char *)(DerivedStorage + 273)) {
    goto LABEL_7;
  }
  if (!*(unsigned char *)(DerivedStorage + 274)) {
    goto LABEL_7;
  }
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 0x40000000;
  aBlock[2] = __usb_clientThreadSetup_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_36_1;
  aBlock[4] = v25;
  aBlock[5] = DerivedStorage;
  *(void *)(DerivedStorage + 232) = _Block_copy(aBlock);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 0x40000000;
  int v19[2] = __usb_clientThreadSetup_block_invoke_2;
  v19[3] = &__block_descriptor_tmp_38_0;
  v19[4] = DerivedStorage;
  *(void *)(DerivedStorage + 240) = _Block_copy(v19);
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v25 + 32))(v25, DerivedStorage + 280)
    || (CFRunLoopAddSource(*(CFRunLoopRef *)(DerivedStorage + 136), *(CFRunLoopSourceRef *)(DerivedStorage + 280), (CFRunLoopMode)*MEMORY[0x1E4F1D418]), (*(unsigned int (**)(void))(*(void *)(DerivedStorage + 232) + 16))()))
  {
LABEL_7:
    usb_clientThreadTearDown((uint64_t)a1);
    goto LABEL_8;
  }
  uint64_t v17 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v18 = malloc_type_malloc(0x10uLL, 0x6CFA150CuLL);
  int v18[2] = 1;
  *(void *)uint64_t v18 = 0x70696E6700000010;
  v18[3] = *(_DWORD *)(v17 + 28);
  if (!(*(unsigned int (**)(void, void))(**(void **)(v17 + 264) + 224))(*(void *)(v17 + 264), *(unsigned __int8 *)(v17 + 274))&& !(*(unsigned int (**)(void, void, _DWORD *, uint64_t, void (__cdecl *)(void *), _DWORD *))(**(void **)(v17 + 264) + 272))(*(void *)(v17 + 264), *(unsigned __int8 *)(v17 + 274), v18, 16, usb_pingAsyncCallback, v18))
  {
    uint64_t v18 = 0;
  }
  free(v18);
LABEL_8:
  CFRunLoopRun();
  usb_setDisconnected(a1);
  usb_clientThreadTearDown((uint64_t)a1);
  return 0;
}

void usb_sendDataViaUSB(const void *a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 208));
  dataPointerOut = 0;
  size_t lengthAtOffsetOut = 0;
  uint64_t v15 = 0;
  BOOL v16 = &v15;
  uint64_t v17 = 0x2000000000;
  uint64_t v18 = 0;
  CFUUIDRef v6 = (CFTypeRef *)(DerivedStorage + 216);
  uint64_t v5 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 216);
  if (v5)
  {
    CMBlockBufferGetDataPointer(v5, *(void *)(DerivedStorage + 224), &lengthAtOffsetOut, 0, &dataPointerOut);
    unint64_t v7 = usb_sendMemoryBlockViaUSB(a1);
    *(void *)(DerivedStorage + 224) += v7;
    if (v7 != lengthAtOffsetOut) {
      goto LABEL_17;
    }
    if (!(v7 % *(void *)(DerivedStorage + 248)))
    {
      uint64_t v14 = 0;
      (*(void (**)(void))(*(void *)(DerivedStorage + 240) + 16))();
    }
    if (*v6)
    {
      CFRelease(*v6);
      *CFUUIDRef v6 = 0;
    }
    *(void *)(DerivedStorage + 224) = 0;
  }
  dispatch_queue_t v8 = *(NSObject **)(DerivedStorage + 16);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  int v12[2] = __usb_sendDataViaUSB_block_invoke;
  v12[3] = &unk_1E567EAE8;
  int v13 = a2;
  v12[4] = &v15;
  v12[5] = DerivedStorage;
  dispatch_sync(v8, v12);
  size_t v9 = (OpaqueCMBlockBuffer *)v16[3];
  if (v9)
  {
    CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, *(CFAllocatorRef *)(DerivedStorage + 120), 0, 0, 0, 0, (CMBlockBufferRef *)(DerivedStorage + 216));
    CFUUIDRef v10 = (const void *)v16[3];
    if (v10)
    {
      CFRelease(v10);
      v16[3] = 0;
    }
    CMBlockBufferGetDataPointer((CMBlockBufferRef)*v6, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    unint64_t v11 = usb_sendMemoryBlockViaUSB(a1);
    if (v11 == lengthAtOffsetOut)
    {
      if (!(v11 % *(void *)(DerivedStorage + 248)))
      {
        uint64_t v14 = 0;
        (*(void (**)(void))(*(void *)(DerivedStorage + 240) + 16))();
      }
      unint64_t v11 = (unint64_t)*v6;
      if (*v6)
      {
        CFRelease((CFTypeRef)v11);
        unint64_t v11 = 0;
        *CFUUIDRef v6 = 0;
      }
    }
    *(void *)(DerivedStorage + 224) = v11;
  }
LABEL_17:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 208));
  _Block_object_dispose(&v15, 8);
}

uint64_t usb_sendMemoryBlockViaUSB(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v7 = 0;
  if (!*(unsigned char *)DerivedStorage)
  {
    uint64_t v3 = DerivedStorage;
    if (*(unsigned char *)(DerivedStorage + 25))
    {
      if ((*(unsigned int (**)(void))(*(void *)(DerivedStorage + 240) + 16))() == -536870186)
      {
        CFRetain(a1);
        uint64_t v4 = *(NSObject **)(v3 + 8);
        v6[0] = MEMORY[0x1E4F143A8];
        v6[1] = 0x40000000;
        int v6[2] = __usb_sendMemoryBlockViaUSB_block_invoke;
        v6[3] = &__block_descriptor_tmp_32_1;
        v6[4] = a1;
        dispatch_async(v4, v6);
      }
    }
  }
  return v7;
}

void __usb_sendDataViaUSB_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  if ((v2 - 1) >= 2)
  {
    uint64_t v3 = 56;
    while (1)
    {
      uint64_t v4 = *(OpaqueCMBlockBuffer **)(*(void *)(a1 + 40) + v3);
      if (v4)
      {
        uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
        CFUUIDRef v6 = *(OpaqueCMBlockBuffer **)(v5 + 24);
        if (!v6)
        {
          *(void *)(v5 + 24) = v4;
          goto LABEL_9;
        }
        CMBlockBufferAppendBufferReference(v6, v4, 0, 0, 0);
        uint64_t v7 = *(const void **)(*(void *)(a1 + 40) + v3);
        if (v7)
        {
          CFRelease(v7);
LABEL_9:
          *(void *)(*(void *)(a1 + 40) + v3) = 0;
        }
      }
      v3 += 8;
      if (v3 == 72) {
        return;
      }
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(*(void *)(a1 + 40) + 8 * v2 + 48);
  *(void *)(*(void *)(a1 + 40) + 8 * v2 + 48) = 0;
}

void __usb_sendMemoryBlockViaUSB_block_invoke(uint64_t a1)
{
  usb_setDisconnected(*(const void **)(a1 + 32));
  uint64_t v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

uint64_t usb_setDisconnected(const void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v12[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v12, &type);
  int v4 = v12[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    v12[1] = 136315138;
    int v13 = "usb_setDisconnected";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v12[0];
  }
  else
  {
    uint64_t v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v14, v4, 0, v5);
  *(unsigned char *)(DerivedStorage + 25) = 0;
  if (!*(unsigned char *)DerivedStorage)
  {
    CFRetain(a1);
    dispatch_queue_t v8 = *(NSObject **)(DerivedStorage + 104);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __usb_setDisconnected_block_invoke;
    block[3] = &__block_descriptor_tmp_33_0;
    void block[4] = DerivedStorage;
    void block[5] = a1;
    dispatch_async(v8, block);
  }
  return usb_connectionReset(a1);
}

void __usb_setDisconnected_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)v2)
  {
    uint64_t v3 = *(void *)(v2 + 96);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, 2, 0);
    }
  }
  int v4 = *(const void **)(a1 + 40);

  CFRelease(v4);
}

uint64_t usb_connectionReset(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  usb_resetMessageReceiptState((uint64_t)a1);
  CFRetain(a1);
  uint64_t v3 = *(NSObject **)(DerivedStorage + 16);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  int v6[2] = __usb_connectionReset_block_invoke;
  v6[3] = &__block_descriptor_tmp_34_1;
  v6[4] = DerivedStorage;
  void v6[5] = a1;
  dispatch_async(v3, v6);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 208));
  int v4 = *(const void **)(DerivedStorage + 216);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 216) = 0;
  }
  *(void *)(DerivedStorage + 224) = 0;
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 208));
}

uint64_t usb_resetMessageReceiptState(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 160));
  uint64_t v2 = *(const void **)(DerivedStorage + 184);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 184) = 0;
  }
  *(_DWORD *)(DerivedStorage + 176) = 0;
  *(void *)(DerivedStorage + 168) = 0;
  uint64_t v3 = *(pthread_mutex_t **)(DerivedStorage + 160);

  return FigSimpleMutexUnlock(v3);
}

void __usb_connectionReset_block_invoke(uint64_t a1)
{
  for (uint64_t i = 56; i != 72; i += 8)
  {
    uint64_t v3 = *(const void **)(*(void *)(a1 + 32) + i);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(*(void *)(a1 + 32) + i) = 0;
    }
  }
  int v4 = *(const void **)(a1 + 40);

  CFRelease(v4);
}

void usb_clientThreadTearDown(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = DerivedStorage;
  if (*(unsigned char *)(DerivedStorage + 273))
  {
    (*(void (**)(void))(**(void **)(DerivedStorage + 264) + 224))(*(void *)(DerivedStorage + 264));
    *(unsigned char *)(v2 + 273) = 0;
  }
  if (*(unsigned char *)(v2 + 274))
  {
    (*(void (**)(void))(**(void **)(v2 + 264) + 224))(*(void *)(v2 + 264));
    *(unsigned char *)(v2 + 274) = 0;
  }
  uint64_t v3 = *(__CFRunLoopSource **)(v2 + 280);
  if (v3)
  {
    CFRunLoopRemoveSource(*(CFRunLoopRef *)(v2 + 136), v3, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
    int v4 = *(const void **)(v2 + 280);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(v2 + 280) = 0;
    }
  }
  if (*(unsigned char *)(v2 + 272))
  {
    (*(void (**)(void))(**(void **)(v2 + 264) + 72))(*(void *)(v2 + 264));
    *(unsigned char *)(v2 + 272) = 0;
  }
  uint64_t v5 = *(void *)(v2 + 264);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    *(void *)(v2 + 264) = 0;
  }
  unsigned int v6 = *(IOCFPlugInInterface ***)(v2 + 256);
  if (v6)
  {
    IODestroyPlugInInterface(v6);
    *(void *)(v2 + 256) = 0;
  }
  *(void *)(v2 + 136) = 0;
  free(*(void **)(v2 + 304));
  *(void *)(v2 + 304) = 0;
  uint64_t v7 = *(const void **)(v2 + 232);
  if (v7)
  {
    _Block_release(v7);
    *(void *)(v2 + 232) = 0;
  }
  dispatch_queue_t v8 = *(const void **)(v2 + 240);
  if (v8)
  {
    _Block_release(v8);
    *(void *)(v2 + 240) = 0;
  }
}

uint64_t __usb_clientThreadSetup_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, void, uint64_t, uint64_t (*)(uint64_t *, int, size_t)))(**(void **)(a1 + 32) + 264))(*(void *)(a1 + 32), *(unsigned __int8 *)(*(void *)(a1 + 40) + 273), *(void *)(a2 + 16), 0x10000, usb_readCompleted);
}

uint64_t usb_readCompleted(uint64_t *a1, int a2, size_t a3)
{
  unsigned int v6 = (const void *)*a1;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  uint64_t v8 = DerivedStorage;
  size_t v9 = (char *)a1[2];
  size_t lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  if (a2)
  {
    usb_resetMessageReceiptState((uint64_t)v6);
    LODWORD(v10) = 0;
    goto LABEL_49;
  }
  unint64_t v11 = (unsigned int *)(DerivedStorage + 176);
  uint64_t v12 = (CMBlockBufferRef *)(DerivedStorage + 184);
  structureCFAllocatorRef Allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v8 + 160));
    size_t v13 = *(void *)(v8 + 168);
    if (v13 <= 3) {
      break;
    }
LABEL_10:
    if (!*v12)
    {
      LODWORD(v10) = 1;
      if (CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, *(unsigned int *)(v8 + 176), *(CFAllocatorRef *)(v8 + 120), 0, 0, *(unsigned int *)(v8 + 176), 1u, (CMBlockBufferRef *)(v8 + 184))|| CMBlockBufferReplaceDataBytes((const void *)(v8 + 176), *v12, 0, 4uLL))
      {
        goto LABEL_49;
      }
      size_t v13 = *(void *)(v8 + 168);
    }
    size_t v15 = *v11;
    if (v13 < v15)
    {
      if (!a3 || CMBlockBufferGetDataPointer(*v12, v13, &lengthAtOffsetOut, 0, &dataPointerOut)) {
        goto LABEL_48;
      }
      if (lengthAtOffsetOut >= a3) {
        size_t v16 = a3;
      }
      else {
        size_t v16 = lengthAtOffsetOut;
      }
      size_t lengthAtOffsetOut = v16;
      memcpy(dataPointerOut, v9, v16);
      v9 += lengthAtOffsetOut;
      a3 -= lengthAtOffsetOut;
      size_t v13 = *(void *)(v8 + 168) + lengthAtOffsetOut;
      *(void *)(v8 + 168) = v13;
      size_t v15 = *(unsigned int *)(v8 + 176);
    }
    if (v13 == v15)
    {
      CFUUIDRef v10 = *(OpaqueCMBlockBuffer **)(v8 + 184);
      *(void *)(v8 + 184) = 0;
      *(_DWORD *)(v8 + 176) = 0;
      *(void *)(v8 + 168) = 0;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 160));
      uint64_t v17 = CMBaseObjectGetDerivedStorage((uint64_t)v6);
      unsigned int v32 = 0;
      if (CMBlockBufferGetDataLength(v10) >= 8)
      {
        size_t DataLength = CMBlockBufferGetDataLength(v10);
        if (CMBlockBufferIsRangeContiguous(v10, 0, DataLength))
        {
          if (!CMBlockBufferGetDataPointer(v10, 0, 0, 0, &v32))
          {
            size_t v19 = CMBlockBufferGetDataLength(v10);
            CFDictionaryRef v20 = v32;
            if (v19 == *(_DWORD *)v32)
            {
              if (*((_DWORD *)v32 + 1) != 1885957735)
              {
                if (!*(unsigned char *)v17)
                {
                  CFRetain(v10);
                  CFRetain(v6);
                  __int16 v23 = *(NSObject **)(v17 + 104);
                  block[0] = MEMORY[0x1E4F143A8];
                  block[1] = 0x40000000;
                  block[2] = __usb_didReceivePackage_block_invoke;
                  block[3] = &__block_descriptor_tmp_39;
                  void block[4] = v17;
                  void block[5] = v10;
                  void block[6] = v6;
                  dispatch_async(v23, block);
                }
                goto LABEL_25;
              }
              uint64_t v21 = CMBaseObjectGetDerivedStorage((uint64_t)v6);
              size_t v22 = CMBlockBufferGetDataLength(v10);
              CMBlockBufferRef v33 = 0;
              if (v22 >= 0xD)
              {
                if (CMBlockBufferCreateWithBufferReference(structureAllocator, v10, 0xCuLL, v22 - 12, 0, &v33))
                {
LABEL_46:
                  if (v33) {
                    CFRelease(v33);
                  }
                  goto LABEL_25;
                }
                if (*((_DWORD *)v20 + 2)) {
                  usb_deviceSendStartupPing((uint64_t)v6);
                }
              }
              if (*(unsigned char *)(v21 + 40)) {
                usb_setDisconnected(v6);
              }
              else {
                *(unsigned char *)(v21 + 40) = 1;
              }
              CMBlockBufferRef v24 = v33;
              uint64_t v25 = CMBaseObjectGetDerivedStorage((uint64_t)v6);
              usb_connectionReset(v6);
              *(unsigned char *)(v25 + 25) = 1;
              if (!*(unsigned char *)v25)
              {
                if (v24) {
                  CFRetain(v24);
                }
                CFRetain(v6);
                uint64_t v26 = *(NSObject **)(v25 + 104);
                v34[0] = MEMORY[0x1E4F143A8];
                v34[1] = 0x40000000;
                v34[2] = __usb_setConnected_block_invoke;
                v34[3] = &__block_descriptor_tmp_40_1;
                v34[4] = v25;
                v34[5] = v24;
                v34[6] = v6;
                dispatch_async(v26, v34);
              }
              goto LABEL_46;
            }
          }
        }
      }
LABEL_25:
      if (v10)
      {
        CFRelease(v10);
        LODWORD(v10) = 0;
      }
      if (!a3) {
        goto LABEL_49;
      }
    }
    else
    {
      LODWORD(v10) = 1;
      if (!a3) {
        goto LABEL_49;
      }
    }
  }
  if (4 - v13 >= a3) {
    size_t v14 = a3;
  }
  else {
    size_t v14 = 4 - v13;
  }
  size_t lengthAtOffsetOut = v14;
  dataPointerOut = (char *)v11 + v13;
  memcpy((char *)v11 + v13, v9, v14);
  size_t v13 = *(void *)(v8 + 168) + v14;
  *(void *)(v8 + 168) = v13;
  if (v13 >= 4)
  {
    v9 += v14;
    a3 -= v14;
    goto LABEL_10;
  }
LABEL_48:
  LODWORD(v10) = 1;
LABEL_49:
  uint64_t result = *(void *)(v8 + 232);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(result + 16))(result, a1);
  }
  if (v10) {
    return FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 160));
  }
  return result;
}

uint64_t __usb_clientThreadSetup_block_invoke_2(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, void *a5)
{
  if (!a3) {
    a3 = &v9;
  }
  uint64_t result = (*(uint64_t (**)(void, void, char *))(**(void **)(*(void *)(a1 + 32) + 264) + 256))(*(void *)(*(void *)(a1 + 32) + 264), *(unsigned __int8 *)(*(void *)(a1 + 32) + 274), a3);
  if (result) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = a4;
  }
  *a5 = v8;
  return result;
}

void __usb_didReceivePackage_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)v2)
  {
    uint64_t v3 = *(void *)(v2 + 96);
    if (v3) {
      (*(void (**)(uint64_t, void, void))(v3 + 16))(v3, 0, *(void *)(a1 + 40));
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  int v4 = *(const void **)(a1 + 48);

  CFRelease(v4);
}

uint64_t usb_deviceSendStartupPing(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(DerivedStorage + 296) + 192))(*(void *)(DerivedStorage + 296), *(void *)(DerivedStorage + 312));
  if (!result)
  {
    uint64_t v3 = *(void *)(DerivedStorage + 392);
    uint64_t v4 = usb_deviceSendStartupPing_pingHeader;
    *(_DWORD *)(v3 + 8) = dword_1E92713D8;
    *(void *)uint64_t v3 = v4;
    *(_DWORD *)(*(void *)(DerivedStorage + 392) + 12) = *(_DWORD *)(DerivedStorage + 28);
    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(DerivedStorage + 296) + 176);
    return v5();
  }
  return result;
}

void __usb_setConnected_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (!*(unsigned char *)v2)
  {
    uint64_t v3 = *(void *)(v2 + 96);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, 1, a1[5]);
    }
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[6];

  CFRelease(v5);
}

uint64_t usb_serverThreadMain(void *a1)
{
  kern_return_t v22;
  os_log_type_t type;
  int v25;
  int v26;
  const char *v27;
  unsigned char v28[128];
  uint64_t v29;

  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v25 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
  int v4 = v25;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    uint64_t v26 = 136315138;
    uint64_t v27 = "usb_serverThreadMain";
    uint64_t v7 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v25;
  }
  else
  {
    uint64_t v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != v28, v4, 0, v5);
  uint64_t v8 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v25 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  char v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
  int v10 = v25;
  if (os_log_type_enabled(v9, type)) {
    unsigned int v12 = v10;
  }
  else {
    unsigned int v12 = v10 & 0xFFFFFFFE;
  }
  if (v12)
  {
    uint64_t v26 = 136315138;
    uint64_t v27 = "usb_serverThreadSetup";
    size_t v13 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v10) = v25;
  }
  else
  {
    size_t v13 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v13, v13 != v28, v10, 0, v11);
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  *(void *)(v8 + 136) = Current;
  if (!Current) {
    goto LABEL_25;
  }
  CFMutableDictionaryRef v15 = IOServiceMatching("IOUSBDeviceInterface");
  if (!v15) {
    goto LABEL_25;
  }
  size_t v16 = v15;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    goto LABEL_24;
  }
  uint64_t v18 = Mutable;
  CFDictionarySetValue(Mutable, @"USBDeviceFunction", *(const void **)(v8 + 32));
  CFDictionarySetValue(v16, @"IOPropertyMatch", v18);
  CFRelease(v18);
  size_t v19 = IONotificationPortCreate(*MEMORY[0x1E4F2EEF0]);
  *(void *)(v8 + 256) = v19;
  if (!v19 || (RunLoopSource = IONotificationPortGetRunLoopSource(v19), (*(void *)(v8 + 264) = RunLoopSource) == 0))
  {
LABEL_24:
    CFRelease(v16);
LABEL_25:
    size_t v22 = -12051;
    goto LABEL_19;
  }
  CFRunLoopAddSource(*(CFRunLoopRef *)(v8 + 136), RunLoopSource, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
  uint64_t v21 = (io_iterator_t *)(v8 + 272);
  size_t v22 = IOServiceAddMatchingNotification(*(IONotificationPortRef *)(v8 + 256), "IOServiceFirstMatch", v16, (IOServiceMatchingCallback)usb_handleDeviceAttached, a1, (io_iterator_t *)(v8 + 272));
  if (v22)
  {
LABEL_19:
    usb_serverThreadTearDown(a1);
    goto LABEL_21;
  }
  usb_handleDeviceAttached(a1, *v21);
LABEL_21:
  *(_DWORD *)(DerivedStorage + 152) = v22;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 144));
  if (!v22)
  {
    CFRunLoopRun();
    usb_setDisconnected(a1);
    usb_serverThreadTearDown(a1);
  }
  return 0;
}

void usb_serverThreadTearDown(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  usb_deviceTearDown(a1);
  io_object_t v3 = *(_DWORD *)(DerivedStorage + 272);
  if (v3)
  {
    IOObjectRelease(v3);
    *(_DWORD *)(DerivedStorage + 272) = 0;
  }
  int v4 = *(__CFRunLoopSource **)(DerivedStorage + 264);
  if (v4) {
    CFRunLoopRemoveSource(*(CFRunLoopRef *)(DerivedStorage + 136), v4, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
  }
  uint64_t v5 = *(IONotificationPort **)(DerivedStorage + 256);
  if (v5)
  {
    IONotificationPortDestroy(v5);
    *(void *)(DerivedStorage + 256) = 0;
  }
  *(void *)(DerivedStorage + 136) = 0;
}

uint64_t usb_handleDeviceAttached(void *a1, io_iterator_t a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t result = IOIteratorNext(a2);
  if (result)
  {
    io_object_t v6 = result;
    uint64_t v26 = *MEMORY[0x1E4F1D418];
    while (*(_DWORD *)(DerivedStorage + 280))
    {
LABEL_33:
      uint64_t result = IOIteratorNext(a2);
      io_object_t v6 = result;
      if (!result) {
        return result;
      }
    }
    uint64_t v7 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    theInterface = 0;
    SInt32 theScore = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    unsigned int v28 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v28, &type);
    int v9 = v28;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v11 = v9;
    }
    else {
      unsigned int v11 = v9 & 0xFFFFFFFE;
    }
    if (v11)
    {
      int v33 = 136315138;
      CFAllocatorRef v34 = "usb_deviceSetup";
      unsigned int v12 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v9) = v28;
    }
    else
    {
      unsigned int v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v12, v12 != v35, v9, 0, v10);
    if (!IOServiceAddInterestNotification(*(IONotificationPortRef *)(v7 + 256), v6, "IOGeneralInterest", (IOServiceInterestCallback)usb_generalInterestNotification, a1, (io_object_t *)(v7 + 276)))
    {
      CFUUIDRef v13 = CFUUIDGetConstantUUIDWithBytes(0, 0x9Eu, 0x72u, 0x21u, 0x7Eu, 0x8Au, 0x60u, 0x11u, 0xDBu, 0xBFu, 0x57u, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
      CFUUIDRef v14 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
      if (!IOCreatePlugInInterfaceForService(v6, v13, v14, &theInterface, &theScore))
      {
        CFMutableDictionaryRef v15 = theInterface;
        if (theInterface)
        {
          *(void *)(v7 + 288) = theInterface;
          QueryInterface = (*v15)->QueryInterface;
          CFUUIDRef v17 = CFUUIDGetConstantUUIDWithBytes(0, 0xEAu, 0x33u, 0xBAu, 0x4Fu, 0x8Au, 0x60u, 0x11u, 0xDBu, 0x84u, 0xDBu, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
          CFUUIDBytes v18 = CFUUIDGetUUIDBytes(v17);
          if (!((unsigned int (*)(IOCFPlugInInterface **, void, void, uint64_t *))QueryInterface)(v15, *(void *)&v18.byte0, *(void *)&v18.byte8, &v30))
          {
            uint64_t v19 = v30;
            if (v30)
            {
              *(void *)(v7 + 296) = v30;
              if (!(*(unsigned int (**)(uint64_t, void))(*(void *)v19 + 32))(v19, 0))
              {
                *(unsigned char *)(v7 + 304) = 1;
                (*(void (**)(uint64_t, void))(*(void *)v30 + 80))(v30, *(void *)(v7 + 32));
                if (!(*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)v30 + 88))(v30, 255, 0)&& !(*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)v30 + 96))(v30, 42, 0)&& !(*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)v30 + 104))(v30, 255, 0)&& !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, uint64_t))(*(void *)v30 + 128))(v30, 2, 1, 0xFFFFFFFFLL, 10, 0, 0, v7 + 312)&& !(*(unsigned int (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, void, void, uint64_t))(*(void *)v30 + 128))(v30,
                        2,
                        0,
                        0xFFFFFFFFLL,
                        10,
                        0,
                        0,
                        v7 + 320)
                  && !(*(unsigned int (**)(uint64_t, void, void, void *))(*(void *)v30 + 72))(v30, usb_deviceHandleInterfaceMessage, 0, a1)&& !(*(unsigned int (**)(uint64_t, uint64_t (*)(), void, void, void *, void *, void, uint64_t))(*(void *)v30 + 64))(v30, usb_deviceHandleSetupAction, 0, 0, a1, a1, *(void *)(v7 + 136), v26)&& !(*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v30 + 48))(v30, *(void *)(v7 + 136), v26))
                {
                  unsigned int v28 = 0;
                  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                  CFDictionaryRef v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v28, &type);
                  unsigned int v21 = v28;
                  if (os_log_type_enabled(v20, type) ? v21 : v21 & 0xFFFFFFFE)
                  {
                    int v33 = 136315138;
                    CFAllocatorRef v34 = "usb_deviceSetup";
                    CMBlockBufferRef v24 = (unsigned char *)_os_log_send_and_compose_impl();
                    LOBYTE(v21) = v28;
                  }
                  else
                  {
                    CMBlockBufferRef v24 = 0;
                  }
                  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v24, v24 != v35, v21, 0, v22);
                  if (!(*(unsigned int (**)(uint64_t))(*(void *)v30 + 136))(v30))
                  {
                    IOObjectRetain(v6);
                    *(_DWORD *)(v7 + 280) = v6;
                    int v25 = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)v30 + 288))(v30, (char *)&v29 + 4, &v29);
                    if (!v25 && HIDWORD(v29))
                    {
                      usb_deviceActivate(a1);
                      goto LABEL_32;
                    }
                    if (!v25) {
                      goto LABEL_32;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    usb_deviceTearDown(a1);
LABEL_32:
    IOObjectRelease(v6);
    goto LABEL_33;
  }
  return result;
}

uint64_t usb_generalInterestNotification(const void *a1, uint64_t a2, int a3)
{
  uint64_t result = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a3 == -536870896)
  {
    return usb_deviceTearDown(a1);
  }
  return result;
}

void usb_deviceHandleInterfaceMessage(uint64_t a1, int a2, uint64_t a3, const void *a4)
{
  if (a2 == -469794543)
  {
    usb_deviceDeactivate(a4);
  }
  else if (a2 == -469794544)
  {
    usb_deviceActivate(a4);
  }
}

uint64_t usb_deviceHandleSetupAction()
{
  return 0;
}

void usb_deviceActivate(const void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v20 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v20, &type);
  unsigned int v4 = v20;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    int v21 = 136315138;
    uint64_t v22 = "usb_deviceActivate";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v20;
  }
  else
  {
    uint64_t v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v23, v4, 0, v5);
  if (!(*(unsigned int (**)(void, void, char *))(**(void **)(DerivedStorage + 296) + 200))(*(void *)(DerivedStorage + 296), *(void *)(DerivedStorage + 320), (char *)&v20 + 4))
  {
    *(void *)(DerivedStorage + 248) = SHIDWORD(v20);
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 0x40000000;
    aBlock[2] = __usb_deviceActivate_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_53;
    aBlock[4] = DerivedStorage;
    *(void *)(DerivedStorage + 232) = _Block_copy(aBlock);
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 0x40000000;
    int v17[2] = __usb_deviceActivate_block_invoke_2;
    v17[3] = &__block_descriptor_tmp_54;
    v17[4] = DerivedStorage;
    uint64_t v8 = 0;
    *(void *)(DerivedStorage + 240) = _Block_copy(v17);
    char v9 = 1;
    while (1)
    {
      char v10 = v9;
      uint64_t v11 = DerivedStorage + 24 * v8;
      *(void *)(v11 + 328) = a1;
      if ((*(unsigned int (**)(void, uint64_t, uint64_t))(**(void **)(DerivedStorage + 296) + 208))(*(void *)(DerivedStorage + 296), 0x10000, v11 + 336))
      {
        break;
      }
      uint64_t BytePtr = IOUSBDeviceDataGetBytePtr();
      char v9 = 0;
      *(void *)(DerivedStorage + 24 * v8 + 344) = BytePtr;
      uint64_t v8 = 1;
      if ((v10 & 1) == 0)
      {
        if (!(*(unsigned int (**)(void, uint64_t, uint64_t))(**(void **)(DerivedStorage + 296) + 208))(*(void *)(DerivedStorage + 296), 0x10000, DerivedStorage + 384))
        {
          uint64_t v13 = IOUSBDeviceDataGetBytePtr();
          uint64_t v14 = 0;
          *(void *)(DerivedStorage + 392) = v13;
          for (char i = 1; ; char i = 0)
          {
            char v16 = i;
            if ((*(unsigned int (**)(void, uint64_t))(*(void *)(DerivedStorage + 232) + 16))(*(void *)(DerivedStorage + 232), DerivedStorage + 24 * v14 + 328))
            {
              break;
            }
            uint64_t v14 = 1;
            if ((v16 & 1) == 0)
            {
              *(unsigned char *)(DerivedStorage + 305) = 1;
              usb_deviceSendStartupPing((uint64_t)a1);
              return;
            }
          }
        }
        break;
      }
    }
  }
  usb_deviceDeactivate(a1);
}

uint64_t usb_deviceTearDown(const void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v13[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v13, &type);
  int v4 = v13[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    v13[1] = 136315138;
    uint64_t v14 = "usb_deviceTearDown";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v13[0];
  }
  else
  {
    uint64_t v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v15, v4, 0, v5);
  usb_deviceDeactivate(a1);
  io_object_t v8 = *(_DWORD *)(DerivedStorage + 276);
  if (v8)
  {
    IOObjectRelease(v8);
    *(_DWORD *)(DerivedStorage + 276) = 0;
  }
  if (*(void *)(DerivedStorage + 312))
  {
    (*(void (**)(void))(**(void **)(DerivedStorage + 296) + 192))(*(void *)(DerivedStorage + 296));
    *(void *)(DerivedStorage + 312) = 0;
  }
  if (*(void *)(DerivedStorage + 320))
  {
    (*(void (**)(void))(**(void **)(DerivedStorage + 296) + 192))(*(void *)(DerivedStorage + 296));
    *(void *)(DerivedStorage + 320) = 0;
  }
  if (*(unsigned char *)(DerivedStorage + 304))
  {
    (*(void (**)(void, void))(**(void **)(DerivedStorage + 296) + 40))(*(void *)(DerivedStorage + 296), 0);
    *(unsigned char *)(DerivedStorage + 304) = 0;
  }
  uint64_t v9 = *(void *)(DerivedStorage + 296);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
    *(void *)(DerivedStorage + 296) = 0;
  }
  char v10 = *(IOCFPlugInInterface ***)(DerivedStorage + 288);
  if (v10)
  {
    IODestroyPlugInInterface(v10);
    *(void *)(DerivedStorage + 288) = 0;
  }
  uint64_t result = *(unsigned int *)(DerivedStorage + 280);
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    *(_DWORD *)(DerivedStorage + 280) = 0;
  }
  return result;
}

void usb_deviceDeactivate(const void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v18[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v18, &type);
  int v4 = v18[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    v18[1] = 136315138;
    uint64_t v19 = "usb_deviceDeactivate";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v18[0];
  }
  else
  {
    uint64_t v7 = 0;
  }
  char v8 = 1;
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v20, v4, 0, v5);
  usb_setDisconnected(a1);
  uint64_t v9 = 0;
  do
  {
    char v10 = v8;
    uint64_t v11 = DerivedStorage + 24 * v9;
    unsigned int v12 = *(const void **)(v11 + 336);
    if (v12)
    {
      uint64_t v13 = (void *)(v11 + 336);
      CFRelease(v12);
      *uint64_t v13 = 0;
    }
    char v8 = 0;
    uint64_t v9 = 1;
  }
  while ((v10 & 1) != 0);
  uint64_t v14 = *(const void **)(DerivedStorage + 232);
  if (v14)
  {
    _Block_release(v14);
    *(void *)(DerivedStorage + 232) = 0;
  }
  char v15 = *(const void **)(DerivedStorage + 240);
  if (v15)
  {
    _Block_release(v15);
    *(void *)(DerivedStorage + 240) = 0;
  }
  uint64_t v16 = *(const void **)(DerivedStorage + 384);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(DerivedStorage + 384) = 0;
  }
  if (*(unsigned char *)(DerivedStorage + 305)) {
    *(unsigned char *)(DerivedStorage + 305) = 0;
  }
}

uint64_t __usb_deviceActivate_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, void, uint64_t, uint64_t (*)(uint64_t *, int, size_t)))(**(void **)(*(void *)(a1 + 32) + 296) + 160))(*(void *)(*(void *)(a1 + 32) + 296), *(void *)(*(void *)(a1 + 32) + 320), *(void *)(a2 + 8), 0x10000, usb_readCompleted);
}

uint64_t __usb_deviceActivate_block_invoke_2(uint64_t a1, int a2, char *__src, unint64_t a4, void *a5)
{
  if (a4)
  {
    unint64_t v7 = a4;
    uint64_t v9 = 0;
    while (1)
    {
      size_t v10 = v7 >= 0x10000 ? 0x10000 : v7;
      memcpy(*(void **)(*(void *)(a1 + 32) + 392), __src, v10);
      size_t v13 = v10;
      uint64_t result = (*(uint64_t (**)(void, void, void, size_t *))(**(void **)(*(void *)(a1 + 32) + 296)
                                                                           + 168))(*(void *)(*(void *)(a1 + 32) + 296), *(void *)(*(void *)(a1 + 32) + 312), *(void *)(*(void *)(a1 + 32) + 384), &v13);
      if (result) {
        break;
      }
      v9 += v13;
      v7 -= v13;
      __src += v13;
      if (v13 < v10 || v7 == 0)
      {
        uint64_t result = 0;
        break;
      }
    }
  }
  else
  {
    size_t v13 = 0;
    uint64_t result = (*(uint64_t (**)(void, void, void, size_t *))(**(void **)(*(void *)(a1 + 32) + 296)
                                                                         + 168))(*(void *)(*(void *)(a1 + 32) + 296), *(void *)(*(void *)(a1 + 32) + 312), *(void *)(*(void *)(a1 + 32) + 384), &v13);
    uint64_t v9 = 0;
  }
  *a5 = v9;
  return result;
}

void __usb_enqueuePackageWithPriority_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 24))
  {
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  else
  {
    uint64_t v3 = v2 + 8 * *(int *)(a1 + 56);
    unsigned int v6 = *(OpaqueCMBlockBuffer **)(v3 + 48);
    uint64_t v5 = (OpaqueCMBlockBuffer **)(v3 + 48);
    int v4 = v6;
    unint64_t v7 = *(OpaqueCMBlockBuffer **)(a1 + 40);
    if (v6)
    {
      CMBlockBufferAppendBufferReference(v4, v7, 0, 0, 0);
      CFRelease(*(CFTypeRef *)(a1 + 40));
    }
    else
    {
      *uint64_t v5 = v7;
    }
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 200));
  }
  char v8 = *(const void **)(a1 + 48);

  CFRelease(v8);
}

uint64_t FigXPCCreateBasicMessage(unsigned int a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
    unint64_t v7 = v6;
    if (v6)
    {
      xpc_dictionary_set_uint64(v6, ".Operation", a1);
      if (a2) {
        xpc_dictionary_set_uint64(v7, ".objectID", a2);
      }
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    unint64_t v7 = 0;
  }
  *a3 = v7;
  return result;
}

uint64_t FigXPCMessageGetOpCode(void *a1, _DWORD *a2)
{
  uint64_t int64 = xpc_dictionary_get_uint64(a1, ".Operation");
  if (!uint64) {
    return 4294951145;
  }
  uint64_t result = 0;
  *a2 = uint64;
  return result;
}

uint64_t FigXPCSendStdCopyPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  *(void *)unsigned int v12 = 0;
  CFTypeRef cf = 0;
  xpc_object_t v11 = 0;
  uint64_t v7 = FigXPCCreateBasicMessage(0x2E637079u, a2, v12);
  if (!v7)
  {
    char v8 = *(void **)v12;
    uint64_t v7 = FigXPCMessageSetCFString(*(void **)v12, ".PropertyName", a3);
    if (!v7)
    {
      uint64_t v7 = FigXPCRemoteClientSendSyncMessageCreatingReply(a1, (uint64_t)v8, &v11);
      if (!v7) {
        uint64_t v7 = FigXPCMessageCopyCFObject(v11, ".Value", (__CFDictionary **)&cf);
      }
    }
  }
  uint64_t v9 = v7;
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  FigXPCRelease(v11);
  FigXPCRelease(*(xpc_object_t *)v12);
  return v9;
}

uint64_t FigXPCRemoteClientSendSyncMessageCreatingReply(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  xpc_object_t object = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    if (!a3) {
      return v4;
    }
    goto LABEL_12;
  }
  uint64_t v4 = FigXPCConnectionSendSyncMessageCreatingReply(*(void *)(a1 + 24), a2, &object);
  xpc_object_t v5 = object;
  if (v4) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = a3 == 0;
  }
  if (v6 && object != 0)
  {
    xpc_object_t object = 0;
    xpc_release(v5);
  }
  if (a3) {
LABEL_12:
  }
    *a3 = object;
  return v4;
}

uint64_t FigXPCSendStdSetPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  *(void *)xpc_object_t v11 = 0;
  uint64_t v7 = FigXPCCreateBasicMessage(0x2E736574u, a2, v11);
  char v8 = *(void **)v11;
  if (!v7)
  {
    uint64_t v7 = FigXPCMessageSetCFString(*(void **)v11, ".PropertyName", a3);
    if (!v7)
    {
      uint64_t v7 = FigXPCMessageSetCFObject(v8, ".Value", a4);
      if (!v7) {
        uint64_t v7 = FigXPCRemoteClientSendSyncMessageCreatingReply(a1, (uint64_t)v8, 0);
      }
    }
  }
  uint64_t v9 = v7;
  FigXPCRelease(v8);
  return v9;
}

uint64_t FigXPCRemoteClientSendSyncMessage(uint64_t a1, uint64_t a2)
{
  return FigXPCRemoteClientSendSyncMessageCreatingReply(a1, a2, 0);
}

uint64_t FigXPCHandleStdCopyPropertyMessage(uint64_t a1, void *a2, void *a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v15 = 0;
  uint64_t v5 = FigXPCMessageCopyCFString(a2, ".PropertyName", &v15);
  if (v5) {
    goto LABEL_15;
  }
  CFTypeRef v6 = v15;
  if (!v15)
  {
    uint64_t v5 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
LABEL_15:
    uint64_t v12 = v5;
    goto LABEL_11;
  }
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, CFTypeRef, void, CFTypeRef *))(v8 + 48);
  if (v9)
  {
    uint64_t v10 = v9(a1, v6, *MEMORY[0x1E4F1CF80], &cf);
    CFTypeRef v11 = cf;
    if (!v10)
    {
      uint64_t v12 = FigXPCMessageSetCFObject(a3, ".Value", cf);
      CFTypeRef v11 = cf;
      if (!cf) {
        goto LABEL_11;
      }
      goto LABEL_9;
    }
    uint64_t v12 = v10;
    if (cf) {
LABEL_9:
    }
      CFRelease(v11);
  }
  else
  {
    uint64_t v12 = 4294954514;
  }
LABEL_11:
  if (v15) {
    CFRelease(v15);
  }
  return v12;
}

uint64_t FigXPCHandleStdSetPropertyMessage(uint64_t a1, void *a2)
{
  CFTypeRef cf = 0;
  CFTypeRef v13 = 0;
  uint64_t v4 = FigXPCMessageCopyCFString(a2, ".PropertyName", &v13);
  if (v4) {
    goto LABEL_9;
  }
  if (!v13)
  {
    uint64_t v4 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  uint64_t v4 = FigXPCMessageCopyCFObject(a2, ".Value", (__CFDictionary **)&cf);
  if (v4)
  {
LABEL_9:
    uint64_t v10 = v4;
    goto LABEL_11;
  }
  CFTypeRef v6 = cf;
  CFTypeRef v5 = v13;
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef))(v8 + 56);
  if (v9)
  {
    uint64_t v4 = v9(a1, v5, v6);
    goto LABEL_9;
  }
  uint64_t v10 = 4294954514;
LABEL_11:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v10;
}

uint64_t FigXPCConnectionSendSyncMessageWithNoTimeoutCreatingReply(uint64_t a1, xpc_object_t xdict, void *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 80))
    {
      uint64_t v8 = 4294951142;
      goto LABEL_10;
    }
    if (xdict)
    {
      uint64_t int64 = xpc_dictionary_get_uint64(xdict, ".Operation");
      if (uint64)
      {
        xpc_dictionary_set_uint64(xdict, ".Operation", uint64 | 0x200000000);
        return FigXPCConnectionSendSyncMessageCreatingReply(a1, xdict, a3);
      }
    }
  }
  uint64_t v8 = 4294951145;
LABEL_10:

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionSendSyncMessageCreatingReply(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = 0;
  unint64_t v6 = FigAtomicIncrement64(&FigXPCConnectionSendSyncMessageCreatingReply_sAbortActionID);
  if (!a1) {
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 80))
  {
    uint64_t v16 = 4294951142;
    goto LABEL_24;
  }
  if (!a2)
  {
LABEL_22:
    uint64_t v16 = 4294951145;
LABEL_24:
    uint64_t v13 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    xpc_object_t v12 = 0;
    goto LABEL_25;
  }
  int64_t v7 = v6;
  if (!*(unsigned char *)(a1 + 84))
  {
    xpc_dictionary_get_uint64(a2, ".Operation");
    if (gGMFigKTraceEnabled == 1)
    {
      uint64_t v8 = *(void *)(a1 + 16);
      uint64_t v9 = *(void *)(v8 + 16);
      if (v9)
      {
        size_t v10 = strlen(*(const char **)(v8 + 16));
        strncpy(__dst, (const char *)(v10 + v9 - 8), 8uLL);
      }
      kdebug_trace();
    }
    UpTimeNanoFloat64 seconds = FigGetUpTimeNanoseconds();
    xpc_dictionary_set_int64(a2, ".Date", UpTimeNanoseconds);
  }
  *(void *)__dst = v7;
  uint64_t v19 = a1;
  xpc_dictionary_set_int64(a2, ".AbortActionID", v7);
  FigThreadRegisterAbortAction((uint64_t (*)())figXPC_forwardThreadAbortForSyncMessage, (_opaque_pthread_t *)__dst, &v20);
  xpc_object_t v12 = xpc_connection_send_message_with_reply_sync(*(xpc_connection_t *)(a1 + 40), a2);
  uint64_t v13 = figXPCConnection_processServerReply(a1, v12);
  if (v20) {
    FigThreadUnregisterAbortAction(v20);
  }
  if (a3) {
    BOOL v14 = v13 == 0;
  }
  else {
    BOOL v14 = 0;
  }
  int v15 = !v14;
  if (!v12 || !v15)
  {
LABEL_25:
    if (a3) {
      goto LABEL_26;
    }
    return v13;
  }
  xpc_release(v12);
  if (a3)
  {
    xpc_object_t v12 = 0;
LABEL_26:
    *a3 = v12;
  }
  return v13;
}

void figXPC_forwardThreadAbortForSyncMessage(int64_t *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  xpc_object_t xdict = 0;
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1[1] + 24));
  if (v2)
  {
    uint64_t v3 = v2;
    if (v2[4])
    {
      int v4 = FigXPCCreateBasicMessage(0x2E737470u, 0, &xdict);
      xpc_object_t v5 = xdict;
      if (!v4)
      {
        xpc_dictionary_set_int64(xdict, ".AbortActionID", *a1);
        FigXPCConnectionSendAsyncMessage((uint64_t)v3[4], v5);
      }
    }
    else
    {
      int v13 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v13, &type);
      int v7 = v13;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v9 = v7;
      }
      else {
        unsigned int v9 = v7 & 0xFFFFFFFE;
      }
      if (v9)
      {
        uint64_t v10 = *((void *)v3[2] + 2);
        int v15 = 136315394;
        uint64_t v16 = "figXPC_forwardThreadAbortForSyncMessage";
        __int16 v17 = 2080;
        uint64_t v18 = v10;
        CFTypeRef v11 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v7) = v13;
      }
      else
      {
        CFTypeRef v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v11, v11 != &v19, v7, 0, v8);
      xpc_object_t v5 = 0;
    }
    FigXPCRelease(v5);
    CFRelease(v3);
  }
  else
  {
    FigXPCRelease(0);
  }
}

int64_t figXPCConnection_processServerReply(uint64_t a1, void *a2)
{
  v22[16] = *MEMORY[0x1E4F143B8];
  if (MEMORY[0x192FC6B30](a2) == MEMORY[0x1E4F14590])
  {
    if (*(unsigned char *)(a1 + 84)) {
      goto LABEL_12;
    }
    if (gGMFigKTraceEnabled == 1)
    {
      xpc_connection_get_pid(*(xpc_connection_t *)(a1 + 40));
      kdebug_trace();
    }
    if (!FigAtomicCompareAndSwap32(0, 1u, (atomic_uint *)(a1 + 92))) {
      goto LABEL_12;
    }
    int v4 = *(_DWORD *)(a1 + 88);
    *(unsigned char *)(a1 + 84) = 1;
    FigXPCConnectionGetServerPID(a1, (pid_t *)(a1 + 88));
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 16);
      if (*(void *)(v5 + 120)) {
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t int64 = xpc_dictionary_get_uint64(a2, ".ServerCapabilities");
      uint64_t v5 = *(void *)(a1 + 16);
      *(void *)(v5 + 120) = uint64;
      if (uint64) {
        goto LABEL_11;
      }
    }
    if (!*(unsigned char *)(a1 + 85))
    {
      if (!*(unsigned char *)(v5 + 105))
      {
        xpc_object_t value = xpc_dictionary_get_value(a2, ".ProcessStateMonitorEndpoint");
        if (value && (unsigned int v9 = value, MEMORY[0x192FC6B30]() == MEMORY[0x1E4F145A0]))
        {
          v22[0] = 0;
          int v10 = FigProcessStateMonitorCopyRemoteStateMonitor(v9, *(_DWORD *)(a1 + 88), *(_DWORD *)(*(void *)(a1 + 16) + 120) & 2, v22);
          if (!v10)
          {
            FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 96));
            CFTypeRef v11 = *(const void **)(a1 + 104);
            if (v11) {
              CFRelease(v11);
            }
            *(void *)(a1 + 104) = v22[0];
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 96));
          }
          if (!v10) {
            goto LABEL_12;
          }
        }
        else
        {
          int v10 = FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
          if (!v10) {
            goto LABEL_12;
          }
        }
        v18[0] = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v18, &type);
        int v13 = v18[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v15 = v13;
        }
        else {
          unsigned int v15 = v13 & 0xFFFFFFFE;
        }
        if (v15)
        {
          v18[1] = 136315394;
          char v19 = "figXPCConnection_handleServerLaunchOrRelaunch";
          __int16 v20 = 1024;
          int v21 = v10;
          uint64_t v16 = (uint64_t *)_os_log_send_and_compose_impl();
          LOBYTE(v13) = v18[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v16, v16 != v22, v13, 0, v14);
        FigAtomicCompareAndSwap32(1, 0, (atomic_uint *)(a1 + 92));
      }
LABEL_12:
      if (!*(void *)(a1 + 64)) {
        *(void *)(a1 + 64) = xpc_dictionary_get_int64(a2, ".Token");
      }
      return xpc_dictionary_get_int64(a2, ".ErrorReturn");
    }
LABEL_11:
    *(unsigned char *)(v5 + 105) = 1;
    goto LABEL_12;
  }

  return FigSignalErrorAt(4294951141, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionSendSyncMessage(uint64_t a1, void *a2)
{
  return FigXPCConnectionSendSyncMessageCreatingReply(a1, a2, 0);
}

uint64_t FigXPCConnectionSendAsyncMessage(uint64_t a1, xpc_object_t xdict)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 80))
    {
      uint64_t v10 = 4294951142;
      goto LABEL_14;
    }
    if (xdict)
    {
      uint64_t int64 = xpc_dictionary_get_uint64(xdict, ".Operation");
      if (uint64)
      {
        xpc_dictionary_set_uint64(xdict, ".Operation", uint64 | 0x100000000);
        if (!*(unsigned char *)(a1 + 84))
        {
          if (gGMFigKTraceEnabled == 1)
          {
            uint64_t v5 = *(void *)(a1 + 16);
            uint64_t v6 = *(void *)(v5 + 16);
            if (v6)
            {
              size_t v7 = strlen(*(const char **)(v5 + 16));
              strncpy(__dst, (const char *)(v7 + v6 - 8), 8uLL);
            }
            kdebug_trace();
          }
          UpTimeNanoFloat64 seconds = FigGetUpTimeNanoseconds();
          xpc_dictionary_set_int64(xdict, ".Date", UpTimeNanoseconds);
        }
        xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), xdict);
        return 0;
      }
    }
  }
  uint64_t v10 = 4294951145;
LABEL_14:

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionSendAsyncMessageWithReplyHandler(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 80))
    {
      uint64_t v13 = 4294951142;
      goto LABEL_14;
    }
    if (xdict && a3)
    {
      if (!*(unsigned char *)(a1 + 84))
      {
        xpc_dictionary_get_uint64(xdict, ".Operation");
        if (gGMFigKTraceEnabled == 1)
        {
          uint64_t v6 = *(void *)(a1 + 16);
          uint64_t v7 = *(void *)(v6 + 16);
          if (v7)
          {
            size_t v8 = strlen(*(const char **)(v6 + 16));
            strncpy(__dst, (const char *)(v8 + v7 - 8), 8uLL);
          }
          kdebug_trace();
        }
        UpTimeNanoFloat64 seconds = FigGetUpTimeNanoseconds();
        xpc_dictionary_set_int64(xdict, ".Date", UpTimeNanoseconds);
      }
      uint64_t v10 = *(_xpc_connection_s **)(a1 + 40);
      CFTypeRef v11 = *(NSObject **)(a1 + 72);
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 0x40000000;
      handler[2] = __FigXPCConnectionSendAsyncMessageWithReplyHandler_block_invoke;
      handler[3] = &unk_1E567EDC0;
      handler[4] = a3;
      void handler[5] = a1;
      xpc_connection_send_message_with_reply(v10, xdict, v11, handler);
      return 0;
    }
  }
  uint64_t v13 = 4294951145;
LABEL_14:

  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

uint64_t __FigXPCConnectionSendAsyncMessageWithReplyHandler_block_invoke(uint64_t a1, void *a2)
{
  figXPCConnection_processServerReply(*(void *)(a1 + 40), a2);
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v3();
}

uint64_t FigXPCConnectionSendAsyncMessageWithNoTimeoutWithReplyHandler(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 80))
    {
      uint64_t v8 = 4294951142;
      goto LABEL_11;
    }
    if (xdict)
    {
      if (a3)
      {
        uint64_t int64 = xpc_dictionary_get_uint64(xdict, ".Operation");
        if (uint64)
        {
          xpc_dictionary_set_uint64(xdict, ".Operation", uint64 | 0x200000000);
          return FigXPCConnectionSendAsyncMessageWithReplyHandler(a1, xdict, a3);
        }
      }
    }
  }
  uint64_t v8 = 4294951145;
LABEL_11:

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionSetCustomServerTimeoutPerConnection(uint64_t a1, int64_t a2)
{
  xpc_object_t xdict = 0;
  uint64_t v4 = FigXPCCreateBasicMessage(0x2E746F21u, 0, &xdict);
  xpc_object_t v5 = xdict;
  if (!v4)
  {
    xpc_dictionary_set_int64(xdict, ".SelfTerminationTimeout", a2);
    uint64_t v4 = FigXPCConnectionSendAsyncMessage(a1, v5);
  }
  uint64_t v6 = v4;
  FigXPCRelease(v5);
  return v6;
}

uint64_t FigXPCConnectionAssociateObject(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a1)
  {
    uint64_t result = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(void *)(a1 + 32), a2, (uint64_t)a3);
    if (!result)
    {
      uint64_t result = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(void *)(*(void *)(a1 + 16) + 112), a2, (uint64_t)a3);
      if (!result)
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 96));
        uint64_t v8 = *(void *)(a1 + 104);
        if (v8) {
          FigProcessStateMonitorRemoteAssociateObject(v8, a3);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 96));
        return 0;
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPCConnectionDisassociateObject(uint64_t a1, const void *a2)
{
  if (a1)
  {
    if (!a2) {
      return 0;
    }
    uint64_t result = FigCFWeakReferenceTableRemoveValue(*(void *)(a1 + 32), (uint64_t)a2);
    if (!result)
    {
      uint64_t result = FigCFWeakReferenceTableRemoveValue(*(void *)(*(void *)(a1 + 16) + 112), (uint64_t)a2);
      if (!result)
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 96));
        uint64_t v6 = *(void *)(a1 + 104);
        if (v6) {
          FigProcessStateMonitorRemoteDisassociateObject(v6, a2);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 96));
        return 0;
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPConnectionLookupAndRetainAssociatedObject(uint64_t a1, void *a2, void *a3)
{
  if (a1)
  {
    id v5 = FigCFWeakReferenceTableCopyValue(*(void *)(a1 + 32), a2);
    *a3 = v5;
    uint64_t v3 = vars8;
    if (v5) {
      return 0;
    }
    uint64_t v7 = 4294951144;
  }
  else
  {
    uint64_t v7 = 4294951145;
  }
  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionRetainCopiedObject(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v12 = 0;
  CFTypeRef cf = 0;
  uint64_t v14 = 0;
  if (a1)
  {
    unint64_t v12 = a2 & 0xFFFFFFFFFFFFFF00;
    uint64_t v6 = FigCFWeakReferenceTableApplyFunction(*(void *)(*(void *)(a1 + 16) + 112), (void (*)(void, CFTypeRef, uint64_t))figXPC_RetainCopiedObjectApplierFunction, (uint64_t)&v12);
    if (v6) {
      goto LABEL_8;
    }
    CFTypeRef v7 = cf;
    if (!cf || v14 == a2) {
      goto LABEL_7;
    }
    xpc_object_t xdict = 0;
    uint64_t v8 = FigXPCCreateBasicMessage(0x2E6E6370u, a2, &xdict);
    if (!v8)
    {
      xpc_object_t v9 = xdict;
      uint64_t v6 = FigXPCConnectionSendAsyncMessage(a1, xdict);
      FigXPCRelease(v9);
      CFTypeRef v7 = cf;
LABEL_7:
      *a3 = v7;
      CFTypeRef cf = 0;
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v6 = v8;
LABEL_8:
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t figXPC_RetainCopiedObjectApplierFunction(uint64_t result, CFTypeRef cf, void *a3)
{
  if (!a3[1])
  {
    uint64_t v4 = result;
    if (*a3 == (result & 0xFFFFFFFFFFFFFF00))
    {
      uint64_t result = (uint64_t)CFRetain(cf);
      a3[1] = result;
      a3[2] = v4;
    }
  }
  return result;
}

uint64_t FigXPCConnectionSendStdCopyPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  *(void *)unint64_t v12 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v11 = 0;
  uint64_t v7 = FigXPCCreateBasicMessage(0x2E637079u, a2, v12);
  if (!v7)
  {
    uint64_t v8 = *(void **)v12;
    uint64_t v7 = FigXPCMessageSetCFString(*(void **)v12, ".PropertyName", a3);
    if (!v7)
    {
      uint64_t v7 = FigXPCConnectionSendSyncMessageCreatingReply(a1, v8, &v11);
      if (!v7) {
        uint64_t v7 = FigXPCMessageCopyCFObject(v11, ".Value", (__CFDictionary **)&cf);
      }
    }
  }
  uint64_t v9 = v7;
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  FigXPCRelease(v11);
  FigXPCRelease(*(xpc_object_t *)v12);
  return v9;
}

uint64_t FigXPCConnectionSendStdSetPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  *(void *)CFTypeRef v11 = 0;
  uint64_t v7 = FigXPCCreateBasicMessage(0x2E736574u, a2, v11);
  uint64_t v8 = *(void **)v11;
  if (!v7)
  {
    uint64_t v7 = FigXPCMessageSetCFString(*(void **)v11, ".PropertyName", a3);
    if (!v7)
    {
      uint64_t v7 = FigXPCMessageSetCFObject(v8, ".Value", a4);
      if (!v7) {
        uint64_t v7 = FigXPCConnectionSendSyncMessageCreatingReply(a1, v8, 0);
      }
    }
  }
  uint64_t v9 = v7;
  FigXPCRelease(v8);
  return v9;
}

uint64_t FigXPCConnectionGetServerPID(uint64_t a1, pid_t *a2)
{
  pid_t pid = xpc_connection_get_pid(*(xpc_connection_t *)(a1 + 40));
  *a2 = pid;
  if (pid) {
    return 0;
  }

  return FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionCopyMemoryOriginForConnectedProcess(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 16) + 128));
  uint64_t v4 = *(const void **)(*(void *)(a1 + 16) + 136);
  if (v4)
  {
    id v5 = 0;
  }
  else
  {
    uint64_t v6 = FigXPCCreateBasicMessage(0x2E6F7267u, 0, &v10);
    id v5 = v10;
    if (v6
      || (uint64_t v6 = FigMemoryOriginBeginEstablishingMemoryRecipientByFillingInXPCMessage1(v10), v6)
      || (uint64_t v6 = FigXPCConnectionSendSyncMessageCreatingReply(a1, v5, &v9), v6)
      || (uint64_t v6 = FigMemoryOriginCompleteEstablishingMemoryRecipientUsingXPCMessage2(v9, (void *)(*(void *)(a1 + 16) + 136)), v6))
    {
      uint64_t v7 = v6;
      goto LABEL_9;
    }
    uint64_t v4 = *(const void **)(*(void *)(a1 + 16) + 136);
  }
  uint64_t v7 = 0;
  *a2 = CFRetain(v4);
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(void *)(a1 + 16) + 128));
  FigXPCRelease(v5);
  FigXPCRelease(v9);
  return v7;
}

uint64_t FigXPCConnectionCopyMemoryRecipientForConnectedProcess(uint64_t a1, CFTypeRef *a2)
{
  xpc_object_t v11 = 0;
  unint64_t v12 = 0;
  uint64_t v10 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 16) + 128));
  uint64_t v4 = *(const void **)(*(void *)(a1 + 16) + 144);
  if (v4)
  {
    id v5 = 0;
  }
  else
  {
    uint64_t updated = FigXPCCreateBasicMessage(0x2E727031u, 0, &v12);
    id v5 = v12;
    if (updated
      || (uint64_t updated = FigXPCConnectionSendSyncMessageCreatingReply(a1, v12, &v11), updated)
      || (uint64_t updated = FigXPCCreateBasicMessage(0x2E727032u, 0, &v10), updated)
      || (uint64_t v7 = v10,
          uint64_t updated = FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(v11, v10, *(const char **)(*(void *)(a1 + 16) + 16), (uint64_t **)(*(void *)(a1 + 16) + 144)), updated)|| (uint64_t updated = FigXPCConnectionSendSyncMessageCreatingReply(a1, v7, 0), updated))
    {
      uint64_t v8 = updated;
      goto LABEL_10;
    }
    uint64_t v4 = *(const void **)(*(void *)(a1 + 16) + 144);
  }
  uint64_t v8 = 0;
  *a2 = CFRetain(v4);
LABEL_10:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(void *)(a1 + 16) + 128));
  FigXPCRelease(v5);
  FigXPCRelease(v11);
  FigXPCRelease(v10);
  return v8;
}

uint64_t FigXPCConnectionCreateAssociatedEventLink(_DWORD *a1, uint64_t a2, unsigned int a3, int a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  CFTypeRef v21 = 0;
  xpc_object_t xdict = 0;
  CFTypeRef v19 = 0;
  __int16 v17 = 0;
  if (!a1)
  {
    uint64_t v16 = 4294951145;
LABEL_20:
    uint64_t v9 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_21:
    uint64_t v14 = v9;
    xpc_object_t v11 = 0;
    goto LABEL_9;
  }
  if (a1[20])
  {
    uint64_t v16 = 4294951142;
    goto LABEL_20;
  }
  uint64_t v9 = FigXPCConnectionCopyMemoryOriginForConnectedProcess((uint64_t)a1, &v21);
  if (v9) {
    goto LABEL_21;
  }
  uint64_t v9 = FigXPCConnectionCopyMemoryRecipientForConnectedProcess((uint64_t)a1, &cf);
  if (v9) {
    goto LABEL_21;
  }
  uint64_t v10 = FigXPCCreateBasicMessage(0x2E656C73u, 0, &xdict);
  xpc_object_t v11 = xdict;
  if (v10
    || (xpc_dictionary_set_uint64(xdict, "ServerEventLinkFigThreadPriority", a3),
        xpc_dictionary_set_int64(v11, "ServerEventLinkMachThreadPriority", a4),
        uint64_t v10 = FigXPCConnectionSendSyncMessageCreatingReply((uint64_t)a1, v11, &v17),
        v10))
  {
    uint64_t v14 = v10;
  }
  else
  {
    int v12 = CFGetAllocator(a1);
    CFTypeRef v13 = v21;
    uint64_t v14 = FigOSEventLinkRemoteCreateFromXPCObject(v12, v17, v21, cf, (uint64_t *)&v19);
    if (v14) {
      goto LABEL_10;
    }
    *a5 = v19;
    CFTypeRef v19 = 0;
  }
LABEL_9:
  CFTypeRef v13 = v21;
LABEL_10:
  FigXPCRelease(v11);
  FigXPCRelease(v17);
  if (v13) {
    CFRelease(v13);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v19) {
    CFRelease(v19);
  }
  return v14;
}

uint64_t FigXPCServerCreateAssociatedEventLinkForConnection(_xpc_connection_s *a1, int a2, const void *a3, const void *a4, uint64_t a5, unsigned int a6, int a7, CFTypeRef *a8)
{
  uint64_t v8 = a1;
  xpc_object_t xdict = 0;
  CFTypeRef cf = 0;
  if (a1)
  {
    uint64_t v15 = FigXPCCreateBasicMessage(0x2E656C63u, 0, &xdict);
    xpc_object_t v16 = xdict;
    if (v15)
    {
      uint64_t v17 = v15;
      uint64_t v8 = 0;
    }
    else
    {
      xpc_dictionary_set_uint64(xdict, "ServerEventLinkFigThreadPriority", a6);
      xpc_dictionary_set_int64(v16, "ServerEventLinkMachThreadPriority", a7);
      uint64_t v8 = (_xpc_connection_s *)xpc_connection_send_message_with_reply_sync(v8, v16);
      if (v8)
      {
        uint64_t v17 = FigOSEventLinkRemoteCreateFromXPCObject(a2, v8, a3, a4, (uint64_t *)&cf);
        if (!v17)
        {
          *a8 = cf;
          CFTypeRef cf = 0;
        }
      }
      else
      {
        uint64_t v17 = FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  else
  {
    uint64_t v17 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    xpc_object_t v16 = 0;
  }
  FigXPCRelease(v16);
  FigXPCRelease(v8);
  if (cf) {
    CFRelease(cf);
  }
  return v17;
}

uint64_t FigXPCRemoteClientSendSyncMessageWithNoTimeoutCreatingReply(uint64_t a1, void *a2, void *a3)
{
  if (a1 && a2) {
    return FigXPCConnectionSendSyncMessageWithNoTimeoutCreatingReply(*(void *)(a1 + 24), a2, a3);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCRemoteClientSendAsyncMessage(uint64_t a1, void *a2)
{
  if (a1 && a2) {
    return FigXPCConnectionSendAsyncMessage(*(void *)(a1 + 24), a2);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCRemoteClientSendAsyncMessageWithReplyHandler(uint64_t a1, void *a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return FigXPCConnectionSendAsyncMessageWithReplyHandler(*(void *)(a1 + 24), a2, a3);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCRemoteClientSendAsyncMessageWithNoTimeoutWithReplyHandler(uint64_t a1, void *a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return FigXPCConnectionSendAsyncMessageWithNoTimeoutWithReplyHandler(*(void *)(a1 + 24), a2, a3);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCRemoteClientDisassociateObject(uint64_t a1, const void *a2)
{
  if (!a1) {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  if (a2) {
    return FigXPCConnectionDisassociateObject(*(void *)(a1 + 24), a2);
  }
  return 0;
}

uint64_t FigXPCRemoteClientAssociateObject(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a1) {
    return FigXPCConnectionAssociateObject(*(void *)(a1 + 24), a2, a3);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCRemoteClientLookupAndRetainAssociatedObject(uint64_t a1, void *a2, void *a3)
{
  if (a1) {
    return FigXPConnectionLookupAndRetainAssociatedObject(*(void *)(a1 + 24), a2, a3);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCRemoteClientRetainCopiedObject(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1) {
    return FigXPCConnectionRetainCopiedObject(*(void *)(a1 + 24), a2, a3);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCRemoteClientCreate(uint64_t a1, unint64_t *a2, CFDictionaryRef theDict, void *a4)
{
  if (theDict) {
    uint64_t v8 = 2
  }
       * (CFDictionaryGetValue(theDict, @"xpcRemoteClientOption_PrivilegedConnection") == (const void *)*MEMORY[0x1E4F1CFD0]);
  else {
    uint64_t v8 = 0;
  }
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  int v10[2] = __FigXPCRemoteClientCreate_block_invoke;
  v10[3] = &__block_descriptor_tmp_80;
  void v10[4] = a1;
  v10[5] = v8;
  return FigXPCRemoteClientCreateWithConnectionCreatingBlock(a1, a2, theDict, 0, a4, (uint64_t)v10);
}

uint64_t FigXPCRemoteClientCreateWithConnectionCreatingBlock(uint64_t a1, unint64_t *a2, const void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  if (figXPC_RemoteClientOneTimeInitialization_sInitFigXPCRemoteClientOnce != -1) {
    dispatch_once(&figXPC_RemoteClientOneTimeInitialization_sInitFigXPCRemoteClientOnce, &__block_literal_global_92_0);
  }
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (figXPCRemoteClient_GetTypeID_sRegisterFigXPCRemoteClientTypeOnce != -1) {
    dispatch_once(&figXPCRemoteClient_GetTypeID_sRegisterFigXPCRemoteClientTypeOnce, &__block_literal_global_97_0);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v14 = (void *)Instance;
    if (*a2 - 1 > 3)
    {
      uint64_t v20 = 4294951145;
    }
    else
    {
      if (figXPCClientConnectionInfo_GetTypeID_sRegisterFigXPCClientConnectionInfoTypeOnce != -1) {
        dispatch_once(&figXPCClientConnectionInfo_GetTypeID_sRegisterFigXPCClientConnectionInfoTypeOnce, &__block_literal_global_104);
      }
      uint64_t v15 = _CFRuntimeCreateInstance();
      if (v15)
      {
        uint64_t v16 = v15;
        uint64_t v17 = FigCFWeakReferenceTableCreate(v12, 1, (uint64_t *)(v15 + 112));
        if (v17)
        {
          uint64_t v22 = v17;
          goto LABEL_34;
        }
        if (a3)
        {
          CFDictionaryRef v18 = (const __CFDictionary *)CFRetain(a3);
          CFTypeRef v19 = @"SomeServerDiedSomewhere";
          *(void *)(v16 + 96) = @"SomeServerDiedSomewhere";
          *(void *)(v16 + 88) = v18;
          *(void *)(v16 + 16) = a1;
          if (v18)
          {
            CFDictionaryGetValueIfPresent(v18, @"xpcRemoteClientOption_DeathNoticeName", (const void **)(v16 + 96));
            FigCFDictionaryGetBooleanIfPresent(*(void *)(v16 + 88), @"xpcRemoteClientOption_FilterHandlesNotificationsForUnknownObjects", (Boolean *)(v16 + 104));
            FigCFDictionaryGetBooleanIfPresent(*(void *)(v16 + 88), @"xpcRemoteClientOption_DoNotMonitorConnection", (Boolean *)(v16 + 105));
            CFTypeRef v19 = *(__CFString **)(v16 + 96);
            if (!v19)
            {
LABEL_20:
              *(void *)(v16 + 128) = FigSimpleMutexCreate();
              *(void *)(v16 + 24) = *a2;
              *(void *)(v16 + 32) = a2[1];
              *(void *)(v16 + 40) = a2[2];
              *(void *)(v16 + 48) = a2[3];
              *(void *)(v16 + 56) = a2[4];
              unint64_t v23 = *a2;
              if (*a2 >= 2)
              {
                *(void *)(v16 + 64) = a2[5];
                if (v23 >= 3)
                {
                  *(void *)(v16 + 72) = a2[6];
                  if (v23 >= 4) {
                    *(void *)(v16 + 80) = a2[7];
                  }
                }
              }
LABEL_24:
              int v14[2] = v16;
              uint64_t v22 = figXPCCreateXPCConnectionInternal((uint64_t)v14, v16, a4, (uint64_t *)&cf, a6);
              uint64_t v16 = (uint64_t)cf;
              if (!v22)
              {
                v14[3] = cf;
                CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
                FigNotificationCenterAddWeakListener(DefaultLocalCenter, v14, (CFNotificationCallback)figXPCRemoteClient_PrimaryConnectionNotificationCallback, 0, v14[3], 0, 0);
                *a5 = v14;
                return v22;
              }
              if (!cf)
              {
LABEL_35:
                CFRelease(v14);
                return v22;
              }
LABEL_34:
              CFRelease((CFTypeRef)v16);
              goto LABEL_35;
            }
          }
        }
        else
        {
          *(void *)(v16 + 16) = a1;
          CFTypeRef v19 = @"SomeServerDiedSomewhere";
          *(void *)(v16 + 88) = 0;
          *(void *)(v16 + 96) = @"SomeServerDiedSomewhere";
        }
        CFRetain(v19);
        goto LABEL_20;
      }
      uint64_t v20 = 4294951146;
    }
    uint64_t v21 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    uint64_t v16 = 0;
    if (v21)
    {
      uint64_t v22 = v21;
      goto LABEL_35;
    }
    goto LABEL_24;
  }

  return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
}

xpc_connection_t __FigXPCRemoteClientCreate_block_invoke(uint64_t a1, NSObject *a2)
{
  return xpc_connection_create_mach_service(*(const char **)(a1 + 32), a2, *(void *)(a1 + 40));
}

uint64_t FigXPCRemoteClientCreateWithXPCService(uint64_t a1, unint64_t *a2, const void *a3, void *a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __FigXPCRemoteClientCreateWithXPCService_block_invoke;
  v5[3] = &__block_descriptor_tmp_81;
  void v5[4] = a1;
  return FigXPCRemoteClientCreateWithConnectionCreatingBlock(a1, a2, a3, 0x400000000, a4, (uint64_t)v5);
}

xpc_connection_t __FigXPCRemoteClientCreateWithXPCService_block_invoke(uint64_t a1, NSObject *a2)
{
  return xpc_connection_create(*(const char **)(a1 + 32), a2);
}

uint64_t FigXPCRemoteClientCreateWithXPCEndpoint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  int v6[2] = __FigXPCRemoteClientCreateWithXPCEndpoint_block_invoke;
  v6[3] = &__block_descriptor_tmp_82;
  v6[4] = a2;
  return FigXPCRemoteClientCreateWithConnectionCreatingBlock(a1, a3, a4, 0x400000000, a5, v6);
}

_xpc_connection_s *__FigXPCRemoteClientCreateWithXPCEndpoint_block_invoke(uint64_t a1, NSObject *a2)
{
  uint64_t v3 = xpc_connection_create_from_endpoint(*(xpc_endpoint_t *)(a1 + 32));
  xpc_connection_set_target_queue(v3, a2);
  return v3;
}

void FigXPCRemoteClientDispose(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigXPCRemoteClientGetServerPID(uint64_t a1, _DWORD *a2)
{
  if (!a1) {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *(_DWORD *)(*(void *)(a1 + 24) + 88);
  return 0;
}

uint64_t FigXPCRemoteClientCopyMemoryOrigin(uint64_t a1, CFTypeRef *a2)
{
  return FigXPCConnectionCopyMemoryOriginForConnectedProcess(*(void *)(a1 + 24), a2);
}

uint64_t FigXPCRemoteClientCopyMemoryRecipient(uint64_t a1, CFTypeRef *a2)
{
  return FigXPCConnectionCopyMemoryRecipientForConnectedProcess(*(void *)(a1 + 24), a2);
}

uint64_t FigXPCRemoteClientCopyPrimaryConnection(uint64_t a1, CFTypeRef *a2)
{
  if (a1)
  {
    uint64_t v2 = *(_DWORD **)(a1 + 24);
    if (v2 && !v2[20])
    {
      *a2 = CFRetain(v2);
      return 0;
    }
    uint64_t v4 = 4294951142;
  }
  else
  {
    uint64_t v4 = 4294951145;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientCreateSecondaryConnection(uint64_t a1, unsigned int a2, uint64_t a3, void *a4)
{
  CFTypeRef v9 = 0;
  uint64_t v5 = *(void *)(a1 + 16);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  int v8[2] = __FigXPCRemoteClientCreateSecondaryConnection_block_invoke;
  v8[3] = &__block_descriptor_tmp_83_0;
  v8[4] = a1;
  uint64_t v6 = figXPCCreateXPCConnectionInternal(a1, v5, a2 | 0x600000000, (uint64_t *)&v9, (uint64_t)v8);
  if (v6)
  {
    if (v9) {
      CFRelease(v9);
    }
  }
  else
  {
    *a4 = v9;
  }
  return v6;
}

uint64_t figXPCCreateXPCConnectionInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v33 = 0;
  CFAllocatorRef v34 = 0;
  unsigned int v32 = 0;
  unsigned int v30 = -1;
  int v31 = 0;
  uint64_t v10 = *(void *)(a2 + 88);
  if (v10) {
    FigCFDictionaryGetInt32IfPresent(v10, @"xpcRemoteClientOption_QueuePriority", &v30);
  }
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (figXPCConnection_GetTypeID_sRegisterFigXPCConnectionTypeOnce != -1) {
    dispatch_once(&figXPCConnection_GetTypeID_sRegisterFigXPCConnectionTypeOnce, &__block_literal_global_118);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v13 = Instance;
  if (!a1)
  {
    uint64_t v26 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    if (!v13) {
      goto LABEL_26;
    }
    goto LABEL_34;
  }
  if (!Instance)
  {
    uint64_t v26 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  *(void *)(Instance + 16) = CFRetain((CFTypeRef)a2);
  *(unsigned char *)(v13 + 86) = (a3 & 0x400000000) != 0;
  CFTypeRef v14 = FigCFWeakReferenceHolderCreateWithReferencedObject(a1);
  *(void *)(v13 + 24) = v14;
  if (!v14) {
    goto LABEL_27;
  }
  uint64_t v15 = FigSimpleMutexCreate();
  *(void *)(v13 + 96) = v15;
  if (!v15) {
    goto LABEL_27;
  }
  uint64_t v16 = FigCFWeakReferenceTableCreate(v11, 1, (uint64_t *)(v13 + 32));
  if (v16)
  {
LABEL_33:
    uint64_t v26 = v16;
LABEL_34:
    CFRelease((CFTypeRef)v13);
    goto LABEL_26;
  }
  if ((a3 & 0x200000000) != 0)
  {
    *(unsigned char *)(v13 + 85) = 1;
    asprintf(&v34, "%s.secondary.%p.notifications", *(const char **)(a2 + 16), (const void *)v13);
    asprintf(&v33, "%s.secondary.%p.connection", *(const char **)(a2 + 16), (const void *)v13);
    asprintf(&v32, "%s.secondary.%p.clientMessages");
  }
  else
  {
    asprintf(&v34, "%s.notifications", *(const char **)(a2 + 16));
    asprintf(&v33, "%s.connections", *(const char **)(a2 + 16));
    asprintf(&v32, "%s.clientMessages");
  }
  *(void *)(v13 + 56) = figXPC_CreateSerialDispatchQueueWithPriority(v34, v30);
  SerialDispatchQueueWithPrioritdouble y = figXPC_CreateSerialDispatchQueueWithPriority(v33, v30);
  *(void *)(v13 + 48) = SerialDispatchQueueWithPriority;
  CFDictionaryRef v18 = (_xpc_connection_s *)(*(uint64_t (**)(uint64_t, NSObject *))(a5 + 16))(a5, SerialDispatchQueueWithPriority);
  if (!v18)
  {
    uint64_t v28 = 4294951143;
    goto LABEL_32;
  }
  CFTypeRef v19 = v18;
  *(void *)(v13 + 40) = v18;
  xpc_connection_set_target_queue(v18, *(dispatch_queue_t *)(v13 + 48));
  uint64_t v20 = *(void **)(v13 + 16);
  if (v20[6] || v20[3] >= 2uLL && v20[8]) {
    *(void *)(v13 + 72) = figXPC_CreateSerialDispatchQueueWithPriority(v32, v30);
  }
  uint64_t v21 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v13);
  if (!v21)
  {
LABEL_27:
    uint64_t v28 = 4294951146;
LABEL_32:
    uint64_t v16 = FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  xpc_connection_set_context(v19, v21);
  xpc_connection_set_finalizer_f(v19, (xpc_finalizer_t)figXPC_ServerConnectionFinalizer);
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 0x40000000;
  handler[2] = __figXPCCreateXPCConnectionInternal_block_invoke;
  handler[3] = &__block_descriptor_tmp_114;
  handler[4] = v19;
  xpc_connection_set_event_handler(v19, handler);
  if (FigCFDictionaryGetInt32IfPresent(*(void *)(*(void *)(v13 + 16) + 88), @"xpcRemoteClientOption_UserID", &v31))xpc_connection_set_target_uid(); {
  xpc_connection_activate(*(xpc_connection_t *)(v13 + 40));
  }
  xpc_object_t v35 = 0;
  xpc_object_t xdict = 0;
  memset(buffer, 0, sizeof(buffer));
  BOOL IsServerProcess = FigServer_IsServerProcess();
  uint64_t v23 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &xdict);
  if (v23)
  {
    uint64_t v26 = v23;
    xpc_object_t v25 = xdict;
  }
  else
  {
    pid_t v24 = getpid();
    proc_name(v24, buffer, 0x80u);
    xpc_object_t v25 = xdict;
    xpc_dictionary_set_string(xdict, ".ProcessName", (const char *)buffer);
    xpc_dictionary_set_BOOL(v25, ".IsDaemon", IsServerProcess);
    uint64_t v26 = FigXPCConnectionSendSyncMessageCreatingReply(v13, v25, &v35);
    if (!v26) {
      *(void *)(v13 + 64) = xpc_dictionary_get_int64(v35, ".Token");
    }
  }
  FigXPCRelease(v25);
  FigXPCRelease(v35);
  if (v26) {
    goto LABEL_34;
  }
  *a4 = v13;
LABEL_26:
  free(v34);
  free(v33);
  free(v32);
  return v26;
}

xpc_connection_t __FigXPCRemoteClientCreateSecondaryConnection_block_invoke(uint64_t a1)
{
  xpc_object_t xdict = 0;
  CFTypeRef v9 = 0;
  int v2 = FigXPCCreateBasicMessage(0x2E326E64u, 0, &v9);
  uint64_t v3 = v9;
  if (v2 || FigXPCRemoteClientSendSyncMessageCreatingReply(*(void *)(a1 + 32), (uint64_t)v9, &xdict)) {
    goto LABEL_8;
  }
  xpc_object_t value = (_xpc_endpoint_s *)xpc_dictionary_get_value(xdict, ".SecondaryEndpoint");
  if (!value
    || (uint64_t v5 = value, MEMORY[0x192FC6B30]() != MEMORY[0x1E4F145A0])
    || (xpc_connection_t v6 = xpc_connection_create_from_endpoint(v5)) == 0)
  {
    FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
LABEL_8:
    xpc_connection_t v6 = 0;
  }
  FigXPCRelease(v3);
  FigXPCRelease(xdict);
  return v6;
}

BOOL FigXPCIsObjectIDLocallyServed(uint64_t a1, uint64_t a2)
{
  if (a1) {
    return (a2 & 0xFFFFFF0000000000) == *(void *)(a1 + 8);
  }
  FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigXPCServerCopyMemoryOrigin(_xpc_connection_s *a1, CFTypeRef *a2)
{
  uint64_t context = (id *)xpc_connection_get_context(a1);
  uint64_t v4 = FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v4)
  {
    uint64_t v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1) {
      dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_139);
    }
    if (v6 == figXPCPerProcessInfo_GetTypeID_sPerProcessInfoTypeID)
    {
      uint64_t v7 = (const void *)v5[8];
      if (v7)
      {
        uint64_t v8 = 0;
        *a2 = CFRetain(v7);
LABEL_7:
        CFRelease(v5);
        return v8;
      }
      uint64_t v10 = 4294951137;
    }
    else
    {
      uint64_t v10 = 4294951142;
    }
    uint64_t v8 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }

  return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerCopyMemoryRecipient(_xpc_connection_s *a1, CFTypeRef *a2)
{
  uint64_t context = (id *)xpc_connection_get_context(a1);
  uint64_t v4 = FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v4)
  {
    uint64_t v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1) {
      dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_139);
    }
    if (v6 == figXPCPerProcessInfo_GetTypeID_sPerProcessInfoTypeID)
    {
      uint64_t v7 = (const void *)v5[9];
      if (v7)
      {
        uint64_t v8 = 0;
        *a2 = CFRetain(v7);
LABEL_7:
        CFRelease(v5);
        return v8;
      }
      uint64_t v10 = 4294951137;
    }
    else
    {
      uint64_t v10 = 4294951142;
    }
    uint64_t v8 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }

  return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerDisassociateObjectWithConnection(_xpc_connection_s *a1, uint64_t a2)
{
  uint64_t context = (id *)xpc_connection_get_context(a1);
  id v4 = FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v4)
  {
    uint64_t v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1) {
      dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_139);
    }
    if (v6 == figXPCPerProcessInfo_GetTypeID_sPerProcessInfoTypeID)
    {
      figXPCServer_DisassociateObjectWithPerProcessInfo((uint64_t)v5, a2);
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v5);
    return v7;
  }
  else
  {
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figXPCServer_DisassociateObjectWithPerProcessInfo(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    FigSimpleMutexLock(*(pthread_mutex_t **)(result + 80));
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v3 + 88));
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      while (1)
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 88), v6);
        if (ValueAtIndex[3] == a2) {
          break;
        }
        if (v5 == ++v6) {
          goto LABEL_9;
        }
      }
      uint64_t v8 = ValueAtIndex;
      figXPC_ForgetNotificationsForServedObject(*(void *)(v3 + 112), ValueAtIndex);
      FigCFWeakReferenceTableRemoveValue(*(void *)(v3 + 48), v8[3]);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 88), v6);
    }
LABEL_9:
    CFTypeRef v9 = *(pthread_mutex_t **)(v3 + 80);
    return FigSimpleMutexUnlock(v9);
  }
  return result;
}

uint64_t FigXPCServerAssociateObjectWithConnectionWithFlags(_xpc_connection_s *a1, const void *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7)
{
  uint64_t context = (id *)xpc_connection_get_context(a1);
  uint64_t v15 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v15)
  {
    uint64_t v16 = v15;
    FigSimpleMutexLock(v15[10]);
    uint64_t v17 = figXPC_RegisterServedObject((uint64_t)v16, a1, a2, a3, a4, a5, a6, a7);
    FigSimpleMutexUnlock(v16[10]);
    CFRelease(v16);
    return v17;
  }
  else
  {
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figXPC_RegisterServedObject(uint64_t a1, void *a2, const void *a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t *a8)
{
  if (a1 && a3)
  {
    unint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8) | ((unint64_t)FigAtomicIncrement32((atomic_uint *)(*(void *)(a1 + 56) + 20)) << 8) | 1;
    uint64_t result = figXPC_RegisterServedObjectWithID(a1, a2, a3, a4, a5, a6, a7, v16);
    if (!result) {
      *a8 = v16;
    }
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPCServerAssociateObjectWithConnection(_xpc_connection_s *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  return FigXPCServerAssociateObjectWithConnectionWithFlags(a1, a2, 0, a3, a4, a5, a6);
}

uint64_t FigXPCServerAssociateCopiedObjectWithConnection(_xpc_connection_s *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  uint64_t context = (id *)xpc_connection_get_context(a1);
  uint64_t v13 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v13)
  {
    CFTypeRef v14 = v13;
    FigSimpleMutexLock(v13[10]);
    uint64_t v15 = figXPC_RegisterCopiedObject((uint64_t)v14, a1, a2, a3, a4, a5, a6);
    FigSimpleMutexUnlock(v14[10]);
    CFRelease(v14);
    return v15;
  }
  else
  {
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figXPC_RegisterCopiedObject(uint64_t a1, void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  unint64_t v13 = 0;
  unsigned __int8 v14 = 2;
  while (2)
  {
    if (Count >= 1)
    {
      int v15 = 0;
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), i);
        if ((const void *)ValueAtIndex[2] == a3 && (void *)ValueAtIndex[7] == a2)
        {
          uint64_t v18 = ValueAtIndex[3];
          unint64_t v13 = v18 & 0xFFFFFFFFFFFFFF00;
          __int16 v19 = v14;
          if (v14 == v18)
          {
            ++v14;
            if (((v19 + 1) & 0x100) != 0)
            {
              return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
            }
            int v15 = 1;
          }
        }
      }
      if (v15) {
        continue;
      }
    }
    break;
  }
  if (v13)
  {
    uint64_t result = figXPC_RegisterServedObjectWithID(a1, a2, a3, 0, a4, a5, a6, v13 | v14);
    *a7 = v13 | v14;
  }
  else
  {
    return figXPC_RegisterServedObject(a1, a2, a3, 0, a4, a5, a6, a7);
  }
  return result;
}

uint64_t FigXPCServerFindUniqueObjectIDForObjectAssociatedWithConnection(_xpc_connection_s *a1, uint64_t a2, void *a3)
{
  uint64_t context = (id *)xpc_connection_get_context(a1);
  uint64_t v7 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v7)
  {
    uint64_t v8 = v7;
    FigSimpleMutexLock(v7[10]);
    CFIndex Count = CFArrayGetCount((CFArrayRef)v8[11]);
    if (Count < 1) {
      goto LABEL_11;
    }
    CFIndex v10 = Count;
    uint64_t v11 = 0;
    for (CFIndex i = 0; i != v10; ++i)
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)v8[11], i);
      if (ValueAtIndex[2] == a2 && (_xpc_connection_s *)ValueAtIndex[7] == a1)
      {
        if (v11) {
          goto LABEL_11;
        }
        uint64_t v11 = ValueAtIndex[3];
      }
    }
    if (v11)
    {
      uint64_t v14 = 0;
      *a3 = v11;
    }
    else
    {
LABEL_11:
      uint64_t v14 = FigSignalErrorAt(4294948085, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(v8[10]);
    CFRelease(v8);
    return v14;
  }
  else
  {
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerLookupAndRetainAssociatedObject(_xpc_connection_s *a1, uint64_t a2, void *a3, void *a4)
{
  return _figXPCServerLookupAndRetainAssociatedObject(a1, a2, 0, a3, a4);
}

uint64_t _figXPCServerLookupAndRetainAssociatedObject(_xpc_connection_s *a1, uint64_t a2, int a3, void *a4, void *a5)
{
  uint64_t context = (id *)xpc_connection_get_context(a1);
  CFIndex v10 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v10)
  {
    uint64_t v11 = v10;
    FigSimpleMutexLock(v10[10]);
    CFIndex Count = CFArrayGetCount((CFArrayRef)v11[11]);
    if (Count < 1)
    {
LABEL_6:
      FigSimpleMutexUnlock(v11[10]);
    }
    else
    {
      CFIndex v13 = Count;
      CFIndex v14 = 0;
      while (1)
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)v11[11], v14);
        if (ValueAtIndex[3] == a2) {
          break;
        }
        if (v13 == ++v14) {
          goto LABEL_6;
        }
      }
      __int16 v19 = CFRetain(ValueAtIndex);
      FigSimpleMutexUnlock(v11[10]);
      if (v19)
      {
        CFTypeRef v20 = (CFTypeRef)v19[2];
        if (v20) {
          CFTypeRef v20 = CFRetain(v20);
        }
        *a4 = v20;
        if (a5)
        {
          if (a3)
          {
            uint64_t v21 = (const void *)v19[4];
            if (v21) {
              CFRetain(v21);
            }
          }
          *a5 = v19[4];
        }
        CFRelease(v19);
        uint64_t v17 = 0;
        goto LABEL_11;
      }
    }
    FigSimpleMutexLock(v11[10]);
    if ((a2 & 0xFFFFFFFFFFFFFF00) >= ((unint64_t)v11[12] & 0xFFFFFFFFFFFFFF00)) {
      uint64_t v16 = 4294951144;
    }
    else {
      uint64_t v16 = 4294948086;
    }
    FigSimpleMutexUnlock(v11[10]);
    uint64_t v17 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_11:
    CFRelease(v11);
    return v17;
  }

  return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerLookupAndRetainAssociatedObjectAndCFTypeRefcon(_xpc_connection_s *a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    return _figXPCServerLookupAndRetainAssociatedObject(a1, a2, 1, a3, a4);
  }
  else {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerRetainNeighborObjectFromID(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v4 = 4294951145;
  if (a1 && a3)
  {
    id v6 = FigCFWeakReferenceTableCopyValue(*a1, a2);
    *a3 = v6;
    if (v6) {
      return 0;
    }
    uint64_t v4 = 4294951144;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerRetainNeighborObjectFromIDWithProcessID(uint64_t a1, int a2, void *a3, void *a4)
{
  if (a1 && a4)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    CFIndex v14 = 0;
    uint64_t v8 = figXPC_CopyInfoForProcess(a1, a2, &v14);
    if (v8)
    {
      uint64_t v9 = v8;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      return v9;
    }
    CFIndex v10 = v14;
    id v11 = FigCFWeakReferenceTableCopyValue(v14[6], a3);
    CFRelease(v10);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    if (v11)
    {
      uint64_t v9 = 0;
      *a4 = v11;
      return v9;
    }
    uint64_t v13 = 4294951144;
  }
  else
  {
    uint64_t v13 = 4294951145;
  }

  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

uint64_t figXPC_CopyInfoForProcess(uint64_t a1, int a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uintptr_t v6 = a2;
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), (const void *)a2);
  if (Value)
  {
    uint64_t v8 = CFRetain(Value);
    if (v8) {
      goto LABEL_26;
    }
  }
  uint64_t v27 = 0;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1) {
    dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_139);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = (void *)Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = a2;
    asprintf(&v27, "%s(%d)-messages", *(const char **)(a1 + 88), a2);
    id v11 = FigDispatchQueueCreateWithPriority(v27, 0, *(_DWORD *)(a1 + 120));
    v8[3] = v11;
    FigThreadMakeDispatchQueueAbortable(v11);
    CFAllocatorRef v12 = FigSimpleMutexCreate();
    v8[10] = v12;
    if (v12 && (CFMutableArrayRef v13 = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]), (v8[11] = v13) != 0))
    {
      if (*(unsigned char *)(a1 + 124))
      {
        CFTypeRef v14 = *(CFTypeRef *)a1;
        if (*(void *)a1) {
          CFTypeRef v14 = CFRetain(v14);
        }
        void v8[6] = v14;
      }
      else
      {
        FigCFWeakReferenceTableCreate(v9, 1, v8 + 6);
      }
      v8[7] = a1;
      *((_DWORD *)v8 + 42) = 0;
      v8[20] = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v15 = *(const char **)(v8[7] + 88);
      uint64_t v16 = *((unsigned int *)v8 + 4);
      CFTypeRef cf = 0;
      label[0] = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long handler = 0u;
      if (figXPCEnqueuedNotifications_GetTypeID_sRegisterEnqueuedNotificationsTypeOnce != -1) {
        dispatch_once(&figXPCEnqueuedNotifications_GetTypeID_sRegisterEnqueuedNotificationsTypeOnce, &__block_literal_global_152);
      }
      uint64_t v17 = _CFRuntimeCreateInstance();
      if (v17)
      {
        uint64_t v18 = v17;
        FigServer_CopyProcessName(v16, (CFStringRef *)&cf);
        CStringPtrMaybeUsingPreallocatedBuffer = FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)cf, (char *)&handler, 128, 0x600u);
        asprintf(label, "%s(%s-%d)-drainNotifications", v15, CStringPtrMaybeUsingPreallocatedBuffer, v16);
        snprintf((char *)(v18 + 16), 0x80uLL, "%s-%d", v15, v16);
        CFTypeRef v20 = FigSimpleMutexCreate();
        *(void *)(v18 + 152) = v20;
        if (v20
          && (CFMutableArrayRef Mutable = CFArrayCreateMutable(v9, 0, 0), (*(void *)(v18 + 160) = Mutable) != 0)
          && (dispatch_queue_t v22 = dispatch_queue_create(label[0], 0), (*(void *)(v18 + 144) = v22) != 0))
        {
          uint64_t v23 = 0;
          *(void *)(v18 + 168) = 0;
          v8[14] = v18;
        }
        else
        {
          uint64_t v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
          CFRelease((CFTypeRef)v18);
        }
      }
      else
      {
        uint64_t v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
      }
      if (cf) {
        CFRelease(cf);
      }
      free(label[0]);
      if (!v23)
      {
        pid_t v24 = v27;
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
    }
    free(v27);
    CFRelease(v8);
    uint64_t v8 = 0;
    if (v23) {
      return v23;
    }
    goto LABEL_25;
  }
  uint64_t v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
  pid_t v24 = 0;
LABEL_24:
  free(v24);
  if (!v23)
  {
LABEL_25:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), (const void *)v6, v8);
    xpc_object_t v25 = dispatch_source_create(MEMORY[0x1E4F14470], v6, 0x80000000uLL, (dispatch_queue_t)gCommonServerTimeoutQueue);
    *(void *)&long long handler = MEMORY[0x1E4F143A8];
    *((void *)&handler + 1) = 0x40000000;
    *(void *)&long long v31 = __figXPC_StartListeningForClientProcessDeath_block_invoke;
    *((void *)&v31 + 1) = &__block_descriptor_tmp_153;
    *(void *)&long long v32 = a1;
    DWORD2(v32) = a2;
    dispatch_source_set_event_handler(v25, &handler);
    label[0] = (char *)MEMORY[0x1E4F143A8];
    label[1] = (char *)0x40000000;
    label[2] = (char *)__figXPC_StartListeningForClientProcessDeath_block_invoke_2;
    label[3] = (char *)&__block_descriptor_tmp_154;
    label[4] = (char *)v25;
    dispatch_source_set_cancel_handler(v25, label);
    v8[13] = v25;
    dispatch_resume(v25);
LABEL_26:
    uint64_t v23 = 0;
    *a3 = v8;
  }
  return v23;
}

uint64_t FigXPCServerRetainNeighborObjectFromIDWithConnection(uint64_t a1, xpc_connection_t connection, void *a3, void *a4)
{
  pid_t pid = xpc_connection_get_pid(connection);

  return FigXPCServerRetainNeighborObjectFromIDWithProcessID(a1, pid, a3, a4);
}

uint64_t FigXPCServerAssociateObjectWithNeighborProcess(uint64_t a1, xpc_connection_t connection, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  unint64_t v19 = 0;
  if (a1 && a7)
  {
    pid_t pid = xpc_connection_get_pid(connection);
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    uint64_t v18 = 0;
    uint64_t v14 = figXPC_CopyInfoForProcess(a1, pid, &v18);
    if (v14)
    {
      uint64_t v15 = v14;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    }
    else
    {
      uint64_t v16 = v18;
      FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
      uint64_t v15 = figXPC_RegisterServedObject(v16, *(void **)(v16 + 32), a3, 0, a4, a5, a6, &v19);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
      CFRelease((CFTypeRef)v16);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      if (!v15) {
        *a7 = v19;
      }
    }
    return v15;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerAssociateObjectWithNeighborProcessByPID(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  unint64_t v19 = 0;
  if (a1 && a7)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    uint64_t v18 = 0;
    uint64_t v14 = figXPC_CopyInfoForProcess(a1, a2, &v18);
    if (v14)
    {
      uint64_t v15 = v14;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    }
    else
    {
      uint64_t v16 = v18;
      FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
      uint64_t v15 = figXPC_RegisterServedObject(v16, *(void **)(v16 + 32), a3, 0, a4, a5, a6, &v19);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
      CFRelease((CFTypeRef)v16);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      if (!v15) {
        *a7 = v19;
      }
    }
    return v15;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerDisassociateObjectWithNeighborClientPID(uint64_t a1, int a2, uint64_t a3)
{
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    CFTypeRef cf = 0;
    uint64_t v7 = figXPC_CopyInfoForProcess(a1, a2, &cf);
    CFTypeRef v8 = cf;
    if (!v7) {
      figXPCServer_DisassociateObjectWithPerProcessInfo((uint64_t)cf, a3);
    }
    if (v8) {
      CFRelease(v8);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    return v7;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerDisassociateObjectWithNeighborClientConnection(uint64_t a1, xpc_connection_t connection, uint64_t a3)
{
  pid_t pid = xpc_connection_get_pid(connection);

  return FigXPCServerDisassociateObjectWithNeighborClientPID(a1, pid, a3);
}

uint64_t FigXPCServerAssociateCopiedObjectWithNeighborProcess(uint64_t a1, xpc_connection_t connection, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  unint64_t v19 = 0;
  if (a3 && a1 && a7)
  {
    pid_t pid = xpc_connection_get_pid(connection);
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    uint64_t v18 = 0;
    uint64_t v14 = figXPC_CopyInfoForProcess(a1, pid, &v18);
    if (v14)
    {
      uint64_t v15 = v14;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    }
    else
    {
      uint64_t v16 = v18;
      FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
      uint64_t v15 = figXPC_RegisterCopiedObject(v16, *(void **)(v16 + 32), a3, a4, a5, a6, &v19);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
      CFRelease((CFTypeRef)v16);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      if (!v15) {
        *a7 = v19;
      }
    }
    return v15;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  unint64_t v19 = 0;
  if (a1 && a7)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    uint64_t v18 = 0;
    uint64_t v14 = figXPC_CopyInfoForProcess(a1, a2, &v18);
    if (v14)
    {
      uint64_t v15 = v14;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    }
    else
    {
      uint64_t v16 = v18;
      FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
      uint64_t v15 = figXPC_RegisterCopiedObject(v16, *(void **)(v16 + 32), a3, a4, a5, a6, &v19);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
      CFRelease((CFTypeRef)v16);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      if (!v15) {
        *a7 = v19;
      }
    }
    return v15;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerConfirmNeighborProcessByPID(uint64_t a1, int a2)
{
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), (const void *)a2);
    if (Value && Value[4]) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = FigSignalErrorAt(4294951139, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    return v6;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerSetConnectionRefcon(_xpc_connection_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t context = xpc_connection_get_context(a1);
  if (context && (CFTypeRef v6 = CFRetain(context)) != 0)
  {
    uint64_t v7 = v6;
    if (a2)
    {
      if (!a3 || *((void *)v6 + 22))
      {
        uint64_t v8 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        uint64_t v8 = 0;
        *((void *)v6 + 22) = a2;
        *((void *)v6 + 23) = a3;
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    CFRelease(v7);
    return v8;
  }
  else
  {
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerSelfTerminateDueToError(uint64_t result, int a2)
{
  if (result)
  {
    if (*(unsigned char *)(result + 136)) {
      FigXPCServerSelfTerminateDueToError_cold_1(&v2, result, a2);
    }
  }
  return result;
}

uint64_t FigXPCServerGetConnectionRefcon(_xpc_connection_s *a1)
{
  uint64_t context = xpc_connection_get_context(a1);
  if (context && (uint64_t v2 = CFRetain(context)) != 0)
  {
    uint64_t v3 = v2[22];
    CFRelease(v2);
  }
  else
  {
    FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v3;
}

xpc_object_t FigXPCServerCopyPrimaryConnection(_xpc_connection_s *a1)
{
  uint64_t context = xpc_connection_get_context(a1);
  if (context && (uint64_t v2 = (id *)CFRetain(context)) != 0)
  {
    uint64_t v3 = v2;
    uint64_t v4 = (xpc_object_t *)FigCFWeakReferenceLoadAndRetain(v2 + 2);
    if (v4)
    {
      CFIndex v5 = v4;
      xpc_object_t v6 = FigXPCRetain(v4[4]);
      CFRelease(v3);
      CFRelease(v5);
      return v6;
    }
    CFRelease(v3);
  }
  else
  {
    FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigXPCServerStart(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __FigXPCServerStart_block_invoke;
  v5[3] = &__block_descriptor_tmp_85;
  void v5[4] = a1;
  return FigXPCServerStartWithListenerCreatingBlock(a1, a2, a3, a4, (uint64_t)v5);
}

uint64_t FigXPCServerStartWithListenerCreatingBlock(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  int v24 = 44;
  __int16 v23 = 0;
  __int16 v22 = 0;
  Boolean v21 = 0;
  if (figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce != -1) {
    dispatch_once(&figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce, &__block_literal_global_159);
  }
  *a4 = 0;
  if (a2 && (unint64_t)(*a2 - 1) < 3 && (a2[1] || a2[2]))
  {
    CFIndex v10 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F0040053421ABuLL);
    if (v10)
    {
      uint64_t v11 = (uint64_t)v10;
      CFAllocatorRef v12 = FigSimpleMutexCreate();
      *(void *)(v11 + 112) = v12;
      if (v12)
      {
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
        *(void *)(v11 + 104) = Mutable;
        if (Mutable)
        {
          FigCFWeakReferenceTableCreate(v13, 1, (uint64_t *)v11);
          FigCFDictionaryGetInt32IfPresent(a3, @"xpcServerOption_QueuePriority", &v24);
          FigCFDictionaryGetBooleanIfPresent(a3, @"xpcServerOption_SiloObjectIDs", (Boolean *)&v23 + 1);
          FigCFDictionaryGetBooleanIfPresent(a3, @"xpcServerOption_ForwardClientSideAbortActions", (Boolean *)&v23);
          FigCFDictionaryGetBooleanIfPresent(a3, @"xpcServerOption_StartInactive", (Boolean *)&v22 + 1);
          FigCFDictionaryGetBooleanIfPresent(a3, @"xpcServerOption_SelfTerminateOnError", (Boolean *)&v22);
          FigCFDictionaryGetBooleanIfPresent(a3, @"xpcServerOption_OptOutOfPurge", &v21);
          *(void *)(v11 + 40) = *a2;
          *(void *)(v11 + 48) = a2[1];
          *(void *)(v11 + 56) = a2[2];
          *(void *)(v11 + 64) = a2[3];
          *(void *)(v11 + 72) = a2[4];
          if (*a2 >= 3uLL) {
            *(void *)(v11 + 80) = a2[5];
          }
          *(void *)(v11 + 88) = a1;
          *(void *)(v11 + 24) = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, gCommonServerListenerQueue);
          *(_DWORD *)(v11 + 120) = v24;
          *(unsigned char *)(v11 + 124) = HIBYTE(v23) == 0;
          *(unsigned char *)(v11 + 125) = v23;
          *(unsigned char *)(v11 + 136) = v22;
          *(unsigned char *)(v11 + 137) = v21;
          dispatch_queue_t v15 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.terminateSecondaryConnectionsQueue", 0, 0);
          *(void *)(v11 + 128) = v15;
          if (!v15) {
            return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
          }
          figXPC_RegisterNewServer(v11);
          if (!FigCFDictionaryGetInt32IfPresent(a3, @"xpcServerOption_SelfTerminationTimeout", (void *)(v11 + 96)))
          {
            unint64_t TimeoutNanoseconds = FigRPCServer_GetTimeoutNanoseconds();
            *(_DWORD *)(v11 + 96) = TimeoutNanoseconds / 0x3B9ACA00;
            if ((TimeoutNanoseconds / 0x3B9ACA00)) {
              *(_DWORD *)(v11 + 100) = 90;
            }
          }
          uint64_t v17 = *(_xpc_connection_s **)(v11 + 24);
          handler[0] = MEMORY[0x1E4F143A8];
          handler[1] = 0x40000000;
          handler[2] = __FigXPCServerStartWithListenerCreatingBlock_block_invoke;
          handler[3] = &__block_descriptor_tmp_156_0;
          handler[4] = v11;
          xpc_connection_set_event_handler(v17, handler);
          *a4 = v11;
          if (!HIBYTE(v22)) {
            xpc_connection_activate(*(xpc_connection_t *)(v11 + 24));
          }
          return 0;
        }
      }
    }
    uint64_t v19 = 4294951146;
  }
  else
  {
    uint64_t v19 = 4294951145;
  }

  return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
}

xpc_connection_t __FigXPCServerStart_block_invoke(uint64_t a1, NSObject *a2)
{
  return xpc_connection_create_mach_service(*(const char **)(a1 + 32), a2, 1uLL);
}

uint64_t FigXPCServerStartWithNewXPCEndpoint(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = FigXPCServerStartWithListenerCreatingBlock(a1, a2, a3, a4, (uint64_t)&__block_literal_global_56);
  if (!v5) {
    *(void *)(*a4 + 32) = xpc_endpoint_create(*(xpc_connection_t *)(*a4 + 24));
  }
  return v5;
}

xpc_connection_t __FigXPCServerStartWithNewXPCEndpoint_block_invoke(uint64_t a1, NSObject *a2)
{
  return xpc_connection_create(0, a2);
}

uint64_t FigXPCServerCopyXPCEndpoint(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    *a2 = *(void *)(a1 + 32);
    FigXPCRetain(*(xpc_object_t *)(a1 + 32));
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCServerStartWithClientXPCConnection(_xpc_connection_s *a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  int v18 = 44;
  __int16 v17 = 0;
  __int16 v16 = 0;
  if (figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce != -1)
  {
    dispatch_once(&figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce, &__block_literal_global_159);
    if (a3) {
      goto LABEL_3;
    }
LABEL_13:
    uint64_t result = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    CFIndex v10 = 0;
    goto LABEL_14;
  }
  if (!a3) {
    goto LABEL_13;
  }
LABEL_3:
  if ((unint64_t)(*a3 - 3) <= 0xFFFFFFFFFFFFFFFDLL || !a3[1] && !a3[2]) {
    goto LABEL_13;
  }
  CFIndex v10 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F0040053421ABuLL);
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = FigSimpleMutexCreate();
  *((void *)v10 + 14) = v11;
  if (!v11) {
    goto LABEL_11;
  }
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  *((void *)v10 + 13) = Mutable;
  if (!Mutable) {
    goto LABEL_11;
  }
  FigCFWeakReferenceTableCreate(v12, 1, (uint64_t *)v10);
  FigCFDictionaryGetInt32IfPresent(a4, @"xpcServerOption_QueuePriority", &v18);
  FigCFDictionaryGetBooleanIfPresent(a4, @"xpcServerOption_SiloObjectIDs", (Boolean *)&v17 + 1);
  FigCFDictionaryGetBooleanIfPresent(a4, @"xpcServerOption_ForwardClientSideAbortActions", (Boolean *)&v17);
  FigCFDictionaryGetBooleanIfPresent(a4, @"xpcServerOption_SelfTerminateOnError", (Boolean *)&v16 + 1);
  FigCFDictionaryGetBooleanIfPresent(a4, @"xpcServerOption_OptOutOfPurge", (Boolean *)&v16);
  __copy_assignment_8_8_t0w8_pa0_45604_8_pa0_22587_16_pa0_57319_24_pa0_49646_32_pa0_60888_40((void *)v10 + 5, a3);
  *((void *)v10 + 11) = a2;
  *((void *)v10 + 3) = 0;
  *((_DWORD *)v10 + 30) = v18;
  *((unsigned char *)v10 + 124) = HIBYTE(v17) == 0;
  *((unsigned char *)v10 + 125) = v17;
  *((unsigned char *)v10 + 136) = HIBYTE(v16);
  *((unsigned char *)v10 + 137) = v16;
  dispatch_queue_t v14 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.terminateSecondaryConnectionsQueue", 0, 0);
  *((void *)v10 + 16) = v14;
  if (v14)
  {
    figXPC_RegisterNewServer((uint64_t)v10);
    FigSimpleMutexLock(*((pthread_mutex_t **)v10 + 14));
    figXPC_HandleNewClientConnection((uint64_t)v10, a1);
    FigSimpleMutexUnlock(*((pthread_mutex_t **)v10 + 14));
    uint64_t result = 0;
  }
  else
  {
LABEL_11:
    uint64_t result = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
  }
LABEL_14:
  *a5 = v10;
  return result;
}

void *__copy_assignment_8_8_t0w8_pa0_45604_8_pa0_22587_16_pa0_57319_24_pa0_49646_32_pa0_60888_40(void *result, void *a2)
{
  *uint64_t result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  result[3] = a2[3];
  result[4] = a2[4];
  result[5] = a2[5];
  return result;
}

void figXPC_RegisterNewServer(uint64_t a1)
{
  if (figXPC_ServerRegistryOneTimeInitialization_sInitServerRegistryOnce != -1) {
    dispatch_once(&figXPC_ServerRegistryOneTimeInitialization_sInitServerRegistryOnce, &__block_literal_global_166);
  }
  *(unsigned char *)(a1 + 16) = FigAtomicIncrement32(gNextServerNumber);
  *(void *)(a1 + 8) = ((unint64_t)*(unsigned __int8 *)(a1 + 16) << 40) | ((uint64_t)getpid() << 48);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figXPC_RegisterNewServer_block_invoke;
  block[3] = &__block_descriptor_tmp_163;
  void block[4] = a1;
  dispatch_sync((dispatch_queue_t)gServerRegistry_0, block);
}

void figXPC_HandleNewClientConnection(uint64_t a1, xpc_connection_t connection)
{
  CFTypeRef cf = 0;
  uint64_t v14 = 0;
  uint64_t pid = xpc_connection_get_pid(connection);
  uint64_t v5 = &gHasProcessInitialized;
  if (gHasProcessInitialized) {
    uint64_t v5 = &isFirstTime;
  }
  *uint64_t v5 = 1;
  xpc_object_t v6 = *(unsigned int (**)(xpc_connection_t))(a1 + 64);
  if (v6 && !v6(connection))
  {
    xpc_connection_cancel(connection);
  }
  else
  {
    if (!figXPC_CopyInfoForProcess(a1, pid, &v14))
    {
      FigServer_CopyProcessName(pid, (CFStringRef *)&cf);
      uint64_t v7 = v14;
      if (*(void *)(v14 + 32))
      {
        xpc_connection_cancel(connection);
      }
      else
      {
        dispatch_queue_t v15 = 0;
        *(void *)(v14 + 32) = connection;
        xpc_retain(connection);
        xpc_connection_set_target_queue(connection, *(dispatch_queue_t *)(v7 + 24));
        FigSimpleMutexLock(*(pthread_mutex_t **)(v7 + 80));
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v7 + 88));
        if (Count >= 1)
        {
          CFIndex v9 = Count;
          for (CFIndex i = 0; i != v9; ++i)
          {
            ValueAtIndedouble x = CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 88), i);
            ValueAtIndex[7] = xpc_retain(connection);
          }
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(v7 + 80));
        figXPC_CreateNewConnectionInfo(v7, *(NSObject **)(v7 + 24), (uint64_t *)&v15);
        xpc_connection_set_context(connection, v15);
        xpc_connection_set_finalizer_f(connection, (xpc_finalizer_t)figXPC_ConnectionInfoFinalizer);
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 0x40000000;
        int v12[2] = __figXPC_HandleNewClientConnection_block_invoke;
        v12[3] = &__block_descriptor_tmp_168;
        v12[4] = a1;
        v12[5] = v7;
        void v12[6] = connection;
        xpc_connection_set_event_handler(connection, v12);
        xpc_connection_resume(connection);
      }
      goto LABEL_12;
    }
    uint64_t v7 = v14;
    if (v14) {
LABEL_12:
    }
      CFRelease((CFTypeRef)v7);
  }
  if (cf) {
    CFRelease(cf);
  }
}

void FigXPCServerActivate(uint64_t a1)
{
  if (a1) {
    xpc_connection_activate(*(xpc_connection_t *)(a1 + 24));
  }
}

uint64_t FigXPCPurgeObjectsForPIDWithReportingBlock(int a1, uint64_t a2)
{
  UpTimeNanoFloat64 seconds = FigGetUpTimeNanoseconds();
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigXPCPurgeObjectsForPIDWithReportingBlock_block_invoke;
  block[3] = &__block_descriptor_tmp_89_0;
  void block[4] = a2;
  int v7 = a1;
  int v8 = 0;
  unint64_t v9 = UpTimeNanoseconds;
  dispatch_sync((dispatch_queue_t)gServerRegistry_0, block);
  return 0;
}

void __FigXPCPurgeObjectsForPIDWithReportingBlock_block_invoke(uint64_t a1)
{
  CFArrayRef v2 = (const __CFArray *)gServerRegistry_1;
  v3.length = CFArrayGetCount((CFArrayRef)gServerRegistry_1);
  v3.location = 0;

  CFArrayApplyFunction(v2, v3, (CFArrayApplierFunction)figXPC_PurgeObjectsForPIDArrayApplier, (void *)(a1 + 32));
}

void figXPC_PurgeObjectsForPIDArrayApplier(uint64_t a1, void *a2)
{
  CFTypeRef cf = 0;
  if (*(unsigned char *)(a1 + 137))
  {
    int v4 = 0;
    goto LABEL_19;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  int v4 = figXPC_CopyInfoForProcess(a1, *((_DWORD *)a2 + 2), &cf);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  if (v4)
  {
LABEL_19:
    xpc_object_t v7 = 0;
    goto LABEL_11;
  }
  CFTypeRef v5 = cf;
  FigSimpleMutexLock(*((pthread_mutex_t **)cf + 10));
  CFIndex Count = CFArrayGetCount(*((CFArrayRef *)v5 + 11));
  xpc_object_t v7 = xpc_array_create(0, 0);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      ValueAtIndedouble x = (uint64_t *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 11), v8 - 2);
      figXPC_ForgetNotificationsForServedObject(*((void *)v5 + 14), ValueAtIndex);
      FigCFWeakReferenceTableRemoveValue(*((void *)v5 + 6), ValueAtIndex[3]);
      xpc_array_set_uint64(v7, 0xFFFFFFFFFFFFFFFFLL, ValueAtIndex[3]);
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)v5 + 11), v8 - 2);
      --v8;
    }
    while (v8 > 1);
  }
  if (*((void *)v5 + 4))
  {
    int64_t v10 = a2[2];
    xpc_object_t xdict = 0;
    int v11 = FigXPCCreateBasicMessage(0x2E706721u, 0, &xdict);
    xpc_object_t v12 = xdict;
    if (!v11)
    {
      xpc_dictionary_set_value(xdict, ".ObjectIDs", v7);
      xpc_dictionary_set_int64(v12, ".PurgeIdentifier", v10);
      xpc_connection_send_notification();
    }
    FigXPCRelease(v12);
  }
  *((void *)v5 + 12) = *(void *)(*((void *)v5 + 7) + 8) | ((unint64_t)FigAtomicIncrement32((atomic_uint *)(*((void *)v5 + 7) + 20)) << 8) | 1;
  FigSimpleMutexUnlock(*((pthread_mutex_t **)v5 + 10));
  int v4 = 0;
LABEL_11:
  if (*a2) {
    (*(void (**)(void, void, xpc_object_t, void, BOOL))(*a2 + 16))(*a2, *(void *)(a1 + 88), v7, a2[2], v4 != 0);
  }
  if (cf) {
    CFRelease(cf);
  }

  FigXPCRelease(v7);
}

void figXPCRemoteClient_PrimaryConnectionNotificationCallback(int a1, const void *a2, CFTypeRef cf1, uint64_t a4, const __CFDictionary *a5)
{
  uint64_t v12 = 0;
  if (CFEqual(cf1, @"xpcConnectionNotification_ServerDied"))
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, @"xpcRemoteClientNotification_ServerDied", a2, a5);
  }
  else if (CFEqual(cf1, @"xpcConnectionNotification_ServerStatePurged"))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v10 = Mutable;
      FigCFDictionaryGetInt64IfPresent((uint64_t)a5, @"xpcConnectionNotificationServerStatePurgedPayloadKey_PurgeIdentifier", &v12);
      FigCFDictionarySetInt64(v10, @"xpcRemoteClientNotificationServerStatePurgedPayloadKey_PurgeIdentifier", v12);
      int v11 = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification(v11, @"xpcRemoteClientNotification_ServerStatePurged", a2, v10);
      CFRelease(v10);
    }
  }
}

void *figXPCRemoteClient_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void figXPCRemoteClient_Finalize(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, (const void *)a1, (uint64_t)figXPCRemoteClient_PrimaryConnectionNotificationCallback, 0, *(const void **)(a1 + 24));
    CFRange v3 = *(const void **)(a1 + 24);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 24) = 0;
    }
  }
  int v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16) = 0;
  }
}

double figXPCClientConnectionInfo_Init(uint64_t a1)
{
  *(void *)(a1 + 144) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figXPCClientConnectionInfo_Finalize(void *a1)
{
  CFArrayRef v2 = (const void *)a1[11];
  if (v2)
  {
    CFRelease(v2);
    a1[11] = 0;
  }
  CFRange v3 = (const void *)a1[14];
  if (v3)
  {
    CFRelease(v3);
    a1[14] = 0;
  }
  int v4 = (const void *)a1[12];
  if (v4)
  {
    CFRelease(v4);
    a1[12] = 0;
  }
  FigSimpleMutexDestroy(a1[16]);
  CFTypeRef v5 = (const void *)a1[17];
  if (v5)
  {
    CFRelease(v5);
    a1[17] = 0;
  }
  xpc_object_t v6 = (const void *)a1[18];
  if (v6)
  {
    CFRelease(v6);
    a1[18] = 0;
  }
}

__CFString *figXPCClientConnectionInfo_CopyDebugDesc(void *a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = a1[2];
  CFIndex v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigXPCClientConnectionInfo %p %s> RC %d", a1, v3, v4);
  return Mutable;
}

NSObject *figXPC_CreateSerialDispatchQueueWithPriority(const char *a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return FigDispatchQueueCreateStandardDispatchQueue(a1, 0, 0, QOS_CLASS_UNSPECIFIED);
  }
  else {
    return FigDispatchQueueCreateWithPriority(a1, 0, a2);
  }
}

void __figXPCCreateXPCConnectionInternal_block_invoke(uint64_t a1, void *a2)
{
  CFArrayRef v2 = a2;
  uint64_t v4 = MEMORY[0x192FC6B30](a2);
  uint64_t context = (id *)xpc_connection_get_context(*(xpc_connection_t *)(a1 + 32));
  xpc_object_t v6 = FigCFWeakReferenceHolderCopyReferencedObject(context);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    if (v4 == MEMORY[0x1E4F145A8])
    {
      if (v2 == (void *)MEMORY[0x1E4F14528])
      {
        __int16 v17 = (void *)xpc_connection_copy_invalidation_reason();
        xpc_dictionary_get_string(MEMORY[0x1E4F14528], (const char *)*MEMORY[0x1E4F14530]);
        *(_DWORD *)(v7 + 80) = 1;
        free(v17);
      }
      unsigned int v55 = 0;
      *(void *)(v7 + 64) = 0;
      if (*(unsigned char *)(v7 + 86)) {
        *(_DWORD *)(v7 + 80) = 1;
      }
      *(unsigned char *)(v7 + 84) = 0;
      FigAtomicCompareAndSwap32(1, 0, (atomic_uint *)(v7 + 92));
      FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(v7 + 16) + 128));
      uint64_t v18 = *(void *)(v7 + 16);
      uint64_t v19 = *(const void **)(v18 + 136);
      if (v19)
      {
        CFRelease(v19);
        uint64_t v18 = *(void *)(v7 + 16);
        *(void *)(v18 + 136) = 0;
      }
      CFTypeRef v20 = *(const void **)(v18 + 144);
      if (v20)
      {
        CFRelease(v20);
        uint64_t v18 = *(void *)(v7 + 16);
        *(void *)(v18 + 144) = 0;
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v18 + 128));
      FigCFWeakReferenceTableCopyValues(*(void *)(v7 + 32), (CFMutableDictionaryRef *)&v55);
      CFRetain((CFTypeRef)v7);
      if (v55)
      {
        CFRetain(v55);
        uint64_t v21 = (uint64_t)v55;
      }
      else
      {
        uint64_t v21 = 0;
      }
      __int16 v22 = gCommonRemoteClientCleanupQueue;
      blocuint64_t k = (__CFDictionary *)MEMORY[0x1E4F143A8];
      uint64_t v46 = 0x40000000;
      uint64_t v47 = __figXPCConnection_HandleConnectionDemise_block_invoke;
      unsigned int v48 = &__block_descriptor_tmp_124;
      uint64_t v49 = v21;
      uint64_t v50 = v7;
    }
    else
    {
      if (v4 != MEMORY[0x1E4F14590]) {
        goto LABEL_42;
      }
      uint int64 = xpc_dictionary_get_uint64(v2, ".Operation");
      if (uint64 <= 778989427)
      {
        if (uint64 != 778264932)
        {
          if (uint64 == 778398819)
          {
            blocuint64_t k = 0;
            CFTypeRef v54 = 0;
            unsigned int v55 = 0;
            xpc_object_t value = 0;
            repldouble y = xpc_dictionary_create_reply(v2);
            if (*(void *)(*(void *)(v7 + 16) + 24) <= 3uLL)
            {
              FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
            }
            else
            {
              if (!v2)
              {
                FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
                goto LABEL_91;
              }
              if (!FigXPCConnectionCopyMemoryOriginForConnectedProcess(v7, &v54))
              {
                if (!FigXPCConnectionCopyMemoryRecipientForConnectedProcess(v7, (CFTypeRef *)&v55))
                {
                  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                  CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s.%d.eventlink", *(void *)(*(void *)(v7 + 16) + 16), *(unsigned int *)(v7 + 88));
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  CFDictionarySetValue(Mutable, @"FigMemoryPool_LoggingName", v11);
                  CMMemoryPoolRef v13 = CMMemoryPoolCreate(Mutable);
                  if (Mutable) {
                    CFRelease(Mutable);
                  }
                  int int64 = xpc_dictionary_get_int64(v2, "ServerEventLinkMachThreadPriority");
                  unsigned int v15 = xpc_dictionary_get_uint64(v2, "ServerEventLinkFigThreadPriority");
                  CFArrayRef v2 = v55;
                  if (!FigOSEventLinkServerCreate((int)v10, v15, int64, v11, 0, v13, v54, v55, &block)
                    && !FigOSEventLinkServerSetAssociatedFigXPCServerXPCConnection((uint64_t)block, *(void **)(v7 + 40))&& !FigOSEventLinkServerCopyRemoteCreationInfoXPCObject((uint64_t)block, &value))
                  {
                    xpc_dictionary_set_value(reply, "RemoteEventLinkCreationInfo", value);
                    (*(void (**)(__CFDictionary *, void))(*(void *)(v7 + 16) + 80))(block, 0);
                  }
                  xpc_connection_send_message(*(xpc_connection_t *)(v7 + 40), reply);
                  if (v13) {
                    CFRelease(v13);
                  }
                  if (v2) {
                    goto LABEL_20;
                  }
                  goto LABEL_21;
                }
                CFArrayRef v2 = v55;
LABEL_91:
                xpc_connection_send_message(*(xpc_connection_t *)(v7 + 40), reply);
                CFStringRef v11 = 0;
                if (v2) {
LABEL_20:
                }
                  CFRelease(v2);
LABEL_21:
                if (v54) {
                  CFRelease(v54);
                }
                if (v11) {
                  CFRelease(v11);
                }
                FigXPCRelease(value);
                FigXPCRelease(reply);
                CFMutableDictionaryRef v16 = block;
                if (!block) {
                  goto LABEL_42;
                }
                goto LABEL_41;
              }
            }
            CFArrayRef v2 = 0;
            goto LABEL_91;
          }
          goto LABEL_68;
        }
        unsigned int v55 = 0;
        xpc_object_t v27 = xpc_dictionary_create_reply(v2);
        remote_connection = xpc_dictionary_get_remote_connection(v2);
        uint64_t v29 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v7 + 24));
        unsigned int v30 = v29;
        if (v29)
        {
          id v31 = v29[2];
          blocuint64_t k = (__CFDictionary *)MEMORY[0x1E4F143A8];
          uint64_t v46 = 0x40000000;
          uint64_t v47 = __figXPCConnection_handleCreateAdminConnectionReplyMessageFromServer_block_invoke;
          unsigned int v48 = &__block_descriptor_tmp_127_0;
          uint64_t v49 = (uint64_t)v2;
          if (!figXPCCreateXPCConnectionInternal(v29, v31, 0x600000000, &v55, &block))
          {
            v30[4] = v55;
            unsigned int v55 = 0;
          }
          if (!remote_connection) {
            goto LABEL_58;
          }
        }
        else
        {
          FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
          if (!remote_connection)
          {
LABEL_58:
            if (v30) {
              CFRelease(v30);
            }
            if (v55) {
              CFRelease(v55);
            }
            FigXPCRelease(v27);
            goto LABEL_42;
          }
        }
        if (v27) {
          xpc_connection_send_message(remote_connection, v27);
        }
        goto LABEL_58;
      }
      if (uint64 == 779118369)
      {
        uint64_t v32 = *(void *)(v7 + 16);
        if (*(void *)(v32 + 24) >= 3uLL && *(void *)(v32 + 72))
        {
          CFRetain((CFTypeRef)v7);
          FigXPCRetain(v2);
          long long v33 = *(NSObject **)(v7 + 56);
          blocuint64_t k = (__CFDictionary *)MEMORY[0x1E4F143A8];
          uint64_t v46 = 0x40000000;
          uint64_t v47 = __figXPCConnection_CallObjectPurgedCallback_block_invoke;
          unsigned int v48 = &__block_descriptor_tmp_130;
          uint64_t v49 = (uint64_t)v2;
          uint64_t v50 = v7;
          dispatch_async(v33, &block);
        }
        int64_t v34 = xpc_dictionary_get_int64(v2, ".PurgeIdentifier");
        CFMutableDictionaryRef v35 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        FigCFDictionarySetInt64(v35, @"xpcConnectionNotificationServerStatePurgedPayloadKey_PurgeIdentifier", v34);
        CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterPostNotification(DefaultLocalCenter, @"xpcConnectionNotification_ServerStatePurged", (const void *)v7, v35);
        if (!v35) {
          goto LABEL_42;
        }
        CFMutableDictionaryRef v16 = v35;
        goto LABEL_41;
      }
      if (uint64 != 778989428)
      {
LABEL_68:
        long long v37 = *(void **)(v7 + 16);
        if (!v37[6] && (v37[3] < 2uLL || !v37[8])) {
          goto LABEL_42;
        }
        uint64_t v38 = (void *)xpc_dictionary_get_uint64(v2, ".objectID");
        CFTypeRef v39 = *(void **)(v7 + 16);
        if (v39[6] && v38)
        {
          id v43 = figXPCConnection_copyObjectForID(v7, v38);
          if (!v43) {
            goto LABEL_42;
          }
          uint64_t v44 = (uint64_t)v43;
          xpc_retain(v2);
          xpc_object_t v40 = *(NSObject **)(v7 + 72);
          blocuint64_t k = (__CFDictionary *)MEMORY[0x1E4F143A8];
          uint64_t v46 = 0x40000000;
          uint64_t v47 = __figXPCConnection_CallClientMessageHandlers_block_invoke;
          unsigned int v48 = &__block_descriptor_tmp_134;
          uint64_t v49 = v7;
          uint64_t v50 = v44;
          CFTypeRef v51 = v2;
        }
        else
        {
          if (v39[3] < 2uLL || !v39[8]) {
            goto LABEL_42;
          }
          xpc_retain(v2);
          xpc_object_t v40 = *(NSObject **)(v7 + 72);
          blocuint64_t k = (__CFDictionary *)MEMORY[0x1E4F143A8];
          uint64_t v46 = 0x40000000;
          uint64_t v47 = __figXPCConnection_CallClientMessageHandlers_block_invoke_2;
          unsigned int v48 = &__block_descriptor_tmp_135;
          uint64_t v49 = v7;
          uint64_t v50 = (uint64_t)v2;
        }
        dispatch_async(v40, &block);
LABEL_42:
        CFRelease((CFTypeRef)v7);
        return;
      }
      unsigned int v55 = 0;
      FigXPCMessageCopyCFString(v2, ".NotificationName", &v55);
      if (!v55) {
        goto LABEL_42;
      }
      __int16 v23 = (void *)xpc_dictionary_get_uint64(v2, ".objectID");
      id v24 = figXPCConnection_copyObjectForID(v7, v23);
      if (v24)
      {
        id v25 = v24;
        if (v55) {
          CFRetain(v55);
        }
        FigXPCRetain(v2);
        if (*(void *)(*(void *)(v7 + 16) + 40)) {
          uint64_t v26 = *(void *)(*(void *)(v7 + 16) + 40);
        }
        else {
          uint64_t v26 = 0;
        }
        __int16 v22 = *(NSObject **)(v7 + 56);
        blocuint64_t k = (__CFDictionary *)MEMORY[0x1E4F143A8];
        uint64_t v46 = 0x40000000;
        uint64_t v47 = __figXPCConnection_HandleNotificationMessage_block_invoke;
        unsigned int v48 = &__block_descriptor_tmp_125;
        uint64_t v49 = (uint64_t)v2;
        uint64_t v50 = v26;
        CFTypeRef v51 = v25;
        CFTypeRef v52 = v55;
      }
      else
      {
        uint64_t v41 = *(void *)(v7 + 16);
        if (!*(unsigned char *)(v41 + 104) || !*(void *)(v41 + 40))
        {
LABEL_40:
          CFMutableDictionaryRef v16 = (CFMutableDictionaryRef)v55;
          if (!v55) {
            goto LABEL_42;
          }
LABEL_41:
          CFRelease(v16);
          goto LABEL_42;
        }
        uint64_t v42 = *(void *)(v41 + 40);
        if (v55) {
          CFRetain(v55);
        }
        FigXPCRetain(v2);
        __int16 v22 = *(NSObject **)(v7 + 56);
        blocuint64_t k = (__CFDictionary *)MEMORY[0x1E4F143A8];
        uint64_t v46 = 0x40000000;
        uint64_t v47 = __figXPCConnection_HandleNotificationMessage_block_invoke_2;
        unsigned int v48 = &__block_descriptor_tmp_126;
        uint64_t v49 = (uint64_t)v2;
        uint64_t v50 = v42;
        CFTypeRef v51 = v55;
      }
    }
    dispatch_async(v22, &block);
    goto LABEL_40;
  }
}

double figXPCConnection_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCConnection_Finalize(void *a1)
{
  CFArrayRef v2 = (_xpc_connection_s *)a1[5];
  if (v2)
  {
    xpc_connection_cancel(v2);
    uint64_t v3 = (void *)a1[5];
    if (v3)
    {
      a1[5] = 0;
      xpc_release(v3);
    }
  }
  uint64_t v4 = a1[9];
  if (v4)
  {
    dispatch_release(v4);
    a1[9] = 0;
  }
  CFTypeRef v5 = a1[7];
  if (v5)
  {
    dispatch_release(v5);
    a1[7] = 0;
  }
  xpc_object_t v6 = a1[6];
  if (v6)
  {
    dispatch_release(v6);
    a1[6] = 0;
  }
  uint64_t v7 = (const void *)a1[4];
  if (v7)
  {
    CFRelease(v7);
    a1[4] = 0;
  }
  unint64_t v8 = (const void *)a1[2];
  if (v8)
  {
    CFRelease(v8);
    a1[2] = 0;
  }
  unint64_t v9 = (const void *)a1[3];
  if (v9)
  {
    CFRelease(v9);
    a1[3] = 0;
  }
  FigSimpleMutexDestroy(a1[12]);
  a1[12] = 0;
  CFAllocatorRef v10 = (const void *)a1[13];
  if (v10)
  {
    CFRelease(v10);
    a1[13] = 0;
  }
}

__CFString *figXPCConnection_CopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = *(void *)(*(void *)(a1 + 16) + 16);
  CFIndex v4 = CFGetRetainCount((CFTypeRef)a1);
  if (*(_DWORD *)(a1 + 80)) {
    CFTypeRef v5 = " INVALID";
  }
  else {
    CFTypeRef v5 = "";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigXPCConnection %p %s> RC %d%s", a1, v3, v4, v5);
  return Mutable;
}

uint64_t figXPCConnection_DeadConnectionObjectApplierFunction(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  xpc_object_t v6 = *(void (**)(const void *))(v5 + 32);
  if (v6)
  {
    v6(a2);
    uint64_t v5 = *(void *)(a3 + 16);
  }
  int v7 = *(_DWORD *)(a3 + 88);
  uint64_t v8 = *(void *)(v5 + 120);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32(Mutable, @"PID", v7);
  FigCFDictionarySetInt64(Mutable, @"ServerCapabilities", v8);
  BOOL IsServerProcess = FigServer_IsServerProcess();
  CFStringRef v11 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!IsServerProcess) {
    CFStringRef v11 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  FigCFDictionarySetValue(Mutable, @"IsIndirectConnection", *v11);
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, @"MediaServicesProcessDeath", a2, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  CMMemoryPoolRef v13 = CMNotificationCenterGetDefaultLocalCenter();
  CFStringRef v14 = *(const __CFString **)(*(void *)(a3 + 16) + 96);

  return CMNotificationCenterPostNotification(v13, v14, a2, 0);
}

id figXPCConnection_copyObjectForID(uint64_t a1, void *a2)
{
  id result = FigCFWeakReferenceTableCopyValue(*(void *)(a1 + 32), a2);
  if (!result)
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 16) + 112);
    return FigCFWeakReferenceTableCopyValue(v5, a2);
  }
  return result;
}

xpc_connection_t __figXPCConnection_handleCreateAdminConnectionReplyMessageFromServer_block_invoke(uint64_t a1)
{
  xpc_object_t value = (_xpc_endpoint_s *)xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 32), ".SecondaryEndpoint");
  if (!value
    || (CFArrayRef v2 = value, MEMORY[0x192FC6B30]() != MEMORY[0x1E4F145A0])
    || (xpc_connection_t result = xpc_connection_create_from_endpoint(v2)) == 0)
  {
    FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

double figXPCPerProcessInfo_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCPerProcessInfo_Finalize(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  CFArrayRef v2 = *(const __CFArray **)(a1 + 88);
  if (v2)
  {
    if (*(void *)(a1 + 48))
    {
      CFIndex Count = CFArrayGetCount(v2);
      if (Count >= 1)
      {
        CFIndex v4 = Count;
        for (CFIndex i = 0; i != v4; ++i)
        {
          ValueAtIndedouble x = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), i);
          figXPC_ForgetNotificationsForServedObject(*(void *)(a1 + 112), ValueAtIndex);
          FigCFWeakReferenceTableRemoveValue(*(void *)(a1 + 48), ValueAtIndex[3]);
        }
      }
    }
    int v7 = *(const void **)(a1 + 88);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a1 + 88) = 0;
    }
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 80));
  *(void *)(a1 + 80) = 0;
  uint64_t v8 = *(_xpc_connection_s **)(a1 + 32);
  if (v8)
  {
    xpc_connection_cancel(v8);
    unint64_t v9 = *(void **)(a1 + 32);
    if (v9)
    {
      *(void *)(a1 + 32) = 0;
      xpc_release(v9);
    }
  }
  CFAllocatorRef v10 = *(NSObject **)(a1 + 24);
  if (v10)
  {
    dispatch_release(v10);
    *(void *)(a1 + 24) = 0;
  }
  CFArrayRef v11 = *(const __CFArray **)(a1 + 144);
  if (v11)
  {
    CFIndex v12 = CFArrayGetCount(v11);
    if (v12 >= 1)
    {
      CFIndex v13 = v12;
      CFIndex v14 = 0;
      uint64_t v15 = MEMORY[0x1E4F14578];
      do
      {
        CFMutableDictionaryRef v16 = (_xpc_connection_s *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v14);
        __int16 v17 = v16;
        if (v16 && MEMORY[0x192FC6B30](v16) == v15)
        {
          xpc_connection_cancel(v17);
          xpc_release(v17);
        }
        else
        {
          v36[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v36, &type);
          int v19 = v36[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v21 = v19;
          }
          else {
            unsigned int v21 = v19 & 0xFFFFFFFE;
          }
          if (v21)
          {
            uint64_t v22 = *(void *)(*(void *)(a1 + 56) + 88);
            int v23 = *(_DWORD *)(a1 + 16);
            v36[1] = 136315906;
            long long v37 = "figXPCPerProcessInfo_DisposeSecondaryConnections";
            __int16 v38 = 2048;
            CFTypeRef v39 = v17;
            __int16 v40 = 2082;
            uint64_t v41 = v22;
            __int16 v42 = 1024;
            int v43 = v23;
            id v24 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v19) = v36[0];
          }
          else
          {
            id v24 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v24, v24 != &v44, v19, 0, v20);
        }
        ++v14;
      }
      while (v13 != v14);
    }
    id v25 = *(const void **)(a1 + 144);
    if (v25)
    {
      CFRelease(v25);
      *(void *)(a1 + 144) = 0;
    }
  }
  uint64_t v26 = *(void **)(a1 + 136);
  if (v26)
  {
    *(void *)(a1 + 136) = 0;
    xpc_release(v26);
  }
  xpc_object_t v27 = *(void **)(a1 + 128);
  if (v27)
  {
    *(void *)(a1 + 128) = 0;
    xpc_release(v27);
  }
  uint64_t v28 = *(NSObject **)(a1 + 120);
  if (v28)
  {
    dispatch_release(v28);
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v29 = *(const void **)(a1 + 48);
  if (v29)
  {
    CFRelease(v29);
    *(void *)(a1 + 48) = 0;
  }
  unsigned int v30 = *(NSObject **)(a1 + 104);
  if (v30)
  {
    dispatch_source_cancel(v30);
    *(void *)(a1 + 104) = 0;
  }
  id v31 = *(const void **)(a1 + 112);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(a1 + 112) = 0;
  }
  uint64_t v32 = *(const void **)(a1 + 64);
  if (v32)
  {
    CFRelease(v32);
    *(void *)(a1 + 64) = 0;
  }
  long long v33 = *(const void **)(a1 + 72);
  if (v33)
  {
    CFRelease(v33);
    *(void *)(a1 + 72) = 0;
  }
  int64_t v34 = *(const void **)(a1 + 160);
  if (v34)
  {
    CFRelease(v34);
    *(void *)(a1 + 160) = 0;
  }
}

uint64_t figXPC_ForgetNotificationsForServedObject(uint64_t a1, CFTypeRef a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 152));
  CFArrayRef v4 = *(const __CFArray **)(a1 + 160);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      do
      {
        ValueAtIndedouble x = (CFTypeRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 160), v7);
        if (*ValueAtIndex == a2)
        {
          unint64_t v9 = ValueAtIndex;
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 160), v7);
          CFTypeRef v10 = v9[1];
          if (v10) {
            CFRelease(v10);
          }
          CFTypeRef v11 = v9[2];
          if (v11) {
            CFRelease(v11);
          }
          if (*v9) {
            CFRelease(*v9);
          }
          free(v9);
          --v6;
        }
        else
        {
          ++v7;
        }
      }
      while (v7 < v6);
    }
  }
  CFIndex v12 = *(pthread_mutex_t **)(a1 + 152);

  return FigSimpleMutexUnlock(v12);
}

uint64_t figXPC_RegisterServedObjectWithID(uint64_t a1, void *a2, const void *a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (figXPCServedObject_GetTypeID_sRegisterServedObjectTypeOnce != -1) {
    dispatch_once(&figXPCServedObject_GetTypeID_sRegisterServedObjectTypeOnce, &__block_literal_global_143);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v17 = Instance;
    *(void *)(Instance + 16) = CFRetain(a3);
    *(void *)(v17 + 40) = a6;
    *(void *)(v17 + 48) = a7;
    *(void *)(v17 + 32) = a5;
    *(void *)(v17 + 56) = FigXPCRetain(a2);
    *(void *)(v17 + 24) = a8;
    uint64_t v18 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(void *)(a1 + 48), (uint64_t)a3, a8);
    if (!v18)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 88), (const void *)v17);
      FigCFWeakReferenceStore((id *)(v17 + 64), (id)a1);
      if (a4)
      {
        char v20 = 0;
      }
      else
      {
        CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)v17, (CFNotificationCallback)figXPCServedObject_NotificationCallback, 0, (unint64_t)a3, 0, 0);
        char v20 = 1;
      }
      *(unsigned char *)(v17 + 72) = v20;
    }
    CFRelease((CFTypeRef)v17);
    return v18;
  }
  else
  {
    return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
  }
}

void figXPCServedObject_NotificationCallback(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5)
{
  if (!*(void *)(a2 + 56)) {
    return;
  }
  uint64_t v8 = (uint64_t *)FigCFWeakReferenceLoadAndRetain((id *)(a2 + 64));
  if (!v8) {
    return;
  }
  unint64_t v9 = v8;
  uint64_t v10 = v8[14];
  FigSimpleMutexLock(*(pthread_mutex_t **)(v10 + 152));
  int v11 = *(_DWORD *)(v10 + 172);
  if ((v11 - 1) < 2)
  {
    figXPC_EnqueueNotification((uint64_t)v9, v10, (CFTypeRef)a2, a3, a5);
    goto LABEL_9;
  }
  if (v11 == 3)
  {
    int v12 = *(_DWORD *)(v10 + 168);
    goto LABEL_11;
  }
  if (!v11)
  {
    int v12 = *(_DWORD *)(v10 + 168);
    if (v12 >= 100)
    {
      *(_DWORD *)(v10 + 172) = 1;
      figXPC_EnqueueNotification((uint64_t)v9, v10, (CFTypeRef)a2, a3, a5);
      figXPC_SendNotificationCheckpoint((const void *)v10, *(_xpc_connection_s **)(a2 + 56));
      goto LABEL_9;
    }
LABEL_11:
    *(_DWORD *)(v10 + 168) = v12 + 1;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v10 + 152));
    figXPC_SendOneNotification((void *)a2, a3, a5);
    goto LABEL_12;
  }
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v10 + 152));
LABEL_12:

  CFRelease(v9);
}

double figXPCServedObject_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCServedObject_Finalize(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    CFArrayRef v2 = *(void (**)(void))(a1 + 40);
    if (v2)
    {
      v2();
      *(void *)(a1 + 32) = 0;
    }
  }
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    if (!*(unsigned char *)(a1 + 72)
      || (CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter(),
          FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, (const void *)a1, (uint64_t)figXPCServedObject_NotificationCallback, 0, *(const void **)(a1 + 16)), (uint64_t v3 = *(const void **)(a1 + 16)) != 0))
    {
      CFRelease(v3);
      *(void *)(a1 + 16) = 0;
    }
  }
  FigCFWeakReferenceDestroy((id *)(a1 + 64));
  uint64_t v5 = *(void **)(a1 + 56);
  if (v5)
  {
    *(void *)(a1 + 56) = 0;
    xpc_release(v5);
  }
}

void figXPC_EnqueueNotification(uint64_t a1, uint64_t a2, CFTypeRef a3, const void *a4, const void *a5)
{
  uint64_t v9 = *(void *)(a1 + 56);
  if (*(void *)(v9 + 40) < 2uLL) {
    goto LABEL_17;
  }
  uint64_t v10 = *(uint64_t (**)(const void *))(v9 + 72);
  if (!v10) {
    goto LABEL_17;
  }
  int v11 = v10(a4);
  if (v11 == 3) {
    return;
  }
  if (v11 != 2)
  {
    if (v11 == 1)
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 160));
      if (Count >= 1)
      {
        CFIndex v13 = Count;
        CFIndex v14 = 0;
        do
        {
          ValueAtIndedouble x = (CFTypeRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 160), v14);
          if (*ValueAtIndex == a3)
          {
            if (CFEqual(a4, ValueAtIndex[1])) {
              return;
            }
          }
        }
        while (v13 != ++v14);
      }
    }
LABEL_17:
    unsigned int v21 = malloc_type_malloc(0x18uLL, 0xE00406B48E91AuLL);
    if (v21)
    {
      uint64_t v22 = v21;
      void *v21 = CFRetain(a3);
      v22[1] = CFRetain(a4);
      if (a5) {
        CFTypeRef v23 = CFRetain(a5);
      }
      else {
        CFTypeRef v23 = 0;
      }
      int v22[2] = v23;
      id v24 = *(__CFArray **)(a2 + 160);
      CFArrayAppendValue(v24, v22);
    }
    return;
  }
  CFIndex v16 = CFArrayGetCount(*(CFArrayRef *)(a2 + 160));
  if (v16 < 1) {
    goto LABEL_17;
  }
  CFIndex v17 = v16;
  CFIndex v18 = 0;
  while (1)
  {
    int v19 = (CFTypeRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 160), v18);
    if (*v19 == a3)
    {
      char v20 = v19;
      if (CFEqual(a4, v19[1])) {
        break;
      }
    }
    if (v17 == ++v18) {
      goto LABEL_17;
    }
  }
  CFTypeRef v25 = v20[2];
  v20[2] = a5;
  if (a5) {
    CFRetain(a5);
  }
  if (v25)
  {
    CFRelease(v25);
  }
}

void figXPC_SendNotificationCheckpoint(const void *a1, _xpc_connection_s *a2)
{
  CFRetain(a1);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = __figXPC_SendNotificationCheckpoint_block_invoke;
  v4[3] = &__block_descriptor_tmp_145;
  v4[4] = a1;
  v4[5] = a2;
  xpc_connection_send_barrier(a2, v4);
}

void figXPC_SendOneNotification(void *a1, const void *a2, const void *a3)
{
  *(void *)int v12 = 0;
  int v6 = FigXPCCreateBasicMessage(0x2E6E6F74u, a1[3], v12);
  CFIndex v7 = *(void **)v12;
  if (v6) {
    goto LABEL_14;
  }
  FigXPCMessageSetCFString(*(void **)v12, ".NotificationName", a2);
  uint64_t v8 = (uint64_t (*)(void, void, const void *, const void *, const void **, void *))a1[6];
  if (!v8)
  {
    if (a3)
    {
LABEL_7:
      CFTypeRef v10 = CFRetain(a3);
LABEL_8:
      if (v10)
      {
LABEL_9:
        if (!FigXPCMessageSetCFDictionary(v7, ".payload", v10)) {
          xpc_connection_send_notification();
        }
        CFRelease(v10);
        CFIndex v7 = *(void **)v12;
        goto LABEL_14;
      }
    }
LABEL_13:
    xpc_connection_send_notification();
    goto LABEL_14;
  }
  int v11 = 0;
  int v9 = v8(a1[4], a1[2], a2, a3, &v11, v7);
  CFTypeRef v10 = 0;
  switch(v9)
  {
    case 0:
      if (!a3) {
        goto LABEL_13;
      }
      goto LABEL_7;
    case 2:
      goto LABEL_8;
    case 4:
      CFTypeRef v10 = v11;
      if (!v11) {
        goto LABEL_13;
      }
      goto LABEL_9;
    default:
      break;
  }
LABEL_14:
  FigXPCRelease(v7);
}

double figXPCEnqueuedNotifications_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCEnqueuedNotifications_Finalize(void *a1)
{
  FigSimpleMutexDestroy(a1[19]);
  CFArrayRef v2 = (const void *)a1[20];
  if (v2)
  {
    CFRelease(v2);
    a1[20] = 0;
  }
  uint64_t v3 = a1[18];
  if (v3)
  {
    dispatch_release(v3);
  }
}

void figXPC_ForgetProcessInfo(uint64_t a1, int a2)
{
  uint64_t v3 = (const void *)a2;
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), (const void *)a2);
  if (Value)
  {
    uint64_t v5 = Value;
    CFRetain(Value);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 104), v3);
    uint64_t v6 = v5[14];
    FigSimpleMutexLock(*(pthread_mutex_t **)(v6 + 152));
    *(_DWORD *)(v6 + 172) = 3;
    CFIndex v7 = *(pthread_mutex_t **)(v6 + 152);
    CFArrayRef v8 = *(const __CFArray **)(v6 + 160);
    *(void *)(v6 + 160) = 0;
    FigSimpleMutexUnlock(v7);
    if (v8)
    {
      CFIndex Count = CFArrayGetCount(v8);
      if (Count >= 1)
      {
        CFIndex v10 = Count;
        for (CFIndex i = 0; i != v10; ++i)
        {
          ValueAtIndedouble x = (CFTypeRef *)CFArrayGetValueAtIndex(v8, i);
          if (*ValueAtIndex) {
            CFRelease(*ValueAtIndex);
          }
          CFTypeRef v13 = ValueAtIndex[1];
          if (v13) {
            CFRelease(v13);
          }
          CFTypeRef v14 = ValueAtIndex[2];
          if (v14) {
            CFRelease(v14);
          }
          free(ValueAtIndex);
        }
      }
      CFRelease(v8);
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __figXPC_ForgetProcessInfo_block_invoke;
    block[3] = &__block_descriptor_tmp_155;
    void block[4] = v5;
    dispatch_async((dispatch_queue_t)gCommonServerProcessCleanupQueue, block);
  }
  else
  {
    uint64_t v15 = *(__CFDictionary **)(a1 + 104);
    CFDictionaryRemoveValue(v15, v3);
  }
}

void __FigXPCServerStartWithListenerCreatingBlock_block_invoke(uint64_t a1, _xpc_connection_s *a2)
{
  uint64_t v4 = MEMORY[0x192FC6B30](a2);
  if (v4 == MEMORY[0x1E4F14578])
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 112));
    figXPC_HandleNewClientConnection(*(void *)(a1 + 32), a2);
    uint64_t v6 = *(pthread_mutex_t **)(*(void *)(a1 + 32) + 112);
    FigSimpleMutexUnlock(v6);
  }
  else if (a2 == (_xpc_connection_s *)MEMORY[0x1E4F14528] && v4 == MEMORY[0x1E4F145A8])
  {
    CFIndex v7 = (void *)xpc_connection_copy_invalidation_reason();
    free(v7);
  }
}

void figXPC_HandleMessage(uint64_t a1, uint64_t a2, _xpc_connection_s *a3, xpc_object_t xdict)
{
  uint int64 = xpc_dictionary_get_uint64(xdict, ".Operation");
  uint64_t context = xpc_connection_get_context(a3);
  if (context) {
    CFTypeRef v10 = CFRetain(context);
  }
  else {
    CFTypeRef v10 = 0;
  }
  xdicta[0] = 0;
  if (*(unsigned char *)(a1 + 125) && FigAtomicCompareAndSwap32(0, 1u, (atomic_uint *)(a2 + 40)))
  {
    figXPCServer_EstablishSecondaryConnectionManagement((xpc_endpoint_t)a1, a2);
    int v11 = FigXPCCreateBasicMessage(0x2E636164u, 0, xdicta);
    xpc_object_t v12 = xdicta[0];
    if (!v11)
    {
      xpc_dictionary_set_value(xdicta[0], ".SecondaryEndpoint", *(xpc_object_t *)(a2 + 136));
      xpc_object_t v13 = xpc_connection_send_message_with_reply_sync(a3, v12);
      goto LABEL_8;
    }
  }
  else
  {
    xpc_object_t v12 = 0;
  }
  xpc_object_t v13 = 0;
LABEL_8:
  FigXPCRelease(v13);
  FigXPCRelease(v12);
  if ((uint64 & 0x100000000) == 0)
  {
    remote_connection = xpc_dictionary_get_remote_connection(xdict);
    repldouble y = xpc_dictionary_create_reply(xdict);
    if (!reply)
    {
      FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
      goto LABEL_112;
    }
    CFIndex v16 = reply;
    if ((int)uint64 <= 779120230)
    {
      if (uint64 != 775056996)
      {
        if (uint64 != 778398835)
        {
          if (uint64 == 779055719)
          {
            int updated = FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(xdict, reply, *(const char **)(a1 + 88), (uint64_t **)(a2 + 72));
LABEL_60:
            int v25 = updated;
            BOOL v43 = 0;
            id v24 = sRootQueuesIndexedByMachPriority + 8;
            goto LABEL_105;
          }
          goto LABEL_61;
        }
        CFTypeRef v60 = 0;
        xdicta[0] = 0;
        CFTypeRef v62 = 0;
        CFTypeRef cf = 0;
        xpc_object_t value = 0;
        uint64_t v56 = remote_connection;
        if (*(void *)(a1 + 40) > 2uLL
          && (v33 = *(void *)(a1 + 80), uint64_t v32 = (uint64_t (**)(xpc_object_t, void))(a1 + 80), v33)
          && a3)
        {
          int v34 = FigXPCServerCopyMemoryOrigin(a3, &v60);
          if (!v34)
          {
            int v34 = FigXPCServerCopyMemoryRecipient(a3, &v62);
            if (!v34)
            {
              FigServer_CopyProcessName(*(unsigned int *)(a2 + 16), (CFStringRef *)&cf);
              CFAllocatorRef v35 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              CFStringRef v36 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s.%d.%@.eventlink", *(void *)(*(void *)(a2 + 56) + 88), *(unsigned int *)(a2 + 16), cf);
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v35, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              CFDictionarySetValue(Mutable, @"FigMemoryPool_LoggingName", v36);
              CMMemoryPoolRef v38 = CMMemoryPoolCreate(Mutable);
              if (Mutable) {
                CFRelease(Mutable);
              }
              int int64 = xpc_dictionary_get_int64(xdict, "ServerEventLinkMachThreadPriority");
              unsigned int v40 = xpc_dictionary_get_uint64(xdict, "ServerEventLinkFigThreadPriority");
              int v41 = FigOSEventLinkServerCreate((int)v35, v40, int64, v36, 0, v38, v60, v62, xdicta);
              if (!v41)
              {
                int v42 = FigOSEventLinkServerSetAssociatedFigXPCServerXPCConnection((uint64_t)xdicta[0], a3);
                id v24 = sRootQueuesIndexedByMachPriority + 8;
                if (!v42)
                {
                  int v42 = FigOSEventLinkServerCopyRemoteCreationInfoXPCObject((uint64_t)xdicta[0], &value);
                  if (!v42)
                  {
                    xpc_dictionary_set_value(v16, "RemoteEventLinkCreationInfo", value);
                    int v42 = (*v32)(xdicta[0], 0);
                  }
                }
                int v25 = v42;
                goto LABEL_66;
              }
              int v25 = v41;
LABEL_65:
              id v24 = sRootQueuesIndexedByMachPriority + 8;
LABEL_66:
              if (cf) {
                CFRelease(cf);
              }
              if (v38) {
                CFRelease(v38);
              }
              if (v62) {
                CFRelease(v62);
              }
              remote_connection = v56;
              if (v60) {
                CFRelease(v60);
              }
              if (v36) {
                CFRelease(v36);
              }
              FigXPCRelease(value);
              if (xdicta[0]) {
                CFRelease(xdicta[0]);
              }
              goto LABEL_78;
            }
          }
        }
        else
        {
          int v34 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
        }
        int v25 = v34;
        CMMemoryPoolRef v38 = 0;
        CFStringRef v36 = 0;
        goto LABEL_65;
      }
      int v30 = *(_DWORD *)(a2 + 16);
      xdicta[0] = 0;
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
      int v25 = figXPC_CopyInfoForProcess(a1, v30, xdicta);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      id v31 = (xpc_object_t *)xdicta[0];
      if (v25)
      {
        id v24 = sRootQueuesIndexedByMachPriority + 8;
        if (!xdicta[0]) {
          goto LABEL_45;
        }
      }
      else
      {
        figXPCServer_EstablishSecondaryConnectionManagement((xpc_endpoint_t)a1, (uint64_t)xdicta[0]);
        xpc_dictionary_set_value(v16, ".SecondaryEndpoint", v31[17]);
        id v24 = sRootQueuesIndexedByMachPriority + 8;
      }
      CFRelease(v31);
LABEL_45:
      FigXPCRelease(0);
LABEL_78:
      BOOL v43 = 0;
LABEL_105:
      xdicta[0] = 0;
      if ((v24[223] & 1) != 0 || !FigAtomicCompareAndSwap32(0, 1u, (atomic_uint *)(a2 + 44)))
      {
        xpc_object_t v55 = 0;
      }
      else
      {
        int v54 = FigProcessStateMonitorServerEnsureStartedAndCopyEndpoint(xdicta);
        xpc_object_t v55 = xdicta[0];
        if (!v54)
        {
          xpc_dictionary_set_value(v16, ".ProcessStateMonitorEndpoint", xdicta[0]);
          xpc_object_t v55 = xdicta[0];
        }
      }
      FigXPCRelease(v55);
      if (!v43)
      {
        xpc_dictionary_set_int64(v16, ".ErrorReturn", v25);
        xpc_connection_send_message(remote_connection, v16);
      }
      xpc_release(v16);
      goto LABEL_112;
    }
    if (uint64 == 779251762)
    {
      int updated = FigMemoryOriginCompleteEstablishingMemoryRecipientUsingXPCMessage2(xdict, (void *)(a2 + 64));
      goto LABEL_60;
    }
    if (uint64 == 779251761)
    {
      int updated = FigMemoryOriginBeginEstablishingMemoryRecipientByFillingInXPCMessage1(reply);
      goto LABEL_60;
    }
    if (uint64 != 779120231)
    {
LABEL_61:
      __int16 v57 = remote_connection;
      uint64_t TimeoutNanoseconds = FigRPCServer_GetTimeoutNanoseconds();
      if (*((void *)v10 + 28))
      {
        uint64_t v45 = *((void *)v10 + 29);
        uint64_t v46 = *((void *)v10 + 28);
      }
      else
      {
        uint64_t v46 = TimeoutNanoseconds;
        uint64_t v45 = 0;
      }
      int64_t v47 = xpc_dictionary_get_int64(xdict, ".SelfTerminationTimeout");
      if (1000000000 * v47) {
        uint64_t v48 = 1000000000 * v47;
      }
      else {
        uint64_t v48 = v46;
      }
      if (1000000000 * v47) {
        uint64_t v49 = 0;
      }
      else {
        uint64_t v49 = v45;
      }
      if (v48 && v49) {
        uint64_t v48 = FigRPCServer_PickRPCTimeoutForCurrentThread(v48, v49);
      }
      xpc_dictionary_set_int64(v16, ".Token", *((void *)v10 + 25));
      if (v48)
      {
        xpc_dictionary_set_int64(v16, ".ErrorReturn", -16156);
        xpc_retain(v16);
        *((void *)v10 + 27) = xpc_retain(xdict);
        dispatch_set_context(*((dispatch_object_t *)v10 + 24), v16);
        uint64_t v50 = *((void *)v10 + 24);
        dispatch_time_t v51 = dispatch_time(0, v48);
        dispatch_source_set_timer(v50, v51, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
        *((unsigned char *)v10 + 208) = 1;
      }
      int64_t v52 = xpc_dictionary_get_int64(xdict, ".AbortActionID");
      if (v52 && *(unsigned char *)(a1 + 125))
      {
        CFNumberRef SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v52);
        os_unfair_lock_lock((os_unfair_lock_t)(a2 + 168));
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 160), SInt64, v10);
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 168));
      }
      else
      {
        CFNumberRef SInt64 = 0;
      }
      int v25 = (*(uint64_t (**)(_xpc_connection_s *, xpc_object_t, void *))(a1 + 48))(a3, xdict, v16);
      if (v52 && *(unsigned char *)(a1 + 125))
      {
        os_unfair_lock_lock((os_unfair_lock_t)(a2 + 168));
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 160), SInt64);
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 168));
      }
      id v24 = &sRootQueuesIndexedByMachPriority[1];
      if (SInt64) {
        CFRelease(SInt64);
      }
      CFTypeRef v62 = 0;
      int v63 = &v62;
      uint64_t v64 = 0x2000000000;
      char v65 = 0;
      if (*((unsigned char *)v10 + 208))
      {
        *((unsigned char *)v10 + 208) = 0;
        dispatch_source_set_timer(*((dispatch_source_t *)v10 + 24), 0xFFFFFFFFFFFFFFFFLL, 0, 0x1DCD6500uLL);
        xdicta[0] = (xpc_object_t)MEMORY[0x1E4F143A8];
        xdicta[1] = (xpc_object_t)0x40000000;
        xdicta[2] = __figXPC_UnsetTimeoutTimer_block_invoke;
        xdicta[3] = &unk_1E567F288;
        xdicta[4] = &v62;
        xdicta[5] = (xpc_object_t)v10;
        dispatch_sync((dispatch_queue_t)gCommonServerTimeoutQueue, xdicta);
        BOOL v43 = *((unsigned char *)v63 + 24) != 0;
      }
      else
      {
        BOOL v43 = 0;
      }
      remote_connection = v57;
      _Block_object_dispose(&v62, 8);
      if ((uint64 & 0x200000000) != 0) {
        BOOL v43 = 0;
      }
      goto LABEL_105;
    }
    string = xpc_dictionary_get_string(xdict, ".ProcessName");
    if (string)
    {
      char v20 = string;
      uint64_t v21 = *MEMORY[0x1E4F1CF80];
      CFStringRef v22 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], string, 0x8000100u);
      if (v22)
      {
        if (xpc_dictionary_get_BOOL(xdict, ".IsDaemon")) {
          FigApplicationStateMonitorAddPIDToIgnore(*((_DWORD *)v10 + 40));
        }
        FigProcessInfoCreateWithDetails(v21, *((_DWORD *)v10 + 40), v22, (void *)v10 + 3);
        id v23 = FigCFWeakReferenceLoadAndRetain((id *)v10 + 2);
        id v24 = &sRootQueuesIndexedByMachPriority[1];
        if (v23)
        {
          strncpy((char *)xdicta, v20, 8uLL);
          *((xpc_object_t *)v10 + 21) = xdicta[0];
        }
        goto LABEL_29;
      }
    }
    else
    {
      CFStringRef v22 = 0;
    }
    id v23 = 0;
    id v24 = sRootQueuesIndexedByMachPriority + 8;
LABEL_29:
    xpc_dictionary_set_uint64(v16, ".ServerCapabilities", v24[223]);
    xpc_dictionary_set_int64(v16, ".Token", *((void *)v10 + 25));
    if (v23) {
      CFRelease(v23);
    }
    if (v22) {
      CFRelease(v22);
    }
    int v25 = 0;
    goto LABEL_78;
  }
  if (uint64 != 779382561)
  {
    if (uint64 == 779318384)
    {
      int64_t v26 = xpc_dictionary_get_int64(xdict, ".AbortActionID");
      if (v26)
      {
        CFNumberRef v27 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v26);
        os_unfair_lock_lock((os_unfair_lock_t)(a2 + 168));
        uint64_t v28 = (NSObject **)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 160), v27);
        if (v28) {
          FigThreadAbortQueue(v28[30]);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 168));
        if (v27) {
          CFRelease(v27);
        }
      }
    }
    else if (uint64 == 778986352)
    {
      uint64_t v18 = xpc_dictionary_get_uint64(xdict, ".objectID");
      FigXPCServerDisassociateObjectWithConnection(a3, v18);
    }
    else
    {
      uint64_t v29 = *(void (**)(_xpc_connection_s *, xpc_object_t))(a1 + 56);
      if (v29) {
        v29(a3, xdict);
      }
    }
LABEL_112:
    if (!v10) {
      return;
    }
    goto LABEL_113;
  }
  *((void *)v10 + 28) = 1000000000 * xpc_dictionary_get_int64(xdict, ".SelfTerminationTimeout");
  *((void *)v10 + 29) = 0;
LABEL_113:
  CFRelease(v10);
}

void figXPC_CreateNewConnectionInfo(uint64_t a1, NSObject *a2, uint64_t *a3)
{
  if (a2)
  {
    if (figXPCConnectionInfo_GetTypeID_sRegisterConnectionInfoTypeOnce != -1) {
      dispatch_once(&figXPCConnectionInfo_GetTypeID_sRegisterConnectionInfoTypeOnce, &__block_literal_global_173);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v7 = Instance;
      FigCFWeakReferenceStore((id *)(Instance + 16), (id)a1);
      *(_DWORD *)(v7 + 160) = *(_DWORD *)(a1 + 16);
      *(void *)(v7 + 240) = a2;
      dispatch_retain(a2);
      strncpy((char *)(v7 + 32), *(const char **)(*(void *)(a1 + 56) + 88), 0x7FuLL);
      *(void *)(v7 + 192) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, (dispatch_queue_t)gCommonServerTimeoutQueue);
      *(void *)(v7 + 200) = FigRemote_GetServerTimeoutToken();
      uint64_t v8 = *(void *)(a1 + 56);
      int v9 = *(_DWORD *)(v8 + 96);
      if (v9) {
        *(void *)(v7 + 224) = 1000000000 * v9;
      }
      int v10 = *(_DWORD *)(v8 + 100);
      if (v10) {
        *(void *)(v7 + 232) = 1000000000 * v10;
      }
      int v11 = *(NSObject **)(v7 + 192);
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 0x40000000;
      handler[2] = __figXPC_CreateNewConnectionInfo_block_invoke;
      handler[3] = &__block_descriptor_tmp_169;
      handler[4] = v7;
      dispatch_source_set_event_handler(v11, handler);
      dispatch_resume(*(dispatch_object_t *)(v7 + 192));
      *a3 = v7;
      return;
    }
    uint64_t v12 = 4294951146;
  }
  else
  {
    uint64_t v12 = 4294951145;
  }

  FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

void figXPC_ConnectionInfoFinalizer(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

double figXPCConnectionInfo_Init(uint64_t a1)
{
  *(void *)(a1 + 240) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figXPCConnectionInfo_Finalize(uint64_t a1)
{
  FigCFWeakReferenceDestroy((id *)(a1 + 16));
  if (*(void *)(a1 + 176))
  {
    (*(void (**)(void))(a1 + 184))();
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
  }
  CFArrayRef v2 = *(NSObject **)(a1 + 192);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = *(NSObject **)(a1 + 192);
    if (v3)
    {
      dispatch_release(v3);
      *(void *)(a1 + 192) = 0;
    }
  }
  uint64_t v4 = *(NSObject **)(a1 + 240);
  if (v4) {
    dispatch_release(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 24) = 0;
  }
}

uint64_t OpCodeChar(unsigned int a1, unsigned int a2)
{
  unsigned int v9 = a1;
  uint64_t v4 = MEMORY[0x1E4F14390];
  if (a1 > 0x7Fu)
  {
    if (!__maskrune(a1, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * a1 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  if (((a1 >> 8) & 0x80) != 0)
  {
    if (!__maskrune(BYTE1(a1), 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(v4 + 4 * BYTE1(a1) + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  if ((a1 & 0x800000) != 0)
  {
    if (!__maskrune(BYTE2(a1), 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(v4 + 4 * BYTE2(a1) + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  unsigned int v5 = HIBYTE(a1);
  if ((a1 & 0x80000000) != 0)
  {
    if (__maskrune(v5, 0x40000uLL)) {
      return (char)*((unsigned char *)&v9 + a2);
    }
LABEL_17:
    snprintf(__str, 5uLL, "%4d", a1);
    return __str[-a2 + 3];
  }
  if ((*(_DWORD *)(v4 + 4 * v5 + 60) & 0x40000) == 0) {
    goto LABEL_17;
  }
  return (char)*((unsigned char *)&v9 + a2);
}

xpc_endpoint_t figXPCServer_EstablishSecondaryConnectionManagement(xpc_endpoint_t result, uint64_t a2)
{
  if (!*(void *)(a2 + 128))
  {
    xpc_endpoint_t v3 = result;
    uint64_t v4 = xpc_connection_create(0, (dispatch_queue_t)gCommonServerListenerQueue);
    *(void *)(a2 + 128) = v4;
    xpc_connection_set_context(v4, (void *)a2);
    *(void *)(a2 + 144) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    unsigned int v5 = *(_xpc_connection_s **)(a2 + 128);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    int v6[2] = __figXPCServer_EstablishSecondaryConnectionManagement_block_invoke;
    v6[3] = &__block_descriptor_tmp_176;
    v6[4] = v3;
    void v6[5] = a2;
    xpc_connection_set_event_handler(v5, v6);
    xpc_connection_activate(*(xpc_connection_t *)(a2 + 128));
    double result = xpc_endpoint_create(*(xpc_connection_t *)(a2 + 128));
    *(void *)(a2 + 136) = result;
  }
  return result;
}

xpc_object_t FigXPCRetain(xpc_object_t object)
{
  if (object) {
    return xpc_retain(object);
  }
  return object;
}

void FigXPCRelease(xpc_object_t object)
{
  if (object) {
    xpc_release(object);
  }
}

uint64_t FigXPCMessageSetCFObject(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1 && a2)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
    {
      return FigXPCMessageSetCFDictionary(a1, a2, cf);
    }
    uint64_t v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (v8)
    {
      unsigned int v9 = v8;
      xpc_dictionary_set_value(a1, a2, v8);
      xpc_release(v9);
      return 0;
    }
    uint64_t v10 = 4294950015;
  }
  else
  {
    uint64_t v10 = 4294950016;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFDictionary(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1 && a2)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
    {
      uint64_t v7 = figXPCCopySanitizedCFDictionary(cf);
      uint64_t v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v8)
      {
        unsigned int v9 = v8;
        xpc_dictionary_set_value(a1, a2, v8);
        xpc_release(v9);
        uint64_t v10 = 0;
        if (!v7) {
          return v10;
        }
      }
      else
      {
        uint64_t v10 = FigSignalErrorAt(4294950015, 0, 0, 0, 0, 0, 0);
        if (!v7) {
          return v10;
        }
      }
      CFRelease(v7);
      return v10;
    }
    uint64_t v12 = 4294950013;
  }
  else
  {
    uint64_t v12 = 4294950016;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFURL(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1 && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFURLGetTypeID())
    {
      CFTypeID v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v6)
      {
        uint64_t v7 = v6;
        xpc_dictionary_set_value(a1, a2, v6);
        xpc_release(v7);
        return 0;
      }
      uint64_t v9 = 4294950015;
    }
    else
    {
      uint64_t v9 = 4294950013;
    }
  }
  else
  {
    uint64_t v9 = 4294950016;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

__CFDictionary *figXPCCopySanitizedCFDictionary(const void *a1)
{
  v5[2] = *(const void **)MEMORY[0x1E4F143B8];
  CFArrayRef v2 = (const void *)*MEMORY[0x1E4F24CB8];
  v5[0] = *(const void **)MEMORY[0x1E4F24D38];
  v5[1] = v2;
  CFTypeID v3 = CFGetTypeID(a1);
  if (v3 == CFDictionaryGetTypeID()) {
    return FigCFDictionaryCreateCopyRemovingKeys((CFDictionaryRef)a1, v5, 2);
  }
  else {
    return 0;
  }
}

uint64_t FigXPCMessageSetCFString(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1 && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID())
    {
      CFTypeID v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v6)
      {
        uint64_t v7 = v6;
        xpc_dictionary_set_value(a1, a2, v6);
        xpc_release(v7);
        return 0;
      }
      uint64_t v9 = 4294950015;
    }
    else
    {
      uint64_t v9 = 4294950013;
    }
  }
  else
  {
    uint64_t v9 = 4294950016;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFNumber(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
    {
      return FigXPCMessageSetCFObject(a1, a2, cf);
    }
    uint64_t v8 = 4294950013;
  }
  else
  {
    uint64_t v8 = 4294950016;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFBoolean(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFBooleanGetTypeID())
    {
      return FigXPCMessageSetCFObject(a1, a2, cf);
    }
    uint64_t v8 = 4294950013;
  }
  else
  {
    uint64_t v8 = 4294950016;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFArray(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1 && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFArrayGetTypeID())
    {
      CFTypeID v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v6)
      {
        uint64_t v7 = v6;
        xpc_dictionary_set_value(a1, a2, v6);
        xpc_release(v7);
        return 0;
      }
      uint64_t v9 = 4294950015;
    }
    else
    {
      uint64_t v9 = 4294950013;
    }
  }
  else
  {
    uint64_t v9 = 4294950016;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFDate(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (a1 && a2)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDateGetTypeID())
    {
      double v7 = MEMORY[0x192FC3EB0](cf);
      xpc_dictionary_set_double(a1, a2, v7);
      return 0;
    }
    uint64_t v9 = 4294950013;
  }
  else
  {
    uint64_t v9 = 4294950016;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFData(void *a1, const char *a2, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  int v10 = 0;
  if (!a1 || !a2)
  {
    uint64_t v9 = 4294950016;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFDataGetTypeID())
  {
    uint64_t v9 = 4294950013;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  double v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  xpc_dictionary_set_value(a1, a2, v7);
  xpc_release(v7);
  FigXPCMessageGetOpCode(a1, &v10);
  if (gGMFigKTraceEnabled == 1)
  {
    strncpy(__dst, a2, 8uLL);
    CFDataGetLength((CFDataRef)cf);
    kdebug_trace();
  }
  return 0;
}

uint64_t FigXPCMessageSetAndConsumeVMData(xpc_object_t xdict, char *key, void *bytes, size_t size)
{
  uint64_t v7 = 4294950016;
  if (!xdict || !key) {
    goto LABEL_12;
  }
  if (!size)
  {
    xpc_dictionary_set_data(xdict, key, bytes, 0);
    return 0;
  }
  if (bytes)
  {
    uint64_t v9 = dispatch_data_create(bytes, size, 0, (dispatch_block_t)*MEMORY[0x1E4F14408]);
    if (v9)
    {
      int v10 = v9;
      xpc_object_t v11 = xpc_data_create_with_dispatch_data(v9);
      dispatch_release(v10);
      if (v11)
      {
        xpc_dictionary_set_value(xdict, key, v11);
        xpc_release(v11);
        return 0;
      }
      uint64_t v7 = 4294950014;
      goto LABEL_16;
    }
    uint64_t v7 = 4294950014;
LABEL_12:
    uint64_t v12 = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    if (bytes && size) {
      MEMORY[0x192FC66D0](*MEMORY[0x1E4F14960], bytes, size);
    }
    return v12;
  }
LABEL_16:

  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFError(void *a1, const char *a2, __CFError *a3)
{
  if (!a3) {
    return 0;
  }
  if (a1 && a2)
  {
    CFTypeID v5 = FigCFCopyCFErrorAsPropertyList(a3);
    uint64_t v6 = FigXPCMessageSetCFDictionary(a1, a2, v5);
    if (v5) {
      CFRelease(v5);
    }
    return v6;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFError(void *a1, const char *a2, const __CFDictionary **a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3) {
      *a3 = 0;
    }
    return v4;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFDictionary(a1, a2, &cf);
    CFTypeRef v5 = cf;
    if (v4)
    {
      CFDictionaryRef v6 = 0;
    }
    else
    {
      CFDictionaryRef v6 = FigCFErrorCreateFromPropertyList((const __CFDictionary *)cf);
      CFTypeRef v5 = cf;
    }
    *a3 = v6;
    if (v5) {
      CFRelease(v5);
    }
    return v4;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFDictionary(void *a1, const char *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (!a3) {
      return v4;
    }
    goto LABEL_9;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (!cf)
      {
        uint64_t v4 = 0;
        goto LABEL_9;
      }
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CFDictionaryGetTypeID())
      {
        uint64_t v4 = 0;
        CFTypeRef v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v4)
    {
      if (v5)
      {
        CFRelease(v5);
        CFTypeRef v5 = 0;
      }
    }
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFObject(void *a1, const char *a2, __CFDictionary **a3)
{
  if (a1 && a2)
  {
    if (a3)
    {
      uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, a2);
      if (result)
      {
        CFTypeRef v5 = (__CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
        CFTypeID v6 = v5;
        if (v5)
        {
          CFTypeID v7 = CFGetTypeID(v5);
          if (v7 == CFDictionaryGetTypeID())
          {
            uint64_t v8 = figXPCCopySanitizedCFDictionary(v6);
            CFRelease(v6);
            uint64_t result = 0;
            CFTypeID v6 = v8;
          }
          else
          {
            uint64_t result = 0;
          }
        }
        else
        {
          uint64_t result = FigSignalErrorAt(4294950015, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        CFTypeID v6 = 0;
      }
      goto LABEL_9;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeID v6 = 0;
    if (a3) {
LABEL_9:
    }
      *a3 = v6;
  }
  return result;
}

uint64_t FigXPCMessageCopyCFString(void *a1, const char *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (!a3) {
      return v4;
    }
    goto LABEL_9;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (!cf)
      {
        uint64_t v4 = 0;
        goto LABEL_9;
      }
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CFStringGetTypeID())
      {
        uint64_t v4 = 0;
        CFTypeRef v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v4)
    {
      if (v5)
      {
        CFRelease(v5);
        CFTypeRef v5 = 0;
      }
    }
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFNumber(void *a1, const char *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (!a3) {
      return v4;
    }
    goto LABEL_9;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (!cf)
      {
        uint64_t v4 = 0;
        goto LABEL_9;
      }
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CFNumberGetTypeID())
      {
        uint64_t v4 = 0;
        CFTypeRef v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v4)
    {
      if (v5)
      {
        CFRelease(v5);
        CFTypeRef v5 = 0;
      }
    }
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFBoolean(void *a1, const char *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (!a3) {
      return v4;
    }
    goto LABEL_9;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (!cf)
      {
        uint64_t v4 = 0;
        goto LABEL_9;
      }
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CFBooleanGetTypeID())
      {
        uint64_t v4 = 0;
        CFTypeRef v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v4)
    {
      if (v5)
      {
        CFRelease(v5);
        CFTypeRef v5 = 0;
      }
    }
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFArray(void *a1, const char *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (!a3) {
      return v4;
    }
    goto LABEL_9;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (!cf)
      {
        uint64_t v4 = 0;
        goto LABEL_9;
      }
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CFArrayGetTypeID())
      {
        uint64_t v4 = 0;
        CFTypeRef v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v4)
    {
      if (v5)
      {
        CFRelease(v5);
        CFTypeRef v5 = 0;
      }
    }
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFDate(void *a1, const char *a2, CFDateRef *a3)
{
  if (a1 && a2)
  {
    if (a3)
    {
      double v4 = xpc_dictionary_get_double(a1, a2);
      CFDateRef v5 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4);
      if (v5)
      {
        CFDateRef v6 = v5;
        uint64_t result = 0;
      }
      else
      {
        uint64_t result = FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
        CFDateRef v6 = 0;
      }
      goto LABEL_6;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFDateRef v6 = 0;
    if (a3) {
LABEL_6:
    }
      *a3 = v6;
  }
  return result;
}

uint64_t FigXPCMessageCopyCFData(void *a1, const char *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (!a3) {
      return v4;
    }
    goto LABEL_9;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (!cf)
      {
        uint64_t v4 = 0;
        goto LABEL_9;
      }
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CFDataGetTypeID())
      {
        uint64_t v4 = 0;
        CFTypeRef v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v4)
    {
      if (v5)
      {
        CFRelease(v5);
        CFTypeRef v5 = 0;
      }
    }
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFURL(void *a1, const char *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (!a3) {
      return v4;
    }
    goto LABEL_9;
  }
  if (a3)
  {
    uint64_t v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (!cf)
      {
        uint64_t v4 = 0;
        goto LABEL_9;
      }
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CFURLGetTypeID())
      {
        uint64_t v4 = 0;
        CFTypeRef v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v4)
    {
      if (v5)
      {
        CFRelease(v5);
        CFTypeRef v5 = 0;
      }
    }
    goto LABEL_9;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCreateBlockBufferDataWithSize(const __CFAllocator *a1, xpc_object_t xdict, char *key, size_t a4, CMBlockBufferRef *a5)
{
  CMBlockBufferRef blockBufferOut = 0;
  HIDWORD(customBlockSource.AllocateBlock) = 0;
  *(void *)&customBlockSource.version = 0;
  customBlockSource.refCon = xdict;
  customBlockSource.FreeBlocuint64_t k = (void (__cdecl *)(void *, void *, size_t))BBufUtilXPCObjectReleaser;
  if (xdict && key)
  {
    if (a5)
    {
      size_t length = 0;
      uint64_t result = (uint64_t)xpc_dictionary_get_data(xdict, key, &length);
      if (result)
      {
        size_t v10 = length;
        if (a4 && length > a4)
        {
          size_t length = a4;
          size_t v10 = a4;
        }
        uint64_t result = CMBlockBufferCreateWithMemoryBlock(a1, (void *)result, v10, 0, &customBlockSource, 0, v10, 0, &blockBufferOut);
        if (!result)
        {
          xpc_retain(xdict);
          uint64_t result = 0;
        }
      }
      goto LABEL_10;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a5) {
LABEL_10:
    }
      *a5 = blockBufferOut;
  }
  return result;
}

uint64_t FigXPCMessageCreateBlockBufferData(const __CFAllocator *a1, void *a2, char *a3, CMBlockBufferRef *a4)
{
  return FigXPCMessageCreateBlockBufferDataWithSize(a1, a2, a3, 0, a4);
}

uint64_t FigXPCMessageSetBlockBuffer(void *a1, char *a2, CMBlockBufferRef theBuffer)
{
  vm_address_t address = 0;
  size_t totalLengthOut = 0;
  dataPointerOut = 0;
  size_t lengthAtOffsetOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  int v13 = 0;
  CFTypeID v3 = (vm_map_t *)MEMORY[0x1E4F14960];
  if (!theBuffer)
  {
LABEL_17:
    uint64_t v10 = 0;
    goto LABEL_18;
  }
  if (!a1 || !a2)
  {
    uint64_t v12 = 4294950016;
LABEL_25:
    uint64_t DataPointer = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_26;
  }
  size_t v8 = totalLengthOut;
  if (!totalLengthOut)
  {
    uint64_t v12 = 4294954590;
    goto LABEL_25;
  }
  if (totalLengthOut >= *MEMORY[0x1E4F14B00])
  {
    uint64_t DataPointer = vm_allocate(*v3, &address, totalLengthOut, 1543503873);
    if (!DataPointer)
    {
      uint64_t DataPointer = CMBlockBufferCopyDataBytes(theBuffer, 0, totalLengthOut, (void *)address);
      if (!DataPointer)
      {
        uint64_t v9 = FigXPCMessageSetAndConsumeVMData(a1, a2, (void *)address, totalLengthOut);
        vm_address_t address = 0;
        if (v9)
        {
          uint64_t v10 = v9;
          goto LABEL_20;
        }
        goto LABEL_15;
      }
    }
  }
  else
  {
    if (lengthAtOffsetOut == totalLengthOut)
    {
LABEL_11:
      xpc_dictionary_set_data(a1, a2, dataPointerOut, v8);
LABEL_15:
      FigXPCMessageGetOpCode(a1, &v13);
      if (gGMFigKTraceEnabled == 1)
      {
        strncpy(__dst, a2, 8uLL);
        kdebug_trace();
      }
      goto LABEL_17;
    }
    uint64_t DataPointer = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, totalLengthOut, 0, &blockBufferOut);
    if (!DataPointer)
    {
      uint64_t DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
      if (!DataPointer)
      {
        size_t v8 = totalLengthOut;
        goto LABEL_11;
      }
    }
  }
LABEL_26:
  uint64_t v10 = DataPointer;
LABEL_18:
  if (address) {
    MEMORY[0x192FC66D0](*v3, address, totalLengthOut);
  }
LABEL_20:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v10;
}

uint64_t FigXPCMessageSetCMTime(void *a1, const char *a2, const void *a3)
{
  if (a1 && a2)
  {
    xpc_dictionary_set_data(a1, a2, a3, 0x18uLL);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCMessageGetCMTime(void *a1, const char *a2, uint64_t a3)
{
  size_t length = 0;
  long long v7 = *(_OWORD *)&kCMTimeInvalid.value;
  uint64_t v8 = 0;
  if (a1 && a2)
  {
    if (a3)
    {
      CFDataRef data = xpc_dictionary_get_data(a1, a2, &length);
      if (data)
      {
        if (length == 24)
        {
          CFTypeRef v5 = data;
          uint64_t result = 0;
          long long v7 = *(_OWORD *)v5;
          uint64_t v8 = v5[2];
        }
        else
        {
          uint64_t result = FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        uint64_t result = 4294950011;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3)
    {
LABEL_7:
      *(_OWORD *)a3 = v7;
      *(void *)(a3 + 16) = v8;
    }
  }
  return result;
}

uint64_t FigXPCArraySetCMTime(void *a1, uint64_t a2, const void *a3)
{
  if (a1 && a2 == -1 && (xpc_array_get_count(a1) & 0x80000000) == 0)
  {
    xpc_array_set_data(a1, 0xFFFFFFFFFFFFFFFFLL, a3, 0x18uLL);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCArrayAppendCMTime(void *a1, long long *a2)
{
  long long v3 = *a2;
  uint64_t v4 = *((void *)a2 + 2);
  return FigXPCArraySetCMTime(a1, -1, &v3);
}

uint64_t FigXPCArrayGetCMTime(void *a1, int64_t a2, uint64_t a3)
{
  size_t length = 0;
  long long v10 = *(_OWORD *)&kCMTimeInvalid.value;
  uint64_t v11 = 0;
  if (!a1 || a2 < 0)
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3) {
      goto LABEL_8;
    }
  }
  else
  {
    if (a3)
    {
      if (a2 >= (int)xpc_array_get_count(a1))
      {
        uint64_t v9 = 4294950016;
      }
      else
      {
        CFDataRef data = xpc_array_get_data(a1, a2, &length);
        if (!data)
        {
          uint64_t result = 4294950013;
          goto LABEL_8;
        }
        if (length == 24)
        {
          long long v7 = data;
          uint64_t result = 0;
          long long v10 = *(_OWORD *)v7;
          uint64_t v11 = v7[2];
LABEL_8:
          *(_OWORD *)a3 = v10;
          *(void *)(a3 + 16) = v11;
          return result;
        }
        uint64_t v9 = 4294950012;
      }
      uint64_t result = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
      goto LABEL_8;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPCMessageSetCMTimeRange(void *a1, const char *a2, const void *a3)
{
  if (a1 && a2)
  {
    xpc_dictionary_set_data(a1, a2, a3, 0x30uLL);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCMessageGetCMTimeRange(void *a1, const char *a2, CMTimeRange *a3)
{
  size_t length = 0;
  CMTimeRange v7 = kCMTimeRangeInvalid;
  if (a1 && a2)
  {
    if (a3)
    {
      CFDataRef data = (CMTimeRange *)xpc_dictionary_get_data(a1, a2, &length);
      if (data)
      {
        if (length == 48)
        {
          CFTypeRef v5 = data;
          uint64_t result = 0;
          CMTimeRange v7 = *v5;
        }
        else
        {
          uint64_t result = FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        uint64_t result = 4294950011;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3) {
LABEL_7:
    }
      *a3 = v7;
  }
  return result;
}

uint64_t FigXPCMessageSetCMTimeMapping(void *a1, const char *a2, const void *a3)
{
  if (a1 && a2)
  {
    xpc_dictionary_set_data(a1, a2, a3, 0x60uLL);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCMessageGetCMTimeMapping(void *a1, const char *a2, CMTimeMapping *a3)
{
  size_t length = 0;
  CMTimeMapping v7 = kCMTimeMappingInvalid;
  if (a1 && a2)
  {
    if (a3)
    {
      CFDataRef data = (CMTimeMapping *)xpc_dictionary_get_data(a1, a2, &length);
      if (data)
      {
        if (length == 96)
        {
          CFTypeRef v5 = data;
          uint64_t result = 0;
          CMTimeMapping v7 = *v5;
        }
        else
        {
          uint64_t result = FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        uint64_t result = 4294950011;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3) {
LABEL_7:
    }
      *a3 = v7;
  }
  return result;
}

void FigXPCMessageSetOSStatus(void *a1, const char *a2, int a3)
{
  if (a1 && a2) {
    xpc_dictionary_set_int64(a1, a2, a3);
  }
  else {
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

int64_t FigXPCMessageGetOSStatus(void *a1, const char *a2)
{
  if (a1)
  {
    if (a2)
    {
      int64_t result = xpc_dictionary_get_int64(a1, a2);
      uint64_t v2 = vars8;
      if (result == (int)result) {
        return result;
      }
      uint64_t v4 = 4294950013;
    }
    else
    {
      uint64_t v4 = 4294950016;
    }
  }
  else
  {
    uint64_t v4 = 4294950016;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

void FigXPCMessageSetInt32(void *a1, const char *a2, int a3)
{
  if (a1 && a2) {
    xpc_dictionary_set_int64(a1, a2, a3);
  }
  else {
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

int64_t FigXPCMessageGetInt32(void *a1, const char *a2)
{
  if (a1)
  {
    if (a2)
    {
      int64_t result = xpc_dictionary_get_int64(a1, a2);
      if (result == (int)result) {
        return result;
      }
      uint64_t v3 = 4294950013;
    }
    else
    {
      uint64_t v3 = 4294950016;
    }
  }
  else
  {
    uint64_t v3 = 4294950016;
  }
  FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  return 0;
}

void FigXPCMessageSetUInt32(void *a1, const char *a2, uint64_t value)
{
  if (a1 && a2) {
    xpc_dictionary_set_uint64(a1, a2, value);
  }
  else {
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCMessageGetUInt32(void *a1, const char *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t result = xpc_dictionary_get_uint64(a1, a2);
      if (!HIDWORD(result)) {
        return result;
      }
      uint64_t v3 = 4294950013;
    }
    else
    {
      uint64_t v3 = 4294950016;
    }
  }
  else
  {
    uint64_t v3 = 4294950016;
  }
  FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigXPCMessageSetFormatDescriptionArray(void *a1, const char *a2, const __CFArray *a3)
{
  CFTypeID v6 = 0;
  vm_size_t v7 = 0;
  if (!a3) {
    return 0;
  }
  if (a1 && a2)
  {
    uint64_t result = FigRemote_CreateSerializedAtomDataForFormatDescriptions(a3, (uint64_t *)&v6, *MEMORY[0x1E4F14B00], &v7);
    if (result) {
      return result;
    }
    xpc_dictionary_set_data(a1, a2, v6, v7);
    MEMORY[0x192FC66D0](*MEMORY[0x1E4F14960], v6, v7);
    return 0;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyFormatDescriptionArray(void *a1, const char *a2, __CFArray **a3)
{
  size_t v6 = 0;
  vm_size_t v7 = 0;
  if (a1 && a2)
  {
    if (a3)
    {
      uint64_t result = (uint64_t)xpc_dictionary_get_data(a1, a2, &v6);
      if (result)
      {
        uint64_t result = FigRemote_CreateFormatDescriptionArrayFromSerializedAtomData(result, v6, &v7);
        CFTypeRef v5 = v7;
      }
      else
      {
        CFTypeRef v5 = 0;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    CFTypeRef v5 = 0;
    if (a3) {
LABEL_7:
    }
      *a3 = v5;
  }
  return result;
}

uint64_t FigXPCMessageSetFormatDescription(void *a1, char *a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  if (!a3) {
    return 0;
  }
  if (a1 && a2)
  {
    uint64_t SerializedAtomDataBlockBufferForFormatDescription = FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3, (CMBlockBufferRef *)&cf);
    CFTypeRef v6 = cf;
    if (SerializedAtomDataBlockBufferForFormatDescription)
    {
      uint64_t v7 = SerializedAtomDataBlockBufferForFormatDescription;
      if (!cf) {
        return v7;
      }
    }
    else
    {
      uint64_t v7 = FigXPCMessageSetBlockBuffer(a1, a2, (CMBlockBufferRef)cf);
      CFTypeRef v6 = cf;
      if (!cf) {
        return v7;
      }
    }
    CFRelease(v6);
    return v7;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyFormatDescription2(const __CFAllocator *a1, void *a2, char *a3, void *a4)
{
  uint64_t v10 = 0;
  CFTypeRef cf = 0;
  if (!a2 || !a3)
  {
    uint64_t BlockBufferDataWithSize = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a4) {
      *a4 = 0;
    }
    return BlockBufferDataWithSize;
  }
  if (a4)
  {
    uint64_t BlockBufferDataWithSize = FigXPCMessageCreateBlockBufferDataWithSize(a1, a2, a3, 0, (CMBlockBufferRef *)&cf);
    uint64_t v7 = 0;
    CFTypeRef v8 = cf;
    if (!BlockBufferDataWithSize && cf)
    {
      uint64_t BlockBufferDataWithSize = FigRemote_CreateFormatDescriptionFromSerializedAtomDataBlockBuffer(a1, (CMBlockBufferRef)cf, 0, &v10);
      uint64_t v7 = v10;
      CFTypeRef v8 = cf;
    }
    *a4 = v7;
    if (v8) {
      CFRelease(v8);
    }
    return BlockBufferDataWithSize;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyFormatDescription(void *a1, char *a2, void *a3)
{
  return FigXPCMessageCopyFormatDescription2((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1, a2, a3);
}

BOOL FigXPCConnectionHasEntitlement(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2)
  {
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v2 = xpc_connection_copy_entitlement_value();
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (void *)v2;
  BOOL v4 = MEMORY[0x192FC6B30]() == MEMORY[0x1E4F14570] && xpc_BOOL_get_value(v3);
  xpc_release(v3);
  return v4;
}

xpc_object_t FigXPCArrayGetCount(xpc_object_t xarray)
{
  if (xarray) {
    return (xpc_object_t)xpc_array_get_count(xarray);
  }
  return xarray;
}

uint64_t FigXPCMessageSetBlockBufferUsingMemoryOrigin(void *a1, const char *a2, CMBlockBufferRef theBuffer, uint64_t a4, uint64_t *a5)
{
  CMBlockBufferRef theBuffera = 0;
  if (theBuffer)
  {
    uint64_t v10 = *a5;
    if (!CMBlockBufferGetDataLength(theBuffer)) {
      return 0;
    }
    if (FigMemoryOriginIsBlockBufferSendable(a4, theBuffer))
    {
      return FigMemoryOriginSetBlockBufferInXPCMessage(a4, a1, a2, theBuffer);
    }
    int v18 = 0;
    vm_address_t DataLength = CMBlockBufferGetDataLength(theBuffer);
    dataPointerOut = 0;
    if (!v10)
    {
      uint64_t v15 = FigCopyCommonMemoryPool();
      if (!v15)
      {
        uint64_t v16 = FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
LABEL_16:
        uint64_t v12 = v16;
        if (theBuffera) {
          CFRelease(theBuffera);
        }
        return v12;
      }
      uint64_t v10 = (uint64_t)v15;
      *a5 = (uint64_t)v15;
    }
    uint64_t v16 = (uint64_t)FigMemoryPoolCreateBlockBuffer(v10, DataLength, &theBuffera, v13);
    if (!v16)
    {
      CMBlockBufferGetDataPointer(theBuffera, 0, 0, 0, &dataPointerOut);
      uint64_t v16 = CMBlockBufferCopyDataBytes(theBuffer, 0, DataLength, dataPointerOut);
      if (!v16)
      {
        FigXPCMessageGetOpCode(a1, &v18);
        if (gGMFigKTraceEnabled == 1) {
          kdebug_trace();
        }
        uint64_t v16 = FigMemoryOriginSetBlockBufferInXPCMessage(a4, a1, a2, theBuffera);
      }
    }
    goto LABEL_16;
  }

  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyBlockBufferUsingMemoryRecipient(const __CFAllocator *a1, xpc_object_t xdict, char *key, uint64_t a4, CMBlockBufferRef *a5)
{
  if (xdict && key && a4 && a5) {
    return FigMemoryRecipientCopyBlockBufferFromXPCMessage(a1, a4, xdict, key, a5);
  }
  else {
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

OpaqueCMBlockBuffer *FigXPCMessageAddDataBufferFromCMSampleBuffer(void *a1, CMSampleBufferRef sbuf, uint64_t a3, uint64_t *a4)
{
  if (sbuf && CMSampleBufferDataIsReady(sbuf) == 1)
  {
    uint64_t result = CMSampleBufferGetDataBuffer(sbuf);
    if (result)
    {
      uint64_t v9 = result;
      if (CMBlockBufferGetDataLength(result) > 0x3000)
      {
        return (OpaqueCMBlockBuffer *)FigXPCMessageSetBlockBufferUsingMemoryOrigin(a1, "SampleData-PooledBBuf", v9, a3, a4);
      }
      else
      {
        return (OpaqueCMBlockBuffer *)FigXPCMessageSetBlockBuffer(a1, "SampleData-Inline", v9);
      }
    }
  }
  else
  {
    return (OpaqueCMBlockBuffer *)FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPCMessageAddCMSampleBufferForPID(void *a1, CMSampleBufferRef sbuf, const __CFArray *a3, unsigned int a4, uint64_t a5, const opaqueCMFormatDescription **a6, uint64_t *a7, int a8)
{
  CFTypeRef v33 = 0;
  CFTypeRef v8 = *a6;
  size_t size = 0;
  CFTypeRef cf = 0;
  uint64_t v9 = *a7;
  dataPointerOut = 0;
  CMBlockBufferRef theBuffer = 0;
  CFTypeRef v34 = 0;
  CFTypeRef v35 = 0;
  if (!sbuf)
  {
    uint64_t v31 = 4294951145;
LABEL_44:
    CopyWithNoCFDataRef Data = FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
    goto LABEL_45;
  }
  char v17 = a4;
  if (CMSampleBufferDataIsReady(sbuf))
  {
    CFTypeRef v35 = CFRetain(sbuf);
  }
  else
  {
    if ((a4 & 1) == 0 || (v17 & 2) == 0)
    {
      uint64_t v31 = 4294951145;
      goto LABEL_44;
    }
    CopyWithNoCFDataRef Data = FigSampleBufferCreateCopyWithNoData((const __CFAllocator *)*MEMORY[0x1E4F1CF80], sbuf, (CMSampleBufferRef *)&v35);
    if (CopyWithNoData) {
      goto LABEL_45;
    }
  }
  if (!v9)
  {
    int v19 = FigCopyCommonMemoryPool();
    if (!v19)
    {
LABEL_42:
      uint64_t v31 = 4294951146;
      goto LABEL_44;
    }
    uint64_t v9 = (uint64_t)v19;
    *a7 = (uint64_t)v19;
  }
  CopyWithNoCFDataRef Data = FigRemote_CopyReplacementAttachmentsForSampleBuffer(v35, a3, (__CFDictionary **)&v34, (__CFDictionary **)&v33);
  if (CopyWithNoData) {
    goto LABEL_45;
  }
  unsigned int v20 = (a4 >> 2) & 1;
  CopyWithNoCFDataRef Data = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v35, (const __CFDictionary *)v34, (const __CFDictionary *)v33, v20, 0, 0, &size, v8, 0, a8);
  if (CopyWithNoData) {
    goto LABEL_45;
  }
  size_t v22 = size;
  if (size <= 0x3000)
  {
    id v23 = (char *)malloc_type_calloc(1uLL, size, 0x17D1D8E2uLL);
    dataPointerOut = v23;
    if (v23)
    {
      id v24 = v23;
      uint64_t v25 = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v35, (const __CFDictionary *)v34, (const __CFDictionary *)v33, v20, (uint64_t)v23, size, 0, v8, &cf, a8);
      if (v25)
      {
        uint64_t v29 = v25;
LABEL_29:
        free(v24);
        goto LABEL_30;
      }
      xpc_dictionary_set_data(a1, "SerializedMetadata-Inline", v24, size);
      if ((v17 & 2) != 0) {
        goto LABEL_22;
      }
LABEL_21:
      int64_t v26 = FigXPCMessageAddDataBufferFromCMSampleBuffer(a1, (CMSampleBufferRef)v35, a5, a7);
      if (v26)
      {
        uint64_t v29 = (uint64_t)v26;
LABEL_27:
        if (v22 > 0x3000) {
          goto LABEL_30;
        }
        id v24 = dataPointerOut;
        goto LABEL_29;
      }
LABEL_22:
      CFNumberRef v27 = *a6;
      CFTypeRef v28 = cf;
      *a6 = (const opaqueCMFormatDescription *)cf;
      if (v28) {
        CFRetain(v28);
      }
      if (v27) {
        CFRelease(v27);
      }
      uint64_t v29 = 0;
      goto LABEL_27;
    }
    goto LABEL_42;
  }
  CopyWithNoCFDataRef Data = (uint64_t)FigMemoryPoolCreateBlockBuffer(v9, size, &theBuffer, v21);
  if (!CopyWithNoData)
  {
    CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    CopyWithNoCFDataRef Data = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v35, (const __CFDictionary *)v34, (const __CFDictionary *)v33, v20, (uint64_t)dataPointerOut, size, 0, v8, &cf, a8);
    if (!CopyWithNoData)
    {
      CopyWithNoCFDataRef Data = FigMemoryOriginSetBlockBufferInXPCMessage(a5, a1, "SerializedMetadata-PooledBBuf", theBuffer);
      if (!CopyWithNoData)
      {
        if ((v17 & 2) != 0) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
    }
  }
LABEL_45:
  uint64_t v29 = CopyWithNoData;
LABEL_30:
  if (v34) {
    CFRelease(v34);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v35) {
    CFRelease(v35);
  }
  return v29;
}

uint64_t FigXPCMessageAddCMSampleBuffer(void *a1, opaqueCMSampleBuffer *a2, unsigned int a3, uint64_t a4, const opaqueCMFormatDescription **a5, uint64_t *a6)
{
  return FigXPCMessageAddCMSampleBufferForPID(a1, a2, 0, a3, a4, a5, a6, 0);
}

uint64_t FigXPCMessageCopyDataBufferFromCMSampleBufferMessage(const __CFAllocator *a1, void *a2, uint64_t a3, CMBlockBufferRef *a4)
{
  CMBlockBufferRef v8 = 0;
  if (a4)
  {
    uint64_t result = FigXPCMessageCopyBlockBufferUsingMemoryRecipient(a1, a2, "SampleData-PooledBBuf", a3, &v8);
    if (result) {
      return result;
    }
    CMBlockBufferRef v7 = v8;
    if (!v8)
    {
      uint64_t result = FigXPCMessageCreateBlockBufferDataWithSize((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2, "SampleData-Inline", 0, &v8);
      if (result) {
        return result;
      }
      CMBlockBufferRef v7 = v8;
    }
    uint64_t result = 0;
    *a4 = v7;
  }
  else
  {
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPCMessageCopyCMSampleBufferWithLastCryptor(const __CFAllocator *a1, xpc_object_t xdict, uint64_t a3, char a4, const opaqueCMFormatDescription **a5, CFTypeRef *a6, CMSampleBufferRef *a7)
{
  dataPointerOut = 0;
  CMBlockBufferRef theBuffer = 0;
  CFTypeRef cf = 0;
  size_t length = 0;
  uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigMemoryRecipientCopyBlockBufferFromXPCMessage(a1, a3, xdict, "SerializedMetadata-PooledBBuf", &theBuffer);
  if (!SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor)
  {
    if (theBuffer)
    {
      CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
      size_t length = CMBlockBufferGetDataLength(theBuffer);
    }
    else
    {
      dataPointerOut = (char *)xpc_dictionary_get_data(xdict, "SerializedMetadata-Inline", &length);
    }
    uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigXPCMessageCopyDataBufferFromCMSampleBufferMessage(a1, xdict, a3, (CMBlockBufferRef *)&cf);
    if (!SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor) {
      uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(a1, dataPointerOut, (const __CFAllocator *)length, (a4 & 1) == 0, (OpaqueCMBlockBuffer *)cf, a5, a6, a7);
    }
  }
  uint64_t v15 = SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor;
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

uint64_t FigXPCMessageCopyCMSampleBuffer(const __CFAllocator *a1, void *a2, uint64_t a3, char a4, const opaqueCMFormatDescription **a5, CMSampleBufferRef *a6)
{
  return FigXPCMessageCopyCMSampleBufferWithLastCryptor(a1, a2, a3, a4, a5, 0, a6);
}

uint64_t FigMetricEventTimelineGetClassID()
{
  if (sRegisterFigMetricEventTimelineClassIDOnce != -1) {
    dispatch_once_f(&sRegisterFigMetricEventTimelineClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventTimelineType);
  }
  return sFigMetricEventTimelineClassID;
}

uint64_t RegisterFigMetricEventTimelineType()
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigMetricEventTimelineClassDesc, ClassID, 1, &sFigMetricEventTimelineClassID);
}

uint64_t FigMetricEventTimelineGetTypeID()
{
  if (sRegisterFigMetricEventTimelineClassIDOnce != -1) {
    dispatch_once_f(&sRegisterFigMetricEventTimelineClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventTimelineType);
  }
  uint64_t v0 = (void *)sFigMetricEventTimelineClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigMetricEventTimelineCreate(uint64_t a1, uint64_t a2, uint64_t *a3, const void *a4, const void *a5, CFTypeRef *a6)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (a6)
  {
    if (sRegisterFigMetricEventTimelineClassIDOnce != -1) {
      dispatch_once_f(&sRegisterFigMetricEventTimelineClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventTimelineType);
    }
    uint64_t v12 = CMDerivedObjectCreate(a1, (uint64_t)&kigMetricEventTimeline_VTable, (void *)sFigMetricEventTimelineClassID, &cf);
    if (!v12)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      if (a2 < 1)
      {
        size_t v18 = 0;
      }
      else
      {
        uint64_t v14 = 0;
        uint64_t v15 = a3;
        uint64_t v16 = a2;
        do
        {
          uint64_t v17 = *v15++;
          v14 += v17;
          --v16;
        }
        while (v16);
        size_t v18 = 8 * v14;
      }
      MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
      unsigned int v20 = malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, v18, 0x10040436913F5uLL);
      DerivedStorage[5] = v20;
      if (v20)
      {
        CFTypeRef v21 = a4 ? CFRetain(a4) : 0;
        DerivedStorage[8] = v21;
        if (a2 < 1)
        {
          uint64_t v22 = 0;
        }
        else
        {
          uint64_t v22 = 0;
          id v23 = (void *)DerivedStorage[5];
          uint64_t v24 = a2;
          do
          {
            *v23++ = v22;
            uint64_t v25 = *a3++;
            v22 += v25;
            --v24;
          }
          while (v24);
        }
        int64_t v26 = (malloc_zone_t *)FigGetMallocZoneForMedia();
        CFNumberRef v27 = malloc_type_zone_calloc(v26, 1uLL, 8 * v22, 0x80040B8603338uLL);
        DerivedStorage[6] = v27;
        if (v27)
        {
          DerivedStorage[2] = v22;
          DerivedStorage[3] = a2;
          CFTypeRef v28 = a5 ? CFRetain(a5) : 0;
          DerivedStorage[4] = v28;
          CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          DerivedStorage[1] = Mutable;
          if (Mutable)
          {
            dispatch_queue_t v31 = dispatch_queue_create("com.apple.coremedia.figmetriceventtimeline", 0);
            void *DerivedStorage = v31;
            if (v31)
            {
              if (dword_1E9273018)
              {
                int v40 = 0;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9273010, 1, &v40, &type);
                int v33 = v40;
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
                  unsigned int v35 = v33;
                }
                else {
                  unsigned int v35 = v33 & 0xFFFFFFFE;
                }
                if (v35)
                {
                  int v42 = 136315394;
                  BOOL v43 = "FigMetricEventTimelineCreate";
                  __int16 v44 = 2048;
                  CFTypeRef v45 = cf;
                  CFStringRef v36 = (char *)_os_log_send_and_compose_impl();
                  LOBYTE(v33) = v40;
                }
                else
                {
                  CFStringRef v36 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9273010, 1u, 1, v36, v36 != &v46, v33, 0, v34);
              }
              uint64_t v37 = 0;
              *a6 = cf;
              return v37;
            }
          }
        }
      }
      uint64_t v12 = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v37 = v12;
    if (cf) {
      CFRelease(cf);
    }
    return v37;
  }

  return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
}

CFStringRef met_copyFormattingDesc(uint64_t a1)
{
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, @"[FigMetricEventTimeline %p]", a1);
}

uint64_t met_invalidate(void *a1)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  dispatch_sync_f(*DerivedStorage, a1, (dispatch_function_t)met_invalidateOnQueue);
  return 0;
}

void met_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v3 = *(const void **)(DerivedStorage + 32);
  if (v3) {
    CFRelease(v3);
  }
  met_invalidateOnQueue(a1);
  BOOL v4 = *(NSObject **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    dispatch_release(v4);
  }
}

CFStringRef met_copyDebugDesc(uint64_t a1)
{
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, @"[FigMetricEventTimeline %p]", a1);
}

uint64_t met_setProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v6 = 4294954516;
  if (a2 && a3)
  {
    v8[0] = DerivedStorage;
    v8[1] = a2;
    int v8[2] = a3;
    uint64_t v9 = 0;
    dispatch_sync_f(*DerivedStorage, v8, (dispatch_function_t)met_setPropertyOnQueue);
    return v9;
  }
  return v6;
}

void met_invalidateOnQueue(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(unsigned char *)(CMBaseObjectGetDerivedStorage(a1) + 56))
  {
    *(unsigned char *)(DerivedStorage + 56) = 1;
    uint64_t v3 = *(const void **)(DerivedStorage + 8);
    if (v3) {
      CFRelease(v3);
    }
    BOOL v4 = *(const void **)(DerivedStorage + 64);
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = *(void *)(DerivedStorage + 16);
    if (v5 >= 1)
    {
      for (uint64_t i = 0; i < v5; ++i)
      {
        CMBlockBufferRef v7 = *(const void **)(*(void *)(DerivedStorage + 48) + 8 * i);
        if (v7)
        {
          CFRelease(v7);
          uint64_t v5 = *(void *)(DerivedStorage + 16);
        }
      }
    }
    MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
    malloc_zone_free(MallocZoneForMedia, *(void **)(DerivedStorage + 48));
    uint64_t v9 = (malloc_zone_t *)FigGetMallocZoneForMedia();
    uint64_t v10 = *(void **)(DerivedStorage + 40);
    malloc_zone_free(v9, v10);
  }
}

void met_setPropertyOnQueue(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  if (FigCFEqual(*(CFTypeRef *)(a1 + 8), @"MetricEventTimelineProperty_Timebase"))
  {
    uint64_t v2 = *(const void **)(*(void *)a1 + 32);
    uint64_t v3 = *(const void **)(a1 + 16);
    *(void *)(*(void *)a1 + 32) = v3;
    if (!v3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (!FigCFEqual(*(CFTypeRef *)(a1 + 8), @"MetricEventTimelineProperty_SessionID"))
  {
    *(_DWORD *)(a1 + 24) = -12787;
    return;
  }
  uint64_t v2 = *(const void **)(*(void *)a1 + 64);
  uint64_t v3 = *(const void **)(a1 + 16);
  *(void *)(*(void *)a1 + 64) = v3;
  if (v3) {
LABEL_3:
  }
    CFRetain(v3);
LABEL_4:
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t met_registerSubscriber(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v13 = 0;
  long long v12 = 0u;
  long long v11 = 0u;
  if (a1 && a2 && a3 && a4)
  {
    context[0] = a1;
    context[1] = a2;
    void context[2] = a3;
    _OWORD context[3] = a4;
    dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_registerSubscriberDispatch);
    return v13;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t met_subscribeByEventID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v12 = 0;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  if (a1 && a2)
  {
    context[0] = a1;
    context[1] = a2;
    *(void *)&long long v10 = a3;
    dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_subscribeByEventIDOnQueue);
    return v12;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t met_subscribeByClassID(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v12 = 0;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  if (a1 && a2)
  {
    context[0] = a1;
    context[1] = a2;
    BYTE8(v10) = a3;
    dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_subscribeByClassIDOnQueue);
    return v12;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t met_subscribetoAllEvents(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v10 = 0;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v7 = 0u;
  if (a1 && a2)
  {
    context[0] = a1;
    context[1] = a2;
    dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_subscribeToAllEventsOnQueue);
    return v10;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t met_publishEvent_0(const void *a1, const void *a2, const void *a3)
{
  void (*v26)(long long *__return_ptr, const void *);
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(const void *);
  uint64_t v30;
  uint64_t v31;
  uint64_t (*v32)(const void *);
  pthread_mutex_t **v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(const void *, CMTime *);
  uint64_t v37;
  uint64_t v38;
  void (*v39)(const void *);
  malloc_zone_t *MallocZoneForMedia;
  void *v41;
  void *v42;
  CMTime v44;
  CMTime v45;
  long long v46;
  uint64_t v47;
  CMTime v48;
  uint64_t vars8;

  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1 && a2 && a3)
  {
    long long v7 = (dispatch_queue_t *)DerivedStorage;
    uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a3) + 16);
    if (v8) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(const void *))(v9 + 40);
    if (v10 && (uint64_t v11 = v10(a3)) != 0)
    {
      uint64_t v12 = (const void *)v11;
      char v13 = 0;
    }
    else
    {
      uint64_t v14 = *(void *)(CMBaseObjectGetVTable((uint64_t)a3) + 16);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v16 = *(unsigned int (**)(const void *))(v15 + 16);
      if (v16 && v16(a3))
      {
        uint64_t v17 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 16);
        uint64_t v18 = v17 ? v17 : 0;
        int v19 = *(uint64_t (**)(const void *))(v18 + 48);
        uint64_t v20 = v19 ? v19(a1) : 0;
        uint64_t v21 = *(void *)(CMBaseObjectGetVTable((uint64_t)a3) + 16);
        uint64_t v22 = v21 ? v21 : 0;
        id v23 = *(void (**)(const void *, uint64_t))(v22 + 48);
        if (v23) {
          v23(a3, v20);
        }
      }
      uint64_t v12 = 0;
      char v13 = 1;
    }
    uint64_t v24 = *(void *)(CMBaseObjectGetVTable((uint64_t)a3) + 16);
    if (v24) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = 0;
    }
    int64_t v26 = *(void (**)(long long *__return_ptr, const void *))(v25 + 56);
    if (v26)
    {
      v26(&v46, a3);
    }
    else
    {
      char v46 = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v47 = 0;
    }
    if ((BYTE12(v46) & 1) == 0)
    {
      CFNumberRef v27 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 16);
      CFTypeRef v28 = v27 ? v27 : 0;
      uint64_t v29 = *(uint64_t (**)(const void *))(v28 + 56);
      if (v29 && v29(a1))
      {
        memset(&v45, 0, sizeof(v45));
        int v30 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 16);
        dispatch_queue_t v31 = v30 ? v30 : 0;
        uint64_t v32 = *(uint64_t (**)(const void *))(v31 + 56);
        int v33 = v32 ? (pthread_mutex_t **)v32(a1) : 0;
        CMTimebaseGetTimeClampedAboveAnchorTime(v33, 0, &v45);
        __int16 v44 = v45;
        uint64_t v34 = *(void *)(CMBaseObjectGetVTable((uint64_t)a3) + 16);
        unsigned int v35 = v34 ? v34 : 0;
        CFStringRef v36 = *(void (**)(const void *, CMTime *))(v35 + 64);
        if (v36)
        {
          uint64_t v48 = v44;
          v36(a3, &v48);
        }
      }
    }
    uint64_t v37 = *(void *)(CMBaseObjectGetVTable((uint64_t)a3) + 16);
    if (v37) {
      CMMemoryPoolRef v38 = v37;
    }
    else {
      CMMemoryPoolRef v38 = 0;
    }
    CFTypeRef v39 = *(void (**)(const void *))(v38 + 8);
    if (v39) {
      v39(a3);
    }
    if ((v13 & 1) == 0) {
      CFRelease(v12);
    }
    MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
    int v41 = malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, 0x48uLL, 0x10E0040608237F2uLL);
    if (v41)
    {
      int v42 = v41;
      *int v41 = CFRetain(a1);
      v42[6] = CFRetain(a2);
      v42[7] = CFRetain(a3);
      dispatch_async_f(*v7, v42, (dispatch_function_t)met_publishEventDispatch);
      return 0;
    }
    else
    {
      return FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t met_getSessionID(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  v2[0] = CMBaseObjectGetDerivedStorage(a1);
  v2[1] = 0;
  dispatch_sync_f(*(dispatch_queue_t *)v2[0], v2, (dispatch_function_t)met_getSessionIDOnQueue);
  return v3;
}

uint64_t met_getTimebase(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  v2[0] = CMBaseObjectGetDerivedStorage(a1);
  v2[1] = 0;
  dispatch_sync_f(*(dispatch_queue_t *)v2[0], v2, (dispatch_function_t)met_getTimebaseOnQueue);
  return v3;
}

uint64_t met_registerSubscriberDispatch(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)a1);
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 8), v2))
  {
    FigGetAllocatorForMedia();
    long long v10 = xmmword_1E567F2B8;
    if (metSubscriberCallbackData_getTypeID_once != -1) {
      dispatch_once_f(&metSubscriberCallbackData_getTypeID_once, &v10, (dispatch_function_t)metutil_registerClass_0);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      long long v7 = (void *)Instance;
      if (v2) {
        CFTypeRef v8 = CFRetain(v2);
      }
      else {
        CFTypeRef v8 = 0;
      }
      _OWORD v7[2] = v8;
      v7[3] = v3;
      v7[4] = v4;
      if (v4) {
        dispatch_retain(v4);
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 8), v2, v7);
      CFRelease(v7);
    }
    else
    {
      uint64_t result = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
      if (result) {
        goto LABEL_12;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 8), v2, 0);
    }
  }
  uint64_t result = 0;
LABEL_12:
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

void metSubscriberCallbackData_finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 32);
  if (v3)
  {
    dispatch_release(v3);
  }
}

uint64_t metutil_registerClass_0(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 8) = result;
  return result;
}

uint64_t met_subscribeByEventIDOnQueue(uint64_t a1)
{
  uint64_t result = met_addSubscriberForEventID(*(void *)a1, *(void *)(a1 + 32), *(const void **)(a1 + 8));
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

uint64_t met_addSubscriberForEventID(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 8), a3);
  if (Value
    && (uint64_t v7 = *(void *)(*(void *)(DerivedStorage + 40) + 8 * (a2 >> 56)) + (a2 & 0xFFFFFFFFFFFFFFLL),
        v7 < *(void *)(DerivedStorage + 16)))
  {
    CFTypeRef v8 = Value;
    uint64_t v9 = *(__CFSet **)(*(void *)(DerivedStorage + 48) + 8 * v7);
    if (v9
      || (CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia(),
          *(void *)(*(void *)(DerivedStorage + 48) + 8 * v7) = CFSetCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D548]), (uint64_t v9 = *(__CFSet **)(*(void *)(DerivedStorage + 48) + 8 * v7)) != 0))
    {
      CFSetSetValue(v9, v8);
      return 0;
    }
    uint64_t v12 = 4294947845;
  }
  else
  {
    uint64_t v12 = 4294947844;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t met_subscribeByClassIDOnQueue(uint64_t a1)
{
  uint64_t v2 = *(char *)(a1 + 40);
  uint64_t v3 = *(const void **)(a1 + 8);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)a1);
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 8), v3);
  if (!Value
    || (uint64_t v6 = *(void *)(DerivedStorage + 40),
        uint64_t v7 = *(void *)(v6 + 8 * v2),
        uint64_t v8 = *(void *)(DerivedStorage + 16),
        v7 >= v8)
    || (uint64_t v9 = Value, v2 + 1 < *(void *)(DerivedStorage + 24))
    && (uint64_t v10 = *(void *)(v6 + 8 * (v2 + 1)), v11 = v10 <= v8, v8 = v10, !v11))
  {
    uint64_t v16 = 4294947844;
LABEL_14:
    uint64_t result = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  if (v7 < v8)
  {
    uint64_t v12 = (const CFSetCallBacks *)MEMORY[0x1E4F1D548];
    while (1)
    {
      char v13 = *(__CFSet **)(*(void *)(DerivedStorage + 48) + 8 * v7);
      if (!v13)
      {
        CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        *(void *)(*(void *)(DerivedStorage + 48) + 8 * v7) = CFSetCreateMutable(AllocatorForMedia, 0, v12);
        char v13 = *(__CFSet **)(*(void *)(DerivedStorage + 48) + 8 * v7);
        if (!v13) {
          break;
        }
      }
      CFSetSetValue(v13, v9);
      if (v8 == ++v7) {
        goto LABEL_11;
      }
    }
    uint64_t v16 = 4294947845;
    goto LABEL_14;
  }
LABEL_11:
  uint64_t result = 0;
LABEL_12:
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

uint64_t met_subscribeToAllEventsOnQueue(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(const void **)(a1 + 8);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)a1);
  if (*(uint64_t *)(DerivedStorage + 16) < 1)
  {
LABEL_5:
    uint64_t result = 0;
  }
  else
  {
    uint64_t v5 = DerivedStorage;
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t result = met_addSubscriberForEventID(v2, v6, v3);
      if (result) {
        break;
      }
      if (*(void *)(v5 + 16) <= ++v6) {
        goto LABEL_5;
      }
    }
  }
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

void met_publishEventDispatch(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(const void **)a1;
  uint64_t v3 = *(const void **)(a1 + 48);
  uint64_t v4 = *(const void **)(a1 + 56);
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable((uint64_t)v4) + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(const void *))(v6 + 24);
  if (v7) {
    uint64_t v8 = v7(v4);
  }
  else {
    uint64_t v8 = -12782;
  }
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)v2);
  uint64_t v10 = *(void *)(DerivedStorage[5] + 8 * (v8 >> 56)) + (v8 & 0xFFFFFFFFFFFFFFLL);
  if (v10 >= DerivedStorage[2])
  {
    uint64_t v35 = 4294947845;
LABEL_52:
    FigSignalErrorAt(v35, 0, 0, 0, 0, 0, 0);
    goto LABEL_53;
  }
  uint64_t v11 = DerivedStorage[6];
  CFSetRef v12 = *(const __CFSet **)(v11 + 8 * v10);
  if (v12)
  {
    CFIndex Count = CFSetGetCount(*(CFSetRef *)(v11 + 8 * v10));
    MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
    uint64_t v15 = (const void **)malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, 8 * Count, 0xC0040B8AA526DuLL);
    if (v15)
    {
      uint64_t v16 = v15;
      CFSetGetValues(v12, v15);
      if (Count < 1) {
        goto LABEL_41;
      }
      uint64_t v36 = v1;
      uint64_t v17 = 0;
      while (1)
      {
        uint64_t v18 = v16[v17];
        int v19 = (const void *)v18[2];
        if (v19) {
          CFTypeRef v20 = CFRetain(v19);
        }
        else {
          CFTypeRef v20 = 0;
        }
        uint64_t v21 = v18[3];
        uint64_t v22 = v18[4];
        if (v22) {
          dispatch_retain(v22);
        }
        if (v20)
        {
          uint64_t v23 = *(void *)(v21 + 8);
          if (v23
            && (v22 ? (BOOL v24 = v23 == 0) : (BOOL v24 = 1),
                !v24
             && (uint64_t v25 = (malloc_zone_t *)FigGetMallocZoneForMedia(),
                 (int64_t v26 = malloc_type_zone_calloc(v25, 1uLL, 0x28uLL, 0xE0040BA15B581uLL)) != 0)))
          {
            CFNumberRef v27 = v26;
            v26[1] = CFRetain(v20);
            v27[4] = v21;
            if (v2) {
              CFTypeRef v28 = CFRetain(v2);
            }
            else {
              CFTypeRef v28 = 0;
            }
            *CFNumberRef v27 = v28;
            if (v3) {
              CFTypeRef v29 = CFRetain(v3);
            }
            else {
              CFTypeRef v29 = 0;
            }
            v27[2] = v29;
            if (v4) {
              CFTypeRef v30 = CFRetain(v4);
            }
            else {
              CFTypeRef v30 = 0;
            }
            v27[3] = v30;
            dispatch_async_f(v22, v27, (dispatch_function_t)met_issueSubscriberCallbackOnCallbackQueue);
          }
          else
          {
            FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
          }
          CFRelease(v20);
          if (!v22) {
            goto LABEL_37;
          }
        }
        else
        {
          FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
          if (!v22) {
            goto LABEL_37;
          }
        }
        dispatch_release(v22);
LABEL_37:
        if (Count == ++v17)
        {
          uint64_t v1 = v36;
          goto LABEL_41;
        }
      }
    }
    uint64_t v35 = 4294954305;
    goto LABEL_52;
  }
LABEL_53:
  uint64_t v16 = 0;
LABEL_41:
  dispatch_queue_t v31 = (malloc_zone_t *)FigGetMallocZoneForMedia();
  malloc_zone_free(v31, v16);
  if (*(void *)v1) {
    CFRelease(*(CFTypeRef *)v1);
  }
  uint64_t v32 = *(const void **)(v1 + 48);
  if (v32) {
    CFRelease(v32);
  }
  int v33 = *(const void **)(v1 + 56);
  if (v33) {
    CFRelease(v33);
  }
  uint64_t v34 = (malloc_zone_t *)FigGetMallocZoneForMedia();

  malloc_zone_free(v34, (void *)v1);
}

void met_issueSubscriberCallbackOnCallbackQueue(void *a1)
{
  (*(void (**)(void, void, void, void))(a1[4] + 8))(a1[1], *a1, a1[2], a1[3]);
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  uint64_t v3 = (const void *)a1[2];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[3];
  if (v4) {
    CFRelease(v4);
  }
  MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();

  malloc_zone_free(MallocZoneForMedia, a1);
}

void *met_getSessionIDOnQueue(void *result)
{
  result[2] = *(void *)(*result + 64);
  return result;
}

void *met_getTimebaseOnQueue(void *result)
{
  result[2] = *(void *)(*result + 32);
  return result;
}

uint64_t FigEndpointCopyActiveEndpointOfType(const void *a1, void *a2)
{
  *(void *)uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v8 = 0;
  xpc_object_t v9 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce == -1)
  {
    if (!a1)
    {
LABEL_13:
      uint64_t SharedXPCClient = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
LABEL_14:
      uint64_t v5 = SharedXPCClient;
      xpc_object_t v6 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_57);
    if (!a1) {
      goto LABEL_13;
    }
  }
  if (!a2) {
    goto LABEL_13;
  }
  *a2 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(0, &v8);
  if (SharedXPCClient) {
    goto LABEL_14;
  }
  if (ensureActiveEndpointNotificationsRegistered_initNotifyOnce != -1) {
    dispatch_once(&ensureActiveEndpointNotificationsRegistered_initNotifyOnce, &__block_literal_global_15_0);
  }
  uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x61637476u, 0, v10);
  if (SharedXPCClient) {
    goto LABEL_14;
  }
  uint64_t SharedXPCClient = FigXPCMessageSetCFString(*(void **)v10, "EndpointType", a1);
  if (SharedXPCClient) {
    goto LABEL_14;
  }
  uint64_t v5 = FigXPCRemoteClientSendSyncMessageCreatingReply(v8, *(uint64_t *)v10, &v9);
  xpc_object_t v6 = v9;
  if (!v5)
  {
    uint64_t v5 = (uint64_t)FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v9, &v11, a2);
    xpc_object_t v6 = v9;
  }
LABEL_11:
  FigXPCRelease(v6);
  FigXPCRelease(*(xpc_object_t *)v10);
  return v5;
}

uint64_t remoteXPCFigEndpoint_getSharedXPCClient(unint64_t a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a1 > 1) {
    return 4294950576;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&remoteXPCFigEndpoint_getSharedXPCClient_lock);
  uint64_t v4 = (char *)&remoteXPCFigEndpoint_getSharedXPCClient_sSourceInfo[2 * a1];
  uint64_t v5 = (int *)(v4 + 8);
  if (*((_DWORD *)v4 + 2) || (uint64_t v13 = *(void *)v4) == 0)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_DeathNoticeName", @"Endpoint_ServerConnectionDied");
    CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_PrivilegedConnection", (const void *)*MEMORY[0x1E4F1CFD0]);
    int v25 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
    int v8 = v25;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v10 = v8;
    }
    else {
      unsigned int v10 = v8 & 0xFFFFFFFE;
    }
    if (v10)
    {
      uint64_t v11 = FigEndpointXPCServerNameForSource(a1);
      int v26 = 136315650;
      CFNumberRef v27 = "remoteXPCFigEndpoint_getSharedXPCClient";
      __int16 v28 = 2048;
      unint64_t v29 = a1;
      __int16 v30 = 2080;
      dispatch_queue_t v31 = v11;
      CFSetRef v12 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v25;
    }
    else
    {
      CFSetRef v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v12, v12 != v32, v8, 0, v9);
    uint64_t v15 = FigEndpointXPCServerNameForSource(a1);
    *uint64_t v5 = FigXPCRemoteClientCreate((uint64_t)v15, remoteXPCFigEndpoint_getSharedXPCClient_clientCallbacks, Mutable, &remoteXPCFigEndpoint_getSharedXPCClient_sSourceInfo[2 * a1]);
    int v25 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    uint64_t v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
    int v17 = v25;
    if (os_log_type_enabled(v16, type)) {
      unsigned int v19 = v17;
    }
    else {
      unsigned int v19 = v17 & 0xFFFFFFFE;
    }
    if (v19)
    {
      CFTypeRef v20 = FigEndpointXPCServerNameForSource(a1);
      int v21 = *v5;
      int v26 = 136315650;
      CFNumberRef v27 = "remoteXPCFigEndpoint_getSharedXPCClient";
      __int16 v28 = 2080;
      unint64_t v29 = (unint64_t)v20;
      __int16 v30 = 1024;
      LODWORD(v31) = v21;
      uint64_t v22 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v17) = v25;
    }
    else
    {
      uint64_t v22 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v22, v22 != v32, v17, 0, v18);
    if (Mutable) {
      CFRelease(Mutable);
    }
    uint64_t v13 = *(void *)v4;
    uint64_t v14 = *v5;
    if (!v13)
    {
      FigSignalErrorAt(*v5, 0, 0, 0, 0, 0, 0);
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  *a2 = v13;
LABEL_22:
  os_unfair_lock_unlock((os_unfair_lock_t)&remoteXPCFigEndpoint_getSharedXPCClient_lock);
  return v14;
}

void *FigEndpointXPCRemoteRetainCopiedEndpointFromReply(void *result, void *a2, void *a3)
{
  if (result)
  {
    if (a3)
    {
      uint64_t v5 = result;
      uint int64 = (const void *)xpc_dictionary_get_uint64(result, "EndpointObjectID");
      if (!uint64)
      {
        *a3 = 0;
        if (!a2) {
          return 0;
        }
        goto LABEL_11;
      }
      uint64_t v7 = xpc_dictionary_get_uint64(v5, "EndpointXPCSource");
      if (FigEndpointXPCSourceNeedsSubEndpoint(v7))
      {
        uint64_t v8 = xpc_dictionary_get_uint64(v5, "SubEndpointObjectID");
        uint64_t v9 = xpc_dictionary_get_uint64(v5, "SubEndpointXPCSource");
      }
      else
      {
        uint64_t v8 = 0;
        uint64_t v9 = 0;
      }
      uint64_t result = (void *)remoteXPCEndpoint_retainCopiedEndpointForSource(uint64, v7, v8, v9, a3);
      if (a2 && !result)
      {
LABEL_11:
        uint64_t result = 0;
        *a2 = uint64;
      }
    }
    else
    {
      return (void *)FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigEndpointCopyActiveCarPlayEndpoint(void *a1)
{
  return FigEndpointCopyActiveEndpointOfType(@"EndpointType_Car", a1);
}

uint64_t FigEndpointIsCarPlayActive(BOOL *a1)
{
  xpc_object_t xdict = 0;
  xpc_object_t v8 = 0;
  uint64_t v6 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1)
  {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_57);
    if (a1) {
      goto LABEL_3;
    }
LABEL_11:
    uint64_t SharedXPCClient = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
LABEL_12:
    uint64_t v3 = SharedXPCClient;
    xpc_object_t v4 = 0;
    goto LABEL_9;
  }
  if (!a1) {
    goto LABEL_11;
  }
LABEL_3:
  *a1 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(0, &v6);
  if (SharedXPCClient) {
    goto LABEL_12;
  }
  if (ensureActiveEndpointNotificationsRegistered_initNotifyOnce != -1) {
    dispatch_once(&ensureActiveEndpointNotificationsRegistered_initNotifyOnce, &__block_literal_global_15_0);
  }
  uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x61766C62u, 0, &v8);
  if (SharedXPCClient) {
    goto LABEL_12;
  }
  uint64_t v3 = FigXPCRemoteClientSendSyncMessageCreatingReply(v6, (uint64_t)v8, &xdict);
  xpc_object_t v4 = xdict;
  if (!v3)
  {
    *a1 = xpc_dictionary_get_BOOL(xdict, ".Value");
    xpc_object_t v4 = xdict;
  }
LABEL_9:
  FigXPCRelease(v4);
  FigXPCRelease(v8);
  return v3;
}

uint64_t FigEndpointXPCRemoteEnableActiveCarPlayEndpoint()
{
  return 4294950570;
}

uint64_t FigEndpointXPCRemoteGetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  if (!a2)
  {
    uint64_t v7 = 0;
    uint64_t v6 = 4294950576;
    goto LABEL_9;
  }
  if (a1 && (_UNKNOWN *)CMBaseObjectGetVTable(a1) == &kFigEndpointRemoteXPC_EndpointAggregateVTable)
  {
    if (*(unsigned char *)(DerivedStorage + 40))
    {
      uint64_t v5 = 4294950573;
    }
    else
    {
      if (!*(unsigned char *)(DerivedStorage + 41))
      {
        uint64_t v6 = 0;
        uint64_t v7 = *(void *)DerivedStorage;
        goto LABEL_9;
      }
      uint64_t v5 = 4294950574;
    }
  }
  else
  {
    uint64_t v5 = 4294954516;
  }
  uint64_t v6 = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  uint64_t v7 = 0;
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  *a2 = v7;
  return v6;
}

BOOL FigEndpointIsXPCRemote(uint64_t a1)
{
  return a1 && (_UNKNOWN *)CMBaseObjectGetVTable(a1) == &kFigEndpointRemoteXPC_EndpointAggregateVTable;
}

uint64_t FigEndpointXPCRemotePing()
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1) {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_57);
  }
  unint64_t v0 = FigIsAirplaydEnabled() != 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(v0, &v6);
  if (SharedXPCClient)
  {
    uint64_t v4 = SharedXPCClient;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v2 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v7);
    uint64_t v3 = v7;
    if (v2)
    {
      uint64_t v4 = v2;
    }
    else
    {
      uint64_t v4 = FigXPCRemoteClientSendSyncMessage(v6, (uint64_t)v7);
      uint64_t v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

uint64_t FigEndpointXPCRemoteRetainCopiedEndpoint(const void *a1, void *a2)
{
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1) {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_57);
  }

  return remoteXPCEndpoint_retainCopiedEndpointForSource(a1, 0, 0, 0, a2);
}

uint64_t remoteXPCEndpoint_retainCopiedEndpointForSource(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v31 = 0;
  CFIndex v32 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce == -1)
  {
    if (!a1) {
      goto LABEL_48;
    }
  }
  else
  {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_57);
    if (!a1) {
      goto LABEL_48;
    }
  }
  if (a5)
  {
    if ((a2 & 0x1000) == 0)
    {
      unint64_t Base = FigEndpointXPCSourceGetBase(a2);
      uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(Base, &v31);
      if (SharedXPCClient) {
        return SharedXPCClient;
      }
      uint64_t v12 = FigXPCRemoteClientRetainCopiedObject(v31, (uint64_t)a1, &v32);
      version = (const void *)v32;
      if (!v12)
      {
        if (v32)
        {
          uint64_t v14 = 0;
LABEL_44:
          *a5 = version;
          return v14;
        }
        CFTypeRef v34 = 0;
        CFTypeRef v35 = 0;
        memset(&cf, 0, sizeof(cf));
        unint64_t v19 = FigEndpointXPCSourceGetBase(a2);
        uint64_t v20 = remoteXPCFigEndpoint_getSharedXPCClient(v19, &v34);
        if (!v20)
        {
          unsigned int v21 = (a2 >> 13) & 1;
          CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v23 = (void *)(v21 ? FigEndpointAggregateGetClassID() : FigEndpointExtendedGetClassID());
          uint64_t v20 = CMDerivedObjectCreate((uint64_t)v22, (uint64_t)&kFigEndpointRemoteXPC_EndpointAggregateVTable, v23, &v35);
          if (!v20)
          {
            uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v35);
            *(void *)uint64_t DerivedStorage = a1;
            *(void *)(DerivedStorage + 96) = 1;
            *(void *)(DerivedStorage + 8) = FigEndpointXPCSourceGetBase(a2);
            *(unsigned char *)(DerivedStorage + 16) = (a2 & 0x2000) != 0;
            if (!v21 || (uint64_t v20 = FigEndpointRPCCacheCreate((void *)(DerivedStorage + 48), 1), !v20))
            {
              cf.version = 0;
              cf.retain = (CFDictionaryRetainCallBack)remoteXPCEndpoint_cloneCompletionCallback;
              cf.copyDescription = 0;
              cf.equal = 0;
              cf.release = (CFDictionaryReleaseCallBack)remoteXPCEndpoint_freeCompletionCallback;
              int v25 = FigSimpleMutexCreate();
              *(void *)(DerivedStorage + 32) = v25;
              if (!v25)
              {
                uint64_t v14 = 4294950575;
LABEL_53:
                if (v35) {
                  CFRelease(v35);
                }
                goto LABEL_43;
              }
              CFMutableDictionaryRef v26 = CFDictionaryCreateMutable(v22, 0, 0, &cf);
              *(void *)(DerivedStorage + 88) = v26;
              if (v26)
              {
                dispatch_queue_t v27 = dispatch_queue_create("com.apple.coremedia.remoteendpoint.notification", 0);
                *(void *)(DerivedStorage + 24) = v27;
                if (v27)
                {
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v22, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  *(void *)(DerivedStorage + 56) = Mutable;
                  if (Mutable)
                  {
                    CFMutableArrayRef v29 = CFArrayCreateMutable(v22, 0, MEMORY[0x1E4F1D510]);
                    *(void *)(DerivedStorage + 80) = v29;
                    if (v29)
                    {
                      FigXPCRemoteClientAssociateObject((uint64_t)v34, (uint64_t)v35, a1);
                      uint64_t v14 = 0;
                      CFIndex v32 = (CFIndex)v35;
LABEL_43:
                      version = (const void *)v32;
                      goto LABEL_44;
                    }
                  }
                }
              }
              uint64_t v20 = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
            }
          }
        }
        uint64_t v14 = v20;
        goto LABEL_53;
      }
      uint64_t v14 = v12;
LABEL_57:
      if (version) {
        CFRelease(version);
      }
      return v14;
    }
    cf.version = 0;
    CFTypeRef v34 = 0;
    CFTypeRef v35 = 0;
    if (remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_initDemuxMutexOnce != -1) {
      dispatch_once(&remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_initDemuxMutexOnce, &__block_literal_global_24);
    }
    FigSimpleMutexLock((pthread_mutex_t *)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutex);
    unint64_t v15 = FigEndpointXPCSourceGetBase(a2);
    uint64_t v16 = remoteXPCEndpoint_retainCopiedEndpointForSource(a1, v15, 0, 0, &v35);
    if (!v16)
    {
      unint64_t v17 = FigEndpointXPCSourceGetBase(a4);
      uint64_t v16 = remoteXPCEndpoint_retainCopiedEndpointForSource(a3, v17, 0, 0, &v34);
      if (!v16)
      {
        if (FigEndpointIsXPCDemux(remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint)
          && FigEndpointXPCDemuxEndpointsMatch(remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint, (uint64_t)v35, (uint64_t)v34))
        {
          cf.version = (CFIndex)CFRetain((CFTypeRef)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint);
LABEL_21:
          uint64_t v14 = 0;
          version = (const void *)cf.version;
          CFIndex v32 = cf.version;
          cf.version = 0;
          goto LABEL_22;
        }
        uint64_t v16 = FigEndpointXPCDemuxCreate(v35, v34, (CFTypeRef *)&cf);
        if (!v16)
        {
          uint64_t v18 = (const void *)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint;
          remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint = cf.version;
          if (cf.version) {
            CFRetain((CFTypeRef)cf.version);
          }
          if (v18) {
            CFRelease(v18);
          }
          goto LABEL_21;
        }
      }
    }
    uint64_t v14 = v16;
    version = 0;
LABEL_22:
    FigSimpleMutexUnlock((pthread_mutex_t *)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutex);
    if (cf.version) {
      CFRelease((CFTypeRef)cf.version);
    }
    if (v35) {
      CFRelease(v35);
    }
    if (v34) {
      CFRelease(v34);
    }
    if (!v14) {
      goto LABEL_44;
    }
    goto LABEL_57;
  }
LABEL_48:

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointXPCRemoteObtainObjectIDForOtherProcess(uint64_t a1, int a2, uint64_t *a3)
{
  xpc_object_t xdict = 0;
  uint64_t v14 = 0;
  xpc_object_t v12 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v11 = 0;
  if (!a1 || !a2 || !a3)
  {
    uint64_t SharedXPCClient = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_13:
    uint64_t v9 = SharedXPCClient;
    goto LABEL_11;
  }
  uint64_t v7 = DerivedStorage;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1) {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_57);
  }
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(v7 + 8), &v11);
  if (SharedXPCClient) {
    goto LABEL_13;
  }
  uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v14);
  if (SharedXPCClient) {
    goto LABEL_13;
  }
  uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x63656670u, v14, &xdict);
  if (SharedXPCClient) {
    goto LABEL_13;
  }
  xpc_dictionary_set_int64(xdict, "OtherProcessPID", a2);
  uint64_t v9 = FigXPCRemoteClientSendSyncMessageCreatingReply(v11, (uint64_t)xdict, &v12);
  if (!v9) {
    *a3 = xpc_dictionary_get_uint64(v12, ".objectID");
  }
LABEL_11:
  FigXPCRelease(xdict);
  FigXPCRelease(v12);
  return v9;
}

uint64_t FigEndpointXPCRemoteGetSource(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a2)
  {
    *a2 = *(void *)(DerivedStorage + 8);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

void *FigEndpointXPCRemoteRetainCopiedEndpointFromArray(void *a1, size_t a2, void *a3, void *a4)
{
  if (a4)
  {
    xpc_object_t value = xpc_array_get_value(a1, a2);
    return FigEndpointXPCRemoteRetainCopiedEndpointFromReply(value, a3, a4);
  }
  else
  {
    return (void *)FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigEndpointXPCRemoteRetainCopiedEndpointsFromArrayToCFArray(void *a1, __CFArray **a2)
{
  if (a2)
  {
    if (a1)
    {
      xpc_object_t Count = FigXPCArrayGetCount(a1);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, (CFIndex)Count, MEMORY[0x1E4F1D510]);
      if (Count)
      {
        size_t v7 = 0;
        while (1)
        {
          xpc_object_t value = 0;
          xpc_object_t v8 = xpc_array_get_value(a1, v7);
          uint64_t v9 = FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v8, 0, &value);
          if (v9) {
            break;
          }
          CFArrayAppendValue(Mutable, value);
          if (value) {
            CFRelease(value);
          }
          if (Count == (xpc_object_t)++v7) {
            goto LABEL_9;
          }
        }
        unsigned int v10 = v9;
        if (Mutable) {
          CFRelease(Mutable);
        }
      }
      else
      {
LABEL_9:
        unsigned int v10 = 0;
        *a2 = Mutable;
      }
    }
    else
    {
      unsigned int v10 = 0;
      *a2 = 0;
    }
    return (uint64_t)v10;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

void remoteXPCEndpointClient_DeadConnectionCallback(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return;
  }
  CFMutableDictionaryRef v5 = Mutable;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  *(_WORD *)(DerivedStorage + 40) = 257;
  FigCFDictionarySetInt64(v5, @"ActivationSeed", *(void *)(DerivedStorage + 64));
  FigCFDictionarySetInt64(v5, @"Features", *(void *)(DerivedStorage + 72));
  if (!*(void *)(DerivedStorage + 72))
  {
    CFMutableDictionaryRef v8 = 0;
    size_t v7 = 0;
    goto LABEL_7;
  }
  uint64_t v6 = *(id **)(DerivedStorage + 184);
  if (!v6)
  {
    size_t v7 = 0;
    goto LABEL_9;
  }
  size_t v7 = FigCFWeakReferenceHolderCopyReferencedObject(v6);
  if (v7)
  {
LABEL_9:
    uint64_t v9 = *(void *)(DerivedStorage + 160);
    uint64_t v10 = *(void *)(DerivedStorage + 64);
    CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    FigCFDictionarySetInt64(v8, @"Status", -16722);
    FigCFDictionarySetValue(v8, @"FailureType", @"FailureType_Disconnected");
    goto LABEL_10;
  }
  CFMutableDictionaryRef v8 = 0;
LABEL_7:
  uint64_t v9 = 0;
  uint64_t v10 = 0;
LABEL_10:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  uint64_t v11 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(v11 + 32));
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v3, *(CFDictionaryRef *)(v11 + 88));
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v11 + 88));
  uint64_t v13 = *(void *)(v11 + 64);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v11 + 32));
  uint64_t v14 = *(NSObject **)(v11 + 24);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigEndpointRemoteXPC_runAllCallbacks_block_invoke;
  block[3] = &__block_descriptor_tmp_7_11;
  void block[4] = Copy;
  void block[5] = v13;
  int v18 = -16722;
  dispatch_async(v14, block);
  if (v9) {
    remoteXPCEndpointClient_callDelegateHandleFailed(a1, 0, v10, 0, v9, (uint64_t)v7, v8);
  }
  unint64_t v15 = *(NSObject **)(DerivedStorage + 24);
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification(v15, DefaultLocalCenter, @"Endpoint_Dissociated", a1, v5, 0);
  if (v8) {
    CFRelease(v8);
  }
  CFRelease(v5);
  if (v7) {
    CFRelease(v7);
  }
}

uint64_t remoteXPCEndpointClient_NotificationFilter(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"Endpoint_ConnectedStateChanged"))
  {
    if (a4) {
      CFStringRef Value = CFDictionaryGetValue(a4, @"ConnectedState");
    }
    else {
      CFStringRef Value = 0;
    }
    uint64_t v9 = @"IsConnected";
    uint64_t v10 = DerivedStorage;
    goto LABEL_14;
  }
  if (CFEqual(a2, @"Endpoint_Dissociated"))
  {
    CFMutableDictionaryRef v8 = kFigEndpointProperty_IsDissociated;
  }
  else
  {
    if (CFEqual(a2, @"Endpoint_EndpointActivated"))
    {
      uint64_t v11 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else
    {
      if (!CFEqual(a2, @"Endpoint_EndpointDeactivated"))
      {
        if (CFEqual(a2, @"Endpoint_StreamsChanged"))
        {
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"Streams", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"AirPlayVodkaVersion", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"AirPlayFromCloud", 0);
          CFMutableDictionaryRef v8 = kFigEndpointProperty_SupportedFeatures;
        }
        else if (CFEqual(a2, @"Endpoint_EndpointDescriptionChanged"))
        {
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"AirPlayVodkaVersion", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"AirPlayFromCloud", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"AudioWithScreenMirroringOnly", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"AuthorizationType", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"ID", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"MACAddress", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"Model", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"Name", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"SubType", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"SupportedFeatures", 0);
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"SystemFlags", 0);
          CFMutableDictionaryRef v8 = kFigEndpointProperty_TransportType;
        }
        else
        {
          if (CFEqual(a2, @"EndpointAdded") || CFEqual(a2, @"EndpointRemoved"))
          {
            remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(DerivedStorage);
            return 0;
          }
          if (CFEqual(a2, @"Endpoint_VolumeControlTypeDidChange"))
          {
            CFMutableDictionaryRef v8 = kFigEndpointProperty_VolumeControlType;
          }
          else if (CFEqual(a2, @"Endpoint_VolumeControlSupportedDidChange"))
          {
            CFMutableDictionaryRef v8 = kFigEndpointProperty_VolumeControlSupported;
          }
          else
          {
            if (!CFEqual(a2, @"Endpoint_VolumeDidChange")) {
              return 0;
            }
            remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"Volume", 0);
            CFMutableDictionaryRef v8 = kFigEndpointProperty_VolumeDB;
          }
        }
        goto LABEL_13;
      }
      uint64_t v11 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"IsActivated", *v11);
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"IsPerAppDisplay", 0);
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"PrimaryUsage", 0);
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"Streams", 0);
    CFMutableDictionaryRef v8 = kFigEndpointProperty_Volume;
  }
LABEL_13:
  uint64_t v9 = *v8;
  uint64_t v10 = DerivedStorage;
  CFStringRef Value = 0;
LABEL_14:
  remoteXPCFigEndpoint_setCachedProperty(v10, v9, Value);
  return 0;
}

uint64_t remoteXPCEndpointClient_HandleClientMessage(const void *a1, void *a2)
{
  int v36 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v36);
  if (OpCode) {
    return OpCode;
  }
  if (v36 != 1920230499)
  {
    if (v36 != 1919116387)
    {
      if (v36 != 1667329122) {
        return 4294966630;
      }
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      uint64_t v52 = 0;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      *(void *)&long long v53 = 0;
      uint int64 = (const void *)xpc_dictionary_get_uint64(a2, "CompletionID");
      int int64 = xpc_dictionary_get_int64(a2, "CompletionStatus");
      uint64_t v8 = xpc_dictionary_get_uint64(a2, "ActivationSeed");
      uint64_t v9 = xpc_dictionary_get_uint64(a2, "ActivationFeatures");
      FigXPCMessageCopyCFDictionary(a2, "SendCommandResponse", &v53);
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 88), uint64);
      if (Value)
      {
        uint64_t v11 = Value;
        long long v49 = Value[1];
        long long v50 = Value[2];
        long long v51 = Value[3];
        uint64_t v52 = *((void *)Value + 8);
        long long v48 = *Value;
        remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)&v48);
        if (*((void *)v11 + 1) && *((unsigned char *)v11 + 40) && !int64)
        {
          *(void *)(DerivedStorage + 64) = v8;
          *(void *)(DerivedStorage + 72) = v9;
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(DerivedStorage + 88), uint64);
        uint64_t v12 = v48;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
        if (v12)
        {
          if ((void)v50) {
            remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(DerivedStorage);
          }
          if ((void)v53) {
            CFRetain((CFTypeRef)v53);
          }
          remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)&v48);
          uint64_t v13 = *(NSObject **)(DerivedStorage + 24);
          blocuint64_t k = MEMORY[0x1E4F143A8];
          uint64_t v38 = 0x40000000;
          CFTypeRef v39 = __remoteXPCEndpointClient_handleCompletionCallback_block_invoke;
          int v40 = &__block_descriptor_tmp_9_7;
          long long v43 = v50;
          *(_OWORD *)__int16 v44 = v51;
          long long v42 = v49;
          long long v41 = v48;
          *(void *)&v44[16] = v52;
          *(void *)&long long v45 = v8;
          *((void *)&v45 + 1) = v9;
          uint64_t v46 = v53;
          int v47 = int64;
          dispatch_async(v13, &block);
          uint64_t v14 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
      }
      uint64_t v14 = FigSignalErrorAt(4294950571, 0, 0, 0, 0, 0, 0);
LABEL_16:
      if ((void)v53) {
        CFRelease((CFTypeRef)v53);
      }
      remoteXPCEndpointClient_releaseCompletionCallbackEntryFields((uint64_t)&v48);
      return v14;
    }
    uint64_t v19 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    CFDictionaryRef v55 = 0;
    v56[0] = 0;
    *(void *)&long long v48 = 0;
    *((void *)&v48 + 1) = &v48;
    long long v49 = 0x2000000000uLL;
    uint64_t v20 = xpc_dictionary_get_uint64(a2, "ActivationSeed");
    FigXPCMessageCopyCFString(a2, "CommChannelUUID", v56);
    FigXPCMessageCopyCFString(a2, "DelegateFunctionType", &v55);
    FigSimpleMutexLock(*(pthread_mutex_t **)(v19 + 32));
    unsigned int v21 = *(id **)(v19 + 136);
    if (v21)
    {
      CFAllocatorRef v22 = FigCFWeakReferenceHolderCopyReferencedObject(v21);
      if (!v22)
      {
        int v25 = 0;
        uint64_t v14 = 4294949690;
        goto LABEL_33;
      }
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      CFAllocatorRef v22 = 0;
    }
    int v25 = 1;
LABEL_33:
    long long v26 = *(_OWORD *)(v19 + 120);
    long long v53 = *(_OWORD *)(v19 + 104);
    long long v54 = v26;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
    if (v25)
    {
      CFRetain(a1);
      FigXPCRetain(a2);
      if (v22) {
        CFRetain(v22);
      }
      if (v56[0]) {
        CFRetain(v56[0]);
      }
      if (v55)
      {
        CFRetain(v55);
        CFDictionaryRef v27 = v55;
      }
      else
      {
        CFDictionaryRef v27 = 0;
      }
      CFIndex v32 = *(NSObject **)(v19 + 24);
      blocuint64_t k = MEMORY[0x1E4F143A8];
      uint64_t v38 = 0x40000000;
      *(_OWORD *)&v44[8] = v53;
      long long v45 = v54;
      CFTypeRef v39 = __remoteXPCEndpointClient_handleRemoteControlDelegateCallback_block_invoke;
      int v40 = &unk_1E567F380;
      *(void *)&long long v41 = &v48;
      *((void *)&v41 + 1) = v27;
      *(void *)&long long v42 = a2;
      *((void *)&v42 + 1) = a1;
      *(void *)&long long v43 = v20;
      *((const void **)&v43 + 1) = v56[0];
      *(void *)__int16 v44 = v22;
      dispatch_async(v32, &block);
    }
    if (v56[0]) {
      CFRelease(v56[0]);
    }
    if (v22) {
      CFRelease(v22);
    }
    if (v55) {
      CFRelease(v55);
    }
    _Block_object_dispose(&v48, 8);
    return v14;
  }
  uint64_t v15 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  *(void *)&long long v53 = 0;
  CFDictionaryRef v55 = 0;
  v56[0] = 0;
  uint64_t v16 = xpc_dictionary_get_uint64(a2, "ActivationSeed");
  FigXPCMessageCopyCFString(a2, "DelegateFunctionType", &v53);
  FigSimpleMutexLock(*(pthread_mutex_t **)(v15 + 32));
  unint64_t v17 = *(id **)(v15 + 184);
  if (v17)
  {
    int v18 = FigCFWeakReferenceHolderCopyReferencedObject(v17);
    if (v18) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = 4294949690;
    }
  }
  else
  {
    uint64_t v14 = 0;
    int v18 = 0;
  }
  uint64_t v24 = *(void *)(v15 + 152);
  uint64_t v23 = *(void *)(v15 + 160);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v15 + 32));
  FigEndpointXPCRemoteRetainCopiedEndpointFromReply(a2, 0, v56);
  if (CFStringCompare((CFStringRef)v53, @"hrar", 0))
  {
    if (CFStringCompare((CFStringRef)v53, @"hrtf", 0))
    {
      uint64_t v14 = 4294950570;
    }
    else
    {
      FigXPCMessageCopyCFDictionary(a2, "FailureInfo", &v55);
      uint64_t v14 = remoteXPCEndpointClient_callDelegateHandleFailed(a1, (CFMutableDictionaryRef)v14, v16, v56[0], v23, (uint64_t)v18, v55);
      if (v55) {
        CFRelease(v55);
      }
    }
  }
  else
  {
    __int16 v28 = v56[0];
    uint64_t v29 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    *(void *)&long long v48 = 0;
    __int16 v30 = malloc_type_calloc(1uLL, 8uLL, 0x80040B8603338uLL);
    *__int16 v30 = FigXPCRetain(a2);
    if (!v14)
    {
      if (v24)
      {
        FigXPCMessageCopyCFString(a2, "AuthorizationType", &v48);
        CFRetain(a1);
        if (v28) {
          CFRetain(v28);
        }
        if ((void)v48)
        {
          CFRetain((CFTypeRef)v48);
          uint64_t v31 = v48;
        }
        else
        {
          uint64_t v31 = 0;
        }
        uint64_t v33 = *(NSObject **)(v29 + 24);
        blocuint64_t k = MEMORY[0x1E4F143A8];
        uint64_t v38 = 0x40000000;
        CFTypeRef v39 = __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke;
        int v40 = &__block_descriptor_tmp_11_4;
        *(void *)&long long v41 = v24;
        *((void *)&v41 + 1) = a1;
        *(void *)&long long v42 = v28;
        *((void *)&v42 + 1) = v16;
        *(void *)&long long v43 = v18;
        *((void *)&v43 + 1) = v31;
        *(void *)__int16 v44 = v30;
        dispatch_async(v33, &block);
        if ((void)v48) {
          CFRelease((CFTypeRef)v48);
        }
        uint64_t v14 = 0;
        goto LABEL_61;
      }
      uint64_t v14 = 4294949690;
    }
    CFRetain(a1);
    CFTypeRef v35 = *(NSObject **)(v29 + 24);
    blocuint64_t k = MEMORY[0x1E4F143A8];
    uint64_t v38 = 0x40000000;
    CFTypeRef v39 = __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke_2;
    int v40 = &__block_descriptor_tmp_12_5;
    *(void *)&long long v41 = a1;
    *((void *)&v41 + 1) = v30;
    dispatch_async(v35, &block);
  }
LABEL_61:
  if (v56[0]) {
    CFRelease(v56[0]);
  }
  if (v18) {
    CFRelease(v18);
  }
  if ((void)v53) {
    CFRelease((CFTypeRef)v53);
  }
  return v14;
}

uint64_t remoteXPCEndpointClient_callDelegateHandleFailed(const void *a1, CFMutableDictionaryRef a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, const __CFDictionary *a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a2) {
    return (uint64_t)a2;
  }
  if (!a5) {
    return 4294949690;
  }
  uint64_t v15 = DerivedStorage;
  if (a4 && a7)
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a7);
    FigCFDictionarySetValue(MutableCopy, @"SubEndpoint", a4);
    CFRetain(a1);
    a7 = MutableCopy;
LABEL_7:
    CFRetain(a4);
    a2 = MutableCopy;
    goto LABEL_8;
  }
  CFRetain(a1);
  CFMutableDictionaryRef MutableCopy = 0;
  a2 = 0;
  if (a4) {
    goto LABEL_7;
  }
LABEL_8:
  if (a7) {
    CFRetain(a7);
  }
  unint64_t v17 = *(NSObject **)(v15 + 24);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 0x40000000;
  int v19[2] = __remoteXPCEndpointClient_callDelegateHandleFailed_block_invoke;
  v19[3] = &__block_descriptor_tmp_8_6;
  v19[4] = a5;
  void v19[5] = a1;
  v19[6] = a3;
  void v19[7] = a7;
  v19[8] = a6;
  v19[9] = a4;
  dispatch_async(v17, v19);
  if (a2)
  {
    CFRelease(a2);
    return 0;
  }
  return (uint64_t)a2;
}

void *remoteXPCEndpointClient_runCallback(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = result;
  uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))result[1];
  if (v9)
  {
    uint64_t v10 = *result;
    uint64_t v11 = v8[8];
    return (void *)v9(v10, a3, a2, a5, v11);
  }
  if (result[2])
  {
    uint64_t v12 = (char *)*result;
    if (!*result
      || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v12, ClassID)))
    {
      uint64_t v12 = 0;
    }
    uint64_t v14 = (uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v8[2];
    uint64_t v15 = v8[8];
    uint64_t v16 = v12;
    uint64_t v17 = a5;
    uint64_t v18 = a4;
    return (void *)v14(v16, v17, v18, v15);
  }
  if (result[3])
  {
    uint64_t v19 = (char *)*result;
    if (!*result
      || (uint64_t v20 = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v19, v20)))
    {
      uint64_t v19 = 0;
    }
    uint64_t v14 = (uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v8[3];
    uint64_t v17 = v8[6];
    uint64_t v15 = v8[8];
    uint64_t v16 = v19;
    uint64_t v18 = a5;
    return (void *)v14(v16, v17, v18, v15);
  }
  unsigned int v21 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))result[4];
  if (v21)
  {
    uint64_t v22 = *result;
    uint64_t v23 = v8[7];
    uint64_t v24 = v8[8];
    return (void *)v21(v22, v23, a3, a2, a5, v24);
  }
  return result;
}

void __remoteXPCEndpointClient_callDelegateHandleFailed_block_invoke(uint64_t a1)
{
  (*(void (**)(void, void, void, void))(a1 + 32))(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  uint64_t v2 = *(const void **)(a1 + 72);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 56);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t remoteXPCFigEndpoint_setCachedProperty(uint64_t a1, const void *a2, const void *a3)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  uint64_t v6 = *(__CFDictionary **)(a1 + 56);
  if (a3) {
    CFDictionarySetValue(v6, a2, a3);
  }
  else {
    CFDictionaryRemoveValue(v6, a2);
  }
  size_t v7 = *(pthread_mutex_t **)(a1 + 32);

  return FigSimpleMutexUnlock(v7);
}

uint64_t remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(uint64_t a1)
{
  remoteXPCFigEndpoint_setCachedProperty(a1, @"Endpoints", 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, @"AirPlayVodkaVersion", 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, @"AirPlayFromCloud", 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, @"Streams", 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, @"Volume", 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, @"VolumeDB", 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, @"VolumeControlSupported", 0);

  return remoteXPCFigEndpoint_setCachedProperty(a1, @"VolumeControlType", 0);
}

CFTypeRef remoteXPCEndpointClient_retainCompletionCallbackEntryFields(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    CFRetain(v2);
  }
  if (*(void *)a1) {
    CFRetain(*(CFTypeRef *)a1);
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 56);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void __remoteXPCEndpointClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  uint64_t v2 = a1 + 32;
  remoteXPCEndpointClient_runCallback((void *)(a1 + 32), *(void *)(a1 + 104), *(void *)(a1 + 112), *(void *)(a1 + 120), *(unsigned int *)(a1 + 128));
  CFAllocatorRef v3 = *(const void **)(a1 + 120);
  if (v3) {
    CFRelease(v3);
  }

  remoteXPCEndpointClient_releaseCompletionCallbackEntryFields(v2);
}

void remoteXPCEndpointClient_releaseCompletionCallbackEntryFields(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    CFRelease(v2);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 56);
  if (v3)
  {
    CFRelease(v3);
  }
}

void __remoteXPCEndpointClient_handleRemoteControlDelegateCallback_block_invoke(uint64_t a1)
{
  if (CFStringCompare(*(CFStringRef *)(a1 + 40), @"hrcd", 0))
  {
    if (CFEqual(*(CFStringRef *)(a1 + 40), @"hrcc"))
    {
      uint64_t v2 = *(void (**)(void, void, void, void))(a1 + 112);
      if (v2) {
        v2(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80));
      }
    }
  }
  else if (*(void *)(a1 + 104))
  {
    FigXPCMessageCopyCFData(*(void **)(a1 + 48), "Data", (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    (*(void (**)(void, void, void, void, void))(a1 + 104))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(void *)(a1 + 80));
  }
  CFRelease(*(CFTypeRef *)(a1 + 56));
  FigXPCRelease(*(xpc_object_t *)(a1 + 48));
  CFAllocatorRef v3 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 80);
  if (v4) {
    CFRelease(v4);
  }
  CFMutableDictionaryRef v5 = *(const void **)(a1 + 72);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 40);
  if (v6)
  {
    CFRelease(v6);
  }
}

void __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke(uint64_t a1)
{
  (*(void (**)(void, void, void, void, void, void (*)(uint64_t, const void *, int, xpc_object_t *), void))(a1 + 32))(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), remoteXPCEndpointClient_handleAuthCompletionCallback, *(void *)(a1 + 80));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 72);
  if (v3)
  {
    CFRelease(v3);
  }
}

void remoteXPCEndpointClient_handleAuthCompletionCallback(uint64_t a1, const void *a2, int a3, xpc_object_t *a4)
{
  if (*a4 && (xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4)) != 0)
  {
    uint64_t v8 = remote_connection;
    repldouble y = xpc_dictionary_create_reply(*a4);
    xpc_dictionary_set_int64(reply, "AuthorizationResult", a3);
    FigXPCMessageSetCFString(reply, "AuthorizationString", a2);
    xpc_connection_send_message(v8, reply);
  }
  else
  {
    repldouble y = 0;
  }
  FigXPCRelease(reply);
  FigXPCRelease(*a4);

  free(a4);
}

void __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke_2(uint64_t a1)
{
  remoteXPCEndpointClient_handleAuthCompletionCallback(a1, 0, -16728, *(xpc_object_t **)(a1 + 40));
  uint64_t v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

uint64_t __ensureActiveEndpointNotificationsRegistered_block_invoke()
{
  unint64_t v0 = dispatch_queue_create("com.apple.coremedia.remoteendpoint.notify-active", 0);
  ensureActiveEndpointNotificationsRegistered_notifyQueue = (uint64_t)v0;

  return notify_register_dispatch("com.apple.coremedia.active-endpoint-changed", (int *)&ensureActiveEndpointNotificationsRegistered_notifyToken, v0, &__block_literal_global_21_0);
}

uint64_t __ensureActiveEndpointNotificationsRegistered_block_invoke_2()
{
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterPostNotification(DefaultLocalCenter, @"Endpoint_ActiveCarPlayEndpointChanged", @"Endpoint_ActiveCarPlayEndpointChanged", 0);
}

void __remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutedouble x = (uint64_t)FigSimpleMutexCreate();
  if (!remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutex)
  {
    v6[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v6, &type);
    int v1 = v6[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v3 = v1;
    }
    else {
      unsigned int v3 = v1 & 0xFFFFFFFE;
    }
    if (v3)
    {
      v6[1] = 136315138;
      size_t v7 = "remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_block_invoke";
      uint64_t v4 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v1) = v6[0];
    }
    else
    {
      uint64_t v4 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v4, v4 != &v8, v1, 0, v2);
  }
}

void *remoteXPCEndpoint_cloneCompletionCallback(const __CFAllocator *a1, uint64_t a2)
{
  unsigned int v3 = CFAllocatorAllocate(a1, 72, 0);
  *(_OWORD *)unsigned int v3 = *(_OWORD *)a2;
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 16);
  v3[8] = *(void *)(a2 + 64);
  *((_OWORD *)v3 + 2) = v5;
  *((_OWORD *)v3 + 3) = v4;
  *((_OWORD *)v3 + 1) = v6;
  remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)v3);
  return v3;
}

void remoteXPCEndpoint_freeCompletionCallback(const __CFAllocator *a1, void *a2)
{
  remoteXPCEndpointClient_releaseCompletionCallbackEntryFields((uint64_t)a2);

  CFAllocatorDeallocate(a1, a2);
}

CFAllocatorRef FigEndpointRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v3 = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  long long v4 = *(const void **)v3;
  if (*(unsigned char *)(v3 + 40)
    || (uint64_t v5 = v3, remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(v3 + 8), &v17))
    || (uint64_t v6 = v17, FigXPCRemoteClientDisassociateObject(v17, v4), *(unsigned char *)(v5 + 41)))
  {
    size_t v7 = 0;
  }
  else
  {
    int v8 = FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v4, &v18);
    size_t v7 = v18;
    if (!v8)
    {
      uint64_t v9 = FigXPCRemoteClientSendSyncMessage(v6, (uint64_t)v18);
      FigXPCRemoteClientKillServerOnTimeout(v6, v9, "FigEndpointRemoteXPC_teardown", 0);
      size_t v7 = v18;
    }
  }
  FigXPCRelease(v7);
  uint64_t v10 = *(const void **)(DerivedStorage + 88);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(DerivedStorage + 88) = 0;
  }
  uint64_t v11 = *(const void **)(DerivedStorage + 56);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(DerivedStorage + 56) = 0;
  }
  uint64_t v12 = *(const void **)(DerivedStorage + 80);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(DerivedStorage + 80) = 0;
  }
  uint64_t v13 = *(const void **)(DerivedStorage + 136);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(DerivedStorage + 136) = 0;
  }
  uint64_t v14 = *(const void **)(DerivedStorage + 184);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(DerivedStorage + 184) = 0;
  }
  FigEndpointRPCCacheDispose(*(void **)(DerivedStorage + 48));
  uint64_t v15 = *(NSObject **)(DerivedStorage + 24);
  if (v15) {
    dispatch_release(v15);
  }
  return FigSimpleMutexDestroy(*(void *)(DerivedStorage + 32));
}

CFStringRef FigEndpointRemoteXPC_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<FigEndpointRemote %p>{ dissociated : %d, serverDied : %d, objectID : %llu, source : %llu }", a1, *(unsigned __int8 *)(DerivedStorage + 40), *(unsigned __int8 *)(DerivedStorage + 41), *(void *)DerivedStorage, *(void *)(DerivedStorage + 8));
}

uint64_t FigEndpointRemoteXPC_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t valuePtr = 0;
  uint64_t v36 = 0;
  CFTypeRef v33 = 0;
  CFTypeRef cf = 0;
  uint64_t v32 = 0;
  if (FigCFEqual(a2, @"Name") || FigCFEqual(a2, @"Type"))
  {
    if (remoteXPCFigEndpoint_copyCachedProperty(a1, a2, &cf))
    {
LABEL_10:
      CFArrayRef v11 = 0;
      CFMutableDictionaryRef Mutable = 0;
      uint64_t v13 = 0;
      goto LABEL_89;
    }
    int v9 = 0;
  }
  else
  {
    int v9 = 1;
  }
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v32);
  if (SharedXPCClient) {
    goto LABEL_102;
  }
  uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v36);
  if (SharedXPCClient) {
    goto LABEL_102;
  }
  if (v9 && remoteXPCFigEndpoint_copyCachedProperty(a1, a2, &cf)) {
    goto LABEL_10;
  }
  if (!a2)
  {
    CFArrayRef v11 = 0;
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v13 = 4294954516;
    goto LABEL_89;
  }
  if (CFEqual(@"Streams", a2))
  {
    uint64_t SharedXPCClient = FigEndpointStreamXPCRemotePing();
    if (!SharedXPCClient) {
      goto LABEL_17;
    }
LABEL_102:
    uint64_t v13 = SharedXPCClient;
    goto LABEL_103;
  }
  if (CFEqual(@"Messenger", a2))
  {
    uint64_t SharedXPCClient = FigEndpointMessengerXPCRemotePing();
    if (SharedXPCClient) {
      goto LABEL_102;
    }
  }
LABEL_17:
  if (CFEqual(@"Messenger", a2))
  {
    uint64_t v14 = v32;
    xpc_object_t xdict = 0;
    xpc_object_t value = 0;
    CFTypeRef v39 = 0;
    uint64_t v15 = FigXPCCreateBasicMessage(0x636D7367u, v36, &xdict);
    if (v15
      || (uint64_t v15 = FigXPCRemoteClientSendSyncMessageCreatingReply(v14, (uint64_t)xdict, (xpc_object_t *)&v39), v15))
    {
      uint64_t v13 = v15;
    }
    else
    {
      uint64_t v13 = FigXPCMessageCopyCFObject(v39, ".Value", (__CFDictionary **)&value);
      if (v13)
      {
        if (value) {
          CFRelease(value);
        }
      }
      else
      {
        CFTypeRef cf = value;
        xpc_object_t value = 0;
      }
    }
    FigXPCRelease(v39);
    FigXPCRelease(xdict);
    if (!cf) {
      goto LABEL_41;
    }
    CFTypeID v16 = CFGetTypeID(cf);
    if (v16 != CFNumberGetTypeID()) {
      goto LABEL_41;
    }
    if (!CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr)
      || (cf = 0, uint64_t v13 = FigEndpointMessengerXPCRemoteCreateWithObjectID(valuePtr, &v33), !v13))
    {
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef v17 = v33;
      CFTypeRef v33 = 0;
      CFTypeRef cf = v17;
      goto LABEL_41;
    }
LABEL_103:
    CFArrayRef v11 = 0;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_89;
  }
  if (CFEqual(@"Endpoints", a2))
  {
    xpc_object_t xdict = 0;
    xpc_object_t value = 0;
    uint64_t v38 = 0;
    CFTypeRef v39 = 0;
    uint64_t v37 = 0;
    uint64_t v18 = CMBaseObjectGetDerivedStorage(a1);
    if (*(unsigned char *)(v18 + 16))
    {
      uint64_t v19 = v18;
      ObjectIOSurfaceID ID = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(v18 + 8), &v37);
      if (!ObjectID)
      {
        ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID(a1, &v38);
        if (!ObjectID)
        {
          ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x63707365u, v38, &value);
          if (!ObjectID)
          {
            ObjectIOSurfaceID ID = FigXPCRemoteClientSendSyncMessageCreatingReply(v37, (uint64_t)value, &xdict);
            if (!ObjectID)
            {
              xpc_object_t v21 = xpc_dictionary_get_value(xdict, "AddedSubEndpoints");
              xpc_object_t v22 = xpc_dictionary_get_value(xdict, "SubtractedSubEndpoints");
              FigSimpleMutexLock(*(pthread_mutex_t **)(v19 + 32));
              uint64_t v13 = (uint64_t)FigEndpointRPCCacheApplyObjectDeltas(*(void *)(v19 + 48), v21, v22);
              if (!v13) {
                uint64_t v13 = FigEndpointRPCCacheCopyAvailableObjects(*(void *)(v19 + 48), &v39);
              }
              FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
              CFTypeRef cf = v39;
              CFTypeRef v39 = 0;
LABEL_38:
              FigXPCRelease(xdict);
              FigXPCRelease(value);
              if (v13) {
                goto LABEL_103;
              }
              goto LABEL_41;
            }
          }
        }
      }
    }
    else
    {
      ObjectIOSurfaceID ID = FigSignalErrorAt(4294954509, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v13 = ObjectID;
    goto LABEL_38;
  }
  uint64_t v13 = FigXPCSendStdCopyPropertyMessage(v32, v36, a2, &cf);
  if (v13) {
    goto LABEL_103;
  }
LABEL_41:
  CFArrayRef v11 = 0;
  if (CFEqual(@"Streams", a2) && cf)
  {
    CFTypeID v23 = CFGetTypeID(cf);
    if (v23 == CFArrayGetTypeID())
    {
      CFArrayRef v11 = (const __CFArray *)cf;
      CFTypeRef cf = 0;
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a3, 0, MEMORY[0x1E4F1D510]);
      if (!Mutable) {
        goto LABEL_89;
      }
      CFIndex Count = CFArrayGetCount(v11);
      if (Count >= 1)
      {
        CFIndex v25 = Count;
        for (CFIndex i = 0; i != v25; ++i)
        {
          xpc_object_t xdict = 0;
          xpc_object_t value = 0;
          ValueAtIndedouble x = (const __CFNumber *)CFArrayGetValueAtIndex(v11, i);
          if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt64Type, &xdict))
          {
            uint64_t v13 = FigEndpointStreamXPCRemoteRetainCopiedEndpointStream(xdict, &value);
            if (v13) {
              goto LABEL_89;
            }
            CFArrayAppendValue(Mutable, value);
            CFRelease(value);
          }
        }
      }
      CFTypeRef cf = CFRetain(Mutable);
    }
    else
    {
      CFArrayRef v11 = 0;
      CFMutableDictionaryRef Mutable = 0;
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  if (FigCFEqual(a2, @"AirPlayFromCloud")
    || FigCFEqual(a2, @"AirPlayVodkaVersion")
    || FigCFEqual(a2, @"AudioWithScreenMirroringOnly")
    || FigCFEqual(a2, @"AuthorizationType")
    || FigCFEqual(a2, @"AutoconnectEnabled")
    || FigCFEqual(a2, @"IsDissociated")
    || FigCFEqual(a2, @"ID")
    || FigCFEqual(a2, @"IsLocalDevice")
    || FigCFEqual(a2, @"IsPerAppDisplay")
    || FigCFEqual(a2, @"IsRemoteControlOnly")
    || FigCFEqual(a2, @"MACAddress")
    || FigCFEqual(a2, @"Model")
    || FigCFEqual(a2, @"Name")
    || FigCFEqual(a2, @"PrimaryUsage")
    || FigCFEqual(a2, @"Streams")
    || FigCFEqual(a2, @"Endpoints")
    || FigCFEqual(a2, @"SubType")
    || FigCFEqual(a2, @"SupportedFeatures")
    || FigCFEqual(a2, @"SystemFlags")
    || FigCFEqual(a2, @"TransportType")
    || FigCFEqual(a2, @"Type")
    || FigCFEqual(a2, @"Volume")
    || FigCFEqual(a2, @"VolumeDB")
    || FigCFEqual(a2, @"VolumeControlSupported")
    || FigCFEqual(a2, @"VolumeControlType"))
  {
    if (cf && !FigCFEqual(a2, @"ID")) {
      FigCFEqual(a2, @"Name");
    }
    if (v13) {
      BOOL v28 = 0;
    }
    else {
      BOOL v28 = cf == 0;
    }
    if (v28) {
      CFTypeRef v29 = (CFTypeRef)*MEMORY[0x1E4F1D260];
    }
    else {
      CFTypeRef v29 = cf;
    }
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, a2, v29);
  }
LABEL_89:
  if (a4)
  {
    CFTypeRef v30 = cf;
    if (cf) {
      CFTypeRef v30 = CFRetain(cf);
    }
    *a4 = v30;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v33) {
    CFRelease(v33);
  }
  FigXPCRemoteClientKillServerOnTimeout(v32, v13, "FigEndpointRemoteXPC_CopyProperty", a2);
  return v13;
}

uint64_t FigEndpointRemoteXPC_SetProperty(uint64_t a1, __CFString *a2, const void *a3)
{
  uint64_t v15 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v14 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v14);
  if (SharedXPCClient)
  {
    uint64_t v12 = SharedXPCClient;
    uint64_t v9 = v14;
    goto LABEL_15;
  }
  ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID(a1, &v15);
  uint64_t v9 = v14;
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCSendStdSetPropertyMessage(v14, v15, a2, a3), ObjectID))
  {
    uint64_t v12 = ObjectID;
    goto LABEL_15;
  }
  if (FigCFEqual(a2, @"AutoconnectEnabled"))
  {
    uint64_t v10 = DerivedStorage;
    CFArrayRef v11 = a2;
  }
  else
  {
    if (!FigCFEqual(a2, @"Volume")
      && !FigCFEqual(a2, @"VolumeDB")
      && !FigCFEqual(a2, @"IsMuted")
      && !FigCFEqual(a2, @"IsMutedByUser")
      && !FigCFEqual(a2, @"IsMutedProgrammatically")
      && !FigCFEqual(a2, @"MasterVolume"))
    {
      goto LABEL_14;
    }
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, @"Volume", 0);
    uint64_t v10 = DerivedStorage;
    CFArrayRef v11 = @"VolumeDB";
  }
  remoteXPCFigEndpoint_setCachedProperty(v10, v11, 0);
LABEL_14:
  uint64_t v12 = 0;
LABEL_15:
  FigXPCRemoteClientKillServerOnTimeout(v9, v12, "FigEndpointRemoteXPC_SetProperty", a2);
  return v12;
}

uint64_t remoteXPCFigEndpoint_copyCachedProperty(uint64_t a1, const void *a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 56), a2);
  size_t v7 = Value;
  if (Value)
  {
    CFRetain(Value);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    if (v7 == (const void *)*MEMORY[0x1E4F1D260])
    {
      CFRelease(v7);
      size_t v7 = 0;
    }
    uint64_t result = 1;
  }
  else
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    uint64_t result = 0;
  }
  *a3 = v7;
  return result;
}

uint64_t FigEndpointRemoteXPC_ActivateWithCompletionCallback(const void *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = 0;
  xpc_object_t xdict = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID((uint64_t)a1, &v18);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x61637674u, v18, &xdict), ObjectID))
  {
    uint64_t v12 = ObjectID;
    if (a4)
    {
      if (a1) {
        CFRetain(a1);
      }
      uint64_t v14 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_ActivateWithCompletionCallback_block_invoke;
      block[3] = &__block_descriptor_tmp_29_3;
      void block[4] = a4;
      void block[5] = a1;
      int v16 = v12;
      void block[6] = a5;
      dispatch_async(v14, block);
    }
  }
  else
  {
    FigXPCMessageSetCFDictionary(xdict, "ActivateOptions", a3);
    xpc_dictionary_set_uint64(xdict, "ActivationFeatures", a2);
    uint64_t v12 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback((uint64_t)a1, xdict, a4, 1, 0, 0, 0, 0, 0, a5);
  }
  FigXPCRelease(xdict);
  return v12;
}

uint64_t FigEndpointRemoteXPC_DeactivateWithCompletionCallback(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID((uint64_t)a1, &v16);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x64617674u, v16, &v15), ObjectID))
  {
    uint64_t v10 = ObjectID;
    if (a3)
    {
      if (a1) {
        CFRetain(a1);
      }
      uint64_t v12 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_DeactivateWithCompletionCallback_block_invoke;
      block[3] = &__block_descriptor_tmp_31_2;
      void block[4] = a3;
      void block[5] = a1;
      int v14 = v10;
      void block[6] = 0;
      void block[7] = a4;
      dispatch_async(v12, block);
    }
  }
  else
  {
    FigXPCMessageSetCFDictionary(v15, "DeactivateOptions", a2);
    FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
    *(void *)(DerivedStorage + 72) = 0;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    uint64_t v10 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback((uint64_t)a1, v15, a3, 0, 0, 0, 0, 0, 0, a4);
  }
  FigXPCRelease(v15);
  return v10;
}

uint64_t FigEndpointRemoteXPC_Dissociate(uint64_t a1)
{
  xpc_object_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v6 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v6);
  if (SharedXPCClient
    || (uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v8), SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x64736F63u, v8, &v7), SharedXPCClient))
  {
    uint64_t v4 = SharedXPCClient;
  }
  else
  {
    uint64_t v4 = FigXPCRemoteClientSendSyncMessage(v6, (uint64_t)v7);
    if (!v4)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      *(unsigned char *)(DerivedStorage + 40) = 1;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    }
  }
  FigXPCRelease(v7);
  return v4;
}

uint64_t FigEndpointRemoteXPC_SetDelegateRouting(uint64_t a1, long long *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xpc_object_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  uint64_t v5 = *(const void **)(DerivedStorage + 184);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 184) = 0;
  }
  uint64_t v6 = (_OWORD *)(DerivedStorage + 144);
  if (a2)
  {
    long long v7 = *a2;
    long long v8 = a2[1];
    *(void *)(DerivedStorage + 176) = *((void *)a2 + 4);
    *uint64_t v6 = v7;
    *(_OWORD *)(DerivedStorage + 160) = v8;
    *(void *)(DerivedStorage + 184) = FigCFWeakReferenceHolderCreateWithReferencedObject(*(void *)a2);
  }
  else
  {
    *(void *)(DerivedStorage + 176) = 0;
    *uint64_t v6 = 0u;
    *(_OWORD *)(DerivedStorage + 160) = 0u;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (!SharedXPCClient)
  {
    uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v15);
    if (!SharedXPCClient)
    {
      if (a2) {
        unsigned int v10 = 1935962740;
      }
      else {
        unsigned int v10 = 1667527284;
      }
      uint64_t SharedXPCClient = FigXPCCreateBasicMessage(v10, v15, &v14);
      if (!SharedXPCClient) {
        uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v13, (uint64_t)v14);
      }
    }
  }
  uint64_t v11 = SharedXPCClient;
  FigXPCRelease(v14);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_SetDelegateRouting", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_SetDelegateRemoteControl(uint64_t a1, uint64_t a2)
{
  xpc_object_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v12 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  uint64_t v5 = *(const void **)(DerivedStorage + 136);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 136) = 0;
  }
  uint64_t v6 = (_OWORD *)(DerivedStorage + 104);
  if (a2)
  {
    long long v7 = *(_OWORD *)(a2 + 16);
    *uint64_t v6 = *(_OWORD *)a2;
    *(_OWORD *)(DerivedStorage + 120) = v7;
    *(void *)(DerivedStorage + 136) = FigCFWeakReferenceHolderCreateWithReferencedObject(*(void *)a2);
  }
  else
  {
    *uint64_t v6 = 0u;
    *(_OWORD *)(DerivedStorage + 120) = 0u;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v12);
  if (!SharedXPCClient)
  {
    uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v14);
    if (!SharedXPCClient)
    {
      if (a2) {
        unsigned int v9 = 1935962723;
      }
      else {
        unsigned int v9 = 1667527267;
      }
      uint64_t SharedXPCClient = FigXPCCreateBasicMessage(v9, v14, &v13);
      if (!SharedXPCClient) {
        uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v12, (uint64_t)v13);
      }
    }
  }
  uint64_t v10 = SharedXPCClient;
  FigXPCRelease(v13);
  FigXPCRemoteClientKillServerOnTimeout(v12, v10, "FigEndpointRemoteXPC_SetDelegateRemoteControl", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_CreatePlaybackSession(uint64_t a1, CFTypeRef *a2)
{
  xpc_object_t v12 = 0;
  uint64_t v13 = 0;
  CFTypeRef cf = 0;
  xpc_object_t xdict = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v9 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v9);
  if (SharedXPCClient
    || (uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v13), SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x63706273u, v13, &v12), SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v9, (uint64_t)v12, &xdict),
        SharedXPCClient))
  {
    uint64_t v7 = SharedXPCClient;
  }
  else
  {
    uint int64 = (const void *)xpc_dictionary_get_uint64(xdict, "PlaybackSessionID");
    uint64_t v7 = FigEndpointPlaybackSessionXPCRemoteCreateWithObjectID(uint64, &cf);
    if (!v7)
    {
      *a2 = cf;
      CFTypeRef cf = 0;
    }
  }
  FigXPCRelease(v12);
  FigXPCRelease(xdict);
  if (cf) {
    CFRelease(cf);
  }
  FigXPCRemoteClientKillServerOnTimeout(v9, v7, "FigEndpointRemoteXPC_CreatePlaybackSession", 0);
  return v7;
}

uint64_t FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(uint64_t a1, void *a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v19 = DerivedStorage;
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long value = 0u;
  long long v41 = 0u;
  uint64_t v39 = 0;
  uint64_t v20 = a8 | a5 | a3 | a7;
  BOOL v21 = v20 != 0;
  if (v20)
  {
    *(void *)&long long v41 = a7;
    *((void *)&v41 + 1) = a5;
    *(void *)&long long value = a1;
    *((void *)&value + 1) = a3;
    BYTE8(v42) = a4;
    *(void *)&long long v42 = a8;
    *(void *)&long long v43 = a6;
    *((void *)&v43 + 1) = a9;
    uint64_t v44 = a10;
    FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
    uint64_t v22 = CMBaseObjectGetDerivedStorage(a1);
    CFTypeID v23 = *(const void **)(v22 + 96);
    uint64_t v24 = 1;
    if ((unint64_t)v23 + 1 > 1) {
      uint64_t v24 = (uint64_t)v23 + 1;
    }
    *(void *)(v22 + 96) = v24;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v19 + 88), v23, &value);
    uint64_t v25 = *(void *)(v19 + 64);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
    xpc_dictionary_set_uint64(a2, "CompletionID", (uint64_t)v23);
  }
  else
  {
    CFTypeID v23 = 0;
    uint64_t v25 = 0;
  }
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(v19 + 8), &v39);
  if (!SharedXPCClient) {
    uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v39, (uint64_t)a2);
  }
  uint64_t v27 = SharedXPCClient;
  char v28 = !v21;
  if (!SharedXPCClient) {
    char v28 = 1;
  }
  if ((v28 & 1) == 0)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v19 + 32));
    if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(v19 + 88), v23, 0))
    {
      remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)&value);
      CFTypeRef v29 = *(NSObject **)(v19 + 24);
      v31[0] = MEMORY[0x1E4F143A8];
      v31[1] = 0x40000000;
      v31[2] = __FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
      v31[3] = &__block_descriptor_tmp_30_1;
      long long v34 = v42;
      long long v35 = v43;
      long long v32 = value;
      long long v33 = v41;
      uint64_t v36 = v44;
      uint64_t v37 = v25;
      int v38 = v27;
      dispatch_async(v29, v31);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v19 + 88), v23);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
  }
  FigXPCRemoteClientKillServerOnTimeout(v39, v27, "FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  return v27;
}

uint64_t FigEndpointRemoteXPC_RequestCarUI(uint64_t a1, const void *a2, const void *a3)
{
  *(void *)uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v6 = ((uint64_t (*)(void))FigEndpointExtendedGetFigEndpoint)();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(v6);
  uint64_t v12 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v12);
  if (!SharedXPCClient)
  {
    uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
    uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(FigEndpoint, &v14);
    if (!SharedXPCClient)
    {
      uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x63617220u, v14, v13);
      if (!SharedXPCClient)
      {
        if (a2) {
          FigXPCMessageSetCFString(*(void **)v13, "UUID", a2);
        }
        if (a3) {
          FigXPCMessageSetCFURL(*(void **)v13, "URL", a3);
        }
        uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v12, *(uint64_t *)v13);
      }
    }
  }
  uint64_t v10 = SharedXPCClient;
  FigXPCRelease(*(xpc_object_t *)v13);
  FigXPCRemoteClientKillServerOnTimeout(v12, v10, "FigEndpointRemoteXPC_RequestCarUI", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_BorrowScreen(uint64_t a1, const void *a2, const void *a3)
{
  *(void *)uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (SharedXPCClient
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        SharedXPCClient))
  {
    uint64_t v10 = SharedXPCClient;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = FigXPCCreateBasicMessage(0x62732020u, v15, v14);
    uint64_t v11 = *(void **)v14;
    if (!v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "Client", a2);
      FigXPCMessageSetCFString(*(void **)v14, "Reason", a3);
      uint64_t v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      uint64_t v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_BorrowScreen", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_UnborrowScreen(uint64_t a1, const void *a2, const void *a3)
{
  *(void *)uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (SharedXPCClient
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        SharedXPCClient))
  {
    uint64_t v10 = SharedXPCClient;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = FigXPCCreateBasicMessage(0x756E6273u, v15, v14);
    uint64_t v11 = *(void **)v14;
    if (!v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "Client", a2);
      FigXPCMessageSetCFString(*(void **)v14, "Reason", a3);
      uint64_t v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      uint64_t v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_UnborrowScreen", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_TakeScreen(uint64_t a1, const void *a2, const void *a3)
{
  *(void *)uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (SharedXPCClient
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        SharedXPCClient))
  {
    uint64_t v10 = SharedXPCClient;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = FigXPCCreateBasicMessage(0x74732020u, v15, v14);
    uint64_t v11 = *(void **)v14;
    if (!v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "Client", a2);
      FigXPCMessageSetCFString(*(void **)v14, "Reason", a3);
      uint64_t v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      uint64_t v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_TakeScreen", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_DisableBluetoothConnectivityToDevice(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v14 = 0;
  *(void *)uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (SharedXPCClient
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14),
        SharedXPCClient))
  {
    uint64_t v10 = SharedXPCClient;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = FigXPCCreateBasicMessage(0x64627464u, v14, v15);
    uint64_t v11 = *(void **)v15;
    if (!v10)
    {
      FigXPCMessageSetCFString(*(void **)v15, "DeviceAddress", a2);
      FigXPCMessageSetCFDictionary(*(void **)v15, "DisableBluetoothOptions", a3);
      uint64_t v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v15);
      uint64_t v11 = *(void **)v15;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_DisableBluetoothConnectivityToDevice", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_DuckAudio(uint64_t a1, const void *a2)
{
  uint64_t v12 = 0;
  *(void *)uint64_t v13 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v11 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v11);
  if (SharedXPCClient
    || (uint64_t v7 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v7, &v12),
        SharedXPCClient))
  {
    uint64_t v8 = SharedXPCClient;
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v8 = FigXPCCreateBasicMessage(0x64756361u, v12, v13);
    uint64_t v9 = *(void **)v13;
    if (!v8)
    {
      FigXPCMessageSetCFDictionary(*(void **)v13, "Params", a2);
      uint64_t v8 = FigXPCRemoteClientSendSyncMessage(v11, *(uint64_t *)v13);
      uint64_t v9 = *(void **)v13;
    }
  }
  FigXPCRelease(v9);
  FigXPCRemoteClientKillServerOnTimeout(v11, v8, "FigEndpointRemoteXPC_DuckAudio", 0);
  return v8;
}

uint64_t FigEndpointRemoteXPC_SetHIDInputMode(uint64_t a1, const void *a2, const void *a3)
{
  *(void *)uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (SharedXPCClient
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        SharedXPCClient))
  {
    uint64_t v10 = SharedXPCClient;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = FigXPCCreateBasicMessage(0x73686D20u, v15, v14);
    uint64_t v11 = *(void **)v14;
    if (!v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "HIDUUID", a2);
      FigXPCMessageSetCFNumber(*(void **)v14, "HIDInputMode", a3);
      uint64_t v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      uint64_t v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_SetHIDInputMode", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_CopyHIDInputMode(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  *(void *)uint64_t v16 = 0;
  uint64_t v17 = 0;
  xpc_object_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v14 = 0;
  if (a4)
  {
    uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v14);
    if (SharedXPCClient
      || (uint64_t v10 = FigEndpointExtendedGetFigEndpoint(a1),
          uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v10, &v17),
          SharedXPCClient)
      || (uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x63686D20u, v17, v16), SharedXPCClient)
      || (uint64_t SharedXPCClient = FigXPCMessageSetCFString(*(void **)v16, "HIDUUID", a2), SharedXPCClient))
    {
      uint64_t v11 = SharedXPCClient;
      xpc_object_t v12 = 0;
    }
    else
    {
      uint64_t v11 = FigXPCRemoteClientSendSyncMessageCreatingReply(v14, *(uint64_t *)v16, &v15);
      xpc_object_t v12 = v15;
      if (!v11)
      {
        uint64_t v11 = FigXPCMessageCopyCFNumber(v15, "HIDInputMode", a4);
        xpc_object_t v12 = v15;
      }
    }
  }
  else
  {
    xpc_object_t v12 = 0;
    uint64_t v11 = 0;
  }
  FigXPCRelease(v12);
  FigXPCRelease(*(xpc_object_t *)v16);
  FigXPCRemoteClientKillServerOnTimeout(v14, v11, "FigEndpointRemoteXPC_CopyHIDInputMode", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_SendCommand(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v19 = 0;
  *(void *)uint64_t v18 = 0;
  ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID(FigEndpoint, &v19);
  if (ObjectID || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x636D6D64u, v19, v18), ObjectID))
  {
    uint64_t v13 = ObjectID;
    if (a4)
    {
      if (a1) {
        CFRetain(a1);
      }
      xpc_object_t v15 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_SendCommand_block_invoke;
      block[3] = &__block_descriptor_tmp_32_2;
      void block[4] = a4;
      void block[5] = a1;
      int v17 = v13;
      void block[6] = a5;
      dispatch_async(v15, block);
    }
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v18, "Command", a2);
    FigXPCMessageSetCFDictionary(*(void **)v18, "Params", a3);
    uint64_t v13 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(FigEndpoint, *(void **)v18, 0, 0, 0, 0, a4, 0, 0, a5);
  }
  FigXPCRelease(*(xpc_object_t *)v18);
  return v13;
}

uint64_t FigEndpointRemoteXPC_CreateRemoteControlSession(uint64_t a1, const void *a2, void *a3)
{
  xpc_object_t xdict = 0;
  *(void *)int v17 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = FigEndpointRemoteControlSessionXPCRemotePing();
  if (SharedXPCClient
    || (uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13),
        SharedXPCClient)
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x63726373u, v15, v17), SharedXPCClient)
    || (FigXPCMessageSetCFDictionary(*(void **)v17, "Params", a2),
        uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, *(uint64_t *)v17, &xdict),
        SharedXPCClient))
  {
    uint64_t v11 = SharedXPCClient;
  }
  else
  {
    uint int64 = (const void *)xpc_dictionary_get_uint64(xdict, "RemoteControlSessionID");
    uint64_t v11 = FigEndpointRemoteControlSessionXPCRemoteCreateWithObjectID(uint64, &v14);
    if (!v11) {
      *a3 = v14;
    }
  }
  FigXPCRelease(xdict);
  FigXPCRelease(*(xpc_object_t *)v17);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_CreateRemoteControlSession", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_CreateCommChannel(uint64_t a1, const void *a2, void *a3)
{
  long long value = 0;
  uint64_t v17 = 0;
  xpc_object_t v14 = 0;
  *(void *)uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (SharedXPCClient
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v17),
        SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x63726363u, v17, v15), SharedXPCClient)
    || (FigXPCMessageSetCFDictionary(*(void **)v15, "Params", a2),
        uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, *(uint64_t *)v15, &v14),
        SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCMessageCopyCFString(v14, "CommChannelUUID", &value), SharedXPCClient))
  {
    uint64_t v11 = SharedXPCClient;
  }
  else
  {
    uint64_t v10 = value;
    if (value)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 80), value);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
      uint64_t v10 = value;
    }
    uint64_t v11 = 0;
    *a3 = v10;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  FigXPCRelease(v14);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_CreateCommChannel", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_SendData(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  if (a2 && a3)
  {
    ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID(FigEndpoint, &v19);
    if (!ObjectID)
    {
      ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(0x64617461u, v19, &v18);
      if (!ObjectID)
      {
        FigXPCMessageSetCFString(v18, "CommChannelUUID", a2);
        FigXPCMessageSetCFData(v18, "Data", a3);
        uint64_t v13 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(FigEndpoint, v18, 0, 0, a4, (uint64_t)a2, 0, 0, 0, a5);
        goto LABEL_6;
      }
    }
  }
  else
  {
    ObjectIOSurfaceID ID = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v13 = ObjectID;
  if (a4 && ObjectID)
  {
    if (a1) {
      CFRetain(a1);
    }
    if (a2) {
      CFRetain(a2);
    }
    uint64_t v15 = *(NSObject **)(DerivedStorage + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __FigEndpointRemoteXPC_SendData_block_invoke;
    block[3] = &__block_descriptor_tmp_33_1;
    void block[4] = a4;
    void block[5] = a1;
    int v17 = v13;
    void block[6] = a2;
    void block[7] = a5;
    dispatch_async(v15, block);
  }
LABEL_6:
  FigXPCRelease(v18);
  return v13;
}

uint64_t FigEndpointRemoteXPC_CloseCommChannel(uint64_t a1, const void *a2)
{
  xpc_object_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  if (!a2)
  {
    uint64_t SharedXPCClient = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = SharedXPCClient;
    goto LABEL_9;
  }
  uint64_t v6 = DerivedStorage;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13);
  if (SharedXPCClient) {
    goto LABEL_11;
  }
  uint64_t v8 = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v8, &v15);
  if (SharedXPCClient) {
    goto LABEL_11;
  }
  uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x636C6363u, v15, &v14);
  if (SharedXPCClient) {
    goto LABEL_11;
  }
  uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v13, (uint64_t)v14);
  if (SharedXPCClient) {
    goto LABEL_11;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(v6 + 32));
  CFArrayRef v9 = *(const __CFArray **)(v6 + 80);
  v16.size_t length = CFArrayGetCount(v9);
  v16.location = 0;
  FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v9, v16, a2);
  if (FirstIndexOfValue != -1) {
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v6 + 80), FirstIndexOfValue);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v6 + 32));
  uint64_t v11 = 0;
LABEL_9:
  FigXPCRelease(v14);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_CloseCommChannel", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_RequestScreenViewArea(uint64_t a1, const void *a2, int64_t a3)
{
  xpc_object_t v15 = 0;
  xpc_object_t xdict = 0;
  uint64_t v14 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = FigEndpointRemoteControlSessionXPCRemotePing();
  if (SharedXPCClient
    || (uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13),
        SharedXPCClient)
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14),
        SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x72737661u, v14, &xdict), SharedXPCClient))
  {
    uint64_t v10 = SharedXPCClient;
    xpc_object_t v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(xdict, "UUID", a2);
    xpc_dictionary_set_int64(xdict, "Index", a3);
    uint64_t v10 = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, (uint64_t)xdict, &v15);
    xpc_object_t v11 = v15;
  }
  FigXPCRelease(v11);
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_RequestScreenViewArea", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_CopyCurrentScreenViewArea(uint64_t a1, const void *a2, void *a3)
{
  xpc_object_t v15 = 0;
  *(void *)CFRange v16 = 0;
  uint64_t v14 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v13 = 0;
  uint64_t SharedXPCClient = FigEndpointRemoteControlSessionXPCRemotePing();
  if (SharedXPCClient
    || (uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v13),
        SharedXPCClient)
    || (uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1),
        uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14),
        SharedXPCClient)
    || (uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x63737661u, v14, v16), SharedXPCClient))
  {
    uint64_t v10 = SharedXPCClient;
    xpc_object_t v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v16, "UUID", a2);
    uint64_t v10 = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, *(uint64_t *)v16, &v15);
    xpc_object_t v11 = v15;
    if (!v10)
    {
      uint64_t v10 = FigXPCMessageCopyCFDictionary(v15, "ViewArea", a3);
      xpc_object_t v11 = v15;
    }
  }
  FigXPCRelease(v11);
  FigXPCRelease(*(xpc_object_t *)v16);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_CopyCurrentScreenViewArea", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_AcquireAndCopyResource(uint64_t a1, const void *a2, const void *a3, void *a4)
{
  xpc_object_t xdict = 0;
  *(void *)uint64_t v19 = 0;
  uint64_t v17 = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v16 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v16);
  if (!SharedXPCClient)
  {
    uint64_t v11 = FigEndpointExtendedGetFigEndpoint(a1);
    uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v11, &v17);
    if (!SharedXPCClient)
    {
      uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x61727363u, v17, v19);
      if (!SharedXPCClient)
      {
        uint64_t SharedXPCClient = FigXPCMessageSetCFString(*(void **)v19, "ResourceType", a2);
        if (!SharedXPCClient)
        {
          uint64_t SharedXPCClient = FigXPCMessageSetCFDictionary(*(void **)v19, "ResourceOptions", a3);
          if (!SharedXPCClient)
          {
            uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v16, *(uint64_t *)v19, &xdict);
            if (!SharedXPCClient)
            {
              uint int64 = xpc_dictionary_get_uint64(xdict, "ResourceID");
              if (!uint64)
              {
                uint64_t v14 = 4294950567;
                goto LABEL_12;
              }
              uint64_t v13 = (const void *)uint64;
              if (!FigCFEqual(a2, @"endpointStream"))
              {
                uint64_t v14 = 4294950570;
                goto LABEL_12;
              }
              uint64_t SharedXPCClient = FigEndpointStreamXPCRemoteRetainCopiedEndpointStream(v13, a4);
            }
          }
        }
      }
    }
  }
  uint64_t v14 = SharedXPCClient;
LABEL_12:
  FigXPCRelease(*(xpc_object_t *)v19);
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(v16, v14, "FigEndpointRemoteXPC_AcquireAndCopyResource", 0);
  return v14;
}

uint64_t FigEndpointRemoteXPC_RelinquishResource(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v14 = 0;
  xpc_object_t xdict = 0;
  uint64_t value = 0;
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  uint64_t v12 = 0;
  uint64_t SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(void *)(DerivedStorage + 8), &v12);
  if (!SharedXPCClient)
  {
    uint64_t v9 = FigEndpointExtendedGetFigEndpoint(a1);
    uint64_t SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14);
    if (!SharedXPCClient)
    {
      uint64_t SharedXPCClient = FigXPCCreateBasicMessage(0x72727363u, v14, &xdict);
      if (!SharedXPCClient)
      {
        uint64_t SharedXPCClient = FigXPCMessageSetCFString(xdict, "ResourceType", a2);
        if (!SharedXPCClient)
        {
          if (!FigCFEqual(a2, @"endpointStream"))
          {
            uint64_t v10 = 4294950570;
            goto LABEL_10;
          }
          uint64_t SharedXPCClient = FigEndpointStreamXPCRemoteGetObjectID(a3, &value);
          if (!SharedXPCClient)
          {
            xpc_dictionary_set_uint64(xdict, "ResourceID", value);
            uint64_t SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v12, (uint64_t)xdict);
          }
        }
      }
    }
  }
  uint64_t v10 = SharedXPCClient;
LABEL_10:
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(v12, v10, "FigEndpointRemoteXPC_RelinquishResource", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_EndpointAggregateAddEndpointWithCompletionCallback(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  return FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback(a1, a2, 0x61656165u, a3, a4, a5);
}

uint64_t FigEndpointRemoteXPC_EndpointAggregateRemoveEndpointWithCompletionCallback(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  return FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback(a1, a2, 0x61657265u, a3, a4, a5);
}

uint64_t FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback(const void *a1, const void *a2, unsigned int a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID((uint64_t)a1, &v22);
  if (ObjectID
    || (ObjectIOSurfaceID ID = FigXPCCreateBasicMessage(a3, v22, &v20), ObjectID)
    || (ObjectIOSurfaceID ID = FigEndpointXPCRemoteGetObjectID((uint64_t)a2, &v21), ObjectID))
  {
    uint64_t v14 = ObjectID;
    if (a5)
    {
      if (a1) {
        CFRetain(a1);
      }
      if (a2) {
        CFRetain(a2);
      }
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      uint64_t v16 = *(void *)(DerivedStorage + 64);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
      uint64_t v17 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback_block_invoke;
      block[3] = &__block_descriptor_tmp_34_2;
      void block[4] = a5;
      void block[5] = a1;
      void block[6] = a2;
      void block[7] = v16;
      int v19 = v14;
      void block[8] = a6;
      dispatch_async(v17, block);
    }
  }
  else
  {
    FigXPCMessageSetCFDictionary(v20, "AggregateOptions", a4);
    xpc_dictionary_set_uint64(v20, "SubEndpointObjectID", v21);
    uint64_t v14 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback((uint64_t)a1, v20, 0, 0, 0, 0, 0, a5, (uint64_t)a2, a6);
    if (!v14) {
      remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(DerivedStorage);
    }
  }
  FigXPCRelease(v20);
  return v14;
}

uint64_t FigEndpointAudioSourceGetClassID()
{
  if (FigEndpointAudioSourceGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigEndpointAudioSourceGetClassID_sRegisterOnce, &FigEndpointAudioSourceGetClassID_sClassID, (dispatch_function_t)source_getClassID);
  }
  return FigEndpointAudioSourceGetClassID_sClassID;
}

uint64_t source_getClassID(void *a1)
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&source_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointAudioSourceGetTypeID()
{
  if (FigEndpointAudioSourceGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigEndpointAudioSourceGetClassID_sRegisterOnce, &FigEndpointAudioSourceGetClassID_sClassID, (dispatch_function_t)source_getClassID);
  }
  unint64_t v0 = (void *)FigEndpointAudioSourceGetClassID_sClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef source_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointAudioSource %p]", a1);
}

uint64_t FigEndpointStartServerEx(const char *a1)
{
  v5[0] = 1;
  v5[1] = HandleEndpointRemoteMessage;
  v5[2] = HandleNoReplyEndpointMessage;
  memset(&v5[3], 0, 24);
  if (!a1) {
    return FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32(Mutable, @"xpcServerOption_SelfTerminationTimeout", 30);
  uint64_t v3 = FigXPCServerStart((uint64_t)a1, v5, (uint64_t)Mutable, &gEndpointServer);
  if (!v3)
  {
    gServerSource = strcmp(a1, "com.apple.airplay.endpoint.xpc") == 0;
    if (GetActiveEndpointQueue_onceToken != -1)
    {
      dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_67_0);
      if (!Mutable) {
        return v3;
      }
      goto LABEL_5;
    }
  }
  if (Mutable) {
LABEL_5:
  }
    CFRelease(Mutable);
  return v3;
}

uint64_t HandleEndpointRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v26 = 0;
  uint64_t v24 = 0;
  CFTypeRef v25 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v26);
  if (OpCode) {
    return OpCode;
  }
  if (v26 == 1635150946)
  {
    uint64_t v34 = 0;
    long long v35 = &v34;
    uint64_t v36 = 0x2000000000;
    LOBYTE(v37) = 0;
    if (GetActiveEndpointQueue_onceToken != -1) {
      dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_67_0);
    }
    blocuint64_t k = MEMORY[0x1E4F143A8];
    uint64_t v30 = 0x40000000;
    uint64_t v31 = __HandleEndpointIsActiveEndpointAvailableMessage_block_invoke;
    long long v32 = &unk_1E567F698;
    long long v33 = &v34;
    dispatch_sync((dispatch_queue_t)gActiveEndpointQueue, &block);
    xpc_dictionary_set_BOOL(a3, ".Value", *((unsigned char *)v35 + 24) != 0);
    _Block_object_dispose(&v34, 8);
    uint64_t v12 = 0;
LABEL_55:
    CFTypeRef v15 = v25;
    if (!v25) {
      return v12;
    }
    goto LABEL_117;
  }
  if (v26 == 1633907830)
  {
    CFTypeRef v27 = 0;
    CFTypeRef cf = 0;
    uint64_t v34 = 0;
    long long v35 = &v34;
    uint64_t v36 = 0x2000000000;
    uint64_t v37 = 0;
    uint64_t v7 = FigXPCMessageCopyCFString(a2, "EndpointType", &cf);
    if (!v7)
    {
      if (GetActiveEndpointQueue_onceToken != -1) {
        dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_67_0);
      }
      blocuint64_t k = MEMORY[0x1E4F143A8];
      uint64_t v30 = 0x40000000;
      uint64_t v31 = __HandleEndpointCopyActiveEndpointMessage_block_invoke;
      long long v32 = &unk_1E567F670;
      long long v33 = &v34;
      dispatch_sync((dispatch_queue_t)gActiveEndpointQueue, &block);
      uint64_t v8 = v35[3];
      if (!v8)
      {
        uint64_t v17 = 0;
LABEL_45:
        uint64_t v7 = FigEndpointXPCServerWriteNeighborEndpointToReply(a1, v17, a3, 0);
        goto LABEL_46;
      }
      uint64_t CMBaseObject = FigEndpointGetCMBaseObject(v8);
      uint64_t v10 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v18 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v11 + 48);
      if (!v18)
      {
        uint64_t v12 = 4294954514;
        goto LABEL_48;
      }
      uint64_t v7 = v18(CMBaseObject, @"Type", *MEMORY[0x1E4F1CF80], &v27);
      if (!v7)
      {
        int v19 = FigCFEqual(cf, v27);
        uint64_t v17 = (void *)v35[3];
        if (!v19 && v17)
        {
          CFRelease((CFTypeRef)v35[3]);
          uint64_t v17 = 0;
          v35[3] = 0;
        }
        goto LABEL_45;
      }
    }
LABEL_46:
    uint64_t v12 = v7;
LABEL_48:
    uint64_t v20 = (const void *)v35[3];
    if (v20) {
      CFRelease(v20);
    }
    if (cf) {
      CFRelease(cf);
    }
    if (v27) {
      CFRelease(v27);
    }
    _Block_object_dispose(&v34, 8);
    goto LABEL_55;
  }
  uint int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  uint64_t v14 = LookupEndpointByObjectIDForConnection(a1, uint64, &v25, &v24);
  if (v14) {
    goto LABEL_94;
  }
  uint64_t v12 = 4294951138;
  if (v26 > 1668313956)
  {
    if (v26 > 1685286754)
    {
      if (v26 <= 1935962722)
      {
        if (v26 > 1920103266)
        {
          if (v26 == 1920103267)
          {
            CFTypeRef v15 = v25;
            uint64_t RemoteControlSessionMessage = HandleEndpointRelinquishResourceMessage((char *)v25, a2);
          }
          else
          {
            if (v26 != 1920169569) {
              goto LABEL_55;
            }
            CFTypeRef v15 = v25;
            uint64_t RemoteControlSessionMessage = HandleEndpointRequestScreenViewAreaMessage((char *)v25, a2);
          }
        }
        else if (v26 == 1685286755)
        {
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointDissociateMessage((uint64_t)v25);
        }
        else
        {
          if (v26 != 1685414753) {
            goto LABEL_55;
          }
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointDuckAudio((char *)v25, a2);
        }
      }
      else if (v26 <= 1936223519)
      {
        if (v26 == 1935962723)
        {
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointSetDelegateRemoteControlMessage((uint64_t)v25, a1, uint64, v24);
        }
        else
        {
          if (v26 != 1935962740) {
            goto LABEL_55;
          }
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointSetDelegateRoutingMessage((uint64_t)v25, a1, uint64, v24);
        }
      }
      else
      {
        switch(v26)
        {
          case 1936223520:
            CFTypeRef v15 = v25;
            uint64_t RemoteControlSessionMessage = HandleEndpointSetHIDInputMessage((char *)v25, a2);
            break;
          case 1953701920:
            CFTypeRef v15 = v25;
            uint64_t RemoteControlSessionMessage = HandleEndpointTakeScreenMessage((char *)v25, a2);
            break;
          case 1970168435:
            CFTypeRef v15 = v25;
            uint64_t RemoteControlSessionMessage = HandleEndpointUnborrowScreenMessage((char *)v25, a2);
            break;
          default:
            goto LABEL_55;
        }
      }
      goto LABEL_116;
    }
    if (v26 <= 1684108384)
    {
      if (v26 > 1668440946)
      {
        if (v26 == 1668440947)
        {
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointCreateRemoteControlSessionMessage((char *)v25, a1, a2, a3);
        }
        else
        {
          if (v26 != 1668511329) {
            goto LABEL_55;
          }
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointCopyCurrentScreenViewAreaMessage((char *)v25, a2, a3);
        }
      }
      else if (v26 == 1668313957)
      {
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointCopySubEndpointsMessage((uint64_t)v25, a1, a3, v24);
      }
      else
      {
        if (v26 != 1668440931) {
          goto LABEL_55;
        }
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointCreateCommChannelMessage((uint64_t)v25, a2, a3);
      }
      goto LABEL_116;
    }
    if (v26 <= 1684173923)
    {
      if (v26 == 1684108385)
      {
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointSendDataMessage((uint64_t)v25, a1, a2);
      }
      else
      {
        if (v26 != 1684108916) {
          goto LABEL_55;
        }
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointDeactivateMessage((uint64_t)v25, a1, a2);
      }
      goto LABEL_116;
    }
    if (v26 == 1684173924)
    {
      CFTypeRef v15 = v25;
      uint64_t RemoteControlSessionMessage = HandleEndpointDisableBluetoothConnectivityToDevice((char *)v25, a2);
      goto LABEL_116;
    }
    if (v26 != 1685024621) {
      goto LABEL_55;
    }
    uint64_t v14 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_94:
    uint64_t v12 = v14;
    goto LABEL_55;
  }
  if (v26 > 1667527266)
  {
    if (v26 > 1668047714)
    {
      if (v26 > 1668117350)
      {
        if (v26 == 1668117351)
        {
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointCopyMessengerMessage((uint64_t)v25, a1, a3);
        }
        else
        {
          if (v26 != 1668309619) {
            goto LABEL_55;
          }
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointCreatePlaybackSessionMessage((uint64_t)v25, a1, a3);
        }
      }
      else if (v26 == 1668047715)
      {
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointCloseCommChannelMessage((uint64_t)v25, a2);
      }
      else
      {
        if (v26 != 1668115812) {
          goto LABEL_55;
        }
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointSendCommandMessage((char *)v25, a1, a2);
      }
    }
    else if (v26 > 1667589743)
    {
      if (v26 == 1667589744)
      {
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointCopyEndpointForAnotherProcess(v25, a2, a3);
      }
      else
      {
        if (v26 != 1667788064) {
          goto LABEL_55;
        }
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointCopyHIDInputMessage((char *)v25, a2, a3);
      }
    }
    else if (v26 == 1667527267)
    {
      CFTypeRef v15 = v25;
      uint64_t RemoteControlSessionMessage = HandleEndpointClearDelegateRemoteControlMessage((uint64_t)v25, v24);
    }
    else
    {
      if (v26 != 1667527284) {
        goto LABEL_55;
      }
      CFTypeRef v15 = v25;
      uint64_t RemoteControlSessionMessage = HandleEndpointClearDelegateRoutingMessage((uint64_t)v25, v24);
    }
  }
  else
  {
    if (v26 <= 1634038372)
    {
      if (v26 <= 1633908339)
      {
        if (v26 == 778268793)
        {
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = HandleEndpointCopyPropertyMessage((uint64_t)v25, a1, a2, a3);
        }
        else
        {
          if (v26 != 779314548) {
            goto LABEL_55;
          }
          CFTypeRef v15 = v25;
          uint64_t RemoteControlSessionMessage = FigXPCHandleStdSetPropertyMessage((uint64_t)v25, a2);
        }
        goto LABEL_116;
      }
      if (v26 == 1633908340)
      {
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointActivateMessage((uint64_t)v25, a1, a2);
        goto LABEL_116;
      }
      if (v26 != 1634034021) {
        goto LABEL_55;
      }
      CFTypeRef v15 = v25;
      uint64_t v21 = (char *)v25;
      int v22 = 1;
      goto LABEL_105;
    }
    if (v26 <= 1651712031)
    {
      if (v26 != 1634038373)
      {
        if (v26 != 1634890595) {
          goto LABEL_55;
        }
        CFTypeRef v15 = v25;
        uint64_t RemoteControlSessionMessage = HandleEndpointAcquireAndCopyResourceMessage((char *)v25, a1, a2, a3);
        goto LABEL_116;
      }
      CFTypeRef v15 = v25;
      uint64_t v21 = (char *)v25;
      int v22 = 0;
LABEL_105:
      uint64_t RemoteControlSessionMessage = HandleEndpointAddRemoveEndpointMessage(v21, v22, a1, a2);
      goto LABEL_116;
    }
    if (v26 == 1651712032)
    {
      CFTypeRef v15 = v25;
      uint64_t RemoteControlSessionMessage = HandleEndpointBorrowScreenMessage((char *)v25, a2);
    }
    else
    {
      if (v26 != 1667330592) {
        goto LABEL_55;
      }
      CFTypeRef v15 = v25;
      uint64_t RemoteControlSessionMessage = HandleEndpointRequestCarUIMessage((char *)v25, a2);
    }
  }
LABEL_116:
  uint64_t v12 = RemoteControlSessionMessage;
  if (v15) {
LABEL_117:
  }
    CFRelease(v15);
  return v12;
}

uint64_t HandleNoReplyEndpointMessage(_xpc_connection_s *a1, void *a2)
{
  int v10 = 0;
  CFTypeRef cf = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v10);
  if (OpCode) {
    return OpCode;
  }
  uint int64 = xpc_dictionary_get_uint64(a2, ".objectID");
  unsigned int v6 = LookupEndpointByObjectIDForConnection(a1, uint64, &cf, 0);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 4294950586;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t FigEndpointStartServer()
{
  if (FigIsAirplaydEnabled()) {
    unint64_t v0 = "com.apple.mediaexperience.endpoint.xpc";
  }
  else {
    unint64_t v0 = "com.apple.coremedia.endpoint.xpc";
  }

  return FigEndpointStartServerEx(v0);
}

const char *FigEndpointXPCServerNameForSource(uint64_t a1)
{
  if (a1 == 1) {
    return "com.apple.airplay.endpoint.xpc";
  }
  if (a1) {
    return 0;
  }
  if (FigIsAirplaydEnabled()) {
    return "com.apple.mediaexperience.endpoint.xpc";
  }
  return "com.apple.coremedia.endpoint.xpc";
}

void FigEndpointServerSetActiveEndpoint(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  if (GetActiveEndpointQueue_onceToken != -1) {
    dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_67_0);
  }
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 0x40000000;
  void v2[2] = __FigEndpointServerSetActiveEndpointAndForceNotify_block_invoke;
  v2[3] = &__block_descriptor_tmp_70;
  v2[4] = cf;
  char v3 = 0;
  dispatch_async((dispatch_queue_t)gActiveEndpointQueue, v2);
}

uint64_t FigXPCEndpointServerAssociateNeighborFigEndpointWithRegistration(_xpc_connection_s *a1, CFTypeRef cf, void *a3)
{
  if (cf && (CFTypeID v6 = CFGetTypeID(cf), v6 == FigEndpointGetTypeID()))
  {
    uint64_t v7 = gEndpointServer;
    return FigXPCServerAssociateCopiedObjectWithNeighborProcess(v7, a1, cf, 0, 0, 0, a3);
  }
  else
  {
    return FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigXPCEndpointServerRetainEndpointForID(void *a1, void *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gEndpointServer, a1, a2);
}

uint64_t FigEndpointXPCServerWriteNeighborEndpointToReply(_xpc_connection_s *a1, void *cf, void *a3, uint64_t *a4)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v11 = 0;
  uint64_t value = 0;
  if (!cf)
  {
    uint64_t v10 = 0;
LABEL_6:
    xpc_dictionary_set_uint64(a3, "EndpointObjectID", v10);
    xpc_dictionary_set_uint64(a3, "EndpointXPCSource", value);
    if ((value & 0x1000) != 0)
    {
      xpc_dictionary_set_uint64(a3, "SubEndpointObjectID", v13);
      xpc_dictionary_set_uint64(a3, "SubEndpointXPCSource", v11);
    }
    uint64_t result = 0;
    if (a4) {
      *a4 = v14;
    }
    return result;
  }
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 == FigEndpointGetTypeID())
  {
    uint64_t result = figEndpointXPC_getNeighborObjectIDAndSource(a1, cf, &v14, (uint64_t *)&value, &v13, &v11);
    if (result) {
      return result;
    }
    uint64_t v10 = v14;
    goto LABEL_6;
  }

  return FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
}

uint64_t figEndpointXPC_getNeighborObjectIDAndSource(_xpc_connection_s *a1, void *a2, void *a3, uint64_t *a4, void *a5, void *a6)
{
  uint64_t v25 = 0;
  CFTypeRef cf = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v22 = 0;
  if (!a2 || (CFTypeID v12 = CFGetTypeID(a2), v12 != FigEndpointGetTypeID()) || !a3 || !a4)
  {
    uint64_t ObjectIDForSource = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  if (!FigEndpointIsXPCRemote((uint64_t)a2))
  {
    uint64_t v14 = gServerSource;
    uint64_t v23 = gServerSource;
    ClassIOSurfaceID ID = (void *)FigEndpointAggregateGetClassID();
    if (CMBaseObjectIsMemberOfClass((char *)a2, ClassID))
    {
      v14 |= 0x2000uLL;
      uint64_t v23 = v14;
    }
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a2);
    uint64_t v17 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v17) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = 0;
    }
    int v19 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v18 + 48);
    if (!v19
      || (v19(CMBaseObject, @"CarPlaySubEndpoint", *MEMORY[0x1E4F1CF80], &cf), !cf)
      || (v14 |= 0x1000uLL,
          uint64_t v23 = v14,
          uint64_t ObjectIDForSource = figEndpointXPC_getNeighborObjectIDAndSource(a1, cf, &v24, &v22, 0, 0),
          !ObjectIDForSource))
    {
      uint64_t ObjectIDForSource = figEndpointXPC_getObjectIDForSource(a1, a2, v14, &v25);
      if (!ObjectIDForSource) {
        goto LABEL_18;
      }
    }
LABEL_26:
    uint64_t v20 = ObjectIDForSource;
    goto LABEL_22;
  }
  uint64_t ObjectIDForSource = FigEndpointXPCRemoteGetSource((uint64_t)a2, &v23);
  if (ObjectIDForSource) {
    goto LABEL_26;
  }
  uint64_t ObjectIDForSource = figEndpointXPC_getObjectIDForSource(a1, a2, v23, &v25);
  if (ObjectIDForSource) {
    goto LABEL_26;
  }
  uint64_t v14 = v23;
LABEL_18:
  *a3 = v25;
  *a4 = v14;
  if (a5) {
    *a5 = v24;
  }
  uint64_t v20 = 0;
  if (a6) {
    *a6 = v22;
  }
LABEL_22:
  if (cf) {
    CFRelease(cf);
  }
  return v20;
}

uint64_t FigEndpointXPCSourceNeedsSubEndpoint(unsigned int a1)
{
  return (a1 >> 12) & 1;
}

uint64_t FigEndpointXPCServerAppendNeighborEndpointToArray(_xpc_connection_s *a1, void *cf, void *a3, uint64_t *a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == FigEndpointGetTypeID()))
  {
    emptdouble y = xpc_dictionary_create_empty();
    uint64_t v10 = FigEndpointXPCServerWriteNeighborEndpointToReply(a1, cf, empty, a4);
    if (!v10) {
      xpc_array_set_value(a3, 0xFFFFFFFFFFFFFFFFLL, empty);
    }
  }
  else
  {
    uint64_t v10 = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    emptdouble y = 0;
  }
  FigXPCRelease(empty);
  return v10;
}

unint64_t FigEndpointXPCSourceGetBase(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFFCFFFLL;
}

uint64_t LookupEndpointByObjectIDForConnection(_xpc_connection_s *a1, uint64_t a2, CFTypeRef *a3, void *a4)
{
  CFTypeRef cf = 0;
  uint64_t v5 = FigXPCServerLookupAndRetainAssociatedObject(a1, a2, &cf, a4);
  if (!v5)
  {
    if (cf)
    {
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == FigEndpointGetTypeID())
      {
        uint64_t v7 = 0;
        *a3 = cf;
        return v7;
      }
    }
    uint64_t v5 = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v7 = v5;
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t HandleEndpointCopyPropertyMessage(uint64_t a1, _xpc_connection_s *a2, void *a3, void *a4)
{
  theArradouble y = 0;
  CFTypeRef cf1 = 0;
  uint64_t v7 = FigXPCMessageCopyCFString(a3, ".PropertyName", &cf1);
  if (!v7)
  {
    CFTypeRef v8 = cf1;
    if (cf1)
    {
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
      if (v9) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v11 = *(uint64_t (**)(uint64_t, CFTypeRef, void, CFArrayRef *))(v10 + 48);
      if (!v11)
      {
        uint64_t v24 = 4294954514;
        goto LABEL_24;
      }
      CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v7 = v11(a1, v8, *MEMORY[0x1E4F1CF80], &theArray);
      if (!v7)
      {
        int v13 = CFEqual(cf1, @"Streams");
        CFArrayRef v14 = theArray;
        if (v13)
        {
          CFIndex Count = CFArrayGetCount(theArray);
          CFArrayRef v16 = theArray;
          if (theArray)
          {
            uint64_t v17 = Count;
            CFArrayRef Mutable = CFArrayCreateMutable(v12, 0, MEMORY[0x1E4F1D510]);
            theArradouble y = Mutable;
            if (!Mutable)
            {
              uint64_t v24 = 4294950585;
LABEL_23:
              CFRelease(v16);
              goto LABEL_24;
            }
            if (v17 >= 1)
            {
              CFIndex v19 = 0;
              while (1)
              {
                uint64_t valuePtr = 0;
                ValueAtIndedouble x = CFArrayGetValueAtIndex(v16, v19);
                uint64_t v21 = FigXPCEndpointStreamServerAssociateCopiedNeighborFigEndpointStream(a2, ValueAtIndex, &valuePtr);
                if (v21) {
                  break;
                }
                CFNumberRef v22 = CFNumberCreate(v12, kCFNumberSInt64Type, &valuePtr);
                if (!v22)
                {
                  uint64_t v24 = 4294950585;
                  if (v16) {
                    goto LABEL_23;
                  }
                  goto LABEL_24;
                }
                CFNumberRef v23 = v22;
                CFArrayAppendValue(theArray, v22);
                CFRelease(v23);
                if (v17 == ++v19)
                {
                  CFArrayRef v14 = theArray;
                  goto LABEL_21;
                }
              }
LABEL_22:
              uint64_t v24 = v21;
              if (!v16) {
                goto LABEL_24;
              }
              goto LABEL_23;
            }
            CFArrayRef v14 = Mutable;
          }
          else
          {
            CFArrayRef v14 = 0;
          }
        }
        else
        {
          CFArrayRef v16 = 0;
        }
LABEL_21:
        uint64_t v21 = FigXPCMessageSetCFObject(a4, ".Value", v14);
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    }
  }
  uint64_t v24 = v7;
LABEL_24:
  if (theArray) {
    CFRelease(theArray);
  }
  if (cf1) {
    CFRelease(cf1);
  }
  return v24;
}

uint64_t HandleEndpointSetDelegateRemoteControlMessage(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  if (!a4) {
    return 4294954513;
  }
  uint64_t DelegateCallbackParameters = CreateDelegateCallbackParameters(a3, a2, (uint64_t *)&cf);
  CFTypeRef v7 = cf;
  if (DelegateCallbackParameters) {
    goto LABEL_12;
  }
  CFTypeRef v8 = *(const void **)(a4 + 16);
  *(void *)(a4 + 16) = cf;
  if (v7) {
    CFRetain(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  long long v14 = *(unint64_t *)(a4 + 16);
  *(void *)&long long v15 = SendDidReceiveDataFromCommChannelCallback;
  *((void *)&v15 + 1) = SendDidCloseCommChannelCallback;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, long long *))(v10 + 56);
  if (v11)
  {
    uint64_t DelegateCallbackParameters = v11(a1, &v14);
LABEL_12:
    uint64_t v12 = DelegateCallbackParameters;
    if (!v7) {
      return v12;
    }
    goto LABEL_15;
  }
  uint64_t v12 = 4294954514;
  if (v7) {
LABEL_15:
  }
    CFRelease(v7);
  return v12;
}

uint64_t HandleEndpointClearDelegateRemoteControlMessage(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 4294954513;
  }
  uint64_t v4 = *(const void **)(a2 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 16) = 0;
  }
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  CFTypeRef v7 = *(uint64_t (**)(uint64_t, void))(v6 + 56);
  if (!v7) {
    return 4294954514;
  }

  return v7(a1, 0);
}

uint64_t HandleEndpointSetDelegateRoutingMessage(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  CFTypeRef cf = 0;
  if (!a4) {
    return 4294954513;
  }
  uint64_t DelegateCallbackParameters = CreateDelegateCallbackParameters(a3, a2, (uint64_t *)&cf);
  CFTypeRef v7 = cf;
  if (DelegateCallbackParameters) {
    goto LABEL_12;
  }
  CFTypeRef v8 = *(const void **)(a4 + 8);
  *(void *)(a4 + 8) = cf;
  if (v7) {
    CFRetain(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  *(void *)&long long v15 = *(void *)(a4 + 8);
  *((void *)&v15 + 1) = SendHandleAuthRequiredCallback;
  *(void *)&long long v16 = SendHandleFailedCallback;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, long long *))(v10 + 48);
  if (v11)
  {
    uint64_t DelegateCallbackParameters = v11(a1, &v15);
LABEL_12:
    uint64_t v12 = DelegateCallbackParameters;
    if (!v7) {
      return v12;
    }
    goto LABEL_15;
  }
  uint64_t v12 = 4294954514;
  if (v7) {
LABEL_15:
  }
    CFRelease(v7);
  return v12;
}

uint64_t HandleEndpointClearDelegateRoutingMessage(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 4294954513;
  }
  uint64_t v4 = *(const void **)(a2 + 8);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 8) = 0;
  }
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  CFTypeRef v7 = *(uint64_t (**)(uint64_t, void))(v6 + 48);
  if (!v7) {
    return 4294954514;
  }

  return v7(a1, 0);
}

uint64_t HandleEndpointRequestCarUIMessage(char *a1, void *a2)
{
  uint64_t v13 = 0;
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = v5;
    goto LABEL_13;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "UUID", &v13);
  if (v5) {
    goto LABEL_11;
  }
  uint64_t v5 = FigXPCMessageCopyCFURL(a2, "URL", &cf);
  if (v5) {
    goto LABEL_11;
  }
  uint64_t v6 = v13;
  CFTypeRef v7 = cf;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, CFTypeRef))(v9 + 8);
  if (v10)
  {
    uint64_t v5 = v10(a1, v6, v7);
    goto LABEL_11;
  }
  uint64_t v11 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t HandleEndpointBorrowScreenMessage(char *a1, void *a2)
{
  CFTypeRef v13 = 0;
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = v5;
    goto LABEL_13;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "Client", &cf);
  if (v5) {
    goto LABEL_11;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "Reason", &v13);
  if (v5) {
    goto LABEL_11;
  }
  CFTypeRef v7 = v13;
  CFTypeRef v6 = cf;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(v9 + 16);
  if (v10)
  {
    uint64_t v5 = v10(a1, v6, v7);
    goto LABEL_11;
  }
  uint64_t v11 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v11;
}

uint64_t HandleEndpointUnborrowScreenMessage(char *a1, void *a2)
{
  CFTypeRef v13 = 0;
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = v5;
    goto LABEL_13;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "Client", &cf);
  if (v5) {
    goto LABEL_11;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "Reason", &v13);
  if (v5) {
    goto LABEL_11;
  }
  CFTypeRef v7 = v13;
  CFTypeRef v6 = cf;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(v9 + 24);
  if (v10)
  {
    uint64_t v5 = v10(a1, v6, v7);
    goto LABEL_11;
  }
  uint64_t v11 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v11;
}

uint64_t HandleEndpointTakeScreenMessage(char *a1, void *a2)
{
  CFTypeRef v13 = 0;
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = v5;
    goto LABEL_13;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "Client", &cf);
  if (v5) {
    goto LABEL_11;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "Reason", &v13);
  if (v5) {
    goto LABEL_11;
  }
  CFTypeRef v7 = v13;
  CFTypeRef v6 = cf;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(v9 + 32);
  if (v10)
  {
    uint64_t v5 = v10(a1, v6, v7);
    goto LABEL_11;
  }
  uint64_t v11 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v11;
}

uint64_t HandleEndpointCopyHIDInputMessage(char *a1, void *a2, void *a3)
{
  CFTypeRef v14 = 0;
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v7 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  uint64_t v7 = FigXPCMessageCopyCFString(a2, "HIDUUID", &cf);
  if (v7)
  {
LABEL_11:
    uint64_t v12 = v7;
    goto LABEL_13;
  }
  CFTypeRef v8 = cf;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(char *, CFTypeRef, void, CFTypeRef *))(v10 + 64);
  if (v11)
  {
    uint64_t v7 = v11(a1, v8, *MEMORY[0x1E4F1CF80], &v14);
    if (!v7) {
      uint64_t v7 = FigXPCMessageSetCFNumber(a3, "HIDInputMode", v14);
    }
    goto LABEL_11;
  }
  uint64_t v12 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v12;
}

uint64_t HandleEndpointDisableBluetoothConnectivityToDevice(char *a1, void *a2)
{
  CFTypeRef v13 = 0;
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = v5;
    goto LABEL_13;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "DeviceAddress", &cf);
  if (v5) {
    goto LABEL_11;
  }
  uint64_t v5 = FigXPCMessageCopyCFDictionary(a2, "DisableBluetoothOptions", &v13);
  if (v5) {
    goto LABEL_11;
  }
  CFTypeRef v7 = v13;
  CFTypeRef v6 = cf;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(v9 + 40);
  if (v10)
  {
    uint64_t v5 = v10(a1, v6, v7);
    goto LABEL_11;
  }
  uint64_t v11 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v11;
}

uint64_t HandleEndpointDuckAudio(char *a1, void *a2)
{
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  uint64_t v5 = FigXPCMessageCopyCFDictionary(a2, "Params", &cf);
  if (v5)
  {
LABEL_10:
    uint64_t v10 = v5;
    goto LABEL_12;
  }
  CFTypeRef v6 = cf;
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(char *, CFTypeRef))(v8 + 48);
  if (v9)
  {
    uint64_t v5 = v9(a1, v6);
    goto LABEL_10;
  }
  uint64_t v10 = 4294954514;
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t HandleEndpointSetHIDInputMessage(char *a1, void *a2)
{
  CFTypeRef v13 = 0;
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v11 = v5;
    goto LABEL_13;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "HIDUUID", &cf);
  if (v5) {
    goto LABEL_11;
  }
  uint64_t v5 = FigXPCMessageCopyCFNumber(a2, "HIDInputMode", &v13);
  if (v5) {
    goto LABEL_11;
  }
  CFTypeRef v7 = v13;
  CFTypeRef v6 = cf;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(v9 + 56);
  if (v10)
  {
    uint64_t v5 = v10(a1, v6, v7);
    goto LABEL_11;
  }
  uint64_t v11 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v11;
}

uint64_t HandleEndpointSendCommandMessage(char *a1, xpc_connection_t connection, void *a3)
{
  CFTypeRef v26 = 0;
  CFTypeRef cf = 0;
  pid_t pid = xpc_connection_get_pid(connection);
  CFTypeRef cf1 = 0;
  if (!a1
    || (pid_t v7 = pid,
        ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(),
        !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v9 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_9:
    uint64_t v16 = v9;
    CFMutableDictionaryRef MutableCopy = 0;
LABEL_10:
    CompletionCallbackParametersFromMessageAndConnection_1 = 0;
    goto LABEL_26;
  }
  uint64_t v9 = FigXPCMessageCopyCFString(a3, "Command", &cf);
  if (v9) {
    goto LABEL_9;
  }
  uint64_t v9 = FigXPCMessageCopyCFDictionary(a3, "Params", &v26);
  if (v9) {
    goto LABEL_9;
  }
  CompletionCallbackParametersFromMessageAndConnection_1 = (xpc_object_t *)CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, connection);
  uint64_t v11 = *MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (CFDictionaryRef)v26);
  if (MutableCopy)
  {
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
    uint64_t v14 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v14) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v17 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v15 + 48);
    if (!v17)
    {
LABEL_25:
      uint64_t v16 = 4294954514;
      goto LABEL_26;
    }
    uint64_t v18 = v17(CMBaseObject, @"Type", v11, &cf1);
    if (!v18)
    {
      if (FigCFEqual(cf1, @"EndpointType_Car")
        || (uint64_t v18 = FigCFDictionarySetInt64(MutableCopy, @"clientPID", v7), !v18))
      {
        CFTypeRef v19 = cf;
        if (CompletionCallbackParametersFromMessageAndConnection_1) {
          uint64_t v20 = SendCommandCompletionCallback;
        }
        else {
          uint64_t v20 = 0;
        }
        uint64_t v21 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
        if (v21) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = 0;
        }
        CFNumberRef v23 = *(uint64_t (**)(char *, CFTypeRef, CFMutableDictionaryRef, void (*)(uint64_t, int, const void *, uint64_t), xpc_object_t *))(v22 + 72);
        if (v23)
        {
          uint64_t v16 = v23(a1, v19, MutableCopy, v20, CompletionCallbackParametersFromMessageAndConnection_1);
          goto LABEL_10;
        }
        CompletionCallbackParametersFromMessageAndConnection_1 = 0;
        goto LABEL_25;
      }
    }
    uint64_t v16 = v18;
  }
  else
  {
    uint64_t v16 = 4294954510;
  }
LABEL_26:
  DestroyCompletionCallbackParameters(CompletionCallbackParametersFromMessageAndConnection_1);
  if (cf) {
    CFRelease(cf);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (cf1) {
    CFRelease(cf1);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  return v16;
}

uint64_t HandleEndpointCreateRemoteControlSessionMessage(char *a1, _xpc_connection_s *a2, void *a3, void *a4)
{
  CFTypeRef cf = 0;
  CFTypeRef v18 = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v9 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  uint64_t v9 = FigXPCMessageCopyCFDictionary(a3, "Params", &cf);
  if (v9)
  {
LABEL_7:
    uint64_t v13 = v9;
    goto LABEL_15;
  }
  CFTypeRef v10 = cf;
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v14 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef *))(v12 + 80);
  if (v14)
  {
    uint64_t v13 = v14(a1, v10, &v18);
    if (!v13)
    {
      if (v18)
      {
        uint64_t value = 0;
        uint64_t v13 = FigXPCEndpointRemoteControlSessionServerAssociateCopiedNeighborRemoteControlSession(a2, v18, &value);
        if (!v13) {
          xpc_dictionary_set_uint64(a4, "RemoteControlSessionID", value);
        }
      }
    }
  }
  else
  {
    uint64_t v13 = 4294954514;
  }
LABEL_15:
  if (cf) {
    CFRelease(cf);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v13;
}

uint64_t HandleEndpointCreateCommChannelMessage(uint64_t a1, void *a2, void *a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v12 = 0;
  FigXPCMessageCopyCFDictionary(a2, "Params", &cf);
  CFTypeRef v5 = cf;
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(a1) + 24);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef *))(v7 + 88);
  if (v8)
  {
    uint64_t v9 = v8(a1, v5, &v12);
    if (!v9) {
      FigXPCMessageSetCFString(a3, "CommChannelUUID", v12);
    }
  }
  else
  {
    uint64_t v9 = 4294954514;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v9;
}

uint64_t HandleEndpointSendDataMessage(uint64_t a1, void *a2, void *a3)
{
  CFTypeRef v16 = 0;
  CFTypeRef cf = 0;
  uint64_t v6 = FigXPCMessageCopyCFString(a3, "CommChannelUUID", &cf);
  if (v6) {
    goto LABEL_11;
  }
  uint64_t v6 = FigXPCMessageCopyCFData(a3, "Data", &v16);
  if (v6) {
    goto LABEL_11;
  }
  CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, a2);
  CFTypeRef v9 = v16;
  CFTypeRef v8 = cf;
  if (CompletionCallbackParametersFromMessageAndConnection_1) {
    CFTypeRef v10 = SendDataCompletionCallback;
  }
  else {
    CFTypeRef v10 = 0;
  }
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable(a1) + 24);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef, void (*)(uint64_t, const void *, int, uint64_t), void *))(v12 + 96);
  if (v13)
  {
    uint64_t v6 = v13(a1, v8, v9, v10, CompletionCallbackParametersFromMessageAndConnection_1);
LABEL_11:
    uint64_t v14 = v6;
    goto LABEL_13;
  }
  uint64_t v14 = 4294954514;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v16) {
    CFRelease(v16);
  }
  return v14;
}

uint64_t HandleEndpointCloseCommChannelMessage(uint64_t a1, void *a2)
{
  CFTypeRef cf = 0;
  uint64_t v3 = FigXPCMessageCopyCFString(a2, "CommChannelUUID", &cf);
  if (v3) {
    goto LABEL_7;
  }
  CFTypeRef v4 = cf;
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable(a1) + 24);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, CFTypeRef))(v6 + 104);
  if (v7)
  {
    uint64_t v3 = v7(a1, v4);
LABEL_7:
    uint64_t v8 = v3;
    goto LABEL_9;
  }
  uint64_t v8 = 4294954514;
LABEL_9:
  if (cf) {
    CFRelease(cf);
  }
  return v8;
}

uint64_t HandleEndpointRequestScreenViewAreaMessage(char *a1, void *a2)
{
  CFTypeRef cf = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  uint64_t v5 = FigXPCMessageCopyCFString(a2, "UUID", &cf);
  if (v5)
  {
LABEL_10:
    uint64_t v11 = v5;
    goto LABEL_12;
  }
  int64_t int64 = xpc_dictionary_get_int64(a2, "Index");
  CFTypeRef v7 = cf;
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  CFTypeRef v10 = *(uint64_t (**)(char *, CFTypeRef, int64_t))(v9 + 112);
  if (v10)
  {
    uint64_t v5 = v10(a1, v7, int64);
    goto LABEL_10;
  }
  uint64_t v11 = 4294954514;
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t HandleEndpointCopyCurrentScreenViewAreaMessage(char *a1, void *a2, void *a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v17 = 0;
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v7 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  uint64_t v7 = FigXPCMessageCopyCFString(a2, "UUID", &v17);
  if (v7)
  {
LABEL_7:
    uint64_t v11 = v7;
    goto LABEL_14;
  }
  CFTypeRef v8 = v17;
  uint64_t v9 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
  if (v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef *))(v10 + 120);
  if (v12)
  {
    uint64_t v13 = v12(a1, v8, &cf);
    CFTypeRef v14 = cf;
    if (!v13)
    {
      uint64_t v11 = FigXPCMessageSetCFDictionary(a3, "ViewArea", cf);
      CFTypeRef v14 = cf;
      if (!cf) {
        goto LABEL_14;
      }
      goto LABEL_12;
    }
    uint64_t v11 = v13;
    if (cf) {
LABEL_12:
    }
      CFRelease(v14);
  }
  else
  {
    uint64_t v11 = 4294954514;
  }
LABEL_14:
  if (v17) {
    CFRelease(v17);
  }
  return v11;
}

uint64_t HandleEndpointActivateMessage(uint64_t a1, void *a2, void *a3)
{
  CFTypeRef cf = 0;
  uint64_t v6 = FigXPCMessageCopyCFDictionary(a3, "ActivateOptions", &cf);
  if (v6) {
    goto LABEL_11;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a3, "ActivationFeatures");
  if (uint64)
  {
    uint64_t v8 = uint64;
    CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, a2);
    CFTypeRef v10 = cf;
    if (CompletionCallbackParametersFromMessageAndConnection_1) {
      uint64_t v11 = ActivationCompletionCallback;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
    if (v12) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    CFTypeRef v14 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef, void, void *))(v13 + 8);
    if (v14)
    {
      uint64_t v6 = v14(a1, v8, v10, v11, CompletionCallbackParametersFromMessageAndConnection_1);
LABEL_11:
      uint64_t v15 = v6;
      goto LABEL_13;
    }
    uint64_t v15 = 4294954514;
  }
  else
  {
    uint64_t v15 = 4294950576;
  }
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

uint64_t HandleEndpointDeactivateMessage(uint64_t a1, void *a2, void *a3)
{
  CFTypeRef cf = 0;
  uint64_t v6 = FigXPCMessageCopyCFDictionary(a3, "DeactivateOptions", &cf);
  if (v6) {
    goto LABEL_15;
  }
  CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, a2);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  CFTypeRef v10 = *(void (**)(uint64_t, void))(v9 + 48);
  if (v10) {
    v10(a1, 0);
  }
  CFTypeRef v11 = cf;
  if (CompletionCallbackParametersFromMessageAndConnection_1) {
    uint64_t v12 = ActivationCompletionCallback;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(uint64_t (**)(uint64_t, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, int, uint64_t), void *))(v14 + 16);
  if (v15)
  {
    uint64_t v6 = v15(a1, v11, v12, CompletionCallbackParametersFromMessageAndConnection_1);
LABEL_15:
    uint64_t v16 = v6;
    goto LABEL_17;
  }
  uint64_t v16 = 4294954514;
LABEL_17:
  if (cf) {
    CFRelease(cf);
  }
  return v16;
}

uint64_t HandleEndpointCreatePlaybackSessionMessage(uint64_t a1, _xpc_connection_s *a2, void *a3)
{
  CFTypeRef cf = 0;
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, CFTypeRef *))(v7 + 72);
  if (!v8) {
    return 4294954514;
  }
  uint64_t v9 = v8(a1, &cf);
  CFTypeRef v10 = cf;
  if (!v9 && cf)
  {
    uint64_t value = 0;
    uint64_t v9 = FigXPCEndpointPlaybackSessionServerAssociateCopiedNeighborFigEndpointPlaybackSession(a2, cf, &value);
    xpc_dictionary_set_uint64(a3, "PlaybackSessionID", value);
    CFTypeRef v10 = cf;
  }
  if (v10) {
    CFRelease(v10);
  }
  return v9;
}

uint64_t HandleEndpointAcquireAndCopyResourceMessage(char *a1, _xpc_connection_s *a2, void *a3, void *a4)
{
  CFTypeRef v26 = 0;
  CFTypeRef cf = 0;
  uint64_t value = 0;
  CFTypeRef v25 = 0;
  uint64_t v8 = FigXPCMessageCopyCFString(a3, "ResourceType", &cf);
  if (v8) {
    goto LABEL_32;
  }
  uint64_t v8 = FigXPCMessageCopyCFDictionary(a3, "ResourceOptions", &v26);
  if (v8) {
    goto LABEL_32;
  }
  if (!a1
    || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(),
        uint64_t v10 = (uint64_t)a1,
        !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    uint64_t v10 = 0;
  }
  CFTypeRef v12 = v26;
  CFTypeRef v11 = cf;
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable(v10) + 24);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef, CFTypeRef *))(v14 + 128);
  if (!v15)
  {
    uint64_t v16 = 4294954514;
    goto LABEL_15;
  }
  uint64_t v8 = v15(v10, v11, v12, &v25);
  if (v8)
  {
LABEL_32:
    uint64_t v16 = v8;
  }
  else if (FigCFEqual(cf, @"endpointStream"))
  {
    uint64_t v16 = FigXPCEndpointStreamServerAssociateCopiedNeighborFigEndpointStream(a2, v25, &value);
    if (!v16)
    {
      xpc_dictionary_set_uint64(a4, "ResourceID", value);
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v16 = 4294950570;
  }
LABEL_15:
  if (v25)
  {
    if (!a1 || (CFTypeRef v17 = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, v17))) {
      a1 = 0;
    }
    CFTypeRef v18 = cf;
    CFTypeRef v19 = v25;
    uint64_t v20 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
    if (v20) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = 0;
    }
    uint64_t v22 = *(void (**)(char *, CFTypeRef, CFTypeRef))(v21 + 136);
    if (v22) {
      v22(a1, v18, v19);
    }
  }
LABEL_24:
  if (cf) {
    CFRelease(cf);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v25) {
    CFRelease(v25);
  }
  return v16;
}

uint64_t HandleEndpointRelinquishResourceMessage(char *a1, void *a2)
{
  CFTypeRef v15 = 0;
  CFTypeRef cf = 0;
  uint64_t v4 = FigXPCMessageCopyCFString(a2, "ResourceType", &cf);
  if (v4) {
    goto LABEL_14;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a2, "ResourceID");
  if (uint64)
  {
    uint64_t v6 = (void *)uint64;
    if (!FigCFEqual(cf, @"endpointStream"))
    {
      uint64_t v12 = 4294950570;
      goto LABEL_16;
    }
    uint64_t v4 = FigXPCEndpointStreamServerRetainEndpointStreamForID(v6, &v15);
    if (v4) {
      goto LABEL_14;
    }
    if (!a1
      || (ClassIOSurfaceID ID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
    {
      a1 = 0;
    }
    CFTypeRef v9 = v15;
    CFTypeRef v8 = cf;
    uint64_t v10 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 24);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v13 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(v11 + 136);
    if (v13)
    {
      uint64_t v4 = v13(a1, v8, v9);
LABEL_14:
      uint64_t v12 = v4;
      goto LABEL_16;
    }
    uint64_t v12 = 4294954514;
  }
  else
  {
    uint64_t v12 = 4294950576;
  }
LABEL_16:
  if (cf) {
    CFRelease(cf);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v12;
}

uint64_t HandleEndpointCopyMessengerMessage(uint64_t a1, _xpc_connection_s *a2, void *a3)
{
  CFTypeRef cf = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], "Messenger", 0x8000100u);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, CFStringRef, const __CFAllocator *, CFTypeRef *))(v9 + 48);
  if (!v10)
  {
    CFTypeRef v12 = 0;
    uint64_t v15 = 4294954514;
    if (!v7) {
      goto LABEL_15;
    }
LABEL_14:
    CFRelease(v7);
    goto LABEL_15;
  }
  uint64_t v11 = v10(a1, v7, v6, &cf);
  if (!v11)
  {
    CFTypeRef v12 = cf;
    CFTypeRef cf = 0;
    if (v12)
    {
      uint64_t v17 = 0;
      uint64_t v13 = FigXPCEndpointMessengerServerAssociateNeighborFigEndpointMessenger(a2, v12, &v17);
      if (v13) {
        goto LABEL_13;
      }
      CFNumberRef v14 = CFNumberCreate(v6, kCFNumberSInt64Type, &v17);
      CFTypeRef cf = v14;
    }
    else
    {
      CFNumberRef v14 = 0;
    }
    uint64_t v13 = FigXPCMessageSetCFObject(a3, ".Value", v14);
LABEL_13:
    uint64_t v15 = v13;
    if (!v7) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v15 = v11;
  CFTypeRef v12 = 0;
  if (v7) {
    goto LABEL_14;
  }
LABEL_15:
  if (v12) {
    CFRelease(v12);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v15;
}

uint64_t HandleEndpointCopySubEndpointsMessage(uint64_t a1, _xpc_connection_s *a2, void *a3, uint64_t a4)
{
  xpc_object_t value = 0;
  CFTypeRef cf = 0;
  xpc_object_t v14 = 0;
  if (a4)
  {
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
    uint64_t v8 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v8) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(uint64_t, __CFString *, void, CFTypeRef *))(v9 + 48);
    if (v10)
    {
      uint64_t v11 = v10(CMBaseObject, @"Endpoints", *MEMORY[0x1E4F1CF80], &cf);
      if (v11
        || (uint64_t v11 = FigEndpointRPCCacheComputeCacheDeltas(*(void *)(a4 + 24), a2, (CFArrayRef)cf, &value, &v14),
            v11))
      {
        uint64_t v12 = v11;
      }
      else
      {
        if (value) {
          xpc_dictionary_set_value(a3, "AddedSubEndpoints", value);
        }
        if (v14) {
          xpc_dictionary_set_value(a3, "SubtractedSubEndpoints", v14);
        }
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = 4294954514;
    }
  }
  else
  {
    uint64_t v12 = 4294954513;
  }
  FigXPCRelease(value);
  FigXPCRelease(v14);
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

uint64_t HandleEndpointDissociateMessage(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 32);
  if (!v4) {
    return 4294954514;
  }

  return v4(a1);
}

uint64_t HandleEndpointAddRemoveEndpointMessage(char *a1, int a2, _xpc_connection_s *a3, void *a4)
{
  CFTypeRef v21 = 0;
  CFTypeRef cf = 0;
  if (!a1) {
    return 4294950576;
  }
  ClassIOSurfaceID ID = (void *)FigEndpointAggregateGetClassID();
  if (CMBaseObjectIsMemberOfClass(a1, ClassID))
  {
    uint64_t v9 = FigXPCMessageCopyCFDictionary(a4, "AggregateOptions", &cf);
    if (v9) {
      goto LABEL_21;
    }
    uint64_t int64 = xpc_dictionary_get_uint64(a4, "SubEndpointObjectID");
    uint64_t v9 = LookupEndpointByObjectIDForConnection(a3, uint64, &v21, 0);
    if (v9) {
      goto LABEL_21;
    }
    CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a4, a3);
    CFTypeRef v12 = v21;
    CFTypeRef v13 = cf;
    if (CompletionCallbackParametersFromMessageAndConnection_1) {
      xpc_object_t v14 = AggregateEndpointAddRemoveEndpointCallback;
    }
    else {
      xpc_object_t v14 = 0;
    }
    uint64_t v15 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 32);
    if (a2)
    {
      if (v15) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = 0;
      }
      CFTypeRef v19 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, int, uint64_t), void *))(v16 + 8);
      if (v19)
      {
LABEL_20:
        uint64_t v9 = v19(a1, v12, v13, v14, CompletionCallbackParametersFromMessageAndConnection_1);
LABEL_21:
        uint64_t v17 = v9;
        goto LABEL_23;
      }
    }
    else
    {
      if (v15) {
        uint64_t v18 = v15;
      }
      else {
        uint64_t v18 = 0;
      }
      CFTypeRef v19 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, int, uint64_t), void *))(v18 + 16);
      if (v19) {
        goto LABEL_20;
      }
    }
    uint64_t v17 = 4294954514;
    goto LABEL_23;
  }
  uint64_t v17 = 4294950576;
LABEL_23:
  if (cf) {
    CFRelease(cf);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v17;
}

uint64_t HandleEndpointCopyEndpointForAnotherProcess(const void *a1, xpc_object_t xdict, void *a3)
{
  uint64_t value = 0;
  int int64 = xpc_dictionary_get_int64(xdict, "OtherProcessPID");
  if (!int64)
  {
    uint64_t v7 = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    goto LABEL_4;
  }
  EndpointRefCon = CreateEndpointRefCon(a1);
  uint64_t v7 = FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(gEndpointServer, int64, a1, (uint64_t)EndpointRefCon, (uint64_t)DisposeEndpointRefCon, 0, &value);
  if (!v7)
  {
    xpc_dictionary_set_uint64(a3, ".objectID", value);
LABEL_4:
    EndpointRefCon = 0;
  }
  DisposeEndpointRefCon((uint64_t)EndpointRefCon);
  return v7;
}

CFTypeRef __HandleEndpointCopyActiveEndpointMessage_block_invoke(uint64_t a1)
{
  CFTypeRef result = (CFTypeRef)gActiveEndpoint;
  if (gActiveEndpoint) {
    CFTypeRef result = CFRetain((CFTypeRef)gActiveEndpoint);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __HandleEndpointIsActiveEndpointAvailableMessage_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = gActiveEndpoint != 0;
  return result;
}

uint64_t CreateDelegateCallbackParameters(uint64_t a1, void *a2, uint64_t *a3)
{
  if (delegateCallbackParameters_GetTypeID_sRegisterDelegateCallbackParametersTypeOnce != -1) {
    dispatch_once(&delegateCallbackParameters_GetTypeID_sRegisterDelegateCallbackParametersTypeOnce, &__block_literal_global_58);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v7 = Instance;
    *(void *)(Instance + 16) = a1;
    *(void *)(Instance + 24) = FigXPCRetain(a2);
    *a3 = v7;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  }
}

void SendDidReceiveDataFromCommChannelCallback(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5)
{
  xpc_object_t xdict = 0;
  if (a5)
  {
    int v9 = FigXPCCreateBasicMessage(0x72636463u, *(void *)(a5 + 16), &xdict);
    xpc_object_t v10 = xdict;
    if (!v9)
    {
      FigXPCMessageSetCFString(xdict, "CommChannelUUID", a3);
      xpc_dictionary_set_uint64(xdict, "ActivationSeed", a2);
      FigXPCMessageSetCFString(xdict, "DelegateFunctionType", @"hrcd");
      FigXPCMessageSetCFData(xdict, "Data", a4);
      xpc_connection_send_message(*(xpc_connection_t *)(a5 + 24), xdict);
      xpc_object_t v10 = xdict;
    }
  }
  else
  {
    xpc_object_t v10 = 0;
  }
  FigXPCRelease(v10);
}

void SendDidCloseCommChannelCallback(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  xpc_object_t xdict = 0;
  if (a4)
  {
    int v7 = FigXPCCreateBasicMessage(0x72636463u, *(void *)(a4 + 16), &xdict);
    xpc_object_t v8 = xdict;
    if (!v7)
    {
      FigXPCMessageSetCFString(xdict, "CommChannelUUID", a3);
      xpc_dictionary_set_uint64(xdict, "ActivationSeed", a2);
      FigXPCMessageSetCFString(xdict, "DelegateFunctionType", @"hrcc");
      xpc_connection_send_message(*(xpc_connection_t *)(a4 + 24), xdict);
      xpc_object_t v8 = xdict;
    }
  }
  else
  {
    xpc_object_t v8 = 0;
  }
  FigXPCRelease(v8);
}

void delegateCallbackParameters_Finalize(uint64_t a1)
{
  *(void *)(a1 + 16) = 0;
  int v1 = *(void **)(a1 + 24);
  if (v1)
  {
    *(void *)(a1 + 24) = 0;
    xpc_release(v1);
  }
}

__CFString *delegateCallbackParameters_CopyDebugDesc(uint64_t a1)
{
  CFArrayRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, @"DelegateCallbackParameters %p objectID %llx connection %p", a1, *(void *)(a1 + 16), *(void *)(a1 + 24));
  return Mutable;
}

void SendHandleAuthRequiredCallback(const void *a1, void *a2, uint64_t a3, uint64_t a4, const void *a5, void (*a6)(const void *, void, uint64_t, uint64_t), uint64_t a7)
{
  xpc_object_t xdict = 0;
  if (!a4
    || FigXPCCreateBasicMessage(0x72746463u, *(void *)(a4 + 16), &xdict)
    || a2
    && FigEndpointXPCServerWriteNeighborEndpointToReply(*(_xpc_connection_s **)(a4 + 24), a2, xdict, 0))
  {
    if (a6) {
      a6(a1, 0, 4294950568, a7);
    }
  }
  else
  {
    xpc_dictionary_set_uint64(xdict, "ActivationSeed", a3);
    FigXPCMessageSetCFString(xdict, "AuthorizationType", a5);
    FigXPCMessageSetCFString(xdict, "DelegateFunctionType", @"hrar");
    CFRetain(a1);
    if (a5) {
      CFRetain(a5);
    }
    xpc_object_t v14 = *(_xpc_connection_s **)(a4 + 24);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __SendHandleAuthRequiredCallback_block_invoke;
    handler[3] = &__block_descriptor_tmp_64;
    handler[4] = a6;
    void handler[5] = a1;
    void handler[6] = a7;
    handler[7] = a5;
    xpc_connection_send_message_with_reply(v14, xdict, 0, handler);
  }
  FigXPCRelease(xdict);
}

void SendHandleFailedCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  v15[1] = *(const void **)MEMORY[0x1E4F143B8];
  xpc_object_t xdict = 0;
  if (a4)
  {
    int v7 = FigXPCCreateBasicMessage(0x72746463u, *(void *)(a4 + 16), &xdict);
    xpc_object_t v8 = xdict;
    if (!v7)
    {
      int v9 = *(_xpc_connection_s **)(a4 + 24);
      v15[0] = @"SubEndpoint";
      if (CFDictionaryContainsKey(a3, @"SubEndpoint"))
      {
        CFStringRef Value = (void *)CFDictionaryGetValue(a3, @"SubEndpoint");
        CopyRemovingKeys = FigCFDictionaryCreateCopyRemovingKeys(a3, v15, 1);
        int v12 = FigEndpointXPCServerWriteNeighborEndpointToReply(v9, Value, v8, 0);
        if (!v12) {
          int v12 = FigXPCMessageSetCFDictionary(v8, "FailureInfo", CopyRemovingKeys);
        }
        int v13 = v12;
        if (CopyRemovingKeys) {
          CFRelease(CopyRemovingKeys);
        }
      }
      else
      {
        int v13 = FigXPCMessageSetCFDictionary(v8, "FailureInfo", a3);
      }
      xpc_object_t v8 = xdict;
      if (!v13)
      {
        xpc_dictionary_set_uint64(xdict, "ActivationSeed", a2);
        FigXPCMessageSetCFString(xdict, "DelegateFunctionType", @"hrtf");
        xpc_connection_send_message(*(xpc_connection_t *)(a4 + 24), xdict);
        xpc_object_t v8 = xdict;
      }
    }
  }
  else
  {
    xpc_object_t v8 = 0;
  }
  FigXPCRelease(v8);
}

void __SendHandleAuthRequiredCallback_block_invoke(uint64_t a1, void *a2)
{
  CFTypeRef cf = 0;
  if (MEMORY[0x192FC6B30](a2) == MEMORY[0x1E4F145A8])
  {
    CFTypeRef v5 = 0;
    int64_t int64 = 4294950568;
  }
  else
  {
    int64_t int64 = xpc_dictionary_get_int64(a2, "AuthorizationResult");
    FigXPCMessageCopyCFString(a2, "AuthorizationString", &cf);
    CFTypeRef v5 = cf;
  }
  CFAllocatorRef v6 = *(void (**)(void, CFTypeRef, int64_t, void))(a1 + 32);
  if (v6)
  {
    v6(*(void *)(a1 + 40), v5, int64, *(void *)(a1 + 48));
    CFTypeRef v5 = cf;
  }
  if (v5) {
    CFRelease(v5);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  int v7 = *(const void **)(a1 + 56);
  if (v7) {
    CFRelease(v7);
  }
}

void *CreateCompletionCallbackParametersFromMessageAndConnection_1(void *a1, void *a2)
{
  uint64_t int64 = xpc_dictionary_get_uint64(a1, "CompletionID");
  if (!uint64) {
    return 0;
  }
  uint64_t v5 = uint64;
  CFAllocatorRef v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  int v7 = v6;
  if (v6)
  {
    *CFAllocatorRef v6 = v5;
    v6[1] = xpc_dictionary_get_uint64(a1, ".objectID");
    _OWORD v7[2] = FigXPCRetain(a2);
  }
  else
  {
    FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  }
  return v7;
}

void SendCommandCompletionCallback(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  xpc_object_t xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a4);
    FigXPCMessageSetCFDictionary(xdict, "SendCommandResponse", a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

void SendDataCompletionCallback(uint64_t a1, const void *a2, int a3, uint64_t a4)
{
  xpc_object_t xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a4);
    FigXPCMessageSetCFString(xdict, "CommChannelUUID", a2);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

void ActivationCompletionCallback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  xpc_object_t xdict = 0;
  if (a5 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a5 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "ActivationFeatures", a2);
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a5);
    xpc_dictionary_set_uint64(xdict, "ActivationSeed", a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a4);
    xpc_connection_send_message(*(xpc_connection_t *)(a5 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a5);
  FigXPCRelease(xdict);
}

void AggregateEndpointAddRemoveEndpointCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  xpc_object_t xdict = 0;
  if (a6 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a6 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "ActivationFeatures", a3);
    xpc_dictionary_set_uint64(xdict, "ActivationSeed", a4);
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a6);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a5);
    xpc_connection_send_message(*(xpc_connection_t *)(a6 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a6);
  FigXPCRelease(xdict);
}

void *CreateEndpointRefCon(const void *a1)
{
  uint64_t v5 = 0;
  if (FigEndpointRPCCacheCreate(&v5, 1))
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
    if (v2)
    {
      if (a1) {
        CFTypeRef v3 = CFRetain(a1);
      }
      else {
        CFTypeRef v3 = 0;
      }
      *uint64_t v2 = v3;
      v2[3] = v5;
      uint64_t v5 = 0;
    }
    else
    {
      FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
    }
  }
  FigEndpointRPCCacheDispose(v5);
  return v2;
}

void DisposeEndpointRefCon(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      uint64_t v2 = *(void *)a1;
      uint64_t v3 = *(void *)(CMBaseObjectGetVTable(*(void *)a1) + 16);
      if (v3) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t v5 = *(void (**)(uint64_t, void))(v4 + 56);
      if (v5) {
        v5(v2, 0);
      }
      CFAllocatorRef v6 = *(const void **)(a1 + 16);
      if (v6)
      {
        CFRelease(v6);
        *(void *)(a1 + 16) = 0;
      }
    }
    if (*(void *)(a1 + 8))
    {
      uint64_t v7 = *(void *)a1;
      uint64_t v8 = *(void *)(CMBaseObjectGetVTable(*(void *)a1) + 16);
      if (v8) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 0;
      }
      xpc_object_t v10 = *(void (**)(uint64_t, void))(v9 + 48);
      if (v10) {
        v10(v7, 0);
      }
      uint64_t v11 = *(const void **)(a1 + 8);
      if (v11)
      {
        CFRelease(v11);
        *(void *)(a1 + 8) = 0;
      }
    }
    if (*(void *)a1)
    {
      CFRelease(*(CFTypeRef *)a1);
      *(void *)a1 = 0;
    }
    FigEndpointRPCCacheDispose(*(void **)(a1 + 24));
    free((void *)a1);
  }
}

dispatch_queue_t __GetActiveEndpointQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("FigEndpointServerActiveEndpointQueue", 0);
  gActiveEndpointQueue = (uint64_t)result;
  return result;
}

void __FigEndpointServerSetActiveEndpointAndForceNotify_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  uint64_t v3 = (const void *)gActiveEndpoint;
  if (v2 == (const void *)gActiveEndpoint)
  {
    if (!*(unsigned char *)(a1 + 40)) {
      goto LABEL_8;
    }
  }
  else
  {
    gActiveEndpoint = (uint64_t)v2;
    if (v2) {
      CFRetain(v2);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
  notify_post("com.apple.coremedia.active-endpoint-changed");
  uint64_t v2 = *(const void **)(a1 + 32);
LABEL_8:
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t figEndpointXPC_getObjectIDForSource(xpc_connection_t connection, const void *a2, uint64_t a3, void *a4)
{
  uint64_t v13 = 0;
  if ((a3 & 0xFFFFFFFFFFFFCFFFLL) != gServerSource)
  {
    pid_t pid = xpc_connection_get_pid(connection);
    uint64_t v11 = FigEndpointXPCRemoteObtainObjectIDForOtherProcess((uint64_t)a2, pid, &v13);
    if (v11)
    {
      uint64_t v9 = v11;
      EndpointRefCon = 0;
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  EndpointRefCon = CreateEndpointRefCon(a2);
  uint64_t v8 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointServer, connection, a2, (uint64_t)EndpointRefCon, (uint64_t)DisposeEndpointRefCon, 0, &v13);
  if (!v8)
  {
LABEL_5:
    uint64_t v9 = 0;
    EndpointRefCon = 0;
    *a4 = v13;
    goto LABEL_6;
  }
  uint64_t v9 = v8;
LABEL_6:
  DisposeEndpointRefCon((uint64_t)EndpointRefCon);
  return v9;
}

uint64_t FigNetworkHistoryObserverGetClassID()
{
  return sFigNetworkHistoryObserverClassID;
}

uint64_t RegisterFigNetworkHistoryObserverType()
{
  ClassIOSurfaceID ID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigNetworkHistoryObserverClassDesc, ClassID, 1, &sFigNetworkHistoryObserverClassID);
}

uint64_t FigNetworkHistoryObserverGetCFTypeID()
{
  FigThreadRunOnce(&FigNetworkHistoryObserverGetClassID_sRegisterFigNetworkHistoryObserverTypeOnce, (void (*)(void))RegisterFigNetworkHistoryObserverType);
  unint64_t v0 = (void *)sFigNetworkHistoryObserverClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigNetworkHistoryObserverCreate(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  if (a6)
  {
    if (a5 && a2 && a4)
    {
      FigThreadRunOnce(&FigNetworkHistoryObserverGetClassID_sRegisterFigNetworkHistoryObserverTypeOnce, (void (*)(void))RegisterFigNetworkHistoryObserverType);
      uint64_t v12 = CMDerivedObjectCreate(a1, (uint64_t)&kFigNetworkHistoryObserverVTable, (void *)sFigNetworkHistoryObserverClassID, &cf);
      if (!cf) {
        goto LABEL_24;
      }
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *(void *)(DerivedStorage + 48) = a5;
      *(void *)(DerivedStorage + 32) = a3;
      CFTypeRef v14 = FigCFWeakReferenceHolderCreateWithReferencedObject(a4);
      *(void *)(DerivedStorage + 40) = v14;
      if (!v14) {
        goto LABEL_24;
      }
      uint64_t v15 = *MEMORY[0x1E4F1CF80];
      CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kFigNetworkHistoryCondition_CompletionCallbackEntrySetCallbacks);
      *(void *)(DerivedStorage + 72) = Mutable;
      if (!Mutable) {
        goto LABEL_24;
      }
      CFTypeRef v17 = CFRetain(a2);
      *(void *)(DerivedStorage + 64) = v17;
      uint64_t v18 = *(void *)(CMBaseObjectGetVTable((uint64_t)v17) + 8);
      if (v18) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = 0;
      }
      uint64_t v20 = (unint64_t *)(DerivedStorage + 56);
      CFTypeRef v21 = *(void (**)(CFTypeRef, __CFString *, uint64_t, uint64_t))(v19 + 48);
      if (v21) {
        v21(v17, @"NetworkPredictorProperty_History", v15, DerivedStorage + 56);
      }
      if (*v20)
      {
        uint64_t v22 = FigSimpleMutexCreate();
        *(void *)uint64_t DerivedStorage = v22;
        if (v22)
        {
          dispatch_queue_t v23 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkhisotryobserver.timer", 0, 0);
          *(void *)(DerivedStorage + 16) = v23;
          if (v23)
          {
            dispatch_queue_t v24 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkhisotryobserver.callback", 0, 0);
            *(void *)(DerivedStorage + 24) = v24;
            if (v24)
            {
              dispatch_source_t v25 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(DerivedStorage + 16));
              *(void *)(DerivedStorage + 8) = v25;
              if (v25)
              {
                CFTypeRef v26 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
                if (v26)
                {
                  dispatch_set_context(*(dispatch_object_t *)(DerivedStorage + 8), v26);
                  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(DerivedStorage + 8), (dispatch_function_t)fnho_callbacktimerProc);
                  dispatch_set_finalizer_f(*(dispatch_object_t *)(DerivedStorage + 8), (dispatch_function_t)FigCFRelease_0);
                  dispatch_resume(*(dispatch_object_t *)(DerivedStorage + 8));
                  BOOL v27 = FigNetworkHistoryAreAnyRequestsActive(*(void *)(DerivedStorage + 56));
                  *(unsigned char *)(DerivedStorage + 81) = v27;
                  if (v27)
                  {
                    fnho_ensureTimerIsScheduled((uint64_t)cf);
                  }
                  else
                  {
                    *(unsigned char *)(DerivedStorage + 80) = 1;
                    fnho_ensureTimerIsPaused((uint64_t)cf);
                  }
                  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
                  FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)cf, (CFNotificationCallback)fnho_networkHistoryBecameActiveHandler, @"NetworkHistoryNotification_NetworkBecameActive", *v20, 0, 0);
                  CFTypeRef v29 = CMNotificationCenterGetDefaultLocalCenter();
                  FigNotificationCenterAddWeakListener(v29, (void *)cf, (CFNotificationCallback)fnho_networkHistoryBecameInactiveHandler, @"NetworkHistoryNotification_NetworkBecameInactive", *v20, 0, 0);
                  *a6 = cf;
                  return v12;
                }
                uint64_t v31 = 4294951335;
LABEL_26:
                uint64_t v12 = FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
                if (cf) {
                  CFRelease(cf);
                }
                return v12;
              }
            }
          }
        }
LABEL_24:
        uint64_t v31 = 4294951335;
        goto LABEL_26;
      }
    }
    uint64_t v31 = 4294951336;
    goto LABEL_26;
  }

  return FigSignalErrorAt(4294951336, 0, 0, 0, 0, 0, 0);
}

void fnho_callbacktimerProc(id *a1)
{
  int v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v1);
    FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
    CFSetApplyFunction(*(CFSetRef *)(DerivedStorage + 72), (CFSetApplierFunction)fnho_conditionApplier, v2);
    if (!*(unsigned char *)(DerivedStorage + 81)) {
      fnho_ensureTimerIsPaused((uint64_t)v2);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
    CFRelease(v2);
  }
}

void FigCFRelease_0(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void fnho_ensureTimerIsScheduled(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(unsigned char *)(DerivedStorage + 80))
  {
    uint64_t v2 = DerivedStorage;
    *(unsigned char *)(DerivedStorage + 80) = 1;
    uint64_t v3 = *(NSObject **)(DerivedStorage + 8);
    dispatch_time_t v4 = dispatch_time(0, *(void *)(DerivedStorage + 32));
    uint64_t v5 = *(void *)(v2 + 32);
    dispatch_source_set_timer(v3, v4, v5, 0xEE6B280uLL);
  }
}

void fnho_ensureTimerIsPaused(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(unsigned char *)(DerivedStorage + 80))
  {
    *(unsigned char *)(DerivedStorage + 80) = 0;
    uint64_t v2 = *(NSObject **)(DerivedStorage + 8);
    dispatch_source_set_timer(v2, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  }
}

pthread_mutex_t **fnho_networkHistoryBecameActiveHandler(uint64_t a1, uint64_t a2)
{
  dispatch_queue_t result = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a2);
  if (a2)
  {
    dispatch_time_t v4 = result;
    FigSimpleMutexLock(*result);
    fnho_ensureTimerIsScheduled(a2);
    *((unsigned char *)v4 + 81) = 1;
    uint64_t v5 = *v4;
    return (pthread_mutex_t **)FigSimpleMutexUnlock(v5);
  }
  return result;
}

pthread_mutex_t **fnho_networkHistoryBecameInactiveHandler(uint64_t a1, uint64_t a2)
{
  dispatch_queue_t result = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a2);
  if (a2)
  {
    dispatch_time_t v4 = result;
    FigSimpleMutexLock(*result);
    *((unsigned char *)v4 + 81) = 0;
    uint64_t v5 = *v4;
    return (pthread_mutex_t **)FigSimpleMutexUnlock(v5);
  }
  return result;
}

uint64_t FigNetworkHistoryObserverAddCondition(uint64_t a1, long long *a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a3)
  {
    uint64_t v6 = DerivedStorage;
    CFAllocatorRef v7 = CFGetAllocator(*(CFTypeRef *)(DerivedStorage + 72));
    uint64_t v8 = CFAllocatorAllocate(v7, 240, 0);
    if (v8)
    {
      uint64_t v9 = v8;
      long long v10 = *a2;
      long long v11 = a2[2];
      v8[1] = a2[1];
      int v8[2] = v11;
      *uint64_t v8 = v10;
      long long v12 = a2[3];
      long long v13 = a2[4];
      long long v14 = a2[6];
      void v8[5] = a2[5];
      void v8[6] = v14;
      void v8[3] = v12;
      v8[4] = v13;
      long long v15 = a2[7];
      long long v16 = a2[8];
      long long v17 = a2[10];
      v8[9] = a2[9];
      v8[10] = v17;
      v8[7] = v15;
      v8[8] = v16;
      long long v18 = a2[11];
      long long v19 = a2[12];
      long long v20 = a2[14];
      v8[13] = a2[13];
      v8[14] = v20;
      v8[11] = v18;
      v8[12] = v19;
      FigSimpleMutexLock(*(pthread_mutex_t **)v6);
      CFSetSetValue(*(CFMutableSetRef *)(v6 + 72), v9);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)v6);
      *a3 = v9;
      return 0;
    }
    uint64_t v22 = 4294951335;
  }
  else
  {
    uint64_t v22 = 4294951336;
  }

  return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
}

uint64_t FigNetworkHistoryObserverRemoveCondition(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  if (a2)
  {
    dispatch_time_t v4 = DerivedStorage;
    FigSimpleMutexLock(*DerivedStorage);
    CFSetRemoveValue((CFMutableSetRef)v4[9], a2);
    FigSimpleMutexUnlock(*v4);
  }
  return 0;
}

BOOL FigNetworkHistoryObserverTestCondition(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (CFSetContainsValue(*(CFSetRef *)(DerivedStorage + 72), a2)) {
    BOOL v5 = fnho_testCondition(a1, (uint64_t)a2, 0);
  }
  else {
    BOOL v5 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v5;
}

BOOL fnho_testCondition(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v38 = 0u;
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 64);
  UpTimeNanoFloat64 seconds = FigGetUpTimeNanoseconds();
  long long v7 = *(_OWORD *)(a2 + 192);
  long long v34 = *(_OWORD *)(a2 + 176);
  long long v35 = v7;
  long long v8 = *(_OWORD *)(a2 + 224);
  long long v36 = *(_OWORD *)(a2 + 208);
  long long v37 = v8;
  long long v9 = *(_OWORD *)(a2 + 128);
  long long v30 = *(_OWORD *)(a2 + 112);
  long long v31 = v9;
  long long v10 = *(_OWORD *)(a2 + 160);
  long long v32 = *(_OWORD *)(a2 + 144);
  long long v33 = v10;
  long long v11 = *(_OWORD *)(a2 + 64);
  long long v26 = *(_OWORD *)(a2 + 48);
  long long v27 = v11;
  long long v12 = *(_OWORD *)(a2 + 96);
  long long v28 = *(_OWORD *)(a2 + 80);
  long long v29 = v12;
  long long v13 = *(_OWORD *)(a2 + 32);
  long long v24 = *(_OWORD *)(a2 + 16);
  long long v25 = v13;
  uint64_t v14 = *(void *)(CMBaseObjectGetVTable(v5) + 16);
  if (v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t valuePtr = 0;
  long long v16 = *(unsigned int (**)(uint64_t, unint64_t, _OWORD *, long long *))(v15 + 8);
  if (!v16) {
    goto LABEL_11;
  }
  v44[10] = v34;
  v44[11] = v35;
  v44[12] = v36;
  v44[13] = v37;
  v44[6] = v30;
  v44[7] = v31;
  v44[8] = v32;
  v44[9] = v33;
  int v44[2] = v26;
  v44[3] = v27;
  v44[4] = v28;
  v44[5] = v29;
  v44[0] = v24;
  v44[1] = v25;
  if (v16(v5, UpTimeNanoseconds, v44, &v38)
    || (uint64_t valuePtr = (uint64_t)(*((double *)&v39 + 1) * (double)(uint64_t)v38),
        (CFNumberRef v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr)) == 0))
  {
LABEL_11:
    BOOL v20 = 0;
    if (!a3) {
      return v20;
    }
    CFNumberRef v18 = 0;
    CFTypeRef v21 = 0;
    goto LABEL_17;
  }
  CFNumberRef v18 = v17;
  int v19 = *(_DWORD *)(a2 + 8);
  if (v19 != 6)
  {
    if (v19 == 5)
    {
      *(void *)&v44[0] = 0;
      CFNumberGetValue(*(CFNumberRef *)a2, kCFNumberSInt64Type, v44);
      BOOL v20 = valuePtr >= *(void *)&v44[0];
      if (!a3) {
        goto LABEL_18;
      }
    }
    else
    {
      FigSignalErrorAt(4294951336, 0, 0, 0, 0, 0, 0);
      BOOL v20 = 0;
      if (!a3) {
        goto LABEL_18;
      }
    }
    goto LABEL_16;
  }
  *(void *)&v44[0] = 0;
  CFNumberGetValue(*(CFNumberRef *)a2, kCFNumberSInt64Type, v44);
  BOOL v20 = valuePtr <= *(void *)&v44[0];
  if (a3)
  {
LABEL_16:
    CFTypeRef v21 = CFRetain(v18);
LABEL_17:
    *a3 = v21;
  }
LABEL_18:
  if (v18) {
    CFRelease(v18);
  }
  return v20;
}

CFStringRef FigNetworkHistoryObserverCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigNetworkHistoryObserver <%p>]", a1);
}

CFAllocatorRef fnho_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  dispatch_source_cancel(*(dispatch_source_t *)(DerivedStorage + 8));
  uint64_t v2 = *(NSObject **)(DerivedStorage + 8);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(NSObject **)(DerivedStorage + 16);
  if (v3) {
    dispatch_release(v3);
  }
  dispatch_time_t v4 = *(NSObject **)(DerivedStorage + 24);
  if (v4) {
    dispatch_release(v4);
  }
  uint64_t v5 = *(const void **)(DerivedStorage + 72);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(DerivedStorage + 40);
  if (v6) {
    CFRelease(v6);
  }
  long long v7 = *(const void **)(DerivedStorage + 56);
  if (v7) {
    CFRelease(v7);
  }
  long long v8 = *(const void **)(DerivedStorage + 64);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(void *)DerivedStorage;

  return FigSimpleMutexDestroy(v9);
}

CFStringRef fnho_copyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(DerivedStorage + 72));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigNetworkHistoryObserver <%p> timeInterval=%lld total condition=%ld]", a1, *(void *)(DerivedStorage + 32), Count);
}

CFTypeRef *fnho_networkConditionRetainCallback(uint64_t a1, CFTypeRef *a2)
{
  if (a2 && *a2) {
    CFRetain(*a2);
  }
  return a2;
}

void fnho_networkConditionReleaseCallback(CFAllocatorRef allocator, CFTypeRef *ptr)
{
  if (*ptr) {
    CFRelease(*ptr);
  }

  CFAllocatorDeallocate(allocator, ptr);
}

void fnho_conditionApplier(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  CFTypeRef cf = 0;
  if (fnho_testCondition((uint64_t)a2, a1, &cf))
  {
    uint64_t v5 = *(void *)(DerivedStorage + 48);
    CFTypeRef v6 = cf;
    uint64_t v7 = CMBaseObjectGetDerivedStorage((uint64_t)a2);
    long long v8 = malloc_type_calloc(1uLL, 0x20uLL, 0x10E0040018299E6uLL);
    if (v8)
    {
      uint64_t v9 = v8;
      *long long v8 = v5;
      if (a2) {
        CFTypeRef v10 = CFRetain(a2);
      }
      else {
        CFTypeRef v10 = 0;
      }
      v9[1] = v10;
      int v9[2] = a1;
      if (v6) {
        CFTypeRef v11 = CFRetain(v6);
      }
      else {
        CFTypeRef v11 = 0;
      }
      v9[3] = v11;
      dispatch_async_f(*(dispatch_queue_t *)(v7 + 24), v9, (dispatch_function_t)fnho_dispatchObserverConditionFn);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
}

void fnho_dispatchObserverConditionFn(void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1[1]);
  ((void (*)(void, void, void, void))*a1)(a1[1], *(void *)(DerivedStorage + 40), a1[2], a1[3]);
  uint64_t v3 = (const void *)a1[1];
  if (v3) {
    CFRelease(v3);
  }
  dispatch_time_t v4 = (const void *)a1[3];
  if (v4) {
    CFRelease(v4);
  }

  free(a1);
}

uint64_t FigAudioRenderingPreferencesGetTypeID()
{
  if (FigAudioRenderingPreferencesGetTypeID_sRegisterAudioRenderingPreferencesTypeOnce != -1) {
    dispatch_once_f(&FigAudioRenderingPreferencesGetTypeID_sRegisterAudioRenderingPreferencesTypeOnce, &FigAudioRenderingPreferencesGetTypeID_sAudioRenderingPreferencesID, (dispatch_function_t)RegisterAudioRenderingPreferencesType);
  }
  return FigAudioRenderingPreferencesGetTypeID_sAudioRenderingPreferencesID;
}

uint64_t RegisterAudioRenderingPreferencesType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigAudioRenderingPreferencesCreate(uint64_t a1, uint64_t a2, unint64_t a3, _DWORD *a4, void *a5)
{
  if (a5)
  {
    BOOL v7 = a3 == 0;
    if (a4) {
      BOOL v7 = a3 != 0;
    }
    if (v7
      && (!a4
       || a3 > 0x1F
       && (*a4 || 20 * (unint64_t)(a4[2] - 1) + 32 <= a3)
       && FigGetAudioChannelCountFromLayout((uint64_t)a4, a3) == a2))
    {
      if (FigAudioRenderingPreferencesGetTypeID_sRegisterAudioRenderingPreferencesTypeOnce != -1) {
        dispatch_once_f(&FigAudioRenderingPreferencesGetTypeID_sRegisterAudioRenderingPreferencesTypeOnce, &FigAudioRenderingPreferencesGetTypeID_sAudioRenderingPreferencesID, (dispatch_function_t)RegisterAudioRenderingPreferencesType);
      }
      uint64_t Instance = (void *)_CFRuntimeCreateInstance();
      if (Instance)
      {
        CFTypeRef v11 = Instance;
        Instance[2] = a2;
        Instance[3] = a3;
        if (a3)
        {
          if (a4) {
            memcpy(Instance + 4, a4, a3);
          }
        }
        *a5 = v11;
        return 0;
      }
      uint64_t v13 = 4294954585;
    }
    else
    {
      uint64_t v13 = 4294954586;
    }
  }
  else
  {
    uint64_t v13 = 4294954586;
  }

  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioRenderingPreferencesGetMaximumChannelCountAndPreferredChannelLayout(uint64_t a1, void *a2, void *a3)
{
  if (a1)
  {
    if (a2) {
      *a2 = *(void *)(a1 + 24);
    }
    uint64_t v3 = a1 + 32;
    uint64_t v5 = a1 + 16;
    uint64_t result = *(void *)(a1 + 16);
    if (!*(void *)(v5 + 8)) {
      uint64_t v3 = 0;
    }
    *a3 = v3;
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

uint64_t audioRenderingPreferences_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

CFStringRef audioRenderingPreferences_CopyDebugDesc(void *cf)
{
  CFTypeRef v7 = 0;
  uint64_t v2 = cf[3];
  if (v2)
  {
    int v6 = 8;
    AudioToolbox_AudioFormatGetProperty(1819242093, v2, (uint64_t)(cf + 4), (uint64_t)&v6, (uint64_t)&v7);
  }
  CFAllocatorRef v3 = CFGetAllocator(cf);
  CFStringRef v4 = CFStringCreateWithFormat(v3, 0, @"FigAudioRenderingPreferences [%p]: maximum channel count %d, preferred channel layout size %d, preferred channel layout name \"%@\"", cf, cf[2], cf[3], v7);
  if (v7) {
    CFRelease(v7);
  }
  return v4;
}

uint64_t FigMetricEventTimelineClientServerXPC_SerializeEvent(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v6 = *(void *)(CMBaseObjectGetVTable(a3) + 16);
    if (v6) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0;
    }
    long long v8 = *(uint64_t (**)(uint64_t))(v7 + 72);
    if (v8) {
      int v9 = v8(a3);
    }
    else {
      int v9 = 0;
    }
    uint64_t v10 = *(void *)(CMBaseObjectGetVTable(a3) + 16);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    long long v12 = *(uint64_t (**)(uint64_t))(v11 + 24);
    if (v12) {
      int64_t v13 = v12(a3);
    }
    else {
      int64_t v13 = -12782;
    }
    xpc_dictionary_set_int64(a1, "EventID", v13);
    xpc_dictionary_set_BOOL(a1, "MockEvent", v9 != 0);
    if (!v9)
    {
      uint64_t v15 = *(void *)(CMBaseObjectGetVTable(a3) + 16);
      if (v15) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = 0;
      }
      CFNumberRef v17 = *(void (**)(uint64_t, void *))(v16 + 80);
      if (v17) {
        v17(a3, a1);
      }
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigMetricEventTimelineClientServerXPC_DeserializeAndCopyEvent(void *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    int64_t int64 = xpc_dictionary_get_int64(a1, "EventID");
    if (xpc_dictionary_get_BOOL(a1, "MockEvent"))
    {
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      uint64_t v6 = FigMetricMockEventForTestCreate(AllocatorForMedia, int64, &cf);
      if (v6) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v6 = FigMetricEventDeserializeEvent(a1, &cf);
      if (v6)
      {
LABEL_4:
        uint64_t v7 = v6;
        if (cf) {
          CFRelease(cf);
        }
        return v7;
      }
    }
    uint64_t v7 = 0;
    *a2 = cf;
    return v7;
  }

  return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
}

pthread_mutex_t *FigNotificationCenterSupportInitOnce()
{
  sFigNotificationCenterLocks_0 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  uint64_t result = FigSimpleMutexCreate();
  sFigNotificationCenterLocks_1 = (uint64_t)result;
  return result;
}

uint64_t FigNotificationCenterSupportWillPostNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  if (!result)
  {
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)-a3);
    uint64_t result = FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
    if (!result && Value != 0)
    {
      return FigReadWriteLockLockForRead((uint64_t)Value);
    }
  }
  return result;
}

uint64_t FigNotificationCenterSupportDidPostNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1))
  {
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)-a3);
    if (FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = Value == 0;
    }
    if (!v5) {
      FigReadWriteLockUnlockForRead((uint64_t)Value);
    }
  }
  return 0;
}

uint64_t CMNotificationCenterRegisterForBarrierSupport(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = FigReadWriteLockCreate(0);
  if (v3)
  {
    CFStringRef v4 = (uint64_t *)v3;
    uint64_t v5 = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
    if (v5) {
      return v5;
    }
    uint64_t v6 = -a2;
    if (CFDictionaryContainsKey((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v6))
    {
      uint64_t v7 = FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
      FigReadWriteLockDestroy(v4);
      if (v7)
      {
        FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
        return v7;
      }
    }
    else
    {
      CFDictionarySetValue((CFMutableDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v6, v4);
    }
    long long v8 = (pthread_mutex_t *)sFigNotificationCenterLocks_1;
    return FigSimpleMutexUnlock(v8);
  }
  else
  {
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CMNotificationCenterUnregisterForBarrierSupport(uint64_t a1, uint64_t a2)
{
  uint64_t result = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  if (!result)
  {
    uint64_t v4 = -a2;
    CFStringRef Value = (uint64_t *)CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v4);
    if (Value)
    {
      uint64_t v6 = Value;
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v4);
      unsigned int v7 = FigReadWriteLockDestroy(v6);
    }
    else
    {
      unsigned int v7 = FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
    }
    unsigned int v8 = v7;
    LODWORD(result) = FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
    if (v8) {
      return v8;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t CMNotificationCenterBarrier(uint64_t a1, uint64_t a2)
{
  uint64_t result = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  if (!result)
  {
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)-a2);
    uint64_t result = FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
    if (!result)
    {
      if (Value)
      {
        uint64_t result = FigReadWriteLockLockForWrite((uint64_t)Value);
        if (!result)
        {
          return FigReadWriteLockUnlockForWrite((uint64_t)Value);
        }
      }
      else
      {
        return FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return result;
}

uint64_t FigNotificationCenterAddListeners(__CFNotificationCenter *a1, const void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (!a4) {
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  while (1)
  {
    long long v12 = *(void *)(a3 + v10)
        ? *(void (__cdecl **)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))(a3 + v10)
        : 0;
    uint64_t v13 = CMNotificationCenterAddListener(a1, a2, v12, **(const __CFString ***)(a3 + v10 + 8), (unint64_t)a5);
    if (v13) {
      break;
    }
    ++v11;
    v10 += 16;
    if (a4 == v11) {
      return 0;
    }
  }
  uint64_t v14 = v13;
  FigNotificationCenterRemoveListeners(a1, a2, a3, v11, a5);
  return v14;
}

uint64_t FigNotificationCenterRemoveListeners(__CFNotificationCenter *a1, const void *a2, uint64_t a3, uint64_t a4, void *object)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  LODWORD(v10) = 0;
  uint64_t v11 = (CFNotificationName **)(a3 + 8);
  do
  {
    if (*(v11 - 1)) {
      int v12 = *(v11 - 1);
    }
    else {
      int v12 = 0;
    }
    uint64_t v13 = *v11;
    v11 += 2;
    unsigned int v14 = CMNotificationCenterRemoveListener(a1, a2, v12, *v13, object);
    if (v10) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = v14 == 0;
    }
    if (v15) {
      uint64_t v10 = v10;
    }
    else {
      uint64_t v10 = v14;
    }
    v7 += 16;
    --v6;
  }
  while (v6);
  return v10;
}

uint64_t FigPowerLogRegisterEvent(const void *a1, const __CFDictionary *a2, int a3)
{
  id v6 = objc_alloc_init(MEMORY[0x1E4F28B28]);
  uint64_t v7 = 0;
  if (a1 && a2)
  {
    if (openFrameworkPredicate != -1) {
      dispatch_once_f(&openFrameworkPredicate, 0, (dispatch_function_t)figPowerLogOpenFramework);
    }
    uint64_t v7 = 0;
    if (figPLShouldLogRegisteredEvent && figPLLogRegisteredEvent)
    {
      if (figPLShouldLogRegisteredEvent(28, a1)
        && (CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2)) != 0)
      {
        CFMutableDictionaryRef v9 = MutableCopy;
        FigCFDictionarySetInt32(MutableCopy, @"clientPID", a3);
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 3221225472;
        int v12[2] = __FigPowerLogRegisterEvent_block_invoke;
        v12[3] = &__block_descriptor_52_e5_v8__0l;
        int v13 = a3;
        v12[4] = v9;
        v12[5] = a1;
        CFRetain(v9);
        CFRetain(a1);
        if (FigPowerLogRegisterEvent_sCreatePowerLogQueueOnce != -1) {
          dispatch_once(&FigPowerLogRegisterEvent_sCreatePowerLogQueueOnce, &__block_literal_global_59);
        }
        v11[0] = MEMORY[0x1E4F143A8];
        v11[1] = 3221225472;
        int v11[2] = __FigPowerLogRegisterEvent_block_invoke_3;
        v11[3] = &unk_1E567F828;
        v11[4] = v12;
        dispatch_async((dispatch_queue_t)sPowerLogProcessingQueue, v11);
        CFRelease(v9);
        uint64_t v7 = 1;
      }
      else
      {
        uint64_t v7 = 0;
      }
    }
  }
  [v6 drain];
  return v7;
}

void figPowerLogOpenFramework()
{
  unint64_t v0 = (void *)MGCopyAnswer();
  if (v0)
  {
    int v1 = v0;
    BOOL v2 = 1;
    if ([v0 rangeOfString:@"AudioAccessory" options:1] != 0x7FFFFFFFFFFFFFFFLL) {
      BOOL v2 = v3 != [@"AudioAccessory" length];
    }
    isPowerLogEnabled = v2;
    CFRelease(v1);
  }
  if (isPowerLogEnabled)
  {
    uint64_t v4 = dlopen("/System/Library/PrivateFrameworks/PowerLog.framework/PowerLog", 4);
    if (v4)
    {
      uint64_t v5 = v4;
      figPLShouldLogRegisteredEvent = dlsym(v4, "PLShouldLogRegisteredEvent");
      figPLLogRegisteredEvent = dlsym(v5, "PLLogRegisteredEvent");
      figPLLogTimeSensitiveRegisteredEvent = dlsym(v5, "PLLogTimeSensitiveRegisteredEvent");
    }
  }
}

void __FigPowerLogRegisterEvent_block_invoke(uint64_t a1)
{
  BOOL v2 = (void *)MEMORY[0x192FC5D30]();
  uint64_t v8 = 0;
  uint64_t v3 = objc_msgSend(MEMORY[0x1E4F963F0], "handleForIdentifier:error:", objc_msgSend(MEMORY[0x1E4F96400], "identifierWithPid:", *(unsigned int *)(a1 + 48)), &v8);
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = (void *)[v3 identity];
    id v6 = (const void *)[v5 embeddedApplicationIdentifier];
    if (v6 || (id v6 = (const void *)[v5 xpcServiceIdentifier]) != 0)
    {
    }
    else
    {
      id v6 = (const void *)objc_msgSend((id)objc_msgSend(v4, "bundle"), "identifier");
      if (!v6) {
        goto LABEL_8;
      }
    }
    CFTypeID v7 = CFGetTypeID(v6);
    if (v7 == CFStringGetTypeID()) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), @"clientDisplayID", v6);
    }
  }
  else
  {
  }
LABEL_8:
  figPLLogRegisteredEvent(28, *(void *)(a1 + 40), *(void *)(a1 + 32), 0);
  CFRelease(*(CFTypeRef *)(a1 + 32));
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

dispatch_queue_t __FigPowerLogRegisterEvent_block_invoke_2()
{
  dispatch_queue_t result = FigDispatchQueueCreateWithPriority("com.apple.coremedia.powerlogprocessing", 0, 0);
  sPowerLogProcessingQueue = (uint64_t)result;
  return result;
}

uint64_t __FigPowerLogRegisterEvent_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t FigPlaybackLogPowerEvent(unsigned int a1, unsigned int a2, CFDictionaryRef theDict)
{
  uint64_t v3 = 0;
  unsigned int v17 = 0;
  if (a1 <= 1 && theDict && a2 <= 8)
  {
    id v6 = off_1E567F848[a2];
    if (a1 == 1)
    {
      CFTypeID v7 = (void *)MEMORY[0x192FC5D30]();
      uint64_t v16 = 0;
      FigCFDictionaryGetInt32IfPresent((uint64_t)theDict, @"processID", &v17);
      uint64_t v8 = objc_msgSend(MEMORY[0x1E4F963F0], "handleForIdentifier:error:", objc_msgSend(MEMORY[0x1E4F96400], "identifierWithPid:", v17, 0), &v16);
      if (v8)
      {
        CFMutableDictionaryRef v9 = v8;
        uint64_t v10 = (void *)[v8 identity];
        uint64_t v11 = (const void *)[v10 embeddedApplicationIdentifier];
        if (!v11)
        {
          uint64_t v11 = (const void *)[v10 xpcServiceIdentifier];
          if (!v11) {
            uint64_t v11 = (const void *)objc_msgSend((id)objc_msgSend(v9, "bundle"), "identifier");
          }
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
    if (MutableCopy)
    {
      CFMutableDictionaryRef v13 = MutableCopy;
      if (v11)
      {
        CFTypeID v14 = CFGetTypeID(v11);
        if (v14 == CFStringGetTypeID()) {
          FigCFDictionarySetValue(v13, @"BundleID", v11);
        }
      }
      FigCFDictionarySetInt32(v13, @"Category", a2);
      if (openFrameworkPredicate != -1) {
        dispatch_once_f(&openFrameworkPredicate, 0, (dispatch_function_t)figPowerLogOpenFramework);
      }
      if (figPLLogTimeSensitiveRegisteredEvent)
      {
        figPLLogTimeSensitiveRegisteredEvent(28, v6, v13, 0);
        uint64_t v3 = 1;
      }
      else
      {
        uint64_t v3 = 0;
      }
      CFRelease(v13);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t FigCFWeakReferenceHolderGetTypeID()
{
  if (FigCFWeakReferenceHolderGetTypeID_once != -1) {
    dispatch_once_f(&FigCFWeakReferenceHolderGetTypeID_once, 0, (dispatch_function_t)registerFigCFWeakReferenceHolder);
  }
  return sFigCFWeakReferenceHolderID;
}

uint64_t registerFigCFWeakReferenceHolder()
{
  sFigCFWeakReferenceHolderUseCache = 1;
  sFigCFWeakReferenceHolderDictionaryMutedouble x = (uint64_t)FigSimpleMutexCreate();
  sFigCFWeakReferenceHolderDictionardouble y = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCFWeakReferenceHolderIOSurfaceID ID = result;
  return result;
}

CFTypeRef FigCFWeakReferenceHolderCreateWithReferencedObject(uint64_t a1)
{
  if (FigCFWeakReferenceHolderGetTypeID_once != -1) {
    dispatch_once_f(&FigCFWeakReferenceHolderGetTypeID_once, 0, (dispatch_function_t)registerFigCFWeakReferenceHolder);
  }
  CFTypeRef cf = 0;
  CFTypeID v7 = 0;
  if (!a1) {
    return 0;
  }
  if (sFigCFWeakReferenceHolderUseCache == 1
    && FigSimpleMutexTryLock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex))
  {
    FigCFWeakReferenceHolderCopyCachedInstance(a1, (uint64_t *)&v7, (uint64_t *)&cf);
    FigSimpleMutexUnlock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
    CFRelease((CFTypeRef)a1);
    if (cf) {
      CFRelease(cf);
    }
  }
  CFTypeRef v2 = v7;
  if (!v7)
  {
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v4 = Instance;
    if (Instance) {
      FigCFWeakReferenceInit((id *)(Instance + 24), (id)a1);
    }
    if (sFigCFWeakReferenceHolderUseCache == 1
      && FigSimpleMutexTryLock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex))
    {
      uint64_t v8 = 0;
      FigCFWeakReferenceHolderCopyCachedInstance(a1, (uint64_t *)&v8, (uint64_t *)&cf);
      CFTypeRef v2 = v8;
      if (!v8)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)sFigCFWeakReferenceHolderDictionary, (const void *)-a1, (const void *)-v4);
        *(void *)(v4 + 16) = -a1;
        CFTypeRef v2 = CFRetain((CFTypeRef)v4);
      }
      FigSimpleMutexUnlock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
      CFRelease((CFTypeRef)a1);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease((CFTypeRef)v4);
    }
    else
    {
      return (CFTypeRef)v4;
    }
  }
  return v2;
}

void FigCFWeakReferenceHolderCopyCachedInstance(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = -a1;
  CFDictionaryGetValue((CFDictionaryRef)sFigCFWeakReferenceHolderDictionary, (const void *)-a1);
  CFRetain((CFTypeRef)a1);
  uint64_t v7 = _CFTryRetain();
  uint64_t v8 = v7;
  if (v7)
  {
    if (FigCFWeakReferenceLoadAndRetain((id *)(v7 + 24)) == (id)a1)
    {
      CFRelease((CFTypeRef)a1);
      uint64_t v9 = v8;
      uint64_t v8 = 0;
      goto LABEL_6;
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigCFWeakReferenceHolderDictionary, (const void *)v6);
  }
  uint64_t v9 = 0;
LABEL_6:
  *a2 = v9;
  *a3 = v8;
}

id *FigCFWeakReferenceHolderCopyReferencedObject(id *result)
{
  if (result) {
    return (id *)FigCFWeakReferenceLoadAndRetain(result + 3);
  }
  return result;
}

uint64_t FigCFWeakReferenceHolderInit(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

void FigCFWeakReferenceHolderFinalize(uint64_t a1)
{
  if (sFigCFWeakReferenceHolderUseCache == 1 && *(void *)(a1 + 16))
  {
    FigSimpleMutexLock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
    if (!((char *)CFDictionaryGetValue((CFDictionaryRef)sFigCFWeakReferenceHolderDictionary, *(const void **)(a1 + 16))
         + a1))
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigCFWeakReferenceHolderDictionary, *(const void **)(a1 + 16));
    FigSimpleMutexUnlock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
  }

  FigCFWeakReferenceDestroy((id *)(a1 + 24));
}

CFStringRef FigCFWeakReferenceHolderCopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"FigCFWeakReferenceHolder <%p> -> <%p>", a1, *(void *)(a1 + 24));
}

uint64_t FigEndpointRPCCacheCreate(void *a1, int a2)
{
  uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0x20uLL, 0x102004039A5F366uLL);
  if (v4)
  {
    uint64_t v5 = v4;
    *(_DWORD *)uint64_t v4 = a2;
    *(_OWORD *)(v4 + 8) = xmmword_18FE96E70;
    uint64_t v6 = 0;
    *((void *)v4 + 3) = malloc_type_calloc(0x20uLL, 0x10uLL, 0x10C004028F705ECuLL);
    *a1 = v5;
  }
  else
  {
    uint64_t v6 = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  }
  FigEndpointRPCCacheDispose(0);
  return v6;
}

void FigEndpointRPCCacheDispose(void *a1)
{
  if (a1)
  {
    CFTypeRef v2 = (char *)a1[3];
    if (v2)
    {
      uint64_t v3 = a1[1];
      if (v3 >= 1)
      {
        uint64_t v4 = 0;
        for (uint64_t i = 0; i < v3; ++i)
        {
          if (*(void *)&v2[v4])
          {
            CFRelease(*(CFTypeRef *)&v2[v4]);
            CFTypeRef v2 = (char *)a1[3];
            *(void *)&v2[v4] = 0;
            uint64_t v3 = a1[1];
          }
          v4 += 16;
        }
      }
      a1[3] = 0;
      free(v2);
    }
    free(a1);
  }
}

uint64_t FigEndpointRPCCacheRemoveAllEndpoints(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(a1 + 24);
    do
    {
      uint64_t v6 = *(const void **)(v5 + v3);
      if (v6)
      {
        CFRelease(v6);
        uint64_t v5 = *(void *)(a1 + 24);
        *(void *)(v5 + v3) = 0;
        uint64_t v2 = *(void *)(a1 + 8);
      }
      *(void *)(v5 + v3 + 8) = 0;
      ++v4;
      v3 += 16;
    }
    while (v4 < v2);
  }
  *(void *)(a1 + 8) = 0;
  return 0;
}

uint64_t FigEndpointRPCCacheComputeCacheDeltas(uint64_t a1, _xpc_connection_s *a2, CFArrayRef theArray, void *a4, void *a5)
{
  CFArrayRef MutableCopy = FigCFArrayCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], theArray);
  uint64_t v10 = *(void *)(a1 + 8);
  if (v10 < 1)
  {
    xpc_object_t v11 = 0;
  }
  else
  {
    xpc_object_t v11 = 0;
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = *(void *)(a1 + 24);
      CFTypeID v14 = (const void **)(v13 + 16 * v12);
      v26.size_t length = CFArrayGetCount(MutableCopy);
      v26.location = 0;
      FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(MutableCopy, v26, *v14);
      if (FirstIndexOfValue == -1)
      {
        if (a5)
        {
          if (!v11) {
            xpc_object_t v11 = xpc_array_create(0, 0);
          }
          xpc_array_set_uint64(v11, 0xFFFFFFFFFFFFFFFFLL, *(void *)(v13 + 16 * v12 + 8));
        }
        if (*v14)
        {
          CFRelease(*v14);
          *CFTypeID v14 = 0;
        }
        --v10;
        *(_OWORD *)(*(void *)(a1 + 24) + 16 * v12) = *(_OWORD *)(*(void *)(a1 + 24) + 16 * v10);
        --*(void *)(a1 + 8);
      }
      else
      {
        CFArrayRemoveValueAtIndex(MutableCopy, FirstIndexOfValue);
        ++v12;
      }
    }
    while (v12 < v10);
  }
  CFIndex Count = CFArrayGetCount(MutableCopy);
  if (!Count)
  {
    xpc_object_t v18 = 0;
    if (!a4)
    {
LABEL_26:
      uint64_t v22 = 0;
      if (a5)
      {
        *a5 = v11;
        xpc_object_t v11 = 0;
      }
      goto LABEL_28;
    }
LABEL_25:
    *a4 = v18;
    xpc_object_t v18 = 0;
    goto LABEL_26;
  }
  uint64_t v17 = Count;
  xpc_object_t v18 = xpc_array_create(0, 0);
  if (v17 < 1)
  {
LABEL_24:
    if (!a4) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  long long v24 = a4;
  CFIndex v19 = 0;
  while (1)
  {
    uint64_t v25 = 0;
    ValueAtIndedouble x = (void *)CFArrayGetValueAtIndex(MutableCopy, v19);
    uint64_t v21 = *(_DWORD *)a1 == 1
        ? FigEndpointXPCServerAppendNeighborEndpointToArray(a2, ValueAtIndex, v18, (uint64_t *)&v25)
        : FigSignalErrorAt(4294950056, 0, 0, 0, 0, 0, 0);
    uint64_t v22 = v21;
    if (v21) {
      break;
    }
    figEndpointRPCCacheAddObject(a1, ValueAtIndex, v25);
    if (v17 == ++v19)
    {
      a4 = v24;
      goto LABEL_24;
    }
  }
LABEL_28:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  FigXPCRelease(v18);
  FigXPCRelease(v11);
  return v22;
}

void *figEndpointRPCCacheAddObject(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 == *(void *)(a1 + 16))
  {
    uint64_t v7 = v6 + 16;
    uint64_t result = malloc_type_realloc(*(void **)(a1 + 24), 16 * (v6 + 16), 0x264AB722uLL);
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = result;
    uint64_t v6 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t result = *(void **)(a1 + 24);
  }
  result[2 * v6 + 1] = a3;
  if (a2)
  {
    CFTypeRef v9 = CFRetain(a2);
    uint64_t result = *(void **)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 8);
  }
  else
  {
    CFTypeRef v9 = 0;
  }
  result[2 * v6] = v9;
  *(void *)(a1 + 8) = v6 + 1;
  return result;
}

void *FigEndpointRPCCacheApplyObjectDeltas(uint64_t a1, xpc_object_t xarray, xpc_object_t a3)
{
  uint64_t v21 = 0;
  CFTypeRef cf = 0;
  if (xarray && (size_t v6 = xpc_array_get_count(xarray)) != 0)
  {
    size_t v7 = v6;
    size_t v8 = 0;
    while (1)
    {
      CFTypeRef v9 = *(_DWORD *)a1 == 1
         ? FigEndpointXPCRemoteRetainCopiedEndpointFromArray(xarray, v8, &v21, &cf)
         : (void *)FigSignalErrorAt(4294950056, 0, 0, 0, 0, 0, 0);
      uint64_t v10 = v9;
      if (v9) {
        break;
      }
      figEndpointRPCCacheAddObject(a1, cf, v21);
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
      if (v7 == ++v8) {
        goto LABEL_11;
      }
    }
  }
  else
  {
LABEL_11:
    if (a3)
    {
      size_t count = xpc_array_get_count(a3);
      if (count)
      {
        size_t v12 = count;
        for (size_t i = 0; i != v12; ++i)
        {
          uint64_t int64 = xpc_array_get_uint64(a3, i);
          uint64_t v21 = uint64;
          uint64_t v15 = *(void *)(a1 + 8);
          if (v15 >= 1)
          {
            uint64_t v16 = 0;
            uint64_t v17 = *(void *)(a1 + 24);
            uint64_t v18 = *(void *)(a1 + 8);
            while (*(void *)(v17 + v16 + 8) != uint64)
            {
              v16 += 16;
              if (!--v18) {
                goto LABEL_22;
              }
            }
            CFIndex v19 = *(const void **)(v17 + v16);
            if (v19)
            {
              CFRelease(v19);
              uint64_t v17 = *(void *)(a1 + 24);
              *(void *)(v17 + v16) = 0;
              uint64_t v15 = *(void *)(a1 + 8);
            }
            *(_OWORD *)(v17 + v16) = *(_OWORD *)(v17 + 16 * v15 - 16);
            --*(void *)(a1 + 8);
          }
LABEL_22:
          ;
        }
      }
    }
    uint64_t v10 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t FigEndpointRPCCacheCopyAvailableObjects(uint64_t a1, __CFArray **a2)
{
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    if (*(uint64_t *)(a1 + 8) >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      do
      {
        CFArrayAppendValue(Mutable, *(const void **)(*(void *)(a1 + 24) + v5));
        ++v6;
        v5 += 16;
      }
      while (v6 < *(void *)(a1 + 8));
    }
    uint64_t result = 0;
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950585, 0, 0, 0, 0, 0, 0);
  }
  *a2 = Mutable;
  return result;
}

uint64_t FigForcefullyPurgeObjectsAndGenerateReportForPID(int a1, CFTypeRef *a2, CFTypeRef *a3, void *a4)
{
  return FigControlCommandsRemoteClientPurgeObjectsAndGenerateReportForPID(a1, 1, a2, a3, a4);
}

uint64_t FigControlCommandsRemoteClientPurgeObjectsAndGenerateReportForPID(int a1, int a2, CFTypeRef *a3, CFTypeRef *a4, void *a5)
{
  uint64_t v16 = 0;
  CFTypeRef v17 = 0;
  xpc_object_t xdict = 0;
  CFTypeRef cf = 0;
  xpc_object_t v13 = 0;
  if (a1 <= 0)
  {
    uint64_t v11 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  if (gFigControlCommandsRemoteClientSetupOnce != -1) {
    dispatch_once(&gFigControlCommandsRemoteClientSetupOnce, &__block_literal_global_60);
  }
  uint64_t v10 = remoteClient_EnsureClientEstablished_err;
  if (!remoteClient_EnsureClientEstablished_err)
  {
    uint64_t v11 = FigXPCCreateBasicMessage(0x70677270u, 0, &xdict);
    if (!v11)
    {
      xpc_dictionary_set_int64(xdict, "Pid", a1);
      xpc_dictionary_set_BOOL(xdict, "ForcePurge", a2 != 0);
      uint64_t v11 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigControlCommandsRemoteClient, (uint64_t)xdict, &v13);
      if (!v11)
      {
        uint64_t v11 = FigXPCMessageCopyCFBoolean(v13, "CouldNotPurgeAllObjects", &v17);
        if (!v11)
        {
          uint64_t v11 = FigXPCMessageCopyCFBoolean(v13, "PurgeProhibited", &v16);
          if (!v11)
          {
            uint64_t v11 = FigXPCMessageCopyCFString(v13, "Stats", &cf);
            if (!v11)
            {
              if (a3)
              {
                *a3 = cf;
                CFTypeRef cf = 0;
              }
              if (a4)
              {
                *a4 = v17;
                CFTypeRef v17 = 0;
              }
              uint64_t v10 = 0;
              if (a5)
              {
                *a5 = v16;
                uint64_t v16 = 0;
              }
              goto LABEL_16;
            }
          }
        }
      }
    }
LABEL_22:
    uint64_t v10 = v11;
  }
LABEL_16:
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    CFRelease(v17);
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v13);
  return v10;
}

uint64_t FigPurgeObjectsAndGenerateReportForPID(int a1, CFTypeRef *a2, CFTypeRef *a3, void *a4)
{
  return FigControlCommandsRemoteClientPurgeObjectsAndGenerateReportForPID(a1, 0, a2, a3, a4);
}

uint64_t CMStartAirPlayLoopback()
{
  uint64_t v4 = 0;
  if (gFigControlCommandsRemoteClientSetupOnce != -1) {
    dispatch_once(&gFigControlCommandsRemoteClientSetupOnce, &__block_literal_global_60);
  }
  uint64_t v0 = remoteClient_EnsureClientEstablished_err;
  if (remoteClient_EnsureClientEstablished_err)
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v1 = FigXPCCreateBasicMessage(0x6C6F6F70u, 0, &v4);
    uint64_t v2 = v4;
    if (v1)
    {
      uint64_t v0 = v1;
    }
    else
    {
      uint64_t v0 = FigXPCRemoteClientSendAsyncMessage(gFigControlCommandsRemoteClient, v4);
      uint64_t v2 = v4;
    }
  }
  FigXPCRelease(v2);
  return v0;
}

uint64_t FigRPCTimeoutRemote_KillAndForceCrashReport(mach_port_name_t a1, uint64_t a2, char *src)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v12 = 0u;
  memset(v13, 0, 464);
  *(_OWORD *)rcv_mach_port_name_t name = 0u;
  long long v11 = 0u;
  *((void *)&v11 + 1) = *MEMORY[0x1E4F14068];
  *(void *)&long long v12 = a2;
  if (MEMORY[0x1E4F149B0]) {
    int v4 = mig_strncpy_zerofill((char *)v13, src, 512);
  }
  else {
    int v4 = mig_strncpy((char *)v13, src, 512);
  }
  DWORD2(v12) = 0;
  HIDWORD(v12) = v4;
  mach_msg_size_t v5 = ((v4 + 3) & 0xFFFFFFFC) + 48;
  mach_port_t reply_port = mig_get_reply_port();
  rcv_name[2] = a1;
  rcv_name[3] = reply_port;
  rcv_name[0] = 5395;
  *(void *)&long long v11 = 0x275C00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)rcv_name);
    mach_port_t reply_port = rcv_name[3];
  }
  uint64_t v7 = mach_msg((mach_msg_header_t *)rcv_name, 3, v5, 0x2Cu, reply_port, 0, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(rcv_name[3]);
    return v8;
  }
  if (v7)
  {
    mig_dealloc_reply_port(rcv_name[3]);
    return v8;
  }
  if (DWORD1(v11) == 71)
  {
    uint64_t v8 = 4294966988;
LABEL_20:
    mach_msg_destroy((mach_msg_header_t *)rcv_name);
    return v8;
  }
  if (DWORD1(v11) != 10176)
  {
    uint64_t v8 = 4294966995;
    goto LABEL_20;
  }
  uint64_t v8 = 4294966996;
  if ((rcv_name[0] & 0x80000000) != 0) {
    goto LABEL_20;
  }
  if (rcv_name[1] != 36) {
    goto LABEL_20;
  }
  if (rcv_name[2]) {
    goto LABEL_20;
  }
  uint64_t v8 = v12;
  if (v12) {
    goto LABEL_20;
  }
  return v8;
}

uint64_t (*FigRPCTimeout_server_routine(uint64_t a1))()
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 10079) >= 0xFFFFFFFD) {
    return FigRPCTimeoutServer_FigRPCTimeout_subsystem[5 * (v1 - 10076) + 5];
  }
  else {
    return 0;
  }
}

_DWORD *_XKillAndForceCrashReport(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0
    && (uint64_t v3 = result, v4 = result[1], v4 >= 0x30)
    && v4 <= 0x230
    && ((v5 = result[11], v5 <= 0x200) ? (BOOL v6 = (int)v4 - 48 >= v5) : (BOOL v6 = 0),
        (unsigned int v7 = ((v5 + 3) & 0xFFFFFFFC) + 48, v6) ? (v8 = v4 == v7) : (v8 = 0),
        v8 && (uint64_t result = memchr(result + 12, 0, v4 - 48)) != 0))
  {
    uint64_t v10 = (char *)v3 + ((v4 + 3) & 0x1FFFFFFFCLL);
    if (!*(_DWORD *)v10 && *((_DWORD *)v10 + 1) > 0x1Fu)
    {
      uint64_t v11 = v3[3];
      uint64_t v12 = *((void *)v3 + 4);
      long long v13 = *(_OWORD *)(v10 + 36);
      v14[0] = *(_OWORD *)(v10 + 20);
      v14[1] = v13;
      uint64_t result = (_DWORD *)FigRPCTimeoutServer_KillAndForceCrashReport(v11, v12, (const char *)v3 + 48, v14);
      *(_DWORD *)(a2 + 32) = result;
      goto LABEL_13;
    }
    int v9 = -309;
  }
  else
  {
    int v9 = -304;
  }
  *(_DWORD *)(a2 + 32) = v9;
LABEL_13:
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _XSetFigNotePreferences(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 3 || *(_DWORD *)(result + 4) != 96)
  {
    int v6 = -304;
LABEL_12:
    *(_DWORD *)(a2 + 32) = v6;
    goto LABEL_13;
  }
  if (*(unsigned char *)(result + 39) != 1
    || *(unsigned char *)(result + 55) != 1
    || *(unsigned char *)(result + 71) != 1
    || (int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 84))
    || (unsigned int v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 88))
    || (unsigned int v5 = *(_DWORD *)(result + 72), v5 != *(_DWORD *)(result + 92)))
  {
    int v6 = -300;
    goto LABEL_12;
  }
  uint64_t result = FigRPCTimeoutServer_SetFigNotePreferences(*(unsigned int *)(result + 12), *(void *)(result + 28), v3, *(void *)(result + 44), v4, *(void *)(result + 60), v5);
  *(_DWORD *)(a2 + 32) = result;
LABEL_13:
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _XResetFigNotePreset(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v4 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v4;
    goto LABEL_9;
  }
  if (*(unsigned char *)(result + 39) != 1 || (int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    int v4 = -300;
    goto LABEL_8;
  }
  uint64_t result = FigRPCTimeoutServer_ResetFigNotePreset(*(unsigned int *)(result + 12), *(void *)(result + 28), v3);
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t FigRPCTimeout_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 10079) >= 0xFFFFFFFD
    && (unsigned int v5 = (void (*)(void))FigRPCTimeoutServer_FigRPCTimeout_subsystem[5 * (v4 - 10076) + 5]) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t sntp_shortstamp_ntoh(unsigned int a1)
{
  return __rev16(a1);
}

unint64_t sntp_timestamp_hton(unint64_t a1)
{
  return __rev32(a1);
}

uint64_t sntp_timestamp_to_datestamp(uint64_t result)
{
  return result;
}

unint64_t sntp_timestamp_from_datestamp(unsigned int a1, uint64_t a2)
{
  return a2 & 0xFFFFFFFF00000000 | a1;
}

uint64_t sntp_datestamp_subsecs_to_nsec(unint64_t a1)
{
  uint64_t v1 = (a1 * (unsigned __int128)0x3B9ACA00uLL) >> 64;
  if (1000000000 * a1 < 0x8000000000000000) {
    return v1;
  }
  else {
    return (v1 + 1);
  }
}

uint64_t sntp_datestamp_from_timespec(uint64_t a1)
{
  return a1;
}

double sntp_datestamp_to_double(uint64_t a1, unint64_t a2)
{
  return (double)a2 * 5.42101086e-20 + (double)a1;
}

double sntp_datestamp_from_double(double a1)
{
  return a1 - (double)(uint64_t)a1;
}

uint64_t sntp_calc_offset(uint64_t a1)
{
  uint64_t v2 = sntp_timestamp_to_datestamp(*(void *)(a1 + 4));
  uint64_t v4 = v3;
  uint64_t v5 = -v2;
  uint64_t v6 = sntp_timestamp_to_datestamp(*(void *)(a1 + 12));
  uint64_t v8 = v7;
  uint64_t v9 = sntp_timestamp_to_datestamp(*(void *)(a1 + 20));
  uint64_t v11 = v10;
  uint64_t v12 = sntp_timestamp_to_datestamp(*(void *)(a1 + 28));
  unsigned long long v14 = __PAIR128__(v5 - (v4 != 0) + __CFADD__(-v4, v8) + v6 + (unint64_t)__CFADD__(v8 - v4, v11) + v9, v8 - v4 + v11)- v13;
  return (__CFADD__((void)v14, (unint64_t)(*((void *)&v14 + 1) - v12) >> 63) + *((void *)&v14 + 1) - v12) >> 1;
}

uint64_t sntp_calc_delay(uint64_t a1)
{
  uint64_t v2 = sntp_timestamp_to_datestamp(*(void *)(a1 + 4));
  uint64_t v4 = v3;
  uint64_t v5 = -v2;
  uint64_t v6 = sntp_timestamp_to_datestamp(*(void *)(a1 + 12));
  uint64_t v8 = v7;
  uint64_t v9 = sntp_timestamp_to_datestamp(*(void *)(a1 + 20));
  unint64_t v11 = v10;
  uint64_t v12 = -v9;
  uint64_t v13 = sntp_timestamp_to_datestamp(*(void *)(a1 + 28));
  return v13
       + ((__PAIR128__(v5 - (v4 != 0) + (unint64_t)__CFADD__(-v4, v8) + v6, v8 - v4) - v11 + __PAIR128__(v12, v14)) >> 64);
}

unint64_t sntp_clock_select(unint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  unint64_t v2 = a1;
  unsigned int v3 = 0;
  unint64_t v4 = a1 + 80 * a2;
  unint64_t v5 = a1;
  do
  {
    if (!*(_DWORD *)v5 && *(unsigned char *)(v5 + 37)) {
      ++v3;
    }
    v5 += 80;
  }
  while (v5 < v4);
  unint64_t result = 0;
  unint64_t v7 = 0;
  uint64_t v8 = 0;
  unsigned int v31 = v3 >> 1;
  do
  {
    if (!*(_DWORD *)v2 && *(unsigned char *)(v2 + 37))
    {
      uint64_t v32 = v8;
      unint64_t v33 = v7;
      unint64_t v34 = result;
      uint64_t v9 = sntp_calc_delay(v2);
      unint64_t v10 = (_DWORD *)(v2 + 80);
      unint64_t v37 = v11;
      if (v2 + 80 >= v4)
      {
        unsigned int v36 = 1;
        unint64_t v35 = v2;
      }
      else
      {
        unsigned int v36 = 1;
        unint64_t v35 = v2;
        do
        {
          if (!*v10)
          {
            uint64_t v12 = sntp_calc_offset(v2);
            unint64_t v14 = v13;
            uint64_t v15 = sntp_calc_offset((uint64_t)v10);
            unint64_t v17 = v16;
            uint64_t v18 = sntp_calc_delay(v2);
            unint64_t v20 = v19;
            uint64_t v21 = sntp_calc_delay((uint64_t)v10);
            if ((__int128)(__PAIR128__(v18, v20) + __PAIR128__(v12, v14)) >= (__int128)(__PAIR128__(v15, v17)
                                                                                       - __PAIR128__(v21, v22))
              && (__int128)(__PAIR128__(v21, v22) + __PAIR128__(v15, v17)) >= (__int128)(__PAIR128__(v12, v14)
                                                                                       - __PAIR128__(v18, v20)))
            {
              ++v36;
              uint64_t v23 = sntp_calc_delay((uint64_t)v10);
              unint64_t v25 = v37;
              CFRange v26 = (_DWORD *)v35;
              if ((__int128)__PAIR128__(v23, v24) < (__int128)__PAIR128__(v9, v37)) {
                CFRange v26 = v10;
              }
              unint64_t v35 = (unint64_t)v26;
              if ((__int128)__PAIR128__(v23, v24) < (__int128)__PAIR128__(v9, v37))
              {
                uint64_t v9 = v23;
                unint64_t v25 = v24;
              }
              unint64_t v37 = v25;
            }
          }
          v10 += 20;
        }
        while ((unint64_t)v10 < v4);
      }
      uint64_t v8 = v32;
      unint64_t v7 = v33;
      unint64_t v27 = v37;
      unint64_t result = v34;
      unint64_t v28 = v35;
      BOOL v29 = (__int128)__PAIR128__(v9, v37) < (__int128)__PAIR128__(v32, v33) || v34 == 0;
      if (v29) {
        uint64_t v30 = v9;
      }
      else {
        uint64_t v30 = v32;
      }
      if (!v29)
      {
        unint64_t v27 = v33;
        unint64_t v28 = v34;
      }
      if (v36 > v31)
      {
        unint64_t v7 = v27;
        uint64_t v8 = v30;
        unint64_t result = v28;
      }
    }
    v2 += 80;
  }
  while (v2 < v4);
  return result;
}

unint64_t sntp_packet_ntoh@<X0>(long long *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  long long v5 = *a1;
  uint64_t v6 = *((void *)a1 + 2);
  sntp_header_ntoh((int *)&v5, a2);
  *(void *)(a2 + 24) = sntp_timestamp_hton(*((void *)a1 + 3));
  *(void *)(a2 + 32) = sntp_timestamp_hton(*((void *)a1 + 4));
  unint64_t result = sntp_timestamp_hton(*((void *)a1 + 5));
  *(void *)(a2 + 40) = result;
  return result;
}

unint64_t sntp_header_ntoh@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  int v5 = *a1;
  unsigned int v4 = a1[1];
  *(_DWORD *)a2 = v5;
  *(_DWORD *)(a2 + 4) = sntp_shortstamp_ntoh(v4);
  int v6 = sntp_shortstamp_ntoh(a1[2]);
  unsigned int v7 = bswap32(a1[3]);
  *(_DWORD *)(a2 + 8) = v6;
  *(_DWORD *)(a2 + 12) = v7;
  unint64_t result = sntp_timestamp_hton(*((void *)a1 + 2));
  *(void *)(a2 + 16) = result;
  return result;
}

__n128 sntp_client_exchange@<Q0>(int a1@<W0>, timeval *a2@<X3>, uint64_t (*a3)(void)@<X4>, uint64_t a4@<X8>)
{
  long long v19 = 0u;
  long long v20 = 0u;
  memset(v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  if (__darwin_check_fd_set_overflow(a1, &v17, 0)) {
    *(__int32_t *)((char *)v17.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  }
  long long v16 = 0u;
  memset(v15, 0, sizeof(v15));
  LOBYTE(v15[0]) = 35;
  if (a3)
  {
    *(void *)((char *)v18 + 4) = a3();
    *((void *)&v16 + 1) = sntp_timestamp_hton(*(unint64_t *)((char *)v18 + 4));
  }
  if (send(a1, v15, 0x30uLL, 0) != 48)
  {
    int v9 = 5;
LABEL_17:
    LODWORD(v18[0]) = v9;
    long long v10 = v19;
    *(_OWORD *)(a4 + 32) = v18[2];
    *(_OWORD *)(a4 + 48) = v10;
    *(_OWORD *)(a4 + 64) = v20;
    __n128 result = (__n128)v18[1];
    *(_OWORD *)a4 = v18[0];
    *(__n128 *)(a4 + 16) = result;
    return result;
  }
  if (a2 && (a2->tv_sec || a2->tv_usec) && select(a1 + 1, &v17, 0, &v17, a2) != 1)
  {
    int v9 = 6;
    goto LABEL_17;
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  if (recv(a1, &v12, 0x30uLL, 0) != 48)
  {
    int v9 = 7;
    goto LABEL_17;
  }
  if (a3) {
    *(void *)((char *)&v18[1] + 12) = a3();
  }
  v11[0] = v12;
  v11[1] = v13;
  int v11[2] = v14;
  sntp_client_process_response((unsigned __int8 *)v11, (unint64_t *)((char *)v18 + 4), (_OWORD *)((char *)&v18[1] + 12), a4);
  return result;
}

unint64_t sntp_client_process_response@<X0>(unsigned __int8 *a1@<X0>, unint64_t *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a2)
  {
    unint64_t v8 = *a2;
    *(void *)(a4 + 4) = *a2;
    unint64_t v9 = HIDWORD(v8);
    if (!a3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  LODWORD(v9) = 0;
  LODWORD(v8) = 0;
  if (a3) {
LABEL_3:
  }
    *(void *)(a4 + 28) = *a3;
LABEL_4:
  long long v10 = *((_OWORD *)a1 + 1);
  v16[0] = *(_OWORD *)a1;
  v16[1] = v10;
  int v16[2] = *((_OWORD *)a1 + 2);
  unint64_t result = sntp_packet_ntoh(v16, (uint64_t)v17);
  long long v12 = v17[1];
  *(_OWORD *)a1 = v17[0];
  *((_OWORD *)a1 + 1) = v12;
  *((_OWORD *)a1 + 2) = v17[2];
  *(_OWORD *)(a4 + 36) = *(_OWORD *)a1;
  *(void *)(a4 + 52) = *((void *)a1 + 2);
  uint64_t v13 = *((void *)a1 + 4);
  uint64_t v14 = *((void *)a1 + 5);
  *(void *)(a4 + 12) = v13;
  *(void *)(a4 + 20) = v14;
  if (*a1 <= 0xBFu)
  {
    if (a1[1])
    {
      if (__ROR8__(v14, 32) >= __ROR8__(v13, 32))
      {
        if (a2)
        {
          if (*((_DWORD *)a1 + 6) != v8 || *((_DWORD *)a1 + 7) != v9)
          {
            int v15 = 10;
            goto LABEL_19;
          }
          if (a3)
          {
            unint64_t result = sntp_calc_delay(a4);
            if ((result & 0x8000000000000000) != 0)
            {
              int v15 = 11;
              goto LABEL_19;
            }
          }
        }
        int v15 = 0;
      }
      else
      {
        int v15 = 12;
      }
    }
    else
    {
      int v15 = 8;
    }
  }
  else
  {
    int v15 = 9;
  }
LABEL_19:
  *(_DWORD *)a4 = v15;
  return result;
}

void figObjectDependencyDeathDefaultCallback_cold_1()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "void soft_FigAudioSessionTriggerAVAudioSessionReset(pid_t)"), @"FigMediaServicesProcessDeathMonitoringFigOnly.m", 80, @"%s", dlerror());
  __break(1u);
}

void __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke_cold_1(void *a1)
{
  unint64_t v2 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "void *MediaToolboxLibrary(void)"), @"FigMediaServicesProcessDeathMonitoringFigOnly.m", 79, @"%s", *a1);
  __break(1u);
}

void fpm_timerCallback_cold_1()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef getkRTCReportingUserInfoClientName(void)"), @"FigPerformanceMonitor.m", 93, @"%s", dlerror());
  __break(1u);
}

void fpm_timerCallback_cold_2()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef getkRTCReportingSessionInfoClientType(void)"), @"FigPerformanceMonitor.m", 84, @"%s", dlerror());
  __break(1u);
}

void fpm_timerCallback_cold_3()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef getkRTCReportingSessionInfoSessionID(void)"), @"FigPerformanceMonitor.m", 87, @"%s", dlerror());
  __break(1u);
}

void fpm_timerCallback_cold_4()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "CFStringRef getkRTCReportingSessionInfoContainsRealtimeEvents(void)"), @"FigPerformanceMonitor.m", 90, @"%s", dlerror());
  __break(1u);
}

void RTCReportingLibrary_cold_1(void *a1)
{
  unint64_t v2 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "void *RTCReportingLibrary(void)"), @"FigPerformanceMonitor.m", 81, @"%s", *a1);
  __break(1u);
}

void __getRTCReportingClass_block_invoke_cold_1()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "Class getRTCReportingClass(void)_block_invoke"), @"FigPerformanceMonitor.m", 82, @"Unable to find class %s", "RTCReporting");
  __break(1u);
}

void FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1()
{
}

void CMAudioClockCreate_cold_1()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "OSStatus soft_FigAudioSessionClockCreateForSharedAudioSession(CFAllocatorRef, CMAudioClockTimingPreference, CMClockRef *)"), @"CMAudioClock.m", 49, @"%s", dlerror());
  __break(1u);
}

void CMAudioClockCreateForAudioSession_cold_1()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "OSStatus soft_FigAudioSessionClockCreateForAVAudioSession(CFAllocatorRef, AVAudioSession *, CMAudioClockTimingPreference, CMClockRef *)"), @"CMAudioClock.m", 52, @"%s", dlerror());
  __break(1u);
}

void MediaToolboxLibrary_cold_1(void *a1)
{
  unint64_t v2 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "void *MediaToolboxLibrary(void)"), @"CMAudioClock.m", 48, @"%s", *a1);
  __break(1u);
}

void FigUserFaultWithMessage_cold_1(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  int v2 = 134218242;
  uint64_t v3 = a2;
  __int16 v4 = 2112;
  uint64_t v5 = a1;
  _os_log_fault_impl(&dword_18FD29000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "0x%llx - %@", (uint8_t *)&v2, 0x16u);
}

void fig_log_internal_cold_1(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_18FD29000, log, OS_LOG_TYPE_ERROR, "Trying to write to ring buffer while owning ringConfigurationLock for writing. Dropping log.", v1, 2u);
}

void fig_log_internal_cold_2(uint64_t *a1, NSObject *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  int v3 = 134218240;
  uint64_t v4 = v2;
  __int16 v5 = 2048;
  uint64_t v6 = qword_1E9270E78;
  _os_log_error_impl(&dword_18FD29000, a2, OS_LOG_TYPE_ERROR, "Log size (%ld) too long for ring buffer size %zu. Dropping it.", (uint8_t *)&v3, 0x16u);
}

void fig_post_a_symptom_guts_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_18FD29000, a2, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&v2, 0xCu);
}

void sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface_cold_1()
{
}

void sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce_cold_1()
{
  *(_WORD *)uint64_t v0 = 0;
  _os_log_fault_impl(&dword_18FD29000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Detected and patched single-sample video CMSampleBuffer with data buffer but no sample size entry. Video CMSampleBuffers must be created with at least one sampleSizeArray entry.", v0, 2u);
}

void FigXPCServerSelfTerminateDueToError_cold_1(char **a1, uint64_t a2, int a3)
{
  *a1 = 0;
  asprintf(a1, "****** Self-terminating due to fatal error %d on server %s", a3, *(const char **)(a2 + 88));
  uint64_t v4 = *a1;
  getpid();
  FigRPCServer_TimeoutCrashReport(0, v4);
  abort();
}

uint64_t APFSCaptureCreatePreallocFile()
{
  return MEMORY[0x1F4105348]();
}

uint64_t APFSCaptureDeletePreallocFile()
{
  return MEMORY[0x1F4105350]();
}

uint64_t APFSCaptureExtendPreallocSizeForFile()
{
  return MEMORY[0x1F4105358]();
}

uint64_t APFSCaptureFinishCaptureForFile()
{
  return MEMORY[0x1F4105360]();
}

uint64_t APFSCaptureStartCaptureInFile()
{
  return MEMORY[0x1F4105368]();
}

uint64_t AnalyticsSendEvent()
{
  return MEMORY[0x1F41138A0]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1F41138B8]();
}

OSStatus AudioDeviceGetCurrentTime(AudioObjectID inDevice, AudioTimeStamp *outTime)
{
  return MEMORY[0x1F40D6F98](*(void *)&inDevice, outTime);
}

OSStatus AudioObjectAddPropertyListener(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, AudioObjectPropertyListenerProc inListener, void *inClientData)
{
  return MEMORY[0x1F40D6FE0](*(void *)&inObjectID, inAddress, inListener, inClientData);
}

OSStatus AudioObjectGetPropertyData(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, UInt32 inQualifierDataSize, const void *inQualifierData, UInt32 *ioDataSize, void *outData)
{
  return MEMORY[0x1F40D6FF8](*(void *)&inObjectID, inAddress, *(void *)&inQualifierDataSize, inQualifierData, ioDataSize, outData);
}

OSStatus AudioObjectGetPropertyDataSize(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, UInt32 inQualifierDataSize, const void *inQualifierData, UInt32 *outDataSize)
{
  return MEMORY[0x1F40D7000](*(void *)&inObjectID, inAddress, *(void *)&inQualifierDataSize, inQualifierData, outDataSize);
}

Boolean AudioObjectHasProperty(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress)
{
  return MEMORY[0x1F40D7008](*(void *)&inObjectID, inAddress);
}

OSStatus AudioObjectRemovePropertyListener(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, AudioObjectPropertyListenerProc inListener, void *inClientData)
{
  return MEMORY[0x1F40D7018](*(void *)&inObjectID, inAddress, inListener, inClientData);
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9718](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9720](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9728](c, data, *(void *)&len);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1F40C9730](data, *(void *)&len, md);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x1F40C9738](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x1F40C9740](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9748](c, data, *(void *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1F40D70E8](allocator, size, hint);
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return (CFAllocatorRef)MEMORY[0x1F40D70F8](allocator, context);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
}

void CFAllocatorGetContext(CFAllocatorRef allocator, CFAllocatorContext *context)
{
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7110]();
}

CFTypeID CFAllocatorGetTypeID(void)
{
  return MEMORY[0x1F40D7120]();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

CFIndex CFArrayBSearchValues(CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  return MEMORY[0x1F40D7158](theArray, range.location, range.length, value, comparator, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D7160](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71C8](theArray, range.location, range.length, value);
}

CFIndex CFArrayGetLastIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71D0](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1F40D7250](alloc, maxLength);
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  return (CFTypeRef)MEMORY[0x1F40D7278](aStr, loc, attrName, inRange.location, inRange.length, longestEffectiveRange);
}

CFDictionaryRef CFAttributedStringGetAttributes(CFAttributedStringRef aStr, CFIndex loc, CFRange *effectiveRange)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7280](aStr, loc, effectiveRange);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x1F40D7298](aStr);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  return (CFStringRef)MEMORY[0x1F40D72A0](aStr);
}

void CFAttributedStringRemoveAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName)
{
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
}

void CFBagAddValue(CFMutableBagRef theBag, const void *value)
{
}

CFMutableBagRef CFBagCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFBagCallBacks *callBacks)
{
  return (CFMutableBagRef)MEMORY[0x1F40D7308](allocator, capacity, callBacks);
}

CFIndex CFBagGetCountOfValue(CFBagRef theBag, const void *value)
{
  return MEMORY[0x1F40D7320](theBag, value);
}

void CFBagRemoveValue(CFMutableBagRef theBag, const void *value)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7450](bundle);
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7470](bundle);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7490](locArray, prefArray);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1F40D74D0](bundle, resourceName, resourceType, subDirName);
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7500](bundle);
}

CFArrayRef CFBundleCreateBundlesFromDirectory(CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  return (CFArrayRef)MEMORY[0x1F40D7530](allocator, directoryURL, bundleType);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1F40D7538](bundleID);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  return (void *)MEMORY[0x1F40D7558](bundle, functionName);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1F40D7598]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40D75D0](bundle, key);
}

Boolean CFBundleIsExecutableLoaded(CFBundleRef bundle)
{
  return MEMORY[0x1F40D75E0](bundle);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1F40D7678](calendar, at, componentDesc);
}

CFTimeZoneRef CFCalendarCopyTimeZone(CFCalendarRef calendar)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D7688](calendar);
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)MEMORY[0x1F40D7690](allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t v3 = va_arg(va, void);
  return MEMORY[0x1F40D7698](calendar, v3, at);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7740](theSetIdentifier);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1F40D77F8](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7810](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1F40D78B0](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return (CFStringRef)MEMORY[0x1F40D78E0](allocator, formatter, date);
}

Boolean CFDateFormatterGetAbsoluteTimeFromString(CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep, CFAbsoluteTime *atp)
{
  return MEMORY[0x1F40D78E8](formatter, string, rangep, atp);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  MEMORY[0x1F40D7928](theDate);
  return result;
}

CFTimeInterval CFDateGetTimeIntervalSinceDate(CFDateRef theDate, CFDateRef otherDate)
{
  MEMORY[0x1F40D7930](theDate, otherDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1F40D7938]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

Boolean CFDictionaryContainsValue(CFDictionaryRef theDict, const void *value)
{
  return MEMORY[0x1F40D7970](theDict, value);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D79C8](theDict, key);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1F40D7A18](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFStringRef CFErrorCopyFailureReason(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A88](err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7A90](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1F40D7A98](allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1F40D7AA8](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1F40D7AB8](err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return MEMORY[0x1F40D7AC0]();
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7B60](cf);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B68](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

uint64_t CFHashBytes()
{
  return MEMORY[0x1F40D7BA8]();
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BB8]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BE0](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(CFAllocatorRef allocator, LangCode lcode, RegionCode rcode)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7BF0](allocator, lcode, rcode);
}

uint64_t CFLog()
{
  return MEMORY[0x1F40D7C50]();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D20]();
}

CFTypeID CFNotificationCenterGetTypeID(void)
{
  return MEMORY[0x1F40D7D28]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1F40D7D68]();
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1F40D7D78](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return (CFNumberFormatterRef)MEMORY[0x1F40D7D98](allocator, locale, style);
}

Boolean CFNumberFormatterGetValueFromString(CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFNumberType numberType, void *valuePtr)
{
  return MEMORY[0x1F40D7DD8](formatter, string, rangep, numberType, valuePtr);
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return MEMORY[0x1F40D7DF8](number);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E08](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)MEMORY[0x1F40D7EB8](applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7ED0](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE0](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE8](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1F40D7F10](applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D7F18](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F28](allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B0]();
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRun(void)
{
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x1F40D8128](mode, returnAfterSourceHandled, seconds);
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1F40D8180](allocator, flags, order, callout, context, fireDate, interval);
}

CFTimeInterval CFRunLoopTimerGetInterval(CFRunLoopTimerRef timer)
{
  MEMORY[0x1F40D81A0](timer);
  return result;
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
}

Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer)
{
  return MEMORY[0x1F40D81C8](timer);
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1F40D8200](allocator, values, numValues, callBacks);
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  return (CFSetRef)MEMORY[0x1F40D8208](allocator, theSet);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8218](allocator, capacity, theSet);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return MEMORY[0x1F40D8230]();
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  return (const void *)MEMORY[0x1F40D8238](theSet, value);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
}

void CFShow(CFTypeRef obj)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

void CFStringAppendFormatAndArguments(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8390](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFStringEncoding CFStringConvertNSStringEncodingToEncoding(unint64_t encoding)
{
  return MEMORY[0x1F40D83C0](encoding);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1F40D83F8](alloc, theString, *(void *)&encoding, lossByte);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8400](alloc, data, *(void *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8440](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8458](alloc, cStr, *(void *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1F40D8498](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D84A0](alloc, pStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.size_t length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D84D0](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84D8](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x1F40D8548](str);
  return result;
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8558](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1F40D8568](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

Boolean CFStringGetPascalString(CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D85C0](theString, buffer, bufferSize, *(void *)&encoding);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1F40D85E0]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1F40D8608](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D86F8]();
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D8708](allocator, ti);
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  return MEMORY[0x1F40D8728](anURL);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8768](anURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8790](anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8798](url);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1F40D87B0](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87C0](anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyAppendingPathExtension(CFAllocatorRef allocator, CFURLRef url, CFStringRef extension)
{
  return (CFURLRef)MEMORY[0x1F40D8800](allocator, url, extension);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8808](allocator, url);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D8848](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8870](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(void *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding(CFAllocatorRef allocator, CFStringRef origString, CFStringRef charsToLeaveEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8880](allocator, origString, charsToLeaveEscaped, *(void *)&encoding);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8918](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return MEMORY[0x1F40D8938](anURL);
}

Boolean CFURLStartAccessingSecurityScopedResource(CFURLRef url)
{
  return MEMORY[0x1F40D8968](url);
}

void CFURLStopAccessingSecurityScopedResource(CFURLRef url)
{
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1F40D8988](alloc);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1F40D8998](alloc, uuidStr);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1F40D89A0](alloc, *(void *)&bytes.byte0, *(void *)&bytes.byte8);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1F40D89B0](alloc, uuid);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1F40D89D0](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1 = MEMORY[0x1F40D89E8](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x1F40D9970](space, components);
}

BOOL CGColorEqualToColor(CGColorRef color1, CGColorRef color2)
{
  return MEMORY[0x1F40D99D0](color1, color2);
}

CGColorSpaceRef CGColorGetColorSpace(CGColorRef color)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D99F8](color);
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  return (const CGFloat *)MEMORY[0x1F40D9A00](color);
}

size_t CGColorGetNumberOfComponents(CGColorRef color)
{
  return MEMORY[0x1F40D9A18](color);
}

CFTypeID CGColorGetTypeID(void)
{
  return MEMORY[0x1F40D9A30]();
}

void CGColorRelease(CGColorRef color)
{
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x1F40D9A60](color);
}

CFPropertyListRef CGColorSpaceCopyPropertyList(CGColorSpaceRef space)
{
  return (CFPropertyListRef)MEMORY[0x1F40D9AC0](space);
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9B60](name);
}

CGColorSpaceRef CGColorSpaceCreateWithPropertyList(CFPropertyListRef plist)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9B70](plist);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x1F40D9BE0](space);
}

CFTypeID CGColorSpaceGetTypeID(void)
{
  return MEMORY[0x1F40D9C10]();
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
}

CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point)
{
  return (CFDictionaryRef)MEMORY[0x1F40DB200]((__n128)point, *(__n128 *)&point.y);
}

BOOL CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point)
{
  return MEMORY[0x1F40DB210](dict, point);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x1F40DB238]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  MEMORY[0x1F40DB250]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  MEMORY[0x1F40DB268]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  MEMORY[0x1F40DB270]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  MEMORY[0x1F40DB298]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  MEMORY[0x1F40DB2A0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  MEMORY[0x1F40DB2A8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x1F40DB2F0](dict, rect);
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  MEMORY[0x1F40DB2F8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.double height = v6;
  result.size.double width = v5;
  result.origin.double y = v4;
  result.origin.double x = v3;
  return result;
}

CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size)
{
  return (CFDictionaryRef)MEMORY[0x1F40DB4C8]((__n128)size, *(__n128 *)&size.height);
}

BOOL CGSizeMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGSize *size)
{
  return MEMORY[0x1F40DB4E0](dict, size);
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1F40DFB48](buffer, key, attachmentMode);
}

CFDictionaryRef CVBufferCopyAttachments(CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return (CFDictionaryRef)MEMORY[0x1F40DFB50](buffer, *(void *)&attachmentMode);
}

CFTypeRef CVBufferGetAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1F40DFB58](buffer, key, attachmentMode);
}

void CVBufferRemoveAllAttachments(CVBufferRef buffer)
{
}

void CVBufferRemoveAttachment(CVBufferRef buffer, CFStringRef key)
{
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
}

void CVBufferSetAttachments(CVBufferRef buffer, CFDictionaryRef theAttachments, CVAttachmentMode attachmentMode)
{
}

int CVColorPrimariesGetIntegerCodePointForString(CFStringRef colorPrimariesString)
{
  return MEMORY[0x1F40DFBA8](colorPrimariesString);
}

CFStringRef CVColorPrimariesGetStringForIntegerCodePoint(int colorPrimariesCodePoint)
{
  return (CFStringRef)MEMORY[0x1F40DFBB0](*(void *)&colorPrimariesCodePoint);
}

uint64_t CVDataBufferCreateWithIOSurface()
{
  return MEMORY[0x1F40DFBC0]();
}

uint64_t CVDataBufferGetDataSize()
{
  return MEMORY[0x1F40DFBD0]();
}

uint64_t CVDataBufferGetIOSurface()
{
  return MEMORY[0x1F40DFBD8]();
}

uint64_t CVDataBufferGetPixelFormatType()
{
  return MEMORY[0x1F40DFBE0]();
}

uint64_t CVDataBufferGetTypeID()
{
  return MEMORY[0x1F40DFBE8]();
}

CGSize CVImageBufferGetEncodedSize(CVImageBufferRef imageBuffer)
{
  MEMORY[0x1F40DFC38](imageBuffer);
  result.double height = v2;
  result.double width = v1;
  return result;
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFCE0](allocator, width, height, *(void *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

uint64_t CVPixelBufferCreateWithBufferBacking()
{
  return MEMORY[0x1F40DFCF8]();
}

CVReturn CVPixelBufferCreateWithBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *baseAddress, size_t bytesPerRow, CVPixelBufferReleaseBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFD00](allocator, width, height, *(void *)&pixelFormatType, baseAddress, bytesPerRow, releaseCallback, releaseRefCon);
}

CVReturn CVPixelBufferCreateWithIOSurface(CFAllocatorRef allocator, IOSurfaceRef surface, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFD08](allocator, surface, pixelBufferAttributes, pixelBufferOut);
}

CVReturn CVPixelBufferCreateWithPlanarBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *dataPtr, size_t dataSize, size_t numberOfPlanes, void **planeBaseAddress, size_t *planeWidth, size_t *planeHeight, size_t *planeBytesPerRow, CVPixelBufferReleasePlanarBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFD10](allocator, width, height, *(void *)&pixelFormatType, dataPtr, dataSize, numberOfPlanes, planeBaseAddress);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x1F40DFD28](pixelBuffer);
}

uint64_t CVPixelBufferGetBufferBacking()
{
  return MEMORY[0x1F40DFD38]();
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD40](pixelBuffer);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD50](pixelBuffer);
}

void CVPixelBufferGetExtendedPixels(CVPixelBufferRef pixelBuffer, size_t *extraColumnsOnLeft, size_t *extraColumnsOnRight, size_t *extraRowsOnTop, size_t *extraRowsOnBottom)
{
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD68](pixelBuffer);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x1F40DFD78](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD80](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD88](pixelBuffer);
}

CFTypeID CVPixelBufferGetTypeID(void)
{
  return MEMORY[0x1F40DFD90]();
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD98](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x1F40DFDB8](pixelBuffer, lockFlags);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x1F40DFE48](pixelBuffer, unlockFlags);
}

uint64_t CVPixelFormatDescriptionGetDescriptionWithPixelFormatType()
{
  return MEMORY[0x1F40DFE58]();
}

int CVTransferFunctionGetIntegerCodePointForString(CFStringRef transferFunctionString)
{
  return MEMORY[0x1F40DFE78](transferFunctionString);
}

CFStringRef CVTransferFunctionGetStringForIntegerCodePoint(int transferFunctionCodePoint)
{
  return (CFStringRef)MEMORY[0x1F40DFE80](*(void *)&transferFunctionCodePoint);
}

int CVYCbCrMatrixGetIntegerCodePointForString(CFStringRef yCbCrMatrixString)
{
  return MEMORY[0x1F40DFE88](yCbCrMatrixString);
}

CFStringRef CVYCbCrMatrixGetStringForIntegerCodePoint(int yCbCrMatrixCodePoint)
{
  return (CFStringRef)MEMORY[0x1F40DFE90](*(void *)&yCbCrMatrixCodePoint);
}

DNSServiceErrorType DNSServiceGetAddrInfo(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, DNSServiceProtocol protocol, const char *hostname, DNSServiceGetAddrInfoReply callBack, void *context)
{
  return MEMORY[0x1F40C9840](sdRef, *(void *)&flags, *(void *)&interfaceIndex, *(void *)&protocol, hostname, callBack, context);
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
}

DNSServiceErrorType DNSServiceSetDispatchQueue(DNSServiceRef service, dispatch_queue_t queue)
{
  return MEMORY[0x1F40C98B0](service, queue);
}

uint64_t FigCaptureCopySerializableKeys()
{
  return MEMORY[0x1F410D470]();
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  return MEMORY[0x1F40E8748](*(void *)&service, pluginType, interfaceType, theInterface, theScore);
}

kern_return_t IODestroyPlugInInterface(IOCFPlugInInterface **interface)
{
  return MEMORY[0x1F40E8780](interface);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1F40E8ED8](*(void *)&iterator);
}

kern_return_t IOMainPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  return MEMORY[0x1F40E8EF0](*(void *)&bootstrapPort, mainPort);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x1F40E8F08](*(void *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40E8F20](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x1F40E8F38](*(void *)&object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1F40E8F60](*(void *)&object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return MEMORY[0x1F40E8F68](*(void *)&object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1F40E9168](*(void *)&entry, key, allocator, *(void *)&options);
}

kern_return_t IORegistryEntryGetChildIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return MEMORY[0x1F40E9190](*(void *)&entry, plane, iterator);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return MEMORY[0x1F40E91C8](*(void *)&entry, plane, parent);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x1F40E9230](notifyPort, *(void *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x1F40E9238](notifyPort, notificationType, matching, callback, refCon, notification);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1F40E9250](*(void *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40E9268](name);
}

mach_port_t IOSurfaceCreateMachPort(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9318](buffer);
}

xpc_object_t IOSurfaceCreateXPCObject(IOSurfaceRef aSurface)
{
  return (xpc_object_t)MEMORY[0x1F40E9328](aSurface);
}

void IOSurfaceDecrementUseCount(IOSurfaceRef buffer)
{
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9350](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1F40E9358](buffer);
}

IOSurfaceID IOSurfaceGetID(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9460](buffer);
}

uint64_t IOSurfaceGetProhibitUseCount()
{
  return MEMORY[0x1F40E9490]();
}

void IOSurfaceIncrementUseCount(IOSurfaceRef buffer)
{
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9540](buffer, *(void *)&options, seed);
}

IOSurfaceRef IOSurfaceLookup(IOSurfaceID csid)
{
  return (IOSurfaceRef)MEMORY[0x1F40E9550](*(void *)&csid);
}

IOSurfaceRef IOSurfaceLookupFromMachPort(mach_port_t port)
{
  return (IOSurfaceRef)MEMORY[0x1F40E9558](*(void *)&port);
}

IOSurfaceRef IOSurfaceLookupFromXPCObject(xpc_object_t xobj)
{
  return (IOSurfaceRef)MEMORY[0x1F40E9560](xobj);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9630](buffer, *(void *)&options, seed);
}

uint64_t IOUSBDeviceDataGetBytePtr()
{
  return MEMORY[0x1F40E9288]();
}

uint64_t LogACQEvents()
{
  return MEMORY[0x1F410B768]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1F417CDE0]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1F417CE00]();
}

uint64_t MGGetProductType()
{
  return MEMORY[0x1F417CE18]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1F417CE28]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1F40E7010](aClassName);
}

uint64_t NSErrorToOSStatus()
{
  return MEMORY[0x1F4116790]();
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return (CFDataRef)MEMORY[0x1F40F6AD0](certificate);
}

CFTypeID SecCertificateGetTypeID(void)
{
  return MEMORY[0x1F40F6BB8]();
}

OSStatus SecCodeCopyPath(SecStaticCodeRef staticCode, SecCSFlags flags, CFURLRef *path)
{
  return MEMORY[0x1F40F6D40](staticCode, *(void *)&flags, path);
}

OSStatus SecCodeCopySigningInformation(SecStaticCodeRef code, SecCSFlags flags, CFDictionaryRef *information)
{
  return MEMORY[0x1F40F6D48](code, *(void *)&flags, information);
}

OSStatus SecRequirementCreateWithStringAndErrors(CFStringRef text, SecCSFlags flags, CFErrorRef *errors, SecRequirementRef *requirement)
{
  return MEMORY[0x1F40F7100](text, *(void *)&flags, errors, requirement);
}

OSStatus SecStaticCodeCheckValidityWithErrors(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  return MEMORY[0x1F40F7118](staticCode, *(void *)&flags, requirement, errors);
}

OSStatus SecStaticCodeCreateWithPath(CFURLRef path, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  return MEMORY[0x1F40F7120](path, *(void *)&flags, staticCode);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1F40F7138](task, entitlement, error);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeGetClassWithTypeID()
{
  return MEMORY[0x1F40D90D8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

uint64_t _CFTryRetain()
{
  return MEMORY[0x1F40D91E0]();
}

uint64_t _CFURLIsFileURL()
{
  return MEMORY[0x1F40D9348]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x1F40D9438]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x1F40D9450]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1F40C9B68](*(void *)&a1, a2, *(void *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1F40C9CD0]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

uint64_t __strncat_chk()
{
  return MEMORY[0x1F40C9CE0]();
}

uint64_t __strncpy_chk()
{
  return MEMORY[0x1F40C9CE8]();
}

uint64_t __udivti3()
{
  return MEMORY[0x1F40C9D08]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1F40C9FF8]();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

void abort(void)
{
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CA200](*(void *)&a1, a2, a3);
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1F40CA210](a1, *(void *)&a2);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1F40CA3A8]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1F40CA3C0](*(void *)&__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

uint64_t audiomxd_enabled()
{
  return MEMORY[0x1F410BC68]();
}

void audit_token_to_au32(audit_token_t *atoken, uid_t *auidp, uid_t *euidp, gid_t *egidp, uid_t *ruidp, gid_t *rgidp, pid_t *pidp, au_asid_t *asidp, au_tid_t *tidp)
{
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1F40CA4F8](a1, *(void *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1F40CA508](a1, *(void *)&a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1F40CA530](*(void *)&a1, a2, *(void *)&a3);
}

kern_return_t bootstrap_check_in(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1F40CA538](*(void *)&bp, service_name, sp);
}

kern_return_t bootstrap_look_up(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1F40CA548](*(void *)&bp, service_name, sp);
}

void bzero(void *a1, size_t a2)
{
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1F40CB3D0](*(void *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CB438](*(void *)&a1, a2, a3);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1F40CB440](*(void *)&a1, a2, *(void *)&a3);
}

char *__cdecl ctime(const time_t *a1)
{
  return (char *)MEMORY[0x1F40CB8E0](a1);
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x1F4182BD0](strm, *(void *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x1F4182BE0](strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return MEMORY[0x1F4182BE8](strm, *(void *)&level, *(void *)&method, *(void *)&windowBits, *(void *)&memLevel, *(void *)&strategy, version, *(void *)&stream_size);
}

int deflateInit_(z_streamp strm, int level, const char *version, int stream_size)
{
  return MEMORY[0x1F4182BF0](strm, *(void *)&level, version, *(void *)&stream_size);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_barrier_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C0](flags, block);
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CB9F8](block, timeout);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1F40CBA10](buffer, size, queue, destructor);
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return (void *)MEMORY[0x1F40CBA50](object);
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBA58]();
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x1F40CBA68](key);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

uint64_t dispatch_mach_cancel()
{
  return MEMORY[0x1F40CBB38]();
}

uint64_t dispatch_mach_connect()
{
  return MEMORY[0x1F40CBB40]();
}

uint64_t dispatch_mach_create()
{
  return MEMORY[0x1F40CBB48]();
}

uint64_t dispatch_mach_mig_demux()
{
  return MEMORY[0x1F40CBB58]();
}

uint64_t dispatch_mach_msg_get_msg()
{
  return MEMORY[0x1F40CBB68]();
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

uint64_t dispatch_pthread_root_queue_create()
{
  return MEMORY[0x1F40CBB98]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA0](attr);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

uint64_t dispatch_queue_attr_make_with_overcommit()
{
  return MEMORY[0x1F40CBBB0]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1F40CBBD8](queue);
}

void *__cdecl dispatch_queue_get_specific(dispatch_queue_t queue, const void *key)
{
  return (void *)MEMORY[0x1F40CBBE8](queue, key);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
}

uint64_t dispatch_set_qos_class_fallback()
{
  return MEMORY[0x1F40CBC70]();
}

void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
{
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

uintptr_t dispatch_source_get_handle(dispatch_source_t source)
{
  return MEMORY[0x1F40CBCA8](source);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return MEMORY[0x1F40CBCF8](source);
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1F40CBD58](label);
}

uint64_t dispatch_workloop_set_scheduler_priority()
{
  return MEMORY[0x1F40CBD88]();
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1F40CBDA0](a1, a2);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

void exit(int a1)
{
}

long double exp(long double __x)
{
  MEMORY[0x1F40CBFE0](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

int feof(FILE *a1)
{
  return MEMORY[0x1F40CC098](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1F40CC110](a1);
}

int flock(int a1, int a2)
{
  return MEMORY[0x1F40CC160](*(void *)&a1, *(void *)&a2);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x1F40CC1A0](__x, __y);
  return result;
}

const char *__cdecl fmtcheck(const char *a1, const char *a2)
{
  return (const char *)MEMORY[0x1F40CC1B0](a1, a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC200](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

void freeaddrinfo(addrinfo *a1)
{
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1F40CC288](a1, a2, a3, *(void *)&a4);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x1F40CC2D8](*(void *)&a1);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1F40CC2E0](a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1F40CC2F0](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x1F40CC348](a1, a2, a3, a4);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1F40CC360](a1, a2, a3, a4, *(void *)&a5);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

int getiopolicy_np(int a1, int a2)
{
  return MEMORY[0x1F40CC418](*(void *)&a1, *(void *)&a2);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x1F40CC4F0](*(void *)&a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1F40CC568](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

uint64_t in_audio_mx_server_process()
{
  return MEMORY[0x1F410BC98]();
}

in_addr_t inet_addr(const char *a1)
{
  return MEMORY[0x1F40CC660](a1);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x1F4182CB0](strm, *(void *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x1F4182CB8](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x1F4182CC8](strm, *(void *)&windowBits, version, *(void *)&stream_size);
}

int inflateInit_(z_streamp strm, const char *version, int stream_size)
{
  return MEMORY[0x1F4182CD8](strm, version, *(void *)&stream_size);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1F40CC700]();
}

int kill(pid_t a1, int a2)
{
  return MEMORY[0x1F40CC728](*(void *)&a1, *(void *)&a2);
}

int listen(int a1, int a2)
{
  return MEMORY[0x1F40CC840](*(void *)&a1, *(void *)&a2);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1F40CC868](a1);
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x1F40CC8A8](__x);
  return result;
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CC900](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x1F40CC930]();
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1F40CC970](msg, *(void *)&option, *(void *)&send_size, *(void *)&rcv_size, *(void *)&rcv_name, *(void *)&timeout, *(void *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1F40CC9A0](*(void *)&task, *(void *)&right, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1F40CC9B8](*(void *)&task, *(void *)&name);
}

kern_return_t mach_port_get_attributes(ipc_space_read_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1F40CC9E0](*(void *)&task, *(void *)&name, *(void *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1F40CCA08](*(void *)&task, *(void *)&name, *(void *)&poly, *(void *)&polyPoly);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x1F40CCA10](*(void *)&task, *(void *)&name, *(void *)&right, *(void *)&delta);
}

kern_return_t mach_port_set_attributes(ipc_space_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info, mach_msg_type_number_t port_infoCnt)
{
  return MEMORY[0x1F40CCA30](*(void *)&task, *(void *)&name, *(void *)&flavor, port_info, *(void *)&port_infoCnt);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return (malloc_zone_t *)MEMORY[0x1F40CCB20](start_size, *(void *)&flags);
}

malloc_zone_t *malloc_default_zone(void)
{
  return (malloc_zone_t *)MEMORY[0x1F40CCB30]();
}

const char *__cdecl malloc_get_zone_name(malloc_zone_t *zone)
{
  return (const char *)MEMORY[0x1F40CCB50](zone);
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBB8](zone, count, size, type_id);
}

void *__cdecl malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBD8](zone, ptr, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
}

mach_port_t mig_get_reply_port(void)
{
  return MEMORY[0x1F40CCD70]();
}

void mig_put_reply_port(mach_port_t reply_port)
{
}

int mig_strncpy(char *dest, const char *src, int len)
{
  return MEMORY[0x1F40CCD90](dest, src, *(void *)&len);
}

int mig_strncpy_zerofill(char *dest, const char *src, int len)
{
  return MEMORY[0x1F40CCD98](dest, src, *(void *)&len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1F40CCDD0](a1, a2);
}

char *__cdecl mkdtemp(char *a1)
{
  return (char *)MEMORY[0x1F40CCDE0](a1);
}

int mkstemp(char *a1)
{
  return MEMORY[0x1F40CCE08](a1);
}

int mkstemps(char *a1, int a2)
{
  return MEMORY[0x1F40CCE18](a1, *(void *)&a2);
}

long double modf(long double __x, long double *__y)
{
  MEMORY[0x1F40CCE48](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1F40CD050](name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x1F4181718](object, key);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1F4181778](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F4181798](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

uint64_t os_eventlink_activate()
{
  return MEMORY[0x1F40CD2D0]();
}

uint64_t os_eventlink_associate()
{
  return MEMORY[0x1F40CD2D8]();
}

uint64_t os_eventlink_cancel()
{
  return MEMORY[0x1F40CD2E0]();
}

uint64_t os_eventlink_create()
{
  return MEMORY[0x1F40CD2E8]();
}

uint64_t os_eventlink_create_with_port()
{
  return MEMORY[0x1F40CD2F0]();
}

uint64_t os_eventlink_extract_remote_port()
{
  return MEMORY[0x1F40CD2F8]();
}

uint64_t os_eventlink_signal()
{
  return MEMORY[0x1F40CD300]();
}

uint64_t os_eventlink_signal_and_wait()
{
  return MEMORY[0x1F40CD308]();
}

uint64_t os_eventlink_wait()
{
  return MEMORY[0x1F40CD318]();
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

uint64_t os_log_pack_compose()
{
  return MEMORY[0x1F40CD370]();
}

uint64_t os_log_pack_send()
{
  return MEMORY[0x1F40CD378]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

uint64_t os_log_with_args()
{
  return MEMORY[0x1F40CD3C8]();
}

void os_release(void *object)
{
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1F40CD558](log);
}

uint64_t os_state_add_handler()
{
  return MEMORY[0x1F40CD570]();
}

uint64_t os_transaction_copy_description()
{
  return MEMORY[0x1F40CD598]();
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1F40CD5A0]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1F40CD650]();
}

int pipe(int a1[2])
{
  return MEMORY[0x1F40CD760](a1);
}

int poll(pollfd *a1, nfds_t a2, int a3)
{
  return MEMORY[0x1F40CD770](a1, *(void *)&a2, *(void *)&a3);
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CD830](*(void *)&__fd, __buf, __nbyte, a4);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1F40CD888](*(void *)&pid, buffer, *(void *)&buffersize);
}

int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
{
  return MEMORY[0x1F40CD890](*(void *)&pid, *(void *)&flavor, buffer);
}

uint64_t proc_pidbind()
{
  return MEMORY[0x1F40CD898]();
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x1F40CD8A8](*(void *)&pid, *(void *)&flavor, arg, buffer, *(void *)&buffersize);
}

uint64_t proc_pidoriginatorinfo()
{
  return MEMORY[0x1F40CD8B0]();
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD918](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x1F40CD920](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD930](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x1F40CD938](__attr, *(void *)&__qos_class, *(void *)&__relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD940](a1, *(void *)&a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x1F40CD950](a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD958](a1, *(void *)&a2);
}

int pthread_attr_setstacksize(pthread_attr_t *a1, size_t a2)
{
  return MEMORY[0x1F40CD968](a1, a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x1F40CD978](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1F40CD980](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1F40CD988](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x1F40CD990](a1);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x1F40CD998](a1, a2, a3);
}

int pthread_cond_timedwait_relative_np(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x1F40CD9A0](a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1F40CD9A8](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

void pthread_exit(void *a1)
{
}

int pthread_get_qos_class_np(pthread_t __pthread, qos_class_t *__qos_class, int *__relative_priority)
{
  return MEMORY[0x1F40CD9F8](__pthread, __qos_class, __relative_priority);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1F40CDA20](a1);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x1F40CDA38](a1, a2);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1F40CDA40](a1, a2);
}

int pthread_kill(pthread_t a1, int a2)
{
  return MEMORY[0x1F40CDA58](a1, *(void *)&a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1F40CDA60](a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA78](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA90](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA0](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA8](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1F40CDAC0](a1, *(void *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1F40CDB60](a1);
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1F40CDB70](a1, a2);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return MEMORY[0x1F40CDB90](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1F40CDBB8](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CDBC0](*(void *)&__fd, __buf, __nbyte, a4);
}

ssize_t pwritev(int a1, const iovec *a2, int a3, off_t a4)
{
  return MEMORY[0x1F40CDBC8](*(void *)&a1, a2, *(void *)&a3, a4);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1F40CDBD8]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CDC70](a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CDC98](a1, a2);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x1F40CDCB8](*(void *)&a1, a2, a3, *(void *)&a4);
}

int removefile(const char *path, removefile_state_t state, removefile_flags_t flags)
{
  return MEMORY[0x1F40CDD18](path, state, *(void *)&flags);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

uint64_t sandbox_check_by_audit_token()
{
  return MEMORY[0x1F40CDDD8]();
}

uint64_t sandbox_container_path_for_pid()
{
  return MEMORY[0x1F40CDDE8]();
}

uint64_t sandbox_extension_consume()
{
  return MEMORY[0x1F40CDDF8]();
}

uint64_t sandbox_extension_issue_file()
{
  return MEMORY[0x1F40CDE00]();
}

uint64_t sandbox_extension_issue_file_to_self()
{
  return MEMORY[0x1F40CDE18]();
}

uint64_t sandbox_extension_release()
{
  return MEMORY[0x1F40CDE50]();
}

int sched_yield(void)
{
  return MEMORY[0x1F40CDEC8]();
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x1F4181B48](str);
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return MEMORY[0x1F40CDED8](*(void *)&a1, a2, a3, a4, a5);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x1F40CDF30](*(void *)&a1, a2, a3, *(void *)&a4);
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return MEMORY[0x1F40CDF60](__name, __value, *(void *)&__overwrite);
}

int setiopolicy_np(int a1, int a2, int a3)
{
  return MEMORY[0x1F40CDF78](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1F40CDFC0](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, *(void *)&a5);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  return MEMORY[0x1F40CDFD0](a1, a2, *(void *)&a3, a4);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return (void (__cdecl *)(int))MEMORY[0x1F40CE030](*(void *)&a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1F40CE078](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1F40CE090](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1F40CE198](a1, a2, a3, a4);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1F40CE1D8](a1, a2, a3);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1E8](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return (char *)MEMORY[0x1F40CE200](__s1, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1F40CE208](__s1, __n);
}

char *__cdecl strptime(const char *a1, const char *a2, tm *a3)
{
  return (char *)MEMORY[0x1F40CE220](a1, a2, a3);
}

int symlink(const char *a1, const char *a2)
{
  return MEMORY[0x1F40CE360](a1, a2);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1F40CE3C0](a1, *(void *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1F40CE3D0](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

kern_return_t thread_info(thread_inspect_t target_act, thread_flavor_t flavor, thread_info_t thread_info_out, mach_msg_type_number_t *thread_info_outCnt)
{
  return MEMORY[0x1F40CE530](*(void *)&target_act, *(void *)&flavor, thread_info_out, thread_info_outCnt);
}

kern_return_t thread_policy_get(thread_inspect_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t *policy_infoCnt, BOOLean_t *get_default)
{
  return MEMORY[0x1F40CE538](*(void *)&thread, *(void *)&flavor, policy_info, policy_infoCnt, get_default);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return MEMORY[0x1F40CE540](*(void *)&thread, *(void *)&flavor, policy_info, *(void *)&policy_infoCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

int unsetenv(const char *a1)
{
  return MEMORY[0x1F40CE5F8](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1F40CE608](*(void *)&a1);
}

void uuid_clear(uuid_t uu)
{
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x1F40CE630](uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
{
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1F40CE6A8](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1F40CE6C0](*(void *)&target_task, address, size);
}

uint64_t voucher_adopt()
{
  return MEMORY[0x1F40CE708]();
}

uint64_t voucher_copy()
{
  return MEMORY[0x1F40CE710]();
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  return MEMORY[0x1F40CE758](msg);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}

uint64_t wd_endpoint_activate()
{
  return MEMORY[0x1F41682E0]();
}

uint64_t wd_endpoint_add_queue()
{
  return MEMORY[0x1F41682E8]();
}

uint64_t wd_endpoint_register()
{
  return MEMORY[0x1F41682F0]();
}

uint64_t wd_endpoint_set_alive_func()
{
  return MEMORY[0x1F41682F8]();
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEA30](objects, count);
}

xpc_object_t xpc_array_create_empty(void)
{
  return (xpc_object_t)MEMORY[0x1F40CEA38]();
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1F40CEA58](xarray);
}

const void *__cdecl xpc_array_get_data(xpc_object_t xarray, size_t index, size_t *length)
{
  return (const void *)MEMORY[0x1F40CEA68](xarray, index, length);
}

xpc_object_t xpc_array_get_dictionary(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1F40CEA70](xarray, index);
}

int64_t xpc_array_get_int64(xpc_object_t xarray, size_t index)
{
  return MEMORY[0x1F40CEA80](xarray, index);
}

uint64_t xpc_array_get_uint64(xpc_object_t xarray, size_t index)
{
  return MEMORY[0x1F40CEA98](xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1F40CEAA8](xarray, index);
}

void xpc_array_set_data(xpc_object_t xarray, size_t index, const void *bytes, size_t length)
{
}

void xpc_array_set_int64(xpc_object_t xarray, size_t index, int64_t value)
{
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
}

void xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value)
{
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x1F40CEB18](xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return MEMORY[0x1F40CEB90]();
}

uint64_t xpc_connection_copy_invalidation_reason()
{
  return MEMORY[0x1F40CEB98]();
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBA8](name, targetq);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBC0](endpoint);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBD0](name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return MEMORY[0x1F40CEBE8]();
}

void *__cdecl xpc_connection_get_context(xpc_connection_t connection)
{
  return (void *)MEMORY[0x1F40CEBF8](connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return MEMORY[0x1F40CEC20](connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_barrier(xpc_connection_t connection, dispatch_block_t barrier)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1F40CEC68](connection, message);
}

uint64_t xpc_connection_send_notification()
{
  return MEMORY[0x1F40CEC70]();
}

void xpc_connection_set_context(xpc_connection_t connection, void *context)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_finalizer_f(xpc_connection_t connection, xpc_finalizer_t finalizer)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

uint64_t xpc_connection_set_target_uid()
{
  return MEMORY[0x1F40CECE8]();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1F40CED90](bytes, length);
}

xpc_object_t xpc_data_create_with_dispatch_data(dispatch_data_t ddata)
{
  return (xpc_object_t)MEMORY[0x1F40CEDA0](ddata);
}

size_t xpc_data_get_bytes(xpc_object_t xdata, void *buffer, size_t off, size_t length)
{
  return MEMORY[0x1F40CEDA8](xdata, buffer, off, length);
}

uint64_t xpc_dictionary_copy_mach_send()
{
  return MEMORY[0x1F40CEE18]();
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

xpc_object_t xpc_dictionary_create_empty(void)
{
  return (xpc_object_t)MEMORY[0x1F40CEE30]();
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1F40CEE40](original);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1F40CEE68](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEE80](xdict, key);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1F40CEE98](xdict, key, length);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  MEMORY[0x1F40CEEB8](xdict, key);
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEC8](xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return (xpc_connection_t)MEMORY[0x1F40CEEE0](xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1F40CEEF0](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEF8](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1F40CEF10](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

uint64_t xpc_dictionary_set_mach_send()
{
  return MEMORY[0x1F40CEF98]();
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return (xpc_endpoint_t)MEMORY[0x1F40CF018](connection);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1F40CF248](object);
}

xpc_object_t xpc_shmem_create(void *region, size_t length)
{
  return (xpc_object_t)MEMORY[0x1F40CF268](region, length);
}

size_t xpc_shmem_map(xpc_object_t xshmem, void **region)
{
  return MEMORY[0x1F40CF278](xshmem, region);
}