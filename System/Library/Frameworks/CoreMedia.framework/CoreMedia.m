pthread_mutex_t *FigSimpleMutexCreate()
{
  return FigSimpleMutexCreateWithAttr((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 0);
}

pthread_mutex_t *FigSimpleMutexCreateWithAttr(const __CFAllocator *a1, const pthread_mutexattr_t *a2)
{
  v4 = (pthread_mutex_t *)CFAllocatorAllocate(a1, 72, 0);
  v5 = v4;
  if (v4)
  {
    if (pthread_mutex_init(v4, a2))
    {
      CFAllocatorDeallocate(a1, v5);
      return 0;
    }
    else
    {
      if (a1) {
        CFTypeRef v6 = CFRetain(a1);
      }
      else {
        CFTypeRef v6 = 0;
      }
      v5[1].__sig = (uint64_t)v6;
    }
  }
  return v5;
}

uint64_t FigThreadCreate(uint64_t a1, uint64_t a2, unsigned int a3, int a4, const __CFDictionary *a5, pthread_t *a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = 0;
  pthread_t v32 = 0;
  memset(&__attr, 0, sizeof(__attr));
  if (a3 >= 0x32)
  {
    uint64_t v12 = FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
    int v13 = 0;
    if (!a4) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (a3 != 5)
  {
    int v13 = 0;
    uint64_t v12 = 0;
    if (!a4) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (!FigCFDictionaryGetInt32IfPresent((uint64_t)a5, @"com.apple.fig.ThreadCreateKey_MachThreadPriority", &valuePtr)|| (int)valuePtr <= 0)
  {
    return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v12 = 0;
  int v13 = 1;
  if (a4)
  {
LABEL_10:
    if (!a6) {
      uint64_t v12 = FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
    }
  }
LABEL_12:
  if (!v12)
  {
    uint64_t v14 = pthread_attr_init(&__attr);
    if (v14)
    {
      uint64_t v12 = v14;
LABEL_17:
      FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
      return v12;
    }
    qos_class_t QualityOfServiceClassForFigThreadPriority = FigGetQualityOfServiceClassForFigThreadPriority(a3);
    uint64_t v16 = pthread_attr_set_qos_class_np(&__attr, QualityOfServiceClassForFigThreadPriority, 0);
    if (v16)
    {
      uint64_t v12 = v16;
      FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      goto LABEL_17;
    }
    if (a5)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a5, @"com.apple.fig.ThreadCreateKey_StackSize");
      if (Value)
      {
        CFNumberRef v19 = Value;
        CFTypeID v20 = CFGetTypeID(Value);
        if (v20 == CFNumberGetTypeID()) {
          CFNumberGetValue(v19, kCFNumberSInt32Type, (char *)&valuePtr + 4);
        }
      }
    }
    if (a4) {
      int v21 = 1;
    }
    else {
      int v21 = 2;
    }
    uint64_t v12 = pthread_attr_setdetachstate(&__attr, v21);
    if (v12) {
      goto LABEL_44;
    }
    if (SHIDWORD(valuePtr) > 0x4000)
    {
      uint64_t v12 = pthread_attr_setstacksize(&__attr, HIDWORD(valuePtr));
      if (v12) {
        goto LABEL_44;
      }
    }
    uint64_t v22 = FigThreadLockAbortList();
    if (v22)
    {
      uint64_t v12 = v22;
      goto LABEL_45;
    }
    if (a5 && (v23 = CFDictionaryGetValue(a5, @"com.apple.fig.ThreadCreateKey_Identifier")) != 0)
    {
      v24 = v23;
      CFTypeID v25 = CFGetTypeID(v23);
      if (v25 == CFStringGetTypeID()) {
        v26 = v24;
      }
      else {
        v26 = 0;
      }
    }
    else
    {
      v26 = 0;
    }
    v27 = malloc_type_calloc(1uLL, 0x38uLL, 0x10E00404CF1D47AuLL);
    *(void *)v27 = a1;
    *((void *)v27 + 1) = a2;
    if (v26) {
      *((void *)v27 + 2) = CFRetain(v26);
    }
    *((_DWORD *)v27 + 6) = a3;
    if (a5) {
      *((void *)v27 + 4) = CFRetain(a5);
    }
    *((unsigned char *)v27 + 40) = 1;
    *((void *)v27 + 6) = 0;
    FigCFDictionaryGetBooleanIfPresent((uint64_t)a5, @"com.apple.fig.ThreadCreateKey_AdoptVoucher", (Boolean *)v27 + 40);
    if (*((unsigned char *)v27 + 40)) {
      *((void *)v27 + 6) = voucher_copy();
    }
    uint64_t v28 = pthread_create(&v32, &__attr, (void *(__cdecl *)(void *))figThreadMain, v27);
    if (v28)
    {
      uint64_t v12 = v28;
      FigThreadUnlockAbortList();
LABEL_44:
      FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
LABEL_45:
      pthread_attr_destroy(&__attr);
      return v12;
    }
    if (a3 == 16)
    {
      figSetPThreadBackground(v32, 1);
    }
    else
    {
      int v29 = valuePtr;
      if (valuePtr) {
        int v30 = v13;
      }
      else {
        int v30 = 0;
      }
      if (v30 != 1) {
        int v29 = kNativePriorityMap[a3];
      }
      figSetPThreadPriority(v32, v29);
    }
    FigThreadRemoveFromAbortListAndCleanup((uint64_t)v32);
    FigThreadUnlockAbortList();
    if (gGMFigKTraceEnabled == 1)
    {
      FigThreadGetMachThreadPriorityValue(a3);
      kdebug_trace();
    }
    uint64_t v12 = 0;
    if (a6) {
      *a6 = v32;
    }
  }
  return v12;
}

uint64_t figSetMachThreadPriority(thread_act_t a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 0;
  memset(buffer, 0, sizeof(buffer));
  pid_t v4 = getpid();
  if (proc_pidinfo(v4, 2, 0, buffer, 232) < 1)
  {
    uint64_t result = 0xFFFFFFFFLL;
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  integer_t policy_info = a2 - HIDWORD(v8);
  uint64_t result = thread_policy_set(a1, 3u, &policy_info, 1u);
  if (result) {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t figGetMachThreadPriority(thread_inspect_t a1, _DWORD *a2)
{
  uint64_t v14 = 0;
  *(_OWORD *)thread_info_out = 0u;
  long long v13 = 0u;
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  mach_msg_type_number_t thread_info_outCnt = 10;
  uint64_t v4 = thread_info(a1, 3u, thread_info_out, &thread_info_outCnt);
  if (v4) {
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (DWORD1(v13) == 4)
  {
    mach_msg_type_number_t thread_info_outCnt = 4;
    uint64_t v4 = thread_info(a1, 0xCu, (thread_info_t)&v9 + 2, &thread_info_outCnt);
    if (v4) {
      return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    }
    v5 = (char *)&v9 + 12;
  }
  else
  {
    if (DWORD1(v13) != 2)
    {
      if (DWORD1(v13) == 1)
      {
        mach_msg_type_number_t thread_info_outCnt = 5;
        uint64_t v4 = thread_info(a1, 0xAu, (thread_info_t)&v7, &thread_info_outCnt);
        if (!v4)
        {
          v5 = (char *)&v7 + 4;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v4 = 4294954503;
      }
      return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    }
    mach_msg_type_number_t thread_info_outCnt = 5;
    uint64_t v4 = thread_info(a1, 0xBu, (thread_info_t)&v8 + 1, &thread_info_outCnt);
    if (v4) {
      return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    }
    v5 = (char *)&v8 + 8;
  }
LABEL_11:
  uint64_t result = 0;
  if (a2) {
    *a2 = *(_DWORD *)v5;
  }
  return result;
}

uint64_t fig_note_initialize_logging()
{
  return FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
}

uint64_t fig_note_init_logging_once()
{
  gFigLogControlMutex = (uint64_t)FigReentrantMutexCreate();

  return fig_note_read_control_preferences();
}

BOOL FigAtomicCompareAndSwap32(int a1, unsigned int a2, atomic_uint *a3)
{
  int v3 = a1;
  atomic_compare_exchange_strong_explicit(a3, (unsigned int *)&v3, a2, memory_order_relaxed, memory_order_relaxed);
  return v3 == a1;
}

void fig_note_initialize_work(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
}

pthread_mutex_t *FigReentrantMutexCreate()
{
  return FigReentrantMutexCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
}

CFPropertyListRef CelestialCFCreatePropertyList(const __CFString *a1)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  v2 = (__CFString *)CelestialGetModelSpecificName_sModelNameStr;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(v3, @"com.apple.MediaToolbox", a1, v2);
}

uint64_t CelestialGetModelSpecificName()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1) {
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_10);
  }
  return CelestialGetModelSpecificName_sModelNameStr;
}

CFPropertyListRef FigCFCreatePropertyListFromBundleIdentifier(CFStringRef bundleID, const __CFString *a2, const __CFString *a3)
{
  return FigCreatePropertyListFromBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E4F1CF80], bundleID, a2, a3);
}

void *FigSemaphoreCreate(uint64_t a1, uint64_t a2)
{
  return FigSemaphoreCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1, a2);
}

uint64_t FigSemaphoreWaitRelative(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 < 0)
  {
    int v5 = 1;
  }
  else
  {
    uint64_t v17 = 0;
    int v4 = RelativeTimeToAbsoluteTime(a2, &v17);
    if (v4) {
      uint64_t v2 = v17;
    }
    int v5 = v4 ^ 1;
  }
  uint64_t v6 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if (v6) {
    return v6;
  }
  uint64_t v7 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v7 + 1;
  if (*(unsigned char *)(a1 + 80))
  {
LABEL_21:
    *(void *)(a1 + 72) = v7;
    uint64_t v13 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    unsigned int v8 = 0;
    while (1)
    {
      uint64_t v9 = *(void *)(a1 + 56);
      if (v9 || v8 != 0) {
        break;
      }
      v11 = *(pthread_mutex_t **)a1;
      uint64_t v12 = (pthread_cond_t *)(a1 + 8);
      if (v2 < 0)
      {
        unsigned int v8 = WaitOnCondition(v12, v11);
      }
      else if (v5)
      {
        unsigned int v8 = WaitOnConditionTimedRelative(v12, v11, v2);
      }
      else
      {
        unsigned int v8 = WaitOnConditionTimed(v12, v11, v2);
      }
      if (*(unsigned char *)(a1 + 80))
      {
        uint64_t v7 = *(void *)(a1 + 72) - 1;
        goto LABEL_21;
      }
    }
    --*(void *)(a1 + 72);
    if (v8)
    {
      if (v8 == 60) {
        uint64_t v13 = 4294954504;
      }
      else {
        uint64_t v13 = v8;
      }
    }
    else
    {
      BOOL v15 = v9 < 1;
      uint64_t v16 = v9 - 1;
      if (v15)
      {
        uint64_t v13 = 4294954504;
      }
      else
      {
        uint64_t v13 = 0;
        *(void *)(a1 + 56) = v16;
      }
    }
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v13;
}

uint64_t WaitOnCondition(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  uint64_t v2 = pthread_cond_wait(a1, a2);
  uint64_t v3 = v2;
  if (v2) {
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  return v3;
}

void FigMemoryBarrier()
{
}

uint64_t FigAtomicIncrement32(atomic_uint *a1)
{
  return atomic_fetch_add_explicit(a1, 1u, memory_order_relaxed) + 1;
}

uint64_t FigAtomicDecrement32(atomic_uint *a1)
{
  return atomic_fetch_add_explicit(a1, 0xFFFFFFFF, memory_order_relaxed) - 1;
}

void *FigBaseGetClassID()
{
  return &kFigBaseClassID;
}

uint64_t FigBaseClassRegisterClass(uint64_t a1, void *a2, char a3, void *a4)
{
  if (!a1 || !a2 || !a4)
  {
LABEL_12:
    uint64_t v14 = 4294954516;
    goto LABEL_13;
  }
  if (a3)
  {
    unsigned int v8 = a2;
    while (!v8[14])
    {
      unsigned int v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_8;
      }
    }
    goto LABEL_12;
  }
LABEL_8:
  MallocZoneForPermanentAllocations = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
  uint64_t v10 = malloc_type_zone_calloc(MallocZoneForPermanentAllocations, 1uLL, 0x78uLL, 0x10F0040C6888576uLL);
  if (v10)
  {
    v11 = v10;
    *uint64_t v10 = a2;
    v10[1] = a1;
    if ((a3 & 1) == 0) {
      goto LABEL_18;
    }
    v10[2] = 0;
    uint64_t v12 = *(void *)(a1 + 24);
    v10[3] = *(void *)(a1 + 8);
    v10[4] = FigBaseObjectInit;
    v10[5] = 0;
    v10[6] = FigBaseObjectFinalize;
    v10[7] = FigBaseObjectEqual;
    v10[8] = 0;
    uint64_t v13 = v12 ? v12 : 0;
    v10[9] = v13;
    v10[10] = FigBaseObjectCopyDebugDescription;
    uint64_t v16 = _CFRuntimeRegisterClass();
    v11[14] = v16;
    if (!v16)
    {
      uint64_t v17 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
      if (v17)
      {
        v18 = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
        malloc_zone_free(v18, v11);
      }
    }
    else
    {
LABEL_18:
      uint64_t v17 = 0;
      *a4 = v11;
    }
    return v17;
  }
  uint64_t v14 = 4294954510;
LABEL_13:

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBaseObjectInit(uint64_t result)
{
  *(void *)(result + 24) = 0;
  return result;
}

uint64_t FigBaseObjectGetDerivedStorage(uint64_t a1)
{
  if (a1) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

uint64_t FigBaseObjectGetVTable(uint64_t result)
{
  if (result)
  {
    if (*(void *)(result + 24)) {
      return *(void *)(result + 24);
    }
    else {
      return 0;
    }
  }
  return result;
}

BOOL FigReentrantMutexTryLock(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}

uint64_t FigSemaphoreSignal(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if (v2) {
    return v2;
  }
  if (!*(unsigned char *)(a1 + 80))
  {
    uint64_t v4 = *(void *)(a1 + 56);
    if (v4 >= *(void *)(a1 + 64))
    {
      LOBYTE(v3) = 1;
    }
    else
    {
      LOBYTE(v3) = 0;
      *(void *)(a1 + 56) = v4 + 1;
    }
    goto LABEL_8;
  }
  uint64_t v3 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
  if (!v3)
  {
LABEL_8:
    unsigned int v5 = pthread_cond_signal((pthread_cond_t *)(a1 + 8));
    if ((v3 & (v5 == 0)) != 0) {
      uint64_t v3 = 4294954505;
    }
    else {
      uint64_t v3 = v5;
    }
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v3;
}

uint64_t createHostTimeClock()
{
  uint64_t v0 = *MEMORY[0x1E4F1CF80];
  long long v2 = *(_OWORD *)&kCMTimeZero.value;
  uint64_t v3 = 0;
  return FigDerivedClockCreateWithGetTimeCallback(v0, gFigHostTimeClockCallbacks, 0, &v2, 0, &sHostTimeClock);
}

uint64_t FigDerivedClockCreateWithGetTimeCallback(uint64_t a1, void *a2, const void *a3, long long *a4, char a5, uint64_t *a6)
{
  if (!a2 || !a6 || !a2[6])
  {
    uint64_t v15 = 4294954551;
    goto LABEL_11;
  }
  if (*a2 != 1)
  {
    uint64_t v15 = 4294954550;
LABEL_11:
    uint64_t v16 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    uint64_t v13 = 0;
    if (!v16) {
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  size_t v11 = a2[1];
  FigThreadRunOnce(&CMClockGetTypeID_sRegisterFigClockOnce, (void (*)(void))registerFigClock);
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v13 = Instance;
  if (Instance)
  {
    if (v11) {
      bzero((void *)(Instance + 208), v11);
    }
    if (a3) {
      CFTypeRef v14 = CFRetain(a3);
    }
    else {
      CFTypeRef v14 = 0;
    }
    *(void *)(v13 + 32) = v14;
  }
  else
  {
    uint64_t v18 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
    if (v18)
    {
      uint64_t v16 = v18;
      uint64_t v13 = 0;
      goto LABEL_15;
    }
  }
  *(void *)(v13 + 24) = a2;
  *(_DWORD *)(v13 + 44) = 1735680866;
  *(unsigned char *)(v13 + 73) = a5;
  long long v19 = *a4;
  *(void *)(v13 + 64) = *((void *)a4 + 2);
  *(_OWORD *)(v13 + 48) = v19;
  *(void *)(v13 + 16) = FigReentrantMutexCreate();
  *(unsigned char *)(v13 + 74) = 1;
  *(unsigned char *)(v13 + 72) = 0;
  if ((*(_DWORD *)(v13 + 60) & 0x1D) != 1
    || (CMTime time1 = *(CMTime *)(v13 + 48),
        *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value,
        time2.epoch = 0,
        !CMTimeCompare(&time1, &time2)))
  {
    *(unsigned char *)(v13 + 72) = 1;
    goto LABEL_28;
  }
  if (*(unsigned char *)(v13 + 72))
  {
LABEL_28:
    uint64_t v16 = 0;
    *(unsigned char *)(v13 + 41) = 1;
    goto LABEL_15;
  }
  if (*(void *)(v13 + 32))
  {
    *(_OWORD *)(v13 + 152) = *(_OWORD *)&kCMTimeZero.value;
    *(void *)(v13 + 168) = 0;
    *(_OWORD *)(v13 + 128) = *(_OWORD *)&kCMTimeZero.value;
    *(void *)(v13 + 144) = 0;
    goto LABEL_28;
  }
  uint64_t v16 = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  if (v16)
  {
LABEL_12:
    if (v13)
    {
      CFRelease((CFTypeRef)v13);
      uint64_t v13 = 0;
    }
  }
LABEL_14:
  if (a6) {
LABEL_15:
  }
    *a6 = v13;
  return v16;
}

uint64_t registerFigClock()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigClockID = result;
  return result;
}

double fcInit(_OWORD *a1)
{
  double result = 0.0;
  a1[11] = 0u;
  a1[12] = 0u;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

CFTypeRef FigClockRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void FigClockRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t figTimebaseCreate(uint64_t a1, char a2, void *a3)
{
  unsigned int v5 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimebaseTrace[1], @"timebase_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v5, 0, gFigTimebaseTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EB28B5D0, @"timebase_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EB28B5C8);
  if (a3)
  {
    FigThreadRunOnce(&CMTimebaseGetTypeID_sRegisterFigTimebaseOnce, (void (*)(void))registerFigTimebase);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v7 = (void *)Instance;
      unsigned int v8 = FigReentrantMutexCreate();
      v7[14] = v8;
      if (v8
        && ((a2 & 1) == 0
         || (dispatch_queue_t v9 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.timebase.notification", 0, 0),
             (v7[15] = v9) != 0)))
      {
        CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        uint64_t v11 = CMNotificationCenterRegisterForBarrierSupport((uint64_t)DefaultLocalCenter, (uint64_t)v7);
        if (!v11)
        {
          *a3 = v7;
          return v11;
        }
      }
      else
      {
        uint64_t v11 = FigSignalErrorAt(4294954546, 0, 0, 0, 0, 0, 0);
      }
      CFRelease(v7);
      return v11;
    }
    uint64_t v12 = 4294954546;
  }
  else
  {
    uint64_t v12 = 4294954548;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t registerFigTimebase()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigTimebaseID = result;
  return result;
}

double ftbInit(uint64_t a1)
{
  *(void *)(a1 + 320) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void FigTimebaseRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CFTypeRef FigTimebaseRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

uint64_t figTimebaseFindUltimateMasterClock(pthread_mutex_t **a1, uint64_t *a2)
{
  uint64_t v3 = figTimebaseCopyTargetTimebase(a1);
  uint64_t v4 = v3;
  uint64_t UltimateMasterClock = (uint64_t)v3[16];
  if (UltimateMasterClock)
  {
    if (a2)
    {
      uint64_t v6 = 1;
LABEL_6:
      *a2 = v6;
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t UltimateMasterClock = figTimebaseFindUltimateMasterClock(v3[17], &v8);
    if (a2)
    {
      uint64_t v6 = v8 + 1;
      goto LABEL_6;
    }
  }
  CFRelease(v4);
  return UltimateMasterClock;
}

uint64_t figTimebaseSwitchListenersToNewMaster(void *a1, const void *a2, unint64_t a3)
{
  if (a2)
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figTimebaseEffectiveRateChangedNotificationCallback, @"CMTimebaseEffectiveRateChanged", a2);
    uint64_t v7 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v7, a1, (uint64_t)figTimebaseTimeJumpedNotificationCallback, @"CMTimebaseTimeJumped", a2);
    uint64_t v8 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v8, a1, (uint64_t)figTimebaseTimeJumpedNotificationCallback, @"CMTimebaseTimeAdjusted", a2);
    dispatch_queue_t v9 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v9, a1, (uint64_t)figTimebaseMasterDidChangeNotificationCallback, @"CMTimebaseMasterDidChange", a2);
    uint64_t v10 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v10, a1, (uint64_t)figTimebaseMasterWillChangeNotificationCallback, @"CMTimebaseMasterWillChange", a2);
  }
  if (!a3) {
    return 0;
  }
  uint64_t v11 = CMNotificationCenterGetDefaultLocalCenter();
  uint64_t result = FigNotificationCenterAddWeakListener(v11, a1, (CFNotificationCallback)figTimebaseEffectiveRateChangedNotificationCallback, @"CMTimebaseEffectiveRateChanged", a3, 0, 0);
  if (!result)
  {
    uint64_t v13 = CMNotificationCenterGetDefaultLocalCenter();
    uint64_t result = FigNotificationCenterAddWeakListener(v13, a1, (CFNotificationCallback)figTimebaseTimeJumpedNotificationCallback, @"CMTimebaseTimeJumped", a3, 0, 0);
    if (!result)
    {
      CFTypeRef v14 = CMNotificationCenterGetDefaultLocalCenter();
      uint64_t result = FigNotificationCenterAddWeakListener(v14, a1, (CFNotificationCallback)figTimebaseTimeJumpedNotificationCallback, @"CMTimebaseTimeAdjusted", a3, 0, 0);
      if (!result)
      {
        uint64_t v15 = CMNotificationCenterGetDefaultLocalCenter();
        uint64_t result = FigNotificationCenterAddWeakListener(v15, a1, (CFNotificationCallback)figTimebaseMasterDidChangeNotificationCallback, @"CMTimebaseMasterDidChange", a3, 0, 0);
        if (!result)
        {
          uint64_t v16 = CMNotificationCenterGetDefaultLocalCenter();
          return FigNotificationCenterAddWeakListener(v16, a1, (CFNotificationCallback)figTimebaseMasterWillChangeNotificationCallback, @"CMTimebaseMasterWillChange", a3, 0, 0);
        }
      }
    }
  }
  return result;
}

unint64_t FigGetUpTimeNanoseconds()
{
  uint64_t v0 = mach_absolute_time();

  return FigHostTimeToNanoseconds(v0);
}

unint64_t FigHostTimeToNanoseconds(int64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  FigGetHostTimeToNanosecondsScale(&v7, &v6);
  signed int v3 = v6;
  signed int v2 = v7;
  unint64_t result = a1;
  if (v7 != 1 || v6 != 1)
  {
    return FigInt64MulDiv(a1, v2, v3, 0);
  }
  return result;
}

void FigGetHostTimeToNanosecondsScale(void *a1, void *a2)
{
  uint32_t denom = FigGetHostTimeToNanosecondsScale_denom;
  if (!FigGetHostTimeToNanosecondsScale_denom)
  {
    mach_timebase_info info = 0;
    if (mach_timebase_info(&info))
    {
      uint32_t denom = FigGetHostTimeToNanosecondsScale_denom;
    }
    else
    {
      FigGetHostTimeToNanosecondsScale_numer = info.numer;
      FigMemoryBarrier();
      uint32_t denom = info.denom;
      FigGetHostTimeToNanosecondsScale_uint32_t denom = info.denom;
    }
  }
  *a1 = FigGetHostTimeToNanosecondsScale_numer;
  *a2 = denom;
}

unint64_t FigInt64MulDiv(int64_t a1, signed int a2, signed int a3, _DWORD *a4)
{
  BOOL v5 = a1 >= 0;
  if (a1 < 0) {
    a1 = -a1;
  }
  BOOL v6 = a2 >= 0;
  if (a2 < 0) {
    a2 = -a2;
  }
  int v7 = v5 ^ v6;
  int v8 = a3 < 0;
  if (a3 < 0) {
    a3 = -a3;
  }
  unint64_t result = FigUInt64MulDiv(a1, a2, a3, a4);
  unint64_t v10 = result;
  if (result >= 0x7FFFFFFFFFFFFFFFLL) {
    unint64_t result = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v7 != v8)
  {
    if (a4) {
      *a4 = -*a4;
    }
    if (v10 <= 0x7FFFFFFFFFFFFFFELL) {
      return -(uint64_t)result;
    }
    else {
      return 0x8000000000000000;
    }
  }
  return result;
}

unint64_t FigUInt64MulDiv(unint64_t a1, unsigned int a2, unsigned int a3, _DWORD *a4)
{
  if (!a3) {
    goto LABEL_11;
  }
  if (!a2)
  {
    int v4 = 0;
    LODWORD(a1) = 0;
    LODWORD(v5) = 0;
    goto LABEL_12;
  }
  if (a2 == a3)
  {
    int v4 = 0;
    unint64_t v5 = HIDWORD(a1);
    goto LABEL_12;
  }
  if (!(a1 >> 15) && !HIWORD(a2))
  {
    LODWORD(v5) = 0;
    int v6 = a1 * a2;
    LODWORD(a1) = a1 * a2 / a3;
    int v4 = v6 - a1 * a3;
    goto LABEL_12;
  }
  unint64_t v7 = a1 * (unint64_t)a2;
  unint64_t v5 = HIDWORD(v7) + HIDWORD(a1) * (unint64_t)a2;
  if (HIDWORD(v5) < a3)
  {
    a1 = (v7 | ((v5 % a3) << 32)) / a3;
    int v4 = v7 - a1 * a3;
    LODWORD(v5) = v5 / a3;
  }
  else
  {
LABEL_11:
    int v4 = 0;
    LODWORD(a1) = -1;
    LODWORD(v5) = -1;
  }
LABEL_12:
  if (a4) {
    *a4 = v4;
  }
  return a1 | ((unint64_t)v5 << 32);
}

double FigSyncGetRelativeRate(void *a1, void *a2)
{
  uint64_t v7 = 0;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  int PivotTransform = figSyncGetPivotTransform(a2, a1, (uint64_t)&v4);
  double result = *((double *)&v5 + 1);
  if (PivotTransform) {
    return NAN;
  }
  return result;
}

uint64_t figSyncGetPivotTransform(void *a1, void *a2, uint64_t a3)
{
  uint64_t v67 = 0;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v64 = 0u;
  uint64_t v63 = 0;
  memset(v62, 0, sizeof(v62));
  uint64_t v61 = 0;
  memset(v60, 0, sizeof(v60));
  v58 = 0;
  v59 = 0;
  if (!a1 || (long long v4 = a2) == 0 || !a3)
  {
    uint64_t TransformRelativeToMaster = FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
    goto LABEL_44;
  }
  if (a1 == a2)
  {
    long long v66 = *(_OWORD *)&kCMTimeZero.value;
    uint64_t v67 = 0;
    long long v64 = *(_OWORD *)&kCMTimeZero.value;
    *(void *)&long long v65 = 0;
    *((void *)&v65 + 1) = 0x3FF0000000000000;
LABEL_45:
    uint64_t TransformRelativeToMaster = 0;
    long long v24 = v65;
    *(_OWORD *)a3 = v64;
    *(_OWORD *)(a3 + 16) = v24;
    *(_OWORD *)(a3 + 32) = v66;
    *(void *)(a3 + 48) = v67;
    return TransformRelativeToMaster;
  }
  long long v6 = figSyncCopyUltimateMasterClockAndHeight(a1, &v59);
  v49 = figSyncCopyUltimateMasterClockAndHeight(v4, &v58);
  int v7 = CFEqual(v6, v49);
  if (v58) {
    BOOL v8 = v59 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8 && v7)
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 == CMClockGetTypeID())
    {
      unint64_t v10 = (pthread_mutex_t **)v4;
      int v11 = 1;
    }
    else
    {
      unint64_t v10 = (pthread_mutex_t **)a1;
      int v11 = 0;
    }
    TransformRelativeTouint64_t UltimateMasterClock = FigTimebaseGetTransformRelativeToUltimateMasterClock(v10, v11, (uint64_t)&v64);
    goto LABEL_25;
  }
  if (v7)
  {
    CFTypeID v13 = CFGetTypeID(a1);
    if (v13 != CMClockGetTypeID())
    {
      CFTypeID v14 = CFGetTypeID(v4);
      if (v14 != CMClockGetTypeID())
      {
        CMClockOrTimebaseRef v48 = CMTimebaseCopySource((CMTimebaseRef)a1);
        if (v48 == v4)
        {
          uint64_t TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster((pthread_mutex_t **)a1, 0, (uint64_t)&v64);
          long long v19 = 0;
          CFTypeID v20 = 0;
          int v21 = 0;
          uint64_t v22 = 0;
          goto LABEL_27;
        }
        CMClockOrTimebaseRef v27 = CMTimebaseCopySource((CMTimebaseRef)v4);
        if (v27 == a1)
        {
          uint64_t TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster((pthread_mutex_t **)v4, 1, (uint64_t)&v64);
          long long v19 = 0;
          CFTypeID v20 = 0;
          int v21 = 0;
          uint64_t v22 = 0;
          v23 = a1;
        }
        else
        {
          v23 = v27;
          v47 = v6;
          int v29 = v58;
          uint64_t v28 = v59;
          int64_t v30 = (char *)v59 - (char *)v58;
          long long v19 = (OpaqueCMTimebase *)CFRetain(a1);
          CFTypeID v20 = (OpaqueCMTimebase *)CFRetain(v4);
          if (v30 < 1)
          {
            if (v30 < 0)
            {
              do
              {
                v36 = v20;
                CFTypeID v20 = CMTimebaseCopySourceTimebase(v20);
                CFRelease(v36);
                BOOL v33 = __CFADD__(v30++, 1);
              }
              while (!v33);
            }
            uint64_t v34 = &v59;
          }
          else
          {
            int64_t v31 = (char *)v29 - (char *)v28;
            do
            {
              pthread_t v32 = v19;
              long long v19 = CMTimebaseCopySourceTimebase(v19);
              CFRelease(v32);
              BOOL v33 = __CFADD__(v31++, 1);
            }
            while (!v33);
            uint64_t v34 = &v58;
          }
          v37 = *v34;
          int v21 = CMTimebaseCopySourceTimebase(v19);
          CMTimebaseRef v38 = CMTimebaseCopySourceTimebase(v20);
          uint64_t v22 = v38;
          if (v37) {
            BOOL v39 = v21 == v38;
          }
          else {
            BOOL v39 = 1;
          }
          if (!v39)
          {
            do
            {
              v40 = v19;
              v41 = v20;
              long long v19 = v21;
              CFTypeID v20 = v22;
              CFRelease(v40);
              int v21 = CMTimebaseCopySourceTimebase(v21);
              CFRelease(v41);
              CMTimebaseRef v42 = CMTimebaseCopySourceTimebase(v22);
              uint64_t v22 = v42;
              v37 = (pthread_mutex_t *)((char *)v37 - 1);
            }
            while (v37 && v21 != v42);
          }
          v43 = &v37[-1].__opaque[55];
          v46 = v58;
          uint64_t TransformRelativeToMasterAtHeight = FigTimebaseGetTransformRelativeToMasterAtHeight((pthread_mutex_t **)a1, (char *)v59 - v43, 0, (uint64_t)v62);
          if (!TransformRelativeToMasterAtHeight)
          {
            uint64_t TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMasterAtHeight((pthread_mutex_t **)v4, (char *)v46 - v43, 1, (uint64_t)v60);
            long long v6 = v47;
            long long v4 = (void *)v48;
            uint64_t v18 = v49;
            if (TransformRelativeToMaster) {
              goto LABEL_28;
            }
            goto LABEL_80;
          }
          uint64_t TransformRelativeToMaster = TransformRelativeToMasterAtHeight;
          long long v6 = v47;
        }
        long long v4 = (void *)v48;
        uint64_t v18 = v49;
        goto LABEL_28;
      }
    }
  }
  CFTypeID v15 = CFGetTypeID(a1);
  if (v15 == CMClockGetTypeID())
  {
    TransformRelativeTouint64_t UltimateMasterClock = FigClockGetTransformRelativeToHostTimeClock((uint64_t)a1, 0, (uint64_t)v62);
    if (TransformRelativeToUltimateMasterClock)
    {
LABEL_25:
      uint64_t TransformRelativeToMaster = TransformRelativeToUltimateMasterClock;
LABEL_26:
      long long v19 = 0;
      CFTypeID v20 = 0;
      int v21 = 0;
      uint64_t v22 = 0;
      long long v4 = 0;
LABEL_27:
      v23 = 0;
      uint64_t v18 = v49;
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v57 = 0;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v54 = 0u;
    uint64_t v53 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v50 = 0u;
    uint64_t TransformRelativeToMaster = FigTimebaseGetTransformRelativeToUltimateMasterClock((pthread_mutex_t **)a1, 0, (uint64_t)&v54);
    if (TransformRelativeToMaster) {
      goto LABEL_26;
    }
    uint64_t TransformRelativeToMaster = FigClockGetTransformRelativeToHostTimeClock((uint64_t)v6, 0, (uint64_t)&v50);
    if (TransformRelativeToMaster) {
      goto LABEL_26;
    }
    FigSyncCombineTransforms(&v54, (uint64_t)&v50, (uint64_t)v62);
    uint64_t TransformRelativeToMaster = v26;
    if (v26) {
      goto LABEL_26;
    }
  }
  CFTypeID v17 = CFGetTypeID(v4);
  uint64_t v18 = v49;
  if (v17 != CMClockGetTypeID())
  {
    uint64_t v57 = 0;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v54 = 0u;
    uint64_t v53 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v50 = 0u;
    uint64_t TransformRelativeToMaster = FigClockGetTransformRelativeToHostTimeClock((uint64_t)v49, 1, (uint64_t)&v54);
    if (TransformRelativeToMaster
      || (uint64_t TransformRelativeToMaster = FigTimebaseGetTransformRelativeToUltimateMasterClock((pthread_mutex_t **)v4, 1, (uint64_t)&v50), TransformRelativeToMaster)|| (FigSyncCombineTransforms(&v54, (uint64_t)&v50, (uint64_t)v60), uint64_t TransformRelativeToMaster = v35, v35))
    {
      long long v19 = 0;
      CFTypeID v20 = 0;
      int v21 = 0;
      uint64_t v22 = 0;
      long long v4 = 0;
      v23 = 0;
      goto LABEL_28;
    }
    long long v19 = 0;
    CFTypeID v20 = 0;
    int v21 = 0;
    uint64_t v22 = 0;
    long long v4 = 0;
    v23 = 0;
LABEL_80:
    FigSyncCombineTransforms(v62, (uint64_t)v60, (uint64_t)&v64);
    uint64_t TransformRelativeToMaster = v45;
    goto LABEL_28;
  }
  uint64_t TransformRelativeToMaster = FigClockGetTransformRelativeToHostTimeClock((uint64_t)v4, 1, (uint64_t)v60);
  long long v19 = 0;
  CFTypeID v20 = 0;
  int v21 = 0;
  uint64_t v22 = 0;
  long long v4 = 0;
  v23 = 0;
  if (!TransformRelativeToMaster) {
    goto LABEL_80;
  }
LABEL_28:
  if (v6) {
    CFRelease(v6);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v23) {
    CFRelease(v23);
  }
LABEL_44:
  if (!TransformRelativeToMaster) {
    goto LABEL_45;
  }
  return TransformRelativeToMaster;
}

uint64_t figTimebaseSetRateAndMaybeAnchorTime(uint64_t a1, long long *a2, CMTime *a3, int a4, double a5)
{
  long long v6 = a3;
  CMTimeFlags flags = a3->flags;
  memset(&v38, 0, sizeof(v38));
  memset(&v37, 0, sizeof(v37));
  BOOL v11 = (a4 & 1) == 0;
  if (a5 != 0.0 || (a4 & 2) == 0) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = (*((unsigned char *)a2 + 12) & 1) == 0 && (flags & 1) == 0;
  }
  if (!a1) {
    return 4294954548;
  }
  if (*(_DWORD *)(a1 + 16) != 1)
  {
    if ((*((_DWORD *)a2 + 3) ^ flags))
    {
      uint64_t v14 = 4294954547;
      goto LABEL_20;
    }
    int v15 = flags & 1;
    CMTime time1 = *(CMTime *)a2;
    CMTime v36 = *a3;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    FigCFDictionarySetDouble(Mutable, @"CMTimebaseRate", a5);
    FigCFDictionarySetCMTime(Mutable, @"CMTimebaseTimebaseTime", &time1);
    CMTime time1 = v36;
    FigCFDictionarySetCMTime(Mutable, @"CMTimebaseSourceTime", &time1);
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, @"CMTimebaseWillUpdateTiming", (const void *)a1, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
    uint64_t v18 = (_OWORD *)(a1 + 160);
    if (*(double *)(a1 + 184) == a5)
    {
      if (!v15
        || a5 == 0.0
        && (CMTime time1 = *(CMTime *)(a1 + 192), v36 = *(CMTime *)a2, !CMTimeCompare(&time1, &v36))
        && (*(_OWORD *)&time1.value = *v18, time1.epoch = *(void *)(a1 + 176), CMTime v36 = *v6, !CMTimeCompare(&time1, &v36)))
      {
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
        return 0;
      }
    }
    double EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    figTimebaseGetMasterTime((pthread_mutex_t **)a1, (uint64_t)&v38);
    if (v13)
    {
      LOBYTE(v36.value) = 0;
      memset(&time1, 0, sizeof(time1));
      figTimebaseGetAnchorTimebaseTimeIfClamped((pthread_mutex_t **)a1, (char *)&v36, (uint64_t)&time1);
      if (LOBYTE(v36.value))
      {
        *(CMTime *)a2 = time1;
        *long long v6 = v38;
        int v15 = 1;
      }
    }
    int v21 = (_OWORD *)(a1 + 192);
    if (v15)
    {
      long long v22 = *a2;
      *(void *)(a1 + 208) = *((void *)a2 + 2);
      *int v21 = v22;
    }
    else
    {
      figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &time1);
      *int v21 = *(_OWORD *)&time1.value;
      *(void *)(a1 + 208) = time1.epoch;
      long long v6 = &v38;
    }
    long long v23 = *(_OWORD *)&v6->value;
    *(void *)(a1 + 176) = v6->epoch;
    _OWORD *v18 = v23;
    *(double *)(a1 + 184) = a5;
    *(unsigned char *)(a1 + 216) = 0;
    if (a5 != 0.0)
    {
      FigSyncInvertTransform(a1 + 160, a1 + 224);
      if (!v24) {
        *(unsigned char *)(a1 + 216) = 1;
      }
    }
    CMTime time1 = v38;
    figTimebaseGetTimeAtMasterTime((pthread_mutex_t **)a1, &time1, &v37);
    double v25 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    double v26 = v25;
    if (v15)
    {
      char v27 = a4 & 1;
    }
    else
    {
      BOOL v11 = 1;
      char v27 = 1;
      if (v25 == EffectiveRate) {
        goto LABEL_52;
      }
    }
    double v28 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    int v29 = *(_DWORD *)(a1 + 320);
    if (v28 > 0.0) {
      int v30 = 1;
    }
    else {
      int v30 = -1;
    }
    if (v28 == 0.0) {
      int v30 = *(_DWORD *)(a1 + 320);
    }
    *(_DWORD *)(a1 + 320) = v30;
    int v31 = a4 & (v15 != 0);
    if (v26 != EffectiveRate) {
      int v31 = 0;
    }
    if (v29 == v30) {
      int v32 = 1;
    }
    else {
      int v32 = v31;
    }
    int v33 = (a4 | (v15 == 0)) & v32;
    if (*(void *)(a1 + 280))
    {
      CMTime time1 = v37;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &time1, v33);
    }
    if (*(void *)(a1 + 304))
    {
      CMTime time1 = v37;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &time1, v33);
    }
LABEL_52:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    CFAllocatorRef v34 = CFGetAllocator((CFTypeRef)a1);
    CMTime time1 = v37;
    CFDictionaryRef v35 = figTimebaseCreatePayloadForNotificationAtTime(v34, &time1);
    if (v26 != EffectiveRate) {
      figTimebasePostNotification((void *)a1, @"CMTimebaseEffectiveRateChanged", v35);
    }
    if (v27)
    {
      if (v11) {
        goto LABEL_56;
      }
    }
    else
    {
      figTimebasePostNotification((void *)a1, @"CMTimebaseTimeJumped", v35);
      if (v11)
      {
LABEL_56:
        if (v35) {
LABEL_57:
        }
          CFRelease(v35);
        return 0;
      }
    }
    figTimebasePostNotification((void *)a1, @"CMTimebaseTimeAdjusted", v35);
    if (!v35) {
      return 0;
    }
    goto LABEL_57;
  }
  uint64_t v14 = 4294954539;
LABEL_20:

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

void figTimebaseGetMasterTime(pthread_mutex_t **a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  signed int v3 = figTimebaseCopyTargetTimebase(a1);
  FigReentrantMutexLock(v3[14]);
  long long v4 = v3[16];
  if (v4) {
    long long v5 = (OpaqueCMClock *)CFRetain(v4);
  }
  else {
    long long v5 = 0;
  }
  long long v6 = v3[17];
  if (v6) {
    int v7 = (pthread_mutex_t **)CFRetain(v6);
  }
  else {
    int v7 = 0;
  }
  FigReentrantMutexUnlock(v3[14]);
  if (v5)
  {
    CMClockGetTime((CMTime *)a2, v5);
    if (!v7) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v7, 1, 0, (CMTime *)a2);
  if (v7) {
LABEL_9:
  }
    CFRelease(v7);
LABEL_10:
  if (v5) {
    CFRelease(v5);
  }

  CFRelease(v3);
}

__n128 FigSyncInvertTransform(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = 0;
  long long v9 = 0uLL;
  uint64_t v8 = 0;
  __n128 v7 = 0uLL;
  if (a1 && (*(_DWORD *)(a1 + 44) & 0x1D) == 1 && (*(_DWORD *)(a1 + 12) & 0x1D) == 1)
  {
    double v3 = *(double *)(a1 + 24);
    if (v3 != 0.0)
    {
      __n128 v7 = *(__n128 *)a1;
      uint64_t v8 = *(void *)(a1 + 16);
      long long v9 = *(_OWORD *)(a1 + 32);
      uint64_t v10 = *(void *)(a1 + 48);
      double v6 = 1.0 / v3;
      goto LABEL_9;
    }
    uint64_t v4 = 4294954541;
  }
  else
  {
    uint64_t v4 = 4294954544;
  }
  if (FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0)) {
    return result;
  }
  double v6 = 0.0;
LABEL_9:
  *(_OWORD *)a2 = v9;
  *(void *)(a2 + 16) = v10;
  *(double *)(a2 + 24) = v6;
  __n128 result = v7;
  *(__n128 *)(a2 + 32) = v7;
  *(void *)(a2 + 48) = v8;
  return result;
}

uint64_t FigTimebaseGetTransformRelativeToUltimateMasterClock(pthread_mutex_t **a1, int a2, uint64_t a3)
{
  uint64_t v3 = 4294954548;
  if (a1 && a3)
  {
    long long v23 = *(_OWORD *)&kCMTimeZero.value;
    uint64_t v24 = 0;
    long long v21 = *(_OWORD *)&kCMTimeZero.value;
    *(void *)&long long v22 = 0;
    *((void *)&v22 + 1) = 0x3FF0000000000000;
    double v6 = figTimebaseCopyTargetTimebase(a1);
    if (v6)
    {
      __n128 v7 = v6;
      while (1)
      {
        uint64_t v20 = 0;
        long long v18 = 0u;
        long long v19 = 0u;
        long long v17 = 0u;
        uint64_t v16 = 0;
        memset(v15, 0, sizeof(v15));
        uint64_t TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster(v7, a2, (uint64_t)v15);
        if (TransformRelativeToMaster) {
          break;
        }
        long long v17 = v21;
        long long v18 = v22;
        long long v19 = v23;
        uint64_t v20 = v24;
        if (a2)
        {
          long long v9 = v15;
          uint64_t v10 = &v17;
        }
        else
        {
          long long v9 = &v17;
          uint64_t v10 = v15;
        }
        FigSyncCombineTransforms(v9, (uint64_t)v10, (uint64_t)&v21);
        uint64_t v3 = v11;
        if (v11) {
          goto LABEL_13;
        }
        CMTimebaseRef v12 = CMTimebaseCopySourceTimebase((CMTimebaseRef)v7);
        CFRelease(v7);
        __n128 v7 = (pthread_mutex_t **)v12;
        if (!v12) {
          goto LABEL_11;
        }
      }
      uint64_t v3 = TransformRelativeToMaster;
LABEL_13:
      CFRelease(v7);
    }
    else
    {
LABEL_11:
      uint64_t v3 = 0;
      long long v13 = v22;
      *(_OWORD *)a3 = v21;
      *(_OWORD *)(a3 + 16) = v13;
      *(_OWORD *)(a3 + 32) = v23;
      *(void *)(a3 + 48) = v24;
    }
  }
  return v3;
}

uint64_t FigTimebaseGetTransformRelativeToMaster(pthread_mutex_t **a1, int a2, uint64_t a3)
{
  uint64_t v3 = 4294954548;
  if (a1 && a3)
  {
    double v6 = figTimebaseCopyTargetTimebase(a1);
    FigReentrantMutexLock(v6[14]);
    if (a2)
    {
      __n128 v7 = v6 + 20;
LABEL_5:
      long long v10 = *(_OWORD *)v7;
      long long v11 = *((_OWORD *)v7 + 1);
      long long v12 = *((_OWORD *)v7 + 2);
      long long v13 = v7[6];
      FigReentrantMutexUnlock(v6[14]);
      uint64_t v3 = 0;
      *(_OWORD *)a3 = v10;
      *(_OWORD *)(a3 + 16) = v11;
      *(_OWORD *)(a3 + 32) = v12;
      *(void *)(a3 + 48) = v13;
LABEL_9:
      CFRelease(v6);
      return v3;
    }
    if (CMTimebaseGetRate((CMTimebaseRef)v6) == 0.0)
    {
      uint64_t v3 = 4294954541;
    }
    else
    {
      if (*((unsigned char *)v6 + 216))
      {
        __n128 v7 = v6 + 28;
        goto LABEL_5;
      }
      __n128 v7 = v6 + 28;
      FigSyncInvertTransform((uint64_t)(v6 + 20), (uint64_t)(v6 + 28));
      uint64_t v3 = v9;
      if (!v9)
      {
        *((unsigned char *)v6 + 216) = 1;
        goto LABEL_5;
      }
    }
    FigReentrantMutexUnlock(v6[14]);
    goto LABEL_9;
  }
  return v3;
}

double FigSyncCombineTransforms(long long *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = 0;
  long long v10 = 0uLL;
  memset(&v9, 0, sizeof(v9));
  if ((*((_DWORD *)a1 + 11) & 0x1D) == 1
    && (*((_DWORD *)a1 + 3) & 0x1D) == 1
    && (*(_DWORD *)(a2 + 44) & 0x1D) == 1
    && (*(_DWORD *)(a2 + 12) & 0x1D) == 1)
  {
    CMTime v8 = *(CMTime *)(a1 + 2);
    FigSyncApplyTransform(&v8, a2, &v9);
    long long v10 = *a1;
    uint64_t v11 = *((void *)a1 + 2);
    double v6 = *((double *)a1 + 3) * *(double *)(a2 + 24);
  }
  else
  {
    if (FigSignalErrorAt(4294954543, 0, 0, 0, 0, 0, 0)) {
      return result;
    }
    double v6 = 0.0;
  }
  *(_OWORD *)a3 = v10;
  *(void *)(a3 + 16) = v11;
  *(double *)(a3 + 24) = v6;
  double result = *(double *)&v9.value;
  *(CMTime *)(a3 + 32) = v9;
  return result;
}

CMTime *FigSyncApplyTransform@<X0>(CMTime *a1@<X0>, uint64_t a2@<X1>, CMTime *a3@<X8>)
{
  *(_OWORD *)&a3->value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->epoch = 0;
  if (a2 && (a1->flags & 0x1D) == 1 && (*(_DWORD *)(a2 + 44) & 0x1D) == 1 && (*(_DWORD *)(a2 + 12) & 0x1D) == 1)
  {
    long long v5 = (_OWORD *)(a2 + 32);
    CMTime lhs = *a1;
    CMTime v7 = *(CMTime *)a2;
    CMTimeSubtract(&time, &lhs, &v7);
    CMTimeMultiplyByFloat64(&v10, &time, *(Float64 *)(a2 + 24));
    *(_OWORD *)&lhs.value = *v5;
    lhs.epoch = *(void *)(a2 + 48);
    return CMTimeAdd(a3, &v10, &lhs);
  }
  else
  {
    return (CMTime *)FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
  }
}

void figTimebaseEffectiveRateChangedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  memset(&v15, 0, sizeof(v15));
  if (a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(void *)(a2 + 136) != a4)
    {
      FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
LABEL_8:
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      return;
    }
    figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v15);
    if (*(double *)(a2 + 184) == 0.0) {
      goto LABEL_8;
    }
    double EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a2);
    int v9 = *(_DWORD *)(a2 + 320);
    if (EffectiveRate > 0.0) {
      int v10 = 1;
    }
    else {
      int v10 = -1;
    }
    if (EffectiveRate == 0.0) {
      int v10 = *(_DWORD *)(a2 + 320);
    }
    *(_DWORD *)(a2 + 320) = v10;
    BOOL v11 = v9 == v10;
    if (*(void *)(a2 + 280))
    {
      CMTime v14 = v15;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a2, &v14, v11);
    }
    if (*(void *)(a2 + 304))
    {
      CMTime v14 = v15;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a2, &v14, v11);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a2);
    CMTime v14 = v15;
    CFDictionaryRef v13 = figTimebaseCreatePayloadForNotificationAtTime(v12, &v14);
    figTimebasePostNotification((void *)a2, @"CMTimebaseEffectiveRateChanged", v13);
    if (v13) {
      CFRelease(v13);
    }
  }
  else
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
}

CMTime *FigSyncConvertTime@<X0>(CMTime *a1@<X0>, const void *a2@<X1>, const void *a3@<X2>, CMTime *a4@<X8>)
{
  CMTime v5 = *a1;
  return CMSyncConvertTime(a4, &v5, a2, a3);
}

uint64_t FigTimebaseSetRateAndAnchorTime(OpaqueCMTimebase *a1, CMTime *a2, CMTime *a3, Float64 a4)
{
  CMTime timebaseTime = *a2;
  CMTime v5 = *a3;
  return CMTimebaseSetRateAndAnchorTime(a1, a4, &timebaseTime, &v5);
}

uint64_t FigFilePathCreateFromNativePath(int a1, CFStringRef theString, uint64_t *a3)
{
  BOOL v11 = 0;
  CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(theString, 0x8000100u, (char **)&v11);
  if (CStringPtrAndBufferToFree)
  {
    double v6 = CStringPtrAndBufferToFree;
    if (!strncasecmp(CStringPtrAndBufferToFree, "file://", 7uLL)) {
      uint64_t v7 = 7;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = FigFilePathCreateFromDarwinPath(a1, &v6[v7], a3);
  }
  else
  {
    uint64_t v8 = FigSignalErrorAt(4294967246, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v9 = v8;
  free(v11);
  return v9;
}

uint64_t FigFilePathCreateFromDarwinPath(int a1, char *a2, uint64_t *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2 && a3)
  {
    uint64_t v4 = a2;
    CMTime v5 = realpath_DARWIN_EXTSN(a2, v11);
    if (v5) {
      uint64_t v4 = v5;
    }
    size_t v6 = strlen(v4) + 1;
    if (v6 >= 0x401)
    {
      uint64_t v10 = 4294955096;
    }
    else
    {
      FigFilePathGetTypeID();
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v8 = Instance;
        memcpy((void *)(Instance + 16), v4, v6);
        uint64_t result = 0;
        *a3 = v8;
        return result;
      }
      uint64_t v10 = 0xFFFFFFFFLL;
    }
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }

  return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFilePathGetTypeID()
{
  return sFigFilePathID;
}

uint64_t RegisterFigFilePathType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigFilePathID = result;
  return result;
}

uint64_t FigFilePathInit(uint64_t result)
{
  *(unsigned char *)(result + 16) = 0;
  return result;
}

uint64_t RegisterFigBlockBufferType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigBlockBufferID = result;
  return result;
}

void FigRuntimeRegisterAttachmentBearerWithTypeID(void *a1, const void *a2)
{
  FigThreadRunOnce(&sFigAttachmentsEnsureAttachmentBearerRegistrationDictionaryOnce, (void (*)(void))figAttachmentsMakeAttachmentBearerRegistrationDictionary);
  if (*a1 || !a1[1] || !a1[2] || !a1[3] || !a1[4] || !a1[5]) {
    goto LABEL_2;
  }
  uint64_t v4 = sFigAttachmentBearerCallbacksPerTypeID;
  if (!sFigAttachmentBearerCallbacksPerTypeID) {
    goto LABEL_3;
  }
  if (CFDictionaryGetCountOfKey((CFDictionaryRef)sFigAttachmentBearerCallbacksPerTypeID, a2))
  {
LABEL_2:
    uint64_t v4 = 0;
LABEL_3:
    FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    return;
  }
  CMTime v5 = (__CFDictionary *)sFigAttachmentBearerCallbacksPerTypeID;

  CFDictionarySetValue(v5, a2, a1);
}

double BBufInit(_OWORD *a1)
{
  double result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t NewBufferSubBlock(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v17 = 0;
  int v6 = *(_DWORD *)(a1 + 32);
  uint64_t v7 = *(int *)(a1 + 36);
  uint64_t v8 = v7 - 1;
  if (v6 < (int)v7 - 1)
  {
    uint64_t v9 = a1 + 48 * v6;
    uint64_t v17 = v9 + 48;
    *(void *)(v9 + 64) = a2;
    *(_DWORD *)(a1 + 32) = v6 + 1;
LABEL_6:
    uint64_t result = 0;
    *(void *)(a1 + 40) += a2;
    goto LABEL_7;
  }
  uint64_t v10 = a1 + 48 * v8;
  int v12 = *(_DWORD *)(v10 + 48);
  BOOL v11 = (_DWORD *)(v10 + 48);
  if (!v12)
  {
    CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
    uint64_t result = CMBlockBufferCreateEmpty(v14, *(_DWORD *)(a1 + 36), v15, (CMBlockBufferRef *)(a1 + 48 * v8 + 72));
    if (result) {
      goto LABEL_7;
    }
    _DWORD *v11 = 1;
    uint64_t v16 = a1 + 48 * v8;
    *(void *)(v16 + 56) = 0;
    *(void *)(v16 + 64) = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  uint64_t result = NewBufferSubBlock(*(void *)(a1 + 48 * v8 + 72), a2, &v17);
  if (!result)
  {
    *(void *)(a1 + 48 * v8 + 64) += a2;
    goto LABEL_6;
  }
LABEL_7:
  *a3 = v17;
  return result;
}

BOOL FigSimpleMutexTryLock(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}

uint64_t FigFileForkOpenMainByPath(uint64_t a1, unsigned int a2, int **a3)
{
  int v6 = a2 & 3;
  uint64_t v7 = (int *)malloc_type_malloc(4uLL, 0x100004052888210uLL);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((a2 & 0x20) != 0) {
      int v9 = 16778240;
    }
    else {
      int v9 = 0x1000000;
    }
    int v10 = (a2 >> 2) & 0x20 | v9;
    int v11 = (32 * a2) & 0x200;
    if ((a2 & 0x200) != 0) {
      int v11 = 2560;
    }
    v6 |= v10 | v11;
    int v12 = open((const char *)(a1 + 16), v6, 420);
    *uint64_t v8 = v12;
    if (v12 == -1)
    {
      if (*__error()) {
        uint64_t v15 = *__error();
      }
      else {
        uint64_t v15 = 0xFFFFFFFFLL;
      }
      uint64_t v14 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      if (((a2 & 0x40) == 0 || fcntl(v12, 48, 1) != -1) && ((a2 & 0x100) == 0 || fcntl(*v8, 68, 1) != -1))
      {
        *a3 = v8;
        return 0;
      }
      if (*__error()) {
        uint64_t v16 = *__error();
      }
      else {
        uint64_t v16 = 0xFFFFFFFFLL;
      }
      uint64_t v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      close(*v8);
    }
    free(v8);
  }
  else
  {
    uint64_t v14 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  }

  return convertPOSIXErrorToFigFileError(v14, v6);
}

uint64_t FigFileGetDarwinFileDesc(unsigned int *a1)
{
  return *a1;
}

uint64_t FigFileForkClose(int *a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = *a1;
  if (v2 == -1 || !close(v2)) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = *__error();
  }
  *a1 = 0;
  free(a1);
  return v3;
}

uint64_t FigByteStreamCreateForFile(uint64_t a1, unsigned int a2, const __CFAllocator *a3, CFTypeRef *a4)
{
  DarwinPath = (const char *)FigFileGetDarwinPath(a1);
  size_t v8 = strlen(DarwinPath);
  CFURLRef v9 = CFURLCreateFromFileSystemRepresentation(a3, (const UInt8 *)DarwinPath, v8, 0);
  uint64_t v10 = CMByteStreamCreateForFileURL((uint64_t)a3, v9, a2, a4);
  if (v9) {
    CFRelease(v9);
  }
  return v10;
}

uint64_t RegisterFigByteStreamBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigByteStreamClassDesc, ClassID, 1, &sFigByteStreamClassID);
}

uint64_t FigFileByteStreamRead(uint64_t a1, size_t a2, off_t a3, char *a4, unint64_t *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  unint64_t v25 = 0;
  unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  if (a2 > 0x1000 || !*(unsigned char *)(DerivedStorage + 4144))
  {
    uint64_t v20 = FigFileForkReadWithIOPolicy(*(int **)(DerivedStorage + 8), *(_DWORD *)(DerivedStorage + 4216), a4, a2, a3, (uint64_t *)&v25);
    goto LABEL_16;
  }
  uint64_t v24 = *(int **)(DerivedStorage + 8);
  int v11 = *(_DWORD *)(DerivedStorage + 4216);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 4136));
  uint64_t v12 = *(void *)(DerivedStorage + 4120);
  BOOL v13 = __OFSUB__(a3, v12);
  uint64_t v14 = a3 - v12;
  if (v14 < 0 == v13)
  {
    off_t v15 = *(void *)(DerivedStorage + 4128);
    BOOL v16 = v15 <= a3;
    size_t v17 = v15 - a3;
    if (!v16)
    {
      if (v17 >= a2) {
        size_t v18 = a2;
      }
      else {
        size_t v18 = v17;
      }
      memcpy(a4, (const void *)(DerivedStorage + 24 + v14), v18);
      a2 -= v18;
      off_t v19 = v18 + a3;
      if (!a2) {
        goto LABEL_9;
      }
LABEL_12:
      unint64_t v26 = 0;
      uint64_t v20 = FigFileForkReadWithIOPolicy(v24, v11, (void *)(DerivedStorage + 24), 0x1000uLL, v19, (uint64_t *)&v26);
      *(void *)(DerivedStorage + 4120) = v19;
      unint64_t v21 = v26;
      *(void *)(DerivedStorage + 4128) = v26 + v19;
      if (v21 < a2) {
        a2 = v21;
      }
      memcpy(&a4[v18], (const void *)(DerivedStorage + 24), a2);
      v18 += a2;
      goto LABEL_15;
    }
  }
  size_t v18 = 0;
  off_t v19 = a3;
  if (a2) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v20 = 0;
LABEL_15:
  unint64_t v25 = v18;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 4136));
LABEL_16:
  unint64_t v22 = FigGetUpTimeNanoseconds();
  FigByteStreamStatsLogOneRead((pthread_mutex_t *)(DerivedStorage + 4152), UpTimeNanoseconds, v22, v20, a3, v25);
  if (v20)
  {
    FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    if (a5) {
LABEL_18:
    }
      *a5 = v25;
  }
  else
  {
    if (v25) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = 4294954423;
    }
    if (a5) {
      goto LABEL_18;
    }
  }
  return v20;
}

uint64_t FigFileByteStreamCopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFURLRef *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"FBS_EntireLength") || CFEqual(a2, @"FBS_AvailableLength"))
  {
    valuePtr[0] = 0;
    uint64_t v9 = CMBaseObjectGetDerivedStorage(a1);
    FigFileForkGetLengthAtOffset(*(int **)(v9 + 8), 0, valuePtr);
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    int v11 = valuePtr;
    CFNumberType v12 = kCFNumberSInt64Type;
LABEL_4:
    CFURLRef StatsDictionary = CFNumberCreate(v10, v12, v11);
LABEL_5:
    uint64_t AllocatedStorageSpaceLength = 0;
    goto LABEL_6;
  }
  if (CFEqual(a2, @"FBS_EntireLengthAvailableOnDemand"))
  {
    if (*(void *)DerivedStorage)
    {
      CFURLRef StatsDictionary = (CFURLRef)*MEMORY[0x1E4F1CFD0];
LABEL_13:
      CFURLRef StatsDictionary = (CFURLRef)CFRetain(StatsDictionary);
      goto LABEL_5;
    }
    return 4294954513;
  }
  if (CFEqual(a2, @"FBS_URL"))
  {
    CFURLRef StatsDictionary = *(CFURLRef *)DerivedStorage;
    if (*(void *)DerivedStorage) {
      goto LABEL_13;
    }
    return 4294954513;
  }
  if (!CFEqual(a2, @"FBS_FileType"))
  {
    if (CFEqual(a2, @"FBS_IOPolicy"))
    {
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      int v11 = (uint64_t *)(DerivedStorage + 4216);
LABEL_22:
      CFNumberType v12 = kCFNumberIntType;
      goto LABEL_4;
    }
    if (CFEqual(a2, @"FBS_MIMEType")) {
      return 4294954512;
    }
    if (CFEqual(a2, @"FBS_ReadStats"))
    {
      CFURLRef StatsDictionary = FigByteStreamStatsCreateStatsDictionary(a3, @"FileByteStream", *(CFURLRef *)DerivedStorage, DerivedStorage + 4152);
      goto LABEL_5;
    }
    if (CFEqual(a2, @"FBS_ReadSupported"))
    {
      size_t v17 = (const void **)MEMORY[0x1E4F1CFD0];
      if (*(unsigned char *)(DerivedStorage + 16)) {
        size_t v17 = (const void **)MEMORY[0x1E4F1CFC8];
      }
    }
    else
    {
      if (!CFEqual(a2, @"FBS_WriteSupported"))
      {
        if (CFEqual(a2, @"FBS_FileDescriptor"))
        {
          LODWORD(valuePtr[0]) = FigFileGetDarwinFileDesc(*(unsigned int **)(DerivedStorage + 8));
          CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          int v11 = valuePtr;
          goto LABEL_22;
        }
        if (CFEqual(a2, @"FBS_AllocatedStorageSpaceLength"))
        {
          valuePtr[0] = 0;
          uint64_t AllocatedStorageSpaceLength = FigFileForkGetAllocatedStorageSpaceLength(*(int **)(DerivedStorage + 8), valuePtr);
          if (AllocatedStorageSpaceLength) {
            return AllocatedStorageSpaceLength;
          }
          CFURLRef StatsDictionary = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], valuePtr[0]);
          goto LABEL_6;
        }
        return 4294954512;
      }
      size_t v17 = (const void **)MEMORY[0x1E4F1CFD0];
      if ((*(unsigned char *)(DerivedStorage + 16) & 3) == 0) {
        size_t v17 = (const void **)MEMORY[0x1E4F1CFC8];
      }
    }
    CFURLRef StatsDictionary = (CFURLRef)*v17;
    if (!*v17) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
  CFURLRef v16 = *(const __CFURL **)DerivedStorage;
  if (!v16) {
    return 4294954513;
  }
  int v21 = 0;
  memset(v20, 0, sizeof(v20));
  v18[1] = 0;
  v18[2] = 0;
  bzero(valuePtr, 0x400uLL);
  v18[0] = 0x400000000005;
  if (!CFURLGetFileSystemRepresentation(v16, 1u, (UInt8 *)valuePtr, 1024)) {
    return 4294954513;
  }
  uint64_t AllocatedStorageSpaceLength = getattrlist((const char *)valuePtr, v18, v20, 0x24uLL, 0);
  if (AllocatedStorageSpaceLength) {
    return AllocatedStorageSpaceLength;
  }
  CFURLRef StatsDictionary = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v20[4]);
LABEL_6:
  *a4 = StatsDictionary;
  return AllocatedStorageSpaceLength;
}

uint64_t FigSemaphoreDestroy(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFAllocatorRef v2 = *(const __CFAllocator **)(a1 + 88);
  uint64_t v3 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if (v3) {
    return v3;
  }
  *(unsigned char *)(a1 + 80) = 1;
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  if (*(void *)(a1 + 72) && !pthread_cond_broadcast((pthread_cond_t *)(a1 + 8)))
  {
    while (!pthread_mutex_lock(*(pthread_mutex_t **)a1))
    {
      uint64_t v4 = *(void *)(a1 + 72);
      pthread_mutex_unlock(*(pthread_mutex_t **)a1);
      if (!v4) {
        break;
      }
      sched_yield();
    }
  }
  FigSimpleMutexDestroy(*(void *)a1);
  uint64_t v5 = pthread_cond_destroy((pthread_cond_t *)(a1 + 8));
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  CFAllocatorDeallocate(v2, (void *)a1);
  if (v2) {
    CFRelease(v2);
  }
  return v5;
}

CFAllocatorRef FigSimpleMutexDestroy(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = pthread_mutex_destroy((pthread_mutex_t *)a1);
  if (!v2)
  {
    CFAllocatorRef v3 = *(const __CFAllocator **)(a1 + 64);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(void *)(a1 + 64) = 0;
    CFAllocatorDeallocate(v3, (void *)a1);
    if (!v3) {
      return v3;
    }
    CFRelease(v3);
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)v2;
  FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  return v3;
}

uint64_t FigFileGetDarwinPath(uint64_t a1)
{
  return a1 + 16;
}

uint64_t FigAtomicBitAnd32(unsigned int a1, atomic_uint *a2)
{
  return atomic_fetch_and_explicit(a2, a1, memory_order_relaxed) & a1;
}

uint64_t FindDataReference(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t *a5)
{
  uint64_t v6 = *(unsigned int *)(a2 + 32);
  if ((int)v6 < 1)
  {
    uint64_t v24 = 0;
    LOBYTE(result) = 0;
  }
  else
  {
    unint64_t v8 = a3;
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    while (1)
    {
      unint64_t v13 = *(void *)(a2 + v11 + 64) + v12;
      if ((*(_DWORD *)(a2 + v11 + 48) - 2) <= 3)
      {
        unint64_t v14 = *(void *)(a1 + 16);
        if (v14 + a3 >= v12 && v13 > a3) {
          break;
        }
      }
      v11 += 48;
      unint64_t v12 = v13;
      if (48 * v6 == v11)
      {
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        LOBYTE(result) = 0;
        *a5 = 0;
        off_t v19 = (void *)(a2 + 72);
        do
        {
          if (!*(void *)(a1 + 16)) {
            break;
          }
          uint64_t v20 = *(v19 - 1);
          uint64_t v21 = v20 + v17;
          if (v8 < v20 + v17 && *((_DWORD *)v19 - 6) == 1)
          {
            unint64_t v26 = 0;
            if (v17 - v8 + v20 >= a4) {
              unint64_t v22 = a4;
            }
            else {
              unint64_t v22 = v17 - v8 + v20;
            }
            LODWORD(result) = FindDataReference(a1, *v19, v8 - v17 + *(v19 - 2), v22, &v26);
            if (result)
            {
              unint64_t v23 = v26;
              if (v26 >= v22) {
                unint64_t v23 = v22;
              }
              v8 += v23;
              *a5 += v23;
            }
            LODWORD(v6) = *(_DWORD *)(a2 + 32);
          }
          ++v16;
          v19 += 6;
          uint64_t v17 = v21;
        }
        while (v16 < (int)v6);
        return result;
      }
    }
    unint64_t v25 = *(void *)(a2 + 40) - a3;
    if (v25 >= a4) {
      unint64_t v25 = a4;
    }
    if (v14 >= v25) {
      uint64_t v24 = v25;
    }
    else {
      uint64_t v24 = *(void *)(a1 + 16);
    }
    AppendBufferReferenceSubBlock(*(void *)(a1 + 8), (const void *)a2, a3, v24);
    *(void *)(a1 + 16) -= v24;
    LOBYTE(result) = 1;
  }
  *a5 = v24;
  return result;
}

uint64_t AppendBufferReferenceSubBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  int v9 = *(_DWORD *)(a1 + 32);
  int v8 = *(_DWORD *)(a1 + 36);
  uint64_t v10 = v9;
  if (v9) {
    BOOL v11 = v9 < v8;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    uint64_t v12 = v9 - 1;
    if (*(_DWORD *)(a1 + 48 * (v10 - 1) + 48) == 1 && *(const void **)(a1 + 48 * v12 + 72) == a2)
    {
      uint64_t v13 = a1 + 48 * v12;
      uint64_t v16 = *(void *)(v13 + 64);
      unint64_t v14 = (void *)(v13 + 64);
      uint64_t v15 = v16;
      if (v16 + *(v14 - 1) == a3)
      {
        *unint64_t v14 = v15 + a4;
LABEL_15:
        uint64_t result = 0;
        *(void *)(a1 + 40) += a4;
        return result;
      }
    }
  }
  int v17 = v8 - 1;
  if ((int)v10 < v17)
  {
    uint64_t v18 = a1 + 48 * (int)v10;
    *(_DWORD *)(v18 + 48) = 1;
    *(void *)(v18 + 56) = a3;
    *(void *)(v18 + 64) = a4;
    *(void *)(v18 + 72) = CFRetain(a2);
    ++*(_DWORD *)(a1 + 32);
    goto LABEL_15;
  }
  int v19 = v17;
  uint64_t v20 = a1 + 48 * v17;
  int v22 = *(_DWORD *)(v20 + 48);
  uint64_t v21 = (_DWORD *)(v20 + 48);
  if (v22)
  {
LABEL_13:
    uint64_t result = AppendBufferReferenceSubBlock(*(void *)(a1 + 48 * v19 + 72), a2, a3, a4);
    if (result) {
      return result;
    }
    *(void *)(a1 + 48 * v19 + 64) += a4;
    goto LABEL_15;
  }
  CFAllocatorRef v24 = CFGetAllocator((CFTypeRef)a1);
  uint64_t result = CMBlockBufferCreateEmpty(v24, *(_DWORD *)(a1 + 36), v25, (CMBlockBufferRef *)(a1 + 48 * v19 + 72));
  if (!result)
  {
    *uint64_t v21 = 1;
    uint64_t v26 = a1 + 48 * v19;
    *(void *)(v26 + 56) = 0;
    *(void *)(v26 + 64) = 0;
    ++*(_DWORD *)(a1 + 32);
    goto LABEL_13;
  }
  return result;
}

void FigBlockBufferRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void BBufFinalize(CFAllocatorRef *cf)
{
  if (*((int *)cf + 8) >= 1)
  {
    uint64_t v2 = 0;
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
    uint64_t v4 = cf + 11;
    do
    {
      int v5 = *((_DWORD *)v4 - 10);
      if ((v5 - 2) < 2)
      {
        uint64_t v6 = v4 - 2;
        CFAllocatorRef v9 = v3;
        if (*v4 != v3)
        {
          if (*v6) {
            CFAllocatorDeallocate(*v4, *v6);
          }
          CFAllocatorRef v9 = *v4;
        }
        CFRelease(v9);
      }
      else
      {
        if ((v5 - 4) >= 2)
        {
          if (v5 == 1)
          {
            CFRelease(*(v4 - 2));
            *(v4 - 2) = 0;
          }
          goto LABEL_18;
        }
        uint64_t v6 = v4 - 2;
        uint64_t v7 = *(void (**)(void, CFAllocatorRef, void))((char *)*v4 + 12);
        if (v7 && *v6) {
          v7(*(void *)((char *)*v4 + 20), *v6, *(v4 - 1));
        }
        CFAllocatorRef v8 = CFGetAllocator(cf);
        CFAllocatorDeallocate(v8, *v4);
      }
      *uint64_t v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
LABEL_18:
      *((_DWORD *)v4 - 10) = 0;
      ++v2;
      *(v4 - 4) = 0;
      *(v4 - 3) = 0;
      v4 += 6;
    }
    while (v2 < *((int *)cf + 8));
  }
  uint64_t v10 = 0;
  char v11 = 1;
  do
  {
    char v12 = v11;
    uint64_t v13 = (char *)&cf[v10];
    uint64_t v16 = (const void *)*((void *)v13 + 2);
    uint64_t v15 = v13 + 16;
    unint64_t v14 = v16;
    if (v16)
    {
      CFRelease(v14);
      *uint64_t v15 = 0;
    }
    char v11 = 0;
    uint64_t v10 = 1;
  }
  while ((v12 & 1) != 0);
  *((_DWORD *)cf + 8) = 0;
  cf[5] = 0;
}

CFTypeRef FigBlockBufferRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

uint64_t AudioToolbox_AudioFormatGetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetProperty;
  if (pAudioFormatGetProperty
    || ((FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce), !gAudioToolboxBundleStatus)? (uint64_t result = 0): (uint64_t result = 4294965266), (v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetProperty) != 0))
  {
    return v10(a1, a2, a3, a4, a5);
  }
  return result;
}

void *loadAudioToolboxPointersOnce()
{
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.audio.toolbox.AudioToolbox");
  gAudioToolboxBundle = (uint64_t)BundleWithIdentifier;
  if (!BundleWithIdentifier)
  {
    uint64_t v2 = (FILE *)*MEMORY[0x1E4F143C8];
    CFAllocatorRef v3 = "Failed to get AudioToolbox bundle!\n";
    size_t v4 = 35;
    goto LABEL_13;
  }
  pAudioConverterGetProperty = CFBundleGetFunctionPointerForName(BundleWithIdentifier, @"AudioConverterGetProperty");
  if (!pAudioConverterGetProperty)
  {
    uint64_t v2 = (FILE *)*MEMORY[0x1E4F143C8];
    CFAllocatorRef v3 = "Failed to get AudioToolbox symbol (pAudioConverterGetProperty)!\n";
LABEL_12:
    size_t v4 = 64;
    goto LABEL_13;
  }
  pAudioConverterSetProperty = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, @"AudioConverterSetProperty");
  if (!pAudioConverterSetProperty)
  {
    uint64_t v2 = (FILE *)*MEMORY[0x1E4F143C8];
    CFAllocatorRef v3 = "Failed to get AudioToolbox symbol (pAudioConverterSetProperty)!\n";
    goto LABEL_12;
  }
  pAudioFormatGetProperty = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, @"AudioFormatGetProperty");
  if (pAudioFormatGetProperty)
  {
    pAudioFormatGetPropertyInfo = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, @"AudioFormatGetPropertyInfo");
    if (pAudioFormatGetPropertyInfo)
    {
      pAudioConverterDispose = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, @"AudioConverterDispose");
      if (pAudioConverterDispose)
      {
        uint64_t result = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, @"AudioConverterNew");
        pAudioConverterNew = result;
        if (result) {
          return result;
        }
        uint64_t v2 = (FILE *)*MEMORY[0x1E4F143C8];
        CFAllocatorRef v3 = "Failed to get AudioToolbox symbol (pAudioConverterNew)!\n";
        size_t v4 = 56;
      }
      else
      {
        uint64_t v2 = (FILE *)*MEMORY[0x1E4F143C8];
        CFAllocatorRef v3 = "Failed to get AudioToolbox symbol (pAudioConverterDispose)!\n";
        size_t v4 = 60;
      }
    }
    else
    {
      uint64_t v2 = (FILE *)*MEMORY[0x1E4F143C8];
      CFAllocatorRef v3 = "Failed to get AudioToolbox symbol (pAudioFormatGetPropertyInfo)!\n";
      size_t v4 = 65;
    }
  }
  else
  {
    uint64_t v2 = (FILE *)*MEMORY[0x1E4F143C8];
    CFAllocatorRef v3 = "Failed to get AudioToolbox symbol (pAudioFormatGetProperty)!\n";
    size_t v4 = 61;
  }
LABEL_13:
  uint64_t result = (void *)fwrite(v3, v4, 1uLL, v2);
  gAudioToolboxBundleStatus = 1;
  return result;
}

uint64_t AudioToolbox_AudioFormatGetPropertyInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetPropertyInfo;
  if (pAudioFormatGetPropertyInfo
    || ((FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce), !gAudioToolboxBundleStatus)? (uint64_t result = 0): (uint64_t result = 4294965266), (v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetPropertyInfo) != 0))
  {
    return v8(a1, a2, a3, a4);
  }
  return result;
}

uint64_t FigAudioFormatDescriptionRegisterOnce()
{
  int v1 = 0;
  int v5 = figAudioFormatDescriptionFinalize;
  size_t v4 = figAudioFormatDescriptionCopyDebugDesc;
  uint64_t v2 = 144;
  CFAllocatorRef v3 = figAudioFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x736F756Eu, (long long *)&v1);
}

uint64_t FigDerivedFormatDescriptionRegister(unsigned int a1, long long *a2)
{
  if (a2)
  {
    if (*(_DWORD *)a2 || !*(void *)((char *)a2 + 12))
    {
      uint64_t v3 = 4294954586;
    }
    else
    {
      FigThreadRunOnce(&sCreateRegistryGuard, (void (*)(void))createDescriptionRegistry);
      if (sFigFormatDescriptionRegistry)
      {
        if (sRegistryLock)
        {
          uint64_t v6 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 36, 0);
          if (v6)
          {
            uint64_t v7 = v6;
            long long v8 = *a2;
            long long v9 = a2[1];
            *((_DWORD *)v6 + 8) = *((_DWORD *)a2 + 8);
            *uint64_t v6 = v8;
            v6[1] = v9;
            FigSimpleMutexLock((pthread_mutex_t *)sRegistryLock);
            CFDictionaryAddValue((CFMutableDictionaryRef)sFigFormatDescriptionRegistry, (const void *)a1, v7);
            FigSimpleMutexUnlock((pthread_mutex_t *)sRegistryLock);
            return 0;
          }
        }
      }
      uint64_t v3 = 4294954585;
    }
  }
  else
  {
    uint64_t v3 = 4294954586;
  }

  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

pthread_mutex_t *createDescriptionRegistry()
{
  CFDictionaryValueCallBacks v1 = *(CFDictionaryValueCallBacks *)byte_1EDF6D188;
  sFigFormatDescriptionRegistry = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, &v1);
  uint64_t result = FigSimpleMutexCreate();
  sRegistryLock = (uint64_t)result;
  return result;
}

uint64_t FigDerivedFormatDescriptionCreate(const __CFAllocator *a1, void *key, int a3, const void *a4, uint64_t *a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a5) {
    goto LABEL_32;
  }
  int v5 = (int)key;
  if (!key || !sFigFormatDescriptionRegistry) {
    goto LABEL_32;
  }
  CFNumberRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)key);
  if (!Value)
  {
    if (v5 <= 1885954931)
    {
      if (v5 > 1835365472)
      {
        if (v5 == 1835365473)
        {
          FigMetadataFormatDescriptionRegister();
          goto LABEL_25;
        }
        uint64_t v11 = 1734700658;
        if (v5 == 1836415096)
        {
          FigMuxedFormatDescriptionRegister();
          goto LABEL_25;
        }
        goto LABEL_26;
      }
      if (v5 != 1635088502)
      {
        uint64_t v11 = 1734700658;
        if (v5 == 1668310898)
        {
          FigCaptionGroupFormatDescriptionRegister();
LABEL_25:
          uint64_t v11 = v5;
        }
LABEL_26:
        CFNumberRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)v11);
        if (Value) {
          goto LABEL_28;
        }
        CFNumberRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72);
        if (Value) {
          goto LABEL_28;
        }
LABEL_32:
        uint64_t v16 = 4294954586;
        goto LABEL_33;
      }
    }
    else
    {
      if (v5 > 1952606065)
      {
        if (v5 == 1952606066)
        {
          FigTaggedBufferGroupFormatDescriptionRegister();
          goto LABEL_25;
        }
        if (v5 == 1953325924)
        {
          FigTimeCodeFormatDescriptionRegister();
          goto LABEL_25;
        }
        uint64_t v11 = 1734700658;
        if (v5 != 1986618469) {
          goto LABEL_26;
        }
        goto LABEL_18;
      }
      if (v5 != 1885954932)
      {
        uint64_t v11 = 1734700658;
        if (v5 == 1936684398)
        {
          FigAudioFormatDescriptionRegister();
          goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
LABEL_18:
    FigVideoFormatDescriptionRegister();
    goto LABEL_25;
  }
LABEL_28:
  FigThreadRunOnce(&CMFormatDescriptionGetTypeID_sRegisterFigFormatDescriptionOnce, (void (*)(void))registerFigFormatDescription);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v13 = Instance;
    bzero((void *)(Instance + 32), *(void *)(Value + 4));
    *(_DWORD *)(v13 + 16) = v5;
    *(_DWORD *)(v13 + 20) = a3;
    if (a4 && (CFPropertyListRef DeepCopy = CFPropertyListCreateDeepCopy(a1, a4, 0), (*(void *)(v13 + 24) = DeepCopy) == 0))
    {
      uint64_t v15 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      v24[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DF0, 0, v24, &type);
      int v19 = v24[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v21 = v19;
      }
      else {
        unsigned int v21 = v19 & 0xFFFFFFFE;
      }
      if (v21)
      {
        v24[1] = 136315138;
        CMBlockBufferFlags v25 = "FigDerivedFormatDescriptionCreate";
        int v22 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v19) = v24[0];
      }
      else
      {
        int v22 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DF0, 0, 0, v22, v22 != &v26, v19, 0, v20);
      CFRelease((CFTypeRef)v13);
    }
    else
    {
      uint64_t v15 = 0;
      *a5 = v13;
    }
    return v15;
  }
  uint64_t v16 = 4294954585;
LABEL_33:

  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t registerFigFormatDescription()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigFormatDescriptionID = result;
  return result;
}

uint64_t figFormatDescriptionInit(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

uint64_t FigDerivedFormatDescriptionGetDerivedStorage(uint64_t a1)
{
  if (a1) {
    return a1 + 32;
  }
  FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  return 0;
}

void FigFormatDescriptionRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigBaseObjectFinalize(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v3 = (void *)(result + 24);
  uint64_t v2 = *(void *)(result + 24);
  if (v2) {
    uint64_t v4 = *(void *)(result + 24);
  }
  else {
    uint64_t v4 = 0;
  }
  if (**(void **)(v4 + 8) >= 2uLL
    && (!v2 ? (uint64_t v5 = 0) : (uint64_t v5 = *(void *)(result + 24)),
        !*(void *)(v5 + 8) ? (uint64_t v6 = 0) : (uint64_t v6 = *(void *)(v5 + 8)),
        (uint64_t v7 = *(uint64_t (**)(uint64_t))(v6 + 64)) != 0 && v7 == FigBaseObjectStandardNotificationBarrier))
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    uint64_t result = CMNotificationCenterUnregisterForBarrierSupport((uint64_t)DefaultLocalCenter, v1);
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2) {
      goto LABEL_14;
    }
  }
  else if (v2)
  {
LABEL_14:
    uint64_t v8 = v2;
    goto LABEL_17;
  }
  uint64_t v8 = 0;
LABEL_17:
  if (*(void *)(v8 + 8)) {
    uint64_t v10 = *(void *)(v8 + 8);
  }
  else {
    uint64_t v10 = 0;
  }
  if (*(void *)(v10 + 32))
  {
    if (*(void *)(v2 + 8)) {
      uint64_t v11 = *(void *)(v2 + 8);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))(v11 + 32))(v1);
  }
  *uint64_t v3 = 0;
  return result;
}

CFTypeRef FigFormatDescriptionRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t registerFigBufferQueueType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigBufferQueueID = result;
  return result;
}

double bufQInit(uint64_t a1)
{
  *(void *)(a1 + 256) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t fig_note_initialize_timestamps()
{
  return FigThreadRunOnce(&sFigNoteInit, (void (*)(void))fig_note_init_timestamps_once);
}

uint64_t fig_note_init_timestamps_once()
{
  return gettimeofday((timeval *)&sStartTime, 0);
}

CFTypeRef FigBufferQueueRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

uint64_t bufQInstallTrigger(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(unsigned char *)(a1 + 168))
  {
    uint64_t v16 = 4294954530;
    goto LABEL_3;
  }
  if (!*(void *)(a1 + 160))
  {
    CFSetCallBacks v26 = *(CFSetCallBacks *)byte_1EDF6CEF8;
    CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)a1);
    CFMutableSetRef v20 = CFSetCreateMutable(v19, 0, &v26);
    *(void *)(a1 + 160) = v20;
    if (!v20)
    {
      uint64_t v16 = 4294954536;
LABEL_3:
      uint64_t v17 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      uint64_t v18 = 0;
      if (!a8) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  CFAllocatorRef v21 = CFGetAllocator((CFTypeRef)a1);
  int v22 = CFAllocatorAllocate(v21, 72, 0);
  uint64_t v18 = (uint64_t)v22;
  if (!v22)
  {
    uint64_t v17 = FigSignalErrorAt(4294954536, 0, 0, 0, 0, 0, 0);
    if (!a8) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  *int v22 = a2;
  v22[1] = a3;
  v22[2] = _Block_copy(a4);
  *(_DWORD *)(v18 + 24) = a5;
  uint64_t v23 = *(void *)(a6 + 16);
  *(_OWORD *)(v18 + 28) = *(_OWORD *)a6;
  *(void *)(v18 + 44) = v23;
  *(void *)(v18 + 56) = a7;
  *(unsigned char *)(v18 + 64) = 0;
  CFSetSetValue(*(CFMutableSetRef *)(a1 + 160), (const void *)v18);
  int v24 = *(unsigned __int8 *)(a1 + 169);
  *(unsigned char *)(a1 + 169) = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 160), (CFSetApplierFunction)bufQCheckForDataBecomesReadyTrigger, (void *)a1);
  if (!v24 && *(unsigned char *)(a1 + 169)) {
    bufQStartListeningForHeadBufferBecomingReady(a1);
  }
  if (a8) {
    *a8 = v18;
  }
  evaluateAndMaybeFireTrigger(v18, (char *)a1);
  uint64_t v17 = 0;
  if (a8) {
LABEL_14:
  }
    *a8 = v18;
LABEL_15:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v17;
}

uint64_t bufQCheckForDataBecomesReadyTrigger(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 24) == 7) {
    *(unsigned char *)(a2 + 169) = 1;
  }
  return result;
}

uint64_t bufQStartListeningForHeadBufferBecomingReady(uint64_t result)
{
  if (*(unsigned char *)(result + 169))
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 120))
    {
      if (!*(void *)(result + 84)) {
        return result;
      }
      uint64_t v2 = (const __CFString **)(result + 100);
    }
    else
    {
      if (!*(void *)(result + 80)) {
        return result;
      }
      uint64_t v2 = (const __CFString **)(result + 96);
    }
    CFStringRef v3 = *v2;
    if (*v2)
    {
      FigReentrantMutexLock(*(pthread_mutex_t **)(result + 16));
      CFArrayRef v4 = *(const __CFArray **)(v1 + 24);
      if (v4)
      {
        if (CFArrayGetCount(v4) >= 1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 24), 0);
          if (ValueAtIndex)
          {
            unint64_t v6 = (unint64_t)ValueAtIndex;
            if (!*(unsigned char *)(v1 + 120))
            {
              if ((*(unsigned int (**)(void))(*(void *)(v1 + 80) + 16))()) {
                goto LABEL_14;
              }
              goto LABEL_13;
            }
            if (!(*(unsigned int (**)(const void *, void))(v1 + 84))(ValueAtIndex, *(void *)(v1 + 52)))
            {
LABEL_13:
              CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
              CMNotificationCenterAddListener(DefaultLocalCenter, (const void *)v1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))bufQDataBecameReady, v3, v6);
              *(void *)(v1 + 176) = v6;
            }
          }
        }
      }
LABEL_14:
      uint64_t v8 = *(pthread_mutex_t **)(v1 + 16);
      return FigReentrantMutexUnlock(v8);
    }
  }
  return result;
}

uint64_t evaluateAndMaybeFireTrigger(uint64_t result, char *queue)
{
  uint64_t v3 = result;
  int v4 = *(unsigned __int8 *)(result + 64);
  memset(&v17, 0, sizeof(v17));
  memset(&v16, 0, sizeof(v16));
  switch(*(_DWORD *)(result + 24))
  {
    case 1:
      CMTime time1 = *(CMTime *)(queue + 124);
      CMTime v14 = *(CMTime *)(result + 28);
      double result = CMTimeCompare(&time1, &v14);
      unsigned int v5 = result >> 31;
      goto LABEL_39;
    case 2:
      CMTime time1 = *(CMTime *)(queue + 124);
      CMTime v14 = *(CMTime *)(result + 28);
      double result = CMTimeCompare(&time1, &v14);
      BOOL v6 = (int)result < 1;
      goto LABEL_23;
    case 3:
      CMTime time1 = *(CMTime *)(queue + 124);
      CMTime v14 = *(CMTime *)(result + 28);
      double result = CMTimeCompare(&time1, &v14);
      BOOL v7 = (int)result <= 0;
      goto LABEL_28;
    case 4:
      CMTime time1 = *(CMTime *)(queue + 124);
      CMTime v14 = *(CMTime *)(result + 28);
      double result = CMTimeCompare(&time1, &v14);
      LOBYTE(v5) = (int)result >= 0;
      goto LABEL_39;
    case 5:
      CMBufferQueueGetMinPresentationTimeStamp(&v17, (CMBufferQueueRef)queue);
      CMTime time1 = *(CMTime *)(v3 + 28);
      CMTime v14 = v17;
      double result = CMTimeCompare(&time1, &v14);
      *(unsigned char *)(v3 + 64) = result != 0;
      if (!result) {
        return result;
      }
      uint64_t v8 = v3 + 28;
      *(_OWORD *)(v3 + 28) = *(_OWORD *)&v17.value;
      CMTimeEpoch epoch = v17.epoch;
      goto LABEL_11;
    case 6:
      CMBufferQueueGetMaxPresentationTimeStamp(&v16, (CMBufferQueueRef)queue);
      CMTime time1 = *(CMTime *)(v3 + 28);
      CMTime v14 = v16;
      double result = CMTimeCompare(&time1, &v14);
      *(unsigned char *)(v3 + 64) = result != 0;
      if (!result) {
        return result;
      }
      uint64_t v8 = v3 + 28;
      *(_OWORD *)(v3 + 28) = *(_OWORD *)&v16.value;
      CMTimeEpoch epoch = v16.epoch;
LABEL_11:
      *(void *)(v8 + 16) = epoch;
      goto LABEL_42;
    case 7:
      *(unsigned char *)(result + 64) = 0;
      double result = *((void *)queue + 3);
      if (!result) {
        goto LABEL_40;
      }
      double result = CFArrayGetCount((CFArrayRef)result);
      if (result < 1) {
        goto LABEL_40;
      }
      double result = (uint64_t)CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
      uint64_t v10 = result;
      if (queue[120])
      {
        uint64_t v11 = *(uint64_t (**)(uint64_t, void))(queue + 84);
        if (v11)
        {
          double result = v11(result, *(void *)(queue + 52));
LABEL_37:
          LOBYTE(v5) = result != 0;
          goto LABEL_39;
        }
      }
      else
      {
        double result = *((void *)queue + 10);
        if (result)
        {
          double result = (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, v10);
          goto LABEL_37;
        }
      }
LABEL_38:
      LOBYTE(v5) = 1;
LABEL_39:
      *(unsigned char *)(v3 + 64) = v5;
LABEL_40:
      if (v4 || !*(unsigned char *)(v3 + 64)) {
        return result;
      }
LABEL_42:
      char v12 = *(uint64_t (**)(void, uint64_t))v3;
      if (*(void *)v3)
      {
        queue[168] = 1;
        uint64_t v13 = queue + 168;
        double result = v12(*(void *)(v3 + 8), v3);
      }
      else
      {
        double result = *(void *)(v3 + 16);
        if (!result) {
          return result;
        }
        queue[168] = 1;
        uint64_t v13 = queue + 168;
        double result = (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, v3);
      }
      *uint64_t v13 = 0;
      return result;
    case 8:
      *(unsigned char *)(result + 64) = 0;
      if (queue[121])
      {
        double result = *((void *)queue + 3);
        if (!result) {
          goto LABEL_38;
        }
        double result = CFArrayGetCount((CFArrayRef)result);
        if (!result) {
          goto LABEL_38;
        }
      }
      goto LABEL_40;
    case 9:
      LOBYTE(v5) = queue[184];
      goto LABEL_39;
    case 0xA:
      double result = CMBufferQueueGetBufferCount((CMBufferQueueRef)queue);
      BOOL v6 = result < *(void *)(v3 + 56);
LABEL_23:
      LOBYTE(v5) = v6;
      goto LABEL_39;
    case 0xB:
      goto LABEL_27;
    case 0xC:
      CMTime time1 = *(CMTime *)(queue + 124);
      CMTime v14 = *(CMTime *)(result + 28);
      double result = CMTimeCompare(&time1, &v14);
      if ((result & 0x80000000) != 0) {
        goto LABEL_33;
      }
LABEL_27:
      double result = CMBufferQueueGetBufferCount((CMBufferQueueRef)queue);
      BOOL v7 = result <= *(void *)(v3 + 56);
LABEL_28:
      LOBYTE(v5) = !v7;
      goto LABEL_39;
    case 0xD:
      goto LABEL_34;
    case 0xE:
      double result = CMBufferQueueGetTotalSize((CMBufferQueueRef)queue);
      LOBYTE(v5) = (unint64_t)result > *(void *)(v3 + 56);
      goto LABEL_39;
    case 0xF:
      CMTime time1 = *(CMTime *)(queue + 124);
      CMTime v14 = *(CMTime *)(result + 28);
      double result = CMTimeCompare(&time1, &v14);
      if ((int)result > 0) {
        goto LABEL_33;
      }
LABEL_34:
      double result = CMBufferQueueGetTotalSize((CMBufferQueueRef)queue);
      LOBYTE(v5) = (unint64_t)result < *(void *)(v3 + 56);
      goto LABEL_39;
    default:
      double result = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
LABEL_33:
      LOBYTE(v5) = 0;
      goto LABEL_39;
  }
}

uint64_t figAudioDeviceClockCreateCommon(uint64_t a1, uint64_t a2, int a3, CFTypeRef *a4)
{
  uint64_t v23 = 0;
  int v24 = &v23;
  uint64_t v25 = 0x2000000000;
  int v26 = 0;
  CFTypeRef cf = 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFADCTrace[1], @"fadc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFADCTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1E9272E78, @"fadc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1E9272E70);
  if (!a4)
  {
    uint64_t v16 = 4294954551;
LABEL_17:
    uint64_t v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v24 + 6) = v14;
    if (v14) {
      goto LABEL_12;
    }
LABEL_18:
    *a4 = cf;
    goto LABEL_19;
  }
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  CMTimeMake(&v21, 1, 2);
  uint64_t TimeCallback = FigDerivedClockCreateWithGetTimeCallback(a1, gFigAudioDeviceClockCallbacks, HostTimeClock, (long long *)&v21.value, 1, (uint64_t *)&cf);
  *((_DWORD *)v24 + 6) = TimeCallback;
  if (TimeCallback)
  {
LABEL_15:
    uint64_t v14 = TimeCallback;
    goto LABEL_12;
  }
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)cf);
  dispatch_queue_t v11 = dispatch_queue_create("com.apple.coremedia.audiodeviceclock", 0);
  *(void *)(DerivedStorage + 128) = v11;
  if (!v11
    || (char v12 = FigReadWriteLockCreate(0), (*(void *)(DerivedStorage + 136) = v12) == 0)
    || (*(_DWORD *)(DerivedStorage + 120) = 0,
        uint64_t v13 = FigReadWriteLockCreate(0),
        (*(void *)(DerivedStorage + 64) = v13) == 0))
  {
    uint64_t v16 = 4294954549;
    goto LABEL_17;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figAudioDeviceClockCreateCommon_block_invoke;
  block[3] = &unk_1E5677B10;
  block[4] = &v23;
  if (figAudioDeviceClockCreateCommon_fadcInitWeakReferenceTableOnce != -1) {
    dispatch_once(&figAudioDeviceClockCreateCommon_fadcInitWeakReferenceTableOnce, block);
  }
  uint64_t v14 = *((unsigned int *)v24 + 6);
  if (v14) {
    goto LABEL_12;
  }
  *(void *)(DerivedStorage + 144) = 0;
  uint64_t TimeCallback = FigCFWeakReferenceTableAddValueAndGetKey(gFigAudioDeviceClockRegistry, (uint64_t)cf, (void *)(DerivedStorage + 144));
  *((_DWORD *)v24 + 6) = TimeCallback;
  if (TimeCallback) {
    goto LABEL_15;
  }
  FigGetHostTimeToNanosecondsScale((void *)(DerivedStorage + 16), (void *)(DerivedStorage + 24));
  *(void *)(DerivedStorage + 104) = 0;
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  v18[2] = __figAudioDeviceClockCreateCommon_block_invoke_2;
  void v18[3] = &unk_1E5677B38;
  int v19 = a3;
  v18[4] = &v23;
  v18[5] = cf;
  v18[6] = a2;
  uint64_t v15 = writeProtectedStorageSync((uint64_t)cf, (uint64_t)v18);
  uint64_t v14 = *((unsigned int *)v24 + 6);
  if (!v14)
  {
    *((_DWORD *)v24 + 6) = v15;
    uint64_t v14 = v15;
    if (!v15) {
      goto LABEL_18;
    }
  }
LABEL_12:
  if (cf)
  {
    CFRelease(cf);
    uint64_t v14 = *((unsigned int *)v24 + 6);
  }
LABEL_19:
  _Block_object_dispose(&v23, 8);
  return v14;
}

uint64_t FigDerivedClockGetDerivedStorage(uint64_t a1)
{
  if (a1) {
    return a1 + 208;
  }
  FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t fadcSetAudioDeviceUID(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  unsigned int v5 = *(const void **)(DerivedStorage + 80);
  *(void *)(DerivedStorage + 80) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (in_audio_mx_server_process())
  {
    if (a2)
    {
      long long inAddress = *(unint64_t *)"diudbolg";
      inQualifierData = a2;
      outData = (AudioObjectPropertyAddress *)&inQualifierData;
      uint64_t v13 = 8;
      uint64_t v14 = (char *)&inAddress + 12;
      uint64_t v15 = 4;
      UInt32 ioDataSize = 32;
      uint64_t PropertyData = AudioObjectGetPropertyData(1u, (const AudioObjectPropertyAddress *)&inAddress, 0, 0, &ioDataSize, &outData);
      if (!HIDWORD(inAddress))
      {
        v9.mElement = 0;
        UInt32 ioDataSize = 4;
        *(void *)&v9.mSelector = *(void *)"cdiubolg";
        uint64_t PropertyData = AudioObjectGetPropertyData(1u, &v9, 8u, &inQualifierData, &ioDataSize, (char *)&inAddress + 12);
      }
      if (PropertyData) {
        FigSignalErrorAt(PropertyData, 0, 0, 0, 0, 0, 0);
      }
      int v7 = HIDWORD(inAddress);
      if (!HIDWORD(inAddress)) {
        return 4294954550;
      }
    }
    else
    {
      *(unsigned char *)(DerivedStorage + 72) = 1;
      long long inAddress = *(unint64_t *)"diudbolg";
      *(void *)&v9.mSelector = @"VirtualAudioDevice_Default";
      outData = &v9;
      uint64_t v13 = 8;
      uint64_t v14 = (char *)&inAddress + 12;
      uint64_t v15 = 4;
      LODWORD(inQualifierData) = 32;
      if (AudioObjectGetPropertyData(1u, (const AudioObjectPropertyAddress *)&inAddress, 0, 0, (UInt32 *)&inQualifierData, &outData)|| (int v7 = HIDWORD(inAddress)) == 0)
      {
        FigSignalErrorAt(4294967195, 0, 0, 0, 0, 0, 0);
        int v7 = HIDWORD(inAddress);
      }
    }
    return switchToNewDeviceID(a1, v7);
  }
  else
  {
    uint64_t result = 0;
    *(unsigned char *)(DerivedStorage + 72) = 1;
    *(unsigned char *)uint64_t DerivedStorage = 0;
  }
  return result;
}

uint64_t switchToNewDeviceID(uint64_t a1, int a2)
{
  FigDerivedClockGetDerivedStorage(a1);
  if (!a2) {
    return 4294954550;
  }
  FigDerivedClockDiscontinuityOccurred(a1);
  removeAllTracesOfDevice(a1);
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  *(_DWORD *)(DerivedStorage + 88) = a2;
  uint64_t v5 = addPropertyListener(a1, 0x676F696Eu);
  if (v5) {
    goto LABEL_8;
  }
  uint64_t v5 = addPropertyListener(a1, 0x6F766572u);
  if (v5) {
    goto LABEL_8;
  }
  uint64_t v5 = addPropertyListener(a1, 0x6E737274u);
  if (v5) {
    goto LABEL_8;
  }
  int v10 = 0;
  uint64_t v9 = *(void *)"niog****";
  uint64_t v5 = propertyListenerDispatch(a1, &v9);
  char v6 = 0;
  if (!*(unsigned char *)(DerivedStorage + 1))
  {
    uint64_t v7 = FigDerivedClockGetDerivedStorage(a1);
    char v6 = FigAudioDeviceSupportsPresentationTime(*(_DWORD *)(v7 + 88));
  }
  *(unsigned char *)(DerivedStorage + 112) = v6;
  if (v5) {
LABEL_8:
  }
    removeAllTracesOfDevice(a1);
  return v5;
}

void FigDerivedClockDiscontinuityOccurred(uint64_t a1)
{
  if (a1)
  {
    FigAtomicIncrement32((atomic_uint *)(a1 + 200));
    FigMemoryBarrier();
  }
}

uint64_t removeAllTracesOfDevice(uint64_t a1)
{
  uint64_t result = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v3 = result;
  if (*(_DWORD *)(result + 88))
  {
    removePropertyListener(a1, 0x676F696Eu);
    removePropertyListener(a1, 0x6F766572u);
    uint64_t result = removePropertyListener(a1, 0x6E737274u);
  }
  *(_DWORD *)(v3 + 88) = 0;
  *(unsigned char *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 104) = 0;
  return result;
}

uint64_t addPropertyListener(uint64_t a1, AudioObjectPropertySelector a2)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v4 = DerivedStorage;
  if (a2 == 1735354734 || a2 == 1870030194 || a2 == 1853059700)
  {
    AudioObjectID v5 = *(_DWORD *)(DerivedStorage + 88);
  }
  else
  {
    uint64_t v6 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    AudioObjectID v5 = 0;
    if (v6) {
      return v6;
    }
  }
  inAddress.mSelector = a2;
  *(void *)&inAddress.mScope = 707406378;
  uint64_t v7 = AudioObjectAddPropertyListener(v5, &inAddress, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(v4 + 144));
  if (v7) {
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  else {
    return 0;
  }
}

uint64_t propertyListenerDispatch(uint64_t a1, const AudioObjectPropertyAddress *a2)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v5 = DerivedStorage;
  AudioObjectPropertySelector mSelector = a2->mSelector;
  if (a2->mSelector != 1735354734)
  {
    if (mSelector == 1853059700)
    {
      if (*(unsigned char *)DerivedStorage) {
        switchToNewDeviceID(a1, *(_DWORD *)(DerivedStorage + 88));
      }
    }
    else if (mSelector == 1870030194)
    {
      FigDerivedClockDiscontinuityOccurred(a1);
    }
    else
    {
      FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  uint64_t v13 = 0;
  int outData = 0;
  UInt32 ioDataSize = 4;
  uint64_t PropertyData = AudioObjectGetPropertyData(*(_DWORD *)(DerivedStorage + 88), a2, 0, 0, &ioDataSize, &outData);
  if (PropertyData) {
    return FigSignalErrorAt(PropertyData, 0, 0, 0, 0, 0, 0);
  }
  if (!outData)
  {
    if (*(unsigned char *)v5)
    {
      *(unsigned char *)uint64_t v5 = 0;
      FigDerivedClockDiscontinuityOccurred(a1);
      uint64_t v9 = 0;
      *(void *)(v5 + 104) = 0;
      return v9;
    }
    return 0;
  }
  if (*(unsigned char *)v5) {
    return 0;
  }
  AudioObjectPropertyAddress v12 = *a2;
  v12.AudioObjectPropertySelector mSelector = 1853059700;
  UInt32 ioDataSize = 8;
  uint64_t v8 = AudioObjectGetPropertyData(*(_DWORD *)(v5 + 88), &v12, 0, 0, &ioDataSize, &v13);
  uint64_t v9 = v8;
  if (v8)
  {
    FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v11 = v13;
    *(void *)(v5 + 8) = v13;
    *(float64x2_t *)(v5 + 32) = vdivq_f64((float64x2_t)vdupq_lane_s64(v11, 0), (float64x2_t)xmmword_18FE957A0);
    *(double *)(v5 + 48) = *(double *)&v11
                         * (double)*(uint64_t *)(v5 + 16)
                         / (double)(1000000000 * *(void *)(v5 + 24));
    *(unsigned char *)uint64_t v5 = 1;
  }
  return v9;
}

uint64_t FigTimebaseSetTime(OpaqueCMTimebase *a1, CMTime *a2)
{
  CMTime v3 = *a2;
  return CMTimebaseSetTime(a1, &v3);
}

uint64_t FigTimebaseSetAnchorTime(OpaqueCMTimebase *a1, CMTime *a2, CMTime *a3)
{
  CMTime timebaseTime = *a2;
  CMTime v4 = *a3;
  return CMTimebaseSetAnchorTime(a1, &timebaseTime, &v4);
}

CFTypeRef cfDataFigTimeRetain(int a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

uint64_t FigClockGetTransformRelativeToHostTimeClock(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v23 = 0u;
  if (a1) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v6 = v5;
  if (v5)
  {
    uint64_t v7 = 4294954551;
LABEL_23:
    uint64_t TransformRelativeToReferenceClock = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (!*(unsigned char *)(a1 + 41))
  {
    uint64_t v7 = 4294954550;
    goto LABEL_23;
  }
  long long v25 = *(_OWORD *)&kCMTimeZero.value;
  uint64_t v26 = 0;
  long long v23 = *(_OWORD *)&kCMTimeZero.value;
  *(void *)&long long v24 = 0;
  *((void *)&v24 + 1) = 0x3FF0000000000000;
  if (CMClockGetHostTimeClock() == (CMClockRef)a1 || CMClockGetHostTimeClock() == (CMClockRef)a1)
  {
LABEL_26:
    uint64_t v14 = 0;
    long long v15 = v24;
    *(_OWORD *)a3 = v23;
    *(_OWORD *)(a3 + 16) = v15;
    *(_OWORD *)(a3 + 32) = v25;
    *(void *)(a3 + 48) = v26;
    goto LABEL_27;
  }
  uint64_t v9 = (void *)a1;
  while (1)
  {
    uint64_t v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v19 = 0u;
    uint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    uint64_t TransformRelativeToReferenceClock = FigClockGetTransformRelativeToReferenceClock((uint64_t)v9, a2, (uint64_t)v17);
    if (TransformRelativeToReferenceClock) {
      break;
    }
    long long v19 = v23;
    long long v20 = v24;
    long long v21 = v25;
    uint64_t v22 = v26;
    if (a2)
    {
      uint64_t v11 = v17;
      AudioObjectPropertyAddress v12 = &v19;
    }
    else
    {
      uint64_t v11 = &v19;
      AudioObjectPropertyAddress v12 = v17;
    }
    FigSyncCombineTransforms(v11, (uint64_t)v12, (uint64_t)&v23);
    uint64_t v14 = v13;
    if (v13) {
      goto LABEL_25;
    }
    uint64_t v9 = (void *)v9[4];
    if (!v9)
    {
      uint64_t v7 = 4294954543;
      goto LABEL_23;
    }
    if (v9 == (void *)CMClockGetHostTimeClock()) {
      goto LABEL_26;
    }
  }
LABEL_24:
  uint64_t v14 = TransformRelativeToReferenceClock;
LABEL_25:
  if (!v14) {
    goto LABEL_26;
  }
LABEL_27:
  if ((v6 & 1) == 0) {
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }
  return v14;
}

uint64_t FigClockGetTransformRelativeToReferenceClock(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  if (a3)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    if (*(unsigned char *)(a1 + 41))
    {
      if (CMClockGetHostTimeClock() == (CMClockRef)a1)
      {
        long long v17 = *(_OWORD *)&kCMTimeZero.value;
        uint64_t v18 = 0;
        long long v15 = *(_OWORD *)&kCMTimeZero.value;
        *(void *)&long long v16 = 0;
        *((void *)&v16 + 1) = 0x3FF0000000000000;
        goto LABEL_19;
      }
      if (a2)
      {
        char v6 = (CMTime *)&v15;
        uint64_t v7 = (OpaqueCMClock *)a1;
        uint64_t v8 = (CMTime *)&v17;
      }
      else
      {
        uint64_t v8 = (CMTime *)&v15;
        uint64_t v7 = (OpaqueCMClock *)a1;
        char v6 = (CMTime *)&v17;
      }
      uint64_t AnchorTime = CMClockGetAnchorTime(v7, v8, v6);
      if (AnchorTime) {
        goto LABEL_20;
      }
      uint64_t v11 = *(double (**)(uint64_t))(*(void *)(a1 + 24) + 40);
      if (!v11)
      {
        FigSignalErrorAt(4294967292, 0, 0, 0, 0, 0, 0);
        goto LABEL_19;
      }
      double v12 = v11(a1);
      *((double *)&v16 + 1) = v12;
      if (a2)
      {
LABEL_19:
        uint64_t AnchorTime = 0;
        long long v13 = v16;
        *(_OWORD *)a3 = v15;
        *(_OWORD *)(a3 + 16) = v13;
        *(_OWORD *)(a3 + 32) = v17;
        *(void *)(a3 + 48) = v18;
        goto LABEL_20;
      }
      if (v12 != 0.0)
      {
        *((double *)&v16 + 1) = 1.0 / v12;
        goto LABEL_19;
      }
      uint64_t v10 = 4294954541;
    }
    else
    {
      uint64_t v10 = 4294954550;
    }
    uint64_t AnchorTime = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    if (AnchorTime)
    {
LABEL_20:
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      return AnchorTime;
    }
    goto LABEL_19;
  }
  uint64_t AnchorTime = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  if (!AnchorTime) {
    goto LABEL_19;
  }
  return AnchorTime;
}

double fadcGetRate(void (*a1)(void))
{
  uint64_t DerivedStorage = (void (*)(void))FigDerivedClockGetDerivedStorage((uint64_t)a1);
  uint64_t v6 = 0;
  uint64_t v7 = (double *)&v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0x3FF0000000000000;
  v5[0] = (void (*)(void))MEMORY[0x1E4F143A8];
  v5[1] = (void (*)(void))0x40000000;
  v5[2] = (void (*)(void))__fadcGetRate_block_invoke;
  v5[3] = (void (*)(void))&unk_1E5677C18;
  v5[5] = DerivedStorage;
  v5[6] = a1;
  v5[4] = (void (*)(void))&v6;
  readProtectedStorageSync((uint64_t)a1, v5);
  double v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t FigTimebaseSetTimerNextFireTime(OpaqueCMTimebase *a1, __CFRunLoopTimer *a2, CMTime *a3)
{
  CMTime v4 = *a3;
  return CMTimebaseSetTimerNextFireTime(a1, a2, &v4, 0);
}

void cfDataFigTimeRelease(int a1, CFTypeRef cf)
{
}

void rescheduleTimer(__CFRunLoopTimer *a1, __CFRunLoop *a2, CMTime *a3, OpaqueCMTimebase *a4, CMTime *a5, int a6, char a7)
{
  memset(&v29, 0, sizeof(v29));
  memset(&v28, 0, sizeof(v28));
  int IsValid = CFRunLoopTimerIsValid(a1);
  if (a2 && IsValid)
  {
    double v15 = 8073216000.0;
    if ((a3->flags & 0x1D) != 1) {
      goto LABEL_21;
    }
    if (a3->timescale < 1) {
      goto LABEL_21;
    }
    double EffectiveRate = CMTimebaseGetEffectiveRate(a4);
    if (EffectiveRate == 0.0) {
      goto LABEL_21;
    }
    double v17 = EffectiveRate;
    int timescale = a3->timescale;
    if (timescale <= 1023)
    {
      do
      {
        CMTimeValue value = a3->value;
        if ((unint64_t)(a3->value + 0x3FFFFFFFFFFFFFFFLL) > 0x7FFFFFFFFFFFFFFDLL) {
          break;
        }
        memset(&time, 0, sizeof(time));
        CMTimeMake(&time, 2 * value, 2 * timescale);
        *a3 = time;
        int timescale = a3->timescale;
      }
      while (timescale < 1024);
    }
    CMClockRef HostTimeClock = CMClockGetHostTimeClock();
    CMTime time = *a3;
    CMSyncConvertTime(&v29, &time, a4, HostTimeClock);
    double Current = CFAbsoluteTimeGetCurrent();
    memset(&time, 0, sizeof(time));
    uint64_t v22 = CMClockGetHostTimeClock();
    CMClockGetTime(&time, v22);
    BOOL v23 = 1;
    if (v17 <= 0.0 || (time1 = *a3, CMTime v25 = *a5, (CMTimeCompare(&time1, &v25) & 0x80000000) == 0))
    {
      if (v17 >= 0.0 || (time1 = *a3, CMTime v25 = *a5, CMTimeCompare(&time1, &v25) < 1)) {
        BOOL v23 = 0;
      }
    }
    CMTime time1 = v29;
    CMTime v25 = time;
    CMTimeSubtract(&v28, &time1, &v25);
    CMTime time1 = v28;
    double Seconds = CMTimeGetSeconds(&time1);
    if ((a7 & 1) == 0 && v23)
    {
      if (!a6)
      {
        double v15 = 8073216000.0;
        goto LABEL_21;
      }
      if (a6 == 1) {
        return;
      }
    }
    double v15 = Current + Seconds;
LABEL_21:
    CFRunLoopTimerSetNextFireDate(a1, v15);
    CFRunLoopWakeUp(a2);
  }
}

uint64_t sBufCreate(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, void *a5)
{
  if (a5)
  {
    if (a2)
    {
      if ((a2 & 0x8000000000000000) != 0) {
        goto LABEL_31;
      }
      if (a2 > 0x38E38E38E38E38ELL) {
        goto LABEL_31;
      }
      unint64_t v10 = 72 * a2;
      if (!(72 * a2)) {
        goto LABEL_31;
      }
      if (a3)
      {
LABEL_7:
        if ((a3 & 0x8000000000000000) != 0) {
          goto LABEL_31;
        }
        if (a3 >> 61) {
          goto LABEL_31;
        }
        uint64_t v11 = 8 * a3;
        if (!(8 * a3)) {
          goto LABEL_31;
        }
        if (a4)
        {
LABEL_11:
          if ((a4 & 0x8000000000000000) != 0) {
            goto LABEL_31;
          }
          if (a4 >> 60) {
            goto LABEL_31;
          }
          uint64_t v12 = 16 * a4;
          if (!(16 * a4)) {
            goto LABEL_31;
          }
          goto LABEL_21;
        }
LABEL_20:
        uint64_t v12 = 0;
LABEL_21:
        if (v10 < 0xFFFFFFFFFFFFFEA0)
        {
          unint64_t v14 = v10 + 359;
          unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFF8;
          if (!__CFADD__(v11, v14 & 0xFFFFFFFFFFFFFFF8))
          {
            unint64_t v16 = (v11 + v14) & 0xFFFFFFFFFFFFFFF8;
            if (!__CFADD__(v12, v16))
            {
              FigThreadRunOnce(&sRegisterFigSampleBufferTypeOnce, (void (*)(void))registerFigSampleBufferType);
              uint64_t Instance = (void *)_CFRuntimeCreateInstance();
              if (Instance)
              {
                uint64_t v18 = Instance;
                long long v19 = Instance + 44;
                if (!a2) {
                  long long v19 = 0;
                }
                Instance[11] = a2;
                Instance[12] = v19;
                long long v20 = (char *)Instance + v15;
                if (!a3) {
                  long long v20 = 0;
                }
                Instance[13] = a3;
                Instance[14] = v20;
                uint64_t result = 0;
                if (a4)
                {
                  v18[41] = (char *)v18 + v16;
                  v18[42] = a4;
                  *((unsigned char *)v18 + 344) = 0;
                }
                goto LABEL_32;
              }
            }
          }
        }
LABEL_31:
        uint64_t result = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
        uint64_t v18 = 0;
LABEL_32:
        *a5 = v18;
        return result;
      }
    }
    else
    {
      unint64_t v10 = 0;
      if (a3) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = 0;
    if (a4) {
      goto LABEL_11;
    }
    goto LABEL_20;
  }
  return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
}

uint64_t registerFigSampleBufferType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigSampleBufferID = result;
  return result;
}

double sBufInit(_OWORD *a1)
{
  double result = 0.0;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

__n128 sbufUpdateCachedTimestamps(uint64_t a1, __n128 result)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2 >= 1)
  {
    uint64_t v4 = *(void *)(a1 + 96);
    uint64_t v5 = *(void *)(v4 + 64);
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(v4 + 48);
    *(void *)(a1 + 176) = v5;
    uint64_t v6 = *(void *)(v4 + 40);
    *(_OWORD *)(a1 + 184) = *(_OWORD *)(v4 + 24);
    *(void *)(a1 + 200) = v6;
    if (v2 == 1)
    {
      uint64_t v7 = *(void *)(a1 + 80);
      uint64_t v8 = (CMTime *)(a1 + 208);
      double result = *(__n128 *)v4;
      if (v7)
      {
        time.CMTimeEpoch epoch = *(void *)(v4 + 16);
        *(__n128 *)&time.CMTimeValue value = result;
        CMTimeMultiply(&time1, &time, v7);
        result.n128_u64[0] = time1.value;
        *uint64_t v8 = time1;
      }
      else
      {
        *(void *)(a1 + 224) = *(void *)(v4 + 16);
        *(__n128 *)&v8->CMTimeValue value = result;
      }
    }
    else
    {
      uint64_t v9 = 0;
      unint64_t v10 = (_OWORD *)(a1 + 160);
      uint64_t v11 = (_OWORD *)(a1 + 184);
      __n128 v12 = *(__n128 *)v4;
      long long v13 = (_OWORD *)(a1 + 208);
      *(void *)(a1 + 224) = *(void *)(v4 + 16);
      *(__n128 *)(a1 + 208) = v12;
      uint64_t v14 = 1;
      do
      {
        uint64_t v15 = *(void *)(a1 + 96) + v9;
        long long v16 = *(_OWORD *)(v15 + 96);
        time1.CMTimeEpoch epoch = *(void *)(v15 + 112);
        *(_OWORD *)&time1.CMTimeValue value = v16;
        *(_OWORD *)&time.CMTimeValue value = *v11;
        time.CMTimeEpoch epoch = *(void *)(a1 + 200);
        int32_t v17 = CMTimeCompare(&time1, &time);
        uint64_t v18 = *(void *)(a1 + 96);
        if (v17 < 0)
        {
          long long v19 = *(_OWORD *)(v18 + v9 + 96);
          *(void *)(a1 + 200) = *(void *)(v18 + v9 + 112);
          _OWORD *v11 = v19;
        }
        uint64_t v20 = v18 + v9;
        long long v21 = *(_OWORD *)(v20 + 120);
        time1.CMTimeEpoch epoch = *(void *)(v20 + 136);
        *(_OWORD *)&time1.CMTimeValue value = v21;
        *(_OWORD *)&time.CMTimeValue value = *v10;
        time.CMTimeEpoch epoch = *(void *)(a1 + 176);
        int32_t v22 = CMTimeCompare(&time1, &time);
        uint64_t v23 = *(void *)(a1 + 96);
        if (v22 < 0)
        {
          long long v24 = *(_OWORD *)(v23 + v9 + 120);
          *(void *)(a1 + 176) = *(void *)(v23 + v9 + 136);
          *unint64_t v10 = v24;
        }
        uint64_t v25 = v23 + v9;
        *(_OWORD *)&time.CMTimeValue value = *v13;
        time.CMTimeEpoch epoch = *(void *)(a1 + 224);
        long long v26 = *(_OWORD *)(v25 + 72);
        v27.CMTimeEpoch epoch = *(void *)(v25 + 88);
        *(_OWORD *)&v27.CMTimeValue value = v26;
        CMTimeAdd(&time1, &time, &v27);
        result.n128_u64[0] = time1.value;
        *long long v13 = *(_OWORD *)&time1.value;
        *(void *)(a1 + 224) = time1.epoch;
        ++v14;
        v9 += 72;
      }
      while (v14 < *(void *)(a1 + 88));
    }
  }
  return result;
}

size_t figSampleBufferCheckDataSize(size_t result)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(result + 25))
  {
    size_t v1 = result;
    if (!*(_DWORD *)(result + 28))
    {
      double result = *(void *)(result + 16);
      if (result)
      {
        uint64_t v2 = *(void *)(v1 + 104);
        if (v2)
        {
          if (v2 == 1)
          {
            uint64_t v3 = **(void **)(v1 + 112) * *(void *)(v1 + 80);
          }
          else
          {
            if (v2 < 1) {
              return result;
            }
            uint64_t v3 = 0;
            uint64_t v4 = *(uint64_t **)(v1 + 112);
            do
            {
              uint64_t v5 = *v4++;
              v3 += v5;
              --v2;
            }
            while (v2);
          }
          if (v3)
          {
            double result = CMBlockBufferGetDataLength((CMBlockBufferRef)result);
            if (v3 != result)
            {
              v13[0] = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E30, 0, v13, &type);
              int v7 = v13[0];
              if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
                unsigned int v9 = v7;
              }
              else {
                unsigned int v9 = v7 & 0xFFFFFFFE;
              }
              if (v9)
              {
                size_t DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(v1 + 16));
                v13[1] = 136315906;
                uint64_t v14 = "figSampleBufferCheckDataSize";
                __int16 v15 = 2048;
                size_t v16 = v1;
                __int16 v17 = 2048;
                uint64_t v18 = v3;
                __int16 v19 = 2048;
                size_t v20 = DataLength;
                uint64_t v11 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v7) = v13[0];
              }
              else
              {
                uint64_t v11 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E30, 0, 0, v11, v11 != &v21, v7, 0, v8);
              return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

void FigAttachmentsRegisterCVBuffer()
{
  TypeID = (const void *)CVPixelBufferGetTypeID();

  FigRuntimeRegisterAttachmentBearerWithTypeID(sFigCVBufferAttachmentBearerCallbacks, TypeID);
}

CFDictionaryRef FigRuntimeGetAttachmentBearerCallbacksWithTypeID(const void *a1)
{
  FigThreadRunOnce(&sFigAttachmentsRegisterInternalBearersOnce, figAttachmentsRegisterInternalBearers);
  CFDictionaryRef result = (const __CFDictionary *)sFigAttachmentBearerCallbacksPerTypeID;
  if (sFigAttachmentBearerCallbacksPerTypeID)
  {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a1);
  }
  return result;
}

CFDictionaryRef sBufGetAttachment(uint64_t a1, void *key, _DWORD *a3)
{
  if (*(unsigned char *)(a1 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else
  {
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 312);
    if (v7 && (CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(v7, key)) != 0)
    {
      if (a3) {
        *a3 = 1;
      }
    }
    else
    {
      CFDictionaryRef result = *(const __CFDictionary **)(a1 + 320);
      if (result)
      {
        CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, key);
        if (a3)
        {
          if (result) {
            *a3 = 0;
          }
        }
      }
    }
  }
  return result;
}

double sBufSetAttachment(__CFDictionary **cf, void *key, void *value, int a4)
{
  if (a4 == 1) {
    uint64_t v4 = 39;
  }
  else {
    uint64_t v4 = 40;
  }
  if (a4 == 1) {
    uint64_t v5 = cf + 39;
  }
  else {
    uint64_t v5 = cf + 40;
  }
  if (a4 == 1) {
    uint64_t v6 = cf + 40;
  }
  else {
    uint64_t v6 = cf + 39;
  }
  if (*((unsigned char *)cf + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFMutableDictionaryRef Mutable = *v5;
    if (*v5
      || (CFAllocatorRef v12 = CFGetAllocator(cf),
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]),
          (cf[v4] = Mutable) != 0))
    {
      if (value) {
        CFDictionarySetValue(Mutable, key, value);
      }
      else {
        CFDictionaryRemoveValue(Mutable, key);
      }
    }
    if (*v6) {
      CFDictionaryRemoveValue(*v6, key);
    }
    return checkCacheKeys((uint64_t)cf, key);
  }
  return result;
}

double checkCacheKeys(uint64_t a1, CFTypeRef cf1)
{
  if (CFEqual(cf1, @"TrimDurationAtStart")
    || CFEqual(cf1, @"TrimDurationAtEnd")
    || CFEqual(cf1, @"SpeedMultiplier")
    || CFEqual(cf1, @"Reverse"))
  {
    double result = *(double *)&kCMTimeInvalid.value;
    *(_OWORD *)(a1 + 232) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(a1 + 248) = 0;
    *(_OWORD *)(a1 + 256) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(a1 + 272) = 0;
    *(_OWORD *)(a1 + 280) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(a1 + 296) = 0;
  }
  return result;
}

uint64_t bufQInsertElementAtIndex(uint64_t a1, CFIndex a2, const void *a3)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (!a2) {
    bufQStopListeningForHeadBufferBecomingReady(a1);
  }
  if (*(unsigned char *)(a1 + 120))
  {
    if (!*(void *)(a1 + 68))
    {
LABEL_21:
      (*(void (**)(CMTime *__return_ptr, const void *, void))(a1 + 76))(&v20, a3, *(void *)(a1 + 52));
      goto LABEL_23;
    }
  }
  else if (!*(void *)(a1 + 64))
  {
    goto LABEL_22;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  memset(&v20, 0, sizeof(v20));
  if (*(unsigned char *)(a1 + 120)) {
    (*(void (**)(CMTime *__return_ptr, const void *, void))(a1 + 68))(&v20, a3, *(void *)(a1 + 52));
  }
  else {
    (*(void (**)(CMTime *__return_ptr))(*(void *)(a1 + 64) + 16))(&v20);
  }
  if (Count < 1)
  {
    *(_OWORD *)(a1 + 240) = *(_OWORD *)&kCMTimeZero.value;
    *(void *)(a1 + 256) = 0;
    *(_OWORD *)(a1 + 216) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(a1 + 232) = 0;
  }
  else if (v20.flags & 1) != 0 && (*(unsigned char *)(a1 + 228))
  {
    CMTime time1 = v20;
    CMTime time2 = *(CMTime *)(a1 + 216);
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      memset(&time1, 0, sizeof(time1));
      CMTime time2 = *(CMTime *)(a1 + 216);
      CMTime rhs = v20;
      CMTimeSubtract(&time1, &time2, &rhs);
      CMTime rhs = *(CMTime *)(a1 + 240);
      CMTime v16 = time1;
      CMTimeMaximum(&time2, &rhs, &v16);
      *(CMTime *)(a1 + 240) = time2;
    }
  }
  CFDictionaryRef v7 = (_OWORD *)(a1 + 216);
  if ((*(unsigned char *)(a1 + 228) & 1) == 0
    || (v20.flags & 1) != 0
    && (CMTime time1 = v20,
        *(_OWORD *)&time2.CMTimeValue value = *v7,
        time2.CMTimeEpoch epoch = *(void *)(a1 + 232),
        CMTimeCompare(&time1, &time2) >= 1))
  {
    *CFDictionaryRef v7 = *(_OWORD *)&v20.value;
    *(void *)(a1 + 232) = v20.epoch;
  }
  if (*(unsigned char *)(a1 + 120)) {
    goto LABEL_21;
  }
LABEL_22:
  (*(void (**)(CMTime *__return_ptr))(*(void *)(a1 + 72) + 16))(&v20);
LABEL_23:
  *(_OWORD *)&rhs.CMTimeValue value = *(_OWORD *)&v20.value;
  if (v20.epoch) {
    FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  }
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), a2, a3);
  CMTime time1 = *(CMTime *)(a1 + 124);
  *(_OWORD *)&time2.CMTimeValue value = *(_OWORD *)&rhs.value;
  time2.CMTimeEpoch epoch = 0;
  CMTimeAdd(&v20, &time1, &time2);
  *(CMTime *)(a1 + 124) = v20;
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v8 = *(uint64_t (**)(const void *, void))(a1 + 108);
    if (!v8) {
      goto LABEL_31;
    }
    uint64_t v9 = v8(a3, *(void *)(a1 + 52));
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 104);
    if (!v10) {
      goto LABEL_31;
    }
    uint64_t v9 = (*(uint64_t (**)(uint64_t, const void *))(v10 + 16))(v10, a3);
  }
  uint64_t v11 = v9;
  FigCFDictionarySetInt64(*(void **)(a1 + 32), a3, v9);
  *(void *)(a1 + 152) += v11;
LABEL_31:
  if ((*(_DWORD *)(a1 + 136) & 0x1D) != 1)
  {
    CMBufferQueueGetMaxPresentationTimeStamp(&lhs, (CMBufferQueueRef)a1);
    CMBufferQueueGetMinPresentationTimeStamp(&v14, (CMBufferQueueRef)a1);
    CMTimeSubtract(&v20, &lhs, &v14);
    *(CMTime *)(a1 + 124) = v20;
  }
  if (!a2) {
    bufQStartListeningForHeadBufferBecomingReady(a1);
  }
  *(unsigned char *)(a1 + 184) = 0;
  CFSetRef v12 = *(const __CFSet **)(a1 + 160);
  if (v12) {
    CFSetApplyFunction(v12, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a1);
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

uint64_t bufQStopListeningForHeadBufferBecomingReady(uint64_t result)
{
  uint64_t v1 = result;
  if (*(unsigned char *)(result + 120))
  {
    if (!*(void *)(result + 84)) {
      return result;
    }
    uint64_t v2 = (const __CFString **)(result + 100);
  }
  else
  {
    if (!*(void *)(result + 80)) {
      return result;
    }
    uint64_t v2 = (const __CFString **)(result + 96);
  }
  CFStringRef v3 = *v2;
  if (*v2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(result + 16));
    if (*(void *)(v1 + 176))
    {
      CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterRemoveListener(DefaultLocalCenter, (const void *)v1, (int)bufQDataBecameReady, v3, *(void **)(v1 + 176));
      *(void *)(v1 + 176) = 0;
    }
    uint64_t v5 = *(pthread_mutex_t **)(v1 + 16);
    return FigReentrantMutexUnlock(v5);
  }
  return result;
}

uint64_t FigDeferNotificationToRunLoop(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, __CFRunLoop *a7, CFAllocatorRef allocator)
{
  memset(&v25, 0, sizeof(v25));
  CMTime v16 = (const void **)CFAllocatorAllocate(allocator, 64, 0);
  if (v16)
  {
    __int16 v17 = v16;
    *CMTime v16 = a2;
    v16[1] = a1;
    v16[2] = a3;
    v16[3] = a4;
    v16[4] = a5;
    v16[5] = a6;
    v16[6] = allocator;
    v25.mach_timebase_info info = v16;
    v25.release = (void (__cdecl *)(const void *))figDeferredNotificationRelease;
    if (a2)
    {
      CFRetain(a2);
      a4 = v17[3];
    }
    if (a4) {
      CFRetain(a4);
    }
    uint64_t v18 = v17[5];
    if (v18) {
      CFRetain(v18);
    }
    __int16 v19 = v17[6];
    if (v19) {
      CFRetain(v19);
    }
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFRunLoopTimerRef v21 = CFRunLoopTimerCreate(allocator, Current, 0.0, 0, 0, (CFRunLoopTimerCallBack)figDeferredNotificationRun, &v25);
    if (v21)
    {
      uint64_t v22 = v21;
      CFRetain(v21);
      CFRunLoopAddTimer(a7, v22, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
      CFRunLoopAddTimer(a7, v22, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
      CFRunLoopAddTimer(a7, v22, @"FigDeferredNotificationMode");
      CFRelease(v22);
      CFRunLoopWakeUp(a7);
      return 0;
    }
    else
    {
      uint64_t v23 = FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
      figDeferredNotificationRelease(v17);
    }
    return v23;
  }
  else
  {
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  }
}

void *findBestTimeStamp(uint64_t a1, uint64_t *a2)
{
  memset(&v11, 0, sizeof(v11));
  double result = ((void *(*)(CMTime *__return_ptr, uint64_t, uint64_t))a2[1])(&v11, a1, a2[2]);
  if (v11.flags)
  {
    uint64_t v4 = (long long *)*a2;
    if ((*(unsigned char *)(*a2 + 12) & 1) == 0) {
      goto LABEL_5;
    }
    if (*((unsigned char *)a2 + 24))
    {
      CMTime time1 = v11;
      long long v5 = *v4;
      v9.CMTimeEpoch epoch = *((void *)v4 + 2);
      *(_OWORD *)&v9.CMTimeValue value = v5;
      double result = (void *)CMTimeCompare(&time1, &v9);
      if ((int)result <= 0) {
        return result;
      }
      goto LABEL_5;
    }
    CMTime time1 = v11;
    long long v8 = *v4;
    v9.CMTimeEpoch epoch = *((void *)v4 + 2);
    *(_OWORD *)&v9.CMTimeValue value = v8;
    double result = (void *)CMTimeCompare(&time1, &v9);
    if ((result & 0x80000000) != 0)
    {
LABEL_5:
      uint64_t v6 = *a2;
      long long v7 = *(_OWORD *)&v11.value;
      *(void *)(v6 + 16) = v11.epoch;
      *(_OWORD *)uint64_t v6 = v7;
    }
  }
  return result;
}

CMTime *bufQGetEndPTS@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, CMTime *a3@<X8>)
{
  (*(void (**)(CMTime *__return_ptr, uint64_t, void))(a2 + 20))(&lhs, a1, *(void *)(a2 + 4));
  (*(void (**)(CMTime *__return_ptr, uint64_t, void))(a2 + 28))(&v7, a1, *(void *)(a2 + 4));
  return CMTimeAdd(a3, &lhs, &v7);
}

uint64_t FigTimebaseGetTransformRelativeToMasterAtHeight(pthread_mutex_t **a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = 4294954548;
  if (a1)
  {
    uint64_t v5 = a2 - 1;
    if (a2 >= 1)
    {
      if (a4)
      {
        long long v26 = *(_OWORD *)&kCMTimeZero.value;
        uint64_t v27 = 0;
        long long v24 = *(_OWORD *)&kCMTimeZero.value;
        *(void *)&long long v25 = 0;
        *((void *)&v25 + 1) = 0x3FF0000000000000;
        long long v8 = figTimebaseCopyTargetTimebase(a1);
        if (!v8) {
          goto LABEL_23;
        }
        CMTime v9 = v8;
        while (1)
        {
          uint64_t v23 = 0;
          long long v21 = 0u;
          long long v22 = 0u;
          long long v20 = 0u;
          uint64_t v19 = 0;
          memset(v18, 0, sizeof(v18));
          uint64_t TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster(v9, a3, (uint64_t)v18);
          if (TransformRelativeToMaster)
          {
            uint64_t v4 = TransformRelativeToMaster;
            goto LABEL_19;
          }
          long long v20 = v24;
          long long v21 = v25;
          long long v22 = v26;
          uint64_t v23 = v27;
          if (a3)
          {
            CMTime v11 = v18;
            CFSetRef v12 = &v20;
          }
          else
          {
            CMTime v11 = &v20;
            CFSetRef v12 = v18;
          }
          FigSyncCombineTransforms(v11, (uint64_t)v12, (uint64_t)&v24);
          uint64_t v4 = v13;
          if (v13) {
            goto LABEL_19;
          }
          CMTimebaseRef v14 = CMTimebaseCopySourceTimebase((CMTimebaseRef)v9);
          CFRelease(v9);
          if (v5)
          {
            if (!v14) {
              break;
            }
          }
          uint64_t v4 = 0;
          if (v5-- != 0)
          {
            CMTime v9 = (pthread_mutex_t **)v14;
            if (v14) {
              continue;
            }
          }
          goto LABEL_20;
        }
        uint64_t v4 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
        CMTime v9 = 0;
LABEL_19:
        CMTimebaseRef v14 = (CMTimebaseRef)v9;
LABEL_20:
        if (v14) {
          CFRelease(v14);
        }
        if (!v4)
        {
LABEL_23:
          uint64_t v4 = 0;
          long long v16 = v25;
          *(_OWORD *)a4 = v24;
          *(_OWORD *)(a4 + 16) = v16;
          *(_OWORD *)(a4 + 32) = v26;
          *(void *)(a4 + 48) = v27;
        }
      }
    }
  }
  return v4;
}

uint64_t FigFileByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a3)
  {
    uint64_t v6 = *(int **)(DerivedStorage + 8);
    return FigFileForkGetLengthAtOffset(v6, a2, a3);
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figDeferredNotificationRun(__CFRunLoopTimer *a1, void *a2)
{
  uint64_t v2 = (void (*)(void, void, void, void, void))a2[1];
  if (v2)
  {
    v2(*a2, a2[2], a2[3], a2[4], a2[5]);
    a2[1] = 0;
    CFRunLoopTimerInvalidate(a1);
    CFRelease(a1);
  }

  return FigAtomicIncrement32(&sFigDeferredNotificationRunSeed);
}

uint64_t bufQRemoveElementAtIndex(uint64_t a1)
{
  memset(&v13, 0, sizeof(v13));
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  bufQStopListeningForHeadBufferBecomingReady(a1);
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
  CFTypeRef v3 = CFRetain(ValueAtIndex);
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), 0);
  if (*(unsigned char *)(a1 + 120)) {
    (*(void (**)(CMTime *__return_ptr, CFTypeRef, void))(a1 + 76))(&v13, v3, *(void *)(a1 + 52));
  }
  else {
    (*(void (**)(CMTime *__return_ptr))(*(void *)(a1 + 72) + 16))(&v13);
  }
  CMTime lhs = *(CMTime *)(a1 + 124);
  CMTime rhs = v13;
  CMTimeSubtract(&time1, &lhs, &rhs);
  *(CMTime *)(a1 + 124) = time1;
  if (*(unsigned char *)(a1 + 120))
  {
    if (!*(void *)(a1 + 108)) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (*(void *)(a1 + 104))
  {
LABEL_6:
    time1.CMTimeValue value = 0;
    FigCFDictionaryGetInt64IfPresent(*(void *)(a1 + 32), v3, &time1);
    *(void *)(a1 + 152) -= time1.value;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v3);
  }
LABEL_7:
  uint64_t v4 = (_OWORD *)(a1 + 124);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count)
  {
    *(_OWORD *)&time1.CMTimeValue value = *v4;
    time1.CMTimeEpoch epoch = *(void *)(a1 + 140);
    *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
    lhs.CMTimeEpoch epoch = 0;
    if (!CMTimeCompare(&time1, &lhs))
    {
      _OWORD *v4 = *(_OWORD *)&kCMTimeZero.value;
      *(void *)(a1 + 140) = 0;
    }
  }
  else
  {
    _OWORD *v4 = *(_OWORD *)&kCMTimeZero.value;
    *(void *)(a1 + 140) = 0;
    *(void *)(a1 + 152) = 0;
  }
  if ((*(_DWORD *)(a1 + 136) & 0x1D) != 1)
  {
    CMBufferQueueGetMaxPresentationTimeStamp(&v9, (CMBufferQueueRef)a1);
    CMBufferQueueGetMinPresentationTimeStamp(&v8, (CMBufferQueueRef)a1);
    CMTimeSubtract(&time1, &v9, &v8);
    _OWORD *v4 = *(_OWORD *)&time1.value;
    *(void *)(a1 + 140) = time1.epoch;
  }
  bufQStartListeningForHeadBufferBecomingReady(a1);
  if (Count <= 1)
  {
    *(_OWORD *)(a1 + 240) = *(_OWORD *)&kCMTimeZero.value;
    *(void *)(a1 + 256) = 0;
    if (!Count)
    {
      *(_OWORD *)(a1 + 216) = *(_OWORD *)&kCMTimeInvalid.value;
      *(void *)(a1 + 232) = 0;
    }
  }
  CFSetRef v6 = *(const __CFSet **)(a1 + 160);
  if (v6) {
    CFSetApplyFunction(v6, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a1);
  }
  CFRelease(v3);
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

uint64_t FigAtomicAdd32(unsigned int a1, atomic_uint *a2)
{
  return atomic_fetch_add_explicit(a2, a1, memory_order_relaxed) + a1;
}

uint64_t coreAudioObjectPropertyListener(uint64_t a1, int a2, int *a3, void *a4)
{
  LODWORD(v5) = a2;
  id v6 = FigCFWeakReferenceTableCopyValue(gFigAudioDeviceClockRegistry, a4);
  if (v6)
  {
    CMTime v7 = v6;
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)v6);
    FigReadWriteLockLockForRead(*(void *)(DerivedStorage + 64));
    if (v5)
    {
      unsigned int v9 = 0;
      uint64_t v5 = v5;
      do
      {
        int v11 = *a3;
        a3 += 3;
        int v10 = v11;
        if (v11 == 1735354734)
        {
          v9 |= 4u;
        }
        else if (v10 == 1853059700)
        {
          v9 |= 8u;
        }
        else if (v10 == 1870030194)
        {
          v9 |= 2u;
        }
        else
        {
          FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
        }
        --v5;
      }
      while (v5);
      if ((v9 & 0xF) != 0)
      {
        FigAtomicBitOr32(v9, (atomic_uint *)(DerivedStorage + 56));
        v15[0] = MEMORY[0x1E4F143A8];
        v15[1] = 0x40000000;
        v15[2] = __coreAudioObjectPropertyListener_block_invoke;
        _OWORD v15[3] = &__block_descriptor_tmp_26_0;
        v15[4] = v7;
        CFRetain(v7);
        uint64_t v12 = FigDerivedClockGetDerivedStorage((uint64_t)v7);
        FigAtomicIncrement32((atomic_uint *)(v12 + 120));
        CMTime v13 = *(NSObject **)(v12 + 128);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = __writeProtectedStorageAsync_block_invoke;
        block[3] = &unk_1E5677BA0;
        block[4] = v15;
        void block[5] = v12;
        block[6] = v7;
        dispatch_async(v13, block);
      }
    }
    FigReadWriteLockUnlockForRead(*(void *)(DerivedStorage + 64));
    CFRelease(v7);
  }
  return 0;
}

void rescheduleValidAndRemoveInvalidTimers(CFDictionaryRef *a1, CMTime *a2, int a3)
{
  CFIndex Count = CFDictionaryGetCount(a1[35]);
  if (Count)
  {
    uint64_t v7 = Count;
    if (Count == CFDictionaryGetCount(a1[37]))
    {
      CFAllocatorRef v8 = CFGetAllocator(a1);
      unsigned int v9 = (const void **)CFAllocatorAllocate(v8, 8 * v7, 0);
      if (v9)
      {
        int v10 = v9;
        CFAllocatorRef v11 = CFGetAllocator(a1);
        uint64_t v12 = (const void **)CFAllocatorAllocate(v11, 8 * v7, 0);
        if (v12)
        {
          CMTime v13 = v12;
          CFDictionaryGetKeysAndValues(a1[35], v10, v12);
          if (v7 >= 1)
          {
            CFDataRef v14 = (const __CFData *)*MEMORY[0x1E4F1CFC8];
            __int16 v15 = v10;
            long long v16 = (CFDataRef *)v13;
            do
            {
              if (CFRunLoopTimerIsValid((CFRunLoopTimerRef)*v15))
              {
                if (v14 != *v16)
                {
                  CMTime v23 = *(CMTime *)CFDataGetBytePtr(*v16);
                  CFNumberRef Value = (__CFRunLoop *)CFDictionaryGetValue(a1[37], *v15);
                  char v18 = CFDictionaryGetValue(a1[36], *v15);
                  uint64_t v19 = (__CFRunLoopTimer *)*v15;
                  CMTime v22 = *a2;
                  rescheduleTimer(v19, Value, &v23, (OpaqueCMTimebase *)a1, &v22, a3, v18);
                }
              }
              else
              {
                CFDictionaryRemoveValue(a1[35], *v15);
                CFDictionaryRemoveValue(a1[36], *v15);
                CFDictionaryRemoveValue(a1[37], *v15);
              }
              ++v16;
              ++v15;
              --v7;
            }
            while (v7);
          }
          CFAllocatorRef v20 = CFGetAllocator(a1);
          CFAllocatorDeallocate(v20, v10);
        }
        else
        {
          CMTime v13 = v10;
        }
        CFAllocatorRef v21 = CFGetAllocator(a1);
        CFAllocatorDeallocate(v21, v13);
      }
    }
  }
}

void figDeferredNotificationRelease(const void **ptr)
{
  uint64_t v2 = *ptr;
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = ptr[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = ptr[5];
  if (v4) {
    CFRelease(v4);
  }
  CFAllocatorRef v5 = (const __CFAllocator *)ptr[6];
  CFAllocatorDeallocate(v5, ptr);
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t FigBaseObjectEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = 0;
  if (!a1 || !a2) {
    return v2;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    uint64_t v4 = *(void *)(a1 + 24);
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 != *(void *)(a2 + 24)) {
    return 0;
  }
  uint64_t v6 = v3 ? *(void *)(a1 + 24) : 0;
  uint64_t v7 = *(void *)(v6 + 8) ? *(void *)(v6 + 8) : 0;
  if (!*(void *)(v7 + 16)) {
    return 0;
  }
  if (*(void *)(v3 + 8)) {
    uint64_t v8 = *(void *)(v3 + 8);
  }
  else {
    uint64_t v8 = 0;
  }
  return (*(uint64_t (**)(void))(v8 + 16))();
}

double sBufFinalize(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 28))
  {
    case 0:
    case 1:
    case 2:
    case 3:
      uint64_t v2 = *(const void **)(a1 + 16);
      if (v2) {
        CFRelease(v2);
      }
      break;
    default:
      break;
  }
  if (*(unsigned char *)(a1 + 27)) {
    _Block_release(*(const void **)(a1 + 48));
  }
  if (*(void *)(a1 + 32) == 1) {
    _Block_release(*(const void **)(a1 + 40));
  }
  uint64_t v3 = *(const void **)(a1 + 152);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 64);
  if (v4) {
    CFRelease(v4);
  }
  FigFormatDescriptionRelease(*(CFTypeRef *)(a1 + 72));
  CFAllocatorRef v5 = *(const void **)(a1 + 304);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 312);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)(a1 + 320);
  if (v7) {
    CFRelease(v7);
  }
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v8 = *(void **)(a1 + 112);
    if (v8)
    {
      *(void *)(a1 + 112) = 0;
      free(v8);
    }
  }
  double result = 0.0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void FigSampleBufferRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void ftbFinalize(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 136);
  figTimebaseSwitchListenersToNewMaster((void *)a1, *(const void **)(a1 + 136), 0);
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    figTimebaseUninstallReadOnlyTimebaseNotifications((const void *)a1, v3);
    uint64_t v4 = *(const void **)(a1 + 24);
    if (!v4) {
      goto LABEL_6;
    }
    uint64_t v2 = (const void **)(a1 + 24);
  }
  else
  {
    uint64_t v4 = *v2;
    if (!*v2) {
      goto LABEL_6;
    }
  }
  CFRelease(v4);
  const void *v2 = 0;
LABEL_6:
  CFAllocatorRef v5 = *(const void **)(a1 + 128);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 128) = 0;
  uint64_t v6 = *(const void **)(a1 + 144);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 144) = 0;
  uint64_t v7 = *(__CFDictionary **)(a1 + 280);
  if (v7)
  {
    CFDictionaryRemoveAllValues(v7);
    CFRelease(*(CFTypeRef *)(a1 + 280));
    *(void *)(a1 + 280) = 0;
  }
  uint64_t v8 = *(__CFDictionary **)(a1 + 288);
  if (v8)
  {
    CFDictionaryRemoveAllValues(v8);
    CFRelease(*(CFTypeRef *)(a1 + 288));
    *(void *)(a1 + 288) = 0;
  }
  unsigned int v9 = *(__CFDictionary **)(a1 + 296);
  if (v9)
  {
    CFDictionaryRemoveAllValues(v9);
    CFRelease(*(CFTypeRef *)(a1 + 296));
    *(void *)(a1 + 296) = 0;
  }
  int v10 = *(__CFDictionary **)(a1 + 304);
  if (v10)
  {
    CFDictionaryRemoveAllValues(v10);
    CFRelease(*(CFTypeRef *)(a1 + 304));
    *(void *)(a1 + 304) = 0;
  }
  CFAllocatorRef v11 = *(__CFDictionary **)(a1 + 312);
  if (v11)
  {
    CFDictionaryRemoveAllValues(v11);
    CFRelease(*(CFTypeRef *)(a1 + 312));
    *(void *)(a1 + 312) = 0;
  }
  if (*(void *)(a1 + 112))
  {
    FigReentrantMutexDestroy();
    *(void *)(a1 + 112) = 0;
  }
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterUnregisterForBarrierSupport((uint64_t)DefaultLocalCenter, a1);
  CMTime v13 = *(NSObject **)(a1 + 120);
  if (v13)
  {
    dispatch_release(v13);
    *(void *)(a1 + 120) = 0;
  }
  if (*(_DWORD *)(a1 + 16) == 1)
  {
    CFDataRef v14 = *(NSObject **)(a1 + 104);
    if (v14)
    {
      dispatch_source_cancel(v14);
      dispatch_release(*(dispatch_object_t *)(a1 + 104));
    }
    __int16 v15 = *(NSObject **)(a1 + 96);
    if (v15)
    {
      dispatch_release(v15);
    }
  }
}

uint64_t FigThreadAbort(uint64_t a1)
{
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  uint64_t result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (!result)
  {
    if ((gAbortingNow & 1) == 0)
    {
      gAbortingNow = 1;
      uint64_t v3 = (void *)gAbortActionList;
      if (gAbortActionList)
      {
        do
        {
          if (*v3 == a1)
          {
            uint64_t v4 = (void (*)(void))v3[2];
            if (v4) {
              v4(v3[3]);
            }
          }
          uint64_t v3 = (void *)v3[4];
        }
        while (v3);
        CFAllocatorRef v5 = (void *)gAbortActionList;
        if (gAbortActionList)
        {
          while (1)
          {
            uint64_t v6 = (void *)v5[4];
            if (!v5[2]) {
              break;
            }
LABEL_18:
            CFAllocatorRef v5 = v6;
            if (!v6) {
              goto LABEL_19;
            }
          }
          uint64_t v7 = gAbortActionList;
          if ((void *)gAbortActionList == v5)
          {
            gAbortActionList = v5[4];
            if (v6)
            {
LABEL_17:
              free(v5);
              goto LABEL_18;
            }
            unsigned int v9 = &gAbortActionList;
          }
          else
          {
            do
            {
              uint64_t v8 = v7;
              uint64_t v7 = *(void *)(v7 + 32);
            }
            while ((void *)v7 != v5);
            *(void *)(v8 + 32) = v6;
            unsigned int v9 = (uint64_t *)(v8 + 32);
            if (v6) {
              goto LABEL_17;
            }
          }
          qword_1EB28B780 = (uint64_t)v9;
          goto LABEL_17;
        }
      }
LABEL_19:
      gAbortingNow = 0;
    }
    int v10 = (pthread_mutex_t *)gAbortActionLock;
    return FigReentrantMutexUnlock(v10);
  }
  return result;
}

pthread_mutex_t *abortActionInitOnce()
{
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t result = FigReentrantMutexCreateWithFlags(AllocatorForPermanentAllocations);
  gAbortActionLock = (uint64_t)result;
  gAbortActionList = 0;
  qword_1EB28B780 = (uint64_t)&gAbortActionList;
  return result;
}

uint64_t FigThreadJoin(pthread_t a1, void **a2)
{
  if (gAnyFigThreadIsPidBound == 1) {
    figThreadBindToPID(a1);
  }
  uint64_t v4 = pthread_join(a1, a2);
  uint64_t v5 = 4294954500;
  if (v4 != 22 && v4 != 11)
  {
    if (v4 != 3) {
      return v4;
    }
    uint64_t v5 = 4294954502;
  }

  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

void triggerRelease(const __CFAllocator *a1, const void **a2)
{
  _Block_release(a2[2]);

  CFAllocatorDeallocate(a1, a2);
}

void FigBufferQueueRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

double bufQFinalize(uint64_t a1)
{
  bufQStopListeningForHeadBufferBecomingReady(a1);
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v2 = *(const void **)(a1 + 100);
    if (v2) {
      CFRelease(v2);
    }
  }
  else
  {
    uint64_t v3 = *(const void **)(a1 + 96);
    if (v3) {
      CFRelease(v3);
    }
    _Block_release(*(const void **)(a1 + 56));
    _Block_release(*(const void **)(a1 + 64));
    _Block_release(*(const void **)(a1 + 72));
    _Block_release(*(const void **)(a1 + 80));
    _Block_release(*(const void **)(a1 + 88));
    if (*(void *)(a1 + 48)) {
      _Block_release(*(const void **)(a1 + 104));
    }
  }
  if (*(void *)(a1 + 16)) {
    FigReentrantMutexDestroy();
  }
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 32);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 160);
  if (v6) {
    CFRelease(v6);
  }
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterUnregisterForBarrierSupport((uint64_t)DefaultLocalCenter, a1);
  _Block_release(*(const void **)(a1 + 192));
  *(void *)(a1 + 256) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t FigRunDeferredNotificationsOnCurrentRunLoop()
{
  int v0 = sFigDeferredNotificationRunSeed;
  do
  {
    CFRunLoopRunInMode(@"FigDeferredNotificationMode", 0.0, 1u);
    BOOL v1 = v0 == sFigDeferredNotificationRunSeed;
    int v0 = sFigDeferredNotificationRunSeed;
  }
  while (!v1);
  return 0;
}

BOOL FigFilePathEqual(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(a1 + 16), (const char *)(a2 + 16)) == 0;
}

uint64_t fcFinalize(OpaqueCMClock *a1)
{
  CMClockInvalidate(a1);
  uint64_t result = *((void *)a1 + 2);
  if (result)
  {
    uint64_t result = FigReentrantMutexDestroy();
    *((void *)a1 + 2) = 0;
  }
  return result;
}

CFAllocatorRef fadcFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  FigCFWeakReferenceTableRemoveValue(gFigAudioDeviceClockRegistry, *(void *)(DerivedStorage + 144));
  int v2 = *(_DWORD *)(DerivedStorage + 88);
  uint64_t v3 = *(void *)(DerivedStorage + 144);
  if (fadcDeferRemovePropertyListeners_deferredFadcRemoveQueueOnce != -1) {
    dispatch_once_f(&fadcDeferRemovePropertyListeners_deferredFadcRemoveQueueOnce, &fadcDeferRemovePropertyListeners_deferredFadcRemoveQueue, (dispatch_function_t)fadcInitDeferredRemoveQueue);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = __fadcDeferRemovePropertyListeners_block_invoke;
  v6[3] = &__block_descriptor_tmp_24;
  int v7 = v2;
  v6[4] = v3;
  char v8 = 0;
  dispatch_async((dispatch_queue_t)fadcDeferRemovePropertyListeners_deferredFadcRemoveQueue, v6);
  FigReadWriteLockLockForWrite(*(void *)(DerivedStorage + 64));
  FigReadWriteLockUnlockForWrite(*(void *)(DerivedStorage + 64));
  uint64_t v4 = *(const void **)(DerivedStorage + 80);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 80) = 0;
  }
  dispatch_release(*(dispatch_object_t *)(DerivedStorage + 128));
  FigReadWriteLockDestroy(*(uint64_t **)(DerivedStorage + 136));
  CFAllocatorRef result = FigReadWriteLockDestroy(*(uint64_t **)(DerivedStorage + 64));
  *(void *)(DerivedStorage + 64) = 0;
  return result;
}

uint64_t removePropertyListener(uint64_t a1, AudioObjectPropertySelector a2)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  if (a2 == 1735354734 || a2 == 1870030194 || a2 == 1853059700)
  {
    AudioObjectID v4 = *(_DWORD *)(DerivedStorage + 88);
    inAddress.AudioObjectPropertySelector mSelector = a2;
    *(void *)&inAddress.mScope = 707406378;
    return AudioObjectRemovePropertyListener(v4, &inAddress, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(DerivedStorage + 144));
  }
  else
  {
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

void figFormatDescriptionFinalize(uint64_t a1)
{
  int v2 = (const void *)*(unsigned int *)(a1 + 16);
  if (v2 && (CFNumberRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, v2)) != 0
    || (CFNumberRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72)) != 0)
  {
    AudioObjectID v4 = *(void (**)(uint64_t))(Value + 28);
    if (v4) {
      v4(a1);
    }
  }
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
  }
}

void figAudioFormatDescriptionFinalize(const void *a1)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (*(void *)(DerivedStorage + 48))
  {
    CFAllocatorRef v3 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v3, *(void **)(DerivedStorage + 48));
  }
  if (*(void *)(DerivedStorage + 64))
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v4, *(void **)(DerivedStorage + 64));
  }
  if (*(void *)(DerivedStorage + 88))
  {
    CFAllocatorRef v5 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v5, *(void **)(DerivedStorage + 88));
  }
  if (*(void *)(DerivedStorage + 104))
  {
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v6, *(void **)(DerivedStorage + 104));
  }
  if (*(void *)(DerivedStorage + 120))
  {
    CFAllocatorRef v7 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v7, *(void **)(DerivedStorage + 120));
  }
  if (*(void *)(DerivedStorage + 136))
  {
    uint64_t v8 = *(void *)(DerivedStorage + 128);
    if (v8 >= 1)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8;
      do
      {
        if (*(void *)(*(void *)(DerivedStorage + 136) + v10))
        {
          CFAllocatorRef v11 = CFGetAllocator(a1);
          CFAllocatorDeallocate(v11, *(void **)(*(void *)(DerivedStorage + 136) + v10));
          uint64_t v8 = *(void *)(DerivedStorage + 128);
        }
        ++v9;
        v10 += 16;
      }
      while (v9 < v8);
    }
    CFAllocatorRef v12 = CFGetAllocator(a1);
    CMTime v13 = *(void **)(DerivedStorage + 136);
    CFAllocatorDeallocate(v12, v13);
  }
}

double FigFileByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = *(void *)(DerivedStorage + 4136);
  if (v2)
  {
    FigSimpleMutexDestroy(v2);
    *(void *)(DerivedStorage + 4136) = 0;
    *(unsigned char *)(DerivedStorage + 4144) = 0;
  }
  if (*(unsigned char *)(DerivedStorage + 4220)) {
    FigFileForkClose(*(int **)(DerivedStorage + 8));
  }
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }

  return FigByteStreamStatsTeardownWorker(DerivedStorage + 4152);
}

uint64_t FigFilePathCreateFromParent(int a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (const char *)(a2 + 16);
  size_t v9 = strlen((const char *)(a2 + 16));
  if (v9 + strlen(a3) - 1022 <= 0xFFFFFFFFFFFFFBFFLL)
  {
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v10 = "/";
    if (v9)
    {
      if (*(unsigned char *)(v9 + a2 + 15) == 47) {
        uint64_t v10 = "";
      }
    }
    snprintf(__str, 0x400uLL, "%s%s%s", v8, v10, a3);
    return FigFilePathCreateFromDarwinPath(a1, __str, a4);
  }
}

uint64_t FigByteStreamCreateFromOpenFile(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 0, a3);
}

uint64_t FigThreadRegisterAbortAction(uint64_t (*a1)(), _opaque_pthread_t *a2, void *a3)
{
  pthread_t Current = FigThreadGetCurrent();
  specific = (_opaque_pthread_t *)dispatch_get_specific(&kFigThreadDispatchQueueAbortabilityKey);
  if (a3)
  {
    pthread_t v8 = specific;
    FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
    uint64_t v9 = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
    if (v9) {
      return v9;
    }
    if (gAbortingNow)
    {
      uint64_t v10 = 4294954498;
    }
    else
    {
      uint64_t v13 = (pthread_t *)gAbortActionList;
      if (gAbortActionList)
      {
        do
        {
          CFDataRef v14 = (uint64_t (*)())v13[2];
          if (v14 == a1 && v13[3] == a2)
          {
            if (*v13 == Current || v8 && v13[1] == v8)
            {
              int v12 = 0;
              uint64_t v11 = 4294949736;
              goto LABEL_21;
            }
          }
          else if (v14 == kSpecialAction_ThreadWasAbortedForTeardown {
                 && !v13[3]
          }
                 && (*v13 == Current || v8 && v13[1] == v8))
          {
            uint64_t v11 = FigSignalErrorAt(4294949735, 0, 0, 0, 0, 0, 0);
            int v12 = 1;
            goto LABEL_21;
          }
          uint64_t v13 = (pthread_t *)v13[4];
        }
        while (v13);
      }
      __int16 v15 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040D3751E5BuLL);
      if (v15)
      {
        uint64_t v11 = 0;
        int v12 = 0;
        *__int16 v15 = Current;
        v15[1] = v8;
        v15[4] = 0;
        v15[2] = a1;
        _OWORD v15[3] = a2;
        *(void *)qword_1EB28B780 = v15;
        qword_1EB28B780 = (uint64_t)(v15 + 4);
        *a3 = v15;
LABEL_21:
        FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
        if (a1)
        {
          if (v12) {
            ((void (*)(_opaque_pthread_t *))a1)(a2);
          }
        }
        return v11;
      }
      uint64_t v10 = 4294954497;
    }
    uint64_t v11 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    int v12 = 0;
    goto LABEL_21;
  }

  return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
}

uint64_t FigThreadGetGlobalNetworkBufferingRunloop()
{
  return sNetworkRunLoop;
}

void *networkThreadInitOnce()
{
  return networkThreadCommonInit(@"com.apple.coremedia.networkbuffering", (uint64_t)FigThreadGlobalNetworkBufferingRunloop, 7u, &sNetworkThread);
}

uint64_t FigThreadGlobalNetworkBufferingRunloop(uint64_t a1)
{
  if (sNetworkRunLoopTimer)
  {
    CFRelease((CFTypeRef)sNetworkRunLoopTimer);
    sNetworkRunLoopTimer = 0;
  }
  return 0;
}

uint64_t FigThreadUnregisterAbortAction(uint64_t result)
{
  if (!result) {
    return result;
  }
  BOOL v1 = (void *)result;
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  CFAllocatorRef result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (result) {
    return result;
  }
  uint64_t v2 = &gAbortActionList;
  CFAllocatorRef v3 = &gAbortActionList;
  do
  {
    CFAllocatorRef v4 = (void *)*v3;
    CFAllocatorRef v3 = (uint64_t *)(*v3 + 32);
    if (v4) {
      BOOL v5 = v4 == v1;
    }
    else {
      BOOL v5 = 1;
    }
  }
  while (!v5);
  if (v4)
  {
    if (gAbortingNow)
    {
      v4[2] = 0;
      v4[3] = 0;
      goto LABEL_17;
    }
    uint64_t v6 = gAbortActionList;
    if ((void *)gAbortActionList == v4)
    {
      gAbortActionList = *v3;
      if (gAbortActionList) {
        goto LABEL_16;
      }
    }
    else
    {
      do
      {
        uint64_t v7 = v6;
        uint64_t v6 = *(void *)(v6 + 32);
      }
      while ((void *)v6 != v4);
      uint64_t v8 = *v3;
      *(void *)(v7 + 32) = v8;
      uint64_t v2 = (uint64_t *)(v7 + 32);
      if (v8) {
        goto LABEL_16;
      }
    }
    qword_1EB28B780 = (uint64_t)v2;
LABEL_16:
    free(v4);
  }
LABEL_17:
  uint64_t v9 = (pthread_mutex_t *)gAbortActionLock;

  return FigReentrantMutexUnlock(v9);
}

uint64_t FigDebugSettingGetKeyAsInteger(const __CFString *a1, CFIndex *a2)
{
  Boolean keyExistsAndHasValidFormat = 0;
  *a2 = CFPreferencesGetAppIntegerValue(a1, @"com.apple.coremedia", &keyExistsAndHasValidFormat);
  return keyExistsAndHasValidFormat;
}

uint64_t FigFileByteStreamWrite(uint64_t a1, size_t a2, off_t a3, void *a4, void *a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v14 = 0;
  uint64_t v10 = FigFileForkWriteWithIOPolicy(*(int **)(DerivedStorage + 8), *(_DWORD *)(DerivedStorage + 4216), a4, a2, a3, &v14);
  unsigned int v11 = v10;
  if (v10) {
    FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v12 = v14;
  if (a5) {
    *a5 = v14;
  }
  if (v12 == a2) {
    return 0;
  }
  else {
    return v11;
  }
}

uint64_t FigFilePathCreateFromChild(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  while (1)
  {
    int v6 = *(unsigned __int8 *)(a2 + v3 + 16);
    if (v6 != 47) {
      break;
    }
    uint64_t v5 = v4;
    uint64_t v4 = a2 + v3 + 16;
LABEL_6:
    v9[v3++] = v6;
  }
  if (*(unsigned char *)(a2 + v3 + 16)) {
    goto LABEL_6;
  }
  if (a2 + v3 + 15 == v4) {
    uint64_t v4 = v5;
  }
  if (v4)
  {
    v9[v4 - (a2 + 16) + 1] = 0;
    if (v9[0]) {
      return FigFilePathCreateFromDarwinPath(a1, v9, a3);
    }
    uint64_t v8 = 4294967253;
  }
  else
  {
    uint64_t v8 = 4294955096;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t figBridge_WalkAndConvertImageDescriptionExtensions(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, size_t *a7, size_t count, const void *a9)
{
  uint64_t v10 = a6;
  uint64_t v189 = *MEMORY[0x1E4F143B8];
  uint64_t v179 = 0;
  if (count)
  {
    uint64_t v14 = (CFTypeRef *)malloc_type_calloc(count, 0x18uLL, 0x1060040D0FAAE32uLL);
    if (!v14)
    {
      return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  size_t v171 = count;
  v172 = (void *)a4;
  if (a3 < 8)
  {
    size_t v16 = 0;
LABEL_9:
    if (v172) {
      void *v172 = v179;
    }
    if (a7)
    {
      uint64_t v17 = 0;
      *a7 = v16;
      if (!v14) {
        return v17;
      }
    }
    else if (v16 == v171)
    {
      uint64_t v17 = 0;
      size_t v16 = v171;
      if (!v14) {
        return v17;
      }
    }
    else
    {
      strcpy((char *)valuePtr, "Image description data could have changed");
      uint64_t v17 = 4294954584;
      uint64_t v116 = 4294954584;
LABEL_273:
      FigSignalErrorAt(v116, 0, 0, 0, 0, 0, 0);
      figSoundBridge_ReportParsingFailureMessage((uint64_t)a9, (uint64_t)valuePtr);
      if (!v14) {
        return v17;
      }
    }
LABEL_321:
    if (v16)
    {
LABEL_322:
      v142 = v14 + 1;
      do
      {
        if (*v142) {
          CFRelease(*v142);
        }
        v142 += 3;
        --v16;
      }
      while (v16);
    }
LABEL_326:
    free(v14);
    return v17;
  }
  size_t v16 = 0;
  unint64_t v18 = 0;
  uint64_t v170 = 0;
  CFTypeRef v165 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v164 = (const void *)*MEMORY[0x1E4F24A10];
  v173 = (const void *)*MEMORY[0x1E4F24A08];
  CFTypeRef v163 = (CFTypeRef)*MEMORY[0x1E4F24B28];
  CFTypeRef v161 = (CFTypeRef)*MEMORY[0x1E4F24A90];
  CFTypeRef v166 = (CFTypeRef)*MEMORY[0x1E4F24BC8];
  CFTypeRef v160 = (CFTypeRef)*MEMORY[0x1E4F24C18];
  CFTypeRef v158 = (CFTypeRef)*MEMORY[0x1E4F24A78];
  v159 = (const void *)*MEMORY[0x1E4F1CFC8];
  uint64_t v156 = *MEMORY[0x1E4F24A68];
  uint64_t v157 = *MEMORY[0x1E4F24A88];
  uint64_t v155 = *MEMORY[0x1E4F24A70];
  uint64_t v154 = *MEMORY[0x1E4F24A80];
  CFTypeRef v153 = (CFTypeRef)*MEMORY[0x1E4F24B98];
  v152 = (void *)*MEMORY[0x1E4F24B90];
  CFTypeRef v162 = (CFTypeRef)*MEMORY[0x1E4F24AF8];
  CFTypeRef v151 = (CFTypeRef)*MEMORY[0x1E4F24B00];
  uint64_t v178 = v10;
  uint64_t v19 = a2;
  while (1)
  {
    unint64_t v20 = v19 + v18;
    int v21 = bswap32(*(_DWORD *)(v19 + v18));
    CFIndex v22 = (v21 - 8);
    if (v21 < 8)
    {
LABEL_262:
      if (BYTE4(v170) && v170)
      {
        if (a5)
        {
          CFTypeRef v113 = CFRetain(v166);
          *(void *)(a5 + 8 * v179) = v113;
        }
        if (v10)
        {
          CFTypeRef v114 = CFRetain((CFTypeRef)*MEMORY[0x1E4F24C08]);
          uint64_t v115 = v179;
          *(void *)(v10 + 8 * v179) = v114;
        }
        else
        {
          uint64_t v115 = v179;
        }
        uint64_t v179 = v115 + 1;
      }
      if (!v16) {
        goto LABEL_9;
      }
      if (a5)
      {
        CFTypeRef v117 = CFRetain(@"SampleDescriptionExtensionAtoms");
        *(void *)(a5 + 8 * v179) = v117;
      }
      if (v10)
      {
        v118 = malloc_type_calloc(v16, 8uLL, 0x6004044C4A2DFuLL);
        v119 = malloc_type_calloc(v16, 8uLL, 0x6004044C4A2DFuLL);
        v120 = malloc_type_calloc(v16, 8uLL, 0x6004044C4A2DFuLL);
        v121 = v120;
        if (!v118 || !v119 || !v120)
        {
          uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          if (!v118) {
            goto LABEL_311;
          }
LABEL_306:
          for (uint64_t i = 0; i != v16; ++i)
          {
            v139 = (const void *)v118[i];
            if (v139) {
              CFRelease(v139);
            }
          }
          free(v118);
LABEL_311:
          if (v119)
          {
            for (uint64_t j = 0; j != v16; ++j)
            {
              v141 = (const void *)v119[j];
              if (v141) {
                CFRelease(v141);
              }
            }
            free(v119);
          }
          if (v121) {
            free(v121);
          }
          if (!v17) {
            goto LABEL_9;
          }
LABEL_320:
          if (!v14) {
            return v17;
          }
          goto LABEL_321;
        }
        v176 = (const void **)v119;
        CFIndex v122 = 0;
        uint64_t v123 = 0;
        v124 = (int *)(v14 + 3);
        v125 = v14 + 2;
        size_t v126 = v16;
        v168 = v14;
        do
        {
          if (!LODWORD(v14[3 * v123 + 2]))
          {
            int v127 = (int)v14[3 * v123];
            LOBYTE(valuePtr[0]) = 4;
            BYTE1(valuePtr[0]) = HIBYTE(v127);
            BYTE2(valuePtr[0]) = BYTE2(v127);
            BYTE3(valuePtr[0]) = BYTE1(v127);
            BYTE4(valuePtr[0]) = v127;
            CFStringRef v128 = CFStringCreateWithPascalString(a1, (ConstStr255Param)valuePtr, 0);
            v118[v122] = v128;
            if (!v128)
            {
              uint64_t v129 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              if (v129)
              {
                uint64_t v14 = v168;
                uint64_t v17 = v129;
                v119 = v176;
                goto LABEL_306;
              }
            }
            v130 = v124;
            uint64_t v131 = v123;
            do
            {
              if (++v131 >= v16)
              {
                uint64_t v14 = v168;
                v176[v122] = CFRetain(v168[3 * v123 + 1]);
                goto LABEL_298;
              }
              int v132 = *v130;
              v130 += 6;
            }
            while (v127 != v132);
            CFIndex v133 = 0;
            size_t v134 = v126;
            v135 = v125;
            do
            {
              if (v127 == *(v135 - 4))
              {
                *((void *)v121 + v133++) = *((void *)v135 - 1);
                _DWORD *v135 = 1;
              }
              v135 += 6;
              --v134;
            }
            while (v134);
            CFArrayRef v136 = CFArrayCreate(a1, (const void **)v121, v133, MEMORY[0x1E4F1D510]);
            v176[v122] = v136;
            uint64_t v14 = v168;
            if (!v136)
            {
              uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              v119 = v176;
              goto LABEL_306;
            }
LABEL_298:
            ++v122;
          }
          ++v123;
          v124 += 6;
          v125 += 6;
          --v126;
        }
        while (v123 != v16);
        v119 = v176;
        CFDictionaryRef v137 = CFDictionaryCreate(a1, (const void **)v118, v176, v122, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(void *)(v178 + 8 * v179) = v137;
        if (v137) {
          uint64_t v17 = 0;
        }
        else {
          uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        uint64_t v17 = 0;
        v118 = 0;
        v119 = 0;
        v121 = 0;
      }
      ++v179;
      if (!v118) {
        goto LABEL_311;
      }
      goto LABEL_306;
    }
    v18 += v21;
    if (v18 > a3)
    {
      strcpy((char *)valuePtr, "Image description extension size exceeds image description size");
      uint64_t v17 = 4294954582;
      uint64_t v116 = 4294954582;
      goto LABEL_273;
    }
    int v23 = bswap32(*(_DWORD *)(v20 + 4));
    long long v24 = (unsigned int *)(v20 + 8);
    if (v23 > 1718773092) {
      break;
    }
    if (v23 > 1667789420)
    {
      if (v23 <= 1668050024)
      {
        if (v23 == 1667789421)
        {
          if (v21 != 10) {
            goto LABEL_131;
          }
          uint64_t v63 = 0;
          char v64 = 1;
          uint64_t v10 = v178;
          do
          {
            char v65 = v64;
            uint64_t v66 = figConvertChromaLocationIndexToString(*((unsigned __int8 *)v24 + v63));
            if (v66)
            {
              uint64_t v67 = (const void *)v66;
              if (a5)
              {
                if (v65) {
                  v68 = v164;
                }
                else {
                  v68 = v173;
                }
                CFTypeRef v69 = CFRetain(v68);
                *(void *)(a5 + 8 * v179) = v69;
              }
              if (v178)
              {
                CFTypeRef v70 = CFRetain(v67);
                uint64_t v71 = v179;
                *(void *)(v178 + 8 * v179) = v70;
              }
              else
              {
                uint64_t v71 = v179;
              }
              uint64_t v179 = v71 + 1;
            }
            char v64 = 0;
            uint64_t v63 = 1;
          }
          while ((v65 & 1) != 0);
LABEL_220:
          uint64_t v19 = a2;
          goto LABEL_261;
        }
        if (v23 != 1668047216) {
          goto LABEL_176;
        }
        if (v21 == 40
          && (uint64_t v39 = *(void *)(v20 + 8),
              unsigned int v40 = *(_DWORD *)(v20 + 20),
              unsigned int v41 = *(_DWORD *)(v20 + 28),
              v42.i64[0] = v39,
              v42.i64[1] = __PAIR64__(v41, v40),
              (vmaxv_u16((uint16x4_t)vmovn_s32(vceqzq_s32(v42))) & 1) == 0)
          && (unsigned int v43 = *(_DWORD *)(v20 + 16)) != 0
          && (unsigned int v44 = *(_DWORD *)(v20 + 36)) != 0)
        {
          int v45 = HIDWORD(v39);
          int v46 = bswap32(*(_DWORD *)(v20 + 24));
          int v47 = bswap32(*(_DWORD *)(v20 + 32));
          unsigned int v143 = bswap32(HIDWORD(v39));
          unsigned int v144 = bswap32(v39);
          unsigned int v145 = bswap32(v40);
          unsigned int v146 = bswap32(v43);
          double v182 = (double)v146 / (double)v145;
          double v183 = (double)v144 / (double)v143;
          unsigned int v147 = bswap32(v41);
          int v148 = v46;
          unsigned int v149 = bswap32(v44);
          double v180 = (double)v47 / (double)v149;
          double v181 = (double)v46 / (double)v147;
          if (a5)
          {
            CFTypeRef v48 = CFRetain(v158);
            *(void *)(a5 + 8 * v179) = v48;
          }
          memset(valuePtr, 0, 64);
          *(_OWORD *)values = 0u;
          long long v186 = 0u;
          long long v187 = 0u;
          long long v188 = 0u;
          if (v178)
          {
            *(void *)&valuePtr[0] = v157;
            values[0] = CFNumberCreate(alloc, kCFNumberDoubleType, &v183);
            *((void *)&valuePtr[0] + 1) = v156;
            values[1] = CFNumberCreate(alloc, kCFNumberDoubleType, &v182);
            *(void *)&valuePtr[1] = v155;
            *(void *)&long long v186 = CFNumberCreate(alloc, kCFNumberDoubleType, &v181);
            *((void *)&valuePtr[1] + 1) = v154;
            *((void *)&v186 + 1) = CFNumberCreate(alloc, kCFNumberDoubleType, &v180);
            if (v45 == 0x1000000)
            {
              CFIndex v49 = 4;
            }
            else
            {
              *(void *)&valuePtr[2] = @"WidthAsRational";
              *(void *)&long long v187 = figBridge_CFArrayCreateWithTwoIntegers(a1, v144, v143);
              CFIndex v49 = 5;
            }
            if (v40 != 0x1000000)
            {
              *((void *)valuePtr + v49) = @"HeightAsRational";
              values[v49++] = figBridge_CFArrayCreateWithTwoIntegers(a1, v146, v145);
            }
            uint64_t v10 = v178;
            if (v41 != 0x1000000)
            {
              *((void *)valuePtr + v49) = @"HorizontalOffsetAsRational";
              values[v49++] = figBridge_CFArrayCreateWithTwoIntegers(a1, v148, v147);
            }
            if (v44 != 0x1000000)
            {
              *((void *)valuePtr + v49) = @"VerticalOffsetAsRational";
              values[v49++] = figBridge_CFArrayCreateWithTwoIntegers(a1, v47, v149);
            }
            uint64_t v107 = 0;
            do
            {
              if (!values[v107])
              {
                uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                goto LABEL_254;
              }
              ++v107;
            }
            while (v49 != v107);
            CFDictionaryRef v108 = CFDictionaryCreate(a1, (const void **)valuePtr, (const void **)values, v49, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            *(void *)(v178 + 8 * v179) = v108;
            if (v108) {
              uint64_t v17 = 0;
            }
            else {
              uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            }
          }
          else
          {
            uint64_t v17 = 0;
            CFIndex v49 = 0;
            uint64_t v10 = 0;
          }
          ++v179;
LABEL_254:
          if ((int)v49 >= 1)
          {
            v112 = values;
            do
            {
              if (*v112) {
                CFRelease(*v112);
              }
              ++v112;
              --v49;
            }
            while (v49);
          }
        }
        else
        {
          FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
          uint64_t v17 = 0;
          uint64_t v10 = v178;
        }
        goto LABEL_259;
      }
      if (v23 == 1668050025)
      {
        CFAllocatorRef v31 = a1;
        uint64_t v10 = v178;
        uint64_t v32 = a5;
        uint64_t v33 = v178;
        CFAllocatorRef v34 = (UInt8 *)(v20 + 8);
        CFIndex v35 = (v21 - 8);
        CMTime v36 = @"ContentLightLevelInfo";
        goto LABEL_122;
      }
      if (v23 == 1668246642)
      {
        if (v22 < 5) {
          unsigned int v55 = 0;
        }
        else {
          unsigned int v55 = *v24;
        }
        uint64_t v10 = v178;
        BOOL v76 = v21 == 19 && v55 == 2020369262;
        BOOL v77 = v55 == 1668047726 && v22 == 10;
        if (v77 || v76)
        {
          v167 = v14;
          BOOL v79 = v55 != 2020369262 || *(char *)(v20 + 18) >= 0;
          BOOL v150 = v79;
          unsigned int v80 = *(unsigned __int16 *)(v20 + 14);
          unsigned int v81 = bswap32(*(unsigned __int16 *)(v20 + 16)) >> 16;
          CFStringRef StringForIntegerCodePoint = CVColorPrimariesGetStringForIntegerCodePoint(bswap32(*(unsigned __int16 *)(v20 + 12)) >> 16);
          CFStringRef v83 = CVTransferFunctionGetStringForIntegerCodePoint(__rev16(v80));
          int v84 = HIDWORD(v170);
          if (v80 == 512) {
            int v84 = 1;
          }
          HIDWORD(v17CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v84;
          CFStringRef v85 = CVYCbCrMatrixGetStringForIntegerCodePoint(v81);
          uint64_t v14 = v167;
          uint64_t v10 = v178;
          if (StringForIntegerCodePoint)
          {
            if (a5)
            {
              CFTypeRef v86 = CFRetain(v161);
              *(void *)(a5 + 8 * v179) = v86;
            }
            if (v178)
            {
              CFTypeRef v87 = CFRetain(StringForIntegerCodePoint);
              uint64_t v88 = v179;
              *(void *)(v178 + 8 * v179) = v87;
            }
            else
            {
              uint64_t v88 = v179;
            }
            uint64_t v179 = v88 + 1;
          }
          if (v83)
          {
            if (a5)
            {
              CFTypeRef v96 = CFRetain(v166);
              *(void *)(a5 + 8 * v179) = v96;
            }
            if (v178)
            {
              CFTypeRef v97 = CFRetain(v83);
              uint64_t v98 = v179;
              *(void *)(v178 + 8 * v179) = v97;
            }
            else
            {
              uint64_t v98 = v179;
            }
            uint64_t v179 = v98 + 1;
          }
          if (v85)
          {
            if (a5)
            {
              CFTypeRef v99 = CFRetain(v160);
              *(void *)(a5 + 8 * v179) = v99;
            }
            if (v178)
            {
              CFTypeRef v100 = CFRetain(v85);
              uint64_t v101 = v179;
              *(void *)(v178 + 8 * v179) = v100;
            }
            else
            {
              uint64_t v101 = v179;
            }
            uint64_t v179 = v101 + 1;
          }
          if (v55 == 2020369262)
          {
            uint64_t v19 = a2;
            if (a5)
            {
              CFTypeRef v102 = CFRetain(@"FullRangeVideo");
              *(void *)(a5 + 8 * v179) = v102;
            }
            if (v178)
            {
              if (v150) {
                v74 = v159;
              }
              else {
                v74 = v165;
              }
LABEL_218:
              v74 = CFRetain(v74);
LABEL_219:
              uint64_t v103 = v179;
              *(void *)(v10 + 8 * v179) = v74;
LABEL_222:
              uint64_t v179 = v103 + 1;
              goto LABEL_261;
            }
LABEL_221:
            uint64_t v103 = v179;
            goto LABEL_222;
          }
          goto LABEL_220;
        }
        if (v55 == 1718579824 || v55 == 1128483186)
        {
          if (a5)
          {
            CFTypeRef v78 = CFRetain(@"CVImageBufferICCProfile");
            *(void *)(a5 + 8 * v179) = v78;
          }
          if (!v178) {
            goto LABEL_154;
          }
          CFDataRef v52 = CFDataCreate(a1, (const UInt8 *)(v20 + 12), v22 - 4);
          goto LABEL_153;
        }
        goto LABEL_157;
      }
      if (v23 != 1718183276) {
        goto LABEL_176;
      }
      if (v21 != 10) {
        goto LABEL_131;
      }
      LOBYTE(valuePtr[0]) = *(unsigned char *)(v20 + 8);
      int v27 = *(unsigned __int8 *)(v20 + 9);
      uint64_t v10 = v178;
      if (a5)
      {
        CFTypeRef v28 = CFRetain(v162);
        *(void *)(a5 + 8 * v179) = v28;
      }
      if (v178
        && (CFNumberRef v29 = CFNumberCreate(alloc, kCFNumberSInt8Type, valuePtr), (*(void *)(v178 + 8 * v179) = v29) == 0))
      {
        uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        uint64_t v17 = 0;
      }
      uint64_t v94 = ++v179;
      if (LOBYTE(valuePtr[0]) >= 2u)
      {
        if (v27 > 8)
        {
          if (v27 == 9)
          {
            v95 = (const void **)MEMORY[0x1E4F24B08];
          }
          else
          {
            if (v27 != 14) {
              goto LABEL_259;
            }
            v95 = (const void **)MEMORY[0x1E4F24B10];
          }
        }
        else
        {
          if (v27 != 1)
          {
            if (v27 == 6)
            {
              v95 = (const void **)MEMORY[0x1E4F24B18];
              goto LABEL_246;
            }
            goto LABEL_259;
          }
          v95 = (const void **)MEMORY[0x1E4F24B20];
        }
LABEL_246:
        v109 = *v95;
        if (*v95)
        {
          if (a5)
          {
            CFTypeRef v110 = CFRetain(v151);
            uint64_t v94 = v179;
            *(void *)(a5 + 8 * v179) = v110;
          }
          if (v178)
          {
            CFTypeRef v111 = CFRetain(v109);
            uint64_t v94 = v179;
            *(void *)(v178 + 8 * v179) = v111;
          }
          uint64_t v179 = v94 + 1;
        }
      }
LABEL_259:
      uint64_t v19 = a2;
      goto LABEL_260;
    }
    if (v23 <= 1635017575)
    {
      if (v23 != 1634495855)
      {
        if (v23 != 1634563685) {
          goto LABEL_176;
        }
        CFAllocatorRef v31 = a1;
        uint64_t v10 = v178;
        uint64_t v32 = a5;
        uint64_t v33 = v178;
        CFAllocatorRef v34 = (UInt8 *)(v20 + 8);
        CFIndex v35 = (v21 - 8);
        CMTime v36 = @"AmbientViewingEnvironment";
        goto LABEL_122;
      }
      if (v21 != 12) {
        goto LABEL_133;
      }
      if (v178)
      {
        unsigned int v61 = bswap32(*v24);
        if (v61 != 256)
        {
          if (v61 == 258)
          {
            v62 = (CFTypeRef *)&kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
            goto LABEL_224;
          }
LABEL_133:
          FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
          if (v14) {
            goto LABEL_177;
          }
          goto LABEL_179;
        }
        v62 = (CFTypeRef *)&kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
LABEL_224:
        CFTypeRef v104 = CFRetain(*v62);
        *(void *)(v178 + 8 * v179) = v104;
      }
      if (a5)
      {
        CFTypeRef v105 = CFRetain(@"AlphaChannelMode");
        uint64_t v106 = v179;
        *(void *)(a5 + 8 * v179) = v105;
      }
      else
      {
        uint64_t v106 = v179;
      }
      uint64_t v179 = v106 + 1;
      if (v14) {
        goto LABEL_177;
      }
      goto LABEL_179;
    }
    if (v23 == 1635017576)
    {
      if (v21 != 9) {
        goto LABEL_131;
      }
      int v72 = *(unsigned __int8 *)v24;
      uint64_t v10 = v178;
      if (*(unsigned char *)v24)
      {
        if (a5)
        {
          CFTypeRef v73 = CFRetain(@"AlternativeTransferCharacteristics");
          *(void *)(a5 + 8 * v179) = v73;
        }
        if (v178)
        {
          v74 = CVTransferFunctionGetStringForIntegerCodePoint(v72);
          if (v74) {
            goto LABEL_218;
          }
          goto LABEL_219;
        }
        goto LABEL_221;
      }
    }
    else
    {
      if (v23 != 1667460214) {
        goto LABEL_176;
      }
      uint64_t v10 = v178;
      figBridge_WrapPayloadAsCFData(a1, a5, v178, &v179, (UInt8 *)(v20 + 8), v22, @"ContentColorVolume");
    }
LABEL_261:
    if (v18 + 8 > a3) {
      goto LABEL_262;
    }
  }
  if (v23 <= 1835295605)
  {
    if (v23 > 1751543669)
    {
      if (v23 != 1751543670)
      {
        if (v23 == 1785751363)
        {
          if (v21 != 8)
          {
            uint64_t v17 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
            strcpy((char *)valuePtr, "Image description - unsupported extension 'jpgC'");
            FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
            figSoundBridge_ReportParsingFailureMessage((uint64_t)a9, (uint64_t)valuePtr);
            uint64_t v10 = v178;
            goto LABEL_260;
          }
          goto LABEL_180;
        }
        if (v23 == 1819240307)
        {
          if (v21 != 8)
          {
            uint64_t v10 = v178;
            if (a5)
            {
              CFTypeRef v25 = CFRetain(@"LogTransferFunction");
              *(void *)(a5 + 8 * v179) = v25;
            }
            if (v178)
            {
              CFStringRef v26 = CFStringCreateWithBytes(alloc, (const UInt8 *)(v20 + 8), v22, 0x600u, 0);
              uint64_t v17 = 0;
              *(void *)(v178 + 8 * v179) = v26;
              if (!v26) {
                goto LABEL_158;
              }
LABEL_183:
              ++v179;
              goto LABEL_260;
            }
LABEL_96:
            uint64_t v17 = 0;
            goto LABEL_183;
          }
LABEL_131:
          FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
LABEL_180:
          uint64_t v10 = v178;
          goto LABEL_261;
        }
LABEL_176:
        if (v14)
        {
LABEL_177:
          if (v16 >= v171)
          {
            strcpy((char *)valuePtr, "Image description data could have changed");
            uint64_t v17 = 4294954584;
            FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
            figSoundBridge_ReportParsingFailureMessage((uint64_t)a9, (uint64_t)valuePtr);
            if (v16) {
              goto LABEL_322;
            }
            goto LABEL_326;
          }
          v93 = &v14[3 * v16];
          *(_DWORD *)v93 = v23;
          v93[1] = CFDataCreate(a1, (const UInt8 *)(v20 + 8), v22);
          *((_DWORD *)v93 + 4) = 0;
          uint64_t v19 = a2;
        }
LABEL_179:
        ++v16;
        goto LABEL_180;
      }
      if (v21 != 12) {
        goto LABEL_131;
      }
      LODWORD(valuePtr[0]) = bswap32(*v24);
      uint64_t v10 = v178;
      if (a5)
      {
        CFTypeRef v53 = CFRetain(@"HorizontalFieldOfView");
        *(void *)(a5 + 8 * v179) = v53;
      }
      if (!v178) {
        goto LABEL_96;
      }
      CFAllocatorRef v54 = alloc;
LABEL_95:
      CFNumberRef v57 = CFNumberCreate(v54, kCFNumberSInt32Type, valuePtr);
      *(void *)(v10 + 8 * v179) = v57;
      if (!v57)
      {
LABEL_158:
        uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        goto LABEL_183;
      }
      goto LABEL_96;
    }
    if (v23 == 1718773093) {
      goto LABEL_180;
    }
    if (v23 != 1734438241) {
      goto LABEL_176;
    }
    if (v21 != 12) {
      goto LABEL_131;
    }
    *(double *)uint64_t valuePtr = (double)(int)bswap32(*v24) * 0.0000152587891;
    uint64_t v10 = v178;
    if (a5)
    {
      CFTypeRef v37 = CFRetain(v163);
      *(void *)(a5 + 8 * v179) = v37;
    }
    if (v178 && (CFNumberRef v38 = CFNumberCreate(0, kCFNumberDoubleType, valuePtr), (*(void *)(v178 + 8 * v179) = v38) == 0)) {
      uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    }
    else {
      uint64_t v17 = 0;
    }
    ++v179;
    LODWORD(v17CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
LABEL_260:
    if (v17) {
      goto LABEL_320;
    }
    goto LABEL_261;
  }
  if (v23 <= 1919907681)
  {
    if (v23 != 1835295606)
    {
      if (v23 != 1885434736) {
        goto LABEL_176;
      }
      if (v21 != 16) {
        goto LABEL_131;
      }
      uint64_t v50 = bswap32(*(_DWORD *)(v20 + 8));
      uint64_t v10 = v178;
      if ((int)v50 >= 1 && (int)bswap32(*(_DWORD *)(v20 + 12)) > 0)
      {
        if (a5)
        {
          CFTypeRef v51 = CFRetain(v153);
          *(void *)(a5 + 8 * v179) = v51;
        }
        if (!v178) {
          goto LABEL_154;
        }
        CFDataRef v52 = figBridge_CFDictionaryCreateWithNumbers(a1, a2, v152, a4, a5, a6, (uint64_t)a7, count, v50);
LABEL_153:
        *(void *)(v10 + 8 * v179) = v52;
        if (!v52)
        {
          uint64_t v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          goto LABEL_182;
        }
LABEL_154:
        uint64_t v17 = 0;
LABEL_182:
        uint64_t v19 = a2;
        goto LABEL_183;
      }
LABEL_157:
      FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
      goto LABEL_220;
    }
    CFAllocatorRef v31 = a1;
    uint64_t v10 = v178;
    uint64_t v32 = a5;
    uint64_t v33 = v178;
    CFAllocatorRef v34 = (UInt8 *)(v20 + 8);
    CFIndex v35 = (v21 - 8);
    CMTime v36 = @"MasteringDisplayColorVolume";
LABEL_122:
    uint64_t v30 = figBridge_WrapPayloadAsCFData(v31, v32, v33, &v179, v34, v35, v36);
    goto LABEL_123;
  }
  if (v23 == 1919907682)
  {
    if (v21 != 12) {
      goto LABEL_131;
    }
    LODWORD(valuePtr[0]) = bswap32(*v24);
    uint64_t v10 = v178;
    if (a5)
    {
      CFTypeRef v56 = CFRetain(@"CVBytesPerRow");
      *(void *)(a5 + 8 * v179) = v56;
    }
    if (!v178) {
      goto LABEL_96;
    }
    CFAllocatorRef v54 = 0;
    goto LABEL_95;
  }
  if (v23 != 1936289382)
  {
    if (v23 != 1986361461) {
      goto LABEL_176;
    }
    uint64_t v10 = v178;
    uint64_t v30 = VEXUBridge_ConvertVideoExtendedUsageDescriptionExtensions((uint64_t)a1, a5, v178, &v179, v20 + 8, v22, a9);
LABEL_123:
    uint64_t v17 = v30;
    goto LABEL_260;
  }
  if (!FigBridgeGetCommonEncryptionScheme(v20 + 8, v22)) {
    goto LABEL_176;
  }
  LODWORD(valuePtr[0]) = 0;
  if (a5)
  {
    CFTypeRef v58 = CFRetain(@"CommonEncryptionProtected");
    *(void *)(a5 + 8 * v179) = v58;
  }
  if (v178)
  {
    CFTypeRef v59 = CFRetain(v165);
    uint64_t v60 = v179;
    *(void *)(v178 + 8 * v179) = v59;
  }
  else
  {
    uint64_t v60 = v179;
  }
  uint64_t v179 = v60 + 1;
  LODWORD(valuePtr[0]) = FigBridgeGetOriginalFormatFromSinf(v20 + 8, v22);
  uint64_t v19 = a2;
  if (LODWORD(valuePtr[0]))
  {
    if (a5)
    {
      CFTypeRef v89 = CFRetain(@"CommonEncryptionOriginalFormat");
      *(void *)(a5 + 8 * v179) = v89;
    }
    if (v178)
    {
      CFNumberRef v90 = CFNumberCreate(alloc, kCFNumberSInt32Type, valuePtr);
      uint64_t v91 = v179;
      *(void *)(v178 + 8 * v179) = v90;
    }
    else
    {
      uint64_t v91 = v179;
    }
    uint64_t v19 = a2;
    uint64_t v179 = v91 + 1;
  }
  uint64_t v92 = FigBridgeExtractCommonEncryptionTrackEncryptionExtension(a1, a5, v178, &v179, v20 + 8, v22);
  if (!v92) {
    goto LABEL_176;
  }
  uint64_t v17 = v92;
  if (v14) {
    goto LABEL_321;
  }
  return v17;
}

void *figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions(void *result, _DWORD *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = 0;
  int valuePtr = (int)result;
  while (figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions_mpeg2ConformingVideoCodecTypes[v9] != result)
  {
    if (++v9 == 39) {
      return result;
    }
  }
  if (a4)
  {
    CFAllocatorRef result = (void *)CFRetain(@"ConformsToMPEG2VideoProfile");
    *(void *)(a4 + 8 * *a3) = result;
  }
  if (a5)
  {
    CFAllocatorRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
    uint64_t v10 = *a3;
    *(void *)(a5 + 8 * *a3) = result;
  }
  else
  {
    uint64_t v10 = *a3;
  }
  *a3 = v10 + 1;
  if (a2) {
    *a2 = 1836069494;
  }
  return result;
}

uint64_t FigH264Bridge_GetSPSFromAVCC(uint64_t a1, unint64_t a2, int a3, void *a4, void *a5)
{
  if (a2 >= 7)
  {
    int v5 = *(unsigned char *)(a1 + 5) & 0x1F;
    if ((*(unsigned char *)(a1 + 5) & 0x1F) == 0) {
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
    unsigned int v6 = 6;
    while (1)
    {
      unint64_t v7 = v6 + 2;
      if (v7 > a2) {
        break;
      }
      unsigned int v8 = *(unsigned __int16 *)(a1 + v6);
      uint64_t v9 = __rev16(v8);
      unint64_t v10 = v7 + (bswap32(v8) >> 16);
      if (v9 >= 2)
      {
        BOOL v11 = v10 >= a2;
        BOOL v12 = v10 == a2;
      }
      else
      {
        BOOL v11 = 1;
        BOOL v12 = 0;
      }
      if (!v12 && v11) {
        break;
      }
      if (!a3)
      {
        uint64_t v14 = 0;
        *a4 = a1 + v6 + 2;
        *a5 = v9;
        return v14;
      }
      --a3;
      unsigned int v6 = v10;
      if (!--v5) {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return 4294954582;
}

uint64_t FigH264Bridge_GetSPS_VUI_ChromaLocation(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  memset(v18, 0, sizeof(v18));
  uint64_t v15 = 0;
  size_t v16 = 0;
  uint64_t v17 = 0;
  CFDataRef theData = 0;
  uint64_t v8 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v8) {
    return v8;
  }
  CFDataRef v9 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v9);
  }
  uint64_t v14 = BytePtr;
  LODWORD(v15) = Length;
  size_t v16 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v17) = 0;
      __memcpy_chk();
      unsigned int v10 = v17;
    }
    else
    {
      unsigned int v10 = 0;
    }
  }
  else
  {
    unsigned int v10 = *(_DWORD *)BytePtr;
  }
  LODWORD(v17) = bswap32(v10);
  BYTE4(v17) = 0;
  uint64_t v11 = PullParamSetSPS((uint64_t)&v14, (char *)v18);
  if (v9) {
    CFRelease(v9);
  }
  if (!v11)
  {
    uint64_t v11 = 4294954584;
    if (HIDWORD(v19))
    {
      if (DWORD1(v23))
      {
        uint64_t v11 = 0;
        *a3 = DWORD2(v23);
        *a4 = HIDWORD(v23);
      }
    }
  }
  return v11;
}

uint64_t RemoveEmulation3Byte(const UInt8 *a1, unint64_t a2, __CFData **a3)
{
  if (a2 < 3)
  {
    uint64_t v8 = 0;
LABEL_15:
    if ((((_WORD)a2 + (_WORD)a1 + 3) & 0xFFC) == 0)
    {
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, a2 + 4);
      uint64_t v8 = Mutable;
      BOOL v12 = a1;
      CFIndex v11 = a2;
LABEL_17:
      CFDataAppendBytes(Mutable, v12, v11);
    }
  }
  else
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    uint64_t v8 = 0;
    int v9 = 0;
    for (unint64_t i = 2; i < a2; i += 3)
    {
      if (a1[v7] || *(_WORD *)&a1[v7 + 1] != 768)
      {
        unint64_t i = v7;
      }
      else
      {
        if (!v9)
        {
          uint64_t v8 = CFDataCreateMutable(0, a2 + 3);
          if (!v8)
          {
            uint64_t result = FigSignalErrorAt(12, 0, 0, 0, 0, 0, 0);
            goto LABEL_19;
          }
          int v9 = 1;
        }
        CFDataAppendBytes(v8, &a1[v6], i - v6);
        unint64_t v6 = v7 + 3;
      }
      unint64_t v7 = i + 1;
    }
    if (!v9) {
      goto LABEL_15;
    }
    CFIndex v11 = a2 - v6;
    if (a2 != v6)
    {
      BOOL v12 = &a1[v6];
      CFMutableDictionaryRef Mutable = v8;
      goto LABEL_17;
    }
  }
  uint64_t result = 0;
LABEL_19:
  *a3 = v8;
  return result;
}

uint64_t PullParamSetSPS(uint64_t a1, char *a2)
{
  unsigned int v263 = 0;
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 24);
  uint64_t v6 = *(unsigned __int8 *)(a1 + 28);
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = *(void *)a1;
  bzero(a2, 0x218uLL);
  LODWORD(v9) = v8;
  int v10 = v7;
  int v11 = (v6 + 1) & 7;
  BOOL v12 = (unsigned int *)(v4 + ((unint64_t)(v6 + 1) >> 3));
  int v13 = v8 + v7;
  int v14 = v8 + v7 - v12;
  if (v14 < 4)
  {
    if (v14 < 1)
    {
      int v15 = v11 | v14;
      if (v15)
      {
        LOBYTE(v17) = v11;
        goto LABEL_476;
      }
    }
    else
    {
      int v16 = *(unsigned __int8 *)v12;
      if (v14 == 1)
      {
        int v15 = v16 << 24;
      }
      else
      {
        int v18 = (v16 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v14 != 2) {
          v18 |= *((unsigned __int8 *)v12 + 2);
        }
        int v15 = v18 << 8;
      }
    }
  }
  else
  {
    int v15 = bswap32(*v12);
  }
  int v19 = (v11 + 2) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + ((v11 + 2) >> 3));
  int v20 = v13 - v12;
  if (v13 - (int)v12 < 4)
  {
    if (v20 < 1)
    {
      int v21 = v19 | v20;
      if (v21)
      {
        LOBYTE(v17) = (v11 + 2) & 7;
        goto LABEL_476;
      }
    }
    else
    {
      int v22 = *(unsigned __int8 *)v12;
      if (v20 == 1)
      {
        int v21 = v22 << 24;
      }
      else
      {
        int v23 = (v22 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v20 != 2) {
          v23 |= *((unsigned __int8 *)v12 + 2);
        }
        int v21 = v23 << 8;
      }
    }
  }
  else
  {
    int v21 = bswap32(*v12);
  }
  int v17 = (v19 + 5) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + ((v19 + 5) >> 3));
  int v24 = v13 - v12;
  if (v13 - (int)v12 < 4)
  {
    if (v24 < 1)
    {
      int v25 = v17 | v24;
      if (v25) {
        goto LABEL_476;
      }
      if (v5 < 0) {
        goto LABEL_487;
      }
    }
    else
    {
      int v26 = *(unsigned __int8 *)v12;
      if (v24 == 1)
      {
        int v25 = v26 << 24;
        if (v5 < 0) {
          goto LABEL_487;
        }
      }
      else
      {
        int v33 = (v26 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v24 != 2) {
          v33 |= *((unsigned __int8 *)v12 + 2);
        }
        int v25 = v33 << 8;
        if (v5 < 0) {
          goto LABEL_487;
        }
      }
    }
  }
  else
  {
    int v25 = bswap32(*v12);
    if (v5 < 0) {
      goto LABEL_487;
    }
  }
  if (!((v15 << v11) >> 30) || (v21 << v19) >> 27 != 7) {
    goto LABEL_487;
  }
  int v27 = v25 << v17;
  unsigned int v28 = (v25 << v17) >> 24;
  *(_DWORD *)a2 = v28;
  CFNumberRef v29 = (unsigned int *)((char *)v12 + 1);
  int v30 = v13 - (v12 + 1);
  if (v30 < 4)
  {
    if (v30 < 1)
    {
      int v31 = v17 | v30;
      if (v31) {
        goto LABEL_94;
      }
    }
    else
    {
      int v32 = *(unsigned __int8 *)v29;
      if (v30 == 1)
      {
        int v31 = v32 << 24;
      }
      else
      {
        int v34 = (v32 << 16) | (*((unsigned __int8 *)v12 + 2) << 8);
        if (v30 != 2) {
          v34 |= *((unsigned __int8 *)v12 + 3);
        }
        int v31 = v34 << 8;
      }
    }
  }
  else
  {
    int v31 = bswap32(*v29);
  }
  *((_DWORD *)a2 + 2) = (v31 << v17) >> 31;
  uint64_t v35 = (v17 + 1) >> 3;
  int v17 = (v17 + 1) & 7;
  BOOL v12 = (unsigned int *)((char *)v29 + v35);
  int v36 = v13 - (v29 + v35);
  if (v36 < 4)
  {
    if (v36 < 1)
    {
      int v37 = v17 | v36;
      if (v37) {
        goto LABEL_476;
      }
    }
    else
    {
      int v38 = *(unsigned __int8 *)v12;
      if (v36 == 1)
      {
        int v37 = v38 << 24;
      }
      else
      {
        int v39 = (v38 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v36 != 2) {
          v39 |= *((unsigned __int8 *)v12 + 2);
        }
        int v37 = v39 << 8;
      }
    }
  }
  else
  {
    int v37 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 3) = (v37 << v17) >> 31;
  uint64_t v40 = (v17 + 1) >> 3;
  int v17 = (v17 + 1) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + v40);
  int v41 = v13 - v12;
  if (v13 - (int)v12 < 4)
  {
    if (v41 < 1)
    {
      int v42 = v17 | v41;
      if (v42) {
        goto LABEL_476;
      }
    }
    else
    {
      int v43 = *(unsigned __int8 *)v12;
      if (v41 == 1)
      {
        int v42 = v43 << 24;
      }
      else
      {
        int v44 = (v43 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v41 != 2) {
          v44 |= *((unsigned __int8 *)v12 + 2);
        }
        int v42 = v44 << 8;
      }
    }
  }
  else
  {
    int v42 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 4) = (v42 << v17) >> 31;
  uint64_t v45 = (v17 + 1) >> 3;
  int v17 = (v17 + 1) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + v45);
  int v46 = v13 - v12;
  if (v13 - (int)v12 < 4)
  {
    if (v46 < 1)
    {
      int v47 = v17 | v46;
      if (v47) {
        goto LABEL_476;
      }
    }
    else
    {
      int v48 = *(unsigned __int8 *)v12;
      if (v46 == 1)
      {
        int v47 = v48 << 24;
      }
      else
      {
        int v49 = (v48 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v46 != 2) {
          v49 |= *((unsigned __int8 *)v12 + 2);
        }
        int v47 = v49 << 8;
      }
    }
  }
  else
  {
    int v47 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 5) = (v47 << v17) >> 31;
  uint64_t v50 = (v17 + 1) >> 3;
  int v17 = (v17 + 1) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + v50);
  if (v13 - (int)v12 <= 0 && v17 | (v13 - v12)) {
    goto LABEL_476;
  }
  uint64_t v51 = (v17 + 4) >> 3;
  int v17 = (v17 + 4) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + v51);
  int v52 = v13 - v12;
  if (v13 - (int)v12 < 4)
  {
    if (v52 < 1)
    {
      int v53 = v17 | v52;
      if (v53) {
        goto LABEL_476;
      }
    }
    else
    {
      int v54 = *(unsigned __int8 *)v12;
      if (v52 == 1)
      {
        int v53 = v54 << 24;
      }
      else
      {
        int v55 = (v54 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v52 != 2) {
          v55 |= *((unsigned __int8 *)v12 + 2);
        }
        int v53 = v55 << 8;
      }
    }
  }
  else
  {
    int v53 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 1) = (v53 << v17) >> 24;
  CFNumberRef v29 = (unsigned int *)((char *)v12 + 1);
  int v56 = v13 - (v12 + 1);
  if (v56 >= 4)
  {
    int v57 = bswap32(*v29);
    goto LABEL_98;
  }
  if (v56 < 1)
  {
    int v57 = v17 | v56;
    if (!v57) {
      goto LABEL_98;
    }
LABEL_94:
    uint64_t v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    unsigned int v60 = 0;
LABEL_489:
    BOOL v12 = v29;
LABEL_484:
    unsigned int v261 = v60;
    if (v59) {
      return v59;
    }
    goto LABEL_481;
  }
  int v58 = *(unsigned __int8 *)v29;
  if (v56 == 1)
  {
    int v57 = v58 << 24;
  }
  else
  {
    int v61 = (v58 << 16) | (*((unsigned __int8 *)v12 + 2) << 8);
    if (v56 != 2) {
      v61 |= *((unsigned __int8 *)v12 + 3);
    }
    int v57 = v61 << 8;
  }
LABEL_98:
  unsigned int v60 = v57 << v17;
  if (!((v57 << v17) >> 19))
  {
    uint64_t v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_489;
  }
  unsigned int v62 = __clz(v60);
  unsigned int v63 = v60 << (v62 + 1) >> -(char)v62;
  if (!v62) {
    unsigned int v63 = 0;
  }
  int v64 = v63 + ~(-1 << v62);
  *((_DWORD *)a2 + 9) = v64;
  unsigned int v65 = v62 + v17 + v62 + 1;
  uint64_t v66 = v65 >> 3;
  int v17 = v65 & 7;
  BOOL v12 = (unsigned int *)((char *)v29 + v66);
  int v67 = v13 - (v29 + v66);
  if (v67 < 4)
  {
    if (v67 < 1)
    {
      int v68 = v17 | v67;
      if (v68) {
        goto LABEL_476;
      }
    }
    else
    {
      int v69 = *(unsigned __int8 *)v12;
      if (v67 == 1)
      {
        int v68 = v69 << 24;
      }
      else
      {
        int v70 = (v69 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v67 != 2) {
          v70 |= *((unsigned __int8 *)v12 + 2);
        }
        int v68 = v70 << 8;
      }
    }
  }
  else
  {
    int v68 = bswap32(*v12);
  }
  unsigned int v60 = v68 << v17;
  int32x4_t v71 = vdupq_n_s32(v28);
  int16x8_t v72 = (int16x8_t)vceqq_s32(v71, (int32x4_t)xmmword_18FE96500);
  v71.i32[2] = v27 & 0xDF000000;
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16(v72, (int16x8_t)vceqq_s32(v71, (int32x4_t)xmmword_18FE964F0)))) & 1) != 0
    || (int v80 = v28 & 0xFE, v80 == 138)
    || v80 == 134)
  {
    if (!(v60 >> 19)) {
      goto LABEL_486;
    }
    unsigned int v73 = __clz(v60);
    unsigned int v74 = v60 << (v73 + 1) >> -(char)v73;
    if (!v73) {
      unsigned int v74 = 0;
    }
    unsigned int v75 = v74 + ~(-1 << v73);
    a2[40] = v75;
    unsigned int v76 = v73 + v17 + v73 + 1;
    int v17 = v76 & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + (v76 >> 3));
    int v77 = v13 - v12;
    if (v13 - (int)v12 < 4)
    {
      if (v77 < 1)
      {
        int v78 = v17 | v77;
        if (v78) {
          goto LABEL_476;
        }
      }
      else
      {
        int v79 = *(unsigned __int8 *)v12;
        if (v77 == 1)
        {
          int v78 = v79 << 24;
        }
        else
        {
          int v81 = (v79 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v77 != 2) {
            v81 |= *((unsigned __int8 *)v12 + 2);
          }
          int v78 = v81 << 8;
        }
      }
    }
    else
    {
      int v78 = bswap32(*v12);
    }
    if (v75 >= 4u) {
      goto LABEL_487;
    }
    unsigned int v60 = v78 << v17;
    if (v75 == 3)
    {
      a2[41] = (v60 & 0x80000000) != 0;
      uint64_t v82 = (v17 + 1) >> 3;
      int v17 = (v17 + 1) & 7;
      BOOL v12 = (unsigned int *)((char *)v12 + v82);
      int v83 = v13 - v12;
      if (v13 - (int)v12 < 4)
      {
        if (v83 < 1)
        {
          int v84 = v17 | v83;
          if (v84) {
            goto LABEL_476;
          }
        }
        else
        {
          int v85 = *(unsigned __int8 *)v12;
          if (v83 == 1)
          {
            int v84 = v85 << 24;
          }
          else
          {
            int v86 = (v85 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v83 != 2) {
              v86 |= *((unsigned __int8 *)v12 + 2);
            }
            int v84 = v86 << 8;
          }
        }
      }
      else
      {
        int v84 = bswap32(*v12);
      }
      unsigned int v60 = v84 << v17;
    }
    if (!(v60 >> 19)) {
      goto LABEL_486;
    }
    unsigned int v87 = __clz(v60);
    unsigned int v88 = v60 << (v87 + 1) >> -(char)v87;
    if (!v87) {
      unsigned int v88 = 0;
    }
    unsigned int v89 = v88 + ~(-1 << v87);
    a2[42] = v89;
    unsigned int v90 = v87 + v17 + v87 + 1;
    int v17 = v90 & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + (v90 >> 3));
    int v91 = v13 - v12;
    if (v13 - (int)v12 < 4)
    {
      if (v91 < 1)
      {
        int v92 = v17 | v91;
        if (v92) {
          goto LABEL_476;
        }
      }
      else
      {
        int v93 = *(unsigned __int8 *)v12;
        if (v91 == 1)
        {
          int v92 = v93 << 24;
        }
        else
        {
          int v94 = (v93 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v91 != 2) {
            v94 |= *((unsigned __int8 *)v12 + 2);
          }
          int v92 = v94 << 8;
        }
      }
    }
    else
    {
      int v92 = bswap32(*v12);
    }
    if (v89 >= 7u) {
      goto LABEL_487;
    }
    unsigned int v60 = v92 << v17;
    if (!((v92 << v17) >> 19)) {
      goto LABEL_486;
    }
    unsigned int v95 = __clz(v60);
    unsigned int v96 = v60 << (v95 + 1) >> -(char)v95;
    if (!v95) {
      unsigned int v96 = 0;
    }
    unsigned int v97 = v96 + ~(-1 << v95);
    a2[43] = v97;
    unsigned int v98 = v95 + v17 + v95 + 1;
    int v17 = v98 & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + (v98 >> 3));
    int v99 = v13 - v12;
    if (v13 - (int)v12 < 4)
    {
      if (v99 < 1)
      {
        int v100 = v17 | v99;
        if (v100) {
          goto LABEL_476;
        }
      }
      else
      {
        int v101 = *(unsigned __int8 *)v12;
        if (v99 == 1)
        {
          int v100 = v101 << 24;
        }
        else
        {
          int v102 = (v101 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v99 != 2) {
            v102 |= *((unsigned __int8 *)v12 + 2);
          }
          int v100 = v102 << 8;
        }
      }
    }
    else
    {
      int v100 = bswap32(*v12);
    }
    if (v97 >= 7u) {
      goto LABEL_487;
    }
    uint64_t v59 = v263;
    if (v263) {
      return v59;
    }
    a2[44] = v100 << v17 < 0;
    uint64_t v103 = (v17 + 1) >> 3;
    int v17 = (v17 + 1) & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + v103);
    int v104 = v13 - v12;
    if (v13 - (int)v12 < 4)
    {
      if (v104 < 1)
      {
        int v105 = v17 | v104;
        if (v105) {
          goto LABEL_476;
        }
      }
      else
      {
        int v106 = *(unsigned __int8 *)v12;
        if (v104 == 1)
        {
          int v105 = v106 << 24;
        }
        else
        {
          int v107 = (v106 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v104 != 2) {
            v107 |= *((unsigned __int8 *)v12 + 2);
          }
          int v105 = v107 << 8;
        }
      }
    }
    else
    {
      int v105 = bswap32(*v12);
    }
    int v108 = v105 << v17;
    a2[45] = v108 < 0;
    unsigned int v109 = v17 + 1;
    int v17 = (v17 + 1) & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + (v109 >> 3));
    int v110 = v13 - v12;
    if (v110 < 4)
    {
      if (v110 < 1)
      {
        int v111 = v17 | v110;
        if (v111) {
          goto LABEL_476;
        }
      }
      else
      {
        int v112 = *(unsigned __int8 *)v12;
        if (v110 == 1)
        {
          int v111 = v112 << 24;
        }
        else
        {
          int v113 = (v112 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v110 != 2) {
            v113 |= *((unsigned __int8 *)v12 + 2);
          }
          int v111 = v113 << 8;
        }
      }
    }
    else
    {
      int v111 = bswap32(*v12);
    }
    unsigned int v60 = v111 << v17;
    if (v108 < 0)
    {
      unsigned int v114 = 0;
      while (1)
      {
        uint64_t v59 = v263;
        if (v263) {
          return v59;
        }
        uint64_t v115 = (v17 + 1) >> 3;
        int v17 = (v17 + 1) & 7;
        BOOL v12 = (unsigned int *)((char *)v12 + v115);
        int v116 = v9 + v10 - v12;
        if (v116 < 4)
        {
          if (v116 < 1)
          {
            int v117 = v17 | v116;
            if (v117) {
              goto LABEL_476;
            }
          }
          else
          {
            int v118 = *(unsigned __int8 *)v12;
            if (v116 == 1)
            {
              int v117 = v118 << 24;
            }
            else
            {
              int v119 = (v118 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
              if (v116 != 2) {
                v119 |= *((unsigned __int8 *)v12 + 2);
              }
              int v117 = v119 << 8;
            }
          }
        }
        else
        {
          int v117 = bswap32(*v12);
        }
        unsigned int v120 = v117 << v17;
        if ((v60 & 0x80000000) != 0)
        {
          *(void *)(a1 + 16) = v12;
          *(_DWORD *)(a1 + 24) = v120;
          *(unsigned char *)(a1 + 28) = v17;
          if (v114 >= 6) {
            int v121 = 64;
          }
          else {
            int v121 = 16;
          }
          scaling_list(a1, v121, &v263);
          BOOL v12 = *(unsigned int **)(a1 + 16);
          unsigned int v60 = *(_DWORD *)(a1 + 24);
          int v17 = *(unsigned __int8 *)(a1 + 28);
          int v10 = *(_DWORD *)(a1 + 8);
          uint64_t v9 = *(void *)a1;
        }
        else
        {
          unsigned int v60 = v120;
        }
        ++v114;
        if (a2[40] == 3) {
          unsigned int v122 = 12;
        }
        else {
          unsigned int v122 = 8;
        }
        if (v114 >= v122)
        {
          int v64 = *((_DWORD *)a2 + 9);
          break;
        }
      }
    }
  }
  else
  {
    a2[40] = 1;
  }
  if (v64 >= 32) {
    goto LABEL_487;
  }
  uint64_t v59 = v263;
  if (v263) {
    return v59;
  }
  if (!(v60 >> 19)) {
    goto LABEL_486;
  }
  unsigned int v123 = __clz(v60);
  unsigned int v124 = v60 << (v123 + 1) >> -(char)v123;
  if (!v123) {
    unsigned int v124 = 0;
  }
  *((_DWORD *)a2 + 72) = v124 + ~(-1 << v123);
  unsigned int v125 = v123 + v17 + v123 + 1;
  int v17 = v125 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v125 >> 3));
  int v126 = v9 + v10;
  int v127 = v9 + v10 - v12;
  if (v127 < 4)
  {
    if (v127 < 1)
    {
      int v128 = v17 | v127;
      if (v128) {
        goto LABEL_476;
      }
    }
    else
    {
      int v129 = *(unsigned __int8 *)v12;
      if (v127 == 1)
      {
        int v128 = v129 << 24;
      }
      else
      {
        int v130 = (v129 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v127 != 2) {
          v130 |= *((unsigned __int8 *)v12 + 2);
        }
        int v128 = v130 << 8;
      }
    }
  }
  else
  {
    int v128 = bswap32(*v12);
  }
  unsigned int v60 = v128 << v17;
  if (!((v128 << v17) >> 19)) {
    goto LABEL_486;
  }
  unsigned int v131 = __clz(v60);
  unsigned int v132 = v60 << (v131 + 1) >> -(char)v131;
  if (!v131) {
    unsigned int v132 = 0;
  }
  unsigned int v133 = v132 + ~(-1 << v131);
  *((_DWORD *)a2 + 73) = v133;
  unsigned int v134 = v131 + v17 + v131 + 1;
  int v17 = v134 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v134 >> 3));
  int v135 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v135 < 1)
    {
      int v136 = v17 | v135;
      if (v136) {
        goto LABEL_476;
      }
    }
    else
    {
      int v137 = *(unsigned __int8 *)v12;
      if (v135 == 1)
      {
        int v136 = v137 << 24;
      }
      else
      {
        int v138 = (v137 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v135 != 2) {
          v138 |= *((unsigned __int8 *)v12 + 2);
        }
        int v136 = v138 << 8;
      }
    }
  }
  else
  {
    int v136 = bswap32(*v12);
  }
  unsigned int v60 = v136 << v17;
  if (v133 != 1)
  {
    if (v133) {
      goto LABEL_322;
    }
    if (v60 >> 19)
    {
      unsigned int v139 = __clz(v60);
      unsigned int v140 = v60 << (v139 + 1) >> -(char)v139;
      if (!v139) {
        unsigned int v140 = 0;
      }
      int v141 = v140 + ~(-1 << v139);
      *((_DWORD *)a2 + 74) = v141;
      unsigned int v142 = v139 + v17 + v139 + 1;
      int v17 = v142 & 7;
      BOOL v12 = (unsigned int *)((char *)v12 + (v142 >> 3));
      int v143 = v126 - v12;
      if (v126 - (int)v12 < 4)
      {
        if (v143 < 1)
        {
          int v144 = v17 | v143;
          if (v144) {
            goto LABEL_476;
          }
        }
        else
        {
          int v149 = *(unsigned __int8 *)v12;
          if (v143 == 1)
          {
            int v144 = v149 << 24;
          }
          else
          {
            int v157 = (v149 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v143 != 2) {
              v157 |= *((unsigned __int8 *)v12 + 2);
            }
            int v144 = v157 << 8;
          }
        }
      }
      else
      {
        int v144 = bswap32(*v12);
      }
      if (v141 >= 13) {
        goto LABEL_487;
      }
      unsigned int v60 = v144 << v17;
      *((_DWORD *)a2 + 132) = 1 << (v141 + 4);
      *(void *)(a2 + 308) = 0;
      *(void *)(a2 + 30CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
      goto LABEL_322;
    }
LABEL_486:
    uint64_t v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_484;
  }
  *((_DWORD *)a2 + 75) = v60 >> 31;
  uint64_t v145 = (v17 + 1) >> 3;
  int v17 = (v17 + 1) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + v145);
  int v146 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v146 < 1)
    {
      int v147 = v17 | v146;
      if (v147) {
        goto LABEL_476;
      }
    }
    else
    {
      int v148 = *(unsigned __int8 *)v12;
      if (v146 == 1)
      {
        int v147 = v148 << 24;
      }
      else
      {
        int v150 = (v148 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v146 != 2) {
          v150 |= *((unsigned __int8 *)v12 + 2);
        }
        int v147 = v150 << 8;
      }
    }
  }
  else
  {
    int v147 = bswap32(*v12);
  }
  unsigned int v60 = v147 << v17;
  if (!((v147 << v17) >> 19)) {
    goto LABEL_486;
  }
  unsigned int v151 = __clz(v60);
  unsigned int v152 = v60 << (v151 + 1) >> -(char)v151;
  if (!v151) {
    unsigned int v152 = 0;
  }
  unsigned int v153 = v151 + v17 + v151 + 1;
  int v17 = v153 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v153 >> 3));
  int v154 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v154 < 1)
    {
      int v155 = v17 | v154;
      if (v155) {
        goto LABEL_476;
      }
    }
    else
    {
      int v156 = *(unsigned __int8 *)v12;
      if (v154 == 1)
      {
        int v155 = v156 << 24;
      }
      else
      {
        int v158 = (v156 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v154 != 2) {
          v158 |= *((unsigned __int8 *)v12 + 2);
        }
        int v155 = v158 << 8;
      }
    }
  }
  else
  {
    int v155 = bswap32(*v12);
  }
  unsigned int v60 = v155 << v17;
  *((_DWORD *)a2 + 76) = ((v152 + (1 << v151)) >> 1) - ((v152 + (1 << v151)) >> 1) * 2 * ((v152 + (1 << v151)) & 1);
  if (!((v155 << v17) >> 19)) {
    goto LABEL_486;
  }
  unsigned int v159 = __clz(v60);
  unsigned int v160 = v60 << (v159 + 1) >> -(char)v159;
  if (!v159) {
    unsigned int v160 = 0;
  }
  unsigned int v161 = v159 + v17 + v159 + 1;
  int v17 = v161 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v161 >> 3));
  int v162 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v162 < 1)
    {
      int v163 = v17 | v162;
      if (v163) {
        goto LABEL_476;
      }
    }
    else
    {
      int v164 = *(unsigned __int8 *)v12;
      if (v162 == 1)
      {
        int v163 = v164 << 24;
      }
      else
      {
        int v165 = (v164 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v162 != 2) {
          v165 |= *((unsigned __int8 *)v12 + 2);
        }
        int v163 = v165 << 8;
      }
    }
  }
  else
  {
    int v163 = bswap32(*v12);
  }
  unsigned int v60 = v163 << v17;
  *((_DWORD *)a2 + 77) = ((v160 + (1 << v159)) >> 1) - ((v160 + (1 << v159)) >> 1) * 2 * ((v160 + (1 << v159)) & 1);
  if (!((v163 << v17) >> 19)) {
    goto LABEL_486;
  }
  unsigned int v166 = __clz(v60);
  unsigned int v167 = v60 << (v166 + 1) >> -(char)v166;
  if (!v166) {
    unsigned int v167 = 0;
  }
  int v168 = v167 + ~(-1 << v166);
  *((_DWORD *)a2 + 78) = v168;
  unsigned int v169 = v166 + v17 + v166 + 1;
  int v17 = v169 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v169 >> 3));
  int v170 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v170 < 1)
    {
      int v171 = v17 | v170;
      if (v171) {
        goto LABEL_476;
      }
    }
    else
    {
      int v172 = *(unsigned __int8 *)v12;
      if (v170 == 1)
      {
        int v171 = v172 << 24;
      }
      else
      {
        int v173 = (v172 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v170 != 2) {
          v173 |= *((unsigned __int8 *)v12 + 2);
        }
        int v171 = v173 << 8;
      }
    }
  }
  else
  {
    int v171 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 132) = 0;
  if (v168 > 255) {
    goto LABEL_487;
  }
  unsigned int v60 = v171 << v17;
  if (v168 >= 1)
  {
    while (v60 >> 19)
    {
      unsigned int v174 = v17 + 2 * __clz(v60) + 1;
      int v17 = v174 & 7;
      BOOL v12 = (unsigned int *)((char *)v12 + (v174 >> 3));
      int v175 = v126 - v12;
      if (v126 - (int)v12 < 4)
      {
        if (v175 < 1)
        {
          int v176 = v17 | v175;
          if (v176) {
            goto LABEL_476;
          }
        }
        else
        {
          int v177 = *(unsigned __int8 *)v12;
          if (v175 == 1)
          {
            int v176 = v177 << 24;
          }
          else
          {
            int v178 = (v177 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v175 != 2) {
              v178 |= *((unsigned __int8 *)v12 + 2);
            }
            int v176 = v178 << 8;
          }
        }
      }
      else
      {
        int v176 = bswap32(*v12);
      }
      unsigned int v60 = v176 << v17;
      if (!--v168) {
        goto LABEL_322;
      }
    }
    goto LABEL_486;
  }
LABEL_322:
  if (!(v60 >> 19)) {
    goto LABEL_486;
  }
  unsigned int v179 = __clz(v60);
  unsigned int v180 = v60 << (v179 + 1) >> -(char)v179;
  if (!v179) {
    unsigned int v180 = 0;
  }
  *((_DWORD *)a2 + 79) = v180 + ~(-1 << v179);
  unsigned int v181 = v179 + v17 + v179 + 1;
  int v17 = v181 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v181 >> 3));
  int v182 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v182 < 1)
    {
      int v183 = v17 | v182;
      if (v183) {
        goto LABEL_476;
      }
    }
    else
    {
      int v184 = *(unsigned __int8 *)v12;
      if (v182 == 1)
      {
        int v183 = v184 << 24;
      }
      else
      {
        int v185 = (v184 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v182 != 2) {
          v185 |= *((unsigned __int8 *)v12 + 2);
        }
        int v183 = v185 << 8;
      }
    }
  }
  else
  {
    int v183 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = (v183 << v17) >> 31;
  uint64_t v186 = (v17 + 1) >> 3;
  int v17 = (v17 + 1) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + v186);
  int v187 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v187 < 1)
    {
      int v188 = v17 | v187;
      if (v188) {
        goto LABEL_476;
      }
    }
    else
    {
      int v189 = *(unsigned __int8 *)v12;
      if (v187 == 1)
      {
        int v188 = v189 << 24;
      }
      else
      {
        int v190 = (v189 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v187 != 2) {
          v190 |= *((unsigned __int8 *)v12 + 2);
        }
        int v188 = v190 << 8;
      }
    }
  }
  else
  {
    int v188 = bswap32(*v12);
  }
  unsigned int v60 = v188 << v17;
  if (!((v188 << v17) >> 19)) {
    goto LABEL_486;
  }
  unsigned int v191 = __clz(v60);
  unsigned int v192 = v60 << (v191 + 1) >> -(char)v191;
  if (!v191) {
    unsigned int v192 = 0;
  }
  *((_DWORD *)a2 + 81) = v192 + ~(-1 << v191);
  unsigned int v193 = v191 + v17 + v191 + 1;
  int v17 = v193 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v193 >> 3));
  int v194 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v194 < 1)
    {
      int v195 = v17 | v194;
      if (v195) {
        goto LABEL_476;
      }
    }
    else
    {
      int v196 = *(unsigned __int8 *)v12;
      if (v194 == 1)
      {
        int v195 = v196 << 24;
      }
      else
      {
        int v197 = (v196 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v194 != 2) {
          v197 |= *((unsigned __int8 *)v12 + 2);
        }
        int v195 = v197 << 8;
      }
    }
  }
  else
  {
    int v195 = bswap32(*v12);
  }
  unsigned int v60 = v195 << v17;
  if (!((v195 << v17) >> 19)) {
    goto LABEL_486;
  }
  unsigned int v198 = __clz(v60);
  unsigned int v199 = v60 << (v198 + 1) >> -(char)v198;
  if (!v198) {
    unsigned int v199 = 0;
  }
  *((_DWORD *)a2 + 82) = v199 + ~(-1 << v198);
  unsigned int v200 = v198 + v17 + v198 + 1;
  int v17 = v200 & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + (v200 >> 3));
  int v201 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v201 < 1)
    {
      int v202 = v17 | v201;
      if (v202) {
        goto LABEL_476;
      }
    }
    else
    {
      int v203 = *(unsigned __int8 *)v12;
      if (v201 == 1)
      {
        int v202 = v203 << 24;
      }
      else
      {
        int v204 = (v203 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v201 != 2) {
          v204 |= *((unsigned __int8 *)v12 + 2);
        }
        int v202 = v204 << 8;
      }
    }
  }
  else
  {
    int v202 = bswap32(*v12);
  }
  unsigned int v205 = v202 << v17;
  *((_DWORD *)a2 + 83) = v205 >> 31;
  uint64_t v206 = (v17 + 1) >> 3;
  int v17 = (v17 + 1) & 7;
  BOOL v12 = (unsigned int *)((char *)v12 + v206);
  int v207 = v126 - v12;
  if (v126 - (int)v12 < 4)
  {
    if (v207 < 1)
    {
      int v208 = v17 | v207;
      if (v208) {
        goto LABEL_476;
      }
    }
    else
    {
      int v209 = *(unsigned __int8 *)v12;
      if (v207 == 1)
      {
        int v208 = v209 << 24;
      }
      else
      {
        int v210 = (v209 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v207 != 2) {
          v210 |= *((unsigned __int8 *)v12 + 2);
        }
        int v208 = v210 << 8;
      }
    }
  }
  else
  {
    int v208 = bswap32(*v12);
  }
  unsigned int v211 = v208 << v17;
  if ((v205 & 0x80000000) != 0)
  {
    *((_DWORD *)a2 + 84) = 0;
  }
  else
  {
    uint64_t v59 = v263;
    if (v263) {
      return v59;
    }
    *((_DWORD *)a2 + 84) = v211 >> 31;
    uint64_t v212 = (v17 + 1) >> 3;
    int v17 = (v17 + 1) & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + v212);
    int v213 = v126 - v12;
    if (v126 - (int)v12 < 4)
    {
      if (v213 < 1)
      {
        int v214 = v17 | v213;
        if (v214) {
          goto LABEL_476;
        }
      }
      else
      {
        int v215 = *(unsigned __int8 *)v12;
        if (v213 == 1)
        {
          int v214 = v215 << 24;
        }
        else
        {
          int v216 = (v215 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v213 != 2) {
            v216 |= *((unsigned __int8 *)v12 + 2);
          }
          int v214 = v216 << 8;
        }
      }
    }
    else
    {
      int v214 = bswap32(*v12);
    }
    unsigned int v211 = v214 << v17;
  }
  uint64_t v59 = v263;
  if (!v263)
  {
    *((_DWORD *)a2 + 85) = v211 >> 31;
    uint64_t v217 = (v17 + 1) >> 3;
    int v17 = (v17 + 1) & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + v217);
    int v218 = v126 - v12;
    if (v126 - (int)v12 < 4)
    {
      if (v218 < 1)
      {
        int v219 = v17 | v218;
        if (v219) {
          goto LABEL_476;
        }
      }
      else
      {
        int v220 = *(unsigned __int8 *)v12;
        if (v218 == 1)
        {
          int v219 = v220 << 24;
        }
        else
        {
          int v221 = (v220 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v218 != 2) {
            v221 |= *((unsigned __int8 *)v12 + 2);
          }
          int v219 = v221 << 8;
        }
      }
    }
    else
    {
      int v219 = bswap32(*v12);
    }
    unsigned int v222 = v219 << v17;
    *((_DWORD *)a2 + 86) = v222 >> 31;
    uint64_t v223 = (v17 + 1) >> 3;
    int v17 = (v17 + 1) & 7;
    BOOL v12 = (unsigned int *)((char *)v12 + v223);
    int v224 = v126 - v12;
    if (v126 - (int)v12 < 4)
    {
      if (v224 < 1)
      {
        int v225 = v17 | v224;
        if (v225) {
          goto LABEL_476;
        }
      }
      else
      {
        int v226 = *(unsigned __int8 *)v12;
        if (v224 == 1)
        {
          int v225 = v226 << 24;
        }
        else
        {
          int v227 = (v226 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v224 != 2) {
            v227 |= *((unsigned __int8 *)v12 + 2);
          }
          int v225 = v227 << 8;
        }
      }
    }
    else
    {
      int v225 = bswap32(*v12);
    }
    unsigned int v60 = v225 << v17;
    if ((v222 & 0x80000000) == 0) {
      goto LABEL_470;
    }
    if (v60 >> 19)
    {
      unsigned int v228 = __clz(v60);
      unsigned int v229 = v60 << (v228 + 1) >> -(char)v228;
      if (!v228) {
        unsigned int v229 = 0;
      }
      *((_DWORD *)a2 + 87) = v229 + ~(-1 << v228);
      unsigned int v230 = v228 + v17 + v228 + 1;
      int v17 = v230 & 7;
      BOOL v12 = (unsigned int *)((char *)v12 + (v230 >> 3));
      int v231 = v126 - v12;
      if (v126 - (int)v12 < 4)
      {
        if (v231 < 1)
        {
          int v232 = v17 | v231;
          if (v232) {
            goto LABEL_476;
          }
        }
        else
        {
          int v233 = *(unsigned __int8 *)v12;
          if (v231 == 1)
          {
            int v232 = v233 << 24;
          }
          else
          {
            int v234 = (v233 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v231 != 2) {
              v234 |= *((unsigned __int8 *)v12 + 2);
            }
            int v232 = v234 << 8;
          }
        }
      }
      else
      {
        int v232 = bswap32(*v12);
      }
      unsigned int v60 = v232 << v17;
      if ((v232 << v17) >> 19)
      {
        unsigned int v235 = __clz(v60);
        unsigned int v236 = v60 << (v235 + 1) >> -(char)v235;
        if (!v235) {
          unsigned int v236 = 0;
        }
        *((_DWORD *)a2 + 88) = v236 + ~(-1 << v235);
        unsigned int v237 = v235 + v17 + v235 + 1;
        int v17 = v237 & 7;
        BOOL v12 = (unsigned int *)((char *)v12 + (v237 >> 3));
        int v238 = v126 - v12;
        if (v126 - (int)v12 < 4)
        {
          if (v238 < 1)
          {
            int v239 = v17 | v238;
            if (v239) {
              goto LABEL_476;
            }
          }
          else
          {
            int v240 = *(unsigned __int8 *)v12;
            if (v238 == 1)
            {
              int v239 = v240 << 24;
            }
            else
            {
              int v241 = (v240 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
              if (v238 != 2) {
                v241 |= *((unsigned __int8 *)v12 + 2);
              }
              int v239 = v241 << 8;
            }
          }
        }
        else
        {
          int v239 = bswap32(*v12);
        }
        unsigned int v60 = v239 << v17;
        if ((v239 << v17) >> 19)
        {
          unsigned int v242 = __clz(v60);
          unsigned int v243 = v60 << (v242 + 1) >> -(char)v242;
          if (!v242) {
            unsigned int v243 = 0;
          }
          *((_DWORD *)a2 + 89) = v243 + ~(-1 << v242);
          unsigned int v244 = v242 + v17 + v242 + 1;
          int v17 = v244 & 7;
          BOOL v12 = (unsigned int *)((char *)v12 + (v244 >> 3));
          int v245 = v126 - v12;
          if (v126 - (int)v12 < 4)
          {
            if (v245 < 1)
            {
              int v246 = v17 | v245;
              if (v246) {
                goto LABEL_476;
              }
            }
            else
            {
              int v247 = *(unsigned __int8 *)v12;
              if (v245 == 1)
              {
                int v246 = v247 << 24;
              }
              else
              {
                int v248 = (v247 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
                if (v245 != 2) {
                  v248 |= *((unsigned __int8 *)v12 + 2);
                }
                int v246 = v248 << 8;
              }
            }
          }
          else
          {
            int v246 = bswap32(*v12);
          }
          unsigned int v60 = v246 << v17;
          if ((v246 << v17) >> 19)
          {
            unsigned int v249 = __clz(v60);
            unsigned int v250 = v60 << (v249 + 1) >> -(char)v249;
            if (!v249) {
              unsigned int v250 = 0;
            }
            *((_DWORD *)a2 + 9CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v250 + ~(-1 << v249);
            unsigned int v251 = v249 + v17 + v249 + 1;
            int v17 = v251 & 7;
            BOOL v12 = (unsigned int *)((char *)v12 + (v251 >> 3));
            int v252 = v126 - v12;
            if (v126 - (int)v12 < 4)
            {
              if (v252 < 1)
              {
                int v253 = v17 | v252;
                if (v253) {
                  goto LABEL_476;
                }
              }
              else
              {
                int v254 = *(unsigned __int8 *)v12;
                if (v252 == 1)
                {
                  int v253 = v254 << 24;
                }
                else
                {
                  int v255 = (v254 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
                  if (v252 != 2) {
                    v255 |= *((unsigned __int8 *)v12 + 2);
                  }
                  int v253 = v255 << 8;
                }
              }
            }
            else
            {
              int v253 = bswap32(*v12);
            }
            unsigned int v60 = v253 << v17;
LABEL_470:
            *((_DWORD *)a2 + 91) = v60 >> 31;
            unsigned int v256 = v17 + 1;
            int v17 = (v17 + 1) & 7;
            BOOL v12 = (unsigned int *)((char *)v12 + (v256 >> 3));
            int v257 = v126 - v12;
            if (v257 >= 4)
            {
              int v258 = bswap32(*v12);
              goto LABEL_480;
            }
            if (v257 >= 1)
            {
              int v259 = *(unsigned __int8 *)v12;
              if (v257 == 1)
              {
                int v258 = v259 << 24;
              }
              else
              {
                int v260 = (v259 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
                if (v257 != 2) {
                  v260 |= *((unsigned __int8 *)v12 + 2);
                }
                int v258 = v260 << 8;
              }
LABEL_480:
              unsigned int v261 = v258 << v17;
              if ((v60 & 0x80000000) == 0)
              {
LABEL_481:
                uint64_t v59 = 0;
                *(void *)(a1 + 16) = v12;
                *(_DWORD *)(a1 + 24) = v261;
                *(unsigned char *)(a1 + 28) = v17;
                return v59;
              }
              *(void *)(a1 + 16) = v12;
              *(_DWORD *)(a1 + 24) = v261;
              *(unsigned char *)(a1 + 28) = v17;
              if (*(_DWORD *)(a1 + 8) >= (int)v12 - *(_DWORD *)a1)
              {
                uint64_t v59 = PullVUIParamSet((uint64_t *)a1, (unsigned int *)a2 + 92);
                BOOL v12 = *(unsigned int **)(a1 + 16);
                unsigned int v60 = *(_DWORD *)(a1 + 24);
                LOBYTE(v17) = *(unsigned char *)(a1 + 28);
                goto LABEL_484;
              }
LABEL_487:
              uint64_t v59 = 4294954582;
              FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              return v59;
            }
            int v258 = v17 | v257;
            if (!v258) {
              goto LABEL_480;
            }
LABEL_476:
            uint64_t v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            unsigned int v60 = 0;
            goto LABEL_484;
          }
        }
      }
    }
    goto LABEL_486;
  }
  return v59;
}

uint64_t FigH264Bridge_GetSPS_VUI_NCLC(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  uint64_t v17 = 0;
  int v18 = 0;
  uint64_t v19 = 0;
  CFDataRef theData = 0;
  uint64_t v10 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v10) {
    return v10;
  }
  CFDataRef v11 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v11);
  }
  int v16 = BytePtr;
  LODWORD(v17) = Length;
  int v18 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v19) = 0;
      __memcpy_chk();
      unsigned int v12 = v19;
    }
    else
    {
      unsigned int v12 = 0;
    }
  }
  else
  {
    unsigned int v12 = *(_DWORD *)BytePtr;
  }
  LODWORD(v19) = bswap32(v12);
  BYTE4(v19) = 0;
  uint64_t v13 = PullParamSetSPS((uint64_t)&v16, (char *)v20);
  if (v11) {
    CFRelease(v11);
  }
  if (!v13)
  {
    uint64_t v13 = 4294954584;
    if (HIDWORD(v21))
    {
      if (DWORD1(v24))
      {
        uint64_t v13 = 0;
        *a3 = DWORD2(v24);
        *a4 = HIDWORD(v24);
        *a5 = v25;
      }
    }
  }
  return v13;
}

uint64_t FigH264Bridge_GetSPS_VUI_AspectRatio(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int Length = a2;
  BytePtr = a1;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  uint64_t v17 = 0;
  int v18 = 0;
  uint64_t v19 = 0;
  CFDataRef theData = 0;
  uint64_t v8 = RemoveEmulation3Byte(a1, a2, &theData);
  if (v8) {
    return v8;
  }
  CFDataRef v9 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unsigned int Length = CFDataGetLength(v9);
  }
  int v16 = BytePtr;
  LODWORD(v17) = Length;
  int v18 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v19) = 0;
      __memcpy_chk();
      unsigned int v10 = v19;
    }
    else
    {
      unsigned int v10 = 0;
    }
  }
  else
  {
    unsigned int v10 = *(_DWORD *)BytePtr;
  }
  LODWORD(v19) = bswap32(v10);
  BYTE4(v19) = 0;
  uint64_t v11 = PullParamSetSPS((uint64_t)&v16, (char *)v20);
  if (v9) {
    CFRelease(v9);
  }
  if (!v11)
  {
    uint64_t v11 = 4294954584;
    if (HIDWORD(v21))
    {
      if (v22)
      {
        if (DWORD1(v22) == 255)
        {
          *a3 = DWORD2(v22);
          int v12 = HIDWORD(v22);
        }
        else
        {
          if ((DWORD1(v22) - 1) > 0xF) {
            return 0;
          }
          uint64_t v13 = (unsigned __int8 *)&kH264SampleAspectRatioIndicators + 2 * DWORD1(v22);
          *a3 = *v13;
          int v12 = v13[1];
        }
        uint64_t v11 = 0;
        *a4 = v12;
      }
    }
  }
  return v11;
}

uint64_t FigCFCreateExtendedDictionary(const __CFAllocator *a1, CFDictionaryRef theDict, const void *a3, const void *a4, uint64_t a5, CFDictionaryRef *a6)
{
  if (a6 && (a4 ? (BOOL v11 = a3 == 0) : (BOOL v11 = 1), !v11 || a5 <= 0))
  {
    *a6 = 0;
    if (theDict) {
      CFIndex Count = CFDictionaryGetCount(theDict);
    }
    else {
      CFIndex Count = 0;
    }
    int v15 = 0;
    CFIndex v16 = Count + a5;
    if ((unint64_t)(Count + a5) >> 61)
    {
      uint64_t v17 = 0;
    }
    else
    {
      uint64_t v17 = 0;
      if (8 * v16)
      {
        int v15 = (const void **)malloc_type_malloc(8 * v16, 0x89DA2F20uLL);
        if (v15)
        {
          uint64_t v17 = (const void **)malloc_type_malloc(8 * v16, 0xC56C2843uLL);
          if (v17)
          {
            if (theDict) {
              CFDictionaryGetKeysAndValues(theDict, v15, v17);
            }
            memcpy(&v15[Count], a3, 8 * a5);
            memcpy(&v17[Count], a4, 8 * a5);
            *a6 = CFDictionaryCreate(a1, v15, v17, Count + a5, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          }
        }
        else
        {
          uint64_t v17 = 0;
        }
      }
    }
    free(v15);
    free(v17);
    if (*a6) {
      return 0;
    }
    uint64_t v12 = 4294954305;
  }
  else
  {
    uint64_t v12 = 4294954306;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigVideoFormatDescriptionRegisterOnce()
{
  int v1 = 0;
  int v5 = figVideoFormatDescriptionFinalize;
  uint64_t v4 = figVideoFormatDescriptionCopyDebugDesc;
  uint64_t v2 = 12;
  uint64_t v3 = figVideoFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x76696465u, (long long *)&v1);
}

uint64_t FigSignalErrorAt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7)
{
  return a1;
}

uint64_t FigFileWrapDarwinFileDesc(int a1, void *a2)
{
  uint64_t v4 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  if (v4)
  {
    _DWORD *v4 = a1;
    *a2 = v4;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAtomicBitAnd32Orig(unsigned int a1, atomic_uint *a2)
{
  return atomic_fetch_and_explicit(a2, a1, memory_order_relaxed);
}

uint64_t FigCFCreateCombinedDictionary(const __CFAllocator *a1, CFDictionaryRef *a2, uint64_t a3, CFDictionaryRef *a4)
{
  if (!a4 || (v5 = a3, (uint64_t v6 = a2) == 0) && a3 > 0)
  {
    uint64_t v8 = 4294954306;
    goto LABEL_5;
  }
  *a4 = 0;
  if (a3 < 1) {
    goto LABEL_21;
  }
  unint64_t v10 = 0;
  BOOL v11 = a2;
  uint64_t v12 = a3;
  do
  {
    CFDictionaryRef v13 = *v11++;
    v10 += CFDictionaryGetCount(v13);
    --v12;
  }
  while (v12);
  size_t v14 = 8 * v10;
  if (v10 >> 61 || v14 == 0)
  {
LABEL_21:
    CFIndex v16 = 0;
  }
  else
  {
    CFIndex v16 = (const void **)malloc_type_malloc(8 * v10, 0xD9AED4ADuLL);
    if (v16)
    {
      uint64_t v17 = (const void **)malloc_type_malloc(v14, 0x8667CBBCuLL);
      if (v17)
      {
        if (v5 < 1)
        {
          CFIndex v18 = 0;
        }
        else
        {
          CFIndex v18 = 0;
          do
          {
            CFIndex Count = CFDictionaryGetCount(*v6);
            CFDictionaryRef v20 = *v6++;
            CFDictionaryGetKeysAndValues(v20, &v16[v18], &v17[v18]);
            v18 += Count;
            --v5;
          }
          while (v5);
        }
        *a4 = CFDictionaryCreate(a1, v16, v17, v18, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      goto LABEL_25;
    }
  }
  uint64_t v17 = 0;
LABEL_25:
  free(v16);
  free(v17);
  if (*a4) {
    return 0;
  }
  uint64_t v8 = 4294954305;
LABEL_5:

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigScheduledIOCreateForReadingByteStream(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a2);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFDataRef v9 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(v8 + 48);
  if (!v9) {
    return 4294954514;
  }
  uint64_t v10 = v9(CMBaseObject, @"FBS_ScheduledIO", a1, a3);
  if (v10 == -12784)
  {
    uint64_t v10 = FigScheduledIOFRSCreateForByteStream(a1, a2, &cf);
    if (v10)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *a3 = cf;
    }
  }
  return v10;
}

uint64_t FigScheduledIOGetClassID()
{
  return sFigScheduledIOClassID;
}

uint64_t RegisterFigScheduledIOBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigScheduledIOClassDesc, ClassID, 1, &sFigScheduledIOClassID);
}

uint64_t bufQDataBecameReady(uint64_t a1, uint64_t a2)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 16));
  CFSetRef v3 = *(const __CFSet **)(a2 + 160);
  if (v3) {
    CFSetApplyFunction(v3, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a2);
  }
  uint64_t v4 = *(pthread_mutex_t **)(a2 + 16);

  return FigReentrantMutexUnlock(v4);
}

uint64_t PeekBits(uint64_t a1, unsigned int a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v3 = *(void *)(a1 + 24);
  if (v4 >= v3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = *(_DWORD *)(a1 + 36) & 7 | (8
  }
                                     * (v3
                                      - (*(void *)(a1 + 40)
                                       + v4)
                                      + ((unint64_t)*(unsigned int *)(a1 + 36) >> 3)));
  if (v5 < a2) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t result = GetBits(a1, a2);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v6;
  return result;
}

uint64_t GetBits(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 36);
  unsigned int v4 = a2 - v3;
  if (a2 <= v3)
  {
    int v6 = 0;
    unsigned int v4 = 0;
  }
  else
  {
    if (v3) {
      unsigned int v5 = 0xFFFFFFFF >> -(char)v3;
    }
    else {
      unsigned int v5 = 0;
    }
    int v6 = *(_DWORD *)(a1 + 32) & v5;
    *(void *)(a1 + 16) += 4;
    CopyNextWord(a1);
    unsigned int v3 = *(_DWORD *)(a1 + 36);
    a2 = v4;
  }
  unsigned int v7 = v3 - a2;
  if (v3 < a2)
  {
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else
  {
    if (v7 == 32)
    {
      unsigned int v8 = 0;
    }
    else
    {
      unsigned int v9 = -1 << -(char)a2;
      if (!a2) {
        unsigned int v9 = 0;
      }
      unsigned int v10 = v9 >> -(char)v3;
      if (v3) {
        unsigned int v11 = v10;
      }
      else {
        unsigned int v11 = 0;
      }
      unsigned int v8 = (*(_DWORD *)(a1 + 32) & v11) >> v7;
    }
    int v12 = v6 << v4;
    if (v4 == 32) {
      int v12 = 0;
    }
    uint64_t result = v8 | v12;
    *(_DWORD *)(a1 + 36) = v7;
  }
  return result;
}

uint64_t FigHALAudioBrokeredPluginCreateDeviceBroker(const void *a1, void *a2)
{
  brokeredPlugin_CreateDeviceBroker(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a2)
  {
    CFTypeRef v5 = *(CFTypeRef *)(DerivedStorage + 24);
    if (v5) {
      CFTypeRef v5 = CFRetain(v5);
    }
    *a2 = v5;
  }
  return 0;
}

uint64_t brokeredPlugin_CreateDeviceBroker(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v7 = 0;
  CFAllocatorRef v3 = CFGetAllocator(a1);
  ClassID = (void *)FigHALAudioDeviceBrokerGetClassID();
  uint64_t v5 = CMDerivedObjectCreate((uint64_t)v3, (uint64_t)&kFigHALAudioBasicBrokerVTable, ClassID, &v7);
  if (!v5)
  {
    *(void *)CMBaseObjectGetDerivedStorage(v7) = a1;
    *(void *)(DerivedStorage + 24) = v7;
  }
  return v5;
}

uint64_t FigHALAudioCreateBrokeredPluginObject(const __CFAllocator *a1, const void *a2, uint64_t *a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  return brokeredPlugin_CreateBrokeredPluginObjectInternal(a1, a2, a3, a4, a5, 0, a6);
}

uint64_t brokeredPlugin_CreateBrokeredPluginObjectInternal(const __CFAllocator *a1, const void *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, CFTypeRef *a7)
{
  CFTypeRef cf = 0;
  ClassID = (void *)FigHALAudioPluginGetClassID();
  uint64_t v15 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigHALAudioBrokeredPluginVTable, ClassID, &cf);
  if (v15) {
    goto LABEL_10;
  }
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
  DerivedStorage[1] = a3;
  DerivedStorage[2] = CFRetain(a2);
  DerivedStorage[6] = a5;
  DerivedStorage[7] = a6;
  DerivedStorage[5] = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  dispatch_queue_t v17 = dispatch_queue_create("FigHALBrokeredPluginDeviceManagementQueue", 0);
  DerivedStorage[4] = v17;
  DerivedStorage[8] = a4;
  if (DerivedStorage[5]) {
    BOOL v18 = v17 == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18)
  {
    uint64_t v15 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_10:
    uint64_t v19 = v15;
    goto LABEL_11;
  }
  uint64_t v19 = FigHALAudioObjectMapperAddPluginObjectMapping(a3, (uint64_t)cf);
  if (!v19)
  {
    *a7 = cf;
    return v19;
  }
LABEL_11:
  if (cf) {
    CFRelease(cf);
  }
  return v19;
}

void *basicBroker_Finalize(uint64_t a1)
{
  uint64_t result = (void *)CMBaseObjectGetDerivedStorage(a1);
  *uint64_t result = 0;
  return result;
}

CFStringRef basicBroker_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"FigHALAudioDeviceBroker-BasicBroker pluginObject %@", *DerivedStorage);
}

uint64_t basicBroker_CreateDevice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t DerivedStorage = (uint64_t (***)(void, uint64_t, uint64_t, uint64_t))CMBaseObjectGetDerivedStorage(v8);
  uint64_t v14 = 0;
  uint64_t v10 = ((uint64_t (*)(void, uint64_t (**)(void, uint64_t, uint64_t, uint64_t), void, uint64_t, uint64_t, uint64_t, uint64_t *))DerivedStorage[6])(*MEMORY[0x1E4F1CF80], DerivedStorage[1], *DerivedStorage, a3, a4, a5, &v14);
  if (!v10)
  {
    unsigned int v11 = DerivedStorage[4];
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    int v13[2] = __brokeredPlugin_CreateDeviceForEndpointStream_block_invoke;
    v13[3] = &__block_descriptor_tmp;
    v13[4] = DerivedStorage;
    v13[5] = v14;
    v13[6] = v8;
    dispatch_sync(v11, v13);
    FigHALAudioPropertySendChanges(*DerivedStorage, 1, 2, (uint64_t)"#vedbolg");
  }
  return v10;
}

void brokeredPlugin_DeviceUnpluggedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  uint64_t v7 = *(NSObject **)(DerivedStorage + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __brokeredPlugin_DeviceUnpluggedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_2;
  block[4] = a2;
  void block[5] = a4;
  block[6] = DerivedStorage;
  dispatch_sync(v7, block);
  FigHALAudioPropertySendChanges(*(uint64_t (***)(void, uint64_t, uint64_t, uint64_t))DerivedStorage, 1, 2, (uint64_t)"#vedbolg");
}

void brokeredPlugin_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = (const void *)DerivedStorage[2];
  if (v2)
  {
    CFRelease(v2);
    DerivedStorage[2] = 0;
  }
  CFAllocatorRef v3 = (const void *)DerivedStorage[5];
  if (v3)
  {
    CFRelease(v3);
    DerivedStorage[5] = 0;
  }
  unsigned int v4 = DerivedStorage[4];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[4] = 0;
  }
  uint64_t v5 = (const void *)DerivedStorage[9];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[9] = 0;
  }
}

CFStringRef brokeredPlugin_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  uint64_t v2 = *(NSObject **)(DerivedStorage + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __brokeredPlugin_CopyDebugDescription_block_invoke;
  block[3] = &unk_1E5675FC8;
  block[4] = &v6;
  void block[5] = DerivedStorage;
  dispatch_sync(v2, block);
  CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"FigHALBrokeredPlugin: brokerType: %@ %ld devices", *(void *)(DerivedStorage + 16), v7[3]);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t brokeredPlugin_GetObjectID()
{
  return 1;
}

uint64_t brokeredPlugin_HasProperty(uint64_t a1, int *a2)
{
  int v2 = *a2;
  uint64_t result = 1;
  if (*a2 <= 1819107690)
  {
    BOOL v4 = v2 == 1668047219;
    int v5 = 1684370979;
  }
  else
  {
    BOOL v4 = v2 == 1819107691 || v2 == 1870098020;
    int v5 = 1969841252;
  }
  if (!v4 && v2 != v5) {
    return 0;
  }
  return result;
}

uint64_t brokeredPlugin_IsPropertySettable()
{
  return 0;
}

uint64_t brokeredPlugin_GetPropertyDataSize(uint64_t a1, int *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  int v4 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v4 == 1668047219) {
      return 4;
    }
    if (v4 != 1684370979) {
      return 0;
    }
LABEL_9:
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000;
    uint64_t v12 = 0;
    uint64_t v6 = *(NSObject **)(DerivedStorage + 32);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    v8[2] = __brokeredPlugin_GetPropertyDataSize_block_invoke;
    v8[3] = &unk_1E5675FF0;
    v8[4] = &v9;
    v8[5] = DerivedStorage;
    dispatch_sync(v6, v8);
    uint64_t v5 = (4 * *((_DWORD *)v10 + 6));
    _Block_object_dispose(&v9, 8);
    return v5;
  }
  switch(v4)
  {
    case 1819107691:
      return 8;
    case 1870098020:
      goto LABEL_9;
    case 1969841252:
      return 4;
    default:
      return 0;
  }
}

uint64_t brokeredPlugin_GetPropertyData(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v14 = 0;
  int v15 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v15 != 1668047219)
    {
      if (v15 != 1684370979) {
        return v14;
      }
LABEL_11:
      uint64_t v22 = 0;
      long long v23 = &v22;
      uint64_t v24 = 0x2000000000;
      uint64_t v25 = 0;
      dispatch_queue_t v17 = *(NSObject **)(DerivedStorage + 32);
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 0x40000000;
      v20[2] = __brokeredPlugin_GetPropertyData_block_invoke;
      v20[3] = &unk_1E5676018;
      unsigned int v21 = a5;
      v20[4] = &v22;
      v20[5] = DerivedStorage;
      v20[6] = a7;
      dispatch_sync(v17, v20);
      *a6 = 4 * *((_DWORD *)v23 + 6);
      _Block_object_dispose(&v22, 8);
      return 0;
    }
    *a6 = 4;
    if (a5 >= 4)
    {
      uint64_t v14 = 0;
      *a7 = 1634757735;
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1819107691)
  {
    *a6 = 8;
    if (a5 >= 8)
    {
      uint64_t v14 = 0;
      *(void *)a7 = @"Apple Inc.";
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1870098020) {
    goto LABEL_11;
  }
  if (v15 != 1969841252) {
    return v14;
  }
  if (a5 > 3 && a3 == 8 && a4)
  {
    CFIndex v16 = *(NSObject **)(DerivedStorage + 32);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __brokeredPlugin_GetPropertyData_block_invoke_2;
    block[3] = &__block_descriptor_tmp_14;
    block[4] = DerivedStorage;
    void block[5] = a4;
    void block[6] = a7;
    dispatch_sync(v16, block);
    uint64_t v14 = 0;
    *a6 = 4;
    return v14;
  }

  return FigSignalErrorAt(561211770, 0, 0, 0, 0, 0, 0);
}

uint64_t brokeredPlugin_SetPropertyData()
{
  return 2003332927;
}

uint64_t brokeredPlugin_Initialize(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  *uint64_t DerivedStorage = a2;
  uint64_t v5 = (void (*)(void, void, uint64_t, CFTypeRef *))DerivedStorage[7];
  if (v5)
  {
    uint64_t v6 = DerivedStorage;
    CFTypeRef v13 = 0;
    v5(*MEMORY[0x1E4F1CF80], DerivedStorage[1], a2, &v13);
    if (v13)
    {
      uint64_t v7 = v6[4];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __brokeredPlugin_Initialize_block_invoke;
      block[3] = &__block_descriptor_tmp_15;
      block[4] = v6;
      void block[5] = v13;
      dispatch_sync(v7, block);
      CFRelease(v13);
    }
  }
  uint64_t result = brokeredPlugin_CreateDeviceBroker(a1);
  if (!result)
  {
    uint64_t v9 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    uint64_t v10 = *(uint64_t (**)(CFAllocatorRef, uint64_t))(v9 + 64);
    if (!v10) {
      return FigHALAudioDeviceBrokerRegister(*(const void **)(v9 + 16), *(const void **)(v9 + 24));
    }
    CFAllocatorRef v11 = CFGetAllocator(a1);
    uint64_t result = v10(v11, v9 + 72);
    if (!result) {
      return FigHALAudioDeviceBrokerRegister(*(const void **)(v9 + 16), *(const void **)(v9 + 24));
    }
  }
  return result;
}

void FigKTraceInit()
{
  if (initializeOnceToken != -1) {
    dispatch_once_f(&initializeOnceToken, 0, (dispatch_function_t)fig_ktrace_initialize);
  }
}

uint64_t fig_ktrace_initialize()
{
  gGMFigKTraceEnabled = FigGetCFPreferenceNumberWithDefault(@"gm_ktrace", @"com.apple.coremedia", 1);
  uint64_t result = FigGetCFPreferenceNumberWithDefault(@"gm_signpost", @"com.apple.coremedia", 0);
  gFigUseSignposts = result;
  return result;
}

const char *fig_gm_ktrace_wrapper(uint64_t a1, int a2, const char *a3, const char *a4, const char *a5, const char *a6, uint64_t a7, uint64_t a8, const char *a9)
{
  if (a3 != 3)
  {
    uint64_t result = fig_trace_point_arg_to_ktrace_arg(a3, &a9);
    if (a4 != 3)
    {
      uint64_t result = fig_trace_point_arg_to_ktrace_arg(a4, &a9);
      if (a5 != 3)
      {
        uint64_t result = fig_trace_point_arg_to_ktrace_arg(a5, &a9);
        if (a6 != 3) {
          uint64_t result = fig_trace_point_arg_to_ktrace_arg(a6, &a9);
        }
      }
    }
  }
  if (a2 == 2)
  {
    if (gGMFigKTraceEnabled == 1) {
      return (const char *)kdebug_trace();
    }
  }
  else
  {
    if (a2 == 1)
    {
      if (gGMFigKTraceEnabled != 1) {
        return result;
      }
      return (const char *)kdebug_trace();
    }
    if (!a2 && gGMFigKTraceEnabled == 1) {
      return (const char *)kdebug_trace();
    }
  }
  return result;
}

const char *fig_trace_point_arg_to_ktrace_arg(const char *result, const char **a2)
{
  if (result == 2)
  {
    strncpy(__dst, *a2, 8uLL);
    return *(const char **)__dst;
  }
  else if (result <= 1)
  {
    return *a2;
  }
  return result;
}

uint64_t FigEndpointManagerRemoteCreateWithType(const void *a1, CFTypeRef *a2)
{
  uint64_t v18 = 0;
  CFTypeRef cf = 0;
  uint64_t v2 = 4294950586;
  uint64_t v17 = 0;
  if (a1 && a2)
  {
    if (remoteXPCFigEndpointManager_initializeLogging_initLoggingOnce != -1) {
      dispatch_once(&remoteXPCFigEndpointManager_initializeLogging_initLoggingOnce, &__block_literal_global_15);
    }
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    ClassID = (void *)FigEndpointManagerGetClassID();
    uint64_t v7 = CMDerivedObjectCreate((uint64_t)v5, (uint64_t)&kFigEndpointManagerRemoteXPC_EndpointVTable, ClassID, &cf);
    if (!v7)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      dispatch_queue_t v9 = dispatch_queue_create("com.apple.coremedia.remoteendpointmgr.state", 0);
      DerivedStorage[2] = v9;
      if (v9
        && (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
            (DerivedStorage[3] = Mutable) != 0)
        && (dispatch_queue_t v11 = dispatch_queue_create("com.apple.coremedia.remoteendpointmgr.notification", 0),
            (DerivedStorage[8] = v11) != 0))
      {
        uint64_t v7 = FigEndpointRPCCacheCreate(DerivedStorage + 4, 1);
        if (!v7)
        {
          uint64_t v7 = remoteXPCEndpointManager_ResetCachedAvailableEndpoints((uint64_t)DerivedStorage);
          if (!v7)
          {
            uint64_t v12 = *MEMORY[0x1E4F1CFC8];
            CFTypeRef v13 = DerivedStorage[2];
            uint64_t block = MEMORY[0x1E4F143A8];
            uint64_t v21 = 0x40000000;
            uint64_t v22 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
            long long v23 = &__block_descriptor_tmp_22;
            uint64_t v24 = v12;
            uint64_t v25 = DerivedStorage;
            long long v26 = @"EndpointPresent";
            dispatch_sync(v13, &block);
            DerivedStorage[5] = 0;
            *uint64_t DerivedStorage = CFRetain(a1);
            int IsAppleTV = CelestialIsAppleTV();
            if (!FigEndpointManagerGetSupportedFeatures(a1, IsAppleTV, &v18)) {
              remoteXPCEndpointManager_SetCachedPropertyInt64((uint64_t)DerivedStorage, @"SupportedFeatures", v18);
            }
            if (!FigEndpointManagerGetSupportedDiscoveryFeatures(a1, &v17)) {
              remoteXPCEndpointManager_SetCachedPropertyInt64((uint64_t)DerivedStorage, @"SupportedDiscoveryFeatures", v17);
            }
            int v15 = DerivedStorage[2];
            uint64_t block = MEMORY[0x1E4F143A8];
            uint64_t v21 = 0x40000000;
            uint64_t v22 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
            long long v23 = &__block_descriptor_tmp_22;
            uint64_t v24 = v12;
            uint64_t v25 = DerivedStorage;
            long long v26 = @"EndpointPresent";
            dispatch_sync(v15, &block);
            uint64_t v2 = 0;
            *a2 = cf;
            return v2;
          }
        }
      }
      else
      {
        uint64_t v7 = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
      }
    }
    uint64_t v2 = v7;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

uint64_t remoteXPCEndpointManager_ResetCachedAvailableEndpoints(uint64_t a1)
{
  CFArrayRef v2 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  if (v2)
  {
    CFArrayRef v3 = v2;
    int v4 = *(NSObject **)(a1 + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
    block[3] = &__block_descriptor_tmp_22;
    block[4] = v3;
    void block[5] = a1;
    void block[6] = @"AvailableEndpoints";
    dispatch_sync(v4, block);
    CFRelease(v3);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  }
}

void remoteXPCEndpointManager_SetCachedPropertyInt64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFNumberRef SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3);
  uint64_t v6 = *(NSObject **)(a1 + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
  block[3] = &__block_descriptor_tmp_22;
  block[4] = SInt64;
  void block[5] = a1;
  void block[6] = a2;
  dispatch_sync(v6, block);
  if (SInt64) {
    CFRelease(SInt64);
  }
}

uint64_t FigEndpointManagerRemoteCopyAirPlayManager(CFTypeRef *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopyAirPlayManager_sCreateOnce != -1) {
      dispatch_once(&FigEndpointManagerRemoteCopyAirPlayManager_sCreateOnce, &__block_literal_global);
    }
    uint64_t v2 = FigEndpointManagerRemoteCopyAirPlayManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopyAirPlayManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopyAirPlayManager_sAirPlayManager);
      return v2;
    }
  }
  else
  {
    uint64_t v2 = FigSignalErrorAt(4294950586, 0, 0, 0, 0, 0, 0);
    if (!v2) {
      return v2;
    }
  }
  v10[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  int v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v7 = v5;
  }
  else {
    unsigned int v7 = v5 & 0xFFFFFFFE;
  }
  if (v7)
  {
    v10[1] = 136315394;
    dispatch_queue_t v11 = "FigEndpointManagerRemoteCopyAirPlayManager";
    __int16 v12 = 1024;
    int v13 = v2;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    uint64_t v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

void __FigEndpointManagerRemoteCopyAirPlayManager_block_invoke()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  FigEndpointManagerRemoteCopyAirPlayManager_sCreationResult = FigEndpointManagerRemoteCreateWithType(@"AirPlay", (CFTypeRef *)&FigEndpointManagerRemoteCopyAirPlayManager_sAirPlayManager);
  v6[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v6, &type);
  int v1 = v6[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    v6[1] = 136315394;
    unsigned int v7 = "FigEndpointManagerRemoteCopyAirPlayManager_block_invoke";
    __int16 v8 = 1024;
    int v9 = FigEndpointManagerRemoteCopyAirPlayManager_sCreationResult;
    int v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v6[0];
  }
  else
  {
    int v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v10, v1, 0, v2);
}

uint64_t FigEndpointManagerRemoteCopyCarPlayManager(CFTypeRef *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopyCarPlayManager_sCreateOnce != -1) {
      dispatch_once(&FigEndpointManagerRemoteCopyCarPlayManager_sCreateOnce, &__block_literal_global_6);
    }
    uint64_t v2 = FigEndpointManagerRemoteCopyCarPlayManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopyCarPlayManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopyCarPlayManager_sCarPlayManager);
      return v2;
    }
  }
  else
  {
    uint64_t v2 = 4294950586;
  }
  v10[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  int v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v7 = v5;
  }
  else {
    unsigned int v7 = v5 & 0xFFFFFFFE;
  }
  if (v7)
  {
    v10[1] = 136315394;
    uint64_t v11 = "FigEndpointManagerRemoteCopyCarPlayManager";
    __int16 v12 = 1024;
    int v13 = v2;
    __int16 v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    __int16 v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

void __FigEndpointManagerRemoteCopyCarPlayManager_block_invoke()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  FigEndpointManagerRemoteCopyCarPlayManager_sCreationResult = FigEndpointManagerRemoteCreateWithType(@"CarPlay", (CFTypeRef *)&FigEndpointManagerRemoteCopyCarPlayManager_sCarPlayManager);
  v6[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v6, &type);
  int v1 = v6[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    v6[1] = 136315394;
    unsigned int v7 = "FigEndpointManagerRemoteCopyCarPlayManager_block_invoke";
    __int16 v8 = 1024;
    int v9 = FigEndpointManagerRemoteCopyCarPlayManager_sCreationResult;
    int v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v6[0];
  }
  else
  {
    int v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v10, v1, 0, v2);
}

uint64_t FigEndpointManagerRemoteCopyNeroManager(CFTypeRef *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopyNeroManager_sCreateOnce != -1) {
      dispatch_once(&FigEndpointManagerRemoteCopyNeroManager_sCreateOnce, &__block_literal_global_9);
    }
    uint64_t v2 = FigEndpointManagerRemoteCopyNeroManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopyNeroManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopyNeroManager_sNeroManager);
      return v2;
    }
  }
  else
  {
    uint64_t v2 = 4294950586;
  }
  v10[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  int v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v7 = v5;
  }
  else {
    unsigned int v7 = v5 & 0xFFFFFFFE;
  }
  if (v7)
  {
    v10[1] = 136315394;
    uint64_t v11 = "FigEndpointManagerRemoteCopyNeroManager";
    __int16 v12 = 1024;
    int v13 = v2;
    __int16 v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    __int16 v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

void *__FigEndpointManagerRemoteCopyNeroManager_block_invoke()
{
  v13[16] = *MEMORY[0x1E4F143B8];
  FigEndpointManagerRemoteCopyNeroManager_sCreationResult = FigEndpointManagerRemoteCreateWithType(@"Nero/Stevenote", (CFTypeRef *)&FigEndpointManagerRemoteCopyNeroManager_sNeroManager);
  v9[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v9, &type);
  int v1 = v9[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    v9[1] = 136315394;
    char v10 = "FigEndpointManagerRemoteCopyNeroManager_block_invoke";
    __int16 v11 = 1024;
    int v12 = FigEndpointManagerRemoteCopyNeroManager_sCreationResult;
    int v4 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v9[0];
  }
  else
  {
    int v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != v13, v1, 0, v2);
  uint64_t v5 = FigEndpointManagerRemoteCopyNeroManager_sNeroManager;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpointManagerRemoteCopyNeroManager_sNeroManager);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  int v13[2] = __remoteXPCEndpointManager_startListeningForValeriaConnections_block_invoke;
  v13[3] = &__block_descriptor_tmp_26;
  v13[4] = v5;
  uint64_t result = NeroValeriaListenerCreate((uint64_t)v13);
  *(void *)(DerivedStorage + 8) = result;
  return result;
}

uint64_t FigEndpointManagerRemoteCopySidePlayManager(CFTypeRef *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopySidePlayManager_sCreateOnce != -1) {
      dispatch_once(&FigEndpointManagerRemoteCopySidePlayManager_sCreateOnce, &__block_literal_global_12);
    }
    uint64_t v2 = FigEndpointManagerRemoteCopySidePlayManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopySidePlayManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopySidePlayManager_sSidePlayManager);
      return v2;
    }
  }
  else
  {
    uint64_t v2 = 4294950586;
  }
  v10[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  int v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v7 = v5;
  }
  else {
    unsigned int v7 = v5 & 0xFFFFFFFE;
  }
  if (v7)
  {
    v10[1] = 136315394;
    __int16 v11 = "FigEndpointManagerRemoteCopySidePlayManager";
    __int16 v12 = 1024;
    int v13 = v2;
    __int16 v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    __int16 v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

void __FigEndpointManagerRemoteCopySidePlayManager_block_invoke()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  FigEndpointManagerRemoteCopySidePlayManager_sCreationResult = FigEndpointManagerRemoteCreateWithType(@"SidePlay", (CFTypeRef *)&FigEndpointManagerRemoteCopySidePlayManager_sSidePlayManager);
  v6[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v6, &type);
  int v1 = v6[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v3 = v1;
  }
  else {
    unsigned int v3 = v1 & 0xFFFFFFFE;
  }
  if (v3)
  {
    v6[1] = 136315394;
    unsigned int v7 = "FigEndpointManagerRemoteCopySidePlayManager_block_invoke";
    __int16 v8 = 1024;
    int v9 = FigEndpointManagerRemoteCopySidePlayManager_sCreationResult;
    int v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v6[0];
  }
  else
  {
    int v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v10, v1, 0, v2);
}

void FigEndpointManagerRemoteXPC_Finalize(uint64_t a1)
{
  v22[16] = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  int v20 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v20, &type);
  int v4 = v20;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    LODWORD(v21[0]) = 136315138;
    *(uint64_t *)((char *)v21 + 4) = (uint64_t)"FigEndpointManagerRemoteXPC_Finalize";
    unsigned int v7 = (uint64_t *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v20;
  }
  else
  {
    unsigned int v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != v22, v4, 0, v5);
  uint64_t v8 = CMBaseObjectGetDerivedStorage(a1);
  v22[0] = 0;
  v21[0] = 0;
  int v9 = *(const void **)(v8 + 40);
  if (!v9 || (uint64_t v10 = v8, remoteXPCEndpointManager_getSharedXPCClient(v21)))
  {
    int v13 = 0;
  }
  else
  {
    FigEndpointRPCCacheRemoveAllEndpoints(*(void *)(v10 + 32));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v10 + 24));
    uint64_t v11 = v21[0];
    FigXPCRemoteClientDisassociateObject(v21[0], v9);
    int v12 = FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v9, v22);
    int v13 = (void *)v22[0];
    if (!v12)
    {
      FigXPCRemoteClientSendSyncMessage(v11, v22[0]);
      int v13 = (void *)v22[0];
    }
  }
  FigXPCRelease(v13);
  NeroValeriaListenerDestroy(*(CFTypeRef **)(DerivedStorage + 8));
  FigEndpointRPCCacheDispose(*(void **)(DerivedStorage + 32));
  char v14 = *(const void **)(DerivedStorage + 24);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(DerivedStorage + 24) = 0;
  }
  uint64_t v15 = *(const void **)(DerivedStorage + 48);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(DerivedStorage + 48) = 0;
  }
  CFIndex v16 = *(const void **)(DerivedStorage + 56);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(DerivedStorage + 56) = 0;
  }
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v17 = *(NSObject **)(DerivedStorage + 16);
  if (v17)
  {
    dispatch_release(v17);
    *(void *)(DerivedStorage + 16) = 0;
  }
  uint64_t v18 = *(NSObject **)(DerivedStorage + 64);
  if (v18)
  {
    dispatch_release(v18);
    *(void *)(DerivedStorage + 64) = 0;
  }
}

uint64_t FigEndpointManagerRemoteXPC_CopyProperty(uint64_t a1, __CFString *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(@"Name", a2))
  {
    uint64_t v8 = 0;
    CFTypeRef cf = CFRetain(*(CFTypeRef *)DerivedStorage);
    goto LABEL_23;
  }
  uint64_t v45 = 0;
  int v46 = &v45;
  uint64_t v47 = 0x2000000000;
  uint64_t v48 = 0;
  int v9 = *(NSObject **)(DerivedStorage + 16);
  uint64_t block = MEMORY[0x1E4F143A8];
  uint64_t v29 = 0x40000000;
  long long v30 = __remoteXPCEndpointManager_CopyCachedProperty_block_invoke;
  int v31 = &unk_1E5676150;
  int v32 = &v45;
  int v33 = (uint64_t *)DerivedStorage;
  int v34 = a2;
  dispatch_sync(v9, &block);
  uint64_t v10 = (const void *)v46[3];
  _Block_object_dispose(&v45, 8);
  CFTypeRef cf = v10;
  if (v10) {
    goto LABEL_4;
  }
  uint64_t v11 = remoteXPCEndpointManager_ensureConnected(a1, &v25, &v27);
  if (v11) {
    goto LABEL_29;
  }
  if (!CFEqual(@"AvailableEndpoints", a2))
  {
    uint64_t v11 = FigXPCSendStdCopyPropertyMessage(v25, v27, a2, &cf);
    if (!v11)
    {
      if (CFEqual(@"EndpointPresent", a2))
      {
        uint64_t v19 = *(NSObject **)(DerivedStorage + 16);
        uint64_t block = MEMORY[0x1E4F143A8];
        uint64_t v29 = 0x40000000;
        long long v30 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
        int v31 = &__block_descriptor_tmp_22;
        int v32 = (uint64_t *)cf;
        int v33 = (uint64_t *)DerivedStorage;
        int v34 = a2;
        dispatch_sync(v19, &block);
      }
LABEL_4:
      uint64_t v8 = 0;
      goto LABEL_23;
    }
    goto LABEL_29;
  }
  uint64_t v11 = FigEndpointXPCRemotePing();
  if (v11)
  {
LABEL_29:
    uint64_t v8 = v11;
    goto LABEL_23;
  }
  uint64_t v45 = 0;
  int v46 = &v45;
  uint64_t v47 = 0x2000000000;
  LODWORD(v48) = 0;
  xpc_object_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v41 = 0;
  xpc_object_t xdict = 0;
  uint64_t v38 = 0;
  int v39 = &v38;
  uint64_t v40 = 0x2000000000;
  uint64_t v37 = 0;
  int v12 = remoteXPCEndpointManager_ensureConnected(a1, &v37, &v44);
  *((_DWORD *)v46 + 6) = v12;
  if (v12
    || (uint64_t v13 = CMBaseObjectGetDerivedStorage(a1),
        int v14 = FigXPCCreateBasicMessage(0x6176616Cu, v44, &v43),
        (*((_DWORD *)v46 + 6) = v14) != 0)
    || (int v15 = FigXPCRemoteClientSendSyncMessageCreatingReply(v37, (uint64_t)v43, &xdict),
        (*((_DWORD *)v46 + 6) = v15) != 0))
  {
    uint64_t v21 = 0;
    goto LABEL_20;
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, "AddedEndpoints");
  xpc_object_t v17 = xpc_dictionary_get_value(xdict, "SubtractedEndpoints");
  if (v17)
  {
    char v18 = 1;
LABEL_18:
    NeroValeriaListenerSetActiveStatus(*(void *)(v13 + 8), v18);
    goto LABEL_19;
  }
  if (value)
  {
    char v18 = 0;
    goto LABEL_18;
  }
LABEL_19:
  int v20 = *(NSObject **)(v13 + 16);
  uint64_t block = MEMORY[0x1E4F143A8];
  uint64_t v29 = 0x40000000;
  long long v30 = __remoteXPCEndpointManager_CopyAvailableEndpoints_block_invoke;
  int v31 = &unk_1E56761A0;
  int v34 = (__CFString *)v13;
  xpc_object_t v35 = value;
  xpc_object_t v36 = v17;
  int v32 = &v45;
  int v33 = &v38;
  dispatch_sync(v20, &block);
  uint64_t v21 = (void *)v39[3];
  CFTypeRef cf = v21;
  v39[3] = 0;
LABEL_20:
  uint64_t v22 = (const void *)v39[3];
  if (v22) {
    CFRelease(v22);
  }
  FigXPCRelease(v43);
  FigXPCRelease(xdict);
  uint64_t v8 = *((unsigned int *)v46 + 6);
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v45, 8);
  long long v23 = *(NSObject **)(DerivedStorage + 16);
  uint64_t block = MEMORY[0x1E4F143A8];
  uint64_t v29 = 0x40000000;
  long long v30 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
  int v31 = &__block_descriptor_tmp_22;
  int v32 = (uint64_t *)v21;
  int v33 = (uint64_t *)DerivedStorage;
  int v34 = @"AvailableEndpoints";
  dispatch_sync(v23, &block);
LABEL_23:
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v8;
}

uint64_t FigEndpointManagerRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t result = remoteXPCEndpointManager_ensureConnected(a1, &v6, &v7);
  if (!result) {
    return FigXPCSendStdSetPropertyMessage(v6, v7, a2, a3);
  }
  return result;
}

uint64_t remoteXPCEndpointManager_getSharedXPCClient(uint64_t *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock(&remoteXPCEndpointManager_getSharedXPCClient_lock);
  uint64_t v2 = remoteXPCEndpointManager_getSharedXPCClient_sSharedClient;
  if (remoteXPCEndpointManager_getSharedXPCClient_err) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = remoteXPCEndpointManager_getSharedXPCClient_sSharedClient == 0;
  }
  if (!v3) {
    goto LABEL_21;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_DeathNoticeName", @"EndpointManager_ServerConnectionDied");
  CFDictionarySetValue(Mutable, @"xpcRemoteClientOption_PrivilegedConnection", (const void *)*MEMORY[0x1E4F1CFD0]);
  unsigned int v17 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v17, &type);
  unsigned int v6 = v17;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type) ? v6 : v6 & 0xFFFFFFFE)
  {
    int v18 = 136315138;
    uint64_t v19 = "remoteXPCEndpointManager_getSharedXPCClient";
    int v9 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v6) = v17;
  }
  else
  {
    int v9 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v9, v9 != v22, v6, 0, v7);
  remoteXPCEndpointManager_getSharedXPCClient_err = FigXPCRemoteClientCreate((uint64_t)"com.apple.coremedia.endpointmanager.xpc", remoteXPCEndpointManager_getSharedXPCClient_clientCallbacks, Mutable, &remoteXPCEndpointManager_getSharedXPCClient_sSharedClient);
  unsigned int v17 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  uint64_t v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v17, &type);
  unsigned int v11 = v17;
  if (os_log_type_enabled(v10, type) ? v11 : v11 & 0xFFFFFFFE)
  {
    int v18 = 136315394;
    uint64_t v19 = "remoteXPCEndpointManager_getSharedXPCClient";
    __int16 v20 = 1024;
    int v21 = remoteXPCEndpointManager_getSharedXPCClient_err;
    int v14 = (unsigned char *)_os_log_send_and_compose_impl();
    LOBYTE(v11) = v17;
  }
  else
  {
    int v14 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v14, v14 != v22, v11, 0, v12);
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t v2 = remoteXPCEndpointManager_getSharedXPCClient_sSharedClient;
  if (!remoteXPCEndpointManager_getSharedXPCClient_sSharedClient) {
    FigSignalErrorAt(remoteXPCEndpointManager_getSharedXPCClient_err, 0, 0, 0, 0, 0, 0);
  }
  else {
LABEL_21:
  }
    *a1 = v2;
  os_unfair_lock_unlock(&remoteXPCEndpointManager_getSharedXPCClient_lock);
  return remoteXPCEndpointManager_getSharedXPCClient_err;
}

void remoteXPCEndpointManagerClient_DeadConnectionCallback(const void *a1)
{
  v31[16] = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2000000000;
  int v21 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v21, &type);
  int v4 = v21;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v6 = v4;
  }
  else {
    unsigned int v6 = v4 & 0xFFFFFFFE;
  }
  if (v6)
  {
    int v27 = 136315138;
    long long v28 = "remoteXPCEndpointManagerClient_DeadConnectionCallback";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v21;
  }
  else
  {
    uint64_t v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != v31, v4, 0, v5);
  uint64_t v8 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointManagerClient_DeadConnectionCallback_block_invoke;
  block[3] = &unk_1E5676128;
  block[4] = &v22;
  void block[5] = DerivedStorage;
  dispatch_sync(v8, block);
  remoteXPCEndpointManager_ResetCachedAvailableEndpoints(DerivedStorage);
  uint64_t v9 = *MEMORY[0x1E4F1CFC8];
  uint64_t v10 = *(NSObject **)(DerivedStorage + 16);
  v31[0] = MEMORY[0x1E4F143A8];
  v31[1] = 0x40000000;
  v31[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
  v31[3] = &__block_descriptor_tmp_22;
  v31[4] = v9;
  v31[5] = DerivedStorage;
  v31[6] = @"EndpointPresent";
  dispatch_sync(v10, v31);
  unsigned int v11 = *(NSObject **)(DerivedStorage + 64);
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification(v11, DefaultLocalCenter, @"EndpointManager_AvailableEndpointsChanged", a1, 0, 0);
  if (!remoteXPCEndpointManager_getSharedXPCClient(&v26))
  {
    FigXPCRemoteClientDisassociateObject(v26, (const void *)v23[3]);
    int v21 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    uint64_t v13 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v21, &type);
    int v14 = v21;
    if (os_log_type_enabled(v13, type)) {
      unsigned int v16 = v14;
    }
    else {
      unsigned int v16 = v14 & 0xFFFFFFFE;
    }
    if (v16)
    {
      uint64_t v17 = v23[3];
      int v27 = 136315394;
      long long v28 = "remoteXPCEndpointManagerClient_DeadConnectionCallback";
      __int16 v29 = 2048;
      uint64_t v30 = v17;
      int v18 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(v14) = v21;
    }
    else
    {
      int v18 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v18, v18 != v31, v14, 0, v15);
  }
  _Block_object_dispose(&v22, 8);
}

uint64_t remoteXPCEndpointManagerClient_NotificationFilter(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"EndpointManager_AvailableEndpointsChanged"))
  {
    int v4 = kFigEndpointManagerProperty_AvailableEndpoints;
LABEL_5:
    uint64_t v5 = *v4;
    unsigned int v6 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
    block[3] = &__block_descriptor_tmp_22;
    block[4] = 0;
    void block[5] = DerivedStorage;
    void block[6] = v5;
    dispatch_sync(v6, block);
    return 0;
  }
  if (CFEqual(a2, @"EndpointManager_EndpointPresentChanged"))
  {
    int v4 = kFigEndpointManagerProperty_EndpointPresent;
    goto LABEL_5;
  }
  return 0;
}

uint64_t remoteXPCEndpointManager_ensureConnected(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  int v21 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  uint64_t v17 = 0;
  uint64_t v13 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t SharedXPCClient = remoteXPCEndpointManager_getSharedXPCClient(&v13);
  *((_DWORD *)v19 + 6) = SharedXPCClient;
  if (SharedXPCClient)
  {
    uint64_t v10 = SharedXPCClient;
  }
  else
  {
    uint64_t v8 = *(NSObject **)(DerivedStorage + 16);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    v12[2] = __remoteXPCEndpointManager_ensureConnected_block_invoke;
    v12[3] = &unk_1E5676178;
    uint64_t v9 = v13;
    v12[6] = DerivedStorage;
    v12[7] = v13;
    v12[4] = &v18;
    v12[5] = &v14;
    v12[8] = a1;
    dispatch_sync(v8, v12);
    uint64_t v10 = *((unsigned int *)v19 + 6);
    if (!v10)
    {
      if (a3) {
        *a3 = v15[3];
      }
      uint64_t v10 = 0;
      if (a2) {
        *a2 = v9;
      }
    }
  }
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return v10;
}

void __remoteXPCEndpointManager_ensureConnected_block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  xpc_object_t xdict = 0;
  *(void *)uint64_t v20 = 0;
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 40);
  if (v2)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v2;
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigXPCCreateBasicMessage(0x6765706Du, 0, v20);
    if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigXPCMessageSetCFString(*(void **)v20, "EndpointManagerType", **(CFTypeRef **)(a1 + 48));
      if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigXPCRemoteClientSendSyncMessageCreatingReply(*(void *)(a1 + 56), *(uint64_t *)v20, &xdict);
        if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
        {
          *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = xpc_dictionary_get_uint64(xdict, ".objectID");
          if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
          {
            int v18 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v18, &type);
            int v4 = v18;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v6 = v4;
            }
            else {
              unsigned int v6 = v4 & 0xFFFFFFFE;
            }
            if (v6)
            {
              uint64_t v7 = **(void **)(a1 + 48);
              uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
              int v21 = 136315650;
              uint64_t v22 = "remoteXPCEndpointManager_ensureConnected_block_invoke";
              __int16 v23 = 2112;
              uint64_t v24 = v7;
              __int16 v25 = 2048;
              uint64_t v26 = v8;
              uint64_t v9 = (unsigned char *)_os_log_send_and_compose_impl();
              LOBYTE(v4) = v18;
            }
            else
            {
              uint64_t v9 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v9, v9 != v27, v4, 0, v5);
            *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigXPCRemoteClientAssociateObject(*(void *)(a1 + 56), *(void *)(a1 + 64), *(const void **)(*(void *)(*(void *)(a1 + 40) + 8)+ 24));
            if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
            {
              uint64_t v15 = *(void *)(a1 + 48);
              *(void *)(v15 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
              uint64_t v16 = *(const void **)(v15 + 48);
              if (v16) {
                remoteXPCFigEndpointManager_sendSetDiscoveryMode(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), *(void *)(a1 + 56), v16, *(const void **)(v15 + 56));
              }
            }
          }
          else
          {
            int v18 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            uint64_t v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v18, &type);
            int v11 = v18;
            if (os_log_type_enabled(v10, type)) {
              unsigned int v13 = v11;
            }
            else {
              unsigned int v13 = v11 & 0xFFFFFFFE;
            }
            if (v13)
            {
              int v21 = 136315138;
              uint64_t v22 = "remoteXPCEndpointManager_ensureConnected_block_invoke";
              uint64_t v14 = (unsigned char *)_os_log_send_and_compose_impl();
              LOBYTE(v11) = v18;
            }
            else
            {
              uint64_t v14 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v14, v14 != v27, v11, 0, v12);
            *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
          }
        }
      }
    }
  }
  FigXPCRelease(xdict);
  FigXPCRelease(*(xpc_object_t *)v20);
}

uint64_t remoteXPCFigEndpointManager_sendSetDiscoveryMode(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  *(void *)uint64_t v10 = 0;
  uint64_t v7 = FigXPCCreateBasicMessage(0x73646D20u, a1, v10);
  if (!v7)
  {
    FigXPCMessageSetCFString(*(void **)v10, "DiscoveryMode", a3);
    FigXPCMessageSetCFDictionary(*(void **)v10, "DiscoveryOptions", a4);
    uint64_t v7 = FigXPCRemoteClientSendSyncMessage(a2, *(uint64_t *)v10);
  }
  uint64_t v8 = v7;
  FigXPCRelease(*(xpc_object_t *)v10);
  return v8;
}

uint64_t FigEndpointManagerRemoteXPC_SetDiscoveryMode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  int v17 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v7 = remoteXPCEndpointManager_ensureConnected(a1, &v12, &v13);
  *((_DWORD *)v15 + 6) = v7;
  if (v7)
  {
    uint64_t v9 = v7;
  }
  else
  {
    uint64_t v8 = *(NSObject **)(DerivedStorage + 16);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    v11[2] = __FigEndpointManagerRemoteXPC_SetDiscoveryMode_block_invoke;
    v11[3] = &unk_1E56761C8;
    v11[4] = &v14;
    v11[5] = v13;
    v11[6] = v12;
    v11[7] = a2;
    v11[8] = a3;
    v11[9] = DerivedStorage;
    dispatch_sync(v8, v11);
    uint64_t v9 = *((unsigned int *)v15 + 6);
  }
  _Block_object_dispose(&v14, 8);
  return v9;
}

uint64_t FigEndpointManagerRemoteXPC_CreateEndpointAggregate(uint64_t a1, unsigned int a2, CFTypeRef *a3)
{
  xpc_object_t xdict = 0;
  uint64_t v12 = 0;
  uint64_t v9 = 0;
  xpc_object_t v10 = 0;
  CFTypeRef cf = 0;
  uint64_t v5 = remoteXPCEndpointManager_ensureConnected(a1, &v9, &v12);
  if (v5
    || (uint64_t v5 = FigXPCCreateBasicMessage(0x63726561u, v12, &xdict), v5)
    || (xpc_dictionary_set_uint64(xdict, "EndpointAggregateType", a2),
        uint64_t v5 = FigXPCRemoteClientSendSyncMessageCreatingReply(v9, (uint64_t)xdict, &v10),
        v5))
  {
    uint64_t v6 = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t)FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v10, 0, &cf);
    if (!v6)
    {
      *a3 = cf;
      CFTypeRef cf = 0;
    }
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v10);
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t FigEndpointManagerRemoteXPC_CopyEndpointRemoteControlDepot(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v10 = 0;
  xpc_object_t v8 = 0;
  xpc_object_t v9 = 0;
  CFTypeRef cf = 0;
  uint64_t v7 = 0;
  if (a2)
  {
    uint64_t v3 = remoteXPCEndpointManager_ensureConnected(a1, &v7, &v10);
    if (v3
      || (uint64_t v3 = FigXPCCreateBasicMessage(0x65726364u, v10, &v9), v3)
      || (uint64_t v3 = FigXPCRemoteClientSendSyncMessageCreatingReply(v7, (uint64_t)v9, &v8), v3))
    {
      uint64_t v4 = v3;
    }
    else
    {
      uint64_t v4 = (uint64_t)FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v8, 0, &cf);
      if (!v4)
      {
        *a2 = cf;
        CFTypeRef cf = 0;
      }
    }
  }
  else
  {
    uint64_t v4 = 4294950586;
  }
  FigXPCRelease(v9);
  FigXPCRelease(v8);
  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

void __remoteXPCEndpointManager_startListeningForValeriaConnections_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t CMBaseObject = FigEndpointManagerGetCMBaseObject(*(void *)(a1 + 32));
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, __CFString *, void))(v3 + 56);
  if (v4)
  {
    int v5 = v4(CMBaseObject, @"ValeriaConnected", *MEMORY[0x1E4F1CFD0]);
    if (!v5) {
      return;
    }
  }
  else
  {
    int v5 = -12782;
  }
  v12[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v12, &type);
  int v7 = v12[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = v7 & 0xFFFFFFFE;
  }
  if (v9)
  {
    v12[1] = 136315394;
    uint64_t v13 = "remoteXPCEndpointManager_startListeningForValeriaConnections_block_invoke";
    __int16 v14 = 1024;
    int v15 = v5;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v7) = v12[0];
  }
  else
  {
    uint64_t v10 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v10, v10 != &v16, v7, 0, v8);
}

uint64_t FigWatchdogMonitorDispatchQueue(uint64_t a1)
{
  if (a1)
  {
    if (sDidRegisterWatchdogClient)
    {
      wd_endpoint_add_queue();
      return 0;
    }
    uint64_t v2 = 4294949365;
  }
  else
  {
    uint64_t v2 = 4294949366;
  }

  return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
}

uint64_t FigWatchdogBeginVitalWork(const char *a1, uint64_t *a2)
{
  if (a1 && a2)
  {
    if (sDidRegisterWatchdogClient)
    {
      FigSimpleMutexLock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
      uint64_t v4 = sNextVitalWorkID++;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberRef SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v4);
      CFStringRef v7 = CFStringCreateWithCString(v5, a1, 0x8000100u);
      CFDictionarySetValue((CFMutableDictionaryRef)sVitalWorkDescriptions, SInt64, v7);
      ++sVitalWorkSectionsInProgress;
      FigSimpleMutexUnlock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
      *a2 = v4;
      if (SInt64) {
        CFRelease(SInt64);
      }
      if (v7) {
        CFRelease(v7);
      }
      return 0;
    }
    uint64_t v9 = 4294949365;
  }
  else
  {
    uint64_t v9 = 4294949366;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigWatchdogCompleteVitalWork(uint64_t a1)
{
  if (a1 <= 0)
  {
    uint64_t v4 = 4294949366;
  }
  else
  {
    if (sDidRegisterWatchdogClient)
    {
      FigSimpleMutexLock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
      CFNumberRef SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sVitalWorkDescriptions, SInt64);
      --sVitalWorkSectionsInProgress;
      FigSimpleMutexUnlock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
      if (SInt64) {
        CFRelease(SInt64);
      }
      return 0;
    }
    uint64_t v4 = 4294949365;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigWatchdogStart(uint64_t a1)
{
  if (a1)
  {
    if ((sDidRegisterWatchdogClient & 1) == 0)
    {
      sVitalWorkDescriptionMutex = (uint64_t)FigSimpleMutexCreate();
      sVitalWorkDescriptions = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      wd_endpoint_register();
      wd_endpoint_set_alive_func();
      wd_endpoint_activate();
      sDidRegisterWatchdogClient = 1;
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949366, 0, 0, 0, 0, 0, 0);
  }
}

BOOL __FigWatchdogStart_block_invoke(uint64_t a1, char **a2, void *a3)
{
  int v3 = sVitalWorkSectionsInProgress;
  if (sVitalWorkSectionsInProgress)
  {
    uint64_t v9 = 0;
    FigSimpleMutexLock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
    uint64_t v6 = FigCFCopyCompactDescription((const __CFSet *)sVitalWorkDescriptions);
    CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v6, 0x8000100u, (char **)&v9);
    asprintf(a2, "%d vital tasks are still running: %s", sVitalWorkSectionsInProgress, CStringPtrAndBufferToFree);
    FigSimpleMutexUnlock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
    *a3 = -17932;
    if (v6) {
      CFRelease(v6);
    }
    free(v9);
  }
  return v3 == 0;
}

CFStringRef FigBaseObjectCopyDebugDescription(uint64_t *cf)
{
  int v3 = cf + 3;
  uint64_t v2 = cf[3];
  if (v2) {
    uint64_t v4 = cf[3];
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(void *)(v4 + 8)) {
    uint64_t v5 = *(void *)(v4 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (!*(void *)(v5 + 40))
  {
LABEL_13:
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v2) {
      uint64_t v9 = v2;
    }
    else {
      uint64_t v9 = 0;
    }
    CFAllocatorRef v10 = CFGetAllocator(cf);
    return CFStringCreateWithFormat(v8, 0, @"<CMBaseObject: instance<%p> storage<%p> class<%p> allocator<%p>>", cf, cf + 4, v9, v10);
  }
  if (*(void *)(v2 + 8)) {
    uint64_t v6 = *(void *)(v2 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  CFStringRef result = (CFStringRef)(*(uint64_t (**)(uint64_t *))(v6 + 40))(cf);
  if (!result)
  {
    uint64_t v2 = *v3;
    goto LABEL_13;
  }
  return result;
}

uint64_t FigBaseProtocolRegisterProtocol(long long *a1, uint64_t a2, void *a3)
{
  if (a1 && a3)
  {
    MallocZoneForPermanentAllocations = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
    uint64_t v6 = (char *)malloc_type_zone_calloc(MallocZoneForPermanentAllocations, 1uLL, 0x28uLL, 0x1070040C4A17F08uLL);
    if (v6)
    {
      *(void *)uint64_t v6 = 0;
      long long v7 = *a1;
      *(_OWORD *)(v6 + 24) = a1[1];
      *(_OWORD *)(v6 + 8) = v7;
      *a3 = v6;
      return 0;
    }
    uint64_t v9 = 4294954510;
  }
  else
  {
    uint64_t v9 = 4294954516;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t CMDerivedObjectCreate(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!a2 || !a4) {
    goto LABEL_10;
  }
  unint64_t v6 = **(void **)(a2 + 8);
  if (!v6 || v6 >= 6)
  {
    uint64_t v9 = 4294954515;
    goto LABEL_11;
  }
  if (*(void *)a2 || !a3)
  {
LABEL_10:
    uint64_t v9 = 4294954516;
LABEL_11:
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  CFAllocatorRef v8 = a3;
  while (!v8[14])
  {
    CFAllocatorRef v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_10;
    }
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v9 = 4294954510;
    goto LABEL_11;
  }
  uint64_t v12 = Instance;
  Instance[2] = a3;
  Instance[3] = a2;
  bzero(Instance + 4, *(void *)(*(void *)(a2 + 8) + 8));
  uint64_t v13 = *(void **)(a2 + 8);
  if (*v13 >= 2uLL
    && (__int16 v14 = (uint64_t (*)(uint64_t))v13[8]) != 0
    && v14 == FigBaseObjectStandardNotificationBarrier
    && (CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter(),
        uint64_t v16 = CMNotificationCenterRegisterForBarrierSupport((uint64_t)DefaultLocalCenter, (uint64_t)v12),
        v16))
  {
    uint64_t v17 = v16;
    CFRelease(v12);
  }
  else
  {
    uint64_t v17 = 0;
    *a4 = v12;
  }
  return v17;
}

uint64_t FigBaseObjectStandardNotificationBarrier(uint64_t a1)
{
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterBarrier((uint64_t)DefaultLocalCenter, a1);
}

uint64_t CMBaseObjectGetVTable(uint64_t result)
{
  if (result)
  {
    if (*(void *)(result + 24)) {
      return *(void *)(result + 24);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CMBaseObjectGetProtocolVTable(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (!a1 || !a2) {
    return result;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    return 0;
  }
  unint64_t v6 = *(void **)(v5 + 8);
  if (*v6 < 3uLL) {
    return 0;
  }
  uint64_t v7 = v6[9];
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  unint64_t v9 = *(unsigned int *)(v7 + 4);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    uint64_t v12 = *(uint64_t (**)(void))(*(void *)(v8 + 8) + v10);
    if (v12) {
      break;
    }
LABEL_11:
    uint64_t result = 0;
    ++v11;
    v10 += 16;
    if (v11 >= v9) {
      return result;
    }
  }
  if (v12(0) != a2)
  {
    unint64_t v9 = *(unsigned int *)(v8 + 4);
    goto LABEL_11;
  }
  if (*(void *)(*(void *)(v8 + 8) + v10 + 8)) {
    return *(void *)(*(void *)(v8 + 8) + v10 + 8);
  }
  return 0;
}

uint64_t CMBaseObjectGetDerivedStorage(uint64_t a1)
{
  if (a1) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

uint64_t CMBaseObjectGetClassID(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t CMBaseClassGetCFTypeID(void *a1)
{
  if (!a1) {
    return 0;
  }
  while (1)
  {
    uint64_t v1 = a1[14];
    if (v1) {
      break;
    }
    a1 = (void *)*a1;
    if (!a1) {
      return 0;
    }
  }
  return v1;
}

uint64_t CMBaseObjectIsMemberOfClass(char *cf, void *a2)
{
  if (!a2) {
    goto LABEL_7;
  }
  uint64_t v4 = a2;
  while (1)
  {
    uint64_t v5 = v4[14];
    if (v5) {
      break;
    }
    uint64_t v4 = (void *)*v4;
    if (!v4) {
      goto LABEL_7;
    }
  }
  if (v5 == CFGetTypeID(cf))
  {
LABEL_7:
    unint64_t v6 = cf + 16;
    while (1)
    {
      unint64_t v6 = (void *)*v6;
      if (!v6) {
        break;
      }
      if (v6 == a2) {
        return 1;
      }
    }
  }
  return 0;
}

BOOL CFTypeIsCMBaseObject(const void *a1)
{
  return *(void *)(_CFRuntimeGetClassWithTypeID() + 16) == (void)FigBaseObjectInit;
}

void *CMBaseGetClassID()
{
  return &kFigBaseClassID;
}

BOOL CMBaseObjectImplementsProtocol(uint64_t a1, uint64_t a2)
{
  return CMBaseObjectGetProtocolVTable(a1, a2) != 0;
}

__CFString *CMBaseProtocolCopyDebugDescription(const void *a1, uint64_t a2)
{
  uint64_t ProtocolVTable = CMBaseObjectGetProtocolVTable((uint64_t)a1, a2);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<CMBaseProtocol on CMBaseObject: protocol<%p> instance<%p> allocator<%p>>{", a2, a1, v6);
  if (ProtocolVTable
    && (uint64_t v7 = *(void *)(ProtocolVTable + 8)) != 0
    && (uint64_t v8 = *(uint64_t (**)(const void *))(v7 + 8)) != 0
    && (uint64_t v9 = v8(a1)) != 0)
  {
    uint64_t v10 = (const void *)v9;
    CFStringAppendFormat(Mutable, 0, @"\n%@\n", v9);
    CFRelease(v10);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"UNIMPLEMENTED");
  }
  CFStringAppend(Mutable, @"}");
  return Mutable;
}

uint64_t FigBaseObjectGetClassID(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t FigBaseClassGetCFTypeID(void *a1)
{
  if (!a1) {
    return 0;
  }
  while (1)
  {
    uint64_t v1 = a1[14];
    if (v1) {
      break;
    }
    a1 = (void *)*a1;
    if (!a1) {
      return 0;
    }
  }
  return v1;
}

uint64_t _FigEnsureReadyToCollectIncrementalCoverageData(uint64_t a1)
{
  if (a1)
  {
    CFStringRef theString = 0;
    long long v11 = xmmword_18FE95520;
    CFRange result = (CFRange)xmmword_18FE95520;
    uint64_t v3 = FigCopyCoverageFilePathPattern(&theString);
    CFStringRef v4 = theString;
    if (v3)
    {
      uint64_t v7 = v3;
LABEL_23:
      if (v4) {
        CFRelease(v4);
      }
      return v7;
    }
    if (theString)
    {
      if (CFStringFind(theString, @"%m", 4uLL).location != -1)
      {
        CFMutableStringRef MutableCopy = 0;
        goto LABEL_20;
      }
    }
    else
    {
      FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
    }
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v4);
    v14.length = CFStringGetLength(MutableCopy);
    v14.location = 0;
    if (!CFStringFindWithOptions(MutableCopy, @"/", v14, 4uLL, &result))
    {
      uint64_t v10 = FigSignalErrorAt(4294949394, 0, 0, 0, 0, 0, 0);
LABEL_21:
      uint64_t v7 = v10;
      if (MutableCopy)
      {
        CFRelease(MutableCopy);
        CFStringRef v4 = theString;
      }
      goto LABEL_23;
    }
    CFIndex Length = CFStringGetLength(MutableCopy);
    v15.location = result.location;
    v15.length = Length - result.location;
    result.length = Length - result.location;
    if (CFStringFindWithOptions(MutableCopy, @".", v15, 4uLL, (CFRange *)&v11)) {
      CFIndex v9 = v11;
    }
    else {
      CFIndex v9 = CFStringGetLength(MutableCopy);
    }
    CFStringInsert(MutableCopy, v9, @"-%m");
    CFStringRef theString = MutableCopy;
    if (MutableCopy) {
      CFRetain(MutableCopy);
    }
    if (v4) {
      CFRelease(v4);
    }
    CFStringRef v4 = MutableCopy;
LABEL_20:
    uint64_t v10 = _FigSetCoverageFilePathPattern(a1, v4);
    goto LABEL_21;
  }
  return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCopyCoverageFilePathPattern(void *a1)
{
  if (getCodeCoverageGlobals_onceToken != -1) {
    dispatch_once(&getCodeCoverageGlobals_onceToken, &__block_literal_global_1);
  }
  FigSimpleMutexLock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  if (getCodeCoverageGlobals_sFigCodeCoverageGlobals_0)
  {
    uint64_t v2 = (void *)CFRetain((CFTypeRef)getCodeCoverageGlobals_sFigCodeCoverageGlobals_0);
    FigSimpleMutexUnlock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
    if (v2)
    {
LABEL_9:
      uint64_t result = 0;
      *a1 = v2;
      return result;
    }
  }
  else
  {
    FigSimpleMutexUnlock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  }
  uint64_t v3 = getenv("LLVM_PROFILE_FILE");
  if (v3)
  {
    uint64_t v2 = (void *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    goto LABEL_9;
  }
  return 4294949395;
}

uint64_t _FigCopyResolvedCoverageFilePath(uint64_t a1, CFStringRef *a2)
{
  if (a1 && (uint64_t v2 = *(uint64_t (**)(void))(a1 + 24)) != 0)
  {
    CFStringRef v4 = (const char *)v2();
    if (v4) {
      *a2 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t _FigSetCoverageFilePathPattern(uint64_t a1, CFStringRef theString)
{
  uint64_t v2 = (uint64_t (**)(void))a1;
  long long v11 = 0;
  if (!a1)
  {
    uint64_t v10 = 4294949396;
LABEL_16:
    uint64_t v8 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  uint64_t v3 = *(uint64_t (**)(char *))(a1 + 16);
  if (!v3 || !*(void *)(a1 + 24))
  {
    uint64_t v8 = FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
    uint64_t v2 = 0;
    goto LABEL_12;
  }
  CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(theString, 0x8000100u, (char **)&v11);
  uint64_t v6 = v3(CStringPtrAndBufferToFree);
  uint64_t v2 = (uint64_t (**)(void))v2[3](v6);
  if (!v2)
  {
    uint64_t v10 = 4294949395;
    goto LABEL_16;
  }
  if (getCodeCoverageGlobals_onceToken != -1) {
    dispatch_once(&getCodeCoverageGlobals_onceToken, &__block_literal_global_1);
  }
  FigSimpleMutexLock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  uint64_t v7 = (const void *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_0;
  getCodeCoverageGlobals_sFigCodeCoverageGlobals_0 = (uint64_t)theString;
  if (theString) {
    CFRetain(theString);
  }
  if (v7) {
    CFRelease(v7);
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  uint64_t v8 = 0;
LABEL_12:
  free(v2);
  free(v11);
  return v8;
}

uint64_t _FigFinishUpdatingIncrementalCodeCoverageData(uint64_t (**a1)(void))
{
  if (a1 && (uint64_t v1 = *a1) != 0) {
    return v1();
  }
  else {
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t _FigBeginUpdatingIncrementalCodeCoverageData(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void (**)(void))(a1 + 8)) != 0)
  {
    v1();
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CMFinishUpdatingIncrementalCodeCoverageData()
{
  return 4294949395;
}

uint64_t CMBeginUpdatingIncrementalCodeCoverageData()
{
  return 4294949395;
}

uint64_t CMEnsureReadyToCollectIncrementalCoverageData()
{
  return 4294949395;
}

uint64_t CMSetCodeCoverageFilePathPattern()
{
  return 4294949395;
}

pthread_mutex_t *__getCodeCoverageGlobals_block_invoke()
{
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  getCodeCoverageGlobals_sFigCodeCoverageGlobals_1 = (uint64_t)result;
  getCodeCoverageGlobals_sFigCodeCoverageGlobals_0 = 0;
  return result;
}

void FigCVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
  if (value) {
    CVBufferSetAttachment(buffer, key, value, attachmentMode);
  }
  else {
    CVBufferRemoveAttachment(buffer, key);
  }
}

CFDictionaryRef FigCVBufferCopyDictionaryOfAttachments(int a1, CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return CVBufferCopyAttachments(buffer, attachmentMode);
}

uint64_t FigEndpointManagerCopyActivatedEndpoints(uint64_t a1, const __CFAllocator *a2, __CFArray **a3)
{
  CFBooleanRef BOOLean = 0;
  CFArrayRef theArray = 0;
  if (!a1 || !a3)
  {
    uint64_t v9 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_33:
    uint64_t v20 = v9;
    goto LABEL_22;
  }
  uint64_t CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFArrayRef *))(v7 + 48);
  if (!v8)
  {
    CFMutableDictionaryRef Mutable = 0;
LABEL_24:
    uint64_t v20 = 4294954514;
    goto LABEL_25;
  }
  uint64_t v9 = v8(CMBaseObject, @"AvailableEndpoints", a2, &theArray);
  if (v9) {
    goto LABEL_33;
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a2, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      CFIndex v13 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v13);
        uint64_t v15 = FigEndpointGetCMBaseObject(ValueAtIndex);
        uint64_t v16 = *(void *)(CMBaseObjectGetVTable(v15) + 8);
        uint64_t v17 = v16 ? v16 : 0;
        int v18 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFBooleanRef *))(v17 + 48);
        if (!v18) {
          goto LABEL_24;
        }
        uint64_t v19 = v18(v15, @"IsActivated", a2, &BOOLean);
        if (v19) {
          goto LABEL_35;
        }
        if (CFBooleanGetValue(BOOLean)) {
          CFArrayAppendValue(Mutable, ValueAtIndex);
        }
        if (BOOLean)
        {
          CFRelease(BOOLean);
          CFBooleanRef BOOLean = 0;
        }
      }
      while (v12 != ++v13);
    }
    uint64_t v20 = 0;
    *a3 = Mutable;
LABEL_22:
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_25;
  }
  uint64_t v19 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_35:
  uint64_t v20 = v19;
LABEL_25:
  if (theArray) {
    CFRelease(theArray);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (BOOLean) {
    CFRelease(BOOLean);
  }
  return v20;
}

uint64_t FigEndpointManagerCopyEndpointForID(const void *a1, uint64_t a2, CFTypeRef cf, CFTypeRef *a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFStringGetTypeID()))
  {
    return managerUtil_copyEndpointMatchingPropertyValue(a1, a2, @"ID", cf, a4);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t managerUtil_copyEndpointMatchingPropertyValue(const void *a1, uint64_t a2, const void *a3, const void *a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  CFArrayRef theArray = 0;
  if (!a1
    || (CFTypeID v10 = CFGetTypeID(a1), v10 != FigEndpointManagerGetTypeID())
    || !a3
    || (CFTypeID v11 = CFGetTypeID(a3), v11 != CFStringGetTypeID())
    || !a4
    || !a5)
  {
    uint64_t v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_36:
    uint64_t v25 = v16;
    goto LABEL_30;
  }
  uint64_t CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFArrayRef *))(v14 + 48);
  if (!v15)
  {
LABEL_24:
    uint64_t v25 = 4294954514;
    goto LABEL_30;
  }
  uint64_t v16 = v15(CMBaseObject, @"AvailableEndpoints", a2, &theArray);
  if (v16) {
    goto LABEL_36;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v18 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
      CFAllocatorRef v20 = CFGetAllocator(ValueAtIndex);
      uint64_t v21 = FigEndpointGetCMBaseObject(ValueAtIndex);
      uint64_t v22 = *(void *)(CMBaseObjectGetVTable(v21) + 8);
      uint64_t v23 = v22 ? v22 : 0;
      uint64_t v24 = *(uint64_t (**)(uint64_t, const void *, CFAllocatorRef, CFTypeRef *))(v23 + 48);
      if (!v24) {
        goto LABEL_24;
      }
      uint64_t v16 = v24(v21, a3, v20, &cf);
      if (v16) {
        goto LABEL_36;
      }
      if (FigCFEqual(cf, a4))
      {
        *a5 = CFRetain(ValueAtIndex);
        goto LABEL_27;
      }
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
      if (Count == ++v18)
      {
        CFIndex v18 = Count;
        goto LABEL_27;
      }
    }
  }
  CFIndex v18 = 0;
LABEL_27:
  if (v18 == Count) {
    uint64_t v25 = 4294950583;
  }
  else {
    uint64_t v25 = 0;
  }
LABEL_30:
  if (theArray) {
    CFRelease(theArray);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v25;
}

uint64_t FigEndpointManagerCopyEndpointForName(const void *a1, uint64_t a2, CFTypeRef cf, CFTypeRef *a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFStringGetTypeID()))
  {
    return managerUtil_copyEndpointMatchingPropertyValue(a1, a2, @"Name", cf, a4);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigEndpointManagerCopyEndpointsForType(const void *a1, const __CFAllocator *a2, const void *a3, __CFArray **a4)
{
  CFTypeRef cf = 0;
  CFArrayRef theArray = 0;
  if (!a1
    || (CFTypeID v8 = CFGetTypeID(a1), v8 != FigEndpointManagerGetTypeID())
    || !a3
    || (CFTypeID v9 = CFGetTypeID(a3), v9 != CFStringGetTypeID())
    || !a4)
  {
    uint64_t v26 = FigSignalErrorAt(4294950586, 0, 0, 0, 0, 0, 0);
    goto LABEL_25;
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a2, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v15 = FigSignalErrorAt(4294950585, 0, 0, 0, 0, 0, 0);
LABEL_37:
    uint64_t v26 = v15;
    goto LABEL_27;
  }
  uint64_t CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFArrayRef *))(v13 + 48);
  if (!v14)
  {
    uint64_t v26 = 4294954514;
    goto LABEL_27;
  }
  uint64_t v15 = v14(CMBaseObject, @"AvailableEndpoints", a2, &theArray);
  if (v15) {
    goto LABEL_37;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
LABEL_24:
    uint64_t v26 = 0;
    *a4 = Mutable;
LABEL_25:
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_27;
  }
  CFIndex v17 = Count;
  CFIndex v18 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
    CFAllocatorRef v20 = CFGetAllocator(ValueAtIndex);
    uint64_t v21 = FigEndpointGetCMBaseObject(ValueAtIndex);
    uint64_t v22 = *(void *)(CMBaseObjectGetVTable(v21) + 8);
    if (v22) {
      uint64_t v23 = v22;
    }
    else {
      uint64_t v23 = 0;
    }
    uint64_t v24 = *(uint64_t (**)(uint64_t, __CFString *, CFAllocatorRef, CFTypeRef *))(v23 + 48);
    if (!v24)
    {
      uint64_t v26 = 4294954514;
      goto LABEL_33;
    }
    uint64_t v25 = v24(v21, @"Type", v20, &cf);
    if (v25) {
      break;
    }
    if (FigCFEqual(cf, a3)) {
      CFArrayAppendValue(Mutable, ValueAtIndex);
    }
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    if (v17 == ++v18) {
      goto LABEL_24;
    }
  }
  uint64_t v26 = v25;
LABEL_33:
  if (cf) {
    CFRelease(cf);
  }
LABEL_27:
  if (theArray) {
    CFRelease(theArray);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v26;
}

__CFArray *FigEndpointManagerCopyMatchingEndpoints(uint64_t a1, unsigned int (*a2)(const void *, uint64_t), uint64_t a3)
{
  CFArrayRef theArray = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFTypeID v9 = *(void (**)(uint64_t, __CFString *, const __CFAllocator *, CFArrayRef *))(v8 + 48);
  if (v9) {
    v9(CMBaseObject, @"AvailableEndpoints", v5, &theArray);
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E4F1D510]);
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        uint64_t v15 = ValueAtIndex;
        if (!a2 || a2(ValueAtIndex, a3)) {
          CFArrayAppendValue(Mutable, v15);
        }
      }
    }
  }
  if (Mutable && !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    CFMutableDictionaryRef Mutable = 0;
  }
  if (theArray) {
    CFRelease(theArray);
  }
  return Mutable;
}

uint64_t FigEndpointUtility_CopyMatchingEndpointEntities(const __CFArray *a1, unsigned int (*a2)(const void *, uint64_t), uint64_t a3, unsigned int (*a4)(const void *, uint64_t), uint64_t a5, unsigned int (*a6)(const void *, uint64_t, uint64_t), uint64_t a7, uint64_t a8, __CFArray **a9, __CFArray **a10, void *a11)
{
  CFIndex v12 = a10;
  CFTypeID v11 = a11;
  uint64_t v13 = a9;
  unsigned int v48 = 0;
  if (!a1 || (!a9 ? (BOOL v14 = a10 == 0) : (BOOL v14 = 0), v14 ? (v15 = a11 == 0) : (v15 = 0), v15))
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    CFMutableDictionaryRef Mutable = 0;
    unsigned int v48 = -16720;
    if (!a9) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  CFIndex Count = CFArrayGetCount(a1);
  uint64_t v23 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  uint64_t v44 = Count;
  if (a9)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
    if (a10) {
      goto LABEL_11;
    }
LABEL_21:
    xpc_object_t v43 = 0;
    if (a11) {
      goto LABEL_12;
    }
LABEL_22:
    uint64_t v24 = 0;
    goto LABEL_23;
  }
  CFMutableDictionaryRef Mutable = 0;
  if (!a10) {
    goto LABEL_21;
  }
LABEL_11:
  xpc_object_t v43 = CFArrayCreateMutable(*v23, 0, MEMORY[0x1E4F1D510]);
  if (!a11) {
    goto LABEL_22;
  }
LABEL_12:
  uint64_t v24 = CFArrayCreateMutable(*v23, 0, MEMORY[0x1E4F1D510]);
LABEL_23:
  uint64_t v13 = a9;
  if (v44 < 1) {
    goto LABEL_42;
  }
  CFIndex v27 = 0;
  unsigned int v28 = 0;
  uint64_t v41 = a4;
  uint64_t v42 = a5;
  uint64_t v40 = a3;
  do
  {
    if (!a2 || (__int16 v29 = CFArrayGetValueAtIndex(a1, v27), a2(v29, a3)))
    {
      if ((unint64_t)v43 | (unint64_t)v24)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v27);
        int v31 = FigEndpointManagerCopyMatchingEndpoints((uint64_t)ValueAtIndex, a4, a5);
        if (!v31) {
          goto LABEL_40;
        }
        CFArrayRef v32 = v31;
        CFIndex v33 = CFArrayGetCount(v31);
        if (v33 >= 1)
        {
          CFIndex v34 = v33;
          for (CFIndex i = 0; i != v34; ++i)
          {
            xpc_object_t v36 = CFArrayGetValueAtIndex(v32, i);
            if (v24)
            {
              uint64_t v37 = FigEndpointUtility_CopyMatchingStreamsFromEndpoint((uint64_t)v36, a6, a7, a8);
              if (v37)
              {
                CFArrayRef v38 = v37;
                v49.length = CFArrayGetCount(v37);
                v49.location = 0;
                CFArrayAppendArray(v24, v38, v49);
                CFRelease(v38);
              }
            }
          }
        }
        if (v43)
        {
          v50.length = CFArrayGetCount(v32);
          v50.location = 0;
          CFArrayAppendArray(v43, v32, v50);
        }
        CFRelease(v32);
        a4 = v41;
        a5 = v42;
        a3 = v40;
      }
      if (Mutable)
      {
        int v39 = CFArrayGetValueAtIndex(a1, v27);
        CFArrayAppendValue(Mutable, v39);
      }
    }
LABEL_40:
    CFIndex v27 = ++v28;
  }
  while (v44 > v28);
  CFIndex v12 = a10;
  CFTypeID v11 = a11;
  uint64_t v13 = a9;
LABEL_42:
  uint64_t v25 = v43;
  if (v13) {
LABEL_14:
  }
    *uint64_t v13 = Mutable;
LABEL_15:
  if (v12) {
    *CFIndex v12 = v25;
  }
  if (v11) {
    void *v11 = v24;
  }
  return v48;
}

uint64_t FigEndpointUtility_EndpointManagerPredicate_IsEndpointManagerOfType(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeRef cf = 0;
  uint64_t CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v7 = *(void (**)(uint64_t, __CFString *, void, CFTypeRef *))(v5 + 48);
  if (v7)
  {
    v7(CMBaseObject, @"Name", *MEMORY[0x1E4F1CF80], &cf);
    CFTypeRef v8 = cf;
  }
  else
  {
    CFTypeRef v8 = 0;
  }
  uint64_t v6 = FigCFEqual(v8, a2);
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t FigRuntimeUnregisterAttachmentBearerWithTypeID()
{
  return FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
}

void CMSetAttachment(CMAttachmentBearerRef target, CFStringRef key, CFTypeRef value, CMAttachmentMode attachmentMode)
{
  uint64_t v4 = *(void *)&attachmentMode;
  if (target)
  {
    CFTypeRef v8 = (const void *)CFGetTypeID(target);
    CFDictionaryRef AttachmentBearerCallbacksWithTypeID = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v8);
    if (!key) {
      goto LABEL_6;
    }
  }
  else
  {
    CFDictionaryRef AttachmentBearerCallbacksWithTypeID = 0;
    if (!key)
    {
LABEL_6:
      FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
      return;
    }
  }
  if (v4 >= 2) {
    goto LABEL_6;
  }
  if (AttachmentBearerCallbacksWithTypeID)
  {
    CFTypeID v10 = (void (*)(CMAttachmentBearerRef, CFStringRef, CFTypeRef, uint64_t))*((void *)AttachmentBearerCallbacksWithTypeID
                                                                                       + 1);
    v10(target, key, value, v4);
  }
}

CFTypeRef CMGetAttachment(CMAttachmentBearerRef target, CFStringRef key, CMAttachmentMode *attachmentModeOut)
{
  if (!target)
  {
    if (key) {
      return 0;
    }
LABEL_8:
    FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v6 = (const void *)CFGetTypeID(target);
  CFDictionaryRef AttachmentBearerCallbacksWithTypeID = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v6);
  if (!key) {
    goto LABEL_8;
  }
  if (!AttachmentBearerCallbacksWithTypeID) {
    return 0;
  }
  CFTypeRef v8 = (uint64_t (*)(CMAttachmentBearerRef, CFStringRef, CMAttachmentMode *))*((void *)AttachmentBearerCallbacksWithTypeID
                                                                                       + 2);

  return (CFTypeRef)v8(target, key, attachmentModeOut);
}

void CMRemoveAttachment(CMAttachmentBearerRef target, CFStringRef key)
{
  if (target)
  {
    uint64_t v4 = (const void *)CFGetTypeID(target);
    CFDictionaryRef AttachmentBearerCallbacksWithTypeID = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v4);
    if (key)
    {
      if (AttachmentBearerCallbacksWithTypeID)
      {
        uint64_t v6 = (void (*)(CMAttachmentBearerRef, CFStringRef))*((void *)AttachmentBearerCallbacksWithTypeID + 3);
        v6(target, key);
      }
      return;
    }
  }
  else if (key)
  {
    return;
  }

  FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
}

void CMRemoveAllAttachments(CMAttachmentBearerRef target)
{
  if (target)
  {
    uint64_t v2 = (const void *)CFGetTypeID(target);
    CFDictionaryRef AttachmentBearerCallbacksWithTypeID = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v2);
    if (AttachmentBearerCallbacksWithTypeID)
    {
      uint64_t v4 = (void (*)(CMAttachmentBearerRef))*((void *)AttachmentBearerCallbacksWithTypeID + 4);
      v4(target);
    }
  }
}

CFDictionaryRef CMCopyDictionaryOfAttachments(CFAllocatorRef allocator, CMAttachmentBearerRef target, CMAttachmentMode attachmentMode)
{
  uint64_t v3 = *(void *)&attachmentMode;
  if (!target)
  {
    if (attachmentMode < 2) {
      return 0;
    }
LABEL_8:
    FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v6 = (const void *)CFGetTypeID(target);
  CFDictionaryRef AttachmentBearerCallbacksWithTypeID = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v6);
  if (v3 > 1) {
    goto LABEL_8;
  }
  if (!AttachmentBearerCallbacksWithTypeID) {
    return 0;
  }
  CFTypeRef v8 = (uint64_t (*)(CFAllocatorRef, CMAttachmentBearerRef, uint64_t))*((void *)AttachmentBearerCallbacksWithTypeID
                                                                               + 5);

  return (CFDictionaryRef)v8(allocator, target, v3);
}

void CMSetAttachments(CMAttachmentBearerRef target, CFDictionaryRef theAttachments, CMAttachmentMode attachmentMode)
{
  if (target)
  {
    uint64_t v6 = (const void *)CFGetTypeID(target);
    CFDictionaryRef AttachmentBearerCallbacksWithTypeID = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v6);
    if (AttachmentBearerCallbacksWithTypeID)
    {
      context[1] = AttachmentBearerCallbacksWithTypeID;
      context[0] = target;
      context[2] = attachmentMode;
      CFDictionaryApplyFunction(theAttachments, (CFDictionaryApplierFunction)figSetOneAttachment, context);
    }
  }
}

uint64_t figSetOneAttachment(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(a3 + 8) + 8))(*(void *)a3, a1, a2, *(unsigned int *)(a3 + 16));
}

void CMPropagateAttachments(CMAttachmentBearerRef source, CMAttachmentBearerRef destination)
{
  CFDictionaryRef v3 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], source, 1u);
  if (v3)
  {
    CFDictionaryRef v4 = v3;
    CMSetAttachments(destination, v3, 1u);
    CFRelease(v4);
  }
}

CFMutableDictionaryRef figAttachmentsMakeAttachmentBearerRegistrationDictionary()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  sFigAttachmentBearerCallbacksPerTypeID = (uint64_t)result;
  if (!result)
  {
    return (CFMutableDictionaryRef)FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void figAttachmentsRegisterInternalBearers()
{
  FigThreadRunOnce(&sFigAttachmentsEnsureAttachmentBearerRegistrationDictionaryOnce, (void (*)(void))figAttachmentsMakeAttachmentBearerRegistrationDictionary);
  FigAttachmentsRegisterBlockBuffer();
  FigAttachmentsRegisterSampleBuffer();

  FigAttachmentsRegisterCVBuffer();
}

CFTypeID CMBlockBufferGetTypeID(void)
{
  return sFigBlockBufferID;
}

void FigAttachmentsRegisterBlockBuffer()
{
  FigThreadRunOnce(&sRegisterFigBlockBufferTypeOnce, (void (*)(void))RegisterFigBlockBufferType);
  int v0 = (const void *)sFigBlockBufferID;

  FigRuntimeRegisterAttachmentBearerWithTypeID(sFigBlockBufferAttachmentBearerCallbacks, v0);
}

OSStatus CMBlockBufferCreateEmpty(CFAllocatorRef structureAllocator, uint32_t subBlockCapacity, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  if (blockBufferOut)
  {
    if (subBlockCapacity + 1 > 2) {
      uint32_t v6 = subBlockCapacity + 1;
    }
    else {
      uint32_t v6 = 2;
    }
    FigThreadRunOnce(&sRegisterFigBlockBufferTypeOnce, (void (*)(void))RegisterFigBlockBufferType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    CFTypeRef v8 = (OpaqueCMBlockBuffer *)Instance;
    if (Instance)
    {
      *(_DWORD *)(Instance + 36) = v6;
      bzero((void *)(Instance + 48), 48 * v6);
      OSStatus result = 0;
    }
    else
    {
      OSStatus result = FigSignalErrorAt(4294954596, 0, 0, 0, 0, 0, 0);
    }
    *blockBufferOut = v8;
  }
  else
  {
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMBlockBufferAppendMemoryBlock(CMBlockBufferRef theBuffer, void *memoryBlock, size_t blockLength, CFAllocatorRef blockAllocator, const CMBlockBufferCustomBlockSource *customBlockSource, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags)
{
  if (!theBuffer)
  {
    uint64_t v12 = 4294954591;
    goto LABEL_11;
  }
  if (!blockLength || !dataLength) {
    goto LABEL_8;
  }
  if (offsetToData >= blockLength)
  {
    uint64_t v12 = 4294954593;
    goto LABEL_11;
  }
  if (dataLength + offsetToData > blockLength || __CFADD__(*((void *)theBuffer + 5), blockLength))
  {
LABEL_8:
    uint64_t v12 = 4294954592;
LABEL_11:
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  char v14 = flags;
  CFAllocatorRef Default = blockAllocator;
  uint64_t v17 = (uint64_t)memoryBlock;
  if (customBlockSource)
  {
    if (customBlockSource->version)
    {
LABEL_16:
      uint64_t v12 = 4294954594;
      goto LABEL_11;
    }
    if (memoryBlock)
    {
      if (!customBlockSource->FreeBlock) {
        goto LABEL_16;
      }
    }
    else if (!customBlockSource->AllocateBlock)
    {
      goto LABEL_16;
    }
    CFAllocatorRef v19 = CFGetAllocator(theBuffer);
    CFAllocatorRef v20 = CFAllocatorAllocate(v19, 28, 0);
    if (!v20)
    {
      uint64_t v12 = 4294954596;
      goto LABEL_11;
    }
    CFIndex v18 = v20;
    long long v21 = *(_OWORD *)&customBlockSource->version;
    *(_OWORD *)((char *)v20 + 12) = *(_OWORD *)&customBlockSource->FreeBlock;
    *CFAllocatorRef v20 = v21;
  }
  else if (blockAllocator)
  {
    CFIndex v18 = 0;
    if (!memoryBlock && (CFAllocatorRef)*MEMORY[0x1E4F1CFA0] == blockAllocator) {
      goto LABEL_20;
    }
  }
  else
  {
    CFAllocatorRef Default = CFAllocatorGetDefault();
    CFIndex v18 = 0;
  }
  if (!v17)
  {
    if ((v14 & 1) == 0)
    {
      uint64_t v17 = 0;
      goto LABEL_31;
    }
    if (v18)
    {
      uint64_t v30 = (*(uint64_t (**)(void, size_t))((char *)v18 + 4))(*(void *)((char *)v18 + 20), blockLength);
      if (v30)
      {
        uint64_t v17 = v30;
        uint64_t v22 = 0;
        uint64_t v23 = v30;
        goto LABEL_32;
      }
      CFAllocatorRef v32 = CFGetAllocator(theBuffer);
      CFAllocatorDeallocate(v32, v18);
    }
    else
    {
      int v31 = CFAllocatorAllocate(Default, blockLength, 0);
      if (v31)
      {
        uint64_t v17 = (uint64_t)v31;
        uint64_t v23 = 0;
        uint64_t v22 = v31;
        goto LABEL_32;
      }
    }
LABEL_20:
    uint64_t v12 = 4294954595;
    goto LABEL_11;
  }
LABEL_31:
  uint64_t v22 = 0;
  uint64_t v23 = 0;
LABEL_32:
  uint64_t v33 = 0;
  OSStatus v24 = NewBufferSubBlock((uint64_t)theBuffer, dataLength, &v33);
  if (v24)
  {
    OSStatus v25 = v24;
    if (v22)
    {
      CFAllocatorDeallocate(Default, v22);
    }
    else if (v23)
    {
      ((void (*)(void *, uint64_t, size_t))customBlockSource->FreeBlock)(customBlockSource->refCon, v23, blockLength);
    }
    if (v18)
    {
      CFAllocatorRef v29 = CFGetAllocator(theBuffer);
      CFAllocatorDeallocate(v29, v18);
    }
  }
  else
  {
    uint64_t v26 = v33;
    *(void *)(v33 + 8) = offsetToData;
    *(void *)(v26 + 24) = v17;
    *(void *)(v26 + 32) = blockLength;
    if (v18)
    {
      OSStatus v25 = 0;
      *(void *)(v26 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v18;
      BOOL v27 = v17 == 0;
      int v28 = 4;
    }
    else
    {
      *(void *)(v26 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = Default;
      CFRetain(Default);
      OSStatus v25 = 0;
      BOOL v27 = v17 == 0;
      int v28 = 2;
    }
    if (!v27) {
      ++v28;
    }
    *(_DWORD *)uint64_t v26 = v28;
  }
  return v25;
}

size_t CMBlockBufferGetDataLength(size_t theBuffer)
{
  if (theBuffer) {
    return *(void *)(theBuffer + 40);
  }
  return theBuffer;
}

OSStatus CMBlockBufferCreateWithMemoryBlock(CFAllocatorRef structureAllocator, void *memoryBlock, size_t blockLength, CFAllocatorRef blockAllocator, const CMBlockBufferCustomBlockSource *customBlockSource, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  if (blockBufferOut)
  {
    CMBlockBufferRef theBuffer = 0;
    OSStatus appended = CMBlockBufferCreateEmpty(structureAllocator, 0, blockLength, &theBuffer);
    uint64_t v17 = theBuffer;
    if (!appended)
    {
      OSStatus appended = CMBlockBufferAppendMemoryBlock(theBuffer, memoryBlock, blockLength, blockAllocator, customBlockSource, offsetToData, dataLength, flags);
      uint64_t v17 = theBuffer;
      if (appended)
      {
        CFRelease(theBuffer);
        uint64_t v17 = 0;
      }
    }
    *blockBufferOut = v17;
    return appended;
  }
  else
  {
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMBlockBufferAppendBufferReference(CMBlockBufferRef theBuffer, CMBlockBufferRef targetBBuf, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags)
{
  if (theBuffer && targetBBuf)
  {
    size_t v5 = *((void *)targetBBuf + 5);
    if (v5)
    {
      if (v5 > offsetToData)
      {
        if (dataLength + offsetToData > v5)
        {
LABEL_15:
          uint64_t v6 = 4294954592;
          goto LABEL_16;
        }
        if (dataLength)
        {
LABEL_13:
          uint64_t v8 = 0;
          if (!__CFADD__(*((void *)theBuffer + 5), dataLength))
          {
            v9[1] = theBuffer;
            int v9[2] = dataLength;
            v9[0] = targetBBuf;
            if (v5 >= dataLength + offsetToData)
            {
              if ((flags & 4) != 0)
              {
LABEL_26:
                return AppendBufferReferenceSubBlock((uint64_t)theBuffer, targetBBuf, offsetToData, dataLength);
              }
              FindDataReference((uint64_t)v9, (uint64_t)targetBBuf, offsetToData, dataLength, &v8);
            }
            else if ((flags & 8) != 0)
            {
              goto LABEL_26;
            }
            return 0;
          }
          goto LABEL_15;
        }
        dataCFIndex Length = v5 - offsetToData;
LABEL_12:
        if (!dataLength)
        {
          uint64_t v6 = 4294954592;
          goto LABEL_16;
        }
        goto LABEL_13;
      }
      uint64_t v6 = 4294954593;
    }
    else
    {
      if ((flags & 8) != 0) {
        goto LABEL_12;
      }
      uint64_t v6 = 4294954590;
    }
  }
  else
  {
    uint64_t v6 = 4294954591;
  }
LABEL_16:

  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

OSStatus CMBlockBufferCreateWithBufferReference(CFAllocatorRef structureAllocator, CMBlockBufferRef bufferReference, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  if (blockBufferOut)
  {
    CMBlockBufferRef blockBufferOuta = 0;
    OSStatus appended = CMBlockBufferCreateEmpty(structureAllocator, 0, offsetToData, &blockBufferOuta);
    uint64_t v13 = blockBufferOuta;
    if (!appended)
    {
      OSStatus appended = CMBlockBufferAppendBufferReference(blockBufferOuta, bufferReference, offsetToData, dataLength, flags);
      uint64_t v13 = blockBufferOuta;
      if (appended)
      {
        CFRelease(blockBufferOuta);
        uint64_t v13 = 0;
      }
    }
    *blockBufferOut = v13;
    return appended;
  }
  else
  {
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  }
}

Boolean CMBlockBufferIsEmpty(CMBlockBufferRef theBuffer)
{
  return !theBuffer || *((_DWORD *)theBuffer + 8) == 0;
}

OSStatus CMBlockBufferGetDataPointer(CMBlockBufferRef theBuffer, size_t offset, size_t *lengthAtOffsetOut, size_t *totalLengthOut, char **dataPointerOut)
{
  CFIndex v18 = 0;
  size_t lengthAtOffsetOuta = 0;
  if (theBuffer)
  {
    uint64_t v9 = *((unsigned int *)theBuffer + 8);
    if ((int)v9 < 1)
    {
LABEL_6:
      OSStatus result = 0;
    }
    else
    {
      size_t v11 = 0;
      uint64_t v12 = (CMBlockBufferRef *)((char *)theBuffer + 72);
      while (1)
      {
        size_t v13 = (size_t)*(v12 - 1) + v11;
        if (v13 > offset) {
          break;
        }
        v12 += 6;
        size_t v11 = v13;
        if (!--v9) {
          goto LABEL_6;
        }
      }
      switch(*((_DWORD *)v12 - 6))
      {
        case 1:
          OSStatus result = CMBlockBufferGetDataPointer(*v12, (size_t)*(v12 - 2) + offset - v11, &lengthAtOffsetOuta, 0, &v18);
          if (!result)
          {
            size_t v17 = (size_t)*(v12 - 1) + v11 - offset;
            if (lengthAtOffsetOuta < v17) {
              size_t v17 = lengthAtOffsetOuta;
            }
            size_t lengthAtOffsetOuta = v17;
          }
          break;
        case 2:
        case 4:
          OSStatus result = -12707;
          break;
        case 3:
        case 5:
          OSStatus result = 0;
          size_t lengthAtOffsetOuta = v13 - offset;
          CFIndex v18 = (char *)*(v12 - 2) + (void)*v12 + offset - v11;
          break;
        default:
          goto LABEL_6;
      }
    }
    BOOL v15 = v18;
    if (v18) {
      BOOL v16 = 0;
    }
    else {
      BOOL v16 = result == 0;
    }
    if (v16) {
      OSStatus result = -12703;
    }
    if (lengthAtOffsetOut) {
      *lengthAtOffsetOut = lengthAtOffsetOuta;
    }
    if (totalLengthOut) {
      *totalLengthOut = *((void *)theBuffer + 5);
    }
    if (dataPointerOut) {
      *dataPointerOut = v15;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigBlockBufferGetDataPointerAndOrigin(uint64_t a1, unint64_t a2, unint64_t *a3, void *a4, unint64_t *a5, void *a6, unint64_t *a7)
{
  unint64_t v22 = 0;
  unint64_t v23 = 0;
  if (a1 && a6 && a7)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 32);
    if ((int)v11 < 1)
    {
LABEL_8:
      LODWORD(result) = 0;
    }
    else
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      uint64_t v15 = 48 * v11;
      while (1)
      {
        uint64_t v16 = a1 + v13;
        unint64_t v17 = *(void *)(a1 + v13 + 64) + v14;
        if (v17 > a2) {
          break;
        }
        v13 += 48;
        unint64_t v14 = v17;
        if (v15 == v13) {
          goto LABEL_8;
        }
      }
      switch(*(_DWORD *)(v16 + 48))
      {
        case 1:
          LODWORD(result) = FigBlockBufferGetDataPointerAndOrigin(*(void *)(a1 + v13 + 72), a2 - v14 + *(void *)(a1 + v13 + 56), &v23, 0, &v22);
          if (!result)
          {
            unint64_t v21 = v14 - a2 + *(void *)(v16 + 64);
            if (v23 < v21) {
              unint64_t v21 = v23;
            }
            unint64_t v23 = v21;
          }
          break;
        case 2:
        case 4:
          LODWORD(result) = -12707;
          break;
        case 3:
        case 5:
          LODWORD(result) = 0;
          *a6 = a1;
          *a7 = a2;
          unint64_t v22 = *(void *)(a1 + v13 + 72) + *(void *)(a1 + v13 + 56) + a2 - v14;
          unint64_t v23 = v17 - a2;
          break;
        default:
          goto LABEL_8;
      }
    }
    unint64_t v19 = v22;
    if (v22) {
      BOOL v20 = 0;
    }
    else {
      BOOL v20 = result == 0;
    }
    if (v20) {
      uint64_t result = 4294954593;
    }
    else {
      uint64_t result = result;
    }
    if (a3) {
      *a3 = v23;
    }
    if (a4) {
      *a4 = *(void *)(a1 + 40);
    }
    if (a5) {
      *a5 = v19;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMBlockBufferCopyDataBytes(CMBlockBufferRef theSourceBuffer, size_t offsetToData, size_t dataLength, void *destination)
{
  uint64_t v5 = 4294954591;
  if (!theSourceBuffer) {
    goto LABEL_22;
  }
  uint64_t v6 = (char *)destination;
  if (!destination) {
    goto LABEL_22;
  }
  size_t v7 = dataLength;
  if (!dataLength)
  {
    uint64_t v5 = 4294954592;
LABEL_22:
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  size_t v8 = *((void *)theSourceBuffer + 5);
  if (!v8)
  {
    uint64_t v5 = 4294954590;
    goto LABEL_22;
  }
  size_t v9 = offsetToData;
  if (v8 <= offsetToData)
  {
    uint64_t v5 = 4294954593;
    goto LABEL_22;
  }
  BOOL v10 = __CFADD__(dataLength, offsetToData);
  uint64_t v5 = 4294954592;
  if (dataLength + offsetToData > v8 || v10) {
    goto LABEL_22;
  }
  uint64_t v13 = 0;
  size_t lengthAtOffsetOut = 0;
  while (1)
  {
    OSStatus result = CMBlockBufferGetDataPointer(theSourceBuffer, v9, &lengthAtOffsetOut, 0, &v13);
    if (result) {
      break;
    }
    if (v7 >= lengthAtOffsetOut) {
      size_t v12 = lengthAtOffsetOut;
    }
    else {
      size_t v12 = v7;
    }
    memcpy(v6, v13, v12);
    v9 += v12;
    v6 += v12;
    v7 -= v12;
    if (!v7) {
      return 0;
    }
  }
  return result;
}

OSStatus CMBlockBufferReplaceDataBytes(const void *sourceBytes, CMBlockBufferRef destinationBuffer, size_t offsetIntoDestination, size_t dataLength)
{
  uint64_t v5 = 4294954591;
  if (!sourceBytes || !destinationBuffer)
  {
LABEL_10:
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  size_t v7 = dataLength;
  if (!dataLength) {
    goto LABEL_7;
  }
  size_t v8 = *((void *)destinationBuffer + 5);
  if (!v8)
  {
    uint64_t v5 = 4294954590;
    goto LABEL_10;
  }
  size_t v9 = offsetIntoDestination;
  if (v8 <= offsetIntoDestination)
  {
    uint64_t v5 = 4294954593;
    goto LABEL_10;
  }
  if (dataLength + offsetIntoDestination > v8)
  {
LABEL_7:
    uint64_t v5 = 4294954592;
    goto LABEL_10;
  }
  size_t v12 = 0;
  size_t lengthAtOffsetOut = 0;
  while (1)
  {
    OSStatus result = CMBlockBufferGetDataPointer(destinationBuffer, v9, &lengthAtOffsetOut, 0, &v12);
    if (result == -12707)
    {
      OSStatus result = CMBlockBufferAssureBlockMemory(destinationBuffer);
      if (result) {
        return result;
      }
      OSStatus result = CMBlockBufferGetDataPointer(destinationBuffer, v9, &lengthAtOffsetOut, 0, &v12);
    }
    if (result) {
      break;
    }
    if (v7 >= lengthAtOffsetOut) {
      size_t v11 = lengthAtOffsetOut;
    }
    else {
      size_t v11 = v7;
    }
    memcpy(v12, sourceBytes, v11);
    v9 += v11;
    sourceBytes = (char *)sourceBytes + v11;
    v7 -= v11;
    if (!v7) {
      return 0;
    }
  }
  return result;
}

OSStatus CMBlockBufferAssureBlockMemory(CMBlockBufferRef theBuffer)
{
  if (!theBuffer)
  {
    uint64_t v11 = 4294954591;
LABEL_22:
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  int v2 = *((_DWORD *)theBuffer + 8);
  if (!v2)
  {
    uint64_t v11 = 4294954590;
    goto LABEL_22;
  }
  if (v2 >= 1)
  {
    CFDictionaryRef v3 = (CFAllocatorRef *)((char *)theBuffer + 88);
    uint64_t v4 = 1;
    while (1)
    {
      int v5 = *((_DWORD *)v3 - 10);
      switch(v5)
      {
        case 4:
          uint64_t v7 = (*(uint64_t (**)(void, void))((char *)*v3 + 4))(*(void *)((char *)*v3 + 20), *(v3 - 1));
          *(v3 - 2) = (CFAllocatorRef)v7;
          if (!v7) {
            goto LABEL_14;
          }
          OSStatus result = 0;
          *((_DWORD *)v3 - 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 5;
          break;
        case 2:
          CFAllocatorRef v8 = (const __CFAllocator *)CFAllocatorAllocate(*v3, (CFIndex)*(v3 - 1), 0);
          *(v3 - 2) = v8;
          if (!v8)
          {
LABEL_14:
            OSStatus result = FigSignalErrorAt(4294954595, 0, 0, 0, 0, 0, 0);
            break;
          }
          OSStatus result = 0;
          *((_DWORD *)v3 - 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 3;
          break;
        case 1:
          OSStatus result = CMBlockBufferAssureBlockMemory(*(v3 - 2));
          break;
        default:
          OSStatus result = 0;
          break;
      }
      v3 += 6;
      if (v4++ >= *((int *)theBuffer + 8) || result != 0) {
        return result;
      }
    }
  }
  return 0;
}

OSStatus CMBlockBufferFillDataBytes(char fillByte, CMBlockBufferRef destinationBuffer, size_t offsetIntoDestination, size_t dataLength)
{
  if (!destinationBuffer)
  {
    uint64_t v7 = 4294954591;
    goto LABEL_10;
  }
  if ((dataLength & 0x8000000000000000) != 0) {
    goto LABEL_6;
  }
  size_t v5 = *((void *)destinationBuffer + 5);
  if (!v5)
  {
    uint64_t v7 = 4294954590;
    goto LABEL_10;
  }
  size_t v6 = offsetIntoDestination;
  if (v5 <= offsetIntoDestination)
  {
    uint64_t v7 = 4294954593;
    goto LABEL_10;
  }
  if (dataLength + offsetIntoDestination > v5)
  {
LABEL_6:
    uint64_t v7 = 4294954592;
LABEL_10:
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  int v9 = fillByte;
  size_t v12 = 0;
  size_t lengthAtOffsetOut = 0;
  if (dataLength) {
    size_t v10 = dataLength;
  }
  else {
    size_t v10 = v5 - offsetIntoDestination;
  }
  while (1)
  {
    OSStatus result = CMBlockBufferGetDataPointer(destinationBuffer, v6, &lengthAtOffsetOut, 0, &v12);
    if (result == -12707)
    {
      OSStatus result = CMBlockBufferAssureBlockMemory(destinationBuffer);
      if (result) {
        return result;
      }
      OSStatus result = CMBlockBufferGetDataPointer(destinationBuffer, v6, &lengthAtOffsetOut, 0, &v12);
    }
    if (result) {
      break;
    }
    if (v10 >= lengthAtOffsetOut) {
      size_t v11 = lengthAtOffsetOut;
    }
    else {
      size_t v11 = v10;
    }
    memset(v12, v9, v11);
    v6 += v11;
    v10 -= v11;
    if (!v10) {
      return 0;
    }
  }
  return result;
}

OSStatus CMBlockBufferAccessDataBytes(CMBlockBufferRef theBuffer, size_t offset, size_t length, void *temporaryBlock, char **returnedPointerOut)
{
  if (theBuffer && temporaryBlock && returnedPointerOut)
  {
    if (length)
    {
      unint64_t v19 = 0;
      size_t lengthAtOffsetOut = 0;
      OSStatus result = CMBlockBufferGetDataPointer(theBuffer, offset, &lengthAtOffsetOut, 0, &v19);
      if (result)
      {
        size_t v11 = 0;
      }
      else
      {
        size_t v11 = v19;
        size_t v13 = lengthAtOffsetOut;
        size_t v14 = length - lengthAtOffsetOut;
        if (length <= lengthAtOffsetOut)
        {
          OSStatus result = 0;
        }
        else
        {
          memcpy(temporaryBlock, v19, lengthAtOffsetOut);
          size_t v15 = v13 + offset;
          uint64_t v16 = (char *)temporaryBlock + v13;
          do
          {
            OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, v15, &lengthAtOffsetOut, 0, &v19);
            if (DataPointer) {
              break;
            }
            size_t v18 = v14 >= lengthAtOffsetOut ? lengthAtOffsetOut : v14;
            memcpy(v16, v19, v18);
            v15 += v18;
            v16 += v18;
            v14 -= v18;
          }
          while (v14);
          if (v14) {
            OSStatus result = -12704;
          }
          else {
            OSStatus result = DataPointer;
          }
          if (v14) {
            size_t v11 = 0;
          }
          else {
            size_t v11 = (char *)temporaryBlock;
          }
        }
      }
      *returnedPointerOut = v11;
      return result;
    }
    uint64_t v12 = 4294954592;
  }
  else
  {
    uint64_t v12 = 4294954591;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

OSStatus CMBlockBufferCreateContiguous(CFAllocatorRef structureAllocator, CMBlockBufferRef sourceBuffer, CFAllocatorRef blockAllocator, const CMBlockBufferCustomBlockSource *customBlockSource, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  if (!sourceBuffer || !blockBufferOut)
  {
    uint64_t v12 = 4294954591;
    goto LABEL_10;
  }
  if (!*((_DWORD *)sourceBuffer + 8))
  {
    uint64_t v12 = 4294954590;
    goto LABEL_10;
  }
  size_t v11 = *((void *)sourceBuffer + 5);
  if (v11 <= offsetToData)
  {
    uint64_t v12 = 4294954593;
    goto LABEL_10;
  }
  if (dataLength + offsetToData > v11)
  {
    uint64_t v12 = 4294954592;
LABEL_10:
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  CMBlockBufferRef theBuffer = 0;
  if (dataLength) {
    size_t v18 = dataLength;
  }
  else {
    size_t v18 = v11 - offsetToData;
  }
  if ((flags & 2) == 0)
  {
    size_t lengthAtOffsetOut = 0;
    if (!CMBlockBufferGetDataPointer(sourceBuffer, offsetToData, &lengthAtOffsetOut, 0, 0)
      && lengthAtOffsetOut >= v18)
    {
      return CMBlockBufferCreateWithBufferReference(structureAllocator, sourceBuffer, offsetToData, v18, flags, blockBufferOut);
    }
  }
  OSStatus v19 = CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, v18, blockAllocator, customBlockSource, 0, v18, flags | 1, &theBuffer);
  BOOL v20 = theBuffer;
  if (!v19)
  {
    size_t lengthAtOffsetOut = 0;
    CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, (char **)&lengthAtOffsetOut);
    OSStatus v19 = CMBlockBufferCopyDataBytes(sourceBuffer, offsetToData, v18, (void *)lengthAtOffsetOut);
    BOOL v20 = theBuffer;
    if (v19)
    {
      CFRelease(theBuffer);
      BOOL v20 = 0;
    }
  }
  *blockBufferOut = v20;
  return v19;
}

Boolean CMBlockBufferIsRangeContiguous(CMBlockBufferRef theBuffer, size_t offset, size_t length)
{
  if (!theBuffer)
  {
    FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  size_t v4 = *((void *)theBuffer + 5);
  size_t v5 = v4 - offset;
  if (v4 <= offset || length + offset > v4) {
    return 0;
  }
  size_t lengthAtOffsetOut = 0;
  if (CMBlockBufferGetDataPointer(theBuffer, offset, &lengthAtOffsetOut, 0, 0)) {
    return 0;
  }
  if (length) {
    size_t v7 = length;
  }
  else {
    size_t v7 = v5;
  }
  return lengthAtOffsetOut >= v7;
}

CFStringRef BBufCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[CMBlockBuffer %p]", a1);
}

__CFString *BBufCopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  AppendBBufDescription(Mutable, a1, 0, 0);
  return Mutable;
}

void AppendBBufDescription(__CFString *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (4 * a3);
  if (!a4)
  {
    uint64_t v9 = *(void *)(a2 + 40);
    CFIndex v10 = CFGetRetainCount((CFTypeRef)a2);
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a2);
    CFStringAppendFormat(a1, 0, @"%*sCMBlockBuffer %p totalDataLength: %ld retainCount: %ld allocator: %p subBlockCapacity: %d\n", v8, "", a2, v9, v10, v11, *(unsigned int *)(a2 + 36));
    uint64_t v12 = 0;
    char v13 = 1;
    do
    {
      char v14 = v13;
      CFDictionaryRef v15 = *(const __CFDictionary **)(a2 + 8 * v12 + 16);
      if (v15)
      {
        context = a1;
        int v30 = a3;
        int v31 = v12;
        CFDictionaryApplyFunction(v15, (CFDictionaryApplierFunction)DescribeBBufAnnotation, &context);
      }
      char v13 = 0;
      uint64_t v12 = 1;
    }
    while ((v14 & 1) != 0);
  }
  if (*(int *)(a2 + 32) >= 1)
  {
    uint64_t v16 = 0;
    unint64_t v17 = (unsigned int **)(a2 + 88);
    do
    {
      uint64_t v18 = (*(_DWORD *)(a2 + 36) - 1);
      if (v16 == v18)
      {
        uint64_t v19 = (uint64_t)*(v17 - 2);
        BOOL v20 = a1;
        uint64_t v21 = a3;
        uint64_t v22 = (a4 + 1);
LABEL_10:
        AppendBBufDescription(v20, v19, v21, v22);
      }
      else
      {
        CFStringAppendFormat(a1, 0, @"%*s [%d] ", v8, "", v16 + (v18 * a4));
        CFStringAppendFormat(a1, 0, @"%ld bytes @ offset %ld ", *(v17 - 3), *(v17 - 4));
        switch(*((_DWORD *)v17 - 10))
        {
          case 0:
            unint64_t v23 = a1;
            CFStringRef v24 = @"UNUSED!!!\n";
            goto LABEL_14;
          case 1:
            CFStringAppend(a1, @"Buffer Reference:\n");
            uint64_t v19 = (uint64_t)*(v17 - 2);
            BOOL v20 = a1;
            uint64_t v21 = (a3 + 1);
            uint64_t v22 = 0;
            goto LABEL_10;
          case 2:
            CFStringAppendFormat(a1, 0, @"Memory UNALLOCATED, %ld bytes (allocator %p)\n", *(v17 - 1), *v17, v25, v26, v27, v28);
            break;
          case 3:
            CFStringAppendFormat(a1, 0, @"Memory Block %p, %ld bytes (allocator %p)\n", *(v17 - 2), *(v17 - 1), *v17, v26, v27, v28);
            break;
          case 4:
            CFStringAppendFormat(a1, 0, @"Memory UNALLOCATED, %ld bytes (custom V=%d A=%p F=%p R=%p)\n", *(v17 - 1), **v17, *(void *)(*v17 + 1), *(void *)(*v17 + 3), *(void *)(*v17 + 5), v28);
            break;
          case 5:
            CFStringAppendFormat(a1, 0, @"Memory Block %p, %ld bytes (custom V=%d A=%p F=%p R=%p)\n", *(v17 - 2), *(v17 - 1), **v17, *(void *)(*v17 + 1), *(void *)(*v17 + 3), *(void *)(*v17 + 5));
            break;
          default:
            unint64_t v23 = a1;
            CFStringRef v24 = @"UNKNOWN STATE!!!\n";
LABEL_14:
            CFStringAppend(v23, v24);
            break;
        }
      }
      ++v16;
      v17 += 6;
    }
    while (v16 < *(int *)(a2 + 32));
  }
}

void DescribeBBufAnnotation(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v19 = 0;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v7 = 0u;
  *(_DWORD *)buffer = 1061109567;
  CFStringGetCString(a1, buffer, 200, 0x8000100u);
  if (*(_DWORD *)(a3 + 12) == 1) {
    size_t v5 = "(P)";
  }
  else {
    size_t v5 = "   ";
  }
  CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, @"%*s %-10s%s = %@\n", (4 * *(_DWORD *)(a3 + 8)), "", buffer, v5, a2);
}

void BBufSetAttachment(char *cf, void *key, void *value, int a4)
{
  int v7 = 1 - a4;
  long long v8 = &cf[8 * a4];
  long long v11 = (__CFDictionary *)*((void *)v8 + 2);
  long long v10 = (__CFDictionary **)(v8 + 16);
  CFMutableDictionaryRef Mutable = v11;
  if (v11
    || (CFAllocatorRef v12 = CFGetAllocator(cf),
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]),
        (*long long v10 = Mutable) != 0))
  {
    if (value) {
      CFDictionarySetValue(Mutable, key, value);
    }
    else {
      CFDictionaryRemoveValue(Mutable, key);
    }
  }
  long long v13 = *(__CFDictionary **)&cf[8 * v7 + 16];
  if (v13)
  {
    CFDictionaryRemoveValue(v13, key);
  }
}

const void *BBufGetAttachment(uint64_t a1, void *key, _DWORD *a3)
{
  uint64_t v6 = 0;
  for (char i = 1; ; char i = 0)
  {
    char v8 = i;
    CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 8 * v6 + 16);
    if (v9)
    {
      OSStatus result = CFDictionaryGetValue(v9, key);
      if (result) {
        break;
      }
    }
    uint64_t v6 = 1;
    if ((v8 & 1) == 0) {
      return 0;
    }
  }
  if (a3) {
    *a3 = v6;
  }
  return result;
}

void BBufRemoveAttachment(uint64_t a1, void *key)
{
  uint64_t v4 = 0;
  char v5 = 1;
  do
  {
    char v6 = v5;
    int v7 = *(__CFDictionary **)(a1 + 8 * v4 + 16);
    if (v7) {
      CFDictionaryRemoveValue(v7, key);
    }
    char v5 = 0;
    uint64_t v4 = 1;
  }
  while ((v6 & 1) != 0);
}

void BBufRemoveAllAttachments(uint64_t a1)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = a1 + 8 * v2;
    char v8 = *(const void **)(v5 + 16);
    int v7 = (void *)(v5 + 16);
    char v6 = v8;
    if (v8)
    {
      CFRelease(v6);
      *int v7 = 0;
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
}

CFDictionaryRef BBufCopyDictionaryOfAttachments(const __CFAllocator *a1, uint64_t a2, unsigned int a3)
{
  CFDictionaryRef v3 = *(const __CFDictionary **)(a2 + 8 * a3 + 16);
  if (v3) {
    return CFDictionaryCreateCopy(a1, v3);
  }
  else {
    return 0;
  }
}

uint64_t FigCaptionTextOutlineGetTypeID()
{
  return sFigCaptionTextOutlineID;
}

uint64_t RegisterFigCaptionTextOutlineType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionTextOutlineID = result;
  return result;
}

uint64_t FigCaptionTextOutlineGetColor(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t FigCaptionTextOutlineGetThickness(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t FigCaptionTextOutlineCreate(uint64_t a1, uint64_t a2, uint64_t a3, CGColor *a4, void *a5)
{
  if (a5)
  {
    FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      long long v11 = (void *)Instance;
      CGColorRef v12 = CGColorRetain(a4);
      v11[3] = a3;
      v11[4] = v12;
      v11[2] = a2;
      *a5 = v11;
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionTextOutlineCreateNone(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      *(void *)(Instance + 32) = 0;
      *(_OWORD *)(Instance + 16) = kFigGeometryDimensionZero;
      *a2 = Instance;
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

void *fcto_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void fcto_Finalize(uint64_t a1)
{
}

BOOL fcto_Equal(BOOL result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
    uint64_t result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextOutlineID)
      {
        CFTypeID v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
        if (v5 == sFigCaptionTextOutlineID)
        {
          uint64_t result = CGColorEqualToColor(*(CGColorRef *)(v3 + 32), *(CGColorRef *)(a2 + 32));
          if (result) {
            return FigGeometryDimensionEqualToDimension(*(void *)(v3 + 16), *(void *)(v3 + 24), *(void *)(a2 + 16), *(void *)(a2 + 24));
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fcto_Hash(void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
  if (v2 != sFigCaptionTextOutlineID) {
    return 0;
  }
  uint64_t v3 = (const void *)a1[4];

  return CFHash(v3);
}

CFStringRef fcto_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextOutline %p]", a1);
}

CFStringRef fcto_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextOutline %p]", a1);
}

uint64_t FigVirtualCaptureCardCreate(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v8 = 0;
  CFDictionaryRef v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigVirtualCaptureCardCreate_block_invoke;
  block[3] = &unk_1E5676308;
  block[4] = &v8;
  void block[5] = a1;
  void block[6] = a2;
  if (FigVirtualCaptureCardCreate_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce != -1) {
    dispatch_once(&FigVirtualCaptureCardCreate_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce, block);
  }
  CFTypeRef v4 = (CFTypeRef)FigVirtualCaptureCardCreate_sVirtualCaptureCardSingleton;
  if (FigVirtualCaptureCardCreate_sVirtualCaptureCardSingleton) {
    CFTypeRef v4 = CFRetain((CFTypeRef)FigVirtualCaptureCardCreate_sVirtualCaptureCardSingleton);
  }
  *a3 = v4;
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t __FigVirtualCaptureCardCreate_block_invoke(uint64_t a1)
{
  FigVirtualCaptureCardInitializeFilesystemPaths();
  uint64_t result = FigVirtualCaptureCardCreateInternal(*(void *)(a1 + 40), &FigVirtualCaptureCardCreate_sVirtualCaptureCardSingleton);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t FigVirtualCaptureCardCreateInternal(uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  sVCCEnableCrashRecovery = 1;
  if (!a2) {
    goto LABEL_27;
  }
  ClassID = (void *)FigVirtualCaptureCardGetClassID();
  uint64_t v5 = CMDerivedObjectCreate(a1, (uint64_t)&kFigVirtualCaptureCardVTable, ClassID, &cf);
  if (v5)
  {
LABEL_28:
    uint64_t FileInfo = v5;
    goto LABEL_13;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  if (!DerivedStorage)
  {
LABEL_27:
    uint64_t v5 = FigSignalErrorAt(4294950086, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  int v7 = (void *)DerivedStorage;
  uint64_t v8 = FigSimpleMutexCreate();
  *int v7 = v8;
  if (!v8)
  {
    uint64_t FileInfo = 0;
    CFTypeRef v15 = cf;
LABEL_17:
    *a2 = v15;
    return FileInfo;
  }
  CFURLRef v9 = (const __CFURL *)sVCCPreallocationFile;
  v7[2] = sVCCPreallocationFile;
  v7[3] = 0;
  v7[1] = vcc_StatFileCapacity(v9);
  CFTypeRef v10 = cf;
  uint64_t v11 = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  if (*(void *)(v11 + 24))
  {
    CFURLRef v13 = 0;
    uint64_t FileInfo = 4294950080;
    goto LABEL_9;
  }
  uint64_t v12 = v11;
  memset(&v23, 0, sizeof(v23));
  if (lstat(sVCCPreallocationSaveToSymlinkCString, &v23)) {
    goto LABEL_7;
  }
  ssize_t v17 = readlink(sVCCPreallocationSaveToSymlinkCString, (char *)&v23, 0x400uLL);
  if ((unint64_t)(v17 - 1024) < 0xFFFFFFFFFFFFFC01)
  {
    CFURLRef v13 = 0;
    uint64_t FileInfo = 4294950078;
    goto LABEL_9;
  }
  CFIndex v18 = v17;
  *((unsigned char *)&v23.st_dev + v17) = 0;
  if (!FigFileDoesFileExist(*(const __CFURL **)(v12 + 16))) {
    goto LABEL_7;
  }
  *(void *)(v12 + 8) = vcc_StatFileCapacity(*(const __CFURL **)(v12 + 16));
  memset(&v22, 0, 40);
  uint64_t FileInfo = FigFileGetFileInfo(*(const __CFURL **)(v12 + 16), (uint64_t)&v22);
  if (FileInfo)
  {
    CFURLRef v13 = 0;
    goto LABEL_9;
  }
  if (*(uint64_t *)&v22.st_dev <= 0)
  {
LABEL_7:
    CFURLRef v13 = 0;
  }
  else
  {
    CFURLRef v13 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)&v23, v18, 0);
    if (FigFileDoesFileExist(v13)) {
      goto LABEL_9;
    }
    if (v13)
    {
      *(void *)(v12 + 24) = v13;
      CFRetain(v13);
      uint64_t v19 = FigVirtualCaptureCard_SaveCapture((uint64_t)v10);
      if (v19)
      {
        CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to recover preallocated file data %@ due to FigVirtualCaptureCard_SaveCapture err: %d", v10, v19);
        uint64_t FileInfo = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
        CFRelease(v20);
        goto LABEL_9;
      }
    }
  }
  uint64_t FileInfo = 0;
LABEL_9:
  memset(&v22, 0, sizeof(v22));
  if (!lstat(sVCCPreallocationSaveToSymlinkCString, &v22)) {
    uint64_t FileInfo = FigFileDeleteFile((const __CFURL *)sVCCPreallocationSaveToSymlink);
  }
  if (v13) {
    CFRelease(v13);
  }
LABEL_13:
  CFTypeRef v15 = cf;
  if (FileInfo && cf)
  {
    CFRelease(cf);
    CFTypeRef v15 = 0;
  }
  if (a2) {
    goto LABEL_17;
  }
  return FileInfo;
}

uint64_t FigVirtualCaptureCardGetSingleton(uint64_t a1, void *a2)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = 0;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __FigVirtualCaptureCardGetSingleton_block_invoke;
  v5[3] = &unk_1E5676330;
  v5[4] = &v6;
  v5[5] = a1;
  if (FigVirtualCaptureCardGetSingleton_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce != -1) {
    dispatch_once(&FigVirtualCaptureCardGetSingleton_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce, v5);
  }
  *a2 = FigVirtualCaptureCardGetSingleton_sVirtualCaptureCardSingleton;
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t __FigVirtualCaptureCardGetSingleton_block_invoke(uint64_t a1)
{
  FigVirtualCaptureCardInitializeFilesystemPaths();
  uint64_t result = FigVirtualCaptureCardCreateInternal(0, &FigVirtualCaptureCardGetSingleton_sVirtualCaptureCardSingleton);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

CFTypeRef FigVirtualCaptureCardInitializeFilesystemPaths()
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  memset(&v14, 0, sizeof(v14));
  CFURLRef v13 = 0;
  uid_t v0 = getuid();
  if (getpwuid_r(v0, &v14, v15, 0x400uLL, &v13) || !v13)
  {
    CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to get user home dir with getpwuid_r()");
    goto LABEL_8;
  }
  if (!v14.pw_dir)
  {
LABEL_10:
    CFURLRef v5 = CFURLCreateWithString(0, @"/var/mobile/Library/VirtualCaptureCard", 0);
    goto LABEL_11;
  }
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v14.pw_dir, 0x600u);
  if (!v2)
  {
    CFStringRef v6 = CFStringCreateWithFormat(v1, 0, @"Failed to create user homedir from string %s", v14.pw_dir);
LABEL_8:
    CFStringRef v7 = v6;
    int v8 = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
    CFRelease(v7);
    if (v8)
    {
      CFStringRef v9 = CFStringCreateWithFormat(v1, 0, @"Unable to get storage directory", v12);
LABEL_13:
      CFStringRef v10 = v9;
      FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
      CFRelease(v10);
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  CFStringRef v3 = v2;
  CFURLRef v4 = CFURLCreateWithString(0, v2, 0);
  CFRelease(v3);
  CFURLRef v5 = CFURLCreateWithString(0, @"/var/mobile/Library/VirtualCaptureCard", 0);
  if (v4) {
    CFRelease(v4);
  }
LABEL_11:
  if (FigCFURLCreateDirectory(v5))
  {
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to create preallocation directory at path %@", v5);
    goto LABEL_13;
  }
  sVCCPreallocationFile = (uint64_t)CFURLCreateWithString(0, @"/var/mobile/Library/VirtualCaptureCard/43D8CBBD-2797-497D-8CAC-93D1952C83AE.virtual_capture_card", 0);
  sVCCPreallocationSaveToSymlink = (uint64_t)CFURLCreateWithString(0, @"/var/mobile/Library/VirtualCaptureCard/43D8CBBD-2797-497D-8CAC-93D1952C83AE.virtual_capture_card_target", 0);
  if (v5) {
    CFRelease(v5);
  }
  if (!CFURLGetFileSystemRepresentation((CFURLRef)sVCCPreallocationFile, 1u, sVCCPreallocationFileCString, 1024))
  {
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Preallocation file path %@ is invalid", sVCCPreallocationFile);
    goto LABEL_13;
  }
  if (!CFURLGetFileSystemRepresentation((CFURLRef)sVCCPreallocationSaveToSymlink, 1u, (UInt8 *)sVCCPreallocationSaveToSymlinkCString, 1024))
  {
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Preallocation target file path %@ is invalid", sVCCPreallocationSaveToSymlink);
    goto LABEL_13;
  }
LABEL_14:
  if (sVCCPreallocationFile) {
    CFRetain((CFTypeRef)sVCCPreallocationFile);
  }
  CFTypeRef result = (CFTypeRef)sVCCPreallocationSaveToSymlink;
  if (sVCCPreallocationSaveToSymlink) {
    return CFRetain((CFTypeRef)sVCCPreallocationSaveToSymlink);
  }
  return result;
}

blkcnt_t vcc_StatFileCapacity(const __CFURL *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024)) {
    return 0;
  }
  memset(&v2, 0, sizeof(v2));
  if (stat((const char *)buffer, &v2) == -1) {
    return 0;
  }
  else {
    return v2.st_blocks << 9;
  }
}

CFAllocatorRef FigVirtualCaptureCard_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  stat v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(DerivedStorage + 16) = 0;
  }
  CFStringRef v3 = *(const void **)(DerivedStorage + 24);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(DerivedStorage + 24) = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  CFAllocatorRef result = FigSimpleMutexDestroy(*(void *)DerivedStorage);
  *(void *)uint64_t DerivedStorage = 0;
  return result;
}

__CFString *FigVirtualCaptureCard_CopyDebugDescription(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (!CFURLGetFileSystemRepresentation(*(CFURLRef *)(DerivedStorage + 24), 1u, buffer, 1024)) {
    strcpy((char *)buffer, "N/A");
  }
  CFStringAppendFormat(Mutable, 0, @"<FigFigVirtualCaptureCard %p> capacity: %lld, preallocatedFileURLh %@, saveToFileURL: %s", a1, *(void *)(DerivedStorage + 8), *(void *)(DerivedStorage + 16), buffer);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return Mutable;
}

uint64_t FigVirtualCaptureCard_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!a2)
  {
LABEL_18:
    uint64_t v14 = 4294950085;
LABEL_19:
    uint64_t v12 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }
  if (!a4)
  {
    uint64_t v14 = 4294950086;
    goto LABEL_19;
  }
  *a4 = 0;
  if (!CFEqual(a2, @"FigVirtualCaptureCardProperty_Capacity"))
  {
    if (CFEqual(a2, @"FigVirtualCaptureCardProperty_FreeSpace"))
    {
      uint64_t v8 = *(void *)(DerivedStorage + 8);
      CFURLRef v7 = *(const __CFURL **)(DerivedStorage + 16);
      if (FigFileDoesFileExist(v7))
      {
        uint64_t v16 = 0;
        memset(v15, 0, sizeof(v15));
        int FileInfo = FigFileGetFileInfo(v7, (uint64_t)v15);
        uint64_t v10 = 0;
        if (v8 >= 1 && !FileInfo) {
          uint64_t v10 = (v8 - *(void *)&v15[0]) & ~((v8 - *(void *)&v15[0]) >> 63);
        }
      }
      else
      {
        uint64_t v10 = 0;
      }
      *(void *)&v15[0] = v10;
      goto LABEL_15;
    }
    if (CFEqual(a2, @"FigVirtualCaptureCardProperty_PreallocatedStorageFileURL"))
    {
      uint64_t v11 = *(const void **)(DerivedStorage + 16);
      if (v11) {
        uint64_t v11 = CFRetain(v11);
      }
      goto LABEL_16;
    }
    goto LABEL_18;
  }
  *(void *)&v15[0] = vcc_StatFileCapacity(*(const __CFURL **)(DerivedStorage + 16));
LABEL_15:
  uint64_t v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, v15);
LABEL_16:
  uint64_t v12 = 0;
  *a4 = v11;
LABEL_17:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v12;
}

uint64_t FigVirtualCaptureCard_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!a2 || !a3) {
    goto LABEL_10;
  }
  if (!CFEqual(a2, @"FigVirtualCaptureCardProperty_Capacity"))
  {
    uint64_t v10 = 4294950085;
LABEL_8:
    uint64_t v9 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  CFTypeID v7 = CFGetTypeID(a3);
  if (v7 != CFNumberGetTypeID())
  {
LABEL_10:
    uint64_t v10 = 4294950086;
    goto LABEL_8;
  }
  CFNumberRef SInt64 = FigCFNumberGetSInt64((const __CFNumber *)a3);
  if (vcc_FigVirtualCaptureCardPreallocateCapacity(a1, (uint64_t)SInt64))
  {
    uint64_t v10 = 4294950082;
    goto LABEL_8;
  }
  uint64_t v9 = 0;
  *(void *)(DerivedStorage + 8) = SInt64;
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v9;
}

uint64_t vcc_FigVirtualCaptureCardPreallocateCapacity(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  CFURLRef v4 = *(const __CFURL **)(DerivedStorage + 16);
  if (!v4)
  {
    uint64_t v16 = 4294950082;
LABEL_24:
    uint64_t v5 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  if (*(void *)(DerivedStorage + 24))
  {
    uint64_t v16 = 4294950080;
    goto LABEL_24;
  }
  if (!a2)
  {
    uint64_t v10 = APFSCaptureDeletePreallocFile();
    if (!v10)
    {
      blkcnt_t v14 = 0;
      uint64_t v5 = 0;
      goto LABEL_20;
    }
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"APFSCaptureDeletePreallocFile failed for : path %@, err %d", *(void *)(DerivedStorage + 16), v10);
    goto LABEL_17;
  }
  if (!FigFileDoesFileExist(v4))
  {
LABEL_15:
    uint64_t PreallocFile = APFSCaptureCreatePreallocFile();
    if (PreallocFile)
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"APFSCaptureCreatePreallocFile failed: path %@, err %d, capacity %lld", *(void *)(DerivedStorage + 16), PreallocFile, a2);
      goto LABEL_17;
    }
LABEL_18:
    uint64_t v5 = 0;
    goto LABEL_19;
  }
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v5 = 4294950082;
  if (FigFileGetFileInfo(*(const __CFURL **)(DerivedStorage + 16), (uint64_t)v17) || *(void *)&v17[0]) {
    goto LABEL_19;
  }
  blkcnt_t v6 = vcc_StatFileCapacity(*(const __CFURL **)(DerivedStorage + 16));
  blkcnt_t v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 >= v6) {
      goto LABEL_18;
    }
    uint64_t v11 = APFSCaptureDeletePreallocFile();
    if (v11)
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"FigFileDeleteFile failed for path %@, err %d", *(void *)(DerivedStorage + 16), v11);
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  uint64_t v8 = APFSCaptureExtendPreallocSizeForFile();
  if (!v8) {
    goto LABEL_18;
  }
  CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"APFSCaptureExtendPreallocSizeForFile failed: path %@, err %d, growBy %lld", *(void *)(DerivedStorage + 16), v8, v7);
LABEL_17:
  CFStringRef v13 = v9;
  uint64_t v5 = FigSignalErrorAt(4294950082, 0, 0, 0, 0, 0, 0);
  CFRelease(v13);
LABEL_19:
  blkcnt_t v14 = vcc_StatFileCapacity(*(const __CFURL **)(DerivedStorage + 16));
LABEL_20:
  *(void *)(DerivedStorage + 8) = v14;
  return v5;
}

uint64_t FigVirtualCaptureCard_ShowSystemUserInterface(uint64_t a1)
{
  return 0;
}

uint64_t FigVirtualCaptureCard_ReserveForCaptureToFile(uint64_t a1, const __CFURL *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!*(void *)(DerivedStorage + 16)) {
    goto LABEL_18;
  }
  if (*(void *)(DerivedStorage + 24))
  {
    uint64_t v12 = 4294950080;
    goto LABEL_21;
  }
  if (!a2)
  {
    uint64_t v12 = 4294950086;
    goto LABEL_21;
  }
  if (sVCCEnableCrashRecovery == 1)
  {
    memset(&v14, 0, sizeof(v14));
    if (!lstat(sVCCPreallocationSaveToSymlinkCString, &v14))
    {
LABEL_18:
      uint64_t v12 = 4294950082;
LABEL_21:
      uint64_t v7 = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
      goto LABEL_11;
    }
  }
  if (!CFURLGetFileSystemRepresentation(a2, 1u, (UInt8 *)&v14, 1024))
  {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Save to file path %@ is invalid", a2);
    goto LABEL_10;
  }
  uint64_t started = APFSCaptureStartCaptureInFile();
  if (started)
  {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"APFSCaptureStartCaptureInFile err %d", started);
LABEL_10:
    CFStringRef v6 = v5;
    uint64_t v7 = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
    CFRelease(v6);
    goto LABEL_11;
  }
  if (sVCCEnableCrashRecovery == 1 && symlink((const char *)&v14, sVCCPreallocationSaveToSymlinkCString))
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = __error();
    CFStringRef v13 = strerror(*v10);
    CFStringRef v5 = CFStringCreateWithFormat(v9, 0, @"symlink failed for: %s -> %s, err: %s", sVCCPreallocationSaveToSymlinkCString, &v14, v13);
    goto LABEL_10;
  }
  uint64_t v11 = *(const void **)(DerivedStorage + 24);
  *(void *)(DerivedStorage + 24) = a2;
  CFRetain(a2);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v7 = 0;
LABEL_11:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v7;
}

uint64_t FigVirtualCaptureCard_SaveCapture(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!*(void *)(DerivedStorage + 16))
  {
LABEL_21:
    uint64_t v20 = 4294950082;
LABEL_23:
    uint64_t v13 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  CFURLRef v3 = *(const __CFURL **)(DerivedStorage + 24);
  if (!v3)
  {
    uint64_t v20 = 4294950079;
    goto LABEL_23;
  }
  if (sVCCEnableCrashRecovery == 1)
  {
    memset(&v22, 0, sizeof(v22));
    if (!lstat(sVCCPreallocationSaveToSymlinkCString, &v22))
    {
      CFURLRef v3 = *(const __CFURL **)(DerivedStorage + 24);
      goto LABEL_6;
    }
    goto LABEL_21;
  }
LABEL_6:
  if (!CFURLGetFileSystemRepresentation(v3, 1u, (UInt8 *)&v22, 1024))
  {
    CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Save to file path %@ is invalid", *(void *)(DerivedStorage + 24));
LABEL_10:
    CFStringRef v10 = v12;
    uint64_t v11 = 4294950078;
    goto LABEL_11;
  }
  uint64_t v4 = APFSCaptureFinishCaptureForFile();
  if (v4)
  {
    uint64_t v5 = v4;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v7 = *__error();
    uint64_t v8 = __error();
    CFAllocatorRef v9 = strerror(*v8);
    CFStringRef v10 = CFStringCreateWithFormat(v6, 0, @"APFSCaptureFinishCaptureForFile failed with err = 0x%08x, errno = 0x%08x, strerror = %s", v5, v7, v9);
    uint64_t v11 = 4294950077;
LABEL_11:
    uint64_t v13 = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
    CFRelease(v10);
    goto LABEL_12;
  }
  if (sVCCEnableCrashRecovery == 1 && FigFileDeleteFile((const __CFURL *)sVCCPreallocationSaveToSymlink))
  {
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v17 = *__error();
    uint64_t v18 = __error();
    uint64_t v21 = strerror(*v18);
    CFStringRef v12 = CFStringCreateWithFormat(v16, 0, @"FigFileDeleteFile failed for %s, errno 0x%08x, strerror = %s", &sVCCPreallocationFileCString, v17, v21);
    goto LABEL_10;
  }
  uint64_t v19 = *(const void **)(DerivedStorage + 24);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(DerivedStorage + 24) = 0;
  }
  vcc_FigVirtualCaptureCardPreallocateCapacity(a1, *(void *)(DerivedStorage + 8));
  uint64_t v13 = 0;
LABEL_12:
  stat v14 = *(const void **)(DerivedStorage + 24);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(DerivedStorage + 24) = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v13;
}

uint64_t FigFoundationCreateHardLink(uint64_t a1, const __CFURL *a2)
{
  uint64_t v7 = 0;
  id v4 = objc_alloc_init(MEMORY[0x1E4F28B28]);
  if (FigFileDoesFileExist(a2)
    || (objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28CB8], "defaultManager"), "linkItemAtURL:toURL:error:", a1, a2, &v7) & 1) == 0)
  {
    uint64_t v5 = FigSignalErrorAt(4294950434, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v5 = 0;
  }

  return v5;
}

CFTypeRef FigCFStringCreateWithBytesWithUnknownEncoding(const __CFAllocator *a1, const UInt8 *a2, CFIndex a3, void *a4, uint64_t *a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  CFStringRef v12 = (void *)MEMORY[0x192FC5D30]();
  if (!a2 && a3 || a3 < 0 || a4 && (CFTypeID v13 = CFGetTypeID(a4), v13 != CFDictionaryGetTypeID()))
  {
    uint64_t v22 = 4294950436;
LABEL_38:
    FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
    goto LABEL_36;
  }
  if (!a3)
  {
LABEL_10:
    CFDataRef v15 = 0;
    goto LABEL_11;
  }
  stat v14 = a2;
  while ((*(char *)v14 & 0x80000000) == 0)
  {
    if (++v14 >= &a2[a3]) {
      goto LABEL_10;
    }
  }
  CFDataRef v17 = CFDataCreate(a1, a2, a3);
  if (!v17)
  {
    uint64_t v22 = 4294950435;
    goto LABEL_38;
  }
  CFDataRef v15 = v17;
  if (a4)
  {
    if ([a4 objectForKey:*MEMORY[0x1E4F288F0]])
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_39;
      }
    }
    if ([a4 objectForKey:*MEMORY[0x1E4F288D0]])
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_39;
      }
    }
    if ((uint64_t v18 = (void *)[a4 objectForKey:*MEMORY[0x1E4F288F8]]) != 0
      && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
      || (uint64_t v19 = (void *)[a4 objectForKey:*MEMORY[0x1E4F28900]]) != 0
      && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
      || (![v19 BOOLValue] || (unint64_t)objc_msgSend(v18, "count") >= 2)
      && ([a4 objectForKey:*MEMORY[0x1E4F288E0]]
       && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
       || [a4 objectForKey:*MEMORY[0x1E4F288E8]]
       && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
       || [a4 objectForKey:*MEMORY[0x1E4F288D8]]
       && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)))
    {
LABEL_39:
      FigSignalErrorAt(4294950436, 0, 0, 0, 0, 0, 0);
      goto LABEL_35;
    }
  }
  unint64_t v20 = [NSString stringEncodingForData:v15 encodingOptions:a4 convertedString:&cf usedLossyConversion:a6];
  if (cf)
  {
    CFTypeRef cf = CFRetain(cf);
    *a5 = CFStringConvertNSStringEncodingToEncoding(v20);
LABEL_35:
    CFRelease(v15);
    goto LABEL_36;
  }
LABEL_11:
  CFTypeRef cf = CFStringCreateWithBytes(a1, a2, a3, 0x8000100u, 1u);
  uint64_t v16 = 0xFFFFFFFFLL;
  if (cf) {
    uint64_t v16 = 134217984;
  }
  *a5 = v16;
  if (v15) {
    goto LABEL_35;
  }
LABEL_36:
  return cf;
}

CFTypeRef FigCFStringCreateWithJSONDictionary(int a1, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 != CFDictionaryGetTypeID()) {
    return 0;
  }

  return figCFStringCreateWithCFDictionaryOrCFArray(cf);
}

CFTypeRef figCFStringCreateWithCFDictionaryOrCFArray(CFTypeRef cf)
{
  CFTypeRef v1 = cf;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    CFTypeID TypeID = CFDictionaryGetTypeID();
    CFTypeID v4 = CFGetTypeID(v1);
    CFTypeID v5 = CFArrayGetTypeID();
    if (v2 == TypeID || v4 == v5)
    {
      CFAllocatorRef v6 = (void *)MEMORY[0x192FC5D30](v5);
      if ([MEMORY[0x1E4F28D90] isValidJSONObject:v1]
        && (uint64_t v7 = [MEMORY[0x1E4F28D90] dataWithJSONObject:v1 options:1 error:0],
            (id v8 = (id)[[NSString alloc] initWithData:v7 encoding:4]) != 0))
      {
        CFTypeRef v1 = CFRetain(v8);
      }
      else
      {
        CFTypeRef v1 = 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

CFTypeRef FigCFStringCreateWithJSONArray(int a1, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 != CFArrayGetTypeID()) {
    return 0;
  }

  return figCFStringCreateWithCFDictionaryOrCFArray(cf);
}

uint64_t FigCreateSerializedDictionaryFromNSErrorUserInfo(const __CFDictionary *a1, __CFDictionary **a2)
{
  xpc_object_t value = 0;
  uint64_t result = 4294950436;
  if (a1 && a2)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (CFDictionaryGetValueIfPresent(a1, (const void *)*MEMORY[0x1E4F289D8], (const void **)&value)) {
      CFDictionarySetValue(Mutable, @"CFError_NetworkUnavailableReason", value);
    }
    uint64_t result = 0;
    *a2 = Mutable;
  }
  return result;
}

uint64_t FigCreateNSErrorUserInfoFromSerializedDictionary(const __CFDictionary *a1, __CFDictionary **a2)
{
  xpc_object_t value = 0;
  uint64_t result = 4294950436;
  if (a1 && a2)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFAllocatorRef v6 = Mutable;
      if (CFDictionaryGetValueIfPresent(a1, @"CFError_NetworkUnavailableReason", (const void **)&value)) {
        CFDictionarySetValue(v6, (const void *)*MEMORY[0x1E4F289D8], value);
      }
      uint64_t result = 0;
      *a2 = v6;
    }
    else
    {
      return 4294950435;
    }
  }
  return result;
}

uint64_t FigCreateCFDataFromBase64EncodedString(uint64_t a1, uint64_t *a2)
{
  uint64_t result = 4294950436;
  if (a1 && a2)
  {
    uint64_t v5 = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:a1 options:0];
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t result = 0;
      *a2 = v6;
    }
    else
    {
      return 4294950436;
    }
  }
  return result;
}

const CMBufferCallbacks *CMBufferQueueGetCallbacksForUnsortedSampleBuffers(void)
{
  uint64_t result = (const CMBufferCallbacks *)&gFigBufferQueueCallbacksForUnsortedSampleBuffers;
  unk_1E92709B4 = sbufGetDecodeTimeStamp;
  unk_1E92709BC = sbufGetPresentationTimeStamp;
  unk_1E92709C4 = sbufGetDuration;
  unk_1E92709CC = sbufDataIsReady;
  unk_1E92709DC = @"FigSampleBufferDataBecameReady";
  unk_1E92709E4 = sbufGetTotalSampleSize;
  return result;
}

const CMBufferCallbacks *CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(void)
{
  uint64_t result = (const CMBufferCallbacks *)&gCMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS;
  unk_1E92709F8 = sbufGetDecodeTimeStamp;
  unk_1E9270A00 = sbufGetPresentationTimeStamp;
  unk_1E9270A08 = sbufGetDuration;
  unk_1E9270A10 = sbufDataIsReady;
  unk_1E9270A18 = sbufCompareOutputPTS;
  unk_1E9270A20 = @"FigSampleBufferDataBecameReady";
  unk_1E9270A28 = sbufGetTotalSampleSize;
  return result;
}

uint64_t sbufCompareOutputPTS(opaqueCMSampleBuffer *a1, opaqueCMSampleBuffer *a2)
{
  CMSampleBufferGetOutputPresentationTimeStamp(&v7, a1);
  CMSampleBufferGetOutputPresentationTimeStamp(&v6, a2);
  CMTime time1 = v7;
  CMTime v4 = v6;
  return CMTimeCompare(&time1, &v4);
}

CFTypeID CMBufferQueueGetTypeID(void)
{
  return sFigBufferQueueID;
}

OSStatus CMBufferQueueCreate(CFAllocatorRef allocator, CMItemCount capacity, const CMBufferCallbacks *callbacks, CMBufferQueueRef *queueOut)
{
  return figBufferQueueCreateWithCallbacksOrHandlers((uint64_t)allocator, capacity, (uint64_t)callbacks, 0, (uint64_t *)queueOut);
}

uint64_t figBufferQueueCreateWithCallbacksOrHandlers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (a5 && a3 | a4)
  {
    FigThreadRunOnce(&sRegisterFigBufferQueueTypeOnce, (void (*)(void))registerFigBufferQueueType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      if (a3 && (*(_DWORD *)a3 > 1u || !*(void *)(a3 + 28)) || a4 && (*(void *)a4 != 1 || !*(void *)(a4 + 24)))
      {
        uint64_t v13 = 4294954534;
        goto LABEL_31;
      }
      CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      uint64_t v11 = CMNotificationCenterRegisterForBarrierSupport((uint64_t)DefaultLocalCenter, Instance);
      if (v11)
      {
        uint64_t v12 = v11;
LABEL_33:
        CFRelease((CFTypeRef)Instance);
        uint64_t Instance = 0;
        goto LABEL_34;
      }
      if (a3)
      {
        *(_DWORD *)(Instance + 48) = *(_DWORD *)a3;
        *(void *)(Instance + 52) = *(void *)(a3 + 4);
        *(void *)(Instance + 6CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(void *)(a3 + 12);
        *(void *)(Instance + 68) = *(void *)(a3 + 20);
        *(void *)(Instance + 76) = *(void *)(a3 + 28);
        *(void *)(Instance + 84) = *(void *)(a3 + 36);
        *(void *)(Instance + 92) = *(void *)(a3 + 44);
        CFTypeRef v14 = *(CFTypeRef *)(a3 + 52);
        if (v14) {
          CFTypeRef v14 = CFRetain(v14);
        }
        *(void *)(Instance + 10CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v14;
        if (*(_DWORD *)a3) {
          *(void *)(Instance + 108) = *(void *)(a3 + 60);
        }
        *(unsigned char *)(Instance + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
      }
      if (a4)
      {
        *(void *)(Instance + 48) = *(void *)a4;
        *(void *)(Instance + 56) = _Block_copy(*(const void **)(a4 + 8));
        *(void *)(Instance + 64) = _Block_copy(*(const void **)(a4 + 16));
        *(void *)(Instance + 72) = _Block_copy(*(const void **)(a4 + 24));
        *(void *)(Instance + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = _Block_copy(*(const void **)(a4 + 32));
        *(void *)(Instance + 88) = _Block_copy(*(const void **)(a4 + 40));
        CFTypeRef v15 = *(CFTypeRef *)(a4 + 48);
        if (v15) {
          CFTypeRef v15 = CFRetain(v15);
        }
        *(void *)(Instance + 96) = v15;
        *(void *)(Instance + 104) = _Block_copy(*(const void **)(a4 + 56));
      }
      uint64_t v16 = FigReentrantMutexCreate();
      *(void *)(Instance + 16) = v16;
      if (v16)
      {
        CMTimeMake(&v22, 0, 1);
        *(CMTime *)(Instance + 124) = v22;
        *(void *)(Instance + 152) = 0;
        *(void *)(Instance + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a2;
        if (!a2
          || (CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)Instance),
              CFMutableArrayRef Mutable = CFArrayCreateMutable(v17, *(void *)(Instance + 40), MEMORY[0x1E4F1D510]),
              (*(void *)(Instance + 24) = Mutable) != 0)
          && (CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)Instance),
              CFMutableDictionaryRef v20 = CFDictionaryCreateMutable(v19, *(void *)(Instance + 40), 0, MEMORY[0x1E4F1D540]),
              (*(void *)(Instance + 32) = v20) != 0))
        {
          uint64_t v12 = 0;
          *(_OWORD *)(Instance + 216) = *(_OWORD *)&kCMTimeInvalid.value;
          *(void *)(Instance + 232) = 0;
          *(_OWORD *)(Instance + 24CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&kCMTimeZero.value;
          *(void *)(Instance + 256) = 0;
LABEL_35:
          *a5 = Instance;
          return v12;
        }
      }
    }
    uint64_t v13 = 4294954536;
LABEL_31:
    uint64_t v12 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
    if (!v12) {
      goto LABEL_34;
    }
LABEL_32:
    if (!Instance) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  uint64_t v12 = FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  uint64_t Instance = 0;
  if (v12) {
    goto LABEL_32;
  }
LABEL_34:
  if (a5) {
    goto LABEL_35;
  }
  return v12;
}

OSStatus CMBufferQueueCreateWithHandlers(CFAllocatorRef allocator, CMItemCount capacity, const CMBufferHandlers *handlers, CMBufferQueueRef *queueOut)
{
  return figBufferQueueCreateWithCallbacksOrHandlers((uint64_t)allocator, capacity, 0, (uint64_t)handlers, (uint64_t *)queueOut);
}

OSStatus CMBufferQueueEnqueue(CMBufferQueueRef queue, CMBufferRef buf)
{
  if (queue && buf)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 168))
    {
      uint64_t v4 = 4294954530;
LABEL_10:
      OSStatus v6 = FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
LABEL_11:
      FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
      return v6;
    }
    if (*((unsigned char *)queue + 121))
    {
      uint64_t v4 = 4294954533;
      goto LABEL_10;
    }
    CMTime v7 = (uint64_t (*)(CMBufferQueueRef, CMBufferRef, void))*((void *)queue + 25);
    if (v7)
    {
      OSStatus v6 = v7(queue, buf, *((void *)queue + 26));
      if (v6) {
        goto LABEL_11;
      }
    }
    uint64_t v8 = *((void *)queue + 24);
    if (v8)
    {
      OSStatus v6 = (*(uint64_t (**)(uint64_t, CMBufferQueueRef, CMBufferRef))(v8 + 16))(v8, queue, buf);
      if (v6) {
        goto LABEL_11;
      }
    }
    CFArrayRef v9 = (const __CFArray *)*((void *)queue + 3);
    if (!v9)
    {
      CFAllocatorRef v16 = CFGetAllocator(queue);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v16, *((void *)queue + 5), MEMORY[0x1E4F1D510]);
      *((void *)queue + 3) = Mutable;
      if (!Mutable
        || (CFAllocatorRef v18 = CFGetAllocator(queue),
            CFMutableDictionaryRef v19 = CFDictionaryCreateMutable(v18, *((void *)queue + 5), 0, MEMORY[0x1E4F1D540]),
            (*((void *)queue + 4) = v19) == 0))
      {
        uint64_t v4 = 4294954536;
        goto LABEL_10;
      }
      CFArrayRef v9 = (const __CFArray *)*((void *)queue + 3);
    }
    CFIndex Count = CFArrayGetCount(v9);
    CFIndex v11 = Count;
    uint64_t v12 = *((void *)queue + 5);
    if (v12 && Count == v12)
    {
      uint64_t v4 = 4294954532;
      goto LABEL_10;
    }
    if (*((unsigned char *)queue + 120))
    {
      if (*(void *)((char *)queue + 92))
      {
        uint64_t v13 = *(void *)((char *)queue + 52);
        uint64_t v24 = *(void *)((char *)queue + 92);
        uint64_t v25 = v13;
        uint64_t v26 = 0;
        CMBufferRef v27 = buf;
        CFArrayRef v14 = (const __CFArray *)*((void *)queue + 3);
        CFTypeRef v15 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))figBufferQueueCallCompareCallback;
LABEL_29:
        v29.location = 0;
        v29.length = v11;
        CFIndex v21 = CFArrayBSearchValues(v14, v29, buf, v15, &v24);
        if (v21 >= v11) {
          CFIndex v22 = v11;
        }
        else {
          CFIndex v22 = v21;
        }
        CMBufferQueueRef v23 = queue;
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v20 = *((void *)queue + 11);
      if (v20)
      {
        uint64_t v24 = 0;
        uint64_t v25 = 0;
        uint64_t v26 = v20;
        CMBufferRef v27 = buf;
        CFArrayRef v14 = (const __CFArray *)*((void *)queue + 3);
        CFTypeRef v15 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))figBufferQueueCallCompareHandler;
        goto LABEL_29;
      }
    }
    CMBufferQueueRef v23 = queue;
    CFIndex v22 = v11;
LABEL_34:
    bufQInsertElementAtIndex((uint64_t)v23, v22, buf);
    OSStatus v6 = 0;
    goto LABEL_11;
  }

  return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

uint64_t figBufferQueueCallCompareCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))a3)(a1, a2, *(void *)(a3 + 8));
  if (!result)
  {
    uint64_t v7 = *(void *)(a3 + 24);
    if (v7 == a2) {
      uint64_t v8 = -1;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v7 == a1) {
      return 1;
    }
    else {
      return v8;
    }
  }
  return result;
}

uint64_t figBufferQueueCallCompareHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a3 + 16) + 16))();
  if (!result)
  {
    uint64_t v7 = *(void *)(a3 + 24);
    if (v7 == a2) {
      uint64_t v8 = -1;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v7 == a1) {
      return 1;
    }
    else {
      return v8;
    }
  }
  return result;
}

OSStatus CMBufferQueueSetValidationCallback(CMBufferQueueRef queue, CMBufferValidationCallback callback, void *refcon)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    *((void *)queue + 25) = callback;
    *((void *)queue + 26) = refcon;
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

OSStatus CMBufferQueueSetValidationHandler(CMBufferQueueRef queue, CMBufferValidationHandler handler)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    uint64_t v4 = (const void *)*((void *)queue + 24);
    *((void *)queue + 24) = _Block_copy(handler);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    uint64_t v4 = 0;
  }
  _Block_release(v4);
  return 0;
}

CMBufferRef CMBufferQueueDequeueAndRetain(CMBufferQueueRef queue)
{
  if (!queue)
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((unsigned char *)queue + 168))
  {
    FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFArrayRef v4 = (const __CFArray *)*((void *)queue + 3);
    if (v4 && CFArrayGetCount(v4))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
      CFTypeID v2 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFRetain(ValueAtIndex);
        bufQRemoveElementAtIndex((uint64_t)queue);
      }
      goto LABEL_5;
    }
  }
  CFTypeID v2 = 0;
LABEL_5:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  return v2;
}

CMBufferRef CMBufferQueueDequeueIfDataReadyAndRetain(CMBufferQueueRef queue)
{
  if (!queue)
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (!*((unsigned char *)queue + 168))
  {
    CFArrayRef v4 = (const __CFArray *)*((void *)queue + 3);
    if (!v4 || !CFArrayGetCount(v4)) {
      goto LABEL_4;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
    CFTypeID v2 = ValueAtIndex;
    if (!ValueAtIndex) {
      goto LABEL_5;
    }
    if (*((unsigned char *)queue + 120))
    {
      OSStatus v6 = *(unsigned int (**)(const void *, void))((char *)queue + 84);
      if (v6 && !v6(ValueAtIndex, *(void *)((char *)queue + 52))) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v7 = *((void *)queue + 10);
      if (v7 && !(*(unsigned int (**)(uint64_t, const void *))(v7 + 16))(v7, v2)) {
        goto LABEL_4;
      }
    }
    CFRetain(v2);
    bufQRemoveElementAtIndex((uint64_t)queue);
    goto LABEL_5;
  }
  FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
LABEL_4:
  CFTypeID v2 = 0;
LABEL_5:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  return v2;
}

const void *FigBufferQueueDequeueIfMatchingAndRetain(uint64_t a1, const void *a2)
{
  if (!a1 || !a2)
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(unsigned char *)(a1 + 168))
  {
    FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFArrayRef v6 = *(const __CFArray **)(a1 + 24);
    if (v6 && CFArrayGetCount(v6))
    {
      CFArrayRef v4 = 0;
      if (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0) == a2)
      {
        CFRetain(a2);
        bufQRemoveElementAtIndex(a1);
        CFArrayRef v4 = a2;
      }
      goto LABEL_6;
    }
  }
  CFArrayRef v4 = 0;
LABEL_6:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v4;
}

CMBufferRef CMBufferQueueGetHead(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    CFArrayRef v2 = (const __CFArray *)*((void *)queue + 3);
    if (v2 && CFArrayGetCount(v2)) {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
    }
    else {
      ValueAtIndex = 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return ValueAtIndex;
}

CMBufferRef CMBufferQueueCopyHead(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    CFArrayRef v2 = (const __CFArray *)*((void *)queue + 3);
    if (v2 && CFArrayGetCount(v2))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
      CFArrayRef v4 = ValueAtIndex;
      if (ValueAtIndex) {
        CFRetain(ValueAtIndex);
      }
    }
    else
    {
      CFArrayRef v4 = 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v4;
}

Boolean CMBufferQueueIsEmpty(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    CFArrayRef v2 = (const __CFArray *)*((void *)queue + 3);
    if (v2) {
      Boolean v3 = CFArrayGetCount(v2) == 0;
    }
    else {
      Boolean v3 = 1;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 1;
  }
  return v3;
}

OSStatus CMBufferQueueMarkEndOfData(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 168))
    {
      OSStatus v3 = FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      *((unsigned char *)queue + 121) = 1;
      *((unsigned char *)queue + 184) = 0;
      CFSetRef v5 = (const __CFSet *)*((void *)queue + 20);
      if (v5) {
        CFSetApplyFunction(v5, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, queue);
      }
      OSStatus v3 = 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    return v3;
  }
  else
  {
    return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  }
}

Boolean CMBufferQueueContainsEndOfData(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    Boolean v2 = *((unsigned char *)queue + 121);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 1;
  }
  return v2;
}

Boolean CMBufferQueueIsAtEndOfData(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    int v2 = *((unsigned __int8 *)queue + 121);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    if (v2) {
      LOBYTE(v2) = CMBufferQueueIsEmpty(queue) != 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    LOBYTE(v2) = 1;
  }
  return v2;
}

uint64_t resetWithCallback(uint64_t a1, void (*a2)(CFTypeRef, uint64_t), uint64_t a3)
{
  if (a1)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    if (*(unsigned char *)(a1 + 168))
    {
      uint64_t v7 = FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
      CFMutableArrayRef Mutable = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 121) = 0;
      CFArrayRef v10 = *(const __CFArray **)(a1 + 24);
      if (v10)
      {
        if (!a2)
        {
          CFMutableArrayRef Mutable = 0;
          goto LABEL_24;
        }
        CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
        CFMutableArrayRef Mutable = CFArrayCreateMutable(v11, Count, MEMORY[0x1E4F1D510]);
        while (1)
        {
          CFArrayRef v10 = *(const __CFArray **)(a1 + 24);
LABEL_24:
          if (!CFArrayGetCount(v10)) {
            break;
          }
          if (Mutable)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          bufQRemoveElementAtIndex(a1);
        }
      }
      else
      {
        CFMutableArrayRef Mutable = 0;
      }
      *(unsigned char *)(a1 + 184) = 1;
      CFSetRef v13 = *(const __CFSet **)(a1 + 160);
      if (v13) {
        CFSetApplyFunction(v13, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a1);
      }
      uint64_t v7 = 0;
      if (a2 && Mutable)
      {
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
        if (CFArrayGetCount(Mutable))
        {
          do
          {
            CFArrayRef v14 = CFArrayGetValueAtIndex(Mutable, 0);
            CFTypeRef v15 = CFRetain(v14);
            CFArrayRemoveValueAtIndex(Mutable, 0);
            a2(v15, a3);
            CFRelease(v15);
          }
          while (CFArrayGetCount(Mutable));
          uint64_t v7 = 0;
        }
        else
        {
          uint64_t v7 = 0;
        }
        goto LABEL_5;
      }
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (!Mutable) {
      return v7;
    }
LABEL_5:
    CFRelease(Mutable);
    return v7;
  }
  return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

OSStatus CMBufferQueueReset(CMBufferQueueRef queue)
{
  return resetWithCallback((uint64_t)queue, 0, 0);
}

CMTime *__cdecl CMBufferQueueGetMinDecodeTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 120))
    {
      if (!*(void *)((char *)queue + 60)) {
        return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
      }
    }
    else if (!*((void *)queue + 7))
    {
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    }
    CFArrayRef v5 = (const __CFArray *)*((void *)queue + 3);
    if (v5 && CFArrayGetCount(v5) >= 1)
    {
      v10[3] = 0;
      v10[0] = retstr;
      if (*((unsigned char *)queue + 120))
      {
        CFArrayRef v6 = *(uint64_t (**)(uint64_t, uint64_t))((char *)queue + 60);
        uint64_t v7 = (char *)queue + 52;
      }
      else
      {
        uint64_t v7 = (char *)queue + 56;
        CFArrayRef v6 = figBufferQueueCallGetTimeHandler;
      }
      uint64_t v8 = *(void *)v7;
      v10[1] = v6;
      int v10[2] = v8;
      CFArrayRef v9 = (const __CFArray *)*((void *)queue + 3);
      v12.length = CFArrayGetCount(v9);
      v12.location = 0;
      CFArrayApplyFunction(v9, v12, (CFArrayApplierFunction)findBestTimeStamp, v10);
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }

  return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

uint64_t figBufferQueueCallGetTimeHandler(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CMTime *__cdecl CMBufferQueueGetFirstDecodeTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 120))
    {
      if (!*(void *)((char *)queue + 60)) {
        goto LABEL_14;
      }
    }
    else if (!*((void *)queue + 7))
    {
LABEL_14:
      CFArrayRef v9 = (pthread_mutex_t *)*((void *)queue + 2);
      return (CMTime *)FigReentrantMutexUnlock(v9);
    }
    CFArrayRef v4 = (const __CFArray *)*((void *)queue + 3);
    if (v4 && CFArrayGetCount(v4))
    {
      if (*((unsigned char *)queue + 120))
      {
        CFArrayRef v5 = *(void (**)(const void *, void))((char *)queue + 60);
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        v5(ValueAtIndex, *(void *)((char *)queue + 52));
      }
      else
      {
        uint64_t v7 = *((void *)queue + 7);
        uint64_t v8 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        (*(void (**)(uint64_t, const void *))(v7 + 16))(v7, v8);
      }
    }
    goto LABEL_14;
  }

  return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

CMTime *__cdecl CMBufferQueueGetMinPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  void (*v9)(CMTime *__return_ptr, const void *, void);
  const void *ValueAtIndex;
  uint64_t v11;
  const void *v12;
  CMTime v13;
  CMTime time2;
  CMTime time1;
  CMTime v16;
  uint64_t vars8;

  *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 120))
    {
      if (!*(void *)((char *)queue + 68)) {
        return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
      }
    }
    else if (!*((void *)queue + 8))
    {
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    }
    CFArrayRef v5 = (const __CFArray *)*((void *)queue + 3);
    if (v5)
    {
      CFIndex Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        uint64_t v7 = Count;
        CFIndex v8 = 0;
        while (1)
        {
          memset(&v16, 0, sizeof(v16));
          if (*((unsigned char *)queue + 120))
          {
            CFArrayRef v9 = *(void (**)(CMTime *__return_ptr, const void *, void))((char *)queue + 68);
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v8);
            v9(&v16, ValueAtIndex, *(void *)((char *)queue + 52));
          }
          else
          {
            CFAllocatorRef v11 = *((void *)queue + 8);
            CFRange v12 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v8);
            (*(void (**)(CMTime *__return_ptr, uint64_t, const void *))(v11 + 16))(&v16, v11, v12);
          }
          if (v16.flags)
          {
            if ((retstr->flags & 1) == 0 || (time1 = v16, CMTime time2 = *retstr, CMTimeCompare(&time1, &time2) < 0)) {
              *retstr = v16;
            }
            if (*((unsigned char *)queue + 252))
            {
              memset(&time1, 0, sizeof(time1));
              CMTime time2 = v16;
              CFSetRef v13 = *retstr;
              CMTimeSubtract(&time1, &time2, &v13);
              CMTime time2 = time1;
              CFSetRef v13 = *(CMTime *)((unsigned char *)queue + 10);
              if ((CMTimeCompare(&time2, &v13) & 0x80000000) == 0) {
                break;
              }
            }
          }
          if (v7 == ++v8)
          {
            CFIndex v8 = v7;
            break;
          }
        }
        if (v7 >= 10 && v8 == v7) {
          bufQReconstructBounds((uint64_t)queue);
        }
      }
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }

  return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

double bufQReconstructBounds(uint64_t a1)
{
  void (*v7)(CMTime *__return_ptr, const void *, void);
  const void *ValueAtIndex;
  uint64_t v9;
  const void *v10;
  CMTimeFlags flags;
  double result;
  CMTime v13;
  CMTime time2;
  CMTime time1;
  CMTime v16;
  CMTime v17;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v20;

  uint64_t v20 = *MEMORY[0x1E4F143B8];
  xpc_object_t value = 0;
  CMTimeFlags v2 = 0;
  int timescale = 0;
  CMTimeEpoch epoch = 0;
  *(_OWORD *)&v17.xpc_object_t value = *(_OWORD *)&kCMTimeZero.value;
  v17.CMTimeEpoch epoch = 0;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; v5 != i; ++i)
    {
      memset(&v16, 0, sizeof(v16));
      if (*(unsigned char *)(a1 + 120))
      {
        uint64_t v7 = *(void (**)(CMTime *__return_ptr, const void *, void))(a1 + 68);
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
        v7(&v16, ValueAtIndex, *(void *)(a1 + 52));
      }
      else
      {
        CFArrayRef v9 = *(void *)(a1 + 64);
        CFArrayRef v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
        (*(void (**)(CMTime *__return_ptr, uint64_t, const void *))(v9 + 16))(&v16, v9, v10);
      }
      CMTimeFlags flags = v16.flags;
      if (v16.flags & 1) != 0 && (v2)
      {
        CMTime time1 = v16;
        time2.xpc_object_t value = value;
        time2.int timescale = timescale;
        time2.CMTimeFlags flags = v2;
        time2.CMTimeEpoch epoch = epoch;
        if (CMTimeCompare(&time1, &time2) < 0)
        {
          memset(&time1, 0, sizeof(time1));
          time2.xpc_object_t value = value;
          time2.int timescale = timescale;
          time2.CMTimeFlags flags = v2;
          time2.CMTimeEpoch epoch = epoch;
          CFSetRef v13 = v16;
          CMTimeSubtract(&time1, &time2, &v13);
          CMTime time2 = v17;
          CFSetRef v13 = time1;
          CMTimeMaximum(&v17, &time2, &v13);
        }
      }
      else if ((v2 & 1) == 0)
      {
        goto LABEL_14;
      }
      if ((v16.flags & 1) == 0) {
        continue;
      }
      CMTime time1 = v16;
      time2.xpc_object_t value = value;
      time2.int timescale = timescale;
      time2.CMTimeFlags flags = v2;
      time2.CMTimeEpoch epoch = epoch;
      if (CMTimeCompare(&time1, &time2) < 1) {
        continue;
      }
      CMTimeFlags flags = v16.flags;
LABEL_14:
      xpc_object_t value = v16.value;
      int timescale = v16.timescale;
      CMTimeEpoch epoch = v16.epoch;
      CMTimeFlags v2 = flags;
    }
  }
  *(void *)(a1 + 216) = value;
  *(_DWORD *)(a1 + 224) = timescale;
  *(_DWORD *)(a1 + 228) = v2;
  *(void *)(a1 + 232) = epoch;
  uint64_t result = *(double *)&v17.value;
  *(CMTime *)(a1 + 24CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v17;
  return result;
}

CMTime *__cdecl CMBufferQueueGetMaxPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  void (*v10)(CMTime *__return_ptr, const void *, void);
  const void *ValueAtIndex;
  uint64_t v12;
  const void *v13;
  CMTime v14;
  CMTime time2;
  CMTime time1;
  CMTime v17;
  uint64_t vars8;

  *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 120))
    {
      if (!*(void *)((char *)queue + 68)) {
        return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
      }
    }
    else if (!*((void *)queue + 8))
    {
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    }
    CFArrayRef v5 = (const __CFArray *)*((void *)queue + 3);
    if (v5)
    {
      CFIndex Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        uint64_t v7 = Count;
        CFIndex v8 = Count + 1;
        while (1)
        {
          CFIndex v9 = v8 - 2;
          memset(&v17, 0, sizeof(v17));
          if (*((unsigned char *)queue + 120))
          {
            CFArrayRef v10 = *(void (**)(CMTime *__return_ptr, const void *, void))((char *)queue + 68);
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v9);
            v10(&v17, ValueAtIndex, *(void *)((char *)queue + 52));
          }
          else
          {
            CFRange v12 = *((void *)queue + 8);
            CFSetRef v13 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v9);
            (*(void (**)(CMTime *__return_ptr, uint64_t, const void *))(v12 + 16))(&v17, v12, v13);
          }
          if (v17.flags)
          {
            if ((retstr->flags & 1) == 0 || (time1 = v17, CMTime time2 = *retstr, CMTimeCompare(&time1, &time2) >= 1)) {
              *retstr = v17;
            }
            if (*((unsigned char *)queue + 252))
            {
              memset(&time1, 0, sizeof(time1));
              CMTime time2 = *retstr;
              CFArrayRef v14 = v17;
              CMTimeSubtract(&time1, &time2, &v14);
              CMTime time2 = time1;
              CFArrayRef v14 = *(CMTime *)((unsigned char *)queue + 10);
              if ((CMTimeCompare(&time2, &v14) & 0x80000000) == 0) {
                break;
              }
            }
          }
          if ((unint64_t)--v8 < 2)
          {
            if (v7 >= 10) {
              bufQReconstructBounds((uint64_t)queue);
            }
            return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
          }
        }
      }
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }

  return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

CMTime *__cdecl CMBufferQueueGetEndPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 120))
    {
      if (!*(void *)((char *)queue + 68) || !*(void *)((char *)queue + 76)) {
        return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
      }
    }
    else if (!*((void *)queue + 8) || !*((void *)queue + 9))
    {
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    }
    CFArrayRef v5 = (const __CFArray *)*((void *)queue + 3);
    if (v5 && CFArrayGetCount(v5) >= 1)
    {
      v8[3] = 1;
      CFArrayRef v6 = bufQGetEndPTS;
      if (!*((unsigned char *)queue + 120)) {
        CFArrayRef v6 = bufQGetEndPTSUsingHandlers;
      }
      v8[0] = retstr;
      v8[1] = v6;
      v8[2] = (char *)queue + 48;
      CFArrayRef v7 = (const __CFArray *)*((void *)queue + 3);
      v10.length = CFArrayGetCount(v7);
      v10.location = 0;
      CFArrayApplyFunction(v7, v10, (CFArrayApplierFunction)findBestTimeStamp, v8);
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }

  return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

CMTime *bufQGetEndPTSUsingHandlers@<X0>(uint64_t a1@<X1>, CMTime *a2@<X8>)
{
  (*(void (**)(CMTime *__return_ptr))(*(void *)(a1 + 16) + 16))(&lhs);
  (*(void (**)(CMTime *__return_ptr))(*(void *)(a1 + 24) + 16))(&v5);
  return CMTimeAdd(a2, &lhs, &v5);
}

CMTime *__cdecl CMBufferQueueGetFirstPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 120))
    {
      if (!*(void *)((char *)queue + 68)) {
        goto LABEL_14;
      }
    }
    else if (!*((void *)queue + 8))
    {
LABEL_14:
      CFIndex v9 = (pthread_mutex_t *)*((void *)queue + 2);
      return (CMTime *)FigReentrantMutexUnlock(v9);
    }
    CFArrayRef v4 = (const __CFArray *)*((void *)queue + 3);
    if (v4 && CFArrayGetCount(v4))
    {
      if (*((unsigned char *)queue + 120))
      {
        CMTime v5 = *(void (**)(const void *, void))((char *)queue + 68);
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        v5(ValueAtIndex, *(void *)((char *)queue + 52));
      }
      else
      {
        uint64_t v7 = *((void *)queue + 8);
        CFIndex v8 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        (*(void (**)(uint64_t, const void *))(v7 + 16))(v7, v8);
      }
    }
    goto LABEL_14;
  }

  return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

CMItemCount CMBufferQueueGetBufferCount(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    CFArrayRef v2 = (const __CFArray *)*((void *)queue + 3);
    if (v2) {
      CMItemCount Count = CFArrayGetCount(v2);
    }
    else {
      CMItemCount Count = 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return Count;
}

CMTime *__cdecl CMBufferQueueGetDuration(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    *(_OWORD *)&retstr->xpc_object_t value = *(_OWORD *)((char *)queue + 124);
    retstr->CMTimeEpoch epoch = *(void *)((char *)queue + 140);
    CFArrayRef v4 = (pthread_mutex_t *)*((void *)queue + 2);
    return (CMTime *)FigReentrantMutexUnlock(v4);
  }
  else
  {
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  }
}

size_t CMBufferQueueGetTotalSize(CMBufferQueueRef queue)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    size_t v2 = *((void *)queue + 19);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v2;
}

uint64_t FigBufferQueueInstallTriggerWithTimeAndIntegerThresholds(uint64_t a1, uint64_t a2, uint64_t a3, int a4, long long *a5, uint64_t a6, uint64_t *a7)
{
  if (a1 && a4 && a2 | (unint64_t)a7)
  {
    if ((*((_DWORD *)a5 + 3) & 0x1D) == 1 && !*((void *)a5 + 2))
    {
      if (a4 == 12 || a4 == 15)
      {
        long long v9 = *a5;
        uint64_t v10 = *((void *)a5 + 2);
        return bufQInstallTrigger(a1, a2, a3, 0, a4, (uint64_t)&v9, a6, a7);
      }
      uint64_t v7 = 4294954529;
    }
    else
    {
      uint64_t v7 = 4294954531;
    }
  }
  else
  {
    uint64_t v7 = 4294954535;
  }

  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

OSStatus CMBufferQueueInstallTrigger(CMBufferQueueRef queue, CMBufferQueueTriggerCallback callback, void *refcon, CMBufferQueueTriggerCondition condition, CMTime *time, CMBufferQueueTriggerToken *triggerTokenOut)
{
  CMTime v7 = *time;
  return figBufferQueueInstallTriggerCallbackOrHandler((char *)queue, (uint64_t)callback, (uint64_t)refcon, 0, condition, (uint64_t)&v7, (uint64_t *)triggerTokenOut);
}

uint64_t figBufferQueueInstallTriggerCallbackOrHandler(char *queue, uint64_t a2, uint64_t a3, const void *a4, unsigned int a5, uint64_t a6, uint64_t *a7)
{
  if (queue && a5 && (a2 || a4 || a7))
  {
    if (a5 == 6)
    {
      CMBufferQueueGetMaxPresentationTimeStamp(&v16, (CMBufferQueueRef)queue);
    }
    else
    {
      if (a5 != 5)
      {
        if (a5 - 7 > 2)
        {
          if ((*(_DWORD *)(a6 + 12) & 0x1D) != 1 || *(void *)(a6 + 16))
          {
            uint64_t v14 = 4294954531;
            goto LABEL_7;
          }
        }
        else
        {
          *(_OWORD *)a6 = *(_OWORD *)&kCMTimeInvalid.value;
          *(void *)(a6 + 16) = 0;
        }
        if (a5 > 9 || ((1 << a5) & 0x39E) == 0) {
          goto LABEL_23;
        }
        goto LABEL_21;
      }
      CMBufferQueueGetMinPresentationTimeStamp(&v16, (CMBufferQueueRef)queue);
    }
    *(CMTime *)a6 = v16;
    if (queue[120])
    {
      if (!*(void *)(queue + 68)) {
        goto LABEL_23;
      }
    }
    else if (!*((void *)queue + 8))
    {
LABEL_23:
      uint64_t v14 = 4294954529;
      goto LABEL_7;
    }
LABEL_21:
    CMTime v16 = *(CMTime *)a6;
    return bufQInstallTrigger((uint64_t)queue, a2, a3, a4, a5, (uint64_t)&v16, 0, a7);
  }
  uint64_t v14 = 4294954535;
LABEL_7:

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

OSStatus CMBufferQueueInstallTriggerWithIntegerThreshold(CMBufferQueueRef queue, CMBufferQueueTriggerCallback callback, void *refcon, CMBufferQueueTriggerCondition condition, CMItemCount threshold, CMBufferQueueTriggerToken *triggerTokenOut)
{
  return figBufferQueueInstallTriggerWithIntegerThresholdCallbackOrHandler((uint64_t)queue, (uint64_t)callback, (uint64_t)refcon, 0, condition, threshold, (uint64_t *)triggerTokenOut);
}

uint64_t figBufferQueueInstallTriggerWithIntegerThresholdCallbackOrHandler(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, unsigned int a5, uint64_t a6, uint64_t *a7)
{
  if (!a1 || !a5 || !a2 && !a4 && !a7)
  {
    uint64_t v7 = 4294954535;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (a5 > 0xE || ((1 << a5) & 0x6C00) == 0)
  {
    uint64_t v7 = 4294954529;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return bufQInstallTrigger(a1, a2, a3, a4, a5, (uint64_t)&kCMTimeInvalid, a6, a7);
}

OSStatus CMBufferQueueInstallTriggerHandler(CMBufferQueueRef queue, CMBufferQueueTriggerCondition condition, CMTime *time, CMBufferQueueTriggerToken *triggerTokenOut, CMBufferQueueTriggerHandler handler)
{
  CMTime v6 = *time;
  return figBufferQueueInstallTriggerCallbackOrHandler((char *)queue, 0, 0, handler, condition, (uint64_t)&v6, (uint64_t *)triggerTokenOut);
}

OSStatus CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(CMBufferQueueRef queue, CMBufferQueueTriggerCondition condition, CMItemCount threshold, CMBufferQueueTriggerToken *triggerTokenOut, CMBufferQueueTriggerHandler handler)
{
  return figBufferQueueInstallTriggerWithIntegerThresholdCallbackOrHandler((uint64_t)queue, 0, 0, handler, condition, threshold, (uint64_t *)triggerTokenOut);
}

OSStatus CMBufferQueueRemoveTrigger(CMBufferQueueRef queue, CMBufferQueueTriggerToken triggerToken)
{
  if (queue && triggerToken)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    if (*((unsigned char *)queue + 168))
    {
      uint64_t v4 = 4294954530;
    }
    else
    {
      CFSetRef v6 = (const __CFSet *)*((void *)queue + 20);
      if (v6 && CFSetGetValue(v6, triggerToken))
      {
        CFSetRemoveValue(*((CFMutableSetRef *)queue + 20), triggerToken);
        *((unsigned char *)queue + 169) = 0;
        CFSetApplyFunction(*((CFSetRef *)queue + 20), (CFSetApplierFunction)bufQCheckForDataBecomesReadyTrigger, queue);
        OSStatus v7 = 0;
        if (!*((unsigned char *)queue + 169))
        {
          bufQStopListeningForHeadBufferBecomingReady((uint64_t)queue);
          OSStatus v7 = 0;
        }
        goto LABEL_14;
      }
      uint64_t v4 = 4294954528;
    }
    OSStatus v7 = FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
LABEL_14:
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    return v7;
  }

  return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

Boolean CMBufferQueueTestTrigger(CMBufferQueueRef queue, CMBufferQueueTriggerToken triggerToken)
{
  if (queue && triggerToken)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    CFSetRef v4 = (const __CFSet *)*((void *)queue + 20);
    if (v4 && CFSetGetValue(v4, triggerToken))
    {
      Boolean v5 = *((unsigned char *)triggerToken + 64);
    }
    else
    {
      FigSignalErrorAt(4294954528, 0, 0, 0, 0, 0, 0);
      Boolean v5 = 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v5;
}

OSStatus CMBufferQueueCallForEachBuffer(CMBufferQueueRef queue, OSStatus (__cdecl *callback)(CMBufferRef, void *), void *refcon)
{
  OSStatus v10 = 0;
  if (queue && callback)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    CFArrayRef v6 = (const __CFArray *)*((void *)queue + 3);
    if (v6)
    {
      if (CFArrayGetCount(v6) >= 1)
      {
        v9[0] = &v10;
        v9[1] = callback;
        int v9[2] = refcon;
        CFArrayRef v7 = (const __CFArray *)*((void *)queue + 3);
        v11.length = CFArrayGetCount(v7);
        v11.location = 0;
        CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)bufqCallForOneBuffer, v9);
      }
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    return v10;
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t bufqCallForOneBuffer(uint64_t result, uint64_t a2)
{
  if (!**(_DWORD **)a2)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(a2 + 8))(result, *(void *)(a2 + 16));
    **(_DWORD **)a2 = result;
  }
  return result;
}

uint64_t FigBufferQueueCallForEachBufferLastToFirst(uint64_t a1, uint64_t (*a2)(const void *, uint64_t), uint64_t a3)
{
  if (a1 && a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    CFArrayRef v6 = *(const __CFArray **)(a1 + 24);
    if (v6) {
      CFIndex Count = CFArrayGetCount(v6);
    }
    else {
      CFIndex Count = 0;
    }
    while (Count-- >= 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), Count);
      uint64_t v11 = a2(ValueAtIndex, a3);
      if (v11)
      {
        uint64_t v8 = v11;
        goto LABEL_11;
      }
    }
    uint64_t v8 = 0;
LABEL_11:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v8;
}

__CFString *bufQCopyDebugDesc(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, @"<");
  uint64_t v3 = 92;
  if (!*(unsigned char *)(a1 + 120)) {
    uint64_t v3 = 88;
  }
  if (*(void *)(a1 + v3)) {
    CFSetRef v4 = "sorted";
  }
  else {
    CFSetRef v4 = "unsorted";
  }
  CFIndex v5 = CFGetRetainCount((CFTypeRef)a1);
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"CMBufferQueue(%s) %p retainCount: %ld allocator: %p\n", v4, a1, v5, v6);
  if (*(unsigned char *)(a1 + 120))
  {
    unk_1E92709B4 = sbufGetDecodeTimeStamp;
    unk_1E92709BC = sbufGetPresentationTimeStamp;
    unk_1E92709C4 = sbufGetDuration;
    unk_1E92709CC = sbufDataIsReady;
    unk_1E92709DC = @"FigSampleBufferDataBecameReady";
    unk_1E92709E4 = sbufGetTotalSampleSize;
    if (!memcmp((const void *)(a1 + 48), &gFigBufferQueueCallbacksForUnsortedSampleBuffers, 0x44uLL)) {
      CFStringAppendFormat(Mutable, 0, @"\tcallbacks: kCMBufferQueueCallbacksForUnsortedSampleBuffers\n", v21, v22, v23, v24);
    }
    else {
      CFStringAppendFormat(Mutable, 0, @"\tcallbacks:\n\t\tversion = %d\n\t\trefcon = %p\n\t\tgetDTS = %p\n\t\tgetPTS = %p\n\t\tgetDuration = %p\n\t\tisDataReady = %p\n\t\tcompare = %p\n", *(unsigned int *)(a1 + 48), *(void *)(a1 + 52), *(void *)(a1 + 60), *(void *)(a1 + 68), *(void *)(a1 + 76), *(void *)(a1 + 84), *(void *)(a1 + 92));
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"\thandlers:\n\t\tversion = %d\n\t\tgetDTS = %p\n\t\tgetPTS = %p\n\t\tgetDuration = %p\n\t\tisDataReady = %p\n\t\tcompare = %p\n", *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88));
  }
  CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
  CMTime time = *(CMTime *)(a1 + 124);
  CFStringRef v8 = CMTimeCopyDescription(v7, &time);
  CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a1);
  CMBufferQueueGetMinPresentationTimeStamp(&time, (CMBufferQueueRef)a1);
  CFStringRef v10 = CMTimeCopyDescription(v9, &time);
  CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
  CMBufferQueueGetMinDecodeTimeStamp(&v25, (CMBufferQueueRef)a1);
  CFStringRef v12 = CMTimeCopyDescription(v11, &v25);
  CFArrayRef Count = *(const __CFArray **)(a1 + 24);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  uint64_t v14 = "YES";
  if (*(unsigned char *)(a1 + 168)) {
    CFTypeRef v15 = "YES";
  }
  else {
    CFTypeRef v15 = "NO";
  }
  if (!*(unsigned char *)(a1 + 121)) {
    uint64_t v14 = "NO";
  }
  CFStringAppendFormat(Mutable, 0, @"\telement count: %ld\n\tfiringTrigger: %s\n\tcontainsEOD: %s\n\ttotalDuration: %@\n\tminPTS: %@\n\tminDTS: %@\n", Count, v15, v14, v8, v10, v12);
  if (v8) {
    CFRelease(v8);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v12) {
    CFRelease(v12);
  }
  CFSetRef v16 = *(const __CFSet **)(a1 + 160);
  if (v16 && CFSetGetCount(v16))
  {
    CFIndex v17 = CFSetGetCount(*(CFSetRef *)(a1 + 160));
    CFStringAppendFormat(Mutable, 0, @"\tTriggers (%ld):", v17);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 160), (CFSetApplierFunction)appendTriggerDescription, Mutable);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"\tNO triggers\n");
  }
  CFArrayRef v18 = *(const __CFArray **)(a1 + 24);
  if (v18 && CFArrayGetCount(v18))
  {
    CFStringAppendFormat(Mutable, 0, @"\tElements:");
    CFArrayRef v19 = *(const __CFArray **)(a1 + 24);
    v27.length = CFArrayGetCount(v19);
    v27.location = 0;
    CFArrayApplyFunction(v19, v27, (CFArrayApplierFunction)appendBufQElementDescription, Mutable);
    CFStringAppendFormat(Mutable, 0, @">\n");
  }
  return Mutable;
}

void appendBufQElementDescription(uint64_t a1, CFMutableStringRef theString)
{
  CFStringAppendFormat(theString, 0, @"\n\telement = %p", a1);
}

void appendTriggerDescription(uint64_t a1, __CFString *cf)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = CFGetAllocator(cf);
  CMTime time = *(CMTime *)(a1 + 28);
  CFStringRef v5 = CMTimeCopyDescription(v4, &time);
  int v6 = *(_DWORD *)(a1 + 24);
  if ((v6 - 1) > 0xE)
  {
    char v9 = 0;
    snprintf((char *)&time, 0xFFuLL, "%d", v6);
  }
  else
  {
    strncpy((char *)&time, off_1E5676350[v6 - 1], 0xFFuLL);
    char v9 = 0;
  }
  if (*(unsigned char *)(a1 + 64)) {
    CFAllocatorRef v7 = "true";
  }
  else {
    CFAllocatorRef v7 = "false";
  }
  CFStringAppendFormat(cf, 0, @"\n\t\tcondition: %s\n\t\tduration: %@\n\t\tcurrentValue: %s\n\t\tcallback: %p\n\t\trefCon: %p\n", &time, v5, v7, *(void *)a1, *(void *)(a1 + 8));
  CFStringAppendFormat(cf, 0, @"\t\thandler: %p\n", *(void *)(a1 + 16));
  if (v5) {
    CFRelease(v5);
  }
}

__CFString *FigTapToRadarComponentNameFromComponentIdentifier(int a1)
{
  if (a1 > 1019129)
  {
    if (a1 > 1507077)
    {
      if (a1 == 1507078) {
        return @"CoreMedia (New Bugs)";
      }
      if (a1 == 1507080) {
        return @"CoreMedia Formats";
      }
    }
    else
    {
      if (a1 == 1019130) {
        return @"MediaExperience (New Bugs)";
      }
      if (a1 == 1326216) {
        return @"CoreMedia Streaming (New Bugs)";
      }
    }
    return 0;
  }
  if (a1 == 629193) {
    return @"AirPlay (New Bugs)";
  }
  if (a1 != 629219)
  {
    if (a1 == 629221) {
      return @"CoreMedia Video Toolbox";
    }
    return 0;
  }
  return @"CoreMedia Playback";
}

__CFString *FigTapToRadarComponentVersionFromComponentIdentifier(int a1)
{
  uint64_t result = @"All";
  if (a1 <= 1019129)
  {
    unsigned int v4 = a1 - 629193;
    if (v4 > 0x1C || ((1 << v4) & 0x14000001) == 0) {
      return 0;
    }
  }
  else
  {
    if (a1 > 1507077)
    {
      if (a1 == 1507078) {
        return result;
      }
      int v3 = 1507080;
    }
    else
    {
      if (a1 == 1019130) {
        return result;
      }
      int v3 = 1326216;
    }
    if (a1 != v3) {
      return 0;
    }
  }
  return result;
}

uint64_t FigIsAllowedToTriggerTapToRadar()
{
  if (FigServer_IsMediaplaybackd()
    || FigServer_IsMediaparserd()
    || FigServer_IsAirplayd()
    || FigServer_IsVideocodecd()
    || FigServer_IsMediaserverd())
  {
    return 1;
  }
  else
  {
    return in_audio_mx_server_process();
  }
}

CFStringRef FigTapToRadarCreateRadarDescriptionString(const __CFAllocator *a1, CFStringRef format, ...)
{
  va_start(va, format);
  CFStringRef v3 = CFStringCreateWithFormatAndArguments(a1, 0, format, va);
  CFArrayRef v4 = FigCopyProcessNamesForGatheringDiagnosticsWithCoreMediaDiagnosticExtension();
  CFStringRef v5 = CFStringCreateWithFormat(a1, 0, @"[If you did anything related to media playback recently, please add details here]\n%@\n\nDiagnostics collected beyond a typical radar.\n -memory, thread and sandbox state of media-related daemons [%@]", v3, [(__CFArray *)v4 componentsJoinedByString:@", "]);
  if (v5)
  {
    if (!v3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  FigSignalErrorAt(4294947922, 0, 0, 0, 0, 0, 0);
  if (v3) {
LABEL_3:
  }
    CFRelease(v3);
LABEL_4:
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

uint64_t FigCanTriggerTapToRadar()
{
  uint64_t result = FigDebugIsInternalBuild();
  if (result)
  {
    uint64_t result = FigIsAllowedToTriggerTapToRadar();
    if (result) {
      return (Class)getTapToRadarServiceClass[0]() != 0;
    }
  }
  return result;
}

uint64_t FigTriggerTapToRadar(uint64_t a1, const __CFString *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v15 = 0;
  CFStringRef v8 = FigTapToRadarComponentNameFromComponentIdentifier(a4);
  char v9 = FigTapToRadarComponentVersionFromComponentIdentifier(a4);
  if (!FigDebugIsInternalBuild()) {
    return 4294947925;
  }
  if (!FigIsAllowedToTriggerTapToRadar()) {
    return 4294947926;
  }
  if (v8 && v9)
  {
    if (a2 && a3 && CFStringGetLength(a2) < 206)
    {
      uint64_t v10 = (void *)MEMORY[0x192FC5D30]();
      id v11 = objc_alloc_init((Class)getRadarDraftClass[0]());
      [v11 setTitle:objc_msgSend(NSString, "stringWithFormat:", @"[Automatic CoreMedia Diagnostics] %@", a2, v15)];
      [v11 setProblemDescription:a3];
      objc_msgSend(v11, "setComponent:", objc_msgSend(objc_alloc(getRadarComponentClass()), "initWithName:version:identifier:", v8, v9, a4));
      [v11 setClassification:0];
      [v11 setReproducibility:0];
      [v11 setIsUserInitiated:0];
      objc_msgSend(v11, "setDiagnosticExtensionIDs:", objc_msgSend(objc_alloc(MEMORY[0x1E4F1C978]), "initWithObjects:", @"com.apple.coremedia.CoreMediaDiagnostics.CoreMediaDiagnosticExtension", 0));
      objc_msgSend((id)objc_msgSend((Class)getTapToRadarServiceClass[0](), "shared"), "createDraft:forProcessNamed:withDisplayReason:error:", v11, @"CoreMedia", a1, &v15);
      uint64_t v12 = 0;
      if (NSErrorToOSStatus()) {
        uint64_t v12 = NSErrorToOSStatus();
      }
      return v12;
    }
    uint64_t v14 = 4294947923;
  }
  else
  {
    uint64_t v14 = 4294947924;
  }

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

Class initTapToRadarService()
{
  if (TapToRadarKitLibrary_sOnce != -1) {
    dispatch_once(&TapToRadarKitLibrary_sOnce, &__block_literal_global_2);
  }
  Class result = objc_getClass("TapToRadarService");
  classTapToRadarService = (uint64_t)result;
  getTapToRadarServiceClass[0] = TapToRadarServiceFunction;
  return result;
}

uint64_t TapToRadarServiceFunction()
{
  return classTapToRadarService;
}

void *__TapToRadarKitLibrary_block_invoke()
{
  Class result = dlopen("/AppleInternal/Library/Frameworks/TapToRadarKit.framework/TapToRadarKit", 2);
  TapToRadarKitLibrary_sLib = (uint64_t)result;
  return result;
}

Class initRadarDraft()
{
  if (TapToRadarKitLibrary_sOnce != -1) {
    dispatch_once(&TapToRadarKitLibrary_sOnce, &__block_literal_global_2);
  }
  Class result = objc_getClass("RadarDraft");
  classRadarDraft = (uint64_t)result;
  getRadarDraftClass[0] = RadarDraftFunction;
  return result;
}

uint64_t RadarDraftFunction()
{
  return classRadarDraft;
}

Class initRadarComponent()
{
  if (TapToRadarKitLibrary_sOnce != -1) {
    dispatch_once(&TapToRadarKitLibrary_sOnce, &__block_literal_global_2);
  }
  Class result = objc_getClass("RadarComponent");
  classRadarComponent = (uint64_t)result;
  getRadarComponentClass = RadarComponentFunction;
  return result;
}

uint64_t RadarComponentFunction()
{
  return classRadarComponent;
}

OSStatus CMTextFormatDescriptionGetDisplayFlags(CMFormatDescriptionRef desc, CMTextDisplayFlags *displayFlagsOut)
{
  if (desc)
  {
    CMMediaType MediaType = CMFormatDescriptionGetMediaType(desc);
    if (MediaType == 1668310898 || MediaType == 1935832172 || MediaType == 1952807028)
    {
      if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
        || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
        || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
        || CMFormatDescriptionGetMediaType(desc) == 1668310898
        || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
      {
        return -12718;
      }
      if (!displayFlagsOut) {
        return 0;
      }
      CFNumberRef Extension = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, @"DisplayFlags");
      if (Extension)
      {
        CFNumberRef v7 = Extension;
        CFTypeID v8 = CFGetTypeID(Extension);
        if (v8 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v7, kCFNumberSInt32Type, displayFlagsOut);
          return 0;
        }
      }
    }
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTextFormatDescriptionGetJustification(CMFormatDescriptionRef desc, CMTextJustificationValue *horizontaJustificationlOut, CMTextJustificationValue *verticalJustificationOut)
{
  if (!desc) {
    goto LABEL_23;
  }
  CMMediaType MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType != 1668310898 && MediaType != 1935832172 && MediaType != 1952807028) {
    goto LABEL_23;
  }
  if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
    || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
    || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
    || CMFormatDescriptionGetMediaType(desc) == 1668310898
    || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
  {
    return -12718;
  }
  if (!horizontaJustificationlOut) {
    goto LABEL_20;
  }
  if (CMFormatDescriptionGetMediaSubType(desc) != 1952807028)
  {
    CFNumberRef Extension = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, @"HorizontalJustification");
    if (Extension)
    {
      CFNumberRef v12 = Extension;
      CFTypeID v13 = CFGetTypeID(Extension);
      if (v13 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v12, kCFNumberSInt8Type, horizontaJustificationlOut);
        goto LABEL_20;
      }
    }
LABEL_23:
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  int valuePtr = 0;
  CFNumberRef v8 = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, @"TextJustification");
  if (!v8) {
    goto LABEL_23;
  }
  CFNumberRef v9 = v8;
  CFTypeID v10 = CFGetTypeID(v8);
  if (v10 != CFNumberGetTypeID()) {
    goto LABEL_23;
  }
  CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
  *horizontaJustificationlOut = valuePtr;
LABEL_20:
  if (!verticalJustificationOut) {
    return 0;
  }
  if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
  {
    OSStatus result = 0;
    *verticalJustificationOut = 0;
    return result;
  }
  CFNumberRef v14 = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, @"VerticalJustification");
  if (v14)
  {
    CFNumberRef v15 = v14;
    CFTypeID v16 = CFGetTypeID(v14);
    if (v16 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v15, kCFNumberSInt8Type, verticalJustificationOut);
      return 0;
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTextFormatDescriptionGetDefaultTextBox(CMFormatDescriptionRef desc, Boolean originIsAtTopLeft, CGFloat heightOfTextTrack, CGRect *defaultTextBoxOut)
{
  if (!desc) {
    goto LABEL_26;
  }
  int v6 = originIsAtTopLeft;
  CMMediaType MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType != 1668310898 && MediaType != 1935832172 && MediaType != 1952807028) {
    goto LABEL_26;
  }
  if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
    || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
    || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
    || CMFormatDescriptionGetMediaType(desc) == 1668310898
    || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
  {
    return -12718;
  }
  if (!defaultTextBoxOut) {
    return 0;
  }
  CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(desc, @"DefaultTextBox");
  if (Extension
    && (v11 = Extension, CFTypeID v12 = CFGetTypeID(Extension), v12 == CFDictionaryGetTypeID())
    && (CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(v11, @"Top")) != 0
    && (CFNumberRef v14 = v13, v15 = CFGetTypeID(v13), v15 == CFNumberGetTypeID()))
  {
    int v29 = 0;
    int valuePtr = 0;
    CFNumberGetValue(v14, kCFNumberSInt16Type, (char *)&valuePtr + 2);
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v11, @"Left");
    if (!Value) {
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
    CFNumberRef v17 = Value;
    CFTypeID v18 = CFGetTypeID(Value);
    if (v18 != CFNumberGetTypeID()) {
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
    CFNumberGetValue(v17, kCFNumberSInt16Type, &valuePtr);
    CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(v11, @"Bottom");
    if (!v19) {
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
    CFNumberRef v20 = v19;
    CFTypeID v21 = CFGetTypeID(v19);
    if (v21 == CFNumberGetTypeID()
      && (CFNumberGetValue(v20, kCFNumberSInt16Type, (char *)&v29 + 2),
          (CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v11, @"Right")) != 0)
      && (v23 = v22, CFTypeID v24 = CFGetTypeID(v22), v24 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v23, kCFNumberSInt16Type, &v29);
      int v25 = (__int16)valuePtr;
      int v26 = SHIWORD(valuePtr);
      CGFloat v27 = (double)(SHIWORD(v29) - SHIWORD(valuePtr));
      defaultTextBoxOut->size.width = (double)((__int16)v29 - (__int16)valuePtr);
      defaultTextBoxOut->size.height = v27;
      defaultTextBoxOut->origin.x = (double)v25;
      double v28 = (double)v26;
      OSStatus result = 0;
      if (!v6) {
        double v28 = heightOfTextTrack - v28;
      }
      defaultTextBoxOut->origin.y = v28;
    }
    else
    {
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
LABEL_26:
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMTextFormatDescriptionGetDefaultStyle(CMFormatDescriptionRef desc, uint16_t *localFontIDOut, Boolean *boldOut, Boolean *italicOut, Boolean *underlineOut, CGFloat *fontSizeOut, CGFloat *colorComponentsOut)
{
  if (!desc) {
    goto LABEL_34;
  }
  CMMediaType MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType != 1668310898 && MediaType != 1935832172 && MediaType != 1952807028) {
    goto LABEL_34;
  }
  if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
    || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
    || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
    || CMFormatDescriptionGetMediaType(desc) == 1668310898
    || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
  {
    return -12718;
  }
  CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(desc, @"DefaultStyle");
  if (!Extension) {
    goto LABEL_34;
  }
  CFDictionaryRef v17 = Extension;
  CFTypeID v18 = CFGetTypeID(Extension);
  if (v18 != CFDictionaryGetTypeID()) {
    goto LABEL_34;
  }
  if (localFontIDOut)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v17, @"Font");
    if (!Value) {
      goto LABEL_34;
    }
    CFNumberRef v20 = Value;
    CFTypeID v21 = CFGetTypeID(Value);
    if (v21 != CFNumberGetTypeID()) {
      goto LABEL_34;
    }
    CFNumberGetValue(v20, kCFNumberSInt16Type, localFontIDOut);
  }
  if (!boldOut && !italicOut && !underlineOut) {
    goto LABEL_29;
  }
  char valuePtr = 0;
  CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v17, @"FontFace");
  if (v22)
  {
    CFNumberRef v23 = v22;
    CFTypeID v24 = CFGetTypeID(v22);
    if (v24 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v23, kCFNumberSInt8Type, &valuePtr);
      if (boldOut) {
        *boldOut = valuePtr & 1;
      }
      if (italicOut) {
        *italicOut = (valuePtr & 2) != 0;
      }
      if (underlineOut) {
        *underlineOut = (valuePtr & 4) != 0;
      }
LABEL_29:
      if (fontSizeOut)
      {
        CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(v17, @"FontSize");
        if (!v25) {
          return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
        }
        CFNumberRef v26 = v25;
        CFTypeID v27 = CFGetTypeID(v25);
        if (v27 != CFNumberGetTypeID()) {
          return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
        }
        if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
        {
          __int16 v63 = 0;
          CFNumberGetValue(v26, kCFNumberSInt16Type, &v63);
          int v28 = v63;
        }
        else
        {
          char v62 = 0;
          CFNumberGetValue(v26, kCFNumberSInt8Type, &v62);
          int v28 = v62;
        }
        *fontSizeOut = (double)v28;
      }
      if (!colorComponentsOut) {
        return 0;
      }
      CFDictionaryRef v29 = (const __CFDictionary *)CFDictionaryGetValue(v17, @"ForegroundColor");
      if (v29)
      {
        CFDictionaryRef v30 = v29;
        CFTypeID v31 = CFGetTypeID(v29);
        if (v31 == CFDictionaryGetTypeID())
        {
          if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
          {
            __int16 v61 = 0;
            CFNumberRef v32 = (const __CFNumber *)CFDictionaryGetValue(v30, @"Red");
            if (v32)
            {
              CFNumberRef v33 = v32;
              CFTypeID v34 = CFGetTypeID(v32);
              if (v34 == CFNumberGetTypeID())
              {
                CFNumberGetValue(v33, kCFNumberSInt16Type, &v61);
                LOWORD(v35) = v61;
                *colorComponentsOut = (double)v35 / 65535.0;
                CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(v30, @"Green");
                if (v36)
                {
                  CFNumberRef v37 = v36;
                  CFTypeID v38 = CFGetTypeID(v36);
                  if (v38 == CFNumberGetTypeID())
                  {
                    CFNumberGetValue(v37, kCFNumberSInt16Type, &v61);
                    LOWORD(v39) = v61;
                    colorComponentsOut[1] = (double)v39 / 65535.0;
                    CFNumberRef v40 = (const __CFNumber *)CFDictionaryGetValue(v30, @"Blue");
                    if (v40)
                    {
                      CFNumberRef v41 = v40;
                      CFTypeID v42 = CFGetTypeID(v40);
                      if (v42 == CFNumberGetTypeID())
                      {
                        CFNumberGetValue(v41, kCFNumberSInt16Type, &v61);
                        OSStatus result = 0;
                        LOWORD(v43) = v61;
                        colorComponentsOut[2] = (double)v43 / 65535.0;
                        colorComponentsOut[3] = 1.0;
                        return result;
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            char v60 = 0;
            CFNumberRef v44 = (const __CFNumber *)CFDictionaryGetValue(v30, @"Red");
            if (v44)
            {
              CFNumberRef v45 = v44;
              CFTypeID v46 = CFGetTypeID(v44);
              if (v46 == CFNumberGetTypeID())
              {
                CFNumberGetValue(v45, kCFNumberSInt8Type, &v60);
                LOBYTE(v47) = v60;
                *colorComponentsOut = (double)v47 / 255.0;
                CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(v30, @"Green");
                if (v48)
                {
                  CFNumberRef v49 = v48;
                  CFTypeID v50 = CFGetTypeID(v48);
                  if (v50 == CFNumberGetTypeID())
                  {
                    CFNumberGetValue(v49, kCFNumberSInt8Type, &v60);
                    LOBYTE(v51) = v60;
                    colorComponentsOut[1] = (double)v51 / 255.0;
                    CFNumberRef v52 = (const __CFNumber *)CFDictionaryGetValue(v30, @"Blue");
                    if (v52)
                    {
                      CFNumberRef v53 = v52;
                      CFTypeID v54 = CFGetTypeID(v52);
                      if (v54 == CFNumberGetTypeID())
                      {
                        CFNumberGetValue(v53, kCFNumberSInt8Type, &v60);
                        LOBYTE(v55) = v60;
                        colorComponentsOut[2] = (double)v55 / 255.0;
                        CFNumberRef v56 = (const __CFNumber *)CFDictionaryGetValue(v30, @"Alpha");
                        if (v56)
                        {
                          CFNumberRef v57 = v56;
                          CFTypeID v58 = CFGetTypeID(v56);
                          if (v58 == CFNumberGetTypeID())
                          {
                            CFNumberGetValue(v57, kCFNumberSInt8Type, &v60);
                            OSStatus result = 0;
                            LOBYTE(v59) = v60;
                            colorComponentsOut[3] = (double)v59 / 255.0;
                            return result;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
  }
LABEL_34:

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTextFormatDescriptionGetFontName(CMFormatDescriptionRef desc, uint16_t localFontID, CFStringRef *fontNameOut)
{
  if (desc)
  {
    if (fontNameOut)
    {
      unsigned int v4 = localFontID;
      CMMediaType MediaType = CMFormatDescriptionGetMediaType(desc);
      if (MediaType == 1668310898 || MediaType == 1935832172 || MediaType == 1952807028)
      {
        if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
          || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
          || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
          || CMFormatDescriptionGetMediaType(desc) == 1668310898
          || CMFormatDescriptionGetMediaType(desc) == 1952807028
          && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
        {
          return -12718;
        }
        *fontNameOut = 0;
        if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
        {
          CFStringRef Extension = (const __CFString *)CMFormatDescriptionGetExtension(desc, @"DefaultFontName");
          if (Extension)
          {
            CFStringRef v10 = Extension;
            CFTypeID v11 = CFGetTypeID(Extension);
            if (v11 == CFStringGetTypeID())
            {
              OSStatus v7 = 0;
              *fontNameOut = v10;
              return v7;
            }
          }
        }
        else
        {
          CFDictionaryRef v12 = (const __CFDictionary *)CMFormatDescriptionGetExtension(desc, @"FontTable");
          if (v12)
          {
            CFDictionaryRef v13 = v12;
            CFTypeID v14 = CFGetTypeID(v12);
            if (v14 == CFDictionaryGetTypeID())
            {
              CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%d", v4);
              if (v15)
              {
                CFStringRef v16 = v15;
                CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v13, v15);
                if (Value && (v18 = Value, CFTypeID v19 = CFGetTypeID(Value), v19 == CFStringGetTypeID()))
                {
                  OSStatus v7 = 0;
                  *fontNameOut = v18;
                }
                else
                {
                  OSStatus v7 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
                }
                CFRelease(v16);
                return v7;
              }
            }
          }
        }
      }
    }
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

void sub_18FD46114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18FD46474(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

uint64_t FigPurgeAndRenewProcessStateTrackerGetPurgeEligibilityForPID(uint64_t a1, char *a2)
{
  uint64_t v3 = [NSNumber numberWithUnsignedInt:a1];
  if (a2)
  {
    uint64_t v4 = v3;
    if (_os_feature_enabled_impl())
    {
      uint64_t v5 = [(id)sProcessStateTrackingContexts objectForKey:v4];
      if (v5)
      {
        char v6 = [*(id *)(v5 + 8) purgeSuspended];
        uint64_t v7 = 0;
LABEL_5:
        *a2 = v6;
        return v7;
      }
      uint64_t v7 = FigSignalErrorAt(4294947824, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      uint64_t v7 = 0;
    }
    char v6 = 1;
    goto LABEL_5;
  }

  return FigSignalErrorAt(4294947826, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPurgeAndRenewProcessStateTrackerModifyPurgeEligibilityForPID(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [NSNumber numberWithUnsignedInt:a1];
  if (!_os_feature_enabled_impl()) {
    return 0;
  }
  uint64_t v4 = [(id)sProcessStateTrackingContexts objectForKey:v3];
  if (v4)
  {
    if ([*(id *)(v4 + 8) setPurgeSuspended:a2]) {
      return 0;
    }
    uint64_t v6 = 4294947823;
  }
  else
  {
    uint64_t v6 = 4294947824;
  }

  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

void FigPurgeAndRenewProcessStateTrackerStartTrackingPIDWithBlock(int a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x192FC5D30]();
  unsigned int v5 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigPurgeAndRenewProcessStateTracker[1], @"processtatetracker_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v5, 0, gFigPurgeAndRenewProcessStateTracker);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272DB8, @"processtatetracker_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272DB0);
  if (_os_feature_enabled_impl()
    && FigGetCFPreferenceNumberWithDefault(@"purge_timeout_seconds", @"com.apple.coremedia", 600))
  {
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2020000000;
    int v9 = 0;
    if (ensureProcessStateTrackerDispatchQExists_sProcessStateTrackerDispatchQueueInitializer != -1) {
      dispatch_once(&ensureProcessStateTrackerDispatchQExists_sProcessStateTrackerDispatchQueueInitializer, &__block_literal_global_3);
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __startProcessStateTracking_block_invoke;
    block[3] = &unk_1E5676500;
    int v7 = a1;
    block[4] = a2;
    void block[5] = v8;
    dispatch_sync((dispatch_queue_t)sProcessStateTrackerDispatchQueue, block);
    _Block_object_dispose(v8, 8);
  }
}

void FigPurgeAndRenewProcessStateTrackerStartTrackingPID(int a1)
{
}

uint64_t FigPurgeAndRenewProcessStateTrackerGetTrackedState(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x192FC5D30]();
  uint64_t v3 = [NSNumber numberWithUnsignedInt:a1];
  uint64_t v4 = [(id)sProcessStateTrackingContexts objectForKey:v3];
  if (v4)
  {
    if ([*(id *)(v4 + 8) isProcessStateSuspended]) {
      uint64_t v5 = 2;
    }
    else {
      uint64_t v5 = 1;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  return v5;
}

uint64_t __startProcessStateTracking_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = [NSNumber numberWithUnsignedInt:v2];
  if ([(id)sProcessStateTrackingContexts objectForKey:v4]) {
    [(id)sProcessStateTrackingContexts removeObjectForKey:v4];
  }
  id v5 = +[FigPurgeAndRenewPurgeOperator operatorForClientPID:v2 notificationQueue:sProcessStateTrackerDispatchQueue withPurgeBlock:v3];
  if (!v5) {
    goto LABEL_9;
  }
  id v6 = v5;
  id v7 = [[ProcessStateTracker alloc] initForClientPID:v2 withOperator:v5];
  if (!v7) {
    goto LABEL_9;
  }
  CFNumberRef v8 = v7;
  int v9 = objc_alloc_init(ProcessStateTrackingContext);
  if (!v9) {
    goto LABEL_9;
  }
  CFStringRef v10 = v9;
  CFTypeID v11 = (void *)[MEMORY[0x1E4F28EB8] defaultCenter];
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  int v13[2] = __startProcessTrackerOnQueue_block_invoke;
  v13[3] = &unk_1E5676528;
  v13[4] = v4;
  v10->token = [v11 addObserverForName:@"FigProcessStateTrackerClientProcessIsTerminated" object:v6 queue:0 usingBlock:v13];
  if (![v8 isProcessTerminated])
  {
    v10->tracker = (ProcessStateTracker *)v8;
    [(id)sProcessStateTrackingContexts setObject:v10 forKey:v4];
    uint64_t result = 0;
  }
  else
  {
LABEL_9:
    uint64_t result = FigSignalErrorAt(4294947825, 0, 0, 0, 0, 0, 0);
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t __ensureProcessStateTrackerDispatchQExists_block_invoke()
{
  uid_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  sProcessStateTrackerDispatchQueue = (uint64_t)dispatch_queue_create("com.apple.coremedia.pnrq", v0);
  uint64_t result = objc_opt_new();
  sProcessStateTrackingContexts = result;
  return result;
}

void __startProcessTrackerOnQueue_block_invoke(uint64_t a1)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __startProcessTrackerOnQueue_block_invoke_2;
  block[3] = &unk_1E5676460;
  block[4] = *(void *)(a1 + 32);
  dispatch_async((dispatch_queue_t)sProcessStateTrackerDispatchQueue, block);
}

void __startProcessTrackerOnQueue_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = (id)[(id)sProcessStateTrackingContexts objectForKey:v1];
  if (v2)
  {
    id v3 = v2;
    [(id)sProcessStateTrackingContexts removeObjectForKey:v1];
  }
}

uint64_t defaultBlock_block_invoke(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (dword_1E9272DB8)
  {
    v10[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DB0, 1, v10, &type);
    int v4 = v10[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v6 = v4;
    }
    else {
      unsigned int v6 = v4 & 0xFFFFFFFE;
    }
    if (v6)
    {
      v10[1] = 136315394;
      CFTypeID v11 = "defaultBlock_block_invoke";
      __int16 v12 = 1024;
      int v13 = a2;
      id v7 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v4) = v10[0];
    }
    else
    {
      id v7 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DB0, 1u, 1, v7, v7 != &v14, v4, 0, v5);
  }
  return FigXPCPurgeObjectsForPIDWithReportingBlock(a2, (uint64_t)&__block_literal_global_103);
}

uint64_t FigCAStatsReportingSubmitData(const void *a1, uint64_t a2, uint64_t a3, double a4)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  if (frcs_initOnce_onceToken != -1) {
    dispatch_once(&frcs_initOnce_onceToken, &__block_literal_global_4);
  }
  uint64_t v8 = 0;
  if (a1 && gFigCAStatsDispatchQueue)
  {
    int v9 = (void *)MEMORY[0x192FC5D30]();
    if (a3)
    {
      v20[1] = a3;
      v21[0] = a1;
      v20[0] = @"appName";
      v21[1] = [NSNumber numberWithDouble:a4];
      CFStringRef v10 = (void *)MEMORY[0x1E4F1C9E8];
      CFTypeID v11 = (const void **)v21;
      __int16 v12 = (__CFString **)v20;
      uint64_t v13 = 2;
    }
    else
    {
      CFStringRef v18 = @"appName";
      CFTypeID v19 = a1;
      CFStringRef v10 = (void *)MEMORY[0x1E4F1C9E8];
      CFTypeID v11 = &v19;
      __int16 v12 = &v18;
      uint64_t v13 = 1;
    }
    uint64_t v14 = [v10 dictionaryWithObjects:v11 forKeys:v12 count:v13];
    if (v14)
    {
      CFTypeRef v15 = CFRetain(a1);
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 3221225472;
      _OWORD v17[2] = __FigCAStatsReportingSubmitData_block_invoke;
      _OWORD v17[3] = &unk_1E56765F8;
      v17[4] = v14;
      v17[5] = a2;
      v17[6] = v15;
      dispatch_async((dispatch_queue_t)gFigCAStatsDispatchQueue, v17);
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = 4294954510;
    }
  }
  return v8;
}

void __FigCAStatsReportingSubmitData_block_invoke(uint64_t a1)
{
  AnalyticsSendEvent();
  id v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
  }
}

dispatch_queue_t __frcs_initOnce_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.coremedia.FigReportingCAStats", 0);
  gFigCAStatsDispatchQueue = (uint64_t)result;
  return result;
}

uint64_t FigAudioDeviceSupportsPresentationTime(AudioObjectID inObjectID)
{
  v3.mElement = 0;
  *(void *)&v3.AudioObjectPropertySelector mSelector = *(void *)"tptbbolg";
  if (sCheckTraceOnceToken != -1)
  {
    dispatch_once(&sCheckTraceOnceToken, &__block_literal_global_5);
    if (inObjectID) {
      return AudioObjectHasProperty(inObjectID, &v3);
    }
LABEL_6:
    FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!inObjectID) {
    goto LABEL_6;
  }
  return AudioObjectHasProperty(inObjectID, &v3);
}

uint64_t FigAudioDeviceGetCurrentPresentationTime(AudioObjectID inObjectID, uint64_t a2)
{
  UInt32 outDataSize = 0;
  memset(v5, 0, sizeof(v5));
  if (sCheckTraceOnceToken == -1)
  {
    if (!a2) {
      goto LABEL_10;
    }
  }
  else
  {
    dispatch_once(&sCheckTraceOnceToken, &__block_literal_global_3);
    if (!a2) {
      goto LABEL_10;
    }
  }
  if (inObjectID)
  {
    uint64_t result = AudioObjectGetPropertyDataSize(inObjectID, (const AudioObjectPropertyAddress *)"tptbbolg", 0, 0, &outDataSize);
    if (!result)
    {
      if (outDataSize == 40)
      {
        uint64_t result = AudioObjectGetPropertyData(inObjectID, (const AudioObjectPropertyAddress *)"tptbbolg", 0, 0, &outDataSize, v5);
        if (!result)
        {
          *(void *)a2 = *(void *)v5;
          *(_OWORD *)(a2 + 8) = *(_OWORD *)&v5[8];
          *(_OWORD *)(a2 + 24) = *(_OWORD *)&v5[24];
        }
      }
      else
      {
        return FigSignalErrorAt(4294949374, 0, 0, 0, 0, 0, 0);
      }
    }
    return result;
  }
LABEL_10:

  return FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioDeviceGetCurrentDynamicLatency(AudioObjectID inObjectID, CMTime *a2)
{
  uint64_t v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  double outData = NAN;
  *(void *)&inAddress.AudioObjectPropertySelector mSelector = *(void *)"trsnptuo";
  inAddress.mElement = 0;
  if (sCheckTraceOnceToken == -1)
  {
    if (a2)
    {
LABEL_3:
      uint64_t result = FigAudioDeviceGetCurrentPresentationTime(inObjectID, (uint64_t)&v12);
      if (!result)
      {
        double v5 = *((double *)&v12 + 1);
        double v6 = *(double *)&v13;
        UInt32 ioDataSize = 8;
        uint64_t result = AudioObjectGetPropertyData(inObjectID, &inAddress, 0, 0, &ioDataSize, &outData);
        if (!result)
        {
          double v7 = v5 - v6;
          if (v5 - v6 < 0.0) {
            double v7 = -(v5 - v6);
          }
          CMTimeMake(&v8, (uint64_t)v7, (int)outData);
          uint64_t result = 0;
          *a2 = v8;
        }
      }
      return result;
    }
  }
  else
  {
    dispatch_once(&sCheckTraceOnceToken, &__block_literal_global_6_0);
    if (a2) {
      goto LABEL_3;
    }
  }

  return FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionDataGetClassID()
{
  return sFigCaptionDataClassID;
}

uint64_t RegisterFigCaptionDataBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigCaptionDataClassDesc, ClassID, 1, &sFigCaptionDataClassID);
}

uint64_t FigCaptionDataGetTypeID()
{
  FigThreadRunOnce(&FigCaptionDataGetClassID_sRegisterFigCaptionDataBaseTypeOnce, (void (*)(void))RegisterFigCaptionDataBaseType);
  uid_t v0 = (void *)sFigCaptionDataClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigCaptionDataCreate(const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    if (a3)
    {
      uint64_t v5 = FigCaptionDataCreateMutable(a1, &cf);
      if (!v5)
      {
        CFTypeRef v6 = cf;
        uint64_t v7 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 16);
        if (v7) {
          uint64_t v8 = v7;
        }
        else {
          uint64_t v8 = 0;
        }
        int v9 = *(uint64_t (**)(CFTypeRef, uint64_t))(v8 + 16);
        if (v9)
        {
          uint64_t v10 = v9(v6, a2);
          if (!v10)
          {
            *a3 = cf;
            return v10;
          }
        }
        else
        {
          uint64_t v10 = 4294954514;
        }
LABEL_11:
        if (cf) {
          CFRelease(cf);
        }
        return v10;
      }
    }
    else
    {
      uint64_t v5 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v10 = v5;
    goto LABEL_11;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionDataCopySubrange(const __CFAllocator *a1, uint64_t a2, CFIndex a3, CFIndex a4, CFTypeRef *a5)
{
  CFArrayRef theArray = 0;
  CFTypeRef v51 = 0;
  CFTypeRef cf = 0;
  if (!a2)
  {
    uint64_t v41 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    CFStringRef v17 = 0;
    goto LABEL_49;
  }
  uint64_t v5 = a5;
  if (!a5
    || ((uint64_t v10 = *(void *)(CMBaseObjectGetVTable(a2) + 16)) == 0 ? (v11 = 0) : (v11 = v10),
        (long long v12 = *(uint64_t (**)(uint64_t))(v11 + 8)) == 0
      ? (CFStringRef v13 = &stru_1EDF73CD0)
      : (CFStringRef v13 = (const __CFString *)v12(a2)),
        (CFIndex Length = CFStringGetLength(v13), a3 < 0) || a3 + a4 > Length))
  {
    uint64_t v15 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_60;
  }
  uint64_t v15 = FigCaptionDataCreateMutable(a1, &v51);
  if (v15)
  {
LABEL_60:
    uint64_t v41 = v15;
    CFStringRef v17 = 0;
    goto LABEL_47;
  }
  uint64_t v16 = *MEMORY[0x1E4F1CF80];
  v52.location = a3;
  v52.length = a4;
  CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v13, v52);
  CFTypeRef v18 = v51;
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable((uint64_t)v51) + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  CFTypeID v21 = *(uint64_t (**)(CFTypeRef, CFStringRef))(v20 + 16);
  if (!v21)
  {
LABEL_46:
    uint64_t v41 = 4294954514;
    goto LABEL_47;
  }
  uint64_t v22 = v21(v18, v17);
  if (!v22)
  {
    uint64_t v23 = *(void *)(CMBaseObjectGetVTable(a2) + 8);
    if (v23) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 0;
    }
    CFNumberRef v25 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFArrayRef *))(v24 + 48);
    if (v25)
    {
      CFStringRef v45 = v17;
      uint64_t v26 = v25(a2, @"StylePropertyKeysInUse", v16, &theArray);
      if (v26)
      {
LABEL_58:
        uint64_t v41 = v26;
      }
      else if (theArray && (CFIndex Count = CFArrayGetCount(theArray)) != 0)
      {
        CFIndex v27 = 0;
        CFTypeID v46 = v5;
        while (1)
        {
          CFIndex v44 = v27;
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, v27);
          if (a4 >= 1) {
            break;
          }
LABEL_44:
          CFIndex v27 = v44 + 1;
          if (v44 + 1 == Count) {
            goto LABEL_45;
          }
        }
        CFDictionaryRef v29 = ValueAtIndex;
        CFIndex v30 = a3;
        while (1)
        {
          uint64_t v47 = 0;
          uint64_t v48 = 0;
          if (cf)
          {
            CFRelease(cf);
            CFTypeRef cf = 0;
          }
          uint64_t v31 = *(void *)(CMBaseObjectGetVTable(a2) + 16);
          uint64_t v32 = v31 ? v31 : 0;
          CFNumberRef v33 = *(uint64_t (**)(uint64_t, CFIndex, const void *, uint64_t, CFTypeRef *, uint64_t *))(v32 + 24);
          if (!v33) {
            break;
          }
          uint64_t v26 = v33(a2, v30, v29, v16, &cf, &v47);
          if (v26) {
            goto LABEL_58;
          }
          CFTypeRef v34 = cf;
          if (cf)
          {
            uint64_t v35 = (v47 - a3) & ~((v47 - a3) >> 63);
            if (((v47 - a3) & ((v47 - a3) >> 63)) + v48 + v35 <= a4) {
              CFIndex v36 = ((v47 - a3) & ((v47 - a3) >> 63)) + v48;
            }
            else {
              CFIndex v36 = a4 - v35;
            }
            CFTypeRef v37 = v51;
            uint64_t v38 = *(void *)(CMBaseObjectGetVTable((uint64_t)v51) + 16);
            if (v38) {
              uint64_t v39 = v38;
            }
            else {
              uint64_t v39 = 0;
            }
            CFNumberRef v40 = *(uint64_t (**)(CFTypeRef, const void *, CFTypeRef, uint64_t, CFIndex))(v39 + 32);
            if (!v40) {
              break;
            }
            uint64_t v26 = v40(v37, v29, v34, v35, v36);
            uint64_t v5 = v46;
            if (v26) {
              goto LABEL_58;
            }
          }
          CFIndex v30 = v48 + v47;
          if (v48 + v47 >= a3 + a4) {
            goto LABEL_44;
          }
        }
        uint64_t v41 = 4294954514;
      }
      else
      {
LABEL_45:
        uint64_t v41 = 0;
        CFTypeRef *v5 = v51;
        CFTypeRef v51 = 0;
      }
      CFStringRef v17 = v45;
      goto LABEL_47;
    }
    goto LABEL_46;
  }
  uint64_t v41 = v22;
LABEL_47:
  if (cf) {
    CFRelease(cf);
  }
LABEL_49:
  if (theArray) {
    CFRelease(theArray);
  }
  if (v51) {
    CFRelease(v51);
  }
  if (v17) {
    CFRelease(v17);
  }
  return v41;
}

CFStringRef FigCaptionDataCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionData %p]", a1);
}

uint64_t FigProcessStateMonitorServerEnsureStartedAndCopyEndpoint(void *a1)
{
  uint64_t v5 = 0;
  if (!a1)
  {
    uint64_t v2 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  if (FigProcessStateMonitorEnsureServerStarted_sStartStateMonitorServerOnce != -1) {
    dispatch_once(&FigProcessStateMonitorEnsureServerStarted_sStartStateMonitorServerOnce, &__block_literal_global_6);
  }
  uint64_t v2 = FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult;
  if (FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult) {
    goto LABEL_7;
  }
  uint64_t v2 = FigXPCServerCopyXPCEndpoint(gFigProcessMonitorServer, &v5);
  AudioObjectPropertyAddress v3 = v5;
  if (!v2)
  {
    *a1 = v5;
    uint64_t v5 = 0;
LABEL_7:
    AudioObjectPropertyAddress v3 = 0;
  }
  FigXPCRelease(v3);
  return v2;
}

uint64_t FigProcessStateMonitorInformRemotesOfIndirectDependencyDeath(uint64_t a1)
{
  return FigCFWeakReferenceTableApplyFunction(gServedObjects, (void (*)(void, CFTypeRef, uint64_t))figProcessStateMonitorInformRemoteOfIndirectDependencyDeathApply, a1);
}

uint64_t figProcessStateMonitorInformRemoteOfIndirectDependencyDeathApply(uint64_t a1, const void *a2, const __CFDictionary *a3)
{
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterPostNotification(DefaultLocalCenter, @"MediaServicesProcessDeath", a2, a3);
}

uint64_t FigProcessStateMonitorPurgePreventionAssertionGetTypeID()
{
  if (FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce != -1) {
    dispatch_once_f(&FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce, 0, (dispatch_function_t)registerFigProcessStateMonitorPurgePreventionAssertionType);
  }
  return sFigProcessStateMonitorPurgePreventionAssertionID;
}

uint64_t registerFigProcessStateMonitorPurgePreventionAssertionType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigProcessStateMonitorPurgePreventionAssertionID = result;
  return result;
}

uint64_t FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID(int a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 0;
  uint64_t result = fpsmServer_copyCompanionForPID(a1, &v22);
  if (!result)
  {
    uint64_t v8 = (dispatch_queue_t *)v22;
    if (*(unsigned char *)(v22 + 80))
    {
      uint64_t result = figProcessStateMonitorMustNotPurgeClientObjects(v22, a2);
      if (!result)
      {
        if (FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce != -1) {
          dispatch_once_f(&FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce, 0, (dispatch_function_t)registerFigProcessStateMonitorPurgePreventionAssertionType);
        }
        uint64_t Instance = (void *)_CFRuntimeCreateInstance();
        if (Instance || (uint64_t result = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0), !result))
        {
          if (dword_1E9272DD8)
          {
            int v21 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v21, &type);
            int v11 = v21;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v13 = v11;
            }
            else {
              unsigned int v13 = v11 & 0xFFFFFFFE;
            }
            if (v13)
            {
              int v23 = 136315650;
              uint64_t v24 = "FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID";
              __int16 v25 = 2112;
              uint64_t v26 = Instance;
              __int16 v27 = 2048;
              uint64_t v28 = a3;
              uint64_t v14 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v11) = v21;
            }
            else
            {
              uint64_t v14 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v14, v14 != &v29, v11, 0, v12);
          }
          uint64_t v15 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v8[3]);
          dispatch_time_t v16 = dispatch_time(0, 1000000000 * a3);
          dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
          CFStringRef v17 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)Instance);
          dispatch_set_context(v15, v17);
          dispatch_set_finalizer_f(v15, (dispatch_function_t)figProcessStateMonitorPurgePreventionAssertionTimeoutFinalizer);
          handler[0] = MEMORY[0x1E4F143A8];
          handler[1] = 3221225472;
          handler[2] = __FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID_block_invoke;
          handler[3] = &unk_1E5676460;
          handler[4] = v15;
          dispatch_source_set_event_handler(v15, handler);
          Instance[5] = v15;
          if (a2) {
            CFTypeRef v18 = CFRetain(a2);
          }
          else {
            CFTypeRef v18 = 0;
          }
          Instance[3] = v18;
          Instance[4] = CFRetain(v8);
          dispatch_activate(v15);
          uint64_t result = 0;
          *a4 = Instance;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t fpsmServer_copyCompanionForPID(int a1, void *a2)
{
  CFTypeRef cf = 0;
  uint64_t v4 = FigCFWeakReferenceTableCopyValues(gServedObjects, (CFMutableDictionaryRef *)&cf);
  if (v4) {
    goto LABEL_16;
  }
  CFArrayRef v5 = FigCFDictionaryCopyArrayOfKeys((const __CFDictionary *)cf);
  if (!v5)
  {
    uint64_t v4 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
LABEL_16:
    uint64_t v11 = v4;
    goto LABEL_12;
  }
  CFArrayRef v6 = v5;
  if (CFArrayGetCount(v5) < 1)
  {
LABEL_9:
    uint64_t v11 = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFIndex v7 = 0;
    while (1)
    {
      CFTypeRef v8 = cf;
      ValueAtIndex = CFArrayGetValueAtIndex(v6, v7);
      CFStringRef Value = FigCFDictionaryGetValue(v8, ValueAtIndex);
      if (Value) {
        CFStringRef Value = CFRetain(Value);
      }
      if (Value[4] == a1) {
        break;
      }
      CFRelease(Value);
      if (++v7 >= CFArrayGetCount(v6)) {
        goto LABEL_9;
      }
    }
    uint64_t v11 = 0;
    *a2 = Value;
  }
  CFRelease(v6);
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t figProcessStateMonitorMustNotPurgeClientObjects(uint64_t a1, const void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    if (dword_1E9272DD8)
    {
      v12[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, v12, &type);
      int v5 = v12[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v7 = v5;
      }
      else {
        unsigned int v7 = v5 & 0xFFFFFFFE;
      }
      if (v7)
      {
        v12[1] = 136315650;
        unsigned int v13 = "figProcessStateMonitorMustNotPurgeClientObjects";
        __int16 v14 = 2114;
        uint64_t v15 = a1;
        __int16 v16 = 2114;
        CFStringRef v17 = a2;
        CFTypeRef v8 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v5) = v12[0];
      }
      else
      {
        CFTypeRef v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v8, v8 != &v18, v5, 0, v6);
    }
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 64));
    uint64_t v9 = FigPurgeAndRenewProcessStateTrackerModifyPurgeEligibilityForPID(*(unsigned int *)(a1 + 16), 1);
    if (!v9)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), a2);
      *(unsigned char *)(a1 + 56) = 0;
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    return v9;
  }
  else
  {
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  }
}

void figProcessStateMonitorPurgePreventionAssertionTimeoutFinalizer(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void __FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  context = (id *)dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject(context);
  if (v2)
  {
    AudioObjectPropertyAddress v3 = v2;
    if (!*((unsigned char *)v2 + 16))
    {
      if (dword_1E9272DD8)
      {
        v11[0] = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, v11, &type);
        int v5 = v11[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v7 = v5;
        }
        else {
          unsigned int v7 = v5 & 0xFFFFFFFE;
        }
        if (v7)
        {
          v11[1] = 136315394;
          uint64_t v12 = "FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID_block_invoke";
          __int16 v13 = 2112;
          __int16 v14 = v3;
          CFTypeRef v8 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v5) = v11[0];
        }
        else
        {
          CFTypeRef v8 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v8, v8 != &v15, v5, 0, v6);
      }
      figProcessStateMonitorMayPurgeClientObjects((uint64_t)v3[4], v3[3]);
      *((unsigned char *)v3 + 16) = 1;
      uint64_t v9 = v3[5];
      if (v9)
      {
        dispatch_release(v9);
        v3[5] = 0;
      }
    }
    CFRelease(v3);
  }
}

uint64_t figProcessStateMonitorMayPurgeClientObjects(uint64_t a1, const void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 64));
    FirstIndexOfCFStringRef Value = FigCFArrayGetFirstIndexOfValue(*(const __CFArray **)(a1 + 48), a2);
    if (FirstIndexOfValue == -1)
    {
      FigSignalErrorAt(4294947863, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      CFIndex v5 = FirstIndexOfValue;
      if (dword_1E9272DD8)
      {
        int v19 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v19, &type);
        int v7 = v19;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v9 = v7;
        }
        else {
          unsigned int v9 = v7 & 0xFFFFFFFE;
        }
        if (v9)
        {
          int v20 = 136315650;
          int v21 = "figProcessStateMonitorMayPurgeClientObjects";
          __int16 v22 = 2114;
          uint64_t v23 = a1;
          __int16 v24 = 2114;
          __int16 v25 = a2;
          uint64_t v10 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v7) = v19;
        }
        else
        {
          uint64_t v10 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v10, v10 != v26, v7, 0, v8);
      }
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 48), v5);
      CFArrayRef v11 = *(const __CFArray **)(a1 + 48);
      if ((!v11 || !CFArrayGetCount(v11))
        && !FigPurgeAndRenewProcessStateTrackerModifyPurgeEligibilityForPID(*(unsigned int *)(a1 + 16), 0))
      {
        *(unsigned char *)(a1 + 56) = 1;
        if (dword_1E9272DD8)
        {
          int v19 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          uint64_t v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v19, &type);
          int v13 = v19;
          if (os_log_type_enabled(v12, type)) {
            unsigned int v15 = v13;
          }
          else {
            unsigned int v15 = v13 & 0xFFFFFFFE;
          }
          if (v15)
          {
            int v20 = 136315394;
            int v21 = "figProcessStateMonitorMayPurgeClientObjects";
            __int16 v22 = 2114;
            uint64_t v23 = a1;
            uint64_t v16 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v13) = v19;
          }
          else
          {
            uint64_t v16 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v16, v16 != v26, v13, 0, v14);
        }
      }
    }
    return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  }
  else
  {
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  }
}

void __FigProcessStateMonitorEnsureServerStarted_block_invoke()
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  v11[0] = 1;
  v11[1] = FigProcessStateMonitor_handleMessage;
  int v11[2] = FigProcessStateMonitor_noReplyHandleMessage;
  memset(&v11[3], 0, 24);
  unsigned int v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigProcessStateMonitorServerTrace[1], @"figprocessstatemonitor_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigProcessStateMonitorServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272DD8, @"figprocessstatemonitor_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272DD0);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFMutableDictionaryRef v2 = Mutable;
    FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult = FigXPCServerStartWithNewXPCEndpoint((uint64_t)"ProcessStateMonitorServer", v11, (uint64_t)Mutable, &gFigProcessMonitorServer);
    if (!FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult)
    {
      CFAllocatorRef Default = CFAllocatorGetDefault();
      FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult = FigCFWeakReferenceTableCreate(Default, 1, &gServedObjects);
    }
    CFRelease(v2);
  }
  else
  {
    FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
  if (dword_1E9272DD8)
  {
    int v10 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v10, &type);
    int v5 = v10;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      int v12 = 136315394;
      int v13 = "FigProcessStateMonitorEnsureServerStarted_block_invoke";
      __int16 v14 = 1024;
      int v15 = FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v10;
    }
    else
    {
      uint64_t v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v8, v8 != &v16, v5, 0, v6);
  }
}

uint64_t FigProcessStateMonitor_handleMessage(_xpc_connection_s *a1, xpc_object_t xdict, void *a3)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v32 = 0;
  CFNumberRef v33 = &v32;
  uint64_t v34 = 0x2020000000;
  int v35 = 0;
  int v31 = 0;
  uint64 = (void *)xpc_dictionary_get_uint64(xdict, ".objectID");
  uint64_t OpCode = FigXPCMessageGetOpCode(xdict, &v31);
  *((_DWORD *)v33 + 6) = OpCode;
  if (!OpCode)
  {
    if (v31 == 1668441460)
    {
      uint64_t value = 0;
      pid_t pid = xpc_connection_get_pid(a1);
      FigThreadRunOnce(&sRegisterFigProcessStateMonitorCompanionClassOnce, (void (*)(void))RegisterFigProcessStateMonitorCompanionClass);
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t Instance = _CFRuntimeCreateInstance();
      uint64_t v11 = Instance;
      if (Instance)
      {
        *(_DWORD *)(Instance + 16) = pid;
        dispatch_queue_t v12 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.figprocessstatemonitor.server", 0, 0);
        *(void *)(v11 + 24) = v12;
        if (v12)
        {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
          *(void *)(v11 + 48) = Mutable;
          if (Mutable)
          {
            *(void *)(v11 + 32) = 0;
            *(void *)(v11 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
            *(unsigned char *)(v11 + 56) = 1;
            __int16 v14 = FigReentrantMutexCreate();
            *(void *)(v11 + 64) = v14;
            if (v14)
            {
              if (dword_1E9272DD8)
              {
                int v38 = 0;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v38, &type);
                int v16 = v38;
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
                  unsigned int v18 = v16;
                }
                else {
                  unsigned int v18 = v16 & 0xFFFFFFFE;
                }
                if (v18)
                {
                  int v39 = 136315394;
                  CFNumberRef v40 = "fpsmServer_createCompanion";
                  __int16 v41 = 2114;
                  *(void *)CFTypeID v42 = v11;
                  int v19 = (unsigned char *)_os_log_send_and_compose_impl();
                  LOBYTE(v16) = v38;
                }
                else
                {
                  int v19 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v19, v19 != v45, v16, 0, v17);
              }
              goto LABEL_17;
            }
          }
        }
        uint64_t OpCode = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
        CFRelease((CFTypeRef)v11);
      }
      else
      {
        uint64_t OpCode = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
      }
      uint64_t v11 = 0;
      if (OpCode)
      {
LABEL_20:
        if (dword_1E9272DD8)
        {
          int v38 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          uint64_t v23 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v38, &type);
          int v24 = v38;
          if (os_log_type_enabled(v23, type)) {
            unsigned int v26 = v24;
          }
          else {
            unsigned int v26 = v24 & 0xFFFFFFFE;
          }
          if (v26)
          {
            int v39 = 136315906;
            CFNumberRef v40 = "figProcessStateMonitorHandleCreate";
            __int16 v41 = 1024;
            *(_DWORD *)CFTypeID v42 = pid;
            *(_WORD *)&v42[4] = 2114;
            *(void *)&v42[6] = v11;
            __int16 v43 = 1024;
            int v44 = OpCode;
            uint64_t v27 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v24) = v38;
          }
          else
          {
            uint64_t v27 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v27, v27 != v45, v24, 0, v25);
        }
        if (v11) {
          CFRelease((CFTypeRef)v11);
        }
        goto LABEL_30;
      }
LABEL_17:
      uint64_t OpCode = FigXPCServerAssociateObjectWithConnection(a1, (const void *)v11, 0, 0, 0, &value);
      if (!OpCode)
      {
        uint64_t OpCode = FigCFWeakReferenceTableAddValueAssociatedWithKey(gServedObjects, v11, value);
        if (!OpCode)
        {
          xpc_dictionary_set_uint64(a3, ".objectID", value);
          uint64_t OpCode = 0;
        }
      }
      goto LABEL_20;
    }
    int v20 = (NSObject **)FigCFWeakReferenceTableCopyValue(gServedObjects, uint64);
    int v21 = v20;
    if (!v20)
    {
      uint64_t OpCode = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
LABEL_30:
      *((_DWORD *)v33 + 6) = OpCode;
      goto LABEL_31;
    }
    __int16 v22 = v20[3];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __FigProcessStateMonitor_handleMessage_block_invoke;
    block[3] = &unk_1E56768F8;
    int v30 = v31;
    block[4] = a1;
    void block[5] = xdict;
    void block[6] = a3;
    void block[7] = &v32;
    dispatch_sync(v22, block);
    CFRelease(v21);
    uint64_t OpCode = *((unsigned int *)v33 + 6);
  }
LABEL_31:
  _Block_object_dispose(&v32, 8);
  return OpCode;
}

void sub_18FD49088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FigProcessStateMonitor_noReplyHandleMessage(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v13 = 0;
  __int16 v14 = &v13;
  uint64_t v15 = 0x2020000000;
  int v16 = 0;
  int v12 = 0;
  uint64 = (void *)xpc_dictionary_get_uint64(xdict, ".objectID");
  uint64_t OpCode = FigXPCMessageGetOpCode(xdict, &v12);
  *((_DWORD *)v14 + 6) = OpCode;
  if (!OpCode)
  {
    uint64_t v6 = (NSObject **)FigCFWeakReferenceTableCopyValue(gServedObjects, uint64);
    unsigned int v7 = v6;
    if (v6)
    {
      uint64_t v8 = v6[3];
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 3221225472;
      int v10[2] = __FigProcessStateMonitor_noReplyHandleMessage_block_invoke;
      v10[3] = &unk_1E5676980;
      int v11 = v12;
      void v10[4] = a1;
      v10[5] = xdict;
      v10[6] = &v13;
      dispatch_sync(v8, v10);
      CFRelease(v7);
      uint64_t OpCode = *((unsigned int *)v14 + 6);
    }
    else
    {
      uint64_t OpCode = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
      *((_DWORD *)v14 + 6) = OpCode;
    }
  }
  _Block_object_dispose(&v13, 8);
  return OpCode;
}

void sub_18FD491F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t RegisterFigProcessStateMonitorCompanionClass()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigProcessStateMonitorServerCompanionID = result;
  return result;
}

double fpsmServerCompanion_init(_OWORD *a1)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void fpsmServerCompanion_finalize(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (dword_1E9272DD8)
  {
    v15[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, v15, &type);
    int v3 = v15[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = v3 & 0xFFFFFFFE;
    }
    if (v5)
    {
      v15[1] = 136315394;
      int v16 = "fpsmServerCompanion_finalize";
      __int16 v17 = 2048;
      unsigned int v18 = a1;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v15[0];
    }
    else
    {
      uint64_t v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v6, v6 != &v19, v3, 0, v4);
  }
  unsigned int v7 = a1[3];
  if (v7) {
    dispatch_release(v7);
  }
  uint64_t v8 = (const void *)a1[4];
  if (v8) {
    CFRelease(v8);
  }
  CFAllocatorRef v9 = (const void *)a1[6];
  if (v9) {
    CFRelease(v9);
  }
  int v10 = (const void *)a1[5];
  if (v10) {
    CFRelease(v10);
  }
  FigReentrantMutexDestroy(a1[8]);
  int v11 = (const void *)a1[11];
  if (v11) {
    CFRelease(v11);
  }
  int v12 = (const void *)a1[12];
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v13 = (const void *)a1[14];
  if (v13) {
    CFRelease(v13);
  }
}

__CFString *figProcessStateMonitorServer_CopyDebugDesc(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable(0, 0);
  int v3 = Mutable;
  if (!Mutable) {
    return v3;
  }
  CFStringAppendFormat(Mutable, 0, @"<FigProcessStateMonitorServerCompanion (%p, %d)> {\n", a1, *(unsigned int *)(a1 + 16));
  CFStringAppendFormat(v3, 0, @"\tMEMRC=\"%@\",\n", *(void *)(a1 + 32));
  CFTimeZoneRef v4 = CFTimeZoneCopySystem();
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v6 = CFDateFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, kCFDateFormatterShortStyle, kCFDateFormatterLongStyle);
  unsigned int v7 = v6;
  uint64_t v8 = 0;
  CFAllocatorRef v9 = 0;
  if (v4
    && v6
    && ((CFDateFormatterSetProperty(v6, (CFStringRef)*MEMORY[0x1E4F1D0F8], v4),
         (CFDateRef v10 = *(const __CFDate **)(a1 + 88)) == 0)
      ? (StringWithDate = 0)
      : (StringWithDate = CFDateFormatterCreateStringWithDate(v5, v7, v10)),
        (CFDateRef v12 = *(const __CFDate **)(a1 + 96)) == 0
      ? (CFAllocatorRef v9 = 0)
      : (CFAllocatorRef v9 = CFDateFormatterCreateStringWithDate(v5, v7, v12)),
        (CFDateRef v13 = *(const __CFDate **)(a1 + 112)) == 0
      ? (uint64_t v8 = 0)
      : (uint64_t v8 = CFDateFormatterCreateStringWithDate(v5, v7, v13)),
        !*(void *)(a1 + 88) || StringWithDate))
  {
    if ((!*(void *)(a1 + 96) || v9) && (!*(void *)(a1 + 112) || v8)) {
      goto LABEL_29;
    }
    CFStringAppendFormat(v3, 0, @"\t // Note: Fallback to GMT\n");
    if (StringWithDate) {
      CFRelease(StringWithDate);
    }
  }
  else
  {
    CFStringAppendFormat(v3, 0, @"\t // Note: Fallback to GMT\n");
  }
  __int16 v14 = *(const void **)(a1 + 88);
  if (v14)
  {
    StringWithDate = CFRetain(v14);
    if (!v9) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  StringWithDate = 0;
  if (v9) {
LABEL_18:
  }
    CFRelease(v9);
LABEL_19:
  uint64_t v15 = *(const void **)(a1 + 96);
  if (v15)
  {
    CFAllocatorRef v9 = CFRetain(v15);
    if (!v8) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  CFAllocatorRef v9 = 0;
  if (v8) {
LABEL_21:
  }
    CFRelease(v8);
LABEL_22:
  int v16 = *(const void **)(a1 + 112);
  if (v16) {
    uint64_t v8 = CFRetain(v16);
  }
  else {
    uint64_t v8 = 0;
  }
LABEL_29:
  int v17 = *(unsigned __int8 *)(a1 + 80);
  if (*(unsigned char *)(a1 + 80))
  {
    unsigned int TrackedState = FigPurgeAndRenewProcessStateTrackerGetTrackedState(*(unsigned int *)(a1 + 16));
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 64));
    if (TrackedState > 2) {
      char v19 = "??";
    }
    else {
      char v19 = off_1E56769A0[TrackedState];
    }
  }
  else
  {
    char v19 = "NT";
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  CFStringAppendFormat(v3, 0, @"\tENRD=\"%@\", AC=\"%ld\", PS=\"%s\", MRP=\"%lld@%@\",\n", StringWithDate, Count, v19, *(void *)(a1 + 72), v9);
  if (*(unsigned char *)(a1 + 120)) {
    CFStringAppendFormat(v3, 0, @"\t!!!! SPE=\"%lld\" SPD=\"%@\"\n", *(void *)(a1 + 104), v8);
  }
  CFStringAppendFormat(v3, 0, @"}");
  if (v17) {
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (StringWithDate) {
    CFRelease(StringWithDate);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v3;
}

void __figProcessStateMonitorHandleEnrollInPurge_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  dataPointerOut = 0;
  if (dword_1E9272DD8)
  {
    int v28 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v28, &type);
    int v5 = v28;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      int v31 = 136315394;
      uint64_t v32 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
      __int16 v33 = 2048;
      uint64_t v34 = v8;
      CFAllocatorRef v9 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v28;
    }
    else
    {
      CFAllocatorRef v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v9, v9 != v35, v5, 0, v6);
  }
  int v10 = fpsmServer_copyCompanionForPID(a2, &v29);
  uint64_t v11 = v29;
  if (v10)
  {
    if (v29) {
LABEL_31:
    }
      CFRelease((CFTypeRef)v11);
  }
  else
  {
    if (v29)
    {
      if (dword_1E9272DD8)
      {
        int v28 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        CFDateRef v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v28, &type);
        int v13 = v28;
        if (os_log_type_enabled(v12, type)) {
          unsigned int v15 = v13;
        }
        else {
          unsigned int v15 = v13 & 0xFFFFFFFE;
        }
        if (v15)
        {
          int v31 = 136315394;
          uint64_t v32 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
          __int16 v33 = 2114;
          uint64_t v34 = v11;
          int v16 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v13) = v28;
        }
        else
        {
          int v16 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v16, v16 != v35, v13, 0, v14);
      }
      FigReentrantMutexLock(*(pthread_mutex_t **)(v11 + 64));
      if (*(unsigned char *)(v11 + 56))
      {
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(v11 + 64));
        if (!CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v11 + 40), 0, 0, 0, &dataPointerOut))
        {
          if ((dataPointerOut & 0xF) != 0)
          {
            FigSignalErrorAt(4294947862, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            int v17 = *(NSObject **)(v11 + 24);
            block[0] = MEMORY[0x1E4F143A8];
            block[1] = 3221225472;
            block[2] = __figProcessStateMonitorHandleEnrollInPurge_block_invoke_36;
            block[3] = &__block_descriptor_52_e5_v8__0l;
            int v26 = a2;
            block[4] = v11;
            void block[5] = dataPointerOut;
            dispatch_sync(v17, block);
            CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"event=%lld, stickyCouldNotPurgeAllObjects=%d", *(void *)(v11 + 72), *(unsigned __int8 *)(v11 + 120));
            if (v18)
            {
              CFStringRef v19 = v18;
              FigPerformanceMonitorAddToReclamationEventLog(a2, v18);
              CFRelease(v19);
            }
            else
            {
              int v28 = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              uint64_t v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 0, &v28, &type);
              int v21 = v28;
              if (os_log_type_enabled(v20, type)) {
                unsigned int v23 = v21;
              }
              else {
                unsigned int v23 = v21 & 0xFFFFFFFE;
              }
              if (v23)
              {
                int v31 = 136315138;
                uint64_t v32 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
                int v24 = (unsigned char *)_os_log_send_and_compose_impl();
                LOBYTE(v21) = v28;
              }
              else
              {
                int v24 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 0, 1, v24, v24 != v35, v21, 0, v22);
            }
          }
        }
      }
      else
      {
        FigSignalErrorAt(4294947861, 0, 0, 0, 0, 0, 0);
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(v11 + 64));
      }
      goto LABEL_31;
    }
    FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t __figProcessStateMonitorHandleEnrollInPurge_block_invoke_36(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  FigReentrantMutexLock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 64));
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 56))
  {
    if (dword_1E9272DD8)
    {
      int v18 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, &v18, &type);
      int v4 = v18;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v6 = v4;
      }
      else {
        unsigned int v6 = v4 & 0xFFFFFFFE;
      }
      if (v6)
      {
        uint64_t v7 = *(void *)(a1 + 32);
        int v19 = 136315394;
        uint64_t v20 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
        __int16 v21 = 2114;
        uint64_t v22 = v7;
        uint64_t v8 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v18;
      }
      else
      {
        uint64_t v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v8, v8 != v23, v4, 0, v5);
      uint64_t v2 = *(void *)(a1 + 32);
    }
    int v14 = *(_DWORD *)(a1 + 48);
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    v16[2] = __figProcessStateMonitorHandleEnrollInPurge_block_invoke_37;
    v16[3] = &__block_descriptor_48_e43_v36__0r_8__NSObject_OS_xpc_object__16q24C32l;
    v16[4] = *(void *)(a1 + 40);
    v16[5] = v2;
    FigXPCPurgeObjectsForPIDWithReportingBlock(v14, (uint64_t)v16);
  }
  else
  {
    int v18 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    CFAllocatorRef v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 0, &v18, &type);
    int v10 = v18;
    if (os_log_type_enabled(v9, type)) {
      unsigned int v12 = v10;
    }
    else {
      unsigned int v12 = v10 & 0xFFFFFFFE;
    }
    if (v12)
    {
      int v19 = 136315138;
      uint64_t v20 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
      int v13 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v18;
    }
    else
    {
      int v13 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 0, 1, v13, v13 != v23, v10, 0, v11);
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(*(void *)(a1 + 32) + 64));
}

void __figProcessStateMonitorHandleEnrollInPurge_block_invoke_37(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void **)(a1 + 32);
  if (*v8 != a4)
  {
    CFAllocatorRef v9 = *(const void **)(*(void *)(a1 + 40) + 96);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(*(void *)(a1 + 40) + 96) = 0;
    }
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(void *)(*(void *)(a1 + 40) + 96) = CFDateCreate(v10, Current);
    uint64_t v8 = *(void **)(a1 + 32);
  }
  *uint64_t v8 = a4;
  uint64_t v12 = *(void *)(a1 + 40);
  *(void *)(v12 + 72) = a4;
  if (a5 && !*(unsigned char *)(v12 + 120))
  {
    *(void *)(v12 + 104) = a4;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFAbsoluteTime v14 = CFAbsoluteTimeGetCurrent();
    *(void *)(*(void *)(a1 + 40) + 112) = CFDateCreate(v13, v14);
    *(unsigned char *)(*(void *)(a1 + 40) + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
  }
  if (dword_1E9272DD8)
  {
    v23[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272DD0, 1, v23, &type);
    int v16 = v23[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v18 = v16;
    }
    else {
      unsigned int v18 = v16 & 0xFFFFFFFE;
    }
    if (v18)
    {
      uint64_t v19 = *(void *)(a1 + 40);
      uint64_t v20 = "could not";
      uint64_t v24 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
      v23[1] = 136315906;
      __int16 v25 = 2114;
      if (!a5) {
        uint64_t v20 = "did";
      }
      uint64_t v26 = v19;
      __int16 v27 = 2048;
      uint64_t v28 = a4;
      __int16 v29 = 2080;
      int v30 = v20;
      __int16 v21 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v16) = v23[0];
    }
    else
    {
      __int16 v21 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272DD0, 1u, 1, v21, v21 != &v31, v16, 0, v17);
  }
  FigMemoryBarrier();
}

double FigProcessStateMonitorPurgePreventionAssertion_Init(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigProcessStateMonitorPurgePreventionAssertion_Finalize(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 16))
  {
    figProcessStateMonitorMayPurgeClientObjects(*(void *)(a1 + 32), *(const void **)(a1 + 24));
    *(unsigned char *)(a1 + 16) = 1;
  }
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    int v3 = *(NSObject **)(a1 + 40);
    if (v3) {
      dispatch_release(v3);
    }
  }
  int v4 = *(const void **)(a1 + 24);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 32);
  if (v5)
  {
    CFRelease(v5);
  }
}

__CFString *FigProcessStateMonitorPurgePreventionAssertion_CopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  int v4 = Mutable;
  uint64_t v5 = "Yes";
  if (*(void *)(a1 + 40)) {
    unsigned int v6 = "Yes";
  }
  else {
    unsigned int v6 = "No";
  }
  if (!*(unsigned char *)(a1 + 16)) {
    uint64_t v5 = "No";
  }
  CFStringAppendFormat(Mutable, 0, @"<FigProcessStateMonitorPurgePreventionAssertion %p hasTimeout:%s didPurge:%s>", a1, v6, v5);
  return v4;
}

CFTypeID CMFormatDescriptionGetTypeID(void)
{
  return sFigFormatDescriptionID;
}

Boolean CMFormatDescriptionEqual(CMFormatDescriptionRef formatDescription, CMFormatDescriptionRef otherFormatDescription)
{
  if (formatDescription && otherFormatDescription) {
    return CFEqual(formatDescription, otherFormatDescription);
  }
  else {
    return formatDescription == otherFormatDescription;
  }
}

Boolean CMFormatDescriptionEqualIgnoringExtensionKeys(CMFormatDescriptionRef formatDescription, CMFormatDescriptionRef otherFormatDescription, CFTypeRef formatDescriptionExtensionKeysToIgnore, CFTypeRef sampleDescriptionExtensionAtomKeysToIgnore)
{
  if (formatDescription && otherFormatDescription) {
    return figFormatDescriptionEqualIgnoringExtensionsKeys((uint64_t)formatDescription, (uint64_t)otherFormatDescription, (uint64_t)formatDescriptionExtensionKeysToIgnore, (uint64_t)sampleDescriptionExtensionAtomKeysToIgnore);
  }
  else {
    return formatDescription == otherFormatDescription;
  }
}

uint64_t figFormatDescriptionEqualIgnoringExtensionsKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (const void *)*(unsigned int *)(a1 + 16);
  if (v5 != *(_DWORD *)(a2 + 16) || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)) {
    return 0;
  }
  if (!v5) {
    return 1;
  }
  CFStringRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, v5);
  if (!Value)
  {
    CFStringRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72);
    if (!Value) {
      return 1;
    }
  }
  CFAllocatorRef v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(Value + 12);
  if (!v10) {
    return 0;
  }

  return v10(a1, a2, a3, a4);
}

uint64_t FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(CFDictionaryRef theDict, const __CFDictionary *a2, unint64_t a3, unint64_t a4)
{
  if (a3 | a4)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableStringRef MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], theDict);
    CFAllocatorRef v10 = FigCFDictionaryCreateMutableCopy(v8, a2);
    CFDictionaryRemoveValue(MutableCopy, @"VerbatimSampleDescription");
    CFDictionaryRemoveValue(MutableCopy, @"VerbatimISOSampleEntry");
    CFDictionaryRemoveValue(v10, @"VerbatimSampleDescription");
    CFDictionaryRemoveValue(v10, @"VerbatimISOSampleEntry");
    if (a3)
    {
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID((CFTypeRef)a3))
      {
        CFDictionaryRemoveValue(MutableCopy, (const void *)a3);
        CFDictionaryRemoveValue(v10, (const void *)a3);
      }
      else
      {
        CFTypeID v13 = CFArrayGetTypeID();
        if (v13 == CFGetTypeID((CFTypeRef)a3))
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)a3);
          if (Count >= 1)
          {
            CFIndex v15 = Count;
            for (CFIndex i = 0; i != v15; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, i);
              CFDictionaryRemoveValue(MutableCopy, ValueAtIndex);
              CFDictionaryRemoveValue(v10, ValueAtIndex);
            }
          }
        }
      }
    }
    if (!a4) {
      goto LABEL_26;
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, @"SampleDescriptionExtensionAtoms");
    uint64_t v19 = FigCFDictionaryCreateMutableCopy(v8, Value);
    CFDictionaryRef v20 = (const __CFDictionary *)CFDictionaryGetValue(v10, @"SampleDescriptionExtensionAtoms");
    __int16 v21 = FigCFDictionaryCreateMutableCopy(v8, v20);
    CFDictionaryRemoveValue(MutableCopy, @"SampleDescriptionExtensionAtoms");
    CFDictionaryRemoveValue(v10, @"SampleDescriptionExtensionAtoms");
    CFTypeID v22 = CFStringGetTypeID();
    if (v22 == CFGetTypeID((CFTypeRef)a4))
    {
      CFDictionaryRemoveValue(v19, (const void *)a4);
      CFDictionaryRemoveValue(v21, (const void *)a4);
    }
    else
    {
      CFTypeID v23 = CFArrayGetTypeID();
      if (v23 == CFGetTypeID((CFTypeRef)a4))
      {
        CFIndex v24 = CFArrayGetCount((CFArrayRef)a4);
        if (v24 >= 1)
        {
          CFIndex v25 = v24;
          for (CFIndex j = 0; j != v25; ++j)
          {
            __int16 v27 = CFArrayGetValueAtIndex((CFArrayRef)a4, j);
            CFDictionaryRemoveValue(v19, v27);
            CFDictionaryRemoveValue(v21, v27);
          }
        }
      }
    }
    uint64_t v28 = FigCFEqual(v19, v21);
    if (v19) {
      CFRelease(v19);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (v28) {
LABEL_26:
    }
      uint64_t v28 = FigCFEqual(MutableCopy, v10) != 0;
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    if (v10) {
      CFRelease(v10);
    }
    return v28;
  }
  if (!FigCFDictionaryGetCount(theDict) && !FigCFDictionaryGetCount(a2)) {
    return 1;
  }

  return FigCFEqual(theDict, a2);
}

CMMediaType CMFormatDescriptionGetMediaType(CMFormatDescriptionRef desc)
{
  if (desc) {
    LODWORD(desc) = *((_DWORD *)desc + 4);
  }
  return desc;
}

FourCharCode CMFormatDescriptionGetMediaSubType(CMFormatDescriptionRef desc)
{
  if (desc) {
    LODWORD(desc) = *((_DWORD *)desc + 5);
  }
  return desc;
}

CFDictionaryRef CMFormatDescriptionGetExtensions(CFDictionaryRef desc)
{
  if (desc) {
    return (CFDictionaryRef)*((void *)desc + 3);
  }
  return desc;
}

CFPropertyListRef CMFormatDescriptionGetExtension(CMFormatDescriptionRef desc, CFStringRef extensionKey)
{
  if (desc && (CFDictionaryRef v2 = (const __CFDictionary *)*((void *)desc + 3)) != 0) {
    return CFDictionaryGetValue(v2, extensionKey);
  }
  else {
    return 0;
  }
}

OSStatus CMFormatDescriptionCreate(CFAllocatorRef allocator, CMMediaType mediaType, FourCharCode mediaSubType, CFDictionaryRef extensions, CMFormatDescriptionRef *formatDescriptionOut)
{
  if (formatDescriptionOut)
  {
    CFAllocatorRef v9 = *(void **)&mediaType;
    FigThreadRunOnce(&sFigGenericFormatDescriptionRegisterOnce, (void (*)(void))FigGenericFormatDescriptionRegisterOnce);
    return FigDerivedFormatDescriptionCreate(allocator, v9, mediaSubType, extensions, (uint64_t *)formatDescriptionOut);
  }
  else
  {
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  return figFormatDescriptionEqualIgnoringExtensionsKeys(a1, a2, 0, 0);
}

__CFString *figFormatDescriptionCopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  int v4 = *(_DWORD *)(a1 + 16);
  unsigned int v5 = *(_DWORD *)(a1 + 20);
  if (v4
    && ((CFDictionaryRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)*(unsigned int *)(a1 + 16))) != 0|| (CFDictionaryRef Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72)) != 0)&& (v7 = *(uint64_t (**)(uint64_t))(Value + 20)) != 0)
  {
    CFAllocatorRef v8 = (const void *)v7(a1);
  }
  else
  {
    CFAllocatorRef v8 = 0;
  }
  CFAllocatorRef v9 = *(const void **)(a1 + 24);
  if (v9) {
    CFStringRef v10 = CFCopyDescription(v9);
  }
  else {
    CFStringRef v10 = 0;
  }
  if (v4 <= 1885564003)
  {
    if (v4 <= 1668310897)
    {
      if (v4 == 1635088502)
      {
        uint64_t v11 = @"AuxiliaryPicture";
        goto LABEL_38;
      }
      if (v4 == 1668047728)
      {
        uint64_t v11 = @"ClosedCaption";
        goto LABEL_38;
      }
    }
    else
    {
      switch(v4)
      {
        case 1668310898:
          uint64_t v11 = @"CaptionGroup";
          goto LABEL_38;
        case 1835365473:
          uint64_t v11 = @"Metadata";
          goto LABEL_38;
        case 1836415096:
          uint64_t v11 = @"Muxed";
          goto LABEL_38;
      }
    }
  }
  else if (v4 > 1936684397)
  {
    switch(v4)
    {
      case 1936684398:
        uint64_t v11 = @"Audio";
        goto LABEL_38;
      case 1952807028:
        uint64_t v11 = @"Text";
        goto LABEL_38;
      case 1986618469:
        uint64_t v11 = @"Video";
        goto LABEL_38;
    }
  }
  else
  {
    switch(v4)
    {
      case 1885564004:
        uint64_t v11 = @"PointCloud";
        goto LABEL_38;
      case 1935832172:
        uint64_t v11 = @"Subtitle";
        goto LABEL_38;
      case 1935893870:
        uint64_t v11 = @"Scene";
        goto LABEL_38;
    }
  }
  if (v4 == 1952606066) {
    uint64_t v11 = @"TaggedBufferGroup";
  }
  else {
    uint64_t v11 = &stru_1EDF73CD0;
  }
LABEL_38:
  CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"<CM%@FormatDescription %p [%p]> {\n\tmediaType:'%c%c%c%c' \n\tmediaSubType:'%c%c%c%c' \n\tmediaSpecific: {\n%@ \n\t} \n\textensions: {%@}\n}", v11, a1, v12, HIBYTE(v4), BYTE2(v4), BYTE1(v4), v4, HIBYTE(v5), BYTE2(v5), BYTE1(v5), v5, v8, v10);
  if (v8) {
    CFRelease(v8);
  }
  if (v10) {
    CFRelease(v10);
  }
  return Mutable;
}

void myCFDictionaryReleaseCallBack(uint64_t a1, void *a2)
{
}

uint64_t FigGenericFormatDescriptionRegisterOnce()
{
  memset(v1, 0, sizeof(v1));
  int v2 = 0;
  *(void *)((char *)v1 + 12) = figGenericFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x67656E72u, v1);
}

uint64_t figGenericFormatDescriptionEqual(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(*(CFDictionaryRef *)(a1 + 24), *(const __CFDictionary **)(a2 + 24), a3, a4);
}

uint64_t FigMuxedFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigMuxedFormatDescriptionRegisterOnce, (void (*)(void))FigMuxedFormatDescriptionRegisterOnce);
}

uint64_t FigMuxedFormatDescriptionRegisterOnce()
{
  int v1 = 0;
  unsigned int v5 = figMuxedFormatDescriptionFinalize;
  int v4 = figMuxedFormatDescriptionCopyDebugDesc;
  uint64_t v2 = 4;
  int v3 = figMuxedFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x6D757878u, (long long *)&v1);
}

OSStatus CMMuxedFormatDescriptionCreate(CFAllocatorRef allocator, CMMuxedStreamType muxType, CFDictionaryRef extensions, CMMuxedFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  if (muxType && formatDescriptionOut)
  {
    FigThreadRunOnce(&sFigMuxedFormatDescriptionRegisterOnce, (void (*)(void))FigMuxedFormatDescriptionRegisterOnce);
    OSStatus v8 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x6D757878, muxType, extensions, (uint64_t *)&cf);
    CFAllocatorRef v9 = (const opaqueCMFormatDescription *)cf;
    if (v8)
    {
      if (cf)
      {
        CFRelease(cf);
        CFAllocatorRef v9 = 0;
      }
    }
    else
    {
      *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf) = muxType;
      CFAllocatorRef v9 = (const opaqueCMFormatDescription *)cf;
    }
  }
  else
  {
    OSStatus v8 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    CFAllocatorRef v9 = 0;
    if (!formatDescriptionOut) {
      return v8;
    }
  }
  *formatDescriptionOut = v9;
  return v8;
}

__CFString *figMuxedFormatDescriptionCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, @"\t\tmuxType: '%c%c%c%c'", HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  return Mutable;
}

BOOL figMuxedFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a1);
  return *DerivedStorage == *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a2);
}

uint64_t FigVideoFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigVideoFormatDescriptionRegisterOnce, (void (*)(void))FigVideoFormatDescriptionRegisterOnce);
}

OSStatus CMVideoFormatDescriptionCreate(CFAllocatorRef allocator, CMVideoCodecType codecType, int32_t width, int32_t height, CFDictionaryRef extensions, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  CFTypeRef cf = 0;
  if (formatDescriptionOut)
  {
    if (codecType)
    {
      FigThreadRunOnce(&sFigVideoFormatDescriptionRegisterOnce, (void (*)(void))FigVideoFormatDescriptionRegisterOnce);
      OSStatus v12 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x76696465, codecType, extensions, (uint64_t *)&cf);
      CFTypeID v13 = (const opaqueCMFormatDescription *)cf;
      if (!v12)
      {
        uint64_t DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
        *uint64_t DerivedStorage = codecType;
        DerivedStorage[1] = width;
        DerivedStorage[2] = height;
        CFTypeID v13 = (const opaqueCMFormatDescription *)cf;
        goto LABEL_12;
      }
      if (!cf)
      {
LABEL_12:
        *formatDescriptionOut = v13;
        return v12;
      }
      CFRelease(cf);
    }
    else
    {
      OSStatus v12 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
    CFTypeID v13 = 0;
    goto LABEL_12;
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMVideoFormatDescriptionCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  CMVideoFormatDescriptionRef formatDescriptionOuta = 0;
  if (formatDescriptionOut)
  {
    if (imageBuffer)
    {
      FigThreadRunOnce(&sFigVideoFormatDescriptionRegisterOnce, (void (*)(void))FigVideoFormatDescriptionRegisterOnce);
      FigThreadRunOnce(&sFigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce, (void (*)(void))FigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce);
      CFIndex Count = CFArrayGetCount((CFArrayRef)sExtensionKeysCommonWithImageBuffers);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, Count + 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFMutableDictionaryRef v8 = Mutable;
        CFTypeID v9 = CFGetTypeID(imageBuffer);
        if (CVPixelBufferGetTypeID() == v9)
        {
          CFStringRef v10 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
          OSType PixelFormatType = CVPixelBufferGetPixelFormatType(imageBuffer);
          int32_t Width = CVPixelBufferGetWidth(imageBuffer);
          int32_t Height = CVPixelBufferGetHeight(imageBuffer);
          int valuePtr = CVPixelBufferGetBytesPerRow(imageBuffer);
          CFNumberRef v14 = CFNumberCreate(*v10, kCFNumberSInt32Type, &valuePtr);
          if (!v14)
          {
            OSStatus v18 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_29:
            CFRelease(v8);
            goto LABEL_30;
          }
          CFNumberRef v15 = v14;
          int32_t v25 = Height;
          int32_t v26 = Width;
          CMVideoCodecType codecType = PixelFormatType;
          CFDictionarySetValue(v8, @"CVBytesPerRow", v14);
        }
        else
        {
          CGSize EncodedSize = CVImageBufferGetEncodedSize(imageBuffer);
          CMVideoCodecType codecType = 0;
          CFNumberRef v15 = 0;
          int32_t v26 = (int)(EncodedSize.width + 0.5);
          int32_t v25 = (int)(EncodedSize.height + 0.5);
        }
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)sExtensionKeysCommonWithImageBuffers, i);
            CFTypeRef v22 = CVBufferCopyAttachment(imageBuffer, ValueAtIndex, 0);
            if (v22)
            {
              CFTypeID v23 = v22;
              CFDictionarySetValue(v8, ValueAtIndex, v22);
              CFRelease(v23);
            }
          }
        }
        int valuePtr = 2;
        CFNumberRef v24 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
        if (v24)
        {
          CFDictionarySetValue(v8, @"Version", v24);
          OSStatus v18 = CMVideoFormatDescriptionCreate(allocator, codecType, v26, v25, v8, &formatDescriptionOuta);
          if (v18 && formatDescriptionOuta)
          {
            CFRelease(formatDescriptionOuta);
            CMVideoFormatDescriptionRef formatDescriptionOuta = 0;
          }
        }
        else
        {
          OSStatus v18 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        }
        if (v15) {
          CFRelease(v15);
        }
        if (v24) {
          CFRelease(v24);
        }
        goto LABEL_29;
      }
      uint64_t v17 = 4294954585;
    }
    else
    {
      uint64_t v17 = 4294954586;
    }
    OSStatus v18 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
LABEL_30:
    *formatDescriptionOut = formatDescriptionOuta;
    return v18;
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  uint64_t DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)videoDesc);
  if (DerivedStorage && (uint64_t v3 = DerivedStorage, CMFormatDescriptionGetMediaType(videoDesc) == 1986618469))
  {
    return *(CMVideoDimensions *)(v3 + 4);
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return (CMVideoDimensions)0;
  }
}

uint64_t CMPointCloudFormatDescriptionGetNumberOfPoints(const opaqueCMFormatDescription *a1)
{
  unsigned int v3 = 0;
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  FigCFDictionaryGetInt32IfPresent((uint64_t)Extensions, @"NumberOfPointsPerSample", &v3);
  return v3;
}

CGRect CMVideoFormatDescriptionGetCleanAperture(CMVideoFormatDescriptionRef videoDesc, Boolean originIsAtTopLeft)
{
  int v2 = originIsAtTopLeft;
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(videoDesc);
  double width = (double)Dimensions.width;
  double height = (double)Dimensions.height;
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E4F24A78]);
  double v8 = 0.0;
  if (!Extension) {
    goto LABEL_20;
  }
  CFTypeID v9 = Extension;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v9)) {
    goto LABEL_20;
  }
  double v32 = 0.0;
  double valuePtr = 0.0;
  double v30 = 0.0;
  double v31 = 0.0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E4F24A88]);
  if (Value)
  {
    CFNumberRef v12 = Value;
    CFTypeID v13 = CFNumberGetTypeID();
    if (v13 == CFGetTypeID(v12)) {
      CFNumberGetValue(v12, kCFNumberCGFloatType, &valuePtr);
    }
  }
  CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E4F24A68]);
  if (v14)
  {
    CFNumberRef v15 = v14;
    CFTypeID v16 = CFNumberGetTypeID();
    if (v16 == CFGetTypeID(v15)) {
      CFNumberGetValue(v15, kCFNumberCGFloatType, &v32);
    }
  }
  CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E4F24A70]);
  if (v17)
  {
    CFNumberRef v18 = v17;
    CFTypeID v19 = CFNumberGetTypeID();
    if (v19 == CFGetTypeID(v18)) {
      CFNumberGetValue(v18, kCFNumberCGFloatType, &v31);
    }
  }
  CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E4F24A80]);
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFTypeID v22 = CFNumberGetTypeID();
    if (v22 == CFGetTypeID(v21)) {
      CFNumberGetValue(v21, kCFNumberCGFloatType, &v30);
    }
  }
  if (valuePtr <= width
    && valuePtr > 0.0
    && v32 > 0.0
    && v32 <= height
    && (double v23 = (width - valuePtr) * 0.5, fabs(v31) <= v23))
  {
    double v28 = (height - v32) * 0.5;
    double v24 = 0.0;
    if (fabs(v30) <= v28)
    {
      double v24 = v23 + v31;
      double v29 = -v30;
      if (v2) {
        double v29 = v30;
      }
      double v8 = v28 + v29;
      double width = valuePtr;
      double height = v32;
    }
  }
  else
  {
LABEL_20:
    double v24 = 0.0;
  }
  double v25 = v8;
  double v26 = width;
  double v27 = height;
  result.size.double height = v27;
  result.size.double width = v26;
  result.origin.y = v25;
  result.origin.x = v24;
  return result;
}

CGSize CMVideoFormatDescriptionGetPresentationDimensions(CMVideoFormatDescriptionRef videoDesc, Boolean usePixelAspectRatio, Boolean useCleanAperture)
{
  int v3 = useCleanAperture;
  int v4 = usePixelAspectRatio;
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(videoDesc);
  double width = (double)Dimensions.width;
  double height = (double)Dimensions.height;
  if (v3)
  {
    CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E4F24A78]);
    if (Extension)
    {
      CFDictionaryRef v10 = Extension;
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v10))
      {
        double v31 = 0.0;
        double valuePtr = 0.0;
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E4F24A88]);
        if (Value)
        {
          CFNumberRef v13 = Value;
          CFTypeID v14 = CFNumberGetTypeID();
          if (v14 == CFGetTypeID(v13)) {
            CFNumberGetValue(v13, kCFNumberCGFloatType, &valuePtr);
          }
        }
        CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E4F24A68]);
        double v16 = 0.0;
        if (v15)
        {
          CFNumberRef v17 = v15;
          CFTypeID v18 = CFNumberGetTypeID();
          if (v18 == CFGetTypeID(v17))
          {
            CFNumberGetValue(v17, kCFNumberCGFloatType, &v31);
            double v16 = v31;
          }
        }
        BOOL v19 = valuePtr <= 0.0;
        if (v16 <= 0.0) {
          BOOL v19 = 1;
        }
        if (valuePtr > width) {
          BOOL v19 = 1;
        }
        if (v16 > height) {
          BOOL v19 = 1;
        }
        if (!v19)
        {
          double height = v16;
          double width = valuePtr;
        }
      }
    }
  }
  if (v4)
  {
    CFDictionaryRef v20 = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E4F24B98]);
    if (v20)
    {
      CFDictionaryRef v21 = v20;
      CFTypeID v22 = CFDictionaryGetTypeID();
      if (v22 == CFGetTypeID(v21))
      {
        double v31 = 0.0;
        double valuePtr = 0.0;
        CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E4F24B90]);
        if (v23)
        {
          CFNumberRef v24 = v23;
          CFTypeID v25 = CFNumberGetTypeID();
          if (v25 == CFGetTypeID(v24)) {
            CFNumberGetValue(v24, kCFNumberDoubleType, &valuePtr);
          }
        }
        CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E4F24BA0]);
        if (v26)
        {
          CFNumberRef v27 = v26;
          CFTypeID v28 = CFNumberGetTypeID();
          if (v28 == CFGetTypeID(v27))
          {
            CFNumberGetValue(v27, kCFNumberDoubleType, &v31);
            if (valuePtr > 0.0 && v31 > 0.0) {
              double width = width * (valuePtr / v31);
            }
          }
        }
      }
    }
  }
  double v29 = width;
  double v30 = height;
  result.double height = v30;
  result.double width = v29;
  return result;
}

CFArrayRef CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers(void)
{
  return (CFArrayRef)sExtensionKeysCommonWithImageBuffers;
}

Boolean CMVideoFormatDescriptionMatchesImageBuffer(CMVideoFormatDescriptionRef desc, CVImageBufferRef imageBuffer)
{
  if (!desc || !imageBuffer)
  {
    uint64_t v12 = 4294954586;
    goto LABEL_9;
  }
  CFTypeID v4 = CFGetTypeID(imageBuffer);
  if (CVPixelBufferGetTypeID() == v4)
  {
    int valuePtr = 0;
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(imageBuffer);
    int Width = CVPixelBufferGetWidth(imageBuffer);
    int Height = CVPixelBufferGetHeight(imageBuffer);
    CFNumberRef Extension = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, @"CVBytesPerRow");
    if (Extension)
    {
      CFNumberRef v9 = Extension;
      CFTypeID v10 = CFGetTypeID(Extension);
      if (v10 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
        int BytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
        if (valuePtr != BytesPerRow) {
          return 0;
        }
      }
    }
  }
  else
  {
    CGSize EncodedSize = CVImageBufferGetEncodedSize(imageBuffer);
    OSType PixelFormatType = 0;
    int Width = (int)(EncodedSize.width + 0.5);
    int Height = (int)(EncodedSize.height + 0.5);
  }
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(desc);
  FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(desc);
  Boolean result = 0;
  if (MediaSubType == PixelFormatType && Width == Dimensions.width && Height == Dimensions.height)
  {
    FigThreadRunOnce(&sFigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce, (void (*)(void))FigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce);
    CFArrayRef v18 = (const __CFArray *)sExtensionKeysCommonWithImageBuffers;
    CFIndex Count = CFArrayGetCount((CFArrayRef)sExtensionKeysCommonWithImageBuffers);
    if (v18)
    {
      uint64_t v20 = Count;
      CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(desc);
      if (Extensions)
      {
        if (v20 >= 1)
        {
          CFDictionaryRef v22 = Extensions;
          CFIndex v23 = 0;
          while (1)
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, v23);
            unint64_t Value = (unint64_t)CFDictionaryGetValue(v22, ValueAtIndex);
            unint64_t v26 = (unint64_t)CVBufferCopyAttachment(imageBuffer, ValueAtIndex, 0);
            if (Value | v26)
            {
              CFNumberRef v27 = (const void *)v26;
              if (!Value || !v26)
              {
                if (!v26) {
                  return 0;
                }
LABEL_38:
                CFTypeRef v30 = v27;
LABEL_39:
                CFRelease(v30);
                return 0;
              }
              if (!CFEqual((CFTypeRef)Value, (CFTypeRef)v26)) {
                goto LABEL_38;
              }
              CFRelease(v27);
            }
            ++v23;
            Boolean result = 1;
            if (v20 == v23) {
              return result;
            }
          }
        }
      }
      else if (v20 >= 1)
      {
        for (CFIndex i = 0; i != v20; ++i)
        {
          CFStringRef v29 = (const __CFString *)CFArrayGetValueAtIndex(v18, i);
          CFTypeRef v30 = CVBufferCopyAttachment(imageBuffer, v29, 0);
          if (v30) {
            goto LABEL_39;
          }
          Boolean result = 1;
        }
        return result;
      }
      return 1;
    }
    uint64_t v12 = 4294954585;
LABEL_9:
    FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

BOOL FigVideoFormatDescriptionContainsWideColor(const opaqueCMFormatDescription *a1)
{
  if (CMFormatDescriptionGetMediaType(a1) != 1986618469) {
    return 0;
  }
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E4F24A90]);
  if (FigCFEqual(Extension, @"DCI_P3")) {
    return 1;
  }
  if (FigCFEqual(Extension, @"P3_D65")) {
    return 1;
  }
  if (FigCFEqual(Extension, @"ITU_R_2020")) {
    return 1;
  }
  CFPropertyListRef v3 = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E4F24BC8]);
  if (FigCFEqual(v3, @"aYCC") || FigCFEqual(v3, @"ITU_R_2020")) {
    return 1;
  }
  CFPropertyListRef v5 = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E4F24C18]);
  return FigCFEqual(v5, @"ITU_R_2020") != 0;
}

BOOL FigVideoFormatDescriptionContainsHDR(const opaqueCMFormatDescription *a1)
{
  if (!a1 || CMFormatDescriptionGetMediaType(a1) != 1986618469) {
    return 0;
  }
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E4F24BC8]);
  BOOL result = 1;
  if (MediaSubType <= 1685481520)
  {
    if (MediaSubType <= 1667524656)
    {
      if (MediaSubType == 1634759272) {
        return result;
      }
      int v6 = 1634759278;
LABEL_18:
      if (MediaSubType == v6) {
        return result;
      }
      return FigCFEqual(Extension, @"ITU_R_2100_HLG")
          || FigCFEqual(Extension, @"SMPTE_ST_2084_PQ");
    }
    if (MediaSubType != 1667524657 && MediaSubType != 1684108849)
    {
      int v6 = 1684895096;
      goto LABEL_18;
    }
  }
  else if (MediaSubType > 1902405680)
  {
    if (MediaSubType != 1902405681 && MediaSubType != 1902405733)
    {
      unsigned __int16 v5 = 28024;
      goto LABEL_15;
    }
  }
  else if (MediaSubType != 1685481521 && MediaSubType != 1685481573)
  {
    unsigned __int16 v5 = 24950;
LABEL_15:
    int v6 = v5 | 0x71640000;
    goto LABEL_18;
  }
  return result;
}

uint64_t CMFormatDescriptionGetWidestGamutAndLargestDynamicRangeColorPropertiesFromFormatDescriptions(const __CFArray *a1, int a2, int a3, void *a4, void *a5, void *a6)
{
  if (a1)
  {
    CFArrayRef v11 = a1;
    CFTypeID v12 = CFGetTypeID(a1);
    if (v12 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount(v11);
      if (Count > 0 && a4 && a5 && a6)
      {
        int v38 = a3;
        int v39 = a2;
        int v35 = a4;
        uint64_t v36 = a5;
        CFTypeRef v37 = a6;
        CFIndex v13 = 0;
        unsigned int v14 = 0;
        unsigned int v15 = 0;
        CFPropertyListRef v40 = 0;
        CFPropertyListRef v41 = 0;
        CFPropertyListRef v42 = 0;
        CFStringRef v16 = (const __CFString *)*MEMORY[0x1E4F24BC8];
        CFStringRef v45 = (const __CFString *)*MEMORY[0x1E4F24A90];
        CFStringRef v17 = (const __CFString *)*MEMORY[0x1E4F24C18];
        CFArrayRef v43 = v11;
        while (1)
        {
          CFStringRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(v11, v13);
          if (!ValueAtIndex) {
            break;
          }
          BOOL v19 = ValueAtIndex;
          CFTypeID v20 = CFGetTypeID(ValueAtIndex);
          if (v20 != CMFormatDescriptionGetTypeID()) {
            break;
          }
          CFPropertyListRef Extension = CMFormatDescriptionGetExtension(v19, v16);
          if (FigCFEqual(Extension, @"SMPTE_ST_2084_PQ"))
          {
            unsigned int v22 = 2;
          }
          else if (FigCFEqual(Extension, @"ITU_R_2100_HLG"))
          {
            unsigned int v22 = 3;
          }
          else
          {
            unsigned int v22 = 1;
          }
          CFPropertyListRef v23 = CMFormatDescriptionGetExtension(v19, v45);
          CFPropertyListRef v24 = CMFormatDescriptionGetExtension(v19, v16);
          CFPropertyListRef v25 = CMFormatDescriptionGetExtension(v19, v17);
          if (FigCFEqual(v23, @"DCI_P3") || FigCFEqual(v23, @"P3_D65"))
          {
            unsigned int v26 = 2;
          }
          else if (FigCFEqual(v23, @"ITU_R_2020") {
                 || !v23
          }
                 && (FigCFEqual(v24, @"ITU_R_2100_HLG")
                  || FigCFEqual(v24, @"SMPTE_ST_2084_PQ")
                  || FigCFEqual(v24, @"aYCC")
                  || FigCFEqual(v25, @"ITU_R_2020")))
          {
            unsigned int v26 = 3;
          }
          else
          {
            unsigned int v26 = 1;
          }
          CFArrayRef v11 = v43;
          if (v22 > v15)
          {
            CFPropertyListRef v40 = CMFormatDescriptionGetExtension(v19, v16);
            unsigned int v15 = v22;
          }
          if (v26 > v14)
          {
            CFPropertyListRef v42 = CMFormatDescriptionGetExtension(v19, v45);
            CFPropertyListRef v41 = CMFormatDescriptionGetExtension(v19, v17);
            unsigned int v14 = v26;
          }
          if (Count == ++v13)
          {
            if (v15 > 1 && v38 == 0) {
              CFTypeID v28 = (const void *)*MEMORY[0x1E4F24BE0];
            }
            else {
              CFTypeID v28 = v40;
            }
            if (v39 == 0 && v14 > 1) {
              CFStringRef v29 = (const void *)*MEMORY[0x1E4F24AB0];
            }
            else {
              CFStringRef v29 = v42;
            }
            if (v39 == 0 && v14 > 1) {
              CFTypeRef v30 = (const void *)*MEMORY[0x1E4F24C48];
            }
            else {
              CFTypeRef v30 = v41;
            }
            if (v29)
            {
              CFTypeID v31 = CFGetTypeID(v29);
              if (v31 == CFStringGetTypeID())
              {
                if (v28)
                {
                  CFTypeID v32 = CFGetTypeID(v28);
                  if (v32 == CFStringGetTypeID())
                  {
                    if (v30)
                    {
                      CFTypeID v33 = CFGetTypeID(v30);
                      if (v33 == CFStringGetTypeID())
                      {
                        *int v35 = v29;
                        void *v36 = v28;
                        void *v37 = v30;
                      }
                    }
                  }
                }
              }
            }
            return 0;
          }
        }
      }
    }
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

uint64_t CMFormatDescriptionGetWidestColorPropertiesFromFormatDescriptions(const void *a1, int a2, void *a3, void *a4, void *a5)
{
  if (a1)
  {
    CFTypeID v10 = CFGetTypeID(a1);
    if (v10 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count > 0 && a3 && a4 && a5)
      {
        CFIndex v12 = Count;
        int v30 = a2;
        CFNumberRef v27 = a3;
        CFTypeID v28 = a4;
        CFStringRef v29 = a5;
        CFIndex v13 = 0;
        CFPropertyListRef v14 = 0;
        CFPropertyListRef v15 = 0;
        CFPropertyListRef v16 = 0;
        CFStringRef v17 = (const __CFString *)*MEMORY[0x1E4F24A90];
        CFArrayRef v18 = (const void *)*MEMORY[0x1E4F24AB0];
        CFStringRef extensionKey = (const __CFString *)*MEMORY[0x1E4F24BC8];
        CFStringRef v32 = (const __CFString *)*MEMORY[0x1E4F24C18];
        while (1)
        {
          CFStringRef ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex((CFArrayRef)a1, v13);
          if (!ValueAtIndex) {
            goto LABEL_29;
          }
          CFTypeID v20 = ValueAtIndex;
          CFTypeID v21 = CFGetTypeID(ValueAtIndex);
          if (v21 != CMFormatDescriptionGetTypeID()) {
            goto LABEL_29;
          }
          CFPropertyListRef Extension = CMFormatDescriptionGetExtension(v20, v17);
          if (FigVideoFormatDescriptionContainsWideColor(v20)) {
            break;
          }
          if (FigCFEqual(Extension, v18) || !v16 && !v15 && !v14)
          {
            CFPropertyListRef v15 = CMFormatDescriptionGetExtension(v20, extensionKey);
            CFPropertyListRef v14 = CMFormatDescriptionGetExtension(v20, v32);
            CFPropertyListRef v16 = Extension;
          }
          if (v12 == ++v13) {
            goto LABEL_20;
          }
        }
        if (v30)
        {
          CFPropertyListRef v16 = CMFormatDescriptionGetExtension(v20, v17);
          CFPropertyListRef v15 = CMFormatDescriptionGetExtension(v20, extensionKey);
          CFPropertyListRef v14 = CMFormatDescriptionGetExtension(v20, v32);
LABEL_20:
          if (v16) {
            goto LABEL_21;
          }
        }
        else
        {
          CFPropertyListRef v15 = (CFPropertyListRef)*MEMORY[0x1E4F24BE0];
          CFPropertyListRef v14 = (CFPropertyListRef)*MEMORY[0x1E4F24C48];
          CFPropertyListRef v16 = v18;
          if (v18)
          {
LABEL_21:
            CFTypeID v23 = CFGetTypeID(v16);
            if (v23 == CFStringGetTypeID())
            {
              if (v15)
              {
                CFTypeID v24 = CFGetTypeID(v15);
                if (v24 == CFStringGetTypeID())
                {
                  if (v14)
                  {
                    CFTypeID v25 = CFGetTypeID(v14);
                    if (v25 == CFStringGetTypeID())
                    {
                      void *v27 = v16;
                      *CFTypeID v28 = v15;
                      *CFStringRef v29 = v14;
                    }
                  }
                }
              }
            }
          }
        }
        return 0;
      }
    }
  }
LABEL_29:

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

BOOL FigVideoFormatDescriptionContainsAlphaChannel(const opaqueCMFormatDescription *a1)
{
  return CMFormatDescriptionGetMediaType(a1) == 1986618469
      && CMFormatDescriptionGetExtension(a1, @"ContainsAlphaChannel") == (CFPropertyListRef)*MEMORY[0x1E4F1CFD0];
}

BOOL FigVideoFormatDescriptionContainsStereoMultiviewVideo(const opaqueCMFormatDescription *a1)
{
  CFArrayRef tagCollectionsOut = 0;
  if (CMFormatDescriptionGetMediaType(a1) != 1986618469 && CMFormatDescriptionGetMediaType(a1) != 1635088502) {
    return 0;
  }
  CMVideoFormatDescriptionCopyTagCollectionArray(a1, &tagCollectionsOut);
  if (tagCollectionsOut)
  {
    CFIndex Count = CFArrayGetCount(tagCollectionsOut);
    CFIndex v3 = Count - 1;
    if (Count < 1)
    {
      int v9 = 0;
LABEL_16:
      int v13 = 0;
    }
    else
    {
      CFIndex v4 = Count;
      CFIndex v5 = 0;
      do
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(tagCollectionsOut, v5);
        int v7 = FigTagCollectionContainsTag(ValueAtIndex, *(void *)"seye\a", 1);
        if (v7) {
          BOOL v8 = 1;
        }
        else {
          BOOL v8 = v3 == v5;
        }
        ++v5;
      }
      while (!v8);
      int v9 = v7;
      CFIndex v10 = 0;
      while (1)
      {
        CFArrayRef v11 = CFArrayGetValueAtIndex(tagCollectionsOut, v10);
        int v12 = FigTagCollectionContainsTag(v11, *(void *)"seye\a", 2);
        if (v12) {
          break;
        }
        if (v4 == ++v10) {
          goto LABEL_16;
        }
      }
      int v13 = v12;
    }
    if (tagCollectionsOut) {
      CFRelease(tagCollectionsOut);
    }
  }
  else
  {
    int v13 = 0;
    int v9 = 0;
  }
  if (v13) {
    BOOL v15 = v9 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  return !v15;
}

BOOL FigVideoFormatDescriptionGetMVHEVCVideoLayerIDs(const opaqueCMFormatDescription *a1, uint64_t *a2, uint64_t *a3)
{
  CFArrayRef tagCollectionsOut = 0;
  if (CMFormatDescriptionGetMediaType(a1) != 1986618469 && CMFormatDescriptionGetMediaType(a1) != 1635088502) {
    goto LABEL_44;
  }
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  int v7 = 0;
  if (MediaSubType > 1836415072)
  {
    if (MediaSubType > 1902407031)
    {
      if (MediaSubType > 1902671458)
      {
        if (MediaSubType == 1902998904) {
          goto LABEL_28;
        }
        unsigned __int16 v9 = 30307;
      }
      else
      {
        if (MediaSubType == 1902407032) {
          goto LABEL_28;
        }
        unsigned __int16 v9 = 25974;
      }
      int v8 = v9 | 0x71680000;
    }
    else if (MediaSubType > 1902405680)
    {
      if (MediaSubType == 1902405681) {
        goto LABEL_28;
      }
      int v8 = 1902405733;
    }
    else
    {
      if (MediaSubType == 1836415073) {
        goto LABEL_28;
      }
      int v8 = 1869117027;
    }
  }
  else if (MediaSubType > 1685481572)
  {
    if (MediaSubType > 1751479856)
    {
      if (MediaSubType == 1751479857) {
        goto LABEL_28;
      }
      int v8 = 1752589105;
    }
    else
    {
      if (MediaSubType == 1685481573) {
        goto LABEL_28;
      }
      int v8 = 1718908520;
    }
  }
  else if (MediaSubType > 1684895095)
  {
    if (MediaSubType == 1684895096) {
      goto LABEL_28;
    }
    int v8 = 1685481521;
  }
  else
  {
    if (MediaSubType == 1667524657) {
      goto LABEL_28;
    }
    int v8 = 1667790435;
  }
  int v10 = 0;
  if (MediaSubType != v8) {
    goto LABEL_52;
  }
LABEL_28:
  CMVideoFormatDescriptionCopyTagCollectionArray(a1, &tagCollectionsOut);
  if (!tagCollectionsOut)
  {
    int v10 = 0;
    int v7 = 0;
    goto LABEL_54;
  }
  CFIndex Count = CFArrayGetCount(tagCollectionsOut);
  if (Count >= 1)
  {
    CFIndex v12 = Count;
    CFIndex v13 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const OpaqueCMTagCollection *)CFArrayGetValueAtIndex(tagCollectionsOut, v13);
      if (FigTagCollectionContainsTag(ValueAtIndex, *(void *)"seye\a", 1)) {
        break;
      }
      if (v12 == ++v13)
      {
        int v7 = 0;
        goto LABEL_40;
      }
    }
    *(void *)&tagBuffer.category = 0;
    tagBuffer.uint64_t value = 0;
    CMItemCount v21 = 0;
    if (FigTagCollectionGetTagsWithCategory(ValueAtIndex, 1986814329, &tagBuffer, 1, &v21)) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v21 == 1;
    }
    if (!v15) {
      goto LABEL_44;
    }
    *a2 = FigTagGetSInt64Value(*(uint64_t *)&tagBuffer.category, tagBuffer.value);
    int v7 = 1;
LABEL_40:
    CFIndex v16 = 0;
    while (1)
    {
      CFStringRef v17 = (const OpaqueCMTagCollection *)CFArrayGetValueAtIndex(tagCollectionsOut, v16);
      if (FigTagCollectionContainsTag(v17, *(void *)"seye\a", 2)) {
        break;
      }
      if (v12 == ++v16) {
        goto LABEL_45;
      }
    }
    *(void *)&tagBuffer.category = 0;
    tagBuffer.uint64_t value = 0;
    CMItemCount v21 = 0;
    if (FigTagCollectionGetTagsWithCategory(v17, 1986814329, &tagBuffer, 1, &v21)) {
      BOOL v18 = 0;
    }
    else {
      BOOL v18 = v21 == 1;
    }
    if (v18)
    {
      *a3 = FigTagGetSInt64Value(*(uint64_t *)&tagBuffer.category, tagBuffer.value);
      int v10 = 1;
      goto LABEL_52;
    }
    goto LABEL_45;
  }
LABEL_44:
  int v7 = 0;
LABEL_45:
  int v10 = 0;
LABEL_52:
  if (tagCollectionsOut) {
    CFRelease(tagCollectionsOut);
  }
LABEL_54:
  if (v10) {
    BOOL v19 = v7 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  return !v19;
}

uint64_t FigVideoCreateBlockBufferAndFormatDescriptionForHoistingInStreamParameterSets(const opaqueCMFormatDescription *a1, OpaqueCMBlockBuffer *a2, unint64_t a3, void *a4)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  CMFormatDescriptionRef formatDescriptionOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  *(_OWORD *)parameterSetPointers = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v68 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  *(_OWORD *)parameterSetSizes = 0u;
  signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  signed int v9 = MediaSubType;
  signed int valuePtr = MediaSubType;
  int v10 = 1;
  if (MediaSubType > 1836415072)
  {
    if (MediaSubType > 1902407031)
    {
      if (MediaSubType > 1902671458)
      {
        if (MediaSubType == 1902671459) {
          goto LABEL_26;
        }
        int v11 = 1902998904;
      }
      else
      {
        if (MediaSubType == 1902407032) {
          goto LABEL_26;
        }
        int v11 = 1902667126;
      }
    }
    else if (MediaSubType > 1902405680)
    {
      if (MediaSubType == 1902405681) {
        goto LABEL_26;
      }
      int v11 = 1902405733;
    }
    else
    {
      if (MediaSubType == 1836415073) {
        goto LABEL_26;
      }
      int v11 = 1869117027;
    }
LABEL_24:
    if (MediaSubType != v11) {
      int v10 = 0;
    }
    goto LABEL_26;
  }
  if (MediaSubType > 1685481572)
  {
    if (MediaSubType > 1751479856)
    {
      if (MediaSubType == 1751479857) {
        goto LABEL_26;
      }
      int v11 = 1752589105;
    }
    else
    {
      if (MediaSubType == 1685481573) {
        goto LABEL_26;
      }
      int v11 = 1718908520;
    }
    goto LABEL_24;
  }
  if (MediaSubType > 1684895095)
  {
    if (MediaSubType == 1684895096) {
      goto LABEL_26;
    }
    int v11 = 1685481521;
    goto LABEL_24;
  }
  if (MediaSubType != 1667524657)
  {
    int v11 = 1667790435;
    goto LABEL_24;
  }
LABEL_26:
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  if (!a1) {
    goto LABEL_128;
  }
  if (!a3)
  {
    uint64_t v37 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef MutableCopy = 0;
    a2 = 0;
    goto LABEL_130;
  }
  if (!a2)
  {
    uint64_t v37 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef MutableCopy = 0;
    goto LABEL_132;
  }
  if (!a4)
  {
LABEL_128:
    uint64_t v37 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef MutableCopy = 0;
    a2 = 0;
LABEL_132:
    CFNumberRef v38 = 0;
    a3 = 0;
    goto LABEL_105;
  }
  int v51 = v9;
  uint64_t v48 = (void *)a3;
  *(CMVideoDimensions *)double width = Dimensions;
  desc = a1;
  *(void *)a3 = 0;
  CFTypeID v50 = a4;
  *a4 = 0;
  size_t DataLength = CMBlockBufferGetDataLength(a2);
  if (!DataLength)
  {
    a3 = 0;
LABEL_74:
    if (v51 <= 1751479856)
    {
      if (v51 == 1635148595)
      {
        CMVideoCodecType v31 = 1635148593;
        goto LABEL_86;
      }
      if (v51 == 1685481573)
      {
        CMVideoCodecType v31 = 1685481521;
        goto LABEL_86;
      }
    }
    else
    {
      switch(v51)
      {
        case 1751479857:
          CMVideoCodecType v31 = 1752589105;
          goto LABEL_86;
        case 1902405733:
          CMVideoCodecType v31 = 1902405681;
          goto LABEL_86;
        case 1902667126:
          CMVideoCodecType v31 = 1902671459;
          goto LABEL_86;
      }
    }
    CMVideoCodecType v31 = v51;
LABEL_86:
    if (a3)
    {
      CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
      CFDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(v32, Extensions);
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, @"SampleDescriptionExtensionAtoms");
      a2 = FigCFDictionaryCreateMutableCopy(v32, Value);
      if (v10)
      {
        uint64_t v36 = FigVideoFormatDescriptionCreateUpdatedFromHEVCParameterSets(v32, a1, a3, (uint64_t)parameterSetPointers, (uint64_t)parameterSetSizes, 4u, &formatDescriptionOut);
        if (v36)
        {
LABEL_89:
          uint64_t v37 = v36;
LABEL_130:
          CFNumberRef v38 = 0;
          goto LABEL_105;
        }
      }
      else
      {
        uint64_t v36 = CMVideoFormatDescriptionCreateFromH264ParameterSets(v32, a3, (const uint8_t *const *)parameterSetPointers, parameterSetSizes, 4, &formatDescriptionOut);
        if (v36) {
          goto LABEL_89;
        }
      }
      CFDictionaryRef v39 = CMFormatDescriptionGetExtensions(formatDescriptionOut);
      CFDictionaryRef v40 = (const __CFDictionary *)CFDictionaryGetValue(v39, @"SampleDescriptionExtensionAtoms");
      CFDictionaryApplyFunction(v39, (CFDictionaryApplierFunction)sFigTransferDictionaryValues, MutableCopy);
      CFDictionaryApplyFunction(v40, (CFDictionaryApplierFunction)sFigTransferDictionaryValues, a2);
      CFDictionarySetValue(MutableCopy, @"SampleDescriptionExtensionAtoms", a2);
      CFDictionaryRemoveValue(MutableCopy, @"VerbatimISOSampleEntry");
      CFDictionaryRemoveValue(MutableCopy, @"VerbatimSampleDescription");
      if (v31 == valuePtr)
      {
        CFNumberRef v38 = 0;
      }
      else
      {
        CFNumberRef v38 = CFNumberCreate(v32, kCFNumberSInt32Type, &valuePtr);
        CFDictionarySetValue(MutableCopy, @"OriginalCodec", v38);
      }
      if (formatDescriptionOut)
      {
        CFRelease(formatDescriptionOut);
        CMFormatDescriptionRef formatDescriptionOut = 0;
      }
    }
    else
    {
      if (v31 == v51)
      {
        CFNumberRef v38 = 0;
        a2 = 0;
        CFDictionaryRef MutableCopy = 0;
LABEL_100:
        CFArrayRef v43 = blockBufferOut;
        if (blockBufferOut) {
          CFArrayRef v43 = (void *)CFRetain(blockBufferOut);
        }
        *CFTypeID v50 = v43;
        if (formatDescriptionOut && !CMFormatDescriptionEqual(desc, formatDescriptionOut))
        {
          uint64_t v37 = 0;
          CFTypeID v28 = 0;
          *uint64_t v48 = FigFormatDescriptionRetain(formatDescriptionOut);
          goto LABEL_111;
        }
        uint64_t v37 = 0;
LABEL_105:
        CFTypeID v28 = 0;
        goto LABEL_111;
      }
      CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDictionaryRef v41 = CMFormatDescriptionGetExtensions(a1);
      CFDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy(v32, v41);
      CFNumberRef v38 = CFNumberCreate(v32, kCFNumberSInt32Type, &valuePtr);
      CFDictionarySetValue(MutableCopy, @"OriginalCodec", v38);
      a2 = 0;
    }
    uint64_t v42 = CMVideoFormatDescriptionCreate(v32, v31, width[0], width[1], MutableCopy, &formatDescriptionOut);
    if (v42)
    {
      uint64_t v37 = v42;
      goto LABEL_105;
    }
    goto LABEL_100;
  }
  unint64_t v14 = DataLength;
  a3 = 0;
  size_t v15 = 0;
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef blockAllocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  CFAllocatorRef v52 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    unsigned int destination = 0;
    unsigned __int8 v56 = 0;
    if (v15 + 5 > v14) {
      goto LABEL_107;
    }
    uint64_t appended = CMBlockBufferCopyDataBytes(a2, v15, 4uLL, &destination);
    if (appended) {
      goto LABEL_109;
    }
    uint64_t v18 = bswap32(destination);
    unsigned int destination = v18;
    if (v15 + 4 + v18 > v14)
    {
LABEL_107:
      uint64_t v44 = 4294954554;
      goto LABEL_108;
    }
    uint64_t appended = CMBlockBufferCopyDataBytes(a2, v15 + 4, 1uLL, &v56);
    if (appended) {
      goto LABEL_109;
    }
    if (v10)
    {
      int v19 = (v56 >> 1) & 0x3F;
      unsigned __int8 v56 = (v56 >> 1) & 0x3F;
      if ((v19 - 32) >= 3)
      {
        if (v19 == 39)
        {
          int v20 = 0;
          size_t v21 = v15 + 4 + destination;
          unsigned __int8 v55 = 0;
          size_t v22 = v15 + 7;
          while (1)
          {
            uint64_t appended = CMBlockBufferCopyDataBytes(a2, v22 - 1, 1uLL, &v55);
            if (appended) {
              goto LABEL_109;
            }
            v20 += v55;
            if (v55 != 255 || v22++ >= v21)
            {
              if ((v20 - 137) <= 0xA && ((1 << (v20 + 119)) & 0x481) != 0)
              {
                CFAllocatorRef v16 = v52;
                goto LABEL_52;
              }
              CFAllocatorRef v16 = v52;
              break;
            }
          }
        }
LABEL_69:
        if (blockBufferOut)
        {
          uint64_t appended = CMBlockBufferAppendBufferReference(blockBufferOut, a2, v15, destination + 4, 0);
          if (appended) {
            goto LABEL_109;
          }
        }
        goto LABEL_71;
      }
    }
    else
    {
      v56 &= 0x1Fu;
      if (v56 - 7 >= 2) {
        goto LABEL_69;
      }
    }
LABEL_52:
    size_t v25 = destination + 4;
    if (v25 <= 6) {
      goto LABEL_107;
    }
    if (!blockBufferOut)
    {
      if (v15)
      {
        uint64_t appended = CMBlockBufferCreateWithBufferReference(v16, a2, 0, v15, 0, &blockBufferOut);
        if (appended) {
          goto LABEL_109;
        }
      }
      else
      {
        uint64_t appended = CMBlockBufferCreateEmpty(v16, 0, 0, &blockBufferOut);
        if (appended) {
          goto LABEL_109;
        }
      }
    }
    if (a3 >= 0x14) {
      goto LABEL_107;
    }
    size_t v26 = destination;
    parameterSetSizes[a3] = destination;
    CFNumberRef v27 = (uint8_t *)malloc_type_malloc(v26, 0x1F49BFCEuLL);
    parameterSetPointers[a3] = v27;
    if (!v27)
    {
      uint64_t v44 = 4294954510;
LABEL_108:
      uint64_t appended = FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
LABEL_109:
      uint64_t v37 = appended;
      CFTypeID v28 = 0;
      goto LABEL_110;
    }
    uint64_t appended = CMBlockBufferCopyDataBytes(a2, v15 + 4, destination, v27);
    if (appended) {
      goto LABEL_109;
    }
    CFTypeID v28 = malloc_type_malloc(v25, 0x700140E0uLL);
    if (!v28) {
      break;
    }
    uint64_t v29 = CMBlockBufferCopyDataBytes(a2, v15, 4uLL, v28);
    if (v29) {
      goto LABEL_127;
    }
    memset(v28 + 5, 255, v25 - 6);
    if (v10)
    {
      v28[5] = 1;
      char v30 = 76;
    }
    else
    {
      char v30 = 12;
    }
    v28[4] = v30;
    v28[v25 - 1] = 0x80;
    uint64_t appended = CMBlockBufferAppendMemoryBlock(blockBufferOut, v28, v25, blockAllocator, 0, 0, v25, 0);
    if (appended) {
      goto LABEL_109;
    }
    ++a3;
LABEL_71:
    v15 += destination + 4;
    if (v15 >= v14) {
      goto LABEL_74;
    }
  }
  uint64_t v29 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_127:
  uint64_t v37 = v29;
LABEL_110:
  CFDictionaryRef MutableCopy = 0;
  a2 = 0;
  CFNumberRef v38 = 0;
LABEL_111:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (formatDescriptionOut) {
    CFRelease(formatDescriptionOut);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (a2) {
    CFRelease(a2);
  }
  if (v38) {
    CFRelease(v38);
  }
  if (a3)
  {
    CFStringRef v45 = parameterSetPointers;
    do
    {
      uint64_t v46 = *v45++;
      free(v46);
      --a3;
    }
    while (a3);
  }
  free(v28);
  return v37;
}

void sFigTransferDictionaryValues(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile84(const opaqueCMFormatDescription *a1)
{
  __int16 v3 = 0;
  int DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v3 + 1, &v3);
  BOOL result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 8) {
      return v3 == 4;
    }
  }
  return result;
}

uint64_t sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(const opaqueCMFormatDescription *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t result = (uint64_t)CMFormatDescriptionGetExtension(a1, @"SampleDescriptionExtensionAtoms");
  if (result)
  {
    CFDictionaryRef v6 = (const __CFDictionary *)result;
    CFTypeID v7 = CFGetTypeID((CFTypeRef)result);
    if (v7 != CFDictionaryGetTypeID()) {
      return 0;
    }
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v6, @"dvvC");
    if (Value)
    {
      CFDataRef v9 = Value;
      BytePtr = CFDataGetBytePtr(Value);
      if (CFDataGetLength(v9) <= 8)
      {
LABEL_13:
        FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
        return 0;
      }
      int v11 = *BytePtr;
      int v12 = BytePtr[1];
    }
    else
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(v6, @"dvcC");
      if (!result) {
        return result;
      }
      CFDataRef v13 = (const __CFData *)result;
      BytePtr = CFDataGetBytePtr((CFDataRef)result);
      if (CFDataGetLength(v13) <= 8) {
        goto LABEL_13;
      }
      int v12 = BytePtr[1];
      int v11 = *BytePtr & 0xFD;
    }
    if (v11 != 1 || v12 != 0) {
      goto LABEL_13;
    }
    if (a2) {
      *a2 = BytePtr[2] >> 1;
    }
    if (a3) {
      *a3 = BytePtr[4] >> 4;
    }
    return 1;
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile81(const opaqueCMFormatDescription *a1)
{
  __int16 v3 = 0;
  int DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v3 + 1, &v3);
  BOOL result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 8) {
      return v3 == 1;
    }
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10p0(const opaqueCMFormatDescription *a1)
{
  __int16 v3 = 0;
  int DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v3 + 1, &v3);
  BOOL result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 10) {
      return (_BYTE)v3 == 0;
    }
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10p1(const opaqueCMFormatDescription *a1)
{
  __int16 v3 = 0;
  int DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v3 + 1, &v3);
  BOOL result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 10) {
      return v3 == 1;
    }
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10p4(const opaqueCMFormatDescription *a1)
{
  __int16 v3 = 0;
  int DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v3 + 1, &v3);
  BOOL result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 10) {
      return v3 == 4;
    }
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10(const opaqueCMFormatDescription *a1)
{
  return FigVideoFormatDescriptionConformsToDolbyVisionProfile10p0(a1)
      || FigVideoFormatDescriptionConformsToDolbyVisionProfile10p1(a1)
      || FigVideoFormatDescriptionConformsToDolbyVisionProfile10p4(a1);
}

uint64_t CMVideoFormatDescriptionGetVideoDynamicRange(const opaqueCMFormatDescription *a1)
{
  __int16 v15 = 0;
  FourCharCode MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  if (!a1) {
    return 0;
  }
  int v3 = MediaSubType;
  uint64_t result = 6;
  if (v3 > 1685481572)
  {
    if (v3 > 1902405680)
    {
      if (v3 != 1902405681 && v3 != 1902407032)
      {
        int v5 = 1902405733;
        goto LABEL_16;
      }
LABEL_17:
      int DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v15 + 1, &v15);
      if (HIBYTE(v15) != 20 || DolbyVisionProfileAndCompatibilityIDIfGiven == 0) {
        return 5;
      }
      else {
        return 10;
      }
    }
    if (v3 == 1685481573) {
      goto LABEL_17;
    }
    int v6 = 1902403958;
LABEL_12:
    if (v3 == v6) {
      return result;
    }
    goto LABEL_24;
  }
  if (v3 <= 1684895095)
  {
    if (v3 == 1667524657) {
      goto LABEL_17;
    }
    int v6 = 1684108849;
    goto LABEL_12;
  }
  if (v3 == 1684895096) {
    goto LABEL_17;
  }
  int v5 = 1685481521;
LABEL_16:
  if (v3 == v5) {
    goto LABEL_17;
  }
LABEL_24:
  CFPropertyListRef Extension = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E4F24BC8]);
  if (FigCFEqual(Extension, @"SMPTE_ST_2084_PQ"))
  {
    int v10 = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v15 + 1, &v15);
    uint64_t result = 4;
    if (!v10 || v15 != 1) {
      return result;
    }
    if (HIBYTE(v15) != 10)
    {
      if (HIBYTE(v15) != 8) {
        return result;
      }
      if (v3 <= 1836415072)
      {
        if (v3 > 1751479856)
        {
          if (v3 == 1751479857) {
            return 8;
          }
          int v11 = 1752589105;
        }
        else
        {
          if (v3 == 1667790435) {
            return 8;
          }
          int v11 = 1718908520;
        }
      }
      else if (v3 <= 1902667125)
      {
        if (v3 == 1836415073) {
          return 8;
        }
        int v11 = 1869117027;
      }
      else
      {
        if (v3 == 1902667126 || v3 == 1902998904) {
          return 8;
        }
        int v11 = 1902671459;
      }
      if (v3 != v11) {
        return result;
      }
      return 8;
    }
    BOOL v13 = v3 == 1902212657 || v3 == 1635135537;
    unsigned int v14 = 9;
LABEL_60:
    if (v13) {
      return v14;
    }
    else {
      return result;
    }
  }
  if (FigCFEqual(Extension, @"ITU_R_2100_HLG"))
  {
    int v12 = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (unsigned char *)&v15 + 1, &v15);
    uint64_t result = 2;
    if (!v12 || v15 != 4) {
      return result;
    }
    if (HIBYTE(v15) == 10)
    {
      BOOL v13 = v3 == 1902212657 || v3 == 1635135537;
      unsigned int v14 = 7;
      goto LABEL_60;
    }
    if (HIBYTE(v15) == 8)
    {
      if (FigVideoCodecTypeIsHEVCFlavor(v3)) {
        return 3;
      }
      else {
        return 2;
      }
    }
  }
  else
  {
    return !Extension
        || FigCFEqual(Extension, @"ITU_R_2020")
        || FigCFEqual(Extension, @"SMPTE_ST_428_1")
        || FigCFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F24BE0])
        || FigCFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F24BF0])
        || FigCFEqual(Extension, (CFTypeRef)*MEMORY[0x1E4F24C08])
        || FigCFEqual(Extension, @"IEC_sRGB") != 0;
  }
  return result;
}

uint64_t FigVideoCodecTypeIsHEVCFlavor(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1836415072)
  {
    if (a1 > 1751479856)
    {
      if (a1 == 1751479857) {
        return result;
      }
      int v3 = 1752589105;
    }
    else
    {
      if (a1 == 1667790435) {
        return result;
      }
      int v3 = 1718908520;
    }
    goto LABEL_13;
  }
  if (a1 <= 1902667125)
  {
    if (a1 == 1836415073) {
      return result;
    }
    int v3 = 1869117027;
    goto LABEL_13;
  }
  if (a1 != 1902667126 && a1 != 1902671459)
  {
    int v3 = 1902998904;
LABEL_13:
    if (a1 != v3) {
      return 0;
    }
  }
  return result;
}

uint64_t CMVideoFormatDescriptionGetPlaintextMediaSubTypeAndEncryptionScheme(const opaqueCMFormatDescription *a1, _DWORD *a2, int *a3)
{
  int v3 = 1852796517;
  int v13 = 1852796517;
  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1986618469)
  {
    signed int MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
    int v14 = MediaSubType;
    if (MediaSubType <= 1902207794)
    {
      if (MediaSubType <= 1685220712)
      {
        if (MediaSubType > 1667524656)
        {
          if (MediaSubType <= 1667656802)
          {
            if (MediaSubType == 1667524657 || MediaSubType == 1667574579) {
              goto LABEL_84;
            }
            int v10 = 1667575091;
          }
          else if (MediaSubType > 1668047202)
          {
            if (MediaSubType == 1668047203) {
              goto LABEL_84;
            }
            int v10 = 1668641633;
          }
          else
          {
            if (MediaSubType == 1667656803) {
              goto LABEL_84;
            }
            int v10 = 1667790435;
          }
        }
        else
        {
          if (MediaSubType <= 1667326823)
          {
            if (MediaSubType == 1633771875 || MediaSubType == 1667312947) {
              goto LABEL_84;
            }
            unsigned __int16 v8 = 24931;
          }
          else if (MediaSubType > 1667330146)
          {
            if (MediaSubType == 1667330147) {
              goto LABEL_84;
            }
            unsigned __int16 v8 = 30307;
          }
          else
          {
            if (MediaSubType == 1667326824) {
              goto LABEL_84;
            }
            unsigned __int16 v8 = 25456;
          }
          int v10 = v8 | 0x63610000;
        }
        goto LABEL_83;
      }
      if (MediaSubType <= 1885430578)
      {
        if (MediaSubType <= 1701733237)
        {
          if (MediaSubType == 1685220713 || MediaSubType == 1700886115) {
            goto LABEL_84;
          }
          int v10 = 1701733217;
        }
        else if (MediaSubType > 1882599479)
        {
          if (MediaSubType == 1882599480) {
            goto LABEL_84;
          }
          int v10 = 1885430115;
        }
        else
        {
          if (MediaSubType == 1701733238) {
            goto LABEL_84;
          }
          int v10 = 1869117027;
        }
        goto LABEL_83;
      }
      if (MediaSubType <= 1885547314)
      {
        if ((MediaSubType - 1885430579) <= 0x3D
          && ((1 << (MediaSubType - 51)) & 0x2020000000000001) != 0)
        {
          goto LABEL_84;
        }
        goto LABEL_88;
      }
      if (MediaSubType <= 1886745440)
      {
        if (MediaSubType == 1885547315) {
          goto LABEL_84;
        }
        int v10 = 1885692723;
        goto LABEL_83;
      }
      if (MediaSubType == 1886745441) {
        goto LABEL_84;
      }
      unsigned __int16 v9 = 24931;
    }
    else
    {
      if (MediaSubType > 1902667125)
      {
        if (MediaSubType <= 2053202738)
        {
          if (MediaSubType <= 1902998903)
          {
            if (MediaSubType == 1902667126 || MediaSubType == 1902671459) {
              goto LABEL_84;
            }
            int v10 = 1902928227;
          }
          else if (MediaSubType > 1903587384)
          {
            if (MediaSubType == 1903587385) {
              goto LABEL_84;
            }
            int v10 = 2053202275;
          }
          else
          {
            if (MediaSubType == 1902998904) {
              goto LABEL_84;
            }
            int v10 = 1903522657;
          }
        }
        else
        {
          if (MediaSubType <= 2053319474)
          {
            if ((MediaSubType - 2053202739) > 0x3D
              || ((1 << (MediaSubType - 51)) & 0x2020000000000001) == 0)
            {
              if (MediaSubType == 2053207651)
              {
                int v14 = 1635148593;
                int v3 = 2053467747;
              }
              goto LABEL_88;
            }
LABEL_84:
            uint64_t result = FigBridge_GetPlaintextMediaSubTypeAndEncryptionSchemeFromProtectedCodecType(MediaSubType, &v14, &v13);
            if (result) {
              return result;
            }
            if (v13 == 1667392306) {
              int v3 = 1667392371;
            }
            else {
              int v3 = v13;
            }
            goto LABEL_88;
          }
          if (MediaSubType > 2053923170)
          {
            if (MediaSubType == 2053923171) {
              goto LABEL_84;
            }
            int v10 = 2054517601;
          }
          else
          {
            if (MediaSubType == 2053319475) {
              goto LABEL_84;
            }
            int v10 = 2053464883;
          }
        }
        goto LABEL_83;
      }
      if (MediaSubType > 1902324530)
      {
        if (MediaSubType <= 1902405732)
        {
          if (MediaSubType == 1902324531 || MediaSubType == 1902403958) {
            goto LABEL_84;
          }
          unsigned __int16 v11 = 26673;
        }
        else
        {
          if (MediaSubType > 1902469938)
          {
            if (MediaSubType == 1902469939) {
              goto LABEL_84;
            }
            int v10 = 1902537827;
            goto LABEL_83;
          }
          if (MediaSubType == 1902405733) {
            goto LABEL_84;
          }
          unsigned __int16 v11 = 28024;
        }
        int v10 = v11 | 0x71640000;
LABEL_83:
        if (MediaSubType == v10) {
          goto LABEL_84;
        }
LABEL_88:
        if (a2) {
          *a2 = v14;
        }
        uint64_t result = 0;
        if (a3) {
          *a3 = v3;
        }
        return result;
      }
      if ((MediaSubType - 1902207795) <= 0x3D
        && ((1 << (MediaSubType - 51)) & 0x2020000000000001) != 0
        || (MediaSubType - 1902212657) <= 0x34
        && ((1 << (MediaSubType - 49)) & 0x14000000000001) != 0)
      {
        goto LABEL_84;
      }
      unsigned __int16 v9 = 28771;
    }
    int v10 = v9 | 0x71610000;
    goto LABEL_83;
  }

  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

__CFString *figVideoFormatDescriptionCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = (unsigned int *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  int v5 = Mutable;
  if (*DerivedStorage > 0xFF) {
    CFStringAppendFormat(Mutable, 0, @"\t\tcodecType: '%c%c%c%c'", HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  }
  else {
    CFStringAppendFormat(Mutable, 0, @"\t\tcodecType: %d", *DerivedStorage);
  }
  CFStringAppendFormat(v5, 0, @"\t\tdimensions: %d x %d", DerivedStorage[1], DerivedStorage[2]);
  return v5;
}

BOOL figVideoFormatDescriptionEqual(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  uint64_t DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions(a1);
  int v10 = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a2);
  CFDictionaryRef v11 = CMFormatDescriptionGetExtensions(a2);
  return *DerivedStorage == *v10
      && DerivedStorage[1] == v10[1]
      && DerivedStorage[2] == v10[2]
      && FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v11, a3, a4) != 0;
}

CFArrayRef FigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce()
{
  values[16] = *(void **)MEMORY[0x1E4F143B8];
  unsigned int v0 = (void *)*MEMORY[0x1E4F24AF8];
  values[0] = *(void **)MEMORY[0x1E4F24A78];
  values[1] = v0;
  int v1 = (void *)*MEMORY[0x1E4F24B98];
  values[2] = *(void **)MEMORY[0x1E4F24B00];
  values[3] = v1;
  int v2 = (void *)*MEMORY[0x1E4F24BC8];
  values[4] = *(void **)MEMORY[0x1E4F24A90];
  values[5] = v2;
  CFAllocatorRef v3 = (void *)*MEMORY[0x1E4F24C18];
  values[6] = *(void **)MEMORY[0x1E4F24B28];
  values[7] = v3;
  CFIndex v4 = (void *)*MEMORY[0x1E4F24A10];
  values[8] = @"CVImageBufferICCProfile";
  values[9] = v4;
  values[10] = *(void **)MEMORY[0x1E4F24A08];
  values[11] = @"MasteringDisplayColorVolume";
  values[12] = @"ContentLightLevelInfo";
  values[13] = @"ContentColorVolume";
  values[14] = @"AmbientViewingEnvironment";
  values[15] = @"LogTransferFunction";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 16, MEMORY[0x1E4F1D510]);
  sExtensionKeysCommonWithImageBuffers = (uint64_t)result;
  return result;
}

void FigMobileAsset_RegisterForAssetUpdates(const void *a1, int a2, const __CFDictionary *a3, const void *a4, int a5, uint64_t a6, uint64_t a7)
{
  if (figMobileAsset_Initialize_onceToken == -1)
  {
    if (!a6) {
      return;
    }
  }
  else
  {
    dispatch_once(&figMobileAsset_Initialize_onceToken, &__block_literal_global_7);
    if (!a6) {
      return;
    }
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &FigMobileAssetCallbackCFArrayCallbacks);
  value[0] = a6;
  value[1] = a7;
  CFArrayAppendValue(Mutable, value);
  figMobileAsset_QueryMostRecentAsset(a1, 0, a2, 1, a3, a4, Mutable);
  if (a1) {
    CFRetain(a1);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  if (Mutable) {
    CFRetain(Mutable);
  }
  if (figMobileAsset_GetNotificationQueue_onceToken != -1) {
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_42);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __FigMobileAsset_RegisterForAssetUpdates_block_invoke;
  block[3] = &__block_descriptor_88_e5_v8__0l;
  block[4] = a1;
  void block[5] = a3;
  void block[6] = a4;
  void block[7] = Mutable;
  int v16 = a2;
  int v17 = a5;
  void block[8] = a6;
  block[9] = a7;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void figMobileAsset_QueryMostRecentAsset(const void *a1, int a2, int a3, int a4, const __CFDictionary *a5, const void *a6, const void *a7)
{
  if (a2 <= 1)
  {
    uint64_t v23 = v7;
    uint64_t v24 = v8;
    int v16 = (void *)MEMORY[0x192FC5D30]();
    int v17 = (void *)[objc_alloc((Class)sMAAssetQueryClass) initWithType:a1];
    if (a5) {
      CFDictionaryApplyFunction(a5, (CFDictionaryApplierFunction)figMobileAsset_AddFilterToQuery, v17);
    }
    [v17 setDoNotBlockBeforeFirstUnlock:1];
    if (a4) {
      uint64_t v18 = 1;
    }
    else {
      uint64_t v18 = 2;
    }
    [v17 returnTypes:v18];
    if (a1) {
      CFRetain(a1);
    }
    if (a5) {
      CFRetain(a5);
    }
    if (a6) {
      CFRetain(a6);
    }
    if (a7) {
      CFRetain(a7);
    }
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 3221225472;
    v19[2] = __figMobileAsset_QueryMostRecentAsset_block_invoke;
    v19[3] = &unk_1E5676E58;
    char v22 = a4;
    v19[4] = v17;
    v19[5] = a1;
    v19[6] = a5;
    v19[7] = a6;
    v19[8] = a7;
    int v20 = a3;
    int v21 = a2;
    [v17 queryMetaData:v19];
  }
}

BOOL figMobileAsset_IsAssetTypeRegistered(void *key)
{
  if (figMobileAsset_Initialize_onceToken != -1) {
    dispatch_once(&figMobileAsset_Initialize_onceToken, &__block_literal_global_7);
  }
  BOOL result = 0;
  if (key)
  {
    if (gRegisteredAssetTypes) {
      return CFDictionaryContainsKey((CFDictionaryRef)gRegisteredAssetTypes, key) != 0;
    }
  }
  return result;
}

void figMobileAsset_DownloadCatalogAndRequery(CFTypeRef cf, int a2)
{
  if (cf) {
    CFRetain(cf);
  }
  if (figMobileAsset_GetNotificationQueue_onceToken != -1) {
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_42);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __figMobileAsset_DownloadCatalogAndRequery_block_invoke;
  v4[3] = &__block_descriptor_44_e5_v8__0l;
  v4[4] = cf;
  int v5 = a2;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, v4);
}

void FigMobileAsset_UnregisterFromAssetUpdates(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  if (figMobileAsset_GetNotificationQueue_onceToken != -1) {
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_42);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __FigMobileAsset_UnregisterFromAssetUpdates_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = cf;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
}

void FigMobileAsset_UnregisterCallbackFromAssetUpdates(CFTypeRef cf, uint64_t a2, uint64_t a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (figMobileAsset_GetNotificationQueue_onceToken != -1) {
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_42);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __FigMobileAsset_UnregisterCallbackFromAssetUpdates_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = cf;
  void block[5] = a2;
  void block[6] = a3;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
}

void FigMobileAsset_UpdateCatalogIfTimeIntervalElapsed(const void *a1)
{
}

__n128 figMobileAsset_CallbackArrayRetain(const __CFAllocator *a1, __n128 *a2)
{
  CFAllocatorRef v3 = CFAllocatorAllocate(a1, 16, 0);
  if (v3)
  {
    __n128 result = *a2;
    *CFAllocatorRef v3 = *a2;
  }
  return result;
}

void figMobileAsset_CallbackArrayRelease(CFAllocatorRef allocator, void *ptr)
{
  if (ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
}

CFTypeID figMobileAsset_AddFilterToQuery(CFTypeID result, CFTypeRef cf, void *a3)
{
  if (result && cf && a3)
  {
    CFTypeID v5 = result;
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      return [a3 addKeyValuePair:v5 with:cf];
    }
    else
    {
      CFTypeID v7 = CFGetTypeID(cf);
      __n128 result = CFArrayGetTypeID();
      if (v7 == result)
      {
        return [a3 addKeyValueArray:v5 with:cf];
      }
    }
  }
  return result;
}

void figMobileAsset_UpdateLastUpdatedTime(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  if (figMobileAsset_GetNotificationQueue_onceToken != -1) {
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_42);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __figMobileAsset_UpdateLastUpdatedTime_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = cf;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
}

void figMobileAsset_ExtractPlistFromAssetForCallback(void *a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFTypeID v5 = (void *)[a1 getLocalFileUrl];
  if (v5)
  {
    CFTypeID v6 = v5;
    CFTypeID v7 = (const void *)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C978]), "initWithContentsOfURL:", objc_msgSend(v5, "URLByAppendingPathComponent:", a2));
    if (!v7) {
      CFTypeID v7 = (const void *)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithContentsOfURL:", objc_msgSend(v6, "URLByAppendingPathComponent:", a2));
    }
    if (a3 && CFArrayGetCount(a3) >= 1)
    {
      CFIndex v8 = 0;
      do
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a3, v8);
        if (*ValueAtIndex)
        {
          ((void (*)(const void *, void))*ValueAtIndex)(v7, ValueAtIndex[1]);
        }
        else
        {
          v16[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E10, 0, v16, &type);
          int v11 = v16[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v13 = v11;
          }
          else {
            unsigned int v13 = v11 & 0xFFFFFFFE;
          }
          if (v13)
          {
            v16[1] = 136315138;
            int v17 = "figMobileAsset_ExtractPlistFromAssetForCallback";
            int v14 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v11) = v16[0];
          }
          else
          {
            int v14 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E10, 0, 1, v14, v14 != &v18, v11, 0, v12);
        }
        ++v8;
      }
      while (CFArrayGetCount(a3) > v8);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

uint64_t FigNotificationCenterAddWeakListener(CFNotificationCenterRef center, void *observer, CFNotificationCallback callBack, CFStringRef name, unint64_t object, int a6, NSObject *a7)
{
  observera = 0;
  if ((a6 & 1) == 0 || a7)
  {
    if (!a7 && (a6 & 2) == 0)
    {
      CFNotificationCenterAddObserver(center, observer, callBack, name, (const void *)object, (CFNotificationSuspensionBehavior)1024);
      return 0;
    }
    CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"weak--%p--%p--%@--%p--listener", observer, callBack, name, object);
    if (!v17)
    {
      uint64_t v14 = 4294954570;
      goto LABEL_4;
    }
    CFStringRef v18 = v17;
    FigThreadRunOnce(&sFigNotificationCenterWeakListenerLinks, (void (*)(void))FigNotificationCenterWeakListenerLinksInitOnce);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (!Instance)
    {
      uint64_t v16 = FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
      goto LABEL_23;
    }
    uint64_t v20 = Instance;
    CFTypeRef v21 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)observer);
    *(void *)(v20 + 16) = v21;
    if (v21)
    {
      *(void *)(v20 + 24) = callBack;
      *(_DWORD *)(v20 + 48) = a6;
      if (a7)
      {
        dispatch_retain(a7);
        *(void *)(v20 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a7;
      }
      uint64_t Key = FigCFWeakReferenceTableAddValueAndGetKey(qword_1EB28B378, v20, &observera);
      if (!Key)
      {
        *(void *)(v20 + 32) = observera;
        FigSimpleMutexLock((pthread_mutex_t *)qword_1EB28B380);
        int v23 = CFDictionaryContainsKey((CFDictionaryRef)qword_1EB28B370, v18);
        if (v23)
        {
          uint64_t v16 = FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
          FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EB28B380);
          if (v16)
          {
LABEL_35:
            FigCFWeakReferenceTableRemoveValue(qword_1EB28B378, (uint64_t)observera);
            goto LABEL_22;
          }
          if (center) {
            goto LABEL_19;
          }
        }
        else
        {
          CFDictionarySetValue((CFMutableDictionaryRef)qword_1EB28B370, v18, (const void *)v20);
          FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EB28B380);
          if (center)
          {
LABEL_19:
            if (observera)
            {
              if ((unint64_t)name | object)
              {
                CFNotificationCenterAddObserver(center, observera, (CFNotificationCallback)fncHandleWeakNotification, name, (const void *)object, (CFNotificationSuspensionBehavior)0);
                uint64_t v16 = 0;
LABEL_22:
                CFRelease((CFTypeRef)v20);
LABEL_23:
                CFRelease(v18);
                return v16;
              }
              uint64_t v16 = 4294954571;
            }
            else
            {
              uint64_t v16 = 4294954573;
            }
            goto LABEL_33;
          }
        }
        uint64_t v16 = 4294954575;
LABEL_33:
        if (!v23)
        {
          FigSimpleMutexLock((pthread_mutex_t *)qword_1EB28B380);
          CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_1EB28B370, v18);
          FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EB28B380);
        }
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t Key = FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v16 = Key;
    goto LABEL_22;
  }
  uint64_t v14 = 4294954569;
LABEL_4:

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t CMNotificationCenterAddListener(__CFNotificationCenter *a1, const void *a2, void (__cdecl *a3)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef), const __CFString *a4, unint64_t a5)
{
  if (!a1) {
    return 4294954575;
  }
  if (!a3) {
    return 4294954576;
  }
  if (!a2) {
    return 4294954573;
  }
  if (!((unint64_t)a4 | a5)) {
    return 4294954571;
  }
  CFNotificationCenterAddObserver(a1, a2, a3, a4, (const void *)a5, (CFNotificationSuspensionBehavior)0);
  return 0;
}

void fncHandleWeakNotification(const void *a1, void *a2, const void *a3, const void *a4, uint64_t a5)
{
  unsigned __int16 v9 = (id **)FigCFWeakReferenceTableCopyValue(qword_1EB28B378, a2);
  if (!v9) {
    return;
  }
  uint64_t v10 = (uint64_t)v9;
  if (FigCFWeakReferenceHolderCopyReferencedObject(v9[2]))
  {
    int v11 = *(NSObject **)(v10 + 40);
    if (v11)
    {
      if (*(unsigned char *)(v10 + 48))
      {
        CFRetain(a4);
        int v11 = *(NSObject **)(v10 + 40);
      }
      CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      FigDeferNotificationToDispatchQueue((uint64_t)fncHandleDeferredNotification, a1, v10, a3, (uint64_t)a4, a5, v11, v12);
      return;
    }
    fncCallOriginalCallbackAndReleaseWeakListener(v10, (uint64_t)a1, (uint64_t)a3, (uint64_t)a4, a5);
  }

  CFRelease((CFTypeRef)v10);
}

uint64_t FigNotificationCenterRemoveWeakListener(__CFNotificationCenter *a1, const void *a2, uint64_t a3, const __CFString *a4, const void *a5)
{
  uint64_t value = 0;
  CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"weak--%p--%p--%@--%p--listener", a2, a3, a4, a5);
  if (v9)
  {
    CFStringRef v10 = v9;
    FigThreadRunOnce(&sFigNotificationCenterWeakListenerLinks, (void (*)(void))FigNotificationCenterWeakListenerLinksInitOnce);
    FigSimpleMutexLock((pthread_mutex_t *)qword_1EB28B380);
    if (CFDictionaryGetValueIfPresent((CFDictionaryRef)qword_1EB28B370, v10, (const void **)&value))
    {
      CFRetain(value);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_1EB28B370, v10);
    }
    FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EB28B380);
    if (value)
    {
      uint64_t v11 = *((void *)value + 4);
      if (a1)
      {
        if (v11)
        {
          CFNotificationCenterRemoveObserver(a1, *((const void **)value + 4), a4, a5);
          uint64_t v12 = 0;
        }
        else
        {
          uint64_t v12 = 4294954573;
        }
      }
      else
      {
        uint64_t v12 = 4294954575;
      }
      FigCFWeakReferenceTableRemoveValue(qword_1EB28B378, v11);
      CFRelease(value);
    }
    else
    {
      CFNotificationCenterRemoveObserver(a1, a2, a4, a5);
      uint64_t v12 = 0;
    }
    CFRelease(v10);
    return v12;
  }
  else
  {
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigNotificationCenterWeakListenerLinksInitOnce()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  qword_1EB28B370 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  qword_1EB28B380 = (uint64_t)FigSimpleMutexCreate();
  FigCFWeakReferenceTableCreate(v0, 0, &qword_1EB28B378);
  uint64_t result = _CFRuntimeRegisterClass();
  sfncWeakListenerLinkID = result;
  return result;
}

uint64_t CMNotificationCenterRemoveListener(__CFNotificationCenter *a1, const void *a2, int a3, CFNotificationName name, void *object)
{
  if (!a1) {
    return 4294954575;
  }
  if (!a2) {
    return 4294954573;
  }
  CFNotificationCenterRemoveObserver(a1, a2, name, object);
  return 0;
}

CFNotificationCenterRef CMNotificationCenterGetDefaultLocalCenter()
{
  FigThreadRunOnce(&CMNotificationCenterGetDefaultLocalCenter_initOnce, (void (*)(void))FigNotificationCenterSupportInitOnce);

  return CFNotificationCenterGetLocalCenter();
}

CFNotificationCenterRef CMNotificationCenterCreate()
{
  FigThreadRunOnce(&CMNotificationCenterGetDefaultLocalCenter_initOnce, (void (*)(void))FigNotificationCenterSupportInitOnce);
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
  CFRetain(LocalCenter);
  return LocalCenter;
}

uint64_t CMNotificationCenterPostNotification(__CFNotificationCenter *a1, const __CFString *a2, const void *a3, const __CFDictionary *cf)
{
  if (!a1) {
    return 4294954575;
  }
  if (!a2) {
    return 4294954574;
  }
  if (!a3) {
    return 4294954572;
  }
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    return FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    FigNotificationCenterSupportWillPostNotification((uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
    CFNotificationCenterPostNotification(a1, a2, a3, cf, 1u);
    FigNotificationCenterSupportDidPostNotification((uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
    return 0;
  }
}

uint64_t FigNotificationCenterAddWeakListeners(CFNotificationCenterRef center, void *observer, uint64_t a3, uint64_t a4, void *object, int a6, NSObject *a7)
{
  if (!a4) {
    return 0;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  while (1)
  {
    uint64_t v16 = *(void *)(a3 + v14)
        ? *(void (__cdecl **)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))(a3 + v14)
        : 0;
    uint64_t v17 = FigNotificationCenterAddWeakListener(center, observer, v16, **(CFStringRef **)(a3 + v14 + 8), (unint64_t)object, a6, a7);
    if (v17) {
      break;
    }
    ++v15;
    v14 += 16;
    if (a4 == v15) {
      return 0;
    }
  }
  uint64_t v18 = v17;
  FigNotificationCenterRemoveWeakListeners(center, observer, a3, v15, object);
  return v18;
}

uint64_t FigNotificationCenterRemoveWeakListeners(__CFNotificationCenter *a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  LODWORD(v1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  uint64_t v11 = (const __CFString ***)(a3 + 8);
  do
  {
    if (*(v11 - 1)) {
      uint64_t v12 = (uint64_t)*(v11 - 1);
    }
    else {
      uint64_t v12 = 0;
    }
    unsigned int v13 = *v11;
    v11 += 2;
    unsigned int v14 = FigNotificationCenterRemoveWeakListener(a1, a2, v12, *v13, a5);
    if (v10) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = v14 == 0;
    }
    if (v15) {
      uint64_t v10 = v10;
    }
    else {
      uint64_t v10 = v14;
    }
    v7 += 16;
    --v6;
  }
  while (v6);
  return v10;
}

void fncHandleDeferredNotification(uint64_t a1, unsigned char *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  fncCallOriginalCallbackAndReleaseWeakListener((uint64_t)a2, a1, a3, (uint64_t)a4, a5);
  if (a2[48]) {
    CFRelease(a4);
  }

  CFRelease(a2);
}

void fncCallOriginalCallbackAndReleaseWeakListener(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 16));
  (*(void (**)(uint64_t, id *, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, v10, a3, a4, a5);
  if (v10)
  {
    CFRelease(v10);
    if ((*(unsigned char *)(a1 + 48) & 2) != 0)
    {
      if (fncDeferReleaseWeakListenerToQueue_deferredReleaseQueueOnce != -1) {
        dispatch_once_f(&fncDeferReleaseWeakListenerToQueue_deferredReleaseQueueOnce, &fncDeferReleaseWeakListenerToQueue_deferredReleaseQueue, (dispatch_function_t)fncInitDeferredReleaseQueue);
      }
      uint64_t v11 = fncDeferReleaseWeakListenerToQueue_deferredReleaseQueue;
      dispatch_async_f(v11, v10, (dispatch_function_t)fncReleaseCFType);
    }
    else
    {
      CFRelease(v10);
    }
  }
}

dispatch_queue_t fncInitDeferredReleaseQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.coremedia.notificationcenter.deferredRelease", 0);
  *a1 = result;
  return result;
}

double fncWeakListenerLinkInit(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void fncWeakListenerLinkFinalize(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
  CFAllocatorRef v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  }
}

uint64_t FigDeferNotificationToDispatchQueue(uint64_t a1, const void *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, NSObject *a7, CFAllocatorRef allocator)
{
  uint64_t v16 = CFAllocatorAllocate(allocator, 64, 0);
  if (v16)
  {
    uint64_t v17 = v16;
    *uint64_t v16 = a2;
    v16[1] = a1;
    int v16[2] = a3;
    v16[3] = a4;
    v16[4] = a5;
    v16[5] = a6;
    void v16[6] = allocator;
    if (a2)
    {
      CFRetain(a2);
      a4 = (const void *)v17[3];
    }
    if (a4) {
      CFRetain(a4);
    }
    uint64_t v18 = (const void *)v17[5];
    if (v18) {
      CFRetain(v18);
    }
    uint64_t v19 = (const void *)v17[6];
    if (v19) {
      CFRetain(v19);
    }
    dispatch_async_f(a7, v17, (dispatch_function_t)figDeferredNotificationDispatchFunction);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  }
}

void figDeferredNotificationDispatchFunction(const void **ptr)
{
  int v2 = (void (*)(const void *, const void *, const void *, const void *, const void *))ptr[1];
  if (v2) {
    v2(*ptr, ptr[2], ptr[3], ptr[4], ptr[5]);
  }

  figDeferredNotificationRelease(ptr);
}

uint64_t FigDispatchAsyncPostNotification(NSObject *a1, const void *a2, const void *a3, const void *a4, const void *a5, int a6)
{
  if (a1 && a2)
  {
    if (a3 && a4)
    {
      uint64_t v12 = (const void *)*MEMORY[0x1E4F1CF80];
      unsigned int v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 64, 0);
      if (v13)
      {
        unsigned int v14 = v13;
        *unsigned int v13 = CFRetain(a2);
        v14[1] = 0;
        *((_DWORD *)v14 + 14) = a6;
        v14[3] = CFRetain(a3);
        v14[4] = CFRetain(a4);
        if (a5) {
          CFTypeRef v15 = CFRetain(a5);
        }
        else {
          CFTypeRef v15 = 0;
        }
        v14[5] = v15;
        if (v12) {
          CFTypeRef v16 = CFRetain(v12);
        }
        else {
          CFTypeRef v16 = 0;
        }
        v14[6] = v16;
        dispatch_async_f(a1, v14, (dispatch_function_t)figDeferredPostNotification);
        return 0;
      }
      uint64_t v18 = 4294954570;
    }
    else
    {
      uint64_t v18 = 4294954571;
    }
  }
  else
  {
    uint64_t v18 = 4294954575;
  }

  return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
}

void figDeferredPostNotification(uint64_t a1)
{
  CMNotificationCenterPostNotification(*(__CFNotificationCenter **)a1, *(const __CFString **)(a1 + 24), *(const void **)(a1 + 32), *(const __CFDictionary **)(a1 + 40));
  int v2 = *(void **)(a1 + 32);
  if (*(unsigned char *)(a1 + 56))
  {
    if (v2)
    {
      if (fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueueOnce != -1) {
        dispatch_once_f(&fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueueOnce, &fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueue, (dispatch_function_t)fdpnInitDeferredReleaseQueue);
      }
      dispatch_async_f((dispatch_queue_t)fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueue, v2, (dispatch_function_t)fdpnReleaseCFType);
    }
  }
  else if (v2)
  {
    CFRelease(*(CFTypeRef *)(a1 + 32));
  }

  figDeferredNotificationRelease((const void **)a1);
}

dispatch_queue_t fdpnInitDeferredReleaseQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.coremedia.deferredpostnotification.deferredRelease", 0);
  *a1 = result;
  return result;
}

CFTypeID CMSampleBufferGetTypeID(void)
{
  return sFigSampleBufferID;
}

void FigAttachmentsRegisterSampleBuffer()
{
  FigThreadRunOnce(&sRegisterFigSampleBufferTypeOnce, (void (*)(void))registerFigSampleBufferType);
  CFAllocatorRef v0 = (const void *)sFigSampleBufferID;

  FigRuntimeRegisterAttachmentBearerWithTypeID(sFigSampleBufferAttachmentBearerCallbacks, v0);
}

CFTypeRef FigSampleBufferRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

OSStatus CMSampleBufferCreate(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMItemCount numSampleSizeEntries, const size_t *sampleSizeArray, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, (uint64_t)makeDataReadyCallback, (uint64_t)makeDataReadyRefcon, 0, formatDescription, numSamples, numSampleTimingEntries, (void *)sampleTimingArray, numSampleSizeEntries, (void *)sampleSizeArray, sampleBufferOut);
}

uint64_t figSampleBufferCreateCallbackOrHandler(uint64_t a1, const void *a2, char a3, uint64_t a4, uint64_t a5, const void *a6, CMFormatDescriptionRef desc, unint64_t a8, unint64_t a9, void *__src, unint64_t a11, void *a12, void *a13)
{
  CFTypeRef cf = 0;
  if (!a13)
  {
    uint64_t v22 = 4294954565;
    goto LABEL_14;
  }
  if (a8)
  {
    BOOL v20 = a9 < 2 || a9 == a8;
    if (!v20 || (a11 >= 2 ? (BOOL v21 = a11 == a8) : (BOOL v21 = 1), !v21))
    {
LABEL_12:
      uint64_t v22 = 4294954558;
LABEL_14:
      uint64_t v23 = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
      goto LABEL_15;
    }
  }
  else if (a9 > 1 || a11 != 0)
  {
    goto LABEL_12;
  }
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398) {
    goto LABEL_27;
  }
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
  if (!StreamBasicDescription)
  {
    uint64_t v22 = 4294954586;
    goto LABEL_14;
  }
  if (!StreamBasicDescription->mFramesPerPacket || !StreamBasicDescription->mBytesPerPacket) {
    unint64_t v27 = a8;
  }
  else {
LABEL_27:
  }
    unint64_t v27 = 0;
  uint64_t v28 = sBufCreate(a1, a9, a11, v27, &cf);
  if (!v28)
  {
    if (a2)
    {
      CFTypeRef v29 = CFRetain(a2);
      char v30 = cf;
      *((void *)cf + 2) = v29;
    }
    else
    {
      char v30 = cf;
    }
    v30[25] = a3;
    if (a6)
    {
      v30[27] = 1;
      CMVideoCodecType v31 = _Block_copy(a6);
      *((void *)cf + 6) = v31;
    }
    else
    {
      *((void *)v30 + 6) = a4;
      *((void *)v30 + 7) = a5;
    }
    CFTypeRef v32 = FigFormatDescriptionRetain(desc);
    CFTypeRef v33 = cf;
    *((void *)cf + 9) = v32;
    *((void *)v33 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a8;
    uint64_t v34 = *((void *)v33 + 11);
    if (v34)
    {
      memcpy(*((void **)v33 + 12), __src, 72 * v34);
      sbufUpdateCachedTimestamps((uint64_t)cf, v35);
      CFTypeRef v33 = cf;
    }
    uint64_t v36 = *((void *)v33 + 13);
    if (v36)
    {
      memcpy(*((void **)v33 + 14), a12, 8 * v36);
      CFTypeRef v33 = cf;
    }
    figSampleBufferCheckDataSize((size_t)v33);
    uint64_t v23 = 0;
    CFTypeRef v24 = cf;
    goto LABEL_40;
  }
  uint64_t v23 = v28;
  if (cf) {
    CFRelease(cf);
  }
LABEL_15:
  if (a13)
  {
    CFTypeRef v24 = 0;
LABEL_40:
    *a13 = v24;
  }
  return v23;
}

OSStatus CMSampleBufferCreateWithMakeDataReadyHandler(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMItemCount numSampleSizeEntries, const size_t *sampleSizeArray, CMSampleBufferRef *sampleBufferOut, CMSampleBufferMakeDataReadyHandler makeDataReadyHandler)
{
  return figSampleBufferCreateCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, 0, 0, makeDataReadyHandler, formatDescription, numSamples, numSampleTimingEntries, (void *)sampleTimingArray, numSampleSizeEntries, (void *)sampleSizeArray, sampleBufferOut);
}

OSStatus CMSampleBufferCreateReady(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMItemCount numSampleSizeEntries, const size_t *sampleSizeArray, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateCallbackOrHandler((uint64_t)allocator, dataBuffer, 1, 0, 0, 0, formatDescription, numSamples, numSampleTimingEntries, (void *)sampleTimingArray, numSampleSizeEntries, (void *)sampleSizeArray, sampleBufferOut);
}

OSStatus CMAudioSampleBufferCreateWithPacketDescriptions(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMTime *presentationTimeStamp, const AudioStreamPacketDescription *packetDescriptions, CMSampleBufferRef *sampleBufferOut)
{
  CMTime v11 = *presentationTimeStamp;
  return figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, (uint64_t)makeDataReadyCallback, (uint64_t)makeDataReadyRefcon, 0, formatDescription, numSamples, (long long *)&v11.value, packetDescriptions, sampleBufferOut);
}

uint64_t figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler(uint64_t a1, const void *a2, int a3, uint64_t a4, uint64_t a5, const void *a6, CMFormatDescriptionRef desc, int64_t a8, long long *a9, void *a10, void *a11)
{
  CMTime v11 = a11;
  v63[0] = 0;
  if (!a11) {
    goto LABEL_57;
  }
  if (a8 <= 0)
  {
    uint64_t v24 = 4294954558;
    goto LABEL_17;
  }
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398) {
    goto LABEL_57;
  }
  if ((*((_DWORD *)a9 + 3) & 0x1D) != 1)
  {
    uint64_t v24 = 4294954556;
LABEL_17:
    uint64_t v25 = FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
    if (!v25) {
      goto LABEL_54;
    }
    goto LABEL_18;
  }
  if (!a2 && a3)
  {
LABEL_57:
    uint64_t v24 = 4294954565;
    goto LABEL_17;
  }
  uint64_t v58 = a4;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
  if (!StreamBasicDescription)
  {
    uint64_t v24 = 4294954586;
    goto LABEL_17;
  }
  BOOL v21 = StreamBasicDescription;
  if (StreamBasicDescription->mFramesPerPacket) {
    unint64_t v22 = 1;
  }
  else {
    unint64_t v22 = a8;
  }
  if (!StreamBasicDescription->mBytesPerPacket)
  {
    if (a10)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      uint64_t v28 = a10;
      do
      {
        if (v27)
        {
          if (*v28 != v26) {
            goto LABEL_29;
          }
        }
        else
        {
          uint64_t v26 = *a10;
        }
        v26 += *((unsigned int *)v28 + 3);
        ++v27;
        v28 += 2;
      }
      while (a8 != v27);
      unint64_t v23 = a8;
      goto LABEL_30;
    }
    goto LABEL_57;
  }
  if (StreamBasicDescription->mFormatID == 1819304813 && (StreamBasicDescription->mFormatFlags & 0x20) != 0) {
LABEL_29:
  }
    unint64_t v23 = 0;
  else {
    unint64_t v23 = 1;
  }
LABEL_30:
  uint64_t v29 = sBufCreate(a1, v22, v23, a8, v63);
  if (!v29)
  {
    if (a2)
    {
      CFTypeRef v30 = CFRetain(a2);
      CMVideoCodecType v31 = (char *)v63[0];
      *((void *)v63[0] + 2) = v30;
      *((_DWORD *)v31 + 7) = 0;
    }
    else
    {
      CMVideoCodecType v31 = (char *)v63[0];
    }
    v31[25] = a3;
    if (a6)
    {
      v31[27] = 1;
      CFTypeRef v32 = _Block_copy(a6);
      *((void *)v63[0] + 6) = v32;
    }
    else
    {
      *((void *)v31 + 6) = v58;
      *((void *)v31 + 7) = a5;
    }
    CFTypeRef v33 = FigFormatDescriptionRetain(desc);
    uint64_t v34 = (char *)v63[0];
    *((void *)v63[0] + 9) = v33;
    *((void *)v34 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a8;
    __n128 v35 = (long long *)*((void *)v34 + 12);
    *((_OWORD *)v34 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&kCMTimeInvalid.value;
    *((void *)v34 + 22) = 0;
    long long v36 = *a9;
    *((void *)v34 + 25) = *((void *)a9 + 2);
    *(_OWORD *)(v34 + 184) = v36;
    *((void *)v34 + 28) = 0;
    *((_OWORD *)v34 + 13) = *(_OWORD *)&kCMTimeZero.value;
    int64_t mFramesPerPacket = v21->mFramesPerPacket;
    if (mFramesPerPacket)
    {
      CMTimeMake(&v62, mFramesPerPacket, (int)v21->mSampleRate);
      long long v38 = *(_OWORD *)&v62.value;
      *((void *)v35 + 2) = v62.epoch;
      *__n128 v35 = v38;
      long long v39 = *a9;
      *((void *)v35 + 5) = *((void *)a9 + 2);
      *(long long *)((char *)v35 + 24) = v39;
      v35[3] = *(_OWORD *)&kCMTimeInvalid.value;
      *((void *)v35 + 8) = 0;
      CFDictionaryRef v40 = (char *)v63[0];
      int32_t v41 = *((_DWORD *)v63[0] + 20);
      long long v42 = *v35;
      time.CMTimeEpoch epoch = *((void *)v35 + 2);
      *(_OWORD *)&time.uint64_t value = v42;
      CMTimeMultiply(&v62, &time, v41);
      *(CMTime *)(v40 + 208) = v62;
    }
    else
    {
      *(_OWORD *)&v62.uint64_t value = *a9;
      v62.CMTimeEpoch epoch = *((void *)a9 + 2);
      if (!a10) {
        goto LABEL_61;
      }
      CFArrayRef v43 = (unsigned int *)(a10 + 1);
      int64_t v44 = a8;
      do
      {
        unsigned int v45 = *v43;
        v43 += 4;
        CMTimeMake(&time, v45, (int)v21->mSampleRate);
        long long v46 = *(_OWORD *)&time.value;
        *((void *)v35 + 2) = time.epoch;
        *__n128 v35 = v46;
        long long v47 = *(_OWORD *)&v62.value;
        *((void *)v35 + 5) = v62.epoch;
        *(long long *)((char *)v35 + 24) = v47;
        v35[3] = *(_OWORD *)&kCMTimeInvalid.value;
        *((void *)v35 + 8) = 0;
        uint64_t v48 = (char *)v63[0];
        CMTime lhs = *(CMTime *)((char *)v63[0] + 208);
        long long v49 = *v35;
        rhs.CMTimeEpoch epoch = *((void *)v35 + 2);
        *(_OWORD *)&rhs.uint64_t value = v49;
        CMTimeAdd(&time, &lhs, &rhs);
        *(CMTime *)(v48 + 208) = time;
        CMTime time = v62;
        long long v50 = *v35;
        lhs.CMTimeEpoch epoch = *((void *)v35 + 2);
        *(_OWORD *)&lhs.uint64_t value = v50;
        CMTimeAdd(&v62, &time, &lhs);
        __n128 v35 = (long long *)((char *)v35 + 72);
        --v44;
      }
      while (v44);
    }
    if (!v23)
    {
LABEL_47:
      if (!a10)
      {
        uint64_t v25 = 0;
        CMTime v11 = a11;
        goto LABEL_54;
      }
      int v51 = (void **)v63[0];
      CMTime v11 = a11;
      goto LABEL_53;
    }
    int v51 = (void **)v63[0];
    CFAllocatorRef v52 = (void *)*((void *)v63[0] + 14);
    uint64_t mBytesPerPacket = v21->mBytesPerPacket;
    if (mBytesPerPacket)
    {
      if (v21->mFormatID != 1819304813 || (v21->mFormatFlags & 0x20) == 0) {
        *CFAllocatorRef v52 = mBytesPerPacket;
      }
      goto LABEL_47;
    }
    if (a10)
    {
      CFTypeID v54 = (unsigned int *)a10 + 3;
      int64_t v55 = a8;
      CMTime v11 = a11;
      do
      {
        unsigned int v56 = *v54;
        v54 += 4;
        *v52++ = v56;
        --v55;
      }
      while (v55);
LABEL_53:
      memcpy(v51[41], a10, 16 * a8);
      uint64_t v25 = 0;
      *((unsigned char *)v63[0] + 344) = 1;
      goto LABEL_54;
    }
LABEL_61:
    uint64_t v25 = FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    CMTime v11 = a11;
    if (!v25) {
      goto LABEL_54;
    }
    goto LABEL_18;
  }
  uint64_t v25 = v29;
  CMTime v11 = a11;
LABEL_18:
  if (v63[0]) {
    CFRelease(v63[0]);
  }
  v63[0] = 0;
LABEL_54:
  if (v11) {
    void *v11 = v63[0];
  }
  return v25;
}

OSStatus CMAudioSampleBufferCreateWithPacketDescriptionsAndMakeDataReadyHandler(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMTime *presentationTimeStamp, const AudioStreamPacketDescription *packetDescriptions, CMSampleBufferRef *sampleBufferOut, CMSampleBufferMakeDataReadyHandler makeDataReadyHandler)
{
  CMTime v10 = *presentationTimeStamp;
  return figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, 0, 0, makeDataReadyHandler, formatDescription, numSamples, (long long *)&v10.value, packetDescriptions, sampleBufferOut);
}

OSStatus CMAudioSampleBufferCreateReadyWithPacketDescriptions(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMTime *presentationTimeStamp, const AudioStreamPacketDescription *packetDescriptions, CMSampleBufferRef *sampleBufferOut)
{
  CMTime v8 = *presentationTimeStamp;
  return figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler((uint64_t)allocator, dataBuffer, 1, 0, 0, 0, formatDescription, numSamples, (long long *)&v8.value, packetDescriptions, sampleBufferOut);
}

OSStatus CMSampleBufferCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateForImageBufferCallbackOrHandler((uint64_t)allocator, imageBuffer, dataReady, (uint64_t)makeDataReadyCallback, (uint64_t)makeDataReadyRefcon, 0, formatDescription, (uint64_t)sampleTiming, sampleBufferOut);
}

uint64_t figSampleBufferCreateForImageBufferCallbackOrHandler(uint64_t a1, void *a2, char a3, uint64_t a4, uint64_t a5, const void *a6, CMFormatDescriptionRef desc, uint64_t a8, void *a9)
{
  CFTypeRef cf = 0;
  uint64_t v10 = 4294954565;
  if (!a2 || !desc || !a9) {
    goto LABEL_23;
  }
  if (CMFormatDescriptionGetMediaType(desc) != 1986618469
    && CMFormatDescriptionGetMediaType(desc) != 1635088502
    && CMFormatDescriptionGetMediaType(desc) != 1885954932)
  {
    uint64_t v10 = 4294954555;
    goto LABEL_23;
  }
  if (!a8)
  {
    uint64_t v10 = 4294954565;
LABEL_23:
    uint64_t v18 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  if (CMVideoFormatDescriptionMatchesImageBuffer(desc, (CVImageBufferRef)a2))
  {
    uint64_t v18 = sBufCreate(a1, 1uLL, 0, 0, &cf);
    if (!v18)
    {
      *((_DWORD *)cf + 7) = 1;
      CFTypeRef v19 = CFRetain(a2);
      BOOL v20 = cf;
      *((void *)cf + 2) = v19;
      v20[25] = a3;
      if (a6)
      {
        v20[27] = 1;
        BOOL v21 = _Block_copy(a6);
        *((void *)cf + 6) = v21;
      }
      else
      {
        *((void *)v20 + 6) = a4;
        *((void *)v20 + 7) = a5;
      }
      CFTypeRef v23 = FigFormatDescriptionRetain(desc);
      uint64_t v18 = 0;
      unint64_t v22 = (char *)cf;
      *((void *)cf + 9) = v23;
      *((void *)v22 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
      uint64_t v24 = *((void *)v22 + 12);
      long long v25 = *(_OWORD *)(a8 + 16);
      long long v26 = *(_OWORD *)(a8 + 32);
      long long v27 = *(_OWORD *)(a8 + 48);
      *(void *)(v24 + 64) = *(void *)(a8 + 64);
      *(_OWORD *)(v24 + 32) = v26;
      *(_OWORD *)(v24 + 48) = v27;
      *(_OWORD *)(v24 + 16) = v25;
      *(_OWORD *)uint64_t v24 = *(_OWORD *)a8;
      uint64_t v28 = *(void *)(a8 + 64);
      *((_OWORD *)v22 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)(a8 + 48);
      *((void *)v22 + 22) = v28;
      uint64_t v29 = *(void *)(a8 + 40);
      *(_OWORD *)(v22 + 184) = *(_OWORD *)(a8 + 24);
      *((void *)v22 + 25) = v29;
      uint64_t v30 = *(void *)(a8 + 16);
      *((_OWORD *)v22 + 13) = *(_OWORD *)a8;
      *((void *)v22 + 28) = v30;
      goto LABEL_17;
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    uint64_t v18 = 4294954553;
  }
LABEL_13:
  if (a9)
  {
    unint64_t v22 = 0;
LABEL_17:
    *a9 = v22;
  }
  return v18;
}

OSStatus CMSampleBufferCreateForImageBufferWithMakeDataReadyHandler(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, Boolean dataReady, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut, CMSampleBufferMakeDataReadyHandler makeDataReadyHandler)
{
  return figSampleBufferCreateForImageBufferCallbackOrHandler((uint64_t)allocator, imageBuffer, dataReady, 0, 0, makeDataReadyHandler, formatDescription, (uint64_t)sampleTiming, sampleBufferOut);
}

OSStatus CMSampleBufferCreateReadyWithImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateForImageBufferCallbackOrHandler((uint64_t)allocator, imageBuffer, 1, 0, 0, 0, formatDescription, (uint64_t)sampleTiming, sampleBufferOut);
}

uint64_t FigSampleBufferCreateForCaptionGroup(const __CFAllocator *a1, const void *a2, long long *a3, uint64_t a4, void *a5)
{
  CFTypeRef cf = 0;
  if (a2 && (*((_DWORD *)a3 + 3) & 0x1D) == 1 && (*(_DWORD *)(a4 + 12) & 0x1D) == 1 && a5)
  {
    uint64_t v10 = sBufCreate((uint64_t)a1, 1uLL, 0, 0, &cf);
    CMTime v11 = (char *)cf;
    if (v10) {
      goto LABEL_10;
    }
    *((_DWORD *)cf + 7) = 2;
    CFTypeRef v12 = CFRetain(a2);
    CFTypeRef v13 = cf;
    *((void *)cf + 2) = v12;
    *((unsigned char *)v13 + 25) = 1;
    *((void *)v13 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
    uint64_t v10 = FigCaptionGroupFormatDescriptionCreate(a1, 1668310898, (CFTypeRef *)v13 + 9);
    CMTime v11 = (char *)cf;
    if (v10)
    {
LABEL_10:
      if (v11) {
        CFRelease(v11);
      }
    }
    else
    {
      uint64_t v14 = *((void *)cf + 12);
      long long v15 = *a3;
      *(void *)(v14 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *((void *)a3 + 2);
      *(_OWORD *)(v14 + 24) = v15;
      *(_OWORD *)(v14 + 48) = *(_OWORD *)&kCMTimeInvalid.value;
      *(void *)(v14 + 64) = 0;
      uint64_t v16 = *(void *)(a4 + 16);
      *(_OWORD *)uint64_t v14 = *(_OWORD *)a4;
      *(void *)(v14 + 16) = v16;
      *((void *)v11 + 22) = 0;
      *((_OWORD *)v11 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v17 = *(void *)(v14 + 40);
      *(_OWORD *)(v11 + 184) = *(_OWORD *)(v14 + 24);
      *((void *)v11 + 25) = v17;
      uint64_t v18 = *(void *)(v14 + 16);
      *((_OWORD *)v11 + 13) = *(_OWORD *)v14;
      *((void *)v11 + 28) = v18;
      *a5 = v11;
    }
    return v10;
  }
  else
  {
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigSampleBufferCreateForTaggedBufferGroup(const __CFAllocator *a1, const void *a2, long long *a3, uint64_t a4, void *a5)
{
  CFTypeRef cf = 0;
  if (a2 && (*((_DWORD *)a3 + 3) & 0x1D) == 1 && a5)
  {
    uint64_t v10 = sBufCreate((uint64_t)a1, 1uLL, 0, 0, &cf);
    CMTime v11 = (char *)cf;
    if (v10) {
      goto LABEL_9;
    }
    *((_DWORD *)cf + 7) = 3;
    CFTypeRef v12 = CFRetain(a2);
    CFTypeRef v13 = cf;
    *((void *)cf + 2) = v12;
    *((unsigned char *)v13 + 25) = 1;
    *((void *)v13 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
    uint64_t v10 = FigTaggedBufferGroupFormatDescriptionCreate(a1, 1952606066, (CFTypeRef *)v13 + 9);
    CMTime v11 = (char *)cf;
    if (v10)
    {
LABEL_9:
      if (v11) {
        CFRelease(v11);
      }
    }
    else
    {
      uint64_t v14 = *((void *)cf + 12);
      long long v15 = *a3;
      *(void *)(v14 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *((void *)a3 + 2);
      *(_OWORD *)(v14 + 24) = v15;
      *(_OWORD *)(v14 + 48) = *(_OWORD *)&kCMTimeInvalid.value;
      *(void *)(v14 + 64) = 0;
      uint64_t v16 = *(void *)(a4 + 16);
      *(_OWORD *)uint64_t v14 = *(_OWORD *)a4;
      *(void *)(v14 + 16) = v16;
      *((void *)v11 + 22) = 0;
      *((_OWORD *)v11 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v17 = *(void *)(v14 + 40);
      *(_OWORD *)(v11 + 184) = *(_OWORD *)(v14 + 24);
      *((void *)v11 + 25) = v17;
      uint64_t v18 = *(void *)(v14 + 16);
      *((_OWORD *)v11 + 13) = *(_OWORD *)v14;
      *((void *)v11 + 28) = v18;
      *a5 = v11;
    }
    return v10;
  }
  else
  {
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMSampleBufferCreateForTaggedBufferGroup(CFAllocatorRef allocator, CMTaggedBufferGroupRef taggedBufferGroup, CMTime *sbufPTS, CMTime *sbufDuration, CMTaggedBufferGroupFormatDescriptionRef formatDescription, CMSampleBufferRef *sBufOut)
{
  CFTypeRef cf = 0;
  if (taggedBufferGroup)
  {
    if ((sbufPTS->flags & 0x1D) == 1 && formatDescription)
    {
      if (CMFormatDescriptionGetMediaType(formatDescription) != 1952606066)
      {
        uint64_t v23 = 4294954555;
        goto LABEL_12;
      }
      if (sBufOut)
      {
        OSStatus v12 = sBufCreate((uint64_t)allocator, 1uLL, 0, 0, &cf);
        if (v12)
        {
          if (cf) {
            CFRelease(cf);
          }
        }
        else
        {
          *((_DWORD *)cf + 7) = 3;
          CFTypeRef v13 = CFRetain(taggedBufferGroup);
          uint64_t v14 = cf;
          *((void *)cf + 2) = v13;
          v14[25] = 1;
          *((void *)v14 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
          CFTypeRef v15 = FigFormatDescriptionRetain(formatDescription);
          uint64_t v16 = (char *)cf;
          *((void *)cf + 9) = v15;
          uint64_t v17 = (long long *)*((void *)v16 + 12);
          CMTimeEpoch epoch = sbufPTS->epoch;
          *(long long *)((char *)v17 + 24) = *(_OWORD *)&sbufPTS->value;
          *((void *)v17 + 5) = epoch;
          *((void *)v17 + 8) = 0;
          _OWORD v17[3] = *(_OWORD *)&kCMTimeInvalid.value;
          CMTimeEpoch v19 = sbufDuration->epoch;
          *uint64_t v17 = *(_OWORD *)&sbufDuration->value;
          *((void *)v17 + 2) = v19;
          *((_OWORD *)v16 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&kCMTimeInvalid.value;
          *((void *)v16 + 22) = 0;
          long long v20 = *(long long *)((char *)v17 + 24);
          *((void *)v16 + 25) = *((void *)v17 + 5);
          *(_OWORD *)(v16 + 184) = v20;
          long long v21 = *v17;
          *((void *)v16 + 28) = *((void *)v17 + 2);
          *((_OWORD *)v16 + 13) = v21;
          *sBufOut = (CMSampleBufferRef)v16;
        }
        return v12;
      }
    }
    uint64_t v23 = 4294954565;
  }
  else
  {
    uint64_t v23 = 4294954565;
  }
LABEL_12:

  return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSampleBufferCreateCopy(CFAllocatorRef allocator, CMSampleBufferRef sbuf, CMSampleBufferRef *sampleBufferOut)
{
  if (sbuf && sampleBufferOut) {
    return CMSampleBufferCreateCopyWithNewTiming(allocator, sbuf, *((void *)sbuf + 11), *((const CMSampleTimingInfo **)sbuf + 12), sampleBufferOut);
  }
  else {
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMSampleBufferCreateCopyWithNewTiming(CFAllocatorRef allocator, CMSampleBufferRef originalSBuf, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMSampleBufferRef *sampleBufferOut)
{
  CFTypeRef cf = 0;
  if (originalSBuf && sampleBufferOut)
  {
    if (!numSampleTimingEntries || sampleTimingArray)
    {
      if ((unint64_t)numSampleTimingEntries < 2 || *((void *)originalSBuf + 10) == numSampleTimingEntries)
      {
        CFTypeRef v13 = (const opaqueCMFormatDescription *)*((void *)originalSBuf + 9);
        if (v13)
        {
          CMMediaType MediaType = CMFormatDescriptionGetMediaType(v13);
          unint64_t v15 = *((void *)originalSBuf + 13);
          if (MediaType == 1936684398) {
            unint64_t v16 = *((void *)originalSBuf + 42);
          }
          else {
            unint64_t v16 = 0;
          }
        }
        else
        {
          unint64_t v16 = 0;
          unint64_t v15 = *((void *)originalSBuf + 13);
        }
        OSStatus result = sBufCreate((uint64_t)allocator, numSampleTimingEntries, v15, v16, &cf);
        OSStatus v12 = (char *)cf;
        if (!result)
        {
          OSStatus result = sBufCopyInternals((unsigned __int8 *)originalSBuf, (uint64_t)cf, 0, 1);
          OSStatus v12 = (char *)cf;
          if (!result)
          {
            uint64_t v18 = *((void *)cf + 11);
            if (v18) {
              memcpy(*((void **)cf + 12), sampleTimingArray, 72 * v18);
            }
            OSStatus v12 = (char *)cf;
            if (*((const CMSampleTimingInfo **)originalSBuf + 12) == sampleTimingArray)
            {
              OSStatus result = 0;
              long long v19 = *(_OWORD *)((char *)originalSBuf + 124);
              *(void *)((char *)cf + 14CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(void *)((char *)originalSBuf + 140);
              *(_OWORD *)(v12 + 124) = v19;
              long long v20 = *((_OWORD *)originalSBuf + 10);
              *((void *)v12 + 22) = *((void *)originalSBuf + 22);
              *((_OWORD *)v12 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v20;
              long long v21 = *(_OWORD *)((char *)originalSBuf + 184);
              *((void *)v12 + 25) = *((void *)originalSBuf + 25);
              *(_OWORD *)(v12 + 184) = v21;
              long long v22 = *((_OWORD *)originalSBuf + 13);
              *((void *)v12 + 28) = *((void *)originalSBuf + 28);
              *((_OWORD *)v12 + 13) = v22;
            }
            else
            {
              sbufUpdateCachedTimestamps((uint64_t)cf, v17);
              OSStatus result = 0;
              OSStatus v12 = (char *)cf;
            }
            goto LABEL_24;
          }
        }
        if (!v12)
        {
LABEL_24:
          *sampleBufferOut = (CMSampleBufferRef)v12;
          return result;
        }
        OSStatus v23 = result;
        CFRelease(v12);
        OSStatus result = v23;
LABEL_7:
        OSStatus v12 = 0;
        goto LABEL_24;
      }
      uint64_t v10 = 4294954558;
    }
    else
    {
      uint64_t v10 = 4294954565;
    }
    OSStatus result = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  OSStatus result = FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  OSStatus v12 = 0;
  if (sampleBufferOut) {
    goto LABEL_24;
  }
  return result;
}

uint64_t FigSampleBufferCreateCopyWithNoData(const __CFAllocator *a1, opaqueCMSampleBuffer *a2, CMSampleBufferRef *a3)
{
  CMSampleBufferRef sampleBufferOut = 0;
  uint64_t v4 = CMSampleBufferCreateCopy(a1, a2, &sampleBufferOut);
  if (v4) {
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  CMSampleBufferRef v6 = sampleBufferOut;
  switch(*((_DWORD *)sampleBufferOut + 7))
  {
    case 0:
      if (*((void *)sampleBufferOut + 2))
      {
        CFRelease(*((CFTypeRef *)sampleBufferOut + 2));
        CMSampleBufferRef v6 = sampleBufferOut;
        *((void *)sampleBufferOut + 2) = 0;
      }
      break;
    case 1:
    case 2:
    case 3:
      if (*((void *)sampleBufferOut + 2))
      {
        CFRelease(*((CFTypeRef *)sampleBufferOut + 2));
        CMSampleBufferRef v6 = sampleBufferOut;
        *((void *)sampleBufferOut + 2) = 0;
      }
      *((_DWORD *)v6 + 7) = 0;
      break;
    default:
      break;
  }
  if (a3)
  {
    uint64_t v5 = 0;
    *a3 = v6;
  }
  else
  {
    CFRelease(v6);
    return 0;
  }
  return v5;
}

uint64_t sBufCopyInternals(unsigned __int8 *cf, uint64_t a2, int a3, int a4)
{
  if (a2)
  {
    int v9 = *((_DWORD *)cf + 7);
    *(_DWORD *)(a2 + 28) = v9;
    switch(v9)
    {
      case 0:
      case 1:
      case 2:
      case 3:
        CFTypeRef v10 = (CFTypeRef)*((void *)cf + 2);
        if (v10) {
          CFTypeRef v10 = CFRetain(v10);
        }
        *(void *)(a2 + 16) = v10;
        break;
      default:
        break;
    }
    int v11 = cf[25];
    *(unsigned char *)(a2 + 25) = v11;
    if (!v11)
    {
      CFRetain(cf);
      *(void *)(a2 + 64) = cf;
    }
    CFTypeRef v12 = FigFormatDescriptionRetain(*((CFTypeRef *)cf + 9));
    uint64_t v13 = *((void *)cf + 10);
    *(void *)(a2 + 72) = v12;
    *(void *)(a2 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v13;
    CFTypeRef v14 = (CFTypeRef)*((void *)cf + 19);
    if (v14) {
      CFTypeRef v14 = CFRetain(v14);
    }
    *(void *)(a2 + 152) = v14;
    if (a3)
    {
      uint64_t v15 = *(void *)(a2 + 88);
      if (v15) {
        memcpy(*(void **)(a2 + 96), *((const void **)cf + 12), 72 * v15);
      }
      long long v16 = *(_OWORD *)(cf + 124);
      *(void *)(a2 + 14CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(void *)(cf + 140);
      *(_OWORD *)(a2 + 124) = v16;
      long long v17 = *((_OWORD *)cf + 10);
      *(void *)(a2 + 176) = *((void *)cf + 22);
      *(_OWORD *)(a2 + 16CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v17;
      long long v18 = *(_OWORD *)(cf + 184);
      *(void *)(a2 + 20CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *((void *)cf + 25);
      *(_OWORD *)(a2 + 184) = v18;
      long long v19 = *((_OWORD *)cf + 13);
      *(void *)(a2 + 224) = *((void *)cf + 28);
      *(_OWORD *)(a2 + 208) = v19;
    }
    if (a4)
    {
      uint64_t v20 = *(void *)(a2 + 104);
      if (v20) {
        memcpy(*(void **)(a2 + 112), *((const void **)cf + 14), 8 * v20);
      }
    }
    long long v21 = (const opaqueCMFormatDescription *)*((void *)cf + 9);
    if (v21)
    {
      if (CMFormatDescriptionGetMediaType(v21) == 1936684398)
      {
        uint64_t v22 = *((void *)cf + 42);
        if (v22)
        {
          if (cf[344])
          {
            memcpy(*(void **)(a2 + 328), *((const void **)cf + 41), 16 * v22);
            *(unsigned char *)(a2 + 344) = 1;
          }
        }
      }
    }
    if (!*((void *)cf + 38))
    {
      long long v25 = 0;
      uint64_t v23 = 0;
      goto LABEL_34;
    }
    uint64_t v23 = *(void *)(a2 + 80);
    uint64_t v24 = (const void **)malloc_type_calloc(v23, 8uLL, 0x2004093837F09uLL);
    if (v24)
    {
      long long v25 = v24;
      if (v23 >= 1)
      {
        CFIndex v26 = 0;
        do
        {
          CFAllocatorRef v27 = CFGetAllocator((CFTypeRef)a2);
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 38), v26);
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v27, 0, ValueAtIndex);
          v25[v26] = MutableCopy;
          if (!MutableCopy) {
            goto LABEL_29;
          }
        }
        while (v23 != ++v26);
      }
      CFAllocatorRef v30 = CFGetAllocator(cf);
      CFArrayRef v31 = CFArrayCreate(v30, v25, v23, MEMORY[0x1E4F1D510]);
      *(void *)(a2 + 304) = v31;
      if (!v31)
      {
LABEL_29:
        FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
LABEL_38:
        if (v23 >= 1)
        {
          __n128 v35 = v25;
          do
          {
            if (*v35) {
              CFRelease(*v35);
            }
            ++v35;
            --v23;
          }
          while (v23);
        }
        free(v25);
        return 0;
      }
LABEL_34:
      if (*((void *)cf + 39))
      {
        CFAllocatorRef v33 = CFGetAllocator((CFTypeRef)a2);
        CFMutableDictionaryRef v34 = CFDictionaryCreateMutableCopy(v33, 0, *((CFDictionaryRef *)cf + 39));
        *(void *)(a2 + 312) = v34;
        if (!v34) {
          FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
        }
      }
      if (!v25) {
        return 0;
      }
      goto LABEL_38;
    }
    uint64_t result = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    if (result)
    {
      *(unsigned char *)(a2 + 25) = 0;
      *(void *)(a2 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigSampleBufferCreateCopyWithNewSizesAndDataBuffer(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, const void *a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  if (!a2 || !a5 || !a6)
  {
    uint64_t v16 = FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    if (!a6) {
      return v16;
    }
    goto LABEL_25;
  }
  if (a3 && a4)
  {
    if (*(_DWORD *)(a2 + 28))
    {
      uint64_t v17 = 4294954553;
    }
    else
    {
      if (a3 == 1 || *(void *)(a2 + 80) == a3)
      {
        CFTypeRef v12 = *(const opaqueCMFormatDescription **)(a2 + 72);
        if (v12)
        {
          CMMediaType MediaType = CMFormatDescriptionGetMediaType(v12);
          unint64_t v14 = *(void *)(a2 + 88);
          if (MediaType == 1936684398) {
            unint64_t v15 = *(void *)(a2 + 336);
          }
          else {
            unint64_t v15 = 0;
          }
        }
        else
        {
          unint64_t v15 = 0;
          unint64_t v14 = *(void *)(a2 + 88);
        }
        uint64_t v18 = sBufCreate(a1, v14, a3, v15, &cf);
        long long v19 = cf;
        if (v18 || (v18 = sBufCopyInternals((unsigned __int8 *)a2, (uint64_t)cf, 1, 0), long long v19 = cf, v18))
        {
          uint64_t v16 = v18;
          if (v19)
          {
            CFRelease(v19);
            CFTypeRef cf = 0;
          }
        }
        else
        {
          uint64_t v20 = *((void *)cf + 13);
          if (v20)
          {
            memcpy(*((void **)cf + 14), a4, 8 * v20);
            long long v19 = cf;
          }
          long long v21 = (const void *)v19[2];
          v19[2] = a5;
          CFRetain(a5);
          if (v21) {
            CFRelease(v21);
          }
          uint64_t v16 = 0;
        }
        goto LABEL_25;
      }
      uint64_t v17 = 4294954558;
    }
  }
  else
  {
    uint64_t v17 = 4294954565;
  }
  uint64_t v16 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
LABEL_25:
  *a6 = cf;
  return v16;
}

const void **FigSampleBufferCreateCopyWithNewFormatDescription(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  if (!a2 || !a3 || !a4)
  {
    unint64_t v14 = (const void **)FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    goto LABEL_47;
  }
  CMTime v8 = *(const opaqueCMFormatDescription **)(a2 + 72);
  if (v8)
  {
    CMMediaType MediaType = CMFormatDescriptionGetMediaType(v8);
    unint64_t v10 = *(void *)(a2 + 88);
    unint64_t v11 = *(void *)(a2 + 104);
    if (MediaType == 1936684398)
    {
      char v12 = 0;
      unint64_t v13 = *(void *)(a2 + 336);
      goto LABEL_11;
    }
    unint64_t v13 = 0;
  }
  else
  {
    unint64_t v13 = 0;
    unint64_t v10 = *(void *)(a2 + 88);
    unint64_t v11 = *(void *)(a2 + 104);
  }
  char v12 = 1;
LABEL_11:
  unint64_t v14 = (const void **)sBufCreate(a1, v10, v11, v13, &cf);
  CFTypeRef v15 = cf;
  if (v14)
  {
LABEL_51:
    if (v14 && v15)
    {
      CFRelease(v15);
      CFTypeRef cf = 0;
    }
    goto LABEL_48;
  }
  int v16 = *(_DWORD *)(a2 + 28);
  *((_DWORD *)cf + 7) = v16;
  switch(v16)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      CFTypeRef v17 = *(CFTypeRef *)(a2 + 16);
      if (v17)
      {
        CFTypeRef v17 = CFRetain(*(CFTypeRef *)(a2 + 16));
        CFTypeRef v15 = cf;
      }
      *((void *)v15 + 2) = v17;
      break;
    default:
      break;
  }
  int v18 = *(unsigned __int8 *)(a2 + 25);
  *((unsigned char *)v15 + 25) = v18;
  if (!v18)
  {
    CFRetain((CFTypeRef)a2);
    *((void *)cf + 8) = a2;
  }
  CFTypeRef v19 = FigFormatDescriptionRetain(a3);
  uint64_t v20 = (char *)cf;
  uint64_t v21 = *(void *)(a2 + 80);
  *((void *)cf + 9) = v19;
  *((void *)v20 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v21;
  CFTypeRef v22 = *(CFTypeRef *)(a2 + 152);
  if (v22)
  {
    CFTypeRef v22 = CFRetain(*(CFTypeRef *)(a2 + 152));
    uint64_t v20 = (char *)cf;
  }
  *((void *)v20 + 19) = v22;
  uint64_t v23 = *((void *)v20 + 11);
  if (v23)
  {
    memcpy(*((void **)v20 + 12), *(const void **)(a2 + 96), 72 * v23);
    uint64_t v20 = (char *)cf;
  }
  uint64_t v24 = *((void *)v20 + 13);
  if (v24)
  {
    memcpy(*((void **)v20 + 14), *(const void **)(a2 + 112), 8 * v24);
    uint64_t v20 = (char *)cf;
  }
  long long v25 = *(_OWORD *)(a2 + 124);
  *(void *)(v20 + 14CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(void *)(a2 + 140);
  *(_OWORD *)(v20 + 124) = v25;
  long long v26 = *(_OWORD *)(a2 + 160);
  *((void *)v20 + 22) = *(void *)(a2 + 176);
  *((_OWORD *)v20 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v26;
  long long v27 = *(_OWORD *)(a2 + 184);
  *((void *)v20 + 25) = *(void *)(a2 + 200);
  *(_OWORD *)(v20 + 184) = v27;
  long long v28 = *(_OWORD *)(a2 + 208);
  *((void *)v20 + 28) = *(void *)(a2 + 224);
  *((_OWORD *)v20 + 13) = v28;
  if ((v12 & 1) == 0)
  {
    uint64_t v29 = *(void *)(a2 + 336);
    if (v29)
    {
      if (*(unsigned char *)(a2 + 344))
      {
        memcpy(*((void **)v20 + 41), *(const void **)(a2 + 328), 16 * v29);
        uint64_t v20 = (char *)cf;
        *((unsigned char *)cf + 344) = 1;
      }
    }
  }
  if (!*(void *)(a2 + 304))
  {
    unint64_t v14 = 0;
    uint64_t v30 = 0;
    goto LABEL_37;
  }
  uint64_t v30 = *((void *)v20 + 10);
  CFArrayRef v31 = (const void **)malloc_type_calloc(v30, 8uLL, 0x2004093837F09uLL);
  if (!v31)
  {
    unint64_t v14 = (const void **)FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    CFTypeRef v15 = cf;
    goto LABEL_51;
  }
  unint64_t v14 = v31;
  if (v30 >= 1)
  {
    CFIndex v32 = 0;
    do
    {
      CFAllocatorRef v33 = CFGetAllocator(cf);
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 304), v32);
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v33, 0, ValueAtIndex);
      v14[v32] = MutableCopy;
      if (!MutableCopy) {
        goto LABEL_35;
      }
    }
    while (v30 != ++v32);
  }
  CFAllocatorRef v36 = CFGetAllocator((CFTypeRef)a2);
  CFArrayRef v37 = CFArrayCreate(v36, v14, v30, MEMORY[0x1E4F1D510]);
  uint64_t v20 = (char *)cf;
  *((void *)cf + 38) = v37;
  if (!v37)
  {
LABEL_35:
    FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
LABEL_41:
    if (v30 >= 1)
    {
      CFDictionaryRef v40 = v14;
      do
      {
        if (*v40) {
          CFRelease(*v40);
        }
        ++v40;
        --v30;
      }
      while (v30);
    }
    free(v14);
    unint64_t v14 = 0;
    goto LABEL_47;
  }
LABEL_37:
  if (*(void *)(a2 + 312))
  {
    CFAllocatorRef v38 = CFGetAllocator(v20);
    CFMutableDictionaryRef v39 = CFDictionaryCreateMutableCopy(v38, 0, *(CFDictionaryRef *)(a2 + 312));
    *((void *)cf + 39) = v39;
    if (!v39) {
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    }
  }
  if (v14) {
    goto LABEL_41;
  }
LABEL_47:
  if (a4) {
LABEL_48:
  }
    *a4 = cf;
  return v14;
}

OSStatus CMSampleBufferCopySampleBufferForRange(CFAllocatorRef allocator, CMSampleBufferRef sbuf, CFRange sampleRange, CMSampleBufferRef *sampleBufferOut)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  int v108 = 0;
  CMTimeValue value = 0;
  CMTimeScale timescale = 0;
  CMTimeValue v109 = 0;
  CMTimeScale v110 = 0;
  CMAttachmentMode attachmentModeOut = 0;
  CMItemCount timingArrayEntriesNeededOut = 0;
  if (!sbuf || !sampleBufferOut)
  {
    uint64_t v13 = 4294954565;
LABEL_18:
    OSStatus v15 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
    int v16 = 0;
    CFTypeRef v17 = 0;
LABEL_19:
    uint64_t v18 = 0;
    goto LABEL_20;
  }
  CFIndex length = sampleRange.length;
  CFIndex location = sampleRange.location;
  int v9 = (const opaqueCMFormatDescription *)*((void *)sbuf + 9);
  if (!v9)
  {
    char v12 = (uint64_t **)((char *)sbuf + 112);
    if (*((void *)sbuf + 14))
    {
      BOOL v11 = 0;
      goto LABEL_12;
    }
    goto LABEL_17;
  }
  CMMediaType MediaType = CMFormatDescriptionGetMediaType(v9);
  BOOL v11 = MediaType == 1936684398;
  char v12 = (uint64_t **)((char *)sbuf + 112);
  if (!*((void *)sbuf + 14))
  {
    if (MediaType == 1936684398 && *((void *)sbuf + 41) && *((unsigned char *)sbuf + 344))
    {
      BOOL v11 = 1;
      goto LABEL_12;
    }
LABEL_17:
    uint64_t v13 = 4294954561;
    goto LABEL_18;
  }
LABEL_12:
  if (location < 0 || (CFIndex v14 = *((void *)sbuf + 10), location >= v14) || length < 0 || location + length > v14)
  {
    uint64_t v13 = 4294954562;
    goto LABEL_18;
  }
  if (v11)
  {
    BOOL v21 = *((void *)sbuf + 42) != 0;
    BOOL v22 = *((unsigned char *)sbuf + 344) == 0;
  }
  else
  {
    BOOL v21 = 0;
    BOOL v22 = 1;
  }
  BOOL v95 = v22;
  if (length)
  {
    if (*((uint64_t *)sbuf + 11) <= 1) {
      unint64_t v23 = *((void *)sbuf + 11);
    }
    else {
      unint64_t v23 = length;
    }
    if (*((uint64_t *)sbuf + 13) <= 1) {
      unint64_t v24 = *((void *)sbuf + 13);
    }
    else {
      unint64_t v24 = length;
    }
  }
  else
  {
    unint64_t v24 = 0;
    unint64_t v23 = 0;
  }
  if (CMGetAttachment(sbuf, @"TrimDurationAtStart", 0)
    || CMGetAttachment(sbuf, @"TrimDurationAtEnd", 0)
    || CMGetAttachment(sbuf, @"SpeedMultiplier", 0)
    || CMGetAttachment(sbuf, @"Reverse", 0)
    || (*((_DWORD *)sbuf + 34) & 0x1D) == 1)
  {
    OSStatus OutputSampleTimingInfoArray = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, 0, 0, &timingArrayEntriesNeededOut);
    if (OutputSampleTimingInfoArray)
    {
      OSStatus v15 = OutputSampleTimingInfoArray;
      uint64_t v18 = 0;
      CFTypeRef v17 = 0;
LABEL_52:
      int v16 = 0;
LABEL_21:
      if (v108) {
        CFRelease(v108);
      }
      int v108 = 0;
LABEL_24:
      free(v17);
      if (!v16) {
        goto LABEL_31;
      }
      goto LABEL_25;
    }
    CFAllocatorRef structureAllocator = allocator;
    CFTypeRef v17 = (CMSampleTimingInfo *)malloc_type_malloc(72 * timingArrayEntriesNeededOut, 0x1000040FF89C88EuLL);
    if (!v17)
    {
      OSStatus v15 = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
      int v16 = 0;
      goto LABEL_19;
    }
    OSStatus v26 = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, timingArrayEntriesNeededOut, v17, 0);
    if (v26)
    {
LABEL_55:
      OSStatus v15 = v26;
      uint64_t v18 = 0;
      goto LABEL_52;
    }
    char v93 = 0;
  }
  else
  {
    CFAllocatorRef structureAllocator = allocator;
    CFTypeRef v17 = 0;
    char v93 = 1;
  }
  if (v21) {
    unint64_t v27 = length;
  }
  else {
    unint64_t v27 = 0;
  }
  OSStatus v26 = sBufCreate((uint64_t)structureAllocator, v23, v24, v27, &v108);
  if (v26) {
    goto LABEL_55;
  }
  long long v28 = (CMBlockBufferRef *)v108;
  *((_DWORD *)v108 + 7) = *((_DWORD *)sbuf + 7);
  switch(*((_DWORD *)sbuf + 7))
  {
    case 0:
      uint64_t v31 = *((void *)sbuf + 13);
      if (v31 < 1) {
        goto LABEL_63;
      }
      if (v31 == 1)
      {
        uint64_t v32 = **v12;
        size_t v30 = v32 * location;
        size_t v33 = v32 * length;
      }
      else
      {
        size_t v30 = 0;
        if (location)
        {
          CFMutableDictionaryRef v34 = *v12;
          CFIndex v35 = location;
          do
          {
            uint64_t v36 = *v34++;
            v30 += v36;
            --v35;
          }
          while (v35);
        }
        if (length < 1) {
          break;
        }
        size_t v33 = 0;
        CFArrayRef v37 = &(*v12)[location];
        CFIndex v38 = length;
        do
        {
          uint64_t v39 = *v37++;
          v33 += v39;
          --v38;
        }
        while (v38);
      }
      CFDictionaryRef v40 = (OpaqueCMBlockBuffer *)*((void *)sbuf + 2);
      if (v40) {
        BOOL v41 = v33 == 0;
      }
      else {
        BOOL v41 = 1;
      }
      if (v41) {
        break;
      }
      if (length >= *((void *)sbuf + 10))
      {
        CFTypeRef v29 = CFRetain(*((CFTypeRef *)sbuf + 2));
        long long v28 = (CMBlockBufferRef *)v108;
        goto LABEL_66;
      }
      OSStatus v42 = CMBlockBufferCreateWithBufferReference(structureAllocator, v40, v30, v33, 0, v28 + 2);
      if (!v42)
      {
        long long v28 = (CMBlockBufferRef *)v108;
        break;
      }
      uint64_t v18 = 0;
      int v16 = 0;
      OSStatus v15 = v42;
      goto LABEL_21;
    case 1:
    case 2:
    case 3:
LABEL_63:
      CFTypeRef v29 = (CFTypeRef)*((void *)sbuf + 2);
      if (v29)
      {
        CFTypeRef v29 = CFRetain(v29);
        long long v28 = (CMBlockBufferRef *)v108;
      }
      size_t v30 = 0;
LABEL_66:
      v28[2] = (CMBlockBufferRef)v29;
      break;
    default:
      size_t v30 = 0;
      break;
  }
  int v43 = *((unsigned __int8 *)sbuf + 25);
  *((unsigned char *)v28 + 25) = v43;
  if (!v43)
  {
    CFRetain(sbuf);
    *((void *)v108 + 8) = sbuf;
  }
  CFTypeRef v44 = FigFormatDescriptionRetain(*((CFTypeRef *)sbuf + 9));
  uint64_t v46 = (uint64_t)v108;
  *((void *)v108 + 9) = v44;
  *(void *)(v46 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = length;
  CFTypeRef v47 = (CFTypeRef)*((void *)sbuf + 19);
  if (v47)
  {
    CFTypeRef v47 = CFRetain(*((CFTypeRef *)sbuf + 19));
    uint64_t v46 = (uint64_t)v108;
  }
  *(void *)(v46 + 152) = v47;
  uint64_t v48 = *(void *)(v46 + 88);
  if (v48)
  {
    size_t v49 = 72 * v48;
    CFIndex v50 = *((void *)sbuf + 11) == 1 ? 0 : location;
    memcpy(*(void **)(v46 + 96), (const void *)(*((void *)sbuf + 12) + 72 * v50), v49);
    uint64_t v46 = (uint64_t)v108;
    if (*((void *)sbuf + 11) == 1)
    {
      int v51 = (CMTime *)*((void *)v108 + 12);
      CFAllocatorRef v52 = (long long *)*((void *)sbuf + 12);
      long long v53 = *v52;
      time.CMTimeEpoch epoch = *((void *)v52 + 2);
      *(_OWORD *)&time.CMTimeValue value = v53;
      CMTimeMultiply(&rhs, &time, location);
      CMTime lhs = *(CMTime *)((unsigned char *)v52 + 1);
      CMTimeAdd(&time, &lhs, &rhs);
      __n128 v45 = *(__n128 *)&time.value;
      v51[1] = time;
      CFTypeID v54 = (long long *)*((void *)sbuf + 12);
      uint64_t v46 = (uint64_t)v108;
      if (*((unsigned char *)v54 + 60))
      {
        int64_t v55 = (CMTime *)*((void *)v108 + 12);
        long long v56 = *v54;
        time.CMTimeEpoch epoch = *((void *)v54 + 2);
        *(_OWORD *)&time.CMTimeValue value = v56;
        CMTimeMultiply(&v102, &time, location);
        CMTime lhs = *(CMTime *)((unsigned char *)v54 + 2);
        CMTimeAdd(&time, &lhs, &v102);
        __n128 v45 = *(__n128 *)&time.value;
        v55[2] = time;
        uint64_t v46 = (uint64_t)v108;
      }
    }
  }
  uint64_t v57 = *(void *)(v46 + 104);
  if (v57)
  {
    size_t v58 = 8 * v57;
    if (*((void *)sbuf + 13) == 1) {
      CFIndex v59 = 0;
    }
    else {
      CFIndex v59 = location;
    }
    memcpy(*(void **)(v46 + 112), (const void *)(*((void *)sbuf + 14) + 8 * v59), v58);
    uint64_t v46 = (uint64_t)v108;
  }
  sbufUpdateCachedTimestamps(v46, v45);
  if ((v93 & 1) == 0)
  {
    if (timingArrayEntriesNeededOut == *((void *)sbuf + 10))
    {
      memset(&time, 0, sizeof(time));
      if (length >= 1)
      {
        uint64_t p_presentationTimeStamp = (uint64_t)&v17[location].presentationTimeStamp;
        CFIndex v61 = location;
        do
        {
          long long v62 = *(_OWORD *)p_presentationTimeStamp;
          lhs.CMTimeEpoch epoch = *(void *)(p_presentationTimeStamp + 16);
          *(_OWORD *)&lhs.CMTimeValue value = v62;
          CMTime time2 = time;
          if (CMTimeCompare(&lhs, &time2) < 0)
          {
            long long v63 = *(_OWORD *)p_presentationTimeStamp;
            time.CMTimeEpoch epoch = *(void *)(p_presentationTimeStamp + 16);
            *(_OWORD *)&time.CMTimeValue value = v63;
          }
          ++v61;
          p_presentationTimeStamp += 72;
        }
        while (v61 < location + length);
      }
      *(CMTime *)(v108 + 124) = time;
    }
    else
    {
      long long v64 = v108;
      long long v65 = *(_OWORD *)&v17->duration.value;
      time.CMTimeEpoch epoch = v17->duration.epoch;
      *(_OWORD *)&time.CMTimeValue value = v65;
      CMTimeMultiply(&v100, &time, location);
      CMTime lhs = v17->presentationTimeStamp;
      CMTimeAdd(&time, &lhs, &v100);
      *(CMTime *)(v64 + 124) = time;
    }
  }
  if (!v95)
  {
    long long v66 = v108;
    if (*((void *)sbuf + 42))
    {
      memcpy(*((void **)v108 + 41), (const void *)(*((void *)sbuf + 41) + 16 * location), 16 * length);
      long long v66 = v108;
      if (*((uint64_t *)v108 + 13) >= 1 && length >= 1)
      {
        uint64_t v67 = 0;
        do
        {
          *(void *)(*((void *)v66 + 41) + v67) -= v30;
          v67 += 16;
          --length;
        }
        while (length);
      }
    }
    v66[344] = 1;
  }
  if (!*((void *)sbuf + 38))
  {
    int v16 = 0;
    uint64_t v18 = 0;
LABEL_126:
    if (*((void *)sbuf + 39)
      && (CFAllocatorRef v76 = CFGetAllocator(v108),
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v76, 0, *((CFDictionaryRef *)sbuf + 39)),
          (*((void *)v108 + 39) = MutableCopy) == 0))
    {
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      CFDictionaryRef v78 = (const __CFDictionary *)CMGetAttachment(sbuf, @"TrimDurationAtStart", &attachmentModeOut);
      CMTimeMakeFromDictionary(&time, v78);
      CMTimeValue value = time.value;
      CMTimeFlags flags = time.flags;
      CMTimeScale timescale = time.timescale;
      CMTimeEpoch epoch = time.epoch;
      *(_OWORD *)&v99.CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
      v99.CMTimeEpoch epoch = 0;
      if (time.flags)
      {
        memset(&time, 0, sizeof(time));
        CMTime lhs = *(CMTime *)(v108 + 184);
        CMTime time2 = *(CMTime *)((char *)sbuf + 184);
        CMTimeSubtract(&time, &lhs, &time2);
        CMRemoveAttachment(v108, @"TrimDurationAtStart");
        if (time.flags)
        {
          memset(&lhs, 0, sizeof(lhs));
          time2.CMTimeValue value = value;
          time2.CMTimeScale timescale = timescale;
          time2.CMTimeFlags flags = flags;
          time2.CMTimeEpoch epoch = epoch;
          CMTime v98 = time;
          CMTimeSubtract(&lhs, &time2, &v98);
          *(_OWORD *)&time2.CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
          time2.CMTimeEpoch epoch = 0;
          CMTime v98 = lhs;
          if (CMTimeCompare(&time2, &v98) < 0)
          {
            CMTime time2 = lhs;
            CFDictionaryRef v81 = CMTimeCopyAsDictionary(&time2, structureAllocator);
            if (!v81) {
              goto LABEL_144;
            }
            CFDictionaryRef v82 = v81;
            CMSetAttachment(v108, @"TrimDurationAtStart", v81, attachmentModeOut);
            CFRelease(v82);
            CMTime v99 = lhs;
          }
        }
      }
      CFDictionaryRef v83 = (const __CFDictionary *)CMGetAttachment(sbuf, @"TrimDurationAtEnd", &attachmentModeOut);
      CMTimeMakeFromDictionary(&time, v83);
      CMTimeValue v109 = time.value;
      CMTimeFlags v84 = time.flags;
      CMTimeScale v110 = time.timescale;
      if (time.flags)
      {
        CMTimeEpoch v85 = time.epoch;
        memset(&time, 0, sizeof(time));
        CMTime lhs = *(CMTime *)(v108 + 184);
        CMTime time2 = *(CMTime *)(v108 + 208);
        CMTimeAdd(&v97, &lhs, &time2);
        CMTime lhs = *(CMTime *)((char *)sbuf + 184);
        CMTime time2 = *(CMTime *)((char *)sbuf + 208);
        CMTimeAdd(&v96, &lhs, &time2);
        CMTimeSubtract(&time, &v97, &v96);
        CMRemoveAttachment(v108, @"TrimDurationAtEnd");
        if (time.flags)
        {
          memset(&lhs, 0, sizeof(lhs));
          time2.CMTimeValue value = v109;
          time2.CMTimeScale timescale = v110;
          time2.CMTimeFlags flags = v84;
          time2.CMTimeEpoch epoch = v85;
          CMTime v98 = time;
          CMTimeAdd(&lhs, &time2, &v98);
          *(_OWORD *)&time2.CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
          time2.CMTimeEpoch epoch = 0;
          CMTime v98 = lhs;
          if (CMTimeCompare(&time2, &v98) < 0)
          {
            CMTime time2 = lhs;
            CFDictionaryRef v86 = CMTimeCopyAsDictionary(&time2, structureAllocator);
            if (!v86) {
              goto LABEL_144;
            }
            CFDictionaryRef v87 = v86;
            CMSetAttachment(v108, @"TrimDurationAtEnd", v86, attachmentModeOut);
            CFRelease(v87);
            CMTime time2 = v99;
            CMTime v98 = lhs;
            CMTimeAdd(&v99, &time2, &v98);
          }
        }
      }
      CMTime time = v99;
      CMTime lhs = *(CMTime *)(v108 + 208);
      if ((CMTimeCompare(&time, &lhs) & 0x80000000) == 0)
      {
        CMRemoveAttachment(v108, @"TrimDurationAtStart");
        CMRemoveAttachment(v108, @"TrimDurationAtEnd");
        CMTime time = *(CMTime *)(v108 + 208);
        CFDictionaryRef v88 = CMTimeCopyAsDictionary(&time, structureAllocator);
        if (!v88) {
          goto LABEL_144;
        }
        CFDictionaryRef v89 = v88;
        CMSetAttachment(v108, @"TrimDurationAtStart", v88, attachmentModeOut);
        CFRelease(v89);
      }
      CFNumberRef v90 = (const __CFNumber *)CMGetAttachment(sbuf, @"SampleReferenceByteOffset", &attachmentModeOut);
      if (v90)
      {
        time.CMTimeValue value = 0;
        CFNumberGetValue(v90, kCFNumberSInt64Type, &time);
        time.value += v30;
        CFNumberRef SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], time.value);
        if (SInt64)
        {
          CFNumberRef v92 = SInt64;
          CMSetAttachment(v108, @"SampleReferenceByteOffset", SInt64, attachmentModeOut);
          CFRelease(v92);
          OSStatus v15 = 0;
          goto LABEL_20;
        }
LABEL_144:
        OSStatus v15 = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
LABEL_20:
        if (!v15) {
          goto LABEL_24;
        }
        goto LABEL_21;
      }
    }
    OSStatus v15 = 0;
    goto LABEL_24;
  }
  uint64_t v18 = *((void *)v108 + 10);
  long long v68 = (const void **)malloc_type_calloc(v18, 8uLL, 0x2004093837F09uLL);
  int v16 = v68;
  if (!v68) {
    goto LABEL_144;
  }
  if (v18 >= 1)
  {
    long long v69 = (CFMutableDictionaryRef *)v68;
    uint64_t v70 = v18;
    do
    {
      CFAllocatorRef v71 = CFGetAllocator(v108);
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)sbuf + 38), location);
      CFMutableDictionaryRef v73 = CFDictionaryCreateMutableCopy(v71, 0, ValueAtIndex);
      *long long v69 = v73;
      if (!v73) {
        goto LABEL_124;
      }
      ++v69;
      ++location;
    }
    while (--v70);
  }
  CFAllocatorRef v74 = CFGetAllocator(sbuf);
  CFArrayRef v75 = CFArrayCreate(v74, v16, v18, MEMORY[0x1E4F1D510]);
  *((void *)v108 + 38) = v75;
  if (v75) {
    goto LABEL_126;
  }
LABEL_124:
  FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
  free(v17);
  OSStatus v15 = 0;
LABEL_25:
  if (v18 >= 1)
  {
    CFTypeRef v19 = v16;
    do
    {
      if (*v19) {
        CFRelease(*v19);
      }
      ++v19;
      --v18;
    }
    while (v18);
  }
  free(v16);
LABEL_31:
  if (sampleBufferOut) {
    *CMSampleBufferRef sampleBufferOut = (CMSampleBufferRef)v108;
  }
  return v15;
}

OSStatus CMSampleBufferGetOutputSampleTimingInfoArray(CMSampleBufferRef sbuf, CMItemCount timingArrayEntries, CMSampleTimingInfo *timingArrayOut, CMItemCount *timingArrayEntriesNeededOut)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  CMTimeValue value = 0;
  CMTimeScale timescale = 0;
  CMTimeValue v48 = 0;
  CMTimeScale v49 = 0;
  if (*((unsigned char *)sbuf + 24))
  {
    return FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v7 = *((void *)sbuf + 11);
  if (v7 && *((void *)sbuf + 12))
  {
    CMTimeFlags v10 = 0;
    CMTimeEpoch epoch = 0;
    CFDictionaryRef v12 = (const __CFDictionary *)CMGetAttachment(sbuf, @"TrimDurationAtStart", 0);
    CMTimeFlags flags = 0;
    CMTimeEpoch v39 = 0;
    if (v12)
    {
      CMTimeMakeFromDictionary(&time1, v12);
      CMTimeValue value = time1.value;
      CMTimeFlags flags = time1.flags;
      CMTimeScale timescale = time1.timescale;
      CMTimeEpoch epoch = time1.epoch;
    }
    CFDictionaryRef v14 = (const __CFDictionary *)CMGetAttachment(sbuf, @"TrimDurationAtEnd", 0);
    if (v14)
    {
      CMTimeMakeFromDictionary(&time1, v14);
      CMTimeValue v48 = time1.value;
      CMTimeFlags v10 = time1.flags;
      CMTimeScale v49 = time1.timescale;
      CMTimeEpoch v39 = time1.epoch;
    }
    if (*((void *)sbuf + 10) > v7 && ((v10 & 0x1D) == 1 || (flags & 0x1D) == 1)) {
      uint64_t v7 = *((void *)sbuf + 10);
    }
    if (timingArrayEntriesNeededOut) {
      *CMItemCount timingArrayEntriesNeededOut = v7;
    }
    if (!timingArrayOut) {
      return 0;
    }
    if (v7 > timingArrayEntries) {
      return FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
    }
    unint64_t v16 = *((void *)sbuf + 10);
    if (v16 <= 1)
    {
      CMSampleBufferGetOutputDuration(&time1, sbuf);
      timingArrayOut->duration = time1;
      CMSampleBufferGetOutputPresentationTimeStamp(&time1, sbuf);
      timingArrayOut->presentationTimeStamp = time1;
      CMSampleBufferGetOutputDecodeTimeStamp(&time1, sbuf);
      OSStatus result = 0;
      timingArrayOut->decodeTimeStamp = time1;
      return result;
    }
    CFTypeRef v17 = &timingArrayOut[v7];
    uint64_t v38 = v7;
    if (*((void *)sbuf + 11) == v16)
    {
      memcpy(timingArrayOut, *((const void **)sbuf + 12), 72 * v16);
    }
    else
    {
      *(_OWORD *)&time1.CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
      time1.CMTimeEpoch epoch = 0;
      if (v7 >= 1)
      {
        uint64_t v18 = timingArrayOut;
        do
        {
          CFTypeRef v19 = (long long *)*((void *)sbuf + 12);
          long long v20 = *v19;
          v18->duration.CMTimeEpoch epoch = *((void *)v19 + 2);
          *(_OWORD *)&v18->duration.CMTimeValue value = v20;
          CMTime lhs = *(CMTime *)(*((void *)sbuf + 12) + 24);
          CMTime rhs = time1;
          CMTimeAdd(&time2, &lhs, &rhs);
          v18->presentationTimeStamp = time2;
          *(_OWORD *)&v18->decodeTimeStamp.CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
          v18->decodeTimeStamp.CMTimeEpoch epoch = 0;
          BOOL v21 = (long long *)*((void *)sbuf + 12);
          CMTime time2 = time1;
          long long v22 = *v21;
          lhs.CMTimeEpoch epoch = *((void *)v21 + 2);
          *(_OWORD *)&lhs.CMTimeValue value = v22;
          CMTimeAdd(&time1, &time2, &lhs);
          ++v18;
        }
        while (v18 < v17);
      }
    }
    if ((flags & 0x1D) == 1)
    {
      rhs.CMTimeValue value = value;
      rhs.CMTimeScale timescale = timescale;
      if (v7 >= 1)
      {
        unint64_t v23 = timingArrayOut;
        while (1)
        {
          CMTime time1 = v23->duration;
          time2.CMTimeValue value = rhs.value;
          time2.CMTimeScale timescale = rhs.timescale;
          time2.CMTimeFlags flags = flags;
          time2.CMTimeEpoch epoch = epoch;
          if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
            break;
          }
          CMTime time2 = v23->presentationTimeStamp;
          lhs.CMTimeValue value = rhs.value;
          lhs.CMTimeScale timescale = rhs.timescale;
          lhs.CMTimeFlags flags = flags;
          lhs.CMTimeEpoch epoch = epoch;
          CMTimeAdd(&time1, &time2, &lhs);
          v23->presentationTimeStamp = time1;
          CMTime time2 = v23->decodeTimeStamp;
          lhs.CMTimeValue value = rhs.value;
          lhs.CMTimeScale timescale = rhs.timescale;
          lhs.CMTimeFlags flags = flags;
          lhs.CMTimeEpoch epoch = epoch;
          CMTimeAdd(&time1, &time2, &lhs);
          v23->decodeTimeStamp = time1;
          time2.CMTimeValue value = rhs.value;
          time2.CMTimeScale timescale = rhs.timescale;
          time2.CMTimeFlags flags = flags;
          time2.CMTimeEpoch epoch = epoch;
          CMTime lhs = v23->duration;
          CMTimeSubtract(&time1, &time2, &lhs);
          rhs.CMTimeValue value = time1.value;
          CMTimeFlags flags = time1.flags;
          rhs.CMTimeScale timescale = time1.timescale;
          CMTimeEpoch epoch = time1.epoch;
          *(_OWORD *)&v23->duration.CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
          v23->duration.CMTimeEpoch epoch = 0;
          if (++v23 >= v17) {
            goto LABEL_39;
          }
        }
        CMTime time2 = v23->presentationTimeStamp;
        lhs.CMTimeValue value = rhs.value;
        lhs.CMTimeScale timescale = rhs.timescale;
        lhs.CMTimeFlags flags = flags;
        lhs.CMTimeEpoch epoch = epoch;
        CMTimeAdd(&time1, &time2, &lhs);
        v23->presentationTimeStamp = time1;
        CMTime time2 = v23->decodeTimeStamp;
        lhs.CMTimeValue value = rhs.value;
        lhs.CMTimeScale timescale = rhs.timescale;
        lhs.CMTimeFlags flags = flags;
        lhs.CMTimeEpoch epoch = epoch;
        CMTimeAdd(&time1, &time2, &lhs);
        v23->decodeTimeStamp = time1;
        CMTime time2 = v23->duration;
        lhs.CMTimeValue value = rhs.value;
        lhs.CMTimeScale timescale = rhs.timescale;
        lhs.CMTimeFlags flags = flags;
        lhs.CMTimeEpoch epoch = epoch;
        CMTimeSubtract(&time1, &time2, &lhs);
        v23->duration = time1;
      }
    }
LABEL_39:
    if ((v10 & 0x1D) == 1)
    {
      rhs.CMTimeValue value = v48;
      rhs.CMTimeScale timescale = v49;
      p_duration = &v17[-1].duration;
      CMTimeEpoch v25 = v39;
      if (&v17[-1] >= timingArrayOut)
      {
        while (1)
        {
          CMTime time1 = *p_duration;
          time2.CMTimeValue value = rhs.value;
          time2.CMTimeScale timescale = rhs.timescale;
          time2.CMTimeFlags flags = v10;
          time2.CMTimeEpoch epoch = v25;
          if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
            break;
          }
          time2.CMTimeValue value = rhs.value;
          time2.CMTimeScale timescale = rhs.timescale;
          time2.CMTimeFlags flags = v10;
          time2.CMTimeEpoch epoch = v25;
          CMTime lhs = *p_duration;
          CMTimeSubtract(&time1, &time2, &lhs);
          rhs.CMTimeValue value = time1.value;
          CMTimeFlags v10 = time1.flags;
          rhs.CMTimeScale timescale = time1.timescale;
          CMTimeEpoch v25 = time1.epoch;
          *(_OWORD *)&p_duration->CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
          p_duration->CMTimeEpoch epoch = 0;
          p_duration -= 3;
          if (p_duration < (CMTime *)timingArrayOut) {
            goto LABEL_45;
          }
        }
        CMTime time2 = *p_duration;
        lhs.CMTimeValue value = rhs.value;
        lhs.CMTimeScale timescale = rhs.timescale;
        lhs.CMTimeFlags flags = v10;
        lhs.CMTimeEpoch epoch = v25;
        CMTimeSubtract(&time1, &time2, &lhs);
        CMTime *p_duration = time1;
      }
    }
LABEL_45:
    CFNumberRef v26 = (const __CFNumber *)CMGetAttachment(sbuf, @"SpeedMultiplier", 0);
    if (v26)
    {
      CFNumberRef v27 = v26;
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v27))
      {
        CMTime time1 = timingArrayOut->presentationTimeStamp;
        rhs.CMTimeValue value = 0x3FF0000000000000;
        CFNumberGetValue(v27, kCFNumberDoubleType, &rhs);
        if (v38 >= 1)
        {
          CFTypeRef v29 = timingArrayOut;
          double v30 = 1.0 / *(double *)&rhs.value;
          do
          {
            CMTime lhs = v29->duration;
            CMTimeMultiplyByFloat64(&time2, &lhs, v30);
            v29->duration = time2;
            CMTime time2 = v29->presentationTimeStamp;
            CMTime lhs = time1;
            CMTimeSubtract(&time, &time2, &lhs);
            CMTimeMultiplyByFloat64(&v43, &time, v30);
            CMTime lhs = time1;
            CMTimeAdd(&time2, &v43, &lhs);
            v29->presentationTimeStamp = time2;
            CMTime time2 = v29->decodeTimeStamp;
            CMTime lhs = time1;
            CMTimeSubtract(&v40, &time2, &lhs);
            CMTimeMultiplyByFloat64(&v41, &v40, v30);
            CMTime lhs = time1;
            CMTimeAdd(&time2, &v41, &lhs);
            v29->decodeTimeStamp = time2;
            ++v29;
          }
          while (v29 < v17);
        }
      }
    }
    CFBooleanRef v31 = (const __CFBoolean *)CMGetAttachment(sbuf, @"Reverse", 0);
    if (v31 && (CFBooleanRef v32 = v31, v33 = CFBooleanGetTypeID(), v33 == CFGetTypeID(v32)))
    {
      int v34 = CFBooleanGetValue(v32);
      if (v34 && v38 >= 1)
      {
        CFIndex v35 = timingArrayOut;
        do
        {
          CMTime time2 = v35->presentationTimeStamp;
          CMTime lhs = v35->duration;
          CMTimeAdd(&time1, &time2, &lhs);
          v35->presentationTimeStamp = time1;
          ++v35;
        }
        while (v35 < v17);
      }
      if ((*((_DWORD *)sbuf + 34) & 0x1D) != 1) {
        return 0;
      }
      uint64_t v36 = (CMTime *)((char *)sbuf + 124);
      memset(&time1, 0, sizeof(time1));
      if (v34)
      {
        *(_OWORD *)&time2.CMTimeValue value = *(_OWORD *)&v36->value;
        time2.CMTimeEpoch epoch = *(void *)((char *)sbuf + 140);
        *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&v17[-1].presentationTimeStamp.value;
        CMTimeEpoch v37 = v17[-1].presentationTimeStamp.epoch;
        goto LABEL_62;
      }
    }
    else
    {
      if ((*((_DWORD *)sbuf + 34) & 0x1D) != 1) {
        return 0;
      }
      uint64_t v36 = (CMTime *)((char *)sbuf + 124);
      memset(&time1, 0, sizeof(time1));
    }
    CMTime time2 = *v36;
    *(_OWORD *)&lhs.CMTimeValue value = *(_OWORD *)&timingArrayOut->presentationTimeStamp.value;
    CMTimeEpoch v37 = timingArrayOut->presentationTimeStamp.epoch;
LABEL_62:
    lhs.CMTimeEpoch epoch = v37;
    CMTimeSubtract(&time1, &time2, &lhs);
    if (v38 >= 1)
    {
      do
      {
        CMTime lhs = timingArrayOut->presentationTimeStamp;
        CMTime rhs = time1;
        CMTimeAdd(&time2, &lhs, &rhs);
        timingArrayOut->presentationTimeStamp = time2;
        CMTime lhs = timingArrayOut->decodeTimeStamp;
        CMTime rhs = time1;
        CMTimeAdd(&time2, &lhs, &rhs);
        timingArrayOut->decodeTimeStamp = time2;
        ++timingArrayOut;
      }
      while (timingArrayOut < v17);
    }
    return 0;
  }
  if (timingArrayEntriesNeededOut) {
    *CMItemCount timingArrayEntriesNeededOut = 0;
  }
  return -12736;
}

OSStatus CMSampleBufferSetDataBuffer(CMSampleBufferRef sbuf, CMBlockBufferRef dataBuffer)
{
  if (sbuf && dataBuffer)
  {
    if (*((unsigned char *)sbuf + 24))
    {
      uint64_t v2 = 4294954552;
    }
    else
    {
      if (!*((_DWORD *)sbuf + 7) && !*((void *)sbuf + 2))
      {
        *((void *)sbuf + 2) = CFRetain(dataBuffer);
        return 0;
      }
      uint64_t v2 = 4294954564;
    }
  }
  else
  {
    uint64_t v2 = 4294954565;
  }

  return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
}

CMBlockBufferRef CMSampleBufferGetDataBuffer(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!*((_DWORD *)sbuf + 7)) {
    return (CMBlockBufferRef)*((void *)sbuf + 2);
  }
  return 0;
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*((_DWORD *)sbuf + 7) == 1) {
    return (CVImageBufferRef)*((void *)sbuf + 2);
  }
  return 0;
}

uint64_t FigSampleBufferGetCaptionGroup(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = 4294954565;
LABEL_7:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = 4294954552;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 28) == 2) {
    return *(void *)(a1 + 16);
  }
  return 0;
}

uint64_t FigSampleBufferGetTaggedBufferGroup(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v2 = 4294954565;
LABEL_7:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = 4294954552;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 28) == 3) {
    return *(void *)(a1 + 16);
  }
  return 0;
}

CMTaggedBufferGroupRef CMSampleBufferGetTaggedBufferGroup(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
LABEL_7:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v2 = 4294954552;
    goto LABEL_7;
  }
  if (*((_DWORD *)sbuf + 7) == 3) {
    return (CMTaggedBufferGroupRef)*((void *)sbuf + 2);
  }
  return 0;
}

OSStatus CMSampleBufferSetDataReady(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    goto LABEL_7;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v2 = 4294954552;
LABEL_7:
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((unsigned char *)sbuf + 26))
  {
    uint64_t v2 = *((unsigned int *)sbuf + 12);
    goto LABEL_7;
  }
  int v4 = *((unsigned __int8 *)sbuf + 25);
  *((unsigned char *)sbuf + 25) = 1;
  figSampleBufferCheckDataSize((size_t)sbuf);
  if (!v4)
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, @"FigSampleBufferDataBecameReady", sbuf, 0);
  }
  return 0;
}

uint64_t CMSampleBufferSetDataReadyWithNewSize(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a1)
  {
    if (*(void *)(a1 + 104) || *(void *)(a1 + 112))
    {
      uint64_t v8 = 4294954556;
      goto LABEL_11;
    }
    if (a2 > 0 && a3)
    {
      CMSampleBufferRef v6 = malloc_type_malloc(8 * a2, 0x1DDE389AuLL);
      *(void *)(a1 + 112) = v6;
      *(unsigned char *)(a1 + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
      memcpy(v6, a3, 8 * a2);
      *(void *)(a1 + 104) = a2;
      return CMSampleBufferSetDataReady((CMSampleBufferRef)a1);
    }
  }
  uint64_t v8 = 4294954565;
LABEL_11:

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

Boolean CMSampleBufferDataIsReady(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v2 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
LABEL_6:
    LOBYTE(IsReady) = 0;
    return IsReady;
  }
  if (*((unsigned char *)sbuf + 26)) {
    goto LABEL_6;
  }
  uint64_t v5 = (opaqueCMSampleBuffer *)*((void *)sbuf + 8);
  if (v5)
  {
    int IsReady = CMSampleBufferDataIsReady(v5);
    if (IsReady)
    {
      CMSampleBufferSetDataReady(sbuf);
      CMSampleBufferRef v6 = (const void *)*((void *)sbuf + 8);
      if (v6) {
        CFRelease(v6);
      }
      *((void *)sbuf + 8) = 0;
    }
  }
  else
  {
    LOBYTE(IsReady) = *((unsigned char *)sbuf + 25);
  }
  return IsReady;
}

OSStatus CMSampleBufferSetDataFailed(CMSampleBufferRef sbuf, OSStatus status)
{
  if (!sbuf)
  {
    uint64_t v3 = 4294954565;
    goto LABEL_9;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v3 = 4294954552;
LABEL_9:
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((unsigned char *)sbuf + 25))
  {
    uint64_t v3 = 4294954564;
    goto LABEL_9;
  }
  if (*((unsigned char *)sbuf + 26))
  {
    uint64_t v3 = 4294950546;
    goto LABEL_9;
  }
  if (*((unsigned char *)sbuf + 27))
  {
    _Block_release(*((const void **)sbuf + 6));
    *((void *)sbuf + 6) = 0;
    *((unsigned char *)sbuf + 27) = 0;
  }
  *((unsigned char *)sbuf + 26) = 1;
  if (status) {
    OSStatus v6 = status;
  }
  else {
    OSStatus v6 = -16750;
  }
  *((_DWORD *)sbuf + 12) = v6;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32(Mutable, @"OSStatus", v6);
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, @"CMSampleBufferDataFailed", sbuf, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return 0;
}

Boolean CMSampleBufferHasDataFailed(CMSampleBufferRef sbuf, OSStatus *statusOut)
{
  if (!sbuf)
  {
    uint64_t v3 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v3 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
LABEL_6:
    LOBYTE(HasDataFailed) = 0;
    return HasDataFailed;
  }
  if (*((unsigned char *)sbuf + 25)) {
    goto LABEL_6;
  }
  uint64_t v7 = (opaqueCMSampleBuffer *)*((void *)sbuf + 8);
  if (v7)
  {
    OSStatus statusOuta = 0;
    int HasDataFailed = CMSampleBufferHasDataFailed(v7, &statusOuta);
    if (HasDataFailed)
    {
      CMSampleBufferSetDataFailed(sbuf, statusOuta);
      uint64_t v8 = (const void *)*((void *)sbuf + 8);
      if (v8)
      {
        CFRelease(v8);
        *((void *)sbuf + 8) = 0;
      }
    }
  }
  else
  {
    int HasDataFailed = *((unsigned __int8 *)sbuf + 26);
  }
  if (statusOut && HasDataFailed) {
    *statusOut = *((_DWORD *)sbuf + 12);
  }
  return HasDataFailed;
}

OSStatus CMSampleBufferMakeDataReady(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    goto LABEL_5;
  }
  if (!*((unsigned char *)sbuf + 24))
  {
    int v4 = (opaqueCMSampleBuffer *)*((void *)sbuf + 8);
    if (v4)
    {
      LODWORD(v5) = CMSampleBufferMakeDataReady(v4);
      if (!v5)
      {
        OSStatus v6 = (const void *)*((void *)sbuf + 8);
        if (v6) {
          CFRelease(v6);
        }
        LODWORD(v5) = 0;
        *((void *)sbuf + 8) = 0;
        *((unsigned char *)sbuf + 25) = 1;
      }
      return v5;
    }
    if (*((unsigned char *)sbuf + 25))
    {
      LODWORD(v5) = 0;
      return v5;
    }
    if (*((unsigned char *)sbuf + 26))
    {
      LODWORD(v5) = *((_DWORD *)sbuf + 12);
      return v5;
    }
    uint64_t v7 = (uint64_t (**)(void, void))*((void *)sbuf + 6);
    if (*((unsigned char *)sbuf + 27))
    {
      if (v7)
      {
        *((void *)sbuf + 6) = 0;
        *((unsigned char *)sbuf + 27) = 0;
        uint64_t v5 = ((uint64_t (**)(void, CMSampleBufferRef))v7)[2](v7, sbuf);
        _Block_release(v7);
        goto LABEL_23;
      }
    }
    else if (v7)
    {
      uint64_t v5 = ((uint64_t (*)(CMSampleBufferRef, void))v7)(sbuf, *((void *)sbuf + 7));
LABEL_23:
      if (v5)
      {
        FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        *((unsigned char *)sbuf + 25) = 1;
        figSampleBufferCheckDataSize((size_t)sbuf);
      }
      return v5;
    }
    uint64_t v2 = 4294954563;
    goto LABEL_5;
  }
  uint64_t v2 = 4294954552;
LABEL_5:

  return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSampleBufferTrackDataReadiness(CMSampleBufferRef sbuf, CMSampleBufferRef sampleBufferToTrack)
{
  if (sbuf)
  {
    if (!*((unsigned char *)sbuf + 24) && (!sampleBufferToTrack || !*((unsigned char *)sampleBufferToTrack + 24)))
    {
      if (*((unsigned char *)sbuf + 25))
      {
        uint64_t v3 = 4294954564;
        goto LABEL_5;
      }
      if (*((unsigned char *)sbuf + 26))
      {
        uint64_t v3 = *((unsigned int *)sbuf + 12);
        goto LABEL_5;
      }
      if (sbuf == sampleBufferToTrack) {
        uint64_t v5 = 0;
      }
      else {
        uint64_t v5 = sampleBufferToTrack;
      }
      OSStatus v6 = (const void *)*((void *)sbuf + 8);
      if (v6) {
        CFRelease(v6);
      }
      *((void *)sbuf + 8) = 0;
      if (v5)
      {
        if (CMSampleBufferDataIsReady(v5))
        {
          *((unsigned char *)sbuf + 25) = 1;
          figSampleBufferCheckDataSize((size_t)sbuf);
          return 0;
        }
        CFRetain(v5);
      }
      *((void *)sbuf + 8) = v5;
      return 0;
    }
    uint64_t v3 = 4294954552;
  }
  else
  {
    uint64_t v3 = 4294954565;
  }
LABEL_5:

  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSampleBufferInvalidate(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v2 = 4294954552;
LABEL_5:
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  int v4 = (void (*)(CMSampleBufferRef, void))*((void *)sbuf + 4);
  if (v4)
  {
    if (v4 == (void (*)(CMSampleBufferRef, void))1) {
      (*(void (**)(void))(*((void *)sbuf + 5) + 16))();
    }
    else {
      v4(sbuf, *((void *)sbuf + 5));
    }
  }
  *((unsigned char *)sbuf + 24) = 1;
  return 0;
}

Boolean CMSampleBufferIsValid(CMSampleBufferRef sbuf)
{
  if (sbuf) {
    LOBYTE(sbuf) = *((unsigned char *)sbuf + 24) == 0;
  }
  return sbuf;
}

OSStatus CMSampleBufferSetInvalidateCallback(CMSampleBufferRef sbuf, CMSampleBufferInvalidateCallback invalidateCallback, uint64_t invalidateRefCon)
{
  if (!sbuf) {
    goto LABEL_6;
  }
  if (!*((unsigned char *)sbuf + 24))
  {
    uint64_t v7 = *((void *)sbuf + 4);
    if (invalidateCallback)
    {
      if (v7)
      {
LABEL_6:
        uint64_t v4 = 4294954565;
        goto LABEL_7;
      }
    }
    else if (v7 == 1)
    {
      _Block_release(*((const void **)sbuf + 5));
    }
    *((void *)sbuf + 4) = invalidateCallback;
    *((void *)sbuf + 5) = invalidateRefCon;
    return 0;
  }
  uint64_t v4 = 4294954552;
LABEL_7:

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSampleBufferSetInvalidateHandler(CMSampleBufferRef sbuf, CMSampleBufferInvalidateHandler invalidateHandler)
{
  if (!sbuf) {
    goto LABEL_6;
  }
  if (!*((unsigned char *)sbuf + 24))
  {
    uint64_t v5 = *((void *)sbuf + 4);
    if (invalidateHandler)
    {
      if (v5)
      {
LABEL_6:
        uint64_t v3 = 4294954565;
        goto LABEL_7;
      }
      uint64_t v7 = 1;
    }
    else
    {
      if (v5 == 1) {
        _Block_release(*((const void **)sbuf + 5));
      }
      uint64_t v7 = 0;
    }
    uint64_t v8 = _Block_copy(invalidateHandler);
    *((void *)sbuf + 4) = v7;
    *((void *)sbuf + 5) = v8;
    return 0;
  }
  uint64_t v3 = 4294954552;
LABEL_7:

  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

CMItemCount CMSampleBufferGetNumSamples(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return *((void *)sbuf + 10);
}

CMTime *__cdecl CMSampleBufferGetDuration(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (LOBYTE(sbuf[1].value))
  {
    uint64_t v2 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (!sbuf[4].value) {
    return CMTimeMake(retstr, 0, 1);
  }
  *retstr = *(CMTime *)((char *)sbuf + 208);
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (LOBYTE(sbuf[1].value))
  {
    uint64_t v2 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (sbuf[4].value) {
    *retstr = *(CMTime *)((char *)sbuf + 184);
  }
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetDecodeTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (LOBYTE(sbuf[1].value))
  {
    uint64_t v2 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (sbuf[4].value) {
    *retstr = *(CMTime *)((char *)sbuf + 160);
  }
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetOutputDuration(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (!sbuf)
  {
    uint64_t v4 = 4294954565;
    goto LABEL_5;
  }
  uint64_t v3 = sbuf;
  if (LOBYTE(sbuf[1].value))
  {
    uint64_t v4 = 4294954552;
LABEL_5:
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  p_CMTimeEpoch epoch = &sbuf[11].epoch;
  if ((HIDWORD(sbuf[12].value) & 0x1D) == 1)
  {
    *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)p_epoch;
    retstr->CMTimeEpoch epoch = *(void *)&sbuf[12].timescale;
  }
  else
  {
    sbuf = CMSampleBufferGetDuration(retstr, (CMSampleBufferRef)sbuf);
    if ((retstr->flags & 0x1D) == 1)
    {
      CFDictionaryRef v6 = (const __CFDictionary *)CMGetAttachment(v3, @"TrimDurationAtStart", 0);
      CFDictionaryRef v7 = (const __CFDictionary *)CMGetAttachment(v3, @"TrimDurationAtEnd", 0);
      sbuf = (CMTime *)CMGetAttachment(v3, @"SpeedMultiplier", 0);
      uint64_t v8 = sbuf;
      if (v6)
      {
        memset(&v13, 0, sizeof(v13));
        CMTimeMakeFromDictionary(&v13, v6);
        CMTime lhs = *retstr;
        CMTime v10 = v13;
        sbuf = CMTimeSubtract(&time, &lhs, &v10);
        *retstr = time;
      }
      if (v7)
      {
        memset(&v13, 0, sizeof(v13));
        CMTimeMakeFromDictionary(&v13, v7);
        CMTime lhs = *retstr;
        CMTime v10 = v13;
        sbuf = CMTimeSubtract(&time, &lhs, &v10);
        *retstr = time;
      }
      if (v8)
      {
        CFTypeID TypeID = (CMTime *)CFNumberGetTypeID();
        sbuf = (CMTime *)CFGetTypeID(v8);
        if (TypeID == sbuf)
        {
          lhs.CMTimeValue value = 0x3FF0000000000000;
          CFNumberGetValue((CFNumberRef)v8, kCFNumberDoubleType, &lhs);
          CMTime time = *retstr;
          sbuf = CMTimeMultiplyByFloat64(&v13, &time, 1.0 / *(double *)&lhs.value);
          *retstr = v13;
        }
      }
    }
    *(_OWORD *)p_CMTimeEpoch epoch = *(_OWORD *)&retstr->value;
    p_epoch[2] = retstr->epoch;
  }
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetOutputPresentationTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (!sbuf)
  {
    uint64_t v4 = 4294954565;
    goto LABEL_5;
  }
  uint64_t v3 = sbuf;
  if (!LOBYTE(sbuf[1].value))
  {
    if ((sbuf[5].epoch & 0x1D) == 1)
    {
      *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)((char *)&sbuf[5].value + 4);
      CMTimeEpoch epoch = *(CMTimeEpoch *)((char *)&sbuf[5].epoch + 4);
    }
    else
    {
      if ((HIDWORD(sbuf[11].value) & 0x1D) == 1)
      {
        *retstr = *(CMTime *)((char *)sbuf + 256);
        return sbuf;
      }
      CFTypeRef v6 = CMGetAttachment(sbuf, @"Reverse", 0);
      CMSampleBufferGetPresentationTimeStamp(retstr, (CMSampleBufferRef)v3);
      if (!v6 || (CFTypeID TypeID = CFBooleanGetTypeID(), TypeID != CFGetTypeID(v6)) || !CFBooleanGetValue((CFBooleanRef)v6))
      {
        sbuf = (CMTime *)CMGetAttachment(v3, @"TrimDurationAtStart", 0);
        if (sbuf)
        {
          memset(&v13, 0, sizeof(v13));
          CMTimeMakeFromDictionary(&v13, (CFDictionaryRef)sbuf);
          CMTime lhs = *retstr;
          CMTime rhs = v13;
          sbuf = CMTimeAdd(retstr, &lhs, &rhs);
        }
        goto LABEL_11;
      }
      memset(&v13, 0, sizeof(v13));
      CMSampleBufferGetDuration(&v13, (CMSampleBufferRef)v3);
      CFDictionaryRef v8 = (const __CFDictionary *)CMGetAttachment(v3, @"TrimDurationAtEnd", 0);
      CMTime lhs = *retstr;
      CMTime rhs = v13;
      sbuf = CMTimeAdd(retstr, &lhs, &rhs);
      if (!v8)
      {
LABEL_11:
        *(_OWORD *)&v3[10].CMTimeEpoch epoch = *(_OWORD *)&retstr->value;
        *(void *)&v3[11].CMTimeScale timescale = retstr->epoch;
        return sbuf;
      }
      memset(&lhs, 0, sizeof(lhs));
      CMTimeMakeFromDictionary(&lhs, v8);
      CMTime v10 = *retstr;
      CMTime v9 = lhs;
      sbuf = CMTimeSubtract(&rhs, &v10, &v9);
      *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&rhs.value;
      CMTimeEpoch epoch = rhs.epoch;
    }
    retstr->CMTimeEpoch epoch = epoch;
    goto LABEL_11;
  }
  uint64_t v4 = 4294954552;
LABEL_5:

  return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSampleBufferSetOutputPresentationTimeStamp(CMSampleBufferRef sbuf, CMTime *outputPresentationTimeStamp)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v2 = 4294954552;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  long long v4 = *(_OWORD *)&outputPresentationTimeStamp->value;
  *(void *)((char *)sbuf + 14CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = outputPresentationTimeStamp->epoch;
  *(_OWORD *)((char *)sbuf + 124) = v4;
  return 0;
}

CMTime *__cdecl CMSampleBufferGetOutputDecodeTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  memset(&v15, 0, sizeof(v15));
  if (!sbuf)
  {
    uint64_t v4 = 4294954565;
    goto LABEL_5;
  }
  uint64_t v3 = sbuf;
  if (LOBYTE(sbuf[1].value))
  {
    uint64_t v4 = 4294954552;
LABEL_5:
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  p_CMTimeEpoch epoch = &sbuf[9].epoch;
  if ((HIDWORD(sbuf[10].value) & 0x1D) == 1)
  {
    *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)p_epoch;
    retstr->CMTimeEpoch epoch = *(void *)&sbuf[10].timescale;
  }
  else
  {
    CMSampleBufferGetOutputPresentationTimeStamp(retstr, (CMSampleBufferRef)sbuf);
    CMSampleBufferGetDecodeTimeStamp(&lhs, (CMSampleBufferRef)v3);
    CMSampleBufferGetPresentationTimeStamp(&rhs, (CMSampleBufferRef)v3);
    CMTimeSubtract(&v15, &lhs, &rhs);
    CFNumberRef v6 = (const __CFNumber *)CMGetAttachment(v3, @"SpeedMultiplier", 0);
    if (v6)
    {
      CFNumberRef v7 = v6;
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v7))
      {
        v10.CMTimeValue value = 0x3FF0000000000000;
        CFNumberGetValue(v7, kCFNumberDoubleType, &v10);
        CMTime time = v15;
        CMTimeMultiplyByFloat64(&v12, &time, 1.0 / *(double *)&v10.value);
        CMTime v15 = v12;
      }
    }
    CMTime time = *retstr;
    CMTime v10 = v15;
    sbuf = CMTimeAdd(&v12, &time, &v10);
    *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&v12.value;
    CMTimeEpoch epoch = v12.epoch;
    retstr->CMTimeEpoch epoch = v12.epoch;
    *(_OWORD *)p_CMTimeEpoch epoch = *(_OWORD *)&retstr->value;
    p_epoch[2] = epoch;
  }
  return sbuf;
}

OSStatus CMSampleBufferGetSampleTimingInfoArray(CMSampleBufferRef sbuf, CMItemCount numSampleTimingEntries, CMSampleTimingInfo *timingArrayOut, CMItemCount *timingArrayEntriesNeededOut)
{
  if (!sbuf)
  {
    uint64_t v5 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v5 = 4294954552;
LABEL_5:
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  CMItemCount v8 = *((void *)sbuf + 11);
  if (v8 && *((void *)sbuf + 12))
  {
    if (timingArrayOut && v8 > numSampleTimingEntries)
    {
      OSStatus result = FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
      if (!timingArrayEntriesNeededOut) {
        return result;
      }
LABEL_20:
      *CMItemCount timingArrayEntriesNeededOut = *((void *)sbuf + 11);
      return result;
    }
    if (timingArrayOut) {
      memcpy(timingArrayOut, *((const void **)sbuf + 12), 72 * v8);
    }
    OSStatus result = 0;
    if (timingArrayEntriesNeededOut) {
      goto LABEL_20;
    }
  }
  else
  {
    if (timingArrayEntriesNeededOut) {
      *CMItemCount timingArrayEntriesNeededOut = 0;
    }
    return -12736;
  }
  return result;
}

OSStatus CMSampleBufferGetSampleTimingInfo(CMSampleBufferRef sbuf, CMItemIndex sampleIndex, CMSampleTimingInfo *timingInfoOut)
{
  if (!sbuf || !timingInfoOut)
  {
    uint64_t v4 = 4294954565;
    goto LABEL_6;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v4 = 4294954552;
LABEL_6:
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v6 = *((void *)sbuf + 11);
  if (!v6)
  {
    uint64_t v4 = 4294954560;
    goto LABEL_6;
  }
  if (sampleIndex < 0 || (CMItemIndex v7 = *((void *)sbuf + 10), v7 <= sampleIndex))
  {
    uint64_t v4 = 4294954562;
    goto LABEL_6;
  }
  if (v6 == v7)
  {
    CMItemIndex v8 = *((void *)sbuf + 12) + 72 * sampleIndex;
    *(_OWORD *)&timingInfoOut->duration.CMTimeValue value = *(_OWORD *)v8;
    long long v9 = *(_OWORD *)(v8 + 16);
    long long v10 = *(_OWORD *)(v8 + 32);
    long long v11 = *(_OWORD *)(v8 + 48);
    timingInfoOut->decodeTimeStamp.CMTimeEpoch epoch = *(void *)(v8 + 64);
    *(_OWORD *)&timingInfoOut->presentationTimeStamp.CMTimeScale timescale = v10;
    *(_OWORD *)&timingInfoOut->decodeTimeStamp.CMTimeValue value = v11;
    *(_OWORD *)&timingInfoOut->duration.CMTimeEpoch epoch = v9;
  }
  else
  {
    CMTime v12 = (long long *)*((void *)sbuf + 12);
    CMTimeEpoch v13 = *((void *)v12 + 2);
    long long v17 = *v12;
    *(void *)&v18[0] = v13;
    *(_OWORD *)&v15.CMTimeValue value = v17;
    v15.CMTimeEpoch epoch = v13;
    CMTimeMultiply(&rhs, &v15, sampleIndex);
    CMTime v15 = *(CMTime *)((unsigned char *)v12 + 1);
    CMTimeAdd((CMTime *)((char *)v18 + 8), &v15, &rhs);
    *(_OWORD *)&timingInfoOut->presentationTimeStamp.CMTimeScale timescale = v18[1];
    *(_OWORD *)&timingInfoOut->decodeTimeStamp.CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
    timingInfoOut->decodeTimeStamp.CMTimeEpoch epoch = 0;
    long long v14 = v18[0];
    *(_OWORD *)&timingInfoOut->duration.CMTimeValue value = v17;
    *(_OWORD *)&timingInfoOut->duration.CMTimeEpoch epoch = v14;
  }
  return 0;
}

OSStatus CMSampleBufferGetSampleSizeArray(CMSampleBufferRef sbuf, CMItemCount sizeArrayEntries, size_t *sizeArrayOut, CMItemCount *sizeArrayEntriesNeededOut)
{
  if (!sbuf)
  {
    uint64_t v5 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v5 = 4294954552;
LABEL_5:
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  CMItemCount v8 = *((void *)sbuf + 13);
  if (v8 && *((void *)sbuf + 14))
  {
    if (sizeArrayOut && v8 > sizeArrayEntries)
    {
      OSStatus result = FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
      if (!sizeArrayEntriesNeededOut) {
        return result;
      }
LABEL_20:
      *sizeArrayEntriesNeededOut = *((void *)sbuf + 13);
      return result;
    }
    if (sizeArrayOut) {
      memcpy(sizeArrayOut, *((const void **)sbuf + 14), 8 * v8);
    }
    OSStatus result = 0;
    if (sizeArrayEntriesNeededOut) {
      goto LABEL_20;
    }
  }
  else
  {
    if (sizeArrayEntriesNeededOut) {
      *sizeArrayEntriesNeededOut = 0;
    }
    return -12735;
  }
  return result;
}

size_t CMSampleBufferGetSampleSize(CMSampleBufferRef sbuf, CMItemIndex sampleIndex)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    goto LABEL_12;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v2 = 4294954552;
LABEL_12:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v3 = *((void *)sbuf + 13);
  if (!v3)
  {
    uint64_t v2 = 4294954561;
    goto LABEL_12;
  }
  if (sampleIndex < 0 || *((void *)sbuf + 10) <= sampleIndex)
  {
    uint64_t v2 = 4294954562;
    goto LABEL_12;
  }
  uint64_t v4 = (size_t *)*((void *)sbuf + 14);
  if (v3 == 1) {
    return *v4;
  }
  else {
    return v4[sampleIndex];
  }
}

size_t CMSampleBufferGetTotalSampleSize(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v2 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v2 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v4 = *((void *)sbuf + 13);
  if (v4)
  {
    if (v4 == 1) {
      return **((void **)sbuf + 14) * *((void *)sbuf + 10);
    }
    if (v4 < 1) {
      return 0;
    }
    size_t result = 0;
    CMItemCount v8 = (uint64_t *)*((void *)sbuf + 14);
    do
    {
      uint64_t v9 = *v8++;
      result += v9;
      --v4;
    }
    while (v4);
  }
  else
  {
    size_t result = *((void *)sbuf + 9);
    if (result)
    {
      if (CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)result) != 1936684398) {
        return 0;
      }
      if (!*((unsigned char *)sbuf + 344)) {
        return 0;
      }
      uint64_t v5 = *((void *)sbuf + 42);
      if (!v5) {
        return 0;
      }
      size_t result = 0;
      uint64_t v6 = (unsigned int *)(*((void *)sbuf + 41) + 12);
      do
      {
        unsigned int v7 = *v6;
        v6 += 4;
        result += v7;
        --v5;
      }
      while (v5);
    }
  }
  return result;
}

CMFormatDescriptionRef CMSampleBufferGetFormatDescription(CMSampleBufferRef sbuf)
{
  if (!sbuf)
  {
    uint64_t v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return (CMFormatDescriptionRef)*((void *)sbuf + 9);
}

CFArrayRef CMSampleBufferGetSampleAttachmentsArray(CMSampleBufferRef sbuf, Boolean createIfNecessary)
{
  if (!sbuf)
  {
    uint64_t v3 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v3 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFArrayRef v4 = (const __CFArray *)*((void *)sbuf + 38);
  if (createIfNecessary && !v4)
  {
    CFIndex v6 = *((void *)sbuf + 10);
    if (!v6) {
      return 0;
    }
    unsigned int v7 = (const void **)malloc_type_calloc(*((void *)sbuf + 10), 8uLL, 0x2004093837F09uLL);
    CMItemCount v8 = v7;
    if (v6 >= 1)
    {
      uint64_t v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D048];
      long long v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      long long v11 = (CFMutableDictionaryRef *)v7;
      CFIndex v12 = v6;
      while (1)
      {
        CFAllocatorRef v13 = CFGetAllocator(sbuf);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v13, 0, v9, v10);
        CFMutableDictionaryRef *v11 = Mutable;
        if (!Mutable) {
          break;
        }
        ++v11;
        if (!--v12) {
          goto LABEL_15;
        }
      }
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
      CFArrayRef v4 = 0;
      goto LABEL_20;
    }
LABEL_15:
    CFAllocatorRef v15 = CFGetAllocator(sbuf);
    CFArrayRef v4 = CFArrayCreate(v15, v8, v6, MEMORY[0x1E4F1D510]);
    *((void *)sbuf + 38) = v4;
    if (!v4) {
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    }
    if (v8)
    {
LABEL_20:
      if (v6 >= 1)
      {
        unint64_t v16 = v8;
        do
        {
          if (*v16) {
            CFRelease(*v16);
          }
          ++v16;
          --v6;
        }
        while (v6);
      }
      free(v8);
    }
  }
  return v4;
}

OSStatus CMSampleBufferCallForEachSample(CMSampleBufferRef sbuf, OSStatus (__cdecl *callback)(CMSampleBufferRef, CMItemCount, void *), void *refcon)
{
  CMTimeValue v48 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  CMItemCount timingArrayEntriesNeededOut = 0;
  if (!sbuf)
  {
    uint64_t v4 = 4294954565;
    goto LABEL_5;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v4 = 4294954552;
LABEL_5:
    OSStatus OutputSampleTimingInfoArray = FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
LABEL_6:
    OSStatus v6 = OutputSampleTimingInfoArray;
    unsigned int v7 = 0;
    goto LABEL_7;
  }
  CMItemCount NumSamples = CMSampleBufferGetNumSamples(sbuf);
  CMFormatDescriptionRef FormatDescription = CMSampleBufferGetFormatDescription(sbuf);
  CMBlockBufferRef DataBuffer = CMSampleBufferGetDataBuffer(sbuf);
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 0);
  if (NumSamples == 1)
  {
    OSStatus OutputSampleTimingInfoArray = ((uint64_t (*)(CMSampleBufferRef, void, void *))callback)(sbuf, 0, refcon);
    goto LABEL_6;
  }
  if (NumSamples < 2)
  {
    unsigned int v7 = 0;
LABEL_45:
    OSStatus v6 = 0;
    goto LABEL_7;
  }
  CFArrayRef v15 = SampleAttachmentsArray;
  if (CMGetAttachment(sbuf, @"TrimDurationAtStart", 0)
    || CMGetAttachment(sbuf, @"TrimDurationAtEnd", 0)
    || CMGetAttachment(sbuf, @"SpeedMultiplier", 0)
    || CMGetAttachment(sbuf, @"Reverse", 0)
    || (*((_DWORD *)sbuf + 34) & 0x1D) == 1)
  {
    OSStatus OutputSampleTimingInfoArray = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, 0, 0, &timingArrayEntriesNeededOut);
    if (OutputSampleTimingInfoArray) {
      goto LABEL_6;
    }
    unsigned int v7 = (CMSampleTimingInfo *)malloc_type_malloc(72 * timingArrayEntriesNeededOut, 0x1000040FF89C88EuLL);
    if (v7)
    {
      OSStatus SampleTimingInfo = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, timingArrayEntriesNeededOut, v7, 0);
      if (!SampleTimingInfo)
      {
        CFArrayRef theArray = v15;
        desc = FormatDescription;
        int v38 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v37 = 4294954566;
LABEL_47:
      OSStatus SampleTimingInfo = FigSignalErrorAt(v37, 0, 0, 0, 0, 0, 0);
    }
LABEL_48:
    OSStatus v6 = SampleTimingInfo;
    goto LABEL_7;
  }
  CFArrayRef theArray = v15;
  desc = FormatDescription;
  unsigned int v7 = 0;
  int v38 = 1;
LABEL_26:
  size_t v17 = 0;
  CMItemIndex v18 = 0;
  uint64_t p_presentationTimeStamp = &v7->presentationTimeStamp;
  while (1)
  {
    memset(&timingInfoOut, 0, sizeof(timingInfoOut));
    size_t SampleSize = CMSampleBufferGetSampleSize(sbuf, v18);
    size_t v46 = SampleSize;
    if (!SampleSize)
    {
      uint64_t v37 = 4294954557;
      goto LABEL_47;
    }
    size_t v21 = SampleSize;
    CFAllocatorRef v22 = CFGetAllocator(DataBuffer);
    size_t v41 = v17;
    OSStatus SampleTimingInfo = CMBlockBufferCreateWithBufferReference(v22, DataBuffer, v17, v21, 0, &blockBufferOut);
    if (SampleTimingInfo) {
      goto LABEL_48;
    }
    OSStatus SampleTimingInfo = CMSampleBufferGetSampleTimingInfo(sbuf, v18, &timingInfoOut);
    if (SampleTimingInfo) {
      goto LABEL_48;
    }
    CFAllocatorRef v23 = CFGetAllocator(sbuf);
    OSStatus SampleTimingInfo = figSampleBufferCreateCallbackOrHandler((uint64_t)v23, blockBufferOut, 0, 0, 0, 0, desc, 1uLL, 1uLL, &timingInfoOut, 1uLL, &v46, &v48);
    if (SampleTimingInfo) {
      goto LABEL_48;
    }
    CFRelease(blockBufferOut);
    CMBlockBufferRef blockBufferOut = 0;
    CFTypeRef v24 = (CFTypeRef)*((void *)sbuf + 19);
    if (v24) {
      CFTypeRef v24 = CFRetain(v24);
    }
    CMTimeEpoch v25 = (opaqueCMSampleBuffer *)v48;
    *((void *)v48 + 19) = v24;
    OSStatus SampleTimingInfo = CMSampleBufferTrackDataReadiness(v25, sbuf);
    if (SampleTimingInfo) {
      goto LABEL_48;
    }
    if (theArray)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v18);
      CFArrayRef v27 = CMSampleBufferGetSampleAttachmentsArray((CMSampleBufferRef)v48, 1u);
      long long v28 = (void *)CFArrayGetValueAtIndex(v27, 0);
      CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)sBufDictionarySetValue, v28);
    }
    if (v38)
    {
      CFTypeRef v29 = v48;
    }
    else
    {
      CFTypeRef v29 = v48;
      double v30 = v48 + 280;
      if (timingArrayEntriesNeededOut == NumSamples)
      {
        long long v31 = *(_OWORD *)&p_presentationTimeStamp[-1].value;
        *((void *)v48 + 37) = p_presentationTimeStamp[-1].epoch;
        *double v30 = v31;
        long long v32 = *(_OWORD *)&p_presentationTimeStamp->value;
        *(void *)(v29 + 14CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = p_presentationTimeStamp->epoch;
        *(_OWORD *)(v29 + 124) = v32;
        long long v33 = *(_OWORD *)&p_presentationTimeStamp[1].value;
        *((void *)v29 + 31) = p_presentationTimeStamp[1].epoch;
        *(_OWORD *)(v29 + 232) = v33;
      }
      else
      {
        long long v34 = *(_OWORD *)&v7->duration.value;
        *((void *)v48 + 37) = v7->duration.epoch;
        *double v30 = v34;
        long long v35 = *(_OWORD *)&v7->duration.value;
        time.CMTimeEpoch epoch = v7->duration.epoch;
        *(_OWORD *)&time.CMTimeValue value = v35;
        CMTimeMultiply(&rhs, &time, v18);
        CMTime lhs = v7->presentationTimeStamp;
        CMTimeAdd(&time, &lhs, &rhs);
        *(CMTime *)(v29 + 124) = time;
        CFTypeRef v29 = v48;
        *(_OWORD *)(v48 + 232) = *(_OWORD *)&kCMTimeInvalid.value;
        *((void *)v29 + 31) = 0;
      }
    }
    uint64_t v36 = ((uint64_t (*)(char *, CMItemIndex, void *))callback)(v29, v18, refcon);
    if (v36) {
      break;
    }
    CFRelease(v48);
    CMTimeValue v48 = 0;
    size_t v17 = v21 + v41;
    ++v18;
    p_presentationTimeStamp += 3;
    if (NumSamples == v18) {
      goto LABEL_45;
    }
  }
  OSStatus v6 = v36;
  FigSignalErrorAt(v36, 0, 0, 0, 0, 0, 0);
LABEL_7:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  if (v48) {
    CFRelease(v48);
  }
  if (v7) {
    free(v7);
  }
  return v6;
}

void sBufDictionarySetValue(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

OSStatus CMSampleBufferCallBlockForEachSample(CMSampleBufferRef sbuf, void *handler)
{
  return CMSampleBufferCallForEachSample(sbuf, (OSStatus (__cdecl *)(CMSampleBufferRef, CMItemCount, void *))figSampleBufferCallForEachSampleBlockFunctionCallback, handler);
}

uint64_t figSampleBufferCallForEachSampleBlockFunctionCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

OSStatus CMSampleBufferSetDataBufferFromAudioBufferList(CMSampleBufferRef sbuf, CFAllocatorRef blockBufferStructureAllocator, CFAllocatorRef blockBufferBlockAllocator, uint32_t flags, const AudioBufferList *bufferList)
{
  CMBlockBufferRef blockBufferOut = 0;
  size_t sizeOut = 0;
  dataPointerOut = 0;
  if (!sbuf || !bufferList) {
    goto LABEL_47;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v7 = 4294954552;
LABEL_48:
    OSStatus v31 = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    goto LABEL_49;
  }
  if (*((_DWORD *)sbuf + 7) || *((void *)sbuf + 2))
  {
    uint64_t v7 = 4294954564;
    goto LABEL_48;
  }
  char v8 = flags;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*((CMAudioFormatDescriptionRef *)sbuf + 9));
  if (!StreamBasicDescription)
  {
    uint64_t v7 = 4294954586;
    goto LABEL_48;
  }
  CFIndex v12 = StreamBasicDescription;
  if (StreamBasicDescription->mFormatID == 1819304813 && (StreamBasicDescription->mFormatFlags & 0x20) != 0)
  {
    UInt32 mChannelsPerFrame = StreamBasicDescription->mChannelsPerFrame;
    if (bufferList->mNumberBuffers == mChannelsPerFrame)
    {
      UInt32 mNumberChannels = 1;
      if (mChannelsPerFrame != 1) {
        goto LABEL_25;
      }
      goto LABEL_13;
    }
LABEL_47:
    uint64_t v7 = 4294954565;
    goto LABEL_48;
  }
  if (bufferList->mNumberBuffers != 1) {
    goto LABEL_47;
  }
  UInt32 mNumberChannels = StreamBasicDescription->mChannelsPerFrame;
LABEL_13:
  if (mNumberChannels != bufferList->mBuffers[0].mNumberChannels)
  {
    FormatList = CMAudioFormatDescriptionGetFormatList(*((CMAudioFormatDescriptionRef *)sbuf + 9), &sizeOut);
    if (FormatList)
    {
      if (sizeOut >= 0x31)
      {
        uint64_t v15 = 0;
        unsigned int v16 = 1;
        while (FormatList[v15].mASBD.mChannelsPerFrame != bufferList->mBuffers[0].mNumberChannels)
        {
          uint64_t v15 = v16;
          if (sizeOut / 0x30 <= v16++) {
            goto LABEL_25;
          }
        }
        UInt32 mNumberChannels = bufferList->mBuffers[0].mNumberChannels;
      }
    }
  }
LABEL_25:
  uint64_t mNumberBuffers = bufferList->mNumberBuffers;
  if (mNumberBuffers)
  {
    size_t v20 = 0;
    size_t v21 = 0;
    p_mData = &bufferList->mBuffers[0].mData;
    while (*((_DWORD *)p_mData - 2) == mNumberChannels)
    {
      uint64_t v23 = *((unsigned int *)p_mData - 1);
      if (!v23 || !*p_mData) {
        break;
      }
      if (v21)
      {
        if (v21 != v23) {
          goto LABEL_47;
        }
      }
      else
      {
        size_t v21 = *((unsigned int *)p_mData - 1);
      }
      p_mData += 2;
      v20 += v21;
      if (!--mNumberBuffers) {
        goto LABEL_37;
      }
    }
    goto LABEL_47;
  }
  size_t v21 = 0;
  size_t v20 = 0;
LABEL_37:
  if (v12->mFormatID == 1819304813)
  {
    CFTypeRef v24 = (long long *)*((void *)sbuf + 12);
    if (!v24) {
      goto LABEL_47;
    }
    if (*((void *)sbuf + 11) != 1) {
      goto LABEL_47;
    }
    CMTimeMake(&time2, 1, (int)v12->mSampleRate);
    long long v25 = *v24;
    time1.CMTimeEpoch epoch = *((void *)v24 + 2);
    *(_OWORD *)&time1.CMTimeValue value = v25;
    if (CMTimeCompare(&time1, &time2) || *((void *)sbuf + 10) != v21 / v12->mBytesPerFrame) {
      goto LABEL_47;
    }
  }
  if ((v8 & 1) != 0 && (v21 & 0xF) != 0)
  {
    unint64_t v26 = (v21 + 15) & 0xFFFFFFFFFFFFFFF0;
    CFIndex v27 = v26 * bufferList->mNumberBuffers;
    long long v28 = (char *)CFAllocatorAllocate(blockBufferBlockAllocator, v27, 0);
    if (!v28)
    {
      OSStatus v31 = -12730;
      goto LABEL_49;
    }
    CFTypeRef v29 = v28;
    OSStatus v30 = CMBlockBufferCreateEmpty(blockBufferStructureAllocator, bufferList->mNumberBuffers, 0, &blockBufferOut);
    if (v30)
    {
      OSStatus v31 = v30;
      CFAllocatorDeallocate(blockBufferBlockAllocator, v29);
LABEL_49:
      if (v31 && blockBufferOut) {
        CFRelease(blockBufferOut);
      }
      return v31;
    }
    CMTime v43 = v12;
    if (bufferList->mNumberBuffers)
    {
      uint64_t v36 = v29;
      size_t v37 = v27;
      unint64_t v38 = 0;
      size_t v39 = 0;
      CFAllocatorRef v44 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
      CMTime v40 = &bufferList->mBuffers[0].mData;
      do
      {
        if (v38) {
          CFAllocatorRef v41 = v44;
        }
        else {
          CFAllocatorRef v41 = blockBufferBlockAllocator;
        }
        CMBlockBufferAppendMemoryBlock(blockBufferOut, v36, v37, v41, 0, v39, v21, 0);
        OSStatus v42 = *v40;
        v40 += 2;
        memcpy(&v36[v39], v42, v21);
        v39 += v26;
        ++v38;
      }
      while (v38 < bufferList->mNumberBuffers);
    }
  }
  else
  {
    OSStatus v31 = CMBlockBufferCreateWithMemoryBlock(blockBufferStructureAllocator, 0, v20, blockBufferBlockAllocator, 0, 0, v20, 1u, &blockBufferOut);
    if (v31) {
      goto LABEL_49;
    }
    CMTime v43 = v12;
    CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
    if (bufferList->mNumberBuffers)
    {
      unint64_t v33 = 0;
      long long v34 = dataPointerOut;
      uint64_t v35 = 16;
      do
      {
        memcpy(v34, *(const void **)((char *)&bufferList->mNumberBuffers + v35), v21);
        long long v34 = &dataPointerOut[v21];
        dataPointerOut += v21;
        ++v33;
        v35 += 16;
      }
      while (v33 < bufferList->mNumberBuffers);
    }
  }
  *((void *)sbuf + 2) = blockBufferOut;
  *((unsigned char *)sbuf + 25) = 1;
  CMBlockBufferRef blockBufferOut = 0;
  if (v43->mFormatID == 1819304813 && (v43->mFormatFlags & 0x20) != 0)
  {
    *((void *)sbuf + 13) = 0;
    *((void *)sbuf + 14) = 0;
  }
  figSampleBufferCheckDataSize((size_t)sbuf);
  return 0;
}

OSStatus CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(CMSampleBufferRef sbuf, size_t *bufferListSizeNeededOut, AudioBufferList *bufferListOut, size_t bufferListSize, CFAllocatorRef blockBufferStructureAllocator, CFAllocatorRef blockBufferBlockAllocator, uint32_t flags, CMBlockBufferRef *blockBufferOut)
{
  if (!sbuf) {
    goto LABEL_18;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v9 = 4294954552;
LABEL_19:
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  char v11 = flags;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*((CMAudioFormatDescriptionRef *)sbuf + 9));
  if (!StreamBasicDescription)
  {
    uint64_t v9 = 4294954586;
    goto LABEL_19;
  }
  if (StreamBasicDescription->mFormatID == 1819304813 && (StreamBasicDescription->mFormatFlags & 0x20) != 0)
  {
    signed int mChannelsPerFrame = StreamBasicDescription->mChannelsPerFrame;
    if (!mChannelsPerFrame)
    {
      uint64_t v9 = 4294954553;
      goto LABEL_19;
    }
    int v18 = 1;
  }
  else
  {
    int v18 = StreamBasicDescription->mChannelsPerFrame;
    signed int mChannelsPerFrame = 1;
  }
  size_t v20 = 16 * (mChannelsPerFrame - 1) + 24;
  if (bufferListSizeNeededOut) {
    *bufferListSizeNeededOut = v20;
  }
  if (!bufferListOut) {
    return 0;
  }
  if (v20 != bufferListSize)
  {
    uint64_t v9 = 4294954559;
    goto LABEL_19;
  }
  if (!blockBufferOut)
  {
LABEL_18:
    uint64_t v9 = 4294954565;
    goto LABEL_19;
  }
  size_t v21 = (OpaqueCMBlockBuffer *)*((void *)sbuf + 2);
  if (!v21 || !*((unsigned char *)sbuf + 25))
  {
    uint64_t v9 = 4294954563;
    goto LABEL_19;
  }

  return DataBufferToAudioListWorker(v21, blockBufferStructureAllocator, blockBufferBlockAllocator, mChannelsPerFrame, v18, v11 & 1, (signed int *)bufferListOut, blockBufferOut);
}

uint64_t DataBufferToAudioListWorker(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, const __CFAllocator *a3, signed int a4, int a5, int a6, signed int *a7, CMBlockBufferRef *a8)
{
  size_t lengthAtOffsetOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  dataPointerOut = 0;
  *a7 = a4;
  uint64_t v13 = a4;
  size_t v14 = CMBlockBufferGetDataLength(a1) / a4;
  if (a4)
  {
    CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (lengthAtOffsetOut >= v14)
    {
      size_t v16 = 0;
      unint64_t v17 = 1;
      BOOL v15 = 1;
      do
      {
        if (a6 && (dataPointerOut & 0xF) != 0) {
          break;
        }
        if (a4 == v17) {
          goto LABEL_11;
        }
        v16 += v14;
        BOOL v15 = v17 < a4;
        CMBlockBufferGetDataPointer(a1, v16, &lengthAtOffsetOut, 0, &dataPointerOut);
        ++v17;
      }
      while (lengthAtOffsetOut >= v14);
    }
    else
    {
      BOOL v15 = 1;
    }
    uint64_t v18 = CMBlockBufferCreateEmpty(a2, a4, 0, &blockBufferOut);
    if (v18) {
      goto LABEL_26;
    }
  }
  else
  {
LABEL_11:
    if (a1) {
      CFTypeRef v19 = (OpaqueCMBlockBuffer *)CFRetain(a1);
    }
    else {
      CFTypeRef v19 = 0;
    }
    BOOL v15 = 0;
    CMBlockBufferRef blockBufferOut = v19;
    if (!a4)
    {
LABEL_24:
      uint64_t v18 = 0;
      CMBlockBufferRef v23 = blockBufferOut;
      goto LABEL_28;
    }
  }
  size_t v20 = 0;
  size_t v21 = (char **)(a7 + 4);
  while (1)
  {
    CMBlockBufferGetDataPointer(a1, v20, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (v15) {
      break;
    }
LABEL_23:
    *size_t v21 = dataPointerOut;
    *((_DWORD *)v21 - 2) = a5;
    *((_DWORD *)v21 - 1) = v14;
    v20 += v14;
    v21 += 2;
    if (!--v13) {
      goto LABEL_24;
    }
  }
  if (lengthAtOffsetOut >= v14 && (!a6 || (dataPointerOut & 0xF) == 0))
  {
    CMBlockBufferAppendBufferReference(blockBufferOut, a1, v20, v14, 0);
    goto LABEL_23;
  }
  uint64_t appended = CMBlockBufferAppendMemoryBlock(blockBufferOut, 0, v14, a3, 0, 0, v14, 1u);
  if (!appended)
  {
    CMBlockBufferGetDataPointer(blockBufferOut, v20, 0, 0, &dataPointerOut);
    CMBlockBufferCopyDataBytes(a1, v20, v14, dataPointerOut);
    goto LABEL_23;
  }
  uint64_t v18 = appended;
LABEL_26:
  if (blockBufferOut)
  {
    CFRelease(blockBufferOut);
    CMBlockBufferRef v23 = 0;
LABEL_28:
    *a8 = v23;
  }
  return v18;
}

OSStatus CMSampleBufferCopyPCMDataIntoAudioBufferList(CMSampleBufferRef sbuf, int32_t frameOffset, int32_t numFrames, AudioBufferList *bufferList)
{
  if (!sbuf || !bufferList) {
    goto LABEL_32;
  }
  if (CMFormatDescriptionGetMediaType(*((CMFormatDescriptionRef *)sbuf + 9)) != 1936684398)
  {
    uint64_t v23 = 4294954555;
    goto LABEL_33;
  }
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*((CMAudioFormatDescriptionRef *)sbuf + 9));
  if (!StreamBasicDescription)
  {
    uint64_t v23 = 4294954586;
    goto LABEL_33;
  }
  uint64_t v9 = StreamBasicDescription;
  if (StreamBasicDescription->mFormatID != 1819304813)
  {
    uint64_t v23 = 4294954554;
    goto LABEL_33;
  }
  uint64_t v10 = *((void *)sbuf + 10);
  if (v10 <= frameOffset) {
    goto LABEL_36;
  }
  if (!numFrames)
  {
LABEL_32:
    uint64_t v23 = 4294954565;
LABEL_33:
    return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
  }
  if (v10 < numFrames + frameOffset)
  {
LABEL_36:
    uint64_t v23 = 4294954562;
    goto LABEL_33;
  }
  char v11 = (OpaqueCMBlockBuffer *)*((void *)sbuf + 2);
  if (!v11 || !*((unsigned char *)sbuf + 25))
  {
    uint64_t v23 = 4294954563;
    goto LABEL_33;
  }
  uint64_t mBytesPerFrame = v9->mBytesPerFrame;
  int mChannelsPerFrame = v9->mChannelsPerFrame;
  size_t v14 = (mBytesPerFrame * numFrames);
  LODWORD(v15) = bufferList->mNumberBuffers;
  if ((v9->mFormatFlags & 0x20) == 0)
  {
    if (v15 != 1) {
      goto LABEL_41;
    }
    goto LABEL_17;
  }
  if (v15 != mChannelsPerFrame)
  {
LABEL_41:
    FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (mChannelsPerFrame)
  {
    LODWORD(v15) = v9->mChannelsPerFrame;
    int mChannelsPerFrame = 1;
LABEL_17:
    uint64_t v15 = v15;
    p_mData = &bufferList->mBuffers[0].mData;
    while (*((_DWORD *)p_mData - 2) == mChannelsPerFrame && *((_DWORD *)p_mData - 1) == v14 && *p_mData)
    {
      p_mData += 2;
      if (!--v15) {
        goto LABEL_22;
      }
    }
    goto LABEL_32;
  }
LABEL_22:
  size_t v17 = (mBytesPerFrame * frameOffset);
  if ((v9->mFormatFlags & 0x20) != 0)
  {
    if (!v9->mChannelsPerFrame) {
      return 0;
    }
    unint64_t v20 = 0;
    uint64_t v21 = v10 * mBytesPerFrame;
    for (CFIndex i = &bufferList->mBuffers[0].mData; ; i += 2)
    {
      OSStatus result = CMBlockBufferCopyDataBytes(*((CMBlockBufferRef *)sbuf + 2), v17, v14, *i);
      if (result) {
        break;
      }
      ++v20;
      v17 += v21;
      if (v20 >= v9->mChannelsPerFrame) {
        return 0;
      }
    }
  }
  else
  {
    mData = bufferList->mBuffers[0].mData;
    return CMBlockBufferCopyDataBytes(v11, v17, v14, mData);
  }
  return result;
}

OSStatus CMSampleBufferGetAudioStreamPacketDescriptionsPtr(CMSampleBufferRef sbuf, const AudioStreamPacketDescription **packetDescriptionsPointerOut, size_t *packetDescriptionsSizeOut)
{
  if (!sbuf) {
    goto LABEL_14;
  }
  if (*((unsigned char *)sbuf + 24))
  {
    uint64_t v4 = 4294954552;
LABEL_15:
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (!((unint64_t)packetDescriptionsPointerOut | (unint64_t)packetDescriptionsSizeOut))
  {
LABEL_14:
    uint64_t v4 = 4294954565;
    goto LABEL_15;
  }
  uint64_t v7 = (const opaqueCMFormatDescription *)*((void *)sbuf + 9);
  if (!v7 || CMFormatDescriptionGetMediaType(v7) != 1936684398)
  {
    uint64_t v4 = 4294954555;
    goto LABEL_15;
  }
  if (*((unsigned char *)sbuf + 344) || (OSStatus result = sBufComputeAudioStreamPacketDescriptions((uint64_t)sbuf)) == 0)
  {
    if (packetDescriptionsPointerOut)
    {
      char v8 = (const AudioStreamPacketDescription *)*((void *)sbuf + 42);
      if (v8) {
        char v8 = (const AudioStreamPacketDescription *)*((void *)sbuf + 41);
      }
      *packetDescriptionsPointerOut = v8;
    }
    OSStatus result = 0;
    if (packetDescriptionsSizeOut) {
      *packetDescriptionsSizeOut = 16 * *((void *)sbuf + 42);
    }
  }
  return result;
}

uint64_t sBufComputeAudioStreamPacketDescriptions(uint64_t a1)
{
  memset(&timingInfoOut, 0, sizeof(timingInfoOut));
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*(CMAudioFormatDescriptionRef *)(a1 + 72));
  if (!StreamBasicDescription)
  {
    uint64_t v6 = 4294954586;
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 344)) {
    goto LABEL_8;
  }
  uint64_t v3 = StreamBasicDescription;
  CMItemCount NumSamples = CMSampleBufferGetNumSamples((CMSampleBufferRef)a1);
  if (v3->mFramesPerPacket)
  {
    p_uint64_t mBytesPerPacket = &v3->mBytesPerPacket;
    if (v3->mBytesPerPacket)
    {
      *(void *)(a1 + 336) = 0;
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (!*(void *)(a1 + 96))
  {
    uint64_t v6 = 4294954560;
    goto LABEL_7;
  }
  p_uint64_t mBytesPerPacket = &v3->mBytesPerPacket;
  if (!v3->mBytesPerPacket)
  {
LABEL_12:
    if (!*(void *)(a1 + 112))
    {
      uint64_t v6 = 4294954561;
      goto LABEL_7;
    }
  }
  *(void *)(a1 + 336) = NumSamples;
  if (!NumSamples) {
    goto LABEL_8;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int value = 0;
  UInt32 v11 = *p_mBytesPerPacket;
  unint64_t v12 = 1;
  size_t SampleSize = *p_mBytesPerPacket;
  while (1)
  {
    if (!v11) {
      size_t SampleSize = CMSampleBufferGetSampleSize((CMSampleBufferRef)a1, v12 - 1);
    }
    UInt32 mFramesPerPacket = v3->mFramesPerPacket;
    if (!mFramesPerPacket) {
      break;
    }
LABEL_21:
    *(void *)(*(void *)(a1 + 328) + v8) = v9;
    if (mFramesPerPacket) {
      int v16 = 0;
    }
    else {
      int v16 = value;
    }
    *(_DWORD *)(*(void *)(a1 + 328) + v8 + 8) = v16;
    *(_DWORD *)(*(void *)(a1 + 328) + v8 + 12) = SampleSize;
    if (v12 >= *(void *)(a1 + 336)) {
      goto LABEL_8;
    }
    v9 += SampleSize;
    UInt32 v11 = *p_mBytesPerPacket;
    ++v12;
    v8 += 16;
  }
  uint64_t result = CMSampleBufferGetSampleTimingInfo((CMSampleBufferRef)a1, v12 - 1, &timingInfoOut);
  if (result) {
    return result;
  }
  int32_t mSampleRate = (int)v3->mSampleRate;
  CMTime duration = timingInfoOut.duration;
  CMTimeConvertScale(&v18, &duration, mSampleRate, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  if ((v18.flags & 0x1D) == 1)
  {
    int value = v18.value;
    UInt32 mFramesPerPacket = v3->mFramesPerPacket;
    goto LABEL_21;
  }
  uint64_t v6 = 4294954556;
LABEL_7:
  uint64_t result = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  if (!result)
  {
LABEL_8:
    uint64_t result = 0;
    *(unsigned char *)(a1 + 344) = 1;
  }
  return result;
}

OSStatus CMSampleBufferGetAudioStreamPacketDescriptions(CMSampleBufferRef sbuf, size_t packetDescriptionsSize, AudioStreamPacketDescription *packetDescriptionsOut, size_t *packetDescriptionsSizeNeededOut)
{
  size_t __n = 0;
  packetDescriptionsPointerOut = 0;
  OSStatus result = CMSampleBufferGetAudioStreamPacketDescriptionsPtr(sbuf, (const AudioStreamPacketDescription **)&packetDescriptionsPointerOut, &__n);
  if (!result)
  {
    if (packetDescriptionsSizeNeededOut) {
      *packetDescriptionsSizeNeededOut = __n;
    }
    if (!packetDescriptionsOut) {
      return 0;
    }
    if (__n > packetDescriptionsSize) {
      return FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
    }
    OSStatus result = 0;
    if (__n && packetDescriptionsPointerOut)
    {
      memcpy(packetDescriptionsOut, packetDescriptionsPointerOut, __n);
      return 0;
    }
  }
  return result;
}

uint64_t FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary(const __CFAllocator *a1, unint64_t a2, void *a3)
{
  if (FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_onceToken != -1) {
    dispatch_once_f(&FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_onceToken, &FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_context, (dispatch_function_t)InitializePacketAttributes);
  }
  if ((_BYTE)a2)
  {
    if ((a2 & 0x8000000000000000) != 0 || SHIDWORD(a2) > 3)
    {
      SampleDependencyAttributeDictionaryForAudioRefreshCFIndex Count = createSampleDependencyAttributeDictionaryForAudioRefreshCount(a1, SHIDWORD(a2));
      if (SampleDependencyAttributeDictionaryForAudioRefreshCount) {
        goto LABEL_10;
      }
      goto LABEL_12;
    }
    uint64_t v6 = (const void *)FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_sIndependentPacketAttributes[HIDWORD(a2)];
    if (!v6) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v6 = (const void *)FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_sDependentPacketAttributes;
    if (!FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_sDependentPacketAttributes) {
      goto LABEL_12;
    }
  }
  SampleDependencyAttributeDictionaryForAudioRefreshCFIndex Count = (void *)CFRetain(v6);
  if (SampleDependencyAttributeDictionaryForAudioRefreshCount)
  {
LABEL_10:
    *a3 = SampleDependencyAttributeDictionaryForAudioRefreshCount;
    return 0;
  }
LABEL_12:

  return FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
}

CFDictionaryRef InitializePacketAttributes(uint64_t a1)
{
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t v3 = 0;
  **(void **)a1 = CFDictionaryCreate(AllocatorForPermanentAllocations, (const void **)&kCMSampleAttachmentKey_NotSync, MEMORY[0x1E4F1CFD0], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  do
  {
    CFAllocatorRef v4 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
    CFDictionaryRef result = createSampleDependencyAttributeDictionaryForAudioRefreshCount(v4, v3);
    *(void *)(*(void *)(a1 + 8) + 8 * v3++) = result;
  }
  while (v3 != 4);
  return result;
}

CFDictionaryRef createSampleDependencyAttributeDictionaryForAudioRefreshCount(const __CFAllocator *a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int valuePtr = a2;
  long long v16 = xmmword_1E56772A8;
  uint64_t v14 = *MEMORY[0x1E4F1CFD0];
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (!v3) {
    return 0;
  }
  CFNumberRef v4 = v3;
  CFNumberRef v15 = v3;
  if (valuePtr)
  {
    uint64_t v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    uint64_t v7 = (const void **)&v16;
    uint64_t v8 = (const void **)&v14;
    CFAllocatorRef v9 = a1;
    CFIndex v10 = 2;
  }
  else
  {
    uint64_t v8 = (const void **)&v15;
    uint64_t v7 = (const void **)&v16 + 1;
    uint64_t v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    CFAllocatorRef v9 = a1;
    CFIndex v10 = 1;
  }
  CFDictionaryRef v11 = CFDictionaryCreate(v9, v7, v8, v10, v5, v6);
  CFRelease(v4);
  return v11;
}

uint64_t FigAudioStreamPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary(const __CFAllocator *a1, _DWORD *a2, void *a3)
{
  if (*a2) {
    unint64_t v3 = 0;
  }
  else {
    unint64_t v3 = (unint64_t)a2[1] << 32;
  }
  return FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary(a1, v3 | (*a2 == 0), a3);
}

uint64_t FigSampleBufferGetDecryptor(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

void FigSampleBufferSetDecryptor(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(const void **)(a1 + 152);
  *(void *)(a1 + 152) = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t CMSampleBufferCreateReadyForCVDataBuffer(const __CFAllocator *a1, void *cf, const opaqueCMFormatDescription *a3, uint64_t a4, void *a5)
{
  CFTypeRef cfa = 0;
  CMBlockBufferRef blockBufferOut = 0;
  memset(&customBlockSource, 0, sizeof(customBlockSource));
  if (!a5)
  {
    uint64_t v30 = 4294954565;
    goto LABEL_15;
  }
  if (!cf
    || (CFTypeID v10 = CFGetTypeID(cf), v10 != CVDataBufferGetTypeID())
    || !a3
    || !a4
    || (uint64_t IOSurface = CVDataBufferGetIOSurface()) == 0)
  {
    uint64_t v30 = 4294954565;
LABEL_15:
    uint64_t v14 = FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  unint64_t v12 = (__IOSurface *)IOSurface;
  int PixelFormatType = CVDataBufferGetPixelFormatType();
  if (CMFormatDescriptionGetMediaSubType(a3) != PixelFormatType)
  {
    uint64_t v30 = 4294954553;
    goto LABEL_15;
  }
  CVDataBufferGetDataSize();
  uint64_t v14 = sBufCreate((uint64_t)a1, 1uLL, 1uLL, 0, &cfa);
  if (v14)
  {
LABEL_16:
    uint64_t v17 = v14;
    goto LABEL_17;
  }
  IOSurfaceLock(v12, 1u, 0);
  BaseAddress = IOSurfaceGetBaseAddress(v12);
  size_t AllocSize = IOSurfaceGetAllocSize(v12);
  CFRetain(cf);
  customBlockSource.version = 0;
  customBlockSource.refCon = cf;
  customBlockSource.AllocateBlock = 0;
  customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))sbufReleaseCVDataBufferAfterUnlockingIOSurface;
  uint64_t v17 = CMBlockBufferCreateWithMemoryBlock(a1, BaseAddress, AllocSize, 0, &customBlockSource, 0, AllocSize, 0, &blockBufferOut);
  if (!v17)
  {
    CMSetAttachment(blockBufferOut, @"CVDataBuffer", cf, 0);
    CMTime v18 = cfa;
    CMBlockBufferRef v19 = blockBufferOut;
    *((_DWORD *)cfa + 7) = 0;
    v18[2] = v19;
    CMBlockBufferRef blockBufferOut = 0;
    *((unsigned char *)v18 + 25) = 1;
    CFTypeRef v20 = FigFormatDescriptionRetain(a3);
    uint64_t v21 = (char *)cfa;
    *((void *)cfa + 9) = v20;
    *((void *)v21 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
    **((void **)v21 + 14) = AllocSize;
    uint64_t v22 = *((void *)v21 + 12);
    long long v24 = *(_OWORD *)(a4 + 32);
    long long v23 = *(_OWORD *)(a4 + 48);
    long long v25 = *(_OWORD *)(a4 + 16);
    *(void *)(v22 + 64) = *(void *)(a4 + 64);
    *(_OWORD *)(v22 + 32) = v24;
    *(_OWORD *)(v22 + 48) = v23;
    *(_OWORD *)(v22 + 16) = v25;
    *(_OWORD *)uint64_t v22 = *(_OWORD *)a4;
    uint64_t v26 = *(void *)(a4 + 64);
    *((_OWORD *)v21 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)(a4 + 48);
    *((void *)v21 + 22) = v26;
    uint64_t v27 = *(void *)(a4 + 40);
    *(_OWORD *)(v21 + 184) = *(_OWORD *)(a4 + 24);
    *((void *)v21 + 25) = v27;
    uint64_t v28 = *(void *)(a4 + 16);
    *((_OWORD *)v21 + 13) = *(_OWORD *)a4;
    *((void *)v21 + 28) = v28;
    *a5 = v21;
    CFTypeRef cfa = 0;
    goto LABEL_11;
  }
  IOSurfaceUnlock(v12, 1u, 0);
  CFRelease(cf);
LABEL_17:
  if (cfa) {
    CFRelease(cfa);
  }
LABEL_11:
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v17;
}

void sbufReleaseCVDataBufferAfterUnlockingIOSurface(const void *a1)
{
  uint64_t IOSurface = (__IOSurface *)CVDataBufferGetIOSurface();
  IOSurfaceUnlock(IOSurface, 1u, 0);

  CFRelease(a1);
}

__CFString *sBufCopyDebugDesc(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFIndex v3 = CFGetRetainCount((CFTypeRef)a1);
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"CMSampleBuffer %p retainCount: %d allocator: %p\n", a1, v3, v4);
  if (*(unsigned char *)(a1 + 24)) {
    uint64_t v5 = "YES";
  }
  else {
    uint64_t v5 = "NO";
  }
  CFStringAppendFormat(Mutable, 0, @"\tinvalid = %s\n", v5);
  if (*(unsigned char *)(a1 + 26))
  {
    CFStringAppendFormat(Mutable, 0, @"\tdataFailed = YES\n", v35, v36, v37);
  }
  else
  {
    if (*(unsigned char *)(a1 + 25)) {
      uint64_t v6 = "YES";
    }
    else {
      uint64_t v6 = "NO";
    }
    if (*(unsigned char *)(a1 + 27)) {
      CFStringAppendFormat(Mutable, 0, @"\tdataReady = %s\n\tmakeDataReadyHandler = %p\n", v6, *(void *)(a1 + 48), v37);
    }
    else {
      CFStringAppendFormat(Mutable, 0, @"\tdataReady = %s\n\tmakeDataReadyCallback = %p\n\tmakeDataReadyRefcon = %p\n", v6, *(void *)(a1 + 48), *(void *)(a1 + 56));
    }
  }
  if (*(void *)(a1 + 312) || *(void *)(a1 + 320))
  {
    CFStringAppendFormat(Mutable, 0, @"\tbuffer-level attachments:\n");
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 312);
    if (v7)
    {
      context.int value = (CMTimeValue)Mutable;
      *(void *)&context.CMTimeScale timescale = 1;
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)describeSBufAnnotation, &context);
    }
  }
  CFDictionaryRef v8 = *(const __CFDictionary **)(a1 + 320);
  if (v8)
  {
    context.int value = (CMTimeValue)Mutable;
    *(void *)&context.CMTimeScale timescale = 0;
    CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)describeSBufAnnotation, &context);
  }
  CFAllocatorRef v9 = *(const void **)(a1 + 72);
  if (v9)
  {
    CFStringRef v10 = CFCopyDescription(v9);
    CFStringAppendFormat(Mutable, 0, @"\tformatDescription = %@\n", v10);
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"\tformatDescription = %@\n", 0);
  }
  CFStringAppendFormat(Mutable, 0, @"\tsbufToTrackReadiness = %p\n\tnumSamples = %ld\n", *(void *)(a1 + 64), *(void *)(a1 + 80));
  CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
  CMSampleBufferGetOutputPresentationTimeStamp(&context, (CMSampleBufferRef)a1);
  CFStringRef v12 = CMTimeCopyDescription(v11, &context);
  CFStringAppendFormat(Mutable, 0, @"\toutputPTS = %@", v12);
  if (v12) {
    CFRelease(v12);
  }
  if ((*(_DWORD *)(a1 + 136) & 0x1D) == 1)
  {
    CFStringAppendFormat(Mutable, 0, @"(based on outputPresentationTimeStamp)\n");
  }
  else if ((*(_DWORD *)(a1 + 268) & 0x1D) == 1)
  {
    CFStringAppendFormat(Mutable, 0, @"(based on cachedOutputPresentationTimeStamp)\n");
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"(computed from PTS, duration and attachments)\n");
  }
  if (*(void *)(a1 + 88))
  {
    CFStringAppendFormat(Mutable, 0, @"\tsampleTimingArray[%d] = {\n", *(void *)(a1 + 88));
    if (*(uint64_t *)(a1 + 88) >= 1)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      do
      {
        CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
        long long v16 = (long long *)(*(void *)(a1 + 96) + v13);
        long long v17 = *v16;
        time.CMTimeEpoch epoch = *((void *)v16 + 2);
        *(_OWORD *)&time.int value = v17;
        CFStringRef v18 = CMTimeCopyDescription(v15, &time);
        CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)a1);
        uint64_t v20 = *(void *)(a1 + 96) + v13;
        long long v21 = *(_OWORD *)(v20 + 24);
        time.CMTimeEpoch epoch = *(void *)(v20 + 40);
        *(_OWORD *)&time.int value = v21;
        CFStringRef v22 = CMTimeCopyDescription(v19, &time);
        CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
        uint64_t v24 = *(void *)(a1 + 96) + v13;
        long long v25 = *(_OWORD *)(v24 + 48);
        time.CMTimeEpoch epoch = *(void *)(v24 + 64);
        *(_OWORD *)&time.int value = v25;
        CFStringRef v26 = CMTimeCopyDescription(v23, &time);
        CFStringAppendFormat(Mutable, 0, @"\t\t{PTS = %@, DTS = %@, CMTime duration = %@},\n", v22, v26, v18);
        CFRelease(v18);
        CFRelease(v22);
        CFRelease(v26);
        ++v14;
        v13 += 72;
      }
      while (v14 < *(void *)(a1 + 88));
    }
    CFStringAppendFormat(Mutable, 0, @"\t}\n");
  }
  if (*(void *)(a1 + 104))
  {
    CFStringAppendFormat(Mutable, 0, @"\tsampleSizeArray[%d] = {\n", *(void *)(a1 + 104));
    if (*(uint64_t *)(a1 + 104) >= 1)
    {
      uint64_t v27 = 0;
      do
        CFStringAppendFormat(Mutable, 0, @"\t\tsampleSize = %zu,\n", *(void *)(*(void *)(a1 + 112) + 8 * v27++));
      while (v27 < *(void *)(a1 + 104));
    }
    CFStringAppendFormat(Mutable, 0, @"\t}\n");
  }
  if (*(void *)(a1 + 304))
  {
    CFStringAppendFormat(Mutable, 0, @"\tsampleAttachmentsArray[%d] = {\n", *(void *)(a1 + 104));
    if (*(uint64_t *)(a1 + 80) >= 1)
    {
      CFIndex v28 = 0;
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 304), v28);
        CFStringAppendFormat(Mutable, 0, @"\t\tsample %d:\n", v28);
        CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)appendSampleAnnotation, Mutable);
        ++v28;
      }
      while (v28 < *(void *)(a1 + 80));
    }
    CFStringAppendFormat(Mutable, 0, @"\t}\n");
  }
  switch(*(_DWORD *)(a1 + 28))
  {
    case 0:
      uint64_t v30 = *(const void **)(a1 + 16);
      if (v30)
      {
        CFStringRef v31 = CFCopyDescription(v30);
        if (v31)
        {
          CFStringRef v32 = v31;
          CFStringAppendFormat(Mutable, 0, @"\tdataBuffer = {\n%@}\n", v31);
          CFRelease(v32);
          return Mutable;
        }
        uint64_t v33 = *(void *)(a1 + 16);
      }
      else
      {
        uint64_t v33 = 0;
      }
      CFStringAppendFormat(Mutable, 0, @"\tdataBuffer = %p\n", v33);
      return Mutable;
    case 1:
      CFStringAppendFormat(Mutable, 0, @"\timageBuffer = %p\n", *(void *)(a1 + 16));
      return Mutable;
    case 2:
      CFStringAppendFormat(Mutable, 0, @"\tcaptionGroup = %p\n", *(void *)(a1 + 16));
      return Mutable;
    case 3:
      CFStringAppendFormat(Mutable, 0, @"\ttaggedBufferGroup = %p\n", *(void *)(a1 + 16));
      return Mutable;
    default:
      return Mutable;
  }
}

void describeSBufAnnotation(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v19 = 0;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v7 = 0u;
  *(_DWORD *)buffer = 1061109567;
  CFStringGetCString(a1, buffer, 200, 0x8000100u);
  if (*(_DWORD *)(a3 + 8) == 1) {
    uint64_t v5 = "(P)";
  }
  else {
    uint64_t v5 = "   ";
  }
  CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, @"\t\t%-10s%s = %@\n", buffer, v5, a2);
}

void appendSampleAnnotation(const __CFString *a1, uint64_t a2, __CFString *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v18 = 0;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v7 = 0u;
  long long v6 = 0u;
  *(_DWORD *)buffer = 1061109567;
  CFStringGetCString(a1, buffer, 200, 0x8000100u);
  CFStringAppendFormat(a3, 0, @"\t\t\t%-10s = %@\n", buffer, a2);
}

double sBufRemoveAttachment(uint64_t a1, CFTypeRef cf1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v5 = *(__CFDictionary **)(a1 + 312);
    if (v5) {
      CFDictionaryRemoveValue(v5, cf1);
    }
    long long v6 = *(__CFDictionary **)(a1 + 320);
    if (v6) {
      CFDictionaryRemoveValue(v6, cf1);
    }
    return checkCacheKeys(a1, cf1);
  }
  return result;
}

double sBufRemoveAllAttachments(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFIndex v3 = *(const void **)(a1 + 312);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 312) = 0;
    }
    CFAllocatorRef v4 = *(const void **)(a1 + 320);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 32CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    }
    return checkCacheKeys(a1, @"TrimDurationAtStart");
  }
  return result;
}

CFDictionaryRef sBufCopyDictionaryOfAttachments(const __CFAllocator *a1, uint64_t a2, int a3)
{
  if (*(unsigned char *)(a2 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v4 = 320;
  if (a3 == 1) {
    uint64_t v4 = 312;
  }
  CFDictionaryRef v5 = *(const __CFDictionary **)(a2 + v4);
  if (!v5) {
    return 0;
  }

  return CFDictionaryCreateCopy(a1, v5);
}

CFTypeID CMSimpleQueueGetTypeID(void)
{
  return sFigSimpleQueueID;
}

uint64_t registerFigSimpleQueueType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigSimpleQueueID = result;
  return result;
}

CFTypeRef FigSimpleQueueRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void FigSimpleQueueRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

OSStatus CMSimpleQueueCreate(CFAllocatorRef allocator, int32_t capacity, CMSimpleQueueRef *queueOut)
{
  if (capacity && queueOut)
  {
    if (capacity < 0)
    {
      OSStatus result = FigSignalErrorAt(4294954524, 0, 0, 0, 0, 0, 0);
      long long v7 = 0;
    }
    else
    {
      size_t v5 = 8 * capacity + 24;
      FigThreadRunOnce(&sRegisterFigSimpleQueueTypeOnce, (void (*)(void))registerFigSimpleQueueType);
      uint64_t Instance = _CFRuntimeCreateInstance();
      long long v7 = (opaqueCMSimpleQueue *)Instance;
      if (Instance)
      {
        bzero((void *)(Instance + 16), v5);
        OSStatus result = 0;
        *((_DWORD *)v7 + 4) = capacity;
      }
      else
      {
        OSStatus result = FigSignalErrorAt(4294954526, 0, 0, 0, 0, 0, 0);
      }
    }
    goto LABEL_10;
  }
  OSStatus result = FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  long long v7 = 0;
  if (queueOut) {
LABEL_10:
  }
    *queueOut = v7;
  return result;
}

OSStatus CMSimpleQueueEnqueue(CMSimpleQueueRef queue, const void *element)
{
  if (queue && element)
  {
    uint64_t v4 = *((int *)queue + 6);
    int v5 = ((int)v4 + 1) % (*((_DWORD *)queue + 4) + 1);
    if (v5 == *((_DWORD *)queue + 5))
    {
      return -12773;
    }
    else
    {
      *((void *)queue + v4 + 4) = element;
      FigMemoryBarrier();
      *((_DWORD *)queue + 6) = v5;
      FigMemoryBarrier();
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  }
}

const void *__cdecl CMSimpleQueueDequeue(CMSimpleQueueRef queue)
{
  if (!queue)
  {
    FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  uint64_t v2 = *((int *)queue + 5);
  if (v2 == *((_DWORD *)queue + 6)) {
    return 0;
  }
  CFIndex v3 = (const void *)*((void *)queue + v2 + 4);
  int v4 = ((int)v2 + 1) % (*((_DWORD *)queue + 4) + 1);
  FigMemoryBarrier();
  *((_DWORD *)queue + 5) = v4;
  FigMemoryBarrier();
  return v3;
}

const void *__cdecl CMSimpleQueueGetHead(CMSimpleQueueRef queue)
{
  if (queue)
  {
    uint64_t v1 = *((int *)queue + 5);
    if (v1 != *((_DWORD *)queue + 6)) {
      return (const void *)*((void *)queue + v1 + 4);
    }
  }
  else
  {
    FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

OSStatus CMSimpleQueueReset(CMSimpleQueueRef queue)
{
  if (!queue) {
    return FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  }
  *((_DWORD *)queue + 5) = 0;
  *((_DWORD *)queue + 6) = 0;
  return 0;
}

int32_t CMSimpleQueueGetCapacity(CMSimpleQueueRef queue)
{
  if (queue) {
    LODWORD(queue) = *((_DWORD *)queue + 4);
  }
  return (int)queue;
}

int32_t CMSimpleQueueGetCount(CMSimpleQueueRef queue)
{
  if (queue)
  {
    CMSimpleQueueRef v1 = queue;
    int v2 = *((_DWORD *)queue + 5);
    int v3 = *((_DWORD *)queue + 6);
    LODWORD(queue) = v3 - v2;
    if (v3 != v2 && v3 <= v2) {
      LODWORD(queue) = queue + *((_DWORD *)v1 + 4) + 1;
    }
  }
  return (int)queue;
}

uint64_t FigSimpleQueueSetQueueIsFullErrorLoggingEnabled(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  }
}

__CFString *simpQCopyDebugDesc(unsigned int *a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFIndex v3 = CFGetRetainCount(a1);
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<CMSimpleQueue %p retainCount: %ld allocator: %p\n", a1, v3, v4);
  uint64_t v5 = a1[4];
  int v6 = a1[5];
  uint64_t v7 = a1[6];
  if ((int)v7 <= v6) {
    LODWORD(v8) = v5 - v6 + v7 + 1;
  }
  else {
    LODWORD(v8) = v7 - v6;
  }
  if (v7 == v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v8;
  }
  CFStringAppendFormat(Mutable, 0, @"\tcapacity = %d\n\tcount = %d\n\treadIndex = %d\n\twriteIndex = %d\n", v5, v8, a1[5], v7);
  CFStringAppend(Mutable, @"\telements[readIndex..(writeIndex-1) %% (capacity+1)] = {\n");
  uint64_t v9 = (int)a1[5];
  if (v9 != a1[6])
  {
    CFStringAppendFormat(Mutable, 0, @"\t\t%p", *(void *)&a1[2 * v9 + 8]);
    for (int i = (int)(a1[5] + 1) % (int)(a1[4] + 1); i != a1[6]; int i = (i + 1) % (int)(a1[4] + 1))
      CFStringAppendFormat(Mutable, 0, @",\n\t\t%p", *(void *)&a1[2 * i + 8]);
  }
  CFStringAppendFormat(Mutable, 0, @"}\n>\n");
  return Mutable;
}

uint64_t FigEndpointStreamStartServer()
{
  v3[0] = 1;
  v3[1] = HandleEndpointStreamRemoteMessage;
  long long v4 = 0u;
  long long v5 = 0u;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetInt32(Mutable, @"xpcServerOption_SelfTerminationTimeout", 30);
  uint64_t v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointstream.xpc", v3, (uint64_t)Mutable, &gEndpointStreamServer);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v1;
}

uint64_t HandleEndpointStreamRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v62 = 0;
  CFIndex v61 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v62);
  if (OpCode) {
    return OpCode;
  }
  uint64_t uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  *(void *)&long long v73 = 0;
  uint64_t v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v73, &v61);
  if (!v8)
  {
    if ((void)v73)
    {
      CFTypeID v9 = CFGetTypeID((CFTypeRef)v73);
      if (v9 == FigEndpointStreamGetTypeID())
      {
        long long v10 = (const void *)v73;
        goto LABEL_6;
      }
    }
    uint64_t v8 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v11 = v8;
  if ((void)v73) {
    CFRelease((CFTypeRef)v73);
  }
  if (!v11)
  {
    long long v10 = 0;
LABEL_6:
    uint64_t v11 = 4294950536;
    if (v62 > 1886611043)
    {
      if (v62 <= 1936875891)
      {
        if (v62 == 1886611044)
        {
          LOBYTE(v71) = 0;
          *(void *)&long long v73 = 0;
          uint64_t v13 = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(*MEMORY[0x1E4F1CF80], a2, "FormatDescription", (uint64_t *)&v73);
          if (!v13)
          {
            uint64_t v40 = v73;
            uint64_t v41 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 24);
            if (v41) {
              uint64_t v42 = v41;
            }
            else {
              uint64_t v42 = 0;
            }
            CFIndex v59 = *(uint64_t (**)(const void *, uint64_t, long long *))(v42 + 32);
            if (v59)
            {
              uint64_t v11 = v59(v10, v40, &v71);
              if (!v11) {
                xpc_dictionary_set_BOOL(a3, "IsPassthroughSupported", (_BYTE)v71 != 0);
              }
LABEL_94:
              CFTypeID v54 = (const void *)v73;
              if (!(void)v73) {
                goto LABEL_96;
              }
              goto LABEL_95;
            }
LABEL_93:
            uint64_t v11 = 4294954514;
            goto LABEL_94;
          }
LABEL_74:
          uint64_t v11 = v13;
          goto LABEL_94;
        }
        if (v62 != 1918985828)
        {
          if (v62 != 1920169325) {
            goto LABEL_96;
          }
          long long v12 = v61;
          *(void *)&long long v73 = 0;
          uint64_t v13 = FigXPCMessageCopyCFDictionary(a2, "Options", &v73);
          if (!v13)
          {
            CompletionCallbackParametersFromMessageAndConnection = CreateCompletionCallbackParametersFromMessageAndConnection(a2, a1);
            uint64_t v15 = v73;
            if (CompletionCallbackParametersFromMessageAndConnection) {
              long long v16 = SuspendResumeCompletionCallback;
            }
            else {
              long long v16 = 0;
            }
            uint64_t v17 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
            if (v17) {
              uint64_t v18 = v17;
            }
            else {
              uint64_t v18 = 0;
            }
            size_t v58 = *(uint64_t (**)(const void *, uint64_t, void (*)(uint64_t, int, uint64_t), void *))(v18 + 16);
            if (v58)
            {
              uint64_t v11 = v58(v10, v15, v16, CompletionCallbackParametersFromMessageAndConnection);
              if (!v11) {
                *long long v12 = 1;
              }
              goto LABEL_94;
            }
            goto LABEL_93;
          }
          goto LABEL_74;
        }
        *(void *)&long long v73 = 0;
        uint64_t CMBaseObject = FigEndpointStreamGetCMBaseObject(v10);
        uint64_t v28 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
        if (v28) {
          uint64_t v29 = v28;
        }
        else {
          uint64_t v29 = 0;
        }
        CMTimeScale v49 = *(uint64_t (**)(uint64_t, __CFString *, void, long long *))(v29 + 48);
        if (v49)
        {
          uint64_t v50 = v49(CMBaseObject, @"RichestAudioFormatDescription", *MEMORY[0x1E4F1CF80], &v73);
          int v51 = (const void *)v73;
          if (!v50)
          {
            uint64_t v52 = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(a3, "RichestFormatDescription", (xpc_object_t)v73);
            goto LABEL_65;
          }
          goto LABEL_105;
        }
        goto LABEL_67;
      }
      if (v62 != 1936875892)
      {
        if (v62 == 1936945252)
        {
          uint64_t v30 = v61;
          *(void *)&long long v73 = 0;
          uint64_t v13 = FigXPCMessageCopyCFDictionary(a2, "Options", &v73);
          if (!v13)
          {
            CFStringRef v31 = CreateCompletionCallbackParametersFromMessageAndConnection(a2, a1);
            *uint64_t v30 = 0;
            uint64_t v32 = v73;
            if (v31) {
              uint64_t v33 = SuspendResumeCompletionCallback;
            }
            else {
              uint64_t v33 = 0;
            }
            uint64_t v34 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
            if (v34) {
              uint64_t v35 = v34;
            }
            else {
              uint64_t v35 = 0;
            }
            int64_t v55 = *(uint64_t (**)(const void *, uint64_t, void (*)(uint64_t, int, uint64_t), void *))(v35 + 8);
            if (!v55) {
              goto LABEL_93;
            }
            uint64_t v13 = v55(v10, v32, v33, v31);
          }
          goto LABEL_74;
        }
        if (v62 != 1937072484) {
          goto LABEL_96;
        }
        *(void *)&long long v73 = 0;
        uint64_t v23 = FigEndpointStreamGetCMBaseObject(v10);
        uint64_t v24 = *(void *)(CMBaseObjectGetVTable(v23) + 8);
        if (v24) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = 0;
        }
        long long v53 = *(uint64_t (**)(uint64_t, __CFString *, void, long long *))(v25 + 48);
        if (v53)
        {
          uint64_t v50 = v53(v23, @"SupportedAudioFormatDescriptions", *MEMORY[0x1E4F1CF80], &v73);
          int v51 = (const void *)v73;
          if (!v50)
          {
            uint64_t v52 = FigXPCMessageSetFigEndpointStreamAudioFormatDescriptionArray(a3, "FormatDescriptionArray", (const __CFArray *)v73);
LABEL_65:
            uint64_t v11 = v52;
            int v51 = (const void *)v73;
            if (!(void)v73) {
              goto LABEL_96;
            }
LABEL_66:
            CFTypeID v54 = v51;
LABEL_95:
            CFRelease(v54);
            goto LABEL_96;
          }
LABEL_105:
          uint64_t v11 = v50;
          if (!v51)
          {
LABEL_96:
            if (v10) {
              CFRelease(v10);
            }
            return v11;
          }
          goto LABEL_66;
        }
LABEL_67:
        uint64_t v11 = 4294954514;
        goto LABEL_96;
      }
      CMTime v43 = v61;
      long long v69 = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v70 = 0;
      long long v67 = *(_OWORD *)&kCMTimeInvalid.value;
      uint64_t v68 = 0;
      double v44 = xpc_dictionary_get_double(a2, "Rate");
      uint64_t CMTime = FigXPCMessageGetCMTime(a2, "SampleTime", (uint64_t)&v69);
      if (!CMTime)
      {
        uint64_t CMTime = FigXPCMessageGetCMTime(a2, "HostTime", (uint64_t)&v67);
        if (!CMTime)
        {
          __n128 v45 = CreateCompletionCallbackParametersFromMessageAndConnection(a2, a1);
          unsigned char *v43 = 0;
          if (v45) {
            size_t v46 = SetRateAndAnchorTimeCallback;
          }
          else {
            size_t v46 = 0;
          }
          long long v65 = v69;
          uint64_t v66 = v70;
          long long v63 = v67;
          uint64_t v64 = v68;
          uint64_t v47 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 24);
          if (!v47) {
            goto LABEL_67;
          }
          CMTimeValue v48 = *(uint64_t (**)(const void *, long long *, long long *, void (*)(double, uint64_t, int, long long *, long long *, uint64_t), void *, double))(v47 + 16);
          if (!v48) {
            goto LABEL_67;
          }
          long long v73 = v65;
          uint64_t v74 = v66;
          long long v71 = v63;
          uint64_t v72 = v64;
          uint64_t CMTime = v48(v10, &v73, &v71, v46, v45, v44);
        }
      }
LABEL_34:
      uint64_t v11 = CMTime;
      goto LABEL_96;
    }
    if (v62 <= 1668572771)
    {
      if (v62 == 778268793)
      {
        uint64_t CMTime = FigXPCHandleStdCopyPropertyMessage((uint64_t)v10, a2, a3);
      }
      else
      {
        if (v62 != 779314548) {
          goto LABEL_96;
        }
        uint64_t CMTime = FigXPCHandleStdSetPropertyMessage((uint64_t)v10, a2);
      }
      goto LABEL_34;
    }
    if (v62 != 1668572772)
    {
      if (v62 != 1685024621)
      {
        if (v62 != 1718383987) {
          goto LABEL_96;
        }
        *(void *)&long long v73 = 0;
        uint64_t v13 = FigXPCMessageCopyCFDictionary(a2, "Options", &v73);
        if (!v13)
        {
          uint64_t v19 = xpc_dictionary_get_uint64(a2, "FlushFlags");
          uint64_t v20 = v73;
          uint64_t v21 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 16);
          if (v21) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = 0;
          }
          long long v56 = *(uint64_t (**)(const void *, uint64_t, uint64_t))(v22 + 24);
          if (!v56) {
            goto LABEL_93;
          }
          uint64_t v13 = v56(v10, v19, v20);
        }
        goto LABEL_74;
      }
      uint64_t CMTime = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
      goto LABEL_34;
    }
    *(void *)&long long v73 = 0;
    *(void *)&long long v71 = 0;
    uint64_t v36 = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(*MEMORY[0x1E4F1CF80], a2, "FormatDescription", (uint64_t *)&v73);
    if (!v36)
    {
      uint64_t v37 = v73;
      uint64_t v38 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 24);
      if (v38) {
        uint64_t v39 = v38;
      }
      else {
        uint64_t v39 = 0;
      }
      uint64_t v57 = *(uint64_t (**)(const void *, uint64_t, long long *))(v39 + 24);
      if (!v57)
      {
        uint64_t v11 = 4294954514;
LABEL_81:
        if ((void)v73) {
          CFRelease((CFTypeRef)v73);
        }
        CFTypeID v54 = (const void *)v71;
        if (!(void)v71) {
          goto LABEL_96;
        }
        goto LABEL_95;
      }
      uint64_t v36 = v57(v10, v37, &v71);
      if (!v36) {
        uint64_t v36 = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(a3, "FormatDescription", (xpc_object_t)v71);
      }
    }
    uint64_t v11 = v36;
    goto LABEL_81;
  }
  return v11;
}

uint64_t FigXPCEndpointStreamServerAssociateNeighborFigEndpointStream(_xpc_connection_s *a1, CFTypeRef cf, void *a3)
{
  uint64_t v11 = 0;
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != FigEndpointStreamGetTypeID())
  {
    uint64_t v9 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
    uint64_t v8 = 0;
    if (!v9) {
      return v9;
    }
    goto LABEL_4;
  }
  uint64_t v7 = CreateEndpointStreamServerState(cf, &v11);
  uint64_t v8 = v11;
  if (v7)
  {
    uint64_t v9 = v7;
    goto LABEL_4;
  }
  uint64_t v9 = FigXPCServerAssociateObjectWithNeighborProcess(gEndpointStreamServer, a1, cf, (uint64_t)v11, (uint64_t)DisposeEndpointStreamServerState, 0, a3);
  if (v9) {
LABEL_4:
  }
    DisposeEndpointStreamServerState(v8);
  return v9;
}

uint64_t CreateEndpointStreamServerState(const void *a1, void *a2)
{
  long long v4 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040984C81BBuLL);
  if (v4)
  {
    if (a1) {
      CFTypeRef v5 = CFRetain(a1);
    }
    else {
      CFTypeRef v5 = 0;
    }
    uint64_t result = 0;
    v4[2] = v5;
  }
  else
  {
    uint64_t result = FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
  }
  *a2 = v4;
  return result;
}

void DisposeEndpointStreamServerState(void *a1)
{
  if (a1)
  {
    int v2 = (const void *)a1[1];
    if (v2)
    {
      CFRelease(v2);
      a1[1] = 0;
    }
    CFIndex v3 = (const void *)a1[2];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

uint64_t FigXPCEndpointStreamServerAssociateCopiedNeighborFigEndpointStream(_xpc_connection_s *a1, CFTypeRef cf, void *a3)
{
  uint64_t v11 = 0;
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != FigEndpointStreamGetTypeID())
  {
    uint64_t v9 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
    uint64_t v8 = 0;
    if (!v9) {
      return v9;
    }
    goto LABEL_4;
  }
  uint64_t v7 = CreateEndpointStreamServerState(cf, &v11);
  uint64_t v8 = v11;
  if (v7)
  {
    uint64_t v9 = v7;
    goto LABEL_4;
  }
  uint64_t v9 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointStreamServer, a1, cf, (uint64_t)v11, (uint64_t)DisposeEndpointStreamServerState, 0, a3);
  if (v9) {
LABEL_4:
  }
    DisposeEndpointStreamServerState(v8);
  return v9;
}

uint64_t FigXPCEndpointStreamServerAssociateCopiedEndpointStreamWithNeighborProcessByPID(int a1, CFTypeRef cf, void *a3)
{
  uint64_t v11 = 0;
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != FigEndpointStreamGetTypeID())
  {
    uint64_t v9 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
    uint64_t v8 = 0;
    if (!v9) {
      return v9;
    }
    goto LABEL_4;
  }
  uint64_t v7 = CreateEndpointStreamServerState(cf, &v11);
  uint64_t v8 = v11;
  if (v7)
  {
    uint64_t v9 = v7;
    goto LABEL_4;
  }
  uint64_t v9 = FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(gEndpointStreamServer, a1, cf, (uint64_t)v11, (uint64_t)DisposeEndpointStreamServerState, 0, a3);
  if (v9) {
LABEL_4:
  }
    DisposeEndpointStreamServerState(v8);
  return v9;
}

uint64_t FigXPCEndpointStreamServerRetainEndpointStreamForID(void *a1, void *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gEndpointStreamServer, a1, a2);
}

void *CreateCompletionCallbackParametersFromMessageAndConnection(void *a1, void *a2)
{
  uint64_t uint64 = xpc_dictionary_get_uint64(a1, "CompletionID");
  if (!uint64) {
    return 0;
  }
  uint64_t v5 = uint64;
  CFTypeID v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *CFTypeID v6 = v5;
    v6[1] = xpc_dictionary_get_uint64(a1, ".objectID");
    v7[2] = FigXPCRetain(a2);
  }
  else
  {
    FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
  }
  return v7;
}

void SuspendResumeCompletionCallback(uint64_t a1, int a2, uint64_t a3)
{
  xpc_object_t xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void DestroyCompletionCallbackParameters(xpc_object_t *a1)
{
  if (a1)
  {
    FigXPCRelease(a1[2]);
    free(a1);
  }
}

void SetRateAndAnchorTimeCallback(double a1, uint64_t a2, int a3, long long *a4, long long *a5, uint64_t a6)
{
  xpc_object_t xdict = 0;
  if (a6 && !FigXPCCreateBasicMessage(0x63616C62u, *(void *)(a6 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(void *)a6);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    xpc_dictionary_set_double(xdict, "Rate", a1);
    long long v11 = *a4;
    uint64_t v12 = *((void *)a4 + 2);
    FigXPCMessageSetCMTime(xdict, "SampleTime", &v11);
    long long v11 = *a5;
    uint64_t v12 = *((void *)a5 + 2);
    FigXPCMessageSetCMTime(xdict, "HostTime", &v11);
    xpc_connection_send_message(*(xpc_connection_t *)(a6 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a6);
  FigXPCRelease(xdict);
}

uint64_t FigEndpointPlaybackSessionGetClassID()
{
  if (FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce, &FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID, (dispatch_function_t)playbackSession_getClassID);
  }
  return FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID;
}

uint64_t playbackSession_getClassID(void *a1)
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&playbackSession_getClassID_sFigEndpointPlaybackSessionClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointPlaybackSessionGetTypeID()
{
  if (FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce, &FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID, (dispatch_function_t)playbackSession_getClassID);
  }
  CFAllocatorRef v0 = (void *)FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef playbackSession_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointPlaybackSession %p]", a1);
}

uint64_t FigCreatePathForPersistentURL(void *a1, uint64_t a2)
{
  if (sPUTFunctionsLoadedOnce != -1) {
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  }
  if (figPersistentURLIsMediaLibraryURL(a1))
  {
    if (!figPersistentURLCanTranslateUsingMPMediaLibrary()) {
      return 0;
    }
    long long v4 = (void *)MEMORY[0x192FC5D30]();
    uint64_t v5 = (const void *)objc_msgSend((id)objc_msgSend((id)getMPMediaLibraryClass(), "defaultMediaLibrary"), "pathForAssetURL:", a1);
    CFTypeID v6 = v5;
    if (v5) {
      CFRetain(v5);
    }
    return (uint64_t)v6;
  }
  else
  {
    uint64_t v7 = (uint64_t (*)(void *, uint64_t))sPUTCreatePathForPersistentURL;
    return v7(a1, a2);
  }
}

void *LoadPUTFunctions()
{
  CFAllocatorRef v0 = dlopen("/System/Library/PrivateFrameworks/PhotoLibraryServicesCore.framework/PhotoLibraryServicesCore", 4);
  if (v0)
  {
    uint64_t v1 = v0;
    sPUTCreatePathForPersistentURL = dlsym(v0, "PUTCreatePathForPersistentURL");
    sPUTCreateSandboxExtensionURLForPersistentURL = dlsym(v1, "PUTCreateSandboxExtensionURLForPersistentURL");
    sPUTIsPersistentURL = dlsym(v1, "PUTIsPersistentURL");
    uint64_t result = dlsym(v1, "PUTGetCurrentAccessForURLAndToken");
    sPUTGetCurrentAccessForURLAndToken = result;
  }
  else
  {
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t figPersistentURLIsMediaLibraryURL(void *a1)
{
  int v2 = (void *)MEMORY[0x192FC5D30]();
  if ([MEMORY[0x1E4F1CB10] instancesRespondToSelector:sel_msv_isValidMediaAssetURL]) {
    uint64_t v3 = objc_msgSend(a1, "msv_isValidMediaAssetURL");
  }
  else {
    uint64_t v3 = 0;
  }
  return v3;
}

uint64_t FigCreateSecurityScopedFileURLForPersistentURL(void *a1)
{
  if (sPUTFunctionsLoadedOnce != -1) {
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  }
  if (figPersistentURLIsMediaLibraryURL(a1))
  {
    if (!figPersistentURLCanTranslateUsingMPMediaLibrary()) {
      return 0;
    }
    int v2 = (void *)MEMORY[0x192FC5D30]();
    uint64_t v3 = (const void *)objc_msgSend((id)objc_msgSend((id)getMPMediaLibraryClass(), "defaultMediaLibrary"), "securityScopedFileURLForAssetURL:", a1);
    long long v4 = v3;
    if (v3) {
      CFRetain(v3);
    }
    return (uint64_t)v4;
  }
  else
  {
    uint64_t v5 = (uint64_t (*)(void *))sPUTCreateSandboxExtensionURLForPersistentURL;
    return v5(a1);
  }
}

uint64_t FigIsPersistentURL(const __CFURL *a1)
{
  CFStringRef v2 = CFURLCopyScheme(a1);
  if (!v2) {
    goto LABEL_5;
  }
  CFStringRef v3 = v2;
  if (CFStringCompare(v2, @"file", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v3, @"http", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v3);
    return 0;
  }
  CFComparisonResult v4 = CFStringCompare(v3, @"https", 1uLL);
  CFRelease(v3);
  if (v4 == kCFCompareEqualTo) {
    return 0;
  }
LABEL_5:
  if (sPUTFunctionsLoadedOnce != -1) {
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  }
  if (sPUTIsPersistentURL(a1)) {
    return 1;
  }
  uint64_t result = figPersistentURLIsMediaLibraryURL(a1);
  if (result) {
    return 1;
  }
  return result;
}

BOOL FigMayAccessPersistentURLOnBehalfOfClientWithAuditToken(void *a1, _OWORD *a2)
{
  if (sPUTFunctionsLoadedOnce != -1) {
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  }
  if (figPersistentURLIsMediaLibraryURL(a1)) {
    return 1;
  }
  long long v5 = a2[1];
  v6[0] = *a2;
  v6[1] = v5;
  return sPUTGetCurrentAccessForURLAndToken(a1, v6) == 2;
}

uint64_t figPersistentURLCanTranslateUsingMPMediaLibrary()
{
  uint64_t result = [MEMORY[0x1E4F1CB10] instancesRespondToSelector:sel_msv_isValidMediaAssetURL];
  if (result) {
    return MediaPlayerLibraryCore() != 0;
  }
  return result;
}

uint64_t getMPMediaLibraryClass()
{
  uint64_t v2 = 0;
  CFStringRef v3 = &v2;
  uint64_t v4 = 0x3052000000;
  long long v5 = __Block_byref_object_copy_;
  CFTypeID v6 = __Block_byref_object_dispose_;
  uint64_t v0 = getMPMediaLibraryClass_softClass;
  uint64_t v7 = getMPMediaLibraryClass_softClass;
  if (!getMPMediaLibraryClass_softClass)
  {
    MediaPlayerLibraryCore();
    v3[5] = (uint64_t)objc_getClass("MPMediaLibrary");
    getMPMediaLibraryClass_softClass = v3[5];
    uint64_t v0 = v3[5];
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_18FD5A194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t MediaPlayerLibraryCore()
{
  if (!MediaPlayerLibraryCore_frameworkLibrary) {
    MediaPlayerLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  return MediaPlayerLibraryCore_frameworkLibrary;
}

uint64_t __MediaPlayerLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  MediaPlayerLibraryCore_frameworkLibrary = result;
  return result;
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

Class __getMPMediaLibraryClass_block_invoke(uint64_t a1)
{
  MediaPlayerLibraryCore();
  Class result = objc_getClass("MPMediaLibrary");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = result;
  getMPMediaLibraryClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

double FigGeometryDimensionMakeMirrored(uint64_t a1, int a2)
{
  double result = -*(double *)&a1;
  if (a2 == 622862368) {
    return 100.0 - *(double *)&a1;
  }
  return result;
}

uint64_t FigGeometryPointMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

uint64_t FigGeometrySizeMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

uint64_t FigGeometryVectorMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

uint64_t FigGeometryRectMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, void *a9@<X8>)
{
  *a9 = result;
  a9[1] = a2;
  a9[2] = a3;
  a9[3] = a4;
  a9[4] = a5;
  a9[5] = a6;
  a9[6] = a7;
  a9[7] = a8;
  return result;
}

uint64_t FigGeometryDimensionMakeZeroedDimension()
{
  return 0;
}

uint64_t FigGeometryPointMakeZeroedPoint@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(unsigned int *)(result + 8) | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  uint64_t v3 = *(unsigned int *)(result + 24) | 0x100000000;
  a2[2] = 0;
  a2[3] = v3;
  return result;
}

uint64_t FigGeometrySizeMakeZeroedSize@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(unsigned int *)(result + 8) | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  uint64_t v3 = *(unsigned int *)(result + 24) | 0x100000000;
  a2[2] = 0;
  a2[3] = v3;
  return result;
}

uint64_t FigGeometryVectorMakeZeroedVector@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(unsigned int *)(result + 8) | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  uint64_t v3 = *(unsigned int *)(result + 24) | 0x100000000;
  a2[2] = 0;
  a2[3] = v3;
  return result;
}

unsigned int *FigGeometryRectMakeZeroedRect@<X0>(unsigned int *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[2] | 0x100000000;
  uint64_t v3 = result[6] | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  a2[2] = 0;
  a2[3] = v3;
  uint64_t v4 = result[10] | 0x100000000;
  uint64_t v5 = result[14] | 0x100000000;
  a2[4] = 0;
  a2[5] = v4;
  a2[6] = 0;
  a2[7] = v5;
  return result;
}

__n128 FigGeometryPointMakeFromPointAndReferenceUnits@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

__n128 FigGeometrySizeMakeFromSizeAndReferenceUnits@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

__n128 FigGeometryVectorMakeFromVectorAndReferenceUnits@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

double FigGeometryRectMakeFromRectAndReferenceUnits@<D0>(uint64_t *a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *a1;
  *(void *)(a3 + 12) = *(uint64_t *)((char *)a1 + 12);
  int v4 = *((_DWORD *)a1 + 5);
  int v5 = *((_DWORD *)a1 + 7);
  *(_DWORD *)(a3 + 8) = a2[2];
  int v6 = a2[6];
  *(void *)a3 = v3;
  *(_DWORD *)(a3 + 2CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v4;
  *(_DWORD *)(a3 + 24) = v6;
  *(_DWORD *)(a3 + 28) = v5;
  double result = *((double *)a1 + 4);
  int v8 = *((_DWORD *)a1 + 13);
  *(void *)(a3 + 44) = *(uint64_t *)((char *)a1 + 44);
  int v9 = *((_DWORD *)a1 + 15);
  int v10 = a2[10];
  int v11 = a2[14];
  *(double *)(a3 + 32) = result;
  *(_DWORD *)(a3 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v10;
  *(_DWORD *)(a3 + 52) = v8;
  *(_DWORD *)(a3 + 56) = v11;
  *(_DWORD *)(a3 + 6CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v9;
  return result;
}

BOOL FigGeometryDimensionEqualToDimension(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v5 = *(double *)&a1 == *(double *)&a3 && a2 == a4;
  return HIDWORD(a2) == HIDWORD(a4) && v5;
}

BOOL FigGeometryPointEqualToPoint(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3)) {
    return 0;
  }
  if (v2 != v3 || *(double *)a1 != *(double *)a2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6)) {
    return 0;
  }
  return *(double *)(a1 + 16) == *(double *)(a2 + 16) && v5 == v6;
}

BOOL FigGeometrySizeEqualToSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3)) {
    return 0;
  }
  if (v2 != v3 || *(double *)a1 != *(double *)a2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6)) {
    return 0;
  }
  return *(double *)(a1 + 16) == *(double *)(a2 + 16) && v5 == v6;
}

BOOL FigGeometryVectorEqualToVector(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3)) {
    return 0;
  }
  if (v2 != v3 || *(double *)a1 != *(double *)a2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6)) {
    return 0;
  }
  return *(double *)(a1 + 16) == *(double *)(a2 + 16) && v5 == v6;
}

BOOL FigGeometryRectEqualToRect(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3)) {
    return 0;
  }
  if (v2 != v3 || *(double *)a1 != *(double *)a2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6)) {
    return 0;
  }
  if (v5 != v6 || *(double *)(a1 + 16) != *(double *)(a2 + 16)) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a2 + 40);
  if (HIDWORD(v8) != HIDWORD(v9)) {
    return 0;
  }
  uint64_t v10 = 0;
  if (v8 != v9 || *(double *)(a1 + 32) != *(double *)(a2 + 32)) {
    return v10;
  }
  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v12 = *(void *)(a2 + 56);
  if (HIDWORD(v11) != HIDWORD(v12)) {
    return 0;
  }
  return *(double *)(a1 + 48) == *(double *)(a2 + 48) && v11 == v12;
}

__CFString *FigGeometryDimensionCopyDescription(const __CFAllocator *a1, uint64_t a2, unint64_t a3)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(a1, 0);
  uint64_t v6 = Mutable;
  if (Mutable)
  {
    if ((a3 & 0x100000000) != 0)
    {
      if ((a3 & 0x1000000000) != 0)
      {
        uint64_t v9 = 0;
        uint64_t v10 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v9] != a3)
        {
          v9 += 4;
          if (v9 == 52) {
            goto LABEL_17;
          }
        }
        uint64_t v10 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v9 + 2];
LABEL_17:
        CFStringAppendFormat(Mutable, 0, @"{INDEFINITE}%s", v10);
      }
      else if ((a3 & 0x400000000) != 0)
      {
        uint64_t v11 = 0;
        uint64_t v12 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v11] != a3)
        {
          v11 += 4;
          if (v11 == 52) {
            goto LABEL_23;
          }
        }
        uint64_t v12 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v11 + 2];
LABEL_23:
        CFStringAppendFormat(Mutable, 0, @"{+INFINITY}%s", v12);
      }
      else if ((a3 & 0x800000000) != 0)
      {
        uint64_t v13 = 0;
        long long v14 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v13] != a3)
        {
          v13 += 4;
          if (v13 == 52) {
            goto LABEL_29;
          }
        }
        long long v14 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v13 + 2];
LABEL_29:
        CFStringAppendFormat(Mutable, 0, @"{-INFINITY}%s", v14);
      }
      else if ((BYTE4(a3) & 0x1D) == 1)
      {
        uint64_t v7 = 0;
        uint64_t v8 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v7] != a3)
        {
          v7 += 4;
          if (v7 == 52) {
            goto LABEL_35;
          }
        }
        uint64_t v8 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v7 + 2];
LABEL_35:
        CFStringAppendFormat(Mutable, 0, @"%0.2f%s", a2, v8);
        if ((a3 & 0x200000000) != 0) {
          CFStringAppendFormat(v6, 0, @"<rounded>");
        }
        if ((a3 & 0x2000000000) != 0) {
          CFStringAppendFormat(v6, 0, @"<reversed>");
        }
        if ((a3 & 0xFFFFFFDC00000000) != 0) {
          CFStringAppendFormat(v6, 0, @"<flags=0x%08x>", HIDWORD(a3));
        }
      }
      else
      {
        uint64_t v15 = 0;
        long long v16 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v15] != a3)
        {
          v15 += 4;
          if (v15 == 52) {
            goto LABEL_42;
          }
        }
        long long v16 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v15 + 2];
LABEL_42:
        CFStringAppendFormat(Mutable, 0, @"{UNKNOWN}%s", v16);
      }
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, @"{INVALID}");
    }
  }
  return v6;
}

__CFString *FigGeometryPointCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(a1, 0);
  uint64_t v5 = FigGeometryDimensionCopyDescription(a1, *(void *)a2, *(void *)(a2 + 8));
  uint64_t v6 = FigGeometryDimensionCopyDescription(a1, *(void *)(a2 + 16), *(void *)(a2 + 24));
  uint64_t v7 = v6;
  if (!Mutable || (v5 ? (BOOL v8 = v6 == 0) : (BOOL v8 = 1), v8))
  {
    if (!v5) {
      goto LABEL_9;
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"(%@, %@)", v5, v6);
  }
  CFRelease(v5);
LABEL_9:
  if (v7) {
    CFRelease(v7);
  }
  return Mutable;
}

__CFString *FigGeometrySizeCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(a1, 0);
  uint64_t v5 = FigGeometryDimensionCopyDescription(a1, *(void *)a2, *(void *)(a2 + 8));
  uint64_t v6 = FigGeometryDimensionCopyDescription(a1, *(void *)(a2 + 16), *(void *)(a2 + 24));
  uint64_t v7 = v6;
  if (!Mutable || (v5 ? (BOOL v8 = v6 == 0) : (BOOL v8 = 1), v8))
  {
    if (!v5) {
      goto LABEL_9;
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"(%@, %@)", v5, v6);
  }
  CFRelease(v5);
LABEL_9:
  if (v7) {
    CFRelease(v7);
  }
  return Mutable;
}

__CFString *FigGeometryVectorCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(a1, 0);
  uint64_t v5 = FigGeometryDimensionCopyDescription(a1, *(void *)a2, *(void *)(a2 + 8));
  uint64_t v6 = FigGeometryDimensionCopyDescription(a1, *(void *)(a2 + 16), *(void *)(a2 + 24));
  uint64_t v7 = v6;
  if (!Mutable || (v5 ? (BOOL v8 = v6 == 0) : (BOOL v8 = 1), v8))
  {
    if (!v5) {
      goto LABEL_9;
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"<%@, %@>", v5, v6);
  }
  CFRelease(v5);
LABEL_9:
  if (v7) {
    CFRelease(v7);
  }
  return Mutable;
}

__CFString *FigGeometryRectCopyDescription(const __CFAllocator *a1, long long *a2)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(a1, 0);
  long long v5 = a2[1];
  long long v11 = *a2;
  long long v12 = v5;
  uint64_t v6 = FigGeometryPointCopyDescription(a1, (uint64_t)&v11);
  long long v7 = a2[3];
  long long v11 = a2[2];
  long long v12 = v7;
  BOOL v8 = FigGeometrySizeCopyDescription(a1, (uint64_t)&v11);
  uint64_t v9 = v8;
  if (Mutable && v6 && v8)
  {
    CFStringAppendFormat(Mutable, 0, @"{origin:%@, size:%@}", v6, v8);
  }
  else if (!v6)
  {
    goto LABEL_7;
  }
  CFRelease(v6);
LABEL_7:
  if (v9) {
    CFRelease(v9);
  }
  return Mutable;
}

double FigGeometryDimensionGetCGFloat(uint64_t a1)
{
  return *(double *)&a1;
}

double FigGeometryPointGetCGPoint(uint64_t a1)
{
  return *(double *)a1;
}

double FigGeometrySizeGetCGSize(uint64_t a1)
{
  return *(double *)a1;
}

double FigGeometryVectorGetCGVector(uint64_t a1)
{
  return *(double *)a1;
}

double FigGeometryRectGetCGRect(uint64_t a1)
{
  return *(double *)a1;
}

_OWORD *FigGeometryPointMakeFromCGPointAndReferenceUnits@<X0>(_OWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = *result;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)result + 12);
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 28) = 1;
  return result;
}

_OWORD *FigGeometrySizeMakeFromCGSizeAndReferenceUnits@<X0>(_OWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = *result;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)result + 12);
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 28) = 1;
  return result;
}

_OWORD *FigGeometryVectorMakeFromCGVectorAndReferenceUnits@<X0>(_OWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = *result;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)result + 12);
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 28) = 1;
  return result;
}

_DWORD *FigGeometryRectMakeFromCGRectAndReferenceUnits@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  int v6 = result[2];
  int v7 = result[6];
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 8) = v6;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 24) = v7;
  *(_DWORD *)(a2 + 28) = 1;
  int v8 = result[10];
  int v9 = result[14];
  *(double *)(a2 + 32) = a5;
  *(_DWORD *)(a2 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v8;
  *(_DWORD *)(a2 + 44) = 1;
  *(double *)(a2 + 48) = a6;
  *(_DWORD *)(a2 + 56) = v9;
  *(_DWORD *)(a2 + 6CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
  return result;
}

CFDictionaryRef FigGeometryDimensionCopyAsDictionary(uint64_t a1, uint64_t a2, const __CFAllocator *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a1;
  uint64_t v10 = a2;
  *(_OWORD *)keys = xmmword_1E5677898;
  uint64_t v13 = @"flags";
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCGFloatType, &valuePtr);
  values[1] = CFNumberCreate(v4, kCFNumberSInt32Type, &v10);
  values[2] = CFNumberCreate(v4, kCFNumberSInt32Type, (char *)&v10 + 4);
  CFDictionaryRef v5 = CFDictionaryCreate(a3, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = 0; i != 3; ++i)
  {
    int v7 = values[i];
    if (v7) {
      CFRelease(v7);
    }
  }
  return v5;
}

const void *FigGeometryDimensionMakeFromDictionary(const void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFDictionaryGetTypeID()
      && (v3 = 0, uint64_t v4 = 0, FigCFDictionaryGetCGFloatIfPresent(v1, @"value", &v4))
      && FigCFDictionaryGetInt32IfPresent(v1, @"units", (char *)&v3 + 4)
      && FigCFDictionaryGetInt32IfPresent(v1, @"flags", &v3))
    {
      return (const void *)v4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFDictionaryRef FigGeometryPointCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  CFDictionaryRef v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  CFDictionaryRef v6 = v5;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E56778B0;
    v11[0] = v4;
    v11[1] = v5;
    CFDictionaryRef v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_10;
  }
  CFDictionaryRef v10 = 0;
  CFDictionaryRef v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    CFDictionaryRef v8 = v10;
    if (!v6) {
      return v8;
    }
    goto LABEL_8;
  }
  if (v5) {
LABEL_8:
  }
    CFRelease(v6);
  return v8;
}

CFTypeID FigGeometryPointMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  CFTypeRef cf = 0;
  int value = 0;
  if (result)
  {
    CFDictionaryRef v2 = (const __CFDictionary *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    double result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      double result = CFDictionaryGetValueIfPresent(v2, @"x", (const void **)&value);
      if (result)
      {
        double result = CFDictionaryGetValueIfPresent(v2, @"y", &cf);
        if (result)
        {
          double result = (CFTypeID)value;
          if (value)
          {
            CFTypeID v5 = CFGetTypeID(value);
            double result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              double result = (CFTypeID)cf;
              if (cf)
              {
                CFTypeID v6 = CFGetTypeID(cf);
                double result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  BOOL v7 = FigGeometryDimensionMakeFromDictionary(value);
                  uint64_t v9 = v8;
                  double result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(cf);
                  *(void *)a2 = v7;
                  *(void *)(a2 + 8) = v9;
                  *(void *)(a2 + 16) = result;
                  *(void *)(a2 + 24) = v10;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigGeometrySizeCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  CFDictionaryRef v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  CFDictionaryRef v6 = v5;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E56778C0;
    v11[0] = v4;
    v11[1] = v5;
    CFDictionaryRef v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_10;
  }
  CFDictionaryRef v10 = 0;
  CFDictionaryRef v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    CFDictionaryRef v8 = v10;
    if (!v6) {
      return v8;
    }
    goto LABEL_8;
  }
  if (v5) {
LABEL_8:
  }
    CFRelease(v6);
  return v8;
}

CFTypeID FigGeometrySizeMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  CFTypeRef cf = 0;
  int value = 0;
  if (result)
  {
    CFDictionaryRef v2 = (const __CFDictionary *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    double result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      double result = CFDictionaryGetValueIfPresent(v2, @"width", (const void **)&value);
      if (result)
      {
        double result = CFDictionaryGetValueIfPresent(v2, @"height", &cf);
        if (result)
        {
          double result = (CFTypeID)value;
          if (value)
          {
            CFTypeID v5 = CFGetTypeID(value);
            double result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              double result = (CFTypeID)cf;
              if (cf)
              {
                CFTypeID v6 = CFGetTypeID(cf);
                double result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  BOOL v7 = FigGeometryDimensionMakeFromDictionary(value);
                  uint64_t v9 = v8;
                  double result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(cf);
                  *(void *)a2 = v7;
                  *(void *)(a2 + 8) = v9;
                  *(void *)(a2 + 16) = result;
                  *(void *)(a2 + 24) = v10;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigGeometryVectorCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  CFDictionaryRef v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  CFDictionaryRef v6 = v5;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E56778D0;
    v11[0] = v4;
    v11[1] = v5;
    CFDictionaryRef v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_10;
  }
  CFDictionaryRef v10 = 0;
  CFDictionaryRef v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    CFDictionaryRef v8 = v10;
    if (!v6) {
      return v8;
    }
    goto LABEL_8;
  }
  if (v5) {
LABEL_8:
  }
    CFRelease(v6);
  return v8;
}

CFTypeID FigGeometryVectorMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  CFTypeRef cf = 0;
  int value = 0;
  if (result)
  {
    CFDictionaryRef v2 = (const __CFDictionary *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    double result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      double result = CFDictionaryGetValueIfPresent(v2, @"dx", (const void **)&value);
      if (result)
      {
        double result = CFDictionaryGetValueIfPresent(v2, @"dy", &cf);
        if (result)
        {
          double result = (CFTypeID)value;
          if (value)
          {
            CFTypeID v5 = CFGetTypeID(value);
            double result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              double result = (CFTypeID)cf;
              if (cf)
              {
                CFTypeID v6 = CFGetTypeID(cf);
                double result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  BOOL v7 = FigGeometryDimensionMakeFromDictionary(value);
                  uint64_t v9 = v8;
                  double result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(cf);
                  *(void *)a2 = v7;
                  *(void *)(a2 + 8) = v9;
                  *(void *)(a2 + 16) = result;
                  *(void *)(a2 + 24) = v10;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigGeometryRectCopyAsDictionary(_OWORD *a1, const __CFAllocator *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v4 = a1[1];
  *(_OWORD *)keys = *a1;
  long long v14 = v4;
  CFDictionaryRef v5 = FigGeometryPointCopyAsDictionary((uint64_t *)keys, a2);
  long long v6 = a1[3];
  *(_OWORD *)keys = a1[2];
  long long v14 = v6;
  CFDictionaryRef v7 = FigGeometrySizeCopyAsDictionary((uint64_t *)keys, a2);
  CFDictionaryRef v8 = v7;
  if (v5 && v7)
  {
    *(_OWORD *)keys = xmmword_1E56778E0;
    v12[0] = v5;
    v12[1] = v7;
    CFDictionaryRef v9 = CFDictionaryCreate(a2, (const void **)keys, v12, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v9 = 0;
    CFDictionaryRef v10 = 0;
    if (!v5) {
      goto LABEL_6;
    }
  }
  CFRelease(v5);
  CFDictionaryRef v10 = v9;
LABEL_6:
  if (v8) {
    CFRelease(v8);
  }
  return v10;
}

double FigGeometryRectMakeFromDictionary@<D0>(const void *a1@<X0>, _OWORD *a2@<X8>)
{
  double result = 0.0;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  long long v12 = 0;
  int value = 0;
  if (a1)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFDictionaryGetTypeID())
    {
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, @"origin", (const void **)&value))
      {
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, @"size", (const void **)&v12))
        {
          if (value)
          {
            CFTypeID v6 = CFGetTypeID(value);
            if (v6 == CFDictionaryGetTypeID())
            {
              if (v12)
              {
                CFTypeID v7 = CFGetTypeID(v12);
                if (v7 == CFDictionaryGetTypeID())
                {
                  FigGeometryPointMakeFromDictionary((CFTypeID)value, (uint64_t)v11);
                  FigGeometrySizeMakeFromDictionary((CFTypeID)v12, (uint64_t)v10);
                  long long v8 = v11[1];
                  *a2 = v11[0];
                  a2[1] = v8;
                  double result = *(double *)v10;
                  long long v9 = v10[1];
                  a2[2] = v10[0];
                  a2[3] = v9;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FigXPCMessageSetFigEndpointStreamAudioFormatDescription(void *a1, const char *a2, xpc_object_t a3)
{
  xpc_object_t value = 0;
  if (a1 && a2)
  {
    if (a3)
    {
      uint64_t v5 = _FigEndpointStreamAudioFormatDescriptionCopyXPCObject((uint64_t)a3, &value);
      a3 = value;
      if (!v5)
      {
        xpc_dictionary_set_value(a1, a2, value);
        a3 = value;
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    a3 = 0;
  }
  FigXPCRelease(a3);
  return v5;
}

uint64_t _FigEndpointStreamAudioFormatDescriptionCopyXPCObject(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    uint64_t ASBD = FigEndpointStreamAudioFormatDescriptionGetASBD(a1);
    uint64_t v5 = *(void *)(ASBD + 32);
    long long v6 = *(_OWORD *)(ASBD + 16);
    v9[0] = *(_OWORD *)ASBD;
    v9[1] = v6;
    uint64_t v10 = v5;
    int ChannelLayoutTag = FigEndpointStreamAudioFormatDescriptionGetChannelLayoutTag(a1);
    xpc_object_t v7 = xpc_data_create(v9, 0x2CuLL);
    *a2 = v7;
    if (v7) {
      return 0;
    }
    else {
      return FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
}

xpc_object_t FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(uint64_t a1, xpc_object_t xdict, char *key, uint64_t *a4)
{
  if (xdict && key && a4)
  {
    xpc_object_t result = xpc_dictionary_get_value(xdict, key);
    if (result)
    {
      return (xpc_object_t)_FigEndpointStreamAudioFormatDescriptionCreateWithXPCObject(a1, result, a4);
    }
    else
    {
      *a4 = 0;
    }
  }
  else
  {
    return (xpc_object_t)FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t _FigEndpointStreamAudioFormatDescriptionCreateWithXPCObject(uint64_t a1, void *a2, uint64_t *a3)
{
  memset(v8, 0, 44);
  if (a2)
  {
    if (a3)
    {
      if (MEMORY[0x192FC6B30](a2) == MEMORY[0x1E4F14580])
      {
        if (xpc_data_get_bytes(a2, v8, 0, 0x2CuLL) == 44) {
          return FigEndpointStreamAudioFormatDescriptionCreate(a1, v8, SDWORD2(v8[2]), a3);
        }
        else {
          return FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
        }
      }
      uint64_t v7 = 4294950013;
    }
    else
    {
      uint64_t v7 = 4294950016;
    }
  }
  else
  {
    uint64_t v7 = 4294950016;
  }

  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetFigEndpointStreamAudioFormatDescriptionArray(void *a1, const char *a2, const __CFArray *a3)
{
  xpc_object_t value = 0;
  if (!a1 || !a2)
  {
    uint64_t v12 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
LABEL_13:
    xpc_object_t empty = 0;
    goto LABEL_10;
  }
  if (!a3)
  {
    uint64_t v12 = 0;
    goto LABEL_13;
  }
  xpc_object_t empty = xpc_array_create_empty();
  if (!empty)
  {
    uint64_t v11 = FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
LABEL_15:
    uint64_t v12 = v11;
    goto LABEL_10;
  }
  CFIndex Count = CFArrayGetCount(a3);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    CFIndex v9 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a3, v9);
      uint64_t v11 = _FigEndpointStreamAudioFormatDescriptionCopyXPCObject((uint64_t)ValueAtIndex, &value);
      if (v11) {
        goto LABEL_15;
      }
      xpc_array_append_value(empty, value);
      xpc_release(value);
    }
    while (v8 != ++v9);
  }
  xpc_dictionary_set_value(a1, a2, empty);
  uint64_t v12 = 0;
LABEL_10:
  FigXPCRelease(empty);
  return v12;
}

uint64_t FigXPCMessageCopyFigEndpointStreamAudioFormatDescriptionArray(const __CFAllocator *a1, xpc_object_t xdict, char *key, __CFArray **a4)
{
  xpc_object_t value = 0;
  if (xdict)
  {
    if (key)
    {
      if (a4)
      {
        xpc_object_t v6 = xpc_dictionary_get_value(xdict, key);
        if (!v6)
        {
          uint64_t v14 = 0;
          *a4 = 0;
          return v14;
        }
        uint64_t v7 = v6;
        if (MEMORY[0x192FC6B30]() == MEMORY[0x1E4F14568])
        {
          size_t count = xpc_array_get_count(v7);
          CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, count, MEMORY[0x1E4F1D510]);
          if (Mutable)
          {
            uint64_t v10 = Mutable;
            if (count)
            {
              size_t v11 = 0;
              while (1)
              {
                xpc_object_t v12 = xpc_array_get_value(v7, v11);
                uint64_t v13 = _FigEndpointStreamAudioFormatDescriptionCreateWithXPCObject((uint64_t)a1, v12, (uint64_t *)&value);
                if (v13) {
                  break;
                }
                CFArrayAppendValue(v10, value);
                CFRelease(value);
                if (count == ++v11) {
                  goto LABEL_11;
                }
              }
              uint64_t v14 = v13;
              CFRelease(v10);
            }
            else
            {
LABEL_11:
              uint64_t v14 = 0;
              *a4 = v10;
            }
            return v14;
          }
          uint64_t v16 = 4294950014;
        }
        else
        {
          uint64_t v16 = 4294950013;
        }
      }
      else
      {
        uint64_t v16 = 4294950016;
      }
    }
    else
    {
      uint64_t v16 = 4294950016;
    }
  }
  else
  {
    uint64_t v16 = 4294950016;
  }

  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBufferedAirPlayClientRoutingRegistryGetSharedInstance()
{
  if (FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_sCreateOnce != -1) {
    dispatch_once(&FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_sCreateOnce, &__block_literal_global_8);
  }
  return FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_sFigBufferedAirPlayClientRoutingRegistry;
}

void __FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_block_invoke()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigBufferedAirPlayClientRoutingRegistryTrace[1], @"routingRegistry_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigBufferedAirPlayClientRoutingRegistryTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272E58, @"routingRegistry_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272E50);
  if (dword_1E9272E58 == 256) {
    dword_1E9272E58 = 0;
  }
  if (FigBufferedAirPlayClientRoutingRegistryGetTypeID_once != -1) {
    dispatch_once(&FigBufferedAirPlayClientRoutingRegistryGetTypeID_once, &__block_literal_global_23);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    CFDictionaryRef v2 = Instance;
    Instance[2] = 0;
    Instance[3] = 0;
    Instance[4] = 0;
    dispatch_queue_t v3 = dispatch_queue_create("com.apple.airplay.FigBufferedAirPlayClientRoutingRegistry.notification", 0);
    v2[2] = v3;
    if (v3)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      v2[3] = Mutable;
      if (Mutable)
      {
        uint64_t v5 = FigSimpleMutexCreate();
        v2[4] = v5;
        if (v5)
        {
          if (FigBufferedAirPlayClientRoutingRegistryCreate_onceToken != -1) {
            dispatch_once(&FigBufferedAirPlayClientRoutingRegistryCreate_onceToken, &__block_literal_global_19);
          }
          if (dword_1E9272E58)
          {
            int v18 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v18, &type);
            int v7 = v18;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v9 = v7;
            }
            else {
              unsigned int v9 = v7 & 0xFFFFFFFE;
            }
            if (v9)
            {
              int v19 = 136315138;
              uint64_t v20 = "FigBufferedAirPlayClientRoutingRegistryCreate";
              uint64_t v10 = (unsigned char *)_os_log_send_and_compose_impl();
              LOBYTE(v7) = v18;
            }
            else
            {
              uint64_t v10 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v10, v10 != v23, v7, 0, v8);
          }
          FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_sFigBufferedAirPlayClientRoutingRegistry = (uint64_t)v2;
          return;
        }
      }
      int v11 = -17721;
    }
    else
    {
      int v11 = FigSignalErrorAt(4294949575, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v2);
  }
  else
  {
    int v11 = -17721;
  }
  if (v11 && dword_1E9272E58)
  {
    int v18 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    xpc_object_t v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v18, &type);
    int v13 = v18;
    if (os_log_type_enabled(v12, type)) {
      unsigned int v15 = v13;
    }
    else {
      unsigned int v15 = v13 & 0xFFFFFFFE;
    }
    if (v15)
    {
      int v19 = 136315394;
      uint64_t v20 = "FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_block_invoke";
      __int16 v21 = 1024;
      int v22 = v11;
      uint64_t v16 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v13) = v18;
    }
    else
    {
      uint64_t v16 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v16, v16 != v23, v13, 0, v14);
  }
}

uint64_t FigBufferedAirPlayClientRoutingRegistryRegisterClient(uint64_t a1, const void *a2, const void *a3)
{
  return FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID(a1, a2, a3, 0);
}

uint64_t FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 4294949576;
  if (a1 && a2 && a3)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a3);
    CFDictionaryRef v10 = Value;
    if (Value) {
      CFRetain(Value);
    }
    if (dword_1E9272E58)
    {
      int v35 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v35, &type);
      int v12 = v35;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v14 = v12;
      }
      else {
        unsigned int v14 = v12 & 0xFFFFFFFE;
      }
      if (v14)
      {
        CFDictionaryRef Count = FigCFDictionaryGetCount(v10);
        int v36 = 136316162;
        uint64_t v37 = "FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID";
        __int16 v38 = 2048;
        uint64_t v39 = a2;
        __int16 v40 = 2048;
        uint64_t v41 = a4;
        __int16 v42 = 2112;
        CFDictionaryRef v43 = (CFDictionaryRef)a3;
        __int16 v44 = 2048;
        CFDictionaryRef v45 = Count;
        uint64_t v16 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v12) = v35;
      }
      else
      {
        uint64_t v16 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v16, v16 != v46, v12, 0, v13);
    }
    if (v10)
    {
      if (CFDictionaryContainsKey(v10, a2))
      {
        uint64_t v4 = 0;
        goto LABEL_42;
      }
      CFDictionaryAddValue(v10, a2, a4);
    }
    else
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
      if (!Mutable)
      {
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
        return 4294949575;
      }
      CFDictionaryRef v10 = Mutable;
      CFDictionarySetValue(Mutable, a2, a4);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a3, v10);
    }
    int v18 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v18)
    {
      int v19 = v18;
      CFDictionarySetValue(v18, @"RoutingContextUUID", a3);
      if (dword_1E9272E58)
      {
        int v35 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        uint64_t v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v35, &type);
        int v21 = v35;
        if (os_log_type_enabled(v20, type)) {
          unsigned int v23 = v21;
        }
        else {
          unsigned int v23 = v21 & 0xFFFFFFFE;
        }
        if (v23)
        {
          int v36 = 136315650;
          uint64_t v37 = "FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID";
          __int16 v38 = 2112;
          uint64_t v39 = a3;
          __int16 v40 = 2048;
          uint64_t v41 = a4;
          uint64_t v24 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v21) = v35;
        }
        else
        {
          uint64_t v24 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v24, v24 != v46, v21, 0, v22);
      }
      uint64_t v25 = *(NSObject **)(a1 + 16);
      CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      uint64_t v4 = FigDispatchAsyncPostNotification(v25, DefaultLocalCenter, @"RunningClientsChanged", (const void *)a1, v19, 0);
      if (!v4 && dword_1E9272E58)
      {
        int v35 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        uint64_t v27 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v35, &type);
        int v28 = v35;
        if (os_log_type_enabled(v27, type)) {
          unsigned int v30 = v28;
        }
        else {
          unsigned int v30 = v28 & 0xFFFFFFFE;
        }
        if (v30)
        {
          CFDictionaryRef v31 = FigCFDictionaryGetCount(v10);
          int v36 = 136315906;
          uint64_t v37 = "FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID";
          __int16 v38 = 2112;
          uint64_t v39 = a3;
          __int16 v40 = 2048;
          uint64_t v41 = a4;
          __int16 v42 = 2048;
          CFDictionaryRef v43 = v31;
          uint64_t v32 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v28) = v35;
        }
        else
        {
          uint64_t v32 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v32, v32 != v46, v28, 0, v29);
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
      CFRelease(v19);
      goto LABEL_38;
    }
    uint64_t v4 = 4294949575;
LABEL_42:
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
LABEL_38:
    CFRelease(v10);
  }
  return v4;
}

uint64_t FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 0;
  }
  uint64_t v4 = 4294949576;
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 24), a3))
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a3);
      if (dword_1E9272E58)
      {
        int v31 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v31, &type);
        int v9 = v31;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v11 = v9;
        }
        else {
          unsigned int v11 = v9 & 0xFFFFFFFE;
        }
        if (v11)
        {
          CFIndex Count = CFDictionaryGetCount(Value);
          int v32 = 136315906;
          uint64_t v33 = "FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID";
          __int16 v34 = 2048;
          int v35 = a2;
          __int16 v36 = 2112;
          CFIndex v37 = (CFIndex)a3;
          __int16 v38 = 2048;
          CFIndex v39 = Count;
          uint64_t v13 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v9) = v31;
        }
        else
        {
          uint64_t v13 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v13, v13 != v40, v9, 0, v10);
      }
      CFDictionaryRemoveValue(Value, a2);
      if (dword_1E9272E58)
      {
        int v31 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        unsigned int v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v31, &type);
        int v15 = v31;
        if (os_log_type_enabled(v14, type)) {
          unsigned int v17 = v15;
        }
        else {
          unsigned int v17 = v15 & 0xFFFFFFFE;
        }
        if (v17)
        {
          CFIndex v18 = CFDictionaryGetCount(Value);
          int v32 = 136315650;
          uint64_t v33 = "FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID";
          __int16 v34 = 2112;
          int v35 = a3;
          __int16 v36 = 2048;
          CFIndex v37 = v18;
          int v19 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v15) = v31;
        }
        else
        {
          int v19 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v19, v19 != v40, v15, 0, v16);
      }
      if (!CFDictionaryGetCount(Value)) {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), a3);
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        int v21 = Mutable;
        CFDictionarySetValue(Mutable, @"RoutingContextUUID", a3);
        if (dword_1E9272E58)
        {
          int v31 = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          uint64_t v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v31, &type);
          int v23 = v31;
          if (os_log_type_enabled(v22, type)) {
            unsigned int v25 = v23;
          }
          else {
            unsigned int v25 = v23 & 0xFFFFFFFE;
          }
          if (v25)
          {
            int v32 = 136315394;
            uint64_t v33 = "FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID";
            __int16 v34 = 2112;
            int v35 = a3;
            CFStringRef v26 = (unsigned char *)_os_log_send_and_compose_impl();
            LOBYTE(v23) = v31;
          }
          else
          {
            CFStringRef v26 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v26, v26 != v40, v23, 0, v24);
        }
        uint64_t v27 = *(NSObject **)(a1 + 16);
        CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        uint64_t v4 = FigDispatchAsyncPostNotification(v27, DefaultLocalCenter, @"RunningClientsChanged", (const void *)a1, v21, 0);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
        CFRelease(v21);
        return v4;
      }
      uint64_t v4 = 4294949575;
    }
    else
    {
      uint64_t v4 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  }
  return v4;
}

uint64_t FigBufferedAirPlayClientRoutingRegistryGetCountOfRunningClientsForRoutingContext(uint64_t a1, const void *a2, CFIndex *a3)
{
  CFIndex Count = 0;
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  CFTypeRef v36 = 0;
  CFTypeRef v33 = 0;
  CFTypeRef v34 = 0;
  uint64_t v6 = 4294949576;
  if (!a1) {
    goto LABEL_40;
  }
  CFTypeRef v7 = a2;
  if (!a2) {
    goto LABEL_40;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  if (FigServer_IsAirplayd() && (uint64_t v8 = sFigRoutingContextRemoteCopySystemAudioContext) != 0
    || (uint64_t v8 = (void *)sFigRoutingContextCopySystemAudioContext) != 0)
  {
    if (((unsigned int (*)(void, void, CFTypeRef *))v8)(0, 0, &v36)) {
      goto LABEL_60;
    }
  }
  else
  {
    int v38 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 0, &v38, &type);
    int v17 = v38;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v19 = v17;
    }
    else {
      unsigned int v19 = v17 & 0xFFFFFFFE;
    }
    if (v19)
    {
      int v39 = 136315138;
      __int16 v40 = "routingRegistry_figRoutingContextCopySystemAudioContext";
      uint64_t v20 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v17) = v38;
    }
    else
    {
      uint64_t v20 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 0, 1, v20, v20 != v45, v17, 0, v18);
  }
  uint64_t v9 = *MEMORY[0x1E4F1CF80];
  if (routingRegistry_figRoutingContextCopyProperty((uint64_t)v36, *(void *)skFigRoutingContextProperty_ContextUUID, *MEMORY[0x1E4F1CF80], (uint64_t)&v34))goto LABEL_60; {
  if (FigCFEqual(v7, v34))
  }
  {
    if (FigServer_IsAirplayd() && (uint64_t v10 = sFigRoutingContextRemoteCopySystemMusicContext) != 0
      || (uint64_t v10 = (void *)sFigRoutingContextCopySystemMusicContext) != 0)
    {
      if (((unsigned int (*)(void, void, CFTypeRef *))v10)(0, 0, &cf)) {
        goto LABEL_60;
      }
    }
    else
    {
      int v38 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      int v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 0, &v38, &type);
      int v29 = v38;
      if (os_log_type_enabled(v28, type)) {
        unsigned int v31 = v29;
      }
      else {
        unsigned int v31 = v29 & 0xFFFFFFFE;
      }
      if (v31)
      {
        int v39 = 136315138;
        __int16 v40 = "routingRegistry_figRoutingContextCopySystemMusicContext";
        int v32 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v29) = v38;
      }
      else
      {
        int v32 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 0, 1, v32, v32 != v45, v29, 0, v30);
    }
    if (!routingRegistry_figRoutingContextCopyProperty((uint64_t)cf, *(void *)skFigRoutingContextProperty_ContextUUID, v9, (uint64_t)&v33))
    {
      if (dword_1E9272E58)
      {
        int v38 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        unsigned int v11 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v38, &type);
        int v12 = v38;
        if (os_log_type_enabled(v11, type)) {
          unsigned int v14 = v12;
        }
        else {
          unsigned int v14 = v12 & 0xFFFFFFFE;
        }
        if (v14)
        {
          int v39 = 136315650;
          __int16 v40 = "FigBufferedAirPlayClientRoutingRegistryGetCountOfRunningClientsForRoutingContext";
          __int16 v41 = 2112;
          CFTypeRef v42 = v33;
          __int16 v43 = 2112;
          CFIndex v44 = (CFIndex)v7;
          int v15 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v12) = v38;
        }
        else
        {
          int v15 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v15, v15 != v45, v12, 0, v13);
      }
      CFTypeRef v7 = v33;
      goto LABEL_28;
    }
LABEL_60:
    CFIndex Count = 0;
    uint64_t v6 = 4294949574;
    goto LABEL_40;
  }
LABEL_28:
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), v7);
  if (Value) {
    CFIndex Count = CFDictionaryGetCount(Value);
  }
  else {
    CFIndex Count = 0;
  }
  if (dword_1E9272E58)
  {
    int v38 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    uint64_t v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, &v38, &type);
    int v23 = v38;
    if (os_log_type_enabled(v22, type)) {
      unsigned int v25 = v23;
    }
    else {
      unsigned int v25 = v23 & 0xFFFFFFFE;
    }
    if (v25)
    {
      int v39 = 136315650;
      __int16 v40 = "FigBufferedAirPlayClientRoutingRegistryGetCountOfRunningClientsForRoutingContext";
      __int16 v41 = 2112;
      CFTypeRef v42 = v7;
      __int16 v43 = 2048;
      CFIndex v44 = Count;
      CFStringRef v26 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v23) = v38;
    }
    else
    {
      CFStringRef v26 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v26, v26 != v45, v23, 0, v24);
  }
  uint64_t v6 = 0;
LABEL_40:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  if (a3) {
    *a3 = Count;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v34) {
    CFRelease(v34);
  }
  return v6;
}

uint64_t routingRegistry_figRoutingContextCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 4294949576;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 48);
  if (!v10) {
    return 4294954514;
  }

  return v10(a1, a2, a3, a4);
}

uint64_t FigBufferedAirPlayClientRoutingRegistryClearAllClientsWithRemoteID(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 24);
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 0x40000000;
  context[2] = __FigBufferedAirPlayClientRoutingRegistryClearAllClientsWithRemoteID_block_invoke;
  void context[3] = &unk_1E5677A18;
  context[4] = &v8;
  context[5] = a2;
  context[6] = a1;
  FigCFDictionaryApplyBlock(v4, context);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void __FigBufferedAirPlayClientRoutingRegistryClearAllClientsWithRemoteID_block_invoke(void *a1, const void *a2, const __CFDictionary *a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
  CFMutableDictionaryRef v7 = Mutable;
  if (a3)
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    v8[2] = __FigBufferedAirPlayClientRoutingRegistryClearAllClientsWithRemoteID_block_invoke_2;
    long long v8[3] = &__block_descriptor_tmp_6;
    void v8[4] = a1[5];
    v8[5] = Mutable;
    FigCFDictionaryApplyBlock(a3, v8);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1[6] + 24), a2, v7);
    if (!v7) {
      return;
    }
  }
  else
  {
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = -17721;
    if (!Mutable) {
      return;
    }
  }
  CFRelease(v7);
}

void __FigBufferedAirPlayClientRoutingRegistryClearAllClientsWithRemoteID_block_invoke_2(uint64_t a1, const void *a2, const void *a3)
{
  if (*(const void **)(a1 + 32) != a3) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), a2, a3);
  }
}

void __FigBufferedAirPlayClientRoutingRegistryCreate_block_invoke()
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unsigned int v0 = dlopen("/System/Library/PrivateFrameworks/MediaExperience.framework/MediaExperience", 4);
  mediaexperience = (uint64_t)v0;
  if (v0)
  {
    skFigRoutingContextProperty_ContextUUID = (uint64_t)dlsym(v0, "kFigRoutingContextProperty_ContextUUID");
    if (skFigRoutingContextProperty_ContextUUID)
    {
      if (FigServer_IsAirplayd())
      {
        sFigRoutingContextRemoteCopySystemAudioContext = dlsym((void *)mediaexperience, "FigRoutingContextRemoteCopySystemAudioContext");
        if (sFigRoutingContextRemoteCopySystemAudioContext)
        {
          sFigRoutingContextRemoteCopySystemMusicContext = dlsym((void *)mediaexperience, "FigRoutingContextRemoteCopySystemMusicContext");
          if (sFigRoutingContextRemoteCopySystemMusicContext) {
            return;
          }
        }
      }
      else
      {
        sFigRoutingContextCopySystemAudioContext = (uint64_t)dlsym((void *)mediaexperience, "FigRoutingContextCopySystemAudioContext");
        if (sFigRoutingContextCopySystemAudioContext)
        {
          sFigRoutingContextCopySystemMusicContext = (uint64_t)dlsym((void *)mediaexperience, "FigRoutingContextCopySystemMusicContext");
          if (sFigRoutingContextCopySystemMusicContext) {
            return;
          }
        }
      }
    }
    FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v8[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 0, v8, &type);
    int v2 = v8[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v4 = v2;
    }
    else {
      unsigned int v4 = v2 & 0xFFFFFFFE;
    }
    if (v4)
    {
      uint64_t v5 = dlerror();
      v8[1] = 136315650;
      uint64_t v9 = "LoadMediaExperienceFramework";
      __int16 v10 = 2082;
      int v11 = "/System/Library/PrivateFrameworks/MediaExperience.framework/MediaExperience";
      __int16 v12 = 2082;
      uint64_t v13 = v5;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v2) = v8[0];
    }
    else
    {
      uint64_t v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 0, 1, v6, v6 != &v14, v2, 0, v3);
  }
}

void FigBufferedAirPlayClientRoutingRegistry_Finalize(void *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  FigSimpleMutexDestroy(a1[4]);
  int v2 = a1[2];
  if (v2)
  {
    dispatch_release(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  if (dword_1E9272E58)
  {
    v10[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E50, 1, v10, &type);
    int v5 = v10[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      v10[1] = 136315138;
      int v11 = "FigBufferedAirPlayClientRoutingRegistry_Finalize";
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v10[0];
    }
    else
    {
      uint64_t v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E50, 1u, 1, v8, v8 != &v12, v5, 0, v6);
  }
}

uint64_t __FigBufferedAirPlayClientRoutingRegistryGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  FigBufferedAirPlayClientRoutingRegistryGetTypeID_typeID = result;
  return result;
}

OSStatus CMAudioDeviceClockCreate(CFAllocatorRef allocator, CFStringRef deviceUID, CMClockRef *clockOut)
{
  CFStringRef v4 = deviceUID;
  if (FigCFEqual(deviceUID, @"AQDefaultDevice")) {
    CFStringRef v4 = @"VirtualAudioDevice_Default";
  }
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFADCTrace[1], @"fadc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFADCTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1E9272E78, @"fadc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1E9272E70);
  if (fadcShouldCreateRemoteClock())
  {
    return FigAudioDeviceClock_RemoteCreateCommon((uint64_t)allocator, v4, 0, clockOut);
  }
  else
  {
    return figAudioDeviceClockCreateCommon((uint64_t)allocator, (uint64_t)v4, 0, (CFTypeRef *)clockOut);
  }
}

BOOL fadcShouldCreateRemoteClock()
{
  return !FigServer_IsMediaserverd() && !FigServer_IsMediaplaybackd() && !FigServer_IsCameracaptured();
}

OSStatus CMAudioDeviceClockCreateFromAudioDeviceID(CFAllocatorRef allocator, AudioDeviceID deviceID, CMClockRef *clockOut)
{
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFADCTrace[1], @"fadc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFADCTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1E9272E78, @"fadc_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1E9272E70);
  if (deviceID)
  {
    if (fadcShouldCreateRemoteClock())
    {
      return FigAudioDeviceClock_RemoteCreateCommon((uint64_t)allocator, 0, deviceID, clockOut);
    }
    else
    {
      return figAudioDeviceClockCreateCommon((uint64_t)allocator, 0, deviceID, (CFTypeRef *)clockOut);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMAudioDeviceClockSetAudioDeviceUID(CMClockRef clock, CFStringRef deviceUID)
{
  CFStringRef v2 = deviceUID;
  uint64_t v9 = 0;
  __int16 v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = 0;
  if (FigCFEqual(deviceUID, @"AQDefaultDevice")) {
    CFStringRef v2 = @"VirtualAudioDevice_Default";
  }
  if (!clock)
  {
    uint64_t v6 = 4294954551;
LABEL_9:
    OSStatus v4 = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  if (!FigDerivedClockVerifyCallbacksMatch((BOOL)clock, (uint64_t)&gFigAudioDeviceClockCallbacks))
  {
    uint64_t v6 = 4294954550;
    goto LABEL_9;
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  int v8[2] = __CMAudioDeviceClockSetAudioDeviceUID_block_invoke;
  long long v8[3] = &unk_1E5677A80;
  void v8[4] = &v9;
  v8[5] = clock;
  void v8[6] = v2;
  OSStatus v4 = writeProtectedStorageSync((uint64_t)clock, (uint64_t)v8);
  OSStatus v5 = *((_DWORD *)v10 + 6);
  if (!v5)
  {
    *((_DWORD *)v10 + 6) = v4;
LABEL_10:
    OSStatus v5 = v4;
  }
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t writeProtectedStorageSync(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
    FigAtomicIncrement32((atomic_uint *)(DerivedStorage + 120));
    OSStatus v5 = *(NSObject **)(DerivedStorage + 128);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    v7[2] = __writeProtectedStorageSync_block_invoke;
    v7[3] = &unk_1E5677C68;
    v7[4] = a2;
    v7[5] = DerivedStorage;
    dispatch_sync(v5, v7);
    FigAtomicDecrement32((atomic_uint *)(DerivedStorage + 120));
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t __CMAudioDeviceClockSetAudioDeviceUID_block_invoke(uint64_t a1)
{
  uint64_t result = fadcSetAudioDeviceUID(*(void *)(a1 + 40), *(const void **)(a1 + 48));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

OSStatus CMAudioDeviceClockSetAudioDeviceID(CMClockRef clock, AudioDeviceID deviceID)
{
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v13 = 0;
  if (!clock)
  {
    uint64_t v6 = 4294954551;
LABEL_8:
    OSStatus v4 = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  if (!FigDerivedClockVerifyCallbacksMatch((BOOL)clock, (uint64_t)&gFigAudioDeviceClockCallbacks))
  {
    uint64_t v6 = 4294954550;
    goto LABEL_8;
  }
  if (!deviceID)
  {
    OSStatus v5 = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v11 + 6) = v5;
    goto LABEL_10;
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  int v8[2] = __CMAudioDeviceClockSetAudioDeviceID_block_invoke;
  long long v8[3] = &unk_1E5677AA8;
  void v8[4] = &v10;
  v8[5] = clock;
  AudioDeviceID v9 = deviceID;
  OSStatus v4 = writeProtectedStorageSync((uint64_t)clock, (uint64_t)v8);
  OSStatus v5 = *((_DWORD *)v11 + 6);
  if (!v5)
  {
    *((_DWORD *)v11 + 6) = v4;
LABEL_9:
    OSStatus v5 = v4;
  }
LABEL_10:
  _Block_object_dispose(&v10, 8);
  return v5;
}

uint64_t __CMAudioDeviceClockSetAudioDeviceID_block_invoke(uint64_t a1)
{
  uint64_t result = fadcSetAudioDeviceID(*(void *)(a1 + 40), *(_DWORD *)(a1 + 48));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t fadcSetAudioDeviceID(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  if (a2)
  {
    uint64_t v5 = DerivedStorage;
    uint64_t v6 = *(const void **)(DerivedStorage + 80);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(v5 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    }
    if (in_audio_mx_server_process())
    {
      return switchToNewDeviceID(a1, a2);
    }
    else
    {
      *(unsigned char *)uint64_t v5 = 0;
      *(unsigned char *)(v5 + 72) = 1;
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMAudioDeviceClockGetAudioDevice(CMClockRef clock, CFStringRef *deviceUIDOut, AudioDeviceID *deviceIDOut, Boolean *trackingDefaultDeviceOut)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)clock);
  if (clock)
  {
    AudioDeviceID v9 = (void (*)(void))DerivedStorage;
    if (FigDerivedClockVerifyCallbacksMatch((BOOL)clock, (uint64_t)gFigAudioDeviceClockCallbacks))
    {
      v12[0] = (void (*)(void))MEMORY[0x1E4F143A8];
      v12[1] = (void (*)(void))0x40000000;
      int v12[2] = (void (*)(void))__CMAudioDeviceClockGetAudioDevice_block_invoke;
      v12[3] = (void (*)(void))&__block_descriptor_tmp_8;
      v12[4] = (void (*)(void))deviceUIDOut;
      v12[5] = v9;
      v12[6] = (void (*)(void))deviceIDOut;
      v12[7] = (void (*)(void))trackingDefaultDeviceOut;
      return readProtectedStorageSync((uint64_t)clock, v12);
    }
    uint64_t v11 = 4294954550;
  }
  else
  {
    uint64_t v11 = 4294954551;
  }

  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t readProtectedStorageSync(uint64_t a1, void (**a2)(void))
{
  if (a1)
  {
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
    uint64_t v5 = DerivedStorage;
    if (*(_DWORD *)(DerivedStorage + 120))
    {
      dispatch_sync(*(dispatch_queue_t *)(DerivedStorage + 128), a2);
    }
    else
    {
      FigReadWriteLockLockForRead(*(void *)(DerivedStorage + 136));
      a2[2](a2);
      FigReadWriteLockUnlockForRead(*(void *)(v5 + 136));
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  }
}

void *__CMAudioDeviceClockGetAudioDevice_block_invoke(void *result)
{
  uint64_t v1 = (void *)result[4];
  if (v1) {
    *uint64_t v1 = *(void *)(result[5] + 80);
  }
  uint64_t v2 = (_DWORD *)result[6];
  if (v2) {
    _DWORD *v2 = *(_DWORD *)(result[5] + 88);
  }
  uint64_t v3 = (unsigned char *)result[7];
  if (v3) {
    *uint64_t v3 = *(unsigned char *)(result[5] + 72);
  }
  return result;
}

uint64_t FigAudioDeviceClockSetIgnoresBluetoothPresentationTimeSupport(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
    if (FigDerivedClockVerifyCallbacksMatch(a1, (uint64_t)&gFigAudioDeviceClockCallbacks))
    {
      *(unsigned char *)(DerivedStorage + 1) = a2;
      return 0;
    }
    uint64_t v6 = 4294954550;
  }
  else
  {
    uint64_t v6 = 4294954551;
  }

  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPreferAudioSessionClock()
{
  uint64_t v0 = FigPreferAudioSessionOverCMSession();
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigPreferAudioSessionClock_block_invoke;
  block[3] = &__block_descriptor_tmp_9_0;
  char v3 = v0;
  if (FigPreferAudioSessionClock_onceToken != -1) {
    dispatch_once(&FigPreferAudioSessionClock_onceToken, block);
  }
  return v0;
}

BOOL __FigPreferAudioSessionClock_block_invoke(BOOL result)
{
  if (!*(unsigned char *)(result + 32))
  {
    uint64_t result = FigServer_IsServerProcess();
    if (result)
    {
      return FigServer_IsMediaserverd();
    }
  }
  return result;
}

uint64_t __figAudioDeviceClockCreateCommon_block_invoke(uint64_t a1)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 0, &gFigAudioDeviceClockRegistry);
  uint64_t result = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (result)
  {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t __figAudioDeviceClockCreateCommon_block_invoke_2(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v2) {
    uint64_t result = fadcSetAudioDeviceID(v3, v2);
  }
  else {
    uint64_t result = fadcSetAudioDeviceUID(v3, *(const void **)(a1 + 48));
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

CFStringRef fadcCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  OSStatus v4 = "true";
  if (!*(unsigned char *)(DerivedStorage + 72)) {
    OSStatus v4 = "false";
  }
  return CFStringCreateWithFormat(v3, 0, @"AudioDeviceClock(deviceUID='%@', deviceID=%d, trackDefaultDevice=%s)", *(void *)(DerivedStorage + 80), *(unsigned int *)(DerivedStorage + 88), v4);
}

uint64_t fadcMightDrift(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = 0;
  char v14 = &v13;
  uint64_t v15 = 0x2000000000;
  char v16 = 1;
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v4 = FigDerivedClockGetDerivedStorage(a2);
  uint64_t v5 = *(NSObject **)(DerivedStorage + 128);
  uint64_t v6 = *(NSObject **)(v4 + 128);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  int v12[2] = __fadcMightDrift_block_invoke;
  v12[3] = &unk_1E5677BC8;
  v12[5] = DerivedStorage;
  v12[6] = v4;
  v12[4] = &v13;
  if (v6 >= v5) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = v5;
  }
  if (v6 >= v5) {
    uint64_t v8 = v5;
  }
  else {
    uint64_t v8 = v6;
  }
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  _OWORD v11[2] = __fadcMightDrift_block_invoke_2;
  v11[3] = &unk_1E5677BF0;
  v11[5] = v8;
  void v11[6] = v7;
  v11[4] = v12;
  dispatch_sync(v8, v11);
  uint64_t v9 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v9;
}

uint64_t fadcGetAnchorTime(void (*a1)(void), void (*a2)(void), void (*a3)(void))
{
  return fadcGetAnchorTimeInternal(a1, a2, a3, 0);
}

dispatch_queue_t fadcInitDeferredRemoveQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.coremedia.fadcdeferredremovepropertylistener", 0);
  *a1 = result;
  return result;
}

uint64_t __fadcDeferRemovePropertyListeners_block_invoke(uint64_t a1)
{
  *(void *)&v3.AudioObjectPropertySelector mSelector = 0x2A2A2A2A676F696ELL;
  v3.mElement = 0;
  AudioObjectRemovePropertyListener(*(_DWORD *)(a1 + 40), &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  *(void *)&v3.AudioObjectPropertySelector mSelector = 0x2A2A2A2A6F766572;
  v3.mElement = 0;
  AudioObjectRemovePropertyListener(*(_DWORD *)(a1 + 40), &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  *(void *)&v3.AudioObjectPropertySelector mSelector = 0x2A2A2A2A6E737274;
  v3.mElement = 0;
  uint64_t result = AudioObjectRemovePropertyListener(*(_DWORD *)(a1 + 40), &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  if (*(unsigned char *)(a1 + 44))
  {
    *(void *)&v3.AudioObjectPropertySelector mSelector = 0x2A2A2A2A644F7574;
    v3.mElement = 0;
    return AudioObjectRemovePropertyListener(1u, &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  }
  return result;
}

uint64_t __coreAudioObjectPropertyListener_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(v1);
  uint64_t result = FigAtomicBitAnd32Orig(0, (atomic_uint *)(DerivedStorage + 56));
  char v4 = result;
  *(void *)&v5.AudioObjectPropertySelector mSelector = 0x676C6F6200000000;
  v5.mElement = 0;
  if ((result & 2) != 0)
  {
    v5.AudioObjectPropertySelector mSelector = 1870030194;
    uint64_t result = propertyListenerDispatch(v1, &v5);
    if ((v4 & 4) == 0)
    {
LABEL_3:
      if ((v4 & 8) == 0) {
        return result;
      }
      goto LABEL_4;
    }
  }
  else if ((result & 4) == 0)
  {
    goto LABEL_3;
  }
  v5.AudioObjectPropertySelector mSelector = 1735354734;
  uint64_t result = propertyListenerDispatch(v1, &v5);
  if ((v4 & 8) == 0) {
    return result;
  }
LABEL_4:
  v5.AudioObjectPropertySelector mSelector = 1853059700;
  return propertyListenerDispatch(v1, &v5);
}

void __writeProtectedStorageAsync_block_invoke(void *a1)
{
  FigReadWriteLockLockForWrite(*(void *)(a1[5] + 136));
  (*(void (**)(void))(a1[4] + 16))();
  FigReadWriteLockUnlockForWrite(*(void *)(a1[5] + 136));
  FigAtomicDecrement32((atomic_uint *)(a1[5] + 120));
  int v2 = (const void *)a1[6];
  if (v2)
  {
    CFRelease(v2);
  }
}

void *__fadcMightDrift_block_invoke(void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = result[6];
  if (*(_DWORD *)(v1 + 88) == *(_DWORD *)(v2 + 88))
  {
    int v3 = *(unsigned __int8 *)(v1 + 72);
    uint64_t v4 = *(void *)(result[4] + 8);
    if (v3 == *(unsigned __int8 *)(v2 + 72))
    {
      *(unsigned char *)(v4 + 24) = 0;
      return result;
    }
  }
  else
  {
    uint64_t v4 = *(void *)(result[4] + 8);
  }
  *(unsigned char *)(v4 + 24) = 1;
  return result;
}

void __fadcMightDrift_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[6];
  int v3 = (void (**)(void))a1[4];
  if (a1[5] == v2) {
    v3[2](a1[4]);
  }
  else {
    dispatch_sync(v2, v3);
  }
}

uint64_t __fadcGetRate_block_invoke(uint64_t result)
{
  if (**(unsigned char **)(result + 40))
  {
    uint64_t v1 = result;
    uint64_t result = fadc_getDeviceRateAndSampleTimeAndHostTime(*(void *)(result + 48), (Float64 *)(*(void *)(*(void *)(result + 32) + 8) + 24), 0, 0);
    if (result) {
      *(void *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = 0x3FF0000000000000;
    }
  }
  return result;
}

uint64_t fadc_getDeviceRateAndSampleTimeAndHostTime(uint64_t a1, Float64 *a2, Float64 *a3, Float64 *a4)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  if (!*(unsigned char *)(DerivedStorage + 1))
  {
    uint64_t v14 = DerivedStorage;
    uint64_t v15 = FigDerivedClockGetDerivedStorage(a1);
    int v16 = FigAudioDeviceSupportsPresentationTime(*(_DWORD *)(v15 + 88));
    int v17 = v16;
    if (v16 != *(unsigned __int8 *)(v14 + 112))
    {
      *(unsigned char *)(v14 + 112) = v16;
      FigDerivedClockDiscontinuityOccurred(a1);
    }
    if (v17)
    {
      uint64_t v18 = FigDerivedClockGetDerivedStorage(a1);
      memset(&v19, 0, 40);
      uint64_t result = FigAudioDeviceGetCurrentPresentationTime(*(_DWORD *)(v18 + 88), (uint64_t)&v19);
      if (result) {
        return result;
      }
      Float64 v11 = *(double *)&v19.mSMPTETime.mSubframes;
      Float64 mRateScalar = v19.mRateScalar;
      Float64 mSampleTime = v19.mSampleTime;
      if (!a2) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  uint64_t v9 = FigDerivedClockGetDerivedStorage(a1);
  memset(&v19, 0, sizeof(v19));
  v19.mFlags = 7;
  uint64_t result = AudioDeviceGetCurrentTime(*(_DWORD *)(v9 + 88), &v19);
  if (result) {
    return result;
  }
  if ((~v19.mFlags & 7) == 0)
  {
    Float64 v11 = v19.mRateScalar;
    Float64 mSampleTime = *(double *)&v19.mHostTime;
    Float64 mRateScalar = v19.mSampleTime;
    if (!a2) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  uint64_t result = FigSignalErrorAt(4294949324, 0, 0, 0, 0, 0, 0);
  if (result) {
    return result;
  }
  Float64 mSampleTime = 0.0;
  Float64 v11 = NAN;
  Float64 mRateScalar = NAN;
  if (a2) {
LABEL_11:
  }
    *a2 = v11;
LABEL_12:
  if (a3) {
    *a3 = mRateScalar;
  }
  uint64_t result = 0;
  if (a4) {
    *a4 = mSampleTime;
  }
  return result;
}

uint64_t fadcGetAnchorTimeInternal(void (*a1)(void), void (*a2)(void), void (*a3)(void), int a4)
{
  uint64_t v18 = 0;
  AudioTimeStamp v19 = &v18;
  uint64_t v20 = 0x2000000000;
  int v21 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  char v17 = 0;
  uint64_t DerivedStorage = (void (*)(void))FigDerivedClockGetDerivedStorage((uint64_t)a1);
  v12[0] = (void (*)(void))MEMORY[0x1E4F143A8];
  v12[1] = (void (*)(void))0x40000000;
  int v12[2] = (void (*)(void))__fadcGetAnchorTimeInternal_block_invoke;
  v12[3] = (void (*)(void))&unk_1E5677C40;
  char v13 = a4;
  v12[4] = (void (*)(void))&v18;
  v12[5] = (void (*)(void))&v14;
  v12[6] = DerivedStorage;
  void v12[7] = a1;
  v12[8] = a2;
  void v12[9] = a3;
  if (a4) {
    uint64_t ProtectedStorageSync = writeProtectedStorageSync((uint64_t)a1, (uint64_t)v12);
  }
  else {
    uint64_t ProtectedStorageSync = readProtectedStorageSync((uint64_t)a1, v12);
  }
  uint64_t AnchorTimeInternal = *((unsigned int *)v19 + 6);
  if (!AnchorTimeInternal)
  {
    *((_DWORD *)v19 + 6) = ProtectedStorageSync;
    uint64_t AnchorTimeInternal = ProtectedStorageSync;
  }
  if (*((unsigned char *)v15 + 24))
  {
    uint64_t AnchorTimeInternal = fadcGetAnchorTimeInternal(a1, a2, a3, 1);
    *((_DWORD *)v19 + 6) = AnchorTimeInternal;
  }
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return AnchorTimeInternal;
}

__n128 __fadcGetAnchorTimeInternal_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  CMTimeValue value = 0;
  CMTimeFlags flags = 0;
  CMTimeScale timescale = 0;
  CMTimeEpoch epoch = 0;
  result.n128_u64[0] = kCMTimeInvalid.value;
  memset(&v30, 0, sizeof(v30));
  double v28 = 0.0;
  double v29 = 0.0;
  uint64_t hostTime = 0;
  uint64_t v5 = *(void *)(a1 + 48);
  if (!*(unsigned char *)v5)
  {
    uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8);
    int v22 = -17970;
    goto LABEL_21;
  }
  if (!*(void *)(v5 + 104) && !*(unsigned char *)(a1 + 80)) {
    goto LABEL_16;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = fadc_getDeviceRateAndSampleTimeAndHostTime(*(void *)(a1 + 56), &v29, &v28, (Float64 *)&hostTime);
  uint64_t v6 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (!v6)
  {
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(v7 + 104);
    result.n128_f64[0] = v28;
    if (v8)
    {
      double v9 = v28 - *(double *)(v7 + 96) + -(v29 * *(double *)(v7 + 48)) * (double)(hostTime - v8);
      if (v9 < *(double *)(v7 + 32) || v9 > *(double *)(v7 + 40))
      {
        if (!*(unsigned char *)(a1 + 80)) {
          goto LABEL_16;
        }
        int v26 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E70, 0, &v26, &type);
        int v11 = v26;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v13 = v11;
        }
        else {
          unsigned int v13 = v11 & 0xFFFFFFFE;
        }
        if (v13)
        {
          uint64_t v14 = *(void *)(a1 + 48);
          double v15 = *(double *)(v14 + 96);
          double v16 = *(double *)(v14 + 48);
          uint64_t v17 = *(void *)(v14 + 104);
          uint64_t v19 = *(void *)(v14 + 32);
          uint64_t v18 = *(void *)(v14 + 40);
          int v31 = 136317698;
          int v32 = "fadcGetAnchorTimeInternal_block_invoke";
          __int16 v33 = 2048;
          double v34 = v28;
          __int16 v35 = 2048;
          double v36 = v15;
          __int16 v37 = 2048;
          double v38 = v28 - v15;
          __int16 v39 = 2048;
          double v40 = v29;
          __int16 v41 = 2048;
          double v42 = v16;
          __int16 v43 = 2048;
          uint64_t v44 = hostTime;
          __int16 v45 = 2048;
          uint64_t v46 = v17;
          __int16 v47 = 2048;
          double v48 = v29 * v16 * (double)(hostTime - v17);
          __int16 v49 = 2048;
          uint64_t v50 = v19;
          __int16 v51 = 2048;
          uint64_t v52 = v18;
          uint64_t v20 = (CMTime *)_os_log_send_and_compose_impl();
          LOBYTE(v11) = v26;
        }
        else
        {
          uint64_t v20 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E70, 0, 2, v20, v20 != &v53, v11, 0, v12);
        uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8);
        int v22 = -17971;
LABEL_21:
        *(_DWORD *)(v21 + 24) = v22;
        goto LABEL_22;
      }
    }
    else
    {
      *(double *)(v7 + 96) = v28;
      *(void *)(v7 + 104) = hostTime;
    }
    CMTimeMake(&v53, (uint64_t)result.n128_f64[0], (int)*(double *)(v7 + 8));
    CMTimeValue value = v53.value;
    CMTimeFlags flags = v53.flags;
    CMTimeScale timescale = v53.timescale;
    CMTimeEpoch epoch = v53.epoch;
    CMClockMakeHostTimeFromSystemUnits(&v30, hostTime);
    goto LABEL_22;
  }
  if (!*(unsigned char *)(a1 + 80))
  {
LABEL_16:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    goto LABEL_22;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
LABEL_22:
  if (*(unsigned char *)(a1 + 80) && (flags & 1) == 0) {
    *(void *)(*(void *)(a1 + 48) + 104) = 0;
  }
  uint64_t v23 = *(void *)(a1 + 64);
  if (v23)
  {
    *(void *)uint64_t v23 = value;
    *(_DWORD *)(v23 + 8) = timescale;
    *(_DWORD *)(v23 + 12) = flags;
    *(void *)(v23 + 16) = epoch;
  }
  uint64_t v24 = *(__n128 **)(a1 + 72);
  if (v24)
  {
    __n128 result = *(__n128 *)&v30.value;
    v24[1].n128_u64[0] = v30.epoch;
    __n128 *v24 = result;
  }
  return result;
}

uint64_t __writeProtectedStorageSync_block_invoke(uint64_t a1)
{
  FigReadWriteLockLockForWrite(*(void *)(*(void *)(a1 + 40) + 136));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 136);

  return FigReadWriteLockUnlockForWrite(v2);
}

CFTypeID CMClockGetTypeID(void)
{
  return sFigClockID;
}

void CMClockInvalidate(CMClockRef clock)
{
  if (clock)
  {
    uint64_t v2 = *((void *)clock + 2);
    if (v2) {
      FigReentrantMutexLock(*((pthread_mutex_t **)clock + 2));
    }
    if (*((unsigned char *)clock + 41))
    {
      int v3 = *(void (**)(CMClockRef))(*((void *)clock + 3) + 24);
      if (v3) {
        v3(clock);
      }
      *((unsigned char *)clock + 41) = 0;
      FigMemoryBarrier();
      uint64_t v4 = (const void *)*((void *)clock + 4);
      if (v4) {
        CFRelease(v4);
      }
      *((void *)clock + 3) = 0;
      *((void *)clock + 4) = 0;
    }
    if (v2)
    {
      uint64_t v5 = (pthread_mutex_t *)*((void *)clock + 2);
      FigReentrantMutexUnlock(v5);
    }
  }
  else
  {
    FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMClockGetAnchorTime(CMClockRef clock, CMTime *clockTimeOut, CMTime *referenceClockTimeOut)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  long long v33 = *(_OWORD *)&kCMTimeInvalid.value;
  CMTimeEpoch v6 = 0;
  CMTimeEpoch v34 = 0;
  memset(v32, 0, 24);
  if (!clock)
  {
    OSStatus v8 = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)clock + 2));
  if (!*((unsigned char *)clock + 41))
  {
    OSStatus v9 = -12746;
    goto LABEL_22;
  }
  int v7 = *((_DWORD *)clock + 11);
  if (v7 == 1702392677)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s: kFigClockClass_ExternalSyncEvents not yet implemented\n", "CMClockGetAnchorTime");
    OSStatus v9 = -12756;
    goto LABEL_22;
  }
  if (v7 != 1735680866)
  {
    OSStatus v9 = 0;
    goto LABEL_22;
  }
  if (*((unsigned char *)clock + 72))
  {
    OSStatus v8 = (*(uint64_t (**)(CMClockRef, long long *, _OWORD *))(*((void *)clock + 3) + 48))(clock, &v33, v32);
LABEL_7:
    OSStatus v9 = v8;
    goto LABEL_22;
  }
  if (*((unsigned char *)clock + 73))
  {
    CMTimeValue v45 = 0;
    CMTimeScale v46 = 0;
    memset(&v38, 0, sizeof(v38));
    memset(&lhs, 0, sizeof(lhs));
    memset(&v36, 0, sizeof(v36));
    memset(&v35, 0, sizeof(v35));
    FigMemoryBarrier();
    int v11 = *((_DWORD *)clock + 50);
    int v10 = *((_DWORD *)clock + 51);
    uint64_t v12 = (OpaqueCMClock *)*((void *)clock + 4);
    memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
    CMClockGetAnchorTime(v12, &clockTimeOuta, 0);
    CMTimeValue value = clockTimeOuta.value;
    uint64_t v43 = *(void *)&clockTimeOuta.flags;
    CMTimeScale timescale = clockTimeOuta.timescale;
    CMTimeScale epoch_high = HIDWORD(clockTimeOuta.epoch);
    CMTime clockTimeOuta = *(CMTime *)((char *)clock + 128);
    CMTime rhs = *(CMTime *)((unsigned char *)clock + 2);
    CMTimeAdd(&time2, &clockTimeOuta, &rhs);
    clockTimeOuta.CMTimeValue value = value;
    *(void *)&clockTimeOuta.CMTimeFlags flags = v43;
    clockTimeOuta.CMTimeScale timescale = timescale;
    HIDWORD(clockTimeOuta.epoch) = epoch_high;
    if ((CMTimeCompare(&clockTimeOuta, &time2) & 0x80000000) == 0 || v10 != v11)
    {
      memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
      if (v10 != v11) {
        goto LABEL_30;
      }
      while (1)
      {
        if (!(*(unsigned int (**)(CMClockRef, CMTime *, CMTime *))(*((void *)clock + 3) + 48))(clock, &v38, &clockTimeOuta)&& (v38.flags & 0x1D) == 1)
        {
          CMTime time = v38;
          CMTimeConvertScale(&rhs, &time, timescale, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
          CMTime v38 = rhs;
          CMTime lhs = clockTimeOuta;
        }
        FigMemoryBarrier();
        if (*((_DWORD *)clock + 51) == *((_DWORD *)clock + 50)) {
          break;
        }
        memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
LABEL_30:
        *((unsigned char *)clock + 124) = 0;
        FigMemoryBarrier();
        *((_DWORD *)clock + 51) = *((_DWORD *)clock + 50);
      }
      *((void *)clock + 16) = value;
      *((_DWORD *)clock + 34) = timescale;
      *(void *)((char *)clock + 14CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v43;
      *((_DWORD *)clock + 37) = epoch_high;
      if ((v38.flags & 0x1D) == 1)
      {
        *((unsigned char *)clock + 74) = 1;
        if (!*((unsigned char *)clock + 124))
        {
          *(CMTime *)((char *)clock + 10CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = lhs;
          CMTime rhs = v38;
          CMTime time = *(CMTime *)((char *)clock + 152);
          CMTimeSubtract(&clockTimeOuta, &rhs, &time);
          *(CMTime *)((char *)clock + 76) = clockTimeOuta;
          *((unsigned char *)clock + 124) = 1;
        }
        CMTime clockTimeOuta = v38;
        CMTime rhs = *(CMTime *)((char *)clock + 76);
        CMTimeSubtract(&v36, &clockTimeOuta, &rhs);
        CMTime clockTimeOuta = *(CMTime *)((char *)clock + 100);
        CMTime rhs = v36;
        CMTimeAdd(&v35, &clockTimeOuta, &rhs);
        CMTime rhs = v35;
        CMTime time = lhs;
        CMTimeSubtract(&clockTimeOuta, &rhs, &time);
        *(CMTime *)((char *)clock + 152) = clockTimeOuta;
      }
      else
      {
        *((unsigned char *)clock + 74) = 0;
        *((unsigned char *)clock + 124) = 0;
      }
    }
    *(void *)&clockTimeOuta.CMTimeFlags flags = v43;
    clockTimeOuta.CMTimeValue value = value;
    HIDWORD(clockTimeOuta.epoch) = epoch_high;
    clockTimeOuta.CMTimeScale timescale = timescale;
    CMTime rhs = *(CMTime *)((char *)clock + 152);
    CMTimeAdd(&time, &clockTimeOuta, &rhs);
    CMTimeValue v45 = time.value;
    CMTimeScale v46 = time.timescale;
    CMTimeEpoch epoch = time.epoch;
    CMTimeFlags v22 = time.flags & 0xFFFFFFFD;
    uint64_t v23 = (CMTimeValue *)((char *)clock + 176);
    clockTimeOuta.CMTimeValue value = time.value;
    clockTimeOuta.CMTimeScale timescale = time.timescale;
    clockTimeOuta.CMTimeFlags flags = time.flags & 0xFFFFFFFD;
    clockTimeOuta.CMTimeEpoch epoch = time.epoch;
    CMTime rhs = *(CMTime *)((char *)clock + 176);
    if (CMTimeCompare(&clockTimeOuta, &rhs) < 0 && (CMTimeFlags v24 = *((_DWORD *)clock + 47), (v24 & 0x1D) == 1))
    {
      CMTimeValue v45 = *v23;
      CMTimeScale v46 = *((_DWORD *)clock + 46);
      CMTimeEpoch epoch = *((void *)clock + 24);
      CMTimeFlags v22 = v24;
    }
    else
    {
      CMTimeValue *v23 = v45;
      *((_DWORD *)clock + 46) = v46;
      *((_DWORD *)clock + 47) = v22;
      *((void *)clock + 24) = epoch;
    }
    OSStatus v9 = 0;
    *(void *)&long long v33 = v45;
    *((void *)&v33 + 1) = __PAIR64__(v22, v46);
    CMTimeEpoch v34 = epoch;
    *(void *)&v32[0] = value;
    DWORD2(v32[0]) = timescale;
    *(void *)((char *)v32 + 12) = v43;
    CMTimeScale v25 = epoch_high;
    goto LABEL_45;
  }
  time2.CMTimeValue value = 0;
  time2.CMTimeScale timescale = 0;
  memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
  memset(&rhs, 0, sizeof(rhs));
  memset(&v38, 0, sizeof(v38));
  FigMemoryBarrier();
  int v16 = *((_DWORD *)clock + 50);
  int v15 = *((_DWORD *)clock + 51);
  uint64_t v17 = (OpaqueCMClock *)*((void *)clock + 4);
  memset(&lhs, 0, sizeof(lhs));
  CMClockGetAnchorTime(v17, &lhs, 0);
  CMTimeValue v18 = lhs.value;
  time.CMTimeValue value = *(void *)&lhs.flags;
  int32_t v19 = lhs.timescale;
  time.CMTimeScale timescale = HIDWORD(lhs.epoch);
  CMTime v36 = *(CMTime *)((char *)clock + 128);
  CMTimeSubtract(&v38, &lhs, &v36);
  CMTime lhs = v38;
  CMTime v36 = *(CMTime *)((unsigned char *)clock + 2);
  if (CMTimeCompare(&lhs, &v36) < 0 && v15 == v16 && *((unsigned char *)clock + 124)) {
    goto LABEL_46;
  }
  memset(&lhs, 0, sizeof(lhs));
  if (v15 != v16) {
    goto LABEL_48;
  }
  while (1)
  {
    if (!(*(unsigned int (**)(CMClockRef, CMTime *, CMTime *))(*((void *)clock + 3) + 48))(clock, &clockTimeOuta, &lhs)&& (clockTimeOuta.flags & 0x1D) == 1)
    {
      CMTime v35 = clockTimeOuta;
      CMTimeConvertScale(&v36, &v35, v19, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      CMTime clockTimeOuta = v36;
      CMTime rhs = lhs;
    }
    FigMemoryBarrier();
    if (*((_DWORD *)clock + 51) == *((_DWORD *)clock + 50)) {
      break;
    }
    memset(&lhs, 0, sizeof(lhs));
LABEL_48:
    FigMemoryBarrier();
    *((_DWORD *)clock + 51) = *((_DWORD *)clock + 50);
  }
  *((void *)clock + 16) = v18;
  *((_DWORD *)clock + 34) = v19;
  *(void *)((char *)clock + 14CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = time.value;
  *((_DWORD *)clock + 37) = time.timescale;
  if ((clockTimeOuta.flags & 0x1D) == 1)
  {
    long long v26 = *(_OWORD *)&rhs.value;
    *(_OWORD *)((char *)clock + 10CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&rhs.value;
    *(_OWORD *)((char *)clock + 76) = *(_OWORD *)&clockTimeOuta.value;
    *((unsigned char *)clock + 74) = 1;
    *((unsigned char *)clock + 124) = 1;
    CMTimeEpoch v27 = rhs.epoch;
    *(void *)((char *)clock + 116) = rhs.epoch;
    *(void *)((char *)clock + 92) = clockTimeOuta.epoch;
    *(void *)&v36.CMTimeFlags flags = time.value;
    HIDWORD(v36.epoch) = time.timescale;
    v36.CMTimeValue value = v18;
    v36.CMTimeScale timescale = v19;
    *(_OWORD *)&v35.CMTimeValue value = v26;
    v35.CMTimeEpoch epoch = v27;
    goto LABEL_55;
  }
  *((unsigned char *)clock + 74) = 0;
  if (*((unsigned char *)clock + 124))
  {
LABEL_46:
    v36.CMTimeValue value = v18;
    v36.CMTimeScale timescale = v19;
    *(void *)&v36.CMTimeFlags flags = time.value;
    HIDWORD(v36.epoch) = time.timescale;
    CMTime v35 = *(CMTime *)((char *)clock + 100);
LABEL_55:
    CMTimeSubtract(&lhs, &v36, &v35);
    CMTime v38 = lhs;
    CMTime v36 = lhs;
    CMTime v35 = *(CMTime *)((char *)clock + 76);
    CMTimeAdd(&lhs, &v36, &v35);
    time2.CMTimeValue value = lhs.value;
    CMTimeFlags flags = lhs.flags;
    time2.CMTimeScale timescale = lhs.timescale;
    CMTimeEpoch v6 = lhs.epoch;
    goto LABEL_56;
  }
  time2.CMTimeValue value = 0;
  time2.CMTimeScale timescale = 0;
  CMTimeFlags flags = 0;
LABEL_56:
  unsigned int v29 = flags & 0xFFFFFFFD;
  CMTime v30 = (CMTimeValue *)((char *)clock + 176);
  lhs.CMTimeValue value = time2.value;
  lhs.CMTimeScale timescale = time2.timescale;
  lhs.CMTimeFlags flags = flags & 0xFFFFFFFD;
  lhs.CMTimeEpoch epoch = v6;
  CMTime v36 = *(CMTime *)((char *)clock + 176);
  if (CMTimeCompare(&lhs, &v36) < 0 && (unsigned int v31 = *((_DWORD *)clock + 47), (v31 & 0x1D) == 1))
  {
    time2.CMTimeValue value = *v30;
    time2.CMTimeScale timescale = *((_DWORD *)clock + 46);
    CMTimeEpoch v6 = *((void *)clock + 24);
    unsigned int v29 = v31;
  }
  else
  {
    *CMTime v30 = time2.value;
    *((_DWORD *)clock + 46) = time2.timescale;
    *((_DWORD *)clock + 47) = v29;
    *((void *)clock + 24) = v6;
  }
  OSStatus v9 = 0;
  *(void *)&long long v33 = time2.value;
  *((void *)&v33 + 1) = __PAIR64__(v29, time2.timescale);
  CMTimeEpoch v34 = v6;
  *(void *)&v32[0] = v18;
  DWORD2(v32[0]) = v19;
  *(void *)((char *)v32 + 12) = time.value;
  CMTimeScale v25 = time.timescale;
LABEL_45:
  DWORD1(v32[1]) = v25;
LABEL_22:
  if (clockTimeOut)
  {
    *(_OWORD *)&clockTimeOut->CMTimeValue value = v33;
    clockTimeOut->CMTimeEpoch epoch = v34;
  }
  if (referenceClockTimeOut)
  {
    *(_OWORD *)&referenceClockTimeOut->CMTimeValue value = v32[0];
    referenceClockTimeOut->CMTimeEpoch epoch = *(void *)&v32[1];
  }
  if (clock) {
    FigReentrantMutexUnlock(*((pthread_mutex_t **)clock + 2));
  }
  return v9;
}

CMTime *__cdecl CMClockGetTime(CMTime *__return_ptr retstr, CMClockRef clock)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  return (CMTime *)CMClockGetAnchorTime(clock, retstr, 0);
}

Boolean CMClockMightDrift(CMClockRef clock, CMClockRef otherClock)
{
  if (clock == otherClock) {
    return 0;
  }
  uint64_t v2 = *((void *)clock + 3);
  if (v2 == *((void *)otherClock + 3)) {
    return (*(uint64_t (**)(void))(v2 + 32))();
  }
  else {
    return 1;
  }
}

BOOL FigDerivedClockVerifyCallbacksMatch(BOOL result, uint64_t a2)
{
  if (result) {
    return *(void *)(result + 24) == a2;
  }
  return result;
}

__CFString *fcCopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"FigClock");
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(unsigned char *)(a1 + 41))
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16);
    if (v4) {
      uint64_t v5 = (const void *)v4(a1);
    }
    else {
      uint64_t v5 = 0;
    }
    memset(&clockTimeOut, 0, sizeof(clockTimeOut));
    CMClockGetAnchorTime((CMClockRef)a1, &clockTimeOut, 0);
    CMTime v15 = clockTimeOut;
    CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
    CMTime clockTimeOut = v15;
    CFStringRef v9 = CMTimeCopyDescription(v8, &clockTimeOut);
    CMTime clockTimeOut = v15;
    Float64 Seconds = CMTimeGetSeconds(&clockTimeOut);
    if (v5) {
      CFStringAppendFormat(Mutable, 0, @"[%@]: ", v5);
    }
    else {
      CFStringAppendFormat(Mutable, 0, @": ");
    }
    CFIndex v11 = CFGetRetainCount((CFTypeRef)a1);
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
    CFStringAppendFormat(Mutable, 0, @"%p retainCount: %d allocator: %p current time: %@ = %f seconds", a1, v11, v12, v9, *(void *)&Seconds);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (v9) {
      CFRelease(v9);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"(INVALID): ");
    CFIndex v6 = CFGetRetainCount((CFTypeRef)a1);
    CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
    CFStringAppendFormat(Mutable, 0, @"%p retainCount: %d allocator: %p", a1, v6, v7);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }
  return Mutable;
}

CMClockRef CMClockGetHostTimeClock(void)
{
  return (CMClockRef)sHostTimeClock;
}

uint64_t CMClockConvertHostTimeToSystemUnits(CMTime *hostTime)
{
  memset(&v3, 0, sizeof(v3));
  CMTime v2 = *hostTime;
  CMTimeConvertScale(&v3, &v2, 1000000000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  uint64_t result = 0;
  if ((v3.flags & 0x1D) == 1) {
    return FigNanosecondsToHostTime(v3.value);
  }
  return result;
}

CMTime *__cdecl CMClockMakeHostTimeFromSystemUnits(CMTime *__return_ptr retstr, uint64_t hostTime)
{
  int64_t v3 = FigHostTimeToNanoseconds(hostTime);

  return CMTimeMake(retstr, v3, 1000000000);
}

CFStringRef fhtcCopyDebugDesc(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithCString(v1, "HostTimeClock", 0);
}

void fhtcFinalizeAndCrash()
{
  MEMORY[0x539] = 1;
}

double fhtcGetRate()
{
  return 1.0;
}

uint64_t fhtcGetAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  memset(&v7, 0, sizeof(v7));
  int64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  CMTimeMake(&v7, UpTimeNanoseconds, 1000000000);
  if (a2) {
    *a2 = v7;
  }
  if (a3) {
    *a3 = v7;
  }
  return 0;
}

uint64_t FigStartForwardingMediaServicesProcessDeathNotification(void *a1, unint64_t a2)
{
  unsigned int v4 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigMediaServicesProcessDeathMonitoringTrace[1], @"processdeathmonitoring_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v4, 0, gFigMediaServicesProcessDeathMonitoringTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EB28B5B0, @"processdeathmonitoring_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EB28B5A8);
  if (a1 && a2)
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    return FigNotificationCenterAddWeakListener(DefaultLocalCenter, a1, (CFNotificationCallback)figDependencyDeathRepostNotificationCallback, @"MediaServicesProcessDeath", a2, 0, 0);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figDependencyDeathRepostNotificationCallback(__CFNotificationCenter *a1, const void *a2, const __CFString *a3, int a4, const __CFDictionary *cf)
{
  return CMNotificationCenterPostNotification(a1, a3, a2, cf);
}

uint64_t FigStopForwardingMediaServicesProcessDeathNotification(const void *a1, const void *a2)
{
  if (a1 && a2)
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    return FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figDependencyDeathRepostNotificationCallback, @"MediaServicesProcessDeath", a2);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigStartMonitoringMediaServicesProcessDeath(void *a1)
{
  return FigStartMonitoringMediaServicesProcessDeathWithCallback(a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))figObjectDependencyDeathDefaultCallback);
}

uint64_t FigStartMonitoringMediaServicesProcessDeathWithCallback(void *a1, void (__cdecl *a2)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))
{
  unsigned int v4 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigMediaServicesProcessDeathMonitoringTrace[1], @"processdeathmonitoring_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v4, 0, gFigMediaServicesProcessDeathMonitoringTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EB28B5B0, @"processdeathmonitoring_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EB28B5A8);
  if (a1 && a2)
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    return FigNotificationCenterAddWeakListener(DefaultLocalCenter, a1, a2, @"MediaServicesProcessDeath", (unint64_t)a1, 0, 0);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t figObjectDependencyDeathDefaultCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  v24[16] = *MEMORY[0x1E4F143B8];
  unsigned int v19 = 0;
  uint64_t v18 = 0;
  uint64_t result = FigCFDictionaryGetInt64IfPresent(a5, @"ServerCapabilities", &v18);
  if (!result) {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if ((v18 & 1) == 0)
  {
    if (!FigCFDictionaryGetInt32IfPresent(a5, @"PID", &v19)) {
      FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    if (dword_1EB28B5B0)
    {
      int v17 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5A8, 1, &v17, &type);
      int v10 = v17;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v12 = v10;
      }
      else {
        unsigned int v12 = v10 & 0xFFFFFFFE;
      }
      if (v12)
      {
        *(_DWORD *)uint64_t v20 = 136315906;
        *(void *)&v20[4] = "figObjectDependencyDeathDefaultCallback";
        *(_WORD *)&v20[12] = 2048;
        *(void *)&v20[14] = a2;
        *(_WORD *)&_OWORD v20[22] = 2048;
        uint64_t v21 = a4;
        __int16 v22 = 1024;
        unsigned int v23 = v19;
        unsigned int v13 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(v1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v17;
      }
      else
      {
        unsigned int v13 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5A8, 1u, 1, v13, v13 != v24, v10, 0, v11);
    }
    uint64_t v14 = v19;
    *(void *)uint64_t v20 = 0;
    *(void *)&v20[8] = v20;
    *(void *)&v20[16] = 0x2020000000;
    CMTime v15 = (uint64_t (*)(uint64_t))getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr;
    uint64_t v21 = getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr;
    if (!getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr)
    {
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3221225472;
      int v24[2] = __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke;
      v24[3] = &unk_1E5677820;
      v24[4] = v20;
      __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke((uint64_t)v24);
      CMTime v15 = *(uint64_t (**)(uint64_t))(*(void *)&v20[8] + 24);
    }
    _Block_object_dispose(v20, 8);
    if (!v15) {
      figObjectDependencyDeathDefaultCallback_cold_1();
    }
    return v15(v14);
  }
  return result;
}

void sub_18FD60018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FigStopMonitoringMediaServicesProcessDeath(const void *a1)
{
  return FigStopMonitoringMediaServicesProcessDeathWithCallback(a1, (uint64_t)figObjectDependencyDeathDefaultCallback);
}

uint64_t FigStopMonitoringMediaServicesProcessDeathWithCallback(const void *a1, uint64_t a2)
{
  if (a1 && a2)
  {
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    return FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, a2, @"MediaServicesProcessDeath", a1);
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

void *__getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!MediaToolboxLibraryCore_frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    v4[3] = __MediaToolboxLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    void v4[5] = v4;
    long long v5 = xmmword_1E5677C88;
    uint64_t v6 = 0;
    MediaToolboxLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  CMTime v2 = (void *)MediaToolboxLibraryCore_frameworkLibrary;
  if (!MediaToolboxLibraryCore_frameworkLibrary) {
    __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke_cold_1(v4);
  }
  if (v4[0]) {
    free(v4[0]);
  }
  uint64_t result = dlsym(v2, "FigAudioSessionTriggerAVAudioSessionReset");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                           + 24);
  return result;
}

uint64_t __MediaToolboxLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  MediaToolboxLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t FigEndpointStreamResume(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, void, void))(v5 + 16);
  if (!v6) {
    return 4294954514;
  }

  return v6(a1, a2, 0, 0);
}

uint64_t FigEndpointStreamSuspend(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, void, void))(v5 + 8);
  if (!v6) {
    return 4294954514;
  }

  return v6(a1, a2, 0, 0);
}

uint64_t FigEndpointStreamResumeSync(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int valuePtr = 0;
  if (a3) {
    dispatch_time_t v5 = dispatch_time(0, 1000000 * a3);
  }
  else {
    dispatch_time_t v5 = -1;
  }
  SyncContext = (dispatch_object_t *)endpointStreamUtil_createSyncContext();
  if (!SyncContext)
  {
    FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
    return valuePtr;
  }
  uint64_t v7 = SyncContext;
  dispatch_object_t v8 = SyncContext[1];
  if (v8) {
    CFArrayRef v9 = (const __CFArray *)CFRetain(v8);
  }
  else {
    CFArrayRef v9 = 0;
  }
  int v10 = *v7;
  dispatch_retain(*v7);
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  unsigned int v13 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(uint64_t, int, uint64_t), dispatch_object_t *))(v12 + 16);
  if (!v13)
  {
    unsigned int valuePtr = -12782;
    goto LABEL_18;
  }
  unsigned int valuePtr = v13(a1, a2, endpointStreamUtil_completionCallback, v7);
  if (valuePtr) {
    goto LABEL_18;
  }
  if (!dispatch_semaphore_wait(v10, v5))
  {
    if (CFArrayGetCount(v9) >= 1)
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v9, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
      if (!v9) {
        goto LABEL_20;
      }
LABEL_19:
      CFRelease(v9);
      goto LABEL_20;
    }
LABEL_18:
    if (!v9) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  unsigned int valuePtr = -16764;
  if (v9) {
    goto LABEL_19;
  }
LABEL_20:
  if (v10) {
    dispatch_release(v10);
  }
  return valuePtr;
}

void *endpointStreamUtil_createSyncContext()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  if (v0
    && (CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]),
        (v0[1] = Mutable) != 0))
  {
    *uint64_t v0 = dispatch_semaphore_create(0);
  }
  else if (FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0))
  {
    free(v0);
    return 0;
  }
  return v0;
}

void endpointStreamUtil_completionCallback(uint64_t a1, int a2, uint64_t a3)
{
  int valuePtr = a2;
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 8), v4);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)a3);
  if (*(void *)a3) {
    dispatch_release(*(dispatch_object_t *)a3);
  }
  dispatch_time_t v5 = *(const void **)(a3 + 8);
  if (v5) {
    CFRelease(v5);
  }
  free((void *)a3);
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t FigEndpointStreamSuspendSync(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int valuePtr = 0;
  if (a3) {
    dispatch_time_t v5 = dispatch_time(0, 1000000 * a3);
  }
  else {
    dispatch_time_t v5 = -1;
  }
  SyncContext = (dispatch_object_t *)endpointStreamUtil_createSyncContext();
  if (!SyncContext)
  {
    FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
    return valuePtr;
  }
  uint64_t v7 = SyncContext;
  dispatch_object_t v8 = SyncContext[1];
  if (v8) {
    CFArrayRef v9 = (const __CFArray *)CFRetain(v8);
  }
  else {
    CFArrayRef v9 = 0;
  }
  int v10 = *v7;
  dispatch_retain(*v7);
  uint64_t v11 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  unsigned int v13 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(uint64_t, int, uint64_t), dispatch_object_t *))(v12 + 8);
  if (!v13)
  {
    unsigned int valuePtr = -12782;
    goto LABEL_18;
  }
  unsigned int valuePtr = v13(a1, a2, endpointStreamUtil_completionCallback, v7);
  if (valuePtr) {
    goto LABEL_18;
  }
  if (!dispatch_semaphore_wait(v10, v5))
  {
    if (CFArrayGetCount(v9) >= 1)
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v9, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
      if (!v9) {
        goto LABEL_20;
      }
LABEL_19:
      CFRelease(v9);
      goto LABEL_20;
    }
LABEL_18:
    if (!v9) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  unsigned int valuePtr = -16764;
  if (v9) {
    goto LABEL_19;
  }
LABEL_20:
  if (v10) {
    dispatch_release(v10);
  }
  return valuePtr;
}

uint64_t FigControlCommandsStartServer()
{
  unsigned int v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigControlCommandsXPCServerTrace[1], @"controlcommandsserver_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigControlCommandsXPCServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272E98, @"controlcommandsserver_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272E90);
  v5[0] = 1;
  v5[1] = HandleControlCommandsServerRemoteMessage;
  v5[2] = HandleControlCommandsServerRemoteMessageNoReply;
  memset(&v5[3], 0, 24);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigCFDictionarySetValue(Mutable, @"xpcServerOption_OptOutOfPurge", (const void *)*MEMORY[0x1E4F1CFD0]);
  if (FigServer_IsMediaparserd())
  {
    uint64_t v2 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    if (Mutable) {
LABEL_3:
    }
      CFRelease(Mutable);
  }
  else
  {
    if (FigServer_IsMediaplaybackd()) {
      CFNumberRef v4 = "com.apple.coremedia.mediaplaybackd.controlcommands.xpc";
    }
    else {
      CFNumberRef v4 = "com.apple.coremedia.logging.xpc";
    }
    uint64_t v2 = FigXPCServerStart((uint64_t)v4, v5, 0, &gControlCommandsServer);
    FigInstallSysdiagnoseBlock(@"CoreMediaPreferences", (uint64_t)&__block_literal_global_9);
    if (Mutable) {
      goto LABEL_3;
    }
  }
  return v2;
}

uint64_t HandleControlCommandsServerRemoteMessage(uint64_t a1, void *a2, void *a3)
{
  int v15 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v15);
  if (OpCode) {
    return OpCode;
  }
  if (v15 != 1885827696) {
    return 4294951145;
  }
  uint64_t v18 = 0;
  unsigned int v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 0;
  char v17 = 0;
  int64_t int64 = xpc_dictionary_get_int64(a2, "Pid");
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"|%-80s|%-20s|%-64s|%-32s|\n", "Server", "Purged", "Purge Identifier", "Could Not Purge All Objects");
  if (xpc_dictionary_get_BOOL(a2, "ForcePurge")) {
    goto LABEL_6;
  }
  uint64_t PurgeEligibilityForPID = FigPurgeAndRenewProcessStateTrackerGetPurgeEligibilityForPID(int64, &v17);
  if (PurgeEligibilityForPID)
  {
    uint64_t v9 = PurgeEligibilityForPID;
    goto LABEL_7;
  }
  if (v17)
  {
    uint64_t v9 = 0;
    *((unsigned char *)v19 + 24) = 1;
  }
  else
  {
LABEL_6:
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 0x40000000;
    int v16[2] = __HandleLoggingPurgeObjectsAndGenerateReportForPID_block_invoke;
    v16[3] = &unk_1E5677CC8;
    v16[4] = &v18;
    v16[5] = Mutable;
    FigXPCPurgeObjectsForPIDWithReportingBlock(int64, (uint64_t)v16);
    uint64_t v9 = 0;
  }
LABEL_7:
  int v10 = (const void *)*MEMORY[0x1E4F1CFD0];
  uint64_t v11 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (*((unsigned char *)v19 + 24)) {
    uint64_t v12 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    uint64_t v12 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  FigXPCMessageSetCFBoolean(a3, "CouldNotPurgeAllObjects", v12);
  if (v17) {
    unsigned int v13 = v10;
  }
  else {
    unsigned int v13 = v11;
  }
  FigXPCMessageSetCFBoolean(a3, "PurgeProhibited", v13);
  FigXPCMessageSetCFString(a3, "Stats", Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  _Block_object_dispose(&v18, 8);
  return v9;
}

uint64_t HandleControlCommandsServerRemoteMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  int v4 = 0;
  uint64_t result = FigXPCMessageGetOpCode(a2, &v4);
  if (!result)
  {
    if (v4 == 1819242352)
    {
      unint64_t v5 = 0;
      uint64_t result = FigXPCServerAssociateObjectWithConnection(a1, @"Loopback", @"refcon", (uint64_t)AirPlayLoopbackDispose, 0, &v5);
      if (!result)
      {
        if (setenv("ENABLE_BUFFERED_LOCAL_PLAYBACK", "1", 1))
        {
          return 4294948106;
        }
        else
        {
          FigAtomicIncrement32(gEnableBufferedAirplayEnvClientCount);
          return 0;
        }
      }
    }
    else
    {
      return 4294951145;
    }
  }
  return result;
}

void __FigControlCommandsStartServer_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (dword_1E9272E98)
  {
    v6[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E90, 1, v6, &type);
    int v1 = v6[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v3 = v1;
    }
    else {
      unsigned int v3 = v1 & 0xFFFFFFFE;
    }
    if (v3)
    {
      v6[1] = 136315138;
      uint64_t v7 = "DumpCoreMediaPreferences";
      int v4 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v1) = v6[0];
    }
    else
    {
      int v4 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E90, 1u, 1, v4, v4 != &v8, v1, 0, v2);
  }
  DumpPreferencesToLog(@"com.apple.coremedia");
  DumpPreferencesToLog(@"com.apple.coremedia.bag");
  DumpPreferencesToLog(@"com.apple.avfoundation");
}

void __HandleLoggingPurgeObjectsAndGenerateReportForPID_block_invoke(uint64_t a1, uint64_t a2, xpc_object_t xarray, uint64_t a4, unsigned int a5)
{
  uint64_t v9 = *(__CFString **)(a1 + 40);
  if (xarray) {
    size_t count = xpc_array_get_count(xarray);
  }
  else {
    size_t count = 0;
  }
  CFStringAppendFormat(v9, 0, @"|%-80s|%-20ld|%-64lld|%-32d|\n", a2, count, a4, a5);
  if (a5) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

uint64_t AirPlayLoopbackDispose()
{
  uint64_t result = FigAtomicDecrement32(gEnableBufferedAirplayEnvClientCount);
  if (!result)
  {
    return unsetenv("ENABLE_BUFFERED_LOCAL_PLAYBACK");
  }
  return result;
}

void DumpPreferencesToLog(const __CFString *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
  CFStringRef v3 = (const __CFString *)*MEMORY[0x1E4F1D3C8];
  CFArrayRef v4 = CFPreferencesCopyKeyList(a1, (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (v4)
  {
    CFArrayRef v5 = v4;
    CFIndex Count = CFArrayGetCount(v4);
    if (dword_1E9272E98)
    {
      int v26 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E90, 1, &v26, &type);
      int v8 = v26;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v10 = v8;
      }
      else {
        unsigned int v10 = v8 & 0xFFFFFFFE;
      }
      if (v10)
      {
        int v27 = 136315650;
        double v28 = "DumpPreferencesToLog";
        __int16 v29 = 2114;
        CFStringRef v30 = a1;
        __int16 v31 = 2050;
        CFIndex v32 = Count;
        uint64_t v11 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v8) = v26;
      }
      else
      {
        uint64_t v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E90, 1u, 1, v11, v11 != v35, v8, 0, v9);
    }
    if (Count >= 1)
    {
      CFIndex v12 = 0;
      CFArrayRef v24 = v5;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v12);
        CFPropertyListRef v14 = CFPreferencesCopyValue(ValueAtIndex, a1, v2, v3);
        if (ValueAtIndex)
        {
          int v15 = v14;
          if (v14)
          {
            if (dword_1E9272E98)
            {
              CFIndex v16 = Count;
              CFStringRef v17 = v3;
              CFStringRef v18 = v2;
              int v26 = 0;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              unsigned int v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272E90, 1, &v26, &type);
              int v20 = v26;
              if (os_log_type_enabled(v19, type)) {
                unsigned int v22 = v20;
              }
              else {
                unsigned int v22 = v20 & 0xFFFFFFFE;
              }
              if (v22)
              {
                int v27 = 136315906;
                double v28 = "DumpPreferencesToLog";
                __int16 v29 = 2114;
                CFStringRef v30 = a1;
                __int16 v31 = 2114;
                CFIndex v32 = (CFIndex)ValueAtIndex;
                __int16 v33 = 2114;
                CMTimeEpoch v34 = v15;
                unsigned int v23 = (unsigned char *)_os_log_send_and_compose_impl();
                LOBYTE(v2CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v26;
              }
              else
              {
                unsigned int v23 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272E90, 1u, 1, v23, v23 != v35, v20, 0, v21);
              CFStringRef v2 = v18;
              CFStringRef v3 = v17;
              CFIndex Count = v16;
              CFArrayRef v5 = v24;
            }
            CFRelease(v15);
          }
        }
        ++v12;
      }
      while (Count != v12);
    }
    CFRelease(v5);
  }
}

Float64 CMSyncGetRelativeRate(CMClockOrTimebaseRef ofClockOrTimebase, CMClockOrTimebaseRef relativeToClockOrTimebase)
{
  uint64_t v7 = 0;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  int PivotTransform = figSyncGetPivotTransform((void *)relativeToClockOrTimebase, (void *)ofClockOrTimebase, (uint64_t)&v4);
  Float64 result = *((double *)&v5 + 1);
  if (PivotTransform) {
    return NAN;
  }
  return result;
}

OSStatus CMSyncGetRelativeRateAndAnchorTime(CMClockOrTimebaseRef ofClockOrTimebase, CMClockOrTimebaseRef relativeToClockOrTimebase, Float64 *outRelativeRate, CMTime *outOfClockOrTimebaseAnchorTime, CMTime *outRelativeToClockOrTimebaseAnchorTime)
{
  CMTimeEpoch v12 = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  OSStatus result = figSyncGetPivotTransform((void *)relativeToClockOrTimebase, (void *)ofClockOrTimebase, (uint64_t)&v9);
  if (!result)
  {
    if (outRelativeRate) {
      *outRelativeRate = *((Float64 *)&v10 + 1);
    }
    if (outOfClockOrTimebaseAnchorTime)
    {
      *(_OWORD *)&outOfClockOrTimebaseAnchorTime->CMTimeValue value = v11;
      outOfClockOrTimebaseAnchorTime->CMTimeEpoch epoch = v12;
    }
    if (outRelativeToClockOrTimebaseAnchorTime)
    {
      *(_OWORD *)&outRelativeToClockOrTimebaseAnchorTime->CMTimeValue value = v9;
      outRelativeToClockOrTimebaseAnchorTime->CMTimeEpoch epoch = v10;
    }
  }
  return result;
}

CMTime *__cdecl CMSyncConvertTime(CMTime *__return_ptr retstr, CMTime *time, CMClockOrTimebaseRef fromClockOrTimebase, CMClockOrTimebaseRef toClockOrTimebase)
{
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (fromClockOrTimebase && toClockOrTimebase && (time->flags & 0x1D) == 1)
  {
    uint64_t v9 = 0;
    memset(v8, 0, sizeof(v8));
    OSStatus result = (CMTime *)figSyncGetPivotTransform((void *)fromClockOrTimebase, (void *)toClockOrTimebase, (uint64_t)v8);
    if (!result)
    {
      CMTime v7 = *time;
      return FigSyncApplyTransform(&v7, (uint64_t)v8, retstr);
    }
  }
  else
  {
    return (CMTime *)FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

Boolean CMSyncMightDrift(CMClockOrTimebaseRef clockOrTimebase1, CMClockOrTimebaseRef clockOrTimebase2)
{
  if (clockOrTimebase1 && clockOrTimebase2)
  {
    CFStringRef v3 = (OpaqueCMClock *)figSyncCopyUltimateMasterClockAndHeight((void *)clockOrTimebase1, 0);
    long long v4 = (OpaqueCMClock *)figSyncCopyUltimateMasterClockAndHeight((void *)clockOrTimebase2, 0);
    Boolean v5 = CMClockMightDrift(v3, v4);
    if (v3) {
      CFRelease(v3);
    }
    if (v4) {
      CFRelease(v4);
    }
  }
  else
  {
    FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
    return 1;
  }
  return v5;
}

CMTime *__cdecl CMSyncGetTime(CMTime *__return_ptr retstr, CMClockOrTimebaseRef clockOrTimebase)
{
  if (clockOrTimebase)
  {
    CFTypeID v4 = CFGetTypeID(clockOrTimebase);
    if (v4 == CMClockGetTypeID())
    {
      return CMClockGetTime(retstr, (CMClockRef)clockOrTimebase);
    }
    else
    {
      return CMTimebaseGetTime(retstr, (CMTimebaseRef)clockOrTimebase);
    }
  }
  else
  {
    OSStatus result = (CMTime *)FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
    *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
    retstr->CMTimeEpoch epoch = 0;
  }
  return result;
}

uint64_t FigClockConvertHostTimeToSystemUnits(CMTime *a1)
{
  CMTime v2 = *a1;
  return CMClockConvertHostTimeToSystemUnits(&v2);
}

uint64_t FigTimebaseSetTimerDispatchSourceNextFireTime(OpaqueCMTimebase *a1, NSObject *a2, CMTime *a3)
{
  CMTime v4 = *a3;
  return CMTimebaseSetTimerDispatchSourceNextFireTime(a1, a2, &v4, 0);
}

pthread_mutex_t *figSyncCopyUltimateMasterClockAndHeight(void *a1, pthread_mutex_t **a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CMClockGetTypeID())
  {
    if (a2) {
      *a2 = 0;
    }
    CFRetain(a1);
    return (pthread_mutex_t *)a1;
  }
  else
  {
    return FigTimebaseCopyUltimateMasterClockAndHeight((pthread_mutex_t **)a1, a2);
  }
}

CFTypeID CMTimebaseGetTypeID(void)
{
  return sFigTimebaseID;
}

uint64_t CMTimebaseCreateReadOnlyTimebaseWithFlags(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, char a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  uint64_t v6 = 4294954548;
  if (a2 && a6)
  {
    uint64_t v6 = figTimebaseCreate(a1, a5, &cf);
    if (v6) {
      goto LABEL_5;
    }
    *((_DWORD *)cf + 4) = 2;
    CFTypeRef v11 = CFRetain(a2);
    CMTimeEpoch v12 = cf;
    *((void *)cf + 3) = v11;
    v12[4] = a3;
    v12[5] = a4;
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    uint64_t v6 = FigNotificationCenterAddWeakListener(DefaultLocalCenter, v12, (CFNotificationCallback)figTimebaseReflectNotification, 0, (unint64_t)v11, 2, 0);
    if (v6)
    {
LABEL_5:
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *a6 = cf;
    }
  }
  return v6;
}

uint64_t CMTimebaseCreateReadOnlyTimebase(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  return CMTimebaseCreateReadOnlyTimebaseWithFlags(a1, a2, a3, a4, 0, a5);
}

uint64_t CMTimebaseCreateLoopingTimebase(uint64_t a1, long long *a2, const void *a3, OpaqueCMTimebase **a4)
{
  __int16 v29 = 0;
  if (!a3 || !a4)
  {
    uint64_t v9 = 4294954548;
    if (!a4) {
      return v9;
    }
    goto LABEL_20;
  }
  int v6 = *((_DWORD *)a2 + 3);
  if ((v6 & 1) == 0 || (int v7 = *((_DWORD *)a2 + 9), (v7 & 1) == 0) || *((void *)a2 + 5))
  {
    int v8 = 0;
    uint64_t v9 = 4294954547;
    goto LABEL_7;
  }
  int v8 = 0;
  uint64_t v9 = 4294954547;
  if (((v7 | v6) & 0x10) != 0 || (*((void *)a2 + 3) & 0x8000000000000000) != 0) {
    goto LABEL_7;
  }
  *(_OWORD *)&time1.start.CMTimeValue value = *(long long *)((char *)a2 + 24);
  time1.start.CMTimeEpoch epoch = *((void *)a2 + 5);
  *(_OWORD *)&time2.CMTimeValue value = *(_OWORD *)&kCMTimeZero.value;
  time2.CMTimeEpoch epoch = 0;
  if (!CMTimeCompare(&time1.start, &time2))
  {
LABEL_20:
    int v8 = 0;
    goto LABEL_7;
  }
  uint64_t v13 = figTimebaseCreate(a1, 0, &v29);
  int v8 = (OpaqueCMTimebase *)v29;
  if (v13) {
    goto LABEL_17;
  }
  *((_DWORD *)v29 + 4) = 1;
  long long v14 = *a2;
  long long v15 = a2[2];
  *((_OWORD *)v8 + 4) = a2[1];
  *((_OWORD *)v8 + 5) = v15;
  *((_OWORD *)v8 + 3) = v14;
  CFIndex v16 = CFRetain(a3);
  CFStringRef v17 = v29;
  v29[17] = v16;
  uint64_t UltimateMasterClock = figTimebaseFindUltimateMasterClock((pthread_mutex_t **)v17, (uint64_t *)v17 + 19);
  if (UltimateMasterClock) {
    uint64_t UltimateMasterClock = CFRetain(UltimateMasterClock);
  }
  unsigned int v19 = v29;
  v29[18] = UltimateMasterClock;
  *((_OWORD *)v19 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&kCMTimeZero.value;
  v19[22] = 0;
  v19[23] = (dispatch_object_t)0x3FF0000000000000;
  *((_OWORD *)v19 + 12) = *(_OWORD *)&kCMTimeZero.value;
  v19[26] = 0;
  *((unsigned char *)v19 + 216) = 0;
  int v20 = dispatch_queue_create("com.apple.timebase.loop", 0);
  v29[12] = v20;
  dispatch_source_t v21 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v20);
  uint64_t v22 = (uint64_t)v29;
  v29[13] = v21;
  unsigned int v23 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v22);
  dispatch_set_context(v29[13], v23);
  dispatch_source_set_event_handler_f(v29[13], (dispatch_function_t)figTimebaseLoopEndTimerCallback);
  dispatch_source_set_cancel_handler_f(v29[13], (dispatch_function_t)figTimebaseLoopEndTimerCancelCallback);
  dispatch_resume(v29[13]);
  uint64_t v13 = CMTimebaseAddTimerDispatchSource((CMTimebaseRef)v29, v29[13]);
  int v8 = (OpaqueCMTimebase *)v29;
  if (v13
    || (uint64_t v13 = figTimebaseSwitchListenersToNewMaster(v29, 0, (unint64_t)a3),
        int v8 = (OpaqueCMTimebase *)v29,
        v13))
  {
LABEL_17:
    uint64_t v9 = v13;
  }
  else
  {
    CFArrayRef v24 = v29[13];
    long long v25 = a2[1];
    *(_OWORD *)&time1.start.CMTimeValue value = *a2;
    *(_OWORD *)&time1.start.CMTimeEpoch epoch = v25;
    *(_OWORD *)&time1.duration.CMTimeScale timescale = a2[2];
    CMTimeRangeGetEnd(&fireTime, &time1);
    uint64_t v9 = CMTimebaseSetTimerDispatchSourceNextFireTime(v8, v24, &fireTime, 0);
    int v8 = (OpaqueCMTimebase *)v29;
    if (!v9) {
      goto LABEL_7;
    }
  }
  if (v8)
  {
    CFRelease(v8);
    goto LABEL_20;
  }
LABEL_7:
  *a4 = v8;
  return v9;
}

void figTimebaseLoopEndTimerCallback(id *a1)
{
  int v1 = (pthread_mutex_t **)FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    CMTime v2 = v1;
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v1, 1, 0, &v4);
    CMTime v4 = *(CMTime *)((unsigned char *)v2 + 8);
    CMTime v3 = *(CMTime *)(v2 + 20);
    figTimebaseSetAnchorTimeMaybeNowMaybeNotifying((uint64_t)v2, &v4, &v3, 0, 1);
    CFRelease(v2);
  }
}

void figTimebaseLoopEndTimerCancelCallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

OSStatus CMTimebaseAddTimerDispatchSource(CMTimebaseRef timebase, dispatch_source_t timerSource)
{
  OSStatus v2 = -12748;
  if (!timebase || !timerSource) {
    return v2;
  }
  if (!dispatch_source_testcancel(timerSource))
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    CFDictionaryRef v6 = (const __CFDictionary *)*((void *)timebase + 38);
    if (!v6)
    {
      keyCallBacks.version = 0;
      keyCallBacks.retain = (CFDictionaryRetainCallBack)cfDispatchSourceRetain;
      keyCallBacks.release = (CFDictionaryReleaseCallBack)cfDispatchSourceRelease;
      memset(&keyCallBacks.copyDescription, 0, 24);
      valueCallBacks.version = 0;
      valueCallBacks.retain = (CFDictionaryRetainCallBack)cfDataFigTimeRetain;
      valueCallBacks.release = (CFDictionaryReleaseCallBack)cfDataFigTimeRelease;
      valueCallBacks.equal = (CFDictionaryEqualCallBack)cfDataFigTimeEqual;
      valueCallBacks.copyDescription = (CFDictionaryCopyDescriptionCallBack)cfDataFigTimeCopyDescription;
      CFAllocatorRef v7 = CFGetAllocator(timebase);
      CFDictionaryRef v6 = CFDictionaryCreateMutable(v7, 0, &keyCallBacks, &valueCallBacks);
      *((void *)timebase + 38) = v6;
      if (!v6) {
        goto LABEL_16;
      }
    }
    if (!*((void *)timebase + 39))
    {
      CFAllocatorRef v8 = CFGetAllocator(timebase);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v8, 0, 0, 0);
      *((void *)timebase + 39) = Mutable;
      if (!Mutable) {
        goto LABEL_16;
      }
      CFDictionaryRef v6 = (const __CFDictionary *)*((void *)timebase + 38);
    }
    if (CFDictionaryContainsKey(v6, timerSource))
    {
LABEL_15:
      OSStatus v2 = 0;
LABEL_17:
      FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
      return v2;
    }
    CFAllocatorRef v10 = CFGetAllocator(timebase);
    CFDataRef v11 = CFDataCreate(v10, (const UInt8 *)&kCMTimeInvalid, 24);
    if (v11)
    {
      CFDataRef v12 = v11;
      dispatch_source_set_timer(timerSource, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource, v12);
      CFRelease(v12);
      goto LABEL_15;
    }
LABEL_16:
    OSStatus v2 = FigSignalErrorAt(4294954546, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }

  return FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTimebaseSetTimerDispatchSourceNextFireTime(CMTimebaseRef timebase, dispatch_source_t timerSource, CMTime *fireTime, uint32_t flags)
{
  OSStatus v4 = -12748;
  if (timebase && timerSource)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    CFDictionaryRef v9 = (const __CFDictionary *)*((void *)timebase + 38);
    if (!v9 || !CFDictionaryContainsKey(v9, timerSource))
    {
      OSStatus v4 = -12749;
      goto LABEL_10;
    }
    if (dispatch_source_testcancel(timerSource))
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource);
      uint64_t v10 = 4294954547;
    }
    else
    {
      CFAllocatorRef v11 = CFGetAllocator(timebase);
      CFDataRef v12 = CFDataCreate(v11, (const UInt8 *)fireTime, 24);
      if (v12)
      {
        CFDataRef v13 = v12;
        CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource, v12);
        CFRelease(v13);
        CFDictionarySetValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource, (const void *)flags);
        figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, &v16);
        CMTime v15 = *fireTime;
        rescheduleTimerSource(timerSource, &v15, timebase, &v16, 2, flags);
        OSStatus v4 = 0;
        goto LABEL_10;
      }
      uint64_t v10 = 4294954546;
    }
    OSStatus v4 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
LABEL_10:
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v4;
}

uint64_t FigReadOnlyTimebaseSetTargetTimebase(uint64_t a1, pthread_mutex_t **cf)
{
  memset(&v34, 0, sizeof(v34));
  TransformRelativeTouint64_t UltimateMasterClock = 4294954548;
  if (!a1 || !cf) {
    return TransformRelativeToUltimateMasterClock;
  }
  if (!*(void *)(a1 + 24) || figTimebaseIsDescendantOfTimebase(cf, (pthread_mutex_t *)a1)) {
    return 4294954547;
  }
  *(_OWORD *)multiplier = 0u;
  memset(&v33, 0, sizeof(v33));
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  memset(&v30, 0, sizeof(v30));
  CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &v27);
  CFDictionaryRef v6 = figTimebaseCreatePayloadForNotificationAtTime(v5, &v27);
  if (!v6) {
    return 4294954546;
  }
  CFDictionaryRef v7 = v6;
  figTimebasePostNotification((void *)a1, @"CMTimebaseMasterWillChange", v6);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
  CFAllocatorRef v8 = *(pthread_mutex_t ***)(a1 + 24);
  if (v8 == cf)
  {
    TransformRelativeTouint64_t UltimateMasterClock = 0;
    uint64_t v10 = 0;
    goto LABEL_50;
  }
  FigReentrantMutexLock(v8[14]);
  double EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)v8);
  uint64_t v10 = FigTimebaseCopyUltimateMasterClockAndHeight(v8, 0);
  TransformRelativeTouint64_t UltimateMasterClock = FigTimebaseGetTransformRelativeToUltimateMasterClock(v8, 1, (uint64_t)&v31);
  FigReentrantMutexUnlock(v8[14]);
  if (TransformRelativeToUltimateMasterClock)
  {
LABEL_50:
    CFDataRef v12 = 0;
LABEL_52:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    goto LABEL_54;
  }
  FigReentrantMutexLock(cf[14]);
  double v11 = CMTimebaseGetEffectiveRate((CMTimebaseRef)cf);
  CFDataRef v12 = FigTimebaseCopyUltimateMasterClockAndHeight(cf, 0);
  uint64_t v13 = FigTimebaseGetTransformRelativeToUltimateMasterClock(cf, 1, (uint64_t)&v28);
  if (v13)
  {
    TransformRelativeTouint64_t UltimateMasterClock = v13;
    FigReentrantMutexUnlock(cf[14]);
    goto LABEL_52;
  }
  memset(&v39, 0, sizeof(v39));
  memset(&v38, 0, sizeof(v38));
  memset(&v37, 0, sizeof(v37));
  if (CFEqual(v10, v12) && multiplier[1] == *((double *)&v29 + 1))
  {
    CMTime lhs = v33;
    CMTime rhs = v30;
    CMTimeSubtract(&v39, &lhs, &rhs);
    *(_OWORD *)&lhs.CMTimeValue value = v31;
    *(Float64 *)&lhs.CMTimeEpoch epoch = multiplier[0];
    *(_OWORD *)&rhs.CMTimeValue value = v28;
    rhs.CMTimeEpoch epoch = v29;
    CMTimeSubtract(&v38, &lhs, &rhs);
    CMTime lhs = v38;
    CMTimeMultiplyByFloat64(&v37, &lhs, multiplier[1]);
    CMTime lhs = v37;
    CMTime rhs = v39;
    BOOL v14 = CMTimeCompare(&lhs, &rhs) != 0;
  }
  else
  {
    BOOL v14 = 1;
  }
  *(void *)(a1 + 24) = cf;
  CFRetain(cf);
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)a1, (CFNotificationCallback)figTimebaseReflectNotification, 0, (unint64_t)cf, 2, 0);
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(cf, 1, 0, &v34);
  FigReentrantMutexUnlock(cf[14]);
  BOOL v16 = EffectiveRate == v11 && !v14;
  int v17 = !v16;
  if (!v16)
  {
    double v18 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    int v19 = *(_DWORD *)(a1 + 320);
    if (v18 > 0.0) {
      int v20 = 1;
    }
    else {
      int v20 = -1;
    }
    if (v18 == 0.0) {
      int v20 = *(_DWORD *)(a1 + 320);
    }
    *(_DWORD *)(a1 + 32CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v20;
    int v22 = !v14 && v19 == v20;
    if (*(void *)(a1 + 280))
    {
      CMTime v39 = v34;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &v39, v22);
    }
    if (*(void *)(a1 + 304))
    {
      CMTime v39 = v34;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &v39, v22);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  TransformRelativeTouint64_t UltimateMasterClock = figTimebaseUninstallReadOnlyTimebaseNotifications((const void *)a1, v8);
  CFRelease(v8);
  CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
  CMTime v39 = v34;
  CFDictionaryRef v24 = figTimebaseCreatePayloadForNotificationAtTime(v23, &v39);
  if (v24)
  {
    CFDictionaryRef v25 = v24;
    figTimebasePostNotification((void *)a1, @"CMTimebaseMasterDidChange", v24);
    if (v17)
    {
      if (EffectiveRate != v11) {
        figTimebasePostNotification((void *)a1, @"CMTimebaseEffectiveRateChanged", v25);
      }
      if (v14) {
        figTimebasePostNotification((void *)a1, @"CMTimebaseTimeJumped", v25);
      }
    }
    CFRelease(v7);
    goto LABEL_43;
  }
  TransformRelativeTouint64_t UltimateMasterClock = 4294954546;
LABEL_54:
  figTimebasePostNotification((void *)a1, @"CMTimebaseMasterDidChange", v7);
  CFDictionaryRef v25 = v7;
LABEL_43:
  CFRelease(v25);
  if (v10) {
    CFRelease(v10);
  }
  if (v12) {
    CFRelease(v12);
  }
  return TransformRelativeToUltimateMasterClock;
}

uint64_t figTimebaseIsDescendantOfTimebase(pthread_mutex_t **cf, pthread_mutex_t *a2)
{
  if (cf == (pthread_mutex_t **)a2) {
    return 1;
  }
  OSStatus v2 = cf;
  if (!cf) {
    return 0;
  }
  CFRetain(cf);
  while (1)
  {
    FigReentrantMutexLock(v2[14]);
    OSStatus v4 = v2[3];
    if (!v4)
    {
      OSStatus v4 = v2[17];
      if (!v4) {
        break;
      }
    }
    CFRetain(v4);
    FigReentrantMutexUnlock(v2[14]);
    if (v4 == a2)
    {
      CFRelease(a2);
      uint64_t v5 = 1;
      goto LABEL_12;
    }
    CFRetain(v4);
    CFRelease(v2);
    CFRelease(v4);
    OSStatus v2 = (pthread_mutex_t **)v4;
  }
  FigReentrantMutexUnlock(v2[14]);
  uint64_t v5 = 0;
LABEL_12:
  CFRelease(v2);
  return v5;
}

CFDictionaryRef figTimebaseCreatePayloadForNotificationAtTime(CFAllocatorRef allocator, CMTime *a2)
{
  CMTime cf = *a2;
  cf.CMTimeValue value = (CMTimeValue)CMTimeCopyAsDictionary(&cf, allocator);
  if (!cf.value) {
    return 0;
  }
  CFDictionaryRef v3 = CFDictionaryCreate(allocator, (const void **)&kCMTimebaseNotificationKey_EventTime, (const void **)&cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (cf.value) {
    CFRelease((CFTypeRef)cf.value);
  }
  return v3;
}

CMTime *__cdecl CMTimebaseGetTime(CMTime *__return_ptr retstr, CMTimebaseRef timebase)
{
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, retstr);
  return result;
}

uint64_t figTimebasePostNotification(void *a1, const __CFString *a2, const void *a3)
{
  CFDictionaryRef v6 = a1[15];
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  if (v6)
  {
    return FigDispatchAsyncPostNotification(v6, DefaultLocalCenter, a2, a1, a3, 0);
  }
  else
  {
    return CMNotificationCenterPostNotification(DefaultLocalCenter, a2, a1, (const __CFDictionary *)a3);
  }
}

Float64 CMTimebaseGetEffectiveRate(CMTimebaseRef timebase)
{
  if (!timebase) {
    return 0.0;
  }
  int v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  double Rate = CMTimebaseGetRate((CMTimebaseRef)v1);
  if (Rate == 0.0)
  {
    Relativedouble Rate = Rate;
    OSStatus v4 = 0;
    if (!v1) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  OSStatus v4 = FigTimebaseCopyUltimateMasterClockAndHeight(v1, 0);
  Relativedouble Rate = CMSyncGetRelativeRate(v1, v4);
  if (v1) {
LABEL_4:
  }
    CFRelease(v1);
LABEL_5:
  if (v4) {
    CFRelease(v4);
  }
  return RelativeRate;
}

CMClockRef CMTimebaseCopyUltimateSourceClock(CMTimebaseRef timebase)
{
  return (CMClockRef)FigTimebaseCopyUltimateMasterClockAndHeight((pthread_mutex_t **)timebase, 0);
}

void rescheduleValidAndRemoveCancelledTimerSources(CFDictionaryRef *a1, CMTime *a2, int a3)
{
  CFIndex Count = CFDictionaryGetCount(a1[38]);
  if (Count)
  {
    uint64_t v7 = Count;
    CFAllocatorRef v8 = CFGetAllocator(a1);
    CFDictionaryRef v9 = (const void **)CFAllocatorAllocate(v8, 8 * v7, 0);
    if (v9)
    {
      uint64_t v10 = v9;
      CFAllocatorRef v11 = CFGetAllocator(a1);
      CFDataRef v12 = (const void **)CFAllocatorAllocate(v11, 8 * v7, 0);
      if (v12)
      {
        uint64_t v13 = v12;
        CFDictionaryGetKeysAndValues(a1[38], v10, v12);
        if (v7 >= 1)
        {
          CFDataRef v14 = (const __CFData *)*MEMORY[0x1E4F1CFC8];
          CMTime v15 = v10;
          BOOL v16 = (CFDataRef *)v13;
          do
          {
            int v17 = *v15;
            if (dispatch_source_testcancel((dispatch_source_t)*v15))
            {
              CFDictionaryRemoveValue(a1[38], v17);
              CFDictionaryRemoveValue(a1[39], *v15);
            }
            else if (v14 != *v16)
            {
              CMTime v23 = *(CMTime *)CFDataGetBytePtr(*v16);
              char Value = CFDictionaryGetValue(a1[39], *v15);
              int v19 = *v15;
              CMTime v22 = *a2;
              rescheduleTimerSource(v19, &v23, (OpaqueCMTimebase *)a1, &v22, a3, Value);
            }
            ++v16;
            ++v15;
            --v7;
          }
          while (v7);
        }
        CFAllocatorRef v20 = CFGetAllocator(a1);
        CFAllocatorDeallocate(v20, v10);
      }
      else
      {
        uint64_t v13 = v10;
      }
      CFAllocatorRef v21 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v21, v13);
    }
  }
}

uint64_t figTimebaseUninstallReadOnlyTimebaseNotifications(const void *a1, const void *a2)
{
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  uint64_t v5 = FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figTimebaseReflectNotification, 0, a2);
  if (a2)
  {
    CFNotificationCenterRef v6 = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterBarrier((uint64_t)v6, (uint64_t)a2);
  }
  return v5;
}

OSStatus CMTimebaseCreateWithSourceClock(CFAllocatorRef allocator, CMClockRef sourceClock, CMTimebaseRef *timebaseOut)
{
  CFTypeRef cf = 0;
  if (sourceClock && timebaseOut)
  {
    OSStatus v5 = figTimebaseCreate((uint64_t)allocator, 0, &cf);
    if (!v5)
    {
      *((_DWORD *)cf + 4) = 0;
      CFTypeRef v7 = CFRetain(sourceClock);
      *((void *)cf + 16) = v7;
      CFTypeRef v8 = CFRetain(sourceClock);
      CFNotificationCenterRef v6 = cf;
      *((void *)cf + 18) = v8;
      v6[19] = 1;
      v6[22] = 0;
      v6[23] = 0;
      v6[26] = 0;
      *((_OWORD *)v6 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)&kCMTimeZero.value;
      *((_OWORD *)v6 + 12) = *(_OWORD *)&kCMTimeZero.value;
      *((unsigned char *)v6 + 216) = 0;
      goto LABEL_10;
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    OSStatus v5 = FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
  if (timebaseOut)
  {
    CFNotificationCenterRef v6 = 0;
LABEL_10:
    *timebaseOut = (CMTimebaseRef)v6;
  }
  return v5;
}

OSStatus CMTimebaseCreateWithSourceTimebase(CFAllocatorRef allocator, CMTimebaseRef sourceTimebase, CMTimebaseRef *timebaseOut)
{
  CFTypeRef cf = 0;
  if (sourceTimebase && timebaseOut)
  {
    OSStatus v5 = figTimebaseCreate((uint64_t)allocator, 0, &cf);
    CFTypeRef v6 = cf;
    if (v5) {
      goto LABEL_10;
    }
    *((_DWORD *)cf + 4) = 0;
    CFTypeRef v7 = CFRetain(sourceTimebase);
    CFTypeRef v8 = (void *)cf;
    *((void *)cf + 17) = v7;
    uint64_t UltimateMasterClock = (const void *)figTimebaseFindUltimateMasterClock((pthread_mutex_t **)v8, (uint64_t *)v8 + 19);
    if (UltimateMasterClock) {
      uint64_t UltimateMasterClock = CFRetain(UltimateMasterClock);
    }
    uint64_t v10 = cf;
    *((void *)cf + 18) = UltimateMasterClock;
    v10[10] = *(_OWORD *)&kCMTimeZero.value;
    *((void *)v10 + 22) = 0;
    *((void *)v10 + 23) = 0;
    v10[12] = *(_OWORD *)&kCMTimeZero.value;
    *((void *)v10 + 26) = 0;
    *((unsigned char *)v10 + 216) = 0;
    OSStatus v11 = figTimebaseSwitchListenersToNewMaster(v10, 0, (unint64_t)sourceTimebase);
  }
  else
  {
    OSStatus v11 = FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
  OSStatus v5 = v11;
  if (!v11) {
    goto LABEL_13;
  }
  CFTypeRef v6 = cf;
LABEL_10:
  if (v6) {
    CFRelease(v6);
  }
  CFTypeRef cf = 0;
LABEL_13:
  if (timebaseOut) {
    *timebaseOut = (CMTimebaseRef)cf;
  }
  return v5;
}

void figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(pthread_mutex_t **a1@<X0>, int a2@<W1>, int a3@<W2>, CMTime *a4@<X8>)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)&a4->unsigned int value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->CMTimeEpoch epoch = 0;
  long long v26 = *(_OWORD *)&kCMTimeInvalid.value;
  CMTimeEpoch v27 = 0;
  if (a1)
  {
    CFTypeRef v7 = figTimebaseCopyTargetTimebase(a1);
    figTimebaseGetMasterTime(&v26, v7);
    *(_OWORD *)&time[0].start.unsigned int value = v26;
    time[0].start.CMTimeEpoch epoch = v27;
    figTimebaseGetTimeAtMasterTime(v7, &time[0].start, a4);
    if (a3 && dword_1EB28B5D0)
    {
      LODWORD(v34.CFDictionarySetValue(theDict, key, value) = 0;
      LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_CMTime type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5C8, 1, (int *)&v34, &type);
      unsigned int value = v34.value;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value)) {
        unsigned int v11 = value;
      }
      else {
        unsigned int v11 = value & 0xFFFFFFFE;
      }
      if (v11)
      {
        unsigned int value = *((_DWORD *)v7 + 4);
        *(_OWORD *)&time[0].start.unsigned int value = v26;
        time[0].start.CMTimeEpoch epoch = v27;
        Float64 Seconds = CMTimeGetSeconds(&time[0].start);
        *(_OWORD *)&time[0].start.unsigned int value = *(_OWORD *)&a4->value;
        time[0].start.CMTimeEpoch epoch = a4->epoch;
        Float64 v13 = CMTimeGetSeconds(&time[0].start);
        LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136316162;
        *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness";
        LOWORD(time2.flags) = 2048;
        *(void *)((char *)&time2.flags + 2) = v7;
        HIWORD(time2.epoch) = 1024;
        unsigned int v36 = value;
        __int16 v37 = 2048;
        Float64 v38 = Seconds;
        __int16 v39 = 2048;
        Float64 v40 = v13;
        CFDataRef v14 = (CMTimeRange *)_os_log_send_and_compose_impl();
        LOBYTE(CFDictionarySetValue(theDict, key, value) = v34.value;
      }
      else
      {
        CFDataRef v14 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5C8, 1u, 1, v14, v14 != time, value, 0, v10);
    }
    if (*((_DWORD *)v7 + 4) == 1)
    {
      CMTime v25 = *a4;
      CMTime v15 = figTimebaseCopyTargetTimebase(v7);
      uint64_t v16 = (uint64_t)v15;
      if (*((_DWORD *)v15 + 4) == 1)
      {
        long long v17 = *((_OWORD *)v15 + 4);
        CMTime v34 = *(CMTime *)((unsigned char *)v15 + 2);
        CMTime type = *(CMTime *)((unsigned char *)v15 + 3);
        memset(&v32, 0, sizeof(v32));
        *(_OWORD *)&time[0].start.unsigned int value = *((_OWORD *)v15 + 3);
        *(_OWORD *)&time[0].start.CMTimeEpoch epoch = v17;
        *(_OWORD *)&time[0].duration.CMTimeScale timescale = *((_OWORD *)v15 + 5);
        CMTimeRangeGetEnd(&v32, time);
        time[0].start = v25;
        CMTime time2 = v32;
        if ((CMTimeCompare(&time[0].start, &time2) & 0x80000000) == 0)
        {
          memset(&v31, 0, sizeof(v31));
          *(_OWORD *)&time[0].start.unsigned int value = v26;
          time[0].start.CMTimeEpoch epoch = v27;
          CMTime time2 = v34;
          CMTimeSubtract(&v31, &time[0].start, &time2);
          memset(&v30, 0, sizeof(v30));
          time[0].start = v31;
          CMTime time2 = type;
          uint64_t v18 = CMTimeDivide((uint64_t)time, (uint64_t)&time2, (uint64_t)&v30);
          if (a2)
          {
            memset(&v29, 0, sizeof(v29));
            if (v18 > 0x7FFFFFFF)
            {
              *(_OWORD *)&time[0].start.unsigned int value = v26;
              time[0].start.CMTimeEpoch epoch = v27;
              CMTime time2 = v30;
              CMTimeSubtract(&v29, &time[0].start, &time2);
            }
            else
            {
              memset(time, 0, 24);
              CMTime time2 = type;
              CMTimeMultiply(&time[0].start, &time2, v18);
              CMTime time2 = v34;
              CMTime rhs = time[0].start;
              CMTimeAdd(&v29, &time2, &rhs);
            }
            *(_OWORD *)&time[0].start.unsigned int value = *(_OWORD *)(v16 + 160);
            time[0].start.CMTimeEpoch epoch = *(void *)(v16 + 176);
            CMTime time2 = v29;
            if (CMTimeCompare(&time[0].start, &time2))
            {
              time[0].start = v34;
              CMTime time2 = v29;
              figTimebaseSetAnchorTimeMaybeNowMaybeNotifying(v16, &time[0].start, &time2, 0, 0);
            }
          }
          time[0].start = v34;
          CMTime time2 = v30;
          CMTimeAdd(&v25, &time[0].start, &time2);
        }
      }
      CFRelease((CFTypeRef)v16);
      *a4 = v25;
      if (a3 && dword_1EB28B5D0)
      {
        LODWORD(v34.CFDictionarySetValue(theDict, key, value) = 0;
        LOBYTE(type.CFDictionarySetValue(theDict, key, value) = 0;
        int v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5C8, 1, (int *)&v34, &type);
        unsigned int v20 = v34.value;
        if (os_log_type_enabled(v19, type.value)) {
          unsigned int v22 = v20;
        }
        else {
          unsigned int v22 = v20 & 0xFFFFFFFE;
        }
        if (v22)
        {
          *(_OWORD *)&time[0].start.unsigned int value = *(_OWORD *)&a4->value;
          time[0].start.CMTimeEpoch epoch = a4->epoch;
          Float64 v23 = CMTimeGetSeconds(&time[0].start);
          LODWORD(time2.CFDictionarySetValue(theDict, key, value) = 136315394;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness";
          LOWORD(time2.flags) = 2048;
          *(Float64 *)((char *)&time2.flags + 2) = v23;
          CFDictionaryRef v24 = (CMTimeRange *)_os_log_send_and_compose_impl();
          LOBYTE(v2CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v34.value;
        }
        else
        {
          CFDictionaryRef v24 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5C8, 1u, 1, v24, v24 != time, v20, 0, v21);
      }
    }
    CFRelease(v7);
  }
}

void CMTimebaseGetTimeWithLogging(pthread_mutex_t **a1@<X0>, CMTime *a2@<X8>)
{
}

CMTime *__cdecl CMTimebaseGetTimeWithTimeScale(CMTime *__return_ptr retstr, CMTime *timebase, CMTimeScale timescale, CMTimeRoundingMethod method)
{
  *(_OWORD *)&retstr->unsigned int value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->CMTimeEpoch epoch = 0;
  if (timebase)
  {
    CFTypeRef v7 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v7, 1, 0, retstr);
    if (timescale)
    {
      if ((retstr->flags & 0x1D) == 1 && retstr->timescale != timescale)
      {
        CMTime v9 = *retstr;
        timebase = CMTimeConvertScale(retstr, &v9, timescale, method);
      }
    }
    if (v7) {
      CFRelease(v7);
    }
  }
  return timebase;
}

pthread_mutex_t **figTimebaseCopyTargetTimebase(pthread_mutex_t **a1)
{
  if (!a1) {
    return 0;
  }
  int v1 = a1;
  CFRetain(a1);
  for (uint64_t i = 0; ; uint64_t i = v3)
  {
    CFDictionaryRef v3 = v1;
    if (i) {
      CFRelease(i);
    }
    FigReentrantMutexLock(v1[14]);
    int v1 = (pthread_mutex_t **)v1[3];
    if (!v1) {
      break;
    }
    CFRetain(v3[3]);
    FigReentrantMutexUnlock(v3[14]);
  }
  FigReentrantMutexUnlock(v3[14]);
  return v3;
}

OSStatus CMTimebaseSetTime(CMTimebaseRef timebase, CMTime *time)
{
  if (!timebase) {
    return -12748;
  }
  if ((time->flags & 0x1D) == 1)
  {
    OSStatus result = figTimebaseVerifyReadWrite((uint64_t)timebase);
    if (result) {
      return result;
    }
    if (*((_DWORD *)timebase + 4) != 1)
    {
      CMTime v7 = *time;
      memset(&v6, 0, sizeof(v6));
      return figTimebaseSetAnchorTimeMaybeNowMaybeNotifying((uint64_t)timebase, &v7, &v6, 1, 1);
    }
    uint64_t v5 = 4294954539;
  }
  else
  {
    uint64_t v5 = 4294954548;
  }

  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t figTimebaseVerifyReadWrite(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16) != 2) {
    return 0;
  }
  int v1 = *(void (**)(uint64_t, void))(a1 + 32);
  if (v1) {
    v1(a1, *(void *)(a1 + 40));
  }

  return FigSignalErrorAt(4294954539, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTimebaseSetAnchorTime(CMTimebaseRef timebase, CMTime *timebaseTime, CMTime *immediateSourceTime)
{
  if (!timebase) {
    return -12748;
  }
  if (*((_DWORD *)timebase + 4) == 1)
  {
    return FigSignalErrorAt(4294954539, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CMTime v5 = *timebaseTime;
    CMTime v4 = *immediateSourceTime;
    return figTimebaseSetAnchorTimeMaybeNowMaybeNotifying((uint64_t)timebase, &v5, &v4, 0, 1);
  }
}

Float64 CMTimebaseGetRate(CMTimebaseRef timebase)
{
  if (!timebase) {
    return 0.0;
  }
  int v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  double v2 = *((double *)v1 + 23);
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

OSStatus CMTimebaseGetTimeAndRate(CMTimebaseRef timebase, CMTime *timeOut, Float64 *rateOut)
{
  if (!timebase) {
    return -12748;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
  if (timeOut)
  {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, &v7);
    *timeOut = v7;
  }
  if (rateOut) {
    *rateOut = CMTimebaseGetRate(timebase);
  }
  FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  return 0;
}

OSStatus CMTimebaseSetRate(CMTimebaseRef timebase, Float64 rate)
{
  if (!timebase) {
    return -12748;
  }
  OSStatus result = figTimebaseVerifyReadWrite((uint64_t)timebase);
  if (!result)
  {
    long long v6 = *(_OWORD *)&kCMTimeInvalid.value;
    uint64_t v7 = 0;
    memset(&v5, 0, sizeof(v5));
    return figTimebaseSetRateAndMaybeAnchorTime((uint64_t)timebase, &v6, &v5, 0, rate);
  }
  return result;
}

OSStatus CMTimebaseSetRateAndAnchorTime(CMTimebaseRef timebase, Float64 rate, CMTime *timebaseTime, CMTime *immediateSourceTime)
{
  CMTime v6 = *timebaseTime;
  CMTime v5 = *immediateSourceTime;
  return CMTimebaseSetRateAndAnchorTimeWithFlags((uint64_t)timebase, (uint64_t)&v6, &v5, 0, rate);
}

uint64_t CMTimebaseSetRateAndAnchorTimeWithFlags(uint64_t a1, uint64_t a2, CMTime *a3, int a4, double a5)
{
  if (!a1) {
    return 4294954548;
  }
  uint64_t result = figTimebaseVerifyReadWrite(a1);
  if (!result)
  {
    long long v12 = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
    CMTime v11 = *a3;
    return figTimebaseSetRateAndMaybeAnchorTime(a1, &v12, &v11, a4, a5);
  }
  return result;
}

CMTimebaseRef CMTimebaseCopySourceTimebase(CMTimebaseRef timebase)
{
  if (!timebase) {
    return 0;
  }
  int v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  double v2 = (OpaqueCMTimebase *)v1[17];
  if (v2) {
    CFRetain(v1[17]);
  }
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

CMClockRef CMTimebaseGetMasterClock(CMTimebaseRef timebase)
{
  CMClockRef v1 = CMTimebaseCopySourceClock(timebase);
  double v2 = v1;
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

CMClockRef CMTimebaseCopySourceClock(CMTimebaseRef timebase)
{
  if (!timebase) {
    return 0;
  }
  CMClockRef v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  double v2 = (OpaqueCMClock *)v1[16];
  if (v2) {
    CFRetain(v1[16]);
  }
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

CMTimebaseRef CMTimebaseGetMasterTimebase(CMTimebaseRef timebase)
{
  CMTimebaseRef v1 = CMTimebaseCopySourceTimebase(timebase);
  double v2 = v1;
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

CMClockOrTimebaseRef CMTimebaseGetMaster(CMTimebaseRef timebase)
{
  CMClockOrTimebaseRef v1 = CMTimebaseCopySource(timebase);
  double v2 = v1;
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

CMClockOrTimebaseRef CMTimebaseCopySource(CMTimebaseRef timebase)
{
  if (!timebase) {
    return 0;
  }
  CMClockOrTimebaseRef v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  double v2 = v1[17];
  if (v2 || (double v2 = v1[16]) != 0) {
    CFRetain(v2);
  }
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

CMClockRef CMTimebaseGetUltimateMasterClock(CMTimebaseRef timebase)
{
  CMClockOrTimebaseRef v1 = FigTimebaseCopyUltimateMasterClockAndHeight((pthread_mutex_t **)timebase, 0);
  double v2 = (OpaqueCMClock *)v1;
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

pthread_mutex_t *FigTimebaseCopyUltimateMasterClockAndHeight(pthread_mutex_t **a1, pthread_mutex_t **a2)
{
  if (!a1) {
    return 0;
  }
  CFDictionaryRef v3 = figTimebaseCopyTargetTimebase(a1);
  FigReentrantMutexLock(v3[14]);
  CMTime v4 = v3[18];
  if (v4) {
    CFRetain(v3[18]);
  }
  CMTime v5 = v3[19];
  FigReentrantMutexUnlock(v3[14]);
  if (a2 && v4) {
    *a2 = v5;
  }
  CFRelease(v3);
  return v4;
}

OSStatus CMTimebaseSetSourceClock(CMTimebaseRef timebase, CMClockRef newSourceClock)
{
  OSStatus result = -12748;
  if (timebase)
  {
    if (newSourceClock)
    {
      OSStatus result = figTimebaseVerifyReadWrite((uint64_t)timebase);
      if (!result)
      {
        return figTimebaseSetMaster((uint64_t)timebase, 0, newSourceClock);
      }
    }
  }
  return result;
}

uint64_t figTimebaseSetMaster(uint64_t a1, void *a2, void *a3)
{
  memset(&v23, 0, sizeof(v23));
  if (!a1 || (a2 == 0) == (a3 == 0)) {
    return 4294954548;
  }
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &v23);
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  CMTime v22 = v23;
  CFDictionaryRef v7 = figTimebaseCreatePayloadForNotificationAtTime(v6, &v22);
  figTimebasePostNotification((void *)a1, @"CMTimebaseMasterWillChange", v7);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
  double EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
  figTimebaseSwitchListenersToNewMaster((void *)a1, *(const void **)(a1 + 136), (unint64_t)a2);
  CMTime v9 = *(pthread_mutex_t ***)(a1 + 136);
  if (v9) {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v9, 1, 0, &v22);
  }
  else {
    CMClockGetTime(&v22, *(CMClockRef *)(a1 + 128));
  }
  uint64_t v10 = *(const void **)(a1 + 128);
  *(void *)(a1 + 128) = a3;
  if (a3) {
    CFRetain(a3);
  }
  if (v10) {
    CFRelease(v10);
  }
  CMTime v11 = *(const void **)(a1 + 136);
  *(void *)(a1 + 136) = a2;
  if (a2) {
    CFRetain(a2);
  }
  if (v11) {
    CFRelease(v11);
  }
  long long v12 = *(const void **)(a1 + 144);
  uint64_t UltimateMasterClock = (const void *)figTimebaseFindUltimateMasterClock((pthread_mutex_t **)a1, (uint64_t *)(a1 + 152));
  *(void *)(a1 + 144) = UltimateMasterClock;
  if (UltimateMasterClock) {
    CFRetain(UltimateMasterClock);
  }
  if (v12) {
    CFRelease(v12);
  }
  CFDataRef v14 = (_OWORD *)(a1 + 160);
  *(CMTime *)(a1 + 192) = v23;
  if (a2)
  {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a2, 1, 0, &v22);
    *CFDataRef v14 = *(_OWORD *)&v22.value;
    *(void *)(a1 + 176) = v22.epoch;
    *(unsigned char *)(a1 + 216) = 0;
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a2, 1, 0, &v22);
  }
  else
  {
    CMClockGetTime(&v22, (CMClockRef)a3);
    *CFDataRef v14 = *(_OWORD *)&v22.value;
    *(void *)(a1 + 176) = v22.epoch;
    *(unsigned char *)(a1 + 216) = 0;
    CMClockGetTime(&v22, (CMClockRef)a3);
  }
  if (*(double *)(a1 + 184) != 0.0)
  {
    FigSyncInvertTransform(a1 + 160, a1 + 224);
    if (!v15) {
      *(unsigned char *)(a1 + 216) = 1;
    }
  }
  if (CMTimebaseGetEffectiveRate((CMTimebaseRef)a1) == EffectiveRate)
  {
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    CFStringRef v16 = @"CMTimebaseMasterDidChange";
  }
  else
  {
    double v17 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    int v18 = *(_DWORD *)(a1 + 320);
    if (v17 > 0.0) {
      int v19 = 1;
    }
    else {
      int v19 = -1;
    }
    if (v17 == 0.0) {
      int v19 = *(_DWORD *)(a1 + 320);
    }
    *(_DWORD *)(a1 + 32CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v19;
    BOOL v20 = v18 == v19;
    if (*(void *)(a1 + 280))
    {
      CMTime v22 = v23;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &v22, v20);
    }
    if (*(void *)(a1 + 304))
    {
      CMTime v22 = v23;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &v22, v20);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    figTimebasePostNotification((void *)a1, @"CMTimebaseMasterDidChange", v7);
    CFStringRef v16 = @"CMTimebaseEffectiveRateChanged";
  }
  figTimebasePostNotification((void *)a1, v16, v7);
  if (v7) {
    CFRelease(v7);
  }
  return 0;
}

OSStatus CMTimebaseSetSourceTimebase(CMTimebaseRef timebase, CMTimebaseRef newSourceTimebase)
{
  OSStatus result = -12748;
  if (timebase)
  {
    if (newSourceTimebase)
    {
      OSStatus result = figTimebaseVerifyReadWrite((uint64_t)timebase);
      if (!result)
      {
        if (figTimebaseIsDescendantOfTimebase((pthread_mutex_t **)newSourceTimebase, (pthread_mutex_t *)timebase))
        {
          return -12749;
        }
        else
        {
          return figTimebaseSetMaster((uint64_t)timebase, newSourceTimebase, 0);
        }
      }
    }
  }
  return result;
}

OSStatus CMTimebaseAddTimer(CMTimebaseRef timebase, CFRunLoopTimerRef timer, CFRunLoopRef runloop)
{
  if (!timebase) {
    return -12748;
  }
  OSStatus v4 = -12748;
  if (!timer || !runloop) {
    return v4;
  }
  if (CFRunLoopTimerGetInterval(timer) >= 86400.0)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    if (*((void *)timebase + 35)) {
      goto LABEL_27;
    }
    valueCallBacks.version = 0;
    valueCallBacks.retain = (CFDictionaryRetainCallBack)cfDataFigTimeRetain;
    valueCallBacks.release = (CFDictionaryReleaseCallBack)cfDataFigTimeRelease;
    valueCallBacks.equal = (CFDictionaryEqualCallBack)cfDataFigTimeEqual;
    valueCallBacks.copyDescription = (CFDictionaryCopyDescriptionCallBack)cfDataFigTimeCopyDescription;
    CFAllocatorRef v8 = CFGetAllocator(timebase);
    CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], &valueCallBacks);
    *((void *)timebase + 35) = v9;
    if (v9)
    {
LABEL_27:
      if (*((void *)timebase + 36)
        || (CFAllocatorRef v10 = CFGetAllocator(timebase),
            CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(v10, 0, 0, 0),
            (*((void *)timebase + 36) = v11) != 0))
      {
        if (*((void *)timebase + 37)
          || (CFAllocatorRef v12 = CFGetAllocator(timebase),
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
              (*((void *)timebase + 37) = Mutable) != 0))
        {
          if (CFDictionaryContainsKey(*((CFDictionaryRef *)timebase + 35), timer))
          {
            char Value = CFDictionaryGetValue(*((CFDictionaryRef *)timebase + 37), timer);
            if (!FigCFEqual(Value, runloop))
            {
              uint64_t v15 = 4294954547;
LABEL_21:
              OSStatus v4 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
              goto LABEL_22;
            }
LABEL_19:
            OSStatus v4 = 0;
LABEL_22:
            FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
            return v4;
          }
          CFAllocatorRef v16 = CFGetAllocator(timebase);
          CFDataRef v17 = CFDataCreate(v16, (const UInt8 *)&kCMTimeInvalid, 24);
          if (v17)
          {
            CFDataRef v18 = v17;
            CFRunLoopTimerSetNextFireDate(timer, 8073216000.0);
            CFRunLoopWakeUp(runloop);
            CFDictionaryAddValue(*((CFMutableDictionaryRef *)timebase + 35), timer, v18);
            CFRelease(v18);
            CFDictionaryAddValue(*((CFMutableDictionaryRef *)timebase + 37), timer, runloop);
            goto LABEL_19;
          }
        }
      }
    }
    uint64_t v15 = 4294954546;
    goto LABEL_21;
  }

  return FigSignalErrorAt(4294954545, 0, 0, 0, 0, 0, 0);
}

BOOL cfDataFigTimeEqual(const __CFData *a1, const __CFData *a2)
{
  BytePtr = CFDataGetBytePtr(a1);
  OSStatus v4 = CFDataGetBytePtr(a2);
  long long v5 = *(_OWORD *)BytePtr;
  time1.CMTimeEpoch epoch = *((void *)BytePtr + 2);
  *(_OWORD *)&time1.unsigned int value = v5;
  long long v6 = *(_OWORD *)v4;
  v8.CMTimeEpoch epoch = *((void *)v4 + 2);
  *(_OWORD *)&v8.unsigned int value = v6;
  return CMTimeCompare(&time1, &v8) == 0;
}

CFStringRef cfDataFigTimeCopyDescription(const __CFData *a1)
{
  BytePtr = CFDataGetBytePtr(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  long long v4 = *(_OWORD *)BytePtr;
  v6.CMTimeEpoch epoch = *((void *)BytePtr + 2);
  *(_OWORD *)&v6.unsigned int value = v4;
  return CMTimeCopyDescription(v3, &v6);
}

OSStatus CMTimebaseRemoveTimer(CMTimebaseRef timebase, CFRunLoopTimerRef timer)
{
  OSStatus v2 = -12748;
  if (timebase && timer)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)timebase + 35);
    if (v5 && CFDictionaryContainsKey(v5, timer))
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 35), timer);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 36), timer);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 37), timer);
      CFRunLoopTimerSetNextFireDate(timer, 8073216000.0);
      OSStatus v2 = 0;
    }
    else
    {
      OSStatus v2 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v2;
}

OSStatus CMTimebaseSetTimerNextFireTime(CMTimebaseRef timebase, CFRunLoopTimerRef timer, CMTime *fireTime, uint32_t flags)
{
  OSStatus v4 = -12748;
  if (timebase && timer)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    CFDictionaryRef v9 = (const __CFDictionary *)*((void *)timebase + 35);
    if (v9 && CFDictionaryContainsKey(v9, timer))
    {
      if (CFRunLoopTimerIsValid(timer))
      {
        CFDictionaryRef v10 = (const __CFDictionary *)*((void *)timebase + 37);
        if (v10)
        {
          char Value = (__CFRunLoop *)CFDictionaryGetValue(v10, timer);
          if (Value)
          {
            CFAllocatorRef v12 = Value;
            CFAllocatorRef v13 = CFGetAllocator(timebase);
            CFDataRef v14 = CFDataCreate(v13, (const UInt8 *)fireTime, 24);
            if (v14)
            {
              CFDataRef v15 = v14;
              CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)timebase + 35), timer, v14);
              CFRelease(v15);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)timebase + 36), timer, (const void *)flags);
              figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, &v19);
              CMTime v18 = *fireTime;
              rescheduleTimer(timer, v12, &v18, timebase, &v19, 2, flags);
              OSStatus v4 = 0;
LABEL_13:
              FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
              return v4;
            }
            uint64_t v16 = 4294954546;
LABEL_12:
            OSStatus v4 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
            goto LABEL_13;
          }
        }
      }
      else
      {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 35), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 36), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 37), timer);
      }
    }
    uint64_t v16 = 4294954547;
    goto LABEL_12;
  }
  return v4;
}

OSStatus CMTimebaseSetTimerToFireImmediately(CMTimebaseRef timebase, CFRunLoopTimerRef timer)
{
  OSStatus v2 = -12748;
  if (timebase && timer)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)timebase + 35);
    if (v5 && CFDictionaryContainsKey(v5, timer))
    {
      if (CFRunLoopTimerIsValid(timer))
      {
        CFDictionaryRef v6 = (const __CFDictionary *)*((void *)timebase + 37);
        if (v6)
        {
          char Value = (__CFRunLoop *)CFDictionaryGetValue(v6, timer);
          if (Value)
          {
            CMTime v8 = Value;
            CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)timebase + 35), timer, (const void *)*MEMORY[0x1E4F1CFC8]);
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            CFRunLoopTimerSetNextFireDate(timer, Current);
            CFRunLoopWakeUp(v8);
            OSStatus v2 = 0;
LABEL_11:
            FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
            return v2;
          }
        }
      }
      else
      {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 35), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 36), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 37), timer);
      }
    }
    OSStatus v2 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  return v2;
}

dispatch_object_t cfDispatchSourceRetain(int a1, dispatch_object_t object)
{
  return object;
}

void cfDispatchSourceRelease(int a1, dispatch_object_t object)
{
}

OSStatus CMTimebaseRemoveTimerDispatchSource(CMTimebaseRef timebase, dispatch_source_t timerSource)
{
  OSStatus v2 = -12748;
  if (timebase && timerSource)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)timebase + 38);
    if (v5 && CFDictionaryContainsKey(v5, timerSource))
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource);
      dispatch_source_set_timer(timerSource, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
      OSStatus v2 = 0;
    }
    else
    {
      OSStatus v2 = -12749;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v2;
}

void rescheduleTimerSource(NSObject *a1, CMTime *a2, OpaqueCMTimebase *a3, CMTime *a4, int a5, char a6)
{
  memset(&v27, 0, sizeof(v27));
  memset(&v26, 0, sizeof(v26));
  if (!dispatch_source_testcancel(a1))
  {
    if ((a2->flags & 0x1D) != 1) {
      goto LABEL_5;
    }
    if (a2->timescale < 1) {
      goto LABEL_5;
    }
    double EffectiveRate = CMTimebaseGetEffectiveRate(a3);
    if (EffectiveRate == 0.0) {
      goto LABEL_5;
    }
    double v14 = EffectiveRate;
    int timescale = a2->timescale;
    if (timescale <= 1023)
    {
      do
      {
        CMTimeValue value = a2->value;
        if ((unint64_t)(a2->value + 0x3FFFFFFFFFFFFFFFLL) > 0x7FFFFFFFFFFFFFFDLL) {
          break;
        }
        memset(&time, 0, sizeof(time));
        CMTimeMake(&time, 2 * value, 2 * timescale);
        *a2 = time;
        int timescale = a2->timescale;
      }
      while (timescale < 1024);
    }
    CMClockRef HostTimeClock = CMClockGetHostTimeClock();
    CMTime time = *a2;
    CMSyncConvertTime(&v27, &time, a3, HostTimeClock);
    memset(&time, 0, sizeof(time));
    CMTime v18 = CMClockGetHostTimeClock();
    CMClockGetTime(&time, v18);
    BOOL v19 = 0;
    if (v14 <= 0.0 || (CMTime time1 = *a2, v23 = *a4, (CMTimeCompare(&time1, &v23) & 0x80000000) == 0))
    {
      if (v14 >= 0.0 || (CMTime time1 = *a2, v23 = *a4, CMTimeCompare(&time1, &v23) < 1)) {
        BOOL v19 = 1;
      }
    }
    CMTime time1 = v27;
    CMTime v23 = time;
    CMTimeSubtract(&v26, &time1, &v23);
    CMTime v23 = v26;
    CMTimeConvertScale(&time1, &v23, 1000000000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    CMTimeValue v20 = time1.value;
    if ((~time1.flags & 9) != 0) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = -1;
    }
    if ((~time1.flags & 5) != 0) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = 8073216000000000000;
    }
    if ((time1.flags & 0x1D) != 1) {
      CMTimeValue v20 = v22;
    }
    if (v19)
    {
LABEL_30:
      dispatch_time_t v13 = dispatch_time(0, v20 & ~(v20 >> 63));
      goto LABEL_6;
    }
    if (a6) {
      goto LABEL_29;
    }
    if (!a5)
    {
LABEL_5:
      dispatch_time_t v13 = -1;
LABEL_6:
      dispatch_source_set_timer(a1, v13, 0x7009D32DA3000000uLL, 0);
      return;
    }
    if (a5 != 1)
    {
LABEL_29:
      CMTimeValue v20 = 0;
      goto LABEL_30;
    }
  }
}

OSStatus CMTimebaseSetTimerDispatchSourceToFireImmediately(CMTimebaseRef timebase, dispatch_source_t timerSource)
{
  OSStatus v2 = -12748;
  if (timebase && timerSource)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)timebase + 38);
    if (v5 && CFDictionaryContainsKey(v5, timerSource))
    {
      intptr_t v6 = dispatch_source_testcancel(timerSource);
      CFDictionaryRef v7 = (__CFDictionary *)*((void *)timebase + 38);
      if (!v6)
      {
        CFDictionaryReplaceValue(v7, timerSource, (const void *)*MEMORY[0x1E4F1CFC8]);
        dispatch_source_set_timer(timerSource, 0, 0x7009D32DA3000000uLL, 0);
        OSStatus v2 = 0;
        goto LABEL_8;
      }
      CFDictionaryRemoveValue(v7, timerSource);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource);
    }
    OSStatus v2 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
LABEL_8:
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v2;
}

OSStatus CMTimebaseNotificationBarrier(CMTimebaseRef timebase)
{
  if (!timebase) {
    return -12748;
  }
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();

  return CMNotificationCenterBarrier((uint64_t)DefaultLocalCenter, (uint64_t)timebase);
}

pthread_mutex_t **CMTimebaseGetTimeClampedAboveAnchorTime@<X0>(pthread_mutex_t **result@<X0>, char *a2@<X1>, CMTime *a3@<X8>)
{
  *(_OWORD *)&a3->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->CMTimeEpoch epoch = 0;
  char v7 = 0;
  if (!result)
  {
    char v6 = 0;
    if (!a2) {
      return result;
    }
    goto LABEL_5;
  }
  CFDictionaryRef v5 = result;
  FigReentrantMutexLock(result[14]);
  figTimebaseGetAnchorTimebaseTimeIfClamped(v5, &v7, (uint64_t)a3);
  char v6 = v7;
  if (!v7) {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v5, 1, 0, a3);
  }
  OSStatus result = (pthread_mutex_t **)FigReentrantMutexUnlock(v5[14]);
  if (a2) {
LABEL_5:
  }
    *a2 = v6;
  return result;
}

void figTimebaseGetAnchorTimebaseTimeIfClamped(pthread_mutex_t **a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = *(_OWORD *)&kCMTimeInvalid.value;
  *(void *)(a3 + 16) = 0;
  char v6 = FigTimebaseCopyUltimateMasterClockAndHeight(a1, 0);
  CMClockOrTimebaseRef v7 = CMTimebaseCopySource((CMTimebaseRef)a1);
  CMTime v8 = v7;
  if (v6 && v7)
  {
    Float64 v16 = 0.0;
    outRelativedouble Rate = 0.0;
    memset(&outOfClockOrTimebaseAnchorTime, 0, sizeof(outOfClockOrTimebaseAnchorTime));
    memset(&outRelativeToClockOrTimebaseAnchorTime, 0, sizeof(outRelativeToClockOrTimebaseAnchorTime));
    CMSyncGetRelativeRateAndAnchorTime(a1, v6, &outRelativeRate, 0, 0);
    CMSyncGetRelativeRateAndAnchorTime(a1, v8, 0, &outOfClockOrTimebaseAnchorTime, &outRelativeToClockOrTimebaseAnchorTime);
    CMSyncGetRelativeRateAndAnchorTime(v8, v6, &v16, 0, 0);
    CMSyncGetTime(&v15, v8);
    if (outRelativeRate == 0.0)
    {
LABEL_9:
      char v10 = 0;
LABEL_15:
      *a2 = v10;
      goto LABEL_16;
    }
    double v9 = v16;
    if (v16 > 0.0)
    {
      CMTime time1 = outRelativeToClockOrTimebaseAnchorTime;
      CMTime v11 = v15;
      if (CMTimeCompare(&time1, &v11) > 0) {
        goto LABEL_14;
      }
      double v9 = v16;
    }
    if (v9 >= 0.0) {
      goto LABEL_9;
    }
    CMTime time1 = outRelativeToClockOrTimebaseAnchorTime;
    CMTime v11 = v15;
    if ((CMTimeCompare(&time1, &v11) & 0x80000000) == 0) {
      goto LABEL_9;
    }
LABEL_14:
    *(CMTime *)a3 = outOfClockOrTimebaseAnchorTime;
    char v10 = 1;
    goto LABEL_15;
  }
  *a2 = 0;
  if (!v6)
  {
    if (!v7) {
      return;
    }
    goto LABEL_12;
  }
LABEL_16:
  CFRelease(v6);
  if (!v8) {
    return;
  }
LABEL_12:
  CFRelease(v8);
}

__CFString *ftbCopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &v18);
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CMTime time = v18;
  CFStringRef v5 = CMTimeCopyDescription(v4, &time);
  CMTime time = v18;
  Float64 Seconds = CMTimeGetSeconds(&time);
  CMClockOrTimebaseRef v7 = "(UNKNOWN TYPE)";
  int v8 = *(_DWORD *)(a1 + 16);
  if (v8 == 1) {
    CMClockOrTimebaseRef v7 = "(Looping)";
  }
  if (v8 == 2) {
    CMClockOrTimebaseRef v7 = "(ReadOnly)";
  }
  if (v8) {
    double v9 = v7;
  }
  else {
    double v9 = "";
  }
  uint64_t v10 = *(void *)(a1 + 24);
  CFIndex v11 = CFGetRetainCount((CFTypeRef)a1);
  CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v13 = *(void *)(a1 + 128);
  if (v13) {
    double v14 = "clock";
  }
  else {
    double v14 = "timebase";
  }
  if (!v13) {
    uint64_t v13 = *(void *)(a1 + 136);
  }
  Float64 Rate = CMTimebaseGetRate((CMTimebaseRef)a1);
  CFStringAppendFormat(Mutable, 0, @"FigTimebase: %p %s targetTimebase: %p retainCount: %d allocator: %p master %s: %p rate: %f time: %@ = %f seconds\n", a1, v9, v10, v11, v12, v14, v13, *(void *)&Rate, v5, *(void *)&Seconds);
  if (v5) {
    CFRelease(v5);
  }
  return Mutable;
}

uint64_t figTimebaseReflectNotification(int a1, uint64_t a2, const __CFString *cf1, uint64_t a4, const void *a5)
{
  int v9 = FigCFEqual(cf1, @"CMTimebaseTimeJumped");
  uint64_t result = FigCFEqual(cf1, @"CMTimebaseTimeAdjusted");
  if (a2)
  {
    int v11 = result;
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(void *)(a2 + 24) == a4)
    {
      if (v9 | v11 || FigCFEqual(cf1, @"CMTimebaseEffectiveRateChanged"))
      {
        memset(&v21, 0, sizeof(v21));
        if (a5)
        {
          CFTypeID v12 = CFGetTypeID(a5);
          if (v12 == CFDictionaryGetTypeID())
          {
            CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a5, @"CMTimebaseEventTime");
            CMTimeMakeFromDictionary(&v21, Value);
          }
        }
        if ((v21.flags & 1) == 0)
        {
          figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(*(pthread_mutex_t ***)(a2 + 24), 1, 0, &v22);
          CMTime v21 = v22;
        }
        CMTime v22 = v21;
        double EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a2);
        int v15 = *(_DWORD *)(a2 + 320);
        if (EffectiveRate > 0.0) {
          int v16 = 1;
        }
        else {
          int v16 = -1;
        }
        if (EffectiveRate == 0.0) {
          int v16 = *(_DWORD *)(a2 + 320);
        }
        *(_DWORD *)(a2 + 32CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v16;
        if (v11) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = v15 == v16;
        }
        int v19 = v17 && v9 == 0;
        if (*(void *)(a2 + 280))
        {
          CMTime v21 = v22;
          rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a2, &v21, v19);
        }
        if (*(void *)(a2 + 304))
        {
          CMTime v21 = v22;
          rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a2, &v21, v19);
        }
      }
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      return figTimebasePostNotification((void *)a2, cf1, a5);
    }
    else
    {
      CMTimeValue v20 = *(pthread_mutex_t **)(a2 + 112);
      return FigReentrantMutexUnlock(v20);
    }
  }
  return result;
}

void figTimebaseTimeJumpedNotificationCallback(int a1, uint64_t a2, const __CFString *cf1, uint64_t a4, const void *a5)
{
  memset(&v14, 0, sizeof(v14));
  int v9 = FigCFEqual(cf1, @"CMTimebaseTimeJumped");
  if (a2)
  {
    int v10 = v9;
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(void *)(a2 + 136) != a4)
    {
      FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
LABEL_8:
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      return;
    }
    figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v14);
    if (*(double *)(a2 + 184) == 0.0) {
      goto LABEL_8;
    }
    if (*(void *)(a2 + 280))
    {
      CMTime v13 = v14;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a2, &v13, v10 == 0);
    }
    if (*(void *)(a2 + 304))
    {
      CMTime v13 = v14;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a2, &v13, v10 == 0);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a2);
    CMTime v13 = v14;
    CFDictionaryRef v12 = figTimebaseCreatePayloadForNotificationAtTime(v11, &v13);
    figTimebasePostNotification((void *)a2, cf1, v12);
    if (v12) {
      CFRelease(v12);
    }
  }
  else
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
}

void figTimebaseMasterDidChangeNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  memset(&v14, 0, sizeof(v14));
  if (a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(void *)(a2 + 136) == a4)
    {
      figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v14);
      int v9 = *(const void **)(a2 + 144);
      if (v9) {
        CFRelease(v9);
      }
      uint64_t UltimateMasterClock = (const void *)figTimebaseFindUltimateMasterClock((pthread_mutex_t **)a2, (uint64_t *)(a2 + 152));
      if (UltimateMasterClock) {
        uint64_t UltimateMasterClock = CFRetain(UltimateMasterClock);
      }
      *(void *)(a2 + 144) = UltimateMasterClock;
      CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a2);
      CMTime v13 = v14;
      CFDictionaryRef v12 = figTimebaseCreatePayloadForNotificationAtTime(v11, &v13);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      figTimebasePostNotification((void *)a2, @"CMTimebaseMasterDidChange", v12);
      if (v12) {
        CFRelease(v12);
      }
    }
    else
    {
      FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
      int v8 = *(pthread_mutex_t **)(a2 + 112);
      FigReentrantMutexUnlock(v8);
    }
  }
  else
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
}

void figTimebaseMasterWillChangeNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  memset(&v12, 0, sizeof(v12));
  if (a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(void *)(a2 + 136) == a4)
    {
      figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v12);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a2);
      CMTime v11 = v12;
      CFDictionaryRef v10 = figTimebaseCreatePayloadForNotificationAtTime(v9, &v11);
      figTimebasePostNotification((void *)a2, @"CMTimebaseMasterWillChange", v10);
      if (v10) {
        CFRelease(v10);
      }
    }
    else
    {
      FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
      int v8 = *(pthread_mutex_t **)(a2 + 112);
      FigReentrantMutexUnlock(v8);
    }
  }
  else
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
}

void figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(CFTypeRef cf@<X1>, uint64_t a2@<X0>, CMTime *a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CMTimeValue v11 = 0;
  CMTimeFlags flags = 0;
  CMTimeScale timescale = 0;
  CMTimeEpoch epoch = 0;
  if (cf)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFDictionaryGetTypeID())
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, @"CMTimebaseEventTime");
      CMTimeMakeFromDictionary(&v10, Value);
      CMTimeValue v11 = v10.value;
      CMTimeFlags flags = v10.flags;
      CMTimeScale timescale = v10.timescale;
      CMTimeEpoch epoch = v10.epoch;
    }
  }
  if ((flags & 1) == 0)
  {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(*(pthread_mutex_t ***)(a2 + 136), 1, 0, &v10);
    CMTimeValue v11 = v10.value;
    CMTimeFlags flags = v10.flags;
    CMTimeScale timescale = v10.timescale;
    CMTimeEpoch epoch = v10.epoch;
  }
  v10.CMTimeValue value = v11;
  v10.CMTimeScale timescale = timescale;
  v10.CMTimeFlags flags = flags;
  v10.CMTimeEpoch epoch = epoch;
  figTimebaseGetTimeAtMasterTime((pthread_mutex_t **)a2, &v10, a3);
}

void figTimebaseGetTimeAtMasterTime(pthread_mutex_t **a1@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  *(_OWORD *)&a3->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->CMTimeEpoch epoch = 0;
  if (a1)
  {
    CFStringRef v5 = figTimebaseCopyTargetTimebase(a1);
    FigReentrantMutexLock(v5[14]);
    if (CMTimebaseGetRate((CMTimebaseRef)v5) == 0.0)
    {
      long long v6 = *((_OWORD *)v5 + 12);
      a3->CMTimeEpoch epoch = (CMTimeEpoch)v5[26];
      *(_OWORD *)&a3->CMTimeValue value = v6;
    }
    else
    {
      CMTime v7 = *a2;
      FigSyncApplyTransform(&v7, (uint64_t)(v5 + 20), a3);
    }
    a3->flags &= ~2u;
    FigReentrantMutexUnlock(v5[14]);
    CFRelease(v5);
  }
  else
  {
    a3->flags &= ~2u;
  }
}

uint64_t figTimebaseSetAnchorTimeMaybeNowMaybeNotifying(uint64_t a1, CMTime *a2, CMTime *a3, int a4, int a5)
{
  memset(&v18, 0, sizeof(v18));
  if (!a1) {
    return 4294954548;
  }
  uint64_t result = figTimebaseVerifyReadWrite(a1);
  if (!result)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
    if (*(double *)(a1 + 184) == 0.0
      && (figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(&time1, a1, 0, 0),
          CMTime v16 = *a2,
          !CMTimeCompare(&time1, &v16)))
    {
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    }
    else
    {
      if (a4)
      {
        figTimebaseGetMasterTime(&v16, a1);
        *a3 = v16;
        CMTime v18 = *a2;
      }
      long long v11 = *(_OWORD *)&a3->value;
      *(void *)(a1 + 176) = a3->epoch;
      *(_OWORD *)(a1 + 16CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v11;
      long long v12 = *(_OWORD *)&a2->value;
      *(void *)(a1 + 208) = a2->epoch;
      *(_OWORD *)(a1 + 192) = v12;
      *(unsigned char *)(a1 + 216) = 0;
      if (*(double *)(a1 + 184) != 0.0)
      {
        FigSyncInvertTransform(a1 + 160, a1 + 224);
        if (!v13) {
          *(unsigned char *)(a1 + 216) = 1;
        }
      }
      if (!a4) {
        figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(&v18, a1, 0, 0);
      }
      if (*(void *)(a1 + 280))
      {
        CMTime v16 = v18;
        rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &v16, 0);
      }
      if (*(void *)(a1 + 304))
      {
        CMTime v16 = v18;
        rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &v16, 0);
      }
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      if (a5 == 1)
      {
        CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
        CMTime v16 = v18;
        CFDictionaryRef v15 = figTimebaseCreatePayloadForNotificationAtTime(v14, &v16);
        figTimebasePostNotification((void *)a1, @"CMTimebaseTimeJumped", v15);
        if (v15) {
          CFRelease(v15);
        }
      }
    }
    return 0;
  }
  return result;
}

CMTime *__cdecl CMTimeMake(CMTime *__return_ptr retstr, CMTime *value, int32_t timescale)
{
  retstr->CMTimeValue value = (CMTimeValue)value;
  retstr->CMTimeScale timescale = timescale;
  retstr->CMTimeFlags flags = 1;
  retstr->CMTimeEpoch epoch = 0;
  if (timescale <= 0)
  {
    retstr->CMTimeValue value = 0;
    *(void *)&retstr->CMTimeScale timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
  }
  return value;
}

CMTime *__cdecl CMTimeMakeWithEpoch(CMTime *__return_ptr retstr, CMTime *value, int32_t timescale, int64_t epoch)
{
  retstr->CMTimeValue value = (CMTimeValue)value;
  retstr->CMTimeScale timescale = timescale;
  retstr->CMTimeFlags flags = 1;
  retstr->CMTimeEpoch epoch = epoch;
  if (timescale <= 0)
  {
    retstr->CMTimeValue value = 0;
    *(void *)&retstr->CMTimeScale timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
  }
  return value;
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  retstr->CMTimeValue value = 0;
  *(void *)&retstr->CMTimeScale timescale = 0;
  retstr->CMTimeEpoch epoch = 0;
  if (preferredTimescale < 1) {
    goto LABEL_32;
  }
  retstr->CMTimeScale timescale = preferredTimescale;
  retstr->CMTimeFlags flags = 1;
  if (seconds == 0.0) {
    goto LABEL_32;
  }
  double v3 = -((double)preferredTimescale * seconds);
  if (seconds >= 0.0) {
    double v3 = (double)preferredTimescale * seconds;
  }
  if (v3 <= 9.22337204e18)
  {
    int32_t v6 = preferredTimescale;
  }
  else
  {
    int32_t v4 = preferredTimescale >> 1;
    BOOL v5 = preferredTimescale < 2;
    if (preferredTimescale >= 2)
    {
      while (1)
      {
        double v3 = -((double)v4 * seconds);
        if (seconds >= 0.0) {
          double v3 = (double)v4 * seconds;
        }
        if (v3 <= 9.22337204e18) {
          break;
        }
        int32_t v6 = v4 >> 1;
        BOOL v7 = v4 >= 2;
        BOOL v5 = v4 < 2;
        v4 >>= 1;
        if (!v7) {
          goto LABEL_14;
        }
      }
    }
    int32_t v6 = v4;
LABEL_14:
    retstr->CMTimeScale timescale = v6;
    if (v5)
    {
      retstr->CMTimeEpoch epoch = 0;
      if (seconds >= 0.0) {
        CFTypeID v8 = &kCMTimePositiveInfinity;
      }
      else {
        CFTypeID v8 = &kCMTimeNegativeInfinity;
      }
      *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&v8->value;
      goto LABEL_32;
    }
  }
  CMTimeValue v9 = (uint64_t)v3;
  if (v3 == 9.22337204e18) {
    CMTimeValue v9 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (seconds < 0.0) {
    CMTimeValue v9 = -v9;
  }
  retstr->CMTimeValue value = v9;
  double v10 = (double)v9 / (double)v6 - seconds;
  if (v10 != 0.0)
  {
    retstr->CMTimeFlags flags = 3;
    if (preferredTimescale <= 100
      && (v10 > 0.01 || v10 < -0.01)
      && fabs(v10) < 1.0
      && CMTimeMakeWithSeconds_onlyThisManyTimes >= 1)
    {
      --CMTimeMakeWithSeconds_onlyThisManyTimes;
      *(void *)&preferredTimescale = CFLog();
    }
  }
LABEL_32:
  LODWORD(result) = preferredTimescale;
  return result;
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  CMTimeFlags flags = time->flags;
  if ((flags & 0x11) == 1)
  {
    if ((flags & 4) != 0) {
      return INFINITY;
    }
    if ((flags & 8) != 0) {
      return -INFINITY;
    }
    if ((flags & 0x1D) == 1) {
      return (double)time->value / (double)time->timescale;
    }
  }
  return NAN;
}

CMTime *__cdecl CMTimeConvertScale(CMTime *__return_ptr retstr, CMTime *time, int32_t newTimescale, CMTimeRoundingMethod method)
{
  int32_t v4 = time;
  int v14 = 0;
  if ((time->flags & 0x1D) != 1) {
    goto LABEL_4;
  }
  if (newTimescale <= 0)
  {
    retstr->CMTimeValue value = 0;
    *(void *)&retstr->uint64_t timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
    return time;
  }
  uint64_t timescale = time->timescale;
  if (timescale == newTimescale)
  {
LABEL_4:
    *retstr = *time;
    return time;
  }
  CMTime time = (CMTime *)FigInt64MulDiv(time->value, newTimescale, time->timescale, &v14);
  if (time == (CMTime *)0x7FFFFFFFFFFFFFFFLL)
  {
    retstr->CMTimeEpoch epoch = 0;
    CMTimeValue v9 = &kCMTimePositiveInfinity;
    goto LABEL_10;
  }
  if (time == (CMTime *)0x8000000000000000)
  {
    retstr->CMTimeEpoch epoch = 0;
    CMTimeValue v9 = &kCMTimeNegativeInfinity;
LABEL_10:
    *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&v9->value;
    return time;
  }
  CMTimeEpoch epoch = v4->epoch;
  retstr->CMTimeValue value = (CMTimeValue)time;
  retstr->CMTimeEpoch epoch = epoch;
  LODWORD(epoch) = v4->flags & 2 | 1;
  retstr->uint64_t timescale = newTimescale;
  retstr->CMTimeFlags flags = epoch;
  int v11 = v14;
  if (v14)
  {
    retstr->CMTimeFlags flags = 3;
    switch(method)
    {
      case kCMTimeRoundingMethod_RoundHalfAwayFromZero:
        if (v11 >= 0) {
          int v12 = v11;
        }
        else {
          int v12 = -v11;
        }
        if ((2 * v12) >= timescale) {
          goto LABEL_20;
        }
        return time;
      case kCMTimeRoundingMethod_RoundAwayFromZero:
        goto LABEL_20;
      case kCMTimeRoundingMethod_QuickTime:
        if ((int)timescale < newTimescale)
        {
LABEL_20:
          if (v11 < 0) {
LABEL_25:
          }
            CMTimeValue v13 = (CMTimeValue)&time[-1].epoch + 7;
          else {
LABEL_23:
          }
            CMTimeValue v13 = (CMTimeValue)&time->value + 1;
          goto LABEL_26;
        }
        if (!time && v4->value < 0)
        {
          CMTimeValue v13 = -1;
LABEL_26:
          retstr->CMTimeValue value = v13;
          return time;
        }
        break;
      case kCMTimeRoundingMethod_RoundTowardPositiveInfinity:
        if ((v11 & 0x80000000) == 0) {
          goto LABEL_23;
        }
        return time;
      case kCMTimeRoundingMethod_RoundTowardNegativeInfinity:
        if (v11 < 0) {
          goto LABEL_25;
        }
        return time;
      default:
        return time;
    }
  }
  return time;
}

CMTime *__cdecl CMTimeAdd(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  retstr->CMTimeValue value = 0;
  *(void *)&retstr->CMTimeScale timescale = 0;
  retstr->CMTimeEpoch epoch = 0;
  CMTimeFlags flags = lhs->flags;
  if ((flags & 1) == 0) {
    goto LABEL_66;
  }
  CMTimeFlags v6 = rhs->flags;
  if ((v6 & 1) == 0) {
    goto LABEL_66;
  }
  if ((flags & 4) != 0)
  {
    if ((v6 & 8) == 0) {
      goto LABEL_54;
    }
    goto LABEL_66;
  }
  if ((flags & 8) != 0)
  {
    if ((v6 & 4) != 0) {
      goto LABEL_66;
    }
LABEL_56:
    retstr->CMTimeEpoch epoch = 0;
    CFDictionaryRef v24 = &kCMTimeNegativeInfinity;
    goto LABEL_57;
  }
  if ((v6 & 4) != 0) {
    goto LABEL_54;
  }
  if ((v6 & 8) != 0) {
    goto LABEL_56;
  }
  char v7 = v6 | flags;
  if ((v7 & 0x10) != 0)
  {
    retstr->CMTimeEpoch epoch = 0;
    CFDictionaryRef v24 = &kCMTimeIndefinite;
    goto LABEL_57;
  }
  CFTypeID v8 = lhs;
  CMTimeEpoch epoch = lhs->epoch;
  CMTimeEpoch v10 = rhs->epoch;
  if (epoch)
  {
    if (!v10 || epoch == v10)
    {
      if (epoch == v10) {
        CMTimeEpoch v10 = 0;
      }
      else {
        CMTimeEpoch v10 = lhs->epoch;
      }
      goto LABEL_14;
    }
LABEL_66:
    retstr->CMTimeValue value = 0;
    *(void *)&retstr->CMTimeScale timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
    return lhs;
  }
LABEL_14:
  if (!lhs->value)
  {
    retstr->CMTimeValue value = rhs->value;
    CMTimeScale timescale = rhs->timescale;
    goto LABEL_61;
  }
  if (!rhs->value)
  {
    retstr->CMTimeValue value = lhs->value;
    CMTimeScale timescale = lhs->timescale;
LABEL_61:
    retstr->CMTimeEpoch epoch = v10;
    CMTimeFlags v26 = v7 & 2 | 1;
    retstr->CMTimeScale timescale = timescale;
LABEL_62:
    retstr->CMTimeFlags flags = v26;
    return lhs;
  }
  CMTimeScale v11 = lhs->timescale;
  CMTimeScale v12 = rhs->timescale;
  int32_t v13 = v11;
  if (v11 != v12)
  {
    uint64_t v14 = v12;
    CMTimeScale v15 = 1;
    if (v11 != -1 && v12 != -1)
    {
      CMTimeScale v15 = lhs->timescale;
      if (v12)
      {
        CMTimeScale v16 = lhs->timescale;
        do
        {
          CMTimeScale v15 = v12;
          CMTimeScale v12 = v16 % v12;
          CMTimeScale v16 = v15;
        }
        while (v12);
      }
    }
    if (v14 / v15 * v11 <= 0x7FFFFFFF) {
      int32_t v13 = v14 / v15 * v11;
    }
    else {
      int32_t v13 = 1000000000;
    }
  }
  while (1)
  {
    if (v13 == v11)
    {
      CMTimeValue value = (unsigned char *)v8->value;
      CMTimeFlags v18 = v8->flags;
    }
    else
    {
      CMTime v27 = *v8;
      CMTime lhs = CMTimeConvertScale(&v28, &v27, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      CMTimeFlags v18 = v28.flags;
      if ((v28.flags & 1) == 0) {
        goto LABEL_66;
      }
      CMTimeValue value = (unsigned char *)v28.value;
      if ((v28.flags & 4) != 0)
      {
        if (v13 >= 2) {
          goto LABEL_52;
        }
      }
      else if (v13 >= 2 && (v28.flags & 8) != 0)
      {
        goto LABEL_52;
      }
    }
    if (v13 == rhs->timescale)
    {
      CMTimeValue v19 = rhs->value;
      CMTimeFlags v20 = rhs->flags;
    }
    else
    {
      CMTime v27 = *rhs;
      CMTime lhs = CMTimeConvertScale(&v28, &v27, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      CMTimeFlags v20 = v28.flags;
      if ((v28.flags & 1) == 0) {
        goto LABEL_66;
      }
      CMTimeValue v19 = v28.value;
      if ((v28.flags & 4) != 0)
      {
        if (v13 > 1) {
          goto LABEL_52;
        }
      }
      else if (v13 >= 2 && (v28.flags & 8) != 0)
      {
        goto LABEL_52;
      }
    }
    if ((~v18 & 5) == 0)
    {
      if ((~v20 & 9) != 0) {
        goto LABEL_54;
      }
      goto LABEL_66;
    }
    int v21 = v20 & 5;
    if ((~v18 & 9) == 0)
    {
      if (v21 != 5) {
        goto LABEL_56;
      }
      goto LABEL_66;
    }
    if (v21 == 5) {
      goto LABEL_54;
    }
    if ((~v20 & 9) == 0) {
      goto LABEL_56;
    }
    if ((v18 & 0x1D) != 1 || (v20 & 0x1D) != 1) {
      goto LABEL_66;
    }
    BOOL v22 = __OFADD__(value, v19);
    CMTimeValue v23 = (CMTimeValue)&value[v19];
    if (!v22)
    {
      retstr->CMTimeValue value = v23;
      retstr->CMTimeEpoch epoch = v10;
      CMTimeFlags v26 = (v20 | v18) & 2 | 1;
      retstr->CMTimeScale timescale = v13;
      goto LABEL_62;
    }
    if (v13 <= 1) {
      break;
    }
LABEL_52:
    int32_t v13 = v13 >> 1;
    CMTimeScale v11 = v8->timescale;
  }
  if ((v23 & 0x8000000000000000) == 0) {
    goto LABEL_56;
  }
LABEL_54:
  retstr->CMTimeEpoch epoch = 0;
  CFDictionaryRef v24 = &kCMTimePositiveInfinity;
LABEL_57:
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&v24->value;
  return lhs;
}

CMTime *__cdecl CMTimeSubtract(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  retstr->CMTimeValue value = 0;
  *(void *)&retstr->CMTimeScale timescale = 0;
  retstr->CMTimeEpoch epoch = 0;
  CMTimeFlags flags = lhs->flags;
  if ((flags & 1) == 0) {
    goto LABEL_66;
  }
  CMTimeFlags v6 = rhs->flags;
  if ((v6 & 1) == 0) {
    goto LABEL_66;
  }
  if ((flags & 4) != 0)
  {
    if ((v6 & 4) == 0) {
      goto LABEL_19;
    }
    goto LABEL_66;
  }
  if ((flags & 8) != 0)
  {
    if ((v6 & 8) != 0) {
      goto LABEL_66;
    }
LABEL_21:
    retstr->CMTimeEpoch epoch = 0;
    CMTimeScale v12 = &kCMTimeNegativeInfinity;
    goto LABEL_22;
  }
  if ((v6 & 4) != 0) {
    goto LABEL_21;
  }
  if ((v6 & 8) != 0) {
    goto LABEL_19;
  }
  char v7 = v6 | flags;
  if ((v7 & 0x10) != 0)
  {
    retstr->CMTimeEpoch epoch = 0;
    CMTimeScale v12 = &kCMTimeIndefinite;
    goto LABEL_22;
  }
  CFTypeID v8 = lhs;
  CMTimeEpoch epoch = lhs->epoch;
  CMTimeEpoch v10 = rhs->epoch;
  if (!epoch) {
    goto LABEL_14;
  }
  if (v10 && epoch != v10)
  {
LABEL_66:
    retstr->CMTimeValue value = 0;
    *(void *)&retstr->CMTimeScale timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
    return lhs;
  }
  if (epoch == v10) {
    CMTimeEpoch v10 = 0;
  }
  else {
    CMTimeEpoch v10 = lhs->epoch;
  }
LABEL_14:
  if (!rhs->value)
  {
    retstr->CMTimeValue value = lhs->value;
    CMTimeScale timescale = lhs->timescale;
    retstr->CMTimeEpoch epoch = v10;
    CMTimeFlags v11 = v7 & 2 | 1;
    retstr->CMTimeScale timescale = timescale;
    goto LABEL_25;
  }
  if (rhs->value != 0x8000000000000000 && !lhs->value)
  {
    *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&rhs->value;
    retstr->CMTimeValue value = -retstr->value;
    retstr->CMTimeEpoch epoch = v10;
    CMTimeFlags v11 = v7 & 2 | 1;
LABEL_25:
    retstr->CMTimeFlags flags = v11;
    return lhs;
  }
  CMTimeScale v14 = lhs->timescale;
  CMTimeScale v15 = rhs->timescale;
  int32_t v16 = v14;
  if (v14 != v15)
  {
    uint64_t v17 = v15;
    CMTimeScale v18 = 1;
    if (v14 != -1 && v15 != -1)
    {
      CMTimeScale v18 = lhs->timescale;
      if (v15)
      {
        CMTimeScale v19 = lhs->timescale;
        do
        {
          CMTimeScale v18 = v15;
          CMTimeScale v15 = v19 % v15;
          CMTimeScale v19 = v18;
        }
        while (v15);
      }
    }
    if (v17 / v18 * v14 <= 0x7FFFFFFF) {
      int32_t v16 = v17 / v18 * v14;
    }
    else {
      int32_t v16 = 1000000000;
    }
  }
  while (1)
  {
    if (v16 == v14)
    {
      CMTimeValue value = (unsigned char *)v8->value;
      CMTimeFlags v21 = v8->flags;
    }
    else
    {
      CMTime v26 = *v8;
      CMTime lhs = CMTimeConvertScale(&v27, &v26, v16, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      CMTimeFlags v21 = v27.flags;
      if ((v27.flags & 1) == 0) {
        goto LABEL_66;
      }
      CMTimeValue value = (unsigned char *)v27.value;
      if ((v27.flags & 4) != 0)
      {
        if (v16 >= 2) {
          goto LABEL_62;
        }
      }
      else if (v16 >= 2 && (v27.flags & 8) != 0)
      {
        goto LABEL_62;
      }
    }
    if (v16 == rhs->timescale)
    {
      CMTimeValue v22 = rhs->value;
      CMTimeFlags v23 = rhs->flags;
    }
    else
    {
      CMTime v26 = *rhs;
      CMTime lhs = CMTimeConvertScale(&v27, &v26, v16, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      CMTimeFlags v23 = v27.flags;
      if ((v27.flags & 1) == 0) {
        goto LABEL_66;
      }
      CMTimeValue v22 = v27.value;
      if ((v27.flags & 4) != 0)
      {
        if (v16 > 1) {
          goto LABEL_62;
        }
      }
      else if (v16 >= 2 && (v27.flags & 8) != 0)
      {
        goto LABEL_62;
      }
    }
    if ((~v21 & 5) == 0)
    {
      if ((~v23 & 5) != 0) {
        goto LABEL_19;
      }
      goto LABEL_66;
    }
    if ((~v21 & 9) == 0)
    {
      if ((~v23 & 9) != 0) {
        goto LABEL_21;
      }
      goto LABEL_66;
    }
    if ((~v23 & 5) == 0) {
      goto LABEL_21;
    }
    if ((~v23 & 9) == 0) {
      goto LABEL_19;
    }
    if ((v21 & 0x1D) != 1 || (v23 & 0x1D) != 1) {
      goto LABEL_66;
    }
    BOOL v24 = __OFSUB__(value, v22);
    CMTimeValue v25 = (CMTimeValue)&value[-v22];
    if (!v24)
    {
      retstr->CMTimeValue value = v25;
      retstr->CMTimeEpoch epoch = v10;
      CMTimeFlags v11 = (v23 | v21) & 2 | 1;
      retstr->CMTimeScale timescale = v16;
      goto LABEL_25;
    }
    if (v16 <= 1) {
      break;
    }
LABEL_62:
    int32_t v16 = v16 >> 1;
    CMTimeScale v14 = v8->timescale;
  }
  if ((v25 & 0x8000000000000000) == 0) {
    goto LABEL_21;
  }
LABEL_19:
  retstr->CMTimeEpoch epoch = 0;
  CMTimeScale v12 = &kCMTimePositiveInfinity;
LABEL_22:
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&v12->value;
  return lhs;
}

CMTime *__cdecl CMTimeMultiply(CMTime *__return_ptr retstr, CMTime *time, int32_t multiplier)
{
  CMTimeFlags flags = time->flags;
  if ((flags & 1) == 0)
  {
LABEL_2:
    retstr->CMTimeValue value = 0;
    *(void *)&retstr->CMTimeScale timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
    return time;
  }
  if ((flags & 0x10) == 0)
  {
    if ((flags & 4) != 0)
    {
LABEL_17:
      if (multiplier < 0) {
        goto LABEL_20;
      }
    }
    else
    {
      if ((flags & 8) == 0)
      {
        CMTimeFlags v6 = time;
        CMTimeEpoch epoch = time->epoch;
        CMTimeScale timescale = time->timescale;
        int32_t v9 = timescale;
        while (1)
        {
          if (v9 == timescale)
          {
            CMTimeValue value = (unsigned char *)v6->value;
            CMTimeFlags v11 = v6->flags;
          }
          else
          {
            CMTime v13 = *v6;
            CMTime time = CMTimeConvertScale(&v14, &v13, v9, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
            LOBYTE(v11) = v14.flags;
            if ((v14.flags & 1) == 0) {
              goto LABEL_2;
            }
            if ((v14.flags & 4) != 0) {
              goto LABEL_17;
            }
            if ((v14.flags & 8) != 0) {
              goto LABEL_19;
            }
            CMTimeValue value = (unsigned char *)v14.value;
          }
          CMTime time = (CMTime *)FigInt64MulDiv((int64_t)value, multiplier, 1, 0);
          if ((unint64_t)&time[0xFAAAAAAAAAAAAAABLL] - 7 > 1)
          {
            retstr->CMTimeValue value = (CMTimeValue)time;
            retstr->CMTimeEpoch epoch = epoch;
            retstr->CMTimeScale timescale = v9;
            retstr->CMTimeFlags flags = v11 & 2 | 1;
            return time;
          }
          if (v9 < 2) {
            break;
          }
          int32_t v9 = v9 >> 1;
          CMTimeScale timescale = v6->timescale;
        }
        if (((unint64_t)time & 0x8000000000000000) != 0) {
          goto LABEL_20;
        }
        goto LABEL_18;
      }
LABEL_19:
      if ((multiplier & 0x80000000) == 0)
      {
LABEL_20:
        retstr->CMTimeEpoch epoch = 0;
        CMTimeScale v12 = &kCMTimeNegativeInfinity;
        goto LABEL_21;
      }
    }
LABEL_18:
    retstr->CMTimeEpoch epoch = 0;
    CMTimeScale v12 = &kCMTimePositiveInfinity;
    goto LABEL_21;
  }
  retstr->CMTimeEpoch epoch = 0;
  CMTimeScale v12 = &kCMTimeIndefinite;
LABEL_21:
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&v12->value;
  return time;
}

CMTime *__cdecl CMTimeMultiplyByFloat64(CMTime *__return_ptr retstr, CMTime *time, Float64 multiplier)
{
  retstr->CMTimeValue value = 0;
  CMTimeFlags flags = time->flags;
  if ((flags & 1) == 0)
  {
LABEL_2:
    retstr->CMTimeValue value = 0;
    *(void *)&retstr->CMTimeScale timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
    return time;
  }
  if ((flags & 0x10) != 0)
  {
    retstr->CMTimeEpoch epoch = 0;
    int32_t v16 = &kCMTimeIndefinite;
    goto LABEL_34;
  }
  if ((flags & 4) != 0)
  {
LABEL_30:
    if (multiplier >= 0.0) {
      goto LABEL_33;
    }
LABEL_31:
    retstr->CMTimeEpoch epoch = 0;
    int32_t v16 = &kCMTimeNegativeInfinity;
    goto LABEL_34;
  }
  if ((flags & 8) != 0)
  {
LABEL_32:
    if (multiplier < 0.0) {
      goto LABEL_33;
    }
    goto LABEL_31;
  }
  CMTimeFlags v6 = time;
  CMTimeEpoch epoch = time->epoch;
  CMTimeScale timescale = time->timescale;
  double v9 = (double)(uint64_t)multiplier;
  if (timescale <= 1000000000) {
    CMTimeScale v10 = 1000000000;
  }
  else {
    CMTimeScale v10 = time->timescale;
  }
  if (v9 == multiplier) {
    int32_t v11 = time->timescale;
  }
  else {
    int32_t v11 = v10;
  }
  while (1)
  {
    if (v11 == timescale)
    {
      CMTimeValue value = (unsigned char *)v6->value;
      CMTimeFlags v13 = v6->flags;
    }
    else
    {
      CMTime v19 = *v6;
      CMTime time = CMTimeConvertScale(&v20, &v19, v11, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      LOBYTE(v13) = v20.flags;
      if ((v20.flags & 1) == 0) {
        goto LABEL_2;
      }
      if ((v20.flags & 4) != 0)
      {
        if (v11 < 2) {
          goto LABEL_30;
        }
        goto LABEL_28;
      }
      if ((v20.flags & 8) != 0)
      {
        if (v11 <= 1) {
          goto LABEL_32;
        }
        goto LABEL_28;
      }
      CMTimeValue value = (unsigned char *)v20.value;
    }
    double v14 = (double)(uint64_t)value * multiplier;
    if (v14 <= 9.22337204e18 && v14 >= -9.22337204e18)
    {
      if (v14 >= 9.22337204e18)
      {
        CMTimeValue v18 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else if (v14 <= -9.22337204e18)
      {
        CMTimeValue v18 = 0x8000000000000000;
      }
      else
      {
        if (v14 >= 0.0) {
          double v17 = 0.5;
        }
        else {
          double v17 = -0.5;
        }
        CMTimeValue v18 = (uint64_t)(v14 + v17);
      }
      retstr->CMTimeValue value = v18;
      retstr->CMTimeEpoch epoch = epoch;
      retstr->CMTimeScale timescale = v11;
      retstr->CMTimeFlags flags = v13 & 2 | 1;
      if ((v13 & 2) == 0
        && ((unint64_t)(v18 - 0x8000000000001) <= 0xFFEFFFFFFFFFFFFELL || v11 <= 999999999
                                                                                && v14 != (double)v18))
      {
        retstr->CMTimeFlags flags = 3;
      }
      return time;
    }
    if (v11 <= 1) {
      break;
    }
LABEL_28:
    int32_t v11 = v11 >> 1;
    CMTimeScale timescale = v6->timescale;
  }
  if (v14 < 0.0) {
    goto LABEL_31;
  }
LABEL_33:
  retstr->CMTimeEpoch epoch = 0;
  int32_t v16 = &kCMTimePositiveInfinity;
LABEL_34:
  *(_OWORD *)&retstr->CMTimeValue value = *(_OWORD *)&v16->value;
  return time;
}

uint64_t CMTimeDivide(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 12);
  if ((v4 & 1) == 0) {
    goto LABEL_48;
  }
  int v6 = *(_DWORD *)(a2 + 12);
  if ((v6 & 1) == 0) {
    goto LABEL_48;
  }
  if ((*(_DWORD *)(a1 + 12) & 0x1D) != 1 || (*(_DWORD *)(a2 + 12) & 0x1D) != 1) {
    goto LABEL_48;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a2 + 16);
  if (v9)
  {
    if (v10 && v9 != v10) {
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v9 = *(void *)(a2 + 16);
  }
  if (!*(void *)a2) {
    goto LABEL_48;
  }
  if (!*(void *)a1)
  {
    uint64_t result = 0;
    if (!a3) {
      return result;
    }
    uint64_t v22 = 0;
    int32_t v13 = *(_DWORD *)(a1 + 8);
    char v23 = v6 | v4;
    goto LABEL_54;
  }
  int32_t v11 = *(_DWORD *)(a1 + 8);
  int v12 = *(_DWORD *)(a2 + 8);
  int32_t v13 = v11;
  if (v11 != v12)
  {
    uint64_t v14 = v12;
    int v15 = 1;
    if (v11 != -1 && v12 != -1)
    {
      int v15 = *(_DWORD *)(a1 + 8);
      if (v12)
      {
        int v16 = *(_DWORD *)(a1 + 8);
        do
        {
          int v15 = v12;
          int v12 = v16 % v12;
          int v16 = v15;
        }
        while (v12);
      }
    }
    if (v14 / v15 * v11 <= 0x7FFFFFFF) {
      int32_t v13 = v14 / v15 * v11;
    }
    else {
      int32_t v13 = 1000000000;
    }
  }
  while (1)
  {
    if (v13 == v11)
    {
      CMTimeValue value = *(void *)a1;
      int v18 = *(_DWORD *)(a1 + 12);
    }
    else
    {
      CMTime v26 = *(CMTime *)a1;
      CMTimeConvertScale(&v27, &v26, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      LOBYTE(v18) = v27.flags;
      if ((v27.flags & 1) == 0) {
        goto LABEL_48;
      }
      CMTimeValue value = v27.value;
      if ((v27.flags & 4) != 0)
      {
        if (v13 >= 2) {
          goto LABEL_40;
        }
      }
      else if (v13 >= 2 && (v27.flags & 8) != 0)
      {
        goto LABEL_40;
      }
    }
    if (v13 == *(_DWORD *)(a2 + 8)) {
      break;
    }
    CMTime v26 = *(CMTime *)a2;
    CMTimeConvertScale(&v27, &v26, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    LOBYTE(v19) = v27.flags;
    if ((v27.flags & 1) == 0) {
      goto LABEL_48;
    }
    CMTimeValue v20 = v27.value;
    if ((v27.flags & 4) != 0)
    {
      if (v13 <= 1) {
        goto LABEL_44;
      }
    }
    else if (v13 < 2 || (v27.flags & 8) == 0)
    {
      goto LABEL_44;
    }
LABEL_40:
    int32_t v13 = v13 >> 1;
    int32_t v11 = *(_DWORD *)(a1 + 8);
  }
  CMTimeValue v20 = *(void *)a2;
  int v19 = *(_DWORD *)(a2 + 12);
LABEL_44:
  if ((v18 & 0x1D) != 1 || (v19 & 0x1D) != 1)
  {
LABEL_48:
    uint64_t result = 0;
    if (a3)
    {
      int v25 = 0;
      int32_t v13 = 0;
      uint64_t v9 = 0;
      uint64_t v22 = 0;
      goto LABEL_50;
    }
    return result;
  }
  uint64_t result = value / v20;
  if (!a3) {
    return result;
  }
  uint64_t v22 = value % v20;
  char v23 = v19 | v18;
LABEL_54:
  int v25 = v23 & 2 | 1;
LABEL_50:
  *(void *)a3 = v22;
  *(_DWORD *)(a3 + 8) = v13;
  *(_DWORD *)(a3 + 12) = v25;
  *(void *)(a3 + 16) = v9;
  return result;
}

uint64_t CMTimeRemainder@<X0>(long long *a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  long long v6 = *a1;
  uint64_t v7 = *((void *)a1 + 2);
  long long v4 = *a2;
  uint64_t v5 = *((void *)a2 + 2);
  return CMTimeDivide((uint64_t)&v6, (uint64_t)&v4, (uint64_t)a3);
}

CMTime *__cdecl CMTimeMultiplyByRatio(CMTime *__return_ptr retstr, CMTime *time, int32_t multiplier, int32_t divisor)
{
  int v39 = 0;
  if (divisor >= 0) {
    int v5 = (multiplier >> 31) | 1;
  }
  else {
    int v5 = -((multiplier >> 31) | 1);
  }
  CMTimeFlags flags = time->flags;
  if ((flags & 1) == 0) {
    goto LABEL_5;
  }
  if ((flags & 0x10) != 0)
  {
    retstr->CMTimeEpoch epoch = 0;
    CMTime v28 = &kCMTimeIndefinite;
    goto LABEL_73;
  }
  LODWORD(v7) = divisor;
  LODWORD(v8) = multiplier;
  uint64_t v9 = time;
  if (!divisor)
  {
    CMTime time1 = *time;
    CMTime time = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero);
    if (!v8 || !time) {
      goto LABEL_5;
    }
    CMTime time1 = *v9;
    CMTime time = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero);
    if ((int)time >= 1) {
      goto LABEL_68;
    }
    CMTime time1 = *v9;
    CMTime time = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero);
    if ((time & 0x80000000) != 0)
    {
LABEL_71:
      if ((v5 & 0x80000000) == 0) {
        goto LABEL_72;
      }
      goto LABEL_69;
    }
  }
  if ((flags & 4) != 0)
  {
    if (!v8) {
      goto LABEL_5;
    }
LABEL_68:
    if (v5 < 0) {
      goto LABEL_72;
    }
LABEL_69:
    retstr->CMTimeEpoch epoch = 0;
    CMTime v28 = &kCMTimePositiveInfinity;
    goto LABEL_73;
  }
  if ((flags & 8) != 0)
  {
    if (v8) {
      goto LABEL_71;
    }
LABEL_5:
    retstr->int64_t value = 0;
    *(void *)&retstr->CMTimeScale timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
    return time;
  }
  if (v8 && v7 && v8 != -1 && v7 != -1)
  {
    uint64_t v10 = (int)v7;
    uint64_t v11 = (int)v8;
    do
    {
      uint64_t v12 = v11;
      uint64_t v11 = v10;
      uint64_t v10 = v12 % v10;
    }
    while (v10);
    if (v11 < 0) {
      uint64_t v11 = -v11;
    }
    if (v11 != 1)
    {
      uint64_t v8 = (int)v8 / v11;
      uint64_t v7 = (int)v7 / v11;
    }
  }
  CMTimeEpoch epoch = v9->epoch;
  int64_t value = v9->value;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        CMTime time = (CMTime *)FigInt64MulDiv(value, v8, 1, 0);
        CMTimeScale timescale = v9->timescale;
        if (time) {
          uint64_t v15 = (int)v7;
        }
        else {
          uint64_t v15 = 1;
        }
        uint64_t v16 = v15 * timescale;
        if ((unint64_t)&time[0xFAAAAAAAAAAAAAABLL] - 7 >= 2
          && v16 <= 0x7FFFFFFF
          && v16 > (uint64_t)0xFFFFFFFF80000000)
        {
          LOBYTE(v29) = 0;
          BOOL v30 = 1;
LABEL_89:
          if (v16 >= 0) {
            CMTimeValue v32 = (CMTimeValue)time;
          }
          else {
            CMTimeValue v32 = -(uint64_t)time;
          }
          retstr->int64_t value = v32;
          if (v16 >= 0) {
            LODWORD(v33) = v16;
          }
          else {
            uint64_t v33 = -v16;
          }
          retstr->CMTimeEpoch epoch = epoch;
          retstr->CMTimeScale timescale = v33;
          retstr->CMTimeFlags flags = 1;
          if (v30)
          {
            if (v29) {
              int v34 = v29 & 2;
            }
            else {
              int v34 = v9->flags & 2;
            }
            CMTimeFlags v35 = v34 | 1;
          }
          else
          {
            CMTimeFlags v35 = 3;
          }
          retstr->CMTimeFlags flags = v35;
          return time;
        }
        int64_t value = v9->value;
        if (v7 == -1 || value == -1) {
          break;
        }
        uint64_t v19 = v9->value;
        if (v7)
        {
          uint64_t v20 = (int)v7;
          uint64_t v21 = v9->value;
          do
          {
            uint64_t v19 = v20;
            uint64_t v20 = v21 % v20;
            uint64_t v21 = v19;
          }
          while (v20);
        }
        if (v19 < 0) {
          uint64_t v19 = -v19;
        }
        if (v19 == 1) {
          break;
        }
        value /= v19;
        v9->int64_t value = value;
        uint64_t v7 = (int)v7 / v19;
      }
      if (v8 == -1 || timescale == -1) {
        break;
      }
      uint64_t v22 = (int)v8;
      if (timescale)
      {
        uint64_t v23 = timescale;
        uint64_t v24 = (int)v8;
        do
        {
          uint64_t v22 = v23;
          uint64_t v23 = v24 % v23;
          uint64_t v24 = v22;
        }
        while (v23);
      }
      if (v22 < 0) {
        uint64_t v22 = -v22;
      }
      if (v22 == 1) {
        break;
      }
      v9->CMTimeScale timescale = timescale / v22;
      uint64_t v8 = (int)v8 / v22;
    }
    if (value == -1 || timescale == -1) {
      break;
    }
    if (timescale)
    {
      uint64_t v25 = timescale;
      uint64_t v26 = v9->value;
      do
      {
        uint64_t v27 = v25;
        uint64_t v25 = v26 % v25;
        uint64_t v26 = v27;
      }
      while (v25);
    }
    else
    {
      uint64_t v27 = v9->value;
    }
    if (v27 < 0) {
      uint64_t v27 = -v27;
    }
    if (v27 == 1) {
      break;
    }
    value /= v27;
    v9->int64_t value = value;
    v9->CMTimeScale timescale = timescale / v27;
  }
  uint64_t v16 = 1000000000;
  while (1)
  {
    if (v16 == timescale)
    {
      CMTime time = (CMTime *)v9->value;
      CMTimeFlags v29 = v9->flags;
    }
    else
    {
      CMTime timea = *v9;
      CMTime time = CMTimeConvertScale(&time1, &timea, v16, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      LOBYTE(v29) = time1.flags;
      if ((time1.flags & 1) == 0) {
        goto LABEL_5;
      }
      CMTime time = (CMTime *)time1.value;
      if ((time1.flags & 0xC) != 0)
      {
        if ((unint64_t)v16 >= 2) {
          goto LABEL_84;
        }
        if ((time1.flags & 4) != 0) {
          goto LABEL_68;
        }
        if ((time1.flags & 8) != 0) {
          goto LABEL_71;
        }
      }
    }
    CMTime time = (CMTime *)FigInt64MulDiv((int64_t)time, v8, v7, &v39);
    if ((unint64_t)&time[0xFAAAAAAAAAAAAAABLL] - 7 > 1)
    {
      BOOL v30 = v39 == 0;
      if ((int)v7 >= 0) {
        uint64_t v31 = (int)v7;
      }
      else {
        uint64_t v31 = -(uint64_t)(int)v7;
      }
      CMTime time = (CMTime *)((char *)time + 2 * v39 / v31);
      goto LABEL_89;
    }
    if ((unint64_t)v16 <= 1) {
      break;
    }
LABEL_84:
    uint64_t v16 = (unint64_t)v16 >> 1;
    CMTimeScale timescale = v9->timescale;
  }
  if (((unint64_t)time & 0x8000000000000000) == 0) {
    goto LABEL_69;
  }
LABEL_72:
  retstr->CMTimeEpoch epoch = 0;
  CMTime v28 = &kCMTimeNegativeInfinity;
LABEL_73:
  *(_OWORD *)&retstr->int64_t value = *(_OWORD *)&v28->value;
  return time;
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  CMTimeFlags flags = time1->flags;
  CMTimeFlags v4 = time2->flags;
  int32_t result = v4 & 1;
  if (flags)
  {
    if ((v4 & 1) == 0) {
      return -1;
    }
    if ((flags & 4) != 0)
    {
      return ((v4 >> 2) & 1) == 0;
    }
    else
    {
      if ((v4 & 4) != 0) {
        return -1;
      }
      if ((flags & 0x10) != 0)
      {
        return ((v4 >> 4) & 1) == 0;
      }
      else
      {
        if ((v4 & 0x10) != 0) {
          return -1;
        }
        if ((flags & 8) != 0)
        {
          return ((v4 >> 3) & 1) - 1;
        }
        else
        {
          if ((v4 & 8) != 0) {
            return 1;
          }
          CMTimeEpoch epoch = time1->epoch;
          CMTimeEpoch v7 = time2->epoch;
          if (epoch > v7)
          {
            return 1;
          }
          else
          {
            if (epoch < v7) {
              return -1;
            }
            CMTimeScale timescale = time1->timescale;
            CMTimeValue value = time1->value;
            CMTimeValue v10 = time2->value;
            if (timescale == time2->timescale)
            {
              if (value >= v10) {
                int32_t v11 = 0;
              }
              else {
                int32_t v11 = -1;
              }
              if (value > v10) {
                return 1;
              }
              else {
                return v11;
              }
            }
            else
            {
              return multiplyAndCompare96(value, time2->timescale, v10, timescale);
            }
          }
        }
      }
    }
  }
  return result;
}

CMTime *CMTimeMultiplyTimeByTimeRatio@<X0>(CMTime *result@<X0>, uint64_t a2@<X1>, CMTime *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if ((result->flags & 0x1D) != 1
    || (*(_DWORD *)(a2 + 12) & 0x1D) != 1
    || (a3->flags & 0x1D) != 1
    || (v7 = result, time1 = *a3, int32_t result = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero), !result))
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    return result;
  }
  uint64_t v8 = *(void *)a2;
  if (*(void *)a2 == (int)*(void *)a2)
  {
    uint64_t value = a3->value;
  }
  else
  {
    uint64_t v10 = *(int *)(a2 + 8);
    if (v10)
    {
      uint64_t v11 = *(int *)(a2 + 8);
      uint64_t v12 = *(void *)a2;
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = v11;
        uint64_t v11 = v13 % v11;
      }
      while (v11);
      if (v12 >= 0) {
        uint64_t v14 = v12;
      }
      else {
        uint64_t v14 = -v12;
      }
      uint64_t v15 = *(void *)a2;
      if (v14 != 1)
      {
        uint64_t v15 = v8 / v14;
        *(void *)a2 = v8 / v14;
        *(_DWORD *)(a2 + 8) = v10 / v14;
      }
    }
    else
    {
      uint64_t v15 = *(void *)a2;
    }
    uint64_t value = a3->value;
    if (v15 && value)
    {
      uint64_t v16 = a3->value;
      uint64_t v17 = v15;
      do
      {
        uint64_t v18 = v17;
        uint64_t v17 = v16;
        uint64_t v16 = v18 % v16;
      }
      while (v16);
      if (v17 < 0) {
        uint64_t v17 = -v17;
      }
      if (v17 != 1)
      {
        *(void *)a2 = v15 / v17;
        uint64_t value = a3->value / v17;
        a3->uint64_t value = value;
      }
    }
  }
  if (value != (int)value)
  {
    unint64_t v19 = v8 + 0x80000000;
    uint64_t timescale = a3->timescale;
    if (timescale)
    {
      uint64_t v21 = a3->timescale;
      uint64_t v22 = value;
      do
      {
        uint64_t v23 = v22;
        uint64_t v22 = v21;
        uint64_t v21 = v23 % v21;
      }
      while (v21);
      if (v22 < 0) {
        uint64_t v22 = -v22;
      }
      if (v22 != 1)
      {
        value /= v22;
        a3->uint64_t value = value;
        a3->uint64_t timescale = timescale / v22;
      }
    }
    if (!HIDWORD(v19) && *(void *)a2 && value)
    {
      uint64_t v24 = value;
      uint64_t v25 = *(void *)a2;
      do
      {
        uint64_t v26 = v25;
        uint64_t v25 = v24;
        uint64_t v24 = v26 % v24;
      }
      while (v24);
      if (v25 < 0) {
        uint64_t v25 = -v25;
      }
      if (v25 != 1)
      {
        *(uint64_t *)a2 /= v25;
        uint64_t value = a3->value / v25;
        a3->uint64_t value = value;
      }
    }
  }
  uint64_t v27 = *(void *)a2;
  if (*(void *)a2 != (int)*(void *)a2 || (unint64_t)(value + 0x80000000) >> 32)
  {
LABEL_47:
    int v33 = *(_DWORD *)(a2 + 12);
    CMTimeFlags flags = a3->flags;
    if ((v33 & 0x11) == 1)
    {
      if ((v33 & 4) != 0)
      {
        unint64_t v36 = 0x7FF0000000000000;
        goto LABEL_55;
      }
      if ((v33 & 8) != 0)
      {
        unint64_t v36 = 0xFFF0000000000000;
        goto LABEL_55;
      }
      if ((v33 & 0x1D) == 1)
      {
        double v35 = (double)v27 / (double)*(int *)(a2 + 8);
        goto LABEL_56;
      }
    }
    unint64_t v36 = 0x7FF8000000000000;
LABEL_55:
    double v35 = *(double *)&v36;
LABEL_56:
    if ((a3->flags & 0x11) == 1)
    {
      if ((flags & 4) != 0)
      {
        unint64_t v38 = 0x7FF0000000000000;
        goto LABEL_64;
      }
      if ((flags & 8) != 0)
      {
        unint64_t v38 = 0xFFF0000000000000;
        goto LABEL_64;
      }
      if ((a3->flags & 0x1D) == 1)
      {
        double v37 = (double)value / (double)a3->timescale;
        goto LABEL_65;
      }
    }
    unint64_t v38 = 0x7FF8000000000000;
LABEL_64:
    double v37 = *(double *)&v38;
LABEL_65:
    CMTime v40 = *v7;
    double v39 = v35 / v37;
    int32_t result = CMTimeMultiplyByFloat64(&time1, &v40, v35 / v37);
    CMTimeValue v42 = time1.value;
    CMTimeFlags v31 = time1.flags;
    CMTimeScale v43 = time1.timescale;
    CMTimeEpoch epoch = time1.epoch;
    if (v39 != (double)(uint64_t)v39) {
      CMTimeFlags v31 = time1.flags | 2;
    }
    goto LABEL_67;
  }
  int32_t v28 = *(_DWORD *)(a2 + 8);
  CMTime v40 = *v7;
  CMTimeMultiplyByRatio(&time1, &v40, v27, v28);
  CMTimeScale v43 = time1.timescale;
  CMTimeValue v42 = time1.value;
  int32_t v29 = a3->timescale;
  int32_t v30 = a3->value;
  CMTime v40 = time1;
  int32_t result = CMTimeMultiplyByRatio(&time1, &v40, v29, v30);
  CMTimeValue v42 = time1.value;
  CMTimeFlags v31 = time1.flags;
  CMTimeScale v43 = time1.timescale;
  if ((time1.flags & 2) != 0)
  {
    uint64_t v27 = *(void *)a2;
    uint64_t value = a3->value;
    goto LABEL_47;
  }
  CMTimeEpoch epoch = time1.epoch;
LABEL_67:
  *(void *)a4 = v42;
  *(_DWORD *)(a4 + 8) = v43;
  *(_DWORD *)(a4 + 12) = v31;
  *(void *)(a4 + 16) = epoch;
  return result;
}

uint64_t multiplyAndCompare96(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  if ((unint64_t)a1 >> 63 == (unint64_t)a3 >> 63)
  {
    if (a1 >= 0) {
      unint64_t v4 = a1;
    }
    else {
      unint64_t v4 = -a1;
    }
    if (a3 >= 0) {
      unint64_t v5 = a3;
    }
    else {
      unint64_t v5 = -a3;
    }
    unint64_t v6 = HIDWORD(v4);
    unint64_t v7 = v4 * (unint64_t)a2;
    unint64_t v8 = HIDWORD(v7) + v6 * (unint64_t)a2;
    unint64_t v9 = HIDWORD(v5);
    unint64_t v10 = v5 * (unint64_t)a4;
    unint64_t v11 = HIDWORD(v10) + v9 * (unint64_t)a4;
    BOOL v12 = v8 > v11;
    if (v8 >= v11) {
      int v13 = 0;
    }
    else {
      int v13 = -1;
    }
    if (v12) {
      int v13 = 1;
    }
    BOOL v14 = v7 > (unint64_t)v10;
    if (v7 >= (unint64_t)v10) {
      unsigned int v15 = 0;
    }
    else {
      unsigned int v15 = -1;
    }
    if (v14) {
      unsigned int v15 = 1;
    }
    if (v13) {
      unsigned int v15 = v13;
    }
    if (v15) {
      BOOL v16 = a1 < 0;
    }
    else {
      BOOL v16 = 0;
    }
  }
  else
  {
    BOOL v16 = a1 < 0;
    unsigned int v15 = 1;
  }
  if (v16) {
    return -v15;
  }
  else {
    return v15;
  }
}

CMTime *__cdecl CMTimeMinimum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  CMTime time1a = *time1;
  CMTime v8 = *time2;
  int32_t result = (CMTime *)CMTimeCompare(&time1a, &v8);
  if ((int)result >= 0) {
    unint64_t v7 = time2;
  }
  else {
    unint64_t v7 = time1;
  }
  *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&v7->value;
  retstr->CMTimeEpoch epoch = v7->epoch;
  return result;
}

CMTime *__cdecl CMTimeMaximum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  CMTime time1a = *time1;
  CMTime v8 = *time2;
  int32_t result = (CMTime *)CMTimeCompare(&time1a, &v8);
  if ((int)result >= 0) {
    unint64_t v7 = time1;
  }
  else {
    unint64_t v7 = time2;
  }
  *(_OWORD *)&retstr->uint64_t value = *(_OWORD *)&v7->value;
  retstr->CMTimeEpoch epoch = v7->epoch;
  return result;
}

CMTime *__cdecl CMTimeAbsoluteValue(CMTime *__return_ptr retstr, CMTime *time)
{
  if ((~time->flags & 9) != 0)
  {
    if (time->value < 0) {
      time->uint64_t value = -time->value;
    }
  }
  else
  {
    time->CMTimeEpoch epoch = 0;
    *(_OWORD *)&time->uint64_t value = *(_OWORD *)&kCMTimePositiveInfinity.value;
  }
  *retstr = *time;
  return time;
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)keys = xmmword_1E5677D68;
  long long v11 = *(_OWORD *)off_1E5677D78;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v9[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, time);
  v9[1] = CFNumberCreate(v4, kCFNumberSInt32Type, &time->timescale);
  _OWORD v9[2] = CFNumberCreate(v4, kCFNumberSInt64Type, &time->epoch);
  void v9[3] = CFNumberCreate(v4, kCFNumberSInt32Type, &time->flags);
  CFDictionaryRef v5 = CFDictionaryCreate(allocator, (const void **)keys, v9, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = 0; i != 4; ++i)
  {
    unint64_t v7 = v9[i];
    if (v7) {
      CFRelease(v7);
    }
  }
  return v5;
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CMTime *dictionaryRepresentation)
{
  retstr->uint64_t value = 0;
  *(void *)&retstr->uint64_t timescale = 0;
  retstr->CMTimeEpoch epoch = 0;
  if (!dictionaryRepresentation) {
    goto LABEL_15;
  }
  double v3 = dictionaryRepresentation;
  CFTypeID TypeID = (CMTime *)CFDictionaryGetTypeID();
  dictionaryRepresentation = (CMTime *)CFGetTypeID(v3);
  if (TypeID != dictionaryRepresentation) {
    goto LABEL_15;
  }
  CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)v3, @"value");
  unint64_t v6 = CFDictionaryGetValue((CFDictionaryRef)v3, @"timescale");
  unint64_t v7 = CFDictionaryGetValue((CFDictionaryRef)v3, @"epoch");
  dictionaryRepresentation = (CMTime *)CFDictionaryGetValue((CFDictionaryRef)v3, @"flags");
  if (!Value) {
    goto LABEL_15;
  }
  CMTime v8 = dictionaryRepresentation;
  unint64_t v9 = (CMTime *)CFGetTypeID(Value);
  dictionaryRepresentation = (CMTime *)CFNumberGetTypeID();
  if (v9 != dictionaryRepresentation) {
    goto LABEL_15;
  }
  if (!v6) {
    goto LABEL_15;
  }
  unint64_t v10 = (CMTime *)CFGetTypeID(v6);
  dictionaryRepresentation = (CMTime *)CFNumberGetTypeID();
  if (v10 != dictionaryRepresentation) {
    goto LABEL_15;
  }
  if (!v7) {
    goto LABEL_15;
  }
  long long v11 = (CMTime *)CFGetTypeID(v7);
  dictionaryRepresentation = (CMTime *)CFNumberGetTypeID();
  if (v11 != dictionaryRepresentation
    || !v8
    || (uint64_t v12 = (CMTime *)CFGetTypeID(v8),
        dictionaryRepresentation = (CMTime *)CFNumberGetTypeID(),
        v12 != dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt64Type, retstr),
        !dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)v6, kCFNumberSInt32Type, &retstr->timescale),
        !dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)v7, kCFNumberSInt64Type, &retstr->epoch),
        !dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)v8, kCFNumberSInt32Type, &retstr->flags),
        !dictionaryRepresentation))
  {
LABEL_15:
    retstr->uint64_t value = 0;
    *(void *)&retstr->uint64_t timescale = 0;
    retstr->CMTimeEpoch epoch = 0;
  }
  return dictionaryRepresentation;
}

CFDictionaryRef CMTimeCopyAsCVBufferTimeDictionary(_DWORD *valuePtr, const __CFAllocator *a2)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  if ((valuePtr[3] & 0x1D) != 1) {
    return 0;
  }
  CFAllocatorRef v4 = (void *)*MEMORY[0x1E4F24998];
  keys[0] = *(void **)MEMORY[0x1E4F249A0];
  keys[1] = v4;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, valuePtr);
  values[1] = CFNumberCreate(v5, kCFNumberSInt32Type, valuePtr + 2);
  CFDictionaryRef v6 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v7 = 0;
  char v8 = 1;
  do
  {
    char v9 = v8;
    unint64_t v10 = values[v7];
    if (v10) {
      CFRelease(v10);
    }
    char v8 = 0;
    uint64_t v7 = 1;
  }
  while ((v9 & 1) != 0);
  return v6;
}

CFTypeID CMTimeMakeFromCVBufferTimeDictionary@<X0>(CFTypeID result@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (!result) {
    goto LABEL_10;
  }
  double v3 = (const void *)result;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  int32_t result = CFGetTypeID(v3);
  if (TypeID != result) {
    goto LABEL_10;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v3, (const void *)*MEMORY[0x1E4F249A0]);
  int32_t result = (CFTypeID)CFDictionaryGetValue((CFDictionaryRef)v3, (const void *)*MEMORY[0x1E4F24998]);
  BOOL v6 = !Value || result == 0;
  if (!v6
    && (v7 = (const __CFNumber *)result, int32_t result = CFNumberGetValue(Value, kCFNumberSInt64Type, a2), result)
    && (int32_t result = CFNumberGetValue(v7, kCFNumberSInt32Type, a2 + 1), result))
  {
    *((_DWORD *)a2 + 3) = 1;
  }
  else
  {
LABEL_10:
    *a2 = 0;
    a2[1] = 0;
  }
  a2[2] = 0;
  return result;
}

CFStringRef CMTimeCopyDescription(CFAllocatorRef allocator, CMTime *time)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(allocator, 0);
  CFAllocatorRef v4 = Mutable;
  if (Mutable)
  {
    CMTimeFlags flags = time->flags;
    if (flags)
    {
      if ((flags & 0x10) != 0)
      {
        CFStringAppendFormat(Mutable, 0, @"{INDEFINITE}");
      }
      else if ((flags & 4) != 0)
      {
        CFStringAppendFormat(Mutable, 0, @"{+INFINITY}");
      }
      else if ((flags & 8) != 0)
      {
        CFStringAppendFormat(Mutable, 0, @"{-INFINITY}");
      }
      else if ((time->flags & 0x1D) == 1)
      {
        CMTimeValue value = time->value;
        uint64_t timescale = time->timescale;
        if ((time->flags & 0x11) == 1) {
          double v8 = (double)value / (double)(int)timescale;
        }
        else {
          double v8 = NAN;
        }
        CFStringAppendFormat(Mutable, 0, @"{%lld/%d = %1.3f", value, timescale, *(void *)&v8);
        if (time->epoch) {
          CFStringAppendFormat(v4, 0, @", epoch=%lld", time->epoch);
        }
        uint64_t v9 = time->flags;
        if ((time->flags & 0x1F) == 3)
        {
          CFStringAppendFormat(v4, 0, @", rounded");
          uint64_t v9 = time->flags;
        }
        if (v9 >= 4) {
          CFStringAppendFormat(v4, 0, @", flags=0x%08x", v9);
        }
        CFStringAppendFormat(v4, 0, @"}");
      }
      else
      {
        CFStringAppendFormat(Mutable, 0, @"{UNKNOWN}");
      }
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, @"{INVALID}");
    }
  }
  return v4;
}

void CMTimeShow(CMTime *time)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(CMTime *)CMTime timea = *time;
  CFStringRef v2 = CMTimeCopyDescription(v1, (CMTime *)timea);
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  memset(timea, 0, sizeof(timea));
  if (v2)
  {
    CFStringRef v3 = v2;
    if (CFStringGetCString(v2, timea, 512, 0)) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", timea);
    }
    CFRelease(v3);
  }
}

uint64_t FigPerformanceMonitorGetClassID()
{
  return sFigPerformanceMonitorClassID;
}

uint64_t RegisterFigPerformanceMonitorBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigPerformanceMonitorClassDesc, ClassID, 1, &sFigPerformanceMonitorClassID);
}

uint64_t FigPerformanceMonitorUpdateOSTransactionData(const void *a1, const char *a2, const char *a3, int a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 0;
  long long v26 = &v25;
  uint64_t v27 = 0x2020000000;
  int v28 = 0;
  uint64_t v21 = 0;
  long long v22 = &v21;
  uint64_t v23 = 0x2020000000;
  uint64_t v24 = 0;
  char v30 = 0;
  memset(buffer, 0, sizeof(buffer));
  pid_t v8 = getpid();
  if (proc_name(v8, buffer, 0x21u) >= 1)
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v10 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)buffer, 0x8000100u);
    if (v10)
    {
      long long v11 = FigRemote_ShouldConnectToMediaplaybackd() ? @"mediaplaybackd" : @"mediaserverd";
      BOOL v12 = FigCFEqual(v10, v11)
         && !FigGetCFPreferenceBooleanWithDefault(@"DisableFigPerfMonitor", @"com.apple.coremedia", 0)&& FigDebugIsInternalBuild() != 0;
      CFRelease(v10);
      if (v12)
      {
        if (FigPerformanceMonitorGetGlobal_onceToken != -1) {
          dispatch_once_f(&FigPerformanceMonitorGetGlobal_onceToken, 0, (dispatch_function_t)fpm_globalPerformanceMonitorInitOnce);
        }
        if (gPerformanceMonitor)
        {
          uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(gPerformanceMonitor);
          if (a1) {
            CFTypeRef v14 = CFRetain(a1);
          }
          else {
            CFTypeRef v14 = 0;
          }
          v22[3] = (uint64_t)v14;
          if (a2) {
            a2 = (const char *)CFStringCreateWithCString(v9, a2, 0x8000100u);
          }
          if (a3) {
            CFStringRef v15 = CFStringCreateWithCString(v9, a3, 0x8000100u);
          }
          else {
            CFStringRef v15 = 0;
          }
          long long v16 = *(NSObject **)(DerivedStorage + 8);
          v19[0] = MEMORY[0x1E4F143A8];
          v19[1] = 3221225472;
          v19[2] = __FigPerformanceMonitorUpdateOSTransactionData_block_invoke;
          v19[3] = &unk_1E5677D90;
          v19[4] = &v25;
          v19[5] = &v21;
          v19[6] = DerivedStorage;
          v19[7] = a2;
          v19[8] = v15;
          int v20 = a4;
          dispatch_async(v16, v19);
        }
        else
        {
          *((_DWORD *)v26 + 6) = -19070;
        }
      }
    }
  }
  uint64_t v17 = *((unsigned int *)v26 + 6);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  return v17;
}

void sub_18FD67888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void __FigPerformanceMonitorUpdateOSTransactionData_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  CFStringRef v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  long long v5 = *(const void **)(a1 + 56);
  CFAllocatorRef v4 = *(const void **)(a1 + 64);
  uint64_t v6 = *(unsigned int *)(a1 + 72);
  long long v20 = 0uLL;
  unsigned int v19 = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    int v15 = FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0);
    CFStringRef v11 = 0;
    CFStringRef v13 = 0;
    goto LABEL_20;
  }
  CFMutableDictionaryRef v9 = Mutable;
  if ((int)v6 >= 1)
  {
    FigApplicationStateMonitorGetHostPIDIfAvailable(v6, (int *)&v19);
    if ((int)v19 >= 1) {
      FigServer_CopyProcessName(v19, (CFStringRef *)&v20);
    }
  }
  FigServer_CopyProcessName(v6, (CFStringRef *)&v20 + 1);
  if (*((void *)&v20 + 1) && (void)v20)
  {
    CFStringRef Copy = CFStringCreateWithFormat(v7, 0, @"%@->%@ ", v20);
  }
  else
  {
    if (v20 == 0)
    {
      CFStringRef v11 = 0;
LABEL_16:
      FigCFDictionarySetValue(v9, @"name", v5);
      CFStringRef v13 = 0;
      goto LABEL_17;
    }
    if (*((void *)&v20 + 1)) {
      CFStringRef Copy = CFStringCreateCopy(v7, *((CFStringRef *)&v20 + 1));
    }
    else {
      CFStringRef Copy = CFStringCreateWithFormat(v7, 0, @"%@-><UNKNOWN>", (void)v20);
    }
  }
  CFStringRef v11 = Copy;
  if (!Copy) {
    goto LABEL_16;
  }
  CFStringRef v12 = CFStringCreateWithFormat(v7, 0, @"%@_%@", v5, Copy);
  if (!v12) {
    goto LABEL_16;
  }
  CFStringRef v13 = v12;
  FigCFDictionarySetValue(v9, @"name", v12);
LABEL_17:
  FigCFDictionarySetValue(v9, @"weakRef", v3);
  FigCFDictionarySetValue(v9, @"reason", v4);
  FigCFDictionarySetInt32(v9, @"pid", v6);
  unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  FigCFDictionarySetInt64(v9, @"creationTime", UpTimeNanoseconds);
  CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 64), v9);
  CFRelease(v9);
  if (*((void *)&v20 + 1)) {
    CFRelease(*((CFTypeRef *)&v20 + 1));
  }
  int v15 = 0;
LABEL_20:
  if ((void)v20) {
    CFRelease((CFTypeRef)v20);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v11) {
    CFRelease(v11);
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v15;
  uint64_t v16 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v16) {
    CFRelease(v16);
  }
  uint64_t v17 = *(const void **)(a1 + 56);
  if (v17) {
    CFRelease(v17);
  }
  long long v18 = *(const void **)(a1 + 64);
  if (v18) {
    CFRelease(v18);
  }
}

CFStringRef FigPerformanceMonitorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigPerformanceMonitor %p]", a1);
}

void fpm_globalPerformanceMonitorInitOnce()
{
  CFTypeRef v23 = 0;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  FigThreadRunOnce(&FigPerformanceMonitorGetClassID_sRegisterFigPerformanceMonitorBaseTypeOnce, (void (*)(void))RegisterFigPerformanceMonitorBaseType);
  if (CMDerivedObjectCreate((uint64_t)v0, (uint64_t)&kFigPerformanceMonitor_VTable, (void *)sFigPerformanceMonitorClassID, &v23))goto LABEL_15; {
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v23);
  }
  if (!DerivedStorage) {
    goto LABEL_15;
  }
  uint64_t v2 = DerivedStorage;
  dispatch_queue_t v3 = dispatch_queue_create("com.apple.coremedia.figperfmonitor.state", 0);
  *(void *)(v2 + 8) = v3;
  if (!v3) {
    goto LABEL_18;
  }
  CFAllocatorRef v4 = v3;
  CFTypeRef v5 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v23);
  if (v5)
  {
    uint64_t v6 = v5;
    dispatch_source_t v7 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v4);
    if (v7)
    {
      pid_t v8 = v7;
      dispatch_time_t v9 = dispatch_time(0, 30000000000);
      dispatch_source_set_timer(v8, v9, 0x6FC23AC00uLL, 0x3B9ACA00uLL);
      CFStringRef v10 = (void *)CFRetain(v6);
      dispatch_set_context(v8, v10);
      dispatch_source_set_event_handler_f(v8, (dispatch_function_t)fpm_timerCallback);
      dispatch_source_set_cancel_handler_f(v8, (dispatch_function_t)fpm_timerCancellationCallback);
      dispatch_resume(v8);
      int v11 = 0;
      *(void *)uint64_t v2 = v8;
    }
    else
    {
      int v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v6);
    if (v11) {
      goto LABEL_15;
    }
  }
  else if (FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0))
  {
    goto LABEL_15;
  }
  CFUUIDRef v12 = CFUUIDCreate(v0);
  if (!v12)
  {
LABEL_18:
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  CFUUIDRef v13 = v12;
  CFStringRef v14 = CFUUIDCreateString(v0, v12);
  *(void *)(v2 + 664) = v14;
  if (!v14) {
    goto LABEL_19;
  }
  pid_t v15 = getpid();
  *(_DWORD *)(v2 + 16) = v15;
  proc_name(v15, (void *)(v2 + 20), 0x21u);
  id v16 = objc_alloc_init(MEMORY[0x1E4F5E1F0]);
  *(void *)(v2 + 584) = v16;
  if (!v16) {
    goto LABEL_19;
  }
  *(_DWORD *)(v2 + 56) = arc4random();
  uint64_t v17 = (void *)MEMORY[0x192FC5D30]();
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 3221225472;
  v22[2] = __fpm_performanceMonitorCreate_block_invoke;
  v22[3] = &__block_descriptor_40_e5_v8__0l;
  v22[4] = v2;
  [*(id *)(v2 + 584) setScreenOnChangedHandler:v22];
  long long v18 = *(void **)(v2 + 584);
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = __fpm_performanceMonitorCreate_block_invoke_3;
  void v21[3] = &__block_descriptor_40_e5_v8__0l;
  v21[4] = v2;
  [v18 activateWithCompletion:v21];
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v0, 0, MEMORY[0x1E4F1D510]);
  *(void *)(v2 + 64) = Mutable;
  if (!Mutable) {
    goto LABEL_19;
  }
  CFMutableDictionaryRef v20 = CFDictionaryCreateMutable(v0, 0, 0, MEMORY[0x1E4F1D540]);
  *(void *)(v2 + 672) = v20;
  if (v20)
  {
    gPerformanceMonitor = (uint64_t)v23;
    CFTypeRef v23 = 0;
  }
  else
  {
LABEL_19:
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  CFRelease(v13);
LABEL_15:
  if (v23) {
    CFRelease(v23);
  }
}

void __fpm_performanceMonitorCreate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __fpm_performanceMonitorCreate_block_invoke_2;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = v1;
  dispatch_async(v2, block);
}

uint64_t __fpm_performanceMonitorCreate_block_invoke_2(uint64_t a1)
{
  unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(v3 + 648) = UpTimeNanoseconds;
  uint64_t result = [*(id *)(v3 + 584) screenOn];
  *(unsigned char *)(*(void *)(a1 + 32) + 64CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = result;
  return result;
}

void __fpm_performanceMonitorCreate_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __fpm_performanceMonitorCreate_block_invoke_4;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = v1;
  dispatch_async(v2, block);
}

uint64_t __fpm_performanceMonitorCreate_block_invoke_4(uint64_t a1)
{
  unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(v3 + 648) = UpTimeNanoseconds;
  uint64_t result = [*(id *)(v3 + 584) screenOn];
  *(unsigned char *)(*(void *)(a1 + 32) + 64CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = result;
  return result;
}

void fpm_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = *(NSObject **)DerivedStorage;
  if (*(void *)DerivedStorage)
  {
    dispatch_source_cancel(v2);
    uint64_t v2 = *(NSObject **)DerivedStorage;
  }
  dispatch_release(v2);
  uint64_t v3 = (void *)MEMORY[0x192FC5D30]();

  CFAllocatorRef v4 = *(const void **)(DerivedStorage + 664);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef v5 = *(const void **)(DerivedStorage + 64);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(DerivedStorage + 64) = 0;
  }
  uint64_t v6 = *(const void **)(DerivedStorage + 632);
  if (v6) {
    CFRelease(v6);
  }
  dispatch_source_t v7 = *(NSObject **)(DerivedStorage + 8);
  if (v7)
  {
    dispatch_release(v7);
    *(void *)(DerivedStorage + 8) = 0;
  }
  pid_t v8 = *(const void **)(DerivedStorage + 672);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(DerivedStorage + 672) = 0;
  }
}

CFStringRef fpm_copyDebugDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigPerformanceMonitor %p]", a1);
}

uint64_t fpm_setProperty(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v8 = 0;
  if (a1)
  {
    uint64_t v1 = *(NSObject **)(CMBaseObjectGetDerivedStorage(a1) + 8);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __fpm_setProperty_block_invoke;
    block[3] = &unk_1E5677820;
    void block[4] = &v5;
    dispatch_sync(v1, block);
    uint64_t v2 = *((unsigned int *)v6 + 6);
  }
  else
  {
    uint64_t v2 = FigSignalErrorAt(4294948225, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v6 + 6) = v2;
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18FD6820C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __fpm_setProperty_block_invoke(uint64_t a1)
{
  uint64_t result = FigSignalErrorAt(4294948224, 0, 0, 0, 0, 0, 0);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void fpm_timerCallback(id *a1)
{
  uint64_t v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    size_t v58 = v1;
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v1);
    *(void *)(DerivedStorage + 592) += 30;
    CFArrayRef v3 = *(const __CFArray **)(DerivedStorage + 64);
    if (!v3 || !CFArrayGetCount(v3)) {
      *(void *)(DerivedStorage + 600) += 30;
    }
    if (*(unsigned char *)(DerivedStorage + 640)) {
      *(void *)(DerivedStorage + 608) = (FigGetUpTimeNanoseconds() - *(void *)(DerivedStorage + 648)) / 0x3B9ACA00;
    }
    uint64_t v65 = 0;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 64));
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      uint64_t v6 = 0;
      CFIndex v7 = 0;
      do
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 64), v7);
        CFNumberRef Value = (id *)FigCFDictionaryGetValue(ValueAtIndex, @"weakRef");
        CFStringRef v10 = FigCFWeakReferenceHolderCopyReferencedObject(Value);
        FigCFDictionaryGetInt64IfPresent((uint64_t)ValueAtIndex, @"creationTime", &v65);
        if (v10)
        {
          uint64_t v11 = FigGetUpTimeNanoseconds() - v65;
          if (v11 > v6)
          {
            CFUUIDRef v12 = *(const void **)(DerivedStorage + 632);
            CFUUIDRef v13 = FigCFDictionaryGetValue(ValueAtIndex, @"name");
            *(void *)(DerivedStorage + 632) = v13;
            if (v13) {
              CFRetain(v13);
            }
            if (v12) {
              CFRelease(v12);
            }
            uint64_t v6 = v11;
          }
          ++v7;
          CFRelease(v10);
        }
        else
        {
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(DerivedStorage + 64), v7);
          --v5;
        }
      }
      while (v7 < v5);
      *(void *)(DerivedStorage + 624) = v6 / 0x3B9ACA00uLL;
    }
    if (proc_pid_rusage(*(_DWORD *)(DerivedStorage + 16), 6, (rusage_info_t *)(DerivedStorage + 72)) == 1
      || __ROR8__(0xFEDCBA987654321 * *(void *)(DerivedStorage + 592) + 0x91A2B3C4D5E6F0, 4) > 0x123456789ABCDEuLL)
    {
      goto LABEL_74;
    }
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFAllocatorRef allocator = v14;
    if (Mutable)
    {
      CFMutableDictionaryRef v16 = Mutable;
      CFStringRef v17 = CFStringCreateWithCString(v14, (const char *)(DerivedStorage + 20), 0x8000100u);
      FigCFDictionarySetValue(v16, @"PidName", v17);
      FigCFDictionarySetInt64(v16, @"IdleTime", *(void *)(DerivedStorage + 600));
      FigCFDictionarySetInt64(v16, @"UpTime", *(void *)(DerivedStorage + 592));
      FigCFDictionarySetInt64(v16, @"ScreenOnTime", *(void *)(DerivedStorage + 608));
      FigCFDictionarySetInt64(v16, @"RUFootprint", *(void *)(DerivedStorage + 144));
      FigCFDictionarySetInt64(v16, @"RUBilledEnergy", *(void *)(DerivedStorage + 336));
      FigCFDictionarySetInt64(v16, @"RUServicedEnergy", *(void *)(DerivedStorage + 344));
      FigCFDictionarySetInt64(v16, @"RUCycles", *(void *)(DerivedStorage + 328));
      FigCFDictionarySetInt64(v16, @"RUInstructions", *(void *)(DerivedStorage + 320));
      FigCFDictionarySetInt64(v16, @"RUMaxFootprint", *(void *)(DerivedStorage + 312));
      FigCFDictionarySetInt64(v16, @"RUWiredSize", *(void *)(DerivedStorage + 128));
      FigCFDictionarySetInt64(v16, @"RUBytesRead", *(void *)(DerivedStorage + 216));
      FigCFDictionarySetInt64(v16, @"RUBytesWrite", *(void *)(DerivedStorage + 224));
      FigCFDictionarySetInt64(v16, @"LongestTransactionTime", *(void *)(DerivedStorage + 624));
      unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      FigCFDictionarySetInt64(v16, @"TimeSinceScreenUpdate", (UpTimeNanoseconds - *(void *)(DerivedStorage + 648)) / 0x3B9ACA00);
      FigCFDictionarySetValue(v16, @"LongestTransactionName", *(const void **)(DerivedStorage + 632));
      FigCFDictionarySetInt(v16, @"IsScreenOn", *(unsigned __int8 *)(DerivedStorage + 640));
      FigCFDictionarySetValue(v16, @"PerfMonSID", *(const void **)(DerivedStorage + 664));
      CFArrayRef v19 = *(const __CFArray **)(DerivedStorage + 64);
      if (v19) {
        CFIndex v20 = CFArrayGetCount(v19);
      }
      else {
        CFIndex v20 = 0;
      }
      FigCFDictionarySetInt64(v16, @"TransactionCount", v20);
      FigCFDictionarySetInt64(v16, @"LastHourRUBytesWrite", *(void *)(DerivedStorage + 224) - *(void *)(DerivedStorage + 576));
      FigCFDictionarySetInt64(v16, @"LastHourRUBytesRead", *(void *)(DerivedStorage + 216) - *(void *)(DerivedStorage + 568));
      FigCFDictionarySetInt64(v16, @"LastHourRUBilledEnergy", *(void *)(DerivedStorage + 336) - *(void *)(DerivedStorage + 544));
      FigCFDictionarySetInt64(v16, @"LastHourRUServicedEnergy", *(void *)(DerivedStorage + 344) - *(void *)(DerivedStorage + 536));
      FigCFDictionarySetInt64(v16, @"LastHourRUCycles", *(void *)(DerivedStorage + 328) - *(void *)(DerivedStorage + 552));
      FigCFDictionarySetInt64(v16, @"LastHourRUInstructions", *(void *)(DerivedStorage + 320) - *(void *)(DerivedStorage + 560));
      CFDictionaryRef v21 = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v21)
      {
        CFDictionaryRef v22 = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v22)
        {
          CFStringRef cf = v17;
          for (CFIndex i = 0; ; ++i)
          {
            CFArrayRef v24 = *(const __CFArray **)(DerivedStorage + 64);
            if (v24) {
              CFArrayRef v24 = (const __CFArray *)CFArrayGetCount(v24);
            }
            if (i >= (uint64_t)v24) {
              break;
            }
            uint64_t v65 = 0;
            CFIndex v59 = 0;
            int64_t v60 = 0;
            uint64_t v25 = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 64), i);
            long long v26 = FigCFDictionaryGetValue(v25, @"name");
            if (CFDictionaryContainsKey(v21, v26))
            {
              FigCFDictionaryGetInt64IfPresent((uint64_t)v21, v26, &v59);
              uint64_t v27 = (uint64_t)++v59;
            }
            else
            {
              uint64_t v27 = 1;
            }
            FigCFDictionarySetInt64(v21, v26, v27);
            FigCFDictionaryGetInt64IfPresent((uint64_t)v25, @"creationTime", &v65);
            int64_t v28 = (FigGetUpTimeNanoseconds() - v65) / 0x3B9ACA00;
            if (CFDictionaryContainsKey(v22, v26))
            {
              FigCFDictionaryGetInt64IfPresent((uint64_t)v22, v26, &v60);
              if (v28 <= v60) {
                continue;
              }
            }
            FigCFDictionarySetInt64(v22, v26, v28);
          }
          FigCFDictionarySetValue(v16, @"TransactionNameDict", v21);
          FigCFDictionarySetValue(v16, @"TransactionTimeDict", v22);
          int v29 = 0;
          char v30 = (void (*)(uint64_t))v16;
          CFMutableDictionaryRef v16 = 0;
          CFStringRef v17 = cf;
        }
        else
        {
          int v29 = FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0);
          char v30 = 0;
        }
      }
      else
      {
        int v29 = FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0);
        char v30 = 0;
        CFDictionaryRef v22 = 0;
      }
      if (v17) {
        CFRelease(v17);
      }
      if (v16) {
        CFRelease(v16);
      }
      if (v21) {
        CFRelease(v21);
      }
      if (v22) {
        CFRelease(v22);
      }
      if (v29) {
        goto LABEL_72;
      }
    }
    else
    {
      char v30 = 0;
      if (FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0)) {
        goto LABEL_72;
      }
    }
    int8x16_t v31 = vextq_s8(*(int8x16_t *)(DerivedStorage + 320), *(int8x16_t *)(DerivedStorage + 320), 8uLL);
    *(int8x16_t *)(DerivedStorage + 536) = vextq_s8(*(int8x16_t *)(DerivedStorage + 336), *(int8x16_t *)(DerivedStorage + 336), 8uLL);
    *(int8x16_t *)(DerivedStorage + 552) = v31;
    *(_OWORD *)(DerivedStorage + 568) = *(_OWORD *)(DerivedStorage + 216);
    CFIndex v59 = 0;
    CFMutableDictionaryRef v32 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v32)
    {
      CFMutableDictionaryRef v33 = v32;
      int64_t v60 = 0;
      uint64_t v61 = (uint64_t)&v60;
      uint64_t v62 = 0x2020000000;
      long long v34 = (const void **)getkRTCReportingUserInfoClientNameSymbolLoc_ptr;
      long long v63 = (void *)getkRTCReportingUserInfoClientNameSymbolLoc_ptr;
      if (!getkRTCReportingUserInfoClientNameSymbolLoc_ptr)
      {
        uint64_t v65 = MEMORY[0x1E4F143A8];
        uint64_t v66 = 3221225472;
        uint64_t v67 = (uint64_t)__getkRTCReportingUserInfoClientNameSymbolLoc_block_invoke;
        uint64_t v68 = (void (*)(uint64_t, uint64_t))&unk_1E5677820;
        long long v69 = (void (*)(uint64_t))&v60;
        uint64_t v35 = (void *)RTCReportingLibrary();
        unint64_t v36 = dlsym(v35, "kRTCReportingUserInfoClientName");
        *(void *)(*((void *)v69 + 1) + 24) = v36;
        getkRTCReportingUserInfoClientNameSymbolLoc_ptr = *(void *)(*((void *)v69 + 1) + 24);
        long long v34 = *(const void ***)(v61 + 24);
      }
      _Block_object_dispose(&v60, 8);
      if (!v34) {
        fpm_timerCallback_cold_1();
      }
      FigCFDictionarySetValue(v33, *v34, @"CoreMediaPerf");
      CFMutableDictionaryRef v37 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v37)
      {
        CFMutableDictionaryRef v38 = v37;
        int64_t v60 = 0;
        uint64_t v61 = (uint64_t)&v60;
        uint64_t v62 = 0x2020000000;
        double v39 = (const void **)getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr;
        long long v63 = (void *)getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr;
        if (!getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr)
        {
          uint64_t v65 = MEMORY[0x1E4F143A8];
          uint64_t v66 = 3221225472;
          uint64_t v67 = (uint64_t)__getkRTCReportingSessionInfoClientTypeSymbolLoc_block_invoke;
          uint64_t v68 = (void (*)(uint64_t, uint64_t))&unk_1E5677820;
          long long v69 = (void (*)(uint64_t))&v60;
          CMTime v40 = (void *)RTCReportingLibrary();
          __int16 v41 = dlsym(v40, "kRTCReportingSessionInfoClientType");
          *(void *)(*((void *)v69 + 1) + 24) = v41;
          getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr = *(void *)(*((void *)v69 + 1) + 24);
          double v39 = *(const void ***)(v61 + 24);
        }
        _Block_object_dispose(&v60, 8);
        if (!v39) {
          fpm_timerCallback_cold_2();
        }
        FigCFDictionarySetInt(v38, *v39, 53);
        int64_t v60 = 0;
        uint64_t v61 = (uint64_t)&v60;
        uint64_t v62 = 0x2020000000;
        CMTimeValue v42 = (const void **)getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr;
        long long v63 = (void *)getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr;
        if (!getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr)
        {
          uint64_t v65 = MEMORY[0x1E4F143A8];
          uint64_t v66 = 3221225472;
          uint64_t v67 = (uint64_t)__getkRTCReportingSessionInfoSessionIDSymbolLoc_block_invoke;
          uint64_t v68 = (void (*)(uint64_t, uint64_t))&unk_1E5677820;
          long long v69 = (void (*)(uint64_t))&v60;
          CMTimeScale v43 = (void *)RTCReportingLibrary();
          uint64_t v44 = dlsym(v43, "kRTCReportingSessionInfoSessionID");
          *(void *)(*((void *)v69 + 1) + 24) = v44;
          getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr = *(void *)(*((void *)v69 + 1) + 24);
          CMTimeValue v42 = *(const void ***)(v61 + 24);
        }
        _Block_object_dispose(&v60, 8);
        if (!v42) {
          fpm_timerCallback_cold_3();
        }
        FigCFDictionarySetInt(v38, *v42, *(_DWORD *)(DerivedStorage + 56));
        int64_t v60 = 0;
        uint64_t v61 = (uint64_t)&v60;
        uint64_t v62 = 0x2020000000;
        CMTimeValue v45 = (const void **)getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr;
        long long v63 = (void *)getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr;
        if (!getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr)
        {
          uint64_t v65 = MEMORY[0x1E4F143A8];
          uint64_t v66 = 3221225472;
          uint64_t v67 = (uint64_t)__getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_block_invoke;
          uint64_t v68 = (void (*)(uint64_t, uint64_t))&unk_1E5677820;
          long long v69 = (void (*)(uint64_t))&v60;
          CMTimeScale v46 = (void *)RTCReportingLibrary();
          uint64_t v47 = dlsym(v46, "kRTCReportingSessionInfoContainsRealtimeEvents");
          *(void *)(*((void *)v69 + 1) + 24) = v47;
          getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr = *(void *)(*((void *)v69 + 1) + 24);
          CMTimeValue v45 = *(const void ***)(v61 + 24);
        }
        _Block_object_dispose(&v60, 8);
        if (!v45) {
          fpm_timerCallback_cold_4();
        }
        uint64_t v48 = FigCFDictionarySetInt(v38, *v45, 0);
        __int16 v49 = (void *)MEMORY[0x192FC5D30](v48);
        uint64_t v65 = 0;
        uint64_t v66 = (uint64_t)&v65;
        uint64_t v67 = 0x3052000000;
        uint64_t v68 = __Block_byref_object_copy__0;
        long long v69 = __Block_byref_object_dispose__0;
        uint64_t v50 = (void *)getRTCReportingClass_softClass;
        uint64_t v70 = getRTCReportingClass_softClass;
        if (!getRTCReportingClass_softClass)
        {
          int64_t v60 = MEMORY[0x1E4F143A8];
          uint64_t v61 = 3221225472;
          uint64_t v62 = (uint64_t)__getRTCReportingClass_block_invoke;
          long long v63 = &unk_1E5677820;
          uint64_t v64 = &v65;
          __getRTCReportingClass_block_invoke((uint64_t)&v60);
          uint64_t v50 = *(void **)(v66 + 40);
        }
        _Block_object_dispose(&v65, 8);
        char v51 = [v50 sendOneMessageWithSessionInfo:v38 userInfo:v33 category:901 type:0 payload:v30 error:&v59];
        int v52 = 0;
        if ((v51 & 1) == 0) {
          int v52 = [v59 code];
        }
        CFRelease(v33);
        CFMutableDictionaryRef v53 = v38;
      }
      else
      {
        int v52 = FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0);
        CFMutableDictionaryRef v53 = v33;
      }
      CFRelease(v53);
      if (v52) {
        goto LABEL_72;
      }
    }
    else if (FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0))
    {
      goto LABEL_72;
    }
    CFTypeID v54 = (void *)MEMORY[0x192FC5D30]();
    objc_msgSend(NSString, "stringWithFormat:", @"com.apple.%s.internal", DerivedStorage + 20);
    uint64_t v65 = MEMORY[0x1E4F143A8];
    uint64_t v66 = 3221225472;
    uint64_t v67 = (uint64_t)__fpm_reportingDataForInternalUsingCoreAnalytics_block_invoke;
    uint64_t v68 = (void (*)(uint64_t, uint64_t))&__block_descriptor_40_e19___NSDictionary_8__0l;
    long long v69 = v30;
    if (AnalyticsSendEventLazy())
    {
LABEL_71:
      *(void *)(DerivedStorage + 656) = FigGetUpTimeNanoseconds();
      goto LABEL_72;
    }
    int v55 = FigSignalErrorAt(4294948221, 0, 0, 0, 0, 0, 0);
    if (!v55) {
      goto LABEL_71;
    }
LABEL_72:
    if (v30) {
      CFRelease(v30);
    }
LABEL_74:
    CFRelease(v58);
  }
}

void sub_18FD68EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void fpm_timerCancellationCallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void *__getkRTCReportingUserInfoClientNameSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)RTCReportingLibrary();
  uint64_t result = dlsym(v2, "kRTCReportingUserInfoClientName");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkRTCReportingUserInfoClientNameSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t RTCReportingLibrary()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!RTCReportingLibraryCore_frameworkLibrary)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    v2[2] = (void *)3221225472;
    v2[3] = __RTCReportingLibraryCore_block_invoke;
    v2[4] = &__block_descriptor_40_e5_v8__0l;
    v2[5] = v2;
    long long v3 = xmmword_1E5677DB0;
    uint64_t v4 = 0;
    RTCReportingLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = RTCReportingLibraryCore_frameworkLibrary;
  if (!RTCReportingLibraryCore_frameworkLibrary) {
    RTCReportingLibrary_cold_1(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t __RTCReportingLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  RTCReportingLibraryCore_frameworkLibrary = result;
  return result;
}

void *__getkRTCReportingSessionInfoClientTypeSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)RTCReportingLibrary();
  uint64_t result = dlsym(v2, "kRTCReportingSessionInfoClientType");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getkRTCReportingSessionInfoSessionIDSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)RTCReportingLibrary();
  uint64_t result = dlsym(v2, "kRTCReportingSessionInfoSessionID");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)RTCReportingLibrary();
  uint64_t result = dlsym(v2, "kRTCReportingSessionInfoContainsRealtimeEvents");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                             + 24);
  return result;
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

Class __getRTCReportingClass_block_invoke(uint64_t a1)
{
  RTCReportingLibrary();
  Class result = objc_getClass("RTCReporting");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getRTCReportingClass_block_invoke_cold_1();
  }
  getRTCReportingClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t __fpm_reportingDataForInternalUsingCoreAnalytics_block_invoke(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t FigMetricEventTimelineStartServer()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __FigMetricEventTimelineStartServer_block_invoke;
  block[3] = &unk_1E5677DF0;
  void block[4] = &v3;
  if (FigMetricEventTimelineStartServer_sFigMetricEventTimelineServerSetupOnce != -1) {
    dispatch_once(&FigMetricEventTimelineStartServer_sFigMetricEventTimelineServerSetupOnce, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

void __FigMetricEventTimelineStartServer_block_invoke(uint64_t a1)
{
  v5[0] = 1;
  v5[1] = metserver_replyingMessageHandler;
  v5[2] = metserver_noReplyMessageHandler;
  memset(&v5[3], 0, 24);
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(AllocatorForPermanentAllocations, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFMutableDictionaryRef v4 = Mutable;
    FigCFDictionarySetInt32(Mutable, @"xpcServerOption_QueuePriority", 44);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigXPCServerStart((uint64_t)"com.apple.coremedia.mediaplaybackd.figmetriceventtimeline.xpc", v5, (uint64_t)v4, &gFigMetricEventTimelineServer);
    if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      FigXPCServerActivate(gFigMetricEventTimelineServer);
    }
    CFRelease(v4);
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t metserver_replyingMessageHandler(_xpc_connection_s *a1, void *a2, void *a3)
{
  int v58 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v58);
  if (OpCode) {
    return OpCode;
  }
  uint64_t v7 = 4294951138;
  if (v58 <= 1886741106)
  {
    if (v58 == 1668051817)
    {
      CFTypeRef v60 = 0;
      CFTypeRef v61 = 0;
      char int64 = xpc_dictionary_get_int64(a2, "ClassID");
      uint64_t v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v61, &v60);
      if (!v8)
      {
        CFTypeRef v28 = v60;
        CFTypeRef v27 = v61;
        uint64_t v29 = *(void *)(CMBaseObjectGetVTable((uint64_t)v61) + 16);
        if (v29) {
          uint64_t v30 = v29;
        }
        else {
          uint64_t v30 = 0;
        }
        CFTypeID v54 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void))(v30 + 24);
        if (v54)
        {
          uint64_t v8 = v54(v27, v28, int64);
          goto LABEL_54;
        }
        goto LABEL_55;
      }
LABEL_54:
      uint64_t v7 = v8;
      goto LABEL_63;
    }
    if (v58 != 1668441460)
    {
      if (v58 != 1684632432) {
        return v7;
      }
      uint64_t uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
      return FigXPCServerDisassociateObjectWithConnection(a1, uint64);
    }
    CFTypeRef v60 = 0;
    CFTypeRef v61 = 0;
    CFTypeRef cf = 0;
    int64_t v31 = xpc_dictionary_get_int64(a2, "MaxNoOfClasses");
    xpc_object_t array = xpc_dictionary_get_array(a2, "EventCountByClassXPCArray");
    if (array
      && (CFMutableDictionaryRef v33 = array,
          MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia(),
          (uint64_t v35 = (uint64_t *)malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, 8 * v31, 0x100004000313F17uLL)) != 0))
    {
      unint64_t v36 = v35;
      if (xpc_array_get_count(v33))
      {
        size_t v37 = 0;
        do
        {
          v36[v37] = xpc_array_get_int64(v33, v37);
          ++v37;
        }
        while (v37 < xpc_array_get_count(v33));
      }
      uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
      uint64_t v39 = FigMetricEventTimelineCreate(AllocatorForMedia, v31, v36, @"metricEventTimeline", 0, &v61);
      if (!v39)
      {
        uint64_t v40 = FigGetAllocatorForMedia();
        uint64_t v41 = metserver_createCompanion(v40, &cf);
        CFTypeRef v42 = cf;
        if (v41)
        {
          uint64_t v7 = v41;
        }
        else
        {
          uint64_t v7 = FigXPCServerAssociateObjectWithConnection(a1, v61, (uint64_t)cf, (uint64_t)FigCFRelease, 0, (unint64_t *)&v60);
          if (!v7)
          {
            xpc_object_t v43 = FigXPCRetain(a1);
            CMTimeValue v45 = cf;
            CFTypeRef v44 = v60;
            *((void *)cf + 2) = v43;
            v45[3] = v44;
            xpc_dictionary_set_uint64(a3, ".objectID", (uint64_t)v44);
            CFTypeRef cf = 0;
            goto LABEL_37;
          }
          CFTypeRef v42 = cf;
        }
        if (v42) {
          CFRelease(v42);
        }
LABEL_37:
        CFTypeRef v46 = v61;
        if (!v61) {
          return v7;
        }
        goto LABEL_66;
      }
    }
    else
    {
      uint64_t v39 = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v7 = v39;
    goto LABEL_37;
  }
  if (v58 > 1936029288)
  {
    if (v58 != 1936029289)
    {
      if (v58 != 1937006949) {
        return v7;
      }
      CFTypeRef v60 = 0;
      CFTypeRef v61 = 0;
      uint64_t v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v61, &v60);
      if (v8) {
        goto LABEL_54;
      }
      CFTypeRef v17 = v60;
      CFTypeRef v16 = v61;
      uint64_t v18 = *(void *)(CMBaseObjectGetVTable((uint64_t)v61) + 16);
      if (v18) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = 0;
      }
      CFMutableDictionaryRef v53 = *(uint64_t (**)(CFTypeRef, CFTypeRef))(v19 + 32);
      if (v53)
      {
        uint64_t v8 = v53(v16, v17);
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    CFTypeRef v60 = 0;
    CFTypeRef v61 = 0;
    int64_t v47 = xpc_dictionary_get_int64(a2, "EventID");
    uint64_t v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v61, &v60);
    if (!v8)
    {
      CFTypeRef v49 = v60;
      CFTypeRef v48 = v61;
      uint64_t v50 = *(void *)(CMBaseObjectGetVTable((uint64_t)v61) + 16);
      if (v50) {
        uint64_t v51 = v50;
      }
      else {
        uint64_t v51 = 0;
      }
      int v55 = *(uint64_t (**)(CFTypeRef, CFTypeRef, int64_t))(v51 + 16);
      if (v55)
      {
        uint64_t v8 = v55(v48, v49, v47);
        goto LABEL_54;
      }
LABEL_55:
      uint64_t v7 = 4294954514;
      goto LABEL_63;
    }
    goto LABEL_54;
  }
  if (v58 != 1886741107)
  {
    if (v58 != 1919248243) {
      return v7;
    }
    CFTypeRef v60 = 0;
    CFTypeRef v61 = 0;
    uint64_t v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v61, &v60);
    if (v8) {
      goto LABEL_54;
    }
    dispatch_time_t v9 = v60;
    if (!*((void *)v60 + 2))
    {
      xpc_object_t v10 = FigXPCRetain(a1);
      dispatch_time_t v9 = v60;
      *((void *)v60 + 2) = v10;
    }
    CFTypeRef v11 = v61;
    uint64_t v12 = v9[4];
    uint64_t v13 = *(void *)(CMBaseObjectGetVTable((uint64_t)v61) + 16);
    if (v13) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    int v52 = *(uint64_t (**)(CFTypeRef, void *, void *, uint64_t))(v14 + 8);
    if (v52)
    {
      uint64_t v8 = v52(v11, v9, &metserver_registerSubscriber_subscriberCallbacks, v12);
      goto LABEL_54;
    }
    goto LABEL_55;
  }
  CFTypeRef v60 = 0;
  CFTypeRef v61 = 0;
  CFTypeRef cf = 0;
  uint64_t v20 = metserver_copyEventTimelineAndCompanion(a1, a2, &v61, &v60);
  if (v20) {
    goto LABEL_59;
  }
  uint64_t v20 = FigMetricEventTimelineClientServerXPC_DeserializeAndCopyEvent(a2, &cf);
  if (v20) {
    goto LABEL_59;
  }
  CFTypeRef v22 = v60;
  CFTypeRef v21 = v61;
  CFTypeRef v23 = cf;
  uint64_t v24 = *(void *)(CMBaseObjectGetVTable((uint64_t)v61) + 16);
  if (v24) {
    uint64_t v25 = v24;
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v56 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef))(v25 + 40);
  if (v56)
  {
    uint64_t v20 = v56(v21, v22, v23);
LABEL_59:
    uint64_t v7 = v20;
    goto LABEL_61;
  }
  uint64_t v7 = 4294954514;
LABEL_61:
  if (cf) {
    CFRelease(cf);
  }
LABEL_63:
  if (v61) {
    CFRelease(v61);
  }
  CFTypeRef v46 = v60;
  if (v60) {
LABEL_66:
  }
    CFRelease(v46);
  return v7;
}

uint64_t metserver_noReplyMessageHandler(_xpc_connection_s *a1, void *a2)
{
  return metserver_replyingMessageHandler(a1, a2, 0);
}

void FigCFRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigMetricEventTimelineGetIDByAssociatingWithClientConnection(const void *a1, _xpc_connection_s *a2, void *a3)
{
  CFTypeRef cf = 0;
  if (a1 && a2 && a3)
  {
    uint64_t AllocatorForMedia = FigGetAllocatorForMedia();
    uint64_t v7 = metserver_createCompanion(AllocatorForMedia, &cf);
    CFTypeRef v8 = cf;
    if (v7)
    {
      uint64_t v9 = v7;
    }
    else
    {
      uint64_t v9 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gFigMetricEventTimelineServer, a2, a1, (uint64_t)cf, (uint64_t)FigCFRelease, 0, a3);
      CFTypeRef v8 = cf;
      if (!v9)
      {
        *((void *)cf + 3) = *a3;
        return v9;
      }
    }
    if (v8) {
      CFRelease(v8);
    }
    return v9;
  }

  return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
}

uint64_t metserver_createCompanion(uint64_t a1, void *a2)
{
  if (a2)
  {
    long long v9 = xmmword_1E5677E10;
    if (metricEventTimelineServerCompanion_getTypeID_once != -1) {
      dispatch_once_f(&metricEventTimelineServerCompanion_getTypeID_once, &v9, (dispatch_function_t)metserver_registerClass);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (!Instance) {
      return FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v5 = (void *)Instance;
    dispatch_queue_t v6 = dispatch_queue_create("com.apple.coremedia.figmetriceventtimelineserver.callback", 0);
    v5[4] = v6;
    if (v6)
    {
      uint64_t v7 = 0;
      *a2 = v5;
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
      CFRelease(v5);
    }
    return v7;
  }
  else
  {
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  }
}

void metserver_didReceiveEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t message = 0;
  if (!a1) {
    goto LABEL_8;
  }
  xpc_object_t v6 = *(xpc_object_t *)(a1 + 24);
  if (!v6) {
    goto LABEL_7;
  }
  if (!*(void *)(a1 + 16))
  {
LABEL_8:
    xpc_object_t v6 = 0;
    goto LABEL_7;
  }
  int v8 = FigXPCCreateBasicMessage(0x65766E74u, (uint64_t)v6, &message);
  xpc_object_t v6 = message;
  if (!v8)
  {
    int v9 = FigMetricEventTimelineClientServerXPC_SerializeEvent(message, a2, a4);
    xpc_object_t v6 = message;
    if (!v9)
    {
      xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), message);
      xpc_object_t v6 = message;
    }
  }
LABEL_7:
  FigXPCRelease(v6);
}

uint64_t metserver_copyEventTimelineAndCompanion(_xpc_connection_s *a1, xpc_object_t xdict, CFTypeRef *a3, void *a4)
{
  CFTypeRef cf = 0;
  CFTypeRef v13 = 0;
  uint64_t uint64 = xpc_dictionary_get_uint64(xdict, ".objectID");
  if (!uint64)
  {
    uint64_t v8 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  uint64_t v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v13, &cf);
  if (v8)
  {
LABEL_14:
    uint64_t v10 = v8;
    goto LABEL_10;
  }
  if (a3)
  {
    *a3 = v13;
    CFTypeRef v13 = 0;
  }
  if (a4)
  {
    CFTypeRef v9 = cf;
    if (cf) {
      CFTypeRef v9 = CFRetain(cf);
    }
    uint64_t v10 = 0;
    *a4 = v9;
  }
  else
  {
    uint64_t v10 = 0;
  }
LABEL_10:
  if (v13) {
    CFRelease(v13);
  }
  return v10;
}

void metricEventTimelineServerCompanion_finalize(uint64_t a1)
{
  FigXPCRelease(*(xpc_object_t *)(a1 + 16));
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_release(v2);
  }
}

uint64_t metserver_registerClass(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 8) = result;
  return result;
}

uint64_t FigCaptionFontFamilyNameListGetTypeID()
{
  return sFigCaptionFontFamilyNameListID;
}

uint64_t fontFamilyList_registerFigCaptionFontFamilyNameListIDType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionFontFamilyNameListID = result;
  return result;
}

uint64_t FigCaptionFontFamilyNameListCreateMutable(const __CFAllocator *a1, uint64_t *a2)
{
  if (a2)
  {
    FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v5 = Instance;
      *(void *)(Instance + 16) = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
      *a2 = v5;
      return 0;
    }
    uint64_t v7 = 4294954510;
  }
  else
  {
    uint64_t v7 = 4294954516;
  }

  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionFontFamilyNameListCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, void *a3)
{
  if (a3)
  {
    FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v7 = (void *)Instance;
      CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(a1, 0, *(CFArrayRef *)(a2 + 16));
      v7[2] = MutableCopy;
      if (MutableCopy)
      {
        *a3 = v7;
        return 0;
      }
      else
      {
        uint64_t v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        CFRelease(v7);
        return v11;
      }
    }
    uint64_t v10 = 4294954510;
  }
  else
  {
    uint64_t v10 = 4294954516;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

CFIndex FigCaptionFontFamilyNameListGetCount(uint64_t a1)
{
  if (a1 && (CFArrayRef v1 = *(const __CFArray **)(a1 + 16)) != 0) {
    return CFArrayGetCount(v1);
  }
  else {
    return 0;
  }
}

uint64_t FigCaptionFontFamilyNameListAppend(uint64_t a1, unsigned int a2, const void *a3)
{
  if (a1 && a2 < 2 && a3)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    FigCFDictionarySetInt32(Mutable, @"kind", a2);
    CFDictionaryAddValue(Mutable, @"familyname", a3);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionFontFamilyNameListCopyFamilyKindAndNameAtIndex(uint64_t a1, CFIndex idx, void *a3, void *a4)
{
  if (!a1) {
    goto LABEL_13;
  }
  CFArrayRef Count = *(const __CFArray **)(a1 + 16);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  if ((uint64_t)Count <= idx || idx < 0)
  {
LABEL_13:
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), idx);
    CFDictionaryRef v10 = ValueAtIndex;
    if (a3) {
      FigCFDictionaryGetInt32IfPresent((uint64_t)ValueAtIndex, @"kind", a3);
    }
    if (a4)
    {
      CFNumberRef Value = CFDictionaryGetValue(v10, @"familyname");
      if (Value) {
        CFNumberRef Value = CFRetain(Value);
      }
      *a4 = Value;
    }
    return 0;
  }
}

uint64_t fontFamilyList_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void fontFamilyList_Finalize(uint64_t a1)
{
  CFArrayRef v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t fontFamilyList_Equal(void *a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
  if (!a2) {
    return 0;
  }
  if (v4 != sFigCaptionFontFamilyNameListID) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
  if (v5 != sFigCaptionFontFamilyNameListID) {
    return 0;
  }
  xpc_object_t v6 = (const void *)a1[2];
  uint64_t v7 = (const void *)a2[2];

  return CFEqual(v6, v7);
}

CFHashCode fontFamilyList_Hash(void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
  if (v2 != sFigCaptionFontFamilyNameListID) {
    return 0;
  }
  uint64_t v3 = (const void *)a1[2];

  return CFHash(v3);
}

__CFString *fontFamilyList_CopyDebugDesc(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  CFTypeID v4 = Mutable;
  if (a1) {
    CFStringAppendFormat(Mutable, 0, @"<FigCaptionFontFamilyNameList %p> familyNames:%@", a1, a1[2]);
  }
  else {
    CFStringAppendFormat(Mutable, 0, @"<FigCaptionFontFamilyNameList %p>", 0);
  }
  return v4;
}

uint64_t FigCPECryptorRemoteRetainCopiedCryptor(uint64_t a1, const void *a2, void *a3)
{
  CFTypeRef v12 = 0;
  if (a2 && a3)
  {
    uint64_t v14 = 0;
    pid_t v15 = &v14;
    uint64_t v16 = 0x2000000000;
    int v17 = 0;
    cf[0] = (CFTypeRef)MEMORY[0x1E4F143A8];
    cf[1] = (CFTypeRef)0x40000000;
    cf[2] = __cryptorRemote_EnsureClientEstablished_block_invoke;
    cf[3] = &unk_1E5677E98;
    cf[4] = &v14;
    if (cryptorRemote_EnsureClientEstablished_sFigCPECryptorRemoteClientSetupOnce != -1) {
      dispatch_once(&cryptorRemote_EnsureClientEstablished_sFigCPECryptorRemoteClientSetupOnce, cf);
    }
    FigXPCRemoteClientKillServerOnTimeout(gFigCPECryptorRemoteClient, *((unsigned int *)v15 + 6), "cryptorRemote_EnsureClientEstablished", 0);
    uint64_t v6 = *((unsigned int *)v15 + 6);
    _Block_object_dispose(&v14, 8);
    if (v6) {
      return v6;
    }
    uint64_t v6 = FigXPCRemoteClientRetainCopiedObject(gFigCPECryptorRemoteClient, (uint64_t)a2, &v12);
    CFTypeRef v7 = v12;
    if (v6) {
      goto LABEL_17;
    }
    if (v12)
    {
LABEL_15:
      uint64_t v6 = 0;
      *a3 = v7;
      return v6;
    }
    cf[0] = 0;
    ClassID = (void *)FigCPECryptorGetClassID();
    uint64_t v9 = CMDerivedObjectCreate(a1, (uint64_t)&kFigCPECryptorRemote_VTable, ClassID, cf);
    if (!v9)
    {
      if (cf[0])
      {
        uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf[0]);
        *(void *)(DerivedStorage + 8) = a2;
        *(_WORD *)uint64_t DerivedStorage = 0;
        *(unsigned char *)(DerivedStorage + 16) = 0;
        *(void *)(DerivedStorage + 24) = 0;
        *(_DWORD *)(DerivedStorage + 32) = 0;
        *(void *)(DerivedStorage + 48) = FigSimpleMutexCreate();
        uint64_t v6 = FigXPCRemoteClientAssociateObject(gFigCPECryptorRemoteClient, (uint64_t)cf[0], a2);
        if (!v6) {
          CFTypeRef v12 = CFRetain(cf[0]);
        }
LABEL_12:
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        CFTypeRef v7 = v12;
        if (!v6) {
          goto LABEL_15;
        }
LABEL_17:
        if (v7) {
          CFRelease(v7);
        }
        return v6;
      }
      uint64_t v9 = FigSignalErrorAt(4294949725, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v6 = v9;
    goto LABEL_12;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCPECryptorRemoteGetID(uint64_t a1, void *a2)
{
  uint64_t v4 = 0;
  if (a1 && a2)
  {
    uint64_t result = cryptorRemote_GetObjectID(a1, &v4);
    if (!result) {
      *a2 = v4;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t cryptorRemote_GetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a2)
  {
    if (*(unsigned char *)DerivedStorage)
    {
      uint64_t v5 = 4294949723;
    }
    else
    {
      if (!*(unsigned char *)(DerivedStorage + 1))
      {
        *a2 = *(void *)(DerivedStorage + 8);
        return 0;
      }
      uint64_t v5 = 4294949722;
    }
  }
  else
  {
    uint64_t v5 = 4294949726;
  }

  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t cryptorRemote_getExternalProtectionMethods(uint64_t a1, _DWORD *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a1)
  {
    if (a2)
    {
      uint64_t v5 = DerivedStorage;
      uint64_t result = cryptorRemote_ensureStateUpdatedFromServer(a1);
      *a2 = *(_DWORD *)(v5 + 32);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t cryptorRemote_ensureStateUpdatedFromServer(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xpc_object_t xdict = 0;
  uint64_t v9 = 0;
  if (*(unsigned char *)DerivedStorage)
  {
    uint64_t v7 = 4294949723;
LABEL_12:
    uint64_t v3 = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    uint64_t v5 = 0;
    goto LABEL_9;
  }
  uint64_t v2 = DerivedStorage;
  if (*(unsigned char *)(DerivedStorage + 1))
  {
    uint64_t v7 = 4294949722;
    goto LABEL_12;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 48));
  if (*(unsigned char *)(v2 + 16))
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v4 = FigXPCCreateBasicMessage(0x6E736D74u, *(void *)(v2 + 8), &v9);
    if (v4)
    {
      uint64_t v3 = v4;
    }
    else
    {
      uint64_t v3 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, (uint64_t)v9, &xdict);
      if (!v3)
      {
        *(void *)(v2 + 24) = xpc_dictionary_get_uint64(xdict, "NativeSession");
        *(_DWORD *)(v2 + 32) = xpc_dictionary_get_uint64(xdict, "ExternalProtectionMethods");
        *(_DWORD *)(v2 + 36) = xpc_dictionary_get_uint64(xdict, "CryptorType");
        *(unsigned char *)(v2 + 16) = 1;
      }
    }
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 48));
  uint64_t v5 = v9;
LABEL_9:
  FigXPCRelease(v5);
  FigXPCRelease(xdict);
  return v3;
}

uint64_t cryptorRemote_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage(a1);
  *(unsigned char *)(result + 1) = 1;
  return result;
}

uint64_t cryptorRemote_Invalidate(uint64_t a1)
{
  xpc_object_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v7);
  if (ObjectID || (uint64_t ObjectID = FigXPCCreateBasicMessage(0x69637279u, v7, &v6), ObjectID))
  {
    uint64_t v4 = ObjectID;
  }
  else
  {
    uint64_t v4 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, (uint64_t)v6);
    if (!v4) {
      *uint64_t DerivedStorage = 1;
    }
  }
  FigXPCRelease(v6);
  return v4;
}

uint64_t cryptorRemote_Finalize(uint64_t a1)
{
  xpc_object_t v6 = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigXPCRemoteClientDisassociateObject(gFigCPECryptorRemoteClient, *(const void **)(DerivedStorage + 8));
  if (!*(unsigned char *)(DerivedStorage + 1)
    && ((uint64_t v2 = FigXPCCreateBasicMessage(0x64697370u, *(void *)(DerivedStorage + 8), &v6), v2)
     || (uint64_t v2 = FigXPCRemoteClientSendAsyncMessage(gFigCPECryptorRemoteClient, v6), v2)))
  {
    uint64_t v4 = v2;
  }
  else
  {
    FigSimpleMutexDestroy(*(void *)(DerivedStorage + 48));
    uint64_t v3 = *(const void **)(DerivedStorage + 40);
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = 0;
  }
  FigXPCRelease(v6);
  return FigXPCRemoteClientKillServerOnTimeout(gFigCPECryptorRemoteClient, v4, "cryptorRemote_Finalize", 0);
}

__CFString *cryptorRemote_CopyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = (unsigned char *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0);
  CFIndex v5 = CFGetRetainCount(a1);
  if (*DerivedStorage) {
    xpc_object_t v6 = " (invalidated)";
  }
  else {
    xpc_object_t v6 = "";
  }
  CFAllocatorRef v7 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigCPECryptor_Remote %p retainCount: %ld%s allocator: %p, ", a1, v5, v6, v7);
  CFStringAppendFormat(Mutable, 0, @">");
  return Mutable;
}

uint64_t cryptorRemote_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v14 = 0;
  if (a4)
  {
    uint64_t v8 = DerivedStorage;
    uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v14);
    if (!ObjectID)
    {
      if (CFEqual(a2, @"UUIDString"))
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(v8 + 48));
        CFDictionaryRef v10 = (CFTypeRef *)(v8 + 40);
        if (*(void *)(v8 + 40))
        {
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 48));
LABEL_9:
          CFTypeRef v12 = *v10;
          if (*v10) {
            CFTypeRef v12 = CFRetain(v12);
          }
          uint64_t v11 = 0;
          *a4 = v12;
          return v11;
        }
        uint64_t v11 = FigXPCSendStdCopyPropertyMessage(gFigCPECryptorRemoteClient, v14, @"UUIDString", (CFTypeRef *)(v8 + 40));
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 48));
        if (!v11) {
          goto LABEL_9;
        }
        return v11;
      }
      return FigXPCSendStdCopyPropertyMessage(gFigCPECryptorRemoteClient, v14, a2, a4);
    }
    return ObjectID;
  }

  return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t cryptorRemote_SetProperty(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v12 = 0;
  if (a2 && a3)
  {
    uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v12);
    if (!ObjectID)
    {
      if (CFEqual(a2, @"KeyRequestError"))
      {
        CFTypeID v6 = CFGetTypeID(a3);
        if (v6 == CFErrorGetTypeID())
        {
          *(void *)CFTypeRef v13 = 0;
          uint64_t v7 = FigXPCCreateBasicMessage(0x736B7272u, v12, v13);
          if (v7) {
            goto LABEL_19;
          }
          uint64_t v7 = FigXPCMessageSetCFError(*(void **)v13, "KeyRequestError", (__CFError *)a3);
          if (v7) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }
        return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
      }
      if (CFEqual(a2, @"CPEBAESCP_VideoFormatDescription"))
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CMFormatDescriptionGetTypeID())
        {
          *(void *)CFTypeRef v13 = 0;
          uint64_t v7 = FigXPCCreateBasicMessage(0x73666D74u, v12, v13);
          if (v7) {
            goto LABEL_19;
          }
          uint64_t v7 = FigXPCMessageSetFormatDescription(*(void **)v13, "FormatDescription", (uint64_t)a3);
          if (v7) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }
        return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
      }
      if (CFEqual(a2, @"CPEAESCP_SUBAUXDATA"))
      {
        CFTypeID v9 = CFGetTypeID(a3);
        if (v9 == CFDataGetTypeID())
        {
          *(void *)CFTypeRef v13 = 0;
          uint64_t v7 = FigXPCCreateBasicMessage(0x73736164u, v12, v13);
          if (v7) {
            goto LABEL_19;
          }
          uint64_t v7 = FigXPCMessageSetCFData(*(void **)v13, "SubsampleAuxiliaryData", a3);
          if (v7) {
            goto LABEL_19;
          }
LABEL_18:
          uint64_t v7 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, *(uint64_t *)v13);
LABEL_19:
          uint64_t v10 = v7;
          FigXPCRelease(*(xpc_object_t *)v13);
          return v10;
        }
        return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
      }
      return FigXPCSendStdSetPropertyMessage(gFigCPECryptorRemoteClient, v12, a2, a3);
    }
    return ObjectID;
  }

  return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t cryptorRemote_getNativeSession(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a1)
  {
    if (a2)
    {
      uint64_t v5 = DerivedStorage;
      uint64_t result = cryptorRemote_ensureStateUpdatedFromServer(a1);
      if (!result) {
        *a2 = *(void *)(v5 + 24);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t cryptorRemote_CreateKeyRequest(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  *(void *)uint64_t v10 = 0;
  uint64_t v11 = 0;
  xpc_object_t v9 = 0;
  uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v11);
  if (!ObjectID)
  {
    uint64_t ObjectID = FigXPCCreateBasicMessage(0x636B6579u, v11, v10);
    if (!ObjectID)
    {
      uint64_t ObjectID = FigXPCMessageSetCFDictionary(*(void **)v10, "KeyRequestData", a2);
      if (!ObjectID)
      {
        uint64_t ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, *(uint64_t *)v10, &v9);
        if (!ObjectID) {
          uint64_t ObjectID = FigXPCMessageCopyCFData(v9, "SPCBytes", a4);
        }
      }
    }
  }
  uint64_t v7 = ObjectID;
  FigXPCRelease(*(xpc_object_t *)v10);
  FigXPCRelease(v9);
  return v7;
}

uint64_t cryptorRemote_SetKeyRequestResponse(uint64_t a1, const void *a2, const void *a3)
{
  *(void *)uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v11);
  if (ObjectID)
  {
    uint64_t v8 = ObjectID;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = FigXPCCreateBasicMessage(0x736B6579u, v11, v10);
    uint64_t v7 = *(void **)v10;
    if (v6
      || (uint64_t v6 = FigXPCMessageSetCFData(*(void **)v10, "KeyRequestResponse", a2), v7 = *(void **)v10, v6)
      || (uint64_t v6 = FigXPCMessageSetCFDictionary(*(void **)v10, "KeyResponseOptionsDictionary", a3),
          uint64_t v7 = *(void **)v10,
          v6))
    {
      uint64_t v8 = v6;
    }
    else
    {
      uint64_t v8 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, *(uint64_t *)v10);
      uint64_t v7 = *(void **)v10;
    }
  }
  FigXPCRelease(v7);
  return v8;
}

uint64_t cryptorRemote_GetSerializationToken(uint64_t a1, void *a2)
{
  uint64_t v4 = 0;
  if (a2)
  {
    uint64_t result = cryptorRemote_GetObjectID(a1, &v4);
    if (!result) {
      *a2 = v4;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t cryptorRemote_CopyPropertyForFormat(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, __CFDictionary **a5)
{
  *(void *)uint64_t v12 = 0;
  uint64_t v13 = 0;
  xpc_object_t v11 = 0;
  if (a5)
  {
    uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v13);
    if (!ObjectID)
    {
      uint64_t ObjectID = FigXPCCreateBasicMessage(0x63706666u, v13, v12);
      if (!ObjectID)
      {
        uint64_t ObjectID = FigXPCMessageSetCFString(*(void **)v12, ".PropertyName", a2);
        if (!ObjectID)
        {
          FigXPCMessageSetUInt32(*(void **)v12, "Format", a3);
          uint64_t ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, *(uint64_t *)v12, &v11);
          if (!ObjectID) {
            uint64_t ObjectID = FigXPCMessageCopyCFObject(v11, ".Value", a5);
          }
        }
      }
    }
  }
  else
  {
    uint64_t ObjectID = FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v9 = ObjectID;
  FigXPCRelease(*(xpc_object_t *)v12);
  FigXPCRelease(v11);
  return v9;
}

uint64_t cryptorRemote_TestAndSetKeyRequestState(uint64_t a1, unsigned int a2, unsigned int a3, BOOL *a4, uint64_t *a5)
{
  xpc_object_t xdict = 0;
  uint64_t v14 = 0;
  xpc_object_t v12 = 0;
  uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v14);
  if (ObjectID
    || (uint64_t ObjectID = FigXPCCreateBasicMessage(0x74617373u, v14, &xdict), ObjectID)
    || (xpc_dictionary_set_int64(xdict, "ExpectedState", a2),
        xpc_dictionary_set_int64(xdict, "NewState", a3),
        uint64_t ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, (uint64_t)xdict, &v12),
        ObjectID))
  {
    uint64_t v10 = ObjectID;
  }
  else
  {
    if (a4) {
      *a4 = xpc_dictionary_get_BOOL(v12, "WasSetOutFlag");
    }
    uint64_t v10 = 0;
    if (a5) {
      *a5 = xpc_dictionary_get_uint64(v12, "KeyRequestIDOut");
    }
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v12);
  return v10;
}

uint64_t cryptorRemote_AbsorbKeyRequestContext(uint64_t a1, uint64_t a2)
{
  uint64_t value = 0;
  uint64_t v9 = 0;
  xpc_object_t xdict = 0;
  uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v9);
  if (ObjectID || (uint64_t ObjectID = cryptorRemote_GetObjectID(a2, &value), ObjectID))
  {
    uint64_t v4 = ObjectID;
    xpc_object_t v5 = 0;
  }
  else
  {
    uint64_t v4 = FigXPCCreateBasicMessage(0x616B7263u, v9, &xdict);
    xpc_object_t v5 = xdict;
    if (!v4)
    {
      xpc_dictionary_set_uint64(xdict, "FromCryptorID", value);
      uint64_t v4 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, (uint64_t)xdict);
      xpc_object_t v5 = xdict;
    }
  }
  FigXPCRelease(v5);
  return v4;
}

uint64_t cryptorRemote_setKeyResponseForAirPlay(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  xpc_object_t xdict = 0;
  uint64_t v13 = 0;
  uint64_t ObjectID = cryptorRemote_GetObjectID(a1, &v13);
  if (ObjectID)
  {
    uint64_t v10 = ObjectID;
    xpc_object_t v9 = 0;
  }
  else
  {
    uint64_t v8 = FigXPCCreateBasicMessage(0x736B6170u, v13, &xdict);
    xpc_object_t v9 = xdict;
    if (v8
      || (xpc_dictionary_set_uint64(xdict, "SessionID", a2),
          uint64_t v8 = FigXPCMessageSetCFData(xdict, "KeyRequestResponse", a3),
          xpc_object_t v9 = xdict,
          v8)
      || (uint64_t v8 = FigXPCMessageSetCFDictionary(xdict, "KeyResponseOptionsDictionary", a4), v9 = xdict, v8))
    {
      uint64_t v10 = v8;
    }
    else
    {
      uint64_t v10 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, (uint64_t)xdict);
      xpc_object_t v9 = xdict;
    }
  }
  FigXPCRelease(v9);
  FigXPCRelease(0);
  return v10;
}

uint64_t cryptorRemote_copySerializedCryptorRecipe(uint64_t a1, CFDataRef *a2)
{
  v11[3] = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a1)
  {
    if (a2)
    {
      uint64_t v5 = DerivedStorage;
      uint64_t result = cryptorRemote_ensureStateUpdatedFromServer(a1);
      if (!result)
      {
        uint64_t v7 = *(unsigned int *)(v5 + 32);
        uint64_t v8 = *(int *)(v5 + 36);
        v11[0] = *(void *)(v5 + 24);
        v11[1] = v7;
        _OWORD v11[2] = v8;
        CFDataRef v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v11, 24);
        if (v9)
        {
          CFDataRef v10 = v9;
          uint64_t result = 0;
          *a2 = v10;
        }
        else
        {
          return 4294949725;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigMetricEventClassInstallEventDeserializeHandler(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFNumberRef SInt64 = FigCFNumberCreateSInt64(AllocatorForMedia, a1);
  if (!a2)
  {
    uint64_t v6 = FigSignalErrorAt(4294947836, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  if (ensureGlobalDeserializeRegister_ensureGlobalDeserializeRegisterOnce != -1) {
    dispatch_once(&ensureGlobalDeserializeRegister_ensureGlobalDeserializeRegisterOnce, &__block_literal_global_10);
  }
  uint64_t v6 = ensureGlobalDeserializeRegister_err;
  if (!ensureGlobalDeserializeRegister_err)
  {
    FigGetAllocatorForMedia();
    long long v10 = xmmword_1E5677F38;
    if (meEventDeserializationCallbackData_getTypeID_once != -1) {
      dispatch_once_f(&meEventDeserializationCallbackData_getTypeID_once, &v10, (dispatch_function_t)metutil_registerClass);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v8 = (const void *)Instance;
    if (Instance)
    {
      *(void *)(Instance + 16) = a2;
    }
    else
    {
      uint64_t v6 = FigSignalErrorAt(4294947835, 0, 0, 0, 0, 0, 0);
      if (v6) {
        goto LABEL_12;
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    FigCFDictionarySetValue((void *)gFigMetricEventDeserializeRegistry, SInt64, v8);
    os_unfair_lock_unlock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v6 = 0;
  }
LABEL_12:
  if (SInt64) {
    CFRelease(SInt64);
  }
  return v6;
}

uint64_t FigMetricEventDeserializeEvent(void *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  int64_t int64 = xpc_dictionary_get_int64(a1, "EventID");
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  CFNumberRef SInt64 = FigCFNumberCreateSInt64(AllocatorForMedia, int64);
  if (gFigMetricEventDeserializeRegistry)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    CFNumberRef Value = FigCFDictionaryGetValue((const void *)gFigMetricEventDeserializeRegistry, SInt64);
    os_unfair_lock_unlock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    if (Value)
    {
      uint64_t v8 = (uint64_t (*)(void *, CFTypeRef *))Value[2];
      if (v8)
      {
        uint64_t v9 = v8(a1, &cf);
        if (!v9)
        {
          *a2 = cf;
          CFTypeRef cf = 0;
        }
        if (SInt64) {
          goto LABEL_7;
        }
        goto LABEL_8;
      }
    }
    uint64_t v11 = 4294947834;
  }
  else
  {
    uint64_t v11 = 4294947833;
  }
  uint64_t v9 = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  if (SInt64) {
LABEL_7:
  }
    CFRelease(SInt64);
LABEL_8:
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t FigMetricEventGetClassID()
{
  if (sRegisterFigMetricEventClassIDOnce != -1) {
    dispatch_once_f(&sRegisterFigMetricEventClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventType);
  }
  return sFigMetricEventClassID;
}

uint64_t RegisterFigMetricEventType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigMetricEventClassDesc, ClassID, 1, &sFigMetricEventClassID);
}

uint64_t FigMetricEventGetTypeID()
{
  if (sRegisterFigMetricEventClassIDOnce != -1) {
    dispatch_once_f(&sRegisterFigMetricEventClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventType);
  }
  uint64_t v0 = (void *)sFigMetricEventClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigMetricMockEventForTestCreate(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a3)
  {
    if (sRegisterFigMetricEventClassIDOnce != -1) {
      dispatch_once_f(&sRegisterFigMetricEventClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventType);
    }
    uint64_t v6 = CMDerivedObjectCreate(a1, (uint64_t)&kFigMetricEventClass_VTable, (void *)sFigMetricEventClassID, &cf);
    if (v6)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *(void *)CMBaseObjectGetDerivedStorage((uint64_t)cf) = a2;
      *a3 = cf;
    }
    return v6;
  }
  else
  {
    return FigSignalErrorAt(4294947836, 0, 0, 0, 0, 0, 0);
  }
}

void __ensureGlobalDeserializeRegister_block_invoke()
{
  gFigMetricEventDeserializeRegistryLock = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  gFigMetricEventDeserializeRegistry = (uint64_t)CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (gFigMetricEventDeserializeRegistry)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
  }
  else
  {
    ensureGlobalDeserializeRegister_err = FigSignalErrorAt(4294947835, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t metutil_registerClass(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 8) = result;
  return result;
}

CFStringRef me_copyFormattingDesc(uint64_t a1)
{
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, @"[FigMetricEvent %p]", a1);
}

CFStringRef meMock_copyDebugDesc(uint64_t a1)
{
  CFAllocatorRef AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, @"[FigMetricEvent %p]", a1);
}

uint64_t me_getMetricEventID(uint64_t a1)
{
  return *(void *)CMBaseObjectGetDerivedStorage(a1);
}

uint64_t me_isMock()
{
  return 1;
}

uint64_t CMByteStreamCreateCompositeForRead(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t *a4, uint64_t *a5, CFTypeRef *a6)
{
  if (a6 && (uint64_t v6 = a2, a2 >= 1) && (v7 = a3) != 0 && (v8 = a4) != 0 && (v9 = a5) != 0)
  {
    CFTypeRef cf = 0;
    ClassID = (void *)CMByteStreamGetClassID();
    uint64_t v13 = CMDerivedObjectCreate(a1, (uint64_t)&kFigCompositeByteStreamVTable, ClassID, &cf);
    if (v13) {
      return v13;
    }
    uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
    *uint64_t DerivedStorage = v6;
    DerivedStorage[2] = 0;
    pid_t v15 = malloc_type_malloc(32 * v6, 0x1020040B07D1DCCuLL);
    DerivedStorage[1] = v15;
    if (v15)
    {
      uint64_t v16 = -16;
      do
      {
        CFTypeRef v17 = CFRetain(*v7);
        uint64_t v18 = DerivedStorage[1];
        uint64_t v19 = (void *)(v18 + v16);
        uint64_t v20 = *v8++;
        v19[2] = v17;
        v19[3] = v20;
        uint64_t v22 = *v9++;
        uint64_t v21 = v22;
        v19[5] = v22;
        if (v16 == -16) {
          uint64_t v23 = 0;
        }
        else {
          uint64_t v23 = v19[1] + *v19;
        }
        v19[4] = v23;
        v16 += 32;
        ++v7;
        --v6;
      }
      while (v6);
      uint64_t v24 = 0;
      DerivedStorage[3] = v21 + *(void *)(v18 + v16);
      *a6 = cf;
    }
    else
    {
      uint64_t v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      CFRelease(cf);
    }
    return v24;
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCompositeReadByteStreamCreate(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t *a4, uint64_t *a5, CFTypeRef *a6)
{
  return CMByteStreamCreateCompositeForRead(a2, a1, a3, a4, a5, a6);
}

uint64_t FigCompositeByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = (void *)CMBaseObjectGetDerivedStorage(a2);
  if (*DerivedStorage == *v4)
  {
    if (*DerivedStorage < 1) {
      return 1;
    }
    uint64_t v5 = v4;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    while (1)
    {
      uint64_t v8 = DerivedStorage[1] + v6;
      uint64_t v9 = v5[1] + v6;
      if (*(void *)(v8 + 8) != *(void *)(v9 + 8) || *(void *)(v8 + 24) != *(void *)(v9 + 24)) {
        break;
      }
      uint64_t result = CFEqual(*(CFTypeRef *)v8, *(CFTypeRef *)v9);
      if (!result) {
        return result;
      }
      ++v7;
      v6 += 32;
      if (v7 >= *DerivedStorage) {
        return 1;
      }
    }
  }
  return 0;
}

void FigCompositeByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      CFRelease(*(CFTypeRef *)(DerivedStorage[1] + v2));
      ++v3;
      v2 += 32;
    }
    while (v3 < *DerivedStorage);
  }
  uint64_t v4 = (void *)DerivedStorage[1];

  free(v4);
}

uint64_t FigCompositeByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFNumberRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"FBS_EntireLength") || CFEqual(a2, @"FBS_AvailableLength"))
  {
    CFNumberRef v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, (const void *)(DerivedStorage + 24));
    uint64_t result = 0;
    *a4 = v8;
  }
  else if (CFEqual(a2, @"FBS_URL") || CFEqual(a2, @"FBS_FileType"))
  {
    uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(**(void **)(DerivedStorage + 8));
    uint64_t v11 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = *(uint64_t (**)(uint64_t, const void *, uint64_t, CFNumberRef *))(v12 + 48);
    if (v13)
    {
      return v13(CMBaseObject, a2, a3, a4);
    }
    else
    {
      return 4294954514;
    }
  }
  else if (CFEqual(a2, @"FBS_MIMEType"))
  {
    uint64_t v14 = **(void **)(DerivedStorage + 8);
    return CMByteStreamCopyProperty(v14, (uint64_t)a2, a3, (uint64_t)a4);
  }
  else
  {
    return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCompositeByteStreamSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v6 = 0;
  uint64_t v7 = -1;
  while (++v7 < *DerivedStorage)
  {
    uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(*(void *)(DerivedStorage[1] + v6));
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 56);
    if (!v11) {
      return 4294954514;
    }
    v6 += 32;
    uint64_t result = v11(CMBaseObject, a2, a3);
    if (result) {
      return result;
    }
  }
  return 0;
}

uint64_t CMByteStreamCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject();
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 48);
  if (!v10) {
    return 4294954514;
  }

  return v10(CMBaseObject, a2, a3, a4);
}

uint64_t FigCompositeByteStreamRead(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage < 1) {
    return 4294954423;
  }
  uint64_t v9 = DerivedStorage;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = DerivedStorage[1];
  while (1)
  {
    uint64_t v13 = *(void *)(v12 + v10 + 16);
    if (v13 <= a3 && *(void *)(v12 + v10 + 24) + v13 > a3) {
      break;
    }
    ++v11;
    v10 += 32;
    if (*DerivedStorage == v11) {
      return 4294954423;
    }
  }
  uint64_t v30 = a5;
  unint64_t v15 = 0;
  if (a2)
  {
    uint64_t v16 = v11 - 1;
    do
    {
      if (++v16 >= *v9) {
        break;
      }
      unint64_t v17 = a2 - v15;
      uint64_t v32 = a2 - v15;
      uint64_t v18 = (uint64_t *)(v9[1] + v10);
      uint64_t v19 = v18[2];
      BOOL v20 = __OFSUB__(a3, v19);
      uint64_t v21 = a3 - v19;
      if ((v21 < 0) ^ v20 | (v21 == 0)) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = v21;
      }
      unint64_t v23 = v18[3] - v22;
      if (v17 > v23)
      {
        uint64_t v32 = v18[3] - v22;
        unint64_t v17 = v23;
      }
      uint64_t v25 = *v18;
      uint64_t v24 = v18[1];
      uint64_t v26 = *(void *)(CMBaseObjectGetVTable(*v18) + 16);
      if (v26) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = 0;
      }
      CFTypeRef v28 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, unint64_t, uint64_t *))(v27 + 8);
      if (!v28) {
        return 4294954514;
      }
      uint64_t result = v28(v25, v17, v24 + v22, a4 + v15, &v32);
      if (result) {
        return result;
      }
      v10 += 32;
      v15 += v32;
    }
    while (v15 < a2);
  }
  if (v15) {
    BOOL v29 = 1;
  }
  else {
    BOOL v29 = a2 == 0;
  }
  if (v29) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 4294954423;
  }
  _OWORD v9[2] = v15 + a3;
  if (v30) {
    *uint64_t v30 = v15;
  }
  return result;
}

uint64_t FigCompositeByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  if (a3)
  {
    uint64_t v6 = DerivedStorage;
    uint64_t v7 = *DerivedStorage;
    if (*DerivedStorage < 1)
    {
      return 4294954423;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = DerivedStorage[1];
      while (1)
      {
        uint64_t v11 = *(void *)(v10 + v8 + 16);
        if (v11 <= a2 && *(void *)(v10 + v8 + 24) + v11 > a2) {
          break;
        }
        ++v9;
        v8 += 32;
        if (v7 == v9) {
          return 4294954423;
        }
      }
      if (v9 >= v7)
      {
        uint64_t v13 = 0;
LABEL_23:
        uint64_t result = 0;
        *a3 = v13;
      }
      else
      {
        uint64_t v13 = 0;
        while (1)
        {
          uint64_t v23 = 0;
          uint64_t v14 = (uint64_t *)(v10 + v8);
          uint64_t v15 = v14[2];
          BOOL v16 = __OFSUB__(a2, v15);
          uint64_t v17 = a2 - v15;
          uint64_t v18 = ((v17 < 0) ^ v16) | (v17 == 0) ? 0 : v17;
          uint64_t v19 = *v14;
          uint64_t v20 = *(void *)(CMBaseObjectGetVTable(*v14) + 16);
          uint64_t v21 = v20 ? v20 : 0;
          uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(v21 + 24);
          if (!v22) {
            return 4294954514;
          }
          uint64_t result = v22(v19, v18, &v23);
          if (result) {
            return result;
          }
          v13 += v23;
          uint64_t v10 = v6[1];
          if (v23 + v18 >= *(void *)(v10 + v8 + 24) + *(void *)(v10 + v8 + 8))
          {
            ++v9;
            v8 += 32;
            if (v9 < *v6) {
              continue;
            }
          }
          goto LABEL_23;
        }
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCompositeByteStreamReadAndCreateBlockBuffer(uint64_t a1, uint64_t appended, uint64_t a3, OpaqueCMBlockBuffer **a4, unint64_t *a5)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  CMBlockBufferRef targetBBuf = 0;
  if (*DerivedStorage < 1) {
    return 4294954423;
  }
  uint64_t v10 = DerivedStorage;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = DerivedStorage[1];
  while (1)
  {
    uint64_t v14 = *(void *)(v13 + v11 + 16);
    if (v14 <= a3 && *(void *)(v13 + v11 + 24) + v14 > a3) {
      break;
    }
    ++v12;
    v11 += 32;
    if (*DerivedStorage == v12) {
      return 4294954423;
    }
  }
  if (appended)
  {
    uint64_t v32 = a4;
    CFMutableDictionaryRef v33 = a5;
    BOOL v16 = 0;
    unint64_t v17 = 0;
    uint64_t v18 = v12 - 1;
    unint64_t v34 = appended;
    while (1)
    {
      if (++v18 >= *v10)
      {
        uint64_t appended = 4294954423;
LABEL_33:
        a4 = v32;
        a5 = v33;
        goto LABEL_34;
      }
      unint64_t v19 = appended - v17;
      uint64_t v35 = v19;
      uint64_t v20 = (uint64_t *)(v10[1] + v11);
      uint64_t v21 = v20[2];
      BOOL v22 = __OFSUB__(a3, v21);
      uint64_t v23 = a3 - v21;
      if ((v23 < 0) ^ v22 | (v23 == 0)) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = v23;
      }
      unint64_t v25 = v20[3] - v24;
      if (v19 > v25)
      {
        uint64_t v35 = v20[3] - v24;
        unint64_t v19 = v25;
      }
      CMBlockBufferRef targetBBuf = 0;
      uint64_t v27 = *v20;
      uint64_t v26 = v20[1];
      uint64_t v28 = *(void *)(CMBaseObjectGetVTable(*v20) + 16);
      if (v28) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, CMBlockBufferRef *, uint64_t *))(v29 + 32);
      if (!v30)
      {
        uint64_t appended = 4294954514;
        if (!v16) {
          return appended;
        }
        goto LABEL_31;
      }
      uint64_t v31 = v30(v27, v19, v26 + v24, &targetBBuf, &v35);
      if (v31) {
        break;
      }
      if (v16)
      {
        uint64_t appended = CMBlockBufferAppendBufferReference(v16, targetBBuf, 0, 0, 0);
        if (targetBBuf) {
          CFRelease(targetBBuf);
        }
        if (appended) {
          goto LABEL_31;
        }
      }
      else
      {
        BOOL v16 = targetBBuf;
      }
      v11 += 32;
      uint64_t appended = v34;
      v17 += v35;
      if (v17 >= v34)
      {
        uint64_t appended = 0;
        goto LABEL_33;
      }
    }
    uint64_t appended = v31;
    if (v16) {
LABEL_31:
    }
      CFRelease(v16);
  }
  else
  {
    unint64_t v17 = 0;
    BOOL v16 = 0;
LABEL_34:
    int v10[2] = v17 + a3;
    *a4 = v16;
    if (a5) {
      *a5 = v17;
    }
  }
  return appended;
}

uint64_t CMByteStreamCreateForBlockBuffer(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  if (a3)
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    void v13[5] = v4;
    v13[6] = v5;
    v13[0] = 0;
    ClassID = (void *)CMByteStreamGetClassID();
    uint64_t result = CMDerivedObjectCreate(a1, (uint64_t)&kFigBBufByteStreamVTable, ClassID, v13);
    if (!result)
    {
      uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(v13[0]);
      if (a2) {
        CFTypeRef v12 = CFRetain(a2);
      }
      else {
        CFTypeRef v12 = 0;
      }
      uint64_t result = 0;
      *uint64_t DerivedStorage = v12;
      *a4 = v13[0];
    }
  }
  return result;
}

uint64_t CMByteStreamCreateWritableForBlockBuffer(const __CFAllocator *a1, void *a2, int a3, CFAllocatorRef Default, long long *a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  if (!a2 || a3)
  {
    uint64_t Empty = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    ClassID = (void *)CMByteStreamGetClassID();
    uint64_t Empty = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigBBufByteStreamVTable, ClassID, &cf);
    if (!Empty)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      uint64_t v14 = DerivedStorage;
      if (a5)
      {
        long long v15 = *a5;
        *(_OWORD *)(DerivedStorage + 76) = *(long long *)((char *)a5 + 12);
        *(_OWORD *)(DerivedStorage + 64) = v15;
        *(unsigned char *)(DerivedStorage + 92) = 1;
        *(void *)(DerivedStorage + 56) = 0;
      }
      else
      {
        if (!Default) {
          CFAllocatorRef Default = CFAllocatorGetDefault();
        }
        *(void *)(v14 + 56) = Default;
        CFRetain(Default);
      }
      uint64_t Empty = CMBlockBufferCreateEmpty(a1, 0x53u, 0, (CMBlockBufferRef *)(v14 + 40));
      if (!Empty)
      {
        if (!CMBlockBufferGetDataLength((CMBlockBufferRef)a2)
          || (uint64_t Empty = CMBlockBufferAssureBlockMemory((CMBlockBufferRef)a2), !Empty))
        {
          uint64_t v16 = 0;
          *(void *)uint64_t v14 = CFRetain(a2);
          *a6 = cf;
          return v16;
        }
      }
    }
  }
  uint64_t v16 = Empty;
  if (Empty && cf) {
    CFRelease(cf);
  }
  return v16;
}

uint64_t FigByteStreamCreateForBlockBuffer(const void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  return CMByteStreamCreateForBlockBuffer(a3, a1, a2, a4);
}

uint64_t FigBBufByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = *(const void **)CMBaseObjectGetDerivedStorage(a2);
  uint64_t v5 = *DerivedStorage;

  return CFEqual(v5, v4);
}

void FigBBufByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 40);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(DerivedStorage + 56);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 8);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(DerivedStorage + 16);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(DerivedStorage + 32);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)(DerivedStorage + 24);
  if (v7)
  {
    CFRelease(v7);
  }
}

uint64_t FigBBufByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"FBS_EntireLength") || CFEqual(a2, @"FBS_AvailableLength"))
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    size_t DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)DerivedStorage);
    CFNumberRef SInt64 = FigCFNumberCreateSInt64(v7, DataLength);
LABEL_4:
    uint64_t v10 = SInt64;
    uint64_t result = 0;
    *a4 = v10;
    return result;
  }
  if (CFEqual(a2, @"FBS_EntireLengthAvailableOnDemand")) {
    goto LABEL_6;
  }
  if (CFEqual(a2, @"FBS_URL"))
  {
    uint64_t v13 = *(const void **)(DerivedStorage + 8);
    if (v13) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_FileType"))
  {
    uint64_t v13 = *(const void **)(DerivedStorage + 32);
    if (v13) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_MIMEType"))
  {
    uint64_t v13 = *(const void **)(DerivedStorage + 16);
    if (v13) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"FBS_UTI"))
  {
    uint64_t v13 = *(const void **)(DerivedStorage + 24);
    if (v13) {
      goto LABEL_8;
    }
    return 4294954512;
  }
  if (CFEqual(a2, @"DoesReadAhead") || CFEqual(a2, @"FBS_ReadSupported"))
  {
LABEL_6:
    CFTypeRef v12 = (const void **)MEMORY[0x1E4F1CFD0];
LABEL_7:
    uint64_t v13 = *v12;
LABEL_8:
    CFNumberRef SInt64 = (void *)CFRetain(v13);
    goto LABEL_4;
  }
  if (CFEqual(a2, @"FBS_WriteSupported"))
  {
    CFTypeRef v12 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!*(void *)(DerivedStorage + 40)) {
      CFTypeRef v12 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    goto LABEL_7;
  }

  return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBBufByteStreamSetProperty(const void *a1, const void *a2, const __CFString *a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (CFEqual(a2, @"FBS_URL"))
  {
    if (!a3 || (CFTypeID v7 = CFGetTypeID(a3), v7 == CFURLGetTypeID()))
    {
      uint64_t v8 = (const void *)DerivedStorage[1];
      if (v8) {
        CFRelease(v8);
      }
      DerivedStorage[1] = a3;
      if (!a3) {
        return 0;
      }
      goto LABEL_14;
    }
    goto LABEL_36;
  }
  if (CFEqual(a2, @"FBS_FileType"))
  {
    if (!a3 || (CFTypeID v9 = CFGetTypeID(a3), v9 == CFNumberGetTypeID()))
    {
      uint64_t v10 = (const void *)DerivedStorage[4];
      if (v10) {
        CFRelease(v10);
      }
      DerivedStorage[4] = a3;
      if (!a3) {
        return 0;
      }
LABEL_14:
      CFRetain(a3);
      return 0;
    }
    goto LABEL_36;
  }
  if (CFEqual(a2, @"FBS_MIMEType"))
  {
    if (!a3 || (CFTypeID v12 = CFGetTypeID(a3), v12 == CFStringGetTypeID()))
    {
      uint64_t v13 = (const void *)DerivedStorage[2];
      if (v13) {
        CFRelease(v13);
      }
      if (a3)
      {
        CFAllocatorRef v14 = CFGetAllocator(a1);
        DerivedStorage[2] = CFStringCreateCopy(v14, a3);
      }
      else
      {
        DerivedStorage[2] = 0;
      }
      return 0;
    }
    goto LABEL_36;
  }
  if (CFEqual(a2, @"FBS_UTI"))
  {
    if (!a3 || (CFTypeID v15 = CFGetTypeID(a3), v15 == CFStringGetTypeID()))
    {
      uint64_t v16 = (const void *)DerivedStorage[3];
      if (v16) {
        CFRelease(v16);
      }
      if (a3)
      {
        CFAllocatorRef v17 = CFGetAllocator(a1);
        DerivedStorage[3] = CFStringCreateCopy(v17, a3);
      }
      else
      {
        DerivedStorage[3] = 0;
      }
      return 0;
    }
LABEL_36:
    uint64_t v18 = 4294954424;
    goto LABEL_32;
  }
  uint64_t v18 = 4294954512;
LABEL_32:

  return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBBufByteStreamRead(uint64_t a1, size_t a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = (CMBlockBufferRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  if ((a3 & 0x8000000000000000) != 0)
  {
    uint64_t result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
    size_t v13 = 0;
    if (!a5) {
      return result;
    }
    goto LABEL_16;
  }
  uint64_t v11 = DerivedStorage;
  size_t DataLength = CMBlockBufferGetDataLength(*DerivedStorage);
  if (DataLength - a3 >= a2) {
    size_t v13 = a2;
  }
  else {
    size_t v13 = DataLength - a3;
  }
  if (DataLength <= a3 || v13 == 0)
  {
    size_t v13 = 0;
    if (a2) {
      uint64_t result = 4294954423;
    }
    else {
      uint64_t result = 0;
    }
    if (a5) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t result = CMBlockBufferCopyDataBytes(*v11, a3, v13, a4);
    if (a5) {
LABEL_16:
    }
      *a5 = v13;
  }
  return result;
}

uint64_t FigBBufByteStreamWrite(uint64_t a1, size_t a2, size_t a3, char *a4, size_t *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  size_t DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)DerivedStorage);
  if (!*(void *)(DerivedStorage + 40))
  {
    uint64_t v23 = 4294954419;
    goto LABEL_41;
  }
  if (!a4 || (a3 & 0x8000000000000000) != 0)
  {
    uint64_t v23 = 4294954424;
LABEL_41:
    uint64_t result = FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
    goto LABEL_42;
  }
  if (!a2) {
    goto LABEL_35;
  }
  size_t v12 = DataLength;
  if (DataLength <= a3)
  {
    size_t v15 = a2;
  }
  else
  {
    if (DataLength - a3 >= a2) {
      size_t v13 = a2;
    }
    else {
      size_t v13 = DataLength - a3;
    }
    uint64_t result = CMBlockBufferReplaceDataBytes(a4, *(CMBlockBufferRef *)DerivedStorage, a3, v13);
    if (result) {
      goto LABEL_42;
    }
    size_t v15 = a2 - v13;
    if (a2 == v13) {
      goto LABEL_35;
    }
    a3 += v13;
    a4 += v13;
  }
  if (a3 >= v12) {
    size_t v16 = a3 - v12;
  }
  else {
    size_t v16 = 0;
  }
  uint64_t v18 = (size_t *)(DerivedStorage + 104);
  size_t v17 = *(void *)(DerivedStorage + 104);
  if (v17)
  {
    if (a3 <= v12)
    {
LABEL_23:
      if (v15 >= v17) {
        size_t v20 = v17;
      }
      else {
        size_t v20 = v15;
      }
      memcpy(*(void **)(DerivedStorage + 96), a4, v20);
      v15 -= v20;
      ConsumeSomeBacking(DerivedStorage, v20);
      if (!v15)
      {
LABEL_35:
        uint64_t result = 0;
        if (!a5) {
          return result;
        }
        goto LABEL_36;
      }
      size_t v16 = 0;
      a4 += v20;
      goto LABEL_28;
    }
    if (v16 >= v17) {
      size_t v19 = *(void *)(DerivedStorage + 104);
    }
    else {
      size_t v19 = v16;
    }
    bzero(*(void **)(DerivedStorage + 96), v19);
    ConsumeSomeBacking(DerivedStorage, v19);
    v16 -= v19;
    if (!v16)
    {
      size_t v17 = *v18;
      if (*v18) {
        goto LABEL_23;
      }
      size_t v16 = 0;
    }
  }
LABEL_28:
  size_t v21 = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(DerivedStorage + 40));
  if (*(unsigned char *)(DerivedStorage + 92)) {
    BOOL v22 = (const CMBlockBufferCustomBlockSource *)(DerivedStorage + 64);
  }
  else {
    BOOL v22 = 0;
  }
  uint64_t result = CMBlockBufferAppendMemoryBlock(*(CMBlockBufferRef *)(DerivedStorage + 40), 0, (v15 + v16 + 0x3FFF) & 0xFFFFFFFFFFFFC000, *(CFAllocatorRef *)(DerivedStorage + 56), v22, 0, (v15 + v16 + 0x3FFF) & 0xFFFFFFFFFFFFC000, 1u);
  if (!result)
  {
    CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(DerivedStorage + 40), v21, (size_t *)(DerivedStorage + 104), 0, (char **)(DerivedStorage + 96));
    if (v16) {
      bzero(*(void **)(DerivedStorage + 96), v16);
    }
    memcpy((void *)(*(void *)(DerivedStorage + 96) + v16), a4, v15);
    ConsumeSomeBacking(DerivedStorage, v15 + v16);
    goto LABEL_35;
  }
LABEL_42:
  a2 = 0;
  if (!a5) {
    return result;
  }
LABEL_36:
  *a5 = a2;
  return result;
}

uint64_t FigBBufByteStreamGetAvailableLengthAtOffset(uint64_t a1, size_t a2, size_t *a3)
{
  size_t totalLengthOut = 0;
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = (CMBlockBufferRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (a3)
  {
    if ((a2 & 0x8000000000000000) != 0)
    {
      size_t v8 = 0;
    }
    else
    {
      OSStatus DataPointer = CMBlockBufferGetDataPointer(*DerivedStorage, a2, 0, &totalLengthOut, 0);
      size_t v8 = 0;
      if (!DataPointer) {
        size_t v8 = totalLengthOut - a2;
      }
    }
    *a3 = v8;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigBBufByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, size_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  uint64_t CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  uint64_t DerivedStorage = (CMBlockBufferRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  CMBlockBufferRef blockBufferOut = 0;
  if ((a3 & 0x8000000000000000) != 0)
  {
    uint64_t result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
    size_t v14 = 0;
    if (!a5) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  size_t v12 = DerivedStorage;
  size_t DataLength = CMBlockBufferGetDataLength(*DerivedStorage);
  if (DataLength - a3 >= a2) {
    size_t v14 = a2;
  }
  else {
    size_t v14 = DataLength - a3;
  }
  if (DataLength <= a3 || v14 == 0)
  {
    size_t v14 = 0;
    if (a2) {
      uint64_t result = 4294954423;
    }
    else {
      uint64_t result = 0;
    }
    if (a5) {
      goto LABEL_16;
    }
  }
  else
  {
    CFAllocatorRef v16 = CFGetAllocator(a1);
    uint64_t result = CMBlockBufferCreateWithBufferReference(v16, *v12, a3, v14, 0, &blockBufferOut);
    if (a5) {
LABEL_16:
    }
      *a5 = v14;
  }
LABEL_17:
  *a4 = blockBufferOut;
  return result;
}

uint64_t ConsumeSomeBacking(uint64_t a1, size_t dataLength)
{
  uint64_t result = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)a1, *(CMBlockBufferRef *)(a1 + 40), *(void *)(a1 + 48), dataLength, 4u);
  *(void *)(a1 + 48) += dataLength;
  size_t v5 = *(void *)(a1 + 104) - dataLength;
  *(void *)(a1 + 104) = v5;
  if (v5) {
    size_t v5 = *(void *)(a1 + 96) + dataLength;
  }
  *(void *)(a1 + 96) = v5;
  return result;
}

uint64_t FigCaptionDynamicStyleGetTypeID()
{
  return sFigCaptionDynamicStyleID;
}

uint64_t RegisterFigCaptionDynamicStyleType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionDynamicStyleID = result;
  return result;
}

uint64_t FigCaptionDynamicStyleCreateMutable(const __CFAllocator *a1, const void *a2, void *a3)
{
  if (a2 && a3)
  {
    FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      CFTypeID v7 = (void *)Instance;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      v7[2] = Mutable;
      if (Mutable)
      {
        uint64_t v9 = FigCaptionDynamicStyleAddKeyFrameValue((uint64_t)v7, a2, 0.0);
        if (!v9)
        {
          *a3 = v7;
          return v9;
        }
      }
      else
      {
        FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        uint64_t v9 = 0;
      }
      CFRelease(v7);
      return v9;
    }
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    return 0;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionDynamicStyleAddKeyFrameValue(uint64_t a1, const void *a2, double a3)
{
  double valuePtr = a3;
  if (a1 && a3 >= 0.0 && a2)
  {
    CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v5, a2);
      CFTypeID v7 = *(const void **)(a1 + 24);
      if (v7)
      {
        CFRelease(v7);
        *(void *)(a1 + 24) = 0;
      }
      CFRelease(v6);
      return 0;
    }
    else
    {
      return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionDynamicStyleCreate(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a3)
  {
    uint64_t v4 = FigCaptionDynamicStyleCreateMutable(a1, a2, &cf);
    if (v4)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      *a3 = cf;
    }
    return v4;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

CFIndex FigCaptionDynamicStyleGetKeyFrameCount(CFIndex result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFArrayRef v2 = *(const __CFArray **)(result + 24);
    if (!v2)
    {
      fcds_initializeSortedKeyFrameValues(v1);
      CFArrayRef v2 = *(const __CFArray **)(v1 + 24);
    }
    return CFArrayGetCount(v2);
  }
  return result;
}

void fcds_initializeSortedKeyFrameValues(uint64_t a1)
{
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
  CFArrayCallBacks v8 = *(CFArrayCallBacks *)byte_1EDF6DB78;
  CFMutableArrayRef v3 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, &v8);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)fcds_appendRelativeTimeAndValueToArray, v3);
  v9.CFIndex location = 0;
  v9.CFIndex length = Count;
  CFArraySortValues(v3, v9, (CFComparatorFunction)fcds_compareRelativeTime, 0);
  if (CFArrayGetCount(v3) >= 1)
  {
    CFIndex v4 = 0;
    CFNumberRef v5 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(v3, v4);
      if (v5 && FigCFEqual(v5[1], ValueAtIndex[1]))
      {
        CFArrayRemoveValueAtIndex(v3, v4);
      }
      else
      {
        ++v4;
        CFNumberRef v5 = ValueAtIndex;
      }
    }
    while (v4 < CFArrayGetCount(v3));
  }
  CFTypeID v7 = *(const void **)(a1 + 24);
  *(void *)(a1 + 24) = v3;
  if (v3) {
    CFRetain(v3);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t FigCaptionDynamicStyleCopyKeyFrameValueAtIndex(CFIndex a1, CFIndex a2, void *a3, void *a4)
{
  KeyFrameCFIndex Count = FigCaptionDynamicStyleGetKeyFrameCount(a1);
  if (!a1 || a2 < 0 || KeyFrameCount <= a2)
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    CFArrayRef v9 = *(const __CFArray **)(a1 + 24);
    if (!v9)
    {
      fcds_initializeSortedKeyFrameValues(a1);
      CFArrayRef v9 = *(const __CFArray **)(a1 + 24);
    }
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v9, a2);
    if (a3) {
      *a3 = *ValueAtIndex;
    }
    if (a4)
    {
      CFTypeRef v11 = (CFTypeRef)ValueAtIndex[1];
      if (v11) {
        CFTypeRef v11 = CFRetain(v11);
      }
      *a4 = v11;
    }
    return 0;
  }
}

uint64_t FigCaptionDynamicStyleCopyKeyFrameValueAtRelativeTime(CFIndex a1, void *a2, void *a3, double a4)
{
  KeyFrameCFIndex Count = FigCaptionDynamicStyleGetKeyFrameCount(a1);
  if (a1 && (CFIndex v9 = KeyFrameCount, KeyFrameCount > 0))
  {
    CFArrayRef v10 = *(const __CFArray **)(a1 + 24);
    if (!v10)
    {
      fcds_initializeSortedKeyFrameValues(a1);
      CFArrayRef v10 = *(const __CFArray **)(a1 + 24);
    }
    v19[0] = a4;
    v19[1] = 0.0;
    v21.CFIndex location = 0;
    v21.CFIndex length = v9;
    CFIndex v11 = CFArrayBSearchValues(v10, v21, v19, (CFComparatorFunction)fcds_compareRelativeTime, 0);
    if (v11 >= v9)
    {
      CFIndex v15 = v9 - 1;
    }
    else
    {
      CFIndex v12 = v11;
      if (v11)
      {
        CFDictionaryRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v11);
        BOOL v14 = v19[0] > *ValueAtIndex || v19[0] < *ValueAtIndex;
        CFIndex v15 = v12 - v14;
      }
      else
      {
        CFIndex v15 = 0;
      }
    }
    CFAllocatorRef v16 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v15);
    if (a2) {
      *a2 = *v16;
    }
    if (a3)
    {
      CFTypeRef v17 = (CFTypeRef)v16[1];
      if (v17) {
        CFTypeRef v17 = CFRetain(v17);
      }
      *a3 = v17;
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t fcds_compareRelativeTime(double *a1, double *a2)
{
  if (*a1 < *a2) {
    return -1;
  }
  else {
    return *a1 > *a2;
  }
}

CFDictionaryRef *FigCaptionDynamicStyleGetInitialValue(CFDictionaryRef *a1)
{
  CFNumberRef Value = a1;
  uint64_t valuePtr = 0;
  if (a1)
  {
    CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
    CFNumberRef Value = (CFDictionaryRef *)CFDictionaryGetValue(Value[2], v2);
    if (v2) {
      CFRelease(v2);
    }
  }
  return Value;
}

uint64_t fcds_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

void fcds_Finalize(uint64_t a1)
{
  CFNumberRef v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  CFMutableArrayRef v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
  }
}

CFTypeRef *fcds_Equal(CFTypeRef *result, CFTypeRef *a2)
{
  if (result)
  {
    CFMutableArrayRef v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
    uint64_t result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionDynamicStyleID)
      {
        CFTypeID v5 = CFGetTypeID(a2);
        FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
        if (v5 == sFigCaptionDynamicStyleID) {
          return (CFTypeRef *)(CFEqual(v3[2], a2[2]) != 0);
        }
        else {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t fcds_Hash(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
  if (v2 != sFigCaptionDynamicStyleID) {
    return 0;
  }
  KeyFrameCFIndex Count = FigCaptionDynamicStyleGetKeyFrameCount((CFIndex)a1);
  if (!KeyFrameCount) {
    return 0;
  }
  CFIndex v4 = KeyFrameCount;
  CFIndex v5 = 0;
  uint64_t v6 = 0;
  double v8 = 0.0;
  do
  {
    if (FigCaptionDynamicStyleCopyKeyFrameValueAtIndex((CFIndex)a1, v5, &v8, 0)) {
      break;
    }
    v6 ^= (unint64_t)(v8 * 1000.0);
    ++v5;
  }
  while (v4 != v5);
  return v6;
}

CFStringRef fcds_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionDynamicStyle %p]", a1);
}

__CFString *fcds_CopyDebugDesc(CFIndex a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  KeyFrameCFIndex Count = FigCaptionDynamicStyleGetKeyFrameCount(a1);
  CFTypeRef cf = 0;
  CFStringAppendFormat(Mutable, 0, @"FigCaptionDynamicStyle (number of values = %ld)\n", KeyFrameCount);
  if (KeyFrameCount)
  {
    CFIndex v4 = 0;
    uint64_t v7 = 0;
    while (!FigCaptionDynamicStyleCopyKeyFrameValueAtIndex(a1, v4, &v7, &cf))
    {
      CFStringAppendFormat(Mutable, 0, @"  %3.2f : %@\n", v7, cf);
      if (KeyFrameCount - 1 == v4) {
        break;
      }
      ++v4;
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  return Mutable;
}

void fcds_appendRelativeTimeAndValueToArray(const __CFNumber *a1, uint64_t a2, __CFArray *a3)
{
  uint64_t v6 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 16, 0);
  CFNumberGetValue(a1, kCFNumberDoubleType, v6);
  v6[1] = a2;

  CFArrayAppendValue(a3, v6);
}

uint64_t FigEndpointXPCDemuxCreate(const void *a1, const void *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (endpointXPCDemux_initializeLogging_initLoggingOnce == -1)
  {
    if (!a1) {
      goto LABEL_8;
    }
  }
  else
  {
    dispatch_once(&endpointXPCDemux_initializeLogging_initLoggingOnce, &__block_literal_global_11);
    if (!a1) {
      goto LABEL_8;
    }
  }
  if (a2)
  {
    uint64_t v6 = *MEMORY[0x1E4F1CF80];
    ClassID = (void *)FigEndpointExtendedGetClassID();
    uint64_t v8 = CMDerivedObjectCreate(v6, (uint64_t)&kFigEndpointXPCDemuxVTable, ClassID, &cf);
    if (v8)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      uint64_t DerivedStorage = (unint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *uint64_t DerivedStorage = (unint64_t)CFRetain(a1);
      DerivedStorage[1] = (unint64_t)CFRetain(a2);
      CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)cf, (CFNotificationCallback)endpointXPCDemux_handleCentralNotification, 0, *DerivedStorage, 0, 0);
      uint64_t v8 = 0;
      *a3 = cf;
    }
    return v8;
  }
LABEL_8:

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t endpointXPCDemux_handleCentralNotification(__CFNotificationCenter *a1, const void *a2, const __CFString *a3, int a4, const __CFDictionary *cf)
{
  return CMNotificationCenterPostNotification(a1, a3, a2, cf);
}

BOOL FigEndpointIsXPCDemux(uint64_t a1)
{
  return a1 && (_UNKNOWN *)CMBaseObjectGetVTable(a1) == &kFigEndpointXPCDemuxVTable;
}

BOOL FigEndpointXPCDemuxEndpointsMatch(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  return *DerivedStorage == a2 && DerivedStorage[1] == a3;
}

uint64_t FigEndpointXPCDemux_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = *DerivedStorage;
  if (!*DerivedStorage) {
    return 4294954516;
  }
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable(*DerivedStorage) + 8);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t))(v4 + 24);
  if (!v6) {
    return 4294954514;
  }

  return v6(v2);
}

void FigEndpointXPCDemux_Finalize(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)endpointXPCDemux_handleCentralNotification, 0, *(const void **)DerivedStorage);
  if (*(void *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(void *)uint64_t DerivedStorage = 0;
  }
  uint64_t v4 = *(const void **)(DerivedStorage + 8);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(DerivedStorage + 8) = 0;
  }
}

CFStringRef FigEndpointXPCDemux_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<FigEndpointXPCDemux %p: central=%@, sub=%@>", a1, *DerivedStorage, DerivedStorage[1]);
}

uint64_t FigEndpointXPCDemux_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, @"iOSEntityIsDoingTurnByTurn")
    || CFEqual(a2, @"CarEntityIsDoingTurnByTurn")
    || CFEqual(a2, @"CarEntityIsDoingVoiceRecognition")
    || CFEqual(a2, @"CarEntityOwnsScreen")
    || CFEqual(a2, @"CarEntityOwnsMainAudio")
    || CFEqual(a2, @"CarPlaySubEndpoint"))
  {
    uint64_t CMBaseObject = FigEndpointGetCMBaseObject(*DerivedStorage);
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    CFIndex v11 = *(uint64_t (**)(uint64_t, const void *, uint64_t, uint64_t))(v10 + 48);
    if (v11)
    {
      return v11(CMBaseObject, a2, a3, a4);
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    uint64_t v13 = DerivedStorage[1];
    return FigEndpointCopyProperty(v13, (uint64_t)a2, a3, a4);
  }
}

uint64_t FigEndpointXPCDemux_SetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(*DerivedStorage);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
  if (!v9) {
    return 4294954514;
  }

  return v9(CMBaseObject, a2, a3);
}

uint64_t FigEndpointCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t CMBaseObject = FigEndpointGetCMBaseObject(a1);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 48);
  if (!v10) {
    return 4294954514;
  }

  return v10(CMBaseObject, a2, a3, a4);
}

uint64_t FigEndpointXPCDemux_ActivateForFeaturesWithCompletionCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable(v9) + 16);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  CFIndex v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 8);
  if (!v12) {
    return 4294954514;
  }

  return v12(v9, a2, a3, a4, a5);
}

uint64_t FigEndpointXPCDemux_DeactivateWithCompletionCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(v7) + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 16);
  if (!v10) {
    return 4294954514;
  }

  return v10(v7, a2, a3, a4);
}

uint64_t FigEndpointXPCDemux_Dissociate(uint64_t a1)
{
  uint64_t v1 = *(void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(v1) + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 32);
  if (!v4) {
    return 4294954514;
  }

  return v4(v1);
}

uint64_t FigEndpointXPCDemux_SetDelegateRemoteControl(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 8);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(v3) + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 56);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigEndpointXPCDemux_CreatePlaybackSession(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = *(void *)(CMBaseObjectGetVTable(v3) + 16);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 72);
  if (!v6) {
    return 4294954514;
  }

  return v6(v3, a2);
}

uint64_t FigEndpointXPCDemux_RequestCarUI(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 8);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_BorrowScreen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 16);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_UnborrowScreen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 24);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_TakeScreen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 32);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_DisableBluetoothConnectivityToDevice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 40);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_DuckAudio(uint64_t a1, uint64_t a2)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v4 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v4
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v4, ClassID)))
  {
    uint64_t v4 = 0;
  }
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable((uint64_t)v4) + 24);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(char *, uint64_t))(v7 + 48);
  if (!v8) {
    return 4294954514;
  }

  return v8(v4, a2);
}

uint64_t FigEndpointXPCDemux_SetHIDInputMode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 56);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_CopyHIDInputMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v8 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v8
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v8, ClassID)))
  {
    uint64_t v8 = 0;
  }
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 24);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  CFIndex v12 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 64);
  if (!v12) {
    return 4294954514;
  }

  return v12(v8, a2, a3, a4);
}

uint64_t FigEndpointXPCDemux_SendCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v10 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v10
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v10, ClassID)))
  {
    uint64_t v10 = 0;
  }
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 24);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  BOOL v14 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 72);
  if (!v14) {
    return 4294954514;
  }

  return v14(v10, a2, a3, a4, a5);
}

uint64_t FigEndpointXPCDemux_CreateRemoteControlSession(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 80);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_CreateCommChannel(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 88);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_SendData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v10 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v10
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v10, ClassID)))
  {
    uint64_t v10 = 0;
  }
  uint64_t v12 = *(void *)(CMBaseObjectGetVTable((uint64_t)v10) + 24);
  if (v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  BOOL v14 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 96);
  if (!v14) {
    return 4294954514;
  }

  return v14(v10, a2, a3, a4, a5);
}

uint64_t FigEndpointXPCDemux_CloseCommChannel(uint64_t a1, uint64_t a2)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v4 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v4
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v4, ClassID)))
  {
    uint64_t v4 = 0;
  }
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable((uint64_t)v4) + 24);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(char *, uint64_t))(v7 + 104);
  if (!v8) {
    return 4294954514;
  }

  return v8(v4, a2);
}

uint64_t FigEndpointXPCDemux_RequestScreenViewArea(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 112);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_CopyCurrentScreenViewArea(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 120);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigEndpointXPCDemux_AcquireAndCopyResource(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v8 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v8
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v8, ClassID)))
  {
    uint64_t v8 = 0;
  }
  uint64_t v10 = *(void *)(CMBaseObjectGetVTable((uint64_t)v8) + 24);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 128);
  if (!v12) {
    return 4294954514;
  }

  return v12(v8, a2, a3, a4);
}

uint64_t FigEndpointXPCDemux_RelinquishResource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  uint64_t v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (void *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable((uint64_t)v6) + 24);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 136);
  if (!v10) {
    return 4294954514;
  }

  return v10(v6, a2, a3);
}

uint64_t FigSecCopyOutmostBundleSignedWithSameCertificateAsCodeAtURL(const __CFURL *a1, CFURLRef *a2)
{
  cf[128] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  SecStaticCodeRef staticCode = 0;
  cf[0] = 0;
  uint64_t v4 = FigCFURLCopyCanonicalPath(a1, cf);
  uint64_t v5 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (v4)
  {
    uint64_t v10 = v4;
    CFURLRef v9 = 0;
  }
  else
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v7 = (const __CFString *)cf[0];
    Boolean v8 = CFURLHasDirectoryPath(a1);
    CFURLRef v9 = CFURLCreateWithFileSystemPath(v6, v7, kCFURLPOSIXPathStyle, v8);
    uint64_t v10 = SecStaticCodeCreateWithPath(v9, 0, &staticCode);
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v10)
  {
    SecRequirementRef v33 = 0;
    CFURLRef v12 = 0;
    goto LABEL_85;
  }
  cf[0] = 0;
  uint64_t v10 = SecCodeCopyPath(staticCode, 0, (CFURLRef *)cf);
  xpc_object_t v43 = a2;
  if (v10)
  {
    CFURLRef v12 = 0;
  }
  else
  {
    if (CFURLHasDirectoryPath((CFURLRef)cf[0]))
    {
      if (!cf[0])
      {
        CFURLRef v12 = 0;
        goto LABEL_20;
      }
      CFURLRef PathComponent = (const __CFURL *)CFRetain(cf[0]);
    }
    else
    {
      CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(*v5, (CFURLRef)cf[0]);
    }
    CFURLRef v12 = PathComponent;
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v10)
  {
    SecRequirementRef v33 = 0;
    goto LABEL_85;
  }
  if (v12)
  {
    CFURLRef v13 = (const __CFURL *)CFRetain(v12);
    goto LABEL_21;
  }
LABEL_20:
  CFURLRef v13 = 0;
LABEL_21:
  SecRequirementRef requirement = 0;
  CFErrorRef errors = 0;
  cf[0] = 0;
  int v14 = SecCodeCopySigningInformation(staticCode, 2u, (CFDictionaryRef *)cf);
  if (!v14)
  {
    if (cf[0])
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf[0], (const void *)*MEMORY[0x1E4F3B9A8]);
      if (Value)
      {
        CFArrayRef v16 = Value;
        if (CFArrayGetCount(Value) > 0)
        {
          CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v16, 0);
          if (ValueAtIndex)
          {
            uint64_t v18 = ValueAtIndex;
            CFTypeID v19 = CFGetTypeID(ValueAtIndex);
            if (v19 == SecCertificateGetTypeID())
            {
              CFRetain(v18);
              int v20 = 0;
              goto LABEL_30;
            }
          }
        }
      }
    }
    int v14 = FigSignalErrorAt(4294949676, 0, 0, 0, 0, 0, 0);
  }
  int v20 = v14;
  uint64_t v18 = 0;
LABEL_30:
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v20)
  {
    SecRequirementRef v33 = 0;
    if (!v18) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
  CFDataRef v21 = SecCertificateCopyData((SecCertificateRef)v18);
  if (v21)
  {
    CFDataRef v22 = v21;
    CFTypeID v23 = CFGetTypeID(v21);
    if (v23 != CFDataGetTypeID() || (unint64_t Length = CFDataGetLength(v22), HIDWORD(Length)))
    {
      int v20 = FigSignalErrorAt(4294949676, 0, 0, 0, 0, 0, 0);
      CFMutableDictionaryRef Mutable = 0;
    }
    else
    {
      CC_LONG v25 = Length;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(*v5, 20);
      CFDataSetLength(Mutable, 20);
      BytePtr = CFDataGetBytePtr(v22);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      CC_SHA1(BytePtr, v25, MutableBytePtr);
      int v20 = 0;
    }
    CFRelease(v22);
    if (!v20)
    {
LABEL_38:
      uint64_t v29 = CFStringCreateMutable(*v5, 0);
      uint64_t v30 = CFDataGetBytePtr(Mutable);
      if (CFDataGetLength(Mutable) >= 1)
      {
        CFIndex v31 = 0;
        do
          CFStringAppendFormat(v29, 0, @"%02x", v30[v31++]);
        while (CFDataGetLength(Mutable) > v31);
      }
      if (Mutable) {
        goto LABEL_42;
      }
      goto LABEL_43;
    }
  }
  else
  {
    int v20 = FigSignalErrorAt(4294949676, 0, 0, 0, 0, 0, 0);
    CFMutableDictionaryRef Mutable = 0;
    if (!v20) {
      goto LABEL_38;
    }
  }
  uint64_t v29 = 0;
  if (Mutable) {
LABEL_42:
  }
    CFRelease(Mutable);
LABEL_43:
  if (v20)
  {
    CFStringRef v32 = 0;
    SecRequirementRef v33 = requirement;
  }
  else
  {
    CFStringRef v32 = CFStringCreateWithFormat(*v5, 0, @"certificate leaf = H\"%@\"", v29);
    int v20 = SecRequirementCreateWithStringAndErrors(v32, 0, &errors, &requirement);
    SecRequirementRef v33 = requirement;
    if (!v20)
    {
      SecRequirementRef requirement = 0;
      goto LABEL_46;
    }
  }
  if (v33)
  {
    CFRelease(v33);
    SecRequirementRef v33 = 0;
  }
LABEL_46:
  if (v29) {
    CFRelease(v29);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (!v18) {
    goto LABEL_52;
  }
LABEL_51:
  CFRelease(v18);
LABEL_52:
  if (errors) {
    CFRelease(errors);
  }
  if (!v20)
  {
    CFAllocatorRef v34 = *v5;
    while (1)
    {
      CFStringRef v35 = CFURLCopyPath(v12);
      int v36 = CFEqual(v35, @"/");
      if (v35) {
        CFRelease(v35);
      }
      if (v36) {
        break;
      }
      SecRequirementRef requirement = 0;
      CFErrorRef errors = 0;
      CFStringRef string = 0;
      OSStatus v37 = FigCFURLCopyCanonicalPath(v12, &string);
      if (v37)
      {
        OSStatus v38 = v37;
      }
      else
      {
        CFStringGetFileSystemRepresentation(string, (char *)cf, 1023);
        if (access((const char *)cf, 4))
        {
          OSStatus v38 = -17621;
        }
        else
        {
          OSStatus v38 = SecStaticCodeCreateWithPath(v12, 0, &errors);
          CFErrorRef v39 = errors;
          if (!v38)
          {
            OSStatus v38 = SecStaticCodeCheckValidityWithErrors(errors, 0, v33, &requirement);
            CFErrorRef v39 = errors;
          }
          if (v39) {
            CFRelease(v39);
          }
        }
      }
      if (requirement) {
        CFRelease(requirement);
      }
      if (string) {
        CFRelease(string);
      }
      if (v38)
      {
        CFURLRef v40 = v13;
      }
      else
      {
        if (v12) {
          CFRetain(v12);
        }
        CFURLRef v40 = v12;
        if (v13)
        {
          CFRelease(v13);
          CFURLRef v40 = v12;
        }
      }
      CFURLRef v41 = CFURLCreateCopyDeletingLastPathComponent(v34, v12);
      if (v12) {
        CFRelease(v12);
      }
      CFURLRef v12 = v41;
      CFURLRef v13 = v40;
      if (v38 != -67062)
      {
        CFURLRef v12 = v41;
        CFURLRef v13 = v40;
        if (v38 != -67028)
        {
          CFURLRef v12 = v41;
          CFURLRef v13 = v40;
          if (v38) {
            goto LABEL_84;
          }
        }
      }
    }
  }
  CFURLRef v41 = v12;
  CFURLRef v40 = v13;
LABEL_84:
  uint64_t v10 = 0;
  CFURLRef *v43 = v40;
  CFURLRef v12 = v41;
LABEL_85:
  if (staticCode) {
    CFRelease(staticCode);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v10;
}

uint64_t FigSecCopyOutmostBundleSignedWithSameCertificateAsCodeOfMainBundle(void *a1)
{
  if (sEstablishOutmostContainerURLOfMainBundleOnce != -1) {
    dispatch_once_f(&sEstablishOutmostContainerURLOfMainBundleOnce, 0, (dispatch_function_t)EstablishOutmostContainerURLOfMainBundle);
  }
  CFTypeRef v2 = (CFTypeRef)sOutmostContainerURLOfMainBundle;
  if (sOutmostContainerURLOfMainBundle) {
    CFTypeRef v2 = CFRetain((CFTypeRef)sOutmostContainerURLOfMainBundle);
  }
  *a1 = v2;
  return sOutmostContainerURLOfMainBundleEstablishmentResult;
}

void EstablishOutmostContainerURLOfMainBundle()
{
  MainBundle = CFBundleGetMainBundle();
  CFURLRef v1 = CFBundleCopyExecutableURL(MainBundle);
  sOutmostContainerURLOfMainBundleEstablishmentResult = FigSecCopyOutmostBundleSignedWithSameCertificateAsCodeAtURL(v1, (CFURLRef *)&sOutmostContainerURLOfMainBundle);
  if (v1)
  {
    CFRelease(v1);
  }
}

BOOL FigIsSecTaskGPUExtensionOfBrowserEngine(SecTaskRef task)
{
  if (sLoadBrowserFrameworkOnce != -1) {
    dispatch_once(&sLoadBrowserFrameworkOnce, &__block_literal_global_12);
  }
  BOOL v2 = 0;
  if (task)
  {
    if (s_SEBrowserEngineEntitlementGPU)
    {
      CFTypeRef v3 = SecTaskCopyValueForEntitlement(task, (CFStringRef)s_SEBrowserEngineEntitlementGPU, 0);
      BOOL v2 = v3 == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
      if (v3) {
        CFRelease(v3);
      }
    }
  }
  return v2;
}

uint64_t *__loadBrowserEngineFramework_block_invoke()
{
  uint64_t result = (uint64_t *)dlopen("/System/Library/Frameworks/BrowserEngineCore.framework/BrowserEngineCore", 4);
  if (result)
  {
    uint64_t result = (uint64_t *)dlsym(result, "_BEBrowserEngineEntitlementRendering");
    s_SEBrowserEngineEntitlementGPU = *result;
  }
  return result;
}

uint64_t CMByteStreamGetClassID()
{
  return sFigByteStreamClassID;
}

uint64_t CMByteStreamBaseGetTypeID()
{
  FigThreadRunOnce(&CMByteStreamGetClassID_sRegisterFigByteStreamBaseTypeOnce, (void (*)(void))RegisterFigByteStreamBaseType);
  uint64_t v0 = (void *)sFigByteStreamClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t CMCreateContiguousBlockBufferFromStream(uint64_t a1, CFAllocatorRef allocator, size_t size, uint64_t a4, CMBlockBufferRef *a5, size_t *a6)
{
  dataunint64_t Length = 0;
  CMBlockBufferRef blockBufferOut = 0;
  if (!size)
  {
LABEL_14:
    uint64_t v18 = 0;
    goto LABEL_15;
  }
  CFURLRef v12 = CFAllocatorAllocate(allocator, size, 0);
  if (v12)
  {
    CFURLRef v13 = v12;
    uint64_t v14 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
    if (v14) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = 0;
    }
    CFArrayRef v16 = *(uint64_t (**)(uint64_t, size_t, uint64_t, void *, size_t *))(v15 + 8);
    if (!v16)
    {
      uint64_t v18 = 4294954514;
      goto LABEL_12;
    }
    uint64_t v17 = v16(a1, size, a4, v13, &dataLength);
    if (v17)
    {
LABEL_10:
      uint64_t v18 = v17;
LABEL_12:
      CFAllocatorDeallocate(allocator, v13);
      goto LABEL_15;
    }
    if (dataLength)
    {
      uint64_t v17 = CMBlockBufferCreateWithMemoryBlock(allocator, v13, size, allocator, 0, 0, dataLength, 0, &blockBufferOut);
      uint64_t v18 = 0;
      if (!v17) {
        goto LABEL_15;
      }
      goto LABEL_10;
    }
    CFAllocatorDeallocate(allocator, v13);
    goto LABEL_14;
  }
  uint64_t v18 = FigSignalErrorAt(4294967188, 0, 0, 0, 0, 0, 0);
LABEL_15:
  *a5 = blockBufferOut;
  if (a6) {
    *a6 = dataLength;
  }
  return v18;
}

uint64_t CMByteStreamWriteBlockBuffer()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  CFAllocatorRef v6 = v5;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (v3)
  {
    uint64_t v7 = v4;
    unint64_t v8 = v3;
    uint64_t v9 = v2;
    uint64_t v10 = v1;
    uint64_t v11 = v0;
    unint64_t v12 = 0;
    uint64_t v21 = 0;
    size_t lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    while (1)
    {
      uint64_t result = CMBlockBufferGetDataPointer(v10, v12 + v9, &lengthAtOffsetOut, 0, &dataPointerOut);
      if (result) {
        break;
      }
      size_t v14 = lengthAtOffsetOut;
      if (lengthAtOffsetOut >= v8 - v12)
      {
        size_t lengthAtOffsetOut = v8 - v12;
        size_t v14 = v8 - v12;
      }
      else if (!(lengthAtOffsetOut >> 14))
      {
        if (v8 - v12 >= 0x4000) {
          size_t v15 = 0x4000;
        }
        else {
          size_t v15 = v8 - v12;
        }
        size_t lengthAtOffsetOut = v15;
        uint64_t result = CMBlockBufferCopyDataBytes(v10, v12 + v9, v15, destination);
        if (result) {
          break;
        }
        dataPointerOut = destination;
        size_t v14 = lengthAtOffsetOut;
      }
      CFArrayRef v16 = dataPointerOut;
      uint64_t v17 = *(void *)(CMBaseObjectGetVTable(v11) + 16);
      if (v17) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = 0;
      }
      CFTypeID v19 = *(uint64_t (**)(uint64_t, size_t, unint64_t, char *, uint64_t *))(v18 + 16);
      if (!v19)
      {
        uint64_t result = 4294954514;
        if (v6) {
          goto LABEL_25;
        }
        return result;
      }
      uint64_t result = v19(v11, v14, v12 + v7, v16, &v21);
      if (result) {
        break;
      }
      if (!v21)
      {
        uint64_t result = FigSignalErrorAt(4294954423, 0, 0, 0, 0, 0, 0);
        if (v6) {
          goto LABEL_25;
        }
        return result;
      }
      v12 += v21;
      if (v12 >= v8) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
LABEL_23:
    uint64_t result = 0;
  }
  if (v6) {
LABEL_25:
  }
    *CFAllocatorRef v6 = v12;
  return result;
}

uint64_t CMByteStreamAppend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v9 + 24);
  if (!v10) {
    return 4294954514;
  }
  uint64_t v16 = 0;
  uint64_t result = v10(a1, 0, &v16);
  if (result) {
    return result;
  }
  uint64_t v12 = v16;
  uint64_t v13 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  uint64_t v14 = v13 ? v13 : 0;
  size_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 16);
  if (v15) {
    return v15(a1, a2, v12, a3, a4);
  }
  else {
    return 4294954514;
  }
}

uint64_t CMByteStreamAppendBlockBuffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, void, uint64_t *))(v3 + 24);
  if (!v4) {
    return 4294954514;
  }
  uint64_t v6 = 0;
  uint64_t result = v4(a1, 0, &v6);
  if (!result) {
    return CMByteStreamWriteBlockBuffer();
  }
  return result;
}

pthread_mutex_t *FigByteStreamStatsSetupWorker(pthread_mutex_t *result)
{
  if (result)
  {
    p_sig = &result->__sig;
    *(_OWORD *)&result->__opaque[24] = 0u;
    *(_OWORD *)&result->__opaque[40] = 0u;
    *(_OWORD *)&result->__sig = 0u;
    *(_OWORD *)&result->__opaque[8] = 0u;
    uint64_t result = FigSimpleMutexCreate();
    void *p_sig = result;
  }
  return result;
}

double FigByteStreamStatsTeardownWorker(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)a1;
    if (v2) {
      FigSimpleMutexDestroy(v2);
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

pthread_mutex_t *FigByteStreamStatsLogOneRead(pthread_mutex_t *result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6)
{
  if (result)
  {
    uint64_t v7 = result;
    double result = (pthread_mutex_t *)result->__sig;
    BOOL v8 = result && a4 == 0;
    if (v8 && a6 != 0)
    {
      uint64_t v10 = a3 - a2;
      uint64_t v11 = (unsigned __int128)((a3 - a2) * (__int128)0x20C49BA5E353F7CFLL) >> 64;
      FigSimpleMutexLock(result);
      ++*(_DWORD *)v7->__opaque;
      *(void *)&v7->__opaque[8] += a6;
      unint64_t v12 = *(int *)&v7->__opaque[16];
      if (!v12 || v12 > a6) {
        *(_DWORD *)&v7->__opaque[16] = a6;
      }
      uint64_t v13 = (v11 >> 7) + ((unint64_t)v11 >> 63);
      if (*(int *)&v7->__opaque[20] < a6) {
        *(_DWORD *)&v7->__opaque[20] = a6;
      }
      uint64_t v14 = *(void *)&v7->__opaque[32];
      *(void *)&v7->__opaque[24] += v13;
      if (v13 < v14 || v14 == 0) {
        *(void *)&v7->__opaque[32] = v13;
      }
      if (v13 > *(void *)&v7->__opaque[40]) {
        *(void *)&v7->__opaque[40] = v13;
      }
      if (v10 < 1000000000)
      {
        if (v10 >= 500000000) {
          ++*(_DWORD *)&v7->__opaque[52];
        }
      }
      else
      {
        ++*(_DWORD *)&v7->__opaque[48];
      }
      sig = (pthread_mutex_t *)v7->__sig;
      return (pthread_mutex_t *)FigSimpleMutexUnlock(sig);
    }
  }
  return result;
}

CFDictionaryRef FigByteStreamStatsCreateStatsDictionary(const __CFAllocator *a1, const void *a2, CFURLRef anURL, uint64_t a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  long long v30 = xmmword_1E56780A0;
  long long v31 = *(_OWORD *)off_1E56780B0;
  CFStringRef v32 = @"ByteStreamType";
  *(_OWORD *)keys = xmmword_1E5678060;
  long long v27 = *(_OWORD *)&off_1E5678070;
  long long v28 = xmmword_1E5678080;
  long long v29 = *(_OWORD *)&off_1E5678090;
  CFTypeRef v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  *(_OWORD *)values = 0u;
  long long v20 = 0u;
  int valuePtr = 0;
  double v17 = 0.0;
  if (a4 && (uint64_t v6 = *(pthread_mutex_t **)a4) != 0)
  {
    if (anURL)
    {
      CFStringRef v8 = CFURLGetString(anURL);
      uint64_t v6 = *(pthread_mutex_t **)a4;
    }
    else
    {
      CFStringRef v8 = 0;
    }
    FigSimpleMutexLock(v6);
    uint64_t v9 = *(int *)(a4 + 8);
    if (v9)
    {
      int valuePtr = *(void *)(a4 + 16) / v9;
      double v10 = (double)(*(void *)(a4 + 32) / v9);
    }
    else
    {
      double v10 = 0.0;
    }
    if (v8) {
      uint64_t v11 = (__CFString *)v8;
    }
    else {
      uint64_t v11 = @"UNKNOWN";
    }
    values[0] = (void *)CFRetain(v11);
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    values[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)(a4 + 8));
    *(void *)&long long v20 = CFNumberCreate(v12, kCFNumberSInt64Type, (const void *)(a4 + 16));
    *((void *)&v20 + 1) = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 24));
    *(void *)&long long v21 = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 28));
    *((void *)&v21 + 1) = CFNumberCreate(v12, kCFNumberSInt32Type, &valuePtr);
    double v17 = (double)*(uint64_t *)(a4 + 32) / 1000000.0;
    *(void *)&long long v22 = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    double v17 = (double)*(uint64_t *)(a4 + 40) / 1000000.0;
    *((void *)&v22 + 1) = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    double v17 = (double)*(uint64_t *)(a4 + 48) / 1000000.0;
    *(void *)&long long v23 = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    double v17 = v10 / 1000000.0;
    *((void *)&v23 + 1) = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    *(void *)&long long v24 = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 56));
    *((void *)&v24 + 1) = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 60));
    CFTypeRef v25 = CFRetain(a2);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a4);
    CFDictionaryRef v13 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 13, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v13 = 0;
  }
  for (uint64_t i = 0; i != 13; ++i)
  {
    size_t v15 = values[i];
    if (v15) {
      CFRelease(v15);
    }
  }
  return v13;
}

uint64_t FigByteStreamCopySHA1Digest(uint64_t a1, CFDataRef *a2)
{
  number[3] = *(CFNumberRef *)MEMORY[0x1E4F143B8];
  char v23 = 0;
  uint64_t valuePtr = 0;
  uint64_t v22 = 0;
  if (!a2)
  {
    unsigned int v8 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    double v10 = 0;
    uint64_t v4 = 0;
    goto LABEL_30;
  }
  *a2 = 0;
  uint64_t v4 = malloc_type_malloc(0x10000uLL, 0xCEF03D8EuLL);
  if (!v4)
  {
    unsigned int v8 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_39:
    double v10 = 0;
    goto LABEL_30;
  }
  number[0] = 0;
  uint64_t v5 = *(void *)(CMBaseObjectGetVTable(a1) + 8);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, __CFString *, void, CFNumberRef *))(v6 + 48);
  if (!v7)
  {
    double v10 = 0;
LABEL_29:
    unsigned int v8 = -12782;
    goto LABEL_30;
  }
  unsigned int v8 = v7(a1, @"FBS_EntireLength", 0, number);
  CFNumberRef v9 = number[0];
  if (!v8)
  {
    CFNumberGetValue(number[0], kCFNumberSInt64Type, &valuePtr);
    CFNumberRef v9 = number[0];
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    goto LABEL_39;
  }
  double v10 = FigDigestSHA1Create();
  FigThreadRegisterAbortAction((uint64_t (*)())figByteStreamDigestAbortAction, (_opaque_pthread_t *)&v23, &v22);
  BOOL v11 = v23 == 0;
  uint64_t v12 = valuePtr;
  BOOL v13 = valuePtr > 0;
  if (!v23 && valuePtr >= 1)
  {
    uint64_t v14 = 0;
    do
    {
      number[0] = 0;
      uint64_t v15 = (unint64_t)(v12 - v14) >= 0x10000 ? 0x10000 : v12 - v14;
      uint64_t v16 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
      uint64_t v17 = v16 ? v16 : 0;
      uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *, CFNumberRef *))(v17 + 8);
      if (!v18) {
        goto LABEL_29;
      }
      unsigned int v19 = v18(a1, v15, v14, v4, number);
      if (v19)
      {
        unsigned int v8 = v19;
        goto LABEL_30;
      }
      FigDigestSHA1AppendData(v10, v4, (CC_LONG)number[0]);
      v14 += (uint64_t)number[0];
      BOOL v11 = v23 == 0;
      uint64_t v12 = valuePtr;
      BOOL v13 = v14 < valuePtr;
    }
    while (!v23 && v14 < valuePtr);
  }
  unsigned int v8 = 0;
  if (v11 && !v13)
  {
    FigDigestSHA1GetDigest(v10, (unsigned __int8 *)number);
    unsigned int v8 = 0;
    *a2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)number, 20);
  }
LABEL_30:
  if (v22) {
    FigThreadUnregisterAbortAction(v22);
  }
  if (v10) {
    FigDigestSHA1Destroy(v10);
  }
  free(v4);
  if (v23) {
    return 4294954425;
  }
  else {
    return v8;
  }
}

unsigned char *figByteStreamDigestAbortAction(unsigned char *result)
{
  *double result = 1;
  return result;
}

CFStringRef FigByteStreamBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigByteStream %p]", a1);
}

uint64_t frb_FigRingBufferOutOfBounds(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a3) {
    BOOL v4 = a1 <= a3;
  }
  else {
    BOOL v4 = 1;
  }
  unsigned int v5 = !v4;
  if (a4) {
    BOOL v6 = a2 > a4;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return 1;
  }
  else {
    return v5;
  }
}

size_t frb_FigCFRingBufferGetSize(__CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    return CFStringGetLength(a1);
  }
  CFTypeID v4 = CFNumberGetTypeID();
  if (v4 == CFGetTypeID(a1))
  {
    return CFNumberGetByteSize((CFNumberRef)a1);
  }
  CFTypeID v5 = CFDataGetTypeID();
  if (v5 == CFGetTypeID(a1))
  {
    return CFDataGetLength((CFDataRef)a1);
  }
  CFTypeID v6 = CMBlockBufferGetTypeID();
  if (v6 != CFGetTypeID(a1)) {
    return 0;
  }

  return CMBlockBufferGetDataLength((CMBlockBufferRef)a1);
}

size_t frb_FigCStrRingBufferGetSize(const char *a1)
{
  return strlen(a1) + 1;
}

void *FigRingBufferCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t (**a4)())
{
  if (a4) {
    CFTypeID v6 = a4;
  }
  else {
    CFTypeID v6 = kFigTypeCFRingBufferCallBacks;
  }
  if (v6[2]) {
    uint64_t v7 = (const CFArrayCallBacks *)v6[2];
  }
  else {
    uint64_t v7 = 0;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, v7);
  if (Mutable)
  {
    CFMutableArrayRef v9 = Mutable;
    double v10 = malloc_type_calloc(1uLL, 0x40uLL, 0x1060040C52B20C0uLL);
    if (v10)
    {
      *double v10 = CFRetain(v9);
      v10[1] = v6;
      int v10[2] = 0;
      v10[3] = a3;
      void v10[4] = 0;
      v10[5] = a2;
      v10[6] = 0;
      void v10[7] = 0;
    }
    CFRelease(v9);
  }
  else
  {
    syslog(3, "Failed to allocate CFArray for ring buffer");
    return 0;
  }
  return v10;
}

uint64_t FigRingBufferAppendValueAndEvictBuffer(uint64_t a1, const void *a2, __CFArray *a3)
{
  if (!a1) {
    return 4294950815;
  }
  if (!*(void *)(a1 + 8)) {
    return 4294950813;
  }
  if (!a2) {
    return 4294950814;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)a1);
  uint64_t v7 = (*(uint64_t (**)(const void *))(*(void *)(a1 + 8) + 8))(a2);
  if (!Count)
  {
    CFIndex v18 = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    goto LABEL_36;
  }
  if (!(**(unsigned int (***)(uint64_t, uint64_t, void, void))(a1 + 8))(Count + 1, *(void *)(a1 + 16) + v7, *(void *)(a1 + 40), *(void *)(a1 + 24)))
  {
LABEL_34:
    CFIndex v18 = *(void *)(a1 + 32);
    goto LABEL_36;
  }
  char v8 = 0;
  do
  {
    if (Count < 1) {
      return 4294950816;
    }
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9 == *(void *)(a1 + 48))
    {
      if (a3 && !v8)
      {
LABEL_24:
        while (v9 < CFArrayGetCount(*(CFArrayRef *)a1))
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v9);
          CFArrayAppendValue(a3, ValueAtIndex);
          ++v9;
        }
        uint64_t v9 = *(void *)(a1 + 32);
        if (v9 >= 1)
        {
          for (CFIndex i = 0; i < v9; ++i)
          {
            uint64_t v14 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, i);
            CFArrayAppendValue(a3, v14);
            uint64_t v9 = *(void *)(a1 + 32);
          }
        }
      }
      char v8 = 1;
      goto LABEL_29;
    }
    if (v8) {
      BOOL v10 = 0;
    }
    else {
      BOOL v10 = (unint64_t)(*(void *)(a1 + 56) + v7) > *(void *)(a1 + 24);
    }
    int v11 = !v10;
    if (!v11) {
      char v8 = 1;
    }
    if ((v11 & 1) == 0 && a3) {
      goto LABEL_24;
    }
LABEL_29:
    if (v9 >= Count)
    {
      uint64_t v9 = 0;
      *(void *)(a1 + 32) = 0;
    }
    uint64_t v15 = *(uint64_t (**)(const void *))(*(void *)(a1 + 8) + 8);
    uint64_t v16 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v9);
    *(void *)(a1 + 16) -= v15(v16);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)a1, *(void *)(a1 + 32));
  }
  while ((**(unsigned int (***)(CFIndex, uint64_t, void, void))(a1 + 8))(Count--, *(void *)(a1 + 16) + v7, *(void *)(a1 + 40), *(void *)(a1 + 24)));
  if (!v8) {
    goto LABEL_34;
  }
  CFIndex v18 = *(void *)(a1 + 32);
  *(void *)(a1 + 48) = v18;
  *(void *)(a1 + 56) = 0;
LABEL_36:
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)a1, v18, a2);
  uint64_t result = 0;
  ++*(void *)(a1 + 32);
  *(void *)(a1 + 16) += v7;
  *(void *)(a1 + 56) += v7;
  return result;
}

void FigRingBufferFlush(uint64_t a1, __CFArray *a2)
{
  if (a1)
  {
    if (a2)
    {
      for (CFIndex i = *(void *)(a1 + 32); i < CFArrayGetCount(*(CFArrayRef *)a1); ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, i);
        CFArrayAppendValue(a2, ValueAtIndex);
      }
      if (*(uint64_t *)(a1 + 32) >= 1)
      {
        CFIndex v6 = 0;
        do
        {
          uint64_t v7 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v6);
          CFArrayAppendValue(a2, v7);
          ++v6;
        }
        while (v6 < *(void *)(a1 + 32));
      }
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)a1);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
  }
}

void FigRingBufferRelease(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(__CFArray **)a1;
    if (v2)
    {
      CFArrayRemoveAllValues(v2);
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = 0;
      if (*(void *)a1) {
        CFRelease(*(CFTypeRef *)a1);
      }
      free((void *)a1);
    }
  }
}

CFIndex FigRingBufferGetCount(const __CFArray **a1)
{
  if (a1 && (CFArrayRef v1 = *a1) != 0) {
    return CFArrayGetCount(v1);
  }
  else {
    return 0;
  }
}

uint64_t FigRingBufferGetSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

void FigRingBufferGetEntries(uint64_t a1, __CFArray *a2)
{
  if (a1)
  {
    if (a2)
    {
      for (CFIndex i = *(void *)(a1 + 32); i < CFArrayGetCount(*(CFArrayRef *)a1); ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, i);
        CFArrayAppendValue(a2, ValueAtIndex);
      }
      if (*(uint64_t *)(a1 + 32) >= 1)
      {
        CFIndex v6 = 0;
        do
        {
          uint64_t v7 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v6);
          CFArrayAppendValue(a2, v7);
          ++v6;
        }
        while (v6 < *(void *)(a1 + 32));
      }
    }
  }
}

uint64_t CMByteStreamCreateForFileURL(uint64_t a1, const void *a2, unsigned int a3, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  ClassID = (void *)CMByteStreamGetClassID();
  uint64_t v9 = CMDerivedObjectCreate(a1, (uint64_t)&kFigFileByteStreamVTable, ClassID, &cf);
  if (v9) {
    return v9;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  CFURLRef v11 = (const __CFURL *)CFRetain(a2);
  *(void *)uint64_t DerivedStorage = v11;
  *(_DWORD *)(DerivedStorage + 4216) = -1;
  *(unsigned char *)(DerivedStorage + 422CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
  *(_DWORD *)(DerivedStorage + 16) = a3;
  uint64_t v12 = FigFileForkOpenMainByCFURL(v11, a3, (int **)(DerivedStorage + 8));
  if (v12)
  {
    uint64_t Buffer = v12;
LABEL_9:
    CFRelease(cf);
    return Buffer;
  }
  FigByteStreamStatsSetupWorker((pthread_mutex_t *)(DerivedStorage + 4152));
  uint64_t Buffer = fbs_SetupSmallReadBuffer(DerivedStorage + 24, a3);
  if (Buffer)
  {
    FigFileForkClose(*(int **)(DerivedStorage + 8));
    goto LABEL_9;
  }
  *a4 = cf;
  return Buffer;
}

uint64_t fbs_SetupSmallReadBuffer(uint64_t a1, __int16 a2)
{
  if ((a2 & 0x133) != 0) {
    return 0;
  }
  uint64_t v3 = FigSimpleMutexCreate();
  *(void *)(a1 + 4112) = v3;
  if (v3)
  {
    *(unsigned char *)(a1 + 412CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
    return 0;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigByteStreamCreateFromOpenFileWithFlags(unsigned int *a1, uint64_t a2, char a3, CFTypeRef *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  ClassID = (void *)CMByteStreamGetClassID();
  uint64_t v9 = CMDerivedObjectCreate(a2, (uint64_t)&kFigFileByteStreamVTable, ClassID, &cf);
  if (v9)
  {
LABEL_9:
    uint64_t v13 = v9;
    goto LABEL_11;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  *(void *)(DerivedStorage + 8) = a1;
  FigByteStreamStatsSetupWorker((pthread_mutex_t *)(DerivedStorage + 4152));
  *(void *)uint64_t DerivedStorage = 0;
  *(unsigned char *)(DerivedStorage + 422CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  *(_DWORD *)(DerivedStorage + 4216) = -1;
  if ((a3 & 2) == 0 {
    || (bzero(buffer, 0x400uLL),
  }
        *(unsigned char *)(DerivedStorage + 422CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1,
        int DarwinFileDesc = FigFileGetDarwinFileDesc(a1),
        fcntl(DarwinFileDesc, 50, buffer) != -1)
    && (CFURLRef v12 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], buffer, 1024, 0),
        (*(void *)uint64_t DerivedStorage = v12) != 0))
  {
    if ((a3 & 1) == 0 || (uint64_t v9 = fbs_SetupSmallReadBuffer(DerivedStorage + 24, 0), !v9))
    {
      uint64_t v13 = 0;
      *a4 = cf;
      return v13;
    }
    goto LABEL_9;
  }
  uint64_t v13 = 4294954422;
LABEL_11:
  if (cf) {
    CFRelease(cf);
  }
  return v13;
}

uint64_t FigByteStreamCreateFromOpenFileAssumingOwnership(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 2, a3);
}

uint64_t FigByteStreamCreateFromReadOnlyOpenFile(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 1, a3);
}

uint64_t FigByteStreamCreateFromReadOnlyOpenFileAssumingOwnership(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 3, a3);
}

uint64_t FigByteStreamCreateForFileURL(const void *a1, unsigned int a2, uint64_t a3, CFTypeRef *a4)
{
  return CMByteStreamCreateForFileURL(a3, a1, a2, a4);
}

uint64_t FigFileByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage(a1);
  CFTypeID v4 = *(const void **)CMBaseObjectGetDerivedStorage(a2);
  CFTypeID v5 = *DerivedStorage;

  return FigCFEqual(v5, v4);
}

__CFString *FigFileByteStreamCopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringRef v3 = CFCopyDescription(*DerivedStorage);
  if (v3)
  {
    CFStringRef v4 = v3;
    CFStringAppendFormat(Mutable, 0, @"<FigFileByteStream %p>{%@}", DerivedStorage, v3);
    CFRelease(v4);
  }
  return Mutable;
}

uint64_t FigFileByteStreamSetProperty(uint64_t a1, const void *a2, const __CFNumber *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!CFEqual(a2, @"FBS_IOPolicy")) {
    return 4294954512;
  }
  if (a3 && (CFTypeID TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(a3)))
  {
    CFNumberGetValue(a3, kCFNumberIntType, (void *)(DerivedStorage + 4216));
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigFileByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, uint64_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  CFAllocatorRef v10 = CFGetAllocator(a1);

  return CMCreateContiguousBlockBufferFromStream((uint64_t)a1, v10, a2, a3, a4, a5);
}

uint64_t FigFileByteStreamSynchronize(uint64_t a1, char a2)
{
  CFStringRef v3 = *(int **)(CMBaseObjectGetDerivedStorage(a1) + 8);

  return FigFileForkSynchronize(v3, a2 & 1);
}

uint64_t FigFileByteStreamPreallocateStorageSpace(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  uint64_t v7 = *(int **)(CMBaseObjectGetDerivedStorage(a1) + 8);

  return FigFileForkPreallocateStorageSpace(v7, a2, a3 & 2, a4);
}

uint64_t FigFileByteStreamWriteBlockBufferOptimized(uint64_t a1, OpaqueCMBlockBuffer *a2, size_t a3, size_t a4, off_t a5, void *a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v31 = 0;
  size_t lengthAtOffsetOut = 0;
  if (a4)
  {
    size_t v10 = 0;
    uint64_t v11 = 0;
    size_t v12 = a4;
    size_t v13 = a3;
    do
    {
      if (v11 == 0x7FFFFFFF)
      {
        uint64_t v27 = 4294954422;
        goto LABEL_25;
      }
      unsigned int DataPointer = CMBlockBufferGetDataPointer(a2, v13, &lengthAtOffsetOut, 0, 0);
      if (DataPointer) {
        goto LABEL_26;
      }
      size_t v15 = lengthAtOffsetOut;
      if (v12 < lengthAtOffsetOut) {
        size_t v15 = v12;
      }
      v13 += v15;
      ++v11;
      v10 += 16;
      v12 -= v15;
    }
    while (v12);
    uint64_t v16 = (size_t *)malloc_type_malloc(v10, 0xD1AAB5CuLL);
    if (!v16) {
      goto LABEL_29;
    }
    uint64_t v17 = v16;
    uint64_t v18 = v11 + 1;
    unsigned int v19 = v16 + 1;
    size_t v20 = a4;
    while (1)
    {
      dataPointerOut = 0;
      if (!--v18) {
        break;
      }
      unsigned int v21 = CMBlockBufferGetDataPointer(a2, a3, &lengthAtOffsetOut, 0, &dataPointerOut);
      if (v21) {
        goto LABEL_28;
      }
      size_t v22 = lengthAtOffsetOut;
      if (v20 < lengthAtOffsetOut) {
        size_t v22 = v20;
      }
      *(v19 - 1) = (size_t)dataPointerOut;
      *unsigned int v19 = v22;
      v19 += 2;
      a3 += v22;
      v20 -= v22;
      if (!v20) {
        goto LABEL_18;
      }
    }
    unsigned int v21 = FigSignalErrorAt(4294954422, 0, 0, 0, 0, 0, 0);
LABEL_28:
    unsigned int v25 = v21;
  }
  else
  {
    char v23 = (size_t *)malloc_type_malloc(0, 0x2CFEBD2BuLL);
    if (v23)
    {
      uint64_t v17 = v23;
      LODWORD(v11) = 0;
LABEL_18:
      unsigned int v24 = FigFileForkWriteIOVecArray(*(int **)(DerivedStorage + 8), *(_DWORD *)(DerivedStorage + 4216), (uint64_t)v17, v11, a5, &v31);
      unsigned int v25 = v24;
      if (a6 && !v24) {
        *a6 = v31;
      }
    }
    else
    {
LABEL_29:
      uint64_t v27 = 4294954420;
LABEL_25:
      unsigned int DataPointer = FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
LABEL_26:
      unsigned int v25 = DataPointer;
      uint64_t v17 = 0;
    }
  }
  free(v17);
  if (v31 == a4) {
    return 0;
  }
  else {
    return v25;
  }
}

uint64_t plugin_CreateStandardPluginObjectInternal(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0;
  ClassID = (void *)FigHALAudioPluginGetClassID();
  uint64_t v13 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigHALAudioPluginVTable, ClassID, &cf);
  if (v13) {
    goto LABEL_11;
  }
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
  DerivedStorage[1] = a2;
  DerivedStorage[4] = a4;
  DerivedStorage[5] = a5;
  size_t v15 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  DerivedStorage[3] = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  DerivedStorage[2] = dispatch_queue_create("FigHALStandardPluginDeviceManagementQueue", 0);
  DerivedStorage[9] = CFArrayCreateMutable(a1, 0, v15);
  DerivedStorage[10] = CFArrayCreateMutable(a1, 0, v15);
  dispatch_queue_t v16 = dispatch_queue_create("FigHALStandardPluginEndpointManagementQueue", 0);
  DerivedStorage[6] = v16;
  DerivedStorage[7] = a3;
  if (!DerivedStorage[3] || !DerivedStorage[2] || !DerivedStorage[9] || !DerivedStorage[10] || !v16)
  {
    uint64_t v13 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_11:
    uint64_t v17 = v13;
    goto LABEL_12;
  }
  uint64_t v17 = FigHALAudioObjectMapperAddPluginObjectMapping(a2, (uint64_t)cf);
  if (!v17)
  {
    *a6 = cf;
    return v17;
  }
LABEL_12:
  if (cf) {
    CFRelease(cf);
  }
  return v17;
}

uint64_t FigHALAudioCreateStandardPluginObject(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  return plugin_CreateStandardPluginObjectInternal(a1, a2, a3, a4, 0, a5);
}

void plugin_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v2 = (const void *)DerivedStorage[3];
  if (v2)
  {
    CFRelease(v2);
    DerivedStorage[3] = 0;
  }
  CFStringRef v3 = DerivedStorage[2];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[2] = 0;
  }
  CFStringRef v4 = (const void *)DerivedStorage[9];
  if (v4)
  {
    CFRelease(v4);
    DerivedStorage[9] = 0;
  }
  CFTypeID v5 = (const void *)DerivedStorage[10];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[10] = 0;
  }
  CFIndex v6 = DerivedStorage[6];
  if (v6)
  {
    dispatch_release(v6);
    DerivedStorage[6] = 0;
  }
  uint64_t v7 = (const void *)DerivedStorage[8];
  if (v7)
  {
    CFRelease(v7);
    DerivedStorage[8] = 0;
  }
}

CFStringRef plugin_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v15 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  uint64_t v2 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __plugin_CopyDebugDescription_block_invoke;
  block[3] = &unk_1E56780D0;
  void block[4] = &v16;
  void block[5] = DerivedStorage;
  dispatch_sync(v2, block);
  CFStringRef v3 = *(NSObject **)(DerivedStorage + 48);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  int v6[2] = __plugin_CopyDebugDescription_block_invoke_2;
  v6[3] = &unk_1E56780F8;
  void v6[5] = &v8;
  v6[6] = DerivedStorage;
  v6[4] = &v12;
  dispatch_sync(v3, v6);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"FigHALStandardPlugin: %ld devices %ld activated endpoints %ld audio streams", v17[3], v13[3], v9[3]);
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  return v4;
}

uint64_t plugin_GetObjectID()
{
  return 1;
}

uint64_t plugin_HasProperty(uint64_t a1, int *a2)
{
  int v2 = *a2;
  uint64_t result = 1;
  if (*a2 <= 1819107690)
  {
    BOOL v4 = v2 == 1668047219;
    int v5 = 1684370979;
  }
  else
  {
    BOOL v4 = v2 == 1819107691 || v2 == 1870098020;
    int v5 = 1969841252;
  }
  if (!v4 && v2 != v5) {
    return 0;
  }
  return result;
}

uint64_t plugin_IsPropertySettable()
{
  return 0;
}

uint64_t plugin_GetPropertyDataSize(uint64_t a1, int *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  int v4 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v4 == 1668047219) {
      return 4;
    }
    if (v4 != 1684370979) {
      return 0;
    }
LABEL_9:
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000;
    uint64_t v12 = 0;
    CFIndex v6 = *(NSObject **)(DerivedStorage + 16);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    int v8[2] = __plugin_GetPropertyDataSize_block_invoke;
    _OWORD v8[3] = &unk_1E5678120;
    void v8[4] = &v9;
    v8[5] = DerivedStorage;
    dispatch_sync(v6, v8);
    uint64_t v5 = (4 * *((_DWORD *)v10 + 6));
    _Block_object_dispose(&v9, 8);
    return v5;
  }
  switch(v4)
  {
    case 1819107691:
      return 8;
    case 1870098020:
      goto LABEL_9;
    case 1969841252:
      return 4;
    default:
      return 0;
  }
}

uint64_t plugin_GetPropertyData(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v14 = 0;
  int v15 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v15 != 1668047219)
    {
      if (v15 != 1684370979) {
        return v14;
      }
LABEL_11:
      uint64_t v22 = 0;
      char v23 = &v22;
      uint64_t v24 = 0x2000000000;
      uint64_t v25 = 0;
      uint64_t v17 = *(NSObject **)(DerivedStorage + 16);
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 0x40000000;
      void v20[2] = __plugin_GetPropertyData_block_invoke;
      v20[3] = &unk_1E5678148;
      unsigned int v21 = a5;
      v20[4] = &v22;
      v20[5] = DerivedStorage;
      v20[6] = a7;
      dispatch_sync(v17, v20);
      *a6 = 4 * *((_DWORD *)v23 + 6);
      _Block_object_dispose(&v22, 8);
      return 0;
    }
    *a6 = 4;
    if (a5 >= 4)
    {
      uint64_t v14 = 0;
      *a7 = 1634757735;
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1819107691)
  {
    *a6 = 8;
    if (a5 >= 8)
    {
      uint64_t v14 = 0;
      *(void *)a7 = @"Apple Inc.";
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1870098020) {
    goto LABEL_11;
  }
  if (v15 != 1969841252) {
    return v14;
  }
  if (a5 > 3 && a3 == 8 && a4)
  {
    uint64_t v16 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __plugin_GetPropertyData_block_invoke_2;
    block[3] = &__block_descriptor_tmp_10_0;
    void block[4] = DerivedStorage;
    void block[5] = a4;
    void block[6] = a7;
    dispatch_sync(v16, block);
    uint64_t v14 = 0;
    *a6 = 4;
    return v14;
  }

  return FigSignalErrorAt(561211770, 0, 0, 0, 0, 0, 0);
}

uint64_t plugin_SetPropertyData()
{
  return 2003332927;
}

uint64_t plugin_Initialize(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  int v16 = 0;
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(a1);
  *uint64_t DerivedStorage = a2;
  uint64_t v5 = (void (*)(void, void, uint64_t, CFTypeRef *))DerivedStorage[5];
  if (v5)
  {
    CFTypeRef v12 = 0;
    v5(*MEMORY[0x1E4F1CF80], DerivedStorage[1], a2, &v12);
    if (v12)
    {
      CFIndex v6 = DerivedStorage[2];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __plugin_Initialize_block_invoke;
      block[3] = &__block_descriptor_tmp_11;
      void block[4] = DerivedStorage;
      void block[5] = v12;
      dispatch_sync(v6, block);
      CFRelease(v12);
    }
  }
  uint64_t v7 = DerivedStorage[6];
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  int v10[2] = __plugin_Initialize_block_invoke_2;
  v10[3] = &unk_1E56781B0;
  void v10[4] = &v13;
  v10[5] = a1;
  dispatch_sync(v7, v10);
  uint64_t v8 = *((unsigned int *)v14 + 6);
  _Block_object_dispose(&v13, 8);
  return v8;
}

void ActivatedEndpointsChangedNotificationCallback(uint64_t a1, uint64_t a2)
{
  CFStringRef v3 = *(NSObject **)(CMBaseObjectGetDerivedStorage(a2) + 48);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __ActivatedEndpointsChangedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_13_1;
  void block[4] = a2;
  dispatch_async(v3, block);
}

uint64_t PeruseActivatedEndpoints(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFTypeRef cf = 0;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v4 = FigEndpointManagerCopyActivatedEndpoints(*(void *)(DerivedStorage + 64), (const __CFAllocator *)*MEMORY[0x1E4F1CF80], (__CFArray **)&cf);
  if (v4) {
    goto LABEL_22;
  }
  CFMutableArrayRef MutableCopy = FigCFArrayCreateMutableCopy(v3, (CFArrayRef)cf);
  if (!MutableCopy)
  {
    uint64_t v4 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_22:
    uint64_t v24 = v4;
    goto LABEL_18;
  }
  CFArrayRef v6 = MutableCopy;
  CFArrayRef v7 = *(const __CFArray **)(DerivedStorage + 72);
  if (v7)
  {
    CFIndex Count = CFArrayGetCount(v7);
    if (Count >= 1)
    {
      CFIndex v9 = Count;
      CFIndex v10 = 0;
      do
      {
        CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 72), v10);
        v27.CFIndex length = CFArrayGetCount(v6);
        v27.CFIndex location = 0;
        FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v6, v27, ValueAtIndex);
        if (FirstIndexOfValue == -1)
        {
          CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterRemoveListener(DefaultLocalCenter, a1, (int)EndpointStreamsChangedNotificationCallback, @"Endpoint_StreamsChanged", ValueAtIndex);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(DerivedStorage + 72), v10);
          --v9;
        }
        else
        {
          CFArrayRemoveValueAtIndex(v6, FirstIndexOfValue);
          ++v10;
        }
      }
      while (v10 < v9);
    }
  }
  CFIndex v14 = CFArrayGetCount(v6);
  if (v14 >= 1)
  {
    CFIndex v15 = v14;
    for (CFIndex i = 0; i != v15; ++i)
    {
      uint64_t v17 = CFArrayGetValueAtIndex(v6, i);
      CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 72), v17);
      uint64_t v18 = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterAddListener(v18, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))EndpointStreamsChangedNotificationCallback, @"Endpoint_StreamsChanged", (unint64_t)v17);
    }
  }
  CFArrayRef v19 = *(const __CFArray **)(DerivedStorage + 72);
  if (v19)
  {
    CFIndex v20 = CFArrayGetCount(v19);
    if (v20 >= 1)
    {
      CFIndex v21 = v20;
      for (CFIndex j = 0; j != v21; ++j)
      {
        char v23 = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 72), j);
        PeruseAudioStreamsForEndpoint(a1, (uint64_t)v23);
      }
    }
  }
  CFRelease(v6);
  uint64_t v24 = 0;
LABEL_18:
  if (cf) {
    CFRelease(cf);
  }
  return v24;
}

uint64_t __ActivatedEndpointsChangedNotificationCallback_block_invoke(uint64_t a1)
{
  return PeruseActivatedEndpoints(*(const void **)(a1 + 32));
}

void EndpointStreamsChangedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  CFRetain(a4);
  CFArrayRef v7 = *(NSObject **)(DerivedStorage + 48);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  int v8[2] = __EndpointStreamsChangedNotificationCallback_block_invoke;
  _OWORD v8[3] = &__block_descriptor_tmp_14_0;
  void v8[4] = a2;
  v8[5] = a4;
  dispatch_async(v7, v8);
}

void PeruseAudioStreamsForEndpoint(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFArrayRef theArray = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!FigEndpointCopyStreamsForTypeAndSubType(a2, *MEMORY[0x1E4F1CF80], @"Audio", 0, &theArray))
  {
    if (!theArray) {
      return;
    }
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count)
    {
      CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(v5, Count, theArray);
      if (MutableCopy)
      {
        CFArrayRef v8 = MutableCopy;
        CFArrayRef v9 = *(const __CFArray **)(DerivedStorage + 80);
        if (v9)
        {
          CFIndex v10 = CFArrayGetCount(v9);
          if (v10 >= 1)
          {
            CFIndex v11 = v10;
            for (CFIndex i = 0; i != v11; ++i)
            {
              CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 80), i);
              v25.CFIndex length = CFArrayGetCount(v8);
              v25.CFIndex location = 0;
              FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v8, v25, ValueAtIndex);
              if (FirstIndexOfValue != -1) {
                CFArrayRemoveValueAtIndex(v8, FirstIndexOfValue);
              }
            }
          }
        }
        CFIndex v15 = CFArrayGetCount(v8);
        if (v15 >= 1)
        {
          CFIndex v16 = v15;
          for (CFIndex j = 0; j != v16; ++j)
          {
            uint64_t v18 = CFArrayGetValueAtIndex(v8, j);
            CFArrayRef v19 = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
            uint64_t v24 = 0;
            if (!((unsigned int (*)(const __CFAllocator *, void, void, uint64_t, const void *, void, uint64_t *))v19[4])(v5, v19[1], *v19, a2, v18, 0, &v24))
            {
              CFIndex v20 = v19[2];
              block[0] = MEMORY[0x1E4F143A8];
              block[1] = 0x40000000;
              block[2] = __CreateDeviceForEndpointStream_block_invoke;
              block[3] = &__block_descriptor_tmp_15_0;
              void block[4] = v19;
              void block[5] = v24;
              void block[6] = a1;
              dispatch_sync(v20, block);
              FigHALAudioPropertySendChanges((uint64_t (**)(void, uint64_t, uint64_t, uint64_t))*v19, 1, 2, (uint64_t)"#vedbolg");
            }
            CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 80), v18);
            CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterAddListener(DefaultLocalCenter, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))EndpointStreamDissociationNotificationCallback, @"EndpointStreamNotification_Dissociated", (unint64_t)v18);
          }
        }
        CFRelease(v8);
      }
      else
      {
        FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  if (theArray) {
    CFRelease(theArray);
  }
}

void __EndpointStreamsChangedNotificationCallback_block_invoke(uint64_t a1)
{
  PeruseAudioStreamsForEndpoint(*(const void **)(a1 + 32), *(void *)(a1 + 40));
  int v2 = *(const void **)(a1 + 40);

  CFRelease(v2);
}

void EndpointStreamDissociationNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  CFRetain(a4);
  CFArrayRef v7 = *(NSObject **)(DerivedStorage + 48);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __EndpointStreamDissociationNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_17_2;
  void block[4] = a2;
  void block[5] = a4;
  void block[6] = DerivedStorage;
  dispatch_async(v7, block);
}

void __CreateDeviceForEndpointStream_block_invoke(uint64_t a1)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(a1 + 32) + 24), *(const void **)(a1 + 40));
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterAddListener(DefaultLocalCenter, *(const void **)(a1 + 48), (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))DeviceUnpluggedNotificationCallback, @"FigHALAudioDeviceUnplugged", *(void *)(a1 + 40));
  CFAllocatorRef v3 = *(const void **)(a1 + 40);

  CFRelease(v3);
}

void DeviceUnpluggedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  CFArrayRef v7 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __DeviceUnpluggedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_16;
  void block[4] = a2;
  void block[5] = a4;
  void block[6] = DerivedStorage;
  dispatch_sync(v7, block);
  FigHALAudioPropertySendChanges(*(uint64_t (***)(void, uint64_t, uint64_t, uint64_t))DerivedStorage, 1, 2, (uint64_t)"#vedbolg");
}

void __DeviceUnpluggedNotificationCallback_block_invoke(uint64_t a1)
{
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterRemoveListener(DefaultLocalCenter, *(const void **)(a1 + 32), (int)DeviceUnpluggedNotificationCallback, @"FigHALAudioDeviceUnplugged", *(void **)(a1 + 40));
  CFArrayRef v3 = *(const __CFArray **)(*(void *)(a1 + 48) + 24);
  v8.CFIndex length = CFArrayGetCount(v3);
  v8.CFIndex location = 0;
  FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v3, v8, *(const void **)(a1 + 40));
  if (FirstIndexOfValue != -1)
  {
    CFIndex v5 = FirstIndexOfValue;
    CFArrayRef v6 = *(__CFArray **)(*(void *)(a1 + 48) + 24);
    CFArrayRemoveValueAtIndex(v6, v5);
  }
}

void __EndpointStreamDissociationNotificationCallback_block_invoke(uint64_t a1)
{
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterRemoveListener(DefaultLocalCenter, *(const void **)(a1 + 32), (int)EndpointStreamDissociationNotificationCallback, @"EndpointStreamNotification_Dissociated", *(void **)(a1 + 40));
  CFArrayRef v3 = *(const __CFArray **)(*(void *)(a1 + 48) + 80);
  v7.CFIndex length = CFArrayGetCount(v3);
  v7.CFIndex location = 0;
  FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v3, v7, *(const void **)(a1 + 40));
  if (FirstIndexOfValue != -1) {
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 48) + 80), FirstIndexOfValue);
  }
  CFIndex v5 = *(const void **)(a1 + 40);

  CFRelease(v5);
}

uint64_t FigMachPortReleaseReceiveRight_(mach_port_name_t name, uint64_t a2, const char *a3, const char *a4, uint64_t a5)
{
  if (!name) {
    return 0;
  }
  uint64_t v9 = mach_port_mod_refs(*MEMORY[0x1E4F14960], name, 1u, -1);
  uint64_t v10 = v9;
  if (v9) {
    FigSignalErrorAt(v9, 0, (uint64_t)"returned by mach_port_mod_refs while releasing mach port receive right", a2, a3, a4, a5);
  }
  return v10;
}

uint64_t FigMachPortReleaseSendRight_(mach_port_name_t name, uint64_t a2, const char *a3, const char *a4, uint64_t a5)
{
  uint64_t v9 = mach_port_deallocate(*MEMORY[0x1E4F14960], name);
  uint64_t v10 = v9;
  if (v9) {
    FigSignalErrorAt(v9, 0, (uint64_t)"returned by mach_port_deallocate while releasing mach port send right", a2, a3, a4, a5);
  }
  return v10;
}

BOOL FigNetworkHistoryAreAnyRequestsActive(uint64_t a1)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  BOOL v3 = *(void *)(CMBaseObjectGetDerivedStorage(a1) + 80) != 0x7FFFFFFFFFFFFFFFLL;
  FigSimpleMutexUnlock(*DerivedStorage);
  return v3;
}

uint64_t FigNetworkHistoryGetActiveLatencyRange(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigNetworkHistoryBeginImmutabilty(a1);
  FigSimpleMutexLock(*DerivedStorage);
  FirstRequestEntryAfterTime = fnh_getFirstRequestEntryAfterTime(a1, a2);
  uint64_t v10 = 0;
  for (uint64_t i = 0x7FFFFFFFFFFFFFFFLL;
        FirstRequestEntryAfterTime;
        FirstRequestEntryAfterTime = fnh_getFirstRequestEntryAfterTime(a1, *FirstRequestEntryAfterTime + 1))
  {
    uint64_t v12 = FirstRequestEntryAfterTime[2];
    uint64_t v13 = v12 - *FirstRequestEntryAfterTime;
    if (v13 >= i) {
      uint64_t v14 = i;
    }
    else {
      uint64_t v14 = v12 - *FirstRequestEntryAfterTime;
    }
    if (v13 <= v10) {
      uint64_t v13 = v10;
    }
    if (v12 >= 1)
    {
      uint64_t i = v14;
      uint64_t v10 = v13;
    }
  }
  FigSimpleMutexUnlock(*DerivedStorage);
  uint64_t result = FigNetworkHistoryEndImmutability(a1);
  if (i == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = i;
  }
  *a3 = v16;
  *a4 = v10;
  return result;
}

uint64_t FigNetworkHistoryBeginImmutabilty(uint64_t a1)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  uint64_t v3 = CMBaseObjectGetDerivedStorage(a1);
  ++*(void *)(v3 + 120);
  FigSimpleMutexUnlock(*DerivedStorage);
  return 0;
}

void *fnh_getFirstRequestEntryAfterTime(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) < 1) {
    return 0;
  }
  for (uint64_t result = *(void **)(DerivedStorage + 40); result; uint64_t result = (void *)result[7])
  {
    if (*result >= a2) {
      break;
    }
  }
  return result;
}

uint64_t FigNetworkHistoryEndImmutability(uint64_t a1)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  uint64_t v3 = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = *(void *)(v3 + 120);
  if (v4 <= 0)
  {
    uint64_t v5 = FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *(void *)(v3 + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v4 - 1;
    if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) <= 0) {
      fnh_runAllEnqueuedCommands(a1, 0);
    }
    uint64_t v5 = 0;
  }
  FigSimpleMutexUnlock(*DerivedStorage);
  return v5;
}

uint64_t FigNetworkHistoryRequestBecameActive(const void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v7 = CFGetAllocator(a1);
  CFRange v8 = CFAllocatorAllocate(v7, 72, 0);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    v8[8] = 0;
    *((_OWORD *)v8 + 2) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *(_OWORD *)CFRange v8 = 0u;
    *((_OWORD *)v8 + 1) = 0u;
  }
  else
  {
    uint64_t v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v11) {
      return v11;
    }
  }
  if (*(unsigned char *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    uint64_t Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistoryRequestBecameActive(Global, a2, v9 + 48);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  uint64_t v11 = fnh_runOrEnqueueCommand(a1, fnh_requestBecameActiveCommand, v9, a2, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  if (a3 && !v11) {
    *a3 = v9;
  }
  return v11;
}

uint64_t FigNetworkHistoryGetGlobal()
{
  if (fnh_ensureGlobalNetworkHistoryIsSetup_onceToken != -1) {
    dispatch_once_f(&fnh_ensureGlobalNetworkHistoryIsSetup_onceToken, 0, (dispatch_function_t)fnh_globalNetworkHistoryOnce);
  }
  FigSimpleMutexLock((pthread_mutex_t *)gNetworkHistoryAccessorMutex);
  if (!gNetworkHistory)
  {
    uint64_t v6 = 0;
    uint64_t v0 = *MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      int v2 = Mutable;
      uint64_t v3 = (const void *)*MEMORY[0x1E4F1CFC8];
      CFDictionarySetValue(Mutable, @"NetworkHistoryCreateOption_EnableLogging", (const void *)*MEMORY[0x1E4F1CFC8]);
      CFDictionarySetValue(v2, @"NetworkHistoryCreateOption_ContributesToGlobalHistory", v3);
      FigCFDictionarySetInt64(v2, @"NetworkHistoryCreateOption_MaxWindowSize", 600000000000);
      FigCFDictionarySetInt64(v2, @"NetworkHistoryCreateOption_BytesReceivedMaxResolution", 5000000000);
      FigNetworkHistoryCreate(v0, (uint64_t)v2, (CFTypeRef *)&v6);
      CFRelease(v2);
      uint64_t v4 = v6;
    }
    else
    {
      uint64_t v4 = 0;
    }
    gNetworkHistory = v4;
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)gNetworkHistoryAccessorMutex);
  return gNetworkHistory;
}

uint64_t fnh_runOrEnqueueCommand(const void *a1, void (*a2)(void *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 120) < 1)
  {
    v17[0] = a1;
    v17[1] = a3;
    _OWORD v17[2] = a4;
    _OWORD v17[3] = a5;
    a2(v17);
    return 0;
  }
  CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v11 = malloc_type_calloc(1uLL, 0x38uLL, 0x10E004066ACBB0EuLL);
  if (v11)
  {
    uint64_t v12 = v11;
    if (a2) {
      uint64_t v13 = (void (*)(void))a2;
    }
    else {
      uint64_t v13 = 0;
    }
    void *v11 = v13;
    if (a1) {
      CFTypeRef v14 = CFRetain(a1);
    }
    else {
      CFTypeRef v14 = 0;
    }
    v12[1] = v14;
    int v12[2] = a3;
    v12[3] = a4;
    v12[4] = a5;
    v12[5] = 0;
    CFIndex v15 = *(void **)(DerivedStorage + 136);
    v12[6] = v15;
    *CFIndex v15 = v12;
    *(void *)(DerivedStorage + 136) = v12 + 5;
    return 0;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

void fnh_requestBecameActiveCommand(uint64_t *a1)
{
  int v2 = (uint64_t *)a1[1];
  uint64_t v1 = a1[2];
  uint64_t v3 = (const void *)*a1;
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage(*a1);
  CMBaseObjectGetDerivedStorage((uint64_t)v3);
  if (*(void *)(CMBaseObjectGetDerivedStorage((uint64_t)v3) + 80) == 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v5 = DerivedStorage[1];
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigDispatchAsyncPostNotification(v5, DefaultLocalCenter, @"NetworkHistoryNotification_NetworkBecameActive", v3, 0, 0);
  }
  fnh_purgeExpiredListEntriesOnQueue(v3, v1);
  CFAllocatorRef v7 = DerivedStorage + 6;
  CFRange v8 = **(uint64_t ***)(DerivedStorage[6] + 8);
  uint64_t *v2 = v1;
  if (v8)
  {
    while (*v8 > v1)
    {
      CFRange v8 = **(uint64_t ***)(v8[8] + 8);
      if (!v8) {
        goto LABEL_6;
      }
    }
    uint64_t v11 = v8[7];
    uint64_t v9 = (uint64_t **)(v8 + 7);
    uint64_t v10 = v11;
  }
  else
  {
LABEL_6:
    uint64_t v9 = (uint64_t **)(DerivedStorage + 5);
    uint64_t v10 = DerivedStorage[5];
  }
  v2[7] = v10;
  if (v10) {
    CFAllocatorRef v7 = (void *)(v10 + 64);
  }
  *CFAllocatorRef v7 = v2 + 7;
  *uint64_t v9 = v2;
  v2[8] = (uint64_t)v9;
  ++DerivedStorage[12];
  uint64_t v12 = DerivedStorage[10];
  if (v12 >= v1) {
    uint64_t v12 = v1;
  }
  DerivedStorage[10] = v12;
}

uint64_t FigNetworkHistorySetRequestSentTimestamp(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(unsigned char *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    uint64_t Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistorySetRequestSentTimestamp(Global, *(void *)(a2 + 48), a3);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  uint64_t v8 = fnh_runOrEnqueueCommand(a1, (void (*)(void *))fnh_setRequestSentTimestampCommand, a2, a3, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

uint64_t fnh_setRequestSentTimestampCommand(uint64_t *a1)
{
  uint64_t v1 = (uint64_t *)a1[1];
  uint64_t v2 = a1[2];
  if (*v1 > v2)
  {
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = CMBaseObjectGetDerivedStorage(*a1);
    v1[1] = v2;
  }
  return result;
}

uint64_t FigNetworkHistorySetRequestLatency(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(unsigned char *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    uint64_t Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistorySetRequestLatency(Global, *(void *)(a2 + 48), a3);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  uint64_t v8 = fnh_runOrEnqueueCommand(a1, (void (*)(void *))fnh_setRequestLatencyCommand, a2, a3, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

uint64_t fnh_setRequestLatencyCommand(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v3 = a1[2];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  if (*v2 > v3 || v2[1] > v3)
  {
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v5 = DerivedStorage;
    CMBaseObjectGetDerivedStorage(v1);
    v2[2] = v3;
    uint64_t result = fnh_updateEarliestActiveRequestFirstBytesSentTimestamp(v1, v3);
    ++*(void *)(v5 + 104);
  }
  return result;
}

uint64_t FigNetworkHistoryRequestReceivedBytes(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(unsigned char *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    uint64_t Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistoryRequestReceivedBytes(Global, *(void *)(a2 + 48), a3, a4);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  uint64_t v10 = fnh_runOrEnqueueCommand(a1, (void (*)(void *))fnh_requestReceivedBytesCommand, a2, a4, a3);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v10;
}

uint64_t fnh_requestReceivedBytesCommand(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = a1[2];
  if (v2[4] > v1 || (uint64_t v3 = v2[2], v3 > v1) || v3 <= 0)
  {
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v4 = (const void *)*a1;
    uint64_t v5 = a1[3];
    CMBaseObjectGetDerivedStorage(*a1);
    uint64_t v6 = v2[4];
    if (!v6)
    {
      uint64_t v7 = v2[1];
      if (!v7) {
        uint64_t v7 = *v2;
      }
      uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
      if ((unint64_t)(v1 - *v2) > 0x1DCD6500) {
        uint64_t v8 = v7 + 250000000;
      }
      uint64_t v9 = v2[2];
      uint64_t v10 = v9 - v7;
      if (v9 < v7) {
        ++v10;
      }
      uint64_t v11 = v7 + (v10 >> 1);
      if (v9 >= 1) {
        uint64_t v6 = v11;
      }
      else {
        uint64_t v6 = v8;
      }
      v2[4] = v6;
    }
    uint64_t result = fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(v4, v5, v6, v1, v1);
    if (!result)
    {
      uint64_t v13 = v2[5] + v5;
      v2[4] = v1;
      v2[5] = v13;
    }
  }
  return result;
}

uint64_t FigNetworkHistoryRequestBecameInactive(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(unsigned char *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    uint64_t Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistoryRequestBecameInactive(Global, *(void *)(a2 + 48), a3);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  uint64_t v8 = fnh_runOrEnqueueCommand(a1, (void (*)(void *))fnh_requestBecameInactiveCommand, a2, a3, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

uint64_t fnh_requestBecameInactiveCommand(uint64_t *a1)
{
  uint64_t v1 = (const void *)*a1;
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v3 = a1[2];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  v2[3] = v3;
  if (*v2 > v3 || v2[2] > v3)
  {
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v5 = DerivedStorage;
    CMBaseObjectGetDerivedStorage((uint64_t)v1);
    fnh_purgeExpiredListEntriesOnQueue(v1, v3);
    fnh_updateEarliestActiveRequestFirstBytesSentTimestamp((uint64_t)v1, v3);
    uint64_t v6 = v2[1];
    if (!v6) {
      uint64_t v6 = *v2;
    }
    if ((unint64_t)(v3 - *v2) <= 0x1DCD6500) {
      uint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v7 = v6 + 250000000;
    }
    uint64_t v8 = v2[2];
    uint64_t v9 = v8 - v6;
    if (v8 < v6) {
      ++v9;
    }
    uint64_t v10 = v6 + (v9 >> 1);
    if (v8 >= 1) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v7;
    }
    if (v11 == 0x7FFFFFFFFFFFFFFFLL
      || (uint64_t result = fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(v1, 0, v11, v2[3], v3), !result))
    {
      uint64_t result = CMBaseObjectGetDerivedStorage((uint64_t)v1);
      if (*(void *)(result + 80) == 0x7FFFFFFFFFFFFFFFLL)
      {
        uint64_t v13 = *(NSObject **)(v5 + 8);
        CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        return FigDispatchAsyncPostNotification(v13, DefaultLocalCenter, @"NetworkHistoryNotification_NetworkBecameInactive", v1, 0, 0);
      }
    }
  }
  return result;
}

uint64_t FigNetworkHistoryGetFirstBandwidthSampleAfterTime(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*DerivedStorage);
  FirstBytesReceivedEntryAfterTime = (uint64_t *)fnh_getFirstBytesReceivedEntryAfterTime(a1, a2, a4, 0);
  if (FirstBytesReceivedEntryAfterTime) {
    uint64_t v12 = fnh_populateBandwidthSampleFromBytesReceivedEntry((uint64_t)a1, FirstBytesReceivedEntryAfterTime, a3, a5);
  }
  else {
    uint64_t v12 = 0;
  }
  FigSimpleMutexUnlock(*DerivedStorage);
  return v12;
}

uint64_t fnh_getFirstBytesReceivedEntryAfterTime(const void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 120) < 1) {
    return 0;
  }
  fnh_purgeExpiredListEntriesOnQueue(a1, a3);
  fnh_updateEarliestActiveRequestFirstBytesSentTimestamp((uint64_t)a1, a3);
  if (DerivedStorage[9] == 0x7FFFFFFFFFFFFFFFLL) {
    goto LABEL_5;
  }
  if (fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(a1, 0, DerivedStorage[11], a3, a3)) {
    return 0;
  }
  DerivedStorage[11] = a3;
LABEL_5:
  uint64_t result = DerivedStorage[7];
  if (result)
  {
    if (a4)
    {
      uint64_t v10 = **(void **)(DerivedStorage[8] + 8);
      do
      {
        uint64_t result = v10;
        uint64_t v10 = **(void **)(*(void *)(v10 + 40) + 8);
      }
      while (v10 && *(void *)(v10 + 8) >= a2);
    }
    else
    {
      do
      {
        if (*(void *)(result + 8) >= a2) {
          break;
        }
        uint64_t result = *(void *)(result + 32);
      }
      while (result);
    }
  }
  return result;
}

uint64_t fnh_populateBandwidthSampleFromBytesReceivedEntry(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t result = 0;
  if (a2 && *(uint64_t *)(DerivedStorage + 120) >= 1)
  {
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)a4 = 0u;
    uint64_t v9 = a2[1];
    uint64_t v10 = v9 - 1;
    if (v9 - 1 <= *a2) {
      uint64_t v10 = *a2;
    }
    uint64_t v11 = a3 + v10 / a3 * a3;
    if (v9 > v11)
    {
      return 0;
    }
    else
    {
      *(void *)a4 = *a2;
      do
      {
        uint64_t v12 = a2[1];
        if (v12 > v11) {
          break;
        }
        uint64_t v13 = a2[2];
        uint64_t v14 = *(void *)(a4 + 16);
        uint64_t v15 = v12 - *a2 + *(void *)(a4 + 32);
        *(void *)(a4 + 24) += a2[3];
        *(void *)(a4 + 32) = v15;
        uint64_t v16 = v13 <= v14 ? v14 : v13;
        *(void *)(a4 + 8) = v12;
        *(void *)(a4 + 16) = v16;
        a2 = (uint64_t *)a2[4];
        *(void *)(a4 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a2;
      }
      while (a2);
      return 1;
    }
  }
  return result;
}

uint64_t FigNetworkHistoryGetNextBandwidthSample(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  uint64_t v10 = fnh_populateBandwidthSampleFromBytesReceivedEntry(a1, a2, a3, a5);
  FigSimpleMutexUnlock(*DerivedStorage);
  return v10;
}

uint64_t FigNetworkHistoryGetFirstLatencySampleAfterTime(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) >= 1
    && (FirstRequestEntryAfterTime = fnh_getFirstRequestEntryAfterTime(a1, a2)) != 0)
  {
    while (1)
    {
      uint64_t v9 = FirstRequestEntryAfterTime[2];
      if (v9 >= 1) {
        break;
      }
      uint64_t v10 = 0;
      FirstRequestEntryAfterTime = (void *)FirstRequestEntryAfterTime[7];
      if (!FirstRequestEntryAfterTime) {
        goto LABEL_8;
      }
    }
    uint64_t v11 = FirstRequestEntryAfterTime[5];
    *a4 = v9 - *FirstRequestEntryAfterTime;
    a4[1] = v11;
    a4[2] = FirstRequestEntryAfterTime[7];
    uint64_t v10 = 1;
  }
  else
  {
    uint64_t v10 = 0;
  }
LABEL_8:
  FigSimpleMutexUnlock(*DerivedStorage);
  return v10;
}

uint64_t FigNetworkHistoryGetNextValidLatencySample(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  uint64_t v8 = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v9 = 0;
  if (a2 && *(uint64_t *)(v8 + 120) >= 1)
  {
    while (1)
    {
      uint64_t v10 = a2[2];
      if (v10 >= 1) {
        break;
      }
      uint64_t v9 = 0;
      a2 = (void *)a2[7];
      if (!a2) {
        goto LABEL_7;
      }
    }
    uint64_t v11 = a2[5];
    *a4 = v10 - *a2;
    a4[1] = v11;
    a4[2] = a2[7];
    uint64_t v9 = 1;
  }
LABEL_7:
  FigSimpleMutexUnlock(*DerivedStorage);
  return v9;
}

uint64_t FigNetworkHistoryGetMaxWindowSize(uint64_t a1)
{
  return *(void *)(CMBaseObjectGetDerivedStorage(a1) + 16);
}

uint64_t FigNetworkHistoryGetBytesReceivedMaxResolution(uint64_t a1)
{
  return *(void *)(CMBaseObjectGetDerivedStorage(a1) + 24);
}

uint64_t FigNetworkHistoryGetLastActiveTimestamp(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) < 1) {
    goto LABEL_5;
  }
  if (*(void *)(CMBaseObjectGetDerivedStorage(a1) + 80) == 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v5 = **(void **)(*(void *)(DerivedStorage + 64) + 8);
    if (v5)
    {
      a2 = *(void *)(v5 + 8);
      goto LABEL_6;
    }
LABEL_5:
    a2 = 0;
  }
LABEL_6:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return a2;
}

uint64_t FigNetworkHistoryGetFirstActiveTimestamp(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 120) <= 0) {
    fnh_purgeExpiredListEntriesOnQueue(a1, a2);
  }
  if (*(void *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 80) != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v5 = (uint64_t *)(DerivedStorage + 80);
    goto LABEL_7;
  }
  uint64_t v5 = *(uint64_t **)(DerivedStorage + 56);
  if (v5)
  {
LABEL_7:
    uint64_t v6 = *v5;
    goto LABEL_8;
  }
  uint64_t v6 = 0;
LABEL_8:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v6;
}

void fnh_purgeExpiredListEntriesOnQueue(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v5 = *(uint64_t **)(DerivedStorage + 40);
  if (v5)
  {
    uint64_t v6 = (void *)DerivedStorage;
    uint64_t v7 = a2 - *(void *)(DerivedStorage + 16);
    do
    {
      uint64_t v8 = v5[3];
      if (v8 < *v5)
      {
LABEL_11:
        uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else
      {
        uint64_t v9 = v5;
        do
        {
          if (*v9 >= v8) {
            break;
          }
          uint64_t v10 = v9[3];
          if (v10 < *v9) {
            goto LABEL_11;
          }
          if (v8 <= v10) {
            uint64_t v8 = v9[3];
          }
          uint64_t v9 = (uint64_t *)v9[7];
        }
        while (v9);
      }
      if (v8 > v7) {
        break;
      }
      uint64_t v11 = v5[7];
      uint64_t v12 = (uint64_t *)v5[8];
      if (v11)
      {
        *(void *)(v11 + 64) = v12;
        uint64_t v12 = (uint64_t *)v5[8];
      }
      else
      {
        v6[6] = v12;
      }
      *uint64_t v12 = v11;
      CFAllocatorRef v13 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v13, v5);
      --v6[12];
      uint64_t v5 = (uint64_t *)v6[5];
    }
    while (v5);
  }
  uint64_t v14 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v15 = *(void **)(v14 + 56);
  if (v15)
  {
    uint64_t v16 = v14;
    uint64_t v17 = a2 - *(void *)(v14 + 16);
    do
    {
      if (v17 <= v15[1]) {
        break;
      }
      CMBaseObjectGetDerivedStorage((uint64_t)a1);
      uint64_t v18 = v15[4];
      CFArrayRef v19 = (void *)v15[5];
      if (v18)
      {
        *(void *)(v18 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v19;
        CFArrayRef v19 = (void *)v15[5];
      }
      else
      {
        *(void *)(v16 + 64) = v19;
      }
      *CFArrayRef v19 = v18;
      CFAllocatorRef v20 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v20, v15);
      uint64_t v15 = *(void **)(v16 + 56);
    }
    while (v15);
  }
}

uint64_t FigNetworkHistoryCopySharedPredictor(const void *a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFTypeRef cf = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  uint64_t v6 = *(id **)(DerivedStorage + 112);
  if (v6)
  {
    uint64_t v7 = FigCFWeakReferenceHolderCopyReferencedObject(v6);
    CFTypeRef cf = v7;
    if (v7) {
      goto LABEL_8;
    }
  }
  uint64_t v8 = FigNetworkHistoricalPredictorCreate(*MEMORY[0x1E4F1CF80], a1, v5, &cf);
  if (!v8)
  {
    uint64_t v9 = *(const void **)(DerivedStorage + 112);
    if (v9) {
      CFRelease(v9);
    }
    CFTypeRef v10 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
    *(void *)(DerivedStorage + 112) = v10;
    if (v10)
    {
      uint64_t v7 = cf;
LABEL_8:
      uint64_t v11 = 0;
      *a2 = v7;
      CFTypeRef cf = 0;
      goto LABEL_9;
    }
    uint64_t v8 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v11 = v8;
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t FigNetworkHistoricalPredictorCreate(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  CFDictionaryValueCallBacks v15 = *(CFDictionaryValueCallBacks *)byte_1EDF6DF38;
  CFTypeRef cf = 0;
  if (a4)
  {
    FigThreadRunOnce(&FigNetworkPredictorGetClassID_sRegisterFigNetworkPredictorBaseTypeOnce, (void (*)(void))RegisterFigNetworkPredictorBaseType);
    uint64_t v7 = CMDerivedObjectCreate(a1, (uint64_t)&kFigNetworkHistoricalVTable, (void *)sFigNetworkPredictorClassID, &cf);
    if (v7) {
      goto LABEL_13;
    }
    uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
    if (a2) {
      CFTypeRef v9 = CFRetain(a2);
    }
    else {
      CFTypeRef v9 = 0;
    }
    *uint64_t DerivedStorage = v9;
    CFTypeRef v10 = FigSimpleMutexCreate();
    DerivedStorage[1] = v10;
    if (v10)
    {
      CFMutableDictionaryRef v11 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], &v15);
      DerivedStorage[2] = v11;
      if (v11)
      {
        uint64_t v12 = 0;
        *a4 = cf;
        return v12;
      }
    }
    uint64_t v14 = 4294954510;
  }
  else
  {
    uint64_t v14 = 4294949561;
  }
  uint64_t v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
LABEL_13:
  uint64_t v12 = v7;
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

uint64_t FigNetworkHistoryDisableThrottleDetection(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!*(unsigned char *)(DerivedStorage + 34))
  {
    CMBaseObjectGetDerivedStorage(a1);
    *(unsigned char *)(DerivedStorage + 34) = 1;
  }
  uint64_t v3 = *(pthread_mutex_t **)DerivedStorage;

  return FigSimpleMutexUnlock(v3);
}

uint64_t FigNetworkHistoryGetClassID()
{
  return sFigNetworkHistoryClassID;
}

uint64_t RegisterFigNetworkHistoryBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigNetworkHistoryClassDesc, ClassID, 1, &sFigNetworkHistoryClassID);
}

uint64_t FigNetworkHistoryGetCFTypeID()
{
  FigThreadRunOnce(&FigNetworkHistoryGetClassID_sRegisterFigNetworkHistoryBaseTypeOnce, (void (*)(void))RegisterFigNetworkHistoryBaseType);
  uint64_t v0 = (void *)sFigNetworkHistoryClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigNetworkHistoryCreate(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a3)
  {
    fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigNetworkHistoryTrace[1], @"fnh_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigNetworkHistoryTrace);
    fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigNetworkHistoryTrace[3], @"fnh_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &gFigNetworkHistoryTrace[2]);
    FigThreadRunOnce(&FigNetworkHistoryGetClassID_sRegisterFigNetworkHistoryBaseTypeOnce, (void (*)(void))RegisterFigNetworkHistoryBaseType);
    uint64_t v6 = CMDerivedObjectCreate(a1, (uint64_t)&kNetworkHistory_VTable, (void *)sFigNetworkHistoryClassID, &cf);
    if (!v6)
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      uint64_t v8 = FigSimpleMutexCreate();
      *(void *)uint64_t DerivedStorage = v8;
      if (v8)
      {
        dispatch_queue_t v9 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkhistory.notification", 0, 0);
        *(void *)(DerivedStorage + 8) = v9;
        if (v9)
        {
          *(void *)(DerivedStorage + 128) = 0;
          *(void *)(DerivedStorage + 136) = DerivedStorage + 128;
          *(void *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
          *(void *)(DerivedStorage + 48) = DerivedStorage + 40;
          *(void *)(DerivedStorage + 56) = 0;
          *(void *)(DerivedStorage + 64) = DerivedStorage + 56;
          *(_OWORD *)(DerivedStorage + 16) = xmmword_18FE958B0;
          *(int64x2_t *)(DerivedStorage + 72) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
          *(_WORD *)(DerivedStorage + 32) = 257;
          *(void *)(DerivedStorage + 88) = 0;
          *(void *)(DerivedStorage + 96) = 0;
          if (a2)
          {
            FigCFDictionaryGetInt64IfPresent(a2, @"NetworkHistoryCreateOption_MaxWindowSize", (void *)(DerivedStorage + 16));
            FigCFDictionaryGetInt64IfPresent(a2, @"NetworkHistoryCreateOption_BytesReceivedMaxResolution", (void *)(DerivedStorage + 24));
            FigCFDictionaryGetBooleanIfPresent(a2, @"NetworkHistoryCreateOption_EnableLogging", (Boolean *)(DerivedStorage + 32));
            FigCFDictionaryGetBooleanIfPresent(a2, @"NetworkHistoryCreateOption_ContributesToGlobalHistory", (Boolean *)(DerivedStorage + 33));
          }
          CMBaseObjectGetDerivedStorage((uint64_t)cf);
          uint64_t v10 = 0;
          *a3 = cf;
          return v10;
        }
      }
      uint64_t v6 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v10 = v6;
    if (cf) {
      CFRelease(cf);
    }
    return v10;
  }

  return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
}

uint64_t FigNetworkPredictorGetClassID()
{
  return sFigNetworkPredictorClassID;
}

uint64_t RegisterFigNetworkPredictorBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigNetworkPredictorClassDesc, ClassID, 1, &sFigNetworkPredictorClassID);
}

uint64_t FigNetworkPredictorGetCFTypeID()
{
  FigThreadRunOnce(&FigNetworkPredictorGetClassID_sRegisterFigNetworkPredictorBaseTypeOnce, (void (*)(void))RegisterFigNetworkPredictorBaseType);
  uint64_t v0 = (void *)sFigNetworkPredictorClassID;

  return CMBaseClassGetCFTypeID(v0);
}

void fnhp_freeBandwidthPredictionCacheEntry(int a1, void *a2)
{
}

uint64_t fnh_updateEarliestActiveRequestFirstBytesSentTimestamp(uint64_t a1, uint64_t a2)
{
  uint64_t result = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = 0x7FFFFFFFFFFFFFFFLL;
  *(int64x2_t *)(result + 72) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  uint64_t v5 = *(uint64_t **)(result + 40);
  if (v5)
  {
    do
    {
      uint64_t v6 = *v5;
      if (v5[3] < *v5)
      {
        uint64_t v7 = v5[1];
        uint64_t v8 = v5[2];
        if (!v7) {
          uint64_t v7 = *v5;
        }
        if (v7 + 250000000 < v4 && (unint64_t)(a2 - v6) > 0x1DCD6500) {
          uint64_t v10 = v7 + 250000000;
        }
        else {
          uint64_t v10 = v4;
        }
        uint64_t v11 = v8 - v7;
        if (v8 < v7) {
          ++v11;
        }
        uint64_t v12 = v7 + (v11 >> 1);
        if (v12 < v4) {
          uint64_t v4 = v12;
        }
        if (v8 < 1) {
          uint64_t v4 = v10;
        }
        if (v6 >= v4) {
          uint64_t v6 = v4;
        }
        *(void *)(result + 72) = v4;
        *(void *)(result + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v6;
      }
      uint64_t v5 = (uint64_t *)v5[7];
    }
    while (v5);
    if (v4 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v4 <= *(void *)(result + 88)) {
        uint64_t v4 = *(void *)(result + 88);
      }
      *(void *)(result + 88) = v4;
    }
  }
  return result;
}

uint64_t fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a4 - 2 * *(void *)(DerivedStorage + 16) <= a3) {
    uint64_t v11 = a3;
  }
  else {
    uint64_t v11 = a4 - 2 * *(void *)(DerivedStorage + 16);
  }
  uint64_t v12 = (uint64_t **)(DerivedStorage + 56);
  uint64_t v78 = DerivedStorage;
  CFAllocatorRef v13 = (uint64_t **)(DerivedStorage + 64);
  uint64_t v14 = **(uint64_t ***)(*(void *)(DerivedStorage + 64) + 8);
  CFDictionaryRef v82 = 0;
  CFDictionaryRef v83 = v14;
  if (!v14)
  {
    CFAllocatorRef v15 = CFGetAllocator(a1);
    uint64_t result = fnh_createBytesReceivedEntry(v15, a4, &v83);
    if (result) {
      return result;
    }
    uint64_t v17 = (uint64_t)*v12;
    uint64_t v14 = v83;
    uint64_t v18 = v83;
    v83[4] = (uint64_t)*v12;
    CFArrayRef v19 = v18 + 4;
    if (v17) {
      CFAllocatorRef v20 = (uint64_t **)(v17 + 40);
    }
    else {
      CFAllocatorRef v20 = v13;
    }
    *CFAllocatorRef v20 = v19;
    *uint64_t v12 = v14;
    v14[5] = (uint64_t)v12;
  }
  uint64_t v77 = a4 - v11;
  while (1)
  {
    uint64_t v21 = *v14;
    if (*v14 <= a4) {
      break;
    }
    uint64_t v14 = **(uint64_t ***)(v14[5] + 8);
    if (!v14)
    {
      CFDictionaryRef v83 = 0;
      CFAllocatorRef v22 = CFGetAllocator(a1);
      uint64_t result = fnh_createBytesReceivedEntry(v22, a4, &v83);
      if (result) {
        return result;
      }
      char v23 = *v12;
      uint64_t v14 = v83;
      uint64_t v24 = v83;
      v83[4] = (uint64_t)*v12;
      CFRange v25 = v24 + 4;
      if (v23) {
        uint64_t v26 = (uint64_t **)(v23 + 5);
      }
      else {
        uint64_t v26 = v13;
      }
      const void *v26 = v25;
      *uint64_t v12 = v14;
LABEL_27:
      v14[5] = (uint64_t)v12;
      goto LABEL_28;
    }
  }
  uint64_t v27 = v14[1];
  if (v11 > v27) {
    goto LABEL_22;
  }
  uint64_t v28 = v27 - 1;
  if (v28 > v21) {
    uint64_t v21 = v28;
  }
  if (*(void *)(v78 + 24) + v21 / *(void *)(v78 + 24) * *(void *)(v78 + 24) < a4)
  {
LABEL_22:
    CFAllocatorRef v29 = CFGetAllocator(a1);
    uint64_t result = fnh_createBytesReceivedEntry(v29, a4, &v82);
    if (result) {
      return result;
    }
    uint64_t v31 = v14[4];
    long long v30 = (uint64_t **)(v14 + 4);
    uint64_t v12 = v30;
    CFStringRef v32 = v82;
    uint64_t v33 = v82;
    v82[4] = v31;
    CFAllocatorRef v34 = v33 + 4;
    CFStringRef v35 = (uint64_t **)(v31 + 40);
    if (v31) {
      int v36 = v35;
    }
    else {
      int v36 = v13;
    }
    uint64_t *v36 = v34;
    *long long v30 = v32;
    uint64_t v14 = v32;
    goto LABEL_27;
  }
LABEL_28:
  uint64_t v37 = *(void *)(v78 + 24);
  CFErrorRef v39 = v14 + 1;
  uint64_t v38 = v14[1];
  uint64_t v40 = v38 - 1;
  uint64_t v41 = *v14;
  if (v38 - 1 <= *v14) {
    uint64_t v40 = *v14;
  }
  uint64_t v42 = v37 + v40 / v37 * v37;
  if (v11 >= v42)
  {
    int v43 = 0;
LABEL_84:
    if (v43)
    {
      do
      {
        v14[2] = a5;
        uint64_t v14 = (uint64_t *)v14[4];
      }
      while (v14);
    }
  }
  else
  {
    int v43 = 0;
    double v44 = (double)a2;
    CMTimeValue v45 = v14;
    while (1)
    {
      uint64_t v46 = v41 / v37 * v37;
      if (v11 <= v46) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = v11;
      }
      if (v42 >= a4) {
        uint64_t v48 = a4;
      }
      else {
        uint64_t v48 = v42;
      }
      if (v77 < 1) {
        double v49 = 1.0;
      }
      else {
        double v49 = (double)(v48 - v47) / (double)v77;
      }
      uint64_t v50 = (uint64_t)(v49 * v44);
      long long v80 = 0u;
      long long v81 = 0u;
      long long __s1 = 0u;
      long long v51 = *(_OWORD *)v45;
      long long v52 = *((_OWORD *)v45 + 2);
      long long v80 = *((_OWORD *)v45 + 1);
      long long v81 = v52;
      long long __s1 = v51;
      if (v41 >= v47) {
        uint64_t v41 = v47;
      }
      *CMTimeValue v45 = v41;
      if (v38 <= v48) {
        uint64_t v38 = v48;
      }
      *CFErrorRef v39 = v38;
      v45[3] += v50;
      if (!v43 && !memcmp(&__s1, v45, 0x30uLL))
      {
        int v43 = 0;
      }
      else
      {
        v45[2] = a5;
        int v43 = 1;
      }
      uint64_t v53 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      CFTypeID v54 = **(uint64_t ***)(v45[5] + 8);
      if (v54)
      {
        uint64_t v55 = v53;
        do
        {
          uint64_t v56 = *v45;
          uint64_t v58 = *v54;
          uint64_t v57 = v54[1];
          if (*v45 >= v57 && v56 != v58) {
            break;
          }
          if (v56 >= v58) {
            uint64_t v56 = *v54;
          }
          *CMTimeValue v45 = v56;
          if (*v39 > v57) {
            uint64_t v57 = *v39;
          }
          *CFErrorRef v39 = v57;
          v45[3] += v54[3];
          uint64_t v61 = v54[4];
          uint64_t v60 = v54[5];
          uint64_t v62 = **(uint64_t ***)(v60 + 8);
          if (v61)
          {
            *(void *)(v61 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v60;
            uint64_t v60 = v54[5];
          }
          else
          {
            *(void *)(v55 + 64) = v60;
          }
          *(void *)uint64_t v60 = v61;
          CFAllocatorRef v63 = CFGetAllocator(a1);
          CFAllocatorDeallocate(v63, v54);
          CFTypeID v54 = v62;
        }
        while (v62);
      }
      CMBaseObjectGetDerivedStorage((uint64_t)a1);
      if (v11 >= *v45) {
        break;
      }
      uint64_t v64 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      uint64_t v65 = *v45 - 1;
      uint64_t v14 = **(uint64_t ***)(v45[5] + 8);
      CMTimeFlags v84 = v14;
      if (v14)
      {
        if (v65 > v14[1])
        {
          CFAllocatorRef v66 = CFGetAllocator(a1);
          uint64_t result = fnh_createBytesReceivedEntry(v66, v65, &v84);
          if (result) {
            return result;
          }
          uint64_t v14 = v84;
          v84[5] = v45[5];
          v14[4] = (uint64_t)v45;
          *(void *)v45[5] = v14;
          v45[5] = (uint64_t)(v14 + 4);
        }
      }
      else
      {
        uint64_t v67 = v64;
        CFAllocatorRef v68 = CFGetAllocator(a1);
        uint64_t result = fnh_createBytesReceivedEntry(v68, v65, &v84);
        if (result) {
          return result;
        }
        uint64_t v70 = *(void *)(v67 + 56);
        long long v69 = (uint64_t **)(v67 + 56);
        uint64_t v14 = v84;
        long long v71 = v84;
        v84[4] = v70;
        uint64_t v72 = v71 + 4;
        long long v73 = (uint64_t **)(v70 + 40);
        if (v70) {
          uint64_t v74 = v73;
        }
        else {
          uint64_t v74 = v69 + 1;
        }
        const void *v74 = v72;
        *long long v69 = v14;
        v14[5] = (uint64_t)v69;
      }
      CFArrayRef v75 = (void *)v14[4];
      if (v75 && v14[1] > *v75)
      {
        uint64_t result = FigSignalErrorAt(4294949564, 0, 0, 0, 0, 0, 0);
        uint64_t v14 = v45;
        if (result) {
          return result;
        }
      }
      else
      {
        CMTimeValue v45 = v14;
      }
      uint64_t v37 = *(void *)(v78 + 24);
      CFErrorRef v39 = v14 + 1;
      uint64_t v38 = v14[1];
      uint64_t v76 = v38 - 1;
      uint64_t v41 = *v14;
      if (v38 - 1 <= *v14) {
        uint64_t v76 = *v14;
      }
      uint64_t v42 = v37 + v76 / v37 * v37;
      if (v11 >= v42) {
        goto LABEL_84;
      }
    }
  }
  return 0;
}

uint64_t fnh_createBytesReceivedEntry(const __CFAllocator *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = CFAllocatorAllocate(a1, 48, 0);
  if (v5)
  {
    _OWORD *v5 = 0u;
    v5[1] = 0u;
    v5[2] = 0u;
    *(void *)uint64_t v5 = a2;
    *((void *)v5 + 1) = a2;
    *((void *)v5 + 2) = a2;
    *a3 = v5;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

void fnh_runAllEnqueuedCommands(uint64_t a1, int a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v5 = *(char **)(DerivedStorage + 128);
  if (v5)
  {
    uint64_t v6 = DerivedStorage;
    do
    {
      uint64_t v7 = (char *)*((void *)v5 + 5);
      uint64_t v8 = v7;
      if (!a2)
      {
        CMBaseObjectGetDerivedStorage(a1);
        dispatch_queue_t v9 = *(void (**)(_OWORD *))v5;
        long long v10 = *(_OWORD *)(v5 + 24);
        v13[0] = *(_OWORD *)(v5 + 8);
        v13[1] = v10;
        v9(v13);
        uint64_t v8 = (char *)*((void *)v5 + 5);
      }
      uint64_t v11 = (void *)*((void *)v5 + 6);
      if (v8)
      {
        *((void *)v8 + 6) = v11;
        uint64_t v11 = (void *)*((void *)v5 + 6);
      }
      else
      {
        *(void *)(v6 + 136) = v11;
      }
      void *v11 = v8;
      uint64_t v12 = (const void *)*((void *)v5 + 1);
      if (v12) {
        CFRelease(v12);
      }
      free(v5);
      uint64_t v5 = v7;
    }
    while (v7);
  }
}

CFStringRef FigNetworkHistoryCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigNetworkHistory %p]", a1);
}

CFAllocatorRef fnh_finalize(const void *a1)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  fnh_runAllEnqueuedCommands((uint64_t)a1, 1);
  uint64_t v3 = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  for (uint64_t i = (void *)v3[5]; i; uint64_t i = (void *)v3[5])
  {
    uint64_t v5 = i[7];
    uint64_t v6 = (void *)i[8];
    if (v5)
    {
      *(void *)(v5 + 64) = v6;
      uint64_t v6 = (void *)i[8];
    }
    else
    {
      v3[6] = v6;
    }
    *uint64_t v6 = v5;
    CFAllocatorRef v7 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v7, i);
  }
  v3[12] = 0;
  uint64_t v8 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  dispatch_queue_t v9 = *(void **)(v8 + 56);
  if (v9)
  {
    uint64_t v10 = v8;
    do
    {
      uint64_t v11 = v9[4];
      uint64_t v12 = (void *)v9[5];
      if (v11)
      {
        *(void *)(v11 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v12;
        uint64_t v12 = (void *)v9[5];
      }
      else
      {
        *(void *)(v10 + 64) = v12;
      }
      *uint64_t v12 = v11;
      CFAllocatorRef v13 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v13, v9);
      dispatch_queue_t v9 = *(void **)(v10 + 56);
    }
    while (v9);
  }
  uint64_t v14 = (const void *)DerivedStorage[14];
  if (v14) {
    CFRelease(v14);
  }
  CFAllocatorRef v15 = DerivedStorage[1];
  if (v15) {
    dispatch_release(v15);
  }
  uint64_t v16 = *DerivedStorage;

  return FigSimpleMutexDestroy(v16);
}

pthread_mutex_t *fnh_globalNetworkHistoryOnce()
{
  uint64_t result = FigSimpleMutexCreate();
  gNetworkHistoryAccessorMutex = (uint64_t)result;
  return result;
}

CFStringRef FigNetworkPredictorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigNetworkPredictor %p]", a1);
}

CFAllocatorRef fnhp_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t v2 = *(const void **)(DerivedStorage + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(void *)(DerivedStorage + 8);

  return FigSimpleMutexDestroy(v3);
}

uint64_t fnhp_copyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage(a1);
  if (!CFEqual(a2, @"NetworkPredictorProperty_History")) {
    return 4294949566;
  }
  if (*DerivedStorage) {
    CFTypeRef v7 = CFRetain(*DerivedStorage);
  }
  else {
    CFTypeRef v7 = 0;
  }
  uint64_t result = 0;
  *a4 = v7;
  return result;
}

uint64_t fnhp_makePrediction(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v232 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(void *)(a4 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  FigNetworkHistoryBeginImmutabilty(*DerivedStorage);
  switch(*(void *)a3)
  {
    case 0:
      long long v8 = *(_OWORD *)(a3 + 176);
      long long v219 = *(_OWORD *)(a3 + 160);
      long long v220 = v8;
      long long v9 = *(_OWORD *)(a3 + 208);
      long long v221 = *(_OWORD *)(a3 + 192);
      long long v222 = v9;
      long long v10 = *(_OWORD *)(a3 + 112);
      long long v215 = *(_OWORD *)(a3 + 96);
      long long v216 = v10;
      long long v11 = *(_OWORD *)(a3 + 144);
      long long v217 = *(_OWORD *)(a3 + 128);
      long long v218 = v11;
      long long v12 = *(_OWORD *)(a3 + 48);
      long long v211 = *(_OWORD *)(a3 + 32);
      long long v212 = v12;
      long long v13 = *(_OWORD *)(a3 + 80);
      long long v213 = *(_OWORD *)(a3 + 64);
      long long v214 = v13;
      long long v14 = *(_OWORD *)(a3 + 16);
      long long v209 = *(_OWORD *)a3;
      long long v210 = v14;
      CFAllocatorRef v15 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      uint64_t v223 = 0;
      uint64_t v16 = *(void *)(CMBaseObjectGetDerivedStorage(*v15) + 24);
      *(_OWORD *)&v228[144] = v219;
      *(_OWORD *)&v228[160] = v220;
      *(_OWORD *)&v228[176] = v221;
      *(_OWORD *)&v228[192] = v222;
      *(_OWORD *)&v228[80] = v215;
      *(_OWORD *)&v228[96] = v216;
      *(_OWORD *)&v228[112] = v217;
      *(_OWORD *)&v228[128] = v218;
      *(_OWORD *)&v228[16] = v211;
      *(_OWORD *)&v228[32] = v212;
      *(_OWORD *)&v228[48] = v213;
      *(_OWORD *)&v228[64] = v214;
      long long v227 = v209;
      *(_OWORD *)unsigned int v228 = v210;
      fnhp_medianAlgorithmForLatency(a1, a2, &v227, v16, (void *)(a4 + 32), (double *)(a4 + 40), &v223);
      *(_OWORD *)&v231[128] = v219;
      *(_OWORD *)&v231[144] = v220;
      *(_OWORD *)&v231[160] = v221;
      *(_OWORD *)&v231[176] = v222;
      *(_OWORD *)&v231[64] = v215;
      *(_OWORD *)&v231[80] = v216;
      *(_OWORD *)&v231[96] = v217;
      *(_OWORD *)&v231[112] = v218;
      *(_OWORD *)int v231 = v211;
      *(_OWORD *)&v231[16] = v212;
      *(_OWORD *)&v231[32] = v213;
      *(_OWORD *)&v231[48] = v214;
      long long v229 = v209;
      long long v230 = v210;
      uint64_t v17 = v223;
      uint64_t v225 = 0;
      v226[0] = 0;
      *(void *)&long long v208 = 0;
      uint64_t v224 = 0;
      long long v227 = v209;
      *(_OWORD *)unsigned int v228 = v210;
      *(_OWORD *)&v228[152] = *(_OWORD *)&v231[136];
      *(_OWORD *)&v228[168] = *(_OWORD *)&v231[152];
      *(_OWORD *)&v228[184] = *(_OWORD *)&v231[168];
      *(_OWORD *)&v228[88] = *(_OWORD *)&v231[72];
      *(_OWORD *)&v228[104] = *(_OWORD *)&v231[88];
      *(_OWORD *)&v228[120] = *(_OWORD *)&v231[104];
      *(_OWORD *)&v228[136] = *(_OWORD *)&v231[120];
      *(_OWORD *)&v228[24] = *(_OWORD *)&v231[8];
      *(_OWORD *)&v228[40] = *(_OWORD *)&v231[24];
      *(_OWORD *)&v228[56] = *(_OWORD *)&v231[40];
      *(_OWORD *)&v228[72] = *(_OWORD *)&v231[56];
      *(void *)&v228[200] = *((void *)&v222 + 1);
      *(void *)&v228[16] = 0;
      uint64_t v18 = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(a1, 0, a2, &v227, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_constantWeightForBandwidthSample, 0, v226, (double *)&v225, (double *)&v224, (uint64_t *)&v208);
      if (v18) {
        goto LABEL_30;
      }
      if (v17 >= 0) {
        uint64_t v19 = v17;
      }
      else {
        uint64_t v19 = v17 + 1;
      }
      uint64_t v20 = v208 + (v19 >> 1);
      if (v20 < 1) {
        double v21 = 0.0;
      }
      else {
        double v21 = (double)v226[0] + (double)(v19 >> 1) / (double)v20 * (0.0 - (double)v226[0]);
      }
      *(void *)a4 = llround(v21);
      uint64_t v22 = v224;
      *(void *)(a4 + 8) = v225;
      *(void *)(a4 + 16) = v22;
      *(void *)(a4 + 48) = v20;
      goto LABEL_28;
    case 1:
      long long v24 = *(_OWORD *)(a3 + 176);
      *(_OWORD *)&v228[144] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v228[160] = v24;
      long long v25 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v228[192] = v25;
      long long v26 = *(_OWORD *)(a3 + 112);
      *(_OWORD *)&v228[80] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v228[96] = v26;
      long long v27 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v228[112] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v228[128] = v27;
      long long v28 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)&v228[16] = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v228[32] = v28;
      long long v29 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v228[48] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v228[64] = v29;
      long long v30 = *(_OWORD *)(a3 + 16);
      long long v227 = *(_OWORD *)a3;
      *(_OWORD *)unsigned int v228 = v30;
      uint64_t v23 = fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, a4);
      goto LABEL_11;
    case 2:
      long long v31 = *(_OWORD *)(a3 + 176);
      long long v32 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v31;
      long long v33 = *(_OWORD *)(a3 + 176);
      long long v34 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v34;
      long long v35 = *(_OWORD *)(a3 + 112);
      long long v36 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v35;
      long long v37 = *(_OWORD *)(a3 + 112);
      long long v38 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v38;
      long long v39 = *(_OWORD *)(a3 + 48);
      long long v40 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)int v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v39;
      long long v41 = *(_OWORD *)(a3 + 48);
      long long v42 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v42;
      long long v43 = *(_OWORD *)(a3 + 16);
      long long v229 = *(_OWORD *)a3;
      long long v230 = v43;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = v33;
      long long v44 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = v44;
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = v37;
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = v32;
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = v41;
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = v36;
      long long v227 = v229;
      *(_OWORD *)unsigned int v228 = v40;
      CMTimeValue v45 = (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_linearTimeWeightForBandwidthSample;
      goto LABEL_18;
    case 3:
      long long v46 = *(_OWORD *)(a3 + 176);
      long long v47 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v46;
      long long v48 = *(_OWORD *)(a3 + 176);
      long long v49 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v49;
      long long v50 = *(_OWORD *)(a3 + 112);
      long long v51 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v50;
      long long v52 = *(_OWORD *)(a3 + 112);
      long long v53 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v53;
      long long v54 = *(_OWORD *)(a3 + 48);
      long long v55 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)int v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v54;
      long long v56 = *(_OWORD *)(a3 + 48);
      long long v57 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v57;
      long long v58 = *(_OWORD *)(a3 + 16);
      long long v229 = *(_OWORD *)a3;
      long long v230 = v58;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = v48;
      long long v59 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = v59;
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = v52;
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = v47;
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = v56;
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = v51;
      long long v227 = v229;
      *(_OWORD *)unsigned int v228 = v55;
      CMTimeValue v45 = (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_quadraticTimeWeightForBandwidthSample;
      goto LABEL_18;
    case 4:
      long long v208 = *(_OWORD *)a3;
      uint64_t v60 = *(void *)(a3 + 16);
      long long v61 = *(_OWORD *)(a3 + 168);
      long long v62 = *(_OWORD *)(a3 + 200);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 184);
      *(_OWORD *)&v231[144] = v62;
      *(void *)&v231[160] = *(void *)(a3 + 216);
      long long v63 = *(_OWORD *)(a3 + 104);
      long long v64 = *(_OWORD *)(a3 + 136);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 120);
      *(_OWORD *)&v231[80] = v64;
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 152);
      *(_OWORD *)&v231[112] = v61;
      long long v65 = *(_OWORD *)(a3 + 40);
      long long v66 = *(_OWORD *)(a3 + 72);
      *(_OWORD *)int v231 = *(_OWORD *)(a3 + 56);
      *(_OWORD *)&v231[16] = v66;
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 88);
      *(_OWORD *)&v231[48] = v63;
      long long v229 = *(_OWORD *)(a3 + 24);
      long long v230 = v65;
      uint64_t v67 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      uint64_t v68 = *(void *)(CMBaseObjectGetDerivedStorage(*v67) + 24);
      *(double *)int v226 = (double)v60
                      / 1000000000.0
                      * ((double)v60
                       / 1000000000.0)
                      * 0.01
                      / ((double)v68
                       / 1000000000.0
                       * ((double)v68
                        / 1000000000.0));
      long long v227 = v208;
      *(_OWORD *)&v228[152] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[168] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[184] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[88] = *(_OWORD *)&v231[48];
      *(_OWORD *)&v228[104] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[120] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[136] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[24] = v230;
      *(_OWORD *)&v228[40] = *(_OWORD *)v231;
      v226[1] = v68;
      *(void *)unsigned int v228 = v60;
      *(void *)&v228[200] = *(void *)&v231[160];
      *(_OWORD *)&v228[56] = *(_OWORD *)&v231[16];
      *(_OWORD *)&v228[72] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[8] = v229;
      uint64_t v18 = fnhp_timeWeightedConstantLatencyPredictionAlgorithm(a1, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_quadraticTimeWeightWithHighPassUtilizationFilterForBandwidthSample, (uint64_t)v226, a2, &v227, a4);
      if (v18) {
        goto LABEL_30;
      }
      long long v227 = v208;
      *(_OWORD *)&v228[152] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[168] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[184] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[88] = *(_OWORD *)&v231[48];
      *(_OWORD *)&v228[104] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[120] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[136] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[24] = v230;
      *(_OWORD *)&v228[40] = *(_OWORD *)v231;
      *(_OWORD *)&v228[56] = *(_OWORD *)&v231[16];
      *(void *)unsigned int v228 = v60;
      *(void *)&v228[200] = *(void *)&v231[160];
      *(_OWORD *)&v228[72] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[8] = v229;
      goto LABEL_20;
    case 5:
      long long v69 = *(_OWORD *)(a3 + 176);
      long long v70 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v69;
      long long v71 = *(_OWORD *)(a3 + 176);
      long long v72 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v72;
      long long v73 = *(_OWORD *)(a3 + 112);
      long long v74 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v73;
      long long v75 = *(_OWORD *)(a3 + 112);
      long long v76 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v76;
      long long v77 = *(_OWORD *)(a3 + 48);
      long long v78 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)int v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v77;
      long long v79 = *(_OWORD *)(a3 + 48);
      long long v80 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v80;
      long long v81 = *(_OWORD *)(a3 + 16);
      long long v229 = *(_OWORD *)a3;
      long long v230 = v81;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = v71;
      long long v82 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = v82;
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = v75;
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = v70;
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = v79;
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = v74;
      long long v227 = v229;
      *(_OWORD *)unsigned int v228 = v78;
      CMTimeValue v45 = (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_logisticTimeWeightForBandwidthSample;
LABEL_18:
      uint64_t v18 = fnhp_timeWeightedConstantLatencyPredictionAlgorithm(a1, v45, 0, a2, &v227, a4);
      if (v18) {
        goto LABEL_30;
      }
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = *(_OWORD *)&v231[176];
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
      long long v227 = v229;
      *(_OWORD *)unsigned int v228 = v230;
LABEL_20:
      long long v83 = *(_OWORD *)(a4 + 48);
      long long v211 = *(_OWORD *)(a4 + 32);
      long long v212 = v83;
      long long v213 = *(_OWORD *)(a4 + 64);
      *(void *)&long long v214 = *(void *)(a4 + 80);
      long long v84 = *(_OWORD *)(a4 + 16);
      long long v209 = *(_OWORD *)a4;
      long long v210 = v84;
      CMTimeEpoch v85 = &v209;
      break;
    case 6:
      long long v86 = *(_OWORD *)(a3 + 176);
      long long v87 = *(_OWORD *)(a3 + 144);
      long long v219 = *(_OWORD *)(a3 + 160);
      long long v220 = v86;
      long long v88 = *(_OWORD *)(a3 + 176);
      long long v89 = *(_OWORD *)(a3 + 208);
      long long v221 = *(_OWORD *)(a3 + 192);
      long long v222 = v89;
      long long v90 = *(_OWORD *)(a3 + 112);
      long long v91 = *(_OWORD *)(a3 + 80);
      long long v215 = *(_OWORD *)(a3 + 96);
      long long v216 = v90;
      long long v92 = *(_OWORD *)(a3 + 112);
      long long v93 = *(_OWORD *)(a3 + 144);
      long long v217 = *(_OWORD *)(a3 + 128);
      long long v218 = v93;
      long long v94 = *(_OWORD *)(a3 + 48);
      long long v95 = *(_OWORD *)(a3 + 16);
      long long v211 = *(_OWORD *)(a3 + 32);
      long long v212 = v94;
      long long v96 = *(_OWORD *)(a3 + 48);
      long long v97 = *(_OWORD *)(a3 + 80);
      long long v213 = *(_OWORD *)(a3 + 64);
      long long v214 = v97;
      long long v98 = *(_OWORD *)(a3 + 16);
      long long v209 = *(_OWORD *)a3;
      long long v210 = v98;
      long long v99 = *(_OWORD *)(a3 + 176);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v99;
      long long v100 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v100;
      long long v101 = *(_OWORD *)(a3 + 112);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v101;
      long long v102 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v102;
      long long v103 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)int v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v103;
      long long v104 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v104;
      long long v105 = *(_OWORD *)(a3 + 16);
      long long v229 = *(_OWORD *)a3;
      long long v230 = v105;
      *(_OWORD *)&v228[144] = v219;
      *(_OWORD *)&v228[160] = v88;
      long long v106 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = v221;
      *(_OWORD *)&v228[192] = v106;
      *(_OWORD *)&v228[80] = v215;
      *(_OWORD *)&v228[96] = v92;
      *(_OWORD *)&v228[112] = v217;
      *(_OWORD *)&v228[128] = v87;
      *(_OWORD *)&v228[16] = v211;
      *(_OWORD *)&v228[32] = v96;
      *(_OWORD *)&v228[48] = v213;
      *(_OWORD *)&v228[64] = v91;
      long long v227 = v209;
      *(_OWORD *)unsigned int v228 = v95;
      int v107 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      uint64_t StartTimestamp = fnhp_getStartTimestamp(a1, a2, (uint64_t)&v227, 1);
      long long v227 = 0uLL;
      *(void *)unsigned int v228 = 0;
      if (FigNetworkHistoryGetFirstLatencySampleAfterTime(*v107, StartTimestamp, v109, &v227))
      {
        uint64_t v111 = 0;
        uint64_t v112 = 0;
        double v113 = 0.0;
        double v114 = 0.0;
        do
        {
          ++v111;
          v112 += v227;
          double v115 = (double)(uint64_t)v227 - v114;
          double v114 = v114 + 1.0 / (double)v111 * v115;
          double v113 = v113 + v115 * ((double)(uint64_t)v227 - v114);
        }
        while (FigNetworkHistoryGetNextValidLatencySample(*v107, *(void **)v228, v110, &v227));
        uint64_t v116 = v112 / v111;
        if (v113 <= 2.22044605e-16) {
          double v117 = 0.0;
        }
        else {
          double v117 = sqrt(v113 / (double)v111);
        }
        *(double *)(a4 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v117;
      }
      else
      {
        uint64_t v116 = 0;
      }
      *(void *)(a4 + 32) = v116;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = *(_OWORD *)&v231[176];
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
      long long v227 = v229;
      *(_OWORD *)unsigned int v228 = v230;
      uint64_t v18 = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(a1, v116, a2, &v227, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_logisticTimeWeightForBandwidthSample, 0, (uint64_t *)a4, (double *)(a4 + 8), (double *)(a4 + 16), (uint64_t *)(a4 + 48));
      if (v18) {
        goto LABEL_30;
      }
LABEL_28:
      *(_OWORD *)&v228[144] = v219;
      *(_OWORD *)&v228[160] = v220;
      *(_OWORD *)&v228[176] = v221;
      *(_OWORD *)&v228[192] = v222;
      *(_OWORD *)&v228[80] = v215;
      *(_OWORD *)&v228[96] = v216;
      *(_OWORD *)&v228[112] = v217;
      *(_OWORD *)&v228[128] = v218;
      *(_OWORD *)&v228[16] = v211;
      *(_OWORD *)&v228[32] = v212;
      *(_OWORD *)&v228[48] = v213;
      *(_OWORD *)&v228[64] = v214;
      long long v227 = v209;
      *(_OWORD *)unsigned int v228 = v210;
      long long v118 = *(_OWORD *)(a4 + 48);
      *(_OWORD *)int v231 = *(_OWORD *)(a4 + 32);
      *(_OWORD *)&v231[16] = v118;
      *(_OWORD *)&v231[32] = *(_OWORD *)(a4 + 64);
      *(void *)&v231[48] = *(void *)(a4 + 80);
      long long v119 = *(_OWORD *)(a4 + 16);
      long long v229 = *(_OWORD *)a4;
      long long v230 = v119;
      CMTimeEpoch v85 = &v229;
      break;
    case 7:
      long long v171 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v171;
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[137] = *(_OWORD *)(a3 + 169);
      long long v172 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v172;
      long long v173 = *(_OWORD *)(a3 + 112);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v173;
      long long v174 = *(_OWORD *)(a3 + 16);
      long long v229 = *(_OWORD *)a3;
      long long v230 = v174;
      long long v175 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)int v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v175;
      int v176 = *(unsigned __int8 *)(a3 + 185);
      int v177 = *(unsigned __int8 *)(a3 + 186);
      LODWORD(v226[0]) = *(_DWORD *)(a3 + 187);
      BYTE4(v226[0]) = *(unsigned char *)(a3 + 191);
      int64_t v178 = *(void *)(a3 + 208);
      long long v203 = *(_OWORD *)(a3 + 192);
      unint64_t v179 = *(void *)(a3 + 216);
      unsigned int v180 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      *(void *)&long long v214 = 0;
      long long v212 = 0u;
      long long v213 = 0u;
      long long v210 = 0u;
      long long v211 = 0u;
      long long v209 = 0u;
      char v204 = v177;
      if (v176 || !v177)
      {
        uint64_t v183 = 0;
        uint64_t v18 = 0;
        double v184 = 1.0;
        if (v176 && v177)
        {
          uint64_t v199 = a4;
          double v185 = 0.0;
          uint64_t v186 = -3000000000;
          uint64_t v206 = 4000000000;
          unint64_t v187 = 3000000000;
          unint64_t v181 = *((void *)&v203 + 1);
          do
          {
            if (v187 + v178 + 1000000000 >= a2)
            {
              double v192 = 0.0;
            }
            else
            {
              uint64_t v202 = v186;
              int v205 = 0;
              double v188 = 0.0;
              do
              {
                *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
                *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
                *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
                *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
                *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
                *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
                *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
                *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
                long long v227 = v229;
                *(_OWORD *)unsigned int v228 = v230;
                *(_OWORD *)&v228[16] = *(_OWORD *)v231;
                *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
                v228[169] = v176;
                v228[170] = v204;
                *(_DWORD *)&v228[171] = v226[0];
                v228[175] = BYTE4(v226[0]);
                *(_OWORD *)&v228[176] = v203;
                *(void *)&v228[192] = v187 + v178;
                *(void *)&v228[200] = 3000000000;
                fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, (uint64_t)&v209);
                uint64_t v189 = a2;
                uint64_t v190 = v209;
                *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
                *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
                *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
                *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
                *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
                *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
                *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
                *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
                long long v227 = v229;
                *(_OWORD *)unsigned int v228 = v230;
                *(_OWORD *)&v228[16] = *(_OWORD *)v231;
                *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
                v228[169] = v176;
                v228[170] = v204;
                *(_DWORD *)&v228[171] = v226[0];
                v228[175] = BYTE4(v226[0]);
                *(_OWORD *)&v228[176] = v203;
                *(void *)&v228[192] = v178;
                *(void *)&v228[200] = v187;
                unint64_t v191 = v189;
                fnhp_constantLatencyPredictionAlgorithm(a1, v189, &v227, (uint64_t)&v209);
                if (v190 && (void)v209)
                {
                  double v188 = v188 + (double)(v190 - v209) * (double)(v190 - v209);
                  ++v205;
                }
                v178 += v187;
                a2 = v191;
              }
              while (v206 + v178 < v191);
              uint64_t v186 = v202;
              v178 += v202;
              if (v205) {
                double v192 = v188 / (double)v205;
              }
              else {
                double v192 = 0.0;
              }
              unint64_t v179 = v187;
            }
            if (v185 == 0.0)
            {
              unint64_t v181 = v187;
            }
            else if (v192 < v185 && v192 != 0.0)
            {
              unint64_t v181 = v187;
            }
            else
            {
              double v192 = v185;
            }
            v186 -= 2000000000;
            v206 += 2000000000;
            double v185 = v192;
            BOOL v193 = v187 >= 0x3F5476A00;
            v187 += 2000000000;
          }
          while (!v193);
          if (v181) {
            unint64_t v194 = v181;
          }
          else {
            unint64_t v194 = v203;
          }
          *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
          *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
          *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
          *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
          *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
          *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
          *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
          *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
          long long v227 = v229;
          *(_OWORD *)unsigned int v228 = v230;
          *(_OWORD *)&v228[16] = *(_OWORD *)v231;
          *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
          v228[169] = v176;
          v228[170] = v204;
          *(_DWORD *)&v228[171] = v226[0];
          v228[175] = BYTE4(v226[0]);
          *(void *)&v228[176] = v203;
          *(void *)&v228[184] = v194;
          *(void *)&v228[192] = a2 - v194;
          *(void *)&v228[200] = v179;
          uint64_t v18 = fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, (uint64_t)&v209);
          double v184 = *((double *)&v209 + 1);
          uint64_t v183 = v209;
          a4 = v199;
        }
        else
        {
          unint64_t v181 = *((void *)&v203 + 1);
        }
      }
      else
      {
        if (v178)
        {
          unint64_t v181 = *((void *)&v203 + 1);
          unint64_t v182 = a2 - *((void *)&v203 + 1);
          if (v178 > (uint64_t)(a2 - *((void *)&v203 + 1))) {
            unint64_t v182 = v178;
          }
        }
        else
        {
          unint64_t v182 = a2 - *(void *)(CMBaseObjectGetDerivedStorage(*v180) + 16);
          unint64_t v181 = *((void *)&v203 + 1);
        }
        *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
        *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
        *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
        *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
        *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
        *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
        *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
        *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
        long long v227 = v229;
        *(_OWORD *)unsigned int v228 = v230;
        *(_OWORD *)&v228[16] = *(_OWORD *)v231;
        *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
        v228[169] = 0;
        v228[170] = v204;
        *(_DWORD *)&v228[171] = v226[0];
        v228[175] = BYTE4(v226[0]);
        *(void *)&v228[176] = v203;
        *(void *)&v228[184] = v181;
        *(void *)&v228[192] = v182;
        *(void *)&v228[200] = v179;
        uint64_t v18 = fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, (uint64_t)&v209);
        double v184 = *((double *)&v209 + 1);
        uint64_t v183 = v209;
      }
      if (v184 <= 0.0) {
        double v195 = 1.0;
      }
      else {
        double v195 = 1.0 / v184;
      }
      *(double *)&long long v214 = v195;
      *(void *)&long long v213 = v181;
      *((void *)&v213 + 1) = v183;
      long long v196 = v212;
      *(_OWORD *)(a4 + 32) = v211;
      *(_OWORD *)(a4 + 48) = v196;
      long long v197 = v210;
      *(_OWORD *)a4 = v209;
      *(_OWORD *)(a4 + 16) = v197;
      *(_OWORD *)(a4 + 64) = v213;
      *(void *)(a4 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v214;
      if (v18) {
        goto LABEL_80;
      }
      goto LABEL_31;
    default:
      uint64_t v23 = FigSignalErrorAt(4294949561, 0, 0, 0, 0, 0, 0);
LABEL_11:
      uint64_t v18 = v23;
      if (v23) {
        goto LABEL_80;
      }
      goto LABEL_31;
  }
  fnhp_makeSafeBandwidthMultiplier((uint64_t)&v227, (uint64_t)v85);
  *(void *)(a4 + 24) = v120;
LABEL_30:
  if (!v18)
  {
LABEL_31:
    if ((*(unsigned char *)(a3 + 8) & 1) == 0 || *(unsigned char *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 34)) {
      goto LABEL_77;
    }
    uint64_t v121 = *(void *)(a3 + 16);
    uint64_t v122 = *(void *)(a3 + 24);
    uint64_t v201 = a3;
    unsigned int v123 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
    uint64_t v124 = *(void *)(CMBaseObjectGetDerivedStorage(*v123) + 24);
    memset(v228, 0, 32);
    long long v227 = 0u;
    FigNetworkHistoryBeginImmutabilty(*v123);
    if (v122) {
      uint64_t v125 = v122;
    }
    else {
      uint64_t v125 = v121;
    }
    if (!FigNetworkHistoryGetFirstBandwidthSampleAfterTime((const void *)*v123, (uint64_t)(a2 - v125) / v124 * v124, v124, a2, (uint64_t)&v227))
    {
      FigNetworkHistoryEndImmutability(*v123);
      goto LABEL_76;
    }
    int v127 = (uint64_t *)a4;
    uint64_t v128 = 0;
    uint64_t v129 = 0;
    uint64_t v130 = 0;
    double v131 = 0.0;
    double v132 = 0.0;
    double v133 = 0.0;
    while (1)
    {
      uint64_t v134 = *(void *)&v228[8];
      uint64_t v135 = *(void *)&v228[16];
      int NextBandwidthSample = FigNetworkHistoryGetNextBandwidthSample(*v123, *(uint64_t **)&v228[24], v124, v126, (uint64_t)&v227);
      if (v124 != v135) {
        goto LABEL_49;
      }
      double v133 = v133 + 1.0;
      double v137 = (double)(8 * v134) / ((double)v124 / 1000000000.0);
      if (v133 <= 2.22044605e-16)
      {
        double v131 = v131 + (v137 - v132) * v137;
        double v132 = 0.0;
      }
      else
      {
        double v138 = v137 - v132;
        double v132 = v132 + 1.0 / v133 * (v137 - v132);
        double v131 = v131 + v138 * (v137 - v132);
        if (v131 > 2.22044605e-16)
        {
          double v139 = sqrt(v131 / v133);
          goto LABEL_42;
        }
      }
      double v139 = 0.0;
LABEL_42:
      ++v129;
      if (v139 / v132 <= 0.05)
      {
        uint64_t v140 = v128 + 1;
        if (v128 > 1)
        {
          if (v137 < (double)v130) {
            double v137 = (double)v130;
          }
          uint64_t v130 = (uint64_t)v137;
          goto LABEL_69;
        }
        ++v128;
      }
      else
      {
        uint64_t v128 = 0;
      }
LABEL_49:
      if (v128) {
        uint64_t v140 = v128;
      }
      else {
        uint64_t v140 = 0;
      }
      if (v128) {
        double v141 = v133;
      }
      else {
        double v141 = 0.0;
      }
      if (v128) {
        double v142 = v132;
      }
      else {
        double v142 = 0.0;
      }
      if (v128) {
        double v143 = v131;
      }
      else {
        double v143 = 0.0;
      }
      if (v128) {
        uint64_t v144 = v129;
      }
      else {
        uint64_t v144 = 0;
      }
      if (v129 >= 1)
      {
        double v133 = v141;
        double v132 = v142;
      }
      else
      {
        uint64_t v140 = v128;
      }
      if (v129 >= 1)
      {
        double v131 = v143;
        uint64_t v129 = v144;
      }
LABEL_69:
      uint64_t v128 = v140;
      if (!NextBandwidthSample)
      {
        FigNetworkHistoryEndImmutability(*v123);
        a4 = (uint64_t)v127;
        if (v130 >= 1 && v130 < *v127)
        {
          *int v127 = v130;
          v127[3] = 0x3FEE666666666666;
        }
LABEL_76:
        a3 = v201;
LABEL_77:
        if ((*(unsigned char *)(a3 + 8) & 2) == 0 || *(unsigned char *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 34))
        {
          uint64_t v18 = 0;
          break;
        }
        unsigned int v198 = (void *)a4;
        uint64_t v146 = *(void *)(a3 + 16);
        uint64_t v147 = *(void *)(a3 + 24);
        int v148 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
        uint64_t v149 = *(void *)(CMBaseObjectGetDerivedStorage(*v148) + 24);
        memset(v228, 0, 32);
        long long v227 = 0u;
        FigNetworkHistoryBeginImmutabilty(*v148);
        if (v147) {
          uint64_t v150 = v147;
        }
        else {
          uint64_t v150 = v146;
        }
        if (!FigNetworkHistoryGetFirstBandwidthSampleAfterTime((const void *)*v148, (uint64_t)(a2 - v150) / v149 * v149, v149, a2, (uint64_t)&v227))
        {
          FigNetworkHistoryEndImmutability(*v148);
          uint64_t v18 = 4294949557;
          break;
        }
        unsigned int v200 = DerivedStorage;
        uint64_t v152 = 0;
        uint64_t v153 = 0;
        uint64_t v154 = 0;
        char v155 = 0;
        uint64_t v156 = 0;
        double v157 = 0.0;
        double v158 = 0.0;
        double v159 = 0.0;
        while (1)
        {
LABEL_86:
          uint64_t v160 = *(void *)&v228[8];
          uint64_t v161 = *(void *)&v228[16];
          int v162 = FigNetworkHistoryGetNextBandwidthSample(*v148, *(uint64_t **)&v228[24], v149, v151, (uint64_t)&v227);
          if (v149 == v161 && v160 >= 1 && v153 <= 10)
          {
            ++v153;
            v154 += v160;
LABEL_105:
            if (!v162) {
              goto LABEL_111;
            }
            continue;
          }
          if (v153 < 1) {
            goto LABEL_105;
          }
          if ((unint64_t)v153 >= 3) {
            break;
          }
          uint64_t v154 = 0;
          uint64_t v153 = 0;
          if (!v162) {
            goto LABEL_111;
          }
        }
        double v159 = v159 + 1.0;
        double v165 = (double)(8 * v154 / v153) / ((double)v149 / 1000000000.0);
        double v166 = v165 - v158;
        if (v159 <= 2.22044605e-16)
        {
          double v157 = v157 + v166 * v165;
          double v158 = 0.0;
        }
        else
        {
          double v158 = v158 + 1.0 / v159 * v166;
          double v157 = v157 + v166 * (v165 - v158);
          if (v157 > 2.22044605e-16)
          {
            double v167 = sqrt(v157 / v159);
            goto LABEL_98;
          }
        }
        double v167 = 0.0;
LABEL_98:
        uint64_t v154 = 0;
        uint64_t v153 = 0;
        BOOL v168 = v152 > 1;
        BOOL v169 = v167 / v158 <= 0.05;
        double v170 = (double)v156;
        if (v158 >= (double)v156) {
          double v170 = v158;
        }
        ++v152;
        if (v168 && v169)
        {
          uint64_t v156 = (uint64_t)v170;
          char v155 = 1;
        }
        if (!v162)
        {
LABEL_111:
          FigNetworkHistoryEndImmutability(*v148);
          if (v155)
          {
            uint64_t v18 = 0;
            *unsigned int v198 = v156;
            v198[3] = 0x3FEE666666666666;
          }
          else
          {
            uint64_t v18 = 4294949557;
          }
          uint64_t DerivedStorage = v200;
          break;
        }
        goto LABEL_86;
      }
    }
  }
LABEL_80:
  FigNetworkHistoryEndImmutability(*DerivedStorage);
  return v18;
}

uint64_t fnhp_constantLatencyPredictionAlgorithm(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  long long v6 = a3[11];
  long long v37 = a3[10];
  long long v38 = v6;
  long long v7 = a3[13];
  long long v39 = a3[12];
  long long v40 = v7;
  long long v8 = a3[7];
  long long v33 = a3[6];
  long long v34 = v8;
  long long v9 = a3[9];
  long long v35 = a3[8];
  long long v36 = v9;
  long long v10 = a3[3];
  long long v29 = a3[2];
  long long v30 = v10;
  long long v11 = a3[5];
  long long v31 = a3[4];
  long long v32 = v11;
  long long v12 = a3[1];
  long long v27 = *a3;
  long long v28 = v12;
  uint64_t v13 = fnhp_timeWeightedConstantLatencyPredictionAlgorithm(a1, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_constantWeightForBandwidthSample, 0, a2, &v27, a4);
  if (!v13)
  {
    long long v14 = a3[11];
    long long v37 = a3[10];
    long long v38 = v14;
    long long v15 = a3[13];
    long long v39 = a3[12];
    long long v40 = v15;
    long long v16 = a3[7];
    long long v33 = a3[6];
    long long v34 = v16;
    long long v17 = a3[9];
    long long v35 = a3[8];
    long long v36 = v17;
    long long v18 = a3[3];
    long long v29 = a3[2];
    long long v30 = v18;
    long long v19 = a3[5];
    long long v31 = a3[4];
    long long v32 = v19;
    long long v20 = a3[1];
    long long v27 = *a3;
    long long v28 = v20;
    long long v21 = *(_OWORD *)(a4 + 48);
    v25[2] = *(_OWORD *)(a4 + 32);
    v25[3] = v21;
    v25[4] = *(_OWORD *)(a4 + 64);
    uint64_t v26 = *(void *)(a4 + 80);
    long long v22 = *(_OWORD *)(a4 + 16);
    v25[0] = *(_OWORD *)a4;
    v25[1] = v22;
    fnhp_makeSafeBandwidthMultiplier((uint64_t)&v27, (uint64_t)v25);
    *(void *)(a4 + 24) = v23;
  }
  return v13;
}

void fnhp_medianAlgorithmForLatency(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, void *a5, double *a6, void *a7)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v15 = CMBaseObjectGetDerivedStorage(*(void *)DerivedStorage);
  long long v16 = a3[11];
  long long v58 = a3[10];
  long long v59 = v16;
  long long v17 = a3[13];
  long long v60 = a3[12];
  long long v61 = v17;
  long long v18 = a3[7];
  long long v54 = a3[6];
  long long v55 = v18;
  long long v19 = a3[9];
  long long v56 = a3[8];
  long long v57 = v19;
  long long v20 = a3[3];
  long long v50 = a3[2];
  long long v51 = v20;
  long long v21 = a3[5];
  long long v52 = a3[4];
  long long v53 = v21;
  long long v22 = a3[1];
  long long v48 = *a3;
  long long v49 = v22;
  uint64_t StartTimestamp = fnhp_getStartTimestamp(a1, a2, (uint64_t)&v48, a4);
  long long v48 = 0uLL;
  *(void *)&long long v49 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  long long v25 = malloc_type_calloc(*(void *)(v15 + 96), 8uLL, 0x100004000313F17uLL);
  if (v25)
  {
    if (FigNetworkHistoryGetFirstLatencySampleAfterTime(*(void *)DerivedStorage, StartTimestamp, v24, &v48))
    {
      uint64_t v26 = *(void *)DerivedStorage;
      uint64_t v27 = CMBaseObjectGetDerivedStorage(*(void *)DerivedStorage);
      FigSimpleMutexLock(*(pthread_mutex_t **)v27);
      if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(v26) + 120) < 1) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = *(void *)(v27 + 104);
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)v27);
      uint64_t v29 = v49;
      uint64_t v30 = CMBaseObjectGetDerivedStorage(a1);
      if (v29 != *(void *)(v30 + 32) || *(void *)(v30 + 24) != v28)
      {
        uint64_t v32 = 0;
        uint64_t v33 = 0;
        *(void *)(DerivedStorage + 32) = v29;
        double v34 = 0.0;
        double v35 = 0.0;
        do
        {
          uint64_t v36 = v48;
          long long v37 = (void *)v49;
          v25[v32++] = v48;
          v33 += v36;
          double v38 = (double)v32;
          double v39 = (double)v36 - v35;
          double v35 = v35 + 1.0 / (double)v32 * v39;
          double v34 = v34 + v39 * ((double)v36 - v35);
        }
        while (FigNetworkHistoryGetNextValidLatencySample(*(void *)DerivedStorage, v37, v31, &v48));
        *(void *)(DerivedStorage + 24) = v28;
        long long v40 = malloc_type_calloc(v32, 8uLL, 0x10040436913F5uLL);
        long long v41 = v40;
        if (v40)
        {
          uint64_t v42 = 0;
          long long v43 = v25;
          do
            *((void *)v40 + v42++) = v43++;
          while (v32 != v42);
          MedianValueOfCArray = (uint64_t *)FigGetMedianValueOfCArray((uint64_t)v40, v32, (uint64_t (*)(void, uint64_t, void))fnhp_compareInt64, (uint64_t (*)(const void *, uint64_t))fnhp_averageInt64, 8uLL);
          CMTimeValue v45 = MedianValueOfCArray;
          if (MedianValueOfCArray) {
            uint64_t v46 = *MedianValueOfCArray;
          }
          else {
            uint64_t v46 = 0;
          }
        }
        else
        {
          uint64_t v46 = 0;
          CMTimeValue v45 = 0;
        }
        free(v41);
        free(v45);
        *(void *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v46;
        if (v34 <= 2.22044605e-16) {
          uint64_t v47 = 0;
        }
        else {
          uint64_t v47 = (uint64_t)sqrt(v34 / v38);
        }
        *(void *)(DerivedStorage + 48) = v47;
        *(void *)(DerivedStorage + 56) = v33;
      }
      if (a5) {
        *a5 = *(void *)(DerivedStorage + 40);
      }
      if (a6) {
        *a6 = (double)*(uint64_t *)(DerivedStorage + 48);
      }
      if (a7) {
        *a7 = *(void *)(DerivedStorage + 56);
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));

  free(v25);
}

CFIndex fnhp_makeSafeBandwidthMultiplier(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a1 + 128);
  *(_OWORD *)long long v9 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)long long v10 = v4;
  *(_OWORD *)long long v11 = *(_OWORD *)(a1 + 144);
  memset(__s2, 0, sizeof(__s2));
  long long v5 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)CFArrayRef theArray = *(_OWORD *)(a1 + 80);
  *(_OWORD *)long long v8 = v5;
  CFIndex result = memcmp(theArray, __s2, 0x50uLL);
  if (result)
  {
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(theArray[0], (double)*(uint64_t *)(a1 + 72));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(theArray[1], (double)*(uint64_t *)a2);
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v8[0], *(double *)(a2 + 8) / (double)*(uint64_t *)a2);
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v8[1], *(double *)(a2 + 8) / sqrt((double)*(uint64_t *)(a2 + 48)));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v9[1], (double)*(uint64_t *)(a2 + 32));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v10[0], *(double *)(a2 + 40) / (double)*(uint64_t *)(a2 + 32));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v10[1], *(double *)(a2 + 40) / sqrt((double)*(uint64_t *)(a2 + 48)));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v11[0], (double)*(uint64_t *)(a2 + 48));
    return fnhp_makeSafeBandwidthMultiplierForSingleVariable(v9[0], *(double *)(a2 + 16) / (double)*(uint64_t *)a2);
  }
  return result;
}

uint64_t fnhp_getStartTimestamp(uint64_t a1, uint64_t LastActiveTimestamp, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a3 + 160))
  {
    uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
    LastActiveTimestamp = FigNetworkHistoryGetLastActiveTimestamp(*DerivedStorage, LastActiveTimestamp);
  }
  return (LastActiveTimestamp - fnhp_getWindowSize(a1, *(void *)(a3 + 16))) / a4 * a4;
}

uint64_t fnhp_getWindowSize(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  if (a2 <= 0) {
    return *(void *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 16);
  }
  return a2;
}

unint64_t fnhp_compareInt64(void *a1, void *a2)
{
  return (*a1 > *a2) - (unint64_t)(*a1 < *a2);
}

void *fnhp_averageInt64(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  CFIndex result = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (result)
  {
    if (v3 >= 0) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = v3 + 1;
    }
    if (v2 >= 0) {
      uint64_t v6 = v2;
    }
    else {
      uint64_t v6 = v2 + 1;
    }
    *CFIndex result = v3 + v2 - (v6 >> 1) - (v5 >> 1);
  }
  return result;
}

uint64_t fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, double (*a5)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a6, uint64_t *a7, double *a8, double *a9, uint64_t *a10)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  unint64_t v19 = *(void *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 24);
  uint64_t v50 = 0;
  long long v20 = a4[11];
  long long v46 = a4[10];
  long long v47 = v20;
  long long v21 = a4[13];
  long long v48 = a4[12];
  long long v49 = v21;
  long long v22 = a4[7];
  long long v42 = a4[6];
  long long v43 = v22;
  long long v23 = a4[9];
  long long v44 = a4[8];
  long long v45 = v23;
  long long v24 = a4[3];
  long long v38 = a4[2];
  long long v39 = v24;
  long long v25 = a4[5];
  long long v40 = a4[4];
  long long v41 = v25;
  long long v26 = a4[1];
  long long v36 = *a4;
  long long v37 = v26;
  uint64_t result = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidthHelper(a1, a2, a3, (uint64_t)&v36, a5, a6, 0, v19, 0.0, &v50, 0, 0, a10);
  if (!result)
  {
    if (v19 <= 0x3B9ACA00) {
      uint64_t v28 = 1000000000;
    }
    else {
      uint64_t v28 = v19;
    }
    long long v29 = a4[11];
    long long v46 = a4[10];
    long long v47 = v29;
    long long v30 = a4[13];
    long long v48 = a4[12];
    long long v49 = v30;
    long long v31 = a4[7];
    long long v42 = a4[6];
    long long v43 = v31;
    long long v32 = a4[9];
    long long v44 = a4[8];
    long long v45 = v32;
    long long v33 = a4[3];
    long long v38 = a4[2];
    long long v39 = v33;
    long long v34 = a4[5];
    long long v40 = a4[4];
    long long v41 = v34;
    long long v35 = a4[1];
    long long v36 = *a4;
    long long v37 = v35;
    uint64_t result = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidthHelper(a1, a2, a3, (uint64_t)&v36, a5, a6, fnhp_bwSampleVariainceLimitingAtMean, v28, (double)v50, 0, a8, a9, 0);
    if (!result) {
      *a7 = v50;
    }
  }
  return result;
}

double fnhp_constantWeightForBandwidthSample()
{
  return 1.0;
}

uint64_t fnhp_constantLatencyTimeWeightedAlgorithmForBandwidthHelper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double (*a5)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a6, double (*a7)(double, double), uint64_t a8, double a9, void *a10, double *a11, double *a12, uint64_t *a13)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t StartTimestamp = *(void *)(a4 + 208);
  if (!StartTimestamp)
  {
    long long v20 = *(_OWORD *)(a4 + 160);
    long long v21 = *(_OWORD *)(a4 + 192);
    long long v22 = *(_OWORD *)(a4 + 208);
    long long v172 = *(_OWORD *)(a4 + 176);
    long long v173 = v21;
    long long v174 = v22;
    long long v23 = *(_OWORD *)(a4 + 96);
    long long v24 = *(_OWORD *)(a4 + 128);
    long long v25 = *(_OWORD *)(a4 + 144);
    long long v168 = *(_OWORD *)(a4 + 112);
    long long v169 = v24;
    long long v170 = v25;
    long long v171 = v20;
    long long v26 = *(_OWORD *)(a4 + 48);
    v163[2] = *(int64x2_t *)(a4 + 32);
    long long v164 = v26;
    long long v27 = *(_OWORD *)(a4 + 80);
    long long v165 = *(_OWORD *)(a4 + 64);
    long long v166 = v27;
    long long v167 = v23;
    int64x2_t v28 = *(int64x2_t *)(a4 + 16);
    v163[0] = *(int64x2_t *)a4;
    v163[1] = v28;
    uint64_t StartTimestamp = fnhp_getStartTimestamp(a1, a3, (uint64_t)v163, a8);
  }
  uint64_t WindowSize = fnhp_getWindowSize(a1, *(void *)(a4 + 16));
  uint64_t v30 = a3 - StartTimestamp;
  if (WindowSize > a3 - StartTimestamp) {
    uint64_t v30 = fnhp_getWindowSize(a1, *(void *)(a4 + 16));
  }
  uint64_t v115 = StartTimestamp;
  if (*(void *)(a4 + 216)) {
    uint64_t v31 = *(void *)(a4 + 216);
  }
  else {
    uint64_t v31 = v30;
  }
  int64x2_t v161 = 0u;
  int64x2_t v162 = 0u;
  int64x2_t v160 = 0u;
  if (a2 >= 0) {
    uint64_t v32 = a2;
  }
  else {
    uint64_t v32 = a2 + 1;
  }
  uint64_t v33 = *(void *)(a4 + 32);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(void *)(a4 + 16)) {
    *(void *)(a4 + 16) = *(void *)(CMBaseObjectGetDerivedStorage(*(void *)DerivedStorage) + 16);
  }
  long long v34 = *(_OWORD *)(a4 + 160);
  long long v35 = *(_OWORD *)(a4 + 192);
  long long v36 = *(_OWORD *)(a4 + 208);
  long long v172 = *(_OWORD *)(a4 + 176);
  long long v173 = v35;
  long long v174 = v36;
  long long v37 = *(_OWORD *)(a4 + 96);
  long long v38 = *(_OWORD *)(a4 + 128);
  long long v39 = *(_OWORD *)(a4 + 144);
  long long v168 = *(_OWORD *)(a4 + 112);
  long long v169 = v38;
  long long v170 = v39;
  long long v171 = v34;
  long long v40 = *(_OWORD *)(a4 + 48);
  v163[2] = *(int64x2_t *)(a4 + 32);
  long long v164 = v40;
  long long v41 = *(_OWORD *)(a4 + 80);
  long long v165 = *(_OWORD *)(a4 + 64);
  long long v166 = v41;
  long long v167 = v37;
  int64x2_t v42 = *(int64x2_t *)(a4 + 16);
  v163[0] = *(int64x2_t *)a4;
  v163[1] = v42;
  uint64_t v43 = CMBaseObjectGetDerivedStorage(a1);
  BandwidthPredictionCacheuint64_t Key = fnhp_createBandwidthPredictionCacheKey(v163[0].i64, a8);
  double v128 = 0.0;
  uint64_t v152 = DerivedStorage;
  if (!BandwidthPredictionCacheKey
    || (CFNumberRef v45 = BandwidthPredictionCacheKey,
        CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v43 + 16), BandwidthPredictionCacheKey),
        CFRelease(v45),
        !Value))
  {
    uint64_t v121 = 0;
    uint64_t v122 = 0;
    uint64_t v118 = 0;
    int64x2_t v127 = 0uLL;
    uint64_t v125 = 0;
    uint64_t v126 = 0;
    uint64_t v124 = 0;
    uint64_t v116 = 0;
    double v119 = 0.0;
    double v120 = 0.0;
    double v123 = 0.0;
    double v117 = 0.0;
    goto LABEL_29;
  }
  double v128 = *(double *)Value;
  uint64_t v47 = *((void *)Value + 3);
  uint64_t v121 = *((void *)Value + 4);
  uint64_t v122 = *((void *)Value + 2);
  double v119 = *((double *)Value + 5);
  double v120 = *((double *)Value + 1);
  double v123 = *((double *)Value + 6);
  double v117 = *((double *)Value + 7);
  int64x2_t v127 = *((int64x2_t *)Value + 4);
  uint64_t v125 = *((void *)Value + 11);
  uint64_t v126 = *((void *)Value + 10);
  uint64_t v124 = *((void *)Value + 12);
  uint64_t v116 = *((void *)Value + 13);
  long long v48 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  memset(v163, 0, sizeof(v163));
  uint64_t v118 = v47;
  if (v47 != v115)
  {
LABEL_29:
    long long v59 = *(_OWORD *)(a4 + 160);
    long long v60 = *(_OWORD *)(a4 + 192);
    long long v61 = *(_OWORD *)(a4 + 208);
    long long v172 = *(_OWORD *)(a4 + 176);
    long long v173 = v60;
    long long v174 = v61;
    long long v62 = *(_OWORD *)(a4 + 96);
    long long v63 = *(_OWORD *)(a4 + 128);
    long long v64 = *(_OWORD *)(a4 + 144);
    long long v168 = *(_OWORD *)(a4 + 112);
    long long v169 = v63;
    long long v170 = v64;
    long long v171 = v59;
    long long v65 = *(_OWORD *)(a4 + 48);
    v163[2] = *(int64x2_t *)(a4 + 32);
    long long v164 = v65;
    long long v66 = *(_OWORD *)(a4 + 80);
    long long v165 = *(_OWORD *)(a4 + 64);
    long long v166 = v66;
    long long v167 = v62;
    int64x2_t v67 = *(int64x2_t *)(a4 + 16);
    v163[0] = *(int64x2_t *)a4;
    v163[1] = v67;
    uint64_t v68 = CMBaseObjectGetDerivedStorage(a1);
    CFNumberRef v69 = fnhp_createBandwidthPredictionCacheKey(v163[0].i64, a8);
    if (v69)
    {
      CFNumberRef v70 = v69;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v68 + 16), v69);
      CFRelease(v70);
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v155 = 0;
    uint64_t v156 = 0;
    double v57 = 0.0;
    int v147 = 1;
    double v58 = 0.0;
    double v56 = 0.0;
    uint64_t v71 = v115;
LABEL_32:
    if (!FigNetworkHistoryGetFirstBandwidthSampleAfterTime(*(const void **)DerivedStorage, v71, a8, a3, (uint64_t)&v160))
    {
      uint64_t v99 = 4294949559;
      goto LABEL_94;
    }
    goto LABEL_33;
  }
  long long v49 = (const void *)*v48;
  uint64_t v50 = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(*v48);
  FigSimpleMutexLock(*v50);
  FirstBytesReceivedEntryAfterTime = (uint64_t *)fnh_getFirstBytesReceivedEntryAfterTime(v49, v127.i64[1] - a8 + 1, a3, 1);
  if (!FirstBytesReceivedEntryAfterTime)
  {
    FigSimpleMutexUnlock(*v50);
    goto LABEL_29;
  }
  int v52 = fnh_populateBandwidthSampleFromBytesReceivedEntry((uint64_t)v49, FirstBytesReceivedEntryAfterTime, a8, (uint64_t)v163);
  FigSimpleMutexUnlock(*v50);
  if (!v52) {
    goto LABEL_29;
  }
  v54.i64[0] = v125;
  v54.i64[1] = v124;
  BOOL v55 = (~vaddv_s16((int16x4_t)vand_s8((int8x8_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64(v127, v163[0]), (int32x4_t)vceqq_s64(v54, *(int64x2_t *)((char *)&v163[1] + 8)))), 0xFuLL)), (int8x8_t)0x8000400020001)) & 0xF) == 0&& v126 == v163[1].i64[0];
  if (!v55 || a7 && v117 < vabdd_f64(v123, a9)) {
    goto LABEL_29;
  }
  int v147 = 0;
  if (!FigNetworkHistoryGetNextBandwidthSample(*(void *)DerivedStorage, (uint64_t *)v163[2].i64[1], a8, v53, (uint64_t)&v160))
  {
    uint64_t v71 = v127.i64[1] + 1;
    uint64_t v118 = v115;
    a9 = v123;
    uint64_t v155 = v121;
    uint64_t v156 = v122;
    double v57 = v119;
    double v56 = v120;
    double v58 = v128;
    goto LABEL_32;
  }
  uint64_t v118 = v115;
  a9 = v123;
  uint64_t v155 = v121;
  uint64_t v156 = v122;
  double v57 = v119;
  double v56 = v120;
  double v58 = v128;
LABEL_33:
  uint64_t v153 = a8;
  uint64_t v154 = a4;
  uint64_t v114 = 8 * v33;
  uint64_t LastActiveTimestamp = FigNetworkHistoryGetLastActiveTimestamp(*(void *)DerivedStorage, a3);
  uint64_t v159 = 0;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v140 = 0;
  uint64_t v141 = 0;
  uint64_t v138 = 0;
  uint64_t v139 = 0;
  int v142 = 0;
  int v146 = 0;
  uint64_t v133 = 0;
  uint64_t v134 = 0;
  uint64_t v135 = 0;
  uint64_t v136 = 0;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v137 = 0;
  double v145 = 0.0;
  double v129 = 0.0;
  double v130 = 0.0;
  double v131 = 0.0;
  double v132 = 0.0;
  uint64_t v148 = LastActiveTimestamp - v31;
  uint64_t v149 = LastActiveTimestamp;
  double v79 = 0.0;
  do
  {
    int64x2_t v80 = v161;
    int64x2_t v81 = v162;
    uint64_t v157 = v160.i64[1];
    uint64_t v158 = v160.i64[0];
    v163[0] = v160;
    v163[1] = v161;
    v163[2] = v162;
    double v83 = a5(v163, v148, v149, v154, a6);
    if (v83 < 0.0)
    {
      uint64_t v99 = FigSignalErrorAt(4294949561, 0, 0, 0, 0, 0, 0);
      goto LABEL_94;
    }
    double v84 = v83;
    int NextBandwidthSample = FigNetworkHistoryGetNextBandwidthSample(*(void *)v152, (uint64_t *)v81.i64[1], v153, v82, (uint64_t)&v160);
    if (v147)
    {
      if (NextBandwidthSample && v159)
      {
        if (v142)
        {
          int v146 = 1;
          double v128 = v132;
          uint64_t v118 = v134;
          uint64_t v121 = v133;
          uint64_t v122 = v135;
          double v119 = v130;
          double v120 = v131;
          double v123 = v129;
          double v117 = v145;
          v127.i64[0] = v141;
          v127.i64[1] = v140;
          uint64_t v125 = v138;
          uint64_t v126 = v139;
          uint64_t v124 = v137;
          uint64_t v116 = v136;
        }
        double v145 = 0.0;
        if (v56 <= 2.22044605e-16 || v57 <= 2.22044605e-16)
        {
          int v142 = 1;
          uint64_t v140 = v74;
          uint64_t v141 = v75;
          uint64_t v138 = v78;
          uint64_t v139 = v73;
          uint64_t v136 = v76;
          uint64_t v137 = v77;
          double v131 = v56;
          double v132 = v58;
          uint64_t v135 = v156;
        }
        else
        {
          int v142 = 1;
          uint64_t v140 = v74;
          uint64_t v141 = v75;
          uint64_t v138 = v78;
          uint64_t v139 = v73;
          uint64_t v136 = v76;
          uint64_t v137 = v77;
          double v131 = v56;
          double v132 = v58;
          uint64_t v135 = v156;
          double v145 = sqrt(v57 / v56);
        }
        uint64_t v133 = v155;
        uint64_t v134 = v115;
        double v129 = a9;
        double v130 = v57;
      }
      else if (v146)
      {
        int v86 = NextBandwidthSample;
        long long v87 = *(_OWORD *)(v154 + 160);
        long long v88 = *(_OWORD *)(v154 + 192);
        long long v89 = *(_OWORD *)(v154 + 208);
        long long v172 = *(_OWORD *)(v154 + 176);
        long long v173 = v88;
        long long v174 = v89;
        long long v90 = *(_OWORD *)(v154 + 96);
        long long v91 = *(_OWORD *)(v154 + 128);
        long long v92 = *(_OWORD *)(v154 + 144);
        long long v168 = *(_OWORD *)(v154 + 112);
        long long v169 = v91;
        long long v170 = v92;
        long long v171 = v87;
        long long v93 = *(_OWORD *)(v154 + 48);
        v163[2] = *(int64x2_t *)(v154 + 32);
        long long v164 = v93;
        long long v94 = *(_OWORD *)(v154 + 80);
        long long v165 = *(_OWORD *)(v154 + 64);
        long long v166 = v94;
        long long v167 = v90;
        int64x2_t v95 = *(int64x2_t *)(v154 + 16);
        v163[0] = *(int64x2_t *)v154;
        v163[1] = v95;
        uint64_t v96 = CMBaseObjectGetDerivedStorage(a1);
        CFNumberRef v97 = fnhp_createBandwidthPredictionCacheKey(v163[0].i64, v153);
        long long v98 = (double *)malloc_type_calloc(1uLL, 0x70uLL, 0x1000040AC4F46D1uLL);
        if (v97)
        {
          if (v98)
          {
            *long long v98 = v128;
            v98[1] = v120;
            *((void *)v98 + 2) = v122;
            *((void *)v98 + 3) = v118;
            *((void *)v98 + 4) = v121;
            v98[5] = v119;
            v98[6] = v123;
            v98[7] = v117;
            *((int64x2_t *)v98 + 4) = v127;
            *((void *)v98 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v126;
            *((void *)v98 + 11) = v125;
            *((void *)v98 + 12) = v124;
            *((void *)v98 + 13) = v116;
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v96 + 16), v97, v98);
            uint64_t v99 = 0;
          }
          else
          {
            uint64_t v99 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          }
          CFRelease(v97);
          if (v99) {
            goto LABEL_94;
          }
        }
        else
        {
          uint64_t v99 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          if (v99) {
            goto LABEL_94;
          }
        }
        int NextBandwidthSample = v86;
        int v146 = 1;
      }
      else
      {
        int v146 = 0;
      }
    }
    if (v81.i64[0] >= 1)
    {
      double v100 = v84 * (double)v81.i64[0];
      double v56 = v56 + v100;
      double v101 = (double)(8 * v80.i64[1]) / ((double)v81.i64[0] / 1000000000.0);
      if (v56 <= 2.22044605e-16) {
        double v102 = 0.0;
      }
      else {
        double v102 = v58 + v100 / v56 * (v101 - v58);
      }
      if (a7)
      {
        int v103 = NextBandwidthSample;
        double v104 = a7((double)(8 * v80.i64[1]) / ((double)v81.i64[0] / 1000000000.0), a9);
        int NextBandwidthSample = v103;
        double v79 = v79 + v100 * (v104 - v58) * (v104 - v102);
      }
      double v57 = v57 + (v101 - v58) * v100 * (v101 - v102);
      v155 += v80.i64[1];
      v156 += v81.i64[0];
      double v58 = v102;
    }
    uint64_t v75 = v158;
    --v159;
    uint64_t v73 = v80.i64[0];
    uint64_t v74 = v157;
    uint64_t v76 = v81.i64[1];
    uint64_t v77 = v81.i64[0];
    uint64_t v78 = v80.i64[1];
  }
  while (NextBandwidthSample);
  uint64_t v106 = *(void *)(v154 + 56);
  uint64_t v105 = *(void *)(v154 + 64);
  BOOL v108 = v106 > 0 && v106 <= v155;
  if (v106) {
    BOOL v109 = v108;
  }
  else {
    BOOL v109 = v105 == 0;
  }
  if (v105 < 1)
  {
    if (v109) {
      goto LABEL_78;
    }
LABEL_96:
    uint64_t v99 = 4294949558;
    goto LABEL_94;
  }
  char v110 = v105 <= v156 || v109;
  if ((v110 & 1) == 0) {
    goto LABEL_96;
  }
LABEL_78:
  if (*(void *)(v154 + 32)) {
    double v58 = (double)v114 / ((double)(v32 >> 1) / 1000000000.0 + (double)v114 / v58);
  }
  double v111 = 0.0;
  double v112 = 0.0;
  if (v56 > 2.22044605e-16)
  {
    double v112 = 0.0;
    if (v57 > 2.22044605e-16) {
      double v112 = sqrt(v57 / v56);
    }
  }
  if (v56 > 2.22044605e-16 && v79 > 2.22044605e-16) {
    double v111 = sqrt(v79 / v56);
  }
  if (a10) {
    *a10 = llround(v58);
  }
  if (a11) {
    *a11 = v112;
  }
  if (a12) {
    *a12 = v111;
  }
  uint64_t v99 = 0;
  if (a13) {
    *a13 = v156;
  }
LABEL_94:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v152 + 8));
  return v99;
}

double fnhp_bwSampleVariainceLimitingAtMean(double result, double a2)
{
  if (result >= a2) {
    return a2;
  }
  return result;
}

CFNumberRef fnhp_createBandwidthPredictionCacheKey(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[2];
  long long v4 = *(_OWORD *)(a1 + 5);
  valuePtr[1] = 0;
  long long v7 = 0u;
  uint64_t v19 = 0;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  valuePtr[0] = v2;
  valuePtr[2] = v3;
  if (v2 == 4) {
    long long v8 = v4;
  }
  uint64_t v20 = a2;
  valuePtr[0] = CFHashBytes();
  return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongLongType, valuePtr);
}

CFIndex fnhp_makeSafeBandwidthMultiplierForSingleVariable(CFArrayRef theArray, long double a2)
{
  CFIndex v4 = 0;
  double v5 = 0.0;
  if (!theArray) {
    goto LABEL_3;
  }
LABEL_2:
  for (CFIndex result = CFArrayGetCount(theArray); v4 < result; CFIndex result = 0)
  {
    double v8 = 0.0;
    if (FigCFArrayGetDoubleAtIndex(theArray, v4, &v8))
    {
      double v7 = v8;
      double v5 = v5 + v7 * pow(a2, (double)v4);
    }
    ++v4;
    if (theArray) {
      goto LABEL_2;
    }
LABEL_3:
    ;
  }
  return result;
}

uint64_t fnhp_timeWeightedConstantLatencyPredictionAlgorithm(uint64_t a1, double (*a2)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4, long long *a5, uint64_t a6)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  uint64_t v44 = 0;
  uint64_t v13 = *(void *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 24);
  long long v14 = a5[11];
  long long v40 = a5[10];
  long long v41 = v14;
  long long v15 = a5[13];
  long long v42 = a5[12];
  long long v43 = v15;
  long long v16 = a5[7];
  long long v36 = a5[6];
  long long v37 = v16;
  long long v17 = a5[9];
  long long v38 = a5[8];
  long long v39 = v17;
  long long v18 = a5[3];
  long long v32 = a5[2];
  long long v33 = v18;
  long long v19 = a5[5];
  long long v34 = a5[4];
  long long v35 = v19;
  long long v20 = a5[1];
  long long v30 = *a5;
  long long v31 = v20;
  fnhp_medianAlgorithmForLatency(a1, a4, &v30, v13, &v44, (double *)(a6 + 40), 0);
  uint64_t v21 = v44;
  *(void *)(a6 + 32) = v44;
  long long v22 = a5[11];
  long long v40 = a5[10];
  long long v41 = v22;
  long long v23 = a5[13];
  long long v42 = a5[12];
  long long v43 = v23;
  long long v24 = a5[7];
  long long v36 = a5[6];
  long long v37 = v24;
  long long v25 = a5[9];
  long long v38 = a5[8];
  long long v39 = v25;
  long long v26 = a5[3];
  long long v32 = a5[2];
  long long v33 = v26;
  long long v27 = a5[5];
  long long v34 = a5[4];
  long long v35 = v27;
  long long v28 = a5[1];
  long long v30 = *a5;
  long long v31 = v28;
  return fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(a1, v21, a4, &v30, a2, a3, (uint64_t *)a6, (double *)(a6 + 8), (double *)(a6 + 16), (uint64_t *)(a6 + 48));
}

double fnhp_linearTimeWeightForBandwidthSample(uint64_t a1, uint64_t a2)
{
  return fmax((double)(*(void *)(a1 + 8) - a2) / 1000000000.0, 0.0);
}

double fnhp_quadraticTimeWeightForBandwidthSample(uint64_t a1, uint64_t a2)
{
  double v2 = (double)(*(void *)(a1 + 8) - a2) / 1000000000.0;
  return fmax(v2 * v2, 0.0);
}

double fnhp_quadraticTimeWeightWithHighPassUtilizationFilterForBandwidthSample(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double v5 = (double)(*(void *)(a1 + 8) - a2) / 1000000000.0;
  double v6 = fmax(v5 * v5, 0.0);
  double v7 = *(double *)(a4 + 40);
  if (v7 > 0.0)
  {
    double v8 = *(double *)a5 + -0.01;
    double v6 = v6
       * (v8
        / (exp(-(*(double *)(a4 + 48) * ((double)*(uint64_t *)(a1 + 32) / (double)*(uint64_t *)(a5 + 8) - v7))) + 1.0)
        + 0.01);
  }
  return fmax(v6, 0.0);
}

double fnhp_logisticTimeWeightForBandwidthSample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return fmax(10000000.0 / (exp(((double)(*(void *)(a1 + 8) - a2) / (double)(a3 - a2) + -0.916666667) * -25.0) + 1.0), 0.0);
}

uint64_t FigTransportConnectionXPCSetCurrentConnection(uint64_t a1)
{
  if (ntcxpc_getReceiver_once != -1) {
    dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
  }
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    FigSimpleMutexLock((pthread_mutex_t *)qword_1E9272058);
    if (ntcxpc_getReceiver_receiver) {
      CFRelease((CFTypeRef)ntcxpc_getReceiver_receiver);
    }
    ntcxpc_getReceiver_receiver = (uint64_t)FigCFWeakReferenceHolderCreateWithReferencedObject(a1);
    if (qword_1E9272050) {
      _Block_release((const void *)qword_1E9272050);
    }
    qword_1E9272050 = (uint64_t)FigTransportConnectionUSBCopyEventHandler(a1);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    int v6[2] = __FigTransportConnectionXPCSetCurrentConnection_block_invoke;
    v6[3] = &__block_descriptor_tmp_13;
    v6[4] = &ntcxpc_getReceiver_receiver;
    uint64_t v3 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
    if (v3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
    double v5 = *(void (**)(uint64_t, void, void *))(v4 + 8);
    if (v5) {
      v5(a1, 0, v6);
    }
    return FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9272058);
  }
  return result;
}

void __FigTransportConnectionXPCSetCurrentConnection_block_invoke(uint64_t a1, uint64_t a2, OpaqueCMBlockBuffer *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  xpc_object_t xdict = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(v5 + 24));
  double v6 = *(void **)(v5 + 8);
  if (v6) {
    double v7 = (_xpc_connection_s *)xpc_retain(v6);
  }
  else {
    double v7 = 0;
  }
  double v8 = *(const void **)(v5 + 16);
  if (v8) {
    long long v9 = (void (**)(void *, void, OpaqueCMBlockBuffer *))_Block_copy(v8);
  }
  else {
    long long v9 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v5 + 24));
  if (v7)
  {
    if (!FigXPCCreateBasicMessage(0x656D7367u, 0, &xdict))
    {
      xpc_dictionary_set_int64(xdict, (const char *)kNeroTransportConnectionEventHandler_Type, (int)a2);
      if (!FigXPCMessageSetBlockBuffer(xdict, (char *)kNeroTransportConnectionEventHandler_BBuf, a3)) {
        xpc_connection_send_message(v7, xdict);
      }
    }
  }
  if (v9)
  {
    v9[2](v9, a2, a3);
    _Block_release(v9);
  }
  FigXPCRelease(v7);
  FigXPCRelease(xdict);
}

uint64_t FigTransportXPCConnectionServerStart()
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v16[0] = 1;
  v16[1] = ntcxpc_handleClientMessage;
  int v16[2] = 0;
  v16[4] = 0;
  v16[5] = 0;
  v16[3] = ntcxpc_verifyConnection;
  if (!_os_feature_enabled_impl()) {
    return 0;
  }
  uint64_t v0 = FigXPCServerStart((uint64_t)"com.apple.coremedia.nerotransportconnectionxpc", v16, 0, &FigTransportXPCConnectionServerStart_sNTCServer);
  if (!v0)
  {
    int v15 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v15, &type);
    int v2 = v15;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v4 = v2;
    }
    else {
      unsigned int v4 = v2 & 0xFFFFFFFE;
    }
    if (v4)
    {
      int v17 = 136315138;
      long long v18 = "FigTransportXPCConnectionServerStart";
      uint64_t v5 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v2) = v15;
    }
    else
    {
      uint64_t v5 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v5, v5 != v21, v2, 0, v3);
    return 0;
  }
  uint64_t v6 = v0;
  int v15 = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  double v8 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v15, &type);
  int v9 = v15;
  if (os_log_type_enabled(v8, type)) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = v9 & 0xFFFFFFFE;
  }
  if (v11)
  {
    int v17 = 136315394;
    long long v18 = "FigTransportXPCConnectionServerStart";
    __int16 v19 = 1024;
    int v20 = v6;
    long long v12 = (unsigned char *)_os_log_send_and_compose_impl();
    char v13 = v15;
  }
  else
  {
    char v13 = v9;
    long long v12 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v12, v12 != v21, v13, 0, v10);
  return v6;
}

uint64_t ntcxpc_handleClientMessage(void *a1, void *a2)
{
  theBuffer[16] = *(CMBlockBufferRef *)MEMORY[0x1E4F143B8];
  int v28 = 0;
  uint64_t OpCode = FigXPCMessageGetOpCode(a2, &v28);
  if (OpCode) {
    return OpCode;
  }
  if (v28 != 1701736821)
  {
    if (v28 != 1718383464)
    {
      if (v28 == 1768843636)
      {
        if (ntcxpc_getReceiver_once != -1) {
          dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
        }
        FigSimpleMutexLock((pthread_mutex_t *)qword_1E9272058);
        uint64_t v5 = (void *)qword_1E9272048;
        if (qword_1E9272048)
        {
          qword_1E9272048 = 0;
          xpc_release(v5);
        }
        qword_1E9272048 = (uint64_t)xpc_retain(a1);
        dword_1E9272060 = xpc_connection_get_pid((xpc_connection_t)a1);
        int v30 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v30, &type);
        int v7 = v30;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v9 = v7;
        }
        else {
          unsigned int v9 = v7 & 0xFFFFFFFE;
        }
        if (v9)
        {
          *(_DWORD *)CFIndex length = 136315394;
          *(void *)&length[4] = "ntcxpc_handleInit";
          __int16 v32 = 1024;
          int v33 = dword_1E9272060;
          uint64_t v10 = (CMBlockBufferRef *)_os_log_send_and_compose_impl();
          LOBYTE(v7) = v30;
        }
        else
        {
          uint64_t v10 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v10, v10 != theBuffer, v7, 0, v8);
        FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9272058);
      }
      return 0;
    }
    if (ntcxpc_getReceiver_once != -1) {
      dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
    }
    int64_t int64 = xpc_dictionary_get_int64(a2, "flushPendingPackage");
    FigSimpleMutexLock((pthread_mutex_t *)qword_1E9272058);
    if (ntcxpc_getReceiver_receiver)
    {
      int v17 = FigCFWeakReferenceHolderCopyReferencedObject((id *)ntcxpc_getReceiver_receiver);
      FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9272058);
      if (v17)
      {
        uint64_t v22 = *(void *)(CMBaseObjectGetVTable((uint64_t)v17) + 16);
        if (v22) {
          uint64_t v23 = v22;
        }
        else {
          uint64_t v23 = 0;
        }
        long long v25 = *(uint64_t (**)(id *, int64_t))(v23 + 40);
        if (v25) {
          uint64_t v24 = v25(v17, int64);
        }
        else {
          uint64_t v24 = 4294954514;
        }
LABEL_49:
        CFRelease(v17);
        return v24;
      }
    }
    else
    {
      FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9272058);
    }
    return 4294955265;
  }
  if (ntcxpc_getReceiver_once != -1) {
    dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
  }
  theBuffer[0] = 0;
  *(void *)CFIndex length = 0;
  data = xpc_dictionary_get_data(a2, "enqueuePkgHeader", (size_t *)length);
  if (!data) {
    goto LABEL_52;
  }
  long long v12 = data;
  uint64_t BlockBufferData = FigXPCMessageCreateBlockBufferData((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2, "enqueuePackage", theBuffer);
  if (BlockBufferData)
  {
    uint64_t v24 = BlockBufferData;
    int v17 = 0;
    goto LABEL_46;
  }
  uint64_t v14 = *(void *)length;
  if (*(void *)length < 8uLL
    || (uint64_t v15 = *v12, CMBlockBufferGetDataLength(theBuffer[0]) + v14 != v15)
    || *v12 < 8u)
  {
LABEL_52:
    int v17 = 0;
    uint64_t v24 = 4294954516;
    goto LABEL_46;
  }
  int64_t v16 = xpc_dictionary_get_int64(a2, "enqueuePriority");
  FigSimpleMutexLock((pthread_mutex_t *)qword_1E9272058);
  if (!ntcxpc_getReceiver_receiver)
  {
    FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9272058);
    int v17 = 0;
    goto LABEL_37;
  }
  int v17 = FigCFWeakReferenceHolderCopyReferencedObject((id *)ntcxpc_getReceiver_receiver);
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1E9272058);
  if (!v17)
  {
LABEL_37:
    uint64_t v24 = 4294955265;
    goto LABEL_46;
  }
  CMBlockBufferRef v18 = theBuffer[0];
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable((uint64_t)v17) + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  long long v26 = *(uint64_t (**)(id *, _DWORD *, CMBlockBufferRef, int64_t))(v20 + 32);
  if (v26) {
    uint64_t v24 = v26(v17, v12, v18, v16);
  }
  else {
    uint64_t v24 = 4294954514;
  }
LABEL_46:
  if (theBuffer[0]) {
    CFRelease(theBuffer[0]);
  }
  if (v17) {
    goto LABEL_49;
  }
  return v24;
}

BOOL ntcxpc_verifyConnection(_xpc_connection_s *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  pid_t pid = xpc_connection_get_pid(a1);
  BOOL HasEntitlement = FigXPCConnectionHasEntitlement((uint64_t)a1, (uint64_t)"com.apple.coremedia.nerotransportconnectionxpc.allow");
  if (!HasEntitlement)
  {
    v11[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v11, &type);
    int v5 = v11[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      v11[1] = 136315394;
      long long v12 = "ntcxpc_verifyConnection";
      __int16 v13 = 1024;
      pid_t v14 = pid;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v11[0];
    }
    else
    {
      uint64_t v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v15, v5, 0, v6);
  }
  return HasEntitlement;
}

pthread_mutex_t *__ntcxpc_getReceiver_block_invoke()
{
  uint64_t result = FigSimpleMutexCreate();
  qword_1E9272058 = (uint64_t)result;
  return result;
}

uint64_t FigScheduledIOGetTypeID()
{
  FigThreadRunOnce(&FigScheduledIOGetClassID_sRegisterFigScheduledIOBaseTypeOnce, (void (*)(void))RegisterFigScheduledIOBaseType);
  uint64_t v0 = (void *)sFigScheduledIOClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigScheduledIOBatchGetClassID()
{
  return sFigScheduledIOClassID;
}

uint64_t RegisterFigScheduledIOBatchBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigScheduledIOBatchClassDesc, ClassID, 1, &sFigScheduledIOBatchClassID);
}

uint64_t FigScheduledIOBatchGetTypeID()
{
  FigThreadRunOnce(&FigScheduledIOGetClassID_sRegisterFigScheduledIOBaseTypeOnce, (void (*)(void))RegisterFigScheduledIOBaseType);
  uint64_t v0 = (void *)sFigScheduledIOClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFTypeRef FigScheduledIOBaseCopyFormattingDesc()
{
  return CFRetain(@"[FigScheduledIORef]");
}

CFTypeRef FigScheduledIOBatchBaseCopyFormattingDesc()
{
  return CFRetain(@"[FigScheduledIOBatchRef]");
}

uint64_t FigReadSchedulerCopyForByteStream(uint64_t a1, uint64_t *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    if (rsRegistry_OneTimeInitialization_sRSRegistryInitOnce != -1) {
      dispatch_once_f(&rsRegistry_OneTimeInitialization_sRSRegistryInitOnce, 0, (dispatch_function_t)rsRegistry_PerformInitialization);
    }
    CFTypeRef v3 = CFRetain((CFTypeRef)*MEMORY[0x1E4F1D260]);
    FigSimpleMutexLock((pthread_mutex_t *)gRSRegistry_0);
    CFArrayRef Value = (id *)CFDictionaryGetValue((CFDictionaryRef)gRSRegistry_1, v3);
    if (Value)
    {
      int v5 = FigCFWeakReferenceHolderCopyReferencedObject(Value);
      if (v5)
      {
        uint64_t v6 = (uint64_t)v5;
LABEL_27:
        uint64_t v26 = 0;
LABEL_28:
        *a2 = v6;
        FigSimpleMutexUnlock((pthread_mutex_t *)gRSRegistry_0);
        if (v3) {
          CFRelease(v3);
        }
        return v26;
      }
    }
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)__str = 0u;
    long long v29 = 0u;
    if (FigReadSchedulerGetTypeID_sRegisterFigReadSchedulerTypeOnce != -1) {
      dispatch_once_f(&FigReadSchedulerGetTypeID_sRegisterFigReadSchedulerTypeOnce, &FigReadSchedulerGetTypeID_sFigReadSchedulerID, (dispatch_function_t)readScheduler_RegisterType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v6 = Instance;
      *(void *)(Instance + 16) = 0;
      unsigned int v9 = (const char *)(Instance + 400);
      snprintf((char *)(Instance + 400), 0x10uLL, "%p", (const void *)Instance);
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFStringRef v11 = CFStringCreateWithFormat(v7, 0, @"ReadScheduler-%s", v9);
      CFDictionarySetValue(Mutable, @"FigMemoryPool_LoggingName", v11);
      *(void *)(v6 + 104) = CMMemoryPoolCreate(Mutable);
      if (v11) {
        CFRelease(v11);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      long long v12 = *(OpaqueCMMemoryPool **)(v6 + 104);
      if (v12)
      {
        CFAllocatorRef Allocator = CMMemoryPoolGetAllocator(v12);
        *(void *)(v6 + 112) = Allocator;
        if (Allocator)
        {
          CFRetain(Allocator);
          snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.internal", v9);
          dispatch_queue_t v14 = FigDispatchQueueCreateWithPriority(__str, 0, 4u);
          *(void *)(v6 + 56) = v14;
          if (v14)
          {
            snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.requests", v9);
            dispatch_queue_t v15 = dispatch_queue_create_with_target_V2(__str, 0, *(dispatch_queue_t *)(v6 + 56));
            *(void *)(v6 + 64) = v15;
            if (v15)
            {
              snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.callbacks", v9);
              dispatch_queue_t v16 = FigDispatchQueueCreateWithPriority(__str, 0, 4u);
              *(void *)(v6 + 72) = v16;
              if (v16)
              {
                *(unsigned char *)(v6 + 376) = 0;
                snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.reads", v9);
                dispatch_queue_t v17 = FigDispatchQueueCreateWithPriority(__str, 0, 4u);
                *(void *)(v6 + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v17;
                if (v17)
                {
                  CFMutableArrayRef v18 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
                  *(void *)(v6 + 24) = v18;
                  if (v18)
                  {
                    CFMutableArrayRef v19 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
                    *(void *)(v6 + 32) = v19;
                    if (v19)
                    {
                      CFMutableArrayRef v20 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
                      *(void *)(v6 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v20;
                      if (v20)
                      {
                        CFMutableArrayRef v21 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
                        *(void *)(v6 + 48) = v21;
                        if (v21)
                        {
                          *(_OWORD *)(v6 + 88) = xmmword_18FE95900;
                          unint64_t v22 = *MEMORY[0x1E4F14B00];
                          *(void *)(v6 + 392) = *MEMORY[0x1E4F14B00];
                          *(_DWORD *)(v6 + 388) = 0x200000 / v22;
                          dispatch_source_t v23 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v6 + 64));
                          *(void *)(v6 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v23;
                          if (v23)
                          {
                            uint64_t v24 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v6);
                            dispatch_set_context(*(dispatch_object_t *)(v6 + 80), v24);
                            dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v6 + 80), (dispatch_function_t)readScheduler_DeadlineTimerHandler);
                            dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(v6 + 80), (dispatch_function_t)readScheduler_DeadlineTimerCancelCallback);
                            dispatch_resume(*(dispatch_object_t *)(v6 + 80));
                            CFTypeRef v25 = FigCFWeakReferenceHolderCreateWithReferencedObject(v6);
                            CFDictionarySetValue((CFMutableDictionaryRef)gRSRegistry_1, v3, v25);
                            CFRelease(v25);
                            goto LABEL_27;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v26 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
      CFRelease((CFTypeRef)v6);
    }
    else
    {
      uint64_t v26 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v6 = 0;
    goto LABEL_28;
  }

  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

uint64_t rsBatch_RegisterType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigReadSchedulerCreateBatch(void *a1, void *a2)
{
  CFTypeRef cf = 0;
  if (a1 && a2)
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    uint64_t v5 = rsBatch_Create(v4, &cf);
    CFTypeRef v6 = cf;
    if (v5)
    {
      if (cf) {
        CFRelease(cf);
      }
    }
    else
    {
      FigCFWeakReferenceStore((id *)cf + 2, a1);
      *a2 = v6;
    }
    return v5;
  }
  else
  {
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t rsBatch_Create(const __CFAllocator *a1, void *a2)
{
  if (FigReadSchedulerBatchGetTypeID_sRegisterRSBatchTypeOnce != -1) {
    dispatch_once_f(&FigReadSchedulerBatchGetTypeID_sRegisterRSBatchTypeOnce, &FigReadSchedulerBatchGetTypeID_sRSBatchID, (dispatch_function_t)rsBatch_RegisterType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v5 = (void *)Instance;
    *(_DWORD *)(Instance + 52) = 0;
    *(unsigned char *)(Instance + 48) = 0;
    dispatch_group_t v6 = dispatch_group_create();
    v5[5] = v6;
    if (v6
      && (CFAllocatorRef v7 = FigSimpleMutexCreate(), (v5[3] = v7) != 0)
      && (CFMutableSetRef Mutable = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]), (v5[4] = Mutable) != 0))
    {
      *a2 = v5;
      return 0;
    }
    else
    {
      uint64_t v10 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
      CFRelease(v5);
      return v10;
    }
  }
  else
  {
    return FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigReadSchedulerBatchAddReadWithDeadline(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  long long v29 = 0;
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52))
    {
      uint64_t v20 = 4294949513;
    }
    else
    {
      uint64_t v20 = 4294949515;
      if (a3 && a5 && a9)
      {
        int v28 = a6;
        id v21 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
        if (v21)
        {
          unint64_t v22 = v21;
          CFAllocatorRef v23 = CFGetAllocator(v21);
          uint64_t v24 = rsRequest_Create((uint64_t)v23, (uint64_t)v22, a2, a3, a4, a5, v28, 0, a7, a8, a9, a10, a11, &v29);
          CFTypeRef v25 = v29;
          if (!v24 && (CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v29), a12))
          {
            *a12 = v25[4];
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
          }
          else
          {
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
            if (!v25) {
              goto LABEL_13;
            }
          }
          CFRelease(v25);
LABEL_13:
          CFRelease(v22);
          return v24;
        }
        uint64_t v20 = 4294949515;
      }
    }
    uint64_t v27 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v27;
  }
  else
  {
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t rsRequest_Create(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, const void *a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  if (rsRequest_GetTypeID_sRegisterRSRequestTypeOnce != -1) {
    dispatch_once_f(&rsRequest_GetTypeID_sRegisterRSRequestTypeOnce, &rsRequest_GetTypeID_sRSRequestID, (dispatch_function_t)rsRequest_RegisterType);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v20 = Instance;
    Instance[2] = a2;
    Instance[3] = a3;
    Instance[4] = FigAtomicIncrement64(&gNextRequestID);
    if (a7) {
      CFTypeRef v21 = CFRetain(a7);
    }
    else {
      CFTypeRef v21 = 0;
    }
    v20[5] = v21;
    v20[6] = CFRetain(a4);
    void v20[7] = a5;
    v20[8] = a6;
    *((unsigned char *)v20 + 104) = a8;
    v20[11] = a9;
    v20[12] = a10;
    v20[14] = a11;
    v20[15] = a12;
    v20[16] = a13;
    *a14 = v20;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigReadSchedulerBatchAddBackgroundRead(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  int v28 = 0;
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52))
    {
      uint64_t v19 = 4294949513;
    }
    else
    {
      uint64_t v19 = 4294949515;
      if (a3 && a5 && a8)
      {
        uint64_t v27 = a6;
        id v20 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
        if (v20)
        {
          CFTypeRef v21 = v20;
          CFAllocatorRef v22 = CFGetAllocator(v20);
          uint64_t v23 = rsRequest_Create((uint64_t)v22, (uint64_t)v21, a2, a3, a4, a5, v27, 1, a7, 0, a8, a9, a10, &v28);
          uint64_t v24 = v28;
          if (!v23 && (CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v28), a11))
          {
            *a11 = v24[4];
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
          }
          else
          {
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
            if (!v24) {
              goto LABEL_13;
            }
          }
          CFRelease(v24);
LABEL_13:
          CFRelease(v21);
          return v23;
        }
        uint64_t v19 = 4294949515;
      }
    }
    uint64_t v26 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v26;
  }
  else
  {
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigReadSchedulerBatchCommit(uint64_t a1)
{
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52))
    {
      uint64_t v7 = 0;
    }
    else
    {
      CFTypeRef v3 = (dispatch_queue_t *)FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v3)
      {
        CFAllocatorRef v4 = v3;
        uint64_t v5 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (v5)
        {
          dispatch_group_t v6 = v5;
          v5[1] = CFRetain((CFTypeRef)a1);
          *dispatch_group_t v6 = CFRetain(v4);
          *(_DWORD *)(a1 + 52) = 1;
          dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
          dispatch_async_f(v4[8], v6, (dispatch_function_t)readScheduler_HandleBatchCommit);
          uint64_t v7 = 0;
        }
        else
        {
          uint64_t v7 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        CFRelease(v4);
        return v7;
      }
      uint64_t v7 = FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v7;
  }
  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleBatchCommit(uint64_t a1)
{
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(*(void *)(a1 + 8) + 32));
  CFTypeRef v3 = *(CFMutableArrayRef **)a1;
  if (Count)
  {
    CFArrayAppendValue(v3[6], *(const void **)(a1 + 8));
    CFSetApplyFunction(*(CFSetRef *)(*(void *)(a1 + 8) + 32), (CFSetApplierFunction)readScheduler_BatchRequestIngestApplierFunction, *(void **)a1);
    readScheduler_IssueReadsAndScheduleWakeup(*(void *)a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v3, *(void *)(a1 + 8));
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 8));

  free((void *)a1);
}

uint64_t FigReadSchedulerBatchCancel(uint64_t a1)
{
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52) == 2)
    {
      uint64_t v9 = 0;
    }
    else
    {
      CFTypeRef v3 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v3)
      {
        CFAllocatorRef v4 = v3;
        uint64_t v5 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (v5)
        {
          dispatch_group_t v6 = v5;
          v5[1] = CFRetain((CFTypeRef)a1);
          *dispatch_group_t v6 = CFRetain(v4);
          if (*(_DWORD *)(a1 + 52))
          {
            uint64_t v7 = v4[7];
            uint64_t v8 = (void (__cdecl *)(void *))readScheduler_HandleCommittedBatchCancellation;
          }
          else
          {
            *(_DWORD *)(a1 + 52) = 1;
            dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
            uint64_t v7 = v4[7];
            uint64_t v8 = (void (__cdecl *)(void *))readScheduler_HandleOpenBatchCancellation;
          }
          dispatch_async_f(v7, v6, v8);
          uint64_t v9 = 0;
        }
        else
        {
          uint64_t v9 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        CFRelease(v4);
        return v9;
      }
      uint64_t v9 = FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v9;
  }
  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleOpenBatchCancellation(CFTypeRef *a1)
{
  CFIndex Count = CFSetGetCount(*((CFSetRef *)a1[1] + 4));
  CFTypeRef v3 = (CFMutableArrayRef *)*a1;
  if (Count)
  {
    CFArrayAppendValue(v3[6], a1[1]);
    CFAllocatorRef v4 = CFGetAllocator(*((CFTypeRef *)a1[1] + 4));
    CFSetRef Copy = CFSetCreateCopy(v4, *((CFSetRef *)a1[1] + 4));
    dispatch_group_t v6 = (void *)*a1;
    *((unsigned char *)a1[1] + 48) = 1;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)readScheduler_CancelRequestApplierFunction, v6);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v3, (uint64_t)a1[1]);
    CFSetRef Copy = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Copy)
  {
    CFRelease(Copy);
  }
}

void readScheduler_HandleCommittedBatchCancellation(CFTypeRef *a1)
{
  if (CFSetGetCount(*((CFSetRef *)a1[1] + 4)))
  {
    readScheduler_RemoveMatchingRequestsFromReadArray(*((const __CFArray **)*a1 + 4), *((const __CFSet **)a1[1] + 4));
    readScheduler_RemoveMatchingRequestsFromReadArray(*((const __CFArray **)*a1 + 5), *((const __CFSet **)a1[1] + 4));
    int v2 = (CFArrayRef *)*a1;
    CFSetRef v3 = (const __CFSet *)*((void *)a1[1] + 4);
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)*a1 + 3));
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v2[3], i);
        CFIndex v8 = CFArrayGetCount(ValueAtIndex[6]);
        if (v8 >= 1)
        {
          CFIndex v9 = v8;
          CFIndex v10 = 0;
          do
          {
            CFStringRef v11 = CFArrayGetValueAtIndex(ValueAtIndex[6], v10);
            if (CFSetContainsValue(v3, v11))
            {
              CFArrayRemoveValueAtIndex(ValueAtIndex[6], v10);
              --v9;
            }
            else
            {
              ++v10;
            }
          }
          while (v10 < v9);
        }
        if (!CFArrayGetCount(ValueAtIndex[6])) {
          *((unsigned char *)ValueAtIndex + 114) = 1;
        }
      }
    }
    CFAllocatorRef v12 = CFGetAllocator(*((CFTypeRef *)a1[1] + 4));
    CFSetRef Copy = CFSetCreateCopy(v12, *((CFSetRef *)a1[1] + 4));
    dispatch_queue_t v14 = (void *)*a1;
    *((unsigned char *)a1[1] + 48) = 1;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)readScheduler_CancelRequestApplierFunction, v14);
  }
  else
  {
    CFSetRef Copy = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Copy)
  {
    CFRelease(Copy);
  }
}

uint64_t FigReadSchedulerBatchExpedite(uint64_t a1)
{
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52) == 2)
    {
      uint64_t v9 = 0;
    }
    else
    {
      CFSetRef v3 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v3)
      {
        CFAllocatorRef v4 = v3;
        CFIndex v5 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (v5)
        {
          dispatch_group_t v6 = v5;
          v5[1] = CFRetain((CFTypeRef)a1);
          *dispatch_group_t v6 = CFRetain(v4);
          if (*(_DWORD *)(a1 + 52))
          {
            uint64_t v7 = v4[8];
            CFIndex v8 = (void (__cdecl *)(void *))readScheduler_HandleCommittedBatchExpedite;
          }
          else
          {
            *(_DWORD *)(a1 + 52) = 1;
            dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
            uint64_t v7 = v4[8];
            CFIndex v8 = (void (__cdecl *)(void *))readScheduler_HandleOpenBatchExpedite;
          }
          dispatch_async_f(v7, v6, v8);
          uint64_t v9 = 0;
        }
        else
        {
          uint64_t v9 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        CFRelease(v4);
        return v9;
      }
      uint64_t v9 = FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v9;
  }
  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleOpenBatchExpedite(const void **a1)
{
  CFIndex Count = CFSetGetCount(*((CFSetRef *)a1[1] + 4));
  CFSetRef v3 = *a1;
  if (Count)
  {
    CFAllocatorRef v4 = CFGetAllocator(v3);
    CFMutableSetRef Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue(*((CFMutableArrayRef *)*a1 + 6), a1[1]);
    CFSetApplyFunction(*((CFSetRef *)a1[1] + 4), (CFSetApplierFunction)readScheduler_BatchRequestIngestApplierFunction, (void *)*a1);
    readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*((const __CFArray **)*a1 + 4), *((const __CFSet **)a1[1] + 4), Mutable);
    readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*((const __CFArray **)*a1 + 5), *((const __CFSet **)a1[1] + 4), Mutable);
    v7.CFIndex length = CFArrayGetCount(Mutable);
    v7.CFIndex location = 0;
    CFArrayApplyFunction(Mutable, v7, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, (void *)*a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v3, (uint64_t)a1[1]);
    CFMutableSetRef Mutable = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void readScheduler_HandleCommittedBatchExpedite(uint64_t a1)
{
  if (CFSetGetCount(*(CFSetRef *)(*(void *)(a1 + 8) + 32)))
  {
    CFAllocatorRef v2 = CFGetAllocator(*(CFTypeRef *)a1);
    CFMutableSetRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*(const __CFArray **)(*(void *)a1 + 32), *(const __CFSet **)(*(void *)(a1 + 8) + 32), Mutable);
      readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*(const __CFArray **)(*(void *)a1 + 40), *(const __CFSet **)(*(void *)(a1 + 8) + 32), Mutable);
      if (CFArrayGetCount(Mutable))
      {
        v5.CFIndex length = CFArrayGetCount(Mutable);
        v5.CFIndex location = 0;
        CFArrayApplyFunction(Mutable, v5, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, *(void **)a1);
      }
      else
      {
        readScheduler_CompleteBatch(*(void *)a1, *(void *)(a1 + 8));
      }
    }
    else
    {
      FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    CFMutableSetRef Mutable = 0;
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 8));
  free((void *)a1);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t FigReadSchedulerBatchAwaitCompletion(uint64_t a1)
{
  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    int v2 = *(_DWORD *)(a1 + 52);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    if (v2)
    {
      dispatch_group_wait(*(dispatch_group_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL);
      if (!*(unsigned char *)(a1 + 48)) {
        return 0;
      }
      uint64_t v4 = 4294949511;
    }
    else
    {
      uint64_t v4 = 4294949512;
    }
  }
  else
  {
    uint64_t v4 = 4294949515;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t readScheduler_RegisterType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigReadSchedulerGetNewClientID(uint64_t a1, unint64_t *a2)
{
  if (a1 && a2)
  {
    *a2 = FigAtomicIncrement64(&FigReadSchedulerGetNewClientID_sNextClientID);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigReadSchedulerRequestReadWithDeadline(dispatch_queue_t *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  CFTypeRef cf = 0;
  if (a1 && a3 && a5 && a9)
  {
    CFAllocatorRef v19 = CFGetAllocator(a1);
    uint64_t v20 = rsRequest_Create((uint64_t)v19, (uint64_t)a1, a2, a3, a4, a5, a6, 0, a7, a8, a9, a10, a11, &cf);
    CFTypeRef v21 = (void *)cf;
    if (!v20)
    {
      if (a12) {
        *a12 = *((void *)cf + 4);
      }
      CFRetain(a1);
      CFRetain(v21);
      dispatch_async_f(a1[8], v21, (dispatch_function_t)readScheduler_HandleReadRequest);
    }
    if (v21) {
      CFRelease(v21);
    }
    return v20;
  }
  else
  {
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  }
}

void readScheduler_HandleReadRequest(void *a1)
{
  int v2 = (const void *)a1[2];
  readScheduler_IngestRequest((uint64_t)v2, (uint64_t)a1);
  readScheduler_IssueReadsAndScheduleWakeup((uint64_t)v2);
  CFRelease(a1);

  CFRelease(v2);
}

uint64_t FigReadSchedulerRequestBackgroundRead(dispatch_queue_t *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  CFTypeRef cf = 0;
  if (a1 && a3 && a5 && a8)
  {
    CFAllocatorRef v19 = CFGetAllocator(a1);
    uint64_t v20 = rsRequest_Create((uint64_t)v19, (uint64_t)a1, a2, a3, a4, a5, a6, 1, a7, 0, a8, a9, a10, &cf);
    CFTypeRef v21 = (void *)cf;
    if (!v20)
    {
      if (a11) {
        *a11 = *((void *)cf + 4);
      }
      CFRetain(a1);
      CFRetain(v21);
      dispatch_async_f(a1[8], v21, (dispatch_function_t)readScheduler_HandleReadRequest);
    }
    if (v21) {
      CFRelease(v21);
    }
    return v20;
  }
  else
  {
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigReadSchedulerCancelRequest(dispatch_queue_t *a1, uint64_t a2)
{
  if (a1 && a2)
  {
    uint64_t v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040EDED9539uLL);
    if (v4)
    {
      CFRange v5 = v4;
      void *v4 = CFRetain(a1);
      v5[1] = a2;
      dispatch_async_f(a1[8], v5, (dispatch_function_t)readScheduler_HandleCancelOneRequestJob);
      return 0;
    }
    uint64_t v7 = 4294949516;
  }
  else
  {
    uint64_t v7 = 4294949515;
  }

  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleCancelOneRequestJob(uint64_t *a1)
{
  int v2 = readScheduler_RemoveAndRetainRequestFromReadArray(*(const __CFArray **)(*a1 + 32), a1[1]);
  if (v2) {
    goto LABEL_3;
  }
  int v2 = readScheduler_RemoveAndRetainRequestFromReadArray(*(const __CFArray **)(*a1 + 40), a1[1]);
  if (v2) {
    goto LABEL_3;
  }
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*a1 + 24));
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 24), v7);
      CFIndex v9 = CFArrayGetCount(ValueAtIndex[6]);
      if (v9 < 1)
      {
LABEL_13:
        int v2 = 0;
      }
      else
      {
        CFIndex v10 = v9;
        CFIndex v11 = 0;
        while (1)
        {
          CFAllocatorRef v12 = CFArrayGetValueAtIndex(ValueAtIndex[6], v11);
          if (v12[4] == v4) {
            break;
          }
          if (v10 == ++v11) {
            goto LABEL_13;
          }
        }
        int v2 = CFRetain(v12);
        CFArrayRemoveValueAtIndex(ValueAtIndex[6], v11);
      }
      if (!CFArrayGetCount(ValueAtIndex[6])) {
        *((unsigned char *)ValueAtIndex + 114) = 1;
      }
      ++v7;
    }
    while (v7 < v6 && !v2);
    if (v2)
    {
LABEL_3:
      v2[27] = -17785;
      readScheduler_HandleFailedRequest(*a1, v2);
      CFRelease(v2);
    }
  }
  CFRelease((CFTypeRef)*a1);

  free(a1);
}

uint64_t FigReadSchedulerExpediteRequest(dispatch_queue_t *a1, uint64_t a2, int a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (a2)
    {
      CFAllocatorRef v6 = CFGetAllocator(a1);
      uint64_t v7 = rsBatch_Create(v6, &cf);
      if (v7)
      {
LABEL_17:
        uint64_t v12 = v7;
LABEL_8:
        if (cf) {
          CFRelease(cf);
        }
        return v12;
      }
      CFIndex v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004014030ADEuLL);
      if (v8)
      {
        CFIndex v9 = v8;
        *CFIndex v8 = CFRetain(a1);
        v9[1] = a2;
        CFIndex v10 = (dispatch_group_t *)cf;
        CFTypeRef v11 = CFRetain(cf);
        CFArrayRef v9[2] = v11;
        *((_DWORD *)v11 + 13) = 1;
        dispatch_group_enter(*((dispatch_group_t *)v11 + 5));
        dispatch_async_f(a1[8], v9, (dispatch_function_t)readScheduler_HandleExpediteSingleRequestJob);
        if (a3) {
          dispatch_group_wait(v10[5], 0xFFFFFFFFFFFFFFFFLL);
        }
        uint64_t v12 = 0;
        goto LABEL_8;
      }
      uint64_t v14 = 4294949516;
    }
    else
    {
      uint64_t v14 = 4294949515;
    }
    uint64_t v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }

  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleExpediteSingleRequestJob(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator(*(CFTypeRef *)a1);
  CFMutableSetRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  if (!readScheduler_RemoveAndCollectReadForRequestToExpediteFromReadArray(*(const __CFArray **)(*(void *)a1 + 32), *(void *)(a1 + 8), *(__CFSet **)(*(void *)(a1 + 16) + 32), Mutable)&& !readScheduler_RemoveAndCollectReadForRequestToExpediteFromReadArray(*(const __CFArray **)(*(void *)a1 + 40), *(void *)(a1 + 8), *(__CFSet **)(*(void *)(a1 + 16) + 32), Mutable))
  {
    uint64_t v4 = *(CFArrayRef **)a1;
    uint64_t v5 = *(void *)(a1 + 8);
    CFAllocatorRef v6 = *(__CFSet **)(*(void *)(a1 + 16) + 32);
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)a1 + 24));
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v4[3], v9);
        CFIndex v11 = CFArrayGetCount(ValueAtIndex[6]);
        if (v11 >= 1) {
          break;
        }
LABEL_9:
        if (++v9 == v8) {
          goto LABEL_12;
        }
      }
      CFIndex v12 = v11;
      CFIndex v13 = 0;
      while (1)
      {
        uint64_t v14 = CFArrayGetValueAtIndex(ValueAtIndex[6], v13);
        if (v14[4] == v5) {
          break;
        }
        if (v12 == ++v13) {
          goto LABEL_9;
        }
      }
      CFSetAddValue(v6, v14);
    }
  }
LABEL_12:
  CFIndex v15 = CFSetGetCount(*(CFSetRef *)(*(void *)(a1 + 16) + 32));
  dispatch_queue_t v16 = *(CFMutableArrayRef **)a1;
  if (v15)
  {
    CFArrayAppendValue(v16[6], *(const void **)(a1 + 16));
    v18.CFIndex length = CFArrayGetCount(Mutable);
    v18.CFIndex location = 0;
    CFArrayApplyFunction(Mutable, v18, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, *(void **)a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v16, *(void *)(a1 + 16));
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 16));
  free((void *)a1);

  CFRelease(Mutable);
}

uint64_t FigReadSchedulerCancelAllClientRequests(dispatch_queue_t *a1, uint64_t a2, int a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (a2)
    {
      CFAllocatorRef v6 = CFGetAllocator(a1);
      uint64_t v7 = rsBatch_Create(v6, &cf);
      if (v7)
      {
LABEL_17:
        uint64_t v12 = v7;
LABEL_8:
        if (cf) {
          CFRelease(cf);
        }
        return v12;
      }
      CFIndex v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
      if (v8)
      {
        CFIndex v9 = v8;
        *CFIndex v8 = CFRetain(a1);
        CFIndex v10 = (dispatch_group_t *)cf;
        CFTypeRef v11 = CFRetain(cf);
        v9[1] = v11;
        CFArrayRef v9[2] = a2;
        *((_DWORD *)v11 + 13) = 1;
        dispatch_group_enter(*((dispatch_group_t *)v11 + 5));
        dispatch_async_f(a1[8], v9, (dispatch_function_t)readScheduler_HandleCancelAllClientRequestsJob);
        if (a3) {
          dispatch_group_wait(v10[5], 0xFFFFFFFFFFFFFFFFLL);
        }
        uint64_t v12 = 0;
        goto LABEL_8;
      }
      uint64_t v14 = 4294949516;
    }
    else
    {
      uint64_t v14 = 4294949515;
    }
    uint64_t v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }

  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleCancelAllClientRequestsJob(const void **a1)
{
  readScheduler_RemoveAndCollectClientRequestsFromReadArray(*((const __CFArray **)*a1 + 4), (uint64_t)a1[2], *((__CFSet **)a1[1] + 4));
  readScheduler_RemoveAndCollectClientRequestsFromReadArray(*((const __CFArray **)*a1 + 5), (uint64_t)a1[2], *((__CFSet **)a1[1] + 4));
  CFAllocatorRef v2 = a1[2];
  uint64_t v3 = (CFArrayRef *)*a1;
  uint64_t v4 = (__CFSet *)*((void *)a1[1] + 4);
  CFIndex Count = CFArrayGetCount(*((CFArrayRef *)*a1 + 3));
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0; i != v6; ++i)
    {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v3[3], i);
      CFIndex v9 = CFArrayGetCount(ValueAtIndex[6]);
      if (v9 >= 1)
      {
        CFIndex v10 = v9;
        CFIndex v11 = 0;
        do
        {
          uint64_t v12 = CFArrayGetValueAtIndex(ValueAtIndex[6], v11);
          if ((const void *)v12[3] == v2)
          {
            CFSetAddValue(v4, v12);
            CFArrayRemoveValueAtIndex(ValueAtIndex[6], v11);
            --v10;
          }
          else
          {
            ++v11;
          }
        }
        while (v11 < v10);
      }
      if (!CFArrayGetCount(ValueAtIndex[6])) {
        *((unsigned char *)ValueAtIndex + 114) = 1;
      }
    }
  }
  CFIndex v13 = CFSetGetCount(*((CFSetRef *)a1[1] + 4));
  uint64_t v14 = (uint64_t)*a1;
  if (v13)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(v14 + 48), a1[1]);
    CFAllocatorRef v15 = CFGetAllocator(*((CFTypeRef *)a1[1] + 4));
    CFSetRef Copy = CFSetCreateCopy(v15, *((CFSetRef *)a1[1] + 4));
    CFSetApplyFunction(Copy, (CFSetApplierFunction)readScheduler_CancelRequestApplierFunction, (void *)*a1);
  }
  else
  {
    readScheduler_CompleteBatch(v14, (uint64_t)a1[1]);
    CFSetRef Copy = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Copy)
  {
    CFRelease(Copy);
  }
}

uint64_t FigReadSchedulerExpediteAllClientRequests(dispatch_queue_t *a1, uint64_t a2, int a3)
{
  CFTypeRef cf = 0;
  if (a1)
  {
    if (a2)
    {
      CFAllocatorRef v6 = CFGetAllocator(a1);
      uint64_t v7 = rsBatch_Create(v6, &cf);
      if (v7)
      {
LABEL_17:
        uint64_t v12 = v7;
LABEL_8:
        if (cf) {
          CFRelease(cf);
        }
        return v12;
      }
      CFIndex v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
      if (v8)
      {
        CFIndex v9 = v8;
        *CFIndex v8 = CFRetain(a1);
        CFIndex v10 = (dispatch_group_t *)cf;
        CFTypeRef v11 = CFRetain(cf);
        v9[1] = v11;
        CFArrayRef v9[2] = a2;
        *((_DWORD *)v11 + 13) = 1;
        dispatch_group_enter(*((dispatch_group_t *)v11 + 5));
        dispatch_async_f(a1[8], v9, (dispatch_function_t)readScheduler_HandleExpediteAllClientRequestsJob);
        if (a3) {
          dispatch_group_wait(v10[5], 0xFFFFFFFFFFFFFFFFLL);
        }
        uint64_t v12 = 0;
        goto LABEL_8;
      }
      uint64_t v14 = 4294949516;
    }
    else
    {
      uint64_t v14 = 4294949515;
    }
    uint64_t v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }

  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleExpediteAllClientRequestsJob(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator(*(CFTypeRef *)a1);
  CFMutableSetRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  readScheduler_RemoveAndCollectClientReadsToExpediteFromReadArray(*(const __CFArray **)(*(void *)a1 + 32), *(void *)(a1 + 16), *(__CFSet **)(*(void *)(a1 + 8) + 32), Mutable);
  readScheduler_RemoveAndCollectClientReadsToExpediteFromReadArray(*(const __CFArray **)(*(void *)a1 + 40), *(void *)(a1 + 16), *(__CFSet **)(*(void *)(a1 + 8) + 32), Mutable);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(CFArrayRef **)a1;
  CFAllocatorRef v6 = *(__CFSet **)(*(void *)(a1 + 8) + 32);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)a1 + 24));
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    for (CFIndex i = 0; i != v8; ++i)
    {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v5[3], i);
      CFIndex v11 = CFArrayGetCount(ValueAtIndex[6]);
      if (v11 >= 1)
      {
        CFIndex v12 = v11;
        for (CFIndex j = 0; j != v12; ++j)
        {
          uint64_t v14 = CFArrayGetValueAtIndex(ValueAtIndex[6], j);
          if (v14[3] == v4) {
            CFSetAddValue(v6, v14);
          }
        }
      }
    }
  }
  CFIndex v15 = CFSetGetCount(*(CFSetRef *)(*(void *)(a1 + 8) + 32));
  dispatch_queue_t v16 = *(CFMutableArrayRef **)a1;
  if (v15)
  {
    CFArrayAppendValue(v16[6], *(const void **)(a1 + 8));
    v18.CFIndex length = CFArrayGetCount(Mutable);
    v18.CFIndex location = 0;
    CFArrayApplyFunction(Mutable, v18, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, *(void **)a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v16, *(void *)(a1 + 8));
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 8));
  free((void *)a1);

  CFRelease(Mutable);
}

CFMutableDictionaryRef rsRegistry_PerformInitialization()
{
  gRSRegistry_0 = (uint64_t)FigSimpleMutexCreate();
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  gRSRegistry_1 = (uint64_t)result;
  return result;
}

void readScheduler_DeadlineTimerHandler(id *a1)
{
  uint64_t v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    CFAllocatorRef v2 = v1;
    dispatch_source_set_timer((dispatch_source_t)v1[10], 0xFFFFFFFFFFFFFFFFLL, 0, 0);
    v2[11] = (id)0x7FFFFFFFFFFFFFFFLL;
    readScheduler_IssueReadsAndScheduleWakeup((uint64_t)v2);
    CFRelease(v2);
  }
}

void readScheduler_DeadlineTimerCancelCallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void readScheduler_IssueReadsAndScheduleWakeup(uint64_t a1)
{
  for (int i = 0; i != 4; ++i)
  {
    int64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), v6);
        if (ValueAtIndex[10] - *(void *)(a1 + 96) <= UpTimeNanoseconds) {
          break;
        }
        if (v5 == ++v6) {
          goto LABEL_8;
        }
      }
      CFIndex v8 = CFRetain(ValueAtIndex);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 32), v6);
      if (v8) {
        goto LABEL_14;
      }
    }
LABEL_8:
    CFIndex v9 = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    if (v9 < 1) {
      break;
    }
    CFIndex v10 = v9;
    CFIndex v11 = 0;
    while (1)
    {
      CFIndex v12 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v11);
      if (!v12[113]) {
        break;
      }
      if (v10 == ++v11) {
        goto LABEL_15;
      }
    }
    CFIndex v8 = CFRetain(v12);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 40), v11);
    if (!v8) {
      break;
    }
LABEL_14:
    readScheduler_IssueOneRead(a1, v8);
    CFRelease(v8);
  }
LABEL_15:
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 32))
    && (CFIndex v13 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), 0)) != 0
    && (uint64_t v14 = v13[10] - *(void *)(a1 + 96), v14 < *(void *)(a1 + 88)))
  {
    int64_t v15 = v14 - FigGetUpTimeNanoseconds();
    if (v15 >= 1)
    {
      dispatch_time_t v16 = dispatch_time(0, v15);
      *(void *)(a1 + 88) = v14;
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 80), v16, 0xFFFFFFFFFFFFFFFFLL, 0);
      goto LABEL_20;
    }
LABEL_21:
    CFRetain((CFTypeRef)a1);
    uint64_t v17 = 120;
    if (*(int *)(a1 + 380) > 3)
    {
      CFRange v18 = (void (__cdecl *)(void *))readScheduler_LetReadsProgress;
    }
    else
    {
      uint64_t v17 = 64;
      CFRange v18 = (void (__cdecl *)(void *))readScheduler_CallIssueReadsAndScheduleWakeup;
    }
    CFAllocatorRef v19 = *(NSObject **)(a1 + v17);
    dispatch_async_f(v19, (void *)a1, v18);
  }
  else
  {
LABEL_20:
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 40)) != *(_DWORD *)(a1 + 384)) {
      goto LABEL_21;
    }
  }
}

void readScheduler_LetReadsProgress(dispatch_queue_t *a1)
{
  CFRetain(a1);
  dispatch_async_f(a1[8], a1, (dispatch_function_t)readScheduler_CallIssueReadsAndScheduleWakeup);

  CFRelease(a1);
}

void readScheduler_CallIssueReadsAndScheduleWakeup(const void *a1)
{
  readScheduler_IssueReadsAndScheduleWakeup();

  CFRelease(a1);
}

void readScheduler_IssueOneRead(uint64_t a1, void *a2)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 24), a2);
  FigAtomicIncrement32((atomic_uint *)(a1 + 380));
  if (*(unsigned char *)(a1 + 376))
  {
    uint64_t v4 = 0;
    int v5 = 0;
    CFIndex v6 = (int *)(a1 + 176);
    int v7 = 0x7FFFFFFF;
    while (*((void *)v6 - 1) != a2[4])
    {
      int v9 = *v6;
      v6 += 16;
      int v8 = v9;
      if (v9 < v7)
      {
        int v5 = v4;
        int v7 = v8;
      }
      if (++v4 == 4) {
        goto LABEL_10;
      }
    }
    int v5 = v4;
LABEL_10:
    uint64_t v10 = a1 + ((uint64_t)v5 << 6) + 120;
  }
  else
  {
    uint64_t v10 = a1 + 120;
  }
  a2[3] = v10;
  FigAtomicIncrement32((atomic_uint *)(v10 + 56));
  *(void *)(a2[3] + 48) = a2[4];
  CFRetain((CFTypeRef)a1);
  CFRetain(a2);
  CFIndex v11 = *(NSObject **)a2[3];

  dispatch_async_f(v11, a2, (dispatch_function_t)readScheduler_PerformRead);
}

void readScheduler_PerformRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(unsigned char *)(a1 + 114))
  {
    *(_DWORD *)(a1 + 64) = 0;
    goto LABEL_48;
  }
  uint64_t v6 = *(void *)(a1 + 24);
  int v7 = (void *)(a1 + 96);
  uint64_t v8 = *(void *)(a1 + 104) - *(void *)(a1 + 96);
  uint64_t v9 = *(void *)(v5 + 392);
  CMBlockBufferRef theBuffer = 0;
  dataPointerOut = 0;
  long long v40 = (_OWORD *)(a1 + 96);
  if (*(void *)(v6 + 8))
  {
    id v10 = FigCFWeakReferenceLoadAndRetain((id *)(v6 + 32));
    if (*(id *)(a1 + 32) == v10
      && (v11 = *v7, uint64_t v12 = *(void *)(v6 + 16), v13 = __OFSUB__(*v7, v12), v14 = *v7 - v12, v14 < 0 == v13)
      && (uint64_t v15 = *(void *)(v6 + 24), v11 <= v15))
    {
      if (*(void *)(a1 + 104) < v15) {
        uint64_t v15 = *(void *)(a1 + 104);
      }
      uint64_t v37 = v15 - v11;
      uint64_t v18 = v37 + 1;
      uint64_t v38 = *(void *)(v5 + 392);
      size_t v17 = v38 * v14;
      size_t v16 = (v37 + 1) * v38;
      if (v37 == v8)
      {
        CFAllocatorRef v39 = CFGetAllocator((CFTypeRef)v5);
        OSStatus DataPointer = CMBlockBufferCreateWithBufferReference(v39, *(CMBlockBufferRef *)(v6 + 8), v17, v16, 0, &theBuffer);
        if (DataPointer) {
          goto LABEL_55;
        }
        CMBlockBufferRef v23 = theBuffer;
        if (theBuffer)
        {
          CFTypeRef v21 = 0;
          vm_address_t v22 = 0;
LABEL_14:
          uint64_t v24 = *(void *)(a1 + 88) + *(void *)(v5 + 392) * v18;
          CFTypeRef v25 = CFRetain(v23);
          int v26 = 0;
          if (!v10) {
            goto LABEL_16;
          }
          goto LABEL_15;
        }
      }
    }
    else
    {
      size_t v16 = 0;
      size_t v17 = 0;
      uint64_t v18 = 0;
    }
  }
  else
  {
    size_t v16 = 0;
    size_t v17 = 0;
    uint64_t v18 = 0;
    id v10 = 0;
  }
  vm_address_t v19 = v9 + v9 * v8;
  OSStatus DataPointer = FigMemoryPoolCreateBlockBuffer(*(void *)(v5 + 104), v19, &theBuffer, a4);
  if (!DataPointer)
  {
    OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (!DataPointer)
    {
      CFTypeRef v21 = dataPointerOut;
      if (!v16)
      {
LABEL_13:
        vm_address_t v22 = v19 - v16;
        CMBlockBufferRef v23 = theBuffer;
        goto LABEL_14;
      }
      OSStatus DataPointer = CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v6 + 8), v17, v16, dataPointerOut);
      if (!DataPointer)
      {
        CFTypeRef v21 = &dataPointerOut[v16];
        dataPointerOut += v16;
        goto LABEL_13;
      }
    }
  }
LABEL_55:
  int v26 = DataPointer;
  size_t v16 = 0;
  vm_address_t v22 = 0;
  uint64_t v24 = 0;
  CFTypeRef v21 = 0;
  CFTypeRef v25 = 0;
  if (v10) {
LABEL_15:
  }
    CFRelease(v10);
LABEL_16:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  if (v26) {
    goto LABEL_46;
  }
  if (v22)
  {
    dataPointerOut = 0;
    uint64_t v27 = *(void *)(a1 + 32);
    uint64_t v28 = *(void *)(CMBaseObjectGetVTable(v27) + 16);
    if (v28) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = 0;
    }
    long long v31 = *(uint64_t (**)(uint64_t, vm_address_t, uint64_t, char *, char **))(v29 + 8);
    if (v31)
    {
      int v26 = v31(v27, v22, v24, v21, &dataPointerOut);
      long long v32 = dataPointerOut;
    }
    else
    {
      long long v32 = 0;
      int v26 = -12782;
    }
    if (v22 <= (unint64_t)v32)
    {
      int v30 = 0;
    }
    else
    {
      bzero(&v32[(void)v21], v22 - (void)v32);
      if (v16) {
        BOOL v33 = v26 == 0;
      }
      else {
        BOOL v33 = 1;
      }
      if (!v33) {
        int v26 = 0;
      }
      int v30 = 1;
      long long v32 = dataPointerOut;
    }
    v16 += (size_t)v32;
    if (!v16) {
      goto LABEL_46;
    }
    goto LABEL_37;
  }
  int v26 = 0;
  int v30 = 0;
  if (v16)
  {
LABEL_37:
    *(void *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = CFRetain(v25);
    *(void *)(a1 + 72) = v16;
    if (v30)
    {
      FigCFWeakReferenceStore((id *)(v6 + 32), 0);
      long long v34 = *(const void **)(v6 + 8);
      if (v34)
      {
        CFRelease(v34);
        *(void *)(v6 + 8) = 0;
      }
    }
    else if (v22)
    {
      FigCFWeakReferenceStore((id *)(v6 + 32), *(id *)(a1 + 32));
      long long v35 = *(const void **)(v6 + 8);
      long long v36 = *(const void **)(a1 + 40);
      *(void *)(v6 + 8) = v36;
      if (v36) {
        CFRetain(v36);
      }
      if (v35) {
        CFRelease(v35);
      }
      *(_OWORD *)(v6 + 16) = *v40;
    }
  }
LABEL_46:
  *(_DWORD *)(a1 + 64) = v26;
  if (v25) {
    CFRelease(v25);
  }
LABEL_48:
  FigAtomicDecrement32((atomic_uint *)(v5 + 380));
  FigAtomicDecrement32((atomic_uint *)(*(void *)(a1 + 24) + 56));
  CFRetain((CFTypeRef)v5);
  CFRetain((CFTypeRef)a1);
  dispatch_async_f(*(dispatch_queue_t *)(v5 + 56), (void *)a1, (dispatch_function_t)readScheduler_HandleOneCompletedRead);
  CFRelease((CFTypeRef)a1);
  CFRelease((CFTypeRef)v5);
}

void readScheduler_HandleOneCompletedRead(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  CFArrayRef v3 = *(const __CFArray **)(v2 + 24);
  v19.CFIndex length = CFArrayGetCount(v3);
  v19.CFIndex location = 0;
  FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v3, v19, (const void *)a1);
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 24), FirstIndexOfValue);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count)
  {
    CFIndex v6 = Count;
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != v6; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), i);
        int appended = *(_DWORD *)(a1 + 64);
        if (!appended)
        {
          size_t v10 = *((void *)ValueAtIndex + 7) - *(void *)(a1 + 88);
          if (v10 >= *(void *)(a1 + 72))
          {
            int appended = FigSignalErrorAt(4294949514, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            uint64_t v11 = (OpaqueCMBlockBuffer *)*((void *)ValueAtIndex + 5);
            if (v11)
            {
              if (CMBlockBufferIsEmpty(v11))
              {
                int appended = CMBlockBufferAppendBufferReference(*((CMBlockBufferRef *)ValueAtIndex + 5), *(CMBlockBufferRef *)(a1 + 40), v10, *((void *)ValueAtIndex + 8), 0);
              }
              else
              {
                size_t v17 = 0;
                dataPointerOut = 0;
                int appended = CMBlockBufferAssureBlockMemory(*((CMBlockBufferRef *)ValueAtIndex + 5));
                if (!appended)
                {
                  int appended = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 40), v10, &v17, 0, &dataPointerOut);
                  if (!appended) {
                    int appended = CMBlockBufferReplaceDataBytes(dataPointerOut, *((CMBlockBufferRef *)ValueAtIndex + 5), 0, *((void *)ValueAtIndex + 8));
                  }
                }
              }
            }
            else
            {
              CFAllocatorRef v12 = CFGetAllocator(ValueAtIndex);
              int appended = CMBlockBufferCreateWithBufferReference(v12, *(CMBlockBufferRef *)(a1 + 40), v10, *((void *)ValueAtIndex + 8), 0, (CMBlockBufferRef *)ValueAtIndex + 5);
            }
          }
        }
        *((_DWORD *)ValueAtIndex + 27) = appended;
      }
    }
    CFArrayRef v13 = *(const __CFArray **)(a1 + 48);
    *(void *)(a1 + 48) = 0;
    CFIndex v14 = CFArrayGetCount(v13);
    CFRetain(v13);
    dispatch_async_f(*(dispatch_queue_t *)(v2 + 72), v13, (dispatch_function_t)readScheduler_DispatchFulfilledRequestsCallbacks);
    if (v14 >= 1)
    {
      for (CFIndex j = 0; j != v14; ++j)
      {
        size_t v16 = CFArrayGetValueAtIndex(v13, j);
        readScheduler_UpdateBatches(v2, v16, 0);
      }
    }
    CFRelease(v13);
  }
  CFRelease((CFTypeRef)a1);
  CFRelease((CFTypeRef)v2);
}

void readScheduler_DispatchFulfilledRequestsCallbacks(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      readScheduler_CallRequestCallback((uint64_t)ValueAtIndex);
    }
  }

  CFRelease(a1);
}

void readScheduler_UpdateBatches(uint64_t a1, const void *a2, int a3)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (CFSetRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v8);
      uint64_t v10 = (uint64_t)ValueAtIndex;
      if (a3 && CFSetContainsValue(ValueAtIndex[4], a2)) {
        *(unsigned char *)(v10 + 48) = 1;
      }
      CFSetRemoveValue(*(CFMutableSetRef *)(v10 + 32), a2);
      if (CFSetGetCount(*(CFSetRef *)(v10 + 32)))
      {
        ++v8;
      }
      else
      {
        readScheduler_CompleteBatch(a1, v10);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 48), v8);
        --v7;
      }
    }
    while (v8 < v7);
  }
}

void readScheduler_CallRequestCallback(uint64_t a1)
{
  (*(void (**)(void, void, void, void, void, void))(a1 + 112))(*(void *)(a1 + 32), *(void *)(a1 + 120), *(void *)(a1 + 128), *(void *)(a1 + 40), *(void *)(a1 + 64), *(unsigned int *)(a1 + 108));
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  }
}

void readScheduler_CompleteBatch(uint64_t a1, uint64_t a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 24));
  *(_DWORD *)(a2 + 52) = 2;
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a2 + 32));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a2 + 24));
  CFRetain((CFTypeRef)a2);
  uint64_t v4 = *(NSObject **)(a1 + 72);

  dispatch_async_f(v4, (void *)a2, (dispatch_function_t)readScheduler_NotifyCompletedBatch);
}

void readScheduler_NotifyCompletedBatch(dispatch_group_t *a1)
{
  dispatch_group_leave(a1[5]);
  CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, @"readSchedulerNotification_BatchCompleted", a1, 0);

  CFRelease(a1);
}

double rsBatch_Init(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

id rsBatch_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 32) = 0;
  }
  CFIndex v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  }
  FigSimpleMutexDestroy(*(void *)(a1 + 24));

  return FigCFWeakReferenceStore((id *)(a1 + 16), 0);
}

__CFString *rsBatch_CopyDebugDesc(uint64_t a1)
{
  CFMutableSetRef Mutable = CFStringCreateMutable(0, 0);
  CFIndex v3 = CFGetRetainCount((CFTypeRef)a1);
  int v4 = *(_DWORD *)(a1 + 52);
  uint64_t v5 = "Completed";
  if (v4 == 1) {
    uint64_t v5 = "Committed";
  }
  if (v4) {
    CFIndex v6 = v5;
  }
  else {
    CFIndex v6 = "Open";
  }
  if (*(unsigned char *)(a1 + 48)) {
    CFIndex v7 = "and Cancelled";
  }
  else {
    CFIndex v7 = "";
  }
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(a1 + 32));
  CFStringAppendFormat(Mutable, 0, @"RSBatch %p RC %d State %s%s req %d", a1, v3, v6, v7, Count);
  CFSetApplyFunction(*(CFSetRef *)(a1 + 32), (CFSetApplierFunction)rsBatch_RequestSetDebugDescApplierFunction, Mutable);
  return Mutable;
}

void rsBatch_RequestSetDebugDescApplierFunction(const void *a1, __CFString *a2)
{
  CFStringRef v3 = CFCopyDescription(a1);
  CFStringAppendFormat(a2, 0, @"\n\t%@", v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t rsRequest_RegisterType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

double rsRequest_Init(uint64_t a1)
{
  *(void *)(a1 + 128) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void rsRequest_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  }
  CFStringRef v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 48) = 0;
  }
}

__CFString *rsRequest_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableSetRef Mutable = CFStringCreateMutable(v2, 0);
  int v4 = *(unsigned __int8 *)(a1 + 104);
  CFIndex v5 = CFGetRetainCount((CFTypeRef)a1);
  if (v4)
  {
    if ((*(void *)(a1 + 88) & 0x100000000) != 0) {
      CFIndex v6 = "Latched ";
    }
    else {
      CFIndex v6 = "";
    }
    CFStringAppendFormat(Mutable, 0, @"RSRequest %p RC %d Background %sreqID %lld clientID %lld %zd bytes @ %lld [%lld:%lld]", a1, v5, v6, *(void *)(a1 + 32), *(void *)(a1 + 24), *(void *)(a1 + 64), *(void *)(a1 + 56), *(void *)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"RSRequest %p RC %d reqID %lld clientID %lld %zd bytes @ %lld [%lld:%lld] time %lld", a1, v5, *(void *)(a1 + 32), *(void *)(a1 + 24), *(void *)(a1 + 64), *(void *)(a1 + 56), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 96));
  }
  return Mutable;
}

void readScheduler_BatchRequestIngestApplierFunction(uint64_t a1, uint64_t a2)
{
}

void readScheduler_IngestRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  uint64_t v5 = *(void *)(a1 + 392);
  *(void *)(a2 + 72) = (v4 & (unint64_t)-v5) / v5;
  CFIndex v6 = (void *)(a2 + 72);
  *(void *)(a2 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = ((v4 + v5 + *(void *)(a2 + 64) - 1) & (unint64_t)-v5) / v5 - 1;
  uint64_t v7 = *(void *)(a2 + 96);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count < 1)
  {
LABEL_8:
    uint64_t v12 = 40;
    if (!*(unsigned char *)(a2 + 104)) {
      uint64_t v12 = 32;
    }
    CFArrayRef v13 = *(const __CFArray **)(a1 + v12);
    if (*(void *)(a2 + 80) - *(void *)(a2 + 72) < *(int *)(a1 + 388))
    {
      CFIndex v14 = CFArrayGetCount(v13);
      if (v14 >= 1)
      {
        CFIndex v15 = v14;
        CFIndex v16 = 0;
        while (1)
        {
          long long v45 = 0uLL;
          CFDictionaryRef ValueAtIndex = (char *)CFArrayGetValueAtIndex(v13, v16);
          if (*(void *)(a2 + 48) == *((void *)ValueAtIndex + 4))
          {
            uint64_t v18 = ValueAtIndex;
            CFRange v19 = ValueAtIndex + 96;
            if (readScheduler_CombinePageRanges(a1, (void *)ValueAtIndex + 12, v6, &v45) == 1) {
              break;
            }
          }
          if (v15 == ++v16) {
            goto LABEL_16;
          }
        }
        uint64_t v43 = v45;
        if (*((uint64_t *)&v45 + 1) <= v18[13]) {
          int v25 = 2 * ((uint64_t)v45 < v18[12]);
        }
        else {
          int v25 = (2 * ((uint64_t)v45 < v18[12])) | 4;
        }
        *CFRange v19 = v45;
        v18[11] = *(void *)(v18[2] + 392) * v43;
        readScheduler_AddRequestToRead((uint64_t)v18, a2);
        if (v7 >= v18[10])
        {
          uint64_t v22 = 0;
          int v24 = 1;
        }
        else
        {
          uint64_t v22 = (uint64_t)CFRetain(v18);
          CFArrayRemoveValueAtIndex(v13, v16);
          v18[10] = v7;
          int v24 = 1;
          if (v22)
          {
            int v26 = 0;
LABEL_25:
            CFIndex v27 = CFArrayGetCount(v13);
            if (v27 < 1)
            {
              CFIndex v29 = 0;
            }
            else
            {
              CFIndex v28 = v27;
              CFIndex v29 = 0;
              while (1)
              {
                int v30 = CFArrayGetValueAtIndex(v13, v29);
                uint64_t v31 = *(void *)(v22 + 80);
                uint64_t v32 = v30[10];
                if (v31 < v32) {
                  break;
                }
                if (v31 == v32)
                {
                  BOOL v33 = v30;
                  uint64_t v34 = *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v22 + 48), 0) + 4);
                  if (v34 < *((void *)CFArrayGetValueAtIndex((CFArrayRef)v33[6], 0) + 4)) {
                    break;
                  }
                }
                if (v28 == ++v29)
                {
                  CFIndex v29 = v28;
                  break;
                }
              }
            }
            CFArrayInsertValueAtIndex(v13, v29, (const void *)v22);
            if (v26) {
              CFIndex v16 = -1;
            }
            else {
              CFIndex v16 = v29;
            }
            goto LABEL_36;
          }
          CFIndex v16 = -1;
        }
LABEL_36:
        if (v24 && v25)
        {
          while (1)
          {
            long long v35 = CFArrayGetValueAtIndex(v13, v16);
            CFIndex v36 = CFArrayGetCount(v13);
            if (v36 < 1) {
              break;
            }
            CFIndex v37 = v36;
            CFIndex v38 = 0;
            while (1)
            {
              if (v16 != v38)
              {
                long long v45 = 0uLL;
                CFAllocatorRef v39 = CFArrayGetValueAtIndex(v13, v38);
                if (v35[4] == v39[4])
                {
                  uint64_t v40 = (uint64_t)v39;
                  if (readScheduler_CombinePageRanges(a1, v39 + 12, v35 + 12, &v45) == 1) {
                    break;
                  }
                }
              }
              if (v37 == ++v38) {
                goto LABEL_55;
              }
            }
            if (v38 >= v16)
            {
              readScheduler_CombineReads(v13, (uint64_t)v35, v40, &v45, v38);
            }
            else
            {
              BOOL v42 = *((uint64_t *)&v45 + 1) > *(void *)(v40 + 104) || (uint64_t)v45 < *(void *)(v40 + 96);
              readScheduler_CombineReads(v13, v40, (uint64_t)v35, &v45, v16);
              CFIndex v16 = v38;
              if (!v42) {
                break;
              }
            }
          }
        }
LABEL_55:
        if (v22)
        {
          CFRelease((CFTypeRef)v22);
        }
        return;
      }
    }
LABEL_16:
    CFAllocatorRef v20 = CFGetAllocator((CFTypeRef)a1);
    if (rsRead_GetTypeID_sRegisterRSReadTypeOnce != -1) {
      dispatch_once_f(&rsRead_GetTypeID_sRegisterRSReadTypeOnce, &rsRead_GetTypeID_sRSReadID, (dispatch_function_t)rsRead_RegisterType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v22 = Instance;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v20, 0, MEMORY[0x1E4F1D510]);
      *(void *)(v22 + 48) = Mutable;
      if (Mutable)
      {
LABEL_20:
        *(void *)(v22 + 16) = a1;
        *(void *)(v22 + 56) = FigAtomicIncrement64(&gNextReadID);
        *(void *)(v22 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v7;
        *(void *)(v22 + 32) = CFRetain(*(CFTypeRef *)(a2 + 48));
        *(_OWORD *)(v22 + 96) = *(_OWORD *)v6;
        *(void *)(v22 + 88) = *(void *)(*(void *)(v22 + 16) + 392) * *(void *)(a2 + 72);
        if (*(unsigned char *)(a2 + 104))
        {
          *(unsigned char *)(v22 + 112) = 1;
          if (*(unsigned char *)(a2 + 92))
          {
            *(unsigned char *)(v22 + 113) = 1;
            FigAtomicIncrement32((atomic_uint *)(a1 + 384));
          }
          else
          {
            *(unsigned char *)(v22 + 113) = 0;
          }
        }
        readScheduler_AddRequestToRead(v22, a2);
        int v24 = 0;
        int v25 = 0;
        int v26 = 1;
        goto LABEL_25;
      }
      int v44 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
      CFRelease((CFTypeRef)v22);
    }
    else
    {
      int v44 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
    }
    if (v44)
    {
      *(_DWORD *)(a2 + 108) = v44;
      readScheduler_HandleFailedRequest(a1, (_DWORD *)a2);
      return;
    }
    uint64_t v22 = 0;
    goto LABEL_20;
  }
  CFIndex v9 = Count;
  CFIndex v10 = 0;
  while (1)
  {
    uint64_t v11 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v10);
    if (*(void *)(a2 + 48) == v11[4] && *v6 >= v11[12] && *(void *)(a2 + 80) <= v11[13] && !*((unsigned char *)v11 + 114)) {
      break;
    }
    if (v9 == ++v10) {
      goto LABEL_8;
    }
  }

  readScheduler_AddRequestToRead((uint64_t)v11, a2);
}

uint64_t readScheduler_CombinePageRanges(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = *a3;
  if (*a3 <= *a2) {
    uint64_t v5 = *a2;
  }
  else {
    uint64_t v5 = *a3;
  }
  if (*a3 >= *a2) {
    CFIndex v6 = a3;
  }
  else {
    CFIndex v6 = a2;
  }
  if (*a3 < *a2)
  {
    uint64_t v7 = a3;
  }
  else
  {
    uint64_t v4 = *a2;
    uint64_t v7 = a2;
  }
  if (v4 == v5)
  {
    *a4 = v5;
    uint64_t v8 = v6[1];
    if (v7[1] > v8) {
      uint64_t v8 = v7[1];
    }
  }
  else
  {
    uint64_t v9 = v7[1];
    if (v9 >= v5 - 1)
    {
      *a4 = v4;
      uint64_t v8 = v6[1];
      if (v9 > v8) {
        uint64_t v8 = v9;
      }
    }
    else
    {
      if (v5 - v9 > 2) {
        return 0;
      }
      *a4 = v4;
      uint64_t v8 = v6[1];
    }
  }
  a4[1] = v8;
  if (v8 - v4 < *(int *)(a1 + 388)) {
    return 1;
  }
  else {
    return 2;
  }
}

void readScheduler_AddRequestToRead(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  while ((Count & 0x8000000000000000) == 0)
  {
    CFIndex v5 = Count;
    if (Count)
    {
      uint64_t v6 = *(void *)(a2 + 32);
      --Count;
      if (v6 <= *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v5 - 1) + 4)) {
        continue;
      }
    }
    CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 48), v5, (const void *)a2);
    break;
  }
  if (*(unsigned char *)(a2 + 104) && (*(unsigned char *)(a2 + 92) & 1) == 0 && *(unsigned char *)(a1 + 112) && *(unsigned char *)(a1 + 113))
  {
    *(unsigned char *)(a1 + 113) = 0;
    uint64_t v7 = (atomic_uint *)(*(void *)(a1 + 16) + 384);
    FigAtomicDecrement32(v7);
  }
}

void readScheduler_HandleFailedRequest(uint64_t a1, _DWORD *cf)
{
  BOOL v4 = cf[27] == -17785;
  CFRetain(cf);
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 72), cf, (dispatch_function_t)readScheduler_DispatchRequestCallback);

  readScheduler_UpdateBatches(a1, cf, v4);
}

uint64_t rsRead_RegisterType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

double rsRead_Init(uint64_t a1)
{
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void rsRead_Finalize(void *a1)
{
  CFAllocatorRef v2 = (const void *)a1[4];
  if (v2)
  {
    CFRelease(v2);
    a1[4] = 0;
  }
  CFStringRef v3 = (const void *)a1[5];
  if (v3)
  {
    CFRelease(v3);
    a1[5] = 0;
  }
  BOOL v4 = (const void *)a1[6];
  if (v4)
  {
    CFRelease(v4);
    a1[6] = 0;
  }
}

__CFString *rsRead_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  int v5 = *(unsigned __int8 *)(a1 + 112);
  CFIndex v6 = CFGetRetainCount((CFTypeRef)a1);
  if (v5)
  {
    if (*(unsigned char *)(a1 + 113)) {
      uint64_t v7 = "Latched ";
    }
    else {
      uint64_t v7 = "";
    }
    uint64_t v8 = *(void *)(a1 + 24);
    if (v8) {
      uint64_t v9 = *(unsigned int *)(v8 + 40);
    }
    else {
      uint64_t v9 = 0xFFFFFFFFLL;
    }
    CFStringAppendFormat(Mutable, 0, @"RSRead %p RC %d Background %sreadID %lld context %d BS %@ @ %lld [%lld:%lld] numReqs %d\n", a1, v6, v7, *(void *)(a1 + 56), v9, *(void *)(a1 + 32), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), Count);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 24);
    if (v10) {
      uint64_t v11 = *(unsigned int *)(v10 + 40);
    }
    else {
      uint64_t v11 = 0xFFFFFFFFLL;
    }
    CFStringAppendFormat(Mutable, 0, @"RSRead %p RC %d readID %lld context %d BS %@ @ %lld [%lld:%lld] time %lld numReqs %d\n", a1, v6, *(void *)(a1 + 56), v11, *(void *)(a1 + 32), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), *(void *)(a1 + 80), Count);
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), i);
      CFStringRef v14 = CFCopyDescription(ValueAtIndex);
      CFStringAppendFormat(Mutable, 0, @"\t%2d. %@\n", i, v14);
      if (v14) {
        CFRelease(v14);
      }
    }
  }
  return Mutable;
}

void readScheduler_DispatchRequestCallback(const void *a1)
{
  readScheduler_CallRequestCallback((uint64_t)a1);

  CFRelease(a1);
}

void readScheduler_CombineReads(__CFArray *a1, uint64_t a2, uint64_t a3, _OWORD *a4, CFIndex a5)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 48));
  if (Count >= 1)
  {
    CFIndex v11 = Count;
    for (CFIndex i = 0; i != v11; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 48), i);
      readScheduler_AddRequestToRead(a2, (uint64_t)ValueAtIndex);
    }
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a3 + 48));
  if (*(unsigned char *)(a3 + 112) && *(unsigned char *)(a3 + 113))
  {
    *(unsigned char *)(a3 + 113) = 0;
    FigAtomicDecrement32((atomic_uint *)(*(void *)(a3 + 16) + 384));
  }
  *(_OWORD *)(a2 + 96) = *a4;
  *(void *)(a2 + 88) = *(void *)(*(void *)(a2 + 16) + 392) * *(void *)a4;

  CFArrayRemoveValueAtIndex(a1, a5);
}

void readScheduler_CancelRequestApplierFunction(_DWORD *cf, uint64_t a2)
{
  cf[27] = -17785;
  readScheduler_HandleFailedRequest(a2, cf);
}

void readScheduler_RemoveMatchingRequestsFromReadArray(const __CFArray *a1, const __CFSet *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v6);
      CFIndex v8 = CFArrayGetCount(ValueAtIndex[6]);
      if (v8 >= 1)
      {
        CFIndex v9 = v8;
        CFIndex v10 = 0;
        do
        {
          CFIndex v11 = CFArrayGetValueAtIndex(ValueAtIndex[6], v10);
          if (CFSetContainsValue(a2, v11))
          {
            CFArrayRemoveValueAtIndex(ValueAtIndex[6], v10);
            --v9;
          }
          else
          {
            ++v10;
          }
        }
        while (v10 < v9);
      }
      if (CFArrayGetCount(ValueAtIndex[6]))
      {
        ++v6;
      }
      else
      {
        CFArrayRemoveValueAtIndex(a1, v6);
        --v5;
      }
    }
    while (v6 < v5);
  }
}

void readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(const __CFArray *a1, const __CFSet *a2, __CFArray *a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v8);
      CFIndex v10 = CFArrayGetCount(ValueAtIndex[6]);
      if (v10 < 1) {
        goto LABEL_10;
      }
      CFIndex v11 = v10;
      uint64_t v12 = CFArrayGetValueAtIndex(ValueAtIndex[6], 0);
      if (!CFSetContainsValue(a2, v12)) {
        break;
      }
LABEL_5:
      CFArrayAppendValue(a3, ValueAtIndex);
      CFArrayRemoveValueAtIndex(a1, v8);
      --v7;
LABEL_11:
      if (v8 >= v7) {
        return;
      }
    }
    CFIndex v13 = 1;
    while (v11 != v13)
    {
      CFStringRef v14 = CFArrayGetValueAtIndex(ValueAtIndex[6], v13++);
      if (CFSetContainsValue(a2, v14))
      {
        if (v13 - 1 < v11) {
          goto LABEL_5;
        }
        break;
      }
    }
LABEL_10:
    ++v8;
    goto LABEL_11;
  }
}

void readScheduler_ExpediteReadsArrayApplierFunction(void *a1, uint64_t a2)
{
}

double readScheduler_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void readScheduler_Finalize(void *a1)
{
  CFAllocatorRef v2 = a1[10];
  if (v2)
  {
    dispatch_source_cancel(v2);
    CFStringRef v3 = a1[10];
    if (v3)
    {
      dispatch_release(v3);
      a1[10] = 0;
    }
  }
  for (uint64_t i = 0; i != 32; i += 8)
  {
    CFIndex v5 = &a1[i];
    FigCFWeakReferenceStore((id *)&a1[i + 19], 0);
    CFIndex v6 = (const void *)a1[i + 16];
    if (v6)
    {
      CFRelease(v6);
      v5[16] = 0;
    }
    CFIndex v7 = v5[15];
    if (v7)
    {
      dispatch_release(v7);
      v5[15] = 0;
    }
  }
  CFIndex v8 = (const void *)a1[2];
  if (v8)
  {
    CFRelease(v8);
    a1[2] = 0;
  }
  CFIndex v9 = (const void *)a1[3];
  if (v9)
  {
    CFRelease(v9);
    a1[3] = 0;
  }
  CFIndex v10 = (const void *)a1[4];
  if (v10)
  {
    CFRelease(v10);
    a1[4] = 0;
  }
  CFIndex v11 = (const void *)a1[5];
  if (v11)
  {
    CFRelease(v11);
    a1[5] = 0;
  }
  uint64_t v12 = (const void *)a1[6];
  if (v12)
  {
    CFRelease(v12);
    a1[6] = 0;
  }
  CFIndex v13 = (const void *)a1[14];
  if (v13)
  {
    CFRelease(v13);
    a1[14] = 0;
  }
  CFStringRef v14 = (const void *)a1[13];
  if (v14)
  {
    CFRelease(v14);
    a1[13] = 0;
  }
  CFIndex v15 = a1[8];
  if (v15)
  {
    dispatch_release(v15);
    a1[8] = 0;
  }
  CFIndex v16 = a1[9];
  if (v16)
  {
    dispatch_release(v16);
    a1[9] = 0;
  }
  size_t v17 = a1[7];
  if (v17)
  {
    dispatch_release(v17);
    a1[7] = 0;
  }
}

__CFString *readScheduler_CopyDebugDesc(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  BOOL v4 = FigCFCopyCompactDescription(*(const __CFSet **)(a1 + 16));
  CFIndex v5 = CFGetRetainCount((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"FigReadScheduler %p(%d) \"%s\": sched=%@ background=%@ inFlight=%@ batches=%@ inProg=%d info={%@}", a1, v5, a1 + 400, *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 24), *(void *)(a1 + 48), *(unsigned int *)(a1 + 380), v4);
  if (v4) {
    CFRelease(v4);
  }
  return Mutable;
}

CFTypeRef readScheduler_RemoveAndRetainRequestFromReadArray(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v6);
    CFIndex v8 = CFArrayGetCount(ValueAtIndex[6]);
    if (v8 >= 1)
    {
      CFIndex v9 = v8;
      CFIndex v10 = 0;
      while (1)
      {
        CFIndex v11 = CFArrayGetValueAtIndex(ValueAtIndex[6], v10);
        if (v11[4] == a2) {
          break;
        }
        if (v9 == ++v10) {
          goto LABEL_9;
        }
      }
      CFTypeRef v12 = CFRetain(v11);
      CFArrayRemoveValueAtIndex(ValueAtIndex[6], v10);
      if (v12) {
        break;
      }
    }
LABEL_9:
    if (++v6 == v5) {
      return 0;
    }
  }
  if (!CFArrayGetCount(ValueAtIndex[6])) {
    CFArrayRemoveValueAtIndex(a1, v6);
  }
  return v12;
}

uint64_t readScheduler_RemoveAndCollectReadForRequestToExpediteFromReadArray(const __CFArray *a1, uint64_t a2, __CFSet *a3, __CFArray *a4)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v9 = Count;
  CFIndex v10 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v10);
    CFIndex v12 = CFArrayGetCount(ValueAtIndex[6]);
    if (v12 >= 1) {
      break;
    }
LABEL_7:
    if (++v10 == v9) {
      return 0;
    }
  }
  CFIndex v13 = v12;
  CFIndex v14 = 0;
  while (1)
  {
    CFIndex v15 = CFArrayGetValueAtIndex(ValueAtIndex[6], v14);
    if (v15[4] == a2) {
      break;
    }
    if (v13 == ++v14) {
      goto LABEL_7;
    }
  }
  CFSetAddValue(a3, v15);
  CFArrayAppendValue(a4, ValueAtIndex);
  CFArrayRemoveValueAtIndex(a1, v10);
  return 1;
}

void readScheduler_RemoveAndCollectClientRequestsFromReadArray(const __CFArray *a1, uint64_t a2, __CFSet *a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v8);
      CFIndex v10 = CFArrayGetCount(ValueAtIndex[6]);
      if (v10 >= 1)
      {
        CFIndex v11 = v10;
        CFIndex v12 = 0;
        do
        {
          CFIndex v13 = CFArrayGetValueAtIndex(ValueAtIndex[6], v12);
          if (v13[3] == a2)
          {
            CFSetAddValue(a3, v13);
            CFArrayRemoveValueAtIndex(ValueAtIndex[6], v12);
            --v11;
          }
          else
          {
            ++v12;
          }
        }
        while (v12 < v11);
      }
      if (CFArrayGetCount(ValueAtIndex[6]))
      {
        ++v8;
      }
      else
      {
        CFArrayRemoveValueAtIndex(a1, v8);
        --v7;
      }
    }
    while (v8 < v7);
  }
}

void readScheduler_RemoveAndCollectClientReadsToExpediteFromReadArray(const __CFArray *a1, uint64_t a2, __CFSet *a3, __CFArray *a4)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v9 = Count;
    CFIndex v10 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v10);
      CFIndex v12 = CFArrayGetCount(ValueAtIndex[6]);
      if (v12 < 1) {
        goto LABEL_10;
      }
      CFIndex v13 = v12;
      CFIndex v14 = 0;
      int v15 = 0;
      do
      {
        CFIndex v16 = CFArrayGetValueAtIndex(ValueAtIndex[6], v14);
        if (v16[3] == a2)
        {
          CFSetAddValue(a3, v16);
          int v15 = 1;
        }
        ++v14;
      }
      while (v13 != v14);
      if (v15)
      {
        CFArrayAppendValue(a4, ValueAtIndex);
        CFArrayRemoveValueAtIndex(a1, v10);
        --v9;
      }
      else
      {
LABEL_10:
        ++v10;
      }
    }
    while (v10 < v9);
  }
}

uint64_t FigNTPClientGetTypeID()
{
  if (sRegisterFigNTPClientTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigNTPClientTypeOnce, 0, (dispatch_function_t)RegisterFigNTPClientIDType);
  }
  return sFigNTPClientID;
}

uint64_t RegisterFigNTPClientIDType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigNTPClientID = result;
  return result;
}

uint64_t FigNTPClientCreate(uint64_t a1, uint64_t *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigNTPTrace[1], @"figntp_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v3, 0, gFigNTPTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272ED8, @"figntp_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272ED0);
  if (dword_1E9272ED8)
  {
    v18[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272ED0, 1, v18, &type);
    int v5 = v18[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v7 = v5;
    }
    else {
      unsigned int v7 = v5 & 0xFFFFFFFE;
    }
    if (v7)
    {
      v18[1] = 136315138;
      CFRange v19 = "FigNTPClientCreate";
      CFIndex v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v18[0];
    }
    else
    {
      CFIndex v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272ED0, 1u, 1, v8, v8 != &v20, v5, 0, v6);
  }
  if (a2)
  {
    if (sRegisterFigNTPClientTypeOnce != -1) {
      dispatch_once_f(&sRegisterFigNTPClientTypeOnce, 0, (dispatch_function_t)RegisterFigNTPClientIDType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v10 = Instance;
      *(void *)(Instance + 16) = 0;
      *(void *)(Instance + 24) = 0;
      *(_DWORD *)(Instance + 32) = 0;
      CFPreferenceOrOptionNumberWithCFAllocatorRef Default = (int)FigGetCFPreferenceOrOptionNumberWithDefault(0, @"ntp_timeout", @"com.apple.coremedia", 1);
      *(_DWORD *)(v10 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
      *(void *)(v10 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = FigDispatchQueueCreateWithPriority("com.apple.coremedia.figntpclient", 0, 0);
      *(void *)(v10 + 56) = FigDispatchQueueCreateWithPriority("com.apple.coremedia.figntpclient_dns", 0, 0);
      CFRetain((CFTypeRef)v10);
      CFIndex v12 = *(NSObject **)(v10 + 40);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __FigNTPClientCreate_block_invoke;
      block[3] = &__block_descriptor_tmp_14;
      int v16 = 5;
      void block[4] = CFPreferenceOrOptionNumberWithDefault;
      void block[5] = v10;
      dispatch_async(v12, block);
      uint64_t result = 0;
      *a2 = v10;
      return result;
    }
    uint64_t v14 = 4294951425;
  }
  else
  {
    uint64_t v14 = 4294951426;
  }
  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

void __FigNTPClientCreate_block_invoke(uint64_t a1)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  MEMORY[0x1F4188790]();
  BOOL v4 = &(&v45)[-2 * v3];
  double v58 = 0;
  CFStringRef v5 = (const __CFString *)FigCopyCFPreferenceAppValueOrOptionCFTypeWithDefault(0, @"ntp_hostname", @"com.apple.coremedia", @"time.apple.com");
  CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v5, 0x8000100u, &v58);
  *(void *)(*(void *)(a1 + 40) + 48) = dispatch_semaphore_create(0);
  *(void *)(*(void *)(a1 + 40) + 72) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  LODWORD(v7) = *(_DWORD *)(a1 + 48);
  if ((int)v7 >= 1)
  {
    CFStringRef v46 = v5;
    CFIndex v8 = v4;
    uint64_t v9 = 0;
    unint64_t v10 = (unint64_t)(1000000 * v2) >> 1;
    unint64_t v50 = 1000000 * v2 / 0x1E8480uLL;
    int64_t v51 = 1000 * v10;
    int v49 = v10 - 1000000 * v50;
    long long v48 = &block[16];
    *(void *)&long long v6 = 136315394;
    long long v47 = v6;
    long long v45 = v8;
    do
    {
      CFIndex v11 = *(dispatch_semaphore_t **)(a1 + 40);
      DNSServiceRef v59 = 0;
      dispatch_time_t v12 = dispatch_time(0, v51);
      uint64_t v60 = 0;
      long long v61 = &v60;
      uint64_t v62 = 0x6800000000;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      uint64_t AddrInfo = DNSServiceGetAddrInfo(&v59, 0x10000u, 0, 1u, CStringPtrAndBufferToFree, (DNSServiceGetAddrInfoReply)figNTPClient_addressInfoCallBack, v11);
      if (AddrInfo || (uint64_t AddrInfo = DNSServiceSetDispatchQueue(v59, v11[7]), AddrInfo))
      {
        *((_DWORD *)v61 + 6) = 1;
        FigSignalErrorAt(AddrInfo, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        dispatch_semaphore_wait(v11[6], v12);
        uint64_t v14 = v11[7];
        *(void *)uint64_t block = MEMORY[0x1E4F143A8];
        *(void *)&void block[8] = 0x40000000;
        *(void *)&block[16] = __figNTPClient_sntp_unicast_block_invoke;
        CFNumberRef v69 = &unk_1E5678398;
        int v77 = v9;
        int v78 = 123;
        char v79 = 0;
        CFNumberRef v70 = &v60;
        uint64_t v71 = v11;
        unint64_t v72 = v50;
        int v73 = v49;
        int v74 = 0;
        uint64_t v75 = figntp_gettime;
        DNSServiceRef v76 = v59;
        dispatch_sync(v14, block);
      }
      long long v15 = *(_OWORD *)(v61 + 7);
      long long v54 = *(_OWORD *)(v61 + 5);
      long long v55 = v15;
      long long v16 = *(_OWORD *)(v61 + 11);
      long long v56 = *(_OWORD *)(v61 + 9);
      long long v57 = v16;
      long long v53 = *(_OWORD *)(v61 + 3);
      _Block_object_dispose(&v60, 8);
      long long v17 = v56;
      CFArrayRef v8[2] = v55;
      _OWORD v8[3] = v17;
      void v8[4] = v57;
      long long v18 = v54;
      *CFIndex v8 = v53;
      v8[1] = v18;
      uint64_t v19 = *(unsigned int *)v8;
      if (v19)
      {
        LODWORD(v53) = 0;
        LOBYTE(v59) = 0;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272ED0, 0, (int *)&v53, &v59);
        unsigned int v21 = v53;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, (os_log_type_t)v59)) {
          unsigned int v23 = v21;
        }
        else {
          unsigned int v23 = v21 & 0xFFFFFFFE;
        }
        if (v23)
        {
          int v24 = sntp_result_strings[v19];
          *(_DWORD *)uint64_t block = v47;
          *(void *)&void block[4] = "FigNTPClientCreate_block_invoke";
          *(_WORD *)&block[12] = 2082;
          *(void *)&block[14] = v24;
          int v25 = (uint64_t *)_os_log_send_and_compose_impl();
          LOBYTE(v21) = v53;
        }
        else
        {
          int v25 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272ED0, 0, 1, v25, v25 != &v60, v21, 0, v22);
      }
      ++v9;
      uint64_t v7 = *(int *)(a1 + 48);
      v8 += 5;
    }
    while (v9 < v7);
    BOOL v4 = v45;
    CFStringRef v5 = v46;
  }
  unint64_t v26 = sntp_clock_select((unint64_t)v4, v7);
  if (v26)
  {
    uint64_t v27 = *(void *)(a1 + 40);
    *(void *)(v27 + 16) = sntp_calc_offset(v26);
    *(void *)(v27 + 24) = v28;
    uint64_t v29 = *(void *)(a1 + 40);
    unint64_t v30 = *(void *)(v29 + 24);
    *(void *)(v29 + 16) -= 2208988800;
    int v31 = sntp_datestamp_subsecs_to_nsec(v30);
    uint64_t v32 = *(void *)(a1 + 40);
    *(_DWORD *)(v32 + 32) = v31;
    *(_DWORD *)(v32 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
    if (dword_1E9272ED8)
    {
      LODWORD(v53) = 0;
      LOBYTE(v59) = 0;
      BOOL v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272ED0, 1, (int *)&v53, &v59);
      unsigned int v34 = v53;
      if (os_log_type_enabled(v33, (os_log_type_t)v59)) {
        unsigned int v36 = v34;
      }
      else {
        unsigned int v36 = v34 & 0xFFFFFFFE;
      }
      if (v36)
      {
        *(_DWORD *)uint64_t block = 136315138;
        *(void *)&void block[4] = "FigNTPClientCreate_block_invoke";
        CFIndex v37 = (uint64_t *)_os_log_send_and_compose_impl();
        LOBYTE(v34) = v53;
      }
      else
      {
        CFIndex v37 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272ED0, 1u, 1, v37, v37 != &v60, v34, 0, v35);
      uint64_t v32 = *(void *)(a1 + 40);
    }
  }
  else
  {
    LODWORD(v53) = 0;
    LOBYTE(v59) = 0;
    CFIndex v38 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272ED0, 0, (int *)&v53, &v59);
    unsigned int v39 = v53;
    if (os_log_type_enabled(v38, (os_log_type_t)v59)) {
      unsigned int v41 = v39;
    }
    else {
      unsigned int v41 = v39 & 0xFFFFFFFE;
    }
    if (v41)
    {
      *(_DWORD *)uint64_t block = 136315138;
      *(void *)&void block[4] = "FigNTPClientCreate_block_invoke";
      BOOL v42 = (uint64_t *)_os_log_send_and_compose_impl();
      LOBYTE(v39) = v53;
    }
    else
    {
      BOOL v42 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272ED0, 0, 1, v42, v42 != &v60, v39, 0, v40);
    uint64_t v32 = *(void *)(a1 + 40);
    *(_DWORD *)(v32 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 2;
  }
  uint64_t v43 = *(const void **)(v32 + 72);
  if (v43)
  {
    CFRelease(v43);
    uint64_t v32 = *(void *)(a1 + 40);
  }
  int v44 = *(NSObject **)(v32 + 48);
  if (v44) {
    dispatch_release(v44);
  }
  if (v5) {
    CFRelease(v5);
  }
  free(v58);
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

unint64_t figntp_gettime()
{
  v3.tv_sec = 0;
  v3.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC, &v3);
  unsigned int v0 = sntp_datestamp_from_timespec(v3.tv_sec);
  return sntp_timestamp_from_datestamp(v0, v1);
}

uint64_t FigNTPGetTimeOfDay(uint64_t a1, _OWORD *a2)
{
  uint64_t v12 = 0;
  CFIndex v13 = &v12;
  uint64_t v14 = 0x2000000000;
  int v15 = 0;
  uint64_t v7 = 0;
  CFIndex v8 = &v7;
  uint64_t v9 = 0x2800000000;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  timespec v3 = *(NSObject **)(a1 + 40);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  int v6[2] = __FigNTPGetTimeOfDay_block_invoke;
  v6[3] = &unk_1E5678370;
  void v6[5] = &v12;
  v6[6] = a1;
  v6[4] = &v7;
  dispatch_sync(v3, v6);
  if (a2) {
    *a2 = *(_OWORD *)(v8 + 3);
  }
  uint64_t v4 = *((unsigned int *)v13 + 6);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v12, 8);
  return v4;
}

void __FigNTPGetTimeOfDay_block_invoke(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(a1[6] + 80);
  if (v2)
  {
    if (v2 == 1)
    {
      if (clock_gettime(_CLOCK_MONOTONIC, (timespec *)(*(void *)(a1[4] + 8) + 24)))
      {
        *(_DWORD *)(*(void *)(a1[5] + 8) + 24) = -15874;
      }
      else
      {
        uint64_t v9 = a1[6];
        uint64_t v10 = *(void *)(v9 + 16);
        *(void *)(*(void *)(a1[4] + 8) + 24) += v10;
        uint64_t v11 = *(void *)(a1[4] + 8);
        uint64_t v12 = *(void *)(v11 + 32);
        uint64_t v13 = *(unsigned int *)(v9 + 32);
        if (v10 < 0) {
          uint64_t v14 = v12 - v13;
        }
        else {
          uint64_t v14 = v12 + v13;
        }
        *(void *)(v11 + 32) = v14;
      }
    }
    else
    {
      *(_DWORD *)(*(void *)(a1[5] + 8) + 24) = -15873;
      if (dword_1E9272ED8)
      {
        v16[0] = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272ED0, 1, v16, &type);
        int v4 = v16[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v6 = v4;
        }
        else {
          unsigned int v6 = v4 & 0xFFFFFFFE;
        }
        if (v6)
        {
          uint64_t v7 = a1[6];
          v16[1] = 136315394;
          long long v17 = "FigNTPGetTimeOfDay_block_invoke";
          __int16 v18 = 2048;
          uint64_t v19 = v7;
          CFIndex v8 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v4) = v16[0];
        }
        else
        {
          CFIndex v8 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272ED0, 1u, 1, v8, v8 != &v20, v4, 0, v5);
      }
    }
  }
  else
  {
    *(_DWORD *)(*(void *)(a1[5] + 8) + 24) = FigSignalErrorAt(4294951424, 0, 0, 0, 0, 0, 0);
  }
}

unint64_t FigNTPTimestampFromTimeOfDayTime(CMTime *a1)
{
  CMTime v5 = *a1;
  Float64 Seconds = CMTimeGetSeconds(&v5);
  sntp_datestamp_from_double(Seconds + 2208988800.0);
  return sntp_timestamp_from_datestamp(v2, v3);
}

CMTime *FigTimeOfDayTimeFromNTPTimestamp@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = sntp_timestamp_to_datestamp(a1);
  double v5 = sntp_datestamp_to_double(v3, v4);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;

  return CMTimeMake((CMTime *)a2, (uint64_t)((v5 + -2208988800.0) * 1000000.0), 1000000);
}

double figNTPClient_Init(uint64_t a1)
{
  *(void *)(a1 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigNTPClient_Finalize(uint64_t a1)
{
  unsigned int v2 = *(NSObject **)(a1 + 56);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_release(v3);
  }
}

CFStringRef FigNTPClient_CopyFormattingDesc(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"FigNTPClient");
}

CFStringRef FigNTPClient_CopyDebugDesc(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"FigNTPClient");
}

void figNTPClient_addressInfoCallBack(uint64_t a1, char a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    FigSignalErrorAt(4294951422, 0, 0, 0, 0, 0, 0);
  }
  else if (a1 && a6)
  {
    if ((a2 & 2) != 0 && *(unsigned char *)(a6 + 1) == 2)
    {
      CFNumberRef UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(_DWORD *)(a6 + 4));
      CFArrayAppendValue(*(CFMutableArrayRef *)(a8 + 72), UInt32);
      if (UInt32) {
        CFRelease(UInt32);
      }
      *(unsigned char *)(a8 + 64) = 1;
    }
    if ((a2 & 1) == 0)
    {
      uint64_t v11 = *(NSObject **)(a8 + 48);
      dispatch_semaphore_signal(v11);
    }
  }
}

void __figNTPClient_sntp_unicast_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 64))
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 72);
    if (v3)
    {
      unsigned int Count = CFArrayGetCount(v3);
      CFArrayRef v3 = *(const __CFArray **)(*(void *)(a1 + 40) + 72);
    }
    else
    {
      unsigned int Count = 0;
    }
    CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v3, *(_DWORD *)(a1 + 80) % Count);
    *(_DWORD *)&v17.sa_len = 512;
    *(_DWORD *)&v17.sa_data[10] = 0;
    *(void *)&v17.sa_data[2] = FigCFNumberGetUInt64(ValueAtIndex);
    *(_WORD *)v17.sa_data = bswap32(*(unsigned __int16 *)(a1 + 84)) >> 16;
    int v6 = socket(2, 2, 17);
    if (v6)
    {
      int v7 = v6;
      if (*(unsigned char *)(a1 + 88)
        && (*(void *)&v16.sa_len = 2063598080, *(void *)&v16.sa_data[6] = 0, bind(v6, &v16, 0x10u)))
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
        int v9 = 3;
      }
      else
      {
        if (!connect(v7, &v17, 0x10u))
        {
          sntp_client_exchange(v7, (timeval *)(a1 + 48), *(uint64_t (**)(void))(a1 + 64), (uint64_t)v15);
          uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
          long long v11 = v15[4];
          long long v12 = v15[3];
          long long v13 = v15[2];
          long long v14 = v15[0];
          *(_OWORD *)(v10 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v15[1];
          *(_OWORD *)(v10 + 56) = v13;
          *(_OWORD *)(v10 + 72) = v12;
          *(_OWORD *)(v10 + 88) = v11;
          *(_OWORD *)(v10 + 24) = v14;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 84) = *(_DWORD *)&v17.sa_data[2];
          goto LABEL_15;
        }
        uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
        int v9 = 4;
      }
      *(_DWORD *)(v8 + 24) = v9;
LABEL_15:
      close(v7);
      goto LABEL_16;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 2;
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
LABEL_16:
  DNSServiceRefDeallocate(*(DNSServiceRef *)(a1 + 72));
}

uint64_t FigSandboxRegistrationRemoteGetTypeID()
{
  if (sRegisterFigSandboxRegistrationRemoteTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigSandboxRegistrationRemoteTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationRemoteType);
  }
  return sFigSandboxRegistrationRemoteID;
}

uint64_t RegisterFigSandboxRegistrationRemoteType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigSandboxRegistrationRemoteID = result;
  return result;
}

uint64_t FigSandboxRegistrationRemoteCreate(int a1, const char *a2, const void *a3, const void *a4, NSObject *a5, void *a6)
{
  xpc_object_t xdict = 0;
  *(void *)int v24 = 0;
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (sRegisterFigSandboxRegistrationRemoteTypeOnce != -1) {
    dispatch_once_f(&sRegisterFigSandboxRegistrationRemoteTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationRemoteType);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (!Instance) {
    goto LABEL_17;
  }
  uint64_t v14 = remoteSandboxReg_copyRemoteClientForProcess(a1, Instance + 7);
  if (v14) {
    goto LABEL_18;
  }
  Instance[2] = CFRetain(a3);
  CFTypeRef v15 = CFRetain(a4);
  Instance[3] = a5;
  Instance[4] = v15;
  dispatch_retain(a5);
  uint64_t v14 = FigXPCCreateBasicMessage(0x63726538u, 0, v24);
  if (v14) {
    goto LABEL_18;
  }
  size_t v16 = strlen(a2);
  CFDataRef v17 = CFDataCreate(v12, (const UInt8 *)a2, v16 + 1);
  if (!v17)
  {
LABEL_17:
    uint64_t v14 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
LABEL_18:
    uint64_t v21 = v14;
    goto LABEL_14;
  }
  CFDataRef v18 = v17;
  uint64_t v19 = FigXPCMessageSetCFData(*(void **)v24, "ExtensionTokenData", v17);
  if (v19) {
    goto LABEL_19;
  }
  if (FigIsItOKToLogURLs()) {
    FigXPCMessageSetCFString(*(void **)v24, "ExtensionPath", a3);
  }
  uint64_t v19 = FigXPCRemoteClientSendSyncMessageCreatingReply(Instance[7], *(uint64_t *)v24, &xdict);
  if (v19)
  {
LABEL_19:
    uint64_t v21 = v19;
  }
  else
  {
    uint64_t uint64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
    uint64_t v21 = FigXPCRemoteClientAssociateObject(Instance[7], (uint64_t)Instance, uint64);
    if (!v21)
    {
      Instance[5] = uint64;
      *a6 = Instance;
      uint64_t Instance = 0;
    }
  }
  CFRelease(v18);
LABEL_14:
  FigXPCRelease(*(xpc_object_t *)v24);
  FigXPCRelease(xdict);
  if (Instance) {
    CFRelease(Instance);
  }
  return v21;
}

uint64_t remoteSandboxReg_copyRemoteClientForProcess(int a1, void *a2)
{
  if (a1 == 2)
  {
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    int v6[2] = __remoteSandboxReg_copyRemoteClientForProcess_block_invoke_2;
    v6[3] = &__block_descriptor_tmp_7_3;
    int v7 = 2;
    if (remoteSandboxReg_copyRemoteClientForProcess_gCaptureSandboxRegRemoteClientSetupOnce != -1) {
      dispatch_once(&remoteSandboxReg_copyRemoteClientForProcess_gCaptureSandboxRegRemoteClientSetupOnce, v6);
    }
    uint64_t result = remoteSandboxReg_copyRemoteClientForProcess_captureErr;
    if (!remoteSandboxReg_copyRemoteClientForProcess_captureErr)
    {
      unint64_t v4 = (const void *)gCameraCaptureSandboxRegistrationRemoteClient;
      if (!gCameraCaptureSandboxRegistrationRemoteClient) {
        goto LABEL_7;
      }
      goto LABEL_12;
    }
  }
  else if (a1 == 1)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __remoteSandboxReg_copyRemoteClientForProcess_block_invoke;
    block[3] = &__block_descriptor_tmp_6_0;
    int v9 = 1;
    if (remoteSandboxReg_copyRemoteClientForProcess_gPlaybackSandboxRegRemoteClientSetupOnce != -1) {
      dispatch_once(&remoteSandboxReg_copyRemoteClientForProcess_gPlaybackSandboxRegRemoteClientSetupOnce, block);
    }
    uint64_t result = remoteSandboxReg_copyRemoteClientForProcess_playbackErr;
    if (!remoteSandboxReg_copyRemoteClientForProcess_playbackErr)
    {
      unint64_t v4 = (const void *)gPlaybackSandboxRegistrationRemoteClient;
      if (!gPlaybackSandboxRegistrationRemoteClient)
      {
LABEL_7:
        CFTypeRef v5 = 0;
LABEL_13:
        uint64_t result = 0;
        *a2 = v5;
        return result;
      }
LABEL_12:
      CFTypeRef v5 = CFRetain(v4);
      goto LABEL_13;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t FigSandboxRegistrationRemoteGetObjectID(uint64_t a1, void *a2)
{
  if (!a1 || !a2 || *(unsigned char *)(a1 + 48)) {
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *(void *)(a1 + 40);
  return 0;
}

double figSandboxRegistrationRemoteInit(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void figSandboxRegistrationRemoteFinalize(uint64_t a1)
{
  xpc_object_t v12 = 0;
  if (*(void *)(a1 + 24))
  {
    uint64_t v2 = *(const void **)(a1 + 16);
    if (v2)
    {
      if (*(void *)(a1 + 32))
      {
        CFTypeRef v3 = CFRetain(v2);
        CFTypeRef v4 = CFRetain(*(CFTypeRef *)(a1 + 32));
        CFTypeRef v5 = *(NSObject **)(a1 + 24);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = __figSandboxRegistrationRemoteFinalize_block_invoke;
        block[3] = &__block_descriptor_tmp_15;
        void block[4] = v4;
        void block[5] = v3;
        dispatch_async(v5, block);
      }
    }
  }
  int v6 = *(const void **)(a1 + 40);
  if (v6)
  {
    FigXPCRemoteClientDisassociateObject(*(void *)(a1 + 56), v6);
    if (!*(unsigned char *)(a1 + 48))
    {
      FigXPCCreateBasicMessage(0x646F6F6Du, *(void *)(a1 + 40), &v12);
      FigXPCRemoteClientSendSyncMessage(*(void *)(a1 + 56), (uint64_t)v12);
    }
  }
  int v7 = *(const void **)(a1 + 56);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 56) = 0;
  }
  FigXPCRelease(v12);
  uint64_t v8 = *(const void **)(a1 + 16);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 16) = 0;
  }
  int v9 = *(const void **)(a1 + 32);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v10 = *(NSObject **)(a1 + 24);
  if (v10) {
    dispatch_release(v10);
  }
}

__CFString *figSandboxRegistrationRemoteCopyFormattingDesc()
{
  return @"[FigSandboxRegistrationRemote]";
}

__CFString *figSandboxRegistrationRemoteCopyDebugDesc(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"<FigSandboxRegistrationRemote %p> objectID %lld", a1, a1[5]);
  return Mutable;
}

void __figSandboxRegistrationRemoteFinalize_block_invoke(uint64_t a1)
{
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), *(const void **)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFAllocatorRef v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

uint64_t __remoteSandboxReg_copyRemoteClientForProcess_block_invoke(uint64_t a1)
{
  if (FigRemote_ShouldConnectToMediaplaybackd()) {
    uint64_t result = remoteSandboxReg_createRemoteClientForProcess(*(_DWORD *)(a1 + 32), &gPlaybackSandboxRegistrationRemoteClient);
  }
  else {
    uint64_t result = remoteSandboxReg_copyRemoteClientForProcess(2, &gPlaybackSandboxRegistrationRemoteClient);
  }
  remoteSandboxReg_copyRemoteClientForProcess_playbackErr = result;
  return result;
}

uint64_t remoteSandboxReg_createRemoteClientForProcess(int a1, void *a2)
{
  CFTypeRef v4 = remoteSandboxReg_PlaybackProcessDied;
  if (a1 == 1) {
    goto LABEL_4;
  }
  if (a1 == 2)
  {
    CFTypeRef v4 = remoteSandboxReg_CameraCaptureProcessDied;
LABEL_4:
    v9[0] = 1;
    v9[1] = (unint64_t)remoteSandboxReg_DeadConnectionCallback;
    CFArrayRef v9[2] = 0;
    void v9[3] = 0;
    v9[4] = (unint64_t)v4;
    memset(&v9[5], 0, 24);
    int ShouldConnectToMediaplaybackd = FigRemote_ShouldConnectToMediaplaybackd();
    int v6 = "com.apple.coremedia.mediaplaybackd.sandboxserver.xpc";
    if (a1 != 1) {
      int v6 = "com.apple.coremedia.sandboxserver.xpc";
    }
    if (ShouldConnectToMediaplaybackd) {
      int v7 = v6;
    }
    else {
      int v7 = "com.apple.coremedia.sandboxserver.xpc";
    }
    return FigXPCRemoteClientCreate((uint64_t)v7, v9, 0, a2);
  }

  return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
}

uint64_t __remoteSandboxReg_copyRemoteClientForProcess_block_invoke_2(uint64_t a1)
{
  uint64_t result = remoteSandboxReg_createRemoteClientForProcess(*(_DWORD *)(a1 + 32), &gCameraCaptureSandboxRegistrationRemoteClient);
  remoteSandboxReg_copyRemoteClientForProcess_captureErr = result;
  return result;
}

void remoteSandboxReg_PlaybackProcessDied()
{
}

void remoteSandboxReg_CameraCaptureProcessDied()
{
}

uint64_t remoteSandboxReg_DeadConnectionCallback(uint64_t result)
{
  *(unsigned char *)(result + 48) = 1;
  return result;
}

uint64_t FigHALAudioStreamGetClassID()
{
  if (FigHALAudioStreamGetClassID_sRegisterFigHALAudioStreamClassOnce != -1) {
    dispatch_once(&FigHALAudioStreamGetClassID_sRegisterFigHALAudioStreamClassOnce, &__block_literal_global_14);
  }
  return FigHALAudioStreamGetClassID_sFigHALAudioStreamClassID;
}

uint64_t __FigHALAudioStreamGetClassID_block_invoke()
{
  ClassID = (void *)FigHALAudioDeviceGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&FigHALAudioStreamGetClassID_sFigHALAudioStreamClassDesc, ClassID, 0, &FigHALAudioStreamGetClassID_sFigHALAudioStreamClassID);
}

uint64_t FigCaptionDataCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, void *a3)
{
  CFTypeRef v53 = 0;
  CFTypeRef value = 0;
  CFArrayRef theArray = 0;
  CFStringRef attrName = 0;
  uint64_t valuePtr = 0;
  CFTypeRef cf = 0;
  if (!a3)
  {
    uint64_t v36 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    CFMutableArrayRef Mutable = 0;
    goto LABEL_56;
  }
  if (!a2)
  {
    uint64_t v36 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    CFNumberRef v27 = 0;
LABEL_75:
    CFMutableArrayRef Mutable = 0;
    goto LABEL_52;
  }
  CFTypeRef v4 = a3;
  CFMutableArrayRef Mutable = CFAttributedStringCreateMutable(a1, 0);
  if (!Mutable)
  {
    uint64_t v36 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    CFNumberRef v27 = 0;
    goto LABEL_52;
  }
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable(a2) + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t))(v7 + 8);
  if (v8) {
    CFStringRef v9 = (const __CFString *)v8(a2);
  }
  else {
    CFStringRef v9 = &stru_1EDF73CD0;
  }
  v54.CFIndex location = 0;
  v54.CFIndex length = 0;
  CFStringRef theString = v9;
  CFAttributedStringReplaceString(Mutable, v54, v9);
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  long long v11 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  FigThreadRunOnce(&fmcd_getCaptionPropertyKeys_sCaptionPropertyKeysOnce, (void (*)(void))fmcd_initializeCaptionPropertyKeys);
  CFArrayRef v12 = (const __CFArray *)sCaptionPropertyKeys;
  if (CFArrayGetCount((CFArrayRef)sCaptionPropertyKeys))
  {
    CFIndex v13 = 0;
    do
    {
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v12, v13);
      uint64_t CMBaseObject = FigCaptionDataGetCMBaseObject(a2);
      uint64_t v16 = *(void *)(CMBaseObjectGetVTable(CMBaseObject) + 8);
      uint64_t v17 = v16 ? v16 : 0;
      CFDataRef v18 = *(uint64_t (**)(uint64_t, const void *, const __CFAllocator *, CFTypeRef *))(v17 + 48);
      if (!v18) {
        goto LABEL_48;
      }
      uint64_t v19 = v18(CMBaseObject, ValueAtIndex, v10, &cf);
      if (v19) {
        goto LABEL_78;
      }
      if (cf)
      {
        char v20 = CFArrayGetValueAtIndex(v12, v13);
        CFDictionaryAddValue(v11, v20, cf);
      }
    }
    while (++v13 < (unint64_t)CFArrayGetCount(v12));
  }
  uint64_t v21 = FigCaptionDataGetCMBaseObject(a2);
  uint64_t v22 = *(void *)(CMBaseObjectGetVTable(v21) + 8);
  if (v22) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 0;
  }
  int v24 = *(uint64_t (**)(uint64_t, __CFString *, const __CFAllocator *, CFArrayRef *))(v23 + 48);
  if (!v24)
  {
LABEL_48:
    CFNumberRef v27 = 0;
LABEL_49:
    uint64_t v36 = 4294954514;
    goto LABEL_50;
  }
  uint64_t v19 = v24(v21, @"StylePropertyKeysInUse", v10, &theArray);
  if (v19)
  {
LABEL_78:
    uint64_t v36 = v19;
    CFNumberRef v27 = 0;
LABEL_50:
    if (v11) {
      CFRelease(v11);
    }
    goto LABEL_52;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count)
  {
    CFStringRef v25 = 0;
    CFIndex v26 = 0;
    CFNumberRef v27 = 0;
    BOOL v42 = v4;
    while (1)
    {
      CFIndex v44 = v26;
      CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v26);
      CFIndex Length = CFStringGetLength(theString);
      if (Length) {
        break;
      }
LABEL_46:
      CFIndex v26 = v44 + 1;
      CFTypeRef v4 = v42;
      if (v44 + 1 == Count) {
        goto LABEL_68;
      }
    }
    CFIndex v30 = Length;
    uint64_t v31 = 0;
    while (1)
    {
      v47.CFIndex location = 0;
      v47.CFIndex length = 0;
      if (value)
      {
        CFRelease(value);
        CFTypeRef value = 0;
      }
      uint64_t v32 = *(void *)(CMBaseObjectGetVTable(a2) + 16);
      uint64_t v33 = v32 ? v32 : 0;
      unsigned int v34 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *, CFRange *))(v33 + 24);
      if (!v34) {
        goto LABEL_49;
      }
      uint64_t v35 = v34(a2, v31, v28, a1, &value, &v47);
      if (v35) {
        goto LABEL_72;
      }
      if (value)
      {
        CFAttributedStringSetAttribute(Mutable, v47, v28, value);
        if (v25)
        {
          CFRelease(v25);
          CFStringRef attrName = 0;
        }
        if (v27) {
          CFRelease(v27);
        }
        fmcd_createStylePropertyRunIDKey((uint64_t)v28, &attrName);
        CFNumberRef v27 = CFNumberCreate(v10, kCFNumberCFIndexType, &valuePtr);
        if (!v27)
        {
          uint64_t v35 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          goto LABEL_72;
        }
        CFStringRef v25 = attrName;
        CFAttributedStringSetAttribute(Mutable, v47, attrName, v27);
        ++valuePtr;
      }
      v31 += v47.length;
      if (v31 == v30) {
        goto LABEL_46;
      }
    }
  }
  CFNumberRef v27 = 0;
LABEL_68:
  ClassID = (void *)FigCaptionDataGetClassID();
  uint64_t v35 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionDataVTable, ClassID, &v53);
  if (v35)
  {
LABEL_72:
    uint64_t v36 = v35;
    goto LABEL_50;
  }
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)v53);
  uint64_t v40 = valuePtr;
  DerivedStorage[1] = v11;
  DerivedStorage[2] = v40;
  *uint64_t DerivedStorage = Mutable;
  unsigned int v41 = FigSimpleMutexCreate();
  DerivedStorage[3] = v41;
  if (!v41)
  {
    uint64_t v36 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_75;
  }
  uint64_t v36 = 0;
  CFMutableArrayRef Mutable = 0;
  void *v4 = v53;
  CFTypeRef v53 = 0;
LABEL_52:
  if (cf) {
    CFRelease(cf);
  }
  if (v27) {
    CFRelease(v27);
  }
LABEL_56:
  if (attrName) {
    CFRelease(attrName);
  }
  if (value) {
    CFRelease(value);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v53) {
    CFRelease(v53);
  }
  return v36;
}

CFStringRef fmcd_createStylePropertyRunIDKey(uint64_t a1, CFStringRef *a2)
{
  CFStringRef result = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@%@", a1, @"_InternalUseOnly_StyleRunID");
  if (result)
  {
    *a2 = result;
  }
  else
  {
    return (CFStringRef)FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCaptionDataCreateMutable(const __CFAllocator *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    ClassID = (void *)FigCaptionDataGetClassID();
    uint64_t v5 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionDataVTable, ClassID, &cf);
    if (!v5)
    {
      if (cf) {
        uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      }
      else {
        uint64_t DerivedStorage = 0;
      }
      CFMutableAttributedStringRef Mutable = CFAttributedStringCreateMutable(a1, 0);
      *uint64_t DerivedStorage = Mutable;
      if (Mutable)
      {
        CFMutableDictionaryRef v8 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        DerivedStorage[1] = v8;
        if (v8)
        {
          CFStringRef v9 = FigSimpleMutexCreate();
          DerivedStorage[3] = v9;
          if (v9)
          {
            uint64_t v10 = 0;
            *a2 = cf;
            return v10;
          }
        }
      }
      uint64_t v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v10 = v5;
    if (cf) {
      CFRelease(cf);
    }
    return v10;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

CFArrayRef fmcd_initializeCaptionPropertyKeys()
{
  v1[13] = *(const void **)MEMORY[0x1E4F143B8];
  v1[0] = @"Region";
  v1[1] = @"Animation";
  long long v1[2] = @"TextAlign";
  v1[3] = @"MultiRowAlign";
  v1[4] = @"SourceInformation";
  v1[5] = @"LinePadding";
  v1[6] = @"LineHeight";
  v1[7] = @"BackgroundColor";
  v1[8] = @"FillLineGap";
  v1[9] = @"Hidden";
  v1[10] = @"RubyAlign";
  v1[11] = @"RubyPosition";
  v1[12] = @"RubyReserve";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, 13, MEMORY[0x1E4F1D510]);
  sCaptionPropertyKeys = (uint64_t)result;
  return result;
}

BOOL fmcd_Equal(char *a1, char *a2)
{
  if (a1 && (ClassID = (void *)FigCaptionDataGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID))
    || a2 && (uint64_t v5 = (void *)FigCaptionDataGetClassID(), !CMBaseObjectIsMemberOfClass(a2, v5)))
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else if (a1 == a2)
  {
    return 1;
  }
  else
  {
    BOOL result = 0;
    if (a1 && a2)
    {
      uint64_t v7 = *(void *)(CMBaseObjectGetVTable((uint64_t)a1) + 16);
      if (v7) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = 0;
      }
      CFStringRef v9 = *(uint64_t (**)(char *))(v8 + 8);
      if (v9) {
        uint64_t v10 = (__CFString *)v9(a1);
      }
      else {
        uint64_t v10 = &stru_1EDF73CD0;
      }
      uint64_t v11 = *(void *)(CMBaseObjectGetVTable((uint64_t)a2) + 16);
      if (v11) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = 0;
      }
      CFIndex v13 = *(uint64_t (**)(char *))(v12 + 8);
      if (v13) {
        uint64_t v14 = (__CFString *)v13(a2);
      }
      else {
        uint64_t v14 = &stru_1EDF73CD0;
      }
      return FigCFEqual(v10, v14) != 0;
    }
  }
  return result;
}

CFAllocatorRef fmcd_Finalize(uint64_t a1)
{
  if (a1) {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  }
  else {
    uint64_t DerivedStorage = 0;
  }
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  CFAllocatorRef v2 = *(const void **)(DerivedStorage + 8);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(void *)(DerivedStorage + 24);

  return FigSimpleMutexDestroy(v3);
}

__CFString *fmcd_CopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableAttributedStringRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringRef CaptionText = fmcd_GetCaptionText((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, @"\tCaptionData: %p text<%@>", a1, CaptionText);
  return Mutable;
}

uint64_t fmcd_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, void *a4)
{
  if (a1)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    if (!a2) {
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t DerivedStorage = 0;
    if (!a2)
    {
LABEL_45:
      uint64_t v31 = 4294954516;
      goto LABEL_42;
    }
  }
  if (!a4) {
    goto LABEL_45;
  }
  if (CFEqual(a2, @"Text"))
  {
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v12 = *(uint64_t (**)(uint64_t))(v10 + 8);
    if (v12)
    {
      CFIndex v13 = (__CFString *)v12(a1);
      if (!v13)
      {
        uint64_t v14 = 0;
        goto LABEL_39;
      }
    }
    else
    {
      CFIndex v13 = &stru_1EDF73CD0;
    }
    uint64_t v14 = (void *)CFRetain(v13);
    goto LABEL_39;
  }
  if (CFEqual(a2, @"StylePropertyKeysInUse"))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 24));
    if (a1) {
      uint64_t v11 = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1);
    }
    else {
      uint64_t v11 = 0;
    }
    CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
    if (Mutable)
    {
      CFMutableSetRef v22 = Mutable;
      CFIndex Length = CFAttributedStringGetLength(*v11);
      if (Length)
      {
        CFIndex v24 = Length;
        CFIndex v25 = 0;
        do
        {
          v32.CFIndex location = 0;
          v32.CFIndex length = 0;
          CFDictionaryRef Attributes = CFAttributedStringGetAttributes(*v11, v25, &v32);
          CFDictionaryApplyFunction(Attributes, (CFDictionaryApplierFunction)fmcd_collectKeys, v22);
          CFIndex v25 = v32.length + v32.location;
        }
        while (v32.length + v32.location != v24);
      }
      CFIndex Count = CFSetGetCount(v22);
      uint64_t v14 = CFArrayCreateMutable(a3, Count, MEMORY[0x1E4F1D510]);
      if (v14)
      {
        CFSetApplyFunction(v22, (CFSetApplierFunction)fmcd_addKeyToArray, v14);
        uint64_t v28 = 0;
      }
      else
      {
        uint64_t v28 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      }
      CFRelease(v22);
    }
    else
    {
      uint64_t v28 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      uint64_t v14 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 24));
    if (v28)
    {
      if (v14) {
        CFRelease(v14);
      }
      return v28;
    }
LABEL_39:
    uint64_t v28 = 0;
    *a4 = v14;
    return v28;
  }
  int v15 = CFEqual(a2, @"CaptionPropertyKeysInUse");
  CFDictionaryRef v16 = *(const __CFDictionary **)(DerivedStorage + 8);
  if (!v15)
  {
    CFArrayRef Value = (void *)CFDictionaryGetValue(v16, a2);
    uint64_t v14 = Value;
    if (Value) {
      CFRetain(Value);
    }
    goto LABEL_39;
  }
  unint64_t v17 = CFDictionaryGetCount(v16);
  CFIndex v18 = v17;
  if (v17)
  {
    if (v17 >> 61) {
      goto LABEL_41;
    }
    size_t v19 = 8 * v17;
    if (!(8 * v18)) {
      goto LABEL_41;
    }
    char v20 = (const void **)malloc_type_malloc(v19, 0xD1AAB5CuLL);
    if (!v20) {
      goto LABEL_41;
    }
  }
  else
  {
    char v20 = 0;
  }
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(DerivedStorage + 8), v20, 0);
  uint64_t v14 = CFArrayCreate(a3, v20, v18, MEMORY[0x1E4F1D510]);
  free(v20);
  if (v14) {
    goto LABEL_39;
  }
LABEL_41:
  uint64_t v31 = 4294954510;
LABEL_42:

  return FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
}

uint64_t fmcd_SetProperty(uint64_t a1, const void *a2, void *a3)
{
  if (!a1) {
    goto LABEL_68;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!DerivedStorage || !a2) {
    goto LABEL_68;
  }
  uint64_t v7 = DerivedStorage;
  if (CFEqual(a2, @"Text"))
  {
    if (a3)
    {
      CFTypeID v8 = CFGetTypeID(a3);
      if (v8 == CFStringGetTypeID())
      {
        uint64_t v9 = *(void *)(CMBaseObjectGetVTable(a1) + 16);
        if (v9) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v14 = *(uint64_t (**)(uint64_t, void *))(v10 + 16);
        if (!v14) {
          return 4294954514;
        }
        return v14(a1, a3);
      }
    }
    goto LABEL_68;
  }
  if (CFEqual(a2, @"Region"))
  {
    if (!a3) {
      goto LABEL_68;
    }
    CFTypeID v11 = CFGetTypeID(a3);
    CFTypeID TypeID = FigCaptionRegionGetTypeID();
    goto LABEL_12;
  }
  if (CFEqual(a2, @"Animation"))
  {
    if (!a3) {
      goto LABEL_13;
    }
    CFTypeID v15 = CFGetTypeID(a3);
    if (v15 == CFStringGetTypeID()
      && (CFEqual(a3, @"Animation_CharacterReveal") || CFEqual(a3, @"Animation_None")))
    {
      goto LABEL_13;
    }
    goto LABEL_68;
  }
  if (CFEqual(a2, @"TextAlign")) {
    goto LABEL_28;
  }
  if (CFEqual(a2, @"LinePadding"))
  {
    double v31 = 0.0;
    if (!a3) {
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    CFTypeID v18 = CFGetTypeID(a3);
    if (v18 != FigCaptionDynamicStyleGetTypeID()) {
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    if (!FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    InitialCFArrayRef Value = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    CFTypeID v20 = CFGetTypeID(InitialValue);
    if (v20 != CFDictionaryGetTypeID()) {
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v21 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    uint64_t result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(v21, &v31);
    if (result) {
      return result;
    }
    if (v31 < 0.0) {
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
LABEL_13:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v7 + 8), a2, a3);
    return 0;
  }
  if (!CFEqual(a2, @"LineHeight"))
  {
    if (!CFEqual(a2, @"MultiRowAlign"))
    {
      if (CFEqual(a2, @"SourceInformation"))
      {
        if (!a3) {
          goto LABEL_68;
        }
        uint64_t v23 = (CFDictionaryRef *)a3;
        goto LABEL_45;
      }
      if (CFEqual(a2, @"BackgroundColor"))
      {
        if (!a3) {
          goto LABEL_68;
        }
        CFTypeID v24 = CFGetTypeID(a3);
        if (v24 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
          goto LABEL_68;
        }
        CFIndex v25 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        CFTypeID v11 = CFGetTypeID(v25);
        CFTypeID TypeID = CGColorGetTypeID();
        goto LABEL_12;
      }
      if (CFEqual(a2, @"FillLineGap") || CFEqual(a2, @"Hidden"))
      {
        if (!a3) {
          goto LABEL_68;
        }
        CFTypeID v26 = CFGetTypeID(a3);
        if (v26 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
          goto LABEL_68;
        }
        CFNumberRef v27 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        CFTypeID v11 = CFGetTypeID(v27);
        CFTypeID TypeID = CFBooleanGetTypeID();
        goto LABEL_12;
      }
      if (!CFEqual(a2, @"RubyAlign") && !CFEqual(a2, @"RubyPosition"))
      {
        if (!CFEqual(a2, @"RubyReserve"))
        {
          uint64_t v30 = 4294954512;
          goto LABEL_69;
        }
        if (!a3) {
          goto LABEL_68;
        }
        CFTypeID v28 = CFGetTypeID(a3);
        if (v28 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
          goto LABEL_68;
        }
        uint64_t v29 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        CFTypeID v11 = CFGetTypeID(v29);
        CFTypeID TypeID = FigCaptionRubyReserveGetTypeID();
        goto LABEL_12;
      }
    }
LABEL_28:
    if (!a3) {
      goto LABEL_68;
    }
    CFTypeID v16 = CFGetTypeID(a3);
    if (v16 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
      goto LABEL_68;
    }
    unint64_t v17 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    CFTypeID v11 = CFGetTypeID(v17);
    CFTypeID TypeID = CFStringGetTypeID();
    goto LABEL_12;
  }
  if (!a3) {
    goto LABEL_68;
  }
  CFTypeID v22 = CFGetTypeID(a3);
  if (v22 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
    goto LABEL_68;
  }
  uint64_t v23 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
LABEL_45:
  CFTypeID v11 = CFGetTypeID(v23);
  CFTypeID TypeID = CFDictionaryGetTypeID();
LABEL_12:
  if (v11 == TypeID) {
    goto LABEL_13;
  }
LABEL_68:
  uint64_t v30 = 4294954516;
LABEL_69:

  return FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
}

CFStringRef fmcd_GetCaptionText(uint64_t a1)
{
  if (a1 && (uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1)) != 0)
  {
    uint64_t v2 = DerivedStorage;
    if (*(void *)DerivedStorage)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 24));
      CFStringRef String = CFAttributedStringGetString(*(CFAttributedStringRef *)v2);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 24));
      return String;
    }
    uint64_t v5 = 4294954512;
  }
  else
  {
    uint64_t v5 = 4294954516;
  }
  FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  return 0;
}

void fmcd_collectKeys(const __CFString *a1, uint64_t a2, __CFSet *a3)
{
  if (!CFStringHasSuffix(a1, @"_InternalUseOnly_StyleRunID"))
  {
    CFSetAddValue(a3, a1);
  }
}

void fmcd_addKeyToArray(void *value, CFMutableArrayRef theArray)
{
}

uint64_t fmcd_SetCaptionText(const void *a1, const __CFString *a2)
{
  if (a1 && (uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1), a2))
  {
    uint64_t v5 = (const void **)DerivedStorage;
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFMutableSetRef Mutable = CFAttributedStringCreateMutable(v6, 0);
    if (Mutable)
    {
      CFTypeID v8 = Mutable;
      v13.CFIndex location = 0;
      v13.CFIndex length = 0;
      CFAttributedStringReplaceString(Mutable, v13, a2);
      uint64_t v9 = *v5;
      void *v5 = v8;
      CFRetain(v8);
      if (v9) {
        CFRelease(v9);
      }
      CFRelease(v8);
      return 0;
    }
    uint64_t v11 = 4294954510;
  }
  else
  {
    uint64_t v11 = 4294954516;
  }

  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t fmcd_CopyStylePropertyAtIndex(uint64_t a1, CFIndex a2, const __CFString *a3, uint64_t a4, void *a5, CFRange *a6)
{
  if (!a1) {
    goto LABEL_16;
  }
  uint64_t DerivedStorage = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1);
  longestEffectiveRange.CFIndex length = 0;
  CFStringRef v19 = 0;
  v17.CFIndex length = 0;
  longestEffectiveRange.CFIndex location = 0;
  v17.CFIndex location = 0;
  if (!DerivedStorage) {
    goto LABEL_16;
  }
  if ((a2 & 0x8000000000000000) == 0
    && (uint64_t v11 = DerivedStorage, String = CFAttributedStringGetString(*DerivedStorage), CFStringGetLength(String) > a2))
  {
    fmcd_createStylePropertyRunIDKey((uint64_t)a3, &v19);
    FigSimpleMutexLock((pthread_mutex_t *)v11[3]);
    CFAttributedStringRef v13 = *v11;
    CFStringRef v14 = v19;
    v21.CFIndex length = CFAttributedStringGetLength(*v11);
    v21.CFIndex location = 0;
    CFAttributedStringGetAttributeAndLongestEffectiveRange(v13, a2, v14, v21, &longestEffectiveRange);
    CFTypeRef AttributeAndLongestEffectiveRange = CFAttributedStringGetAttributeAndLongestEffectiveRange(*v11, a2, a3, longestEffectiveRange, &v17);
    FigSimpleMutexUnlock((pthread_mutex_t *)v11[3]);
    if (AttributeAndLongestEffectiveRange) {
      CFRetain(AttributeAndLongestEffectiveRange);
    }
    if (a5)
    {
      *a5 = AttributeAndLongestEffectiveRange;
      CFTypeRef AttributeAndLongestEffectiveRange = 0;
    }
    if (a6) {
      *a6 = v17;
    }
    if (AttributeAndLongestEffectiveRange) {
      CFRelease(AttributeAndLongestEffectiveRange);
    }
    if (v14) {
      CFRelease(v14);
    }
    return 0;
  }
  else
  {
LABEL_16:
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t fmcd_SetStylePropertyInRange(uint64_t a1, const __CFString *a2, const void *a3, CFIndex a4, CFIndex a5)
{
  if (a1)
  {
    uint64_t DerivedStorage = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1);
    CFStringRef attrName = 0;
    if (DerivedStorage)
    {
      if (a2)
      {
        if (a3)
        {
          if ((a4 & 0x8000000000000000) == 0)
          {
            uint64_t v10 = DerivedStorage;
            CFStringRef String = CFAttributedStringGetString(*DerivedStorage);
            if (a4 < CFStringGetLength(String) && ((a4 + a5) & 0x8000000000000000) == 0)
            {
              CFStringRef v12 = CFAttributedStringGetString(*v10);
              if (a4 + a5 <= CFStringGetLength(v12))
              {
                v20.CFIndex location = a4;
                v20.CFIndex length = a5;
                CFAttributedStringSetAttribute(*v10, v20, a2, a3);
                fmcd_createStylePropertyRunIDKey((uint64_t)a2, &attrName);
                CFNumberRef v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, v10 + 2);
                if (v13)
                {
                  CFNumberRef v14 = v13;
                  CFStringRef v15 = attrName;
                  v21.CFIndex location = a4;
                  v21.CFIndex length = a5;
                  CFAttributedStringSetAttribute(*v10, v21, attrName, v13);
                  CFArrayRef v10[2] = (CFAttributedStringRef)((char *)v10[2] + 1);
                  CFRelease(v14);
                  uint64_t v16 = 0;
                  if (!v15) {
                    return v16;
                  }
                }
                else
                {
                  uint64_t v16 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                  CFStringRef v15 = attrName;
                  if (!attrName) {
                    return v16;
                  }
                }
                CFRelease(v15);
                return v16;
              }
            }
          }
        }
      }
    }
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t fmcd_RemoveStylePropertyInRange(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4)
{
  if (!a1
    || (uint64_t DerivedStorage = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1), attrName = 0, !DerivedStorage)
    || a3 < 0
    || (CFTypeID v8 = DerivedStorage, String = CFAttributedStringGetString(*DerivedStorage), a3 >= CFStringGetLength(String))
    || a3 + a4 < 0
    || (CFStringRef v10 = CFAttributedStringGetString(*v8), a3 + a4 > CFStringGetLength(v10)))
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v15.CFIndex location = a3;
    v15.CFIndex length = a4;
    CFAttributedStringRemoveAttribute(*v8, v15, a2);
    fmcd_createStylePropertyRunIDKey((uint64_t)a2, &attrName);
    CFStringRef v11 = attrName;
    v16.CFIndex location = a3;
    v16.CFIndex length = a4;
    CFAttributedStringRemoveAttribute(*v8, v16, attrName);
    if (v11) {
      CFRelease(v11);
    }
    return 0;
  }
}

uint64_t FigVirtualCaptureCardRemoteCreate(uint64_t a1, CFTypeRef *a2)
{
  xpc_object_t v11 = 0;
  CFTypeRef cf = 0;
  xpc_object_t xdict = 0;
  uint64_t v4 = remoteVirtualCaptureCardClient_EnsureClientEstablished();
  if (v4
    || (ClassID = (void *)FigVirtualCaptureCardGetClassID(),
        uint64_t v4 = CMDerivedObjectCreate(a1, (uint64_t)&kRemoteFigVirtualCaptureCard_VTable, ClassID, &cf),
        v4)
    || (uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf),
        uint64_t v4 = FigXPCCreateBasicMessage(0x63726538u, 0, &v11),
        v4)
    || (uint64_t v4 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigVirtualCaptureCardRemoteClient, (uint64_t)v11, &xdict),
        v4))
  {
    uint64_t v8 = v4;
  }
  else
  {
    uint64_t uint64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
    *uint64_t DerivedStorage = uint64;
    uint64_t v8 = FigXPCRemoteClientAssociateObject(gFigVirtualCaptureCardRemoteClient, (uint64_t)cf, uint64);
    if (!v8)
    {
      *a2 = cf;
      CFTypeRef cf = 0;
      goto LABEL_7;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_7:
  FigXPCRelease(v11);
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, v8, "FigVirtualCaptureCardRemoteCreate", 0);
  return v8;
}

BOOL FigVirtualCaptureCardRemoteSupported()
{
  return remoteVirtualCaptureCardClient_EnsureClientEstablished() == 0;
}

uint64_t remoteVirtualCaptureCardClient_EnsureClientEstablished()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __remoteVirtualCaptureCardClient_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E5678478;
  void block[4] = &v3;
  if (remoteVirtualCaptureCardClient_EnsureClientEstablished_gFigVirtualCaptureCardRemoteClientSetupOnce != -1) {
    dispatch_once(&remoteVirtualCaptureCardClient_EnsureClientEstablished_gFigVirtualCaptureCardRemoteClientSetupOnce, block);
  }
  if (gFigVirtualCaptureCardRemoteClient)
  {
    uint64_t v0 = *((unsigned int *)v4 + 6);
  }
  else
  {
    uint64_t v0 = FigSignalErrorAt(4294950083, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v4 + 6) = v0;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t remoteVirtualCaptureCardClient_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result = CMBaseObjectGetDerivedStorage(a1);
  *(unsigned char *)(result + 9) = 1;
  return result;
}

uint64_t remoteFigVirtualCaptureCard_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  int v6 = 0;
  FigXPCRemoteClientDisassociateObject(gFigVirtualCaptureCardRemoteClient, *(const void **)DerivedStorage);
  if (*(unsigned char *)(DerivedStorage + 9))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v4 = FigXPCCreateBasicMessage(0x64697370u, *(void *)DerivedStorage, &v6);
    uint64_t v2 = v6;
    if (v4)
    {
      uint64_t v3 = v4;
    }
    else
    {
      uint64_t v3 = FigXPCRemoteClientSendAsyncMessage(gFigVirtualCaptureCardRemoteClient, v6);
      uint64_t v2 = v6;
    }
  }
  FigXPCRelease(v2);
  return FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, v3, "remoteFigVirtualCaptureCard_Finalize", 0);
}

__CFString *remoteFigVirtualCaptureCard_CopyDebugDescription(const void *a1)
{
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableSetRef Mutable = CFStringCreateMutable(v3, 0);
  CFIndex v5 = CFGetRetainCount(a1);
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, @"<FigVirtualCaptureCardRemote %p retainCount: %ld allocator: %p objectID %016llx", a1, v5, v6, *DerivedStorage);
  return Mutable;
}

uint64_t remoteFigVirtualCaptureCard_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v9 = 0;
  if (a2 && a4)
  {
    *a4 = 0;
    uint64_t ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v9);
    if (!ObjectID) {
      uint64_t ObjectID = FigXPCSendStdCopyPropertyMessage(gFigVirtualCaptureCardRemoteClient, v9, a2, a4);
    }
  }
  else
  {
    uint64_t ObjectID = FigSignalErrorAt(4294950086, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v7 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_CopyProperty", 0);
  return v7;
}

uint64_t remoteFigVirtualCaptureCard_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v8 = 0;
  if (a2)
  {
    uint64_t ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v8);
    if (!ObjectID) {
      uint64_t ObjectID = FigXPCSendStdSetPropertyMessage(gFigVirtualCaptureCardRemoteClient, v8, a2, a3);
    }
  }
  else
  {
    uint64_t ObjectID = FigSignalErrorAt(4294950086, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v6 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_SetProperty", 0);
  return v6;
}

uint64_t remoteVirtualCaptureCardClient_GetObjectID(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a1 || *(unsigned char *)(DerivedStorage + 9) || *(unsigned char *)(DerivedStorage + 8))
  {
    return FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *a2 = *(void *)DerivedStorage;
    return 0;
  }
}

uint64_t remoteFigVirtualCaptureCard_showSystemUserInterface(uint64_t a1)
{
  xpc_object_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v5);
  if (!ObjectID)
  {
    uint64_t ObjectID = FigXPCCreateBasicMessage(0x73686F77u, v5, &v4);
    if (!ObjectID) {
      uint64_t ObjectID = FigXPCRemoteClientSendSyncMessage(gFigVirtualCaptureCardRemoteClient, (uint64_t)v4);
    }
  }
  uint64_t v2 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_showSystemUserInterface", 0);
  FigXPCRelease(v4);
  return v2;
}

uint64_t remoteFigVirtualCaptureCard_reserveForCaptureToFile(uint64_t a1, const __CFURL *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  xpc_object_t xdict = 0;
  uint64_t v7 = 0;
  uint64_t ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v7);
  if (!ObjectID)
  {
    uint64_t ObjectID = FigXPCCreateBasicMessage(0x72657376u, v7, &xdict);
    if (!ObjectID)
    {
      if (CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024))
      {
        xpc_dictionary_set_string(xdict, "FileURL", (const char *)buffer);
        uint64_t ObjectID = FigXPCRemoteClientSendSyncMessage(gFigVirtualCaptureCardRemoteClient, (uint64_t)xdict);
      }
      else
      {
        uint64_t ObjectID = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  uint64_t v4 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_reserveForCaptureToFile", 0);
  FigXPCRelease(xdict);
  return v4;
}

uint64_t remoteFigVirtualCaptureCard_saveCapture(uint64_t a1)
{
  xpc_object_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v5);
  if (!ObjectID)
  {
    uint64_t ObjectID = FigXPCCreateBasicMessage(0x73617665u, v5, &v4);
    if (!ObjectID) {
      uint64_t ObjectID = FigXPCRemoteClientSendSyncMessage(gFigVirtualCaptureCardRemoteClient, (uint64_t)v4);
    }
  }
  uint64_t v2 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_saveCapture", 0);
  FigXPCRelease(v4);
  return v2;
}

uint64_t FigAV1BridgeParsingStateGetTypeID()
{
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  return FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID;
}

uint64_t RegisterFigAV1BridgeParsingStateType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigAV1Bridge_LocateSubsampleRangeForCBCS(OpaqueCMBlockBuffer *a1, uint64_t a2, size_t a3, uint64_t a4, void *a5, uint64_t a6, void *a7, void *a8)
{
  return locateSubsampleRangeForCBCS(a1, a2, a3, a4, 0, a5, a6, a7, a8);
}

uint64_t locateSubsampleRangeForCBCS(CMBlockBufferRef theBuffer, uint64_t a2, size_t a3, uint64_t a4, int a5, void *a6, uint64_t a7, void *a8, void *a9)
{
  size_t totalLengthOut = 0;
  dataPointerOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)uint64_t v35 = 0u;
  long long v36 = 0u;
  int v34 = 0;
  if (!a4 || !theBuffer) {
    goto LABEL_19;
  }
  if (a6) {
    *a6 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a9) {
    *a9 = 0;
  }
  size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!DataLength) {
    goto LABEL_19;
  }
  size_t v17 = DataLength;
  if (CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
  {
    CFTypeID v18 = (OpaqueCMBlockBuffer *)CFRetain(theBuffer);
    CMBlockBufferRef blockBufferOut = v18;
  }
  else
  {
    uint64_t DataPointer = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v17, 0, &blockBufferOut);
    if (DataPointer)
    {
LABEL_20:
      uint64_t v20 = DataPointer;
      goto LABEL_41;
    }
    CFTypeID v18 = blockBufferOut;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(v18, 0, 0, &totalLengthOut, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_20;
  }
  if (a3)
  {
    if (a3 + a2 <= totalLengthOut)
    {
      size_t totalLengthOut = a3;
      dataPointerOut += a2;
      goto LABEL_21;
    }
    goto LABEL_19;
  }
  if (a2)
  {
LABEL_19:
    uint64_t DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
LABEL_21:
  v35[0] = malloc_type_malloc(0x48uLL, 0x1070040C633F987uLL);
  if (!v35[0])
  {
LABEL_40:
    uint64_t v20 = 4294954584;
    goto LABEL_41;
  }
  size_t v21 = totalLengthOut;
  if (totalLengthOut)
  {
    int v22 = 0;
    uint64_t v23 = a4 + 3184;
    uint64_t v24 = a4 + 16;
    uint64_t v25 = a4 + 1504;
    CFTypeID v26 = dataPointerOut;
    while (1)
    {
      unsigned int v33 = 0;
      uint64_t v27 = FigAV1Bridge_parseOBU((uint64_t)v26, v21, v22, v23, v24, v25, (uint64_t)v35, -1, a5, &v33, &v34);
      if (v27)
      {
        uint64_t v20 = v27;
        goto LABEL_33;
      }
      size_t v28 = totalLengthOut;
      if (totalLengthOut < v33) {
        goto LABEL_29;
      }
      if (!v33) {
        break;
      }
      if ((v34 & 8) == 0)
      {
        CFTypeID v26 = &dataPointerOut[v33];
        v22 += v33;
        size_t v21 = totalLengthOut - v33;
        size_t totalLengthOut = v21;
        dataPointerOut = v26;
        if (v28 != v33) {
          continue;
        }
      }
LABEL_29:
      uint64_t v20 = 0;
      goto LABEL_33;
    }
    uint64_t v20 = 4294954582;
LABEL_33:
    if (v20) {
      goto LABEL_41;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v29 = v36;
  if ((v36 - 1) <= 0x7FFFFFFD)
  {
    if (a6) {
      *a6 = v36;
    }
    uint64_t v20 = 0;
    if (a8)
    {
      if (a9)
      {
        if (v29 < a7) {
          goto LABEL_40;
        }
        uint64_t v20 = 0;
        double v31 = &v35[a7];
        *a8 = v31[3];
        *a9 = v31[67];
      }
    }
  }
LABEL_41:
  free(v35[0]);
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v20;
}

uint64_t FigAV1Bridge_AdvanceParsingStateForFrame(OpaqueCMBlockBuffer *a1, uint64_t a2, size_t a3, uint64_t a4)
{
  return locateSubsampleRangeForCBCS(a1, a2, a3, a4, 1, 0, 0, 0, 0);
}

uint64_t FigAV1Bridge_GetProfileTierLevelFromAV1CodecConfigurationRecord(char *a1, unint64_t a2, unsigned char *a3, unsigned char *a4, unsigned char *a5)
{
  int v18 = 0;
  memset(v17, 0, sizeof(v17));
  if (!a1 || a2 <= 3)
  {
    uint64_t v6 = 4294954584;
LABEL_4:
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v6 = 4294954583;
    goto LABEL_4;
  }
  CFNumberRef v13 = (const void *)Instance;
  int v16 = 0;
  uint64_t v14 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v16, &v18, (unsigned int *)v17);
  if (v14)
  {
    uint64_t v15 = v14;
  }
  else if ((v18 & 0x20) != 0)
  {
    if (a3) {
      *a3 = v17[0];
    }
    if (a4) {
      *a4 = BYTE4(v17[0]);
    }
    uint64_t v15 = 0;
    if (a5) {
      *a5 = BYTE8(v17[0]);
    }
  }
  else
  {
    uint64_t v15 = 4294954584;
  }
  CFRelease(v13);
  return v15;
}

uint64_t FigAV1Bridge_parseav1c(char *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, _DWORD *a7, unsigned int *a8)
{
  if (a1 && a3 && a4 && a5 && a8)
  {
    if (a7) {
      *a7 = 0;
    }
    int v8 = *a1;
    if ((v8 & 0x80000000) == 0) {
      return 4294954582;
    }
    if ((v8 & 0x7F) == 1)
    {
      unsigned int v9 = a1[1];
      *a8 = v9 >> 5;
      if (v9 > 0x5F) {
        return 4294954582;
      }
      a8[1] = a1[1] & 0x1F;
      a8[2] = a1[2] >> 7;
      unsigned int v11 = a1[2];
      a8[4] = (v11 >> 4) & 1;
      a8[5] = (a1[2] >> 3) & 1;
      a8[6] = (a1[2] >> 2) & 1;
      a8[7] = a1[2] & 3;
      if ((v11 & 0x40) != 0) {
        int v12 = 10;
      }
      else {
        int v12 = 8;
      }
      if ((v11 & 0x20) != 0) {
        int v13 = 12;
      }
      else {
        int v13 = v12;
      }
      a8[3] = v13;
      if (a7) {
        *a7 |= 0x20u;
      }
      if (a2 < 5) {
        return 0;
      }
      else {
        return FigAV1Bridge_parseOBU((uint64_t)(a1 + 4), a2 - 4, 0, a3, a4, a5, 0, 2, 1, a6, a7);
      }
    }
    else
    {
      return 4294954579;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAV1Bridge_GetChromaFormatAndBitDepthsFromAV1CodecConfigurationRecord(char *a1, unint64_t a2, char *a3, unsigned char *a4, unsigned char *a5)
{
  int v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  if (!a1 || a2 <= 3)
  {
    uint64_t v6 = 4294954584;
LABEL_4:
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v6 = 4294954583;
    goto LABEL_4;
  }
  int v13 = (const void *)Instance;
  int v17 = 0;
  uint64_t v14 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v17, &v21, (unsigned int *)&v18);
  if (v14)
  {
    uint64_t v15 = v14;
  }
  else if ((v21 & 0x20) != 0)
  {
    if (a5) {
      *a5 = BYTE12(v18);
    }
    if (a4) {
      *a4 = BYTE12(v19);
    }
    if (a3)
    {
      if (v19)
      {
        char v16 = 111;
      }
      else if (DWORD2(v19))
      {
        char v16 = 110;
      }
      else if (DWORD1(v19))
      {
        char v16 = 100;
      }
      else
      {
        char v16 = 0;
      }
      uint64_t v15 = 0;
      *a3 = v16;
    }
    else
    {
      uint64_t v15 = 0;
    }
  }
  else
  {
    uint64_t v15 = 4294954584;
  }
  CFRelease(v13);
  return v15;
}

uint64_t FigAV1Bridge_GetColorRangeFromAV1CodecConfigurationRecord(char *a1, unint64_t a2, BOOL *a3)
{
  int v14 = 0;
  memset(v13, 0, sizeof(v13));
  if (!a1 || a2 <= 3)
  {
    uint64_t v4 = 4294954584;
LABEL_4:
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v4 = 4294954583;
    goto LABEL_4;
  }
  unsigned int v9 = (_DWORD *)Instance;
  int v12 = 0;
  uint64_t v10 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v12, &v14, (unsigned int *)v13);
  if (v10)
  {
    uint64_t v11 = v10;
  }
  else if ((v14 & 2) != 0)
  {
    uint64_t v11 = 0;
    if (a3) {
      *a3 = v9[13] > 0;
    }
  }
  else
  {
    uint64_t v11 = 4294954584;
  }
  CFRelease(v9);
  return v11;
}

uint64_t FigAV1Bridge_CreateParsingStateFromAV1FormatDescription(const opaqueCMFormatDescription *a1, void *a2)
{
  if (a1 && a2)
  {
    CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(a1, @"SampleDescriptionExtensionAtoms");
    if (Extension)
    {
      CFDictionaryRef v4 = Extension;
      CFTypeID v5 = CFGetTypeID(Extension);
      if (v5 == CFDictionaryGetTypeID())
      {
        CFArrayRef Value = CFDictionaryGetValue(v4, @"av1C");
        if (Value)
        {
          CFNumberRef ValueAtIndex = Value;
          CFTypeID v8 = CFGetTypeID(Value);
          if (v8 != CFArrayGetTypeID() || (CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0)) != 0)
          {
            CFTypeID v9 = CFGetTypeID(ValueAtIndex);
            if (v9 == CFDataGetTypeID())
            {
              return FigAV1Bridge_CreateParsingStateFromAV1CodecConfigurationRecord((const __CFData *)ValueAtIndex, a2);
            }
          }
        }
      }
    }
    uint64_t v11 = 4294954581;
  }
  else
  {
    uint64_t v11 = 4294954584;
  }

  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAV1Bridge_CreateParsingStateFromAV1CodecConfigurationRecord(const __CFData *a1, void *a2)
{
  int v13 = 0;
  if (!a1 || !a2 || (unint64_t Length = CFDataGetLength(a1), Length <= 3))
  {
    uint64_t v5 = 4294954584;
LABEL_5:
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  unint64_t v7 = Length;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v5 = 4294954583;
    goto LABEL_5;
  }
  CFTypeID v9 = (const void *)Instance;
  BytePtr = CFDataGetBytePtr(a1);
  int v12 = 0;
  if (FigAV1Bridge_parseOBU((uint64_t)BytePtr, v7, 0, (uint64_t)v9 + 3184, (uint64_t)v9 + 16, (uint64_t)v9 + 1504, 0, 2, 1, &v12, &v13))
  {
    uint64_t v11 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    CFRelease(v9);
  }
  else
  {
    uint64_t v11 = 0;
    *a2 = v9;
  }
  return v11;
}

uint64_t FigAV1Bridge_parseOBU(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __int16 a8, int a9, _DWORD *a10, _DWORD *a11)
{
  uint64_t v449 = *MEMORY[0x1E4F143B8];
  long long v441 = 0u;
  long long v442 = 0u;
  long long v440 = 0u;
  if (a2 <= 2 || !a1 || (uint64_t v12 = a4) == 0 || !a5 || !a6)
  {
    uint64_t v18 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    int v29 = 0;
    int uleb128 = 0;
    unsigned int v26 = 0;
    goto LABEL_829;
  }
  *((void *)&v441 + 1) = a1;
  *(void *)&long long v442 = a1;
  *((void *)&v442 + 1) = a1 + a2;
  long long v440 = 0uLL;
  LODWORD(v441) = 0;
  av1_get_bits((uint64_t)&v440, 1u);
  uint64_t v18 = v440;
  if (v440) {
    return v18;
  }
  int bits = av1_get_bits((uint64_t)&v440, 4u);
  uint64_t v18 = v440;
  if (v440) {
    return v18;
  }
  int v438 = bits;
  int v434 = a3;
  int v20 = av1_get_bits((uint64_t)&v440, 1u);
  uint64_t v18 = v440;
  if (v440) {
    return v18;
  }
  int v21 = v20;
  uint64_t v439 = a5;
  int v22 = av1_get_bits((uint64_t)&v440, 1u);
  uint64_t v18 = v440;
  if (v440) {
    return v18;
  }
  int v23 = v22;
  av1_get_bits((uint64_t)&v440, 1u);
  uint64_t v18 = v440;
  if (v440) {
    return v18;
  }
  if (v21)
  {
    int v24 = av1_get_bits((uint64_t)&v440, 3u);
    uint64_t v18 = v440;
    if (v440) {
      return v18;
    }
    int v25 = v24;
    int v435 = av1_get_bits((uint64_t)&v440, 2u);
    uint64_t v18 = v440;
    if (v440) {
      return v18;
    }
    av1_get_bits((uint64_t)&v440, 3u);
    uint64_t v18 = v440;
    if (v440) {
      return v18;
    }
    if (v23) {
      goto LABEL_16;
    }
LABEL_19:
    int uleb128 = ~v21 + a2;
    goto LABEL_20;
  }
  int v25 = 0;
  int v435 = 0;
  if (!v23) {
    goto LABEL_19;
  }
LABEL_16:
  int uleb128 = av1_get_uleb128(&v440);
  uint64_t v18 = v440;
  if (v440) {
    return v18;
  }
LABEL_20:
  unsigned int v26 = 8 * (DWORD2(v441) - v442) - v441;
  if ((v26 & 7) != 0) {
    return 4294954582;
  }
  unint64_t v27 = v26 >> 3;
  if (v27 > a2) {
    return 4294954582;
  }
  if ((v438 - 3) <= 0xFFFFFFFD)
  {
    if (v21)
    {
      int v28 = *(_DWORD *)(v12 + 6052);
      if (v28)
      {
        if ((((1 << (v435 + 8)) | (1 << v25)) & ~v28) != 0)
        {
          int v29 = 0;
          uint64_t v18 = 0;
          goto LABEL_829;
        }
      }
    }
  }
  int v29 = 0;
  uint64_t v18 = 0;
  switch(v438)
  {
    case 1:
      unsigned int v433 = 8 * (DWORD2(v441) - v442) - v441;
      int v30 = av1_get_bits((uint64_t)&v440, 3u);
      *(_DWORD *)uint64_t v439 = v30;
      if (v30 > 1) {
        goto LABEL_97;
      }
      int v31 = v30;
      int v32 = av1_get_bits((uint64_t)&v440, 1u);
      *(_DWORD *)(v439 + 94CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v32;
      int v33 = av1_get_bits((uint64_t)&v440, 1u);
      *(_DWORD *)(v439 + 944) = v33;
      if (v33)
      {
        if (!v32) {
          return 4294954584;
        }
        uint64_t v431 = a7;
        *(_DWORD *)(v439 + 948) = 0;
        *(_DWORD *)(v439 + 968) = 0;
        *(_DWORD *)(v439 + 988) = 0;
        *(_DWORD *)(v439 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
        *(_DWORD *)(v439 + 56) = 0;
        *(_DWORD *)(v439 + 44) = av1_get_bits((uint64_t)&v440, 3u);
        *(_DWORD *)(v439 + 48) = av1_get_bits((uint64_t)&v440, 2u);
        *(void *)(v439 + 64) = 0;
        *(_DWORD *)(v439 + 6CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
        goto LABEL_671;
      }
      int v56 = av1_get_bits((uint64_t)&v440, 1u);
      *(_DWORD *)(v439 + 948) = v56;
      if (!v56)
      {
        uint64_t v431 = a7;
        *(_DWORD *)(v439 + 968) = 0;
        uint64_t v123 = v439;
        char v124 = 1;
        goto LABEL_654;
      }
      *(_DWORD *)(v439 + 952) = av1_get_bits((uint64_t)&v440, 0x20u);
      *(_DWORD *)(v439 + 956) = av1_get_bits((uint64_t)&v440, 0x20u);
      int v57 = av1_get_bits((uint64_t)&v440, 1u);
      *(_DWORD *)(v439 + 96CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v57;
      if (!v57) {
        goto LABEL_652;
      }
      unsigned int v58 = 0;
      while (!av1_get_bits((uint64_t)&v440, 1u))
      {
        if (++v58 == 32) {
          goto LABEL_97;
        }
      }
      if (!v58)
      {
        int v193 = 0;
        goto LABEL_650;
      }
      int v193 = av1_get_bits((uint64_t)&v440, v58) + ~(-1 << v58);
      if (v193 != -1)
      {
LABEL_650:
        uint64_t v18 = v440;
        if (v440) {
          return v18;
        }
        *(_DWORD *)(v439 + 964) = v193 + 1;
LABEL_652:
        uint64_t v123 = v439;
        char v124 = 1;
        int v337 = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(v439 + 968) = v337;
        uint64_t v431 = a7;
        if (v337)
        {
          *(_DWORD *)(v439 + 972) = av1_get_bits((uint64_t)&v440, 5u) + 1;
          *(_DWORD *)(v439 + 976) = av1_get_bits((uint64_t)&v440, 0x20u);
          *(_DWORD *)(v439 + 98CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits((uint64_t)&v440, 5u) + 1;
          char v124 = 0;
          *(_DWORD *)(v439 + 984) = av1_get_bits((uint64_t)&v440, 5u) + 1;
        }
LABEL_654:
        int v338 = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(v123 + 988) = v338;
        unsigned int v339 = av1_get_bits((uint64_t)&v440, 5u);
        uint64_t v340 = v339 + 1;
        *(_DWORD *)(v123 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v340;
        if (v339 <= 0x7FFFFFFE)
        {
          v341 = (_DWORD *)(v439 + 68);
          v342 = (_DWORD *)(v439 + 1108);
          while (1)
          {
            int v343 = av1_get_bits((uint64_t)&v440, 0xCu);
            *(v341 - 3) = v343;
            unsigned int v59 = v433;
            if (v343)
            {
              if (!(_BYTE)v343 || (v343 & 0xF00) == 0) {
                break;
              }
            }
            int v344 = av1_get_bits((uint64_t)&v440, 3u) + 2;
            *(v341 - 6) = v344;
            *(v341 - 5) = av1_get_bits((uint64_t)&v440, 2u);
            if (v344 < 4) {
              int v345 = 0;
            }
            else {
              int v345 = av1_get_bits((uint64_t)&v440, 1u);
            }
            *(v341 - 2) = v345;
            if (v124)
            {
              *(v341 - 1) = 0;
            }
            else
            {
              int v346 = av1_get_bits((uint64_t)&v440, 1u);
              *(v341 - 1) = v346 != 0;
              if (v346)
              {
                unsigned int v347 = *(_DWORD *)(v439 + 972);
                *(v342 - 2) = av1_get_bits((uint64_t)&v440, v347);
                *(v342 - 1) = av1_get_bits((uint64_t)&v440, v347);
                _DWORD *v342 = av1_get_bits((uint64_t)&v440, 1u);
              }
            }
            if (v338)
            {
              int v348 = av1_get_bits((uint64_t)&v440, 1u);
              _DWORD *v341 = v348 != 0;
              if (v348) {
                *(v341 - 4) = av1_get_bits((uint64_t)&v440, 4u) + 1;
              }
            }
            else
            {
              _DWORD *v341 = 0;
            }
            v341 += 7;
            v342 += 3;
            if (!--v340) {
              goto LABEL_671;
            }
          }
LABEL_765:
          uint64_t v283 = check_for_overrun(&v440, v59, uleb128);
          if (v283) {
            return v283;
          }
          *(void *)(v12 + 3312) = v439;
          if (v441 <= 7) {
            uint64_t v18 = 0;
          }
          else {
            uint64_t v18 = 4294954584;
          }
          int v29 = 2;
          a7 = v431;
          goto LABEL_770;
        }
LABEL_671:
        unsigned int v349 = av1_get_bits((uint64_t)&v440, 4u) + 1;
        *(_DWORD *)(v439 + 992) = v349;
        unsigned int v350 = av1_get_bits((uint64_t)&v440, 4u) + 1;
        *(_DWORD *)(v439 + 996) = v350;
        *(_DWORD *)(v439 + 4) = av1_get_bits((uint64_t)&v440, v349) + 1;
        *(_DWORD *)(v439 + 8) = av1_get_bits((uint64_t)&v440, v350) + 1;
        if (v33)
        {
          *(_DWORD *)(v439 + 100CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
        }
        else
        {
          int v351 = av1_get_bits((uint64_t)&v440, 1u);
          *(_DWORD *)(v439 + 100CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v351;
          if (v351)
          {
            int v352 = av1_get_bits((uint64_t)&v440, 4u);
            *(_DWORD *)(v439 + 1004) = v352 + 2;
            *(_DWORD *)(v439 + 1008) = v352 + av1_get_bits((uint64_t)&v440, 3u) + 3;
          }
        }
        *(_DWORD *)(v439 + 1012) = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(v439 + 1016) = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(v439 + 102CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits((uint64_t)&v440, 1u);
        if (v33)
        {
          *(void *)(v439 + 104CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
          *(_OWORD *)(v439 + 1024) = 0u;
          *(void *)(v439 + 1048) = 0x200000000;
          *(void *)(v439 + 1056) = 2;
          goto LABEL_688;
        }
        *(_DWORD *)(v439 + 1024) = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(v439 + 1028) = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(v439 + 1032) = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(v439 + 1036) = av1_get_bits((uint64_t)&v440, 1u);
        int v353 = av1_get_bits((uint64_t)&v440, 1u);
        int v354 = v353;
        *(_DWORD *)(v439 + 104CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v353;
        if (v353)
        {
          *(_DWORD *)(v439 + 1044) = av1_get_bits((uint64_t)&v440, 1u);
          int v353 = av1_get_bits((uint64_t)&v440, 1u);
        }
        else
        {
          *(_DWORD *)(v439 + 1044) = 0;
          *(_DWORD *)(v439 + 106CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
        }
        *(_DWORD *)(v439 + 1048) = v353;
        if (av1_get_bits((uint64_t)&v440, 1u))
        {
          *(_DWORD *)(v439 + 1052) = 2;
        }
        else
        {
          int v355 = av1_get_bits((uint64_t)&v440, 1u);
          *(_DWORD *)(v439 + 1052) = v355;
          if (!v355) {
            goto LABEL_684;
          }
        }
        if (!av1_get_bits((uint64_t)&v440, 1u))
        {
          int v356 = av1_get_bits((uint64_t)&v440, 1u);
LABEL_686:
          *(_DWORD *)(v439 + 1056) = v356;
          if (v354) {
            *(_DWORD *)(v439 + 106CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits((uint64_t)&v440, 3u) + 1;
          }
LABEL_688:
          *(_DWORD *)(v439 + 1064) = av1_get_bits((uint64_t)&v440, 1u);
          *(_DWORD *)(v439 + 1068) = av1_get_bits((uint64_t)&v440, 1u);
          *(_DWORD *)(v439 + 1072) = av1_get_bits((uint64_t)&v440, 1u);
          *(_DWORD *)(v439 + 32) = av1_get_bits((uint64_t)&v440, 1u);
          if (v31 == 1) {
            int v357 = 0;
          }
          else {
            int v357 = av1_get_bits((uint64_t)&v440, 1u);
          }
          *(_DWORD *)(v439 + 1084) = v357;
          int v358 = av1_get_bits((uint64_t)&v440, 1u);
          *(_DWORD *)(v439 + 1088) = v358;
          if (v358)
          {
            int v359 = av1_get_bits((uint64_t)&v440, 8u);
            *(_DWORD *)(v439 + 16) = v359;
            int v360 = av1_get_bits((uint64_t)&v440, 8u);
            *(_DWORD *)(v439 + 2CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v360;
            int v361 = av1_get_bits((uint64_t)&v440, 8u);
            *(_DWORD *)(v439 + 24) = v361;
            if (!v357)
            {
              if (v359 == 1 && v360 == 13 && !v361)
              {
                *(_DWORD *)(v439 + 12) = 3;
                *(void *)(v439 + 1076) = 0;
                *(_DWORD *)(v439 + 36) = 1;
                if (v31 != 1) {
                  return 4294954584;
                }
                goto LABEL_763;
              }
LABEL_700:
              *(_DWORD *)(v439 + 36) = av1_get_bits((uint64_t)&v440, 1u);
              if (v31)
              {
                if (v31 == 1)
                {
                  int v364 = 0;
                  *(_DWORD *)(v439 + 12) = 3;
                  *(void *)(v439 + 1076) = 0;
LABEL_762:
                  *(_DWORD *)(v439 + 28) = v364;
LABEL_763:
                  BOOL v363 = av1_get_bits((uint64_t)&v440, 1u) != 0;
                  goto LABEL_764;
                }
                if (*(_DWORD *)(v439 + 1076) != 1 || *(_DWORD *)(v439 + 1080) != 1)
                {
                  int v364 = 0;
                  goto LABEL_762;
                }
              }
              else
              {
                *(_DWORD *)(v439 + 12) = 1;
                *(void *)(v439 + 1076) = 0x100000001;
              }
              int v364 = av1_get_bits((uint64_t)&v440, 2u);
              goto LABEL_762;
            }
          }
          else
          {
            *(void *)(v439 + 16) = 0x200000002;
            *(_DWORD *)(v439 + 24) = 2;
            if (!v357) {
              goto LABEL_700;
            }
          }
          int v362 = av1_get_bits((uint64_t)&v440, 1u);
          BOOL v363 = 0;
          *(_DWORD *)(v439 + 36) = v362;
          *(_DWORD *)(v439 + 12) = 0;
          *(void *)(v439 + 1076) = 0x100000001;
          *(_DWORD *)(v439 + 28) = 0;
LABEL_764:
          *(_DWORD *)(v439 + 1092) = v363;
          *(_DWORD *)(v439 + 1096) = av1_get_bits((uint64_t)&v440, 1u);
          av1_get_bits((uint64_t)&v440, 1u);
          unsigned int v59 = v433;
          goto LABEL_765;
        }
LABEL_684:
        int v356 = 2;
        goto LABEL_686;
      }
LABEL_97:
      uint64_t v431 = a7;
      uint64_t v18 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      unsigned int v59 = v433;
      if (!v18) {
        goto LABEL_765;
      }
      return v18;
    case 2:
    case 15:
      goto LABEL_820;
    case 3:
    case 6:
      if ((a8 & 4) != 0) {
        goto LABEL_38;
      }
      goto LABEL_35;
    case 4:
      goto LABEL_545;
    case 5:
      if ((a8 & 0x10) == 0)
      {
LABEL_35:
        int v29 = 0;
        goto LABEL_546;
      }
      unsigned int v43 = v26 >> 3;
      unsigned int v433 = 8 * (DWORD2(v441) - v442) - v441;
      long long v444 = v441;
      long long v445 = v442;
      long long v443 = v440;
      int v44 = DWORD2(v441);
      int v45 = v442;
      int v46 = v441;
      int v47 = av1_get_uleb128(&v443);
      uint64_t v18 = v443;
      if (v443) {
        goto LABEL_541;
      }
      unsigned int v26 = v433;
      int v48 = uleb128 - ((8 * (v44 - v45) - v46 - v433) >> 3);
      if (v48 + v43 > a2)
      {
        uint64_t v418 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        unsigned int v26 = v433;
        uint64_t v18 = v418;
        int v29 = 0;
        goto LABEL_820;
      }
      if (v48 < 1) {
        goto LABEL_66;
      }
      while (!*(unsigned char *)(a1 + v43 - 1 + v48))
      {
        BOOL v49 = __OFSUB__(v48--, 1);
        if ((v48 < 0) ^ v49 | (v48 == 0))
        {
          int v48 = 0;
          break;
        }
      }
LABEL_66:
      switch(v47)
      {
        case 1:
          if (v48 <= 5) {
            goto LABEL_810;
          }
          long long v446 = v443;
          long long v447 = v444;
          long long v448 = v445;
          uint64_t v126 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
          *(void *)(v12 + 3344) = v126;
          if (v126)
          {
            int64x2_t v127 = v126;
            *uint64_t v126 = av1_get_bits((uint64_t)&v446, 0x10u);
            v127[1] = av1_get_bits((uint64_t)&v446, 0x10u);
            if (!check_for_overrun(&v446, v433, uleb128))
            {
              if ((a8 & 0x100) == 0)
              {
                double v128 = *(void **)(v12 + 3344);
                if (v128)
                {
                  *(void *)(v12 + 3344) = 0;
                  free(v128);
                }
              }
              uint64_t v18 = 0;
              int v52 = 256;
              goto LABEL_818;
            }
            v419 = *(void **)(v12 + 3344);
            if (v419)
            {
              *(void *)(v12 + 3344) = 0;
LABEL_816:
              free(v419);
            }
          }
          break;
        case 2:
          if (v48 <= 25) {
            goto LABEL_810;
          }
          long long v446 = v443;
          long long v447 = v444;
          long long v448 = v445;
          double v129 = malloc_type_malloc(0x18uLL, 0x1000040504FFAC1uLL);
          *(void *)(v12 + 336CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v129;
          if (v129)
          {
            double v130 = v129;
            for (uint64_t i = 0; i != 6; i += 2)
            {
              v130[i] = av1_get_bits((uint64_t)&v446, 0x10u);
              v130[i + 1] = av1_get_bits((uint64_t)&v446, 0x10u);
            }
            v130[6] = av1_get_bits((uint64_t)&v446, 0x10u);
            v130[7] = av1_get_bits((uint64_t)&v446, 0x10u);
            *((_DWORD *)v130 + 4) = av1_get_bits((uint64_t)&v446, 0x20u);
            *((_DWORD *)v130 + 5) = av1_get_bits((uint64_t)&v446, 0x20u);
            if (!check_for_overrun(&v446, v433, uleb128))
            {
              if ((a8 & 0x200) == 0)
              {
                double v132 = *(void **)(v12 + 3360);
                if (v132)
                {
                  *(void *)(v12 + 336CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
                  free(v132);
                }
              }
              uint64_t v18 = 0;
              int v52 = 512;
              goto LABEL_818;
            }
            v419 = *(void **)(v12 + 3360);
            if (v419)
            {
              *(void *)(v12 + 336CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
              goto LABEL_816;
            }
          }
          break;
        case 4:
          if (v48 > 7)
          {
            char v50 = av1_get_bits((uint64_t)&v443, 8u);
            *(unsigned char *)(v12 + 3376) = v50;
            if (v50 == -1) {
              *(unsigned char *)(v12 + 3377) = av1_get_bits((uint64_t)&v443, 8u);
            }
            uint64_t v51 = check_for_overrun(&v443, v433, uleb128);
            if (!v51)
            {
              if ((a8 & 0x40) == 0)
              {
                unsigned int v26 = v433;
                if ((a8 & 0x80) == 0) {
                  goto LABEL_75;
                }
                long long v446 = v443;
                long long v447 = v444;
                long long v448 = v445;
                if (*(unsigned __int8 *)(v12 + 3376) != 181)
                {
                  uint64_t v18 = 0;
LABEL_786:
                  v410 = *(void **)(v12 + 3400);
                  if (v410)
                  {
                    *(void *)(v12 + 340CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
                    free(v410);
                    unsigned int v26 = v433;
                  }
                  int v52 = 0;
                  goto LABEL_819;
                }
                unsigned int v328 = uleb128 - ((8 * (DWORD2(v447) - v448) - (v447 + v433)) >> 3);
                if (v328 - 512 >= 0xFFFFFE07)
                {
                  size_t v329 = v328 + 1;
                  v330 = malloc_type_malloc(v329, 0x1B48CED7uLL);
                  *(void *)(v12 + 340CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v330;
                  if (v330)
                  {
                    unsigned char *v330 = *(unsigned char *)(v12 + 3376);
                    __int16 v331 = av1_get_bits((uint64_t)&v446, 0x10u);
                    *(_WORD *)(v12 + 3378) = v331;
                    *(unsigned char *)(*(void *)(v12 + 3400) + 1) = HIBYTE(v331);
                    *(unsigned char *)(*(void *)(v12 + 3400) + 2) = *(unsigned char *)(v12 + 3378);
                    __int16 v332 = av1_get_bits((uint64_t)&v446, 0x10u);
                    *(_WORD *)(v12 + 338CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v332;
                    *(unsigned char *)(*(void *)(v12 + 3400) + 3) = HIBYTE(v332);
                    *(unsigned char *)(*(void *)(v12 + 3400) + 4) = *(unsigned char *)(v12 + 3380);
                    if (*(_WORD *)(v12 + 3378) == 60 && *(_WORD *)(v12 + 3380) == 1)
                    {
                      char v333 = av1_get_bits((uint64_t)&v446, 8u);
                      *(unsigned char *)(*(void *)(v12 + 3400) + 5) = v333;
                      if (v333 == 4
                        && (char v334 = av1_get_bits((uint64_t)&v446, 8u),
                            *(unsigned char *)(*(void *)(v12 + 3400) + 6) = v334,
                            v334 == 1))
                      {
                        *(unsigned char *)(*(void *)(v12 + 3400) + 7) = av1_get_bits((uint64_t)&v446, 8u);
                        uint64_t v335 = 4294954579;
                        if ((*(unsigned char *)(*(void *)(v12 + 3400) + 7) & 0xC0) == 0x40 && v329 >= 9)
                        {
                          for (uint64_t j = 8; j != v329; ++j)
                            *(unsigned char *)(*(void *)(v12 + 3400) + j) = av1_get_bits((uint64_t)&v446, 8u);
                          uint64_t v18 = check_for_overrun(&v446, v433, uleb128);
                          if (!v18)
                          {
                            *(void *)(v12 + 3384) = v329;
                            int v52 = 128;
LABEL_818:
                            unsigned int v26 = v433;
                            goto LABEL_819;
                          }
                          goto LABEL_785;
                        }
                      }
                      else
                      {
                        uint64_t v335 = 4294954579;
                      }
                      goto LABEL_841;
                    }
                    uint64_t v18 = 0;
                  }
                  else
                  {
                    uint64_t v18 = 4294954584;
                  }
LABEL_785:
                  unsigned int v26 = v433;
                  goto LABEL_786;
                }
                uint64_t v335 = 4294954584;
LABEL_841:
                uint64_t v18 = FigSignalErrorAt(v335, 0, 0, 0, 0, 0, 0);
                goto LABEL_785;
              }
              long long v447 = v444;
              long long v448 = v445;
              long long v446 = v443;
              if (uleb128 - ((8 * (DWORD2(v444) - v445) - (v444 + v433)) >> 3) + 1 < 7)
              {
                uint64_t v395 = v12;
              }
              else
              {
                unsigned __int16 v194 = av1_get_bits((uint64_t)&v446, 0x10u);
                int v195 = v194;
                *(_WORD *)(v12 + 3378) = v194;
                __int16 v196 = av1_get_bits((uint64_t)&v446, 0x20u);
                uint64_t v18 = 0;
                *(_WORD *)(v12 + 338CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v196;
                if (v195 != 59 || v196 != 2048) {
                  goto LABEL_753;
                }
                int v197 = av1_get_bits((uint64_t)&v446, 2u);
                uint64_t v198 = check_for_overrun(&v446, v433, uleb128);
                if (v198)
                {
                  uint64_t v18 = v198;
                  goto LABEL_753;
                }
                if (v197
                  || av1_get_bits((uint64_t)&v446, 3u) != 6
                  || av1_get_bits((uint64_t)&v446, 5u) != 31
                  || av1_get_bits((uint64_t)&v446, 5u) != 6
                  || av1_get_bits((uint64_t)&v446, 1u) != 1
                  || av1_get_bits((uint64_t)&v446, 5u) != 1
                  || av1_get_bits((uint64_t)&v446, 1u))
                {
                  uint64_t v18 = 0;
                  goto LABEL_753;
                }
                if (av1_get_bits((uint64_t)&v446, 1u)
                  || av1_get_bits((uint64_t)&v446, 1u)
                  || av1_get_bits((uint64_t)&v446, 1u)
                  || av1_get_bits((uint64_t)&v446, 1u))
                {
                  uint64_t v395 = v12;
                  uint64_t v399 = 4294954579;
                  goto LABEL_751;
                }
                uint64_t v395 = v12;
                if (av1_get_bits((uint64_t)&v446, 1u) != 1)
                {
                  uint64_t v18 = 4294954584;
                  goto LABEL_752;
                }
                unsigned int v396 = 0;
                int v397 = 1;
                while (v397)
                {
                  int v398 = av1_get_bits((uint64_t)&v446, 8u);
                  int v397 = av1_get_bits((uint64_t)&v446, 1u);
                  if (!check_for_overrun(&v446, v433, uleb128))
                  {
                    if (v397) {
                      unsigned int v396 = ((v398 + v396) << 8) + 256;
                    }
                    else {
                      v396 += v398;
                    }
                    if (!v446) {
                      continue;
                    }
                  }
                  goto LABEL_750;
                }
                if (v396 - 513 >= 0xFFFFFE00)
                {
                  v411 = malloc_type_malloc((2 * v396) | 1, 0x866FC41AuLL);
                  uint64_t v12 = v395;
                  *(void *)(v395 + 340CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v411;
                  if (!v411)
                  {
                    uint64_t v18 = 4294954584;
                    goto LABEL_753;
                  }
                  int v412 = 0;
                  unsigned char *v411 = 25;
                  *(void *)(v395 + 3384) = 1;
                  do
                  {
                    char v413 = av1_get_bits((uint64_t)&v446, 8u);
                    if (v412 == 2)
                    {
                      if ((v413 & 0xFC) != 0)
                      {
                        int v412 = 2;
                      }
                      else
                      {
                        int v412 = 0;
                        uint64_t v414 = *(void *)(v395 + 3400);
                        uint64_t v415 = *(void *)(v395 + 3384);
                        *(void *)(v395 + 3384) = v415 + 1;
                        *(unsigned char *)(v414 + v415) = 3;
                      }
                    }
                    uint64_t v416 = *(void *)(v395 + 3400);
                    uint64_t v417 = *(void *)(v395 + 3384);
                    *(void *)(v395 + 3384) = v417 + 1;
                    *(unsigned char *)(v416 + v417) = v413;
                    if (v413) {
                      int v412 = 0;
                    }
                    else {
                      ++v412;
                    }
                    --v396;
                  }
                  while (v396);
                  if (!av1_get_bits((uint64_t)&v446, 5u)
                    && av1_get_bits((uint64_t)&v446, 2u) == 1
                    && !av1_get_bits((uint64_t)&v446, 2u)
                    && !av1_get_bits((uint64_t)&v446, 8u))
                  {
                    uint64_t v18 = check_for_overrun(&v446, v433, uleb128);
                    if (!v18)
                    {
                      int v52 = 64;
                      goto LABEL_818;
                    }
LABEL_753:
                    v400 = *(void **)(v12 + 3400);
                    if (v400)
                    {
                      *(void *)(v12 + 340CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
                      free(v400);
                    }
                    int v52 = 0;
                    goto LABEL_818;
                  }
                }
              }
LABEL_750:
              uint64_t v399 = 4294954584;
LABEL_751:
              uint64_t v18 = FigSignalErrorAt(v399, 0, 0, 0, 0, 0, 0);
LABEL_752:
              uint64_t v12 = v395;
              goto LABEL_753;
            }
LABEL_811:
            uint64_t v18 = v51;
            goto LABEL_541;
          }
LABEL_810:
          uint64_t v51 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
          goto LABEL_811;
        default:
LABEL_75:
          int v52 = 0;
          uint64_t v18 = 0;
LABEL_819:
          int v29 = v52 | 0x10;
          goto LABEL_820;
      }
      int v52 = 0;
      uint64_t v18 = 0;
      goto LABEL_818;
    case 7:
      int v29 = 0;
      if ((a8 & 4) == 0)
      {
        uint64_t v18 = 0;
        goto LABEL_820;
      }
      uint64_t v18 = 0;
      if (*(void *)(v12 + 3328)) {
        goto LABEL_820;
      }
LABEL_38:
      uint64_t v18 = 4294954584;
      uint64_t v432 = a7;
      if (!a7) {
        return v18;
      }
      uint64_t v34 = *(void *)(v12 + 3312);
      if (!v34) {
        return v18;
      }
      int v35 = *(_DWORD *)(v439 + 944);
      int v430 = v25;
      unsigned int v433 = 8 * (DWORD2(v441) - v442) - v441;
      if (v35)
      {
        int v36 = 0;
        *(_DWORD *)(a6 + 232) = 0;
        *(_DWORD *)(a6 + 26CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
        v428 = (_DWORD *)(a6 + 232);
        *(_DWORD *)(a6 + 276) = 1;
        v427 = (_DWORD *)(a6 + 276);
      }
      else
      {
        int v39 = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(a6 + 26CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v39 != 0;
        if (v39)
        {
          int v40 = av1_get_bits((uint64_t)&v440, 3u);
          *(_DWORD *)(a6 + 264) = v40;
          if (*(_DWORD *)(v439 + 968) && !*(_DWORD *)(v439 + 960)) {
            *(_DWORD *)(a6 + 272) = av1_get_bits((uint64_t)&v440, *(_DWORD *)(v439 + 984));
          }
          if (*(_DWORD *)(v439 + 1000))
          {
            int v41 = av1_get_bits((uint64_t)&v440, *(_DWORD *)(v439 + 1008));
            *(_DWORD *)(a6 + 268) = v41;
            uint64_t v42 = *(void *)(v12 + 328 * v40 + 3432);
            if (!v42 || *(_DWORD *)(v42 + 268) != v41) {
              return 4294954584;
            }
          }
          goto LABEL_537;
        }
        int v36 = av1_get_bits((uint64_t)&v440, 2u);
        *(_DWORD *)(a6 + 232) = v36;
        int v121 = av1_get_bits((uint64_t)&v440, 1u);
        v427 = (_DWORD *)(a6 + 276);
        v428 = (_DWORD *)(a6 + 232);
        *(_DWORD *)(a6 + 276) = v121 != 0;
        if (!v121)
        {
          int v122 = av1_get_bits((uint64_t)&v440, 1u);
          int v37 = 0;
          *(_DWORD *)(a6 + 28CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v122;
          goto LABEL_46;
        }
      }
      if (*(_DWORD *)(v439 + 968) && !*(_DWORD *)(v439 + 960)) {
        *(_DWORD *)(a6 + 272) = av1_get_bits((uint64_t)&v440, *(_DWORD *)(v439 + 984));
      }
      int v37 = 1;
LABEL_46:
      if (v36 != 3)
      {
        if (v36)
        {
          if (!v35) {
            goto LABEL_49;
          }
        }
        else if (!(v37 | v35))
        {
LABEL_49:
          BOOL v38 = av1_get_bits((uint64_t)&v440, 1u) != 0;
          goto LABEL_78;
        }
      }
      BOOL v38 = 1;
LABEL_78:
      *(_DWORD *)(a6 + 284) = v38;
      *(_DWORD *)(a6 + 288) = av1_get_bits((uint64_t)&v440, 1u);
      int v53 = *(_DWORD *)(v439 + 1052);
      if (v53 == 2) {
        int v53 = av1_get_bits((uint64_t)&v440, 1u);
      }
      *(_DWORD *)(a6 + 292) = v53;
      if (v53)
      {
        int v53 = *(_DWORD *)(v439 + 1056);
        if (v53 == 2) {
          int v53 = av1_get_bits((uint64_t)&v440, 1u);
        }
      }
      if (*(_DWORD *)(a6 + 232)) {
        int v54 = v53;
      }
      else {
        int v54 = 1;
      }
      *(_DWORD *)(a6 + 296) = v54;
      if (*(_DWORD *)(v439 + 1000)) {
        *(_DWORD *)(a6 + 268) = av1_get_bits((uint64_t)&v440, *(_DWORD *)(v439 + 1008));
      }
      int v426 = v27;
      if (v35)
      {
        int v55 = 0;
      }
      else if (*v428 == 3)
      {
        int v55 = 1;
      }
      else
      {
        int v55 = av1_get_bits((uint64_t)&v440, 1u);
      }
      *(_DWORD *)(a6 + 30CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v55;
      int v60 = *(_DWORD *)(v439 + 1040);
      if (v60) {
        int v61 = av1_get_bits((uint64_t)&v440, *(_DWORD *)(v439 + 1060));
      }
      else {
        int v61 = 0;
      }
      *(_DWORD *)(a6 + 248) = v61;
      int v424 = v55;
      if (!v38 && (*(unsigned char *)v428 & 1) != 0)
      {
        uint64_t v62 = v12;
        int v63 = av1_get_bits((uint64_t)&v440, 3u);
      }
      else
      {
        uint64_t v62 = v12;
        int v63 = 7;
      }
      *(_DWORD *)(a6 + 304) = v63;
      if (*(_DWORD *)(v439 + 968))
      {
        int v64 = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(a6 + 308) = v64;
        if (v64)
        {
          int v65 = *(_DWORD *)(v34 + 40);
          if (v65 >= 1)
          {
            uint64_t v66 = 0;
            long long v67 = (_DWORD *)(v439 + 64);
            do
            {
              if (*v67)
              {
                int v68 = *(v67 - 2);
                if (!v68 || (((1 << (*(_DWORD *)(a6 + 256) + 8)) | (1 << *(_DWORD *)(a6 + 252))) & ~v68) == 0)
                {
                  *(_DWORD *)(a6 + 312 + 4 * v66) = av1_get_bits((uint64_t)&v440, *(_DWORD *)(v439 + 980));
                  int v65 = *(_DWORD *)(v34 + 40);
                }
              }
              ++v66;
              v67 += 7;
            }
            while (v66 < v65);
          }
        }
      }
      int v69 = !v38;
      int v70 = *v428;
      if ((*v428 & 1) == 0)
      {
        uint64_t v12 = v62;
        if (v70 || !*v427)
        {
          int v71 = av1_get_bits((uint64_t)&v440, 8u);
          *(_DWORD *)(a6 + 44CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v71;
          char v72 = v71 == 255 || !v38;
          if (v60 && (v72 & 1) == 0)
          {
            unsigned int v73 = *(_DWORD *)(v439 + 1060);
            int v74 = 8;
            do
            {
              av1_get_bits((uint64_t)&v440, v73);
              --v74;
            }
            while (v74);
          }
        }
        else
        {
          *(_DWORD *)(a6 + 44CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 255;
        }
        double v83 = (_DWORD *)v439;
        read_frame_size(v62, (uint64_t)&v440, (_DWORD *)a6, (_DWORD *)v439, 0);
        BOOL v120 = *(_DWORD *)(a6 + 292) && !*(_DWORD *)(a6 + 456) && av1_get_bits((uint64_t)&v440, 1u) != 0;
        int v125 = 0;
        *(_DWORD *)(a6 + 464) = v120;
LABEL_251:
        *(_DWORD *)(a6 + 512) = v125;
        BOOL v139 = !v83[236] && !*(_DWORD *)(a6 + 288) && av1_get_bits((uint64_t)&v440, 1u) == 0;
        *(_DWORD *)(a6 + 516) = v139;
        int v140 = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(a6 + 52CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v140;
        int v141 = v83[253];
        int v142 = (64 << v141) - 1;
        char v143 = v141 + 6;
        int v144 = (v142 + *(_DWORD *)(a6 + 236)) >> v143;
        int v145 = *(_DWORD *)(a6 + 244);
        signed int v146 = 0x1000u >> v143;
        unsigned int v147 = -1;
        do
          ++v147;
        while (v146 << v147 < v144);
        *(_DWORD *)(a6 + 528) = v147;
        if (v144 >= 64) {
          int v148 = 64;
        }
        else {
          int v148 = v144;
        }
        unsigned int v149 = -1;
        do
          ++v149;
        while (1 << v149 < v148);
        int v150 = (v145 + v142) >> v143;
        *(_DWORD *)(a6 + 532) = v149;
        if (v150 >= 64) {
          int v151 = 64;
        }
        else {
          int v151 = (v145 + v142) >> v143;
        }
        unsigned int v152 = -1;
        do
          ++v152;
        while (1 << v152 < v151);
        unsigned int v153 = 0x900000u >> (2 * v143);
        *(_DWORD *)(a6 + 548) = v152;
        int v154 = v144 * v150;
        unsigned int v155 = -1;
        do
          ++v155;
        while ((int)(v153 << v155) < v154);
        int v156 = v147;
        if (v155 > v147)
        {
          int v156 = -1;
          do
            ++v156;
          while ((int)(v153 << v156) < v154);
        }
        if (v140)
        {
          *(_DWORD *)(a6 + 536) = v147;
          if (v147 >= v149)
          {
            a7 = v432;
          }
          else
          {
            a7 = v432;
            do
            {
              if (!av1_get_bits((uint64_t)&v440, 1u)) {
                break;
              }
              *(_DWORD *)(a6 + 536) = ++v147;
            }
            while (v147 < v149);
          }
          if (v144 < 1)
          {
            LODWORD(v157) = 0;
          }
          else
          {
            int v163 = 0;
            int v164 = ((v144 - 1) >> v147) + 1;
            if (v144 <= v164) {
              int v165 = ((v144 - 1) >> v147) + 1;
            }
            else {
              int v165 = v144;
            }
            uint64_t v166 = (v165 - 1) / v164 + 1;
            LODWORD(v157) = v166;
            long long v167 = (_WORD *)(a6 + 560);
            do
            {
              *v167++ = v163;
              v163 += v164;
              --v166;
            }
            while (v166);
          }
          *(_DWORD *)(a6 + 54CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v157;
          unsigned int v168 = (v156 - v147) & ~((int)(v156 - v147) >> 31);
          *(_DWORD *)(a6 + 544) = v168;
          *(_DWORD *)(a6 + 552) = v168;
          if (v168 >= v152)
          {
            uint64_t v169 = v439;
          }
          else
          {
            uint64_t v169 = v439;
            do
            {
              if (!av1_get_bits((uint64_t)&v440, 1u)) {
                break;
              }
              *(_DWORD *)(a6 + 552) = ++v168;
            }
            while (v168 < v152);
          }
          if (v150 < 1)
          {
            LODWORD(v174) = 0;
          }
          else
          {
            int v170 = 0;
            int v171 = ((v150 - 1) >> v168) + 1;
            if (v150 <= v171) {
              int v172 = ((v150 - 1) >> v168) + 1;
            }
            else {
              int v172 = v150;
            }
            uint64_t v173 = (v172 - 1) / v171 + 1;
            LODWORD(v174) = v173;
            long long v175 = (_WORD *)(a6 + 690);
            do
            {
              *v175++ = v170;
              v170 += v171;
              --v173;
            }
            while (v173);
          }
          *(_DWORD *)(a6 + 556) = v174;
        }
        else
        {
          *(_DWORD *)(a6 + 54CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
          if (v144 < 1)
          {
            LODWORD(v157) = 0;
            unsigned int v159 = 0;
          }
          else
          {
            uint64_t v157 = 0;
            int v158 = 0;
            unsigned int v159 = 0;
            do
            {
              if (v144 - v158 >= v146) {
                signed int v160 = v146;
              }
              else {
                signed int v160 = v144 - v158;
              }
              if (v160 < 2) {
                int v161 = 1;
              }
              else {
                int v161 = av1_get_uniform(&v440, v160) + 1;
              }
              *(_WORD *)(a6 + 560 + 2 * v157) = v158;
              if ((int)v159 <= v161) {
                unsigned int v159 = v161;
              }
              *(_DWORD *)(a6 + 54CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v157 + 1;
              unsigned int v162 = v157++;
              if (v162 > 0x3E) {
                break;
              }
              v158 += v161;
            }
            while (v158 < v144);
          }
          unsigned int v147 = -1;
          a7 = v432;
          do
            ++v147;
          while (1 << v147 < (int)v157);
          *(_DWORD *)(a6 + 536) = v147;
          if (v156) {
            char v176 = v156 + 1;
          }
          else {
            char v176 = 0;
          }
          int v177 = v154 >> v176;
          if (v159 <= 1) {
            int v178 = 1;
          }
          else {
            int v178 = v159;
          }
          int v179 = v177 / v178;
          if (v179 <= 1) {
            int v180 = 1;
          }
          else {
            int v180 = v179;
          }
          *(_DWORD *)(a6 + 556) = 0;
          if (v150 < 1)
          {
            LODWORD(v174) = 0;
          }
          else
          {
            uint64_t v174 = 0;
            for (int k = 0; k < v150; k += v183)
            {
              if (v150 - k >= v180) {
                signed int v182 = v180;
              }
              else {
                signed int v182 = v150 - k;
              }
              if (v182 < 2) {
                int v183 = 1;
              }
              else {
                int v183 = av1_get_uniform(&v440, v182) + 1;
              }
              *(_WORD *)(a6 + 690 + 2 * v174) = k;
              *(_DWORD *)(a6 + 556) = v174 + 1;
              unsigned int v184 = v174++;
              if (v184 > 0x3E) {
                break;
              }
            }
          }
          unsigned int v168 = -1;
          uint64_t v169 = v439;
          do
            ++v168;
          while (1 << v168 < (int)v174);
          *(_DWORD *)(a6 + 552) = v168;
        }
        *(_WORD *)(a6 + 520 + 2 * (int)v157 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v144;
        *(_WORD *)(a6 + 520 + 2 * (int)v174 + 17CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v150;
        int v185 = v147 | v168;
        if (v147 | v168)
        {
          int v186 = av1_get_bits((uint64_t)&v440, v147 + v168);
          *(_DWORD *)(a6 + 82CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v186;
          if (v186 >= (int)v174 * (int)v157) {
            return 4294954584;
          }
          int v185 = av1_get_bits((uint64_t)&v440, 2u) + 1;
        }
        else
        {
          *(_DWORD *)(a6 + 82CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
        }
        *(_DWORD *)(a6 + 524) = v185;
        int v187 = av1_get_bits((uint64_t)&v440, 8u);
        *(_DWORD *)(a6 + 824) = v187;
        if (av1_get_bits((uint64_t)&v440, 1u)) {
          int v188 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
        }
        else {
          int v188 = 0;
        }
        *(_DWORD *)(a6 + 828) = v188;
        if (!*(_DWORD *)(v169 + 1084))
        {
          if (*(_DWORD *)(v169 + 1092)) {
            int v189 = av1_get_bits((uint64_t)&v440, 1u);
          }
          else {
            int v189 = 0;
          }
          if (av1_get_bits((uint64_t)&v440, 1u)) {
            int v190 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
          }
          else {
            int v190 = 0;
          }
          *(_DWORD *)(a6 + 832) = v190;
          if (av1_get_bits((uint64_t)&v440, 1u)) {
            int v191 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
          }
          else {
            int v191 = 0;
          }
          *(_DWORD *)(a6 + 836) = v191;
          if (v189)
          {
            if (av1_get_bits((uint64_t)&v440, 1u)) {
              int v192 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
            }
            else {
              int v192 = 0;
            }
            *(_DWORD *)(a6 + 84CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v192;
            if (av1_get_bits((uint64_t)&v440, 1u)) {
              int v191 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
            }
            else {
              int v191 = 0;
            }
          }
          else
          {
            *(_DWORD *)(a6 + 84CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v190;
          }
          *(_DWORD *)(a6 + 844) = v191;
        }
        int v199 = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(a6 + 848) = v199;
        if (v199)
        {
          *(_DWORD *)(a6 + 852) = av1_get_bits((uint64_t)&v440, 4u);
          int v200 = av1_get_bits((uint64_t)&v440, 4u);
          *(_DWORD *)(a6 + 856) = v200;
          if (*(_DWORD *)(v169 + 1092)) {
            int v200 = av1_get_bits((uint64_t)&v440, 4u);
          }
          *(_DWORD *)(a6 + 86CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v200;
        }
        int v201 = av1_get_bits((uint64_t)&v440, 1u);
        *(_DWORD *)(a6 + 864) = v201;
        if (v201)
        {
          uint64_t v202 = *(int *)(a6 + 304);
          if (v202 == 7)
          {
            *(_DWORD *)(a6 + 868) = 1;
            *(void *)(a6 + 872) = 0x100000000;
          }
          else
          {
            int v204 = av1_get_bits((uint64_t)&v440, 1u);
            *(_DWORD *)(a6 + 868) = v204;
            if (v204) {
              int v204 = av1_get_bits((uint64_t)&v440, 1u);
            }
            *(_DWORD *)(a6 + 872) = v204;
            int v205 = av1_get_bits((uint64_t)&v440, 1u);
            *(_DWORD *)(a6 + 876) = v205;
            if (!v205)
            {
              uint64_t v220 = *(void *)(v12 + 328 * *(int *)(a6 + 4 * v202 + 472) + 3432);
              if (!v220) {
                return 4294954584;
              }
              memcpy((void *)(a6 + 880), (const void *)(v220 + 880), 0x108uLL);
              if (v187)
              {
LABEL_419:
                int v216 = av1_get_bits((uint64_t)&v440, 1u);
                *(_DWORD *)(a6 + 1208) = v216;
                if (v216)
                {
                  *(_DWORD *)(a6 + 1212) = av1_get_bits((uint64_t)&v440, 2u);
                  if (!*(_DWORD *)(a6 + 464))
                  {
                    int v217 = av1_get_bits((uint64_t)&v440, 1u);
                    *(_DWORD *)(a6 + 1216) = v217 != 0;
                    long long v218 = (_DWORD *)v439;
                    if (v217)
                    {
                      *(_DWORD *)(a6 + 122CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits((uint64_t)&v440, 2u);
                      int v219 = av1_get_bits((uint64_t)&v440, 1u);
                      goto LABEL_429;
                    }
LABEL_428:
                    int v219 = 0;
                    *(_DWORD *)(a6 + 122CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
LABEL_429:
                    *(_DWORD *)(a6 + 1224) = v219;
                    BOOL v221 = !v188
                        && !*(_DWORD *)(a6 + 832)
                        && !*(_DWORD *)(a6 + 836)
                        && !*(_DWORD *)(a6 + 840)
                        && *(_DWORD *)(a6 + 844) == 0;
                    *(_DWORD *)(a6 + 1228) = 1;
                    uint64_t v222 = 880;
                    uint64_t v223 = 1176;
                    do
                    {
                      int v224 = v187;
                      if (v201)
                      {
                        int v225 = *(_DWORD *)(a6 + v222) + v187;
                        if (v225 >= 255) {
                          int v225 = 255;
                        }
                        int v224 = v225 & ~(v225 >> 31);
                      }
                      *(_DWORD *)(a6 + v223) = v224;
                      if (v224) {
                        BOOL v226 = 0;
                      }
                      else {
                        BOOL v226 = v221;
                      }
                      *(_DWORD *)(a6 + v223 - 32) = v226;
                      int v227 = *(_DWORD *)(a6 + 1228) & v226;
                      *(_DWORD *)(a6 + 1228) = v227;
                      v222 += 32;
                      v223 += 4;
                    }
                    while (v222 != 1136);
                    if (v227 || *(_DWORD *)(a6 + 464))
                    {
                      *(_DWORD *)(a6 + 1296) = 0;
                      *(_OWORD *)(a6 + 1232) = 0u;
                      *(void *)(a6 + 1248) = 0x100000001;
                      *(_OWORD *)(a6 + 1256) = default_mode_ref_deltas;
                      *(_OWORD *)(a6 + 1272) = unk_18FE95960;
                      *(void *)(a6 + 1288) = -1;
                    }
                    else
                    {
                      int v310 = av1_get_bits((uint64_t)&v440, 6u);
                      *(_DWORD *)(a6 + 1232) = v310;
                      int v311 = av1_get_bits((uint64_t)&v440, 6u);
                      *(_DWORD *)(a6 + 1236) = v311;
                      if (!v218[271] && v310 | v311)
                      {
                        *(_DWORD *)(a6 + 124CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits((uint64_t)&v440, 6u);
                        *(_DWORD *)(a6 + 1244) = av1_get_bits((uint64_t)&v440, 6u);
                      }
                      *(_DWORD *)(a6 + 1296) = av1_get_bits((uint64_t)&v440, 3u);
                      int v312 = av1_get_bits((uint64_t)&v440, 1u);
                      *(_DWORD *)(a6 + 1248) = v312;
                      if (!v312 || (int v313 = av1_get_bits((uint64_t)&v440, 1u), (*(_DWORD *)(a6 + 1252) = v313) == 0))
                      {
LABEL_447:
                        if (v218[267] && !*(_DWORD *)(a6 + 464))
                        {
                          *(_DWORD *)(a6 + 130CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits((uint64_t)&v440, 2u) + 3;
                          int v323 = av1_get_bits((uint64_t)&v440, 2u);
                          *(_DWORD *)(a6 + 1304) = v323;
                          if (v323 == 31)
                          {
LABEL_452:
                            if (v218[268] && !*(_DWORD *)(a6 + 464))
                            {
                              int v269 = av1_get_bits((uint64_t)&v440, 2u);
                              *(_DWORD *)(a6 + 1372) = v269;
                              if (v218[271])
                              {
                                int v270 = 0;
                                int v271 = 0;
                                *(_DWORD *)(a6 + 1376) = 0;
                              }
                              else
                              {
                                int v270 = av1_get_bits((uint64_t)&v440, 2u);
                                *(_DWORD *)(a6 + 1376) = v270;
                                int v271 = av1_get_bits((uint64_t)&v440, 2u);
                              }
                              *(_DWORD *)(a6 + 138CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v271;
                              if (v269 || v270 | v271)
                              {
                                int v326 = v218[253];
                                int v327 = v326 + 6;
                                *(_DWORD *)(a6 + 1384) = v326 + 6;
                                if (av1_get_bits((uint64_t)&v440, 1u))
                                {
                                  int v327 = v326 + 7;
                                  *(_DWORD *)(a6 + 1384) = v326 + 7;
                                  if (!v218[253])
                                  {
                                    v327 += av1_get_bits((uint64_t)&v440, 1u);
                                    *(_DWORD *)(a6 + 1384) = v327;
                                  }
                                }
                                *(_DWORD *)(a6 + 1388) = v327;
                                if (v270 | v271 && v218[269] == 1 && v218[270] == 1) {
                                  *(_DWORD *)(a6 + 1388) = v327 - av1_get_bits((uint64_t)&v440, 1u);
                                }
                              }
                              else
                              {
                                *(_DWORD *)(a6 + 1384) = 8;
                              }
LABEL_455:
                              if (v227)
                              {
                                int v228 = 0;
                              }
                              else if (av1_get_bits((uint64_t)&v440, 1u))
                              {
                                int v228 = 2;
                              }
                              else
                              {
                                int v228 = 1;
                              }
                              *(_DWORD *)(a6 + 1392) = v228;
                              int v25 = v430;
                              if (*(unsigned char *)(a6 + 232))
                              {
                                int v229 = av1_get_bits((uint64_t)&v440, 1u);
                                *(_DWORD *)(a6 + 1396) = v229;
                                *(_DWORD *)(a6 + 140CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
                                if (v229)
                                {
                                  if ((*(unsigned char *)v428 & 1) == 0 || !v218[260]) {
                                    goto LABEL_493;
                                  }
                                  uint64_t v230 = 0;
                                  int v231 = 0;
                                  int v232 = 0;
                                  int v233 = v218[265];
                                  int v234 = 1 << (v233 - 1);
                                  int v235 = v234 - 1;
                                  int v237 = -1;
                                  int v238 = -1;
                                  do
                                  {
                                    if (v233)
                                    {
                                      uint64_t v236 = a6 + 472;
                                      int v239 = *(_DWORD *)(v12 + 328 * *(int *)(a6 + 472 + 4 * v230) + 3440);
                                      int v240 = ((v239 - *(_DWORD *)(a6 + 248)) & v235)
                                           - ((v239 - *(_DWORD *)(a6 + 248)) & v234);
                                      if (v240 < 1)
                                      {
                                        if (v240 < 0 && (v238 == -1 || ((v239 - v238) & v235) > ((v239 - v238) & v234)))
                                        {
                                          int v238 = *(_DWORD *)(v12 + 328 * *(int *)(v236 + 4 * v230) + 3440);
                                          int v232 = v230;
                                        }
                                      }
                                      else if (v237 == -1 || ((v237 - v239) & v235) > ((v237 - v239) & v234))
                                      {
                                        int v237 = *(_DWORD *)(v12 + 328 * *(int *)(v236 + 4 * v230) + 3440);
                                        int v231 = v230;
                                      }
                                    }
                                    ++v230;
                                  }
                                  while (v230 != 7);
                                  if (v238 != -1 && v237 != -1) {
                                    goto LABEL_487;
                                  }
                                  if (v238 == -1) {
                                    goto LABEL_493;
                                  }
                                  uint64_t v241 = 0;
                                  int v231 = 0;
                                  int v242 = -1;
                                  do
                                  {
                                    if (v233)
                                    {
                                      int v243 = *(_DWORD *)(v12 + 328 * *(int *)(a6 + 472 + 4 * v241) + 3440);
                                      if (((v243 - v238) & v235) < ((v243 - v238) & v234)
                                        && (v242 == -1 || ((v243 - v242) & v235) > ((v243 - v242) & v234)))
                                      {
                                        int v242 = *(_DWORD *)(v12 + 328 * *(int *)(a6 + 472 + 4 * v241) + 3440);
                                        int v231 = v241;
                                      }
                                    }
                                    ++v241;
                                  }
                                  while (v241 != 7);
                                  if (v242 == -1)
                                  {
LABEL_493:
                                    int v229 = 0;
                                  }
                                  else
                                  {
LABEL_487:
                                    if (v232 >= v231) {
                                      int v244 = v231;
                                    }
                                    else {
                                      int v244 = v232;
                                    }
                                    *(_DWORD *)(a6 + 1408) = v244;
                                    if (v232 <= v231) {
                                      int v232 = v231;
                                    }
                                    *(_DWORD *)(a6 + 1412) = v232;
                                    *(_DWORD *)(a6 + 140CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
                                    int v229 = av1_get_bits((uint64_t)&v440, 1u);
                                  }
                                }
                              }
                              else
                              {
                                int v229 = 0;
                                *(void *)(a6 + 1396) = 0;
                              }
                              *(_DWORD *)(a6 + 1404) = v229;
                              if (!*(_DWORD *)(a6 + 284) && (*(unsigned char *)v428 & 1) != 0)
                              {
                                int v245 = v218[258];
                                if (v245) {
                                  int v245 = av1_get_bits((uint64_t)&v440, 1u) != 0;
                                }
                              }
                              else
                              {
                                int v245 = 0;
                              }
                              *(_DWORD *)(a6 + 1416) = v245;
                              *(_DWORD *)(a6 + 142CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits((uint64_t)&v440, 1u);
                              for (uint64_t m = 1424; m != 1676; m += 36)
                              {
                                uint64_t v247 = a6 + m;
                                *(_OWORD *)uint64_t v247 = dav1d_default_wm_params;
                                *(_OWORD *)(v247 + 16) = *(_OWORD *)&dword_18FE95988;
                                *(_DWORD *)(v247 + 32) = 0;
                              }
                              if (*(unsigned char *)v428)
                              {
                                uint64_t v248 = 0;
                                uint64_t v249 = a6 + 1448;
                                while (!av1_get_bits((uint64_t)&v440, 1u))
                                {
                                  *(_DWORD *)(v249 + v248 - 24) = 0;
LABEL_524:
                                  v248 += 36;
                                  if (v248 == 252) {
                                    goto LABEL_525;
                                  }
                                }
                                if (av1_get_bits((uint64_t)&v440, 1u))
                                {
                                  unsigned int v250 = 2;
                                }
                                else if (av1_get_bits((uint64_t)&v440, 1u))
                                {
                                  unsigned int v250 = 1;
                                }
                                else
                                {
                                  unsigned int v250 = 3;
                                }
                                *(_DWORD *)(v249 + v248 - 24) = v250;
                                uint64_t v251 = *(int *)(a6 + 304);
                                int v252 = (int *)&dav1d_default_wm_params;
                                if (v251 != 7)
                                {
                                  uint64_t v253 = *(void *)(v12 + 328 * *(int *)(a6 + 4 * v251 + 472) + 3432);
                                  if (!v253) {
                                    return 4294954584;
                                  }
                                  int v252 = (int *)(v253 + v248 + 1424);
                                }
                                if (v250 <= 1)
                                {
                                  if (*(_DWORD *)(a6 + 500)) {
                                    char v254 = 9;
                                  }
                                  else {
                                    char v254 = 8;
                                  }
                                  if (*(_DWORD *)(a6 + 500)) {
                                    char v257 = 13;
                                  }
                                  else {
                                    char v257 = 14;
                                  }
                                  int v255 = *(_DWORD *)(v249 + v248 - 12);
                                  int v256 = *(_DWORD *)(v249 + v248 - 8);
                                }
                                else
                                {
                                  char v254 = 12;
                                  int v255 = 2 * av1_get_bits_subexp(&v440, (v252[3] - 0x10000) >> 1, 12) + 0x10000;
                                  *(_DWORD *)(v249 + v248 - 12) = v255;
                                  int v256 = 2 * av1_get_bits_subexp(&v440, v252[4] >> 1, 12);
                                  *(_DWORD *)(v249 + v248 - 8) = v256;
                                  if (v250 == 3)
                                  {
                                    *(_DWORD *)(v249 + v248 - 4) = 2 * av1_get_bits_subexp(&v440, v252[5] >> 1, 12);
                                    int v255 = 2 * av1_get_bits_subexp(&v440, (v252[6] - 0x10000) >> 1, 12) + 0x10000;
                                    char v257 = 10;
LABEL_523:
                                    *(_DWORD *)(v249 + v248) = v255;
                                    *(_DWORD *)(v249 + v248 - 2CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = av1_get_bits_subexp(&v440, v252[1] >> v257, v254) << v257;
                                    *(_DWORD *)(v249 + v248 - 16) = av1_get_bits_subexp(&v440, v252[2] >> v257, v254) << v257;
                                    a7 = v432;
                                    long long v218 = (_DWORD *)v439;
                                    int v25 = v430;
                                    goto LABEL_524;
                                  }
                                  char v257 = 10;
                                }
                                *(_DWORD *)(v249 + v248 - 4) = -v256;
                                goto LABEL_523;
                              }
LABEL_525:
                              if (v218[274] && (*v427 || *(_DWORD *)(a6 + 280)))
                              {
                                int v258 = av1_get_bits((uint64_t)&v440, 1u);
                                *(_DWORD *)(a6 + 224) = v258 != 0;
                                LODWORD(v27) = v426;
                                if (v258)
                                {
                                  int v259 = av1_get_bits((uint64_t)&v440, 0x10u);
                                  if (*v428 == 1)
                                  {
                                    int v260 = av1_get_bits((uint64_t)&v440, 1u);
                                    *(_DWORD *)(a6 + 228) = v260 != 0;
                                    if (!v260)
                                    {
                                      int v261 = av1_get_bits((uint64_t)&v440, 3u);
                                      uint64_t v262 = 472;
                                      uint64_t v18 = 4294954584;
                                      while (*(_DWORD *)(a6 + v262) != v261)
                                      {
                                        v262 += 4;
                                        if (v262 == 500) {
                                          return v18;
                                        }
                                      }
                                      v384 = *(_OWORD **)(v12 + 328 * v261 + 3432);
                                      a7 = v432;
                                      if (!v384) {
                                        return 4294954584;
                                      }
                                      long long v385 = v384[1];
                                      *(_OWORD *)a6 = *v384;
                                      *(_OWORD *)(a6 + 16) = v385;
                                      long long v386 = v384[2];
                                      long long v387 = v384[3];
                                      long long v388 = v384[5];
                                      *(_OWORD *)(a6 + 64) = v384[4];
                                      *(_OWORD *)(a6 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v388;
                                      *(_OWORD *)(a6 + 32) = v386;
                                      *(_OWORD *)(a6 + 48) = v387;
                                      long long v389 = v384[6];
                                      long long v390 = v384[7];
                                      long long v391 = v384[9];
                                      *(_OWORD *)(a6 + 128) = v384[8];
                                      *(_OWORD *)(a6 + 144) = v391;
                                      *(_OWORD *)(a6 + 96) = v389;
                                      *(_OWORD *)(a6 + 112) = v390;
                                      long long v392 = v384[10];
                                      long long v393 = v384[11];
                                      long long v394 = v384[13];
                                      *(_OWORD *)(a6 + 192) = v384[12];
                                      *(_OWORD *)(a6 + 208) = v394;
                                      *(_OWORD *)(a6 + 16CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v392;
                                      *(_OWORD *)(a6 + 176) = v393;
                                      *(_DWORD *)a6 = v259;
                                      goto LABEL_537;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a6 + 228) = 1;
                                  }
                                  *(_DWORD *)a6 = v259;
                                  int v309 = av1_get_bits((uint64_t)&v440, 4u);
                                  *(_DWORD *)(a6 + 4) = v309;
                                  if (v309 > 14) {
                                    return 4294954584;
                                  }
                                  int v317 = v309;
                                  if (v309 >= 1)
                                  {
                                    uint64_t v318 = 0;
                                    uint64_t v319 = 2 * v309;
                                    do
                                    {
                                      unsigned __int8 v320 = av1_get_bits((uint64_t)&v440, 8u);
                                      uint64_t v321 = a6 + v318;
                                      *(unsigned char *)(a6 + v318 + 8) = v320;
                                      if (v318)
                                      {
                                        if (*(unsigned __int8 *)(v321 + 6) >= v320) {
                                          return 4294954584;
                                        }
                                      }
                                      *(unsigned char *)(v321 + 9) = av1_get_bits((uint64_t)&v440, 8u);
                                      v318 += 2;
                                    }
                                    while (v319 != v318);
                                  }
                                  uint64_t v322 = v439;
                                  if (*(_DWORD *)(v439 + 1084))
                                  {
                                    *(_DWORD *)(a6 + 36) = 0;
                                    v429 = (_DWORD *)(a6 + 36);
                                  }
                                  else
                                  {
                                    int v365 = av1_get_bits((uint64_t)&v440, 1u);
                                    *(_DWORD *)(a6 + 36) = v365 != 0;
                                    v429 = (_DWORD *)(a6 + 36);
                                    if (!v365
                                      && (*(_DWORD *)(v439 + 1080) != 1 || v317 || *(_DWORD *)(v439 + 1076) != 1))
                                    {
                                      uint64_t v401 = v12;
                                      uint64_t v402 = 0;
                                      char v403 = 1;
                                      while (1)
                                      {
                                        char v404 = v403;
                                        int v405 = av1_get_bits((uint64_t)&v440, 4u);
                                        *(_DWORD *)(a6 + 4 * v402 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v405;
                                        if (v405 > 10) {
                                          return 4294954584;
                                        }
                                        if (v405 >= 1) {
                                          break;
                                        }
LABEL_782:
                                        char v403 = 0;
                                        uint64_t v402 = 1;
                                        if ((v404 & 1) == 0)
                                        {
                                          uint64_t v12 = v401;
                                          uint64_t v322 = v439;
                                          goto LABEL_708;
                                        }
                                      }
                                      uint64_t v406 = 0;
                                      uint64_t v407 = v405;
                                      v408 = (unsigned char *)(a6 + 49 + 20 * v402);
                                      while (1)
                                      {
                                        unsigned __int8 v409 = av1_get_bits((uint64_t)&v440, 8u);
                                        *(v408 - 1) = v409;
                                        if (v406)
                                        {
                                          if (*(v408 - 3) >= v409) {
                                            return 4294954584;
                                          }
                                        }
                                        unsigned char *v408 = av1_get_bits((uint64_t)&v440, 8u);
                                        v408 += 2;
                                        if (++v406 >= v407) {
                                          goto LABEL_782;
                                        }
                                      }
                                    }
                                  }
                                  *(void *)(a6 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
LABEL_708:
                                  if (*(_DWORD *)(v322 + 1076) == 1
                                    && *(_DWORD *)(v322 + 1080) == 1
                                    && (*(_DWORD *)(a6 + 40) == 0) == (*(_DWORD *)(a6 + 44) != 0))
                                  {
                                    return 4294954584;
                                  }
                                  uint64_t v425 = v12;
                                  *(_DWORD *)(a6 + 88) = av1_get_bits((uint64_t)&v440, 2u) + 8;
                                  int v366 = av1_get_bits((uint64_t)&v440, 2u);
                                  *(_DWORD *)(a6 + 92) = v366;
                                  int v367 = v366 + v366 * v366;
                                  int v368 = 2 * v367;
                                  if (v317 && v368 > 0)
                                  {
                                    v369 = (unsigned char *)(a6 + 96);
                                    uint64_t v370 = (2 * v367);
                                    do
                                    {
                                      *v369++ = av1_get_bits((uint64_t)&v440, 8u) ^ 0x80;
                                      --v370;
                                    }
                                    while (v370);
                                  }
                                  uint64_t v371 = 0;
                                  char v372 = 1;
                                  do
                                  {
                                    char v373 = v372;
                                    if (*(_DWORD *)(a6 + 4 * v371 + 40) || *v429)
                                    {
                                      int v374 = *(_DWORD *)(a6 + 4);
                                      BOOL v375 = v374 != 0;
                                      int v376 = v368 | v375;
                                      if ((v368 | v375) >= 1)
                                      {
                                        v377 = (unsigned char *)(a6 + 120 + 28 * v371);
                                        uint64_t v378 = v368 | v375;
                                        do
                                        {
                                          *v377++ = av1_get_bits((uint64_t)&v440, 8u) ^ 0x80;
                                          --v378;
                                        }
                                        while (v378);
                                      }
                                      if (!v374) {
                                        *(unsigned char *)(a6 + 28 * v371 + v376 + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
                                      }
                                    }
                                    char v372 = 0;
                                    uint64_t v371 = 1;
                                  }
                                  while ((v373 & 1) != 0);
                                  *(void *)(a6 + 176) = av1_get_bits((uint64_t)&v440, 2u) + 6;
                                  int v379 = av1_get_bits((uint64_t)&v440, 2u);
                                  uint64_t v380 = 0;
                                  *(_DWORD *)(a6 + 184) = v379;
                                  char v381 = 1;
                                  uint64_t v12 = v425;
                                  LODWORD(v27) = v426;
                                  a7 = v432;
                                  do
                                  {
                                    char v382 = v381;
                                    v383 = (_DWORD *)(a6 + 4 * v380);
                                    if (v383[10])
                                    {
                                      v383[47] = av1_get_bits((uint64_t)&v440, 8u) - 128;
                                      v383[49] = av1_get_bits((uint64_t)&v440, 8u) - 128;
                                      v383[51] = av1_get_bits((uint64_t)&v440, 9u) - 256;
                                    }
                                    char v381 = 0;
                                    uint64_t v380 = 1;
                                  }
                                  while ((v382 & 1) != 0);
                                  *(_DWORD *)(a6 + 212) = av1_get_bits((uint64_t)&v440, 1u);
                                  *(_DWORD *)(a6 + 216) = av1_get_bits((uint64_t)&v440, 1u);
                                  int v25 = v430;
LABEL_537:
                                  *(void *)(v12 + 3328) = a6;
                                  *(_DWORD *)(a6 + 252) = v25;
                                  *(_DWORD *)(a6 + 256) = v435;
                                  *(_DWORD *)(a7 + 12) = 0;
                                  *(_DWORD *)(a7 + 16) = 0;
                                  if (v438 != 6)
                                  {
                                    av1_get_bits((uint64_t)&v440, 1u);
                                    uint64_t v18 = check_for_overrun(&v440, v433, uleb128);
                                    if (v18) {
                                      return v18;
                                    }
LABEL_541:
                                    int v29 = 0;
LABEL_770:
                                    unsigned int v26 = v433;
LABEL_820:
                                    if (!*(void *)(v12 + 3312)) {
                                      goto LABEL_829;
                                    }
                                    v420 = *(_DWORD **)(v12 + 3328);
                                    if (!v420) {
                                      goto LABEL_829;
                                    }
                                    if (v420[65]) {
                                      goto LABEL_823;
                                    }
                                    if (*(_DWORD *)(a7 + 16) == v420[139] * v420[135])
                                    {
                                      if (*(_DWORD *)(a7 + 12))
                                      {
                                        if (a9 == 1)
                                        {
                                          unsigned int v421 = v26;
                                          dav1d_submit_frame(v12);
                                          unsigned int v26 = v421;
                                        }
LABEL_823:
                                        *(void *)(v12 + 3328) = 0;
                                        goto LABEL_829;
                                      }
                                      v29 |= 0x40000000u;
                                    }
LABEL_829:
                                    if (*((void *)&v441 + 1)) {
                                      BOOL v422 = v18 == 0;
                                    }
                                    else {
                                      BOOL v422 = 0;
                                    }
                                    if (v422)
                                    {
                                      if (a10) {
                                        *a10 = uleb128 + (v26 >> 3);
                                      }
                                      uint64_t v18 = 0;
                                      if (a11) {
                                        *a11 |= v29;
                                      }
                                    }
                                    return v18;
                                  }
                                  if (*(_DWORD *)(a6 + 260))
                                  {
                                    int v29 = 0;
                                    uint64_t v18 = 0;
                                    *(void *)(v12 + 3328) = 0;
                                    unsigned int v26 = v433;
                                    goto LABEL_829;
                                  }
                                  unsigned int v263 = v441;
                                  LODWORD(v441) = 0;
                                  *((void *)&v440 + 1) = 0;
                                  unsigned int v26 = v433;
                                  if (v263 <= 7 && *(_DWORD *)(a6 + 556) * *(_DWORD *)(a6 + 540))
                                  {
                                    int v29 = 4;
LABEL_545:
                                    if ((a8 & 4) == 0)
                                    {
LABEL_546:
                                      uint64_t v18 = 0;
                                      goto LABEL_820;
                                    }
                                    v264 = *(_DWORD **)(v12 + 3328);
                                    if (v264)
                                    {
                                      int v265 = v27;
                                      int v266 = *(_DWORD *)(a7 + 12);
                                      if (v266)
                                      {
                                        unsigned int v267 = v26;
                                        int v268 = uleb128;
                                      }
                                      else
                                      {
                                        unsigned int v267 = v26;
                                        int v268 = uleb128;
                                        if (*(int *)(a7 + 8) < 1)
                                        {
                                          v272 = (char *)malloc_type_realloc(*(void **)a7, 0x48uLL, 0x1070040C633F987uLL);
                                          if (!v272) {
                                            return 4294954584;
                                          }
                                          *(void *)a7 = v272;
                                          v273 = &v272[72 * *(int *)(a7 + 12)];
                                          *((void *)v273 + 8) = 0;
                                          *((_OWORD *)v273 + 2) = 0u;
                                          *((_OWORD *)v273 + 3) = 0u;
                                          *(_OWORD *)v273 = 0u;
                                          *((_OWORD *)v273 + 1) = 0u;
                                          int v266 = *(_DWORD *)(a7 + 12);
                                          *(_DWORD *)(a7 + 8) = v266 + 1;
                                          v264 = *(_DWORD **)(v12 + 3328);
                                          if (!v264) {
                                            return 4294954584;
                                          }
                                        }
                                        else
                                        {
                                          int v266 = 0;
                                        }
                                      }
                                      int v274 = v264[139] * v264[135];
                                      int v275 = v274 - 1;
                                      if (v274 > 1 && av1_get_bits((uint64_t)&v440, 1u))
                                      {
                                        unsigned int v276 = v264[138] + v264[134];
                                        int v277 = av1_get_bits((uint64_t)&v440, v276);
                                        uint64_t v278 = *(void *)a7 + 72 * v266;
                                        *(_DWORD *)(v278 + 64) = v277;
                                        int v275 = av1_get_bits((uint64_t)&v440, v276);
                                        *(_DWORD *)(v278 + 68) = v275;
                                        int v279 = *(_DWORD *)(v278 + 64);
                                      }
                                      else
                                      {
                                        int v279 = 0;
                                        uint64_t v280 = *(void *)a7 + 72 * v266;
                                        *(_DWORD *)(v280 + 64) = 0;
                                        *(_DWORD *)(v280 + 68) = v275;
                                      }
                                      if (v279 > v275 || v279 != *(_DWORD *)(a7 + 16))
                                      {
                                        *(_DWORD *)(a7 + 12) = 0;
                                        *(_DWORD *)(a7 + 16) = 0;
                                      }
                                      unsigned int v281 = v441;
                                      LODWORD(v441) = 0;
                                      *((void *)&v440 + 1) = 0;
                                      if (v281 <= 7)
                                      {
                                        unsigned int v282 = v267;
                                        uint64_t v283 = check_for_overrun(&v440, v267, v268);
                                        if (v283) {
                                          return v283;
                                        }
                                        unsigned int v284 = 8 * (DWORD2(v441) - v442) - v441;
                                        if (v265 + v268 >= v284 >> 3)
                                        {
                                          unsigned int v285 = v284 >> 3;
                                          v286 = *(void **)a7;
                                          int v287 = *(_DWORD *)(a7 + 12);
                                          uint64_t v288 = *(void *)a7 + 72 * v287;
                                          *(void *)uint64_t v288 = *((void *)&v441 + 1);
                                          *(_DWORD *)(a7 + 16) += *(_DWORD *)(v288 + 68) - *(_DWORD *)(v288 + 64) + 1;
                                          *(void *)(v288 + 8) = v265 + v268 - v285;
                                          uint64_t v289 = (v287 + 1);
                                          *(_DWORD *)(a7 + 12) = v289;
                                          if ((v287 & 0x80000000) == 0)
                                          {
                                            uint64_t v290 = 0;
                                            int v291 = v285 + v434;
                                            do
                                            {
                                              v292 = (char *)&v286[9 * v290];
                                              uint64_t v293 = *((int *)v292 + 16);
                                              uint64_t v294 = *((int *)v292 + 17);
                                              if ((int)v293 <= (int)v294)
                                              {
                                                v296 = (unsigned __int8 *)v286[9 * v290];
                                                unint64_t v295 = v286[9 * v290 + 1];
                                                do
                                                {
                                                  if (v293 == v294)
                                                  {
                                                    *(void *)(a7 + 8 * v294 + 536) = v295;
                                                    uint64_t v297 = *(void *)(v12 + 3328);
                                                    unint64_t v298 = v295;
                                                  }
                                                  else
                                                  {
                                                    uint64_t v297 = *(void *)(v12 + 3328);
                                                    unint64_t v299 = *(unsigned int *)(v297 + 524);
                                                    BOOL v300 = v295 >= v299;
                                                    v295 -= v299;
                                                    if (!v300) {
                                                      return 4294954584;
                                                    }
                                                    if (v299)
                                                    {
                                                      int v301 = 0;
                                                      uint64_t v302 = 0;
                                                      uint64_t v303 = (v299 - 1);
                                                      v304 = v296;
                                                      do
                                                      {
                                                        int v305 = *v304++;
                                                        v302 |= (v305 << v301);
                                                        v301 += 8;
                                                        LODWORD(v299) = v299 - 1;
                                                      }
                                                      while (v299);
                                                      v296 += v303 + 1;
                                                    }
                                                    else
                                                    {
                                                      uint64_t v302 = 0;
                                                    }
                                                    unint64_t v298 = v302 + 1;
                                                    if (v298 > v295) {
                                                      return 4294954584;
                                                    }
                                                    *(void *)(a7 + 8 * v293 + 536) = v298;
                                                  }
                                                  if (v293 < 1)
                                                  {
                                                    uint64_t v307 = (v291 + *(_DWORD *)(v297 + 524));
                                                    uint64_t v308 = v293;
                                                  }
                                                  else
                                                  {
                                                    if (v293 == v294) {
                                                      uint64_t v306 = 0;
                                                    }
                                                    else {
                                                      uint64_t v306 = *(unsigned int *)(v297 + 524);
                                                    }
                                                    uint64_t v307 = *(void *)(a7 + 8 * (v293 - 1) + 536)
                                                         + *(void *)(a7 + 8 * (v293 - 1) + 24)
                                                         + v306;
                                                    uint64_t v308 = v293;
                                                  }
                                                  v296 += v298;
                                                  v295 -= v298;
                                                  *(void *)(a7 + 8 * v308 + 24) = v307;
                                                  ++v293;
                                                }
                                                while (v294 + 1 != v293);
                                              }
                                              ++v290;
                                            }
                                            while (v290 != v289);
                                          }
                                          uint64_t v18 = 0;
                                          v29 |= 8u;
                                          unsigned int v26 = v282;
                                          goto LABEL_820;
                                        }
                                        uint64_t v18 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
                                        unsigned int v26 = v282;
                                        goto LABEL_829;
                                      }
                                    }
                                  }
                                  return 4294954584;
                                }
                              }
                              else
                              {
                                *(_DWORD *)(a6 + 224) = 0;
                                LODWORD(v27) = v426;
                              }
                              *(_OWORD *)(a6 + 192) = 0u;
                              *(_OWORD *)(a6 + 208) = 0u;
                              *(_OWORD *)(a6 + 16CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
                              *(_OWORD *)(a6 + 176) = 0u;
                              *(_OWORD *)(a6 + 128) = 0u;
                              *(_OWORD *)(a6 + 144) = 0u;
                              *(_OWORD *)(a6 + 96) = 0u;
                              *(_OWORD *)(a6 + 112) = 0u;
                              *(_OWORD *)(a6 + 64) = 0u;
                              *(_OWORD *)(a6 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
                              *(_OWORD *)(a6 + 32) = 0u;
                              *(_OWORD *)(a6 + 48) = 0u;
                              *(_OWORD *)a6 = 0u;
                              *(_OWORD *)(a6 + 16) = 0u;
                              goto LABEL_537;
                            }
LABEL_454:
                            *(_DWORD *)(a6 + 1372) = 0;
                            *(void *)(a6 + 1376) = 0;
                            goto LABEL_455;
                          }
                          if (1 << v323 <= 1) {
                            uint64_t v324 = 1;
                          }
                          else {
                            uint64_t v324 = (1 << v323);
                          }
                          v325 = (_DWORD *)(a6 + 1340);
                          do
                          {
                            *(v325 - 8) = av1_get_bits((uint64_t)&v440, 6u);
                            if (!v218[271]) {
                              _DWORD *v325 = av1_get_bits((uint64_t)&v440, 6u);
                            }
                            ++v325;
                            --v324;
                          }
                          while (v324);
LABEL_450:
                          if (v227 && !*(_DWORD *)(a6 + 456)) {
                            goto LABEL_454;
                          }
                          goto LABEL_452;
                        }
LABEL_449:
                        *(void *)(a6 + 1304) = 0;
                        *(_DWORD *)(a6 + 134CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
                        goto LABEL_450;
                      }
                      int v314 = 8;
                      do
                      {
                        if (av1_get_bits((uint64_t)&v440, 1u)) {
                          av1_get_bits((uint64_t)&v440, 7u);
                        }
                        --v314;
                      }
                      while (v314);
                      char v315 = 1;
                      do
                      {
                        char v316 = v315;
                        if (av1_get_bits((uint64_t)&v440, 1u)) {
                          av1_get_bits((uint64_t)&v440, 7u);
                        }
                        char v315 = 0;
                      }
                      while ((v316 & 1) != 0);
                    }
                    if (v227) {
                      goto LABEL_449;
                    }
                    goto LABEL_447;
                  }
LABEL_427:
                  *(_DWORD *)(a6 + 1216) = 0;
                  long long v218 = (_DWORD *)v439;
                  goto LABEL_428;
                }
LABEL_426:
                *(_DWORD *)(a6 + 1212) = 0;
                goto LABEL_427;
              }
LABEL_425:
              *(_DWORD *)(a6 + 1208) = 0;
              goto LABEL_426;
            }
          }
          uint64_t v206 = 0;
          *(void *)(a6 + 1136) = 0xFFFFFFFF00000000;
          int v207 = (_DWORD *)(a6 + 908);
          do
          {
            if (av1_get_bits((uint64_t)&v440, 1u))
            {
              int v208 = (int)(av1_get_bits((uint64_t)&v440, 9u) << 23) >> 23;
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
            }
            else
            {
              int v208 = 0;
            }
            *(v207 - 7) = v208;
            if (av1_get_bits((uint64_t)&v440, 1u))
            {
              int v209 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
            }
            else
            {
              int v209 = 0;
            }
            *(v207 - 6) = v209;
            if (av1_get_bits((uint64_t)&v440, 1u))
            {
              int v210 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
            }
            else
            {
              int v210 = 0;
            }
            *(v207 - 5) = v210;
            if (av1_get_bits((uint64_t)&v440, 1u))
            {
              int v211 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
            }
            else
            {
              int v211 = 0;
            }
            *(v207 - 4) = v211;
            if (av1_get_bits((uint64_t)&v440, 1u))
            {
              int v212 = (int)(av1_get_bits((uint64_t)&v440, 7u) << 25) >> 25;
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
            }
            else
            {
              int v212 = 0;
            }
            *(v207 - 3) = v212;
            if (av1_get_bits((uint64_t)&v440, 1u))
            {
              int v213 = av1_get_bits((uint64_t)&v440, 3u);
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
              *(_DWORD *)(a6 + 1136) = 1;
            }
            else
            {
              int v213 = -1;
            }
            *(v207 - 2) = v213;
            int v214 = av1_get_bits((uint64_t)&v440, 1u);
            *(v207 - 1) = v214;
            if (v214)
            {
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
              *(_DWORD *)(a6 + 1136) = 1;
            }
            int v215 = av1_get_bits((uint64_t)&v440, 1u);
            *int v207 = v215;
            if (v215)
            {
              *(_DWORD *)(a6 + 114CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v206;
              *(_DWORD *)(a6 + 1136) = 1;
            }
            ++v206;
            v207 += 8;
          }
          while (v206 != 8);
        }
        else
        {
          uint64_t v203 = 0;
          *(void *)(a6 + 1136) = 0;
          *(_OWORD *)(a6 + 112CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
          *(_OWORD *)(a6 + 1104) = 0u;
          *(_OWORD *)(a6 + 1088) = 0u;
          *(_OWORD *)(a6 + 1072) = 0u;
          *(_OWORD *)(a6 + 1056) = 0u;
          *(_OWORD *)(a6 + 104CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
          *(_OWORD *)(a6 + 1008) = 0u;
          *(_OWORD *)(a6 + 1024) = 0u;
          *(_OWORD *)(a6 + 976) = 0u;
          *(_OWORD *)(a6 + 992) = 0u;
          *(_OWORD *)(a6 + 944) = 0u;
          *(_OWORD *)(a6 + 96CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
          *(_OWORD *)(a6 + 912) = 0u;
          *(_OWORD *)(a6 + 928) = 0u;
          *(_OWORD *)(a6 + 88CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
          *(_OWORD *)(a6 + 896) = 0u;
          do
          {
            *(_DWORD *)(a6 + 900 + v203) = -1;
            v203 += 32;
          }
          while (v203 != 256);
        }
        if (v187) {
          goto LABEL_419;
        }
        goto LABEL_425;
      }
      *(_DWORD *)(a6 + 464) = 0;
      uint64_t v12 = v62;
      if (v70 == 3) {
        int v75 = 255;
      }
      else {
        int v75 = av1_get_bits((uint64_t)&v440, 8u);
      }
      *(_DWORD *)(a6 + 44CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v75;
      if (v38)
      {
        if (!v60) {
          goto LABEL_204;
        }
        unsigned int v76 = *(_DWORD *)(v439 + 1060);
        int v77 = 8;
        do
        {
          av1_get_bits((uint64_t)&v440, v76);
          --v77;
        }
        while (v77);
      }
      if (v60)
      {
        int v78 = av1_get_bits((uint64_t)&v440, 1u);
        BOOL v79 = v78 != 0;
        *(_DWORD *)(a6 + 468) = v79;
        if (v78)
        {
          int v80 = av1_get_bits((uint64_t)&v440, 3u);
          *(_DWORD *)(a6 + 472) = v80;
          *(void *)(a6 + 476) = -1;
          int v81 = av1_get_bits((uint64_t)&v440, 3u);
          uint64_t v82 = 0;
          *(_DWORD *)(a6 + 484) = v81;
          *(_DWORD *)(a6 + 496) = -1;
          *(void *)(a6 + 488) = -1;
          double v83 = (_DWORD *)v439;
          int v84 = *(_DWORD *)(v439 + 1060);
          int v85 = 1 << (v84 - 1);
          int v86 = (_DWORD *)(v62 + 3440);
          do
          {
            if (!*((void *)v86 - 1)) {
              return 4294954584;
            }
            if (v84) {
              int v87 = ((*v86 - v61) & (v85 - 1)) - ((*v86 - v61) & v85);
            }
            else {
              int v87 = 0;
            }
            *(_DWORD *)((char *)&v446 + v82) = v87 + v85;
            v82 += 4;
            v86 += 82;
          }
          while (v82 != 32);
          uint64_t v88 = 0;
          long long v443 = 0u;
          long long v444 = 0u;
          *((_DWORD *)&v443 + v8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
          *((_DWORD *)&v443 + v81) = 1;
          int v89 = -1;
          int v90 = -1;
          do
          {
            int v91 = *((_DWORD *)&v446 + v88);
            if (*((_DWORD *)&v443 + v88)) {
              BOOL v92 = 1;
            }
            else {
              BOOL v92 = v91 < v85;
            }
            if (!v92 && v91 >= v90)
            {
              *(_DWORD *)(a6 + 496) = v88;
              int v89 = v88;
              int v90 = v91;
            }
            ++v88;
          }
          while (v88 != 8);
          if (v90 != -1) {
            *((_DWORD *)&v443 + v89) = 1;
          }
          uint64_t v94 = 0;
          int v95 = 0x7FFFFFFF;
          int v96 = -1;
          do
          {
            int v97 = *((_DWORD *)&v446 + v94);
            if (*((_DWORD *)&v443 + v94)) {
              BOOL v98 = 1;
            }
            else {
              BOOL v98 = v97 < v85;
            }
            if (!v98 && v97 < v95)
            {
              *(_DWORD *)(a6 + 488) = v94;
              int v96 = v94;
              int v95 = v97;
            }
            ++v94;
          }
          while (v94 != 8);
          if (v95 != 0x7FFFFFFF) {
            *((_DWORD *)&v443 + v96) = 1;
          }
          uint64_t v100 = 0;
          int v101 = 0x7FFFFFFF;
          int v102 = -1;
          do
          {
            int v103 = *((_DWORD *)&v446 + v100);
            if (*((_DWORD *)&v443 + v100)) {
              BOOL v104 = 1;
            }
            else {
              BOOL v104 = v103 < v85;
            }
            if (!v104 && v103 < v101)
            {
              *(_DWORD *)(a6 + 492) = v100;
              int v102 = v100;
              int v101 = v103;
            }
            ++v100;
          }
          while (v100 != 8);
          if (v101 != 0x7FFFFFFF) {
            *((_DWORD *)&v443 + v102) = 1;
          }
          for (uint64_t n = 1; n != 7; ++n)
          {
            uint64_t v107 = a6 + 4 * n;
            int v108 = *(_DWORD *)(v107 + 472);
            if (v108 < 0)
            {
              uint64_t v109 = 0;
              char v110 = (_DWORD *)(v107 + 472);
              int v111 = -1;
              do
              {
                int v112 = *((_DWORD *)&v446 + v109);
                if (*((_DWORD *)&v443 + v109)) {
                  BOOL v113 = 0;
                }
                else {
                  BOOL v113 = v112 < v85;
                }
                if (v113 && v112 >= v111)
                {
                  *char v110 = v109;
                  int v108 = v109;
                  int v111 = v112;
                }
                ++v109;
              }
              while (v109 != 8);
              if (v111 != -1) {
                *((_DWORD *)&v443 + v108) = 1;
              }
            }
          }
          uint64_t v115 = 0;
          int v116 = 0x7FFFFFFF;
          int v117 = -1;
          do
          {
            if (*((_DWORD *)&v446 + v115) < v116)
            {
              int v116 = *((_DWORD *)&v446 + v115);
              int v117 = v115;
            }
            ++v115;
          }
          while (v115 != 8);
          uint64_t v118 = 0;
          uint64_t v119 = a6 + 472;
          do
          {
            if ((*(_DWORD *)(v119 + v118) & 0x80000000) != 0) {
              *(_DWORD *)(v119 + v118) = v117;
            }
            v118 += 4;
          }
          while (v118 != 28);
LABEL_233:
          for (iuint64_t i = 472; ii != 500; ii += 4)
          {
            if (!v79) {
              *(_DWORD *)(a6 + ii) = av1_get_bits((uint64_t)&v440, 3u);
            }
            if (v83[250])
            {
              int v134 = av1_get_bits((uint64_t)&v440, v83[251]);
              uint64_t v135 = *(void *)(v62 + 328 * *(int *)(a6 + ii) + 3432);
              if (!v135
                || *(_DWORD *)(v135 + 268) != ((*(_DWORD *)(a6 + 268) + (1 << v83[252]) + ~v134) & ((1 << v83[252]) - 1)))
              {
                return 4294954584;
              }
            }
          }
          if (v424) {
            int v136 = v69;
          }
          else {
            int v136 = 0;
          }
          read_frame_size(v62, (uint64_t)&v440, (_DWORD *)a6, v83, v136);
          if (*(_DWORD *)(a6 + 296)) {
            BOOL v137 = 0;
          }
          else {
            BOOL v137 = av1_get_bits((uint64_t)&v440, 1u) != 0;
          }
          *(_DWORD *)(a6 + 50CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v137;
          if (av1_get_bits((uint64_t)&v440, 1u)) {
            int v138 = 4;
          }
          else {
            int v138 = av1_get_bits((uint64_t)&v440, 2u);
          }
          *(_DWORD *)(a6 + 504) = v138;
          *(_DWORD *)(a6 + 508) = av1_get_bits((uint64_t)&v440, 1u);
          if (!*(_DWORD *)(a6 + 284))
          {
            int v125 = v83[262];
            if (!v125) {
              goto LABEL_251;
            }
            int v125 = v83[260];
            if (!v125) {
              goto LABEL_251;
            }
            if (*(unsigned char *)v428)
            {
              int v125 = av1_get_bits((uint64_t)&v440, 1u) != 0;
              goto LABEL_251;
            }
          }
          int v125 = 0;
          goto LABEL_251;
        }
        BOOL v79 = 0;
LABEL_232:
        double v83 = (_DWORD *)v439;
        goto LABEL_233;
      }
LABEL_204:
      BOOL v79 = 0;
      *(_DWORD *)(a6 + 468) = 0;
      goto LABEL_232;
    default:
      uint64_t v18 = 0;
      int v29 = 0x40000000;
      goto LABEL_820;
  }
}

uint64_t FigAV1Bridge_Getav1CStartAndLength(const __CFData *a1, const UInt8 **a2, unint64_t *a3)
{
  if (a1 && (BytePtr = CFDataGetBytePtr(a1), unint64_t Length = CFDataGetLength(a1), Length > 3))
  {
    if (a2) {
      *a2 = BytePtr;
    }
    if (a3) {
      *a3 = Length;
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAV1Bridge_GetSeqOBU_VUI_NCLC(char *a1, unint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v18 = 0;
  memset(v17, 0, sizeof(v17));
  if (!a1 || a2 <= 3)
  {
    uint64_t v6 = 4294954584;
LABEL_4:
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v6 = 4294954583;
    goto LABEL_4;
  }
  int v13 = (_DWORD *)Instance;
  int v16 = 0;
  uint64_t v14 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v16, &v18, (unsigned int *)v17);
  if (v14)
  {
    uint64_t v15 = v14;
  }
  else if ((v18 & 2) != 0)
  {
    if (a3) {
      *a3 = v13[8];
    }
    if (a4) {
      *a4 = v13[9];
    }
    uint64_t v15 = 0;
    if (a5) {
      *a5 = v13[10];
    }
  }
  else
  {
    uint64_t v15 = 4294954584;
  }
  CFRelease(v13);
  return v15;
}

uint64_t FigAV1Bridge_GetSeqOBU_VUI_AspectRatio(char *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v16 = 0;
  memset(v15, 0, sizeof(v15));
  if (!a1 || a2 <= 3)
  {
    uint64_t v5 = 4294954584;
LABEL_4:
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v5 = 4294954583;
    goto LABEL_4;
  }
  uint64_t v11 = (_DWORD *)Instance;
  int v14 = 0;
  uint64_t v12 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v14, &v16, (unsigned int *)v15);
  if (v12)
  {
    uint64_t v13 = v12;
  }
  else if ((v16 & 4) != 0)
  {
    if (a3) {
      *a3 = v11[435] * v11[487];
    }
    uint64_t v13 = 0;
    if (a4) {
      *a4 = v11[437] * v11[488];
    }
  }
  else
  {
    uint64_t v13 = 4294954584;
  }
  CFRelease(v11);
  return v13;
}

uint64_t FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence(uint64_t a1, unint64_t a2, CFIndex *a3, CFDataRef *a4)
{
  int v21 = 0;
  if (!a1) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  unint64_t v4 = a2;
  if (!a2) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  if (!a4) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  uint64_t v7 = a1;
  if (a3) {
    *a3 = 0;
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFTypeID v9 = (void *)Instance;
  if (!Instance)
  {
LABEL_27:
    uint64_t v12 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  int v10 = 0;
  *(void *)(Instance + 6584) = 0;
  do
  {
    unsigned int v20 = 0;
    uint64_t v11 = FigAV1Bridge_parseOBU(v7, v4, v10, (uint64_t)(v9 + 398), (uint64_t)(v9 + 2), (uint64_t)(v9 + 188), 0, 80, 0, &v20, &v21);
    if (v11)
    {
      uint64_t v12 = v11;
      goto LABEL_24;
    }
    if (v4 < v20) {
      break;
    }
    if (!v20)
    {
      uint64_t v12 = 4294954582;
      goto LABEL_24;
    }
    if ((v21 & 0x40) != 0) {
      break;
    }
    v7 += v20;
    v10 += v20;
    v4 -= v20;
  }
  while (v4);
  uint64_t v12 = 0;
  CFIndex v13 = v9[821];
  if (v13)
  {
    if (a3)
    {
      *a3 = v13;
      CFIndex v13 = v9[821];
      if (!v13)
      {
        uint64_t v12 = 0;
        goto LABEL_24;
      }
    }
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v15 = (const UInt8 *)v9[823];
    GlobalCFAllocatorFigMCFAllocatorRef alloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    CFDataRef v17 = CFDataCreateWithBytesNoCopy(v14, v15, v13, GlobalCFAllocatorFigMalloc);
    if (v17)
    {
      uint64_t v12 = 0;
      v9[823] = 0;
      *a4 = v17;
      goto LABEL_24;
    }
    goto LABEL_27;
  }
LABEL_24:
  int v18 = (void *)v9[823];
  if (v18)
  {
    v9[823] = 0;
    free(v18);
  }
  CFRelease(v9);
  return v12;
}

uint64_t FigAV1Bridge_CopyITU_T_T35MetadataHDR10PlusMetadata(uint64_t a1, unint64_t a2, CFDataRef *a3)
{
  int v19 = 0;
  if (!a1) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  unint64_t v3 = a2;
  if (!a2) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  if (!a3) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  uint64_t v5 = a1;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v7 = (void *)Instance;
  if (!Instance)
  {
LABEL_22:
    uint64_t v10 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  int v8 = 0;
  *(void *)(Instance + 6584) = 0;
  do
  {
    unsigned int v18 = 0;
    uint64_t v9 = FigAV1Bridge_parseOBU(v5, v3, v8, (uint64_t)(v7 + 398), (uint64_t)(v7 + 2), (uint64_t)(v7 + 188), 0, 144, 0, &v18, &v19);
    if (v9)
    {
      uint64_t v10 = v9;
      goto LABEL_19;
    }
    if (v3 < v18) {
      break;
    }
    if (!v18)
    {
      uint64_t v10 = 4294954582;
      goto LABEL_19;
    }
    if ((v19 & 0x80) != 0) {
      break;
    }
    v5 += v18;
    v8 += v18;
    v3 -= v18;
  }
  while (v3);
  uint64_t v10 = 0;
  CFIndex v11 = v7[821];
  if (v11)
  {
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v13 = (const UInt8 *)v7[823];
    GlobalCFAllocatorFigMCFAllocatorRef alloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    CFDataRef v15 = CFDataCreateWithBytesNoCopy(v12, v13, v11, GlobalCFAllocatorFigMalloc);
    if (v15)
    {
      uint64_t v10 = 0;
      v7[823] = 0;
      *a3 = v15;
      goto LABEL_19;
    }
    goto LABEL_22;
  }
LABEL_19:
  int v16 = (void *)v7[823];
  if (v16)
  {
    v7[823] = 0;
    free(v16);
  }
  CFRelease(v7);
  return v10;
}

uint64_t FigAV1Bridge_CopyCLLIDataFromAV1ConfigurationRecordConfigOBU(const __CFData *a1, CFDataRef *a2)
{
  int v19 = 0;
  if (!a1) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  if (!Length) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  if (!a2) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  unint64_t v6 = Length;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  int v8 = (void *)Instance;
  if (Instance)
  {
    int v9 = 0;
    *(void *)(Instance + 6528) = 0;
    do
    {
      unsigned int v18 = 0;
      uint64_t v10 = FigAV1Bridge_parseOBU((uint64_t)BytePtr, v6, v9, (uint64_t)(v8 + 398), (uint64_t)(v8 + 2), (uint64_t)(v8 + 188), 0, 274, 0, &v18, &v19);
      if (v10)
      {
        uint64_t v11 = v10;
LABEL_19:
        *a2 = 0;
        goto LABEL_20;
      }
      if (v6 < v18) {
        break;
      }
      if (!v18)
      {
        uint64_t v11 = 4294954582;
        goto LABEL_19;
      }
      if ((v19 & 0x100) != 0) {
        break;
      }
      BytePtr += v18;
      v9 += v18;
      v6 -= v18;
    }
    while (v6);
    uint64_t v11 = 0;
    CFAllocatorRef v12 = (const UInt8 *)v8[816];
    if (!v12) {
      goto LABEL_19;
    }
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    GlobalCFAllocatorFigMCFAllocatorRef alloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    CFDataRef v15 = CFDataCreateWithBytesNoCopy(v13, v12, 4, GlobalCFAllocatorFigMalloc);
    if (!v15) {
      goto LABEL_23;
    }
    uint64_t v11 = 0;
    v8[816] = 0;
    *a2 = v15;
  }
  else
  {
LABEL_23:
    uint64_t v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
LABEL_20:
  int v16 = (void *)v8[816];
  if (v16)
  {
    v8[816] = 0;
    free(v16);
  }
  CFRelease(v8);
  return v11;
}

uint64_t FigAV1Bridge_CopyMDCVDataFromAV1ConfigurationRecordConfigOBU(const __CFData *a1, CFDataRef *a2)
{
  int v19 = 0;
  if (!a1) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  if (!Length) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  if (!a2) {
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  }
  unint64_t v6 = Length;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1) {
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  int v8 = (void *)Instance;
  if (Instance)
  {
    int v9 = 0;
    *(void *)(Instance + 6544) = 0;
    do
    {
      unsigned int v18 = 0;
      uint64_t v10 = FigAV1Bridge_parseOBU((uint64_t)BytePtr, v6, v9, (uint64_t)(v8 + 398), (uint64_t)(v8 + 2), (uint64_t)(v8 + 188), 0, 530, 0, &v18, &v19);
      if (v10)
      {
        uint64_t v11 = v10;
LABEL_19:
        *a2 = 0;
        goto LABEL_20;
      }
      if (v6 < v18) {
        break;
      }
      if (!v18)
      {
        uint64_t v11 = 4294954582;
        goto LABEL_19;
      }
      if ((v19 & 0x200) != 0) {
        break;
      }
      BytePtr += v18;
      v9 += v18;
      v6 -= v18;
    }
    while (v6);
    uint64_t v11 = 0;
    CFAllocatorRef v12 = (const UInt8 *)v8[818];
    if (!v12) {
      goto LABEL_19;
    }
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    GlobalCFAllocatorFigMCFAllocatorRef alloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    CFDataRef v15 = CFDataCreateWithBytesNoCopy(v13, v12, 24, GlobalCFAllocatorFigMalloc);
    if (!v15) {
      goto LABEL_23;
    }
    uint64_t v11 = 0;
    v8[818] = 0;
    *a2 = v15;
  }
  else
  {
LABEL_23:
    uint64_t v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
LABEL_20:
  int v16 = (void *)v8[818];
  if (v16)
  {
    v8[818] = 0;
    free(v16);
  }
  CFRelease(v8);
  return v11;
}

void FigAV1BridgeParsingState_Init(uint64_t a1)
{
}

__CFString *FigAV1BridgeParsingState_CopyDebugDesc(uint64_t a1)
{
  CFMutableSetRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, @"FigAV1BridgeParsingState %p", a1);
  return Mutable;
}

unint64_t av1_get_bits(uint64_t a1, unsigned int a2)
{
  if (a2 - 33 >= 0xFFFFFFE0)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 16);
    if (v4 >= a2)
    {
      int v3 = 0;
    }
    else if (v4 > 0x38)
    {
      int v3 = -12714;
    }
    else
    {
      uint64_t v5 = 0;
      unint64_t v6 = *(void *)(a1 + 40);
      int v7 = *(_DWORD *)(a1 + 4);
      int v8 = *(unsigned __int8 **)(a1 + 24);
      do
      {
        v5 <<= 8;
        v4 += 8;
        *(_DWORD *)(a1 + 16) = v4;
        if (!v7)
        {
          *(void *)(a1 + 24) = v8 + 1;
          v5 |= *v8++;
        }
        if ((unint64_t)v8 >= v6)
        {
          *(_DWORD *)a1 = v7;
          int v7 = 1;
          *(_DWORD *)(a1 + 4) = 1;
        }
      }
      while (v4 < a2);
      int v3 = 0;
      *(void *)(a1 + 8) |= v5 << -(char)v4;
    }
    unint64_t v9 = *(void *)(a1 + 8);
    *(_DWORD *)(a1 + 16) = v4 - a2;
    *(void *)(a1 + 8) = v9 << a2;
    unint64_t v2 = v9 >> -(char)a2;
  }
  else
  {
    unint64_t v2 = 0;
    int v3 = -12714;
  }
  *(_DWORD *)a1 = v3;
  return v2;
}

unint64_t av1_get_uleb128(_DWORD *a1)
{
  unint64_t v2 = 0;
  unint64_t v3 = 0;
  do
  {
    char bits = av1_get_bits((uint64_t)a1, 8u);
    v3 |= (unint64_t)(bits & 0x7F) << v2;
    if ((bits & 0x80) == 0) {
      break;
    }
    BOOL v5 = v2 >= 0x31;
    v2 += 7;
  }
  while (!v5);
  if (bits < 0 || HIDWORD(v3)) {
    *a1 = -12714;
  }
  return v3;
}

uint64_t check_for_overrun(_DWORD *a1, unsigned int a2, int a3)
{
  if (*a1) {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v3 = 8 * (a1[6] - a1[8]) - a1[4];
  BOOL v4 = v3 >= a2;
  unsigned int v5 = v3 - a2;
  if (!v4) {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  if (v5 <= 8 * a3) {
    return 0;
  }
  return 4294954584;
}

uint64_t dav1d_submit_frame(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 3312);
  uint64_t v3 = *(void *)(a1 + 3304) + 40;
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *(void *)(a1 + 3328);
  uint64_t v5 = *(void *)(a1 + 3320);
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v4;
  unint64_t v6 = (_OWORD *)(a1 + 2264);
  if (picture_alloc_with_edges(a1 + 2264, *(_DWORD *)(v4 + 240), *(_DWORD *)(v4 + 244), v2, v3, v4, v5, *(void *)(a1 + 3336), *(void *)(a1 + 3352), a1 + 3376, *(void *)(a1 + 3368), 2 * *(_DWORD *)(v2 + 32) + 8))
  {
LABEL_2:
    for (uint64_t i = 0; i != 1960; i += 280)
    {
      if (*(void *)(a1 + i + 56)) {
        dav1d_picture_unref_internal((_OWORD *)(a1 + i + 32));
      }
    }
    *(_OWORD *)(a1 + 2232) = 0u;
    *(_OWORD *)(a1 + 2248) = 0u;
    *(_OWORD *)(a1 + 220CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
    *(_OWORD *)(a1 + 2216) = 0u;
    *(_OWORD *)(a1 + 2168) = 0u;
    *(_OWORD *)(a1 + 2184) = 0u;
    *(_OWORD *)(a1 + 2136) = 0u;
    *(_OWORD *)(a1 + 2152) = 0u;
    *(_OWORD *)(a1 + 2104) = 0u;
    *(_OWORD *)(a1 + 212CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
    *(_OWORD *)(a1 + 2072) = 0u;
    *(_OWORD *)(a1 + 2088) = 0u;
    *(_OWORD *)(a1 + 204CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0u;
    *(_OWORD *)(a1 + 2056) = 0u;
    *(_OWORD *)(a1 + 2008) = 0u;
    *(_OWORD *)(a1 + 2024) = 0u;
    *(_OWORD *)(a1 + 1992) = 0u;
    uint64_t result = (uint64_t)dav1d_picture_unref_internal(v6);
    *(_DWORD *)(a1 + 2948) = 0;
    return result;
  }
  *(void *)(a1 + 340CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  *(_DWORD *)(a1 + 254CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_DWORD *)(a1 + 6056);
  *(_DWORD *)(a1 + 6056) = 0;
  unint64_t v9 = *(_DWORD **)(a1 + 24);
  *(_DWORD *)(a1 + 2536) = v9[69];
  int v10 = v9[59];
  uint64_t v11 = (void *)(a1 + 1992);
  if (v10 == v9[60])
  {
    uint64_t result = dav1d_picture_ref(v11, v6);
    if (result) {
      goto LABEL_2;
    }
  }
  else
  {
    uint64_t result = picture_alloc_with_edges((uint64_t)v11, v10, *(_DWORD *)(a1 + 2332), *(void *)(a1 + 2264), *(void *)(a1 + 2456), *(void *)(a1 + 2272), *(void *)(a1 + 2448), *(void *)(a1 + 2464), *(void *)(a1 + 2472), *(void *)(a1 + 2408), *(void *)(a1 + 2480), *(_DWORD *)(a1 + 2340));
    if (result) {
      goto LABEL_2;
    }
  }
  uint64_t v12 = 0;
  char v13 = 0;
  CFAllocatorRef v14 = *(_DWORD **)(a1 + 24);
  *(_DWORD *)(a1 + 3096) = (v14[59] + 3) >> 2;
  int v15 = v14[61];
  *(_DWORD *)(a1 + 310CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = (v15 + 3) >> 2;
  signed int v16 = ((v14[59] + 7) >> 2) & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 3104) = v16;
  unsigned int v17 = ((v15 + 7) >> 2) & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 3108) = v17;
  v16 += 31;
  *(_DWORD *)(a1 + 3112) = v16 >> 5;
  *(_DWORD *)(a1 + 3116) = (int)(v17 + 31) >> 5;
  int v18 = *(_DWORD *)(*(void *)(a1 + 8) + 1012);
  int v19 = 16 << v18;
  *(_DWORD *)(a1 + 3128) = 16 << v18;
  v18 += 4;
  *(_DWORD *)(a1 + 3124) = v18;
  *(_DWORD *)(a1 + 312CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = (int)(v17 + v19 - 1) >> v18;
  *(void *)(a1 + 3088) = (int)(v16 & 0xFFFFFFE0);
  *(_DWORD *)(a1 + 3288) = ~(-1 << *(_DWORD *)(a1 + 2068));
  unsigned int v20 = v14[110];
  do
  {
    if ((v20 >> v13))
    {
      if (*(void *)(a1 + v12 + 3448)) {
        dav1d_picture_unref_internal((_OWORD *)(a1 + v12 + 3424));
      }
      uint64_t result = dav1d_picture_ref((void *)(a1 + v12 + 3424), v6);
      *(void *)(a1 + v12 + 3696) = *(void *)(a1 + 2536);
      uint64_t v21 = *(void *)(a1 + 24);
      if (v21) {
        *(_DWORD *)(a1 + v12 + 344CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_DWORD *)(*(void *)(a1 + 3328) + 248);
      }
      uint64_t v22 = a1 + v12;
      *(void *)(a1 + v12 + 3704) = *(void *)(a1 + 2672);
      if (!*(_DWORD *)(v21 + 464)) {
        *(void *)(v22 + 3712) = *(void *)(a1 + 2544);
      }
      *(_OWORD *)(v22 + 372CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)(a1 + 2704);
      *(_OWORD *)(v22 + 3732) = *(_OWORD *)(a1 + 2716);
    }
    ++v13;
    v12 += 328;
  }
  while (v12 != 2624);
  return result;
}

unint64_t read_frame_size(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int a5)
{
  if (a5)
  {
    uint64_t v9 = 472;
    while (1)
    {
      unint64_t result = av1_get_bits(a2, 1u);
      if (result) {
        break;
      }
      v9 += 4;
      if (v9 == 500) {
        goto LABEL_5;
      }
    }
    uint64_t v12 = a1 + 328 * *(int *)(*(void *)(a1 + 3328) + v9);
    int v13 = *(_DWORD *)(v12 + 3488);
    a3[60] = v13;
    a3[61] = *(_DWORD *)(v12 + 3492);
    uint64_t v14 = *(void *)(v12 + 3432);
    a3[111] = *(_DWORD *)(v14 + 444);
    a3[112] = *(_DWORD *)(v14 + 448);
    if (a4[266])
    {
      unint64_t result = av1_get_bits(a2, 1u);
      a3[114] = result != 0;
      if (result)
      {
        unint64_t result = av1_get_bits(a2, 3u);
        a3[113] = result + 9;
        int v15 = a3[60];
        int v13 = (8 * v15 + (((int)result + 9) >> 1)) / ((int)result + 9);
        if (v15 >= 16) {
          int v15 = 16;
        }
        if (v13 <= v15) {
          int v13 = v15;
        }
        goto LABEL_28;
      }
      int v13 = a3[60];
    }
    else
    {
      a3[114] = 0;
    }
    a3[113] = 8;
LABEL_28:
    a3[59] = v13;
    return result;
  }
LABEL_5:
  if (a3[75])
  {
    a3[60] = av1_get_bits(a2, a4[248]) + 1;
    int v11 = av1_get_bits(a2, a4[249]) + 1;
  }
  else
  {
    a3[60] = a4[1];
    int v11 = a4[2];
  }
  a3[61] = v11;
  if (a4[266])
  {
    int bits = av1_get_bits(a2, 1u);
    a3[114] = bits != 0;
    if (bits)
    {
      int v17 = av1_get_bits(a2, 3u);
      a3[113] = v17 + 9;
      int v18 = a3[60];
      int v19 = (8 * v18 + ((v17 + 9) >> 1)) / (v17 + 9);
      if (v18 >= 16) {
        int v18 = 16;
      }
      if (v19 <= v18) {
        int v19 = v18;
      }
      goto LABEL_22;
    }
  }
  else
  {
    a3[114] = 0;
  }
  a3[113] = 8;
  int v19 = a3[60];
LABEL_22:
  a3[59] = v19;
  unint64_t result = av1_get_bits(a2, 1u);
  a3[115] = result;
  if (result)
  {
    a3[111] = av1_get_bits(a2, 0x10u) + 1;
    unint64_t result = av1_get_bits(a2, 0x10u);
    a3[112] = result + 1;
  }
  else
  {
    *(void *)(a3 + 111) = *((void *)a3 + 30);
  }
  return result;
}

unint64_t av1_get_uniform(_DWORD *a1, unsigned int a2)
{
  if (a2 <= 1)
  {
    unint64_t bits = 0;
    *a1 = -12714;
  }
  else
  {
    unsigned int v3 = __clz(a2);
    unsigned int v4 = (1 << -(char)v3) - a2;
    unint64_t bits = av1_get_bits((uint64_t)a1, v3 ^ 0x1F);
    if (bits >= v4) {
      return av1_get_bits((uint64_t)a1, 1u) - v4 + 2 * bits;
    }
  }
  return bits;
}

uint64_t av1_get_bits_subexp(_DWORD *a1, int a2, char a3)
{
  int v4 = 1 << a3;
  int v5 = (1 << a3) + a2;
  unsigned int v6 = 2 << a3;
  if ((2 << a3) < 0x18)
  {
    int v7 = 0;
LABEL_3:
    uniforuint64_t m = av1_get_uniform(a1, (v6 | 1) - v7);
    goto LABEL_11;
  }
  int v7 = 0;
  if (av1_get_bits((uint64_t)a1, 1u))
  {
    unsigned int v9 = 2;
    int v10 = 8;
    while (1)
    {
      v7 += v10;
      if (v7 + (24 << (v9 - 2)) > v6) {
        goto LABEL_3;
      }
      int v10 = 8 << (v9++ - 2);
      if (!av1_get_bits((uint64_t)a1, 1u)) {
        goto LABEL_10;
      }
    }
  }
  unsigned int v9 = 3;
LABEL_10:
  uniforuint64_t m = av1_get_bits((uint64_t)a1, v9);
LABEL_11:
  unsigned int v11 = uniform + v7;
  unsigned int v12 = 2 * v5;
  unsigned int v13 = uniform + v7 + 1;
  unsigned int v14 = v6 - v5 - (v13 >> 1);
  if (((uniform + v7) & 1) == 0) {
    unsigned int v14 = v6 - v5 + ((uniform + v7) >> 1);
  }
  if (v11 <= 2 * (v6 - v5)) {
    unsigned int v15 = v14;
  }
  else {
    unsigned int v15 = uniform + v7;
  }
  unsigned int v16 = v6 - v15;
  unsigned int v17 = v5 - (v13 >> 1);
  if ((v11 & 1) == 0) {
    unsigned int v17 = v5 + (v11 >> 1);
  }
  if (v12 >= v11) {
    unsigned int v11 = v17;
  }
  if (v12 > v6) {
    unsigned int v11 = v16;
  }
  return v11 - v4;
}

uint64_t dav1d_picture_ref(void *a1, const void *a2)
{
  if (a1 && !a1[3] && a2)
  {
    memcpy(a1, a2, 0x110uLL);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

_OWORD *dav1d_picture_unref_internal(_OWORD *result)
{
  if (!result) {
    return (_OWORD *)FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  result[15] = 0u;
  result[16] = 0u;
  result[13] = 0u;
  result[14] = 0u;
  result[11] = 0u;
  result[12] = 0u;
  result[9] = 0u;
  result[10] = 0u;
  result[7] = 0u;
  result[8] = 0u;
  result[5] = 0u;
  result[6] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[1] = 0u;
  result[2] = 0u;
  *unint64_t result = 0u;
  return result;
}

uint64_t picture_alloc_with_edges(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12)
{
  if ((a12 - 17) <= 0xFFFFFFEF) {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  *(_DWORD *)(a1 + 64) = a2;
  *(_DWORD *)(a1 + 68) = a3;
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = a6;
  *(void *)(a1 + 144) = a10;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(a1 + 76) = a12;
  *(_OWORD *)(a1 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = xmmword_18FE95940;
  *(void *)(a1 + 96) = -1;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  *(void *)(a1 + 184) = a7;
  *(void *)(a1 + 192) = a5;
  *(void *)(a1 + 20CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a8;
  *(void *)(a1 + 208) = a9;
  *(void *)(a1 + 216) = a11;
  return 0;
}

uint64_t OUTLINED_FUNCTION_0()
{
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoCreateMutable(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  if (a2)
  {
    if (a3)
    {
      CFMutableSetRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        unsigned int v6 = Mutable;
        CFDictionarySetValue(Mutable, @"RequestInfoURL", a2);
        *a3 = CFRetain(v6);
        CFRelease(v6);
        return 0;
      }
      uint64_t v8 = 4294954510;
    }
    else
    {
      uint64_t v8 = 4294954516;
    }
  }
  else
  {
    uint64_t v8 = 4294954516;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoCreateMutableCopy(const __CFAllocator *a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  if (theDict)
  {
    if (a3)
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, theDict);
      if (MutableCopy)
      {
        CFMutableDictionaryRef v5 = MutableCopy;
        *a3 = CFRetain(MutableCopy);
        CFRelease(v5);
        return 0;
      }
      uint64_t v7 = 4294954510;
    }
    else
    {
      uint64_t v7 = 4294954516;
    }
  }
  else
  {
    uint64_t v7 = 4294954516;
  }

  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoSetByteRange(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FigCFDictionarySetInt64(a1, @"RequestInfoByteRangeStart", a2);
  if (!result)
  {
    return FigCFDictionarySetInt64(a1, @"RequestInfoByteRangeLength", a3);
  }
  return result;
}

uint64_t FigCustomURLRequestInfoSetHTTPHeaders(CFMutableDictionaryRef theDict, CFTypeRef cf)
{
  if (!cf)
  {
    CFDictionaryRemoveValue(theDict, @"RequestInfoHTTPHeaders");
    return 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(cf);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v4, (CFDictionaryRef)cf);
  if (Copy)
  {
    CFDictionaryRef v6 = Copy;
    CFDictionarySetValue(theDict, @"RequestInfoHTTPHeaders", Copy);
    CFRelease(v6);
    return 0;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoSetIsRenewalRequest(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"RequestInfoIsRenewalRequest", *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetIsPingRequest(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"RequestInfoIsPingRequest", *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetDefaultLatency(void *a1, uint64_t a2)
{
  return 0;
}

uint64_t FigCustomURLRequestInfoSetExpectedToBlock(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"RequestInfoExpectedToBlock", *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetUserAgent(const __CFDictionary *a1, const void *a2)
{
  return figCustomURLRequestInfoReplaceValueForHTTPHeader(a1, @"User-Agent", a2);
}

uint64_t figCustomURLRequestInfoReplaceValueForHTTPHeader(const __CFDictionary *a1, const void *a2, const void *a3)
{
  CFDictionaryRef theDict = 0;
  uint64_t v6 = FigCustomURLRequestInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if (!v6)
  {
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v10, 0, theDict);
LABEL_5:
    unsigned int v11 = MutableCopy;
    if (MutableCopy)
    {
      if (a3) {
        CFDictionarySetValue(MutableCopy, a2, a3);
      }
      else {
        CFDictionaryRemoveValue(MutableCopy, a2);
      }
      uint64_t v7 = FigCustomURLRequestInfoSetHTTPHeaders(a1, v11);
      CFRelease(v11);
    }
    else
    {
      uint64_t v7 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    goto LABEL_10;
  }
  uint64_t v7 = v6;
  if (v6 == -17360)
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_5;
  }
LABEL_10:
  if (theDict) {
    CFRelease(theDict);
  }
  return v7;
}

uint64_t FigCustomURLRequestInfoSetAcceptEncoding(const __CFDictionary *a1, const void *a2)
{
  return figCustomURLRequestInfoReplaceValueForHTTPHeader(a1, @"Accept-Encoding", a2);
}

uint64_t FigCustomURLRequestInfoSetCryptor(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, @"RequestInfoCryptor", value);
  }
  else {
    CFDictionaryRemoveValue(a1, @"RequestInfoCryptor");
  }
  return 0;
}

uint64_t FigCustomURLRequestInfoSetCryptorKeyAttributes(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, @"RequestInfoCryptKeyAttributes", value);
  }
  else {
    CFDictionaryRemoveValue(a1, @"RequestInfoCryptKeyAttributes");
  }
  return 0;
}

uint64_t FigCustomURLRequestInfoSetCryptorID(void *a1, uint64_t a2)
{
  if (a2) {
    FigCFDictionarySetInt64(a1, @"RequestInfoCryptorID", a2);
  }
  else {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, @"RequestInfoCryptorID");
  }
  return 0;
}

uint64_t FigCustomURLRequestInfoSetCryptorKeyRequestID(void *a1, uint64_t a2)
{
  if (a2) {
    FigCFDictionarySetInt64(a1, @"RequestInfoCryptorKeyRequestID", a2);
  }
  else {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, @"RequestInfoCryptorKeyRequestID");
  }
  return 0;
}

uint64_t FigCustomURLRequestInfoSetAllowedUniversalTypeIdentifiers(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, @"AllowedUniversalTypeIdentifiers", value);
  }
  else {
    CFDictionaryRemoveValue(a1, @"AllowedUniversalTypeIdentifiers");
  }
  return 0;
}

uint64_t FigCustomURLRequestInfoSetIsSecureStopSupported(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"RequestInfoIsSecureStopSupported", *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetNetworkHistory(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, @"RequestInfoNetworkHistory", value);
  }
  else {
    CFDictionaryRemoveValue(a1, @"RequestInfoNetworkHistory");
  }
  return 0;
}

uint64_t FigCustomURLRequestInfoGetByteRange(uint64_t a1, void *a2, void *a3)
{
  if (!FigCFDictionaryGetInt64IfPresent(a1, @"RequestInfoByteRangeStart", a2)) {
    return 4294949936;
  }
  if (FigCFDictionaryGetInt64IfPresent(a1, @"RequestInfoByteRangeLength", a3)) {
    return 0;
  }
  return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetIsRenewalRequest(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, @"RequestInfoIsRenewalRequest", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoGetIsPingRequest(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, @"RequestInfoIsPingRequest", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoGetDefaultLatency(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, @"RequestInfoDefaultLatency", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoGetExpectedToBlock(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, @"RequestInfoExpectedToBlock", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoCopyURL(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"RequestInfoURL", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoCopyHTTPHeaders(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"RequestInfoHTTPHeaders", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoCopyUserAgent(const __CFDictionary *a1, CFTypeRef *a2)
{
  return figCustomURLRequestInfoCopyHTTPHeader(a1, @"User-Agent", a2);
}

uint64_t figCustomURLRequestInfoCopyHTTPHeader(const __CFDictionary *a1, const void *a2, CFTypeRef *a3)
{
  CFDictionaryRef theDict = 0;
  uint64_t v5 = FigCustomURLRequestInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if (v5)
  {
    uint64_t v7 = v5;
  }
  else
  {
    CFArrayRef Value = CFDictionaryGetValue(theDict, a2);
    if (Value)
    {
      uint64_t v7 = 0;
      *a3 = CFRetain(Value);
    }
    else
    {
      uint64_t v7 = 4294949936;
    }
  }
  if (theDict) {
    CFRelease(theDict);
  }
  return v7;
}

uint64_t FigCustomURLRequestInfoCopyAcceptEncoding(const __CFDictionary *a1, CFTypeRef *a2)
{
  return figCustomURLRequestInfoCopyHTTPHeader(a1, @"Accept-Encoding", a2);
}

uint64_t FigCustomURLRequestInfoCopyCryptor(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"RequestInfoCryptor", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoCopyCryptKeyAttributes(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"RequestInfoCryptKeyAttributes", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoGetCryptorID(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, @"RequestInfoCryptorID", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoGetCryptorKeyRequestID(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, @"RequestInfoCryptorKeyRequestID", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoCopyAllowedUniversalTypeIdentifiers(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"AllowedUniversalTypeIdentifiers", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLRequestInfoGetIsSecureStopSupported(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, @"RequestInfoIsSecureStopSupported", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoCreateMutable(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  if (a2)
  {
    if (a3)
    {
      CFMutableSetRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        uint64_t v6 = Mutable;
        CFDictionarySetValue(Mutable, @"ResponseInfoRequestInfo", a2);
        *a3 = CFRetain(v6);
        CFRelease(v6);
        return 0;
      }
      uint64_t v8 = 4294954510;
    }
    else
    {
      uint64_t v8 = 4294954516;
    }
  }
  else
  {
    uint64_t v8 = 4294954516;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoCreateMutableCopy(const __CFAllocator *a1, CFDictionaryRef theDict, CFMutableDictionaryRef *a3)
{
  if (theDict)
  {
    if (a3)
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, theDict);
      if (MutableCopy)
      {
        *a3 = MutableCopy;
        return 0;
      }
      uint64_t v6 = 4294954510;
    }
    else
    {
      uint64_t v6 = 4294954516;
    }
  }
  else
  {
    uint64_t v6 = 4294954516;
  }

  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoSetRequestInfo(__CFDictionary *a1, void *value)
{
  return 0;
}

uint64_t FigCustomURLResponseInfoCreate(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  CFDictionaryRef theDict = 0;
  if (a2)
  {
    if (a3)
    {
      uint64_t Mutable = FigCustomURLResponseInfoCreateMutable(a1, a2, (CFTypeRef *)&theDict);
      if (Mutable)
      {
LABEL_15:
        uint64_t v8 = Mutable;
        goto LABEL_6;
      }
      CFDictionaryRef Copy = CFDictionaryCreateCopy(a1, theDict);
      if (Copy)
      {
        CFDictionaryRef v7 = Copy;
        *a3 = CFRetain(Copy);
        CFRelease(v7);
        uint64_t v8 = 0;
LABEL_6:
        if (theDict) {
          CFRelease(theDict);
        }
        return v8;
      }
      uint64_t v10 = 4294954510;
    }
    else
    {
      uint64_t v10 = 4294954516;
    }
    uint64_t Mutable = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoSetHTTPStatusCode(void *a1, uint64_t a2)
{
  return FigCFDictionarySetCFIndex(a1, @"ResponseInfoHTTPStatusCode", a2);
}

uint64_t FigCustomURLResponseInfoSetContentLength(void *a1, uint64_t a2)
{
  return FigCFDictionarySetInt64(a1, @"ResponseInfoContentLength", a2);
}

uint64_t FigCustomURLResponseInfoSetResourceSize(void *a1, uint64_t a2)
{
  return FigCFDictionarySetInt64(a1, @"ResponseInfoResourceSize", a2);
}

uint64_t FigCustomURLResponseInfoSetIsCachingDisabled(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"ResponseInfoIsCachingDisabled", *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoSetIsByteRangeAccessSupported(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"ResponseInfoIsByteRangeAccessSupported", *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoSetIsEntireLengthAvailableOnDemand(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"ResponseInfoEntireLengthAvailableOnDemand", *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoSetUniversalTypeIdentifier(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, @"ResponseInfoUTI", value);
  }
  else {
    CFDictionaryRemoveValue(a1, @"ResponseInfoUTI");
  }
  return 0;
}

uint64_t FigCustomURLResponseInfoSetContentRenewalDate(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, @"ResponseInfoContentRenewalDate", value);
  }
  else {
    CFDictionaryRemoveValue(a1, @"ResponseInfoContentRenewalDate");
  }
  return 0;
}

uint64_t FigCustomURLResponseInfoSetFinalURL(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, @"ResponseInfoURL", value);
  }
  else {
    CFDictionaryRemoveValue(a1, @"ResponseInfoURL");
  }
  return 0;
}

uint64_t FigCustomURLResponseInfoSetHTTPHeaders(CFMutableDictionaryRef theDict, CFTypeRef cf)
{
  if (!cf)
  {
    CFDictionaryRemoveValue(theDict, @"ResponseInfoHTTPHeaders");
    return 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(cf);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v4, (CFDictionaryRef)cf);
  if (Copy)
  {
    CFDictionaryRef v6 = Copy;
    CFDictionarySetValue(theDict, @"ResponseInfoHTTPHeaders", Copy);
    CFRelease(v6);
    return 0;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoSetRedirectLocation(const __CFDictionary *a1, const __CFURL *a2)
{
  CFDictionaryRef theDict = 0;
  uint64_t v4 = FigCustomURLResponseInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if (v4)
  {
    uint64_t v5 = v4;
    if (v4 != -17360) {
      goto LABEL_14;
    }
    CFAllocatorRef v6 = CFGetAllocator(a1);
    uint64_t Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    uint64_t Mutable = CFDictionaryCreateMutableCopy(v8, 0, theDict);
  }
  unsigned int v9 = Mutable;
  if (Mutable)
  {
    if (a2)
    {
      CFURLRef v10 = CFURLCopyAbsoluteURL(a2);
      if (v10)
      {
        CFURLRef v11 = v10;
        CFStringRef v12 = CFURLGetString(v10);
        if (v12)
        {
          CFDictionarySetValue(v9, @"Location", v12);
          uint64_t v13 = FigCustomURLResponseInfoSetHTTPHeaders(a1, v9);
        }
        else
        {
          uint64_t v13 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        }
        uint64_t v5 = v13;
        CFRelease(v11);
        goto LABEL_13;
      }
      uint64_t v14 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      CFDictionaryRemoveValue(Mutable, @"Location");
      uint64_t v14 = FigCustomURLResponseInfoSetHTTPHeaders(a1, v9);
    }
    uint64_t v5 = v14;
LABEL_13:
    CFRelease(v9);
    goto LABEL_14;
  }
  uint64_t v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_14:
  if (theDict) {
    CFRelease(theDict);
  }
  return v5;
}

uint64_t FigCustomURLResponseInfoCopyHTTPHeaders(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"ResponseInfoHTTPHeaders", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoSetAllValuesFromResponseInfo(void *a1, const void *a2)
{
  CFTypeRef value = 0;
  if (FigCFEqual(a1, a2)) {
    return 0;
  }
  uint64_t v4 = FigCustomURLResponseInfoCopyRequestInfo((const __CFDictionary *)a1, (const void **)&value);
  if (!v4)
  {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, @"ResponseInfoRequestInfo");
    FigCFDictionaryAddEntriesToDictionaryWithRecursion(a2, (const __CFDictionary *)a1, 1);
    CFDictionarySetValue((CFMutableDictionaryRef)a1, @"ResponseInfoRequestInfo", value);
  }
  if (value) {
    CFRelease(value);
  }
  return v4;
}

uint64_t FigCustomURLResponseInfoCopyRequestInfo(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"ResponseInfoRequestInfo", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoSetRedirectRequestHeaders(CFMutableDictionaryRef theDict, const __CFDictionary *a2)
{
  if (!a2)
  {
    CFDictionaryRemoveValue(theDict, @"ResponseInfoRedirectRequestHeaders");
    return 0;
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (Copy)
  {
    CFDictionaryRef v4 = Copy;
    CFDictionarySetValue(theDict, @"ResponseInfoRedirectRequestHeaders", Copy);
    CFRelease(v4);
    return 0;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoSetRoundTripTime(__CFDictionary *a1, double a2)
{
  if (a2 <= 2.22044605e-16) {
    CFDictionaryRemoveValue(a1, @"ResponseInfoRoundTripTime");
  }
  else {
    FigCFDictionarySetDouble(a1, @"ResponseInfoRoundTripTime", a2);
  }
  return 0;
}

uint64_t FigCustomURLResponseInfoSetSuppressErrorLogging(__CFDictionary *a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, @"ResponseInfoSuppressErrorLogging", *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoGetHTTPStatusCode(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetCFIndexIfPresent(a1, @"ResponseInfoHTTPStatusCode", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoGetContentLength(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, @"ResponseInfoContentLength", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoGetResourceSize(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, @"ResponseInfoResourceSize", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoGetIsCachingDisabled(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, @"ResponseInfoIsCachingDisabled", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoGetIsByteRangeAccessSupported(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, @"ResponseInfoIsByteRangeAccessSupported", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoGetEntireLengthAvailableOnDemand(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, @"ResponseInfoEntireLengthAvailableOnDemand", a2)) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoCopyUniversalTypeIdentifier(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"ResponseInfoUTI", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoCopyContentRenewalDate(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"ResponseInfoContentRenewalDate", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

uint64_t FigCustomURLResponseInfoCopyFinalURL(const __CFDictionary *a1, const void **value)
{
  CFDictionaryRef theDict = 0;
  if (!CFDictionaryGetValueIfPresent(a1, @"ResponseInfoURL", value))
  {
    uint64_t v4 = FigCustomURLResponseInfoCopyRequestInfo(a1, (const void **)&theDict);
    if (v4)
    {
      uint64_t v5 = v4;
      goto LABEL_7;
    }
    CFDictionaryGetValueIfPresent(theDict, @"RequestInfoURL", value);
  }
  if (*value) {
    CFRetain(*value);
  }
  uint64_t v5 = 0;
LABEL_7:
  if (theDict) {
    CFRelease(theDict);
  }
  return v5;
}

uint64_t FigCustomURLResponseInfoCopyRedirectLocation(const __CFDictionary *a1, CFURLRef *a2)
{
  CFDictionaryRef theDict = 0;
  uint64_t v3 = FigCustomURLResponseInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if (!v3)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"Location");
    if (!Value)
    {
      uint64_t v8 = 4294949936;
      goto LABEL_5;
    }
    CFStringRef v5 = Value;
    CFAllocatorRef v6 = CFGetAllocator(theDict);
    CFURLRef v7 = CFURLCreateWithString(v6, v5, 0);
    *a2 = v7;
    if (v7)
    {
      uint64_t v8 = 0;
      goto LABEL_5;
    }
    uint64_t v3 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v8 = v3;
LABEL_5:
  if (theDict) {
    CFRelease(theDict);
  }
  return v8;
}

uint64_t FigCustomURLResponseInfoCopyRedirectRequestHeaders(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a1, @"ResponseInfoRedirectRequestHeaders", value);
  if (*value) {
    CFRetain(*value);
  }
  if (ValueIfPresent) {
    return 0;
  }
  else {
    return 4294949936;
  }
}

double FigCustomURLResponseInfoGetRoundTripTime(uint64_t a1)
{
  double v2 = 0.0;
  FigCFDictionaryGetDoubleIfPresent(a1, @"ResponseInfoRoundTripTime", &v2);
  return v2;
}

uint64_t FigCustomURLHandlerGetClassID()
{
  return sFigCustomURLHandlerClassID;
}

uint64_t RegisterFigCustomURLHandlerBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigCustomURLHandlerClassDesc, ClassID, 1, &sFigCustomURLHandlerClassID);
}

uint64_t FigCustomURLHandlerGetTypeID()
{
  FigThreadRunOnce(&FigCustomURLHandlerGetClassID_sRegisterFigCustomURLHandlerBaseTypeOnce, (void (*)(void))RegisterFigCustomURLHandlerBaseType);
  uint64_t v0 = (void *)sFigCustomURLHandlerClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigCustomURLHandlerCreate(const void *a1, const char *a2, uint64_t a3, NSObject *a4, uint64_t a5, uint64_t a6, CFTypeRef *a7)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (FigNote_AllowInternalDefaultLogs())
  {
    if (FigNote_AllowInternalDefaultLogs()) {
      unsigned int v12 = 2;
    }
    else {
      unsigned int v12 = 1;
    }
  }
  else
  {
    unsigned int v12 = 0;
  }
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigCustomURLHandlingTrace[1], @"curl_handling_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v12, 0, gFigCustomURLHandlingTrace);
  if (FigNote_AllowInternalDefaultLogs()) {
    unsigned int v13 = 2;
  }
  else {
    unsigned int v13 = 1;
  }
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EB28B5F0, @"curl_handling_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v13, 0, &qword_1EB28B5E8);
  if (!a2 || !a3 || !a4 || !a5 || !*(void *)(a5 + 8) || !a7 || strnlen(a2, 0x40uLL) >= 0x40)
  {
    uint64_t v18 = 4294949916;
LABEL_22:
    uint64_t v14 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
    goto LABEL_23;
  }
  FigThreadRunOnce(&FigCustomURLHandlerGetClassID_sRegisterFigCustomURLHandlerBaseTypeOnce, (void (*)(void))RegisterFigCustomURLHandlerBaseType);
  uint64_t v14 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kCustomURLHandler_VTable, (void *)sFigCustomURLHandlerClassID, &cf);
  if (!v14)
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
    uint64_t v14 = figCustomURLWorkQueueCreate((CFTypeRef *)DerivedStorage);
    if (!v14)
    {
      unsigned int v16 = FigReentrantMutexCreate();
      *(void *)(DerivedStorage + 8) = v16;
      if (v16)
      {
        CFTypeRef v17 = a1 ? CFRetain(a1) : 0;
        *(void *)(DerivedStorage + 16) = v17;
        dispatch_retain(a4);
        *(void *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a4;
        *(_DWORD *)(DerivedStorage + 48) = *(_DWORD *)a5;
        *(void *)(DerivedStorage + 56) = *(void *)(a5 + 8);
        *(void *)(DerivedStorage + 64) = *(void *)(a5 + 16);
        *(void *)(DerivedStorage + 24) = a2;
        CFTypeRef v20 = FigCFWeakReferenceHolderCreateWithReferencedObject(a3);
        *(void *)(DerivedStorage + 32) = v20;
        if (v20)
        {
          FigCFDictionaryGetBooleanIfPresent(a6, @"CURLHOption_ClientRequestsRepresentAccurateNetworkStatistics", (Boolean *)(DerivedStorage + 72));
          *(void *)(DerivedStorage + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
          *(void *)(DerivedStorage + 88) = DerivedStorage + 80;
          if (dword_1EB28B5F0)
          {
            int v31 = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v31, &type);
            int v22 = v31;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v24 = v22;
            }
            else {
              unsigned int v24 = v22 & 0xFFFFFFFE;
            }
            if (v24)
            {
              uint64_t v25 = *(void *)(DerivedStorage + 24);
              int v33 = 136315906;
              uint64_t v34 = "FigCustomURLHandlerCreate";
              __int16 v35 = 2082;
              uint64_t v36 = v25;
              __int16 v37 = 2048;
              CFTypeRef v38 = cf;
              __int16 v39 = 2114;
              uint64_t v40 = a6;
              unsigned int v26 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v22) = v31;
            }
            else
            {
              unsigned int v26 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v26, v26 != &v41, v22, 0, v23);
          }
          uint64_t v19 = 0;
          *a7 = cf;
          return v19;
        }
      }
      uint64_t v18 = 4294954510;
      goto LABEL_22;
    }
  }
LABEL_23:
  uint64_t v19 = v14;
  if (cf) {
    CFRelease(cf);
  }
  return v19;
}

uint64_t figCustomURLWorkQueueCreate(CFTypeRef *a1)
{
  if (sFigCustomURLWorkQueueRegisterTypeOnce != -1) {
    dispatch_once_f(&sFigCustomURLWorkQueueRegisterTypeOnce, 0, (dispatch_function_t)figCustomURLWorkQueueRegisterType);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v3 = (void *)Instance;
    uint64_t v4 = FigReentrantMutexCreate();
    void v3[2] = v4;
    if (v4)
    {
      v3[3] = 0;
      v3[4] = v3 + 3;
      uint64_t v5 = 0;
      *a1 = CFRetain(v3);
    }
    else
    {
      uint64_t v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v3);
    return v5;
  }
  else
  {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCustomURLLoaderGetClassID()
{
  return sFigCustomURLLoaderClassID;
}

uint64_t RegisterFigCustomURLLoaderBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigCustomURLLoaderClassDesc, ClassID, 1, &sFigCustomURLLoaderClassID);
}

uint64_t FigCustomURLLoaderGetCFTypeID()
{
  FigThreadRunOnce(&FigCustomURLLoaderGetClassID_sRegisterFigCustomURLLoaderBaseTypeOnce, (void (*)(void))RegisterFigCustomURLLoaderBaseType);
  uint64_t v0 = (void *)sFigCustomURLLoaderClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigCustomURLLoaderCreate(const void *a1, uint64_t a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (FigNote_AllowInternalDefaultLogs())
  {
    if (FigNote_AllowInternalDefaultLogs()) {
      unsigned int v5 = 2;
    }
    else {
      unsigned int v5 = 1;
    }
  }
  else
  {
    unsigned int v5 = 0;
  }
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigCustomURLHandlingTrace[1], @"curl_handling_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v5, 0, gFigCustomURLHandlingTrace);
  if (FigNote_AllowInternalDefaultLogs()) {
    unsigned int v6 = 2;
  }
  else {
    unsigned int v6 = 1;
  }
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EB28B5F0, @"curl_handling_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v6, 0, &qword_1EB28B5E8);
  if (!a3)
  {
    uint64_t v21 = 4294949916;
    goto LABEL_35;
  }
  FigThreadRunOnce(&FigCustomURLLoaderGetClassID_sRegisterFigCustomURLLoaderBaseTypeOnce, (void (*)(void))RegisterFigCustomURLLoaderBaseType);
  uint64_t v7 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kCustomURLLoader_VTable, (void *)sFigCustomURLLoaderClassID, &cf);
  if (v7) {
    goto LABEL_36;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  uint64_t v7 = figCustomURLWorkQueueCreate((CFTypeRef *)DerivedStorage);
  if (v7) {
    goto LABEL_36;
  }
  unsigned int v9 = FigReentrantMutexCreate();
  *(void *)(DerivedStorage + 8) = v9;
  if (!v9 {
    || (!a1 ? (CFAllocatorRef v10 = 0) : (CFAllocatorRef v10 = (const __CFAllocator *)CFRetain(a1)),
  }
        (*(void *)(DerivedStorage + 16) = v10,
         CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
         (*(void *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = Mutable) == 0)
     || (CFMutableArrayRef v12 = CFArrayCreateMutable(*(CFAllocatorRef *)(DerivedStorage + 16), 0, MEMORY[0x1E4F1D510]),
         (*(void *)(DerivedStorage + 48) = v12) == 0)))
  {
    uint64_t v21 = 4294954510;
LABEL_35:
    uint64_t v7 = FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
    goto LABEL_36;
  }
  uint64_t v7 = FigCFWeakReferenceTableCreate(*(const __CFAllocator **)(DerivedStorage + 16), 1, (uint64_t *)(DerivedStorage + 56));
  if (v7)
  {
LABEL_36:
    uint64_t v19 = v7;
    goto LABEL_30;
  }
  if (dword_1EB28B5F0)
  {
    int v23 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v23, &type);
    int v14 = v23;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v16 = v14;
    }
    else {
      unsigned int v16 = v14 & 0xFFFFFFFE;
    }
    if (v16)
    {
      int v25 = 136315394;
      unsigned int v26 = "FigCustomURLLoaderCreate";
      __int16 v27 = 2048;
      CFTypeRef v28 = cf;
      CFTypeRef v17 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v14) = v23;
    }
    else
    {
      CFTypeRef v17 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v17, v17 != &v29, v14, 0, v15);
  }
  CFTypeRef v18 = cf;
  if (cf) {
    CFTypeRef v18 = CFRetain(cf);
  }
  uint64_t v19 = 0;
  *a3 = v18;
LABEL_30:
  if (cf) {
    CFRelease(cf);
  }
  return v19;
}

CFStringRef FigCustomURLHandlerCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCustomURLHandler %p]", a1);
}

uint64_t curlh_invalidate(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(unsigned char *)(DerivedStorage + 73))
  {
    *(unsigned char *)(DerivedStorage + 73) = 1;
    uint64_t v3 = *(void **)(CMBaseObjectGetDerivedStorage(a1) + 80);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)v3[8];
        curlh_removeAndFreeCustomURLRequestEntry(a1, v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    unsigned int v5 = *(const void **)(DerivedStorage + 16);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(DerivedStorage + 16) = 0;
    }
    unsigned int v6 = *(const void **)(DerivedStorage + 32);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(DerivedStorage + 32) = 0;
    }
    uint64_t v7 = *(NSObject **)(DerivedStorage + 40);
    if (v7)
    {
      dispatch_release(v7);
      *(void *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    }
    if (*(void *)DerivedStorage)
    {
      CFRelease(*(CFTypeRef *)DerivedStorage);
      *(void *)uint64_t DerivedStorage = 0;
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return 0;
}

uint64_t curlh_finalize(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  curlh_invalidate(a1);
  uint64_t v3 = *(void *)(DerivedStorage + 8);

  return FigReentrantMutexDestroy(v3);
}

uint64_t curlh_copyDebugDescription()
{
  return 0;
}

void curlh_removeAndFreeCustomURLRequestEntry(uint64_t a1, void *a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  uint64_t v4 = (const void *)a2[1];
  if (v4)
  {
    CFRelease(v4);
    a2[1] = 0;
  }
  unsigned int v5 = a2[2];
  if (v5)
  {
    dispatch_release(v5);
    a2[2] = 0;
  }
  unsigned int v6 = (const void *)a2[4];
  if (v6)
  {
    CFRelease(v6);
    a2[4] = 0;
  }
  uint64_t v7 = (const void *)a2[7];
  if (v7)
  {
    CFRelease(v7);
    a2[7] = 0;
  }
  uint64_t v8 = (const void *)a2[5];
  if (v8)
  {
    CFRelease(v8);
    a2[5] = 0;
  }
  uint64_t v9 = a2[8];
  CFAllocatorRef v10 = (void *)a2[9];
  if (v9)
  {
    *(void *)(v9 + 72) = v10;
    CFAllocatorRef v10 = (void *)a2[9];
  }
  else
  {
    *(void *)(DerivedStorage + 88) = v10;
  }
  *CFAllocatorRef v10 = v9;
  CFAllocatorRef v11 = *(const __CFAllocator **)(DerivedStorage + 16);

  CFAllocatorDeallocate(v11, a2);
}

uint64_t curlh_sendResponseInfo(const void *a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a3)
  {
    uint64_t v7 = (uint64_t *)DerivedStorage;
    uint64_t v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x106004049771C40uLL);
    if (v8)
    {
      uint64_t v9 = (uint64_t)v8;
      if (a1) {
        CFTypeRef v10 = CFRetain(a1);
      }
      else {
        CFTypeRef v10 = 0;
      }
      *(void *)uint64_t v9 = v10;
      *(void *)(v9 + 8) = a2;
      *(void *)(v9 + 16) = CFRetain(a3);
      uint64_t v11 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curlh_sendResponseInfoDispatch, v9);
      if (v11)
      {
        if (*(void *)v9) {
          CFRelease(*(CFTypeRef *)v9);
        }
        CFMutableArrayRef v12 = *(const void **)(v9 + 16);
        if (v12) {
          CFRelease(v12);
        }
        free((void *)v9);
      }
      return v11;
    }
    uint64_t v14 = 4294954510;
  }
  else
  {
    uint64_t v14 = 4294949926;
  }

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t curlh_sendData(const void *a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a3)
  {
    uint64_t v7 = (uint64_t *)DerivedStorage;
    uint64_t v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x1060040B6A22668uLL);
    if (v8)
    {
      uint64_t v9 = (uint64_t)v8;
      if (a1) {
        CFTypeRef v10 = CFRetain(a1);
      }
      else {
        CFTypeRef v10 = 0;
      }
      *(void *)uint64_t v9 = v10;
      *(void *)(v9 + 8) = a2;
      *(void *)(v9 + 16) = CFRetain(a3);
      uint64_t v11 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curlh_sendDataDispatch, v9);
      if (v11)
      {
        if (*(void *)v9) {
          CFRelease(*(CFTypeRef *)v9);
        }
        CFMutableArrayRef v12 = *(const void **)(v9 + 16);
        if (v12) {
          CFRelease(v12);
        }
        free((void *)v9);
      }
      return v11;
    }
    uint64_t v14 = 4294954510;
  }
  else
  {
    uint64_t v14 = 4294949926;
  }

  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t curlh_finishLoading(const void *a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  uint64_t v9 = malloc_type_calloc(1uLL, 0x20uLL, 0x1060040EF2C8554uLL);
  if (v9)
  {
    uint64_t v10 = (uint64_t)v9;
    if (a1) {
      CFTypeRef v11 = CFRetain(a1);
    }
    else {
      CFTypeRef v11 = 0;
    }
    *(void *)uint64_t v10 = v11;
    *(void *)(v10 + 8) = a2;
    if (a3) {
      CFTypeRef v12 = CFRetain(a3);
    }
    else {
      CFTypeRef v12 = 0;
    }
    *(void *)(v10 + 16) = v12;
    if (a4) {
      CFTypeRef v13 = CFRetain(a4);
    }
    else {
      CFTypeRef v13 = 0;
    }
    *(void *)(v10 + 24) = v13;
    uint64_t v14 = figCustomURLWorkQueueEnqueue(*DerivedStorage, (uint64_t)curlh_finishLoadingDispatch, v10);
    if (v14)
    {
      if (*(void *)v10) {
        CFRelease(*(CFTypeRef *)v10);
      }
      uint64_t v15 = *(const void **)(v10 + 16);
      if (v15) {
        CFRelease(v15);
      }
      unsigned int v16 = *(const void **)(v10 + 24);
      if (v16) {
        CFRelease(v16);
      }
      free((void *)v10);
    }
    return v14;
  }
  else
  {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t curlh_handleRequest(const void *a1, const void *a2, uint64_t a3, const void *a4, NSObject *a5, uint64_t a6, uint64_t a7, const void *a8)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1 || !a2 || !a4 || !a5 || !a7)
  {
    uint64_t v27 = 4294949926;
LABEL_20:
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v16 = (uint64_t *)DerivedStorage;
  if (handleRequestRec_getCFAllocator_sOnceToken != -1) {
    dispatch_once_f(&handleRequestRec_getCFAllocator_sOnceToken, &handleRequestRec_getCFAllocator_sAllocator, (dispatch_function_t)handleRequestRec_initializeCFAllocatorOnce);
  }
  CFAllocatorRef v17 = (const __CFAllocator *)handleRequestRec_getCFAllocator_sAllocator;
  if (handleRequestRec_getCFAllocator_sAllocator
    || (uint64_t result = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0), !result))
  {
    CFTypeRef v18 = (const UInt8 *)malloc_type_calloc(1uLL, 0x40uLL, 0x10E0040BCA754A7uLL);
    if (v18)
    {
      uint64_t v19 = v18;
      CFDataRef v20 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v18, 64, v17);
      if (v20)
      {
        CFDataRef v21 = v20;
        *uint64_t v19 = CFRetain(a1);
        v19[1] = CFRetain(a2);
        double v19[2] = a3;
        v19[3] = CFRetain(a4);
        dispatch_retain(a5);
        v19[4] = a5;
        v19[5] = a6;
        v19[6] = a7;
        CFTypeRef v22 = a8;
        if (a8) {
          CFTypeRef v22 = CFRetain(a8);
        }
        v19[7] = v22;
        uint64_t v23 = *v16;
        CFTypeRef v24 = CFRetain(v21);
        uint64_t v25 = figCustomURLWorkQueueEnqueue(v23, (uint64_t)curlh_handleRequestDispatch, (uint64_t)v24);
        CFRelease(v21);
        return v25;
      }
      free(v19);
    }
    uint64_t v27 = 4294954510;
    goto LABEL_20;
  }
  return result;
}

uint64_t curlh_cancelRequest(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1)
  {
    unsigned int v5 = (uint64_t *)DerivedStorage;
    unsigned int v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
    if (v6)
    {
      uint64_t v7 = (uint64_t)v6;
      *unsigned int v6 = CFRetain(a1);
      *(void *)(v7 + 8) = a2;
      uint64_t v8 = figCustomURLWorkQueueEnqueue(*v5, (uint64_t)curlh_cancelRequestDispatch, v7);
      if (v8)
      {
        if (*(void *)v7) {
          CFRelease(*(CFTypeRef *)v7);
        }
        free((void *)v7);
      }
      return v8;
    }
    uint64_t v10 = 4294954510;
  }
  else
  {
    uint64_t v10 = 4294949926;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t curlh_requestSetDormant(const void *a1, uint64_t a2, char a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1)
  {
    uint64_t v7 = (uint64_t *)DerivedStorage;
    uint64_t v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x10600407BD382EDuLL);
    if (v8)
    {
      uint64_t v9 = (uint64_t)v8;
      *uint64_t v8 = CFRetain(a1);
      *(void *)(v9 + 8) = a2;
      *(unsigned char *)(v9 + 16) = a3;
      uint64_t v10 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curlh_requestSetDormantDispatch, v9);
      if (v10)
      {
        if (*(void *)v9) {
          CFRelease(*(CFTypeRef *)v9);
        }
        free((void *)v9);
      }
      return v10;
    }
    uint64_t v12 = 4294954510;
  }
  else
  {
    uint64_t v12 = 4294949926;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t curlh_lookupAndRetainRegisteredInfoForRequestID(const void *a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1 && a3)
  {
    uint64_t v9 = (uint64_t *)DerivedStorage;
    uint64_t v10 = malloc_type_calloc(1uLL, 0x20uLL, 0x10E00402E54A04BuLL);
    if (v10)
    {
      uint64_t v11 = (uint64_t)v10;
      *uint64_t v10 = CFRetain(a1);
      *(void *)(v11 + 8) = a2;
      *(void *)(v11 + 16) = a3;
      if (a4) {
        CFTypeRef v12 = CFRetain(a4);
      }
      else {
        CFTypeRef v12 = 0;
      }
      *(void *)(v11 + 24) = v12;
      uint64_t v13 = figCustomURLWorkQueueEnqueue(*v9, (uint64_t)curlh_lookupAndRetainRegisteredInfoForRequestIDDispatch, v11);
      if (v13)
      {
        if (*(void *)v11) {
          CFRelease(*(CFTypeRef *)v11);
        }
        uint64_t v14 = *(const void **)(v11 + 24);
        if (v14) {
          CFRelease(v14);
        }
        free((void *)v11);
      }
      return v13;
    }
    uint64_t v16 = 4294954510;
  }
  else
  {
    uint64_t v16 = 4294949926;
  }

  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t figCustomURLWorkQueueEnqueue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(_DWORD *)(a1 + 40) == 4)
  {
    uint64_t v9 = 4294954511;
    goto LABEL_8;
  }
  unsigned int v6 = malloc_type_calloc(1uLL, 0x18uLL, 0xA0040114AFA65uLL);
  if (!v6)
  {
    uint64_t v9 = 4294954510;
LABEL_8:
    uint64_t v7 = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    if (v7) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  *unsigned int v6 = a2;
  v6[1] = a3;
  int v6[2] = 0;
  **(void **)(a1 + 32) = v6;
  *(void *)(a1 + 32) = v6 + 2;
LABEL_4:
  figCustomURLWorkQueueDrain(a1, 0);
  uint64_t v7 = 0;
LABEL_5:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v7;
}

void curlh_sendResponseInfoDispatch(uint64_t *a1)
{
  uint64_t v3 = (const void *)*a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (const void *)a1[2];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  dispatch_object_t object = 0;
  CFTypeRef v17 = 0;
  uint64_t v14 = 0;
  CFTypeRef v15 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73))
  {
    int RequestEntryForRequestID = FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    goto LABEL_35;
  }
  int RequestEntryForRequestID = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &v15, 0, &v17, &object, &v14, 0, 0);
  if (RequestEntryForRequestID) {
    goto LABEL_35;
  }
  CFTypeRef v21 = 0;
  if (!v4)
  {
    uint64_t v13 = 4294949926;
    goto LABEL_41;
  }
  int RequestEntryForRequestID = curlh_getRequestEntryForRequestID((uint64_t)v3, v2, &v21);
  if (RequestEntryForRequestID)
  {
LABEL_35:
    int v11 = RequestEntryForRequestID;
    goto LABEL_36;
  }
  uint64_t v7 = v21;
  if (!*((void *)v21 + 7))
  {
    v7[7] = CFRetain(v4);
    goto LABEL_7;
  }
  uint64_t v13 = 4294949920;
LABEL_41:
  int RequestEntryForRequestID = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  if (RequestEntryForRequestID) {
    goto LABEL_35;
  }
LABEL_7:
  CFTypeRef cf = 0;
  CFTypeRef v21 = 0;
  uint64_t v19 = 0;
  unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  uint64_t v18 = 0;
  int v9 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &v21, 0, 0, 0, 0, 0, 0);
  if (v9)
  {
LABEL_15:
    int v11 = v9;
    goto LABEL_17;
  }
  if (curlh_copyNetworkHistoryIfReporting(v3, v2, &cf, &v19))
  {
    FigCFDictionaryGetInt64IfPresent((uint64_t)v21, @"RequestInfoDefaultLatency", &v18);
    uint64_t v10 = v19;
    if (!v19)
    {
      curlh_requestSetDormantOnQueue(v3, v2, 0, &v19);
      uint64_t v10 = v19;
    }
    if (v18)
    {
      int v11 = FigNetworkHistorySetRequestSentTimestamp(cf, v10, UpTimeNanoseconds - v18);
      if (v11) {
        goto LABEL_17;
      }
      uint64_t v10 = v19;
    }
    int v9 = FigNetworkHistorySetRequestLatency(cf, v10, UpTimeNanoseconds);
    goto LABEL_15;
  }
  int v11 = 0;
LABEL_17:
  if (cf) {
    CFRelease(cf);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (!v11)
  {
    curl_dispatchDataCallback(object, v17, v14, v2, v4, 0, 0, 0, 0);
    goto LABEL_23;
  }
LABEL_36:
  if (v11 && v17)
  {
    curlh_cleanupRegisteredInfoForRequestID(v3, v2);
    curl_dispatchDataCallbackWithError(object, v17, v14, v2, v15, v4, v11);
  }
LABEL_23:
  if (v15) {
    CFRelease(v15);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (object) {
    dispatch_release(object);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  CFTypeRef v12 = (const void *)a1[2];
  if (v12) {
    CFRelease(v12);
  }
  free(a1);
}

uint64_t figCustomURLWorkQueueDrain(uint64_t result, int a2)
{
  int v2 = *(_DWORD *)(result + 40);
  if (v2 != 4)
  {
    uint64_t v3 = result;
    if (a2 || (v2 - 1) >= 3)
    {
      unsigned int v5 = (void *)(result + 24);
      uint64_t v4 = *(void **)(result + 24);
      *(_DWORD *)(result + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
      if (v4)
      {
        do
        {
          uint64_t v6 = v4[2];
          void *v5 = v6;
          if (!v6) {
            *(void *)(v3 + 32) = v5;
          }
          FigReentrantMutexUnlock(*(pthread_mutex_t **)(v3 + 16));
          ((void (*)(void))*v4)(v4[1]);
          free(v4);
          uint64_t result = FigReentrantMutexLock(*(pthread_mutex_t **)(v3 + 16));
          int v7 = *(_DWORD *)(v3 + 40);
          if ((v7 - 2) < 2)
          {
            *(_DWORD *)(v3 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 3;
            return result;
          }
          if (v7 == 4)
          {
            return FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
          }
          uint64_t v4 = (void *)*v5;
        }
        while (*v5);
        if (v7 != 1) {
          return result;
        }
      }
      *(_DWORD *)(v3 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    }
  }
  return result;
}

uint64_t curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(const void *a1, uint64_t a2, void *a3, void *a4, CFTypeRef *a5, NSObject **a6, void *a7, void *a8, void *a9)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73))
  {
    uint64_t v30 = FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
    goto LABEL_36;
  }
  uint64_t v18 = *(void *)(DerivedStorage + 80);
  if (!v18)
  {
    uint64_t v30 = 4294949922;
    goto LABEL_36;
  }
  uint64_t v34 = a5;
  __int16 v35 = a6;
  uint64_t v36 = a7;
  __int16 v37 = a3;
  CFTypeRef v38 = a4;
  __int16 v39 = a8;
  uint64_t v40 = DerivedStorage;
  CFTypeRef cf = 0;
  uint64_t v42 = 0;
  uint64_t v19 = 0;
  CFDataRef v20 = 0;
  CFTypeRef v21 = 0;
  CFTypeRef v22 = 0;
  CFTypeRef v23 = 0;
  do
  {
    uint64_t v24 = *(void *)(v18 + 64);
    uint64_t v25 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v18 + 8));
    uint64_t v26 = *(void *)v18;
    if (v25)
    {
      uint64_t v27 = v25;
      if (v26 != a2)
      {
LABEL_8:
        CFRelease(v27);
        goto LABEL_10;
      }
      if (!v23)
      {
        CFTypeRef v22 = *(const void **)(v18 + 32);
        CFTypeRef v21 = *(const void **)(v18 + 56);
        CFTypeRef v23 = CFRetain(v25);
        CFDataRef v20 = *(NSObject **)(v18 + 16);
        uint64_t v19 = *(void *)(v18 + 24);
        CFTypeRef cf = *(CFTypeRef *)(v18 + 40);
        uint64_t v42 = *(void *)(v18 + 48);
        goto LABEL_8;
      }
      uint64_t v30 = FigSignalErrorAt(4294949924, 0, 0, 0, 0, 0, 0);
      CFRelease(v27);
      uint64_t DerivedStorage = v40;
LABEL_35:
      CFRelease(v23);
      goto LABEL_36;
    }
    uint64_t v28 = curlh_cleanupRegisteredInfoForRequestID(a1, v26);
    if (v28)
    {
      uint64_t v30 = v28;
      uint64_t DerivedStorage = v40;
      if (!v23) {
        goto LABEL_36;
      }
      goto LABEL_35;
    }
LABEL_10:
    uint64_t v18 = v24;
  }
  while (v24);
  if (v23)
  {
    if (v34) {
      *uint64_t v34 = CFRetain(v23);
    }
    if (v35)
    {
      dispatch_retain(v20);
      *__int16 v35 = v20;
    }
    if (v36) {
      void *v36 = v19;
    }
    uint64_t DerivedStorage = v40;
    if (v37)
    {
      if (v22) {
        CFTypeRef v29 = CFRetain(v22);
      }
      else {
        CFTypeRef v29 = 0;
      }
      void *v37 = v29;
    }
    if (v38)
    {
      if (v21) {
        CFTypeRef v31 = CFRetain(v21);
      }
      else {
        CFTypeRef v31 = 0;
      }
      *CFTypeRef v38 = v31;
    }
    if (v39)
    {
      CFTypeRef v32 = cf;
      if (cf) {
        CFTypeRef v32 = CFRetain(cf);
      }
      *__int16 v39 = v32;
    }
    uint64_t v30 = 0;
    if (a9) {
      *a9 = v42;
    }
    goto LABEL_35;
  }
  uint64_t v30 = 4294949922;
  uint64_t DerivedStorage = v40;
LABEL_36:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v30;
}

void curl_dispatchDataCallback(NSObject *a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5, const void *a6, int a7, const void *a8, const void *a9)
{
  CFTypeRef v17 = malloc_type_calloc(1uLL, 0x40uLL, 0x10E00408CCBC589uLL);
  if (a2) {
    CFTypeRef v18 = CFRetain(a2);
  }
  else {
    CFTypeRef v18 = 0;
  }
  *CFTypeRef v17 = v18;
  v17[1] = a3;
  _OWORD v17[2] = a4;
  if (a5) {
    CFTypeRef v19 = CFRetain(a5);
  }
  else {
    CFTypeRef v19 = 0;
  }
  _OWORD v17[3] = v19;
  if (a6) {
    CFTypeRef v20 = CFRetain(a6);
  }
  else {
    CFTypeRef v20 = 0;
  }
  void v17[4] = v20;
  *((_DWORD *)v17 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = a7;
  if (a8) {
    CFTypeRef v21 = CFRetain(a8);
  }
  else {
    CFTypeRef v21 = 0;
  }
  v17[6] = v21;
  if (a9) {
    CFTypeRef v22 = CFRetain(a9);
  }
  else {
    CFTypeRef v22 = 0;
  }
  void v17[7] = v22;

  dispatch_async_f(a1, v17, (dispatch_function_t)curl_performDataCallbackDispatch);
}

uint64_t curlh_cleanupRegisteredInfoForRequestID(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFTypeRef v12 = 0;
  uint64_t RequestEntryForRequestID = curlh_getRequestEntryForRequestID((uint64_t)a1, a2, &v12);
  if (RequestEntryForRequestID) {
    return RequestEntryForRequestID;
  }
  curlh_removeAndFreeCustomURLRequestEntry((uint64_t)a1, v12);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(DerivedStorage + 16), 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFDictionaryRef v7 = Mutable;
    uint64_t v8 = FigCFDictionarySetInt64(Mutable, @"CURLHRequestCompletedNotificationKey_RequestID", a2);
    if (!v8)
    {
      CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      uint64_t v8 = CMNotificationCenterPostNotification(DefaultLocalCenter, @"CURLHNotification_RequestCompleted", a1, v7);
    }
    uint64_t v10 = v8;
    CFRelease(v7);
    return v10;
  }

  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

void curl_dispatchDataCallbackWithError(NSObject *a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5, CFTypeRef cf, int a7)
{
  CFTypeRef cfa = cf;
  CFTypeRef v12 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (cf)
  {
    CFRetain(cf);
  }
  else if (!a5 || (FigCustomURLResponseInfoCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a5, &cfa), !cfa))
  {
    FigSignalErrorAt(4294949914, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  CFErrorRef v13 = CFErrorCreate(*v12, @"CoreMediaErrorDomain", a7, 0);
  curl_dispatchDataCallback(a1, a2, a3, a4, cfa, 0, 1, v13, 0);
  if (v13) {
    CFRelease(v13);
  }
LABEL_8:
  if (cfa) {
    CFRelease(cfa);
  }
}

uint64_t curlh_getRequestEntryForRequestID(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *a3 = 0;
  uint64_t v6 = *(void **)(DerivedStorage + 80);
  if (v6)
  {
    while (*v6 != a2)
    {
      uint64_t v6 = (void *)v6[8];
      if (!v6) {
        goto LABEL_4;
      }
    }
    *a3 = v6;
    return 0;
  }
  else
  {
LABEL_4:
    return FigSignalErrorAt(4294949922, 0, 0, 0, 0, 0, 0);
  }
}

BOOL curlh_copyNetworkHistoryIfReporting(const void *a1, uint64_t a2, void *a3, void *a4)
{
  CFTypeRef cf = 0;
  if (curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(a1, a2, &cf, 0, 0, 0, 0, a3, a4))
  {
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    BOOL shouldReportToNetworkHistory = curlh_shouldReportToNetworkHistory((uint64_t)a1, (uint64_t)cf);
    if (cf) {
      CFRelease(cf);
    }
    if (shouldReportToNetworkHistory) {
      return *a3 != 0;
    }
  }
  return 0;
}

uint64_t curlh_requestSetDormantOnQueue(const void *a1, uint64_t a2, int a3, void *a4)
{
  v46[16] = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFTypeRef v32 = 0;
  CFTypeRef v33 = 0;
  dispatch_object_t object = 0;
  CFTypeRef v31 = 0;
  CFTypeRef cf = 0;
  uint64_t v29 = 0;
  uint64_t v27 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73))
  {
    FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  if (curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(a1, a2, &v32, &v31, &v33, &object, &v29, 0, 0))goto LABEL_28; {
  if (!curlh_copyNetworkHistoryIfReporting(a1, a2, &cf, &v27) || (v27 == 0) == a3)
  }
    goto LABEL_26;
  int64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  if (a3)
  {
    if (dword_1EB28B5F0)
    {
      LODWORD(v26) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, (int *)&v26, type);
      unsigned int v11 = v26;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0])) {
        unsigned int v13 = v11;
      }
      else {
        unsigned int v13 = v11 & 0xFFFFFFFE;
      }
      if (v13)
      {
        uint64_t v14 = *(void *)(DerivedStorage + 24);
        int v34 = 136316418;
        __int16 v35 = "curlh_requestSetDormantOnQueue";
        __int16 v36 = 2082;
        uint64_t v37 = v14;
        __int16 v38 = 2048;
        __int16 v39 = a1;
        __int16 v40 = 2048;
        uint64_t v41 = a2;
        __int16 v42 = 2048;
        uint64_t v43 = v27;
        __int16 v44 = 2048;
        double v45 = (double)UpTimeNanoseconds / 1000000000.0;
        CFTypeRef v15 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v26;
      }
      else
      {
        CFTypeRef v15 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v15, v15 != v46, v11, 0, v12);
    }
    FigNetworkHistoryRequestBecameInactive(cf, v27, UpTimeNanoseconds);
    uint64_t v22 = 0;
    uint64_t v27 = 0;
  }
  else
  {
    uint64_t v26 = 1000000;
    FigCFDictionaryGetInt64IfPresent((uint64_t)v32, @"RequestInfoDefaultLatency", &v26);
    FigNetworkHistoryRequestBecameActive(cf, UpTimeNanoseconds - v26, &v27);
    FigNetworkHistorySetRequestLatency(cf, v27, UpTimeNanoseconds);
    if (dword_1EB28B5F0)
    {
      *(_DWORD *)os_log_type_t type = 0;
      os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
      uint64_t v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, (int *)type, &v24);
      unsigned int v17 = *(_DWORD *)type;
      if (os_log_type_enabled(v16, v24)) {
        unsigned int v19 = v17;
      }
      else {
        unsigned int v19 = v17 & 0xFFFFFFFE;
      }
      if (v19)
      {
        uint64_t v20 = *(void *)(DerivedStorage + 24);
        int v34 = 136316418;
        __int16 v35 = "curlh_requestSetDormantOnQueue";
        __int16 v36 = 2082;
        uint64_t v37 = v20;
        __int16 v38 = 2048;
        __int16 v39 = a1;
        __int16 v40 = 2048;
        uint64_t v41 = a2;
        __int16 v42 = 2048;
        uint64_t v43 = v27;
        __int16 v44 = 2048;
        double v45 = (double)UpTimeNanoseconds / 1000000000.0;
        CFTypeRef v21 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(v17) = type[0];
      }
      else
      {
        CFTypeRef v21 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v21, v21 != v46, v17, 0, v18);
    }
    uint64_t v22 = v27;
  }
  v46[0] = 0;
  if (!curlh_getRequestEntryForRequestID((uint64_t)a1, a2, v46))
  {
    *(void *)(v46[0] + 48) = v22;
LABEL_26:
    if (a4) {
      *a4 = v27;
    }
  }
LABEL_28:
  if (cf) {
    CFRelease(cf);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v31) {
    CFRelease(v31);
  }
  if (object) {
    dispatch_release(object);
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
}

BOOL curlh_shouldReportToNetworkHistory(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  Boolean v6 = 0;
  FigCFDictionaryGetBooleanIfPresent(a2, @"RequestInfoExpectedToBlock", &v6);
  return *(unsigned char *)(DerivedStorage + 72) && v6 == 0;
}

void curl_performDataCallbackDispatch(uint64_t a1)
{
  (*(void (**)(void, void, void, void, void, void, void))(a1 + 8))(*(void *)a1, *(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), *(unsigned int *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  int v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }
  unsigned int v5 = *(const void **)(a1 + 56);
  if (v5) {
    CFRelease(v5);
  }

  free((void *)a1);
}

void curlh_sendDataDispatch(uint64_t *a1)
{
  uint64_t v3 = (const void *)*a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (OpaqueCMBlockBuffer *)a1[2];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  dispatch_object_t object = 0;
  CFTypeRef v20 = 0;
  CFTypeRef v17 = 0;
  uint64_t v18 = 0;
  CFTypeRef v15 = 0;
  CFTypeRef v16 = 0;
  uint64_t v14 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73))
  {
    uint64_t v13 = 4294949925;
LABEL_32:
    int v6 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  int v6 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &v17, &v16, &v20, &object, &v18, 0, 0);
  if (v6)
  {
LABEL_33:
    int v11 = v6;
    goto LABEL_34;
  }
  if (!v16)
  {
    uint64_t v13 = 4294949921;
    goto LABEL_32;
  }
  if (curlh_copyNetworkHistoryIfReporting(v3, v2, &v15, &v14) && !v14) {
    curlh_requestSetDormantOnQueue(v3, v2, 0, &v14);
  }
  uint64_t v21 = 0;
  CFTypeRef cf = 0;
  if (!v4) {
    goto LABEL_14;
  }
  if (curlh_copyNetworkHistoryIfReporting(v3, v2, &cf, &v21))
  {
    uint64_t v8 = v21;
    CFTypeRef v7 = cf;
    size_t DataLength = CMBlockBufferGetDataLength(v4);
    unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    int v11 = FigNetworkHistoryRequestReceivedBytes(v7, v8, DataLength, UpTimeNanoseconds);
  }
  else
  {
    int v11 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (!v11)
  {
LABEL_14:
    curl_dispatchDataCallback(object, v20, v18, v2, v16, v4, 0, 0, 0);
    goto LABEL_15;
  }
LABEL_34:
  if (v11 && v20)
  {
    curlh_cleanupRegisteredInfoForRequestID(v3, v2);
    curl_dispatchDataCallbackWithError(object, v20, v18, v2, v17, v16, v11);
  }
LABEL_15:
  if (v15) {
    CFRelease(v15);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (object) {
    dispatch_release(object);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  uint64_t v12 = (const void *)a1[2];
  if (v12) {
    CFRelease(v12);
  }
  free(a1);
}

void curlh_finishLoadingDispatch(uint64_t *a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (const void *)*a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (__CFError *)a1[2];
  unsigned int v5 = (const void *)a1[3];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  dispatch_object_t object = 0;
  CFTypeRef v33 = 0;
  CFTypeRef cf = 0;
  uint64_t v31 = 0;
  CFDictionaryRef theDict = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73))
  {
    int v7 = FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    goto LABEL_48;
  }
  int v7 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &cf, &theDict, &v33, &object, &v31, 0, 0);
  if (!v7)
  {
    CFDictionaryRef v8 = theDict;
    if (!theDict)
    {
      int v7 = FigCustomURLResponseInfoCreate(*(const __CFAllocator **)(DerivedStorage + 16), cf, (CFTypeRef *)&theDict);
      if (v7) {
        goto LABEL_48;
      }
      CFDictionaryRef v8 = theDict;
    }
    int v9 = (const void *)*MEMORY[0x1E4F1CFD0];
    if (v9 == CFDictionaryGetValue(v8, @"ResponseInfoSuppressErrorLogging"))
    {
      if (dword_1EB28B5F0)
      {
        int v28 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v28, &type);
        int v16 = v28;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v17 = v16;
        }
        else {
          unsigned int v17 = v16 & 0xFFFFFFFE;
        }
        if (v17)
        {
          uint64_t v18 = *(void *)(DerivedStorage + 24);
          unsigned int v19 = "suppressed";
          if (!v4) {
            unsigned int v19 = 0;
          }
          int v34 = 136316162;
          __int16 v35 = "curlh_finishLoadingOnQueue";
          __int16 v36 = 2082;
          uint64_t v37 = v18;
          __int16 v38 = 2048;
          __int16 v39 = v3;
          __int16 v40 = 2048;
          uint64_t v41 = v2;
          __int16 v42 = 2080;
          uint64_t v43 = (void *)v19;
          CFTypeRef v20 = (unsigned char *)_os_log_send_and_compose_impl();
          LOBYTE(v16) = v28;
        }
        else
        {
          CFTypeRef v20 = 0;
        }
        uint64_t v21 = (uint64_t *)qword_1EB28B5E8;
        BOOL v22 = v20 != v46;
        char v23 = v16;
        goto LABEL_28;
      }
    }
    else if (dword_1EB28B5F0)
    {
      int v28 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v28, &type);
      LODWORD(v11) = v28;
      if (os_log_type_enabled(v10, type)) {
        int v13 = v11;
      }
      else {
        int v13 = v11 & 0xFFFFFFFE;
      }
      if (v13)
      {
        uint64_t v11 = *(void *)(DerivedStorage + 24);
        if (v4) {
          int Code = CFErrorGetCode(v4);
        }
        else {
          int Code = 0;
        }
        int v34 = 136316419;
        __int16 v35 = "curlh_finishLoadingOnQueue";
        __int16 v36 = 2082;
        uint64_t v37 = v11;
        __int16 v38 = 2048;
        __int16 v39 = v3;
        __int16 v40 = 2048;
        uint64_t v41 = v2;
        __int16 v42 = 2113;
        uint64_t v43 = v4;
        __int16 v44 = 1024;
        int v45 = Code;
        CFTypeRef v20 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v28;
      }
      else
      {
        CFTypeRef v20 = 0;
      }
      uint64_t v21 = (uint64_t *)qword_1EB28B5E8;
      BOOL v22 = v20 != v46;
      char v23 = v11;
LABEL_28:
      fig_log_call_emit_and_clean_up_after_send_and_compose(v21, 1u, 1, v20, v22, v23, 0, v12);
    }
    int v7 = curlh_networkHistoryRequestBecameInactive(v3, v2);
    if (!v7)
    {
      int v7 = curlh_cleanupRegisteredInfoForRequestID(v3, v2);
      if (!v7)
      {
        curl_dispatchDataCallback(object, v33, v31, v2, theDict, 0, 1, v4, v5);
        goto LABEL_32;
      }
    }
  }
LABEL_48:
  int v26 = v7;
  if (v7 && v33)
  {
    curlh_cleanupRegisteredInfoForRequestID(v3, v2);
    curl_dispatchDataCallbackWithError(object, v33, v31, v2, cf, theDict, v26);
  }
LABEL_32:
  if (cf) {
    CFRelease(cf);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (object) {
    dispatch_release(object);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  os_log_type_t v24 = (const void *)a1[2];
  if (v24) {
    CFRelease(v24);
  }
  uint64_t v25 = (const void *)a1[3];
  if (v25) {
    CFRelease(v25);
  }
  free(a1);
}

uint64_t curlh_networkHistoryRequestBecameInactive(const void *a1, uint64_t a2)
{
  uint64_t v7 = 0;
  CFTypeRef cf = 0;
  uint64_t v2 = 0;
  if (curlh_copyNetworkHistoryIfReporting(a1, a2, &cf, &v7))
  {
    uint64_t v3 = v7;
    if (v7)
    {
      CFTypeRef v4 = cf;
      unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      uint64_t v2 = FigNetworkHistoryRequestBecameInactive(v4, v3, UpTimeNanoseconds);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

void curlh_handleRequestDispatch(const __CFData *a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  BytePtr = (uint64_t *)CFDataGetBytePtr(a1);
  CFTypeRef v4 = (const void *)*BytePtr;
  uint64_t v3 = (const void *)BytePtr[1];
  uint64_t v5 = BytePtr[2];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*BytePtr);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73))
  {
    int v26 = FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    CFDictionaryRef v8 = 0;
    goto LABEL_36;
  }
  uint64_t v7 = CMBaseObjectGetDerivedStorage((uint64_t)v4);
  CFDictionaryRef v8 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v7 + 32));
  if (!v8)
  {
    int v26 = -17373;
    goto LABEL_37;
  }
  if (dword_1EB28B5F0)
  {
    int v43 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v43, &type);
    int v10 = v43;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v12 = v10;
    }
    else {
      unsigned int v12 = v10 & 0xFFFFFFFE;
    }
    if (v12)
    {
      uint64_t v13 = *(void *)(DerivedStorage + 24);
      int v44 = 136315906;
      int v45 = "curlh_handleRequestOnQueue";
      __int16 v46 = 2082;
      uint64_t v47 = v13;
      __int16 v48 = 2048;
      BOOL v49 = v4;
      __int16 v50 = 2048;
      uint64_t v51 = v5;
      uint64_t v14 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v43;
    }
    else
    {
      uint64_t v14 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v14, v14 != v52, v10, 0, v11);
  }
  CFTypeRef v15 = (uint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)v4);
  if (performHandleRequestCallbackRec_getCFAllocator_sOnceToken != -1) {
    dispatch_once_f(&performHandleRequestCallbackRec_getCFAllocator_sOnceToken, &performHandleRequestCallbackRec_getCFAllocator_sAllocator, (dispatch_function_t)performHandleRequestCallbackRec_initializeCFAllocatorOnce);
  }
  CFAllocatorRef v16 = (const __CFAllocator *)performHandleRequestCallbackRec_getCFAllocator_sAllocator;
  if (performHandleRequestCallbackRec_getCFAllocator_sAllocator
    || (int v27 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0)) == 0)
  {
    unsigned int v17 = (const UInt8 *)malloc_type_calloc(1uLL, 0x38uLL, 0x10E0040A6443F3CuLL);
    if (v17)
    {
      uint64_t v18 = (UInt8 *)v17;
      CFDataRef v19 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v17, 56, v16);
      if (v19)
      {
        CFDataRef v20 = v19;
        *(void *)uint64_t v18 = v15[7];
        *((void *)v18 + 1) = CFRetain(v8);
        if (v4) {
          CFTypeRef v21 = CFRetain(v4);
        }
        else {
          CFTypeRef v21 = 0;
        }
        *((void *)v18 + 2) = v21;
        *((void *)v18 + 3) = v5;
        if (v3) {
          CFTypeRef v22 = CFRetain(v3);
        }
        else {
          CFTypeRef v22 = 0;
        }
        *((void *)v18 + 4) = v22;
        *((void *)v18 + 5) = curlh_handleRequestCompletionHandlerDispatch;
        if (a1) {
          CFTypeRef v23 = CFRetain(a1);
        }
        else {
          CFTypeRef v23 = 0;
        }
        *((void *)v18 + 6) = v23;
        figCustomURLWorkQueueSuspendDraining(*v15);
        os_log_type_t v24 = v15[5];
        uint64_t v25 = (void *)CFRetain(v20);
        dispatch_async_f(v24, v25, (dispatch_function_t)curlh_performHandleRequestCallbackDispatch);
        CFRelease(v20);
        goto LABEL_26;
      }
      free(v18);
    }
    int v26 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_36:
    if (!v26) {
      goto LABEL_44;
    }
    goto LABEL_37;
  }
  int v26 = v27;
LABEL_37:
  int v28 = (uint64_t *)CFDataGetBytePtr(a1);
  uint64_t v29 = (const void *)*v28;
  uint64_t v30 = CMBaseObjectGetDerivedStorage(*v28);
  uint64_t v31 = malloc_type_calloc(1uLL, 0x20uLL, 0x10E004018FB7DF4uLL);
  if (v31)
  {
    CFTypeRef v32 = v31;
    if (v29) {
      CFTypeRef v33 = CFRetain(v29);
    }
    else {
      CFTypeRef v33 = 0;
    }
    *CFTypeRef v32 = v33;
    v32[1] = v28[6];
    CFTypeRef v34 = (CFTypeRef)v28[7];
    if (v34) {
      CFTypeRef v34 = CFRetain(v34);
    }
    _OWORD v32[2] = v34;
    *((_DWORD *)v32 + 6) = v26;
    figCustomURLWorkQueueSuspendDraining(*(void *)v30);
    dispatch_async_f(*(dispatch_queue_t *)(v30 + 40), v32, (dispatch_function_t)curlh_haltHandleRequestBeforeCallbackDueToErrorDispatch);
  }
  else
  {
    uint64_t v35 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v35)
    {
      uint64_t v36 = v35;
      int v43 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v37 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 0, &v43, &type);
      int v38 = v43;
      if (os_log_type_enabled(v37, type)) {
        unsigned int v40 = v38;
      }
      else {
        unsigned int v40 = v38 & 0xFFFFFFFE;
      }
      if (v40)
      {
        int v44 = 136315138;
        int v45 = "curlh_haltHandleRequestBeforeCallbackDueToError";
        uint64_t v41 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v38) = v43;
      }
      else
      {
        uint64_t v41 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 0, 1, v41, v41 != v52, v38, 0, v39);
      ((void (*)(uint64_t, void, uint64_t))v28[6])(v28[7], 0, v36);
    }
  }
LABEL_44:
  if (v8) {
LABEL_26:
  }
    CFRelease(v8);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (a1) {
    CFRelease(a1);
  }
}

uint64_t handleRequestRec_initializeCFAllocatorOnce(void *a1)
{
  CFTypeRef v3 = 0;
  uint64_t result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))handleRequestRec_dealloc, &v3);
  if (!result) {
    *a1 = v3;
  }
  return result;
}

void handleRequestRec_dealloc(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = a1[1];
  if (v3) {
    CFRelease(v3);
  }
  CFTypeRef v4 = a1[3];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = a1[4];
  if (v5) {
    dispatch_release(v5);
  }
  int v6 = a1[7];
  if (v6) {
    CFRelease(v6);
  }

  free(a1);
}

uint64_t curlh_handleRequestCompletionHandlerDispatch(const __CFData *a1, unsigned int a2, uint64_t a3)
{
  v53[16] = *MEMORY[0x1E4F143B8];
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t v6 = *(void *)BytePtr;
  CFDictionaryRef v7 = (const __CFDictionary *)*((void *)BytePtr + 1);
  uint64_t v8 = *((void *)BytePtr + 3);
  uint64_t v38 = *((void *)BytePtr + 2);
  long long v39 = *((_OWORD *)BytePtr + 2);
  int v9 = (uint64_t (*)(void, void, void))*((void *)BytePtr + 6);
  uint64_t v10 = *((void *)BytePtr + 7);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)BytePtr);
  CFTypeRef value = 0;
  if (a3) {
    goto LABEL_34;
  }
  uint64_t v12 = DerivedStorage;
  if (!a2) {
    goto LABEL_21;
  }
  v53[0] = 0;
  uint64_t v37 = DerivedStorage;
  if (!curlh_shouldReportToNetworkHistory(v6, (uint64_t)v7))
  {
    uint64_t v17 = v10;
    uint64_t v18 = v9;
    uint64_t v19 = 0;
    uint64_t v14 = 0;
    goto LABEL_11;
  }
  int ValueIfPresent = CFDictionaryGetValueIfPresent(v7, @"RequestInfoNetworkHistory", (const void **)&value);
  if (!value)
  {
    uint64_t v14 = 0;
    if (ValueIfPresent) {
      goto LABEL_6;
    }
LABEL_10:
    uint64_t v17 = v10;
    uint64_t v18 = v9;
    uint64_t v19 = 0;
    goto LABEL_11;
  }
  CFRetain(value);
  uint64_t v14 = value;
  if (!ValueIfPresent) {
    goto LABEL_10;
  }
LABEL_6:
  unint64_t UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  uint64_t v16 = FigNetworkHistoryRequestBecameActive(v14, UpTimeNanoseconds, v53);
  if (v16)
  {
    a3 = v16;
    goto LABEL_32;
  }
  uint64_t v17 = v10;
  uint64_t v18 = v9;
  uint64_t v14 = value;
  uint64_t v19 = v53[0];
LABEL_11:
  uint64_t v20 = CMBaseObjectGetDerivedStorage(v6);
  CFTypeRef v21 = CFAllocatorAllocate(*(CFAllocatorRef *)(v20 + 16), 80, 0);
  CFTypeRef v22 = v21;
  if (v21)
  {
    *CFTypeRef v21 = v38;
    dispatch_retain((dispatch_object_t)v39);
    *((_OWORD *)v22 + 1) = v39;
    CFTypeRef v23 = v7 ? CFRetain(v7) : 0;
    v22[4] = v23;
    v22[7] = 0;
    CFTypeRef v24 = v14 ? CFRetain(v14) : 0;
    void v22[5] = v24;
    v22[6] = v19;
    CFTypeRef v25 = FigCFWeakReferenceHolderCreateWithReferencedObject(v8);
    v22[1] = v25;
    if (v25)
    {
      v22[8] = 0;
      int v26 = *(void **)(v20 + 88);
      v22[9] = v26;
      void *v26 = v22;
      *(void *)(v20 + 88) = v22 + 8;
LABEL_20:
      int v9 = v18;
      uint64_t v10 = v17;
      uint64_t v12 = v37;
LABEL_21:
      if (dword_1EB28B5F0)
      {
        int v41 = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v41, &type);
        int v28 = v41;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v30 = v28;
        }
        else {
          unsigned int v30 = v28 & 0xFFFFFFFE;
        }
        if (v30)
        {
          uint64_t v31 = "YES";
          uint64_t v32 = *(void *)(v12 + 24);
          int v44 = "curlh_handleRequestCompletionHandler";
          __int16 v45 = 2082;
          int v43 = 136316162;
          if (!a2) {
            uint64_t v31 = "NO";
          }
          uint64_t v46 = v32;
          __int16 v47 = 2048;
          uint64_t v48 = v6;
          __int16 v49 = 2048;
          uint64_t v50 = v38;
          __int16 v51 = 2080;
          int v52 = v31;
          CFTypeRef v33 = (uint64_t *)_os_log_send_and_compose_impl();
          LOBYTE(v28) = v41;
        }
        else
        {
          CFTypeRef v33 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v33, v33 != v53, v28, 0, v29);
      }
      a3 = 0;
      goto LABEL_32;
    }
  }
  uint64_t v36 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  if (!v36) {
    goto LABEL_20;
  }
  a3 = v36;
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v20 + 16), v22);
  int v9 = v18;
  uint64_t v10 = v17;
LABEL_32:
  if (value) {
    CFRelease(value);
  }
LABEL_34:
  if (a3) {
    uint64_t v34 = 0;
  }
  else {
    uint64_t v34 = a2;
  }
  return v9(v10, v34, a3);
}

uint64_t figCustomURLWorkQueueSuspendDraining(uint64_t a1)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  unsigned int v2 = *(_DWORD *)(a1 + 40);
  if (v2 >= 4)
  {
    if (v2 == 4) {
      FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 2;
  }
  CFTypeRef v3 = *(pthread_mutex_t **)(a1 + 16);

  return FigReentrantMutexUnlock(v3);
}

uint64_t curlh_performHandleRequestCallbackDispatch(const __CFData *a1)
{
  BytePtr = CFDataGetBytePtr(a1);
  CFTypeRef v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void (*)(const __CFData *, uint64_t, uint64_t), const __CFData *))BytePtr;
  uint64_t v5 = *((void *)BytePtr + 3);
  uint64_t v4 = *((void *)BytePtr + 4);
  uint64_t v6 = *((void *)BytePtr + 2);
  uint64_t v7 = *((void *)BytePtr + 1);

  return v3(v7, v6, v4, v5, curlh_handleRequestCallbackShimCompletionHandler, a1);
}

uint64_t performHandleRequestCallbackRec_initializeCFAllocatorOnce(void *a1)
{
  CFTypeRef v3 = 0;
  uint64_t result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))performHandleRequestCallbackRec_dealloc, &v3);
  if (!result) {
    *a1 = v3;
  }
  return result;
}

void performHandleRequestCallbackRec_dealloc(void *a1)
{
  unsigned int v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = (const void *)a1[2];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[6];
  if (v5) {
    CFRelease(v5);
  }

  free(a1);
}

void curlh_handleRequestCallbackShimCompletionHandler(const __CFData *a1, uint64_t a2, uint64_t a3)
{
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*((void *)BytePtr + 2));
  (*((void (**)(void, uint64_t, uint64_t))BytePtr + 5))(*((void *)BytePtr + 6), a2, a3);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(unsigned char *)(DerivedStorage + 73)) {
    figCustomURLWorkQueueResumeDraining(*(void *)DerivedStorage);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (a1)
  {
    CFRelease(a1);
  }
}

uint64_t figCustomURLWorkQueueResumeDraining(uint64_t a1)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  unsigned int v2 = *(_DWORD *)(a1 + 40);
  if (v2 >= 3)
  {
    if (v2 == 3)
    {
      figCustomURLWorkQueueDrain(a1, 1);
    }
    else if (v2 == 4)
    {
      FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
  }
  CFTypeRef v3 = *(pthread_mutex_t **)(a1 + 16);

  return FigReentrantMutexUnlock(v3);
}

void curlh_haltHandleRequestBeforeCallbackDueToErrorDispatch(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)a1);
  (*(void (**)(void, void, void))(a1 + 8))(*(void *)(a1 + 16), 0, *(unsigned int *)(a1 + 24));
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73)) {
    FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
  }
  else {
    figCustomURLWorkQueueResumeDraining(*(void *)DerivedStorage);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  CFTypeRef v3 = *(const void **)(a1 + 16);
  if (v3) {
    CFRelease(v3);
  }

  free((void *)a1);
}

void curlh_cancelRequestDispatch(uint64_t *a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = (const void *)*a1;
  uint64_t v3 = a1[1];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  CFTypeRef v26 = 0;
  CFTypeRef cf = 0;
  dispatch_object_t object = 0;
  CFTypeRef v25 = 0;
  uint64_t v23 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 73))
  {
    FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    uint64_t v12 = 0;
  }
  else
  {
    if (dword_1EB28B5F0)
    {
      int v22 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v22, &type);
      int v6 = v22;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v8 = v6;
      }
      else {
        unsigned int v8 = v6 & 0xFFFFFFFE;
      }
      if (v8)
      {
        uint64_t v9 = *(void *)(DerivedStorage + 24);
        int v28 = 136315906;
        uint64_t v29 = "curlh_cancelRequestOnQueue";
        __int16 v30 = 2082;
        uint64_t v31 = v9;
        __int16 v32 = 2048;
        CFTypeRef v33 = v2;
        __int16 v34 = 2048;
        uint64_t v35 = v3;
        uint64_t v10 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v6) = v22;
      }
      else
      {
        uint64_t v10 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v10, v10 != &v36, v6, 0, v7);
    }
    uint64_t v11 = CMBaseObjectGetDerivedStorage((uint64_t)v2);
    uint64_t v12 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v11 + 32));
    if (v12
      && !curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v2, v3, &v26, &v25, &cf, &object, &v23, 0, 0)&& (v25|| !FigCustomURLResponseInfoCreateMutable(*(const __CFAllocator **)(DerivedStorage + 16), v26, &v25))&& !curlh_networkHistoryRequestBecameInactive(v2, v3))
    {
      CFTypeRef v13 = v26;
      uint64_t v14 = CMBaseObjectGetDerivedStorage((uint64_t)v2);
      CFTypeRef v15 = (void *)(v14 + 64);
      if (!*(void *)(v14 + 64)) {
        goto LABEL_24;
      }
      uint64_t v16 = v14;
      uint64_t v17 = malloc_type_calloc(1uLL, 0x28uLL, 0x10E00409DBA6119uLL);
      if (v17)
      {
        uint64_t v18 = v17;
        *uint64_t v17 = *v15;
        v17[1] = CFRetain(v12);
        if (v2) {
          CFTypeRef v19 = CFRetain(v2);
        }
        else {
          CFTypeRef v19 = 0;
        }
        int v18[2] = v19;
        _OWORD v18[3] = v3;
        if (v13) {
          CFTypeRef v20 = CFRetain(v13);
        }
        else {
          CFTypeRef v20 = 0;
        }
        _OWORD v18[4] = v20;
        dispatch_async_f(*(dispatch_queue_t *)(v16 + 40), v18, (dispatch_function_t)curlh_performRequestCancelledCallbackDispatch);
        goto LABEL_24;
      }
      if (!FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0))
      {
LABEL_24:
        curl_dispatchDataCallback(object, cf, v23, v3, v25, 0, 2, 0, 0);
        curlh_cleanupRegisteredInfoForRequestID(v2, v3);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (object) {
    dispatch_release(object);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  free(a1);
}

void curlh_performRequestCancelledCallbackDispatch(void *a1)
{
  ((void (*)(void, void, void, void))*a1)(a1[1], a1[2], a1[4], a1[3]);
  unsigned int v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[2];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4) {
    CFRelease(v4);
  }

  free(a1);
}

void curlh_requestSetDormantDispatch(uint64_t a1)
{
  curlh_requestSetDormantOnQueue(*(const void **)a1, *(void *)(a1 + 8), *(unsigned __int8 *)(a1 + 16), 0);
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }

  free((void *)a1);
}

void curlh_lookupAndRetainRegisteredInfoForRequestIDDispatch(uint64_t a1)
{
  CFTypeRef v2 = *(CFTypeRef *)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void (**)(CFTypeRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef, NSObject *, uint64_t, uint64_t, uint64_t))(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  CFTypeRef v14 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v6 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v2, v3, &v13, &v12, &v14, &v11, &v10, &v9, &v8);
  v5(v2, v3, v4, v6, v13, v12, v14, v11, v10, v9, v8);
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  uint64_t v7 = *(const void **)(a1 + 24);
  if (v7) {
    CFRelease(v7);
  }
  free((void *)a1);
}

uint64_t figCustomURLWorkQueueRegisterType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCustomURLWorkQueueCFTypeID TypeID = result;
  return result;
}

double figCustomURLWorkQueueInit(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

uint64_t figCustomURLWorkQueueFinalize(uint64_t a1)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(_DWORD *)(a1 + 40) != 4)
  {
    uint64_t v3 = (void *)(a1 + 24);
    CFTypeRef v2 = *(void **)(a1 + 24);
    *(_DWORD *)(a1 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 4;
    if (v2)
    {
      do
      {
        uint64_t v4 = v2[2];
        *uint64_t v3 = v4;
        if (!v4) {
          *(void *)(a1 + 32) = v3;
        }
        free(v2);
        CFTypeRef v2 = (void *)*v3;
      }
      while (*v3);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v5 = *(void *)(a1 + 16);

  return FigReentrantMutexDestroy(v5);
}

CFStringRef figCustomURLWorkQueueCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCustomURLWorkQueue %p]", a1);
}

CFStringRef figCustomURLWorkQueueCopyDebugDesc(uint64_t a1)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      ++v3;
      uint64_t v2 = *(void *)(v2 + 16);
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v5 = CFGetRetainCount((CFTypeRef)a1);
  CFStringRef v6 = CFStringCreateWithFormat(v4, 0, @"[FigCustomURLWorkQueue %p (%d) { %zu jobs enqueued; state = %d }]",
         a1,
         v5,
         v3,
         *(unsigned int *)(a1 + 40));
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v6;
}

CFStringRef FigCustomURLLoaderCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCustomURLLoader %p]", a1);
}

uint64_t curll_invalidate(const void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(unsigned char *)(DerivedStorage + 24))
  {
    *(unsigned char *)(DerivedStorage + 24) = 1;
    if (dword_1EB28B5F0)
    {
      v18[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, v18, &type);
      int v4 = v18[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v6 = v4;
      }
      else {
        unsigned int v6 = v4 & 0xFFFFFFFE;
      }
      if (v6)
      {
        v18[1] = 136315394;
        CFTypeRef v19 = "curll_invalidate";
        __int16 v20 = 2048;
        CFTypeRef v21 = a1;
        uint64_t v7 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v18[0];
      }
      else
      {
        uint64_t v7 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v7, v7 != &v22, v4, 0, v5);
    }
    uint64_t v8 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    if (CFArrayGetCount(*(CFArrayRef *)(v8 + 48)) >= 1)
    {
      CFIndex v9 = 0;
      do
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v8 + 48), v9);
        CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        if (FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)curll_requestCompletedNote, @"CURLHNotification_RequestCompleted", ValueAtIndex))break; {
        ++v9;
        }
      }
      while (v9 < CFArrayGetCount(*(CFArrayRef *)(v8 + 48)));
    }
    uint64_t v12 = *(const void **)(DerivedStorage + 16);
    if (v12)
    {
      CFRelease(v12);
      *(void *)(DerivedStorage + 16) = 0;
    }
    uint64_t v13 = *(const void **)(DerivedStorage + 40);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    }
    CFTypeRef v14 = *(const void **)(DerivedStorage + 48);
    if (v14)
    {
      CFRelease(v14);
      *(void *)(DerivedStorage + 48) = 0;
    }
    CFTypeRef v15 = *(const void **)(DerivedStorage + 56);
    if (v15)
    {
      CFRelease(v15);
      *(void *)(DerivedStorage + 56) = 0;
    }
    if (*(void *)DerivedStorage)
    {
      CFRelease(*(CFTypeRef *)DerivedStorage);
      *(void *)uint64_t DerivedStorage = 0;
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return 0;
}

uint64_t curll_finalize(const void *a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  curll_invalidate(a1);
  uint64_t v3 = *(void *)(DerivedStorage + 8);

  return FigReentrantMutexDestroy(v3);
}

uint64_t curll_copyDebugDescription()
{
  return 0;
}

uint64_t curll_copyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFNumberRef *a4)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v11 = 4294949915;
LABEL_11:
    uint64_t v9 = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  if (!a4)
  {
    uint64_t v11 = 4294949916;
    goto LABEL_11;
  }
  if (!FigCFEqual(@"CURLLProperty_AllowedCommonMediaClientDataKeys", a2))
  {
    uint64_t v9 = 4294954512;
    goto LABEL_7;
  }
  CFNumberRef UInt64 = FigCFNumberCreateUInt64(a3, *(void *)(DerivedStorage + 32));
  *a4 = UInt64;
  if (!UInt64)
  {
    uint64_t v11 = 4294954510;
    goto LABEL_11;
  }
  uint64_t v9 = 0;
LABEL_7:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v9;
}

uint64_t curll_setProperty(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v8 = 4294949915;
LABEL_11:
    a3 = FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  if (!FigCFEqual(@"CURLLProperty_AllowedCommonMediaClientDataKeys", a2))
  {
    a3 = 4294954512;
    goto LABEL_8;
  }
  if (!a3)
  {
    *(void *)(DerivedStorage + 32) = 0;
    goto LABEL_8;
  }
  CFTypeID v6 = CFGetTypeID((CFTypeRef)a3);
  if (v6 != CFNumberGetTypeID())
  {
    uint64_t v8 = 4294949916;
    goto LABEL_11;
  }
  *(void *)(DerivedStorage + 32) = 0;
  CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, (void *)(DerivedStorage + 32));
  a3 = 0;
LABEL_8:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return a3;
}

void curll_requestCompletedNote(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  uint64_t v13 = 0;
  if (!FigCFDictionaryGetInt64IfPresent(a5, @"CURLHRequestCompletedNotificationKey_RequestID", &v13))return; {
  if (*(unsigned char *)(DerivedStorage + 24))
  }
  {
    uint64_t v12 = 4294949915;
LABEL_14:
    FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    return;
  }
  uint64_t v8 = malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
  if (!v8)
  {
    uint64_t v12 = 4294954510;
    goto LABEL_14;
  }
  uint64_t v9 = (uint64_t)v8;
  if (a2) {
    CFTypeRef v10 = CFRetain(a2);
  }
  else {
    CFTypeRef v10 = 0;
  }
  uint64_t v11 = v13;
  *(void *)uint64_t v9 = v10;
  *(void *)(v9 + 8) = v11;
  if (figCustomURLWorkQueueEnqueue(*(void *)DerivedStorage, (uint64_t)curll_unregisterHandlerForRequestDispatch, v9))
  {
    if (*(void *)v9) {
      CFRelease(*(CFTypeRef *)v9);
    }
    free((void *)v9);
  }
}

void curll_unregisterHandlerForRequestDispatch(uint64_t *a1)
{
  curll_unregisterHandlerForRequestOnQueue(*a1, a1[1]);
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }

  free(a1);
}

uint64_t curll_unregisterHandlerForRequestOnQueue(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24)) {
    uint64_t v4 = FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
  }
  else {
    uint64_t v4 = FigCFWeakReferenceTableRemoveValue(*(void *)(DerivedStorage + 56), a2);
  }
  uint64_t v5 = v4;
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v5;
}

uint64_t curll_installHandler(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v17 = 4294949915;
LABEL_16:
    uint64_t v12 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 40), a2))
  {
    uint64_t v17 = 4294949914;
    goto LABEL_16;
  }
  if (dword_1EB28B5F0)
  {
    v19[0] = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, v19, &type);
    int v8 = v19[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v10 = v8;
    }
    else {
      unsigned int v10 = v8 & 0xFFFFFFFE;
    }
    if (v10)
    {
      v19[1] = 136315906;
      __int16 v20 = "curll_installHandler";
      __int16 v21 = 2048;
      uint64_t v22 = DerivedStorage;
      __int16 v23 = 2048;
      CFTypeRef v24 = a2;
      __int16 v25 = 2048;
      uint64_t v26 = a3;
      uint64_t v11 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v19[0];
    }
    else
    {
      uint64_t v11 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v11, v11 != &v27, v8, 0, v9);
  }
  uint64_t v12 = FigCFDictionarySetCFIndex(*(void **)(DerivedStorage + 40), a2, a3);
  if (!v12)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 48), a2);
    CFArrayRef v13 = *(const __CFArray **)(DerivedStorage + 48);
    v29.CFIndex length = CFArrayGetCount(v13);
    v29.CFIndex location = 0;
    CFArraySortValues(v13, v29, (CFComparatorFunction)curll_compareHandlersByPriority, (void *)DerivedStorage);
    CFNotificationCenterRef DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    uint64_t v12 = FigNotificationCenterAddWeakListener(DefaultLocalCenter, a1, (CFNotificationCallback)curll_requestCompletedNote, @"CURLHNotification_RequestCompleted", (unint64_t)a2, 0, 0);
  }
LABEL_13:
  uint64_t v15 = v12;
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v15;
}

uint64_t curll_createAndInstallHandler(void *a1, uint64_t a2, const char *a3, uint64_t a4, NSObject *a5, uint64_t a6, uint64_t a7, void *a8)
{
  CFTypeRef cf = 0;
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v20 = FigSignalErrorAt(4294949915, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  uint64_t v17 = FigCustomURLHandlerCreate(*(const void **)(DerivedStorage + 16), a3, a4, a5, a6, a7, &cf);
  CFTypeRef v18 = cf;
  if (v17 || (uint64_t v17 = curll_installHandler(a1, cf, a2), v18 = cf, v17))
  {
    uint64_t v20 = v17;
    if (!v18) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (cf)
  {
    CFTypeRef v19 = CFRetain(cf);
    CFTypeRef v18 = cf;
  }
  else
  {
    CFTypeRef v19 = 0;
  }
  uint64_t v20 = 0;
  *a8 = v19;
  if (v18) {
LABEL_8:
  }
    CFRelease(v18);
LABEL_9:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v20;
}

uint64_t curll_getURL(const void *a1, const void *a2, const void *a3, NSObject *a4, uint64_t a5, void *a6)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1 && a2 && a3 && a4 && a5 && a6)
  {
    CFArrayRef v13 = (uint64_t *)DerivedStorage;
    uint64_t v14 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    int v15 = FigAtomicIncrement32((atomic_uint *)(v14 + 28));
    uint64_t v16 = malloc_type_calloc(1uLL, 0x30uLL, 0x10E004085FF1568uLL);
    if (v16)
    {
      uint64_t v17 = (uint64_t)v16;
      uint64_t v18 = 2 * v15;
      *uint64_t v16 = CFRetain(a1);
      *(void *)(v17 + 16) = CFRetain(a2);
      *(void *)(v17 + 8) = CFRetain(a3);
      dispatch_retain(a4);
      *(void *)(v17 + 24) = a4;
      *(void *)(v17 + 32) = a5;
      *(void *)(v17 + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v18;
      uint64_t v19 = figCustomURLWorkQueueEnqueue(*v13, (uint64_t)curll_getURLDispatch, v17);
      if (v19)
      {
        if (*(void *)v17) {
          CFRelease(*(CFTypeRef *)v17);
        }
        uint64_t v22 = *(const void **)(v17 + 16);
        if (v22) {
          CFRelease(v22);
        }
        __int16 v23 = *(const void **)(v17 + 8);
        if (v23) {
          CFRelease(v23);
        }
        CFTypeRef v24 = *(NSObject **)(v17 + 24);
        if (v24) {
          dispatch_release(v24);
        }
        free((void *)v17);
      }
      else
      {
        *a6 = v18;
      }
      return v19;
    }
    uint64_t v21 = 4294954510;
  }
  else
  {
    uint64_t v21 = 4294949916;
  }

  return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
}

uint64_t curll_cancelRequest(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1)
  {
    uint64_t v5 = (uint64_t *)DerivedStorage;
    CFTypeID v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
    if (v6)
    {
      uint64_t v7 = (uint64_t)v6;
      *CFTypeID v6 = CFRetain(a1);
      *(void *)(v7 + 8) = a2;
      uint64_t v8 = figCustomURLWorkQueueEnqueue(*v5, (uint64_t)curll_cancelRequestDispatch, v7);
      if (v8)
      {
        if (*(void *)v7) {
          CFRelease(*(CFTypeRef *)v7);
        }
        free((void *)v7);
      }
      return v8;
    }
    uint64_t v10 = 4294954510;
  }
  else
  {
    uint64_t v10 = 4294949916;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t curll_requestSetDormant(const void *a1, uint64_t a2, char a3)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1)
  {
    uint64_t v7 = (uint64_t *)DerivedStorage;
    uint64_t v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x10600407BD382EDuLL);
    if (v8)
    {
      uint64_t v9 = (uint64_t)v8;
      *uint64_t v8 = CFRetain(a1);
      *(void *)(v9 + 8) = a2;
      *(unsigned char *)(v9 + 16) = a3;
      uint64_t v10 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curll_requestSetDormantDispatch, v9);
      if (v10)
      {
        if (*(void *)v9) {
          CFRelease(*(CFTypeRef *)v9);
        }
        free((void *)v9);
      }
      return v10;
    }
    uint64_t v12 = 4294954510;
  }
  else
  {
    uint64_t v12 = 4294949916;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t curll_transferHandlingOfRequest(const void *a1, const void *a2, const void *a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1 && a2 && a3)
  {
    uint64_t v9 = (uint64_t *)DerivedStorage;
    if (transferHandlingOfRequestRec_getCFAllocator_sOnceToken != -1) {
      dispatch_once_f(&transferHandlingOfRequestRec_getCFAllocator_sOnceToken, &transferHandlingOfRequestRec_getCFAllocator_sAllocator, (dispatch_function_t)transferHandlingOfRequestRec_initializeCFAllocatorOnce);
    }
    CFAllocatorRef v10 = (const __CFAllocator *)transferHandlingOfRequestRec_getCFAllocator_sAllocator;
    if (!transferHandlingOfRequestRec_getCFAllocator_sAllocator)
    {
      uint64_t v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      if (v24) {
        return v24;
      }
    }
    uint64_t v11 = (const UInt8 *)malloc_type_calloc(1uLL, 0x48uLL, 0x10E004078E2DE95uLL);
    if (v11)
    {
      uint64_t v12 = v11;
      CFDataRef v13 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11, 72, v10);
      if (v13)
      {
        CFDataRef v14 = v13;
        *uint64_t v12 = CFRetain(a1);
        v12[1] = CFRetain(a2);
        int v12[2] = CFRetain(a3);
        v12[3] = a4;
        if (dword_1EB28B5F0)
        {
          v28[0] = 0;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, v28, &type);
          int v16 = v28[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
            unsigned int v18 = v16;
          }
          else {
            unsigned int v18 = v16 & 0xFFFFFFFE;
          }
          if (v18)
          {
            uint64_t v19 = v12[3];
            uint64_t v20 = v12[1];
            v28[1] = 136316162;
            CFRange v29 = "curll_transferHandlingOfRequest";
            __int16 v30 = 2048;
            uint64_t v31 = v9;
            __int16 v32 = 2048;
            uint64_t v33 = v19;
            __int16 v34 = 2048;
            uint64_t v35 = v20;
            __int16 v36 = 2048;
            uint64_t v37 = v20;
            uint64_t v21 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v16) = v28[0];
          }
          else
          {
            uint64_t v21 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v21, v21 != &v38, v16, 0, v17);
        }
        uint64_t v22 = *v9;
        CFTypeRef v23 = CFRetain(v14);
        uint64_t v24 = figCustomURLWorkQueueEnqueue(v22, (uint64_t)curll_transferHandlingOfRequestDispatch, (uint64_t)v23);
        if (v24) {
          CFRelease(v14);
        }
        CFRelease(v14);
        return v24;
      }
      free(v12);
    }
    uint64_t v26 = 4294954510;
  }
  else
  {
    uint64_t v26 = 4294949916;
  }

  return FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
}

uint64_t curll_compareHandlersByPriority(void *key, const void *a2, uint64_t a3)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 40), key);
  CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 40), a2);
  CFComparisonResult v7 = CFNumberCompare(Value, v6, 0);
  if (v7 == kCFCompareGreaterThan) {
    uint64_t v8 = -1;
  }
  else {
    uint64_t v8 = v7;
  }
  if (v7 == kCFCompareLessThan) {
    return 1;
  }
  else {
    return v8;
  }
}

void curll_getURLDispatch(uint64_t *a1)
{
  uint64_t v3 = (const void *)*a1;
  uint64_t v2 = (const void *)a1[1];
  uint64_t v4 = (const void *)a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = a1[5];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  CFTypeRef cf = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v15 = 4294949915;
LABEL_18:
    int v10 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    goto LABEL_4;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 48)) <= 0)
  {
    uint64_t v15 = 4294949913;
    goto LABEL_18;
  }
  CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 48), 0);
  int v10 = curll_handlerHandleRequestOnLoaderQueue(v3, ValueAtIndex, v4, v7, v2, v5, v6, (uint64_t)curll_respondToHandleRequestCompletionOnQueue);
LABEL_4:
  int v11 = v10;
  if (v10)
  {
    FigCustomURLResponseInfoCreateMutable(*(const __CFAllocator **)(DerivedStorage + 16), v4, &cf);
    curl_dispatchDataCallbackWithError(v5, v2, v6, v7, v4, cf, v11);
    if (cf) {
      CFRelease(cf);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  uint64_t v12 = (const void *)a1[2];
  if (v12) {
    CFRelease(v12);
  }
  CFDataRef v13 = (const void *)a1[1];
  if (v13) {
    CFRelease(v13);
  }
  CFDataRef v14 = a1[3];
  if (v14) {
    dispatch_release(v14);
  }
  free(a1);
}

uint64_t curll_handlerHandleRequestOnLoaderQueue(const void *a1, const void *a2, const void *a3, uint64_t a4, const void *a5, NSObject *a6, uint64_t a7, uint64_t a8)
{
  uint64_t DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  bytesDeCFAllocatorRef allocator = 0;
  CFCFAllocatorRef Allocator = handlerHandleRequestRec_getCFAllocator(&bytesDeallocator);
  if (CFAllocator) {
    return CFAllocator;
  }
  int v16 = (const UInt8 *)malloc_type_calloc(1uLL, 0x58uLL, 0x10E0040CF94696AuLL);
  if (!v16) {
    goto LABEL_32;
  }
  uint64_t v17 = (UInt8 *)v16;
  CFDataRef v18 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v16, 88, bytesDeallocator);
  if (!v18)
  {
    free(v17);
LABEL_32:
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  CFDataRef v19 = v18;
  CFTypeRef v20 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v18);
  if (v20)
  {
    uint64_t v21 = (void *)v20;
    if (a1) {
      CFTypeRef v22 = CFRetain(a1);
    }
    else {
      CFTypeRef v22 = 0;
    }
    *(void *)uint64_t v17 = v22;
    if (a2) {
      CFTypeRef v23 = CFRetain(a2);
    }
    else {
      CFTypeRef v23 = 0;
    }
    *((void *)v17 + 1) = v23;
    if (a3) {
      CFTypeRef v24 = CFRetain(a3);
    }
    else {
      CFTypeRef v24 = 0;
    }
    *((void *)v17 + 2) = v24;
    *((void *)v17 + 3) = a4;
    if (a5) {
      CFTypeRef v25 = CFRetain(a5);
    }
    else {
      CFTypeRef v25 = 0;
    }
    *((void *)v17 + 4) = v25;
    if (a6) {
      dispatch_retain(a6);
    }
    *((void *)v17 + 5) = a6;
    *((void *)v17 + 6) = a7;
    *((void *)v17 + 7) = 0x4024000000000000;
    *((void *)v17 + 8) = a8;
    v17[84] = 1;
    if (curl_getLowPriorityBackgroundQueue_sOnceToken != -1) {
      dispatch_once_f(&curl_getLowPriorityBackgroundQueue_sOnceToken, 0, (dispatch_function_t)curl_getLowPriorityBackgroundQueueOnce);
    }
    uint64_t v26 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, (dispatch_queue_t)gLowPriorityBackgroundQueue);
    *((void *)v17 + 9) = v26;
    dispatch_time_t v27 = dispatch_time(0, 10000000000);
    uint64_t v28 = dispatch_time(0, 10000000000);
    dispatch_source_set_timer(v26, v27, v28, 0);
    dispatch_set_context(*((dispatch_object_t *)v17 + 9), v21);
    dispatch_source_set_event_handler_f(*((dispatch_source_t *)v17 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerTimeoutCallback);
    dispatch_source_set_cancel_handler_f(*((dispatch_source_t *)v17 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerCancellationCallback);
    dispatch_resume(*((dispatch_object_t *)v17 + 9));
    figCustomURLWorkQueueSuspendDraining(*DerivedStorage);
    uint64_t v29 = *(void *)(CMBaseObjectGetVTable((uint64_t)a2) + 16);
    if (v29) {
      uint64_t v30 = v29;
    }
    else {
      uint64_t v30 = 0;
    }
    uint64_t v31 = *(uint64_t (**)(const void *, const void *, uint64_t, const void *, NSObject *, uint64_t, void (*)(const __CFData *, unsigned int, unsigned int), CFDataRef))(v30 + 32);
    if (v31)
    {
      uint64_t v32 = v31(a2, a3, a4, a5, a6, a7, curll_handlerHandleRequestCompletionHandler, v19);
      if (!v32) {
        return v32;
      }
    }
    else
    {
      uint64_t v32 = 4294954514;
    }
    figCustomURLWorkQueueResumeDraining(*DerivedStorage);
    return v32;
  }
  uint64_t v34 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  CFRelease(v19);
  return v34;
}

uint64_t curll_respondToHandleRequestCompletionOnQueue(const __CFData *a1, int a2, int a3)
{
  bytesDeallocator[16] = *(CFAllocatorRef *)MEMORY[0x1E4F143B8];
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t v8 = *(void *)BytePtr;
  uint64_t v7 = (const void *)*((void *)BytePtr + 1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)BytePtr);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v63 = 4294954511;
    goto LABEL_56;
  }
  CFArrayRef v10 = *(const __CFArray **)(DerivedStorage + 48);
  v81.CFIndex length = CFArrayGetCount(v10);
  v81.CFIndex location = 0;
  FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v10, v81, v7);
  if (FirstIndexOfValue == -1)
  {
    uint64_t v63 = 4294949914;
    goto LABEL_56;
  }
  CFIndex v12 = FirstIndexOfValue;
  if (a3 == -17377)
  {
    if (dword_1EB28B5F0)
    {
      int v69 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v69, &type);
      int v14 = v69;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v16 = v14;
      }
      else {
        unsigned int v16 = v14 & 0xFFFFFFFE;
      }
      if (v16)
      {
        uint64_t v17 = *((void *)BytePtr + 3);
        int v70 = 136315906;
        int v71 = "curll_respondToHandleRequestCompletionOnQueue";
        __int16 v72 = 2048;
        uint64_t v73 = DerivedStorage;
        __int16 v74 = 2048;
        uint64_t v75 = v17;
        __int16 v76 = 2048;
        int v77 = v7;
        int v67 = 42;
        uint64_t v66 = &v70;
        CFDataRef v18 = (CFAllocatorRef *)_os_log_send_and_compose_impl();
        LOBYTE(v14) = v69;
      }
      else
      {
        CFDataRef v18 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v18, v18 != bytesDeallocator, v14, 0, v15);
    }
    BOOL v26 = 0;
    int v25 = -17377;
  }
  else if (a3)
  {
    if (dword_1EB28B5F0)
    {
      int v69 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      CFDataRef v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, &v69, &type);
      int v20 = v69;
      if (os_log_type_enabled(v19, type)) {
        unsigned int v22 = v20;
      }
      else {
        unsigned int v22 = v20 & 0xFFFFFFFE;
      }
      if (v22)
      {
        uint64_t v23 = *((void *)BytePtr + 3);
        int v70 = 136316162;
        int v71 = "curll_respondToHandleRequestCompletionOnQueue";
        __int16 v72 = 2048;
        uint64_t v73 = DerivedStorage;
        __int16 v74 = 2048;
        uint64_t v75 = v23;
        __int16 v76 = 2048;
        int v77 = v7;
        __int16 v78 = 1024;
        int v79 = a3;
        int v67 = 48;
        uint64_t v66 = &v70;
        CFTypeRef v24 = (CFAllocatorRef *)_os_log_send_and_compose_impl();
        LOBYTE(v2CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v69;
      }
      else
      {
        CFTypeRef v24 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v24, v24 != bytesDeallocator, v20, 0, v21);
    }
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(DerivedStorage + 48), v12);
    int v25 = 0;
    --v12;
    BOOL v26 = 1;
  }
  else
  {
    int v25 = 0;
    BOOL v26 = a2 == 0;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 48));
  if (!v26 || v12 == Count - 1)
  {
    if (a2)
    {
      uint64_t v60 = *((void *)BytePtr + 3);
      uint64_t v61 = CMBaseObjectGetDerivedStorage(v8);
      int v62 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(void *)(v61 + 56), (uint64_t)v7, v60);
LABEL_57:
      int v25 = v62;
      goto LABEL_58;
    }
    if (a3 == -17377) {
      goto LABEL_58;
    }
    uint64_t v63 = 4294949913;
LABEL_56:
    int v62 = FigSignalErrorAt(v63, 0, 0, 0, 0, 0, 0);
    goto LABEL_57;
  }
  CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 48), v12 + 1);
  uint64_t v29 = CFDataGetBytePtr(a1);
  bytesDeallocator[0] = 0;
  uint64_t v30 = CFDataGetBytePtr(a1);
  CFCFAllocatorRef Allocator = handlerHandleRequestRec_getCFAllocator(bytesDeallocator);
  if (CFAllocator) {
    goto LABEL_74;
  }
  uint64_t v32 = malloc_type_calloc(1uLL, 0x58uLL, 0x10E0040CF94696AuLL);
  if (v32)
  {
    uint64_t v33 = v32;
    long long v34 = *((_OWORD *)v30 + 1);
    *uint64_t v32 = *(_OWORD *)v30;
    v32[1] = v34;
    long long v35 = *((_OWORD *)v30 + 2);
    long long v36 = *((_OWORD *)v30 + 3);
    long long v37 = *((_OWORD *)v30 + 4);
    *((void *)v32 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *((void *)v30 + 10);
    v32[3] = v36;
    v32[4] = v37;
    _OWORD v32[2] = v35;
    CFDataRef v38 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v32, 88, bytesDeallocator[0]);
    if (v38)
    {
      CFDataRef v39 = v38;
      if (*(void *)v33) {
        CFRetain(*(CFTypeRef *)v33);
      }
      unsigned int v40 = (const void *)*((void *)v33 + 1);
      if (v40) {
        CFRetain(v40);
      }
      int v41 = (const void *)*((void *)v33 + 2);
      if (v41) {
        CFRetain(v41);
      }
      __int16 v42 = (const void *)*((void *)v33 + 4);
      if (v42) {
        CFRetain(v42);
      }
      int v43 = *((void *)v33 + 5);
      if (v43) {
        dispatch_retain(v43);
      }
      int v44 = *((void *)v33 + 9);
      if (v44) {
        dispatch_retain(v44);
      }
      goto LABEL_41;
    }
    free(v33);
  }
  CFCFAllocatorRef Allocator = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  CFDataRef v39 = 0;
  if (CFAllocator) {
    goto LABEL_74;
  }
LABEL_41:
  __int16 v45 = CFDataGetBytePtr(v39);
  CFTypeRef v46 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v39);
  if (!v46)
  {
    int v25 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v39) {
      CFRelease(v39);
    }
LABEL_58:
    if (!v25) {
      return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
    }
    goto LABEL_65;
  }
  __int16 v47 = (void *)v46;
  *((_DWORD *)v45 + 2CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  uint64_t v48 = (const void *)*((void *)v45 + 1);
  *((void *)v45 + 1) = ValueAtIndex;
  if (ValueAtIndex) {
    CFRetain(ValueAtIndex);
  }
  if (v48) {
    CFRelease(v48);
  }
  *((unsigned char *)v45 + 84) = 1;
  __int16 v49 = *((void *)v45 + 9);
  if (v49) {
    dispatch_release(v49);
  }
  if (curl_getLowPriorityBackgroundQueue_sOnceToken != -1) {
    dispatch_once_f(&curl_getLowPriorityBackgroundQueue_sOnceToken, 0, (dispatch_function_t)curl_getLowPriorityBackgroundQueueOnce);
  }
  uint64_t v50 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, (dispatch_queue_t)gLowPriorityBackgroundQueue);
  *((void *)v45 + 9) = v50;
  dispatch_time_t v51 = dispatch_time(0, (uint64_t)(*((double *)v45 + 7) * 1000000000.0));
  uint64_t v52 = dispatch_time(0, (uint64_t)(*((double *)v45 + 7) * 1000000000.0));
  dispatch_source_set_timer(v50, v51, v52, 0);
  dispatch_set_context(*((dispatch_object_t *)v45 + 9), v47);
  dispatch_source_set_event_handler_f(*((dispatch_source_t *)v45 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerTimeoutCallback);
  dispatch_source_set_cancel_handler_f(*((dispatch_source_t *)v45 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerCancellationCallback);
  dispatch_resume(*((dispatch_object_t *)v45 + 9));
  uint64_t v53 = *((void *)v45 + 2);
  uint64_t v54 = *((void *)v45 + 3);
  uint64_t v55 = *((void *)v45 + 4);
  uint64_t v56 = *((void *)v45 + 5);
  uint64_t v57 = *((void *)v45 + 6);
  uint64_t v58 = *(void *)(CMBaseObjectGetVTable((uint64_t)ValueAtIndex) + 16);
  if (v58) {
    uint64_t v59 = v58;
  }
  else {
    uint64_t v59 = 0;
  }
  int v64 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void (*)(const __CFData *, unsigned int, unsigned int), const __CFData *, int *, int))(v59 + 32);
  if (!v64)
  {
    int v25 = -12782;
    goto LABEL_65;
  }
  CFCFAllocatorRef Allocator = v64(ValueAtIndex, v53, v54, v55, v56, v57, curll_handlerHandleRequestCompletionHandler, v39, v66, v67);
  if (!CFAllocator)
  {
    *((unsigned char *)v29 + 84) = 0;
    return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  }
LABEL_74:
  int v25 = CFAllocator;
LABEL_65:
  bytesDeallocator[0] = 0;
  FigCustomURLResponseInfoCreateMutable(*(const __CFAllocator **)(DerivedStorage + 16), *((const void **)BytePtr + 2), (CFTypeRef *)bytesDeallocator);
  curl_dispatchDataCallbackWithError(*((NSObject **)BytePtr + 5), *((const void **)BytePtr + 4), *((void *)BytePtr + 6), *((void *)BytePtr + 3), *((const void **)BytePtr + 2), bytesDeallocator[0], v25);
  if (bytesDeallocator[0]) {
    CFRelease(bytesDeallocator[0]);
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
}

uint64_t handlerHandleRequestRec_getCFAllocator(void *a1)
{
  if (handlerHandleRequestRec_getCFAllocator_sOnceToken != -1) {
    dispatch_once_f(&handlerHandleRequestRec_getCFAllocator_sOnceToken, &handlerHandleRequestRec_getCFAllocator_sAllocator, (dispatch_function_t)handlerHandleRequestRec_initializeCFAllocatorOnce);
  }
  if (handlerHandleRequestRec_getCFAllocator_sAllocator)
  {
    *a1 = handlerHandleRequestRec_getCFAllocator_sAllocator;
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

void curll_handlerHandleRequestTimerTimeoutCallback(id *a1)
{
  CFAllocatorRef v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    curll_handlerHandleRequestCompletionHandlerCommon((const __CFData *)v1, 0, 1, 0xFFFFBC1F);
    CFRelease(v2);
  }
}

void curll_handlerHandleRequestTimerCancellationCallback(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void curll_handlerHandleRequestCompletionHandler(const __CFData *a1, unsigned int a2, unsigned int a3)
{
  curll_handlerHandleRequestCompletionHandlerCommon(a1, a2, 0, a3);
  if (a1)
  {
    CFRelease(a1);
  }
}

uint64_t handlerHandleRequestRec_initializeCFAllocatorOnce(void *a1)
{
  CFTypeRef v3 = 0;
  uint64_t result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))handlerHandleRequestRec_dealloc, &v3);
  if (!result) {
    *a1 = v3;
  }
  return result;
}

void handlerHandleRequestRec_dealloc(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = a1[1];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = a1[2];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = a1[4];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = a1[5];
  if (v6) {
    dispatch_release(v6);
  }
  uint64_t v7 = a1[9];
  if (v7) {
    dispatch_release(v7);
  }

  free(a1);
}

dispatch_queue_t curl_getLowPriorityBackgroundQueueOnce()
{
  dispatch_queue_t result = FigDispatchQueueCreateWithPriority("com.apple.coremedia.customurl.bg", 0, 0x19u);
  gLowPriorityBackgroundQueue = (uint64_t)result;
  return result;
}

void curll_handlerHandleRequestCompletionHandlerCommon(const __CFData *a1, unsigned int a2, int a3, unsigned int a4)
{
  BytePtr = CFDataGetBytePtr(a1);
  if (FigAtomicCompareAndSwap32(0, 1u, (atomic_uint *)BytePtr + 20))
  {
    if (a3) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = a2;
    }
    if (a3) {
      uint64_t v10 = 4294949919;
    }
    else {
      uint64_t v10 = a4;
    }
    (*((void (**)(const __CFData *, uint64_t, uint64_t))BytePtr + 8))(a1, v9, v10);
    if (BytePtr[84])
    {
      uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)BytePtr);
      FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
      if (!*(unsigned char *)(DerivedStorage + 24)) {
        figCustomURLWorkQueueResumeDraining(*(void *)DerivedStorage);
      }
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
    }
    CFIndex v12 = *((void *)BytePtr + 9);
    dispatch_source_cancel(v12);
  }
}

void curll_cancelRequestDispatch(uint64_t *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  uint64_t v2 = (void *)a1[1];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    FigSignalErrorAt(4294949915, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    if (dword_1EB28B5F0)
    {
      v17[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, v17, &type);
      int v6 = v17[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v8 = v6;
      }
      else {
        unsigned int v8 = v6 & 0xFFFFFFFE;
      }
      if (v8)
      {
        v17[1] = 136315650;
        CFDataRef v18 = "curll_cancelRequestOnQueue";
        __int16 v19 = 2048;
        uint64_t v20 = DerivedStorage;
        __int16 v21 = 2048;
        unsigned int v22 = v2;
        uint64_t v9 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v6) = v17[0];
      }
      else
      {
        uint64_t v9 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v9, v9 != &v23, v6, 0, v7);
    }
    uint64_t v10 = CMBaseObjectGetDerivedStorage(v3);
    id v11 = FigCFWeakReferenceTableCopyValue(*(void *)(v10 + 56), v2);
    if (v11)
    {
      CFIndex v12 = v11;
      uint64_t v13 = *(void *)(CMBaseObjectGetVTable((uint64_t)v11) + 16);
      if (v13) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v15 = *(void (**)(const void *, void *))(v14 + 40);
      if (v15) {
        v15(v12, v2);
      }
      CFRelease(v12);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1) {
    CFRelease((CFTypeRef)*a1);
  }
  free(a1);
}

void curll_requestSetDormantDispatch(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)a1;
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v4 = *(unsigned __int8 *)(a1 + 16);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    FigSignalErrorAt(4294949915, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    if (dword_1EB28B5F0)
    {
      v18[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, v18, &type);
      int v7 = v18[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v9 = v7;
      }
      else {
        unsigned int v9 = v7 & 0xFFFFFFFE;
      }
      if (v9)
      {
        v18[1] = 136315906;
        __int16 v19 = "curll_requestSetDormantOnQueue";
        __int16 v20 = 2048;
        uint64_t v21 = DerivedStorage;
        __int16 v22 = 2048;
        char v23 = v2;
        __int16 v24 = 1024;
        int v25 = v4;
        uint64_t v10 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v7) = v18[0];
      }
      else
      {
        uint64_t v10 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v10, v10 != &v26, v7, 0, v8);
    }
    uint64_t v11 = CMBaseObjectGetDerivedStorage(v3);
    id v12 = FigCFWeakReferenceTableCopyValue(*(void *)(v11 + 56), v2);
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)(CMBaseObjectGetVTable((uint64_t)v12) + 16);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = 0;
      }
      unsigned int v16 = *(void (**)(const void *, void *, uint64_t))(v15 + 48);
      if (v16) {
        v16(v13, v2, v4);
      }
      CFRelease(v13);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  free((void *)a1);
}

uint64_t curll_transferHandlingOfRequestDispatch(const __CFData *a1)
{
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t v3 = *((void *)BytePtr + 1);
  uint64_t v4 = *((void *)BytePtr + 3);
  uint64_t VTable = CMBaseObjectGetVTable(v3);
  uint64_t v8 = *(void *)(VTable + 16);
  uint64_t result = VTable + 16;
  uint64_t v7 = v8;
  if (v8) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(int, int, CFDataRef, int, const void *, const void *, const void *, NSObject *, uint64_t, const void *), const __CFData *))(v9 + 56);
  if (v10)
  {
    return v10(v3, v4, curll_handlerLookupRegisteredInfoCallbackForHandlerTransfer, a1);
  }
  return result;
}

uint64_t transferHandlingOfRequestRec_initializeCFAllocatorOnce(void *a1)
{
  CFTypeRef v3 = 0;
  uint64_t result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))transferHandlingOfRequestRec_dealloc, &v3);
  if (!result) {
    *a1 = v3;
  }
  return result;
}

void transferHandlingOfRequestRec_dealloc(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = a1[1];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = a1[2];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = a1[4];
  if (v5) {
    CFRelease(v5);
  }
  int v6 = a1[5];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = a1[6];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = a1[7];
  if (v8) {
    dispatch_release(v8);
  }

  free(a1);
}

void curll_handlerLookupRegisteredInfoCallbackForHandlerTransfer(int a1, int a2, CFDataRef theData, int a4, const void *a5, const void *a6, const void *a7, NSObject *a8, uint64_t a9, const void *a10)
{
  BytePtr = (uint64_t *)CFDataGetBytePtr(theData);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*BytePtr);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v23 = 4294954511;
  }
  else
  {
    if (a4) {
      goto LABEL_39;
    }
    if (!BytePtr[4] && !BytePtr[5] && !BytePtr[6] && !BytePtr[7] && !BytePtr[8])
    {
      if (a5) {
        CFTypeRef v18 = CFRetain(a5);
      }
      else {
        CFTypeRef v18 = 0;
      }
      BytePtr[4] = (uint64_t)v18;
      if (a6) {
        CFTypeRef v19 = CFRetain(a6);
      }
      else {
        CFTypeRef v19 = 0;
      }
      BytePtr[5] = (uint64_t)v19;
      if (a7) {
        CFTypeRef v20 = CFRetain(a7);
      }
      else {
        CFTypeRef v20 = 0;
      }
      BytePtr[6] = (uint64_t)v20;
      BytePtr[8] = a9;
      if (a8) {
        dispatch_retain(a8);
      }
      BytePtr[7] = (uint64_t)a8;
      uint64_t v21 = *(void *)DerivedStorage;
      if (theData)
      {
        CFTypeRef v22 = CFRetain(theData);
        if (figCustomURLWorkQueueEnqueue(v21, (uint64_t)curll_transferHandlingOfRequestWithRegisteredInfoDispatch, (uint64_t)v22))CFRelease(theData); {
        goto LABEL_22;
        }
      }
      figCustomURLWorkQueueEnqueue(*(void *)DerivedStorage, (uint64_t)curll_transferHandlingOfRequestWithRegisteredInfoDispatch, 0);
      goto LABEL_24;
    }
    uint64_t v23 = 4294949914;
  }
  FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
LABEL_39:
  if (theData) {
LABEL_22:
  }
    CFRelease(theData);
LABEL_24:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (a5) {
    CFRelease(a5);
  }
  if (a6) {
    CFRelease(a6);
  }
  if (a7) {
    CFRelease(a7);
  }
  if (a8) {
    dispatch_release(a8);
  }
  if (a10)
  {
    CFRelease(a10);
  }
}

void curll_transferHandlingOfRequestWithRegisteredInfoDispatch(const __CFData *a1)
{
  CFDataRef v1 = a1;
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t v4 = *(const void **)BytePtr;
  CFTypeRef v3 = (const void *)*((void *)BytePtr + 1);
  int v6 = (const void *)*((void *)BytePtr + 2);
  uint64_t v5 = *((void *)BytePtr + 3);
  uint64_t v7 = (const void *)*((void *)BytePtr + 4);
  uint64_t v8 = (const void *)*((void *)BytePtr + 5);
  uint64_t v9 = (const void *)*((void *)BytePtr + 6);
  int64x2_t v23 = *(int64x2_t *)(BytePtr + 56);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)BytePtr);
  if (v8) {
    CFTypeRef v11 = CFRetain(v8);
  }
  else {
    CFTypeRef v11 = 0;
  }
  CFTypeRef v24 = v11;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v21 = 4294949915;
    goto LABEL_28;
  }
  CFTypeRef v22 = v11;
  id v12 = v9;
  uint64_t v13 = v5;
  CFDataRef v14 = v1;
  CFArrayRef v15 = *(const __CFArray **)(DerivedStorage + 48);
  v25.CFIndex length = CFArrayGetCount(v15);
  v25.CFIndex location = 0;
  if (!CFArrayContainsValue(v15, v25, v3))
  {
    int v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    CFDataRef v1 = v14;
LABEL_31:
    uint64_t v5 = v13;
LABEL_33:
    uint64_t v9 = v12;
LABEL_35:
    CFTypeRef v11 = v22;
    goto LABEL_16;
  }
  CFArrayRef v16 = *(const __CFArray **)(DerivedStorage + 48);
  v26.CFIndex length = CFArrayGetCount(v16);
  v26.CFIndex location = 0;
  CFDataRef v1 = v14;
  if (!CFArrayContainsValue(v16, v26, v6))
  {
    int v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    goto LABEL_31;
  }
  uint64_t v5 = v13;
  if (!v7)
  {
    int v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  uint64_t v9 = v12;
  if (v8)
  {
    int v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    goto LABEL_35;
  }
  CFTypeRef v11 = v22;
  if (v9 && v23.i64[0] && v23.i64[1])
  {
    int v17 = curll_unregisterHandlerForRequestOnQueue((uint64_t)v4, v5);
    if (!v17)
    {
      uint64_t v18 = CMBaseObjectGetDerivedStorage((uint64_t)v4);
      int v17 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(void *)(v18 + 56), (uint64_t)v6, v5);
      if (!v17) {
        int v17 = curll_handlerHandleRequestOnLoaderQueue(v4, v6, v7, v5, v9, v23.i64[0], v23.i64[1], (uint64_t)curll_respondToHandleRequestCompletionForTransferOnQueue);
      }
    }
    goto LABEL_15;
  }
  uint64_t v21 = 4294949914;
LABEL_28:
  int v17 = FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
LABEL_15:
  int v19 = v17;
LABEL_16:
  v20.i64[0] = (uint64_t)v7;
  v20.i64[1] = (uint64_t)v9;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqzq_s64(v20), (int32x4_t)vceqzq_s64(v23)))) & 1) == 0
    && v19)
  {
    if (!v11)
    {
      FigCustomURLResponseInfoCreate(*(const __CFAllocator **)(DerivedStorage + 16), v7, &v24);
      CFTypeRef v11 = v24;
    }
    curl_dispatchDataCallbackWithError(v23.i64[0], v9, v23.i64[1], v5, v7, v11, v19);
    CFTypeRef v11 = v24;
  }
  if (v11) {
    CFRelease(v11);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t curll_respondToHandleRequestCompletionForTransferOnQueue(const __CFData *a1, int a2, int a3)
{
  cf[16] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage(*(void *)BytePtr);
  uint64_t v7 = *((void *)BytePtr + 1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(unsigned char *)(DerivedStorage + 24))
  {
    uint64_t v14 = 4294954511;
    goto LABEL_12;
  }
  if (a3 != -17377 || !dword_1EB28B5F0)
  {
    if (a2 || a3)
    {
LABEL_13:
      if (!a3) {
        return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
      }
      goto LABEL_17;
    }
    uint64_t v14 = 4294949912;
LABEL_12:
    a3 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  v17[0] = 0;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B5E8, 1, v17, &type);
  int v9 = v17[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = v9 & 0xFFFFFFFE;
  }
  if (v11)
  {
    uint64_t v12 = *((void *)BytePtr + 3);
    v17[1] = 136315906;
    uint64_t v18 = "curll_respondToHandleRequestCompletionForTransferOnQueue";
    __int16 v19 = 2048;
    uint64_t v20 = DerivedStorage;
    __int16 v21 = 2048;
    uint64_t v22 = v12;
    __int16 v23 = 2048;
    uint64_t v24 = v7;
    uint64_t v13 = (CFTypeRef *)_os_log_send_and_compose_impl();
    LOBYTE(v9) = v17[0];
  }
  else
  {
    uint64_t v13 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B5E8, 1u, 1, v13, v13 != cf, v9, 0, v10);
  a3 = -17377;
LABEL_17:
  cf[0] = 0;
  FigCustomURLResponseInfoCreate(*(const __CFAllocator **)(DerivedStorage + 16), *((const void **)BytePtr + 2), cf);
  curl_dispatchDataCallbackWithError(*((NSObject **)BytePtr + 5), *((const void **)BytePtr + 4), *((void *)BytePtr + 6), *((void *)BytePtr + 3), *((const void **)BytePtr + 2), cf[0], a3);
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
}

id FigCFWeakReferenceStore(id *location, id obj)
{
  if (wr_initializeOnceToken != -1) {
    dispatch_once_f(&wr_initializeOnceToken, 0, (dispatch_function_t)wr_initialize);
  }

  return objc_storeWeak(location, obj);
}

id FigCFWeakReferenceInit(id *location, id val)
{
  if (wr_initializeOnceToken != -1) {
    dispatch_once_f(&wr_initializeOnceToken, 0, (dispatch_function_t)wr_initialize);
  }

  return objc_initWeak(location, val);
}

uint64_t FigCaptionRegionGetClassID()
{
  return sFigCaptionRegionClassID;
}

uint64_t RegisterFigCaptionRegionBaseType()
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&sFigCaptionRegionClassDesc, ClassID, 1, &sFigCaptionRegionClassID);
}

uint64_t FigCaptionRegionGetTypeID()
{
  FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType);
  uint64_t v0 = (void *)sFigCaptionRegionClassID;

  return CMBaseClassGetCFTypeID(v0);
}

uint64_t FigCaptionRegionCreate(const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  uint64_t v5 = FigCaptionRegionCreateMutable(a1, &cf);
  if (v5)
  {
    uint64_t v10 = v5;
  }
  else
  {
    CFTypeRef v6 = cf;
    uint64_t v7 = *(void *)(CMBaseObjectGetVTable((uint64_t)cf) + 8);
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    int v9 = *(uint64_t (**)(CFTypeRef, __CFString *, uint64_t))(v8 + 56);
    if (v9)
    {
      uint64_t v10 = v9(v6, @"CMCaptionRegionIdentifier", a2);
      if (!v10)
      {
        *a3 = cf;
        return v10;
      }
    }
    else
    {
      uint64_t v10 = 4294954514;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t FigCaptionRegionCreateMutable(const __CFAllocator *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType);
    uint64_t v4 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionRegionVTable, (void *)sFigCaptionRegionClassID, &cf);
    CFTypeRef v5 = cf;
    if (!v4)
    {
      if (cf) {
        uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      }
      else {
        uint64_t DerivedStorage = 0;
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      *uint64_t DerivedStorage = Mutable;
      if (Mutable)
      {
        uint64_t v4 = 0;
        *a2 = cf;
        return v4;
      }
      uint64_t v4 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      CFTypeRef v5 = cf;
    }
    if (v5) {
      CFRelease(v5);
    }
    return v4;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionRegionCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  if (a3)
  {
    if (a2)
    {
      FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType);
      uint64_t v6 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionRegionVTable, (void *)sFigCaptionRegionClassID, &cf);
      if (v6) {
        goto LABEL_24;
      }
      if (!cf)
      {
        uint64_t v16 = 4294954510;
        goto LABEL_23;
      }
      uint64_t DerivedStorage = (CFMutableDictionaryRef *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      *uint64_t DerivedStorage = Mutable;
      if (Mutable)
      {
        for (uint64_t i = 0; i != 22; ++i)
        {
          CFTypeRef value = 0;
          uint64_t v10 = off_1E5678680[i];
          uint64_t v11 = *(void *)(CMBaseObjectGetVTable(a2) + 8);
          if (v11) {
            uint64_t v12 = v11;
          }
          else {
            uint64_t v12 = 0;
          }
          uint64_t v13 = *(void (**)(uint64_t, __CFString *, const __CFAllocator *, void **))(v12 + 48);
          if (v13) {
            v13(a2, v10, a1, &value);
          }
          if (value)
          {
            CFDictionarySetValue(*DerivedStorage, v10, value);
            if (value) {
              CFRelease(value);
            }
          }
        }
        uint64_t v14 = 0;
        *a3 = cf;
        return v14;
      }
    }
    uint64_t v16 = 4294954516;
LABEL_23:
    uint64_t v6 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_24:
    uint64_t v14 = v6;
    if (cf) {
      CFRelease(cf);
    }
    return v14;
  }

  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

CFStringRef FigCaptionRegionCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionRegion %p]", a1);
}

uint64_t fmcregion_Equal(char *a1, char *a2)
{
  if (a1
    && (FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType), !CMBaseObjectIsMemberOfClass(a1, (void *)sFigCaptionRegionClassID))|| a2&& (FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType), !CMBaseObjectIsMemberOfClass(a2, (void *)sFigCaptionRegionClassID)))
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else if (a1 == a2)
  {
    return 1;
  }
  else
  {
    uint64_t result = 0;
    if (a1 && a2)
    {
      uint64_t DerivedStorage = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
      uint64_t v6 = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage((uint64_t)a2);
      unint64_t Value = (unint64_t)CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionIdentifier");
      unint64_t v8 = (unint64_t)CFDictionaryGetValue(*v6, @"CMCaptionRegionIdentifier");
      if (Value | v8)
      {
        return FigCFEqual((CFTypeRef)Value, (CFTypeRef)v8);
      }
      else
      {
        int v9 = CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionPosition");
        uint64_t v10 = CFDictionaryGetValue(*v6, @"CMCaptionRegionPosition");
        uint64_t result = FigCFEqual(v9, v10);
        if (result)
        {
          uint64_t v11 = CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionAbstractPosition");
          uint64_t v12 = CFDictionaryGetValue(*v6, @"CMCaptionRegionAbstractPosition");
          uint64_t result = FigCFEqual(v11, v12);
          if (result)
          {
            uint64_t v13 = CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionHeight");
            uint64_t v14 = CFDictionaryGetValue(*v6, @"CMCaptionRegionHeight");
            uint64_t result = FigCFEqual(v13, v14);
            if (result)
            {
              CFArrayRef v15 = CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionAnchor");
              uint64_t v16 = CFDictionaryGetValue(*v6, @"CMCaptionRegionAnchor");
              uint64_t result = FigCFEqual(v15, v16);
              if (result)
              {
                int v17 = CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionLuminanceGain");
                uint64_t v18 = CFDictionaryGetValue(*v6, @"CMCaptionRegionLuminanceGain");
                uint64_t result = FigCFEqual(v17, v18);
                if (result)
                {
                  __int16 v19 = CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionStereoDisparity");
                  uint64_t v20 = CFDictionaryGetValue(*v6, @"CMCaptionRegionStereoDisparity");
                  uint64_t result = FigCFEqual(v19, v20);
                  if (result)
                  {
                    __int16 v21 = (__CFString *)CFDictionaryGetValue(*DerivedStorage, @"CMCaptionRegionAnimation");
                    if (v21) {
                      uint64_t v22 = v21;
                    }
                    else {
                      uint64_t v22 = @"CMCaptionRegionAnimationType_None";
                    }
                    __int16 v23 = (__CFString *)CFDictionaryGetValue(*v6, @"CMCaptionRegionAnimation");
                    if (v23) {
                      uint64_t v24 = v23;
                    }
                    else {
                      uint64_t v24 = @"CMCaptionRegionAnimationType_None";
                    }
                    return CFEqual(v22, v24) != 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void fmcregion_Finalize(uint64_t a1)
{
  CFDataRef v1 = *(const void **)CMBaseObjectGetDerivedStorage(a1);
  if (v1)
  {
    CFRelease(v1);
  }
}

__CFString *fmcregion_CopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 0);
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, @"\tCaptionRegion: %p %@", a1, *DerivedStorage);
  return Mutable;
}

uint64_t fmcregion_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFArrayRef *a4)
{
  if (!a2)
  {
    uint64_t v17 = 4294954516;
    goto LABEL_18;
  }
  if (!a4)
  {
    uint64_t v17 = 4294954516;
    goto LABEL_18;
  }
  if (a1) {
    uint64_t DerivedStorage = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage(a1);
  }
  else {
    uint64_t DerivedStorage = 0;
  }
  int v8 = FigCFEqual(a2, @"CMCaptionRegionPropertyKeysInUse");
  CFDictionaryRef v9 = *DerivedStorage;
  if (!v8)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v9, a2);
    CFArrayRef v15 = Value;
    if (Value) {
      CFRetain(Value);
    }
    goto LABEL_16;
  }
  unint64_t Count = CFDictionaryGetCount(v9);
  CFIndex v11 = Count;
  if (Count)
  {
    if (Count >> 61) {
      goto LABEL_17;
    }
    size_t v12 = 8 * Count;
    if (!(8 * v11)) {
      goto LABEL_17;
    }
    uint64_t v13 = (const void **)malloc_type_malloc(v12, 0xD1AAB5CuLL);
    if (!v13) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  CFDictionaryGetKeysAndValues(*DerivedStorage, v13, 0);
  CFArrayRef v15 = CFArrayCreate(a3, v13, v11, MEMORY[0x1E4F1D510]);
  free(v13);
  if (v15)
  {
LABEL_16:
    *a4 = v15;
    return 0;
  }
LABEL_17:
  uint64_t v17 = 4294954510;
LABEL_18:

  return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
}

uint64_t fmcregion_SetProperty(uint64_t a1, const void *a2, void *a3)
{
  if (!a1) {
    goto LABEL_88;
  }
  uint64_t DerivedStorage = (CFMutableDictionaryRef *)CMBaseObjectGetDerivedStorage(a1);
  if (!a2) {
    goto LABEL_88;
  }
  uint64_t v6 = DerivedStorage;
  if (!DerivedStorage) {
    goto LABEL_88;
  }
  if (!a3)
  {
    CFDictionaryRemoveValue(*DerivedStorage, a2);
    return 0;
  }
  if (CFEqual(a2, @"CMCaptionRegionIdentifier"))
  {
    CFTypeID v7 = CFGetTypeID(a3);
    CFTypeID TypeID = CFStringGetTypeID();
    goto LABEL_20;
  }
  if (CFEqual(a2, @"CMCaptionRegionExplicitRegion"))
  {
    CFDictionaryRef v9 = (CFDictionaryRef *)a3;
LABEL_10:
    CFTypeID v7 = CFGetTypeID(v9);
    CFTypeID TypeID = CFBooleanGetTypeID();
    goto LABEL_20;
  }
  if (CFEqual(a2, @"CMCaptionRegionPosition")) {
    goto LABEL_12;
  }
  if (CFEqual(a2, @"CMCaptionRegionAbstractPosition"))
  {
    CFTypeID v12 = CFGetTypeID(a3);
    if (v12 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
      goto LABEL_88;
    }
    InitialCFArrayRef Value = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    CFTypeID v7 = CFGetTypeID(InitialValue);
    CFTypeID TypeID = FigCaptionPositionGetTypeID();
    goto LABEL_20;
  }
  if (CFEqual(a2, @"CMCaptionRegionWidth") || CFEqual(a2, @"CMCaptionRegionHeight")) {
    goto LABEL_12;
  }
  if (CFEqual(a2, @"CMCaptionRegionDisplayAspectRatio") || CFEqual(a2, @"CMCaptionRegionActiveArea")) {
    goto LABEL_27;
  }
  if (CFEqual(a2, @"CMCaptionRegionAnimation"))
  {
    CFTypeID v15 = CFGetTypeID(a3);
    if (v15 != CFStringGetTypeID()) {
      goto LABEL_88;
    }
    if (CFEqual(a3, @"CMCaptionRegionAnimationType_Rollup")) {
      goto LABEL_21;
    }
    uint64_t v16 = @"CMCaptionRegionAnimationType_None";
    uint64_t v17 = (CFDictionaryRef *)a3;
LABEL_32:
    if (CFEqual(v17, v16)) {
      goto LABEL_21;
    }
    goto LABEL_88;
  }
  if (CFEqual(a2, @"CMCaptionRegionContainerRegion"))
  {
    CFTypeID v7 = CFGetTypeID(a3);
    CFTypeID TypeID = FigCaptionRegionGetTypeID();
    goto LABEL_20;
  }
  if (CFEqual(a2, @"CMCaptionRegionClipOverflow")
    || CFEqual(a2, @"CMCaptionRegionInvisible")
    || CFEqual(a2, @"CMCaptionRegionForcedDisplay")
    || CFEqual(a2, @"CMCaptionRegionHidden"))
  {
    CFTypeID v18 = CFGetTypeID(a3);
    if (v18 == FigCaptionDynamicStyleGetTypeID() && FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
    {
      CFDictionaryRef v9 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      goto LABEL_10;
    }
    goto LABEL_88;
  }
  if (CFEqual(a2, @"CMCaptionRegionShowbackground"))
  {
    CFTypeID v19 = CFGetTypeID(a3);
    if (v19 != FigCaptionDynamicStyleGetTypeID()) {
      goto LABEL_88;
    }
    uint64_t v20 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    if (CFEqual(v20, @"CMCaptionRegionShowbackground_Always")) {
      goto LABEL_21;
    }
    uint64_t v17 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    uint64_t v16 = @"CMCaptionRegionShowbackground_WhenActive";
    goto LABEL_32;
  }
  if (!CFEqual(a2, @"CMCaptionRegionOpacity"))
  {
    if (CFEqual(a2, @"CMCaptionRegionWritingMode"))
    {
      CFTypeID v25 = CFGetTypeID(a3);
      if (v25 != FigCaptionDynamicStyleGetTypeID()) {
        goto LABEL_88;
      }
      if (!FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
        goto LABEL_88;
      }
      CFRange v26 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      CFTypeID v27 = CFGetTypeID(v26);
      if (v27 != CFStringGetTypeID()) {
        goto LABEL_88;
      }
      uint64_t v28 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      if (CFEqual(v28, @"CMCaptionRegionWritingMode_TopToBottomAndLeftToRight")
        || CFEqual(v28, @"CMCaptionRegionWritingMode_TopToButtomAndRightToLeft")
        || CFEqual(v28, @"CMCaptionRegionWritingMode_RightToLeftAndTopToBottom"))
      {
        goto LABEL_21;
      }
      uint64_t v16 = @"CMCaptionRegionWritingMode_LeftToRightAndTopToBottom";
LABEL_69:
      uint64_t v17 = v28;
      goto LABEL_32;
    }
    if (CFEqual(a2, @"CMCaptionRegionDisplayAlign"))
    {
      CFTypeID v29 = CFGetTypeID(a3);
      if (v29 != FigCaptionDynamicStyleGetTypeID()) {
        goto LABEL_88;
      }
      if (!FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
        goto LABEL_88;
      }
      uint64_t v30 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      CFTypeID v31 = CFGetTypeID(v30);
      if (v31 != CFStringGetTypeID()) {
        goto LABEL_88;
      }
      uint64_t v28 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      if (CFEqual(v28, @"CMCaptionRegionDisplayAlign_Before")
        || CFEqual(v28, @"CMCaptionRegionDisplayAlign_After"))
      {
        goto LABEL_21;
      }
      uint64_t v16 = @"CMCaptionRegionDisplayAlign_Center";
      goto LABEL_69;
    }
    if (CFEqual(a2, @"CMCaptionRegionPadding"))
    {
      CFTypeID v32 = CFGetTypeID(a3);
      if (v32 == FigCaptionDynamicStyleGetTypeID())
      {
        if (FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
        {
          uint64_t v33 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
          CFTypeID v34 = CFGetTypeID(v33);
          if (v34 == CFDictionaryGetTypeID())
          {
            long long v35 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
            if (CFDictionaryContainsKey((CFDictionaryRef)v35, @"CMCaptionRegionPadding_Before"))
            {
              if (CFDictionaryContainsKey((CFDictionaryRef)v35, @"CMCaptionRegionPadding_After")
                && CFDictionaryContainsKey((CFDictionaryRef)v35, @"CMCaptionRegionPadding_Start")
                && CFDictionaryContainsKey((CFDictionaryRef)v35, @"CMCaptionRegionPadding_End"))
              {
                goto LABEL_21;
              }
            }
          }
        }
      }
      goto LABEL_88;
    }
    if (!CFEqual(a2, @"CMCaptionRegionAnchor"))
    {
      if (CFEqual(a2, @"CMCaptionRegionZIndex")) {
        goto LABEL_81;
      }
      if (CFEqual(a2, @"CMCaptionRegionBackgroundColor"))
      {
        CFTypeID v38 = CFGetTypeID(a3);
        if (v38 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
          goto LABEL_88;
        }
        CFDataRef v39 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        CFTypeID v7 = CFGetTypeID(v39);
        CFTypeID TypeID = CGColorGetTypeID();
LABEL_20:
        if (v7 == TypeID)
        {
LABEL_21:
          CFDictionarySetValue(*v6, a2, a3);
          return 0;
        }
        goto LABEL_88;
      }
      if (CFEqual(a2, @"CMCaptionRegionCellResolution"))
      {
LABEL_27:
        CFIndex v11 = (CFDictionaryRef *)a3;
        goto LABEL_15;
      }
      if (CFEqual(a2, @"CMCaptionRegionLuminanceGain"))
      {
LABEL_81:
        CFTypeID v36 = CFGetTypeID(a3);
        if (v36 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3)) {
          goto LABEL_88;
        }
        long long v37 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        CFTypeID v7 = CFGetTypeID(v37);
        CFTypeID TypeID = CFNumberGetTypeID();
        goto LABEL_20;
      }
      if (!CFEqual(a2, @"CMCaptionRegionStereoDisparity")) {
        return 4294954512;
      }
    }
LABEL_12:
    CFTypeID v10 = CFGetTypeID(a3);
    if (v10 == FigCaptionDynamicStyleGetTypeID() && FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
    {
      CFIndex v11 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
LABEL_15:
      CFTypeID v7 = CFGetTypeID(v11);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      goto LABEL_20;
    }
LABEL_88:
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  float valuePtr = -1.0;
  CFTypeID v21 = CFGetTypeID(a3);
  if (v21 == FigCaptionDynamicStyleGetTypeID())
  {
    if (FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
    {
      uint64_t v22 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      CFTypeID v23 = CFGetTypeID(v22);
      if (v23 == CFNumberGetTypeID())
      {
        uint64_t v24 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        CFNumberGetValue((CFNumberRef)v24, kCFNumberFloatType, &valuePtr);
        if (valuePtr >= 0.0 && valuePtr <= 1.0) {
          goto LABEL_21;
        }
      }
    }
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointRemoteControlSessionGetClassID()
{
  if (FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce, &FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID, (dispatch_function_t)remoteControlSession_getClassID);
  }
  return FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID;
}

uint64_t remoteControlSession_getClassID(void *a1)
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&remoteControlSession_getClassID_sFigEndpointRemoteControlSessionClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointRemoteControlSessionGetTypeID()
{
  if (FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce != -1) {
    dispatch_once_f(&FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce, &FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID, (dispatch_function_t)remoteControlSession_getClassID);
  }
  uint64_t v0 = (void *)FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef remoteControlSession_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointRemoteControlSession %p]", a1);
}

uint64_t FigGraphGetTypeID()
{
  return sFigGraphID;
}

uint64_t RegisterFigGraph()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigGraphID = result;
  return result;
}

uint64_t FigGraphCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  memset(&keyCallBacks, 0, sizeof(keyCallBacks));
  if (a7 && a6)
  {
    CFDictionaryValueCallBacks v19 = *(CFDictionaryValueCallBacks *)byte_1EDF6E7E8;
    FigThreadRunOnce(&FigGraphGetTypeID_sRegisterFigGraphOnce, (void (*)(void))RegisterFigGraph);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v14 = (void *)Instance;
      *(void *)(Instance + 24) = 0;
      if (a3)
      {
        keyCallBacks.copyDescriptiouint64_t n = *(CFDictionaryCopyDescriptionCallBack *)(a3 + 24);
        copyDescriptiouint64_t n = keyCallBacks.copyDescription;
        *(_OWORD *)&keyCallBacks.CFDictionaryEqualCallBack equal = *(_OWORD *)(a3 + 32);
        CFDictionaryEqualCallBack equal = keyCallBacks.equal;
        *(void *)(Instance + 32) = a2;
        *(_OWORD *)(Instance + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)(a3 + 8);
        *(void *)(Instance + 56) = equal;
        *(void *)(Instance + 64) = copyDescription;
        *(void *)(Instance + 72) = a4;
        *(_OWORD *)(Instance + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(_OWORD *)(a5 + 8);
        *(void *)(Instance + 96) = *(void *)(a5 + 24);
      }
      *(void *)(Instance + 104) = a6;
      CFMutableDictionaryRef v17 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &keyCallBacks, &v19);
      v14[2] = v17;
      if (v17)
      {
        uint64_t result = 0;
        *a7 = v14;
        return result;
      }
      CFRelease(v14);
    }
    return 4294954305;
  }
  else
  {
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t nodeInfoCFDictionaryRetainCallBack(uint64_t a1, uint64_t a2)
{
  return a2;
}

void nodeInfoCFDictionaryReleaseCallBack(CFAllocatorRef allocator, void *ptr)
{
  uint64_t v4 = (void *)ptr[1];
  CFTypeRef v5 = (void (*)(void, void))v4[2];
  if (v5) {
    v5(*v4, *ptr);
  }
  uint64_t v6 = (const void *)ptr[2];
  if (v6) {
    CFRelease(v6);
  }
  CFTypeID v7 = (const void *)ptr[6];
  if (v7) {
    CFRelease(v7);
  }

  CFAllocatorDeallocate(allocator, ptr);
}

BOOL nodeInfoCFDictionaryEqualCallBack(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t FigGraphAppendEdge(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
  CFArrayCallBacks callBacks = *(CFArrayCallBacks *)byte_1EDF6E810;
  if (!a1) {
    return 4294954306;
  }
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 16);
  if (!v5) {
    return 4294954305;
  }
  uint64_t v18 = 0;
  uint64_t result = figGraphCreateNodeInfoAddToDictionary(v5, a2, a1 + 32, &v18);
  if (result) {
    return result;
  }
  uint64_t v9 = v18;
  if (!v18) {
    return 4294954305;
  }
  CFTypeID v10 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (!*(void *)(v18 + 16))
  {
    CFMutableArrayRef v11 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callBacks);
    *(void *)(v9 + 16) = v11;
    if (!v11) {
      return 4294954305;
    }
  }
  uint64_t v17 = 0;
  uint64_t result = figGraphCreateNodeInfoAddToDictionary(*(const __CFDictionary **)(a1 + 16), a3, a1 + 32, &v17);
  if (result) {
    return result;
  }
  uint64_t v12 = v17;
  if (!v17) {
    return 4294954305;
  }
  uint64_t v13 = (uint64_t *)CFAllocatorAllocate(*v10, 24, 0);
  if (!v13) {
    return 4294954305;
  }
  uint64_t v14 = v13;
  _OWORD v13[2] = v12;
  CFTypeID v15 = (void *)(a1 + 72);
  uint64_t v16 = *(uint64_t (**)(void, uint64_t))(a1 + 80);
  if (v16) {
    a4 = v16(*v15, a4);
  }
  *uint64_t v14 = a4;
  v14[1] = (uint64_t)v15;
  CFArrayAppendValue(*(CFMutableArrayRef *)(v9 + 16), v14);
  uint64_t result = 0;
  ++*(void *)(a1 + 24);
  return result;
}

void EdgeInfoCFArrayReleaseCallBack(CFAllocatorRef allocator, void *ptr)
{
  uint64_t v4 = (void *)ptr[1];
  CFDictionaryRef v5 = (void (*)(void, void))v4[2];
  if (v5) {
    v5(*v4, *ptr);
  }

  CFAllocatorDeallocate(allocator, ptr);
}

uint64_t figGraphCreateNodeInfoAddToDictionary(const __CFDictionary *a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t v6 = a2;
  CFArrayRef Value = CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    uint64_t v9 = Value;
  }
  else
  {
    uint64_t v10 = *MEMORY[0x1E4F1CF80];
    uint64_t v9 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 56, 0);
    if (!v9)
    {
      uint64_t result = 4294954305;
      goto LABEL_9;
    }
    if (a3)
    {
      CFMutableArrayRef v11 = *(uint64_t (**)(uint64_t, const void *))(a3 + 8);
      if (v11) {
        uint64_t v6 = (const void *)v11(v10, v6);
      }
    }
    *uint64_t v9 = v6;
    v9[1] = a3;
    v9[5] = 0;
    v9[6] = 0;
    void v9[3] = -1;
    v9[4] = 0;
    CFArrayRef v9[2] = 0;
    CFDictionarySetValue(a1, v6, v9);
  }
  uint64_t result = 0;
LABEL_9:
  *a4 = v9;
  return result;
}

uint64_t FigGraphFindOptimalEdges(uint64_t a1, const void *a2, const void *a3, uint64_t (*a4)(void, void, void, uint64_t), uint64_t a5)
{
  CFTypeRef cf = 0;
  if (!a1) {
    return 4294954306;
  }
  CFDictionaryRef v6 = *(const __CFDictionary **)(a1 + 16);
  if (!v6 || !*(void *)(a1 + 104)) {
    return 4294954305;
  }
  uint64_t Value = (uint64_t)CFDictionaryGetValue(v6, a2);
  int v41 = (void *)Value;
  if (!Value) {
    return Value;
  }
  uint64_t v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a3);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = v12;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  FigPriorityQueueCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 0, 0, (uint64_t)nodeInfoCompare, 0, &cf);
  if (!cf) {
    return 4294954305;
  }
  CFDataRef v39 = a2;
  char v14 = 0;
  CFTypeID v15 = v41;
  v41[3] = -1;
  do
  {
    CFArrayRef v16 = (const __CFArray *)v15[2];
    if (v16)
    {
      CFIndex Count = CFArrayGetCount(v16);
      if (Count >= 1)
      {
        CFIndex v18 = Count;
        for (CFIndex i = 0; i != v18; ++i)
        {
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v41[2], i);
          CFTypeID v21 = (void *)ValueAtIndex[2];
          unint64_t v22 = (*(uint64_t (**)(void, void, void, uint64_t))(a1 + 104))(*v41, *v21, *ValueAtIndex, a5);
          if (v14)
          {
            uint64_t v23 = v41[3];
            uint64_t v24 = v23 + v22;
            if (__CFADD__(v23, v22)) {
              uint64_t v24 = -1;
            }
            if (__CFADD__(v22, v23)) {
              unint64_t v22 = -1;
            }
            else {
              unint64_t v22 = v24;
            }
          }
          if (v22 < v21[3])
          {
            CFTypeID v25 = (void *)v21[6];
            void v21[3] = v22;
            CFRange v26 = v41;
            v21[4] = *ValueAtIndex;
            void v21[5] = v26;
            if (v25) {
              FigPriorityQueueTokenUpdatePriority(v25);
            }
            else {
              FigPriorityQueueInsertItemAndCreateUpdateToken((uint64_t)cf, (uint64_t)v21, v21 + 6);
            }
          }
        }
      }
    }
    FigPriorityQueueGetItem((uint64_t)cf, &v41);
    if (v41) {
      BOOL v27 = v41 == v13;
    }
    else {
      BOOL v27 = 1;
    }
    if (v27) {
      break;
    }
    uint64_t v28 = (const void *)v41[6];
    if (v28)
    {
      CFRelease(v28);
      v41[6] = 0;
    }
    FigPriorityQueueRemoveItem((uint64_t)cf);
    CFTypeID v15 = v41;
    char v14 = 1;
  }
  while (v41);
  if (v13[5])
  {
    uint64_t v29 = 1;
    uint64_t v30 = 1;
    CFTypeID v31 = v13;
    do
    {
      CFTypeID v31 = (void *)v31[5];
      ++v29;
      v30 += 2;
    }
    while (v31 != (void *)Value);
    CFTypeID v32 = CFAllocatorAllocate(allocator, v30 * 8 + 8, 0);
    uint64_t v33 = v32;
    if (v32)
    {
      *CFTypeID v32 = v39;
      v32[v30] = 0;
      uint64_t v34 = (int)v29 - 1;
      do
      {
        v32[2 * v34--] = *v13;
        v32[2 * v34 + 1] = v13[4];
        uint64_t v13 = (void *)v13[5];
      }
      while (v13 != (void *)Value);
      long long v35 = v32 + 2;
      while (--v29)
      {
        CFTypeID v36 = v35 + 2;
        uint64_t v37 = a4(*(v35 - 2), *v35, *(v35 - 1), a5);
        long long v35 = v36;
        if (v37)
        {
          uint64_t Value = v37;
          goto LABEL_42;
        }
      }
      uint64_t Value = 0;
    }
    else
    {
      uint64_t Value = 4294954305;
    }
  }
  else
  {
    uint64_t Value = 0;
    uint64_t v33 = 0;
  }
LABEL_42:
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)CFDictionaryApplierCleanupNodes, 0);
  if (cf) {
    CFRelease(cf);
  }
  if (v33) {
    CFAllocatorDeallocate(allocator, v33);
  }
  return Value;
}

uint64_t nodeInfoCompare(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(a2 + 24);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return -1;
  }
}

void CFDictionaryApplierCleanupNodes(uint64_t a1, void *a2)
{
  if (a2)
  {
    a2[4] = 0;
    a2[5] = 0;
    a2[3] = -1;
    unint64_t v3 = (const void *)a2[6];
    if (v3)
    {
      CFRelease(v3);
      a2[6] = 0;
    }
  }
}

double FigGraphInit(_OWORD *a1)
{
  double result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void FigGraphFinalize(uint64_t a1)
{
  CFDataRef v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

__CFString *FigGraphCopyFormattingDesc(CFDictionaryRef *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v4, 0);
  if (Mutable)
  {
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFStringAppendFormat(Mutable, a2, @"<FigGraph %p [%p]>{\n", a1, v6);
    CFDictionaryApplyFunction(a1[2], (CFDictionaryApplierFunction)graphDataDescriptionApplier, Mutable);
    CFStringAppendFormat(Mutable, a2, @"}");
  }
  return Mutable;
}

__CFString *FigGraphCopyDebugDesc(CFDictionaryRef *a1)
{
  return FigGraphCopyFormattingDesc(a1, 0);
}

void graphDataDescriptionApplier(uint64_t a1, uint64_t a2, __CFString *a3)
{
  if (*(void *)(a2 + 16))
  {
    if (*(void *)a2)
    {
      uint64_t v4 = *(void *)(a2 + 8);
      if (v4)
      {
        BOOL v5 = *(uint64_t (**)(void))(v4 + 32);
        if (v5)
        {
          uint64_t v7 = v5();
          if (v7)
          {
            int v8 = (const void *)v7;
            if (CFArrayGetCount(*(CFArrayRef *)(a2 + 16)) >= 1)
            {
              for (CFIndex i = 0; CFArrayGetCount(*(CFArrayRef *)(a2 + 16)) > i; ++i)
              {
                CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 16), i);
                uint64_t v11 = ValueAtIndex[1];
                uint64_t v12 = (void *)ValueAtIndex[2];
                if (v11 && (uint64_t v13 = *(uint64_t (**)(void))(v11 + 24)) != 0)
                {
                  char v14 = (const void *)v13(*ValueAtIndex);
                  if (!v12) {
                    goto LABEL_19;
                  }
                }
                else
                {
                  char v14 = 0;
                  if (!v12) {
                    goto LABEL_19;
                  }
                }
                if (*v12)
                {
                  uint64_t v15 = v12[1];
                  if (v15)
                  {
                    CFArrayRef v16 = *(uint64_t (**)(void))(v15 + 32);
                    if (v16)
                    {
                      uint64_t v17 = v16();
                      CFIndex v18 = (const void *)v17;
                      if (v14 && v17)
                      {
                        CFStringAppendFormat(a3, 0, @"\t%@ %@ %@\n", v8, v17, v14);
                        CFRelease(v14);
                        char v14 = v18;
                      }
                      else
                      {
                        if (v14) {
                          CFRelease(v14);
                        }
                        char v14 = v18;
                        if (!v18) {
                          continue;
                        }
                      }
LABEL_20:
                      CFRelease(v14);
                      continue;
                    }
                  }
                }
LABEL_19:
                if (v14) {
                  goto LABEL_20;
                }
              }
            }
            CFRelease(v8);
          }
        }
      }
    }
  }
}

uint64_t VEXUBridge_ConvertVideoExtendedUsageDescriptionExtensions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, const void *a7)
{
  v19[0] = a2;
  v19[1] = a3;
  uint64_t v20 = *a4;
  *(_OWORD *)CFArrayRef theArray = 0u;
  *(_OWORD *)CFTypeRef cf = 0u;
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  theArray[1] = Mutable;
  if (!Mutable)
  {
    a6 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  CFArrayRef v13 = Mutable;
  CFArrayRef v14 = CFArrayCreateMutable(v11, 0, MEMORY[0x1E4F1D510]);
  theArray[0] = v14;
  if (!v14
    || (CFArrayRef v15 = v14, (cf[0] = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) == 0))
  {
    uint64_t v16 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  cf[1] = a7;
  FigCFArrayAppendInt32(v15, 1986361461);
  if (!a6)
  {
LABEL_12:
    CFRelease(v13);
    goto LABEL_13;
  }
  memset(v23, 0, sizeof(v23));
  uint64_t v16 = FigAtomStreamInitWithMemoryBlock(a5, a6, 0, 0, (uint64_t)v23);
  if (v16)
  {
LABEL_19:
    a6 = v16;
    goto LABEL_12;
  }
  a6 = parseVideoExtendedUsageExtensionChildAtoms(v23, (uint64_t)parseVideoExtendedUsageExtensionAtom_atomDispatch, 6, (uint64_t)v19);
  CFArrayRef v13 = theArray[1];
  if (!a6)
  {
    if (theArray[1])
    {
      CFIndex Count = CFArrayGetCount(theArray[1]);
      CFArrayRef v13 = theArray[1];
      if (Count >= 1)
      {
        vexuReader_appendKeyAndValue(v19, @"RequiredButUnrecognizedFormatAtoms", theArray[1]);
        CFArrayRef v13 = theArray[1];
      }
    }
    *a4 = v20;
  }
  if (v13) {
    goto LABEL_12;
  }
LABEL_13:
  if (theArray[0]) {
    CFRelease(theArray[0]);
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return a6;
}

void *vexuReader_appendKeyAndValue(void *result, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v4 = result;
  if (*result)
  {
    double result = CFRetain(cf);
    *(void *)(*v4 + 8 * v4[2]) = result;
  }
  if (v4[1])
  {
    double result = CFRetain(a3);
    uint64_t v5 = v4[2];
    *(void *)(v4[1] + 8 * v5) = result;
  }
  else
  {
    uint64_t v5 = v4[2];
  }
  v4[2] = v5 + 1;
  return result;
}

uint64_t VEXUBridge_ConvertVideoExtendedUsageExtensionToAtom(const opaqueCMFormatDescription *a1, size_t *a2, void *a3)
{
  uint64_t v56 = 0;
  memset(v55, 0, sizeof(v55));
  uint64_t v54 = 0;
  memset(v53, 0, sizeof(v53));
  dataPointerOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t DataPointer = CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 8u, 0, &blockBufferOut);
  if (DataPointer) {
    goto LABEL_144;
  }
  uint64_t DataPointer = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v55);
  if (DataPointer) {
    goto LABEL_144;
  }
  uint64_t DataPointer = FigAtomWriterBeginAtom((uint64_t)v55, 0x76657875u, 0);
  if (DataPointer) {
    goto LABEL_144;
  }
  __dst = a3;
  if (a1)
  {
    if (!CMFormatDescriptionGetExtension(a1, @"HasLeftStereoEyeView")
      && !CMFormatDescriptionGetExtension(a1, @"HasRightStereoEyeView")
      && !CMFormatDescriptionGetExtension(a1, @"HasEyeViewsReversed")
      && !CMFormatDescriptionGetExtension(a1, @"HasAdditionalViews")
      && !CMFormatDescriptionGetExtension(a1, @"HeroEye")
      && !CMFormatDescriptionGetExtension(a1, @"StereoCameraBaseline")
      && !CMFormatDescriptionGetExtension(a1, @"HorizontalDisparityAdjustment"))
    {
      goto LABEL_71;
    }
    uint64_t DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
    if (DataPointer) {
      goto LABEL_144;
    }
    uint64_t DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x65796573u, 0);
    if (DataPointer) {
      goto LABEL_144;
    }
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    LODWORD(v59) = 0;
    LOBYTE(v63) = 0;
    CFBooleanRef Extension = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, @"HasLeftStereoEyeView");
    uint64_t v50 = a2;
    if (Extension && (CFBooleanRef v8 = Extension, v9 = CFGetTypeID(Extension), v9 == CFBooleanGetTypeID()))
    {
      int v10 = 1;
      if (CFBooleanGetValue(v8))
      {
        LOBYTE(v63) = 1;
        char v11 = 1;
      }
      else
      {
        char v11 = 0;
      }
    }
    else
    {
      char v11 = 0;
      int v10 = 0;
    }
    CFBooleanRef v12 = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, @"HasRightStereoEyeView");
    if (v12)
    {
      CFBooleanRef v13 = v12;
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v13))
        {
          v11 |= 2u;
          LOBYTE(v63) = v11;
        }
        int v10 = 1;
      }
    }
    CFBooleanRef v15 = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, @"HasAdditionalViews");
    if (v15)
    {
      CFBooleanRef v16 = v15;
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v16))
        {
          v11 |= 4u;
          LOBYTE(v63) = v11;
        }
        int v10 = 1;
      }
    }
    CFBooleanRef v18 = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, @"HasEyeViewsReversed");
    if (v18 && (CFBooleanRef v19 = v18, v20 = CFGetTypeID(v18), v20 == CFBooleanGetTypeID()))
    {
      if (CFBooleanGetValue(v19)) {
        LOBYTE(v63) = v11 | 8;
      }
    }
    else if (!v10)
    {
      goto LABEL_39;
    }
    if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
      && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x73747269u, 0))
    {
      LODWORD(v59) = 0;
      if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)
        && !FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v63, 1))
      {
        FigAtomWriterEndAtom((uint64_t)&v64);
      }
    }
LABEL_39:
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    CFPropertyListRef v21 = CMFormatDescriptionGetExtension(a1, @"HeroEye");
    a2 = v50;
    if (v21)
    {
      unint64_t v22 = v21;
      CFTypeID v23 = CFGetTypeID(v21);
      if (v23 == CFStringGetTypeID())
      {
        if (CFEqual(@"Left", v22))
        {
          char v24 = 1;
        }
        else
        {
          if (!CFEqual(@"Right", v22))
          {
            FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
            goto LABEL_50;
          }
          char v24 = 2;
        }
        LOBYTE(v63) = v24;
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x6865726Fu, 0))
        {
          LODWORD(v59) = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)
            && !FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v63, 1))
          {
            FigAtomWriterEndAtom((uint64_t)&v64);
          }
        }
      }
    }
LABEL_50:
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    uint64_t v62 = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v59 = 0u;
    unsigned int valuePtr = 0;
    CFNumberRef v25 = (const __CFNumber *)CMFormatDescriptionGetExtension(a1, @"StereoCameraBaseline");
    if (v25)
    {
      CFNumberRef v26 = v25;
      CFTypeID v27 = CFGetTypeID(v25);
      if (v27 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v26, kCFNumberSInt32Type, &valuePtr);
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x63616D73u, 0)
          && !FigAtomWriterInitWithParent((uint64_t)&v64, (uint64_t)&v59)
          && !FigAtomWriterBeginAtom((uint64_t)&v59, 0x626C696Eu, 0))
        {
          unsigned int v63 = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&v63, 4))
          {
            unsigned int v63 = bswap32(valuePtr);
            if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&v63, 4)
              && !FigAtomWriterEndAtom((uint64_t)&v59))
            {
              FigAtomWriterEndAtom((uint64_t)&v64);
            }
          }
        }
      }
    }
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    uint64_t v62 = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v59 = 0u;
    unsigned int v57 = 0;
    CFNumberRef v28 = (const __CFNumber *)CMFormatDescriptionGetExtension(a1, @"HorizontalDisparityAdjustment");
    if (v28)
    {
      CFNumberRef v29 = v28;
      CFTypeID v30 = CFGetTypeID(v28);
      if (v30 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v29, kCFNumberSInt32Type, &v57);
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x636D6679u, 0)
          && !FigAtomWriterInitWithParent((uint64_t)&v64, (uint64_t)&v59)
          && !FigAtomWriterBeginAtom((uint64_t)&v59, 0x6461646Au, 0))
        {
          unsigned int v63 = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&v63, 4))
          {
            unsigned int valuePtr = bswap32(v57);
            if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&valuePtr, 4)
              && !FigAtomWriterEndAtom((uint64_t)&v59))
            {
              FigAtomWriterEndAtom((uint64_t)&v64);
            }
          }
        }
      }
    }
    uint64_t DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
    if (DataPointer) {
      goto LABEL_144;
    }
LABEL_71:
    if (CMFormatDescriptionGetExtension(a1, @"TransportIdentifier"))
    {
      uint64_t DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
      if (DataPointer) {
        goto LABEL_144;
      }
      uint64_t DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x636D7261u, 0);
      if (DataPointer) {
        goto LABEL_144;
      }
      uint64_t v67 = 0;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v64 = 0u;
      unsigned int v63 = 0;
      CFNumberRef v31 = (const __CFNumber *)CMFormatDescriptionGetExtension(a1, @"TransportIdentifier");
      if (v31)
      {
        CFNumberRef v32 = v31;
        CFTypeID v33 = CFGetTypeID(v31);
        if (v33 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v32, kCFNumberSInt32Type, &v63);
          if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
            && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x74696E79u, 0))
          {
            LODWORD(v59) = 0;
            if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
            {
              LODWORD(v59) = bswap32(v63);
              if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)) {
                FigAtomWriterEndAtom((uint64_t)&v64);
              }
            }
          }
        }
      }
      uint64_t DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
      if (DataPointer) {
        goto LABEL_144;
      }
    }
    if (!CMFormatDescriptionGetExtension(a1, @"ProjectionKind")) {
      goto LABEL_103;
    }
    uint64_t DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
    if (DataPointer) {
      goto LABEL_144;
    }
    uint64_t DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x70726F6Au, 0);
    if (DataPointer) {
      goto LABEL_144;
    }
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    CFPropertyListRef v34 = CMFormatDescriptionGetExtension(a1, @"ProjectionKind");
    if (v34)
    {
      long long v35 = v34;
      CFTypeID v36 = CFGetTypeID(v34);
      if (v36 == CFStringGetTypeID())
      {
        if (CFEqual(@"Rectilinear", v35))
        {
          unsigned int v37 = 1919247220;
        }
        else if (CFEqual(@"Equirectangular", v35))
        {
          unsigned int v37 = 1701934441;
        }
        else if (CFEqual(@"HalfEquirectangular", v35))
        {
          unsigned int v37 = 1751478645;
        }
        else
        {
          if (!CFEqual(@"Fisheye", v35))
          {
            FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
            goto LABEL_102;
          }
          unsigned int v37 = 1718186856;
        }
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x70726A69u, 0))
        {
          LODWORD(v59) = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
          {
            LODWORD(v59) = bswap32(v37);
            if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)) {
              FigAtomWriterEndAtom((uint64_t)&v64);
            }
          }
        }
      }
    }
LABEL_102:
    uint64_t DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
    if (DataPointer) {
      goto LABEL_144;
    }
LABEL_103:
    if (!CMFormatDescriptionGetExtension(a1, @"ViewPackingKind"))
    {
LABEL_118:
      if (CMFormatDescriptionGetExtension(a1, @"WarpKind"))
      {
        uint64_t DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
        if (DataPointer) {
          goto LABEL_144;
        }
        uint64_t DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x77617270u, 0);
        if (DataPointer) {
          goto LABEL_144;
        }
        uint64_t v67 = 0;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v64 = 0u;
        CFPropertyListRef v42 = CMFormatDescriptionGetExtension(a1, @"WarpKind");
        if (v42)
        {
          int v43 = v42;
          CFTypeID v44 = CFGetTypeID(v42);
          if (v44 == CFStringGetTypeID())
          {
            if (CFEqual(@"ApplicationDefined", v43))
            {
              if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
                && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x77727069u, 0))
              {
                LODWORD(v59) = 0;
                if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
                {
                  LODWORD(v59) = 1953723747;
                  if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)) {
                    FigAtomWriterEndAtom((uint64_t)&v64);
                  }
                }
              }
            }
            else
            {
              FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
            }
          }
        }
        uint64_t DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
        if (DataPointer) {
          goto LABEL_144;
        }
      }
      goto LABEL_131;
    }
    uint64_t DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
    if (DataPointer) {
      goto LABEL_144;
    }
    uint64_t DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x7061636Bu, 0);
    if (DataPointer) {
      goto LABEL_144;
    }
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    CFPropertyListRef v38 = CMFormatDescriptionGetExtension(a1, @"ViewPackingKind");
    if (!v38) {
      goto LABEL_117;
    }
    CFDataRef v39 = v38;
    CFTypeID v40 = CFGetTypeID(v38);
    if (v40 != CFStringGetTypeID()) {
      goto LABEL_117;
    }
    if (CFEqual(@"SideBySide", v39))
    {
      unsigned int v41 = 1936286821;
    }
    else
    {
      if (!CFEqual(@"OverUnder", v39))
      {
        FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
        goto LABEL_117;
      }
      unsigned int v41 = 1870030194;
    }
    if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
      && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x706B696Eu, 0))
    {
      LODWORD(v59) = 0;
      if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
      {
        LODWORD(v59) = bswap32(v41);
        if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)) {
          FigAtomWriterEndAtom((uint64_t)&v64);
        }
      }
    }
LABEL_117:
    uint64_t DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
    if (!DataPointer) {
      goto LABEL_118;
    }
LABEL_144:
    uint64_t v46 = DataPointer;
    goto LABEL_135;
  }
LABEL_131:
  uint64_t DataPointer = FigAtomWriterEndAtom((uint64_t)v55);
  if (DataPointer) {
    goto LABEL_144;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_144;
  }
  size_t DataLength = CMBlockBufferGetDataLength(blockBufferOut);
  if (DataLength == 8)
  {
    uint64_t v46 = 0;
LABEL_135:
    size_t v47 = 0;
    goto LABEL_139;
  }
  size_t v47 = DataLength;
  if (__dst) {
    memcpy(__dst, dataPointerOut, DataLength);
  }
  uint64_t v46 = 0;
LABEL_139:
  *a2 = v47;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v46;
}

uint64_t parseRequiredBoxTypesAtom(uint64_t a1, uint64_t a2)
{
  int v17 = 0;
  size_t size = 0;
  CFArrayRef v3 = *(const __CFArray **)(a2 + 24);
  if (!v3
    || (CFIndex Count = CFArrayGetCount(v3), Count <= 0)
    || (CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 24), Count - 2)) == 0)
  {
    uint64_t v14 = 4294954516;
LABEL_11:
    CurrentAtomTypeAndsize_t DataLength = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  uint64_t v7 = ValueAtIndex;
  CurrentAtomTypeAndsize_t DataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v17, &size);
  if (CurrentAtomTypeAndDataLength)
  {
LABEL_12:
    uint64_t v13 = CurrentAtomTypeAndDataLength;
    CFTypeID v9 = 0;
LABEL_13:
    free(v9);
    return v13;
  }
  if ((size & 3) != 0)
  {
    uint64_t v14 = 4294954584;
    goto LABEL_11;
  }
  CFTypeID v9 = (UInt8 *)malloc_type_malloc(size, 0x29CAD75FuLL);
  if (!v9) {
    goto LABEL_15;
  }
  uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1, 0, size, (uint64_t)v9);
  if (CurrentAtomData)
  {
LABEL_16:
    uint64_t v13 = CurrentAtomData;
    goto LABEL_13;
  }
  CFDataRef v11 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9 + 4, size - 4);
  if (!v11)
  {
LABEL_15:
    uint64_t CurrentAtomData = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  CFDataRef v12 = v11;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 40), v7, v11);
  free(v9);
  CFRelease(v12);
  return 0;
}

uint64_t parseStereoViewAtom(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)parseStereoViewAtom_atomDispatch, 5, a2);
    }
  }
  return result;
}

uint64_t parseCameraIdentifierAtom(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)parseCameraIdentifierAtom_atomDispatch, 2, a2);
    }
  }
  return result;
}

uint64_t parseProjectionAtom(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)parseProjectionAtom_atomDispatch, 2, a2);
    }
  }
  return result;
}

uint64_t parsePackingAtom(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)parsePackingAtom_atomDispatch, 2, a2);
    }
  }
  return result;
}

uint64_t parseWarpAtom(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)parseWarpAtom_atomDispatch, 2, a2);
    }
  }
  return result;
}

uint64_t parseVideoExtendedUsageExtensionChildAtoms(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFMutableArrayRef v10 = Mutable;
    int v53 = 0;
    CFDataRef v11 = (_DWORD *)(a2 + 8);
    do
    {
      CurrentAtomTypeAndsize_t DataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)a1, &v53, 0);
      if (CurrentAtomTypeAndDataLength)
      {
LABEL_47:
        uint64_t v19 = CurrentAtomTypeAndDataLength;
        goto LABEL_46;
      }
      if (a3 >= 1)
      {
        uint64_t v13 = v11;
        uint64_t v14 = v11;
        uint64_t v15 = a3;
        while (v53 != *(v13 - 2))
        {
          v14 += 4;
          v13 += 4;
          if (!--v15) {
            goto LABEL_14;
          }
        }
        FigCFArrayAppendInt32(*(void **)(a4 + 24), v53);
        CurrentAtomTypeAndsize_t DataLength = (*(uint64_t (**)(void *, uint64_t))v13)(a1, a4);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_47;
        }
        FigCFArrayAppendInt32(v10, v53);
        CFBooleanRef v16 = *(__CFArray **)(a4 + 24);
        if (v16) {
          CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a4 + 24));
        }
        else {
          CFIndex Count = 0;
        }
        CFArrayRemoveValueAtIndex(v16, Count - 1);
      }
LABEL_14:
      Atouint64_t m = FigAtomStreamAdvanceToNextAtom(a1);
    }
    while (!Atom);
    uint64_t v19 = Atom;
    if (Atom == -12890) {
      uint64_t v19 = 0;
    }
    CFArrayRef v20 = *(const __CFArray **)(a4 + 24);
    if (v20)
    {
      CFIndex v21 = CFArrayGetCount(v20);
      if (v21 > 0)
      {
        CFNumberRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 24), v21 - 1);
        if (ValueAtIndex)
        {
          CFTypeID v23 = ValueAtIndex;
          CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 40), ValueAtIndex);
          if (!Value) {
            goto LABEL_46;
          }
          CFDataRef v25 = Value;
          size_t v47 = v23;
          CFIndex Length = CFDataGetLength(Value);
          BytePtr = CFDataGetBytePtr(v25);
          uint64_t v28 = Length + 3;
          if (Length >= 0) {
            uint64_t v28 = Length;
          }
          if (Length < 4)
          {
LABEL_43:
            CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 40), v47);
            goto LABEL_46;
          }
          CFNumberRef v29 = BytePtr;
          uint64_t v30 = 0;
          uint64_t v52 = v28 >> 2;
          uint64_t v48 = BytePtr;
          __int16 v49 = v10;
          CFAllocatorRef allocator = v8;
          while (1)
          {
            unsigned int v31 = bswap32(*(_DWORD *)&v29[4 * v30]);
            if (!FigCFArrayContainsInt32(v10, v31))
            {
              uint64_t v54 = 0;
              CFMutableArrayRef v32 = CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
              if (!v32)
              {
                uint64_t v45 = 4294954510;
                goto LABEL_45;
              }
              CFMutableArrayRef v33 = v32;
              CFMutableStringRef v34 = CFStringCreateMutable(v8, 0);
              if (!v34)
              {
                FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                CFRelease(v33);
                goto LABEL_46;
              }
              long long v35 = v34;
              for (CFIndex i = 0; ; ++i)
              {
                CFArrayRef v37 = *(const __CFArray **)(a4 + 24);
                if (v37) {
                  CFArrayRef v37 = (const __CFArray *)CFArrayGetCount(v37);
                }
                if (i >= (uint64_t)v37) {
                  break;
                }
                *(_DWORD *)__str = 0;
                FigCFArrayGetInt32AtIndex(*(const void **)(a4 + 24), i, __str);
                FigCFArrayAppendInt32(v33, *(int *)__str);
                if (i) {
                  CFPropertyListRef v38 = "/";
                }
                else {
                  CFPropertyListRef v38 = "";
                }
                CFStringAppendFormat(v35, 0, @"%s%c%c%c%c", v38, __str[3], __str[2], __str[1], __str[0], v47);
              }
              FigCFArrayAppendInt32(v33, v31);
              CFArrayAppendValue(*(CFMutableArrayRef *)(a4 + 32), v33);
              CFStringAppendFormat(v35, 0, @"/%c%c%c%c", HIBYTE(v31), BYTE2(v31), BYTE1(v31), v31);
              CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v35, 0x8000100u, (char **)&v54);
              snprintf(__str, 0x100uLL, "The video extensibility usability box indicates that the content requires that readers successfully parse the '%s' box, which this reader can not do.", CStringPtrAndBufferToFree);
              FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
              uint64_t v40 = *(void *)(a4 + 48);
              if (v40)
              {
                CFMutableDictionaryRef v41 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (v41)
                {
                  CFMutableDictionaryRef v42 = v41;
                  uint64_t v50 = v40;
                  int v43 = CFStringCreateMutable(allocator, 0);
                  if (v43)
                  {
                    CFTypeID v44 = v43;
                    CFStringAppendFormat(v43, 0, @" %s.", __str);
                    FigCFDictionarySetInt64(v42, @"MessageType", 4);
                    CFDictionarySetValue(v42, @"DiagnosticInformation", v44);
                    FigCFDictionarySetInt32(v42, @"AnalysisType", 1836019574);
                    FigAssetAnalysisReporterAddMessage(v50, v42);
                    CFRelease(v44);
                  }
                  CFRelease(v42);
                }
              }
              free(v54);
              CFRelease(v33);
              CFRelease(v35);
              CFNumberRef v29 = v48;
              CFMutableArrayRef v10 = v49;
              CFAllocatorRef v8 = allocator;
            }
            if (++v30 == v52) {
              goto LABEL_43;
            }
          }
        }
      }
    }
    uint64_t v45 = 4294954516;
LABEL_45:
    FigSignalErrorAt(v45, 0, 0, 0, 0, 0, 0);
LABEL_46:
    CFRelease(v10);
    return v19;
  }
  else
  {
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t parseStereoViewInformationAtom(uint64_t a1, void *a2)
{
  int v10 = 0;
  uint64_t v9 = 0;
  char v8 = 0;
  int v7 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!result)
  {
    if (v9 != 5) {
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
    uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 5, (uint64_t)&v7);
    if (!result)
    {
      char v5 = v8;
      uint64_t v6 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      if (v8)
      {
        vexuReader_appendKeyAndValue(a2, @"HasLeftStereoEyeView", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
        char v5 = v8;
        if ((v8 & 2) == 0)
        {
LABEL_6:
          if ((v5 & 4) == 0) {
            goto LABEL_7;
          }
          goto LABEL_13;
        }
      }
      else if ((v8 & 2) == 0)
      {
        goto LABEL_6;
      }
      vexuReader_appendKeyAndValue(a2, @"HasRightStereoEyeView", *v6);
      char v5 = v8;
      if ((v8 & 4) == 0)
      {
LABEL_7:
        if ((v5 & 8) == 0) {
          return 0;
        }
LABEL_8:
        vexuReader_appendKeyAndValue(a2, @"HasEyeViewsReversed", *v6);
        return 0;
      }
LABEL_13:
      vexuReader_appendKeyAndValue(a2, @"HasAdditionalViews", *v6);
      if ((v8 & 8) == 0) {
        return 0;
      }
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t parseHeroStereoEyeAtom(uint64_t a1, void *a2)
{
  int v10 = 0;
  uint64_t v9 = 0;
  unsigned __int8 v8 = 0;
  int v7 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!result)
  {
    if (v9 != 5)
    {
      uint64_t v6 = 4294954584;
      return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
    }
    uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 5, (uint64_t)&v7);
    if (!result)
    {
      uint64_t result = v8;
      if (v8)
      {
        if (v8 == 2)
        {
          char v5 = kFigFormatDescriptionHeroEye_Right;
          goto LABEL_9;
        }
        if (v8 == 1)
        {
          char v5 = kFigFormatDescriptionHeroEye_Left;
LABEL_9:
          vexuReader_appendKeyAndValue(a2, @"HeroEye", *v5);
          return 0;
        }
        uint64_t v6 = 4294954580;
        return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return result;
}

uint64_t parseStereoCameraSystemAtom(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)parseStereoCameraSystemAtom_atomDispatch, 2, a2);
    }
  }
  return result;
}

uint64_t parseStereoComfortAtom(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!result)
  {
    uint64_t result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!result) {
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)parseStereoComfortAtom_atomDispatch, 2, a2);
    }
  }
  return result;
}

uint64_t parseStereoCameraSystemBaselineAtom(uint64_t a1, void *a2)
{
  int v10 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!result)
  {
    if (v9 == 8)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if (result) {
        return result;
      }
      CFNumberRef UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], bswap32(HIDWORD(v8)));
      if (UInt32)
      {
        CFNumberRef v6 = UInt32;
        vexuReader_appendKeyAndValue(a2, @"StereoCameraBaseline", UInt32);
        CFRelease(v6);
        return 0;
      }
      uint64_t v7 = 4294954583;
    }
    else
    {
      uint64_t v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseStereoComfortDisparityAdjustmentAtom(uint64_t a1, void *a2)
{
  int v10 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!result)
  {
    if (v9 == 8)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if (result) {
        return result;
      }
      CFNumberRef SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], bswap32(HIDWORD(v8)));
      if (SInt32)
      {
        CFNumberRef v6 = SInt32;
        vexuReader_appendKeyAndValue(a2, @"HorizontalDisparityAdjustment", SInt32);
        CFRelease(v6);
        return 0;
      }
      uint64_t v7 = 4294954583;
    }
    else
    {
      uint64_t v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseTransportIdentifierAtom(uint64_t a1, void *a2)
{
  int v10 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!result)
  {
    if (v9 == 8)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if (result) {
        return result;
      }
      CFNumberRef UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], bswap32(HIDWORD(v8)));
      if (UInt32)
      {
        CFNumberRef v6 = UInt32;
        vexuReader_appendKeyAndValue(a2, @"TransportIdentifier", UInt32);
        CFRelease(v6);
        return 0;
      }
      uint64_t v7 = 4294954583;
    }
    else
    {
      uint64_t v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseProjectionInformationAtom(uint64_t a1, void *a2)
{
  int v10 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!result)
  {
    if (v9 == 8)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if (result) {
        return result;
      }
      int v5 = bswap32(HIDWORD(v8));
      HIDWORD(v8) = v5;
      if (v5 > 1751478644)
      {
        if (v5 == 1751478645)
        {
          CFNumberRef v6 = kFigFormatDescriptionProjectionKind_HalfEquirectangular;
          goto LABEL_13;
        }
        if (v5 == 1919247220)
        {
          CFNumberRef v6 = kFigFormatDescriptionProjectionKind_Rectilinear;
          goto LABEL_13;
        }
      }
      else
      {
        if (v5 == 1701934441)
        {
          CFNumberRef v6 = kFigFormatDescriptionProjectionKind_Equirectangular;
          goto LABEL_13;
        }
        if (v5 == 1718186856)
        {
          CFNumberRef v6 = kFigFormatDescriptionProjectionKind_Fisheye;
LABEL_13:
          vexuReader_appendKeyAndValue(a2, @"ProjectionKind", *v6);
          return 0;
        }
      }
      uint64_t v7 = 4294954580;
    }
    else
    {
      uint64_t v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseViewPackingInformationAtom(uint64_t a1, void *a2)
{
  int v10 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!result)
  {
    if (v9 == 8)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if (result) {
        return result;
      }
      unsigned int v5 = bswap32(HIDWORD(v8));
      HIDWORD(v8) = v5;
      if (v5 == 1870030194)
      {
        CFNumberRef v6 = kFigFormatDescriptionViewPackingKind_OverUnder;
        goto LABEL_8;
      }
      if (v5 == 1936286821)
      {
        CFNumberRef v6 = kFigFormatDescriptionViewPackingKind_SideBySide;
LABEL_8:
        vexuReader_appendKeyAndValue(a2, @"ViewPackingKind", *v6);
        return 0;
      }
      uint64_t v7 = 4294954580;
    }
    else
    {
      uint64_t v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseWarpInformationAtom(uint64_t a1, void *a2)
{
  int v9 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v9, &v8);
  if (!result)
  {
    if (v8 == 8)
    {
      uint64_t result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v7);
      if (result) {
        return result;
      }
      int v5 = HIDWORD(v7);
      HIDWORD(v7) = bswap32(HIDWORD(v7));
      if (v5 == 1953723747)
      {
        vexuReader_appendKeyAndValue(a2, @"WarpKind", @"ApplicationDefined");
        return 0;
      }
      uint64_t v6 = 4294954580;
    }
    else
    {
      uint64_t v6 = 4294954584;
    }
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigEndpointMessengerGetClassID()
{
  if (FigEndpointMessengerGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigEndpointMessengerGetClassID_sRegisterOnce, &FigEndpointMessengerGetClassID_sClassID, (dispatch_function_t)messenger_getClassID);
  }
  return FigEndpointMessengerGetClassID_sClassID;
}

uint64_t messenger_getClassID(void *a1)
{
  ClassID = CMBaseGetClassID();

  return FigBaseClassRegisterClass((uint64_t)&messenger_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointMessengerGetTypeID()
{
  if (FigEndpointMessengerGetClassID_sRegisterOnce != -1) {
    dispatch_once_f(&FigEndpointMessengerGetClassID_sRegisterOnce, &FigEndpointMessengerGetClassID_sClassID, (dispatch_function_t)messenger_getClassID);
  }
  uint64_t v0 = (void *)FigEndpointMessengerGetClassID_sClassID;

  return CMBaseClassGetCFTypeID(v0);
}

CFStringRef messenger_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigEndpointMessenger %p]", a1);
}

uint64_t FigCaptionTextShadowGetTypeID()
{
  return sFigCaptionTextShadowID;
}

uint64_t RegisterFigCaptionTextShadowType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionTextShadowID = result;
  return result;
}

uint64_t FigCaptionTextShadowGetColor(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t FigCaptionTextShadowGetHorizontalAxisOffset(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t FigCaptionTextShadowGetVerticalAxisOffset(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t FigCaptionTextShadowGetBlurRadius(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t FigCaptionTextShadowCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CGColor *a8, void *a9)
{
  if (a9)
  {
    FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      int v17 = (void *)Instance;
      CGColorRef v18 = CGColorRetain(a8);
      void v17[7] = a7;
      v17[8] = v18;
      int v17[2] = a2;
      _OWORD v17[3] = a3;
      void v17[4] = a4;
      v17[5] = a5;
      v17[6] = a6;
      *a9 = v17;
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionTextShadowCreateNone(uint64_t a1, void *a2)
{
  return FigCaptionTextShadowCreate(a1, 0, 0x100000000, 0, 0x100000000, 0, 0x100000000, 0, a2);
}

uint64_t FigCaptionTextShadowListGetTypeID()
{
  return sFigCaptionTextShadowListID;
}

uint64_t RegisterFigCaptionTextShadowListType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionTextShadowListID = result;
  return result;
}

uint64_t FigCaptionTextShadowListGetTextShadowArray(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t FigCaptionTextShadowListCreate(const __CFAllocator *a1, const __CFArray *a2, uint64_t *a3)
{
  if (a3)
  {
    FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v8 = Instance;
      if (a2) {
        CFArrayRef Copy = CFArrayCreateCopy(a1, a2);
      }
      else {
        CFArrayRef Copy = 0;
      }
      *(void *)(v8 + 16) = Copy;
      *a3 = v8;
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionTextShadowListCreateNone(const __CFAllocator *a1, uint64_t *a2)
{
  return FigCaptionTextShadowListCreate(a1, 0, a2);
}

double fcts_Init(uint64_t a1)
{
  *(void *)(a1 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void fcts_Finalize(uint64_t a1)
{
}

BOOL fcts_Equal(BOOL result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
    double result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextShadowID)
      {
        CFTypeID v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
        if (v5 == sFigCaptionTextShadowID)
        {
          double result = CGColorEqualToColor(*(CGColorRef *)(v3 + 64), *(CGColorRef *)(a2 + 64));
          if (result)
          {
            double result = FigGeometryDimensionEqualToDimension(*(void *)(v3 + 16), *(void *)(v3 + 24), *(void *)(a2 + 16), *(void *)(a2 + 24));
            if (result)
            {
              double result = FigGeometryDimensionEqualToDimension(*(void *)(v3 + 32), *(void *)(v3 + 40), *(void *)(a2 + 32), *(void *)(a2 + 40));
              if (result) {
                return FigGeometryDimensionEqualToDimension(*(void *)(v3 + 48), *(void *)(v3 + 56), *(void *)(a2 + 48), *(void *)(a2 + 56));
              }
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fcts_Hash(void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
  if (v2 != sFigCaptionTextShadowID) {
    return 0;
  }
  uint64_t v3 = (const void *)a1[8];

  return CFHash(v3);
}

CFStringRef fcts_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextShadow %p]", a1);
}

CFStringRef fcts_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextShadow %p]", a1);
}

uint64_t fctslist_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void fctslist_Finalize(uint64_t a1)
{
  CFDataRef v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t fctslist_Equal(uint64_t result, CFArrayRef *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
    double result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextShadowListID)
      {
        CFTypeID v5 = CFGetTypeID(a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
        if (v5 != sFigCaptionTextShadowListID) {
          return 0;
        }
        CFArrayRef v6 = *(const __CFArray **)(v3 + 16);
        CFIndex v7 = v6 ? CFArrayGetCount(v6) : 0;
        CFArrayRef Count = a2[2];
        if (Count) {
          CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
        }
        if ((const __CFArray *)v7 == Count)
        {
          if (v7 < 1)
          {
            return 1;
          }
          else
          {
            CFIndex v9 = 0;
            while (1)
            {
              CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 16), v9);
              CFDataRef v11 = CFArrayGetValueAtIndex(a2[2], v9);
              double result = FigCFEqual(ValueAtIndex, v11);
              if (!result) {
                break;
              }
              if (v7 == ++v9) {
                return 1;
              }
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fctslist_Hash(void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
  if (v2 != sFigCaptionTextShadowListID) {
    return 0;
  }
  uint64_t v3 = (const void *)a1[2];

  return CFHash(v3);
}

CFStringRef fctslist_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextShadowList %p]", a1);
}

CFStringRef fctslist_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextShadowList %p]", a1);
}

uint64_t flipPointCloudDescriptionData(int8x8_t *a1, unint64_t a2)
{
  if (a2 <= 0xF) {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  unsigned int v2 = bswap32(a1[1].u32[0]);
  unsigned int v3 = bswap32(a1[1].u16[2]) >> 16;
  unsigned int v4 = bswap32(a1[1].u16[3]) >> 16;
  *a1 = vrev32_s8(*a1);
  a1[1].i32[0] = v2;
  a1[1].i16[2] = v3;
  a1[1].i16[3] = v4;
  return 0;
}

uint64_t CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionData(CFAllocatorRef alloc, unsigned int *a2, unint64_t a3, CMMediaType a4, CMFormatDescriptionRef *a5)
{
  if (a2)
  {
    if (a3 <= 0xF)
    {
      uint64_t v28 = 4294954584;
    }
    else if (a5)
    {
      signed int v5 = bswap32(*a2);
      if (v5 >= 0x10 && v5 <= a3)
      {
        unsigned int v29 = a2[1];
        unint64_t v8 = v5 - 16;
        *(_DWORD *)bytes = 0;
        if (v8 >= 8)
        {
          CFMutableArrayRef Mutable = 0;
          int v10 = 0;
          CFDataRef v11 = a2 + 4;
          while (1)
          {
            signed int v12 = bswap32(*v11);
            uint64_t v13 = v12;
            if (v12 < 8 || v8 < v12) {
              goto LABEL_42;
            }
            unsigned int v15 = v11[1];
            unsigned int v16 = bswap32(v15);
            if (v16 != 1718773093 && v16 != 1936419184)
            {
              if (v16 == 1852863603)
              {
                if (*v11 != 201326592) {
                  goto LABEL_42;
                }
                int v10 = bswap32(v11[2]);
              }
              else
              {
                if (!Mutable)
                {
                  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  if (!Mutable)
                  {
                    uint64_t v24 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                    CFDataRef v25 = 0;
                    goto LABEL_35;
                  }
                }
                *(_DWORD *)bytes = v15;
                CFStringRef v18 = CFStringCreateWithBytes(alloc, bytes, 4, 0, 0);
                if (!v18)
                {
                  uint64_t v24 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_47:
                  CFTypeID v23 = 0;
                  goto LABEL_34;
                }
                CFStringRef v19 = v18;
                CFDataRef v20 = CFDataCreate(alloc, (const UInt8 *)v11 + 8, v13 - 8);
                if (!v20)
                {
                  uint64_t v24 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                  CFRelease(v19);
                  goto LABEL_47;
                }
                CFDataRef v21 = v20;
                CFDictionarySetValue(Mutable, v19, v20);
                CFRelease(v21);
                CFRelease(v19);
              }
            }
            CFDataRef v11 = (unsigned int *)((char *)v11 + v13);
            v8 -= v13;
            if (v8 <= 7) {
              goto LABEL_30;
            }
          }
        }
        int v10 = 0;
        CFMutableArrayRef Mutable = 0;
LABEL_30:
        if (v8)
        {
LABEL_42:
          uint64_t v27 = 4294954582;
        }
        else
        {
          CFMutableDictionaryRef v22 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (v22)
          {
            CFTypeID v23 = v22;
            FigCFDictionarySetInt32(v22, @"NumberOfPointsPerSample", v10);
            if (Mutable)
            {
              CFDictionarySetValue(v23, @"SampleDescriptionExtensionAtoms", Mutable);
              uint64_t v24 = 0;
LABEL_34:
              CFRelease(Mutable);
              CFDataRef v25 = v23;
              goto LABEL_35;
            }
            CFDataRef v25 = v23;
LABEL_38:
            uint64_t v24 = CMFormatDescriptionCreate(alloc, a4, bswap32(v29), v23, a5);
LABEL_39:
            if (v25) {
              CFRelease(v25);
            }
            return v24;
          }
          uint64_t v27 = 4294954583;
        }
        uint64_t v24 = FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
        CFTypeID v23 = 0;
        CFDataRef v25 = 0;
        if (Mutable) {
          goto LABEL_34;
        }
LABEL_35:
        CFTypeID v23 = v25;
        if (v24) {
          goto LABEL_39;
        }
        goto LABEL_38;
      }
      uint64_t v28 = 4294954582;
    }
    else
    {
      uint64_t v28 = 4294954584;
    }
  }
  else
  {
    uint64_t v28 = 4294954584;
  }

  return FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
}

uint64_t CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, uint64_t a3, CMMediaType a4, CMFormatDescriptionRef *a5)
{
  uint64_t v13 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  if (theBuffer && a5)
  {
    CFIndex v7 = theBuffer;
    size_t DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (!CMBlockBufferIsRangeContiguous(v7, 0, 0))
    {
      uint64_t DataPointer = CMBlockBufferCreateContiguous(a1, v7, a1, 0, 0, 0, 0, &blockBufferOut);
      if (DataPointer) {
        goto LABEL_8;
      }
      CFIndex v7 = blockBufferOut;
    }
    uint64_t DataPointer = CMBlockBufferGetDataPointer(v7, 0, 0, 0, &v13);
    if (!DataPointer) {
      uint64_t DataPointer = CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionData(a1, (unsigned int *)v13, DataLength, a4, a5);
    }
  }
  else
  {
    uint64_t DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
LABEL_8:
  uint64_t v11 = DataPointer;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v11;
}

uint64_t CMPointCloudFormatDescriptionCopyAsBigEndianPointCloudDescriptionBlockBuffer(const __CFAllocator *a1, CFTypeRef cf, uint64_t a3, CMBlockBufferRef *a4)
{
  unint64_t sourceBytes = 0;
  unint64_t v25 = 0;
  destinationuint64_t Buffer = 0;
  if (cf)
  {
    if (a4)
    {
      CFTypeID v7 = CFGetTypeID(cf);
      if (v7 == CMFormatDescriptionGetTypeID()
        && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)cf) == 1885564004)
      {
        CFDictionaryRef Extensions = CMFormatDescriptionGetExtensions((CMFormatDescriptionRef)cf);
        CFDictionaryRef v9 = Extensions;
        if (!Extensions)
        {
          uint64_t v11 = 0;
          CFDataRef Value = 0;
          size_t v13 = 0;
          int v17 = 0;
          goto LABEL_21;
        }
        uint64_t v26 = 0;
        uint64_t v30 = 0;
        long long v28 = 0u;
        long long v29 = 0u;
        long long context = 0u;
        CMBlockBufferRef blockBufferOut = 0;
        if (FigCFDictionaryGetInt32IfPresent((uint64_t)Extensions, @"NumberOfPointsPerSample", (char *)&v26 + 4))
        {
          uint64_t appended = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
          if (!appended)
          {
            uint64_t appended = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)&context);
            if (!appended)
            {
              uint64_t appended = FigAtomWriterBeginAtom((uint64_t)&context, 0x6E707473u, 0);
              if (!appended)
              {
                LODWORD(v26) = bswap32(HIDWORD(v26));
                uint64_t appended = FigAtomWriterAppendData((uint64_t)&context, (uint64_t)&v26, 4);
                if (!appended)
                {
                  uint64_t appended = FigAtomWriterEndAtom((uint64_t)&context);
                  if (!appended)
                  {
                    uint64_t v11 = blockBufferOut;
                    goto LABEL_13;
                  }
                }
              }
            }
          }
        }
        else
        {
          uint64_t appended = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
        }
        uint64_t v20 = appended;
        if (blockBufferOut) {
          CFRelease(blockBufferOut);
        }
        uint64_t v11 = 0;
        CFDataRef Value = 0;
        if (v20) {
          goto LABEL_54;
        }
LABEL_13:
        size_t DataLength = CMBlockBufferGetDataLength(v11);
        if (DataLength > 0x7FFFFFEF)
        {
          uint64_t v20 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
        }
        else
        {
          size_t v13 = DataLength;
          CMBlockBufferRef blockBufferOut = 0;
          CFDataRef Value = (OpaqueCMBlockBuffer *)CFDictionaryGetValue(v9, @"SampleDescriptionExtensionAtoms");
          if (!Value)
          {
LABEL_18:
            size_t v16 = CMBlockBufferGetDataLength(Value);
            int v17 = v16 + v13;
            if (v16 + v13 > 0x7FFFFFEF)
            {
              uint64_t DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_53:
              uint64_t v20 = DataPointer;
LABEL_54:
              if (destinationBuffer) {
                CFRelease(destinationBuffer);
              }
              goto LABEL_32;
            }
            CFDictionaryRef v9 = (const __CFDictionary *)v16;
LABEL_21:
            size_t v18 = (v17 + 16);
            unint64_t sourceBytes = _byteswap_uint64(__PAIR64__(v18, CMFormatDescriptionGetMediaSubType((CMFormatDescriptionRef)cf)));
            unint64_t v25 = 0xFFFF000000000000;
            uint64_t DataPointer = CMBlockBufferCreateWithMemoryBlock(a1, 0, v18, a1, 0, 0, v18, 1u, &destinationBuffer);
            if (!DataPointer)
            {
              uint64_t DataPointer = CMBlockBufferReplaceDataBytes(&sourceBytes, destinationBuffer, 0, 0x10uLL);
              if (!DataPointer)
              {
                if (!v11
                  || !v13
                  || (*(void *)&long long context = 0,
                      uint64_t DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, 0x10uLL, 0, 0, (char **)&context),
                      !DataPointer)
                  && (uint64_t DataPointer = CMBlockBufferCopyDataBytes(v11, 0, v13, (void *)context), !DataPointer))
                {
                  if (!Value
                    || !v9
                    || (*(void *)&long long context = 0,
                        uint64_t DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, v13 + 16, 0, 0, (char **)&context), !DataPointer)&& (uint64_t DataPointer = CMBlockBufferCopyDataBytes(Value, 0, (size_t)v9, (void *)context), !DataPointer))
                  {
                    uint64_t v20 = 0;
                    *a4 = destinationBuffer;
                    destinationuint64_t Buffer = 0;
LABEL_32:
                    if (v11) {
                      CFRelease(v11);
                    }
                    if (Value) {
                      CFRelease(Value);
                    }
                    return v20;
                  }
                }
              }
            }
            goto LABEL_53;
          }
          uint64_t v30 = 0;
          long long v28 = 0u;
          long long v29 = 0u;
          long long context = 0u;
          uint64_t v15 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
          if (!v15)
          {
            uint64_t v15 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)&context);
            if (!v15)
            {
              CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)PointCloudBridgeAppendExtensionsFunc, &context);
              CFDataRef Value = blockBufferOut;
              goto LABEL_18;
            }
          }
          uint64_t v20 = v15;
          if (blockBufferOut) {
            CFRelease(blockBufferOut);
          }
        }
LABEL_43:
        CFDataRef Value = 0;
        goto LABEL_54;
      }
      uint64_t v22 = 4294954581;
    }
    else
    {
      uint64_t v22 = 4294954584;
    }
    uint64_t v20 = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
    uint64_t v11 = 0;
    goto LABEL_43;
  }

  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t PointCloudBridgeAppendExtensionsFunc(const __CFString *a1, const __CFData *a2, uint64_t a3)
{
  unsigned int v11 = 0;
  if (a1
    && (CFTypeID v6 = CFGetTypeID(a1), v6 == CFStringGetTypeID())
    && a2
    && (CFTypeID v7 = CFGetTypeID(a2), v7 == CFDataGetTypeID())
    && FigCFStringGetOSTypeValue(a1, (int *)&v11))
  {
    if (!FigAtomWriterBeginAtom(a3, v11, 0))
    {
      BytePtr = CFDataGetBytePtr(a2);
      CFIndex Length = CFDataGetLength(a2);
      FigAtomWriterAppendData(a3, (uint64_t)BytePtr, Length);
    }
  }
  else
  {
    FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
  }
  return FigAtomWriterEndAtom(a3);
}

uint64_t FigGetTimeOfDayClock()
{
  if (FigGetTimeOfDayClock_onceToken != -1) {
    dispatch_once_f(&FigGetTimeOfDayClock_onceToken, &FigGetTimeOfDayClock_gClock, (dispatch_function_t)figTimeOfDayClock_creationOnceFunction);
  }
  return FigGetTimeOfDayClock_gClock;
}

uint64_t figTimeOfDayClock_creationOnceFunction(uint64_t *a1)
{
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  CMTimeMake(&v4, 1, 10);
  return FigDerivedClockCreateWithGetTimeCallback(0, gFigTimeOfDayClockCallbacks, HostTimeClock, (long long *)&v4.value, 0, a1);
}

CFStringRef figTimeOfDayClock_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"<FigTimeOfDayClock %p>", a1);
}

void figTimeOfDayClock_Finalize()
{
  MEMORY[0x123] = 3;
}

BOOL figTimeOfDayClock_MightDrift(uint64_t a1, uint64_t a2)
{
  return a1 != a2;
}

double figTimeOfDayClock_GetRate()
{
  return 1.0;
}

uint64_t figTimeOfDayClock_GetAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  v10.tv_sec = 0;
  *(void *)&v10.tv_usec = 0;
  gettimeofday(&v10, 0);
  uint64_t UpTime = FigGetUpTime();
  CMTimeMake(&v9, (uint64_t)(((double)v10.tv_usec / 1000000.0 + (double)v10.tv_sec) * 100000.0), 100000);
  int64_t v6 = FigHostTimeToNanoseconds(UpTime);
  CMTimeMake(&v8, v6, 1000000000);
  *a2 = v9;
  *a3 = v8;
  return 0;
}

uint64_t FigFileGetFileInfo(const __CFURL *a1, uint64_t a2)
{
  timeval v10 = 0;
  uint64_t v3 = FigFileForkOpenMainByCFURL(a1, 0, (int **)&v10);
  if (v3) {
    return v3;
  }
  uint64_t DarwinFileDesc = FigFileGetDarwinFileDesc(v10);
  if (DarwinFileDesc != -1)
  {
    memset(&v11, 0, sizeof(v11));
    if (!fstat(DarwinFileDesc, &v11))
    {
      uint64_t v5 = 0;
      st_size_t size = v11.st_size;
      *(_DWORD *)(a2 + 32) = v11.st_mtimespec.tv_nsec;
      uint64_t st_dev = v11.st_dev;
      *(void *)a2 = st_size;
      *(void *)(a2 + 8) = st_dev;
      __darwin_time_t tv_sec = v11.st_mtimespec.tv_sec;
      *(void *)(a2 + 16) = v11.st_ino;
      *(void *)(a2 + 24) = tv_sec;
      goto LABEL_7;
    }
    uint64_t DarwinFileDesc = *__error();
  }
  uint64_t v5 = FigSignalErrorAt(DarwinFileDesc, 0, 0, 0, 0, 0, 0);
LABEL_7:
  FigFileForkClose((int *)v10);
  return v5;
}

BOOL FigFileInfoEqual(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 16) == *(void *)(a2 + 16)
      && *(void *)(a1 + 8) == *(void *)(a2 + 8)
      && *(void *)a1 == *(void *)a2
      && *(void *)(a1 + 24) == *(void *)(a2 + 24)
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
}

uint64_t FigFileDeleteFile(const __CFURL *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t result = FigFileDoesFileExist(a1);
  if (result)
  {
    CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1023);
    return unlink((const char *)buffer);
  }
  return result;
}

uint64_t FigFileDeleteDirectory(const __CFURL *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t result = FigFileDoesFileExist(a1);
  if (result)
  {
    CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1023);
    return removefile((const char *)buffer, 0, 1u);
  }
  return result;
}

uint64_t FigFileReadURLAndCreateCFData(const __CFURL *a1, CFDataRef *a2)
{
  CFIndex size = 0;
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  uint64_t LengthAtOffset = FigFileForkOpenMainByCFURL(a1, 0, &v14);
  if (LengthAtOffset) {
    goto LABEL_16;
  }
  uint64_t LengthAtOffset = FigFileForkGetLengthAtOffset(v14, 0, &size);
  if (LengthAtOffset) {
    goto LABEL_16;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (size >= 1)
  {
    int64_t v6 = CFAllocatorAllocate(v5, size, 0);
    if (v6)
    {
      CFTypeID v7 = v6;
      uint64_t v8 = FigFileForkRead(v14, v6, size, 0, &v12);
      if (v8)
      {
        uint64_t v10 = v8;
LABEL_14:
        CFAllocatorDeallocate(v4, v7);
        goto LABEL_8;
      }
      CFDataRef v9 = CFDataCreateWithBytesNoCopy(v4, (const UInt8 *)v7, size, v4);
      if (v9)
      {
LABEL_7:
        uint64_t v10 = 0;
        *a2 = v9;
        goto LABEL_8;
      }
      goto LABEL_12;
    }
    uint64_t LengthAtOffset = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
LABEL_16:
    uint64_t v10 = LengthAtOffset;
    goto LABEL_8;
  }
  CFDataRef v9 = CFDataCreate(v5, 0, 0);
  CFTypeID v7 = 0;
  if (v9) {
    goto LABEL_7;
  }
LABEL_12:
  uint64_t v10 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  if (v10 && v7) {
    goto LABEL_14;
  }
LABEL_8:
  if (v14) {
    FigFileForkClose(v14);
  }
  return v10;
}

uint64_t FigFileValidateFileNameIsWithinParentDirectory(CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  if (url)
  {
    if (pathComponent)
    {
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFURLRef v5 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], url, pathComponent, isDirectory);
      if (v5)
      {
        CFURLRef v6 = v5;
        CFURLRef v7 = CFURLCopyAbsoluteURL(v5);
        if (!v7)
        {
          uint64_t v16 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
          CFRelease(v6);
          return v16;
        }
        CFURLRef v8 = v7;
        CFURLRef v9 = CFURLCopyAbsoluteURL(url);
        if (!v9)
        {
          uint64_t v17 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
          CFRelease(v8);
          CFRelease(v6);
          return v17;
        }
        CFURLRef v10 = v9;
        CFURLRef v11 = CFURLCreateCopyDeletingLastPathComponent(v4, v8);
        CFURLRef v12 = v11;
        if (v11)
        {
          if (CFEqual(v11, v10) == 1)
          {
            uint64_t v13 = 0;
LABEL_9:
            CFRelease(v8);
            CFRelease(v10);
            CFRelease(v6);
            if (v12) {
              CFRelease(v12);
            }
            return v13;
          }
          uint64_t v18 = 4294955087;
        }
        else
        {
          uint64_t v18 = 4294955095;
        }
        uint64_t v13 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
        goto LABEL_9;
      }
      uint64_t v15 = 4294955095;
    }
    else
    {
      uint64_t v15 = 4294954516;
    }
  }
  else
  {
    uint64_t v15 = 4294954516;
  }

  return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFileConvertURLToAbsoluteAndMarkAsDirectory(const void *a1, void *a2)
{
  if (!a1 || !a2)
  {
    uint64_t v11 = 4294955096;
LABEL_12:
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  if (CFURLHasDirectoryPath((CFURLRef)a1))
  {
    uint64_t v4 = 0;
    *a2 = CFRetain(a1);
    return v4;
  }
  CFURLRef v5 = CFURLCopyAbsoluteURL((CFURLRef)a1);
  if (!v5)
  {
    uint64_t v11 = 4294955095;
    goto LABEL_12;
  }
  CFURLRef v6 = v5;
  CFStringRef v7 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  if (v7)
  {
    CFStringRef v8 = v7;
    CFURLRef v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, kCFURLPOSIXPathStyle, 1u);
    if (v9)
    {
      uint64_t v4 = 0;
      *a2 = v9;
    }
    else
    {
      uint64_t v4 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v6);
    CFRelease(v8);
    return v4;
  }
  uint64_t v12 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  CFRelease(v6);
  return v12;
}

uint64_t FigThreadLockAbortList()
{
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  uint64_t v0 = (pthread_mutex_t *)gAbortActionLock;

  return FigReentrantMutexLock(v0);
}

uint64_t FigThreadUnlockAbortList()
{
  return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
}

void FigThreadRemoveFromAbortListAndCleanup(uint64_t a1)
{
  uint64_t v1 = gAbortActionList;
  if (gAbortActionList)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v3 = v1;
        uint64_t v1 = *(void *)(v1 + 32);
        if (*(uint64_t (**)())(v3 + 16) == kSpecialAction_ThreadWasAbortedForTeardown
          && (*(void *)v3 == a1 || !*(void *)(v3 + 8) && !FigThreadIsValid(*(_opaque_pthread_t **)v3)))
        {
          break;
        }
        if (!v1) {
          return;
        }
      }
      uint64_t v4 = gAbortActionList;
      if (gAbortActionList != v3) {
        break;
      }
      gAbortActionList = *(void *)(v3 + 32);
      if (!gAbortActionList)
      {
        CFStringRef v7 = &gAbortActionList;
LABEL_14:
        qword_1EB28B780 = (uint64_t)v7;
      }
LABEL_15:
      free((void *)v3);
      if (!v1) {
        return;
      }
    }
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = *(void *)(v4 + 32);
    }
    while (v4 != v3);
    uint64_t v6 = *(void *)(v3 + 32);
    *(void *)(v5 + 32) = v6;
    CFStringRef v7 = (uint64_t *)(v5 + 32);
    if (v6) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
}

void FigThreadMakeDispatchQueueAbortable(NSObject *a1)
{
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  if (a1 == MEMORY[0x1E4F14428] || dispatch_get_global_queue(0, 0) == a1)
  {
    FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  }
  else if (a1)
  {
    unsigned int v2 = (void *)FigAtomicIncrement64(&gNextAbortableQueueID);
    dispatch_queue_set_specific(a1, &kFigThreadDispatchQueueAbortabilityKey, v2, (dispatch_function_t)removeDispatchQueueFromAbortListAndCleanup);
  }
}

uint64_t removeDispatchQueueFromAbortListAndCleanup(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  uint64_t result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (result) {
    return result;
  }
  uint64_t v2 = gAbortActionList;
  if (gAbortActionList)
  {
    while (1)
    {
      uint64_t v3 = v2;
      uint64_t v2 = *(void *)(v2 + 32);
      if (*(uint64_t (**)())(v3 + 16) != kSpecialAction_ThreadWasAbortedForTeardown
        || *(void *)(v3 + 8) != v1)
      {
        goto LABEL_15;
      }
      uint64_t v4 = gAbortActionList;
      if (gAbortActionList != v3) {
        break;
      }
      gAbortActionList = v2;
      if (!v2)
      {
        uint64_t v6 = &gAbortActionList;
LABEL_13:
        qword_1EB28B780 = (uint64_t)v6;
      }
LABEL_14:
      free((void *)v3);
LABEL_15:
      if (!v2) {
        goto LABEL_16;
      }
    }
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = *(void *)(v4 + 32);
    }
    while (v4 != v3);
    *(void *)(v5 + 32) = v2;
    uint64_t v6 = (uint64_t *)(v5 + 32);
    if (v2) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_16:
  CFStringRef v7 = (pthread_mutex_t *)gAbortActionLock;

  return FigReentrantMutexUnlock(v7);
}

void *FigThreadGetAbortableDispatchQueueID(NSObject *a1)
{
  if (a1) {
    return dispatch_queue_get_specific(a1, &kFigThreadDispatchQueueAbortabilityKey);
  }
  else {
    return dispatch_get_specific(&kFigThreadDispatchQueueAbortabilityKey);
  }
}

uint64_t FigThreadAbortForTeardown(uint64_t a1)
{
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  uint64_t result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (result) {
    return result;
  }
  if ((gAbortingNow & 1) == 0)
  {
    gAbortingNow = 1;
    uint64_t v3 = (void *)gAbortActionList;
    if (gAbortActionList)
    {
      int v4 = 1;
      do
      {
        if (*v3 == a1)
        {
          uint64_t v5 = (uint64_t (*)())v3[2];
          if (v5 == kSpecialAction_ThreadWasAbortedForTeardown) {
            int v4 = 0;
          }
          if (v5) {
            ((void (*)(void))v5)(v3[3]);
          }
        }
        uint64_t v3 = (void *)v3[4];
      }
      while (v3);
      if (!v4) {
        goto LABEL_14;
      }
    }
    uint64_t v6 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040D3751E5BuLL);
    if (v6)
    {
      *uint64_t v6 = a1;
      v6[1] = 0;
      int v6[2] = kSpecialAction_ThreadWasAbortedForTeardown;
      v6[3] = 0;
      void v6[4] = 0;
      *(void *)qword_1EB28B780 = v6;
      qword_1EB28B780 = (uint64_t)(v6 + 4);
LABEL_14:
      uint64_t v7 = gAbortActionList;
      if (gAbortActionList)
      {
        while (1)
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(void *)(v7 + 32);
          CFURLRef v9 = *(uint64_t (**)())(v8 + 16);
          if (v9 == kSpecialAction_ThreadWasAbortedForTeardown)
          {
            if (*(void *)(v8 + 8)
              || FigThreadIsValid(*(_opaque_pthread_t **)v8) && *(void *)(v8 + 16))
            {
              goto LABEL_24;
            }
LABEL_17:
            uint64_t v10 = gAbortActionList;
            if (gAbortActionList != v8)
            {
              do
              {
                uint64_t v11 = v10;
                uint64_t v10 = *(void *)(v10 + 32);
              }
              while (v10 != v8);
              uint64_t v12 = *(void *)(v8 + 32);
              *(void *)(v11 + 32) = v12;
              uint64_t v13 = (uint64_t *)(v11 + 32);
              if (v12) {
                goto LABEL_29;
              }
              goto LABEL_28;
            }
            gAbortActionList = *(void *)(v8 + 32);
            if (!gAbortActionList)
            {
              uint64_t v13 = &gAbortActionList;
LABEL_28:
              qword_1EB28B780 = (uint64_t)v13;
            }
LABEL_29:
            free((void *)v8);
            if (!v7) {
              break;
            }
          }
          else
          {
            if (!v9) {
              goto LABEL_17;
            }
LABEL_24:
            if (!v7) {
              break;
            }
          }
        }
      }
      gAbortingNow = 0;
      goto LABEL_31;
    }
    FigSignalErrorAt(4294954497, 0, 0, 0, 0, 0, 0);
  }
LABEL_31:
  uint64_t v14 = (pthread_mutex_t *)gAbortActionLock;

  return FigReentrantMutexUnlock(v14);
}

uint64_t FigThreadAbortQueue(NSObject *a1)
{
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  uint64_t result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (!result)
  {
    if ((gAbortingNow & 1) == 0)
    {
      AbortableDispatchQueueID = FigThreadGetAbortableDispatchQueueID(a1);
      if (AbortableDispatchQueueID)
      {
        gAbortingNow = 1;
        int v4 = (void *)gAbortActionList;
        if (gAbortActionList)
        {
          uint64_t v5 = AbortableDispatchQueueID;
          do
          {
            if ((void *)v4[1] == v5)
            {
              uint64_t v6 = (void (*)(void))v4[2];
              if (v6) {
                v6(v4[3]);
              }
            }
            int v4 = (void *)v4[4];
          }
          while (v4);
          uint64_t v7 = (void *)gAbortActionList;
          if (gAbortActionList)
          {
            while (1)
            {
              uint64_t v8 = (void *)v7[4];
              if (!v7[2]) {
                break;
              }
LABEL_20:
              uint64_t v7 = v8;
              if (!v8) {
                goto LABEL_21;
              }
            }
            uint64_t v9 = gAbortActionList;
            if ((void *)gAbortActionList == v7)
            {
              gAbortActionList = v7[4];
              if (v8)
              {
LABEL_19:
                free(v7);
                goto LABEL_20;
              }
              uint64_t v11 = &gAbortActionList;
            }
            else
            {
              do
              {
                uint64_t v10 = v9;
                uint64_t v9 = *(void *)(v9 + 32);
              }
              while ((void *)v9 != v7);
              *(void *)(v10 + 32) = v8;
              uint64_t v11 = (uint64_t *)(v10 + 32);
              if (v8) {
                goto LABEL_19;
              }
            }
            qword_1EB28B780 = (uint64_t)v11;
            goto LABEL_19;
          }
        }
LABEL_21:
        gAbortingNow = 0;
      }
      else
      {
        FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
      }
    }
    uint64_t v12 = (pthread_mutex_t *)gAbortActionLock;
    return FigReentrantMutexUnlock(v12);
  }
  return result;
}

uint64_t FigThreadAbortQueueForTeardown(NSObject *a1)
{
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  uint64_t result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (result) {
    return result;
  }
  if ((gAbortingNow & 1) == 0)
  {
    AbortableDispatchQueueID = FigThreadGetAbortableDispatchQueueID(a1);
    if (AbortableDispatchQueueID)
    {
      int v4 = AbortableDispatchQueueID;
      gAbortingNow = 1;
      uint64_t v5 = (void *)gAbortActionList;
      if (gAbortActionList)
      {
        int v6 = 1;
        do
        {
          if ((void *)v5[1] == v4)
          {
            uint64_t v7 = (uint64_t (*)())v5[2];
            if (v7 == kSpecialAction_ThreadWasAbortedForTeardown) {
              int v6 = 0;
            }
            if (v7) {
              ((void (*)(void))v7)(v5[3]);
            }
          }
          uint64_t v5 = (void *)v5[4];
        }
        while (v5);
        if (!v6) {
          goto LABEL_15;
        }
      }
      uint64_t v8 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040D3751E5BuLL);
      if (v8)
      {
        *uint64_t v8 = 0;
        v8[1] = v4;
        CFArrayRef v8[2] = kSpecialAction_ThreadWasAbortedForTeardown;
        _OWORD v8[3] = 0;
        void v8[4] = 0;
        *(void *)qword_1EB28B780 = v8;
        qword_1EB28B780 = (uint64_t)(v8 + 4);
LABEL_15:
        uint64_t v9 = (void *)gAbortActionList;
        if (gAbortActionList)
        {
          while (1)
          {
            uint64_t v10 = (void *)v9[4];
            if (!v9[2]) {
              break;
            }
LABEL_25:
            uint64_t v9 = v10;
            if (!v10) {
              goto LABEL_26;
            }
          }
          uint64_t v11 = gAbortActionList;
          if ((void *)gAbortActionList == v9)
          {
            gAbortActionList = v9[4];
            if (v10)
            {
LABEL_24:
              free(v9);
              goto LABEL_25;
            }
            uint64_t v13 = &gAbortActionList;
          }
          else
          {
            do
            {
              uint64_t v12 = v11;
              uint64_t v11 = *(void *)(v11 + 32);
            }
            while ((void *)v11 != v9);
            *(void *)(v12 + 32) = v10;
            uint64_t v13 = (uint64_t *)(v12 + 32);
            if (v10) {
              goto LABEL_24;
            }
          }
          qword_1EB28B780 = (uint64_t)v13;
          goto LABEL_24;
        }
LABEL_26:
        gAbortingNow = 0;
        goto LABEL_27;
      }
      uint64_t v15 = 4294954497;
    }
    else
    {
      uint64_t v15 = 4294954503;
    }
    FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
LABEL_27:
  uint64_t v14 = (pthread_mutex_t *)gAbortActionLock;

  return FigReentrantMutexUnlock(v14);
}

uint64_t FigThreadGetGlobalNetworkBufferingLowPriorityRunloop()
{
  return sNetworkLowPriorityRunLoop;
}

void *networkThreadLowPriorityInitOnce()
{
  return networkThreadCommonInit(@"com.apple.coremedia.networkbufferinglowpriority", (uint64_t)FigThreadGlobalNetworkBufferingLowPriorityRunloop, 0x19u, &sNetworkLowPriorityThread);
}

uint64_t FigThreadGetGlobalNetworkBufferingBackgroundThrottledRunloop()
{
  return sNetworkBackgroundThrottledRunLoop;
}

void *networkThreadBackgroundThrottledInitOnce()
{
  return networkThreadCommonInit(@"com.apple.coremedia.networkbufferingbackgroundthrottled", (uint64_t)FigThreadGlobalNetworkBufferingBackgroundThrottledRunloop, 0x10u, &sNetworkBackgroundThrottledThread);
}

uint64_t FigThreadGetGlobalNetworkBufferingQueue()
{
  return sNetworkQueue;
}

dispatch_queue_t networkQueueInitOnce()
{
  dispatch_queue_t result = FigDispatchQueueCreateTargetingWorkloopWithPriority("com.apple.coremedia.networkbuffering", 0, 7u);
  sNetworkQueue = (uint64_t)result;
  return result;
}

uint64_t FigThreadGetGlobalNetworkBufferingLowPriorityQueue()
{
  return sNetworkLowPriorityQueue;
}

dispatch_queue_t networkLowPriorityQueueInitOnce()
{
  dispatch_queue_t result = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkbufferinglowpriority", 0, 0x19u);
  sNetworkLowPriorityQueue = (uint64_t)result;
  return result;
}

void *networkThreadCommonInit(const void *a1, uint64_t a2, unsigned int a3, pthread_t *a4)
{
  dispatch_queue_t result = FigSemaphoreCreate(0, 1);
  if (result)
  {
    uint64_t v9 = (uint64_t)result;
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(Mutable, @"com.apple.fig.ThreadCreateKey_Identifier", a1);
    CFDictionarySetValue(Mutable, @"com.apple.fig.ThreadCreateKey_AdoptVoucher", (const void *)*MEMORY[0x1E4F1CFC8]);
    int v11 = FigThreadCreate(a2, v9, a3, 0, Mutable, a4);
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (!v11) {
      FigSemaphoreWaitRelative(v9, -1);
    }
    return (void *)FigSemaphoreDestroy(v9);
  }
  return result;
}

void FigThreadGlobalNetworkBufferingCommonSetupRunloop(uint64_t a1, CFRunLoopRef *a2, __CFRunLoopTimer **a3)
{
  *a2 = CFRunLoopGetCurrent();
  FigSemaphoreSignal(a1);
  int v6 = CFRunLoopTimerCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3.1536e13, 3.1536e13, 0, 0, (CFRunLoopTimerCallBack)dummyRunLoopTimer, 0);
  if (v6)
  {
    uint64_t v7 = v6;
    CFRunLoopAddTimer(*a2, v6, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
    if (a3)
    {
      *a3 = v7;
    }
    else
    {
      CFRelease(v7);
    }
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigThreadGlobalNetworkBufferingLowPriorityRunloop(uint64_t a1)
{
  if (sNetworkLowPriorityRunLoopTimer)
  {
    CFRelease((CFTypeRef)sNetworkLowPriorityRunLoopTimer);
    sNetworkLowPriorityRunLoopTimer = 0;
  }
  return 0;
}

uint64_t FigThreadGlobalNetworkBufferingBackgroundThrottledRunloop(uint64_t a1)
{
  if (sNetworkBackgroundThrottledRunLoopTimer)
  {
    CFRelease((CFTypeRef)sNetworkBackgroundThrottledRunLoopTimer);
    sNetworkBackgroundThrottledRunLoopTimer = 0;
  }
  return 0;
}

uint64_t FigUInt32NearestPowerOfTwo(unsigned int a1)
{
  unsigned int v1 = a1 | (a1 >> 1) | ((a1 | (a1 >> 1)) >> 2);
  unsigned int v2 = v1 | (v1 >> 4) | ((v1 | (v1 >> 4)) >> 8);
  return ((v2 | HIWORD(v2)) + 1) >> ((a1 & (((v2 | HIWORD(v2)) + 1) >> 2)) == 0);
}

uint64_t FigFloat32ConvertToFloat16(float a1)
{
  int v1 = HIWORD(LODWORD(a1)) & 0x8000;
  unsigned int v2 = (LODWORD(a1) >> 23);
  unsigned int v3 = ((((LODWORD(a1) & 0x7FFFFFu) >> 13) | (v2 << 10)) + 0x4000) | v1;
  if (v2 < 0x71) {
    LOWORD(v3) = HIWORD(a1) & 0x8000;
  }
  unsigned __int16 v4 = v1 | 0x7C00;
  if (v2 >= 0x8F) {
    LOWORD(v3) = v4;
  }
  __int16 v5 = LOWORD(a1) & 0x3FF;
  if ((LOWORD(a1) & 0x3FF) == 0) {
    __int16 v5 = 512;
  }
  unsigned __int16 v6 = v4 | v5;
  if ((LODWORD(a1) & 0x7FFFFF) == 0) {
    unsigned __int16 v6 = v4;
  }
  if (v2 != 255) {
    return (unsigned __int16)v3;
  }
  return v6;
}

float FigFloat16ConvertToFloat32(unsigned int a1)
{
  unsigned int v1 = (a1 >> 10) & 0x1F;
  int v2 = a1 & 0x3FF;
  if (v1 == 31)
  {
    LODWORD(result) = v2 | 0x7F800000;
  }
  else if (v1)
  {
    if (v1 > 0xE) {
      float v4 = (float)(1 << (v1 - 15));
    }
    else {
      float v4 = 1.0 / (double)(1 << (15 - v1));
    }
    float result = (float)((float)((float)v2 * 0.00097656) + 1.0) * v4;
  }
  else if ((a1 & 0x3FF) != 0)
  {
    float result = (float)v2 * 0.000000059605;
  }
  else
  {
    float result = 0.0;
  }
  if ((a1 & 0x8000u) != 0) {
    return -result;
  }
  return result;
}

uint64_t FigGzipCreate(void *a1)
{
  if (a1)
  {
    int v2 = malloc_type_calloc(1uLL, 0x78uLL, 0x10B00409B971CB9uLL);
    if (v2)
    {
      v2[29] = 1736075632;
      *((void *)v2 + 9) = 0;
      *((void *)v2 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
      *((void *)v2 + 8) = 0;
      *a1 = v2;
      return 0;
    }
    uint64_t v4 = 4294954905;
  }
  else
  {
    uint64_t v4 = 4294954906;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigGzipCreate_zlib(void *a1)
{
  if (a1)
  {
    int v2 = malloc_type_calloc(1uLL, 0x78uLL, 0x10B00409B971CB9uLL);
    if (v2)
    {
      v2[29] = 2053925218;
      *((void *)v2 + 9) = 0;
      *((void *)v2 + 1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
      *((void *)v2 + 8) = 0;
      *a1 = v2;
      return 0;
    }
    uint64_t v4 = 4294954905;
  }
  else
  {
    uint64_t v4 = 4294954906;
  }

  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigGzipDecompressMemory(z_streamp strm, Bytef *a2, uInt a3, void *a4, BOOL *a5, Bytef *a6, uInt a7, void *a8, BOOL *a9, unsigned char *a10)
{
  if (!a4 || !a8 || !a5 || !a9 || !a10)
  {
    uint64_t v21 = 4294954906;
    goto LABEL_30;
  }
  if (((uint64_t)strm[1].next_in & 0xFFFFFFFD) != 0)
  {
    uint64_t v21 = 4294954902;
    goto LABEL_30;
  }
  *a10 = 0;
  if (a2)
  {
    strm->next_iuint64_t n = a2;
    strm->avail_iuint64_t n = a3;
    strm->total_iuint64_t n = 0;
  }
  if (a6)
  {
    uLong total_out = 0;
    strm->next_out = a6;
    strm->avail_out = a7;
    strm->uLong total_out = 0;
  }
  else
  {
    uLong total_out = strm->total_out;
  }
  total_iuint64_t n = strm->total_in;
  if (LODWORD(strm[1].next_in)) {
    goto LABEL_19;
  }
  int next_in_high = HIDWORD(strm[1].next_in);
  if (next_in_high == 2053925218)
  {
    unsigned int v17 = inflateInit_(strm, "1.2.12", 112);
    goto LABEL_17;
  }
  if (next_in_high == 1736075632)
  {
    unsigned int v17 = inflateInit2_(strm, 47, "1.2.12", 112);
LABEL_17:
    if (v17 < 2) {
      goto LABEL_18;
    }
    if (v17 == -4) {
      uint64_t v21 = 4294954905;
    }
    else {
      uint64_t v21 = 4294954904;
    }
LABEL_30:
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
LABEL_18:
  LODWORD(strm[1].next_in) = 2;
LABEL_19:
  int v18 = inflate(strm, 0);
  switch(v18)
  {
    case -4:
      return 4294954905;
    case 0:
      *a10 = 0;
      *a5 = strm->avail_in == 0;
      BOOL v19 = strm->avail_out == 0;
      goto LABEL_25;
    case 1:
      BOOL v19 = 0;
      *a10 = 1;
      *a5 = 0;
LABEL_25:
      uint64_t result = 0;
      *a9 = v19;
      *a4 = strm->total_in - total_in;
      *a8 = strm->total_out - total_out;
      return result;
  }
  return 4294954904;
}

uint64_t FigGzipCompressMemory(z_streamp strm, Bytef *a2, uInt a3, void *a4, BOOL *a5, Bytef *a6, uInt a7, void *a8, BOOL *a9, char a10)
{
  if (a4 && a8 && a5 && a9)
  {
    next_iuint64_t n = strm[1].next_in;
    if (next_in < 2)
    {
      if (a2)
      {
        strm->next_iuint64_t n = a2;
        strm->avail_iuint64_t n = a3;
        strm->total_iuint64_t n = 0;
      }
      if (a6)
      {
        uLong total_out = 0;
        strm->next_out = a6;
        strm->avail_out = a7;
        strm->uLong total_out = 0;
      }
      else
      {
        uLong total_out = strm->total_out;
      }
      total_iuint64_t n = strm->total_in;
      if (next_in)
      {
LABEL_18:
        unsigned int v18 = deflate(strm, 0);
        if (v18 < 2)
        {
          if (a10)
          {
            if (strm->avail_out) {
              unsigned int v18 = deflate(strm, 4);
            }
          }
          if (v18 != -4)
          {
            if (!v18)
            {
              *a5 = strm->avail_in == 0;
              BOOL v19 = strm->avail_out == 0;
              goto LABEL_30;
            }
            if (v18 == 1)
            {
              BOOL v19 = 0;
              *a5 = 0;
LABEL_30:
              uint64_t result = 0;
              *a9 = v19;
              *a4 = strm->total_in - total_in;
              *a8 = strm->total_out - total_out;
              return result;
            }
            return 4294954903;
          }
          return 4294954905;
        }
LABEL_26:
        if (v18 != -4) {
          return 4294954903;
        }
        return 4294954905;
      }
      int next_in_high = HIDWORD(strm[1].next_in);
      if (next_in_high == 2053925218)
      {
        unsigned int v18 = deflateInit_(strm, -1, "1.2.12", 112);
      }
      else
      {
        if (next_in_high != 1736075632)
        {
LABEL_17:
          LODWORD(strm[1].next_in) = 1;
          goto LABEL_18;
        }
        unsigned int v18 = deflateInit2_(strm, -1, 8, 31, 4, 0, "1.2.12", 112);
      }
      if (v18 >= 2) {
        goto LABEL_26;
      }
      goto LABEL_17;
    }
    uint64_t v21 = 4294954902;
  }
  else
  {
    uint64_t v21 = 4294954906;
  }

  return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
}

void FigGzipDispose(void *a1)
{
  if (a1)
  {
    FigGzipReset((uint64_t)a1);
    free(a1);
  }
}

uint64_t FigGzipReset(uint64_t strm)
{
  if (strm)
  {
    uint64_t v1 = strm;
    int v2 = *(_DWORD *)(strm + 112);
    if (v2 == 1)
    {
      struint64_t m = deflateEnd((z_streamp)strm);
    }
    else
    {
      if (v2 != 2) {
        return strm;
      }
      struint64_t m = inflateEnd((z_streamp)strm);
    }
    *(_DWORD *)(v1 + 112) = 0;
  }
  return strm;
}

CFStringRef FigFilePathCopyFormattingDesc(char *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"[%s]", a1 + 16);
}

CFStringRef FigFilePathCopyDebugDesc(char *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<FigFilePathRef %p [%p]>{path:%s}", a1, v3, a1 + 16);
}

uint64_t convertPOSIXErrorToFigFileError(uint64_t result, char a2)
{
  if ((int)result <= 12)
  {
    if (result == 1)
    {
LABEL_20:
      if ((a2 & 3) != 0) {
        return 4294955092;
      }
      else {
        return 4294955093;
      }
    }
    unsigned int v2 = -17913;
    if (result == 5) {
      unsigned int v3 = -17915;
    }
    else {
      unsigned int v3 = result;
    }
    BOOL v4 = result == 2;
    goto LABEL_17;
  }
  if ((int)result > 44)
  {
    unsigned int v2 = -17916;
    if (result == 63) {
      int v5 = -17912;
    }
    else {
      int v5 = result;
    }
    if (result == 62) {
      unsigned int v3 = -17914;
    }
    else {
      unsigned int v3 = v5;
    }
    BOOL v4 = result == 45;
LABEL_17:
    if (v4) {
      return v2;
    }
    else {
      return v3;
    }
  }
  switch((int)result)
  {
    case 13:
      goto LABEL_20;
    case 14:
    case 22:
      uint64_t result = 4294955096;
      break;
    case 20:
      uint64_t result = 4294949385;
      break;
    default:
      return result;
  }
  return result;
}

BOOL FigFileDoesFileExist(const __CFURL *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  memset(&v2, 0, sizeof(v2));
  if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024)) {
    return stat((const char *)buffer, &v2) == 0;
  }
  FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  return 0;
}

BOOL FigFileIsFileOnExternalStorageDevice(const __CFURL *a1)
{
  if (!a1) {
    return 0;
  }
  CFStringRef v1 = CFURLCopyFileSystemPath(a1, kCFURLPOSIXPathStyle);
  if (!v1) {
    return 0;
  }
  CFStringRef v2 = v1;
  if (FigFileIsFileOnExternalStorageDevice_fileOnExternalStorageDevice != -1) {
    dispatch_once(&FigFileIsFileOnExternalStorageDevice_fileOnExternalStorageDevice, &__block_literal_global_15);
  }
  BOOL v3 = 0;
  if (FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare
    && FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate)
  {
    if (CFStringHasPrefix(v2, (CFStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare)) {
      BOOL v3 = 1;
    }
    else {
      BOOL v3 = CFStringHasPrefix(v2, (CFStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate) != 0;
    }
  }
  CFRelease(v2);
  return v3;
}

void __FigFileIsFileOnExternalStorageDevice_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  memset(&v7, 0, sizeof(v7));
  unsigned __int16 v6 = 0;
  uid_t v0 = getuid();
  if (!getpwuid_r(v0, &v7, v8, 0x400uLL, &v6) && v6 && v7.pw_dir)
  {
    CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare = (uint64_t)CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (!FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare) {
      return;
    }
    CFStringRef v2 = CFStringCreateWithCString(v1, v7.pw_dir, 0x600u);
    if (!v2) {
      return;
    }
    CFStringRef v3 = v2;
    CFStringAppend((CFMutableStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare, v2);
    CFStringAppend((CFMutableStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare, @"/Library/LiveFiles/com.apple.filesystems.userfsd/");
    CFStringRef v4 = CFStringCreateWithFormat(v1, 0, @"/private%@", FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare);
    FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate = (uint64_t)v4;
    if (!v4)
    {
LABEL_18:
      CFRelease(v3);
      return;
    }
  }
  else
  {
    CFStringRef v3 = 0;
    CFStringRef v4 = (CFStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate;
  }
  if (!FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare || !v4)
  {
    if (FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare)
    {
      CFRelease((CFTypeRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare);
      FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare = 0;
      CFStringRef v4 = (CFStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate;
    }
    if (v4)
    {
      CFRelease(v4);
      FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate = 0;
    }
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare = (uint64_t)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], "/var/mobile/Library/LiveFiles/com.apple.filesystems.userfsd/", 0x8000100u);
    if (FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare) {
      FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate = (uint64_t)CFStringCreateWithCString(v5, "/private/var/mobile/Library/LiveFiles/com.apple.filesystems.userfsd/", 0x8000100u);
    }
  }
  if (v3) {
    goto LABEL_18;
  }
}

uint64_t FigFileForkOpenMainByCFURL(const __CFURL *a1, unsigned int a2, int **a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v6 = a2 & 3;
  bzero(buffer, 0x400uLL);
  unsigned int v7 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigFileTrace[1], @"figfile_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v7, 0, gFigFileTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EB28B610, @"figfile_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EB28B608);
  if (!a1)
  {
    uint64_t v22 = FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
    uint64_t v9 = 0;
    goto LABEL_29;
  }
  uint64_t v8 = (int *)malloc_type_malloc(4uLL, 0x100004052888210uLL);
  uint64_t v9 = v8;
  if (!v8)
  {
    uint64_t v21 = 4294955095;
LABEL_28:
    uint64_t v22 = FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
LABEL_29:
    uint64_t v15 = convertPOSIXErrorToFigFileError(v22, v6);
    goto LABEL_26;
  }
  *uint64_t v8 = -1;
  if ((a2 & 0x20) != 0) {
    int v10 = 16778240;
  }
  else {
    int v10 = 0x1000000;
  }
  int v11 = (32 * a2) & 0x200;
  if ((a2 & 0x200) != 0) {
    int v11 = 2560;
  }
  v6 |= (a2 >> 2) & 0x20 | ((unsigned __int16)(a2 & 0x400) >> 8) | v10 | v11;
  if (!FigIsPersistentURL(a1))
  {
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      CFURLRef v13 = 0;
      goto LABEL_14;
    }
    uint64_t v21 = 4294955096;
    goto LABEL_28;
  }
  CFURLRef SecurityScopedFileURLForPersistentURL = (const __CFURL *)FigCreateSecurityScopedFileURLForPersistentURL(a1);
  if (!SecurityScopedFileURLForPersistentURL)
  {
    uint64_t v21 = 4294955087;
    goto LABEL_28;
  }
  CFURLRef v13 = SecurityScopedFileURLForPersistentURL;
  CFURLStartAccessingSecurityScopedResource(SecurityScopedFileURLForPersistentURL);
  if (!CFURLGetFileSystemRepresentation(v13, 1u, buffer, 1024))
  {
    uint64_t v14 = FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
    uint64_t v15 = convertPOSIXErrorToFigFileError(v14, v6);
LABEL_25:
    MEMORY[0x192FC4880](v13);
    CFRelease(v13);
    goto LABEL_26;
  }
LABEL_14:
  int v16 = open((const char *)buffer, v6, 420);
  *uint64_t v9 = v16;
  if (v16 == -1)
  {
    BOOL v19 = __error();
    uint64_t v18 = FigSignalErrorAt(*v19, 0, 0, 0, 0, 0, 0);
    if (!FigIsItOKToLogURLs()) {
      __strlcpy_chk();
    }
  }
  else if ((a2 & 0x400) != 0 && (int v17 = fcntl(v16, 3), fcntl(*v9, 4, v17 & 0xFFFFFFFB) == -1) {
         || (a2 & 0x40) != 0 && fcntl(*v9, 48, 1) == -1
  }
         || (a2 & 0x100) != 0 && fcntl(*v9, 68, 1) == -1)
  {
    CFTypeID v23 = __error();
    uint64_t v18 = FigSignalErrorAt(*v23, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t v18 = 0;
    *a3 = v9;
    uint64_t v9 = 0;
  }
  uint64_t v15 = convertPOSIXErrorToFigFileError(v18, v6);
  if (v13) {
    goto LABEL_25;
  }
LABEL_26:
  FigFileForkClose(v9);
  return v15;
}

uint64_t FigFileForkRead(int *a1, void *__buf, size_t __nbyte, off_t a4, uint64_t *a5)
{
  if (gGMFigKTraceEnabled == 1) {
    kdebug_trace();
  }
  ssize_t v10 = pread(*a1, __buf, __nbyte, a4);
  ssize_t v11 = v10;
  uint64_t v12 = v10 & ~(v10 >> 63);
  if (gGMFigKTraceEnabled == 1)
  {
    if (v10 < 0) {
      __error();
    }
    kdebug_trace();
    if (__nbyte != v11 && gGMFigKTraceEnabled == 1) {
      kdebug_trace();
    }
  }
  if (v11 == -1)
  {
    uint64_t v15 = __error();
    uint64_t v14 = FigSignalErrorAt(*v15, 0, 0, 0, 0, 0, 0);
    if (gGMFigKTraceEnabled == 1)
    {
      __error();
      kdebug_trace();
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (a5) {
    *a5 = v12;
  }
  return v14;
}

uint64_t FigFileForkWrite(int *a1, void *__buf, size_t __nbyte, off_t a4, uint64_t *a5)
{
  if (gGMFigKTraceEnabled == 1) {
    kdebug_trace();
  }
  ssize_t v10 = pwrite(*a1, __buf, __nbyte, a4);
  ssize_t v11 = v10;
  uint64_t v12 = v10 & ~(v10 >> 63);
  if (gGMFigKTraceEnabled == 1)
  {
    if (v10 < 0) {
      __error();
    }
    kdebug_trace();
    if (__nbyte != v11 && gGMFigKTraceEnabled == 1) {
      kdebug_trace();
    }
  }
  if (v11 == -1)
  {
    uint64_t v15 = __error();
    uint64_t v14 = FigSignalErrorAt(*v15, 0, 0, 0, 0, 0, 0);
    if (gGMFigKTraceEnabled == 1)
    {
      __error();
      kdebug_trace();
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (a5) {
    *a5 = v12;
  }
  return v14;
}

uint64_t FigFileForkReadWithIOPolicy(int *a1, int a2, void *a3, size_t a4, off_t a5, uint64_t *a6)
{
  int v14 = 0;
  BOOL IsDifferentFromCurrentIOPolicy = FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy("FigFileR", a2, &v14);
  uint64_t v12 = FigFileForkRead(a1, a3, a4, a5, a6);
  if (IsDifferentFromCurrentIOPolicy) {
    FigFileSetIOPolicy("FigFileR", v14);
  }
  return v12;
}

BOOL FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy(const char *a1, int a2, int *a3)
{
  if (a2 < 0)
  {
    BOOL result = 0;
    int v4 = 0;
  }
  else
  {
    int v4 = a2;
    int v6 = getiopolicy_np(0, 1);
    if (gGMFigKTraceEnabled == 1)
    {
      strncpy(__dst, a1, 8uLL);
      if ((v6 + 1) > 6) {
        unsigned int v7 = "UNKNOWN";
      }
      else {
        unsigned int v7 = off_1E5678810[v6 + 1];
      }
      strncpy(__dst, v7, 8uLL);
      kdebug_trace();
    }
    if (v6 == -1)
    {
      uint64_t v9 = __error();
      FigSignalErrorAt(*v9, 0, 0, 0, 0, 0, 0);
      BOOL result = 0;
      int v4 = -1;
    }
    else if (v6 == v4)
    {
      BOOL result = 0;
    }
    else
    {
      BOOL result = FigFileSetIOPolicy(a1, v4) != -1;
      int v4 = v6;
    }
  }
  *a3 = v4;
  return result;
}

uint64_t FigFileSetIOPolicy(const char *a1, int a2)
{
  uint64_t v4 = setiopolicy_np(0, 1, a2);
  if (gGMFigKTraceEnabled == 1)
  {
    strncpy(__dst, a1, 8uLL);
    if ((a2 + 1) > 6) {
      CFAllocatorRef v5 = "UNKNOWN";
    }
    else {
      CFAllocatorRef v5 = off_1E5678810[a2 + 1];
    }
    strncpy(__dst, v5, 8uLL);
    kdebug_trace();
  }
  if (v4 == -1)
  {
    int v6 = __error();
    FigSignalErrorAt(*v6, 0, 0, 0, 0, 0, 0);
  }
  return v4;
}

uint64_t FigFileForkWriteWithIOPolicy(int *a1, int a2, void *a3, size_t a4, off_t a5, uint64_t *a6)
{
  int v14 = 0;
  BOOL IsDifferentFromCurrentIOPolicy = FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy("FigFileW", a2, &v14);
  uint64_t v12 = FigFileForkWrite(a1, a3, a4, a5, a6);
  if (IsDifferentFromCurrentIOPolicy) {
    FigFileSetIOPolicy("FigFileW", v14);
  }
  return v12;
}

uint64_t FigFileForkWriteIOVecArray(int *a1, int a2, uint64_t a3, int a4, off_t a5, void *a6)
{
  int v30 = 0;
  BOOL IsDifferentFromCurrentIOPolicy = FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy("FigFileV", a2, &v30);
  if (a4 >= 1)
  {
    uint64_t v10 = 0;
    int v11 = 0;
    uint64_t v28 = a3 + 8;
    int v29 = a4;
    while (1)
    {
      int v12 = a4 - v11;
      if (a4 - v11 >= 1024) {
        uint64_t v13 = 1024;
      }
      else {
        uint64_t v13 = v12;
      }
      int v14 = v11;
      if (v12 < 1)
      {
        uint64_t v15 = 0;
      }
      else
      {
        uint64_t v15 = 0;
        int v16 = (uint64_t *)(v28 + 16 * v11);
        uint64_t v17 = v13;
        do
        {
          uint64_t v18 = *v16;
          v16 += 2;
          v15 += v18;
          --v17;
        }
        while (v17);
      }
      if (gGMFigKTraceEnabled == 1) {
        kdebug_trace();
      }
      uint64_t v19 = a3;
      ssize_t v20 = pwritev(*a1, (const iovec *)(a3 + 16 * v11), v13, a5);
      ssize_t v21 = v20;
      uint64_t v22 = v20 & ~(v20 >> 63);
      if (gGMFigKTraceEnabled == 1)
      {
        if (v20 < 0) {
          __error();
        }
        kdebug_trace();
        if (v15 != v21 && gGMFigKTraceEnabled == 1) {
          kdebug_trace();
        }
      }
      if (v21 == -1)
      {
        CFTypeID v23 = __error();
        uint64_t v24 = FigSignalErrorAt(*v23, 0, 0, 0, 0, 0, 0);
        if (gGMFigKTraceEnabled == 1)
        {
          __error();
          kdebug_trace();
        }
        if (v24) {
          goto LABEL_30;
        }
        a3 = v19;
        uint64_t v22 = 0;
      }
      else
      {
        a3 = v19;
      }
      a4 = v29;
      v11 += v13;
      a5 += v22;
      v10 += v22;
      if ((int)v13 + v14 >= v29) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v10 = 0;
LABEL_28:
  uint64_t v24 = 0;
  if (a6) {
    *a6 = v10;
  }
LABEL_30:
  if (IsDifferentFromCurrentIOPolicy) {
    FigFileSetIOPolicy("FigFileV", v30);
  }
  return v24;
}

uint64_t FigFileForkPreallocateStorageSpace(int *a1, uint64_t a2, char a3, void *a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  v25[0] = a3 & 2;
  v25[1] = 3;
  uint64_t v26 = 0;
  uint64_t v27 = a2;
  uint64_t v28 = 0;
  if (dword_1EB28B610)
  {
    int v24 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B608, 1, &v24, &type);
    int v8 = v24;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
      unsigned int v10 = v8;
    }
    else {
      unsigned int v10 = v8 & 0xFFFFFFFE;
    }
    if (v10)
    {
      int v11 = *a1;
      int v29 = 136315906;
      int v30 = "FigFileForkPreallocateStorageSpace";
      __int16 v31 = 2048;
      CFMutableArrayRef v32 = a1;
      __int16 v33 = 1024;
      int v34 = v11;
      __int16 v35 = 2048;
      uint64_t v36 = a2;
      int v22 = 38;
      int v12 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v24;
    }
    else
    {
      int v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B608, 1u, 1, v12, v12 != v37, v8, 0, v9);
  }
  int v13 = fcntl(*a1, 42, v25, v22);
  if (dword_1EB28B610)
  {
    int v24 = 0;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    int v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B608, 1, &v24, &type);
    int v15 = v24;
    if (os_log_type_enabled(v14, type)) {
      unsigned int v17 = v15;
    }
    else {
      unsigned int v17 = v15 & 0xFFFFFFFE;
    }
    if (v17)
    {
      int v18 = *a1;
      int v29 = 136315906;
      int v30 = "FigFileForkPreallocateStorageSpace";
      __int16 v31 = 2048;
      CFMutableArrayRef v32 = a1;
      __int16 v33 = 1024;
      int v34 = v18;
      __int16 v35 = 2048;
      uint64_t v36 = v28;
      uint64_t v19 = (unsigned char *)_os_log_send_and_compose_impl();
      LOBYTE(v15) = v24;
    }
    else
    {
      uint64_t v19 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B608, 1u, 1, v19, v19 != v37, v15, 0, v16);
  }
  if (v13 == -1)
  {
    ssize_t v21 = __error();
    return FigSignalErrorAt(*v21, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    uint64_t result = 0;
    if (a4) {
      *a4 = v28;
    }
  }
  return result;
}

uint64_t FigFileForkGetAllocatedStorageSpaceLength(int *a1, void *a2)
{
  memset(&v5, 0, sizeof(v5));
  if (a2)
  {
    if (fstat(*a1, &v5) == -1)
    {
      uint64_t v4 = __error();
      return FigSignalErrorAt(*v4, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      uint64_t result = 0;
      *a2 = v5.st_blocks << 9;
    }
  }
  else
  {
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigFileForkGetLengthAtOffset(int *a1, uint64_t a2, void *a3)
{
  memset(&v7, 0, sizeof(v7));
  if (a3)
  {
    if (fstat(*a1, &v7) == -1)
    {
      int v6 = __error();
      return FigSignalErrorAt(*v6, 0, 0, 0, 0, 0, 0);
    }
    else if (a2 < 0 || v7.st_size <= a2)
    {
      uint64_t result = 0;
      *a3 = 0;
    }
    else
    {
      uint64_t result = 0;
      *a3 = v7.st_size - a2;
    }
  }
  else
  {
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigFileForkTruncate(int *a1, off_t a2)
{
  if (ftruncate(*a1, a2) != -1) {
    return 0;
  }
  uint64_t v3 = *__error();

  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFileForkSynchronize(int *a1, char a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (dword_1EB28B610)
    {
      int v29 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B608, 1, &v29, &type);
      int v10 = v29;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v12 = v10;
      }
      else {
        unsigned int v12 = v10 & 0xFFFFFFFE;
      }
      if (v12)
      {
        int v13 = *a1;
        int v30 = 136315650;
        __int16 v31 = "FigFileForkSynchronize";
        __int16 v32 = 2048;
        __int16 v33 = a1;
        __int16 v34 = 1024;
        int v35 = v13;
        int v27 = 28;
        uint64_t v26 = &v30;
        int v14 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v29;
      }
      else
      {
        int v14 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B608, 1u, 1, v14, v14 != v36, v10, 0, v11);
    }
    int v15 = fcntl(*a1, 51, v26, v27);
    if (dword_1EB28B610)
    {
      int v29 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      ssize_t v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B608, 1, &v29, &type);
      int v17 = v29;
      if (os_log_type_enabled(v20, type)) {
        unsigned int v21 = v17;
      }
      else {
        unsigned int v21 = v17 & 0xFFFFFFFE;
      }
      if (v21) {
        goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else
  {
    if (dword_1EB28B610)
    {
      int v29 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v3 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B608, 1, &v29, &type);
      int v4 = v29;
      if (os_log_type_enabled(v3, type)) {
        unsigned int v6 = v4;
      }
      else {
        unsigned int v6 = v4 & 0xFFFFFFFE;
      }
      if (v6)
      {
        int v7 = *a1;
        int v30 = 136315650;
        __int16 v31 = "FigFileForkSynchronize";
        __int16 v32 = 2048;
        __int16 v33 = a1;
        __int16 v34 = 1024;
        int v35 = v7;
        int v8 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v29;
      }
      else
      {
        int v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B608, 1u, 1, v8, v8 != v36, v4, 0, v5);
    }
    int v15 = fsync(*a1);
    if (dword_1EB28B610)
    {
      int v29 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EB28B608, 1, &v29, &type);
      int v17 = v29;
      if (os_log_type_enabled(v16, type)) {
        unsigned int v19 = v17;
      }
      else {
        unsigned int v19 = v17 & 0xFFFFFFFE;
      }
      if (v19)
      {
LABEL_29:
        int v22 = *a1;
        int v30 = 136315650;
        __int16 v31 = "FigFileForkSynchronize";
        __int16 v32 = 2048;
        __int16 v33 = a1;
        __int16 v34 = 1024;
        int v35 = v22;
        CFTypeID v23 = (unsigned char *)_os_log_send_and_compose_impl();
        LOBYTE(v17) = v29;
LABEL_31:
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EB28B608, 1u, 1, v23, v23 != v36, v17, 0, v18);
        goto LABEL_32;
      }
LABEL_30:
      CFTypeID v23 = 0;
      goto LABEL_31;
    }
  }
LABEL_32:
  if (v15 != -1) {
    return 0;
  }
  uint64_t v25 = __error();
  return FigSignalErrorAt(*v25, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFileCreateTempFileAtURL(const __CFURL *a1, __CFString *a2, CFURLRef *a3, void *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  ptr = 0;
  bzero(__str, 0x400uLL);
  unsigned int v19 = 0;
  int v8 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (!a1) {
    goto LABEL_16;
  }
  if (!a2)
  {
    uint64_t v18 = 4294955096;
    goto LABEL_21;
  }
  if (!a3 || !a4)
  {
LABEL_16:
    uint64_t Path = FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }
  uint64_t Path = FigFileGetPath(a1, (UInt8 **)&ptr);
  if (Path)
  {
LABEL_17:
    uint64_t v16 = Path;
    a2 = 0;
    goto LABEL_11;
  }
  CFAllocatorRef v10 = *v8;
  BytesFromCFCFStringRef String = FigCreateBytesFromCFString(*v8, a2, 0x8000100u, 1, 0);
  a2 = (__CFString *)BytesFromCFString;
  if (!BytesFromCFString)
  {
LABEL_18:
    uint64_t v18 = 4294955095;
LABEL_21:
    uint64_t v13 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  snprintf(__str, 0x400uLL, "%s/%s.XXXXXX", (const char *)ptr, (const char *)BytesFromCFString);
  int v12 = mkstemp(__str);
  if (v12 == -1)
  {
    uint64_t v18 = 4294955091;
    goto LABEL_21;
  }
  uint64_t v13 = FigFileWrapDarwinFileDesc(v12, &v19);
  if (!v13)
  {
    size_t v14 = strlen(__str);
    CFURLRef v15 = CFURLCreateFromFileSystemRepresentation(v10, (const UInt8 *)__str, v14, 0);
    if (v15)
    {
      uint64_t v16 = 0;
      *a3 = v15;
      *a4 = v19;
      unsigned int v19 = 0;
      goto LABEL_11;
    }
    goto LABEL_18;
  }
LABEL_22:
  uint64_t v16 = v13;
LABEL_11:
  if (ptr) {
    CFAllocatorDeallocate(*v8, ptr);
  }
  if (a2) {
    CFAllocatorDeallocate(*v8, a2);
  }
  FigFileForkClose(v19);
  return v16;
}

uint64_t FigFileGetPath(const __CFURL *a1, UInt8 **a2)
{
  if (a1 && a2)
  {
    CFURLRef v3 = CFURLCopyAbsoluteURL(a1);
    if (v3)
    {
      CFURLRef v4 = v3;
      CFStringRef v5 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
      if (v5)
      {
        CFStringRef v6 = v5;
        BytesFromCFCFStringRef String = FigCreateBytesFromCFString((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v5, 0x8000100u, 1, 0);
        if (BytesFromCFString)
        {
          uint64_t v8 = 0;
          *a2 = BytesFromCFString;
        }
        else
        {
          uint64_t v8 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
        }
        CFRelease(v4);
        CFRelease(v6);
        return v8;
      }
      else
      {
        uint64_t v11 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
        CFRelease(v4);
        return v11;
      }
    }
    uint64_t v10 = 4294955095;
  }
  else
  {
    uint64_t v10 = 4294955096;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFileCreateTempDirectory(const char *a1, CFURLRef *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x400uLL);
  bzero(v14, 0x400uLL);
  if (a1 && a2)
  {
    CStringPtrMaybeUsingPreallocateduint64_t Buffer = FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer(a1, v13, 1024, 0x8000100u);
    confstr(65537, v14, 0x400uLL);
    CFStringRef v5 = "";
    if (CStringPtrMaybeUsingPreallocatedBuffer) {
      CFStringRef v5 = CStringPtrMaybeUsingPreallocatedBuffer;
    }
    snprintf(__str, 0x400uLL, "%s/%s.XXXXXX", v14, v5);
    CFStringRef v6 = mkdtemp(__str);
    if (v6)
    {
      int v7 = (const UInt8 *)v6;
      size_t v8 = strlen(v6);
      CFURLRef v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, v8, 1u);
      if (v9)
      {
        CFURLRef v10 = v9;
        uint64_t result = 0;
        *a2 = v10;
        return result;
      }
      uint64_t v12 = 4294955091;
    }
    else
    {
      uint64_t v12 = *__error();
    }
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }

  return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFileRename(const __CFURL *a1, const __CFURL *a2)
{
  CFURLRef v10 = 0;
  ptr = 0;
  if (a1 && a2)
  {
    uint64_t Path = FigFileGetPath(a1, (UInt8 **)&ptr);
    if (Path) {
      goto LABEL_15;
    }
    uint64_t Path = FigFileGetPath(a2, (UInt8 **)&v10);
    if (Path) {
      goto LABEL_15;
    }
    rename((const std::__fs::filesystem::path *)ptr, (const std::__fs::filesystem::path *)v10, v4);
    if (!v5)
    {
      uint64_t v6 = 0;
      goto LABEL_7;
    }
    uint64_t v9 = *__error();
  }
  else
  {
    uint64_t v9 = 4294955096;
  }
  uint64_t Path = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
LABEL_15:
  uint64_t v6 = Path;
LABEL_7:
  int v7 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (ptr) {
    CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ptr);
  }
  if (v10) {
    CFAllocatorDeallocate(*v7, v10);
  }
  return v6;
}

uint64_t FigFileLock(int *a1, char a2)
{
  if (a1)
  {
    uint64_t result = flock(*a1, a2 & 7);
    if (result)
    {
      if (*__error() == 35) {
        return 4294955090;
      }
      else {
        return *__error();
      }
    }
  }
  else
  {
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigFileUnlock(int *a1)
{
  if (a1)
  {
    uint64_t result = flock(*a1, 8);
    if (result) {
      return *__error();
    }
  }
  else
  {
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigFileDeleteRecursive(const __CFURL *a1)
{
  path = 0;
  if (a1)
  {
    if (!FigFileDoesFileExist(a1)) {
      return 0;
    }
    uint64_t v2 = FigFileGetPath(a1, (UInt8 **)&path);
    if (!v2)
    {
      uint64_t v3 = removefile(path, 0, 1u);
      if (!v3)
      {
        uint64_t v4 = 0;
        goto LABEL_6;
      }
      uint64_t v2 = FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    }
    uint64_t v4 = v2;
LABEL_6:
    if (path) {
      CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], path);
    }
    return v4;
  }

  return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
}

uint64_t FigDirectoryEnableDirStatsTracking(const __CFURL *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 0;
  if (!CFURLGetFileSystemRepresentation(a1, 0, buffer, 1024)) {
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  }
  int v1 = fsctl((const char *)buffer, 0x80084A02uLL, &v4, 0);
  uint64_t result = 0;
  if (v1 < 0)
  {
    uint64_t v3 = __error();
    return convertPOSIXErrorToFigFileError(*v3, 0);
  }
  return result;
}

uint64_t FigFileMarkPurgeable(const __CFURL *a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!CFURLGetFileSystemRepresentation(a1, 0, buffer, 1024)) {
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v3 = 66568;
  if (!a2) {
    uint64_t v3 = 0;
  }
  uint64_t v7 = v3;
  int v4 = fsctl((const char *)buffer, 0xC0084A44uLL, &v7, 0);
  uint64_t result = 0;
  if (v4 < 0)
  {
    uint64_t v6 = __error();
    return convertPOSIXErrorToFigFileError(*v6, 0);
  }
  return result;
}

uint64_t FigDirectoryIsDirStatsTrackingEnabled(const __CFURL *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v6 = 0u;
  long long v5 = 0u;
  uint64_t v4 = 1;
  if (CFURLGetFileSystemRepresentation(a1, 0, buffer, 1024))
  {
    if ((fsctl((const char *)buffer, 0xC0284A20uLL, &v4, 0) & 0x80000000) == 0) {
      return 1;
    }
    if (*__error() == 45) {
      return 2;
    }
    uint64_t v2 = __error();
    uint64_t v3 = convertPOSIXErrorToFigFileError(*v2, 0);
  }
  else
  {
    uint64_t v3 = 4294955096;
  }
  FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  return 0;
}

OSStatus CMMetadataCreateIdentifierForKeyAndKeySpace(CFAllocatorRef allocator, CFTypeRef key, CFStringRef keySpace, CFStringRef *identifierOut)
{
  if (!identifierOut)
  {
    uint64_t v10 = 4294950995;
    goto LABEL_62;
  }
  *identifierOut = 0;
  if (!keySpace) {
    goto LABEL_58;
  }
  if (CFEqual(keySpace, @"anon"))
  {
    if (!key)
    {
      OSStatus v15 = 0;
      *identifierOut = (CFStringRef)CFRetain(@"anon");
      return v15;
    }
LABEL_58:
    uint64_t v10 = 4294950995;
    goto LABEL_62;
  }
  if (!key)
  {
    uint64_t v10 = 4294950994;
    goto LABEL_62;
  }
  if (CFEqual(keySpace, @"org.id3")
    || CFEqual(keySpace, @"id3 "))
  {
    CFStringRef v9 = @"id3";
    goto LABEL_15;
  }
  if (CFEqual(keySpace, @"icy "))
  {
    CFStringRef v9 = @"icy";
    goto LABEL_15;
  }
  if (CFEqual(keySpace, @"org.avchd-info"))
  {
    CFStringRef v9 = @"avch";
    goto LABEL_15;
  }
  if (CFEqual(keySpace, @"comn"))
  {
    CFStringRef v9 = @"common";
    goto LABEL_15;
  }
  CFIndex Length = CFStringGetLength(keySpace);
  if (Length)
  {
    if (Length < 5)
    {
      CFStringRef v9 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], keySpace, 0, @"/", 0);
      if (v9)
      {
LABEL_15:
        usedBufLeuint64_t n = 0;
        unsigned int v24 = 0;
        unint64_t valuePtr = 0;
        CFTypeID v11 = CFGetTypeID(key);
        BOOL HasOSTypeValues = keyNamespaceHasOSTypeValues(v9);
        CFTypeID TypeID = CFStringGetTypeID();
        if (HasOSTypeValues)
        {
          if (TypeID == v11)
          {
            if (CFStringGetLength((CFStringRef)key) == 4)
            {
              v27.CFIndex location = 0;
              v27.CFIndex length = 4;
              CFStringGetBytes((CFStringRef)key, v27, 0, 0, 0, buffer, 4, &usedBufLen);
              if (usedBufLen != 4)
              {
                uint64_t v14 = 4294950994;
LABEL_67:
                OSStatus v15 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
                CFStringRef v17 = 0;
                goto LABEL_68;
              }
              goto LABEL_37;
            }
            goto LABEL_66;
          }
          if (CFNumberGetTypeID() == v11)
          {
            CFNumberGetValue((CFNumberRef)key, kCFNumberSInt64Type, &valuePtr);
            CFNumberGetValue((CFNumberRef)key, kCFNumberSInt32Type, &v24);
            if (HIDWORD(valuePtr) && valuePtr != v24)
            {
              uint64_t v14 = 4294950991;
              goto LABEL_67;
            }
            unsigned int v24 = bswap32(v24);
            if (keyNamespaceHasAtSymbolOSTypeValues(v9) && v24 == 64) {
              LOBYTE(v24) = -87;
            }
            uint64_t v18 = (UInt8 *)&v24;
            goto LABEL_41;
          }
          if (CFDataGetTypeID() == v11)
          {
            if (CFDataGetLength((CFDataRef)key) == 4)
            {
              v28.CFIndex location = 0;
              v28.CFIndex length = 4;
              CFDataGetBytes((CFDataRef)key, v28, buffer);
LABEL_37:
              if (keyNamespaceHasAtSymbolOSTypeValues(v9) && buffer[0] == 64) {
                buffer[0] = -87;
              }
              uint64_t v18 = buffer;
LABEL_41:
              CFStringRef v19 = CFStringCreateWithBytes(allocator, v18, 4, 0, 0);
              goto LABEL_42;
            }
LABEL_66:
            uint64_t v14 = 4294950993;
            goto LABEL_67;
          }
        }
        else
        {
          if (TypeID == v11)
          {
            if (CFStringGetLength((CFStringRef)key) > 0)
            {
              CFStringRef v16 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)key, 0, @"/", 0);
              CFStringRef v17 = 0;
              goto LABEL_44;
            }
            goto LABEL_66;
          }
          if (CFDataGetTypeID() == v11)
          {
            CFStringRef v19 = CFStringCreateFromExternalRepresentation(allocator, (CFDataRef)key, 0);
LABEL_42:
            CFStringRef v17 = v19;
            if (!v19)
            {
              OSStatus v15 = FigSignalErrorAt(4294950994, 0, 0, 0, 0, 0, 0);
LABEL_68:
              CFStringRef v16 = 0;
              goto LABEL_47;
            }
            CFStringRef v16 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v19, 0, @"/", 0);
LABEL_44:
            if (v16
              && (CFStringRef v20 = CFStringCreateWithFormat(allocator, 0, @"%@/%@", v9, v16), (*identifierOut = v20) != 0))
            {
              OSStatus v15 = 0;
            }
            else
            {
              OSStatus v15 = FigSignalErrorAt(4294950996, 0, 0, 0, 0, 0, 0);
            }
            goto LABEL_47;
          }
        }
        CFStringRef v17 = 0;
        CFStringRef v16 = 0;
        OSStatus v15 = -16304;
LABEL_47:
        if (v9) {
          CFRelease(v9);
        }
        if (v16) {
          CFRelease(v16);
        }
        if (v17) {
          CFRelease(v17);
        }
        return v15;
      }
    }
  }
  uint64_t v10 = 4294950990;
LABEL_62:

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

BOOL keyNamespaceHasOSTypeValues(const __CFString *a1)
{
  return CFEqual(a1, @"udta")
      || CFEqual(a1, @"itsk")
      || CFEqual(a1, @"uiso")
      || CFEqual(a1, @"id3");
}

BOOL keyNamespaceHasAtSymbolOSTypeValues(const __CFString *a1)
{
  return CFEqual(a1, @"udta")
      || CFEqual(a1, @"itsk");
}

uint64_t FigMetadataCreateIdentifierForKeyAndOSTypeKeySpace(const __CFAllocator *a1, const void *a2, unsigned int a3, CFStringRef *a4)
{
  if (a3 == 1768126752)
  {
    uint64_t v7 = @"icy";
LABEL_5:
    CFStringRef v8 = (const __CFString *)CFRetain(v7);
LABEL_6:
    CFStringRef v9 = v8;
    goto LABEL_7;
  }
  if (a3 == 1768174368)
  {
    uint64_t v7 = @"id3";
    goto LABEL_5;
  }
  int v12 = 0;
  unsigned int v13 = bswap32(a3);
  char v14 = 1;
  int v15 = 4;
  unsigned int v16 = v13;
  uint64_t IdentifierForKeyAndKeySpace = 4294950990;
  do
  {
    if (HIBYTE(v16))
    {
      if (v12 || !(v16 >> 29) || (v16 & 0xFF000000) == 0x7F000000) {
        return IdentifierForKeyAndKeySpace;
      }
      int v12 = 0;
    }
    else
    {
      if (v14) {
        return 4294950990;
      }
      int v12 = 1;
    }
    char v14 = 0;
    v16 <<= 8;
    --v15;
  }
  while (v15);
  uint64_t v17 = 3;
  if (HIBYTE(a3)) {
    uint64_t v17 = 4;
  }
  uint64_t v18 = v17 - (a3 < 0x10000) - (a3 < 0x100);
  uint64_t v19 = a3 == 0;
  uint64_t v20 = v18 - v19;
  if (v18 != v19)
  {
    unsigned int v22 = v13;
    __strncpy_chk();
    cStr[v20] = 0;
    CFStringRef v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0);
    goto LABEL_6;
  }
  CFStringRef v9 = 0;
LABEL_7:
  uint64_t IdentifierForKeyAndKeySpace = CMMetadataCreateIdentifierForKeyAndKeySpace(a1, a2, v9, a4);
  if (v9) {
    CFRelease(v9);
  }
  return IdentifierForKeyAndKeySpace;
}

OSStatus CMMetadataCreateKeyFromIdentifierAsCFData(CFAllocatorRef allocator, CFStringRef identifier, CFDataRef *keyOut)
{
  CFTypeRef v9 = 0;
  CFTypeRef cf = 0;
  if (keyOut)
  {
    *keyOut = 0;
    OSStatus EncodedPartsOfIdentifier = getEncodedPartsOfIdentifier(allocator, identifier, (CFStringRef *)&cf, (CFStringRef *)&v9);
    CFTypeRef v6 = cf;
    if (!EncodedPartsOfIdentifier) {
      OSStatus EncodedPartsOfIdentifier = createKeyAsCFData(allocator, (const __CFString *)cf, (CFStringRef)v9, keyOut);
    }
    OSStatus v7 = EncodedPartsOfIdentifier;
    if (v6) {
      CFRelease(v6);
    }
    if (v9) {
      CFRelease(v9);
    }
    return v7;
  }
  else
  {
    return FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t getEncodedPartsOfIdentifier(const __CFAllocator *a1, CFStringRef theString1, CFStringRef *a3, CFStringRef *a4)
{
  if (theString1)
  {
    if (CFEqual(theString1, @"anon")) {
      return 4294950988;
    }
    CFIndex Length = CFStringGetLength(theString1);
    CFRange v9 = CFStringFind(theString1, @"/", 0);
    if (v9.length)
    {
      if (v9.location && Length - 1 > v9.location)
      {
        v14.CFIndex location = 0;
        v14.CFIndex length = v9.location;
        *a3 = CFStringCreateWithSubstring(a1, theString1, v14);
        v15.CFIndex location = v9.location + 1;
        v15.CFIndex length = Length - (v9.location + 1);
        CFStringRef v10 = CFStringCreateWithSubstring(a1, theString1, v15);
        uint64_t result = 0;
        *a4 = v10;
        return result;
      }
      uint64_t v12 = 4294950989;
    }
    else
    {
      uint64_t v12 = 4294950989;
    }
  }
  else
  {
    uint64_t v12 = 4294950995;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t createKeyAsCFData(const __CFAllocator *a1, const __CFString *a2, CFStringRef origString, CFDataRef *a4)
{
  CFStringRef v7 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E4F1CF80], origString, &stru_1EDF73CD0, 0);
  if (v7)
  {
    CFStringRef v8 = v7;
    usedBufLeuint64_t n = 0;
    if (keyNamespaceHasOSTypeValues(a2))
    {
      if (CFStringGetLength(v8) == 4)
      {
        v17.CFIndex location = 0;
        v17.CFIndex length = 4;
        CFStringGetBytes(v8, v17, 0, 0, 0, buffer, 4, &usedBufLen);
        if (usedBufLen == 4)
        {
          CFDataRef v9 = CFDataCreate(a1, buffer, 4);
          *a4 = v9;
          if (v9)
          {
            uint64_t v10 = 0;
LABEL_8:
            CFRelease(v8);
            return v10;
          }
        }
        uint64_t v13 = 4294950994;
      }
      else
      {
        uint64_t v13 = 4294950993;
      }
      uint64_t v10 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
      goto LABEL_8;
    }
    ExternalRepresentatiouint64_t n = CFStringCreateExternalRepresentation(a1, v8, 0, 0);
    uint64_t v10 = 0;
    *a4 = ExternalRepresentation;
    goto LABEL_8;
  }

  return FigSignalErrorAt(4294950994, 0, 0, 0, 0, 0, 0);
}

OSStatus CMMetadataCreateKeyFromIdentifier(CFAllocatorRef allocator, CFStringRef identifier, CFTypeRef *keyOut)
{
  origCFStringRef String = 0;
  CFTypeRef cf = 0;
  if (keyOut)
  {
    *keyOut = 0;
    OSStatus EncodedPartsOfIdentifier = getEncodedPartsOfIdentifier(allocator, identifier, (CFStringRef *)&cf, &origString);
    CFStringRef v6 = (const __CFString *)cf;
    if (EncodedPartsOfIdentifier) {
      goto LABEL_20;
    }
    if (keyNamespaceHasOSTypeValues((const __CFString *)cf))
    {
      int valuePtr = 0;
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E4F1CF80], origString, &stru_1EDF73CD0, 0);
      if (v8)
      {
        CFStringRef v9 = v8;
        usedBufLeuint64_t n = 0;
        if (keyNamespaceHasOSTypeValues(v6))
        {
          if (CFStringGetLength(v9) == 4)
          {
            v27.CFIndex location = 0;
            v27.CFIndex length = 4;
            CFStringGetBytes(v9, v27, 0, 0, 0, buffer, 4, &usedBufLen);
            if (usedBufLen == 4)
            {
              uint64_t v10 = 0;
              int v11 = 0;
              do
                int v11 = buffer[v10++] | (v11 << 8);
              while (v10 != 4);
              usedBufLeuint64_t n = 4;
              int valuePtr = v11;
              CFNumberRef v12 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
              *keyOut = v12;
              if (v12)
              {
                OSStatus v13 = 0;
LABEL_32:
                CFStringRef v18 = v9;
                goto LABEL_35;
              }
            }
            uint64_t v20 = 4294950994;
          }
          else
          {
            uint64_t v20 = 4294950993;
          }
          OSStatus v13 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
          goto LABEL_32;
        }
        OSStatus v13 = -16304;
        goto LABEL_32;
      }
      goto LABEL_43;
    }
    if (CFStringCompare(v6, @"mdta", 0)
      && CFStringCompare(v6, @"fiel", 0)
      && CFStringCompare(v6, @"comn", 0)
      && CFStringCompare(v6, @"common", 0)
      && CFStringCompare(v6, @"itlk", 0)
      && CFStringCompare(v6, @"icy", 0)
      && CFStringCompare(v6, @"lsdr", 0))
    {
      OSStatus EncodedPartsOfIdentifier = createKeyAsCFData(allocator, v6, origString, (CFDataRef *)keyOut);
      goto LABEL_20;
    }
    CFStringRef v14 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E4F1CF80], origString, &stru_1EDF73CD0, 0);
    if (!v14)
    {
LABEL_43:
      OSStatus EncodedPartsOfIdentifier = FigSignalErrorAt(4294950994, 0, 0, 0, 0, 0, 0);
LABEL_20:
      OSStatus v13 = EncodedPartsOfIdentifier;
      if (!v6) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }
    CFStringRef v15 = v14;
    usedBufLeuint64_t n = 0;
    if (keyNamespaceHasOSTypeValues(v6))
    {
      if (CFStringGetLength(v15) == 4)
      {
        v28.CFIndex location = 0;
        v28.CFIndex length = 4;
        CFStringGetBytes(v15, v28, 0, 0, 0, buffer, 4, &usedBufLen);
        if (usedBufLen == 4)
        {
          if (keyNamespaceHasAtSymbolOSTypeValues(v6) && buffer[0] == 169) {
            buffer[0] = 64;
          }
          CFStringRef v16 = CFStringCreateWithBytes(allocator, buffer, 4, 0, 0);
          OSStatus v13 = 0;
          *keyOut = v16;
          if (v16) {
            goto LABEL_34;
          }
        }
        uint64_t v17 = 4294950994;
      }
      else
      {
        uint64_t v17 = 4294950993;
      }
      OSStatus v13 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      OSStatus v13 = 0;
      *keyOut = CFRetain(v15);
    }
LABEL_34:
    CFStringRef v18 = v15;
LABEL_35:
    CFRelease(v18);
    if (!v6)
    {
LABEL_37:
      if (origString) {
        CFRelease(origString);
      }
      return v13;
    }
LABEL_36:
    CFRelease(v6);
    goto LABEL_37;
  }

  return FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
}

OSStatus CMMetadataCreateKeySpaceFromIdentifier(CFAllocatorRef allocator, CFStringRef identifier, CFStringRef *keySpaceOut)
{
  CFTypeRef cf = 0;
  CFStringRef theString1 = 0;
  if (keySpaceOut)
  {
    *keySpaceOut = 0;
    if (!identifier)
    {
      OSStatus v10 = FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
      CFStringRef v9 = 0;
      goto LABEL_20;
    }
    if (CFStringCompare(identifier, @"anon", 0))
    {
      OSStatus EncodedPartsOfIdentifier = getEncodedPartsOfIdentifier(allocator, identifier, &theString1, (CFStringRef *)&cf);
      CFStringRef v7 = theString1;
      if (EncodedPartsOfIdentifier)
      {
        OSStatus v10 = EncodedPartsOfIdentifier;
LABEL_12:
        CFStringRef v9 = 0;
        if (!v7) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      if (CFStringCompare(theString1, @"common", 0))
      {
        if (CFStringCompare(v7, @"id3", 0))
        {
          if (CFStringCompare(v7, @"avch", 0))
          {
            CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, &stru_1EDF73CD0, 0);
            CFStringRef v9 = v8;
            if (v8 && CFStringGetLength(v8) && CFStringGetLength(v9) < 5)
            {
              OSStatus v10 = 0;
              *keySpaceOut = v9;
              goto LABEL_12;
            }
            OSStatus v10 = FigSignalErrorAt(4294950989, 0, 0, 0, 0, 0, 0);
            if (!v7) {
              goto LABEL_20;
            }
LABEL_19:
            CFRelease(v7);
            goto LABEL_20;
          }
          int v11 = @"org.avchd-info";
        }
        else
        {
          int v11 = @"org.id3";
        }
      }
      else
      {
        int v11 = @"comn";
      }
      CFStringRef v9 = 0;
      OSStatus v10 = 0;
      *keySpaceOut = (CFStringRef)CFRetain(v11);
      if (v7) {
        goto LABEL_19;
      }
    }
    else
    {
      OSStatus v10 = 0;
      CFStringRef v9 = 0;
      *keySpaceOut = (CFStringRef)CFRetain(identifier);
    }
LABEL_20:
    if (cf) {
      CFRelease(cf);
    }
    if (v9) {
      CFRelease(v9);
    }
    return v10;
  }

  return FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMetadataGetKeySpaceAsOSTypeFromIdentifier(CFStringRef identifier)
{
  CFStringRef keySpaceOut = 0;
  if (CMMetadataCreateKeySpaceFromIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], identifier, &keySpaceOut))
  {
    uint64_t v1 = 0;
  }
  else
  {
    uint64_t v1 = 1768174368;
    CFStringRef v2 = keySpaceOut;
    unsigned int v8 = 0;
    if (CFStringCompare(keySpaceOut, @"id3", 0) && CFStringCompare(v2, @"org.id3", 0))
    {
      if (CFStringCompare(v2, @"icy", 0))
      {
        if (CFStringCompare(v2, @"org.avchd-info", 0))
        {
          if (CFStringCompare(v2, @"common", 0))
          {
            usedBufLeuint64_t n = 0;
            CFIndex Length = CFStringGetLength(v2);
            v9.CFIndex location = 0;
            v9.CFIndex length = Length;
            CFStringGetBytes(v2, v9, 0, 0, 0, buffer, 4, &usedBufLen);
            memcpy((char *)&v8 - Length + 4, buffer, Length);
            uint64_t v1 = bswap32(v8);
          }
          else
          {
            uint64_t v1 = 1668246894;
          }
        }
        else
        {
          uint64_t v1 = 1635148648;
        }
      }
      else
      {
        uint64_t v1 = 1768126752;
      }
    }
  }
  if (keySpaceOut) {
    CFRelease(keySpaceOut);
  }
  return v1;
}

OSStatus CMMetadataDataTypeRegistryRegisterDataType(CFStringRef dataType, CFStringRef description, CFArrayRef conformingDataTypes)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v6 = gfigMetadataDataTypeRegistryStorage;

  return doFigMetadataDataTypeRegistryRegisterDataType(v6, dataType, description, conformingDataTypes);
}

uint64_t doFigMetadataDataTypeRegistryRegisterDataType(uint64_t a1, const __CFString *a2, const void *a3, CFArrayRef theArray)
{
  if (!a1)
  {
    uint64_t v33 = 4294950986;
    goto LABEL_32;
  }
  if (!a2)
  {
    uint64_t v33 = 4294950985;
    goto LABEL_32;
  }
  if (!theArray)
  {
    CFArrayRef v28 = *(const __CFArray **)(a1 + 40);
    v37.CFIndex length = CFArrayGetCount(v28);
    v37.CFIndex location = 0;
    int v29 = CFArrayContainsValue(v28, v37, a2);
    CFStringRef v11 = a2;
    if (v29) {
      goto LABEL_20;
    }
    goto LABEL_31;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
LABEL_31:
    uint64_t v33 = 4294950982;
LABEL_32:
    return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
  }
  CFIndex v9 = Count;
  CFIndex v10 = 0;
  CFStringRef v11 = 0;
  do
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v10);
    if (!ValueAtIndex || (CFStringRef v13 = ValueAtIndex, TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v13)))
    {
      uint64_t v33 = 4294950984;
      goto LABEL_32;
    }
    CFArrayRef v15 = *(const __CFArray **)(a1 + 40);
    v35.CFIndex length = CFArrayGetCount(v15);
    v35.CFIndex location = 0;
    if (CFArrayContainsValue(v15, v35, v13))
    {
      if (!v11)
      {
        CFStringRef v11 = v13;
        goto LABEL_18;
      }
      CFStringRef v16 = v11;
      CFStringRef v17 = v13;
    }
    else
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v13);
      if (!Value) {
        goto LABEL_18;
      }
      CFStringRef v17 = Value;
      if (!v11)
      {
        CFStringRef v11 = Value;
        goto LABEL_18;
      }
      CFStringRef v16 = v11;
    }
    if (CFStringCompare(v16, v17, 0))
    {
      uint64_t v33 = 4294950981;
      goto LABEL_32;
    }
LABEL_18:
    ++v10;
  }
  while (v9 != v10);
  if (!v11) {
    goto LABEL_31;
  }
LABEL_20:
  FigReentrantMutexLock(*(pthread_mutex_t **)a1);
  CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  if (v19)
  {
    CFArrayRef v20 = (const __CFArray *)CFDictionaryGetValue(v19, @"ConformingDataTypes");
    if (!((unint64_t)theArray | (unint64_t)v20)) {
      goto LABEL_29;
    }
    uint64_t v21 = 4294950983;
    if (!theArray) {
      goto LABEL_42;
    }
    CFArrayRef v22 = v20;
    if (!v20) {
      goto LABEL_42;
    }
    CFIndex v23 = CFArrayGetCount(theArray);
    CFIndex v24 = CFArrayGetCount(v22);
    if (v23 != v24) {
      goto LABEL_41;
    }
    if (v23 < 1)
    {
LABEL_29:
      uint64_t v21 = 0;
      goto LABEL_42;
    }
    CFIndex v25 = v24;
    CFIndex v26 = 0;
    while (1)
    {
      CFRange v27 = CFArrayGetValueAtIndex(theArray, v26);
      v36.CFIndex location = 0;
      v36.CFIndex length = v25;
      if (!CFArrayContainsValue(v22, v36, v27)) {
        break;
      }
      if (v23 == ++v26) {
        goto LABEL_29;
      }
    }
LABEL_41:
    uint64_t v21 = 4294950983;
LABEL_42:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)a1);
  }
  else
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable)
    {
      uint64_t v21 = 4294950986;
      goto LABEL_42;
    }
    __int16 v32 = Mutable;
    if (a3) {
      CFDictionarySetValue(Mutable, @"Description", a3);
    }
    if (theArray) {
      CFDictionarySetValue(v32, @"ConformingDataTypes", theArray);
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), a2, v32);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), a2, v11);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)a1);
    CFRelease(v32);
    return 0;
  }
  return v21;
}

CFArrayRef CMMetadataDataTypeRegistryGetBaseDataTypes(void)
{
  if (gfigMetadataDataTypeRegistryStorage) {
    return *(CFArrayRef *)(gfigMetadataDataTypeRegistryStorage + 48);
  }
  else {
    return 0;
  }
}

Boolean CMMetadataDataTypeRegistryDataTypeIsBaseDataType(CFStringRef dataType)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v2 = gfigMetadataDataTypeRegistryStorage;
  if (!gfigMetadataDataTypeRegistryStorage) {
    return 0;
  }
  Boolean result = 0;
  if (dataType && *(void *)(gfigMetadataDataTypeRegistryStorage + 16))
  {
    if (FigMetadataDataTypeIsDynamicBaseDataType(dataType))
    {
      return 1;
    }
    else
    {
      FigReentrantMutexLock(*(pthread_mutex_t **)v2);
      CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 16), dataType);
      Boolean v5 = FigCFEqual(dataType, Value);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
      return v5;
    }
  }
  return result;
}

uint64_t FigMetadataDataTypeIsDynamicBaseDataType(const void *a1)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v2 = gfigMetadataDataTypeRegistryStorage;
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  uint64_t v3 = CFDictionaryContainsKey(*(CFDictionaryRef *)(v2 + 24), a1);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  return v3;
}

Boolean CMMetadataDataTypeRegistryDataTypeIsRegistered(CFStringRef dataType)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v2 = gfigMetadataDataTypeRegistryStorage;
  if (!gfigMetadataDataTypeRegistryStorage || !dataType || !*(void *)(gfigMetadataDataTypeRegistryStorage + 8)) {
    return 0;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  Boolean v3 = CFDictionaryContainsKey(*(CFDictionaryRef *)(v2 + 8), dataType);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  return v3;
}

CFStringRef CMMetadataDataTypeRegistryGetDataTypeDescription(CFStringRef dataType)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v2 = gfigMetadataDataTypeRegistryStorage;
  if (!gfigMetadataDataTypeRegistryStorage) {
    return 0;
  }
  if (!dataType) {
    return 0;
  }
  if (!*(void *)(gfigMetadataDataTypeRegistryStorage + 8)) {
    return 0;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 8), dataType);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  if (!Value) {
    return 0;
  }

  return (CFStringRef)CFDictionaryGetValue(Value, @"Description");
}

CFArrayRef CMMetadataDataTypeRegistryGetConformingDataTypes(CFStringRef dataType)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v2 = gfigMetadataDataTypeRegistryStorage;
  if (!gfigMetadataDataTypeRegistryStorage) {
    return 0;
  }
  if (!dataType) {
    return 0;
  }
  if (!*(void *)(gfigMetadataDataTypeRegistryStorage + 8)) {
    return 0;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 8), dataType);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  if (!Value) {
    return 0;
  }

  return (CFArrayRef)CFDictionaryGetValue(Value, @"ConformingDataTypes");
}

CFStringRef CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(CFStringRef dataType)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  CFStringRef result = 0;
  if (dataType)
  {
    uint64_t v3 = gfigMetadataDataTypeRegistryStorage;
    if (gfigMetadataDataTypeRegistryStorage)
    {
      if (*(void *)(gfigMetadataDataTypeRegistryStorage + 16))
      {
        if (!FigMetadataDataTypeIsDynamicBaseDataType(dataType))
        {
          FigReentrantMutexLock(*(pthread_mutex_t **)v3);
          dataType = (CFStringRef)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 16), dataType);
          FigReentrantMutexUnlock(*(pthread_mutex_t **)v3);
        }
        return dataType;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

Boolean CMMetadataDataTypeRegistryDataTypeConformsToDataType(CFStringRef dataType, CFStringRef conformsToDataType)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v4 = gfigMetadataDataTypeRegistryStorage;
  if (FigCFEqual(dataType, conformsToDataType)) {
    return 1;
  }
  Boolean v5 = 0;
  if (dataType && conformsToDataType && v4)
  {
    if (*(void *)(v4 + 16)
      && (FigReentrantMutexLock(*(pthread_mutex_t **)v4),
          (CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0)) != 0))
    {
      CFArrayRef v8 = Mutable;
      CFArrayAppendValue(Mutable, dataType);
      char v9 = 0;
      Boolean v5 = doDataTypeRegistryDatatypeConformsToDatatype(dataType, conformsToDataType, v8, v4, &v9);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)v4);
      CFRelease(v8);
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t doDataTypeRegistryDatatypeConformsToDatatype(const void *a1, const void *a2, const __CFArray *a3, uint64_t a4, unsigned char *a5)
{
  if (*a5) {
    return 0;
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 8), a1);
  if (!result)
  {
    *a5 = 1;
    return result;
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)result, @"ConformingDataTypes");
  if (result)
  {
    CFArrayRef v10 = (const __CFArray *)result;
    CFIndex Count = CFArrayGetCount((CFArrayRef)result);
    if (Count < 1) {
      return 0;
    }
    CFIndex v12 = Count;
    CFIndex v13 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v10, v13);
      if (FigCFEqual(ValueAtIndex, a2)) {
        break;
      }
      if (v12 == ++v13)
      {
        CFIndex v15 = 0;
        while (1)
        {
          CFStringRef v16 = CFArrayGetValueAtIndex(v10, v15);
          v17.CFIndex length = CFArrayGetCount(a3);
          v17.CFIndex location = 0;
          if (CFArrayContainsValue(a3, v17, v16))
          {
            uint64_t result = 0;
          }
          else
          {
            CFArrayAppendValue(a3, v16);
            uint64_t result = doDataTypeRegistryDatatypeConformsToDatatype(v16, a2, a3, a4, a5);
            if (result) {
              return 1;
            }
            if (*a5) {
              return result;
            }
          }
          if (++v15 >= v12) {
            return result;
          }
        }
      }
    }
    return 1;
  }
  return result;
}

CFStringRef FigMetadataCreateDynamicBaseDataType(const __CFAllocator *a1, int a2)
{
  int valuePtr = a2;
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v3 = gfigMetadataDataTypeRegistryStorage;
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  if (!v4)
  {
    FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  CFNumberRef v5 = v4;
  FigReentrantMutexLock(*(pthread_mutex_t **)v3);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 32), v5);
  if (Value)
  {
    CFStringRef v7 = Value;
    CFRetain(Value);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)v3);
  }
  else
  {
    CFUUIDRef v8 = CFUUIDCreate(a1);
    if (v8)
    {
      CFUUIDRef v9 = v8;
      CFStringRef v10 = CFUUIDCreateString(a1, v8);
      if (v10)
      {
        CFStringRef v11 = v10;
        CFStringRef v7 = CFStringCreateWithFormat(a1, 0, @"dyn.%@", v10);
        if (v7)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 32), v5, v7);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 24), v7, v5);
          FigReentrantMutexUnlock(*(pthread_mutex_t **)v3);
        }
        else
        {
          FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
        }
        CFRelease(v9);
        CFRelease(v11);
        goto LABEL_9;
      }
      FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
      CFRelease(v9);
    }
    else
    {
      FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
    }
    CFStringRef v7 = 0;
  }
LABEL_9:
  CFRelease(v5);
  return v7;
}

uint64_t FigMetadataGetQTWellKnownTypeFromDynamicBaseDataType(const void *a1)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  uint64_t v2 = gfigMetadataDataTypeRegistryStorage;
  unsigned int valuePtr = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 24), a1);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  if (!Value) {
    return 0;
  }
  CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  return valuePtr;
}

CFNumberRef FigMetadataKeyGetUInt32(const __CFNumber *result)
{
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (CFNumberGetTypeID() == v2)
    {
      return FigCFNumberGetUInt32(v1);
    }
    else if (CFStringGetTypeID() == v2)
    {
      return (const __CFNumber *)CFStringGetDoubleValue((CFStringRef)v1);
    }
    else if (CFDataGetTypeID() == v2)
    {
      return (const __CFNumber *)bswap32(*(_DWORD *)CFDataGetBytePtr(v1));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFNumberRef FigMetadataKeyGetLocalIDUInt32(const __CFDictionary *a1)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"MetadataKeyLocalID");

  return FigMetadataKeyGetUInt32(Value);
}

uint64_t FigMetadataKeyGetDatatypeUInt32(const __CFDictionary *a1)
{
  CFNumberRef Value = CFDictionaryGetValue(a1, @"MetadataKeyDataType");
  if (!Value) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID v2 = Value;
  CFTypeID TypeID = CFNumberGetTypeID();
  if (TypeID != CFGetTypeID(v2))
  {
    CFTypeID v4 = CFDataGetTypeID();
    if (v4 != CFGetTypeID(v2)) {
      return 0xFFFFFFFFLL;
    }
  }
  CFTypeID v5 = CFNumberGetTypeID();
  if (v5 != CFGetTypeID(v2))
  {
    CFIndex Length = CFDataGetLength((CFDataRef)v2);
    switch(Length)
    {
      case 4:
        *(_DWORD *)CFUUIDRef v8 = 0;
        v13.CFIndex location = 0;
        v13.CFIndex length = 4;
        CFDataGetBytes((CFDataRef)v2, v13, v8);
        return bswap32(*(unsigned int *)v8);
      case 2:
        *(_WORD *)CFUUIDRef v9 = 0;
        v14.CFIndex location = 0;
        v14.CFIndex length = 2;
        CFDataGetBytes((CFDataRef)v2, v14, v9);
        return bswap32(*(unsigned __int16 *)v9) >> 16;
      case 1:
        UInt8 buffer = 0;
        v12.CFIndex location = 0;
        v12.CFIndex length = 1;
        CFDataGetBytes((CFDataRef)v2, v12, &buffer);
        return buffer;
    }
    return 0xFFFFFFFFLL;
  }

  return (uint64_t)FigMetadataKeyGetUInt32((const __CFNumber *)v2);
}

CFNumberRef FigMetadataKeyGetDatatypeNamespaceUInt32(const __CFDictionary *a1)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"MetadataKeyDataTypeNameSpace");

  return FigMetadataKeyGetUInt32(Value);
}

CFNumberRef FigMetadataKeyGetKeyNamespaceUInt32(const __CFDictionary *a1)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"MetadataKeyNamespace");

  return FigMetadataKeyGetUInt32(Value);
}

uint64_t FigBoxedMetadataGetTypeID()
{
  return sFigBoxedMetadataID;
}

uint64_t registerFigBoxedMetadataType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigBoxedMetadataID = result;
  return result;
}

CFTypeRef FigBoxedMetadataRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void FigBoxedMetadataRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t FigBoxedMetadataCreateFromBlockBuffer(int a1, OpaqueCMBlockBuffer *a2, CMFormatDescriptionRef desc, void *a4)
{
  if (a4)
  {
    *a4 = 0;
    if (a2
      && desc
      && CMFormatDescriptionGetMediaType(desc) == 1835365473
      && CMFormatDescriptionGetMediaSubType(desc) == 1835360888)
    {
      FigThreadRunOnce(&sRegisterFigBoxedMetadataTypeOnce, (void (*)(void))registerFigBoxedMetadataType);
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        CFUUIDRef v8 = (void *)Instance;
        uint64_t v9 = FigAtomStreamInitWithBBuf(a2, 0, 1, Instance + 32);
        if (v9)
        {
          CFRelease(v8);
        }
        else
        {
          CFArrayRef v8[2] = a2;
          CFRetain(a2);
          _OWORD v8[3] = desc;
          CFRetain(desc);
          v8[25] = -1;
          *a4 = v8;
        }
        return v9;
      }
      uint64_t v11 = 4294950974;
    }
    else
    {
      uint64_t v11 = 4294950976;
    }
  }
  else
  {
    uint64_t v11 = 4294950976;
  }

  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBoxedMetadataCreateForConstruction(int a1, const __CFAllocator *a2, CMFormatDescriptionRef desc, uint64_t *a4)
{
  CMBlockBufferRef blockBufferOut = 0;
  if (a4)
  {
    *a4 = 0;
    if (desc
      && CMFormatDescriptionGetMediaType(desc) == 1835365473
      && CMFormatDescriptionGetMediaSubType(desc) == 1835360888)
    {
      FigThreadRunOnce(&sRegisterFigBoxedMetadataTypeOnce, (void (*)(void))registerFigBoxedMetadataType);
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v8 = Instance;
        uint64_t v9 = CMBlockBufferCreateEmpty(a2, 0, 1u, &blockBufferOut);
        CMBlockBufferRef v10 = blockBufferOut;
        if (!v9)
        {
          uint64_t v9 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, v8 + 144);
          CMBlockBufferRef v10 = blockBufferOut;
          if (!v9)
          {
            *(void *)(v8 + 16) = blockBufferOut;
            if (v10) {
              CFRetain(v10);
            }
            *(void *)(v8 + 24) = desc;
            CFRetain(desc);
            uint64_t v9 = 0;
            *(unsigned char *)(v8 + 216) = 1;
            *(void *)(v8 + 20CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = -1;
            *a4 = v8;
            CMBlockBufferRef v10 = blockBufferOut;
            uint64_t v8 = 0;
          }
        }
        if (v10) {
          CFRelease(v10);
        }
        if (v8) {
          CFRelease((CFTypeRef)v8);
        }
        return v9;
      }
      uint64_t v12 = 4294950974;
    }
    else
    {
      uint64_t v12 = 4294950976;
    }
  }
  else
  {
    uint64_t v12 = 4294950976;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBoxedMetadataGetBlockBuffer(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 216)) {
      return 0;
    }
    else {
      return *(void *)(result + 16);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataGetFormatDescription(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t FigBoxedMetadataIsUnderConstruction(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 216);
  }
  return result;
}

uint64_t FigBoxedMetadataGetNumberOfItems(uint64_t result)
{
  if (result)
  {
    CFNumberRef v1 = (void *)result;
    if (*(unsigned char *)(result + 216))
    {
      return 0;
    }
    else
    {
      uint64_t result = *(void *)(result + 200);
      if (result == -1)
      {
        while (1)
        {
          Atouint64_t m = FigAtomStreamAdvanceToNextAtom(v1 + 4);
          if (Atom) {
            break;
          }
          ++v1[26];
        }
        if (Atom == -12890) {
          uint64_t result = v1[26] + 1;
        }
        else {
          uint64_t result = 0;
        }
        v1[25] = result;
      }
    }
  }
  return result;
}

uint64_t FigBoxedMetadataGetSizeOfItemAtIndex(uint64_t result, uint64_t a2)
{
  uint64_t v3 = 0;
  if (result)
  {
    uint64_t v2 = result;
    if (*(unsigned char *)(result + 216) || goToIndex(result, a2))
    {
      return 0;
    }
    else
    {
      FigAtomStreamGetCurrentAtomTypeAndDataLength(v2 + 32, 0, &v3);
      return v3;
    }
  }
  return result;
}

uint64_t goToIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2 == a2) {
    return 0;
  }
  if (v2 <= a2)
  {
LABEL_5:
    if (v2 != a2)
    {
      while (!FigAtomStreamAdvanceToNextAtom((void *)(a1 + 32)))
      {
        uint64_t v5 = *(void *)(a1 + 208) + 1;
        *(void *)(a1 + 208) = v5;
        if (v5 == a2) {
          return 0;
        }
      }
      return 4294950973;
    }
    return 0;
  }
  if (!FigAtomStreamInitWithBBuf(*(OpaqueCMBlockBuffer **)(a1 + 16), 0, 1, a1 + 32))
  {
    uint64_t v2 = 0;
    *(void *)(a1 + 208) = 0;
    goto LABEL_5;
  }
  return 4294950973;
}

uint64_t FigBoxedMetadataGetLocalIDOfItemAtIndex(uint64_t result, uint64_t a2)
{
  unsigned int v3 = 0;
  if (result)
  {
    uint64_t v2 = result;
    if (*(unsigned char *)(result + 216) || goToIndex(result, a2))
    {
      return 0;
    }
    else
    {
      FigAtomStreamGetCurrentAtomTypeAndDataLength(v2 + 32, &v3, 0);
      return v3;
    }
  }
  return result;
}

uint64_t FigBoxedMetadataCreateBlockBufferForIndex(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CMBlockBufferRef *a4)
{
  if (a4)
  {
    *a4 = 0;
    if (a2)
    {
      if (*(unsigned char *)(a2 + 216))
      {
        uint64_t v9 = 4294950971;
      }
      else
      {
        if ((a3 & 0x8000000000000000) == 0 && FigBoxedMetadataGetNumberOfItems(a2) > a3)
        {
          uint64_t result = goToIndex(a2, a3);
          if (!result)
          {
            uint64_t v11 = 0;
            uint64_t v12 = 0;
            dataPointerOut = 0;
            uint64_t result = FigAtomStreamGetCurrentAtomDataGlobalOffset(a2 + 32, 0, &v12);
            if (!result)
            {
              if (v12 <= 7)
              {
                return FigSignalErrorAt(4294950973, 0, 0, 0, 0, 0, 0);
              }
              else
              {
                uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a2 + 32, 0, &v11);
                if (!result)
                {
                  uint64_t result = CMBlockBufferCreateWithMemoryBlock(a1, 0, v11 + 8, a1, 0, 0, v11 + 8, 1u, a4);
                  if (!result)
                  {
                    uint64_t result = CMBlockBufferGetDataPointer(*a4, 0, 0, 0, &dataPointerOut);
                    if (!result) {
                      return CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 16), v12 - 8, v11 + 8, dataPointerOut);
                    }
                  }
                }
              }
            }
          }
          return result;
        }
        uint64_t v9 = 4294950973;
      }
    }
    else
    {
      uint64_t v9 = 4294950976;
    }
  }
  else
  {
    uint64_t v9 = 4294950976;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int8x16_t *a5)
{
  uint64_t v5 = a5;
  char v19 = 0;
  if (a4) {
    *a4 = 0;
  }
  if (!a1) {
    goto LABEL_40;
  }
  if (a2 < 0)
  {
    uint64_t v18 = 4294950973;
    goto LABEL_44;
  }
  if (!a3 || !a5)
  {
LABEL_40:
    uint64_t v18 = 4294950976;
LABEL_44:
    LODWORD(result) = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_45:
    BOOL v14 = 0;
    goto LABEL_34;
  }
  if (*(unsigned char *)(a1 + 216))
  {
    uint64_t v18 = 4294950971;
    goto LABEL_44;
  }
  LODWORD(result) = goToIndex(a1, a2);
  if (result) {
    goto LABEL_45;
  }
  unsigned int v21 = 0;
  uint64_t v20 = 0;
  uint64_t v10 = a1 + 32;
  LODWORD(result) = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1 + 32, &v21, &v20);
  if (result) {
    goto LABEL_45;
  }
  int QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), v21);
  uint64_t v12 = v20;
  unint64_t WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, v20, &v19);
  if (WellKnownTypeDataSize)
  {
    if (WellKnownTypeDataSize == a3)
    {
      BOOL v14 = 0;
      goto LABEL_14;
    }
    uint64_t v18 = 4294950969;
    goto LABEL_44;
  }
  BOOL v14 = v12 > a3;
LABEL_14:
  LODWORD(result) = FigAtomStreamReadCurrentAtomData(v10, 0, a3, (uint64_t)v5);
  if (!result)
  {
    if (a4) {
      *a4 = a3;
    }
    if (v19)
    {
      LODWORD(result) = -16328;
      if (QuickTimeWellKnownTypeForLocalID <= 65)
      {
        switch(QuickTimeWellKnownTypeForLocalID)
        {
          case 23:
LABEL_27:
            LODWORD(result) = 0;
            v5->i32[0] = bswap32(v5->i32[0]);
            break;
          case 24:
LABEL_28:
            LODWORD(result) = 0;
            v5->i64[0] = bswap64(v5->i64[0]);
            break;
          case 30:
LABEL_26:
            LODWORD(result) = 0;
            int8x16_t *v5 = vrev32q_s8(*v5);
            break;
        }
      }
      else
      {
        switch(QuickTimeWellKnownTypeForLocalID)
        {
          case 'B':
          case 'L':
            LODWORD(result) = 0;
            v5->i16[0] = bswap32(v5->u16[0]) >> 16;
            break;
          case 'C':
          case 'M':
            goto LABEL_27;
          case 'F':
          case 'G':
            LODWORD(result) = 0;
            *(int8x8_t *)v5->i8 = vrev32_s8(*(int8x8_t *)v5->i8);
            break;
          case 'H':
            goto LABEL_26;
          case 'J':
          case 'N':
            goto LABEL_28;
          case 'O':
          case 'S':
            uint64_t v15 = 0;
            do
            {
              v5->i64[v15] = bswap64(v5->u64[v15]);
              ++v15;
            }
            while ((v15 * 8) != 72);
            goto LABEL_33;
          case 'P':
          case 'Q':
            unint64_t v16 = (unint64_t)(int)a3 >> 2;
            if ((int)v16 >= 1)
            {
              do
              {
                v5->i32[0] = bswap32(v5->i32[0]);
                uint64_t v5 = (int8x16_t *)((char *)v5 + 4);
                LODWORD(v16) = v16 - 1;
              }
              while (v16);
            }
            goto LABEL_33;
          default:
            break;
        }
      }
    }
    else
    {
LABEL_33:
      LODWORD(result) = 0;
    }
  }
LABEL_34:
  if (result) {
    BOOL v17 = 1;
  }
  else {
    BOOL v17 = !v14;
  }
  if (v17) {
    return result;
  }
  else {
    return 4294950972;
  }
}

unint64_t getWellKnownTypeDataSize(int a1, uint64_t a2, unsigned char *a3)
{
  if (a1 <= 64)
  {
    switch(a1)
    {
      case 23:
LABEL_9:
        *a3 = 1;
        return 4;
      case 24:
LABEL_8:
        *a3 = 1;
        return 8;
      case 30:
LABEL_7:
        *a3 = 1;
        return 16;
      default:
        return 0;
    }
  }
  else
  {
    int v3 = a1 - 65;
    unint64_t result = 1;
    switch(v3)
    {
      case 0:
      case 10:
        return result;
      case 1:
      case 11:
        *a3 = 1;
        unint64_t result = 2;
        break;
      case 2:
      case 12:
        goto LABEL_9;
      case 5:
      case 6:
      case 9:
      case 13:
        goto LABEL_8;
      case 7:
        goto LABEL_7;
      case 14:
      case 18:
        *a3 = 1;
        unint64_t result = 72;
        break;
      case 15:
        *a3 = 1;
        if ((a2 & 0xFFFFFFFFFFFFFFF8) < 0x18) {
          unint64_t result = -1;
        }
        else {
          unint64_t result = a2 & 0xFFFFFFFFFFFFFFF8;
        }
        break;
      case 16:
        *a3 = 1;
        if ((a2 & 0xFFFFFFFFFFFFFFF0) != 0) {
          unint64_t result = a2 & 0xFFFFFFFFFFFFFFF8;
        }
        else {
          unint64_t result = -1;
        }
        break;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t FigBoxedMetadataCopyValueOfItemAtIndexAsCFType(const __CFAllocator *a1, uint64_t a2, uint64_t a3, __CFArray **a4)
{
  v58[15] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  unsigned int v57 = 0;
  CFIndex length = 0;
  char v55 = 0;
  CMBlockBufferRef theBuffer = 0;
  if (!a4)
  {
    uint64_t v42 = FigSignalErrorAt(4294950976, 0, 0, 0, 0, 0, 0);
    uint64_t v5 = 0;
    goto LABEL_94;
  }
  uint64_t v5 = (CMBlockBufferRef *)a2;
  *a4 = 0;
  if (!a2)
  {
    uint64_t CurrentAtomData = FigSignalErrorAt(4294950976, 0, 0, 0, 0, 0, 0);
LABEL_97:
    uint64_t v42 = CurrentAtomData;
    goto LABEL_89;
  }
  if (*(unsigned char *)(a2 + 216))
  {
    uint64_t v49 = 4294950971;
LABEL_102:
    CurrentAtomTypeAndsize_t DataLength = FigSignalErrorAt(v49, 0, 0, 0, 0, 0, 0);
    goto LABEL_103;
  }
  CurrentAtomTypeAndsize_t DataLength = goToIndex(a2, a3);
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_103;
  }
  uint64_t v8 = (uint64_t)(v5 + 4);
  CurrentAtomTypeAndsize_t DataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)(v5 + 4), &v57, &length);
  if (CurrentAtomTypeAndDataLength) {
    goto LABEL_103;
  }
  int QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(v5[3], v57);
  CFIndex v10 = length;
  unint64_t WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, length, &v55);
  if (WellKnownTypeDataSize && v10 != WellKnownTypeDataSize)
  {
    uint64_t v49 = 4294950969;
    goto LABEL_102;
  }
  if (QuickTimeWellKnownTypeForLocalID > 23)
  {
    switch(QuickTimeWellKnownTypeForLocalID)
    {
      case 'A':
        v58[0].i8[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 1, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        SInt8 = FigCFNumberCreateSInt8((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v58[0].i8[0]);
        goto LABEL_84;
      case 'B':
        v58[0].i16[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 2, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        v58[0].i16[0] = bswap32(v58[0].u16[0]) >> 16;
        SInt8 = FigCFNumberCreateSInt16((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v58[0].i16[0]);
        goto LABEL_84;
      case 'C':
        v58[0].i32[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 4, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        v58[0].i32[0] = bswap32(v58[0].u32[0]);
        SInt8 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v58[0].i32[0]);
        goto LABEL_84;
      case 'D':
      case 'E':
        memset(v58, 0, 112);
        memset(valuePtr, 0, sizeof(valuePtr));
        dataCFIndex Length = 0;
        size_t v52 = 0;
        dataPointerOut = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamInitWithParent((uint64_t)(v5 + 4), 0, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        int v12 = QuickTimeWellKnownTypeForLocalID == 68 ? 1667330681 : 1668441443;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamPositionAtFirstAtomWithType((uint64_t)v58, v12);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamInitWithParent((uint64_t)v58, 0, (uint64_t)valuePtr);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamPositionAtFirstAtomWithType((uint64_t)valuePtr, 1667855475);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamGetCurrentAtomDataGlobalOffset((uint64_t)valuePtr, 0, &v52);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)valuePtr, 0, &dataLength);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = CMBlockBufferCreateWithMemoryBlock(a1, 0, dataLength, a1, 0, 0, dataLength, 1u, &theBuffer);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = CMBlockBufferCopyDataBytes(v5[2], v52, dataLength, dataPointerOut);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CurrentAtomTypeAndsize_t DataLength = FigBoxedMetadataCreateFromBlockBuffer((int)a1, theBuffer, v5[3], a4);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CFRange v13 = 0;
        uint64_t v5 = 0;
        BOOL v14 = *a4;
        goto LABEL_86;
      case 'F':
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CGPoint v43 = (CGPoint)vcvtq_f64_f32((float32x2_t)vrev32_s8(v58[0]));
        CGFloat y = v43.y;
        SInt8 = CGPointCreateDictionaryRepresentation(v43);
        goto LABEL_84;
      case 'G':
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CGSize v45 = (CGSize)vcvtq_f64_f32((float32x2_t)vrev32_s8(v58[0]));
        CGFloat height = v45.height;
        SInt8 = CGSizeCreateDictionaryRepresentation(v45);
        goto LABEL_84;
      case 'H':
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 16, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        v59.origin.x = COERCE_FLOAT(bswap32(v58[0].u32[0]));
        v59.origin.CGFloat y = COERCE_FLOAT(bswap32(v58[0].u32[1]));
        v59.size.double width = COERCE_FLOAT(bswap32(v58[1].u32[0]));
        v59.size.CGFloat height = COERCE_FLOAT(bswap32(v58[1].u32[1]));
        SInt8 = CGRectCreateDictionaryRepresentation(v59);
        goto LABEL_84;
      case 'I':
      case 'R':
        goto LABEL_57;
      case 'J':
        v58[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        v58[0] = (int8x8_t)bswap64(*(void *)v58);
        SInt8 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)v58);
        goto LABEL_84;
      case 'K':
        v58[0].i8[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 1, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        SInt8 = FigCFNumberCreateUInt8((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v58[0].u8[0]);
        goto LABEL_84;
      case 'L':
        v58[0].i16[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 2, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        unsigned int v47 = bswap32(v58[0].u16[0]);
        v58[0].i16[0] = HIWORD(v47);
        SInt8 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E4F1CF80], HIWORD(v47));
        goto LABEL_84;
      case 'M':
        v58[0].i32[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 4, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        v58[0].i32[0] = bswap32(v58[0].u32[0]);
        SInt8 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v58[0].u32[0]);
        goto LABEL_84;
      case 'N':
        v58[0] = 0;
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        v58[0] = (int8x8_t)bswap64(*(void *)v58);
        SInt8 = FigCFNumberCreateUInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)v58);
        goto LABEL_84;
      case 'O':
      case 'S':
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 72, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 9, MEMORY[0x1E4F1D510]);
        if (!Mutable) {
          goto LABEL_110;
        }
        BOOL v14 = Mutable;
        uint64_t v29 = 0;
        CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        do
        {
          *(void *)&valuePtr[0] = bswap64(*(void *)&v58[v29]);
          CFNumberRef v31 = CFNumberCreate(v30, kCFNumberFloat64Type, valuePtr);
          CFArrayAppendValue(v14, v31);
          CFRelease(v31);
          ++v29;
        }
        while (v29 != 9);
        goto LABEL_47;
      case 'P':
      case 'Q':
        uint64_t v5 = (CMBlockBufferRef *)malloc_type_malloc(v10, 0xACE648F5uLL);
        if (!v5) {
          goto LABEL_106;
        }
        uint64_t CurrentAtomData = FigAtomStreamReadCurrentAtomData(v8, 0, length, (uint64_t)v5);
        if (CurrentAtomData) {
          goto LABEL_97;
        }
        unint64_t v33 = (unint64_t)(int)v10 >> 3;
        BOOL v14 = CFArrayCreateMutable(a1, (int)v33, MEMORY[0x1E4F1D510]);
        if (!v14) {
          goto LABEL_107;
        }
        if ((int)v33 < 1) {
          goto LABEL_55;
        }
        uint64_t v34 = 0;
        break;
      default:
        if (QuickTimeWellKnownTypeForLocalID == 24)
        {
          v58[0] = 0;
          CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
          if (CurrentAtomTypeAndDataLength) {
            goto LABEL_103;
          }
          v58[0] = (int8x8_t)bswap64(*(void *)v58);
          SInt8 = FigCFNumberCreateFloat64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(double *)v58);
          goto LABEL_84;
        }
        if (QuickTimeWellKnownTypeForLocalID != 30) {
          goto LABEL_57;
        }
        CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 16, (uint64_t)v58);
        if (CurrentAtomTypeAndDataLength) {
          goto LABEL_103;
        }
        CFMutableArrayRef v24 = CFArrayCreateMutable(a1, 4, MEMORY[0x1E4F1D510]);
        if (!v24)
        {
LABEL_110:
          uint64_t v42 = 4294950974;
          goto LABEL_104;
        }
        BOOL v14 = v24;
        uint64_t v25 = 0;
        CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        do
        {
          LODWORD(valuePtr[0]) = bswap32(v58[0].u32[v25]);
          CFNumberRef v27 = CFNumberCreate(v26, kCFNumberSInt32Type, valuePtr);
          CFArrayAppendValue(v14, v27);
          CFRelease(v27);
          ++v25;
        }
        while (v25 != 4);
LABEL_47:
        CFRange v13 = 0;
        uint64_t v5 = 0;
        goto LABEL_56;
    }
    while (1)
    {
      CGPoint v35 = (CGPoint)vcvtq_f64_f32((float32x2_t)vrev32_s8((int8x8_t)v5[v34]));
      CGFloat v36 = v35.y;
      DictionaryRepresentatiouint64_t n = CGPointCreateDictionaryRepresentation(v35);
      if (!DictionaryRepresentation) {
        goto LABEL_107;
      }
      CFDictionaryRef v38 = DictionaryRepresentation;
      CFArrayAppendValue(v14, DictionaryRepresentation);
      CFRelease(v38);
      if (v33 == ++v34)
      {
LABEL_55:
        CFRange v13 = 0;
LABEL_56:
        *a4 = v14;
        goto LABEL_86;
      }
    }
  }
  if ((QuickTimeWellKnownTypeForLocalID - 1) < 2
    || (QuickTimeWellKnownTypeForLocalID - 4) < 2)
  {
    uint64_t v15 = CFDataCreateMutable(a1, v10);
    if (v15)
    {
      CFRange v13 = v15;
      CFDataSetLength(v15, length);
      CFIndex v16 = length;
      MutableBytePtr = CFDataGetMutableBytePtr(v13);
      uint64_t v18 = FigAtomStreamReadCurrentAtomData(v8, 0, v16, (uint64_t)MutableBytePtr);
      if (!v18)
      {
        if (QuickTimeWellKnownTypeForLocalID == 4 || QuickTimeWellKnownTypeForLocalID == 1)
        {
          BytePtr = CFDataGetBytePtr(v13);
          CFIndex v20 = length;
          CFAllocatorRef v21 = a1;
          CFStringEncoding v22 = 134217984;
        }
        else
        {
          BytePtr = CFDataGetBytePtr(v13);
          CFIndex v20 = length;
          CFAllocatorRef v21 = a1;
          CFStringEncoding v22 = 268435712;
        }
        SInt8 = (__CFArray *)CFStringCreateWithBytes(v21, BytePtr, v20, v22, 0);
        BOOL v14 = SInt8;
LABEL_85:
        uint64_t v5 = 0;
        *a4 = SInt8;
LABEL_86:
        if (v14)
        {
          uint64_t v42 = 0;
          if (!v13)
          {
LABEL_89:
            BOOL v14 = 0;
            goto LABEL_90;
          }
        }
        else
        {
          uint64_t v42 = FigSignalErrorAt(4294950974, 0, 0, 0, 0, 0, 0);
          if (!v13) {
            goto LABEL_89;
          }
        }
LABEL_88:
        CFRelease(v13);
        goto LABEL_89;
      }
      uint64_t v42 = v18;
LABEL_109:
      uint64_t v5 = 0;
      goto LABEL_88;
    }
LABEL_105:
    uint64_t v5 = 0;
LABEL_106:
    BOOL v14 = 0;
LABEL_107:
    uint64_t v42 = 4294950974;
    goto LABEL_90;
  }
  if (QuickTimeWellKnownTypeForLocalID == 23)
  {
    v58[0].i32[0] = 0;
    CurrentAtomTypeAndsize_t DataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 4, (uint64_t)v58);
    if (!CurrentAtomTypeAndDataLength)
    {
      v58[0].i32[0] = bswap32(v58[0].u32[0]);
      SInt8 = FigCFNumberCreateFloat32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(float *)v58[0].i32);
LABEL_84:
      BOOL v14 = SInt8;
      CFRange v13 = 0;
      goto LABEL_85;
    }
LABEL_103:
    uint64_t v42 = CurrentAtomTypeAndDataLength;
LABEL_104:
    uint64_t v5 = 0;
    goto LABEL_89;
  }
LABEL_57:
  CFDataRef v39 = CFDataCreateMutable(a1, v10);
  if (!v39) {
    goto LABEL_105;
  }
  CFRange v13 = v39;
  CFDataSetLength(v39, length);
  CFIndex v40 = length;
  CFMutableDictionaryRef v41 = CFDataGetMutableBytePtr(v13);
  uint64_t v42 = FigAtomStreamReadCurrentAtomData(v8, 0, v40, (uint64_t)v41);
  if (v42) {
    goto LABEL_109;
  }
  uint64_t v5 = 0;
  BOOL v14 = 0;
  *a4 = v13;
LABEL_90:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  if (v14) {
    CFRelease(v14);
  }
LABEL_94:
  free(v5);
  return v42;
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsSInt8(uint64_t a1, uint64_t a2)
{
  return (char)getValueOfItemAtIndexAsSInt64(a1, a2);
}

unint64_t getValueOfItemAtIndexAsSInt64(uint64_t a1, uint64_t a2)
{
  unint64_t v14 = 0;
  int v13 = 0;
  if (scalarReadSetup(a1, a2, &v13)) {
    return 0;
  }
  unint64_t result = 0;
  switch(v13)
  {
    case 'A':
      LOBYTE(v12) = 0;
      int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 1, (uint64_t)&v12);
      uint64_t v5 = (char)v12;
      goto LABEL_21;
    case 'B':
      LOWORD(v12) = 0;
      int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 2, (uint64_t)&v12);
      uint64_t v5 = (__int16)(bswap32((unsigned __int16)v12) >> 16);
      goto LABEL_21;
    case 'C':
      LODWORD(v12) = 0;
      int v6 = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v12);
      signed int v7 = bswap32(v12);
      if (v6) {
        return 0;
      }
      return v7;
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
      return result;
    case 'J':
      int v8 = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v14);
      unint64_t v9 = bswap64(v14);
      if (v8) {
        return v14;
      }
      else {
        return v9;
      }
    case 'K':
      LOBYTE(v12) = 0;
      int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 1, (uint64_t)&v12);
      uint64_t v5 = v12;
      goto LABEL_21;
    case 'L':
      LOWORD(v12) = 0;
      int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 2, (uint64_t)&v12);
      uint64_t v5 = bswap32((unsigned __int16)v12) >> 16;
      goto LABEL_21;
    case 'M':
      LODWORD(v12) = 0;
      int v10 = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v12);
      unsigned int v11 = bswap32(v12);
      if (v10) {
        return 0;
      }
      else {
        return v11;
      }
    case 'N':
      unint64_t v12 = 0;
      int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v12);
      uint64_t v5 = bswap64(v12);
      goto LABEL_21;
    default:
      if (v13 == 23)
      {
        LODWORD(v12) = 0;
        int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v12);
        uint64_t v5 = (uint64_t)COERCE_FLOAT(bswap32(v12));
      }
      else
      {
        if (v13 != 24) {
          return result;
        }
        unint64_t v12 = 0;
        int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v12);
        uint64_t v5 = (uint64_t)COERCE_DOUBLE(bswap64(v12));
      }
LABEL_21:
      if (CurrentAtomData) {
        unint64_t result = 0;
      }
      else {
        unint64_t result = v5;
      }
      break;
  }
  return result;
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsUInt8(uint64_t a1, uint64_t a2)
{
  return getValueOfItemAtIndexAsSInt64(a1, a2);
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsSInt16(uint64_t a1, uint64_t a2)
{
  return (__int16)getValueOfItemAtIndexAsSInt64(a1, a2);
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsUInt16(uint64_t a1, uint64_t a2)
{
  return (unsigned __int16)getValueOfItemAtIndexAsSInt64(a1, a2);
}

unint64_t FigBoxedMetadataGetValueOfItemAtIndexAsSInt32(uint64_t a1, uint64_t a2)
{
  return getValueOfItemAtIndexAsSInt64(a1, a2);
}

unint64_t FigBoxedMetadataGetValueOfItemAtIndexAsUInt32(uint64_t a1, uint64_t a2)
{
  return getValueOfItemAtIndexAsSInt64(a1, a2);
}

float FigBoxedMetadataGetValueOfItemAtIndexAsFloat32(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  int Setup = scalarReadSetup(a1, a2, (int *)&v9);
  float result = 0.0;
  if (!Setup)
  {
    uint64_t v6 = (v9 - 23);
    if (v6 <= 0x37)
    {
      if (((1 << (v9 - 23)) & 0xF81C0000000000) != 0)
      {
        return (float)(uint64_t)getValueOfItemAtIndexAsSInt64(a1, a2);
      }
      else if (v9 == 23)
      {
        if (FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v9 + 4)) {
          return *((float *)&v9 + 1);
        }
        else {
          return COERCE_FLOAT(bswap32(HIDWORD(v9)));
        }
      }
      else if (v6 == 1)
      {
        unint64_t v8 = 0;
        int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v8);
        float result = COERCE_DOUBLE(bswap64(v8));
        if (CurrentAtomData) {
          return 0.0;
        }
      }
    }
  }
  return result;
}

uint64_t scalarReadSetup(uint64_t a1, uint64_t a2, int *a3)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 216))
    {
      uint64_t result = goToIndex(a1, a2);
      if (!result)
      {
        unsigned int v11 = 0;
        uint64_t v10 = 0;
        uint64_t result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1 + 32, &v11, &v10);
        if (!result)
        {
          int QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), v11);
          *a3 = QuickTimeWellKnownTypeForLocalID;
          uint64_t v7 = v10;
          if (v7 == getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, v10, &v9)) {
            return 0;
          }
          else {
            return FigSignalErrorAt(4294950969, 0, 0, 0, 0, 0, 0);
          }
        }
      }
      return result;
    }
    uint64_t v8 = 4294950971;
  }
  else
  {
    uint64_t v8 = 4294950976;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

double FigBoxedMetadataGetValueOfItemAtIndexAsFloat64(uint64_t a1, uint64_t a2)
{
  double v10 = 0.0;
  int v9 = 0;
  int v4 = scalarReadSetup(a1, a2, &v9);
  double result = 0.0;
  if (!v4)
  {
    uint64_t v6 = (v9 - 23);
    if (v6 <= 0x37)
    {
      if (((1 << (v9 - 23)) & 0xF81C0000000000) != 0)
      {
        return (double)(uint64_t)getValueOfItemAtIndexAsSInt64(a1, a2);
      }
      else if (v9 == 23)
      {
        unsigned int v8 = 0;
        int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v8);
        double result = COERCE_FLOAT(bswap32(v8));
        if (CurrentAtomData) {
          return 0.0;
        }
      }
      else if (v6 == 1)
      {
        if (FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v10)) {
          return v10;
        }
        else {
          return COERCE_DOUBLE(bswap64(*(unint64_t *)&v10));
        }
      }
    }
  }
  return result;
}

float64x2_t FigBoxedMetadataGetValueOfItemAtIndexAsCGPoint(uint64_t a1, uint64_t a2)
{
  v7[1] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  int v6 = 0;
  int v3 = scalarReadSetup(a1, a2, &v6);
  float64x2_t result = 0uLL;
  if (!v3 && v6 == 70)
  {
    int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)v7);
    float64x2_t result = 0uLL;
    if (!CurrentAtomData) {
      return vcvtq_f64_f32((float32x2_t)vrev32_s8(v7[0]));
    }
  }
  return result;
}

float64x2_t FigBoxedMetadataGetValueOfItemAtIndexAsCGSize(uint64_t a1, uint64_t a2)
{
  v7[1] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  int v6 = 0;
  int v3 = scalarReadSetup(a1, a2, &v6);
  float64x2_t result = 0uLL;
  if (!v3 && v6 == 71)
  {
    int CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)v7);
    float64x2_t result = 0uLL;
    if (!CurrentAtomData) {
      return vcvtq_f64_f32((float32x2_t)vrev32_s8(v7[0]));
    }
  }
  return result;
}

float64x2_t FigBoxedMetadataGetValueOfItemAtIndexAsCGRect(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v5 = 0;
  int v3 = scalarReadSetup(a1, a2, &v5);
  float64x2_t result = 0uLL;
  if (!v3 && v5 == 72)
  {
    if (FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 16, (uint64_t)&v6)) {
      return (float64x2_t)0;
    }
    else {
      return vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vrev32q_s8(v6));
    }
  }
  return result;
}

int8x16_t FigBoxedMetadataGetValueOfItemAtIndexAsCGAffineTransform@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  int v7 = 0;
  if (!scalarReadSetup(a1, a2, &v7)
    && v7 == 79
    && !FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 72, (uint64_t)v8))
  {
    int8x16_t v6 = vrev64q_s8(*(int8x16_t *)((char *)&v8[1] + 8));
    *a3 = vrev64q_s8(v8[0]);
    a3[1] = v6;
    int8x16_t result = vrev64q_s8(v8[3]);
    a3[2] = result;
  }
  return result;
}

uint64_t FigBoxedMetadataEndConstruction(uint64_t a1)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 216))
    {
      *(unsigned char *)(a1 + 216) = 0;
      if (CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a1 + 16))
        || !FigAtomWriterBeginAtom(a1 + 144, 0, 0) && !FigAtomWriterEndAtom(a1 + 144))
      {
        FigAtomStreamInitWithBBuf(*(OpaqueCMBlockBuffer **)(a1 + 16), 0, 1, a1 + 32);
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294950976, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigBoxedMetadataAppendValue(uint64_t a1, unsigned int a2, uint64_t a3, int8x16_t *a4)
{
  char v22 = 0;
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  if (!a1 || !a2 || a3 <= 0 || (int8x16_t v6 = a4) == 0)
  {
    uint64_t v19 = 4294950976;
LABEL_35:
    uint64_t v11 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    double v10 = 0;
    goto LABEL_28;
  }
  if (!*(unsigned char *)(a1 + 216))
  {
    uint64_t v19 = 4294950970;
    goto LABEL_35;
  }
  int QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), a2);
  unint64_t WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, a3, &v22);
  if (!WellKnownTypeDataSize)
  {
LABEL_14:
    double v10 = 0;
    goto LABEL_24;
  }
  if (WellKnownTypeDataSize != a3)
  {
    uint64_t v19 = 4294950969;
    goto LABEL_35;
  }
  if (!v22) {
    goto LABEL_14;
  }
  double v10 = 0;
  uint64_t v11 = 4294950968;
  if (QuickTimeWellKnownTypeForLocalID <= 65)
  {
    switch(QuickTimeWellKnownTypeForLocalID)
    {
      case 23:
LABEL_19:
        double v10 = 0;
        LODWORD(v20[0]) = bswap32(v6->i32[0]);
        break;
      case 24:
LABEL_20:
        double v10 = 0;
        *(void *)&v20[0] = bswap64(v6->i64[0]);
        break;
      case 30:
LABEL_18:
        double v10 = 0;
        v20[0] = vrev32q_s8(*v6);
        break;
      default:
        goto LABEL_28;
    }
LABEL_23:
    int8x16_t v6 = (int8x16_t *)v20;
  }
  else
  {
    switch(QuickTimeWellKnownTypeForLocalID)
    {
      case 'B':
      case 'L':
        double v10 = 0;
        LOWORD(v20[0]) = bswap32(v6->u16[0]) >> 16;
        goto LABEL_23;
      case 'C':
      case 'M':
        goto LABEL_19;
      case 'F':
      case 'G':
        double v10 = 0;
        *(int8x8_t *)&v20[0] = vrev32_s8(*(int8x8_t *)v6->i8);
        goto LABEL_23;
      case 'H':
        goto LABEL_18;
      case 'J':
      case 'N':
        goto LABEL_20;
      case 'O':
      case 'S':
        for (uint64_t i = 0; i != 9; ++i)
          *(void *)((char *)v20 + i * 8) = bswap64(v6->u64[i]);
        double v10 = 0;
        goto LABEL_23;
      case 'P':
      case 'Q':
        CFIndex v16 = (int8x16_t *)malloc_type_malloc(a3, 0xAA4FA245uLL);
        double v10 = v16;
        if (!v16)
        {
          uint64_t v11 = 4294950974;
          goto LABEL_28;
        }
        unint64_t v17 = (unint64_t)(int)a3 >> 2;
        if ((int)v17 >= 1)
        {
          uint64_t v18 = 0;
          do
          {
            v16->i32[v18] = bswap32(v6->u32[v18]);
            ++v18;
          }
          while (v17 != v18);
        }
        int8x16_t v6 = v16;
        break;
      default:
        goto LABEL_28;
    }
  }
LABEL_24:
  uint64_t v13 = a1 + 144;
  uint64_t appended = FigAtomWriterBeginAtom(v13, a2, 0);
  if (!appended)
  {
    uint64_t appended = FigAtomWriterAppendData(v13, (uint64_t)v6, a3);
    if (!appended) {
      uint64_t appended = FigAtomWriterEndAtom(v13);
    }
  }
  uint64_t v11 = appended;
LABEL_28:
  free(v10);
  return v11;
}

uint64_t FigBoxedMetadataAppendCFTypedValue(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v66 = 0;
  memset(valuePtr, 0, sizeof(valuePtr));
  if (!a1 || !a2 || !a3)
  {
    uint64_t v59 = 4294950976;
    goto LABEL_102;
  }
  if (!*(unsigned char *)(a1 + 216))
  {
    uint64_t v59 = 4294950970;
    goto LABEL_102;
  }
  int QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), a2);
  int v7 = QuickTimeWellKnownTypeForLocalID;
  if (QuickTimeWellKnownTypeForLocalID <= 23)
  {
    if ((QuickTimeWellKnownTypeForLocalID - 1) >= 2
      && (QuickTimeWellKnownTypeForLocalID - 4) >= 2)
    {
      if (QuickTimeWellKnownTypeForLocalID == 23)
      {
        CFTypeID TypeID = CFNumberGetTypeID();
        if (TypeID == CFGetTypeID((CFTypeRef)a3))
        {
          BytePtr = (const UInt8 *)valuePtr;
          CFNumberRef v18 = (const __CFNumber *)a3;
          CFNumberType v19 = kCFNumberFloat32Type;
LABEL_35:
          CFNumberGetValue(v18, v19, valuePtr);
          CFDataRef v16 = 0;
          CFAllocatorRef v26 = 0;
          LODWORD(valuePtr[0]) = bswap32(valuePtr[0]);
          CFIndex Length = 4;
          goto LABEL_90;
        }
      }
      else
      {
LABEL_66:
        CFTypeID v47 = CFDataGetTypeID();
        if (v47 == CFGetTypeID((CFTypeRef)a3))
        {
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          CFIndex Length = CFDataGetLength((CFDataRef)a3);
LABEL_68:
          CFDataRef v16 = 0;
LABEL_69:
          CFAllocatorRef v26 = 0;
LABEL_90:
          if (BytePtr && Length)
          {
            uint64_t v56 = a1 + 144;
            uint64_t appended = FigAtomWriterBeginAtom(v56, a2, 0);
            if (!appended)
            {
              uint64_t appended = FigAtomWriterAppendData(v56, (uint64_t)BytePtr, Length);
              if (!appended) {
                uint64_t appended = FigAtomWriterEndAtom(v56);
              }
            }
          }
          else
          {
            uint64_t appended = FigSignalErrorAt(4294950974, 0, 0, 0, 0, 0, 0);
          }
          uint64_t v35 = appended;
          if (v16) {
            CFRelease(v16);
          }
          goto LABEL_97;
        }
      }
    }
    else
    {
      CFTypeID v11 = CFStringGetTypeID();
      if (v11 == CFGetTypeID((CFTypeRef)a3))
      {
        if (v7 == 1 || v7 == 4) {
          CFStringEncoding v13 = 134217984;
        }
        else {
          CFStringEncoding v13 = 268435712;
        }
        CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
        ExternalRepresentatiouint64_t n = CFStringCreateExternalRepresentation(v14, (CFStringRef)a3, v13, 0);
        if (!ExternalRepresentation)
        {
          CFAllocatorRef v26 = 0;
LABEL_105:
          uint64_t v35 = 4294950974;
          goto LABEL_97;
        }
        CFDataRef v16 = ExternalRepresentation;
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        CFIndex Length = CFDataGetLength(v16);
        goto LABEL_69;
      }
    }
LABEL_98:
    uint64_t v59 = 4294950968;
LABEL_102:
    uint64_t v34 = FigSignalErrorAt(v59, 0, 0, 0, 0, 0, 0);
LABEL_53:
    uint64_t v35 = v34;
    CFAllocatorRef v26 = 0;
    goto LABEL_97;
  }
  switch(QuickTimeWellKnownTypeForLocalID)
  {
    case 'A':
    case 'K':
      CFTypeID v8 = CFNumberGetTypeID();
      if (v8 != CFGetTypeID((CFTypeRef)a3)) {
        goto LABEL_98;
      }
      CFIndex Length = 1;
      BytePtr = (const UInt8 *)valuePtr;
      CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt8Type, valuePtr);
      goto LABEL_68;
    case 'B':
    case 'L':
      CFTypeID v25 = CFNumberGetTypeID();
      if (v25 != CFGetTypeID((CFTypeRef)a3)) {
        goto LABEL_98;
      }
      CFIndex Length = 2;
      BytePtr = (const UInt8 *)valuePtr;
      CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt16Type, valuePtr);
      CFDataRef v16 = 0;
      CFAllocatorRef v26 = 0;
      LOWORD(valuePtr[0]) = bswap32(LOWORD(valuePtr[0])) >> 16;
      goto LABEL_90;
    case 'C':
    case 'M':
      CFTypeID v27 = CFNumberGetTypeID();
      if (v27 != CFGetTypeID((CFTypeRef)a3)) {
        goto LABEL_98;
      }
      BytePtr = (const UInt8 *)valuePtr;
      CFNumberRef v18 = (const __CFNumber *)a3;
      CFNumberType v19 = kCFNumberSInt32Type;
      goto LABEL_35;
    case 'D':
    case 'E':
      uint64_t v64 = 0;
      long long v63 = 0u;
      memset(&point, 0, sizeof(point));
      uint64_t v61 = 0;
      memset(&v60[1], 0, 32);
      if (QuickTimeWellKnownTypeForLocalID == 68) {
        unsigned int v28 = 1667330681;
      }
      else {
        unsigned int v28 = 1668441443;
      }
      v60[0] = 0uLL;
      FigThreadRunOnce(&sRegisterFigBoxedMetadataTypeOnce, (void (*)(void))registerFigBoxedMetadataType);
      uint64_t v29 = sFigBoxedMetadataID;
      if (v29 != CFGetTypeID((CFTypeRef)a3)) {
        goto LABEL_98;
      }
      if (!FigCFEqual(*(CFTypeRef *)(a3 + 24), *(CFTypeRef *)(a1 + 24)))
      {
        uint64_t v59 = 4294950975;
        goto LABEL_102;
      }
      if (*(unsigned char *)(a3 + 216))
      {
        uint64_t v59 = 4294950971;
        goto LABEL_102;
      }
      CFAllocatorRef v30 = *(OpaqueCMBlockBuffer **)(a3 + 16);
      if (!v30 || (size_t DataLength = CMBlockBufferGetDataLength(v30)) == 0)
      {
        uint64_t v59 = 4294950969;
        goto LABEL_102;
      }
      size_t v32 = DataLength;
      uint64_t v33 = a1 + 144;
      uint64_t v34 = FigAtomWriterBeginAtom(v33, a2, 0);
      if (!v34)
      {
        uint64_t v34 = FigAtomWriterInitWithParent(v33, (uint64_t)&point);
        if (!v34)
        {
          uint64_t v34 = FigAtomWriterBeginAtom((uint64_t)&point, v28, 0);
          if (!v34)
          {
            uint64_t v34 = FigAtomWriterInitWithParent((uint64_t)&point, (uint64_t)v60);
            if (!v34)
            {
              uint64_t v34 = FigAtomWriterBeginAtom((uint64_t)v60, 0x63697473u, 0);
              if (!v34)
              {
                uint64_t v34 = FigAtomWriterAppendBlockBufferData((uint64_t)v60, v30, 0, v32);
                if (!v34)
                {
                  uint64_t v34 = FigAtomWriterEndAtom((uint64_t)v60);
                  if (!v34)
                  {
                    uint64_t v34 = FigAtomWriterEndAtom((uint64_t)&point);
                    if (!v34) {
                      uint64_t v34 = FigAtomWriterEndAtom(v33);
                    }
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_53;
    case 'F':
      point.origin.x = 0.0;
      point.origin.CGFloat y = 0.0;
      CFTypeID v48 = CFDictionaryGetTypeID();
      if (v48 != CFGetTypeID((CFTypeRef)a3)
        || !CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)a3, &point.origin))
      {
        goto LABEL_98;
      }
      goto LABEL_75;
    case 'G':
      point.origin.x = 0.0;
      point.origin.CGFloat y = 0.0;
      CFTypeID v49 = CFDictionaryGetTypeID();
      if (v49 != CFGetTypeID((CFTypeRef)a3)
        || !CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)a3, (CGSize *)&point))
      {
        goto LABEL_98;
      }
LABEL_75:
      CFDataRef v16 = 0;
      CFAllocatorRef v26 = 0;
      *(int8x8_t *)&valuePtr[0] = vrev32_s8((int8x8_t)vcvt_f32_f64((float64x2_t)point.origin));
      BytePtr = (const UInt8 *)valuePtr;
      goto LABEL_89;
    case 'H':
      memset(&point, 0, sizeof(point));
      CFTypeID v50 = CFDictionaryGetTypeID();
      if (v50 != CFGetTypeID((CFTypeRef)a3) || !CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)a3, &point)) {
        goto LABEL_98;
      }
      CFDataRef v16 = 0;
      CFAllocatorRef v26 = 0;
      valuePtr[0] = vrev32q_s8((int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)point.origin), (float64x2_t)point.size));
      BytePtr = (const UInt8 *)valuePtr;
      CFIndex Length = 16;
      goto LABEL_90;
    case 'I':
    case 'R':
      goto LABEL_66;
    case 'J':
    case 'N':
      CFTypeID v36 = CFNumberGetTypeID();
      if (v36 != CFGetTypeID((CFTypeRef)a3)) {
        goto LABEL_98;
      }
      BytePtr = (const UInt8 *)valuePtr;
      CFNumberRef v37 = (const __CFNumber *)a3;
      CFNumberType v38 = kCFNumberSInt64Type;
      goto LABEL_88;
    case 'O':
    case 'S':
      CFTypeID v39 = CFArrayGetTypeID();
      if (v39 != CFGetTypeID((CFTypeRef)a3) || CFArrayGetCount((CFArrayRef)a3) != 9) {
        goto LABEL_98;
      }
      CFIndex v40 = 0;
      CFMutableDictionaryRef v41 = valuePtr;
      CFIndex Length = 72;
      while (1)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, v40);
        CFTypeID v43 = CFNumberGetTypeID();
        if (v43 != CFGetTypeID(ValueAtIndex)) {
          goto LABEL_98;
        }
        CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberDoubleType, v41);
        void *v41 = bswap64(*v41);
        ++v41;
        if (++v40 == 9)
        {
LABEL_61:
          CFDataRef v16 = 0;
          CFAllocatorRef v26 = 0;
          BytePtr = (const UInt8 *)valuePtr;
          goto LABEL_90;
        }
      }
    case 'P':
    case 'Q':
      point.origin.x = 0.0;
      point.origin.CGFloat y = 0.0;
      CFTypeID v44 = CFArrayGetTypeID();
      if (v44 != CFGetTypeID((CFTypeRef)a3)) {
        goto LABEL_98;
      }
      int Count = CFArrayGetCount((CFArrayRef)a3);
      unsigned int v46 = Count;
      if (v7 == 80)
      {
        if (Count <= 2) {
          goto LABEL_98;
        }
      }
      else if (Count <= 1)
      {
        goto LABEL_98;
      }
      CFIndex Length = 8 * (Count & 0x7FFFFFFF);
      CFAllocatorRef v26 = (int8x8_t *)malloc_type_malloc(Length, 0xCEE59F88uLL);
      if (!v26) {
        goto LABEL_105;
      }
      CFIndex v51 = 0;
      uint64_t v52 = v46;
      break;
    default:
      if (QuickTimeWellKnownTypeForLocalID == 24)
      {
        CFTypeID v55 = CFNumberGetTypeID();
        if (v55 != CFGetTypeID((CFTypeRef)a3)) {
          goto LABEL_98;
        }
        BytePtr = (const UInt8 *)valuePtr;
        CFNumberRef v37 = (const __CFNumber *)a3;
        CFNumberType v38 = kCFNumberFloat64Type;
LABEL_88:
        CFNumberGetValue(v37, v38, valuePtr);
        CFDataRef v16 = 0;
        CFAllocatorRef v26 = 0;
        *(void *)&valuePtr[0] = bswap64(*(unint64_t *)&valuePtr[0]);
LABEL_89:
        CFIndex Length = 8;
        goto LABEL_90;
      }
      if (QuickTimeWellKnownTypeForLocalID != 30) {
        goto LABEL_66;
      }
      CFTypeID v20 = CFArrayGetTypeID();
      if (v20 != CFGetTypeID((CFTypeRef)a3) || CFArrayGetCount((CFArrayRef)a3) != 4) {
        goto LABEL_98;
      }
      CFIndex v21 = 0;
      char v22 = valuePtr;
      CFIndex Length = 16;
      do
      {
        CFIndex v23 = CFArrayGetValueAtIndex((CFArrayRef)a3, v21);
        CFTypeID v24 = CFNumberGetTypeID();
        if (v24 != CFGetTypeID(v23)) {
          goto LABEL_98;
        }
        CFNumberGetValue((CFNumberRef)v23, kCFNumberSInt32Type, v22);
        *char v22 = bswap32(*v22);
        ++v22;
        ++v21;
      }
      while (v21 != 4);
      goto LABEL_61;
  }
  while (1)
  {
    int v53 = CFArrayGetValueAtIndex((CFArrayRef)a3, v51);
    CFTypeID v54 = CFDictionaryGetTypeID();
    if (v54 != CFGetTypeID(v53) || !CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)v53, &point.origin)) {
      break;
    }
    v26[v51++] = vrev32_s8((int8x8_t)vcvt_f32_f64((float64x2_t)point.origin));
    if (v52 == v51)
    {
      CFDataRef v16 = 0;
      BytePtr = (const UInt8 *)v26;
      goto LABEL_90;
    }
  }
  uint64_t v35 = FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
LABEL_97:
  free(v26);
  return v35;
}

uint64_t FigBoxedMetadataAppendSInt8(uint64_t a1, unsigned int a2, int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t setupAndNormalizeAndAppendScalarValue(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v8 = 0;
  uint64_t result = scalarWriteSetup(a1, a2, 0, &v8);
  if (!result)
  {
    int v7 = v8;
    return normalizeAndAppendScalarValue(a1, a2, a3, v7);
  }
  return result;
}

uint64_t FigBoxedMetadataAppendUInt8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendSInt16(uint64_t a1, unsigned int a2, int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendUInt16(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendSInt32(uint64_t a1, unsigned int a2, int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendUInt32(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendFloat32(uint64_t a1, unsigned int a2, float a3)
{
  int v14 = 0;
  uint64_t result = scalarWriteSetup(a1, a2, 0, &v14);
  if (result) {
    return result;
  }
  int v7 = v14;
  uint64_t v8 = (v14 - 23);
  if (v8 <= 0x37)
  {
    if (((1 << (v14 - 23)) & 0xF81C0000000000) != 0)
    {
      return normalizeAndAppendScalarValue(a1, a2, (uint64_t)a3, v7);
    }
    if (v14 == 23)
    {
      unsigned int v15 = bswap32(LODWORD(a3));
      uint64_t v9 = (unint64_t *)&v15;
      uint64_t v10 = a1;
      unsigned int v11 = a2;
      uint64_t v12 = 4;
      return appendScalarValue(v10, v11, (uint64_t)v9, v12);
    }
    if (v8 == 1)
    {
      unint64_t v13 = bswap64(COERCE_UNSIGNED_INT64(a3));
      uint64_t v9 = &v13;
      uint64_t v10 = a1;
      unsigned int v11 = a2;
      uint64_t v12 = 8;
      return appendScalarValue(v10, v11, (uint64_t)v9, v12);
    }
  }

  return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
}

uint64_t scalarWriteSetup(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 216))
    {
      int QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), a2);
      *a4 = QuickTimeWellKnownTypeForLocalID;
      unint64_t WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, a3, &v10);
      if (!a3 || WellKnownTypeDataSize == a3) {
        return 0;
      }
      uint64_t v9 = 4294950969;
    }
    else
    {
      uint64_t v9 = 4294950970;
    }
  }
  else
  {
    uint64_t v9 = 4294950976;
  }

  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t normalizeAndAppendScalarValue(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  switch(a4)
  {
    case 'A':
    case 'B':
      LOBYTE(v6[0]) = a3;
      uint64_t v4 = 1;
      return appendScalarValue(a1, a2, (uint64_t)v6, v4);
    case 'C':
    case 'M':
      LODWORD(v6[0]) = bswap32(a3);
      goto LABEL_14;
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'K':
      goto LABEL_9;
    case 'J':
    case 'N':
      *(void *)&v6[0] = bswap64(a3);
      goto LABEL_8;
    case 'L':
      LOWORD(v6[0]) = bswap32(a3) >> 16;
      uint64_t v4 = 2;
      return appendScalarValue(a1, a2, (uint64_t)v6, v4);
    default:
      if (a4 == 23)
      {
        *(float *)int8x16_t v6 = (float)bswap32((float)a3);
LABEL_14:
        uint64_t v4 = 4;
        return appendScalarValue(a1, a2, (uint64_t)v6, v4);
      }
      if (a4 == 24)
      {
        *(double *)int8x16_t v6 = (double)bswap32(a3);
LABEL_8:
        uint64_t v4 = 8;
        return appendScalarValue(a1, a2, (uint64_t)v6, v4);
      }
LABEL_9:
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t appendScalarValue(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1 + 144;
  uint64_t result = FigAtomWriterBeginAtom(a1 + 144, a2, 0);
  if (!result)
  {
    uint64_t result = FigAtomWriterAppendData(v6, a3, a4);
    if (!result)
    {
      return FigAtomWriterEndAtom(v6);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataAppendFloat64(uint64_t a1, unsigned int a2, double a3)
{
  int v15 = 0;
  uint64_t result = scalarWriteSetup(a1, a2, 0, &v15);
  if (result) {
    return result;
  }
  int v7 = v15;
  uint64_t v8 = (v15 - 23);
  if (v8 <= 0x37)
  {
    if (((1 << (v15 - 23)) & 0xF81C0000000000) != 0)
    {
      return normalizeAndAppendScalarValue(a1, a2, (uint64_t)a3, v7);
    }
    if (v15 == 23)
    {
      *(float *)&unsigned int v13 = a3;
      unsigned int v14 = bswap32(v13);
      uint64_t v9 = (unint64_t *)&v14;
      uint64_t v10 = a1;
      unsigned int v11 = a2;
      uint64_t v12 = 4;
      return appendScalarValue(v10, v11, (uint64_t)v9, v12);
    }
    if (v8 == 1)
    {
      unint64_t v16 = bswap64(*(unint64_t *)&a3);
      uint64_t v9 = &v16;
      uint64_t v10 = a1;
      unsigned int v11 = a2;
      uint64_t v12 = 8;
      return appendScalarValue(v10, v11, (uint64_t)v9, v12);
    }
  }

  return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBoxedMetadataAppendCGPoint(uint64_t a1, unsigned int a2, float64_t a3, float64_t a4)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  int v10 = 0;
  uint64_t result = scalarWriteSetup(a1, a2, 8, &v10);
  if (!result)
  {
    if (v10 == 70)
    {
      v7.f64[0] = a3;
      v7.f64[1] = a4;
      v11[0] = vrev32_s8((int8x8_t)vcvt_f32_f64(v7));
      return appendScalarValue(a1, a2, (uint64_t)v11, 8);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataAppendCGSize(uint64_t a1, unsigned int a2, float64_t a3, float64_t a4)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  int v10 = 0;
  uint64_t result = scalarWriteSetup(a1, a2, 8, &v10);
  if (!result)
  {
    if (v10 == 71)
    {
      v7.f64[0] = a3;
      v7.f64[1] = a4;
      v11[0] = vrev32_s8((int8x8_t)vcvt_f32_f64(v7));
      return appendScalarValue(a1, a2, (uint64_t)v11, 8);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataAppendCGRect(uint64_t a1, unsigned int a2, float64_t a3, float64_t a4, float64_t a5, float64_t a6)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v15 = 0;
  uint64_t result = scalarWriteSetup(a1, a2, 16, &v15);
  if (!result)
  {
    if (v15 == 72)
    {
      v9.f64[0] = a5;
      v10.f64[0] = a3;
      v9.f64[1] = a6;
      v10.f64[1] = a4;
      int8x16_t v16 = vrev32q_s8((int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v10), v9));
      return appendScalarValue(a1, a2, (uint64_t)&v16, 16);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataAppendCGAffineTransform(uint64_t a1, unsigned int a2, int8x16_t *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v8 = 0;
  uint64_t result = scalarWriteSetup(a1, a2, 72, &v8);
  if (!result)
  {
    if (v8 == 79)
    {
      int8x16_t v7 = a3[1];
      int8x16_t v9 = vrev64q_s8(*a3);
      uint64_t v10 = 0;
      int8x16_t v11 = vrev64q_s8(v7);
      uint64_t v12 = 0;
      int8x16_t v13 = vrev64q_s8(a3[2]);
      uint64_t v14 = 61503;
      return appendScalarValue(a1, a2, (uint64_t)&v9, 72);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

void createDataTypeRegistryGlobalsOnce()
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  gfigMetadataDataTypeRegistryStorage = (uint64_t)malloc_type_calloc(1uLL, 0x38uLL, 0x60040CEC3798AuLL);
  if (gfigMetadataDataTypeRegistryStorage)
  {
    long long v38 = xmmword_1E5678C68;
    long long v39 = *(_OWORD *)&off_1E5678C78;
    CFIndex v40 = @"com.apple.metadata.perspective-transform-float64";
    long long v34 = xmmword_1E5678C28;
    long long v35 = *(_OWORD *)&off_1E5678C38;
    long long v36 = xmmword_1E5678C48;
    long long v37 = *(_OWORD *)&off_1E5678C58;
    long long v30 = xmmword_1E5678BE8;
    long long v31 = *(_OWORD *)&off_1E5678BF8;
    long long v32 = xmmword_1E5678C08;
    long long v33 = *(_OWORD *)&off_1E5678C18;
    *(_OWORD *)values = xmmword_1E5678BC8;
    long long v29 = *(_OWORD *)&off_1E5678BD8;
    long long v25 = xmmword_1E5678D30;
    long long v26 = *(_OWORD *)&off_1E5678D40;
    CFTypeID v27 = @"3x3 perspective transform using 64-bit big endian floats";
    long long v21 = xmmword_1E5678CF0;
    long long v22 = *(_OWORD *)&off_1E5678D00;
    long long v23 = xmmword_1E5678D10;
    long long v24 = *(_OWORD *)&off_1E5678D20;
    long long v17 = xmmword_1E5678CB0;
    long long v18 = *(_OWORD *)&off_1E5678CC0;
    long long v19 = xmmword_1E5678CD0;
    long long v20 = *(_OWORD *)&off_1E5678CE0;
    *(_OWORD *)uint64_t v15 = xmmword_1E5678C90;
    long long v16 = *(_OWORD *)&off_1E5678CA0;
    *(_OWORD *)int8x16_t v11 = xmmword_1E5678D58;
    long long v12 = *(_OWORD *)&off_1E5678D68;
    long long v13 = xmmword_1E5678D78;
    long long v14 = *(_OWORD *)&off_1E5678D88;
    v10[0] = xmmword_1E5678D98;
    v10[1] = *(_OWORD *)&off_1E5678DA8;
    CFArrayRef v10[2] = xmmword_1E5678DB8;
    v10[3] = *(_OWORD *)&off_1E5678DC8;
    *(void *)gfigMetadataDataTypeRegistryStorage = FigReentrantMutexCreate();
    CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    *(void *)(gfigMetadataDataTypeRegistryStorage + 8) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(gfigMetadataDataTypeRegistryStorage + 16) = CFDictionaryCreateMutable(v0, 0, v1, v2);
    *(void *)(gfigMetadataDataTypeRegistryStorage + 24) = CFDictionaryCreateMutable(v0, 0, v1, v2);
    *(void *)(gfigMetadataDataTypeRegistryStorage + 32) = CFDictionaryCreateMutable(v0, 0, v1, v2);
    int v3 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    *(void *)(gfigMetadataDataTypeRegistryStorage + 48) = CFArrayCreate(v0, (const void **)values, 25, MEMORY[0x1E4F1D510]);
    CFArrayRef v4 = CFArrayCreate(v0, (const void **)v11, 8, v3);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v0, 33, v3);
    uint64_t v6 = Mutable;
    if (*(void *)gfigMetadataDataTypeRegistryStorage)
    {
      if (*(void *)(gfigMetadataDataTypeRegistryStorage + 8))
      {
        if (*(void *)(gfigMetadataDataTypeRegistryStorage + 16))
        {
          CFArrayRef v7 = *(const __CFArray **)(gfigMetadataDataTypeRegistryStorage + 48);
          if (v7)
          {
            if (v4)
            {
              if (Mutable)
              {
                v42.CFIndex location = 0;
                v42.CFIndex length = 25;
                CFArrayAppendArray(Mutable, v7, v42);
                v43.CFIndex location = 0;
                v43.CFIndex length = 8;
                CFArrayAppendArray(v6, v4, v43);
                CFArrayRef Copy = CFArrayCreateCopy(v0, v6);
                *(void *)(gfigMetadataDataTypeRegistryStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = Copy;
                if (Copy)
                {
                  if (createBaseDataTypes((const void **)values, (const void **)v15, 25)
                    && createBaseDataTypes((const void **)v11, (const void **)v10, 8))
                  {
                    goto LABEL_20;
                  }
                }
              }
            }
          }
        }
      }
    }
    FigReentrantMutexDestroy(*(void *)gfigMetadataDataTypeRegistryStorage);
    int8x16_t v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    if (*(void *)(gfigMetadataDataTypeRegistryStorage + 8))
    {
      CFRelease(*(CFTypeRef *)(gfigMetadataDataTypeRegistryStorage + 8));
      int8x16_t v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    if (v9[2])
    {
      CFRelease(v9[2]);
      int8x16_t v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    if (v9[6])
    {
      CFRelease(v9[6]);
      int8x16_t v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    if (v9[5])
    {
      CFRelease(v9[5]);
      int8x16_t v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    free(v9);
    gfigMetadataDataTypeRegistryStorage = 0;
    if (v4) {
LABEL_20:
    }
      CFRelease(v4);
    if (v6) {
      CFRelease(v6);
    }
  }
}

void registerKnownDataTypesOnce()
{
  if (gfigMetadataDataTypeRegistryStorage)
  {
    registerKnownDataType(@"com.apple.quicktime.detected-face", @"detected face", @"com.apple.metadata.datatype.record-collection");
    registerKnownDataType(@"com.apple.quicktime.detected-human-body", @"detected human body", @"com.apple.metadata.datatype.record-collection");
    registerKnownDataType(@"com.apple.quicktime.detected-cat-body", @"detected cat body", @"com.apple.metadata.datatype.record-collection");
    registerKnownDataType(@"com.apple.quicktime.detected-dog-body", @"detected dog body", @"com.apple.metadata.datatype.record-collection");
    registerKnownDataType(@"com.apple.quicktime.detected-salient-object", @"detected salient object", @"com.apple.metadata.datatype.record-collection");
    registerKnownDataType(@"com.apple.quicktime.location.ISO6709", @"location in ISO 6709 format", @"com.apple.metadata.datatype.UTF-8");
    registerKnownDataType(@"com.apple.quicktime.direction", @"direction", @"com.apple.metadata.datatype.UTF-8");
    registerKnownDataType(@"com.apple.quicktime.uuid", @"UUID", @"com.apple.metadata.datatype.UTF-8");
    registerKnownDataType(@"com.apple.quicktime.milli-lux", @"1/1000th of a Lux", @"com.apple.metadata.datatype.uint32");
  }
}

uint64_t createBaseDataTypes(const void **a1, const void **values, uint64_t a3)
{
  if (a3 < 1) {
    return 1;
  }
  uint64_t v3 = a3;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  while (1)
  {
    uint64_t result = (uint64_t)CFDictionaryCreate(v6, (const void **)&kFigMetadata_DataTypeRegistry_RegistrySpecification_Description, values, 1, v7, v8);
    if (!result) {
      break;
    }
    uint64_t v10 = (const void *)result;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(gfigMetadataDataTypeRegistryStorage + 8), *a1, (const void *)result);
    CFRelease(v10);
    int8x16_t v11 = *a1++;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(gfigMetadataDataTypeRegistryStorage + 16), v11, v11);
    ++values;
    if (!--v3) {
      return 1;
    }
  }
  return result;
}

void registerKnownDataType(const __CFString *a1, const void *a2, void *a3)
{
  values = a3;
  CFArrayRef v5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  if (v5)
  {
    CFArrayRef v6 = v5;
    doFigMetadataDataTypeRegistryRegisterDataType(gfigMetadataDataTypeRegistryStorage, a1, a2, v5);
    CFRelease(v6);
  }
  else
  {
    FigSignalErrorAt(4294950996, 0, 0, 0, 0, 0, 0);
  }
}

double boxedMetadataInit(_OWORD *a1)
{
  double result = 0.0;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

double boxedMetadataFinalize(uint64_t a1)
{
  uint64_t v3 = (_OWORD *)(a1 + 16);
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  CFArrayRef v4 = *(const void **)(a1 + 24);
  if (v4) {
    CFRelease(v4);
  }
  double result = 0.0;
  v3[11] = 0u;
  v3[12] = 0u;
  v3[9] = 0u;
  v3[10] = 0u;
  v3[7] = 0u;
  v3[8] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[1] = 0u;
  void v3[2] = 0u;
  *uint64_t v3 = 0u;
  return result;
}

uint64_t boxedMetadataEqual(uint64_t a1, uint64_t a2)
{
  uint64_t result = FigCFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if (result) {
    return FigCFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24)) != 0;
  }
  return result;
}

__CFString *boxedMetadataCopyDebugDesc(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable(0, 0);
  CFIndex v3 = CFGetRetainCount((CFTypeRef)a1);
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, @"CMBoxedMetadata %p retainCount: %ld allocator: %p\n", a1, v3, v4);
  uint64_t v5 = 84;
  if (!*(unsigned char *)(a1 + 216)) {
    uint64_t v5 = 70;
  }
  CFStringAppendFormat(Mutable, 0, @"\tbbuf %p\n\tisUnderConstructiouint64_t n = %c\n", *(void *)(a1 + 16), v5);
  return Mutable;
}

uint64_t FigInMemorySerializerAppendBlockBuffer(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, CMBlockBufferRef theBuffer)
{
  CFArrayRef v6 = theBuffer;
  CMBlockBufferRef theBuffera = 0;
  unint64_t DataLength = CMBlockBufferGetDataLength(theBuffer);
  vm_address_t v13 = DataLength;
  vm_address_t v24 = DataLength;
  if (!a1)
  {
    if (DataLength >= 0x401 && FigMemoryOriginIsBlockBufferSendable(a5, v6))
    {
      uint64_t DataPointer = FigMemoryOriginSetBlockBufferInIPCMessageData(a5, v6, 0, 0, &v24);
      if (DataPointer) {
        goto LABEL_29;
      }
      vm_address_t v13 = v24;
    }
    uint64_t v18 = 0;
    uint64_t v19 = 1024;
    if (v13 < 0x400) {
      uint64_t v19 = v13;
    }
    uint64_t v20 = v19 + 9;
    goto LABEL_24;
  }
  if (a2 <= 8)
  {
    uint64_t DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    unint64_t v14 = a2 - 9;
    unint64_t v15 = 1024;
    if (v14 < 0x400) {
      unint64_t v15 = v14;
    }
    if (DataLength <= v15)
    {
      uint64_t v18 = CMBlockBufferCopyDataBytes(v6, 0, DataLength, (void *)(a1 + 9));
      if (v18) {
        goto LABEL_25;
      }
      *(unsigned char *)a1 = 0;
      goto LABEL_23;
    }
    vm_address_t v23 = 0;
    if (FigMemoryOriginIsBlockBufferSendable(a5, v6))
    {
LABEL_13:
      uint64_t v18 = FigMemoryOriginSetBlockBufferInIPCMessageData(a5, v6, a1 + 9, v14, &v23);
      *(unsigned char *)a1 = 1;
      vm_address_t v13 = v23;
LABEL_23:
      *(void *)(a1 + 1) = v13;
      uint64_t v20 = v13 + 9;
LABEL_24:
      *a3 = v20;
      goto LABEL_25;
    }
    unsigned int destination = 0;
    uint64_t DataPointer = (uint64_t)FigMemoryPoolCreateBlockBuffer(a4, v13, &theBuffera, v16);
    if (!DataPointer)
    {
      uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffera, 0, 0, 0, (char **)&destination);
      if (!DataPointer)
      {
        uint64_t DataPointer = CMBlockBufferCopyDataBytes(v6, 0, v13, destination);
        if (!DataPointer)
        {
          if (gGMFigKTraceEnabled == 1) {
            kdebug_trace();
          }
          CFArrayRef v6 = theBuffera;
          goto LABEL_13;
        }
      }
    }
  }
LABEL_29:
  uint64_t v18 = DataPointer;
LABEL_25:
  if (theBuffera) {
    CFRelease(theBuffera);
  }
  return v18;
}

uint64_t FigInMemoryDeserializerCopyBlockBuffer(CFAllocatorRef blockAllocator, uint64_t a2, unint64_t a3, int a4, uint64_t a5, CMBlockBufferRef *blockBufferOut)
{
  destinationuint64_t Buffer = 0;
  if (a3 <= 8) {
    goto LABEL_15;
  }
  unint64_t v7 = *(void *)(a2 + 1);
  if (v7 >= 0xFFFFFFFFFFFFFFF7 || v7 + 9 > a3) {
    goto LABEL_15;
  }
  if (*(unsigned char *)a2 == 1)
  {
    return FigMemoryRecipientCopyBlockBufferFromIPCMessageData(blockAllocator, a5, a2 + 9, v7, blockBufferOut);
  }
  if (*(unsigned char *)a2)
  {
LABEL_15:
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
  else if (a4)
  {
    return CMBlockBufferCreateWithMemoryBlock(blockAllocator, (void *)(a2 + 9), v7, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0], 0, 0, v7, 0, blockBufferOut);
  }
  else
  {
    uint64_t result = CMBlockBufferCreateWithMemoryBlock(blockAllocator, 0, v7, blockAllocator, 0, 0, v7, 1u, &destinationBuffer);
    CMBlockBufferRef v10 = destinationBuffer;
    if (result
      || (uint64_t result = CMBlockBufferReplaceDataBytes((const void *)(a2 + 9), destinationBuffer, 0, *(void *)(a2 + 1)),
          CMBlockBufferRef v10 = destinationBuffer,
          result))
    {
      if (v10)
      {
        uint64_t v11 = result;
        CFRelease(v10);
        return v11;
      }
    }
    else
    {
      *CMBlockBufferRef blockBufferOut = destinationBuffer;
    }
  }
  return result;
}

uint64_t FigInMemorySerializerAppendCMSampleBuffer(uint64_t *a1, unint64_t a2, void *a3, CMSampleBufferRef sbuf, const __CFArray *a5, unsigned int a6, uint64_t a7, uint64_t a8, const opaqueCMFormatDescription **a9, int a10)
{
  uint64_t v11 = *a9;
  CFTypeRef v42 = 0;
  CFTypeRef v40 = 0;
  uint64_t v41 = 0;
  dataPointerOut = 0;
  size_t lengthAtOffsetOut = 0;
  CFTypeRef cf = 0;
  CMBlockBufferRef theBuffer = 0;
  CFTypeRef v35 = 0;
  if (a2 <= 0x17) {
    goto LABEL_45;
  }
  unint64_t v34 = a2 - 24;
  uint64_t v33 = (uint64_t)(a1 + 3);
  dataPointerOut = (char *)(a1 + 3);
  size_t lengthAtOffsetOut = a2 - 24;
  if (!sbuf) {
    goto LABEL_45;
  }
  char v17 = a6;
  if (CMSampleBufferDataIsReady(sbuf))
  {
    CFTypeRef v18 = CFRetain(sbuf);
    CFTypeRef v40 = v18;
    goto LABEL_9;
  }
  if ((a6 & 1) == 0 || (v17 & 2) == 0)
  {
LABEL_45:
    uint64_t CopyWithNoData = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  uint64_t CopyWithNoData = FigSampleBufferCreateCopyWithNoData((const __CFAllocator *)*MEMORY[0x1E4F1CF80], sbuf, (CMSampleBufferRef *)&v40);
  if (CopyWithNoData)
  {
LABEL_24:
    uint64_t v23 = CopyWithNoData;
    goto LABEL_30;
  }
  CFTypeRef v18 = v40;
LABEL_9:
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t CopyWithNoData = FigRemote_CopyReplacementAttachmentsForSampleBuffer(v18, a5, (__CFDictionary **)&cf, (__CFDictionary **)&v35);
  if (CopyWithNoData) {
    goto LABEL_24;
  }
  unsigned int v20 = (a6 >> 2) & 1;
  while (1)
  {
    while (1)
    {
      uint64_t v21 = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v40, (const __CFDictionary *)cf, (const __CFDictionary *)v35, v20, (uint64_t)dataPointerOut, lengthAtOffsetOut, &v41, v11, &v42, a10);
      if (v21 != -12572) {
        break;
      }
      dataPointerOut = 0;
      size_t lengthAtOffsetOut = 0;
    }
    uint64_t v23 = v21;
    if (v21) {
      break;
    }
    uint64_t v24 = v41;
    a1[1] = v41;
    if ((v17 & 2) == 0)
    {
      if (dataPointerOut)
      {
        long long v25 = &dataPointerOut[v24];
        long long v26 = (opaqueCMSampleBuffer *)v40;
        unint64_t v27 = lengthAtOffsetOut - v24;
      }
      else
      {
        long long v26 = (opaqueCMSampleBuffer *)v40;
        long long v25 = 0;
        unint64_t v27 = 0;
      }
      uint64_t CopyWithNoData = (uint64_t)FigInMemorySerializationAddDataBufferFromCMSampleBuffer((uint64_t)v25, v27, &v41, a7, a8, v26);
      if (CopyWithNoData) {
        goto LABEL_24;
      }
      a1[2] = v41;
    }
    if (dataPointerOut)
    {
      unsigned int v28 = *a9;
      CFTypeRef v29 = v42;
      *a9 = (const opaqueCMFormatDescription *)v42;
      if (v29) {
        CFRetain(v29);
      }
      if (v28) {
        CFRelease(v28);
      }
      uint64_t v23 = 0;
      break;
    }
    uint64_t CopyWithNoData = (uint64_t)FigMemoryPoolCreateBlockBuffer(a7, a1[2] + a1[1], &theBuffer, v22);
    if (!CopyWithNoData)
    {
      uint64_t CopyWithNoData = FigMemoryOriginSetBlockBufferInIPCMessageData(a8, theBuffer, v33, v34, (unint64_t *)&v41);
      if (!CopyWithNoData)
      {
        *a1 = v41;
        uint64_t CopyWithNoData = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
        if (!CopyWithNoData) {
          continue;
        }
      }
    }
    goto LABEL_24;
  }
LABEL_30:
  if (a3)
  {
    uint64_t v30 = *a1;
    if (!*a1) {
      uint64_t v30 = a1[1] + a1[2];
    }
    *a3 = v30 + 24;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v35) {
    CFRelease(v35);
  }
  if (v42) {
    CFRelease(v42);
  }
  if (v40) {
    CFRelease(v40);
  }
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return v23;
}

OpaqueCMBlockBuffer *FigInMemorySerializationAddDataBufferFromCMSampleBuffer(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, CMSampleBufferRef sbuf)
{
  if (sbuf && CMSampleBufferDataIsReady(sbuf) == 1)
  {
    uint64_t result = CMSampleBufferGetDataBuffer(sbuf);
    if (result)
    {
      return (OpaqueCMBlockBuffer *)FigInMemorySerializerAppendBlockBuffer(a1, a2, a3, a4, a5, result);
    }
    else
    {
      *a3 = 0;
    }
  }
  else
  {
    return (OpaqueCMBlockBuffer *)FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigInMemoryDeserializerCopyCMSampleBuffer(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, char a5, const opaqueCMFormatDescription **a6, CFTypeRef *a7, CMSampleBufferRef *a8)
{
  CMBlockBufferRef theBuffer = 0;
  CFTypeRef cf = 0;
  dataPointerOut = 0;
  if (a3 <= 0x17) {
    goto LABEL_22;
  }
  unint64_t v16 = *(void *)a2;
  if (!*(void *)a2)
  {
    unint64_t v19 = *(void *)(a2 + 16);
    if (v19 < 0xFFFFFFFFFFFFFFE8)
    {
      CFAllocatorRef v18 = *(const __CFAllocator **)(a2 + 8);
      if (-25 - v19 >= (unint64_t)v18 && (unint64_t)v18 + v19 + 24 <= a3)
      {
        unsigned int v20 = (char *)(a2 + 24);
        dataPointerOut = (char *)(a2 + 24);
        if (v19) {
          goto LABEL_10;
        }
LABEL_16:
        uint64_t v22 = 0;
LABEL_17:
        uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(a1, v20, v18, (a5 & 1) == 0, v22, a6, a7, a8);
        uint64_t v22 = (OpaqueCMBlockBuffer *)cf;
        if (!cf) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
    }
    goto LABEL_22;
  }
  size_t v25 = 0;
  if (v16 >= 0xFFFFFFFFFFFFFFE8 || v16 + 24 > a3) {
    goto LABEL_22;
  }
  uint64_t DataPointer = FigMemoryRecipientCopyBlockBufferFromIPCMessageData(a1, a4, a2 + 24, v16, &theBuffer);
  if (DataPointer) {
    goto LABEL_23;
  }
  uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &v25, 0, &dataPointerOut);
  if (DataPointer) {
    goto LABEL_23;
  }
  CFAllocatorRef v18 = *(const __CFAllocator **)(a2 + 8);
  unint64_t v19 = *(void *)(a2 + 16);
  if (__CFADD__(v18, v19) || v25 < (unint64_t)v18 + v19)
  {
LABEL_22:
    uint64_t DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
LABEL_23:
    uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = DataPointer;
    goto LABEL_19;
  }
  unsigned int v20 = dataPointerOut;
  if (!v19) {
    goto LABEL_16;
  }
LABEL_10:
  uint64_t v21 = FigInMemoryDeserializerCopyBlockBuffer(a1, (uint64_t)v18 + (void)v20, v19, 0, a4, (CMBlockBufferRef *)&cf);
  uint64_t v22 = (OpaqueCMBlockBuffer *)cf;
  if (!v21)
  {
    unsigned int v20 = dataPointerOut;
    CFAllocatorRef v18 = *(const __CFAllocator **)(a2 + 8);
    goto LABEL_17;
  }
  uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = v21;
  if (cf) {
LABEL_18:
  }
    CFRelease(v22);
LABEL_19:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor;
}

CFIndex FigInMemorySerializerAppendCFType(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *a4, char a5, uint64_t a6, uint64_t a7)
{
  size_t lengthAtOffsetOut = 0;
  vm_address_t v26 = 0;
  CMBlockBufferRef theBuffer = 0;
  dataPointerOut = 0;
  if (a3) {
    *a3 = 0;
  }
  if (a4)
  {
    if (a1 && a2 > 0xF)
    {
      unint64_t v12 = a2 - 16;
      dataPointerOut = (char *)(a1 + 16);
      size_t lengthAtOffsetOut = a2 - 16;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      BOOL v13 = (a5 & 1) == 0;
      size_t v14 = a2 - 16;
      unint64_t v15 = (char *)(a1 + 16);
      while (1)
      {
        while (1)
        {
          CFIndex v16 = FigRemote_WriteSerializedAtomDataForCFType(a4, v13, (uint64_t)v15, v14, &v26);
          if (v16 != -12572) {
            break;
          }
          size_t v14 = 0;
          unint64_t v15 = 0;
          dataPointerOut = 0;
          size_t lengthAtOffsetOut = 0;
        }
        CFIndex v18 = v16;
        if (v16) {
          break;
        }
        vm_address_t v19 = v26;
        *(void *)(a1 + 8) = v26;
        if (dataPointerOut)
        {
          if (!a3) {
            goto LABEL_19;
          }
          if (v19)
          {
            CFIndex v18 = 0;
            if (*(void *)a1) {
              uint64_t v21 = *(void *)a1 + 16;
            }
            else {
              uint64_t v21 = v19 + 16;
            }
            *a3 = v21;
          }
          else
          {
            CFIndex v18 = 0;
            *a3 = 0;
          }
          break;
        }
        uint64_t DataPointer = (uint64_t)FigMemoryPoolCreateBlockBuffer(a6, v19, &theBuffer, v17);
        if (DataPointer) {
          goto LABEL_27;
        }
        uint64_t DataPointer = FigMemoryOriginSetBlockBufferInIPCMessageData(a7, theBuffer, a1 + 16, v12, &v26);
        if (DataPointer) {
          goto LABEL_27;
        }
        *(void *)a1 = v26;
        uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
        if (DataPointer) {
          goto LABEL_27;
        }
        unint64_t v15 = dataPointerOut;
        size_t v14 = lengthAtOffsetOut;
      }
    }
    else
    {
      uint64_t DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
LABEL_27:
      CFIndex v18 = DataPointer;
    }
  }
  else
  {
LABEL_19:
    CFIndex v18 = 0;
  }
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return v18;
}

CFIndex FigInMemorySerializerAppendCFDictionary(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  if (a3) {
    *a3 = 0;
  }
  if (!cf) {
    return 0;
  }
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 == CFDictionaryGetTypeID())
  {
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  }
  else
  {
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
}

CFIndex FigInMemorySerializerAppendCFURL(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 == CFURLGetTypeID())
  {
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  }
  else
  {
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
}

CFIndex FigInMemorySerializerAppendCFString(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 == CFStringGetTypeID())
  {
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  }
  else
  {
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
}

CFIndex FigInMemorySerializerAppendCMFormatDescription(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 == CMFormatDescriptionGetTypeID())
  {
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  }
  else
  {
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigInMemoryDeserializerCopyCFType(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  dataPointerOut = 0;
  CMBlockBufferRef theBuffer = 0;
  if (!a3) {
    return 0;
  }
  if (a3 <= 0xF || !a2 || !a5) {
    goto LABEL_19;
  }
  unint64_t v8 = *(void *)a2;
  if (!*(void *)a2)
  {
    size_t v10 = *(void *)(a2 + 8);
    if (v10 < 0xFFFFFFFFFFFFFFF0 && v10 + 16 <= a3)
    {
      uint64_t v11 = (char *)(a2 + 16);
      dataPointerOut = (char *)(a2 + 16);
      goto LABEL_15;
    }
    goto LABEL_19;
  }
  size_t lengthAtOffsetOut = 0;
  if (v8 >= 0xFFFFFFFFFFFFFFF0 || v8 + 16 > a3)
  {
LABEL_19:
    uint64_t DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  uint64_t DataPointer = FigMemoryRecipientCopyBlockBufferFromIPCMessageData(a1, a4, a2 + 16, v8, &theBuffer);
  if (!DataPointer)
  {
    uint64_t DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (!DataPointer)
    {
      size_t v10 = *(void *)(a2 + 8);
      if (lengthAtOffsetOut >= v10)
      {
        uint64_t v11 = dataPointerOut;
LABEL_15:
        uint64_t DataPointer = FigRemote_CreateCFTypeFromSerializedAtomData(a1, (uint64_t)v11, v10, a5);
        goto LABEL_16;
      }
      goto LABEL_19;
    }
  }
LABEL_16:
  uint64_t v12 = DataPointer;
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return v12;
}

uint64_t FigInMemoryDeserializerCopyCFDictionary(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  CFTypeRef cf = 0;
  uint64_t v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!v6)
  {
    if (!cf)
    {
      CFTypeRef v8 = 0;
      goto LABEL_6;
    }
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFDictionaryGetTypeID())
    {
      CFTypeRef v8 = cf;
LABEL_6:
      uint64_t v9 = 0;
      *a5 = v8;
      return v9;
    }
    uint64_t v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v9 = v6;
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t FigInMemoryDeserializerCopyCFURL(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  CFTypeRef cf = 0;
  uint64_t v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!v6)
  {
    if (!cf)
    {
      CFTypeRef v8 = 0;
      goto LABEL_6;
    }
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFURLGetTypeID())
    {
      CFTypeRef v8 = cf;
LABEL_6:
      uint64_t v9 = 0;
      *a5 = v8;
      return v9;
    }
    uint64_t v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v9 = v6;
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t FigInMemoryDeserializerCopyCFString(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  CFTypeRef cf = 0;
  uint64_t v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!v6)
  {
    if (!cf)
    {
      CFTypeRef v8 = 0;
      goto LABEL_6;
    }
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      CFTypeRef v8 = cf;
LABEL_6:
      uint64_t v9 = 0;
      *a5 = v8;
      return v9;
    }
    uint64_t v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v9 = v6;
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t FigInMemoryDeserializerCopyCMFormatDescription(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  CFTypeRef cf = 0;
  uint64_t v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!v6)
  {
    if (!cf)
    {
      CFTypeRef v8 = 0;
      goto LABEL_6;
    }
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CMFormatDescriptionGetTypeID())
    {
      CFTypeRef v8 = cf;
LABEL_6:
      uint64_t v9 = 0;
      *a5 = v8;
      return v9;
    }
    uint64_t v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  uint64_t v9 = v6;
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

uint64_t FigTraceLoggingStart()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  CFNumberRef v1 = "/tmp/qttrace";
  long long v3 = unk_1E5679128;
  printf("clear kernel trace buffer, reset defaults");
  uint64_t v2 = "-r";
  FigTraceCommandWithArguments("/tmp/qttrace", (uint64_t)&v1);
  printf("disable kernel trace wraparound");
  uint64_t v2 = "-n";
  FigTraceCommandWithArguments("/tmp/qttrace", (uint64_t)&v1);

  return FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTraceCommandWithArguments(const char *a1, uint64_t a2)
{
  memset(&v5, 0, sizeof(v5));
  if (stat("/tmp/qttrace", &v5))
  {
    puts("Error, must create /tmp/qttrace before enabling trace logging.");
    puts("  Try the following:");
    puts("      cp /usr/local/bin/trace /tmp/qttrace");
    puts("      sudo chown root:admin \"/tmp/qttrace\"");
    puts("      sudo chmod 4750 \"/tmp/qttrace\"");
    printf("Error %d creating /tmp/qttrace.\n", -1);
    return unlink("/tmp/qttrace");
  }
  else
  {
    printf(" : system( %s", a1);
    printf(" %s", *(const char **)(a2 + 8));
    puts(")");
    return fflush((FILE *)*MEMORY[0x1E4F143D8]);
  }
}

uint64_t FigTraceLoggingEnd()
{
  return FigSignalErrorAt(4294954499, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTraceLoggingDumpToFile()
{
  return FigSignalErrorAt(4294954499, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionTextEmphasisGetTypeID()
{
  return sFigCaptionTextEmphasisID;
}

uint64_t RegisterFigCaptionTextEmphasisType()
{
  uint64_t result = _CFRuntimeRegisterClass();
  sFigCaptionTextEmphasisID = result;
  return result;
}

uint64_t FigCaptionTextEmphasisGetEmphasisStyle(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t FigCaptionTextEmphasisGetMarkingStyle(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t FigCaptionTextEmphasisGetPredefinedMark(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t FigCaptionTextEmphasisGetCustomMark(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t FigCaptionTextEmphasisGetColor(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t FigCaptionTextEmphasisGetRubyPosition(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t FigCaptionTextEmphasisCreate(uint64_t a1, int a2, int a3, int a4, const void *a5, CGColor *a6, const void *a7, void *a8)
{
  if (a8)
  {
    FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
    uint64_t Instance = (_DWORD *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v17 = Instance;
      Instance[4] = a2;
      Instance[5] = a3;
      Instance[6] = a4;
      if (a5) {
        CFTypeRef v18 = CFRetain(a5);
      }
      else {
        CFTypeRef v18 = 0;
      }
      void v17[4] = v18;
      v17[5] = CGColorRetain(a6);
      if (a7) {
        CFTypeRef v19 = CFRetain(a7);
      }
      else {
        CFTypeRef v19 = 0;
      }
      v17[6] = v19;
      *a8 = v17;
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigCaptionTextEmphasisCreateNone(uint64_t a1, CGColor *a2, const void *a3, void *a4)
{
  return FigCaptionTextEmphasisCreate(a1, 0, 0, 0, 0, a2, a3, a4);
}

uint64_t FigCaptionTextEmphasisCreateAuto(uint64_t a1, CGColor *a2, const void *a3, void *a4)
{
  return FigCaptionTextEmphasisCreate(a1, 1, 0, 0, 0, a2, a3, a4);
}

double fcte_Init(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void fcte_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  CGColorRelease(*(CGColorRef *)(a1 + 40));
  long long v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
  }
}

const void *fcte_Equal(const void *result, uint64_t a2)
{
  if (result)
  {
    long long v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
    double result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextEmphasisID)
      {
        CFTypeID v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
        if (v5 != sFigCaptionTextEmphasisID
          || *((_DWORD *)v3 + 4) != *(_DWORD *)(a2 + 16)
          || *((_DWORD *)v3 + 5) != *(_DWORD *)(a2 + 20)
          || *((_DWORD *)v3 + 6) != *(_DWORD *)(a2 + 24))
        {
          return 0;
        }
        double result = (const void *)FigCFEqual(*((CFTypeRef *)v3 + 4), *(CFTypeRef *)(a2 + 32));
        if (!result) {
          return result;
        }
        if (FigCFEqual(*((CFTypeRef *)v3 + 6), *(CFTypeRef *)(a2 + 48))) {
          return (const void *)CGColorEqualToColor(*((CGColorRef *)v3 + 5), *(CGColorRef *)(a2 + 40));
        }
        uint64_t v6 = (const void *)*((void *)v3 + 6);
        if (v6)
        {
          if (*(void *)(a2 + 48)) {
            return 0;
          }
        }
        else
        {
          if (FigCFEqual(*(CFTypeRef *)(a2 + 48), @"RubyPositionNone")) {
            return (const void *)CGColorEqualToColor(*((CGColorRef *)v3 + 5), *(CGColorRef *)(a2 + 40));
          }
          if (*(void *)(a2 + 48)) {
            return 0;
          }
          uint64_t v6 = (const void *)*((void *)v3 + 6);
        }
        double result = (const void *)FigCFEqual(v6, @"RubyPositionNone");
        if (result) {
          return (const void *)CGColorEqualToColor(*((CGColorRef *)v3 + 5), *(CGColorRef *)(a2 + 40));
        }
      }
    }
  }
  return result;
}

CFHashCode fcte_Hash(void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
  if (v2 != sFigCaptionTextEmphasisID) {
    return 0;
  }
  long long v3 = (const void *)a1[6];
  if (v3) {
    CFHashCode v4 = CFHash(v3);
  }
  else {
    CFHashCode v4 = 0;
  }
  CFTypeID v5 = (const void *)a1[4];
  if (v5) {
    v4 ^= CFHash(v5);
  }
  uint64_t v6 = (const void *)a1[5];
  if (v6) {
    v4 ^= CFHash(v6);
  }
  return v4;
}

CFStringRef fcte_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextEmphasis %p]", a1);
}

CFStringRef fcte_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[FigCaptionTextEmphasis %p]", a1);
}

OSStatus CMAudioClockCreate(CFAllocatorRef allocator, CMClockRef *clockOut)
{
  if (FigPreferAudioSessionClock())
  {
    uint64_t v7 = 0;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2020000000;
    CFHashCode v4 = (uint64_t (*)(CFAllocatorRef, void, CMClockRef *))getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr;
    size_t v10 = getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr;
    if (!getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr)
    {
      CFTypeID v5 = (void *)MediaToolboxLibrary();
      _OWORD v8[3] = (uint64_t)dlsym(v5, "FigAudioSessionClockCreateForSharedAudioSession");
      getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr = (_UNKNOWN *)v8[3];
      CFHashCode v4 = (uint64_t (*)(CFAllocatorRef, void, CMClockRef *))v8[3];
    }
    _Block_object_dispose(&v7, 8);
    if (!v4) {
      CMAudioClockCreate_cold_1();
    }
    return v4(allocator, 0, clockOut);
  }
  else
  {
    return CMAudioDeviceClockCreate(allocator, 0, clockOut);
  }
}

void sub_18FD9FA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CMAudioClockCreateForAudioSession(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr;
  CFTypeID v14 = getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr;
  if (!getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr)
  {
    uint64_t v9 = (void *)MediaToolboxLibrary();
    v12[3] = (uint64_t)dlsym(v9, "FigAudioSessionClockCreateForAVAudioSession");
    getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr = (_UNKNOWN *)v12[3];
    uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v12[3];
  }
  _Block_object_dispose(&v11, 8);
  if (!v8) {
    CMAudioClockCreateForAudioSession_cold_1();
  }
  return v8(a1, a2, a3, a4);
}

void sub_18FD9FB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_block_invoke(uint64_t a1)
{
  CFTypeID v2 = (void *)MediaToolboxLibrary();
  double result = dlsym(v2, "FigAudioSessionClockCreateForSharedAudioSession");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                 + 24);
  return result;
}

uint64_t MediaToolboxLibrary()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!MediaToolboxLibraryCore_frameworkLibrary_0)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    v2[2] = (void *)3221225472;
    v2[3] = __MediaToolboxLibraryCore_block_invoke_0;
    v2[4] = &__block_descriptor_40_e5_v8__0l;
    v2[5] = v2;
    long long v3 = xmmword_1E5679138;
    uint64_t v4 = 0;
    MediaToolboxLibraryCore_frameworkLibrary_0 = _sl_dlopen();
  }
  uint64_t v0 = MediaToolboxLibraryCore_frameworkLibrary_0;
  if (!MediaToolboxLibraryCore_frameworkLibrary_0) {
    MediaToolboxLibrary_cold_1(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t __MediaToolboxLibraryCore_block_invoke_0()
{
  uint64_t result = _sl_dlopen();
  MediaToolboxLibraryCore_frameworkLibrary_0 = result;
  return result;
}

void *__getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_block_invoke(uint64_t a1)
{
  CFTypeID v2 = (void *)MediaToolboxLibrary();
  uint64_t result = dlsym(v2, "FigAudioSessionClockCreateForAVAudioSession");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                             + 24);
  return result;
}

void FigDebugAssert(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
}

void figDebugAssertCommon(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a8;
  char v9 = a7;
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  CFTypeID v14 = "(Fig)";
  if (a1) {
    LOBYTE(v14) = a1;
  }
  size_t v15 = safe_snprintf(v32, 0x400uLL, "%s ", a4, a5, a6, a7, a8, (char)v14);
  size_t v21 = v15;
  if (a2) {
    size_t v21 = safe_snprintf(&v32[v15], 1024 - v15, "assert: \"%s\" ", v16, v17, v18, v19, v20, a2) + v15;
  }
  if (a3 | a5)
  {
    v21 += safe_snprintf(&v32[v21], 1024 - v21, "at ", v16, v17, v18, v19, v20, v31);
    if (a3) {
      v21 += safe_snprintf(&v32[v21], 1024 - v21, "%s ", v16, v17, v18, v19, v20, a3);
    }
    if (a5) {
      v21 += safe_snprintf(&v32[v21], 1024 - v21, "(%s line %d) ", v16, v17, v18, v19, v20, a5);
    }
  }
  size_t v27 = safe_snprintf(&v32[v21], 1024 - v21, "- ", v16, v17, v18, v19, v20, v31) + v21;
  if (a4) {
    v27 += safe_snprintf(&v32[v27], 1024 - v27, "%s ", v22, v23, v24, v25, v26, a4);
  }
  safe_snprintf(&v32[v27], 1024 - v27, "(err=%d)", v22, v23, v24, v25, v26, v9);
  if (v8) {
    syslog(3, "%s", v32);
  }
  else {
    fig_log(2u, 1, 0, 0, "%s", v28, v29, v30, (uint64_t)v32);
  }
}

void FigDebugAssertSyslog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
}

void FigDebugAssert2(const char *a1, const char *a2)
{
  uint64_t v4 = fmtcheck(a1, "%s assert: \"%s\" at %s (%s:%d) - %s (err=%d)");
  uint64_t v6 = "(Fig)";
  if (a2) {
    uint64_t v6 = a2;
  }
  fig_log_with_return_address(0, 2u, 1, 0, 0, v2, v4, v5, (uint64_t)v6);
}

void FigDebugAssert3(const char *a1, uint64_t *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12 = fmtcheck(a1, "%s assert: \"%s\" at %s (%s:%d) - %s%s(err=%d)");
  CFTypeID v14 = "(Fig)";
  if (a3) {
    CFTypeID v14 = a3;
  }
  fig_log_with_return_address(a2, 2u, 1, 0, 0, a10, v12, v13, (uint64_t)v14);
}

uint64_t FigDebugAssertSyslog2()
{
  return CallOSLogWithArgs();
}

uint64_t CallOSLogWithArgs()
{
  return os_log_with_args();
}

void FigUserCrashWithMessage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  va_list v14 = 0;
  bzero(buffer, 0x400uLL);
  va_list v14 = (va_list)&a9;
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef SignaledErrorInfo = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u);
  if (!SignaledErrorInfo)
  {
    FigAtomicIncrement32(&gErrorCount);
    CFStringRef SignaledErrorInfo = (const __CFString *)figRecordLastSignaledErrorInfo(-12786, 0, 0, 0, 0, 0, 0);
    __break(1u);
  }
  CFStringRef v12 = CFStringCreateWithFormatAndArguments(v10, 0, SignaledErrorInfo, v14);
  CFStringGetCString(v12, buffer, 1024, 0x8000100u);
  qword_1E9271400 = (uint64_t)buffer;
  if (v12) {
    CFRelease(v12);
  }
  __break(1u);
}

uint64_t FigUserFaultWithMessage(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)) {
    FigUserFaultWithMessage_cold_1(a2, a1);
  }
  return 1;
}

uint64_t FigUserStackshotWithMessage(uint64_t a1, uint64_t a2)
{
  if (FigUserStackshotWithMessage_nonce != -1) {
    dispatch_once(&FigUserStackshotWithMessage_nonce, &__block_literal_global_16);
  }
  if (!FigUserStackshotWithMessage_stackshotsEnabled) {
    return 0;
  }
  uint64_t v4 = getpid();

  return MEMORY[0x1F4116EC0](a2, a1, v4);
}

uint64_t __FigUserStackshotWithMessage_block_invoke()
{
  uint64_t result = FigGetCFPreferenceNumberWithDefault(@"take_stackshots", @"com.apple.coremedia", 1);
  FigUserStackshotWithMessage_stackshotsEnabled = result;
  return result;
}

uint64_t FigUserTailspinWithMessage()
{
  return 0;
}

void FigUserBreak()
{
  int v0 = FigUserBreak_userbreak;
  if (FigUserBreak_userbreak == 85)
  {
    CFNumberRef v1 = getenv("USERBREAK");
    int v0 = v1 && !strcmp(v1, "1");
    FigUserBreak_userbreaint k = v0;
  }
  if (v0) {
    __break(1u);
  }
}

uint64_t FigCopyBacktrace(const __CFAllocator *a1, CFArrayRef *a2, __CFArray **a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v42 = 0;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  int v6 = backtrace(v17, 51);
  CFIndex v7 = v6 - (v6 > 0);
  if (a2 && (int)v7 >= 1) {
    *a2 = CFArrayCreate(a1, (const void **)&v17[1], v7, 0);
  }
  if (a3 && (int)v7 >= 1)
  {
    int v8 = (const void **)&v17[1];
    char v9 = backtrace_symbols(&v17[1], v7);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, v7, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFIndex v11 = v7;
      CFStringRef v12 = v9;
      do
      {
        uint64_t v13 = *v8;
        memset(&v16, 0, sizeof(v16));
        dladdr(v13, &v16);
        CFStringRef v14 = CFStringCreateWithFormat(a1, 0, @"%s    [%p + %td]", *v12, v16.dli_fbase, (unsigned char *)v13 - (char *)v16.dli_fbase);
        CFArrayAppendValue(Mutable, v14);
        if (v14) {
          CFRelease(v14);
        }
        ++v12;
        ++v8;
        --v11;
      }
      while (v11);
    }
    free(v9);
    *a3 = Mutable;
  }
  return (int)v7;
}

void FigLogBacktraceFrames()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  CFArrayRef v7 = (const __CFArray *)v0;
  *(void *)&v59[26] = *MEMORY[0x1E4F143B8];
  if (v1 && *v1)
  {
    size_t v8 = safe_snprintf(v58, 0x1000uLL, "%s\n", v2, v3, v4, v5, v6, (char)v1);
    if (!v7)
    {
LABEL_4:
      char v9 = &v58[v8];
      size_t v10 = 4096 - v8;
      CFIndex v11 = "FigLogBacktrace passed NULL backtrace";
LABEL_18:
      safe_snprintf(v9, v10, v11, v2, v3, v4, v5, v6, (char)v31);
      goto LABEL_19;
    }
  }
  else
  {
    size_t v8 = 0;
    if (!v0) {
      goto LABEL_4;
    }
  }
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  *(_OWORD *)values = 0u;
  CFIndex Count = CFArrayGetCount(v7);
  if (Count < 50)
  {
    uint64_t v18 = Count;
  }
  else
  {
    v8 += safe_snprintf(&v58[v8], 4096 - v8, "Too many frames\n", v13, v14, v15, v16, v17, (char)v31);
    uint64_t v18 = 50;
  }
  v60.CFIndex location = 0;
  v60.CFIndex length = v18;
  CFArrayGetValues(v7, v60, (const void **)values);
  long long v19 = backtrace_symbols(values, v18);
  if (v19)
  {
    long long v20 = v19;
    if (v18 >= 1)
    {
      long long v21 = values;
      long long v22 = v19;
      uint64_t v23 = v18;
      do
      {
        long long v24 = *v21++;
        memset(&v32, 0, sizeof(v32));
        dladdr(v24, &v32);
        uint64_t v25 = (uint64_t)*v22++;
        v8 += safe_snprintf(&v58[v8], 4096 - v8, "%s    [%p + %td]\n", v26, v27, v28, v29, v30, v25);
        --v23;
      }
      while (v23);
    }
    free(v20);
  }
  if (v8 == 4096 || v18 >= 50 && v8 - 4074 <= 0x16)
  {
    char v9 = v59;
    long long v31 = "FigBacktrace Truncated";
    CFIndex v11 = " - %s";
    size_t v10 = 26;
    goto LABEL_18;
  }
  if (v18 >= 50) {
    safe_snprintf(&v58[v8], 4096 - v8, "%s", v2, v3, v4, v5, v6, (char)"FigBacktrace Truncated");
  }
LABEL_19:
  fig_log(1u, 1, 0, 0, "%s", v4, v5, v6, (uint64_t)v58);
}

size_t safe_snprintf(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  LODWORD(result) = vsnprintf(a1, a2, a3, &a9);
  if (a2 - 1 >= (int)result) {
    return (int)result;
  }
  else {
    return a2 - 1;
  }
}

void FigLogBacktrace()
{
  MEMORY[0x1F4188790]();
  uint64_t v1 = v0;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  long long v29 = 0u;
  v27[0] = 0;
  int v2 = backtrace((void **)&v29, 51);
  unsigned int v8 = v2 - 2;
  if (v2 > 2)
  {
    char v9 = backtrace_symbols((void *const *)v30, v8);
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      memset(&v26, 0, sizeof(v26));
      dladdr(*(const void **)((char *)v30 + v10 * 8), &v26);
      if (v9) {
        uint64_t v17 = v9[v10];
      }
      else {
        uint64_t v17 = "?";
      }
      v11 += safe_snprintf(&v27[v11], 4096 - v11, "%s    [%p + %td]\n", v12, v13, v14, v15, v16, (char)v17);
      ++v10;
    }
    while (v8 != v10);
    if (v11 == 4096) {
      safe_snprintf(v28, 0x19uLL, "%s", v18, v19, v20, v21, v22, (char)" - FigBacktrace Truncated");
    }
    uint64_t v1 = v0;
  }
  else
  {
    safe_snprintf(v27, 0x1000uLL, "Not enough frames to display", v3, v4, v5, v6, v7, v25);
    char v9 = 0;
  }
  excessive_emitter_for_subsysteuint64_t m = fig_log_get_excessive_emitter_for_subsystem("com.apple.coremedia");
  fig_log_with_return_address(excessive_emitter_for_subsystem, 1u, 1, 0, 0, v1, "%s", v24, (uint64_t)v27);
  free(v9);
}

uint64_t FigCopyLastSignaledErrorInfo(_DWORD *a1, CFStringRef *a2, CFStringRef *a3, CFStringRef *a4, CFStringRef *a5, CFStringRef *a6, void *a7, _OWORD *a8)
{
  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1) {
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_42_0);
  }
  FigSimpleMutexLock((pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock);
  if (a1) {
    *a1 = sLastError;
  }
  uint64_t v16 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (a2) {
    *a2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], byte_1EB28B7BC, 0);
  }
  if (a3) {
    *a3 = CFStringCreateWithCString(*v16, byte_1EB28B7DC, 0);
  }
  if (a4) {
    *a4 = CFStringCreateWithCString(*v16, byte_1EB28B85C, 0);
  }
  if (a5) {
    *a5 = CFStringCreateWithCString(*v16, byte_1EB28B87C, 0);
  }
  if (a6) {
    *a6 = CFStringCreateWithCString(*v16, byte_1EB28B8BC, 0);
  }
  if (a7) {
    *a7 = qword_1EB28B900;
  }
  if (a8) {
    *a8 = xmmword_1EB28B908;
  }
  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1) {
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_42_0);
  }
  uint64_t v17 = (pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock;

  return FigSimpleMutexUnlock(v17);
}

uint64_t figRecordLastSignaledErrorInfo(int a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7)
{
  if (a5) {
    char v9 = a5;
  }
  else {
    char v9 = "";
  }
  if (a6) {
    uint64_t v10 = a6;
  }
  else {
    uint64_t v10 = "";
  }
  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1) {
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_42_0);
  }
  FigSimpleMutexLock((pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock);
  sLastError = a1;
  __strlcpy_chk();
  __strlcpy_chk();
  __strlcpy_chk();
  size_t v11 = strlen(v9);
  if (v11 >= 0x3F) {
    uint64_t v12 = 63;
  }
  else {
    uint64_t v12 = v11;
  }
  __memcpy_chk();
  byte_1EB28B87C[v12] = 0;
  size_t v13 = strlen(v10);
  if (v13 >= 0x3F) {
    uint64_t v14 = 63;
  }
  else {
    uint64_t v14 = v13;
  }
  __memcpy_chk();
  byte_1EB28B8BC[v14] = 0;
  qword_1EB28B900 = a7;
  gettimeofday((timeval *)&xmmword_1EB28B908, 0);
  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1) {
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_42_0);
  }
  uint64_t v15 = (pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock;

  return FigSimpleMutexUnlock(v15);
}

uint64_t FigSignalErrorAt2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, const char *a7, uint64_t a8)
{
  return a2;
}

uint64_t FigSignalErrorAt3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7, const char *a8, uint64_t a9)
{
  return a3;
}

uint64_t FigGetErrorCount()
{
  return gErrorCount;
}

void *FigDebugGetDefaultLogEmitter(const char *a1)
{
  return fig_log_get_emitter(a1, 0);
}

uint64_t FigDebugSettingGetKeyAsBoolean(const __CFString *a1, Boolean *a2, Boolean a3)
{
  Boolean keyExistsAndHasValidFormat = 0;
  AppBooleanCFNumberRef Value = CFPreferencesGetAppBooleanValue(a1, @"com.apple.coremedia", &keyExistsAndHasValidFormat);
  uint64_t v6 = keyExistsAndHasValidFormat;
  if (keyExistsAndHasValidFormat) {
    Boolean v7 = AppBooleanValue;
  }
  else {
    Boolean v7 = a3;
  }
  *a2 = v7;
  return v6;
}

uint64_t FigDebugGetAdoptedVoucherProcessIDAndUUIDString(char *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  uuid_unparse_lower(uu, a1);
  long long v5 = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  if (proc_pidoriginatorinfo() != 48) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = v5;
  uuid_copy(uu, (const unsigned __int8 *)&v4);
  uuid_unparse_lower(uu, a1);
  return v2;
}

uint64_t FigSysdiagnoseBlock_OneTimeInitializationForMediaserverd()
{
  if (InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce != -1) {
    dispatch_once(&InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce, &__block_literal_global_45);
  }
  return os_state_add_handler();
}

void FigInstallSysdiagnoseBlock(uint64_t a1, uint64_t a2)
{
  if (InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce != -1) {
    dispatch_once(&InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce, &__block_literal_global_45);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = __FigInstallSysdiagnoseBlock_block_invoke;
  v4[3] = &unk_1E5679198;
  v4[4] = a2;
  void v4[5] = a1;
  dispatch_sync((dispatch_queue_t)gFigSysdiagnoseBlockRegistry_0, v4);
}

void __FigInstallSysdiagnoseBlock_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  uint64_t v1 = *(const void **)(a1 + 40);
  if (v2) {
    CFDictionarySetValue((CFMutableDictionaryRef)gFigSysdiagnoseBlockRegistry_1, v1, v2);
  }
  else {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)gFigSysdiagnoseBlockRegistry_1, v1);
  }
}

uint64_t FigIsItOKToLogURLs()
{
  if (sOKToLogURLs_DetermineInitialValueOnce != -1) {
    dispatch_once_f(&sOKToLogURLs_DetermineInitialValueOnce, 0, (dispatch_function_t)DetermineInitialValueForOKToLogURLs);
  }
  return sOKToLogURLs;
}

uint64_t DetermineInitialValueForOKToLogURLs()
{
  if (FigDebugIsInternalBuild_onceToken != -1) {
    dispatch_once(&FigDebugIsInternalBuild_onceToken, &__block_literal_global_29);
  }
  uint64_t result = FigGetCFPreferenceNumberWithDefault(@"logurls", @"com.apple.coremedia", FigDebugIsInternalBuild_isInternalBuild);
  sOKToLogURLs = result;
  return result;
}

uint64_t FigDebugIsInternalBuild()
{
  if (FigDebugIsInternalBuild_onceToken != -1) {
    dispatch_once(&FigDebugIsInternalBuild_onceToken, &__block_literal_global_29);
  }
  return FigDebugIsInternalBuild_isInternalBuild;
}

uint64_t __FigDebugIsInternalBuild_block_invoke()
{
  uint64_t result = os_variant_has_internal_diagnostics();
  FigDebugIsInternalBuild_isInternalBuild = result;
  return result;
}

uint64_t FigIsCompiledForLightweightAssetRuntime()
{
  return 0;
}

pthread_mutex_t *__figGetSignalErrorLatchLock_block_invoke()
{
  CFAllocatorRef AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  uint64_t result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  figGetSignalErrorLatchLock_sListLocint k = (uint64_t)result;
  return result;
}

CFMutableDictionaryRef __InitializeSysdiagnoseBlockRegistry_block_invoke()
{
  CFDictionaryValueCallBacks v1 = *(CFDictionaryValueCallBacks *)byte_1EDF6ED00;
  gFigSysdiagnoseBlockRegistry_0 = (uint64_t)dispatch_queue_create("FigSysdiagnoseBlockRegistryQueue", 0);
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], &v1);
  gFigSysdiagnoseBlockRegistry_1 = (uint64_t)result;
  return result;
}

void *SysdiagnoseBlockDictionaryRetain(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void SysdiagnoseBlockDictionaryRelease(int a1, void *aBlock)
{
}

uint64_t SysdiagnoseBlockDictionaryApplierFunction(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  return result;
}

uint64_t CMTimeSyncClockCreateForSystemDomainClockIdentifier(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  CMClockRef HostTimeClock = CMClockGetHostTimeClock();
  if (sTimeSyncFunctionsLoadedOnce != -1)
  {
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce, 0, (dispatch_function_t)LoadTimeSyncFunctions);
    if (a2) {
      goto LABEL_3;
    }
LABEL_21:
    uint64_t v5 = 4294954551;
    goto LABEL_22;
  }
  if (!a2) {
    goto LABEL_21;
  }
LABEL_3:
  if (!CM8021ASClockEnsureTimeSyncServices())
  {
    CMTimeMake(&v22, 1, 10);
    uint64_t TimeCallback = FigDerivedClockCreateWithGetTimeCallback(a1, gFigTimeSyncClockCallbacks, HostTimeClock, (long long *)&v22.value, 1, (uint64_t *)&cf);
    if (TimeCallback)
    {
      uint64_t v7 = TimeCallback;
      CFTypeRef v8 = 0;
      goto LABEL_23;
    }
    CFTypeRef v8 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
    if (!v8) {
      goto LABEL_19;
    }
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)cf);
    *(void *)uint64_t DerivedStorage = FigSimpleMutexCreate();
    if (HostTimeClock) {
      CFTypeRef v10 = CFRetain(HostTimeClock);
    }
    else {
      CFTypeRef v10 = 0;
    }
    *(void *)(DerivedStorage + 8) = v10;
    *(void *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = *(void *)sTSNullgPTPClockIdentity;
    *(void *)(DerivedStorage + 112) = 0;
    *(_OWORD *)(DerivedStorage + 96) = *(_OWORD *)&kCMTimeZero.value;
    *(void *)(DerivedStorage + 88) = 0;
    *(_OWORD *)(DerivedStorage + 72) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(DerivedStorage + 64) = 0;
    *(_OWORD *)(DerivedStorage + 48) = *(_OWORD *)&kCMTimeInvalid.value;
    *(void *)(DerivedStorage + 24) = CFRetain(v8);
    *(unsigned char *)(DerivedStorage + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    uint64_t v11 = sTimeSyncSystemDomainClockIdentifier();
    *(void *)(DerivedStorage + 32) = v11;
    if (v11 == *(void *)sTSNullClockIdentifier)
    {
      uint64_t v7 = 4294954540;
      goto LABEL_23;
    }
    uint64_t v12 = sTimeSyncClockCreateWithClockIdentifer();
    *(void *)(DerivedStorage + 16) = v12;
    if (!v12)
    {
LABEL_19:
      uint64_t v7 = 4294954549;
      goto LABEL_23;
    }
    sTimeSyncClockSetLockStateChangeCallback(v12, figTimeSyncClock_LockStateDidChange, *(void *)(DerivedStorage + 24));
    sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallback(*(void *)(DerivedStorage + 16), figTimeSyncClock_MasterAndPortDidChange, *(void *)(DerivedStorage + 24));
    sTimeSyncClockSetTimeSyncTimeChangeCallback(*(void *)(DerivedStorage + 16), figTimeSyncClock_TimeSyncTimeDidChange, *(void *)(DerivedStorage + 24));
    size_t v13 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
    if (figTimeSyncClock_periodicTasksInit_onceToken != -1) {
      dispatch_once_f(&figTimeSyncClock_periodicTasksInit_onceToken, 0, (dispatch_function_t)figTimeSyncClock_periodicTasksInitOnce);
    }
    dispatch_async_f((dispatch_queue_t)gPeriodicTasksQueue, v13, (dispatch_function_t)figTimeSyncClock_addClockToPeriodicTasksInternal);
    if (sLogCreatedOnce != -1) {
      dispatch_once(&sLogCreatedOnce, &__block_literal_global_17);
    }
    *(void *)(DerivedStorage + 128) = os_signpost_id_generate((os_log_t)sLog);
LABEL_28:
    if (dword_1E9272EF8)
    {
      int v21 = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272EF0, 1, &v21, &type);
      int v16 = v21;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v18 = v16;
      }
      else {
        unsigned int v18 = v16 & 0xFFFFFFFE;
      }
      if (v18)
      {
        int v24 = 136315394;
        char v25 = "CMTimeSyncClockCreateForSystemDomainClockIdentifier";
        __int16 v26 = 2048;
        CFTypeRef v27 = cf;
        uint64_t v19 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v16) = v21;
      }
      else
      {
        uint64_t v19 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272EF0, 1u, 1, v19, v19 != &v28, v16, 0, v17);
    }
    uint64_t v7 = 0;
    *a2 = cf;
    CFTypeRef cf = 0;
    if (v8) {
      goto LABEL_26;
    }
    return v7;
  }
  uint64_t v5 = 4294951236;
LABEL_22:
  uint64_t v7 = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  CFTypeRef v8 = 0;
  if (!v7) {
    goto LABEL_28;
  }
LABEL_23:
  if (cf) {
    CFRelease(cf);
  }
  if (v8) {
LABEL_26:
  }
    CFRelease(v8);
  return v7;
}

void *LoadTimeSyncFunctions()
{
  unsigned int v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimeSyncClockTrace[1], @"timesync_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigTimeSyncClockTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1E9272EF8, @"timesync_trace", @"com.apple.coremedia", (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1E9272EF0);
  CFDictionaryValueCallBacks v1 = dlopen("/System/Library/PrivateFrameworks/TimeSync.framework/TimeSync", 4);
  if (!v1) {
    goto LABEL_24;
  }
  uint64_t v2 = v1;
  sTSNullClockIdentifier = (uint64_t)dlsym(v1, "TSNullClockIdentifier");
  if (!sTSNullClockIdentifier) {
    goto LABEL_24;
  }
  sTSNullgPTPClockIdentitCGFloat y = (uint64_t)dlsym(v2, "TSNullgPTPClockIdentity");
  if (!sTSNullgPTPClockIdentity) {
    goto LABEL_24;
  }
  sTimeSyncAddgPTPServicesSync = (uint64_t)dlsym(v2, "TimeSyncAddgPTPServicesSync");
  if (!sTimeSyncAddgPTPServicesSync) {
    goto LABEL_24;
  }
  sTimeSyncRemovegPTPServices = (uint64_t)dlsym(v2, "TimeSyncRemovegPTPServices");
  if (!sTimeSyncRemovegPTPServices) {
    goto LABEL_24;
  }
  sTimeSyncClockCreateWithClockIdentifer = dlsym(v2, "TimeSyncClockCreateWithClockIdentifer");
  if (!sTimeSyncClockCreateWithClockIdentifer) {
    goto LABEL_24;
  }
  sTimeSyncClockDispose = dlsym(v2, "TimeSyncClockDispose");
  if (!sTimeSyncClockDispose) {
    goto LABEL_24;
  }
  sTimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime = (uint64_t)dlsym(v2, "TimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime");
  if (!sTimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime) {
    goto LABEL_24;
  }
  sTimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime = dlsym(v2, "TimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime");
  if (!sTimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime) {
    goto LABEL_24;
  }
  sTimeSyncClockGetClockFloat64 Rate = dlsym(v2, "TimeSyncClockGetClockRate");
  if (!sTimeSyncClockGetClockRate) {
    goto LABEL_24;
  }
  sTimeSyncClockGetLockState = (uint64_t)dlsym(v2, "TimeSyncClockGetLockState");
  if (!sTimeSyncClockGetLockState) {
    goto LABEL_24;
  }
  sTimeSyncClockGetgPTPGrandmasterIdentitCGFloat y = dlsym(v2, "TimeSyncClockGetgPTPGrandmasterIdentity");
  if (!sTimeSyncClockGetgPTPGrandmasterIdentity) {
    goto LABEL_24;
  }
  sTimeSyncSystemDomainClockIdentifier = dlsym(v2, "TimeSyncSystemDomainClockIdentifier");
  if (!sTimeSyncSystemDomainClockIdentifier) {
    goto LABEL_24;
  }
  sTimeSyncClockSetLockStateChangeCallbacint k = dlsym(v2, "TimeSyncClockSetLockStateChangeCallback");
  if (!sTimeSyncClockSetLockStateChangeCallback) {
    goto LABEL_24;
  }
  sTimeSyncClockSetgPTPGrandmasterChangeCallbacint k = (uint64_t)dlsym(v2, "TimeSyncClockSetgPTPGrandmasterChangeCallback");
  if (!sTimeSyncClockSetgPTPGrandmasterChangeCallback) {
    goto LABEL_24;
  }
  sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallbacint k = dlsym(v2, "TimeSyncClockSetgPTPGrandmasterAndPortChangeCallback");
  if (!sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallback) {
    goto LABEL_24;
  }
  sTimeSyncClockSetTimeSyncTimeChangeCallbacint k = dlsym(v2, "TimeSyncClockSetTimeSyncTimeChangeCallback");
  if (!sTimeSyncClockSetTimeSyncTimeChangeCallback
    || (sTimeSyncClockAddUDPv4EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv4EndToEndPort")) == 0
    || (sTimeSyncClockRemoveUDPv4EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockRemoveUDPv4EndToEndPort")) == 0
    || (sTimeSyncClockAddUDPv6EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv6EndToEndPort")) == 0
    || (sTimeSyncClockRemoveUDPv6EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockRemoveUDPv6EndToEndPort")) == 0
    || (sTimeSyncClockAddAWDLPort = (uint64_t)dlsym(v2, "TimeSyncClockAddAWDLPort")) == 0
    || (uint64_t result = dlsym(v2, "TimeSyncClockRemoveAWDLPort"), (sTimeSyncClockRemoveAWDLPort = (uint64_t)result) == 0))
  {
LABEL_24:
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

void figTimeSyncClock_LockStateDidChange(uint64_t a1, id *a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  long long v4 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)v4);
    if (a3 == 2)
    {
      uint64_t v7 = DerivedStorage;
      int v8 = *(unsigned __int8 *)(DerivedStorage + 120);
      if (dword_1E9272EF8)
      {
        v17[0] = 0;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272EF0, 1, v17, &type);
        int v10 = v17[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
          unsigned int v12 = v10;
        }
        else {
          unsigned int v12 = v10 & 0xFFFFFFFE;
        }
        if (v12)
        {
          v17[1] = 136315650;
          unsigned int v18 = "figTimeSyncClock_LockStateDidChange";
          __int16 v19 = 2048;
          uint64_t v20 = v5;
          __int16 v21 = 1024;
          int v22 = v8;
          size_t v13 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v17[0];
        }
        else
        {
          size_t v13 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272EF0, 1u, 1, v13, v13 != &v23, v10, 0, v11);
      }
      figTimeSyncClock_getAnchorTimeWithResync(v5, v8, 0, 0);
      *(unsigned char *)(v7 + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
    }
  }
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figTimeSyncClock_LockStateDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_36;
  void block[4] = v5;
  dispatch_async(global_queue, block);
}

void figTimeSyncClock_MasterAndPortDidChange(uint64_t a1, id *a2, uint64_t a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  long long v6 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  if (v6)
  {
    if (dword_1E9272EF8)
    {
      v15[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272EF0, 1, v15, &type);
      int v8 = v15[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v10 = v8;
      }
      else {
        unsigned int v10 = v8 & 0xFFFFFFFE;
      }
      if (v10)
      {
        v15[1] = 136315906;
        int v16 = "figTimeSyncClock_MasterAndPortDidChange";
        __int16 v17 = 2048;
        unsigned int v18 = v6;
        __int16 v19 = 2048;
        uint64_t v20 = a3;
        __int16 v21 = 1024;
        int v22 = a4;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v8) = v15[0];
      }
      else
      {
        uint64_t v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272EF0, 1u, 1, v11, v11 != &v23, v8, 0, v9);
    }
    figTimeSyncClock_getAnchorTimeWithResync((uint64_t)v6, 1, 0, 0);
  }
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figTimeSyncClock_MasterAndPortDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_37;
  void block[4] = v6;
  dispatch_async(global_queue, block);
}

void figTimeSyncClock_TimeSyncTimeDidChange(uint64_t a1, id *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)v2);
    if (dword_1E9272EF8)
    {
      v13[0] = 0;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272EF0, 1, v13, &type);
      int v6 = v13[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
        unsigned int v8 = v6;
      }
      else {
        unsigned int v8 = v6 & 0xFFFFFFFE;
      }
      if (v8)
      {
        v13[1] = 136315394;
        uint64_t v14 = "figTimeSyncClock_TimeSyncTimeDidChange";
        __int16 v15 = 2048;
        int v16 = v3;
        uint64_t v9 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v6) = v13[0];
      }
      else
      {
        uint64_t v9 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272EF0, 1u, 1, v9, v9 != &v17, v6, 0, v7);
    }
    *(unsigned char *)(DerivedStorage + 12CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 1;
  }
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __figTimeSyncClock_TimeSyncTimeDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_38;
  void block[4] = v3;
  dispatch_async(global_queue, block);
}

os_log_t __CMTimeSyncClockCreateForSystemDomainClockIdentifier_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coremedia", "FigTimeSyncClock");
  sLog = (uint64_t)result;
  return result;
}

CFStringRef figTimeSyncClock_CopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  uint64_t v3 = *(void *)(DerivedStorage + 40);
  uint64_t v4 = *(void *)sTSNullgPTPClockIdentity;
  CFAllocatorRef v5 = CFGetAllocator(a1);
  if (v3 == v4)
  {
    uint64_t v6 = 0;
    uint64_t v7 = "not locked";
  }
  else
  {
    uint64_t v6 = *(void *)(DerivedStorage + 40);
    uint64_t v7 = "locked";
  }
  CFStringRef v8 = CFStringCreateWithFormat(v5, 0, @"CMTimeSyncClock %s, GM=0x%016llx"), v7, v6);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

pthread_mutex_t **figTimeSyncClock_Finalize(uint64_t a1)
{
  os_log_t result = (pthread_mutex_t **)FigDerivedClockGetDerivedStorage(a1);
  uint64_t v2 = *result;
  if (*result)
  {
    uint64_t v3 = result;
    FigSimpleMutexLock(*result);
    uint64_t v4 = v3[1];
    if (v4) {
      CFRelease(v4);
    }
    CFAllocatorRef v5 = v3[2];
    if (v5)
    {
      sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallback(v5, 0, 0);
      sTimeSyncClockSetLockStateChangeCallback(v3[2], 0, 0);
      sTimeSyncClockSetTimeSyncTimeChangeCallback(v3[2], 0, 0);
      sTimeSyncClockDispose(v3[2]);
    }
    uint64_t v6 = v3[3];
    if (v6) {
      CFRelease(v6);
    }
    *uint64_t v3 = 0;
    FigSimpleMutexUnlock(v2);
    return (pthread_mutex_t **)FigSimpleMutexDestroy((uint64_t)v2);
  }
  return result;
}

BOOL figTimeSyncClock_MightDrift(uint64_t a1, uint64_t a2)
{
  if (!FigDerivedClockVerifyCallbacksMatch(a1, (uint64_t)gFigTimeSyncClockCallbacks)
    || !FigDerivedClockVerifyCallbacksMatch(a2, (uint64_t)gFigTimeSyncClockCallbacks))
  {
    return 1;
  }
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v5 = FigDerivedClockGetDerivedStorage(a2);
  uint64_t v6 = sTimeSyncClockGetgPTPGrandmasterIdentity(*(void *)(DerivedStorage + 16));
  return v6 != sTimeSyncClockGetgPTPGrandmasterIdentity(*(void *)(v5 + 16));
}

uint64_t figTimeSyncClock_GetRate(uint64_t a1)
{
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v2 = (uint64_t (*)(uint64_t))sTimeSyncClockGetClockRate;
  uint64_t v3 = *(void *)(DerivedStorage + 16);

  return v2(v3);
}

uint64_t figTimeSyncClock_GetAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  return figTimeSyncClock_getAnchorTimeWithResync(a1, 0, a2, a3);
}

uint64_t figTimeSyncClock_getAnchorTimeWithResync(uint64_t a1, int a2, CMTime *a3, CMTime *a4)
{
  uint64_t v6 = a1;
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  memset(&v52, 0, sizeof(v52));
  memset(&v51, 0, sizeof(v51));
  double v50 = 0.0;
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  CMClockGetTime(&v51, *(CMClockRef *)(DerivedStorage + 8));
  CMTime rhs = v51;
  figTimeSyncClockGetClockTimeForHostTime(v6, &rhs, &v50, &lhs);
  CMTimeValue value = lhs.value;
  CMTimeScale timescale = lhs.timescale;
  double v8 = v50;
  uint64_t v9 = 4294949326;
  if (*(void *)&v50 != *(void *)sTSNullgPTPClockIdentity)
  {
    CMTimeFlags flags = lhs.flags;
    if (lhs.flags)
    {
      long long v40 = a3;
      long long v41 = a4;
      CMTimeEpoch epoch = lhs.epoch;
      unsigned int v12 = (CMTime *)(DerivedStorage + 72);
      long long v42 = (CMTime *)DerivedStorage;
      if (*(unsigned char *)(DerivedStorage + 84))
      {
        double v13 = *(double *)(DerivedStorage + 40);
      }
      else
      {
        *(CMTime *)(DerivedStorage + 48) = v51;
        v12->CMTimeValue value = value;
        *(_DWORD *)(DerivedStorage + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = timescale;
        *(_DWORD *)(DerivedStorage + 84) = flags;
        *(void *)(DerivedStorage + 88) = epoch;
        double v13 = v8;
        *(double *)(DerivedStorage + 4CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = v8;
      }
      if (a2 || *(void *)&v8 != *(void *)&v13)
      {
        int v14 = 0;
        __int16 v15 = (double *)(DerivedStorage + 40);
        long long v45 = (CMTime *)(DerivedStorage + 48);
        long long v47 = (CMTime *)(DerivedStorage + 96);
        int v16 = dword_1E9272EF8;
        long long v44 = (CMTime *)(DerivedStorage + 72);
        long long v46 = (double *)(DerivedStorage + 40);
        while (1)
        {
          if (v16)
          {
            LODWORD(v48.CFArrayAppendValue(theArray, value) = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_os_log_type_t type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272EF0, 1, (int *)&v48, &type);
            unsigned int v18 = v48.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type)) {
              unsigned int v20 = v18;
            }
            else {
              unsigned int v20 = v18 & 0xFFFFFFFE;
            }
            if (v20)
            {
              double v21 = *v15;
              LODWORD(rhs.CFArrayAppendValue(theArray, value) = 136316418;
              *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"figTimeSyncClock_getAnchorTimeWithResync";
              LOWORD(rhs.flags) = 2048;
              *(void *)((char *)&rhs.flags + 2) = v6;
              HIWORD(rhs.epoch) = 2048;
              Float64 v54 = v21;
              __int16 v55 = 2048;
              Float64 v56 = v50;
              __int16 v57 = 1024;
              *(_DWORD *)uint64_t v58 = a2;
              *(_WORD *)&v58[4] = 1024;
              *(_DWORD *)&v58[6] = v14;
              int v22 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v18) = v48.value;
            }
            else
            {
              int v22 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272EF0, 1u, 1, v22, v22 != &lhs, v18, 0, v19);
          }
          CMTime rhs = *v45;
          figTimeSyncClockGetClockTimeForHostTime(v6, &rhs, v15, &lhs);
          CMTimeValue v67 = lhs.value;
          CMTimeFlags v23 = lhs.flags;
          CMTimeScale v68 = lhs.timescale;
          if ((lhs.flags & 1) == 0) {
            break;
          }
          if (*(void *)v15 == *(void *)sTSNullgPTPClockIdentity) {
            break;
          }
          CMTimeEpoch v24 = lhs.epoch;
          CMTime rhs = *v12;
          v48.CMTimeValue value = v67;
          v48.CMTimeScale timescale = v68;
          v48.CMTimeFlags flags = lhs.flags;
          v48.CMTimeEpoch epoch = lhs.epoch;
          CMTimeSubtract(&lhs, &rhs, &v48);
          CMTime *v47 = lhs;
          CMTime rhs = v51;
          figTimeSyncClockGetClockTimeForHostTime(v6, &rhs, &v50, &lhs);
          CMTimeValue value = lhs.value;
          CMTimeFlags flags = lhs.flags;
          CMTimeScale timescale = lhs.timescale;
          if ((lhs.flags & 1) == 0) {
            break;
          }
          double v25 = v50;
          if (*(void *)&v50 == *(void *)sTSNullgPTPClockIdentity) {
            break;
          }
          CMTimeEpoch v26 = lhs.epoch;
          int v16 = dword_1E9272EF8;
          if (dword_1E9272EF8)
          {
            uint64_t v27 = v6;
            LODWORD(v48.CFArrayAppendValue(theArray, value) = 0;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            char v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1E9272EF0, 1, (int *)&v48, &type);
            unsigned int v29 = v48.value;
            if (os_log_type_enabled(v28, type)) {
              unsigned int v31 = v29;
            }
            else {
              unsigned int v31 = v29 & 0xFFFFFFFE;
            }
            if (v31)
            {
              CMTime lhs = *v44;
              Float64 Seconds = CMTimeGetSeconds(&lhs);
              lhs.CMTimeValue value = v67;
              lhs.CMTimeScale timescale = v68;
              lhs.CMTimeFlags flags = v23;
              lhs.CMTimeEpoch epoch = v24;
              Float64 v33 = CMTimeGetSeconds(&lhs);
              uint64_t v34 = *(void *)v46;
              CMTime lhs = *v47;
              Float64 v35 = CMTimeGetSeconds(&lhs);
              CMTime lhs = v51;
              Float64 v36 = CMTimeGetSeconds(&lhs);
              lhs.CMTimeValue value = value;
              lhs.CMTimeScale timescale = timescale;
              lhs.CMTimeFlags flags = flags;
              CMTimeEpoch epoch = v26;
              lhs.CMTimeEpoch epoch = v26;
              Float64 v37 = CMTimeGetSeconds(&lhs);
              LODWORD(rhs.CFArrayAppendValue(theArray, value) = 136317186;
              *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"figTimeSyncClock_getAnchorTimeWithResync";
              LOWORD(rhs.flags) = 2048;
              *(void *)((char *)&rhs.flags + 2) = v27;
              HIWORD(rhs.epoch) = 2048;
              Float64 v54 = Seconds;
              __int16 v55 = 2048;
              Float64 v56 = v33;
              __int16 v57 = 2048;
              *(void *)uint64_t v58 = v34;
              *(_WORD *)&v58[8] = 2048;
              Float64 v59 = v35;
              __int16 v60 = 2048;
              Float64 v61 = v36;
              __int16 v62 = 2048;
              Float64 v63 = v37;
              __int16 v64 = 2048;
              double v65 = v50;
              long long v38 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v29) = v48.value;
            }
            else
            {
              long long v38 = 0;
              CMTimeEpoch epoch = v26;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1E9272EF0, 1u, 1, v38, v38 != &lhs, v29, 0, v30);
            int v16 = dword_1E9272EF8;
            double v25 = v50;
            uint64_t v6 = v27;
            unsigned int v12 = v44;
          }
          else
          {
            CMTimeEpoch epoch = lhs.epoch;
          }
          __int16 v15 = v46;
          ++v14;
          if (*(void *)&v25 == *(void *)v46) {
            goto LABEL_8;
          }
        }
        uint64_t v9 = 4294949326;
        uint64_t DerivedStorage = (uint64_t)v42;
      }
      else
      {
LABEL_8:
        lhs.CMTimeValue value = value;
        lhs.CMTimeScale timescale = timescale;
        lhs.CMTimeFlags flags = flags;
        lhs.CMTimeEpoch epoch = epoch;
        uint64_t DerivedStorage = (uint64_t)v42;
        CMTime rhs = v42[4];
        CMTimeAdd(&v52, &lhs, &rhs);
        if (v40) {
          CMTime *v40 = v52;
        }
        if (v41) {
          CMTime *v41 = v51;
        }
        uint64_t v9 = 0;
        v42[2] = v51;
        *unsigned int v12 = v52;
      }
    }
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v9;
}

void figTimeSyncClockGetClockTimeForHostTime(uint64_t a1@<X0>, CMTime *a2@<X1>, void *a3@<X2>, CMTime *a4@<X8>)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = *(void *)sTSNullgPTPClockIdentity;
  *(_OWORD *)&a4->CMTimeValue value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->CMTimeEpoch epoch = 0;
  uint64_t DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  uint64_t v9 = *(void *)(DerivedStorage + 16);
  CMTime hostTime = *a2;
  uint64_t v10 = CMClockConvertHostTimeToSystemUnits(&hostTime);
  int64_t ClockTimeAndGrandmasterIdentityForHostTime = sTimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime(v9, v10, &v17);
  int64_t v12 = ClockTimeAndGrandmasterIdentityForHostTime;
  if (ClockTimeAndGrandmasterIdentityForHostTime != -1)
  {
    CMTimeMake(a4, ClockTimeAndGrandmasterIdentityForHostTime, 1000000000);
    if (a3) {
      *a3 = v17;
    }
  }
  os_signpost_id_t v13 = *(void *)(DerivedStorage + 128);
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v14 = sLog;
    if (os_signpost_enabled((os_log_t)sLog))
    {
      CMTime hostTime = *a2;
      Float64 Seconds = CMTimeGetSeconds(&hostTime);
      CMTime hostTime = *a4;
      Float64 v16 = CMTimeGetSeconds(&hostTime);
      LODWORD(hostTime.CFArrayAppendValue(theArray, value) = 134219264;
      *(CMTimeValue *)((char *)&hostTime.value + 4) = a1;
      LOWORD(hostTime.flags) = 2048;
      *(Float64 *)((char *)&hostTime.flags + 2) = Seconds;
      HIWORD(hostTime.epoch) = 2048;
      uint64_t v19 = v10;
      __int16 v20 = 2048;
      int64_t v21 = v12;
      __int16 v22 = 2048;
      Float64 v23 = v16;
      __int16 v24 = 2048;
      uint64_t v25 = v17;
      _os_signpost_emit_with_name_impl(&dword_18FD29000, v14, OS_SIGNPOST_EVENT, v13, "TimeSyncConvertTime", "clock <%p> converted hosttime %g (in system units %llu) to clocktime %llu networktime %g using GM 0x%016llx", (uint8_t *)&hostTime, 0x3Eu);
    }
  }
}

void figTimeSyncClock_addClockToPeriodicTasksInternal(void *value)
{
  CFArrayAppendValue((CFMutableArrayRef)gPeriodicTaskClocksArray, value);
  CFRelease(value);

  figTimeSyncClock_updatePeriodicTasksTimerSourceInternal();
}

CFMutableArrayRef figTimeSyncClock_periodicTasksInitOnce()
{
  gPeriodicTasksQueue = (uint64_t)FigDispatchQueueCreateWithPriority("com.apple.coremedia.cmtimesyncclockperiodictasks", 0, 0x10u);
  gPeriodicTasksSource = (uint64_t)dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, (dispatch_queue_t)gPeriodicTasksQueue);
  dispatch_source_set_timer((dispatch_source_t)gPeriodicTasksSource, 0, 0x3B9ACA00uLL, 0x1DCD6500uLL);
  dispatch_source_set_event_handler_f((dispatch_source_t)gPeriodicTasksSource, (dispatch_function_t)figTimeSyncClock_performPeriodicTasksInternal);
  gPeriodicTasksIsArmed = 0;
  CFMutableArrayRef result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  gPeriodicTaskClocksArraCGFloat y = (uint64_t)result;
  return result;
}

void figTimeSyncClock_performPeriodicTasksInternal()
{
  if (CFArrayGetCount((CFArrayRef)gPeriodicTaskClocksArray) >= 1)
  {
    CFIndex v0 = 0;
    do
    {
      CFStringRef ValueAtIndex = (id *)CFArrayGetValueAtIndex((CFArrayRef)gPeriodicTaskClocksArray, v0);
      uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject(ValueAtIndex);
      if (v2)
      {
        uint64_t v3 = v2;
        figTimeSyncClock_getAnchorTimeWithResync((uint64_t)v2, 0, 0, 0);
        CFRelease(v3);
      }
      else
      {
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)gPeriodicTaskClocksArray, v0--);
      }
      ++v0;
    }
    while (v0 < CFArrayGetCount((CFArrayRef)gPeriodicTaskClocksArray));
  }

  figTimeSyncClock_updatePeriodicTasksTimerSourceInternal();
}

void figTimeSyncClock_updatePeriodicTasksTimerSourceInternal()
{
  CFIndex Count = CFArrayGetCount((CFArrayRef)gPeriodicTaskClocksArray);
  if (Count)
  {
    if (gPeriodicTasksIsArmed) {
      return;
    }
    dispatch_resume((dispatch_object_t)gPeriodicTasksSource);
  }
  else
  {
    if (!gPeriodicTasksIsArmed) {
      return;
    }
    dispatch_suspend((dispatch_object_t)gPeriodicTasksSource);
  }
  gPeriodicTasksIsArmed = Count != 0;
}

uint64_t FigAssetAnalysisReporterGetTypeID()
{
  if (FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce != -1) {
    dispatch_once_f(&FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce, &FigAssetAnalysisReporterGetTypeID_sFigAssetAnalysisReporterID, (dispatch_function_t)RegisterFigAssetAnalysisReporterType);
  }
  return FigAssetAnalysisReporterGetTypeID_sFigAssetAnalysisReporterID;
}

uint64_t RegisterFigAssetAnalysisReporterType(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigAssetAnalysisReporterCreate(const __CFAllocator *a1, void *a2)
{
  if (a2)
  {
    if (FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce != -1) {
      dispatch_once_f(&FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce, &FigAssetAnalysisReporterGetTypeID_sFigAssetAnalysisReporterID, (dispatch_function_t)RegisterFigAssetAnalysisReporterType);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v5 = (void *)Instance;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
      v5[2] = Mutable;
      if (Mutable)
      {
        *a2 = v5;
        return 0;
      }
      else
      {
        uint64_t v9 = FigSignalErrorAt(4294949546, 0, 0, 0, 0, 0, 0);
        CFRelease(v5);
        return v9;
      }
    }
    uint64_t v8 = 4294949546;
  }
  else
  {
    uint64_t v8 = 4294949545;
  }

  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAssetAnalysisReporterAddMessage(uint64_t a1, CFDictionaryRef theDict)
{
  if (a1 && theDict && CFDictionaryGetCount(theDict) > 1 && CFDictionaryGetValue(theDict, @"AnalysisType"))
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), theDict);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAssetAnalysisReporterEditAndAppendMessage(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  if (a1 && theDict && CFDictionaryGetCount(theDict) > 1 && CFDictionaryGetValue(theDict, @"AnalysisType"))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
    if (Count)
    {
      CFIndex v7 = Count - 1;
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), Count - 1);
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], ValueAtIndex);
      if (!MutableCopy) {
        return 0;
      }
      CFDictionaryRef v11 = MutableCopy;
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 16), v7);
      if (CFDictionaryGetValue(v11, @"AtomContainer"))
      {
        CFNumberRef Value = (__CFArray *)CFDictionaryGetValue(v11, @"AtomContainer");
        CFArrayAppendValue(Value, theDict);
      }
      else
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
        if (!Mutable)
        {
LABEL_15:
          CFRelease(v11);
          return 0;
        }
        __int16 v15 = Mutable;
        CFArrayAppendValue(Mutable, theDict);
        CFDictionarySetValue(v11, @"AtomContainer", v15);
        CFRelease(v15);
      }
      FigCFDictionarySetInt64(v11, @"MessageType", a3);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), v11);
      goto LABEL_15;
    }
    return FigAssetAnalysisReporterAddMessage(a1, theDict);
  }
  else
  {
    return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAssetAnalysisReporterEditAndCombineMessage(uint64_t a1, CFDictionaryRef theDict)
{
  if (a1 && theDict && CFDictionaryGetCount(theDict) > 1 && CFDictionaryGetValue(theDict, @"AnalysisType"))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
    if (Count)
    {
      CFIndex v5 = Count - 1;
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), Count - 1);
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], ValueAtIndex);
      if (MutableCopy)
      {
        CFMutableDictionaryRef v9 = MutableCopy;
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 16), v5);
        int v16 = 0;
        if (FigCFDictionaryGetInt32IfPresent((uint64_t)theDict, @"TrackID", &v16)) {
          FigCFDictionarySetInt32(v9, @"TrackID", v16);
        }
        int v15 = 0;
        if (FigCFDictionaryGetInt32IfPresent((uint64_t)theDict, @"TrackType", &v15)) {
          FigCFDictionarySetInt32(v9, @"TrackType", v15);
        }
        CFMutableStringRef Mutable = CFStringCreateMutable(v7, 0);
        if (Mutable)
        {
          CFDictionaryRef v11 = Mutable;
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"DiagnosticInformation");
          if (Value) {
            CFStringAppend(v11, Value);
          }
          CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(v9, @"DiagnosticInformation");
          if (v13) {
            CFStringAppend(v11, v13);
          }
          CFDictionaryRemoveValue(v9, @"DiagnosticInformation");
          CFDictionarySetValue(v9, @"DiagnosticInformation", v11);
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), v9);
          CFRelease(v11);
        }
        CFRelease(v9);
      }
      return 0;
    }
    else
    {
      return FigAssetAnalysisReporterAddMessage(a1, theDict);
    }
  }
  else
  {
    return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigAssetAnalysisReporterCopyMessages(CFArrayRef *a1, CFArrayRef *a2)
{
  if (a1 && a2)
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    *a2 = CFArrayCreateCopy(v4, a1[2]);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t AssetAnalysisReporter_Init(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

void AssetAnalysisReporter_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

__CFString *AssetAnalysisReporter_CopyDebugDesc(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  CFArrayRef Count = *(const __CFArray **)(a1 + 16);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  CFStringAppendFormat(Mutable, 0, @"FigAssetAnalysisReporter %d messages", Count);
  return Mutable;
}

unint64_t FigAtomicIncrement64(atomic_ullong *a1)
{
  return atomic_fetch_add_explicit(a1, 1uLL, memory_order_relaxed) + 1;
}

unint64_t FigAtomicDecrement64(atomic_ullong *a1)
{
  return atomic_fetch_add_explicit(a1, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed) - 1;
}

uint64_t FigAtomicBitOr32(unsigned int a1, atomic_uint *a2)
{
  return atomic_fetch_or_explicit(a2, a1, memory_order_relaxed) | a1;
}

uint64_t FigAtomicBitOr32Orig(unsigned int a1, atomic_uint *a2)
{
  return atomic_fetch_or_explicit(a2, a1, memory_order_relaxed);
}

uint64_t FigAtomicBitXor32(unsigned int a1, atomic_uint *a2)
{
  return atomic_fetch_xor_explicit(a2, a1, memory_order_relaxed) ^ a1;
}

uint64_t FigAtomicBitXor32Orig(unsigned int a1, atomic_uint *a2)
{
  return atomic_fetch_xor_explicit(a2, a1, memory_order_relaxed);
}

BOOL FigAtomicCompareAndSwapPtr(uint64_t a1, unint64_t a2, atomic_ullong *a3)
{
  uint64_t v3 = a1;
  atomic_compare_exchange_strong_explicit(a3, (unint64_t *)&v3, a2, memory_order_relaxed, memory_order_relaxed);
  return v3 == a1;
}

pthread_mutex_t *FigSimpleMutexCreateWithFlags(const __CFAllocator *a1)
{
  return FigSimpleMutexCreateWithAttr(a1, 0);
}

pthread_mutex_t *FigReentrantMutexCreateWithFlags(const __CFAllocator *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v4.__sig = 0;
  *(void *)v4.__opaque = 0;
  uint64_t v2 = 0;
  if (!pthread_mutexattr_init(&v4))
  {
    if (pthread_mutexattr_settype(&v4, 2)) {
      uint64_t v2 = 0;
    }
    else {
      uint64_t v2 = FigSimpleMutexCreateWithAttr(a1, &v4);
    }
    pthread_mutexattr_destroy(&v4);
  }
  return v2;
}

void *FigSemaphoreCreateWithFlags(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = CFAllocatorAllocate(a1, 96, 0);
  if (!v6) {
    return v6;
  }
  CFAllocatorRef v7 = FigReentrantMutexCreateWithFlags(a1);
  *uint64_t v6 = v7;
  if (!v7)
  {
LABEL_10:
    CFAllocatorDeallocate(a1, v6);
    return 0;
  }
  if (pthread_cond_init((pthread_cond_t *)(v6 + 1), 0))
  {
    FigSimpleMutexDestroy(*v6);
    goto LABEL_10;
  }
  void v6[7] = a2;
  v6[8] = a3;
  v6[9] = 0;
  *((unsigned char *)v6 + 8CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 0;
  if (a1) {
    CFTypeRef v8 = CFRetain(a1);
  }
  else {
    CFTypeRef v8 = 0;
  }
  v6[11] = v8;
  return v6;
}

pthread_cond_t *FigConditionVariableCreateWithFlags(const __CFAllocator *a1)
{
  uint64_t v2 = (pthread_cond_t *)CFAllocatorAllocate(a1, 56, 0);
  uint64_t v3 = v2;
  if (!v2 || pthread_cond_init(v2, 0))
  {
    CFAllocatorDeallocate(a1, v3);
    return 0;
  }
  else
  {
    if (a1) {
      CFTypeRef v4 = CFRetain(a1);
    }
    else {
      CFTypeRef v4 = 0;
    }
    v3[1].__sig = (uint64_t)v4;
  }
  return v3;
}

pthread_cond_t *FigConditionVariableCreate()
{
  return FigConditionVariableCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
}

uint64_t FigConditionVariableWaitRelative(pthread_cond_t *a1, pthread_mutex_t *a2, unint64_t a3)
{
  LODWORD(result) = WaitOnConditionTimedRelative(a1, a2, a3);
  if (result == 60) {
    return 4294954504;
  }
  else {
    return result;
  }
}

uint64_t WaitOnConditionTimedRelative(pthread_cond_t *a1, pthread_mutex_t *a2, unint64_t a3)
{
  if ((a3 & 0x8000000000000000) != 0)
  {
    return WaitOnCondition(a1, a2);
  }
  else
  {
    if (a3 <= 0x3B9AC9FF)
    {
      __darwin_time_t v5 = 0;
    }
    else
    {
      __darwin_time_t v5 = a3 / 0x3B9ACA00;
      a3 %= 0x3B9ACA00uLL;
    }
    uint64_t v10 = v3;
    uint64_t v11 = v4;
    v9.__darwin_time_t tv_sec = v5;
    v9.tv_nsec = a3;
    uint64_t v7 = pthread_cond_timedwait_relative_np(a1, a2, &v9);
    uint64_t v8 = v7;
    if (v7)
    {
      if (v7 != 60) {
        FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
      }
    }
    return v8;
  }
}

CFAllocatorRef FigConditionVariableDestroy(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = pthread_cond_destroy((pthread_cond_t *)a1);
  if (!v2)
  {
    CFAllocatorRef v3 = *(const __CFAllocator **)(a1 + 48);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(void *)(a1 + 48) = 0;
    CFAllocatorDeallocate(v3, (void *)a1);
    if (!v3) {
      return v3;
    }
    CFRelease(v3);
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)v2;
  FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  return v3;
}

char *FigEventCreate(char a1, char a2)
{
  uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0x1020040989DC6A3uLL);
  if (v4)
  {
    __darwin_time_t v5 = FigReentrantMutexCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
    *(void *)uint64_t v4 = v5;
    if (v5)
    {
      if (!pthread_cond_init((pthread_cond_t *)(v4 + 8), 0))
      {
        *((void *)v4 + 7) = 0;
        v4[64] = a2;
        v4[66] = a1;
        v4[67] = 0;
        return v4;
      }
      FigSimpleMutexDestroy(*(void *)v4);
    }
    free(v4);
    return 0;
  }
  return v4;
}

pthread_mutex_t **FigEventDestroy(pthread_mutex_t **result)
{
  if (result)
  {
    CFDictionaryValueCallBacks v1 = result;
    uint64_t result = (pthread_mutex_t **)pthread_mutex_lock(*result);
    if (!result)
    {
      *((unsigned char *)v1 + 67) = 1;
      if (!pthread_cond_broadcast((pthread_cond_t *)(v1 + 1)))
      {
        while ((*((unsigned char *)v1 + 65) || v1[7]) && !WaitOnCondition((pthread_cond_t *)(v1 + 1), *v1))
          ;
      }
      pthread_mutex_unlock(*v1);
      FigSimpleMutexDestroy((uint64_t)*v1);
      uint64_t v2 = pthread_cond_destroy((pthread_cond_t *)(v1 + 1));
      *(_OWORD *)CFDictionaryValueCallBacks v1 = 0u;
      *((_OWORD *)v1 + 1) = 0u;
      *((_OWORD *)v1 + 2) = 0u;
      *((_OWORD *)v1 + 3) = 0u;
      v1[8] = 0;
      free(v1);
      return (pthread_mutex_t **)v2;
    }
  }
  return result;
}

uint64_t FigEventSet(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if (v2) {
    return v2;
  }
  if (*(unsigned char *)(a1 + 67))
  {
    uint64_t v3 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
LABEL_5:
    uint64_t v4 = v3;
    goto LABEL_20;
  }
  while (*(unsigned char *)(a1 + 65))
  {
    uint64_t v3 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
    if (v3) {
      goto LABEL_5;
    }
  }
  if (!*(unsigned char *)(a1 + 64))
  {
    *(_WORD *)(a1 + 64) = 257;
    uint64_t v5 = pthread_cond_broadcast((pthread_cond_t *)(a1 + 8));
    uint64_t v4 = v5;
    if (*(unsigned char *)(a1 + 66))
    {
      if (v5)
      {
LABEL_19:
        *(unsigned char *)(a1 + 65) = 0;
        pthread_cond_broadcast((pthread_cond_t *)(a1 + 8));
        goto LABEL_20;
      }
      while (*(uint64_t *)(a1 + 56) >= 1)
      {
        uint64_t v6 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
        if (v6) {
          goto LABEL_18;
        }
      }
    }
    else
    {
      if (*(uint64_t *)(a1 + 56) < 1 || v5) {
        goto LABEL_19;
      }
      while (*(unsigned char *)(a1 + 64))
      {
        uint64_t v6 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
        if (v6)
        {
LABEL_18:
          uint64_t v4 = v6;
          goto LABEL_19;
        }
      }
    }
    uint64_t v4 = 0;
    goto LABEL_19;
  }
  uint64_t v4 = 0;
LABEL_20:
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v4;
}

uint64_t FigEventReset(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if (v2) {
    return v2;
  }
  if (*(unsigned char *)(a1 + 67))
  {
    uint64_t v3 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
LABEL_5:
    uint64_t v4 = v3;
  }
  else
  {
    while (*(unsigned char *)(a1 + 65))
    {
      uint64_t v3 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
      if (v3) {
        goto LABEL_5;
      }
    }
    uint64_t v4 = 0;
    *(unsigned char *)(a1 + 64) = 0;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v4;
}

uint64_t FigEventWaitRelative(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 < 0)
  {
    int v5 = 1;
  }
  else
  {
    uint64_t v14 = 0;
    int v4 = RelativeTimeToAbsoluteTime(a2, &v14);
    if (v4) {
      uint64_t v2 = v14;
    }
    int v5 = v4 ^ 1;
  }
  uint64_t v6 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if (v6) {
    return v6;
  }
  while (*(unsigned char *)(a1 + 65))
  {
    uint64_t v7 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
    if (v7) {
      goto LABEL_9;
    }
  }
  if (*(unsigned char *)(a1 + 67)) {
    goto LABEL_33;
  }
  unsigned int v9 = 0;
  ++*(void *)(a1 + 56);
  do
  {
    if (*(unsigned char *)(a1 + 64)) {
      BOOL v10 = 0;
    }
    else {
      BOOL v10 = v9 == 0;
    }
    if (!v10) {
      break;
    }
    uint64_t v11 = *(pthread_mutex_t **)a1;
    int64_t v12 = (pthread_cond_t *)(a1 + 8);
    if (v2 < 0) {
      unsigned int v9 = WaitOnCondition(v12, v11);
    }
    else {
      unsigned int v9 = v5 ? WaitOnConditionTimedRelative(v12, v11, v2) : WaitOnConditionTimed(v12, v11, v2);
    }
  }
  while (!*(unsigned char *)(a1 + 67));
  --*(void *)(a1 + 56);
  if (v9)
  {
    uint64_t v8 = v9 == 60 ? 4294954504 : v9;
  }
  else
  {
    uint64_t v8 = 0;
    if (!*(unsigned char *)(a1 + 66)) {
      *(unsigned char *)(a1 + 64) = 0;
    }
  }
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 8));
  if (*(unsigned char *)(a1 + 67))
  {
LABEL_33:
    uint64_t v7 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
LABEL_9:
    uint64_t v8 = v7;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v8;
}

uint64_t RelativeTimeToAbsoluteTime(uint64_t a1, uint64_t *a2)
{
  v21.unint64_t tv_sec = 0;
  *(void *)&v21.tv_usec = 0;
  gettimeofday(&v21, 0);
  uint64_t result = 0;
  unint64_t tv_sec = v21.tv_sec;
  if (v21.tv_sec >= 0) {
    __darwin_time_t v6 = v21.tv_sec;
  }
  else {
    __darwin_time_t v6 = -v21.tv_sec;
  }
  uint64_t v7 = ((unint64_t)v6 * (unsigned __int128)0xF4240uLL) >> 64;
  unint64_t v8 = 1000000 * v6;
  if (v21.tv_sec >= 0) {
    uint64_t v9 = 1000000 * v6;
  }
  else {
    uint64_t v9 = -1000000 * v6;
  }
  BOOL v10 = v7 != 0;
  BOOL v11 = __OFADD__(v21.tv_usec, v9);
  uint64_t v12 = v21.tv_usec + v9;
  char v13 = v11;
  *a2 = v12;
  if (!v10 && v8 <= (tv_sec >> 63) + 0x7FFFFFFFFFFFFFFFLL && (v13 & 1) == 0)
  {
    if (v12 >= 0) {
      uint64_t v14 = v12;
    }
    else {
      uint64_t v14 = -v12;
    }
    uint64_t v15 = ((unint64_t)v14 * (unsigned __int128)0x3E8uLL) >> 64;
    unint64_t v16 = 1000 * v14;
    if (v12 >= 0) {
      unint64_t v17 = v16;
    }
    else {
      unint64_t v17 = -(uint64_t)v16;
    }
    unint64_t v18 = ((unint64_t)v12 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
    if (v15) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v16 > v18;
    }
    int v20 = v19;
    *a2 = a1 + v17;
    if (__OFADD__(a1, v17)) {
      int v20 = 1;
    }
    return v20 ^ 1u;
  }
  return result;
}

uint64_t WaitOnConditionTimed(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3)
{
  if (a3 <= 999999999)
  {
    __darwin_time_t v5 = 0;
  }
  else
  {
    __darwin_time_t v5 = a3 / 0x3B9ACA00uLL;
    a3 %= 0x3B9ACA00uLL;
  }
  uint64_t v10 = v3;
  uint64_t v11 = v4;
  v9.unint64_t tv_sec = v5;
  v9.tv_nsec = a3;
  uint64_t v6 = pthread_cond_timedwait(a1, a2, &v9);
  uint64_t v7 = v6;
  if (v6 && v6 != 60) {
    FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  return v7;
}

uint64_t figThreadMain(unsigned __int8 *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t (**)(uint64_t))a1;
  uint64_t v1 = *((void *)a1 + 1);
  CFStringRef v3 = (const __CFString *)*((void *)a1 + 2);
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)a1 + 4);
  int v5 = a1[40];
  free(a1);
  if (v5)
  {
    uint64_t v6 = (void *)voucher_adopt();
    os_release(v6);
  }
  if (v3)
  {
    if (CFStringGetCString(v3, buffer, 256, 0x600u)) {
      pthread_setname_np(buffer);
    }
    CFRelease(v3);
  }
  if (v4)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, @"com.apple.fig.ThreadCreateKey_MachTimeSharePolicy");
    if (Value)
    {
      CFBooleanRef v8 = Value;
      CFTypeID v9 = CFGetTypeID(Value);
      if (v9 == CFBooleanGetTypeID())
      {
        uint64_t v10 = pthread_self();
        integer_t v11 = CFBooleanGetValue(v8);
        figSetPThreadTimesharePolicy(v10, v11);
      }
    }
    CFRelease(v4);
  }
  uint64_t v12 = v2(v1);
  if (!FigThreadLockAbortList())
  {
    pthread_t v13 = pthread_self();
    FigThreadRemoveFromAbortListAndCleanup((uint64_t)v13);
    FigThreadUnlockAbortList();
  }
  if (gGMFigKTraceEnabled == 1)
  {
    pthread_self();
    kdebug_trace();
  }
  return v12;
}

uint64_t figSetPThreadBackground(_opaque_pthread_t *a1, int a2)
{
  integer_t v3 = (a2 != 0) << 12;
  uint64_t result = figSetPThreadPolicy(a1, 5u, &v3);
  if (result) {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t figSetPThreadPriority(_opaque_pthread_t *a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 0;
  memset(buffer, 0, sizeof(buffer));
  pid_t v4 = getpid();
  if (proc_pidinfo(v4, 2, 0, buffer, 232) < 1)
  {
    uint64_t result = 0xFFFFFFFFLL;
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  integer_t v6 = a2 - HIDWORD(v8);
  uint64_t result = figSetPThreadPolicy(a1, 3u, &v6);
  if (result) {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigThreadGetMachThreadPriorityValue(unsigned int a1)
{
  if (a1 <= 0x30) {
    return kNativePriorityMap[a1];
  }
  FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  return 47;
}

void FigThreadExit(void *a1)
{
  if (!FigThreadLockAbortList())
  {
    pthread_t v2 = pthread_self();
    FigThreadRemoveFromAbortListAndCleanup((uint64_t)v2);
    FigThreadUnlockAbortList();
  }
  pthread_exit(a1);
}

_opaque_pthread_t *FigThreadIsValid(_opaque_pthread_t *result)
{
  if (result) {
    return (_opaque_pthread_t *)(pthread_kill(result, 0) != 3);
  }
  return result;
}

uint64_t figThreadBindToPID(_opaque_pthread_t *a1)
{
  __uint64_t v2 = 0;
  uint64_t result = pthread_threadid_np(a1, &v2);
  if (!result)
  {
    gAnyFigThreadIsPidBound = 1;
    return proc_pidbind();
  }
  return result;
}

uint64_t FigThreadSetProperty(_opaque_pthread_t *a1, CFTypeRef cf1, const __CFNumber *a3)
{
  if (!cf1) {
    return 4294954501;
  }
  if (CFEqual(cf1, @"com.apple.fig.ThreadPropKey_Priority"))
  {
    if (a3)
    {
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        unsigned int valuePtr = 0;
        CFNumberGetValue(a3, kCFNumberIntType, &valuePtr);
        uint64_t v7 = valuePtr;
        if (gGMFigKTraceEnabled == 1)
        {
          FigThreadGetMachThreadPriorityValue(valuePtr);
          kdebug_trace();
        }
        if (v7 == 16)
        {
          uint64_t result = figSetPThreadBackground(a1, 1);
          if (result) {
            return result;
          }
        }
        else
        {
          figSetPThreadBackground(a1, 0);
          uint64_t result = figSetPThreadPriority(a1, kNativePriorityMap[v7]);
          if (result) {
            return result;
          }
        }
        return 0;
      }
    }
    goto LABEL_30;
  }
  if (CFEqual(cf1, @"com.apple.fig.ThreadPropKey_MachThreadPriority"))
  {
    if (a3)
    {
      CFTypeID v9 = CFNumberGetTypeID();
      if (v9 == CFGetTypeID(a3))
      {
        int SInt32 = FigCFNumberGetSInt32(a3);
        if (gGMFigKTraceEnabled == 1) {
          kdebug_trace();
        }
        figSetPThreadBackground(a1, 0);
        return figSetPThreadPriority(a1, SInt32);
      }
    }
LABEL_30:
    return FigSignalErrorAt(4294954501, 0, 0, 0, 0, 0, 0);
  }
  if (!CFEqual(cf1, @"com.apple.fig.ThreadPropKey_MachTimeSharePolicy"))
  {
    if (CFEqual(cf1, @"com.apple.fig.ThreadPropKey_ClientPID"))
    {
      if (a3)
      {
        CFTypeID v13 = CFNumberGetTypeID();
        if (v13 == CFGetTypeID(a3))
        {
          int v14 = 0;
          CFNumberGetValue(a3, kCFNumberSInt32Type, &v14);
          return figThreadBindToPID(a1);
        }
      }
      goto LABEL_30;
    }
    return 4294954501;
  }
  if (!a3) {
    goto LABEL_30;
  }
  CFTypeID v11 = CFBooleanGetTypeID();
  if (v11 != CFGetTypeID(a3)) {
    goto LABEL_30;
  }
  integer_t Value = CFBooleanGetValue(a3);

  return figSetPThreadTimesharePolicy(a1, Value);
}

uint64_t figSetPThreadTimesharePolicy(_opaque_pthread_t *a1, integer_t a2)
{
  integer_t v3 = a2;
  uint64_t result = figSetPThreadPolicy(a1, 1u, &v3);
  if (result) {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigThreadCopyProperty(_opaque_pthread_t *a1, CFTypeRef cf1, uint64_t a3, void *a4)
{
  if (a4)
  {
    if (cf1)
    {
      if (CFEqual(cf1, @"com.apple.fig.ThreadPropKey_Priority"))
      {
        int v19 = 0;
        thread_inspect_t v8 = pthread_mach_thread_np(a1);
        MachThreadPrioritCGFloat y = figGetMachThreadPriority(v8, &v19);
        if (!MachThreadPriority)
        {
          uint64_t v10 = 1;
          while (kNativePriorityMap[v10] != v19)
          {
            if (++v10 == 49)
            {
              LODWORD(v1CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E4F1D418], 1.79769313e308, 0) = 5;
              break;
            }
          }
          int valuePtr = v10;
          CFNumberRef SInt32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
          goto LABEL_16;
        }
        return MachThreadPriority;
      }
      if (CFEqual(cf1, @"com.apple.fig.ThreadPropKey_MachThreadPriority"))
      {
        int v18 = 0;
        thread_inspect_t v13 = pthread_mach_thread_np(a1);
        MachThreadPrioritCGFloat y = figGetMachThreadPriority(v13, &v18);
        if (!MachThreadPriority)
        {
          CFNumberRef SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v18);
LABEL_16:
          *a4 = SInt32;
        }
        return MachThreadPriority;
      }
      if (CFEqual(cf1, @"com.apple.fig.ThreadPropKey_MachTimeSharePolicy"))
      {
        char v17 = 1;
        thread_inspect_t v14 = pthread_mach_thread_np(a1);
        MachThreadPrioritCGFloat y = figGetMachThreadTimesharePolicy(v14, &v17);
        if (!MachThreadPriority)
        {
          if (v17) {
            uint64_t v15 = (const void **)MEMORY[0x1E4F1CFD0];
          }
          else {
            uint64_t v15 = (const void **)MEMORY[0x1E4F1CFC8];
          }
          uint64_t v16 = *v15;
          *a4 = *v15;
          CFRetain(v16);
        }
        return MachThreadPriority;
      }
    }
    return 4294954501;
  }
  return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
}

uint64_t figGetMachThreadTimesharePolicy(thread_inspect_t a1, unsigned char *a2)
{
  mach_msg_type_number_t policy_infoCnt = 1;
  integer_t policy_info = 0;
  BOOLean_t get_default = 0;
  uint64_t v3 = thread_policy_get(a1, 1u, &policy_info, &policy_infoCnt, &get_default);
  if (v3) {
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  uint64_t result = 0;
  if (a2) {
    *a2 = policy_info;
  }
  return result;
}

uint64_t FigThreadAllocKey(uint64_t a1, pthread_key_t *a2)
{
  pthread_key_t v4 = 0;
  uint64_t result = pthread_key_create(&v4, 0);
  if (!result) {
    *a2 = v4;
  }
  return result;
}

uint64_t FigThreadGetMaxLogicalCoreCount()
{
  return sLogicalCoreCount;
}

uint64_t figGetMaxLogicalCoreCountOnce()
{
  unsigned int v2 = 0;
  size_t v1 = 4;
  uint64_t result = sysctlbyname("hw.logicalcpu_max", &v2, &v1, 0, 0);
  if (!result) {
    sLogicalCoreCFArrayRef Count = v2;
  }
  return result;
}

uint64_t FigThreadGetIOPolicy(int *a1)
{
  if (a1)
  {
    int v3 = getiopolicy_np(0, 1);
    int v4 = v3;
    if (gGMFigKTraceEnabled == 1)
    {
      if ((v3 + 1) > 6) {
        int v5 = "UNKNOWN";
      }
      else {
        int v5 = off_1E5679338[v3 + 1];
      }
      strncpy(__dst, v5, 8uLL);
      kdebug_trace();
    }
    if (v4 == -1)
    {
      return FigSignalErrorAt(4294949734, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      uint64_t result = 0;
      *a1 = v4;
    }
  }
  else
  {
    return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigThreadSetIOPolicy(int a1)
{
  uint64_t v2 = setiopolicy_np(0, 1, a1);
  if (gGMFigKTraceEnabled == 1)
  {
    if ((a1 + 1) > 6) {
      int v3 = "UNKNOWN";
    }
    else {
      int v3 = off_1E5679338[a1 + 1];
    }
    strncpy(__dst, v3, 8uLL);
    kdebug_trace();
  }
  if (v2 == -1) {
    return FigSignalErrorAt(4294949734, 0, 0, 0, 0, 0, 0);
  }
  return v2;
}

uint64_t figSetPThreadPolicy(_opaque_pthread_t *a1, thread_policy_flavor_t a2, integer_t *a3)
{
  thread_act_t v6 = pthread_mach_thread_np(a1);
  qos_class_t __qos_class = QOS_CLASS_UNSPECIFIED;
  uint64_t result = pthread_get_qos_class_np(a1, &__qos_class, 0);
  if (result) {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  if (__qos_class) {
    return 0;
  }
  uint64_t result = thread_policy_set(v6, a2, a3, 1u);
  if (result) {
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

unint64_t FigNanosecondsToHostTime(int64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  FigGetHostTimeToNanosecondsScale(&v7, &v6);
  signed int v2 = v6;
  signed int v3 = v7;
  unint64_t result = a1;
  if (v7 != 1 || v6 != 1)
  {
    return FigInt64MulDiv(a1, v2, v3, 0);
  }
  return result;
}

unint64_t FigGetContinuousUpTimeNanoseconds()
{
  uint64_t v0 = mach_continuous_time();

  return FigHostTimeToNanoseconds(v0);
}

uint64_t FigCFEqual(CFTypeRef cf1, CFTypeRef a2)
{
  if (cf1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (cf1)
  {
    if (a2) {
      return CFEqual(cf1, a2);
    }
  }
  return result;
}

CFMutableDictionaryRef FigCFDictionaryCreateMutableCopy(const __CFAllocator *a1, CFDictionaryRef theDict)
{
  if (theDict) {
    return CFDictionaryCreateMutableCopy(a1, 0, theDict);
  }
  else {
    return CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
}

CFMutableDictionaryRef FigCFDictionaryCreateMutableCopyWithCFTypeCallbacks(const __CFAllocator *a1, const __CFDictionary *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef v4 = Mutable;
  if (a2 && Mutable) {
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)setKeyInDictionaryApply, Mutable);
  }
  return v4;
}

void FigCFDictionarySetAllValuesFromDictionary(void *context, CFDictionaryRef theDict)
{
  if (context)
  {
    if (theDict) {
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)setKeyInDictionaryApply, context);
    }
  }
}

CFMutableArrayRef FigCFArrayCreateMutableCopy(const __CFAllocator *a1, CFArrayRef theArray)
{
  if (theArray) {
    return CFArrayCreateMutableCopy(a1, 0, theArray);
  }
  else {
    return CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  }
}

CFArrayRef FigCFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  if (theArray) {
    return CFArrayCreateCopy(allocator, theArray);
  }
  else {
    return CFArrayCreate(allocator, 0, 0, MEMORY[0x1E4F1D510]);
  }
}

CFArrayRef FigCFArrayCreateConcatenationOfTwoArrays(unint64_t cf, CFTypeRef a2)
{
  if (cf | (unint64_t)a2)
  {
    if (a2)
    {
      if (cf)
      {
        CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)cf);
        CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
        CFIndex v6 = CFArrayGetCount((CFArrayRef)a2);
        CFMutableDictionaryRef MutableCopy = CFArrayCreateMutableCopy(v4, v6 + Count, (CFArrayRef)cf);
        v14.CFIndex length = CFArrayGetCount((CFArrayRef)a2);
        v14.CFIndex location = 0;
        CFArrayAppendArray(MutableCopy, (CFArrayRef)a2, v14);
        return MutableCopy;
      }
      CFAllocatorRef v11 = CFGetAllocator(a2);
      CFArrayRef v12 = (const __CFArray *)a2;
    }
    else
    {
      CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)cf);
      CFArrayRef v12 = (const __CFArray *)cf;
    }
    return CFArrayCreateCopy(v11, v12);
  }
  else
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    return CFArrayCreate(v9, 0, 0, v10);
  }
}

__CFArray *FigCFArrayCopySubarrayWithRange(const __CFAllocator *a1, CFArrayRef theArray, uint64_t a3, CFIndex a4)
{
  if (theArray) {
    CFIndex Count = CFArrayGetCount(theArray);
  }
  else {
    CFIndex Count = 0;
  }
  uint64_t v9 = (a3 & (a3 >> 63)) + a4;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(a1, a4, MEMORY[0x1E4F1D510]);
  uint64_t v11 = a3 & ~(a3 >> 63);
  if (Mutable) {
    BOOL v12 = v11 < Count;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12 && v9 >= 1)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = v11 + v14;
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v11 + v14);
      CFArrayAppendValue(Mutable, ValueAtIndex);
      ++v14;
    }
    while (v15 + 1 < Count && v14 < v9);
  }
  return Mutable;
}

void FigCFArrayAppendArray(__CFArray *a1, CFArrayRef theArray)
{
  if (a1 && theArray)
  {
    v4.CFIndex length = CFArrayGetCount(theArray);
    v4.CFIndex location = 0;
    CFArrayAppendArray(a1, theArray, v4);
  }
}

uint64_t FigCFArrayContainsValue(const __CFArray *a1, const void *a2)
{
  if (!a1 || !a2) {
    return 0;
  }
  v4.CFIndex length = CFArrayGetCount(a1);
  v4.CFIndex location = 0;

  return CFArrayContainsValue(a1, v4, a2);
}

CFIndex FigCFArrayGetFirstIndexOfValue(const __CFArray *a1, const void *a2)
{
  if (!a1) {
    return -1;
  }
  if (!a2) {
    return -1;
  }
  uint64_t Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return -1;
  }
  v5.CFIndex length = Count;
  v5.CFIndex location = 0;

  return CFArrayGetFirstIndexOfValue(a1, v5, a2);
}

CFIndex FigCFArrayGetLastIndexOfValue(const __CFArray *a1, const void *a2)
{
  if (!a1) {
    return -1;
  }
  if (!a2) {
    return -1;
  }
  uint64_t Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return -1;
  }
  v5.CFIndex length = Count;
  v5.CFIndex location = 0;

  return CFArrayGetLastIndexOfValue(a1, v5, a2);
}

uint64_t FigCFArrayGetFirstIndexOfInt32(const __CFArray *a1, int a2)
{
  int v8 = 0;
  if (!a1) {
    return -1;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return -1;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    figCFArrayGetNumberAtIndex(a1, v6, kCFNumberSInt32Type, &v8);
    if (v8 == a2) {
      break;
    }
    if (v5 == ++v6) {
      return -1;
    }
  }
  return v6;
}

uint64_t FigCFArrayGetInt32AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberSInt32Type, a3);
}

uint64_t FigCFArrayGetLastIndexOfInt32(const __CFArray *a1, int a2)
{
  int v8 = 0;
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      while (v5-- >= 1)
      {
        figCFArrayGetNumberAtIndex(a1, v5, kCFNumberSInt32Type, &v8);
        if (v8 == a2) {
          return v5;
        }
      }
    }
  }
  return -1;
}

BOOL FigCFArrayRemoveLastElementOfValue(const __CFArray *a1, const void *a2)
{
  LastIndexOfinteger_t Value = FigCFArrayGetLastIndexOfValue(a1, a2);
  if (LastIndexOfValue != -1) {
    CFArrayRemoveValueAtIndex(a1, LastIndexOfValue);
  }
  return LastIndexOfValue != -1;
}

const void *FigCFArrayGetValueAtIndex(const __CFArray *a1, CFIndex a2)
{
  if (!a1 || a2 < 0 || CFArrayGetCount(a1) <= a2) {
    return 0;
  }

  return CFArrayGetValueAtIndex(a1, a2);
}

const void *FigCFArrayGetLastValue(const __CFArray *a1)
{
  if (!a1 || CFArrayGetCount(a1) < 1) {
    return 0;
  }
  CFIndex v2 = CFArrayGetCount(a1) - 1;

  return CFArrayGetValueAtIndex(a1, v2);
}

const void *FigCFArrayGetFirstValue(const __CFArray *a1)
{
  if (!a1 || CFArrayGetCount(a1) < 1) {
    return 0;
  }

  return CFArrayGetValueAtIndex(a1, 0);
}

uint64_t FigCFArrayContainsInt(const __CFArray *a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  if (!v3) {
    return 0;
  }
  CFNumberRef v4 = v3;
  uint64_t v5 = FigCFArrayContainsValue(a1, v3);
  CFRelease(v4);
  return v5;
}

uint64_t FigCFArrayContainsInt16(const __CFArray *a1, __int16 a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  __int16 valuePtr = a2;
  CFNumberRef v4 = CFNumberCreate(v3, kCFNumberSInt16Type, &valuePtr);
  if (!v4) {
    return 0;
  }
  CFNumberRef v5 = v4;
  uint64_t v6 = FigCFArrayContainsValue(a1, v4);
  CFRelease(v5);
  return v6;
}

CFNumberRef FigCFNumberCreateSInt16(const __CFAllocator *a1, __int16 a2)
{
  __int16 valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt16Type, &valuePtr);
}

uint64_t FigCFArrayContainsInt32(const __CFArray *a1, int a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int valuePtr = a2;
  CFNumberRef v4 = CFNumberCreate(v3, kCFNumberSInt32Type, &valuePtr);
  if (!v4) {
    return 0;
  }
  CFNumberRef v5 = v4;
  uint64_t v6 = FigCFArrayContainsValue(a1, v4);
  CFRelease(v5);
  return v6;
}

CFNumberRef FigCFNumberCreateSInt32(const __CFAllocator *a1, int a2)
{
  int valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt32Type, &valuePtr);
}

uint64_t FigCFArrayContainsInt64(const __CFArray *a1, uint64_t a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t valuePtr = a2;
  CFNumberRef v4 = CFNumberCreate(v3, kCFNumberSInt64Type, &valuePtr);
  if (!v4) {
    return 0;
  }
  CFNumberRef v5 = v4;
  uint64_t v6 = FigCFArrayContainsValue(a1, v4);
  CFRelease(v5);
  return v6;
}

CFNumberRef FigCFNumberCreateSInt64(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt64Type, &valuePtr);
}

CFArrayRef FigCFDictionaryCopyArrayOfValues(const __CFDictionary *a1)
{
  if (a1)
  {
    if (CFDictionaryGetCount(a1) >= 1)
    {
      size_t Count = CFDictionaryGetCount(a1);
      CFIndex v3 = Count;
      if (Count)
      {
        if (Count >> 61) {
          return 0;
        }
        Count *= 8;
        if (!(8 * v3)) {
          return 0;
        }
        malloc_type_id_t v4 = 219851612;
      }
      else
      {
        malloc_type_id_t v4 = 754892075;
      }
      int v8 = (const void **)malloc_type_malloc(Count, v4);
      if (v8)
      {
        CFDictionaryGetKeysAndValues(a1, 0, v8);
        CFAllocatorRef v9 = CFGetAllocator(a1);
        CFArrayRef v10 = CFArrayCreate(v9, v8, v3, MEMORY[0x1E4F1D510]);
        free(v8);
        return v10;
      }
      return 0;
    }
    CFAllocatorRef v5 = CFGetAllocator(a1);
  }
  else
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  uint64_t v6 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];

  return CFArrayCreate(v5, 0, 0, v6);
}

CFArrayRef FigCFDictionaryCopyArrayOfKeys(const __CFDictionary *a1)
{
  if (a1)
  {
    if (CFDictionaryGetCount(a1) >= 1)
    {
      size_t Count = CFDictionaryGetCount(a1);
      CFIndex v3 = Count;
      if (Count)
      {
        if (Count >> 61) {
          return 0;
        }
        Count *= 8;
        if (!(8 * v3)) {
          return 0;
        }
        malloc_type_id_t v4 = 219851612;
      }
      else
      {
        malloc_type_id_t v4 = 754892075;
      }
      int v8 = (const void **)malloc_type_malloc(Count, v4);
      if (v8)
      {
        CFDictionaryGetKeysAndValues(a1, v8, 0);
        CFAllocatorRef v9 = CFGetAllocator(a1);
        CFArrayRef v10 = CFArrayCreate(v9, v8, v3, MEMORY[0x1E4F1D510]);
        free(v8);
        return v10;
      }
      return 0;
    }
    CFAllocatorRef v5 = CFGetAllocator(a1);
  }
  else
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  uint64_t v6 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];

  return CFArrayCreate(v5, 0, 0, v6);
}

CFMutableArrayRef FigCFDictionaryCreateMappedArray(const __CFDictionary *a1, CFArrayRef theArray)
{
  if (theArray)
  {
    uint64_t Count = CFArrayGetCount(theArray);
    CFAllocatorRef v5 = CFGetAllocator(theArray);
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v5, Count, MEMORY[0x1E4F1D510]);
    if (Count >= 1)
    {
      CFIndex v7 = 0;
      int v8 = (const void *)*MEMORY[0x1E4F1D260];
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
        integer_t Value = v8;
        if (a1) {
          integer_t Value = CFDictionaryGetValue(a1, ValueAtIndex);
        }
        if (Value) {
          uint64_t v11 = Value;
        }
        else {
          uint64_t v11 = v8;
        }
        CFArrayAppendValue(Mutable, v11);
        ++v7;
      }
      while (Count != v7);
    }
    return Mutable;
  }
  else
  {
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v14 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    return CFArrayCreateMutable(v13, 0, v14);
  }
}

void FigCFDictionaryApplyBlock(const __CFDictionary *a1, void *context)
{
  if (a1)
  {
    if (context) {
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)dictionaryBlockApplier, context);
    }
  }
}

uint64_t dictionaryBlockApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void FigCFSetApplyBlock(const __CFSet *a1, void *context)
{
  if (a1)
  {
    if (context) {
      CFSetApplyFunction(a1, (CFSetApplierFunction)setBlockApplier, context);
    }
  }
}

uint64_t setBlockApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFArrayRef FigCFArrayForEach2(const __CFArray *theArray, const __CFArray *a2, uint64_t (*a3)(const void *, const void *, uint64_t), uint64_t a4)
{
  CFArrayRef v7 = theArray;
  if (!theArray)
  {
    uint64_t v8 = 0;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    CFArrayRef v9 = 0;
    goto LABEL_6;
  }
  CFArrayRef theArray = (const __CFArray *)CFArrayGetCount(theArray);
  uint64_t v8 = (uint64_t)theArray;
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  CFArrayRef theArray = (const __CFArray *)CFArrayGetCount(a2);
  CFArrayRef v9 = theArray;
LABEL_6:
  if ((const __CFArray *)v8 != v9)
  {
    CFArrayRef theArray = (const __CFArray *)FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    if (v8 >= (uint64_t)v9) {
      uint64_t v8 = (uint64_t)v9;
    }
  }
  if (v8 >= 1)
  {
    for (CFIndex i = 0; i != v8; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
      BOOL v12 = CFArrayGetValueAtIndex(a2, i);
      CFArrayRef theArray = (const __CFArray *)a3(ValueAtIndex, v12, a4);
    }
  }
  return theArray;
}

void FigCFArrayApplyFunction(const __CFArray *a1, void (__cdecl *a2)(const void *, void *), void *a3)
{
  if (a1)
  {
    v6.CFIndex length = CFArrayGetCount(a1);
    v6.CFIndex location = 0;
    CFArrayApplyFunction(a1, v6, a2, a3);
  }
}

void FigCFArrayApplyBlock(const __CFArray *a1, void *a2)
{
  if (a1 && a2)
  {
    v4.CFIndex length = CFArrayGetCount(a1);
    v4.CFIndex location = 0;
    CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)arrayBlockApplier, a2);
  }
}

uint64_t arrayBlockApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFDictionaryRef FigCFDictionaryGetCount(CFDictionaryRef theDict)
{
  if (theDict) {
    return (CFDictionaryRef)CFDictionaryGetCount(theDict);
  }
  return theDict;
}

CFDictionaryRef FigCFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  if (theDict) {
    return (CFDictionaryRef)CFDictionaryGetCountOfKey(theDict, key);
  }
  return theDict;
}

void FigCFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  if (theDict) {
    CFDictionaryRemoveAllValues(theDict);
  }
}

void FigCFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  if (theArray) {
    CFArrayRemoveAllValues(theArray);
  }
}

uint64_t FigCFDictionaryGetValueForCaseInsensitiveKeyIfPresent(CFDictionaryRef theDict, uint64_t a2, void *a3)
{
  uint64_t result = 0;
  uint64_t v6 = a2;
  uint64_t v7 = 0;
  if (theDict && a2 && a3)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)figCFDictionaryCaseInsensitiveKeySearch, &v6);
    if (v7)
    {
      *a3 = v7;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFComparisonResult figCFDictionaryCaseInsensitiveKeySearch(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v6 = *(const __CFString **)a3;
  v8.CFIndex length = CFStringGetLength(*(CFStringRef *)a3);
  v8.CFIndex location = 0;
  CFComparisonResult result = CFStringCompareWithOptions(v6, a1, v8, 1uLL);
  if (result == kCFCompareEqualTo && !*(void *)(a3 + 8)) {
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

void FigCFDictionarySetValue(void *a1, const void *a2, const void *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (a3)
    {
      if (a2 && v6 == TypeID)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, a3);
      }
    }
  }
}

const void *FigCFDictionaryGetValue(const void *a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFDictionaryGetTypeID()) {
    return 0;
  }

  return CFDictionaryGetValue((CFDictionaryRef)a1, a2);
}

const void *FigCFDictionaryGetStringValue(const void *a1, const void *a2)
{
  integer_t Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFIndex v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFStringGetTypeID()) {
    return 0;
  }
  return v3;
}

const void *FigCFDictionaryGetURLValue(const void *a1, const void *a2)
{
  integer_t Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFIndex v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFURLGetTypeID()) {
    return 0;
  }
  return v3;
}

const void *FigCFDictionaryGetDictionaryValue(const void *a1, const void *a2)
{
  integer_t Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFIndex v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFDictionaryGetTypeID()) {
    return 0;
  }
  return v3;
}

const void *FigCFDictionaryGetArrayValue(const void *a1, const void *a2)
{
  integer_t Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFIndex v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFArrayGetTypeID()) {
    return 0;
  }
  return v3;
}

const void *FigCFDictionaryGetDataValue(const void *a1, const void *a2)
{
  integer_t Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFIndex v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFDataGetTypeID()) {
    return 0;
  }
  return v3;
}

const void *FigCFDictionaryGetBooleanValue(const void *a1, const void *a2)
{
  integer_t Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFIndex v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFBooleanGetTypeID()) {
    return 0;
  }
  return v3;
}

const void *FigCFDictionaryGetNumberValue(const void *a1, const void *a2)
{
  integer_t Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFIndex v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFNumberGetTypeID()) {
    return 0;
  }
  return v3;
}

void FigCFDictionaryAddEntriesToDictionaryWithRecursion(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFIndex v3 = 0;
  if (a1)
  {
    CFAllocatorRef v5 = 0;
    if (a2)
    {
      CFTypeID v8 = CFGetTypeID(a1);
      if (v8 == CFDictionaryGetTypeID() && (CFTypeID v9 = CFGetTypeID(a2), v9 == CFDictionaryGetTypeID()))
      {
        CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
        CFIndex v3 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
        CFAllocatorRef v5 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v3, v5);
        if (Count >= 1)
        {
          uint64_t v11 = 0;
          while (1)
          {
            BOOL v12 = v3[v11];
            CFAllocatorRef v13 = v5[v11];
            integer_t Value = CFDictionaryGetValue(a2, v12);
            if (!Value) {
              break;
            }
            if (v13
              && (v15 = Value, CFTypeID v16 = CFGetTypeID(v13), v16 == CFDictionaryGetTypeID())
              && (CFTypeID v17 = CFGetTypeID(v15), v17 == CFDictionaryGetTypeID()))
            {
              FigCFDictionaryAddEntriesToDictionaryWithRecursion(v13, v15, a3);
            }
            else if (a3)
            {
              break;
            }
LABEL_14:
            if (Count == ++v11) {
              goto LABEL_15;
            }
          }
          CFDictionarySetValue(a2, v12, v13);
          goto LABEL_14;
        }
      }
      else
      {
        CFIndex v3 = 0;
        CFAllocatorRef v5 = 0;
      }
    }
  }
  else
  {
    CFAllocatorRef v5 = 0;
  }
LABEL_15:
  free(v3);

  free(v5);
}

uint64_t FigCFDictionaryGetValueIfPresent(const __CFDictionary *a1, const void *a2, const void **a3)
{
  if (!a1 || !a2 || !a3) {
    return 0;
  }
  *a3 = 0;
  return CFDictionaryGetValueIfPresent(a1, a2, a3);
}

__CFDictionary *FigCFDictionaryCreateCopyRemovingKeys(CFDictionaryRef theDict, const void **a2, int a3)
{
  LODWORD(v3) = a3;
  CFMutableDictionaryRef MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], theDict);
  if (a2 && (int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      CFTypeID v6 = *a2++;
      CFDictionaryRemoveValue(MutableCopy, v6);
      --v3;
    }
    while (v3);
  }
  return MutableCopy;
}

uint64_t FigCFDictionaryGetCGFloatIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberCGFloatType, a3);
}

uint64_t figCFDictionaryGetNumberIfPresent(uint64_t result, const void *a2, CFNumberType a3, void *a4)
{
  CMTimeValue value = 0;
  if (result)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)result;
    CFTypeID v8 = CFGetTypeID((CFTypeRef)result);
    if (v8 == CFDictionaryGetTypeID() && a2 && a4)
    {
      CFComparisonResult result = CFDictionaryGetValueIfPresent(v7, a2, (const void **)&value);
      if (!result) {
        return result;
      }
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        CFNumberGetValue((CFNumberRef)value, a3, a4);
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCGFloat(void *a1, const void *a2, double a3)
{
  double v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberCGFloatType, &v4);
}

uint64_t figCFDictionarySetNumber(void *a1, const void *a2, CFNumberType a3, const void *a4)
{
  if (!a1) {
    goto LABEL_7;
  }
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (a2)
  {
    CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a3, a4);
    if (v9)
    {
      CFNumberRef v10 = v9;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, v9);
      CFRelease(v10);
      return 0;
    }
    uint64_t v12 = 4294954305;
  }
  else
  {
LABEL_7:
    uint64_t v12 = 4294954306;
  }

  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayGetCGFloatAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberCGFloatType, a3);
}

uint64_t figCFArrayGetNumberAtIndex(const void *a1, CFIndex a2, CFNumberType a3, void *a4)
{
  if (a1
    && (CFTypeID v8 = CFGetTypeID(a1), v8 == CFArrayGetTypeID())
    && a4
    && (a2 & 0x8000000000000000) == 0
    && CFArrayGetCount((CFArrayRef)a1) > a2
    && (CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2)) != 0
    && (CFNumberRef v10 = ValueAtIndex, v11 = CFGetTypeID(ValueAtIndex), v11 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(v10, a3, a4);
    return 1;
  }
  else
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t FigCFArrayAppendCGFloat(void *a1, double a2)
{
  double v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberCGFloatType, &v3);
}

uint64_t figCFArrayAppendNumber(void *a1, CFNumberType a2, const void *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 != CFArrayGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3);
    if (v7)
    {
      CFNumberRef v8 = v7;
      CFArrayAppendValue((CFMutableArrayRef)a1, v7);
      CFRelease(v8);
      return 0;
    }
    uint64_t v10 = 4294954305;
  }
  else
  {
    uint64_t v10 = 4294954306;
  }

  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFDictionaryGetFloatIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberFloatType, a3);
}

uint64_t FigCFDictionarySetFloat(void *a1, const void *a2, float a3)
{
  float v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberFloatType, &v4);
}

uint64_t FigCFArrayGetFloatAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberFloatType, a3);
}

uint64_t FigCFArrayAppendFloat(void *a1, float a2)
{
  float v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberFloatType, &v3);
}

uint64_t FigCFDictionaryGetFloat32IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberFloat32Type, a3);
}

uint64_t FigCFDictionarySetFloat32(void *a1, const void *a2, float a3)
{
  float v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberFloat32Type, &v4);
}

uint64_t FigCFArrayGetFloat32AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberFloat32Type, a3);
}

uint64_t FigCFArrayAppendFloat32(void *a1, float a2)
{
  float v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberFloat32Type, &v3);
}

uint64_t FigCFDictionaryGetDoubleIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberDoubleType, a3);
}

uint64_t FigCFDictionarySetDouble(void *a1, const void *a2, double a3)
{
  double v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberDoubleType, &v4);
}

uint64_t FigCFArrayGetDoubleAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberDoubleType, a3);
}

uint64_t FigCFArrayAppendDouble(void *a1, double a2)
{
  double v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberDoubleType, &v3);
}

uint64_t FigCFDictionaryGetInt16IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberSInt16Type, a3);
}

uint64_t FigCFDictionarySetInt16(void *a1, const void *a2, __int16 a3)
{
  __int16 v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberSInt16Type, &v4);
}

uint64_t FigCFArrayGetInt16AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberSInt16Type, a3);
}

uint64_t FigCFArrayAppendInt16(void *a1, __int16 a2)
{
  __int16 v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberSInt16Type, &v3);
}

uint64_t FigCFDictionaryGetIntIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberIntType, a3);
}

uint64_t FigCFDictionarySetInt(void *a1, const void *a2, int a3)
{
  int v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberIntType, &v4);
}

uint64_t FigCFArrayGetIntAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberIntType, a3);
}

uint64_t FigCFArrayAppendInt(void *a1, int a2)
{
  int v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberIntType, &v3);
}

uint64_t FigCFDictionaryGetInt32IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberSInt32Type, a3);
}

uint64_t FigCFDictionarySetInt32(void *a1, const void *a2, int a3)
{
  int v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberSInt32Type, &v4);
}

uint64_t FigCFArrayAppendInt32(void *a1, int a2)
{
  int v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberSInt32Type, &v3);
}

uint64_t FigCFDictionarySetUInt32(void *a1, const void *a2, unsigned int a3)
{
  unsigned int v7 = a3;
  if ((a3 & 0x80000000) != 0)
  {
    uint64_t v6 = a3;
    int v3 = &v6;
    CFNumberType v4 = kCFNumberSInt64Type;
  }
  else
  {
    int v3 = (uint64_t *)&v7;
    CFNumberType v4 = kCFNumberSInt32Type;
  }
  return figCFDictionarySetNumber(a1, a2, v4, v3);
}

uint64_t FigCFDictionarySetUInt64(void *a1, const void *a2, uint64_t a3)
{
  CFNumberRef UInt64 = FigCFNumberCreateUInt64((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3);
  if (UInt64)
  {
    CFNumberRef v6 = UInt64;
    FigCFDictionarySetValue(a1, a2, UInt64);
    CFRelease(v6);
    return 0;
  }
  else
  {
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  }
}