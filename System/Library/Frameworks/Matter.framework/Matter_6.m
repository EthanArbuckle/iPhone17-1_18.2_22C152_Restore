uint64_t sub_244CFD01C(long long *a1, void *a2)
{
  uint64_t result;
  unint64_t v4;
  int v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  unsigned __int8 *v9;
  unsigned char *v10;
  unsigned __int8 *v11;
  unint64_t v12;
  void v13[2];

  v13[1] = *MEMORY[0x263EF8340];
  v11 = 0;
  v12 = 0;
  result = sub_244CFCD3C(a1, &v11, 2, 1);
  if (result)
  {
    v4 = v12;
    if (v12)
    {
      v5 = *v11;
      if (v12 == 1
        || ((result = 0, v6 = v5 == 0, (v11[1] & 0x80u) == 0) ? (v7 = 1) : (v6 = 0, v7 = v5 != 255),
            !v6 && (v7 ? (v8 = v12 > 8) : (v8 = 1), !v8)))
      {
        v13[0] = 0x101010101010101 * ((unint64_t)(char)v5 >> 7);
        v9 = v11 - 1;
        v10 = v13;
        do
          *v10++ = v9[v4--];
        while (v4);
        *a2 = v13[0];
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_244CFD114(unsigned __int8 **a1, unsigned int *a2)
{
  v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (uint64_t)*a1;
  unsigned int v4 = **a1;
  if (a2) {
    *a2 = v4 >> 7;
  }
  if (v2 == (unsigned __int8 *)1) {
    return 1;
  }
  int v6 = *(char *)(v3 + 1);
  if (!v4 && (v6 & 0x80000000) == 0) {
    return 0;
  }
  return v4 != 255 || v6 >= 0;
}

uint64_t sub_244CFD164(long long *a1, _DWORD *a2)
{
  int v6 = 0;
  uint64_t v7 = 0;
  int v3 = sub_244CFCD3C(a1, &v6, 1, 1);
  uint64_t result = 0;
  if (v3 && v7 == 1)
  {
    int v5 = *v6;
    if ((v5 - 1) >= 0xFE)
    {
      *a2 = v5 != 0;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244CFD1E4(long long *a1, void *a2, int *a3, int a4)
{
  long long v11 = *a1;
  unsigned int v10 = 0;
  int v8 = 0;
  if (!sub_244CFCE54(&v11, &v10)
    || v10 != a4
    || (v8 = 1, uint64_t result = sub_244CFCD3C(a1, a2, a4, 1), result))
  {
    if (a3) {
      *a3 = v8;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244CFD27C(long long *a1, void *a2, _DWORD *a3, int a4)
{
  long long v9 = 0uLL;
  int v8 = 0;
  uint64_t result = sub_244CFD1E4(a1, &v9, &v8, a4);
  if (result)
  {
    if (!v8)
    {
      *a2 = 0;
      a2[1] = 0;
      if (!a3) {
        return 1;
      }
      goto LABEL_6;
    }
    int v7 = sub_244CFCD3C(&v9, a2, 4, 1);
    uint64_t result = 0;
    if (v7 && !*((void *)&v9 + 1))
    {
      if (!a3) {
        return 1;
      }
LABEL_6:
      *a3 = v8;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244CFD30C(long long *a1, unint64_t *a2, int a3, unint64_t a4)
{
  long long v9 = 0uLL;
  int v8 = 0;
  uint64_t result = sub_244CFD1E4(a1, &v9, &v8, a3);
  if (result)
  {
    if (v8)
    {
      int v7 = sub_244CFCEF4(&v9, a2);
      uint64_t result = 0;
      if (!v7 || *((void *)&v9 + 1)) {
        return result;
      }
    }
    else
    {
      *a2 = a4;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244CFD388(long long *a1, int *a2, int a3, int a4)
{
  long long v11 = 0uLL;
  long long v9 = 0;
  uint64_t v10 = 0;
  int v8 = 0;
  uint64_t result = sub_244CFD1E4(a1, &v11, &v8, a3);
  if (result)
  {
    if (!v8)
    {
LABEL_9:
      *a2 = a4;
      return 1;
    }
    int v7 = sub_244CFCD3C(&v11, &v9, 1, 1);
    uint64_t result = 0;
    if (v7 && v10 == 1 && !*((void *)&v11 + 1))
    {
      a4 = *v9;
      if (*v9)
      {
        if (a4 != 255) {
          return 0;
        }
        a4 = 1;
      }
      goto LABEL_9;
    }
  }
  return result;
}

BOOL sub_244CFD438(unsigned __int8 **a1)
{
  v1 = a1[1];
  if (!v1) {
    return 0;
  }
  unsigned int v2 = **a1;
  if (v2 > 7) {
    return 0;
  }
  if (!**a1) {
    return 1;
  }
  if (v1 == (unsigned __int8 *)1) {
    return 0;
  }
  return ((*a1)[(void)v1 - 1] & ~(-1 << v2)) == 0;
}

BOOL sub_244CFD488(uint64_t a1, unsigned int a2)
{
  BOOL result = sub_244CFD438((unsigned __int8 **)a1);
  if (result)
  {
    unint64_t v5 = (a2 >> 3) + 1;
    if (*(void *)(a1 + 8) <= v5) {
      return 0;
    }
    else {
      return (*(unsigned __int8 *)(*(void *)a1 + v5) >> (~(_BYTE)a2 & 7)) & 1;
    }
  }
  return result;
}

BOOL sub_244CFD4E8(unsigned __int8 **a1)
{
  v1 = a1[1];
  if (!v1) {
    return 0;
  }
  LOBYTE(v2) = 0;
  int v3 = *a1;
  while (1)
  {
    char v4 = v2;
    if (!v1) {
      break;
    }
    int v5 = *v3++;
    int v2 = v5;
    --v1;
    if ((v4 & 0x80) == 0 && v2 == 128) {
      return 0;
    }
  }
  return (v2 & 0x80) == 0;
}

uint64_t sub_244CFD528(unsigned __int8 **a1)
{
  memset(v15, 0, sizeof(v15));
  if (sub_244CFB3DC((uint64_t)v15, 0x20uLL))
  {
    unint64_t v2 = 0;
    int v3 = *a1;
    char v4 = a1[1];
    while (v4)
    {
      if (v2 >> 57) {
        break;
      }
      int v6 = *v3++;
      int v5 = v6;
      if (!v2 && v5 == 128) {
        break;
      }
      unint64_t v7 = v5 & 0x7F | (v2 << 7);
      --v4;
      unint64_t v2 = v7;
      if ((v5 & 0x80) == 0)
      {
        unint64_t v8 = v7 - 80;
        if (v7 < 0x50)
        {
          if (!sub_244CFD6FC((uint64_t)v15, v7 > 0x27)
            || !sub_244CFB8C4((uint64_t)v15, 0x2Eu))
          {
            break;
          }
          if (v7 >= 0x28) {
            uint64_t v9 = v7 - 40;
          }
          else {
            uint64_t v9 = v7;
          }
        }
        else
        {
          if (!sub_244CFBA40((uint64_t)v15, "2.", 2uLL)) {
            break;
          }
LABEL_16:
          uint64_t v9 = v8;
        }
        if (!sub_244CFD6FC((uint64_t)v15, v9)) {
          break;
        }
        if (v4)
        {
          unint64_t v8 = 0;
          while (v4)
          {
            if (v8 >> 57) {
              break;
            }
            int v11 = *v3++;
            int v10 = v11;
            if (!v8 && v10 == 128) {
              break;
            }
            unint64_t v8 = v10 & 0x7F | (v8 << 7);
            --v4;
            if ((v10 & 0x80) == 0)
            {
              if (sub_244CFB8C4((uint64_t)v15, 0x2Eu)) {
                goto LABEL_16;
              }
              goto LABEL_30;
            }
          }
        }
        else
        {
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          if (sub_244CFB8C4((uint64_t)v15, 0) && sub_244CFB48C((uint64_t)v15, &v14, &v13)) {
            return v14;
          }
        }
        break;
      }
    }
  }
LABEL_30:
  sub_244CFB470((uint64_t)v15);
  return 0;
}

uint64_t sub_244CFD69C(void *a1, unint64_t *a2)
{
  unint64_t v2 = 0;
  for (uint64_t i = a1[1] - 1; i != -1; --i)
  {
    char v4 = (unsigned __int8 *)(*a1)++;
    a1[1] = i;
    if (v2 >> 57) {
      break;
    }
    int v5 = *v4;
    if (!v2 && v5 == 128) {
      break;
    }
    unint64_t v6 = v5 & 0x7F | (v2 << 7);
    unint64_t v2 = v6;
    if ((v5 & 0x80) == 0)
    {
      *a2 = v6;
      return 1;
    }
  }
  return 0;
}

uint64_t sub_244CFD6FC(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  snprintf(__str, 0x18uLL, "%llu", a2);
  size_t v3 = strlen(__str);
  return sub_244CFBA40(a1, __str, v3);
}

uint64_t sub_244CFD780(long long *a1, int *a2, int a3)
{
  return sub_244CFD78C(a1, 1, a3, a2);
}

uint64_t sub_244CFD78C(long long *a1, int a2, int a3, int *a4)
{
  int v32 = 0;
  long long v31 = *a1;
  uint64_t result = sub_244CFDA90(&v31, &v32);
  if (a2)
  {
    if (!result) {
      return result;
    }
    int v8 = v32;
    uint64_t result = sub_244CFDA90(&v31, &v32);
    if (!result) {
      return result;
    }
    int v9 = v32 + 100 * v8;
  }
  else
  {
    if (!result) {
      return result;
    }
    if (v32 >= 50) {
      int v10 = 1900;
    }
    else {
      int v10 = 2000;
    }
    int v9 = v10 + v32;
    if (v10 + v32 > 2049) {
      return 0;
    }
  }
  int v37 = 0;
  BOOL v11 = sub_244CFDA90(&v31, &v37);
  uint64_t result = 0;
  if (!v11) {
    return result;
  }
  unsigned int v12 = v37;
  int v13 = v37 - 1;
  if (v37 < 1) {
    return result;
  }
  if (v37 > 12) {
    return result;
  }
  unsigned int v36 = 0;
  uint64_t result = sub_244CFDA90(&v31, &v36);
  if (!result) {
    return result;
  }
  unsigned int v14 = v36;
  if ((int)v36 < 1) {
    return 0;
  }
  uint64_t result = 0;
  if (v12 > 0xC) {
    return result;
  }
  if (((1 << v12) & 0x15AA) != 0)
  {
    if (v36 > 0x1F) {
      return 0;
    }
  }
  else if (((1 << v12) & 0xA50) != 0)
  {
    if (v36 >= 0x1F) {
      return 0;
    }
  }
  else
  {
    if (v12 != 2) {
      return result;
    }
    HIDWORD(v25) = -1030792151 * v9 + 85899344;
    LODWORD(v25) = HIDWORD(v25);
    unsigned int v24 = v25 >> 2;
    BOOL v26 = (v9 & 3) == 0 && v24 > 0x28F5C28;
    BOOL v27 = v26;
    HIDWORD(v28) = -1030792151 * v9 + 85899344;
    LODWORD(v28) = HIDWORD(v28);
    if ((v28 >> 4) < 0xA3D70B || v27)
    {
      if (v36 >= 0x1E) {
        return 0;
      }
    }
    else if (v36 >= 0x1D)
    {
      return 0;
    }
  }
  int v35 = 0;
  BOOL v15 = sub_244CFDA90(&v31, &v35);
  uint64_t result = 0;
  if (!v15) {
    return result;
  }
  int v16 = v35;
  if (v35 > 23) {
    return result;
  }
  int v34 = 0;
  BOOL v17 = sub_244CFDA90(&v31, &v34);
  uint64_t result = 0;
  if (!v17) {
    return result;
  }
  int v18 = v34;
  if (v34 > 59) {
    return result;
  }
  int v33 = 0;
  BOOL v19 = sub_244CFDA90(&v31, &v33);
  uint64_t result = 0;
  if (!v19) {
    return result;
  }
  int v20 = v33;
  if (v33 > 59) {
    return result;
  }
  if (!*((void *)&v31 + 1)) {
    return 0;
  }
  int v21 = *(unsigned __int8 *)v31;
  uint64_t v22 = *((void *)&v31 + 1) - 1;
  *(void *)&long long v31 = v31 + 1;
  --*((void *)&v31 + 1);
  if (v21 == 43)
  {
    int v23 = 1;
LABEL_46:
    if (!a3) {
      return 0;
    }
    uint64_t v30 = 0;
    if (!sub_244CFDA90(&v31, (_DWORD *)&v30 + 1)) {
      return 0;
    }
    int v29 = HIDWORD(v30);
    if (SHIDWORD(v30) > 23 || !sub_244CFDA90(&v31, &v30) || (int)v30 >= 60) {
      return 0;
    }
    LODWORD(result) = (3600 * v29 + 60 * v30) * v23;
    uint64_t v22 = *((void *)&v31 + 1);
    goto LABEL_52;
  }
  uint64_t result = 0;
  if (v21 != 90)
  {
    if (v21 != 45) {
      return result;
    }
    int v23 = -1;
    goto LABEL_46;
  }
LABEL_52:
  if (v22) {
    return 0;
  }
  if (!a4) {
    return 1;
  }
  a4[4] = v13;
  a4[5] = v9 - 1900;
  a4[2] = v16;
  a4[3] = v14;
  *a4 = v20;
  a4[1] = v18;
  if (!result) {
    return 1;
  }
  uint64_t result = sub_244CF5098(a4, 0, (int)result);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t sub_244CFDA84(long long *a1, int *a2, int a3)
{
  return sub_244CFD78C(a1, 0, a3, a2);
}

BOOL sub_244CFDA90(void *a1, _DWORD *a2)
{
  uint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  int v5 = (unsigned __int8 *)(*a1)++;
  a1[1] = v2 - 1;
  int v6 = *v5;
  BOOL result = sub_244D44364(v6);
  if (!result) {
    return result;
  }
  uint64_t v8 = a1[1];
  if (!v8) {
    return 0;
  }
  int v9 = (unsigned __int8 *)(*a1)++;
  a1[1] = v8 - 1;
  int v10 = *v9;
  BOOL result = sub_244D44364(v10);
  if (result)
  {
    *a2 = v10 + 10 * v6 - 528;
    return 1;
  }
  return result;
}

uint64_t sub_244CFDB28(void *a1, unsigned int *a2)
{
  unsigned __int8 v13 = 0;
  uint64_t result = sub_244CFC650(a1, &v13);
  if (result)
  {
    unsigned int v5 = v13;
    if ((char)v13 < 0)
    {
      if ((v13 & 0xE0) == 0xC0)
      {
        unsigned int v6 = 128;
        char v7 = 31;
        uint64_t v8 = 1;
      }
      else if ((v13 & 0xF0) == 0xE0)
      {
        unsigned int v6 = 2048;
        char v7 = 15;
        uint64_t v8 = 2;
      }
      else
      {
        if ((v13 & 0xF8) != 0xF0) {
          return 0;
        }
        unsigned int v6 = 0x10000;
        char v7 = 7;
        uint64_t v8 = 3;
      }
      unsigned int v5 = (v7 & v13);
      while (1)
      {
        unsigned int v9 = v5;
        uint64_t result = sub_244CFC650(a1, &v13);
        if (!result) {
          break;
        }
        if ((v13 & 0xC0) != 0x80) {
          return 0;
        }
        unsigned int v5 = v13 & 0x3F | (v9 << 6);
        if (!--v8)
        {
          uint64_t result = 0;
          if ((v9 & 0x3FFFFE0) != 0x360)
          {
            BOOL v10 = v5 - 64976 < 0x20 || HIWORD(v5) > 0x10u;
            BOOL v11 = v10 || (v13 & 0x3E | (v9 << 6) & 0xFFFE) == 65534;
            if (!v11 && v5 >= v6) {
              goto LABEL_3;
            }
          }
          return result;
        }
      }
    }
    else
    {
LABEL_3:
      *a2 = v5;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244CFDC50(void *a1, _DWORD *a2)
{
  unsigned __int8 v4 = 0;
  uint64_t result = sub_244CFC650(a1, &v4);
  if (result)
  {
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t sub_244CFDC94(unsigned __int16 **a1, _DWORD *a2)
{
  unsigned __int16 v5 = 0;
  uint64_t result = sub_244CFC680(a1, &v5);
  if (result)
  {
    uint64_t result = 0;
    if ((v5 & 0xF800) != 0xD800 && v5 - 64976 >= 0x20 && (v5 & 0xFFFE) != 65534)
    {
      *a2 = v5;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244CFDD08(uint64_t *a1, int *a2)
{
  uint64_t result = sub_244CFC730(a1, a2);
  if (result)
  {
    unsigned int v4 = *a2;
    BOOL v6 = (~*a2 & 0xFFFE) != 0 && v4 < 0x110000 && v4 - 64976 > 0x1F;
    unsigned int v7 = v4 >> 11;
    return v6 && v7 != 27;
  }
  return result;
}

uint64_t sub_244CFDD5C(unsigned int a1)
{
  uint64_t v1 = 2;
  uint64_t v2 = 3;
  if (a1 >= 0x10000) {
    uint64_t v2 = 4;
  }
  if (a1 >= 0x800) {
    uint64_t v1 = v2;
  }
  if (a1 >= 0x80) {
    return v1;
  }
  else {
    return 1;
  }
}

uint64_t sub_244CFDD84(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0;
  if (a2 >> 11 == 27 || a2 - 64976 < 0x20 || HIWORD(a2) > 0x10u || (a2 & 0xFFFE) == 0xFFFE) {
    return result;
  }
  if (a2 > 0x7F)
  {
    if (a2 > 0x7FF)
    {
      if (!HIWORD(a2))
      {
        uint64_t result = sub_244CFB8C4(a1, (a2 >> 12) | 0xE0u);
        if (!result) {
          return result;
        }
        uint64_t result = sub_244CFB8C4(a1, (a2 >> 6) & 0x3F | 0x80);
        if (!result) {
          return result;
        }
        unsigned int v6 = a2 & 0x3F | 0x80;
        return sub_244CFB8C4(a1, v6) != 0;
      }
      uint64_t result = sub_244CFB8C4(a1, (a2 >> 18) | 0xF0u);
      if (!result) {
        return result;
      }
      uint64_t result = sub_244CFB8C4(a1, (a2 >> 12) & 0x3F | 0x80);
      if (!result) {
        return result;
      }
      unsigned int v5 = (a2 >> 6) & 0x3F | 0x80;
    }
    else
    {
      unsigned int v5 = (a2 >> 6) | 0xC0;
    }
    uint64_t result = sub_244CFB8C4(a1, v5);
    if (!result) {
      return result;
    }
    unsigned int v6 = a2 & 0x3F | 0x80;
    return sub_244CFB8C4(a1, v6) != 0;
  }

  return sub_244CFB8C4(a1, a2);
}

BOOL sub_244CFDEE0(uint64_t a1, unsigned int a2)
{
  return a2 <= 0xFF && sub_244CFB8C4(a1, a2) != 0;
}

BOOL sub_244CFDF18(uint64_t a1, unsigned int a2)
{
  if (HIWORD(a2)) {
    return 0;
  }
  BOOL result = 0;
  if (a2 >> 11 != 27 && a2 - 64976 >= 0x20 && (a2 & 0xFFFE) != 0xFFFE) {
    return sub_244CFBD5C(a1, (unsigned __int16)a2) != 0;
  }
  return result;
}

BOOL sub_244CFDF88(uint64_t a1, unsigned int a2)
{
  BOOL result = 0;
  if (a2 >> 11 != 27 && a2 - 64976 >= 0x20 && HIWORD(a2) <= 0x10u && (a2 & 0xFFFE) != 0xFFFE) {
    return sub_244CFBD80(a1, a2) != 0;
  }
  return result;
}

void *sub_244CFDFF0()
{
  return &unk_26F9546A8;
}

void *sub_244CFDFFC()
{
  return &unk_26F9546E0;
}

void *sub_244CFE008()
{
  return &unk_26F954718;
}

void *sub_244CFE014()
{
  return &unk_26F954750;
}

void *sub_244CFE020()
{
  return &unk_26F954788;
}

void *sub_244CFE02C()
{
  return &unk_26F9547C0;
}

uint64_t sub_244CFE038(uint64_t a1, _DWORD *a2)
{
  return 1;
}

uint64_t sub_244CFE060(uint64_t a1, unsigned int *a2, int *a3, unint64_t a4)
{
  return 1;
}

uint64_t sub_244CFE094(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    BOOL v10 = *(int **)(a1 + 16);
    do
    {
      sub_244D054A8((void *)(a3 + v9), (void *)(a2 + v9), v10, *(_DWORD *)(a1 + 28));
      v9 += *(unsigned int *)(*(void *)a1 + 4);
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t sub_244CFE110(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  sub_244D042A8(a2, v3);
  sub_244D042A8(a2 + 2, v3 + 128);
  sub_244D042A8(a2 + 4, v3 + 256);
  return 1;
}

uint64_t sub_244CFE15C(uint64_t a1, uint64_t a2, int *a3, unint64_t a4)
{
  return 1;
}

uint64_t sub_244CFE198(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  sub_244D042A8(a2, v3);
  sub_244D042A8(a2 + 2, v3 + 128);
  sub_244D042A8(a2, v3 + 256);
  return 1;
}

uint64_t sub_244CFE1E4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    BOOL v10 = *(int **)(a1 + 16);
    do
    {
      sub_244D06758((void *)(a3 + v9), (void *)(a2 + v9), v10, v10 + 32, v10 + 64, *(_DWORD *)(a1 + 28));
      v9 += *(unsigned int *)(*(void *)a1 + 4);
    }
    while (v9 <= v5);
  }
  return 1;
}

void *sub_244CFE278()
{
  return &unk_26F9547F8;
}

void *sub_244CFE284()
{
  return &unk_26F954830;
}

uint64_t sub_244CFE290(uint64_t a1, char *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  int v4 = sub_244D22EB0(a1);
  *(unsigned char *)(v3 + 4) = 0;
  uint64_t v5 = v3 + 4;
  int v6 = *(_DWORD *)v3;
  if (v4 >= 128) {
    int v7 = 128;
  }
  else {
    int v7 = v4;
  }
  if (v6 >= 1024) {
    int v8 = 1024;
  }
  else {
    int v8 = *(_DWORD *)v3;
  }
  if (v6 >= 1) {
    int v9 = v8;
  }
  else {
    int v9 = 1024;
  }
  if (v4 < 1) {
    goto LABEL_17;
  }
  uint64_t v10 = v7 <= 1 ? 1 : v7;
  BOOL v11 = (unsigned char *)(v3 + 4);
  do
  {
    char v12 = *a2++;
    *v11++ = v12;
    --v10;
  }
  while (v10);
  if (v4 <= 127)
  {
LABEL_17:
    char v13 = *(unsigned char *)(v5 + v7 - 1);
    uint64_t v14 = (128 - v7);
    BOOL v15 = (unsigned char *)(v3 + 4);
    do
    {
      char v13 = byte_244EAF5D8[(*v15 + v13)];
      v15[v4] = v13;
      ++v15;
      --v14;
    }
    while (v14);
  }
  int v16 = (v9 + 7) >> 3;
  uint64_t v17 = (128 - v16);
  char v18 = byte_244EAF5D8[(0xFFu >> (-(char)v9 & 7)) & (unint64_t)*(unsigned __int8 *)(v5 + v17)];
  *(unsigned char *)(v5 + v17) = v18;
  if (v16 != 128)
  {
    do
    {
      char v18 = byte_244EAF5D8[(*(unsigned char *)(v3 + v16 + v17 + 3) ^ v18)];
      *(unsigned char *)(v3 + v17-- + 3) = v18;
    }
    while (v17);
  }
  uint64_t v19 = 0;
  do
  {
    unint64_t v20 = v19 + 127;
    v19 -= 2;
  }
  while (v20 > 1);
  return 1;
}

uint64_t sub_244CFE3C4(uint64_t a1, unsigned int *a2, int *a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v8 = *(void *)(a1 + 16);
  if (a4 >= 0x10000)
  {
    do
    {
      sub_244CFE4B4(a3, a2, 0x10000, (unsigned __int16 *)(v8 + 4), (_DWORD *)(a1 + 52), *(_DWORD *)(a1 + 28));
      v4 -= 0x10000;
      a3 += 0x4000;
      a2 += 0x4000;
    }
    while (v4 >> 16);
  }
  if (v4) {
    sub_244CFE4B4(a3, a2, v4, (unsigned __int16 *)(v8 + 4), (_DWORD *)(a1 + 52), *(_DWORD *)(a1 + 28));
  }
  return 1;
}

uint64_t sub_244CFE470(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(_DWORD **)(a1 + 16);
  if (a2 == 3) {
    goto LABEL_4;
  }
  if (!a2)
  {
    a3 = 8 * sub_244D22EB0(a1);
LABEL_4:
    *uint64_t v3 = a3;
    return 1;
  }
  return 0xFFFFFFFFLL;
}

int *sub_244CFE4B4(int *result, unsigned int *a2, uint64_t a3, unsigned __int16 *a4, _DWORD *a5, int a6)
{
  int v6 = a5;
  unint64_t v8 = a3;
  uint64_t v10 = result;
  uint64_t v47 = *MEMORY[0x263EF8340];
  unsigned int v11 = *a5;
  unsigned int v12 = a5[1];
  if (a6)
  {
    if (a3 >= 8)
    {
      do
      {
        char v13 = a2;
        unint64_t v14 = v8;
        v8 -= 8;
        unsigned int v15 = *v10;
        int v16 = v10[1];
        v10 += 2;
        unsigned int v45 = v15 ^ v11;
        unsigned int v46 = v16 ^ v12;
        BOOL result = sub_244CFE808((int *)&v45, a4);
        unsigned int v11 = v45;
        unsigned int v12 = v46;
        a2 += 2;
        *char v13 = v45;
        v13[1] = v12;
      }
      while (v14 > 0xF);
    }
    if (v8)
    {
      int v17 = 0;
      char v18 = (char *)v10 + v8;
      int v19 = 0;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_12;
        case 2uLL:
          goto LABEL_11;
        case 3uLL:
          goto LABEL_10;
        case 4uLL:
          goto LABEL_9;
        case 5uLL:
          goto LABEL_8;
        case 6uLL:
          goto LABEL_7;
        case 7uLL:
          int v20 = *--v18;
          int v17 = v20 << 16;
LABEL_7:
          int v21 = *--v18;
          v17 |= v21 << 8;
LABEL_8:
          int v22 = *--v18;
          v17 |= v22;
LABEL_9:
          int v19 = v17;
          int v23 = *--v18;
          int v17 = v23 << 24;
LABEL_10:
          int v24 = *--v18;
          v17 |= v24 << 16;
LABEL_11:
          int v25 = *--v18;
          v17 |= v25 << 8;
LABEL_12:
          v17 |= *(v18 - 1);
          break;
        default:
          int v19 = 0;
          break;
      }
      unsigned int v45 = v17 ^ v11;
      unsigned int v46 = v19 ^ v12;
      BOOL result = sub_244CFE808((int *)&v45, a4);
      LOBYTE(v11) = v45;
      unsigned int v12 = v46;
      unsigned int v26 = v45 >> 8;
      unsigned int v27 = HIWORD(v45);
      unsigned int v28 = HIBYTE(v45);
      unsigned int v29 = v46 >> 8;
      unsigned int v30 = HIWORD(v46);
      unsigned int v31 = HIBYTE(v46);
      *a2 = v45;
      a2[1] = v12;
    }
    else
    {
      unsigned int v26 = v11 >> 8;
      unsigned int v27 = HIWORD(v11);
      unsigned int v28 = HIBYTE(v11);
      unsigned int v29 = v12 >> 8;
      unsigned int v30 = HIWORD(v12);
      unsigned int v31 = HIBYTE(v12);
    }
    *int v6 = v11;
    v6[1] = v26;
    v6[2] = v27;
    v6[3] = v28;
    v6[4] = v12;
    v6[5] = v29;
    v6[6] = v30;
  }
  else
  {
    if (a3 >= 8)
    {
      do
      {
        int v32 = a2;
        unsigned int v33 = v11;
        unsigned int v34 = v12;
        unsigned int v11 = *v10;
        unsigned int v12 = v10[1];
        unint64_t v35 = v8;
        v8 -= 8;
        unsigned int v36 = v10 + 2;
        unsigned int v45 = *v10;
        unsigned int v46 = v12;
        BOOL result = sub_244CFE918((int *)&v45, (uint64_t)a4);
        __int16 v37 = HIWORD(v45) ^ HIWORD(v33);
        int v38 = v46 ^ v34;
        *(_WORD *)int v32 = v45 ^ v33;
        *((_WORD *)v32 + 1) = v37;
        v32[1] = v38;
        a2 = v32 + 2;
        v10 += 2;
      }
      while (v35 > 0xF);
      uint64_t v10 = v36;
      int v6 = a5;
    }
    if (v8)
    {
      unsigned int v40 = *v10;
      unsigned int v39 = v10[1];
      unsigned int v45 = v40;
      unsigned int v46 = v39;
      BOOL result = sub_244CFE918((int *)&v45, (uint64_t)a4);
      int v41 = v45 ^ v11;
      int v42 = v46 ^ v12;
      v43 = (char *)a2 + v8;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_25;
        case 2uLL:
          goto LABEL_24;
        case 3uLL:
          goto LABEL_23;
        case 4uLL:
          goto LABEL_22;
        case 5uLL:
          goto LABEL_21;
        case 6uLL:
          goto LABEL_20;
        case 7uLL:
          *--v43 = BYTE2(v42);
LABEL_20:
          *--v43 = BYTE1(v42);
LABEL_21:
          *--v43 = v42;
LABEL_22:
          *--v43 = HIBYTE(v41);
LABEL_23:
          *--v43 = BYTE2(v41);
LABEL_24:
          *--v43 = BYTE1(v41);
LABEL_25:
          *(v43 - 1) = v41;
          break;
        default:
          break;
      }
    }
    else
    {
      unsigned int v40 = v11;
      unsigned int v39 = v12;
    }
    *(_DWORD *)int v6 = v40;
    *((_WORD *)v6 + 2) = v39;
    unsigned int v31 = HIBYTE(v39);
    v6[6] = BYTE2(v39);
  }
  v6[7] = v31;
  return result;
}

int *sub_244CFE808(int *result, unsigned __int16 *a2)
{
  int v2 = *result;
  unsigned int v3 = result[1];
  int v4 = HIWORD(*result);
  int v5 = HIWORD(v3);
  int v6 = 3;
  int v7 = a2;
  int v8 = 5;
  while (1)
  {
    do
    {
      unsigned int v9 = *v7 + (v4 & ~v5) + v2 + (v5 & v3);
      int v2 = (v9 >> 15) & 1 | (2 * (unsigned __int16)v9);
      LOWORD(v9) = v7[1] + (v2 & v5) + (v3 & ~(_WORD)v2) + v4;
      int v4 = ((unsigned __int16)v9 >> 14) & 0xFFFC0003 | (4 * (unsigned __int16)v9);
      LOWORD(v9) = v7[2] + (v4 & v2) + (v5 & ~(_WORD)v4) + v3;
      unsigned int v3 = ((unsigned __int16)v9 >> 13) & 0xFFF80007 | (8 * (unsigned __int16)v9);
      uint64_t v10 = v7 + 4;
      unsigned __int16 v11 = v7[3] + (v3 & v4) + (v2 & ~(_WORD)v3) + v5;
      int v5 = (v11 >> 11) & 0xFFE0001F | (32 * v11);
      int v7 = v10;
      --v8;
    }
    while (v8);
    if (!--v6) {
      break;
    }
    if (v6 == 2) {
      int v8 = 6;
    }
    else {
      int v8 = 5;
    }
    int v2 = (unsigned __int16)v2 + a2[v5 & 0x3F];
    int v4 = (unsigned __int16)v4 + a2[v2 & 0x3F];
    unsigned int v3 = (unsigned __int16)v3 + a2[v4 & 0x3F];
    int v5 = a2[v3 & 0x3F] + (unsigned __int16)v5;
    int v7 = v10;
  }
  *BOOL result = (unsigned __int16)v2 | ((unsigned __int16)v4 << 16);
  result[1] = (unsigned __int16)v3 | (v5 << 16);
  return result;
}

int *sub_244CFE918(int *result, uint64_t a2)
{
  int v3 = *result;
  unsigned int v2 = result[1];
  unsigned int v4 = HIWORD(*result);
  unsigned int v5 = HIWORD(v2);
  int v6 = (_WORD *)(a2 + 126);
  int v7 = 3;
  int v8 = 5;
  while (1)
  {
    int v9 = ((v5 << 11) | (v5 >> 5)) - (v3 & ~(unsigned __int16)v2 | v2 & v4) - (unsigned __int16)*v6;
    unsigned int v5 = (unsigned __int16)((((_WORD)v5 << 11) | (v5 >> 5)) - (v3 & ~(_WORD)v2 | v2 & v4) - *v6);
    int v10 = (((unsigned __int16)v2 << 13) | ((unsigned __int16)v2 >> 3))
        - ((v4 & v3)
         + (unsigned __int16)*(v6 - 1))
        - (v9 & ~v4);
    unsigned int v2 = (unsigned __int16)((((_WORD)v2 << 13) | ((unsigned __int16)v2 >> 3))
                          - ((v4 & v3)
                           + *(v6 - 1))
                          - (v9 & ~(_WORD)v4));
    int v11 = ((v4 << 14) | (v4 >> 2)) - (unsigned __int16)*(v6 - 2) - (v10 & ~(unsigned __int16)v3 | v9 & v3);
    unsigned int v4 = (unsigned __int16)((((_WORD)v4 << 14) | (v4 >> 2)) - *(v6 - 2) - (v10 & ~(_WORD)v3 | v9 & v3));
    LOWORD(v3) = (((unsigned __int16)v3 >> 1) | ((_WORD)v3 << 15)) - *(v6 - 3) - (v11 & ~(_WORD)v5 | v10 & v9);
    if (--v8) {
      goto LABEL_8;
    }
    if (!--v7) {
      break;
    }
    __int16 v12 = *(_WORD *)(a2 + 2 * (v10 & 0x3F));
    if (v7 == 2) {
      int v8 = 6;
    }
    else {
      int v8 = 5;
    }
    char v13 = v9 - v12;
    unsigned int v5 = (unsigned __int16)(v9 - v12);
    __int16 v14 = *(_WORD *)(a2 + 2 * (v3 & 0x3F));
    LOWORD(v3) = v3 - *(_WORD *)(a2 + 2 * (v13 & 0x3F));
    unsigned int v4 = (unsigned __int16)(v11 - v14);
    unsigned int v2 = (unsigned __int16)(v10 - *(_WORD *)(a2 + 2 * (v11 & 0x3F)));
LABEL_8:
    int v3 = (unsigned __int16)v3;
    v6 -= 4;
  }
  *BOOL result = (unsigned __int16)v3 | ((unsigned __int16)v4 << 16);
  result[1] = v2 | (v5 << 16);
  return result;
}

void *sub_244CFEA3C()
{
  return &unk_26F954868;
}

uint64_t sub_244CFEA48(uint64_t a1, uint64_t a2)
{
  int v3 = *(void **)(a1 + 16);
  int v4 = sub_244D22EB0(a1);
  sub_244D4996C(v3, v4, a2);
  return 1;
}

uint64_t sub_244CFEA84(uint64_t a1, unsigned char *a2, char *a3, uint64_t a4)
{
  return 1;
}

uint64_t *sub_244CFEAB0(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  uint64_t v1 = sub_244D43FF4(0x10uLL);
  if (v1)
  {
    v1[1] = (uint64_t)sub_244D43AD0((uint64_t)sub_244CFEB54, (uint64_t)sub_244CFEB5C);
    int v3 = sub_244D43AD0((uint64_t)sub_244CFEB68, (uint64_t)sub_244CFEBA0);
    uint64_t *v1 = (uint64_t)v3;
    if (!v1[1] || v3 == 0)
    {
      sub_244CFEBF8(v1);
      return 0;
    }
  }
  return v1;
}

uint64_t sub_244CFEB54(const char **a1)
{
  return sub_244D44234(*a1);
}

uint64_t sub_244CFEB5C(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t sub_244CFEB68(const char **a1)
{
  int v2 = sub_244D44234(*a1);
  return sub_244D44234(a1[1]) ^ (4 * v2);
}

uint64_t sub_244CFEBA0(const char **a1, const char **a2)
{
  uint64_t result = strcmp(*a1, *a2);
  if (!result)
  {
    unsigned int v5 = a1[1];
    int v6 = a2[1];
    return strcmp(v5, v6);
  }
  return result;
}

void sub_244CFEBF8(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[1];
    int v4 = sub_244CFEC98;
    uint64_t v5 = 0;
    sub_244D43E94(v2, (void (*)(void, uint64_t))sub_244CFF990, (uint64_t)&v4);
    sub_244D43B40((void *)a1[1]);
    uint64_t v3 = *a1;
    int v4 = sub_244CFEC9C;
    uint64_t v5 = 0;
    sub_244D43E94(v3, (void (*)(void, uint64_t))sub_244CFF9E4, (uint64_t)&v4);
    sub_244D43B40((void *)*a1);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244CFECA0(uint64_t a1, uint64_t a2)
{
  v3[0] = a2;
  v3[1] = 0;
  uint64_t result = sub_244D43BC4(*(void **)(a1 + 8), (uint64_t)v3, (uint64_t (*)(void, uint64_t))sub_244CFF9EC, (unsigned int (*)(void, void, uint64_t))sub_244CFF9F8);
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t sub_244CFECF4(void **a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = "default";
  if (a2) {
    uint64_t v3 = a2;
  }
  v5[1] = a3;
  v5[2] = 0;
  v5[0] = v3;
  uint64_t result = sub_244D43BC4(*a1, (uint64_t)v5, (uint64_t (*)(void, uint64_t))sub_244CFFA08, (unsigned int (*)(void, void, uint64_t))sub_244CFFA14);
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t sub_244CFED5C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  __s2 = 0;
  int v6 = sub_244CFAC60();
  if (!v6)
  {
    int v69 = 7;
    __int16 v70 = 424;
LABEL_138:
    sub_244D0B884(13, 0, v69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/conf/conf.c", v70);
    goto LABEL_139;
  }
  int v7 = (char *)sub_244D442B0("default");
  __s2 = v7;
  if (!v7)
  {
LABEL_139:
    uint64_t v10 = 0;
    goto LABEL_145;
  }
  int v8 = sub_244CFF4A0(a1, v7);
  if (!v8)
  {
    int v69 = 104;
    __int16 v70 = 435;
    goto LABEL_138;
  }
  uint64_t v9 = (uint64_t)v8;
  if (!sub_244CFAD1C(v6, 0x200uLL))
  {
    uint64_t v10 = 0;
    goto LABEL_141;
  }
  uint64_t v10 = 0;
  while (2)
  {
    uint64_t v11 = 0;
    char v12 = 0;
    LODWORD(v13) = 0;
LABEL_7:
    uint64_t v14 = v6[1] + v11;
    *(unsigned char *)uint64_t v14 = 0;
    sub_244CF847C(a2, v14, 511);
    *(unsigned char *)(v14 + 511) = 0;
    int v15 = strlen((const char *)v14);
    if ((v12 & 1) == 0 && !v15)
    {
      sub_244CF474C((uint64_t)v6);
      sub_244D440EC(__s2);
      return 1;
    }
    int v16 = v15;
    if (v15 >= 1)
    {
      uint64_t v17 = v15 + 1;
      int v16 = v15;
      while (1)
      {
        int v18 = *(unsigned __int8 *)(v14 + (v17 - 2));
        BOOL v19 = v18 == 13 || v18 == 10;
        if (!v19) {
          break;
        }
        --v16;
        if ((unint64_t)--v17 <= 1)
        {
          int v16 = 0;
          break;
        }
      }
    }
    if (v15) {
      BOOL v20 = v16 == v15;
    }
    else {
      BOOL v20 = 0;
    }
    char v21 = v20;
    if (!v20)
    {
      *(unsigned char *)(v14 + v16) = 0;
      ++v10;
    }
    LODWORD(v13) = v16 + v13;
    if ((int)v13 >= 1 && (int v22 = (unsigned char *)(v6[1] + (v13 - 1)), *v22 == 92))
    {
      if ((int)v13 < 2)
      {
        char v12 = 1;
        LODWORD(v13) = v13 - 1;
        goto LABEL_114;
      }
      if (*(v22 - 1) != 92)
      {
        char v21 = 1;
        LODWORD(v13) = v13 - 1;
      }
      if (v21)
      {
LABEL_31:
        char v12 = 1;
        goto LABEL_114;
      }
    }
    else if (v21)
    {
      goto LABEL_31;
    }
    int v23 = (char *)v6[1];
    for (uint64_t i = v23; ; ++i)
    {
      int v25 = *i;
      if (v25 > 0x20 || ((1 << v25) & 0x100002600) == 0) {
        break;
      }
    }
    while (v25 > 38)
    {
      if (v25 != 39)
      {
        if (v25 == 92)
        {
          if (*++i) {
            ++i;
          }
          goto LABEL_62;
        }
        if (v25 != 96) {
          goto LABEL_59;
        }
      }
LABEL_44:
      unsigned int v27 = (unsigned __int8 *)(i + 1);
      int v28 = i[1];
      BOOL v29 = v28 == v25;
      if (i[1]) {
        BOOL v30 = v28 == v25;
      }
      else {
        BOOL v30 = 1;
      }
      if (v30)
      {
LABEL_56:
        i += 2;
        if (!v29) {
          uint64_t i = (char *)v27;
        }
      }
      else
      {
        while (1)
        {
          unsigned int v31 = v27;
          if (v28 == 92)
          {
            int v32 = i[2];
            i += 2;
            unsigned int v31 = (unsigned __int8 *)i;
            if (!v32) {
              break;
            }
          }
          unsigned int v27 = v31 + 1;
          int v28 = v31[1];
          BOOL v29 = v28 == v25;
          if (v31[1]) {
            BOOL v33 = v28 == v25;
          }
          else {
            BOOL v33 = 1;
          }
          uint64_t i = (char *)v31;
          if (v33)
          {
            uint64_t i = (char *)v31;
            goto LABEL_56;
          }
        }
      }
LABEL_62:
      int v25 = *i;
    }
    if (v25 == 34) {
      goto LABEL_44;
    }
    if (!v25) {
      goto LABEL_68;
    }
    if (v25 != 35)
    {
LABEL_59:
      ++i;
      goto LABEL_62;
    }
    *uint64_t i = 0;
LABEL_68:
    for (j = v23 + 1; ; ++j)
    {
      unsigned int v36 = *v23;
      if (v36 > 0x20) {
        goto LABEL_74;
      }
      if (((1 << v36) & 0x100002600) == 0) {
        break;
      }
      ++v23;
    }
    if (!*v23)
    {
      char v12 = 0;
      LODWORD(v13) = 0;
      goto LABEL_114;
    }
LABEL_74:
    if (v36 == 91)
    {
      while (1)
      {
        unsigned int v61 = *(unsigned __int8 *)j;
        BOOL v45 = v61 > 0x20;
        uint64_t v62 = (1 << v61) & 0x100002600;
        if (v45 || v62 == 0) {
          break;
        }
        ++j;
      }
      v64 = (char *)j;
      while (2)
      {
        v65 = sub_244CFF55C(v64);
        for (k = v65; ; ++k)
        {
          unsigned int v67 = *k;
          if (v67 > 0x20) {
            goto LABEL_127;
          }
          if (((1 << v67) & 0x100002600) == 0) {
            break;
          }
        }
        if (!*k)
        {
LABEL_142:
          int v71 = 101;
          __int16 v72 = 512;
          goto LABEL_144;
        }
LABEL_127:
        if (v67 != 93)
        {
          BOOL v19 = k == v64;
          v64 = k;
          if (!v19) {
            continue;
          }
          goto LABEL_142;
        }
        break;
      }
      char *v65 = 0;
      if (!sub_244CFF5F4((void **)&__s2, j)) {
        goto LABEL_145;
      }
      v68 = __s2;
      *(void *)__str = __s2;
      uint64_t v84 = 0;
      uint64_t v9 = sub_244D43BC4(*(void **)(a1 + 8), (uint64_t)__str, (uint64_t (*)(void, uint64_t))sub_244CFF9EC, (unsigned int (*)(void, void, uint64_t))sub_244CFF9F8);
      if (v9 || (uint64_t v9 = (uint64_t)sub_244CFF4A0(a1, v68)) != 0)
      {
        if (sub_244CFAD1C(v6, 0x200uLL)) {
          continue;
        }
        goto LABEL_141;
      }
      int v71 = 104;
      __int16 v72 = 523;
LABEL_144:
      sub_244D0B884(13, 0, v71, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/conf/conf.c", v72);
LABEL_145:
      v56 = 0;
      goto LABEL_146;
    }
    break;
  }
  __int16 v37 = sub_244CFF55C(v23);
  uint64_t v81 = a2;
  if (*v37 == 58 && v37[1] == 58)
  {
    *__int16 v37 = 0;
    int v38 = v37 + 2;
    __int16 v37 = sub_244CFF55C(v37 + 2);
    unsigned int v39 = v23;
    int v23 = v38;
  }
  else
  {
    unsigned int v39 = 0;
  }
  unsigned int v40 = v37 + 1;
  for (m = v37; ; ++m)
  {
    uint64_t v42 = *((unsigned __int8 *)v40 - 1);
    if (v42 > 0x3D) {
      goto LABEL_143;
    }
    if (((1 << v42) & 0x100002600) == 0) {
      break;
    }
    ++v40;
  }
  if (v42 != 61)
  {
LABEL_143:
    int v71 = 102;
    __int16 v72 = 540;
    goto LABEL_144;
  }
  *__int16 v37 = 0;
  for (uint64_t n = 1; ; ++n)
  {
    unsigned int v44 = *(unsigned __int8 *)v40;
    BOOL v45 = v44 > 0x20;
    uint64_t v46 = (1 << v44) & 0x100002600;
    if (v45 || v46 == 0) {
      break;
    }
    ++v40;
  }
  do
  {
    uint64_t v48 = n;
    int v49 = *++m;
    --n;
  }
  while (v49);
  do
  {
    v50 = m;
    if (!v48) {
      break;
    }
    --m;
    unsigned int v51 = *(v50 - 1);
    BOOL v52 = v51 == 10;
    BOOL v45 = v51 > 0x20;
    uint64_t v53 = (1 << v51) & 0x100002200;
    BOOL v54 = v45 || v53 == 0;
    BOOL v55 = !v54 || v52;
    ++v48;
  }
  while (v55);
  char *v50 = 0;
  v56 = sub_244D44058(0x18uLL);
  if (!v56) {
    goto LABEL_146;
  }
  if (!v39) {
    unsigned int v39 = __s2;
  }
  v57 = sub_244D442B0(v23);
  v56[1] = v57;
  if (!v57 || !sub_244CFF5F4((void **)v56 + 2, v40)) {
    goto LABEL_146;
  }
  uint64_t v58 = v9;
  if (!strcmp(v39, __s2)
    || (*(void *)__str = v39,
        uint64_t v84 = 0,
        (uint64_t v58 = sub_244D43BC4(*(void **)(a1 + 8), (uint64_t)__str, (uint64_t (*)(void, uint64_t))sub_244CFF9EC, (unsigned int (*)(void, void, uint64_t))sub_244CFF9F8)) != 0)|| (uint64_t v58 = (uint64_t)sub_244CFF4A0(a1, v39)) != 0)
  {
    v59 = sub_244D442B0(*(const char **)v58);
    void *v56 = v59;
    if (!v59 || !sub_244D4BA04(*(unint64_t **)(v58 + 8), (uint64_t)v56)) {
      goto LABEL_146;
    }
    v60 = *(void **)a1;
    *(void *)__str = 0;
    if (!sub_244D43D34(v60, __str, (uint64_t)v56, (uint64_t (*)(void, uint64_t))sub_244CFFA08, (unsigned int (*)(void, void, uint64_t))sub_244CFFA14))
    {
      sub_244D4BA0C(*(uint64_t **)(v58 + 8));
      goto LABEL_146;
    }
    char v13 = *(void **)__str;
    if (*(void *)__str)
    {
      sub_244D4B78C(*(uint64_t **)(v58 + 8), *(uint64_t *)__str);
      sub_244CFF79C(v13);
      char v12 = 0;
      LODWORD(v13) = 0;
    }
    else
    {
      char v12 = 0;
    }
    a2 = v81;
LABEL_114:
    uint64_t v11 = (int)v13;
    if (!sub_244CFAD1C(v6, (int)v13 + 512))
    {
LABEL_141:
      int v71 = 7;
      __int16 v72 = 443;
      goto LABEL_144;
    }
    goto LABEL_7;
  }
  sub_244D0B884(13, 0, 104, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/conf/conf.c", 576);
LABEL_146:
  sub_244CF474C((uint64_t)v6);
  sub_244D440EC(__s2);
  if (a3) {
    *a3 = v10;
  }
  snprintf(__str, 0x18uLL, "%ld", v10);
  sub_244D0B930(2u, v73, v74, v75, v76, v77, v78, v79, (uint64_t)"line ");
  sub_244CFF79C(v56);
  return 0;
}

void *sub_244CFF4A0(uint64_t a1, const char *a2)
{
  int v4 = sub_244D43FF4(0x10uLL);
  if (v4)
  {
    *int v4 = sub_244D442B0(a2);
    uint64_t v5 = sub_244D4B4C8();
    v4[1] = v5;
    if (*v4) {
      BOOL v6 = v5 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6
      || (int v7 = *(void **)(a1 + 8),
          uint64_t v9 = 0,
          !sub_244D43D34(v7, &v9, (uint64_t)v4, (uint64_t (*)(void, uint64_t))sub_244CFF9EC, (unsigned int (*)(void, void, uint64_t))sub_244CFF9F8)))
    {
      sub_244CFF998(v4);
      return 0;
    }
    else
    {
      sub_244CFF998(v9);
    }
  }
  return v4;
}

char *sub_244CFF55C(char *a1)
{
  while (1)
  {
    while (1)
    {
      int v2 = *a1;
      if (v2 != 92) {
        break;
      }
      if (*++a1) {
        ++a1;
      }
    }
    if (!sub_244D443E0(*a1))
    {
      BOOL v4 = v2 - 33 > 0x3E
        || ((1 << (v2 - 33)) & 0x60000000C4007E31) == 0;
      if (v4 && v2 != 124 && v2 != 126) {
        break;
      }
    }
    ++a1;
  }
  return a1;
}

uint64_t sub_244CFF5F4(void **a1, const char *a2)
{
  uint64_t result = (uint64_t)sub_244CFAC60();
  if (result)
  {
    uint64_t v5 = (unint64_t *)result;
    int v6 = strlen(a2);
    if (!sub_244CFAD1C(v5, v6 + 1))
    {
LABEL_40:
      sub_244CF474C((uint64_t)v5);
      return 0;
    }
    for (int i = 0; ; ++i)
    {
      while (1)
      {
        unsigned int v8 = *(unsigned __int8 *)a2;
        if (v8 > 0x26) {
          break;
        }
        if (v8 != 34)
        {
          if (!*a2) {
            goto LABEL_41;
          }
          if (v8 == 36)
          {
            sub_244D0B884(13, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/conf/conf.c", 259);
            goto LABEL_40;
          }
LABEL_27:
          ++a2;
          goto LABEL_39;
        }
LABEL_12:
        uint64_t v9 = (unsigned __int8 *)(a2 + 1);
        int v10 = *((unsigned __int8 *)a2 + 1);
        if (a2[1]) {
          BOOL v11 = v10 == v8;
        }
        else {
          BOOL v11 = 1;
        }
        if (!v11)
        {
          uint64_t v12 = i;
          do
          {
            if (v10 == 92)
            {
              int v10 = *((unsigned __int8 *)a2 + 2);
              uint64_t v9 = (unsigned __int8 *)(a2 + 2);
              if (!a2[2]) {
                break;
              }
            }
            a2 = (const char *)v9;
            *(unsigned char *)(v5[1] + v12++) = v10;
            ++i;
            int v13 = *++v9;
            int v10 = v13;
          }
          while (v13 && v10 != v8);
        }
        if (v10 == v8) {
          a2 = (const char *)(v9 + 1);
        }
        else {
          a2 = (const char *)v9;
        }
      }
      if (v8 == 96) {
        goto LABEL_12;
      }
      if (v8 != 92)
      {
        if (v8 != 39) {
          goto LABEL_27;
        }
        goto LABEL_12;
      }
      unsigned int v8 = *((unsigned __int8 *)a2 + 1);
      if (v8 <= 0x6D)
      {
        if (v8 != 98)
        {
          if (!a2[1])
          {
LABEL_41:
            *(unsigned char *)(v5[1] + i) = 0;
            sub_244D440EC(*a1);
            *a1 = (void *)v5[1];
            sub_244D440EC(v5);
            return 1;
          }
LABEL_36:
          if (v8 == 116) {
            LOBYTE(v8) = 9;
          }
          goto LABEL_38;
        }
        LOBYTE(v8) = 8;
      }
      else if (v8 == 114)
      {
        LOBYTE(v8) = 13;
      }
      else
      {
        if (v8 != 110) {
          goto LABEL_36;
        }
        LOBYTE(v8) = 10;
      }
LABEL_38:
      a2 += 2;
LABEL_39:
      *(unsigned char *)(v5[1] + i) = v8;
    }
  }
  return result;
}

void sub_244CFF79C(void *a1)
{
  if (a1)
  {
    sub_244D440EC((void *)*a1);
    sub_244D440EC((void *)a1[1]);
    sub_244D440EC((void *)a1[2]);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244CFF7F0(uint64_t a1, const char *a2, uint64_t *a3)
{
  uint64_t v5 = sub_244CF8FF4(a2, "rb");
  if (v5)
  {
    uint64_t v6 = (uint64_t)v5;
    uint64_t v7 = sub_244CFED5C(a1, (uint64_t)v5, a3);
    sub_244CF830C(v6);
    return v7;
  }
  else
  {
    sub_244D0B884(13, 0, 2, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/conf/conf.c", 609);
    return 0;
  }
}

uint64_t sub_244CFF87C(char *__s, int __c, int a3, uint64_t (*a4)(char *, uint64_t, uint64_t), uint64_t a5)
{
  if (__s)
  {
    uint64_t v9 = __s;
    while (1)
    {
      if (a3)
      {
        int v10 = *v9;
        if (*v9)
        {
          do
          {
            if (!sub_244D44410(v10)) {
              break;
            }
            int v11 = *++v9;
            int v10 = v11;
          }
          while (v11);
        }
      }
      uint64_t v12 = strchr(v9, __c);
      int v13 = v12;
      if (v12 != v9)
      {
        if (*v9) {
          break;
        }
      }
      int v15 = 0;
      uint64_t v16 = 0;
LABEL_18:
      uint64_t result = a4(v15, v16, a5);
      if ((int)result < 1) {
        return result;
      }
      uint64_t v9 = v13 + 1;
      if (!v13) {
        return 1;
      }
    }
    uint64_t v14 = v12;
    if (v12)
    {
      if (!a3) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v14 = &v9[strlen(v9)];
      if (!a3)
      {
LABEL_16:
        --v14;
LABEL_17:
        uint64_t v16 = v14 - v9 + 1;
        int v15 = v9;
        goto LABEL_18;
      }
    }
    do
      int v17 = *--v14;
    while (sub_244D44410(v17));
    goto LABEL_17;
  }
  sub_244D0B884(13, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/conf/conf.c", 626);
  return 0;
}

uint64_t sub_244CFF990(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))a2)(a1, *(void *)(a2 + 8));
}

void sub_244CFF998(void *a1)
{
  if (a1)
  {
    sub_244D440EC((void *)*a1);
    sub_244CF474C(a1[1]);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244CFF9E4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))a2)(a1, *(void *)(a2 + 8));
}

uint64_t sub_244CFF9EC(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244CFF9F8(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t sub_244CFFA08(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244CFFA14(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

unsigned char *sub_244CFFA24(unsigned char *a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  long long v4 = *(_OWORD *)(a2 + 96);
  v12[0] = *(_OWORD *)(a2 + 80);
  v12[1] = v4;
  uint64_t v13 = *(void *)(a2 + 112);
  sub_244D03D54((uint64_t)v10, (unint64_t *)v12);
  sub_244D03FA4((uint64_t)v8, (unint64_t *)a2, (unint64_t *)v10);
  sub_244D03FA4((uint64_t)v6, (unint64_t *)(a2 + 40), (unint64_t *)v10);
  sub_244CFFAFC(a1, v6);
  uint64_t result = sub_244CFFAFC(v12, v8);
  a1[31] ^= LOBYTE(v12[0]) << 7;
  return result;
}

unsigned char *sub_244CFFAFC(unsigned char *result, void *a2)
{
  unint64_t v2 = *a2 - 0x7FFFFFFFFFFEDLL;
  unint64_t v3 = a2[1] - -(uint64_t)(v2 >> 51) - 0x7FFFFFFFFFFFFLL;
  unint64_t v4 = a2[2] - -(uint64_t)(v3 >> 51) - 0x7FFFFFFFFFFFFLL;
  unint64_t v5 = a2[3] - -(uint64_t)(v4 >> 51) - 0x7FFFFFFFFFFFFLL;
  uint64_t v6 = v2 & 0x7FFFFFFFFFFFFLL;
  uint64_t v7 = v3 & 0x7FFFFFFFFFFFFLL;
  uint64_t v8 = v4 & 0x7FFFFFFFFFFFFLL;
  uint64_t v9 = v5 & 0x7FFFFFFFFFFFFLL;
  uint64_t v10 = a2[4] - -(uint64_t)(v5 >> 51) - 0x7FFFFFFFFFFFFLL;
  if ((v10 & 0x7F8000000000000) != 0) {
    uint64_t v11 = -1;
  }
  else {
    uint64_t v11 = 0;
  }
  unint64_t v12 = (v11 & 0x7FFFFFFFFFFEDLL) + v6;
  result[1] = BYTE1(v12);
  result[2] = BYTE2(v12);
  result[3] = (unint64_t)((v11 & 0xFFFFFFED) + v6) >> 24;
  result[4] = BYTE4(v12);
  result[5] = BYTE5(v12);
  unint64_t v13 = (v11 & 0x7FFFFFFFFFFFFLL) + v7 + (v12 >> 51);
  *uint64_t result = v12;
  result[6] = BYTE6(v12) & 7 | (8 * (v11 + v7 + (v12 >> 51)));
  result[7] = v13 >> 5;
  result[8] = v13 >> 13;
  result[9] = v13 >> 21;
  result[10] = v13 >> 29;
  result[11] = v13 >> 37;
  unint64_t v14 = v8 + (v11 & 0x7FFFFFFFFFFFFLL) + (v13 >> 51);
  result[12] = (v13 >> 45) & 0x3F | (((_BYTE)v8 + (_BYTE)v11 + (v13 >> 51)) << 6);
  result[13] = v14 >> 2;
  result[14] = v14 >> 10;
  result[15] = v14 >> 18;
  result[16] = v14 >> 26;
  result[17] = v14 >> 34;
  result[18] = v14 >> 42;
  unint64_t v15 = v9 + (v11 & 0x7FFFFFFFFFFFFLL) + (v14 >> 51);
  result[19] = ((v14 & 0x4000000000000) != 0) | (2 * (v9 + v11 + (v14 >> 51)));
  result[20] = v15 >> 7;
  result[21] = v15 >> 15;
  result[22] = v15 >> 23;
  result[23] = v15 >> 31;
  result[24] = v15 >> 39;
  unint64_t v16 = v10 + v11 + (v15 >> 51);
  result[25] = (v15 >> 47) & 0xF | (16 * v16);
  result[26] = v16 >> 4;
  result[27] = v16 >> 12;
  result[28] = v16 >> 20;
  result[29] = v16 >> 28;
  result[30] = v16 >> 36;
  result[31] = (v16 >> 44) & 0x7F;
  return result;
}

uint64_t sub_244CFFCB4(uint64_t a1, int64x2_t *a2)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v48 = 0;
  long long v46 = 0u;
  long long v47 = 0u;
  memset(v45, 0, 40);
  unint64_t v3 = (unint64_t *)(a1 + 40);
  int64x2_t v4 = a2[1];
  int64x2_t v57 = *a2;
  int64x2_t v58 = v4;
  v58.i8[15] = v4.i8[15] & 0x7F;
  sub_244D00C4C((unint64_t *)(a1 + 40), (unsigned int *)&v57);
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 80) = 1;
  unsigned int v39 = v3;
  sub_244D001D8((uint64_t)&v46, v3);
  sub_244D03FA4((uint64_t)v45, (unint64_t *)&v46, qword_244EB56F0);
  uint64_t v5 = *(void *)(a1 + 96);
  int64x2_t v6 = vaddq_s64(*(int64x2_t *)((char *)v45 + 8), *(int64x2_t *)(a1 + 88));
  uint64_t v7 = *(void *)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 112);
  int64x2_t v9 = vaddq_s64(*(int64x2_t *)((char *)&v45[1] + 8), *(int64x2_t *)(a1 + 104));
  uint64_t v10 = *(void *)(a1 + 104);
  uint64_t v49 = *(void *)&v45[0] + 1;
  unint64_t v11 = *((void *)&v46 + 1) - v7 + ((unint64_t)(v46 + 0xFFFFFFFFFFFD9) >> 51) + 0xFFFFFFFFFFFFELL;
  unint64_t v12 = v47 - v5 + (v11 >> 51) + 0xFFFFFFFFFFFFELL;
  uint64_t v13 = v12 & 0x7FFFFFFFFFFFFLL;
  int64x2_t v50 = v6;
  unint64_t v14 = *((void *)&v47 + 1) - v10 + (v12 >> 51) + 0xFFFFFFFFFFFFELL;
  unint64_t v15 = v48 - v8 + (v14 >> 51) + 0xFFFFFFFFFFFFELL;
  unint64_t v16 = ((v46 + 0xFFFFFFFFFFFD9) & 0x7FFFFFFFFFFFFLL) + 19 * (v15 >> 51);
  unint64_t v17 = (v11 & 0x7FFFFFFFFFFFFLL) + (v16 >> 51);
  uint64_t v18 = v16 & 0x7FFFFFFFFFFFFLL;
  uint64_t v19 = v17 & 0x7FFFFFFFFFFFFLL;
  v52[0] = v16 & 0x7FFFFFFFFFFFFLL;
  v52[1] = v17 & 0x7FFFFFFFFFFFFLL;
  unint64_t v20 = v13 + (v17 >> 51);
  uint64_t v21 = v14 & 0x7FFFFFFFFFFFFLL;
  v52[2] = v20;
  v52[3] = v14 & 0x7FFFFFFFFFFFFLL;
  uint64_t v22 = v15 & 0x7FFFFFFFFFFFFLL;
  v52[4] = v15 & 0x7FFFFFFFFFFFFLL;
  int64x2_t v51 = v9;
  sub_244D03FA4((uint64_t)&v46, v52, (unint64_t *)&v49);
  uint64_t v59 = 0;
  int64x2_t v57 = 0u;
  int64x2_t v58 = 0u;
  uint64_t v56 = 0;
  memset(v55, 0, sizeof(v55));
  sub_244D001D8((uint64_t)&v57, (unint64_t *)&v46);
  sub_244D001D8((uint64_t)v55, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
  sub_244D03FA4((uint64_t)v55, (unint64_t *)&v46, (unint64_t *)v55);
  sub_244D03FA4((uint64_t)&v57, (unint64_t *)&v57, (unint64_t *)v55);
  sub_244D001D8((uint64_t)&v57, (unint64_t *)&v57);
  sub_244D03FA4((uint64_t)&v57, (unint64_t *)v55, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)v55, (unint64_t *)&v57);
  int v23 = 4;
  do
  {
    sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
    --v23;
  }
  while (v23);
  sub_244D03FA4((uint64_t)&v57, (unint64_t *)v55, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)v55, (unint64_t *)&v57);
  int v24 = 9;
  do
  {
    sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
    --v24;
  }
  while (v24);
  uint64_t v54 = 0;
  memset(v53, 0, sizeof(v53));
  sub_244D03FA4((uint64_t)v55, (unint64_t *)v55, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)v53, (unint64_t *)v55);
  int v25 = 19;
  do
  {
    sub_244D001D8((uint64_t)v53, (unint64_t *)v53);
    --v25;
  }
  while (v25);
  sub_244D03FA4((uint64_t)v55, (unint64_t *)v53, (unint64_t *)v55);
  sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
  int v26 = 9;
  do
  {
    sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
    --v26;
  }
  while (v26);
  sub_244D03FA4((uint64_t)&v57, (unint64_t *)v55, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)v55, (unint64_t *)&v57);
  int v27 = 49;
  do
  {
    sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
    --v27;
  }
  while (v27);
  sub_244D03FA4((uint64_t)v55, (unint64_t *)v55, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)v53, (unint64_t *)v55);
  int v28 = 99;
  do
  {
    sub_244D001D8((uint64_t)v53, (unint64_t *)v53);
    --v28;
  }
  while (v28);
  sub_244D03FA4((uint64_t)v55, (unint64_t *)v53, (unint64_t *)v55);
  sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
  int v29 = 49;
  do
  {
    sub_244D001D8((uint64_t)v55, (unint64_t *)v55);
    --v29;
  }
  while (v29);
  sub_244D03FA4((uint64_t)&v57, (unint64_t *)v55, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)&v57, (unint64_t *)&v57);
  sub_244D001D8((uint64_t)&v57, (unint64_t *)&v57);
  sub_244D03FA4(a1, (unint64_t *)&v57, (unint64_t *)&v46);
  sub_244D03FA4(a1, (unint64_t *)a1, v52);
  sub_244D001D8((uint64_t)v45, (unint64_t *)a1);
  sub_244D03FA4((uint64_t)v45, (unint64_t *)v45, (unint64_t *)&v49);
  long long v30 = v45[0];
  uint64_t v40 = *(void *)&v45[0] - v18 + 0xFFFFFFFFFFFDALL;
  long long v31 = v45[1];
  uint64_t v32 = *(void *)&v45[1] - v20 + 0xFFFFFFFFFFFFELL;
  unint64_t v33 = v20;
  uint64_t v34 = *(void *)&v45[2];
  uint64_t v41 = *((void *)&v45[0] + 1) - v19 + 0xFFFFFFFFFFFFELL;
  uint64_t v42 = v32;
  uint64_t v43 = *((void *)&v45[1] + 1) - v21 + 0xFFFFFFFFFFFFELL;
  uint64_t v44 = *(void *)&v45[2] - v22 + 0xFFFFFFFFFFFFELL;
  if (sub_244D003FC(&v40))
  {
    uint64_t v40 = v30 + v18;
    uint64_t v41 = *((void *)&v30 + 1) + v19;
    uint64_t v42 = v31 + v33;
    uint64_t v43 = *((void *)&v31 + 1) + v21;
    uint64_t v44 = v34 + v22;
    if (sub_244D003FC(&v40)) {
      return 0;
    }
    sub_244D03FA4(a1, (unint64_t *)a1, qword_244EB5718);
  }
  sub_244CFFAFC(&v57, (void *)a1);
  if ((v57.i8[0] & 1) != a2[1].u8[15] >> 7)
  {
    uint64_t v36 = 0xFFFFFFFFFFFFELL - *(void *)(a1 + 32);
    int64x2_t v37 = vsubq_s64(vdupq_n_s64(0xFFFFFFFFFFFFEuLL), *(int64x2_t *)(a1 + 16));
    int64x2_t v57 = vsubq_s64((int64x2_t)xmmword_244EAF6E0, *(int64x2_t *)a1);
    int64x2_t v58 = v37;
    uint64_t v59 = v36;
    sub_244D003A0((unint64_t *)a1, &v57);
  }
  sub_244D03FA4(a1 + 120, (unint64_t *)a1, v39);
  return 1;
}

int8x16_t sub_244D001D8(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = a2[3];
  unint64_t v2 = a2[4];
  unint64_t v4 = a2[1];
  unint64_t v5 = a2[2];
  uint64_t v6 = 2 * v5;
  unint64_t v7 = *a2;
  unint64_t v8 = (v3 * (unsigned __int128)(38 * v2)) >> 64;
  uint64_t v9 = v3 * 38 * v2;
  unint64_t v10 = (v5 * (unsigned __int128)(38 * v2)) >> 64;
  uint64_t v11 = v5 * 38 * v2;
  signed long long v12 = v4 * (unsigned __int128)(38 * v2) + v5 * (unsigned __int128)(38 * v3) + v7 * (unsigned __int128)v7;
  unsigned long long v13 = v4 * (unsigned __int128)(2 * v3) + v5 * (unsigned __int128)v5 + v7 * (unsigned __int128)(2 * v2);
  unsigned long long v16 = v4 * (unsigned __int128)(2 * v5) + 19 * v2 * (unsigned __int128)v2 + v7 * (unsigned __int128)(2 * v3);
  uint64_t v15 = v16 >> 64;
  uint64_t v14 = v16;
  uint64_t v18 = v4 * v4 + v9 + v7 * v6;
  uint64_t v17 = (v4 * (unsigned __int128)v4 + __PAIR128__(v8, v9) + v7 * (unsigned __int128)(unint64_t)v6) >> 64;
  unsigned long long v20 = __PAIR128__(v10, v11) + 19 * v3 * (unsigned __int128)v3 + v7 * (unsigned __int128)(2 * v4);
  uint64_t v19 = *((void *)&v20 + 1);
  uint64_t v21 = v12 >> 51;
  if (__CFADD__((void)v20, v21)) {
    uint64_t v19 = *((void *)&v20 + 1) + 1;
  }
  *((void *)&v23 + 1) = v19;
  *(void *)&long long v23 = v20 + v21;
  uint64_t v22 = v23 >> 51;
  BOOL v24 = __CFADD__(v18, v22);
  uint64_t v25 = v18 + v22;
  if (v24) {
    ++v17;
  }
  *((void *)&v27 + 1) = v17;
  *(void *)&long long v27 = v25;
  uint64_t v26 = v27 >> 51;
  BOOL v24 = __CFADD__(v14, v26);
  uint64_t v28 = v14 + v26;
  if (v24) {
    uint64_t v29 = v15 + 1;
  }
  else {
    uint64_t v29 = v15;
  }
  *((void *)&v31 + 1) = v29;
  *(void *)&long long v31 = v28;
  uint64_t v30 = v31 >> 51;
  BOOL v24 = __CFADD__((void)v13, v30);
  uint64_t v32 = v13 + v30;
  v33.i64[0] = v28;
  if (v24) {
    uint64_t v34 = *((void *)&v13 + 1) + 1;
  }
  else {
    uint64_t v34 = *((void *)&v13 + 1);
  }
  *((void *)&v35 + 1) = v34;
  *(void *)&long long v35 = v32;
  v33.i64[1] = v32;
  unint64_t v36 = (v12 & 0x7FFFFFFFFFFFFLL) + 19 * (v35 >> 51);
  unint64_t v37 = ((v20 + v21) & 0x7FFFFFFFFFFFFLL) + (v36 >> 51);
  *(void *)a1 = v36 & 0x7FFFFFFFFFFFFLL;
  *(void *)(a1 + 8) = v37 & 0x7FFFFFFFFFFFFLL;
  *(void *)(a1 + 16) = (v25 & 0x7FFFFFFFFFFFFLL) + (v37 >> 51);
  int8x16_t result = vandq_s8(v33, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  *(int8x16_t *)(a1 + 24) = result;
  return result;
}

int64x2_t sub_244D0035C(int64x2_t *a1, int64x2_t *a2, int64x2_t *a3)
{
  int64x2_t result = vaddq_s64(vsubq_s64(*a2, *a3), (int64x2_t)xmmword_244EAF6E0);
  uint64_t v4 = a2[2].i64[0] - a3[2].i64[0] + 0xFFFFFFFFFFFFELL;
  int64x2_t v5 = vaddq_s64(vsubq_s64(a2[1], a3[1]), vdupq_n_s64(0xFFFFFFFFFFFFEuLL));
  *a1 = result;
  a1[1] = v5;
  a1[2].i64[0] = v4;
  return result;
}

unint64_t *sub_244D003A0(unint64_t *result, void *a2)
{
  unint64_t v2 = a2[1] + (*a2 >> 51);
  unint64_t v3 = a2[2] + (v2 >> 51);
  unint64_t v4 = a2[3] + (v3 >> 51);
  unint64_t v5 = a2[4] + (v4 >> 51);
  unint64_t v6 = (*a2 & 0x7FFFFFFFFFFFFLL) + 19 * (v5 >> 51);
  unint64_t v7 = (v2 & 0x7FFFFFFFFFFFFLL) + (v6 >> 51);
  *int64x2_t result = v6 & 0x7FFFFFFFFFFFFLL;
  result[1] = v7 & 0x7FFFFFFFFFFFFLL;
  result[2] = (v3 & 0x7FFFFFFFFFFFFLL) + (v7 >> 51);
  result[3] = v4 & 0x7FFFFFFFFFFFFLL;
  result[4] = v5 & 0x7FFFFFFFFFFFFLL;
  return result;
}

BOOL sub_244D003FC(void *a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  uint64_t v3 = 0;
  memset(v2, 0, sizeof(v2));
  sub_244D003A0((unint64_t *)v2, a1);
  sub_244CFFAFC(v4, v2);
  return sub_244D441D4(v4, byte_244EB57A8, 32) != 0;
}

double sub_244D00484(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32) + *(void *)(a2 + 72);
  int64x2_t v5 = vaddq_s64(*(int64x2_t *)(a2 + 16), *(int64x2_t *)(a2 + 56));
  *(int64x2_t *)a1 = vaddq_s64(*(int64x2_t *)a2, *(int64x2_t *)(a2 + 40));
  *(int64x2_t *)(a1 + 16) = v5;
  *(void *)(a1 + 32) = v4;
  sub_244D0035C((int64x2_t *)(a1 + 40), (int64x2_t *)(a2 + 40), (int64x2_t *)a2);
  long long v6 = *(_OWORD *)(a2 + 80);
  long long v7 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = v6;
  *(_OWORD *)(a1 + 96) = v7;

  *(void *)&double result = sub_244D03FA4(a1 + 120, (unint64_t *)(a2 + 120), qword_244EB5740).u64[0];
  return result;
}

double sub_244D0050C(uint64_t a1, unint64_t *a2)
{
  uint64_t v4 = a2 + 15;
  sub_244D03FA4(a1, a2, a2 + 15);
  int64x2_t v5 = a2 + 5;
  long long v6 = a2 + 10;
  sub_244D03FA4(a1 + 40, v5, v6);

  *(void *)&double result = sub_244D03FA4(a1 + 80, v6, v4).u64[0];
  return result;
}

double sub_244D00574(uint64_t a1, unint64_t *a2)
{
  uint64_t v4 = a2 + 15;
  sub_244D03FA4(a1, a2, a2 + 15);
  sub_244D03FA4(a1 + 40, a2 + 5, a2 + 10);
  sub_244D03FA4(a1 + 80, a2 + 10, v4);

  *(void *)&double result = sub_244D03FA4(a1 + 120, a2, a2 + 5).u64[0];
  return result;
}

uint64_t sub_244D005F8(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v42 = 0;
  int64x2_t v40 = 0u;
  int64x2_t v41 = 0u;
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  int64x2_t v6 = vaddq_s64(*(int64x2_t *)a2, *(int64x2_t *)(a2 + 40));
  int64x2_t v7 = vaddq_s64(*(int64x2_t *)(a2 + 16), *(int64x2_t *)(a2 + 56));
  *(void *)(a1 + 32) = *(void *)(a2 + 32) + *(void *)(a2 + 72);
  unint64_t v8 = (unint64_t *)(a1 + 40);
  *(int64x2_t *)a1 = v6;
  *(int64x2_t *)(a1 + 16) = v7;
  sub_244D0035C((int64x2_t *)(a1 + 40), (int64x2_t *)(a2 + 40), (int64x2_t *)a2);
  sub_244D03FA4((uint64_t)&v34, (unint64_t *)a1, a3);
  sub_244D03FA4((uint64_t)&v37, v8, a3 + 5);
  sub_244D03FA4((uint64_t)&v31, a3 + 15, (unint64_t *)(a2 + 120));
  sub_244D03FA4((uint64_t)&v40, (unint64_t *)(a2 + 80), a3 + 10);
  int64x2_t v9 = v41;
  *(int64x2_t *)(a1 + 120) = vaddq_s64(v40, v40);
  uint64_t v10 = 2 * v42;
  *(int64x2_t *)(a1 + 136) = vaddq_s64(v9, v9);
  *(void *)(a1 + 152) = v10;
  long long v11 = v34;
  long long v12 = v37;
  uint64_t v13 = *((void *)&v34 + 1) - *((void *)&v37 + 1) + 0xFFFFFFFFFFFFELL;
  long long v14 = v35;
  long long v15 = v38;
  uint64_t v16 = v35 - v38 + 0xFFFFFFFFFFFFELL;
  uint64_t v17 = *((void *)&v35 + 1) - *((void *)&v38 + 1) + 0xFFFFFFFFFFFFELL;
  uint64_t v18 = v36;
  uint64_t v19 = v39;
  uint64_t v20 = v36 - v39 + 0xFFFFFFFFFFFFELL;
  *(void *)a1 = v34 + 0xFFFFFFFFFFFDALL - v37;
  *(void *)(a1 + 8) = v13;
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + 24) = v17;
  *(void *)(a1 + 32) = v20;
  *(void *)(a1 + 40) = v12 + v11;
  *(void *)(a1 + 48) = *((void *)&v12 + 1) + *((void *)&v11 + 1);
  *(void *)(a1 + 56) = v15 + v14;
  *(void *)(a1 + 64) = *((void *)&v15 + 1) + *((void *)&v14 + 1);
  *(void *)(a1 + 72) = v19 + v18;
  sub_244D003A0((unint64_t *)&v34, (void *)(a1 + 120));
  long long v21 = v34;
  long long v22 = v31;
  uint64_t v23 = *((void *)&v31 + 1) + *((void *)&v34 + 1);
  long long v24 = v35;
  long long v25 = v32;
  uint64_t result = v32 + v35;
  uint64_t v27 = *((void *)&v32 + 1) + *((void *)&v35 + 1);
  uint64_t v28 = v36;
  uint64_t v29 = v33;
  uint64_t v30 = v33 + v36;
  *(void *)(a1 + 80) = v31 + v34;
  *(void *)(a1 + 88) = v23;
  *(void *)(a1 + 96) = result;
  *(void *)(a1 + 104) = v27;
  *(void *)(a1 + 112) = v30;
  *(void *)(a1 + 120) = v21 + 0xFFFFFFFFFFFDALL - v22;
  *(void *)(a1 + 128) = *((void *)&v21 + 1) - *((void *)&v22 + 1) + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 136) = v24 - v25 + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 144) = *((void *)&v24 + 1) - *((void *)&v25 + 1) + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 152) = v28 - v29 + 0xFFFFFFFFFFFFELL;
  return result;
}

uint64_t sub_244D007DC(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v42 = 0;
  int64x2_t v40 = 0u;
  int64x2_t v41 = 0u;
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  int64x2_t v6 = vaddq_s64(*(int64x2_t *)a2, *(int64x2_t *)(a2 + 40));
  int64x2_t v7 = vaddq_s64(*(int64x2_t *)(a2 + 16), *(int64x2_t *)(a2 + 56));
  *(void *)(a1 + 32) = *(void *)(a2 + 32) + *(void *)(a2 + 72);
  unint64_t v8 = (unint64_t *)(a1 + 40);
  *(int64x2_t *)a1 = v6;
  *(int64x2_t *)(a1 + 16) = v7;
  sub_244D0035C((int64x2_t *)(a1 + 40), (int64x2_t *)(a2 + 40), (int64x2_t *)a2);
  sub_244D03FA4((uint64_t)&v34, (unint64_t *)a1, a3 + 5);
  sub_244D03FA4((uint64_t)&v37, v8, a3);
  sub_244D03FA4((uint64_t)&v31, a3 + 15, (unint64_t *)(a2 + 120));
  sub_244D03FA4((uint64_t)&v40, (unint64_t *)(a2 + 80), a3 + 10);
  int64x2_t v9 = v41;
  *(int64x2_t *)(a1 + 120) = vaddq_s64(v40, v40);
  uint64_t v10 = 2 * v42;
  *(int64x2_t *)(a1 + 136) = vaddq_s64(v9, v9);
  *(void *)(a1 + 152) = v10;
  long long v11 = v34;
  long long v12 = v37;
  uint64_t v13 = *((void *)&v34 + 1) - *((void *)&v37 + 1) + 0xFFFFFFFFFFFFELL;
  long long v14 = v35;
  long long v15 = v38;
  uint64_t v16 = v35 - v38 + 0xFFFFFFFFFFFFELL;
  uint64_t v17 = *((void *)&v35 + 1) - *((void *)&v38 + 1) + 0xFFFFFFFFFFFFELL;
  uint64_t v18 = v36;
  uint64_t v19 = v39;
  uint64_t v20 = v36 - v39 + 0xFFFFFFFFFFFFELL;
  *(void *)a1 = v34 + 0xFFFFFFFFFFFDALL - v37;
  *(void *)(a1 + 8) = v13;
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + 24) = v17;
  *(void *)(a1 + 32) = v20;
  *(void *)(a1 + 40) = v12 + v11;
  *(void *)(a1 + 48) = *((void *)&v12 + 1) + *((void *)&v11 + 1);
  *(void *)(a1 + 56) = v15 + v14;
  *(void *)(a1 + 64) = *((void *)&v15 + 1) + *((void *)&v14 + 1);
  *(void *)(a1 + 72) = v19 + v18;
  sub_244D003A0((unint64_t *)&v34, (void *)(a1 + 120));
  long long v21 = v34;
  long long v22 = v31;
  uint64_t v23 = *((void *)&v34 + 1) - *((void *)&v31 + 1) + 0xFFFFFFFFFFFFELL;
  long long v24 = v35;
  long long v25 = v32;
  uint64_t result = v35 - v32 + 0xFFFFFFFFFFFFELL;
  uint64_t v27 = *((void *)&v35 + 1) - *((void *)&v32 + 1) + 0xFFFFFFFFFFFFELL;
  uint64_t v28 = v36;
  uint64_t v29 = v33;
  uint64_t v30 = v36 - v33 + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 80) = v34 + 0xFFFFFFFFFFFDALL - v31;
  *(void *)(a1 + 88) = v23;
  *(void *)(a1 + 96) = result;
  *(void *)(a1 + 104) = v27;
  *(void *)(a1 + 112) = v30;
  *(void *)(a1 + 120) = v22 + v21;
  *(void *)(a1 + 128) = *((void *)&v22 + 1) + *((void *)&v21 + 1);
  *(void *)(a1 + 136) = v25 + v24;
  *(void *)(a1 + 144) = *((void *)&v25 + 1) + *((void *)&v24 + 1);
  *(void *)(a1 + 152) = v29 + v28;
  return result;
}

void sub_244D009C0(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v5 = 0;
  uint64_t v57 = *MEMORY[0x263EF8340];
  do
  {
    *(void *)&long long v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    *(void *)&long long v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    sub_244D00C4C((unint64_t *)&v37, a3);
    sub_244D00C4C((unint64_t *)&v27, a3 + 8);
    int64x2_t v6 = &v56[v5];
    long long v7 = v27;
    long long v8 = v37;
    uint64_t v9 = *((void *)&v37 + 1) + *((void *)&v27 + 1);
    long long v10 = v28;
    long long v11 = v38;
    uint64_t v12 = v38 + v28;
    uint64_t v13 = *((void *)&v38 + 1) + *((void *)&v28 + 1);
    uint64_t v14 = v29;
    uint64_t v15 = v39;
    uint64_t v16 = v39 + v29;
    *int64x2_t v6 = v37 + v27;
    v6[1] = v9;
    _OWORD v6[2] = v12;
    v6[3] = v13;
    v6[4] = v16;
    v6[5] = v7 - v8 + 0xFFFFFFFFFFFDALL;
    v6[6] = *((void *)&v7 + 1) - *((void *)&v8 + 1) + 0xFFFFFFFFFFFFELL;
    v6[7] = v10 - v11 + 0xFFFFFFFFFFFFELL;
    v6[8] = *((void *)&v10 + 1) - *((void *)&v11 + 1) + 0xFFFFFFFFFFFFELL;
    v6[9] = v14 - v15 + 0xFFFFFFFFFFFFELL;
    sub_244D03FA4((uint64_t)&v56[v5 + 80], (unint64_t *)&v37, (unint64_t *)&v27);
    sub_244D03FA4((uint64_t)&v56[v5 + 80], (unint64_t *)&v56[v5 + 80], qword_244EB5740);
    v5 += 120;
    a3 += 16;
  }
  while (v5 != 1800);
  sub_244D00D0C(a1);
  unint64_t v17 = 63;
  do
  {
    uint64_t v18 = 0;
    int v19 = 0;
    uint64_t v20 = (unsigned __int8 *)(a2 + (v17 >> 3));
    do
    {
      unsigned int v21 = *v20;
      v20 += 8;
      v19 |= ((v21 >> (v17 & 7)) & 1) << v18++;
    }
    while (v18 != 4);
    long long v48 = 0u;
    long long v49 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    unint64_t v47 = 1;
    uint64_t v50 = 1;
    uint64_t v22 = (char)v19;
    long long v53 = 0u;
    long long v54 = 0u;
    uint64_t v23 = ~(uint64_t)(char)v19;
    long long v24 = v56;
    uint64_t v25 = 1;
    uint64_t v55 = 0;
    do
    {
      sub_244D00D40((uint64_t)&v47, (uint64_t)v24, (((v25++ ^ v22) - 1) & (unint64_t)v23) >> 63);
      v24 += 120;
    }
    while (v25 != 16);
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    sub_244D00484((uint64_t)&v37, a1);
    sub_244D005F8((uint64_t)&v27, a1, (unint64_t *)&v37);
    sub_244D00574(a1, (unint64_t *)&v27);
    sub_244D00DD0((uint64_t)&v27, a1, &v47);
    sub_244D00574(a1, (unint64_t *)&v27);
    --v17;
  }
  while (v17 < 0x40);
}

unint64_t *sub_244D00C4C(unint64_t *result, unsigned int *a2)
{
  unint64_t v2 = (unint64_t)a2[7] << 20;
  unint64_t v3 = *((unsigned __int8 *)a2 + 6);
  unint64_t v4 = ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40) & 0xFFF8FFFFFFFFFFFFLL | ((v3 & 7) << 48) | *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32);
  unint64_t v5 = *((unsigned __int8 *)a2 + 12);
  uint64_t v6 = *((unsigned __int8 *)a2 + 27);
  uint64_t v7 = *((unsigned __int8 *)a2 + 26);
  unint64_t v8 = *(unsigned int *)((char *)a2 + 22);
  unint64_t v9 = a2[4];
  unint64_t v10 = ((v5 & 0x3F) << 45) | ((unint64_t)*((unsigned __int8 *)a2 + 11) << 37) | ((unint64_t)*((unsigned __int8 *)a2 + 10) << 29) | ((unint64_t)*((unsigned __int8 *)a2 + 9) << 21) | ((unint64_t)*((unsigned __int8 *)a2 + 8) << 13) | (32 * *((unsigned __int8 *)a2 + 7)) | (v3 >> 3);
  unint64_t v11 = ((v9 & 0x1FFFFFF) << 26) | ((unint64_t)*((unsigned __int8 *)a2 + 15) << 18) | ((unint64_t)*((unsigned __int8 *)a2 + 14) << 10) | (4 * *((unsigned __int8 *)a2 + 13)) | (v5 >> 6);
  unint64_t v12 = ((v8 & 0xFFFFFFF) << 23) | ((unint64_t)*((unsigned __int8 *)a2 + 21) << 15) | ((unint64_t)*((unsigned __int8 *)a2 + 20) << 7) | (v9 >> 25);
  *uint64_t result = v4;
  result[1] = v10;
  result[2] = v11;
  result[3] = v12;
  result[4] = v2 | (v6 << 12) | (16 * v7) | (v8 >> 28);
  return result;
}

double sub_244D00D0C(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 1;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  return result;
}

uint64_t sub_244D00D40(uint64_t result, uint64_t a2, unsigned int a3)
{
  for (uint64_t i = 0; i != 40; i += 8)
    *(void *)(result + i) = *(void *)(a2 + i) & -(uint64_t)a3 | *(void *)(result + i) & (a3 - 1);
  for (uint64_t j = 0; j != 40; j += 8)
    *(void *)(result + 40 + j) = *(void *)(a2 + 40 + j) & -(uint64_t)a3 | *(void *)(result + 40 + j) & (a3 - 1);
  for (uint64_t k = 0; k != 40; k += 8)
    *(void *)(result + 80 + k) = *(void *)(a2 + 80 + k) & -(uint64_t)a3 | *(void *)(result + 80 + k) & (a3 - 1);
  return result;
}

uint64_t sub_244D00DD0(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v6 = *(void *)(a2 + 32) + *(void *)(a2 + 72);
  int64x2_t v7 = vaddq_s64(*(int64x2_t *)(a2 + 16), *(int64x2_t *)(a2 + 56));
  *(int64x2_t *)a1 = vaddq_s64(*(int64x2_t *)a2, *(int64x2_t *)(a2 + 40));
  *(int64x2_t *)(a1 + 16) = v7;
  *(void *)(a1 + 32) = v6;
  unint64_t v8 = (unint64_t *)(a1 + 40);
  sub_244D0035C((int64x2_t *)(a1 + 40), (int64x2_t *)(a2 + 40), (int64x2_t *)a2);
  sub_244D03FA4((uint64_t)&v34, (unint64_t *)a1, a3);
  sub_244D03FA4((uint64_t)&v37, v8, a3 + 5);
  sub_244D03FA4((uint64_t)&v31, a3 + 10, (unint64_t *)(a2 + 120));
  uint64_t v9 = 2 * *(void *)(a2 + 112);
  int64x2_t v10 = vaddq_s64(*(int64x2_t *)(a2 + 96), *(int64x2_t *)(a2 + 96));
  *(int64x2_t *)(a1 + 120) = vaddq_s64(*(int64x2_t *)(a2 + 80), *(int64x2_t *)(a2 + 80));
  *(int64x2_t *)(a1 + 136) = v10;
  *(void *)(a1 + 152) = v9;
  long long v11 = v34;
  long long v12 = v37;
  uint64_t v13 = *((void *)&v34 + 1) - *((void *)&v37 + 1) + 0xFFFFFFFFFFFFELL;
  long long v14 = v35;
  long long v15 = v38;
  uint64_t v16 = v35 - v38 + 0xFFFFFFFFFFFFELL;
  uint64_t v17 = *((void *)&v35 + 1) - *((void *)&v38 + 1) + 0xFFFFFFFFFFFFELL;
  uint64_t v18 = v36;
  uint64_t v19 = v39;
  uint64_t v20 = v36 - v39 + 0xFFFFFFFFFFFFELL;
  *(void *)a1 = v34 + 0xFFFFFFFFFFFDALL - v37;
  *(void *)(a1 + 8) = v13;
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + 24) = v17;
  *(void *)(a1 + 32) = v20;
  *(void *)(a1 + 40) = v12 + v11;
  *(void *)(a1 + 48) = *((void *)&v12 + 1) + *((void *)&v11 + 1);
  *(void *)(a1 + 56) = v15 + v14;
  *(void *)(a1 + 64) = *((void *)&v15 + 1) + *((void *)&v14 + 1);
  *(void *)(a1 + 72) = v19 + v18;
  sub_244D003A0((unint64_t *)&v34, (void *)(a1 + 120));
  long long v21 = v34;
  long long v22 = v31;
  uint64_t v23 = *((void *)&v31 + 1) + *((void *)&v34 + 1);
  long long v24 = v35;
  long long v25 = v32;
  uint64_t result = v32 + v35;
  uint64_t v27 = *((void *)&v32 + 1) + *((void *)&v35 + 1);
  uint64_t v28 = v36;
  uint64_t v29 = v33;
  uint64_t v30 = v33 + v36;
  *(void *)(a1 + 80) = v31 + v34;
  *(void *)(a1 + 88) = v23;
  *(void *)(a1 + 96) = result;
  *(void *)(a1 + 104) = v27;
  *(void *)(a1 + 112) = v30;
  *(void *)(a1 + 120) = v21 + 0xFFFFFFFFFFFDALL - v22;
  *(void *)(a1 + 128) = *((void *)&v21 + 1) - *((void *)&v22 + 1) + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 136) = v24 - v25 + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 144) = *((void *)&v24 + 1) - *((void *)&v25 + 1) + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 152) = v28 - v29 + 0xFFFFFFFFFFFFELL;
  return result;
}

void sub_244D00F9C(long long *a1, int8x16_t *a2)
{
  uint64_t v3 = 0;
  uint64_t v24 = *MEMORY[0x263EF8340];
  v4.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v4.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    int8x16_t v5 = *a2++;
    v25.val[0] = vandq_s8(v5, v4);
    v25.val[1] = (int8x16_t)vshrq_n_u8((uint8x16_t)v5, 4uLL);
    uint64_t v6 = &v22[v3];
    vst2q_s8(v6, v25);
    v3 += 32;
  }
  while (v3 != 64);
  uint64_t v7 = 0;
  int v8 = 0;
  do
  {
    int v9 = v22[v7] + v8;
    int v8 = (v9 + 8) << 24 >> 28;
    v22[v7++] = v9 - ((v9 + 8) & 0xF0);
  }
  while (v7 != 63);
  memset(v19, 0, sizeof(v19));
  memset(v15, 0, sizeof(v15));
  uint64_t v16 = 0;
  v23 += v8;
  sub_244D00D0C((uint64_t)a1);
  int v10 = 0;
  unint64_t v11 = 1;
  do
  {
    sub_244D011D0((uint64_t)v15, v10, (char)v22[v11]);
    sub_244D00DD0((uint64_t)v19, (uint64_t)a1, (unint64_t *)v15);
    sub_244D00574((uint64_t)a1, (unint64_t *)v19);
    ++v10;
    BOOL v12 = v11 >= 0x3E;
    v11 += 2;
  }
  while (!v12);
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  sub_244D0195C((uint64_t)v20, a1);
  sub_244D013B4((uint64_t)v19, (uint64_t)v20);
  sub_244D0050C((uint64_t)v17, (unint64_t *)v19);
  sub_244D013B4((uint64_t)v19, (uint64_t)v17);
  sub_244D0050C((uint64_t)v17, (unint64_t *)v19);
  sub_244D013B4((uint64_t)v19, (uint64_t)v17);
  sub_244D0050C((uint64_t)v17, (unint64_t *)v19);
  sub_244D013B4((uint64_t)v19, (uint64_t)v17);
  sub_244D00574((uint64_t)a1, (unint64_t *)v19);
  int v13 = 0;
  unint64_t v14 = 0;
  do
  {
    sub_244D011D0((uint64_t)v15, v13, (char)v22[v14]);
    sub_244D00DD0((uint64_t)v19, (uint64_t)a1, (unint64_t *)v15);
    sub_244D00574((uint64_t)a1, (unint64_t *)v19);
    ++v13;
    BOOL v12 = v14 >= 0x3E;
    v14 += 2;
  }
  while (!v12);
}

uint64_t sub_244D011D0(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = 0;
  uint64_t v41 = *MEMORY[0x263EF8340];
  memset(v40, 0, sizeof(v40));
  long long v39 = 0u;
  uint64_t v6 = (char *)&unk_244EAF6F0 + 768 * a2;
  char v38 = ((a3 - 1) & ~(uint64_t)a3) < 0;
  v40[15] = v38;
  do
  {
    uint64_t v7 = 0;
    int8x16_t v8 = vdupq_n_s8((uint64_t)((++v4 ^ (unint64_t)(a3 - 2 * ((a3 >> 31) & a3))) - 1) >> 63);
    do
    {
      *(int8x16_t *)(&v38 + v7) = veorq_s8(vandq_s8(*(int8x16_t *)&v6[v7], v8), *(int8x16_t *)(&v38 + v7));
      v7 += 16;
    }
    while (v7 != 96);
    v6 += 96;
  }
  while (v4 != 8);
  uint64_t v37 = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  uint64_t v31 = 0;
  int64x2_t v29 = 0u;
  int64x2_t v30 = 0u;
  sub_244D00C4C((unint64_t *)&v35, (unsigned int *)&v38);
  sub_244D00C4C((unint64_t *)&v32, (unsigned int *)&v40[15]);
  sub_244D00C4C((unint64_t *)&v29, (unsigned int *)&v40[47]);
  long long v9 = v36;
  long long v10 = v35;
  long long v11 = v36;
  *(_OWORD *)a1 = v35;
  *(_OWORD *)(a1 + 16) = v9;
  long long v12 = v33;
  *(_OWORD *)(a1 + 40) = v32;
  long long v13 = v32;
  *(_OWORD *)(a1 + 56) = v33;
  int64x2_t v14 = v30;
  int64x2_t v15 = v29;
  int64x2_t v16 = v30;
  *(int64x2_t *)(a1 + 80) = v29;
  *(int64x2_t *)(a1 + 96) = v14;
  v21[0] = v13;
  v21[1] = v12;
  long long v23 = v10;
  long long v24 = v11;
  uint64_t v17 = v37;
  *(void *)(a1 + 32) = v37;
  uint64_t v18 = v34;
  *(void *)(a1 + 72) = v34;
  uint64_t v19 = v31;
  *(void *)(a1 + 112) = v31;
  uint64_t v22 = v18;
  uint64_t v25 = v17;
  int64x2_t v26 = vsubq_s64((int64x2_t)xmmword_244EAF6E0, v15);
  int64x2_t v27 = vsubq_s64(vdupq_n_s64(0xFFFFFFFFFFFFEuLL), v16);
  uint64_t v28 = 0xFFFFFFFFFFFFELL - v19;
  return sub_244D00D40(a1, (uint64_t)v21, (a3 >> 7) & 1);
}

unint64_t *sub_244D013B4(uint64_t a1, uint64_t a2)
{
  uint64_t v46 = 0;
  long long v44 = 0u;
  long long v45 = 0u;
  uint64_t v43 = 0;
  int64x2_t v41 = 0u;
  int64x2_t v42 = 0u;
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v37 = 0;
  int64x2_t v35 = 0u;
  int64x2_t v36 = 0u;
  sub_244D001D8((uint64_t)&v44, (unint64_t *)a2);
  sub_244D001D8((uint64_t)&v41, (unint64_t *)(a2 + 40));
  sub_244D001D8((uint64_t)&v38, (unint64_t *)(a2 + 80));
  unint64_t v4 = (((unint64_t)v38 >> 50) & 0x1FFF) + 2 * *((void *)&v38 + 1);
  unint64_t v5 = (v4 >> 51) + 2 * v39;
  unint64_t v6 = (v5 >> 51) + 2 * *((void *)&v39 + 1);
  unint64_t v7 = (v6 >> 51) + 2 * v40;
  unint64_t v8 = 2 * (v38 & 0x3FFFFFFFFFFFFLL) + 19 * (v7 >> 51);
  unint64_t v9 = (v4 & 0x7FFFFFFFFFFFFLL) + (v8 >> 51);
  uint64_t v10 = v8 & 0x7FFFFFFFFFFFFLL;
  uint64_t v11 = v9 & 0x7FFFFFFFFFFFFLL;
  uint64_t v12 = (v5 & 0x7FFFFFFFFFFFFLL) + (v9 >> 51);
  uint64_t v13 = v6 & 0x7FFFFFFFFFFFFLL;
  uint64_t v14 = v7 & 0x7FFFFFFFFFFFFLL;
  uint64_t v15 = *(void *)(a2 + 72) + *(void *)(a2 + 32);
  int64x2_t v16 = *(int64x2_t *)(a2 + 16);
  int64x2_t v17 = *(int64x2_t *)(a2 + 56);
  *(int64x2_t *)(a1 + 40) = vaddq_s64(*(int64x2_t *)(a2 + 40), *(int64x2_t *)a2);
  *(int64x2_t *)(a1 + 56) = vaddq_s64(v17, v16);
  *(void *)(a1 + 72) = v15;
  sub_244D001D8((uint64_t)&v35, (unint64_t *)(a1 + 40));
  int64x2_t v18 = v41;
  long long v19 = v44;
  uint64_t v20 = *((void *)&v44 + 1) + v41.i64[1];
  int64x2_t v21 = v42;
  long long v22 = v45;
  uint64_t v23 = v45 + v42.i64[0];
  uint64_t v24 = *((void *)&v45 + 1) + v42.i64[1];
  uint64_t v25 = v43;
  uint64_t v26 = v46;
  uint64_t v27 = v46 + v43;
  *(void *)(a1 + 40) = v44 + v41.i64[0];
  *(void *)(a1 + 48) = v20;
  *(void *)(a1 + 56) = v23;
  *(void *)(a1 + 64) = v24;
  *(void *)(a1 + 72) = v27;
  *(void *)(a1 + 80) = v18.i64[0] + 0xFFFFFFFFFFFDALL - v19;
  *(void *)(a1 + 88) = v18.i64[1] - *((void *)&v19 + 1) + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 96) = v21.i64[0] - v22 + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 104) = v21.i64[1] - *((void *)&v22 + 1) + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 112) = v25 - v26 + 0xFFFFFFFFFFFFELL;
  sub_244D003A0((unint64_t *)&v41, (void *)(a1 + 40));
  uint64_t v28 = v37 - v43 + 0xFFFFFFFFFFFFELL;
  int64x2_t v29 = vaddq_s64(vsubq_s64(v36, v42), vdupq_n_s64(0xFFFFFFFFFFFFEuLL));
  *(int64x2_t *)a1 = vaddq_s64(vsubq_s64(v35, v41), (int64x2_t)xmmword_244EAF6E0);
  *(int64x2_t *)(a1 + 16) = v29;
  *(void *)(a1 + 32) = v28;
  uint64_t result = sub_244D003A0((unint64_t *)&v41, (void *)(a1 + 80));
  uint64_t v31 = v11 - v41.i64[1] + 0xFFFFFFFFFFFFELL;
  uint64_t v32 = v12 - v42.i64[0] + 0xFFFFFFFFFFFFELL;
  uint64_t v33 = v13 - v42.i64[1] + 0xFFFFFFFFFFFFELL;
  uint64_t v34 = v14 - v43 + 0xFFFFFFFFFFFFELL;
  *(void *)(a1 + 120) = v10 + 0xFFFFFFFFFFFDALL - v41.i64[0];
  *(void *)(a1 + 128) = v31;
  *(void *)(a1 + 136) = v32;
  *(void *)(a1 + 144) = v33;
  *(void *)(a1 + 152) = v34;
  return result;
}

void sub_244D015EC(uint64_t a1, uint64_t a2, long long *a3)
{
  v33[90] = *MEMORY[0x263EF8340];
  memset(v18, 0, sizeof(v18));
  sub_244D01924((uint64_t)v29);
  sub_244D00484((uint64_t)&v30, (uint64_t)a3);
  unint64_t v6 = v32;
  sub_244D0195C((uint64_t)v32, a3);
  unint64_t v7 = 0;
  unint64_t v8 = (unint64_t *)&v31;
  unint64_t v9 = v33;
  do
  {
    sub_244D013B4((uint64_t)v18, (uint64_t)v6);
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    sub_244D00574((uint64_t)&v19, (unint64_t *)v18);
    sub_244D00484((uint64_t)v8, (uint64_t)&v19);
    if (v7 + 2 <= 7) {
      sub_244D0050C((uint64_t)v9, (unint64_t *)v18);
    }
    sub_244D005F8((uint64_t)v18, (uint64_t)a3, v8);
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    sub_244D00574((uint64_t)&v19, (unint64_t *)v18);
    sub_244D00484((uint64_t)(v8 + 20), (uint64_t)&v19);
    if (v7 + 2 <= 6) {
      sub_244D0050C((uint64_t)(v9 + 15), (unint64_t *)v18);
    }
    v7 += 2;
    v8 += 40;
    v9 += 30;
    v6 += 120;
  }
  while (v7 < 0xE);
  sub_244D01998(a1);
  unsigned int v10 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  do
  {
    sub_244D013B4((uint64_t)v18, a1);
    sub_244D0050C(a1, (unint64_t *)v18);
    sub_244D013B4((uint64_t)v18, a1);
    sub_244D0050C(a1, (unint64_t *)v18);
    sub_244D013B4((uint64_t)v18, a1);
    sub_244D0050C(a1, (unint64_t *)v18);
    sub_244D013B4((uint64_t)v18, a1);
    sub_244D00574((uint64_t)&v19, (unint64_t *)v18);
    int v11 = (*(unsigned __int8 *)(a2 - (v10 >> 3) + 31) >> (~(_BYTE)v10 & 4)) & 0xF;
    memset(v17, 0, sizeof(v17));
    sub_244D01924((uint64_t)v17);
    uint64_t v12 = 0;
    uint64_t v13 = v29;
    do
    {
      uint64_t v14 = 0;
      uint64_t v15 = ((v11 ^ v12) - 1) >> 63;
      do
      {
        *(void *)((char *)v17 + v14) = *(void *)&v13[v14] & v15 | *(void *)((unsigned char *)v17 + v14) & ~v15;
        v14 += 8;
      }
      while (v14 != 40);
      do
      {
        *(void *)((char *)v17 + v14) = *(void *)&v13[v14] & v15 | *(void *)((unsigned char *)v17 + v14) & ~v15;
        v14 += 8;
      }
      while (v14 != 80);
      do
      {
        *(void *)((char *)v17 + v14) = *(void *)&v13[v14] & v15 | *(void *)((unsigned char *)v17 + v14) & ~v15;
        v14 += 8;
      }
      while (v14 != 120);
      do
      {
        *(void *)((char *)v17 + v14) = *(void *)&v13[v14] & v15 | *(void *)((unsigned char *)v17 + v14) & ~v15;
        v14 += 8;
      }
      while (v14 != 160);
      ++v12;
      v13 += 160;
    }
    while (v12 != 16);
    sub_244D005F8((uint64_t)v18, (uint64_t)&v19, (unint64_t *)v17);
    sub_244D0050C(a1, (unint64_t *)v18);
    BOOL v16 = v10 >= 0xFC;
    v10 += 4;
  }
  while (!v16);
}

double sub_244D01924(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 1;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  return result;
}

__n128 sub_244D0195C(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  long long v4 = *(long long *)((char *)a2 + 40);
  long long v5 = *(long long *)((char *)a2 + 56);
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  __n128 result = (__n128)a2[5];
  long long v7 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + 96) = v7;
  return result;
}

double sub_244D01998(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 1;
  return result;
}

unsigned __int16 *sub_244D019C0(unsigned __int16 *result)
{
  unint64_t v1 = *(unsigned int *)((char *)result + 15);
  unint64_t v2 = *((unsigned int *)result + 9);
  unint64_t v3 = (v2 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 40) << 8) | ((unint64_t)*((unsigned __int8 *)result + 41) << 16);
  unint64_t v4 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 11)) | (*((unsigned __int8 *)result + 48) << 8) | (*((unsigned __int8 *)result + 49) << 16)) >> 2) & 0x1FFFFF;
  unint64_t v5 = ((unint64_t)*(unsigned int *)((char *)result + 49) >> 7) & 0x1FFFFF;
  unint64_t v6 = ((unint64_t)*((unsigned int *)result + 13) >> 4) & 0x1FFFFF;
  unint64_t v7 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 13)) | (*((unsigned __int8 *)result + 56) << 8) | (*((unsigned __int8 *)result + 57) << 16)) >> 1) & 0x1FFFFF;
  uint64_t v8 = ((v1 >> 6) & 0x1FFFFF) + 666643 * v4;
  unint64_t v9 = (*(unsigned __int16 *)((char *)result + 21) | ((unint64_t)(*((unsigned char *)result + 23) & 0x1F) << 16))
     + 470296 * v5
     + 666643 * v6
     + 654183 * v4;
  unint64_t v10 = (((v1 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 19) << 8) | ((unint64_t)*((unsigned __int8 *)result + 20) << 16)) >> 3)
      + 666643 * v5
      + 470296 * v4
      + ((unint64_t)(v8 + 0x100000) >> 21);
  unint64_t v11 = (((unint64_t)*(unsigned int *)((char *)result + 23) >> 5) & 0x1FFFFF)
      + 654183 * v5
      + 470296 * v6
      - 997805 * (int)v4
      + 666643 * v7
      + ((v9 + 0x100000) >> 21);
  unint64_t v12 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 23)) | (*((unsigned __int8 *)result + 27) << 8) | (*((unsigned __int8 *)result + 28) << 16)) >> 2) & 0x1FFFFF)
      - 997805 * (int)v5
      + 654183 * v6
      + 136657 * v4;
  unint64_t v13 = (((unint64_t)*((unsigned int *)result + 7) >> 7) & 0x1FFFFF)
      + 136657 * v5
      - 997805 * (int)v6
      - 683901 * (int)v4;
  unint64_t v14 = (((unint64_t)*(unsigned int *)((char *)result + 31) >> 4) & 0x1FFFFF)
      - 683901 * (int)v5
      + 136657 * v6;
  unint64_t v15 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 31)) | (*((unsigned __int8 *)result + 35) << 8) | (*((unsigned __int8 *)result + 36) << 16)) >> 1) & 0x1FFFFF)
      - 683901 * (int)v6;
  unint64_t v16 = (unint64_t)*((unsigned int *)result + 15) >> 3;
  uint64_t v17 = ((v2 >> 6) & 0x1FFFFF) - 997805 * (int)v16;
  uint64_t v18 = (v3 >> 3) + 136657 * v16;
  unint64_t v19 = (result[21] | ((unint64_t)(result[22] & 0x1F) << 16)) - 683901 * (int)v16;
  unint64_t v20 = v14 + 470296 * v16;
  unint64_t v21 = v13 + 666643 * v16;
  unint64_t v22 = v15 + 654183 * v16;
  unint64_t v23 = ((unint64_t)*(unsigned int *)((char *)result + 57) >> 6) & 0x1FFFFF;
  uint64_t v24 = v18 - 683901 * (int)v23;
  uint64_t v25 = v17 + 136657 * v23 - 683901 * (int)v7;
  uint64_t v26 = v20 + 654183 * v23 - 997805 * (int)v7;
  uint64_t v27 = v12 + 666643 * v23 + 470296 * v7;
  unint64_t v28 = v21 + 470296 * v23;
  unint64_t v29 = v22 - 997805 * (int)v23;
  uint64_t v30 = v28 + 654183 * v7 + ((v27 + 0x100000) >> 21);
  uint64_t v31 = v29 + 136657 * v7 + ((v26 + 0x100000) >> 21);
  unint64_t v32 = v26 - ((v26 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v33 = v24 + ((v25 + 0x100000) >> 21);
  unint64_t v34 = (((unint64_t)*((unsigned int *)result + 11) >> 5) & 0x1FFFFF) + ((uint64_t)(v19 + 0x100000) >> 21);
  unint64_t v35 = v9 - ((v9 + 0x100000) & 0xFFFFFE00000) + ((v10 + 0x100000) >> 21);
  unint64_t v36 = v10 - ((v10 + 0x100000) & 0x7FFFFFFFFFE00000);
  unint64_t v37 = v32 + ((v30 + 0x100000) >> 21);
  unint64_t v38 = v30 - ((v30 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v39 = v25 - ((v25 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v31 + 0x100000) >> 21);
  unint64_t v40 = v31 - ((v31 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v41 = v19 - ((v19 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v33 + 0x100000) >> 21);
  unint64_t v42 = v33 - ((v33 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v43 = (((unint64_t)*(unsigned int *)((char *)result + 7) >> 7) & 0x1FFFFF) + 666643 * v42;
  unint64_t v44 = (((unint64_t)*(unsigned int *)(result + 5) >> 4) & 0x1FFFFF) + 666643 * v41 + 470296 * v42;
  unint64_t v45 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 5)) | (*((unsigned __int8 *)result + 14) << 8) | (*((unsigned __int8 *)result + 15) << 16)) >> 1) & 0x1FFFFF)
      + 666643 * v34
      + 470296 * v41
      + 654183 * v42;
  uint64_t v46 = v8 - ((v8 + 0x100000) & 0x7FFFFE00000) + 470296 * v34 + 654183 * v41 - 997805 * v42;
  uint64_t v47 = v36 + 654183 * v34 - 997805 * v41 + 136657 * v42;
  uint64_t v48 = v35 - 997805 * v34 + 136657 * v41 - 683901 * v42;
  unint64_t v49 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 1)) | (*((unsigned __int8 *)result + 6) << 8) | (*((unsigned __int8 *)result + 7) << 16)) >> 2) & 0x1FFFFF)
      + 666643 * v39;
  unint64_t v50 = v43 + 470296 * v39;
  unint64_t v51 = v44 + 654183 * v39;
  unint64_t v52 = v45 - 997805 * v39;
  unint64_t v53 = v46 + 136657 * v39;
  unint64_t v54 = v47 - 683901 * v39;
  unint64_t v55 = (((unint64_t)*(unsigned int *)(result + 1) >> 5) & 0x1FFFFF) + 666643 * v40;
  unint64_t v56 = v49 + 470296 * v40;
  unint64_t v57 = v50 + 654183 * v40;
  unint64_t v58 = v51 - 997805 * v40;
  unint64_t v59 = v52 + 136657 * v40;
  unint64_t v60 = v53 - 683901 * v40;
  unint64_t v61 = v27 - 683901 * v34 - ((v27 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v11 + 0x100000) >> 21);
  unint64_t v62 = (*result | ((unint64_t)(result[1] & 0x1F) << 16)) + 666643 * v37;
  unint64_t v63 = v56 + 654183 * v37;
  unint64_t v64 = v58 + 136657 * v37;
  uint64_t v65 = v55 + 470296 * v37 + ((uint64_t)(v62 + 0x100000) >> 21);
  unint64_t v66 = v54 + ((uint64_t)(v60 + 0x100000) >> 21);
  unint64_t v67 = v11 + 136657 * v34 - ((v11 + 0x100000) & 0xFFFFFFFFFFE00000) - 683901 * v41 + ((v48 + 0x100000) >> 21);
  unint64_t v68 = v48 - ((v48 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v69 = v38 + ((uint64_t)(v61 + 0x100000) >> 21);
  unint64_t v70 = v61 - ((v61 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v71 = v65 + 0x100000;
  unint64_t v72 = v70 + ((uint64_t)(v67 + 0x100000) >> 21);
  unint64_t v73 = v67 - ((v67 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v74 = (uint64_t)(v69 + 0x100000) >> 21;
  unint64_t v75 = v65 + 470296 * v74 - ((v65 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v76 = v57 - 997805 * v37 + ((uint64_t)(v63 + 0x100000) >> 21);
  unint64_t v77 = v63 + 654183 * v74 - ((v63 + 0x100000) & 0xFFFFFFFFFFE00000) + (v71 >> 21);
  unint64_t v78 = v76 - 997805 * v74 - ((v76 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v79 = v59 - 683901 * v37 + ((uint64_t)(v64 + 0x100000) >> 21);
  unint64_t v80 = v64 + 136657 * v74 - ((v64 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v76 + 0x100000) >> 21);
  int64_t v81 = v62 - ((v62 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v74;
  uint64_t v82 = v79 - 683901 * v74;
  v79 += 0x100000;
  unint64_t v83 = v60 - ((v60 + 0x100000) & 0xFFFFFFFFFFE00000) + (v79 >> 21);
  uint64_t v84 = v75 + (v81 >> 21);
  uint64_t v85 = v77 + (v84 >> 21);
  uint64_t v86 = v78 + (v85 >> 21);
  uint64_t v87 = v80 + (v86 >> 21);
  int64_t v88 = v82 - (v79 & 0xFFFFFFFFFFE00000) + (v87 >> 21);
  uint64_t v89 = v83 + (v88 >> 21);
  int64_t v90 = v66 - ((v66 + 0x100000) & 0xFFFFFFFFFFE00000) + (v89 >> 21);
  uint64_t v91 = v68 + ((uint64_t)(v66 + 0x100000) >> 21) + (v90 >> 21);
  uint64_t v92 = v73 + (v91 >> 21);
  uint64_t v93 = v72 + (v92 >> 21);
  int64_t v94 = v69 - ((v69 + 0x100000) & 0xFFFFFFFFFFE00000) + (v93 >> 21);
  uint64_t v95 = (v81 & 0x1FFFFF) + 666643 * (v94 >> 21);
  *((unsigned char *)result + 1) = (unsigned __int16)(v81 + 11283 * (v94 >> 21)) >> 8;
  uint64_t v96 = (v84 & 0x1FFFFF) + 470296 * (v94 >> 21) + (v95 >> 21);
  *(unsigned char *)double result = v81 + 19 * (v94 >> 21);
  *((unsigned char *)result + 2) = ((unint64_t)((v81 & 0x1FFFFF) + 666643 * (v94 >> 21)) >> 16) & 0x1F | (32 * (v84 + 24 * (v94 >> 21) + (v95 >> 21)));
  *((unsigned char *)result + 3) = (unint64_t)v96 >> 3;
  *((unsigned char *)result + 4) = (unint64_t)v96 >> 11;
  uint64_t v97 = (v85 & 0x1FFFFF) + 654183 * (v94 >> 21) + (v96 >> 21);
  *((unsigned char *)result + 5) = (v96 >> 19) & 3 | (4 * (v85 + 103 * (v94 >> 21) + (v96 >> 21)));
  *((unsigned char *)result + 6) = (unint64_t)v97 >> 6;
  uint64_t v98 = (v86 & 0x1FFFFF) - 997805 * (v94 >> 21) + (v97 >> 21);
  *((unsigned char *)result + 7) = (v97 >> 14) & 0x7F | (((_BYTE)v86
                                                              - -83 * (v94 >> 21)
                                                              + (v97 >> 21)) << 7);
  *((unsigned char *)result + 8) = (unint64_t)v98 >> 1;
  *((unsigned char *)result + 9) = (unint64_t)v98 >> 9;
  uint64_t v99 = (v87 & 0x1FFFFF) + 136657 * (v94 >> 21) + (v98 >> 21);
  *((unsigned char *)result + 10) = (v98 >> 17) & 0xF | (16 * (v87 - 47 * (v94 >> 21) + (v98 >> 21)));
  *((unsigned char *)result + 11) = (unint64_t)v99 >> 4;
  *((unsigned char *)result + 12) = (unint64_t)v99 >> 12;
  uint64_t v100 = (v88 & 0x1FFFFF) - 683901 * (v94 >> 21) + (v99 >> 21);
  *((unsigned char *)result + 13) = ((v99 & 0x100000) != 0) | (2 * (v88 - 125 * (v94 >> 21) + (v99 >> 21)));
  *((unsigned char *)result + 14) = (unint64_t)v100 >> 7;
  uint64_t v101 = (v89 & 0x1FFFFF) + (v100 >> 21);
  *((unsigned char *)result + 15) = (v100 >> 15) & 0x3F | (((_BYTE)v89 + (v100 >> 21)) << 6);
  *((unsigned char *)result + 16) = (unint64_t)v101 >> 2;
  *((unsigned char *)result + 17) = (unint64_t)v101 >> 10;
  uint64_t v102 = (v90 & 0x1FFFFF) + (v101 >> 21);
  *((unsigned char *)result + 18) = (v101 >> 18) & 7 | (8 * (v66 + (v89 >> 21) + (v101 >> 21)));
  *((unsigned char *)result + 19) = (unint64_t)v102 >> 5;
  *((unsigned char *)result + 20) = (unint64_t)v102 >> 13;
  *((unsigned char *)result + 22) = (unsigned __int16)(v91 + (v102 >> 21)) >> 8;
  uint64_t v103 = (v92 & 0x1FFFFF) + (((v91 & 0x1FFFFF) + (v102 >> 21)) >> 21);
  *((unsigned char *)result + 21) = v91 + (v102 >> 21);
  *((unsigned char *)result + 23) = ((unint64_t)((v91 & 0x1FFFFF) + (v102 >> 21)) >> 16) & 0x1F | (32 * v103);
  *((unsigned char *)result + 24) = (unint64_t)v103 >> 3;
  *((unsigned char *)result + 25) = (unint64_t)v103 >> 11;
  uint64_t v104 = (v93 & 0x1FFFFF) + (v103 >> 21);
  *((unsigned char *)result + 26) = (v103 >> 19) & 3 | (4 * v104);
  *((unsigned char *)result + 27) = (unint64_t)v104 >> 6;
  unint64_t v105 = (v94 & 0x1FFFFF) + (v104 >> 21);
  *((unsigned char *)result + 28) = (v104 >> 14) & 0x7F | ((_BYTE)v105 << 7);
  *((unsigned char *)result + 29) = v105 >> 1;
  *((unsigned char *)result + 30) = v105 >> 9;
  *((unsigned char *)result + 31) = v105 >> 17;
  return result;
}

double sub_244D01FD4(uint64_t a1, _OWORD *a2)
{
  __src[4] = *MEMORY[0x263EF8340];
  sub_244D20964((char *)__src, 0x20uLL);
  *(void *)&double result = sub_244D02048(a1, a2, __src).n128_u64[0];
  return result;
}

__n128 sub_244D02048(uint64_t a1, _OWORD *a2, unint64_t *__src)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  sub_244D26BC8(__src, 0x20uLL, &v10);
  v10.i8[0] &= 0xF8u;
  char v11 = v11 & 0x3F | 0x40;
  memset(v9, 0, sizeof(v9));
  sub_244D00F9C(v9, &v10);
  sub_244CFFA24((unsigned char *)a1, (uint64_t)v9);
  long long v6 = *((_OWORD *)__src + 1);
  *a2 = *(_OWORD *)__src;
  a2[1] = v6;
  __n128 result = *(__n128 *)a1;
  long long v8 = *(_OWORD *)(a1 + 16);
  a2[2] = *(_OWORD *)a1;
  a2[3] = v8;
  return result;
}

uint64_t sub_244D02118(unint64_t *a1, unint64_t *a2, size_t a3, unint64_t *__src)
{
  v187[4] = *MEMORY[0x263EF8340];
  sub_244D26BC8(__src, 0x20uLL, &v175);
  LOBYTE(v175) = v175 & 0xF8;
  HIBYTE(v186) = HIBYTE(v186) & 0x3F | 0x40;
  uint64_t v174 = 0;
  memset(v173, 0, sizeof(v173));
  sub_244D27798((uint64_t)v173);
  sub_244D277D8((unint64_t)v173, v187, 0x20uLL);
  sub_244D277D8((unint64_t)v173, a2, a3);
  sub_244D278D8(&v161, v173);
  sub_244D019C0(&v161);
  memset(v148, 0, sizeof(v148));
  sub_244D00F9C(v148, (int8x16_t *)&v161);
  sub_244CFFA24(a1, (uint64_t)v148);
  sub_244D27798((uint64_t)v173);
  sub_244D277D8((unint64_t)v173, a1, 0x20uLL);
  sub_244D277D8((unint64_t)v173, __src + 4, 0x20uLL);
  sub_244D277D8((unint64_t)v173, a2, a3);
  sub_244D278D8(&v149, v173);
  sub_244D019C0(&v149);
  unsigned int v8 = v149 | ((v150 & 0x1F) << 16);
  unsigned int v9 = v157 | ((v158 & 0x1F) << 16);
  unsigned int v10 = v175 | ((v176 & 0x1F) << 16);
  unsigned int v11 = v183 | ((v184 & 0x1F) << 16);
  unint64_t v12 = ((unint64_t)v150 >> 5) & 0x1FFFFF;
  unint64_t v13 = ((unint64_t)(HIBYTE(v150) | (v151 << 8) | (v152[0] << 16)) >> 2) & 0x1FFFFF;
  unint64_t v14 = ((unint64_t)v176 >> 5) & 0x1FFFFF;
  unint64_t v15 = ((unint64_t)(HIBYTE(v176) | (v177 << 8) | (v178[0] << 16)) >> 2) & 0x1FFFFF;
  unint64_t v147 = v14 * v12
       + v10 * (unint64_t)v13
       + v15 * v8
       + (((unint64_t)(HIBYTE(v162) | (v163 << 8) | (v164[0] << 16)) >> 2) & 0x1FFFFF);
  unint64_t v16 = ((unint64_t)*(unsigned int *)v152 >> 7) & 0x1FFFFF;
  unint64_t v17 = ((unint64_t)*(unsigned int *)&v152[3] >> 4) & 0x1FFFFF;
  unint64_t v18 = ((unint64_t)*(unsigned int *)v178 >> 7) & 0x1FFFFF;
  unint64_t v19 = ((unint64_t)*(unsigned int *)&v178[3] >> 4) & 0x1FFFFF;
  unint64_t v20 = v14 * (unint64_t)v16
      + v10 * v17
      + v18 * (unint64_t)v12
      + v8 * (unint64_t)v19
      + v15 * (unint64_t)v13
      + (((unint64_t)*(unsigned int *)&v164[3] >> 4) & 0x1FFFFF);
  unint64_t v21 = ((unint64_t)(v152[6] | (v153 << 8) | (v154 << 16)) >> 1) & 0x1FFFFF;
  unint64_t v22 = ((unint64_t)v154 >> 6) & 0x1FFFFF;
  unint64_t v23 = ((unint64_t)v180 >> 6) & 0x1FFFFF;
  unint64_t v24 = ((unint64_t)(v178[6] | (v179 << 8) | (v180 << 16)) >> 1) & 0x1FFFFF;
  unint64_t v145 = v21 * (unint64_t)v14
       + v10 * (unint64_t)v22
       + v18 * (unint64_t)v16
       + v13 * (unint64_t)v19
       + v15 * (unint64_t)v17
       + v8 * (unint64_t)v23
       + v24 * (unint64_t)v12
       + (((unint64_t)v166 >> 6) & 0x1FFFFF);
  unint64_t v25 = (((unint64_t)v154 >> 24) | ((unint64_t)v155 << 8) | ((unint64_t)v156 << 16)) >> 3;
  unint64_t v26 = (((unint64_t)v180 >> 24) | ((unint64_t)v181 << 8) | ((unint64_t)v182 << 16)) >> 3;
  unint64_t v144 = v25 * (unint64_t)v14
       + v10 * (unint64_t)v9
       + v21 * (unint64_t)v18
       + v19 * (unint64_t)v17
       + v15 * (unint64_t)v22
       + v13 * (unint64_t)v23
       + v24 * (unint64_t)v16
       + v26 * (unint64_t)v12
       + v11 * (unint64_t)v8
       + v169
       + ((unint64_t)(v170 & 0x1F) << 16);
  unint64_t v27 = ((unint64_t)v158 >> 5) & 0x1FFFFF;
  unint64_t v28 = ((unint64_t)(HIBYTE(v158) | (v159 << 8) | (v160 << 16)) >> 2) & 0x1FFFFF;
  unint64_t v29 = ((unint64_t)v184 >> 5) & 0x1FFFFF;
  unint64_t v30 = ((unint64_t)(HIBYTE(v184) | (v185 << 8) | (v186 << 16)) >> 2) & 0x1FFFFF;
  unint64_t v143 = v14 * v27
       + v10 * v28
       + v25 * (unint64_t)v18
       + v19 * (unint64_t)v22
       + v15 * (unint64_t)v9
       + v23 * (unint64_t)v17
       + v24 * (unint64_t)v21
       + v26 * (unint64_t)v16
       + v29 * v12
       + v11 * (unint64_t)v13
       + v30 * v8
       + (((unint64_t)(HIBYTE(v170) | (v171 << 8) | (v172 << 16)) >> 2) & 0x1FFFFF);
  unint64_t v31 = (v161 | ((unint64_t)(v162 & 0x1F) << 16)) + v10 * (unint64_t)v8;
  unint64_t v32 = v8 * (unint64_t)v14
      + v10 * (unint64_t)v12
      + (((unint64_t)v162 >> 5) & 0x1FFFFF)
      + ((v31 + 0x100000) >> 21);
  unint64_t v146 = v31 - ((v31 + 0x100000) & 0xFFFFFE00000);
  unint64_t v33 = v13 * (unint64_t)v14
      + v10 * (unint64_t)v16
      + v8 * (unint64_t)v18
      + v15 * (unint64_t)v12
      + (((unint64_t)*(unsigned int *)v164 >> 7) & 0x1FFFFF);
  unint64_t v141 = v14 * (unint64_t)v17
       + v10 * (unint64_t)v21
       + v13 * (unint64_t)v18
       + v19 * (unint64_t)v12
       + v15 * (unint64_t)v16
       + v24 * (unint64_t)v8
       + ((v20 + 0x100000) >> 21)
       + (((unint64_t)(v164[6] | (v165 << 8) | (v166 << 16)) >> 1) & 0x1FFFFF);
  unint64_t v34 = v20 - ((v20 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v139 = v14 * (unint64_t)v22
       + v10 * (unint64_t)v25
       + v18 * (unint64_t)v17
       + v19 * (unint64_t)v16
       + v15 * (unint64_t)v21
       + v23 * (unint64_t)v12
       + v24 * (unint64_t)v13
       + v26 * (unint64_t)v8
       + ((((unint64_t)v166 >> 24) | ((unint64_t)v167 << 8) | ((unint64_t)v168 << 16)) >> 3);
  unint64_t v138 = v9 * (unint64_t)v14
       + v10 * (unint64_t)v27
       + v18 * (unint64_t)v22
       + v21 * (unint64_t)v19
       + v15 * (unint64_t)v25
       + v23 * (unint64_t)v16
       + v24 * (unint64_t)v17
       + v26 * (unint64_t)v13
       + v8 * (unint64_t)v29
       + v11 * (unint64_t)v12
       + (((unint64_t)v170 >> 5) & 0x1FFFFF);
  unint64_t v35 = (unint64_t)v160 >> 7;
  unint64_t v36 = v28 * (unint64_t)v14 + v10 * (unint64_t)v35;
  unint64_t v37 = (unint64_t)v186 >> 7;
  unint64_t v38 = v36
      + v9 * (unint64_t)v18
      + v25 * (unint64_t)v19
      + v15 * (unint64_t)v27
      + v21 * (unint64_t)v23
      + v24 * (unint64_t)v22
      + v26 * (unint64_t)v17
      + v13 * (unint64_t)v29
      + v11 * (unint64_t)v16
      + v8 * (unint64_t)v37;
  unint64_t v39 = v14 * (unint64_t)v35
      + v18 * (unint64_t)v27
      + v9 * (unint64_t)v19
      + v15 * (unint64_t)v28
      + v23 * (unint64_t)v22
      + v24 * (unint64_t)v25
      + v26 * (unint64_t)v21
      + v29 * (unint64_t)v16
      + v11 * (unint64_t)v17
      + v37 * (unint64_t)v12;
  unint64_t v40 = v38 + v30 * (unint64_t)v12 + ((unint64_t)v172 >> 7);
  unint64_t v41 = v39 + v30 * (unint64_t)v13;
  unint64_t v42 = v18 * (unint64_t)v35
      + v28 * (unint64_t)v19
      + v9 * (unint64_t)v23
      + v24 * (unint64_t)v27
      + v26 * (unint64_t)v25
      + v21 * (unint64_t)v29
      + v11 * (unint64_t)v22
      + v37 * (unint64_t)v16;
  unint64_t v43 = v28 * (unint64_t)v18
      + v19 * (unint64_t)v27
      + v15 * (unint64_t)v35
      + v25 * (unint64_t)v23
      + v24 * (unint64_t)v9
      + v26 * (unint64_t)v22
      + v29 * (unint64_t)v17
      + v11 * (unint64_t)v21
      + v13 * (unint64_t)v37
      + v30 * (unint64_t)v16;
  unint64_t v44 = v26 * (unint64_t)v35
      + v29 * (unint64_t)v27
      + v11 * (unint64_t)v28
      + v25 * (unint64_t)v37
      + v30 * (unint64_t)v9;
  unint64_t v45 = v28 * (unint64_t)v29
      + v11 * (unint64_t)v35
      + v9 * (unint64_t)v37
      + v30 * (unint64_t)v27
      + ((v44 + 0x100000) >> 21);
  unint64_t v46 = v42 + v30 * (unint64_t)v17;
  unint64_t v47 = v19 * (unint64_t)v35
      + v23 * (unint64_t)v27
      + v24 * (unint64_t)v28
      + v26 * (unint64_t)v9
      + v29 * (unint64_t)v22
      + v11 * (unint64_t)v25
      + v37 * (unint64_t)v17;
  unint64_t v48 = v28 * (unint64_t)v23
      + v24 * (unint64_t)v35
      + v26 * (unint64_t)v27
      + v25 * (unint64_t)v29
      + v11 * (unint64_t)v9
      + v21 * (unint64_t)v37;
  unint64_t v49 = v23 * (unint64_t)v35
      + v26 * (unint64_t)v28
      + v9 * (unint64_t)v29;
  unint64_t v50 = v33 + ((v147 + 0x100000) >> 21);
  unint64_t v51 = v43 + ((v41 + 0x100000) >> 21);
  unint64_t v52 = v48 + v30 * (unint64_t)v22;
  unint64_t v53 = v47 + v30 * (unint64_t)v21 + ((v46 + 0x100000) >> 21);
  unint64_t v54 = v49
      + v11 * (unint64_t)v27
      + v37 * (unint64_t)v22
      + v30 * (unint64_t)v25
      + ((v52 + 0x100000) >> 21);
  unint64_t v55 = v29 * (unint64_t)v35
      + v37 * (unint64_t)v27
      + v30 * (unint64_t)v28;
  unint64_t v56 = v28 * (unint64_t)v37
      + v30 * (unint64_t)v35
      + ((v55 + 0x100000) >> 21);
  unint64_t v57 = v37 * (unint64_t)v35;
  unint64_t v58 = (v57 + 0x100000) >> 21;
  unint64_t v59 = v32 + 0x100000;
  unint64_t v140 = v32 - ((v32 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v142 = v34 + ((v50 + 0x100000) >> 21);
  unint64_t v60 = v44 - ((v44 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v54 + 0x100000) >> 21);
  unint64_t v61 = v54 - ((v54 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v62 = v55 - ((v55 + 0x100000) & 0x1FFFFFFE00000) + ((v45 + 0x100000) >> 21);
  unint64_t v63 = v45 - ((v45 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v64 = v57 - ((v57 + 0x100000) & 0x7FFFFFFE00000) + ((v56 + 0x100000) >> 21);
  unint64_t v65 = v56 - ((v56 + 0x100000) & 0x1FFFFFFE00000);
  unint64_t v66 = v52 - 683901 * (int)v58 - ((v52 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v67 = v46 - 997805 * (int)v58 - ((v46 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v68 = v41 + 470296 * v58 - ((v41 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v69 = v139 + ((v145 + 0x100000) >> 21);
  unint64_t v70 = v138 + ((v144 + 0x100000) >> 21);
  unint64_t v71 = 666643 * v62
      + 470296 * v63
      + 654183 * v60
      + v144
      + ((v69 + 0x100000) >> 21)
      - ((v144 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v72 = v40 + ((v143 + 0x100000) >> 21);
  unint64_t v73 = 666643 * v64
      + 470296 * v65
      + 654183 * v62
      - 997805 * v63
      + 136657 * v60
      + ((v70 + 0x100000) >> 21)
      + v143
      - ((v143 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v74 = 666643 * v63 + 470296 * v60 + v69 - ((v69 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v75 = 666643 * v65 + 470296 * v62 + 654183 * v63 - 997805 * v60 + v70 - ((v70 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v76 = v68 + 654183 * v64 - 997805 * v65 + 136657 * v62 - 683901 * v63 + ((v72 + 0x100000) >> 21);
  unint64_t v77 = 470296 * v64
      + 666643 * v58
      + 654183 * v65
      - 997805 * v62
      + 136657 * v63
      - 683901 * v60
      + v72
      - ((v72 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v78 = v67 + ((v51 + 0x100000) >> 21);
  unint64_t v79 = v51
      + 654183 * v58
      - ((v51 + 0x100000) & 0xFFFFFFFFFFE00000)
      - 997805 * v64
      + 136657 * v65
      - 683901 * v62
      + ((uint64_t)(v76 + 0x100000) >> 21);
  unint64_t v80 = v53 + 136657 * v58;
  v53 += 0x100000;
  unint64_t v81 = v66 + (v53 >> 21);
  unint64_t v82 = v145 + 666643 * v60 - ((v145 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v141 + 0x100000) >> 21);
  unint64_t v83 = v75 + ((uint64_t)(v71 + 0x100000) >> 21);
  uint64_t v84 = v78 + 136657 * v64 - 683901 * v65;
  unint64_t v85 = v77 + ((uint64_t)(v73 + 0x100000) >> 21);
  unint64_t v86 = v80 - (v53 & 0xFFFFFFFFFFE00000) - 683901 * v64 + ((v84 + 0x100000) >> 21);
  unint64_t v87 = v61 + ((uint64_t)(v81 + 0x100000) >> 21);
  unint64_t v88 = v81 - ((v81 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v89 = v76 - ((v76 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v85 + 0x100000) >> 21);
  unint64_t v90 = v85 - ((v85 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v91 = v84 - ((v84 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v79 + 0x100000) >> 21);
  unint64_t v92 = v79 - ((v79 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v93 = v88 + ((uint64_t)(v86 + 0x100000) >> 21);
  unint64_t v94 = v86 - ((v86 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v95 = v73 - 683901 * v87 + ((uint64_t)(v83 + 0x100000) >> 21) - ((v73 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v96 = v74 + ((uint64_t)(v82 + 0x100000) >> 21);
  unint64_t v97 = -997805 * v87
      + 136657 * v93
      - 683901 * v94
      + v71
      + ((uint64_t)(v96 + 0x100000) >> 21)
      - ((v71 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v98 = v146 + 666643 * v89;
  uint64_t v99 = v140 + 470296 * v89 + 666643 * v92 + ((uint64_t)(v98 + 0x100000) >> 21);
  unint64_t v100 = v82
       + 470296 * v87
       - ((v82 + 0x100000) & 0xFFFFFFFFFFE00000)
       + 654183 * v93
       - 997805 * v94
       + 136657 * v91
       - 683901 * v92;
  unint64_t v101 = v96
       + 654183 * v87
       - 997805 * v93
       + 136657 * v94
       - ((v96 + 0x100000) & 0xFFFFFFFFFFE00000)
       - 683901 * v91
       + ((uint64_t)(v100 + 0x100000) >> 21);
  unint64_t v102 = 136657 * v87
       - 683901 * v93
       + v83
       - ((v83 + 0x100000) & 0xFFFFFFFFFFE00000)
       + ((uint64_t)(v97 + 0x100000) >> 21);
  unint64_t v103 = v90 + ((uint64_t)(v95 + 0x100000) >> 21);
  uint64_t v104 = (uint64_t)(v103 + 0x100000) >> 21;
  unint64_t v105 = v147 + (v59 >> 21) - ((v147 + 0x100000) & 0xFFFFFFFFFFE00000) + 654183 * v89 + 666643 * v91 + 470296 * v92;
  unint64_t v106 = v50
       - ((v50 + 0x100000) & 0xFFFFFFFFFFE00000)
       + 666643 * v94
       - 997805 * v89
       + 470296 * v91
       + 654183 * v92
       + ((uint64_t)(v105 + 0x100000) >> 21);
  unint64_t v107 = v141 + 666643 * v87 - ((v141 + 0x100000) & 0xFFFFFFFFFFE00000) + 470296 * v93 + 654183 * v94 - 683901 * v89;
  uint64_t v108 = v142 + 666643 * v93 + 470296 * v94 + 136657 * v89 + 654183 * v91 - 997805 * v92;
  uint64_t v109 = v107 - 997805 * v91 + 136657 * v92 + ((v108 + 0x100000) >> 21);
  unint64_t v110 = v95 + ((uint64_t)(v102 + 0x100000) >> 21);
  int64_t v111 = v98 - ((v98 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v104;
  unint64_t v112 = (v95 + 0x100000) & 0xFFFFFFFFFFE00000;
  int64_t v113 = v99 + 470296 * v104 - ((v99 + 0x100000) & 0xFFFFFFFFFFE00000) + (v111 >> 21);
  uint64_t v114 = v111 & 0x1FFFFF;
  int64_t v115 = v105 + 654183 * v104 - ((v105 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v99 + 0x100000) >> 21) + (v113 >> 21);
  int64_t v116 = v106 - 997805 * v104 - ((v106 + 0x100000) & 0xFFFFFFFFFFE00000) + (v115 >> 21);
  int64_t v117 = v108
       + 136657 * v104
       - ((v108 + 0x100000) & 0xFFFFFFFFFFE00000)
       + ((uint64_t)(v106 + 0x100000) >> 21)
       + (v116 >> 21);
  int64_t v118 = v109 - 683901 * v104 - ((v109 + 0x100000) & 0xFFFFFFFFFFE00000) + (v117 >> 21);
  int64_t v119 = v100 - ((v100 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v109 + 0x100000) >> 21) + (v118 >> 21);
  int64_t v120 = v101 - ((v101 + 0x100000) & 0xFFFFFFFFFFE00000) + (v119 >> 21);
  int64_t v121 = v97 - ((v97 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v101 + 0x100000) >> 21) + (v120 >> 21);
  int64_t v122 = v102 - ((v102 + 0x100000) & 0xFFFFFFFFFFE00000) + (v121 >> 21);
  uint64_t v123 = v110 - v112 + (v122 >> 21);
  int64_t v124 = v103 - ((v103 + 0x100000) & 0xFFFFFFFFFFE00000) + (v123 >> 21);
  uint64_t v125 = v114 + 666643 * (v124 >> 21);
  *((unsigned char *)a1 + 33) = BYTE1(v125);
  uint64_t v126 = (v113 & 0x1FFFFF) + 470296 * (v124 >> 21) + (v125 >> 21);
  *((unsigned char *)a1 + 32) = v125;
  *((unsigned char *)a1 + 34) = ((v114 + 666643 * (v124 >> 21)) >> 16) & 0x1F | (32 * (v113 + 24 * (v124 >> 21) + (v125 >> 21)));
  *((unsigned char *)a1 + 35) = (unint64_t)v126 >> 3;
  *((unsigned char *)a1 + 36) = (unint64_t)v126 >> 11;
  uint64_t v127 = (v115 & 0x1FFFFF) + 654183 * (v124 >> 21) + (v126 >> 21);
  *((unsigned char *)a1 + 37) = (v126 >> 19) & 3 | (4 * (v115 + 103 * (v124 >> 21) + (v126 >> 21)));
  *((unsigned char *)a1 + 38) = (unint64_t)v127 >> 6;
  uint64_t v128 = (v116 & 0x1FFFFF) - 997805 * (v124 >> 21) + (v127 >> 21);
  *((unsigned char *)a1 + 39) = (v127 >> 14) & 0x7F | (((_BYTE)v106
                                                            - -83 * (_BYTE)v104
                                                            + (v115 >> 21)
                                                            - -83 * (v124 >> 21)
                                                            + (v127 >> 21)) << 7);
  *((unsigned char *)a1 + 40) = (unint64_t)v128 >> 1;
  *((unsigned char *)a1 + 41) = (unint64_t)v128 >> 9;
  uint64_t v129 = (v117 & 0x1FFFFF) + 136657 * (v124 >> 21) + (v128 >> 21);
  *((unsigned char *)a1 + 42) = (v128 >> 17) & 0xF | (16 * (v117 - 47 * (v124 >> 21) + (v128 >> 21)));
  *((unsigned char *)a1 + 43) = (unint64_t)v129 >> 4;
  *((unsigned char *)a1 + 44) = (unint64_t)v129 >> 12;
  uint64_t v130 = (v118 & 0x1FFFFF) - 683901 * (v124 >> 21) + (v129 >> 21);
  *((unsigned char *)a1 + 45) = ((v129 & 0x100000) != 0) | (2 * (v118 - 125 * (v124 >> 21) + (v129 >> 21)));
  *((unsigned char *)a1 + 46) = (unint64_t)v130 >> 7;
  uint64_t v131 = (v119 & 0x1FFFFF) + (v130 >> 21);
  *((unsigned char *)a1 + 47) = (v130 >> 15) & 0x3F | (((_BYTE)v119 + (v130 >> 21)) << 6);
  *((unsigned char *)a1 + 48) = (unint64_t)v131 >> 2;
  *((unsigned char *)a1 + 49) = (unint64_t)v131 >> 10;
  uint64_t v132 = (v120 & 0x1FFFFF) + (v131 >> 21);
  *((unsigned char *)a1 + 50) = (v131 >> 18) & 7 | (8 * (v120 + (v131 >> 21)));
  *((unsigned char *)a1 + 51) = (unint64_t)v132 >> 5;
  uint64_t v133 = (v121 & 0x1FFFFF) + (v132 >> 21);
  *((unsigned char *)a1 + 52) = (unint64_t)v132 >> 13;
  *((unsigned char *)a1 + 54) = BYTE1(v133);
  uint64_t v134 = (v122 & 0x1FFFFF) + (v133 >> 21);
  *((unsigned char *)a1 + 53) = v133;
  *((unsigned char *)a1 + 55) = BYTE2(v133) & 0x1F | (32 * (v122 + (v133 >> 21)));
  *((unsigned char *)a1 + 56) = (unint64_t)v134 >> 3;
  *((unsigned char *)a1 + 57) = (unint64_t)v134 >> 11;
  uint64_t v135 = (v123 & 0x1FFFFF) + (v134 >> 21);
  *((unsigned char *)a1 + 58) = (v134 >> 19) & 3 | (4 * v135);
  *((unsigned char *)a1 + 59) = (unint64_t)v135 >> 6;
  unint64_t v136 = (v124 & 0x1FFFFF) + (v135 >> 21);
  *((unsigned char *)a1 + 60) = (v135 >> 14) & 0x7F | ((_BYTE)v136 << 7);
  *((unsigned char *)a1 + 61) = v136 >> 1;
  *((unsigned char *)a1 + 62) = v136 >> 9;
  *((unsigned char *)a1 + 63) = v136 >> 17;
  return 1;
}

uint64_t sub_244D02DC0(unint64_t *a1, size_t a2, uint64_t a3, int64x2_t *a4)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  if (*(unsigned __int8 *)(a3 + 63) > 0x1Fu) {
    return 0;
  }
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t result = sub_244CFFCB4((uint64_t)&v42, a4);
  if (!result) {
    return result;
  }
  unint64_t v9 = ((unint64_t)(0xFFFFFFFFFFFDALL - v42) >> 51) - *((void *)&v42 + 1) + 0xFFFFFFFFFFFFELL;
  unint64_t v10 = (v9 >> 51) - v43 + 0xFFFFFFFFFFFFELL;
  unint64_t v11 = (v10 >> 51) - *((void *)&v43 + 1) + 0xFFFFFFFFFFFFELL;
  unint64_t v12 = (v11 >> 51) - v44 + 0xFFFFFFFFFFFFELL;
  unint64_t v13 = ((0xFFFFFFFFFFFDALL - v42) & 0x7FFFFFFFFFFFFLL) + 19 * (v12 >> 51);
  unint64_t v14 = (v9 & 0x7FFFFFFFFFFFFLL) + (v13 >> 51);
  *(void *)&long long v42 = v13 & 0x7FFFFFFFFFFFFLL;
  *((void *)&v42 + 1) = v14 & 0x7FFFFFFFFFFFFLL;
  *(void *)&long long v43 = (v10 & 0x7FFFFFFFFFFFFLL) + (v14 >> 51);
  *((void *)&v43 + 1) = v11 & 0x7FFFFFFFFFFFFLL;
  unint64_t v15 = ((unint64_t)(0xFFFFFFFFFFFDALL - *((void *)&v49 + 1)) >> 51) - v50 + 0xFFFFFFFFFFFFELL;
  unint64_t v16 = (v15 >> 51) - *((void *)&v50 + 1) + 0xFFFFFFFFFFFFELL;
  unint64_t v17 = (v16 >> 51) - v51 + 0xFFFFFFFFFFFFELL;
  unint64_t v18 = (v17 >> 51) - *((void *)&v51 + 1) + 0xFFFFFFFFFFFFELL;
  unint64_t v19 = ((0xFFFFFFFFFFFDALL - *((void *)&v49 + 1)) & 0x7FFFFFFFFFFFFLL) + 19 * (v18 >> 51);
  unint64_t v20 = (v15 & 0x7FFFFFFFFFFFFLL) + (v19 >> 51);
  *(void *)&long long v44 = v12 & 0x7FFFFFFFFFFFFLL;
  *((void *)&v49 + 1) = v19 & 0x7FFFFFFFFFFFFLL;
  *(void *)&long long v50 = v20 & 0x7FFFFFFFFFFFFLL;
  *((void *)&v50 + 1) = (v16 & 0x7FFFFFFFFFFFFLL) + (v20 >> 51);
  *(void *)&long long v51 = v17 & 0x7FFFFFFFFFFFFLL;
  *((void *)&v51 + 1) = v18 & 0x7FFFFFFFFFFFFLL;
  long long v21 = *(_OWORD *)(a3 + 16);
  v90[0] = *(_OWORD *)a3;
  v90[1] = v21;
  long long v22 = *(_OWORD *)(a3 + 32);
  long long v89 = *(_OWORD *)(a3 + 48);
  long long v88 = v22;
  unint64_t v23 = *((void *)&v89 + 1);
  if (*((void *)&v89 + 1) > 0x1000000000000000uLL) {
    return 0;
  }
  unint64_t v24 = 0x1000000000000000;
  uint64_t v25 = 0x10u;
  while (v23 >= v24)
  {
    if (v25 != -8)
    {
      unint64_t v23 = *(void *)((char *)&v88 + v25);
      unint64_t v24 = *(void *)((char *)&unk_244EB5768 + v25);
      v25 -= 8;
      if (v23 <= v24) {
        continue;
      }
    }
    return 0;
  }
  uint64_t v87 = 0;
  memset(v86, 0, sizeof(v86));
  sub_244D27798((uint64_t)v86);
  sub_244D277D8((unint64_t)v86, (unint64_t *)a3, 0x20uLL);
  sub_244D277D8((unint64_t)v86, (unint64_t *)a4, 0x20uLL);
  sub_244D277D8((unint64_t)v86, a1, a2);
  sub_244D278D8(v85, v86);
  sub_244D019C0(v85);
  uint64_t v41 = 0;
  memset(v40, 0, sizeof(v40));
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  memset(v60, 0, sizeof(v60));
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  memset(v52, 0, sizeof(v52));
  sub_244D041C0((uint64_t)v100, (uint64_t)v85);
  sub_244D041C0((uint64_t)v99, (uint64_t)&v88);
  sub_244D00484((uint64_t)v91, (uint64_t)&v42);
  uint64_t v78 = 0;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v71 = 0u;
  sub_244D0195C((uint64_t)&v71, &v42);
  sub_244D013B4((uint64_t)&v61, (uint64_t)&v71);
  sub_244D00574((uint64_t)v52, (unint64_t *)&v61);
  sub_244D005F8((uint64_t)&v61, (uint64_t)v52, v91);
  sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
  sub_244D00484((uint64_t)v92, (uint64_t)&v53);
  sub_244D005F8((uint64_t)&v61, (uint64_t)v52, v92);
  sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
  sub_244D00484((uint64_t)v93, (uint64_t)&v53);
  sub_244D005F8((uint64_t)&v61, (uint64_t)v52, v93);
  sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
  sub_244D00484((uint64_t)v94, (uint64_t)&v53);
  sub_244D005F8((uint64_t)&v61, (uint64_t)v52, v94);
  sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
  sub_244D00484((uint64_t)v95, (uint64_t)&v53);
  sub_244D005F8((uint64_t)&v61, (uint64_t)v52, v95);
  sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
  sub_244D00484((uint64_t)v96, (uint64_t)&v53);
  sub_244D005F8((uint64_t)&v61, (uint64_t)v52, v96);
  sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
  sub_244D00484((uint64_t)v97, (uint64_t)&v53);
  sub_244D005F8((uint64_t)&v61, (uint64_t)v52, v97);
  sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
  sub_244D00484((uint64_t)&v98, (uint64_t)&v53);
  sub_244D01998((uint64_t)v40);
  unsigned int v26 = 255;
  while (1)
  {
    uint64_t v27 = v26;
    if (v100[v26] || v99[v26]) {
      break;
    }
    --v26;
    if (!v27) {
      goto LABEL_26;
    }
  }
  if ((v26 & 0x80000000) == 0)
  {
    do
    {
      sub_244D013B4((uint64_t)&v61, (uint64_t)v40);
      unint64_t v28 = v100[v27];
      if ((char)v100[v27] < 1)
      {
        if ((v28 & 0x80) != 0)
        {
          sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
          sub_244D007DC((uint64_t)&v61, (uint64_t)&v53, &v91[20 * (-(char)v28 >> 1)]);
        }
      }
      else
      {
        sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
        sub_244D005F8((uint64_t)&v61, (uint64_t)&v53, &v91[20 * (v28 >> 1)]);
      }
      int v29 = (char)v99[v27];
      if (v29 < 1)
      {
        if (v29 < 0)
        {
          sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
          *(void *)&long long v73 = 0;
          unint64_t v30 = &qword_244EB57C8[15 * (-(char)v29 >> 1)];
          long long v71 = 0u;
          long long v72 = 0u;
          uint64_t v84 = 0;
          long long v82 = 0u;
          long long v83 = 0u;
          uint64_t v81 = 0;
          long long v79 = 0u;
          long long v80 = 0u;
          *(void *)&long long v61 = v53 + *((void *)&v55 + 1);
          *((void *)&v61 + 1) = *((void *)&v53 + 1) + v56;
          *(void *)&long long v62 = v54 + *((void *)&v56 + 1);
          *((void *)&v62 + 1) = *((void *)&v54 + 1) + v57;
          *(void *)&long long v63 = v55 + *((void *)&v57 + 1);
          *((void *)&v63 + 1) = *((void *)&v55 + 1) + 0xFFFFFFFFFFFDALL - v53;
          *(void *)&long long v64 = v56 - *((void *)&v53 + 1) + 0xFFFFFFFFFFFFELL;
          *((void *)&v64 + 1) = *((void *)&v56 + 1) - v54 + 0xFFFFFFFFFFFFELL;
          *(void *)&long long v65 = v57 - *((void *)&v54 + 1) + 0xFFFFFFFFFFFFELL;
          *((void *)&v65 + 1) = *((void *)&v57 + 1) - v55 + 0xFFFFFFFFFFFFELL;
          sub_244D03FA4((uint64_t)&v82, (unint64_t *)&v61, v30 + 5);
          sub_244D03FA4((uint64_t)&v71, (unint64_t *)&v63 + 1, v30);
          sub_244D03FA4((uint64_t)&v79, v30 + 10, (unint64_t *)v60 + 1);
          *(void *)&long long v61 = v82 + 0xFFFFFFFFFFFDALL - v71;
          *((void *)&v61 + 1) = *((void *)&v82 + 1) - *((void *)&v71 + 1) + 0xFFFFFFFFFFFFELL;
          *(void *)&long long v62 = v83 - v72 + 0xFFFFFFFFFFFFELL;
          *((void *)&v62 + 1) = *((void *)&v83 + 1) - *((void *)&v72 + 1) + 0xFFFFFFFFFFFFELL;
          *(void *)&long long v63 = v84 - v73 + 0xFFFFFFFFFFFFELL;
          *((void *)&v63 + 1) = v71 + v82;
          *(void *)&long long v64 = *((void *)&v71 + 1) + *((void *)&v82 + 1);
          *((void *)&v64 + 1) = v72 + v83;
          *(void *)&long long v65 = *((void *)&v72 + 1) + *((void *)&v83 + 1);
          *((void *)&v65 + 1) = v73 + v84;
          unint64_t v31 = 2 * *((void *)&v58 + 1) + ((unint64_t)(2 * v58) >> 51);
          unint64_t v32 = (v31 >> 51) + 2 * v59;
          unint64_t v33 = (v32 >> 51) + 2 * *((void *)&v59 + 1);
          unint64_t v34 = (v33 >> 51) + 2 * *(void *)&v60[0];
          unint64_t v35 = ((2 * v58) & 0x7FFFFFFFFFFFELL) + 19 * (v34 >> 51);
          unint64_t v36 = (v31 & 0x7FFFFFFFFFFFFLL) + (v35 >> 51);
          v35 &= 0x7FFFFFFFFFFFFuLL;
          uint64_t v37 = v36 & 0x7FFFFFFFFFFFFLL;
          uint64_t v38 = (v32 & 0x7FFFFFFFFFFFFLL) + (v36 >> 51);
          *(void *)&long long v66 = v35 + 0xFFFFFFFFFFFDALL - v79;
          *((void *)&v66 + 1) = v37 - *((void *)&v79 + 1) + 0xFFFFFFFFFFFFELL;
          *(void *)&long long v67 = v38 - v80 + 0xFFFFFFFFFFFFELL;
          *((void *)&v67 + 1) = (v33 & 0x7FFFFFFFFFFFFLL) - *((void *)&v80 + 1) + 0xFFFFFFFFFFFFELL;
          *(void *)&long long v68 = (v34 & 0x7FFFFFFFFFFFFLL) - v81 + 0xFFFFFFFFFFFFELL;
          *((void *)&v68 + 1) = v79 + v35;
          *(void *)&long long v69 = *((void *)&v79 + 1) + v37;
          *((void *)&v69 + 1) = v80 + v38;
          *(void *)&long long v70 = *((void *)&v80 + 1) + (v33 & 0x7FFFFFFFFFFFFLL);
          *((void *)&v70 + 1) = v81 + (v34 & 0x7FFFFFFFFFFFFLL);
        }
      }
      else
      {
        sub_244D00574((uint64_t)&v53, (unint64_t *)&v61);
        sub_244D00DD0((uint64_t)&v61, (uint64_t)&v53, &qword_244EB57C8[15 * (v29 >> 1)]);
      }
      sub_244D0050C((uint64_t)v40, (unint64_t *)&v61);
    }
    while (v27-- > 0);
  }
LABEL_26:
  sub_244CFFA24(v91, (uint64_t)v40);
  return sub_244D441D4((char *)v91, (char *)v90, 32) == 0;
}

unsigned char *sub_244D035E8(unsigned char *a1, char *a2)
{
  sub_244D20964(a2, 0x20uLL);
  *a2 |= 7u;
  a2[31] = a2[31] & 0x3F | 0x80;

  return sub_244D0364C(a1, (uint64_t)a2);
}

unsigned char *sub_244D0364C(unsigned char *a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v3 = *(_OWORD *)(a2 + 16);
  int8x16_t v18 = *(int8x16_t *)a2;
  long long v19 = v3;
  v18.i8[0] &= 0xF8u;
  HIBYTE(v19) = HIBYTE(v3) & 0x3F | 0x40;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  memset(v9, 0, sizeof(v9));
  sub_244D00F9C(v9, &v18);
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  v8[0] = *((void *)&v10 + 1) + v13;
  v8[1] = v11 + *((void *)&v13 + 1);
  _OWORD v8[2] = *((void *)&v11 + 1) + v14;
  v8[3] = v12 + *((void *)&v14 + 1);
  v8[4] = *((void *)&v12 + 1) + v15;
  v7[0] = v13 - *((void *)&v10 + 1) + 0xFFFFFFFFFFFDALL;
  v7[1] = *((void *)&v13 + 1) - v11 + 0xFFFFFFFFFFFFELL;
  v7[2] = v14 - *((void *)&v11 + 1) + 0xFFFFFFFFFFFFELL;
  v7[3] = *((void *)&v14 + 1) - v12 + 0xFFFFFFFFFFFFELL;
  v7[4] = v15 - *((void *)&v12 + 1) + 0xFFFFFFFFFFFFELL;
  sub_244D03D54((uint64_t)v5, v7);
  sub_244D03FA4((uint64_t)v5, v8, (unint64_t *)v5);
  return sub_244CFFAFC(a1, v5);
}

BOOL sub_244D03790(char *a1, long long *a2, long long *a3)
{
  uint64_t v107 = *MEMORY[0x263EF8340];
  uint64_t v101 = 0;
  long long v99 = 0u;
  long long v100 = 0u;
  uint64_t v86 = 0;
  long long v84 = 0u;
  long long v85 = 0u;
  uint64_t v83 = 0;
  long long v81 = 0u;
  long long v82 = 0u;
  uint64_t v80 = 0;
  long long v78 = 0u;
  long long v79 = 0u;
  uint64_t v77 = 0;
  long long v75 = 0u;
  long long v76 = 0u;
  uint64_t v74 = 0;
  long long v72 = 0u;
  long long v73 = 0u;
  uint64_t v71 = 0;
  long long v69 = 0u;
  long long v70 = 0u;
  uint64_t v68 = 0;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v3 = a2[1];
  long long v102 = *a2;
  long long v103 = v3;
  LOBYTE(v102) = v102 & 0xF8;
  HIBYTE(v103) = HIBYTE(v3) & 0x3F | 0x40;
  long long v4 = a3[1];
  long long v104 = *a3;
  long long v105 = v4;
  HIBYTE(v105) = HIBYTE(v4) & 0x7F;
  sub_244D00C4C((unint64_t *)&v99, (unsigned int *)&v104);
  unsigned int v5 = 0;
  long long v97 = 0u;
  long long v98 = 0u;
  uint64_t v95 = 0;
  unint64_t v96 = 1;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v90 = v99;
  long long v91 = v100;
  unsigned int v6 = 254;
  uint64_t v92 = v101;
  long long v88 = 0u;
  uint64_t v87 = 1;
  long long v89 = 0u;
  do
  {
    uint64_t v7 = 0;
    unsigned int v64 = v6;
    unsigned int v65 = (*((unsigned __int8 *)&v102 + ((unint64_t)v6 >> 3)) >> (v6 & 7)) & 1;
    uint64_t v8 = -(uint64_t)(v65 ^ v5);
    do
    {
      uint64_t v9 = *(unint64_t *)((char *)&v96 + v7);
      uint64_t v10 = *(void *)((char *)&v90 + v7);
      uint64_t v11 = (v10 ^ v9) & v8;
      *(unint64_t *)((char *)&v96 + v7) = v11 ^ v9;
      *(void *)((char *)&v90 + v7) = v11 ^ v10;
      v7 += 8;
    }
    while (v7 != 40);
    for (uint64_t i = 0; i != 40; i += 8)
    {
      uint64_t v13 = *(void *)((char *)&v93 + i);
      uint64_t v14 = *(uint64_t *)((char *)&v87 + i);
      uint64_t v15 = (v14 ^ v13) & v8;
      *(void *)((char *)&v93 + i) = v15 ^ v13;
      *(uint64_t *)((char *)&v87 + i) = v15 ^ v14;
    }
    *(void *)&long long v69 = v90 + 0xFFFFFFFFFFFDALL - v87;
    *((void *)&v69 + 1) = *((void *)&v90 + 1) - v88 + 0xFFFFFFFFFFFFELL;
    *(void *)&long long v70 = v91 - *((void *)&v88 + 1) + 0xFFFFFFFFFFFFELL;
    *((void *)&v70 + 1) = *((void *)&v91 + 1) - v89 + 0xFFFFFFFFFFFFELL;
    uint64_t v71 = v92 - *((void *)&v89 + 1) + 0xFFFFFFFFFFFFELL;
    *(void *)&long long v66 = v96 + 0xFFFFFFFFFFFDALL - v93;
    *((void *)&v66 + 1) = v97 - *((void *)&v93 + 1) + 0xFFFFFFFFFFFFELL;
    *(void *)&long long v67 = *((void *)&v97 + 1) - v94 + 0xFFFFFFFFFFFFELL;
    *((void *)&v67 + 1) = v98 - *((void *)&v94 + 1) + 0xFFFFFFFFFFFFELL;
    uint64_t v68 = *((void *)&v98 + 1) - v95 + 0xFFFFFFFFFFFFELL;
    *(void *)&long long v78 = v93 + v96;
    *((void *)&v78 + 1) = *((void *)&v93 + 1) + v97;
    *(void *)&long long v79 = v94 + *((void *)&v97 + 1);
    *((void *)&v79 + 1) = *((void *)&v94 + 1) + v98;
    uint64_t v80 = v95 + *((void *)&v98 + 1);
    *(void *)&long long v75 = v87 + v90;
    *((void *)&v75 + 1) = v88 + *((void *)&v90 + 1);
    *(void *)&long long v76 = *((void *)&v88 + 1) + v91;
    *((void *)&v76 + 1) = v89 + *((void *)&v91 + 1);
    uint64_t v77 = *((void *)&v89 + 1) + v92;
    sub_244D03FA4((uint64_t)&v87, (unint64_t *)&v69, (unint64_t *)&v78);
    sub_244D03FA4((uint64_t)&v93, (unint64_t *)&v75, (unint64_t *)&v66);
    sub_244D001D8((uint64_t)&v84, (unint64_t *)&v66);
    sub_244D001D8((uint64_t)&v81, (unint64_t *)&v78);
    *(void *)&long long v72 = v93 + v87;
    *((void *)&v72 + 1) = *((void *)&v93 + 1) + v88;
    *(void *)&long long v73 = v94 + *((void *)&v88 + 1);
    *((void *)&v73 + 1) = *((void *)&v94 + 1) + v89;
    uint64_t v74 = v95 + *((void *)&v89 + 1);
    *(void *)&long long v75 = v87 + 0xFFFFFFFFFFFDALL - v93;
    *((void *)&v75 + 1) = v88 - *((void *)&v93 + 1) + 0xFFFFFFFFFFFFELL;
    *(void *)&long long v76 = *((void *)&v88 + 1) - v94 + 0xFFFFFFFFFFFFELL;
    *((void *)&v76 + 1) = v89 - *((void *)&v94 + 1) + 0xFFFFFFFFFFFFELL;
    uint64_t v77 = *((void *)&v89 + 1) - v95 + 0xFFFFFFFFFFFFELL;
    sub_244D03FA4((uint64_t)&v96, (unint64_t *)&v81, (unint64_t *)&v84);
    long long v63 = v84;
    unint64_t v16 = v81 + 0xFFFFFFFFFFFDALL - v84;
    uint64_t v17 = *((void *)&v81 + 1) - *((void *)&v84 + 1) + 0xFFFFFFFFFFFFELL;
    uint64_t v18 = v85;
    uint64_t v19 = v82 - v85 + 0xFFFFFFFFFFFFELL;
    uint64_t v20 = *((void *)&v82 + 1) - *((void *)&v85 + 1) + 0xFFFFFFFFFFFFELL;
    uint64_t v61 = v86;
    uint64_t v62 = *((void *)&v85 + 1);
    uint64_t v21 = v83 - v86 + 0xFFFFFFFFFFFFELL;
    *(void *)&long long v66 = v16;
    *((void *)&v66 + 1) = v17;
    *(void *)&long long v67 = v19;
    *((void *)&v67 + 1) = v20;
    uint64_t v68 = v21;
    sub_244D001D8((uint64_t)&v93, (unint64_t *)&v75);
    uint64_t v22 = ((unint64_t)v21 * (unsigned __int128)0x1DB42uLL) >> 64;
    uint64_t v23 = 121666 * v21;
    uint64_t v24 = ((unint64_t)v20 * (unsigned __int128)0x1DB42uLL) >> 64;
    uint64_t v25 = 121666 * v20;
    uint64_t v26 = ((unint64_t)v19 * (unsigned __int128)0x1DB42uLL) >> 64;
    uint64_t v27 = 121666 * v19;
    uint64_t v28 = ((unint64_t)v17 * (unsigned __int128)0x1DB42uLL) >> 64;
    uint64_t v29 = (__int128)(v16 * (unsigned __int128)0x1DB42uLL) >> 51;
    if (__CFADD__(121666 * v17, v29)) {
      ++v28;
    }
    *((void *)&v31 + 1) = v28;
    *(void *)&long long v31 = 121666 * v17 + v29;
    uint64_t v30 = v31 >> 51;
    uint64_t v32 = v31 & 0x7FFFFFFFFFFFFLL;
    BOOL v33 = __CFADD__(v30, v27);
    uint64_t v34 = v30 + v27;
    if (v33) {
      ++v26;
    }
    *((void *)&v36 + 1) = v26;
    *(void *)&long long v36 = v34;
    uint64_t v35 = v36 >> 51;
    uint64_t v37 = v34 & 0x7FFFFFFFFFFFFLL;
    BOOL v33 = __CFADD__(v35, v25);
    uint64_t v38 = v35 + v25;
    if (v33) {
      ++v24;
    }
    *((void *)&v40 + 1) = v24;
    *(void *)&long long v40 = v38;
    uint64_t v39 = v40 >> 51;
    BOOL v33 = __CFADD__(v39, v23);
    uint64_t v41 = v39 + v23;
    if (v33) {
      ++v22;
    }
    *((void *)&v42 + 1) = v22;
    *(void *)&long long v42 = v41;
    uint64_t v43 = v38 & 0x7FFFFFFFFFFFFLL;
    uint64_t v44 = v41 & 0x7FFFFFFFFFFFFLL;
    unint64_t v45 = ((121666 * v16) & 0x7FFFFFFFFFFFELL) + 19 * (v42 >> 51);
    uint64_t v46 = v45 & 0x7FFFFFFFFFFFFLL;
    unint64_t v47 = v32 + (v45 >> 51);
    uint64_t v48 = v47 & 0x7FFFFFFFFFFFFLL;
    uint64_t v87 = v46;
    *(void *)&long long v88 = v47 & 0x7FFFFFFFFFFFFLL;
    uint64_t v49 = v37 + (v47 >> 51);
    *((void *)&v88 + 1) = v49;
    *(void *)&long long v89 = v38 & 0x7FFFFFFFFFFFFLL;
    *((void *)&v89 + 1) = v41 & 0x7FFFFFFFFFFFFLL;
    sub_244D001D8((uint64_t)&v90, (unint64_t *)&v72);
    *(void *)&long long v69 = v46 + v63;
    *((void *)&v69 + 1) = v48 + *((void *)&v63 + 1);
    *(void *)&long long v70 = v49 + v18;
    *((void *)&v70 + 1) = v43 + v62;
    uint64_t v71 = v44 + v61;
    sub_244D03FA4((uint64_t)&v87, (unint64_t *)&v99, (unint64_t *)&v93);
    sub_244D03FA4((uint64_t)&v93, (unint64_t *)&v66, (unint64_t *)&v69);
    unsigned int v5 = v65;
    unsigned int v6 = v64 - 1;
  }
  while (v64);
  uint64_t v50 = 0;
  uint64_t v51 = -(uint64_t)v65;
  do
  {
    uint64_t v52 = *(unint64_t *)((char *)&v96 + v50);
    uint64_t v53 = *(void *)((char *)&v90 + v50);
    uint64_t v54 = (v53 ^ v52) & v51;
    *(unint64_t *)((char *)&v96 + v50) = v54 ^ v52;
    *(void *)((char *)&v90 + v50) = v54 ^ v53;
    v50 += 8;
  }
  while (v50 != 40);
  for (uint64_t j = 0; j != 40; j += 8)
  {
    uint64_t v56 = *(void *)((char *)&v93 + j);
    uint64_t v57 = *(uint64_t *)((char *)&v87 + j);
    uint64_t v58 = (v57 ^ v56) & v51;
    *(void *)((char *)&v93 + j) = v58 ^ v56;
    *(uint64_t *)((char *)&v87 + j) = v58 ^ v57;
  }
  long long v104 = v93;
  long long v105 = v94;
  uint64_t v106 = v95;
  sub_244D03D54((uint64_t)&v93, (unint64_t *)&v104);
  sub_244D03FA4((uint64_t)&v96, &v96, (unint64_t *)&v93);
  sub_244CFFAFC(a1, &v96);
  return sub_244D441D4(byte_244EB5788, a1, 32) != 0;
}

double sub_244D03D54(uint64_t a1, unint64_t *a2)
{
  uint64_t v20 = 0;
  memset(v19, 0, sizeof(v19));
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  sub_244D001D8((uint64_t)v19, a2);
  sub_244D001D8((uint64_t)v17, (unint64_t *)v19);
  sub_244D001D8((uint64_t)v17, (unint64_t *)v17);
  sub_244D03FA4((uint64_t)v17, a2, (unint64_t *)v17);
  sub_244D03FA4((uint64_t)v19, (unint64_t *)v19, (unint64_t *)v17);
  sub_244D001D8((uint64_t)v15, (unint64_t *)v19);
  sub_244D03FA4((uint64_t)v17, (unint64_t *)v17, (unint64_t *)v15);
  sub_244D001D8((uint64_t)v15, (unint64_t *)v17);
  int v4 = 4;
  do
  {
    sub_244D001D8((uint64_t)v15, (unint64_t *)v15);
    --v4;
  }
  while (v4);
  sub_244D03FA4((uint64_t)v17, (unint64_t *)v15, (unint64_t *)v17);
  sub_244D001D8((uint64_t)v15, (unint64_t *)v17);
  int v5 = 9;
  do
  {
    sub_244D001D8((uint64_t)v15, (unint64_t *)v15);
    --v5;
  }
  while (v5);
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  sub_244D03FA4((uint64_t)v15, (unint64_t *)v15, (unint64_t *)v17);
  sub_244D001D8((uint64_t)v13, (unint64_t *)v15);
  int v6 = 19;
  do
  {
    sub_244D001D8((uint64_t)v13, (unint64_t *)v13);
    --v6;
  }
  while (v6);
  sub_244D03FA4((uint64_t)v15, (unint64_t *)v13, (unint64_t *)v15);
  sub_244D001D8((uint64_t)v15, (unint64_t *)v15);
  int v7 = 9;
  do
  {
    sub_244D001D8((uint64_t)v15, (unint64_t *)v15);
    --v7;
  }
  while (v7);
  sub_244D03FA4((uint64_t)v17, (unint64_t *)v15, (unint64_t *)v17);
  sub_244D001D8((uint64_t)v15, (unint64_t *)v17);
  int v8 = 49;
  do
  {
    sub_244D001D8((uint64_t)v15, (unint64_t *)v15);
    --v8;
  }
  while (v8);
  sub_244D03FA4((uint64_t)v15, (unint64_t *)v15, (unint64_t *)v17);
  sub_244D001D8((uint64_t)v13, (unint64_t *)v15);
  int v9 = 99;
  do
  {
    sub_244D001D8((uint64_t)v13, (unint64_t *)v13);
    --v9;
  }
  while (v9);
  sub_244D03FA4((uint64_t)v15, (unint64_t *)v13, (unint64_t *)v15);
  sub_244D001D8((uint64_t)v15, (unint64_t *)v15);
  int v10 = 49;
  do
  {
    sub_244D001D8((uint64_t)v15, (unint64_t *)v15);
    --v10;
  }
  while (v10);
  sub_244D03FA4((uint64_t)v17, (unint64_t *)v15, (unint64_t *)v17);
  sub_244D001D8((uint64_t)v17, (unint64_t *)v17);
  int v11 = 4;
  do
  {
    sub_244D001D8((uint64_t)v17, (unint64_t *)v17);
    --v11;
  }
  while (v11);
  *(void *)&double result = sub_244D03FA4(a1, (unint64_t *)v17, (unint64_t *)v19).u64[0];
  return result;
}

int8x16_t sub_244D03FA4(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = a3[3];
  unint64_t v3 = a3[4];
  unint64_t v5 = a2[4];
  unint64_t v7 = a3[1];
  unint64_t v6 = a3[2];
  unint64_t v8 = *a3;
  unint64_t v10 = a2[2];
  unint64_t v9 = a2[3];
  unint64_t v11 = *a2;
  unint64_t v12 = a2[1];
  uint64_t v14 = v9 * 19 * v6 + 19 * v7 * v5 + v10 * 19 * v4 + v12 * 19 * v3 + v11 * *a3;
  unsigned long long v15 = v9 * (unsigned __int128)(19 * v3) + 19 * v4 * (unsigned __int128)v5;
  uint64_t v16 = (v9 * (unsigned __int128)(19 * v4)
       + 19 * v6 * (unsigned __int128)v5
       + v10 * (unsigned __int128)(19 * v3)
       + *a3 * (unsigned __int128)v12
       + v11 * (unsigned __int128)v7) >> 64;
  uint64_t v17 = v9 * 19 * v4 + 19 * v6 * v5 + v10 * 19 * v3 + *a3 * v12 + v11 * v7;
  uint64_t v18 = (__int128)(v9 * (unsigned __int128)(19 * v6)
                 + 19 * v7 * (unsigned __int128)v5
                 + v10 * (unsigned __int128)(19 * v4)
                 + v12 * (unsigned __int128)(19 * v3)
                 + v11 * (unsigned __int128)*a3) >> 51;
  BOOL v19 = __CFADD__(v17, v18);
  uint64_t v20 = v17 + v18;
  if (v19) {
    ++v16;
  }
  *((void *)&v22 + 1) = v16;
  *(void *)&long long v22 = v20;
  uint64_t v21 = v22 >> 51;
  uint64_t v24 = (v15 + v12 * (unsigned __int128)v7 + v8 * (unsigned __int128)v10 + v11 * (unsigned __int128)v6) >> 64;
  uint64_t v23 = v15 + v12 * v7 + v8 * v10 + v11 * v6;
  BOOL v19 = __CFADD__(v23, v21);
  uint64_t v25 = v23 + v21;
  if (v19) {
    ++v24;
  }
  unsigned long long v26 = v10 * (unsigned __int128)v7
      + 19 * v3 * (unsigned __int128)v5
      + v12 * (unsigned __int128)v6
      + v8 * (unsigned __int128)v9
      + v11 * (unsigned __int128)v4;
  unsigned long long v27 = v10 * (unsigned __int128)v6
      + v9 * (unsigned __int128)v7
      + v12 * (unsigned __int128)v4
      + v8 * (unsigned __int128)v5;
  unsigned long long v29 = v27 + v11 * (unsigned __int128)v3;
  uint64_t v28 = *((void *)&v29 + 1);
  *((void *)&v30 + 1) = v24;
  *(void *)&long long v30 = v25;
  uint64_t v31 = v26 + (v30 >> 51);
  *((void *)&v30 + 1) = v27;
  *(void *)&long long v30 = v31;
  uint64_t v32 = v30 >> 51;
  v33.i64[0] = v31;
  if (__CFADD__((void)v29, v32)) {
    uint64_t v28 = *((void *)&v29 + 1) + 1;
  }
  *((void *)&v34 + 1) = v28;
  *(void *)&long long v34 = v29 + v32;
  v33.i64[1] = v29 + v32;
  unint64_t v35 = (v14 & 0x7FFFFFFFFFFFFLL) + 19 * (v34 >> 51);
  unint64_t v36 = (v20 & 0x7FFFFFFFFFFFFLL) + (v35 >> 51);
  *(void *)a1 = v35 & 0x7FFFFFFFFFFFFLL;
  *(void *)(a1 + 8) = v36 & 0x7FFFFFFFFFFFFLL;
  *(void *)(a1 + 16) = (v25 & 0x7FFFFFFFFFFFFLL) + (v36 >> 51);
  int8x16_t result = vandq_s8(v33, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFuLL));
  *(int8x16_t *)(a1 + 24) = result;
  return result;
}

uint64_t sub_244D041C0(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0; i != 256; ++i)
    *(unsigned char *)(result + i) = (*(unsigned __int8 *)(a2 + (i >> 3)) >> (i & 7)) & 1;
  unint64_t v3 = 0;
  uint64_t v4 = result + 1;
  uint64_t v5 = 1;
  do
  {
    if (*(unsigned char *)(result + v3) && v3 <= 0xFE)
    {
      unint64_t v6 = v3;
      unint64_t v7 = 1;
      uint64_t v8 = v5;
      do
      {
        int v9 = *(char *)(result + v8);
        if (*(unsigned char *)(result + v8))
        {
          int v10 = *(char *)(result + v3);
          int v11 = v9 << v7;
          int v12 = (v9 << v7) + v10;
          if (v12 > 15)
          {
            int v13 = v10 - v11;
            if (v13 < -15) {
              break;
            }
            *(unsigned char *)(result + v3) = v13;
            unint64_t v14 = v6;
            while (*(unsigned char *)(v4 + v14))
            {
              *(unsigned char *)(v4 + v14++) = 0;
              if (v14 >= 0xFF) {
                goto LABEL_16;
              }
            }
            *(unsigned char *)(v4 + v14) = 1;
          }
          else
          {
            *(unsigned char *)(result + v3) = v12;
            *(unsigned char *)(result + v8) = 0;
          }
        }
LABEL_16:
        if (v7 > 5) {
          break;
        }
        ++v7;
        ++v8;
        ++v6;
      }
      while (v7 + v3 < 0x100);
    }
    ++v3;
    ++v5;
  }
  while (v3 != 256);
  return result;
}

uint64_t sub_244D042A8(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = a1[1];
  int v4 = (*a1 ^ (v3 >> 4)) & 0xF0F0F0F;
  unsigned int v5 = ((v4 ^ *a1 ^ ((v4 ^ *a1) << 18)) & 0xCCCC0000 | (((v4 ^ *a1 ^ ((v4 ^ *a1) << 18)) & 0xCCCC0000) >> 18)) ^ v4 ^ *a1;
  unsigned int v6 = ((v3 ^ (16 * v4) ^ ((v3 ^ (16 * v4)) << 18)) & 0xCCCC0000 | (((v3 ^ (16 * v4) ^ ((v3 ^ (16 * v4)) << 18)) & 0xCCCC0000) >> 18)) ^ v3 ^ (16 * v4);
  int v7 = (v5 ^ (v6 >> 1)) & 0x55555555;
  unsigned int v8 = v7 ^ v5;
  int v9 = v6 ^ (2 * v7);
  int v10 = (v9 ^ (v8 >> 8)) & 0xFF00FF;
  unsigned int v11 = v10 ^ v9;
  int v12 = v8 ^ (v10 << 8);
  int v13 = (v12 ^ (v11 >> 1)) & 0x55555555;
  unsigned int v14 = v13 ^ v12;
  unsigned int v15 = (v14 >> 4) & 0xF000000 | (v11 ^ (2 * v13)) & 0xFF00 | ((v11 ^ (2 * v13)) << 16) | ((v11 ^ (2 * v13)) >> 16);
  uint64_t v16 = (_DWORD *)(a2 + 4);
  do
  {
    if ((0x8103uLL >> v2)) {
      char v17 = 1;
    }
    else {
      char v17 = 2;
    }
    unsigned int v18 = (v14 & 0xFFFFFFF) >> v17;
    if ((0x8103uLL >> v2)) {
      char v19 = 27;
    }
    else {
      char v19 = 26;
    }
    unsigned int v20 = v15 >> v17;
    unsigned int v14 = v18 | (v14 << v19);
    unsigned int v21 = v20 | (v15 << v19);
    unsigned int v15 = v21 & 0xFFFFFFF;
    int v22 = dword_244EB5B88[((v18 >> 7) & 0x3C | (v18 >> 6)) + 64] | dword_244EB5B88[v18 & 0x3F] | dword_244EB5B88[((v18 >> 14) & 0x30 | (v18 >> 13) & 0xF) + 128] | dword_244EB5B88[((v18 >> 21) & 6 | (v18 >> 20) & 1 | (v14 >> 22) & 0x38) + 192];
    int v23 = dword_244EB5B88[((v20 >> 8) & 0x3C | (v20 >> 7) & 3) + 320] | dword_244EB5B88[(v20 & 0x3F) + 256] | dword_244EB5B88[((v20 >> 15) & 0x3F) + 384] | dword_244EB5B88[((v21 >> 22) & 0x30 | (v20 >> 21) & 0xF) + 448];
    HIDWORD(v24) = v23 << 16;
    LODWORD(v24) = v23 << 16;
    int v25 = (v24 >> 30) | (4 * (unsigned __int16)v22);
    uint64_t result = v23 & 0x3FF0000 | HIWORD(v22);
    HIDWORD(v24) = v23 & 0x3FF0000 | HIWORD(v22);
    LODWORD(v24) = v23;
    *(v16 - 1) = v25;
    *uint64_t v16 = v24 >> 26;
    ++v2;
    v16 += 2;
  }
  while (v2 != 16);
  return result;
}

uint64_t sub_244D0444C(uint64_t result)
{
  for (uint64_t i = 0; i != 8; ++i)
    *(unsigned char *)(result + i) = byte_244EB6388[*(unsigned __int8 *)(result + i)];
  return result;
}

_DWORD *sub_244D04474(int *a1, int *a2, int *a3, int *a4)
{
  unsigned int v7 = a1[1];
  int v8 = (*a1 ^ (v7 >> 4)) & 0xF0F0F0F;
  unsigned int v9 = v8 ^ *a1;
  int v10 = v7 ^ (16 * v8);
  int v11 = (unsigned __int16)v10 ^ HIWORD(v9);
  unsigned int v12 = v11 ^ v10;
  int v13 = v9 ^ (v11 << 16);
  int v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  unsigned int v15 = v14 ^ v13;
  int v16 = v12 ^ (4 * v14);
  int v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  unsigned int v18 = v17 ^ v16;
  int v19 = v15 ^ (v17 << 8);
  int v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *a1 = v20 ^ v19;
  a1[1] = v18 ^ (2 * v20);
  sub_244D0457C(a1, a2, 1);
  sub_244D0457C(a1, a3, 0);
  uint64_t result = sub_244D0457C(a1, a4, 1);
  unsigned int v22 = a1[1];
  int v23 = (*a1 ^ (v22 >> 1)) & 0x55555555;
  unsigned int v24 = v23 ^ *a1;
  int v25 = v22 ^ (2 * v23);
  int v26 = (v25 ^ (v24 >> 8)) & 0xFF00FF;
  unsigned int v27 = v26 ^ v25;
  int v28 = v24 ^ (v26 << 8);
  int v29 = (v28 ^ (v27 >> 2)) & 0x33333333;
  unsigned int v30 = v29 ^ v28;
  int v31 = v27 ^ (4 * v29);
  int v32 = (unsigned __int16)v31 ^ HIWORD(v30);
  unsigned int v33 = v32 ^ v31;
  int v34 = v30 ^ (v32 << 16);
  int v35 = (v34 ^ (v33 >> 4)) & 0xF0F0F0F;
  *a1 = v35 ^ v34;
  a1[1] = v33 ^ (16 * v35);
  return result;
}

_DWORD *sub_244D0457C(_DWORD *result, int *a2, int a3)
{
  HIDWORD(v4) = *result;
  LODWORD(v4) = *result;
  int v3 = v4 >> 29;
  HIDWORD(v4) = result[1];
  LODWORD(v4) = HIDWORD(v4);
  int v5 = v4 >> 29;
  if (a3)
  {
    unsigned int v6 = *a2 ^ v3;
    HIDWORD(v8) = a2[1] ^ v3;
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v7 = v8 >> 4;
    int v9 = dword_244EB6488[v6 >> 2] ^ dword_244EB6488[((unsigned __int16)v6 >> 10) + 128] ^ dword_244EB6488[((v6 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v6 >> 26) + 384] ^ dword_244EB6488[(v7 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v7 >> 10) + 192] ^ dword_244EB6488[((v7 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v7 >> 26) + 448] ^ v5;
    unsigned int v10 = v9 ^ a2[2];
    HIDWORD(v8) = v9 ^ a2[3];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v11 = v8 >> 4;
    int v12 = dword_244EB6488[v10 >> 2] ^ dword_244EB6488[((unsigned __int16)v10 >> 10) + 128] ^ dword_244EB6488[((v10 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v10 >> 26) + 384] ^ dword_244EB6488[(v11 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v11 >> 10) + 192] ^ dword_244EB6488[((v11 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v11 >> 26) + 448] ^ v3;
    unsigned int v13 = v12 ^ a2[4];
    HIDWORD(v8) = v12 ^ a2[5];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v14 = v8 >> 4;
    int v15 = dword_244EB6488[v13 >> 2] ^ dword_244EB6488[((unsigned __int16)v13 >> 10) + 128] ^ dword_244EB6488[((v13 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v13 >> 26) + 384] ^ dword_244EB6488[(v14 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v14 >> 10) + 192] ^ dword_244EB6488[((v14 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v14 >> 26) + 448] ^ v9;
    unsigned int v16 = v15 ^ a2[6];
    HIDWORD(v8) = v15 ^ a2[7];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v17 = v8 >> 4;
    int v18 = dword_244EB6488[v16 >> 2] ^ dword_244EB6488[((unsigned __int16)v16 >> 10) + 128] ^ dword_244EB6488[((v16 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v16 >> 26) + 384] ^ dword_244EB6488[(v17 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v17 >> 10) + 192] ^ dword_244EB6488[((v17 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v17 >> 26) + 448] ^ v12;
    unsigned int v19 = v18 ^ a2[8];
    HIDWORD(v8) = v18 ^ a2[9];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v20 = v8 >> 4;
    int v21 = dword_244EB6488[v19 >> 2] ^ dword_244EB6488[((unsigned __int16)v19 >> 10) + 128] ^ dword_244EB6488[((v19 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v19 >> 26) + 384] ^ dword_244EB6488[(v20 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v20 >> 10) + 192] ^ dword_244EB6488[((v20 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v20 >> 26) + 448] ^ v15;
    unsigned int v22 = v21 ^ a2[10];
    HIDWORD(v8) = v21 ^ a2[11];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v23 = v8 >> 4;
    int v24 = dword_244EB6488[v22 >> 2] ^ dword_244EB6488[((unsigned __int16)v22 >> 10) + 128] ^ dword_244EB6488[((v22 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v22 >> 26) + 384] ^ dword_244EB6488[(v23 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v23 >> 10) + 192] ^ dword_244EB6488[((v23 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v23 >> 26) + 448] ^ v18;
    unsigned int v25 = v24 ^ a2[12];
    HIDWORD(v8) = v24 ^ a2[13];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v26 = v8 >> 4;
    int v27 = dword_244EB6488[v25 >> 2] ^ dword_244EB6488[((unsigned __int16)v25 >> 10) + 128] ^ dword_244EB6488[((v25 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v25 >> 26) + 384] ^ dword_244EB6488[(v26 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v26 >> 10) + 192] ^ dword_244EB6488[((v26 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v26 >> 26) + 448] ^ v21;
    unsigned int v28 = v27 ^ a2[14];
    HIDWORD(v8) = v27 ^ a2[15];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v29 = v8 >> 4;
    int v30 = dword_244EB6488[v28 >> 2] ^ dword_244EB6488[((unsigned __int16)v28 >> 10) + 128] ^ dword_244EB6488[((v28 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v28 >> 26) + 384] ^ dword_244EB6488[(v29 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v29 >> 10) + 192] ^ dword_244EB6488[((v29 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v29 >> 26) + 448] ^ v24;
    unsigned int v31 = v30 ^ a2[16];
    HIDWORD(v8) = v30 ^ a2[17];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v32 = v8 >> 4;
    int v33 = dword_244EB6488[v31 >> 2] ^ dword_244EB6488[((unsigned __int16)v31 >> 10) + 128] ^ dword_244EB6488[((v31 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v31 >> 26) + 384] ^ dword_244EB6488[(v32 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v32 >> 10) + 192] ^ dword_244EB6488[((v32 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v32 >> 26) + 448] ^ v27;
    unsigned int v34 = v33 ^ a2[18];
    HIDWORD(v8) = v33 ^ a2[19];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v35 = v8 >> 4;
    int v36 = dword_244EB6488[v34 >> 2] ^ dword_244EB6488[((unsigned __int16)v34 >> 10) + 128] ^ dword_244EB6488[((v34 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v34 >> 26) + 384] ^ dword_244EB6488[(v35 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v35 >> 10) + 192] ^ dword_244EB6488[((v35 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v35 >> 26) + 448] ^ v30;
    unsigned int v37 = v36 ^ a2[20];
    HIDWORD(v8) = v36 ^ a2[21];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v38 = v8 >> 4;
    int v39 = dword_244EB6488[v37 >> 2] ^ dword_244EB6488[((unsigned __int16)v37 >> 10) + 128] ^ dword_244EB6488[((v37 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v37 >> 26) + 384] ^ dword_244EB6488[(v38 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v38 >> 10) + 192] ^ dword_244EB6488[((v38 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v38 >> 26) + 448] ^ v33;
    unsigned int v40 = v39 ^ a2[22];
    HIDWORD(v8) = v39 ^ a2[23];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v41 = v8 >> 4;
    int v42 = dword_244EB6488[v40 >> 2] ^ dword_244EB6488[((unsigned __int16)v40 >> 10) + 128] ^ dword_244EB6488[((v40 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v40 >> 26) + 384] ^ dword_244EB6488[(v41 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v41 >> 10) + 192] ^ dword_244EB6488[((v41 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v41 >> 26) + 448] ^ v36;
    unsigned int v43 = v42 ^ a2[24];
    HIDWORD(v8) = v42 ^ a2[25];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v44 = v8 >> 4;
    int v45 = dword_244EB6488[v43 >> 2] ^ dword_244EB6488[((unsigned __int16)v43 >> 10) + 128] ^ dword_244EB6488[((v43 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v43 >> 26) + 384] ^ dword_244EB6488[(v44 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v44 >> 10) + 192] ^ dword_244EB6488[((v44 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v44 >> 26) + 448] ^ v39;
    unsigned int v46 = v45 ^ a2[26];
    HIDWORD(v8) = v45 ^ a2[27];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v47 = v8 >> 4;
    int v48 = dword_244EB6488[v46 >> 2] ^ dword_244EB6488[((unsigned __int16)v46 >> 10) + 128] ^ dword_244EB6488[((v46 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v46 >> 26) + 384] ^ dword_244EB6488[(v47 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v47 >> 10) + 192] ^ dword_244EB6488[((v47 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v47 >> 26) + 448] ^ v42;
    unsigned int v49 = v48 ^ a2[28];
    HIDWORD(v8) = v48 ^ a2[29];
    LODWORD(v8) = HIDWORD(v8);
    int v50 = dword_244EB6488[v49 >> 2] ^ dword_244EB6488[((unsigned __int16)v49 >> 10) + 128] ^ dword_244EB6488[((v49 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v49 >> 26) + 384] ^ dword_244EB6488[((v8 >> 4) >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)(v8 >> 4) >> 10) + 192] ^ dword_244EB6488[(((v8 >> 4) >> 18) & 0x3F) + 320] ^ dword_244EB6488[((v8 >> 4) >> 26) + 448] ^ v45;
    int v51 = a2[30];
    int v52 = a2[31];
  }
  else
  {
    unsigned int v53 = a2[30] ^ v3;
    HIDWORD(v55) = a2[31] ^ v3;
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v54 = v55 >> 4;
    int v56 = dword_244EB6488[v53 >> 2] ^ dword_244EB6488[((unsigned __int16)v53 >> 10) + 128] ^ dword_244EB6488[((v53 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v53 >> 26) + 384] ^ dword_244EB6488[(v54 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v54 >> 10) + 192] ^ dword_244EB6488[((v54 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v54 >> 26) + 448] ^ v5;
    unsigned int v57 = v56 ^ a2[28];
    HIDWORD(v55) = v56 ^ a2[29];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v58 = v55 >> 4;
    int v59 = dword_244EB6488[v57 >> 2] ^ dword_244EB6488[((unsigned __int16)v57 >> 10) + 128] ^ dword_244EB6488[((v57 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v57 >> 26) + 384] ^ dword_244EB6488[(v58 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v58 >> 10) + 192] ^ dword_244EB6488[((v58 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v58 >> 26) + 448] ^ v3;
    unsigned int v60 = v59 ^ a2[26];
    HIDWORD(v55) = v59 ^ a2[27];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v61 = v55 >> 4;
    int v62 = dword_244EB6488[v60 >> 2] ^ dword_244EB6488[((unsigned __int16)v60 >> 10) + 128] ^ dword_244EB6488[((v60 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v60 >> 26) + 384] ^ dword_244EB6488[(v61 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v61 >> 10) + 192] ^ dword_244EB6488[((v61 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v61 >> 26) + 448] ^ v56;
    unsigned int v63 = v62 ^ a2[24];
    HIDWORD(v55) = v62 ^ a2[25];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v64 = v55 >> 4;
    int v65 = dword_244EB6488[v63 >> 2] ^ dword_244EB6488[((unsigned __int16)v63 >> 10) + 128] ^ dword_244EB6488[((v63 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v63 >> 26) + 384] ^ dword_244EB6488[(v64 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v64 >> 10) + 192] ^ dword_244EB6488[((v64 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v64 >> 26) + 448] ^ v59;
    unsigned int v66 = v65 ^ a2[22];
    HIDWORD(v55) = v65 ^ a2[23];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v67 = v55 >> 4;
    int v68 = dword_244EB6488[v66 >> 2] ^ dword_244EB6488[((unsigned __int16)v66 >> 10) + 128] ^ dword_244EB6488[((v66 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v66 >> 26) + 384] ^ dword_244EB6488[(v67 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v67 >> 10) + 192] ^ dword_244EB6488[((v67 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v67 >> 26) + 448] ^ v62;
    unsigned int v69 = v68 ^ a2[20];
    HIDWORD(v55) = v68 ^ a2[21];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v70 = v55 >> 4;
    int v71 = dword_244EB6488[v69 >> 2] ^ dword_244EB6488[((unsigned __int16)v69 >> 10) + 128] ^ dword_244EB6488[((v69 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v69 >> 26) + 384] ^ dword_244EB6488[(v70 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v70 >> 10) + 192] ^ dword_244EB6488[((v70 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v70 >> 26) + 448] ^ v65;
    unsigned int v72 = v71 ^ a2[18];
    HIDWORD(v55) = v71 ^ a2[19];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v73 = v55 >> 4;
    int v74 = dword_244EB6488[v72 >> 2] ^ dword_244EB6488[((unsigned __int16)v72 >> 10) + 128] ^ dword_244EB6488[((v72 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v72 >> 26) + 384] ^ dword_244EB6488[(v73 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v73 >> 10) + 192] ^ dword_244EB6488[((v73 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v73 >> 26) + 448] ^ v68;
    unsigned int v75 = v74 ^ a2[16];
    HIDWORD(v55) = v74 ^ a2[17];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v76 = v55 >> 4;
    int v77 = dword_244EB6488[v75 >> 2] ^ dword_244EB6488[((unsigned __int16)v75 >> 10) + 128] ^ dword_244EB6488[((v75 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v75 >> 26) + 384] ^ dword_244EB6488[(v76 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v76 >> 10) + 192] ^ dword_244EB6488[((v76 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v76 >> 26) + 448] ^ v71;
    unsigned int v78 = v77 ^ a2[14];
    HIDWORD(v55) = v77 ^ a2[15];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v79 = v55 >> 4;
    int v80 = dword_244EB6488[v78 >> 2] ^ dword_244EB6488[((unsigned __int16)v78 >> 10) + 128] ^ dword_244EB6488[((v78 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v78 >> 26) + 384] ^ dword_244EB6488[(v79 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v79 >> 10) + 192] ^ dword_244EB6488[((v79 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v79 >> 26) + 448] ^ v74;
    unsigned int v81 = v80 ^ a2[12];
    HIDWORD(v55) = v80 ^ a2[13];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v82 = v55 >> 4;
    int v83 = dword_244EB6488[v81 >> 2] ^ dword_244EB6488[((unsigned __int16)v81 >> 10) + 128] ^ dword_244EB6488[((v81 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v81 >> 26) + 384] ^ dword_244EB6488[(v82 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v82 >> 10) + 192] ^ dword_244EB6488[((v82 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v82 >> 26) + 448] ^ v77;
    unsigned int v84 = v83 ^ a2[10];
    HIDWORD(v55) = v83 ^ a2[11];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v85 = v55 >> 4;
    int v86 = dword_244EB6488[v84 >> 2] ^ dword_244EB6488[((unsigned __int16)v84 >> 10) + 128] ^ dword_244EB6488[((v84 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v84 >> 26) + 384] ^ dword_244EB6488[(v85 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v85 >> 10) + 192] ^ dword_244EB6488[((v85 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v85 >> 26) + 448] ^ v80;
    unsigned int v87 = v86 ^ a2[8];
    HIDWORD(v55) = v86 ^ a2[9];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v88 = v55 >> 4;
    int v89 = dword_244EB6488[v87 >> 2] ^ dword_244EB6488[((unsigned __int16)v87 >> 10) + 128] ^ dword_244EB6488[((v87 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v87 >> 26) + 384] ^ dword_244EB6488[(v88 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v88 >> 10) + 192] ^ dword_244EB6488[((v88 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v88 >> 26) + 448] ^ v83;
    unsigned int v90 = v89 ^ a2[6];
    HIDWORD(v55) = v89 ^ a2[7];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v91 = v55 >> 4;
    int v92 = dword_244EB6488[v90 >> 2] ^ dword_244EB6488[((unsigned __int16)v90 >> 10) + 128] ^ dword_244EB6488[((v90 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v90 >> 26) + 384] ^ dword_244EB6488[(v91 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v91 >> 10) + 192] ^ dword_244EB6488[((v91 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v91 >> 26) + 448] ^ v86;
    unsigned int v93 = v92 ^ a2[4];
    HIDWORD(v55) = v92 ^ a2[5];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v94 = v55 >> 4;
    int v48 = dword_244EB6488[v93 >> 2] ^ dword_244EB6488[((unsigned __int16)v93 >> 10) + 128] ^ dword_244EB6488[((v93 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v93 >> 26) + 384] ^ dword_244EB6488[(v94 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v94 >> 10) + 192] ^ dword_244EB6488[((v94 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v94 >> 26) + 448] ^ v89;
    unsigned int v95 = v48 ^ a2[2];
    HIDWORD(v55) = v48 ^ a2[3];
    LODWORD(v55) = HIDWORD(v55);
    int v50 = dword_244EB6488[v95 >> 2] ^ dword_244EB6488[((unsigned __int16)v95 >> 10) + 128] ^ dword_244EB6488[((v95 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v95 >> 26) + 384] ^ dword_244EB6488[((v55 >> 4) >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)(v55 >> 4) >> 10) + 192] ^ dword_244EB6488[(((v55 >> 4) >> 18) & 0x3F) + 320] ^ dword_244EB6488[((v55 >> 4) >> 26) + 448] ^ v92;
    int v51 = *a2;
    int v52 = a2[1];
  }
  unsigned int v96 = v50 ^ v51;
  HIDWORD(v98) = v50 ^ v52;
  LODWORD(v98) = v50 ^ v52;
  unsigned int v97 = v98 >> 4;
  HIDWORD(v98) = v50;
  LODWORD(v98) = v50;
  int v99 = v98 >> 3;
  HIDWORD(v98) = dword_244EB6488[v96 >> 2] ^ dword_244EB6488[((unsigned __int16)v96 >> 10) + 128] ^ dword_244EB6488[((v96 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v96 >> 26) + 384] ^ dword_244EB6488[(v97 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v97 >> 10) + 192] ^ dword_244EB6488[((v97 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v97 >> 26) + 448] ^ v48;
  LODWORD(v98) = HIDWORD(v98);
  *uint64_t result = v99;
  result[1] = v98 >> 3;
  return result;
}

_DWORD *sub_244D05398(int *a1, int *a2, int *a3, int *a4)
{
  unsigned int v7 = a1[1];
  int v8 = (*a1 ^ (v7 >> 4)) & 0xF0F0F0F;
  unsigned int v9 = v8 ^ *a1;
  int v10 = v7 ^ (16 * v8);
  int v11 = (unsigned __int16)v10 ^ HIWORD(v9);
  unsigned int v12 = v11 ^ v10;
  int v13 = v9 ^ (v11 << 16);
  int v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  unsigned int v15 = v14 ^ v13;
  int v16 = v12 ^ (4 * v14);
  int v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  unsigned int v18 = v17 ^ v16;
  int v19 = v15 ^ (v17 << 8);
  int v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *a1 = v20 ^ v19;
  a1[1] = v18 ^ (2 * v20);
  sub_244D0457C(a1, a4, 0);
  sub_244D0457C(a1, a3, 1);
  uint64_t result = sub_244D0457C(a1, a2, 0);
  unsigned int v22 = a1[1];
  int v23 = (*a1 ^ (v22 >> 1)) & 0x55555555;
  unsigned int v24 = v23 ^ *a1;
  int v25 = v22 ^ (2 * v23);
  int v26 = (v25 ^ (v24 >> 8)) & 0xFF00FF;
  unsigned int v27 = v26 ^ v25;
  int v28 = v24 ^ (v26 << 8);
  int v29 = (v28 ^ (v27 >> 2)) & 0x33333333;
  unsigned int v30 = v29 ^ v28;
  int v31 = v27 ^ (4 * v29);
  int v32 = (unsigned __int16)v31 ^ HIWORD(v30);
  unsigned int v33 = v32 ^ v31;
  int v34 = v30 ^ (v32 << 16);
  int v35 = (v34 ^ (v33 >> 4)) & 0xF0F0F0F;
  *a1 = v35 ^ v34;
  a1[1] = v33 ^ (16 * v35);
  return result;
}

double sub_244D054A8(void *a1, void *a2, int *a3, int a4)
{
  v6[1] = *MEMORY[0x263EF8340];
  v6[0] = *a1;
  sub_244D0551C((int *)v6, a3, a4);
  double result = *(double *)v6;
  *a2 = v6[0];
  return result;
}

int *sub_244D0551C(int *result, int *a2, int a3)
{
  unsigned int v3 = result[1];
  int v4 = (*result ^ (v3 >> 4)) & 0xF0F0F0F;
  unsigned int v5 = v4 ^ *result;
  int v6 = v3 ^ (16 * v4);
  int v7 = (unsigned __int16)v6 ^ HIWORD(v5);
  unsigned int v8 = v7 ^ v6;
  int v9 = v5 ^ (v7 << 16);
  int v10 = (v9 ^ (v8 >> 2)) & 0x33333333;
  unsigned int v11 = v10 ^ v9;
  int v12 = v8 ^ (4 * v10);
  int v13 = (v12 ^ (v11 >> 8)) & 0xFF00FF;
  unsigned int v14 = v13 ^ v12;
  int v15 = v11 ^ (v13 << 8);
  int v16 = (v15 ^ (v14 >> 1)) & 0x55555555;
  HIDWORD(v18) = v16 ^ v15;
  LODWORD(v18) = v16 ^ v15;
  int v17 = v18 >> 29;
  HIDWORD(v18) = v14 ^ (2 * v16);
  LODWORD(v18) = HIDWORD(v18);
  int v19 = v18 >> 29;
  if (a3)
  {
    unsigned int v20 = *a2 ^ v17;
    HIDWORD(v22) = a2[1] ^ v17;
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v21 = v22 >> 4;
    int v23 = dword_244EB6488[v20 >> 2] ^ dword_244EB6488[((unsigned __int16)v20 >> 10) + 128] ^ dword_244EB6488[((v20 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v20 >> 26) + 384] ^ dword_244EB6488[(v21 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v21 >> 10) + 192] ^ dword_244EB6488[((v21 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v21 >> 26) + 448] ^ v19;
    unsigned int v24 = v23 ^ a2[2];
    HIDWORD(v22) = v23 ^ a2[3];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v25 = v22 >> 4;
    int v26 = dword_244EB6488[v24 >> 2] ^ dword_244EB6488[((unsigned __int16)v24 >> 10) + 128] ^ dword_244EB6488[((v24 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v24 >> 26) + 384] ^ dword_244EB6488[(v25 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v25 >> 10) + 192] ^ dword_244EB6488[((v25 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v25 >> 26) + 448] ^ v17;
    unsigned int v27 = v26 ^ a2[4];
    HIDWORD(v22) = v26 ^ a2[5];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v28 = v22 >> 4;
    int v29 = dword_244EB6488[v27 >> 2] ^ dword_244EB6488[((unsigned __int16)v27 >> 10) + 128] ^ dword_244EB6488[((v27 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v27 >> 26) + 384] ^ dword_244EB6488[(v28 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v28 >> 10) + 192] ^ dword_244EB6488[((v28 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v28 >> 26) + 448] ^ v23;
    unsigned int v30 = v29 ^ a2[6];
    HIDWORD(v22) = v29 ^ a2[7];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v31 = v22 >> 4;
    int v32 = dword_244EB6488[v30 >> 2] ^ dword_244EB6488[((unsigned __int16)v30 >> 10) + 128] ^ dword_244EB6488[((v30 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v30 >> 26) + 384] ^ dword_244EB6488[(v31 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v31 >> 10) + 192] ^ dword_244EB6488[((v31 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v31 >> 26) + 448] ^ v26;
    unsigned int v33 = v32 ^ a2[8];
    HIDWORD(v22) = v32 ^ a2[9];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v34 = v22 >> 4;
    int v35 = dword_244EB6488[v33 >> 2] ^ dword_244EB6488[((unsigned __int16)v33 >> 10) + 128] ^ dword_244EB6488[((v33 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v33 >> 26) + 384] ^ dword_244EB6488[(v34 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v34 >> 10) + 192] ^ dword_244EB6488[((v34 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v34 >> 26) + 448] ^ v29;
    unsigned int v36 = v35 ^ a2[10];
    HIDWORD(v22) = v35 ^ a2[11];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v37 = v22 >> 4;
    int v38 = dword_244EB6488[v36 >> 2] ^ dword_244EB6488[((unsigned __int16)v36 >> 10) + 128] ^ dword_244EB6488[((v36 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v36 >> 26) + 384] ^ dword_244EB6488[(v37 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v37 >> 10) + 192] ^ dword_244EB6488[((v37 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v37 >> 26) + 448] ^ v32;
    unsigned int v39 = v38 ^ a2[12];
    HIDWORD(v22) = v38 ^ a2[13];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v40 = v22 >> 4;
    int v41 = dword_244EB6488[v39 >> 2] ^ dword_244EB6488[((unsigned __int16)v39 >> 10) + 128] ^ dword_244EB6488[((v39 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v39 >> 26) + 384] ^ dword_244EB6488[(v40 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v40 >> 10) + 192] ^ dword_244EB6488[((v40 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v40 >> 26) + 448] ^ v35;
    unsigned int v42 = v41 ^ a2[14];
    HIDWORD(v22) = v41 ^ a2[15];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v43 = v22 >> 4;
    int v44 = dword_244EB6488[v42 >> 2] ^ dword_244EB6488[((unsigned __int16)v42 >> 10) + 128] ^ dword_244EB6488[((v42 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v42 >> 26) + 384] ^ dword_244EB6488[(v43 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v43 >> 10) + 192] ^ dword_244EB6488[((v43 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v43 >> 26) + 448] ^ v38;
    unsigned int v45 = v44 ^ a2[16];
    HIDWORD(v22) = v44 ^ a2[17];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v46 = v22 >> 4;
    int v47 = dword_244EB6488[v45 >> 2] ^ dword_244EB6488[((unsigned __int16)v45 >> 10) + 128] ^ dword_244EB6488[((v45 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v45 >> 26) + 384] ^ dword_244EB6488[(v46 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v46 >> 10) + 192] ^ dword_244EB6488[((v46 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v46 >> 26) + 448] ^ v41;
    unsigned int v48 = v47 ^ a2[18];
    HIDWORD(v22) = v47 ^ a2[19];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v49 = v22 >> 4;
    int v50 = dword_244EB6488[v48 >> 2] ^ dword_244EB6488[((unsigned __int16)v48 >> 10) + 128] ^ dword_244EB6488[((v48 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v48 >> 26) + 384] ^ dword_244EB6488[(v49 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v49 >> 10) + 192] ^ dword_244EB6488[((v49 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v49 >> 26) + 448] ^ v44;
    unsigned int v51 = v50 ^ a2[20];
    HIDWORD(v22) = v50 ^ a2[21];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v52 = v22 >> 4;
    int v53 = dword_244EB6488[v51 >> 2] ^ dword_244EB6488[((unsigned __int16)v51 >> 10) + 128] ^ dword_244EB6488[((v51 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v51 >> 26) + 384] ^ dword_244EB6488[(v52 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v52 >> 10) + 192] ^ dword_244EB6488[((v52 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v52 >> 26) + 448] ^ v47;
    unsigned int v54 = v53 ^ a2[22];
    HIDWORD(v22) = v53 ^ a2[23];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v55 = v22 >> 4;
    int v56 = dword_244EB6488[v54 >> 2] ^ dword_244EB6488[((unsigned __int16)v54 >> 10) + 128] ^ dword_244EB6488[((v54 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v54 >> 26) + 384] ^ dword_244EB6488[(v55 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v55 >> 10) + 192] ^ dword_244EB6488[((v55 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v55 >> 26) + 448] ^ v50;
    unsigned int v57 = v56 ^ a2[24];
    HIDWORD(v22) = v56 ^ a2[25];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v58 = v22 >> 4;
    int v59 = dword_244EB6488[v57 >> 2] ^ dword_244EB6488[((unsigned __int16)v57 >> 10) + 128] ^ dword_244EB6488[((v57 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v57 >> 26) + 384] ^ dword_244EB6488[(v58 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v58 >> 10) + 192] ^ dword_244EB6488[((v58 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v58 >> 26) + 448] ^ v53;
    unsigned int v60 = v59 ^ a2[26];
    HIDWORD(v22) = v59 ^ a2[27];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v61 = v22 >> 4;
    int v62 = dword_244EB6488[v60 >> 2] ^ dword_244EB6488[((unsigned __int16)v60 >> 10) + 128] ^ dword_244EB6488[((v60 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v60 >> 26) + 384] ^ dword_244EB6488[(v61 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v61 >> 10) + 192] ^ dword_244EB6488[((v61 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v61 >> 26) + 448] ^ v56;
    unsigned int v63 = v62 ^ a2[28];
    HIDWORD(v22) = v62 ^ a2[29];
    LODWORD(v22) = HIDWORD(v22);
    int v64 = dword_244EB6488[v63 >> 2] ^ dword_244EB6488[((unsigned __int16)v63 >> 10) + 128] ^ dword_244EB6488[((v63 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v63 >> 26) + 384] ^ dword_244EB6488[((v22 >> 4) >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)(v22 >> 4) >> 10) + 192] ^ dword_244EB6488[(((v22 >> 4) >> 18) & 0x3F) + 320] ^ dword_244EB6488[((v22 >> 4) >> 26) + 448] ^ v59;
    int v65 = a2[30];
    int v66 = a2[31];
  }
  else
  {
    unsigned int v67 = a2[30] ^ v17;
    HIDWORD(v69) = a2[31] ^ v17;
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v68 = v69 >> 4;
    int v70 = dword_244EB6488[v67 >> 2] ^ dword_244EB6488[((unsigned __int16)v67 >> 10) + 128] ^ dword_244EB6488[((v67 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v67 >> 26) + 384] ^ dword_244EB6488[(v68 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v68 >> 10) + 192] ^ dword_244EB6488[((v68 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v68 >> 26) + 448] ^ v19;
    unsigned int v71 = v70 ^ a2[28];
    HIDWORD(v69) = v70 ^ a2[29];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v72 = v69 >> 4;
    int v73 = dword_244EB6488[v71 >> 2] ^ dword_244EB6488[((unsigned __int16)v71 >> 10) + 128] ^ dword_244EB6488[((v71 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v71 >> 26) + 384] ^ dword_244EB6488[(v72 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v72 >> 10) + 192] ^ dword_244EB6488[((v72 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v72 >> 26) + 448] ^ v17;
    unsigned int v74 = v73 ^ a2[26];
    HIDWORD(v69) = v73 ^ a2[27];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v75 = v69 >> 4;
    int v76 = dword_244EB6488[v74 >> 2] ^ dword_244EB6488[((unsigned __int16)v74 >> 10) + 128] ^ dword_244EB6488[((v74 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v74 >> 26) + 384] ^ dword_244EB6488[(v75 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v75 >> 10) + 192] ^ dword_244EB6488[((v75 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v75 >> 26) + 448] ^ v70;
    unsigned int v77 = v76 ^ a2[24];
    HIDWORD(v69) = v76 ^ a2[25];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v78 = v69 >> 4;
    int v79 = dword_244EB6488[v77 >> 2] ^ dword_244EB6488[((unsigned __int16)v77 >> 10) + 128] ^ dword_244EB6488[((v77 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v77 >> 26) + 384] ^ dword_244EB6488[(v78 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v78 >> 10) + 192] ^ dword_244EB6488[((v78 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v78 >> 26) + 448] ^ v73;
    unsigned int v80 = v79 ^ a2[22];
    HIDWORD(v69) = v79 ^ a2[23];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v81 = v69 >> 4;
    int v82 = dword_244EB6488[v80 >> 2] ^ dword_244EB6488[((unsigned __int16)v80 >> 10) + 128] ^ dword_244EB6488[((v80 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v80 >> 26) + 384] ^ dword_244EB6488[(v81 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v81 >> 10) + 192] ^ dword_244EB6488[((v81 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v81 >> 26) + 448] ^ v76;
    unsigned int v83 = v82 ^ a2[20];
    HIDWORD(v69) = v82 ^ a2[21];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v84 = v69 >> 4;
    int v85 = dword_244EB6488[v83 >> 2] ^ dword_244EB6488[((unsigned __int16)v83 >> 10) + 128] ^ dword_244EB6488[((v83 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v83 >> 26) + 384] ^ dword_244EB6488[(v84 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v84 >> 10) + 192] ^ dword_244EB6488[((v84 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v84 >> 26) + 448] ^ v79;
    unsigned int v86 = v85 ^ a2[18];
    HIDWORD(v69) = v85 ^ a2[19];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v87 = v69 >> 4;
    int v88 = dword_244EB6488[v86 >> 2] ^ dword_244EB6488[((unsigned __int16)v86 >> 10) + 128] ^ dword_244EB6488[((v86 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v86 >> 26) + 384] ^ dword_244EB6488[(v87 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v87 >> 10) + 192] ^ dword_244EB6488[((v87 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v87 >> 26) + 448] ^ v82;
    unsigned int v89 = v88 ^ a2[16];
    HIDWORD(v69) = v88 ^ a2[17];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v90 = v69 >> 4;
    int v91 = dword_244EB6488[v89 >> 2] ^ dword_244EB6488[((unsigned __int16)v89 >> 10) + 128] ^ dword_244EB6488[((v89 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v89 >> 26) + 384] ^ dword_244EB6488[(v90 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v90 >> 10) + 192] ^ dword_244EB6488[((v90 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v90 >> 26) + 448] ^ v85;
    unsigned int v92 = v91 ^ a2[14];
    HIDWORD(v69) = v91 ^ a2[15];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v93 = v69 >> 4;
    int v94 = dword_244EB6488[v92 >> 2] ^ dword_244EB6488[((unsigned __int16)v92 >> 10) + 128] ^ dword_244EB6488[((v92 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v92 >> 26) + 384] ^ dword_244EB6488[(v93 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v93 >> 10) + 192] ^ dword_244EB6488[((v93 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v93 >> 26) + 448] ^ v88;
    unsigned int v95 = v94 ^ a2[12];
    HIDWORD(v69) = v94 ^ a2[13];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v96 = v69 >> 4;
    int v97 = dword_244EB6488[v95 >> 2] ^ dword_244EB6488[((unsigned __int16)v95 >> 10) + 128] ^ dword_244EB6488[((v95 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v95 >> 26) + 384] ^ dword_244EB6488[(v96 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v96 >> 10) + 192] ^ dword_244EB6488[((v96 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v96 >> 26) + 448] ^ v91;
    unsigned int v98 = v97 ^ a2[10];
    HIDWORD(v69) = v97 ^ a2[11];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v99 = v69 >> 4;
    int v100 = dword_244EB6488[v98 >> 2] ^ dword_244EB6488[((unsigned __int16)v98 >> 10) + 128] ^ dword_244EB6488[((v98 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v98 >> 26) + 384] ^ dword_244EB6488[(v99 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v99 >> 10) + 192] ^ dword_244EB6488[((v99 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v99 >> 26) + 448] ^ v94;
    unsigned int v101 = v100 ^ a2[8];
    HIDWORD(v69) = v100 ^ a2[9];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v102 = v69 >> 4;
    int v103 = dword_244EB6488[v101 >> 2] ^ dword_244EB6488[((unsigned __int16)v101 >> 10) + 128] ^ dword_244EB6488[((v101 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v101 >> 26) + 384] ^ dword_244EB6488[(v102 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v102 >> 10) + 192] ^ dword_244EB6488[((v102 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v102 >> 26) + 448] ^ v97;
    unsigned int v104 = v103 ^ a2[6];
    HIDWORD(v69) = v103 ^ a2[7];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v105 = v69 >> 4;
    int v106 = dword_244EB6488[v104 >> 2] ^ dword_244EB6488[((unsigned __int16)v104 >> 10) + 128] ^ dword_244EB6488[((v104 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v104 >> 26) + 384] ^ dword_244EB6488[(v105 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v105 >> 10) + 192] ^ dword_244EB6488[((v105 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v105 >> 26) + 448] ^ v100;
    unsigned int v107 = v106 ^ a2[4];
    HIDWORD(v69) = v106 ^ a2[5];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v108 = v69 >> 4;
    int v62 = dword_244EB6488[v107 >> 2] ^ dword_244EB6488[((unsigned __int16)v107 >> 10) + 128] ^ dword_244EB6488[((v107 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v107 >> 26) + 384] ^ dword_244EB6488[(v108 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v108 >> 10) + 192] ^ dword_244EB6488[((v108 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v108 >> 26) + 448] ^ v103;
    unsigned int v109 = v62 ^ a2[2];
    HIDWORD(v69) = v62 ^ a2[3];
    LODWORD(v69) = HIDWORD(v69);
    int v64 = dword_244EB6488[v109 >> 2] ^ dword_244EB6488[((unsigned __int16)v109 >> 10) + 128] ^ dword_244EB6488[((v109 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v109 >> 26) + 384] ^ dword_244EB6488[((v69 >> 4) >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)(v69 >> 4) >> 10) + 192] ^ dword_244EB6488[(((v69 >> 4) >> 18) & 0x3F) + 320] ^ dword_244EB6488[((v69 >> 4) >> 26) + 448] ^ v106;
    int v65 = *a2;
    int v66 = a2[1];
  }
  unsigned int v110 = v64 ^ v65;
  HIDWORD(v112) = v64 ^ v66;
  LODWORD(v112) = v64 ^ v66;
  unsigned int v111 = v112 >> 4;
  HIDWORD(v112) = dword_244EB6488[v110 >> 2] ^ dword_244EB6488[((unsigned __int16)v110 >> 10) + 128] ^ dword_244EB6488[((v110 >> 18) & 0x3F) + 256] ^ dword_244EB6488[(v110 >> 26) + 384] ^ dword_244EB6488[(v111 >> 2) + 64] ^ dword_244EB6488[((unsigned __int16)v111 >> 10) + 192] ^ dword_244EB6488[((v111 >> 18) & 0x3F) + 320] ^ dword_244EB6488[(v111 >> 26) + 448] ^ v62;
  LODWORD(v112) = HIDWORD(v112);
  unsigned int v113 = (((v112 >> 3) >> 1) ^ __ROR4__(v64, 3)) & 0x55555555;
  unsigned int v114 = v113 ^ __ROR4__(v64, 3);
  int v115 = (2 * v113) ^ __ROR4__(HIDWORD(v112), 3);
  int v116 = (v115 ^ (v114 >> 8)) & 0xFF00FF;
  unsigned int v117 = v116 ^ v115;
  int v118 = v114 ^ (v116 << 8);
  int v119 = (v118 ^ (v117 >> 2)) & 0x33333333;
  unsigned int v120 = v119 ^ v118;
  int v121 = v117 ^ (4 * v119);
  int v122 = (unsigned __int16)v121 ^ HIWORD(v120);
  unsigned int v123 = v122 ^ v121;
  int v124 = v120 ^ (v122 << 16);
  int v125 = (v124 ^ (v123 >> 4)) & 0xF0F0F0F;
  *double result = v125 ^ v124;
  result[1] = v123 ^ (16 * v125);
  return result;
}

int *sub_244D06400(int *result, unsigned int *a2, unint64_t a3, int *a4, uint64_t a5, int a6)
{
  unint64_t v8 = a3;
  int v10 = result;
  uint64_t v44 = *MEMORY[0x263EF8340];
  unsigned int v11 = *(_DWORD *)a5;
  unsigned int v12 = *(_DWORD *)(a5 + 4);
  if (a6)
  {
    if (a3 >= 8)
    {
      do
      {
        int v13 = a2;
        unsigned int v14 = *v10;
        int v15 = v10[1];
        v10 += 2;
        unsigned int v42 = v14 ^ v11;
        unsigned int v43 = v15 ^ v12;
        double result = sub_244D0551C((int *)&v42, a4, 1);
        unsigned int v11 = v42;
        unsigned int v12 = v43;
        a2 += 2;
        *int v13 = v42;
        v13[1] = v12;
        v8 -= 8;
      }
      while (v8 > 7);
    }
    if (v8)
    {
      int v16 = 0;
      int v17 = (char *)v10 + v8;
      int v18 = 0;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_12;
        case 2uLL:
          goto LABEL_11;
        case 3uLL:
          goto LABEL_10;
        case 4uLL:
          goto LABEL_9;
        case 5uLL:
          goto LABEL_8;
        case 6uLL:
          goto LABEL_7;
        case 7uLL:
          int v19 = *--v17;
          int v16 = v19 << 16;
LABEL_7:
          int v20 = *--v17;
          v16 |= v20 << 8;
LABEL_8:
          int v21 = *--v17;
          v16 |= v21;
LABEL_9:
          int v18 = v16;
          int v22 = *--v17;
          int v16 = v22 << 24;
LABEL_10:
          int v23 = *--v17;
          v16 |= v23 << 16;
LABEL_11:
          int v24 = *--v17;
          v16 |= v24 << 8;
LABEL_12:
          v16 |= *(v17 - 1);
          break;
        default:
          int v18 = 0;
          break;
      }
      unsigned int v42 = v16 ^ v11;
      unsigned int v43 = v18 ^ v12;
      double result = sub_244D0551C((int *)&v42, a4, 1);
      LOBYTE(v11) = v42;
      unsigned int v12 = v43;
      unsigned int v25 = v42 >> 8;
      unsigned int v26 = HIWORD(v42);
      unsigned int v27 = HIBYTE(v42);
      unsigned int v28 = v43 >> 8;
      unsigned int v29 = HIWORD(v43);
      unsigned int v30 = HIBYTE(v43);
      *a2 = v42;
      a2[1] = v12;
    }
    else
    {
      unsigned int v25 = v11 >> 8;
      unsigned int v26 = HIWORD(v11);
      unsigned int v27 = HIBYTE(v11);
      unsigned int v28 = v12 >> 8;
      unsigned int v29 = HIWORD(v12);
      unsigned int v30 = HIBYTE(v12);
    }
    *(unsigned char *)a5 = v11;
    *(unsigned char *)(a5 + 1) = v25;
    *(unsigned char *)(a5 + 2) = v26;
    *(unsigned char *)(a5 + 3) = v27;
    *(unsigned char *)(a5 + 4) = v12;
    *(unsigned char *)(a5 + 5) = v28;
    *(unsigned char *)(a5 + 6) = v29;
  }
  else
  {
    if (a3 >= 8)
    {
      do
      {
        unsigned int v31 = a2;
        unsigned int v32 = v11;
        unsigned int v33 = v12;
        unsigned int v11 = *v10;
        unsigned int v12 = v10[1];
        unsigned int v34 = v10 + 2;
        unsigned int v42 = *v10;
        unsigned int v43 = v12;
        double result = sub_244D0551C((int *)&v42, a4, 0);
        __int16 v35 = HIWORD(v42) ^ HIWORD(v32);
        int v36 = v43 ^ v33;
        *(_WORD *)unsigned int v31 = v42 ^ v32;
        *((_WORD *)v31 + 1) = v35;
        v31[1] = v36;
        a2 = v31 + 2;
        v8 -= 8;
        v10 += 2;
      }
      while (v8 > 7);
      int v10 = v34;
    }
    if (v8)
    {
      unsigned int v38 = *v10;
      unsigned int v37 = v10[1];
      unsigned int v42 = v38;
      unsigned int v43 = v37;
      double result = sub_244D0551C((int *)&v42, a4, 0);
      int v39 = v42 ^ v11;
      int v40 = v43 ^ v12;
      int v41 = (char *)a2 + v8;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_25;
        case 2uLL:
          goto LABEL_24;
        case 3uLL:
          goto LABEL_23;
        case 4uLL:
          goto LABEL_22;
        case 5uLL:
          goto LABEL_21;
        case 6uLL:
          goto LABEL_20;
        case 7uLL:
          *--int v41 = BYTE2(v40);
LABEL_20:
          *--int v41 = BYTE1(v40);
LABEL_21:
          *--int v41 = v40;
LABEL_22:
          *--int v41 = HIBYTE(v39);
LABEL_23:
          *--int v41 = BYTE2(v39);
LABEL_24:
          *--int v41 = BYTE1(v39);
LABEL_25:
          *(v41 - 1) = v39;
          break;
        default:
          break;
      }
    }
    else
    {
      unsigned int v38 = v11;
      unsigned int v37 = v12;
    }
    *(_DWORD *)a5 = v38;
    *(_WORD *)(a5 + 4) = v37;
    unsigned int v30 = HIBYTE(v37);
    *(unsigned char *)(a5 + 6) = BYTE2(v37);
  }
  *(unsigned char *)(a5 + 7) = v30;
  return result;
}

double sub_244D06758(void *a1, void *a2, int *a3, int *a4, int *a5, int a6)
{
  v8[1] = *MEMORY[0x263EF8340];
  v8[0] = *a1;
  if (a6) {
    sub_244D04474((int *)v8, a3, a4, a5);
  }
  else {
    sub_244D05398((int *)v8, a3, a4, a5);
  }
  double result = *(double *)v8;
  *a2 = v8[0];
  return result;
}

int *sub_244D067E0(int *result, uint64_t a2, unint64_t a3, int *a4, int *a5, int *a6, _DWORD *a7, int a8)
{
  unint64_t v8 = a7;
  int v9 = a6;
  int v10 = a5;
  unsigned int v11 = a4;
  unint64_t v12 = a3;
  unsigned int v14 = result;
  uint64_t v51 = *MEMORY[0x263EF8340];
  unsigned int v16 = *a7;
  unsigned int v15 = a7[1];
  if (a8)
  {
    if (a3 >= 8)
    {
      do
      {
        int v17 = *v14;
        int v18 = v14[1];
        v14 += 2;
        unsigned int v49 = v17 ^ v16;
        int v50 = v18 ^ v15;
        double result = sub_244D04474((int *)&v49, v11, v10, v9);
        unsigned int v16 = v49;
        unsigned int v15 = v50;
        *(_WORD *)a2 = v49;
        *(unsigned char *)(a2 + 2) = BYTE2(v16);
        *(unsigned char *)(a2 + 3) = HIBYTE(v16);
        *(_DWORD *)(a2 + 4) = v15;
        a2 += 8;
        v12 -= 8;
      }
      while (v12 > 7);
    }
    if (v12)
    {
      int v19 = 0;
      int v20 = (char *)v14 + v12;
      int v21 = 0;
      switch(v12)
      {
        case 1uLL:
          goto LABEL_12;
        case 2uLL:
          goto LABEL_11;
        case 3uLL:
          goto LABEL_10;
        case 4uLL:
          goto LABEL_9;
        case 5uLL:
          goto LABEL_8;
        case 6uLL:
          goto LABEL_7;
        case 7uLL:
          int v22 = *--v20;
          int v19 = v22 << 16;
LABEL_7:
          int v23 = *--v20;
          v19 |= v23 << 8;
LABEL_8:
          int v24 = *--v20;
          v19 |= v24;
LABEL_9:
          int v21 = v19;
          int v25 = *--v20;
          int v19 = v25 << 24;
LABEL_10:
          int v26 = *--v20;
          v19 |= v26 << 16;
LABEL_11:
          int v27 = *--v20;
          v19 |= v27 << 8;
LABEL_12:
          v19 |= *(v20 - 1);
          break;
        default:
          int v21 = 0;
          break;
      }
      unsigned int v49 = v19 ^ v16;
      int v50 = v21 ^ v15;
      double result = sub_244D04474((int *)&v49, v11, v10, v9);
      unsigned int v16 = v49;
      unsigned int v15 = v50;
      *(unsigned char *)a2 = v49;
      unsigned int v28 = v16 >> 8;
      *(unsigned char *)(a2 + 1) = BYTE1(v16);
      unsigned int v29 = HIWORD(v16);
      *(unsigned char *)(a2 + 2) = BYTE2(v16);
      unsigned int v30 = HIBYTE(v16);
      *(unsigned char *)(a2 + 3) = HIBYTE(v16);
      *(_DWORD *)(a2 + 4) = v15;
      unsigned int v31 = v15 >> 8;
      unsigned int v32 = HIWORD(v15);
      unsigned int v33 = HIBYTE(v15);
    }
    else
    {
      unsigned int v28 = v16 >> 8;
      unsigned int v29 = HIWORD(v16);
      unsigned int v30 = HIBYTE(v16);
      unsigned int v31 = v15 >> 8;
      unsigned int v32 = HIWORD(v15);
      unsigned int v33 = HIBYTE(v15);
    }
    *unint64_t v8 = v16;
    v8[1] = v28;
    void v8[2] = v29;
    v8[3] = v30;
    v8[4] = v15;
    unint64_t v8[5] = v31;
    v8[6] = v32;
  }
  else
  {
    if (a3 >= 8)
    {
      do
      {
        uint64_t v36 = a2;
        unsigned int v37 = v16;
        unsigned int v38 = v15;
        unsigned int v16 = *v14;
        unsigned int v15 = v14[1];
        int v39 = v14 + 2;
        unsigned int v49 = *v14;
        int v50 = v15;
        double result = sub_244D05398((int *)&v49, a4, a5, a6);
        __int16 v40 = HIWORD(v49) ^ HIWORD(v37);
        int v41 = v50 ^ v38;
        *(_WORD *)uint64_t v36 = v49 ^ v37;
        *(_WORD *)(v36 + 2) = v40;
        *(_DWORD *)(v36 + 4) = v41;
        a2 = v36 + 8;
        v12 -= 8;
        v14 += 2;
      }
      while (v12 > 7);
      unsigned int v14 = v39;
      int v9 = a6;
      int v10 = a5;
      unint64_t v8 = a7;
      unsigned int v11 = a4;
    }
    if (v12)
    {
      int v43 = *v14;
      unsigned int v42 = v14[1];
      unsigned int v49 = v43;
      int v50 = v42;
      double result = sub_244D05398((int *)&v49, v11, v10, v9);
      int v44 = v49 ^ v16;
      int v45 = v50 ^ v15;
      uint64_t v46 = a2 + v12;
      switch(v12)
      {
        case 1uLL:
          goto LABEL_25;
        case 2uLL:
          goto LABEL_24;
        case 3uLL:
          goto LABEL_23;
        case 4uLL:
          goto LABEL_22;
        case 5uLL:
          goto LABEL_21;
        case 6uLL:
          goto LABEL_20;
        case 7uLL:
          *(unsigned char *)--uint64_t v46 = BYTE2(v45);
LABEL_20:
          *(unsigned char *)--uint64_t v46 = BYTE1(v45);
LABEL_21:
          *(unsigned char *)--uint64_t v46 = v45;
LABEL_22:
          *(unsigned char *)--uint64_t v46 = HIBYTE(v44);
LABEL_23:
          *(unsigned char *)--uint64_t v46 = BYTE2(v44);
LABEL_24:
          *(unsigned char *)--uint64_t v46 = BYTE1(v44);
LABEL_25:
          *(unsigned char *)(v46 - 1) = v44;
          break;
        default:
          break;
      }
    }
    else
    {
      int v43 = v16;
      unsigned int v42 = v15;
    }
    *(_DWORD *)unint64_t v8 = v43;
    *((_WORD *)v8 + 2) = v42;
    unsigned int v33 = HIBYTE(v42);
    v8[6] = BYTE2(v42);
  }
  v8[7] = v33;
  return result;
}

int *sub_244D06BB4(int *a1, uint64_t a2, unint64_t a3, int *a4, int *a5, _DWORD *a6, int a7)
{
  return sub_244D067E0(a1, a2, a3, a4, a5, a4, a6, a7);
}

void *sub_244D06BC4(long long *a1)
{
  uint64_t v2 = sub_244D24C2C();
  if (v2)
  {
    if ((long long v7 = 0uLL, !sub_244CFCD34(a1, &v7, 536870928))
      || (v3 = sub_244D16670(), (void *v2 = v3) == 0)
      || !sub_244CFA034(&v7, v3)
      || (int v4 = sub_244D16670(), (v2[1] = v4) == 0)
      || !sub_244CFA034(&v7, v4)
      || (unint64_t v6 = 0, *((void *)&v7 + 1))
      && (!sub_244CFCEF4(&v7, &v6) || HIDWORD(v6) || (*((_DWORD *)v2 + 10) = v6, *((void *)&v7 + 1)))
      || !sub_244D24680(v2))
    {
      sub_244D0B884(5, 0, 104, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dh_extra/dh_asn1.c", 120);
      sub_244D24C6C((uint64_t)v2);
      return 0;
    }
  }
  return v2;
}

uint64_t sub_244D06CB8(uint64_t *a1, uint64_t a2)
{
  memset(v6, 0, sizeof(v6));
  if (sub_244CFB808(a1, (uint64_t)v6, 0x20000010u))
  {
    if (sub_244D06D6C((uint64_t *)v6, *(uint64_t **)a2))
    {
      if (sub_244D06D6C((uint64_t *)v6, *(uint64_t **)(a2 + 8)))
      {
        unint64_t v4 = *(unsigned int *)(a2 + 40);
        if (!v4 || sub_244CFBDDC((uint64_t)v6, v4))
        {
          if (sub_244CFB540(a1)) {
            return 1;
          }
        }
      }
    }
  }
  sub_244D0B884(5, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dh_extra/dh_asn1.c", 133);
  return 0;
}

uint64_t sub_244D06D6C(uint64_t *a1, uint64_t *a2)
{
  if (a2)
  {
    return sub_244CFA0E0(a1, a2);
  }
  else
  {
    sub_244D0B884(5, a2, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dh_extra/dh_asn1.c", 81);
    return 0;
  }
}

void *sub_244D06DB0(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  unsigned int v5 = sub_244D06BC4(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D24C6C(*a1);
      *a1 = (uint64_t)v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D06E24(uint64_t a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D06CB8((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D06E98(int a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = 0;
  while (dword_26F9548A0[v1] != a1)
  {
    v1 += 8;
    if (v1 == 144) {
      return 0;
    }
  }
  return (*(uint64_t (**)(void))&dword_26F9548A0[v1 + 2])();
}

uint64_t sub_244D06ED4(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 0;
    while (dword_26F9548A0[v2] != v1)
    {
      v2 += 8;
      if (v2 == 144) {
        return 0;
      }
    }
    unsigned int v5 = *(uint64_t (**)(void))&dword_26F9548A0[v2 + 2];
    return v5();
  }
  else
  {
    v6[0] = sub_244D44988(a1);
    v6[1] = sub_244D44994(a1);
    return sub_244D06F74((uint64_t)v6);
  }
}

uint64_t sub_244D06F74(uint64_t a1)
{
  uint64_t v2 = 0;
  size_t v3 = *(void *)(a1 + 8);
  while (v3 != byte_244EB6C88[v2 + 9] || memcmp(*(const void **)a1, &byte_244EB6C88[v2], v3))
  {
    v2 += 16;
    if (v2 == 112) {
      return 0;
    }
  }
  uint64_t v5 = 0;
  while (dword_26F9548A0[v5] != *(_DWORD *)&byte_244EB6C88[v2 + 12])
  {
    v5 += 8;
    if (v5 == 144) {
      return 0;
    }
  }
  unint64_t v6 = *(uint64_t (**)(void))&dword_26F9548A0[v5 + 2];

  return v6();
}

uint64_t sub_244D07034(long long *a1)
{
  long long v7 = 0uLL;
  v6[0] = 0;
  v6[1] = 0;
  if (!sub_244CFCD34(a1, &v7, 536870928) || !sub_244CFCD34(&v7, v6, 6))
  {
    __int16 v2 = 172;
    goto LABEL_10;
  }
  uint64_t v1 = sub_244D06F74((uint64_t)v6);
  if (!v1)
  {
    sub_244D0B884(29, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/digest_extra/digest_extra.c", 178);
    return v1;
  }
  if (*((void *)&v7 + 1))
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    if (!sub_244CFCD34(&v7, &v4, 5) || v5 || *((void *)&v7 + 1))
    {
      __int16 v2 = 191;
LABEL_10:
      sub_244D0B884(29, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/digest_extra/digest_extra.c", v2);
      return 0;
    }
  }
  return v1;
}

uint64_t sub_244D07128(uint64_t *a1, unsigned int *a2)
{
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t result = sub_244CFB808(a1, (uint64_t)v9, 0x20000010u);
  if (result)
  {
    uint64_t result = sub_244CFB808((uint64_t *)v9, (uint64_t)v8, 6u);
    if (result)
    {
      int v5 = sub_244CF48D8(a2);
      uint64_t v6 = 0;
      while (v5 != *(_DWORD *)&byte_244EB6C88[v6 + 12])
      {
        v6 += 16;
        if (v6 == 112)
        {
          sub_244D0B884(29, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/digest_extra/digest_extra.c", 219);
          return 0;
        }
      }
      uint64_t result = sub_244CFBA40((uint64_t)v8, &byte_244EB6C88[v6], byte_244EB6C88[v6 + 9]);
      if (result)
      {
        uint64_t result = sub_244CFB808((uint64_t *)v9, (uint64_t)v7, 5u);
        if (result) {
          return sub_244CFB540(a1) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_244D0721C(char *__s2)
{
  uint64_t v2 = 6u;
  while (1)
  {
    size_t v3 = *(const char **)&dword_26F9548A0[v2];
    if (!strcmp(*(const char **)&dword_26F9548A0[v2 - 2], __s2) || v2 != 94 && !strcmp(v3, __s2)) {
      break;
    }
    v2 += 8;
    if (v2 == 150) {
      return 0;
    }
  }
  int v5 = *(uint64_t (**)(void))&dword_26F9548A0[v2 - 4];

  return v5();
}

void *sub_244D072BC()
{
  return &unk_26F954AE0;
}

double sub_244D072C8(uint64_t a1)
{
  return sub_244CF99F4(*(void *)(a1 + 8));
}

void *sub_244D072D0(uint64_t a1, char *a2, unint64_t a3)
{
  return sub_244CF9A48(*(void **)(a1 + 8), a2, a3);
}

double sub_244D072D8(uint64_t a1, _OWORD *a2)
{
  *(void *)&double result = sub_244CF9F20(a2, *(void *)(a1 + 8)).n128_u64[0];
  return result;
}

void *sub_244D072E8()
{
  v0 = sub_244D44058(0x110uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    *((_DWORD *)v0 + 64) = 1;
    sub_244D4BD2C((pthread_rwlock_t *)(v0 + 5));
    sub_244D1389C(v1 + 33);
  }
  return v1;
}

void sub_244D07330(uint64_t a1)
{
  if (a1 && sub_244D49A14((unsigned int *)(a1 + 256)))
  {
    sub_244D138A4((uint64_t)&unk_268EBD440, a1, (uint64_t *)(a1 + 264));
    sub_244D16710(*(void **)a1);
    sub_244D16710(*(void **)(a1 + 8));
    sub_244D16710(*(void **)(a1 + 16));
    sub_244D16710(*(void **)(a1 + 24));
    sub_244D16710(*(void **)(a1 + 32));
    sub_244D1A288(*(void ***)(a1 + 240));
    sub_244D1A288(*(void ***)(a1 + 248));
    j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 40));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D073D4(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D073F4(uint64_t **a1)
{
  return sub_244D168EC(*a1);
}

uint64_t sub_244D073FC(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_244D07404(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_244D0740C(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_244D07414(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_244D0741C(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(result + 24);
  }
  if (a3) {
    *a3 = *(void *)(result + 32);
  }
  return result;
}

void *sub_244D07438(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = *result;
  }
  if (a3) {
    *a3 = result[1];
  }
  if (a4) {
    *a4 = result[2];
  }
  return result;
}

uint64_t sub_244D07460(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a1 + 24);
  if (!(a2 | v4)) {
    return 0;
  }
  if (a2)
  {
    sub_244D166B0((void **)v4);
    *(void *)(a1 + 24) = a2;
  }
  if (a3)
  {
    sub_244D166B0(*(void ***)(a1 + 32));
    *(void *)(a1 + 32) = a3;
  }
  return 1;
}

uint64_t sub_244D074C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(void *)a1;
  if (!(a2 | v5) || !(a3 | *(void *)(a1 + 8)) || !(a4 | *(void *)(a1 + 16))) {
    return 0;
  }
  if (a2)
  {
    sub_244D166B0((void **)v5);
    *(void *)a1 = a2;
  }
  if (a3)
  {
    sub_244D166B0(*(void ***)(a1 + 8));
    *(void *)(a1 + 8) = a3;
  }
  if (a4)
  {
    sub_244D166B0(*(void ***)(a1 + 16));
    *(void *)(a1 + 16) = a4;
  }
  sub_244D1A288(*(void ***)(a1 + 240));
  *(void *)(a1 + 240) = 0;
  sub_244D1A288(*(void ***)(a1 + 248));
  *(void *)(a1 + 248) = 0;
  return 1;
}

BOOL sub_244D0756C(void ***a1, unsigned int a2, void **a3, unint64_t a4, _DWORD *a5, void *a6, uint64_t a7)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  if (a2 < 0x2711)
  {
    unsigned int v12 = a2;
    if (a2 < 0x800) {
      unsigned int v14 = sub_244D25B18();
    }
    else {
      unsigned int v14 = sub_244D25C38();
    }
    uint64_t v15 = (uint64_t)v14;
    unint64_t v16 = sub_244CF48E0((uint64_t)v14);
    unint64_t v17 = v16;
    if (v12 <= 0x200) {
      unsigned int v12 = 512;
    }
    if (a3)
    {
      if (v16 > a4) {
        return 0;
      }
      if (v16) {
        __memcpy_chk();
      }
    }
    sub_244D174D4();
    if (v19)
    {
      int v20 = v19;
      unsigned int v55 = a1;
      sub_244D1756C(v19);
      int v21 = sub_244D17610((uint64_t)v20);
      int v56 = sub_244D17610((uint64_t)v20);
      int v22 = sub_244D17610((uint64_t)v20);
      unsigned int v63 = sub_244D17610((uint64_t)v20);
      unsigned int v60 = sub_244D17610((uint64_t)v20);
      int v59 = sub_244D17610((uint64_t)v20);
      unsigned int v61 = sub_244D17610((uint64_t)v20);
      int v23 = sub_244D17610((uint64_t)v20);
      if (v23
        && (uint64_t v62 = a7,
            uint64_t v24 = (uint64_t)v23,
            int v25 = sub_244D16818(),
            unsigned int v26 = ((v12 + 63) & 0xFFFFFFC0) - 1,
            uint64_t v54 = v24,
            sub_244D17CA4(v24, v25, v26)))
      {
        uint64_t v27 = 0;
        uint64_t v28 = v62;
        while (1)
        {
LABEL_17:
          if (!sub_244D1F340(v28, 0, v27)) {
            goto LABEL_73;
          }
          BOOL v57 = a3 == 0;
          if (!a3 && !sub_244D20964(v67, v17)) {
            goto LABEL_73;
          }
          if (v17)
          {
            __memcpy_chk();
            __memcpy_chk();
            unint64_t v29 = v17;
            do
            {
              __int16 v30 = v64[v29 + 31]++ + 1;
              if ((v30 & 0x100) == 0) {
                break;
              }
              unint64_t v31 = v29 - 2;
              --v29;
            }
            while (v31 < v17);
          }
          if (!sub_244D25474((uint64_t)v67, v17, (uint64_t)v66, 0, v15)
            || !sub_244D25474((uint64_t)v65, v17, (uint64_t)v64, 0, v15))
          {
            goto LABEL_73;
          }
          if (v17)
          {
            unsigned int v32 = v66;
            unsigned int v33 = v64;
            unint64_t v34 = v17;
            do
            {
              char v35 = *v33++;
              *v32++ ^= v35;
              --v34;
            }
            while (v34);
          }
          v66[0] |= 0x80u;
          v66[v17 - 1] |= 1u;
          if (!sub_244D16D20(v66, v17, v63)) {
            goto LABEL_73;
          }
          uint64_t v27 = (v27 + 1);
          uint64_t v36 = v62;
          int v37 = sub_244D1F914((uint64_t)v63, 50, (uint64_t)v20, v57, v62);
          if (v37 > 0) {
            break;
          }
          uint64_t v28 = v62;
          a3 = 0;
          if (v37) {
            goto LABEL_74;
          }
        }
        if (!sub_244D1F340(v62, 2, 0) || !sub_244D1F340(v62, 3, 0)) {
          goto LABEL_73;
        }
        uint64_t v38 = 0;
        while (2)
        {
          if (!v38 || (uint64_t v39 = v36, v40 = v38, v41 = sub_244D1F340(v39, 0, v38), LODWORD(v38) = v40, v41))
          {
            int v58 = v38;
            sub_244D1697C((uint64_t)v22);
            int v42 = 0;
            do
            {
              unint64_t v43 = v17 - 1;
              do
              {
                if (v43 >= v17) {
                  break;
                }
                __int16 v44 = v65[v43--]++ + 1;
              }
              while ((v44 & 0x100) != 0);
              if (!sub_244D25474((uint64_t)v65, v17, (uint64_t)v66, 0, v15)
                || !sub_244D16D20(v66, v17, v21)
                || !sub_244D17CA4((uint64_t)v21, (uint64_t *)v21, 8 * (int)v17 * v42)
                || !sub_244D15B90((uint64_t)v22, (uint64_t)v22, (uint64_t)v21))
              {
                goto LABEL_73;
              }
            }
            while (v42++ != v26 / 0xA0);
            if (!sub_244D20FD0((uint64_t)v22, v26)) {
              goto LABEL_73;
            }
            if (!sub_244D16764((void **)v60, (uint64_t)v22)) {
              goto LABEL_73;
            }
            if (!sub_244D15B90((uint64_t)v60, (uint64_t)v60, v54)) {
              goto LABEL_73;
            }
            if (!sub_244D18E1C((uint64_t)v21, (uint64_t *)v63)) {
              goto LABEL_73;
            }
            if (!sub_244D17728(0, (uint64_t)v59, (uint64_t)v60, (uint64_t)v21, (uint64_t)v20)) {
              goto LABEL_73;
            }
            uint64_t v46 = sub_244D16818();
            if (!sub_244D16310((uint64_t)v21, (uint64_t)v59, (uint64_t)v46)
              || !sub_244D16310((uint64_t)v61, (uint64_t)v60, (uint64_t)v21))
            {
              goto LABEL_73;
            }
            uint64_t v27 = v27;
            uint64_t v36 = v62;
            if ((sub_244D17194((uint64_t)v61, v54) & 0x80000000) != 0)
            {
LABEL_56:
              uint64_t v38 = (v58 + 1);
              if (v58 != 4095) {
                continue;
              }
              uint64_t v28 = v62;
              a3 = 0;
              goto LABEL_17;
            }
            int v47 = sub_244D1F914((uint64_t)v61, 50, (uint64_t)v20, 1, v62);
            if (v47 <= 0)
            {
              if (v47) {
                goto LABEL_73;
              }
              goto LABEL_56;
            }
            if (!sub_244D1F340(v62, 2, 1)) {
              goto LABEL_73;
            }
            unsigned int v48 = sub_244D16818();
            if (!sub_244D16310(v54, (uint64_t)v61, (uint64_t)v48)
              || !sub_244D17728(v21, 0, v54, (uint64_t)v63, (uint64_t)v20))
            {
              goto LABEL_73;
            }
            a3 = sub_244D1B1E0((uint64_t)v61, (uint64_t)v20);
            if (!a3
              || !sub_244D16130(v54, 2)
              || !sub_244D19BB4((uint64_t)v56, v54, (uint64_t)v21, (uint64_t)v61, (uint64_t)v20, (uint64_t)a3))
            {
              goto LABEL_74;
            }
            unsigned int v49 = 2;
            while (sub_244D172C8((unsigned int *)v56))
            {
              int v50 = sub_244D16818();
              if (sub_244D15B90(v54, v54, (uint64_t)v50))
              {
                ++v49;
                if (sub_244D19BB4((uint64_t)v56, v54, (uint64_t)v21, (uint64_t)v61, (uint64_t)v20, (uint64_t)a3))continue; {
              }
                }
              goto LABEL_74;
            }
            int v52 = sub_244D1F340(v62, 3, 1);
            BOOL v18 = v52 != 0;
            if (v52)
            {
              sub_244D166B0((void **)*v55);
              sub_244D166B0((void **)v55[1]);
              sub_244D166B0((void **)v55[2]);
              *unsigned int v55 = sub_244D16714((uint64_t)v61);
              v55[1] = sub_244D16714((uint64_t)v63);
              int v53 = sub_244D16714((uint64_t)v56);
              _OWORD v55[2] = v53;
              if (!*v55) {
                goto LABEL_74;
              }
              BOOL v18 = 0;
              if (v55[1] && v53)
              {
                if (a5) {
                  *a5 = v58;
                }
                if (a6) {
                  *a6 = v49;
                }
                BOOL v18 = 1;
              }
            }
          }
          else
          {
LABEL_73:
            a3 = 0;
LABEL_74:
            BOOL v18 = 0;
          }
          break;
        }
      }
      else
      {
        BOOL v18 = 0;
        a3 = 0;
      }
      sub_244D17704((uint64_t)v20);
      sub_244D17500(v20);
    }
    else
    {
      BOOL v18 = 0;
      a3 = 0;
    }
    sub_244D1A288(a3);
    return v18;
  }
  sub_244D0B884(10, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa.c", 212);
  return 0;
}

void *sub_244D07C68(uint64_t *a1)
{
  uint64_t v2 = sub_244D072E8();
  if (v2)
  {
    void *v2 = sub_244D16714(*a1);
    v2[1] = sub_244D16714(a1[1]);
    size_t v3 = sub_244D16714(a1[2]);
    _OWORD v2[2] = v3;
    if (!*v2 || !v2[1] || !v3)
    {
      sub_244D07330((uint64_t)v2);
      return 0;
    }
  }
  return v2;
}

uint64_t sub_244D07CDC(uint64_t a1)
{
  if (!sub_244D088CC((uint64_t *)a1)) {
    return 0;
  }
  sub_244D174D4();
  size_t v3 = v2;
  if (v2)
  {
    unint64_t v4 = *(void **)(a1 + 32);
    if ((v4 || (unint64_t v4 = sub_244D16670()) != 0) && sub_244D1C18C((uint64_t)v4, 1uLL, *(void *)(a1 + 8)))
    {
      unint64_t v5 = *(void **)(a1 + 24);
      if ((v5 || (unint64_t v5 = sub_244D16670()) != 0)
        && sub_244D1E430((void *)(a1 + 240), (pthread_rwlock_t *)(a1 + 40), *(void *)a1, (uint64_t)v3)
        && sub_244D1A91C((uint64_t)v5, *(void *)(a1 + 16), (uint64_t)v4, *(void *)a1, (uint64_t)v3, *(void *)(a1 + 240)))
      {
        *(void *)(a1 + 24) = v5;
        *(void *)(a1 + 32) = v4;
        uint64_t v6 = 1;
      }
      else
      {
        uint64_t v6 = 0;
      }
    }
    else
    {
      uint64_t v6 = 0;
      unint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v5 = 0;
    unint64_t v4 = 0;
  }
  if (!*(void *)(a1 + 24)) {
    sub_244D166B0((void **)v5);
  }
  if (!*(void *)(a1 + 32)) {
    sub_244D166B0((void **)v4);
  }
  sub_244D17500(v3);
  return v6;
}

void *sub_244D07DF4()
{
  return sub_244D44058(0x10uLL);
}

void sub_244D07DFC(void *a1)
{
  if (a1)
  {
    sub_244D166B0((void **)*a1);
    sub_244D166B0((void **)a1[1]);
    sub_244D440EC(a1);
  }
}

void *sub_244D07E48(void *result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *result;
  }
  if (a3) {
    *a3 = result[1];
  }
  return result;
}

uint64_t sub_244D07E64(void ***a1, void **a2, void **a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      sub_244D166B0(*a1);
      sub_244D166B0(a1[1]);
      *a1 = a2;
      a1[1] = a3;
      return 1;
    }
  }
  return result;
}

void *sub_244D07EB8(unsigned __int8 *a1, unint64_t a2, uint64_t *a3)
{
  if (!sub_244D088CC(a3)) {
    return 0;
  }
  if (!a3[4])
  {
    sub_244D0B884(10, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa.c", 599);
    return 0;
  }
  memset(v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  sub_244D166A4(v27);
  sub_244D166A4(v26);
  uint64_t v6 = sub_244D16670();
  if (!v6)
  {
    int v9 = 0;
    int v10 = 0;
    unint64_t v8 = 0;
    goto LABEL_36;
  }
  sub_244D174D4();
  unint64_t v8 = v7;
  int v9 = 0;
  int v10 = 0;
  if (!v7)
  {
LABEL_36:
    sub_244D0B884(10, 0, 3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa.c", 688);
    sub_244D166B0(v10);
    sub_244D166B0((void **)v6);
    int v20 = 0;
    goto LABEL_37;
  }
  int v23 = (pthread_rwlock_t *)(a3 + 5);
  uint64_t v24 = a1;
  int v25 = a3 + 31;
  int v11 = 33;
  while (1)
  {
    memset(v28, 0, sizeof(v28));
    sub_244D166A4(v28);
    unsigned int v12 = sub_244D16670();
    int v13 = sub_244D16670();
    unsigned int v14 = v13;
    if (v12
      && v13
      && sub_244D1C18C((uint64_t)v28, 1uLL, a3[1])
      && sub_244D1E430(a3 + 30, v23, *a3, (uint64_t)v8)
      && sub_244D1E430(v25, v23, a3[1], (uint64_t)v8)
      && sub_244D1A91C((uint64_t)v12, a3[2], (uint64_t)v28, *a3, (uint64_t)v8, a3[30]))
    {
      if (sub_244D17728(0, (uint64_t)v12, (uint64_t)v12, a3[1], (uint64_t)v8)
        && sub_244D1C1F8((uint64_t)v14, (uint64_t)v28, a3[1], (uint64_t)v8, a3[31]))
      {
        sub_244D16710(v9);
        sub_244D16710(v10);
        char v15 = 0;
        unint64_t v16 = v14;
        uint64_t v17 = (uint64_t)v12;
        unsigned int v12 = 0;
        unsigned int v14 = 0;
        goto LABEL_17;
      }
      uint64_t v17 = (uint64_t)v10;
      unint64_t v16 = v9;
      __int16 v18 = 935;
    }
    else
    {
      uint64_t v17 = (uint64_t)v10;
      unint64_t v16 = v9;
      __int16 v18 = 920;
    }
    sub_244D0B884(10, 0, 3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa.c", v18);
    char v15 = 1;
LABEL_17:
    sub_244D16710(v28);
    sub_244D16710(v12);
    sub_244D16710(v14);
    if (v15)
    {
      int v9 = v16;
LABEL_35:
      int v10 = (void **)v17;
      goto LABEL_36;
    }
    if (a2 > sub_244D1695C((uint64_t *)a3[1])) {
      a2 = sub_244D1695C((uint64_t *)a3[1]);
    }
    int v9 = v16;
    if (!sub_244D16D20(v24, a2, v27)) {
      goto LABEL_35;
    }
    unint64_t v19 = (int)sub_244D1663C(a3[1]);
    if (!sub_244D16BB4((uint64_t)v27, v19) || !sub_244D16BB4((uint64_t)v26, v19)) {
      goto LABEL_35;
    }
    sub_244D180A8(v27[0], 0, *(unint64_t **)a3[1], v26[0], v19);
    int v10 = (void **)v17;
    if (!sub_244D08288((uint64_t)v26, a3[4], v17, a3[31], v8)
      || !sub_244D185B8((unint64_t **)v6, (uint64_t)v26, (uint64_t)v27, a3[1], (uint64_t)v8)
      || !sub_244D08288((uint64_t)v6, (uint64_t)v6, (uint64_t)v9, *v25, v8))
    {
      goto LABEL_36;
    }
    if (!sub_244D160FC(v17) && !sub_244D160FC((uint64_t)v6)) {
      break;
    }
    if (!--v11)
    {
      sub_244D0B884(10, 0, 108, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa.c", 673);
      goto LABEL_36;
    }
  }
  int v22 = sub_244D44058(0x10uLL);
  if (!v22) {
    goto LABEL_35;
  }
  int v20 = v22;
  *int v22 = v17;
  v22[1] = v6;
LABEL_37:
  sub_244D17500(v8);
  sub_244D16710(v27);
  sub_244D16710(v26);
  sub_244D16710(v9);
  return v20;
}

BOOL sub_244D08288(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  sub_244D1756C(a5);
  int v10 = sub_244D17610((uint64_t)a5);
  BOOL v12 = v10
     && (uint64_t v11 = (uint64_t)v10, sub_244D1A10C((uint64_t)v10, a2, a4, (uint64_t)a5))
     && sub_244D1A118(a1, v11, a3, a4, (uint64_t)a5) != 0;
  sub_244D17704((uint64_t)a5);
  return v12;
}

uint64_t sub_244D08328(unsigned __int8 *a1, unint64_t a2, uint64_t *a3, uint64_t a4)
{
  unsigned int v5 = 0;
  if (sub_244D0836C(&v5, a1, a2, a3, a4)) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_244D0836C(_DWORD *a1, unsigned __int8 *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  *a1 = 0;
  if (sub_244D088CC((uint64_t *)a5))
  {
    if (*(void *)(a5 + 24))
    {
      memset(v18, 0, sizeof(v18));
      memset(v17, 0, sizeof(v17));
      memset(v16, 0, sizeof(v16));
      sub_244D166A4(v18);
      sub_244D166A4(v17);
      sub_244D166A4(v16);
      sub_244D174D4();
      uint64_t v11 = v10;
      if (v10)
      {
        if (sub_244D160FC(*a4)
          || sub_244D16B50(*a4)
          || (sub_244D15C44(*a4, *(void *)(a5 + 8)) & 0x80000000) == 0
          || sub_244D160FC(a4[1])
          || sub_244D16B50(a4[1])
          || (sub_244D15C44(a4[1], *(void *)(a5 + 8)) & 0x80000000) == 0)
        {
          goto LABEL_10;
        }
        if (sub_244D1B6AC((void **)v17, a4[1], *(void *)(a5 + 8), (uint64_t)v11))
        {
          unsigned int v13 = sub_244D168EC(*(uint64_t **)(a5 + 8));
          unint64_t v14 = v13 >> 3 >= a3 ? a3 : v13 >> 3;
          if (sub_244D16D20(a2, v14, v18)
            && sub_244D1897C((uint64_t)v18, (uint64_t)v18, (uint64_t)v17, *(void *)(a5 + 8), (uint64_t)v11)
            && sub_244D1897C((uint64_t)v17, *a4, (uint64_t)v17, *(void *)(a5 + 8), (uint64_t)v11)
            && sub_244D1E430((void *)(a5 + 240), (pthread_rwlock_t *)(a5 + 40), *(void *)a5, (uint64_t)v11)&& sub_244D1B0C0((uint64_t)v16, *(void *)(a5 + 16), (uint64_t)v18, *(void *)(a5 + 24), (uint64_t)v17, *(void *)a5, (uint64_t)v11, *(void ***)(a5 + 240))&& sub_244D17728(0, (uint64_t)v18, (uint64_t)v16, *(void *)(a5 + 8), (uint64_t)v11))
          {
            *a1 = sub_244D15C44((uint64_t)v18, *a4) == 0;
LABEL_10:
            uint64_t v12 = 1;
LABEL_25:
            sub_244D17500(v11);
            sub_244D166B0(v18);
            sub_244D166B0(v17);
            sub_244D166B0(v16);
            return v12;
          }
        }
      }
      sub_244D0B884(10, 0, 3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa.c", 796);
      uint64_t v12 = 0;
      goto LABEL_25;
    }
    sub_244D0B884(10, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa.c", 718);
  }
  return 0;
}

uint64_t sub_244D085B0(uint64_t a1, unsigned __int8 *a2, unint64_t a3, void *a4, _DWORD *a5, uint64_t *a6)
{
  int v9 = a4;
  uint64_t result = (uint64_t)sub_244D07EB8(a2, a3, a6);
  if (result)
  {
    unint64_t v8 = (void *)result;
    *a5 = sub_244D092D0((uint64_t **)result, &v9);
    sub_244D07DFC(v8);
    return 1;
  }
  else
  {
    *a5 = 0;
  }
  return result;
}

uint64_t sub_244D08614(uint64_t a1, unsigned __int8 *a2, unint64_t a3, char *a4, size_t a5, uint64_t a6)
{
  unsigned int v7 = 0;
  if (sub_244D08648(&v7, a2, a3, a4, a5, a6)) {
    return v7;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_244D08648(_DWORD *a1, unsigned __int8 *a2, unint64_t a3, char *a4, size_t a5, uint64_t a6)
{
  __s2 = 0;
  uint64_t v17 = (uint64_t **)sub_244D44058(0x10uLL);
  if (!v17)
  {
LABEL_8:
    uint64_t v12 = 0;
    goto LABEL_9;
  }
  char v15 = a4;
  uint64_t v12 = 0;
  if (sub_244D0925C(&v17, &v15, a5))
  {
    if (v15 == &a4[a5])
    {
      int v13 = sub_244D092D0(v17, &__s2);
      uint64_t v12 = 0;
      if ((v13 & 0x80000000) == 0 && v13 == a5)
      {
        if (!a5 || !memcmp(a4, __s2, a5))
        {
          uint64_t v12 = sub_244D0836C(a1, a2, a3, (uint64_t *)v17, a6);
          goto LABEL_9;
        }
        goto LABEL_8;
      }
    }
  }
LABEL_9:
  sub_244D440EC(__s2);
  sub_244D07DFC(v17);
  return v12;
}

uint64_t *sub_244D0874C(uint64_t a1)
{
  uint64_t result = *(uint64_t **)(a1 + 8);
  if (result)
  {
    unsigned int v2 = sub_244D1695C(result);
    unint64_t v3 = v2;
    if (v2 >= 0x7F)
    {
      unint64_t v5 = v2 + 1;
      uint64_t v4 = 1;
      do
      {
        ++v4;
        BOOL v6 = v5 >= 0xFF;
        BOOL v7 = v5 == 255;
        v5 >>= 8;
      }
      while (!v7 && v6);
    }
    else
    {
      uint64_t v4 = 1;
    }
    uint64_t result = 0;
    unint64_t v8 = v3 + v4 + 2;
    if (v8 >= v3 && (v8 & 0x8000000000000000) == 0)
    {
      unint64_t v9 = 2 * v8;
      if (v8 >= 0x40)
      {
        uint64_t v10 = 1;
        unint64_t v11 = v9;
        do
        {
          ++v10;
          BOOL v6 = v11 >= 0xFF;
          BOOL v7 = v11 == 255;
          v11 >>= 8;
        }
        while (!v7 && v6);
      }
      else
      {
        uint64_t v10 = 1;
      }
      unint64_t v12 = (v9 | 1) + v10;
      if (v12 >= v9) {
        return (uint64_t *)v12;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_244D087F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D136D4((uint64_t)&unk_268EBD440, a1, a2, a5);
}

uint64_t sub_244D0880C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_244D137A8((unint64_t **)(a1 + 264), a2, a3);
}

unint64_t *sub_244D08814(uint64_t a1, unsigned int a2)
{
  return sub_244D13838((uint64_t *)(a1 + 264), a2);
}

void *sub_244D0881C(uint64_t *a1)
{
  if (!a1) {
    return 0;
  }
  unsigned int v2 = sub_244D24C2C();
  if (!v2) {
    goto LABEL_13;
  }
  unint64_t v3 = (uint64_t *)a1[1];
  if (v3)
  {
    *((_DWORD *)v2 + 10) = sub_244D168EC(v3);
    uint64_t v4 = sub_244D16714(a1[1]);
    _OWORD v2[2] = v4;
    if (!v4) {
      goto LABEL_13;
    }
  }
  if (*a1)
  {
    unint64_t v5 = sub_244D16714(*a1);
    void *v2 = v5;
    if (!v5) {
      goto LABEL_13;
    }
  }
  uint64_t v6 = a1[2];
  if (v6)
  {
    BOOL v7 = sub_244D16714(v6);
    v2[1] = v7;
    if (!v7) {
      goto LABEL_13;
    }
  }
  if ((uint64_t v8 = a1[3]) != 0 && (v9 = sub_244D16714(v8), (v2[3] = v9) == 0)
    || (uint64_t v10 = a1[4]) != 0 && (v11 = sub_244D16714(v10), (v2[4] = v11) == 0))
  {
LABEL_13:
    sub_244D24C6C((uint64_t)v2);
    return 0;
  }
  return v2;
}

uint64_t sub_244D088CC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (!v2 || !a1[1] || !a1[2])
  {
    int v3 = 101;
    __int16 v4 = 73;
    goto LABEL_10;
  }
  if (sub_244D16B50(v2)
    || sub_244D16B50(a1[1])
    || sub_244D160FC(*a1)
    || sub_244D160FC(a1[1])
    || !sub_244D17380(*a1)
    || !sub_244D17380(a1[1])
    || (sub_244D17194(a1[1], *a1) & 0x80000000) == 0
    || sub_244D16B50(a1[2])
    || sub_244D160FC(a1[2])
    || (sub_244D17194(a1[2], *a1) & 0x80000000) == 0)
  {
    int v3 = 107;
    __int16 v4 = 90;
LABEL_10:
    sub_244D0B884(10, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", v4);
    return 0;
  }
  int v6 = sub_244D168EC((uint64_t *)a1[1]);
  if (v6 != 160 && v6 != 224 && v6 != 256)
  {
    int v3 = 100;
    __int16 v4 = 97;
    goto LABEL_10;
  }
  if (sub_244D168EC((uint64_t *)*a1) >= 0x2711)
  {
    int v3 = 102;
    __int16 v4 = 104;
    goto LABEL_10;
  }
  uint64_t v7 = a1[3];
  if (v7 && (sub_244D16B50(v7) || sub_244D160FC(a1[3]) || (sub_244D17194(a1[3], *a1) & 0x80000000) == 0))
  {
    int v3 = 107;
    __int16 v4 = 112;
    goto LABEL_10;
  }
  uint64_t v8 = a1[4];
  if (v8 && (sub_244D16B50(v8) || sub_244D160FC(a1[4]) || (int)sub_244D17194(a1[4], a1[1]) >= 0))
  {
    int v3 = 107;
    __int16 v4 = 123;
    goto LABEL_10;
  }
  return 1;
}

void *sub_244D08AC4(long long *a1)
{
  uint64_t v2 = sub_244D07DF4();
  if (v2)
  {
    long long v6 = 0uLL;
    if (!sub_244CFCD34(a1, &v6, 536870928)
      || (v3 = sub_244D16670(), (void *v2 = v3) == 0)
      || !sub_244CFA034(&v6, v3)
      || (__int16 v4 = sub_244D16670(), (v2[1] = v4) == 0)
      || !sub_244CFA034(&v6, v4)
      || *((void *)&v6 + 1))
    {
      sub_244D0B884(10, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 159);
      sub_244D07DFC(v2);
      return 0;
    }
  }
  return v2;
}

void *sub_244D08B80(long long *a1, void *a2)
{
  uint64_t result = sub_244D16670();
  *a2 = result;
  if (result)
  {
    return (void *)sub_244CFA034(a1, result);
  }
  return result;
}

uint64_t sub_244D08BD4(uint64_t *a1, uint64_t **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v5, 0x20000010u)
    && sub_244D08C74((uint64_t *)v5, *a2)
    && sub_244D08C74((uint64_t *)v5, a2[1])
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(10, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 172);
  return 0;
}

uint64_t sub_244D08C74(uint64_t *a1, uint64_t *a2)
{
  if (a2)
  {
    return sub_244CFA0E0(a1, a2);
  }
  else
  {
    sub_244D0B884(10, a2, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 143);
    return 0;
  }
}

uint64_t *sub_244D08CB8(long long *a1)
{
  uint64_t v2 = sub_244D072E8();
  if (v2)
  {
    long long v8 = 0uLL;
    if (!sub_244CFCD34(a1, &v8, 536870928)) {
      goto LABEL_14;
    }
    int v3 = sub_244D16670();
    v2[3] = (uint64_t)v3;
    if (!v3
      || !sub_244CFA034(&v8, v3)
      || (v4 = sub_244D16670(), (uint64_t *v2 = (uint64_t)v4) == 0)
      || !sub_244CFA034(&v8, v4)
      || (unint64_t v5 = sub_244D16670(), (v2[1] = (uint64_t)v5) == 0)
      || !sub_244CFA034(&v8, v5)
      || (long long v6 = sub_244D16670(), (v2[2] = (uint64_t)v6) == 0)
      || !sub_244CFA034(&v8, v6)
      || *((void *)&v8 + 1))
    {
LABEL_14:
      sub_244D0B884(10, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 190);
LABEL_15:
      sub_244D07330((uint64_t)v2);
      return 0;
    }
    if (!sub_244D088CC(v2)) {
      goto LABEL_15;
    }
  }
  return v2;
}

uint64_t sub_244D08DBC(uint64_t *a1, uint64_t **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v5, 0x20000010u)
    && sub_244D08C74((uint64_t *)v5, a2[3])
    && sub_244D08C74((uint64_t *)v5, *a2)
    && sub_244D08C74((uint64_t *)v5, a2[1])
    && sub_244D08C74((uint64_t *)v5, a2[2])
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(10, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 211);
  return 0;
}

uint64_t *sub_244D08E7C(long long *a1)
{
  uint64_t v2 = sub_244D072E8();
  if (v2)
  {
    long long v7 = 0uLL;
    if (!sub_244CFCD34(a1, &v7, 536870928)
      || (v3 = sub_244D16670(), (uint64_t *v2 = (uint64_t)v3) == 0)
      || !sub_244CFA034(&v7, v3)
      || (__int16 v4 = sub_244D16670(), (v2[1] = (uint64_t)v4) == 0)
      || !sub_244CFA034(&v7, v4)
      || (unint64_t v5 = sub_244D16670(), (v2[2] = (uint64_t)v5) == 0)
      || !sub_244CFA034(&v7, v5)
      || *((void *)&v7 + 1))
    {
      sub_244D0B884(10, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 228);
LABEL_13:
      sub_244D07330((uint64_t)v2);
      return 0;
    }
    if (!sub_244D088CC(v2)) {
      goto LABEL_13;
    }
  }
  return v2;
}

uint64_t sub_244D08F64(uint64_t *a1, uint64_t **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v5, 0x20000010u)
    && sub_244D08C74((uint64_t *)v5, *a2)
    && sub_244D08C74((uint64_t *)v5, a2[1])
    && sub_244D08C74((uint64_t *)v5, a2[2])
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(10, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 248);
  return 0;
}

uint64_t *sub_244D09014(long long *a1)
{
  uint64_t v2 = sub_244D072E8();
  if (v2)
  {
    long long v11 = 0uLL;
    unint64_t v10 = 0;
    if (sub_244CFCD34(a1, &v11, 536870928) && sub_244CFCEF4(&v11, &v10))
    {
      if (v10)
      {
        int v3 = 104;
        __int16 v4 = 269;
      }
      else
      {
        long long v6 = sub_244D16670();
        uint64_t *v2 = (uint64_t)v6;
        if (v6)
        {
          if (sub_244CFA034(&v11, v6))
          {
            long long v7 = sub_244D16670();
            v2[1] = (uint64_t)v7;
            if (v7)
            {
              if (sub_244CFA034(&v11, v7))
              {
                long long v8 = sub_244D16670();
                _OWORD v2[2] = (uint64_t)v8;
                if (v8)
                {
                  if (sub_244CFA034(&v11, v8))
                  {
                    unint64_t v9 = sub_244D16670();
                    v2[3] = (uint64_t)v9;
                    if (v9)
                    {
                      if (sub_244CFA034(&v11, v9)
                        && sub_244D08B80(&v11, v2 + 4)
                        && !*((void *)&v11 + 1))
                      {
                        if (sub_244D088CC(v2)) {
                          return v2;
                        }
                        goto LABEL_8;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        int v3 = 105;
        __int16 v4 = 279;
      }
    }
    else
    {
      int v3 = 105;
      __int16 v4 = 264;
    }
    sub_244D0B884(10, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", v4);
LABEL_8:
    sub_244D07330((uint64_t)v2);
    return 0;
  }
  return v2;
}

uint64_t sub_244D0917C(uint64_t *a1, uint64_t **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v5, 0x20000010u)
    && sub_244CFBDDC((uint64_t)v5, 0)
    && sub_244D08C74((uint64_t *)v5, *a2)
    && sub_244D08C74((uint64_t *)v5, a2[1])
    && sub_244D08C74((uint64_t *)v5, a2[2])
    && sub_244D08C74((uint64_t *)v5, a2[3])
    && sub_244D08C74((uint64_t *)v5, a2[4])
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(10, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/dsa/dsa_asn1.c", 303);
  return 0;
}

void *sub_244D0925C(void **a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  unint64_t v5 = sub_244D08AC4(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D07DFC(*a1);
      *a1 = v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D092D0(uint64_t **a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D08BD4((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t *sub_244D09344(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  unint64_t v5 = sub_244D08CB8(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D07330(*a1);
      *a1 = (uint64_t)v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D093B8(uint64_t **a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D08DBC((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t *sub_244D0942C(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  unint64_t v5 = sub_244D09014(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D07330(*a1);
      *a1 = (uint64_t)v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D094A0(uint64_t **a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D0917C((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t *sub_244D09514(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  unint64_t v5 = sub_244D08E7C(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D07330(*a1);
      *a1 = (uint64_t)v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D09588(uint64_t **a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D08F64((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D095FC(long long *a1, uint64_t a2)
{
  long long v19 = 0uLL;
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  unint64_t v16 = 0;
  if (sub_244CFCD34(a1, &v19, 536870928)
    && sub_244CFCEF4(&v19, &v16)
    && v16 == 1
    && sub_244CFCD34(&v19, &v17, 4))
  {
    if (sub_244CFCE04(&v19, -1610612736))
    {
      long long v15 = 0uLL;
      if (!sub_244CFCD34(&v19, &v15, -1610612736))
      {
        int v4 = 128;
        __int16 v5 = 106;
        goto LABEL_34;
      }
      uint64_t v3 = sub_244D098F8(&v15);
      if (!v3)
      {
LABEL_35:
        uint64_t v6 = 0;
LABEL_36:
        unint64_t v9 = 0;
LABEL_37:
        sub_244D2A380(v6);
        sub_244D166B0((void **)v9);
        return 0;
      }
      if (a2)
      {
        if (sub_244D2670C(a2, v3))
        {
          int v4 = 130;
          __int16 v5 = 117;
LABEL_34:
          sub_244D0B884(15, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", v5);
          goto LABEL_35;
        }
      }
      else
      {
        a2 = v3;
      }
      if (*((void *)&v15 + 1))
      {
        int v4 = 128;
        __int16 v5 = 121;
        goto LABEL_34;
      }
    }
    else if (!a2)
    {
      int v4 = 114;
      __int16 v5 = 127;
      goto LABEL_34;
    }
    long long v8 = sub_244D2A270();
    uint64_t v6 = (uint64_t)v8;
    if (!v8 || !sub_244D2A4D0(v8, a2)) {
      goto LABEL_36;
    }
    unint64_t v9 = sub_244D16D20(v17, v18, 0);
    unint64_t v10 = sub_244D28B04(a2);
    *(void *)(v6 + 8) = v10;
    if (!v9 || !v10 || !sub_244D2A5F0((uint64_t *)v6, (uint64_t)v9)) {
      goto LABEL_37;
    }
    if (sub_244CFCE04(&v19, -1610612735))
    {
      long long v15 = 0uLL;
      int v13 = 0;
      uint64_t v14 = 0;
      char v12 = 0;
      if (!sub_244CFCD34(&v19, &v15, -1610612735)
        || !sub_244CFCD34(&v15, &v13, 3)
        || !sub_244CFC650(&v13, &v12)
        || v12
        || !v14
        || !sub_244D2AB28(a2, *(void *)(v6 + 8), v13, v14, 0)
        || *((void *)&v15 + 1))
      {
        __int16 v11 = 161;
LABEL_43:
        sub_244D0B884(15, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", v11);
        goto LABEL_37;
      }
      *(_DWORD *)(v6 + 28) = *v13 & 0xFE;
    }
    else
    {
      if (!sub_244D29D74(a2, *(void *)(v6 + 8) + 8, *(void *)(v6 + 16) + 24)) {
        goto LABEL_37;
      }
      *(_DWORD *)(v6 + 24) |= 2u;
    }
    if (!*((void *)&v19 + 1))
    {
      if (sub_244D2A77C(v6))
      {
        sub_244D166B0((void **)v9);
        return v6;
      }
      goto LABEL_37;
    }
    __int16 v11 = 181;
    goto LABEL_43;
  }
  sub_244D0B884(15, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", 92);
  return 0;
}

uint64_t sub_244D098F8(long long *a1)
{
  if (!sub_244CFCE04(a1, 536870928))
  {
    return sub_244D0A0E8(a1);
  }
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v32 = 0uLL;
  long long v31 = 0uLL;
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  long long v28 = 0uLL;
  uint64_t v26 = 0;
  unint64_t v27 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  int v23 = 0;
  unint64_t v22 = 0;
  if (!sub_244CFCD34(a1, &v32, 536870928)
    || !sub_244CFCEF4(&v32, &v22)
    || v22 != 1
    || !sub_244CFCD34(&v32, &v31, 536870928)
    || !sub_244CFCD34(&v31, &v29, 6)
    || v30 != 7
    || (*v29 == -834107862 ? (BOOL v2 = *(_DWORD *)((char *)v29 + 3) == 16858574) : (BOOL v2 = 0),
        !v2
     || !sub_244CFCD34(&v31, &v15, 2)
     || !sub_244CFCFC8((unsigned __int8 **)&v15)
     || *((void *)&v31 + 1)
     || !sub_244CFCD34(&v32, &v28, 536870928)
     || !sub_244CFCD34(&v28, &v16, 4)
     || !sub_244CFCD34(&v28, &v17, 4)
     || !sub_244CFD1E4(&v28, 0, 0, 3)
     || *((void *)&v28 + 1)
     || !sub_244CFCD34(&v32, &v26, 4)
     || !sub_244CFCD34(&v32, &v20, 2)
     || !sub_244CFCFC8((unsigned __int8 **)&v20)
     || !sub_244CFD1E4(&v32, &v24, &v23, 2)
     || *((void *)&v32 + 1)))
  {
    int v3 = 128;
    __int16 v4 = 288;
LABEL_13:
    sub_244D0B884(15, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", v4);
    return 0;
  }
  if (v23 && (v25 != 1 || *v24 != 1))
  {
    int v3 = 123;
    __int16 v4 = 296;
    goto LABEL_13;
  }
  char v21 = 0;
  if (!sub_244CFC650(&v26, &v21) || v21 != 4)
  {
    int v3 = 111;
    __int16 v4 = 304;
    goto LABEL_13;
  }
  if (v27)
  {
    int v3 = 128;
    __int16 v4 = 309;
    goto LABEL_13;
  }
  *(void *)&long long v18 = v26;
  *((void *)&v18 + 1) = v27 >> 1;
  *(void *)&long long v19 = v26 + (v27 >> 1);
  *((void *)&v19 + 1) = v27 >> 1;
  uint64_t v6 = sub_244D16670();
  long long v7 = sub_244D16670();
  long long v8 = sub_244D16670();
  unint64_t v9 = sub_244D16670();
  uint64_t v14 = sub_244D16670();
  uint64_t v10 = 0;
  if (v6 && v7 && v8 && v9 && v14)
  {
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t v10 = off_26F954B10[v11]();
      uint64_t v12 = sub_244D27790(v10);
      if (sub_244D0A1A0(&v20, v12)) {
        break;
      }
      if (++v11 == 4) {
        goto LABEL_44;
      }
    }
    if (!sub_244D28914(v10, v6, v7, v8, 0))
    {
LABEL_45:
      uint64_t v10 = 0;
      goto LABEL_46;
    }
    if (!sub_244D0A1A0(&v15, (uint64_t)v6) || !sub_244D0A1A0(&v16, (uint64_t)v7) || !sub_244D0A1A0(&v17, (uint64_t)v8)) {
      goto LABEL_44;
    }
    int v13 = (uint64_t *)sub_244D2887C(v10);
    if (!sub_244D29154(v10, v13, v9, v14)) {
      goto LABEL_45;
    }
    if (!sub_244D0A1A0(&v18, (uint64_t)v9) || !sub_244D0A1A0(&v19, (uint64_t)v14) || !v10)
    {
LABEL_44:
      sub_244D0B884(15, 0, 123, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", 422);
      goto LABEL_45;
    }
  }
LABEL_46:
  sub_244D166B0((void **)v6);
  sub_244D166B0((void **)v7);
  sub_244D166B0((void **)v8);
  sub_244D166B0((void **)v9);
  sub_244D166B0((void **)v14);
  return v10;
}

uint64_t sub_244D09D84(uint64_t *a1, uint64_t a2, char a3)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 16))
  {
    memset(v17, 0, sizeof(v17));
    memset(v16, 0, sizeof(v16));
    if (sub_244CFB808(a1, (uint64_t)v17, 0x20000010u)
      && sub_244CFBDDC((uint64_t)v17, 1uLL)
      && sub_244CFB808((uint64_t *)v17, (uint64_t)v16, 4u)
      && (uint64_t v6 = (uint64_t *)sub_244D27790(*(void *)a2),
          unint64_t v7 = sub_244D1695C(v6),
          uint64_t v8 = sub_244D07414(a2),
          sub_244CFA1C4((uint64_t)v16, v7, v8)))
    {
      if ((a3 & 1) != 0
        || (v14 = 0u, v15 = 0u, long long v13 = 0u, sub_244CFB808((uint64_t *)v17, (uint64_t)&v13, 0xA0000000))
        && sub_244D09FA8((uint64_t *)&v13, *(void *)a2)
        && sub_244CFB540((uint64_t *)v17))
      {
        if ((a3 & 2) != 0
          || !*(void *)(a2 + 8)
          || (long long v14 = 0u,
              long long v15 = 0u,
              long long v13 = 0u,
              memset(v12, 0, sizeof(v12)),
              sub_244CFB808((uint64_t *)v17, (uint64_t)&v13, 0xA0000001))
          && sub_244CFB808((uint64_t *)&v13, (uint64_t)v12, 3u)
          && sub_244CFB8C4((uint64_t)v12, 0)
          && sub_244D0A040((uint64_t)v12, *(void *)a2, *(uint64_t **)(a2 + 8), *(_DWORD *)(a2 + 28))
          && sub_244CFB540((uint64_t *)v17))
        {
          if (sub_244CFB540(a1)) {
            return 1;
          }
          int v10 = 129;
          __int16 v11 = 244;
        }
        else
        {
          int v10 = 129;
          __int16 v11 = 238;
        }
      }
      else
      {
        int v10 = 129;
        __int16 v11 = 222;
      }
    }
    else
    {
      int v10 = 129;
      __int16 v11 = 213;
    }
  }
  else
  {
    int v10 = 67;
    __int16 v11 = 202;
  }
  sub_244D0B884(15, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", v11);
  return 0;
}

uint64_t sub_244D09FA8(uint64_t *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 525))
  {
    memset(v5, 0, sizeof(v5));
    uint64_t result = sub_244CFB808(a1, (uint64_t)v5, 6u);
    if (result)
    {
      uint64_t result = sub_244CFBA40((uint64_t)v5, (const void *)(a2 + 516), *(unsigned __int8 *)(a2 + 525));
      if (result) {
        return sub_244CFB540(a1) != 0;
      }
    }
  }
  else
  {
    sub_244D0B884(15, 0, 123, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", 363);
    return 0;
  }
  return result;
}

uint64_t sub_244D0A040(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  uint64_t result = sub_244D2C870(a2, a3, a4, 0, 0);
  if (result)
  {
    unint64_t v9 = result;
    int v10 = 0;
    uint64_t result = sub_244CFBA94(a1, &v10, result);
    if (result) {
      return sub_244D2C870(a2, a3, a4, v10, v9) == v9;
    }
  }
  return result;
}

uint64_t sub_244D0A0E8(long long *a1)
{
  v6[0] = 0;
  v6[1] = 0;
  if (sub_244CFCD34(a1, v6, 6))
  {
    uint64_t v1 = 0;
    while (1)
    {
      uint64_t v2 = off_26F954B10[v1]();
      if (sub_244CFC618((uint64_t)v6, (char *)(v2 + 516), *(unsigned __int8 *)(v2 + 525))) {
        break;
      }
      if (++v1 == 4)
      {
        int v3 = 123;
        __int16 v4 = 357;
        goto LABEL_7;
      }
    }
  }
  else
  {
    int v3 = 128;
    __int16 v4 = 345;
LABEL_7:
    sub_244D0B884(15, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", v4);
    return 0;
  }
  return v2;
}

BOOL sub_244D0A1A0(long long *a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  for (long long i = *a1; *((void *)&i + 1); sub_244CFC510(&i, 1uLL))
  {
    if (*(unsigned char *)i)
    {
      if (*((void *)&i + 1) > 0x42uLL) {
        return 0;
      }
      break;
    }
  }
  if (sub_244D16FA8(v5, *((unint64_t *)&i + 1), a2)) {
    return sub_244CFC618((uint64_t)&i, v5, *((uint64_t *)&i + 1));
  }
  sub_244D0B1B0();
  return 0;
}

uint64_t sub_244D0A254(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a1 && (uint64_t v6 = *a1) != 0)
  {
    uint64_t v7 = sub_244D0740C(v6);
    if (a3 < 0)
    {
LABEL_4:
      sub_244D0B884(15, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", 454);
      return 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
    if (a3 < 0) {
      goto LABEL_4;
    }
  }
  *(void *)&long long v10 = *a2;
  *((void *)&v10 + 1) = a3;
  uint64_t v8 = sub_244D095FC(&v10, v7);
  if (v8)
  {
    if (a1)
    {
      sub_244D2A380(*a1);
      *a1 = v8;
    }
    *a2 = v10;
  }
  return v8;
}

uint64_t sub_244D0A304(uint64_t a1, void **a2)
{
  memset(v6, 0, sizeof(v6));
  if (sub_244CFB3DC((uint64_t)v6, 0))
  {
    char v4 = sub_244D22EB0(a1);
    if (sub_244D09D84((uint64_t *)v6, a1, v4)) {
      return sub_244CFAE28((uint64_t)v6, a2);
    }
  }
  sub_244CFB470((uint64_t)v6);
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D0A384(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v10 = *a2;
  *((void *)&v10 + 1) = a3;
  uint64_t v5 = sub_244D098F8(&v10);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = sub_244D2A270();
  uint64_t v8 = (uint64_t)v7;
  if (!v7 || !sub_244D2A4D0(v7, v6))
  {
    sub_244D2A380(v8);
    return 0;
  }
  if (a1)
  {
    sub_244D2A380(*a1);
    *a1 = v8;
  }
  *a2 = v10;
  return v8;
}

uint64_t sub_244D0A41C(uint64_t *a1, void **a2)
{
  if (a1 && *a1)
  {
    memset(v5, 0, sizeof(v5));
    if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D09FA8((uint64_t *)v5, *a1)) {
      return sub_244CFAE28((uint64_t)v5, a2);
    }
    sub_244CFB470((uint64_t)v5);
  }
  else
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", 509);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D0A4BC(uint64_t *a1, unsigned __int8 **a2, uint64_t a3)
{
  if (!a1 || (uint64_t v3 = *a1) == 0 || (v4 = *(void *)v3) == 0)
  {
    int v9 = 67;
    __int16 v10 = 526;
LABEL_10:
    sub_244D0B884(15, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", v10);
    return 0;
  }
  uint64_t v7 = *(void *)(v3 + 8);
  if (!v7)
  {
    uint64_t v8 = sub_244D28B04(v4);
    *(void *)(v3 + 8) = v8;
    if (!v8) {
      return 0;
    }
    uint64_t v7 = (uint64_t)v8;
    uint64_t v4 = *(void *)v3;
  }
  if (!sub_244D2AB28(v4, v7, *a2, a3, 0))
  {
    int v9 = 15;
    __int16 v10 = 535;
    goto LABEL_10;
  }
  *(_DWORD *)(v3 + 28) = **a2 & 0xFE;
  *a2 += a3;
  return v3;
}

uint64_t sub_244D0A58C(uint64_t a1, void **a2)
{
  if (a1)
  {
    memset(v6, 0, sizeof(v6));
    if (sub_244CFB3DC((uint64_t)v6, 0)
      && sub_244D0A040((uint64_t)v6, *(void *)a1, *(uint64_t **)(a1 + 8), *(_DWORD *)(a1 + 28)))
    {
      int v4 = sub_244CFAE28((uint64_t)v6, a2);
      return v4 & ~(v4 >> 31);
    }
    else
    {
      sub_244CFB470((uint64_t)v6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ec_extra/ec_asn1.c", 546);
    return 0;
  }
}

uint64_t sub_244D0A634(uint64_t a1, unint64_t a2)
{
  if (a2 >= 4) {
    uint64_t v2 = 4;
  }
  else {
    uint64_t v2 = a2;
  }
  if (v2)
  {
    uint64_t v3 = (void *)(a1 + 8);
    int v4 = off_26F954B10;
    do
    {
      uint64_t v5 = *v4++;
      uint64_t v6 = v5();
      *((_DWORD *)v3 - 2) = *(_DWORD *)(v6 + 512);
      *uint64_t v3 = *(void *)(v6 + 504);
      v3 += 2;
      --v2;
    }
    while (v2);
  }
  return 4;
}

uint64_t sub_244D0A698(void *a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t (*a5)(unsigned char *, size_t, void *, unint64_t *))
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  unint64_t v18 = a2;
  uint64_t v5 = *(void *)(a4 + 16);
  if (!v5)
  {
    int v11 = 27;
    int v12 = 101;
    __int16 v13 = 85;
    goto LABEL_11;
  }
  size_t v8 = a2;
  __int16 v10 = (uint64_t *)sub_244D0740C(a4);
  if (sub_244D2670C((uint64_t)v10, *a3))
  {
    int v11 = 15;
    int v12 = 106;
    __int16 v13 = 91;
LABEL_11:
    sub_244D0B884(v11, 0, v12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ecdh_extra/ecdh_extra.c", v13);
    return 0xFFFFFFFFLL;
  }
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  size_t v15 = 0;
  if (!sub_244D267EC((uint64_t)v10, (uint64_t)v16, (uint64_t)(a3 + 1), v5 + 24)
    || !sub_244D26878(v10, (uint64_t)__src, &v15, 0x42uLL, (uint64_t)v16))
  {
    int v11 = 27;
    int v12 = 102;
    __int16 v13 = 101;
    goto LABEL_11;
  }
  if (a5)
  {
    if (!a5(__src, v15, a1, &v18))
    {
      int v11 = 27;
      int v12 = 100;
      __int16 v13 = 107;
      goto LABEL_11;
    }
    size_t v8 = v18;
LABEL_17:
    if (!(v8 >> 31)) {
      return v8;
    }
    int v11 = 27;
    int v12 = 69;
    __int16 v13 = 119;
    goto LABEL_11;
  }
  if (v15 < v8)
  {
    unint64_t v18 = v15;
    size_t v8 = v15;
  }
  if (v8)
  {
    memcpy(a1, __src, v8);
    goto LABEL_17;
  }
  return v8;
}

uint64_t sub_244D0A87C(uint64_t a1, unint64_t *a2, size_t a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v9 = a6[5];
  if (!v9
    || (__int16 v10 = *(uint64_t (**)(unint64_t *, size_t, uint64_t, _DWORD *, uint64_t *))(v9 + 40)) == 0)
  {
    int v12 = sub_244D27580(a2, a3, a6);
    if (v12)
    {
      memset(v17, 0, sizeof(v17));
      unint64_t v13 = sub_244D0A99C((uint64_t)a6);
      sub_244CFB440((uint64_t)v17, a4, v13);
      uint64_t v16 = 0;
      if (sub_244D0A9FC((uint64_t *)v17, (uint64_t **)v12)
        && sub_244CFB48C((uint64_t)v17, 0, &v16))
      {
        int v14 = v16;
        uint64_t v15 = 1;
LABEL_12:
        *a5 = v14;
        sub_244D07DFC(v12);
        return v15;
      }
      sub_244D0B884(26, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ecdsa_extra/ecdsa_asn1.c", 88);
    }
    int v14 = 0;
    uint64_t v15 = 0;
    goto LABEL_12;
  }

  return v10(a2, a3, a4, a5, a6);
}

unint64_t sub_244D0A99C(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1 || (uint64_t v2 = *(uint64_t (**)(void))(v1 + 32)) == 0)
  {
    uint64_t v4 = sub_244D0740C(a1);
    if (v4)
    {
      uint64_t v5 = (uint64_t *)sub_244D27790(v4);
      unint64_t v3 = sub_244D1695C(v5);
      goto LABEL_7;
    }
    return 0;
  }
  unint64_t v3 = v2();
LABEL_7:

  return sub_244D0ACA4(v3);
}

uint64_t sub_244D0A9FC(uint64_t *a1, uint64_t **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v5, 0x20000010u)
    && sub_244CFA0E0((uint64_t *)v5, *a2)
    && sub_244CFA0E0((uint64_t *)v5, a2[1])
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(26, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ecdsa_extra/ecdsa_asn1.c", 185);
  return 0;
}

uint64_t sub_244D0AA9C(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, uint64_t a6)
{
  __s2 = 0;
  int v11 = (uint64_t **)sub_244D0AB88((uint64_t)a4, a5);
  if (v11)
  {
    uint64_t v14 = 0;
    if (sub_244D0ABF4(&__s2, &v14, v11) && v14 == a5 && (!a5 || !memcmp(a4, __s2, a5)))
    {
      uint64_t v12 = sub_244D2718C(a2, a3, v11, a6);
      goto LABEL_9;
    }
    sub_244D0B884(26, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ecdsa_extra/ecdsa_asn1.c", 117);
  }
  uint64_t v12 = 0;
LABEL_9:
  sub_244D440EC(__s2);
  sub_244D07DFC(v11);
  return v12;
}

void *sub_244D0AB88(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v4 = a1;
  *((void *)&v4 + 1) = a2;
  uint64_t v2 = sub_244D0AD28(&v4);
  if (!v2 || *((void *)&v4 + 1))
  {
    sub_244D0B884(26, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ecdsa_extra/ecdsa_asn1.c", 172);
    sub_244D07DFC(v2);
    return 0;
  }
  return v2;
}

uint64_t sub_244D0ABF4(void *a1, void *a2, uint64_t **a3)
{
  memset(v7, 0, sizeof(v7));
  sub_244CFB3CC(v7);
  if (sub_244CFB3DC((uint64_t)v7, 0)
    && sub_244D0A9FC((uint64_t *)v7, a3)
    && sub_244CFB48C((uint64_t)v7, a1, a2))
  {
    return 1;
  }
  sub_244D0B884(26, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ecdsa_extra/ecdsa_asn1.c", 198);
  sub_244CFB470((uint64_t)v7);
  return 0;
}

unint64_t sub_244D0ACA4(unint64_t a1)
{
  unint64_t v1 = a1 + 1;
  uint64_t v2 = 1;
  if (a1 + 1 >= 0x80)
  {
    do
    {
      ++v2;
      BOOL v3 = v1 > 0xFF;
      v1 >>= 8;
    }
    while (v3);
  }
  uint64_t v4 = 0;
  unint64_t v5 = a1 + v2 + 2;
  if (v5 >= a1 && (v5 & 0x8000000000000000) == 0)
  {
    unint64_t v6 = 2 * v5;
    if (v5 >= 0x40)
    {
      uint64_t v7 = 1;
      unint64_t v8 = v6;
      do
      {
        ++v7;
        BOOL v3 = v8 > 0xFF;
        v8 >>= 8;
      }
      while (v3);
    }
    else
    {
      uint64_t v7 = 1;
    }
    unint64_t v9 = (v6 | 1) + v7;
    if (v9 >= v6) {
      return v9;
    }
    else {
      return 0;
    }
  }
  return v4;
}

void *sub_244D0AD28(long long *a1)
{
  uint64_t v2 = sub_244D26C98();
  if (v2)
  {
    long long v4 = 0uLL;
    if (!sub_244CFCD34(a1, &v4, 536870928)
      || !sub_244CFA034(&v4, (void *)*v2)
      || !sub_244CFA034(&v4, (void *)v2[1])
      || *((void *)&v4 + 1))
    {
      sub_244D0B884(26, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ecdsa_extra/ecdsa_asn1.c", 160);
      sub_244D07DFC(v2);
      return 0;
    }
  }
  return v2;
}

void *sub_244D0ADCC(void **a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  unint64_t v5 = sub_244D0AD28(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D07DFC(*a1);
      *a1 = v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D0AE40(uint64_t **a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D0A9FC((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D0AEB4(void *a1)
{
  return 1;
}

uint64_t sub_244D0AED0(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 80 || !*(unsigned char *)(a2 + 4)) {
    return 0;
  }
  *a1 = a2;
  return 1;
}

uint64_t sub_244D0AEF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 56 || !*(unsigned char *)(a2 + 4)) {
    return 0;
  }
  *(void *)(a1 + 8) = a2;
  return 1;
}

uint64_t sub_244D0AF18()
{
  return sub_244D0AF34(1, 0, 0, 0, 0, 0);
}

uint64_t sub_244D0AF34(int a1, int a2, void *a3, _DWORD *a4, void *a5, _DWORD *a6)
{
  uint64_t v12 = sub_244D0B210();
  if (!v12) {
    return 0;
  }
  unint64_t v13 = v12;
  int v14 = *((_DWORD *)v12 + 97);
  if (v14 == *((_DWORD *)v12 + 96)) {
    return 0;
  }
  int v16 = ((_BYTE)v14 + 1) & 0xF;
  if (a2) {
    unsigned int v17 = *((_DWORD *)v12 + 96);
  }
  else {
    unsigned int v17 = v16;
  }
  unint64_t v18 = &v12[3 * v17];
  uint64_t v15 = *((unsigned int *)v18 + 4);
  if (a3 && a4)
  {
    uint64_t v19 = *v18;
    if (*v18)
    {
      *a3 = v19;
      LODWORD(v19) = WORD2(v12[3 * v17 + 2]);
    }
    else
    {
      *a3 = "NA";
    }
    *a4 = v19;
  }
  if (!a5) {
    goto LABEL_23;
  }
  uint64_t v20 = &v12[3 * v17];
  uint64_t v23 = v20[1];
  unint64_t v22 = v20 + 1;
  uint64_t v21 = v23;
  if (!v23)
  {
    *a5 = "";
    if (a6) {
      *a6 = 0;
    }
LABEL_23:
    if (!a1) {
      return v15;
    }
    uint64_t v24 = (void *)v12[3 * v17 + 1];
LABEL_25:
    free(v24);
    *unint64_t v18 = 0;
    v18[1] = 0;
    v18[2] = 0;
    *((_DWORD *)v13 + 97) = v17;
    return v15;
  }
  *a5 = v21;
  if (a6) {
    *a6 = 3;
  }
  if (a1)
  {
    if (*v22)
    {
      free((void *)v12[49]);
      v13[49] = *v22;
    }
    uint64_t v24 = 0;
    *unint64_t v22 = 0;
    goto LABEL_25;
  }
  return v15;
}

uint64_t sub_244D0B080(void *a1, _DWORD *a2)
{
  return sub_244D0AF34(1, 0, a1, a2, 0, 0);
}

uint64_t sub_244D0B09C(void *a1, _DWORD *a2, void *a3, _DWORD *a4)
{
  return sub_244D0AF34(1, 0, a1, a2, a3, a4);
}

void *sub_244D0B0B8()
{
  uint64_t result = sub_244D0B210();
  if (result)
  {
    int v1 = *((_DWORD *)result + 97);
    if (v1 == *((_DWORD *)result + 96)) {
      return 0;
    }
    else {
      return (void *)LODWORD(result[3 * ((v1 + 1) & 0xF) + 2]);
    }
  }
  return result;
}

uint64_t sub_244D0B100(void *a1, _DWORD *a2)
{
  return sub_244D0AF34(0, 0, a1, a2, 0, 0);
}

uint64_t sub_244D0B11C(void *a1, _DWORD *a2, void *a3, _DWORD *a4)
{
  return sub_244D0AF34(0, 0, a1, a2, a3, a4);
}

void *sub_244D0B138()
{
  uint64_t result = sub_244D0B210();
  if (result)
  {
    unsigned int v1 = *((_DWORD *)result + 96);
    if (*((_DWORD *)result + 97) == v1) {
      return 0;
    }
    else {
      return (void *)LODWORD(result[3 * v1 + 2]);
    }
  }
  return result;
}

uint64_t sub_244D0B178(void *a1, _DWORD *a2)
{
  return sub_244D0AF34(0, 1, a1, a2, 0, 0);
}

uint64_t sub_244D0B194(void *a1, _DWORD *a2, void *a3, _DWORD *a4)
{
  return sub_244D0AF34(0, 1, a1, a2, a3, a4);
}

void sub_244D0B1B0()
{
  v0 = sub_244D0B210();
  if (v0)
  {
    unsigned int v1 = v0;
    for (uint64_t i = 0; i != 48; i += 3)
    {
      BOOL v3 = &v1[i];
      free((void *)v1[i + 1]);
      *BOOL v3 = 0;
      v3[1] = 0;
      void v3[2] = 0;
    }
    free((void *)v1[49]);
    v1[48] = 0;
    v1[49] = 0;
  }
}

void *sub_244D0B210()
{
  v0 = sub_244D4BDD4(0);
  if (!v0)
  {
    uint64_t v2 = malloc_type_malloc(0x190uLL, 0x10D00400F8CE868uLL);
    v0 = v2;
    if (v2)
    {
      v2[23] = 0u;
      v2[24] = 0u;
      v2[21] = 0u;
      v2[22] = 0u;
      v2[19] = 0u;
      v2[20] = 0u;
      v2[17] = 0u;
      v2[18] = 0u;
      v2[15] = 0u;
      v2[16] = 0u;
      v2[13] = 0u;
      v2[14] = 0u;
      v2[11] = 0u;
      v2[12] = 0u;
      v2[9] = 0u;
      v2[10] = 0u;
      v2[7] = 0u;
      v2[8] = 0u;
      v2[5] = 0u;
      v2[6] = 0u;
      v2[3] = 0u;
      v2[4] = 0u;
      v2[1] = 0u;
      _OWORD v2[2] = 0u;
      _OWORD *v2 = 0u;
      if (!sub_244D4BE80(0, (uint64_t)v2, (void (*)(uint64_t))sub_244D0BF18)) {
        return 0;
      }
    }
  }
  return v0;
}

void sub_244D0B2C0(uint64_t a1)
{
  if (!a1) {
    sub_244D0B1B0();
  }
}

uint64_t sub_244D0B2CC()
{
  sub_244D4BD70(&stru_268EBD520);
  uint64_t v0 = dword_268EBD5E8++;
  sub_244D4BD90(&stru_268EBD520);
  return v0;
}

int *sub_244D0B318()
{
  uint64_t result = __error();
  *uint64_t result = 0;
  return result;
}

const char *sub_244D0B334(unsigned int a1)
{
  if (a1 >> 25 <= 0x10) {
    unsigned int v1 = (&off_26519D690)[3 * HIBYTE(a1)];
  }
  else {
    unsigned int v1 = 0;
  }
  if (v1) {
    return v1;
  }
  else {
    return "unknown library";
  }
}

char *sub_244D0B374(unsigned int a1)
{
  if (a1 >> 25 <= 0x10) {
    return (&off_26519D690)[3 * HIBYTE(a1) + 1];
  }
  else {
    return 0;
  }
}

const char *sub_244D0B3A4()
{
  return "OPENSSL_internal";
}

char *sub_244D0B3B0(unsigned int a1)
{
  uint64_t result = sub_244D0B3DC(a1, 0);
  if (!result) {
    return "unknown error";
  }
  return result;
}

char *sub_244D0B3DC(unsigned int a1, int a2)
{
  unsigned int v2 = HIBYTE(a1);
  unsigned int v3 = a1 & 0xFFF;
  if (HIBYTE(a1) == 2)
  {
    uint64_t result = 0;
    if (!a2 && v3 <= 0x7E)
    {
      return strerror(v3);
    }
  }
  else if (v3 > 0x21)
  {
    if (v3 > 0x63)
    {
      uint64_t result = 0;
      if (!(a1 >> 30) && v3 <= 0x7FF)
      {
        int __key = (v3 << 15) | (v2 << 26);
        uint64_t result = (char *)bsearch(&__key, &unk_244EBD9F0, 0x2F5uLL, 4uLL, (int (__cdecl *)(const void *, const void *))sub_244D0BF88);
        if (result) {
          return &aAsn1LengthMism[*(_DWORD *)result & 0x7FFF];
        }
      }
    }
    else
    {
      switch(a1 & 0xFFF)
      {
        case 'A':
          unint64_t v6 = "MALLOC_FAILURE";
          long long v7 = "malloc failure";
          goto LABEL_23;
        case 'B':
          unint64_t v6 = "SHOULD_NOT_HAVE_BEEN_CALLED";
          long long v7 = "function should not have been called";
          goto LABEL_23;
        case 'C':
          unint64_t v6 = "PASSED_NULL_PARAMETER";
          long long v7 = "passed a null parameter";
          goto LABEL_23;
        case 'D':
          unint64_t v6 = "INTERNAL_ERROR";
          long long v7 = "internal error";
          goto LABEL_23;
        case 'E':
          unint64_t v6 = "OVERFLOW";
          long long v7 = "overflow";
LABEL_23:
          if (a2) {
            uint64_t result = (char *)v6;
          }
          else {
            uint64_t result = (char *)v7;
          }
          break;
        default:
          uint64_t result = 0;
          break;
      }
    }
  }
  else
  {
    unint64_t v5 = &(&off_26519D690)[3 * (a1 & 0xFFF)];
    if (a2) {
      v5 += 2;
    }
    return *v5;
  }
  return result;
}

char *sub_244D0B58C(unsigned int a1)
{
  return sub_244D0B3DC(a1, 1);
}

char *sub_244D0B594(unsigned int a1, char *a2)
{
  if (!a2) {
    a2 = (char *)&unk_268EBEDF8;
  }
  return sub_244D0B5AC(a1, a2, 0x78uLL);
}

char *sub_244D0B5AC(unsigned int a1, char *a2, size_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (!a3) {
    return 0;
  }
  unsigned int v6 = HIBYTE(a1);
  if (a1 >> 25 < 0x11)
  {
    unint64_t v8 = (&off_26519D690)[3 * v6];
    long long v7 = sub_244D0B3DC(a1, 0);
    if (v8) {
      goto LABEL_7;
    }
  }
  else
  {
    long long v7 = sub_244D0B3DC(a1, 0);
  }
  unint64_t v8 = __str;
  snprintf(__str, 0x20uLL, "lib(%u)", v6);
LABEL_7:
  if (!v7)
  {
    long long v7 = v16;
    snprintf(v16, 0x20uLL, "reason(%u)", a1 & 0xFFF);
  }
  unsigned int v9 = snprintf(a2, a3, "error:%08x:%s:OPENSSL_internal:%s", a1, v8, v7);
  if (a3 >= 5 && (v9 & 0x80000000) == 0 && v9 >= a3)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (uint64_t)&a2[a3 - 5];
    uint64_t v12 = a2;
    while (1)
    {
      unint64_t v13 = strchr(v12, 58);
      int v14 = (char *)(v11 + v10);
      if (!v13 || v13 > v14) {
        break;
      }
      uint64_t v12 = v13 + 1;
      if (++v10 == 4) {
        return a2;
      }
    }
    memset(v14, 58, 4 - v10);
  }
  return a2;
}

uint64_t sub_244D0B738(uint64_t (*a1)(char *, size_t, uint64_t), uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  uint64_t v8 = 0;
  long long v4 = sub_244D0B210();
  do
  {
    uint64_t result = sub_244D0AF34(1, 0, &v10, (_DWORD *)&v8 + 1, &v9, &v8);
    if (!result) {
      break;
    }
    sub_244D0B5AC(result, v12, 0x78uLL);
    unsigned int v6 = (v8 & 1) != 0 ? v9 : "";
    snprintf(__str, 0x400uLL, "%lu:%s:%s:%d:%s\n", v4, v12, v10, HIDWORD(v8), v6);
    size_t v7 = strlen(__str);
    uint64_t result = a1(__str, v7, a2);
  }
  while ((int)result > 0);
  return result;
}

uint64_t sub_244D0B848(uint64_t a1)
{
  return sub_244D0B738((uint64_t (*)(char *, size_t, uint64_t))sub_244D0B860, a1);
}

BOOL sub_244D0B860(const char *a1, int a2, FILE *a3)
{
  return fputs(a1, a3) >= 0;
}

void sub_244D0B884(int a1, uint64_t a2, int a3, uint64_t a4, __int16 a5)
{
  unsigned int v9 = sub_244D0B210();
  if (v9)
  {
    uint64_t v10 = v9;
    if (a1 == 2 && !a3) {
      a3 = *__error();
    }
    int v11 = *((_DWORD *)v10 + 96);
    int v12 = ((_BYTE)v11 + 1) & 0xF;
    *((_DWORD *)v10 + 96) = v12;
    if (v12 == *((_DWORD *)v10 + 97)) {
      *((_DWORD *)v10 + 97) = ((_BYTE)v11 + 2) & 0xF;
    }
    uint64_t v13 = &v10[3 * ((v11 + 1) & 0xF)];
    free((void *)v13[1]);
    v13[1] = 0;
    _OWORD v13[2] = 0;
    *uint64_t v13 = a4;
    *((_WORD *)v13 + 10) = a5;
    *((_DWORD *)v13 + 4) = a3 & 0xFFF | (a1 << 24);
  }
}

void sub_244D0B930(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v19 = (const char **)&a9;
  uint64_t v20 = (char **)&a9;
  uint64_t v10 = a1;
  uint64_t v11 = 0;
  if (!a1) {
    goto LABEL_8;
  }
  uint64_t v12 = a1;
  do
  {
    uint64_t v13 = v19++;
    if (*v13)
    {
      size_t v14 = strlen(*v13);
      if (__CFADD__(v11, v14)) {
        return;
      }
      v11 += v14;
    }
    --v12;
  }
  while (v12);
  if (v11 != -1)
  {
LABEL_8:
    size_t v15 = v11 + 1;
    int v16 = malloc_type_malloc(v15, 0x8E171D9AuLL);
    if (v16)
    {
      unsigned int v17 = v16;
      *int v16 = 0;
      if (a1)
      {
        do
        {
          uint64_t v18 = v20++;
          if (*v18) {
            sub_244D447E4(v17, *v18, v15);
          }
          --v10;
        }
        while (v10);
      }
      sub_244D0BA4C(v17);
    }
  }
}

void sub_244D0BA04(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unsigned int v9 = 0;
  if (sub_244D44544(&v9, a1, &a9, 1) != -1) {
    sub_244D0BA4C(v9);
  }
}

void sub_244D0BA4C(void *a1)
{
  unsigned int v2 = sub_244D0B210();
  if (v2 && (unsigned int v3 = *((_DWORD *)v2 + 96), v3 != *((_DWORD *)v2 + 97)))
  {
    long long v4 = &v2[3 * v3];
    free((void *)v4[1]);
    v4[1] = a1;
  }
  else
  {
    free(a1);
  }
}

void sub_244D0BAB8(char *a1, char a2)
{
  if (a2)
  {
    long long v4 = sub_244D0BB10(a1);
    if (v4) {
      sub_244D0BA4C(v4);
    }
    if ((a2 & 2) != 0)
    {
      sub_244D440EC(a1);
    }
  }
}

void *sub_244D0BB10(const char *a1)
{
  size_t v2 = strlen(a1) + 1;
  unsigned int v3 = malloc_type_malloc(v2, 0x96AA084AuLL);
  long long v4 = v3;
  if (v3) {
    memcpy(v3, a1, v2);
  }
  return v4;
}

uint64_t sub_244D0BB6C()
{
  uint64_t result = (uint64_t)sub_244D0B210();
  if (result)
  {
    unsigned int v1 = *(_DWORD *)(result + 384);
    if (*(_DWORD *)(result + 388) == v1)
    {
      return 0;
    }
    else
    {
      *(unsigned char *)(result + 24 * v1 + 22) |= 1u;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D0BBB8()
{
  uint64_t result = (uint64_t)sub_244D0B210();
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = *(_DWORD *)(result + 384);
    if (*(_DWORD *)(result + 388) == v2)
    {
      return 0;
    }
    else
    {
      while (1)
      {
        uint64_t v3 = v1 + 24 * v2;
        char v6 = *(unsigned char *)(v3 + 22);
        long long v4 = (unsigned char *)(v3 + 22);
        char v5 = v6;
        if (v6) {
          break;
        }
        uint64_t v7 = v1 + 24 * v2;
        free(*(void **)(v7 + 8));
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(void *)(v7 + 16) = 0;
        int v8 = *(_DWORD *)(v1 + 384);
        if (v8) {
          unsigned int v2 = v8 - 1;
        }
        else {
          unsigned int v2 = 15;
        }
        *(_DWORD *)(v1 + 384) = v2;
        if (*(_DWORD *)(v1 + 388) == v2) {
          return 0;
        }
      }
      *long long v4 = v5 & 0xFE;
      return 1;
    }
  }
  return result;
}

void sub_244D0BC58(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 8))
    {
      uint64_t v2 = 0;
      unint64_t v3 = 0;
      do
      {
        uint64_t v4 = *(void *)a1 + v2;
        free(*(void **)(v4 + 8));
        *(void *)uint64_t v4 = 0;
        *(void *)(v4 + 8) = 0;
        *(void *)(v4 + 16) = 0;
        ++v3;
        v2 += 24;
      }
      while (v3 < *(void *)(a1 + 8));
    }
    free(*(void **)a1);
    free((void *)a1);
  }
}

void *sub_244D0BCE0()
{
  uint64_t v0 = sub_244D0B210();
  if (!v0) {
    return 0;
  }
  uint64_t v1 = v0;
  if (*((_DWORD *)v0 + 96) == *((_DWORD *)v0 + 97)) {
    return 0;
  }
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x1020040EDED9539uLL);
  if (!v2) {
    return v2;
  }
  unsigned int v4 = *((_DWORD *)v1 + 96);
  unsigned int v5 = *((_DWORD *)v1 + 97);
  if (v4 >= v5) {
    unsigned int v6 = *((_DWORD *)v1 + 96);
  }
  else {
    unsigned int v6 = v4 + 16;
  }
  unint64_t v7 = v6 - v5;
  int v8 = malloc_type_malloc(24 * v7, 0x10500400B811B97uLL);
  void *v2 = v8;
  if (!v8)
  {
    free(v2);
    return 0;
  }
  if (v6 == v5)
  {
    v2[1] = v7;
  }
  else
  {
    bzero(v8, 24 * (v6 - v5));
    uint64_t v9 = 0;
    v2[1] = v7;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v6 - v5;
    }
    uint64_t v11 = 24 * v10;
    int v12 = 1;
    do
    {
      sub_244D0BE04(*v2 + v9, (uint64_t)&v1[3 * ((v12 + *((_DWORD *)v1 + 97)) & 0xF)]);
      v9 += 24;
      ++v12;
    }
    while (v11 != v9);
  }
  return v2;
}

const char *sub_244D0BE04(uint64_t a1, uint64_t a2)
{
  free(*(void **)(a1 + 8));
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  uint64_t result = *(const char **)(a2 + 8);
  if (result)
  {
    uint64_t result = (const char *)sub_244D0BB10(result);
    *(void *)(a1 + 8) = result;
  }
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_WORD *)(a1 + 20) = *(_WORD *)(a2 + 20);
  return result;
}

void sub_244D0BE60(void *a1)
{
  if (a1 && (unint64_t v2 = a1[1]) != 0)
  {
    if (v2 >= 0x10) {
      abort();
    }
    unint64_t v3 = sub_244D0B210();
    if (v3)
    {
      unsigned int v4 = v3;
      if (a1[1])
      {
        uint64_t v5 = 0;
        unint64_t v6 = 0;
        do
        {
          sub_244D0BE04((uint64_t)&v4[v5], *a1 + v5 * 8);
          ++v6;
          unint64_t v7 = a1[1];
          v5 += 3;
        }
        while (v6 < v7);
        int v8 = v7 - 1;
      }
      else
      {
        int v8 = -1;
      }
      *((_DWORD *)v4 + 96) = v8;
      *((_DWORD *)v4 + 97) = 15;
    }
  }
  else
  {
    sub_244D0B1B0();
  }
}

void sub_244D0BF18(void **a1)
{
  if (a1)
  {
    for (uint64_t i = 0; i != 48; i += 3)
    {
      unint64_t v3 = &a1[i];
      free(a1[i + 1]);
      *unint64_t v3 = 0;
      v3[1] = 0;
      void v3[2] = 0;
    }
    free(a1[49]);
    free(a1);
  }
}

uint64_t sub_244D0BF88(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2 = *a1 >> 15;
  BOOL v3 = v2 >= *a2 >> 15;
  BOOL v4 = v2 > *a2 >> 15;
  if (v3) {
    return v4;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

double sub_244D0BFA4()
{
  uint64_t v0 = sub_244D44058(0x18uLL);
  if (v0)
  {
    *(void *)&double result = 1;
    void *v0 = 1;
  }
  return result;
}

void sub_244D0BFD0(uint64_t a1)
{
  if (a1 && sub_244D49A14((unsigned int *)a1))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2)
    {
      BOOL v3 = *(void (**)(uint64_t))(v2 + 160);
      if (v3)
      {
        v3(a1);
        *(void *)(a1 + 8) = 0;
        *(_DWORD *)(a1 + 4) = 0;
      }
    }
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D0C03C(unsigned int *a1)
{
  return 1;
}

uint64_t sub_244D0C058(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(uint64_t (**)(void))(v1 + 112)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t sub_244D0C074(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return 4294967294;
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 152);
  if (v5)
  {
    uint64_t result = v5(a1, a2);
    if ((int)result < 1) {
      return result;
    }
    uint64_t v3 = *(void *)(a1 + 16);
  }
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 40);
  if (!v7) {
    return 4294967294;
  }

  return v7(a1, a2);
}

uint64_t sub_244D0C108(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 4);
  if (v4)
  {
    if (v4 != *(_DWORD *)(a2 + 4))
    {
      int v5 = 103;
      __int16 v6 = 151;
LABEL_25:
      sub_244D0B884(6, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", v6);
      return 0;
    }
  }
  else
  {
    unint64_t v7 = *(_DWORD **)(a2 + 16);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8)
    {
      uint64_t v9 = *(void (**)(uint64_t))(v8 + 160);
      if (v9)
      {
        v9(a1);
        *(void *)(a1 + 8) = 0;
        *(_DWORD *)(a1 + 4) = 0;
      }
    }
    *(void *)(a1 + 16) = v7;
    *(_DWORD *)(a1 + 4) = *v7;
  }
  uint64_t v10 = *(void *)(a2 + 16);
  if (v10)
  {
    uint64_t v11 = *(unsigned int (**)(uint64_t))(v10 + 136);
    if (v11)
    {
      if (v11(a2))
      {
        int v5 = 118;
        __int16 v6 = 156;
        goto LABEL_25;
      }
    }
  }
  uint64_t v12 = *(void *)(a1 + 16);
  if (v12 && (uint64_t v13 = *(unsigned int (**)(uint64_t))(v12 + 136)) != 0 && v13(a1))
  {
    uint64_t v14 = *(void *)(a2 + 16);
    if (!v14) {
      return 0;
    }
    size_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v14 + 144);
    if (!v15) {
      return 0;
    }
    return v15(a1, a2);
  }
  else if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4) {
         || (uint64_t v17 = *(void *)(a1 + 16)) == 0
  }
         || (uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(v17 + 152)) == 0
         || (uint64_t result = v18(a1, a2), result != 1))
  {
    int v5 = 104;
    __int16 v6 = 165;
    goto LABEL_25;
  }
  return result;
}

uint64_t sub_244D0C274(uint64_t result, _DWORD *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 16);
  if (v4)
  {
    int v5 = *(uint64_t (**)(uint64_t))(v4 + 160);
    if (v5)
    {
      uint64_t result = v5(result);
      *(void *)(v3 + 8) = 0;
      *(_DWORD *)(v3 + 4) = 0;
    }
  }
  *(void *)(v3 + 16) = a2;
  *(_DWORD *)(v3 + 4) = *a2;
  return result;
}

uint64_t sub_244D0C2C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(uint64_t (**)(void))(v1 + 136)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t sub_244D0C2E0(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 && (uint64_t v3 = *(uint64_t (**)(void))(v2 + 152)) != 0) {
    return v3();
  }
  else {
    return 4294967294;
  }
}

uint64_t sub_244D0C314(uint64_t a1)
{
  if (a1 && (v1 = *(void *)(a1 + 16)) != 0 && (uint64_t v2 = *(uint64_t (**)(void))(v1 + 120)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t sub_244D0C334(uint64_t a1)
{
  if (a1 && (v1 = *(void *)(a1 + 16)) != 0 && (uint64_t v2 = *(uint64_t (**)(void))(v1 + 128)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

BOOL sub_244D0C354(uint64_t a1, int a2, uint64_t a3)
{
  char v3 = a2;
  if (a2 > 115)
  {
    if (a2 == 116)
    {
      return sub_244D0F07C(a1, a3);
    }
    else
    {
      if (a2 != 408) {
        goto LABEL_12;
      }
      return sub_244D0FD9C(a1, a3);
    }
  }
  else
  {
    if (a2 != 6)
    {
      if (a2 == 28)
      {
        return sub_244D0E868(a1, a3);
      }
LABEL_12:
      sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 250);
      sub_244D0BA04("algorithm %d", v5, v6, v7, v8, v9, v10, v11, v3);
      return 0;
    }
    return sub_244D11EDC(a1, a3);
  }
}

uint64_t sub_244D0C464(uint64_t a1, int a2)
{
  if (a1)
  {
    if (*(void *)(a1 + 8))
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = *(void (**)(uint64_t))(v4 + 160);
        if (v5)
        {
          v5(a1);
          *(void *)(a1 + 8) = 0;
          *(_DWORD *)(a1 + 4) = 0;
        }
      }
    }
  }
  if (a2 <= 407)
  {
    if (a2 == 6)
    {
      uint64_t v6 = &dword_26F955028;
      if (!a1) {
        return 1;
      }
LABEL_21:
      uint64_t v7 = *(void *)(a1 + 16);
      if (v7)
      {
        uint64_t v8 = *(void (**)(uint64_t))(v7 + 160);
        if (v8)
        {
          v8(a1);
          *(void *)(a1 + 8) = 0;
        }
      }
      *(void *)(a1 + 16) = v6;
      *(_DWORD *)(a1 + 4) = *v6;
      return 1;
    }
    if (a2 == 116)
    {
      uint64_t v6 = &dword_26F954C50;
      if (!a1) {
        return 1;
      }
      goto LABEL_21;
    }
  }
  else
  {
    switch(a2)
    {
      case 949:
        uint64_t v6 = &dword_26F954E90;
        if (!a1) {
          return 1;
        }
        goto LABEL_21;
      case 948:
        uint64_t v6 = &dword_26F955148;
        if (!a1) {
          return 1;
        }
        goto LABEL_21;
      case 408:
        uint64_t v6 = &dword_26F954D70;
        if (!a1) {
          return 1;
        }
        goto LABEL_21;
    }
  }
  sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 265);
  sub_244D0BA04("algorithm %d", v10, v11, v12, v13, v14, v15, v16, a2);
  return 0;
}

uint64_t sub_244D0C598(int a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (a1 == 948)
  {
    uint64_t v6 = &dword_26F955148;
  }
  else
  {
    if (a1 != 949)
    {
      sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 290);
      return 0;
    }
    uint64_t v6 = &dword_26F954E90;
  }
  uint64_t v7 = sub_244D44058(0x18uLL);
  uint64_t v8 = (uint64_t)v7;
  if (!v7) {
    goto LABEL_10;
  }
  *uint64_t v7 = 1;
  uint64_t v9 = v7[2];
  if (v9)
  {
    uint64_t v10 = *(void (**)(void *))(v9 + 160);
    if (v10)
    {
      v10(v7);
      *(void *)(v8 + 8) = 0;
    }
  }
  *(void *)(v8 + 16) = v6;
  *(_DWORD *)(v8 + 4) = *v6;
  if (!(*((unsigned int (**)(uint64_t, unint64_t *, uint64_t))v6 + 8))(v8, a3, a4))
  {
LABEL_10:
    sub_244D0BFD0(v8);
    return 0;
  }
  return v8;
}

uint64_t sub_244D0C674(int a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  if (a1 == 948)
  {
    uint64_t v6 = &dword_26F955148;
  }
  else
  {
    if (a1 != 949)
    {
      sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 324);
      return 0;
    }
    uint64_t v6 = &dword_26F954E90;
  }
  uint64_t v7 = sub_244D44058(0x18uLL);
  uint64_t v8 = (uint64_t)v7;
  if (!v7) {
    goto LABEL_10;
  }
  *uint64_t v7 = 1;
  uint64_t v9 = v7[2];
  if (v9)
  {
    uint64_t v10 = *(void (**)(void *))(v9 + 160);
    if (v10)
    {
      v10(v7);
      *(void *)(v8 + 8) = 0;
    }
  }
  *(void *)(v8 + 16) = v6;
  *(_DWORD *)(v8 + 4) = *v6;
  if (!(*((unsigned int (**)(uint64_t, _OWORD *, uint64_t))v6 + 9))(v8, a3, a4))
  {
LABEL_10:
    sub_244D0BFD0(v8);
    return 0;
  }
  return v8;
}

uint64_t sub_244D0C750(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 80);
  if (v1)
  {
    return v1();
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 348);
    return 0;
  }
}

uint64_t sub_244D0C7A8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 88);
  if (v1)
  {
    return v1();
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 358);
    return 0;
  }
}

uint64_t sub_244D0C800(uint64_t *a1)
{
  return sub_244D0D84C(a1, -1, 56);
}

uint64_t sub_244D0C818(uint64_t *a1)
{
  return sub_244D0D84C(a1, -1, 56);
}

uint64_t sub_244D0C830(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 96);
  if (v1)
  {
    return v1();
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 409);
    return 0;
  }
}

uint64_t sub_244D0C888(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 104);
  if (v1)
  {
    return v1();
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp.c", 418);
    return 0;
  }
}

uint64_t sub_244D0C8E0(long long *a1)
{
  long long v12 = 0uLL;
  long long v11 = 0uLL;
  v10[0] = 0;
  v10[1] = 0;
  char v9 = 0;
  if (!sub_244CFCD34(a1, &v12, 536870928)
    || !sub_244CFCD34(&v12, &v11, 536870928)
    || !sub_244CFCD34(&v12, v10, 3)
    || *((void *)&v12 + 1))
  {
    int v6 = 102;
    __int16 v7 = 106;
LABEL_13:
    sub_244D0B884(6, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", v7);
    return 0;
  }
  uint64_t v1 = sub_244D0CA44(&v11);
  if (!v1)
  {
    int v6 = 128;
    __int16 v7 = 111;
    goto LABEL_13;
  }
  uint64_t v2 = v1;
  if (!sub_244CFC650(v10, &v9) || v9)
  {
    int v6 = 102;
    __int16 v7 = 118;
    goto LABEL_13;
  }
  sub_244D0BFA4();
  uint64_t v4 = v3;
  if (!v3)
  {
LABEL_19:
    sub_244D0BFD0(v4);
    return 0;
  }
  sub_244D0C274(v3, v2);
  uint64_t v5 = *(unsigned int (**)(uint64_t, long long *, void *))(*(void *)(v4 + 16) + 24);
  if (!v5)
  {
    sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 131);
    goto LABEL_19;
  }
  if (!v5(v4, &v11, v10)) {
    goto LABEL_19;
  }
  return v4;
}

int *sub_244D0CA44(long long *a1)
{
  int v6 = 0;
  size_t v7 = 0;
  if (!sub_244CFCD34(a1, &v6, 6)) {
    return 0;
  }
  uint64_t v1 = 0;
  uint64_t v3 = v6;
  size_t v2 = v7;
  while (1)
  {
    uint64_t v4 = off_26519D9C0[v1];
    if (v2 == *((unsigned __int8 *)v4 + 13) && (!*((unsigned char *)v4 + 13) || !memcmp(v3, v4 + 1, v2))) {
      break;
    }
    if (++v1 == 5) {
      return 0;
    }
  }
  return v4;
}

uint64_t sub_244D0CAD8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2 && (uint64_t v3 = *(uint64_t (**)(void))(v2 + 32)) != 0)
  {
    return v3();
  }
  else
  {
    sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 147);
    return 0;
  }
}

uint64_t sub_244D0CB34(long long *a1)
{
  long long v12 = 0uLL;
  long long v11 = 0uLL;
  v10[0] = 0;
  v10[1] = 0;
  unint64_t v9 = 0;
  if (!sub_244CFCD34(a1, &v12, 536870928)
    || !sub_244CFCEF4(&v12, &v9)
    || v9
    || !sub_244CFCD34(&v12, &v11, 536870928)
    || !sub_244CFCD34(&v12, v10, 4))
  {
    int v6 = 102;
    __int16 v7 = 163;
LABEL_12:
    sub_244D0B884(6, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", v7);
    return 0;
  }
  uint64_t v1 = sub_244D0CA44(&v11);
  if (!v1)
  {
    int v6 = 128;
    __int16 v7 = 168;
    goto LABEL_12;
  }
  uint64_t v2 = v1;
  sub_244D0BFA4();
  uint64_t v4 = v3;
  if (!v3)
  {
LABEL_17:
    sub_244D0BFD0(v4);
    return 0;
  }
  sub_244D0C274(v3, v2);
  uint64_t v5 = *(unsigned int (**)(uint64_t, long long *, void *))(*(void *)(v4 + 16) + 48);
  if (!v5)
  {
    sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 183);
    goto LABEL_17;
  }
  if (!v5(v4, &v11, v10)) {
    goto LABEL_17;
  }
  return v4;
}

uint64_t sub_244D0CC74(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2 && (uint64_t v3 = *(uint64_t (**)(void))(v2 + 56)) != 0)
  {
    return v3();
  }
  else
  {
    sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 199);
    return 0;
  }
}

uint64_t sub_244D0CCD0(int a1, uint64_t *a2, void *a3, uint64_t a4)
{
  if (a4 < 0)
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 250);
    return 0;
  }
  *(void *)&long long v15 = *a3;
  *((void *)&v15 + 1) = a4;
  sub_244D0BFA4();
  if (v8)
  {
    uint64_t v9 = v8;
    switch(a1)
    {
      case 6:
        long long v11 = sub_244D49D4C(&v15);
        if (v11 && sub_244D11EDC(v9, (uint64_t)v11)) {
          goto LABEL_20;
        }
        sub_244D3306C((uint64_t)v11);
        break;
      case 116:
        long long v12 = sub_244D09014(&v15);
        if (v12 && sub_244D0F07C(v9, (uint64_t)v12)) {
          goto LABEL_20;
        }
        sub_244D07330((uint64_t)v12);
        break;
      case 408:
        uint64_t v10 = sub_244D095FC(&v15, 0);
        if (v10 && sub_244D0FD9C(v9, v10)) {
          goto LABEL_20;
        }
        sub_244D2A380(v10);
        break;
      default:
        sub_244D0B884(6, 0, 127, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 238);
        break;
    }
    sub_244D0BFD0(v9);
  }
  sub_244D0B1B0();
  *(void *)&long long v15 = *a3;
  *((void *)&v15 + 1) = a4;
  uint64_t v13 = sub_244D0CB34(&v15);
  uint64_t v9 = v13;
  if (!v13) {
    return v9;
  }
  if (*(_DWORD *)(v13 + 4) != a1)
  {
    sub_244D0B884(6, 0, 103, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 267);
    sub_244D0BFD0(v9);
    return 0;
  }
LABEL_20:
  if (a2)
  {
    sub_244D0BFD0(*a2);
    *a2 = v9;
  }
  *a3 = v15;
  return v9;
}

uint64_t sub_244D0CE80(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0)
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 305);
    return 0;
  }
  else
  {
    *(void *)&long long v12 = *a2;
    *((void *)&v12 + 1) = a3;
    uint64_t v6 = sub_244D0CB34(&v12);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1)
      {
        sub_244D0BFD0(*a1);
        *a1 = v7;
      }
      *a2 = v12;
    }
    else
    {
      sub_244D0B1B0();
      uint64_t v8 = *a2;
      long long v13 = 0uLL;
      *(void *)&long long v14 = v8;
      *((void *)&v14 + 1) = a3;
      if (sub_244CFCD34(&v14, &v13, 536870928) && *((void *)&v13 + 1))
      {
        uint64_t v9 = -1;
        while (sub_244CFCB34(&v13, 0, 0, 0))
        {
          ++v9;
          if (!*((void *)&v13 + 1))
          {
            if (v9 == 5)
            {
              int v10 = 116;
            }
            else
            {
              if (v9 != 3) {
                break;
              }
              int v10 = 408;
            }
            return sub_244D0CCD0(v10, a1, a2, a3);
          }
        }
      }
      int v10 = 6;
      return sub_244D0CCD0(v10, a1, a2, a3);
    }
  }
  return v7;
}

uint64_t sub_244D0CFA8(uint64_t a1, void **a2)
{
  int v3 = *(_DWORD *)(a1 + 4);
  switch(v3)
  {
    case 408:
      uint64_t v6 = sub_244D0FDD8(a1);
      return sub_244D0A58C(v6, a2);
    case 116:
      uint64_t v7 = (uint64_t **)sub_244D0F0B8(a1);
      return sub_244D093B8(v7, a2);
    case 6:
      uint64_t v4 = sub_244D11F18(a1);
      return sub_244D4A19C(v4, a2);
    default:
      sub_244D0B884(6, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 345);
      return 0xFFFFFFFFLL;
  }
}

uint64_t sub_244D0D070(int a1, uint64_t *a2, void *a3, uint64_t a4)
{
  sub_244D0BFA4();
  uint64_t v9 = v8;
  if (!v8) {
    return v9;
  }
  *(void *)&long long v12 = *a3;
  *((void *)&v12 + 1) = a4 & ~(a4 >> 63);
  if (a1 != 6)
  {
    sub_244D0B884(6, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_asn1.c", 375);
LABEL_9:
    sub_244D0BFD0(v9);
    return 0;
  }
  int v10 = sub_244D49A68(&v12);
  if (!v10 || !sub_244D11EDC(v9, (uint64_t)v10))
  {
    sub_244D3306C((uint64_t)v10);
    goto LABEL_9;
  }
  *a3 = v12;
  if (a2)
  {
    sub_244D0BFD0(*a2);
    *a2 = v9;
  }
  return v9;
}

uint64_t sub_244D0D148(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  uint64_t v5 = sub_244D0C8E0(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D0BFD0(*a1);
      *a1 = v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D0D1BC(uint64_t result, void **a2)
{
  if (result)
  {
    uint64_t v3 = result;
    memset(v4, 0, sizeof(v4));
    if (sub_244CFB3DC((uint64_t)v4, 0x80uLL) && sub_244D0CAD8((uint64_t)v4, v3))
    {
      return sub_244CFAE28((uint64_t)v4, a2);
    }
    else
    {
      sub_244CFB470((uint64_t)v4);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_244D0D238(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v9 = *a2;
  *((void *)&v9 + 1) = a3;
  uint64_t v5 = sub_244D0C8E0(&v9);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = sub_244D11F60(v5);
  sub_244D0BFD0(v6);
  if (v7)
  {
    if (a1)
    {
      sub_244D3306C(*a1);
      *a1 = v7;
    }
    *a2 = v9;
  }
  return v7;
}

uint64_t sub_244D0D2C0(uint64_t a1, void **a2)
{
  if (!a1) {
    return 0;
  }
  sub_244D0BFA4();
  uint64_t v5 = v4;
  if (v4 && sub_244D11E90(v4, a1)) {
    uint64_t v6 = sub_244D0D1BC(v5, a2);
  }
  else {
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  sub_244D0BFD0(v5);
  return v6;
}

uint64_t sub_244D0D338(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v9 = *a2;
  *((void *)&v9 + 1) = a3;
  uint64_t v5 = sub_244D0C8E0(&v9);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = sub_244D0F100(v5);
  sub_244D0BFD0(v6);
  if (v7)
  {
    if (a1)
    {
      sub_244D07330(*a1);
      *a1 = v7;
    }
    *a2 = v9;
  }
  return v7;
}

uint64_t sub_244D0D3C0(uint64_t a1, void **a2)
{
  if (!a1) {
    return 0;
  }
  sub_244D0BFA4();
  uint64_t v5 = v4;
  if (v4 && sub_244D0F030(v4, a1)) {
    uint64_t v6 = sub_244D0D1BC(v5, a2);
  }
  else {
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  sub_244D0BFD0(v5);
  return v6;
}

uint64_t sub_244D0D438(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v9 = *a2;
  *((void *)&v9 + 1) = a3;
  uint64_t v5 = sub_244D0C8E0(&v9);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = sub_244D0FE20(v5);
  sub_244D0BFD0(v6);
  if (v7)
  {
    if (a1)
    {
      sub_244D2A380(*a1);
      *a1 = v7;
    }
    *a2 = v9;
  }
  return v7;
}

uint64_t sub_244D0D4C0(uint64_t a1, void **a2)
{
  if (!a1) {
    return 0;
  }
  sub_244D0BFA4();
  uint64_t v5 = v4;
  if (v4 && sub_244D0FD50(v4, a1)) {
    uint64_t v6 = sub_244D0D1BC(v5, a2);
  }
  else {
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  sub_244D0BFD0(v5);
  return v6;
}

void *sub_244D0D538(uint64_t a1, uint64_t a2)
{
  if (!a1 || (uint64_t v3 = *(void *)(a1 + 16)) == 0)
  {
    sub_244D0B884(6, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 116);
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 16);
  if (!v4)
  {
    sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 122);
    sub_244D0BA04("algorithm %d", v6, v7, v8, v9, v10, v11, v12, **(_DWORD **)(a1 + 16));
    return 0;
  }

  return sub_244D0D5F0((unsigned int *)a1, a2, v4);
}

void *sub_244D0D5F0(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_244D44058(0x30uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *uint64_t v6 = a3;
    v6[1] = a2;
    *((_DWORD *)v6 + 8) = 0;
    if (a1)
    {
      sub_244D0C03C(a1);
      v7[2] = a1;
    }
    uint64_t v8 = *(int (**)(void *))(a3 + 8);
    if (v8 && v8(v7) <= 0)
    {
      sub_244D0BFD0(v7[2]);
      sub_244D440EC(v7);
      return 0;
    }
  }
  return v7;
}

void *sub_244D0D678(int a1, uint64_t a2)
{
  char v2 = a1;
  uint64_t v3 = 0;
  while (1)
  {
    uint64_t v4 = *(_UNKNOWN **)((char *)&off_26519D9E8 + v3);
    if (*v4 == a1) {
      break;
    }
    v3 += 8;
    if (v3 == 40)
    {
      sub_244D0B884(6, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 133);
      sub_244D0BA04("algorithm %d", v5, v6, v7, v8, v9, v10, v11, v2);
      return 0;
    }
  }

  return sub_244D0D5F0(0, a2, (uint64_t)v4);
}

void sub_244D0D71C(uint64_t *a1)
{
  if (a1)
  {
    if (*a1)
    {
      char v2 = *(void (**)(uint64_t *))(*a1 + 24);
      if (v2) {
        v2(a1);
      }
    }
    sub_244D0BFD0(a1[2]);
    sub_244D0BFD0(a1[3]);
    sub_244D440EC(a1);
  }
}

uint64_t *sub_244D0D780(uint64_t a1)
{
  if (!*(void *)a1 || !*(void *)(*(void *)a1 + 16)) {
    return 0;
  }
  char v2 = sub_244D44058(0x30uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t *v2 = *(void *)a1;
    v2[1] = *(void *)(a1 + 8);
    *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
    uint64_t v4 = *(unsigned int **)(a1 + 16);
    if (v4)
    {
      sub_244D0C03C(v4);
      void v3[2] = *(void *)(a1 + 16);
    }
    uint64_t v5 = *(unsigned int **)(a1 + 24);
    if (v5)
    {
      sub_244D0C03C(v5);
      v3[3] = *(void *)(a1 + 24);
    }
    if ((*(int (**)(uint64_t *, uint64_t))(*(void *)a1 + 16))(v3, a1) <= 0)
    {
      *uint64_t v3 = 0;
      sub_244D0D71C(v3);
      sub_244D0B884(6, 0, 6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 180);
      return 0;
    }
  }
  return v3;
}

uint64_t sub_244D0D84C(uint64_t *a1, int a2, int a3)
{
  if (!a1 || (uint64_t v3 = *a1) == 0 || (v4 = *(uint64_t (**)(void))(v3 + 112)) == 0)
  {
    int v6 = 101;
    __int16 v7 = 192;
    goto LABEL_11;
  }
  if (a2 != -1 && *(_DWORD *)v3 != a2)
  {
    int v6 = 125;
    __int16 v7 = 196;
    goto LABEL_11;
  }
  int v5 = *((_DWORD *)a1 + 8);
  if (!v5)
  {
    int v6 = 123;
    __int16 v7 = 201;
    goto LABEL_11;
  }
  if (a3 != -1 && (v5 & a3) == 0)
  {
    int v6 = 114;
    __int16 v7 = 206;
LABEL_11:
    sub_244D0B884(6, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v7);
    return 0;
  }

  return v4();
}

uint64_t sub_244D0D938(uint64_t *a1)
{
  if (a1 && (uint64_t v1 = *a1) != 0 && (*(void *)(v1 + 40) || *(void *)(v1 + 48)))
  {
    *((_DWORD *)a1 + 8) = 8;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 216);
    return 0;
  }
}

uint64_t sub_244D0D998(_DWORD *a1)
{
  if (!a1 || !*(void *)a1 || (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 40)) == 0)
  {
    int v3 = 125;
    __int16 v4 = 227;
LABEL_9:
    sub_244D0B884(6, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v4);
    return 0;
  }
  if (a1[8] != 8)
  {
    int v3 = 126;
    __int16 v4 = 231;
    goto LABEL_9;
  }

  return v1();
}

uint64_t sub_244D0DA20(uint64_t *a1)
{
  if (a1 && (uint64_t v1 = *a1) != 0 && (*(void *)(v1 + 56) || *(void *)(v1 + 64)))
  {
    *((_DWORD *)a1 + 8) = 16;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 240);
    return 0;
  }
}

uint64_t sub_244D0DA80(_DWORD *a1)
{
  if (!a1 || !*(void *)a1 || (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 56)) == 0)
  {
    int v3 = 125;
    __int16 v4 = 250;
LABEL_9:
    sub_244D0B884(6, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v4);
    return 0;
  }
  if (a1[8] != 16)
  {
    int v3 = 126;
    __int16 v4 = 254;
    goto LABEL_9;
  }

  return v1();
}

uint64_t sub_244D0DB08(_DWORD *a1)
{
  if (a1 && *(void *)a1 && *(void *)(*(void *)a1 + 80))
  {
    a1[8] = 64;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 262);
    return 0;
  }
}

uint64_t sub_244D0DB60(_DWORD *a1)
{
  if (!a1 || !*(void *)a1 || (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 80)) == 0)
  {
    int v3 = 125;
    __int16 v4 = 272;
LABEL_9:
    sub_244D0B884(6, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v4);
    return 0;
  }
  if (a1[8] != 64)
  {
    int v3 = 126;
    __int16 v4 = 276;
    goto LABEL_9;
  }

  return v1();
}

uint64_t sub_244D0DBE8(_DWORD *a1)
{
  if (a1 && *(void *)a1 && *(void *)(*(void *)a1 + 88))
  {
    a1[8] = 128;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 284);
    return 0;
  }
}

uint64_t sub_244D0DC40(_DWORD *a1)
{
  if (!a1 || !*(void *)a1 || (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 88)) == 0)
  {
    int v3 = 125;
    __int16 v4 = 294;
LABEL_9:
    sub_244D0B884(6, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v4);
    return 0;
  }
  if (a1[8] != 128)
  {
    int v3 = 126;
    __int16 v4 = 298;
    goto LABEL_9;
  }

  return v1();
}

uint64_t sub_244D0DCC8(_DWORD *a1)
{
  if (a1 && *(void *)a1 && *(void *)(*(void *)a1 + 72))
  {
    a1[8] = 32;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 306);
    return 0;
  }
}

uint64_t sub_244D0DD20(_DWORD *a1)
{
  if (!a1 || !*(void *)a1 || (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 72)) == 0)
  {
    int v3 = 125;
    __int16 v4 = 316;
LABEL_9:
    sub_244D0B884(6, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v4);
    return 0;
  }
  if (a1[8] != 32)
  {
    int v3 = 126;
    __int16 v4 = 320;
    goto LABEL_9;
  }

  return v1();
}

uint64_t sub_244D0DDA8(_DWORD *a1)
{
  if (a1 && *(void *)a1 && *(void *)(*(void *)a1 + 96))
  {
    a1[8] = 256;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 328);
    return 0;
  }
}

uint64_t sub_244D0DE00(uint64_t a1, unsigned int *a2)
{
  if (!a1
    || (int v3 = *(void **)a1) == 0
    || !v3[12] && !v3[10] && !v3[11]
    || (int v5 = (uint64_t (*)(uint64_t, uint64_t, void, unsigned int *))v3[14]) == 0)
  {
    int v9 = 125;
    __int16 v10 = 340;
LABEL_14:
    sub_244D0B884(6, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v10);
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 32);
  if (v6 != 64 && v6 != 128 && v6 != 256)
  {
    int v9 = 126;
    __int16 v10 = 346;
    goto LABEL_14;
  }
  int v7 = v5(a1, 3, 0, a2);
  if (v7 < 1) {
    return 0;
  }
  if (v7 == 2) {
    return 1;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  if (!v11)
  {
    int v9 = 120;
    __int16 v10 = 361;
    goto LABEL_14;
  }
  if (*(_DWORD *)(v11 + 4) != a2[1])
  {
    int v9 = 103;
    __int16 v10 = 366;
    goto LABEL_14;
  }
  if (!sub_244D0C2C4((uint64_t)a2) && !sub_244D0C2E0(*(void *)(a1 + 16), (uint64_t)a2))
  {
    int v9 = 104;
    __int16 v10 = 377;
    goto LABEL_14;
  }
  sub_244D0BFD0(*(void *)(a1 + 24));
  *(void *)(a1 + 24) = a2;
  if ((*(int (**)(uint64_t, uint64_t, uint64_t, unsigned int *))(*(void *)a1 + 112))(a1, 3, 1, a2) > 0)
  {
    sub_244D0C03C(a2);
    return 1;
  }
  uint64_t result = 0;
  *(void *)(a1 + 24) = 0;
  return result;
}

uint64_t sub_244D0DFA4(_DWORD *a1)
{
  if (!a1 || !*(void *)a1 || (uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 96)) == 0)
  {
    int v3 = 125;
    __int16 v4 = 397;
LABEL_9:
    sub_244D0B884(6, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v4);
    return 0;
  }
  if (a1[8] != 256)
  {
    int v3 = 126;
    __int16 v4 = 401;
    goto LABEL_9;
  }

  return v1();
}

uint64_t sub_244D0E02C(_DWORD *a1)
{
  if (a1 && *(void *)a1 && *(void *)(*(void *)a1 + 32))
  {
    a1[8] = 4;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 409);
    return 0;
  }
}

uint64_t sub_244D0E084(_DWORD *a1, uint64_t *a2)
{
  if (!a1 || !*(void *)a1 || (int v3 = *(unsigned int (**)(_DWORD *))(*(void *)a1 + 32)) == 0)
  {
    int v7 = 125;
    __int16 v8 = 418;
LABEL_12:
    sub_244D0B884(6, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v8);
    return 0;
  }
  if (a1[8] != 4)
  {
    int v7 = 126;
    __int16 v8 = 422;
    goto LABEL_12;
  }
  if (!a2) {
    return 0;
  }
  if (*a2) {
    goto LABEL_9;
  }
  sub_244D0BFA4();
  *a2 = v5;
  if (!v5)
  {
    int v7 = 6;
    __int16 v8 = 433;
    goto LABEL_12;
  }
  int v3 = *(unsigned int (**)(_DWORD *))(*(void *)a1 + 32);
LABEL_9:
  if (v3(a1)) {
    return 1;
  }
  sub_244D0BFD0(*a2);
  uint64_t result = 0;
  *a2 = 0;
  return result;
}

uint64_t sub_244D0E168(_DWORD *a1)
{
  if (a1 && *(void *)a1 && *(void *)(*(void *)a1 + 104))
  {
    a1[8] = 512;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", 448);
    return 0;
  }
}

uint64_t sub_244D0E1C0(_DWORD *a1, uint64_t *a2)
{
  if (!a1 || !*(void *)a1 || (int v3 = *(unsigned int (**)(_DWORD *))(*(void *)a1 + 104)) == 0)
  {
    int v7 = 125;
    __int16 v8 = 457;
LABEL_12:
    sub_244D0B884(6, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/evp_ctx.c", v8);
    return 0;
  }
  if (a1[8] != 512)
  {
    int v7 = 126;
    __int16 v8 = 461;
    goto LABEL_12;
  }
  if (!a2) {
    return 0;
  }
  if (*a2) {
    goto LABEL_9;
  }
  sub_244D0BFA4();
  *a2 = v5;
  if (!v5)
  {
    int v7 = 6;
    __int16 v8 = 472;
    goto LABEL_12;
  }
  int v3 = *(unsigned int (**)(_DWORD *))(*(void *)a1 + 104);
LABEL_9:
  if (v3(a1)) {
    return 1;
  }
  sub_244D0BFD0(*a2);
  uint64_t result = 0;
  *a2 = 0;
  return result;
}

uint64_t sub_244D0E2A4(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_244D44058(4uLL);
  if (result)
  {
    *(void *)(a1 + 40) = result;
    return 1;
  }
  return result;
}

uint64_t sub_244D0E2D8(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)sub_244D44058(4uLL);
  if (result)
  {
    *(void *)(a1 + 40) = result;
    *(_DWORD *)uint64_t result = **(_DWORD **)(a2 + 40);
    return 1;
  }
  return result;
}

void sub_244D0E31C(uint64_t a1)
{
  *(void *)(a1 + 40) = 0;
}

uint64_t sub_244D0E348(uint64_t a1, uint64_t a2)
{
  __int16 v4 = sub_244D24C2C();
  if (!v4 || !sub_244D0E868(a2, (uint64_t)v4))
  {
    sub_244D24C6C((uint64_t)v4);
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5 && !sub_244D0C108(a2, v5)) {
    return 0;
  }

  return sub_244D24E0C((uint64_t)v4);
}

uint64_t sub_244D0E3D4(void *a1, char *a2, unint64_t *a3)
{
  uint64_t v3 = a1[2];
  if (!v3 || (uint64_t v4 = a1[3]) == 0)
  {
    int v7 = 117;
    __int16 v8 = 68;
    goto LABEL_10;
  }
  uint64_t v5 = *(uint64_t ***)(v3 + 8);
  if (v5) {
    BOOL v6 = *(void *)(v4 + 8) == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    int v7 = 117;
    __int16 v8 = 75;
LABEL_10:
    sub_244D0B884(6, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dh.c", v8);
    return 0;
  }
  uint64_t v12 = (_DWORD *)a1[5];
  uint64_t v13 = sub_244D073FC(*(void *)(v4 + 8));
  if (!v13)
  {
    int v7 = 117;
    __int16 v8 = 81;
    goto LABEL_10;
  }
  if (a2)
  {
    uint64_t v14 = v13;
    unint64_t v15 = *a3;
    if (v15 < (int)sub_244D250B8(v5))
    {
      int v7 = 100;
      __int16 v8 = 91;
      goto LABEL_10;
    }
    if (*v12) {
      unsigned int v17 = sub_244D252A4(a2, v14, v5);
    }
    else {
      unsigned int v17 = sub_244D252A8(a2, v14, (uint64_t)v5);
    }
    if ((v17 & 0x80000000) != 0) {
      return 0;
    }
    unint64_t v16 = v17;
  }
  else
  {
    unint64_t v16 = (int)sub_244D250B8(v5);
  }
  *a3 = v16;
  return 1;
}

uint64_t sub_244D0E51C(uint64_t a1, int a2, int a3)
{
  if (a2 == 3) {
    return 1;
  }
  if (a2 == 4115)
  {
    **(_DWORD **)(a1 + 40) = a3;
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dh.c", 119);
    return 0;
  }
}

uint64_t sub_244D0E580(uint64_t *a1)
{
  return sub_244D0D84C(a1, 28, 256);
}

BOOL sub_244D0E598(uint64_t a1, uint64_t a2)
{
  if ((int)sub_244D0E74C(a1, a2) < 1) {
    return 0;
  }
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = sub_244D073FC(*(void *)(a1 + 8));
  uint64_t v6 = sub_244D073FC(v4);
  return sub_244D17194(v5, v6) == 0;
}

uint64_t sub_244D0E5FC(uint64_t a1)
{
  return sub_244D250B8(*(uint64_t ***)(a1 + 8));
}

uint64_t sub_244D0E604(uint64_t a1)
{
  return sub_244D073F4(*(uint64_t ***)(a1 + 8));
}

BOOL sub_244D0E60C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  return !v1 || !sub_244D0740C(*(void *)(a1 + 8)) || sub_244CF48E8(v1) == 0;
}

uint64_t sub_244D0E654(uint64_t a1, uint64_t a2)
{
  if (sub_244D0E60C(a2))
  {
    sub_244D0B884(6, 0, 118, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dh_asn1.c", 36);
  }
  else
  {
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = sub_244D07414(v4);
    uint64_t v6 = sub_244D0740C(v4);
    int v7 = sub_244D16714(v6);
    if (v5) {
      __int16 v8 = sub_244D16714(v5);
    }
    else {
      __int16 v8 = 0;
    }
    uint64_t v9 = sub_244CF48E8(v4);
    __int16 v10 = sub_244D16714(v9);
    uint64_t v11 = v10;
    if (v7)
    {
      BOOL v12 = v8 || v5 == 0;
      if (v12 && v10 && sub_244D24D70(*(void *)(a1 + 8), (uint64_t)v7, (uint64_t)v8, (uint64_t)v10)) {
        return 1;
      }
    }
    sub_244D166B0((void **)v7);
    sub_244D166B0((void **)v8);
    sub_244D166B0((void **)v11);
  }
  return 0;
}

uint64_t sub_244D0E74C(uint64_t a1, uint64_t a2)
{
  if (sub_244D0E60C(a1) || sub_244D0E60C(a2)) {
    return 4294967294;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = sub_244D0740C(v5);
  uint64_t v8 = sub_244D0740C(v6);
  if (sub_244D17194(v7, v8)) {
    return 0;
  }
  uint64_t v9 = sub_244CF48E8(v5);
  uint64_t v10 = sub_244CF48E8(v6);
  return sub_244D17194(v9, v10) == 0;
}

void sub_244D0E7F0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_244D0E81C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  if (!a2) {
    return 0;
  }
  sub_244D25508(a2);
  return 1;
}

BOOL sub_244D0E868(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  return a2 != 0;
}

uint64_t sub_244D0E8A4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 28) {
    return *(void *)(a1 + 8);
  }
  sub_244D0B884(6, 0, 138, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dh_asn1.c", 108);
  return 0;
}

uint64_t sub_244D0E8EC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 28)
  {
    uint64_t v1 = *(void *)(a1 + 8);
    if (v1) {
      sub_244D25508(*(void *)(a1 + 8));
    }
  }
  else
  {
    sub_244D0B884(6, 0, 138, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dh_asn1.c", 108);
    return 0;
  }
  return v1;
}

uint64_t sub_244D0E94C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v6 = sub_244D08E7C((long long *)a2);
    if (!v6 || *(void *)(a2 + 8))
    {
      __int16 v7 = 81;
LABEL_10:
      sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dsa_asn1.c", v7);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t result = (uint64_t)sub_244D072E8();
    uint64_t v6 = (uint64_t *)result;
    if (!result) {
      return result;
    }
  }
  uint64_t v9 = sub_244D16670();
  _OWORD v6[3] = (uint64_t)v9;
  if (v9)
  {
    if (sub_244CFA034((long long *)a3, v9) && !*(void *)(a3 + 8))
    {
      sub_244D0C274(a1, &dword_26F954C50);
      *(void *)(a1 + 8) = v6;
      return 1;
    }
    __int16 v7 = 93;
    goto LABEL_10;
  }
LABEL_11:
  sub_244D07330((uint64_t)v6);
  return 0;
}

uint64_t sub_244D0EA18(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = *(void *)v3 && *(void *)(v3 + 8) && *(void *)(v3 + 16) != 0;
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  if (sub_244CFB808(a1, (uint64_t)v9, 0x20000010u)
    && sub_244CFB808((uint64_t *)v9, (uint64_t)v8, 0x20000010u)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v7, 6u)
    && sub_244CFBA40((uint64_t)v7, &unk_26F954C54, 7uLL)
    && (!v4 || sub_244D08F64((uint64_t *)v8, (uint64_t **)v3))
    && sub_244CFB808((uint64_t *)v9, (uint64_t)v6, 3u)
    && sub_244CFB8C4((uint64_t)v6, 0)
    && sub_244CFA0E0((uint64_t *)v6, *(uint64_t **)(v3 + 24))
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(6, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dsa_asn1.c", 121);
  return 0;
}

BOOL sub_244D0EB68(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = sub_244D073FC(*(void *)(a2 + 8));
  uint64_t v4 = sub_244D073FC(v2);
  return sub_244D17194(v3, v4) == 0;
}

uint64_t sub_244D0EBB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_244D08E7C((long long *)a2);
  if (!v6 || *(void *)(a2 + 8))
  {
    __int16 v7 = 135;
LABEL_4:
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dsa_asn1.c", v7);
LABEL_5:
    uint64_t v8 = 0;
LABEL_6:
    sub_244D17500(v8);
    sub_244D07330((uint64_t)v6);
    return 0;
  }
  uint64_t v10 = sub_244D16670();
  v6[4] = (uint64_t)v10;
  if (!v10) {
    goto LABEL_5;
  }
  if (!sub_244CFA034((long long *)a3, v10) || *(void *)(a3 + 8))
  {
    __int16 v7 = 145;
    goto LABEL_4;
  }
  if (!sub_244D088CC(v6))
  {
    __int16 v7 = 153;
    goto LABEL_4;
  }
  sub_244D174D4();
  uint64_t v8 = v11;
  BOOL v12 = sub_244D16670();
  _OWORD v6[3] = (uint64_t)v12;
  if (!v8 || !v12 || !sub_244D1A91C((uint64_t)v12, v6[2], v6[4], *v6, (uint64_t)v8, 0)) {
    goto LABEL_6;
  }
  sub_244D17500(v8);
  sub_244D0C274(a1, &dword_26F954C50);
  *(void *)(a1 + 8) = v6;
  return 1;
}

uint64_t sub_244D0ECC4(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t ***)(a2 + 8);
  if (v2 && v2[4])
  {
    memset(v10, 0, sizeof(v10));
    memset(v9, 0, sizeof(v9));
    memset(v8, 0, sizeof(v8));
    memset(v7, 0, sizeof(v7));
    if (sub_244CFB808(a1, (uint64_t)v10, 0x20000010u)
      && sub_244CFBDDC((uint64_t)v10, 0)
      && sub_244CFB808((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
      && sub_244CFB808((uint64_t *)v9, (uint64_t)v8, 6u)
      && sub_244CFBA40((uint64_t)v8, &unk_26F954C54, 7uLL)
      && sub_244D08F64((uint64_t *)v9, v2)
      && sub_244CFB808((uint64_t *)v10, (uint64_t)v7, 4u)
      && sub_244CFA0E0((uint64_t *)v7, v2[4])
      && sub_244CFB540(a1))
    {
      return 1;
    }
    int v5 = 105;
    __int16 v6 = 194;
  }
  else
  {
    int v5 = 118;
    __int16 v6 = 179;
  }
  sub_244D0B884(6, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dsa_asn1.c", v6);
  return 0;
}

uint64_t *sub_244D0EE08(uint64_t a1)
{
  return sub_244D0874C(*(void *)(a1 + 8));
}

uint64_t sub_244D0EE10(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)sub_244D0740C(*(void *)(a1 + 8));

  return sub_244D168EC(v1);
}

BOOL sub_244D0EE3C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  return !sub_244D0740C(v1) || !sub_244CF48E8(v1) || sub_244D07414(v1) == 0;
}

void **sub_244D0EE8C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ****)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(a2 + 8);
  if (!sub_244D0F160(v2, *v3) || !sub_244D0F160(v2 + 1, v3[1])) {
    return 0;
  }
  uint64_t v4 = v3[2];

  return sub_244D0F160(v2 + 2, v4);
}

BOOL sub_244D0EEF8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = sub_244D0740C(v2);
  uint64_t v5 = sub_244D0740C(v3);
  if (sub_244D17194(v4, v5)) {
    return 0;
  }
  uint64_t v6 = sub_244CF48E8(v2);
  uint64_t v7 = sub_244CF48E8(v3);
  if (sub_244D17194(v6, v7)) {
    return 0;
  }
  uint64_t v9 = sub_244D07414(v2);
  uint64_t v10 = sub_244D07414(v3);
  return sub_244D17194(v9, v10) == 0;
}

void sub_244D0EF9C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_244D0EFC8()
{
  return 0;
}

uint64_t sub_244D0EFFC()
{
  return 0;
}

uint64_t sub_244D0F030(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  if (!a2) {
    return 0;
  }
  sub_244D073D4(a2);
  return 1;
}

BOOL sub_244D0F07C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  return a2 != 0;
}

uint64_t sub_244D0F0B8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 116) {
    return *(void *)(a1 + 8);
  }
  sub_244D0B884(6, 0, 108, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dsa_asn1.c", 326);
  return 0;
}

uint64_t sub_244D0F100(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 116)
  {
    uint64_t v1 = *(void *)(a1 + 8);
    if (v1) {
      sub_244D073D4(*(void *)(a1 + 8));
    }
  }
  else
  {
    sub_244D0B884(6, 0, 108, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_dsa_asn1.c", 326);
    return 0;
  }
  return v1;
}

void **sub_244D0F160(void ***a1, uint64_t a2)
{
  uint64_t result = sub_244D16714(a2);
  if (result)
  {
    uint64_t v4 = result;
    sub_244D166B0((void **)*a1);
    *a1 = v4;
    return (void **)1;
  }
  return result;
}

uint64_t sub_244D0F1A0(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_244D44058(0x10uLL);
  if (result)
  {
    *(void *)(a1 + 40) = result;
    return 1;
  }
  return result;
}

uint64_t sub_244D0F1D4(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)sub_244D44058(0x10uLL);
  if (result)
  {
    *(void *)(a1 + 40) = result;
    uint64_t v5 = *(void **)(a2 + 40);
    *(void *)uint64_t result = *v5;
    *(void *)(result + 8) = v5[1];
    return 1;
  }
  return result;
}

void sub_244D0F220(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  if (v1) {
    sub_244D440EC(v1);
  }
}

uint64_t sub_244D0F230(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  if (!v3)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (!v4)
    {
      sub_244D0B884(6, 0, 124, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec.c", 212);
      return 0;
    }
    uint64_t v3 = sub_244D0740C(*(void *)(v4 + 8));
  }
  uint64_t v5 = sub_244D2A270();
  uint64_t v6 = (uint64_t)v5;
  if (v5 && sub_244D2A4D0(v5, v3) && sub_244D2B0F0(v6))
  {
    sub_244D0FD9C(a2, v6);
    return 1;
  }
  sub_244D2A380(v6);
  return 0;
}

uint64_t sub_244D0F2E0(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t *a4, size_t a5)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(uint64_t **)(v6 + 8);
  if (!a2)
  {
    *a3 = sub_244D0A99C(*(void *)(v6 + 8));
    return 1;
  }
  unint64_t v11 = *a3;
  if (v11 < sub_244D0A99C(*(void *)(v6 + 8)))
  {
    sub_244D0B884(6, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec.c", 120);
    return 0;
  }
  unsigned int v13 = 0;
  uint64_t result = sub_244D0A87C(0, a4, a5, a2, &v13, v7);
  if (result)
  {
    *a3 = v13;
    return 1;
  }
  return result;
}

uint64_t sub_244D0F3A8(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D0AA9C(0, a4, a5, a2, a3, *(void *)(*(void *)(a1 + 16) + 8));
}

uint64_t sub_244D0F3D0(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || (uint64_t v4 = *(void *)(a1 + 24)) == 0)
  {
    sub_244D0B884(6, 0, 117, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec.c", 141);
    return 0;
  }
  uint64_t v7 = *(void *)(v3 + 8);
  if (!a2)
  {
    uint64_t v12 = sub_244D0740C(*(void *)(v3 + 8));
    unint64_t v10 = (sub_244D28A10(v12) + 7) >> 3;
    goto LABEL_9;
  }
  uint64_t v8 = (uint64_t *)sub_244CF48E8(*(void *)(v4 + 8));
  unsigned int v9 = sub_244D0A698(a2, *a3, v8, v7, 0);
  if ((v9 & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v10 = v9;
LABEL_9:
  *a3 = v10;
  return 1;
}

uint64_t sub_244D0F480(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 8))
  {
    uint64_t v4 = sub_244D2A270();
    uint64_t v5 = (uint64_t)v4;
    if (v4 && sub_244D2A4D0(v4, *(void *)(v2 + 8)))
    {
      sub_244D0FD9C(a2, v5);
      return 1;
    }
    sub_244D2A380(v5);
  }
  else
  {
    sub_244D0B884(6, 0, 124, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec.c", 231);
  }
  return 0;
}

uint64_t sub_244D0F510(uint64_t a1, int a2, int a3, unsigned int *a4)
{
  uint64_t v4 = *(unsigned int ***)(a1 + 40);
  if (a2 <= 2)
  {
    if (a2 == 1)
    {
      int v7 = sub_244CF48D8(a4);
      if ((v7 - 672) < 4 || v7 == 64)
      {
        *uint64_t v4 = a4;
        return 1;
      }
      int v8 = 111;
      __int16 v9 = 177;
      goto LABEL_13;
    }
    if (a2 == 2)
    {
      *(void *)a4 = *v4;
      return 1;
    }
LABEL_12:
    int v8 = 101;
    __int16 v9 = 202;
LABEL_13:
    sub_244D0B884(6, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec.c", v9);
    return 0;
  }
  if (a2 == 3) {
    return 1;
  }
  if (a2 != 4109) {
    goto LABEL_12;
  }
  uint64_t result = (uint64_t)sub_244D284EC(a3);
  if (result)
  {
    v4[1] = (unsigned int *)result;
    return 1;
  }
  return result;
}

uint64_t sub_244D0F5E4(uint64_t *a1)
{
  return sub_244D0D84C(a1, 408, 516);
}

uint64_t sub_244D0F5FC(uint64_t a1, int a2)
{
  if (a2 == 1) {
    return 1;
  }
  sub_244D0B884(6, 0, 133, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec.c", 270);
  return 0;
}

uint64_t sub_244D0F644(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_244D0A0E8((long long *)a2);
  if (!v6 || *(void *)(a2 + 8))
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 99);
    int v7 = 0;
LABEL_4:
    sub_244D2A380((uint64_t)v7);
    return 0;
  }
  uint64_t v9 = v6;
  unint64_t v10 = sub_244D2A270();
  int v7 = v10;
  if (!v10 || !sub_244D2A4D0(v10, v9) || !sub_244D2AA74(v7, *(unsigned __int8 **)a3, *(void *)(a3 + 8), 0)) {
    goto LABEL_4;
  }
  sub_244D0C274(a1, &dword_26F954D70);
  *(void *)(a1 + 8) = v7;
  return 1;
}

uint64_t sub_244D0F704(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = sub_244D0740C(v3);
  uint64_t v5 = (uint64_t *)sub_244CF48E8(v3);
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  if (sub_244CFB808(a1, (uint64_t)v10, 0x20000010u)
    && sub_244CFB808((uint64_t *)v10, (uint64_t)v9, 0x20000010u)
    && sub_244CFB808((uint64_t *)v9, (uint64_t)v8, 6u)
    && sub_244CFBA40((uint64_t)v8, &unk_26F954D74, 7uLL)
    && sub_244D09FA8((uint64_t *)v9, v4)
    && sub_244CFB808((uint64_t *)v10, (uint64_t)v7, 3u)
    && sub_244CFB8C4((uint64_t)v7, 0)
    && sub_244D0A040((uint64_t)v7, v4, v5, 4)
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(6, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 85);
  return 0;
}

uint64_t sub_244D0F850(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = sub_244D0740C(v3);
  uint64_t v5 = (uint64_t *)sub_244CF48E8(v2);
  uint64_t v6 = (uint64_t *)sub_244CF48E8(v3);
  int v7 = sub_244D290D0(v4, v5, v6);
  if (v7 == 1) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = -2;
  }
  if (v7) {
    return v8;
  }
  else {
    return 1;
  }
}

uint64_t sub_244D0F8C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_244D098F8((long long *)a2);
  if (!v6 || *(void *)(a2 + 8))
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 138);
    return 0;
  }
  uint64_t v8 = sub_244D095FC((long long *)a3, v6);
  if (!v8 || *(void *)(a3 + 8))
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 144);
    sub_244D2A380(v8);
    return 0;
  }
  sub_244D0C274(a1, &dword_26F954D70);
  *(void *)(a1 + 8) = v8;
  return 1;
}

uint64_t sub_244D0F988(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  char v4 = sub_244D22EB0(v3);
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  if (sub_244CFB808(a1, (uint64_t)v10, 0x20000010u))
  {
    if (sub_244CFBDDC((uint64_t)v10, 0))
    {
      if (sub_244CFB808((uint64_t *)v10, (uint64_t)v9, 0x20000010u))
      {
        if (sub_244CFB808((uint64_t *)v9, (uint64_t)v8, 6u))
        {
          if (sub_244CFBA40((uint64_t)v8, &unk_26F954D74, 7uLL))
          {
            uint64_t v5 = sub_244D0740C(v3);
            if (sub_244D09FA8((uint64_t *)v9, v5))
            {
              if (sub_244CFB808((uint64_t *)v10, (uint64_t)v7, 4u)
                && sub_244D09D84((uint64_t *)v7, v3, v4 | 1u)
                && sub_244CFB540(a1))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  sub_244D0B884(6, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 173);
  return 0;
}

BOOL sub_244D0FAC8(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (v3)
  {
    return sub_244D2AA74(v3, a2, a3, 0);
  }
  else
  {
    sub_244D0B884(6, 0, 120, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 184);
    return 0;
  }
}

char *sub_244D0FB20(uint64_t a1, char **a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (v2)
  {
    return sub_244D2AD94(v2, 4, a2);
  }
  else
  {
    sub_244D0B884(6, 0, 120, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 195);
    return 0;
  }
}

uint64_t sub_244D0FB80(uint64_t a1)
{
  return sub_244D2A724(*(void *)(a1 + 8));
}

unint64_t sub_244D0FB88(uint64_t a1)
{
  return sub_244D0A99C(*(void *)(a1 + 8));
}

uint64_t sub_244D0FBA4(uint64_t a1)
{
  uint64_t v1 = sub_244D0740C(*(void *)(a1 + 8));
  if (v1)
  {
    return sub_244D288BC(v1);
  }
  else
  {
    sub_244D0B1B0();
    return 0;
  }
}

BOOL sub_244D0FBE4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  return !v1 || sub_244D0740C(v1) == 0;
}

BOOL sub_244D0FC14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (!v3)
  {
    int v8 = 120;
    __int16 v9 = 225;
LABEL_10:
    sub_244D0B884(6, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", v9);
    return 0;
  }
  uint64_t v4 = sub_244D0740C(v3);
  if (!v4)
  {
    int v8 = 118;
    __int16 v9 = 230;
    goto LABEL_10;
  }
  uint64_t v5 = v4;
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  if (!v6)
  {
    uint64_t v6 = sub_244D2A270();
    *(void *)(a1 + 8) = v6;
    if (!v6) {
      return 0;
    }
  }

  return sub_244D2A4D0(v6, v5);
}

uint64_t sub_244D0FCB8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 4294967294;
  }
  uint64_t v5 = sub_244D0740C(v2);
  uint64_t v6 = sub_244D0740C(v3);
  if (!v5 || v6 == 0) {
    return 4294967294;
  }
  else {
    return sub_244D2670C(v5, v6) == 0;
  }
}

void sub_244D0FD24(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_244D0FD50(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  if (!a2) {
    return 0;
  }
  sub_244D2A704(a2);
  return 1;
}

BOOL sub_244D0FD9C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  return a2 != 0;
}

uint64_t sub_244D0FDD8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 408) {
    return *(void *)(a1 + 8);
  }
  sub_244D0B884(6, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 320);
  return 0;
}

uint64_t sub_244D0FE20(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 408)
  {
    uint64_t v1 = *(void *)(a1 + 8);
    if (v1) {
      sub_244D2A704(*(void *)(a1 + 8));
    }
  }
  else
  {
    sub_244D0B884(6, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ec_asn1.c", 320);
    return 0;
  }
  return v1;
}

uint64_t sub_244D0FE80()
{
  return 1;
}

uint64_t sub_244D0FE88(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v3 = sub_244D43FF4(0x41uLL);
  if (!v3) {
    return 0;
  }
  BOOL v4 = v3;
  sub_244D0C274(a2, &dword_26F954E90);
  sub_244D01FD4((uint64_t)v7, v4);
  uint64_t v5 = 1;
  *((unsigned char *)v4 + 64) = 1;
  sub_244D440EC(*(void **)(a2 + 8));
  *(void *)(a2 + 8) = v4;
  return v5;
}

uint64_t sub_244D0FF30(uint64_t a1, unint64_t *a2, void *a3, unint64_t *a4, size_t a5)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 16) + 8);
  if (!*(unsigned char *)(v5 + 64))
  {
    int v7 = 130;
    __int16 v8 = 49;
    goto LABEL_6;
  }
  if (!a2) {
    goto LABEL_8;
  }
  if (*a3 <= 0x3FuLL)
  {
    int v7 = 100;
    __int16 v8 = 59;
LABEL_6:
    sub_244D0B884(6, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519.c", v8);
    return 0;
  }
  uint64_t result = sub_244D02118(a2, a4, a5, (unint64_t *)v5);
  if (result)
  {
LABEL_8:
    *a3 = 64;
    return 1;
  }
  return result;
}

uint64_t sub_244D0FFD4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, size_t a5)
{
  if (a3 == 64
    && sub_244D02DC0(a4, a5, a2, (int64x2_t *)(*(void *)(*(void *)(a1 + 16) + 8) + 32)))
  {
    return 1;
  }
  sub_244D0B884(6, 0, 131, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519.c", 77);
  return 0;
}

uint64_t sub_244D10040(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8))
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", 119);
    return 0;
  }
  else
  {
    BOOL v4 = *(_OWORD **)a3;
    uint64_t v5 = *(void *)(a3 + 8);
    return sub_244D10474(a1, v4, v5);
  }
}

uint64_t sub_244D10098(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v8, 0x20000010u)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v7, 0x20000010u)
    && sub_244CFB808((uint64_t *)v7, (uint64_t)v6, 6u)
    && sub_244CFBA40((uint64_t)v6, &unk_26F954E94, 3uLL)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v5, 3u)
    && sub_244CFB8C4((uint64_t)v5, 0)
    && sub_244CFBA40((uint64_t)v5, (const void *)(v3 + 32), 0x20uLL)
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(6, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", 140);
  return 0;
}

BOOL sub_244D101A8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void **)(a2 + 8);
  uint64_t v4 = v2[4];
  uint64_t v5 = v2[5];
  uint64_t v6 = v3[4];
  uint64_t v7 = v3[5];
  uint64_t v9 = v2[6];
  uint64_t v8 = v2[7];
  uint64_t v11 = v3[6];
  uint64_t v10 = v3[7];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t sub_244D101D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!*(void *)(a2 + 8) && sub_244CFCD34((long long *)a3, &v6, 4) && !*(void *)(a3 + 8)) {
    return sub_244D103B0(a1, v6, v7);
  }
  sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", 163);
  return 0;
}

uint64_t sub_244D1025C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned char **)(a2 + 8);
  if (v2[64])
  {
    memset(v11, 0, sizeof(v11));
    memset(v10, 0, sizeof(v10));
    memset(v9, 0, sizeof(v9));
    memset(v8, 0, sizeof(v8));
    memset(v7, 0, sizeof(v7));
    if (sub_244CFB808(a1, (uint64_t)v11, 0x20000010u)
      && sub_244CFBDDC((uint64_t)v11, 0)
      && sub_244CFB808((uint64_t *)v11, (uint64_t)v10, 0x20000010u)
      && sub_244CFB808((uint64_t *)v10, (uint64_t)v9, 6u)
      && sub_244CFBA40((uint64_t)v9, &unk_26F954E94, 3uLL)
      && sub_244CFB808((uint64_t *)v11, (uint64_t)v8, 4u)
      && sub_244CFB808((uint64_t *)v8, (uint64_t)v7, 4u)
      && sub_244CFBA40((uint64_t)v7, v2, 0x20uLL)
      && sub_244CFB540(a1))
    {
      return 1;
    }
    int v5 = 105;
    __int16 v6 = 190;
  }
  else
  {
    int v5 = 130;
    __int16 v6 = 173;
  }
  sub_244D0B884(6, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", v6);
  return 0;
}

uint64_t sub_244D103B0(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a3 != 32)
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", 33);
    return 0;
  }
  int v5 = sub_244D43FF4(0x41uLL);
  if (!v5) {
    return 0;
  }
  __int16 v6 = v5;
  sub_244D02048((uint64_t)v9, v5, a2);
  uint64_t v7 = 1;
  *((unsigned char *)v6 + 64) = 1;
  sub_244D440EC(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = v6;
  return v7;
}

uint64_t sub_244D10474(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  if (a3 == 32)
  {
    uint64_t result = (uint64_t)sub_244D43FF4(0x41uLL);
    if (result)
    {
      uint64_t v6 = result;
      long long v7 = a2[1];
      *(_OWORD *)(result + 32) = *a2;
      *(_OWORD *)(result + 48) = v7;
      *(unsigned char *)(result + 64) = 0;
      sub_244D440EC(*(void **)(a1 + 8));
      *(void *)(a1 + 8) = v6;
      return 1;
    }
  }
  else
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", 55);
    return 0;
  }
  return result;
}

uint64_t sub_244D104F8(uint64_t a1, _OWORD *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!*(unsigned char *)(v3 + 64))
  {
    int v4 = 130;
    __int16 v5 = 76;
    goto LABEL_6;
  }
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      int v4 = 100;
      __int16 v5 = 86;
LABEL_6:
      sub_244D0B884(6, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", v5);
      return 0;
    }
    long long v7 = *(_OWORD *)(v3 + 16);
    *a2 = *(_OWORD *)v3;
    a2[1] = v7;
  }
  *a3 = 32;
  return 1;
}

uint64_t sub_244D1057C(uint64_t a1, _OWORD *a2, void *a3)
{
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      sub_244D0B884(6, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_ed25519_asn1.c", 105);
      return 0;
    }
    uint64_t v4 = *(void *)(a1 + 8);
    long long v5 = *(_OWORD *)(v4 + 48);
    *a2 = *(_OWORD *)(v4 + 32);
    a2[1] = v5;
  }
  *a3 = 32;
  return 1;
}

uint64_t sub_244D105DC()
{
  return 64;
}

uint64_t sub_244D105E4()
{
  return 253;
}

void sub_244D105EC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_244D10618(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_244D44058(0x60uLL);
  if (result)
  {
    uint64_t v3 = (void *)result;
    if (sub_244CFB3DC(result + 48, 0))
    {
      *(void *)(a1 + 40) = v3;
      return 1;
    }
    else
    {
      sub_244D440EC(v3);
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D10670(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244D10618(a1);
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a2 + 40);
    *(_DWORD *)uint64_t v5 = *(_DWORD *)v6;
    *(void *)(v5 + 8) = *(void *)(v6 + 8);
    unint64_t v7 = *(void *)(v6 + 24);
    if (v7)
    {
      uint64_t result = (uint64_t)sub_244D442F4(*(const void **)(v6 + 16), v7);
      *(void *)(v5 + 16) = result;
      if (!result) {
        return result;
      }
      *(void *)(v5 + 24) = *(void *)(v6 + 24);
    }
    unint64_t v8 = *(void *)(v6 + 40);
    if (v8)
    {
      uint64_t result = (uint64_t)sub_244D442F4(*(const void **)(v6 + 32), v8);
      *(void *)(v5 + 32) = result;
      if (!result) {
        return result;
      }
      *(void *)(v5 + 40) = *(void *)(v6 + 40);
    }
    uint64_t v9 = v5 + 48;
    uint64_t v10 = v6 + 48;
    uint64_t v11 = sub_244CFB738(v6 + 48);
    size_t v12 = sub_244CFB760(v10);
    return sub_244CFBA40(v9, v11, v12) != 0;
  }
  return result;
}

void sub_244D10730(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    sub_244D440EC(*(void **)(v1 + 16));
    sub_244D440EC(*(void **)(v1 + 32));
    sub_244CFB470(v1 + 48);
    sub_244D440EC((void *)v1);
    *(void *)(a1 + 40) = 0;
  }
}

uint64_t sub_244D1077C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(int **)(a1 + 40);
  uint64_t v4 = *((void *)v3 + 1);
  if (!v4)
  {
    int v17 = 118;
    __int16 v18 = 100;
LABEL_10:
    sub_244D0B884(6, 0, v17, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_hkdf.c", v18);
    return 0;
  }
  unint64_t v5 = *((void *)v3 + 3);
  if (!v5)
  {
    int v17 = 120;
    __int16 v18 = 104;
    goto LABEL_10;
  }
  int v8 = *v3;
  if (a2)
  {
    switch(v8)
    {
      case 2:
        uint64_t v19 = *a3;
        uint64_t v20 = *((void *)v3 + 2);
        uint64_t v21 = sub_244CFB738((uint64_t)(v3 + 12));
        uint64_t v22 = sub_244CFB760((uint64_t)(v3 + 12));
        return sub_244D2E7F8(a2, v19, v4, v20, v5, (uint64_t)v21, v22);
      case 1:
        unint64_t v23 = *a3;
        if (v23 < sub_244CF48E0(*((void *)v3 + 1)))
        {
          int v17 = 100;
          __int16 v18 = 124;
          goto LABEL_10;
        }
        uint64_t v24 = *((void *)v3 + 1);
        uint64_t v25 = *((void *)v3 + 2);
        uint64_t v26 = *((void *)v3 + 3);
        uint64_t v27 = *((void *)v3 + 4);
        unint64_t v28 = *((void *)v3 + 5);
        return sub_244D2E778(a2, a3, v24, v25, v26, v27, v28);
      case 0:
        uint64_t v9 = *a3;
        uint64_t v10 = *((void *)v3 + 2);
        uint64_t v11 = (uint64_t)(v3 + 12);
        uint64_t v12 = *((void *)v3 + 4);
        unint64_t v13 = *((void *)v3 + 5);
        uint64_t v14 = sub_244CFB738(v11);
        uint64_t v15 = sub_244CFB760(v11);
        return sub_244D2E6D4(a2, v9, v4, v10, v5, v12, v13, (uint64_t)v14, v15);
      default:
        int v17 = 68;
        __int16 v18 = 134;
        goto LABEL_10;
    }
  }
  else
  {
    if (v8 == 1) {
      *a3 = sub_244CF48E0(*((void *)v3 + 1));
    }
    return 1;
  }
}

BOOL sub_244D1099C(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 40);
  switch(a2)
  {
    case 4110:
      if (a3 >= 3)
      {
        int v5 = 114;
        __int16 v6 = 145;
        goto LABEL_10;
      }
      *(_DWORD *)uint64_t v4 = a3;
      return 1;
    case 4111:
      *(void *)(v4 + 8) = a4;
      return 1;
    case 4112:
      unint64_t v7 = (uint64_t *)(v4 + 16);
      int v8 = (void *)(v4 + 24);
      goto LABEL_6;
    case 4113:
      unint64_t v7 = (uint64_t *)(v4 + 32);
      int v8 = (void *)(v4 + 40);
LABEL_6:
      int v9 = sub_244CFC538(a4, v7, v8);
      goto LABEL_8;
    case 4114:
      int v9 = sub_244CFBA40(v4 + 48, *(const void **)a4, *(void *)(a4 + 8));
LABEL_8:
      BOOL result = v9 != 0;
      break;
    default:
      int v5 = 101;
      __int16 v6 = 177;
LABEL_10:
      sub_244D0B884(6, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_hkdf.c", v6);
      BOOL result = 0;
      break;
  }
  return result;
}

uint64_t sub_244D10A88(uint64_t *a1)
{
  return sub_244D0D84C(a1, 963, 256);
}

uint64_t sub_244D10AA0(uint64_t *a1)
{
  return sub_244D0D84C(a1, 963, 256);
}

uint64_t sub_244D10AB8(uint64_t *a1)
{
  return sub_244D0D84C(a1, 963, 256);
}

uint64_t sub_244D10AF0(uint64_t *a1)
{
  return sub_244D0D84C(a1, 963, 256);
}

uint64_t sub_244D10B28(uint64_t *a1)
{
  return sub_244D0D84C(a1, 963, 256);
}

uint64_t sub_244D10B60(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_244D44058(0x48uLL);
  if (result)
  {
    uint64_t v3 = result;
    *(_DWORD *)uint64_t result = 2048;
    uint64_t result = 1;
    *(_DWORD *)(v3 + 16) = 1;
    *(_DWORD *)(v3 + 40) = -2;
    *(void *)(a1 + 40) = v3;
  }
  return result;
}

uint64_t sub_244D10BAC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)sub_244D44058(0x48uLL);
  if (result)
  {
    uint64_t v5 = result;
    *(_DWORD *)uint64_t result = 2048;
    *(_DWORD *)(result + 16) = 1;
    *(_DWORD *)(result + 40) = -2;
    *(void *)(a1 + 40) = result;
    uint64_t v6 = *(void *)(a2 + 40);
    *(_DWORD *)uint64_t result = *(_DWORD *)v6;
    uint64_t v7 = *(void *)(v6 + 8);
    if (!v7 || (uint64_t result = (uint64_t)sub_244D16714(v7), (*(void *)(v5 + 8) = result) != 0))
    {
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 16);
      *(void *)(v5 + 24) = *(void *)(v6 + 24);
      *(void *)(v5 + 32) = *(void *)(v6 + 32);
      *(_DWORD *)(v5 + 40) = *(_DWORD *)(v6 + 40);
      if (*(void *)(v6 + 56))
      {
        sub_244D440EC(*(void **)(v5 + 56));
        uint64_t result = (uint64_t)sub_244D442F4(*(const void **)(v6 + 56), *(void *)(v6 + 64));
        *(void *)(v5 + 56) = result;
        if (!result) {
          return result;
        }
        *(void *)(v5 + 64) = *(void *)(v6 + 64);
      }
      return 1;
    }
  }
  return result;
}

void sub_244D10C70(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    sub_244D166B0(*(void ***)(v1 + 8));
    sub_244D440EC(*(void **)(v1 + 48));
    sub_244D440EC(*(void **)(v1 + 56));
    sub_244D440EC((void *)v1);
  }
}

uint64_t sub_244D10CCC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (*(void *)(v3 + 8)
    || (uint64_t result = (uint64_t)sub_244D16670(), (*(void *)(v3 + 8) = result) != 0)
    && (uint64_t result = sub_244D16130(result, 65537), result))
  {
    uint64_t result = (uint64_t)sub_244D32AE8();
    if (result)
    {
      uint64_t v5 = result;
      if (sub_244D35564(result, *(_DWORD *)v3, *(uint64_t **)(v3 + 8), 0))
      {
        sub_244D11EDC(a2, v5);
        return 1;
      }
      else
      {
        sub_244D3306C(v5);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_244D10D5C(uint64_t a1, char *a2, size_t *a3, const void *a4, size_t a5)
{
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(uint64_t ***)(v10 + 8);
  int v12 = sub_244D0C314(v10);
  size_t v13 = v12;
  if (!a2) {
    goto LABEL_9;
  }
  unint64_t v14 = *a3;
  if (*a3 < v12)
  {
    sub_244D0B884(6, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa.c", 181);
    return 0;
  }
  unint64_t v16 = *(unsigned int **)(v9 + 24);
  if (v16)
  {
    unsigned int v19 = 0;
    int v17 = *(_DWORD *)(v9 + 16);
    if (v17 == 6) {
      return sub_244D33D90(v11, a3, a2, v14, (uint64_t)a4, a5, (uint64_t)v16, *(void *)(v9 + 32), *(_DWORD *)(v9 + 40));
    }
    uint64_t result = 0;
    if (v17 == 1)
    {
      uint64_t v18 = sub_244CF48D8(v16);
      uint64_t result = sub_244D33D8C(v18, a4, a5, a2, &v19, v11);
      if (result)
      {
        size_t v13 = v19;
LABEL_9:
        *a3 = v13;
        return 1;
      }
    }
  }
  else
  {
    return sub_244D33980(v11, a3, a2);
  }
  return result;
}

uint64_t sub_244D10EA4(uint64_t a1, unsigned __int8 *a2, unint64_t a3, char *a4, size_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16);
  int v12 = *(void **)(v11 + 8);
  uint64_t v13 = *(void *)(v10 + 24);
  if (!v13)
  {
    size_t v22 = 0;
    int v17 = sub_244D0C314(v11);
    uint64_t result = sub_244D11970(v10, a1);
    if (!result) {
      return result;
    }
    if (sub_244D344B8((uint64_t)v12, &v22, *(char **)(v10 + 48), v17, a2, a3, *(_DWORD *)(v10 + 16))) {
      BOOL v18 = v22 == a5;
    }
    else {
      BOOL v18 = 0;
    }
    if (v18) {
      return sub_244D441D4(a4, *(char **)(v10 + 48), a5) == 0;
    }
    return 0;
  }
  int v14 = *(_DWORD *)(v10 + 16);
  if (v14 != 6)
  {
    if (v14 == 1)
    {
      int v15 = sub_244CF48D8(*(unsigned int **)(v10 + 24));
      return sub_244D34338(v15, a4, a5, a2, a3, v12);
    }
    return 0;
  }
  uint64_t v19 = *(void *)(v10 + 32);
  int v20 = *(_DWORD *)(v10 + 40);
  uint64_t v21 = *(uint64_t ***)(v11 + 8);

  return sub_244D3433C(v21, (uint64_t)a4, a5, v13, v19, v20, a2, a3);
}

uint64_t sub_244D11018(uint64_t a1, void *a2, size_t *a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(void *)(v11 + 8);
  int v13 = sub_244D0C314(v11);
  unint64_t v14 = v13;
  if (!a2)
  {
    *a3 = v13;
    return 1;
  }
  unint64_t v15 = *a3;
  if (*a3 < v13)
  {
    sub_244D0B884(6, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa.c", 253);
    return 0;
  }
  uint64_t v17 = *(void *)(v10 + 24);
  int v18 = *(_DWORD *)(v10 + 16);
  if (v17)
  {
    if (v18 != 1) {
      return 0;
    }
    size_t v19 = sub_244CF48E0(v17);
    size_t v24 = 0;
    uint64_t v25 = 0;
    int v23 = 0;
    uint64_t result = sub_244D11970(v10, a1);
    if (result)
    {
      int v20 = sub_244CF48D8(*(unsigned int **)(v10 + 24));
      uint64_t result = sub_244D33A00((uint64_t *)&v25, &v24, &v23, v20, &unk_244EB6CFF, v19);
      if (result)
      {
        size_t v22 = 0;
        BOOL v21 = !sub_244D344B8(v12, &v22, *(char **)(v10 + 48), v14, a4, a5, 1)
           || v22 != v24
           || sub_244D441D4(*(char **)(v10 + 48), (char *)v25, v22 - v19);
        if (v23) {
          sub_244D440EC(v25);
        }
        if (v21) {
          return 0;
        }
        if (v19) {
          memcpy(a2, (const void *)(*(void *)(v10 + 48) + v22 - v19), v19);
        }
        *a3 = v19;
        return 1;
      }
    }
  }
  else
  {
    return sub_244D344B8(v12, a3, (char *)a2, v15, a4, a5, v18);
  }
  return result;
}

uint64_t sub_244D111FC(uint64_t a1, char *a2, unint64_t *a3, void *a4, size_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(void *)(v11 + 8);
  int v13 = sub_244D0C314(v11);
  unint64_t v14 = v13;
  if (a2)
  {
    unint64_t v15 = *a3;
    if (*a3 >= v13)
    {
      int v17 = *(_DWORD *)(v10 + 16);
      if (v17 == 4)
      {
        uint64_t result = sub_244D11970(v10, a1);
        if (result)
        {
          uint64_t result = sub_244D4A3B0(*(unsigned char **)(v10 + 48), v14, a4, a5, *(void *)(v10 + 56), *(void *)(v10 + 64), *(uint64_t **)(v10 + 24), *(uint64_t **)(v10 + 32));
          if (result) {
            return sub_244D4A990(v12, a3, a2, *a3, *(void **)(v10 + 48), v14, 3) != 0;
          }
        }
      }
      else
      {
        return sub_244D4A990(v12, a3, a2, v15, a4, a5, v17);
      }
    }
    else
    {
      sub_244D0B884(6, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa.c", 317);
      return 0;
    }
  }
  else
  {
    *a3 = v13;
    return 1;
  }
  return result;
}

uint64_t sub_244D11338(uint64_t a1, void *a2, unint64_t *a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(uint64_t ***)(v11 + 8);
  int v13 = sub_244D0C314(v11);
  unint64_t v14 = v13;
  if (a2)
  {
    if (*a3 >= v13)
    {
      int v16 = *(_DWORD *)(v10 + 16);
      if (v16 == 4)
      {
        unint64_t v17 = 0;
        uint64_t result = sub_244D11970(v10, a1);
        if (result)
        {
          uint64_t result = sub_244D4ADDC(v12, &v17, *(char **)(v10 + 48), v14, a4, a5, 3);
          if (result) {
            return sub_244D4A634(a2, a3, v14, *(unsigned __int8 **)(v10 + 48), v17, *(void *)(v10 + 56), *(void *)(v10 + 64), *(uint64_t **)(v10 + 24), *(void *)(v10 + 32)) != 0;
          }
        }
      }
      else
      {
        return sub_244D4ADDC(v12, a3, (char *)a2, v13, a4, a5, v16);
      }
    }
    else
    {
      sub_244D0B884(6, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa.c", 349);
      return 0;
    }
  }
  else
  {
    *a3 = v13;
    return 1;
  }
  return result;
}

uint64_t sub_244D11490(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 40);
  switch(a2)
  {
    case 4097:
      if (a3 > 6 || ((1 << a3) & 0x5A) == 0) {
        goto LABEL_21;
      }
      uint64_t v11 = *(void *)(v5 + 24);
      if (a3 == 3 && v11)
      {
        sub_244D0B884(6, 0, 115, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa.c", 375);
LABEL_21:
        int v8 = 109;
        __int16 v9 = 403;
        goto LABEL_45;
      }
      if (a3 == 4)
      {
        if ((*(unsigned char *)(a1 + 32) & 0xC0) == 0) {
          goto LABEL_21;
        }
      }
      else
      {
        if (a3 != 6) {
          goto LABEL_54;
        }
        if ((*(unsigned char *)(a1 + 32) & 0x18) == 0) {
          goto LABEL_21;
        }
      }
      if (!v11) {
        *(void *)(v5 + 24) = sub_244D25B18();
      }
LABEL_54:
      *(_DWORD *)(v5 + 16) = a3;
      return 1;
    case 4098:
      int v7 = *(_DWORD *)(v5 + 16);
      goto LABEL_23;
    case 4099:
    case 4100:
      if (*(_DWORD *)(v5 + 16) != 6)
      {
        int v8 = 116;
        __int16 v9 = 420;
        goto LABEL_45;
      }
      if (a2 == 4100)
      {
        int v7 = *(_DWORD *)(v5 + 40);
LABEL_23:
        *(_DWORD *)a4 = v7;
      }
      else
      {
        if (a3 < -2) {
          return 0;
        }
        *(_DWORD *)(v5 + 40) = a3;
      }
      return 1;
    case 4101:
      if (a3 <= 255)
      {
        int v8 = 112;
        __int16 v9 = 435;
        goto LABEL_45;
      }
      *(_DWORD *)uint64_t v5 = a3;
      return 1;
    case 4102:
      if (!a4) {
        return 0;
      }
      sub_244D166B0(*(void ***)(v5 + 8));
      *(void *)(v5 + 8) = a4;
      return 1;
    case 4103:
    case 4104:
      if (*(_DWORD *)(v5 + 16) != 4)
      {
        int v8 = 115;
        __int16 v9 = 452;
        goto LABEL_45;
      }
      if (a2 == 4104) {
        goto LABEL_14;
      }
      goto LABEL_37;
    case 4105:
    case 4106:
      if ((*(_DWORD *)(v5 + 16) | 2) != 6)
      {
        int v8 = 113;
        __int16 v9 = 477;
        goto LABEL_45;
      }
      if (a2 != 4106)
      {
        *(void *)(v5 + 32) = a4;
        return 1;
      }
      uint64_t v10 = *(void *)(v5 + 32);
      if (v10) {
        goto LABEL_15;
      }
      goto LABEL_14;
    case 4107:
      if (*(_DWORD *)(v5 + 16) == 4)
      {
        sub_244D440EC(*(void **)(v5 + 56));
        *(void *)(v5 + 56) = *(void *)a4;
        *(void *)(v5 + 64) = *(void *)(a4 + 8);
        return 1;
      }
      int v8 = 115;
      __int16 v9 = 493;
      goto LABEL_45;
    case 4108:
      if (*(_DWORD *)(v5 + 16) == 4)
      {
        uint64_t v12 = *(void *)(v5 + 64);
        *(void *)a4 = *(void *)(v5 + 56);
        *(void *)(a4 + 8) = v12;
        return 1;
      }
      int v8 = 115;
      __int16 v9 = 505;
      goto LABEL_45;
    default:
      if (a2 == 1)
      {
        if (!a4 || *(_DWORD *)(v5 + 16) != 3)
        {
LABEL_37:
          *(void *)(v5 + 24) = a4;
          return 1;
        }
        int v8 = 115;
        __int16 v9 = 375;
        goto LABEL_45;
      }
      if (a2 != 2)
      {
        int v8 = 101;
        __int16 v9 = 512;
LABEL_45:
        sub_244D0B884(6, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa.c", v9);
        return 0;
      }
LABEL_14:
      uint64_t v10 = *(void *)(v5 + 24);
LABEL_15:
      *(void *)a4 = v10;
      return 1;
  }
}

uint64_t sub_244D117C8(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, -1);
}

uint64_t sub_244D117E0(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, -1);
}

uint64_t sub_244D117F8(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 24);
}

uint64_t sub_244D11810(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 24);
}

uint64_t sub_244D11828(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 4);
}

uint64_t sub_244D11840(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 4);
}

uint64_t sub_244D11858(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 192);
}

uint64_t sub_244D11870(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 192);
}

uint64_t sub_244D11888(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 248);
}

uint64_t sub_244D118A0(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 248);
}

uint64_t sub_244D118B8(uint64_t *a1)
{
  return sub_244D0D84C(a1, 6, 192);
}

uint64_t sub_244D118F0(uint64_t *a1, void *a2)
{
  if (!sub_244D0D84C(a1, 6, 192)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a2 = 0;
  return result;
}

BOOL sub_244D11970(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 48)) {
    return 1;
  }
  int v4 = sub_244D0C314(*(void *)(a2 + 16));
  uint64_t v5 = sub_244D43FF4(v4);
  *(void *)(a1 + 48) = v5;
  return v5 != 0;
}

uint64_t sub_244D119BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (!sub_244CFCD34((long long *)a2, &v8, 5) || v9 || *(void *)(a2 + 8))
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 97);
  }
  else
  {
    int v7 = sub_244D49A68((long long *)a3);
    if (v7 && !*(void *)(a3 + 8))
    {
      sub_244D0C274(a1, &dword_26F955028);
      *(void *)(a1 + 8) = v7;
      return 1;
    }
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 103);
    sub_244D3306C((uint64_t)v7);
  }
  return 0;
}

uint64_t sub_244D11A98(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v9, 0x20000010u)
    && sub_244CFB808((uint64_t *)v9, (uint64_t)v8, 0x20000010u)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v7, 6u)
    && sub_244CFBA40((uint64_t)v7, &unk_26F95502C, 9uLL)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v6, 5u)
    && sub_244CFB808((uint64_t *)v9, (uint64_t)v5, 3u)
    && sub_244CFB8C4((uint64_t)v5, 0)
    && sub_244D49BB8((uint64_t *)v5, v3)
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(6, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 82);
  return 0;
}

BOOL sub_244D11BC4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = sub_244CF48E8(v3);
  uint64_t v5 = sub_244CF48E8(v2);
  if (sub_244D17194(v4, v5)) {
    return 0;
  }
  uint64_t v7 = sub_244D07414(v3);
  uint64_t v8 = sub_244D07414(v2);
  return sub_244D17194(v7, v8) == 0;
}

uint64_t sub_244D11C44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (!sub_244CFCD34((long long *)a2, &v8, 5) || v9 || *(void *)(a2 + 8))
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 144);
  }
  else
  {
    uint64_t v7 = sub_244D49D4C((long long *)a3);
    if (v7 && !*(void *)(a3 + 8))
    {
      sub_244D0C274(a1, &dword_26F955028);
      *(void *)(a1 + 8) = v7;
      return 1;
    }
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 150);
    sub_244D3306C((uint64_t)v7);
  }
  return 0;
}

uint64_t sub_244D11D20(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t ***)(a2 + 8);
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v9, 0x20000010u)
    && sub_244CFBDDC((uint64_t)v9, 0)
    && sub_244CFB808((uint64_t *)v9, (uint64_t)v8, 0x20000010u)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v7, 6u)
    && sub_244CFBA40((uint64_t)v7, &unk_26F95502C, 9uLL)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v6, 5u)
    && sub_244CFB808((uint64_t *)v9, (uint64_t)v5, 4u)
    && sub_244D49F68((uint64_t *)v5, v3)
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(6, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 131);
  return 0;
}

uint64_t sub_244D11E4C(uint64_t a1)
{
  return sub_244D339BC(*(void *)(a1 + 8));
}

uint64_t sub_244D11E54(uint64_t a1)
{
  return sub_244D32744(*(uint64_t ***)(a1 + 8));
}

uint64_t sub_244D11E5C(uint64_t a1)
{
  return sub_244D33768(*(void *)(a1 + 8));
}

void sub_244D11E64(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_244D11E90(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  if (!a2) {
    return 0;
  }
  sub_244D33748(a2);
  return 1;
}

BOOL sub_244D11EDC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  return a2 != 0;
}

uint64_t sub_244D11F18(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 6) {
    return *(void *)(a1 + 8);
  }
  sub_244D0B884(6, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 229);
  return 0;
}

uint64_t sub_244D11F60(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4) == 6)
  {
    uint64_t v1 = *(void *)(a1 + 8);
    if (v1) {
      sub_244D33748(*(void *)(a1 + 8));
    }
  }
  else
  {
    sub_244D0B884(6, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_rsa_asn1.c", 229);
    return 0;
  }
  return v1;
}

uint64_t sub_244D11FC0()
{
  return 1;
}

uint64_t sub_244D11FC8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_244D43FF4(0x41uLL);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  sub_244D0C274(a2, &dword_26F955148);
  sub_244D035E8(v4, v4 + 32);
  uint64_t v5 = 1;
  v4[64] = 1;
  sub_244D440EC(*(void **)(a2 + 8));
  *(void *)(a2 + 8) = v4;
  return v5;
}

uint64_t sub_244D1203C(uint64_t a1, char *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || (uint64_t v4 = *(void *)(a1 + 24)) == 0)
  {
    int v9 = 117;
    __int16 v10 = 46;
    goto LABEL_10;
  }
  uint64_t v6 = *(void *)(v3 + 8);
  uint64_t v7 = *(long long **)(v4 + 8);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    int v9 = 117;
    __int16 v10 = 53;
LABEL_10:
    sub_244D0B884(6, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519.c", v10);
    return 0;
  }
  if (!*(unsigned char *)(v6 + 64))
  {
    int v9 = 130;
    __int16 v10 = 58;
    goto LABEL_10;
  }
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      int v9 = 100;
      __int16 v10 = 64;
      goto LABEL_10;
    }
    if (!sub_244D03790(a2, (long long *)(v6 + 32), v7))
    {
      int v9 = 134;
      __int16 v10 = 68;
      goto LABEL_10;
    }
  }
  *a3 = 32;
  return 1;
}

uint64_t sub_244D1214C(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return 1;
  }
  sub_244D0B884(6, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519.c", 85);
  return 0;
}

uint64_t sub_244D12194(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8))
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", 133);
    return 0;
  }
  else
  {
    uint64_t v4 = *(_OWORD **)a3;
    uint64_t v5 = *(void *)(a3 + 8);
    return sub_244D12594(a1, v4, v5);
  }
}

uint64_t sub_244D121EC(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(const void **)(a2 + 8);
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v8, 0x20000010u)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v7, 0x20000010u)
    && sub_244CFB808((uint64_t *)v7, (uint64_t)v6, 6u)
    && sub_244CFBA40((uint64_t)v6, &unk_26F95514C, 3uLL)
    && sub_244CFB808((uint64_t *)v8, (uint64_t)v5, 3u)
    && sub_244CFB8C4((uint64_t)v5, 0)
    && sub_244CFBA40((uint64_t)v5, v3, 0x20uLL)
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(6, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", 153);
  return 0;
}

BOOL sub_244D122FC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(a2 + 8);
  uint64_t v4 = *v2;
  uint64_t v5 = v2[1];
  uint64_t v6 = *v3;
  uint64_t v7 = v3[1];
  uint64_t v9 = v2[2];
  uint64_t v8 = v2[3];
  uint64_t v11 = v3[2];
  uint64_t v10 = v3[3];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t sub_244D1232C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!*(void *)(a2 + 8) && sub_244CFCD34((long long *)a3, &v6, 4) && !*(void *)(a3 + 8)) {
    return sub_244D12504(a1, v6, v7);
  }
  sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", 175);
  return 0;
}

uint64_t sub_244D123B0(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (*(unsigned char *)(v2 + 64))
  {
    memset(v11, 0, sizeof(v11));
    memset(v10, 0, sizeof(v10));
    memset(v9, 0, sizeof(v9));
    memset(v8, 0, sizeof(v8));
    memset(v7, 0, sizeof(v7));
    if (sub_244CFB808(a1, (uint64_t)v11, 0x20000010u)
      && sub_244CFBDDC((uint64_t)v11, 0)
      && sub_244CFB808((uint64_t *)v11, (uint64_t)v10, 0x20000010u)
      && sub_244CFB808((uint64_t *)v10, (uint64_t)v9, 6u)
      && sub_244CFBA40((uint64_t)v9, &unk_26F95514C, 3uLL)
      && sub_244CFB808((uint64_t *)v11, (uint64_t)v8, 4u)
      && sub_244CFB808((uint64_t *)v8, (uint64_t)v7, 4u)
      && sub_244CFBA40((uint64_t)v7, (const void *)(v2 + 32), 0x20uLL)
      && sub_244CFB540(a1))
    {
      return 1;
    }
    int v5 = 105;
    __int16 v6 = 202;
  }
  else
  {
    int v5 = 130;
    __int16 v6 = 185;
  }
  sub_244D0B884(6, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", v6);
  return 0;
}

uint64_t sub_244D12504(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  if (a3 != 32)
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", 33);
    return 0;
  }
  int v5 = sub_244D43FF4(0x41uLL);
  if (!v5) {
    return 0;
  }
  __int16 v6 = v5;
  long long v7 = a2[1];
  *((_OWORD *)v5 + 2) = *a2;
  *((_OWORD *)v5 + 3) = v7;
  sub_244D0364C(v5, (uint64_t)(v5 + 4));
  uint64_t v8 = 1;
  *((unsigned char *)v6 + 64) = 1;
  sub_244D440EC(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = v6;
  return v8;
}

uint64_t sub_244D12594(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  if (a3 == 32)
  {
    uint64_t result = (uint64_t)sub_244D43FF4(0x41uLL);
    if (result)
    {
      uint64_t v6 = result;
      long long v7 = a2[1];
      *(_OWORD *)uint64_t result = *a2;
      *(_OWORD *)(result + 16) = v7;
      *(unsigned char *)(result + 64) = 0;
      sub_244D440EC(*(void **)(a1 + 8));
      *(void *)(a1 + 8) = v6;
      return 1;
    }
  }
  else
  {
    sub_244D0B884(6, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", 53);
    return 0;
  }
  return result;
}

uint64_t sub_244D12618(uint64_t a1, _OWORD *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!*(unsigned char *)(v3 + 64))
  {
    int v4 = 130;
    __int16 v5 = 74;
    goto LABEL_6;
  }
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      int v4 = 100;
      __int16 v5 = 84;
LABEL_6:
      sub_244D0B884(6, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", v5);
      return 0;
    }
    long long v7 = *(_OWORD *)(v3 + 48);
    *a2 = *(_OWORD *)(v3 + 32);
    a2[1] = v7;
  }
  *a3 = 32;
  return 1;
}

uint64_t sub_244D1269C(uint64_t a1, _OWORD *a2, void *a3)
{
  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      sub_244D0B884(6, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", 102);
      return 0;
    }
    int v4 = *(_OWORD **)(a1 + 8);
    long long v5 = v4[1];
    *a2 = *v4;
    a2[1] = v5;
  }
  *a3 = 32;
  return 1;
}

uint64_t sub_244D12700(uint64_t a1, void *a2)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    int v4 = sub_244D442F4(v2, 0x20uLL);
    *a2 = v4;
    return 32 * (v4 != 0);
  }
  else
  {
    sub_244D0B884(6, 0, 120, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/p_x25519_asn1.c", 120);
    return 0;
  }
}

uint64_t sub_244D12764()
{
  return 32;
}

uint64_t sub_244D1276C()
{
  return 253;
}

void sub_244D12774(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

BOOL sub_244D127A0(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unint64_t a7, char *a8)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  unint64_t v14 = sub_244CF48E0(a6);
  uint64_t v25 = 0;
  memset(v24, 0, sizeof(v24));
  sub_244D2EAD0((uint64_t)v24);
  if (!sub_244D2EAF4((uint64_t)v24, a1, a2, a6))
  {
LABEL_24:
    BOOL v22 = 0;
    goto LABEL_25;
  }
  if (a7)
  {
    int v15 = 1;
    do
    {
      size_t v16 = v14 >= a7 ? a7 : v14;
      if (!sub_244D2EAF4((uint64_t)v24, 0, 0, 0)
        || !sub_244D2ECD0((uint64_t)v24)
        || !sub_244D2ECD0((uint64_t)v24)
        || !sub_244D2ECF4((uint64_t)v24, (uint64_t)__src, 0))
      {
        goto LABEL_24;
      }
      if (v16) {
        memcpy(a8, __src, v16);
      }
      if (a5 >= 2)
      {
        int v17 = 1;
        while (sub_244D2EAF4((uint64_t)v24, 0, 0, 0)
             && sub_244D2ECD0((uint64_t)v24)
             && sub_244D2ECF4((uint64_t)v24, (uint64_t)__src, 0))
        {
          if (v16)
          {
            int v18 = __src;
            size_t v19 = a8;
            size_t v20 = v16;
            do
            {
              char v21 = *v18++;
              *v19++ ^= v21;
              --v20;
            }
            while (v20);
          }
          if (++v17 == a5) {
            goto LABEL_22;
          }
        }
        goto LABEL_24;
      }
LABEL_22:
      a8 += v16;
      ++v15;
      a7 -= v16;
    }
    while (a7);
  }
  BOOL v22 = a5 != 0;
LABEL_25:
  sub_244D2EDC0(v24);
  return v22;
}

BOOL sub_244D129A8(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unint64_t a6, char *a7)
{
  unint64_t v14 = sub_244D25B18();

  return sub_244D127A0(a1, a2, a3, a4, a5, (uint64_t)v14, a6, a7);
}

uint64_t sub_244D12A2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_244CF48E0(a2);
  uint64_t v7 = 0;
  while (dword_26F9551F0[v7] != v6)
  {
    v7 += 8;
    if (v7 == 24)
    {
      sub_244CF8A00(a1, a3, 0x80u);
      sub_244CF98F4(a1, "%s algorithm unsupported\n", "Public Key");
      return 1;
    }
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))&dword_26F9551F0[v7 + 2];

  return v9(a1, a2, a3);
}

uint64_t sub_244D12AF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_244CF48E0(a2);
  uint64_t v7 = 0;
  while (dword_26F9551F0[v7] != v6)
  {
    v7 += 8;
    if (v7 == 24)
    {
      sub_244CF8A00(a1, a3, 0x80u);
      sub_244CF98F4(a1, "%s algorithm unsupported\n", "Private Key");
      return 1;
    }
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))&dword_26F9551F0[v7 + 4];

  return v9(a1, a2, a3);
}

uint64_t sub_244D12BC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_244CF48E0(a2);
  uint64_t v7 = 0;
  while (dword_26F9551F0[v7] != v6)
  {
    v7 += 8;
    if (v7 == 24) {
      goto LABEL_9;
    }
  }
  if (!(v7 * 4))
  {
LABEL_9:
    sub_244CF8A00(a1, a3, 0x80u);
    sub_244CF98F4(a1, "%s algorithm unsupported\n", "Parameters");
    return 1;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))&dword_26F9551F0[v7 + 6];

  return v8(a1, a2, a3);
}

uint64_t sub_244D12C98(uint64_t a1, uint64_t a2, unsigned int a3)
{
  long long v5 = (uint64_t ***)sub_244D11F18(a2);

  return sub_244D12EF8(a1, v5, a3, 0);
}

uint64_t sub_244D12CE4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  long long v5 = (uint64_t ***)sub_244D11F18(a2);

  return sub_244D12EF8(a1, v5, a3, 1);
}

uint64_t sub_244D12D30(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = sub_244D0F0B8(a2);

  return sub_244D1335C(a1, v5, a3, 1);
}

uint64_t sub_244D12D7C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = sub_244D0F0B8(a2);

  return sub_244D1335C(a1, v5, a3, 2);
}

uint64_t sub_244D12DC8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = sub_244D0F0B8(a2);

  return sub_244D1335C(a1, v5, a3, 0);
}

uint64_t sub_244D12E14(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = (uint64_t *)sub_244D0FDD8(a2);

  return sub_244D13514(a1, v5, a3, 1);
}

uint64_t sub_244D12E60(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = (uint64_t *)sub_244D0FDD8(a2);

  return sub_244D13514(a1, v5, a3, 2);
}

uint64_t sub_244D12EAC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = (uint64_t *)sub_244D0FDD8(a2);

  return sub_244D13514(a1, v5, a3, 0);
}

uint64_t sub_244D12EF8(uint64_t a1, uint64_t ***a2, unsigned int a3, int a4)
{
  uint64_t v8 = (uint64_t *)a2[1];
  if (v8) {
    int v9 = sub_244D168EC(v8);
  }
  else {
    int v9 = 0;
  }
  uint64_t result = sub_244CF8A00(a1, a3, 0x80u);
  if (!result) {
    return result;
  }
  if (!a4 || !a2[3])
  {
    if ((int)sub_244CF98F4(a1, "Public-Key: (%d bit)\n", v9) >= 1)
    {
      uint64_t v11 = "Modulus:";
      uint64_t v12 = "Exponent:";
      goto LABEL_11;
    }
    return 0;
  }
  if ((int)sub_244CF98F4(a1, "Private-Key: (%d bit)\n", v9) < 1) {
    return 0;
  }
  uint64_t v11 = "modulus:";
  uint64_t v12 = "publicExponent:";
LABEL_11:
  uint64_t result = sub_244D130B4(a1, v11, a2[1], a3);
  if (result)
  {
    uint64_t result = sub_244D130B4(a1, v12, a2[2], a3);
    if (result)
    {
      if (!a4) {
        return 1;
      }
      uint64_t result = sub_244D130B4(a1, "privateExponent:", a2[3], a3);
      if (result)
      {
        uint64_t result = sub_244D130B4(a1, "prime1:", a2[4], a3);
        if (result)
        {
          uint64_t result = sub_244D130B4(a1, "prime2:", a2[5], a3);
          if (result)
          {
            uint64_t result = sub_244D130B4(a1, "exponent1:", a2[6], a3);
            if (result)
            {
              uint64_t result = sub_244D130B4(a1, "exponent2:", a2[7], a3);
              if (result)
              {
                uint64_t result = sub_244D130B4(a1, "coefficient:", a2[8], a3);
                if (result) {
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_244D130B4(uint64_t a1, const char *a2, uint64_t **a3, unsigned int a4)
{
  if (!a3) {
    return 1;
  }
  if (!sub_244CF8A00(a1, a4, 0x80u)) {
    return 0;
  }
  if (sub_244D160FC((uint64_t)a3))
  {
    int v8 = sub_244CF98F4(a1, "%s 0\n");
    return v8 > 0;
  }
  uint64_t v21 = 0;
  int v10 = sub_244D17058(a3, &v21);
  BOOL v11 = sub_244D16B50((uint64_t)a3);
  if (v10)
  {
    int v8 = sub_244CF98F4(a1, "%s %s%llu (%s0x%llx)\n");
    return v8 > 0;
  }
  uint64_t v12 = " (Negative)";
  if (!v11) {
    uint64_t v12 = "";
  }
  if ((int)sub_244CF98F4(a1, "%s%s", a2, v12) < 1) {
    return 0;
  }
  uint64_t v13 = sub_244D1695C((uint64_t *)a3);
  unint64_t v14 = (unsigned __int8 *)sub_244D43FF4(v13 + 1);
  if (!v14) {
    return 0;
  }
  int v15 = v14;
  *unint64_t v14 = 0;
  size_t v16 = v14 + 1;
  sub_244D16EC0((uint64_t)a3, (char *)v14 + 1);
  if (v13 && (char)*v16 < 0)
  {
    uint64_t v17 = a1;
    int v18 = v15;
    uint64_t v19 = v13 + 1;
  }
  else
  {
    uint64_t v17 = a1;
    int v18 = v16;
    uint64_t v19 = v13;
  }
  uint64_t v9 = sub_244D1324C(v17, v18, v19, a4);
  sub_244D440EC(v15);
  return v9;
}

uint64_t sub_244D1324C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  unsigned int v9 = a4 + 4;
  while (a3)
  {
    if (!(v7 - v8 / 0xF + 16 * (v8 / 0xF)))
    {
      if ((int)sub_244CF8634(a1, "\n") < 1) {
        return 0;
      }
      uint64_t result = sub_244CF8A00(a1, v9, 0x80u);
      if (!result) {
        return result;
      }
    }
    int v12 = *a2++;
    int v11 = v12;
    ++v8;
    if (--a3) {
      uint64_t v13 = ":";
    }
    else {
      uint64_t v13 = "";
    }
    --v7;
    if ((int)sub_244CF98F4(a1, "%02x%s", v11, v13) < 1) {
      return 0;
    }
  }
  return (int)sub_244CF8524(a1, (uint64_t)"\n", 1) > 0;
}

uint64_t sub_244D1335C(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  if (a4 == 2)
  {
    uint64_t v8 = sub_244D07404(a2);
LABEL_4:
    int v10 = (uint64_t **)sub_244D073FC(a2);
    unsigned int v9 = (uint64_t **)v8;
    goto LABEL_5;
  }
  uint64_t v8 = 0;
  unsigned int v9 = 0;
  int v10 = 0;
  if (a4 >= 1) {
    goto LABEL_4;
  }
LABEL_5:
  if (!sub_244CF8A00(a1, a3, 0x80u)) {
    return 0;
  }
  int v11 = "DSA-Parameters";
  if (a4 == 1) {
    int v11 = "Public-Key";
  }
  int v12 = a4 == 2 ? "Private-Key" : v11;
  uint64_t v13 = (uint64_t *)sub_244D0740C(a2);
  int v14 = sub_244D168EC(v13);
  if ((int)sub_244CF98F4(a1, "%s: (%u bit)\n", v12, v14) < 1) {
    return 0;
  }
  if (!sub_244D130B4(a1, "priv:", v9, a3)) {
    return 0;
  }
  if (!sub_244D130B4(a1, "pub:", v10, a3)) {
    return 0;
  }
  int v15 = (uint64_t **)sub_244D0740C(a2);
  if (!sub_244D130B4(a1, "P:", v15, a3)) {
    return 0;
  }
  size_t v16 = (uint64_t **)sub_244CF48E8(a2);
  if (!sub_244D130B4(a1, "Q:", v16, a3)) {
    return 0;
  }
  uint64_t v17 = (uint64_t **)sub_244D07414(a2);

  return sub_244D130B4(a1, "G:", v17, a3);
}

uint64_t sub_244D13514(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  if (!a2 || (uint64_t v8 = sub_244D0740C((uint64_t)a2)) == 0)
  {
    sub_244D0B884(6, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/evp/print.c", 246);
    return 0;
  }
  uint64_t v9 = v8;
  int v10 = "ECDSA-Parameters";
  if (a4 == 1) {
    int v10 = "Public-Key";
  }
  if (a4 == 2) {
    int v11 = "Private-Key";
  }
  else {
    int v11 = v10;
  }
  uint64_t result = sub_244CF8A00(a1, a3, 0x80u);
  if (result)
  {
    int v13 = sub_244D28A08(v9);
    if (v13) {
      int v14 = sub_244D28A18(v13);
    }
    else {
      int v14 = "unknown curve";
    }
    if ((int)sub_244CF98F4(a1, "%s: (%s)\n", v11, v14) < 1) {
      return 0;
    }
    if (a4 == 2)
    {
      int v15 = (uint64_t **)sub_244D07414((uint64_t)a2);
      if (v15)
      {
        uint64_t result = sub_244D130B4(a1, "priv:", v15, a3);
        if (!result) {
          return result;
        }
      }
    }
    else if (a4 < 1)
    {
      return 1;
    }
    if (sub_244CF48E8((uint64_t)a2))
    {
      size_t v20 = 0;
      int v16 = sub_244CF8824((uint64_t)a2);
      uint64_t v17 = sub_244D2AD94(a2, v16, (char **)&v20);
      if (v17)
      {
        uint64_t v18 = (uint64_t)v17;
        if (sub_244CF8A00(a1, a3, 0x80u) && (int)sub_244CF8634(a1, "pub:") > 0)
        {
          int v19 = sub_244D1324C(a1, (unsigned __int8 *)v20, v18, a3);
          sub_244D440EC(v20);
          if (v19) {
            return 1;
          }
        }
        else
        {
          sub_244D440EC(v20);
        }
      }
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D136D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_244D43FF4(0x20uLL);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v8;
  *uint64_t v8 = a2;
  v8[1] = a3;
  void v8[2] = a4;
  _OWORD v8[3] = 0;
  sub_244D4BD70((pthread_rwlock_t *)a1);
  unint64_t v10 = atomic_load((unsigned int *)(a1 + 216));
  if ((*(unsigned __int8 *)(a1 + 220) ^ 0x7FFFFFFFuLL) < v10)
  {
    sub_244D0B884(14, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/ex_data.c", 152);
    sub_244D4BD90((pthread_rwlock_t *)a1);
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = *(void *)(a1 + 208);
  if (v12) {
    int v13 = (void *)(v12 + 24);
  }
  else {
    int v13 = (void *)(a1 + 200);
  }
  *int v13 = v9;
  *(void *)(a1 + 208) = v9;
  atomic_store(v10 + 1, (unsigned int *)(a1 + 216));
  sub_244D4BD90((pthread_rwlock_t *)a1);
  return v10 + *(unsigned __int8 *)(a1 + 220);
}

uint64_t sub_244D137A8(unint64_t **a1, unsigned int a2, uint64_t a3)
{
  if ((a2 & 0x80000000) != 0) {
    abort();
  }
  uint64_t result = (uint64_t)*a1;
  if (result || (uint64_t result = (uint64_t)sub_244D4B4C8(), (*a1 = (unint64_t *)result) != 0))
  {
    unint64_t v7 = sub_244D259E0(result);
    unint64_t v8 = a2;
    if (v7 > a2)
    {
LABEL_8:
      sub_244D4B53C(*a1, v8, a3);
      return 1;
    }
    else
    {
      uint64_t v9 = a2 - v7 + 1;
      while (1)
      {
        uint64_t result = (uint64_t)sub_244D4BA04(*a1, 0);
        if (!result) {
          break;
        }
        if (!--v9) {
          goto LABEL_8;
        }
      }
    }
  }
  return result;
}

unint64_t *sub_244D13838(uint64_t *a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v3 = *a1;
  if (!v3 || sub_244D259E0(v3) <= (unint64_t)a2) {
    return 0;
  }
  uint64_t v5 = (unint64_t *)*a1;

  return sub_244D4B518(v5, a2);
}

void *sub_244D1389C(void *result)
{
  *uint64_t result = 0;
  return result;
}

void sub_244D138A4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*a3)
  {
    unsigned int v5 = atomic_load((unsigned int *)(a1 + 216));
    if (v5)
    {
      int v7 = 0;
      unint64_t v8 = (void **)(a1 + 200);
      do
      {
        uint64_t v9 = *v8;
        if ((*v8)[2])
        {
          int v10 = *(unsigned __int8 *)(a1 + 220);
          uint64_t v11 = (v7 + v10);
          uint64_t v12 = sub_244D13838(a3, v7 + v10);
          ((void (*)(uint64_t, unint64_t *, uint64_t *, uint64_t, void, void))(*v8)[2])(a2, v12, a3, v11, **v8, (*v8)[1]);
          uint64_t v9 = *v8;
        }
        unint64_t v8 = (void **)(v9 + 3);
        ++v7;
      }
      while (v5 != v7);
    }
    sub_244CF474C(*a3);
    *a3 = 0;
  }
}

uint64_t *sub_244D13964(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(v8, 0, 512);
  sub_244D14138((uint64_t)v8, a3);
  memset(v7, 0, sizeof(v7));
  sub_244D141B0((uint64_t *)v7, a1, 1);
  sub_244D1425C((uint64_t)v8, *(unsigned int *)(a3 + 240), (uint64_t *)v7);
  return sub_244D14400(a2, 1, v7);
}

uint64_t *sub_244D13A2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(v8, 0, 512);
  sub_244D14138((uint64_t)v8, a3);
  memset(v7, 0, sizeof(v7));
  sub_244D141B0((uint64_t *)v7, a1, 1);
  sub_244D144EC((uint64_t)v8, *(unsigned int *)(a3 + 240), (uint64_t)v7);
  return sub_244D14400(a2, 1, v7);
}

uint64_t sub_244D13AF0(_OWORD *a1, int a2, uint64_t a3)
{
  if (a2 == 128 || a2 == 256 || a2 == 192) {
    return sub_244D13B14(a1, a2, a3);
  }
  else {
    return 4294967294;
  }
}

uint64_t sub_244D13B14(_OWORD *a1, int a2, uint64_t a3)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  switch(a2)
  {
    case 256:
      *(_DWORD *)(a3 + 240) = 14;
      *(_OWORD *)unsigned int v110 = *a1;
      unint64_t v24 = (v110[0] ^ ((unint64_t)v110[0] >> 4)) & 0xF000F000F000F0;
      uint64_t v25 = v110[0] ^ (16 * v24);
      unint64_t v26 = v25 ^ v24;
      uint64_t v27 = (v25 ^ (v26 >> 8)) & 0xFF000000FF00;
      uint64_t v28 = v26 ^ (v27 << 8);
      unint64_t v29 = v28 ^ v27;
      uint64_t v30 = ((v29 >> 16) ^ v28) & 0xFFFF0000;
      uint64_t v31 = (v110[1] ^ ((unint64_t)v110[1] >> 4)) & 0xF000F000F000F0;
      uint64_t v32 = v110[1] ^ (16 * v31);
      unint64_t v33 = v32 ^ v31;
      uint64_t v34 = (v32 ^ (v33 >> 8)) & 0xFF000000FF00;
      uint64_t v35 = v33 ^ (v34 << 8);
      unint64_t v36 = v35 ^ v34;
      uint64_t v37 = ((v36 >> 16) ^ v35) & 0xFFFF0000;
      v110[0] = v30 ^ v29 | ((unint64_t)(v37 ^ v36) << 32);
      v110[1] = (v36 & 0xFFFFFFFF00000000 ^ (v37 << 16)) & 0xFFFFFFFF00000000 | ((v29 ^ (v30 << 16)) >> 32);
      *(_OWORD *)a3 = *(_OWORD *)v110;
      long long v109 = a1[1];
      unint64_t v38 = (v109 ^ ((unint64_t)v109 >> 4)) & 0xF000F000F000F0;
      uint64_t v39 = v109 ^ (16 * v38);
      unint64_t v40 = v39 ^ v38;
      uint64_t v41 = (v39 ^ (v40 >> 8)) & 0xFF000000FF00;
      uint64_t v42 = v40 ^ (v41 << 8);
      unint64_t v43 = v42 ^ v41;
      uint64_t v44 = ((v43 >> 16) ^ v42) & 0xFFFF0000;
      uint64_t v45 = (*((void *)&v109 + 1) ^ (*((void *)&v109 + 1) >> 4)) & 0xF000F000F000F0;
      uint64_t v46 = *((void *)&v109 + 1) ^ (16 * v45);
      unint64_t v47 = v46 ^ v45;
      uint64_t v48 = (v46 ^ (v47 >> 8)) & 0xFF000000FF00;
      uint64_t v49 = v47 ^ (v48 << 8);
      unint64_t v50 = v49 ^ v48;
      uint64_t v51 = ((v50 >> 16) ^ v49) & 0xFFFF0000;
      *(void *)&long long v109 = v44 ^ v43 | ((unint64_t)(v51 ^ v50) << 32);
      *((void *)&v109 + 1) = (v50 & 0xFFFFFFFF00000000 ^ (v51 << 16)) & 0xFFFFFFFF00000000 | ((v43 ^ (v44 << 16)) >> 32);
      *(_OWORD *)(a3 + 16) = v109;
      for (unint64_t i = 2; ; i += 2)
      {
        sub_244D3A938(v108, (uint64_t *)&v109);
        uint64_t v53 = 0;
        unsigned int v54 = *((unsigned __int8 *)&unk_244EB74C7 + (i >> 1) - 1);
        char v55 = 1;
        do
        {
          char v56 = v55;
          uint64_t v57 = v110[v53] ^ (v54 >> (4 * v53)) & 0xF ^ ((v108[v53] >> 36) & 0xF000 | (v108[v53] >> 52));
          v110[v53] = (v57 << 16) ^ (v57 << 32) ^ (v57 << 48) ^ v57;
          uint64_t v53 = 1;
          char v55 = 0;
        }
        while ((v56 & 1) != 0);
        *(_OWORD *)(a3 + 16 * i) = *(_OWORD *)v110;
        if (i == 14) {
          break;
        }
        sub_244D3A938(v108, v110);
        uint64_t v58 = 0;
        char v59 = 1;
        do
        {
          char v60 = v59;
          uint64_t v61 = HIWORD(v108[v58]) ^ v110[v58 - 2];
          v110[v58 - 2] = (v61 << 16) ^ (v61 << 32) ^ (v61 << 48) ^ v61;
          uint64_t v58 = 1;
          char v59 = 0;
        }
        while ((v60 & 1) != 0);
        *(_OWORD *)(a3 + ((16 * i) | 0x10)) = v109;
      }
      return 0;
    case 192:
      uint64_t v62 = 0;
      *(_DWORD *)(a3 + 240) = 12;
      *(_OWORD *)unsigned int v110 = *a1;
      unint64_t v63 = (v110[0] ^ ((unint64_t)v110[0] >> 4)) & 0xF000F000F000F0;
      uint64_t v64 = v110[0] ^ (16 * v63);
      unint64_t v65 = v64 ^ v63;
      uint64_t v66 = (v64 ^ (v65 >> 8)) & 0xFF000000FF00;
      uint64_t v67 = v65 ^ (v66 << 8);
      unint64_t v68 = v67 ^ v66;
      uint64_t v69 = ((v68 >> 16) ^ v67) & 0xFFFF0000;
      uint64_t v70 = (v110[1] ^ ((unint64_t)v110[1] >> 4)) & 0xF000F000F000F0;
      uint64_t v71 = v110[1] ^ (16 * v70);
      unint64_t v72 = v71 ^ v70;
      uint64_t v73 = (v71 ^ (v72 >> 8)) & 0xFF000000FF00;
      uint64_t v74 = v72 ^ (v73 << 8);
      unint64_t v75 = v74 ^ v73;
      uint64_t v76 = ((v75 >> 16) ^ v74) & 0xFFFF0000;
      v110[0] = v69 ^ v68 | ((unint64_t)(v76 ^ v75) << 32);
      v110[1] = (v75 & 0xFFFFFFFF00000000 ^ (v76 << 16)) & 0xFFFFFFFF00000000 | ((v68 ^ (v69 << 16)) >> 32);
      *(_OWORD *)a3 = *(_OWORD *)v110;
      unint64_t v77 = *((void *)a1 + 2);
      uint64_t v78 = (v77 ^ (v77 >> 4)) & 0xF000F000F000F0;
      uint64_t v79 = v77 ^ (16 * v78);
      unint64_t v80 = v79 ^ v78;
      uint64_t v81 = (v79 ^ (v80 >> 8)) & 0xFF000000FF00;
      uint64_t v82 = v80 ^ (v81 << 8);
      unint64_t v83 = v82 ^ v81;
      uint64_t v84 = ((v83 >> 16) ^ v82) & 0xFFFF0000;
      *(void *)&long long v109 = v84 ^ v83;
      *((void *)&v109 + 1) = (v83 ^ (v84 << 16)) >> 32;
      int v85 = (uint64_t *)&v109;
      unsigned int v86 = v110;
      do
      {
        unsigned int v87 = v86;
        sub_244D3A938(v108, v85);
        uint64_t v88 = 0;
        unsigned int v89 = *((unsigned __int8 *)&unk_244EB74C7 + 2 * v62);
        char v90 = 1;
        do
        {
          uint64_t v91 = v85[v88];
          uint64_t v92 = v87[v88];
          unint64_t v93 = v91 | ((unint64_t)(v92 ^ (v89 >> (4 * v88)) & 0xF) << 32);
          v85[v88] = v93;
          uint64_t v94 = (v108[v88] >> 4) & 0xFFF0000 | (((v108[v88] >> 16) & 0xFLL) << 28);
          unint64_t v95 = v93 ^ (v94 << 16) ^ ((v93 ^ (v94 << 16)) >> 32 << 48);
          v85[v88] = v95;
          char v96 = v90;
          *((void *)&v97 + 1) = v91;
          *(void *)&long long v97 = v92;
          v87[v88] = (((unint64_t)(v97 >> 32) ^ HIWORD(v95)) << 16) ^ (((unint64_t)(v97 >> 32) ^ HIWORD(v95)) << 32) ^ (((unint64_t)(v97 >> 32) ^ HIWORD(v95)) << 48) ^ (v97 >> 32) ^ HIWORD(v95);
          uint64_t v88 = 1;
          char v90 = 0;
        }
        while ((v96 & 1) != 0);
        uint64_t v98 = a3 + 48 * v62;
        *(_OWORD *)(v98 + 16) = *(_OWORD *)v85;
        *(_OWORD *)(v98 + 32) = *(_OWORD *)v87;
        sub_244D3A938(v108, v87);
        uint64_t v99 = 0;
        unsigned int v100 = *((unsigned __int8 *)&unk_244EB74C7 + ((2 * v62) | 1));
        char v101 = 1;
        do
        {
          char v102 = v101;
          *((void *)&v103 + 1) = v87[v99];
          *(void *)&long long v103 = v85[v99];
          uint64_t v104 = (v103 >> 32) ^ (v100 >> (4 * v99)) & 0xF;
          v85[v99] = v104;
          uint64_t v105 = ((v108[v99] >> 36) & 0xF000 | (v108[v99] >> 52)) ^ v104;
          unint64_t v106 = (v105 << 16) ^ (v105 << 32) ^ (v105 << 48) ^ v105;
          v85[v99] = v106;
          v87[v99] = ((HIWORD(v106) ^ HIDWORD(v103)) << 16) ^ HIWORD(v106) ^ HIDWORD(*((void *)&v103 + 1));
          uint64_t v99 = 1;
          char v101 = 0;
        }
        while ((v102 & 1) != 0);
        *(_OWORD *)(a3 + 48 * v62++ + 48) = *(_OWORD *)v85;
        unsigned int v86 = v85;
        int v85 = v87;
      }
      while (v62 != 4);
      return 0;
    case 128:
      *(_DWORD *)(a3 + 240) = 10;
      *(_OWORD *)unsigned int v110 = *a1;
      unint64_t v4 = (v110[0] ^ ((unint64_t)v110[0] >> 4)) & 0xF000F000F000F0;
      uint64_t v5 = v110[0] ^ (16 * v4);
      unint64_t v6 = v5 ^ v4;
      uint64_t v7 = (v5 ^ (v6 >> 8)) & 0xFF000000FF00;
      uint64_t v8 = v6 ^ (v7 << 8);
      unint64_t v9 = v8 ^ v7;
      uint64_t v10 = ((v9 >> 16) ^ v8) & 0xFFFF0000;
      uint64_t v11 = (v110[1] ^ ((unint64_t)v110[1] >> 4)) & 0xF000F000F000F0;
      uint64_t v12 = v110[1] ^ (16 * v11);
      unint64_t v13 = v12 ^ v11;
      uint64_t v14 = (v12 ^ (v13 >> 8)) & 0xFF000000FF00;
      uint64_t v15 = v13 ^ (v14 << 8);
      unint64_t v16 = v15 ^ v14;
      uint64_t v17 = ((v16 >> 16) ^ v15) & 0xFFFF0000;
      v110[0] = v10 ^ v9 | ((unint64_t)(v17 ^ v16) << 32);
      v110[1] = (v16 & 0xFFFFFFFF00000000 ^ (v17 << 16)) & 0xFFFFFFFF00000000 | ((v9 ^ (v10 << 16)) >> 32);
      *(_OWORD *)a3 = *(_OWORD *)v110;
      uint64_t v18 = 1u;
      do
      {
        sub_244D3A938(&v109, v110);
        uint64_t v19 = 0;
        unsigned int v20 = *((unsigned __int8 *)&unk_244EB74C7 + v18 - 1);
        char v21 = 1;
        do
        {
          char v22 = v21;
          uint64_t v23 = v110[v19] ^ (v20 >> (4 * v19)) & 0xF ^ (((unint64_t)v110[v19 - 2] >> 36) & 0xF000 | ((unint64_t)v110[v19 - 2] >> 52));
          v110[v19] = (v23 << 16) ^ (v23 << 32) ^ (v23 << 48) ^ v23;
          uint64_t v19 = 1;
          char v21 = 0;
        }
        while ((v22 & 1) != 0);
        *(_OWORD *)(a3 + 16 * v18++) = *(_OWORD *)v110;
      }
      while (v18 != 11);
      return 0;
  }
  return 1;
}

uint64_t *sub_244D14138(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  uint64_t v5 = a1;
  do
  {
    uint64_t v6 = 0;
    uint64_t v7 = (void *)(a2 + 16 * v4);
    do
    {
      uint64_t v8 = v7[1];
      unint64_t v9 = (void *)(v5 + v6);
      *unint64_t v9 = *v7;
      v9[4] = v8;
      v6 += 8;
    }
    while (v6 != 32);
    uint64_t result = sub_244D3A9A4((uint64_t *)(a1 + (v4 << 6)));
    v5 += 64;
  }
  while (v4++ < *(unsigned int *)(a2 + 240));
  return result;
}

uint64_t *sub_244D141B0(uint64_t *result, uint64_t a2, uint64_t a3)
{
  *((_OWORD *)result + 2) = 0u;
  *((_OWORD *)result + 3) = 0u;
  *(_OWORD *)uint64_t result = 0u;
  *((_OWORD *)result + 1) = 0u;
  if (a3)
  {
    uint64_t v3 = (void *)(a2 + 8);
    unint64_t v4 = result + 4;
    do
    {
      unint64_t v5 = *(v3 - 1);
      uint64_t v6 = (v5 ^ (v5 >> 4)) & 0xF000F000F000F0;
      uint64_t v7 = v5 ^ (16 * v6);
      unint64_t v8 = v7 ^ v6;
      uint64_t v9 = (v7 ^ (v8 >> 8)) & 0xFF000000FF00;
      uint64_t v10 = v8 ^ (v9 << 8);
      unint64_t v11 = v10 ^ v9;
      uint64_t v12 = ((v11 >> 16) ^ v10) & 0xFFFF0000;
      uint64_t v13 = (*v3 ^ (*v3 >> 4)) & 0xF000F000F000F0;
      uint64_t v14 = *v3 ^ (16 * v13);
      unint64_t v15 = v14 ^ v13;
      uint64_t v16 = (v14 ^ (v15 >> 8)) & 0xFF000000FF00;
      uint64_t v17 = v15 ^ (v16 << 8);
      unint64_t v18 = v17 ^ v16;
      uint64_t v19 = ((v18 >> 16) ^ v17) & 0xFFFF0000;
      *(v4 - 4) = v12 ^ v11 | ((unint64_t)(v19 ^ v18) << 32);
      *v4++ = (v18 & 0xFFFFFFFF00000000 ^ (v19 << 16)) & 0xFFFFFFFF00000000 | ((v11 ^ (v12 << 16)) >> 32);
      v3 += 2;
      --a3;
    }
    while (a3);
  }
  return sub_244D3A9A4(result);
}

uint64_t *sub_244D1425C(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  for (uint64_t i = 0; i != 8; ++i)
    a3[i] ^= *(void *)(a1 + i * 8);
  if (a2 >= 2)
  {
    uint64_t v7 = a1 + 64;
    for (uint64_t j = 1; j != a2; ++j)
    {
      sub_244D3AA48(a3);
      uint64_t v9 = 0;
      v10.i64[0] = 0xF000F000F000FLL;
      v10.i64[1] = 0xF000F000F000FLL;
      v11.i64[0] = 0xF000F000F000F0;
      v11.i64[1] = 0xF000F000F000F0;
      v12.i64[0] = 0xF000F000F000F00;
      v12.i64[1] = 0xF000F000F000F00;
      v13.i64[0] = 0xF000F000F000F000;
      v13.i64[1] = 0xF000F000F000F000;
      do
      {
        int8x16_t v14 = *(int8x16_t *)&a3[v9];
        int8x16_t v15 = vandq_s8(v14, v10);
        int64x2_t v16 = (int64x2_t)vandq_s8(v14, v11);
        int64x2_t v17 = (int64x2_t)vandq_s8(v14, v12);
        int64x2_t v18 = (int64x2_t)vandq_s8(v14, v13);
        *(int8x16_t *)&a3[v9] = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v17, 0x20uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v17, 0x20uLL)), v15), vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v18, 0x10uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v18, 0x30uLL)), vorrq_s8((int8x16_t)vshlq_n_s64(v16, 0x30uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v16, 0x10uLL))));
        v9 += 2;
      }
      while (v9 != 8);
      sub_244D3AC78((uint64_t)a3);
      for (uint64_t k = 0; k != 8; ++k)
        a3[k] ^= *(void *)(v7 + k * 8);
      v7 += 64;
    }
  }
  uint64_t result = sub_244D3AA48(a3);
  uint64_t v21 = 0;
  v22.i64[0] = 0xF000F000F000FLL;
  v22.i64[1] = 0xF000F000F000FLL;
  v23.i64[0] = 0xF000F000F000F0;
  v23.i64[1] = 0xF000F000F000F0;
  v24.i64[0] = 0xF000F000F000F00;
  v24.i64[1] = 0xF000F000F000F00;
  v25.i64[0] = 0xF000F000F000F000;
  v25.i64[1] = 0xF000F000F000F000;
  do
  {
    int8x16_t v26 = *(int8x16_t *)&a3[v21];
    int8x16_t v27 = vandq_s8(v26, v22);
    int64x2_t v28 = (int64x2_t)vandq_s8(v26, v23);
    int64x2_t v29 = (int64x2_t)vandq_s8(v26, v24);
    int64x2_t v30 = (int64x2_t)vandq_s8(v26, v25);
    *(int8x16_t *)&a3[v21] = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v29, 0x20uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v29, 0x20uLL)), v27), vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v30, 0x10uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v30, 0x30uLL)), vorrq_s8((int8x16_t)vshlq_n_s64(v28, 0x30uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v28, 0x10uLL))));
    v21 += 2;
  }
  while (v21 != 8);
  for (uint64_t m = 0; m != 8; ++m)
    a3[m] ^= *(void *)(a1 + (a2 << 6) + m * 8);
  return result;
}

uint64_t *sub_244D14400(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  long long v5 = a3[1];
  v21[0] = *a3;
  v21[1] = v5;
  long long v6 = a3[3];
  v22[0] = a3[2];
  v22[1] = v6;
  uint64_t result = sub_244D3A9A4((uint64_t *)v21);
  if (a2)
  {
    unint64_t v8 = (unint64_t *)(a1 + 8);
    uint64_t v9 = (uint64_t *)v22;
    do
    {
      uint64_t v10 = *(v9 - 4);
      uint64_t v11 = *v9++;
      uint64_t v12 = (v10 ^ (v11 << 16)) & 0xFFFF0000;
      unint64_t v13 = (v10 | ((unint64_t)v11 << 32)) ^ (v12 << 16);
      unint64_t v14 = v13 ^ v12;
      uint64_t v15 = (v13 ^ (v14 >> 8)) & 0xFF000000FF00;
      unint64_t v16 = v11 & 0xFFFFFFFF00000000 | HIDWORD(v10);
      uint64_t v17 = (((v11 & 0xFFFFFFFF00000000) >> 16) ^ HIDWORD(v10)) & 0xFFFF0000;
      unint64_t v18 = v16 ^ (v17 << 16);
      unint64_t v19 = v18 ^ v17;
      uint64_t v20 = (v18 ^ (v19 >> 8)) & 0xFF000000FF00;
      *(v8 - 1) = v14 ^ (v15 << 8) ^ v15 ^ (16
                                          * ((v14 ^ (v15 << 8) ^ ((v14 ^ (v15 << 8) ^ v15) >> 4)) & 0xF000F000F000F0)) ^ (v14 ^ (v15 << 8) ^ ((v14 ^ (v15 << 8) ^ v15) >> 4)) & 0xF000F000F000F0;
      *unint64_t v8 = v19 ^ (v20 << 8) ^ v20 ^ (16 * ((v19 ^ (v20 << 8) ^ ((v19 ^ (v20 << 8) ^ v20) >> 4)) & 0xF000F000F000F0)) ^ (v19 ^ (v20 << 8) ^ ((v19 ^ (v20 << 8) ^ v20) >> 4)) & 0xF000F000F000F0;
      v8 += 2;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t *sub_244D144EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = 0; i != 64; i += 8)
    *(void *)(a3 + i) ^= *(void *)(a1 + (a2 << 6) + i);
  uint64_t v7 = 0;
  v8.i64[0] = 0xF000F000F000FLL;
  v8.i64[1] = 0xF000F000F000FLL;
  v9.i64[0] = 0xF000F000F000F0;
  v9.i64[1] = 0xF000F000F000F0;
  v10.i64[0] = 0xF000F000F000F00;
  v10.i64[1] = 0xF000F000F000F00;
  v11.i64[0] = 0xF000F000F000F000;
  v11.i64[1] = 0xF000F000F000F000;
  do
  {
    int8x16_t v12 = *(int8x16_t *)(a3 + v7);
    int8x16_t v13 = vandq_s8(v12, v8);
    int64x2_t v14 = (int64x2_t)vandq_s8(v12, v9);
    int64x2_t v15 = (int64x2_t)vandq_s8(v12, v10);
    int64x2_t v16 = (int64x2_t)vandq_s8(v12, v11);
    *(int8x16_t *)(a3 + v7) = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v15, 0x20uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v15, 0x20uLL)), v13), vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v16, 0x30uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v16, 0x10uLL)), vorrq_s8((int8x16_t)vshlq_n_s64(v14, 0x10uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v14, 0x30uLL))));
    v7 += 16;
  }
  while (v7 != 64);
  sub_244D3ADB0((uint64_t *)a3);
  sub_244D3AA48((uint64_t *)a3);
  uint64_t result = sub_244D3ADB0((uint64_t *)a3);
  uint64_t v18 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v19 = a1 + (a2 << 6) - 64;
    do
    {
      for (uint64_t j = 0; j != 64; j += 8)
        *(void *)(a3 + j) ^= *(void *)(v19 + j);
      int64x2_t v21 = *(int64x2_t *)(a3 + 16);
      int64x2_t v23 = *(int64x2_t *)(a3 + 32);
      int8x16_t v22 = *(int8x16_t *)(a3 + 48);
      int64x2_t v24 = (int64x2_t)vextq_s8(v22, v22, 8uLL);
      v25.i64[0] = 0xFF00FF00FF00FFLL;
      v25.i64[1] = 0xFF00FF00FF00FFLL;
      int8x16_t v26 = veorq_s8(vbslq_s8(v25, (int8x16_t)vshrq_n_u64((uint64x2_t)v24, 8uLL), (int8x16_t)vshlq_n_s64(v24, 8uLL)), (int8x16_t)v24);
      int8x16_t v27 = veorq_s8(veorq_s8(veorq_s8(*(int8x16_t *)a3, (int8x16_t)v21), vbslq_s8(v25, (int8x16_t)vshrq_n_u64(*(uint64x2_t *)a3, 8uLL), (int8x16_t)vshlq_n_s64(*(int64x2_t *)a3, 8uLL))), v26);
      int8x16_t v28 = (int8x16_t)vdupq_lane_s64(v26.i64[0], 0);
      uint64_t v29 = v26.i64[0] ^ v26.i64[1] ^ *(void *)(a3 + 8);
      *(void *)a3 ^= v26.u64[1];
      *(void *)(a3 + 8) = v29;
      v28.i64[0] = v26.i64[0] ^ v26.i64[1];
      *(int8x16_t *)(a3 + 16) = v27;
      *(int8x16_t *)(a3 + 32) = veorq_s8(veorq_s8(veorq_s8(vbslq_s8(v25, (int8x16_t)vshrq_n_u64((uint64x2_t)v21, 8uLL), (int8x16_t)vshlq_n_s64(v21, 8uLL)), (int8x16_t)v21), (int8x16_t)v23), v28);
      *(int8x16_t *)(a3 + 48) = veorq_s8(veorq_s8((int8x16_t)v23, v22), vbslq_s8(v25, (int8x16_t)vshrq_n_u64((uint64x2_t)v23, 8uLL), (int8x16_t)vshlq_n_s64(v23, 8uLL)));
      sub_244D3AC78(a3);
      uint64_t v30 = 0;
      v31.i64[0] = 0xF000F000F000FLL;
      v31.i64[1] = 0xF000F000F000FLL;
      v32.i64[0] = 0xF000F000F000F0;
      v32.i64[1] = 0xF000F000F000F0;
      v33.i64[0] = 0xF000F000F000F00;
      v33.i64[1] = 0xF000F000F000F00;
      v34.i64[0] = 0xF000F000F000F000;
      v34.i64[1] = 0xF000F000F000F000;
      do
      {
        int8x16_t v35 = *(int8x16_t *)(a3 + v30);
        int8x16_t v36 = vandq_s8(v35, v31);
        int64x2_t v37 = (int64x2_t)vandq_s8(v35, v32);
        int64x2_t v38 = (int64x2_t)vandq_s8(v35, v33);
        int64x2_t v39 = (int64x2_t)vandq_s8(v35, v34);
        *(int8x16_t *)(a3 + v30) = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v38, 0x20uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v38, 0x20uLL)), v36), vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(v39, 0x30uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v39, 0x10uLL)), vorrq_s8((int8x16_t)vshlq_n_s64(v37, 0x10uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v37, 0x30uLL))));
        v30 += 16;
      }
      while (v30 != 64);
      sub_244D3ADB0((uint64_t *)a3);
      sub_244D3AA48((uint64_t *)a3);
      uint64_t result = sub_244D3ADB0((uint64_t *)a3);
      v19 -= 64;
      --v18;
    }
    while (v18);
  }
  for (uint64_t k = 0; k != 64; k += 8)
    *(void *)(a3 + k) ^= *(void *)(a1 + k);
  return result;
}

uint64_t *sub_244D14738(uint64_t *result, uint64_t a2, unint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unint64_t v7 = a3;
    int8x16_t v9 = result;
    memset(v21, 0, 512);
    sub_244D14138((uint64_t)v21, a4);
    for (uint64_t i = 0; i != 64; i += 16)
      *(_OWORD *)&v23[i] = *a5;
    for (unsigned int j = bswap32(v24); ; j += 4)
    {
      unsigned int v12 = j;
      for (uint64_t k = 12; k != 76; k += 16)
        *(_DWORD *)&v23[k] = bswap32(v12++);
      unint64_t v14 = v7 >= 4 ? 4 : v7;
      memset(v20, 0, sizeof(v20));
      sub_244D141B0((uint64_t *)v20, (uint64_t)v23, v14);
      sub_244D1425C((uint64_t)v21, *(unsigned int *)(a4 + 240), (uint64_t *)v20);
      uint64_t result = sub_244D14400((uint64_t)v22, v14, v20);
      unint64_t v15 = 0;
      uint64_t v16 = v14 <= 1 ? 1 : v14;
      uint64_t v17 = 16 * v16;
      do
      {
        uint64_t v18 = (uint64_t *)(a2 + v15);
        uint64_t v19 = *(void *)&v22[v15 + 8];
        *uint64_t v18 = *(void *)&v22[v15] ^ v9[v15 / 8];
        v18[1] = v19 ^ v9[v15 / 8 + 1];
        v15 += 16;
      }
      while (v17 != v15);
      v7 -= v14;
      if (!v7) {
        break;
      }
      v9 += 8;
      a2 += 64;
    }
  }
  return result;
}

double sub_244D14900(int8x16_t *a1, int8x16_t *a2, unint64_t a3, uint64_t a4, int8x16_t *a5, int a6)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (a3 >= 0x10)
  {
    unint64_t v11 = a3 >> 4;
    memset(v19, 0, 512);
    sub_244D14138((uint64_t)v19, a4);
    int8x16_t v21 = *a5;
    if (a6)
    {
      do
      {
        int8x16_t v12 = *a1++;
        int8x16_t v21 = veorq_s8(v12, v21);
        memset(v20, 0, sizeof(v20));
        sub_244D141B0((uint64_t *)v20, (uint64_t)&v21, 1);
        sub_244D1425C((uint64_t)v19, *(unsigned int *)(a4 + 240), (uint64_t *)v20);
        sub_244D14400((uint64_t)a2, 1, v20);
        int8x16_t v13 = *a2++;
        int8x16_t v21 = v13;
        --v11;
      }
      while (v11);
    }
    else
    {
      do
      {
        if (v11 >= 4) {
          unint64_t v14 = 4;
        }
        else {
          unint64_t v14 = v11;
        }
        unint64_t v15 = v14;
        __memcpy_chk();
        memset(v18, 0, sizeof(v18));
        sub_244D141B0((uint64_t *)v18, (uint64_t)a1, v14);
        sub_244D144EC((uint64_t)v19, *(unsigned int *)(a4 + 240), (uint64_t)v18);
        sub_244D14400((uint64_t)a2, v14, v18);
        *a2 = veorq_s8(v21, *a2);
        if (v14 >= 2)
        {
          unint64_t v16 = 0;
          do
          {
            a2[v16 / 0x10 + 1] = veorq_s8((int8x16_t)v20[v16 / 0x10], a2[v16 / 0x10 + 1]);
            v16 += 16;
          }
          while (v15 * 16 - 16 != v16);
        }
        int8x16_t v21 = (int8x16_t)v20[v15 - 1];
        a1 += 4;
        a2 += 4;
        v11 -= v14;
      }
      while (v11);
    }
    double result = *(double *)v21.i64;
    *a5 = v21;
  }
  return result;
}

uint64_t sub_244D14B14(uint64_t a1, uint64_t *a2, void *a3, void *__src, size_t __len)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (__len - 16 <= 0x7FFFFFE7 && (__len & 7) == 0)
  {
    if (a2) {
      int8x16_t v9 = a2;
    }
    else {
      int8x16_t v9 = (uint64_t *)&unk_244EB7068;
    }
    memmove(a3 + 1, __src, __len);
    uint64_t v10 = 0;
    uint64_t v15 = *v9;
    size_t v11 = __len >> 3;
    int v12 = 1;
    do
    {
      uint64_t v13 = 0;
      do
      {
        unint64_t v14 = &a3[v13];
        uint64_t v16 = v14[1];
        sub_244D13964((uint64_t)&v15, (uint64_t)&v15, a1);
        HIBYTE(v15) ^= (_BYTE)v12 + (_BYTE)v13;
        BYTE6(v15) ^= (unsigned __int16)(v12 + v13) >> 8;
        BYTE5(v15) ^= (v12 + v13) >> 16;
        BYTE4(v15) ^= (v12 + v13) >> 24;
        v14[1] = v16;
        ++v13;
      }
      while (v11 != v13);
      ++v10;
      v12 += v11;
    }
    while (v10 != 6);
    *a3 = v15;
    return (__len + 8);
  }
  return result;
}

uint64_t sub_244D14C60(uint64_t a1, char *a2, char *__dst, uint64_t *a4, unint64_t a5)
{
  int v5 = a5;
  v9[1] = *MEMORY[0x263EF8340];
  if (!sub_244D14D00(a1, __dst, v9, a4, a5)) {
    return 0xFFFFFFFFLL;
  }
  if (a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = (char *)&unk_244EB7068;
  }
  if (sub_244D441D4((char *)v9, v7, 8)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (v5 - 8);
  }
}

uint64_t sub_244D14D00(uint64_t a1, char *__dst, void *a3, uint64_t *__src, unint64_t a5)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a5 - 24 > 0x7FFFFFE7 || (a5 & 7) != 0) {
    return 0;
  }
  uint64_t v18 = *__src;
  memmove(__dst, __src + 1, a5 - 8);
  unint64_t v11 = a5 >> 3;
  int v12 = __dst - 16;
  uint64_t v13 = 6 * (a5 >> 3) - 6;
  uint64_t v14 = 5;
  uint64_t v15 = 1 - (a5 >> 3);
  do
  {
    int v16 = v13;
    unint64_t v17 = v11;
    do
    {
      HIBYTE(v18) ^= v16;
      BYTE6(v18) ^= BYTE1(v16);
      BYTE5(v18) ^= BYTE2(v16);
      BYTE4(v18) ^= HIBYTE(v16);
      uint64_t v19 = *(void *)&v12[8 * v17];
      sub_244D13A2C((uint64_t)&v18, (uint64_t)&v18, a1);
      *(void *)&v12[8 * v17--] = v19;
      --v16;
    }
    while (v17 != 1);
    --v14;
    LODWORD(v13) = v13 + v15;
  }
  while (v14 < 6);
  *a3 = v18;
  return 1;
}

uint64_t sub_244D14E60(uint64_t a1, void *a2, uint64_t *a3, unint64_t a4, const void *a5, size_t a6)
{
  _OWORD v17[2] = *MEMORY[0x263EF8340];
  size_t v6 = (a6 + 7) & 0xFFFFFFFFFFFFFFF8;
  *a3 = 0;
  if (a6 - 0x100000000 < 0xFFFFFFFF00000001 || v6 + 8 > a4) {
    return 0;
  }
  LODWORD(v17[0]) = -1504093786;
  HIDWORD(v17[0]) = bswap32(a6);
  if (a6 > 8)
  {
    uint64_t result = (uint64_t)sub_244D43FF4((a6 + 7) & 0xFFFFFFFFFFFFFFF8);
    if (!result) {
      return result;
    }
    uint64_t v15 = (void *)result;
    *(void *)(result + v6 - 8) = 0;
    memcpy((void *)result, a5, a6);
    unsigned int v16 = sub_244D14B14(a1, v17, a2, v15, v6);
    sub_244D440EC(v15);
    if ((v16 & 0x80000000) == 0)
    {
      uint64_t v14 = v16;
      goto LABEL_12;
    }
    return 0;
  }
  v17[1] = 0;
  __memcpy_chk();
  sub_244D13964((uint64_t)v17, (uint64_t)a2, a1);
  uint64_t v14 = 16;
LABEL_12:
  *a3 = v14;
  return 1;
}

uint64_t sub_244D14FB0(uint64_t a1, char *__dst, uint64_t *a3, unint64_t a4, uint64_t *__src, unint64_t a6)
{
  v19[1] = *MEMORY[0x263EF8340];
  *a3 = 0;
  if (a6 < 0x10 || a6 - 8 > a4) {
    return 0;
  }
  if (a6 == 16)
  {
    sub_244D13A2C((uint64_t)__src, (uint64_t)v18, a1);
    v19[0] = v18[0];
    *(void *)__dst = v18[1];
  }
  else
  {
    uint64_t result = sub_244D14D00(a1, __dst, v19, __src, a6);
    if (!result) {
      return result;
    }
  }
  int v10 = sub_244D441D4((char *)v19, byte_244EB7070, 4);
  uint64_t v11 = 0;
  uint64_t v12 = bswap32(HIDWORD(v19[0]));
  unint64_t v13 = (v12 - 1) ^ (a6 - 9);
  uint64_t v14 = ((v10 - 1) & ~(uint64_t)v10) >> 63;
  if (!HIDWORD(v19[0])) {
    uint64_t v14 = 0;
  }
  BOOL v15 = __OFSUB__(v13, 8);
  if (v13 >= 8) {
    uint64_t v14 = 0;
  }
  unint64_t v16 = 14 - a6;
  do
  {
    if ((((a6 - 15 - v12 + v11) & v16 & 0x8000000000000000) != 0) != v15) {
      uint64_t v17 = -1;
    }
    else {
      uint64_t v17 = (__dst[a6 - 15 + v11] - 1) >> 63;
    }
    v14 &= v17;
    ++v11;
    --v16;
    BOOL v15 = __OFSUB__(v11, 7);
  }
  while (v11 != 7);
  *a3 = v14 & v12;
  return v14 & 1;
}

uint64_t sub_244D15118(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6, unsigned int *a7)
{
  return sub_244D1512C(a1, a2, a3, a4, a5, a6, a7, (uint64_t (*)(char *, unsigned char *, unint64_t, uint64_t, uint64_t))sub_244D14738);
}

uint64_t sub_244D1512C(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6, unsigned int *a7, uint64_t (*a8)(char *, unsigned char *, unint64_t, uint64_t, uint64_t))
{
  uint64_t v12 = (char *)result;
  unsigned int v13 = *a7;
  if (*a7) {
    BOOL v14 = a3 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    unint64_t v15 = a3;
  }
  else
  {
    do
    {
      char v16 = *v12++;
      *a2++ = *((unsigned char *)a6 + v13) ^ v16;
      unint64_t v15 = a3 - 1;
      unsigned int v13 = ((_BYTE)v13 + 1) & 0xF;
      if (!v13) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  unsigned int v17 = bswap32(*(_DWORD *)(a5 + 12));
  if (v15 >= 0x10)
  {
    do
    {
      unint64_t v18 = v15 >> 4;
      if (v15 >> 4 >= 0x10000000) {
        unint64_t v18 = 0x10000000;
      }
      unint64_t v19 = v17 + v18;
      if (v18 <= v19) {
        v17 += v18;
      }
      else {
        unsigned int v17 = 0;
      }
      if (v18 <= v19) {
        unint64_t v19 = 0;
      }
      unint64_t v20 = v18 - v19;
      uint64_t result = a8(v12, a2, v18 - v19, a4, a5);
      *(_DWORD *)(a5 + 12) = bswap32(v17);
      if (!v17)
      {
        int v21 = 1;
        for (uint64_t i = 11; i != -1; --i)
        {
          unsigned int v23 = v21 + *(unsigned __int8 *)(a5 + i);
          *(unsigned char *)(a5 + i) = v23;
          int v21 = v23 >> 8;
        }
      }
      v15 -= 16 * v20;
      a2 += 16 * v20;
      v12 += 16 * v20;
    }
    while (v15 > 0xF);
  }
  if (v15)
  {
    *a6 = 0;
    a6[1] = 0;
    uint64_t result = a8((char *)a6, a6, 1uLL, a4, a5);
    *(_DWORD *)(a5 + 12) = bswap32(v17 + 1);
    if (v17 == -1)
    {
      int v24 = 1;
      for (uint64_t j = 11; j != -1; --j)
      {
        unsigned int v26 = v24 + *(unsigned __int8 *)(a5 + j);
        *(unsigned char *)(a5 + j) = v26;
        int v24 = v26 >> 8;
      }
    }
    int8x16_t v27 = a7;
    do
    {
      a2[v13] = *((unsigned char *)a6 + v13) ^ v12[v13];
      ++v13;
      --v15;
    }
    while (v15);
  }
  else
  {
    int8x16_t v27 = a7;
  }
  *int8x16_t v27 = v13;
  return result;
}

uint64_t sub_244D152E8(uint64_t result, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6, unsigned int *a7, uint64_t (*a8)(uint64_t, void *, uint64_t))
{
  BOOL v14 = (char *)result;
  unsigned int v15 = *a7;
  if (*a7) {
    BOOL v16 = a3 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (v16)
  {
    unint64_t v17 = a3;
  }
  else
  {
    do
    {
      char v18 = *v14++;
      *(unsigned char *)a2 = *((unsigned char *)a6 + v15) ^ v18;
      a2 = (void *)((char *)a2 + 1);
      unint64_t v17 = a3 - 1;
      unsigned int v15 = (v15 + 1) & 0xF;
      if (!v15) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  if (v17 >= 0x10)
  {
    do
    {
      uint64_t result = a8(a5, a6, a4);
      int v19 = 1;
      for (uint64_t i = 15; i != -1; --i)
      {
        unsigned int v21 = v19 + *(unsigned __int8 *)(a5 + i);
        *(unsigned char *)(a5 + i) = v21;
        int v19 = v21 >> 8;
      }
      *a2 = *a6 ^ *(void *)v14;
      a2[1] = a6[1] ^ *((void *)v14 + 1);
      v17 -= 16;
      a2 += 2;
      v14 += 16;
    }
    while (v17 > 0xF);
    unsigned int v15 = 0;
  }
  if (v17)
  {
    uint64_t result = a8(a5, a6, a4);
    int v22 = 1;
    for (uint64_t j = 15; j != -1; --j)
    {
      unsigned int v24 = v22 + *(unsigned __int8 *)(a5 + j);
      *(unsigned char *)(a5 + j) = v24;
      int v22 = v24 >> 8;
    }
    do
    {
      *((unsigned char *)a2 + v15) = *((unsigned char *)a6 + v15) ^ v14[v15];
      ++v15;
      --v17;
    }
    while (v17);
  }
  *a7 = v15;
  return result;
}

uint64_t *sub_244D15450(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 == 1) {
    return sub_244D13964(a1, a2, a3);
  }
  else {
    return sub_244D13A2C(a1, a2, a3);
  }
}

__n128 sub_244D15464(uint64_t a1, __n128 *a2, unint64_t a3, uint64_t a4, __n128 *a5, void (*a6)(__n128 *, __n128 *, uint64_t))
{
  if (a3)
  {
    int v10 = a2;
    if (a3 < 0x10)
    {
      unint64_t v17 = a5;
      unint64_t i = a3;
    }
    else
    {
      unint64_t v12 = 0;
      unsigned int v13 = a5;
      BOOL v14 = a2;
      for (unint64_t i = a3; i > 0xF; i -= 16)
      {
        BOOL v16 = &v10[v12 / 0x10];
        v16->n128_u64[0] = v13->n128_u64[0] ^ *(void *)(a1 + v12);
        v16->n128_u64[1] = v13->n128_u64[1] ^ *(void *)(a1 + v12 + 8);
        a6(&v10[v12 / 0x10], &v10[v12 / 0x10], a4);
        unsigned int v13 = v14++;
        v12 += 16;
      }
      int v10 = (__n128 *)((char *)v10 + v12);
      unint64_t v17 = v10 - 1;
      if (a3 == v12)
      {
        --v10;
LABEL_16:
        __n128 result = *v10;
        *a5 = *v10;
        return result;
      }
      a1 += v12;
    }
    uint64_t v18 = 0;
    do
    {
      v10->n128_u8[v18] = v17->n128_u8[v18] ^ *(unsigned char *)(a1 + v18);
      ++v18;
    }
    while (i != v18);
    if ((unint64_t)(v18 - 1) <= 0xE)
    {
      uint64_t v19 = 15 - 2 * i + v18 + 1;
      unint64_t v20 = (char *)v10 + i;
      unsigned int v21 = (char *)v17 + i;
      do
      {
        char v22 = *v21++;
        *v20++ = v22;
        --v19;
      }
      while (v19);
    }
    a6(v10, v10, a4);
    goto LABEL_16;
  }
  return result;
}

unint64_t sub_244D155C4(unint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void *, void *, uint64_t))
{
  void v28[3] = *MEMORY[0x263EF8340];
  if (!a3) {
    return result;
  }
  unint64_t v9 = a3;
  int v10 = (void *)a2;
  uint64_t v11 = (void *)result;
  BOOL v13 = result > 0x1F && result - 32 >= a2;
  if (result < a2 || v13)
  {
    if (a3 < 0x10)
    {
      unint64_t v20 = (_OWORD *)a5;
    }
    else
    {
      unint64_t v17 = (void *)a5;
      do
      {
        uint64_t v18 = v11;
        __n128 result = a6(v11, v10, a4);
        uint64_t v19 = v10[1];
        *v10 ^= *v17;
        v9 -= 16;
        v10[1] = v17[1] ^ v19;
        v11 += 2;
        v10 += 2;
        unint64_t v17 = v18;
      }
      while (v9 > 0xF);
      unint64_t v20 = v11 - 2;
    }
    *(_OWORD *)a5 = *v20;
    if (!v9) {
      return result;
    }
  }
  else if (a3 >= 0x10)
  {
    do
    {
      __n128 result = a6(v11, v28, a4);
      uint64_t v14 = v28[1];
      uint64_t v15 = *v11;
      *int v10 = *(void *)a5 ^ v28[0];
      *(void *)a5 = v15;
      uint64_t v16 = v11[1];
      v10[1] = *(void *)(a5 + 8) ^ v14;
      *(void *)(a5 + 8) = v16;
      v9 -= 16;
      v11 += 2;
      v10 += 2;
    }
    while (v9 > 0xF);
    if (!v9) {
      return result;
    }
  }
  __n128 result = a6(v11, v28, a4);
  uint64_t v21 = 0;
  uint64_t v22 = 15;
  if (v9 > 0xF) {
    uint64_t v22 = v9;
  }
  do
  {
    char v23 = *((unsigned char *)v11 + v21);
    *((unsigned char *)v10 + v21) = *(unsigned char *)(a5 + v21) ^ *((unsigned char *)v28 + v21);
    *(unsigned char *)(a5 + v21++) = v23;
  }
  while (v9 != v21);
  if ((unint64_t)(v21 - 1) <= 0xE)
  {
    uint64_t v24 = v22 - 2 * v9 + v21 + 1;
    uint64_t v25 = (unsigned char *)(a5 + v9);
    unsigned int v26 = (char *)v11 + v9;
    do
    {
      char v27 = *v26++;
      *v25++ = v27;
      --v24;
    }
    while (v24);
  }
  return result;
}

uint64_t sub_244D157AC(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, void *a5, unsigned int *a6)
{
  unsigned int v8 = *a6;
  uint64_t result = sub_244D157FC(a1, a2, a3, a4, a5, &v8, (uint64_t (*)(void *, void *, uint64_t))sub_244D13960);
  *a6 = v8;
  return result;
}

uint64_t sub_244D157FC(uint64_t result, void *a2, unint64_t a3, uint64_t a4, void *a5, unsigned int *a6, uint64_t (*a7)(void *, void *, uint64_t))
{
  unint64_t v12 = (char *)result;
  unsigned int v13 = *a6;
  if (*a6) {
    BOOL v14 = a3 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    unint64_t v15 = a3;
  }
  else
  {
    do
    {
      char v16 = *v12++;
      *(unsigned char *)a2 = *((unsigned char *)a5 + v13) ^ v16;
      a2 = (void *)((char *)a2 + 1);
      unint64_t v15 = a3 - 1;
      unsigned int v13 = (v13 + 1) & 0xF;
      if (!v13) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  if (v15 >= 0x10)
  {
    do
    {
      uint64_t result = a7(a5, a5, a4);
      *a2 = *a5 ^ *(void *)v12;
      a2[1] = a5[1] ^ *((void *)v12 + 1);
      v15 -= 16;
      a2 += 2;
      v12 += 16;
    }
    while (v15 > 0xF);
    unsigned int v13 = 0;
  }
  if (v15)
  {
    uint64_t result = a7(a5, a5, a4);
    do
    {
      *((unsigned char *)a2 + v13) = *((unsigned char *)a5 + v13) ^ v12[v13];
      ++v13;
      --v15;
    }
    while (v15);
  }
  *a6 = v13;
  return result;
}

uint64_t sub_244D15910(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, int a7)
{
  unsigned int v9 = *a6;
  uint64_t result = sub_244D15960(a1, a2, a3, a4, a5, &v9, a7, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_244D13960);
  *a6 = v9;
  return result;
}

uint64_t sub_244D15960(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, int a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t))
{
  unsigned int v13 = (char *)result;
  unsigned int v14 = *a6;
  if (*a6) {
    BOOL v15 = a3 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  int v16 = !v15;
  if (a7)
  {
    if (v16)
    {
      do
      {
        char v17 = *v13++;
        char v18 = *(unsigned char *)(a5 + v14);
        *(unsigned char *)(a5 + v14) = v18 ^ v17;
        *a2++ = v18 ^ v17;
        unint64_t v19 = a3 - 1;
        unsigned int v14 = ((_BYTE)v14 + 1) & 0xF;
        if (!v14) {
          break;
        }
        --a3;
      }
      while (a3);
    }
    else
    {
      unint64_t v19 = a3;
    }
    if (v19 < 0x10)
    {
      unsigned int v25 = v14;
      if (!v19) {
        goto LABEL_41;
      }
    }
    else
    {
      do
      {
        uint64_t result = a8(a5, a5, a4);
        if (v14 <= 0xF)
        {
          unint64_t v22 = v14;
          do
          {
            uint64_t v23 = *(void *)&v13[v22] ^ *(void *)(a5 + v22);
            *(void *)(a5 + v22) = v23;
            *(void *)&a2[v22] = v23;
            BOOL v24 = v22 >= 8;
            v22 += 8;
          }
          while (!v24);
        }
        unsigned int v14 = 0;
        unsigned int v25 = 0;
        v19 -= 16;
        a2 += 16;
        v13 += 16;
      }
      while (v19 > 0xF);
      if (!v19) {
        goto LABEL_41;
      }
    }
    uint64_t result = a8(a5, a5, a4);
    do
    {
      char v26 = *(unsigned char *)(a5 + v25) ^ v13[v25];
      *(unsigned char *)(a5 + v25) = v26;
      a2[v25++] = v26;
      --v19;
    }
    while (v19);
    goto LABEL_41;
  }
  if (v16)
  {
    do
    {
      char v20 = *v13++;
      *a2++ = v20 ^ *(unsigned char *)(a5 + v14);
      *(unsigned char *)(a5 + v14) = v20;
      unint64_t v21 = a3 - 1;
      unsigned int v14 = ((_BYTE)v14 + 1) & 0xF;
      if (!v14) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  else
  {
    unint64_t v21 = a3;
  }
  if (v21 < 0x10)
  {
    unsigned int v25 = v14;
    if (!v21) {
      goto LABEL_41;
    }
    goto LABEL_39;
  }
  do
  {
    uint64_t result = a8(a5, a5, a4);
    if (v14 <= 0xF)
    {
      unint64_t v27 = v14;
      do
      {
        uint64_t v28 = *(void *)&v13[v27];
        *(void *)&a2[v27] = *(void *)(a5 + v27) ^ v28;
        *(void *)(a5 + v27) = v28;
        BOOL v24 = v27 >= 8;
        v27 += 8;
      }
      while (!v24);
    }
    unsigned int v14 = 0;
    unsigned int v25 = 0;
    v21 -= 16;
    a2 += 16;
    v13 += 16;
  }
  while (v21 > 0xF);
  if (v21)
  {
LABEL_39:
    uint64_t result = a8(a5, a5, a4);
    do
    {
      char v29 = v13[v25];
      a2[v25] = v29 ^ *(unsigned char *)(a5 + v25);
      *(unsigned char *)(a5 + v25++) = v29;
      --v21;
    }
    while (v21);
  }
LABEL_41:
  *a6 = v25;
  return result;
}

uint64_t sub_244D15B90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v4) = *(_DWORD *)(a2 + 16);
  if (v4 == *(_DWORD *)(a3 + 16))
  {
    uint64_t v5 = sub_244D15CD0(a1, a2, a3);
  }
  else
  {
    BOOL v6 = v4 == 0;
    if (v4) {
      uint64_t v7 = a3;
    }
    else {
      uint64_t v7 = a2;
    }
    if (v6) {
      uint64_t v8 = a3;
    }
    else {
      uint64_t v8 = a2;
    }
    if ((sub_244D170B4(*(uint64_t **)v7, *(int *)(v7 + 8), *(uint64_t **)v8, *(int *)(v8 + 8)) & 0x80000000) != 0)
    {
      if (!sub_244D15C60(a1, v8, v7)) {
        return 0;
      }
      LODWORD(v4) = 1;
    }
    else
    {
      int v9 = sub_244D15C60(a1, v7, v8);
      uint64_t v4 = 0;
      if (!v9) {
        return v4;
      }
    }
    uint64_t v5 = 1;
  }
  *(_DWORD *)(a1 + 16) = v4;
  return v5;
}

uint64_t sub_244D15C44(uint64_t a1, uint64_t a2)
{
  return sub_244D170B4(*(uint64_t **)a1, *(int *)(a1 + 8), *(uint64_t **)a2, *(int *)(a2 + 8));
}

uint64_t sub_244D15C60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_244D163DC(a1, a2, a3);
  if (result)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    uint64_t v6 = 8 * v5 - 8;
    int v7 = *(_DWORD *)(a1 + 8);
    while (1)
    {
      BOOL v8 = __OFSUB__(v7--, 1);
      if (v7 < 0 != v8) {
        break;
      }
      uint64_t v9 = *(void *)(*(void *)a1 + v6);
      v6 -= 8;
      if (v9)
      {
        *(_DWORD *)(a1 + 8) = v7 + 1;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 8) = v5 & ((int)v5 >> 31);
    if ((v5 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 16) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D15CD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_244D15D40((void **)a1, a2, a3);
  if (result)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    uint64_t v6 = 8 * v5 - 8;
    int v7 = *(_DWORD *)(a1 + 8);
    while (1)
    {
      BOOL v8 = __OFSUB__(v7--, 1);
      if (v7 < 0 != v8) {
        break;
      }
      uint64_t v9 = *(void *)(*(void *)a1 + v6);
      v6 -= 8;
      if (v9)
      {
        *(_DWORD *)(a1 + 8) = v7 + 1;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 8) = v5 & ((int)v5 >> 31);
    if ((v5 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 16) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D15D40(void **a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a2 + 8);
  int v5 = *(_DWORD *)(a3 + 8);
  if (v4 >= v5) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = a3;
  }
  if (v4 >= v5) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = a2;
  }
  uint64_t v8 = *(int *)(v6 + 8);
  unint64_t v9 = *(int *)(v7 + 8);
  uint64_t result = sub_244D15DEC(a1, v8 + 1);
  if (result)
  {
    *((_DWORD *)a1 + 2) = v8 + 1;
    uint64_t v11 = sub_244D15EB4(*a1, *(uint64_t **)v6, *(uint64_t **)v7, v9);
    if ((int)v9 < (int)v8)
    {
      do
      {
        uint64_t v12 = *(void *)(*(void *)v6 + 8 * v9);
        BOOL v13 = __CFADD__(v12, v11);
        uint64_t v14 = v12 + v11;
        uint64_t v11 = v13;
        (*a1)[v9++] = v14;
      }
      while (v8 != v9);
    }
    (*a1)[v8] = v11;
    return 1;
  }
  return result;
}

uint64_t sub_244D15DEC(void **a1, unint64_t a2)
{
  if (*((int *)a1 + 3) >= a2) {
    return 1;
  }
  int v2 = a2;
  if (a2 < 0x800000)
  {
    if ((*((unsigned char *)a1 + 20) & 2) != 0)
    {
      int v3 = 106;
      __int16 v4 = 360;
      goto LABEL_11;
    }
    uint64_t result = (uint64_t)sub_244D44098(a2, 8uLL);
    if (!result) {
      return result;
    }
    uint64_t v7 = (void *)result;
    uint64_t v8 = *((int *)a1 + 2);
    if (v8) {
      memcpy((void *)result, *a1, 8 * v8);
    }
    sub_244D440EC(*a1);
    *a1 = v7;
    *((_DWORD *)a1 + 3) = v2;
    return 1;
  }
  int v3 = 102;
  __int16 v4 = 355;
LABEL_11:
  sub_244D0B884(3, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/bn.c", v4);
  return 0;
}

uint64_t sub_244D15EB4(void *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (!a4) {
    return 0;
  }
  if (a4 < 4)
  {
    uint64_t v4 = 0;
    do
    {
LABEL_17:
      uint64_t v23 = *a2++;
      uint64_t v22 = v23;
      uint64_t v24 = *a3++;
      BOOL v7 = __CFADD__(v22, v24);
      uint64_t v25 = v22 + v24;
      unsigned int v26 = v7;
      BOOL v7 = __CFADD__(v25, v4);
      uint64_t v27 = v25 + v4;
      if (v7) {
        uint64_t v4 = 1;
      }
      else {
        uint64_t v4 = v26;
      }
      *a1++ = v27;
      --a4;
    }
    while (a4);
    return v4;
  }
  uint64_t v4 = 0;
  do
  {
    uint64_t v5 = *a2 + *a3;
    BOOL v6 = __CFADD__(*a2, *a3);
    BOOL v7 = __CFADD__(v5, v4);
    uint64_t v8 = v5 + v4;
    int v9 = v7 || v6;
    BOOL v7 = v9 != 0;
    *a1 = v8;
    uint64_t v10 = a2[1];
    uint64_t v11 = a3[1];
    BOOL v13 = v7;
    BOOL v7 = __CFADD__(v7, v10);
    uint64_t v12 = v13 + v10;
    v7 |= __CFADD__(v11, v12);
    a1[1] = v11 + v12;
    uint64_t v14 = a2[2];
    uint64_t v15 = a3[2];
    BOOL v17 = v7;
    BOOL v7 = __CFADD__(v7, v14);
    uint64_t v16 = v17 + v14;
    v7 |= __CFADD__(v15, v16);
    a1[2] = v15 + v16;
    uint64_t v18 = a2[3];
    uint64_t v19 = a3[3];
    uint64_t v21 = v7 + v18;
    BOOL v7 = __CFADD__(v7, v18) | __CFADD__(v19, v21);
    uint64_t v20 = v19 + v21;
    uint64_t v4 = v7;
    a1[3] = v20;
    a2 += 4;
    a3 += 4;
    a1 += 4;
    a4 -= 4;
  }
  while (a4 >= 4);
  if (a4) {
    goto LABEL_17;
  }
  return v4;
}

uint64_t sub_244D15F70(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 8);
  uint64_t v2 = 8 * v1 - 8;
  int v3 = *(_DWORD *)(result + 8);
  while (1)
  {
    BOOL v4 = __OFSUB__(v3--, 1);
    if (v3 < 0 != v4) {
      break;
    }
    uint64_t v5 = *(void *)(*(void *)result + v2);
    v2 -= 8;
    if (v5)
    {
      *(_DWORD *)(result + 8) = v3 + 1;
      return result;
    }
  }
  *(_DWORD *)(result + 8) = v1 & ((int)v1 >> 31);
  if ((v1 & 0x80000000) == 0) {
    *(_DWORD *)(result + 16) = 0;
  }
  return result;
}

uint64_t sub_244D15FB8(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 1;
  }
  uint64_t v2 = a2;
  uint64_t v4 = *(int *)(a1 + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = 0;
  BOOL v6 = *(uint64_t **)a1;
  do
  {
    uint64_t v7 = *v6++;
    v5 |= v7;
    --v4;
  }
  while (v4);
  if (!v5)
  {
LABEL_12:
    uint64_t v8 = 1;
    if (sub_244D15DEC((void **)a1, 1uLL))
    {
      *(_DWORD *)(a1 + 16) = 0;
      **(void **)a1 = v2;
      *(_DWORD *)(a1 + 8) = 1;
      return v8;
    }
    return 0;
  }
  if (!*(_DWORD *)(a1 + 16))
  {
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = *(int *)(a1 + 8);
      if (v13 >= v14) {
        break;
      }
      uint64_t v15 = *(void *)(*(void *)a1 + 8 * v13);
      BOOL v16 = __CFADD__(v15, v2);
      *(void *)(*(void *)a1 + 8 * v13++) = v15 + v2;
      uint64_t v2 = 1;
      if (!v16) {
        return 1;
      }
    }
    if (v13 != v14) {
      return 1;
    }
    if (sub_244D15DEC((void **)a1, v14 + 1))
    {
      ++*(_DWORD *)(a1 + 8);
      *(void *)(*(void *)a1 + 8 * v14) = v2;
      return 1;
    }
    return 0;
  }
  *(_DWORD *)(a1 + 16) = 0;
  uint64_t v8 = sub_244D1618C(a1, a2);
  uint64_t v9 = *(int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *(uint64_t **)a1;
    do
    {
      uint64_t v12 = *v11++;
      v10 |= v12;
      --v9;
    }
    while (v9);
    if (v10) {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 16) == 0;
    }
  }
  return v8;
}

BOOL sub_244D160FC(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 8);
  if (!v1) {
    return 1;
  }
  uint64_t v2 = 0;
  int v3 = *(uint64_t **)a1;
  do
  {
    uint64_t v4 = *v3++;
    v2 |= v4;
    --v1;
  }
  while (v1);
  return v2 == 0;
}

uint64_t sub_244D16130(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t result = sub_244D15DEC((void **)a1, 1uLL);
    if (!result) {
      return result;
    }
    *(_DWORD *)(a1 + 16) = 0;
    **(void **)a1 = a2;
    int v5 = 1;
  }
  else
  {
    int v5 = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v5;
  return 1;
}

uint64_t sub_244D1618C(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v4 = *(unsigned int *)(a1 + 8);
    if (!v4) {
      goto LABEL_8;
    }
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = *(unint64_t **)a1;
    do
      v6 |= v7[v5++];
    while ((int)v4 != v5);
    if (!v6)
    {
LABEL_8:
      uint64_t v9 = 1;
      if (!sub_244D15DEC((void **)a1, 1uLL)) {
        return 0;
      }
      *(_DWORD *)(a1 + 16) = 0;
      **(void **)a1 = v2;
      *(_DWORD *)(a1 + 8) = 1;
      *(_DWORD *)(a1 + 16) = **(void **)a1 != 0;
      return v9;
    }
    if (*(_DWORD *)(a1 + 16))
    {
      *(_DWORD *)(a1 + 16) = 0;
      uint64_t result = sub_244D15FB8(a1, a2);
      *(_DWORD *)(a1 + 16) = 1;
      return result;
    }
    uint64_t v10 = 8 * v4 - 8;
    do
    {
      BOOL v11 = __OFSUB__(v4, 1);
      LODWORD(v4) = v4 - 1;
      if ((int)v4 < 0 != v11)
      {
        unint64_t v13 = *v7;
        goto LABEL_18;
      }
      uint64_t v12 = *(unint64_t *)((char *)v7 + v10);
      v10 -= 8;
    }
    while (!v12);
    unint64_t v13 = *v7;
    if (!v4 && a2 > v13)
    {
      *uint64_t v7 = a2 - v13;
      uint64_t v9 = 1;
      *(_DWORD *)(a1 + 16) = 1;
      return v9;
    }
LABEL_18:
    uint64_t v14 = v13 - a2;
    if (v13 >= a2)
    {
      int v17 = 0;
      uint64_t v15 = 0;
    }
    else
    {
      uint64_t v15 = 0;
      uint64_t v16 = 8;
      do
      {
        *uint64_t v7 = v14;
        ++v15;
        uint64_t v7 = (unint64_t *)(*(void *)a1 + v16);
        unint64_t v13 = *v7;
        v16 += 8;
        uint64_t v14 = -1;
      }
      while (!*v7);
      uint64_t v7 = (unint64_t *)(*(void *)a1 + v16 - 8);
      uint64_t v2 = 1;
      int v17 = v15;
    }
    *uint64_t v7 = v13 - v2;
    if (!*(void *)(*(void *)a1 + 8 * v15) && v17 == *(_DWORD *)(a1 + 8) - 1) {
      *(_DWORD *)(a1 + 8) = v17;
    }
  }
  return 1;
}

uint64_t sub_244D16310(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  int v5 = *(_DWORD *)(a3 + 16);
  if (*(_DWORD *)(a2 + 16))
  {
    if (v5)
    {
      uint64_t v6 = a2;
      goto LABEL_10;
    }
    int v7 = 1;
LABEL_7:
    uint64_t result = sub_244D15CD0(a1, a2, a3);
    if (!result) {
      return result;
    }
    goto LABEL_15;
  }
  if (v5)
  {
    int v7 = 0;
    goto LABEL_7;
  }
  uint64_t v6 = a3;
  uint64_t v3 = a2;
LABEL_10:
  if ((sub_244D170B4(*(uint64_t **)v3, *(int *)(v3 + 8), *(uint64_t **)v6, *(int *)(v6 + 8)) & 0x80000000) != 0)
  {
    uint64_t result = sub_244D15C60(a1, v6, v3);
    if (!result) {
      return result;
    }
    int v7 = 1;
    goto LABEL_15;
  }
  int v9 = sub_244D15C60(a1, v3, v6);
  int v7 = 0;
  uint64_t result = 0;
  if (v9)
  {
LABEL_15:
    *(_DWORD *)(a1 + 16) = v7;
    return 1;
  }
  return result;
}

uint64_t sub_244D163DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 8);
  int v7 = *(_DWORD *)(a2 + 8);
  int v8 = v6;
  if (v6 > v7)
  {
    if (v6 > v7)
    {
      uint64_t v9 = 0;
      uint64_t v10 = v6 - (uint64_t)v7;
      BOOL v11 = (uint64_t *)(*(void *)a3 + 8 * v7);
      do
      {
        uint64_t v12 = *v11++;
        v9 |= v12;
        --v10;
      }
      while (v10);
      int v8 = *(_DWORD *)(a2 + 8);
      if (v9)
      {
        __int16 v13 = 229;
LABEL_16:
        sub_244D0B884(3, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/add.c", v13);
        return 0;
      }
    }
    else
    {
      int v8 = *(_DWORD *)(a2 + 8);
    }
  }
  uint64_t result = sub_244D15DEC((void **)a1, v7);
  if (!result) {
    return result;
  }
  uint64_t v15 = v8;
  unint64_t v16 = sub_244D16544(*(unint64_t **)a1, *(unint64_t **)a2, *(unint64_t **)a3, v8);
  LODWORD(v17) = *(_DWORD *)(a2 + 8);
  if (v8 < (int)v17)
  {
    do
    {
      unint64_t v18 = *(void *)(*(void *)a2 + 8 * v15);
      BOOL v19 = v18 >= v16;
      unint64_t v20 = v18 - v16;
      unint64_t v16 = !v19;
      *(void *)(*(void *)a1 + 8 * v15++) = v20;
      uint64_t v17 = *(int *)(a2 + 8);
    }
    while (v15 < v17);
  }
  if (v16)
  {
    __int16 v13 = 245;
    goto LABEL_16;
  }
  *(_DWORD *)(a1 + 8) = v17;
  *(_DWORD *)(a1 + 16) = 0;
  return 1;
}

BOOL sub_244D16508(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(int *)(a1 + 8);
  BOOL v3 = v2 > a2;
  unint64_t v4 = v2 - a2;
  if (!v3) {
    return 1;
  }
  uint64_t v5 = 0;
  int v6 = (uint64_t *)(*(void *)a1 + 8 * a2);
  do
  {
    uint64_t v7 = *v6++;
    v5 |= v7;
    --v4;
  }
  while (v4);
  return v5 == 0;
}

unint64_t sub_244D16544(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  if (!a4) {
    return 0;
  }
  if (a4 < 4)
  {
    unint64_t v4 = 0;
    do
    {
LABEL_14:
      unint64_t v20 = *a2++;
      unint64_t v19 = v20;
      unint64_t v21 = *a3++;
      _BOOL1 v6 = v19 >= v21;
      unint64_t v22 = v19 - v21;
      unsigned int v23 = !v6;
      _BOOL1 v6 = v22 >= v4;
      unint64_t v24 = v22 - v4;
      if (v6) {
        unint64_t v4 = v23;
      }
      else {
        unint64_t v4 = 1;
      }
      *a1++ = v24;
      --a4;
    }
    while (a4);
    return v4;
  }
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = *a2 - *a3;
    _BOOL1 v6 = v5 >= v4;
    unint64_t v7 = v5 - v4;
    BOOL v8 = !v6 || *a2 < *a3;
    _BOOL1 v6 = !v8;
    *a1 = v7;
    unint64_t v9 = a2[1];
    unint64_t v10 = a3[1];
    _BOOL1 v11 = v6;
    _BOOL1 v6 = __CFSUB__(v9, v10, v6);
    a1[1] = v9 - (v10 + !v11);
    unint64_t v12 = a2[2];
    unint64_t v13 = a3[2];
    _BOOL1 v14 = v6;
    _BOOL1 v6 = __CFSUB__(v12, v13, v6);
    a1[2] = v12 - (v13 + !v14);
    unint64_t v15 = a2[3];
    unint64_t v16 = a3[3];
    _BOOL1 v18 = v6;
    _BOOL1 v6 = __CFSUB__(v15, v16, v6);
    unint64_t v17 = v15 - (v16 + !v18);
    unint64_t v4 = !v6;
    a1[3] = v17;
    a2 += 4;
    a3 += 4;
    a1 += 4;
    a4 -= 4;
  }
  while (a4 >= 4);
  if (a4) {
    goto LABEL_14;
  }
  return v4;
}

uint64_t sub_244D16600(uint64_t result, int a2)
{
  if (!a2) {
    goto LABEL_7;
  }
  uint64_t v2 = *(int *)(result + 8);
  if (!v2) {
    goto LABEL_7;
  }
  uint64_t v3 = 0;
  unint64_t v4 = *(uint64_t **)result;
  do
  {
    uint64_t v5 = *v4++;
    v3 |= v5;
    --v2;
  }
  while (v2);
  if (v3) {
    int v6 = 1;
  }
  else {
LABEL_7:
  }
    int v6 = 0;
  *(_DWORD *)(result + 16) = v6;
  return result;
}

uint64_t sub_244D1663C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  uint64_t result = v2 & ((int)v2 >> 31);
  for (uint64_t i = 8 * v2 - 8; ; i -= 8)
  {
    BOOL v5 = __OFSUB__(v2, 1);
    LODWORD(v2) = v2 - 1;
    if ((int)v2 < 0 != v5) {
      break;
    }
    if (*(void *)(*(void *)a1 + i)) {
      return (v2 + 1);
    }
  }
  return result;
}

void *sub_244D16670()
{
  uint64_t result = sub_244D43FF4(0x18uLL);
  if (result)
  {
    result[1] = 0;
    result[2] = 0;
    *uint64_t result = 0;
    *((_DWORD *)result + 5) = 1;
  }
  return result;
}

void *sub_244D166A4(void *result)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void sub_244D166B0(void **a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 5);
    if ((v2 & 2) == 0)
    {
      sub_244D440EC(*a1);
      int v2 = *((_DWORD *)a1 + 5);
    }
    if (v2)
    {
      sub_244D440EC(a1);
    }
    else
    {
      *a1 = 0;
    }
  }
}

void **sub_244D16714(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = (void **)sub_244D16670();
  uint64_t v3 = v2;
  if (v2 && !sub_244D16764(v2, a1))
  {
    sub_244D166B0((void **)v3);
    return 0;
  }
  return v3;
}

void **sub_244D16764(void **a1, uint64_t a2)
{
  if ((void **)a2 == a1) {
    return (void **)a2;
  }
  uint64_t v3 = a1;
  if (!sub_244D15DEC((void **)a1, *(int *)(a2 + 8))) {
    return 0;
  }
  uint64_t v4 = *(int *)(a2 + 8);
  if (v4)
  {
    memcpy(*v3, *(const void **)a2, 8 * v4);
    LODWORD(v4) = *(_DWORD *)(a2 + 8);
  }
  *((_DWORD *)v3 + 2) = v4;
  *((_DWORD *)v3 + 4) = *(_DWORD *)(a2 + 16);
  return v3;
}

void sub_244D167D8(uint64_t a1)
{
  int v2 = *(void **)a1;
  if (v2)
  {
    uint64_t v3 = *(int *)(a1 + 12);
    if (v3) {
      bzero(v2, 8 * v3);
    }
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
}

uint64_t *sub_244D16818()
{
  return &qword_268EBEE70;
}

double sub_244D16850()
{
  qword_268EBEE70 = (uint64_t)&unk_244EB74D8;
  *(void *)&double result = 0x100000001;
  unk_268EBEE78 = xmmword_244EB6D40;
  return result;
}

uint64_t sub_244D16874(unint64_t a1)
{
  unint64_t v1 = HIDWORD(a1);
  if (!HIDWORD(a1)) {
    unint64_t v1 = a1;
  }
  int v2 = (a1 != 0) | (32 * (HIDWORD(a1) != 0)) | (16 * (v1 >> 16 != 0));
  if (v1 >> 16) {
    v1 >>= 16;
  }
  int v3 = v2 | (8 * (v1 > 0xFF));
  if (v1 > 0xFF) {
    v1 >>= 8;
  }
  int v4 = v3 | (4 * (v1 > 0xF));
  if (v1 > 0xF) {
    v1 >>= 4;
  }
  unsigned int v5 = v4 | (2 * (v1 > 3));
  if (v1 > 3) {
    v1 >>= 2;
  }
  if (v1 <= 1) {
    return v5;
  }
  else {
    return v5 + 1;
  }
}

uint64_t sub_244D168EC(uint64_t *a1)
{
  uint64_t v1 = *((unsigned int *)a1 + 2);
  int v2 = v1 & ((int)v1 >> 31);
  uint64_t v3 = 8 * v1 - 8;
  int v4 = *((_DWORD *)a1 + 2);
  while (1)
  {
    BOOL v5 = __OFSUB__(v4--, 1);
    if (v4 < 0 != v5) {
      break;
    }
    uint64_t v6 = *a1;
    uint64_t v7 = *(void *)(*a1 + v3);
    v3 -= 8;
    if (v7)
    {
      int v2 = v4 + 1;
      return sub_244D16874(*(void *)(v6 + 8 * (v2 - 1))) + ((v2 - 1) << 6);
    }
  }
  if ((v1 & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v6 = *a1;
  return sub_244D16874(*(void *)(v6 + 8 * (v2 - 1))) + ((v2 - 1) << 6);
}

uint64_t sub_244D1695C(uint64_t *a1)
{
  return (sub_244D168EC(a1) + 7) >> 3;
}

uint64_t sub_244D1697C(uint64_t result)
{
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

uint64_t sub_244D16988(uint64_t a1)
{
  uint64_t v2 = 1;
  if (!sub_244D15DEC((void **)a1, 1uLL)) {
    return 0;
  }
  *(_DWORD *)(a1 + 16) = 0;
  **(void **)a1 = 1;
  *(_DWORD *)(a1 + 8) = 1;
  return v2;
}

uint64_t sub_244D169D4(uint64_t a1, const void *a2, unint64_t a3)
{
  uint64_t result = sub_244D15DEC((void **)a1, a3);
  if (result)
  {
    if (8 * a3) {
      memmove(*(void **)a1, a2, 8 * a3);
    }
    *(_DWORD *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 16) = 0;
    return 1;
  }
  return result;
}

void sub_244D16A30(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = *(_DWORD *)(a1 + 20);
  if ((v6 & 2) == 0)
  {
    sub_244D440EC(*(void **)a1);
    int v6 = *(_DWORD *)(a1 + 20);
  }
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = v6 | 2;
}

uint64_t sub_244D16A84(void *__dst, unint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 16))
  {
    int v3 = 109;
    __int16 v4 = 317;
LABEL_3:
    sub_244D0B884(3, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/bn.c", v4);
    return 0;
  }
  unint64_t v8 = *(int *)(a3 + 8);
  unint64_t v9 = v8 - a2;
  if (v8 > a2)
  {
    uint64_t v10 = 0;
    _BOOL1 v11 = (uint64_t *)(*(void *)a3 + 8 * a2);
    do
    {
      uint64_t v12 = *v11++;
      v10 |= v12;
      --v9;
    }
    while (v9);
    unint64_t v8 = a2;
    if (v10)
    {
      int v3 = 102;
      __int16 v4 = 324;
      goto LABEL_3;
    }
  }
  size_t v13 = 8 * a2;
  if (v13) {
    bzero(__dst, v13);
  }
  if (8 * v8) {
    memcpy(__dst, *(const void **)a3, 8 * v8);
  }
  return 1;
}

BOOL sub_244D16B50(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) != 0;
}

uint64_t sub_244D16B60(void **a1, unint64_t a2)
{
  if (a2 < 0xFFFFFFFFFFFFFFC1)
  {
    unint64_t v4 = (a2 + 63) >> 6;
    return sub_244D15DEC(a1, v4);
  }
  else
  {
    sub_244D0B884(3, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/bn.c", 380);
    return 0;
  }
}

uint64_t sub_244D16BB4(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(int *)(a1 + 8);
  BOOL v5 = v4 > a2;
  unint64_t v6 = v4 - a2;
  if (v5)
  {
    uint64_t v7 = 0;
    unint64_t v8 = (uint64_t *)(*(void *)a1 + 8 * a2);
    do
    {
      uint64_t v9 = *v8++;
      v7 |= v9;
      --v6;
    }
    while (v6);
    if (v7)
    {
      sub_244D0B884(3, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/bn.c", 399);
      return 0;
    }
    goto LABEL_10;
  }
  uint64_t result = sub_244D15DEC((void **)a1, a2);
  if (result)
  {
    uint64_t v11 = *(int *)(a1 + 8);
    size_t v12 = 8 * (a2 - v11);
    if (v12) {
      bzero((void *)(*(void *)a1 + 8 * v11), v12);
    }
LABEL_10:
    *(_DWORD *)(a1 + 8) = a2;
    return 1;
  }
  return result;
}

uint64_t *sub_244D16C5C(uint64_t *result, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  for (; a5; --a5)
  {
    uint64_t v6 = *a3++;
    uint64_t v5 = v6;
    uint64_t v7 = *a4++;
    *result++ = a2 & v5 | v7 & ~a2;
  }
  return result;
}

void sub_244D16C88(unint64_t *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  if (a4 > 8 * a2) {
    abort();
  }
  if (a4 < 8)
  {
    unint64_t v4 = a4;
    if (!a4) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  do
  {
    unint64_t v4 = a4 - 8;
    *a1++ = bswap64(*(void *)&a3[a4 - 8]);
    --a2;
    a4 = v4;
  }
  while (v4 > 7);
  if (v4)
  {
LABEL_7:
    unint64_t v5 = 0;
    do
    {
      unsigned int v6 = *a3++;
      unint64_t v5 = v6 | (v5 << 8);
      --v4;
    }
    while (v4);
    *a1++ = v5;
    --a2;
  }
LABEL_10:
  size_t v7 = 8 * a2;
  if (v7)
  {
    bzero(a1, v7);
  }
}

void *sub_244D16D20(unsigned __int8 *a1, unint64_t a2, void *a3)
{
  if (a3)
  {
    unint64_t v5 = a3;
    unsigned int v6 = 0;
  }
  else
  {
    unint64_t v5 = sub_244D16670();
    unsigned int v6 = (void **)v5;
    if (!v5) {
      return v5;
    }
  }
  if (a2)
  {
    unint64_t v7 = ((a2 - 1) >> 3) + 1;
    if (sub_244D15DEC((void **)v5, v7))
    {
      *((_DWORD *)v5 + 2) = v7;
      *((_DWORD *)v5 + 4) = 0;
      sub_244D16C88((unint64_t *)*v5, (int)v7, a1, a2);
    }
    else
    {
      sub_244D166B0(v6);
      return 0;
    }
  }
  else
  {
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void *sub_244D16DCC(const void *a1, size_t a2, void *a3)
{
  if (a3)
  {
    unint64_t v5 = a3;
    unsigned int v6 = 0;
  }
  else
  {
    unint64_t v5 = sub_244D16670();
    unsigned int v6 = (void **)v5;
    if (!v5) {
      return v5;
    }
  }
  if (a2)
  {
    unint64_t v7 = (a2 - 1) >> 3;
    if (sub_244D15DEC((void **)v5, v7 + 1))
    {
      *((_DWORD *)v5 + 2) = v7 + 1;
      *(void *)(*v5 + 8 * v7) = 0;
      memcpy((void *)*v5, a1, a2);
    }
    else
    {
      sub_244D166B0(v6);
      return 0;
    }
  }
  else
  {
    *((_DWORD *)v5 + 2) = 0;
    *((_DWORD *)v5 + 4) = 0;
  }
  return v5;
}

void sub_244D16E80(char *a1, unint64_t a2, char *a3, uint64_t a4)
{
  if (8 * a4 >= a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = 8 * a4;
  }
  if (v4)
  {
    unint64_t v5 = &a1[a2 - 1];
    uint64_t v6 = v4;
    do
    {
      char v7 = *a3++;
      *v5-- = v7;
      --v6;
    }
    while (v6);
  }
  if (8 * a4 < a2) {
    bzero(a1, a2 - v4);
  }
}

unint64_t sub_244D16EC0(uint64_t a1, char *a2)
{
  unint64_t v4 = (sub_244D168EC((uint64_t *)a1) + 7) >> 3;
  sub_244D16E80(a2, v4, *(char **)a1, *(int *)(a1 + 8));
  return v4;
}

uint64_t sub_244D16F10(char *__dst, size_t a2, char **a3)
{
  unint64_t v5 = *a3;
  unint64_t v6 = 8 * *((int *)a3 + 2);
  if (a2 < v6)
  {
    int v7 = 0;
    size_t v8 = a2 - v6;
    uint64_t v9 = &v5[a2];
    do
    {
      int v10 = *v9++;
      v7 |= v10;
    }
    while (!__CFADD__(v8++, 1));
    if (v7) {
      return 0;
    }
  }
  if (v6 >= a2) {
    size_t v13 = a2;
  }
  else {
    size_t v13 = 8 * *((int *)a3 + 2);
  }
  if (v13) {
    memcpy(__dst, v5, v13);
  }
  if (v6 < a2) {
    bzero(&__dst[v13], a2 - v13);
  }
  return 1;
}

uint64_t sub_244D16FA8(char *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(char **)a3;
  uint64_t v5 = *(int *)(a3 + 8);
  if (a2 < 8 * v5)
  {
    int v6 = 0;
    unint64_t v7 = a2 - 8 * v5;
    size_t v8 = &v4[a2];
    do
    {
      int v9 = *v8++;
      v6 |= v9;
    }
    while (!__CFADD__(v7++, 1));
    if (v6) {
      return 0;
    }
  }
  sub_244D16E80(a1, a2, v4, v5);
  return 1;
}

uint64_t sub_244D17004(unsigned int *a1)
{
  uint64_t v1 = a1[2];
  int v2 = v1 & ((int)v1 >> 31);
  uint64_t v3 = 8 * v1 - 8;
  while (1)
  {
    BOOL v4 = __OFSUB__(v1, 1);
    LODWORD(v1) = v1 - 1;
    if ((int)v1 < 0 != v4) {
      break;
    }
    uint64_t v5 = *(void *)(*(void *)a1 + v3);
    v3 -= 8;
    if (v5)
    {
      int v2 = v1 + 1;
      break;
    }
  }
  if (!v2) {
    return 0;
  }
  if (v2 == 1) {
    return **(void **)a1;
  }
  return -1;
}

uint64_t sub_244D17058(uint64_t **a1, void *a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  int v3 = v2 & ((int)v2 >> 31);
  uint64_t v4 = 8 * v2 - 8;
  while (1)
  {
    BOOL v5 = __OFSUB__(v2, 1);
    LODWORD(v2) = v2 - 1;
    if ((int)v2 < 0 != v5) {
      break;
    }
    uint64_t v6 = *(uint64_t *)((char *)*a1 + v4);
    v4 -= 8;
    if (v6)
    {
      int v3 = v2 + 1;
      break;
    }
  }
  if (!v3)
  {
    uint64_t v7 = 0;
    goto LABEL_9;
  }
  if (v3 == 1)
  {
    uint64_t v7 = **a1;
LABEL_9:
    *a2 = v7;
    return 1;
  }
  return 0;
}

uint64_t sub_244D170B4(uint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4)
{
  if (a2 >= a4) {
    unint64_t v5 = a4;
  }
  else {
    unint64_t v5 = a2;
  }
  if (v5)
  {
    LODWORD(result) = 0;
    uint64_t v7 = a1;
    size_t v8 = a3;
    do
    {
      uint64_t v10 = *v7++;
      uint64_t v9 = v10;
      uint64_t v11 = *v8++;
      uint64_t v12 = (((v11 ^ v9) - 1) & ~(v11 ^ v9)) >> 63;
      uint64_t result = result & v12 | (((((v9 - v11) ^ v9 | v11 ^ v9) ^ v9) >> 63) | 1) & ~v12;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t result = 0;
  }
  unint64_t v13 = a2 - a4;
  if (a2 >= a4)
  {
    if (a4 < a2)
    {
      uint64_t v18 = 0;
      unint64_t v19 = &a1[a4];
      do
      {
        uint64_t v20 = *v19++;
        v18 |= v20;
        --v13;
      }
      while (v13);
      return (((((v18 - 1) & ~v18) >> 63) & 1) == 0) | (((v18 - 1) & ~v18) >> 63) & result;
    }
  }
  else
  {
    uint64_t v14 = 0;
    unint64_t v15 = a4 - a2;
    unint64_t v16 = &a3[a2];
    do
    {
      uint64_t v17 = *v16++;
      v14 |= v17;
      --v15;
    }
    while (v15);
    return result | ~(((v14 - 1) & ~v14) >> 63);
  }
  return result;
}

uint64_t sub_244D17194(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    int v2 = *(_DWORD *)(a1 + 16);
    if (v2 == *(_DWORD *)(a2 + 16))
    {
      LODWORD(result) = sub_244D170B4(*(uint64_t **)a1, *(int *)(a1 + 8), *(uint64_t **)a2, *(int *)(a2 + 8));
      if (v2) {
        return -(int)result;
      }
      else {
        return result;
      }
    }
    else if (v2)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      return 1;
    }
  }
  else if (a1)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return a2 != 0;
  }
}

uint64_t sub_244D17214(uint64_t *a1, uint64_t *a2, unint64_t a3)
{
  return sub_244D170B4(a1, a3, a2, a3) >> 31;
}

BOOL sub_244D1723C(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = a1[2];
  if (v2)
  {
    a2 ^= **(void **)a1;
    if ((int)v2 >= 2)
    {
      int v3 = (uint64_t *)(*(void *)a1 + 8);
      uint64_t v4 = v2 - 1;
      do
      {
        uint64_t v5 = *v3++;
        a2 |= v5;
        --v4;
      }
      while (v4);
    }
  }
  return a2 == 0;
}

uint64_t sub_244D1727C(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  uint64_t v6 = 0x200000000;
  int v3 = &v7;
  BOOL v4 = a2 != 0;
  int v5 = 1;
  return sub_244D17194(a1, (uint64_t)&v3);
}

BOOL sub_244D172C8(unsigned int *a1)
{
  if (a1[4]) {
    return 0;
  }
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = **(void **)a1 ^ 1;
    if ((int)v2 >= 2)
    {
      uint64_t v4 = v2 - 1;
      int v5 = (uint64_t *)(*(void *)a1 + 8);
      do
      {
        uint64_t v6 = *v5++;
        v3 |= v6;
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    uint64_t v3 = 1;
  }
  return v3 == 0;
}

BOOL sub_244D17320(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a2;
  if (v2)
  {
    uint64_t v3 = **(void **)a1 ^ a2;
    if ((int)v2 >= 2)
    {
      uint64_t v4 = v2 - 1;
      int v5 = (uint64_t *)(*(void *)a1 + 8);
      do
      {
        uint64_t v6 = *v5++;
        v3 |= v6;
        --v4;
      }
      while (v4);
    }
  }
  if (v3) {
    return 0;
  }
  if (a2) {
    return a1[4] == 0;
  }
  return 1;
}

uint64_t sub_244D17380(uint64_t a1)
{
  if (*(int *)(a1 + 8) < 1) {
    return 0;
  }
  else {
    return **(_DWORD **)a1 & 1;
  }
}

BOOL sub_244D173A4(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 8);
  int v2 = v1 & ((int)v1 >> 31);
  uint64_t v3 = 8 * v1 - 8;
  int v4 = *(_DWORD *)(a1 + 8);
  while (1)
  {
    BOOL v5 = __OFSUB__(v4--, 1);
    if (v4 < 0 != v5) {
      break;
    }
    uint64_t v6 = *(void *)(*(void *)a1 + v3);
    v3 -= 8;
    if (v6)
    {
      int v2 = v4 + 1;
      goto LABEL_6;
    }
  }
  if ((v1 & 0x80000000) == 0) {
    return 0;
  }
LABEL_6:
  if (*(_DWORD *)(a1 + 16)) {
    return 0;
  }
  int v8 = v2 - 1;
  if (v2 >= 2)
  {
    uint64_t v9 = (v2 - 1);
    uint64_t v10 = *(void **)a1;
    while (!*v10++)
    {
      if (!--v9) {
        return (*(void *)(*(void *)a1 + 8 * v8) & (*(void *)(*(void *)a1 + 8 * v8) - 1)) == 0;
      }
    }
    return 0;
  }
  return (*(void *)(*(void *)a1 + 8 * v8) & (*(void *)(*(void *)a1 + 8 * v8) - 1)) == 0;
}

BOOL sub_244D17428(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int *)(a1 + 8);
  uint64_t v3 = *(int *)(a2 + 8);
  if ((int)v2 >= (int)v3)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    BOOL v5 = (uint64_t *)(*(void *)a2 + 8 * v2);
    uint64_t v6 = v3 - v2;
    do
    {
      uint64_t v7 = *v5++;
      v4 |= v7;
      --v6;
    }
    while (v6);
  }
  if ((int)v3 < (int)v2)
  {
    int v8 = (uint64_t *)(*(void *)a1 + 8 * v3);
    uint64_t v9 = v2 - v3;
    do
    {
      uint64_t v10 = *v8++;
      v4 |= v10;
      --v9;
    }
    while (v9);
  }
  if ((int)v2 >= (int)v3) {
    uint64_t v2 = v3;
  }
  else {
    uint64_t v2 = v2;
  }
  if ((int)v2 >= 1)
  {
    uint64_t v11 = *(uint64_t **)a1;
    uint64_t v12 = *(uint64_t **)a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      uint64_t v15 = *v12++;
      v4 |= v15 ^ v13;
      --v2;
    }
    while (v2);
  }
  return (v4 | *(_DWORD *)(a2 + 16) ^ *(_DWORD *)(a1 + 16)) == 0;
}

double sub_244D174D4()
{
  uint64_t v0 = sub_244D43FF4(0x30uLL);
  if (v0)
  {
    double result = 0.0;
    *(_OWORD *)((char *)v0 + 26) = 0u;
    _OWORD *v0 = 0u;
    v0[1] = 0u;
  }
  return result;
}

void sub_244D17500(unint64_t **a1)
{
  if (a1)
  {
    sub_244D4B564(*a1, (void (*)(uint64_t))sub_244D3AE08, (uint64_t)sub_244D166B0);
    sub_244D440EC(a1[1]);
    sub_244D440EC(a1);
  }
}

void *sub_244D1756C(void *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = result[4];
    unint64_t v3 = result[2];
    if (v3 != result[3])
    {
      double result = (void *)result[1];
      goto LABEL_14;
    }
    if (v3) {
      unint64_t v4 = (3 * v3) >> 1;
    }
    else {
      unint64_t v4 = 32;
    }
    if (v4 > v3 && v4 >> 61 == 0)
    {
      double result = sub_244D44148((void *)result[1], 8 * v4);
      if (result)
      {
        v1[1] = result;
        v1[3] = v4;
        unint64_t v3 = v1[2];
LABEL_14:
        result[v3] = v2;
        ++v1[2];
        return result;
      }
    }
    *((_WORD *)v1 + 20) = 257;
  }
  return result;
}

unint64_t *sub_244D17610(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40))
  {
    if (*(unsigned char *)(a1 + 41))
    {
      sub_244D0B884(3, 0, 116, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/ctx.c", 155);
      double result = 0;
      *(unsigned char *)(a1 + 41) = 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    double result = *(unint64_t **)a1;
    if (*(void *)a1 || (double result = sub_244D4B4C8(), (*(void *)a1 = result) != 0))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      if (v3 != sub_244D259E0((uint64_t)result)
        || (unint64_t v4 = sub_244D16670()) != 0 && sub_244D4BA04(*(unint64_t **)a1, (uint64_t)v4))
      {
        double result = sub_244D4B518(*(unint64_t **)a1, *(void *)(a1 + 32));
        *((_DWORD *)result + 4) = 0;
        *((_DWORD *)result + 2) = 0;
        ++*(void *)(a1 + 32);
        return result;
      }
      sub_244D0B884(3, 0, 116, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/ctx.c", 172);
      sub_244D166B0((void **)v4);
      double result = 0;
    }
    *(unsigned char *)(a1 + 40) = 1;
  }
  return result;
}

uint64_t sub_244D17704(uint64_t result)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v1 = *(void *)(result + 8);
    uint64_t v2 = *(void *)(result + 16) - 1;
    *(void *)(result + 16) = v2;
    *(void *)(result + 32) = *(void *)(v1 + 8 * v2);
  }
  return result;
}

uint64_t sub_244D17728(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a3 + 8);
  int v10 = v9 & ((int)v9 >> 31);
  uint64_t v11 = 8 * v9 - 8;
  while (1)
  {
    BOOL v12 = __OFSUB__(v9, 1);
    LODWORD(v9) = v9 - 1;
    if ((int)v9 < 0 != v12) {
      break;
    }
    uint64_t v13 = *(void *)(*(void *)a3 + v11);
    v11 -= 8;
    if (v13)
    {
      int v10 = v9 + 1;
      break;
    }
  }
  uint64_t v14 = *(unsigned int *)(a4 + 8);
  uint64_t v15 = (int)v14;
  int v16 = v14 & ((int)v14 >> 31);
  uint64_t v17 = 8 * v14 - 8;
  int v18 = *(_DWORD *)(a4 + 8);
  while (1)
  {
    BOOL v12 = __OFSUB__(v18--, 1);
    if (v18 < 0 != v12) {
      break;
    }
    uint64_t v19 = *(void *)(*(void *)a4 + v17);
    v17 -= 8;
    if (v19)
    {
      int v16 = v18 + 1;
      break;
    }
  }
  BOOL v12 = __OFSUB__(v10, 1);
  int v20 = v10 - 1;
  if (v20 < 0 == v12 && !*(void *)(*(void *)a3 + 8 * v20)
    || v16 >= 1 && !*(void *)(*(void *)a4 + 8 * (v16 - 1)))
  {
    int v37 = 111;
    __int16 v38 = 212;
LABEL_36:
    sub_244D0B884(3, 0, v37, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/div.c", v38);
    return 0;
  }
  if (!v14) {
    goto LABEL_35;
  }
  uint64_t v21 = 0;
  unint64_t v22 = *(uint64_t **)a4;
  do
  {
    uint64_t v23 = *v22++;
    v21 |= v23;
    --v15;
  }
  while (v15);
  if (!v21)
  {
LABEL_35:
    int v37 = 105;
    __int16 v38 = 217;
    goto LABEL_36;
  }
  sub_244D1756C((void *)a5);
  int v85 = sub_244D17610(a5);
  uint64_t v84 = sub_244D17610(a5);
  unint64_t v24 = sub_244D17610(a5);
  if (!a1) {
    a1 = sub_244D17610(a5);
  }
  if (!v24) {
    goto LABEL_79;
  }
  if (!a1) {
    goto LABEL_79;
  }
  int v25 = sub_244D168EC((uint64_t *)a4) & 0x3F;
  if (!sub_244D17CA4((uint64_t)v24, (uint64_t *)a4, 64 - v25)) {
    goto LABEL_79;
  }
  uint64_t v26 = *((unsigned int *)v24 + 2);
  int v27 = v26 & ((int)v26 >> 31);
  uint64_t v28 = 8 * v26 - 8;
  while (1)
  {
    BOOL v12 = __OFSUB__(v26, 1);
    LODWORD(v26) = v26 - 1;
    if ((int)v26 < 0 != v12) {
      break;
    }
    uint64_t v29 = *(void *)(*v24 + v28);
    v28 -= 8;
    if (v29)
    {
      int v27 = v26 + 1;
      break;
    }
  }
  *((_DWORD *)v24 + 2) = v27;
  *((_DWORD *)v24 + 4) = 0;
  unsigned int v79 = 128 - v25;
  if (!sub_244D17CA4((uint64_t)v84, (uint64_t *)a3, 128 - v25)) {
    goto LABEL_79;
  }
  uint64_t v30 = *((unsigned int *)v84 + 2);
  int v31 = v30 & ((int)v30 >> 31);
  uint64_t v32 = 8 * v30 - 8;
  while (1)
  {
    BOOL v12 = __OFSUB__(v30, 1);
    LODWORD(v30) = v30 - 1;
    if ((int)v30 < 0 != v12) {
      break;
    }
    uint64_t v33 = *(void *)(*v84 + v32);
    v32 -= 8;
    if (v33)
    {
      int v31 = v30 + 1;
      break;
    }
  }
  *((_DWORD *)v84 + 2) = v31;
  *((_DWORD *)v84 + 4) = 0;
  uint64_t v34 = *((int *)v24 + 2);
  if (v31 <= (int)v34 + 1)
  {
    if (sub_244D15DEC((void **)v84, v34 + 2))
    {
      int8x16_t v35 = v84;
      uint64_t v40 = *((int *)v84 + 2);
      LODWORD(v36) = *((_DWORD *)v24 + 2) + 2;
      if ((int)v40 < (int)v36)
      {
        do
        {
          *(void *)(*v84 + 8 * v40++) = 0;
          uint64_t v36 = *((int *)v24 + 2) + 2;
        }
        while (v40 < v36);
      }
      goto LABEL_41;
    }
LABEL_79:
    if (!*(unsigned char *)(a5 + 40))
    {
      uint64_t result = 0;
      uint64_t v72 = *(void *)(a5 + 8);
      uint64_t v73 = *(void *)(a5 + 16) - 1;
      *(void *)(a5 + 16) = v73;
      *(void *)(a5 + 32) = *(void *)(v72 + 8 * v73);
      return result;
    }
    return 0;
  }
  if (!sub_244D15DEC((void **)v84, v31 + 1)) {
    goto LABEL_79;
  }
  int8x16_t v35 = v84;
  *(void *)(*v84 + 8 * *((int *)v84 + 2)) = 0;
  LODWORD(v36) = *((_DWORD *)v84 + 2) + 1;
LABEL_41:
  *((_DWORD *)v35 + 2) = v36;
  int v41 = *((_DWORD *)v24 + 2);
  int v42 = v36 - v41;
  unint64_t v43 = *v24;
  unint64_t v82 = v41;
  if (v41 == 1) {
    unint64_t v44 = 0;
  }
  else {
    unint64_t v44 = *(void *)(v43 + 8 * (v41 - 2));
  }
  unint64_t v78 = *v35;
  uint64_t v45 = *(void *)(v43 + 8 * (v41 - 1));
  int v46 = *(_DWORD *)(a3 + 16);
  *((_DWORD *)a1 + 4) = *(_DWORD *)(a4 + 16) ^ v46;
  if (!sub_244D15DEC((void **)a1, v42 + 1)) {
    goto LABEL_79;
  }
  int v47 = v42 - 1;
  *((_DWORD *)a1 + 2) = v42 - 1;
  uint64_t v48 = (void *)*a1;
  if (!sub_244D15DEC((void **)v85, v82 + 1)) {
    goto LABEL_79;
  }
  uint64_t v49 = a1;
  unint64_t v50 = &v48[v47];
  unint64_t v77 = v49;
  int v76 = v46;
  if (*((_DWORD *)v49 + 2)) {
    --v50;
  }
  else {
    *((_DWORD *)v49 + 4) = 0;
  }
  if (v42 >= 2)
  {
    int v51 = 0;
    int v52 = (uint64_t *)(v78 + 8 * v42);
    uint64_t v53 = (void *)(v78 + 8 * ((int)v36 - 1));
    uint64_t v80 = v45;
    int v81 = v47;
    do
    {
      if (*v53 == v45)
      {
        unint64_t v54 = -1;
      }
      else
      {
        uint64_t v55 = *(v53 - 1);
        unint64_t v54 = __udivti3();
        unint64_t v56 = v55 - v45 * v54;
        unint64_t v57 = (v54 * (unsigned __int128)v44) >> 64;
        for (unint64_t i = v54 * v44; __PAIR128__(v56, *(v53 - 2)) < __PAIR128__(v57, i); i -= v44)
        {
          --v54;
          BOOL v59 = __CFADD__(v56, v45);
          v56 += v45;
          if (v59) {
            break;
          }
          unint64_t v57 = (__PAIR128__(v57, i) - v44) >> 64;
        }
      }
      *(void *)(*v85 + 8 * v82) = sub_244D17E10((void *)*v85, (unint64_t *)*v24, v82, v54);
      --v52;
      if (sub_244D16544((unint64_t *)v52, (unint64_t *)v52, (unint64_t *)*v85, v82 + 1))
      {
        --v54;
        if (sub_244D15EB4(v52, v52, (uint64_t *)*v24, v82)) {
          ++*v53;
        }
      }
      uint64_t v45 = v80;
      *v50-- = v54;
      ++v51;
      --v53;
    }
    while (v51 != v81);
  }
  uint64_t v60 = *((unsigned int *)v84 + 2);
  uint64_t v61 = 8 * v60 - 8;
  int v62 = *((_DWORD *)v84 + 2);
  while (1)
  {
    BOOL v12 = __OFSUB__(v62--, 1);
    if (v62 < 0 != v12) {
      break;
    }
    uint64_t v63 = *(void *)(*v84 + v61);
    v61 -= 8;
    if (v63)
    {
      *((_DWORD *)v84 + 2) = v62 + 1;
      goto LABEL_68;
    }
  }
  *((_DWORD *)v84 + 2) = v60 & ((int)v60 >> 31);
  if ((v60 & 0x80000000) == 0) {
    *((_DWORD *)v84 + 4) = 0;
  }
LABEL_68:
  if (!a2) {
    goto LABEL_75;
  }
  if (!sub_244D17ED0((void **)a2, (uint64_t)v84, v79)) {
    goto LABEL_79;
  }
  uint64_t v64 = *(int *)(a2 + 8);
  if (v64)
  {
    uint64_t v65 = 0;
    uint64_t v66 = *(uint64_t **)a2;
    do
    {
      uint64_t v67 = *v66++;
      v65 |= v67;
      --v64;
    }
    while (v64);
    if (v65) {
      *(_DWORD *)(a2 + 16) = v76;
    }
  }
LABEL_75:
  uint64_t v68 = *((unsigned int *)v77 + 2);
  uint64_t v69 = 8 * v68 - 8;
  int v70 = *((_DWORD *)v77 + 2);
  while (1)
  {
    BOOL v12 = __OFSUB__(v70--, 1);
    if (v70 < 0 != v12) {
      break;
    }
    uint64_t v71 = *(void *)(*v77 + v69);
    v69 -= 8;
    if (v71)
    {
      *((_DWORD *)v77 + 2) = v70 + 1;
      goto LABEL_83;
    }
  }
  *((_DWORD *)v77 + 2) = v68 & ((int)v68 >> 31);
  if ((v68 & 0x80000000) == 0) {
    *((_DWORD *)v77 + 4) = 0;
  }
LABEL_83:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v74 = *(void *)(a5 + 8);
    uint64_t v75 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v75;
    *(void *)(a5 + 32) = *(void *)(v74 + 8 * v75);
  }
  return 1;
}

uint64_t sub_244D17CA4(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  if ((a3 & 0x80000000) != 0)
  {
    sub_244D0B884(3, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/shift.c", 73);
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
    uint64_t result = sub_244D15DEC((void **)a1, (int)(*((_DWORD *)a2 + 2) + (a3 >> 6) + 1));
    if (result)
    {
      unsigned int v7 = a3 >> 6;
      uint64_t v8 = *a2;
      uint64_t v9 = *(void **)a1;
      *(void *)(*(void *)a1 + 8 * (int)(*((_DWORD *)a2 + 2) + (a3 >> 6))) = 0;
      unint64_t v10 = *((unsigned int *)a2 + 2);
      char v11 = a3 & 0x3F;
      if ((a3 & 0x3F) != 0)
      {
        if ((int)v10 >= 1)
        {
          uint64_t v12 = v8 - 8;
          do
          {
            unint64_t v13 = *(void *)(v12 + 8 * v10);
            v9[(int)(v7 + v10)] |= v13 >> (64 - v11);
            v9[v7 - 1 + v10] = v13 << v11;
            BOOL v14 = v10-- > 1;
          }
          while (v14);
        }
      }
      else if ((int)v10 >= 1)
      {
        do
        {
          v9[v7 - 1 + v10] = *(void *)(v8 - 8 + 8 * v10);
          BOOL v14 = v10-- > 1;
        }
        while (v14);
      }
      if (a3 >= 0x40) {
        bzero(v9, 8 * v7);
      }
      int v15 = *((_DWORD *)a2 + 2) + v7;
      *(_DWORD *)(a1 + 8) = v15 + 1;
      uint64_t v16 = 8 * (v15 + 1) - 8;
      int v17 = v15 + 2;
      while (--v17 >= 1)
      {
        uint64_t v18 = *(void *)(*(void *)a1 + v16);
        v16 -= 8;
        if (v18)
        {
          *(_DWORD *)(a1 + 8) = v17;
          return 1;
        }
      }
      *(_DWORD *)(a1 + 8) = (v15 + 1) & ((v15 + 1) >> 31);
      if (v15 >= -1) {
        *(_DWORD *)(a1 + 16) = 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D17E10(void *a1, unint64_t *a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0;
  }
  if (a3 < 4)
  {
    uint64_t v4 = 0;
    do
    {
LABEL_20:
      unint64_t v23 = *a2++;
      uint64_t v24 = (v23 * (unsigned __int128)a4) >> 64;
      uint64_t v25 = v23 * a4 + v4;
      if (__CFADD__(v23 * a4, v4)) {
        uint64_t v4 = v24 + 1;
      }
      else {
        uint64_t v4 = v24;
      }
      *a1++ = v25;
      --a3;
    }
    while (a3);
    return v4;
  }
  uint64_t v4 = 0;
  do
  {
    unint64_t v5 = *a2 * a4;
    BOOL v6 = __CFADD__(v5, v4);
    uint64_t v7 = v5 + v4;
    if (v6) {
      uint64_t v8 = ((*a2 * (unsigned __int128)a4) >> 64) + 1;
    }
    else {
      uint64_t v8 = (*a2 * (unsigned __int128)a4) >> 64;
    }
    *a1 = v7;
    unint64_t v9 = a2[1];
    uint64_t v10 = (v9 * (unsigned __int128)a4) >> 64;
    unint64_t v11 = v9 * a4;
    BOOL v6 = __CFADD__(v11, v8);
    uint64_t v12 = v11 + v8;
    if (v6) {
      uint64_t v13 = v10 + 1;
    }
    else {
      uint64_t v13 = v10;
    }
    a1[1] = v12;
    unint64_t v14 = a2[2];
    uint64_t v15 = (v14 * (unsigned __int128)a4) >> 64;
    unint64_t v16 = v14 * a4;
    BOOL v6 = __CFADD__(v16, v13);
    uint64_t v17 = v16 + v13;
    if (v6) {
      uint64_t v18 = v15 + 1;
    }
    else {
      uint64_t v18 = v15;
    }
    a1[2] = v17;
    unint64_t v19 = a2[3];
    uint64_t v20 = (v19 * (unsigned __int128)a4) >> 64;
    unint64_t v21 = v19 * a4;
    BOOL v6 = __CFADD__(v21, v18);
    uint64_t v22 = v21 + v18;
    if (v6) {
      uint64_t v4 = v20 + 1;
    }
    else {
      uint64_t v4 = v20;
    }
    a1[3] = v22;
    a2 += 4;
    a1 += 4;
    a3 -= 4;
  }
  while (a3 >= 4);
  if (a3) {
    goto LABEL_20;
  }
  return v4;
}

uint64_t sub_244D17ED0(void **a1, uint64_t a2, unsigned int a3)
{
  if ((a3 & 0x80000000) != 0)
  {
    sub_244D0B884(3, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/shift.c", 158);
    return 0;
  }
  else
  {
    uint64_t result = sub_244D15DEC(a1, *(int *)(a2 + 8));
    if (result)
    {
      sub_244D20E1C(*a1, *(void *)a2, a3, *(int *)(a2 + 8));
      *((_DWORD *)a1 + 4) = *(_DWORD *)(a2 + 16);
      uint64_t v7 = *(unsigned int *)(a2 + 8);
      *((_DWORD *)a1 + 2) = v7;
      uint64_t v8 = 8 * v7 - 8;
      int v9 = v7;
      while (1)
      {
        BOOL v10 = __OFSUB__(v9--, 1);
        if (v9 < 0 != v10) {
          break;
        }
        uint64_t v11 = *(void *)((char *)*a1 + v8);
        v8 -= 8;
        if (v11)
        {
          *((_DWORD *)a1 + 2) = v9 + 1;
          return 1;
        }
      }
      *((_DWORD *)a1 + 2) = v7 & ((int)v7 >> 31);
      if ((v7 & 0x80000000) == 0) {
        *((_DWORD *)a1 + 4) = 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D17F9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_244D17728(0, a1, a2, a3, a4);
  if (result)
  {
    if (*(_DWORD *)(a1 + 16))
    {
      if (*(_DWORD *)(a3 + 16)) {
        uint64_t v7 = sub_244D16310;
      }
      else {
        uint64_t v7 = sub_244D15B90;
      }
      return v7(a1, a1, a3);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D18038(unint64_t *a1, unint64_t *a2, uint64_t a3, unint64_t *a4, unint64_t a5)
{
  unint64_t v5 = a5;
  BOOL v6 = a2;
  uint64_t v7 = a1;
  for (uint64_t result = a3 - sub_244D16544(a1, a2, a4, a5); v5; --v5)
  {
    uint64_t v9 = *v6++;
    *uint64_t v7 = *v7 & ~result | v9 & result;
    ++v7;
  }
  return result;
}

uint64_t sub_244D180A8(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t *a4, unint64_t a5)
{
  unint64_t v5 = a5;
  BOOL v6 = a4;
  uint64_t v7 = a1;
  for (uint64_t result = a2 - sub_244D16544(a4, a1, a3, a5); v5; --v5)
  {
    uint64_t v9 = *v6++;
    *uint64_t v7 = v9 & ~result | *v7 & result;
    ++v7;
  }
  return result;
}

uint64_t sub_244D1811C(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t *a4, uint64_t *a5, unint64_t a6)
{
  unint64_t v6 = a6;
  uint64_t v9 = (uint64_t *)a1;
  unint64_t v10 = sub_244D16544(a1, a2, a3, a6);
  for (uint64_t result = sub_244D15EB4(a5, v9, a4, v6); v6; --v6)
  {
    uint64_t v12 = *a5++;
    *uint64_t v9 = *v9 & (v10 - 1) | v12 & -(uint64_t)v10;
    ++v9;
  }
  return result;
}

uint64_t sub_244D181A4(unint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, unint64_t a6)
{
  uint64_t v10 = sub_244D15EB4(a1, a2, a3, a6);

  return sub_244D180A8(a1, v10, a4, a5, a6);
}

uint64_t sub_244D18204(void **a1, void **a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  if (*(_DWORD *)(a3 + 16) || *(_DWORD *)(a4 + 16))
  {
    int v7 = 109;
    __int16 v8 = 461;
LABEL_4:
    sub_244D0B884(3, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/div.c", v8);
    return 0;
  }
  uint64_t v10 = *(int *)(a4 + 8);
  if (!v10) {
    goto LABEL_34;
  }
  uint64_t v16 = 0;
  uint64_t v17 = *(unint64_t **)a4;
  do
  {
    uint64_t v18 = *v17++;
    v16 |= v18;
    --v10;
  }
  while (v10);
  if (!v16)
  {
LABEL_34:
    int v7 = 105;
    __int16 v8 = 465;
    goto LABEL_4;
  }
  sub_244D1756C((void *)a6);
  if (!a1 || a1 == (void **)a3 || (unint64_t v19 = (unint64_t *)a1, a1 == (void **)a4)) {
    unint64_t v19 = sub_244D17610(a6);
  }
  if (!a2 || a2 == (void **)a3 || (uint64_t v20 = (unint64_t *)a2, a2 == (void **)a4)) {
    uint64_t v20 = sub_244D17610(a6);
  }
  unint64_t v21 = sub_244D17610(a6);
  uint64_t result = 0;
  if (v19)
  {
    if (v20)
    {
      if (v21)
      {
        uint64_t result = sub_244D15DEC((void **)v19, *(int *)(a3 + 8));
        if (result)
        {
          uint64_t result = sub_244D15DEC((void **)v20, *(int *)(a4 + 8));
          if (result)
          {
            uint64_t result = sub_244D15DEC((void **)v21, *(int *)(a4 + 8));
            if (result)
            {
              uint64_t v22 = *(int *)(a3 + 8);
              if (v22)
              {
                bzero((void *)*v19, 8 * v22);
                LODWORD(v22) = *(_DWORD *)(a3 + 8);
              }
              *((_DWORD *)v19 + 2) = v22;
              *((_DWORD *)v19 + 4) = 0;
              uint64_t v23 = *(int *)(a4 + 8);
              if (v23)
              {
                bzero((void *)*v20, 8 * v23);
                LODWORD(v23) = *(_DWORD *)(a4 + 8);
              }
              *((_DWORD *)v20 + 2) = v23;
              *((_DWORD *)v20 + 4) = 0;
              signed int v24 = *(_DWORD *)(a3 + 8);
              if (a5
                && ((int)((a5 - 1) >> 6) >= v24
                  ? (signed int v25 = *(_DWORD *)(a3 + 8))
                  : (signed int v25 = (a5 - 1) >> 6),
                    v25))
              {
                memcpy((void *)*v20, (const void *)(*(void *)a3 + 8 * v24 - 8 * v25), 8 * v25);
                signed int v24 = *(_DWORD *)(a3 + 8);
                int v26 = ~v25;
              }
              else
              {
                int v26 = -1;
              }
              uint64_t v27 = (v24 + v26);
              if (v24 + v26 >= 0)
              {
                do
                {
                  for (uint64_t i = 63; i != -1; --i)
                  {
                    uint64_t v29 = sub_244D15EB4((void *)*v20, (uint64_t *)*v20, (uint64_t *)*v20, *(int *)(a4 + 8));
                    *(void *)*v20 |= (*(void *)(*(void *)a3 + 8 * v27) >> i) & 1;
                    *(void *)(*v19 + 8 * v27) |= (unint64_t)((sub_244D180A8((unint64_t *)*v20, v29, *(unint64_t **)a4, (unint64_t *)*v21, *(int *)(a4 + 8)) & 1) == 0) << i;
                  }
                }
                while ((int)v27-- > 0);
              }
              if ((!a1 || (uint64_t result = (uint64_t)sub_244D16764(a1, (uint64_t)v19)) != 0)
                && (!a2 || (uint64_t result = (uint64_t)sub_244D16764(a2, (uint64_t)v20)) != 0))
              {
                uint64_t result = 1;
              }
            }
          }
        }
      }
    }
  }
  if (!*(unsigned char *)(a6 + 40))
  {
    uint64_t v31 = *(void *)(a6 + 8);
    uint64_t v32 = *(void *)(a6 + 16) - 1;
    *(void *)(a6 + 16) = v32;
    *(void *)(a6 + 32) = *(void *)(v31 + 8 * v32);
  }
  return result;
}

uint64_t sub_244D184C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = sub_244D15B90(a1, a2, a3);
  if (result)
  {
    return sub_244D17F9C(a1, a1, a4, a5);
  }
  return result;
}

uint64_t sub_244D18530(unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v8 = sub_244D43FF4(0x30uLL);
  uint64_t v9 = (unint64_t **)v8;
  if (v8)
  {
    *(_OWORD *)((char *)v8 + 26) = 0u;
    *__int16 v8 = 0u;
    v8[1] = 0u;
    uint64_t v10 = sub_244D185B8(a1, a2, a3, a4, (uint64_t)v8);
  }
  else
  {
    uint64_t v10 = 0;
  }
  sub_244D17500(v9);
  return v10;
}

uint64_t sub_244D185B8(unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_244D1756C((void *)a5);
  uint64_t v10 = (uint64_t **)sub_244D186D0(a2, *(int *)(a4 + 8), a5);
  uint64_t v11 = (uint64_t **)sub_244D186D0(a3, *(int *)(a4 + 8), a5);
  uint64_t v12 = sub_244D18748(*(int *)(a4 + 8), a5);
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13 || v12 == 0)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t v15 = (unint64_t **)v12;
    uint64_t result = sub_244D15DEC(a1, *(int *)(a4 + 8));
    if (result)
    {
      uint64_t v17 = *a1;
      uint64_t v18 = *v10;
      unint64_t v19 = *v11;
      uint64_t v20 = *(unint64_t **)a4;
      unint64_t v21 = *v15;
      unint64_t v22 = *(int *)(a4 + 8);
      uint64_t v23 = sub_244D15EB4(*a1, v18, v19, v22);
      sub_244D180A8(v17, v23, v20, v21, v22);
      *((_DWORD *)a1 + 2) = *(_DWORD *)(a4 + 8);
      *((_DWORD *)a1 + 4) = 0;
      uint64_t result = 1;
    }
  }
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v24 = *(void *)(a5 + 8);
    uint64_t v25 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v25;
    *(void *)(a5 + 32) = *(void *)(v24 + 8 * v25);
  }
  return result;
}

uint64_t sub_244D186D0(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  if (*(int *)(a1 + 8) < a2)
  {
    unint64_t v5 = sub_244D18748(a2, a3);
    if (v5 && (uint64_t v6 = (uint64_t)v5, sub_244D16764((void **)v5, v3)))
    {
      if (sub_244D16BB4(v6, a2)) {
        return v6;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

unint64_t *sub_244D18748(unint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_244D17610(a2);
  uint64_t v4 = v3;
  if (v3)
  {
    if (sub_244D15DEC((void **)v3, a1))
    {
      *((_DWORD *)v4 + 4) = 0;
      *((_DWORD *)v4 + 2) = a1;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t sub_244D1879C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = sub_244D16310(a1, a2, a3);
  if (result)
  {
    return sub_244D17F9C(a1, a1, a4, a5);
  }
  return result;
}

uint64_t sub_244D18804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_244D1756C((void *)a5);
  uint64_t v10 = (unint64_t **)sub_244D186D0(a2, *(int *)(a4 + 8), a5);
  uint64_t v11 = (unint64_t **)sub_244D186D0(a3, *(int *)(a4 + 8), a5);
  uint64_t v12 = sub_244D18748(*(int *)(a4 + 8), a5);
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13 || v12 == 0)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t v15 = (uint64_t **)v12;
    uint64_t result = sub_244D15DEC((void **)a1, *(int *)(a4 + 8));
    if (result)
    {
      sub_244D1811C(*(unint64_t **)a1, *v10, *v11, *(uint64_t **)a4, *v15, *(int *)(a4 + 8));
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a4 + 8);
      *(_DWORD *)(a1 + 16) = 0;
      uint64_t result = 1;
    }
  }
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v17 = *(void *)(a5 + 8);
    uint64_t v18 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v18;
    *(void *)(a5 + 32) = *(void *)(v17 + 8 * v18);
  }
  return result;
}

uint64_t sub_244D188F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v8 = sub_244D43FF4(0x30uLL);
  uint64_t v9 = (unint64_t **)v8;
  if (v8)
  {
    *(_OWORD *)((char *)v8 + 26) = 0u;
    *__int16 v8 = 0u;
    v8[1] = 0u;
    uint64_t v10 = sub_244D18804(a1, a2, a3, a4, (uint64_t)v8);
  }
  else
  {
    uint64_t v10 = 0;
  }
  sub_244D17500(v9);
  return v10;
}

uint64_t sub_244D1897C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_244D1756C((void *)a5);
  uint64_t result = (uint64_t)sub_244D17610(a5);
  if (!result) {
    goto LABEL_5;
  }
  uint64_t v11 = result;
  if (a2 != a3)
  {
    uint64_t result = sub_244D18AA8(result, a2, a3, a5);
    if (!result) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  uint64_t result = sub_244D18A38(result, a2, a5);
  if (result) {
LABEL_4:
  }
    uint64_t result = sub_244D17F9C(a1, v11, a4, a5) != 0;
LABEL_5:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v12 = *(void *)(a5 + 8);
    uint64_t v13 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v13;
    *(void *)(a5 + 32) = *(void *)(v12 + 8 * v13);
  }
  return result;
}

uint64_t sub_244D18A38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_244D1EE78(a1, a2, a3);
  if (result)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    uint64_t v6 = 8 * v5 - 8;
    int v7 = *(_DWORD *)(a1 + 8);
    while (1)
    {
      BOOL v8 = __OFSUB__(v7--, 1);
      if (v7 < 0 != v8) {
        break;
      }
      uint64_t v9 = *(void *)(*(void *)a1 + v6);
      v6 -= 8;
      if (v9)
      {
        *(_DWORD *)(a1 + 8) = v7 + 1;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 8) = v5 & ((int)v5 >> 31);
    if ((v5 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 16) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D18AA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_244D1EA28(a1, a2, a3, a4);
  if (result)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    uint64_t v7 = 8 * v6 - 8;
    int v8 = *(_DWORD *)(a1 + 8);
    while (1)
    {
      BOOL v9 = __OFSUB__(v8--, 1);
      if (v8 < 0 != v9) {
        break;
      }
      uint64_t v10 = *(void *)(*(void *)a1 + v7);
      v7 -= 8;
      if (v10)
      {
        *(_DWORD *)(a1 + 8) = v8 + 1;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 8) = v6 & ((int)v6 >> 31);
    if ((v6 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 16) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D18B18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_244D18A38(a1, a2, a4);
  if (result)
  {
    return sub_244D17728(0, a1, a1, a3, a4);
  }
  return result;
}

BOOL sub_244D18B88(void **a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (!sub_244D17F9C((uint64_t)a1, a2, a4, a5)) {
    return 0;
  }
  if (!*(_DWORD *)(a4 + 16))
  {
    uint64_t v10 = 0;
    goto LABEL_7;
  }
  BOOL v9 = sub_244D16714(a4);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = v9;
  *((_DWORD *)v9 + 4) = 0;
LABEL_7:
  if (v10) {
    uint64_t v12 = (uint64_t)v10;
  }
  else {
    uint64_t v12 = a4;
  }
  BOOL v13 = sub_244D18C2C(a1, (uint64_t)a1, a3, v12, a5);
  sub_244D166B0((void **)v10);
  return v13;
}

BOOL sub_244D18C2C(void **a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (!sub_244D16764(a1, a2) || !sub_244D16BB4((uint64_t)a1, *(int *)(a4 + 8))) {
    return 0;
  }
  sub_244D1756C((void *)a5);
  BOOL v9 = sub_244D18748(*(int *)(a4 + 8), a5);
  BOOL v10 = v9 != 0;
  if (v9)
  {
    if (a3 >= 1)
    {
      uint64_t v11 = (unint64_t **)v9;
      do
      {
        uint64_t v12 = (unint64_t *)*a1;
        BOOL v13 = *(unint64_t **)a4;
        unint64_t v14 = *v11;
        unint64_t v15 = *(int *)(a4 + 8);
        uint64_t v16 = sub_244D15EB4(*a1, (uint64_t *)*a1, (uint64_t *)*a1, v15);
        sub_244D180A8(v12, v16, v13, v14, v15);
        --a3;
      }
      while (a3);
    }
    *((_DWORD *)a1 + 4) = 0;
  }
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v17 = *(void *)(a5 + 8);
    uint64_t v18 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v18;
    *(void *)(a5 + 32) = *(void *)(v17 + 8 * v18);
  }
  return v10;
}

BOOL sub_244D18D2C(void **a1, uint64_t a2, int a3, uint64_t a4)
{
  int v8 = sub_244D43FF4(0x30uLL);
  BOOL v9 = (unint64_t **)v8;
  if (v8)
  {
    *(_OWORD *)((char *)v8 + 26) = 0u;
    *int v8 = 0u;
    v8[1] = 0u;
    BOOL v10 = sub_244D18C2C(a1, a2, a3, a4, (uint64_t)v8);
  }
  else
  {
    BOOL v10 = 0;
  }
  sub_244D17500(v9);
  return v10;
}

uint64_t sub_244D18DB4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_244D18E1C(a1, a2);
  if (result)
  {
    return sub_244D17F9C(a1, a1, a3, a4);
  }
  return result;
}

uint64_t sub_244D18E1C(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 == a2)
  {
    uint64_t result = sub_244D15DEC((void **)a1, *(int *)(a1 + 8) + 1);
    if (!result) {
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
    uint64_t result = sub_244D15DEC((void **)a1, *((int *)a2 + 2) + 1);
    if (!result) {
      return result;
    }
    *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  }
  if (*((int *)a2 + 2) < 1) {
    return 1;
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  uint64_t v7 = *(void **)a1;
  uint64_t v8 = *a2;
  do
  {
    unint64_t v9 = *(void *)(v8 + 8 * v5);
    v7[v5] = v6 | (2 * v9);
    unint64_t v6 = v9 >> 63;
    ++v5;
  }
  while ((int)v5 < *((_DWORD *)a2 + 2));
  if ((v9 & 0x8000000000000000) == 0) {
    return 1;
  }
  uint64_t result = 1;
  v7[v5] = 1;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_244D18EE0(unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_244D185B8(a1, a2, a2, a3, a4);
}

uint64_t sub_244D18EF0(unint64_t **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_244D43FF4(0x30uLL);
  uint64_t v7 = (unint64_t **)v6;
  if (v6)
  {
    *(_OWORD *)((char *)v6 + 26) = 0u;
    *unint64_t v6 = 0u;
    v6[1] = 0u;
    uint64_t v8 = sub_244D185B8(a1, a2, a2, a3, (uint64_t)v6);
  }
  else
  {
    uint64_t v8 = 0;
  }
  sub_244D17500(v7);
  return v8;
}

uint64_t sub_244D18F6C(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return -1;
  }
  if (!*(_DWORD *)(a1 + 8)) {
    return 0;
  }
  int v4 = sub_244D16874(a2);
  char v5 = 64 - v4;
  if (!sub_244D17CA4(a1, (uint64_t *)a1, 64 - v4)) {
    return -1;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if ((int)v6 < 1)
  {
    unint64_t v12 = 0;
  }
  else
  {
    unint64_t v7 = a2 << -(char)v4;
    unint64_t v8 = v6 + 1;
    do
    {
      uint64_t v9 = *(void *)a1;
      uint64_t v10 = *(void *)(*(void *)a1 + 8 * (v8 - 2));
      uint64_t v11 = __udivti3();
      unint64_t v12 = v10 - v7 * v11;
      *(void *)(v9 + 8 * (v8-- - 2)) = v11;
    }
    while (v8 > 1);
    LODWORD(v6) = *(_DWORD *)(a1 + 8);
  }
  uint64_t v14 = 8 * v6 - 8;
  int v15 = v6;
  while (1)
  {
    BOOL v16 = __OFSUB__(v15--, 1);
    if (v15 < 0 != v16) {
      break;
    }
    uint64_t v17 = *(void *)(*(void *)a1 + v14);
    v14 -= 8;
    if (v17)
    {
      *(_DWORD *)(a1 + 8) = v15 + 1;
      return v12 >> v5;
    }
  }
  *(_DWORD *)(a1 + 8) = v6 & ((int)v6 >> 31);
  if ((v6 & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 16) = 0;
  }
  return v12 >> v5;
}

uint64_t sub_244D19094(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return -1;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if ((int)v2 < 1) {
    return 0;
  }
  unint64_t v3 = v2 + 1;
  do
  {
    uint64_t v4 = __umodti3();
    --v3;
  }
  while (v3 > 1);
  return v4;
}

uint64_t sub_244D19114(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3 || (unint64_t v5 = *(int *)(a2 + 8), !v5))
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    return 1;
  }
  char v6 = a3;
  unint64_t v7 = (unint64_t)(a3 - 1) >> 6;
  if (v7 >= v5) {
    return sub_244D16764((void **)a1, a2) != 0;
  }
  unint64_t v8 = v7 + 1;
  uint64_t result = sub_244D15DEC((void **)a1, v7 + 1);
  if (result)
  {
    memcpy(*(void **)a1, *(const void **)a2, 8 * v8);
    if ((v6 & 0x3F) != 0) {
      *(void *)(*(void *)a1 + 8 * v7) &= ~(-1 << (v6 & 0x3F));
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 8) = v8;
    uint64_t v10 = 8 * (v7 + 1) - 8;
    int v11 = v7 + 2;
    while (--v11 >= 1)
    {
      uint64_t v12 = *(void *)(*(void *)a1 + v10);
      v10 -= 8;
      if (v12)
      {
        *(_DWORD *)(a1 + 8) = v11;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 8) = v8 & ((int)v8 >> 31);
    if ((v8 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 16) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D19224(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_244D19114(a1, a2, a3);
  if (result)
  {
    uint64_t v6 = *(int *)(a1 + 8);
    if (!v6) {
      return 1;
    }
    uint64_t v7 = 0;
    unint64_t v8 = *(uint64_t **)a1;
    do
    {
      uint64_t v9 = *v8++;
      v7 |= v9;
      --v6;
    }
    while (v6);
    if (v7 && *(_DWORD *)(a1 + 16))
    {
      int64_t v10 = ((unint64_t)(a3 - 1) >> 6) + 1;
      uint64_t result = sub_244D15DEC((void **)a1, v10);
      if (result)
      {
        uint64_t v11 = *(int *)(a1 + 8);
        if (v10 != v11) {
          bzero((void *)(*(void *)a1 + 8 * v11), 8 * (v10 - v11));
        }
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 8) = v10;
        if ((int)v10 >= 1)
        {
          int64_t v12 = 0;
          do
          {
            *(void *)(*(void *)a1 + 8 * v12) = ~*(void *)(*(void *)a1 + 8 * v12);
            ++v12;
            int64_t v10 = *(int *)(a1 + 8);
          }
          while (v12 < v10);
        }
        if ((a3 & 0x3F) != 0)
        {
          *(void *)(*(void *)a1 + 8 * ((int)v10 - 1)) &= ~(-1 << (a3 & 0x3F));
          LODWORD(v10) = *(_DWORD *)(a1 + 8);
        }
        uint64_t v13 = 8 * v10 - 8;
        int v14 = v10;
        while (1)
        {
          BOOL v15 = __OFSUB__(v14--, 1);
          if (v14 < 0 != v15) {
            break;
          }
          uint64_t v16 = *(void *)(*(void *)a1 + v13);
          v13 -= 8;
          if (v16)
          {
            *(_DWORD *)(a1 + 8) = v14 + 1;
            goto LABEL_23;
          }
        }
        *(_DWORD *)(a1 + 8) = v10 & ((int)v10 >> 31);
        if ((v10 & 0x80000000) == 0) {
          *(_DWORD *)(a1 + 16) = 0;
        }
LABEL_23:
        sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
        return sub_244D15B90(a1, a1, (uint64_t)&qword_268EBEE70);
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D193AC(uint64_t a1, unsigned int a2)
{
  if (a2 >= 2)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 8);
    if ((int)v4 < 1)
    {
      LOWORD(v2) = 0;
    }
    else
    {
      unint64_t v6 = a2;
      char v7 = sub_244D16874(a2 - 1);
      unsigned int v2 = 0;
      unsigned int v8 = ((1 << (v7 + 32)) + (unint64_t)a2 - 1) / v6;
      char v9 = v7 - 1;
      unint64_t v10 = v4 + 1;
      do
      {
        uint64_t v11 = (int *)(*(void *)a1 + 8 * (v10 - 2));
        int v12 = *v11;
        LODWORD(v11) = v11[1];
        unsigned int v13 = (unsigned __int16)v11 | ((unsigned __int16)(WORD1(v11)
                                                        - ((((v8
                                                                          * (unint64_t)(__PAIR64__(v2, v11) >> 16)) >> 32)
                                                                        + (((__PAIR64__(v2, v11) >> 16)- ((v8* (unint64_t)(__PAIR64__(v2, v11) >> 16)) >> 32)) >> 1)) >> v9)* a2) << 16);
        HIDWORD(v14) = v11
                     - ((((v8 * (unint64_t)v13) >> 32)
                                     + ((v13 - ((v8 * (unint64_t)v13) >> 32)) >> 1)) >> v9)
                     * a2;
        LODWORD(v14) = v12;
        LODWORD(v11) = (unsigned __int16)v12 | ((unsigned __int16)(HIWORD(v12)
                                                                 - ((((v8
                                                                                   * (unint64_t)(v14 >> 16)) >> 32)
                                                                                 + (((v14 >> 16)
                                                                                                 - ((v8 * (unint64_t)(v14 >> 16)) >> 32)) >> 1)) >> v9)
                                                                 * a2) << 16);
        unsigned int v2 = v12
           - ((((v8 * (unint64_t)v11) >> 32)
                           + ((v11 - ((v8 * (unint64_t)v11) >> 32)) >> 1)) >> v9)
           * a2;
        --v10;
      }
      while (v10 > 1);
    }
  }
  else
  {
    LOWORD(v2) = 0;
  }
  return (unsigned __int16)v2;
}

uint64_t sub_244D194CC(void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_244D1756C((void *)a4);
  if (a1 == (void **)a2 || (unsigned int v8 = (unint64_t *)a1, a1 == (void **)a3)) {
    unsigned int v8 = sub_244D17610(a4);
  }
  char v9 = sub_244D17610(a4);
  uint64_t result = 0;
  if (v8)
  {
    if (v9)
    {
      uint64_t result = (uint64_t)sub_244D16764((void **)v9, a2);
      if (result)
      {
        int v11 = sub_244D168EC((uint64_t *)a3);
        if (*(int *)(a3 + 8) >= 1 && (**(unsigned char **)a3 & 1) != 0)
        {
          uint64_t result = (uint64_t)sub_244D16764((void **)v8, a2);
          if (!result) {
            goto LABEL_22;
          }
        }
        else
        {
          uint64_t result = sub_244D15DEC((void **)v8, 1uLL);
          if (!result) {
            goto LABEL_22;
          }
          *((_DWORD *)v8 + 4) = 0;
          *(void *)*unsigned int v8 = 1;
          *((_DWORD *)v8 + 2) = 1;
        }
        if (v11 < 2)
        {
LABEL_19:
          if (v8 == (unint64_t *)a1 || (uint64_t result = (uint64_t)sub_244D16764(a1, (uint64_t)v8)) != 0) {
            uint64_t result = 1;
          }
        }
        else
        {
          uint64_t v12 = v11;
          unint64_t v13 = 1;
          while (1)
          {
            uint64_t result = sub_244D18A38((uint64_t)v9, (uint64_t)v9, a4);
            if (!result) {
              break;
            }
            if (v13 >> 6 < *(int *)(a3 + 8) && ((*(void *)(*(void *)a3 + 8 * (v13 >> 6)) >> v13) & 1) != 0)
            {
              uint64_t result = sub_244D18AA8((uint64_t)v8, (uint64_t)v8, (uint64_t)v9, a4);
              if (!result) {
                break;
              }
            }
            if (v12 == ++v13) {
              goto LABEL_19;
            }
          }
        }
      }
    }
  }
LABEL_22:
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v14 = *(void *)(a4 + 8);
    uint64_t v15 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v15;
    *(void *)(a4 + 32) = *(void *)(v14 + 8 * v15);
  }
  return result;
}

uint64_t sub_244D1965C(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v2 = (unint64_t)a2 >> 6;
  if (v2 >= *(int *)(a1 + 8)) {
    return 0;
  }
  else {
    return (*(void *)(*(void *)a1 + 8 * v2) >> a2) & 1;
  }
}

uint64_t sub_244D19690(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a4 + 16))
  {
    sub_244D0B884(3, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/exponentiation.c", 614);
    return 0;
  }
  uint64_t v10 = a2;
  if (*(_DWORD *)(a2 + 16)
    || (int v12 = *(_DWORD *)(a4 + 8),
        (sub_244D170B4(*(uint64_t **)a2, *(int *)(a2 + 8), *(uint64_t **)a4, v12) & 0x80000000) == 0))
  {
    if (!sub_244D17F9C(a1, v10, a4, a5)) {
      return 0;
    }
    int v12 = *(_DWORD *)(a4 + 8);
    uint64_t v10 = a1;
  }
  if (v12 < 1 || (**(unsigned char **)a4 & 1) == 0)
  {
    *(void *)&v46[56] = 0;
    unsigned int v13 = sub_244D168EC((uint64_t *)a3);
    if (!v13)
    {
      uint64_t v5 = 1;
      if (sub_244D15DEC((void **)a1, 1uLL))
      {
        *(_DWORD *)(a1 + 16) = 0;
        **(void **)a1 = 1;
        *(_DWORD *)(a1 + 8) = 1;
        return v5;
      }
      return 0;
    }
    unsigned int v14 = v13;
    memset(v46, 0, 60);
    sub_244D1756C((void *)a5);
    uint64_t v15 = sub_244D17610(a5);
    uint64_t v16 = sub_244D17610(a5);
    uint64_t v5 = 0;
    int v47 = v16;
    if (v15)
    {
      uint64_t v17 = (uint64_t)v16;
      if (v16)
      {
        if (*(_DWORD *)(a4 + 16))
        {
          if (!sub_244D16764((void **)v15, a4)) {
            goto LABEL_73;
          }
          *((_DWORD *)v15 + 4) = 0;
          uint64_t v18 = (uint64_t *)v15;
        }
        else
        {
          uint64_t v18 = (uint64_t *)a4;
        }
        if (!sub_244D3AE14((uint64_t)v46, v18) || !sub_244D17F9C(v17, v10, a4, a5)) {
          goto LABEL_73;
        }
        uint64_t v19 = *(int *)(v17 + 8);
        if (v19)
        {
          uint64_t v20 = 0;
          unint64_t v21 = *(uint64_t **)v17;
          do
          {
            uint64_t v22 = *v21++;
            v20 |= v22;
            --v19;
          }
          while (v19);
          if (v20)
          {
            uint64_t v63 = 0;
            long long v61 = 0u;
            long long v62 = 0u;
            long long v59 = 0u;
            long long v60 = 0u;
            long long v57 = 0u;
            long long v58 = 0u;
            long long v55 = 0u;
            long long v56 = 0u;
            long long v53 = 0u;
            long long v54 = 0u;
            long long v51 = 0u;
            long long v52 = 0u;
            long long v49 = 0u;
            long long v50 = 0u;
            long long v48 = 0u;
            if (v14 > 0x29F)
            {
              unsigned int v23 = 6;
              goto LABEL_38;
            }
            if (v14 > 0xEF)
            {
              unsigned int v23 = 5;
              goto LABEL_38;
            }
            if (v14 > 0x4F)
            {
              unsigned int v23 = 4;
              goto LABEL_38;
            }
            if (v14 >= 0x18)
            {
              unsigned int v23 = 3;
LABEL_38:
              if (sub_244D3AE58(v15, v17, v17, (uint64_t)v46, a5))
              {
                uint64_t v24 = 0;
                while (1)
                {
                  uint64_t v25 = sub_244D17610(a5);
                  (&v47)[v24 + 1] = v25;
                  if (!v25 || !sub_244D3AE58(v25, (uint64_t)(&v47)[v24], (uint64_t)v15, (uint64_t)v46, a5)) {
                    break;
                  }
                  if ((v24++ + 2) >> (v23 - 1)) {
                    goto LABEL_45;
                  }
                }
              }
              goto LABEL_73;
            }
            unsigned int v23 = 1;
LABEL_45:
            if (sub_244D15DEC((void **)a1, 1uLL))
            {
              char v27 = 0;
              int v28 = v14 - 1;
              *(_DWORD *)(a1 + 16) = 0;
              **(void **)a1 = 1;
              char v45 = 1;
              *(_DWORD *)(a1 + 8) = 1;
              unsigned int v44 = v23;
              uint64_t v43 = v23;
              while (1)
              {
                unsigned int v29 = v28 - 1;
                int v30 = v28 + 1;
                while (1)
                {
                  unsigned int v31 = v28;
                  if ((v28 & 0x80000000) == 0)
                  {
                    unint64_t v32 = *(int *)(a3 + 8);
                    unint64_t v33 = (unint64_t)v31 >> 6;
                    if (v33 < v32 && ((*(void *)(*(void *)a3 + 8 * v33) >> v31) & 1) != 0) {
                      break;
                    }
                  }
                  if ((v27 & 1) != 0 && !sub_244D3AE58((unint64_t *)a1, a1, a1, (uint64_t)v46, a5)) {
                    goto LABEL_73;
                  }
                  int v28 = v31 - 1;
                  --v29;
                  --v30;
                  uint64_t v5 = 1;
                  if (!v31) {
                    goto LABEL_74;
                  }
                }
                if (v44 < 2)
                {
                  int v34 = 0;
                  int v36 = 1;
                }
                else
                {
                  int v34 = 0;
                  uint64_t v35 = 1;
                  int v36 = 1;
                  do
                  {
                    if (v30 == v35) {
                      break;
                    }
                    unint64_t v37 = (unint64_t)v29 >> 6;
                    if (v37 >= v32) {
                      LODWORD(v38) = 0;
                    }
                    else {
                      uint64_t v38 = (*(void *)(*(void *)a3 + 8 * v37) >> v29) & 1;
                    }
                    if (v38)
                    {
                      int v36 = (v36 << (v35 - v34)) | 1;
                      int v34 = v35;
                    }
                    ++v35;
                    --v29;
                  }
                  while (v43 != v35);
                }
                if (!(v45 & 1 | (v34 < 0))) {
                  break;
                }
LABEL_70:
                if (!sub_244D3AE58((unint64_t *)a1, a1, (uint64_t)(&v47)[v36 >> 1], (uint64_t)v46, a5))goto LABEL_73; {
                char v45 = 0;
                }
                int v40 = ~v34;
                char v27 = 1;
                uint64_t v5 = 1;
                int v28 = v31 + v40;
                if (v28 < 0) {
                  goto LABEL_74;
                }
              }
              int v39 = v34 + 1;
              while (sub_244D3AE58((unint64_t *)a1, a1, a1, (uint64_t)v46, a5))
              {
                if (!--v39) {
                  goto LABEL_70;
                }
              }
            }
LABEL_73:
            uint64_t v5 = 0;
            goto LABEL_74;
          }
        }
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 8) = 0;
        uint64_t v5 = 1;
      }
    }
LABEL_74:
    if (!*(unsigned char *)(a5 + 40))
    {
      uint64_t v41 = *(void *)(a5 + 8);
      uint64_t v42 = *(void *)(a5 + 16) - 1;
      *(void *)(a5 + 16) = v42;
      *(void *)(a5 + 32) = *(void *)(v41 + 8 * v42);
    }
    sub_244D166B0((void **)v46);
    sub_244D166B0((void **)&v46[24]);
    return v5;
  }

  return sub_244D19BB4(a1, v10, a3, a4, a5, 0);
}

uint64_t sub_244D19BB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(unsigned int *)(a4 + 8);
  if ((int)v6 < 1 || (unsigned int v8 = *(uint64_t **)a4, v9 = **(void **)a4, (v9 & 1) == 0))
  {
    int v10 = 104;
    __int16 v11 = 634;
LABEL_9:
    sub_244D0B884(3, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/exponentiation.c", v11);
    return 0;
  }
  if (*(_DWORD *)(a4 + 16))
  {
    int v10 = 109;
    __int16 v11 = 638;
    goto LABEL_9;
  }
  if (*(_DWORD *)(a2 + 16)
    || (sub_244D170B4(*(uint64_t **)a2, *(int *)(a2 + 8), *(uint64_t **)a4, *(unsigned int *)(a4 + 8)) & 0x80000000) == 0)
  {
    int v10 = 107;
    __int16 v11 = 643;
    goto LABEL_9;
  }
  unsigned int v19 = sub_244D168EC((uint64_t *)a3);
  if (!v19)
  {
    uint64_t v25 = v9 ^ 1;
    if (v6 >= 2)
    {
      uint64_t v26 = v6 - 1;
      char v27 = v8 + 1;
      do
      {
        uint64_t v28 = *v27++;
        v25 |= v28;
        --v26;
      }
      while (v26);
    }
    if (!v25)
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      return 1;
    }
    uint64_t v17 = 1;
    if (sub_244D15DEC((void **)a1, 1uLL))
    {
      *(_DWORD *)(a1 + 16) = 0;
      **(void **)a1 = 1;
      *(_DWORD *)(a1 + 8) = 1;
      return v17;
    }
    return 0;
  }
  unsigned int v20 = v19;
  uint64_t v69 = 0;
  long long v68 = 0u;
  long long v67 = 0u;
  long long v66 = 0u;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  long long v55 = 0u;
  long long v54 = 0u;
  sub_244D1756C((void *)a5);
  unint64_t v21 = sub_244D17610(a5);
  uint64_t v22 = sub_244D17610(a5);
  unsigned int v23 = 0;
  uint64_t v17 = 0;
  long long v53 = v22;
  if (v21 && v22)
  {
    if (a6)
    {
      uint64_t v24 = 0;
LABEL_25:
      long long v52 = v24;
      if (v20 <= 0x29F)
      {
        if (v20 <= 0xEF)
        {
          if (v20 <= 0x4F)
          {
            if (v20 <= 0x17) {
              unsigned int v29 = 1;
            }
            else {
              unsigned int v29 = 3;
            }
          }
          else
          {
            unsigned int v29 = 4;
          }
        }
        else
        {
          unsigned int v29 = 5;
        }
      }
      else
      {
        unsigned int v29 = 6;
      }
      if (!sub_244D1A118((uint64_t)v22, a2, a6, a6, a5))
      {
LABEL_75:
        uint64_t v17 = 0;
LABEL_77:
        unsigned int v23 = v52;
        goto LABEL_78;
      }
      unsigned int v51 = v29;
      if (v29 >= 2)
      {
        int v30 = sub_244D17610(a5);
        if (v30)
        {
          uint64_t v31 = (uint64_t)v30;
          if (sub_244D1A118((uint64_t)v30, (uint64_t)v22, (uint64_t)v22, a6, a5))
          {
            uint64_t v32 = 0;
            char v33 = v29 - 1;
            while (1)
            {
              int v34 = sub_244D17610(a5);
              (&v53)[v32 + 1] = v34;
              if (!v34 || !sub_244D1A118((uint64_t)v34, (uint64_t)(&v53)[v32], v31, a6, a5)) {
                break;
              }
              if ((v32++ + 2) >> v33) {
                goto LABEL_43;
              }
            }
          }
        }
        goto LABEL_75;
      }
LABEL_43:
      char v36 = 0;
      unsigned int v37 = v20 - 1;
      unsigned int v38 = v51;
      while (1)
      {
        unint64_t v39 = v37;
        unsigned int v40 = v37 - 1;
        if ((v37 & 0x80000000) != 0) {
          goto LABEL_47;
        }
LABEL_45:
        unint64_t v41 = *(int *)(a3 + 8);
        if (v39 >> 6 >= v41 || ((*(void *)(*(void *)a3 + 8 * (v39 >> 6)) >> v39) & 1) == 0)
        {
LABEL_47:
          while ((v36 & 1) == 0 || sub_244D1A118((uint64_t)v21, (uint64_t)v21, (uint64_t)v21, a6, a5))
          {
            if (!v39) {
              goto LABEL_76;
            }
            --v39;
            --v40;
            if ((v39 & 0x80000000) == 0) {
              goto LABEL_45;
            }
          }
          goto LABEL_75;
        }
        if (v38 < 2 || !v39) {
          break;
        }
        int v42 = 0;
        uint64_t v43 = 1;
        int v44 = 1;
        do
        {
          if ((v40 & 0x80000000) != 0 || (unint64_t v45 = (unint64_t)v40 >> 6, v45 >= v41)) {
            LODWORD(v46) = 0;
          }
          else {
            uint64_t v46 = (*(void *)(*(void *)a3 + 8 * v45) >> v40) & 1;
          }
          if (v46)
          {
            int v44 = (v44 << (v43 - v42)) | 1;
            int v42 = v43;
          }
          if (v43 + 1 >= (unint64_t)v51) {
            break;
          }
          --v40;
        }
        while (v43++ < (int)v39);
        if ((v36 & 1) == 0) {
          goto LABEL_72;
        }
        if ((v42 & 0x80000000) == 0) {
          goto LABEL_67;
        }
LABEL_70:
        if (!sub_244D1A118((uint64_t)v21, (uint64_t)v21, (uint64_t)(&v53)[v44 >> 1], a6, a5)) {
          goto LABEL_75;
        }
LABEL_73:
        unsigned int v38 = v51;
        if (v39 == v42)
        {
LABEL_76:
          uint64_t v17 = (uint64_t)sub_244D1A1FC(a1, (uint64_t)v21, a6, a5);
          goto LABEL_77;
        }
        unsigned int v37 = v39 + ~v42;
        char v36 = 1;
      }
      int v42 = 0;
      int v44 = 1;
      if (v36)
      {
LABEL_67:
        int v48 = -1;
        while (sub_244D1A118((uint64_t)v21, (uint64_t)v21, (uint64_t)v21, a6, a5))
        {
          if (v42 == ++v48) {
            goto LABEL_70;
          }
        }
        goto LABEL_75;
      }
LABEL_72:
      if (!sub_244D16764((void **)v21, (uint64_t)(&v53)[v44 >> 1])) {
        goto LABEL_75;
      }
      goto LABEL_73;
    }
    unsigned int v23 = sub_244D1A0A4(a4, a5);
    a6 = (uint64_t)v23;
    uint64_t v24 = v23;
    if (v23) {
      goto LABEL_25;
    }
    uint64_t v17 = 0;
  }
LABEL_78:
  sub_244D1A288(v23);
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v49 = *(void *)(a5 + 8);
    uint64_t v50 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v50;
    *(void *)(a5 + 32) = *(void *)(v49 + 8 * v50);
  }
  return v17;
}

void **sub_244D1A0A4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_244D1DF88();
  uint64_t v5 = (void **)v4;
  if (!v4 || !sub_244D1E0E8((uint64_t)v4, a1) || !sub_244D1E34C((uint64_t)v5, a2))
  {
    sub_244D1A288(v5);
    return 0;
  }
  return v5;
}

uint64_t sub_244D1A10C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_244D1A118(a1, a2, a3, a3, a4);
}

uint64_t sub_244D1A118(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a2 + 16) || *(_DWORD *)(a3 + 16))
  {
    sub_244D0B884(3, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/montgomery.c", 421);
    return 0;
  }
  sub_244D1756C((void *)a5);
  uint64_t result = (uint64_t)sub_244D17610(a5);
  if (result)
  {
    uint64_t v11 = result;
    if (a2 != a3)
    {
      uint64_t result = sub_244D1C868(result, a2, a3, a5);
      if (!result) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
    uint64_t result = sub_244D1EE78(result, a2, a5);
    if (result) {
LABEL_8:
    }
      uint64_t result = sub_244D1E4C0(a1, v11, a4);
  }
LABEL_9:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v12 = *(void *)(a5 + 8);
    uint64_t v13 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v13;
    *(void *)(a5 + 32) = *(void *)(v12 + 8 * v13);
  }
  return result;
}

void **sub_244D1A1FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_244D1756C((void *)a4);
  uint64_t result = (void **)sub_244D17610(a4);
  if (result)
  {
    uint64_t v9 = (uint64_t)result;
    uint64_t result = sub_244D16764(result, a2);
    if (result) {
      uint64_t result = (void **)sub_244D1E4C0(a1, v9, a3);
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v10 = *(void *)(a4 + 8);
    uint64_t v11 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v11;
    *(void *)(a4 + 32) = *(void *)(v10 + 8 * v11);
  }
  return result;
}

void sub_244D1A288(void **a1)
{
  if (a1)
  {
    sub_244D166B0(a1);
    sub_244D166B0(a1 + 3);
    sub_244D440EC(a1);
  }
}

void sub_244D1A2D0(unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  v35[144] = *MEMORY[0x263EF8340];
  if (a5 >> 58 || a3 > 9 || *(_DWORD *)(a6 + 32) != a3) {
    abort();
  }
  uint64_t v10 = -64 * a5;
  while (a5)
  {
    unint64_t v11 = a5 - 1;
    unint64_t v12 = *(void *)(a4 - 8 + 8 * a5);
    v10 += 64;
    --a5;
    if (v12)
    {
      uint64_t v13 = sub_244D16874(v12);
      unint64_t v14 = v13 - v10;
      if ((unint64_t)(v13 - v10) <= 0x29F)
      {
        if (v14 <= 0xEF)
        {
          if (v14 <= 0x17) {
            int v17 = 1;
          }
          else {
            int v17 = 3;
          }
          if (v14 <= 0x4F) {
            LODWORD(v15) = v17;
          }
          else {
            LODWORD(v15) = 4;
          }
        }
        else
        {
          LODWORD(v15) = 5;
        }
      }
      else
      {
        LODWORD(v15) = 6;
      }
      if (v15 >= 5) {
        uint64_t v15 = 5;
      }
      else {
        uint64_t v15 = v15;
      }
      unint64_t v33 = v15;
      if (8 * a3) {
        __memcpy_chk();
      }
      __uint64_t n = 8 * a3;
      if (v33 >= 2)
      {
        uint64_t v31 = v13;
        sub_244D1A72C(v34, v35, v35, a3, a6);
        unsigned int v18 = 2;
        do
          sub_244D1A72C(&v35[9 * v18 - 9], &v35[9 * v18 - 18], v34, a3, a6);
        while (!(v18++ >> (v33 - 1)));
        uint64_t v13 = v31;
      }
      char v20 = 0;
      unint64_t v21 = v11 + 1;
      unint64_t v22 = ~v10 + v13;
      while (1)
      {
        unint64_t v23 = v22 - 1;
        for (unint64_t i = v22; i >> 6 >= v21 || ((*(void *)(a4 + 8 * (i >> 6)) >> i) & 1) == 0; --i)
        {
          if (v20) {
            sub_244D1A72C(a1, a1, a1, a3, a6);
          }
          if (!i) {
            goto LABEL_57;
          }
          --v23;
        }
        if (v33 < 2 || !i) {
          break;
        }
        int v25 = 0;
        unint64_t v26 = 1;
        unsigned int v27 = 1;
        do
        {
          if (v23 >> 6 >= v21) {
            LODWORD(v28) = 0;
          }
          else {
            uint64_t v28 = (*(void *)(a4 + 8 * (v23 >> 6)) >> v23) & 1;
          }
          if (v28)
          {
            unsigned int v27 = (v27 << (v26 - v25)) | 1;
            int v25 = v26;
          }
          if (v26 + 1 >= v33) {
            break;
          }
          --v23;
        }
        while (i > v26++);
        if ((v20 & 1) == 0)
        {
LABEL_54:
          if (__n) {
            memcpy(a1, &v35[9 * (v27 >> 1)], __n);
          }
          goto LABEL_56;
        }
        if (v25 != -1) {
          goto LABEL_51;
        }
LABEL_53:
        sub_244D1A72C(a1, a1, &v35[9 * (v27 >> 1)], a3, a6);
LABEL_56:
        unint64_t v22 = i - (v25 + 1);
        char v20 = 1;
        if (i == v25)
        {
LABEL_57:
          sub_244D4413C(v35, 0x480uLL);
          return;
        }
      }
      int v25 = 0;
      unsigned int v27 = 1;
      if ((v20 & 1) == 0) {
        goto LABEL_54;
      }
LABEL_51:
      for (int j = -1; j != v25; ++j)
        sub_244D1A72C(a1, a1, a1, a3, a6);
      goto LABEL_53;
    }
  }
  uint64_t v16 = *(void *)a6;

  sub_244D1A64C(a1, a3, v16, a3, a6);
}

void sub_244D1A64C(unint64_t *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a2 > 9) {
    goto LABEL_11;
  }
  unint64_t v7 = 2 * a2;
  if (*(_DWORD *)(a5 + 32) != a2 || v7 < a4) {
    goto LABEL_11;
  }
  memset(v10, 0, sizeof(v10));
  if (a4) {
    __memcpy_chk();
  }
  if (!sub_244D1E5EC(a1, a2, (unint64_t *)v10, v7, a5)) {
LABEL_11:
  }
    abort();
  sub_244D4413C(v10, 16 * a2);
}

void sub_244D1A72C(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t a4, uint64_t a5)
{
  v11[18] = *MEMORY[0x263EF8340];
  if (a4 > 9 || *(_DWORD *)(a5 + 32) != a4) {
    goto LABEL_8;
  }
  uint64_t v10 = 2 * a4;
  if (a2 == a3) {
    sub_244D1E6E4(v11, v10, a2, a4);
  }
  else {
    sub_244D1E7F4(v11, v10, a2, a4, a3, a4);
  }
  if (!sub_244D1E5EC(a1, a4, v11, 2 * a4, a5)) {
LABEL_8:
  }
    abort();
  sub_244D4413C(v11, 16 * a4);
}

uint64_t sub_244D1A800(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a3 >> 6 >= a2) {
    return 0;
  }
  else {
    return (*(void *)(a1 + 8 * (a3 >> 6)) >> a3) & 1;
  }
}

void sub_244D1A824(unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v14[8] = *MEMORY[0x263EF8340];
  if (a3 > 9 || *(_DWORD *)(a4 + 32) != a3) {
    abort();
  }
  if (a3)
  {
    __memcpy_chk();
    unint64_t v8 = v13;
    v13 -= 2;
    if (v8 <= 1 && a3 != 1)
    {
      unint64_t v9 = a3 - 2;
      uint64_t v10 = v14;
      do
      {
        unint64_t v11 = v9;
        if ((*v10++)-- != 0) {
          break;
        }
        --v9;
      }
      while (v11);
    }
  }
  sub_244D1A2D0(a1, a2, a3, (uint64_t)&v13, a3, a4);
}

uint64_t sub_244D1A91C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(unsigned int *)(a4 + 8);
  if ((int)v6 < 1 || (unint64_t v8 = *(uint64_t **)a4, v9 = **(void **)a4, (v9 & 1) == 0))
  {
    int v10 = 104;
    __int16 v11 = 938;
LABEL_9:
    sub_244D0B884(3, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/exponentiation.c", v11);
    return 0;
  }
  if (*(_DWORD *)(a4 + 16))
  {
    int v10 = 109;
    __int16 v11 = 942;
    goto LABEL_9;
  }
  if (*(_DWORD *)(a2 + 16)
    || (int)sub_244D170B4(*(uint64_t **)a2, *(int *)(a2 + 8), *(uint64_t **)a4, *(unsigned int *)(a4 + 8)) >= 0)
  {
    int v10 = 107;
    __int16 v11 = 948;
    goto LABEL_9;
  }
  int v19 = *(_DWORD *)(a3 + 8);
  if (!v19)
  {
    uint64_t v21 = v9 ^ 1;
    if (v6 >= 2)
    {
      uint64_t v22 = v6 - 1;
      unint64_t v23 = v8 + 1;
      do
      {
        uint64_t v24 = *v23++;
        v21 |= v24;
        --v22;
      }
      while (v22);
    }
    if (!v21)
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      return 1;
    }
    uint64_t v17 = 1;
    if (sub_244D15DEC((void **)a1, 1uLL))
    {
      *(_DWORD *)(a1 + 16) = 0;
      **(void **)a1 = 1;
      *(_DWORD *)(a1 + 8) = 1;
      return v17;
    }
    return 0;
  }
  if (a6)
  {
    char v20 = 0;
    goto LABEL_22;
  }
  int v25 = sub_244D1A0A4(a4, a5);
  a6 = (uint64_t)v25;
  char v20 = v25;
  if (v25)
  {
LABEL_22:
    int v48 = v20;
    int v26 = *(_DWORD *)(a6 + 32);
    if (v19 == 1) {
      int v27 = 3;
    }
    else {
      int v27 = 1;
    }
    if (v19 <= 1) {
      int v28 = v27;
    }
    else {
      int v28 = 4;
    }
    if (v19 <= 4) {
      int v29 = v28;
    }
    else {
      int v29 = 5;
    }
    if (v19 > 14) {
      int v29 = 6;
    }
    signed int v50 = v29;
    unsigned int v30 = 1 << v29;
    uint64_t v49 = 8 * *(int *)(a6 + 32) * (uint64_t)((1 << v29) + 2);
    uint64_t v31 = sub_244D43FF4(v49 + 64);
    uint64_t v32 = v31;
    if (v31)
    {
      uint64_t v47 = -(int)v31 & 0x3FLL;
      unint64_t v33 = (char *)v31 + v47;
      __dst = (char *)v31 + v47;
      if (v26)
      {
        bzero(__dst, v49);
        unint64_t v33 = __dst;
      }
      long long v56 = &v33[8 * (v26 << v50)];
      long long v52 = &v56[8 * v26];
      int v53 = 0;
      int v54 = v26;
      int v57 = 0;
      int v58 = v26;
      uint64_t v55 = 0x200000000;
      uint64_t v59 = 0x200000000;
      if (sub_244D1AE1C((uint64_t)&v56, a6, a5)
        && sub_244D16BB4((uint64_t)&v56, v26)
        && sub_244D1A118((uint64_t)&v52, a2, a6, a6, a5)
        && sub_244D16BB4((uint64_t)&v52, v26))
      {
        sub_244D16A84(__dst, v26, (uint64_t)&v56);
        sub_244D16A84(&__dst[8 * v26], v26, (uint64_t)&v52);
        if (v50 < 2)
        {
LABEL_48:
          int v37 = (v19 << 6) - 1;
          int v38 = 0;
          int v39 = v37 % v50;
          if (((v37 % v50) & 0x80000000) == 0)
          {
            int v40 = v39 + 1;
            do
            {
              if (v37 < 0 || (unint64_t v41 = (unint64_t)v37 >> 6, v41 >= *(int *)(a3 + 8))) {
                LODWORD(v42) = 0;
              }
              else {
                uint64_t v42 = (*(void *)(*(void *)a3 + 8 * v41) >> v37) & 1;
              }
              int v38 = v42 | (2 * v38);
              --v37;
              --v40;
            }
            while (v40 > 0);
            int v37 = (v19 << 6) - 2 - v39;
          }
          if (sub_244D1AEE8((uint64_t)&v56, v26, (uint64_t)__dst, v38, v50))
          {
LABEL_57:
            if (v37 < 0)
            {
              uint64_t v17 = (uint64_t)sub_244D1A1FC(a1, (uint64_t)&v56, a6, a5);
              goto LABEL_69;
            }
            int v43 = 0;
            int v44 = 0;
            while (sub_244D1A118((uint64_t)&v56, (uint64_t)&v56, (uint64_t)&v56, a6, a5))
            {
              unint64_t v45 = (v37 + v43);
              if ((v45 & 0x80000000) != 0 || v45 >> 6 >= *(int *)(a3 + 8)) {
                LODWORD(v46) = 0;
              }
              else {
                uint64_t v46 = (*(void *)(*(void *)a3 + 8 * ((unint64_t)(v37 + v43) >> 6)) >> (v37 + v43)) & 1;
              }
              int v44 = v46 | (2 * v44);
              --v43;
              if (!(v50 + v43))
              {
                if (sub_244D1AEE8((uint64_t)&v52, v26, (uint64_t)__dst, v44, v50))
                {
                  v37 -= v50;
                  if (sub_244D1A118((uint64_t)&v56, (uint64_t)&v56, (uint64_t)&v52, a6, a5)) {
                    goto LABEL_57;
                  }
                }
                break;
              }
            }
          }
        }
        else if (sub_244D1A118((uint64_t)&v56, (uint64_t)&v52, (uint64_t)&v52, a6, a5))
        {
          sub_244D16A84(&__dst[16 * v26], v26, (uint64_t)&v56);
          if (v30 <= 4) {
            uint64_t v34 = 4;
          }
          else {
            uint64_t v34 = v30;
          }
          uint64_t v35 = (char *)&v32[3 * v26] + v47;
          uint64_t v36 = v34 - 3;
          while (sub_244D1A118((uint64_t)&v56, (uint64_t)&v52, (uint64_t)&v56, a6, a5))
          {
            sub_244D16A84(v35, v26, (uint64_t)&v56);
            v35 += 8 * v26;
            if (!--v36) {
              goto LABEL_48;
            }
          }
        }
      }
      uint64_t v17 = 0;
    }
    else
    {
      uint64_t v17 = 0;
      __dst = 0;
    }
LABEL_69:
    int v25 = v48;
    goto LABEL_70;
  }
  uint64_t v17 = 0;
  uint64_t v32 = 0;
  uint64_t v49 = 0;
  __dst = 0;
LABEL_70:
  sub_244D1A288(v25);
  if (!v32 && __dst) {
    sub_244D4413C(__dst, v49);
  }
  sub_244D440EC(v32);
  return v17;
}

uint64_t sub_244D1AE1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if ((int)v5 >= 1 && (*(void *)(*(void *)(a2 + 24) + 8 * (v5 - 1)) & 0x8000000000000000) != 0)
  {
    uint64_t result = sub_244D15DEC((void **)a1, v5);
    if (result)
    {
      **(void **)a1 = -**(void **)(a2 + 24);
      LODWORD(v7) = *(_DWORD *)(a2 + 32);
      if ((int)v7 >= 2)
      {
        uint64_t v8 = 1;
        do
        {
          *(void *)(*(void *)a1 + 8 * v8) = ~*(void *)(*(void *)(a2 + 24) + 8 * v8);
          ++v8;
          uint64_t v7 = *(int *)(a2 + 32);
        }
        while (v8 < v7);
      }
      *(_DWORD *)(a1 + 8) = v7;
      *(_DWORD *)(a1 + 16) = 0;
      return 1;
    }
  }
  else
  {
    return (uint64_t)sub_244D1A1FC(a1, a2, a2, a3);
  }
  return result;
}

uint64_t sub_244D1AEE8(uint64_t a1, int a2, uint64_t a3, int a4, char a5)
{
  uint64_t v10 = a2;
  uint64_t result = sub_244D15DEC((void **)a1, a2);
  if (result)
  {
    size_t v12 = 8 * v10;
    if (a2) {
      bzero(*(void **)a1, v12);
    }
    unsigned int v13 = 0;
    do
    {
      if (a2 >= 1)
      {
        uint64_t v14 = 0;
        do
        {
          *(void *)(*(void *)a1 + v14) |= *(void *)(a3 + v14) & ((((int)(v13 ^ a4) - 1) & ~(uint64_t)(int)(v13 ^ a4)) >> 63);
          v14 += 8;
        }
        while (8 * a2 != v14);
      }
      ++v13;
      a3 += v12;
    }
    while (!(v13 >> a5));
    *(_DWORD *)(a1 + 8) = a2;
    return 1;
  }
  return result;
}

uint64_t sub_244D1AFB4(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v10 = a2;
  int v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v12 = *(unsigned int *)(a4 + 8);
  uint64_t v13 = 8 * v12 - 8;
  do
  {
    BOOL v14 = __OFSUB__(v12, 1);
    LODWORD(v12) = v12 - 1;
    if ((int)v12 < 0 != v14) {
      goto LABEL_5;
    }
    uint64_t v15 = *(void *)(*(void *)a4 + v13);
    v13 -= 8;
  }
  while (!v15);
  if (!v12)
  {
    unint64_t v10 = a2 % **(void **)a4;
    if (v10) {
      goto LABEL_6;
    }
LABEL_10:
    int v16 = 0;
    goto LABEL_11;
  }
LABEL_5:
  if (!a2) {
    goto LABEL_10;
  }
LABEL_6:
  if (!sub_244D15DEC(&v19, 1uLL))
  {
    sub_244D0B884(3, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/exponentiation.c", 1271);
    uint64_t v17 = 0;
    goto LABEL_12;
  }
  LODWORD(v21) = 0;
  *int v19 = v10;
  int v16 = 1;
LABEL_11:
  LODWORD(v20) = v16;
  uint64_t v17 = sub_244D19BB4(a1, (uint64_t)&v19, a3, a4, a5, a6);
LABEL_12:
  sub_244D166B0(&v19);
  return v17;
}

uint64_t sub_244D1B0C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void **a8)
{
  uint64_t v8 = a8;
  int v16 = 0;
  memset(v19, 0, sizeof(v19));
  if ((a8 || (uint64_t v8 = sub_244D1B1E0(a6, a7), (v16 = v8) != 0))
    && sub_244D19BB4(a1, a2, a3, a6, a7, (uint64_t)v8)
    && sub_244D19BB4((uint64_t)v19, a4, a5, a6, a7, (uint64_t)v8)
    && sub_244D1A118(a1, a1, (uint64_t)v8, (uint64_t)v8, a7))
  {
    uint64_t v17 = sub_244D1A118(a1, a1, (uint64_t)v19, (uint64_t)v8, a7);
  }
  else
  {
    uint64_t v17 = 0;
  }
  sub_244D1A288(v16);
  sub_244D166B0(v19);
  return v17;
}

void **sub_244D1B1E0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_244D1DF88();
  unint64_t v5 = (void **)v4;
  if (!v4 || !sub_244D1E024(v4, a1, a2))
  {
    sub_244D1A288(v5);
    return 0;
  }
  return v5;
}

uint64_t sub_244D1B23C(void **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a2 = 0;
  if (*(int *)(a4 + 8) < 1 || (**(unsigned char **)a4 & 1) == 0)
  {
    int v6 = 104;
    __int16 v7 = 121;
LABEL_7:
    sub_244D0B884(3, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/gcd.c", v7);
    return 0;
  }
  if (*(_DWORD *)(a3 + 16) || (sub_244D17194(a3, a4) & 0x80000000) == 0)
  {
    int v6 = 107;
    __int16 v7 = 126;
    goto LABEL_7;
  }
  sub_244D1756C((void *)a5);
  uint64_t v13 = sub_244D17610(a5);
  BOOL v14 = sub_244D17610(a5);
  uint64_t v15 = sub_244D17610(a5);
  uint64_t result = (uint64_t)sub_244D17610(a5);
  if (result)
  {
    uint64_t v16 = result;
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 8) = 0;
    uint64_t result = sub_244D15DEC((void **)v15, 1uLL);
    if (result)
    {
      *((_DWORD *)v15 + 4) = 0;
      *(void *)*uint64_t v15 = 1;
      *((_DWORD *)v15 + 2) = 1;
      uint64_t result = (uint64_t)sub_244D16764((void **)v14, a3);
      if (result)
      {
        uint64_t result = (uint64_t)sub_244D16764((void **)v13, a4);
        if (result)
        {
          *((_DWORD *)v13 + 4) = 0;
          while (1)
          {
            LODWORD(v17) = *((_DWORD *)v14 + 2);
            if (!v17) {
              break;
            }
            uint64_t v18 = 0;
            uint64_t v17 = (int)v17;
            int v19 = (uint64_t *)*v14;
            do
            {
              uint64_t v20 = *v19++;
              v18 |= v20;
              --v17;
            }
            while (v17);
            if (!v18) {
              break;
            }
            unint64_t v21 = 0;
            while (v21 >> 6 >= *((int *)v14 + 2) || ((*(void *)(*v14 + 8 * (v21 >> 6)) >> v21) & 1) == 0)
            {
              if (*((int *)v15 + 2) < 1
                || (*(unsigned char *)*v15 & 1) == 0
                || (uint64_t result = sub_244D15CD0((uint64_t)v15, (uint64_t)v15, a4), result))
              {
                uint64_t result = sub_244D1B5D8((uint64_t)v15, (uint64_t *)v15);
                ++v21;
                if (result) {
                  continue;
                }
              }
              goto LABEL_53;
            }
            if (!v21 || (uint64_t result = sub_244D17ED0((void **)v14, (uint64_t)v14, v21), result))
            {
              unint64_t v22 = 0;
              while (1)
              {
                unint64_t v23 = *((int *)v13 + 2);
                if (v22 >> 6 < v23)
                {
                  uint64_t v24 = (uint64_t *)*v13;
                  if ((*(void *)(*v13 + 8 * (v22 >> 6)) >> v22)) {
                    break;
                  }
                }
                if (*(int *)(v16 + 8) < 1
                  || (**(unsigned char **)v16 & 1) == 0
                  || (uint64_t result = sub_244D15CD0(v16, v16, a4), result))
                {
                  int v25 = sub_244D1B5D8(v16, (uint64_t *)v16);
                  uint64_t result = 0;
                  ++v22;
                  if (v25) {
                    continue;
                  }
                }
                goto LABEL_53;
              }
              if (v22)
              {
                uint64_t result = sub_244D17ED0((void **)v13, (uint64_t)v13, v22);
                if (!result) {
                  goto LABEL_53;
                }
                uint64_t v24 = (uint64_t *)*v13;
                unint64_t v23 = *((int *)v13 + 2);
              }
              if ((sub_244D170B4((uint64_t *)*v14, *((int *)v14 + 2), v24, v23) & 0x80000000) != 0)
              {
                uint64_t result = sub_244D15CD0(v16, v16, (uint64_t)v15);
                if (!result) {
                  goto LABEL_53;
                }
                uint64_t v26 = (uint64_t)v13;
                uint64_t v27 = (uint64_t)v13;
                uint64_t v28 = (uint64_t)v14;
              }
              else
              {
                uint64_t result = sub_244D15CD0((uint64_t)v15, (uint64_t)v15, v16);
                if (!result) {
                  goto LABEL_53;
                }
                uint64_t v26 = (uint64_t)v14;
                uint64_t v27 = (uint64_t)v14;
                uint64_t v28 = (uint64_t)v13;
              }
              uint64_t result = sub_244D15C60(v26, v27, v28);
              if (result) {
                continue;
              }
            }
            goto LABEL_53;
          }
          if (sub_244D172C8((unsigned int *)v13))
          {
            uint64_t result = sub_244D16310(v16, a4, v16);
            if (result)
            {
              if (!*(_DWORD *)(v16 + 16)
                && (sub_244D170B4(*(uint64_t **)v16, *(int *)(v16 + 8), *(uint64_t **)a4, *(int *)(a4 + 8)) & 0x80000000) != 0
                || (uint64_t result = sub_244D17F9C(v16, v16, a4, a5), result))
              {
                uint64_t result = sub_244D16764(a1, v16) != 0;
              }
            }
          }
          else
          {
            *a2 = 1;
            sub_244D0B884(3, 0, 112, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/gcd.c", 248);
            uint64_t result = 0;
          }
        }
      }
    }
  }
LABEL_53:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v29 = *(void *)(a5 + 8);
    uint64_t v30 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v30;
    *(void *)(a5 + 32) = *(void *)(v29 + 8 * v30);
  }
  return result;
}

uint64_t sub_244D1B5D8(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244D15DEC((void **)a1, *((int *)a2 + 2));
  if (result)
  {
    uint64_t v5 = *((int *)a2 + 2);
    if (v5)
    {
      int v6 = *(void **)a1;
      uint64_t v7 = *a2;
      uint64_t v8 = v5 - 1;
      if (v8)
      {
        uint64_t v9 = v7 + 8;
        uint64_t v10 = v8;
        __int16 v11 = *(void **)a1;
        do
        {
          *v11++ = *(long long *)(v9 - 8) >> 1;
          v9 += 8;
          --v10;
        }
        while (v10);
      }
      v6[v8] = *(void *)(v7 + 8 * v8) >> 1;
      int v12 = *((_DWORD *)a2 + 2);
    }
    else
    {
      int v12 = 0;
    }
    *(_DWORD *)(a1 + 8) = v12;
    *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
    uint64_t v13 = 8 * v12 - 8;
    int v14 = v12;
    while (1)
    {
      BOOL v15 = __OFSUB__(v14--, 1);
      if (v14 < 0 != v15) {
        break;
      }
      uint64_t v16 = *(void *)(*(void *)a1 + v13);
      v13 -= 8;
      if (v16)
      {
        *(_DWORD *)(a1 + 8) = v14 + 1;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 8) = v12 & (v12 >> 31);
    if ((v12 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 16) = 0;
    }
    return 1;
  }
  return result;
}

void **sub_244D1B6AC(void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v7 = a1;
    uint64_t v8 = 0;
LABEL_4:
    if (!*(_DWORD *)(a2 + 16)
      && (int v9 = *(_DWORD *)(a3 + 8),
          (sub_244D170B4(*(uint64_t **)a2, *(int *)(a2 + 8), *(uint64_t **)a3, v9) & 0x80000000) != 0))
    {
      __int16 v11 = 0;
    }
    else
    {
      uint64_t v10 = sub_244D16714(a2);
      if (!v10)
      {
        __int16 v11 = 0;
        goto LABEL_15;
      }
      a2 = (uint64_t)v10;
      if (!sub_244D17F9C((uint64_t)v10, (uint64_t)v10, a3, a4))
      {
        __int16 v11 = (void **)a2;
        goto LABEL_15;
      }
      int v9 = *(_DWORD *)(a3 + 8);
      __int16 v11 = (void **)a2;
    }
    if (v9 >= 1 && (**(unsigned char **)a3 & 1) != 0)
    {
      if (sub_244D1B23C(v7, &v13, a2, a3, a4)) {
        goto LABEL_16;
      }
    }
    else if (sub_244D1B7E4((uint64_t)v7, &v13, a2, a3, a4))
    {
LABEL_16:
      sub_244D166B0(v11);
      return v7;
    }
LABEL_15:
    sub_244D166B0((void **)v8);
    uint64_t v7 = 0;
    goto LABEL_16;
  }
  uint64_t v7 = (void **)sub_244D16670();
  uint64_t v8 = v7;
  if (v7) {
    goto LABEL_4;
  }
  return v7;
}

uint64_t sub_244D1B7E4(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a2 = 0;
  if (*(_DWORD *)(a3 + 16)
    || (uint64_t v10 = *(uint64_t **)a3,
        unint64_t v11 = *(int *)(a3 + 8),
        int v12 = *(uint64_t **)a4,
        unint64_t v13 = *(int *)(a4 + 8),
        (sub_244D170B4(*(uint64_t **)a3, v11, *(uint64_t **)a4, v13) & 0x80000000) == 0))
  {
    int v14 = 107;
    __int16 v15 = 174;
LABEL_4:
    sub_244D0B884(3, 0, v14, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/gcd_extra.c", v15);
    return 0;
  }
  if (!v11) {
    goto LABEL_89;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  do
    v18 |= v10[v17++];
  while (v11 != v17);
  if (!v18)
  {
LABEL_89:
    if (sub_244D172C8((unsigned int *)a4))
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      return 1;
    }
    *a2 = 1;
    int v14 = 112;
    __int16 v15 = 183;
    goto LABEL_4;
  }
  if (((int)v11 < 1 || (*(unsigned char *)v10 & 1) == 0) && ((int)v13 < 1 || (*(unsigned char *)v12 & 1) == 0))
  {
    *a2 = 1;
    int v14 = 112;
    __int16 v15 = 199;
    goto LABEL_4;
  }
  if (v11 >= v13) {
    int v19 = v13;
  }
  else {
    int v19 = v11;
  }
  sub_244D1756C((void *)a5);
  uint64_t v20 = sub_244D17610(a5);
  unint64_t v21 = sub_244D17610(a5);
  unint64_t v22 = sub_244D17610(a5);
  uint64_t v92 = sub_244D17610(a5);
  uint64_t v91 = sub_244D17610(a5);
  uint64_t v94 = sub_244D17610(a5);
  unint64_t v93 = sub_244D17610(a5);
  unint64_t v23 = sub_244D17610(a5);
  uint64_t result = 0;
  if (v20)
  {
    if (v21)
    {
      if (v22)
      {
        if (v92)
        {
          if (v91)
          {
            if (v94)
            {
              if (v93)
              {
                if (v23)
                {
                  char v90 = (unint64_t **)v23;
                  uint64_t result = (uint64_t)sub_244D16764((void **)v20, a3);
                  if (result)
                  {
                    uint64_t result = (uint64_t)sub_244D16764((void **)v21, a4);
                    if (result)
                    {
                      unsigned int v89 = (unint64_t **)v21;
                      uint64_t result = sub_244D15DEC((void **)v22, 1uLL);
                      if (result)
                      {
                        *((_DWORD *)v22 + 4) = 0;
                        *(void *)*unint64_t v22 = 1;
                        *((_DWORD *)v22 + 2) = 1;
                        uint64_t result = sub_244D15DEC((void **)v94, 1uLL);
                        if (result)
                        {
                          *((_DWORD *)v94 + 4) = 0;
                          *(void *)*uint64_t v94 = 1;
                          *((_DWORD *)v94 + 2) = 1;
                          uint64_t result = sub_244D16BB4((uint64_t)v20, v13);
                          if (result)
                          {
                            uint64_t result = sub_244D16BB4((uint64_t)v21, v13);
                            if (result)
                            {
                              uint64_t result = sub_244D16BB4((uint64_t)v22, v13);
                              if (result)
                              {
                                uint64_t result = sub_244D16BB4((uint64_t)v91, v13);
                                if (result)
                                {
                                  uint64_t result = sub_244D16BB4((uint64_t)v92, v19);
                                  if (result)
                                  {
                                    uint64_t result = sub_244D16BB4((uint64_t)v94, v19);
                                    if (result)
                                    {
                                      uint64_t result = sub_244D16BB4((uint64_t)v93, v13);
                                      if (result)
                                      {
                                        uint64_t result = sub_244D16BB4((uint64_t)v90, v13);
                                        if (result)
                                        {
                                          unint64_t v24 = (v19 + v13) << 6;
                                          if (v24 < (uint64_t)v19 << 6)
                                          {
                                            int v25 = 102;
                                            __int16 v26 = 248;
LABEL_83:
                                            sub_244D0B884(3, 0, v25, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/gcd_extra.c", v26);
                                            uint64_t result = 0;
                                            goto LABEL_85;
                                          }
                                          if (v19 + v13)
                                          {
                                            uint64_t v27 = 0;
                                            uint64_t v69 = v19 - 1;
                                            unint64_t v70 = v13 - 1;
                                            if (v24 <= 1) {
                                              unint64_t v24 = 1;
                                            }
                                            unint64_t v68 = v24;
                                            do
                                            {
                                              uint64_t v85 = ((uint64_t)(*(void *)*v20 << 63) >> 63) & -(uint64_t)(**v89 & 1);
                                              unint64_t v28 = sub_244D16544((unint64_t *)*v93, *v89, (unint64_t *)*v20, v13);
                                              uint64_t v29 = *v89;
                                              uint64_t v30 = (unint64_t *)*v93;
                                              uint64_t v81 = v27;
                                              uint64_t v82 = (v28 - 1) & v85;
                                              if (v13)
                                              {
                                                unint64_t v31 = v13;
                                                do
                                                {
                                                  unint64_t v32 = *v30++;
                                                  *uint64_t v29 = *v29 & ~((v28 - 1) & v85) | v32 & (v28 - 1) & v85;
                                                  ++v29;
                                                  --v31;
                                                }
                                                while (v31);
                                                uint64_t v30 = (unint64_t *)*v93;
                                                uint64_t v29 = *v89;
                                              }
                                              uint64_t v33 = -(uint64_t)v28;
                                              sub_244D16544(v30, (unint64_t *)*v20, v29, v13);
                                              uint64_t v34 = v85 & v33;
                                              uint64_t v35 = (unint64_t *)*v93;
                                              uint64_t v86 = v85 & v33;
                                              if (v13)
                                              {
                                                uint64_t v36 = (void *)*v20;
                                                unint64_t v37 = v13;
                                                do
                                                {
                                                  uint64_t v38 = *v35++;
                                                  *uint64_t v36 = *v36 & ~v34 | v38 & v34;
                                                  ++v36;
                                                  --v37;
                                                }
                                                while (v37);
                                                uint64_t v35 = (unint64_t *)*v93;
                                              }
                                              uint64_t v75 = sub_244D15EB4(v35, (uint64_t *)*v22, (uint64_t *)*v91, v13);
                                              unint64_t v39 = v75
                                                  - sub_244D16544(*v90, (unint64_t *)*v93, *(unint64_t **)a4, v13);
                                              int v40 = (unint64_t *)*v93;
                                              unint64_t v76 = v39;
                                              if (v13)
                                              {
                                                unint64_t v41 = *v90;
                                                unint64_t v42 = v13;
                                                do
                                                {
                                                  uint64_t v43 = *v41++;
                                                  *int v40 = v43 & ~v39 | *v40 & v39;
                                                  ++v40;
                                                  --v42;
                                                }
                                                while (v42);
                                                int v44 = (void *)*v22;
                                                unint64_t v45 = (unint64_t *)*v93;
                                                unint64_t v46 = v13;
                                                do
                                                {
                                                  uint64_t v47 = *v45++;
                                                  *int v44 = *v44 & ~v86 | v47 & v86;
                                                  ++v44;
                                                  --v46;
                                                }
                                                while (v46);
                                                int v48 = (uint64_t *)*v91;
                                                uint64_t v49 = (unint64_t *)*v93;
                                                unint64_t v50 = v13;
                                                unint64_t v51 = v19;
                                                do
                                                {
                                                  uint64_t v52 = *v49++;
                                                  *int v48 = *v48 & ~v82 | v52 & v82;
                                                  ++v48;
                                                  --v50;
                                                }
                                                while (v50);
                                                int v40 = (unint64_t *)*v93;
                                                int v53 = (uint64_t **)v94;
                                              }
                                              else
                                              {
                                                int v53 = (uint64_t **)v94;
                                                unint64_t v51 = v19;
                                              }
                                              sub_244D15EB4(v40, (uint64_t *)*v92, *v53, v51);
                                              sub_244D16544(*v90, (unint64_t *)*v93, *(unint64_t **)a3, v51);
                                              int v54 = (unint64_t *)*v93;
                                              if (v51)
                                              {
                                                uint64_t v55 = *v90;
                                                unint64_t v56 = v51;
                                                do
                                                {
                                                  uint64_t v57 = *v55++;
                                                  *int v54 = v57 & ~v76 | *v54 & v76;
                                                  ++v54;
                                                  --v56;
                                                }
                                                while (v56);
                                                int v58 = (uint64_t *)*v92;
                                                uint64_t v59 = (unint64_t *)*v93;
                                                unint64_t v60 = v51;
                                                do
                                                {
                                                  uint64_t v61 = *v59++;
                                                  *int v58 = *v58 & ~v86 | v61 & v86;
                                                  ++v58;
                                                  --v60;
                                                }
                                                while (v60);
                                                long long v62 = (void *)*v94;
                                                long long v63 = (unint64_t *)*v93;
                                                do
                                                {
                                                  uint64_t v64 = *v63++;
                                                  *long long v62 = *v62 & ~v82 | v64 & v82;
                                                  ++v62;
                                                  --v51;
                                                }
                                                while (v51);
                                                int v54 = (unint64_t *)*v93;
                                              }
                                              uint64_t v83 = (*(void *)*v20 & 1) - 1;
                                              unint64_t v87 = **v89;
                                              sub_244D1C9E0((uint64_t *)*v20, v83, (uint64_t *)v54, v13);
                                              uint64_t v77 = (-(*(void *)*v92 & 1) | -(*(void *)*v22 & 1)) & v83;
                                              int v72 = sub_244D1CA54((uint64_t *)*v22, v77, *(uint64_t **)a4, (uint64_t *)*v93, v13);
                                              int v78 = sub_244D1CA54((uint64_t *)*v92, v77, *(uint64_t **)a3, (uint64_t *)*v93, v19);
                                              uint64_t v71 = (void *)*v22;
                                              sub_244D1C9E0((uint64_t *)*v22, v83, (uint64_t *)*v93, v13);
                                              if (v13) {
                                                v71[v70] |= (unint64_t)(v72 & v83) << 63;
                                              }
                                              uint64_t v73 = (uint64_t *)*v92;
                                              sub_244D1C9E0((uint64_t *)*v92, v83, (uint64_t *)*v93, v19);
                                              if (v19) {
                                                v73[v69] |= (unint64_t)(v78 & v83) << 63;
                                              }
                                              uint64_t v88 = (v87 & 1) - 1;
                                              sub_244D1C9E0((uint64_t *)*v89, v88, (uint64_t *)*v93, v13);
                                              uint64_t v65 = (-(*(void *)*v94 & 1) | -(*(void *)*v91 & 1)) & v88;
                                              int v79 = sub_244D1CA54((uint64_t *)*v91, v65, *(uint64_t **)a4, (uint64_t *)*v93, v13);
                                              int v84 = sub_244D1CA54((uint64_t *)*v94, v65, *(uint64_t **)a3, (uint64_t *)*v93, v19);
                                              uint64_t v74 = (uint64_t *)*v91;
                                              sub_244D1C9E0((uint64_t *)*v91, v88, (uint64_t *)*v93, v13);
                                              if (v13) {
                                                v74[v70] |= (unint64_t)(v79 & v88) << 63;
                                              }
                                              uint64_t v80 = (void *)*v94;
                                              sub_244D1C9E0((uint64_t *)*v94, v88, (uint64_t *)*v93, v19);
                                              if (v19) {
                                                v80[v69] |= (unint64_t)(v84 & v88) << 63;
                                              }
                                              uint64_t v27 = v81 + 1;
                                            }
                                            while (v81 + 1 != v68);
                                          }
                                          if (!sub_244D172C8((unsigned int *)v20))
                                          {
                                            *a2 = 1;
                                            int v25 = 112;
                                            __int16 v26 = 322;
                                            goto LABEL_83;
                                          }
                                          uint64_t result = sub_244D16764((void **)a1, (uint64_t)v22) != 0;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_85:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v66 = *(void *)(a5 + 8);
    uint64_t v67 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v67;
    *(void *)(a5 + 32) = *(void *)(v66 + 8 * v67);
  }
  return result;
}

uint64_t sub_244D1C074(void **a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a2 = 0;
  if (*(_DWORD *)(a3 + 16) || (uint64_t v10 = a4 + 24, (int)sub_244D17194(a3, a4 + 24) >= 0))
  {
    sub_244D0B884(3, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/gcd.c", 334);
    return 0;
  }
  else
  {
    memset(v13, 0, sizeof(v13));
    if (sub_244D1C18C((uint64_t)v13, 1uLL, v10)
      && sub_244D1A118((uint64_t)a1, (uint64_t)v13, a3, a4, a5)
      && sub_244D1B23C(a1, a2, (uint64_t)a1, v10, a5))
    {
      uint64_t v11 = sub_244D1A118((uint64_t)a1, (uint64_t)v13, (uint64_t)a1, a4, a5);
    }
    else
    {
      uint64_t v11 = 0;
    }
    sub_244D166B0(v13);
  }
  return v11;
}

uint64_t sub_244D1C18C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = sub_244D15DEC((void **)a1, *(int *)(a3 + 8));
  if (result)
  {
    uint64_t result = sub_244D20A18(*(char **)a1, a2, *(unint64_t **)a3, *(int *)(a3 + 8), (uint64_t)&unk_244EB7094);
    if (result)
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 8);
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D1C1F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_244D1756C((void *)a4);
  uint64_t result = (uint64_t)sub_244D17610(a4);
  if (result)
  {
    uint64_t v11 = result;
    uint64_t result = (uint64_t)sub_244D16764((void **)result, a3);
    if (result)
    {
      uint64_t result = sub_244D1618C(v11, 2uLL);
      if (result) {
        uint64_t result = sub_244D19BB4(a1, a2, v11, a3, a4, a5) != 0;
      }
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v12 = *(void *)(a4 + 8);
    uint64_t v13 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v13;
    *(void *)(a4 + 32) = *(void *)(v12 + 8 * v13);
  }
  return result;
}

void **sub_244D1C2AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_244D1756C((void *)a4);
  uint64_t result = (void **)sub_244D17610(a4);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    uint64_t result = sub_244D16764(result, a3);
    if (result)
    {
      uint64_t result = (void **)sub_244D1618C(v11, 2uLL);
      if (result) {
        uint64_t result = (void **)sub_244D1A91C(a1, a2, v11, a3, a4, a5);
      }
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v12 = *(void *)(a4 + 8);
    uint64_t v13 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v13;
    *(void *)(a4 + 32) = *(void *)(v12 + 8 * v13);
  }
  return result;
}

uint64_t sub_244D1C358(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7 = 0;
  uint64_t result = sub_244D1C3C8((uint64_t)a1, &v7, a2, a3, a4);
  if (result)
  {
    unsigned int v6 = v7;
    return sub_244D17CA4((uint64_t)a1, a1, v6);
  }
  return result;
}

uint64_t sub_244D1C3C8(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a3 + 8) <= *(_DWORD *)(a4 + 8)) {
    int v7 = *(_DWORD *)(a4 + 8);
  }
  else {
    int v7 = *(_DWORD *)(a3 + 8);
  }
  if (v7)
  {
    sub_244D1756C((void *)a5);
    uint64_t v11 = sub_244D17610(a5);
    uint64_t v12 = sub_244D17610(a5);
    uint64_t v13 = sub_244D17610(a5);
    uint64_t result = 0;
    if (v11)
    {
      if (v12)
      {
        if (v13)
        {
          uint64_t result = (uint64_t)sub_244D16764((void **)v11, a3);
          if (result)
          {
            uint64_t result = (uint64_t)sub_244D16764((void **)v12, a4);
            if (result)
            {
              uint64_t result = sub_244D16BB4((uint64_t)v11, v7);
              if (result)
              {
                uint64_t result = sub_244D16BB4((uint64_t)v12, v7);
                if (result)
                {
                  uint64_t result = sub_244D16BB4((uint64_t)v13, v7);
                  if (result)
                  {
                    int v15 = *(_DWORD *)(a3 + 8);
                    unsigned int v16 = (*(_DWORD *)(a4 + 8) + v15) << 6;
                    if (v16 >= v15 << 6)
                    {
                      unint64_t v37 = a2;
                      if (v16)
                      {
                        int v17 = 0;
                        int v18 = 0;
                        int v38 = (*(_DWORD *)(a4 + 8) + v15) << 6;
                        do
                        {
                          uint64_t v19 = ((uint64_t)(*(void *)*v11 << 63) >> 63) & -(*(void *)*v12 & 1);
                          unint64_t v20 = sub_244D16544((unint64_t *)*v13, (unint64_t *)*v11, (unint64_t *)*v12, v7);
                          unint64_t v21 = (void *)*v11;
                          unint64_t v22 = (unint64_t *)*v13;
                          uint64_t v23 = v7;
                          do
                          {
                            uint64_t v24 = *v22++;
                            *unint64_t v21 = *v21 & ~((v20 - 1) & v19) | v24 & (v20 - 1) & v19;
                            ++v21;
                            --v23;
                          }
                          while (v23);
                          uint64_t v25 = -(uint64_t)v20;
                          sub_244D16544((unint64_t *)*v13, (unint64_t *)*v12, (unint64_t *)*v11, v7);
                          __int16 v26 = (void *)*v12;
                          uint64_t v27 = (unint64_t *)*v13;
                          uint64_t v28 = v7;
                          do
                          {
                            uint64_t v29 = *v27++;
                            *__int16 v26 = *v26 & ~(v19 & v25) | v29 & v19 & v25;
                            ++v26;
                            --v28;
                          }
                          while (v28);
                          uint64_t v30 = *(void *)*v12 & 1;
                          uint64_t v31 = (*(void *)*v11 & 1) - 1;
                          uint64_t v32 = v30 - 1;
                          v18 -= (v30 - 1) & v31;
                          sub_244D1C9E0((uint64_t *)*v11, v31, (uint64_t *)*v13, v7);
                          sub_244D1C9E0((uint64_t *)*v12, v32, (uint64_t *)*v13, v7);
                          ++v17;
                        }
                        while (v17 != v38);
                      }
                      else
                      {
                        int v18 = 0;
                      }
                      uint64_t v33 = 0;
                      if ((unint64_t)v7 <= 1) {
                        uint64_t v34 = 1;
                      }
                      else {
                        uint64_t v34 = v7;
                      }
                      do
                      {
                        *(void *)(*v12 + 8 * v33) |= *(void *)(*v11 + 8 * v33);
                        ++v33;
                      }
                      while (v34 != v33);
                      *unint64_t v37 = v18;
                      uint64_t result = sub_244D169D4(a1, (const void *)*v12, v7);
                    }
                    else
                    {
                      sub_244D0B884(3, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/gcd_extra.c", 78);
                      uint64_t result = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!*(unsigned char *)(a5 + 40))
    {
      uint64_t v35 = *(void *)(a5 + 8);
      uint64_t v36 = *(void *)(a5 + 16) - 1;
      *(void *)(a5 + 16) = v36;
      *(void *)(a5 + 32) = *(void *)(v35 + 8 * v36);
    }
  }
  else
  {
    *a2 = 0;
    *(_DWORD *)(a1 + 16) = 0;
    uint64_t result = 1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t sub_244D1C69C(BOOL *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_244D1756C((void *)a4);
  uint64_t result = (uint64_t)sub_244D17610(a4);
  if (result)
  {
    int v9 = (unsigned int *)result;
    unsigned int v18 = 0;
    uint64_t result = sub_244D1C3C8(result, &v18, a2, a3, a4);
    if (result)
    {
      uint64_t v10 = v9[2];
      if (v10)
      {
        uint64_t v11 = **(void **)v9 ^ 1 | v18;
        if ((int)v10 >= 2)
        {
          uint64_t v12 = (uint64_t *)(*(void *)v9 + 8);
          uint64_t v13 = v10 - 1;
          do
          {
            uint64_t v14 = *v12++;
            v11 |= v14;
            --v13;
          }
          while (v13);
        }
        BOOL v15 = v11 == 0;
      }
      else
      {
        BOOL v15 = 0;
      }
      *a1 = v15;
      uint64_t result = 1;
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v16 = *(void *)(a4 + 8);
    uint64_t v17 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = *(void *)(v16 + 8 * v17);
  }
  return result;
}

uint64_t sub_244D1C784(void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_244D1756C((void *)a4);
  uint64_t result = (uint64_t)sub_244D17610(a4);
  if (result)
  {
    uint64_t v9 = result;
    uint64_t result = sub_244D1C868((uint64_t)a1, a2, a3, a4);
    if (result)
    {
      unsigned int v12 = 0;
      uint64_t result = sub_244D1C3C8(v9, &v12, a2, a3, a4);
      if (result)
      {
        uint64_t result = sub_244D18204(a1, 0, (uint64_t)a1, v9, 0, a4);
        if (result) {
          uint64_t result = sub_244D1C8C4((uint64_t)a1, (uint64_t)a1, v12, a4);
        }
      }
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v10 = *(void *)(a4 + 8);
    uint64_t v11 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v11;
    *(void *)(a4 + 32) = *(void *)(v10 + 8 * v11);
  }
  return result;
}

uint64_t sub_244D1C868(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a2 + 16) || *(_DWORD *)(a3 + 16))
  {
    sub_244D0B884(3, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/mul.c", 524);
    return 0;
  }
  else
  {
    return sub_244D1EA28(a1, a2, a3, a4);
  }
}

uint64_t sub_244D1C8C4(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  sub_244D1756C((void *)a4);
  uint64_t v8 = sub_244D17610(a4);
  if (v8 && (uint64_t v9 = v8, sub_244D16764((void **)a1, a2)) && sub_244D15DEC((void **)v9, *(int *)(a1 + 8)))
  {
    int v10 = *(_DWORD *)(a1 + 8);
    uint64_t v11 = 1;
    if (v10)
    {
      char v12 = 0;
      unsigned int v13 = v10 << 6;
      do
      {
        sub_244D20E1C((void *)*v9, *(void *)a1, 1 << v12, *(int *)(a1 + 8));
        uint64_t v14 = *(int *)(a1 + 8);
        if (v14)
        {
          BOOL v15 = *(void **)a1;
          uint64_t v16 = (uint64_t *)*v9;
          do
          {
            uint64_t v17 = *v16++;
            *BOOL v15 = *v15 & (((a3 >> v12) & 1) - 1) | v17 & -(uint64_t)((a3 >> v12) & 1);
            ++v15;
            --v14;
          }
          while (v14);
        }
        ++v12;
      }
      while (v13 >> v12);
      uint64_t v11 = 1;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v18 = *(void *)(a4 + 8);
    uint64_t v19 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v19;
    *(void *)(a4 + 32) = *(void *)(v18 + 8 * v19);
  }
  return v11;
}

uint64_t *sub_244D1C9E0(uint64_t *result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (a4)
  {
    if (a4 == 1)
    {
      *a3 = (unint64_t)*result >> 1;
    }
    else
    {
      uint64_t v4 = result + 1;
      uint64_t v5 = a4 - 1;
      unsigned int v6 = a3;
      do
      {
        *v6++ = *(long long *)(v4++ - 1) >> 1;
        --v5;
      }
      while (v5);
      a3[a4 - 1] = (unint64_t)result[a4 - 1] >> 1;
    }
    do
    {
      uint64_t v7 = *a3++;
      *uint64_t result = *result & ~a2 | v7 & a2;
      ++result;
      --a4;
    }
    while (a4);
  }
  return result;
}

uint64_t sub_244D1CA54(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unint64_t a5)
{
  unint64_t v5 = a5;
  unsigned int v6 = a4;
  uint64_t v8 = a1;
  for (uint64_t i = sub_244D15EB4(a4, a1, a3, a5); v5; --v5)
  {
    uint64_t v10 = *v6++;
    *uint64_t v8 = *v8 & ~a2 | v10 & a2;
    ++v8;
  }
  return i & a2;
}

uint64_t sub_244D1CAC8(unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0;
  }
  if (a3 < 4)
  {
    uint64_t v4 = 0;
    do
    {
LABEL_25:
      unint64_t v27 = *a2++;
      unint64_t v28 = (v27 * (unsigned __int128)a4) >> 64;
      unint64_t v29 = v27 * a4;
      BOOL v6 = __CFADD__(*a1, v4);
      unint64_t v30 = *a1 + v4;
      uint64_t v31 = v6;
      unint64_t v32 = v30 + v29;
      uint64_t v4 = (__PAIR128__(v31, v30) + __PAIR128__(v28, v29)) >> 64;
      *a1++ = v32;
      --a3;
    }
    while (a3);
    return v4;
  }
  uint64_t v4 = 0;
  do
  {
    unint64_t v5 = a1[1];
    BOOL v6 = __CFADD__(*a1, v4);
    unint64_t v7 = *a1 + v4;
    uint64_t v8 = v6;
    unsigned long long v9 = __PAIR128__(v8, v7) + *a2 * (unsigned __int128)a4;
    *a1 = v9;
    unint64_t v10 = a2[1];
    uint64_t v11 = (v10 * (unsigned __int128)a4) >> 64;
    unint64_t v12 = v10 * a4;
    BOOL v6 = __CFADD__(v12, v5);
    unint64_t v13 = v12 + v5;
    if (v6) {
      ++v11;
    }
    BOOL v6 = __CFADD__(v13, *((void *)&v9 + 1));
    unint64_t v14 = v13 + *((void *)&v9 + 1);
    if (v6) {
      uint64_t v15 = v11 + 1;
    }
    else {
      uint64_t v15 = v11;
    }
    a1[1] = v14;
    unint64_t v16 = a2[2];
    unint64_t v17 = a1[2];
    unint64_t v18 = a1[3];
    BOOL v6 = __CFADD__(v16 * a4, v17);
    unint64_t v19 = v16 * a4 + v17;
    uint64_t v20 = (v16 * (unsigned __int128)a4) >> 64;
    if (v6) {
      ++v20;
    }
    BOOL v6 = __CFADD__(v19, v15);
    unint64_t v21 = v19 + v15;
    if (v6) {
      ++v20;
    }
    a1[2] = v21;
    unint64_t v22 = a2[3];
    uint64_t v23 = (v22 * (unsigned __int128)a4) >> 64;
    unint64_t v24 = v22 * a4;
    BOOL v6 = __CFADD__(v24, v18);
    unint64_t v25 = v24 + v18;
    if (v6) {
      ++v23;
    }
    BOOL v6 = __CFADD__(v25, v20);
    unint64_t v26 = v25 + v20;
    if (v6) {
      uint64_t v4 = v23 + 1;
    }
    else {
      uint64_t v4 = v23;
    }
    a1[3] = v26;
    a2 += 4;
    a1 += 4;
    a3 -= 4;
  }
  while (a3 >= 4);
  if (a3) {
    goto LABEL_25;
  }
  return v4;
}

_OWORD *sub_244D1CBBC(_OWORD *result, unint64_t *a2, unint64_t a3)
{
  if (a3)
  {
    if (a3 < 4) {
      goto LABEL_8;
    }
    do
    {
      *uint64_t result = *a2 * (unsigned __int128)*a2;
      result[1] = a2[1] * (unsigned __int128)a2[1];
      result[2] = a2[2] * (unsigned __int128)a2[2];
      result[3] = a2[3] * (unsigned __int128)a2[3];
      a2 += 4;
      result += 4;
      a3 -= 4;
    }
    while (a3 >= 4);
    if (a3)
    {
LABEL_8:
      do
      {
        unint64_t v3 = *a2++;
        *result++ = v3 * (unsigned __int128)v3;
        --a3;
      }
      while (a3);
    }
  }
  return result;
}

void *sub_244D1CC3C(void *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = *a3;
  long long v5 = *a2;
  unint64_t v3 = ((unsigned __int128)*a3 * v5) >> 64;
  *uint64_t result = *a3 * *a2;
  unint64_t v6 = a2[1];
  unint64_t v8 = *a3;
  unint64_t v7 = a3[1];
  uint64_t v9 = (__PAIR128__(v7, v4) * v5) >> 64;
  if (__CFADD__(v7 * *a2, v3)) {
    uint64_t v10 = ((v7 * (unsigned __int128)*a2) >> 64) + 1;
  }
  else {
    uint64_t v10 = (v7 * (unsigned __int128)*a2) >> 64;
  }
  uint64_t v11 = (v8 * (unsigned __int128)v6) >> 64;
  unint64_t v12 = v8 * v6;
  BOOL v13 = __CFADD__(v12, v9);
  uint64_t v14 = v12 + v9;
  if (v13) {
    uint64_t v15 = v11 + 1;
  }
  else {
    uint64_t v15 = v11;
  }
  result[1] = v14;
  unint64_t v16 = a2[2];
  unint64_t v17 = a3[1];
  uint64_t v18 = (*a3 * (unsigned __int128)v16) >> 64;
  unint64_t v19 = *a3 * v16;
  BOOL v13 = __CFADD__(v19, v15 + v10);
  unint64_t v20 = v19 + v15 + v10;
  if (v13) {
    uint64_t v21 = v18 + 1;
  }
  else {
    uint64_t v21 = v18;
  }
  BOOL v13 = __CFADD__(__CFADD__(v15, v10), v21);
  uint64_t v22 = __CFADD__(v15, v10) + v21;
  uint64_t v23 = v13;
  unint64_t v25 = *a2;
  unint64_t v24 = a2[1];
  uint64_t v26 = (v17 * (unsigned __int128)v24) >> 64;
  unint64_t v27 = v17 * v24;
  BOOL v13 = __CFADD__(v20, v27);
  unint64_t v28 = v20 + v27;
  if (v13) {
    uint64_t v29 = v26 + 1;
  }
  else {
    uint64_t v29 = v26;
  }
  BOOL v13 = __CFADD__(v22, v29);
  uint64_t v30 = v22 + v29;
  uint64_t v31 = v13;
  unint64_t v32 = a3[2];
  uint64_t v33 = (v32 * (unsigned __int128)v25) >> 64;
  unint64_t v34 = v32 * v25;
  BOOL v13 = __CFADD__(v28, v34);
  unint64_t v35 = v28 + v34;
  if (v13) {
    uint64_t v36 = v33 + 1;
  }
  else {
    uint64_t v36 = v33;
  }
  BOOL v13 = __CFADD__(v30, v36);
  uint64_t v37 = v30 + v36;
  uint64_t v38 = v23 + v13 + v31;
  result[2] = v35;
  unint64_t v39 = a2[1];
  unint64_t v41 = a3[2];
  unint64_t v40 = a3[3];
  unint64_t v42 = v40 * *a2;
  BOOL v13 = __CFADD__(v42, v37);
  uint64_t v43 = v42 + v37;
  if (v13) {
    uint64_t v44 = ((v40 * (unsigned __int128)*a2) >> 64) + 1;
  }
  else {
    uint64_t v44 = (v40 * (unsigned __int128)*a2) >> 64;
  }
  uint64_t v45 = v38 + v44;
  uint64_t v46 = (v41 * (unsigned __int128)v39) >> 64;
  unint64_t v47 = v41 * v39;
  BOOL v13 = __CFADD__(v43, v47);
  uint64_t v48 = v43 + v47;
  if (v13) {
    uint64_t v49 = v46 + 1;
  }
  else {
    uint64_t v49 = v46;
  }
  BOOL v13 = __CFADD__(v45, v49);
  uint64_t v50 = v45 + v49;
  uint64_t v51 = v13;
  if (__CFADD__(v38, v44)) {
    uint64_t v52 = v51 + 1;
  }
  else {
    uint64_t v52 = v51;
  }
  unint64_t v53 = a2[2];
  unint64_t v54 = a2[3];
  unint64_t v56 = *a3;
  unint64_t v55 = a3[1];
  uint64_t v57 = (v55 * (unsigned __int128)v53) >> 64;
  unint64_t v58 = v55 * v53;
  BOOL v13 = __CFADD__(v48, v58);
  uint64_t v59 = v48 + v58;
  if (v13) {
    uint64_t v60 = v57 + 1;
  }
  else {
    uint64_t v60 = v57;
  }
  BOOL v13 = __CFADD__(v50, v60);
  unint64_t v61 = v50 + v60;
  uint64_t v62 = v13;
  unint64_t v63 = (v56 * (unsigned __int128)v54) >> 64;
  unint64_t v64 = v56 * v54;
  BOOL v13 = __CFADD__(v59, v64);
  uint64_t v65 = v59 + v64;
  if (v13) {
    unint64_t v66 = v63 + 1;
  }
  else {
    unint64_t v66 = v63;
  }
  unsigned long long v67 = __PAIR128__(v52, v61) + __PAIR128__(v62, v66);
  result[3] = v65;
  unint64_t v68 = a3[1];
  uint64_t v69 = *a3 * a2[4] + v67;
  uint64_t v70 = *((void *)&v67 + 1) + v67;
  BOOL v71 = __CFADD__(*((void *)&v67 + 1), (void)v67);
  unint64_t v73 = a2[2];
  unint64_t v72 = a2[3];
  uint64_t v74 = (v68 * (unsigned __int128)v72) >> 64;
  unint64_t v75 = v68 * v72;
  BOOL v13 = __CFADD__(v69, v75);
  uint64_t v76 = v69 + v75;
  if (v13) {
    uint64_t v77 = v74 + 1;
  }
  else {
    uint64_t v77 = v74;
  }
  BOOL v13 = __CFADD__(v70, v77);
  uint64_t v78 = v70 + v77;
  uint64_t v79 = v13;
  unint64_t v80 = a3[2];
  unint64_t v81 = a3[3];
  uint64_t v82 = (v80 * (unsigned __int128)v73) >> 64;
  unint64_t v83 = v80 * v73;
  BOOL v13 = __CFADD__(v76, v83);
  uint64_t v84 = v76 + v83;
  if (v13) {
    uint64_t v85 = v82 + 1;
  }
  else {
    uint64_t v85 = v82;
  }
  BOOL v13 = __CFADD__(v78, v85);
  uint64_t v86 = v78 + v85;
  uint64_t v87 = v71 + v13 + v79;
  unint64_t v89 = *a2;
  unint64_t v88 = a2[1];
  uint64_t v90 = (v81 * (unsigned __int128)v88) >> 64;
  unint64_t v91 = v81 * v88;
  BOOL v13 = __CFADD__(v84, v91);
  uint64_t v92 = v84 + v91;
  if (v13) {
    uint64_t v93 = v90 + 1;
  }
  else {
    uint64_t v93 = v90;
  }
  BOOL v13 = __CFADD__(v86, v93);
  unint64_t v94 = v86 + v93;
  uint64_t v95 = v13;
  unint64_t v96 = a3[4];
  unint64_t v97 = (v96 * (unsigned __int128)v89) >> 64;
  unint64_t v98 = v96 * v89;
  BOOL v13 = __CFADD__(v92, v98);
  uint64_t v99 = v92 + v98;
  if (v13) {
    unint64_t v100 = v97 + 1;
  }
  else {
    unint64_t v100 = v97;
  }
  unsigned long long v101 = __PAIR128__(v87, v94) + __PAIR128__(v95, v100);
  result[4] = v99;
  unint64_t v102 = a2[1];
  unint64_t v103 = a3[4];
  uint64_t v104 = a3[5] * *a2 + v101;
  uint64_t v105 = *((void *)&v101 + 1) + v101;
  uint64_t v106 = (v103 * (unsigned __int128)v102) >> 64;
  unint64_t v107 = v103 * v102;
  BOOL v13 = __CFADD__(v104, v107);
  uint64_t v108 = v104 + v107;
  if (v13) {
    uint64_t v109 = v106 + 1;
  }
  else {
    uint64_t v109 = v106;
  }
  BOOL v13 = __CFADD__(v105, v109);
  uint64_t v110 = v105 + v109;
  uint64_t v111 = v13;
  if (__CFADD__(*((void *)&v101 + 1), (void)v101)) {
    uint64_t v112 = v111 + 1;
  }
  else {
    uint64_t v112 = v111;
  }
  unint64_t v113 = a2[2];
  unint64_t v114 = a2[3];
  unint64_t v116 = a3[2];
  unint64_t v115 = a3[3];
  uint64_t v117 = (v115 * (unsigned __int128)v113) >> 64;
  unint64_t v118 = v115 * v113;
  BOOL v13 = __CFADD__(v108, v118);
  uint64_t v119 = v108 + v118;
  if (v13) {
    uint64_t v120 = v117 + 1;
  }
  else {
    uint64_t v120 = v117;
  }
  BOOL v13 = __CFADD__(v110, v120);
  unint64_t v121 = v110 + v120;
  uint64_t v122 = v13;
  unint64_t v123 = (v116 * (unsigned __int128)v114) >> 64;
  unint64_t v124 = v116 * v114;
  BOOL v13 = __CFADD__(v119, v124);
  uint64_t v125 = v119 + v124;
  if (v13) {
    unint64_t v126 = v123 + 1;
  }
  else {
    unint64_t v126 = v123;
  }
  unsigned long long v127 = __PAIR128__(v112, v121) + __PAIR128__(v122, v126);
  unint64_t v128 = a2[4];
  unint64_t v129 = a2[5];
  unint64_t v131 = *a3;
  unint64_t v130 = a3[1];
  uint64_t v132 = (v130 * (unsigned __int128)v128) >> 64;
  unint64_t v133 = v130 * v128;
  BOOL v13 = __CFADD__(v125, v133);
  uint64_t v134 = v125 + v133;
  if (v13) {
    uint64_t v135 = v132 + 1;
  }
  else {
    uint64_t v135 = v132;
  }
  BOOL v136 = __CFADD__((void)v127, v135);
  unint64_t v137 = (v131 * (unsigned __int128)v129) >> 64;
  unint64_t v138 = v131 * v129;
  BOOL v13 = __CFADD__(v134, v138);
  uint64_t v139 = v134 + v138;
  if (v13) {
    unint64_t v140 = v137 + 1;
  }
  else {
    unint64_t v140 = v137;
  }
  unsigned long long v141 = v127 + __PAIR128__(v136, v140);
  result[5] = v139;
  unint64_t v142 = a3[1];
  uint64_t v143 = *a3 * a2[6] + v141;
  uint64_t v144 = *((void *)&v141 + 1) + v141;
  BOOL v145 = __CFADD__(*((void *)&v141 + 1), (void)v141);
  unint64_t v147 = a2[4];
  unint64_t v146 = a2[5];
  uint64_t v148 = (v142 * (unsigned __int128)v146) >> 64;
  unint64_t v149 = v142 * v146;
  BOOL v13 = __CFADD__(v143, v149);
  uint64_t v150 = v143 + v149;
  if (v13) {
    uint64_t v151 = v148 + 1;
  }
  else {
    uint64_t v151 = v148;
  }
  BOOL v13 = __CFADD__(v144, v151);
  uint64_t v152 = v144 + v151;
  uint64_t v153 = v13;
  unint64_t v154 = a3[2];
  unint64_t v155 = a3[3];
  uint64_t v156 = (v154 * (unsigned __int128)v147) >> 64;
  unint64_t v157 = v154 * v147;
  BOOL v13 = __CFADD__(v150, v157);
  uint64_t v158 = v150 + v157;
  if (v13) {
    uint64_t v159 = v156 + 1;
  }
  else {
    uint64_t v159 = v156;
  }
  BOOL v13 = __CFADD__(v152, v159);
  uint64_t v160 = v152 + v159;
  uint64_t v161 = v145 + v13 + v153;
  unint64_t v163 = a2[2];
  unint64_t v162 = a2[3];
  uint64_t v164 = (v155 * (unsigned __int128)v162) >> 64;
  unint64_t v165 = v155 * v162;
  BOOL v13 = __CFADD__(v158, v165);
  uint64_t v166 = v158 + v165;
  if (v13) {
    uint64_t v167 = v164 + 1;
  }
  else {
    uint64_t v167 = v164;
  }
  BOOL v13 = __CFADD__(v160, v167);
  unint64_t v168 = v160 + v167;
  uint64_t v169 = v13;
  unint64_t v170 = a3[4];
  unint64_t v171 = a3[5];
  unint64_t v172 = (v170 * (unsigned __int128)v163) >> 64;
  unint64_t v173 = v170 * v163;
  BOOL v13 = __CFADD__(v166, v173);
  uint64_t v174 = v166 + v173;
  if (v13) {
    unint64_t v175 = v172 + 1;
  }
  else {
    unint64_t v175 = v172;
  }
  unsigned long long v176 = __PAIR128__(v161, v168) + __PAIR128__(v169, v175);
  unint64_t v178 = *a2;
  unint64_t v177 = a2[1];
  uint64_t v179 = (v171 * (unsigned __int128)v177) >> 64;
  unint64_t v180 = v171 * v177;
  BOOL v13 = __CFADD__(v174, v180);
  uint64_t v181 = v174 + v180;
  if (v13) {
    uint64_t v182 = v179 + 1;
  }
  else {
    uint64_t v182 = v179;
  }
  BOOL v183 = __CFADD__((void)v176, v182);
  unint64_t v184 = a3[6];
  unint64_t v185 = (v184 * (unsigned __int128)v178) >> 64;
  unint64_t v186 = v184 * v178;
  BOOL v13 = __CFADD__(v181, v186);
  uint64_t v187 = v181 + v186;
  if (v13) {
    unint64_t v188 = v185 + 1;
  }
  else {
    unint64_t v188 = v185;
  }
  unsigned long long v189 = v176 + __PAIR128__(v183, v188);
  result[6] = v187;
  unint64_t v190 = a2[1];
  unint64_t v191 = a3[6];
  uint64_t v192 = a3[7] * *a2 + v189;
  uint64_t v193 = *((void *)&v189 + 1) + v189;
  uint64_t v194 = (v191 * (unsigned __int128)v190) >> 64;
  unint64_t v195 = v191 * v190;
  BOOL v13 = __CFADD__(v192, v195);
  uint64_t v196 = v192 + v195;
  if (v13) {
    uint64_t v197 = v194 + 1;
  }
  else {
    uint64_t v197 = v194;
  }
  BOOL v13 = __CFADD__(v193, v197);
  uint64_t v198 = v193 + v197;
  uint64_t v199 = v13;
  if (__CFADD__(*((void *)&v189 + 1), (void)v189)) {
    uint64_t v200 = v199 + 1;
  }
  else {
    uint64_t v200 = v199;
  }
  unint64_t v201 = a2[2];
  unint64_t v202 = a2[3];
  unint64_t v204 = a3[4];
  unint64_t v203 = a3[5];
  uint64_t v205 = (v203 * (unsigned __int128)v201) >> 64;
  unint64_t v206 = v203 * v201;
  BOOL v13 = __CFADD__(v196, v206);
  uint64_t v207 = v196 + v206;
  if (v13) {
    uint64_t v208 = v205 + 1;
  }
  else {
    uint64_t v208 = v205;
  }
  BOOL v13 = __CFADD__(v198, v208);
  unint64_t v209 = v198 + v208;
  uint64_t v210 = v13;
  unint64_t v211 = (v204 * (unsigned __int128)v202) >> 64;
  unint64_t v212 = v204 * v202;
  BOOL v13 = __CFADD__(v207, v212);
  uint64_t v213 = v207 + v212;
  if (v13) {
    unint64_t v214 = v211 + 1;
  }
  else {
    unint64_t v214 = v211;
  }
  unsigned long long v215 = __PAIR128__(v200, v209) + __PAIR128__(v210, v214);
  unint64_t v216 = a2[4];
  unint64_t v217 = a2[5];
  unint64_t v219 = a3[2];
  unint64_t v218 = a3[3];
  uint64_t v220 = (v218 * (unsigned __int128)v216) >> 64;
  unint64_t v221 = v218 * v216;
  BOOL v13 = __CFADD__(v213, v221);
  uint64_t v222 = v213 + v221;
  if (v13) {
    uint64_t v223 = v220 + 1;
  }
  else {
    uint64_t v223 = v220;
  }
  BOOL v224 = __CFADD__((void)v215, v223);
  unint64_t v225 = (v219 * (unsigned __int128)v217) >> 64;
  unint64_t v226 = v219 * v217;
  BOOL v13 = __CFADD__(v222, v226);
  uint64_t v227 = v222 + v226;
  if (v13) {
    unint64_t v228 = v225 + 1;
  }
  else {
    unint64_t v228 = v225;
  }
  unsigned long long v229 = v215 + __PAIR128__(v224, v228);
  unint64_t v230 = a2[6];
  unint64_t v231 = a2[7];
  unint64_t v233 = *a3;
  unint64_t v232 = a3[1];
  uint64_t v234 = (v232 * (unsigned __int128)v230) >> 64;
  unint64_t v235 = v232 * v230;
  BOOL v13 = __CFADD__(v227, v235);
  uint64_t v236 = v227 + v235;
  if (v13) {
    uint64_t v237 = v234 + 1;
  }
  else {
    uint64_t v237 = v234;
  }
  BOOL v238 = __CFADD__((void)v229, v237);
  unint64_t v239 = (v233 * (unsigned __int128)v231) >> 64;
  unint64_t v240 = v233 * v231;
  BOOL v13 = __CFADD__(v236, v240);
  uint64_t v241 = v236 + v240;
  if (v13) {
    unint64_t v242 = v239 + 1;
  }
  else {
    unint64_t v242 = v239;
  }
  unsigned long long v243 = v229 + __PAIR128__(v238, v242);
  result[7] = v241;
  unint64_t v244 = a3[2];
  uint64_t v245 = a3[1] * a2[7] + v243;
  uint64_t v246 = *((void *)&v243 + 1) + v243;
  BOOL v247 = __CFADD__(*((void *)&v243 + 1), (void)v243);
  unint64_t v249 = a2[5];
  unint64_t v248 = a2[6];
  uint64_t v250 = (v244 * (unsigned __int128)v248) >> 64;
  unint64_t v251 = v244 * v248;
  BOOL v13 = __CFADD__(v245, v251);
  uint64_t v252 = v245 + v251;
  if (v13) {
    uint64_t v253 = v250 + 1;
  }
  else {
    uint64_t v253 = v250;
  }
  BOOL v13 = __CFADD__(v246, v253);
  uint64_t v254 = v246 + v253;
  uint64_t v255 = v13;
  unint64_t v256 = a3[3];
  unint64_t v257 = a3[4];
  uint64_t v258 = (v256 * (unsigned __int128)v249) >> 64;
  unint64_t v259 = v256 * v249;
  BOOL v13 = __CFADD__(v252, v259);
  uint64_t v260 = v252 + v259;
  if (v13) {
    uint64_t v261 = v258 + 1;
  }
  else {
    uint64_t v261 = v258;
  }
  BOOL v13 = __CFADD__(v254, v261);
  uint64_t v262 = v254 + v261;
  uint64_t v263 = v247 + v13 + v255;
  unint64_t v265 = a2[3];
  unint64_t v264 = a2[4];
  uint64_t v266 = (v257 * (unsigned __int128)v264) >> 64;
  unint64_t v267 = v257 * v264;
  BOOL v13 = __CFADD__(v260, v267);
  uint64_t v268 = v260 + v267;
  if (v13) {
    uint64_t v269 = v266 + 1;
  }
  else {
    uint64_t v269 = v266;
  }
  BOOL v13 = __CFADD__(v262, v269);
  unint64_t v270 = v262 + v269;
  uint64_t v271 = v13;
  unint64_t v272 = a3[5];
  unint64_t v273 = a3[6];
  unint64_t v274 = (v272 * (unsigned __int128)v265) >> 64;
  unint64_t v275 = v272 * v265;
  BOOL v13 = __CFADD__(v268, v275);
  uint64_t v276 = v268 + v275;
  if (v13) {
    unint64_t v277 = v274 + 1;
  }
  else {
    unint64_t v277 = v274;
  }
  unsigned long long v278 = __PAIR128__(v263, v270) + __PAIR128__(v271, v277);
  unint64_t v280 = a2[1];
  unint64_t v279 = a2[2];
  uint64_t v281 = (v273 * (unsigned __int128)v279) >> 64;
  unint64_t v282 = v273 * v279;
  BOOL v13 = __CFADD__(v276, v282);
  uint64_t v283 = v276 + v282;
  if (v13) {
    uint64_t v284 = v281 + 1;
  }
  else {
    uint64_t v284 = v281;
  }
  BOOL v285 = __CFADD__((void)v278, v284);
  unint64_t v286 = a3[7];
  unint64_t v287 = (v286 * (unsigned __int128)v280) >> 64;
  unint64_t v288 = v286 * v280;
  BOOL v13 = __CFADD__(v283, v288);
  uint64_t v289 = v283 + v288;
  if (v13) {
    unint64_t v290 = v287 + 1;
  }
  else {
    unint64_t v290 = v287;
  }
  unsigned long long v291 = v278 + __PAIR128__(v285, v290);
  result[8] = v289;
  unint64_t v292 = a2[3];
  unint64_t v293 = a3[6];
  uint64_t v294 = a3[7] * a2[2] + v291;
  uint64_t v295 = *((void *)&v291 + 1) + v291;
  uint64_t v296 = (v293 * (unsigned __int128)v292) >> 64;
  unint64_t v297 = v293 * v292;
  BOOL v13 = __CFADD__(v294, v297);
  uint64_t v298 = v294 + v297;
  if (v13) {
    uint64_t v299 = v296 + 1;
  }
  else {
    uint64_t v299 = v296;
  }
  BOOL v13 = __CFADD__(v295, v299);
  uint64_t v300 = v295 + v299;
  uint64_t v301 = v13;
  if (__CFADD__(*((void *)&v291 + 1), (void)v291)) {
    uint64_t v302 = v301 + 1;
  }
  else {
    uint64_t v302 = v301;
  }
  unint64_t v303 = a2[4];
  unint64_t v304 = a2[5];
  unint64_t v306 = a3[4];
  unint64_t v305 = a3[5];
  uint64_t v307 = (v305 * (unsigned __int128)v303) >> 64;
  unint64_t v308 = v305 * v303;
  BOOL v13 = __CFADD__(v298, v308);
  uint64_t v309 = v298 + v308;
  if (v13) {
    uint64_t v310 = v307 + 1;
  }
  else {
    uint64_t v310 = v307;
  }
  BOOL v13 = __CFADD__(v300, v310);
  unint64_t v311 = v300 + v310;
  uint64_t v312 = v13;
  unint64_t v313 = (v306 * (unsigned __int128)v304) >> 64;
  unint64_t v314 = v306 * v304;
  BOOL v13 = __CFADD__(v309, v314);
  uint64_t v315 = v309 + v314;
  if (v13) {
    unint64_t v316 = v313 + 1;
  }
  else {
    unint64_t v316 = v313;
  }
  unsigned long long v317 = __PAIR128__(v302, v311) + __PAIR128__(v312, v316);
  unint64_t v318 = a2[6];
  unint64_t v319 = a2[7];
  unint64_t v321 = a3[2];
  unint64_t v320 = a3[3];
  uint64_t v322 = (v320 * (unsigned __int128)v318) >> 64;
  unint64_t v323 = v320 * v318;
  BOOL v13 = __CFADD__(v315, v323);
  uint64_t v324 = v315 + v323;
  if (v13) {
    uint64_t v325 = v322 + 1;
  }
  else {
    uint64_t v325 = v322;
  }
  BOOL v326 = __CFADD__((void)v317, v325);
  unint64_t v327 = (v321 * (unsigned __int128)v319) >> 64;
  unint64_t v328 = v321 * v319;
  BOOL v13 = __CFADD__(v324, v328);
  uint64_t v329 = v324 + v328;
  if (v13) {
    unint64_t v330 = v327 + 1;
  }
  else {
    unint64_t v330 = v327;
  }
  unsigned long long v331 = v317 + __PAIR128__(v326, v330);
  result[9] = v329;
  unint64_t v332 = a3[4];
  uint64_t v333 = a3[3] * a2[7] + v331;
  uint64_t v334 = *((void *)&v331 + 1) + v331;
  BOOL v335 = __CFADD__(*((void *)&v331 + 1), (void)v331);
  unint64_t v337 = a2[5];
  unint64_t v336 = a2[6];
  uint64_t v338 = (v332 * (unsigned __int128)v336) >> 64;
  unint64_t v339 = v332 * v336;
  BOOL v13 = __CFADD__(v333, v339);
  uint64_t v340 = v333 + v339;
  if (v13) {
    uint64_t v341 = v338 + 1;
  }
  else {
    uint64_t v341 = v338;
  }
  BOOL v13 = __CFADD__(v334, v341);
  uint64_t v342 = v334 + v341;
  uint64_t v343 = v13;
  unint64_t v344 = a3[5];
  unint64_t v345 = a3[6];
  uint64_t v346 = (v344 * (unsigned __int128)v337) >> 64;
  unint64_t v347 = v344 * v337;
  BOOL v13 = __CFADD__(v340, v347);
  uint64_t v348 = v340 + v347;
  if (v13) {
    uint64_t v349 = v346 + 1;
  }
  else {
    uint64_t v349 = v346;
  }
  BOOL v13 = __CFADD__(v342, v349);
  uint64_t v350 = v342 + v349;
  uint64_t v351 = v335 + v13 + v343;
  unint64_t v353 = a2[3];
  unint64_t v352 = a2[4];
  uint64_t v354 = (v345 * (unsigned __int128)v352) >> 64;
  unint64_t v355 = v345 * v352;
  BOOL v13 = __CFADD__(v348, v355);
  uint64_t v356 = v348 + v355;
  if (v13) {
    uint64_t v357 = v354 + 1;
  }
  else {
    uint64_t v357 = v354;
  }
  BOOL v13 = __CFADD__(v350, v357);
  unint64_t v358 = v350 + v357;
  uint64_t v359 = v13;
  unint64_t v360 = a3[7];
  unint64_t v361 = (v360 * (unsigned __int128)v353) >> 64;
  unint64_t v362 = v360 * v353;
  BOOL v13 = __CFADD__(v356, v362);
  uint64_t v363 = v356 + v362;
  if (v13) {
    unint64_t v364 = v361 + 1;
  }
  else {
    unint64_t v364 = v361;
  }
  unsigned long long v365 = __PAIR128__(v351, v358) + __PAIR128__(v359, v364);
  result[10] = v363;
  unint64_t v366 = a2[5];
  unint64_t v367 = a3[6];
  uint64_t v368 = a3[7] * a2[4] + v365;
  uint64_t v369 = *((void *)&v365 + 1) + v365;
  uint64_t v370 = (v367 * (unsigned __int128)v366) >> 64;
  unint64_t v371 = v367 * v366;
  BOOL v13 = __CFADD__(v368, v371);
  uint64_t v372 = v368 + v371;
  if (v13) {
    uint64_t v373 = v370 + 1;
  }
  else {
    uint64_t v373 = v370;
  }
  BOOL v13 = __CFADD__(v369, v373);
  uint64_t v374 = v369 + v373;
  uint64_t v375 = v13;
  unint64_t v376 = a2[6];
  unint64_t v377 = a2[7];
  unint64_t v379 = a3[4];
  unint64_t v378 = a3[5];
  uint64_t v380 = (v378 * (unsigned __int128)v376) >> 64;
  unint64_t v381 = v378 * v376;
  if (__CFADD__(*((void *)&v365 + 1), (void)v365)) {
    ++v375;
  }
  BOOL v13 = __CFADD__(v372, v381);
  uint64_t v382 = v372 + v381;
  if (v13) {
    uint64_t v383 = v380 + 1;
  }
  else {
    uint64_t v383 = v380;
  }
  BOOL v13 = __CFADD__(v374, v383);
  unint64_t v384 = v374 + v383;
  uint64_t v385 = v13;
  unint64_t v386 = (v379 * (unsigned __int128)v377) >> 64;
  unint64_t v387 = v379 * v377;
  BOOL v13 = __CFADD__(v382, v387);
  uint64_t v388 = v382 + v387;
  if (v13) {
    unint64_t v389 = v386 + 1;
  }
  else {
    unint64_t v389 = v386;
  }
  unsigned long long v390 = __PAIR128__(v375, v384) + __PAIR128__(v385, v389);
  result[11] = v388;
  unint64_t v391 = a3[6];
  uint64_t v392 = a3[5] * a2[7] + v390;
  uint64_t v393 = *((void *)&v390 + 1) + v390;
  BOOL v394 = __CFADD__(*((void *)&v390 + 1), (void)v390);
  unint64_t v396 = a2[5];
  unint64_t v395 = a2[6];
  uint64_t v397 = (v391 * (unsigned __int128)v395) >> 64;
  unint64_t v398 = v391 * v395;
  BOOL v13 = __CFADD__(v392, v398);
  uint64_t v399 = v392 + v398;
  if (v13) {
    uint64_t v400 = v397 + 1;
  }
  else {
    uint64_t v400 = v397;
  }
  BOOL v13 = __CFADD__(v393, v400);
  uint64_t v401 = v393 + v400;
  uint64_t v402 = v13;
  unint64_t v403 = a3[7];
  uint64_t v404 = (v403 * (unsigned __int128)v396) >> 64;
  unint64_t v405 = v403 * v396;
  BOOL v13 = __CFADD__(v399, v405);
  uint64_t v406 = v399 + v405;
  if (v13) {
    uint64_t v407 = v404 + 1;
  }
  else {
    uint64_t v407 = v404;
  }
  BOOL v13 = __CFADD__(v401, v407);
  uint64_t v408 = v401 + v407;
  uint64_t v409 = v394 + v13 + v402;
  result[12] = v406;
  unint64_t v410 = a2[6];
  unint64_t v411 = a2[7];
  unint64_t v413 = a3[6];
  unint64_t v412 = a3[7];
  uint64_t v414 = (v412 * (unsigned __int128)v410) >> 64;
  unint64_t v415 = v412 * v410;
  BOOL v13 = __CFADD__(v415, v408);
  uint64_t v416 = v415 + v408;
  if (v13) {
    uint64_t v417 = v414 + 1;
  }
  else {
    uint64_t v417 = v414;
  }
  uint64_t v418 = v409 + v417;
  uint64_t v419 = (v413 * (unsigned __int128)v411) >> 64;
  unint64_t v420 = v413 * v411;
  BOOL v13 = __CFADD__(v416, v420);
  uint64_t v421 = v416 + v420;
  if (v13) {
    uint64_t v422 = v419 + 1;
  }
  else {
    uint64_t v422 = v419;
  }
  BOOL v13 = __CFADD__(v418, v422);
  uint64_t v423 = v418 + v422;
  uint64_t v424 = v13;
  result[13] = v421;
  unint64_t v425 = a2[7];
  unint64_t v426 = a3[7];
  uint64_t v427 = (v426 * (unsigned __int128)v425) >> 64;
  unint64_t v428 = v426 * v425;
  BOOL v13 = __CFADD__(v428, v423);
  uint64_t v429 = v428 + v423;
  if (v13) {
    uint64_t v430 = v427 + 1;
  }
  else {
    uint64_t v430 = v427;
  }
  result[14] = v429;
  result[15] = v424 + __CFADD__(v409, v417) + v430;
  return result;
}

void *sub_244D1D394(void *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = *a3;
  long long v5 = *a2;
  unint64_t v3 = ((unsigned __int128)*a3 * v5) >> 64;
  *uint64_t result = *a3 * *a2;
  unint64_t v6 = a2[1];
  unint64_t v8 = *a3;
  unint64_t v7 = a3[1];
  uint64_t v9 = (__PAIR128__(v7, v4) * v5) >> 64;
  if (__CFADD__(v7 * *a2, v3)) {
    uint64_t v10 = ((v7 * (unsigned __int128)*a2) >> 64) + 1;
  }
  else {
    uint64_t v10 = (v7 * (unsigned __int128)*a2) >> 64;
  }
  uint64_t v11 = (v8 * (unsigned __int128)v6) >> 64;
  unint64_t v12 = v8 * v6;
  BOOL v13 = __CFADD__(v12, v9);
  uint64_t v14 = v12 + v9;
  if (v13) {
    uint64_t v15 = v11 + 1;
  }
  else {
    uint64_t v15 = v11;
  }
  result[1] = v14;
  unint64_t v16 = a2[2];
  unint64_t v17 = a3[1];
  uint64_t v18 = (*a3 * (unsigned __int128)v16) >> 64;
  unint64_t v19 = *a3 * v16;
  BOOL v13 = __CFADD__(v19, v15 + v10);
  unint64_t v20 = v19 + v15 + v10;
  if (v13) {
    uint64_t v21 = v18 + 1;
  }
  else {
    uint64_t v21 = v18;
  }
  BOOL v13 = __CFADD__(__CFADD__(v15, v10), v21);
  uint64_t v22 = __CFADD__(v15, v10) + v21;
  uint64_t v23 = v13;
  unint64_t v25 = *a2;
  unint64_t v24 = a2[1];
  uint64_t v26 = (v17 * (unsigned __int128)v24) >> 64;
  unint64_t v27 = v17 * v24;
  BOOL v13 = __CFADD__(v20, v27);
  unint64_t v28 = v20 + v27;
  if (v13) {
    uint64_t v29 = v26 + 1;
  }
  else {
    uint64_t v29 = v26;
  }
  BOOL v13 = __CFADD__(v22, v29);
  uint64_t v30 = v22 + v29;
  uint64_t v31 = v13;
  unint64_t v32 = a3[2];
  uint64_t v33 = (v32 * (unsigned __int128)v25) >> 64;
  unint64_t v34 = v32 * v25;
  BOOL v13 = __CFADD__(v28, v34);
  unint64_t v35 = v28 + v34;
  if (v13) {
    uint64_t v36 = v33 + 1;
  }
  else {
    uint64_t v36 = v33;
  }
  BOOL v13 = __CFADD__(v30, v36);
  uint64_t v37 = v30 + v36;
  uint64_t v38 = v23 + v13 + v31;
  result[2] = v35;
  unint64_t v39 = a2[1];
  unint64_t v41 = a3[2];
  unint64_t v40 = a3[3];
  unint64_t v42 = v40 * *a2;
  BOOL v13 = __CFADD__(v42, v37);
  uint64_t v43 = v42 + v37;
  if (v13) {
    uint64_t v44 = ((v40 * (unsigned __int128)*a2) >> 64) + 1;
  }
  else {
    uint64_t v44 = (v40 * (unsigned __int128)*a2) >> 64;
  }
  uint64_t v45 = v38 + v44;
  uint64_t v46 = (v41 * (unsigned __int128)v39) >> 64;
  unint64_t v47 = v41 * v39;
  BOOL v13 = __CFADD__(v43, v47);
  uint64_t v48 = v43 + v47;
  if (v13) {
    uint64_t v49 = v46 + 1;
  }
  else {
    uint64_t v49 = v46;
  }
  BOOL v13 = __CFADD__(v45, v49);
  uint64_t v50 = v45 + v49;
  uint64_t v51 = v13;
  BOOL v13 = __CFADD__(v38, v44);
  unint64_t v52 = a2[2];
  unint64_t v53 = a2[3];
  unint64_t v55 = *a3;
  unint64_t v54 = a3[1];
  uint64_t v56 = (v54 * (unsigned __int128)v52) >> 64;
  unint64_t v57 = v54 * v52;
  if (v13) {
    ++v51;
  }
  BOOL v13 = __CFADD__(v48, v57);
  uint64_t v58 = v48 + v57;
  if (v13) {
    uint64_t v59 = v56 + 1;
  }
  else {
    uint64_t v59 = v56;
  }
  BOOL v13 = __CFADD__(v50, v59);
  unint64_t v60 = v50 + v59;
  uint64_t v61 = v13;
  unint64_t v62 = (v55 * (unsigned __int128)v53) >> 64;
  unint64_t v63 = v55 * v53;
  BOOL v13 = __CFADD__(v58, v63);
  uint64_t v64 = v58 + v63;
  if (v13) {
    unint64_t v65 = v62 + 1;
  }
  else {
    unint64_t v65 = v62;
  }
  unsigned long long v66 = __PAIR128__(v51, v60) + __PAIR128__(v61, v65);
  result[3] = v64;
  unint64_t v67 = a3[2];
  uint64_t v68 = a3[1] * a2[3] + v66;
  uint64_t v69 = *((void *)&v66 + 1) + v66;
  BOOL v70 = __CFADD__(*((void *)&v66 + 1), (void)v66);
  unint64_t v72 = a2[1];
  unint64_t v71 = a2[2];
  uint64_t v73 = (v67 * (unsigned __int128)v71) >> 64;
  unint64_t v74 = v67 * v71;
  BOOL v13 = __CFADD__(v68, v74);
  uint64_t v75 = v68 + v74;
  if (v13) {
    uint64_t v76 = v73 + 1;
  }
  else {
    uint64_t v76 = v73;
  }
  BOOL v13 = __CFADD__(v69, v76);
  uint64_t v77 = v69 + v76;
  uint64_t v78 = v13;
  unint64_t v79 = a3[3];
  uint64_t v80 = (v79 * (unsigned __int128)v72) >> 64;
  unint64_t v81 = v79 * v72;
  BOOL v13 = __CFADD__(v75, v81);
  uint64_t v82 = v75 + v81;
  if (v13) {
    uint64_t v83 = v80 + 1;
  }
  else {
    uint64_t v83 = v80;
  }
  BOOL v13 = __CFADD__(v77, v83);
  uint64_t v84 = v77 + v83;
  uint64_t v85 = v70 + v13 + v78;
  result[4] = v82;
  unint64_t v86 = a2[2];
  unint64_t v87 = a2[3];
  unint64_t v89 = a3[2];
  unint64_t v88 = a3[3];
  uint64_t v90 = (v88 * (unsigned __int128)v86) >> 64;
  unint64_t v91 = v88 * v86;
  BOOL v13 = __CFADD__(v91, v84);
  uint64_t v92 = v91 + v84;
  if (v13) {
    uint64_t v93 = v90 + 1;
  }
  else {
    uint64_t v93 = v90;
  }
  uint64_t v94 = v85 + v93;
  uint64_t v95 = (v89 * (unsigned __int128)v87) >> 64;
  unint64_t v96 = v89 * v87;
  BOOL v13 = __CFADD__(v92, v96);
  uint64_t v97 = v92 + v96;
  if (v13) {
    uint64_t v98 = v95 + 1;
  }
  else {
    uint64_t v98 = v95;
  }
  BOOL v13 = __CFADD__(v94, v98);
  uint64_t v99 = v94 + v98;
  uint64_t v100 = v13;
  result[5] = v97;
  unint64_t v101 = a2[3];
  unint64_t v102 = a3[3];
  uint64_t v103 = (v102 * (unsigned __int128)v101) >> 64;
  unint64_t v104 = v102 * v101;
  BOOL v13 = __CFADD__(v104, v99);
  uint64_t v105 = v104 + v99;
  if (v13) {
    uint64_t v106 = v103 + 1;
  }
  else {
    uint64_t v106 = v103;
  }
  result[6] = v105;
  result[7] = v100 + __CFADD__(v85, v93) + v106;
  return result;
}

void *sub_244D1D56C(void *result, unint64_t *a2)
{
  uint64_t v2 = (*a2 * (unsigned __int128)*a2) >> 64;
  *uint64_t result = *a2 * *a2;
  unint64_t v3 = a2[1];
  uint64_t v4 = (*a2 * (unsigned __int128)v3) >> 64;
  unint64_t v5 = *a2 * v3;
  BOOL v6 = __CFADD__(v5, v2);
  uint64_t v7 = v5 + v2;
  if (v6) {
    uint64_t v8 = v4 + 1;
  }
  else {
    uint64_t v8 = v4;
  }
  BOOL v6 = __CFADD__(v7, v5);
  uint64_t v9 = v7 + v5;
  if (v6) {
    uint64_t v10 = v4 + 1;
  }
  else {
    uint64_t v10 = v4;
  }
  result[1] = v9;
  unint64_t v12 = *a2;
  unint64_t v11 = a2[1];
  uint64_t v13 = (v11 * (unsigned __int128)v11) >> 64;
  unint64_t v14 = v11 * v11;
  BOOL v6 = __CFADD__(v14, v10 + v8);
  unint64_t v15 = v14 + v10 + v8;
  if (v6) {
    uint64_t v16 = v13 + 1;
  }
  else {
    uint64_t v16 = v13;
  }
  BOOL v6 = __CFADD__(__CFADD__(v10, v8), v16);
  uint64_t v17 = __CFADD__(v10, v8) + v16;
  uint64_t v18 = v6;
  unint64_t v19 = a2[2];
  uint64_t v20 = (v12 * (unsigned __int128)v19) >> 64;
  unint64_t v21 = v12 * v19;
  BOOL v6 = __CFADD__(v15, v21);
  unint64_t v22 = v15 + v21;
  if (v6) {
    uint64_t v23 = v20 + 1;
  }
  else {
    uint64_t v23 = v20;
  }
  BOOL v6 = __CFADD__(v17, v23);
  uint64_t v24 = v17 + v23;
  uint64_t v25 = v6;
  BOOL v6 = __CFADD__(v22, v21);
  unint64_t v26 = v22 + v21;
  if (v6) {
    uint64_t v27 = v20 + 1;
  }
  else {
    uint64_t v27 = v20;
  }
  BOOL v6 = __CFADD__(v24, v27);
  uint64_t v28 = v24 + v27;
  uint64_t v29 = v18 + v6 + v25;
  result[2] = v26;
  unint64_t v31 = a2[2];
  unint64_t v30 = a2[3];
  unint64_t v32 = a2[1];
  uint64_t v33 = (*a2 * (unsigned __int128)v30) >> 64;
  unint64_t v34 = *a2 * v30;
  BOOL v6 = __CFADD__(v34, v28);
  uint64_t v35 = v34 + v28;
  if (v6) {
    uint64_t v36 = v33 + 1;
  }
  else {
    uint64_t v36 = v33;
  }
  uint64_t v37 = v29 + v36;
  BOOL v6 = __CFADD__(v35, v34);
  uint64_t v38 = v35 + v34;
  if (v6) {
    uint64_t v39 = v33 + 1;
  }
  else {
    uint64_t v39 = v33;
  }
  BOOL v6 = __CFADD__(v37, v39);
  uint64_t v40 = v37 + v39;
  uint64_t v41 = v6;
  if (__CFADD__(v29, v36)) {
    uint64_t v42 = v41 + 1;
  }
  else {
    uint64_t v42 = v41;
  }
  unint64_t v43 = (v32 * (unsigned __int128)v31) >> 64;
  unint64_t v44 = v32 * v31;
  BOOL v6 = __CFADD__(v38, v44);
  uint64_t v45 = v38 + v44;
  if (v6) {
    unint64_t v46 = v43 + 1;
  }
  else {
    unint64_t v46 = v43;
  }
  BOOL v6 = __CFADD__(v40, v46);
  unint64_t v47 = v40 + v46;
  uint64_t v48 = v6;
  BOOL v6 = __CFADD__(v45, v44);
  uint64_t v49 = v45 + v44;
  if (v6) {
    unint64_t v50 = v43 + 1;
  }
  else {
    unint64_t v50 = v43;
  }
  unsigned long long v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  unint64_t v52 = a2[3];
  uint64_t v53 = a2[2] * a2[2] + v51;
  uint64_t v54 = *((void *)&v51 + 1) + v51;
  BOOL v55 = __CFADD__(*((void *)&v51 + 1), (void)v51);
  unint64_t v57 = *a2;
  unint64_t v56 = a2[1];
  uint64_t v58 = (v56 * (unsigned __int128)v52) >> 64;
  unint64_t v59 = v56 * v52;
  BOOL v6 = __CFADD__(v53, v59);
  uint64_t v60 = v53 + v59;
  if (v6) {
    uint64_t v61 = v58 + 1;
  }
  else {
    uint64_t v61 = v58;
  }
  BOOL v6 = __CFADD__(v54, v61);
  uint64_t v62 = v54 + v61;
  uint64_t v63 = v6;
  BOOL v6 = __CFADD__(v60, v59);
  uint64_t v64 = v60 + v59;
  if (v6) {
    uint64_t v65 = v58 + 1;
  }
  else {
    uint64_t v65 = v58;
  }
  BOOL v6 = __CFADD__(v62, v65);
  uint64_t v66 = v62 + v65;
  uint64_t v67 = v55 + v6 + v63;
  unint64_t v68 = a2[4];
  unint64_t v69 = (v57 * (unsigned __int128)v68) >> 64;
  unint64_t v70 = v57 * v68;
  BOOL v6 = __CFADD__(v64, v70);
  uint64_t v71 = v64 + v70;
  if (v6) {
    unint64_t v72 = v69 + 1;
  }
  else {
    unint64_t v72 = v69;
  }
  BOOL v6 = __CFADD__(v66, v72);
  unint64_t v73 = v66 + v72;
  uint64_t v74 = v6;
  BOOL v6 = __CFADD__(v71, v70);
  uint64_t v75 = v71 + v70;
  if (v6) {
    unint64_t v76 = v69 + 1;
  }
  else {
    unint64_t v76 = v69;
  }
  unsigned long long v77 = __PAIR128__(v67, v73) + __PAIR128__(v74, v76);
  result[4] = v75;
  unint64_t v79 = a2[4];
  unint64_t v78 = a2[5];
  unint64_t v80 = a2[1];
  uint64_t v81 = (*a2 * (unsigned __int128)v78) >> 64;
  unint64_t v82 = *a2 * v78;
  uint64_t v83 = v82 + v77;
  if (__CFADD__(v82, (void)v77)) {
    uint64_t v84 = v81 + 1;
  }
  else {
    uint64_t v84 = v81;
  }
  uint64_t v85 = *((void *)&v77 + 1) + v84;
  BOOL v6 = __CFADD__(v83, v82);
  uint64_t v86 = v83 + v82;
  if (v6) {
    uint64_t v87 = v81 + 1;
  }
  else {
    uint64_t v87 = v81;
  }
  BOOL v6 = __CFADD__(v85, v87);
  uint64_t v88 = v85 + v87;
  uint64_t v89 = v6;
  if (__CFADD__(*((void *)&v77 + 1), v84)) {
    uint64_t v90 = v89 + 1;
  }
  else {
    uint64_t v90 = v89;
  }
  unint64_t v91 = (v80 * (unsigned __int128)v79) >> 64;
  unint64_t v92 = v80 * v79;
  BOOL v6 = __CFADD__(v86, v92);
  uint64_t v93 = v86 + v92;
  if (v6) {
    unint64_t v94 = v91 + 1;
  }
  else {
    unint64_t v94 = v91;
  }
  BOOL v6 = __CFADD__(v88, v94);
  unint64_t v95 = v88 + v94;
  uint64_t v96 = v6;
  BOOL v6 = __CFADD__(v93, v92);
  uint64_t v97 = v93 + v92;
  if (v6) {
    unint64_t v98 = v91 + 1;
  }
  else {
    unint64_t v98 = v91;
  }
  unsigned long long v99 = __PAIR128__(v90, v95) + __PAIR128__(v96, v98);
  unint64_t v101 = a2[2];
  unint64_t v100 = a2[3];
  unint64_t v102 = (v101 * (unsigned __int128)v100) >> 64;
  unint64_t v103 = v101 * v100;
  BOOL v6 = __CFADD__(v97, v103);
  uint64_t v104 = v97 + v103;
  if (v6) {
    unint64_t v105 = v102 + 1;
  }
  else {
    unint64_t v105 = v102;
  }
  BOOL v106 = __CFADD__((void)v99, v105);
  BOOL v6 = __CFADD__(v104, v103);
  uint64_t v107 = v104 + v103;
  if (v6) {
    unint64_t v108 = v102 + 1;
  }
  else {
    unint64_t v108 = v102;
  }
  unsigned long long v109 = v99 + __PAIR128__(v106, v108);
  result[5] = v107;
  unint64_t v110 = a2[2];
  uint64_t v111 = a2[3] * a2[3] + v109;
  uint64_t v112 = *((void *)&v109 + 1) + v109;
  BOOL v113 = __CFADD__(*((void *)&v109 + 1), (void)v109);
  unint64_t v114 = a2[4];
  unint64_t v115 = a2[5];
  uint64_t v116 = (v110 * (unsigned __int128)v114) >> 64;
  unint64_t v117 = v110 * v114;
  BOOL v6 = __CFADD__(v111, v117);
  uint64_t v118 = v111 + v117;
  if (v6) {
    uint64_t v119 = v116 + 1;
  }
  else {
    uint64_t v119 = v116;
  }
  BOOL v6 = __CFADD__(v112, v119);
  uint64_t v120 = v112 + v119;
  uint64_t v121 = v6;
  BOOL v6 = __CFADD__(v118, v117);
  uint64_t v122 = v118 + v117;
  if (v6) {
    uint64_t v123 = v116 + 1;
  }
  else {
    uint64_t v123 = v116;
  }
  BOOL v6 = __CFADD__(v120, v123);
  uint64_t v124 = v120 + v123;
  uint64_t v125 = v113 + v6 + v121;
  unint64_t v127 = *a2;
  unint64_t v126 = a2[1];
  unint64_t v128 = (v126 * (unsigned __int128)v115) >> 64;
  unint64_t v129 = v126 * v115;
  BOOL v6 = __CFADD__(v122, v129);
  uint64_t v130 = v122 + v129;
  if (v6) {
    unint64_t v131 = v128 + 1;
  }
  else {
    unint64_t v131 = v128;
  }
  BOOL v6 = __CFADD__(v124, v131);
  unint64_t v132 = v124 + v131;
  uint64_t v133 = v6;
  BOOL v6 = __CFADD__(v130, v129);
  uint64_t v134 = v130 + v129;
  if (v6) {
    unint64_t v135 = v128 + 1;
  }
  else {
    unint64_t v135 = v128;
  }
  unsigned long long v136 = __PAIR128__(v125, v132) + __PAIR128__(v133, v135);
  unint64_t v137 = a2[6];
  unint64_t v138 = (v127 * (unsigned __int128)v137) >> 64;
  unint64_t v139 = v127 * v137;
  BOOL v6 = __CFADD__(v134, v139);
  uint64_t v140 = v134 + v139;
  if (v6) {
    unint64_t v141 = v138 + 1;
  }
  else {
    unint64_t v141 = v138;
  }
  BOOL v142 = __CFADD__((void)v136, v141);
  BOOL v6 = __CFADD__(v140, v139);
  uint64_t v143 = v140 + v139;
  if (v6) {
    unint64_t v144 = v138 + 1;
  }
  else {
    unint64_t v144 = v138;
  }
  unsigned long long v145 = v136 + __PAIR128__(v142, v144);
  result[6] = v143;
  unint64_t v147 = a2[6];
  unint64_t v146 = a2[7];
  unint64_t v148 = a2[1];
  uint64_t v149 = (*a2 * (unsigned __int128)v146) >> 64;
  unint64_t v150 = *a2 * v146;
  uint64_t v151 = v150 + v145;
  if (__CFADD__(v150, (void)v145)) {
    uint64_t v152 = v149 + 1;
  }
  else {
    uint64_t v152 = v149;
  }
  uint64_t v153 = *((void *)&v145 + 1) + v152;
  BOOL v6 = __CFADD__(v151, v150);
  uint64_t v154 = v151 + v150;
  if (v6) {
    uint64_t v155 = v149 + 1;
  }
  else {
    uint64_t v155 = v149;
  }
  BOOL v6 = __CFADD__(v153, v155);
  uint64_t v156 = v153 + v155;
  uint64_t v157 = v6;
  if (__CFADD__(*((void *)&v145 + 1), v152)) {
    uint64_t v158 = v157 + 1;
  }
  else {
    uint64_t v158 = v157;
  }
  unint64_t v159 = (v148 * (unsigned __int128)v147) >> 64;
  unint64_t v160 = v148 * v147;
  BOOL v6 = __CFADD__(v154, v160);
  uint64_t v161 = v154 + v160;
  if (v6) {
    unint64_t v162 = v159 + 1;
  }
  else {
    unint64_t v162 = v159;
  }
  BOOL v6 = __CFADD__(v156, v162);
  unint64_t v163 = v156 + v162;
  uint64_t v164 = v6;
  BOOL v6 = __CFADD__(v161, v160);
  uint64_t v165 = v161 + v160;
  if (v6) {
    unint64_t v166 = v159 + 1;
  }
  else {
    unint64_t v166 = v159;
  }
  unsigned long long v167 = __PAIR128__(v158, v163) + __PAIR128__(v164, v166);
  unint64_t v169 = a2[4];
  unint64_t v168 = a2[5];
  unint64_t v170 = a2[2];
  unint64_t v171 = a2[3];
  unint64_t v172 = (v170 * (unsigned __int128)v168) >> 64;
  unint64_t v173 = v170 * v168;
  BOOL v6 = __CFADD__(v165, v173);
  uint64_t v174 = v165 + v173;
  if (v6) {
    unint64_t v175 = v172 + 1;
  }
  else {
    unint64_t v175 = v172;
  }
  BOOL v176 = __CFADD__((void)v167, v175);
  BOOL v6 = __CFADD__(v174, v173);
  uint64_t v177 = v174 + v173;
  if (v6) {
    unint64_t v178 = v172 + 1;
  }
  else {
    unint64_t v178 = v172;
  }
  unsigned long long v179 = v167 + __PAIR128__(v176, v178);
  unint64_t v180 = (v171 * (unsigned __int128)v169) >> 64;
  unint64_t v181 = v171 * v169;
  BOOL v6 = __CFADD__(v177, v181);
  uint64_t v182 = v177 + v181;
  if (v6) {
    unint64_t v183 = v180 + 1;
  }
  else {
    unint64_t v183 = v180;
  }
  BOOL v184 = __CFADD__((void)v179, v183);
  BOOL v6 = __CFADD__(v182, v181);
  uint64_t v185 = v182 + v181;
  if (v6) {
    ++v180;
  }
  unsigned long long v186 = v179 + __PAIR128__(v184, v180);
  result[7] = v185;
  unint64_t v187 = a2[3];
  uint64_t v188 = a2[4] * a2[4] + v186;
  uint64_t v189 = *((void *)&v186 + 1) + v186;
  BOOL v190 = __CFADD__(*((void *)&v186 + 1), (void)v186);
  unint64_t v191 = a2[5];
  unint64_t v192 = a2[6];
  uint64_t v193 = (v187 * (unsigned __int128)v191) >> 64;
  unint64_t v194 = v187 * v191;
  BOOL v6 = __CFADD__(v188, v194);
  uint64_t v195 = v188 + v194;
  if (v6) {
    uint64_t v196 = v193 + 1;
  }
  else {
    uint64_t v196 = v193;
  }
  BOOL v6 = __CFADD__(v189, v196);
  uint64_t v197 = v189 + v196;
  uint64_t v198 = v6;
  BOOL v6 = __CFADD__(v195, v194);
  uint64_t v199 = v195 + v194;
  if (v6) {
    uint64_t v200 = v193 + 1;
  }
  else {
    uint64_t v200 = v193;
  }
  BOOL v6 = __CFADD__(v197, v200);
  uint64_t v201 = v197 + v200;
  uint64_t v202 = v190 + v6 + v198;
  unint64_t v204 = a2[1];
  unint64_t v203 = a2[2];
  unint64_t v205 = (v203 * (unsigned __int128)v192) >> 64;
  unint64_t v206 = v203 * v192;
  BOOL v6 = __CFADD__(v199, v206);
  uint64_t v207 = v199 + v206;
  if (v6) {
    unint64_t v208 = v205 + 1;
  }
  else {
    unint64_t v208 = v205;
  }
  BOOL v6 = __CFADD__(v201, v208);
  unint64_t v209 = v201 + v208;
  uint64_t v210 = v6;
  BOOL v6 = __CFADD__(v207, v206);
  uint64_t v211 = v207 + v206;
  if (v6) {
    unint64_t v212 = v205 + 1;
  }
  else {
    unint64_t v212 = v205;
  }
  unsigned long long v213 = __PAIR128__(v202, v209) + __PAIR128__(v210, v212);
  unint64_t v214 = a2[7];
  unint64_t v215 = (v204 * (unsigned __int128)v214) >> 64;
  unint64_t v216 = v204 * v214;
  BOOL v6 = __CFADD__(v211, v216);
  uint64_t v217 = v211 + v216;
  if (v6) {
    unint64_t v218 = v215 + 1;
  }
  else {
    unint64_t v218 = v215;
  }
  BOOL v219 = __CFADD__((void)v213, v218);
  BOOL v6 = __CFADD__(v217, v216);
  uint64_t v220 = v217 + v216;
  if (v6) {
    unint64_t v221 = v215 + 1;
  }
  else {
    unint64_t v221 = v215;
  }
  unsigned long long v222 = v213 + __PAIR128__(v219, v221);
  result[8] = v220;
  unint64_t v224 = a2[6];
  unint64_t v223 = a2[7];
  unint64_t v225 = a2[2];
  unint64_t v226 = a2[3];
  uint64_t v227 = (v225 * (unsigned __int128)v223) >> 64;
  unint64_t v228 = v225 * v223;
  uint64_t v229 = v228 + v222;
  if (__CFADD__(v228, (void)v222)) {
    uint64_t v230 = v227 + 1;
  }
  else {
    uint64_t v230 = v227;
  }
  uint64_t v231 = *((void *)&v222 + 1) + v230;
  BOOL v6 = __CFADD__(v229, v228);
  uint64_t v232 = v229 + v228;
  if (v6) {
    uint64_t v233 = v227 + 1;
  }
  else {
    uint64_t v233 = v227;
  }
  BOOL v6 = __CFADD__(v231, v233);
  uint64_t v234 = v231 + v233;
  uint64_t v235 = v6;
  if (__CFADD__(*((void *)&v222 + 1), v230)) {
    uint64_t v236 = v235 + 1;
  }
  else {
    uint64_t v236 = v235;
  }
  unint64_t v237 = (v226 * (unsigned __int128)v224) >> 64;
  unint64_t v238 = v226 * v224;
  BOOL v6 = __CFADD__(v232, v238);
  uint64_t v239 = v232 + v238;
  if (v6) {
    unint64_t v240 = v237 + 1;
  }
  else {
    unint64_t v240 = v237;
  }
  BOOL v6 = __CFADD__(v234, v240);
  unint64_t v241 = v234 + v240;
  uint64_t v242 = v6;
  BOOL v6 = __CFADD__(v239, v238);
  uint64_t v243 = v239 + v238;
  if (v6) {
    unint64_t v244 = v237 + 1;
  }
  else {
    unint64_t v244 = v237;
  }
  unsigned long long v245 = __PAIR128__(v236, v241) + __PAIR128__(v242, v244);
  unint64_t v247 = a2[4];
  unint64_t v246 = a2[5];
  unint64_t v248 = (v247 * (unsigned __int128)v246) >> 64;
  unint64_t v249 = v247 * v246;
  BOOL v6 = __CFADD__(v243, v249);
  uint64_t v250 = v243 + v249;
  if (v6) {
    unint64_t v251 = v248 + 1;
  }
  else {
    unint64_t v251 = v248;
  }
  BOOL v252 = __CFADD__((void)v245, v251);
  BOOL v6 = __CFADD__(v250, v249);
  uint64_t v253 = v250 + v249;
  if (v6) {
    unint64_t v254 = v248 + 1;
  }
  else {
    unint64_t v254 = v248;
  }
  unsigned long long v255 = v245 + __PAIR128__(v252, v254);
  result[9] = v253;
  unint64_t v256 = a2[6];
  uint64_t v257 = a2[5] * a2[5] + v255;
  uint64_t v258 = *((void *)&v255 + 1) + v255;
  BOOL v259 = __CFADD__(*((void *)&v255 + 1), (void)v255);
  unint64_t v261 = a2[3];
  unint64_t v260 = a2[4];
  uint64_t v262 = (v260 * (unsigned __int128)v256) >> 64;
  unint64_t v263 = v260 * v256;
  BOOL v6 = __CFADD__(v257, v263);
  uint64_t v264 = v257 + v263;
  if (v6) {
    uint64_t v265 = v262 + 1;
  }
  else {
    uint64_t v265 = v262;
  }
  BOOL v6 = __CFADD__(v258, v265);
  uint64_t v266 = v258 + v265;
  uint64_t v267 = v6;
  BOOL v6 = __CFADD__(v264, v263);
  uint64_t v268 = v264 + v263;
  if (v6) {
    uint64_t v269 = v262 + 1;
  }
  else {
    uint64_t v269 = v262;
  }
  BOOL v6 = __CFADD__(v266, v269);
  uint64_t v270 = v266 + v269;
  uint64_t v271 = v259 + v6 + v267;
  unint64_t v272 = a2[7];
  unint64_t v273 = (v261 * (unsigned __int128)v272) >> 64;
  unint64_t v274 = v261 * v272;
  BOOL v6 = __CFADD__(v268, v274);
  uint64_t v275 = v268 + v274;
  if (v6) {
    unint64_t v276 = v273 + 1;
  }
  else {
    unint64_t v276 = v273;
  }
  BOOL v6 = __CFADD__(v270, v276);
  unint64_t v277 = v270 + v276;
  uint64_t v278 = v6;
  BOOL v6 = __CFADD__(v275, v274);
  uint64_t v279 = v275 + v274;
  if (v6) {
    unint64_t v280 = v273 + 1;
  }
  else {
    unint64_t v280 = v273;
  }
  unsigned long long v281 = __PAIR128__(v271, v277) + __PAIR128__(v278, v280);
  result[10] = v279;
  unint64_t v283 = a2[6];
  unint64_t v282 = a2[7];
  unint64_t v284 = a2[4];
  unint64_t v285 = a2[5];
  uint64_t v286 = (v284 * (unsigned __int128)v282) >> 64;
  unint64_t v287 = v284 * v282;
  uint64_t v288 = v287 + v281;
  if (__CFADD__(v287, (void)v281)) {
    uint64_t v289 = v286 + 1;
  }
  else {
    uint64_t v289 = v286;
  }
  uint64_t v290 = *((void *)&v281 + 1) + v289;
  BOOL v6 = __CFADD__(v288, v287);
  uint64_t v291 = v288 + v287;
  if (v6) {
    uint64_t v292 = v286 + 1;
  }
  else {
    uint64_t v292 = v286;
  }
  BOOL v6 = __CFADD__(v290, v292);
  uint64_t v293 = v290 + v292;
  uint64_t v294 = v6;
  if (__CFADD__(*((void *)&v281 + 1), v289)) {
    uint64_t v295 = v294 + 1;
  }
  else {
    uint64_t v295 = v294;
  }
  unint64_t v296 = (v285 * (unsigned __int128)v283) >> 64;
  unint64_t v297 = v285 * v283;
  BOOL v6 = __CFADD__(v291, v297);
  uint64_t v298 = v291 + v297;
  if (v6) {
    unint64_t v299 = v296 + 1;
  }
  else {
    unint64_t v299 = v296;
  }
  BOOL v6 = __CFADD__(v293, v299);
  unint64_t v300 = v293 + v299;
  uint64_t v301 = v6;
  BOOL v6 = __CFADD__(v298, v297);
  uint64_t v302 = v298 + v297;
  if (v6) {
    unint64_t v303 = v296 + 1;
  }
  else {
    unint64_t v303 = v296;
  }
  unsigned long long v304 = __PAIR128__(v295, v300) + __PAIR128__(v301, v303);
  result[11] = v302;
  unint64_t v305 = a2[5];
  uint64_t v306 = a2[6] * a2[6] + v304;
  uint64_t v307 = *((void *)&v304 + 1) + v304;
  BOOL v308 = __CFADD__(*((void *)&v304 + 1), (void)v304);
  unint64_t v309 = a2[7];
  uint64_t v310 = (v305 * (unsigned __int128)v309) >> 64;
  unint64_t v311 = v305 * v309;
  BOOL v6 = __CFADD__(v306, v311);
  uint64_t v312 = v306 + v311;
  if (v6) {
    uint64_t v313 = v310 + 1;
  }
  else {
    uint64_t v313 = v310;
  }
  BOOL v6 = __CFADD__(v307, v313);
  uint64_t v314 = v307 + v313;
  uint64_t v315 = v6;
  BOOL v6 = __CFADD__(v312, v311);
  uint64_t v316 = v312 + v311;
  if (v6) {
    uint64_t v317 = v310 + 1;
  }
  else {
    uint64_t v317 = v310;
  }
  BOOL v6 = __CFADD__(v314, v317);
  uint64_t v318 = v314 + v317;
  uint64_t v319 = v308 + v6 + v315;
  result[12] = v316;
  unint64_t v321 = a2[6];
  unint64_t v320 = a2[7];
  uint64_t v322 = (v321 * (unsigned __int128)v320) >> 64;
  unint64_t v323 = v321 * v320;
  BOOL v6 = __CFADD__(v323, v318);
  uint64_t v324 = v323 + v318;
  if (v6) {
    uint64_t v325 = v322 + 1;
  }
  else {
    uint64_t v325 = v322;
  }
  uint64_t v326 = v319 + v325;
  BOOL v6 = __CFADD__(v324, v323);
  uint64_t v327 = v324 + v323;
  if (v6) {
    uint64_t v328 = v322 + 1;
  }
  else {
    uint64_t v328 = v322;
  }
  BOOL v6 = __CFADD__(v326, v328);
  uint64_t v329 = v326 + v328;
  uint64_t v330 = v6;
  result[13] = v327;
  unint64_t v331 = a2[7];
  uint64_t v332 = (v331 * (unsigned __int128)v331) >> 64;
  unint64_t v333 = v331 * v331;
  BOOL v6 = __CFADD__(v333, v329);
  uint64_t v334 = v333 + v329;
  if (v6) {
    uint64_t v335 = v332 + 1;
  }
  else {
    uint64_t v335 = v332;
  }
  result[14] = v334;
  result[15] = v330 + __CFADD__(v319, v325) + v335;
  return result;
}

void *sub_244D1DB54(void *result, unint64_t *a2)
{
  uint64_t v2 = (*a2 * (unsigned __int128)*a2) >> 64;
  *uint64_t result = *a2 * *a2;
  unint64_t v3 = a2[1];
  uint64_t v4 = (*a2 * (unsigned __int128)v3) >> 64;
  unint64_t v5 = *a2 * v3;
  BOOL v6 = __CFADD__(v5, v2);
  uint64_t v7 = v5 + v2;
  if (v6) {
    uint64_t v8 = v4 + 1;
  }
  else {
    uint64_t v8 = v4;
  }
  BOOL v6 = __CFADD__(v7, v5);
  uint64_t v9 = v7 + v5;
  if (v6) {
    uint64_t v10 = v4 + 1;
  }
  else {
    uint64_t v10 = v4;
  }
  result[1] = v9;
  unint64_t v12 = *a2;
  unint64_t v11 = a2[1];
  uint64_t v13 = (v11 * (unsigned __int128)v11) >> 64;
  unint64_t v14 = v11 * v11;
  BOOL v6 = __CFADD__(v14, v10 + v8);
  unint64_t v15 = v14 + v10 + v8;
  if (v6) {
    uint64_t v16 = v13 + 1;
  }
  else {
    uint64_t v16 = v13;
  }
  BOOL v6 = __CFADD__(__CFADD__(v10, v8), v16);
  uint64_t v17 = __CFADD__(v10, v8) + v16;
  uint64_t v18 = v6;
  unint64_t v19 = a2[2];
  uint64_t v20 = (v12 * (unsigned __int128)v19) >> 64;
  unint64_t v21 = v12 * v19;
  BOOL v6 = __CFADD__(v15, v21);
  unint64_t v22 = v15 + v21;
  if (v6) {
    uint64_t v23 = v20 + 1;
  }
  else {
    uint64_t v23 = v20;
  }
  BOOL v6 = __CFADD__(v17, v23);
  uint64_t v24 = v17 + v23;
  uint64_t v25 = v6;
  BOOL v6 = __CFADD__(v22, v21);
  unint64_t v26 = v22 + v21;
  if (v6) {
    uint64_t v27 = v20 + 1;
  }
  else {
    uint64_t v27 = v20;
  }
  BOOL v6 = __CFADD__(v24, v27);
  uint64_t v28 = v24 + v27;
  uint64_t v29 = v18 + v6 + v25;
  result[2] = v26;
  unint64_t v31 = a2[2];
  unint64_t v30 = a2[3];
  unint64_t v32 = a2[1];
  uint64_t v33 = (*a2 * (unsigned __int128)v30) >> 64;
  unint64_t v34 = *a2 * v30;
  BOOL v6 = __CFADD__(v34, v28);
  uint64_t v35 = v34 + v28;
  if (v6) {
    uint64_t v36 = v33 + 1;
  }
  else {
    uint64_t v36 = v33;
  }
  uint64_t v37 = v29 + v36;
  BOOL v6 = __CFADD__(v35, v34);
  uint64_t v38 = v35 + v34;
  if (v6) {
    uint64_t v39 = v33 + 1;
  }
  else {
    uint64_t v39 = v33;
  }
  BOOL v6 = __CFADD__(v37, v39);
  uint64_t v40 = v37 + v39;
  uint64_t v41 = v6;
  if (__CFADD__(v29, v36)) {
    uint64_t v42 = v41 + 1;
  }
  else {
    uint64_t v42 = v41;
  }
  unint64_t v43 = (v32 * (unsigned __int128)v31) >> 64;
  unint64_t v44 = v32 * v31;
  BOOL v6 = __CFADD__(v38, v44);
  uint64_t v45 = v38 + v44;
  if (v6) {
    unint64_t v46 = v43 + 1;
  }
  else {
    unint64_t v46 = v43;
  }
  BOOL v6 = __CFADD__(v40, v46);
  unint64_t v47 = v40 + v46;
  uint64_t v48 = v6;
  BOOL v6 = __CFADD__(v45, v44);
  uint64_t v49 = v45 + v44;
  if (v6) {
    unint64_t v50 = v43 + 1;
  }
  else {
    unint64_t v50 = v43;
  }
  unsigned long long v51 = __PAIR128__(v42, v47) + __PAIR128__(v48, v50);
  result[3] = v49;
  unint64_t v52 = a2[1];
  uint64_t v53 = a2[2] * a2[2] + v51;
  uint64_t v54 = *((void *)&v51 + 1) + v51;
  BOOL v55 = __CFADD__(*((void *)&v51 + 1), (void)v51);
  unint64_t v56 = a2[3];
  uint64_t v57 = (v52 * (unsigned __int128)v56) >> 64;
  unint64_t v58 = v52 * v56;
  BOOL v6 = __CFADD__(v53, v58);
  uint64_t v59 = v53 + v58;
  if (v6) {
    uint64_t v60 = v57 + 1;
  }
  else {
    uint64_t v60 = v57;
  }
  BOOL v6 = __CFADD__(v54, v60);
  uint64_t v61 = v54 + v60;
  uint64_t v62 = v6;
  BOOL v6 = __CFADD__(v59, v58);
  uint64_t v63 = v59 + v58;
  if (v6) {
    uint64_t v64 = v57 + 1;
  }
  else {
    uint64_t v64 = v57;
  }
  BOOL v6 = __CFADD__(v61, v64);
  uint64_t v65 = v61 + v64;
  uint64_t v66 = v55 + v6 + v62;
  result[4] = v63;
  unint64_t v68 = a2[2];
  unint64_t v67 = a2[3];
  uint64_t v69 = (v68 * (unsigned __int128)v67) >> 64;
  unint64_t v70 = v68 * v67;
  BOOL v6 = __CFADD__(v70, v65);
  uint64_t v71 = v70 + v65;
  if (v6) {
    uint64_t v72 = v69 + 1;
  }
  else {
    uint64_t v72 = v69;
  }
  uint64_t v73 = v66 + v72;
  BOOL v6 = __CFADD__(v71, v70);
  uint64_t v74 = v71 + v70;
  if (v6) {
    uint64_t v75 = v69 + 1;
  }
  else {
    uint64_t v75 = v69;
  }
  BOOL v6 = __CFADD__(v73, v75);
  uint64_t v76 = v73 + v75;
  uint64_t v77 = v6;
  result[5] = v74;
  unint64_t v78 = a2[3];
  uint64_t v79 = (v78 * (unsigned __int128)v78) >> 64;
  unint64_t v80 = v78 * v78;
  BOOL v6 = __CFADD__(v80, v76);
  uint64_t v81 = v80 + v76;
  if (v6) {
    uint64_t v82 = v79 + 1;
  }
  else {
    uint64_t v82 = v79;
  }
  result[6] = v81;
  result[7] = v77 + __CFADD__(v66, v72) + v82;
  return result;
}

uint64_t sub_244D1DCD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(int *)(a2 + 8) < 1 || (**(unsigned char **)a2 & 1) == 0)
  {
    int v4 = 104;
    __int16 v5 = 73;
LABEL_6:
    sub_244D0B884(3, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/jacobi.c", v5);
    return 4294967294;
  }
  if (*(_DWORD *)(a2 + 16))
  {
    int v4 = 109;
    __int16 v5 = 79;
    goto LABEL_6;
  }
  sub_244D1756C((void *)a3);
  uint64_t v9 = sub_244D17610(a3);
  uint64_t v10 = sub_244D17610(a3);
  if (v10 && (unint64_t v11 = v10, sub_244D16764((void **)v9, a1)) && sub_244D16764((void **)v11, a2))
  {
    uint64_t v13 = (int *)(v9 + 1);
    int v12 = *((_DWORD *)v9 + 2);
    if (v12)
    {
      unsigned int v14 = 1;
      unint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = 0;
        unint64_t v11 = v9;
        uint64_t v9 = v15;
        uint64_t v17 = (uint64_t *)*v11;
        uint64_t v18 = v12;
        do
        {
          uint64_t v19 = *v17++;
          v16 |= v19;
          --v18;
        }
        while (v18);
        if (!v16) {
          break;
        }
        for (unint64_t i = 0; i >> 6 >= v12 || ((*(void *)(*v11 + 8 * (i >> 6)) >> i) & 1) == 0; ++i)
          ;
        if (!sub_244D17ED0((void **)v11, (uint64_t)v11, i)) {
          goto LABEL_42;
        }
        if (i)
        {
          if (*((_DWORD *)v9 + 2)) {
            uint64_t v21 = *(void *)*v9;
          }
          else {
            LOBYTE(v21) = 0;
          }
          v14 *= dword_244EB7074[v21 & 7];
        }
        int v22 = *v13;
        if (*((_DWORD *)v11 + 4))
        {
          if (v22) {
            uint64_t v23 = *(void *)*v11;
          }
          else {
            LOBYTE(v23) = 0;
          }
          LOBYTE(v24) = ~(_BYTE)v23;
        }
        else if (v22)
        {
          uint64_t v24 = *(void *)*v11;
        }
        else
        {
          LOBYTE(v24) = 0;
        }
        uint64_t v13 = (int *)(v9 + 1);
        if (*((_DWORD *)v9 + 2)) {
          uint64_t v25 = *(void *)*v9;
        }
        else {
          LOBYTE(v25) = 0;
        }
        if (!sub_244D17F9C((uint64_t)v9, (uint64_t)v9, (uint64_t)v11, a3)) {
          goto LABEL_42;
        }
        if ((v24 & v25 & 2) != 0) {
          unsigned int v14 = -v14;
        }
        *((_DWORD *)v11 + 4) = 0;
        int v12 = *v13;
        unint64_t v15 = v11;
        if (!*v13) {
          goto LABEL_47;
        }
      }
      unint64_t v11 = v15;
    }
    else
    {
      unsigned int v14 = 1;
    }
LABEL_47:
    if (sub_244D172C8((unsigned int *)v11)) {
      uint64_t result = v14;
    }
    else {
      uint64_t result = 0;
    }
  }
  else
  {
LABEL_42:
    uint64_t result = 4294967294;
  }
  if (!*(unsigned char *)(a3 + 40))
  {
    uint64_t v26 = *(void *)(a3 + 8);
    uint64_t v27 = *(void *)(a3 + 16) - 1;
    *(void *)(a3 + 16) = v27;
    *(void *)(a3 + 32) = *(void *)(v26 + 8 * v27);
  }
  return result;
}

double sub_244D1DF34(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  return result;
}

void sub_244D1DF50(void **a1)
{
  sub_244D166B0(a1);

  sub_244D166B0(a1 + 3);
}

void *sub_244D1DF88()
{
  uint64_t v0 = sub_244D43FF4(0x40uLL);
  uint64_t v1 = v0;
  if (v0) {
    sub_244D1DF34((uint64_t)v0);
  }
  return v1;
}

void **sub_244D1DFC0(void **a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (a1 != (void **)a2)
  {
    if (sub_244D16764(a1, a2) && sub_244D16764(v2 + 3, a2 + 24))
    {
      v2[6] = *(void **)(a2 + 48);
      v2[7] = *(void **)(a2 + 56);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t sub_244D1E024(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (!sub_244D1E0E8((uint64_t)a1, a2)) {
    return 0;
  }
  if (a3)
  {
    __int16 v5 = 0;
    goto LABEL_6;
  }
  BOOL v6 = sub_244D43FF4(0x30uLL);
  if (!v6) {
    return 0;
  }
  a3 = (uint64_t)v6;
  *(_OWORD *)((char *)v6 + 26) = 0u;
  *BOOL v6 = 0u;
  v6[1] = 0u;
  __int16 v5 = (unint64_t **)v6;
LABEL_6:
  int v7 = a1[8];
  a1[4] = 0;
  a1[2] = 0;
  if (sub_244D1E2A0((uint64_t)a1, v7 << 7)
    && sub_244D17728(0, (uint64_t)a1, (uint64_t)a1, (uint64_t)(a1 + 6), a3))
  {
    uint64_t v8 = sub_244D16BB4((uint64_t)a1, (int)a1[8]);
  }
  else
  {
    uint64_t v8 = 0;
  }
  sub_244D17500(v5);
  return v8;
}

uint64_t sub_244D1E0E8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int *)(a2 + 8);
  if (!v2) {
    goto LABEL_8;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  BOOL v6 = *(unsigned char **)a2;
  do
    v5 |= *(void *)&v6[8 * v4++];
  while (v2 != v4);
  if (!v5)
  {
LABEL_8:
    int v7 = 105;
    __int16 v8 = 170;
    goto LABEL_9;
  }
  if ((int)v2 < 1 || (*v6 & 1) == 0)
  {
    int v7 = 104;
    __int16 v8 = 174;
LABEL_9:
    sub_244D0B884(3, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/montgomery.c", v8);
    return 0;
  }
  if (*(_DWORD *)(a2 + 16))
  {
    int v7 = 109;
    __int16 v8 = 178;
    goto LABEL_9;
  }
  if (v2 >= 0x401)
  {
    uint64_t v10 = 0;
    uint64_t v11 = v2 - 1024;
    int v12 = (uint64_t *)(v6 + 0x2000);
    do
    {
      uint64_t v13 = *v12++;
      v10 |= v13;
      --v11;
    }
    while (v11);
    if (v10)
    {
      int v7 = 102;
      __int16 v8 = 182;
      goto LABEL_9;
    }
  }
  unsigned int v14 = (void *)(a1 + 24);
  if (!sub_244D16764((void **)(a1 + 24), a2))
  {
    int v7 = 68;
    __int16 v8 = 188;
    goto LABEL_9;
  }
  uint64_t v15 = *(unsigned int *)(a1 + 32);
  uint64_t v16 = 8 * v15 - 8;
  int v17 = *(_DWORD *)(a1 + 32);
  while (1)
  {
    BOOL v18 = __OFSUB__(v17--, 1);
    if (v17 < 0 != v18) {
      break;
    }
    uint64_t v19 = *(void *)(*v14 + v16);
    v16 -= 8;
    if (v19)
    {
      *(_DWORD *)(a1 + 32) = v17 + 1;
      goto LABEL_25;
    }
  }
  *(_DWORD *)(a1 + 32) = v15 & ((int)v15 >> 31);
  if ((v15 & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 40) = 0;
  }
LABEL_25:
  unint64_t v20 = 0;
  uint64_t v21 = 1;
  uint64_t v22 = 64;
  do
  {
    unint64_t v23 = v20;
    uint64_t v24 = -(v21 & 1);
    uint64_t v21 = (*(void *)*v14 & v24 & v21) + ((*(void *)*v14 & v24 ^ (unint64_t)v21) >> 1);
    unint64_t v20 = v24 & 0x8000000000000000 | (v23 >> 1);
    --v22;
  }
  while (v22);
  *(void *)(a1 + 48) = v20;
  *(void *)(a1 + 56) = 0;
  return 1;
}

uint64_t sub_244D1E2A0(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  char v2 = a2;
  int v4 = a2 >> 6;
  if (*(_DWORD *)(a1 + 8) <= (signed int)(a2 >> 6))
  {
    uint64_t result = sub_244D15DEC((void **)a1, (v4 + 1));
    if (!result) {
      return result;
    }
    uint64_t v6 = *(int *)(a1 + 8);
    if ((int)v6 <= v4)
    {
      uint64_t v7 = 8 * v6;
      int v8 = v4 - v6 + 1;
      do
      {
        *(void *)(*(void *)a1 + v7) = 0;
        v7 += 8;
        --v8;
      }
      while (v8);
    }
    *(_DWORD *)(a1 + 8) = v4 + 1;
  }
  uint64_t result = 1;
  *(void *)(*(void *)a1 + 8 * v4) |= 1 << (v2 & 0x3F);
  return result;
}

uint64_t sub_244D1E34C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 24;
  int v5 = sub_244D168EC((uint64_t *)(a1 + 24));
  if (v5 == 1)
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 8) = 0;
LABEL_3:
    unint64_t v6 = *(int *)(a1 + 32);
    return sub_244D16BB4(a1, v6);
  }
  else
  {
    int v8 = v5;
    int v9 = *(_DWORD *)(a1 + 32);
    if (sub_244D1E2A0(a1, v5 - 1) && sub_244D18C2C((void **)a1, a1, v9 - v8 + (v9 << 6) + 1, v4, a2))
    {
      int v10 = 6;
      while (sub_244D1A118(a1, a1, a1, a1, a2))
      {
        if (!--v10) {
          goto LABEL_3;
        }
      }
    }
    return 0;
  }
}

uint64_t sub_244D1E430(void *a1, pthread_rwlock_t *a2, uint64_t a3, uint64_t a4)
{
  sub_244D4BD50(a2);
  int v8 = (void **)*a1;
  sub_244D4BD90(a2);
  if (v8) {
    return 1;
  }
  sub_244D4BD70(a2);
  int v10 = (void **)*a1;
  if (!*a1)
  {
    int v10 = sub_244D1B1E0(a3, a4);
    *a1 = v10;
  }
  BOOL v9 = v10 != 0;
  sub_244D4BD90(a2);
  return v9;
}

uint64_t sub_244D1E4C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 16))
  {
    sub_244D0B884(3, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/montgomery.c", 323);
    return 0;
  }
  else
  {
    uint64_t v6 = *(int *)(a3 + 32);
    if (v6)
    {
      uint64_t result = sub_244D16BB4(a2, 2 * v6);
      if (result)
      {
        uint64_t result = sub_244D15DEC((void **)a1, *(int *)(a3 + 32));
        if (result)
        {
          unint64_t v8 = *(int *)(a3 + 32);
          *(_DWORD *)(a1 + 8) = v8;
          *(_DWORD *)(a1 + 16) = 0;
          BOOL v9 = *(unint64_t **)a1;
          int v10 = *(unint64_t **)a2;
          uint64_t v11 = *(int *)(a2 + 8);
          return sub_244D1E5EC(v9, v8, v10, v11, a3);
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      return 1;
    }
  }
  return result;
}

BOOL sub_244D1E588(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t v3 = *(int *)(a2 + 32);
  uint64_t v4 = *(int *)(a1 + 8);
  if (v4 <= v3) {
    return 1;
  }
  uint64_t v5 = 0;
  uint64_t v6 = v4 - v3;
  uint64_t v7 = (uint64_t *)(*(void *)a1 + 8 * v3);
  do
  {
    uint64_t v8 = *v7++;
    v5 |= v8;
    --v6;
  }
  while (v6);
  return v5 == 0;
}

void sub_244D1E5DC(unint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t **a4)
{
}

uint64_t sub_244D1E5EC(unint64_t *a1, unint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(int *)(a5 + 32);
  if (v5 == a2 && 2 * v5 == a4)
  {
    uint64_t v11 = *(unint64_t **)(a5 + 24);
    unint64_t v12 = 0;
    if (v5)
    {
      uint64_t v13 = *(void *)(a5 + 48);
      if (a2 <= 1) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = a2;
      }
      uint64_t v15 = a3;
      do
      {
        uint64_t v16 = sub_244D1CAC8(v15, v11, a2, *v15 * v13);
        unint64_t v17 = v15[a2];
        unint64_t v18 = v16 + v12 + v17;
        unint64_t v12 = (v12 | (v16 + v12 != 0)) & (unint64_t)(v18 <= v17);
        v15[a2] = v18;
        ++v15;
        --v14;
      }
      while (v14);
    }
    sub_244D18038(a1, &a3[a2], v12, v11, a2);
    return 1;
  }
  else
  {
    sub_244D0B884(3, 0, 66, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/montgomery.c", 294);
    return 0;
  }
}

void sub_244D1E6E4(void *a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  v5[18] = *MEMORY[0x263EF8340];
  if (a4 > 9 || 2 * a4 != a2) {
    abort();
  }
  if (a4 == 8)
  {
    sub_244D1D56C(a1, a3);
  }
  else if (a4 == 4)
  {
    sub_244D1DB54(a1, a3);
  }
  else
  {
    sub_244D1F038(a1, a3, a4, v5);
    sub_244D4413C(v5, 16 * a4);
  }
}

void sub_244D1E7F4(void *a1, uint64_t a2, unint64_t *a3, unint64_t a4, unint64_t *a5, unint64_t a6)
{
  if (a6 + a4 != a2) {
    abort();
  }
  if (a4 == 8 && a6 == 8)
  {
    sub_244D1CC3C(a1, a3, a5);
  }
  else
  {
    sub_244D1EC90(a1, a3, a4, a5, a6);
  }
}

unint64_t sub_244D1E858(uint64_t **a1)
{
  unint64_t result = 0;
  uint64_t v3 = **a1;
  uint64_t v4 = 1;
  uint64_t v5 = 64;
  do
  {
    uint64_t v6 = -(v4 & 1);
    uint64_t v4 = (v3 & v6 & v4) + ((v3 & v6 ^ (unint64_t)v4) >> 1);
    unint64_t result = v6 & 0x8000000000000000 | (result >> 1);
    --v5;
  }
  while (v5);
  return result;
}

uint64_t sub_244D1E89C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a2 + 8);
  int v9 = *(_DWORD *)(a3 + 8);
  signed int v10 = v8 - v9;
  if (v8 >= v9) {
    int v11 = *(_DWORD *)(a3 + 8);
  }
  else {
    int v11 = *(_DWORD *)(a2 + 8);
  }
  if (v8 <= v9) {
    int v12 = *(_DWORD *)(a3 + 8);
  }
  else {
    int v12 = *(_DWORD *)(a2 + 8);
  }
  sub_244D1756C((void *)a4);
  uint64_t result = (uint64_t)sub_244D17610(a4);
  if (result)
  {
    uint64_t v14 = (unint64_t **)result;
    uint64_t result = sub_244D15DEC((void **)a1, v12);
    if (result)
    {
      uint64_t result = sub_244D15DEC(v14, v12);
      if (result)
      {
        sub_244D1E978(*(unint64_t **)a1, *(unint64_t **)a2, *(unint64_t **)a3, v11, v10, *v14);
        *(_DWORD *)(a1 + 8) = v12;
        uint64_t result = 1;
      }
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v15 = *(void *)(a4 + 8);
    uint64_t v16 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v16;
    *(void *)(a4 + 32) = *(void *)(v15 + 8 * v16);
  }
  return result;
}

uint64_t sub_244D1E978(unint64_t *a1, unint64_t *a2, unint64_t *a3, int a4, signed int a5, unint64_t *a6)
{
  uint64_t v6 = a6;
  unint64_t v12 = sub_244D3B1B0(a6, a2, a3, a4, a5);
  sub_244D3B1B0(a1, a3, a2, a4, -a5);
  if (a5 >= 0) {
    int v13 = a5;
  }
  else {
    int v13 = -a5;
  }
  uint64_t result = -(uint64_t)v12;
  LODWORD(v15) = v13 + a4;
  if (v15)
  {
    uint64_t v15 = (int)v15;
    do
    {
      uint64_t v16 = *v6++;
      *a1 = v16 & (v12 - 1) | *a1 & result;
      ++a1;
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t sub_244D1EA28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(int *)(a2 + 8);
  int v6 = *(_DWORD *)(a3 + 8);
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    return 1;
  }
  sub_244D1756C((void *)a4);
  if (a1 != a2 && (unint64_t v12 = (void **)a1, a1 != a3)
    || (uint64_t result = (uint64_t)sub_244D17610(a4), (v12 = (void **)result) != 0))
  {
    *((_DWORD *)v12 + 4) = *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a2 + 16);
    if (v5 == 8 && v6 == 8)
    {
      uint64_t result = sub_244D15DEC(v12, 0x10uLL);
      if (result)
      {
        *((_DWORD *)v12 + 2) = 16;
        sub_244D1CC3C(*v12, *(unint64_t **)a2, *(unint64_t **)a3);
LABEL_34:
        if (v12 == (void **)a1 || (uint64_t result = (uint64_t)sub_244D16764((void **)a1, (uint64_t)v12)) != 0) {
          uint64_t result = 1;
        }
      }
    }
    else
    {
      int v13 = v6 + v5;
      if ((int)v5 >= 16 && v6 >= 16 && (v5 - v6 + 1) <= 2)
      {
        if ((int)v5 - v6 >= 0) {
          unint64_t v14 = v5;
        }
        else {
          unint64_t v14 = v6;
        }
        char v15 = sub_244D16874(v14);
        uint64_t result = (uint64_t)sub_244D17610(a4);
        if (!result) {
          goto LABEL_37;
        }
        uint64_t v16 = (unint64_t **)result;
        char v17 = v15 - 1;
        signed int v18 = 1 << (v15 - 1);
        if ((int)v5 <= v18 && v6 <= v18)
        {
          uint64_t result = sub_244D15DEC((void **)result, 4 << v17);
          if (!result) {
            goto LABEL_37;
          }
          uint64_t result = sub_244D15DEC(v12, 2 << v17);
          if (!result) {
            goto LABEL_37;
          }
          sub_244D3B5D8(*v12, *(unint64_t **)a2, *(unint64_t **)a3, v18, (v5 - v18), (v6 - v18), *v16);
        }
        else
        {
          uint64_t result = sub_244D15DEC((void **)result, 8 << v17);
          if (!result) {
            goto LABEL_37;
          }
          uint64_t result = sub_244D15DEC(v12, 4 << v17);
          if (!result) {
            goto LABEL_37;
          }
          sub_244D3B25C(*v12, *(unint64_t **)a2, *(unint64_t **)a3, v18, v5 - v18, v6 - v18, *v16);
        }
        *((_DWORD *)v12 + 2) = v6 + v5;
        goto LABEL_34;
      }
      uint64_t result = sub_244D15DEC(v12, v13);
      if (result)
      {
        *((_DWORD *)v12 + 2) = v13;
        sub_244D1EC90(*v12, *(unint64_t **)a2, v5, *(unint64_t **)a3, v6);
        goto LABEL_34;
      }
    }
  }
LABEL_37:
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v20 = *(void *)(a4 + 8);
    uint64_t v21 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v21;
    *(void *)(a4 + 32) = *(void *)(v20 + 8 * v21);
  }
  return result;
}

void sub_244D1EC90(void *a1, unint64_t *a2, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  if (a3 < a5) {
    unint64_t v6 = a5;
  }
  else {
    unint64_t v6 = a3;
  }
  if (a3 < a5) {
    BOOL v7 = a2;
  }
  else {
    BOOL v7 = a4;
  }
  if (a3 < a5) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = a5;
  }
  if (a3 < a5) {
    int v9 = a4;
  }
  else {
    int v9 = a2;
  }
  if (v8)
  {
    a1[v6] = sub_244D17E10(a1, v9, v6, *v7);
    if (v8 != 1)
    {
      uint64_t v10 = 0;
      int v11 = v7 + 2;
      unint64_t v12 = 4 - v8;
      int v13 = (char *)&a1[v6 + 4];
      do
      {
        *(void *)&v13[v10 * 8 - 24] = sub_244D1CAC8(&a1[v10 + 1], v9, v6, v11[v10 - 1]);
        if (v12 == 2) {
          break;
        }
        *(void *)&v13[v10 * 8 - 16] = sub_244D1CAC8(&a1[v10 + 2], v9, v6, v11[v10]);
        if (v12 == 1) {
          break;
        }
        *(void *)&v13[v10 * 8 - 8] = sub_244D1CAC8(&a1[v10 + 3], v9, v6, v11[v10 + 1]);
        if (!v12) {
          break;
        }
        *(void *)&v13[v10 * 8] = sub_244D1CAC8(&a1[v10 + 4], v9, v6, v11[v10 + 2]);
        v12 += 4;
        v10 += 4;
      }
      while (v12 != 3);
    }
  }
  else if (8 * v6)
  {
    bzero(a1, 8 * v6);
  }
}

uint64_t sub_244D1EDFC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(int *)(a1 + 8);
  if (v2)
  {
    if (a2)
    {
      uint64_t v4 = sub_244D17E10(*(void **)a1, *(unint64_t **)a1, v2, a2);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t result = sub_244D15DEC((void **)a1, *(int *)(a1 + 8) + 1);
        if (!result) {
          return result;
        }
        BOOL v7 = *(unint64_t **)a1;
        uint64_t v8 = *(int *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = v8 + 1;
        v7[v8] = v5;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
    }
  }
  return 1;
}

uint64_t sub_244D1EE78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if ((int)v4 <= 0)
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    return 1;
  }
  sub_244D1756C((void *)a3);
  BOOL v7 = (unint64_t *)a1;
  if (a2 == a1) {
    BOOL v7 = sub_244D17610(a3);
  }
  uint64_t v8 = sub_244D17610(a3);
  uint64_t result = 0;
  if (v7)
  {
    if (v8)
    {
      uint64_t result = sub_244D15DEC((void **)v7, 2 * v4);
      if (result)
      {
        if (v4 == 8)
        {
          sub_244D1D56C((void *)*v7, *(unint64_t **)a2);
          goto LABEL_20;
        }
        if (v4 == 4)
        {
          sub_244D1DB54((void *)*v7, *(unint64_t **)a2);
LABEL_20:
          *((_DWORD *)v7 + 4) = 0;
          *((_DWORD *)v7 + 2) = 2 * v4;
          if (v7 == (unint64_t *)a1 || (uint64_t result = (uint64_t)sub_244D16764((void **)a1, (uint64_t)v7)) != 0) {
            uint64_t result = 1;
          }
          goto LABEL_23;
        }
        if (v4 <= 0xF)
        {
          uint64_t v10 = (void *)*v7;
          int v11 = *(unint64_t **)a2;
          unint64_t v12 = (uint64_t *)&v15;
LABEL_19:
          sub_244D1F038(v10, v11, v4, v12);
          goto LABEL_20;
        }
        if ((v4 & (v4 - 1)) != 0)
        {
          uint64_t result = sub_244D15DEC((void **)v8, 2 * v4);
          if (result)
          {
            uint64_t v10 = (void *)*v7;
            int v11 = *(unint64_t **)a2;
            unint64_t v12 = (uint64_t *)*v8;
            goto LABEL_19;
          }
        }
        else
        {
          uint64_t result = sub_244D15DEC((void **)v8, 4 * (int)v4);
          if (result)
          {
            sub_244D1F140((uint64_t *)*v7, *(unint64_t **)a2, v4, (unint64_t *)*v8);
            goto LABEL_20;
          }
        }
      }
    }
  }
LABEL_23:
  if (!*(unsigned char *)(a3 + 40))
  {
    uint64_t v13 = *(void *)(a3 + 8);
    uint64_t v14 = *(void *)(a3 + 16) - 1;
    *(void *)(a3 + 16) = v14;
    *(void *)(a3 + 32) = *(void *)(v13 + 8 * v14);
  }
  return result;
}

void *sub_244D1F038(void *result, unint64_t *a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    BOOL v7 = result;
    unint64_t v8 = 2 * a3;
    result[2 * a3 - 1] = 0;
    *uint64_t result = 0;
    unint64_t v9 = a3 - 1;
    if (v9)
    {
      result[a3] = sub_244D17E10(result + 1, a2 + 1, v9, *a2);
      if (a3 >= 3)
      {
        unint64_t v10 = a3 - 2;
        int v11 = v7 + 3;
        unint64_t v12 = &v7[a3 + 1];
        uint64_t v13 = a2 + 2;
        do
        {
          *v12++ = sub_244D1CAC8(v11, v13, v10, *(v13 - 1));
          v11 += 2;
          ++v13;
          --v10;
        }
        while (v10);
      }
    }
    sub_244D15EB4(v7, v7, v7, v8);
    sub_244D1CBBC(a4, a2, a3);
    return (void *)sub_244D15EB4(v7, v7, a4, v8);
  }
  return result;
}

void *sub_244D1F140(uint64_t *a1, unint64_t *a2, unint64_t a3, unint64_t *a4)
{
  if (a3 == 8)
  {
    return sub_244D1D56C(a1, a2);
  }
  else if (a3 > 0xF)
  {
    unint64_t v9 = a3 >> 1;
    unint64_t v10 = 2 * a3;
    unint64_t v11 = sub_244D16544(&a4[a3 >> 1], a2, &a2[a3 >> 1], a3 >> 1);
    sub_244D16544(a4, &a2[a3 >> 1], a2, a3 >> 1);
    uint64_t v12 = 0;
    do
    {
      a4[v12] = a4[(a3 >> 1) + v12] & (v11 - 1) | a4[v12] & -(uint64_t)v11;
      ++v12;
    }
    while (v9 != v12);
    uint64_t v13 = &a4[a3];
    sub_244D1F140(v13, a4, a3 >> 1, &a4[2 * a3]);
    sub_244D1F140(a1, a2, a3 >> 1, &a4[2 * a3]);
    sub_244D1F140(&a1[a3], &a2[a3 >> 1], a3 >> 1, &a4[2 * a3]);
    uint64_t v14 = sub_244D15EB4(a4, a1, &a1[a3], a3);
    unint64_t v15 = sub_244D16544(v13, a4, v13, a3);
    uint64_t result = (void *)sub_244D15EB4(&a1[v9], &a1[v9], (uint64_t *)v13, a3);
    if (v9 + a3 < v10)
    {
      uint64_t v16 = (char *)result + v14 - v15;
      unint64_t v17 = a3 - v9;
      signed int v18 = &a1[v9 + a3];
      do
      {
        uint64_t v19 = &v16[*v18];
        uint64_t v16 = (char *)__CFADD__(*v18, v16);
        *v18++ = (uint64_t)v19;
        --v17;
      }
      while (v17);
    }
  }
  else
  {
    return sub_244D1F038(a1, a2, a3, (uint64_t *)a4);
  }
  return result;
}

void *sub_244D1F338(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a3;
  result[1] = a2;
  return result;
}

uint64_t sub_244D1F340(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a2, a3, a1);
  }
  else {
    return 1;
  }
}

uint64_t sub_244D1F364(uint64_t a1, int a2, int a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  if (a2 > 3746)
  {
    int v11 = 3;
LABEL_13:
    BOOL v12 = a3 != 0;
    goto LABEL_14;
  }
  if (a2 > 1344)
  {
    int v11 = 4;
    goto LABEL_13;
  }
  if (a2 > 475)
  {
    int v11 = 5;
    goto LABEL_13;
  }
  if (a2 > 399)
  {
    int v11 = 6;
    goto LABEL_13;
  }
  if (a2 > 346)
  {
    int v11 = 7;
    goto LABEL_13;
  }
  if (a2 >= 308)
  {
    int v11 = 8;
    goto LABEL_13;
  }
  if (a2 <= 1)
  {
    __int16 v45 = 393;
LABEL_105:
    sub_244D0B884(3, 0, 103, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/prime.c", v45);
    return 0;
  }
  if (a2 <= 0x36) {
    int v11 = 34;
  }
  else {
    int v11 = 27;
  }
  BOOL v12 = a3 != 0;
  if (a2 == 2 && a3)
  {
    __int16 v45 = 397;
    goto LABEL_105;
  }
LABEL_14:
  uint64_t v13 = sub_244D43FF4(0x30uLL);
  if (!v13) {
    return 0;
  }
  uint64_t v14 = (uint64_t)v13;
  uint64_t v49 = a5;
  *(_OWORD *)((char *)v13 + 26) = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  *((_OWORD *)v13 + 1) = 0u;
  sub_244D1756C(v13);
  unint64_t v15 = sub_244D17610(v14);
  if (v15)
  {
    uint64_t v16 = (uint64_t)v15;
    uint64_t v17 = 0;
    uint64_t v52 = (uint64_t)a4;
    BOOL v50 = v12;
    while (1)
    {
LABEL_17:
      if (!a4)
      {
        while (sub_244D20780(a1, a2, 1, 1u))
        {
          if (!sub_244D1F95C((unsigned int *)a1)) {
            goto LABEL_69;
          }
        }
        goto LABEL_91;
      }
      unsigned int v51 = v17;
      sub_244D1756C((void *)v14);
      signed int v18 = sub_244D17610(v14);
      uint64_t v19 = (uint64_t)v18;
      if (!v12)
      {
        if (!v18) {
          goto LABEL_37;
        }
        BOOL v24 = 1;
        if (sub_244D20780(a1, a2, 0, 1u))
        {
          if (sub_244D17728(0, v19, a1, (uint64_t)a4, v14) && sub_244D16310(a1, a1, v19))
          {
            if (v49)
            {
              if (!sub_244D15B90(a1, a1, (uint64_t)v49)) {
                goto LABEL_37;
              }
LABEL_43:
              if (*(int *)(a1 + 8) <= 16) {
                uint64_t v27 = 512;
              }
              else {
                uint64_t v27 = 1024;
              }
              for (uint64_t i = 1; i != v27; ++i)
              {
                while (1)
                {
                  unsigned int v29 = sub_244D193AC(a1, (unsigned __int16)word_244EB74E0[i]);
                  BOOL v24 = v29 < 2;
                  if (v29 > 1) {
                    break;
                  }
                  uint64_t i = 1;
                  if (!sub_244D15B90(a1, a1, (uint64_t)a4)) {
                    goto LABEL_38;
                  }
                }
              }
            }
            else
            {
              BOOL v24 = 1;
              if (sub_244D15FB8(a1, 1uLL)) {
                goto LABEL_43;
              }
            }
          }
          else
          {
LABEL_37:
            BOOL v24 = 1;
          }
        }
LABEL_38:
        if (!*(unsigned char *)(v14 + 40))
        {
          uint64_t v25 = *(void *)(v14 + 8);
          uint64_t v26 = *(void *)(v14 + 16) - 1;
          *(void *)(v14 + 16) = v26;
          *(void *)(v14 + 32) = *(void *)(v25 + 8 * v26);
        }
        BOOL v12 = v50;
        uint64_t v17 = v51;
        if (v24) {
          goto LABEL_91;
        }
        goto LABEL_69;
      }
      uint64_t v20 = (uint64_t *)sub_244D17610(v14);
      uint64_t v21 = sub_244D17610(v14);
      if (!v21) {
        goto LABEL_65;
      }
      uint64_t v22 = (uint64_t)v21;
      if (!sub_244D1B5D8((uint64_t)v21, a4)) {
        goto LABEL_65;
      }
      char v23 = 1;
      if (!sub_244D20780((uint64_t)v20, a2 - 1, 0, 1u)) {
        goto LABEL_66;
      }
      if (!sub_244D17728(0, v19, (uint64_t)v20, v22, v14)
        || !sub_244D16310((uint64_t)v20, (uint64_t)v20, v19))
      {
        goto LABEL_65;
      }
      if (v49)
      {
        if (!sub_244D1B5D8(v19, v49) || !sub_244D15B90((uint64_t)v20, (uint64_t)v20, v19)) {
          goto LABEL_65;
        }
      }
      else
      {
        char v23 = 1;
        if (!sub_244D15FB8((uint64_t)v20, 1uLL)) {
          goto LABEL_66;
        }
      }
      if (!sub_244D18E1C(a1, v20)) {
        goto LABEL_65;
      }
      char v23 = 1;
      if (sub_244D15FB8(a1, 1uLL)) {
        break;
      }
LABEL_66:
      if (!*(unsigned char *)(v14 + 40))
      {
        uint64_t v33 = *(void *)(v14 + 8);
        uint64_t v34 = *(void *)(v14 + 16) - 1;
        *(void *)(v14 + 16) = v34;
        *(void *)(v14 + 32) = *(void *)(v33 + 8 * v34);
      }
      BOOL v12 = v50;
      uint64_t v17 = v51;
      if (v23) {
        goto LABEL_91;
      }
LABEL_69:
      if (a6 && !(*(unsigned int (**)(void, uint64_t, uint64_t))(a6 + 8))(0, v17, a6)) {
        goto LABEL_91;
      }
      uint64_t v17 = (v17 + 1);
      if (v12)
      {
        a4 = (uint64_t *)v52;
        if (sub_244D1B5D8(v16, (uint64_t *)a1))
        {
          uint64_t v35 = 0;
          while (1)
          {
            int v54 = 0;
            int v36 = sub_244D1FE18(&v54, a1, 1, v14, 0, 0);
            int v37 = v54;
            if (!v36) {
              int v37 = -1;
            }
            if (v37 == -1) {
              break;
            }
            if (!v37) {
              goto LABEL_17;
            }
            int v55 = 0;
            int v38 = sub_244D1FE18(&v55, v16, 1, v14, 0, 0);
            int v39 = v55;
            if (!v38) {
              int v39 = -1;
            }
            if (v39 == -1) {
              break;
            }
            if (!v39) {
              goto LABEL_17;
            }
            if (a6 && !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a6 + 8))(1, v35, a6)) {
              break;
            }
            uint64_t v35 = (v35 + 1);
            if (v11 == v35) {
              goto LABEL_96;
            }
          }
        }
        goto LABEL_91;
      }
      int v53 = 0;
      int v40 = sub_244D1FE18(&v53, a1, v11, v14, 0, a6);
      int v41 = v53;
      if (!v40) {
        int v41 = -1;
      }
      a4 = (uint64_t *)v52;
      if (v41)
      {
        uint64_t v42 = 0;
        if (v41 != -1) {
LABEL_96:
        }
          uint64_t v42 = 1;
        goto LABEL_92;
      }
    }
    uint64_t v30 = 512;
    if (*(int *)(a1 + 8) > 16) {
      uint64_t v30 = 1024;
    }
    uint64_t v47 = v30;
    uint64_t v48 = (uint64_t)v20;
    uint64_t v31 = 1;
    while (1)
    {
      while (1)
      {
        unsigned int v32 = (unsigned __int16)word_244EB74E0[v31];
        if (!sub_244D193AC(a1, v32) || !sub_244D193AC(v48, v32)) {
          break;
        }
        char v23 = 0;
        if (++v31 == v47) {
          goto LABEL_66;
        }
      }
      if (!sub_244D15B90(a1, a1, v52)) {
        break;
      }
      uint64_t v31 = 1;
      char v23 = 1;
      if (!sub_244D15B90(v48, v48, v22)) {
        goto LABEL_66;
      }
    }
LABEL_65:
    char v23 = 1;
    goto LABEL_66;
  }
LABEL_91:
  uint64_t v42 = 0;
LABEL_92:
  if (!*(unsigned char *)(v14 + 40))
  {
    uint64_t v43 = *(void *)(v14 + 8);
    uint64_t v44 = *(void *)(v14 + 16) - 1;
    *(void *)(v14 + 16) = v44;
    *(void *)(v14 + 32) = *(void *)(v43 + 8 * v44);
  }
  sub_244D17500((unint64_t **)v14);
  return v42;
}

uint64_t sub_244D1F914(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  unsigned int v6 = 0;
  if (sub_244D1FE18(&v6, a1, a2, a3, a4, a5)) {
    return v6;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL sub_244D1F95C(unsigned int *a1)
{
  unsigned __int16 v3 = 0;
  BOOL result = sub_244D1F9A8(&v3, (uint64_t)a1);
  if (result) {
    return !sub_244D17320(a1, v3);
  }
  return result;
}

BOOL sub_244D1F9A8(unsigned __int16 *a1, uint64_t a2)
{
  if (*(int *)(a2 + 8) <= 16) {
    unint64_t v4 = 512;
  }
  else {
    unint64_t v4 = 1024;
  }
  unsigned __int16 v5 = 3;
  if (sub_244D193AC(a2, 3u))
  {
    uint64_t v7 = 2;
    while (v4 != v7)
    {
      unsigned __int16 v5 = word_244EB74E0[v7++];
      if (!sub_244D193AC(a2, v5))
      {
        BOOL result = v7 - 1 < v4;
        goto LABEL_10;
      }
    }
    return 0;
  }
  else
  {
    BOOL result = 1;
LABEL_10:
    *a1 = v5;
  }
  return result;
}

uint64_t sub_244D1FA60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = sub_244D17610(a3);
  *(void *)(a1 + 8) = sub_244D17610(a3);
  *(void *)(a1 + 16) = sub_244D17610(a3);
  unsigned int v6 = sub_244D17610(a3);
  *(void *)(a1 + 24) = v6;
  uint64_t v7 = *(void *)a1;
  if (!*(void *)a1) {
    return 0;
  }
  if (!*(void *)(a1 + 8)) {
    return 0;
  }
  if (!*(void *)(a1 + 16)) {
    return 0;
  }
  if (!v6) {
    return 0;
  }
  sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
  if (!sub_244D163DC(v7, a2 + 24, (uint64_t)&qword_268EBEE70)) {
    return 0;
  }
  uint64_t v8 = *(void *)a1;
  unsigned int v9 = sub_244D1FB94(*(void *)a1);
  *(_DWORD *)(a1 + 36) = v9;
  if (!sub_244D1C8C4(*(void *)(a1 + 8), v8, v9, a3)) {
    return 0;
  }
  *(_DWORD *)(a1 + 32) = sub_244D168EC((uint64_t *)(a2 + 24));
  if (!sub_244D1AE1C(*(void *)(a1 + 16), a2, a3)) {
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a1 + 24);

  return sub_244D163DC(v10, a2 + 24, v11);
}

unint64_t sub_244D1FB94(unint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 8);
  if ((int)v1 < 1) {
    return 0;
  }
  unint64_t v2 = (unint64_t **)result;
  uint64_t v3 = 0;
  LODWORD(result) = 0;
  uint64_t v4 = 0;
  unsigned __int16 v5 = *v2;
  uint64_t v6 = v1 << 6;
  do
  {
    unint64_t v7 = *v5++;
    uint64_t v8 = (uint64_t)(((v7 << 32) - 1) & ~(v7 << 32)) >> 63;
    int v9 = v8 & 0x20;
    unint64_t v10 = v8 & HIDWORD(v7) | v7 & ~v8;
    uint64_t v11 = (uint64_t)(((v10 << 48) - 1) & ~(v10 << 48)) >> 63;
    int v12 = v11 & 0x10;
    unint64_t v13 = v11 & (v10 >> 16) | v10 & ~v11;
    uint64_t v14 = (v7 - 1) & ~v7;
    uint64_t v15 = (uint64_t)(((v13 << 56) - 1) & ~(v13 << 56)) >> 63;
    int v16 = v15 & 8;
    int v17 = v12 | v9;
    unint64_t v18 = v15 & (v13 >> 8) | v13 & ~v15;
    uint64_t v19 = (uint64_t)(((v18 << 60) - 1) & ~(v18 << 60)) >> 63;
    int v20 = v19 & 4;
    uint64_t v21 = v19 & (v18 >> 4) | v18 & ~v19;
    int v22 = v17 | v16;
    uint64_t v23 = (((v21 << 62) - 1) & ~(v21 << 62)) >> 63;
    int v24 = v23 & 2;
    uint64_t v25 = v23 & (v21 >> 2) | v21 & ~v23;
    LODWORD(v23) = (v14 >> 63) | v4;
    v4 |= ~(v14 >> 63);
    BOOL result = (v3 | v22 | v20 | v24 | ((((v25 << 63) - 1) & (unint64_t)~(v25 << 63)) >> 63)) & ~v23 | result;
    v3 += 64;
  }
  while (v6 != v3);
  return result;
}

uint64_t sub_244D1FCB8(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_244D1756C((void *)a5);
  uint64_t result = (uint64_t)sub_244D17610(a5);
  if (result)
  {
    uint64_t v11 = result;
    uint64_t result = sub_244D1A91C(result, a3, *(void *)(a1 + 8), a4 + 24, a5, a4);
    if (result)
    {
      uint64_t result = sub_244D1A118(v11, v11, a4, a4, a5);
      if (result)
      {
        BOOL v12 = sub_244D17428(v11, *(void *)(a1 + 16));
        uint64_t v13 = -(uint64_t)(sub_244D17428(v11, *(void *)(a1 + 24)) | v12);
        if (*(int *)(a1 + 32) >= 2)
        {
          int v14 = 1;
          do
          {
            if (v14 == *(_DWORD *)(a1 + 36)) {
              uint64_t v15 = ~v13;
            }
            else {
              uint64_t v15 = 0;
            }
            if (v15) {
              break;
            }
            uint64_t result = sub_244D1A118(v11, v11, v11, a4, a5);
            if (!result) {
              goto LABEL_14;
            }
            v13 |= -(uint64_t)sub_244D17428(v11, *(void *)(a1 + 24));
            if ((sub_244D17428(v11, *(void *)(a1 + 16)) & (unint64_t)~v13) != 0) {
              break;
            }
            ++v14;
          }
          while (v14 < *(_DWORD *)(a1 + 32));
        }
        *a2 = v13 & 1;
        uint64_t result = 1;
      }
    }
  }
LABEL_14:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v16 = *(void *)(a5 + 8);
    uint64_t v17 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v17;
    *(void *)(a5 + 32) = *(void *)(v16 + 8 * v17);
  }
  return result;
}

uint64_t sub_244D1FE18(_DWORD *a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  *a1 = 0;
  sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
  if ((int)sub_244D17194(a2, (uint64_t)&qword_268EBEE70) < 1) {
    return 1;
  }
  if (*(int *)(a2 + 8) < 1 || (**(unsigned char **)a2 & 1) == 0)
  {
    BOOL v12 = (unsigned int *)a2;
    uint64_t v13 = 2;
LABEL_5:
    *a1 = sub_244D17320(v12, v13);
    return 1;
  }
  if (sub_244D17320((unsigned int *)a2, 3))
  {
    uint64_t v14 = 1;
    *a1 = 1;
    return v14;
  }
  if (a5)
  {
    LOWORD(v34[0]) = 0;
    if (sub_244D1F9A8((unsigned __int16 *)v34, a2))
    {
      uint64_t v13 = LOWORD(v34[0]);
      BOOL v12 = (unsigned int *)a2;
      goto LABEL_5;
    }
    if (a6 && !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a6 + 8))(1, 0xFFFFFFFFLL, a6)) {
      return 0;
    }
  }
  if (!a3)
  {
    int v16 = sub_244D168EC((uint64_t *)a2);
    if (v16 <= 3746)
    {
      if (v16 <= 1344)
      {
        if (v16 <= 475)
        {
          if (v16 <= 399)
          {
            if (v16 <= 346)
            {
              if (v16 <= 307)
              {
                if (v16 <= 54) {
                  a3 = 34;
                }
                else {
                  a3 = 27;
                }
              }
              else
              {
                a3 = 8;
              }
            }
            else
            {
              a3 = 7;
            }
          }
          else
          {
            a3 = 6;
          }
        }
        else
        {
          a3 = 5;
        }
      }
      else
      {
        a3 = 4;
      }
    }
    else
    {
      a3 = 3;
    }
  }
  if (a4)
  {
    uint64_t v17 = 0;
    goto LABEL_35;
  }
  unint64_t v18 = sub_244D43FF4(0x30uLL);
  if (!v18) {
    return 0;
  }
  a4 = (uint64_t)v18;
  *(_OWORD *)((char *)v18 + 26) = 0u;
  *unint64_t v18 = 0u;
  v18[1] = 0u;
  uint64_t v17 = (unint64_t **)v18;
LABEL_35:
  sub_244D1756C((void *)a4);
  uint64_t v19 = sub_244D17610(a4);
  int v20 = sub_244D1A0A4(a2, a4);
  uint64_t v21 = v20;
  uint64_t v14 = 0;
  uint64_t v35 = 0;
  memset(v34, 0, sizeof(v34));
  if (v19 && v20)
  {
    if (sub_244D1FA60((uint64_t)v34, (uint64_t)v20, a4))
    {
      uint64_t v31 = v17;
      uint64_t v22 = 0;
      uint64_t v23 = a3;
      unsigned int v24 = 1;
      uint64_t v25 = *(void *)&v34[0];
      while (1)
      {
        int v33 = 0;
        if (!sub_244D2013C((uint64_t)v19, (unsigned int *)&v33, 2uLL, v25)
          || (uint64_t v26 = v33, v32 = 0, !sub_244D1FCB8((uint64_t)v34, &v32, (uint64_t)v19, (uint64_t)v21, a4)))
        {
LABEL_51:
          uint64_t v14 = 0;
          goto LABEL_53;
        }
        if (!v32) {
          break;
        }
        if (a6 && !(*(unsigned int (**)(uint64_t, void, uint64_t))(a6 + 8))(1, v24 - 1, a6)) {
          goto LABEL_51;
        }
        v22 += v26;
        BOOL v28 = v24++ < 0x10;
        if (!(v28 | ((((v22 - v23) ^ v22 | v22 ^ v23) ^ v22) >> 63)))
        {
          uint64_t v14 = 1;
          *a1 = 1;
          goto LABEL_53;
        }
      }
      *a1 = 0;
      uint64_t v14 = 1;
LABEL_53:
      uint64_t v17 = v31;
    }
    else
    {
      uint64_t v14 = 0;
    }
  }
  sub_244D1A288(v21);
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v29 = *(void *)(a4 + 8);
    uint64_t v30 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v30;
    *(void *)(a4 + 32) = *(void *)(v29 + 8 * v30);
  }
  sub_244D17500(v17);
  return v14;
}

uint64_t sub_244D2013C(uint64_t a1, unsigned int *a2, unint64_t a3, uint64_t a4)
{
  unint64_t v15 = 0;
  unint64_t v16 = 0;
  uint64_t result = sub_244D20B1C(&v16, &v15, a3, *(unint64_t **)a4, *(int *)(a4 + 8));
  if (result)
  {
    unint64_t v9 = v16;
    uint64_t result = sub_244D15DEC((void **)a1, v16);
    if (result)
    {
      unint64_t v10 = v15;
      unint64_t v11 = v15 >> 1;
      if (v9 != 1 || v11 >= a3)
      {
        sub_244D20BA4(*(char **)a1, 8 * v9, (uint64_t)&unk_244EB7218);
        uint64_t v13 = 8 * v9 - 8;
        *(void *)(*(void *)a1 + v13) &= v10;
        unsigned int v14 = sub_244D2098C(*(uint64_t **)a1, a3, *(uint64_t **)a4, v9);
        *a2 = v14;
        **(void **)a1 |= a3 & (v14 - 1);
        *(void *)(*(void *)a1 + v13) &= -(uint64_t)v14 | v11;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 8) = v9;
        return 1;
      }
      else
      {
        sub_244D0B884(3, 0, 108, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/random.c", 323);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_244D20270(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v5 = 0;
  if (sub_244D1FE18(&v5, a1, a2, a3, 0, a4)) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_244D202B8(int *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (*(int *)(a2 + 8) < 1
    || (**(unsigned char **)a2 & 1) == 0
    || (v38 = 3, v37 = 0x200000000, uint64_t v35 = &v38, v36 = 0x100000001, (int)sub_244D17194(a2, (uint64_t)&v35) <= 0))
  {
    sub_244D0B884(3, 0, 119, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/prime.c", 807);
    return 0;
  }
  if (!a3)
  {
    int v10 = sub_244D168EC((uint64_t *)a2);
    if (v10 <= 3746)
    {
      if (v10 <= 1344)
      {
        if (v10 <= 475)
        {
          if (v10 <= 399)
          {
            if (v10 <= 346)
            {
              if (v10 <= 307)
              {
                if (v10 <= 54) {
                  a3 = 34;
                }
                else {
                  a3 = 27;
                }
              }
              else
              {
                a3 = 8;
              }
            }
            else
            {
              a3 = 7;
            }
          }
          else
          {
            a3 = 6;
          }
        }
        else
        {
          a3 = 5;
        }
      }
      else
      {
        a3 = 4;
      }
    }
    else
    {
      a3 = 3;
    }
  }
  sub_244D1756C((void *)a4);
  uint64_t v13 = sub_244D17610(a4);
  if (!v13) {
    goto LABEL_66;
  }
  uint64_t v14 = (uint64_t)v13;
  if (!sub_244D16764((void **)v13, a2) || !sub_244D1618C(v14, 1uLL)) {
    goto LABEL_66;
  }
  for (unint64_t i = 0; i >> 6 >= *(int *)(v14 + 8) || ((*(void *)(*(void *)v14 + 8 * (i >> 6)) >> i) & 1) == 0; ++i)
    ;
  unint64_t v16 = sub_244D17610(a4);
  uint64_t v17 = v16;
  if (!v16) {
    goto LABEL_69;
  }
  if (!sub_244D17ED0((void **)v16, v14, i))
  {
LABEL_66:
    uint64_t v11 = 0;
    uint64_t v17 = 0;
    goto LABEL_67;
  }
  uint64_t v30 = (uint64_t)v17;
  unint64_t v18 = sub_244D17610(a4);
  int v32 = (uint64_t *)sub_244D17610(a4);
  uint64_t v34 = sub_244D17610(a4);
  int v33 = sub_244D17610(a4);
  uint64_t v19 = sub_244D17610(a4);
  uint64_t v17 = 0;
  uint64_t v11 = 0;
  uint64_t v31 = (uint64_t)v18;
  if (v18 && v32 && v34 && v33 && v19)
  {
    uint64_t v27 = (void **)v19;
    int v20 = (unint64_t *)sub_244D1B1E0(a2, a4);
    uint64_t v17 = v20;
    if (v20)
    {
      if (a3 < 1)
      {
LABEL_70:
        int v22 = 0;
LABEL_71:
        *a1 = v22;
        uint64_t v11 = 1;
        goto LABEL_67;
      }
      int v21 = 1;
      BOOL v28 = v20;
      while (1)
      {
        if (!sub_244D1C18C(v31, 2uLL, v14)) {
          goto LABEL_69;
        }
        int v29 = v21;
        if (!sub_244D1C358(v32, v31, a2, a4)) {
          goto LABEL_69;
        }
        int v22 = 1;
        uint64_t v37 = 0x200000000;
        uint64_t v38 = 1;
        uint64_t v35 = &v38;
        uint64_t v36 = 0x100000001;
        if ((int)sub_244D17194((uint64_t)v32, (uint64_t)&v35) > 0) {
          goto LABEL_71;
        }
        if (!sub_244D19BB4((uint64_t)v34, v31, v30, a2, a4, (uint64_t)v17)) {
          goto LABEL_69;
        }
        if (!sub_244D172C8((unsigned int *)v34) && sub_244D17194((uint64_t)v34, v14)) {
          break;
        }
LABEL_44:
        if (a5
          && !(*(unsigned int (**)(uint64_t, void, uint64_t))(a5 + 8))(1, (v29 - 1), a5))
        {
          goto LABEL_72;
        }
        int v21 = v29 + 1;
        uint64_t v17 = v28;
        if (v29 == a3) {
          goto LABEL_70;
        }
      }
      uint64_t v23 = (void **)v33;
      if (i >= 2)
      {
        int v24 = i - 1;
        while (sub_244D16764(v23, (uint64_t)v34)
             && sub_244D1897C((uint64_t)v34, (uint64_t)v23, (uint64_t)v23, a2, a4))
        {
          if (!sub_244D17194((uint64_t)v34, v14)) {
            goto LABEL_44;
          }
          uint64_t v23 = (void **)v33;
          if (sub_244D172C8((unsigned int *)v34)) {
            goto LABEL_60;
          }
          if (!--v24) {
            goto LABEL_56;
          }
        }
        goto LABEL_72;
      }
LABEL_56:
      uint64_t v17 = v28;
      if (sub_244D16764(v23, (uint64_t)v34))
      {
        if (sub_244D1897C((uint64_t)v34, (uint64_t)v23, (uint64_t)v23, a2, a4))
        {
          if (sub_244D172C8((unsigned int *)v34) || sub_244D16764(v23, (uint64_t)v34))
          {
LABEL_60:
            if (sub_244D16764(v27, (uint64_t)v23))
            {
              uint64_t v17 = v28;
              if (sub_244D1618C((uint64_t)v27, 1uLL)
                && sub_244D1C358(v32, (uint64_t)v27, a2, a4))
              {
                uint64_t v37 = 0x200000000;
                uint64_t v38 = 1;
                uint64_t v35 = &v38;
                uint64_t v36 = 0x100000001;
                if ((int)sub_244D17194((uint64_t)v32, (uint64_t)&v35) >= 1) {
                  int v22 = 1;
                }
                else {
                  int v22 = 2;
                }
                goto LABEL_71;
              }
              goto LABEL_69;
            }
          }
LABEL_72:
          uint64_t v11 = 0;
          uint64_t v17 = v28;
          goto LABEL_67;
        }
      }
    }
LABEL_69:
    uint64_t v11 = 0;
  }
LABEL_67:
  sub_244D1A288((void **)v17);
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v25 = *(void *)(a4 + 8);
    uint64_t v26 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v26;
    *(void *)(a4 + 32) = *(void *)(v25 + 8 * v26);
  }
  return v11;
}

uint64_t sub_244D20780(uint64_t result, int a2, int a3, unsigned int a4)
{
  if (result)
  {
    if ((a3 - 2) <= 0xFFFFFFFC)
    {
      int v5 = 66;
      __int16 v6 = 131;
LABEL_9:
      sub_244D0B884(3, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/random.c", v6);
      return 0;
    }
    if (a4 >= 2)
    {
      int v5 = 66;
      __int16 v6 = 136;
      goto LABEL_9;
    }
    uint64_t v9 = result;
    if (!a2)
    {
      *(_DWORD *)(result + 16) = 0;
      *(_DWORD *)(result + 8) = 0;
      return 1;
    }
    if (a2 >= 2147483585)
    {
      int v5 = 102;
      __int16 v6 = 146;
      goto LABEL_9;
    }
    int v10 = a2 >= -63 ? a2 + 63 : a2 + 126;
    int v11 = 1 - a2 >= 0 ? -((1 - a2) & 0x3F) : (a2 - 1) & 0x3F;
    unint64_t v12 = (uint64_t)v10 >> 6;
    uint64_t result = sub_244D15DEC((void **)result, v12);
    if (result)
    {
      int v13 = v10 >> 6;
      if (v11 < 63) {
        uint64_t v14 = ~(-1 << (v11 + 1));
      }
      else {
        uint64_t v14 = -1;
      }
      sub_244D20BA4(*(char **)v9, 8 * v12, (uint64_t)&unk_244EB7218);
      uint64_t v15 = v13 - 1;
      *(void *)(*(void *)v9 + 8 * v15) &= v14;
      if (a3 == -1) {
        goto LABEL_31;
      }
      if (a2 >= 2 && a3 == 1)
      {
        if (!v11)
        {
          *(void *)(*(void *)v9 + 8 * v15) |= 1uLL;
          uint64_t v17 = (void *)(*(void *)v9 + 8 * v13 - 16);
          uint64_t v16 = 0x8000000000000000;
          goto LABEL_30;
        }
        uint64_t v16 = 3 << (v11 - 1);
      }
      else
      {
        uint64_t v16 = 1 << v11;
      }
      uint64_t v17 = (void *)(*(void *)v9 + 8 * v15);
LABEL_30:
      *v17 |= v16;
LABEL_31:
      if (a4 == 1) {
        **(void **)v9 |= 1uLL;
      }
      *(_DWORD *)(v9 + 16) = 0;
      *(_DWORD *)(v9 + 8) = v13;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D20964(char *a1, unint64_t a2)
{
  return 1;
}

uint64_t sub_244D2098C(uint64_t *a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  if (a2)
  {
    if (a4)
    {
      uint64_t v4 = 0;
      unint64_t v5 = a4 - 1;
      if (a4 != 1)
      {
        __int16 v6 = a1 + 1;
        do
        {
          uint64_t v7 = *v6++;
          v4 |= v7;
          --v5;
        }
        while (v5);
      }
      char v8 = ~(((v4 - 1) & ~v4 & (((*a1 - a2) ^ *a1 | *a1 ^ a2) ^ *a1)) >> 63);
    }
    else
    {
      char v8 = 0;
    }
  }
  else
  {
    char v8 = -1;
  }
  return *(_DWORD *)&v8 & (sub_244D170B4(a1, a4, a3, a4) >> 31);
}

uint64_t sub_244D20A18(char *a1, unint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v16 = 0;
  unint64_t v17 = 0;
  uint64_t result = sub_244D20B1C(&v17, &v16, a2, a3, a4);
  if (result)
  {
    unint64_t v11 = v17;
    size_t v12 = 8 * (a4 - v17);
    if (v12) {
      bzero(&a1[8 * v17], v12);
    }
    unint64_t v13 = v16;
    int v14 = -100;
    while (!__CFADD__(v14++, 1))
    {
      sub_244D20BA4(a1, 8 * v11, a5);
      *(void *)&a1[8 * v11 - 8] &= v13;
      if (sub_244D2098C((uint64_t *)a1, a2, (uint64_t *)a3, v11)) {
        return 1;
      }
    }
    sub_244D0B884(3, 0, 115, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/random.c", 271);
    return 0;
  }
  return result;
}

uint64_t sub_244D20B1C(void *a1, unint64_t *a2, unint64_t a3, unint64_t *a4, uint64_t a5)
{
  while (a5)
  {
    uint64_t v5 = a5 - 1;
    unint64_t v6 = a4[--a5];
    if (v6)
    {
      if (v5 || *a4 > a3)
      {
        unint64_t v7 = v6 | (v6 >> 1) | ((v6 | (v6 >> 1)) >> 2);
        unint64_t v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
        *a1 = v5 + 1;
        *a2 = v8 | (v8 >> 16) | ((v8 | (v8 >> 16)) >> 32);
        return 1;
      }
      break;
    }
  }
  sub_244D0B884(3, 0, 108, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/random.c", 230);
  return 0;
}

void sub_244D20BA4(char *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (!a2) {
    return;
  }
  unint64_t v4 = a2;
  sub_244D4BDB4(&stru_268EBD9A0, (void (*)(void))sub_244D31D3C);
  uint64_t v6 = qword_268EC01B0;
  BOOL v7 = sub_244D498E0();
  int v8 = v7;
  if (v6) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = !v7;
  }
  if (v9) {
    sub_244D498F8(v23, 0x20uLL);
  }
  else {
    memset(v23, 0, sizeof(v23));
  }
  for (uint64_t i = 0; i != 2; ++i)
    v23[i] = veorq_s8((int8x16_t)v23[i], *(int8x16_t *)(a3 + i * 16));
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  unint64_t v11 = sub_244D4BDD4(1);
  if (v11)
  {
    size_t v12 = v11;
    unint64_t v13 = v11 + 37;
    if (*((_DWORD *)v11 + 74) > 0xFFFu) {
      goto LABEL_20;
    }
  }
  else
  {
    int v14 = sub_244D44058(0x138uLL);
    if (!v14
      || (size_t v12 = v14, !sub_244D4BE80(1u, (uint64_t)v14, (void (*)(uint64_t))sub_244D31D80)))
    {
      size_t v12 = v21;
    }
    *((_DWORD *)v12 + 75) = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v17 = 0u;
    sub_244D498F8(v20, 0x30uLL);
    if (!sub_244D31840((uint64_t)v12, v20, (char *)&v17, 0)) {
      goto LABEL_31;
    }
    unint64_t v13 = (_DWORD *)v12 + 74;
    *((_DWORD *)v12 + 74) = 0;
    *((void *)v12 + 36) = v6;
    *((_DWORD *)v12 + 76) = v8;
  }
  if (*((void *)v12 + 36) != v6 || *((_DWORD *)v12 + 76) != v8)
  {
LABEL_20:
    long long v18 = 0u;
    long long v19 = 0u;
    long long v17 = 0u;
    sub_244D498F8(v20, 0x30uLL);
    if (sub_244D31944((uint64_t)v12, (char *)v20, (uint64_t)&v17, 0))
    {
      *unint64_t v13 = 0;
      *((void *)v12 + 36) = v6;
      *((_DWORD *)v12 + 76) = v8;
      goto LABEL_22;
    }
LABEL_31:
    abort();
  }
LABEL_22:
  unint64_t v15 = 32;
  do
  {
    if (v4 >= 0x10000) {
      unint64_t v16 = 0x10000;
    }
    else {
      unint64_t v16 = v4;
    }
    if (!sub_244D31B10((uint64_t)v12, a1, v16, (char *)v23, v15)) {
      goto LABEL_31;
    }
    unint64_t v15 = 0;
    a1 += v16;
    ++*v13;
    v4 -= v16;
  }
  while (v4);
  if (v12 == v21) {
    sub_244D4413C(v21, 0x120uLL);
  }
}

uint64_t sub_244D20E10(uint64_t a1, uint64_t a2)
{
  return sub_244D1C18C(a1, 0, a2);
}

void sub_244D20E1C(void *__dst, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t v5 = __dst;
  unint64_t v6 = a3 >> 6;
  uint64_t v7 = a4 - v6;
  if (a4 <= v6)
  {
    if (!a4) {
      return;
    }
    size_t v13 = 8 * a4;
    goto LABEL_14;
  }
  char v9 = a3 & 0x3F;
  if ((a3 & 0x3F) != 0)
  {
    if (a4 - 1 > v6)
    {
      uint64_t v10 = ~v6 + a4;
      unint64_t v11 = (void *)(a2 + 8 * v6 + 8);
      size_t v12 = __dst;
      do
      {
        *v12++ = (*v11 << (64 - v9)) | (*(v11 - 1) >> v9);
        ++v11;
        --v10;
      }
      while (v10);
    }
    __dst[a4 - 1 - v6] = *(void *)(a2 + 8 * (a4 - 1)) >> v9;
  }
  else if (8 * v7)
  {
    memmove(__dst, (const void *)(a2 + 8 * v6), 8 * v7);
  }
  if (a3 >= 0x40)
  {
    size_t v13 = 8 * v6;
    __dst = &v5[a4 - v6];
LABEL_14:
    bzero(__dst, v13);
  }
}

void *sub_244D20F10(void *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (a3 != 1)
    {
      uint64_t v3 = a2 + 8;
      uint64_t v4 = a3 - 1;
      uint64_t v5 = result;
      do
      {
        *v5++ = *(long long *)(v3 - 8) >> 1;
        v3 += 8;
        --v4;
      }
      while (v4);
    }
    result[a3 - 1] = *(void *)(a2 + 8 * (a3 - 1)) >> 1;
  }
  return result;
}

uint64_t sub_244D20F50(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 8) <= (signed int)(a2 >> 6)) {
    return 0;
  }
  *(void *)(*(void *)a1 + 8 * (a2 >> 6)) &= ~(1 << a2);
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  uint64_t v3 = 8 * v2 - 8;
  int v4 = *(_DWORD *)(a1 + 8);
  while (1)
  {
    BOOL v5 = __OFSUB__(v4--, 1);
    if (v4 < 0 != v5) {
      break;
    }
    uint64_t v6 = *(void *)(*(void *)a1 + v3);
    v3 -= 8;
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v4 + 1;
      return 1;
    }
  }
  *(_DWORD *)(a1 + 8) = v2 & ((int)v2 >> 31);
  if ((v2 & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 16) = 0;
  }
  return 1;
}

uint64_t sub_244D20FD0(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  int v2 = a2 >> 6;
  if ((signed int)(a2 >> 6) < *(_DWORD *)(a1 + 8))
  {
    if ((a2 & 0x3F) != 0)
    {
      *(_DWORD *)(a1 + 8) = v2 + 1;
      *(void *)(*(void *)a1 + 8 * v2) &= ~(-1 << (a2 & 0x3F));
      int v2 = *(_DWORD *)(a1 + 8);
    }
    else
    {
      *(_DWORD *)(a1 + 8) = v2;
    }
    uint64_t v4 = 8 * v2 - 8;
    int v5 = v2;
    while (1)
    {
      BOOL v6 = __OFSUB__(v5--, 1);
      if (v5 < 0 != v6) {
        break;
      }
      uint64_t v7 = *(void *)(*(void *)a1 + v4);
      v4 -= 8;
      if (v7)
      {
        *(_DWORD *)(a1 + 8) = v5 + 1;
        return 1;
      }
    }
    *(_DWORD *)(a1 + 8) = v2 & (v2 >> 31);
    if ((v2 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 16) = 0;
    }
  }
  return 1;
}

void *sub_244D21068(void *a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(unsigned int *)(a3 + 8);
  if ((int)v7 < 1) {
    goto LABEL_17;
  }
  int v8 = *(uint64_t **)a3;
  uint64_t v9 = **(void **)a3;
  if ((v9 & 1) == 0) {
    goto LABEL_19;
  }
  uint64_t v11 = v9 ^ 1;
  if (v7 >= 2)
  {
    uint64_t v12 = v7 - 1;
    size_t v13 = v8 + 1;
    do
    {
      uint64_t v14 = *v13++;
      v11 |= v14;
      --v12;
    }
    while (v12);
  }
  if (!v11)
  {
LABEL_17:
    if (!v7) {
      goto LABEL_23;
    }
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = **(void **)a3;
LABEL_19:
    uint64_t v23 = v9 ^ 2;
    if ((int)v7 >= 2)
    {
      uint64_t v24 = v7 - 1;
      uint64_t v25 = v8 + 1;
      do
      {
        uint64_t v26 = *v25++;
        v23 |= v26;
        --v24;
      }
      while (v24);
    }
    if (!v23)
    {
      long long v19 = a1;
      if (a1 || (long long v19 = sub_244D16670()) != 0)
      {
        if (a2[2])
        {
          uint64_t v27 = **(void **)a2;
          if (v27)
          {
            if (sub_244D15DEC((void **)v19, 1uLL))
            {
              BOOL v22 = v27 & 1;
              goto LABEL_32;
            }
            goto LABEL_35;
          }
        }
        goto LABEL_29;
      }
LABEL_35:
      if (v19 != a1) {
        sub_244D166B0((void **)v19);
      }
      return 0;
    }
LABEL_23:
    sub_244D0B884(3, 0, 114, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/sqrt.c", 88);
    return 0;
  }
  uint64_t v15 = (int)a2[2];
  if (!v15) {
    goto LABEL_12;
  }
  uint64_t v16 = 0;
  long long v17 = *(uint64_t **)a2;
  do
  {
    uint64_t v18 = *v17++;
    v16 |= v18;
    --v15;
  }
  while (v15);
  if (!v16 || sub_244D172C8(a2))
  {
LABEL_12:
    long long v19 = a1;
    if (a1 || (long long v19 = sub_244D16670()) != 0)
    {
      BOOL v20 = sub_244D172C8(a2);
      if (v20)
      {
        BOOL v21 = v20;
        if (sub_244D15DEC((void **)v19, 1uLL))
        {
          BOOL v22 = v21;
LABEL_32:
          *((_DWORD *)v19 + 4) = 0;
          *(void *)*long long v19 = v22;
          int v28 = 1;
          goto LABEL_33;
        }
        goto LABEL_35;
      }
LABEL_29:
      int v28 = 0;
      *((_DWORD *)v19 + 4) = 0;
LABEL_33:
      *((_DWORD *)v19 + 2) = v28;
      return v19;
    }
    goto LABEL_35;
  }
  sub_244D1756C((void *)a4);
  uint64_t v30 = sub_244D17610(a4);
  uint64_t v31 = sub_244D17610(a4);
  int v32 = sub_244D17610(a4);
  int v33 = sub_244D17610(a4);
  uint64_t v34 = sub_244D17610(a4);
  uint64_t v35 = sub_244D17610(a4);
  if (!v35) {
    goto LABEL_88;
  }
  uint64_t v36 = (uint64_t)v35;
  uint64_t v71 = (unsigned int *)v31;
  long long v19 = a1;
  if (!a1)
  {
    long long v19 = sub_244D16670();
    if (!v19) {
      goto LABEL_86;
    }
  }
  if (!sub_244D17F9C((uint64_t)v30, (uint64_t)a2, a3, a4)) {
    goto LABEL_86;
  }
  for (unint64_t i = 1; i >> 6 >= *(int *)(a3 + 8) || ((*(void *)(*(void *)a3 + 8 * (i >> 6)) >> i) & 1) == 0; ++i)
    ;
  if (i == 2)
  {
    if (sub_244D185B8((unint64_t **)v33, (uint64_t)v30, (uint64_t)v30, a3, a4))
    {
      if (sub_244D17ED0((void **)v32, a3, 3u))
      {
        *((_DWORD *)v32 + 4) = 0;
        if (sub_244D19BB4((uint64_t)v71, (uint64_t)v33, (uint64_t)v32, a3, a4, 0))
        {
          if (sub_244D18B18(v36, (uint64_t)v71, a3, a4)
            && sub_244D1897C((uint64_t)v33, (uint64_t)v33, v36, a3, a4)
            && sub_244D1618C((uint64_t)v33, 1uLL)
            && sub_244D1897C((uint64_t)v34, (uint64_t)v30, (uint64_t)v71, a3, a4)
            && sub_244D1897C((uint64_t)v34, (uint64_t)v34, (uint64_t)v33, a3, a4)
            && sub_244D16764((void **)v19, (uint64_t)v34))
          {
            goto LABEL_50;
          }
        }
      }
    }
    goto LABEL_86;
  }
  if (i == 1)
  {
    if (sub_244D17ED0((void **)v32, a3, 2u))
    {
      *((_DWORD *)v32 + 4) = 0;
      if (sub_244D15FB8((uint64_t)v32, 1uLL))
      {
        if (sub_244D19BB4((uint64_t)v19, (uint64_t)v30, (uint64_t)v32, a3, a4, 0))
        {
LABEL_50:
          if (!sub_244D18B18((uint64_t)v34, (uint64_t)v19, a3, a4)) {
            goto LABEL_86;
          }
          if (!sub_244D17194((uint64_t)v34, (uint64_t)v30)) {
            goto LABEL_89;
          }
          int v38 = 110;
          __int16 v39 = 409;
          goto LABEL_85;
        }
      }
    }
LABEL_86:
    if (v19 != a1) {
      sub_244D166B0((void **)v19);
    }
LABEL_88:
    long long v19 = 0;
    goto LABEL_89;
  }
  if (!sub_244D16764((void **)v32, a3)) {
    goto LABEL_86;
  }
  uint64_t v69 = (uint64_t)v34;
  uint64_t v70 = (uint64_t)v33;
  uint64_t v68 = (uint64_t)v30;
  *((_DWORD *)v32 + 4) = 0;
  unint64_t v40 = 2;
  while (1)
  {
    if (v40 <= 0x15) {
      goto LABEL_76;
    }
    int v41 = sub_244D168EC((uint64_t *)a3);
    if (!sub_244D20780(v36, v41, 0, 0)) {
      goto LABEL_86;
    }
    int v42 = *(_DWORD *)(v36 + 8);
    uint64_t v43 = v42;
    if ((sub_244D170B4(*(uint64_t **)v36, v42, *(uint64_t **)a3, *(int *)(a3 + 8)) & 0x80000000) == 0)
    {
      uint64_t v44 = sub_244D15B90;
      if (!*(_DWORD *)(a3 + 16)) {
        uint64_t v44 = sub_244D16310;
      }
      if (!v44(v36, v36, a3)) {
        goto LABEL_86;
      }
      int v42 = *(_DWORD *)(v36 + 8);
      uint64_t v43 = v42;
    }
    if (!v42) {
      goto LABEL_76;
    }
    uint64_t v45 = 0;
    unint64_t v46 = *(uint64_t **)v36;
    do
    {
      uint64_t v47 = *v46++;
      v45 |= v47;
      --v43;
    }
    while (v43);
    if (!v45)
    {
LABEL_76:
      if (!sub_244D16130(v36, v40)) {
        goto LABEL_86;
      }
    }
    int v48 = sub_244D1DCD4(v36, (uint64_t)v32, a4);
    if (v48 < -1) {
      goto LABEL_86;
    }
    if (v48 != 1) {
      break;
    }
    if (++v40 == 82) {
      goto LABEL_84;
    }
  }
  if (v48 != -1)
  {
    if (!v48)
    {
      int v38 = 114;
      __int16 v39 = 257;
      goto LABEL_85;
    }
LABEL_84:
    int v38 = 115;
    __int16 v39 = 267;
    goto LABEL_85;
  }
  if (!sub_244D17ED0((void **)v32, (uint64_t)v32, i)
    || !sub_244D19BB4(v36, v36, (uint64_t)v32, a3, a4, 0))
  {
    goto LABEL_86;
  }
  if (sub_244D172C8((unsigned int *)v36))
  {
    int v38 = 114;
    __int16 v39 = 282;
LABEL_85:
    sub_244D0B884(3, 0, v38, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/sqrt.c", v39);
    goto LABEL_86;
  }
  if (!sub_244D1B5D8(v70, (uint64_t *)v32)) {
    goto LABEL_86;
  }
  uint64_t v51 = *(int *)(v70 + 8);
  if (v51)
  {
    uint64_t v52 = 0;
    int v53 = *(uint64_t **)v70;
    do
    {
      uint64_t v54 = *v53++;
      v52 |= v54;
      --v51;
    }
    while (v51);
    if (v52)
    {
      if (!sub_244D19BB4(v69, v68, v70, a3, a4, 0)) {
        goto LABEL_86;
      }
      uint64_t v55 = *(int *)(v69 + 8);
      if (!v55) {
        goto LABEL_134;
      }
      uint64_t v56 = 0;
      uint64_t v57 = *(uint64_t **)v69;
      do
      {
        uint64_t v58 = *v57++;
        v56 |= v58;
        --v55;
      }
      while (v55);
      if (!v56) {
        goto LABEL_134;
      }
LABEL_113:
      if (sub_244D18B18((uint64_t)v71, v69, a3, a4)
        && sub_244D1897C((uint64_t)v71, (uint64_t)v71, v68, a3, a4))
      {
        uint64_t v64 = v68;
        uint64_t v63 = v69;
        uint64_t v65 = v69;
        while (sub_244D1897C(v63, v65, v64, a3, a4))
        {
          if (sub_244D172C8(v71))
          {
            uint64_t v34 = (unint64_t *)v69;
            uint64_t v30 = (unint64_t *)v68;
            if (sub_244D16764((void **)v19, v69)) {
              goto LABEL_50;
            }
            goto LABEL_86;
          }
          int v66 = i - 2;
          if (i < 2)
          {
LABEL_135:
            int v38 = 110;
            __int16 v39 = 377;
            goto LABEL_85;
          }
          int v67 = i - 1;
          LODWORD(i) = 1;
          while (1)
          {
            if (i == 1)
            {
              if (!sub_244D18B18(v70, (uint64_t)v71, a3, a4)) {
                goto LABEL_86;
              }
            }
            else if (!sub_244D1897C(v70, v70, v70, a3, a4))
            {
              goto LABEL_86;
            }
            if (sub_244D172C8((unsigned int *)v70)) {
              break;
            }
            LODWORD(i) = i + 1;
            --v66;
            --v67;
            if (v66 == -1) {
              goto LABEL_135;
            }
          }
          if (!sub_244D16764((void **)v70, v36)) {
            goto LABEL_86;
          }
          if (v66 >= 1)
          {
            while (sub_244D18B18(v70, v70, a3, a4))
            {
              if (--v67 < 2) {
                goto LABEL_131;
              }
            }
            goto LABEL_86;
          }
LABEL_131:
          if (!sub_244D1897C(v36, v70, v70, a3, a4)
            || !sub_244D1897C(v69, v69, v70, a3, a4))
          {
            goto LABEL_86;
          }
          uint64_t v63 = (uint64_t)v71;
          uint64_t v65 = (uint64_t)v71;
          uint64_t v64 = v36;
        }
      }
      goto LABEL_86;
    }
  }
  if (!sub_244D17F9C(v70, v68, a3, a4)) {
    goto LABEL_86;
  }
  uint64_t v59 = *(int *)(v70 + 8);
  if (v59)
  {
    uint64_t v60 = 0;
    uint64_t v61 = *(uint64_t **)v70;
    do
    {
      uint64_t v62 = *v61++;
      v60 |= v62;
      --v59;
    }
    while (v59);
    if (v60)
    {
      if (!sub_244D15DEC((void **)v69, 1uLL)) {
        goto LABEL_86;
      }
      *(_DWORD *)(v69 + 16) = 0;
      **(void **)uint64_t v69 = 1;
      *(_DWORD *)(v69 + 8) = 1;
      goto LABEL_113;
    }
  }
LABEL_134:
  *((_DWORD *)v19 + 4) = 0;
  *((_DWORD *)v19 + 2) = 0;
LABEL_89:
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v49 = *(void *)(a4 + 8);
    uint64_t v50 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v50;
    *(void *)(a4 + 32) = *(void *)(v49 + 8 * v50);
  }
  return v19;
}

uint64_t sub_244D218C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 16))
  {
    sub_244D0B884(3, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/sqrt.c", 430);
    return 0;
  }
  else
  {
    uint64_t v6 = *(int *)(a2 + 8);
    if (!v6) {
      goto LABEL_27;
    }
    uint64_t v8 = 0;
    uint64_t v9 = *(uint64_t **)a2;
    do
    {
      uint64_t v10 = *v9++;
      v8 |= v10;
      --v6;
    }
    while (v6);
    if (v8)
    {
      sub_244D1756C((void *)a3);
      uint64_t v11 = (unint64_t *)a1;
      if (a1 == a2) {
        uint64_t v11 = sub_244D17610(a3);
      }
      uint64_t v12 = (uint64_t *)sub_244D17610(a3);
      size_t v13 = sub_244D17610(a3);
      uint64_t v14 = sub_244D17610(a3);
      uint64_t result = 0;
      if (v11)
      {
        if (v12)
        {
          if (v13)
          {
            if (v14)
            {
              sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
              unsigned int v15 = sub_244D168EC((uint64_t *)a2);
              uint64_t result = sub_244D17CA4((uint64_t)v11, &qword_268EBEE70, v15 >> 1);
              if (result)
              {
                if (sub_244D17728((unint64_t *)v12, 0, a2, (uint64_t)v11, a3))
                {
                  char v16 = 1;
                  do
                  {
                    long long v17 = v13;
                    if (!sub_244D15B90((uint64_t)v12, (uint64_t)v12, (uint64_t)v11)
                      || !sub_244D1B5D8((uint64_t)v11, v12)
                      || !sub_244D18A38((uint64_t)v12, (uint64_t)v11, a3)
                      || !sub_244D16310((uint64_t)v14, a2, (uint64_t)v12))
                    {
                      break;
                    }
                    *((_DWORD *)v14 + 4) = 0;
                    if ((v16 & 1) == 0 && (sub_244D17194((uint64_t)v14, (uint64_t)v13) & 0x80000000) == 0)
                    {
                      if (sub_244D17194((uint64_t)v12, a2))
                      {
                        int v18 = 110;
                        __int16 v19 = 487;
                        goto LABEL_24;
                      }
                      uint64_t result = a1 != a2 || sub_244D16764((void **)a2, (uint64_t)v11) != 0;
                      goto LABEL_25;
                    }
                    char v16 = 0;
                    size_t v13 = v14;
                    uint64_t v14 = v17;
                  }
                  while (sub_244D17728((unint64_t *)v12, 0, a2, (uint64_t)v11, a3));
                }
                int v18 = 3;
                __int16 v19 = 467;
LABEL_24:
                sub_244D0B884(3, 0, v18, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/sqrt.c", v19);
                uint64_t result = 0;
              }
            }
          }
        }
      }
LABEL_25:
      if (!*(unsigned char *)(a3 + 40))
      {
        uint64_t v20 = *(void *)(a3 + 8);
        uint64_t v21 = *(void *)(a3 + 16) - 1;
        *(void *)(a3 + 16) = v21;
        *(void *)(a3 + 32) = *(void *)(v20 + 8 * v21);
      }
    }
    else
    {
LABEL_27:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D21B3C(unsigned __int8 *a1)
{
  return *a1;
}

uint64_t sub_244D21B44(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1);
}

uint64_t sub_244D21B4C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 2);
}

uint64_t sub_244D21B54(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 3);
}

void sub_244D21B5C(void *a1)
{
}

void *sub_244D21B64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_244D43FF4(0x248uLL);
  bzero(v8, 0x248uLL);
  if (!sub_244D21BFC(v8, a1, a2, a3, a4) && v8)
  {
    if (*v8)
    {
      (*(void (**)(void *))(*v8 + 24))(v8);
      *uint64_t v8 = 0;
    }
    sub_244D440EC(v8);
    return 0;
  }
  return v8;
}

uint64_t sub_244D21BFC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a2 + 8))
  {
    return sub_244D21CF4(a1, (unsigned __int8 *)a2, a3, a4, a5, 0);
  }
  else
  {
    sub_244D0B884(30, 0, 124, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/aead.c", 65);
    *a1 = 0;
    return 0;
  }
}

void sub_244D21C6C(void *a1)
{
  if (a1)
  {
    if (*a1)
    {
      (*(void (**)(void *))(*a1 + 24))(a1);
      *a1 = 0;
    }
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D21CC0(uint64_t result)
{
  if (*(void *)result)
  {
    uint64_t v1 = (void *)result;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    void *v1 = 0;
  }
  return result;
}

uint64_t sub_244D21CF4(void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*a2 != a4)
  {
    sub_244D0B884(30, 0, 120, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/aead.c", 78);
    goto LABEL_6;
  }
  *a1 = a2;
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, uint64_t, uint64_t))*((void *)a2 + 1);
  if (v7)
  {
    uint64_t result = v7(a1, a3, a4, a5);
    if (result) {
      return result;
    }
    goto LABEL_6;
  }
  uint64_t result = (*((uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))a2 + 2))(a1, a3, a4, a5, a6);
  if (!result)
  {
LABEL_6:
    uint64_t result = 0;
    *a1 = 0;
  }
  return result;
}

uint64_t sub_244D21D90(uint64_t a1, char *a2, void *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, size_t a8)
{
  if (__CFADD__(a8, *(unsigned __int8 *)(*(void *)a1 + 2)))
  {
    int v12 = 117;
    __int16 v13 = 123;
LABEL_10:
    sub_244D0B884(30, 0, v12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/aead.c", v13);
    goto LABEL_11;
  }
  if (a4 < a8)
  {
    int v12 = 103;
    __int16 v13 = 128;
    goto LABEL_10;
  }
  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    int v12 = 115;
    __int16 v13 = 133;
    goto LABEL_10;
  }
  char v16 = *(unsigned int (**)(uint64_t, char *, char *, uint64_t *, size_t))(*(void *)a1 + 40);
  uint64_t v17 = 0;
  if (v16(a1, a2, &a2[a8], &v17, a4 - a8))
  {
    size_t v14 = v17 + a8;
    uint64_t result = 1;
    goto LABEL_14;
  }
LABEL_11:
  if (a4) {
    bzero(a2, a4);
  }
  size_t v14 = 0;
  uint64_t result = 0;
LABEL_14:
  *a3 = v14;
  return result;
}

uint64_t sub_244D21EB8(uint64_t *a1, char *a2, char *a3, void *a4, size_t a5, uint64_t a6, uint64_t a7, char *a8, size_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v15 = (unint64_t)&a8[a9];
  char v16 = &a2[a9];
  if (a8 != a2 && (v15 > (unint64_t)a2 ? (BOOL v17 = v16 > a8) : (BOOL v17 = 0), v17)
    || &a3[a5] > a2 && v16 > a3
    || &a3[a5] > a8 && v15 > (unint64_t)a3)
  {
    int v18 = 115;
    __int16 v19 = 162;
LABEL_11:
    sub_244D0B884(30, 0, v18, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/aead.c", v19);
    goto LABEL_12;
  }
  uint64_t v21 = *a1;
  if (a11 && !*(_DWORD *)(v21 + 4))
  {
    int v18 = 112;
    __int16 v19 = 167;
    goto LABEL_11;
  }
  if ((*(unsigned int (**)(uint64_t *, char *, char *, void *, size_t))(v21 + 40))(a1, a2, a3, a4, a5)) {
    return 1;
  }
LABEL_12:
  if (a9) {
    bzero(a2, a9);
  }
  if (a5) {
    bzero(a3, a5);
  }
  uint64_t result = 0;
  *a4 = 0;
  return result;
}

uint64_t sub_244D21FEC(unsigned __int8 *a1, char *a2, size_t *a3, size_t a4, uint64_t a5, uint64_t a6, char *a7, unint64_t a8)
{
  if (a7 != a2 && &a2[a4] > a7 && &a7[a8] > a2)
  {
    int v11 = 115;
    __int16 v12 = 191;
    goto LABEL_5;
  }
  unint64_t v15 = *(unsigned int (**)(unsigned __int8 *, char *))(*(void *)a1 + 32);
  if (!v15)
  {
    unint64_t v16 = a1[576];
    size_t v13 = a8 - v16;
    if (a8 >= v16)
    {
      if (v13 <= a4)
      {
        if (sub_244D2212C((uint64_t)a1, a2, a5, a6, a7, a8 - v16))
        {
          uint64_t result = 1;
LABEL_9:
          *a3 = v13;
          return result;
        }
LABEL_6:
        if (a4) {
          bzero(a2, a4);
        }
        size_t v13 = 0;
        uint64_t result = 0;
        goto LABEL_9;
      }
      int v11 = 103;
      __int16 v12 = 214;
    }
    else
    {
      int v11 = 101;
      __int16 v12 = 208;
    }
LABEL_5:
    sub_244D0B884(30, 0, v11, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/aead.c", v12);
    goto LABEL_6;
  }
  if (!v15(a1, a2)) {
    goto LABEL_6;
  }
  return 1;
}

uint64_t sub_244D2212C(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, char *a5, size_t a6)
{
  if (a5 != a2 && &a5[a6] > a2 && &a2[a6] > a5)
  {
    int v8 = 115;
    __int16 v9 = 238;
LABEL_9:
    sub_244D0B884(30, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/aead.c", v9);
    goto LABEL_10;
  }
  uint64_t v10 = *(unsigned int (**)(uint64_t, char *))(*(void *)a1 + 48);
  if (!v10)
  {
    int v8 = 104;
    __int16 v9 = 243;
    goto LABEL_9;
  }
  if (v10(a1, a2)) {
    return 1;
  }
LABEL_10:
  if (a6) {
    bzero(a2, a6);
  }
  return 0;
}

uint64_t sub_244D221F0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 56);
  if (v1) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t sub_244D22208(unsigned __int8 *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(uint64_t (**)(void))(*(void *)a1 + 64);
  if (v5)
  {
    uint64_t v6 = v5();
LABEL_6:
    uint64_t v8 = 1;
    goto LABEL_7;
  }
  uint64_t v7 = a1[576];
  uint64_t v6 = v7 + a4;
  if (!__CFADD__(v7, a4)) {
    goto LABEL_6;
  }
  sub_244D0B884(30, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/aead.c", 281);
  uint64_t v6 = 0;
  uint64_t v8 = 0;
LABEL_7:
  *a2 = v6;
  return v8;
}

double sub_244D22284(uint64_t a1)
{
  *(void *)(a1 + 144) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

double sub_244D222A4()
{
  uint64_t v0 = sub_244D43FF4(0x98uLL);
  if (v0)
  {
    v0[18] = 0;
    double result = 0.0;
    *((_OWORD *)v0 + 7) = 0u;
    *((_OWORD *)v0 + 8) = 0u;
    *((_OWORD *)v0 + 5) = 0u;
    *((_OWORD *)v0 + 6) = 0u;
    *((_OWORD *)v0 + 3) = 0u;
    *((_OWORD *)v0 + 4) = 0u;
    *((_OWORD *)v0 + 1) = 0u;
    *((_OWORD *)v0 + 2) = 0u;
    *(_OWORD *)uint64_t v0 = 0u;
  }
  return result;
}

uint64_t sub_244D222E0(uint64_t a1)
{
  if (*(void *)a1)
  {
    int v2 = *(void (**)(uint64_t))(*(void *)a1 + 40);
    if (v2) {
      v2(a1);
    }
  }
  sub_244D440EC(*(void **)(a1 + 16));
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return 1;
}

void sub_244D22340(void *a1)
{
  if (a1)
  {
    sub_244D222E0((uint64_t)a1);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D22380(uint64_t a1, uint64_t *a2)
{
  if (!a2 || !*a2)
  {
    int v3 = 108;
    __int16 v4 = 103;
    goto LABEL_6;
  }
  if (*((_DWORD *)a2 + 36))
  {
    int v3 = 66;
    __int16 v4 = 108;
LABEL_6:
    sub_244D0B884(30, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", v4);
    return 0;
  }
  sub_244D222E0(a1);
  long long v7 = *((_OWORD *)a2 + 1);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v7;
  long long v8 = *((_OWORD *)a2 + 5);
  long long v10 = *((_OWORD *)a2 + 2);
  long long v9 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(a1 + 64) = *((_OWORD *)a2 + 4);
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 32) = v10;
  *(_OWORD *)(a1 + 48) = v9;
  long long v12 = *((_OWORD *)a2 + 7);
  long long v11 = *((_OWORD *)a2 + 8);
  long long v13 = *((_OWORD *)a2 + 6);
  *(void *)(a1 + 144) = a2[18];
  *(_OWORD *)(a1 + 112) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 96) = v13;
  size_t v14 = (const void *)a2[2];
  uint64_t v15 = *a2;
  if (v14)
  {
    unint64_t v16 = *(unsigned int *)(v15 + 16);
    if (v16)
    {
      uint64_t result = (uint64_t)sub_244D442F4(v14, v16);
      *(void *)(a1 + 16) = result;
      if (!result) {
        goto LABEL_14;
      }
      uint64_t v15 = *a2;
    }
  }
  if ((*(unsigned char *)(v15 + 21) & 0x10) == 0) {
    return 1;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, void, uint64_t))(v15 + 48))(a2, 8, 0, a1);
  if (result) {
    return 1;
  }
LABEL_14:
  *(void *)a1 = 0;
  return result;
}

uint64_t sub_244D22480(uint64_t a1)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  return 1;
}

uint64_t sub_244D224C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, int a6)
{
  if (a6 == -1)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 28);
  }
  else
  {
    uint64_t v10 = a6 != 0;
    *(_DWORD *)(a1 + 28) = v10;
  }
  uint64_t v11 = *(void *)a1;
  if (a2)
  {
    if (v11)
    {
      sub_244D222E0(a1);
      *(_DWORD *)(a1 + 28) = v10;
    }
    *(void *)a1 = a2;
    unint64_t v12 = *(unsigned int *)(a2 + 16);
    if (v12)
    {
      uint64_t result = (uint64_t)sub_244D43FF4(v12);
      *(void *)(a1 + 16) = result;
      if (!result)
      {
        *(void *)a1 = 0;
        return result;
      }
      uint64_t v11 = *(void *)a1;
    }
    else
    {
      *(void *)(a1 + 16) = 0;
      uint64_t v11 = a2;
    }
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 32) = 0;
    if ((*(unsigned char *)(v11 + 21) & 2) == 0) {
      goto LABEL_16;
    }
    if (sub_244D226C8(a1))
    {
      uint64_t v11 = *(void *)a1;
      goto LABEL_16;
    }
    *(void *)a1 = 0;
    int v14 = 107;
    __int16 v15 = 178;
LABEL_23:
    sub_244D0B884(30, 0, v14, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", v15);
    return 0;
  }
  if (!v11)
  {
    int v14 = 114;
    __int16 v15 = 183;
    goto LABEL_23;
  }
LABEL_16:
  int v16 = *(_DWORD *)(v11 + 20);
  if ((v16 & 0x100) == 0)
  {
    switch(v16 & 0x3F)
    {
      case 0:
      case 1:
        break;
      case 2:
        goto LABEL_26;
      case 3:
        *(_DWORD *)(a1 + 104) = 0;
LABEL_26:
        if (a5)
        {
          unsigned int v21 = sub_244D22770(a1);
          if (v21) {
            memcpy((void *)(a1 + 36), a5, v21);
          }
        }
        unsigned int v22 = sub_244D22770(a1);
        if (!v22) {
          break;
        }
        size_t v18 = v22;
        uint64_t v20 = (const void *)(a1 + 36);
        __int16 v19 = (void *)(a1 + 52);
LABEL_31:
        memcpy(v19, v20, v18);
        break;
      case 4:
      case 5:
        *(_DWORD *)(a1 + 104) = 0;
        if (!a5) {
          break;
        }
        unsigned int v17 = sub_244D22770(a1);
        if (!v17) {
          break;
        }
        size_t v18 = v17;
        __int16 v19 = (void *)(a1 + 52);
        uint64_t v20 = a5;
        goto LABEL_31;
      default:
        return 0;
    }
  }
  uint64_t v23 = *(void *)a1;
  if (!a4 && (*(unsigned char *)(v23 + 20) & 0x80) == 0
    || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, const void *, uint64_t))(v23 + 24))(a1, a4, a5, v10),
        result))
  {
    *(_DWORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 108) = 0;
    uint64_t result = 1;
    *(_DWORD *)(a1 + 144) = 0;
  }
  return result;
}

uint64_t sub_244D226C8(uint64_t a1)
{
  if (*(void *)a1)
  {
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 48);
    if (v1)
    {
      uint64_t result = v1();
      if (result != -1) {
        return result;
      }
      int v3 = 105;
      __int16 v4 = 631;
    }
    else
    {
      int v3 = 104;
      __int16 v4 = 625;
    }
  }
  else
  {
    int v3 = 114;
    __int16 v4 = 620;
  }
  sub_244D0B884(30, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", v4);
  return 0;
}

uint64_t sub_244D22750(uint64_t a1)
{
  return *(_DWORD *)(*(void *)a1 + 20) & 0xFFFFFFC0;
}

uint64_t sub_244D22760(uint64_t a1)
{
  return *(_DWORD *)(*(void *)a1 + 20) & 0x3F;
}

uint64_t sub_244D22770(uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  if ((*(_DWORD *)(*(void *)a1 + 20) & 0x3F) == 6)
  {
    if (sub_244D226C8(a1) == 1) {
      return 0;
    }
    uint64_t v1 = *(void *)a1;
  }
  return *(unsigned int *)(v1 + 12);
}

uint64_t sub_244D227D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  return sub_244D224C4(a1, a2, a3, a4, a5, 1);
}

uint64_t sub_244D227E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  return sub_244D224C4(a1, a2, a3, a4, a5, 0);
}

uint64_t sub_244D227E8(int *a1, uint64_t a2, int *a3, char *__src, size_t __n)
{
  if (a1[36])
  {
    int v5 = 66;
    __int16 v6 = 259;
LABEL_13:
    sub_244D0B884(30, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", v6);
    return 0;
  }
  int v7 = __n;
  a1[36] = 1;
  uint64_t v9 = *(void *)a1;
  int v10 = *(_DWORD *)(*(void *)a1 + 4);
  if (v10 >= 2 && (v10 ^ 0x7FFFFFFF) < (int)__n)
  {
    int v5 = 69;
    __int16 v6 = 271;
    goto LABEL_13;
  }
  unint64_t v12 = __src;
  uint64_t v14 = a2;
  if ((*(unsigned char *)(v9 + 21) & 4) != 0)
  {
    int v19 = (*(uint64_t (**)(int *, uint64_t, char *, void))(v9 + 32))(a1, a2, __src, (int)__n);
    if (v19 < 0) {
      return 0;
    }
    *a3 = v19;
    goto LABEL_34;
  }
  if ((int)__n <= 0)
  {
    uint64_t result = 0;
    *a3 = 0;
    if (!__n) {
      goto LABEL_34;
    }
    return result;
  }
  uint64_t v15 = a1[25];
  if (!v15)
  {
    if (((v10 - 1) & __n) != 0)
    {
      int v10 = 0;
      goto LABEL_26;
    }
    uint64_t result = (*(uint64_t (**)(int *, uint64_t, char *, void))(v9 + 32))(a1, a2, __src, __n);
    if (!result)
    {
      *a3 = 0;
      return result;
    }
    *a3 = v7;
LABEL_34:
    a1[36] = 0;
    return 1;
  }
  int v16 = v10 - v15;
  int v17 = __n - (v10 - v15);
  if ((int)__n < v10 - (int)v15)
  {
    memcpy((char *)a1 + v15 + 68, __src, __n);
    a1[25] += v7;
    *a3 = 0;
    goto LABEL_34;
  }
  uint64_t v20 = v16;
  if (v10 != v15)
  {
    memcpy((char *)a1 + v15 + 68, __src, v16);
    uint64_t v9 = *(void *)a1;
  }
  uint64_t result = (*(uint64_t (**)(int *, uint64_t, int *, void))(v9 + 32))(a1, v14, a1 + 17, v10);
  if (!result) {
    return result;
  }
  v12 += v20;
  v14 += v10;
  int v7 = v17;
LABEL_26:
  *a3 = v10;
  int v21 = (*(_DWORD *)(*(void *)a1 + 4) - 1) & v7;
  uint64_t v22 = (v7 - v21);
  if ((int)v22 < 1)
  {
LABEL_29:
    if (v21) {
      memcpy(a1 + 17, &v12[(int)v22], v21);
    }
    a1[25] = v21;
    goto LABEL_34;
  }
  uint64_t result = (*(uint64_t (**)(int *, uint64_t, char *, uint64_t))(*(void *)a1 + 32))(a1, v14, v12, v22);
  if (result)
  {
    *a3 += v22;
    goto LABEL_29;
  }
  return result;
}

uint64_t sub_244D22A1C(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  if (*((_DWORD *)a1 + 36))
  {
    int v3 = 66;
    __int16 v4 = 352;
LABEL_3:
    sub_244D0B884(30, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", v4);
    return 0;
  }
  uint64_t v9 = *a1;
  if ((*(unsigned char *)(*a1 + 21) & 4) != 0)
  {
    int v11 = (*(uint64_t (**)(uint64_t *, uint64_t, void, void))(v9 + 32))(a1, a2, 0, 0);
    if (v11 < 0) {
      return 0;
    }
    *a3 = v11;
    return 1;
  }
  uint64_t v10 = *(unsigned int *)(v9 + 4);
  if (v10 == 1) {
    goto LABEL_7;
  }
  uint64_t v12 = *((unsigned int *)a1 + 25);
  if ((*((unsigned char *)a1 + 33) & 8) != 0)
  {
    if (v12)
    {
      int v3 = 106;
      __int16 v4 = 378;
      goto LABEL_3;
    }
LABEL_7:
    *a3 = 0;
    return 1;
  }
  if (v10 > v12) {
    memset((char *)a1 + v12 + 68, v10 - v12, (v10 + ~v12) + 1);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v9 + 32))(a1, a2, (uint64_t)a1 + 68, v10);
  if (result)
  {
    *a3 = v10;
    return 1;
  }
  return result;
}

uint64_t sub_244D22B38(int *a1, void *a2, int *a3, char *__src, size_t __n)
{
  if (a1[36])
  {
    int v5 = 66;
    __int16 v6 = 402;
LABEL_21:
    sub_244D0B884(30, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", v6);
    return 0;
  }
  uint64_t v9 = *(void *)a1;
  size_t v10 = *(unsigned int *)(*(void *)a1 + 4);
  if (v10 >= 2 && (int)(v10 ^ 0x7FFFFFFF) < (int)__n)
  {
    int v5 = 69;
    __int16 v6 = 410;
    goto LABEL_21;
  }
  uint64_t v14 = (uint64_t)a2;
  if ((*(unsigned char *)(v9 + 21) & 4) != 0)
  {
    int v17 = (*(uint64_t (**)(int *, void *, char *, void))(v9 + 32))(a1, a2, __src, (int)__n);
    int v18 = v17 & ~(v17 >> 31);
    uint64_t result = v17 >= 0;
    *a3 = v18;
    return result;
  }
  if ((int)__n <= 0)
  {
    *a3 = 0;
    return __n == 0;
  }
  if ((*((unsigned char *)a1 + 33) & 8) != 0)
  {
    return sub_244D227E8(a1, (uint64_t)a2, a3, __src, __n);
  }
  else
  {
    int v15 = a1[27];
    if (v15)
    {
      if (v10) {
        memcpy(a2, a1 + 28, v10);
      }
      v14 += v10;
    }
    uint64_t result = sub_244D227E8(a1, v14, a3, __src, __n);
    if (result)
    {
      if (v10 < 2 || a1[25])
      {
        a1[27] = 0;
        if (!v15) {
          return 1;
        }
      }
      else
      {
        *a3 -= v10;
        a1[27] = 1;
        memcpy(a1 + 28, (const void *)(v14 + *a3), v10);
        if (!v15) {
          return 1;
        }
      }
      *a3 += v10;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D22D00(uint64_t *a1, unsigned char *a2, _DWORD *a3)
{
  *a3 = 0;
  if (*((_DWORD *)a1 + 36))
  {
    int v3 = 66;
    __int16 v4 = 469;
LABEL_3:
    sub_244D0B884(30, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", v4);
    return 0;
  }
  uint64_t v7 = *a1;
  if ((*(unsigned char *)(*a1 + 21) & 4) != 0)
  {
    int v9 = (*(uint64_t (**)(void))(v7 + 32))();
    if (v9 < 0) {
      return 0;
    }
    *a3 = v9;
  }
  else if ((*((unsigned char *)a1 + 33) & 8) != 0)
  {
    if (*((_DWORD *)a1 + 25))
    {
      int v3 = 106;
      __int16 v4 = 486;
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(v7 + 4);
    if (v8 >= 2)
    {
      if (*((_DWORD *)a1 + 25) || !*((_DWORD *)a1 + 27))
      {
        int v3 = 123;
        __int16 v4 = 495;
        goto LABEL_3;
      }
      uint64_t v10 = v8 - 1;
      int v11 = *((unsigned __int8 *)a1 + v10 + 112);
      if (*((unsigned char *)a1 + v10 + 112)) {
        BOOL v12 = (int)v8 < v11;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12)
      {
        int v3 = 101;
        __int16 v4 = 504;
        goto LABEL_3;
      }
      int v13 = *((unsigned __int8 *)a1 + v10 + 112);
      do
      {
        if (*((unsigned __int8 *)a1 + v10 + 112) != v11)
        {
          int v3 = 101;
          __int16 v4 = 510;
          goto LABEL_3;
        }
        LODWORD(v10) = v10 - 1;
        --v13;
      }
      while (v13);
      uint64_t v14 = v8 - v11;
      if ((int)v14 >= 1)
      {
        int v15 = (char *)(a1 + 14);
        uint64_t v16 = v14;
        do
        {
          char v17 = *v15++;
          *a2++ = v17;
          --v16;
        }
        while (v16);
      }
      *a3 = v14;
    }
  }
  return 1;
}

uint64_t sub_244D22E78(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
}

uint64_t sub_244D22E84(int *a1, uint64_t a2, int *a3, char *__src, size_t __n)
{
  if (a1[7]) {
    return sub_244D227E8(a1, a2, a3, __src, __n);
  }
  else {
    return sub_244D22B38(a1, (void *)a2, a3, __src, __n);
  }
}

uint64_t sub_244D22E94(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  if (*((_DWORD *)a1 + 7)) {
    return sub_244D22A1C(a1, a2, a3);
  }
  else {
    return sub_244D22D00(a1, (unsigned char *)a2, a3);
  }
}

uint64_t sub_244D22EA4(uint64_t a1)
{
  return *(unsigned int *)(*(void *)a1 + 4);
}

uint64_t sub_244D22EB0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_244D22EB8(uint64_t a1)
{
  return *(_DWORD *)(a1 + 20) & 0x3F;
}

uint64_t sub_244D22EC4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

uint64_t sub_244D22ECC(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 32) & 0xFFFFF7FF | ((a2 == 0) << 11);
  return 1;
}

uint64_t sub_244D22EE8(_DWORD *a1, int a2)
{
  if (a1[6] != a2)
  {
    if (!a2 || (*(unsigned char *)(*(void *)a1 + 20) & 0x40) == 0)
    {
      sub_244D0B884(30, 0, 110, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/cipher.c", 653);
      return 0;
    }
    a1[6] = a2;
  }
  return 1;
}

uint64_t sub_244D22F44(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_244D22F4C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 20) & 0xFFFFFFC0;
}

uint64_t sub_244D22F58(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5)
{
  if (a2)
  {
    *(void *)(a1 + 144) = 0;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
  }
  return sub_244D224C4(a1, a2, a3, a3, a4, a5);
}

uint64_t sub_244D22F88(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  return sub_244D22F58(a1, a2, a3, a4, 1);
}

uint64_t sub_244D22F90(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  return sub_244D22F58(a1, a2, a3, a4, 0);
}

uint64_t *(*sub_244D22FA4(uint64_t a1, uint64_t a2, uint64_t *(**a3)(uint64_t a1, uint64_t a2, uint64_t a3), _OWORD *a4, int a5))(uint64_t *result, uint64_t a2, unint64_t a3, uint64_t a4, _OWORD *a5)
{
  if (a2) {
    sub_244D23028(a2, a1, (uint64_t (*)(unint64_t *, unint64_t *, uint64_t))sub_244D13964);
  }
  if (a3) {
    *a3 = sub_244D13964;
  }
  return sub_244D14738;
}

uint64_t sub_244D23028(uint64_t a1, uint64_t a2, uint64_t (*a3)(unint64_t *, unint64_t *, uint64_t))
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 272) = a3;
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  uint64_t result = a3(&v8, &v8, a2);
  uint64_t v5 = bswap64(v8);
  *((void *)&v7 + 1) = v5;
  *(void *)&long long v7 = bswap64(v9);
  uint64_t v6 = v7 >> 63;
  *((void *)&v7 + 1) = v7;
  *(void *)&long long v7 = v5;
  *(void *)a1 = (v5 >> 63) & 0xC200000000000000 ^ v6;
  *(void *)(a1 + 8) = v7 >> 63;
  *(void *)(a1 + 256) = sub_244D307DC;
  *(void *)(a1 + 264) = sub_244D30858;
  *(unsigned char *)(a1 + 280) &= ~1u;
  return result;
}

long long *sub_244D23110()
{
  return &xmmword_268EBEE90;
}

double sub_244D23148()
{
  qword_268EBEEB8 = 0;
  unk_268EBEEC0 = 0;
  xmmword_268EBEE90 = xmmword_244EB6D50;
  *(void *)&double result = 0x200000108;
  qword_268EBEEA0 = 0x200000108;
  qword_268EBEEA8 = (uint64_t)sub_244D3B90C;
  qword_268EBEEB0 = (uint64_t)sub_244D3B9C8;
  return result;
}

long long *sub_244D23190()
{
  return &xmmword_268EBEED0;
}

double sub_244D231C8()
{
  qword_268EBEEF8 = 0;
  unk_268EBEF00 = 0;
  xmmword_268EBEED0 = xmmword_244EB6D60;
  *(void *)&double result = 0x500000108;
  qword_268EBEEE0 = 0x500000108;
  qword_268EBEEE8 = (uint64_t)sub_244D3B90C;
  qword_268EBEEF0 = (uint64_t)sub_244D3BA2C;
  return result;
}

long long *sub_244D23210()
{
  return &xmmword_268EBEF10;
}

double sub_244D23248()
{
  qword_268EBEF38 = 0;
  unk_268EBEF40 = 0;
  xmmword_268EBEF10 = xmmword_244EB6D70;
  *(void *)&double result = 0x400000108;
  qword_268EBEF20 = 0x400000108;
  qword_268EBEF28 = (uint64_t)sub_244D3B90C;
  qword_268EBEF30 = (uint64_t)sub_244D3BA80;
  return result;
}

long long *sub_244D23290()
{
  return &xmmword_268EBEF50;
}

double sub_244D232C8()
{
  xmmword_268EBEF50 = xmmword_244EB6D80;
  *(void *)&double result = 0x1F86000002A8;
  qword_268EBEF60 = 0x1F86000002A8;
  qword_268EBEF68 = (uint64_t)sub_244D3BAB8;
  qword_268EBEF70 = (uint64_t)sub_244D3BC04;
  qword_268EBEF78 = (uint64_t)sub_244D3BD24;
  qword_268EBEF80 = (uint64_t)sub_244D3BD88;
  return result;
}

long long *sub_244D2332C()
{
  return &xmmword_268EBEF90;
}

double sub_244D23364()
{
  qword_268EBEFB8 = 0;
  unk_268EBEFC0 = 0;
  xmmword_268EBEF90 = xmmword_244EB6D90;
  *(void *)&double result = 0x200000108;
  qword_268EBEFA0 = 0x200000108;
  qword_268EBEFA8 = (uint64_t)sub_244D3B90C;
  qword_268EBEFB0 = (uint64_t)sub_244D3B9C8;
  return result;
}

long long *sub_244D233AC()
{
  return &xmmword_268EBEFD0;
}

double sub_244D233E4()
{
  qword_268EBEFF8 = 0;
  unk_268EBF000 = 0;
  xmmword_268EBEFD0 = xmmword_244EB6DA0;
  *(void *)&double result = 0x500000108;
  qword_268EBEFE0 = 0x500000108;
  qword_268EBEFE8 = (uint64_t)sub_244D3B90C;
  qword_268EBEFF0 = (uint64_t)sub_244D3BA2C;
  return result;
}

long long *sub_244D2342C()
{
  return &xmmword_268EBF010;
}

double sub_244D23464()
{
  qword_268EBF038 = 0;
  unk_268EBF040 = 0;
  xmmword_268EBF010 = xmmword_244EB6DB0;
  *(void *)&double result = 0x400000108;
  qword_268EBF020 = 0x400000108;
  qword_268EBF028 = (uint64_t)sub_244D3B90C;
  qword_268EBF030 = (uint64_t)sub_244D3BA80;
  return result;
}

long long *sub_244D234AC()
{
  return &xmmword_268EBF050;
}

double sub_244D234E4()
{
  xmmword_268EBF050 = xmmword_244EB6DC0;
  *(void *)&double result = 0x1F86000002A8;
  qword_268EBF060 = 0x1F86000002A8;
  qword_268EBF068 = (uint64_t)sub_244D3BAB8;
  qword_268EBF070 = (uint64_t)sub_244D3BC04;
  qword_268EBF078 = (uint64_t)sub_244D3BD24;
  qword_268EBF080 = (uint64_t)sub_244D3BD88;
  return result;
}

long long *sub_244D23548()
{
  return &xmmword_268EBF090;
}

double sub_244D23580()
{
  qword_268EBF0B8 = 0;
  unk_268EBF0C0 = 0;
  xmmword_268EBF090 = xmmword_244EB6DD0;
  *(void *)&double result = 0x200000108;
  qword_268EBF0A0 = 0x200000108;
  qword_268EBF0A8 = (uint64_t)sub_244D3B90C;
  qword_268EBF0B0 = (uint64_t)sub_244D3B9C8;
  return result;
}

long long *sub_244D235C8()
{
  return &xmmword_268EBF0D0;
}

double sub_244D23600()
{
  qword_268EBF0F8 = 0;
  unk_268EBF100 = 0;
  xmmword_268EBF0D0 = xmmword_244EB6DE0;
  *(void *)&double result = 0x500000108;
  qword_268EBF0E0 = 0x500000108;
  qword_268EBF0E8 = (uint64_t)sub_244D3B90C;
  qword_268EBF0F0 = (uint64_t)sub_244D3BA2C;
  return result;
}

long long *sub_244D23648()
{
  return &xmmword_268EBF110;
}

double sub_244D23680()
{
  qword_268EBF138 = 0;
  unk_268EBF140 = 0;
  xmmword_268EBF110 = xmmword_244EB6DF0;
  *(void *)&double result = 0x400000108;
  qword_268EBF120 = 0x400000108;
  qword_268EBF128 = (uint64_t)sub_244D3B90C;
  qword_268EBF130 = (uint64_t)sub_244D3BA80;
  return result;
}

long long *sub_244D236C8()
{
  return &xmmword_268EBF150;
}

double sub_244D23700()
{
  xmmword_268EBF150 = xmmword_244EB6E00;
  *(void *)&double result = 0x1F86000002A8;
  qword_268EBF160 = 0x1F86000002A8;
  qword_268EBF168 = (uint64_t)sub_244D3BAB8;
  qword_268EBF170 = (uint64_t)sub_244D3BC04;
  qword_268EBF178 = (uint64_t)sub_244D3BD24;
  qword_268EBF180 = (uint64_t)sub_244D3BD88;
  return result;
}

uint64_t *sub_244D23764()
{
  return &qword_268EBF188;
}

uint64_t *sub_244D2379C()
{
  return &qword_268EBF1C0;
}

uint64_t *sub_244D237D4()
{
  return &qword_268EBF1F8;
}

int *sub_244D2380C()
{
  return &dword_268EBF230;
}

double sub_244D23844()
{
  xmmword_268EBF240 = 0u;
  unk_268EBF250 = 0u;
  xmmword_268EBF260 = 0u;
  qword_268EBF270 = 0;
  *(void *)&double result = 269487120;
  dword_268EBF230 = 269487120;
  dword_268EBF234 = 1;
  qword_268EBF238 = (uint64_t)sub_244D3C258;
  *((void *)&xmmword_268EBF240 + 1) = nullsub_847;
  qword_268EBF258 = (uint64_t)sub_244D3C2B0;
  *(void *)&xmmword_268EBF260 = sub_244D3C2E8;
  return result;
}

int *sub_244D238B4()
{
  return &dword_268EBF278;
}

double sub_244D238EC()
{
  xmmword_268EBF288 = 0u;
  unk_268EBF298 = 0u;
  xmmword_268EBF2A8 = 0u;
  qword_268EBF2B8 = 0;
  *(void *)&double result = 269487128;
  dword_268EBF278 = 269487128;
  dword_268EBF27C = 1;
  qword_268EBF280 = (uint64_t)sub_244D3C258;
  *((void *)&xmmword_268EBF288 + 1) = nullsub_847;
  qword_268EBF2A0 = (uint64_t)sub_244D3C2B0;
  *(void *)&xmmword_268EBF2A8 = sub_244D3C2E8;
  return result;
}

int *sub_244D2395C()
{
  return &dword_268EBF2C0;
}

double sub_244D23994()
{
  xmmword_268EBF2D0 = 0u;
  unk_268EBF2E0 = 0u;
  xmmword_268EBF2F0 = 0u;
  qword_268EBF300 = 0;
  *(void *)&double result = 269487136;
  dword_268EBF2C0 = 269487136;
  dword_268EBF2C4 = 1;
  qword_268EBF2C8 = (uint64_t)sub_244D3C258;
  *((void *)&xmmword_268EBF2D0 + 1) = nullsub_847;
  qword_268EBF2E8 = (uint64_t)sub_244D3C2B0;
  *(void *)&xmmword_268EBF2F0 = sub_244D3C2E8;
  return result;
}

int *sub_244D23A04()
{
  return &dword_268EBF308;
}

double sub_244D23A3C()
{
  xmmword_268EBF318 = 0u;
  unk_268EBF328 = 0u;
  xmmword_268EBF338 = 0u;
  qword_268EBF348 = 0;
  *(void *)&double result = 471597072;
  dword_268EBF308 = 471597072;
  dword_268EBF30C = 1;
  qword_268EBF310 = (uint64_t)sub_244D3C7F8;
  *((void *)&xmmword_268EBF318 + 1) = nullsub_847;
  qword_268EBF330 = (uint64_t)sub_244D3C88C;
  *(void *)&xmmword_268EBF338 = sub_244D3C9EC;
  return result;
}

int *sub_244D23AAC()
{
  return &dword_268EBF350;
}

double sub_244D23AE4()
{
  xmmword_268EBF360 = 0u;
  unk_268EBF370 = 0u;
  xmmword_268EBF380 = 0u;
  qword_268EBF390 = 0;
  *(void *)&double result = 471597088;
  dword_268EBF350 = 471597088;
  dword_268EBF354 = 1;
  qword_268EBF358 = (uint64_t)sub_244D3C7F8;
  *((void *)&xmmword_268EBF360 + 1) = nullsub_847;
  qword_268EBF378 = (uint64_t)sub_244D3C88C;
  *(void *)&xmmword_268EBF380 = sub_244D3C9EC;
  return result;
}

int *sub_244D23B54()
{
  return &dword_268EBF398;
}

double sub_244D23B8C()
{
  xmmword_268EBF3A8 = 0u;
  unk_268EBF3B8 = 0u;
  xmmword_268EBF3C8 = 0u;
  qword_268EBF3D8 = 0;
  *(void *)&double result = 269487120;
  dword_268EBF398 = 269487120;
  dword_268EBF39C = 1;
  qword_268EBF3A0 = (uint64_t)sub_244D3CA80;
  *((void *)&xmmword_268EBF3A8 + 1) = nullsub_847;
  qword_268EBF3C0 = (uint64_t)sub_244D3CAD8;
  *(void *)&xmmword_268EBF3C8 = sub_244D3C2E8;
  return result;
}

int *sub_244D23BFC()
{
  return &dword_268EBF3E0;
}

double sub_244D23C34()
{
  xmmword_268EBF3F0 = 0u;
  unk_268EBF400 = 0u;
  xmmword_268EBF410 = 0u;
  qword_268EBF420 = 0;
  *(void *)&double result = 269487136;
  dword_268EBF3E0 = 269487136;
  dword_268EBF3E4 = 1;
  qword_268EBF3E8 = (uint64_t)sub_244D3CA80;
  *((void *)&xmmword_268EBF3F0 + 1) = nullsub_847;
  qword_268EBF408 = (uint64_t)sub_244D3CAD8;
  *(void *)&xmmword_268EBF410 = sub_244D3C2E8;
  return result;
}

int *sub_244D23CA4()
{
  return &dword_268EBF428;
}

double sub_244D23CDC()
{
  xmmword_268EBF438 = 0u;
  unk_268EBF448 = 0u;
  xmmword_268EBF458 = 0u;
  qword_268EBF468 = 0;
  *(void *)&double result = 269487120;
  dword_268EBF428 = 269487120;
  dword_268EBF42C = 1;
  qword_268EBF430 = (uint64_t)sub_244D3CB8C;
  *((void *)&xmmword_268EBF438 + 1) = nullsub_847;
  qword_268EBF450 = (uint64_t)sub_244D3CBEC;
  *(void *)&xmmword_268EBF458 = sub_244D3C2E8;
  return result;
}

int *sub_244D23D4C()
{
  return &dword_268EBF470;
}

double sub_244D23D84()
{
  xmmword_268EBF480 = 0u;
  unk_268EBF490 = 0u;
  xmmword_268EBF4A0 = 0u;
  qword_268EBF4B0 = 0;
  *(void *)&double result = 269487136;
  dword_268EBF470 = 269487136;
  dword_268EBF474 = 1;
  qword_268EBF478 = (uint64_t)sub_244D3CB8C;
  *((void *)&xmmword_268EBF480 + 1) = nullsub_847;
  qword_268EBF498 = (uint64_t)sub_244D3CBEC;
  *(void *)&xmmword_268EBF4A0 = sub_244D3C2E8;
  return result;
}

long long *sub_244D23DF4()
{
  return &xmmword_268EBF4B8;
}

double sub_244D23E2C()
{
  xmmword_268EBF4B8 = 0u;
  *(_OWORD *)algn_268EBF4C8 = 0u;
  xmmword_268EBF4D8 = 0u;
  *(_OWORD *)&qword_268EBF4E8 = 0u;
  qword_268EBF4F8 = 0;
  *(void *)&double result = 67374352;
  LODWORD(xmmword_268EBF4B8) = 67374352;
  *((void *)&xmmword_268EBF4B8 + 1) = sub_244D3CCC0;
  qword_268EBF4D0 = (uint64_t)nullsub_848;
  *((void *)&xmmword_268EBF4D8 + 1) = sub_244D3CCCC;
  qword_268EBF4E8 = (uint64_t)sub_244D3CE88;
  return result;
}

long long *sub_244D23E94()
{
  return &xmmword_268EBF500;
}

double sub_244D23ECC()
{
  xmmword_268EBF500 = 0u;
  unk_268EBF510 = 0u;
  xmmword_268EBF520 = 0u;
  *(_OWORD *)&qword_268EBF530 = 0u;
  qword_268EBF540 = 0;
  *(void *)&double result = 134745360;
  LODWORD(xmmword_268EBF500) = 134745360;
  *((void *)&xmmword_268EBF500 + 1) = sub_244D3D644;
  qword_268EBF518 = (uint64_t)nullsub_848;
  *((void *)&xmmword_268EBF520 + 1) = sub_244D3CCCC;
  qword_268EBF530 = (uint64_t)sub_244D3CE88;
  return result;
}

long long *sub_244D23F34()
{
  return &xmmword_268EBF548;
}

double sub_244D23F6C()
{
  xmmword_268EBF548 = 0u;
  *(_OWORD *)algn_268EBF558 = 0u;
  xmmword_268EBF568 = 0u;
  *(_OWORD *)&qword_268EBF578 = 0u;
  qword_268EBF588 = 0;
  *(void *)&double result = 269487376;
  LODWORD(xmmword_268EBF548) = 269487376;
  *((void *)&xmmword_268EBF548 + 1) = sub_244D3D64C;
  qword_268EBF560 = (uint64_t)nullsub_848;
  *((void *)&xmmword_268EBF568 + 1) = sub_244D3CCCC;
  qword_268EBF578 = (uint64_t)sub_244D3CE88;
  return result;
}

BOOL sub_244D23FD4(unsigned char *a1, uint64_t a2, uint64_t a3, char *a4, size_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (a3 == 32)
  {
    sub_244D4BDB4(&stru_268EBD680, (void (*)(void))sub_244D23580);
    uint64_t v10 = &xmmword_268EBF090;
  }
  else
  {
    if (a3 != 16) {
      return 0;
    }
    sub_244D4BDB4(&stru_268EBD600, (void (*)(void))sub_244D23148);
    uint64_t v10 = &xmmword_268EBEE90;
  }
  memset(v14, 0, sizeof(v14));
  BOOL v11 = sub_244D24124((uint64_t)v14, a2, a3, (uint64_t)v10)
     && sub_244D24334((unsigned int *)v14, a4, a5)
     && sub_244D2445C((unsigned int *)v14, a1, &v13) != 0;
  sub_244D24544((uint64_t)v14);
  return v11;
}

uint64_t sub_244D24124(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a4 + 4);
  BOOL v5 = v4 == 16 || v4 == 8;
  if (!v5 || *(_DWORD *)(a4 + 8) != a3) {
    return 0;
  }
  uint64_t result = sub_244D224C4(a1, a4, a3, a2, &unk_244EB70B4, 1);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *, void *, uint64_t))(*(void *)a1 + 32))(a1, v35, &unk_244EB70B4, v4);
    if (result)
    {
      uint64_t result = sub_244D224C4(a1, 0, v8, 0, &unk_244EB70B4, 1);
      if (result)
      {
        uint64_t v9 = a1 + 152;
        int v10 = v35[0];
        if (v4 == 16)
        {
          uint64_t v11 = 0;
          int v12 = v35[0];
          do
          {
            int v13 = v35[v11 + 1];
            HIDWORD(v14) = v12;
            LODWORD(v14) = v13 << 24;
            *(unsigned char *)(v9 + v11) = v14 >> 31;
            int v12 = v13;
            ++v11;
          }
          while (v11 != 15);
          uint64_t v15 = 0;
          unsigned int v16 = (v10 >> 7) & 0xFFFFFF87 ^ (2 * v35[15]);
          *(unsigned char *)(a1 + 167) = v16;
          unsigned int v17 = *(char *)(a1 + 152);
          unsigned int v18 = v17;
          do
          {
            uint64_t v19 = a1 + v15;
            uint64_t v20 = v15 + 1;
            unsigned int v21 = *(unsigned __int8 *)(a1 + v15 + 153);
            HIDWORD(v22) = v18;
            LODWORD(v22) = v21 << 24;
            *(unsigned char *)(v19 + 168) = v22 >> 31;
            unsigned int v18 = v21;
            uint64_t v15 = v20;
          }
          while (v20 != 15);
          *(unsigned char *)(a1 + 183) = (v17 >> 7) & 0x87 ^ (2 * v16);
        }
        else
        {
          uint64_t v23 = 0;
          int v24 = v35[0];
          do
          {
            int v25 = v35[v23 + 1];
            HIDWORD(v26) = v24;
            LODWORD(v26) = v25 << 24;
            *(unsigned char *)(v9 + v23) = v26 >> 31;
            int v24 = v25;
            ++v23;
          }
          while (v23 != 7);
          uint64_t v27 = 0;
          int v28 = (v10 >> 7) & 0x1B ^ (2 * v35[7]);
          *(unsigned char *)(a1 + 159) = v28;
          unsigned int v29 = *(char *)(a1 + 152);
          unsigned int v30 = v29;
          do
          {
            uint64_t v31 = a1 + v27;
            uint64_t v32 = v27 + 1;
            unsigned int v33 = *(unsigned __int8 *)(a1 + v27 + 153);
            HIDWORD(v34) = v30;
            LODWORD(v34) = v33 << 24;
            *(unsigned char *)(v31 + 168) = v34 >> 31;
            unsigned int v30 = v33;
            uint64_t v27 = v32;
          }
          while (v32 != 7);
          *(unsigned char *)(a1 + 175) = (v29 >> 7) & 0x1B ^ (2 * v28);
        }
        *(_DWORD *)(a1 + 200) = 0;
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_244D24334(unsigned int *a1, char *__src, size_t __n)
{
  size_t v3 = __n;
  uint64_t v4 = __src;
  uint64_t v11 = *MEMORY[0x263EF8340];
  size_t v6 = *(unsigned int *)(*(void *)a1 + 4);
  uint64_t v7 = a1[50];
  if (!v7)
  {
LABEL_12:
    while (v3 > v6)
    {
      uint64_t result = (*(uint64_t (**)(unsigned int *, unsigned char *, char *, size_t))(*(void *)a1 + 32))(a1, v10, v4, v6);
      if (!result) {
        return result;
      }
      v4 += v6;
      v3 -= v6;
    }
    if (v3) {
      memcpy(a1 + 46, v4, v3);
    }
    a1[50] = v3;
    return 1;
  }
  if (v6 - v7 >= __n) {
    size_t v8 = __n;
  }
  else {
    size_t v8 = v6 - v7;
  }
  if (v8)
  {
    memcpy((char *)a1 + v7 + 184, __src, v8);
    LODWORD(v7) = a1[50];
  }
  a1[50] = v7 + v8;
  v3 -= v8;
  if (!v3) {
    return 1;
  }
  uint64_t result = (*(uint64_t (**)(unsigned int *, unsigned char *, unsigned int *, size_t))(*(void *)a1 + 32))(a1, v10, a1 + 46, v6);
  if (result)
  {
    v4 += v8;
    goto LABEL_12;
  }
  return result;
}

uint64_t sub_244D2445C(unsigned int *a1, unsigned char *a2, void *a3)
{
  uint64_t v3 = *(unsigned int *)(*(void *)a1 + 4);
  *a3 = v3;
  if (!a2) {
    return 1;
  }
  uint64_t v6 = a1[50];
  if (v6 == v3)
  {
    uint64_t v7 = (char *)(a1 + 38);
    if (!v3) {
      goto LABEL_11;
    }
  }
  else
  {
    *((unsigned char *)a1 + v6 + 184) = 0x80;
    uint64_t v9 = a1[50];
    if (v3 != v9 + 1) {
      bzero((char *)a1 + v9 + 185, v3 - (v9 + 1));
    }
    uint64_t v7 = (char *)(a1 + 42);
    if (!v3) {
      goto LABEL_11;
    }
  }
  int v10 = (char *)(a1 + 46);
  uint64_t v11 = v3;
  int v12 = a2;
  do
  {
    char v14 = *v10++;
    char v13 = v14;
    char v15 = *v7++;
    *v12++ = v15 ^ v13;
    --v11;
  }
  while (v11);
LABEL_11:
  unsigned int v16 = *(uint64_t (**)(unsigned int *, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 32);

  return v16(a1, a2, a2, v3);
}

void sub_244D24544(uint64_t a1)
{
  sub_244D222E0(a1);
  sub_244D4413C((void *)(a1 + 152), 0x10uLL);
  sub_244D4413C((void *)(a1 + 168), 0x10uLL);

  sub_244D4413C((void *)(a1 + 184), 0x10uLL);
}

double sub_244D24598()
{
  uint64_t v0 = sub_244D43FF4(0xD0uLL);
  if (v0)
  {
    v0[18] = 0;
    double result = 0.0;
    *((_OWORD *)v0 + 7) = 0u;
    *((_OWORD *)v0 + 8) = 0u;
    *((_OWORD *)v0 + 5) = 0u;
    *((_OWORD *)v0 + 6) = 0u;
    *((_OWORD *)v0 + 3) = 0u;
    *((_OWORD *)v0 + 4) = 0u;
    *((_OWORD *)v0 + 1) = 0u;
    *((_OWORD *)v0 + 2) = 0u;
    *(_OWORD *)uint64_t v0 = 0u;
  }
  return result;
}

void sub_244D245D4(void *a1)
{
  if (a1)
  {
    sub_244D24544((uint64_t)a1);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D24614(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244D22380(a1, (uint64_t *)a2);
  if (result)
  {
    *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
    *(_DWORD *)(a1 + 200) = *(_DWORD *)(a2 + 200);
    return 1;
  }
  return result;
}

uint64_t sub_244D24664(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 200) = 0;
  return sub_244D224C4(a1, 0, a3, 0, &unk_244EB70B4, 1);
}

uint64_t sub_244D24680(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*(_DWORD *)(v2 + 16)
    || (unint64_t v5 = *(unsigned int *)(v2 + 8), (int)v5 < 1)
    || (uint64_t v6 = *(uint64_t **)v2, (**(unsigned char **)v2 & 1) == 0)
    || sub_244D168EC((uint64_t *)v2) > 0x2710)
  {
    __int16 v3 = 69;
LABEL_3:
    sub_244D0B884(5, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/dh/check.c", v3);
    return 0;
  }
  uint64_t v7 = a1[2];
  if (v7 && (*(_DWORD *)(v7 + 16) || (int)sub_244D170B4(*(uint64_t **)v7, *(int *)(v7 + 8), v6, v5) > 0))
  {
    __int16 v3 = 75;
    goto LABEL_3;
  }
  uint64_t v8 = a1[1];
  if (*(_DWORD *)(v8 + 16)) {
    goto LABEL_12;
  }
  unint64_t v9 = *(int *)(v8 + 8);
  if (!v9) {
    goto LABEL_12;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v12 = *(uint64_t **)v8;
  do
    v11 |= v12[v10++];
  while (v9 != v10);
  if (!v11 || (sub_244D170B4(v12, v9, v6, (int)v5) & 0x80000000) == 0)
  {
LABEL_12:
    __int16 v3 = 82;
    goto LABEL_3;
  }
  return 1;
}

uint64_t sub_244D24788(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 0;
  if (!sub_244D24680(a1)) {
    return 0;
  }
  uint64_t v6 = sub_244D43FF4(0x30uLL);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = (uint64_t)v6;
  *(_OWORD *)((char *)v6 + 26) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  sub_244D1756C(v6);
  sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
  if ((int)sub_244D17194(a2, (uint64_t)&qword_268EBEE70) <= 0) {
    *a3 |= 1u;
  }
  uint64_t v8 = sub_244D17610(v7);
  if (!v8) {
    goto LABEL_16;
  }
  unint64_t v9 = (unsigned int *)v8;
  if (!sub_244D16764((void **)v8, *a1) || !sub_244D1618C((uint64_t)v9, 1uLL)) {
    goto LABEL_16;
  }
  if ((sub_244D17194(a2, (uint64_t)v9) & 0x80000000) == 0) {
    *a3 |= 2u;
  }
  uint64_t v10 = a1[2];
  if (!v10) {
    goto LABEL_14;
  }
  if (!sub_244D19BB4((uint64_t)v9, a2, v10, *a1, v7, 0))
  {
LABEL_16:
    uint64_t v11 = 0;
    goto LABEL_17;
  }
  if (!sub_244D172C8(v9)) {
    *a3 |= 4u;
  }
LABEL_14:
  uint64_t v11 = 1;
LABEL_17:
  if (!*(unsigned char *)(v7 + 40))
  {
    uint64_t v12 = *(void *)(v7 + 8);
    uint64_t v13 = *(void *)(v7 + 16) - 1;
    *(void *)(v7 + 16) = v13;
    *(void *)(v7 + 32) = *(void *)(v12 + 8 * v13);
  }
  sub_244D17500((unint64_t **)v7);
  return v11;
}

uint64_t sub_244D248EC(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  if (!sub_244D24680((uint64_t *)a1)) {
    return 0;
  }
  uint64_t v4 = sub_244D43FF4(0x30uLL);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (uint64_t)v4;
  *(_OWORD *)((char *)v4 + 26) = 0u;
  *(_OWORD *)uint64_t v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  sub_244D1756C(v4);
  uint64_t v6 = sub_244D17610(v5);
  if (!v6) {
    goto LABEL_45;
  }
  uint64_t v7 = (unsigned int *)v6;
  uint64_t v8 = sub_244D17610(v5);
  if (!v8) {
    goto LABEL_45;
  }
  unint64_t v9 = *(unsigned int **)(a1 + 8);
  if (!*(void *)(a1 + 16))
  {
    if (sub_244D17320(*(unsigned int **)(a1 + 8), 2))
    {
      uint64_t v18 = *(unsigned int *)(*(void *)a1 + 8);
      if ((int)v18 >= 1)
      {
        unint64_t v19 = v18 + 1;
        do
        {
          uint64_t v20 = __umodti3();
          --v19;
        }
        while (v19 > 1);
        if (!(v20 ^ 0xB | v21)) {
          goto LABEL_34;
        }
      }
    }
    else
    {
      if (!sub_244D17320(v9, 5))
      {
        int v16 = 4;
        goto LABEL_33;
      }
      uint64_t v22 = *(unsigned int *)(*(void *)a1 + 8);
      if ((int)v22 >= 1)
      {
        unint64_t v23 = v22 + 1;
        do
        {
          char v24 = __umodti3();
          --v23;
        }
        while (v23 > 1);
        if ((v24 & 0xB) == 3) {
          goto LABEL_34;
        }
      }
    }
    int v16 = 8;
    goto LABEL_33;
  }
  uint64_t v10 = (unsigned int *)v8;
  sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
  if ((int)sub_244D17194((uint64_t)v9, (uint64_t)&qword_268EBEE70) < 1) {
    goto LABEL_8;
  }
  uint64_t v11 = *(void *)a1;
  uint64_t v12 = *(void *)(a1 + 8);
  if ((sub_244D17194(v12, *(void *)a1) & 0x80000000) == 0) {
    goto LABEL_8;
  }
  if (!sub_244D19BB4((uint64_t)v7, v12, *(void *)(a1 + 16), v11, v5, 0)) {
    goto LABEL_45;
  }
  if (!sub_244D172C8(v7)) {
LABEL_8:
  }
    *a2 |= 8u;
  uint64_t v13 = *(void *)(a1 + 16);
  int v34 = 0;
  int v14 = sub_244D1FE18(&v34, v13, 64, v5, 0, 0);
  int v15 = v34;
  if (!v14) {
    int v15 = -1;
  }
  if (v15 < 0) {
    goto LABEL_45;
  }
  if (!v15) {
    *a2 |= 0x10u;
  }
  if (!sub_244D17728((unint64_t *)v7, (uint64_t)v10, *(void *)a1, *(void *)(a1 + 16), v5)) {
    goto LABEL_45;
  }
  if (!sub_244D172C8(v10))
  {
    int v16 = 32;
LABEL_33:
    *a2 |= v16;
  }
LABEL_34:
  uint64_t v25 = *(void *)a1;
  int v35 = 0;
  int v26 = sub_244D1FE18(&v35, v25, 64, v5, 0, 0);
  int v27 = v35;
  if (!v26) {
    int v27 = -1;
  }
  if ((v27 & 0x80000000) == 0)
  {
    if (!v27)
    {
      int v30 = 1;
      goto LABEL_51;
    }
    if (*(void *)(a1 + 16))
    {
LABEL_52:
      uint64_t v17 = 1;
      goto LABEL_46;
    }
    if (sub_244D1B5D8((uint64_t)v7, *(uint64_t **)a1))
    {
      int v36 = 0;
      int v28 = sub_244D1FE18(&v36, (uint64_t)v7, 64, v5, 0, 0);
      int v29 = v36;
      if (!v28) {
        int v29 = -1;
      }
      if ((v29 & 0x80000000) == 0)
      {
        if (!v29)
        {
          int v30 = 2;
LABEL_51:
          *a2 |= v30;
          goto LABEL_52;
        }
        goto LABEL_52;
      }
    }
  }
LABEL_45:
  uint64_t v17 = 0;
LABEL_46:
  if (!*(unsigned char *)(v5 + 40))
  {
    uint64_t v31 = *(void *)(v5 + 8);
    uint64_t v32 = *(void *)(v5 + 16) - 1;
    *(void *)(v5 + 16) = v32;
    *(void *)(v5 + 32) = *(void *)(v31 + 8 * v32);
  }
  sub_244D17500((unint64_t **)v5);
  return v17;
}

void *sub_244D24C2C()
{
  uint64_t v0 = sub_244D44058(0x108uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    sub_244D4BD2C((pthread_rwlock_t *)(v0 + 6));
    *((_DWORD *)v1 + 65) = 1;
  }
  return v1;
}

void sub_244D24C6C(uint64_t a1)
{
  if (a1 && sub_244D49A14((unsigned int *)(a1 + 260)))
  {
    sub_244D1A288(*(void ***)(a1 + 248));
    sub_244D166B0(*(void ***)a1);
    sub_244D166B0(*(void ***)(a1 + 8));
    sub_244D166B0(*(void ***)(a1 + 16));
    sub_244D166B0(*(void ***)(a1 + 24));
    sub_244D166B0(*(void ***)(a1 + 32));
    j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 48));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D24CF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    sub_244D166B0(*(void ***)(a1 + 24));
    *(void *)(a1 + 24) = a2;
  }
  if (a3)
  {
    sub_244D166B0(*(void ***)(a1 + 32));
    *(void *)(a1 + 32) = a3;
  }
  return 1;
}

void *sub_244D24D48(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = *result;
  }
  if (a3) {
    *a3 = result[2];
  }
  if (a4) {
    *a4 = result[1];
  }
  return result;
}

uint64_t sub_244D24D70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(void *)a1;
  if (!(a2 | v5) || !(a4 | *(void *)(a1 + 8))) {
    return 0;
  }
  if (a2)
  {
    sub_244D166B0((void **)v5);
    *(void *)a1 = a2;
  }
  if (a3)
  {
    sub_244D166B0(*(void ***)(a1 + 16));
    *(void *)(a1 + 16) = a3;
  }
  if (a4)
  {
    sub_244D166B0(*(void ***)(a1 + 8));
    *(void *)(a1 + 8) = a4;
  }
  sub_244D1A288(*(void ***)(a1 + 248));
  *(void *)(a1 + 248) = 0;
  return 1;
}

uint64_t sub_244D24E00(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 40) = a2;
  return 1;
}

uint64_t sub_244D24E0C(uint64_t a1)
{
  if (!sub_244D24680((uint64_t *)a1)) {
    return 0;
  }
  uint64_t v2 = sub_244D43FF4(0x30uLL);
  __int16 v3 = (unint64_t **)v2;
  if (!v2)
  {
    uint64_t v6 = 0;
    unint64_t v5 = 0;
LABEL_14:
    uint64_t v7 = 0;
    goto LABEL_15;
  }
  *(_OWORD *)((char *)v2 + 26) = 0u;
  _OWORD *v2 = 0u;
  v2[1] = 0u;
  uint64_t v4 = *(void **)(a1 + 32);
  unint64_t v5 = v4;
  if (!v4)
  {
    unint64_t v5 = sub_244D16670();
    if (!v5)
    {
      uint64_t v6 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v6 = *(void **)(a1 + 24);
  if (!v6)
  {
    uint64_t v6 = sub_244D16670();
    if (!v6) {
      goto LABEL_14;
    }
  }
  if (!sub_244D1E430((void *)(a1 + 248), (pthread_rwlock_t *)(a1 + 48), *(void *)a1, (uint64_t)v3)) {
    goto LABEL_14;
  }
  if (v4)
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      uint64_t v7 = 0;
      if (!sub_244D1C18C((uint64_t)v5, 1uLL, v10)) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v7 = sub_244D16670();
      if (!v7) {
        goto LABEL_15;
      }
      unsigned int v11 = *(_DWORD *)(a1 + 40);
      uint64_t v12 = *(uint64_t **)a1;
      if (v11 && v11 < sub_244D168EC(*(uint64_t **)a1) - 1)
      {
        if (!sub_244D1E2A0((uint64_t)v7, v11)) {
          goto LABEL_15;
        }
      }
      else if (!sub_244D1B5D8((uint64_t)v7, v12))
      {
        goto LABEL_15;
      }
      if (!sub_244D1C18C((uint64_t)v5, 1uLL, (uint64_t)v7)) {
        goto LABEL_15;
      }
    }
  }
  if (!sub_244D1A91C((uint64_t)v6, *(void *)(a1 + 8), (uint64_t)v5, *(void *)a1, (uint64_t)v3, *(void *)(a1 + 248)))
  {
LABEL_15:
    sub_244D0B884(5, 0, 3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/dh/dh.c", 282);
    if (!*(void *)(a1 + 24)) {
      sub_244D166B0((void **)v6);
    }
    uint64_t v8 = 0;
    goto LABEL_18;
  }
  *(void *)(a1 + 24) = v6;
  *(void *)(a1 + 32) = v5;
  uint64_t v8 = 1;
LABEL_18:
  if (!*(void *)(a1 + 32)) {
    sub_244D166B0((void **)v5);
  }
  sub_244D166B0((void **)v7);
  sub_244D17500(v3);
  return v8;
}

uint64_t sub_244D24FD4(char *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v6 = sub_244D43FF4(0x30uLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (uint64_t)v6;
  *(_OWORD *)((char *)v6 + 26) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  sub_244D1756C(v6);
  int v8 = sub_244D168EC(*a3);
  unint64_t v9 = sub_244D17610(v7);
  if (v9 && (uint64_t v10 = (uint64_t)v9, sub_244D250DC((uint64_t)a3, (uint64_t)v9, a2, v7)))
  {
    if (sub_244D16FA8(a1, (v8 + 7) >> 3, v10)) {
      uint64_t v11 = (v8 + 7) >> 3;
    }
    else {
      uint64_t v11 = 0xFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(v7 + 40))
  {
    uint64_t v12 = *(void *)(v7 + 8);
    uint64_t v13 = *(void *)(v7 + 16) - 1;
    *(void *)(v7 + 16) = v13;
    *(void *)(v7 + 32) = *(void *)(v12 + 8 * v13);
  }
  sub_244D17500((unint64_t **)v7);
  return v11;
}

uint64_t sub_244D250B8(uint64_t **a1)
{
  return (sub_244D168EC(*a1) + 7) >> 3;
}

uint64_t sub_244D250DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_244D24680((uint64_t *)a1);
  if (result)
  {
    if (*(void *)(a1 + 32))
    {
      int v16 = 0;
      if (sub_244D24788((uint64_t *)a1, a3, &v16) && !v16)
      {
        sub_244D1756C((void *)a4);
        uint64_t result = (uint64_t)sub_244D17610(a4);
        if (!result) {
          goto LABEL_18;
        }
        unint64_t v9 = (void **)result;
        uint64_t result = sub_244D1E430((void *)(a1 + 248), (pthread_rwlock_t *)(a1 + 48), *(void *)a1, a4);
        if (!result) {
          goto LABEL_18;
        }
        if (sub_244D1A91C(a2, a3, *(void *)(a1 + 32), *(void *)a1, a4, *(void *)(a1 + 248))
          && sub_244D16764(v9, *(void *)a1)
          && sub_244D1618C((uint64_t)v9, 1uLL))
        {
          uint64_t v18 = 1;
          _OWORD v17[2] = 0x200000000;
          v17[0] = &v18;
          v17[1] = 0x100000001;
          if ((int)sub_244D17194(a2, (uint64_t)v17) >= 1 && sub_244D17194(a2, (uint64_t)v9))
          {
            uint64_t result = 1;
            goto LABEL_18;
          }
          int v12 = 101;
          __int16 v13 = 334;
        }
        else
        {
          int v12 = 3;
          __int16 v13 = 327;
        }
        sub_244D0B884(5, 0, v12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/dh/dh.c", v13);
        uint64_t result = 0;
LABEL_18:
        if (!*(unsigned char *)(a4 + 40))
        {
          uint64_t v14 = *(void *)(a4 + 8);
          uint64_t v15 = *(void *)(a4 + 16) - 1;
          *(void *)(a4 + 16) = v15;
          *(void *)(a4 + 32) = *(void *)(v14 + 8 * v15);
        }
        return result;
      }
      int v10 = 101;
      __int16 v11 = 309;
    }
    else
    {
      int v10 = 103;
      __int16 v11 = 303;
    }
    sub_244D0B884(5, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/dh/dh.c", v11);
    return 0;
  }
  return result;
}

uint64_t sub_244D252A8(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_244D43FF4(0x30uLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (uint64_t)v6;
  *(_OWORD *)((char *)v6 + 26) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  sub_244D1756C(v6);
  int v8 = sub_244D17610(v7);
  if (v8 && (unint64_t v9 = v8, sub_244D250DC(a3, (uint64_t)v8, a2, v7)))
  {
    unint64_t v10 = (sub_244D168EC((uint64_t *)v9) + 7) >> 3;
    sub_244D16E80(a1, v10, (char *)*v9, *((int *)v9 + 2));
  }
  else
  {
    unint64_t v10 = 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(v7 + 40))
  {
    uint64_t v11 = *(void *)(v7 + 8);
    uint64_t v12 = *(void *)(v7 + 16) - 1;
    *(void *)(v7 + 16) = v12;
    *(void *)(v7 + 32) = *(void *)(v11 + 8 * v12);
  }
  sub_244D17500((unint64_t **)v7);
  return v10;
}

uint64_t sub_244D25384(uint64_t **a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  *a3 = -1;
  unint64_t v6 = *(unsigned int *)(a6 + 4);
  if (v6 > a4) {
    return 0;
  }
  unint64_t v13 = (sub_244D168EC(*a1) + 7) >> 3;
  uint64_t v14 = (char *)sub_244D43FF4(v13);
  uint64_t v15 = v14;
  int v18 = 0;
  if (v14
    && sub_244D24FD4(v14, a5, a1) == v13
    && (sub_244D25474((uint64_t)v15, v13, a2, &v18, a6) ? (BOOL v16 = v6 == v18) : (BOOL v16 = 0), v16))
  {
    *a3 = v6;
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  sub_244D440EC(v15);
  return v7;
}

uint64_t sub_244D25474(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  memset(v11, 0, sizeof(v11));
  uint64_t v9 = sub_244D258CC((uint64_t)v11, a5);
  if (v9)
  {
    (*(void (**)(_OWORD *, uint64_t, uint64_t))(*(void *)&v11[0] + 24))(v11, a1, a2);
    sub_244D25960((void **)v11, a3, a4);
  }
  sub_244D25650((uint64_t)v11);
  return v9;
}

uint64_t sub_244D25508(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D25528()
{
  uint64_t v0 = sub_244D16670();
  uint64_t v1 = sub_244D16670();
  uint64_t v2 = sub_244D16670();
  __int16 v3 = sub_244D24C2C();
  uint64_t v4 = (uint64_t)v3;
  if (!v0
    || !v1
    || !v2
    || !v3
    || (sub_244D16A30((uint64_t)v0, (uint64_t)&unk_244EB70C8, 32), !sub_244D1B5D8((uint64_t)v1, v0))
    || !sub_244D15DEC((void **)v2, 1uLL)
    || (*((_DWORD *)v2 + 4) = 0,
        *(void *)void *v2 = 2,
        *((_DWORD *)v2 + 2) = 1,
        !sub_244D24D70(v4, (uint64_t)v0, (uint64_t)v1, (uint64_t)v2)))
  {
    sub_244D166B0((void **)v0);
    sub_244D166B0((void **)v1);
    sub_244D166B0((void **)v2);
    sub_244D24C6C(v4);
    return 0;
  }
  return v4;
}

uint64_t sub_244D25610(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

double sub_244D25618(_OWORD *a1)
{
  double result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double sub_244D25624()
{
  uint64_t v0 = sub_244D43FF4(0x20uLL);
  if (v0)
  {
    double result = 0.0;
    _OWORD *v0 = 0u;
    v0[1] = 0u;
  }
  return result;
}

uint64_t sub_244D25650(uint64_t a1)
{
  sub_244D440EC(*(void **)(a1 + 8));
  uint64_t v2 = *(void (***)(void))(a1 + 24);
  if (v2) {
    (*v2)(*(void *)(a1 + 16));
  }
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return 1;
}

uint64_t sub_244D25698(void **a1)
{
  sub_244D4413C(a1[1], *((unsigned int *)*a1 + 11));

  return sub_244D25650((uint64_t)a1);
}

void sub_244D256DC(void *a1)
{
  if (a1)
  {
    sub_244D25650((uint64_t)a1);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D2571C()
{
  return 0;
}

uint64_t sub_244D25750(void *a1, uint64_t *a2)
{
  if (!a2) {
    goto LABEL_11;
  }
  if (!a2[2])
  {
    uint64_t v6 = *a2;
    if (*a2)
    {
      uint64_t v5 = 0;
LABEL_8:
      if (*a1 == v6)
      {
        uint64_t v7 = (void *)a1[1];
        a1[1] = 0;
        goto LABEL_14;
      }
      int v8 = sub_244D43FF4(*(unsigned int *)(v6 + 44));
      if (v8)
      {
        uint64_t v7 = v8;
        goto LABEL_14;
      }
      if (v5) {
        (*(void (**)(uint64_t))a2[3])(v5);
      }
      return 0;
    }
LABEL_11:
    sub_244D0B884(29, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digest/digest.c", 138);
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void))(a2[3] + 8))();
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  if (*a2) {
    goto LABEL_8;
  }
  uint64_t v7 = 0;
LABEL_14:
  sub_244D25650((uint64_t)a1);
  *a1 = *a2;
  a1[1] = v7;
  if (*a2)
  {
    size_t v9 = *(unsigned int *)(*a2 + 44);
    if (v9) {
      memcpy(v7, (const void *)a2[1], v9);
    }
  }
  a1[2] = v5;
  a1[3] = a2[3];
  return 1;
}

double sub_244D25858(_OWORD *a1, _OWORD *a2)
{
  sub_244D25650((uint64_t)a1);
  long long v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  double result = 0.0;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

uint64_t sub_244D25890(void *a1, uint64_t *a2)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return sub_244D25750(a1, a2);
}

uint64_t sub_244D2589C(_OWORD *a1)
{
  *a1 = 0u;
  a1[1] = 0u;
  return 1;
}

uint64_t sub_244D258CC(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != a2)
  {
    uint64_t result = (uint64_t)sub_244D43FF4(*(unsigned int *)(a2 + 44));
    if (!result) {
      return result;
    }
    uint64_t v5 = result;
    sub_244D440EC(*(void **)(a1 + 8));
    *(void *)a1 = a2;
    *(void *)(a1 + 8) = v5;
  }
  (*(void (**)(uint64_t))(a2 + 16))(a1);
  return 1;
}

uint64_t sub_244D25930(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return sub_244D258CC(a1, a2);
}

uint64_t sub_244D2593C(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D25960(void **a1, uint64_t a2, _DWORD *a3)
{
  if (a3) {
    *a3 = *((_DWORD *)*a1 + 1);
  }
  sub_244D4413C(a1[1], *((unsigned int *)*a1 + 11));
  return 1;
}

uint64_t sub_244D259B0(void **a1, uint64_t a2, _DWORD *a3)
{
  return 1;
}

uint64_t sub_244D259E0(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_244D259EC(uint64_t a1)
{
  return *(unsigned int *)(*(void *)a1 + 40);
}

uint64_t *sub_244D259F8()
{
  return &qword_268EBF590;
}

double sub_244D25A30()
{
  qword_268EBF590 = 0x1000000101;
  dword_268EBF598 = 0;
  qword_268EBF5A0 = (uint64_t)sub_244D3D654;
  qword_268EBF5A8 = (uint64_t)sub_244D3D678;
  qword_268EBF5B0 = (uint64_t)sub_244D3D6A8;
  *(void *)&double result = 0x5C00000040;
  qword_268EBF5B8 = 0x5C00000040;
  return result;
}

uint64_t *sub_244D25A88()
{
  return &qword_268EBF5C0;
}

double sub_244D25AC0()
{
  qword_268EBF5C0 = 0x1000000004;
  dword_268EBF5C8 = 0;
  qword_268EBF5D0 = (uint64_t)sub_244D3D6B8;
  qword_268EBF5D8 = (uint64_t)sub_244D3D6DC;
  qword_268EBF5E0 = (uint64_t)sub_244D3D70C;
  *(void *)&double result = 0x5C00000040;
  qword_268EBF5E8 = 0x5C00000040;
  return result;
}

uint64_t *sub_244D25B18()
{
  return &qword_268EBF5F0;
}

double sub_244D25B50()
{
  qword_268EBF5F0 = 0x1400000040;
  dword_268EBF5F8 = 0;
  qword_268EBF600 = (uint64_t)sub_244D3D71C;
  qword_268EBF608 = (uint64_t)sub_244D3D748;
  qword_268EBF610 = (uint64_t)sub_244D3D778;
  *(void *)&double result = 0x6000000040;
  qword_268EBF618 = 0x6000000040;
  return result;
}

uint64_t *sub_244D25BA8()
{
  return &qword_268EBF620;
}

double sub_244D25BE0()
{
  qword_268EBF620 = 0x1C000002A3;
  dword_268EBF628 = 0;
  qword_268EBF630 = (uint64_t)sub_244D3D788;
  qword_268EBF638 = (uint64_t)sub_244D3D7BC;
  qword_268EBF640 = (uint64_t)sub_244D3D7EC;
  *(void *)&double result = 0x7000000040;
  qword_268EBF648 = 0x7000000040;
  return result;
}

uint64_t *sub_244D25C38()
{
  return &qword_268EBF650;
}

double sub_244D25C70()
{
  qword_268EBF650 = 0x20000002A0;
  dword_268EBF658 = 0;
  qword_268EBF660 = (uint64_t)sub_244D3D7FC;
  qword_268EBF668 = (uint64_t)sub_244D3D830;
  qword_268EBF670 = (uint64_t)sub_244D3D860;
  *(void *)&double result = 0x7000000040;
  qword_268EBF678 = 0x7000000040;
  return result;
}

uint64_t *sub_244D25CC8()
{
  return &qword_268EBF680;
}

double sub_244D25D00()
{
  qword_268EBF680 = 0x30000002A1;
  dword_268EBF688 = 0;
  qword_268EBF690 = (uint64_t)sub_244D3D874;
  qword_268EBF698 = (uint64_t)sub_244D3D8B4;
  qword_268EBF6A0 = (uint64_t)sub_244D3D8BC;
  *(void *)&double result = 0xD800000080;
  qword_268EBF6A8 = 0xD800000080;
  return result;
}

uint64_t *sub_244D25D58()
{
  return &qword_268EBF6B0;
}

double sub_244D25D90()
{
  qword_268EBF6B0 = 0x40000002A2;
  dword_268EBF6B8 = 0;
  qword_268EBF6C0 = (uint64_t)sub_244D3D8CC;
  qword_268EBF6C8 = (uint64_t)sub_244D3D90C;
  qword_268EBF6D0 = (uint64_t)sub_244D3D914;
  *(void *)&double result = 0xD800000080;
  qword_268EBF6D8 = 0xD800000080;
  return result;
}

uint64_t *sub_244D25DE8()
{
  return &qword_268EBF6E0;
}

double sub_244D25E20()
{
  qword_268EBF6E0 = 0x20000003C2;
  dword_268EBF6E8 = 0;
  qword_268EBF6F0 = (uint64_t)sub_244D3D928;
  qword_268EBF6F8 = (uint64_t)sub_244D3D968;
  qword_268EBF700 = (uint64_t)sub_244D3D970;
  *(void *)&double result = 0xD800000080;
  qword_268EBF708 = 0xD800000080;
  return result;
}

uint64_t *sub_244D25E78()
{
  return &qword_268EBF710;
}

double sub_244D25EB0()
{
  qword_268EBF710 = 0x2400000072;
  dword_268EBF718 = 0;
  qword_268EBF720 = (uint64_t)sub_244D3D980;
  qword_268EBF728 = (uint64_t)sub_244D3D9C8;
  qword_268EBF730 = (uint64_t)sub_244D3DA64;
  *(void *)&double result = 0xBC00000040;
  qword_268EBF738 = 0xBC00000040;
  return result;
}

uint64_t sub_244D25F08(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D25F10(a1, a2, a3, a4, a5, 0);
}

uint64_t sub_244D25F10(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t result = (uint64_t)sub_244D0D538(a5, a4);
    *(void *)(a1 + 16) = result;
    if (!result) {
      return result;
    }
  }
  sub_244D4BDB4(&stru_268EBD840, sub_244D3DAAC);
  *(void *)(a1 + 24) = &qword_268EBF740;
  uint64_t v11 = *(uint64_t **)(a1 + 16);
  if (a6 == 1)
  {
    uint64_t result = sub_244D0DA20(v11);
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t result = sub_244D0D938(v11);
    if (!result) {
      return result;
    }
  }
  if (!a3)
  {
    uint64_t v13 = 56;
    if (!a6) {
      uint64_t v13 = 40;
    }
    if (*(void *)(**(void **)(a1 + 16) + v13))
    {
      sub_244D0B884(6, 0, 119, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digestsign/digestsign.c", 109);
      return 0;
    }
    goto LABEL_18;
  }
  uint64_t result = sub_244D0C800(*(uint64_t **)(a1 + 16));
  if (result)
  {
    uint64_t v12 = 56;
    if (!a6) {
      uint64_t v12 = 40;
    }
    if (!*(void *)(**(void **)(a1 + 16) + v12) || (uint64_t result = sub_244D258CC(a1, a3), result))
    {
LABEL_18:
      if (a2) {
        *a2 = *(void *)(a1 + 16);
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D26044(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D25F10(a1, a2, a3, a4, a5, 1);
}

uint64_t sub_244D2604C(void **a1)
{
  if (*(void *)(*a1[2] + 40))
  {
    ((void (*)(void **))(*a1)[3])(a1);
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digestsign/digestsign.c", 135);
    return 0;
  }
}

uint64_t sub_244D260A4(void **a1)
{
  if (*(void *)(*a1[2] + 56))
  {
    ((void (*)(void **))(*a1)[3])(a1);
    return 1;
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digestsign/digestsign.c", 144);
    return 0;
  }
}

uint64_t sub_244D260FC(uint64_t *a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  __int16 v3 = (_DWORD *)a1[2];
  if (!*(void *)(*(void *)v3 + 40))
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digestsign/digestsign.c", 154);
    return 0;
  }
  if (a2)
  {
    memset(v6, 0, sizeof(v6));
    if (sub_244D25750(v6, a1))
    {
      (*(void (**)(_OWORD *, unsigned char *))(*(void *)&v6[0] + 32))(v6, v7);
      sub_244D4413C(*((void **)&v6[0] + 1), *(unsigned int *)(*(void *)&v6[0] + 44));
      BOOL v4 = sub_244D0D998((_DWORD *)a1[2]) != 0;
    }
    else
    {
      BOOL v4 = 0;
    }
    sub_244D25650((uint64_t)v6);
    return v4;
  }

  return sub_244D0D998(v3);
}

BOOL sub_244D26258(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (*(void *)(**(void **)(a1 + 16) + 56))
  {
    memset(v4, 0, sizeof(v4));
    if (sub_244D25750(v4, (uint64_t *)a1))
    {
      (*(void (**)(_OWORD *, unsigned char *))(*(void *)&v4[0] + 32))(v4, v5);
      sub_244D4413C(*((void **)&v4[0] + 1), *(unsigned int *)(*(void *)&v4[0] + 44));
      BOOL v2 = sub_244D0DA80(*(_DWORD **)(a1 + 16)) != 0;
    }
    else
    {
      BOOL v2 = 0;
    }
    sub_244D25650((uint64_t)v4);
  }
  else
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digestsign/digestsign.c", 186);
    return 0;
  }
  return v2;
}

uint64_t sub_244D26360(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  if (*(void *)(*(void *)v4 + 40))
  {
    if (!a2 || sub_244D2604C((void **)a1))
    {
      return sub_244D260FC(a1, a2);
    }
    return 0;
  }
  uint64_t v6 = *(uint64_t (**)(void))(*(void *)v4 + 48);
  if (!v6)
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digestsign/digestsign.c", 228);
    return 0;
  }

  return v6();
}

uint64_t sub_244D26434(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (*(void *)(*(void *)v2 + 56))
  {
    if (sub_244D260A4((void **)a1))
    {
      return sub_244D26258(a1);
    }
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)v2 + 64);
  if (!v4)
  {
    sub_244D0B884(6, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/digestsign/digestsign.c", 255);
    return 0;
  }

  return v4();
}

uint64_t sub_244D26504(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  *(void *)&__src[33] = *MEMORY[0x263EF8340];
  uint64_t v4 = a4[2];
  if (!v4)
  {
    int v9 = 27;
    int v10 = 101;
    __int16 v11 = 87;
    goto LABEL_10;
  }
  uint64_t v8 = (uint64_t *)*a4;
  if (sub_244D2670C(*a4, *a3))
  {
    int v9 = 15;
    int v10 = 106;
    __int16 v11 = 93;
LABEL_10:
    sub_244D0B884(v9, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ecdh/ecdh.c", v11);
    return 0;
  }
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  __uint64_t n = 0;
  if (!sub_244D267EC((uint64_t)v8, (uint64_t)v15, (uint64_t)(a3 + 1), v4 + 24)
    || !sub_244D26878(v8, (uint64_t)__src, &__n, 0x42uLL, (uint64_t)v15))
  {
    int v9 = 27;
    int v10 = 102;
    __int16 v11 = 103;
    goto LABEL_10;
  }
  *((void *)&v12 + 1) = a2;
  *(void *)&long long v12 = a2 - 28;
  switch((unint64_t)(v12 >> 2))
  {
    case 0uLL:
      sub_244D26950((char *)__src, __n, a1);
      break;
    case 1uLL:
      sub_244D26A24((char *)__src, __n, a1);
      break;
    case 5uLL:
      sub_244D26AF8((unint64_t *)__src, __n, a1);
      break;
    case 9uLL:
      sub_244D26BC8((unint64_t *)__src, __n, a1);
      break;
    default:
      int v9 = 27;
      int v10 = 103;
      __int16 v11 = 122;
      goto LABEL_10;
  }
  return 1;
}

uint64_t sub_244D2670C(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 512);
  if (v4 != *(_DWORD *)(a2 + 512)) {
    return 1;
  }
  if (v4) {
    return 0;
  }
  if (*(void *)a1 != *(void *)a2
    || !*(_DWORD *)(a1 + 532)
    || !*(_DWORD *)(a2 + 532)
    || sub_244D17194(a1 + 256, a2 + 256)
    || sub_244D17194(a1 + 320, a2 + 320)
    || sub_244D441D4((char *)(a1 + 360), (char *)(a2 + 360), 8 * *(int *)(a1 + 328))
    || sub_244D441D4((char *)(a1 + 432), (char *)(a2 + 432), 8 * *(int *)(a1 + 328)))
  {
    return 1;
  }
  else
  {
    return sub_244D28654(a1, a1 + 16, a2 + 16) ^ 1;
  }
}

uint64_t sub_244D267EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 && a4)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    if (sub_244D28EC0(a1, a2)) {
      return 1;
    }
    int v7 = 68;
    __int16 v8 = 846;
  }
  else
  {
    int v7 = 67;
    __int16 v8 = 837;
  }
  sub_244D0B884(15, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v8);
  return 0;
}

uint64_t sub_244D26878(uint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5)
{
  unint64_t v10 = (sub_244D168EC(a1 + 40) + 7) >> 3;
  if (v10 <= a4)
  {
    uint64_t v13 = 0;
    memset(v12, 0, sizeof(v12));
    uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, _OWORD *, void))*a1)(a1, a5, v12, 0);
    if (result)
    {
      (*(void (**)(uint64_t *, uint64_t, unint64_t *, _OWORD *))(*a1 + 104))(a1, a2, a3, v12);
      *a3 = v10;
      return 1;
    }
  }
  else
  {
    sub_244D0B884(15, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 996);
    return 0;
  }
  return result;
}

_DWORD *sub_244D26950(char *__src, size_t __n, _DWORD *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  memset(v6, 0, sizeof(v6));
  v5[0] = xmmword_244EB6E10;
  v5[1] = xmmword_244EB6E20;
  int v7 = 28;
  sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D384F4, (uint64_t)v5, &v6[8], &v6[72], &v6[4], v6, __src, __n);
  sub_244D39114(a3, 0x1CuLL, (uint64_t)v5);
  sub_244D4413C(v5, 0x70uLL);
  return a3;
}

_DWORD *sub_244D26A24(char *__src, size_t __n, _DWORD *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  memset(v6, 0, sizeof(v6));
  v5[0] = xmmword_244EB6E30;
  v5[1] = xmmword_244EB6E40;
  unsigned int v7 = 32;
  sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D384F4, (uint64_t)v5, &v6[8], &v6[72], &v6[4], v6, __src, __n);
  sub_244D39114(a3, v7, (uint64_t)v5);
  sub_244D4413C(v5, 0x70uLL);
  return a3;
}

void *sub_244D26AF8(unint64_t *__src, size_t __n, void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  v5[0] = (int8x16_t)xmmword_244EB6E50;
  v5[1] = (int8x16_t)xmmword_244EB6E60;
  _OWORD v5[2] = (int8x16_t)xmmword_244EB6E70;
  _OWORD v5[3] = (int8x16_t)xmmword_244EB6E80;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v16 = 0x3000000000;
  sub_244D277D8((unint64_t)v5, __src, __n);
  sub_244D39398(a3, 0x30uLL, v5);
  sub_244D4413C(v5, 0xD8uLL);
  return a3;
}

void *sub_244D26BC8(unint64_t *__src, size_t __n, void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  v5[0] = (int8x16_t)xmmword_244EB6E90;
  v5[1] = (int8x16_t)xmmword_244EB6EA0;
  _OWORD v5[2] = (int8x16_t)xmmword_244EB6EB0;
  _OWORD v5[3] = (int8x16_t)xmmword_244EB6EC0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v16 = 0x4000000000;
  sub_244D277D8((unint64_t)v5, __src, __n);
  sub_244D39398(a3, HIDWORD(v16), v5);
  sub_244D4413C(v5, 0xD8uLL);
  return a3;
}

void *sub_244D26C98()
{
  uint64_t v0 = sub_244D43FF4(0x10uLL);
  if (v0)
  {
    void *v0 = sub_244D16670();
    uint64_t v1 = sub_244D16670();
    v0[1] = v1;
    if (*v0) {
      BOOL v2 = v1 == 0;
    }
    else {
      BOOL v2 = 1;
    }
    if (v2)
    {
      sub_244D07DFC(v0);
      return 0;
    }
  }
  return v0;
}

uint64_t sub_244D26CF4(unsigned __int8 *a1, unint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (!a3 || ((int v4 = *(int **)a4, v5 = *(void *)(a4 + 8), *(void *)a4) ? (v6 = v5 == 0) : (v6 = 1), v6))
  {
    int v22 = 101;
    __int16 v23 = 156;
  }
  else
  {
    uint64_t v38 = 0;
    memset(__dst, 0, sizeof(__dst));
    uint64_t v36 = 0;
    memset(v35, 0, sizeof(v35));
    uint64_t v34 = 0;
    memset(v33, 0, sizeof(v33));
    uint64_t v32 = 0;
    memset(v31, 0, sizeof(v31));
    uint64_t v30 = 0;
    memset(v29, 0, sizeof(v29));
    uint64_t v28 = 0;
    memset(v27, 0, sizeof(v27));
    uint64_t v8 = *a3;
    uint64_t v9 = *(int *)(v8 + 8);
    if (!v9) {
      goto LABEL_20;
    }
    uint64_t v12 = 0;
    long long v13 = *(uint64_t **)v8;
    do
    {
      uint64_t v14 = *v13++;
      v12 |= v14;
      --v9;
    }
    while (v9);
    if (!v12) {
      goto LABEL_20;
    }
    if (!sub_244D26F88((uint64_t)v4, __dst, v8)) {
      goto LABEL_20;
    }
    uint64_t v15 = a3[1];
    uint64_t v16 = *(int *)(v15 + 8);
    if (!v16) {
      goto LABEL_20;
    }
    uint64_t v17 = 0;
    int v18 = *(uint64_t **)v15;
    do
    {
      uint64_t v19 = *v18++;
      v17 |= v19;
      --v16;
    }
    while (v16);
    if (v17 && sub_244D26F88((uint64_t)v4, v35, v15))
    {
      if ((*(unsigned int (**)(int *, _OWORD *, _OWORD *))(*(void *)v4 + 144))(v4, v29, v35))
      {
        sub_244D2700C((uint64_t)v4, (unint64_t *)v27, a1, a2);
        sub_244D1A72C((unint64_t *)v33, (unint64_t *)v27, (unint64_t *)v29, v4[66], (uint64_t)(v4 + 58));
        sub_244D1A72C((unint64_t *)v31, (unint64_t *)__dst, (unint64_t *)v29, v4[66], (uint64_t)(v4 + 58));
        uint64_t v26 = 0;
        memset(v25, 0, sizeof(v25));
        uint64_t v20 = v5 + 8;
        uint64_t v21 = *(void (**)(int *, _OWORD *, _OWORD *, uint64_t, _OWORD *))(*(void *)v4 + 56);
        if (v21)
        {
          v21(v4, v25, v33, v20, v31);
        }
        else if (!(*(unsigned int (**)(int *, _OWORD *, _OWORD *, uint64_t, _OWORD *, uint64_t))(*(void *)v4 + 64))(v4, v25, v33, v20, v31, 1))
        {
          int v22 = 15;
          __int16 v23 = 186;
          goto LABEL_21;
        }
        if ((*(unsigned int (**)(int *, _OWORD *, _OWORD *))(*(void *)v4 + 152))(v4, v25, __dst)) {
          return 1;
        }
        int v22 = 100;
        __int16 v23 = 191;
      }
      else
      {
        int v22 = 68;
        __int16 v23 = 171;
      }
    }
    else
    {
LABEL_20:
      int v22 = 100;
      __int16 v23 = 165;
    }
  }
LABEL_21:
  sub_244D0B884(26, 0, v22, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ecdsa/ecdsa.c", v23);
  return 0;
}

uint64_t sub_244D26F88(uint64_t a1, void *__dst, uint64_t a3)
{
  if (sub_244D16A84(__dst, *(int *)(a1 + 264), a3)
    && (int)sub_244D170B4((uint64_t *)__dst, *(int *)(a1 + 264), *(uint64_t **)(a1 + 256), *(int *)(a1 + 264)) < 0)
  {
    return 1;
  }
  sub_244D0B884(15, 0, 133, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/scalar.c", 32);
  return 0;
}

uint64_t sub_244D27000(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
}

uint64_t sub_244D2700C(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unint64_t a4)
{
  v12[9] = *MEMORY[0x263EF8340];
  unsigned int v8 = sub_244D168EC((uint64_t *)(a1 + 256));
  char v9 = v8;
  unint64_t v10 = v8;
  if (((unint64_t)v8 + 7) >> 3 < a4) {
    a4 = ((unint64_t)v8 + 7) >> 3;
  }
  sub_244D16C88(a2, *(int *)(a1 + 264), a3, a4);
  if (v10 < 8 * a4) {
    sub_244D20E1C(a2, (uint64_t)a2, 8 - (v9 & 7), *(int *)(a1 + 264));
  }
  return sub_244D180A8(a2, 0, *(unint64_t **)(a1 + 256), v12, *(int *)(a1 + 264));
}

void sub_244D270EC(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
}

uint64_t sub_244D27108(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a4 && a3 && a5)
  {
    uint64_t v5 = *(void (**)(void))(*(void *)a1 + 56);
    if (v5)
    {
      v5();
      return 1;
    }
    else
    {
      uint64_t v7 = *(uint64_t (**)(void))(*(void *)a1 + 64);
      return v7();
    }
  }
  else
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 809);
    return 0;
  }
}

uint64_t sub_244D27180(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 152))(a1);
}

uint64_t *sub_244D27190(unsigned __int8 *a1, unint64_t a2, uint64_t *a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v7 = a3[5];
  if (v7 && *(void *)(v7 + 40))
  {
    int v8 = 103;
    __int16 v9 = 276;
LABEL_9:
    sub_244D0B884(26, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ecdsa/ecdsa.c", v9);
    return 0;
  }
  uint64_t v10 = *a3;
  if (!*a3 || (uint64_t v11 = a3[2]) == 0)
  {
    int v8 = 67;
    __int16 v9 = 282;
    goto LABEL_9;
  }
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  if (sub_244D27268(v10, (unint64_t *)v14, a4, a5)) {
    return sub_244D27310(v10, &v13, (unint64_t *)(v11 + 24), (uint64_t)v14, a1, a2);
  }
  return 0;
}

uint64_t sub_244D27268(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unint64_t a4)
{
  if ((sub_244D168EC((uint64_t *)(a1 + 256)) + 7) >> 3 != a4)
  {
    __int16 v8 = 68;
    goto LABEL_5;
  }
  sub_244D16C88(a2, *(int *)(a1 + 264), a3, a4);
  if ((sub_244D170B4((uint64_t *)a2, *(int *)(a1 + 264), *(uint64_t **)(a1 + 256), *(int *)(a1 + 264)) & 0x80000000) == 0)
  {
    __int16 v8 = 75;
LABEL_5:
    sub_244D0B884(15, 0, 133, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/scalar.c", v8);
    return 0;
  }
  return 1;
}

uint64_t *sub_244D27310(uint64_t a1, _DWORD *a2, unint64_t *a3, uint64_t a4, unsigned __int8 *a5, unint64_t a6)
{
  *a2 = 0;
  if (sub_244D168EC((uint64_t *)(a1 + 256)) <= 0x9F)
  {
    sub_244D0B884(26, 0, 112, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ecdsa/ecdsa.c", 214);
    return 0;
  }
  uint64_t v33 = 0;
  memset(v32, 0, sizeof(v32));
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  if (!sub_244D29D74(a1, (uint64_t)v32, a4)
    || !sub_244D2A174(a1, (unint64_t *)v30, (uint64_t)v32))
  {
    return 0;
  }
  int v12 = *(_DWORD *)(a1 + 264);
  if (v12 < 1)
  {
    BOOL v17 = 1;
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = (uint64_t *)v30;
    uint64_t v15 = *(unsigned int *)(a1 + 264);
    do
    {
      uint64_t v16 = *v14++;
      v13 |= v16;
      --v15;
    }
    while (v15);
    BOOL v17 = v13 == 0;
  }
  if (v17) {
    goto LABEL_17;
  }
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  sub_244D1A72C((unint64_t *)v28, (unint64_t *)v30, *(unint64_t **)(a1 + 232), v12, a1 + 232);
  sub_244D1A72C((unint64_t *)v28, a3, (unint64_t *)v28, *(int *)(a1 + 264), a1 + 232);
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  sub_244D2700C(a1, (unint64_t *)v26, a5, a6);
  sub_244D2D07C(a1, (unint64_t *)v28, (uint64_t *)v28, (uint64_t *)v26);
  (*(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 136))(a1, v26, a4);
  sub_244D1A64C((unint64_t *)v26, *(int *)(a1 + 264), (uint64_t)v26, *(int *)(a1 + 264), a1 + 232);
  sub_244D1A72C((unint64_t *)v28, (unint64_t *)v28, (unint64_t *)v26, *(int *)(a1 + 264), a1 + 232);
  uint64_t v18 = *(unsigned int *)(a1 + 264);
  if ((int)v18 < 1)
  {
    BOOL v22 = 1;
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v20 = (uint64_t *)v28;
    do
    {
      uint64_t v21 = *v20++;
      v19 |= v21;
      --v18;
    }
    while (v18);
    BOOL v22 = v19 == 0;
  }
  if (v22)
  {
LABEL_17:
    __int16 v23 = 0;
    *a2 = 1;
  }
  else
  {
    char v24 = sub_244D26C98();
    __int16 v23 = v24;
    if (!v24
      || !sub_244D169D4(*v24, v30, *(int *)(a1 + 264))
      || !sub_244D169D4(v23[1], v28, *(int *)(a1 + 264)))
    {
      sub_244D07DFC(v23);
      return 0;
    }
  }
  return v23;
}

uint64_t *sub_244D27580(unint64_t *a1, size_t a2, uint64_t *a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v5 = a3[5];
  if (v5 && *(void *)(v5 + 40))
  {
    int v6 = 103;
    __int16 v7 = 312;
LABEL_14:
    sub_244D0B884(26, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ecdsa/ecdsa.c", v7);
    return 0;
  }
  uint64_t v8 = *a3;
  if (!*a3 || (uint64_t v9 = a3[2]) == 0)
  {
    int v6 = 67;
    __int16 v7 = 318;
    goto LABEL_14;
  }
  uint64_t v10 = (unint64_t *)(v9 + 24);
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  v22[0] = (int8x16_t)xmmword_244EB6E90;
  v22[1] = (int8x16_t)xmmword_244EB6EA0;
  _OWORD v22[2] = (int8x16_t)xmmword_244EB6EB0;
  v22[3] = (int8x16_t)xmmword_244EB6EC0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  size_t v11 = 8 * *(int *)(v8 + 264);
  uint64_t v33 = 0x4000000000;
  sub_244D277D8((unint64_t)v22, (unint64_t *)(v9 + 24), v11);
  sub_244D277D8((unint64_t)v22, a1, a2);
  sub_244D39398(v21, HIDWORD(v33), v22);
  uint64_t v20 = 0;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  if (!sub_244D20A18((char *)&v16, 1uLL, *(unint64_t **)(v8 + 256), *(int *)(v8 + 264), (uint64_t)v21))return 0; {
  int v12 = 33;
  }
  while (1)
  {
    int v15 = 0;
    uint64_t v13 = sub_244D27310(v8, &v15, v10, (uint64_t)&v16, (unsigned __int8 *)a1, a2);
    if (v13 || !v15) {
      break;
    }
    if (!--v12)
    {
      sub_244D0B884(26, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ecdsa/ecdsa.c", 364);
      return v13;
    }
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    if (!sub_244D20A18((char *)&v16, 1uLL, *(unint64_t **)(v8 + 256), *(int *)(v8 + 264), (uint64_t)v21))return 0; {
  }
    }
  return v13;
}

uint64_t sub_244D27790(uint64_t a1)
{
  return a1 + 256;
}

uint64_t sub_244D27798(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_244EB6E90;
  *(_OWORD *)(a1 + 16) = xmmword_244EB6EA0;
  *(_OWORD *)(a1 + 32) = xmmword_244EB6EB0;
  *(_OWORD *)(a1 + 48) = xmmword_244EB6EC0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 208) = 0x4000000000;
  return 1;
}

uint64_t sub_244D277D8(unint64_t a1, unint64_t *__src, size_t __n)
{
  if (__n)
  {
    size_t v3 = __n;
    int v4 = __src;
    int v6 = (unint64_t *)(a1 + 80);
    *(_OWORD *)(a1 + 64) += __PAIR128__(__n >> 61, 8 * __n);
    uint64_t v7 = *(unsigned int *)(a1 + 208);
    if (v7)
    {
      uint64_t v8 = 128 - v7;
      size_t v9 = __n - (128 - v7);
      if (__n < 128 - v7)
      {
        memcpy((char *)v6 + v7, __src, __n);
        LODWORD(v3) = *(_DWORD *)(a1 + 208) + v3;
LABEL_12:
        *(_DWORD *)(a1 + 208) = v3;
        return 1;
      }
      if (v7 != 128) {
        memcpy((char *)v6 + v7, __src, 128 - v7);
      }
      *(_DWORD *)(a1 + 208) = 0;
      int v4 = (unint64_t *)((char *)v4 + v8);
      sub_244D39484(a1, v6, 1);
      size_t v3 = v9;
    }
    if (v3 >= 0x80)
    {
      sub_244D39484(a1, v4, v3 >> 7);
      uint64_t v10 = (char *)v4 + v3;
      v3 &= 0x7Fu;
      int v4 = (unint64_t *)&v10[-v3];
    }
    if (v3)
    {
      memcpy(v6, v4, v3);
      goto LABEL_12;
    }
  }
  return 1;
}

uint64_t sub_244D278D8(void *a1, int8x16_t *a2)
{
  return sub_244D39398(a1, a2[13].u32[1], a2);
}

uint64_t sub_244D278E4(uint64_t a1, char *a2, uint64_t a3)
{
  return sub_244D20A18(a2, 1uLL, *(unint64_t **)(a1 + 256), *(int *)(a1 + 264), a3);
}

uint64_t *sub_244D278FC()
{
  return &qword_268EBF750;
}

double sub_244D27934()
{
  qword_268EBF948 = (uint64_t)"NIST P-224";
  unk_268EBF950 = 0x4812B000002C9;
  byte_268EBF958 = 33;
  byte_268EBF95D = 5;
  sub_244D16A30((uint64_t)&unk_268EBF890, (uint64_t)&unk_244EB7CE8, 4);
  sub_244D16A30((uint64_t)&unk_268EBF878, (uint64_t)&unk_244EB7D08, 4);
  qword_268EBF8A8 = -1;
  sub_244D16A30((uint64_t)&unk_268EBF850, (uint64_t)&unk_244EB7D28, 4);
  sub_244D16A30((uint64_t)&unk_268EBF838, (uint64_t)&unk_244EB7D48, 4);
  qword_268EBF868 = 0xD6E242706A1FC2EBLL;
  sub_244D4BDB4(&stru_268EBD980, sub_244D2CDAC);
  xmmword_268EBF760 = xmmword_244EB7D68;
  unk_268EBF770 = unk_244EB7D78;
  unk_268EBF7A8 = xmmword_244EB7D88;
  unk_268EBF7B8 = unk_244EB7D98;
  qword_268EBF7F0 = 1;
  xmmword_268EBF900 = xmmword_244EB7DA8;
  unk_268EBF910 = unk_244EB7DB8;
  qword_268EBF750 = (uint64_t)&qword_268EC0070;
  *(void *)algn_268EBF758 = &qword_268EBF750;
  sub_244D3DAD8((uint64_t)&qword_268EBF750);
  *(void *)&double result = 0x100000001;
  qword_268EBF964 = 0x100000001;
  return result;
}

uint64_t *sub_244D27A64()
{
  return &qword_268EBF970;
}

double sub_244D27A9C()
{
  dword_268EBFB70 = 415;
  qword_268EBFB68 = (uint64_t)"NIST P-256";
  qword_268EBFB74 = 0x701033DCE48862ALL;
  byte_268EBFB7D = 8;
  sub_244D16A30((uint64_t)&unk_268EBFAB0, (uint64_t)&unk_244EB7DC8, 4);
  sub_244D16A30((uint64_t)&unk_268EBFA98, (uint64_t)&unk_244EB7DE8, 4);
  qword_268EBFAC8 = 1;
  sub_244D16A30((uint64_t)&unk_268EBFA70, (uint64_t)&unk_244EB7E08, 4);
  sub_244D16A30((uint64_t)&unk_268EBFA58, (uint64_t)&unk_244EB7E28, 4);
  qword_268EBFA88 = 0xCCD1C8AAEE00BC4FLL;
  sub_244D4BDB4(&stru_268EBD990, sub_244D2CEC0);
  qword_268EBF970 = (uint64_t)&qword_268EC0110;
  *(void *)algn_268EBF978 = &qword_268EBF970;
  xmmword_268EBF980 = xmmword_244EB7E48;
  unk_268EBF990 = unk_244EB7E58;
  unk_268EBF9C8 = xmmword_244EB7E68;
  unk_268EBF9D8 = unk_244EB7E78;
  xmmword_268EBFA10 = xmmword_244EB7E88;
  unk_268EBFA20 = unk_244EB7E98;
  xmmword_268EBFB20 = xmmword_244EB7EA8;
  unk_268EBFB30 = unk_244EB7EB8;
  sub_244D3DAD8((uint64_t)&qword_268EBF970);
  *(void *)&double result = 0x100000001;
  qword_268EBFB84 = 0x100000001;
  return result;
}

uint64_t *sub_244D27BE0()
{
  return &qword_268EBFB90;
}

double sub_244D27C18()
{
  qword_268EBFD88 = (uint64_t)"NIST P-384";
  unk_268EBFD90 = 0x4812B000002CBLL;
  byte_268EBFD98 = 34;
  byte_268EBFD9D = 5;
  sub_244D16A30((uint64_t)&unk_268EBFCD0, (uint64_t)&unk_244EB7ED0, 6);
  sub_244D16A30((uint64_t)&unk_268EBFCB8, (uint64_t)&unk_244EB7F00, 6);
  qword_268EBFCE8 = 0x100000001;
  sub_244D16A30((uint64_t)&unk_268EBFC90, (uint64_t)&unk_244EB7F30, 6);
  sub_244D16A30((uint64_t)&unk_268EBFC78, (uint64_t)&unk_244EB7F60, 6);
  qword_268EBFCA8 = 0x6ED46089E88FDC45;
  sub_244D4BDB4(&stru_268EBD970, sub_244D2C3D0);
  qword_268EBFB90 = (uint64_t)&qword_268EBFFD0;
  *(void *)algn_268EBFB98 = &qword_268EBFB90;
  xmmword_268EBFBA0 = xmmword_244EB7F90;
  unk_268EBFBB0 = unk_244EB7FA0;
  xmmword_268EBFBC0 = xmmword_244EB7FB0;
  unk_268EBFBE8 = xmmword_244EB7FC0;
  unk_268EBFBF8 = unk_244EB7FD0;
  unk_268EBFC08 = xmmword_244EB7FE0;
  xmmword_268EBFC30 = xmmword_244EB7FF0;
  unk_268EBFC40 = unk_244EB8000;
  xmmword_268EBFC50 = xmmword_244EB8010;
  xmmword_268EBFD40 = xmmword_244EB8020;
  unk_268EBFD50 = unk_244EB8030;
  xmmword_268EBFD60 = xmmword_244EB8040;
  sub_244D3DAD8((uint64_t)&qword_268EBFB90);
  *(void *)&double result = 0x100000001;
  qword_268EBFDA4 = 0x100000001;
  return result;
}

uint64_t *sub_244D27D70()
{
  return &qword_268EBFDB0;
}

double sub_244D27DA8()
{
  qword_268EBFFA8 = (uint64_t)"NIST P-521";
  unk_268EBFFB0 = 0x4812B000002CCLL;
  byte_268EBFFB8 = 35;
  byte_268EBFFBD = 5;
  sub_244D16A30((uint64_t)&unk_268EBFEF0, (uint64_t)&unk_244EB8058, 9);
  sub_244D16A30((uint64_t)&unk_268EBFED8, (uint64_t)&unk_244EB80A0, 9);
  qword_268EBFF08 = 1;
  sub_244D16A30((uint64_t)&unk_268EBFEB0, (uint64_t)&unk_244EB80E8, 9);
  sub_244D16A30((uint64_t)&unk_268EBFE98, (uint64_t)&unk_244EB8130, 9);
  qword_268EBFEC8 = 0x1D2F5CCD79A995C7;
  sub_244D4BDB4(&stru_268EBD970, sub_244D2C3D0);
  qword_268EBFDB0 = (uint64_t)&qword_268EBFFD0;
  *(void *)algn_268EBFDB8 = &qword_268EBFDB0;
  qword_268EBFE00 = 116;
  xmmword_268EBFDC0 = xmmword_244EB8178;
  unk_268EBFDD0 = unk_244EB8188;
  xmmword_268EBFDE0 = xmmword_244EB8198;
  unk_268EBFDF0 = unk_244EB81A8;
  qword_268EBFE48 = 480;
  unk_268EBFE08 = xmmword_244EB81C0;
  unk_268EBFE18 = unk_244EB81D0;
  unk_268EBFE28 = xmmword_244EB81E0;
  unk_268EBFE38 = unk_244EB81F0;
  qword_268EBFE90 = 0;
  xmmword_268EBFE50 = xmmword_244EB8250;
  unk_268EBFE60 = unk_244EB8260;
  xmmword_268EBFE70 = xmmword_244EB8270;
  unk_268EBFE80 = unk_244EB8280;
  qword_268EBFFA0 = 77;
  xmmword_268EBFF60 = xmmword_244EB8208;
  unk_268EBFF70 = unk_244EB8218;
  xmmword_268EBFF80 = xmmword_244EB8228;
  unk_268EBFF90 = unk_244EB8238;
  sub_244D3DAD8((uint64_t)&qword_268EBFDB0);
  *(void *)&double result = 0x100000001;
  qword_268EBFFC4 = 0x100000001;
  return result;
}

void *sub_244D27F20(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_244D168EC(a1) - 529 <= 0xFFFFFDE7)
  {
    sub_244D0B884(15, 0, 110, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 229);
    return 0;
  }
  if (a4)
  {
    size_t v9 = 0;
  }
  else
  {
    uint64_t v10 = sub_244D43FF4(0x30uLL);
    if (!v10) {
      return 0;
    }
    a4 = (uint64_t)v10;
    *(_OWORD *)((char *)v10 + 26) = 0u;
    *uint64_t v10 = 0u;
    v10[1] = 0u;
    size_t v9 = (unint64_t **)v10;
  }
  sub_244D1756C((void *)a4);
  size_t v11 = sub_244D17610(a4);
  int v12 = sub_244D17610(a4);
  uint64_t v8 = 0;
  if (v11)
  {
    uint64_t v13 = (uint64_t)v12;
    if (v12)
    {
      if (sub_244D17F9C((uint64_t)v11, a2, (uint64_t)a1, a4)
        && sub_244D17F9C(v13, a3, (uint64_t)a1, a4))
      {
        uint64_t v14 = sub_244D44058(0x220uLL);
        uint64_t v8 = v14;
        if (!v14) {
          return v8;
        }
        *((_DWORD *)v14 + 135) = 1;
        sub_244D4BDB4(&stru_268EBD970, sub_244D2C3D0);
        *uint64_t v8 = &qword_268EBFFD0;
        sub_244D1DF34((uint64_t)(v8 + 37));
        sub_244D1DF34((uint64_t)(v8 + 29));
        v8[1] = v8;
        if (sub_244D280FC((uint64_t)v8, (uint64_t)a1, (uint64_t)v11, v13, a4)) {
          goto LABEL_16;
        }
        sub_244D2826C((uint64_t)v8);
      }
      uint64_t v8 = 0;
    }
  }
LABEL_16:
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v15 = *(void *)(a4 + 8);
    uint64_t v16 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v16;
    *(void *)(a4 + 32) = *(void *)(v15 + 8 * v16);
  }
  sub_244D17500(v9);
  return v8;
}

uint64_t *sub_244D280C4()
{
  return &qword_268EBFFD0;
}

uint64_t sub_244D280FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if sub_244D168EC((uint64_t *)a2) >= 3 && *(int *)(a2 + 8) >= 1 && (**(unsigned char **)a2)
  {
    sub_244D1756C((void *)a5);
    uint64_t result = (uint64_t)sub_244D17610(a5);
    if (result)
    {
      size_t v11 = (void **)result;
      uint64_t result = sub_244D1E024((_DWORD *)(a1 + 296), a2, a5);
      if (result)
      {
        uint64_t result = sub_244D297C4((uint64_t *)a1, a1 + 360, a3);
        if (result)
        {
          uint64_t result = sub_244D297C4((uint64_t *)a1, a1 + 432, a4);
          if (result)
          {
            sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
            uint64_t result = sub_244D297C4((uint64_t *)a1, a1 + 160, (uint64_t)&qword_268EBEE70);
            if (result)
            {
              uint64_t result = (uint64_t)sub_244D16764(v11, a3);
              if (result)
              {
                uint64_t result = sub_244D15FB8((uint64_t)v11, 3uLL);
                if (result)
                {
                  *(_DWORD *)(a1 + 528) = sub_244D17194((uint64_t)v11, a1 + 320) == 0;
                  uint64_t result = 1;
                }
              }
            }
          }
        }
      }
    }
    if (!*(unsigned char *)(a5 + 40))
    {
      uint64_t v12 = *(void *)(a5 + 8);
      uint64_t v13 = *(void *)(a5 + 16) - 1;
      *(void *)(a5 + 16) = v13;
      *(void *)(a5 + 32) = *(void *)(v12 + 8 * v13);
    }
  }
  else
  {
    sub_244D0B884(15, 0, 110, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/simple.c", 96);
    return 0;
  }
  return result;
}

void sub_244D2826C(uint64_t a1)
{
  if (a1 && !*(_DWORD *)(a1 + 512) && sub_244D49A14((unsigned int *)(a1 + 540)))
  {
    sub_244D166B0((void **)(a1 + 232));
    sub_244D166B0((void **)(a1 + 256));
    sub_244D166B0((void **)(a1 + 296));
    sub_244D166B0((void **)(a1 + 320));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D282E4(uint64_t a1, void *a2, uint64_t *a3, unsigned int *a4)
{
  if (!*(_DWORD *)(a1 + 512) && !*(_DWORD *)(a1 + 532) && *a2 == a1)
  {
    if (sub_244D168EC(a3) - 529 <= 0xFFFFFDE7)
    {
      int v6 = 112;
      __int16 v7 = 287;
      goto LABEL_5;
    }
    if (!sub_244D172C8(a4))
    {
      int v6 = 131;
      __int16 v7 = 293;
      goto LABEL_5;
    }
    uint64_t v12 = sub_244D16670();
    uint64_t v13 = (void **)v12;
    if (v12 && sub_244D18E1C((uint64_t)v12, a3))
    {
      if ((int)sub_244D17194((uint64_t)v13, a1 + 320) <= 0)
      {
        sub_244D0B884(15, 0, 112, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 309);
      }
      else
      {
        long long v22 = 0u;
        memset(v23, 0, sizeof(v23));
        long long v20 = 0u;
        long long v21 = 0u;
        long long v19 = 0u;
        if ((**(unsigned int (***)(uint64_t, uint64_t, long long *, char *))a1)(a1, (uint64_t)(a2 + 1), &v19, (char *)v23 + 8)&& sub_244D1E024((_DWORD *)(a1 + 232), (uint64_t)a3, 0))
        {
          int v14 = sub_244D17194(a1 + 320, (uint64_t)a3);
          long long v15 = v22;
          *(_OWORD *)(a1 + 48) = v21;
          *(_OWORD *)(a1 + 64) = v15;
          long long v16 = v20;
          *(_OWORD *)(a1 + 16) = v19;
          *(_OWORD *)(a1 + 32) = v16;
          long long v17 = *(_OWORD *)((char *)v23 + 8);
          *(_OWORD *)(a1 + 104) = *(_OWORD *)((char *)&v23[1] + 8);
          long long v18 = *(_OWORD *)((char *)&v23[3] + 8);
          *(_OWORD *)(a1 + 120) = *(_OWORD *)((char *)&v23[2] + 8);
          *(_OWORD *)(a1 + 136) = v18;
          *(_DWORD *)(a1 + 536) = v14 > 0;
          *(void *)(a1 + 80) = *(void *)&v23[0];
          *(void *)(a1 + 152) = *((void *)&v23[4] + 1);
          *(_OWORD *)(a1 + 88) = v17;
          uint64_t v8 = 1;
          *(_DWORD *)(a1 + 532) = 1;
LABEL_19:
          sub_244D166B0(v13);
          return v8;
        }
      }
    }
    uint64_t v8 = 0;
    goto LABEL_19;
  }
  int v6 = 66;
  __int16 v7 = 282;
LABEL_5:
  sub_244D0B884(15, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v7);
  return 0;
}

uint64_t sub_244D284D0(uint64_t (***a1)(void, uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return (**a1)(a1, a3, a2, a2 + 72);
}

uint64_t *sub_244D284EC(int a1)
{
  if (a1 > 714)
  {
    if (a1 != 715)
    {
      if (a1 == 716)
      {
        sub_244D4BDB4(&stru_268EBD880, (void (*)(void))sub_244D27DA8);
        return &qword_268EBFDB0;
      }
      goto LABEL_8;
    }
    sub_244D4BDB4(&stru_268EBD870, (void (*)(void))sub_244D27C18);
    return &qword_268EBFB90;
  }
  else
  {
    if (a1 != 415)
    {
      if (a1 == 713)
      {
        sub_244D4BDB4(&stru_268EBD850, (void (*)(void))sub_244D27934);
        return &qword_268EBF750;
      }
LABEL_8:
      sub_244D0B884(15, 0, 123, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 342);
      return 0;
    }
    sub_244D4BDB4(&stru_268EBD860, (void (*)(void))sub_244D27A9C);
    return &qword_268EBF970;
  }
}

uint64_t sub_244D285E8(uint64_t a1)
{
  if (a1 && !*(_DWORD *)(a1 + 512)) {
    sub_244D499E4((unsigned int *)(a1 + 540));
  }
  return a1;
}

BOOL sub_244D28620(uint64_t a1, char *a2, char *a3)
{
  return sub_244D441D4(a2, a3, 8 * *(int *)(a1 + 328)) == 0;
}

uint64_t sub_244D28654(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(void (**)(uint64_t, _OWORD *, uint64_t, uint64_t *))(*(void *)a1 + 88);
  __int16 v7 = *(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 96);
  uint64_t v36 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v30 = 0;
  uint64_t v8 = (uint64_t *)(a3 + 144);
  memset(v29, 0, sizeof(v29));
  v7(a1, v29, a3 + 144);
  v6(a1, v35, a2, (uint64_t *)v29);
  size_t v9 = (uint64_t *)(a2 + 144);
  v7(a1, v31, a2 + 144);
  v6(a1, v33, a3, (uint64_t *)v31);
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  sub_244D1811C((unint64_t *)v35, (unint64_t *)v35, (unint64_t *)v33, *(uint64_t **)(a1 + 320), (uint64_t *)&v37, *(int *)(a1 + 328));
  uint64_t v10 = *(unsigned int *)(a1 + 328);
  if ((int)v10 < 1)
  {
    char v14 = -1;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = (uint64_t *)v35;
    do
    {
      uint64_t v13 = *v12++;
      v11 |= v13;
      --v10;
    }
    while (v10);
    char v14 = ~(v11 != 0);
  }
  v6(a1, v29, (uint64_t)v29, v8);
  v6(a1, v35, a2 + 72, (uint64_t *)v29);
  v6(a1, v31, (uint64_t)v31, (uint64_t *)(a2 + 144));
  v6(a1, v33, a3 + 72, (uint64_t *)v31);
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  sub_244D1811C((unint64_t *)v35, (unint64_t *)v35, (unint64_t *)v33, *(uint64_t **)(a1 + 320), (uint64_t *)&v37, *(int *)(a1 + 328));
  uint64_t v15 = *(unsigned int *)(a1 + 328);
  if ((int)v15 < 1) {
    return 1;
  }
  uint64_t v16 = 0;
  long long v17 = (uint64_t *)v35;
  uint64_t v18 = *(unsigned int *)(a1 + 328);
  do
  {
    uint64_t v19 = *v17++;
    v16 |= v19;
    --v18;
  }
  while (v18);
  uint64_t v20 = 0;
  uint64_t v21 = *(unsigned int *)(a1 + 328);
  do
  {
    uint64_t v22 = *v9++;
    v20 |= v22;
    --v21;
  }
  while (v21);
  do
  {
    uint64_t v23 = *v8++;
    v21 |= v23;
    --v15;
  }
  while (v15);
  BOOL v24 = v21 != 0;
  if (v16) {
    char v25 = 0;
  }
  else {
    char v25 = v14;
  }
  BOOL v26 = v25 & v24;
  if (v20) {
    return v26;
  }
  else {
    return ~v24;
  }
}

uint64_t sub_244D2887C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 532)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

BOOL sub_244D28890(uint64_t a1, void **a2)
{
  return sub_244D16764(a2, a1 + 256) != 0;
}

uint64_t sub_244D288BC(uint64_t a1)
{
  return sub_244D168EC((uint64_t *)(a1 + 256));
}

uint64_t sub_244D288C4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 1;
  if (!sub_244D15DEC((void **)a2, 1uLL)) {
    return 0;
  }
  *(_DWORD *)(a2 + 16) = 0;
  **(void **)a2 = 1;
  *(_DWORD *)(a2 + 8) = 1;
  return v3;
}

uint64_t sub_244D28918(uint64_t a1, void **a2, void *a3, void *a4)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a2 || (uint64_t result = (uint64_t)sub_244D16764(a2, a1 + 320)) != 0)
  {
    if (!a3
      || (unint64_t v8 = 0,
          (*(void (**)(uint64_t, unsigned __int8 *, unint64_t *, uint64_t))(*(void *)a1 + 104))(a1, v9, &v8, a1 + 360), (uint64_t result = (uint64_t)sub_244D16D20(v9, v8, a3)) != 0))
    {
      if (!a4) {
        return 1;
      }
      unint64_t v8 = 0;
      (*(void (**)(uint64_t, unsigned __int8 *, unint64_t *, uint64_t))(*(void *)a1 + 104))(a1, v9, &v8, a1 + 432);
      uint64_t result = (uint64_t)sub_244D16D20(v9, v8, a4);
      if (result) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_244D28A08(uint64_t a1)
{
  return *(unsigned int *)(a1 + 512);
}

uint64_t sub_244D28A10(uint64_t a1)
{
  return sub_244D168EC((uint64_t *)(a1 + 320));
}

const char *sub_244D28A18(int a1)
{
  if (a1 > 714)
  {
    if (a1 != 715)
    {
      if (a1 == 716) {
        return "P-521";
      }
      return 0;
    }
    return "P-384";
  }
  else
  {
    if (a1 != 415)
    {
      if (a1 == 713) {
        return "P-224";
      }
      return 0;
    }
    return "P-256";
  }
}

uint64_t sub_244D28A78(const char *a1)
{
  if (!strcmp(a1, "P-224")) {
    return 713;
  }
  if (!strcmp(a1, "P-256")) {
    return 415;
  }
  if (!strcmp(a1, "P-384")) {
    return 715;
  }
  if (!strcmp(a1, "P-521")) {
    return 716;
  }
  return 0;
}

void *sub_244D28B04(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = sub_244D43FF4(0xE0uLL);
    if (v2)
    {
      if (!*(_DWORD *)(a1 + 512)) {
        sub_244D499E4((unsigned int *)(a1 + 540));
      }
      void *v2 = a1;
      sub_244D28B7C((uint64_t)(v2 + 1));
    }
  }
  else
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 469);
    return 0;
  }
  return v2;
}

double sub_244D28B7C(uint64_t a1)
{
  *(void *)(a1 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(void *)(a1 + 208) = 0;
  return result;
}

void sub_244D28BB0(uint64_t *a1)
{
  if (a1)
  {
    sub_244D2826C(*a1);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D28BF8(uint64_t *a1, uint64_t *a2)
{
  if (sub_244D2670C(*a1, *a2))
  {
    sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 501);
    return 0;
  }
  else
  {
    if (a1 != a2) {
      sub_244D28C68((uint64_t)(a1 + 1), (uint64_t)(a2 + 1));
    }
    return 1;
  }
}

__n128 sub_244D28C68(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  long long v2 = *(_OWORD *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)(a1 + 16) = v2;
  long long v5 = *(_OWORD *)(a2 + 104);
  long long v6 = *(_OWORD *)(a2 + 120);
  uint64_t v7 = *(void *)(a2 + 136);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 136) = v7;
  *(_OWORD *)(a1 + 120) = v6;
  *(_OWORD *)(a1 + 104) = v5;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  long long v9 = *(_OWORD *)(a2 + 176);
  long long v8 = *(_OWORD *)(a2 + 192);
  long long v10 = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(_OWORD *)(a1 + 176) = v9;
  *(_OWORD *)(a1 + 192) = v8;
  *(_OWORD *)(a1 + 160) = v10;
  __n128 result = *(__n128 *)(a2 + 144);
  *(__n128 *)(a1 + 144) = result;
  return result;
}

uint64_t *sub_244D28CD4(uint64_t *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  long long v3 = sub_244D28B04(a2);
  long long v4 = v3;
  if (!v3 || !sub_244D28BF8(v3, a1))
  {
    sub_244D28BB0(v4);
    return 0;
  }
  return v4;
}

uint64_t sub_244D28D28(uint64_t a1, uint64_t *a2)
{
  if (sub_244D2670C(a1, *a2))
  {
    sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 528);
    return 0;
  }
  else
  {
    sub_244D28B7C((uint64_t)(a2 + 1));
    return 1;
  }
}

double sub_244D28D84(uint64_t a1, uint64_t a2)
{
  return sub_244D28B7C(a2);
}

BOOL sub_244D28D8C(uint64_t a1, uint64_t *a2)
{
  if (sub_244D2670C(a1, *a2))
  {
    sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 537);
    return 0;
  }
  else
  {
    uint64_t v5 = *(unsigned int *)(a1 + 328);
    if ((int)v5 < 1)
    {
      return 1;
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v7 = a2 + 19;
      do
      {
        uint64_t v8 = *v7++;
        v6 |= v8;
        --v5;
      }
      while (v5);
      return v6 == 0;
    }
  }
}

BOOL sub_244D28E14(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 328);
  if ((int)v2 < 1) {
    return 1;
  }
  uint64_t v3 = 0;
  long long v4 = (uint64_t *)(a2 + 144);
  do
  {
    uint64_t v5 = *v4++;
    v3 |= v5;
    --v2;
  }
  while (v2);
  return v3 == 0;
}

BOOL sub_244D28E4C(uint64_t a1, uint64_t *a2)
{
  if (sub_244D2670C(a1, *a2))
  {
    sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 546);
    return 0;
  }
  else
  {
    return sub_244D28EC0(a1, (uint64_t)(a2 + 1));
  }
}

BOOL sub_244D28EC0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void (**)(uint64_t, _OWORD *, _OWORD *, _OWORD *))(*(void *)a1 + 88);
  long long v4 = *(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 96);
  uint64_t v23 = 0;
  memset(v22, 0, sizeof(v22));
  v4(a1, v22, a2);
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v19 = 0;
  memset(v18, 0, sizeof(v18));
  uint64_t v17 = 0;
  uint64_t v6 = (uint64_t *)(a2 + 144);
  memset(v16, 0, sizeof(v16));
  v4(a1, v20, a2 + 144);
  v4(a1, v18, (uint64_t)v20);
  v5(a1, v16, v18, v20);
  if (*(_DWORD *)(a1 + 528))
  {
    sub_244D295D0(a1, (unint64_t *)v20, (uint64_t *)v18, (uint64_t *)v18);
    sub_244D295D0(a1, (unint64_t *)v20, (uint64_t *)v20, (uint64_t *)v18);
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    sub_244D1811C((unint64_t *)v22, (unint64_t *)v22, (unint64_t *)v20, *(uint64_t **)(a1 + 320), (uint64_t *)&v24, *(int *)(a1 + 328));
  }
  else
  {
    v5(a1, v20, v18, (_OWORD *)(a1 + 360));
    sub_244D295D0(a1, (unint64_t *)v22, (uint64_t *)v22, (uint64_t *)v20);
  }
  v5(a1, v22, v22, (_OWORD *)a2);
  v5(a1, v20, (_OWORD *)(a1 + 432), v16);
  sub_244D295D0(a1, (unint64_t *)v22, (uint64_t *)v22, (uint64_t *)v20);
  v4(a1, v20, a2 + 72);
  uint64_t v28 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  sub_244D1811C((unint64_t *)v20, (unint64_t *)v20, (unint64_t *)v22, *(uint64_t **)(a1 + 320), (uint64_t *)&v24, *(int *)(a1 + 328));
  uint64_t v7 = *(unsigned int *)(a1 + 328);
  if ((int)v7 < 1) {
    return 1;
  }
  uint64_t v8 = 0;
  long long v9 = (uint64_t *)v20;
  uint64_t v10 = *(unsigned int *)(a1 + 328);
  do
  {
    uint64_t v11 = *v9++;
    v8 |= v11;
    --v10;
  }
  while (v10);
  uint64_t v12 = 0;
  do
  {
    uint64_t v13 = *v6++;
    v12 |= v13;
    --v7;
  }
  while (v7);
  return !v12 || v8 == 0;
}

uint64_t sub_244D290D0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (!sub_244D2670C(a1, *a2) && !sub_244D2670C(a1, *a3)) {
    return sub_244D28654(a1, (uint64_t)(a2 + 1), (uint64_t)(a3 + 1)) ^ 1;
  }
  sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 556);
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D29154(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (!**(void **)a1)
  {
    int v8 = 66;
    __int16 v9 = 568;
    goto LABEL_5;
  }
  if (sub_244D2670C(a1, *a2))
  {
    int v8 = 106;
    __int16 v9 = 572;
LABEL_5:
    sub_244D0B884(15, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v9);
    return 0;
  }
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  if (a3) {
    uint64_t v11 = v15;
  }
  else {
    uint64_t v11 = 0;
  }
  if (a4) {
    uint64_t v12 = v13;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, _OWORD *, _OWORD *))a1)(a1, (uint64_t)(a2 + 1), v11, v12);
  if (result)
  {
    if (!a3
      || (unint64_t v17 = 0,
          (*(void (**)(uint64_t, unsigned __int8 *, unint64_t *, _OWORD *))(*(void *)a1 + 104))(a1, v18, &v17, v15), (uint64_t result = (uint64_t)sub_244D16D20(v18, v17, a3)) != 0))
    {
      if (!a4) {
        return 1;
      }
      unint64_t v17 = 0;
      (*(void (**)(uint64_t, unsigned __int8 *, unint64_t *, _OWORD *))(*(void *)a1 + 104))(a1, v18, &v17, v13);
      uint64_t result = (uint64_t)sub_244D16D20(v18, v17, a4);
      if (result) {
        return 1;
      }
    }
  }
  return result;
}

BOOL sub_244D292DC(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  unint64_t v5 = 0;
  (*(void (**)(uint64_t, unsigned __int8 *, unint64_t *, uint64_t))(*(void *)a1 + 104))(a1, v6, &v5, a3);
  return sub_244D16D20(v6, v5, a2) != 0;
}

__n128 sub_244D29368(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  long long v3 = *(_OWORD *)(a3 + 16);
  long long v4 = *(_OWORD *)(a3 + 32);
  long long v5 = *(_OWORD *)(a3 + 48);
  *(void *)(a2 + 64) = *(void *)(a3 + 64);
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 48) = v5;
  *(_OWORD *)(a2 + 16) = v3;
  long long v6 = *(_OWORD *)(a3 + 104);
  long long v7 = *(_OWORD *)(a3 + 120);
  uint64_t v8 = *(void *)(a3 + 136);
  *(_OWORD *)(a2 + 88) = *(_OWORD *)(a3 + 88);
  *(void *)(a2 + 136) = v8;
  *(_OWORD *)(a2 + 120) = v7;
  *(_OWORD *)(a2 + 104) = v6;
  *(_OWORD *)(a2 + 72) = *(_OWORD *)(a3 + 72);
  long long v10 = *(_OWORD *)(a1 + 192);
  long long v9 = *(_OWORD *)(a1 + 208);
  long long v11 = *(_OWORD *)(a1 + 176);
  *(void *)(a2 + 208) = *(void *)(a1 + 224);
  *(_OWORD *)(a2 + 176) = v10;
  *(_OWORD *)(a2 + 192) = v9;
  *(_OWORD *)(a2 + 160) = v11;
  __n128 result = *(__n128 *)(a1 + 160);
  *(__n128 *)(a2 + 144) = result;
  return result;
}

uint64_t sub_244D293D4(uint64_t a1)
{
  return a1 + 160;
}

uint64_t sub_244D293DC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 8);
  if (v1)
  {
    return v1();
  }
  else
  {
    sub_244D0B884(15, 0, 66, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 607);
    return 0;
  }
}

uint64_t sub_244D29434(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void (**)(uint64_t, _OWORD *, _OWORD *, uint64_t))(*(void *)a1 + 88);
  long long v9 = *(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 96);
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  v9(a1, v25, a4);
  v9(a1, v23, a3);
  sub_244D295D0(a1, (unint64_t *)v23, (uint64_t *)v23, (uint64_t *)(a1 + 360));
  v8(a1, v23, v23, a3);
  sub_244D295D0(a1, (unint64_t *)v23, (uint64_t *)v23, (uint64_t *)(a1 + 432));
  if (sub_244D441D4((char *)v25, (char *)v23, 8 * *(int *)(a1 + 328)))
  {
    sub_244D0B884(15, 0, 120, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 628);
    uint64_t result = 0;
    if (*(_DWORD *)(a1 + 532))
    {
      *(_OWORD *)a2 = *(_OWORD *)(a1 + 16);
      long long v11 = *(_OWORD *)(a1 + 32);
      long long v12 = *(_OWORD *)(a1 + 48);
      long long v13 = *(_OWORD *)(a1 + 64);
      *(void *)(a2 + 64) = *(void *)(a1 + 80);
      *(_OWORD *)(a2 + 32) = v12;
      *(_OWORD *)(a2 + 48) = v13;
      *(_OWORD *)(a2 + 16) = v11;
      long long v14 = *(_OWORD *)(a1 + 120);
      long long v15 = *(_OWORD *)(a1 + 136);
      long long v16 = *(_OWORD *)(a1 + 104);
      *(void *)(a2 + 136) = *(void *)(a1 + 152);
      *(_OWORD *)(a2 + 88) = v16;
      *(_OWORD *)(a2 + 120) = v15;
      *(_OWORD *)(a2 + 104) = v14;
      *(_OWORD *)(a2 + 72) = *(_OWORD *)(a1 + 88);
    }
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)a3;
    long long v17 = *(_OWORD *)(a3 + 16);
    long long v18 = *(_OWORD *)(a3 + 32);
    long long v19 = *(_OWORD *)(a3 + 48);
    *(void *)(a2 + 64) = *(void *)(a3 + 64);
    *(_OWORD *)(a2 + 32) = v18;
    *(_OWORD *)(a2 + 48) = v19;
    *(_OWORD *)(a2 + 16) = v17;
    long long v21 = *(_OWORD *)(a4 + 32);
    long long v20 = *(_OWORD *)(a4 + 48);
    uint64_t v22 = *(void *)(a4 + 64);
    *(_OWORD *)(a2 + 88) = *(_OWORD *)(a4 + 16);
    *(void *)(a2 + 136) = v22;
    *(_OWORD *)(a2 + 120) = v20;
    *(_OWORD *)(a2 + 104) = v21;
    *(_OWORD *)(a2 + 72) = *(_OWORD *)a4;
    return 1;
  }
  return result;
}

uint64_t sub_244D295D0(uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  long long v5 = *(unint64_t **)(a1 + 320);
  unint64_t v6 = *(int *)(a1 + 328);
  uint64_t v7 = sub_244D15EB4(a2, a3, a4, v6);
  return sub_244D180A8(a2, v7, v5, (unint64_t *)v9, v6);
}

uint64_t sub_244D29644(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_244D2670C(a1, *(void *)a2))
  {
    int v8 = 106;
    __int16 v9 = 649;
LABEL_10:
    sub_244D0B884(15, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v9);
    return 0;
  }
  if (!a3 || !a4)
  {
    int v8 = 67;
    __int16 v9 = 654;
    goto LABEL_10;
  }
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v25 = 0;
  memset(v24, 0, sizeof(v24));
  long long v22 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  if (sub_244D297C4((uint64_t *)a1, (uint64_t)v26, a3)
    && sub_244D297C4((uint64_t *)a1, (uint64_t)v24, a4)
    && sub_244D29434(a1, (uint64_t)&v19, (uint64_t)v26, (uint64_t)v24))
  {
    long long v10 = v19;
    *(_OWORD *)(a2 + 24) = v20;
    long long v11 = v22;
    *(_OWORD *)(a2 + 40) = v21;
    *(_OWORD *)(a2 + 56) = v11;
    *(void *)(a2 + 72) = *(void *)&v23[0];
    *(_OWORD *)(a2 + 8) = v10;
    long long v12 = *(_OWORD *)((char *)v23 + 8);
    *(void *)(a2 + 144) = *((void *)&v23[4] + 1);
    long long v13 = *(_OWORD *)((char *)&v23[3] + 8);
    *(_OWORD *)(a2 + 112) = *(_OWORD *)((char *)&v23[2] + 8);
    *(_OWORD *)(a2 + 128) = v13;
    long long v14 = *(_OWORD *)((char *)&v23[1] + 8);
    *(_OWORD *)(a2 + 80) = v12;
    *(_OWORD *)(a2 + 96) = v14;
    *(_OWORD *)(a2 + 152) = *(_OWORD *)(a1 + 160);
    long long v15 = *(_OWORD *)(a1 + 176);
    long long v16 = *(_OWORD *)(a1 + 192);
    long long v17 = *(_OWORD *)(a1 + 208);
    *(void *)(a2 + 216) = *(void *)(a1 + 224);
    *(_OWORD *)(a2 + 200) = v17;
    *(_OWORD *)(a2 + 184) = v16;
    *(_OWORD *)(a2 + 168) = v15;
    return 1;
  }
  sub_244D298B4(a1, a2 + 8);
  return 0;
}

uint64_t sub_244D297C4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v6 = (uint64_t)(a1 + 40);
  int v7 = sub_244D168EC(a1 + 40);
  if (!*(_DWORD *)(a3 + 16))
  {
    int v8 = v7;
    if ((sub_244D17194(a3, v6) & 0x80000000) != 0)
    {
      unint64_t v10 = (v8 + 7) >> 3;
      if (sub_244D16FA8(v11, v10, a3)) {
        return (*(uint64_t (**)(uint64_t *, uint64_t, char *, unint64_t))(*a1 + 112))(a1, a2, v11, v10);
      }
    }
  }
  sub_244D0B884(15, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/felem.c", 37);
  return 0;
}

double sub_244D298B4(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 532)) {
    return sub_244D28B7C(a2);
  }
  *(void *)&double result = sub_244D28C68(a2, a1 + 16).n128_u64[0];
  return result;
}

uint64_t sub_244D298D8(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  if (sub_244D2670C(a1, *a2)
    || sub_244D2670C(a1, *a3)
    || sub_244D2670C(a1, *a4))
  {
    sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 684);
    return 0;
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)a1 + 16))(a1, a2 + 1, a3 + 1, a4 + 1);
    return 1;
  }
}

uint64_t sub_244D2997C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (sub_244D2670C(a1, *a2) || sub_244D2670C(a1, *a3))
  {
    sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 695);
    return 0;
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 24))(a1, a2 + 1, a3 + 1);
    return 1;
  }
}

uint64_t sub_244D29A08(uint64_t a1, uint64_t a2)
{
  if (sub_244D2670C(a1, *(void *)a2))
  {
    sub_244D0B884(15, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 705);
    return 0;
  }
  else
  {
    sub_244D2C518(a1, (unint64_t *)(a2 + 80), (unint64_t *)(a2 + 80));
    return 1;
  }
}

unint64_t sub_244D29A70(uint64_t a1, uint64_t a2)
{
  return sub_244D2C518(a1, (unint64_t *)(a2 + 72), (unint64_t *)(a2 + 72));
}

uint64_t sub_244D29A7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  if ((a4 != 0) != (a5 == 0) && (a3 | a5) != 0)
  {
    if (sub_244D2670C(a1, *(void *)a2) || a4 && sub_244D2670C(a1, *a4))
    {
      int v7 = 106;
      __int16 v8 = 744;
      goto LABEL_8;
    }
    if (a6)
    {
      long long v17 = 0;
      if (!a3) {
        goto LABEL_19;
      }
    }
    else
    {
      long long v18 = sub_244D43FF4(0x30uLL);
      if (!v18)
      {
        uint64_t v15 = 0;
        long long v17 = 0;
        goto LABEL_28;
      }
      a6 = (uint64_t)v18;
      *(_OWORD *)((char *)v18 + 26) = 0u;
      *long long v18 = 0u;
      v18[1] = 0u;
      long long v17 = (unint64_t **)v18;
      if (!a3) {
        goto LABEL_19;
      }
    }
    *(void *)&long long v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    if (!sub_244D29CCC(a1, &v25, a3, a6) || !sub_244D29D74(a1, a2 + 8, (uint64_t)&v25))
    {
LABEL_24:
      uint64_t v15 = 0;
LABEL_28:
      sub_244D17500(v17);
      return v15;
    }
LABEL_19:
    if (!a5)
    {
LABEL_27:
      uint64_t v15 = 1;
      goto LABEL_28;
    }
    uint64_t v40 = 0;
    memset(v39, 0, sizeof(v39));
    uint64_t v38 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v25 = 0u;
    if (sub_244D29CCC(a1, v39, a5, a6)
      && sub_244D267EC(a1, (uint64_t)&v25, (uint64_t)(a4 + 1), (uint64_t)v39))
    {
      if (a3)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, long long *))(*(void *)a1 + 16))(a1, a2 + 8, a2 + 8, &v25);
      }
      else
      {
        long long v19 = v36;
        *(_OWORD *)(a2 + 168) = v35;
        *(_OWORD *)(a2 + 184) = v19;
        *(_OWORD *)(a2 + 200) = v37;
        long long v20 = v32;
        *(_OWORD *)(a2 + 104) = v31;
        *(_OWORD *)(a2 + 120) = v20;
        long long v21 = v34;
        *(_OWORD *)(a2 + 136) = v33;
        *(_OWORD *)(a2 + 152) = v21;
        long long v22 = v28;
        *(_OWORD *)(a2 + 40) = v27;
        *(_OWORD *)(a2 + 56) = v22;
        long long v23 = v30;
        *(_OWORD *)(a2 + 72) = v29;
        *(_OWORD *)(a2 + 88) = v23;
        long long v24 = v26;
        *(_OWORD *)(a2 + 8) = v25;
        *(void *)(a2 + 216) = v38;
        *(_OWORD *)(a2 + 24) = v24;
      }
      goto LABEL_27;
    }
    goto LABEL_24;
  }
  int v7 = 67;
  __int16 v8 = 738;
LABEL_8:
  sub_244D0B884(15, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v8);
  return 0;
}

uint64_t sub_244D29CCC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (sub_244D26F88(a1, a2, a3)) {
    return 1;
  }
  sub_244D0B1B0();
  sub_244D1756C((void *)a4);
  uint64_t result = (uint64_t)sub_244D17610(a4);
  if (result)
  {
    uint64_t v9 = result;
    uint64_t result = sub_244D17F9C(result, a3, a1 + 256, a4);
    if (result) {
      uint64_t result = sub_244D26F88(a1, a2, v9);
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v10 = *(void *)(a4 + 8);
    uint64_t v11 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v11;
    *(void *)(a4 + 32) = *(void *)(v10 + 8 * v11);
  }
  return result;
}

uint64_t sub_244D29D74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if (sub_244D28EC0(a1, a2)) {
      return 1;
    }
    int v6 = 68;
    __int16 v7 = 867;
  }
  else
  {
    int v6 = 67;
    __int16 v7 = 856;
  }
  sub_244D0B884(15, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v7);
  return 0;
}

uint64_t sub_244D29E00(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 64);
  if (v1)
  {
    return v1();
  }
  else
  {
    sub_244D0B884(15, 0, 66, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 826);
    return 0;
  }
}

uint64_t sub_244D29E58(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (**)(void))(*(void *)a1 + 48);
  if (v2)
  {
    v2();
    if (sub_244D28EC0(a1, a2)) {
      return 1;
    }
    int v6 = 68;
    __int16 v7 = 889;
  }
  else
  {
    int v6 = 66;
    __int16 v7 = 880;
  }
  sub_244D0B884(15, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v7);
  return 0;
}

uint64_t sub_244D29EE0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 72);
  if (v1)
  {
    return v1();
  }
  else
  {
    sub_244D0B884(15, 0, 66, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", 899);
    return 0;
  }
}

uint64_t sub_244D29F38(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (**)(void))(*(void *)a1 + 80);
  if (v2)
  {
    v2();
    if (sub_244D28EC0(a1, a2)) {
      return 1;
    }
    int v6 = 68;
    __int16 v7 = 921;
  }
  else
  {
    int v6 = 66;
    __int16 v7 = 912;
  }
  sub_244D0B884(15, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec.c", v7);
  return 0;
}

uint64_t sub_244D29FC0(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *(int *)(result + 328);
  if (v5)
  {
    uint64_t v6 = ~a3;
    __int16 v7 = a4;
    __int16 v8 = a5;
    uint64_t v9 = a2;
    do
    {
      uint64_t v11 = *v7++;
      uint64_t v10 = v11;
      uint64_t v12 = *v8++;
      *v9++ = v12 & v6 | v10 & a3;
      --v5;
    }
    while (v5);
    uint64_t v13 = *(int *)(result + 328);
    if (v13)
    {
      long long v14 = a2 + 9;
      uint64_t v15 = a4 + 9;
      long long v16 = a5 + 9;
      do
      {
        uint64_t v18 = *v15++;
        uint64_t v17 = v18;
        uint64_t v19 = *v16++;
        *v14++ = v19 & v6 | v17 & a3;
        --v13;
      }
      while (v13);
      uint64_t v20 = *(int *)(result + 328);
      if (v20)
      {
        long long v21 = a2 + 18;
        long long v22 = a4 + 18;
        long long v23 = a5 + 18;
        do
        {
          uint64_t v25 = *v22++;
          uint64_t v24 = v25;
          uint64_t v26 = *v23++;
          *v21++ = v26 & v6 | v24 & a3;
          --v20;
        }
        while (v20);
      }
    }
  }
  return result;
}

uint64_t sub_244D2A064(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *(int *)(result + 328);
  if (v5)
  {
    do
    {
      uint64_t v7 = *a4++;
      uint64_t v6 = v7;
      uint64_t v8 = *a5++;
      *a2++ = v8 & ~a3 | v6 & a3;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t sub_244D2A094(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *(int *)(result + 328);
  if (v5)
  {
    uint64_t v6 = ~a3;
    uint64_t v7 = a4;
    uint64_t v8 = a5;
    uint64_t v9 = a2;
    do
    {
      uint64_t v11 = *v7++;
      uint64_t v10 = v11;
      uint64_t v12 = *v8++;
      *v9++ = v12 & v6 | v10 & a3;
      --v5;
    }
    while (v5);
    uint64_t v13 = *(int *)(result + 328);
    if (v13)
    {
      long long v14 = a2 + 9;
      uint64_t v15 = a4 + 9;
      long long v16 = a5 + 9;
      do
      {
        uint64_t v18 = *v15++;
        uint64_t v17 = v18;
        uint64_t v19 = *v16++;
        *v14++ = v19 & v6 | v17 & a3;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t sub_244D2A104(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10 = 31;
  do
  {
    uint64_t result = sub_244D2A094(a1, a2, a3, a4, a5);
    a5 += 18;
    a4 += 18;
    a2 += 18;
    --v10;
  }
  while (v10);
  return result;
}

uint64_t sub_244D2A174(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v6 = 0;
  uint64_t result = sub_244D26878((uint64_t *)a1, (uint64_t)v8, &v6, 0x42uLL, a3);
  if (result)
  {
    memset(v7, 0, sizeof(v7));
    sub_244D16C88((unint64_t *)v7, *(int *)(a1 + 264) + 1, v8, v6);
    sub_244D18038(a2, (unint64_t *)v7, *((void *)v7 + *(int *)(a1 + 264)), *(unint64_t **)(a1 + 256), *(int *)(a1 + 264));
    return 1;
  }
  return result;
}

uint64_t sub_244D2A238(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
}

uint64_t sub_244D2A244()
{
  return 305397760;
}

uint64_t sub_244D2A24C()
{
  return 406;
}

void sub_244D2A254(uint64_t a1, int a2)
{
  if (a2 != 4) {
    abort();
  }
}

void *sub_244D2A270()
{
  return sub_244D2A278(0);
}

void *sub_244D2A278(uint64_t a1)
{
  uint64_t v2 = sub_244D44058(0x38uLL);
  long long v4 = v2;
  if (!v2) {
    return v4;
  }
  if (!a1)
  {
    uint64_t v5 = v2[5];
    if (!v5) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  uint64_t v5 = sub_244CF48E8(a1);
  v4[5] = v5;
  if (v5) {
LABEL_4:
  }
    nullsub_13(v5, v3);
LABEL_5:
  *(void *)((char *)v4 + 28) = 0x100000004;
  sub_244D1389C(v4 + 6);
  uint64_t v6 = v4[5];
  if (v6)
  {
    uint64_t v7 = *(unsigned int (**)(void *))(v6 + 16);
    if (v7)
    {
      if (!v7(v4))
      {
        sub_244D138A4((uint64_t)&unk_268EBD890, (uint64_t)v4, v4 + 6);
        uint64_t v9 = v4[5];
        if (v9) {
          nullsub_13(v9, v8);
        }
        sub_244D440EC(v4);
        return 0;
      }
    }
  }
  return v4;
}

void *sub_244D2A330(int a1)
{
  uint64_t v2 = sub_244D2A278(0);
  if (v2)
  {
    uint64_t v3 = sub_244D284EC(a1);
    void *v2 = v3;
    if (!v3)
    {
      sub_244D2A380((uint64_t)v2);
      return 0;
    }
  }
  return v2;
}

void sub_244D2A380(uint64_t a1)
{
  if (a1 && sub_244D49A14((unsigned int *)(a1 + 32)))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      long long v4 = *(void (**)(uint64_t))(v3 + 24);
      if (v4)
      {
        v4(a1);
        uint64_t v3 = *(void *)(a1 + 40);
      }
      nullsub_13(v3, v2);
    }
    sub_244D138A4((uint64_t)&unk_268EBD890, a1, (uint64_t *)(a1 + 48));
    sub_244D2826C(*(void *)a1);
    sub_244D28BB0(*(uint64_t **)(a1 + 8));
    sub_244D440EC(*(void **)(a1 + 16));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D2A41C(uint64_t a1)
{
  if (!a1)
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 177);
    return 0;
  }
  uint64_t v2 = sub_244D2A278(0);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    if (!*(void *)a1 || sub_244D2A4D0(v2, *(void *)a1))
    {
      long long v4 = *(uint64_t **)(a1 + 8);
      if (!v4 || sub_244D2A554(v3, v4))
      {
        uint64_t v5 = *(void *)(a1 + 16);
        if (!v5 || sub_244D2A5F0((uint64_t *)v3, v5))
        {
          *(_DWORD *)(v3 + 24) = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(v3 + 28) = *(_DWORD *)(a1 + 28);
          return v3;
        }
      }
    }
    sub_244D2A380(v3);
    return 0;
  }
  return v3;
}

BOOL sub_244D2A4D0(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (v4)
  {
    if (sub_244D2670C(v4, a2))
    {
      sub_244D0B884(15, 0, 130, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 216);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (a2 && !*(_DWORD *)(a2 + 512)) {
      sub_244D499E4((unsigned int *)(a2 + 540));
    }
    *a1 = a2;
    return a2 != 0;
  }
}

BOOL sub_244D2A554(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)a1;
  if (!v3)
  {
    int v5 = 114;
    __int16 v6 = 264;
    goto LABEL_6;
  }
  if (a2 && sub_244D2670C(v3, *a2))
  {
    int v5 = 130;
    __int16 v6 = 269;
LABEL_6:
    sub_244D0B884(15, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", v6);
    return 0;
  }
  sub_244D28BB0(*(uint64_t **)(a1 + 8));
  uint64_t v8 = sub_244D28CD4(a2, *(void *)a1);
  *(void *)(a1 + 8) = v8;
  return v8 != 0;
}

uint64_t sub_244D2A5F0(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t result = (uint64_t)sub_244D44058(0x60uLL);
    if (!result) {
      return result;
    }
    __int16 v6 = (void *)result;
    uint64_t v7 = (uint64_t *)(result + 24);
    *(void *)uint64_t result = result + 24;
    *(_DWORD *)(result + 8) = *(_DWORD *)(v2 + 264);
    *(_DWORD *)(result + 12) = *(_DWORD *)(v2 + 264);
    *(_DWORD *)(result + 20) = 2;
    if (sub_244D26F88(*a1, (void *)(result + 24), a2))
    {
      uint64_t v8 = *(unsigned int *)(*a1 + 264);
      if ((int)v8 < 1)
      {
        BOOL v11 = 1;
      }
      else
      {
        uint64_t v9 = 0;
        do
        {
          uint64_t v10 = *v7++;
          v9 |= v10;
          --v8;
        }
        while (v8);
        BOOL v11 = v9 == 0;
      }
      if (!v11)
      {
        sub_244D440EC((void *)a1[2]);
        a1[2] = (uint64_t)v6;
        return 1;
      }
    }
    sub_244D0B884(15, 0, 113, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 249);
    sub_244D440EC(v6);
  }
  else
  {
    sub_244D0B884(15, 0, 114, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 236);
  }
  return 0;
}

uint64_t sub_244D2A704(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D2A724(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1) {
    return *(_DWORD *)(v1 + 48) & 1;
  }
  else {
    return 0;
  }
}

BOOL sub_244D2A740(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 264);
  if ((int)v2 < 1) {
    return 1;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v4 = *a2++;
    v3 |= v4;
    --v2;
  }
  while (v2);
  return v3 == 0;
}

uint64_t sub_244D2A774(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

uint64_t sub_244D2A77C(uint64_t a1)
{
  if (a1 && (v2 = *(void *)a1) != 0 && (uint64_t v3 = *(uint64_t **)(a1 + 8)) != 0)
  {
    if (sub_244D28D8C(v2, v3))
    {
      int v4 = 119;
      __int16 v5 = 299;
    }
    else
    {
      if (sub_244D28E4C(*(void *)a1, *(uint64_t **)(a1 + 8)))
      {
        uint64_t v7 = *(void *)(a1 + 16);
        if (v7)
        {
          uint64_t v9 = 0;
          memset(v8, 0, sizeof(v8));
          if (!sub_244D29D74(*(void *)a1, (uint64_t)v8, v7 + 24))
          {
            int v4 = 15;
            __int16 v5 = 317;
            goto LABEL_7;
          }
          if (!sub_244D28654(*(void *)a1, (uint64_t)v8, *(void *)(a1 + 8) + 8))
          {
            int v4 = 113;
            __int16 v5 = 324;
            goto LABEL_7;
          }
        }
        return 1;
      }
      int v4 = 120;
      __int16 v5 = 305;
    }
  }
  else
  {
    int v4 = 67;
    __int16 v5 = 294;
  }
LABEL_7:
  sub_244D0B884(15, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", v5);
  return 0;
}

uint64_t sub_244D2A8B8(uint64_t *a1)
{
  void v8[2] = *MEMORY[0x263EF8340];
  uint64_t v2 = a1[5];
  if (v2 && (*(unsigned char *)(v2 + 48) & 1) != 0)
  {
    __int16 v7 = 338;
  }
  else
  {
    uint64_t result = sub_244D2A77C((uint64_t)a1);
    if (!result) {
      return result;
    }
    if (!a1[2]) {
      return 1;
    }
    v8[0] = 0;
    v8[1] = 0;
    int v4 = sub_244D27580(v8, 0x10uLL, a1);
    if (v4)
    {
      __int16 v5 = v4;
      int v6 = sub_244D26CF4((unsigned __int8 *)v8, 0x10uLL, v4, (uint64_t)a1);
      sub_244D07DFC(v5);
      if (v6) {
        return 1;
      }
    }
    else
    {
      sub_244D07DFC(0);
    }
    __int16 v7 = 356;
  }
  sub_244D0B884(15, 0, 132, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", v7);
  return 0;
}

uint64_t sub_244D2A9B8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a3 && a2 && (uint64_t v6 = *a1) != 0)
  {
    __int16 v7 = sub_244D28B04(v6);
    if (v7 && sub_244D29644(*a1, (uint64_t)v7, a2, a3) && sub_244D2A554((uint64_t)a1, v7)) {
      uint64_t v8 = sub_244D2A77C((uint64_t)a1);
    }
    else {
      uint64_t v8 = 0;
    }
    sub_244D28BB0(v7);
  }
  else
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 378);
    return 0;
  }
  return v8;
}

BOOL sub_244D2AA74(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a1;
  if (v5)
  {
    uint64_t v9 = sub_244D28B04(v5);
    BOOL v10 = v9 && sub_244D2AB28(*a1, (uint64_t)v9, a2, a3, a4) && sub_244D2A554((uint64_t)a1, v9);
    sub_244D28BB0(v9);
  }
  else
  {
    sub_244D0B884(15, 0, 114, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 399);
    return 0;
  }
  return v10;
}

uint64_t sub_244D2AB28(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  if (sub_244D2670C(a1, *(void *)a2))
  {
    int v10 = 106;
    __int16 v11 = 205;
LABEL_3:
    sub_244D0B884(15, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", v11);
    return 0;
  }
  if (!a4)
  {
    int v10 = 100;
    __int16 v11 = 140;
    goto LABEL_3;
  }
  int v14 = *a3;
  if (v14 == 4)
  {
    long long v36 = 0u;
    memset(v37, 0, sizeof(v37));
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    int v15 = sub_244D2C768((uint64_t *)a1, (uint64_t)&v33, a3, a4);
    long long v16 = (_OWORD *)(a2 + 8);
    if (v15)
    {
      long long v17 = v36;
      *(_OWORD *)(a2 + 40) = v35;
      *(_OWORD *)(a2 + 56) = v17;
      *(void *)(a2 + 72) = *(void *)&v37[0];
      long long v18 = v34;
      *long long v16 = v33;
      *(_OWORD *)(a2 + 24) = v18;
      long long v19 = *(_OWORD *)((char *)v37 + 8);
      *(void *)(a2 + 144) = *((void *)&v37[4] + 1);
      long long v20 = *(_OWORD *)((char *)&v37[3] + 8);
      *(_OWORD *)(a2 + 112) = *(_OWORD *)((char *)&v37[2] + 8);
      *(_OWORD *)(a2 + 128) = v20;
      long long v21 = *(_OWORD *)((char *)&v37[1] + 8);
      *(_OWORD *)(a2 + 80) = v19;
      *(_OWORD *)(a2 + 96) = v21;
      *(_OWORD *)(a2 + 152) = *(_OWORD *)(a1 + 160);
      long long v22 = *(_OWORD *)(a1 + 176);
      long long v23 = *(_OWORD *)(a1 + 192);
      long long v24 = *(_OWORD *)(a1 + 208);
      *(void *)(a2 + 216) = *(void *)(a1 + 224);
      *(_OWORD *)(a2 + 200) = v24;
      *(_OWORD *)(a2 + 184) = v23;
      *(_OWORD *)(a2 + 168) = v22;
      return 1;
    }
    sub_244D298B4(a1, (uint64_t)v16);
    return 0;
  }
  unint64_t v25 = (sub_244D168EC((uint64_t *)(a1 + 320)) + 7) >> 3;
  if ((v14 & 0xFE) != 2 || v25 + 1 != a4)
  {
    int v10 = 109;
    __int16 v11 = 162;
    goto LABEL_3;
  }
  if (a5)
  {
    long long v27 = 0;
  }
  else
  {
    long long v28 = sub_244D43FF4(0x30uLL);
    if (!v28) {
      return 0;
    }
    a5 = (uint64_t)v28;
    *(_OWORD *)((char *)v28 + 26) = 0u;
    *long long v28 = 0u;
    v28[1] = 0u;
    long long v27 = (unint64_t **)v28;
  }
  sub_244D1756C((void *)a5);
  long long v29 = sub_244D17610(a5);
  if (v29)
  {
    uint64_t v30 = (uint64_t)v29;
    if (sub_244D16D20(a3 + 1, v25, v29))
    {
      if ((sub_244D170B4(*(uint64_t **)v30, *(int *)(v30 + 8), *(uint64_t **)(a1 + 320), *(int *)(a1 + 328)) & 0x80000000) != 0)
      {
        BOOL v12 = sub_244D2C9B4(a1, (uint64_t *)a2, v30, v14 & 1, a5) != 0;
        goto LABEL_26;
      }
      sub_244D0B884(15, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", 186);
    }
  }
  BOOL v12 = 0;
LABEL_26:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v31 = *(void *)(a5 + 8);
    uint64_t v32 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v32;
    *(void *)(a5 + 32) = *(void *)(v31 + 8 * v32);
  }
  sub_244D17500(v27);
  return v12;
}

char *sub_244D2AD94(uint64_t *a1, int a2, char **a3)
{
  if (a1 && (v5 = (uint64_t *)a1[1]) != 0 && (uint64_t v6 = *a1) != 0)
  {
    return sub_244D2AE00(v6, v5, a2, a3);
  }
  else
  {
    sub_244D0B884(15, 0, 114, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 414);
    return 0;
  }
}

char *sub_244D2AE00(uint64_t a1, uint64_t *a2, int a3, char **a4)
{
  *a4 = 0;
  uint64_t result = (char *)sub_244D2C870(a1, a2, a3, 0, 0);
  if (result)
  {
    unint64_t v9 = (unint64_t)result;
    uint64_t result = (char *)sub_244D43FF4((unint64_t)result);
    if (result)
    {
      int v10 = result;
      uint64_t result = (char *)sub_244D2C870(a1, a2, a3, result, v9);
      if (result)
      {
        *a4 = v10;
      }
      else
      {
        sub_244D440EC(v10);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_244D2AE90(uint64_t *a1, unsigned __int8 *a2, unint64_t a3)
{
  if (!*a1)
  {
    int v8 = 114;
    __int16 v9 = 423;
LABEL_7:
    sub_244D0B884(15, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", v9);
    return 0;
  }
  if ((sub_244D168EC((uint64_t *)(*a1 + 256)) + 7) >> 3 != a3)
  {
    int v8 = 128;
    __int16 v9 = 428;
    goto LABEL_7;
  }
  uint64_t v6 = sub_244D16D20(a2, a3, 0);
  if (v6) {
    uint64_t v7 = sub_244D2A5F0(a1, (uint64_t)v6);
  }
  else {
    uint64_t v7 = 0;
  }
  sub_244D166B0((void **)v6);
  return v7;
}

unint64_t sub_244D2AF5C(uint64_t *a1, char *a2, unint64_t a3)
{
  uint64_t v3 = *a1;
  if (!*a1 || (uint64_t v4 = a1[2]) == 0)
  {
    int v9 = 114;
    __int16 v10 = 441;
LABEL_7:
    sub_244D0B884(15, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", v10);
    return 0;
  }
  unsigned int v7 = sub_244D168EC((uint64_t *)(v3 + 256)) + 7;
  unint64_t v8 = v7 >> 3;
  if (a2)
  {
    if (v8 <= a3)
    {
      sub_244D16E80(a2, v7 >> 3, (char *)(v4 + 24), *(int *)(v3 + 264));
      return v8;
    }
    int v9 = 100;
    __int16 v10 = 451;
    goto LABEL_7;
  }
  return v8;
}

void sub_244D2B014(uint64_t a1, char *a2, unint64_t *a3, char *a4)
{
  unint64_t v8 = (sub_244D168EC((uint64_t *)(a1 + 256)) + 7) >> 3;
  sub_244D16E80(a2, v8, a4, *(int *)(a1 + 264));
  *a3 = v8;
}

char *sub_244D2B078(uint64_t *a1, char **a2)
{
  *a2 = 0;
  uint64_t result = (char *)sub_244D2AF5C(a1, 0, 0);
  if (result)
  {
    unint64_t v5 = (unint64_t)result;
    uint64_t result = (char *)sub_244D43FF4((unint64_t)result);
    if (result)
    {
      uint64_t v6 = result;
      uint64_t result = (char *)sub_244D2AF5C(a1, result, v5);
      if (result)
      {
        *a2 = v6;
      }
      else
      {
        sub_244D440EC(v6);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_244D2B0F0(uint64_t a1)
{
  if (!a1 || (uint64_t v2 = *(void *)a1) == 0)
  {
    int v3 = 67;
    __int16 v4 = 485;
    goto LABEL_6;
  }
  if ((int)sub_244D168EC((uint64_t *)(v2 + 256)) <= 159)
  {
    int v3 = 112;
    __int16 v4 = 491;
LABEL_6:
    sub_244D0B884(15, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", v4);
    return 0;
  }
  uint64_t v6 = (char *)sub_244D44058(0x60uLL);
  unsigned int v7 = v6;
  if (v6)
  {
    *(void *)uint64_t v6 = v6 + 24;
    *((_DWORD *)v6 + 2) = *(_DWORD *)(v2 + 264);
    *((_DWORD *)v6 + 3) = *(_DWORD *)(v2 + 264);
    *((_DWORD *)v6 + 5) = 2;
  }
  unint64_t v8 = sub_244D28B04(*(void *)a1);
  int v9 = v8;
  if (!v7
    || !v8
    || !sub_244D20A18(v7 + 24, 1uLL, *(unint64_t **)(*(void *)a1 + 256), *(int *)(*(void *)a1 + 264), (uint64_t)&unk_244EB71C8)|| !sub_244D29D74(*(void *)a1, (uint64_t)(v9 + 1), (uint64_t)(v7 + 24)))
  {
    sub_244D28BB0(v9);
    sub_244D440EC(v7);
    return 0;
  }
  sub_244D440EC(*(void **)(a1 + 16));
  *(void *)(a1 + 16) = v7;
  sub_244D28BB0(*(uint64_t **)(a1 + 8));
  *(void *)(a1 + 8) = v9;
  return 1;
}

uint64_t sub_244D2B224(uint64_t a1)
{
  if (a1 && *(void *)a1)
  {
    if (sub_244D2B0F0(a1) && sub_244D2A8B8((uint64_t *)a1))
    {
      return 1;
    }
    else
    {
      sub_244D28BB0(*(uint64_t **)(a1 + 8));
      sub_244D440EC(*(void **)(a1 + 16));
      uint64_t result = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
  }
  else
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_key.c", 525);
    return 0;
  }
  return result;
}

uint64_t sub_244D2B2AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D136D4((uint64_t)&unk_268EBD890, a1, a2, a5);
}

uint64_t sub_244D2B2C4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_244D137A8((unint64_t **)(a1 + 48), a2, a3);
}

unint64_t *sub_244D2B2CC(uint64_t a1, unsigned int a2)
{
  return sub_244D13838((uint64_t *)(a1 + 48), a2);
}

void sub_244D2B2D4(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
}

void sub_244D2B2F0(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
}

void sub_244D2B304(uint64_t a1, char *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  unsigned int v7 = (uint64_t *)(a1 + 320);
  sub_244D1A64C((unint64_t *)v9, *(int *)(a1 + 328), a4, *(int *)(a1 + 328), a1 + 296);
  unint64_t v8 = (sub_244D168EC(v7) + 7) >> 3;
  sub_244D16E80(a2, v8, (char *)v9, *(int *)(a1 + 328));
  *a3 = v8;
}

void sub_244D2B390(uint64_t a1, char *a2, unint64_t *a3, char *a4)
{
  unint64_t v8 = (sub_244D168EC((uint64_t *)(a1 + 320)) + 7) >> 3;
  sub_244D16E80(a2, v8, a4, *(int *)(a1 + 328));
  *a3 = v8;
}

uint64_t sub_244D2B3F4(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unint64_t a4)
{
  uint64_t result = sub_244D2B43C(a1, a2, a3, a4);
  if (result)
  {
    sub_244D1A72C(a2, a2, *(unint64_t **)(a1 + 296), *(int *)(a1 + 328), a1 + 296);
    return 1;
  }
  return result;
}

uint64_t sub_244D2B43C(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unint64_t a4)
{
  if ((sub_244D168EC((uint64_t *)(a1 + 320)) + 7) >> 3 != a4)
  {
    __int16 v8 = 324;
    goto LABEL_5;
  }
  sub_244D16C88(a2, *(int *)(a1 + 328), a3, a4);
  if ((sub_244D170B4((uint64_t *)a2, *(int *)(a1 + 328), *(uint64_t **)(a1 + 320), *(int *)(a1 + 328)) & 0x80000000) == 0)
  {
    __int16 v8 = 331;
LABEL_5:
    sub_244D0B884(15, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/simple.c", v8);
    return 0;
  }
  return 1;
}

void sub_244D2B4E4(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a1 + 296;
  sub_244D1A64C(a2, *(int *)(a1 + 328), a3, a4, a1 + 296);
  sub_244D1A72C(a2, a2, *(unint64_t **)(a1 + 296), *(int *)(a1 + 328), v6);
  unint64_t v7 = *(int *)(a1 + 328);
  __int16 v8 = *(unint64_t **)(a1 + 296);

  sub_244D1A72C(a2, a2, v8, v7, v6);
}

void sub_244D2B560(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
}

uint64_t sub_244D2B578(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  __int16 v4 = a3;
  if (a3 == a4)
  {
    return sub_244D2BCC4(a1, a2, a3);
  }
  else
  {
    uint64_t v100 = 0;
    memset(v99, 0, sizeof(v99));
    uint64_t v98 = 0;
    memset(v97, 0, sizeof(v97));
    uint64_t v96 = 0;
    memset(v95, 0, sizeof(v95));
    __int16 v8 = (uint64_t *)(a3 + 18);
    int v9 = *(_DWORD *)(a1 + 328);
    if (v9 <= 0)
    {
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      int v15 = a4 + 18;
    }
    else
    {
      uint64_t v10 = 0;
      __int16 v11 = (uint64_t *)(a3 + 18);
      uint64_t v12 = *(unsigned int *)(a1 + 328);
      do
      {
        uint64_t v13 = *v11++;
        v10 |= v13;
        --v12;
      }
      while (v12);
      uint64_t v14 = 0;
      int v15 = a4 + 18;
      long long v16 = (uint64_t *)(a4 + 18);
      uint64_t v17 = *(unsigned int *)(a1 + 328);
      do
      {
        uint64_t v18 = *v16++;
        v14 |= v18;
        --v17;
      }
      while (v17);
      if (v10) {
        uint64_t v19 = -1;
      }
      else {
        uint64_t v19 = 0;
      }
      if (v14) {
        uint64_t v20 = -1;
      }
      else {
        uint64_t v20 = 0;
      }
    }
    uint64_t v94 = 0;
    memset(v93, 0, sizeof(v93));
    sub_244D1A72C((unint64_t *)v93, a3 + 18, a3 + 18, v9, a1 + 296);
    uint64_t v92 = 0;
    memset(v91, 0, sizeof(v91));
    sub_244D1A72C((unint64_t *)v91, v15, v15, *(int *)(a1 + 328), a1 + 296);
    uint64_t v90 = 0;
    memset(v89, 0, sizeof(v89));
    sub_244D1A72C((unint64_t *)v89, v4, (unint64_t *)v91, *(int *)(a1 + 328), a1 + 296);
    uint64_t v88 = 0;
    memset(v87, 0, sizeof(v87));
    sub_244D295D0(a1, (unint64_t *)v87, (uint64_t *)v4 + 18, (uint64_t *)v15);
    sub_244D1A72C((unint64_t *)v87, (unint64_t *)v87, (unint64_t *)v87, *(int *)(a1 + 328), a1 + 296);
    uint64_t v105 = 0;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    sub_244D1811C((unint64_t *)v87, (unint64_t *)v87, (unint64_t *)v93, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
    uint64_t v105 = 0;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    sub_244D1811C((unint64_t *)v87, (unint64_t *)v87, (unint64_t *)v91, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
    uint64_t v86 = 0;
    memset(v85, 0, sizeof(v85));
    sub_244D1A72C((unint64_t *)v85, v15, (unint64_t *)v91, *(int *)(a1 + 328), a1 + 296);
    long long v22 = (uint64_t *)(v4 + 9);
    sub_244D1A72C((unint64_t *)v85, (unint64_t *)v85, v4 + 9, *(int *)(a1 + 328), a1 + 296);
    uint64_t v84 = 0;
    memset(v83, 0, sizeof(v83));
    sub_244D1A72C((unint64_t *)v83, a4, (unint64_t *)v93, *(int *)(a1 + 328), a1 + 296);
    uint64_t v82 = 0;
    memset(v81, 0, sizeof(v81));
    uint64_t v105 = 0;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    sub_244D1811C((unint64_t *)v81, (unint64_t *)v83, (unint64_t *)v89, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
    int v23 = *(_DWORD *)(a1 + 328);
    int v66 = a2;
    if (v23 < 1)
    {
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v24 = 0;
      unint64_t v25 = (uint64_t *)v81;
      uint64_t v26 = *(unsigned int *)(a1 + 328);
      do
      {
        uint64_t v27 = *v25++;
        v24 |= v27;
        --v26;
      }
      while (v26);
      if (v24) {
        uint64_t v28 = -1;
      }
      else {
        uint64_t v28 = 0;
      }
    }
    sub_244D1A72C((unint64_t *)v95, (unint64_t *)v81, (unint64_t *)v87, v23, a1 + 296);
    uint64_t v80 = 0;
    memset(v79, 0, sizeof(v79));
    sub_244D1A72C((unint64_t *)v79, v4 + 18, (unint64_t *)v93, *(int *)(a1 + 328), a1 + 296);
    uint64_t v78 = 0;
    memset(v77, 0, sizeof(v77));
    long long v29 = (uint64_t *)(a4 + 9);
    sub_244D1A72C((unint64_t *)v77, a4 + 9, (unint64_t *)v79, *(int *)(a1 + 328), a1 + 296);
    uint64_t v76 = 0;
    memset(v75, 0, sizeof(v75));
    uint64_t v105 = 0;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    sub_244D1811C((unint64_t *)v75, (unint64_t *)v77, (unint64_t *)v85, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
    sub_244D295D0(a1, (unint64_t *)v75, (uint64_t *)v75, (uint64_t *)v75);
    uint64_t v30 = *(unsigned int *)(a1 + 328);
    if ((int)v30 < 1)
    {
      uint64_t v34 = 0;
    }
    else
    {
      uint64_t v31 = 0;
      uint64_t v32 = (uint64_t *)v75;
      do
      {
        uint64_t v33 = *v32++;
        v31 |= v33;
        --v30;
      }
      while (v30);
      if (v31) {
        uint64_t v34 = -1;
      }
      else {
        uint64_t v34 = 0;
      }
    }
    if ((v19 & ~(v34 | v28) & v20) != 0)
    {
      return sub_244D2BCC4(a1, v66, v4);
    }
    else
    {
      uint64_t v74 = 0;
      memset(v73, 0, sizeof(v73));
      sub_244D295D0(a1, (unint64_t *)v73, (uint64_t *)v81, (uint64_t *)v81);
      sub_244D1A72C((unint64_t *)v73, (unint64_t *)v73, (unint64_t *)v73, *(int *)(a1 + 328), a1 + 296);
      uint64_t v72 = 0;
      memset(v71, 0, sizeof(v71));
      sub_244D1A72C((unint64_t *)v71, (unint64_t *)v81, (unint64_t *)v73, *(int *)(a1 + 328), a1 + 296);
      uint64_t v70 = 0;
      memset(v69, 0, sizeof(v69));
      sub_244D1A72C((unint64_t *)v69, (unint64_t *)v89, (unint64_t *)v73, *(int *)(a1 + 328), a1 + 296);
      sub_244D1A72C((unint64_t *)v99, (unint64_t *)v75, (unint64_t *)v75, *(int *)(a1 + 328), a1 + 296);
      uint64_t v105 = 0;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      sub_244D1811C((unint64_t *)v99, (unint64_t *)v99, (unint64_t *)v71, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
      uint64_t v105 = 0;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      sub_244D1811C((unint64_t *)v99, (unint64_t *)v99, (unint64_t *)v69, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
      uint64_t v105 = 0;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      sub_244D1811C((unint64_t *)v99, (unint64_t *)v99, (unint64_t *)v69, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
      uint64_t v105 = 0;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      sub_244D1811C((unint64_t *)v97, (unint64_t *)v69, (unint64_t *)v99, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
      sub_244D1A72C((unint64_t *)v97, (unint64_t *)v97, (unint64_t *)v75, *(int *)(a1 + 328), a1 + 296);
      uint64_t v68 = 0;
      memset(v67, 0, sizeof(v67));
      sub_244D1A72C((unint64_t *)v67, (unint64_t *)v85, (unint64_t *)v71, *(int *)(a1 + 328), a1 + 296);
      uint64_t v105 = 0;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      sub_244D1811C((unint64_t *)v97, (unint64_t *)v97, (unint64_t *)v67, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
      uint64_t v105 = 0;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      uint64_t result = sub_244D1811C((unint64_t *)v97, (unint64_t *)v97, (unint64_t *)v67, *(uint64_t **)(a1 + 320), (uint64_t *)&v101, *(int *)(a1 + 328));
      uint64_t v35 = *(int *)(a1 + 328);
      if (v35)
      {
        uint64_t v36 = ~v19;
        long long v37 = (uint64_t *)v99;
        uint64_t v38 = a4;
        uint64_t v39 = *(int *)(a1 + 328);
        do
        {
          uint64_t v40 = *v38++;
          *long long v37 = v40 & v36 | *v37 & v19;
          ++v37;
          --v39;
        }
        while (v39);
        uint64_t v41 = ~v20;
        int v42 = (uint64_t *)v99;
        uint64_t v43 = v66;
        do
        {
          uint64_t v45 = *v42++;
          uint64_t v44 = v45;
          unint64_t v46 = *v4++;
          *v43++ = v46 & v41 | v44 & v20;
          --v35;
        }
        while (v35);
        uint64_t v47 = *(int *)(a1 + 328);
        if (v47)
        {
          int v48 = (uint64_t *)v97;
          uint64_t v49 = *(int *)(a1 + 328);
          do
          {
            uint64_t v50 = *v29++;
            *int v48 = v50 & v36 | *v48 & v19;
            ++v48;
            --v49;
          }
          while (v49);
          uint64_t v51 = (uint64_t *)(v66 + 9);
          uint64_t v52 = (uint64_t *)v97;
          do
          {
            uint64_t v54 = *v52++;
            uint64_t v53 = v54;
            uint64_t v55 = *v22++;
            *v51++ = v55 & v41 | v53 & v20;
            --v47;
          }
          while (v47);
          uint64_t v56 = *(int *)(a1 + 328);
          if (v56)
          {
            uint64_t v57 = (uint64_t *)(a4 + 18);
            uint64_t v58 = (uint64_t *)v95;
            uint64_t v59 = *(int *)(a1 + 328);
            do
            {
              uint64_t v60 = *v57++;
              *uint64_t v58 = v60 & v36 | *v58 & v19;
              ++v58;
              --v59;
            }
            while (v59);
            uint64_t v61 = (uint64_t *)(v66 + 18);
            uint64_t v62 = (uint64_t *)v95;
            do
            {
              uint64_t v64 = *v62++;
              uint64_t v63 = v64;
              uint64_t v65 = *v8++;
              *v61++ = v65 & v41 | v63 & v20;
              --v56;
            }
            while (v56);
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_244D2BCC4(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  if (*(_DWORD *)(a1 + 528))
  {
    uint64_t v44 = 0;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v34 = 0;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    uint64_t v19 = 0;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    uint64_t v14 = 0;
    memset(v13, 0, sizeof(v13));
    uint64_t v12 = 0;
    memset(v11, 0, sizeof(v11));
    sub_244D1A72C((unint64_t *)&v40, a3 + 18, a3 + 18, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C((unint64_t *)&v35, a3 + 9, a3 + 9, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C((unint64_t *)&v30, a3, (unint64_t *)&v35, *(int *)(a1 + 328), a1 + 296);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C((unint64_t *)&v25, a3, (unint64_t *)&v40, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    sub_244D295D0(a1, (unint64_t *)&v20, (uint64_t *)a3, (uint64_t *)&v40);
    sub_244D295D0(a1, (unint64_t *)&v15, (uint64_t *)&v20, (uint64_t *)&v20);
    sub_244D295D0(a1, (unint64_t *)&v20, (uint64_t *)&v20, (uint64_t *)&v15);
    sub_244D1A72C((unint64_t *)v13, (unint64_t *)&v25, (unint64_t *)&v20, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C(a2, (unint64_t *)v13, (unint64_t *)v13, *(int *)(a1 + 328), a1 + 296);
    sub_244D295D0(a1, (unint64_t *)v11, (uint64_t *)&v30, (uint64_t *)&v30);
    sub_244D295D0(a1, (unint64_t *)v11, (uint64_t *)v11, (uint64_t *)v11);
    sub_244D295D0(a1, (unint64_t *)&v15, (uint64_t *)v11, (uint64_t *)v11);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2, a2, (unint64_t *)&v15, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    sub_244D295D0(a1, (unint64_t *)&v40, (uint64_t *)&v35, (uint64_t *)&v40);
    sub_244D295D0(a1, (unint64_t *)&v25, (uint64_t *)a3 + 9, (uint64_t *)a3 + 18);
    sub_244D1A72C(a2 + 18, (unint64_t *)&v25, (unint64_t *)&v25, *(int *)(a1 + 328), a1 + 296);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2 + 18, a2 + 18, (unint64_t *)&v40, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    uint64_t v6 = a2 + 9;
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2 + 9, (unint64_t *)v11, a2, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    sub_244D295D0(a1, (unint64_t *)&v35, (uint64_t *)&v35, (uint64_t *)&v35);
    sub_244D1A72C((unint64_t *)&v35, (unint64_t *)&v35, (unint64_t *)&v35, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C(a2 + 9, (unint64_t *)v13, a2 + 9, *(int *)(a1 + 328), a1 + 296);
    sub_244D295D0(a1, (unint64_t *)&v35, (uint64_t *)&v35, (uint64_t *)&v35);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    unint64_t v7 = *(uint64_t **)(a1 + 320);
    unint64_t v8 = *(int *)(a1 + 328);
    int v9 = (unint64_t *)&v35;
  }
  else
  {
    uint64_t v44 = 0;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v34 = 0;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    sub_244D1A72C((unint64_t *)&v40, a3, a3, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C((unint64_t *)&v35, a3 + 9, a3 + 9, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C((unint64_t *)&v30, (unint64_t *)&v35, (unint64_t *)&v35, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C((unint64_t *)&v25, a3 + 18, a3 + 18, *(int *)(a1 + 328), a1 + 296);
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    sub_244D295D0(a1, (unint64_t *)&v20, (uint64_t *)a3, (uint64_t *)&v35);
    sub_244D1A72C((unint64_t *)&v20, (unint64_t *)&v20, (unint64_t *)&v20, *(int *)(a1 + 328), a1 + 296);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C((unint64_t *)&v20, (unint64_t *)&v20, (unint64_t *)&v40, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C((unint64_t *)&v20, (unint64_t *)&v20, (unint64_t *)&v30, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    sub_244D295D0(a1, (unint64_t *)&v20, (uint64_t *)&v20, (uint64_t *)&v20);
    uint64_t v19 = 0;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    sub_244D1A72C((unint64_t *)&v15, (unint64_t *)&v25, (unint64_t *)&v25, *(int *)(a1 + 328), a1 + 296);
    sub_244D1A72C((unint64_t *)&v15, (unint64_t *)(a1 + 360), (unint64_t *)&v15, *(int *)(a1 + 328), a1 + 296);
    sub_244D295D0(a1, (unint64_t *)&v15, (uint64_t *)&v15, (uint64_t *)&v40);
    sub_244D295D0(a1, (unint64_t *)&v15, (uint64_t *)&v15, (uint64_t *)&v40);
    sub_244D295D0(a1, (unint64_t *)&v15, (uint64_t *)&v15, (uint64_t *)&v40);
    sub_244D1A72C(a2, (unint64_t *)&v15, (unint64_t *)&v15, *(int *)(a1 + 328), a1 + 296);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2, a2, (unint64_t *)&v20, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2, a2, (unint64_t *)&v20, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    sub_244D295D0(a1, a2 + 18, (uint64_t *)a3 + 9, (uint64_t *)a3 + 18);
    sub_244D1A72C(a2 + 18, a2 + 18, a2 + 18, *(int *)(a1 + 328), a1 + 296);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2 + 18, a2 + 18, (unint64_t *)&v35, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2 + 18, a2 + 18, (unint64_t *)&v25, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    sub_244D295D0(a1, (unint64_t *)&v30, (uint64_t *)&v30, (uint64_t *)&v30);
    sub_244D295D0(a1, (unint64_t *)&v30, (uint64_t *)&v30, (uint64_t *)&v30);
    sub_244D295D0(a1, (unint64_t *)&v30, (uint64_t *)&v30, (uint64_t *)&v30);
    uint64_t v6 = a2 + 9;
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    sub_244D1811C(a2 + 9, (unint64_t *)&v20, a2, *(uint64_t **)(a1 + 320), (uint64_t *)&v45, *(int *)(a1 + 328));
    sub_244D1A72C(a2 + 9, a2 + 9, (unint64_t *)&v15, *(int *)(a1 + 328), a1 + 296);
    uint64_t v49 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    unint64_t v7 = *(uint64_t **)(a1 + 320);
    unint64_t v8 = *(int *)(a1 + 328);
    int v9 = (unint64_t *)&v30;
  }
  return sub_244D1811C(v6, v6, v9, v7, (uint64_t *)&v45, v8);
}

uint64_t sub_244D2C350(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 328);
  if ((int)v2 < 1) {
    return 0;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v4 = *a2++;
    v3 |= v4;
    --v2;
  }
  while (v2);
  if (v3) {
    return -1;
  }
  else {
    return 0;
  }
}

uint64_t sub_244D2C384(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  return sub_244D1811C(a2, a3, a4, *(uint64_t **)(a1 + 320), (uint64_t *)v5, *(int *)(a1 + 328));
}

void sub_244D2C3D0()
{
  qword_268EBFFD0 = (uint64_t)sub_244D3DB7C;
  qword_268EBFFD8 = (uint64_t)sub_244D3DCC0;
  qword_268EBFFE0 = (uint64_t)sub_244D2B578;
  qword_268EBFFE8 = (uint64_t)sub_244D2BCC4;
  qword_268EBFFF0 = (uint64_t)sub_244D2D550;
  qword_268EBFFF8 = (uint64_t)sub_244D2D81C;
  qword_268EC0000 = (uint64_t)sub_244D2D828;
  qword_268EC0010 = (uint64_t)sub_244D2E2F0;
  qword_268EC0018 = (uint64_t)sub_244D2DCE4;
  qword_268EC0020 = (uint64_t)sub_244D2DE9C;
  qword_268EC0028 = (uint64_t)sub_244D2B2D4;
  qword_268EC0030 = (uint64_t)sub_244D2B2F0;
  qword_268EC0038 = (uint64_t)sub_244D2B304;
  qword_268EC0040 = (uint64_t)sub_244D2B3F4;
  qword_268EC0048 = (uint64_t)sub_244D2B4E4;
  qword_268EC0050 = (uint64_t)sub_244D2B560;
  qword_268EC0058 = (uint64_t)sub_244D2D250;
  qword_268EC0060 = (uint64_t)sub_244D2D268;
  qword_268EC0068 = (uint64_t)sub_244D3DF00;
}

uint64_t sub_244D2C50C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
}

unint64_t sub_244D2C518(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 328);
  if (v5 < 1)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v7 = a3;
    uint64_t v8 = *(unsigned int *)(a1 + 328);
    do
    {
      uint64_t v9 = *v7++;
      v6 |= v9;
      --v8;
    }
    while (v8);
    if (v6) {
      uint64_t v10 = -1;
    }
    else {
      uint64_t v10 = 0;
    }
  }
  unint64_t result = sub_244D16544(a2, *(unint64_t **)(a1 + 320), a3, v5);
  if (*(int *)(a1 + 328) >= 1)
  {
    uint64_t v12 = 0;
    do
      a2[v12++] &= v10;
    while (v12 < *(int *)(a1 + 328));
  }
  return result;
}

uint64_t sub_244D2C5B8(uint64_t a1, int a2)
{
  if (a2 == 2 || a2 == 4)
  {
    int v3 = sub_244D168EC((uint64_t *)(a1 + 320));
    if (a2 == 4) {
      uint64_t v4 = (v3 + 7) >> 3;
    }
    else {
      uint64_t v4 = 0;
    }
    return ((v3 + 7) >> 3) + v4 + 1;
  }
  else
  {
    sub_244D0B884(15, 0, 111, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", 79);
    return 0;
  }
}

unint64_t sub_244D2C62C(uint64_t a1, uint64_t a2, int a3, char *a4, unint64_t a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  unint64_t v10 = sub_244D2C5B8(a1, a3);
  if (v10 <= a5)
  {
    unint64_t v11 = v10;
    uint64_t v14 = 0;
    (*(void (**)(uint64_t, char *, uint64_t *, uint64_t))(*(void *)a1 + 104))(a1, a4 + 1, &v14, a2);
    if (a3 == 4)
    {
      (*(void (**)(uint64_t, char *, uint64_t *, uint64_t))(*(void *)a1 + 104))(a1, &a4[v14 + 1], &v14, a2 + 72);
      char v12 = 4;
    }
    else
    {
      (*(void (**)(uint64_t, unsigned char *, uint64_t *, uint64_t))(*(void *)a1 + 104))(a1, v15, &v14, a2 + 72);
      char v12 = (v15[v14 - 1] & 1) + a3;
    }
    *a4 = v12;
  }
  else
  {
    sub_244D0B884(15, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", 97);
    return 0;
  }
  return v11;
}

uint64_t sub_244D2C768(uint64_t *a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v8 = (sub_244D168EC(a1 + 40) + 7) >> 3;
  if (((2 * v8) | 1) == a4 && *a3 == 4)
  {
    uint64_t v14 = 0;
    memset(v13, 0, sizeof(v13));
    uint64_t v12 = 0;
    memset(v11, 0, sizeof(v11));
    uint64_t v9 = a3 + 1;
    uint64_t result = (*(uint64_t (**)(uint64_t *, _OWORD *, unsigned char *, uint64_t))(*a1 + 112))(a1, v13, v9, v8);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t *, _OWORD *, unsigned char *, uint64_t))(*a1 + 112))(a1, v11, &v9[v8], v8);
      if (result) {
        return sub_244D29434((uint64_t)a1, a2, (uint64_t)v13, (uint64_t)v11);
      }
    }
  }
  else
  {
    sub_244D0B884(15, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", 122);
    return 0;
  }
  return result;
}

unint64_t sub_244D2C870(uint64_t a1, uint64_t *a2, int a3, char *a4, unint64_t a5)
{
  if (sub_244D2670C(a1, *a2))
  {
    int v10 = 106;
    __int16 v11 = 215;
LABEL_3:
    sub_244D0B884(15, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", v11);
    return 0;
  }
  if (a4)
  {
    memset(v17, 0, sizeof(v17));
    if ((**(unsigned int (***)(uint64_t, uint64_t, _OWORD *, char *))a1)(a1, (uint64_t)(a2 + 1), v17, (char *)&v17[4] + 8))
    {
      return sub_244D2C62C(a1, (uint64_t)v17, a3, a4, a5);
    }
    return 0;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 328);
  if ((int)v13 < 1) {
    goto LABEL_16;
  }
  uint64_t v14 = 0;
  long long v15 = a2 + 19;
  do
  {
    uint64_t v16 = *v15++;
    v14 |= v16;
    --v13;
  }
  while (v13);
  if (!v14)
  {
LABEL_16:
    int v10 = 119;
    __int16 v11 = 222;
    goto LABEL_3;
  }

  return sub_244D2C5B8(a1, a3);
}

uint64_t sub_244D2C9B4(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, uint64_t a5)
{
  if (sub_244D2670C(a1, *a2))
  {
    int v10 = 106;
    __int16 v11 = 259;
LABEL_6:
    sub_244D0B884(15, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", v11);
    return 0;
  }
  if (*(_DWORD *)(a3 + 16) || (sub_244D17194(a3, a1 + 320) & 0x80000000) == 0)
  {
    int v10 = 107;
    __int16 v11 = 265;
    goto LABEL_6;
  }
  sub_244D0B1B0();
  if (a5)
  {
    long long v32 = 0;
  }
  else
  {
    uint64_t v14 = sub_244D43FF4(0x30uLL);
    if (!v14) {
      return 0;
    }
    a5 = (uint64_t)v14;
    *(_OWORD *)((char *)v14 + 26) = 0u;
    *uint64_t v14 = 0u;
    v14[1] = 0u;
    long long v32 = (unint64_t **)v14;
  }
  int v31 = a4 != 0;
  sub_244D1756C((void *)a5);
  long long v15 = sub_244D17610(a5);
  uint64_t v16 = sub_244D17610(a5);
  long long v17 = sub_244D17610(a5);
  long long v18 = sub_244D17610(a5);
  uint64_t v19 = sub_244D17610(a5);
  if (!v19) {
    goto LABEL_47;
  }
  uint64_t v20 = (uint64_t)v19;
  if (!sub_244D28918(a1, 0, v17, v18)
    || !sub_244D18B18((uint64_t)v16, a3, a1 + 320, a5)
    || !sub_244D1897C((uint64_t)v15, (uint64_t)v16, a3, a1 + 320, a5))
  {
    goto LABEL_47;
  }
  if (*(_DWORD *)(a1 + 528))
  {
    if (!sub_244D185B8((unint64_t **)v16, a3, a3, a1 + 320, a5)
      || !sub_244D185B8((unint64_t **)v16, (uint64_t)v16, a3, a1 + 320, a5)
      || !sub_244D18804((uint64_t)v15, (uint64_t)v15, (uint64_t)v16, a1 + 320, a5))
    {
      goto LABEL_47;
    }
  }
  else if (!sub_244D1897C((uint64_t)v16, (uint64_t)v17, a3, a1 + 320, a5) {
         || !sub_244D185B8((unint64_t **)v15, (uint64_t)v15, (uint64_t)v16, a1 + 320, a5))
  }
  {
    goto LABEL_47;
  }
  if (!sub_244D185B8((unint64_t **)v15, (uint64_t)v15, (uint64_t)v18, a1 + 320, a5)) {
    goto LABEL_47;
  }
  if (!sub_244D21068((void *)v20, (unsigned int *)v15, a1 + 320, a5))
  {
    if ((sub_244D0B138() & 0xFF000FFF) == 0x300006E)
    {
      sub_244D0B1B0();
      int v23 = 107;
      __int16 v24 = 328;
    }
    else
    {
      int v23 = 3;
      __int16 v24 = 330;
    }
    goto LABEL_46;
  }
  LODWORD(v21) = *(_DWORD *)(v20 + 8);
  if ((int)v21 < 1) {
    int v22 = 0;
  }
  else {
    int v22 = **(_DWORD **)v20 & 1;
  }
  if (v22 != v31)
  {
    if (!v21) {
      goto LABEL_41;
    }
    uint64_t v26 = 0;
    uint64_t v21 = (int)v21;
    long long v27 = *(uint64_t **)v20;
    do
    {
      uint64_t v28 = *v27++;
      v26 |= v28;
      --v21;
    }
    while (v21);
    if (!v26)
    {
LABEL_41:
      int v23 = 108;
      __int16 v24 = 337;
LABEL_46:
      sub_244D0B884(15, 0, v23, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/oct.c", v24);
      goto LABEL_47;
    }
    if (sub_244D15C60(v20, a1 + 320, v20))
    {
      LODWORD(v21) = *(_DWORD *)(v20 + 8);
      goto LABEL_32;
    }
LABEL_47:
    uint64_t v12 = 0;
    goto LABEL_48;
  }
LABEL_32:
  if ((int)v21 < 1) {
    int v25 = 0;
  }
  else {
    int v25 = **(_DWORD **)v20 & 1;
  }
  if (v25 != v31)
  {
    int v23 = 68;
    __int16 v24 = 345;
    goto LABEL_46;
  }
  uint64_t v12 = sub_244D29644(a1, (uint64_t)a2, a3, v20);
LABEL_48:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v29 = *(void *)(a5 + 8);
    uint64_t v30 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v30;
    *(void *)(a5 + 32) = *(void *)(v29 + 8 * v30);
  }
  sub_244D17500(v32);
  return v12;
}

uint64_t *sub_244D2CD74()
{
  return &qword_268EC0070;
}

void sub_244D2CDAC()
{
  qword_268EC0070 = (uint64_t)sub_244D3E0D4;
  qword_268EC0080 = (uint64_t)sub_244D3E638;
  qword_268EC0088 = (uint64_t)sub_244D3E7E8;
  qword_268EC0090 = (uint64_t)sub_244D3E900;
  qword_268EC0098 = (uint64_t)sub_244D3EBB0;
  qword_268EC00A8 = (uint64_t)sub_244D3EE14;
  qword_268EC00C8 = (uint64_t)sub_244D3F1E0;
  qword_268EC00D0 = (uint64_t)sub_244D3F2C8;
  qword_268EC00D8 = (uint64_t)sub_244D2B390;
  qword_268EC00E0 = (uint64_t)sub_244D2B43C;
  qword_268EC00F8 = (uint64_t)sub_244D2D250;
  qword_268EC0100 = (uint64_t)sub_244D2D268;
  qword_268EC0108 = (uint64_t)sub_244D2D49C;
}

uint64_t *sub_244D2CE88()
{
  return &qword_268EC0110;
}

void sub_244D2CEC0()
{
  qword_268EC0110 = (uint64_t)sub_244D40564;
  qword_268EC0120 = (uint64_t)sub_244D408D4;
  qword_268EC0128 = (uint64_t)sub_244D409AC;
  qword_268EC0130 = (uint64_t)sub_244D40A54;
  qword_268EC0138 = (uint64_t)sub_244D40F24;
  qword_268EC0148 = (uint64_t)sub_244D41150;
  qword_268EC0168 = (uint64_t)sub_244D2B2D4;
  qword_268EC0170 = (uint64_t)sub_244D2B2F0;
  qword_268EC0178 = (uint64_t)sub_244D2B304;
  qword_268EC0180 = (uint64_t)sub_244D2B3F4;
  qword_268EC0188 = (uint64_t)sub_244D2B4E4;
  qword_268EC0190 = (uint64_t)sub_244D2B560;
  qword_268EC0198 = (uint64_t)sub_244D2D250;
  qword_268EC01A0 = (uint64_t)sub_244D2D268;
  qword_268EC01A8 = (uint64_t)sub_244D41514;
}

BOOL sub_244D2CFBC(uint64_t a1, void *__s1, void *__s2)
{
  uint64_t v3 = *(int *)(a1 + 264);
  return !v3 || memcmp(__s1, __s2, 8 * v3) == 0;
}

void sub_244D2CFFC(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a1 + 232;
  sub_244D1A64C(a2, *(int *)(a1 + 264), a3, a4, a1 + 232);
  unint64_t v7 = *(int *)(a1 + 264);
  uint64_t v8 = *(unint64_t **)(a1 + 232);

  sub_244D1A72C(a2, a2, v8, v7, v6);
}

void sub_244D2D060(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
}

void sub_244D2D07C(uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  v8[9] = *MEMORY[0x263EF8340];
  int v5 = *(unint64_t **)(a1 + 256);
  unint64_t v6 = *(int *)(a1 + 264);
  uint64_t v7 = sub_244D15EB4(a2, a3, a4, v6);
  sub_244D180A8(a2, v7, v5, v8, v6);
  sub_244D4413C(v8, 0x48uLL);
}

void sub_244D2D118(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  v4[9] = *MEMORY[0x263EF8340];
  sub_244D1811C(a2, a3, a4, *(uint64_t **)(a1 + 256), v4, *(int *)(a1 + 264));
  sub_244D4413C(v4, 0x48uLL);
}

void sub_244D2D18C(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  v5[9] = *MEMORY[0x263EF8340];
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  sub_244D1811C(a2, (unint64_t *)v3, a3, *(uint64_t **)(a1 + 256), v5, *(int *)(a1 + 264));
  sub_244D4413C(v5, 0x48uLL);
}

uint64_t sub_244D2D20C(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *(int *)(result + 264);
  if (v5)
  {
    do
    {
      uint64_t v7 = *a4++;
      uint64_t v6 = v7;
      uint64_t v8 = *a5++;
      *a2++ = v8 & ~a3 | v6 & a3;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_244D2D23C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
}

void sub_244D2D250(uint64_t a1, unint64_t *a2, uint64_t a3)
{
}

uint64_t sub_244D2D268(unsigned int *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v3 = a1[66];
  if ((int)v3 < 1) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 8 * v3;
  do
  {
    v7 |= *(void *)(a3 + v6);
    v6 += 8;
  }
  while (v8 != v6);
  if (!v7) {
    return 0;
  }
  (*(void (**)(unsigned int *, unint64_t *))(*(void *)a1 + 136))(a1, a2);
  sub_244D1A64C(a2, (int)a1[66], (uint64_t)a2, (int)a1[66], (uint64_t)(a1 + 58));
  return 1;
}

uint64_t sub_244D2D2F4(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1);
}

uint64_t sub_244D2D300(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v7 = *(void (**)(uint64_t, _OWORD *, uint64_t, uint64_t *))(*(void *)a1 + 88);
  uint64_t v6 = *(void (**)(uint64_t, _OWORD *, unint64_t *))(*(void *)a1 + 96);
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v24 = 0;
  uint64_t v8 = (uint64_t *)(a3 + 18);
  memset(v23, 0, sizeof(v23));
  v6(a1, v23, a3 + 18);
  v7(a1, v25, a2, (uint64_t *)v23);
  uint64_t v31 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  sub_244D1811C((unint64_t *)v25, (unint64_t *)v25, a3, *(uint64_t **)(a1 + 320), (uint64_t *)&v27, *(int *)(a1 + 328));
  uint64_t v9 = *(unsigned int *)(a1 + 328);
  if ((int)v9 < 1)
  {
    int v13 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    __int16 v11 = (uint64_t *)v25;
    do
    {
      uint64_t v12 = *v11++;
      v10 |= v12;
      --v9;
    }
    while (v9);
    int v13 = v10 != 0;
  }
  v7(a1, v25, a2 + 72, (uint64_t *)v23);
  v7(a1, v25, (uint64_t)v25, v8);
  uint64_t v31 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  sub_244D1811C((unint64_t *)v25, (unint64_t *)v25, a3 + 9, *(uint64_t **)(a1 + 320), (uint64_t *)&v27, *(int *)(a1 + 328));
  uint64_t v14 = *(unsigned int *)(a1 + 328);
  if ((int)v14 < 1)
  {
    BOOL v21 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = (uint64_t *)v25;
    uint64_t v17 = *(unsigned int *)(a1 + 328);
    do
    {
      uint64_t v18 = *v16++;
      v15 |= v18;
      --v17;
    }
    while (v17);
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = *v8++;
      v19 |= v20;
      --v14;
    }
    while (v14);
    if (v15) {
      int v13 = -1;
    }
    BOOL v21 = v19 != 0;
  }
  return v21 & ~v13;
}

uint64_t sub_244D2D49C(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 328);
  if ((int)v3 < 1) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 8 * v3;
  do
  {
    v7 |= *(void *)(a2 + v6 + 144);
    v6 += 8;
  }
  while (v8 != v6);
  if (!v7) {
    return 0;
  }
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  uint64_t result = sub_244D2A174(a1, (unint64_t *)v11, a2);
  if (result)
  {
    uint64_t v10 = *(int *)(a1 + 264);
    return !v10 || memcmp(v11, a3, 8 * v10) == 0;
  }
  return result;
}

double sub_244D2D550()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v7 = v0;
  v32[810] = *MEMORY[0x263EF8340];
  sub_244D28B7C((uint64_t)v30);
  sub_244D28C68((uint64_t)v31, v4);
  uint64_t v8 = v32;
  for (unint64_t i = 2; i != 32; ++i)
  {
    if (i) {
      sub_244D2B578(v7, v8, v31, v8 - 27);
    }
    else {
      sub_244D2BCC4(v7, v8, &v30[27 * (i >> 1)]);
    }
    v8 += 27;
  }
  unsigned int v10 = sub_244D168EC((uint64_t *)(v7 + 256));
  if (!v10) {
    return sub_244D28B7C((uint64_t)v6);
  }
  unsigned int v12 = v10;
  unsigned int v13 = v10 - 1;
  int v14 = 1;
  unsigned int v15 = v10;
  do
  {
    unsigned int v16 = v13;
    if (!v14) {
      sub_244D2BCC4(v7, v6, v6);
    }
    if (-858993459 * v16 <= 0x33333333)
    {
      unint64_t v17 = *(int *)(v7 + 264);
      if ((unint64_t)(v15 + 3) >> 6 >= v17) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = (*(void *)(v2 + 8 * ((unint64_t)(v15 + 3) >> 6)) >> (v15 + 3)) & 1;
      }
      if ((unint64_t)(v15 + 2) >> 6 >= v17) {
        uint64_t v19 = 0;
      }
      else {
        uint64_t v19 = (*(void *)(v2 + 8 * ((unint64_t)(v15 + 2) >> 6)) >> (v15 + 2)) & 1;
      }
      if ((unint64_t)(v15 + 1) >> 6 >= v17) {
        uint64_t v20 = 0;
      }
      else {
        uint64_t v20 = (*(void *)(v2 + 8 * ((unint64_t)(v15 + 1) >> 6)) >> (v15 + 1)) & 1;
      }
      unint64_t v21 = (unint64_t)v15 >> 6;
      if (v21 >= v17) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = (*(void *)(v2 + 8 * v21) >> v15) & 1;
      }
      unint64_t v23 = (unint64_t)v16 >> 6;
      if (v23 >= v17) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = (*(void *)(v2 + 8 * v23) >> v16) & 1;
      }
      uint64_t v25 = 0;
      uint64_t v29 = 0;
      uint64_t v26 = v24 | (2 * v22) | (16 * v18) | (8 * v19) | (4 * v20);
      long long v27 = (uint64_t *)v30;
      memset(v28, 0, sizeof(v28));
      do
      {
        sub_244D29FC0(v7, (uint64_t *)v28, ((v25++ ^ v26) - 1) >> 63, v27, (uint64_t *)v28);
        v27 += 27;
      }
      while (v25 != 32);
      if (v14) {
        *(void *)&double result = sub_244D28C68((uint64_t)v6, (uint64_t)v28).n128_u64[0];
      }
      else {
        sub_244D2B578(v7, v6, v6, (unint64_t *)v28);
      }
      int v14 = 0;
    }
    unsigned int v13 = v16 - 1;
    unsigned int v15 = v16;
  }
  while (v16 - 1 < v12);
  if (v14) {
    return sub_244D28B7C((uint64_t)v6);
  }
  return result;
}

double sub_244D2D81C()
{
  return sub_244D2D550();
}

double sub_244D2D828()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v17 = v2;
  uint64_t v18 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  unsigned int v10 = v9;
  uint64_t v11 = v0;
  v23[459] = *MEMORY[0x263EF8340];
  sub_244D2DA40(v0, (uint64_t)v21, v12);
  sub_244D2DA40(v11, (uint64_t)v22, v6);
  if (v4) {
    sub_244D2DA40(v11, (uint64_t)v23, v4);
  }
  unsigned int v13 = sub_244D168EC((uint64_t *)(v11 + 256));
  char v15 = 0;
  unsigned int v16 = v13;
  do
  {
    while (1)
    {
      if (v15) {
        sub_244D2BCC4(v11, v10, v10);
      }
      if (5 * (v16 / 5) != v16) {
        break;
      }
      uint64_t v20 = 0;
      memset(v19, 0, sizeof(v19));
      sub_244D2DADC(v11, (uint64_t)v19, v21, v8, v16);
      if (v15) {
        sub_244D2B578(v11, v10, v10, (unint64_t *)v19);
      }
      else {
        sub_244D28C68((uint64_t)v10, (uint64_t)v19);
      }
      sub_244D2DADC(v11, (uint64_t)v19, v22, v18, v16);
      sub_244D2B578(v11, v10, v10, (unint64_t *)v19);
      if (v4)
      {
        sub_244D2DADC(v11, (uint64_t)v19, v23, v17, v16);
        sub_244D2B578(v11, v10, v10, (unint64_t *)v19);
      }
      --v16;
      char v15 = 1;
      if (v16 > v13) {
        return result;
      }
    }
    --v16;
  }
  while (v16 <= v13);
  if ((v15 & 1) == 0) {
    return sub_244D28B7C((uint64_t)v10);
  }
  return result;
}

uint64_t sub_244D2DA40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_244D28B7C(a2);
  sub_244D28C68(a2 + 216, a3);
  uint64_t v6 = (unint64_t *)(a2 + 432);
  for (unint64_t i = 2; i != 17; ++i)
  {
    if (i) {
      uint64_t result = sub_244D2B578(a1, v6, (unint64_t *)(a2 + 216), v6 - 27);
    }
    else {
      uint64_t result = sub_244D2BCC4(a1, v6, (unint64_t *)(a2 + 216 * (i >> 1)));
    }
    v6 += 27;
  }
  return result;
}

unint64_t sub_244D2DADC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int a5)
{
  unint64_t v8 = *(int *)(a1 + 264);
  if ((unint64_t)(a5 + 4) >> 6 >= v8) {
    int v9 = 0;
  }
  else {
    int v9 = 32 * ((*(void *)(a4 + 8 * ((unint64_t)(a5 + 4) >> 6)) >> (a5 + 4)) & 1);
  }
  if ((unint64_t)(a5 + 3) >> 6 >= v8) {
    int v10 = 0;
  }
  else {
    int v10 = 16 * ((*(void *)(a4 + 8 * ((unint64_t)(a5 + 3) >> 6)) >> (a5 + 3)) & 1);
  }
  int v11 = v10 | v9;
  if ((unint64_t)(a5 + 2) >> 6 >= v8) {
    int v12 = 0;
  }
  else {
    int v12 = 8 * ((*(void *)(a4 + 8 * ((unint64_t)(a5 + 2) >> 6)) >> (a5 + 2)) & 1);
  }
  int v13 = v11 | v12;
  if ((unint64_t)(a5 + 1) >> 6 >= v8) {
    int v14 = 0;
  }
  else {
    int v14 = 4 * ((*(void *)(a4 + 8 * ((unint64_t)(a5 + 1) >> 6)) >> (a5 + 1)) & 1);
  }
  int v15 = v13 | v14;
  unint64_t v16 = (unint64_t)a5 >> 6;
  if (v16 >= v8) {
    int v17 = 0;
  }
  else {
    int v17 = 2 * ((*(void *)(a4 + 8 * v16) >> a5) & 1);
  }
  unsigned int v18 = v15 | v17;
  if (a5)
  {
    if ((unint64_t)(a5 - 1) >> 6 >= v8) {
      LODWORD(v19) = 0;
    }
    else {
      uint64_t v19 = (*(void *)(a4 + 8 * ((unint64_t)(a5 - 1) >> 6)) >> (a5 - 1)) & 1;
    }
    v18 |= v19;
  }
  uint64_t v20 = 0;
  *(void *)(a2 + 208) = 0;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  uint64_t v21 = -(uint64_t)((unint64_t)v18 >> 5);
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  unint64_t v22 = ((v18 >> 5) - 1) & v18 | (v18 ^ 0x3FLL) & v21;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  unint64_t v23 = (v22 & 1) + (v22 >> 1);
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  do
  {
    sub_244D29FC0(a1, (uint64_t *)a2, (uint64_t)((v20++ ^ v23) - 1) >> 63, a3, (uint64_t *)a2);
    a3 += 27;
  }
  while (v20 != 17);
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  uint64_t v24 = (unint64_t *)(a2 + 72);
  unint64_t result = sub_244D2C518(a1, (unint64_t *)v29, v24);
  uint64_t v26 = *(int *)(a1 + 328);
  if (v26)
  {
    long long v27 = (uint64_t *)v29;
    do
    {
      uint64_t v28 = *v27++;
      *uint64_t v24 = *v24 & ~v21 | v28 & v21;
      ++v24;
      --v26;
    }
    while (v26);
  }
  return result;
}

uint64_t sub_244D2DCE4()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v23 = *MEMORY[0x263EF8340];
  unsigned int v4 = sub_244D168EC((uint64_t *)(v0 + 320)) + 4;
  long long v5 = *(_OWORD *)(v2 + 176);
  unsigned int v6 = v4 / 5;
  v21[10] = *(_OWORD *)(v2 + 160);
  v21[11] = v5;
  v21[12] = *(_OWORD *)(v2 + 192);
  uint64_t v22 = *(void *)(v2 + 208);
  long long v7 = *(_OWORD *)(v2 + 112);
  v21[6] = *(_OWORD *)(v2 + 96);
  v21[7] = v7;
  long long v8 = *(_OWORD *)(v2 + 144);
  void v21[8] = *(_OWORD *)(v2 + 128);
  v21[9] = v8;
  long long v9 = *(_OWORD *)(v2 + 48);
  _OWORD v21[2] = *(_OWORD *)(v2 + 32);
  v21[3] = v9;
  long long v10 = *(_OWORD *)(v2 + 80);
  v21[4] = *(_OWORD *)(v2 + 64);
  v21[5] = v10;
  if (v4 / 5 <= 2) {
    unsigned int v6 = 2;
  }
  unsigned int v11 = v6 - 1;
  long long v12 = *(_OWORD *)(v2 + 16);
  int v13 = 1;
  v21[0] = *(_OWORD *)v2;
  v21[1] = v12;
  do
  {
    unsigned int v14 = 1 << v13;
    sub_244D2BCC4(v3, (unint64_t *)&v21[-13] + 27 * v14 - 1, (unint64_t *)&v21[-13] + 27 * (v14 >> 1) - 1);
    unsigned int v15 = v11;
    if (v4 >= 0xA)
    {
      do
      {
        sub_244D2BCC4(v3, (unint64_t *)&v21[-13] + 27 * v14 - 1, (unint64_t *)&v21[-13] + 27 * v14 - 1);
        --v15;
      }
      while (v15);
    }
    uint64_t v16 = 0;
    if (v14 <= 2) {
      unsigned int v17 = 2;
    }
    else {
      unsigned int v17 = 1 << v13;
    }
    unsigned int v18 = (char *)v21 + 216 * v14;
    uint64_t v19 = 216 * v17 - 216;
    do
    {
      sub_244D2B578(v3, (unint64_t *)&v18[v16], (unint64_t *)v21 + 27 * ((1 << v13) - 1), (unint64_t *)((char *)v21 + v16));
      v16 += 216;
    }
    while (v19 != v16);
    ++v13;
  }
  while (v13 != 5);
  return sub_244D293DC(v3);
}

void sub_244D2DE9C(uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  unsigned int v16 = sub_244D168EC((uint64_t *)(a1 + 320)) + 4;
  if (v16 >= 5)
  {
    char v17 = 0;
    unsigned int v18 = v16 / 5;
    unsigned int v19 = v16 / 5 - 1;
    while ((v17 & 1) == 0)
    {
      uint64_t v33 = 0;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v20 = 0u;
      sub_244D2E084(a1, (uint64_t)&v20, a3, a4, v19);
      sub_244D28C68((uint64_t)a2, (uint64_t)&v20);
      if (a5) {
        goto LABEL_10;
      }
LABEL_11:
      if (a7)
      {
        sub_244D2E084(a1, (uint64_t)&v20, a7, a8, v19);
        sub_244D2B578(a1, a2, a2, (unint64_t *)&v20);
      }
      --v19;
      char v17 = 1;
      if (v19 >= v18) {
        return;
      }
    }
    sub_244D2BCC4(a1, a2, a2);
    uint64_t v33 = 0;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    sub_244D2E084(a1, (uint64_t)&v20, a3, a4, v19);
    sub_244D2B578(a1, a2, a2, (unint64_t *)&v20);
    if (!a5) {
      goto LABEL_11;
    }
LABEL_10:
    sub_244D2E084(a1, (uint64_t)&v20, a5, a6, v19);
    sub_244D2B578(a1, a2, a2, (unint64_t *)&v20);
    goto LABEL_11;
  }

  sub_244D28B7C((uint64_t)a2);
}

uint64_t sub_244D2E084(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int a5)
{
  unint64_t v10 = *(int *)(a1 + 264);
  uint64_t result = sub_244D168EC((uint64_t *)(a1 + 320));
  uint64_t v12 = 0;
  LODWORD(v13) = 0;
  unint64_t v14 = a5;
  do
  {
    if (v14 >> 6 >= v10) {
      LODWORD(v15) = 0;
    }
    else {
      uint64_t v15 = (*(void *)(a4 + 8 * (v14 >> 6)) >> v14) & 1;
    }
    uint64_t v13 = (v15 << v12++) | v13;
    v14 += (result + 4) / 5uLL;
  }
  while (v12 != 5);
  uint64_t v16 = 0;
  *(void *)(a2 + 208) = 0;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  do
  {
    ++v16;
    uint64_t v17 = *(int *)(a1 + 328);
    if (v17)
    {
      uint64_t v18 = ((v13 ^ v16) - 1) >> 63;
      uint64_t v19 = ~v18;
      long long v20 = a3;
      long long v21 = (uint64_t *)a2;
      do
      {
        uint64_t v22 = *v20++;
        *long long v21 = *v21 & v19 | v22 & v18;
        ++v21;
        --v17;
      }
      while (v17);
      uint64_t v23 = *(int *)(a1 + 328);
      if (v23)
      {
        for (uint64_t i = 0; i != v23; ++i)
          *(void *)(a2 + 72 + 8 * i) = *(void *)(a2 + 72 + 8 * i) & v19 | a3[i + 9] & v18;
      }
    }
    a3 += 18;
  }
  while (v16 != 31);
  uint64_t v25 = *(int *)(a1 + 328);
  if (v25)
  {
    long long v26 = (uint64_t *)(a2 + 144);
    long long v27 = (uint64_t *)(a1 + 160);
    uint64_t v28 = (v13 - 1) >> 63;
    do
    {
      uint64_t v29 = *v27++;
      *long long v26 = v29 & ~v28 | *v26 & v28;
      ++v26;
      --v25;
    }
    while (v25);
  }
  return result;
}

uint64_t *sub_244D2E214(uint64_t *result, void *a2, unint64_t a3)
{
  unint64_t v3 = ((a3 >> 5) - 1) & a3 | (63 - a3) & -(uint64_t)(a3 >> 5);
  *uint64_t result = -(uint64_t)(a3 >> 5) & 1;
  *a2 = (v3 & 1) + (v3 >> 1);
  return result;
}

uint64_t sub_244D2E24C(uint64_t result, unsigned char *a2, _DWORD *a3, unint64_t a4, int a5)
{
  if (a4 != -1)
  {
    int v5 = ((2 << a5) - 1) & *a3;
    unint64_t v6 = a4 + 1;
    unint64_t v7 = a5 + 1;
    do
    {
      int v8 = v5 - (2 << a5);
      if (v7 >= a4) {
        int v8 = v5 & (((2 << a5) - 1) >> 1);
      }
      if ((v5 & (1 << a5)) == 0) {
        int v8 = v5;
      }
      if (v5) {
        v5 -= v8;
      }
      else {
        LOBYTE(v8) = 0;
      }
      *a2 = v8;
      if (v7 >> 6 >= *(int *)(result + 264)) {
        LODWORD(v9) = 0;
      }
      else {
        uint64_t v9 = (*(void *)&a3[2 * (v7 >> 6)] >> v7) & 1;
      }
      int v5 = (v9 << a5) + (v5 >> 1);
      ++a2;
      ++v7;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_244D2E2F0()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  unint64_t v2 = v1;
  unsigned int v4 = v3;
  unint64_t v6 = v5;
  int v8 = v7;
  unint64_t v10 = v9;
  uint64_t v11 = v0;
  *(void *)&v36[1587] = *MEMORY[0x263EF8340];
  LODWORD(v12) = sub_244D168EC((uint64_t *)(v0 + 256));
  if (v2 >= 4)
  {
    uint64_t v13 = sub_244D44098(v2, 0x211uLL);
    uint64_t v15 = sub_244D44098(v2, 0x6C0uLL);
    unint64_t v14 = v15;
    uint64_t v16 = 0;
    if (!v13) {
      goto LABEL_29;
    }
    uint64_t v29 = (char *)v15;
    long long v30 = v13;
    if (!v15) {
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v29 = &v35;
    long long v30 = v36;
  }
  long long v26 = v14;
  long long v27 = v13;
  unint64_t v12 = (int)v12;
  if (v8)
  {
    sub_244D2E24C(v11, v34, v8, (int)v12, 4);
    sub_244D2E5B0(v11, (uint64_t)v33, (unint64_t *)(v11 + 16));
  }
  uint64_t v28 = v8;
  if (v2)
  {
    uint64_t v17 = (uint64_t)v29;
    uint64_t v18 = v30;
    unint64_t v19 = v2;
    do
    {
      sub_244D2E24C(v11, v18, v4, (int)v12, 4);
      sub_244D2E5B0(v11, v17, v6);
      v6 += 27;
      v17 += 1728;
      v4 += 18;
      v18 += 529;
      --v19;
    }
    while (v19);
  }
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  if (v12 == -1) {
    goto LABEL_27;
  }
  unint64_t v20 = (int)v12 + 1;
  int v21 = 1;
  do
  {
    if (!v21) {
      sub_244D2BCC4(v11, v10, v10);
    }
    if (v28 && v34[v12])
    {
      sub_244D2E64C(v11, (uint64_t)v31, (uint64_t)v33, (char)v34[v12]);
      if (v21)
      {
        sub_244D28C68((uint64_t)v10, (uint64_t)v31);
        int v21 = 0;
      }
      else
      {
        sub_244D2B578(v11, v10, v10, (unint64_t *)v31);
      }
    }
    uint64_t v23 = (uint64_t)v29;
    uint64_t v22 = v30;
    for (unint64_t i = v2; i; --i)
    {
      if (v22[v12])
      {
        sub_244D2E64C(v11, (uint64_t)v31, v23, (char)v22[v12]);
        if (v21)
        {
          sub_244D28C68((uint64_t)v10, (uint64_t)v31);
          int v21 = 0;
        }
        else
        {
          sub_244D2B578(v11, v10, v10, (unint64_t *)v31);
        }
      }
      v22 += 529;
      v23 += 1728;
    }
    --v12;
  }
  while (v12 < v20);
  if (v21) {
LABEL_27:
  }
    sub_244D28B7C((uint64_t)v10);
  uint64_t v16 = 1;
  unint64_t v14 = v26;
  uint64_t v13 = v27;
LABEL_29:
  sub_244D440EC(v13);
  sub_244D440EC(v14);
  return v16;
}

uint64_t sub_244D2E5B0(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  sub_244D28C68(a2, (uint64_t)a3);
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  sub_244D2BCC4(a1, (unint64_t *)v8, a3);
  for (uint64_t i = 0; i != 1512; i += 216)
    uint64_t result = sub_244D2B578(a1, (unint64_t *)(a2 + i + 216), (unint64_t *)(a2 + i), (unint64_t *)v8);
  return result;
}

void sub_244D2E64C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if ((a4 & 0x80000000) != 0)
  {
    sub_244D28C68(a2, a3 + 216 * (-a4 >> 1));
    sub_244D2C518(a1, (unint64_t *)(a2 + 72), (unint64_t *)(a2 + 72));
  }
  else
  {
    sub_244D28C68(a2, a3 + 216 * (a4 >> 1));
  }
}

uint64_t sub_244D2E6D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  unint64_t v14 = 0;
  uint64_t result = sub_244D2E778((uint64_t)v15, &v14, a3, a4, a5, a6, a7);
  if (result) {
    return sub_244D2E7F8(a1, a2, a3, (uint64_t)v15, v14, a8, a9) != 0;
  }
  return result;
}

uint64_t sub_244D2E778(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  unsigned int v9 = 0;
  if (sub_244D2E9F4(a3, a6, a7, a4, a5, a1, &v9))
  {
    *a2 = v9;
    return 1;
  }
  else
  {
    sub_244D0B884(31, 0, 28, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/hkdf/hkdf.c", 51);
    return 0;
  }
}

uint64_t sub_244D2E7F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  size_t v7 = *(unsigned int *)(a3 + 4);
  size_t v8 = v7 + a2;
  if (__CFADD__(v7, a2) || (v9 = v8 - 1, unint64_t v10 = (v8 - 1) / v7, v10 >= 0x100))
  {
    int v23 = 100;
    __int16 v24 = 73;
  }
  else
  {
    uint64_t v27 = 0;
    memset(v26, 0, sizeof(v26));
    sub_244D2EAD0((uint64_t)v26);
    if (sub_244D2EAF4((uint64_t)v26, a4, a5, a3))
    {
      if (v9 < v7)
      {
LABEL_16:
        sub_244D2EDC0(v26);
        return 1;
      }
      uint64_t v18 = 0;
      unsigned int v19 = 1;
      while (1)
      {
        char v25 = v19;
        if (v19 != 1)
        {
          if (!sub_244D2EAF4((uint64_t)v26, 0, 0, 0)) {
            break;
          }
          (*(void (**)(char *, unsigned char *, size_t))(*((void *)&v26[0] + 1) + 24))((char *)v26 + 8, __src, v7);
        }
        (*(void (**)(char *, uint64_t, uint64_t))(*((void *)&v26[0] + 1) + 24))((char *)v26 + 8, a6, a7);
        (*(void (**)(char *, char *, uint64_t))(*((void *)&v26[0] + 1) + 24))((char *)v26 + 8, &v25, 1);
        if (!sub_244D2ECF4((uint64_t)v26, (uint64_t)__src, 0)) {
          break;
        }
        if (a2 - v18 >= v7) {
          size_t v20 = v7;
        }
        else {
          size_t v20 = a2 - v18;
        }
        if (v20) {
          memcpy((void *)(a1 + v18), __src, v20);
        }
        v18 += v20;
        if (v10 <= v19++) {
          goto LABEL_16;
        }
      }
    }
    sub_244D2EDC0(v26);
    int v23 = 28;
    __int16 v24 = 109;
  }
  sub_244D0B884(31, 0, v23, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/hkdf/hkdf.c", v24);
  return 0;
}

uint64_t sub_244D2E9F4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  sub_244D2EAD0((uint64_t)v16);
  if (sub_244D2EAF4((uint64_t)v16, a2, a3, a1))
  {
    (*(void (**)(char *, uint64_t, uint64_t))(*((void *)&v16[0] + 1) + 24))((char *)v16 + 8, a4, a5);
    int v14 = sub_244D2ECF4((uint64_t)v16, a6, a7);
    sub_244D2EDC0(v16);
    if (v14) {
      return a6;
    }
    else {
      return 0;
    }
  }
  else
  {
    sub_244D2EDC0(v16);
    return 0;
  }
}

double sub_244D2EAD0(uint64_t a1)
{
  *(void *)a1 = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return result;
}

uint64_t sub_244D2EAF4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = a3;
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a4) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = *(void *)a1;
  }
  if (!a2 && v7 == *(void *)a1) {
    return sub_244D25750((void *)(a1 + 8), (uint64_t *)(a1 + 40));
  }
  unint64_t v8 = *(unsigned int *)(v7 + 40);
  if (v8 >= a3)
  {
    if (a3) {
      __memcpy_chk();
    }
  }
  else
  {
    if (!sub_244D258CC(a1 + 8, v7)) {
      return 0;
    }
    (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(a1 + 8) + 24))(a1 + 8, a2, v4);
    (*(void (**)(uint64_t, unsigned char *))(*(void *)(a1 + 8) + 32))(a1 + 8, v19);
    uint64_t v9 = *(void *)(a1 + 8);
    LODWORD(v4) = *(_DWORD *)(v9 + 4);
    sub_244D4413C(*(void **)(a1 + 16), *(unsigned int *)(v9 + 44));
  }
  if (v8 != v4) {
    bzero(&v19[v4], v8 - v4);
  }
  if (v8)
  {
    unint64_t v10 = v20;
    uint64_t v11 = v19;
    unint64_t v12 = v8;
    do
    {
      char v13 = *v11++;
      *v10++ = v13 ^ 0x36;
      --v12;
    }
    while (v12);
  }
  if (sub_244D258CC(a1 + 40, v7))
  {
    (*(void (**)(uint64_t, unsigned char *, unint64_t))(*(void *)(a1 + 40) + 24))(a1 + 40, v20, v8);
    if (v8)
    {
      int v14 = v20;
      uint64_t v15 = v19;
      unint64_t v16 = v8;
      do
      {
        char v17 = *v15++;
        *v14++ = v17 ^ 0x5C;
        --v16;
      }
      while (v16);
    }
    if (sub_244D258CC(a1 + 72, v7))
    {
      (*(void (**)(uint64_t, unsigned char *, unint64_t))(*(void *)(a1 + 72) + 24))(a1 + 72, v20, v8);
      *(void *)a1 = v7;
      return sub_244D25750((void *)(a1 + 8), (uint64_t *)(a1 + 40));
    }
  }
  return 0;
}

uint64_t sub_244D2ECD0(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D2ECF4(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = (void **)(a1 + 8);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)(a1 + 8) + 32))(a1 + 8, v8);
  uint64_t v6 = *((unsigned int *)*v5 + 1);
  sub_244D4413C(v5[1], *((unsigned int *)*v5 + 11));
  uint64_t result = sub_244D25750(v5, (uint64_t *)v5 + 8);
  if (result)
  {
    (*((void (**)(void **, unsigned char *, uint64_t))*v5 + 3))(v5, v8, v6);
    sub_244D25960(v5, a2, a3);
    return 1;
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void sub_244D2EDC0(void *a1)
{
  sub_244D25650((uint64_t)a1 + 40);
  sub_244D25650((uint64_t)a1 + 72);
  sub_244D25650((uint64_t)a1 + 8);

  sub_244D4413C(a1, 0x68uLL);
}

void *sub_244D2EE10()
{
  uint64_t v0 = sub_244D43FF4(0x68uLL);
  unint64_t v1 = v0;
  if (v0) {
    sub_244D2EAD0((uint64_t)v0);
  }
  return v1;
}

void sub_244D2EE48(uint64_t a1)
{
  sub_244D4413C(*(void **)(a1 + 48), *(unsigned int *)(*(void *)(a1 + 40) + 44));
  sub_244D25650(a1 + 40);
  sub_244D4413C(*(void **)(a1 + 80), *(unsigned int *)(*(void *)(a1 + 72) + 44));
  sub_244D25650(a1 + 72);
  sub_244D4413C(*(void **)(a1 + 16), *(unsigned int *)(*(void *)(a1 + 8) + 44));
  sub_244D25650(a1 + 8);

  sub_244D4413C((void *)a1, 0x68uLL);
}

void sub_244D2EED4(void *a1)
{
  if (a1)
  {
    sub_244D2EDC0(a1);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D2EF14(void *a1, void *a2)
{
  uint64_t result = sub_244D25750(a1 + 5, a2 + 5);
  if (result)
  {
    uint64_t result = sub_244D25750(a1 + 9, a2 + 9);
    if (result)
    {
      uint64_t result = sub_244D25750(a1 + 1, a2 + 1);
      if (result)
      {
        *a1 = *a2;
        return 1;
      }
    }
  }
  return result;
}

double sub_244D2EF74(void *a1)
{
  sub_244D2EDC0(a1);

  return sub_244D2EAD0((uint64_t)a1);
}

uint64_t sub_244D2EFAC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a2 && a4) {
    sub_244D2EAD0(a1);
  }

  return sub_244D2EAF4(a1, a2, a3, a4);
}

uint64_t sub_244D2F010(void *a1, void *a2)
{
  sub_244D2EAD0((uint64_t)a1);

  return sub_244D2EF14(a1, a2);
}

_DWORD *sub_244D2F050(char *__src, size_t __n, _DWORD *a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  memset(v6, 0, 76);
  long long v5 = xmmword_244EB6ED0;
  sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D2F25C, (uint64_t)&v5, (char *)v6 + 8, (_DWORD *)&v6[4] + 2, (_DWORD *)v6 + 1, v6, __src, __n);
  sub_244D2F170(a3, (unint64_t)&v5);
  return a3;
}

uint64_t sub_244D2F104(_OWORD *a1)
{
  *(_OWORD *)((char *)a1 + 76) = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = xmmword_244EB6ED0;
  return 1;
}

uint64_t sub_244D2F128(uint64_t a1, char *__src, size_t __n)
{
  return 1;
}

uint64_t sub_244D2F170(_DWORD *a1, unint64_t a2)
{
  unint64_t v4 = a2 + 24;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(unsigned int *)(a2 + 88);
  *(unsigned char *)(a2 + 24 + v6) = 0x80;
  uint64_t v7 = v6 + 1;
  if (v6 >= 0x38)
  {
    if (v6 != 63) {
      bzero((void *)(v4 + v7), 63 - v6);
    }
    sub_244D2F25C(a2, (_DWORD *)v4, 1);
    uint64_t v7 = 0;
    goto LABEL_6;
  }
  if (v6 != 55) {
LABEL_6:
  }
    bzero((void *)(v4 + v7), 56 - v7);
  *(void *)(a2 + 80) = v5;
  sub_244D2F25C(a2, (_DWORD *)v4, 1);
  *(_DWORD *)(a2 + 88) = 0;
  *(_OWORD *)unint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *a1 = *(_DWORD *)a2;
  a1[1] = *(_DWORD *)(a2 + 4);
  a1[2] = *(_DWORD *)(a2 + 8);
  a1[3] = *(_DWORD *)(a2 + 12);
  return 1;
}

unint64_t sub_244D2F254(unint64_t a1, _DWORD *a2)
{
  return sub_244D2F25C(a1, a2, 1);
}

unint64_t sub_244D2F25C(unint64_t result, _DWORD *a2, uint64_t a3)
{
  unint64_t v183 = (_DWORD *)result;
  if (a3)
  {
    int v4 = *(_DWORD *)(result + 8);
    int v3 = *(_DWORD *)(result + 12);
    int v6 = *(_DWORD *)result;
    int v5 = *(_DWORD *)(result + 4);
    do
    {
      uint64_t v184 = a3;
      int v7 = a2[1];
      int v9 = __ROR4__((v4 & v5 | v3 & ~v5) + v6 + *a2, 29);
      int v8 = v4 & ~v9;
      int v10 = v5 & v9;
      HIDWORD(v12) = (v4 & v5 | v3 & ~v5) + v6 + *a2;
      LODWORD(v12) = HIDWORD(v12);
      int v11 = v12 >> 29;
      int v14 = a2[2];
      int v13 = a2[3];
      HIDWORD(v12) = v7 + v3 + (v10 | v8);
      LODWORD(v12) = HIDWORD(v12);
      int v15 = v12 >> 25;
      LODWORD(v12) = v14 + v4 + (v11 & __ROR4__(HIDWORD(v12), 25) | v5 & ~__ROR4__(HIDWORD(v12), 25));
      HIDWORD(v12) = v12;
      int v16 = v12 >> 21;
      LODWORD(v12) = v13 + v5 + (v15 & __ROR4__(v12, 21) | v11 & ~__ROR4__(v12, 21));
      HIDWORD(v12) = v12;
      int v17 = v12 >> 13;
      int v19 = a2[4];
      int v18 = a2[5];
      LODWORD(v12) = v19 + v11 + (v16 & __ROR4__(v12, 13) | v15 & ~__ROR4__(v12, 13));
      HIDWORD(v12) = v12;
      int v20 = v12 >> 29;
      int v21 = v15 + v18 + (v17 & __ROR4__(v12, 29) | v16 & ~__ROR4__(v12, 29));
      int v22 = a2[6];
      int v23 = a2[7];
      unint64_t v25 = __PAIR64__(v21, __ROR4__(v21, 25));
      int v24 = v20 & v25;
      LODWORD(v25) = v21;
      int v26 = v25 >> 25;
      HIDWORD(v25) = v16 + v22 + (v24 | v17 & ~__ROR4__(v21, 25));
      LODWORD(v25) = HIDWORD(v25);
      int v27 = v25 >> 21;
      LODWORD(v25) = v17 + v23 + (v26 & __ROR4__(HIDWORD(v25), 21) | v20 & ~__ROR4__(HIDWORD(v25), 21));
      HIDWORD(v25) = v25;
      int v28 = v25 >> 13;
      int v30 = a2[8];
      int v29 = a2[9];
      int v31 = v20 + v30 + (v27 & __ROR4__(v25, 13) | v26 & ~__ROR4__(v25, 13));
      unint64_t v33 = __PAIR64__(v31, __ROR4__(v31, 29));
      int v32 = v28 & v33;
      LODWORD(v33) = v31;
      int v34 = v33 >> 29;
      int v35 = v26 + v29 + (v32 | v27 & ~__ROR4__(v31, 29));
      int v37 = a2[10];
      int v36 = a2[11];
      HIDWORD(v33) = v35;
      LODWORD(v33) = v35;
      int v38 = v33 >> 25;
      LODWORD(v33) = v27 + v37 + (v34 & __ROR4__(v35, 25) | v28 & ~__ROR4__(v35, 25));
      HIDWORD(v33) = v33;
      int v39 = v33 >> 21;
      LODWORD(v33) = v28 + v36 + (v38 & __ROR4__(v33, 21) | v34 & ~__ROR4__(v33, 21));
      HIDWORD(v33) = v33;
      int v40 = v33 >> 13;
      int v42 = a2[12];
      int v41 = a2[13];
      LODWORD(v33) = v34 + v42 + (v39 & __ROR4__(v33, 13) | v38 & ~__ROR4__(v33, 13));
      HIDWORD(v33) = v33;
      int v43 = v33 >> 29;
      int v44 = v38 + v41 + (v40 & __ROR4__(v33, 29) | v39 & ~__ROR4__(v33, 29));
      int v46 = a2[14];
      int v45 = a2[15];
      int v47 = v39 + v46 + (v43 & __ROR4__(v44, 25) | v40 & ~__ROR4__(v44, 25));
      HIDWORD(v33) = v47;
      LODWORD(v33) = v47;
      int v48 = v33 >> 21;
      unint64_t v50 = __PAIR64__(v44, __ROR4__(v44, 25));
      int v49 = v48 & v50;
      unsigned int v51 = v40 + v45 + (v48 & v50 | v43 & ~__ROR4__(v47, 21));
      LODWORD(v50) = v44;
      int v52 = v50 >> 25;
      unint64_t v53 = __PAIR64__(v51, __ROR4__(v51, 13));
      int v54 = (v48 | __ROR4__(v44, 25)) & v53 | v49;
      LODWORD(v53) = v51;
      int v55 = v53 >> 13;
      unsigned int v56 = *a2 + 1518500249 + v43 + v54;
      int v57 = v19 + 1518500249 + v52;
      unint64_t v58 = __PAIR64__(v56, __ROR4__(v56, 29));
      int v59 = (v55 | __ROR4__(v47, 21)) & v58 | v55 & __ROR4__(v47, 21);
      LODWORD(v58) = v56;
      int v60 = v58 >> 29;
      unsigned int v61 = v57 + v59;
      unint64_t v62 = __PAIR64__(v61, __ROR4__(v61, 27));
      int v63 = (v60 | __ROR4__(v51, 13)) & v62 | v60 & __ROR4__(v51, 13);
      LODWORD(v62) = v61;
      int v64 = v62 >> 27;
      unsigned int v65 = v30 + 1518500249 + v48 + v63;
      int v66 = v42 + 1518500249 + v55;
      unint64_t v67 = __PAIR64__(v65, __ROR4__(v65, 23));
      int v68 = (v64 | __ROR4__(v56, 29)) & v67 | v64 & __ROR4__(v56, 29);
      LODWORD(v67) = v65;
      int v69 = v67 >> 23;
      unsigned int v70 = v66 + v68;
      unint64_t v71 = __PAIR64__(v70, __ROR4__(v70, 19));
      int v72 = (v69 | __ROR4__(v61, 27)) & v71 | v69 & __ROR4__(v61, 27);
      int v73 = v7 + 1518500249 + v60;
      LODWORD(v71) = v70;
      int v74 = v71 >> 19;
      unsigned int v75 = v73 + v72;
      int v76 = v18 + 1518500249 + v64;
      unint64_t v77 = __PAIR64__(v75, __ROR4__(v75, 29));
      int v78 = (v74 | __ROR4__(v65, 23)) & v77 | v74 & __ROR4__(v65, 23);
      LODWORD(v77) = v75;
      int v79 = v77 >> 29;
      unsigned int v80 = v76 + v78;
      unint64_t v81 = __PAIR64__(v80, __ROR4__(v80, 27));
      int v82 = (v79 | __ROR4__(v70, 19)) & v81 | v79 & __ROR4__(v70, 19);
      int v83 = v29 + 1518500249 + v69;
      LODWORD(v81) = v80;
      int v84 = v81 >> 27;
      unsigned int v85 = v83 + v82;
      int v86 = v41 + 1518500249 + v74;
      unint64_t v87 = __PAIR64__(v85, __ROR4__(v85, 23));
      int v88 = (v84 | __ROR4__(v75, 29)) & v87 | v84 & __ROR4__(v75, 29);
      LODWORD(v87) = v85;
      int v89 = v87 >> 23;
      unsigned int v90 = v86 + v88;
      unint64_t v91 = __PAIR64__(v90, __ROR4__(v90, 19));
      int v92 = (v89 | __ROR4__(v80, 27)) & v91 | v89 & __ROR4__(v80, 27);
      int v93 = v14 + 1518500249 + v79;
      LODWORD(v91) = v90;
      int v94 = v91 >> 19;
      unsigned int v95 = v93 + v92;
      int v96 = v22 + 1518500249 + v84;
      unint64_t v97 = __PAIR64__(v95, __ROR4__(v95, 29));
      int v98 = (v94 | __ROR4__(v85, 23)) & v97 | v94 & __ROR4__(v85, 23);
      LODWORD(v97) = v95;
      int v99 = v97 >> 29;
      unsigned int v100 = v96 + v98;
      unint64_t v101 = __PAIR64__(v100, __ROR4__(v100, 27));
      int v102 = (v99 | __ROR4__(v90, 19)) & v101 | v99 & __ROR4__(v90, 19);
      int v103 = v37 + 1518500249 + v89;
      LODWORD(v101) = v100;
      int v104 = v101 >> 27;
      unsigned int v105 = v103 + v102;
      int v106 = v46 + 1518500249 + v94;
      unint64_t v107 = __PAIR64__(v105, __ROR4__(v105, 23));
      int v108 = (v104 | __ROR4__(v95, 29)) & v107 | v104 & __ROR4__(v95, 29);
      LODWORD(v107) = v105;
      int v109 = v107 >> 23;
      unsigned int v110 = v106 + v108;
      unint64_t v111 = __PAIR64__(v110, __ROR4__(v110, 19));
      int v112 = (v109 | __ROR4__(v100, 27)) & v111 | v109 & __ROR4__(v100, 27);
      int v113 = v13 + 1518500249 + v99;
      LODWORD(v111) = v110;
      int v114 = v111 >> 19;
      unsigned int v115 = v113 + v112;
      int v116 = v23 + 1518500249 + v104;
      unint64_t v117 = __PAIR64__(v115, __ROR4__(v115, 29));
      int v118 = (v114 | __ROR4__(v105, 23)) & v117 | v114 & __ROR4__(v105, 23);
      LODWORD(v117) = v115;
      int v119 = v117 >> 29;
      unsigned int v120 = v116 + v118;
      unint64_t v121 = __PAIR64__(v120, __ROR4__(v120, 27));
      int v122 = (v119 | __ROR4__(v110, 19)) & v121 | v119 & __ROR4__(v110, 19);
      int v123 = v36 + 1518500249 + v109;
      LODWORD(v121) = v120;
      int v124 = v121 >> 27;
      unsigned int v125 = v123 + v122;
      int v126 = v45 + 1518500249 + v114 + ((v124 | __ROR4__(v115, 29)) & __ROR4__(v125, 23) | v124 & __ROR4__(v115, 29));
      HIDWORD(v121) = v126;
      LODWORD(v121) = v126;
      int v127 = v121 >> 19;
      int v128 = *a2 + 1859775393 + v119;
      int v129 = v127 ^ __ROR4__(v125, 23);
      int v130 = v128 + (v129 ^ __ROR4__(v120, 27));
      unint64_t v131 = __PAIR64__(v125, __ROR4__(v130, 29));
      unsigned int v132 = v30 + 1859775393 + v124 + (v129 ^ v131);
      LODWORD(v131) = v125;
      int v133 = v19 + 1859775393 + (v131 >> 23);
      HIDWORD(v131) = v130;
      LODWORD(v131) = v130;
      int v134 = v131 >> 29;
      unint64_t v135 = __PAIR64__(v132, __ROR4__(v132, 23));
      unsigned int v136 = v133 + (v134 ^ __ROR4__(v126, 19) ^ v135);
      int v137 = v14 + 1859775393 + v134;
      LODWORD(v135) = v132;
      int v138 = v135 >> 23;
      unint64_t v139 = __PAIR64__(v136, __ROR4__(v136, 21));
      unsigned int v140 = v42 + 1859775393 + v127 + (v138 ^ __ROR4__(v130, 29) ^ v139);
      LODWORD(v139) = v136;
      int v141 = v139 >> 21;
      unint64_t v142 = __PAIR64__(v140, __ROR4__(v140, 17));
      unsigned int v143 = v137 + (v141 ^ __ROR4__(v132, 23) ^ v142);
      int v144 = v37 + 1859775393 + v138;
      LODWORD(v142) = v140;
      int v145 = v142 >> 17;
      unint64_t v146 = __PAIR64__(v143, __ROR4__(v143, 29));
      unsigned int v147 = v144 + (v145 ^ __ROR4__(v136, 21) ^ v146);
      int v148 = v22 + 1859775393 + v141;
      LODWORD(v146) = v143;
      int v149 = v146 >> 29;
      unint64_t v150 = __PAIR64__(v147, __ROR4__(v147, 23));
      unsigned int v151 = v148 + (v149 ^ __ROR4__(v140, 17) ^ v150);
      LODWORD(v150) = v147;
      int v152 = v150 >> 23;
      unint64_t v153 = __PAIR64__(v151, __ROR4__(v151, 21));
      unsigned int v154 = v46 + 1859775393 + v145 + (v152 ^ __ROR4__(v143, 29) ^ v153);
      int v155 = v7 + 1859775393 + v149;
      LODWORD(v153) = v151;
      int v156 = v153 >> 21;
      unint64_t v157 = __PAIR64__(v154, __ROR4__(v154, 17));
      unsigned int v158 = v155 + (v156 ^ __ROR4__(v147, 23) ^ v157);
      int v159 = v18 + 1859775393 + v156;
      LODWORD(v157) = v154;
      int v160 = v157 >> 17;
      unint64_t v161 = __PAIR64__(v158, __ROR4__(v158, 29));
      unsigned int v162 = v29 + 1859775393 + v152 + (v160 ^ __ROR4__(v151, 21) ^ v161);
      LODWORD(v161) = v158;
      int v163 = v161 >> 29;
      unint64_t v164 = __PAIR64__(v162, __ROR4__(v162, 23));
      unsigned int v165 = v159 + (v163 ^ __ROR4__(v154, 17) ^ v164);
      int v166 = v41 + 1859775393 + v160;
      LODWORD(v164) = v162;
      int v167 = v164 >> 23;
      unint64_t v168 = __PAIR64__(v165, __ROR4__(v165, 21));
      unsigned int v169 = v166 + (v167 ^ __ROR4__(v158, 29) ^ v168);
      int v170 = v13 + 1859775393 + v163;
      LODWORD(v168) = v165;
      uint64_t result = (v168 >> 21);
      unint64_t v171 = __PAIR64__(v169, __ROR4__(v169, 17));
      unsigned int v172 = v170 + (result ^ __ROR4__(v162, 23) ^ v171);
      int v173 = v36 + 1859775393 + v167;
      LODWORD(v171) = v169;
      int v174 = v171 >> 17;
      unint64_t v175 = __PAIR64__(v172, __ROR4__(v172, 29));
      unsigned int v176 = v173 + (v174 ^ __ROR4__(v165, 21) ^ v175);
      LODWORD(v175) = v172;
      int v177 = v175 >> 29;
      unint64_t v178 = __PAIR64__(v176, __ROR4__(v176, 23));
      unsigned int v179 = v23 + 1859775393 + result + (v177 ^ __ROR4__(v169, 17) ^ v178);
      LODWORD(v178) = v176;
      int v180 = v178 >> 23;
      unint64_t v181 = __PAIR64__(v179, __ROR4__(v179, 21));
      int v182 = v45 + 1859775393 + v174 + (v180 ^ __ROR4__(v172, 29) ^ v181);
      LODWORD(v181) = v179;
      v6 += v177;
      v4 += v181 >> 21;
      v3 += v180;
      HIDWORD(v181) = v182;
      LODWORD(v181) = v182;
      v5 += v181 >> 17;
      *unint64_t v183 = v6;
      v183[1] = v5;
      v183[2] = v4;
      v183[3] = v3;
      a2 += 16;
      a3 = v184 - 1;
    }
    while (v184 != 1);
  }
  return result;
}

uint64_t (*sub_244D2F804(uint64_t (*result)(uint64_t, char *, uint64_t), uint64_t a2, char *__dst, _DWORD *a4, _DWORD *a5, _DWORD *a6, char *__src, size_t __n))(uint64_t, char *, uint64_t)
{
  if (__n)
  {
    size_t v8 = __n;
    int v9 = __src;
    int v13 = result;
    int v14 = *a6 + 8 * __n;
    *a5 += __CFADD__(*a6, 8 * __n) + (__n >> 29);
    *a6 = v14;
    uint64_t v15 = *a4;
    if (v15)
    {
      if (__n <= 0x3F && v15 + __n < 0x40)
      {
        uint64_t result = (uint64_t (*)(uint64_t, char *, uint64_t))memcpy(&__dst[v15], __src, __n);
        *a4 += v8;
        return result;
      }
      uint64_t v16 = 64 - v15;
      if (v15 != 64) {
        memcpy(&__dst[v15], __src, 64 - v15);
      }
      uint64_t result = (uint64_t (*)(uint64_t, char *, uint64_t))v13(a2, __dst, 1);
      v9 += v16;
      v8 -= v16;
      *a4 = 0;
      *((_OWORD *)__dst + 2) = 0u;
      *((_OWORD *)__dst + 3) = 0u;
      *(_OWORD *)__dst = 0u;
      *((_OWORD *)__dst + 1) = 0u;
    }
    if (v8 >= 0x40)
    {
      uint64_t result = (uint64_t (*)(uint64_t, char *, uint64_t))v13(a2, v9, v8 >> 6);
      v9 += v8 & 0xFFFFFFFFFFFFFFC0;
      v8 &= 0x3Fu;
    }
    if (v8)
    {
      *a4 = v8;
      return (uint64_t (*)(uint64_t, char *, uint64_t))memcpy(__dst, v9, v8);
    }
  }
  return result;
}

_DWORD *sub_244D2F954(char *__src, size_t __n, _DWORD *a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  memset(v6, 0, 76);
  long long v5 = xmmword_244EB6ED0;
  sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D2FB3C, (uint64_t)&v5, (char *)v6 + 8, (_DWORD *)&v6[4] + 2, (_DWORD *)v6 + 1, v6, __src, __n);
  sub_244D2FA50(a3, (unint64_t)&v5);
  return a3;
}

uint64_t sub_244D2FA08(uint64_t a1, char *__src, size_t __n)
{
  return 1;
}

uint64_t sub_244D2FA50(_DWORD *a1, unint64_t a2)
{
  unint64_t v4 = a2 + 24;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(unsigned int *)(a2 + 88);
  *(unsigned char *)(a2 + 24 + v6) = 0x80;
  uint64_t v7 = v6 + 1;
  if (v6 >= 0x38)
  {
    if (v6 != 63) {
      bzero((void *)(v4 + v7), 63 - v6);
    }
    sub_244D2FB3C(a2, (_DWORD *)v4, 1);
    uint64_t v7 = 0;
    goto LABEL_6;
  }
  if (v6 != 55) {
LABEL_6:
  }
    bzero((void *)(v4 + v7), 56 - v7);
  *(void *)(a2 + 80) = v5;
  sub_244D2FB3C(a2, (_DWORD *)v4, 1);
  *(_DWORD *)(a2 + 88) = 0;
  *(_OWORD *)unint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *a1 = *(_DWORD *)a2;
  a1[1] = *(_DWORD *)(a2 + 4);
  a1[2] = *(_DWORD *)(a2 + 8);
  a1[3] = *(_DWORD *)(a2 + 12);
  return 1;
}

unint64_t sub_244D2FB34(unint64_t a1, _DWORD *a2)
{
  return sub_244D2FB3C(a1, a2, 1);
}

unint64_t sub_244D2FB3C(unint64_t result, _DWORD *a2, uint64_t a3)
{
  unsigned int v85 = (_DWORD *)result;
  if (a3)
  {
    int v4 = *(_DWORD *)(result + 8);
    int v3 = *(_DWORD *)(result + 12);
    int v5 = *(_DWORD *)result;
    int v6 = *(_DWORD *)(result + 4);
    do
    {
      int v7 = a2[1];
      HIDWORD(v8) = v5 + (v4 & v6 | v3 & ~v6) - 680876936 + *a2;
      LODWORD(v8) = HIDWORD(v8);
      int v9 = (v8 >> 25) + v6;
      HIDWORD(v8) = v3 + v7 - 389564586 + (v6 & v9 | v4 & ~v9);
      LODWORD(v8) = HIDWORD(v8);
      int v10 = (v8 >> 20) + v9;
      uint64_t result = a2[2];
      int v11 = a2[3];
      HIDWORD(v8) = v4 + result + 606105819 + (v9 & v10 | v6 & ~v10);
      LODWORD(v8) = HIDWORD(v8);
      int v12 = (v8 >> 15) + v10;
      HIDWORD(v8) = v6 + v11 - 1044525330 + (v10 & v12 | v9 & ~v12);
      LODWORD(v8) = HIDWORD(v8);
      int v13 = (v8 >> 10) + v12;
      int v14 = a2[4];
      int v15 = a2[5];
      HIDWORD(v8) = v14 + v9 - 176418897 + (v12 & v13 | v10 & ~v13);
      LODWORD(v8) = HIDWORD(v8);
      int v16 = (v8 >> 25) + v13;
      HIDWORD(v8) = v15 + v10 + 1200080426 + (v13 & v16 | v12 & ~v16);
      LODWORD(v8) = HIDWORD(v8);
      int v17 = (v8 >> 20) + v16;
      int v19 = a2[6];
      int v18 = a2[7];
      HIDWORD(v8) = v19 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17);
      LODWORD(v8) = HIDWORD(v8);
      int v20 = (v8 >> 15) + v17;
      HIDWORD(v8) = v18 + v13 - 45705983 + (v17 & v20 | v16 & ~v20);
      LODWORD(v8) = HIDWORD(v8);
      int v21 = (v8 >> 10) + v20;
      int v23 = a2[8];
      int v22 = a2[9];
      HIDWORD(v8) = v23 + v16 + 1770035416 + (v20 & v21 | v17 & ~v21);
      LODWORD(v8) = HIDWORD(v8);
      int v24 = (v8 >> 25) + v21;
      HIDWORD(v8) = v22 + v17 - 1958414417 + (v21 & v24 | v20 & ~v24);
      LODWORD(v8) = HIDWORD(v8);
      int v25 = (v8 >> 20) + v24;
      int v26 = a2[10];
      int v27 = a2[11];
      HIDWORD(v8) = v26 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
      LODWORD(v8) = HIDWORD(v8);
      int v28 = (v8 >> 15) + v25;
      HIDWORD(v8) = v27 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
      LODWORD(v8) = HIDWORD(v8);
      int v29 = (v8 >> 10) + v28;
      int v31 = a2[12];
      int v30 = a2[13];
      HIDWORD(v8) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
      LODWORD(v8) = HIDWORD(v8);
      int v32 = (v8 >> 25) + v29;
      HIDWORD(v8) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
      LODWORD(v8) = HIDWORD(v8);
      int v33 = (v8 >> 20) + v32;
      int v35 = a2[14];
      int v34 = a2[15];
      HIDWORD(v8) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
      LODWORD(v8) = HIDWORD(v8);
      int v36 = (v8 >> 15) + v33;
      HIDWORD(v8) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
      LODWORD(v8) = HIDWORD(v8);
      int v37 = (v8 >> 10) + v36;
      HIDWORD(v8) = v7 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
      LODWORD(v8) = HIDWORD(v8);
      int v38 = (v8 >> 27) + v37;
      HIDWORD(v8) = v19 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
      LODWORD(v8) = HIDWORD(v8);
      int v39 = (v8 >> 23) + v38;
      HIDWORD(v8) = v27 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
      LODWORD(v8) = HIDWORD(v8);
      int v40 = (v8 >> 18) + v39;
      HIDWORD(v8) = *a2 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
      LODWORD(v8) = HIDWORD(v8);
      int v41 = (v8 >> 12) + v40;
      HIDWORD(v8) = v15 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
      LODWORD(v8) = HIDWORD(v8);
      int v42 = (v8 >> 27) + v41;
      HIDWORD(v8) = v26 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
      LODWORD(v8) = HIDWORD(v8);
      int v43 = (v8 >> 23) + v42;
      HIDWORD(v8) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
      LODWORD(v8) = HIDWORD(v8);
      int v44 = (v8 >> 18) + v43;
      HIDWORD(v8) = v14 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
      LODWORD(v8) = HIDWORD(v8);
      int v45 = (v8 >> 12) + v44;
      HIDWORD(v8) = v22 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
      LODWORD(v8) = HIDWORD(v8);
      int v46 = (v8 >> 27) + v45;
      HIDWORD(v8) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
      LODWORD(v8) = HIDWORD(v8);
      int v47 = (v8 >> 23) + v46;
      HIDWORD(v8) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
      LODWORD(v8) = HIDWORD(v8);
      int v48 = (v8 >> 18) + v47;
      HIDWORD(v8) = v23 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
      LODWORD(v8) = HIDWORD(v8);
      int v49 = (v8 >> 12) + v48;
      HIDWORD(v8) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
      LODWORD(v8) = HIDWORD(v8);
      int v50 = (v8 >> 27) + v49;
      HIDWORD(v8) = result + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
      LODWORD(v8) = HIDWORD(v8);
      int v51 = (v8 >> 23) + v50;
      HIDWORD(v8) = v18 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
      LODWORD(v8) = HIDWORD(v8);
      int v52 = (v8 >> 18) + v51;
      HIDWORD(v8) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
      LODWORD(v8) = HIDWORD(v8);
      int v53 = (v8 >> 12) + v52;
      HIDWORD(v8) = v15 + v50 - 378558 + (v52 ^ v51 ^ v53);
      LODWORD(v8) = HIDWORD(v8);
      int v54 = (v8 >> 28) + v53;
      HIDWORD(v8) = v23 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
      LODWORD(v8) = HIDWORD(v8);
      int v55 = (v8 >> 21) + v54;
      HIDWORD(v8) = v27 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
      LODWORD(v8) = HIDWORD(v8);
      int v56 = (v8 >> 16) + v55;
      HIDWORD(v8) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
      LODWORD(v8) = HIDWORD(v8);
      int v57 = (v8 >> 9) + v56;
      HIDWORD(v8) = v7 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
      LODWORD(v8) = HIDWORD(v8);
      int v58 = (v8 >> 28) + v57;
      HIDWORD(v8) = v14 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
      LODWORD(v8) = HIDWORD(v8);
      int v59 = (v8 >> 21) + v58;
      HIDWORD(v8) = v18 + v56 - 155497632 + (v58 ^ v57 ^ v59);
      LODWORD(v8) = HIDWORD(v8);
      int v60 = (v8 >> 16) + v59;
      HIDWORD(v8) = v26 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
      LODWORD(v8) = HIDWORD(v8);
      int v61 = (v8 >> 9) + v60;
      HIDWORD(v8) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
      LODWORD(v8) = HIDWORD(v8);
      int v62 = (v8 >> 28) + v61;
      HIDWORD(v8) = *a2 + v59 - 358537222 + (v61 ^ v60 ^ v62);
      LODWORD(v8) = HIDWORD(v8);
      int v63 = (v8 >> 21) + v62;
      HIDWORD(v8) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
      LODWORD(v8) = HIDWORD(v8);
      int v64 = (v8 >> 16) + v63;
      HIDWORD(v8) = v19 + v61 + 76029189 + (v63 ^ v62 ^ v64);
      LODWORD(v8) = HIDWORD(v8);
      int v65 = (v8 >> 9) + v64;
      HIDWORD(v8) = v22 + v62 - 640364487 + (v64 ^ v63 ^ v65);
      LODWORD(v8) = HIDWORD(v8);
      int v66 = (v8 >> 28) + v65;
      HIDWORD(v8) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
      LODWORD(v8) = HIDWORD(v8);
      int v67 = (v8 >> 21) + v66;
      HIDWORD(v8) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
      LODWORD(v8) = HIDWORD(v8);
      int v68 = (v8 >> 16) + v67;
      HIDWORD(v8) = result + v65 - 995338651 + (v67 ^ v66 ^ v68);
      LODWORD(v8) = HIDWORD(v8);
      int v69 = (v8 >> 9) + v68;
      HIDWORD(v8) = *a2 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
      LODWORD(v8) = HIDWORD(v8);
      int v70 = (v8 >> 26) + v69;
      HIDWORD(v8) = v18 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
      LODWORD(v8) = HIDWORD(v8);
      int v71 = (v8 >> 22) + v70;
      HIDWORD(v8) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
      LODWORD(v8) = HIDWORD(v8);
      int v72 = (v8 >> 17) + v71;
      HIDWORD(v8) = v15 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
      LODWORD(v8) = HIDWORD(v8);
      int v73 = (v8 >> 11) + v72;
      HIDWORD(v8) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
      LODWORD(v8) = HIDWORD(v8);
      int v74 = (v8 >> 26) + v73;
      HIDWORD(v8) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
      LODWORD(v8) = HIDWORD(v8);
      int v75 = (v8 >> 22) + v74;
      HIDWORD(v8) = v26 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
      LODWORD(v8) = HIDWORD(v8);
      int v76 = (v8 >> 17) + v75;
      HIDWORD(v8) = v7 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
      LODWORD(v8) = HIDWORD(v8);
      int v77 = (v8 >> 11) + v76;
      HIDWORD(v8) = v23 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
      LODWORD(v8) = HIDWORD(v8);
      int v78 = (v8 >> 26) + v77;
      HIDWORD(v8) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
      LODWORD(v8) = HIDWORD(v8);
      int v79 = (v8 >> 22) + v78;
      HIDWORD(v8) = v19 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
      LODWORD(v8) = HIDWORD(v8);
      int v80 = (v8 >> 17) + v79;
      HIDWORD(v8) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
      LODWORD(v8) = HIDWORD(v8);
      int v81 = (v8 >> 11) + v80;
      HIDWORD(v8) = v14 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
      LODWORD(v8) = HIDWORD(v8);
      int v82 = (v8 >> 26) + v81;
      HIDWORD(v8) = v27 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
      LODWORD(v8) = HIDWORD(v8);
      int v83 = (v8 >> 22) + v82;
      HIDWORD(v8) = result + v80 + 718787259 + ((v83 | ~v81) ^ v82);
      LODWORD(v8) = HIDWORD(v8);
      int v84 = (v8 >> 17) + v83;
      v5 += v82;
      HIDWORD(v8) = v22 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
      LODWORD(v8) = HIDWORD(v8);
      v6 += v84 + (v8 >> 11);
      v4 += v84;
      v3 += v83;
      *unsigned int v85 = v5;
      v85[1] = v6;
      v85[2] = v4;
      v85[3] = v3;
      a2 += 16;
      --a3;
    }
    while (a3);
  }
  return result;
}

int8x16_t sub_244D30550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, void (*a8)(uint64_t, uint64_t, uint64_t))
{
  if (a3)
  {
    for (unint64_t i = 0; i != a3; ++i)
    {
      int v26 = 1 << (i & 7 ^ 7);
      int v16 = (const char *)a5;
      int8x16_t v17 = vld1q_dup_s8(v16++);
      int8x16_t v25 = v17;
      char v18 = (v26 & *(unsigned char *)(a1 + (i >> 3))) != 0;
      v17.i64[0] = *(void *)v16;
      v17.i32[2] = *(_DWORD *)(a5 + 9);
      v17.i16[6] = *(_WORD *)(a5 + 13);
      v17.i8[14] = *(unsigned char *)(a5 + 15);
      int8x16_t v24 = v17;
      a8(a5, a5, a4);
      char v19 = *(unsigned char *)a5 ^ (v18 << 7);
      __int8 v20 = v18 << 7;
      if (a7) {
        __int8 v20 = *(unsigned char *)a5 ^ (v18 << 7);
      }
      uint8x16_t v21 = (uint8x16_t)v24;
      int8x16_t v22 = vextq_s8(v25, v24, 0xFuLL);
      v21.i8[15] = v20;
      int8x16_t result = vorrq_s8(vaddq_s8(v22, v22), (int8x16_t)vshrq_n_u8(vshrq_n_u8(v21, 1uLL), 6uLL));
      *(int8x16_t *)a5 = result;
      *(unsigned char *)(a2 + (i >> 3)) = *(unsigned char *)(a2 + (i >> 3)) & ~(_BYTE)v26 | ((v19 & 0x80) >> (i & 7));
    }
  }
  return result;
}

uint64_t sub_244D3068C(uint64_t result, unsigned char *a2, uint64_t a3, uint64_t a4, long long *a5, uint64_t a6, int a7, uint64_t (*a8)(long long *, long long *, uint64_t))
{
  if (a3)
  {
    uint64_t v12 = a3;
    int v14 = (char *)result;
    do
    {
      long long v18 = *a5;
      int8x16_t result = a8(a5, a5, a4);
      char v16 = *v14++;
      char v15 = v16;
      char v17 = *(unsigned char *)a5 ^ v16;
      if (a7) {
        char v15 = v17;
      }
      *a2++ = v17;
      *(void *)a5 = *(void *)((char *)&v18 + 1);
      *(void *)((char *)a5 + 7) = *((void *)&v18 + 1);
      *((unsigned char *)a5 + 15) = v15;
      --v12;
    }
    while (v12);
  }
  return result;
}

int8x16_t (**sub_244D30768(int8x16_t (**result)(int8x16_t *a1, uint64_t *a2), int8x16_t (**a2)(int8x16_t *a1, uint64_t *a2, int8x16_t *a3, unint64_t a4), unint64_t *a3, _DWORD *a4, unint64_t *a5))(int8x16_t *a1, uint64_t *a2)
{
  *a4 = 0;
  uint64_t v5 = bswap64(*a5);
  *((void *)&v7 + 1) = v5;
  *(void *)&long long v7 = bswap64(a5[1]);
  uint64_t v6 = v7 >> 63;
  *((void *)&v7 + 1) = v7;
  *(void *)&long long v7 = v5;
  *a3 = (v5 >> 63) & 0xC200000000000000 ^ v6;
  a3[1] = v7 >> 63;
  *int8x16_t result = sub_244D307DC;
  *a2 = sub_244D30858;
  return result;
}

unint64_t *sub_244D307B4(unint64_t *result, void *a2)
{
  unint64_t v2 = a2[1];
  result[1] = v2;
  *((void *)&v4 + 1) = *a2;
  *(void *)&long long v4 = v2;
  uint64_t v3 = v4 >> 63;
  *((void *)&v4 + 1) = v2;
  *(void *)&long long v4 = *a2;
  *int8x16_t result = ((uint64_t)*a2 >> 63) & 0xC200000000000000 ^ v3;
  result[1] = v4 >> 63;
  return result;
}

int8x16_t sub_244D307DC(int8x16_t *a1, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int8x16_t v3 = vrev64q_s8(*a1);
  int8x16_t v6 = vextq_s8(v3, v3, 8uLL);
  sub_244D31570(v6.i64, a2);
  int8x16_t v4 = vrev64q_s8(v6);
  int8x16_t result = vextq_s8(v4, v4, 8uLL);
  *a1 = result;
  return result;
}

int8x16_t sub_244D30858(int8x16_t *a1, uint64_t *a2, int8x16_t *a3, unint64_t a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  int8x16_t v5 = vrev64q_s8(*a1);
  int8x16_t v12 = vextq_s8(v5, v5, 8uLL);
  if (a4 >= 0x10)
  {
    for (unint64_t i = a4; i > 0xF; i -= 16)
    {
      int8x16_t v9 = *a3++;
      int8x16_t v10 = vrev64q_s8(v9);
      int8x16_t v12 = veorq_s8(v12, vextq_s8(v10, v10, 8uLL));
      sub_244D31570(v12.i64, a2);
    }
    int8x16_t v5 = vextq_s8(v12, v12, 8uLL);
  }
  int8x16_t result = vrev64q_s8(v5);
  *a1 = result;
  return result;
}

uint64_t sub_244D30918(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  int8x16_t v4 = a3;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  if (a4 != 12)
  {
    if (a4 < 0x10)
    {
      unint64_t i = a4;
      if (!a4)
      {
LABEL_12:
        *(void *)(a1 + 8) ^= bswap64(8 * a4);
        sub_244D307DC((int8x16_t *)a1, (uint64_t *)(a1 + 80));
        unsigned int v8 = bswap32(*(_DWORD *)(a1 + 12)) + 1;
        goto LABEL_13;
      }
    }
    else
    {
      for (unint64_t i = a4; i > 0xF; i -= 16)
      {
        uint64_t v11 = *(void *)(a1 + 8);
        *(void *)a1 ^= *v4;
        *(void *)(a1 + 8) = v4[1] ^ v11;
        sub_244D307DC((int8x16_t *)a1, (uint64_t *)(a1 + 80));
        v4 += 2;
      }
      if (!i) {
        goto LABEL_12;
      }
    }
    uint64_t v12 = 0;
    do
    {
      *(unsigned char *)(a1 + v12) ^= *((unsigned char *)v4 + v12);
      ++v12;
    }
    while (i != v12);
    sub_244D307DC((int8x16_t *)a1, (uint64_t *)(a1 + 80));
    goto LABEL_12;
  }
  uint64_t v7 = *a3;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a3 + 2);
  *(void *)a1 = v7;
  *(unsigned char *)(a1 + 15) = 1;
  unsigned int v8 = 2;
LABEL_13:
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 352))(a1, a1 + 32, a2);
  *(_DWORD *)(a1 + 12) = bswap32(v8);
  return result;
}

uint64_t sub_244D30A58(int8x16_t *a1, int8x16_t *a2, uint64_t a3)
{
  if (a1[3].i64[1]) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = a1[3].i64[0];
  BOOL v6 = __CFADD__(v5, a3);
  unint64_t v7 = v5 + a3;
  char v8 = v6;
  if (v7 <= 0x2000000000000000 && (v8 & 1) == 0)
  {
    a1[3].i64[0] = v7;
    unsigned int v10 = a1[23].u32[1];
    if (v10)
    {
      if (!a3) {
        goto LABEL_22;
      }
      do
      {
        __int8 v11 = a2->i8[0];
        a2 = (int8x16_t *)((char *)a2 + 1);
        a1[4].i8[v10] ^= v11;
        uint64_t v12 = a3 - 1;
        unsigned int v10 = ((_BYTE)v10 + 1) & 0xF;
        if (!v10) {
          break;
        }
        --a3;
      }
      while (a3);
      if (v10) {
        goto LABEL_22;
      }
      sub_244D307DC(a1 + 4, a1[5].i64);
    }
    else
    {
      uint64_t v12 = a3;
    }
    if ((v12 & 0xFFFFFFFFFFFFFFF0) != 0)
    {
      sub_244D30858(a1 + 4, a1[5].i64, a2, v12 & 0xFFFFFFFFFFFFFFF0);
      a2 = (int8x16_t *)((char *)a2 + (v12 & 0xFFFFFFFFFFFFFFF0));
      v12 &= 0xFu;
    }
    if (v12)
    {
      uint64_t v13 = a1 + 4;
      uint64_t v14 = v12;
      do
      {
        __int8 v15 = a2->i8[0];
        a2 = (int8x16_t *)((char *)a2 + 1);
        v13->i8[0] ^= v15;
        uint64_t v13 = (int8x16_t *)((char *)v13 + 1);
        --v14;
      }
      while (v14);
      unsigned int v10 = v12;
    }
    else
    {
      unsigned int v10 = 0;
    }
LABEL_22:
    a1[23].i32[1] = v10;
    return 1;
  }
  return result;
}

uint64_t sub_244D30B68(int8x16_t *a1, uint64_t a2, char *a3, int8x16_t *a4, unint64_t a5, int8x16_t a6)
{
  uint64_t result = 0;
  uint64_t v8 = a1[3].i64[1];
  BOOL v9 = __CFADD__(v8, a5);
  unint64_t v10 = v8 + a5;
  char v11 = v9;
  if (v10 <= 0xFFFFFFFE0 && (v11 & 1) == 0)
  {
    unint64_t v12 = a5;
    i64 = a1[5].i64;
    char v17 = (void (*)(int8x16_t *, int8x16_t *, uint64_t, __n128))a1[22].i64[0];
    a1[3].i64[1] = v10;
    if (a1[23].i32[1])
    {
      a6 = sub_244D307DC(a1 + 4, a1[5].i64);
      a1[23].i32[1] = 0;
    }
    LODWORD(v18) = a1[23].i32[0];
    if (v18)
    {
      if (!v12) {
        goto LABEL_28;
      }
      do
      {
        char v19 = *a3++;
        __int8 v20 = &a1->i8[v18];
        __int8 v21 = v20[16] ^ v19;
        a4->i8[0] = v21;
        a4 = (int8x16_t *)((char *)a4 + 1);
        v20[64] ^= v21;
        unint64_t v22 = v12 - 1;
        LODWORD(v18) = ((_BYTE)v18 + 1) & 0xF;
        if (!v18) {
          break;
        }
        --v12;
      }
      while (v12);
      if (v18)
      {
LABEL_28:
        a1[23].i32[0] = v18;
        return 1;
      }
      a6 = sub_244D307DC(a1 + 4, a1[5].i64);
    }
    else
    {
      unint64_t v22 = v12;
    }
    unsigned int v23 = bswap32(a1->u32[3]);
    if (v22 >= 0xC00)
    {
      do
      {
        unint64_t v29 = v22;
        uint64_t v24 = -3072;
        do
        {
          int8x16_t v25 = &a4[(unint64_t)v24 / 0x10];
          v17(a1, a1 + 1, a2, (__n128)a6);
          a1->i32[3] = bswap32(++v23);
          v25[192].i64[0] = a1[1].i64[0] ^ *(void *)&a3[v24 + 3072];
          v25[192].i64[1] = a1[1].i64[1] ^ *(void *)&a3[v24 + 3080];
          v24 += 16;
        }
        while (v24);
        a6 = sub_244D30858(a1 + 4, a1[5].i64, a4, 0xC00uLL);
        v22 -= 3072;
        a4 += 192;
        a3 += 3072;
      }
      while (v29 - 3072 > 0xBFF);
      i64 = a1[5].i64;
    }
    unint64_t v26 = v22 & 0xFF0;
    if ((v22 & 0xFF0) != 0)
    {
      do
      {
        v17(a1, a1 + 1, a2, (__n128)a6);
        a1->i32[3] = bswap32(++v23);
        a4->i64[0] = a1[1].i64[0] ^ *(void *)a3;
        a4->i64[1] = a1[1].i64[1] ^ *((void *)a3 + 1);
        ++a4;
        a3 += 16;
        v22 -= 16;
      }
      while (v22 > 0xF);
      a6 = sub_244D30858(a1 + 4, i64, (int8x16_t *)((char *)a4 - v26), v26);
    }
    if (v22)
    {
      v17(a1, a1 + 1, a2, (__n128)a6);
      uint64_t v18 = 0;
      a1->i32[3] = bswap32(v23 + 1);
      do
      {
        int v27 = &a1->i8[v18];
        __int8 v28 = v27[16] ^ a3[v18];
        a4->i8[v18] = v28;
        v27[64] ^= v28;
        ++v18;
      }
      while (v22 != v18);
    }
    else
    {
      LODWORD(v18) = 0;
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t sub_244D30DD8(int8x16_t *a1, uint64_t a2, int8x16_t *a3, uint64_t *a4, unint64_t a5, int8x16_t a6)
{
  uint64_t result = 0;
  uint64_t v8 = a1[3].i64[1];
  BOOL v9 = __CFADD__(v8, a5);
  unint64_t v10 = v8 + a5;
  char v11 = v9;
  if (v10 <= 0xFFFFFFFE0 && (v11 & 1) == 0)
  {
    unint64_t v12 = a5;
    i64 = a1[5].i64;
    char v17 = (void (*)(int8x16_t *, int8x16_t *, uint64_t, __n128))a1[22].i64[0];
    a1[3].i64[1] = v10;
    if (a1[23].i32[1])
    {
      a6 = sub_244D307DC(a1 + 4, a1[5].i64);
      a1[23].i32[1] = 0;
    }
    LODWORD(v18) = a1[23].i32[0];
    if (v18)
    {
      if (!v12) {
        goto LABEL_27;
      }
      do
      {
        __int8 v19 = a3->i8[0];
        a3 = (int8x16_t *)((char *)a3 + 1);
        __int8 v20 = &a1->i8[v18];
        *(unsigned char *)a4 = v20[16] ^ v19;
        a4 = (uint64_t *)((char *)a4 + 1);
        v20[64] ^= v19;
        unint64_t v21 = v12 - 1;
        LODWORD(v18) = ((_BYTE)v18 + 1) & 0xF;
        if (!v18) {
          break;
        }
        --v12;
      }
      while (v12);
      if (v18)
      {
LABEL_27:
        a1[23].i32[0] = v18;
        return 1;
      }
      a6 = sub_244D307DC(a1 + 4, a1[5].i64);
    }
    else
    {
      unint64_t v21 = v12;
    }
    unsigned int v22 = bswap32(a1->u32[3]);
    if (v21 >= 0xC00)
    {
      do
      {
        unint64_t v28 = v21;
        a6 = sub_244D30858(a1 + 4, i64, a3, 0xC00uLL);
        for (unint64_t i = 0; i != 3072; i += 16)
        {
          uint64_t v24 = &a4[i / 8];
          v17(a1, a1 + 1, a2, (__n128)a6);
          a1->i32[3] = bswap32(++v22);
          *uint64_t v24 = a1[1].i64[0] ^ a3[i / 0x10].i64[0];
          v24[1] = a1[1].i64[1] ^ a3[i / 0x10].i64[1];
        }
        unint64_t v21 = v28 - 3072;
        a3 += 192;
        a4 += 384;
        i64 = a1[5].i64;
      }
      while (v28 - 3072 > 0xBFF);
    }
    unint64_t v25 = v21 & 0xFF0;
    if ((v21 & 0xFF0) != 0)
    {
      a6 = sub_244D30858(a1 + 4, i64, a3, v25);
      do
      {
        v17(a1, a1 + 1, a2, (__n128)a6);
        a1->i32[3] = bswap32(++v22);
        *a4 = a1[1].i64[0] ^ a3->i64[0];
        a4[1] = a1[1].i64[1] ^ a3->i64[1];
        a4 += 2;
        ++a3;
        v21 -= 16;
      }
      while (v21 > 0xF);
    }
    if (v21)
    {
      ((void (*)(int8x16_t *, int8x16_t *, uint64_t, unint64_t, __n128))v17)(a1, &a1[1], a2, v25, (__n128)a6);
      uint64_t v18 = 0;
      a1->i32[3] = bswap32(v22 + 1);
      do
      {
        __int8 v26 = a3->i8[v18];
        int v27 = &a1->i8[v18];
        v27[64] ^= v26;
        *((unsigned char *)a4 + v18++) = v27[16] ^ v26;
      }
      while (v21 != v18);
    }
    else
    {
      LODWORD(v18) = 0;
    }
    goto LABEL_27;
  }
  return result;
}

uint64_t sub_244D31044(uint64_t a1, uint64_t a2, char *a3, int8x16_t *a4, unint64_t a5, void (*a6)(char *, int8x16_t *, uint64_t, uint64_t, uint64_t, __n128), int8x16_t a7)
{
  uint64_t result = 0;
  uint64_t v9 = *(void *)(a1 + 56);
  BOOL v10 = __CFADD__(v9, a5);
  unint64_t v11 = v9 + a5;
  char v12 = v10;
  if (v11 <= 0xFFFFFFFE0 && (v12 & 1) == 0)
  {
    unint64_t v14 = a5;
    *(void *)(a1 + 56) = v11;
    if (*(_DWORD *)(a1 + 372))
    {
      a7 = sub_244D307DC((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80));
      *(_DWORD *)(a1 + 372) = 0;
    }
    LODWORD(v18) = *(_DWORD *)(a1 + 368);
    if (v18)
    {
      if (!v14) {
        goto LABEL_24;
      }
      do
      {
        char v19 = *a3++;
        uint64_t v20 = a1 + v18;
        __int8 v21 = *(unsigned char *)(v20 + 16) ^ v19;
        a4->i8[0] = v21;
        a4 = (int8x16_t *)((char *)a4 + 1);
        *(unsigned char *)(v20 + 64) ^= v21;
        unint64_t v22 = v14 - 1;
        LODWORD(v18) = ((_BYTE)v18 + 1) & 0xF;
        if (!v18) {
          break;
        }
        --v14;
      }
      while (v14);
      if (v18)
      {
LABEL_24:
        *(_DWORD *)(a1 + 368) = v18;
        return 1;
      }
      a7 = sub_244D307DC((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80));
    }
    else
    {
      unint64_t v22 = v14;
    }
    unsigned int v23 = bswap32(*(_DWORD *)(a1 + 12));
    if (v22 >= 0xC00)
    {
      do
      {
        a6(a3, a4, 192, a2, a1, (__n128)a7);
        v23 += 192;
        *(_DWORD *)(a1 + 12) = bswap32(v23);
        a7 = sub_244D30858((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80), a4, 0xC00uLL);
        a4 += 192;
        a3 += 3072;
        v22 -= 3072;
      }
      while (v22 > 0xBFF);
    }
    unint64_t v24 = v22 & 0xFF0;
    if ((v22 & 0xFF0) != 0)
    {
      a6(a3, a4, v22 >> 4, a2, a1, (__n128)a7);
      v23 += v22 >> 4;
      *(_DWORD *)(a1 + 12) = bswap32(v23);
      a3 += v24;
      v22 &= 0xFu;
      a7 = sub_244D30858((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80), a4, v24);
      a4 = (int8x16_t *)((char *)a4 + v24);
    }
    if (v22)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, int8x16_t))(a1 + 352))(a1, a1 + 16, a2, a7);
      uint64_t v18 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v23 + 1);
      do
      {
        uint64_t v25 = a1 + v18;
        __int8 v26 = *(unsigned char *)(v25 + 16) ^ a3[v18];
        a4->i8[v18] = v26;
        *(unsigned char *)(v25 + 64) ^= v26;
        ++v18;
      }
      while (v22 != v18);
    }
    else
    {
      LODWORD(v18) = 0;
    }
    goto LABEL_24;
  }
  return result;
}

uint64_t sub_244D3124C(uint64_t a1, uint64_t a2, int8x16_t *a3, unsigned char *a4, unint64_t a5, void (*a6)(int8x16_t *, unsigned char *, uint64_t, uint64_t, uint64_t, __n128))
{
  uint64_t result = 0;
  uint64_t v8 = *(void *)(a1 + 56);
  BOOL v9 = __CFADD__(v8, a5);
  unint64_t v10 = v8 + a5;
  char v11 = v9;
  if (v10 <= 0xFFFFFFFE0 && (v11 & 1) == 0)
  {
    unint64_t v13 = a5;
    *(void *)(a1 + 56) = v10;
    if (*(_DWORD *)(a1 + 372))
    {
      sub_244D307DC((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80));
      *(_DWORD *)(a1 + 372) = 0;
    }
    LODWORD(v17) = *(_DWORD *)(a1 + 368);
    if (v17)
    {
      if (!v13) {
        goto LABEL_24;
      }
      do
      {
        __int8 v18 = a3->i8[0];
        a3 = (int8x16_t *)((char *)a3 + 1);
        uint64_t v19 = a1 + v17;
        *a4++ = *(unsigned char *)(v19 + 16) ^ v18;
        *(unsigned char *)(v19 + 64) ^= v18;
        unint64_t v20 = v13 - 1;
        LODWORD(v17) = ((_BYTE)v17 + 1) & 0xF;
        if (!v17) {
          break;
        }
        --v13;
      }
      while (v13);
      if (v17)
      {
LABEL_24:
        *(_DWORD *)(a1 + 368) = v17;
        return 1;
      }
      sub_244D307DC((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80));
    }
    else
    {
      unint64_t v20 = v13;
    }
    unsigned int v21 = bswap32(*(_DWORD *)(a1 + 12));
    if (v20 >= 0xC00)
    {
      do
      {
        __n128 v22 = (__n128)sub_244D30858((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80), a3, 0xC00uLL);
        a6(a3, a4, 192, a2, a1, v22);
        v21 += 192;
        *(_DWORD *)(a1 + 12) = bswap32(v21);
        a4 += 3072;
        a3 += 192;
        v20 -= 3072;
      }
      while (v20 > 0xBFF);
    }
    unint64_t v23 = v20 & 0xFF0;
    if ((v20 & 0xFF0) != 0)
    {
      __n128 v24 = (__n128)sub_244D30858((int8x16_t *)(a1 + 64), (uint64_t *)(a1 + 80), a3, v20 & 0xFF0);
      a6(a3, a4, v20 >> 4, a2, a1, v24);
      v21 += v20 >> 4;
      *(_DWORD *)(a1 + 12) = bswap32(v21);
      a4 += v23;
      a3 = (int8x16_t *)((char *)a3 + v23);
      v20 &= 0xFu;
    }
    if (v20)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 352))(a1, a1 + 16, a2);
      uint64_t v17 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v21 + 1);
      do
      {
        __int8 v25 = a3->i8[v17];
        uint64_t v26 = a1 + v17;
        *(unsigned char *)(v26 + 64) ^= v25;
        a4[v17++] = *(unsigned char *)(v26 + 16) ^ v25;
      }
      while (v20 != v17);
    }
    else
    {
      LODWORD(v17) = 0;
    }
    goto LABEL_24;
  }
  return result;
}

BOOL sub_244D31454(int8x16_t *a1, char *a2, unint64_t a3)
{
  if (a1[23].i32[0] || a1[23].i32[1]) {
    sub_244D307DC(a1 + 4, a1[5].i64);
  }
  int8x16_t v7 = a1[4];
  BOOL v6 = a1 + 4;
  *BOOL v6 = veorq_s8(vrev64q_s8((int8x16_t)vshlq_n_s64((int64x2_t)v6[-1], 3uLL)), v7);
  sub_244D307DC(v6, v6[1].i64);
  BOOL result = 0;
  *BOOL v6 = veorq_s8(v6[-2], *v6);
  if (a2)
  {
    if (a3 <= 0x10) {
      return sub_244D441D4(v6->i8, a2, a3) == 0;
    }
  }
  return result;
}

void *sub_244D314FC(int8x16_t *a1, void *a2, unint64_t a3)
{
  BOOL result = (void *)sub_244D31454(a1, 0, 0);
  if (a3 >= 0x10) {
    size_t v7 = 16;
  }
  else {
    size_t v7 = a3;
  }
  if (v7)
  {
    return memcpy(a2, &a1[4], v7);
  }
  return result;
}

unint64_t *sub_244D31570(uint64_t *a1, uint64_t *a2)
{
  uint64_t v18 = 0;
  unint64_t v19 = 0;
  uint64_t v4 = *a1;
  uint64_t v5 = a2[1];
  sub_244D434E4(&v19, &v18, *a1, v5);
  uint64_t v16 = 0;
  unint64_t v17 = 0;
  uint64_t v6 = a1[1];
  uint64_t v7 = *a2;
  sub_244D434E4(&v17, &v16, v6, v7);
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  BOOL result = sub_244D434E4(&v15, &v14, v6 ^ v4, v7 ^ v5);
  unint64_t v9 = (v19 << 63) ^ (v19 << 62) ^ (v19 << 57) ^ v19 ^ v15 ^ v17 ^ v18;
  *((void *)&v10 + 1) = v9;
  *(void *)&long long v10 = v19;
  uint64_t v11 = v14 ^ (v10 >> 1);
  *((void *)&v10 + 1) = v9;
  *(void *)&long long v10 = v19;
  uint64_t v12 = v10 >> 2;
  *((void *)&v10 + 1) = v9;
  *(void *)&long long v10 = v19;
  unint64_t v13 = (v9 >> 1) ^ (v9 >> 2) ^ (v9 >> 7) ^ v16 ^ v9;
  *a1 = v11 ^ v12 ^ (v10 >> 7) ^ v18 ^ v16 ^ v17 ^ v19;
  a1[1] = v13;
  return result;
}

void *sub_244D3166C(void *result, long long *a2)
{
  int64_t v2 = 0xFF00000000000000 * (*(void *)a2 & 1);
  *((void *)&v4 + 1) = v2 & 0xE1FFFFFFFFFFFFFFLL ^ (*((void *)a2 + 1) >> 1);
  *(void *)&long long v4 = *a2 >> 1;
  uint64_t v3 = v4 >> 63;
  *((void *)&v4 + 1) = v4;
  *(void *)&long long v4 = v2;
  result[2] = (v2 >> 63) & 0xC200000000000000 ^ v3;
  result[3] = v4 >> 63;
  result[34] = sub_244D307DC;
  result[35] = sub_244D30858;
  *BOOL result = 0;
  result[1] = 0;
  return result;
}

uint64_t sub_244D316C8(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unint64_t v3 = a3;
    uint64_t v5 = result;
    uint64_t v6 = result + 16;
    do
    {
      if (v3 >= 0x200) {
        unint64_t v7 = 512;
      }
      else {
        unint64_t v7 = v3;
      }
      __memcpy_chk();
      if (v7 >= 0x10)
      {
        unint64_t v8 = v7 >> 4;
        unint64_t v9 = (int8x16_t *)v10;
        do
        {
          sub_244D317B4(v9++);
          --v8;
        }
        while (v8);
      }
      a2 += v7;
      v3 -= v7;
      BOOL result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, unint64_t))(v5 + 280))(v5, v6, v10, v7);
    }
    while (v3);
  }
  return result;
}

int8x16_t sub_244D317B4(int8x16_t *a1)
{
  int8x16_t v1 = vrev64q_s8(*a1);
  int8x16_t result = vextq_s8(v1, v1, 8uLL);
  *a1 = result;
  return result;
}

double sub_244D317C8(int8x16_t *a1, int8x16_t *a2)
{
  *a2 = *a1;
  *(void *)&double result = sub_244D317B4(a2).u64[0];
  return result;
}

void *sub_244D317D8(_OWORD *a1, char *a2, unint64_t a3)
{
  uint64_t v6 = sub_244D43FF4(0x120uLL);
  unint64_t v7 = v6;
  if (!v6 || !sub_244D31840((uint64_t)v6, a1, a2, a3))
  {
    sub_244D440EC(v7);
    return 0;
  }
  return v7;
}

uint64_t sub_244D31840(uint64_t a1, _OWORD *a2, char *a3, unint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a4 > 0x30) {
    return 0;
  }
  long long v6 = a2[1];
  v10[0] = *a2;
  v10[1] = v6;
  long long v11 = a2[2];
  if (a4)
  {
    unint64_t v7 = v10;
    do
    {
      char v8 = *a3++;
      *v7++ ^= v8;
      --a4;
    }
    while (a4);
  }
  for (uint64_t i = 0; i != 3; ++i)
    v10[i] = veorq_s8((int8x16_t)v10[i], (int8x16_t)xmmword_244EB71E8[i]);
  sub_244D13B14(v10, 256, a1);
  *(void *)(a1 + 248) = sub_244D13964;
  *(void *)(a1 + 256) = sub_244D14738;
  *(_OWORD *)(a1 + 264) = v11;
  uint64_t result = 1;
  *(void *)(a1 + 280) = 1;
  return result;
}

uint64_t sub_244D31944(uint64_t a1, char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a4)
  {
    if (a4 > 0x30) {
      return 0;
    }
    uint64_t v6 = 0;
    long long v7 = *((_OWORD *)a2 + 1);
    v8[0] = *(_OWORD *)a2;
    v8[1] = v7;
    void v8[2] = *((_OWORD *)a2 + 2);
    do
    {
      a2 = (char *)v8;
      *((unsigned char *)v8 + v6) ^= *(unsigned char *)(a3 + v6);
      ++v6;
    }
    while (a4 != v6);
  }
  uint64_t result = sub_244D319F8(a1, a2, 0x30uLL);
  if (result)
  {
    uint64_t result = 1;
    *(void *)(a1 + 280) = 1;
  }
  return result;
}

uint64_t sub_244D319F8(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a3 > 0x30) {
    return 0;
  }
  unint64_t v4 = a3;
  long long v7 = (_OWORD *)(a1 + 264);
  unint64_t v8 = 0xFFFFFFFFFFFFFFFLL;
  do
  {
    *(_DWORD *)(a1 + 276) = bswap32(bswap32(*(_DWORD *)(a1 + 276)) + 1);
    (*(void (**)(_OWORD *, _OWORD *, uint64_t))(a1 + 248))(v7, &v11[++v8], a1);
  }
  while (v8 < 2);
  if (v4)
  {
    uint64_t v9 = v11;
    do
    {
      char v10 = *a2++;
      *v9++ ^= v10;
      --v4;
    }
    while (v4);
  }
  sub_244D13B14(v11, 256, a1);
  *(void *)(a1 + 248) = sub_244D13964;
  *(void *)(a1 + 256) = sub_244D14738;
  *long long v7 = v11[2];
  return 1;
}

uint64_t sub_244D31B10(uint64_t a1, char *a2, unint64_t a3, char *a4, unint64_t a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (a3 > 0x10000 || *(void *)(a1 + 280) > 0x1000000000000uLL) {
    return 0;
  }
  size_t v9 = a3;
  if (!a5 || (uint64_t result = sub_244D319F8(a1, a4, a5), result))
  {
    if (v9 >= 0x10)
    {
      do
      {
        if (v9 >= 0x2000) {
          unint64_t v11 = 0x2000;
        }
        else {
          unint64_t v11 = v9;
        }
        unint64_t v12 = v11 & 0x3FF0;
        if (*(void *)(a1 + 256))
        {
          if ((v11 & 0x3FF0) != 0) {
            bzero(a2, v11 & 0x3FF0);
          }
          unint64_t v13 = v11 >> 4;
          *(_DWORD *)(a1 + 276) = bswap32(bswap32(*(_DWORD *)(a1 + 276)) + 1);
          (*(void (**)(char *, char *, unint64_t, uint64_t, uint64_t))(a1 + 256))(a2, a2, v13, a1, a1 + 264);
          *(_DWORD *)(a1 + 276) = bswap32(v13 + bswap32(*(_DWORD *)(a1 + 276)) - 1);
        }
        else if ((v11 & 0x3FF0) != 0)
        {
          unint64_t v14 = 0;
          do
          {
            *(_DWORD *)(a1 + 276) = bswap32(bswap32(*(_DWORD *)(a1 + 276)) + 1);
            (*(void (**)(uint64_t, char *, uint64_t))(a1 + 248))(a1 + 264, &a2[v14], a1);
            v14 += 16;
          }
          while (v14 < v12);
        }
        a2 += v12;
        v9 -= v12;
      }
      while (v9 > 0xF);
    }
    if (v9)
    {
      *(_DWORD *)(a1 + 276) = bswap32(bswap32(*(_DWORD *)(a1 + 276)) + 1);
      (*(void (**)(uint64_t, unsigned char *, uint64_t))(a1 + 248))(a1 + 264, __src, a1);
      memcpy(a2, __src, v9);
    }
    uint64_t result = sub_244D319F8(a1, a4, a5);
    if (result)
    {
      ++*(void *)(a1 + 280);
      return 1;
    }
  }
  return result;
}

void sub_244D31CFC(void *a1)
{
}

uint64_t sub_244D31D04()
{
  return qword_268EC01B0;
}

uint64_t sub_244D31D3C()
{
  uint64_t result = pthread_atfork(0, 0, sub_244D43690);
  if (result) {
    abort();
  }
  qword_268EC01B0 = 1;
  return result;
}

void sub_244D31D80(void *a1)
{
  if (a1) {
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D31D8C(void *a1, size_t a2)
{
  if (a2 >= 0x101) {
    abort();
  }
  return sub_244D498F8(a1, a2);
}

void *sub_244D31DB4()
{
  uint64_t v0 = sub_244D44058(0x18uLL);
  if (v0)
  {
    int8x16_t v1 = sub_244D16670();
    void *v0 = v1;
    if (v1 && (uint64_t v2 = sub_244D16670(), (v0[1] = v2) != 0))
    {
      *((_DWORD *)v0 + 4) = 31;
    }
    else
    {
      sub_244D07DFC(v0);
      return 0;
    }
  }
  return v0;
}

uint64_t sub_244D31E14(uint64_t result)
{
  *(_DWORD *)(result + 16) = 31;
  return result;
}

uint64_t sub_244D31E20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9 = *(_DWORD *)(a2 + 16) + 1;
  *(_DWORD *)(a2 + 16) = v9;
  if (v9 == 32)
  {
    if (sub_244D1C18C(*(void *)a2, 1uLL, a4 + 24)
      && sub_244D1A1FC(*(void *)(a2 + 8), *(void *)a2, a4, a5)
      && sub_244D1C074(*(void ***)(a2 + 8), &v13, *(void *)(a2 + 8), a4, a5)
      && sub_244D19BB4(*(void *)a2, *(void *)a2, a3, a4 + 24, a5, a4)
      && sub_244D1A118(*(void *)a2, *(void *)a2, a4, a4, a5))
    {
      *(_DWORD *)(a2 + 16) = 0;
      goto LABEL_10;
    }
    sub_244D0B884(4, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/blinding.c", 236);
LABEL_14:
    *(_DWORD *)(a2 + 16) = 31;
    return 0;
  }
  if (!sub_244D1A118(*(void *)a2, *(void *)a2, *(void *)a2, a4, a5)
    || !sub_244D1A118(*(void *)(a2 + 8), *(void *)(a2 + 8), *(void *)(a2 + 8), a4, a5))
  {
    goto LABEL_14;
  }
LABEL_10:
  uint64_t v11 = *(void *)a2;

  return sub_244D1A118(a1, a1, v11, a4, a5);
}

uint64_t sub_244D31FA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_244D1A118(a1, a1, *(void *)(a2 + 8), a3, a4);
}

uint64_t sub_244D31FB8(_WORD *a1, unint64_t a2, void *__src, size_t __n)
{
  if (a2 <= 0xA)
  {
    int v4 = 126;
    __int16 v5 = 78;
LABEL_5:
    sub_244D0B884(4, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/padding.c", v5);
    return 0;
  }
  if (a2 - 11 < __n)
  {
    int v4 = 118;
    __int16 v5 = 83;
    goto LABEL_5;
  }
  *a1 = 256;
  if (a2 - 3 != __n) {
    memset(a1 + 1, 255, a2 - 3 - __n);
  }
  *((unsigned char *)a1 + ~__n + a2) = 0;
  if (__n) {
    memcpy((char *)a1 + a2 - __n, __src, __n);
  }
  return 1;
}

uint64_t sub_244D32088(void *a1, size_t *a2, size_t a3, unsigned char *a4, unint64_t a5)
{
  if (a5 <= 1)
  {
    int v5 = 116;
    __int16 v6 = 101;
LABEL_11:
    sub_244D0B884(4, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/padding.c", v6);
    return 0;
  }
  if (*a4 || a4[1] != 1)
  {
    int v5 = 107;
    __int16 v6 = 107;
    goto LABEL_11;
  }
  if (a5 < 3) {
    goto LABEL_14;
  }
  uint64_t v8 = 0;
  unint64_t v9 = a5 - 2;
  while (a4[v8 + 2] == 255)
  {
    if (v9 == ++v8) {
      goto LABEL_14;
    }
  }
  if (a4[v8 + 2])
  {
    int v5 = 102;
    __int16 v6 = 119;
    goto LABEL_11;
  }
  if (v9 == v8)
  {
LABEL_14:
    int v5 = 131;
    __int16 v6 = 125;
    goto LABEL_11;
  }
  if ((unint64_t)(v8 + 2) <= 9)
  {
    int v5 = 103;
    __int16 v6 = 130;
    goto LABEL_11;
  }
  size_t v11 = a5 - v8 - 3;
  if (v11 > a3)
  {
    int v5 = 113;
    __int16 v6 = 138;
    goto LABEL_11;
  }
  if (a5 - 3 != v8) {
    memcpy(a1, &a4[v8 + 3], v11);
  }
  *a2 = v11;
  return 1;
}

uint64_t sub_244D321EC(void *a1, size_t a2, void *__src, size_t __n)
{
  if (__n > a2)
  {
    int v4 = 114;
    __int16 v5 = 150;
LABEL_5:
    sub_244D0B884(4, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/padding.c", v5);
    return 0;
  }
  if (__n < a2)
  {
    int v4 = 116;
    __int16 v5 = 155;
    goto LABEL_5;
  }
  if (__n) {
    memcpy(a1, __src, __n);
  }
  return 1;
}

uint64_t sub_244D32260(char *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  memset(v15, 0, sizeof(v15));
  if (a2)
  {
    size_t v8 = a2;
    unsigned int v10 = 0;
    size_t v11 = *(unsigned int *)(a5 + 4);
    while (1)
    {
      unsigned int v14 = bswap32(v10);
      if (!sub_244D258CC((uint64_t)v15, a5))
      {
        uint64_t v12 = 0;
        goto LABEL_10;
      }
      (*(void (**)(_OWORD *, uint64_t, uint64_t))(*(void *)&v15[0] + 24))(v15, a3, a4);
      (*(void (**)(_OWORD *, unsigned int *, uint64_t))(*(void *)&v15[0] + 24))(v15, &v14, 4);
      if (v8 < v11) {
        break;
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v15[0] + 32))(v15, a1);
      sub_244D4413C(*((void **)&v15[0] + 1), *(unsigned int *)(*(void *)&v15[0] + 44));
      a1 += v11;
      ++v10;
      v8 -= v11;
      if (!v8) {
        goto LABEL_9;
      }
    }
    (*(void (**)(_OWORD *, unsigned char *))(*(void *)&v15[0] + 32))(v15, __src);
    sub_244D4413C(*((void **)&v15[0] + 1), *(unsigned int *)(*(void *)&v15[0] + 44));
    memcpy(a1, __src, v8);
  }
LABEL_9:
  uint64_t v12 = 1;
LABEL_10:
  sub_244D25650((uint64_t)v15);
  return v12;
}

uint64_t sub_244D323BC(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, int a6)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a3;
  }
  memset(v39, 0, sizeof(v39));
  size_t v11 = *(unsigned int *)(a3 + 4);
  if (a6 == -2)
  {
    unsigned int v12 = -2;
LABEL_9:
    unsigned int v15 = sub_244D168EC(a1[1]) + 7;
    int v16 = v15 & 7;
    uint64_t v17 = (uint64_t (*)(uint64_t **))(*a1)[4];
    if (v17) {
      unsigned int v18 = v17(a1);
    }
    else {
      unsigned int v18 = v15 >> 3;
    }
    if (*a5 >> v16)
    {
      int v13 = 122;
      __int16 v14 = 240;
      goto LABEL_24;
    }
    uint64_t v19 = v18;
    if (v16) {
      unint64_t v20 = a5;
    }
    else {
      unint64_t v20 = a5 + 1;
    }
    if (v16) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = -1;
    }
    unint64_t v22 = v18 - (unint64_t)(v16 == 0);
    if (v22 < v11 + 2 || (v12 & 0x80000000) == 0 && v22 < v11 + 2 + v12)
    {
      int v13 = 113;
      __int16 v14 = 250;
      goto LABEL_24;
    }
    if (v20[v22 - 1] != 188)
    {
      int v13 = 127;
      __int16 v14 = 254;
      goto LABEL_24;
    }
    uint64_t v38 = v21;
    unint64_t v26 = v22 + ~v11;
    int v27 = (char *)sub_244D43FF4(v26);
    __n128 v24 = v27;
    if (v27)
    {
      __s2 = &v20[v26];
      if (sub_244D32260(v27, v26, (uint64_t)&v20[v26], v11, v10))
      {
        if (v26)
        {
          unint64_t v28 = v24;
          unint64_t v29 = v26;
          do
          {
            char v30 = *v20++;
            *v28++ ^= v30;
            --v29;
          }
          while (v29);
        }
        if (v16) {
          *v24 &= 0xFFu >> (8 - v16);
        }
        unint64_t v31 = 0;
        do
        {
          int v32 = v24[v31];
          unint64_t v33 = v31 + 1;
          if (v24[v31]) {
            BOOL v34 = 1;
          }
          else {
            BOOL v34 = v31 >= v26 - 1;
          }
          ++v31;
        }
        while (!v34);
        if (v32 == 1)
        {
          if ((v12 & 0x80000000) != 0 || ~(unint64_t)v12 + v38 + v19 - v11 == v33)
          {
            if (!sub_244D258CC((uint64_t)v39, a3)) {
              goto LABEL_47;
            }
            (*(void (**)(_OWORD *, void *, uint64_t))(*(void *)&v39[0] + 24))(v39, &unk_244EB7238, 8);
            (*(void (**)(_OWORD *, uint64_t, size_t))(*(void *)&v39[0] + 24))(v39, a2, v11);
            (*(void (**)(_OWORD *, char *, unint64_t))(*(void *)&v39[0] + 24))(v39, &v24[v33], v26 - v33);
            (*(void (**)(_OWORD *, unsigned char *))(*(void *)&v39[0] + 32))(v39, __s1);
            sub_244D4413C(*((void **)&v39[0] + 1), *(unsigned int *)(*(void *)&v39[0] + 44));
            if (!v11 || !memcmp(__s1, __s2, v11))
            {
              uint64_t v23 = 1;
              goto LABEL_25;
            }
            int v35 = 105;
            __int16 v36 = 299;
          }
          else
          {
            int v35 = 138;
            __int16 v36 = 287;
          }
        }
        else
        {
          int v35 = 139;
          __int16 v36 = 281;
        }
        sub_244D0B884(4, 0, v35, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/padding.c", v36);
      }
    }
LABEL_47:
    uint64_t v23 = 0;
    goto LABEL_25;
  }
  unsigned int v12 = *(_DWORD *)(a3 + 4);
  if (a6 == -1) {
    goto LABEL_9;
  }
  unsigned int v12 = a6;
  if (a6 > -3) {
    goto LABEL_9;
  }
  int v13 = 138;
  __int16 v14 = 233;
LABEL_24:
  sub_244D0B884(4, 0, v13, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/padding.c", v14);
  uint64_t v23 = 0;
  __n128 v24 = 0;
LABEL_25:
  sub_244D440EC(v24);
  sub_244D25650((uint64_t)v39);
  return v23;
}

uint64_t sub_244D32744(uint64_t **a1)
{
  int8x16_t v1 = (uint64_t (*)(void))(*a1)[4];
  if (v1) {
    return v1();
  }
  else {
    return (sub_244D168EC(a1[1]) + 7) >> 3;
  }
}

uint64_t sub_244D3277C(void *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  if (a5) {
    uint64_t v7 = a5;
  }
  else {
    uint64_t v7 = a4;
  }
  uint64_t v8 = a1[1];
  uint64_t v9 = *(int *)(v8 + 8);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v14 = 0;
  uint64_t v15 = *(unsigned int *)(a4 + 4);
  int v16 = *(uint64_t **)v8;
  do
  {
    uint64_t v17 = *v16++;
    v14 |= v17;
    --v9;
  }
  while (v9);
  if (!v14)
  {
LABEL_10:
    int v22 = 120;
    __int16 v23 = 329;
LABEL_36:
    sub_244D0B884(4, 0, v22, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/padding.c", v23);
    uint64_t v34 = 0;
    unint64_t v28 = 0;
    goto LABEL_37;
  }
  unsigned int v18 = sub_244D168EC((uint64_t *)v8) + 7;
  int v19 = v18 & 7;
  unint64_t v20 = *(uint64_t (**)(void *))(*a1 + 32);
  if (v20) {
    unsigned int v21 = v20(a1);
  }
  else {
    unsigned int v21 = v18 >> 3;
  }
  unint64_t v24 = v21;
  if (!v19)
  {
    *a2++ = 0;
    unint64_t v24 = v21 - 1;
  }
  if (v24 < v15 + 2)
  {
    int v22 = 114;
    __int16 v23 = 342;
    goto LABEL_36;
  }
  unint64_t v25 = v15;
  if (a6 != -1)
  {
    if (a6 == -2)
    {
      unint64_t v25 = v24 - v15 - 2;
    }
    else
    {
      if ((a6 & 0x80000000) != 0)
      {
        int v22 = 138;
        __int16 v23 = 356;
        goto LABEL_36;
      }
      unint64_t v25 = a6;
    }
  }
  unint64_t v26 = v24 - v15;
  if (v24 - v15 - 2 < v25)
  {
    int v22 = 114;
    __int16 v23 = 363;
    goto LABEL_36;
  }
  if (v25)
  {
    int v27 = (char *)sub_244D43FF4(v25);
    unint64_t v28 = v27;
    if (!v27) {
      goto LABEL_39;
    }
    sub_244D20BA4(v27, v25, (uint64_t)&unk_244EB7218);
  }
  else
  {
    unint64_t v28 = 0;
  }
  memset(v36, 0, sizeof(v36));
  if (!sub_244D258CC((uint64_t)v36, a4))
  {
    sub_244D25650((uint64_t)v36);
    goto LABEL_39;
  }
  size_t v29 = v26 - 1;
  uint64_t v30 = (uint64_t)&a2[v26 - 1];
  (*(void (**)(_OWORD *, void *, uint64_t))(*(void *)&v36[0] + 24))(v36, &unk_244EB7238, 8);
  (*(void (**)(_OWORD *, uint64_t, uint64_t))(*(void *)&v36[0] + 24))(v36, a3, v15);
  (*(void (**)(_OWORD *, char *, unint64_t))(*(void *)&v36[0] + 24))(v36, v28, v25);
  (*(void (**)(_OWORD *, uint64_t))(*(void *)&v36[0] + 32))(v36, v30);
  sub_244D4413C(*((void **)&v36[0] + 1), *(unsigned int *)(*(void *)&v36[0] + 44));
  sub_244D25650((uint64_t)v36);
  if (!sub_244D32260(a2, v29, v30, v15, v7))
  {
LABEL_39:
    uint64_t v34 = 0;
    goto LABEL_37;
  }
  a2[v24 - (v25 + v15) - 2] ^= 1u;
  if (v25)
  {
    unint64_t v31 = &a2[v24 + ~(v25 + v15)];
    int v32 = v28;
    do
    {
      char v33 = *v32++;
      *v31++ ^= v33;
      --v25;
    }
    while (v25);
  }
  if (v19) {
    *a2 &= 0xFFu >> (8 - v19);
  }
  a2[v24 - 1] = -68;
  uint64_t v34 = 1;
LABEL_37:
  sub_244D440EC(v28);
  return v34;
}

uint64_t sub_244D32A70(uint64_t a1, uint64_t a2)
{
  int v4 = sub_244D334EC(0);
  uint64_t v5 = (uint64_t)v4;
  if (!v4
    || !sub_244D32AF0((void ***)v4 + 1, a1)
    || !sub_244D32AF0((void ***)(v5 + 16), a2)
    || !sub_244D32B54((uint64_t *)v5))
  {
    sub_244D3306C(v5);
    return 0;
  }
  return v5;
}

long long **sub_244D32AE8()
{
  return sub_244D334EC(0);
}

BOOL sub_244D32AF0(void ***a1, uint64_t a2)
{
  if (a2)
  {
    sub_244D166B0((void **)*a1);
    int v4 = sub_244D16714(a2);
    *a1 = v4;
    return v4 != 0;
  }
  else
  {
    sub_244D0B884(4, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 88);
    return 0;
  }
}

uint64_t sub_244D32B54(uint64_t *a1)
{
  if (*a1 && (*(unsigned char *)(*a1 + 72) & 1) != 0) {
    return 1;
  }
  if (sub_244D344BC((uint64_t)a1))
  {
    uint64_t v2 = a1[4];
    if ((v2 == 0) == (a1[5] != 0))
    {
      int v4 = 134;
      __int16 v5 = 799;
      goto LABEL_10;
    }
    uint64_t v3 = a1[3];
    if (v3)
    {
      if (*(_DWORD *)(v3 + 16) || (sub_244D17194(v3, a1[1]) & 0x80000000) == 0)
      {
        int v4 = 147;
        __int16 v5 = 807;
LABEL_10:
        sub_244D0B884(4, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", v5);
        return 0;
      }
      if (v2)
      {
        uint64_t v7 = sub_244D43FF4(0x30uLL);
        if (!v7) {
          return 0;
        }
        uint64_t v8 = (unint64_t **)v7;
        *(_OWORD *)((char *)v7 + 26) = 0u;
        *uint64_t v7 = 0u;
        v7[1] = 0u;
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        int v39 = 0;
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        __int16 v36 = 0;
        memset(v35, 0, sizeof(v35));
        memset(v34, 0, sizeof(v34));
        memset(v33, 0, sizeof(v33));
        memset(v32, 0, sizeof(v32));
        uint64_t v9 = a1[4];
        if (*(_DWORD *)(v9 + 16)
          || (uint64_t v10 = a1[1], (int)sub_244D17194(a1[4], v10) >= 0)
          || (uint64_t v11 = a1[5], *(_DWORD *)(v11 + 16))
          || (int)sub_244D17194(a1[5], v10) >= 0)
        {
          int v12 = 132;
          __int16 v13 = 839;
        }
        else if (sub_244D1C868((uint64_t)&v39, v9, v11, (uint64_t)v8))
        {
          if (sub_244D17194((uint64_t)&v39, a1[1]))
          {
            int v12 = 132;
            __int16 v13 = 847;
          }
          else
          {
            uint64_t v15 = a1[4];
            sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
            if (sub_244D163DC((uint64_t)v35, v15, (uint64_t)&qword_268EBEE70)
              && (uint64_t v16 = a1[5],
                  sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850),
                  sub_244D163DC((uint64_t)v34, v16, (uint64_t)&qword_268EBEE70)))
            {
              int v17 = sub_244D168EC((uint64_t *)v35);
              int v18 = sub_244D168EC((uint64_t *)v34);
              if (sub_244D1C868((uint64_t)&v36, a1[3], a1[2], (uint64_t)v8)
                && sub_244D18204(0, (void **)&v39, (uint64_t)&v36, (uint64_t)v35, v17, (uint64_t)v8)
                && sub_244D18204(0, (void **)&v36, (uint64_t)&v36, (uint64_t)v34, v18, (uint64_t)v8))
              {
                if (v41)
                {
                  BOOL v19 = 1;
                }
                else
                {
                  if (v40)
                  {
                    uint64_t v20 = *(void *)v39 ^ 1;
                    if ((int)v40 >= 2)
                    {
                      uint64_t v21 = v40 - 1;
                      int v22 = (uint64_t *)(v39 + 8);
                      do
                      {
                        uint64_t v23 = *v22++;
                        v20 |= v23;
                        --v21;
                      }
                      while (v21);
                    }
                  }
                  else
                  {
                    uint64_t v20 = 1;
                  }
                  BOOL v19 = v20 != 0;
                }
                if (v19) {
                  goto LABEL_54;
                }
                if (v38)
                {
                  BOOL v24 = 1;
                }
                else
                {
                  if (v37)
                  {
                    uint64_t v25 = *(void *)v36 ^ 1;
                    if ((int)v37 >= 2)
                    {
                      uint64_t v26 = v37 - 1;
                      int v27 = (uint64_t *)(v36 + 8);
                      do
                      {
                        uint64_t v28 = *v27++;
                        v25 |= v28;
                        --v26;
                      }
                      while (v26);
                    }
                  }
                  else
                  {
                    uint64_t v25 = 1;
                  }
                  BOOL v24 = v25 != 0;
                }
                if (v24)
                {
LABEL_54:
                  int v12 = 119;
                  __int16 v13 = 871;
                }
                else
                {
                  uint64_t v29 = a1[6];
                  if ((v29 != 0) != (a1[7] == 0) && (v29 != 0) != (a1[8] == 0))
                  {
                    if (v29)
                    {
                      uint64_t v31 = 0;
                      int v30 = 0;
                      if (!sub_244D34674((_DWORD *)&v31 + 1, a1[2], v29, (uint64_t)v35, v17, (uint64_t)v8)
                        || !sub_244D34674(&v31, a1[2], a1[7], (uint64_t)v34, v18, (uint64_t)v8)
                        || !sub_244D34674(&v30, a1[5], a1[8], a1[4], v17, (uint64_t)v8))
                      {
                        int v12 = 3;
                        __int16 v13 = 890;
                        goto LABEL_19;
                      }
                      if (!HIDWORD(v31) || !v31 || !v30)
                      {
                        int v12 = 111;
                        __int16 v13 = 895;
                        goto LABEL_19;
                      }
                    }
                    uint64_t v6 = 1;
                    goto LABEL_20;
                  }
                  int v12 = 123;
                  __int16 v13 = 878;
                }
              }
              else
              {
                int v12 = 3;
                __int16 v13 = 865;
              }
            }
            else
            {
              int v12 = 3;
              __int16 v13 = 857;
            }
          }
        }
        else
        {
          int v12 = 3;
          __int16 v13 = 843;
        }
LABEL_19:
        sub_244D0B884(4, 0, v12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", v13);
        uint64_t v6 = 0;
LABEL_20:
        sub_244D166B0((void **)&v39);
        sub_244D166B0((void **)&v36);
        sub_244D166B0(v35);
        sub_244D166B0(v34);
        sub_244D166B0(v33);
        sub_244D166B0(v32);
        sub_244D17500(v8);
        return v6;
      }
    }
    return 1;
  }
  return 0;
}

void sub_244D3306C(uint64_t a1)
{
  if (a1 && sub_244D49A14((unsigned int *)(a1 + 80)))
  {
    uint64_t v3 = *(void *)a1;
    int v4 = *(void (**)(uint64_t))(*(void *)a1 + 24);
    if (v4)
    {
      v4(a1);
      uint64_t v3 = *(void *)a1;
    }
    nullsub_13(v3, v2);
    sub_244D138A4((uint64_t)&unk_268EBD9B0, a1, (uint64_t *)(a1 + 72));
    sub_244D166B0(*(void ***)(a1 + 8));
    sub_244D166B0(*(void ***)(a1 + 16));
    sub_244D166B0(*(void ***)(a1 + 24));
    sub_244D166B0(*(void ***)(a1 + 32));
    sub_244D166B0(*(void ***)(a1 + 40));
    sub_244D166B0(*(void ***)(a1 + 48));
    sub_244D166B0(*(void ***)(a1 + 56));
    sub_244D166B0(*(void ***)(a1 + 64));
    sub_244D3367C(a1);
    j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 88));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D3313C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = sub_244D334EC(0);
  uint64_t v17 = (uint64_t)v16;
  if (!v16
    || !sub_244D32AF0((void ***)v16 + 1, a1)
    || !sub_244D32AF0((void ***)(v17 + 16), a2)
    || !sub_244D32AF0((void ***)(v17 + 24), a3)
    || !sub_244D32AF0((void ***)(v17 + 32), a4)
    || !sub_244D32AF0((void ***)(v17 + 40), a5)
    || !sub_244D32AF0((void ***)(v17 + 48), a6)
    || !sub_244D32AF0((void ***)(v17 + 56), a7)
    || !sub_244D32AF0((void ***)(v17 + 64), a8)
    || !sub_244D32B54((uint64_t *)v17))
  {
    sub_244D3306C(v17);
    return 0;
  }
  return v17;
}

uint64_t sub_244D33244(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_244D334EC(0);
  uint64_t v7 = (uint64_t)v6;
  if (!v6
    || !sub_244D32AF0((void ***)v6 + 1, a1)
    || !sub_244D32AF0((void ***)(v7 + 16), a2)
    || !sub_244D32AF0((void ***)(v7 + 24), a3)
    || !sub_244D32B54((uint64_t *)v7))
  {
    sub_244D3306C(v7);
    return 0;
  }
  return v7;
}

uint64_t sub_244D332D0(uint64_t a1, uint64_t a2)
{
  int v4 = sub_244D334EC(0);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    *((_DWORD *)v4 + 21) |= 0x40u;
    if (!sub_244D32AF0((void ***)v4 + 1, a1)
      || !sub_244D32AF0((void ***)(v5 + 24), a2)
      || !sub_244D32B54((uint64_t *)v5))
    {
      sub_244D3306C(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t sub_244D33354(uint64_t a1, uint64_t a2)
{
  int v4 = sub_244D334EC(0);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    *((_DWORD *)v4 + 21) |= 0x80u;
    if (!sub_244D32AF0((void ***)v4 + 1, a1)
      || !sub_244D32AF0((void ***)(v5 + 16), a2)
      || !sub_244D32B54((uint64_t *)v5))
    {
      sub_244D3306C(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t sub_244D333D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = sub_244D334EC(0);
  uint64_t v17 = (uint64_t)v16;
  if (v16)
  {
    *((_DWORD *)v16 + 21) |= 0x80u;
    if (!sub_244D32AF0((void ***)v16 + 1, a1)
      || !sub_244D32AF0((void ***)(v17 + 16), a2)
      || !sub_244D32AF0((void ***)(v17 + 24), a3)
      || !sub_244D32AF0((void ***)(v17 + 32), a4)
      || !sub_244D32AF0((void ***)(v17 + 40), a5)
      || !sub_244D32AF0((void ***)(v17 + 48), a6)
      || !sub_244D32AF0((void ***)(v17 + 56), a7)
      || !sub_244D32AF0((void ***)(v17 + 64), a8)
      || !sub_244D32B54((uint64_t *)v17))
    {
      sub_244D3306C(v17);
      return 0;
    }
  }
  return v17;
}

long long **sub_244D334EC(uint64_t a1)
{
  uint64_t v2 = (long long **)sub_244D44058(0x180uLL);
  int v4 = v2;
  if (!v2) {
    return v4;
  }
  if (!a1)
  {
    uint64_t v5 = *v2;
    if (*v4) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  uint64_t v5 = (long long *)sub_244D0740C(a1);
  *int v4 = v5;
  if (!v5)
  {
LABEL_4:
    sub_244D4BDB4(&stru_268EBDAA0, (void (*)(void))sub_244D35D5C);
    uint64_t v5 = &xmmword_268EC01D0;
    *int v4 = &xmmword_268EC01D0;
  }
LABEL_5:
  nullsub_13(v5, v3);
  *((_DWORD *)v4 + 20) = 1;
  *((_DWORD *)v4 + 21) = *((_DWORD *)*v4 + 18);
  sub_244D4BD2C((pthread_rwlock_t *)(v4 + 11));
  sub_244D1389C(v4 + 9);
  uint64_t v6 = (unsigned int (*)(long long **))*((void *)*v4 + 2);
  if (v6 && !v6(v4))
  {
    sub_244D138A4((uint64_t)&unk_268EBD9B0, (uint64_t)v4, (uint64_t *)v4 + 9);
    j__pthread_rwlock_destroy((pthread_rwlock_t *)(v4 + 11));
    nullsub_13(*v4, v7);
    sub_244D440EC(v4);
    return 0;
  }
  return v4;
}

long long *sub_244D335E8()
{
  return &xmmword_268EC01D0;
}

uint64_t sub_244D33620(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_244D334EC(a1);
  uint64_t v4 = (uint64_t)v3;
  if (v3 && sub_244D32AF0((void ***)v3 + 1, a2))
  {
    *(_DWORD *)(v4 + 84) |= 0x40u;
  }
  else
  {
    sub_244D3306C(v4);
    return 0;
  }
  return v4;
}

void sub_244D3367C(uint64_t a1)
{
  *(unsigned char *)(a1 + 376) &= ~1u;
  sub_244D1A288(*(void ***)(a1 + 288));
  *(void *)(a1 + 288) = 0;
  sub_244D1A288(*(void ***)(a1 + 296));
  *(void *)(a1 + 296) = 0;
  sub_244D1A288(*(void ***)(a1 + 304));
  *(void *)(a1 + 304) = 0;
  sub_244D166B0(*(void ***)(a1 + 312));
  *(void *)(a1 + 312) = 0;
  sub_244D166B0(*(void ***)(a1 + 320));
  *(void *)(a1 + 320) = 0;
  sub_244D166B0(*(void ***)(a1 + 328));
  *(void *)(a1 + 328) = 0;
  sub_244D166B0(*(void ***)(a1 + 336));
  *(void *)(a1 + 336) = 0;
  if (*(void *)(a1 + 344))
  {
    unint64_t v2 = 0;
    do
      sub_244D07DFC(*(void **)(*(void *)(a1 + 352) + 8 * v2++));
    while (v2 < *(void *)(a1 + 344));
  }
  sub_244D440EC(*(void **)(a1 + 352));
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  sub_244D440EC(*(void **)(a1 + 360));
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
}

uint64_t sub_244D33748(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D33768(uint64_t a1)
{
  return sub_244D168EC(*(uint64_t **)(a1 + 8));
}

uint64_t sub_244D33770(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

void *sub_244D33778(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = result[1];
  }
  if (a3) {
    *a3 = result[2];
  }
  if (a4) {
    *a4 = result[3];
  }
  return result;
}

uint64_t sub_244D337A0(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(result + 32);
  }
  if (a3) {
    *a3 = *(void *)(result + 40);
  }
  return result;
}

void *sub_244D337BC(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = result[6];
  }
  if (a3) {
    *a3 = result[7];
  }
  if (a4) {
    *a4 = result[8];
  }
  return result;
}

uint64_t sub_244D337E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(void *)(a1 + 8);
  if (!(a2 | v5) || !(a3 | *(void *)(a1 + 16))) {
    return 0;
  }
  if (a2)
  {
    sub_244D166B0((void **)v5);
    *(void *)(a1 + 8) = a2;
  }
  if (a3)
  {
    sub_244D166B0(*(void ***)(a1 + 16));
    *(void *)(a1 + 16) = a3;
  }
  if (a4)
  {
    sub_244D166B0(*(void ***)(a1 + 24));
    *(void *)(a1 + 24) = a4;
  }
  sub_244D3367C(a1);
  return 1;
}

uint64_t sub_244D33870(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!(a2 | v4) || !(a3 | *(void *)(a1 + 40))) {
    return 0;
  }
  if (a2)
  {
    sub_244D166B0((void **)v4);
    *(void *)(a1 + 32) = a2;
  }
  if (a3)
  {
    sub_244D166B0(*(void ***)(a1 + 40));
    *(void *)(a1 + 40) = a3;
  }
  sub_244D3367C(a1);
  return 1;
}

uint64_t sub_244D338E8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = a1[6];
  if (!(a2 | v5) || !(a3 | a1[7]) || !(a4 | a1[8])) {
    return 0;
  }
  if (a2)
  {
    sub_244D166B0((void **)v5);
    a1[6] = a2;
  }
  if (a3)
  {
    sub_244D166B0((void **)a1[7]);
    a1[7] = a3;
  }
  if (a4)
  {
    sub_244D166B0((void **)a1[8]);
    a1[8] = a4;
  }
  sub_244D3367C((uint64_t)a1);
  return 1;
}

uint64_t sub_244D33984(uint64_t **a1, size_t *a2, char *a3, unint64_t a4, void *a5, size_t a6, int a7)
{
  uint64_t v7 = (uint64_t (*)(void))(*a1)[6];
  if (v7) {
    return v7();
  }
  else {
    return sub_244D34E40(a1, a2, a3, a4, a5, a6, a7);
  }
}

uint64_t sub_244D33998(uint64_t a1)
{
  return (sub_244D168EC(*(uint64_t **)(a1 + 8)) + 7) >> 3;
}

uint64_t sub_244D339BC(uint64_t a1)
{
  if (*(void *)a1) {
    return *(_DWORD *)(*(void *)a1 + 72) & 1;
  }
  else {
    return 0;
  }
}

uint64_t sub_244D339D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D136D4((uint64_t)&unk_268EBD9B0, a1, a2, a5);
}

uint64_t sub_244D339F0(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_244D137A8((unint64_t **)(a1 + 72), a2, a3);
}

unint64_t *sub_244D339F8(uint64_t a1, unsigned int a2)
{
  return sub_244D13838((uint64_t *)(a1 + 72), a2);
}

uint64_t sub_244D33A00(uint64_t *a1, size_t *a2, _DWORD *a3, int a4, const void *a5, size_t a6)
{
  uint64_t result = sub_244D33B48(a4, a6);
  if (result)
  {
    if (a4 == 114)
    {
      *a1 = (uint64_t)a5;
      *a2 = a6;
      uint64_t result = 1;
      *a3 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 4;
      while (v14 != a4)
      {
        int v14 = *(_DWORD *)&byte_244EB7240[v13 + 28];
        v13 += 28;
        if (v13 == 168)
        {
          int v15 = 142;
          __int16 v16 = 593;
LABEL_11:
          sub_244D0B884(4, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", v16);
          return 0;
        }
      }
      size_t v17 = byte_244EB7240[v13 + 5];
      if (__CFADD__(v17, a6))
      {
        int v15 = 140;
        __int16 v16 = 574;
        goto LABEL_11;
      }
      uint64_t result = (uint64_t)sub_244D43FF4(v17 + a6);
      if (result)
      {
        uint64_t v18 = result;
        memcpy((void *)result, &byte_244EB7240[v13 + 6], v17);
        if (a6) {
          memcpy((void *)(v18 + v17), a5, a6);
        }
        *a1 = v18;
        *a2 = v17 + a6;
        uint64_t result = 1;
        *a3 = 1;
      }
    }
  }
  return result;
}

uint64_t sub_244D33B48(int a1, uint64_t a2)
{
  if (a1 != 114)
  {
    uint64_t v4 = 0;
    int v5 = 4;
    while (v5 != a1)
    {
      int v5 = *(_DWORD *)&byte_244EB7240[v4 + 28];
      v4 += 28;
      if (v4 == 168)
      {
        int v2 = 142;
        __int16 v3 = 541;
        goto LABEL_11;
      }
    }
    if (byte_244EB7240[v4 + 4] != a2)
    {
      int v2 = 125;
      __int16 v3 = 534;
      goto LABEL_11;
    }
    return 1;
  }
  if (a2 == 36) {
    return 1;
  }
  int v2 = 125;
  __int16 v3 = 524;
LABEL_11:
  sub_244D0B884(4, 0, v2, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", v3);
  return 0;
}

uint64_t sub_244D33C08(uint64_t a1, const void *a2, size_t a3, char *a4, _DWORD *a5, uint64_t **a6)
{
  if (!(*a6)[5])
  {
    int v14 = (uint64_t (*)(uint64_t **))(*a6)[4];
    if (v14) {
      unsigned int v15 = v14(a6);
    }
    else {
      unsigned int v15 = (sub_244D168EC(a6[1]) + 7) >> 3;
    }
    size_t v19 = 0;
    uint64_t v20 = 0;
    int v18 = 0;
    size_t v17 = 0;
    if (sub_244D33A00((uint64_t *)&v20, &v19, &v18, a1, a2, a3)
      && sub_244D33984(a6, &v17, a4, v15, v20, v19, 1))
    {
      if (!HIDWORD(v17))
      {
        *a5 = v17;
        uint64_t v16 = 1;
LABEL_16:
        if (v18) {
          sub_244D440EC(v20);
        }
        return v16;
      }
      sub_244D0B884(4, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 627);
    }
    uint64_t v16 = 0;
    goto LABEL_16;
  }
  if (!sub_244D33B48(a1, a3)) {
    return 0;
  }
  int v12 = (uint64_t (*)(uint64_t, const void *, size_t, char *, _DWORD *, uint64_t **))(*a6)[5];

  return v12(a1, a2, a3, a4, a5, a6);
}

BOOL sub_244D33D90(uint64_t **a1, size_t *a2, char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if (*(_DWORD *)(a7 + 4) != a6)
  {
    sub_244D0B884(4, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 652);
    return 0;
  }
  uint64_t v16 = (uint64_t (*)(uint64_t **))(*a1)[4];
  if (v16) {
    unsigned int v17 = v16(a1);
  }
  else {
    unsigned int v17 = (sub_244D168EC(a1[1]) + 7) >> 3;
  }
  size_t v18 = v17;
  size_t v19 = (char *)sub_244D43FF4(v17);
  if (!v19) {
    return 0;
  }
  uint64_t v20 = v19;
  if (sub_244D3277C(a1, v19, a5, a7, a8, a9)) {
    BOOL v21 = sub_244D33984(a1, a2, a3, a4, v20, v18, 3) != 0;
  }
  else {
    BOOL v21 = 0;
  }
  sub_244D440EC(v20);
  return v21;
}

uint64_t sub_244D33EB4(int a1, const void *a2, size_t a3, unsigned __int8 *a4, unint64_t a5, void *a6)
{
  uint64_t v7 = (uint64_t *)a6[1];
  if (!v7 || !a6[2])
  {
    int v15 = 144;
    __int16 v16 = 674;
LABEL_10:
    sub_244D0B884(4, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", v16);
    return 0;
  }
  uint64_t v13 = *(uint64_t (**)(void *))(*a6 + 32);
  if (v13) {
    unsigned int v14 = v13(a6);
  }
  else {
    unsigned int v14 = (sub_244D168EC(v7) + 7) >> 3;
  }
  size_t v24 = 0;
  __s2 = 0;
  size_t v23 = 0;
  int v22 = 0;
  if (a1 == 114 && a3 != 36)
  {
    int v15 = 125;
    __int16 v16 = 686;
    goto LABEL_10;
  }
  unint64_t v19 = v14;
  uint64_t v20 = (char *)sub_244D43FF4(v14);
  if (!v20) {
    return 0;
  }
  BOOL v21 = v20;
  if (!sub_244D34054((uint64_t)a6, &v23, v20, v19, a4, a5, 1)
    || !sub_244D33A00((uint64_t *)&__s2, &v24, &v22, a1, a2, a3))
  {
    goto LABEL_20;
  }
  if (v23 != v24 || v23 && memcmp(v21, __s2, v23))
  {
    sub_244D0B884(4, 0, 105, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 706);
LABEL_20:
    uint64_t v17 = 0;
    goto LABEL_21;
  }
  uint64_t v17 = 1;
LABEL_21:
  sub_244D440EC(v21);
  if (v22) {
    sub_244D440EC(__s2);
  }
  return v17;
}

uint64_t sub_244D34054(uint64_t a1, size_t *a2, char *a3, unint64_t a4, unsigned __int8 *a5, unint64_t a6, int a7)
{
  if (!*(void *)(a1 + 8) || !*(void *)(a1 + 16))
  {
    int v16 = 144;
    __int16 v17 = 492;
LABEL_7:
    sub_244D0B884(4, 0, v16, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v17);
    return 0;
  }
  if (!sub_244D344BC(a1)) {
    return 0;
  }
  unsigned int v14 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 32);
  if (v14) {
    unsigned int v15 = v14(a1);
  }
  else {
    unsigned int v15 = (sub_244D168EC(*(uint64_t **)(a1 + 8)) + 7) >> 3;
  }
  if (v15 > a4)
  {
    int v16 = 135;
    __int16 v17 = 504;
    goto LABEL_7;
  }
  if (v15 != a6)
  {
    int v16 = 112;
    __int16 v17 = 509;
    goto LABEL_7;
  }
  uint64_t v20 = sub_244D43FF4(0x30uLL);
  if (!v20) {
    return 0;
  }
  uint64_t v21 = (uint64_t)v20;
  *(_OWORD *)((char *)v20 + 26) = 0u;
  *(_OWORD *)uint64_t v20 = 0u;
  *((_OWORD *)v20 + 1) = 0u;
  sub_244D1756C(v20);
  int v22 = sub_244D17610(v21);
  size_t v23 = sub_244D17610(v21);
  uint64_t v31 = 0;
  uint64_t v18 = 0;
  if (v22)
  {
    uint64_t v24 = (uint64_t)v23;
    if (v23)
    {
      uint64_t v25 = a3;
      if (a7 != 3)
      {
        uint64_t v25 = (char *)sub_244D43FF4(a6);
        if (!v25)
        {
          uint64_t v18 = 0;
          uint64_t v31 = 0;
          goto LABEL_24;
        }
      }
      uint64_t v31 = v25;
      if (!sub_244D16D20(a5, a6, v22)) {
        goto LABEL_23;
      }
      uint64_t v26 = *(void *)(a1 + 8);
      if ((sub_244D170B4((uint64_t *)*v22, *((int *)v22 + 2), *(uint64_t **)v26, *(int *)(v26 + 8)) & 0x80000000) == 0)
      {
        int v27 = 115;
        __int16 v28 = 543;
LABEL_22:
        sub_244D0B884(4, 0, v27, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v28);
LABEL_23:
        uint64_t v18 = 0;
        goto LABEL_24;
      }
      if (!sub_244D1E430((void *)(a1 + 288), (pthread_rwlock_t *)(a1 + 88), v26, v21)
        || !sub_244D19BB4(v24, (uint64_t)v22, *(void *)(a1 + 16), *(void *)(a1 + 288) + 24, v21, *(void *)(a1 + 288)))
      {
        goto LABEL_23;
      }
      if (!sub_244D16FA8(v31, a6, v24))
      {
        int v27 = 68;
        __int16 v28 = 553;
        goto LABEL_22;
      }
      if (a7 == 3)
      {
        *a2 = a6;
      }
      else
      {
        if (a7 != 1)
        {
          int v27 = 143;
          __int16 v28 = 567;
          goto LABEL_22;
        }
        if (!sub_244D32088(a3, a2, a6, v31, a6))
        {
          int v27 = 136;
          __int16 v28 = 572;
          goto LABEL_22;
        }
      }
      uint64_t v18 = 1;
    }
  }
LABEL_24:
  if (!*(unsigned char *)(v21 + 40))
  {
    uint64_t v29 = *(void *)(v21 + 8);
    uint64_t v30 = *(void *)(v21 + 16) - 1;
    *(void *)(v21 + 16) = v30;
    *(void *)(v21 + 32) = *(void *)(v29 + 8 * v30);
  }
  sub_244D17500((unint64_t **)v21);
  if (v31 != a3) {
    sub_244D440EC(v31);
  }
  return v18;
}

uint64_t sub_244D3433C(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned __int8 *a7, unint64_t a8)
{
  if (*(_DWORD *)(a4 + 4) == a3)
  {
    unsigned int v15 = (uint64_t (*)(uint64_t **))(*a1)[4];
    if (v15) {
      unsigned int v16 = v15(a1);
    }
    else {
      unsigned int v16 = (sub_244D168EC(a1[1]) + 7) >> 3;
    }
    unint64_t v17 = v16;
    size_t v25 = v16;
    uint64_t v18 = (char *)sub_244D43FF4(v16);
    if (v18)
    {
      unint64_t v19 = v18;
      if (sub_244D34054((uint64_t)a1, &v25, v18, v17, a7, a8, 3))
      {
        size_t v20 = v25;
        uint64_t v21 = (uint64_t (*)(uint64_t **))(*a1)[4];
        if (v21) {
          unsigned int v22 = v21(a1);
        }
        else {
          unsigned int v22 = (sub_244D168EC(a1[1]) + 7) >> 3;
        }
        if (v20 == v22)
        {
          uint64_t v23 = sub_244D323BC(a1, a2, a4, a5, v19, a6);
LABEL_16:
          sub_244D440EC(v19);
          return v23;
        }
        sub_244D0B884(4, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 747);
      }
      uint64_t v23 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    sub_244D0B884(4, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 731);
  }
  return 0;
}

uint64_t sub_244D344BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1)
  {
    int v4 = 144;
    __int16 v5 = 78;
    goto LABEL_11;
  }
  unsigned int v3 = sub_244D168EC(*(uint64_t **)(a1 + 8));
  if (v3 > 0x4000)
  {
    int v4 = 128;
    __int16 v5 = 86;
LABEL_11:
    sub_244D0B884(4, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v5);
    return 0;
  }
  if (v3 <= 0x1FF)
  {
    int v4 = 126;
    __int16 v5 = 93;
    goto LABEL_11;
  }
  unint64_t v6 = *(unsigned int *)(v1 + 8);
  if ((int)v6 < 1 || (uint64_t v7 = *(uint64_t **)v1, (**(unsigned char **)v1 & 1) == 0) || *(_DWORD *)(v1 + 16))
  {
    int v4 = 104;
    __int16 v5 = 100;
    goto LABEL_11;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    unsigned int v10 = sub_244D168EC(*(uint64_t **)(a1 + 16));
    if (v10 < 2 || *(_DWORD *)(v9 + 16) || (unint64_t v11 = *(unsigned int *)(v9 + 8), (int)v11 < 1) || (**(unsigned char **)v9 & 1) == 0)
    {
      int v4 = 101;
      __int16 v5 = 110;
      goto LABEL_11;
    }
    if ((*(unsigned char *)(a1 + 84) & 0x80) != 0)
    {
      if ((int)sub_244D170B4(v7, v6, *(uint64_t **)v9, v11) <= 0)
      {
        int v4 = 101;
        __int16 v5 = 117;
        goto LABEL_11;
      }
    }
    else if (v10 >= 0x22)
    {
      int v4 = 101;
      __int16 v5 = 131;
      goto LABEL_11;
    }
  }
  else if ((*(unsigned char *)(a1 + 84) & 0x40) == 0)
  {
    int v4 = 144;
    __int16 v5 = 140;
    goto LABEL_11;
  }
  return 1;
}

uint64_t sub_244D34674(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  if (*(_DWORD *)(a3 + 16) || (int)sub_244D17194(a3, a4) >= 0)
  {
    *a1 = 0;
    return 1;
  }
  else
  {
    sub_244D1756C((void *)a6);
    uint64_t result = (uint64_t)sub_244D17610(a6);
    if (result)
    {
      uint64_t v13 = (void **)result;
      uint64_t result = sub_244D1C868(result, a2, a3, a6);
      if (result)
      {
        uint64_t result = sub_244D18204(0, v13, (uint64_t)v13, a4, a5, a6);
        if (result)
        {
          *a1 = sub_244D172C8((unsigned int *)v13);
          uint64_t result = 1;
        }
      }
    }
    if (!*(unsigned char *)(a6 + 40))
    {
      uint64_t v14 = *(void *)(a6 + 8);
      uint64_t v15 = *(void *)(a6 + 16) - 1;
      *(void *)(a6 + 16) = v15;
      *(void *)(a6 + 32) = *(void *)(v14 + 8 * v15);
    }
  }
  return result;
}

uint64_t sub_244D34764(uint64_t *a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*a1 && (*(unsigned char *)(*a1 + 72) & 1) != 0)
  {
    sub_244D0B884(4, 0, 146, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 939);
    return 0;
  }
  if (!sub_244D32B54(a1)) {
    return 0;
  }
  int v2 = sub_244D43FF4(0x30uLL);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = (unint64_t **)v2;
  *(_OWORD *)((char *)v2 + 26) = 0u;
  _OWORD *v2 = 0u;
  v2[1] = 0u;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  int v20 = 0;
  uint64_t v4 = a1[2];
  if (sub_244D168EC((uint64_t *)v4) - 257 < 0xFFFFFF10) {
    goto LABEL_10;
  }
  uint64_t v5 = a1[1];
  if (*(int *)(v5 + 8) < 1) {
    goto LABEL_10;
  }
  if ((**(unsigned char **)v5 & 1) == 0) {
    goto LABEL_10;
  }
  if (*(int *)(v4 + 8) < 1) {
    goto LABEL_10;
  }
  if ((**(unsigned char **)v4 & 1) == 0) {
    goto LABEL_10;
  }
  sub_244D4BDB4(&stru_268EBDA90, (void (*)(void))sub_244D436B0);
  if (!sub_244D1C358((uint64_t *)&v21, v5, (uint64_t)&qword_268EC01B8, (uint64_t)v3)
    || v23
    || !v22)
  {
    goto LABEL_10;
  }
  uint64_t v13 = *v21 ^ 1;
  if ((int)v22 >= 2)
  {
    uint64_t v14 = v22 - 1;
    uint64_t v15 = v21 + 1;
    do
    {
      uint64_t v16 = *v15++;
      v13 |= v16;
      --v14;
    }
    while (v14);
  }
  if (!v13 && (sub_244D202B8(&v20, a1[1], 0, (uint64_t)v3, 0) ? (BOOL v17 = v20 == 2) : (BOOL v17 = 0), v17))
  {
    char v7 = 0;
    uint64_t v6 = 1;
  }
  else
  {
LABEL_10:
    sub_244D0B884(4, 0, 146, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", 974);
    uint64_t v6 = 0;
    char v7 = 1;
  }
  sub_244D166B0(&v21);
  sub_244D17500(v3);
  if ((v7 & 1) == 0 && a1[3] && a1[4])
  {
    memset(v24, 0, sizeof(v24));
    uint64_t v8 = *(uint64_t (**)(uint64_t *))(*a1 + 32);
    if (v8) {
      unsigned int v9 = v8(a1);
    }
    else {
      unsigned int v9 = (sub_244D168EC((uint64_t *)a1[1]) + 7) >> 3;
    }
    unsigned int v19 = v9;
    unint64_t v11 = (char *)sub_244D43FF4(v9);
    if (v11)
    {
      int v12 = (unsigned __int8 *)v11;
      if (sub_244D33C08(672, v24, 0x20uLL, v11, &v19, (uint64_t **)a1))
      {
        if (sub_244D33EB4(672, v24, 0x20uLL, v12, v19, a1))
        {
          uint64_t v6 = 1;
LABEL_40:
          sub_244D440EC(v12);
          return v6;
        }
        __int16 v18 = 1007;
      }
      else
      {
        __int16 v18 = 999;
      }
      sub_244D0B884(4, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa.c", v18);
      uint64_t v6 = 0;
      goto LABEL_40;
    }
    return 0;
  }
  return v6;
}

uint64_t sub_244D34A28(uint64_t a1, char *a2, unsigned __int8 *a3, unint64_t a4)
{
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)a1 + 64);
  if (v4) {
    return v4();
  }
  else {
    return sub_244D34A3C(a1, a2, a3, a4);
  }
}

uint64_t sub_244D34A3C(uint64_t a1, char *a2, unsigned __int8 *a3, unint64_t a4)
{
  if (!*(void *)(a1 + 8) || !*(void *)(a1 + 24))
  {
    sub_244D0B884(4, 0, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", 596);
    return 0;
  }
  uint64_t v41 = 0;
  uint64_t v8 = sub_244D43FF4(0x30uLL);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = (uint64_t)v8;
  *(_OWORD *)((char *)v8 + 26) = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  sub_244D1756C(v8);
  unsigned int v10 = sub_244D17610(v9);
  unint64_t v11 = sub_244D17610(v9);
  int v12 = 0;
  uint64_t v13 = 0;
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v14 = v11;
  if (!v11) {
    goto LABEL_11;
  }
  if (!sub_244D16D20(a3, a4, v10)) {
    goto LABEL_10;
  }
  if ((int)sub_244D170B4((uint64_t *)*v10, *((int *)v10 + 2), **(uint64_t ***)(a1 + 8), *(int *)(*(void *)(a1 + 8) + 8)) < 0)
  {
    if (!sub_244D34FB4(a1, v9))
    {
      int v15 = 68;
      __int16 v16 = 633;
      goto LABEL_9;
    }
    int v21 = *(_DWORD *)(a1 + 84) & 0x48;
    if (!*(void *)(a1 + 16) && !v21)
    {
      int v15 = 130;
      __int16 v16 = 649;
      goto LABEL_9;
    }
    if (v21)
    {
      int v12 = 0;
    }
    else
    {
      int v12 = sub_244D35188(a1, &v41);
      if (!v12)
      {
        __int16 v33 = 656;
        goto LABEL_54;
      }
      if (!sub_244D31E20((uint64_t)v10, (uint64_t)v12, *(void *)(a1 + 16), *(void *)(a1 + 288), v9)) {
        goto LABEL_55;
      }
    }
    uint64_t v22 = *(uint64_t **)(a1 + 32);
    if (!v22) {
      goto LABEL_39;
    }
    uint64_t v23 = *(uint64_t **)(a1 + 40);
    if (!v23) {
      goto LABEL_39;
    }
    if (!*(void *)(a1 + 16)) {
      goto LABEL_39;
    }
    if (!*(void *)(a1 + 48)) {
      goto LABEL_39;
    }
    if (!*(void *)(a1 + 56)) {
      goto LABEL_39;
    }
    if (!*(void *)(a1 + 64)) {
      goto LABEL_39;
    }
    if (*((_DWORD *)v23 + 4)) {
      goto LABEL_39;
    }
    uint64_t v24 = *(int *)(*(void *)(a1 + 296) + 32);
    uint64_t v25 = *((int *)v23 + 2);
    if (v25 > v24)
    {
      uint64_t v26 = 0;
      uint64_t v27 = *v23;
      uint64_t v28 = v25 - v24;
      uint64_t v29 = (uint64_t *)(v27 + 8 * v24);
      do
      {
        uint64_t v30 = *v29++;
        v26 |= v30;
        --v28;
      }
      while (v28);
      if (v26) {
        goto LABEL_39;
      }
    }
    if (*((_DWORD *)v22 + 4)) {
      goto LABEL_39;
    }
    uint64_t v34 = *(int *)(*(void *)(a1 + 304) + 32);
    uint64_t v35 = *((int *)v22 + 2);
    if (v35 <= v34) {
      goto LABEL_64;
    }
    uint64_t v36 = 0;
    uint64_t v37 = *v22;
    uint64_t v38 = v35 - v34;
    int v39 = (uint64_t *)(v37 + 8 * v34);
    do
    {
      uint64_t v40 = *v39++;
      v36 |= v40;
      --v38;
    }
    while (v38);
    if (!v36)
    {
LABEL_64:
      if (!sub_244D353A4((void **)v14, (uint64_t)v10, (void *)a1, v9)) {
        goto LABEL_55;
      }
    }
    else
    {
LABEL_39:
      if (!sub_244D1A91C((uint64_t)v14, (uint64_t)v10, *(void *)(a1 + 312), *(void *)(a1 + 8), v9, *(void *)(a1 + 288)))
      {
LABEL_55:
        uint64_t v13 = 0;
        goto LABEL_11;
      }
    }
    if (!*(void *)(a1 + 16)
      || (uint64_t v31 = sub_244D17610(v9)) != 0
      && (uint64_t v32 = (uint64_t)v31,
          sub_244D19BB4((uint64_t)v31, (uint64_t)v14, *(void *)(a1 + 16), *(void *)(a1 + 8), v9, *(void *)(a1 + 288)))&& sub_244D17428(v32, (uint64_t)v10))
    {
      if (!v21 && !sub_244D1A118((uint64_t)v14, (uint64_t)v14, v12[1], *(void *)(a1 + 288), v9)) {
        goto LABEL_55;
      }
      if (sub_244D16FA8(a2, a4, (uint64_t)v14))
      {
        uint64_t v13 = 1;
        goto LABEL_11;
      }
      __int16 v33 = 713;
    }
    else
    {
      __int16 v33 = 695;
    }
LABEL_54:
    sub_244D0B884(4, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v33);
    goto LABEL_55;
  }
  int v15 = 115;
  __int16 v16 = 628;
LABEL_9:
  sub_244D0B884(4, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v16);
LABEL_10:
  uint64_t v13 = 0;
  int v12 = 0;
LABEL_11:
  if (!*(unsigned char *)(v9 + 40))
  {
    uint64_t v17 = *(void *)(v9 + 8);
    uint64_t v18 = *(void *)(v9 + 16) - 1;
    *(void *)(v9 + 16) = v18;
    *(void *)(v9 + 32) = *(void *)(v17 + 8 * v18);
  }
  sub_244D17500((unint64_t **)v9);
  if (v12)
  {
    uint64_t v19 = v41;
    if (v41 == 1024)
    {
      sub_244D07DFC(v12);
    }
    else
    {
      sub_244D4BD70((pthread_rwlock_t *)(a1 + 88));
      *(unsigned char *)(*(void *)(a1 + 360) + v19) = 0;
      sub_244D4BD90((pthread_rwlock_t *)(a1 + 88));
    }
  }
  return v13;
}

uint64_t sub_244D34E2C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t sub_244D34E34(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 84) & a2;
}

uint64_t sub_244D34E40(uint64_t **a1, size_t *a2, char *a3, unint64_t a4, void *a5, size_t a6, int a7)
{
  uint64_t v14 = (uint64_t (*)(uint64_t **))(*a1)[4];
  if (v14) {
    unsigned int v15 = v14(a1);
  }
  else {
    unsigned int v15 = (sub_244D168EC(a1[1]) + 7) >> 3;
  }
  size_t v16 = v15;
  if (v15 <= a4)
  {
    uint64_t v18 = (unsigned __int8 *)sub_244D43FF4(v15);
    uint64_t v19 = v18;
    if (v18)
    {
      if (a7 == 3)
      {
        if (!sub_244D321EC(v18, v16, a5, a6)) {
          goto LABEL_16;
        }
      }
      else
      {
        if (a7 != 1)
        {
          sub_244D0B884(4, 0, 143, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", 463);
          goto LABEL_16;
        }
        if (!sub_244D31FB8(v18, v16, a5, a6)) {
          goto LABEL_16;
        }
      }
      int v20 = (unsigned int (*)(uint64_t **, char *, unsigned __int8 *, size_t))(*a1)[8];
      if (v20)
      {
        if (!v20(a1, a3, v19, v16)) {
          goto LABEL_16;
        }
LABEL_20:
        *a2 = v16;
        uint64_t v17 = 1;
        goto LABEL_17;
      }
      if (sub_244D34A3C((uint64_t)a1, a3, v19, v16)) {
        goto LABEL_20;
      }
    }
LABEL_16:
    uint64_t v17 = 0;
LABEL_17:
    sub_244D440EC(v19);
    return v17;
  }
  sub_244D0B884(4, 0, 135, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", 446);
  return 0;
}

uint64_t sub_244D34FB4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_rwlock_t *)(a1 + 88);
  sub_244D4BD50((pthread_rwlock_t *)(a1 + 88));
  char v5 = *(unsigned char *)(a1 + 376);
  sub_244D4BD90(v4);
  if ((v5 & 1) == 0)
  {
    sub_244D4BD70(v4);
    if (*(unsigned char *)(a1 + 376))
    {
LABEL_25:
      uint64_t v14 = 1;
LABEL_34:
      sub_244D4BD90(v4);
      return v14;
    }
    if (!sub_244D344BC(a1)) {
      goto LABEL_33;
    }
    uint64_t v6 = *(void ***)(a1 + 288);
    if (!v6)
    {
      uint64_t v6 = sub_244D1B1E0(*(void *)(a1 + 8), a2);
      *(void *)(a1 + 288) = v6;
      if (!v6) {
        goto LABEL_33;
      }
    }
    uint64_t v7 = *(void *)(a1 + 24);
    if (v7)
    {
      if (!sub_244D436D4((void ***)(a1 + 312), v7, *((_DWORD *)v6 + 8))) {
        goto LABEL_33;
      }
    }
    if (!*(void *)(a1 + 16)) {
      goto LABEL_24;
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (!v8 || !*(void *)(a1 + 40)) {
      goto LABEL_24;
    }
    if ((uint64_t v9 = *(void ***)(a1 + 296)) == 0 && (uint64_t v9 = sub_244D1A0A4(v8, a2), (*(void *)(a1 + 296) = v9) == 0)
      || (unsigned int v10 = *(void ***)(a1 + 304)) == 0
      && (unsigned int v10 = sub_244D1A0A4(*(void *)(a1 + 40), a2), (*(void *)(a1 + 304) = v10) == 0))
    {
LABEL_33:
      uint64_t v14 = 0;
      goto LABEL_34;
    }
    uint64_t v11 = *(void *)(a1 + 48);
    if (!v11 || !*(void *)(a1 + 56)) {
      goto LABEL_24;
    }
    if (!*(void *)(a1 + 64))
    {
      unsigned int v15 = sub_244D16670();
      size_t v16 = (void **)v15;
      if (!v15
        || !sub_244D1C2AC((uint64_t)v15, *(void *)(a1 + 40), *(void *)(a1 + 32), a2, *(void *)(a1 + 296)))
      {
        uint64_t v17 = v16;
LABEL_32:
        sub_244D166B0(v17);
        goto LABEL_33;
      }
      *(void *)(a1 + 64) = v16;
      uint64_t v11 = *(void *)(a1 + 48);
    }
    if (!sub_244D436D4((void ***)(a1 + 320), v11, *((_DWORD *)v9 + 8))
      || !sub_244D436D4((void ***)(a1 + 328), *(void *)(a1 + 56), *((_DWORD *)v10 + 8)))
    {
      goto LABEL_33;
    }
    if (*(void *)(a1 + 336))
    {
LABEL_24:
      *(unsigned char *)(a1 + 376) |= 1u;
      goto LABEL_25;
    }
    int v12 = sub_244D16670();
    uint64_t v13 = (void **)v12;
    if (v12
      && sub_244D1A118((uint64_t)v12, *(void *)(a1 + 64), *(void *)(a1 + 296), *(void *)(a1 + 296), a2))
    {
      *(void *)(a1 + 336) = v13;
      goto LABEL_24;
    }
    uint64_t v17 = v13;
    goto LABEL_32;
  }
  return 1;
}

void *sub_244D35188(uint64_t a1, void *a2)
{
  sub_244D4BDB4(&stru_268EBD9A0, (void (*)(void))sub_244D31D3C);
  uint64_t v4 = qword_268EC01B0;
  char v5 = (pthread_rwlock_t *)(a1 + 88);
  sub_244D4BD70((pthread_rwlock_t *)(a1 + 88));
  size_t v6 = *(void *)(a1 + 344);
  if (*(void *)(a1 + 368) != v4)
  {
    if (v6)
    {
      for (size_t i = 0; i < v6; ++i)
      {
        *(_DWORD *)(*(void *)(*(void *)(a1 + 352) + 8 * i) + 16) = 31;
        size_t v6 = *(void *)(a1 + 344);
      }
    }
    *(void *)(a1 + 368) = v4;
  }
  if (v6)
  {
    uint64_t v8 = memchr(*(void **)(a1 + 360), 0, v6);
    if (v8)
    {
      *uint64_t v8 = 1;
      uint64_t v9 = &v8[-*(void *)(a1 + 360)];
      *a2 = v9;
      unsigned int v10 = *(void **)(*(void *)(a1 + 352) + 8 * (void)v9);
      goto LABEL_32;
    }
    if (v6 >= 0x400)
    {
      *a2 = 1024;
      unsigned int v10 = sub_244D31DB4();
      goto LABEL_32;
    }
  }
  uint64_t v11 = 2 * v6;
  if (2 * v6 >= 0x400) {
    uint64_t v11 = 1024;
  }
  if (v6) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 1;
  }
  uint64_t v13 = sub_244D44098(v12, 8uLL);
  uint64_t v14 = (char *)sub_244D43FF4(v12);
  unsigned int v15 = v14;
  if (v13) {
    BOOL v16 = v14 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16)
  {
    size_t v17 = *(void *)(a1 + 344);
    if (8 * v17)
    {
      memcpy(v13, *(const void **)(a1 + 352), 8 * v17);
      size_t v17 = *(void *)(a1 + 344);
    }
    if (v17)
    {
      memcpy(v15, *(const void **)(a1 + 360), v17);
      unint64_t v18 = *(void *)(a1 + 344);
    }
    else
    {
      unint64_t v18 = 0;
    }
    if (v18 >= v12)
    {
LABEL_31:
      bzero(&v15[v18], v12 - v18);
      v15[*(void *)(a1 + 344)] = 1;
      *a2 = *(void *)(a1 + 344);
      unsigned int v10 = (void *)v13[*(void *)(a1 + 344)];
      sub_244D440EC(*(void **)(a1 + 352));
      *(void *)(a1 + 352) = v13;
      sub_244D440EC(*(void **)(a1 + 360));
      *(void *)(a1 + 360) = v15;
      *(void *)(a1 + 344) = v12;
      goto LABEL_32;
    }
    while (1)
    {
      uint64_t v19 = sub_244D31DB4();
      v13[v18] = v19;
      if (!v19) {
        break;
      }
      if (v12 == ++v18)
      {
        unint64_t v18 = *(void *)(a1 + 344);
        goto LABEL_31;
      }
    }
    for (unint64_t j = *(void *)(a1 + 344); j < v18; ++j)
      sub_244D07DFC((void *)v13[j]);
  }
  sub_244D440EC(v15);
  sub_244D440EC(v13);
  unsigned int v10 = 0;
LABEL_32:
  sub_244D4BD90(v5);
  return v10;
}

uint64_t sub_244D353A4(void **a1, uint64_t a2, void *a3, uint64_t a4)
{
  sub_244D1756C((void *)a4);
  uint64_t v8 = sub_244D17610(a4);
  uint64_t v9 = sub_244D17610(a4);
  uint64_t result = 0;
  if (v8)
  {
    if (v9)
    {
      uint64_t result = sub_244D34FB4((uint64_t)a3, a4);
      if (result)
      {
        uint64_t v11 = a3[36];
        uint64_t v12 = a3[37] + 24;
        uint64_t v13 = a3[38];
        uint64_t result = sub_244D43740((uint64_t)v8, a2, v13, v12, a4);
        if (result)
        {
          uint64_t v14 = v13 + 24;
          uint64_t result = sub_244D1A91C((uint64_t)v9, (uint64_t)v8, a3[41], v14, a4, a3[38]);
          if (result)
          {
            uint64_t result = sub_244D43740((uint64_t)v8, a2, a3[37], v14, a4);
            if (result)
            {
              uint64_t result = sub_244D1A91C((uint64_t)a1, (uint64_t)v8, a3[40], v12, a4, a3[37]);
              if (result)
              {
                uint64_t result = sub_244D43740((uint64_t)v8, (uint64_t)v9, a3[37], v14, a4);
                if (result)
                {
                  uint64_t result = sub_244D18804((uint64_t)a1, (uint64_t)a1, (uint64_t)v8, v12, a4);
                  if (result)
                  {
                    uint64_t result = sub_244D1A118((uint64_t)a1, (uint64_t)a1, a3[42], a3[37], a4);
                    if (result)
                    {
                      uint64_t result = sub_244D1C868((uint64_t)a1, (uint64_t)a1, v14, a4);
                      if (result)
                      {
                        uint64_t result = sub_244D15D40(a1, (uint64_t)a1, (uint64_t)v9);
                        if (result)
                        {
                          sub_244D168EC((uint64_t *)(v11 + 24));
                          uint64_t result = sub_244D16BB4((uint64_t)a1, *(int *)(v11 + 32));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (!*(unsigned char *)(a4 + 40))
  {
    uint64_t v15 = *(void *)(a4 + 8);
    uint64_t v16 = *(void *)(a4 + 16) - 1;
    *(void *)(a4 + 16) = v16;
    *(void *)(a4 + 32) = *(void *)(v15 + 8 * v16);
  }
  return result;
}

uint64_t sub_244D35564(uint64_t a1, int a2, uint64_t *a3, uint64_t a4)
{
  return sub_244D3556C(a1, a2, a3, a4, 0);
}

uint64_t sub_244D3556C(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, int a5)
{
  if (!a1)
  {
    sub_244D0B884(15, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", 1254);
    return 0;
  }
  unsigned int v6 = 0;
  signed int v7 = a2 & 0xFFFFFF80;
  unsigned int v45 = ((a2 & 0xFFFFFF80) >> 1) - 100;
  unsigned int v44 = (a2 & 0xFFFFFF80) >> 1;
  while (1)
  {
    sub_244D0B1B0();
    uint64_t v8 = sub_244D334EC(0);
    if (!v8) {
      break;
    }
    if (v7 <= 255)
    {
      int v9 = 126;
      __int16 v10 = 1073;
LABEL_8:
      sub_244D0B884(4, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v10);
      goto LABEL_73;
    }
    if (sub_244D168EC(a3) >= 0x21)
    {
      int v9 = 101;
      __int16 v10 = 1084;
      goto LABEL_8;
    }
    uint64_t v11 = sub_244D43FF4(0x30uLL);
    uint64_t v12 = (uint64_t)v11;
    if (v11)
    {
      *(_OWORD *)((char *)v11 + 26) = 0u;
      *(_OWORD *)uint64_t v11 = 0u;
      *((_OWORD *)v11 + 1) = 0u;
      sub_244D1756C(v11);
      uint64_t v13 = sub_244D17610(v12);
      int v48 = sub_244D17610(v12);
      int v47 = sub_244D17610(v12);
      uint64_t v14 = (uint64_t *)sub_244D17610(v12);
      uint64_t v15 = sub_244D17610(v12);
      uint64_t v16 = sub_244D17610(v12);
      if (v13)
      {
        if (v48)
        {
          if (v47)
          {
            if (v14)
            {
              if (v15)
              {
                uint64_t v17 = (uint64_t)v16;
                if (v16)
                {
                  if (sub_244D1E2A0((uint64_t)v15, v45))
                  {
                    if (sub_244D1E2A0(v17, v44))
                    {
                      if (v8[1] || (unint64_t v18 = (long long *)sub_244D16670(), (v8[1] = v18) != 0))
                      {
                        if (v8[3] || (uint64_t v19 = (long long *)sub_244D16670(), (v8[3] = v19) != 0))
                        {
                          if (v8[2] || (int v20 = (long long *)sub_244D16670(), (v8[2] = v20) != 0))
                          {
                            if (v8[4] || (int v21 = (long long *)sub_244D16670(), (v8[4] = v21) != 0))
                            {
                              if (v8[5] || (uint64_t v22 = (long long *)sub_244D16670(), (v8[5] = v22) != 0))
                              {
                                if (v8[6] || (uint64_t v23 = (long long *)sub_244D16670(), (v8[6] = v23) != 0))
                                {
                                  if (v8[7] || (uint64_t v24 = (long long *)sub_244D16670(), (v8[7] = v24) != 0))
                                  {
                                    if (sub_244D16764((void **)v8[2], (uint64_t)a3)
                                      && sub_244D169D4((uint64_t)v14, &unk_244EB7308, 0x20uLL))
                                    {
                                      if (v7 > 0xFFF)
                                      {
                                        if (v7 == 4096
                                          || sub_244D15FB8((uint64_t)v14, 1uLL)
                                          && sub_244D17CA4((uint64_t)v14, v14, v44 - 2048))
                                        {
LABEL_40:
                                          while (sub_244D43814((unsigned int *)v8[4], v44, (unsigned int *)v8[2], 0, (uint64_t)v14, (uint64_t)v15, v12, a4)&& (!a4|| (*(unsigned int (**)(uint64_t, void))(a4 + 8))(3, 0))&& sub_244D43814((unsigned int *)v8[5], v44, (unsigned int *)v8[2], (uint64_t)v8[4], (uint64_t)v14, (uint64_t)v15, v12, a4)
                                               && (!a4
                                                || (*(unsigned int (**)(uint64_t, uint64_t))(a4 + 8))(3, 1)))
                                          {
                                            uint64_t v39 = (uint64_t)v8[5];
                                            uint64_t v40 = (uint64_t)v8[4];
                                            if ((sub_244D17194(v40, v39) & 0x80000000) != 0)
                                            {
                                              v8[4] = (long long *)v39;
                                              unint64_t v8[5] = (long long *)v40;
                                              uint64_t v40 = v39;
                                            }
                                            sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
                                            if (!sub_244D163DC((uint64_t)v48, v40, (uint64_t)&qword_268EBEE70))break; {
                                            uint64_t v41 = (uint64_t)v8[5];
                                            }
                                            sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
                                            if (!sub_244D163DC((uint64_t)v47, v41, (uint64_t)&qword_268EBEE70)|| !sub_244D1C784((void **)v13, (uint64_t)v48, (uint64_t)v47, v12)|| !sub_244D1B7E4((uint64_t)v8[3], &v49, (uint64_t)v8[2], (uint64_t)v13, v12))
                                            {
                                              break;
                                            }
                                            if ((int)sub_244D17194((uint64_t)v8[3], v17) >= 1)
                                            {
                                              if (!sub_244D1C868((uint64_t)v8[1], (uint64_t)v8[4], (uint64_t)v8[5], v12)|| !sub_244D18204(0, (void **)v8[6], (uint64_t)v8[3], (uint64_t)v48, v44, v12)|| !sub_244D18204(0, (void **)v8[7], (uint64_t)v8[3], (uint64_t)v47, v44, v12))
                                              {
                                                break;
                                              }
                                              uint64_t v25 = v8[1];
                                              uint64_t v26 = *((unsigned int *)v25 + 2);
                                              uint64_t v27 = 8 * v26 - 8;
                                              int v28 = *((_DWORD *)v25 + 2);
                                              while (1)
                                              {
                                                BOOL v29 = __OFSUB__(v28--, 1);
                                                if (v28 < 0 != v29) {
                                                  break;
                                                }
                                                uint64_t v30 = *(void *)(*(void *)v25 + v27);
                                                v27 -= 8;
                                                if (v30)
                                                {
                                                  *((_DWORD *)v25 + 2) = v28 + 1;
                                                  goto LABEL_62;
                                                }
                                              }
                                              *((_DWORD *)v25 + 2) = v26 & ((int)v26 >> 31);
                                              if ((v26 & 0x80000000) == 0) {
                                                *((_DWORD *)v25 + 4) = 0;
                                              }
LABEL_62:
                                              if (sub_244D168EC((uint64_t *)v8[1]) == v7)
                                              {
                                                if (!sub_244D34FB4((uint64_t)v8, v12)) {
                                                  break;
                                                }
                                                if (sub_244D32B54((uint64_t *)v8))
                                                {
                                                  int v31 = 0;
                                                  goto LABEL_68;
                                                }
                                                int v32 = 124;
                                                __int16 v33 = 1218;
                                              }
                                              else
                                              {
                                                int v32 = 68;
                                                __int16 v33 = 1204;
                                              }
                                              goto LABEL_67;
                                            }
                                          }
                                        }
                                      }
                                      else if (sub_244D17ED0((void **)v14, (uint64_t)v14, 2048 - v44))
                                      {
                                        goto LABEL_40;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    int v32 = 3;
    __int16 v33 = 1226;
LABEL_67:
    sub_244D0B884(4, 0, v32, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v33);
    int v31 = 1;
LABEL_68:
    if (v12)
    {
      if (!*(unsigned char *)(v12 + 40))
      {
        uint64_t v34 = *(void *)(v12 + 8);
        uint64_t v35 = *(void *)(v12 + 16) - 1;
        *(void *)(v12 + 16) = v35;
        *(void *)(v12 + 32) = *(void *)(v34 + 8 * v35);
      }
      sub_244D17500((unint64_t **)v12);
    }
    if (!v31)
    {
      if (!a5 || sub_244D34764((uint64_t *)v8))
      {
        sub_244D3367C(a1);
        sub_244D166B0(*(void ***)(a1 + 8));
        *(void *)(a1 + 8) = v8[1];
        v8[1] = 0;
        sub_244D166B0(*(void ***)(a1 + 16));
        *(void *)(a1 + 16) = v8[2];
        void v8[2] = 0;
        sub_244D166B0(*(void ***)(a1 + 24));
        *(void *)(a1 + 24) = v8[3];
        _OWORD v8[3] = 0;
        sub_244D166B0(*(void ***)(a1 + 32));
        *(void *)(a1 + 32) = v8[4];
        v8[4] = 0;
        sub_244D166B0(*(void ***)(a1 + 40));
        *(void *)(a1 + 40) = v8[5];
        unint64_t v8[5] = 0;
        sub_244D166B0(*(void ***)(a1 + 48));
        *(void *)(a1 + 48) = v8[6];
        v8[6] = 0;
        sub_244D166B0(*(void ***)(a1 + 56));
        *(void *)(a1 + 56) = v8[7];
        v8[7] = 0;
        sub_244D166B0(*(void ***)(a1 + 64));
        *(void *)(a1 + 64) = v8[8];
        v8[8] = 0;
        sub_244D1A288(*(void ***)(a1 + 288));
        *(void *)(a1 + 288) = v8[36];
        v8[36] = 0;
        sub_244D1A288(*(void ***)(a1 + 296));
        *(void *)(a1 + 296) = v8[37];
        v8[37] = 0;
        sub_244D1A288(*(void ***)(a1 + 304));
        *(void *)(a1 + 304) = v8[38];
        v8[38] = 0;
        sub_244D166B0(*(void ***)(a1 + 312));
        *(void *)(a1 + 312) = v8[39];
        v8[39] = 0;
        sub_244D166B0(*(void ***)(a1 + 320));
        *(void *)(a1 + 320) = v8[40];
        v8[40] = 0;
        sub_244D166B0(*(void ***)(a1 + 328));
        *(void *)(a1 + 328) = v8[41];
        v8[41] = 0;
        sub_244D166B0(*(void ***)(a1 + 336));
        *(void *)(a1 + 336) = v8[42];
        v8[42] = 0;
        *(unsigned char *)(a1 + 376) = *(unsigned char *)(a1 + 376) & 0xFE | (_BYTE)v8[47] & 1;
        uint64_t v37 = 1;
        goto LABEL_84;
      }
      break;
    }
LABEL_73:
    unsigned int v36 = sub_244D0B0B8();
    sub_244D3306C((uint64_t)v8);
    uint64_t v37 = 0;
    uint64_t v8 = 0;
    if (v6 <= 2 && (v36 & 0xFF000000) == 0x4000000)
    {
      ++v6;
      if ((v36 & 0xFFF) == 0x8D) {
        continue;
      }
    }
    goto LABEL_84;
  }
  uint64_t v37 = 0;
LABEL_84:
  sub_244D3306C((uint64_t)v8);
  return v37;
}

uint64_t sub_244D35C80(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 == 2048 || a2 == 3072 || a2 == 4096)
  {
    unsigned int v6 = sub_244D16670();
    signed int v7 = v6;
    if (v6 && sub_244D15DEC((void **)v6, 1uLL))
    {
      *((_DWORD *)v7 + 4) = 0;
      *(void *)*signed int v7 = 65537;
      *((_DWORD *)v7 + 2) = 1;
      uint64_t v8 = sub_244D3556C(a1, a2, v7, a3, 1);
      sub_244D166B0((void **)v7);
      return v8;
    }
    sub_244D166B0((void **)v7);
  }
  else
  {
    sub_244D0B884(4, 0, 104, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", 1329);
  }
  return 0;
}

double sub_244D35D5C()
{
  double result = 0.0;
  xmmword_268EC0200 = 0u;
  unk_268EC0210 = 0u;
  xmmword_268EC01E0 = 0u;
  unk_268EC01F0 = 0u;
  xmmword_268EC01D0 = 0u;
  BYTE4(xmmword_268EC01D0) = 1;
  return result;
}

const char *sub_244D35D80()
{
  return "BoringCrypto";
}

uint64_t sub_244D35D8C()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  sub_244D26A24(byte_244EB7410, 0x10uLL, __s1);
  return sub_244D35E04(byte_244EB7420, (unsigned __int8 *)__s1, 0x20uLL, "SHA-256 KAT");
}

uint64_t sub_244D35E04(unsigned __int8 *__s2, unsigned __int8 *__s1, size_t a3, const char *a4)
{
  if (!a3) {
    return 1;
  }
  size_t v5 = a3;
  unsigned int v6 = __s1;
  signed int v7 = __s2;
  if (!memcmp(__s1, __s2, a3)) {
    return 1;
  }
  uint64_t v8 = (FILE **)MEMORY[0x263EF8348];
  fprintf((FILE *)*MEMORY[0x263EF8348], "%s failed.\nExpected:   ", a4);
  size_t v9 = v5;
  do
  {
    int v10 = *v7++;
    fprintf(*v8, "%02x", v10);
    --v9;
  }
  while (v9);
  fwrite("\nCalculated: ", 0xDuLL, 1uLL, *v8);
  do
  {
    int v11 = *v6++;
    fprintf(*v8, "%02x", v11);
    --v5;
  }
  while (v5);
  fputc(10, *v8);
  fflush(*v8);
  return 0;
}

uint64_t sub_244D35F08()
{
  _DWORD __s1[8] = *MEMORY[0x263EF8340];
  sub_244D26BC8((unint64_t *)&unk_244EB7440, 0x10uLL, __s1);
  return sub_244D35E04(byte_244EB7450, (unsigned __int8 *)__s1, 0x40uLL, "SHA-512 KAT");
}

uint64_t sub_244D35F80()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 0;
  sub_244D4BDB4(&stru_268EBD7F0, (void (*)(void))sub_244D25C70);
  sub_244D2E9F4((uint64_t)&qword_268EBF650, (uint64_t)&unk_244EB7490, 0x10uLL, (uint64_t)&unk_244EB7490, 16, (uint64_t)__s1, &v1);
  uint64_t result = 0;
  if (v1 == 32) {
    return sub_244D35E04(byte_244EB74A0, __s1, 0x20uLL, "HMAC-SHA-256 KAT");
  }
  return result;
}

uint64_t sub_244D3603C()
{
  __s1[73] = *MEMORY[0x263EF8340];
  bzero(__s1, 0x248uLL);
  int v44 = 0;
  memset(v43, 0, sizeof(v43));
  int8x16_t v72 = 0uLL;
  int v0 = sub_244D13B14(&xmmword_244EB96A0, 128, (uint64_t)v43);
  int v1 = (FILE **)MEMORY[0x263EF8348];
  if (v0)
  {
    uint64_t v2 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v3 = "AES_set_encrypt_key failed.\n";
LABEL_3:
    char v4 = 1;
    size_t v5 = 28;
LABEL_4:
    fwrite(v3, v5, 1uLL, v2);
    goto LABEL_5;
  }
  char v4 = 1;
  sub_244D14900(xmmword_244EB96B0, v71, 0x20uLL, (uint64_t)v43, &v72, 1);
  if (sub_244D35E04(byte_244EB96D0, (unsigned __int8 *)v71, 0x20uLL, "AES-CBC-encrypt KAT"))
  {
    int8x16_t v72 = 0uLL;
    if (sub_244D13B14(&xmmword_244EB96A0, 128, (uint64_t)v43))
    {
      uint64_t v2 = *v1;
      uint64_t v3 = "AES_set_decrypt_key failed.\n";
      goto LABEL_3;
    }
    sub_244D14900(xmmword_244EB96F0, v71, 0x20uLL, (uint64_t)v43, &v72, 0);
    if (!sub_244D35E04(byte_244EB9710, (unsigned __int8 *)v71, 0x20uLL, "AES-CBC-decrypt KAT")) {
      goto LABEL_89;
    }
    size_t v42 = 0;
    memset(v70, 0, sizeof(v70));
    sub_244D4BDB4(&stru_268EBD6F0, (void (*)(void))sub_244D23844);
    if (sub_244D21BFC(__s1, (uint64_t)&dword_268EBF230, (uint64_t)&xmmword_244EB96A0, 16, 0))
    {
      sub_244D4BDB4(&stru_268EBD6F0, (void (*)(void))sub_244D23844);
      if (sub_244D21D90((uint64_t)__s1, v71[0].i8, &v42, 0x100uLL, (uint64_t)v70, BYTE1(dword_268EBF230), byte_244EB9730, 0x20uLL)&& sub_244D35E04(byte_244EB9750, (unsigned __int8 *)v71, 0x30uLL, "AES-GCM-encrypt KAT"))
      {
        sub_244D4BDB4(&stru_268EBD6F0, (void (*)(void))sub_244D23844);
        if (!sub_244D21FEC((unsigned __int8 *)__s1, v71[0].i8, &v42, 0x100uLL, (uint64_t)v70, BYTE1(dword_268EBF230), a5, 0x30uLL)|| !sub_244D35E04(byte_244EB97B0, (unsigned __int8 *)v71, 0x20uLL, "AES-GCM-decrypt KAT"))
        {
          uint64_t v2 = *v1;
          uint64_t v3 = "AES-GCM-decrypt KAT failed because EVP_AEAD_CTX_open failed.\n";
          char v4 = 1;
          size_t v5 = 61;
          goto LABEL_4;
        }
        sub_244D36E90(byte_244EB97D0, 0x10uLL, v71);
        if (sub_244D35E04(byte_244EB97E0, (unsigned __int8 *)v71, 0x14uLL, "SHA-1 KAT"))
        {
          sub_244D26A24(byte_244EB7410, 0x10uLL, v68);
          if (sub_244D35E04(byte_244EB7420, (unsigned __int8 *)v68, 0x20uLL, "SHA-256 KAT"))
          {
            sub_244D26BC8((unint64_t *)&unk_244EB7440, 0x10uLL, v68);
            if (sub_244D35E04(byte_244EB7450, (unsigned __int8 *)v68, 0x40uLL, "SHA-512 KAT"))
            {
              if (sub_244D35F80())
              {
                memset(v69, 0, sizeof(v69));
                memset(v68, 0, sizeof(v68));
                if (!sub_244D31840((uint64_t)v68, xmmword_244EB97F4, aBcmpersonaliza, 0x12uLL)
                  || !sub_244D31B10((uint64_t)v68, v71[0].i8, 0x40uLL, &aBcmpersonaliza[18], 0x10uLL)
                  || !sub_244D35E04(byte_244EB9846, (unsigned __int8 *)v71, 0x40uLL, "DRBG Generate KAT")
                  || !sub_244D31944((uint64_t)v68, byte_244EB9886, (uint64_t)&aBcmpersonaliza[18], 0x10uLL)
                  || !sub_244D31B10((uint64_t)v68, v71[0].i8, 0x40uLL, &aBcmpersonaliza[18], 0x10uLL)
                  || !sub_244D35E04(byte_244EB98B6, (unsigned __int8 *)v71, 0x40uLL, "DRBG-reseed KAT"))
                {
                  char v4 = 1;
                  fwrite("CTR-DRBG failed.\n", 0x11uLL, 1uLL, *v1);
                  goto LABEL_5;
                }
                sub_244D4413C(v68, 0x120uLL);
                long long v66 = 0u;
                long long v67 = 0u;
                long long v64 = 0u;
                long long v65 = 0u;
                long long v62 = 0u;
                long long v63 = 0u;
                long long v60 = 0u;
                long long v61 = 0u;
                long long v58 = 0u;
                long long v59 = 0u;
                long long v56 = 0u;
                long long v57 = 0u;
                long long v54 = 0u;
                long long v55 = 0u;
                long long v52 = 0u;
                long long v53 = 0u;
                long long __s2 = 0u;
                long long v51 = 0u;
                if (sub_244D35E04((unsigned __int8 *)&__s2, (unsigned __int8 *)v68, 0x120uLL, "DRBG Clear KAT"))
                {
                  sub_244D4BDB4(&stru_268EBD830, (void (*)(void))sub_244D25EB0);
                  if (!sub_244D3A3A4(&qword_268EBF710, v49, 0x20uLL, (uint64_t)&unk_244EB9925, 0x20uLL, (uint64_t)"FIPS self test", 15, (uint64_t)&unk_244EB9905, 16, (uint64_t)&unk_244EB9915, 16)|| !sub_244D35E04(byte_244EB9945, v49, 0x20uLL, "TLS10-KDF KAT")|| (sub_244D4BDB4(&stru_268EBD7F0, (void (*)(void))sub_244D25C70), !sub_244D3A3A4(&qword_268EBF650, v48, 0x20uLL, (uint64_t)&unk_244EB9965, 0x20uLL,
                                         (uint64_t)"FIPS self test",
                                         15,
                                         (uint64_t)&unk_244EB9905,
                                         16,
                                         (uint64_t)&unk_244EB9915,
                                         16))
                    || !sub_244D35E04(byte_244EB9985, v48, 0x20uLL, "TLS12-KDF KAT"))
                  {
                    uint64_t v2 = *v1;
                    uint64_t v3 = "TLS KDF failed.\n";
                    char v4 = 1;
                    size_t v5 = 16;
                    goto LABEL_4;
                  }
                  uint64_t v41 = 0;
                  sub_244D4BDB4(&stru_268EBD7F0, (void (*)(void))sub_244D25C70);
                  if (!sub_244D2E778((uint64_t)v47, &v41, (uint64_t)&qword_268EBF650, (uint64_t)&unk_244EB99A5, 32, (uint64_t)&unk_244EB99C5, 0x10uLL)|| v41 != 32|| (sub_244D4BDB4(&stru_268EBD7F0, (void (*)(void))sub_244D25C70), !sub_244D3A7E0((uint64_t)v46, 32, (uint64_t)&qword_268EBF650, (uint64_t)v47, 0x20uLL, "c e traffic", 0xBuLL, &unk_244EB99E1, 0x20uLL))
                    || !sub_244D35E04(byte_244EB9A01, v46, 0x20uLL, "CRYPTO_tls13_hkdf_expand_label"))
                  {
                    uint64_t v2 = *v1;
                    uint64_t v3 = "TLS13-KDF failed.\n";
                    char v4 = 1;
                    size_t v5 = 18;
                    goto LABEL_4;
                  }
                  sub_244D4BDB4(&stru_268EBD7F0, (void (*)(void))sub_244D25C70);
                  if (!sub_244D2E6D4((uint64_t)v45, 32, (uint64_t)&qword_268EBF650, (uint64_t)&unk_244EB9A21, 32, (uint64_t)&unk_244EB9A41, 0x20uLL, (uint64_t)&unk_244EB9A61, 32)|| !sub_244D35E04(byte_244EB9A81, v45, 0x20uLL, "HKDF"))
                  {
                    uint64_t v2 = *v1;
                    uint64_t v3 = "HKDF failed.\n";
                    char v4 = 1;
                    size_t v5 = 13;
                    goto LABEL_4;
                  }
                  char v4 = 0;
                  goto LABEL_5;
                }
              }
            }
          }
        }
LABEL_89:
        char v4 = 1;
        goto LABEL_5;
      }
      uint64_t v2 = *v1;
      uint64_t v3 = "EVP_AEAD_CTX_seal for AES-128-GCM failed.\n";
    }
    else
    {
      uint64_t v2 = *v1;
      uint64_t v3 = "EVP_AEAD_CTX_init for AES-128-GCM failed.\n";
    }
    char v4 = 1;
    size_t v5 = 42;
    goto LABEL_4;
  }
LABEL_5:
  if (__s1[0]) {
    (*(void (**)(void *))(__s1[0] + 24))(__s1);
  }
  if (v4) {
    return 0;
  }
  unsigned int v6 = sub_244D334EC(0);
  if (!v6) {
    goto LABEL_54;
  }
  signed int v7 = (long long *)sub_244D16D20(byte_244EB9CE1, 0x100uLL, 0);
  v6[1] = v7;
  if (!v7) {
    goto LABEL_54;
  }
  uint64_t v8 = (long long *)sub_244D16D20(byte_244EB9DE1, 3uLL, 0);
  _OWORD v6[2] = v8;
  if (!v8) {
    goto LABEL_54;
  }
  size_t v9 = (long long *)sub_244D16D20(byte_244EB9DE4, 0x100uLL, 0);
  _OWORD v6[3] = v9;
  if (!v9) {
    goto LABEL_54;
  }
  int v10 = (long long *)sub_244D16D20(byte_244EB9EE4, 0x80uLL, 0);
  v6[4] = v10;
  if (!v10) {
    goto LABEL_54;
  }
  int v11 = (long long *)sub_244D16D20(byte_244EB9F64, 0x80uLL, 0);
  _OWORD v6[5] = v11;
  if (!v11) {
    goto LABEL_54;
  }
  uint64_t v12 = (long long *)sub_244D16D20(byte_244EB9FE4, 0x80uLL, 0);
  v6[6] = v12;
  if (v12
    && (uint64_t v13 = (long long *)sub_244D16D20(byte_244EBA064, 0x80uLL, 0), (v6[7] = v13) != 0)
    && (uint64_t v14 = (long long *)sub_244D16D20(byte_244EBA0E4, 0x80uLL, 0), (v6[8] = v14) != 0))
  {
    *((_DWORD *)v6 + 21) |= 8u;
    LODWORD(v68[0]) = 0;
    if (sub_244D33C08(672, &unk_244EB9AA1, 0x20uLL, (char *)__s1, v68, (uint64_t **)v6)
      && sub_244D35E04(byte_244EB9AC1, (unsigned __int8 *)__s1, 0x100uLL, "RSA-sign KAT"))
    {
      if (sub_244D33EB4(672, &unk_244EB9BC1, 0x20uLL, byte_244EB9BE1, 0x100uLL, v6))
      {
        sub_244D3306C((uint64_t)v6);
        uint64_t v15 = sub_244D2A278(0);
        uint64_t v16 = sub_244D16D20(byte_244EBA2C6, 0x20uLL, 0);
        uint64_t v17 = sub_244D16D20(byte_244EBA2E6, 0x20uLL, 0);
        unint64_t v18 = sub_244D16D20(byte_244EBA306, 0x20uLL, 0);
        uint64_t v19 = (void **)v18;
        if (!v15
          || !v16
          || !v17
          || !v18
          || (sub_244D4BDB4(&stru_268EBD860, (void (*)(void))sub_244D27A9C),
              !sub_244D2A4D0(v15, (uint64_t)&qword_268EBF970))
          || !sub_244D2A9B8(v15, (uint64_t)v16, (uint64_t)v17)
          || !sub_244D2A5F0(v15, (uint64_t)v19))
        {
          sub_244D2A380((uint64_t)v15);
          uint64_t v15 = 0;
        }
        sub_244D166B0((void **)v16);
        sub_244D166B0((void **)v17);
        sub_244D166B0(v19);
        if (v15)
        {
          long long __s2 = 0uLL;
          *(void *)((char *)&v51 + 7) = 0;
          *(void *)&long long v51 = 0;
          HIBYTE(v51) = 42;
          int v20 = sub_244D27190(byte_244EBA164, 0x20uLL, v15, (unsigned __int8 *)&__s2, 0x20uLL);
          int v21 = v20;
          if (v20
            && sub_244D16FA8((char *)v68, 0x20uLL, *v20)
            && sub_244D16FA8((char *)v69, 0x20uLL, v21[1])
            && sub_244D35E04(byte_244EBA184, (unsigned __int8 *)v68, 0x40uLL, "ECDSA-sign signature"))
          {
            sub_244D07DFC(v21);
            uint64_t v22 = sub_244D26C98();
            int v21 = v22;
            if (v22
              && sub_244D16D20(byte_244EBA1E4, 0x20uLL, (void *)*v22)
              && sub_244D16D20(byte_244EBA204, 0x20uLL, (void *)v21[1]))
            {
              if (sub_244D26CF4(byte_244EBA1C4, 0x20uLL, v21, (uint64_t)v15))
              {
                sub_244D4BDB4(&stru_268EBD860, (void (*)(void))sub_244D27A9C);
                uint64_t v23 = sub_244D28B04((uint64_t)&qword_268EBF970);
                uint64_t v24 = sub_244D28B04((uint64_t)&qword_268EBF970);
                uint64_t v25 = sub_244D16670();
                uint64_t v26 = (void **)v25;
                if (v23
                  && v24
                  && v25
                  && sub_244D2AB28((uint64_t)&qword_268EBF970, (uint64_t)v23, byte_244EBA224, 65, 0)
                  && sub_244D16D20(byte_244EBA265, 0x20uLL, v26)
                  && sub_244D29A7C((uint64_t)&qword_268EBF970, (uint64_t)v24, 0, v23, (uint64_t)v26, 0)
                  && sub_244D2C870((uint64_t)&qword_268EBF970, v24, 4, (char *)__s1, 0x41uLL)
                  && sub_244D35E04(byte_244EBA285, (unsigned __int8 *)__s1, 0x41uLL, "Z Computation Result"))
                {
                  sub_244D2A380((uint64_t)v15);
                  sub_244D28BB0(v23);
                  sub_244D28BB0(v24);
                  sub_244D166B0(v26);
                  sub_244D07DFC(v21);
                  uint64_t v27 = sub_244D16670();
                  int v28 = (void **)v27;
                  if (v27) {
                    sub_244D16A30((uint64_t)v27, (uint64_t)&unk_244EBA328, 32);
                  }
                  uint64_t v29 = sub_244D25528();
                  if (v29)
                  {
                    uint64_t v30 = v29;
                    int v31 = sub_244D16670();
                    if (v31)
                    {
                      int v32 = v31;
                      sub_244D16A30((uint64_t)v31, (uint64_t)&unk_244EBA528, 4);
                      sub_244D166B0(*(void ***)(v30 + 32));
                      *(void *)(v30 + 32) = v32;
                      if (v28
                        && ((sub_244D168EC(*(uint64_t **)v30) + 7) & 0xFFFFFFF8) == 0x800
                        && sub_244D24FD4((char *)__s1, (uint64_t)v28, (uint64_t **)v30) == 256
                        && sub_244D35E04(byte_244EBA428, (unsigned __int8 *)__s1, 0x100uLL, "FFC DH"))
                      {
                        uint64_t v33 = 1;
LABEL_111:
                        sub_244D24C6C(v30);
                        sub_244D166B0(v28);
                        return v33;
                      }
LABEL_110:
                      fwrite("FFDH failed.\n", 0xDuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
                      uint64_t v33 = 0;
                      goto LABEL_111;
                    }
                    sub_244D24C6C(v30);
                  }
                  uint64_t v30 = 0;
                  goto LABEL_110;
                }
                fwrite("Z-computation KAT failed.\n", 0x1AuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
                goto LABEL_101;
              }
            }
            else
            {
              sub_244D07DFC(v21);
              int v21 = 0;
            }
            uint64_t v38 = *v1;
            uint64_t v39 = "ECDSA-verify KAT failed.\n";
            size_t v40 = 25;
          }
          else
          {
            uint64_t v38 = *v1;
            uint64_t v39 = "ECDSA-sign KAT failed.\n";
            size_t v40 = 23;
          }
          fwrite(v39, v40, 1uLL, v38);
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          uint64_t v26 = 0;
        }
        else
        {
          fwrite("ECDSA KeyGen failed\n", 0x14uLL, 1uLL, *v1);
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          uint64_t v26 = 0;
          int v21 = 0;
        }
LABEL_101:
        sub_244D2A380((uint64_t)v15);
        sub_244D28BB0(v23);
        sub_244D28BB0(v24);
        sub_244D166B0(v26);
        sub_244D07DFC(v21);
        return 0;
      }
      uint64_t v35 = *v1;
      unsigned int v36 = "RSA-verify KAT failed.\n";
      size_t v37 = 23;
    }
    else
    {
      uint64_t v35 = *v1;
      unsigned int v36 = "RSA signing test failed.\n";
      size_t v37 = 25;
    }
    fwrite(v36, v37, 1uLL, v35);
  }
  else
  {
LABEL_54:
    sub_244D3306C((uint64_t)v6);
    fwrite("RSA key construction failed\n", 0x1CuLL, 1uLL, *v1);
    unsigned int v6 = 0;
  }
  sub_244D3306C((uint64_t)v6);
  return 0;
}

uint64_t sub_244D36E64(_OWORD *a1)
{
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = xmmword_244EB6ED0;
  a1[1] = 0u;
  *((_DWORD *)a1 + 4) = -1009589776;
  return 1;
}

_DWORD *sub_244D36E90(char *__src, size_t __n, _DWORD *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  memset(v7, 0, 76);
  long long v5 = xmmword_244EB6ED0;
  int v6 = -1009589776;
  sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D3708C, (uint64_t)&v5, (char *)v7 + 8, (_DWORD *)&v7[4] + 2, (_DWORD *)v7 + 1, v7, __src, __n);
  sub_244D36FAC(a3, (uint64_t)&v5);
  sub_244D4413C(&v5, 0x60uLL);
  return a3;
}

uint64_t sub_244D36F64(uint64_t a1, char *__src, size_t __n)
{
  return 1;
}

uint64_t sub_244D36FAC(_DWORD *a1, uint64_t a2)
{
  uint64_t v4 = a2 + 28;
  int8x8_t v5 = *(int8x8_t *)(a2 + 20);
  uint64_t v6 = *(unsigned int *)(a2 + 92);
  *(unsigned char *)(a2 + 28 + v6) = 0x80;
  uint64_t v7 = v6 + 1;
  if (v6 >= 0x38)
  {
    if (v6 != 63) {
      bzero((void *)(v4 + v7), 63 - v6);
    }
    sub_244D3708C((int *)a2, (unsigned int *)v4, 1);
    uint64_t v7 = 0;
    goto LABEL_6;
  }
  if (v6 != 55) {
LABEL_6:
  }
    bzero((void *)(v4 + v7), 56 - v7);
  *(int32x2_t *)(a2 + 84) = vrev64_s32((int32x2_t)vrev32_s8(v5));
  sub_244D3708C((int *)a2, (unsigned int *)v4, 1);
  *(_DWORD *)(a2 + 92) = 0;
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  sub_244D3828C(a1, (unsigned int *)a2);
  return 1;
}

uint64_t sub_244D37084(int *a1, unsigned int *a2)
{
  return sub_244D3708C(a1, a2, 1);
}

uint64_t sub_244D3708C(int *a1, unsigned int *a2, uint64_t a3)
{
  int v3 = a1[3];
  int v4 = a1[4];
  int v5 = a1[1];
  int v6 = a1[2];
  int v7 = *a1;
  do
  {
    int v522 = v3;
    int v523 = v5;
    int v521 = v6;
    int v517 = v7;
    int v518 = v4;
    v519 = a2;
    uint64_t v520 = a3;
    int v8 = v7;
    HIDWORD(v10) = v7;
    LODWORD(v10) = v7;
    int v9 = v10 >> 27;
    int v11 = v3 & ~v5;
    unsigned int v12 = bswap32(*a2);
    int v13 = v6 & v523;
    HIDWORD(v10) = v523;
    LODWORD(v10) = v523;
    int v14 = v10 >> 2;
    unsigned int v501 = bswap32(a2[1]);
    unsigned int v15 = v9 + v4 + 1518500249 + (v13 | v11) + v12;
    HIDWORD(v10) = v15;
    LODWORD(v10) = v15;
    int v16 = v10 >> 27;
    HIDWORD(v10) = v8;
    LODWORD(v10) = v8;
    int v17 = v10 >> 2;
    unsigned int v18 = v522 + 1518500249 + (v8 & __ROR4__(v523, 2) | v521 & ~v8) + v501 + v16;
    HIDWORD(v10) = v18;
    LODWORD(v10) = v18;
    int v19 = v10 >> 27;
    HIDWORD(v10) = v15;
    LODWORD(v10) = v15;
    int v20 = v10 >> 2;
    unsigned int v21 = bswap32(a2[2]);
    unsigned int v505 = bswap32(a2[3]);
    unint64_t v23 = __PAIR64__(v18, __ROR4__(v15, 2));
    int v22 = v18 & v23;
    LODWORD(v23) = v18;
    int v24 = v23 >> 2;
    unsigned int v25 = v521 + 1518500249 + v21 + (v15 & __ROR4__(v8, 2) | v14 & ~v15) + v19;
    HIDWORD(v23) = v25;
    LODWORD(v23) = v25;
    int v26 = v23 >> 27;
    unint64_t v28 = __PAIR64__(v25, __ROR4__(v18, 2));
    int v27 = v25 & v28;
    unsigned int v29 = bswap32(a2[4]);
    LODWORD(v28) = v25;
    int v30 = v28 >> 2;
    unsigned int v31 = v14 + 1518500249 + v505 + (v22 | v17 & ~v18) + v26;
    HIDWORD(v28) = v31;
    LODWORD(v28) = v31;
    unsigned int v32 = v17 + 1518500249 + v29 + (v27 | v20 & ~v25) + (v28 >> 27);
    HIDWORD(v28) = v32;
    LODWORD(v28) = v32;
    int v33 = v28 >> 27;
    unint64_t v35 = __PAIR64__(v31, __ROR4__(v25, 2));
    int v34 = v31 & v35;
    LODWORD(v35) = v31;
    int v36 = v35 >> 2;
    unint64_t v38 = __PAIR64__(v32, __ROR4__(v31, 2));
    int v37 = v32 & v38;
    unsigned int v39 = bswap32(a2[5]);
    int v40 = v34 | v24 & ~v31;
    LODWORD(v38) = v32;
    int v41 = v38 >> 2;
    int v42 = v20 + v39 + 1518500249 + v40 + v33;
    HIDWORD(v38) = v42;
    LODWORD(v38) = v42;
    int v43 = v38 >> 27;
    unsigned int v513 = bswap32(a2[6]);
    int v44 = v37 | v30 & ~v32;
    HIDWORD(v38) = v42;
    LODWORD(v38) = v42;
    int v45 = v38 >> 2;
    unsigned int v46 = v24 + v513 + 1518500249 + v44 + v43;
    HIDWORD(v38) = v46;
    LODWORD(v38) = v46;
    int v47 = v38 >> 27;
    unint64_t v48 = __PAIR64__(v46, __ROR4__(v32, 2));
    unsigned int v509 = bswap32(a2[7]);
    int v49 = v42 & v48 | v36 & ~v42;
    LODWORD(v48) = v46;
    int v50 = v48 >> 2;
    unsigned int v51 = v509 + 1518500249 + v30 + v49 + v47;
    HIDWORD(v48) = v51;
    LODWORD(v48) = v51;
    int v52 = v48 >> 27;
    unint64_t v54 = __PAIR64__(v51, __ROR4__(v46, 2));
    int v53 = v51 & v54;
    LODWORD(v54) = v51;
    int v55 = v54 >> 2;
    unsigned int v497 = bswap32(a2[8]);
    unsigned int v56 = v497 + 1518500249 + v36 + (v46 & __ROR4__(v42, 2) | v41 & ~v46) + v52;
    unsigned int v57 = bswap32(a2[13]);
    HIDWORD(v54) = v56;
    LODWORD(v54) = v56;
    int v58 = v54 >> 27;
    HIDWORD(v54) = v21 ^ v12 ^ v497 ^ v57;
    LODWORD(v54) = HIDWORD(v54);
    int v59 = v54 >> 31;
    int v60 = HIDWORD(v54);
    int v466 = HIDWORD(v54);
    unint64_t v62 = __PAIR64__(v56, __ROR4__(v51, 2));
    int v61 = v56 & v62;
    unsigned int v63 = bswap32(a2[9]);
    LODWORD(v62) = v56;
    int v64 = v62 >> 2;
    int v65 = v63 + 1518500249 + v41 + (v53 | v45 & ~v51) + v58;
    HIDWORD(v62) = v65;
    LODWORD(v62) = v65;
    int v66 = v62 >> 27;
    unsigned int v67 = bswap32(a2[10]);
    HIDWORD(v62) = v65;
    LODWORD(v62) = v65;
    int v68 = v62 >> 2;
    unsigned int v69 = v67 + 1518500249 + v45 + (v61 | v50 & ~v56) + v66;
    HIDWORD(v62) = v69;
    LODWORD(v62) = v69;
    int v70 = v62 >> 27;
    unint64_t v71 = __PAIR64__(v69, __ROR4__(v56, 2));
    unsigned int v72 = bswap32(a2[11]);
    int v73 = v65 & v71 | v55 & ~v65;
    LODWORD(v71) = v69;
    int v74 = v71 >> 2;
    unsigned int v75 = v72 + 1518500249 + v50 + v73 + v70;
    HIDWORD(v71) = v75;
    LODWORD(v71) = v75;
    int v76 = v71 >> 27;
    unint64_t v77 = __PAIR64__(v75, __ROR4__(v65, 2));
    unsigned int v78 = bswap32(a2[12]);
    int v79 = v69 & v77 | v64 & ~v69;
    LODWORD(v77) = v75;
    int v80 = v77 >> 2;
    unsigned int v81 = v78 + 1518500249 + v55 + v79 + v76;
    HIDWORD(v77) = v81;
    LODWORD(v77) = v81;
    int v82 = v77 >> 27;
    int v83 = v75 & __ROR4__(v69, 2);
    unsigned int v84 = bswap32(a2[14]);
    int v85 = v68 & ~v75;
    unint64_t v87 = __PAIR64__(v81, __ROR4__(v75, 2));
    int v86 = v81 & v87;
    unsigned int v493 = v57;
    LODWORD(v87) = v81;
    int v88 = v87 >> 2;
    int v89 = v57 + 1518500249 + v64 + (v83 | v85) + v82;
    int v90 = v505 ^ v501 ^ v63 ^ v84;
    HIDWORD(v87) = v89;
    LODWORD(v87) = v89;
    int v91 = v87 >> 27;
    HIDWORD(v87) = v90;
    LODWORD(v87) = v90;
    int v92 = v87 >> 31;
    HIDWORD(v87) = v89;
    LODWORD(v87) = v89;
    int v93 = v87 >> 2;
    int v94 = v84 + 1518500249 + v68 + (v86 | v74 & ~v81) + v91;
    HIDWORD(v87) = v94;
    LODWORD(v87) = v94;
    int v95 = v87 >> 27;
    unsigned int v96 = bswap32(a2[15]);
    int v97 = v29 ^ v21 ^ v67 ^ v96;
    unint64_t v99 = __PAIR64__(v97, __ROR4__(v89, 2));
    int v98 = v94 & v99;
    LODWORD(v99) = v97;
    int v468 = v97;
    int v471 = v99 >> 31;
    int v100 = v89 & __ROR4__(v81, 2) | v80 & ~v89;
    HIDWORD(v99) = v94;
    LODWORD(v99) = v94;
    int v101 = v99 >> 2;
    unsigned int v102 = v96 + 1518500249 + v74 + v100 + v95;
    HIDWORD(v99) = v102;
    LODWORD(v99) = v102;
    int v103 = v99 >> 27;
    unint64_t v105 = __PAIR64__(v102, __ROR4__(v94, 2));
    int v104 = v102 & v105;
    LODWORD(v105) = v102;
    int v106 = v105 >> 2;
    unsigned int v107 = v59 + 1518500249 + v80 + (v98 | v88 & ~v94) + v103;
    HIDWORD(v105) = v107;
    LODWORD(v105) = v107;
    int v108 = v105 >> 27;
    LODWORD(v105) = v39 ^ v505 ^ v72 ^ __ROR4__(v60, 31);
    int v109 = v105;
    HIDWORD(v105) = v105;
    int v110 = v105 >> 31;
    unint64_t v112 = __PAIR64__(v107, __ROR4__(v90, 31));
    int v111 = v513 ^ v29 ^ v78 ^ v112;
    LODWORD(v112) = v107;
    int v113 = v112 >> 2;
    unsigned int v114 = v92 + 1518500249 + v88 + (v104 | v93 & ~v102) + v108;
    HIDWORD(v112) = v114;
    LODWORD(v112) = v114;
    int v115 = v112 >> 27;
    HIDWORD(v112) = v111;
    LODWORD(v112) = v111;
    int v480 = v112 >> 31;
    int v116 = v509 ^ v39 ^ v57 ^ __ROR4__(v97, 31);
    unint64_t v118 = __PAIR64__(v114, __ROR4__(v107, 2));
    int v117 = v114 & v118;
    LODWORD(v118) = v114;
    int v119 = v118 >> 2;
    HIDWORD(v118) = v116;
    LODWORD(v118) = v116;
    int v477 = v118 >> 31;
    int v120 = v471 + 1518500249 + v93 + (v107 & __ROR4__(v102, 2) | v101 & ~v107) + v115;
    HIDWORD(v118) = v120;
    LODWORD(v118) = v120;
    int v121 = v118 >> 27;
    HIDWORD(v118) = v120;
    LODWORD(v118) = v120;
    int v122 = v118 >> 2;
    int v123 = v122 ^ __ROR4__(v114, 2);
    int v124 = v110 + 1518500249 + v101 + (v117 | v106 & ~v114) + v121;
    HIDWORD(v118) = v124;
    LODWORD(v118) = v124;
    int v125 = v118 >> 27;
    HIDWORD(v118) = v124;
    LODWORD(v118) = v124;
    int v126 = v118 >> 2;
    LODWORD(v118) = v497 ^ v513 ^ v84 ^ __ROR4__(v109, 31);
    int v127 = v118;
    HIDWORD(v118) = v118;
    int v474 = v118 >> 31;
    int v128 = v126 ^ __ROR4__(v120, 2);
    unsigned int v129 = v480 + 1859775393 + v106 + (v119 ^ __ROR4__(v107, 2) ^ v120) + v125;
    HIDWORD(v118) = v129;
    LODWORD(v118) = v129;
    int v130 = v118 >> 27;
    unint64_t v132 = __PAIR64__(v129, __ROR4__(v111, 31));
    int v131 = v63 ^ v509 ^ v96 ^ v132;
    int v133 = v477 + 1859775393 + v113 + (v123 ^ v124);
    LODWORD(v132) = v129;
    int v134 = v132 >> 2;
    int v135 = v133 + v130;
    HIDWORD(v132) = v135;
    LODWORD(v132) = v135;
    int v136 = v132 >> 27;
    int v137 = v474 + 1859775393 + v119 + (v128 ^ v129);
    HIDWORD(v132) = v131;
    LODWORD(v132) = v131;
    int v487 = v132 >> 31;
    int v138 = v134 ^ __ROR4__(v124, 2);
    int v139 = v67 ^ v497 ^ __ROR4__(v466, 31) ^ __ROR4__(v116, 31);
    int v140 = v137 + v136;
    HIDWORD(v132) = v140;
    LODWORD(v132) = v140;
    int v141 = v132 >> 27;
    HIDWORD(v132) = v139;
    LODWORD(v132) = v139;
    int v510 = v132 >> 31;
    unsigned int v142 = v487 + 1859775393 + v122 + (v138 ^ v135) + v141;
    HIDWORD(v132) = v135;
    LODWORD(v132) = v135;
    int v143 = v132 >> 2;
    unint64_t v144 = __PAIR64__(v142, __ROR4__(v129, 2));
    int v145 = v510 + 1859775393 + v126 + (v143 ^ v144 ^ v140);
    LODWORD(v144) = v142;
    unsigned int v147 = v145 + (v144 >> 27);
    LODWORD(v144) = v72 ^ v63 ^ __ROR4__(v90, 31) ^ __ROR4__(v127, 31);
    int v146 = v144;
    HIDWORD(v144) = v144;
    int v148 = v144 >> 31;
    HIDWORD(v144) = v140;
    LODWORD(v144) = v140;
    int v149 = v144 >> 2;
    unint64_t v150 = __PAIR64__(v147, __ROR4__(v135, 2));
    int v151 = v148 + 1859775393 + v134 + (v149 ^ v150 ^ v142);
    LODWORD(v150) = v147;
    unsigned int v152 = v151 + (v150 >> 27);
    LODWORD(v150) = v78 ^ v67 ^ __ROR4__(v468, 31) ^ __ROR4__(v131, 31);
    int v153 = v150;
    HIDWORD(v150) = v150;
    int v506 = v150 >> 31;
    int v154 = v506 + 1859775393 + v143;
    HIDWORD(v150) = v142;
    LODWORD(v150) = v142;
    int v155 = v150 >> 2;
    unint64_t v156 = __PAIR64__(v152, __ROR4__(v140, 2));
    int v157 = v154 + (v155 ^ v156 ^ v147);
    LODWORD(v156) = v152;
    unsigned int v158 = v157 + (v156 >> 27);
    int v159 = v493 ^ v72 ^ __ROR4__(v109, 31) ^ __ROR4__(v139, 31);
    HIDWORD(v156) = v159;
    LODWORD(v156) = v159;
    int v502 = v156 >> 31;
    HIDWORD(v156) = v147;
    LODWORD(v156) = v147;
    int v160 = v156 >> 2;
    unint64_t v161 = __PAIR64__(v158, __ROR4__(v142, 2));
    int v162 = v502 + 1859775393 + v149 + (v160 ^ v161 ^ v152);
    LODWORD(v161) = v158;
    unsigned int v163 = v162 + (v161 >> 27);
    LODWORD(v161) = v84 ^ v78 ^ __ROR4__(v111, 31) ^ __ROR4__(v146, 31);
    int v164 = v161;
    HIDWORD(v161) = v161;
    int v498 = v161 >> 31;
    int v165 = v498 + 1859775393 + v155;
    HIDWORD(v161) = v152;
    LODWORD(v161) = v152;
    int v166 = v161 >> 2;
    unint64_t v167 = __PAIR64__(v163, __ROR4__(v147, 2));
    int v168 = v165 + (v166 ^ v167 ^ v158);
    LODWORD(v167) = v163;
    unsigned int v169 = v168 + (v167 >> 27);
    LODWORD(v167) = v96 ^ v493 ^ __ROR4__(v116, 31) ^ __ROR4__(v153, 31);
    int v170 = v167;
    HIDWORD(v167) = v167;
    int v514 = v167 >> 31;
    HIDWORD(v167) = v158;
    LODWORD(v167) = v158;
    int v171 = v167 >> 2;
    unint64_t v172 = __PAIR64__(v169, __ROR4__(v152, 2));
    int v173 = v514 + 1859775393 + v160 + (v171 ^ v172 ^ v163);
    LODWORD(v172) = v169;
    unsigned int v174 = v173 + (v172 >> 27);
    LODWORD(v172) = v84 ^ __ROR4__(v466, 31) ^ __ROR4__(v127, 31) ^ __ROR4__(v159, 31);
    int v175 = v172;
    HIDWORD(v172) = v172;
    int v494 = v172 >> 31;
    HIDWORD(v172) = v163;
    LODWORD(v172) = v163;
    int v176 = v172 >> 2;
    unint64_t v177 = __PAIR64__(v174, __ROR4__(v158, 2));
    int v178 = v494 + 1859775393 + v166 + (v176 ^ v177 ^ v169);
    LODWORD(v177) = v174;
    unsigned int v179 = v178 + (v177 >> 27);
    LODWORD(v177) = v96 ^ __ROR4__(v90, 31) ^ __ROR4__(v131, 31) ^ __ROR4__(v164, 31);
    int v180 = v177;
    HIDWORD(v177) = v177;
    int v490 = v177 >> 31;
    int v181 = v490 + 1859775393 + v171;
    HIDWORD(v177) = v169;
    LODWORD(v177) = v169;
    int v182 = v177 >> 2;
    unint64_t v183 = __PAIR64__(v179, __ROR4__(v163, 2));
    int v184 = v181 + (v182 ^ v183 ^ v174);
    LODWORD(v183) = v179;
    unsigned int v185 = v184 + (v183 >> 27);
    LODWORD(v183) = v471 ^ __ROR4__(v466, 31) ^ __ROR4__(v139, 31) ^ __ROR4__(v170, 31);
    int v186 = v183;
    HIDWORD(v183) = v183;
    int v472 = v183 >> 31;
    HIDWORD(v183) = v174;
    LODWORD(v183) = v174;
    int v187 = v183 >> 2;
    unint64_t v188 = __PAIR64__(v185, __ROR4__(v169, 2));
    int v189 = v472 + 1859775393 + v176 + (v187 ^ v188 ^ v179);
    LODWORD(v188) = v185;
    unsigned int v190 = v189 + (v188 >> 27);
    LODWORD(v188) = v110 ^ __ROR4__(v90, 31) ^ __ROR4__(v146, 31) ^ __ROR4__(v175, 31);
    int v191 = v188;
    HIDWORD(v188) = v188;
    int v484 = v188 >> 31;
    int v192 = v484 + 1859775393 + v182;
    HIDWORD(v188) = v179;
    LODWORD(v188) = v179;
    int v193 = v188 >> 2;
    unint64_t v194 = __PAIR64__(v190, __ROR4__(v174, 2));
    int v195 = v192 + (v193 ^ v194 ^ v185);
    LODWORD(v194) = v190;
    unsigned int v196 = v195 + (v194 >> 27);
    LODWORD(v194) = v480 ^ __ROR4__(v468, 31) ^ __ROR4__(v153, 31) ^ __ROR4__(v180, 31);
    int v197 = v194;
    HIDWORD(v194) = v194;
    int v481 = v194 >> 31;
    int v198 = v481 + 1859775393 + v187;
    HIDWORD(v194) = v185;
    LODWORD(v194) = v185;
    int v199 = v194 >> 2;
    unint64_t v200 = __PAIR64__(v196, __ROR4__(v179, 2));
    int v201 = v198 + (v199 ^ v200 ^ v190);
    LODWORD(v200) = v196;
    unsigned int v202 = v201 + (v200 >> 27);
    LODWORD(v200) = v477 ^ __ROR4__(v109, 31) ^ __ROR4__(v159, 31) ^ __ROR4__(v186, 31);
    HIDWORD(v200) = v200;
    int v478 = v200 >> 31;
    int v203 = v200;
    int v204 = v478 + 1859775393 + v193;
    HIDWORD(v200) = v190;
    LODWORD(v200) = v190;
    int v205 = v200 >> 2;
    unint64_t v206 = __PAIR64__(v202, __ROR4__(v185, 2));
    int v207 = v204 + (v205 ^ v206 ^ v196);
    LODWORD(v206) = v202;
    unsigned int v208 = v207 + (v206 >> 27);
    LODWORD(v206) = v474 ^ __ROR4__(v111, 31) ^ __ROR4__(v164, 31) ^ __ROR4__(v191, 31);
    int v209 = v206;
    HIDWORD(v206) = v206;
    int v210 = v206 >> 31;
    HIDWORD(v206) = v196;
    LODWORD(v206) = v196;
    int v211 = v206 >> 2;
    unint64_t v212 = __PAIR64__(v208, __ROR4__(v190, 2));
    int v213 = v210 + 1859775393 + v199 + (v211 ^ v212 ^ v202);
    LODWORD(v212) = v208;
    unsigned int v214 = v213 + (v212 >> 27);
    LODWORD(v212) = v487 ^ __ROR4__(v116, 31) ^ __ROR4__(v170, 31) ^ __ROR4__(v197, 31);
    int v215 = v212;
    HIDWORD(v212) = v212;
    int v475 = v212 >> 31;
    HIDWORD(v212) = v202;
    LODWORD(v212) = v202;
    int v216 = v212 >> 2;
    unint64_t v217 = __PAIR64__(v214, __ROR4__(v196, 2));
    int v218 = v475 + 1859775393 + v205 + (v216 ^ v217 ^ v208);
    LODWORD(v217) = v214;
    unsigned int v219 = v218 + (v217 >> 27);
    int v221 = v203;
    LODWORD(v217) = v510 ^ __ROR4__(v127, 31) ^ __ROR4__(v175, 31) ^ __ROR4__(v203, 31);
    int v220 = v217;
    HIDWORD(v217) = v217;
    int v488 = v217 >> 31;
    HIDWORD(v217) = v208;
    LODWORD(v217) = v208;
    int v222 = v217 >> 2;
    unint64_t v223 = __PAIR64__(v219, __ROR4__(v202, 2));
    int v224 = v488 + 1859775393 + v211 + (v222 ^ v223 ^ v214);
    LODWORD(v223) = v219;
    unsigned int v225 = v224 + (v223 >> 27);
    int v226 = v209;
    LODWORD(v223) = v148 ^ __ROR4__(v131, 31) ^ __ROR4__(v180, 31) ^ __ROR4__(v209, 31);
    HIDWORD(v223) = v223;
    int v511 = v223 >> 31;
    int v227 = v223;
    HIDWORD(v223) = v214;
    LODWORD(v223) = v214;
    int v228 = v223 >> 2;
    unint64_t v229 = __PAIR64__(v225, __ROR4__(v208, 2));
    int v230 = v511 + 1859775393 + v216 + (v228 ^ v229 ^ v219);
    LODWORD(v229) = v225;
    unsigned int v231 = v230 + (v229 >> 27);
    LODWORD(v229) = v506 ^ __ROR4__(v139, 31) ^ __ROR4__(v186, 31) ^ __ROR4__(v215, 31);
    int v232 = v229;
    HIDWORD(v229) = v229;
    int v507 = v229 >> 31;
    HIDWORD(v229) = v231;
    LODWORD(v229) = v231;
    unsigned int v233 = v507
         - 1894007588
         + v222
         + ((v225 | __ROR4__(v219, 2)) & __ROR4__(v214, 2) | v225 & __ROR4__(v219, 2))
         + (v229 >> 27);
    LODWORD(v229) = v502 ^ __ROR4__(v146, 31) ^ __ROR4__(v191, 31) ^ __ROR4__(v220, 31);
    HIDWORD(v229) = v229;
    int v503 = v229 >> 31;
    int v234 = v229;
    HIDWORD(v229) = v233;
    LODWORD(v229) = v233;
    unsigned int v235 = v503
         - 1894007588
         + v228
         + ((v231 | __ROR4__(v225, 2)) & __ROR4__(v219, 2) | v231 & __ROR4__(v225, 2))
         + (v229 >> 27);
    unint64_t v237 = __PAIR64__(v219, __ROR4__(v153, 31));
    int v236 = v498 ^ v237;
    LODWORD(v237) = v219;
    int v238 = v237 >> 2;
    int v240 = v227;
    LODWORD(v237) = v236 ^ __ROR4__(v197, 31) ^ __ROR4__(v227, 31);
    int v239 = v237;
    HIDWORD(v237) = v237;
    int v499 = v237 >> 31;
    unint64_t v242 = __PAIR64__(v235, __ROR4__(v159, 31));
    int v241 = v514 ^ v242;
    LODWORD(v242) = v235;
    unsigned int v243 = v499
         - 1894007588
         + v238
         + ((v233 | __ROR4__(v231, 2)) & __ROR4__(v225, 2) | v233 & __ROR4__(v231, 2))
         + (v242 >> 27);
    HIDWORD(v242) = v225;
    LODWORD(v242) = v225;
    int v244 = v242 >> 2;
    LODWORD(v242) = v241 ^ __ROR4__(v221, 31) ^ __ROR4__(v232, 31);
    int v245 = v242;
    HIDWORD(v242) = v242;
    int v515 = v242 >> 31;
    unint64_t v246 = __PAIR64__(v243, __ROR4__(v233, 2));
    int v247 = v515 - 1894007588 + v244 + ((v235 | __ROR4__(v233, 2)) & __ROR4__(v231, 2) | v235 & v246);
    LODWORD(v246) = v243;
    unsigned int v248 = v247 + (v246 >> 27);
    unint64_t v250 = __PAIR64__(v231, __ROR4__(v226, 31));
    int v249 = v494 ^ __ROR4__(v164, 31) ^ v250;
    int v251 = v226;
    LODWORD(v250) = v231;
    int v252 = v250 >> 2;
    int v254 = v234;
    LODWORD(v250) = v249 ^ __ROR4__(v234, 31);
    int v253 = v250;
    HIDWORD(v250) = v250;
    int v495 = v250 >> 31;
    HIDWORD(v250) = v248;
    LODWORD(v250) = v248;
    int v255 = v495
         - 1894007588
         + v252
         + ((v243 | __ROR4__(v235, 2)) & __ROR4__(v233, 2) | v243 & __ROR4__(v235, 2))
         + (v250 >> 27);
    unint64_t v257 = __PAIR64__(v233, __ROR4__(v239, 31));
    int v256 = v490 ^ __ROR4__(v170, 31) ^ __ROR4__(v215, 31) ^ v257;
    LODWORD(v257) = v233;
    int v258 = v257 >> 2;
    HIDWORD(v257) = v256;
    LODWORD(v257) = v256;
    int v491 = v257 >> 31;
    HIDWORD(v257) = v255;
    LODWORD(v257) = v255;
    unsigned int v259 = v491
         - 1894007588
         + v258
         + ((v248 | __ROR4__(v243, 2)) & __ROR4__(v235, 2) | v248 & __ROR4__(v243, 2))
         + (v257 >> 27);
    unint64_t v261 = __PAIR64__(v235, __ROR4__(v220, 31));
    int v260 = v472 ^ __ROR4__(v175, 31) ^ v261;
    LODWORD(v261) = v235;
    int v262 = v261 >> 2;
    int v263 = v260 ^ __ROR4__(v245, 31);
    unint64_t v265 = __PAIR64__(v263, __ROR4__(v243, 2));
    int v264 = (v255 | __ROR4__(v248, 2)) & v265;
    LODWORD(v265) = v263;
    int v469 = v265 >> 31;
    unint64_t v266 = __PAIR64__(v259, __ROR4__(v248, 2));
    int v267 = v469 - 1894007588 + v262 + (v264 | v255 & v266);
    LODWORD(v266) = v259;
    unsigned int v268 = v267 + (v266 >> 27);
    unint64_t v269 = __PAIR64__(v243, __ROR4__(v255, 2));
    int v270 = (v259 | __ROR4__(v255, 2)) & __ROR4__(v248, 2) | v259 & v269;
    LODWORD(v269) = v243;
    int v271 = v269 >> 2;
    LODWORD(v269) = v484 ^ __ROR4__(v180, 31) ^ __ROR4__(v240, 31) ^ __ROR4__(v253, 31);
    int v272 = v269;
    HIDWORD(v269) = v269;
    int v485 = v269 >> 31;
    HIDWORD(v269) = v268;
    LODWORD(v269) = v268;
    unsigned int v273 = v485 - 1894007588 + v271 + v270 + (v269 >> 27);
    unint64_t v275 = __PAIR64__(v248, __ROR4__(v186, 31));
    int v274 = v481 ^ v275;
    LODWORD(v275) = v248;
    int v276 = v275 >> 2;
    LODWORD(v275) = v274 ^ __ROR4__(v232, 31) ^ __ROR4__(v256, 31);
    int v277 = v275;
    HIDWORD(v275) = v275;
    int v482 = v275 >> 31;
    int v278 = v482 - 1894007588 + v276 + ((v268 | __ROR4__(v259, 2)) & __ROR4__(v255, 2) | v268 & __ROR4__(v259, 2));
    unint64_t v280 = __PAIR64__(v273, __ROR4__(v191, 31));
    int v279 = v478 ^ v280;
    LODWORD(v280) = v273;
    unsigned int v281 = v278 + (v280 >> 27);
    HIDWORD(v280) = v255;
    LODWORD(v280) = v255;
    int v282 = v280 >> 2;
    LODWORD(v280) = v279 ^ __ROR4__(v234, 31) ^ __ROR4__(v263, 31);
    int v283 = v280;
    HIDWORD(v280) = v280;
    int v479 = v280 >> 31;
    unint64_t v284 = __PAIR64__(v281, __ROR4__(v268, 2));
    int v285 = v479 - 1894007588 + v282 + ((v273 | __ROR4__(v268, 2)) & __ROR4__(v259, 2) | v273 & v284);
    LODWORD(v284) = v281;
    unsigned int v286 = v285 + (v284 >> 27);
    unint64_t v288 = __PAIR64__(v259, __ROR4__(v239, 31));
    int v287 = v210 ^ __ROR4__(v197, 31) ^ v288;
    LODWORD(v288) = v259;
    int v289 = v288 >> 2;
    LODWORD(v288) = v287 ^ __ROR4__(v272, 31);
    int v290 = v288;
    HIDWORD(v288) = v288;
    int v473 = v288 >> 31;
    HIDWORD(v288) = v286;
    LODWORD(v288) = v286;
    int v291 = v473
         - 1894007588
         + v289
         + ((v281 | __ROR4__(v273, 2)) & __ROR4__(v268, 2) | v281 & __ROR4__(v273, 2))
         + (v288 >> 27);
    unint64_t v293 = __PAIR64__(v268, __ROR4__(v277, 31));
    int v292 = v475 ^ __ROR4__(v221, 31) ^ __ROR4__(v245, 31) ^ v293;
    LODWORD(v293) = v268;
    int v294 = v293 >> 2;
    HIDWORD(v293) = v292;
    LODWORD(v293) = v292;
    int v476 = v293 >> 31;
    HIDWORD(v293) = v291;
    LODWORD(v293) = v291;
    unsigned int v295 = v476
         - 1894007588
         + v294
         + ((v286 | __ROR4__(v281, 2)) & __ROR4__(v273, 2) | v286 & __ROR4__(v281, 2))
         + (v293 >> 27);
    unint64_t v297 = __PAIR64__(v273, __ROR4__(v253, 31));
    int v296 = v488 ^ __ROR4__(v251, 31) ^ v297;
    LODWORD(v297) = v273;
    int v298 = v297 >> 2;
    int v299 = v296 ^ __ROR4__(v283, 31);
    unint64_t v301 = __PAIR64__(v299, __ROR4__(v281, 2));
    int v300 = (v291 | __ROR4__(v286, 2)) & v301;
    LODWORD(v301) = v299;
    int v489 = v301 >> 31;
    unint64_t v302 = __PAIR64__(v295, __ROR4__(v286, 2));
    int v303 = v489 - 1894007588 + v298 + (v300 | v291 & v302);
    LODWORD(v302) = v295;
    unsigned int v304 = v303 + (v302 >> 27);
    unint64_t v305 = __PAIR64__(v281, __ROR4__(v291, 2));
    int v306 = (v295 | __ROR4__(v291, 2)) & __ROR4__(v286, 2) | v295 & v305;
    LODWORD(v305) = v281;
    int v307 = v305 >> 2;
    LODWORD(v305) = v511 ^ __ROR4__(v215, 31) ^ __ROR4__(v256, 31) ^ __ROR4__(v290, 31);
    int v308 = v305;
    HIDWORD(v305) = v305;
    int v512 = v305 >> 31;
    HIDWORD(v305) = v304;
    LODWORD(v305) = v304;
    unsigned int v309 = v512 - 1894007588 + v307 + v306 + (v305 >> 27);
    unint64_t v311 = __PAIR64__(v286, __ROR4__(v220, 31));
    int v310 = v507 ^ v311;
    LODWORD(v311) = v286;
    int v312 = v311 >> 2;
    int v313 = v263;
    LODWORD(v311) = v310 ^ __ROR4__(v263, 31) ^ __ROR4__(v292, 31);
    int v314 = v311;
    HIDWORD(v311) = v311;
    int v508 = v311 >> 31;
    unint64_t v316 = __PAIR64__(v309, __ROR4__(v240, 31));
    int v315 = v503 ^ v316;
    LODWORD(v316) = v309;
    unsigned int v317 = v508
         - 1894007588
         + v312
         + ((v304 | __ROR4__(v295, 2)) & __ROR4__(v291, 2) | v304 & __ROR4__(v295, 2))
         + (v316 >> 27);
    HIDWORD(v316) = v291;
    LODWORD(v316) = v291;
    int v318 = v316 >> 2;
    LODWORD(v316) = v315 ^ __ROR4__(v272, 31) ^ __ROR4__(v299, 31);
    int v319 = v316;
    HIDWORD(v316) = v316;
    int v504 = v316 >> 31;
    unint64_t v320 = __PAIR64__(v317, __ROR4__(v304, 2));
    int v321 = v504 - 1894007588 + v318 + ((v309 | __ROR4__(v304, 2)) & __ROR4__(v295, 2) | v309 & v320);
    LODWORD(v320) = v317;
    unsigned int v322 = v321 + (v320 >> 27);
    unint64_t v324 = __PAIR64__(v295, __ROR4__(v277, 31));
    int v323 = v499 ^ __ROR4__(v232, 31) ^ v324;
    LODWORD(v324) = v295;
    int v325 = v324 >> 2;
    LODWORD(v324) = v323 ^ __ROR4__(v308, 31);
    int v326 = v324;
    HIDWORD(v324) = v324;
    int v500 = v324 >> 31;
    HIDWORD(v324) = v322;
    LODWORD(v324) = v322;
    int v327 = v500
         - 1894007588
         + v325
         + ((v317 | __ROR4__(v309, 2)) & __ROR4__(v304, 2) | v317 & __ROR4__(v309, 2))
         + (v324 >> 27);
    unint64_t v329 = __PAIR64__(v304, __ROR4__(v314, 31));
    int v328 = v515 ^ __ROR4__(v254, 31) ^ __ROR4__(v283, 31) ^ v329;
    LODWORD(v329) = v304;
    int v330 = v329 >> 2;
    HIDWORD(v329) = v328;
    LODWORD(v329) = v328;
    int v516 = v329 >> 31;
    HIDWORD(v329) = v327;
    LODWORD(v329) = v327;
    unsigned int v331 = v516
         - 1894007588
         + v330
         + ((v322 | __ROR4__(v317, 2)) & __ROR4__(v309, 2) | v322 & __ROR4__(v317, 2))
         + (v329 >> 27);
    unint64_t v333 = __PAIR64__(v309, __ROR4__(v290, 31));
    int v332 = v495 ^ __ROR4__(v239, 31) ^ v333;
    LODWORD(v333) = v309;
    int v334 = v333 >> 2;
    int v335 = v332 ^ __ROR4__(v319, 31);
    unint64_t v337 = __PAIR64__(v335, __ROR4__(v317, 2));
    int v336 = (v327 | __ROR4__(v322, 2)) & v337;
    LODWORD(v337) = v335;
    int v496 = v337 >> 31;
    unint64_t v338 = __PAIR64__(v331, __ROR4__(v322, 2));
    int v339 = v496 - 1894007588 + v334 + (v336 | v327 & v338);
    LODWORD(v338) = v331;
    int v340 = v339 + (v338 >> 27);
    int v341 = v491 ^ __ROR4__(v245, 31);
    unint64_t v342 = __PAIR64__(v317, __ROR4__(v327, 2));
    int v343 = (v331 | __ROR4__(v327, 2)) & __ROR4__(v322, 2) | v331 & v342;
    LODWORD(v342) = v317;
    int v344 = v342 >> 2;
    LODWORD(v342) = v341 ^ __ROR4__(v292, 31) ^ __ROR4__(v326, 31);
    int v345 = v342;
    HIDWORD(v342) = v342;
    int v467 = v342 >> 31;
    int v346 = v467 - 1894007588 + v344 + v343;
    unint64_t v348 = __PAIR64__(v322, __ROR4__(v253, 31));
    int v347 = v469 ^ v348;
    LODWORD(v348) = v322;
    int v349 = v348 >> 2;
    int v350 = v347 ^ __ROR4__(v299, 31) ^ __ROR4__(v328, 31);
    HIDWORD(v348) = v350;
    LODWORD(v348) = v350;
    int v470 = v348 >> 31;
    HIDWORD(v348) = v340;
    LODWORD(v348) = v340;
    unsigned int v351 = v346 + (v348 >> 27);
    HIDWORD(v348) = v331;
    LODWORD(v348) = v331;
    int v352 = v348 >> 2;
    unint64_t v354 = __PAIR64__(v351, __ROR4__(v256, 31));
    int v353 = v485 ^ v354;
    LODWORD(v354) = v351;
    unsigned int v355 = v470 - 899497514 + v349 + (v352 ^ __ROR4__(v327, 2) ^ v340) + (v354 >> 27);
    HIDWORD(v354) = v327;
    LODWORD(v354) = v327;
    int v356 = v354 >> 2;
    int v357 = v353 ^ __ROR4__(v308, 31) ^ __ROR4__(v335, 31);
    HIDWORD(v354) = v357;
    LODWORD(v354) = v357;
    int v358 = v354 >> 31;
    HIDWORD(v354) = v340;
    LODWORD(v354) = v340;
    int v359 = v354 >> 2;
    unint64_t v360 = __PAIR64__(v355, __ROR4__(v331, 2));
    int v361 = v358 - 899497514 + v356 + (v359 ^ v360 ^ v351);
    LODWORD(v360) = v355;
    unsigned int v362 = v361 + (v360 >> 27);
    LODWORD(v360) = v482 ^ __ROR4__(v313, 31) ^ __ROR4__(v314, 31) ^ __ROR4__(v345, 31);
    int v363 = v360;
    HIDWORD(v360) = v360;
    int v492 = v360 >> 31;
    HIDWORD(v360) = v351;
    LODWORD(v360) = v351;
    int v364 = v360 >> 2;
    unint64_t v365 = __PAIR64__(v362, __ROR4__(v340, 2));
    int v366 = v492 - 899497514 + v352 + (v364 ^ v365 ^ v355);
    LODWORD(v365) = v362;
    unsigned int v367 = v366 + (v365 >> 27);
    LODWORD(v365) = v479 ^ __ROR4__(v272, 31) ^ __ROR4__(v319, 31) ^ __ROR4__(v350, 31);
    int v368 = v365;
    HIDWORD(v365) = v365;
    int v483 = v365 >> 31;
    HIDWORD(v365) = v355;
    LODWORD(v365) = v355;
    int v369 = v365 >> 2;
    unint64_t v370 = __PAIR64__(v367, __ROR4__(v351, 2));
    int v371 = v483 - 899497514 + v359 + (v369 ^ v370 ^ v362);
    LODWORD(v370) = v367;
    unsigned int v372 = v371 + (v370 >> 27);
    LODWORD(v370) = v473 ^ __ROR4__(v277, 31) ^ __ROR4__(v326, 31) ^ __ROR4__(v357, 31);
    int v373 = v370;
    HIDWORD(v370) = v370;
    int v486 = v370 >> 31;
    HIDWORD(v370) = v362;
    LODWORD(v370) = v362;
    int v374 = v370 >> 2;
    unint64_t v375 = __PAIR64__(v372, __ROR4__(v355, 2));
    int v376 = v486 - 899497514 + v364 + (v374 ^ v375 ^ v367);
    LODWORD(v375) = v372;
    unsigned int v377 = v376 + (v375 >> 27);
    LODWORD(v375) = v476 ^ __ROR4__(v283, 31) ^ __ROR4__(v328, 31) ^ __ROR4__(v363, 31);
    int v378 = v375;
    HIDWORD(v375) = v375;
    int v379 = v375 >> 31;
    HIDWORD(v375) = v367;
    LODWORD(v375) = v367;
    int v380 = v375 >> 2;
    unint64_t v381 = __PAIR64__(v377, __ROR4__(v362, 2));
    int v382 = v379 - 899497514 + v369 + (v380 ^ v381 ^ v372);
    LODWORD(v381) = v377;
    unsigned int v383 = v382 + (v381 >> 27);
    LODWORD(v381) = v489 ^ __ROR4__(v290, 31) ^ __ROR4__(v335, 31) ^ __ROR4__(v368, 31);
    int v384 = v381;
    HIDWORD(v381) = v381;
    int v385 = (v381 >> 31) - 899497514;
    HIDWORD(v381) = v372;
    LODWORD(v381) = v372;
    int v386 = v381 >> 2;
    unint64_t v387 = __PAIR64__(v383, __ROR4__(v367, 2));
    int v388 = v385 + v374 + (v386 ^ v387 ^ v377);
    LODWORD(v387) = v383;
    unsigned int v389 = v388 + (v387 >> 27);
    LODWORD(v387) = v512 ^ __ROR4__(v292, 31) ^ __ROR4__(v345, 31) ^ __ROR4__(v373, 31);
    int v390 = v387;
    HIDWORD(v387) = v387;
    int v391 = (v387 >> 31) - 899497514 + v380;
    HIDWORD(v387) = v377;
    LODWORD(v387) = v377;
    int v392 = v387 >> 2;
    unint64_t v393 = __PAIR64__(v389, __ROR4__(v372, 2));
    int v394 = v391 + (v392 ^ v393 ^ v383);
    LODWORD(v393) = v389;
    unsigned int v395 = v394 + (v393 >> 27);
    int v396 = v508 ^ __ROR4__(v299, 31) ^ __ROR4__(v350, 31) ^ __ROR4__(v378, 31);
    HIDWORD(v393) = v396;
    LODWORD(v393) = v396;
    int v397 = (v393 >> 31) - 899497514;
    HIDWORD(v393) = v383;
    LODWORD(v393) = v383;
    int v398 = v393 >> 2;
    unint64_t v399 = __PAIR64__(v395, __ROR4__(v377, 2));
    int v400 = v397 + v386 + (v398 ^ v399 ^ v389);
    LODWORD(v399) = v395;
    unsigned int v401 = v400 + (v399 >> 27);
    LODWORD(v399) = v504 ^ __ROR4__(v308, 31) ^ __ROR4__(v357, 31) ^ __ROR4__(v384, 31);
    int v402 = v399;
    HIDWORD(v399) = v399;
    int v403 = (v399 >> 31) - 899497514 + v392;
    HIDWORD(v399) = v389;
    LODWORD(v399) = v389;
    int v404 = v399 >> 2;
    unint64_t v405 = __PAIR64__(v401, __ROR4__(v383, 2));
    int v406 = v403 + (v404 ^ v405 ^ v395);
    LODWORD(v405) = v401;
    unsigned int v407 = v406 + (v405 >> 27);
    LODWORD(v405) = v500 ^ __ROR4__(v314, 31) ^ __ROR4__(v363, 31) ^ __ROR4__(v390, 31);
    int v408 = v405;
    HIDWORD(v405) = v405;
    int v409 = (v405 >> 31) - 899497514;
    HIDWORD(v405) = v395;
    LODWORD(v405) = v395;
    int v410 = v405 >> 2;
    unint64_t v411 = __PAIR64__(v407, __ROR4__(v389, 2));
    int v412 = v409 + v398 + (v410 ^ v411 ^ v401);
    LODWORD(v411) = v407;
    unsigned int v413 = v412 + (v411 >> 27);
    int v414 = v516 ^ __ROR4__(v319, 31) ^ __ROR4__(v368, 31) ^ __ROR4__(v396, 31);
    HIDWORD(v411) = v414;
    LODWORD(v411) = v414;
    int v415 = (v411 >> 31) - 899497514 + v404;
    HIDWORD(v411) = v401;
    LODWORD(v411) = v401;
    int v416 = v411 >> 2;
    unint64_t v418 = __PAIR64__(v413, __ROR4__(v326, 31));
    int v417 = v496 ^ v418;
    LODWORD(v418) = v413;
    unsigned int v419 = v415 + (v416 ^ __ROR4__(v395, 2) ^ v407) + (v418 >> 27);
    int v420 = v417 ^ __ROR4__(v373, 31) ^ __ROR4__(v402, 31);
    HIDWORD(v418) = v420;
    LODWORD(v418) = v420;
    int v421 = (v418 >> 31) - 899497514;
    HIDWORD(v418) = v407;
    LODWORD(v418) = v407;
    int v422 = v418 >> 2;
    unint64_t v423 = __PAIR64__(v419, __ROR4__(v401, 2));
    int v424 = v421 + v410 + (v422 ^ v423 ^ v413);
    LODWORD(v423) = v419;
    unsigned int v425 = v424 + (v423 >> 27);
    int v426 = v467 ^ __ROR4__(v328, 31) ^ __ROR4__(v378, 31) ^ __ROR4__(v408, 31);
    HIDWORD(v423) = v426;
    LODWORD(v423) = v426;
    int v427 = (v423 >> 31) - 899497514 + v416;
    HIDWORD(v423) = v413;
    LODWORD(v423) = v413;
    int v428 = v423 >> 2;
    int v429 = v427 + (v428 ^ __ROR4__(v407, 2) ^ v419);
    unint64_t v431 = __PAIR64__(v425, __ROR4__(v335, 31));
    int v430 = v470 ^ v431;
    LODWORD(v431) = v425;
    unsigned int v432 = v429 + (v431 >> 27);
    int v433 = v430 ^ __ROR4__(v384, 31) ^ __ROR4__(v414, 31);
    HIDWORD(v431) = v433;
    LODWORD(v431) = v433;
    int v434 = (v431 >> 31) - 899497514;
    HIDWORD(v431) = v419;
    LODWORD(v431) = v419;
    int v435 = v431 >> 2;
    unint64_t v436 = __PAIR64__(v432, __ROR4__(v413, 2));
    int v437 = v434 + v422 + (v435 ^ v436 ^ v425);
    LODWORD(v436) = v432;
    unsigned int v438 = v437 + (v436 >> 27);
    int v439 = v358 ^ __ROR4__(v345, 31) ^ __ROR4__(v390, 31) ^ __ROR4__(v420, 31);
    HIDWORD(v436) = v439;
    LODWORD(v436) = v439;
    int v440 = (v436 >> 31) - 899497514 + v428;
    HIDWORD(v436) = v425;
    LODWORD(v436) = v425;
    int v441 = v436 >> 2;
    unint64_t v443 = __PAIR64__(v438, __ROR4__(v396, 31));
    int v442 = v492 ^ __ROR4__(v350, 31) ^ v443;
    LODWORD(v443) = v438;
    unsigned int v444 = v440 + (v441 ^ __ROR4__(v419, 2) ^ v432) + (v443 >> 27);
    int v445 = v442 ^ __ROR4__(v426, 31);
    HIDWORD(v443) = v445;
    LODWORD(v443) = v445;
    int v446 = (v443 >> 31) - 899497514;
    HIDWORD(v443) = v432;
    LODWORD(v443) = v432;
    int v447 = v443 >> 2;
    unint64_t v448 = __PAIR64__(v444, __ROR4__(v425, 2));
    int v449 = v446 + v435 + (v447 ^ v448 ^ v438);
    LODWORD(v448) = v444;
    unsigned int v450 = v449 + (v448 >> 27);
    LODWORD(v448) = v483 ^ __ROR4__(v357, 31) ^ __ROR4__(v402, 31) ^ __ROR4__(v433, 31);
    HIDWORD(v448) = v448;
    int v451 = (v448 >> 31) - 899497514 + v441;
    HIDWORD(v448) = v438;
    LODWORD(v448) = v438;
    uint64_t result = (v448 >> 2);
    unint64_t v454 = __PAIR64__(v450, __ROR4__(v408, 31));
    int v453 = v486 ^ __ROR4__(v363, 31) ^ v454;
    LODWORD(v454) = v450;
    unsigned int v455 = v451 + (result ^ __ROR4__(v432, 2) ^ v444) + (v454 >> 27);
    LODWORD(v454) = v453 ^ __ROR4__(v439, 31);
    HIDWORD(v454) = v454;
    int v456 = (v454 >> 31) - 899497514;
    HIDWORD(v454) = v444;
    LODWORD(v454) = v444;
    int v457 = v454 >> 2;
    unint64_t v458 = __PAIR64__(v455, __ROR4__(v438, 2));
    int v459 = v456 + v447 + (v457 ^ v458 ^ v450);
    LODWORD(v458) = v455;
    unsigned int v460 = v459 + (v458 >> 27);
    LODWORD(v458) = v379 ^ __ROR4__(v368, 31) ^ __ROR4__(v414, 31) ^ __ROR4__(v445, 31);
    HIDWORD(v458) = v458;
    int v461 = v517 - 899497514 + (v458 >> 31) + result;
    HIDWORD(v458) = v450;
    LODWORD(v458) = v450;
    int v462 = v458 >> 2;
    unint64_t v463 = __PAIR64__(v460, __ROR4__(v444, 2));
    int v464 = v461 + (v462 ^ v463 ^ v455);
    int v5 = v460 + v523;
    LODWORD(v463) = v460;
    int v7 = v464 + (v463 >> 27);
    HIDWORD(v463) = v455;
    LODWORD(v463) = v455;
    int v6 = (v463 >> 2) + v521;
    int v3 = v462 + v522;
    int v4 = v457 + v518;
    *a1 = v7;
    a1[1] = v5;
    a1[2] = v6;
    a1[3] = v3;
    a1[4] = v457 + v518;
    a2 = v519 + 16;
    a3 = v520 - 1;
  }
  while (v520 != 1);
  return result;
}

_DWORD *sub_244D3828C(_DWORD *result, unsigned int *a2)
{
  *uint64_t result = bswap32(*a2);
  result[1] = bswap32(a2[1]);
  result[2] = bswap32(a2[2]);
  result[3] = bswap32(a2[3]);
  result[4] = bswap32(a2[4]);
  return result;
}

_DWORD *sub_244D382CC(_DWORD *result, size_t a2, long long *a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  memset(v23, 0, sizeof(v23));
  long long v22 = 0u;
  long long v20 = *a3;
  int v21 = *((_DWORD *)a3 + 4);
  if (a2)
  {
    size_t v3 = a2;
    for (size_t i = result; ; i += 5)
    {
      long long v18 = 0u;
      memset(v19, 0, sizeof(v19));
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = xmmword_244EB6ED0;
      int v15 = -1009589776;
      int v5 = 1;
      sub_244D3708C((int *)&v14, (unsigned int *)&v20, 1);
      for (uint64_t j = 16; j != -4; j -= 4)
      {
        unsigned int v7 = bswap32(*(_DWORD *)((char *)&v20 + j));
        int v8 = *(_DWORD *)((char *)&v14 + j);
        BOOL v9 = __CFADD__(v7, v8);
        int v10 = v7 + v8;
        int v11 = v9;
        BOOL v9 = __CFADD__(v10, v5);
        unsigned int v12 = v10 + v5;
        if (v9) {
          int v5 = 1;
        }
        else {
          int v5 = v11;
        }
        *(_DWORD *)((char *)&v20 + j) = bswap32(v12);
      }
      if (v3 < 0x14) {
        break;
      }
      uint64_t result = sub_244D3828C(i, (unsigned int *)&v14);
      v3 -= 20;
      if (!v3) {
        return result;
      }
    }
    sub_244D3828C(__src, (unsigned int *)&v14);
    return memcpy(i, __src, v3);
  }
  return result;
}

uint64_t sub_244D38424(uint64_t a1)
{
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)a1 = xmmword_244EB6E10;
  *(_OWORD *)(a1 + 16) = xmmword_244EB6E20;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 108) = 28;
  return 1;
}

uint64_t sub_244D38458(uint64_t a1)
{
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)a1 = xmmword_244EB6E30;
  *(_OWORD *)(a1 + 16) = xmmword_244EB6E40;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 108) = 32;
  return 1;
}

uint64_t sub_244D3848C(uint64_t a1, char *__src, size_t __n)
{
  return 1;
}

uint64_t sub_244D384D4(_DWORD *a1, uint64_t a2)
{
  return sub_244D39114(a1, 0x1CuLL, a2);
}

uint64_t sub_244D384E0(_DWORD *a1, uint64_t a2)
{
  return sub_244D39114(a1, *(unsigned int *)(a2 + 108), a2);
}

unint64_t sub_244D384EC(unint64_t a1, unsigned int *a2)
{
  return sub_244D384F4(a1, a2, 1);
}

unint64_t sub_244D384F4(unint64_t result, unsigned int *a2, uint64_t a3)
{
  unint64_t v217 = (_DWORD *)result;
  uint64_t v229 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unsigned int v3 = *(_DWORD *)result;
    int v4 = *(_DWORD *)(result + 4);
    int v6 = *(_DWORD *)(result + 8);
    int v5 = *(_DWORD *)(result + 12);
    int v8 = *(_DWORD *)(result + 16);
    int v7 = *(_DWORD *)(result + 20);
    int v9 = *(_DWORD *)(result + 24);
    LODWORD(result) = *(_DWORD *)(result + 28);
    do
    {
      uint64_t v227 = a3;
      unsigned int v10 = bswap32(*a2);
      HIDWORD(v11) = v8;
      LODWORD(v11) = v8;
      int v12 = (v11 >> 6) ^ __ROR4__(v8, 11);
      unint64_t v13 = __PAIR64__(v3, __ROR4__(v8, 25));
      int v218 = result;
      int v14 = result + (v8 & v7) + (v9 & ~v8) + v10 + (v12 ^ v13) + 1116352408;
      LODWORD(v13) = v3;
      int v222 = v5;
      int v15 = v14 + v5;
      unsigned int v16 = ((v13 >> 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + ((v4 ^ v6) & v3 ^ v4 & v6) + v14;
      unsigned int v17 = bswap32(a2[1]);
      HIDWORD(v13) = v15;
      LODWORD(v13) = v15;
      v228[0] = v10;
      v228[1] = v17;
      int v18 = (v13 >> 6) ^ __ROR4__(v15, 11);
      unint64_t v19 = __PAIR64__(v16, __ROR4__(v15, 25));
      int v219 = v9;
      int v20 = v9 + v17 + (v7 & ~v15) + (v15 & v8) + 1899447441 + (v18 ^ v19);
      LODWORD(v19) = v16;
      int v223 = v6;
      int v21 = v20 + v6;
      unsigned int v22 = ((v19 >> 2) ^ __ROR4__(v16, 13) ^ __ROR4__(v16, 22)) + (v16 & (v3 ^ v4) ^ v3 & v4) + v20;
      unsigned int v23 = bswap32(a2[2]);
      HIDWORD(v19) = v21;
      LODWORD(v19) = v21;
      int v24 = (v19 >> 6) ^ __ROR4__(v21, 11);
      unint64_t v26 = __PAIR64__(v22, __ROR4__(v21, 25));
      int v25 = v24 ^ v26;
      int v220 = v7;
      LODWORD(v26) = v22;
      int v27 = v7 + v23 + (v8 & ~v21) + (v21 & v15) - 1245643825 + v25;
      int v224 = v4;
      int v28 = v27 + v4;
      unsigned int v29 = ((v26 >> 2) ^ __ROR4__(v22, 13) ^ __ROR4__(v22, 22)) + (v22 & (v16 ^ v3) ^ v16 & v3) + v27;
      unsigned int v30 = bswap32(a2[3]);
      v228[2] = v23;
      v228[3] = v30;
      HIDWORD(v26) = v28;
      LODWORD(v26) = v28;
      int v31 = (v26 >> 6) ^ __ROR4__(v28, 11);
      unint64_t v32 = __PAIR64__(v29, __ROR4__(v28, 25));
      int v221 = v8;
      int v33 = v8 + v30 + (v15 & ~v28) + (v28 & v21) - 373957723 + (v31 ^ v32);
      LODWORD(v32) = v29;
      unsigned int v225 = v3;
      int v34 = v33 + v3;
      unsigned int v35 = ((v32 >> 2) ^ __ROR4__(v29, 13) ^ __ROR4__(v29, 22)) + (v29 & (v22 ^ v16) ^ v22 & v16) + v33;
      unsigned int v36 = bswap32(a2[4]);
      HIDWORD(v32) = v34;
      LODWORD(v32) = v34;
      int v37 = (v32 >> 6) ^ __ROR4__(v34, 11);
      unint64_t v38 = __PAIR64__(v35, __ROR4__(v34, 25));
      int v39 = v15 + v36 + (v21 & ~v34) + (v34 & v28) + 961987163 + (v37 ^ v38);
      LODWORD(v38) = v35;
      int v40 = v39 + v16;
      unsigned int v41 = ((v38 >> 2) ^ __ROR4__(v35, 13) ^ __ROR4__(v35, 22)) + (v35 & (v29 ^ v22) ^ v29 & v22) + v39;
      unsigned int v42 = bswap32(a2[5]);
      v228[4] = v36;
      v228[5] = v42;
      HIDWORD(v38) = v40;
      LODWORD(v38) = v40;
      int v43 = (v38 >> 6) ^ __ROR4__(v40, 11);
      unint64_t v44 = __PAIR64__(v41, __ROR4__(v40, 25));
      int v45 = v21 + v42 + (v28 & ~v40) + (v40 & v34) + 1508970993 + (v43 ^ v44);
      LODWORD(v44) = v41;
      int v46 = v45 + v22;
      unsigned int v47 = ((v44 >> 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v35 ^ v29) ^ v35 & v29) + v45;
      unsigned int v48 = bswap32(a2[6]);
      int v49 = v48 + v28 + (v34 & ~v46) + (v46 & v40);
      HIDWORD(v44) = v46;
      LODWORD(v44) = v46;
      int v50 = (v44 >> 6) ^ __ROR4__(v46, 11);
      unint64_t v51 = __PAIR64__(v47, __ROR4__(v46, 25));
      int v52 = v49 - 1841331548 + (v50 ^ v51);
      LODWORD(v51) = v47;
      int v53 = v52 + v29;
      unsigned int v54 = ((v51 >> 2) ^ __ROR4__(v47, 13) ^ __ROR4__(v47, 22)) + (v47 & (v41 ^ v35) ^ v41 & v35) + v52;
      unsigned int v55 = bswap32(a2[7]);
      HIDWORD(v51) = v53;
      LODWORD(v51) = v53;
      v228[6] = v48;
      v228[7] = v55;
      int v56 = (v51 >> 6) ^ __ROR4__(v53, 11);
      unint64_t v57 = __PAIR64__(v54, __ROR4__(v53, 25));
      int v58 = v55 + v34 + (v40 & ~v53) + (v53 & v46) - 1424204075 + (v56 ^ v57);
      LODWORD(v57) = v54;
      int v59 = v58 + v35;
      unsigned int v60 = ((v57 >> 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + (v54 & (v47 ^ v41) ^ v47 & v41) + v58;
      HIDWORD(v57) = v59;
      LODWORD(v57) = v59;
      unsigned int v61 = bswap32(a2[8]);
      int v62 = (v57 >> 6) ^ __ROR4__(v59, 11);
      unint64_t v63 = __PAIR64__(v60, __ROR4__(v59, 25));
      int v64 = v61 + v40 + (v46 & ~v59) + (v59 & v53) - 670586216 + (v62 ^ v63);
      LODWORD(v63) = v60;
      int v65 = v64 + v41;
      unsigned int v66 = ((v63 >> 2) ^ __ROR4__(v60, 13) ^ __ROR4__(v60, 22)) + (v60 & (v54 ^ v47) ^ v54 & v47) + v64;
      unsigned int v67 = bswap32(a2[9]);
      v228[8] = v61;
      v228[9] = v67;
      HIDWORD(v63) = v65;
      LODWORD(v63) = v65;
      int v68 = (v63 >> 6) ^ __ROR4__(v65, 11);
      unint64_t v69 = __PAIR64__(v66, __ROR4__(v65, 25));
      int v70 = v67 + v46 + (v53 & ~v65) + (v65 & v59) + 310598401 + (v68 ^ v69);
      LODWORD(v69) = v66;
      int v71 = v70 + v47;
      unsigned int v72 = ((v69 >> 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + (v66 & (v60 ^ v54) ^ v60 & v54) + v70;
      unsigned int v73 = bswap32(a2[10]);
      int v74 = v73 + v53 + (v59 & ~v71) + (v71 & v65);
      HIDWORD(v69) = v71;
      LODWORD(v69) = v71;
      int v75 = (v69 >> 6) ^ __ROR4__(v71, 11);
      unint64_t v76 = __PAIR64__(v72, __ROR4__(v71, 25));
      int v77 = v74 + 607225278 + (v75 ^ v76);
      LODWORD(v76) = v72;
      int v78 = v77 + v54;
      unsigned int v79 = ((v76 >> 2) ^ __ROR4__(v72, 13) ^ __ROR4__(v72, 22)) + (v72 & (v66 ^ v60) ^ v66 & v60) + v77;
      unsigned int v80 = bswap32(a2[11]);
      v228[10] = v73;
      v228[11] = v80;
      HIDWORD(v76) = v78;
      LODWORD(v76) = v78;
      int v81 = (v76 >> 6) ^ __ROR4__(v78, 11);
      unint64_t v82 = __PAIR64__(v79, __ROR4__(v78, 25));
      int v83 = v80 + v59 + (v65 & ~v78) + (v78 & v71) + 1426881987 + (v81 ^ v82);
      LODWORD(v82) = v79;
      int v84 = v83 + v60;
      unsigned int v85 = ((v82 >> 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v72 ^ v66) ^ v72 & v66) + v83;
      unsigned int v86 = bswap32(a2[12]);
      HIDWORD(v82) = v84;
      LODWORD(v82) = v84;
      int v87 = (v82 >> 6) ^ __ROR4__(v84, 11);
      unint64_t v88 = __PAIR64__(v85, __ROR4__(v84, 25));
      int v89 = v86 + v65 + (v71 & ~v84) + (v84 & v78) + 1925078388 + (v87 ^ v88);
      LODWORD(v88) = v85;
      unsigned int v90 = v89 + v66;
      unsigned int v91 = ((v88 >> 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v79 ^ v72) ^ v79 & v72) + v89;
      unsigned int v92 = bswap32(a2[13]);
      HIDWORD(v88) = v90;
      LODWORD(v88) = v90;
      v228[12] = v86;
      v228[13] = v92;
      int v93 = (v88 >> 6) ^ __ROR4__(v90, 11);
      unint64_t v94 = __PAIR64__(v91, __ROR4__(v90, 25));
      int v95 = v92 + v71 + (v78 & ~v90) + (v90 & v84) - 2132889090 + (v93 ^ v94);
      LODWORD(v94) = v91;
      unsigned int v96 = v95 + v72;
      unsigned int v97 = ((v94 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v85 ^ v79) ^ v85 & v79) + v95;
      HIDWORD(v94) = v96;
      LODWORD(v94) = v95 + v72;
      int v226 = a2;
      unsigned int v98 = bswap32(a2[14]);
      int v99 = (v94 >> 6) ^ __ROR4__(v96, 11);
      unint64_t v100 = __PAIR64__(v97, __ROR4__(v96, 25));
      int v101 = v98 + v78 + (v84 & ~v96) + (v96 & v90) - 1680079193 + (v99 ^ v100);
      LODWORD(v100) = v97;
      unsigned int v102 = v101 + v79;
      unsigned int v103 = ((v100 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v85) ^ v91 & v85) + v101;
      unsigned int v104 = bswap32(a2[15]);
      v228[14] = v98;
      v228[15] = v104;
      HIDWORD(v100) = v102;
      LODWORD(v100) = v102;
      int v105 = (v100 >> 6) ^ __ROR4__(v102, 11);
      unint64_t v106 = __PAIR64__(v103, __ROR4__(v102, 25));
      int v107 = v104 + v84 + (v90 & ~v102) + (v102 & v96) - 1046744716 + (v105 ^ v106);
      LODWORD(v106) = v103;
      unsigned int v108 = v107 + v85;
      unsigned int v109 = ((v106 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v107;
      int v110 = &dword_244EBA5A4;
      uint64_t v111 = 31;
      do
      {
        unint64_t v112 = v111 - 15;
        uint64_t v113 = ((int)v111 - 14) & 9;
        unsigned int v114 = v228[v113];
        unsigned int v115 = v228[((_BYTE)v111 - 1) & 0xE];
        HIDWORD(v117) = v114;
        LODWORD(v117) = v114;
        int v116 = v117 >> 7;
        unint64_t v119 = __PAIR64__(v115, __ROR4__(v114, 18));
        int v118 = v116 ^ v119;
        LODWORD(v119) = v115;
        int v120 = v119 >> 17;
        unint64_t v121 = __PAIR64__(v108, __ROR4__(v115, 19));
        uint64_t v122 = (v111 - 15) & 8;
        int v123 = v120 ^ v121 ^ (v115 >> 10);
        LODWORD(v121) = v108;
        int v124 = (v111 - 15) & 8;
        unsigned int v125 = (v118 ^ (v114 >> 3)) + v228[((int)v111 - 6) & 9] + v228[v122] + v123;
        int v126 = (v121 >> 6) ^ __ROR4__(v108, 11);
        unint64_t v128 = __PAIR64__(v109, __ROR4__(v108, 25));
        int v127 = v126 ^ v128;
        LODWORD(v128) = v109;
        int v129 = *(v110 - 6);
        int v130 = (v108 & v102) + v90 + (v96 & ~v108) + *(v110 - 7) + v127;
        v228[v122] = v125;
        LODWORD(v122) = ((v128 >> 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + ((v103 ^ v97) & v109 ^ v103 & v97);
        int v131 = v130 + v125;
        unsigned int v132 = v131 + v91;
        HIDWORD(v128) = v228[v124 | 2];
        LODWORD(v128) = HIDWORD(v128);
        unsigned int v133 = v122 + v131;
        unsigned int v134 = v228[v111 & 0xF];
        int v135 = (v128 >> 7) ^ __ROR4__(HIDWORD(v128), 18) ^ (HIDWORD(v128) >> 3);
        HIDWORD(v128) = v134;
        LODWORD(v128) = v134;
        int v136 = v128 >> 17;
        unint64_t v137 = __PAIR64__(v132, __ROR4__(v134, 19));
        int v138 = v228[((int)v111 - 5) & 0xALL] + v114 + (v136 ^ v137 ^ (v134 >> 10));
        LODWORD(v137) = v132;
        int v139 = v138 + v135;
        int v140 = (v137 >> 6) ^ __ROR4__(v132, 11);
        unint64_t v142 = __PAIR64__(v133, __ROR4__(v132, 25));
        int v141 = v140 ^ v142;
        LODWORD(v142) = v133;
        v228[v113] = v139;
        LODWORD(v113) = (v142 >> 2) ^ __ROR4__(v133, 13);
        unint64_t v143 = __PAIR64__(v125, __ROR4__(v133, 22));
        int v144 = (v102 & ~v132) + v96 + (v132 & v108) + v129 + v139 + v141;
        int v145 = (v113 ^ v143) + (v133 & (v109 ^ v103) ^ v109 & v103);
        unsigned int v146 = v144 + v97;
        unsigned int v147 = v228[v124 | 3];
        LODWORD(v143) = v125;
        int v148 = v143 >> 17;
        HIDWORD(v143) = v147;
        LODWORD(v143) = v147;
        LODWORD(v122) = (v143 >> 7) ^ __ROR4__(v147, 18);
        unint64_t v149 = __PAIR64__(v146, __ROR4__(v125, 19));
        int v150 = v148 ^ v149 ^ (v125 >> 10);
        uint64_t v151 = ((int)v111 - 13) & 0xALL;
        unsigned int v152 = v145 + v144;
        int v153 = v228[((int)v111 - 4) & 0xBLL] + v228[v151] + (v122 ^ (v147 >> 3)) + v150;
        LODWORD(v149) = v146;
        int v154 = (v149 >> 6) ^ __ROR4__(v146, 11);
        unint64_t v156 = __PAIR64__(v152, __ROR4__(v146, 25));
        int v155 = v154 ^ v156;
        v228[v151] = v153;
        LODWORD(v151) = *(v110 - 4);
        int v157 = *(v110 - 5) + v102 + v153;
        LODWORD(v156) = v152;
        int v158 = ((v156 >> 2) ^ __ROR4__(v152, 13) ^ __ROR4__(v152, 22)) + (v152 & (v133 ^ v109) ^ v133 & v109);
        unsigned int v159 = v228[v124 | 4];
        int v160 = v157 + (v108 & ~v146) + (v146 & v132) + v155;
        HIDWORD(v156) = v159;
        LODWORD(v156) = v159;
        int v161 = v156 >> 7;
        LODWORD(v122) = v228[v124 | 1];
        unint64_t v163 = __PAIR64__(v122, __ROR4__(v159, 18));
        int v162 = v161 ^ v163;
        LODWORD(v163) = v122;
        int v164 = v162 ^ (v159 >> 3);
        uint64_t v165 = ((int)v111 - 12) & 0xBLL;
        int v166 = v160 + v103;
        int v167 = v164
             + v228[((_BYTE)v111 - 3) & 0xC]
             + v228[v165]
             + ((v163 >> 17) ^ __ROR4__(v122, 19) ^ (v122 >> 10));
        unsigned int v168 = v158 + v160;
        HIDWORD(v163) = v166;
        LODWORD(v163) = v166;
        int v169 = (v163 >> 6) ^ __ROR4__(v166, 11);
        unint64_t v171 = __PAIR64__(v168, __ROR4__(v166, 25));
        int v170 = v169 ^ v171;
        v228[v165] = v167;
        LODWORD(v171) = v168;
        int v172 = v151 + v108 + v167 + (v132 & ~v166) + (v166 & v146) + v170;
        int v173 = ((v171 >> 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + (v168 & (v152 ^ v133) ^ v152 & v133);
        unsigned int v174 = v172 + v109;
        unsigned int v175 = v228[v124 | 5];
        HIDWORD(v171) = v175;
        LODWORD(v171) = v175;
        int v176 = (v171 >> 7) ^ __ROR4__(v175, 18);
        unsigned int v177 = v228[v124 | 2];
        HIDWORD(v171) = v177;
        LODWORD(v171) = v177;
        LODWORD(v165) = v171 >> 17;
        unint64_t v178 = __PAIR64__(v174, __ROR4__(v177, 19));
        uint64_t v179 = ((_BYTE)v111 - 11) & 0xC;
        int v180 = (v176 ^ (v175 >> 3)) + v228[((int)v111 - 2) & 0xDLL] + v228[v179] + (v165 ^ v178 ^ (v177 >> 10));
        unsigned int v181 = v173 + v172;
        LODWORD(v178) = v174;
        int v182 = (v178 >> 6) ^ __ROR4__(v174, 11);
        unint64_t v184 = __PAIR64__(v181, __ROR4__(v174, 25));
        int v183 = v182 ^ v184;
        v228[v179] = v180;
        LODWORD(v165) = *(v110 - 2);
        LODWORD(v184) = v181;
        LODWORD(v151) = ((v184 >> 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v168 ^ v152) ^ v168 & v152);
        int v185 = *(v110 - 3) + v180 + v132 + (v146 & ~v174) + (v174 & v166) + v183;
        unsigned int v90 = v185 + v133;
        unsigned int v186 = v228[v124 | 6];
        HIDWORD(v184) = v186;
        LODWORD(v184) = v186;
        int v187 = v184 >> 7;
        LODWORD(v113) = v228[v124 | 3];
        HIDWORD(v184) = v113;
        LODWORD(v184) = v113;
        int v188 = v184 >> 17;
        int v189 = v187 ^ __ROR4__(v186, 18) ^ (v186 >> 3);
        unint64_t v191 = __PAIR64__(v90, __ROR4__(v113, 19));
        int v190 = v188 ^ v191;
        uint64_t v192 = ((int)v111 - 10) & 0xDLL;
        unsigned int v91 = v151 + v185;
        unsigned int v193 = v228[v192] + v115 + v189 + (v190 ^ (v113 >> 10));
        LODWORD(v191) = v90;
        int v194 = (v191 >> 6) ^ __ROR4__(v90, 11);
        unint64_t v196 = __PAIR64__(v91, __ROR4__(v90, 25));
        int v195 = v194 ^ v196;
        v228[v192] = v193;
        LODWORD(v196) = v91;
        int v197 = v165 + v193 + v146 + (v166 & ~v90) + (v90 & v174) + v195;
        int v198 = ((v196 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v181 ^ v168) ^ v181 & v168);
        LODWORD(v179) = v228[v124 | 7];
        unsigned int v96 = v197 + v152;
        HIDWORD(v196) = v179;
        LODWORD(v196) = v179;
        LODWORD(v113) = v196 >> 7;
        unsigned int v199 = v228[v124 | 4];
        unint64_t v200 = __PAIR64__(v199, __ROR4__(v179, 18));
        LODWORD(v179) = v113 ^ v200 ^ (v179 >> 3);
        LODWORD(v200) = v199;
        LODWORD(v113) = v200 >> 17;
        unint64_t v201 = __PAIR64__(v96, __ROR4__(v199, 19));
        uint64_t v202 = ((_BYTE)v111 - 9) & 0xE;
        LODWORD(v179) = v228[v202] + v134 + v179 + (v113 ^ v201 ^ (v199 >> 10));
        unsigned int v97 = v198 + v197;
        LODWORD(v201) = v96;
        int v203 = (v201 >> 6) ^ __ROR4__(v96, 11);
        unint64_t v205 = __PAIR64__(v97, __ROR4__(v96, 25));
        int v204 = v203 ^ v205;
        v228[v202] = v179;
        LODWORD(v205) = v97;
        int v206 = *(v110 - 1) + v179 + v166 + (v174 & ~v96) + (v96 & v90) + v204;
        unsigned int v102 = v206 + v168;
        unsigned int v103 = ((v205 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v181) ^ v91 & v181) + v206;
        unsigned int v207 = v228[v124 ^ 8];
        HIDWORD(v205) = v207;
        LODWORD(v205) = v207;
        LODWORD(v179) = v205 >> 7;
        unsigned int v208 = v228[v124 | 5];
        HIDWORD(v205) = v208;
        LODWORD(v205) = v208;
        LODWORD(v113) = v205 >> 17;
        int v209 = v179 ^ __ROR4__(v207, 18) ^ (v207 >> 3);
        unint64_t v210 = __PAIR64__(v102, __ROR4__(v208, 19));
        uint64_t v211 = ((_BYTE)v111 - 8) & 0xF;
        LODWORD(v179) = v113 ^ v210 ^ (v208 >> 10);
        LODWORD(v210) = v102;
        int v212 = (v210 >> 6) ^ __ROR4__(v102, 11);
        int v213 = v228[v211] + v209 + v125 + v179;
        unint64_t v214 = __PAIR64__(v103, __ROR4__(v102, 25));
        LODWORD(v179) = v212 ^ v214;
        int v215 = *v110;
        v110 += 8;
        v228[v211] = v213;
        LODWORD(v214) = v103;
        int v216 = v215 + v213 + v174 + (v90 & ~v102) + (v102 & v96) + v179;
        unsigned int v108 = v216 + v181;
        unsigned int v109 = ((v214 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v216;
        v111 += 8;
      }
      while (v112 < 0x38);
      a2 = v226 + 16;
      unsigned int v3 = v109 + v225;
      int v4 = v103 + v224;
      *unint64_t v217 = v109 + v225;
      v217[1] = v103 + v224;
      int v6 = v97 + v223;
      int v5 = v91 + v222;
      v217[2] = v97 + v223;
      v217[3] = v91 + v222;
      int v8 = v108 + v221;
      int v7 = v102 + v220;
      v217[4] = v108 + v221;
      v217[5] = v102 + v220;
      int v9 = v96 + v219;
      uint64_t result = v90 + v218;
      v217[6] = v96 + v219;
      v217[7] = result;
      a3 = v227 - 1;
    }
    while (v227 != 1);
  }
  return result;
}

uint64_t sub_244D39114(_DWORD *a1, unint64_t a2, uint64_t a3)
{
  unsigned int v3 = (int32x2_t *)a3;
  uint64_t v6 = a3 + 40;
  int8x8_t v7 = *(int8x8_t *)(a3 + 32);
  uint64_t v8 = *(unsigned int *)(a3 + 104);
  *(unsigned char *)(a3 + 40 + v8) = 0x80;
  uint64_t v9 = v8 + 1;
  if (v8 < 0x38)
  {
    if (v8 == 55) {
      goto LABEL_7;
    }
  }
  else
  {
    if (v8 != 63) {
      bzero((void *)(v6 + v9), 63 - v8);
    }
    sub_244D384F4((unint64_t)v3, (unsigned int *)v6, 1);
    uint64_t v9 = 0;
  }
  bzero((void *)(v6 + v9), 56 - v9);
LABEL_7:
  v3[12] = vrev64_s32((int32x2_t)vrev32_s8(v7));
  sub_244D384F4((unint64_t)v3, (unsigned int *)v6, 1);
  uint64_t result = 0;
  v3[13].i32[0] = 0;
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  if (a2 <= 0x20)
  {
    if (a2 >= 4)
    {
      unint64_t v11 = a2 >> 2;
      do
      {
        unsigned int v12 = v3->i32[0];
        unsigned int v3 = (int32x2_t *)((char *)v3 + 4);
        *a1++ = bswap32(v12);
        --v11;
      }
      while (v11);
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D39214(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_244EB6E50;
  *(_OWORD *)(a1 + 16) = xmmword_244EB6E60;
  *(_OWORD *)(a1 + 32) = xmmword_244EB6E70;
  *(_OWORD *)(a1 + 48) = xmmword_244EB6E80;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 208) = 0x3000000000;
  return 1;
}

uint64_t sub_244D39254(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_244EB6EE0;
  *(_OWORD *)(a1 + 16) = xmmword_244EB6EF0;
  *(_OWORD *)(a1 + 32) = xmmword_244EB6F00;
  *(_OWORD *)(a1 + 48) = xmmword_244EB6F10;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 208) = 0x2000000000;
  return 1;
}

uint64_t sub_244D39294(unint64_t a1, unint64_t *a2, size_t a3)
{
  return 1;
}

uint64_t sub_244D392B0(void *a1, int8x16_t *a2)
{
  return sub_244D39398(a1, 0x30uLL, a2);
}

void *sub_244D392BC(unint64_t *__src, size_t __n, void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  v5[0] = (int8x16_t)xmmword_244EB6EE0;
  v5[1] = (int8x16_t)xmmword_244EB6EF0;
  _OWORD v5[2] = (int8x16_t)xmmword_244EB6F00;
  _OWORD v5[3] = (int8x16_t)xmmword_244EB6F10;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v16 = 0x2000000000;
  sub_244D277D8((unint64_t)v5, __src, __n);
  sub_244D39398(a3, 0x20uLL, v5);
  sub_244D4413C(v5, 0xD8uLL);
  return a3;
}

uint64_t sub_244D3938C(void *a1, int8x16_t *a2)
{
  return sub_244D39398(a1, 0x20uLL, a2);
}

uint64_t sub_244D39398(void *a1, unint64_t a2, int8x16_t *a3)
{
  unsigned int v3 = a3;
  uint64_t v6 = (unint64_t *)&a3[5];
  uint64_t v7 = a3[13].u32[0];
  a3[5].i8[v7] = 0x80;
  uint64_t v8 = v7 + 1;
  if (v7 < 0x70)
  {
    if (v7 == 111) {
      goto LABEL_7;
    }
  }
  else
  {
    if (v7 != 127) {
      bzero((char *)v6 + v8, 127 - v7);
    }
    sub_244D39484((unint64_t)v3, v6, 1);
    uint64_t v8 = 0;
  }
  bzero((char *)v6 + v8, 112 - v8);
LABEL_7:
  int8x16_t v9 = vrev64q_s8(v3[4]);
  v3[12] = vextq_s8(v9, v9, 8uLL);
  sub_244D39484((unint64_t)v3, v6, 1);
  if (!a1) {
    return 0;
  }
  if (a2 >= 8)
  {
    unint64_t v10 = a2 >> 3;
    do
    {
      unint64_t v11 = v3->i64[0];
      unsigned int v3 = (int8x16_t *)((char *)v3 + 8);
      *a1++ = bswap64(v11);
      --v10;
    }
    while (v10);
  }
  return 1;
}

unint64_t sub_244D3947C(unint64_t a1, unint64_t *a2)
{
  return sub_244D39484(a1, a2, 1);
}

unint64_t sub_244D39484(unint64_t result, unint64_t *a2, uint64_t a3)
{
  int v123 = (void *)result;
  if (a3)
  {
    uint64_t v4 = *(void *)result;
    uint64_t v3 = *(void *)(result + 8);
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v5 = *(void *)(result + 24);
    uint64_t v8 = *(void *)(result + 32);
    unint64_t v7 = *(void *)(result + 40);
    uint64_t v10 = *(void *)(result + 48);
    uint64_t v9 = *(void *)(result + 56);
    do
    {
      uint64_t v132 = a3;
      unint64_t v138 = 0;
      unint64_t v139 = bswap64(*a2);
      uint64_t v124 = v9;
      uint64_t v11 = v9
          + (v8 & v7)
          + (v10 & ~v8)
          + v139
          + (__ROR8__(v8, 14) ^ __ROR8__(v8, 18) ^ __ROR8__(v8, 41))
          + 0x428A2F98D728AE22;
      uint64_t v128 = v5;
      uint64_t v12 = v11 + v5;
      uint64_t v13 = (__ROR8__(v4, 28) ^ __ROR8__(v4, 34) ^ __ROR8__(v4, 39)) + ((v3 ^ v6) & v4 ^ v3 & v6) + v11;
      unint64_t v14 = bswap64(a2[1]);
      uint64_t v125 = v10;
      uint64_t v15 = v10
          + v14
          + (v7 & ~v12)
          + (v12 & v8)
          + 0x7137449123EF65CDLL
          + (__ROR8__(v12, 14) ^ __ROR8__(v12, 18) ^ __ROR8__(v12, 41));
      uint64_t v129 = v6;
      uint64_t v16 = v15 + v6;
      uint64_t v17 = (__ROR8__(v13, 28) ^ __ROR8__(v13, 34) ^ __ROR8__(v13, 39)) + (v13 & (v4 ^ v3) ^ v4 & v3) + v15;
      unint64_t v18 = bswap64(a2[2]);
      unint64_t v126 = v7;
      uint64_t v19 = v7
          + v18
          + (v8 & ~v16)
          + (v16 & v12)
          - 0x4A3F043013B2C4D1
          + (__ROR8__(v15 + v6, 14) ^ __ROR8__(v15 + v6, 18) ^ __ROR8__(v16, 41));
      uint64_t v130 = v3;
      uint64_t v20 = v19 + v3;
      uint64_t v21 = (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + (v17 & (v13 ^ v4) ^ v13 & v4) + v19;
      unint64_t v22 = bswap64(a2[3]);
      uint64_t v127 = v8;
      uint64_t v23 = v8
          + v22
          + (v12 & ~v20)
          + (v20 & v16)
          - 0x164A245A7E762444
          + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41));
      uint64_t v131 = v4;
      uint64_t v24 = v23 + v4;
      uint64_t v25 = (__ROR8__(v21, 28) ^ __ROR8__(v21, 34) ^ __ROR8__(v21, 39)) + (v21 & (v17 ^ v13) ^ v17 & v13) + v23;
      unint64_t v26 = bswap64(a2[4]);
      uint64_t v27 = v12
          + v26
          + (v16 & ~v24)
          + (v24 & v20)
          + 0x3956C25BF348B538
          + (__ROR8__(v24, 14) ^ __ROR8__(v24, 18) ^ __ROR8__(v24, 41));
      uint64_t v28 = v27 + v13;
      uint64_t v29 = (__ROR8__(v25, 28) ^ __ROR8__(v25, 34) ^ __ROR8__(v25, 39)) + (v25 & (v21 ^ v17) ^ v21 & v17) + v27;
      unint64_t v30 = bswap64(a2[5]);
      uint64_t v31 = v30
          + v16
          + (v20 & ~v28)
          + (v28 & v24)
          + 0x59F111F1B605D019
          + (__ROR8__(v28, 14) ^ __ROR8__(v28, 18) ^ __ROR8__(v28, 41));
      uint64_t v32 = v31 + v17;
      uint64_t v33 = (__ROR8__(v29, 28) ^ __ROR8__(v29, 34) ^ __ROR8__(v29, 39)) + (v29 & (v25 ^ v21) ^ v25 & v21) + v31;
      unint64_t v34 = bswap64(a2[6]);
      uint64_t v35 = v34
          + v20
          + (v24 & ~v32)
          + (v32 & v28)
          - 0x6DC07D5B50E6B065
          + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41));
      uint64_t v36 = v35 + v21;
      uint64_t v37 = (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & (v29 ^ v25) ^ v29 & v25) + v35;
      unint64_t v137 = bswap64(a2[7]);
      uint64_t v38 = v137
          + v24
          + (v28 & ~v36)
          + (v36 & v32)
          - 0x54E3A12A25927EE8
          + (__ROR8__(v36, 14) ^ __ROR8__(v36, 18) ^ __ROR8__(v36, 41));
      uint64_t v39 = v38 + v25;
      uint64_t v40 = (__ROR8__(v37, 28) ^ __ROR8__(v37, 34) ^ __ROR8__(v37, 39)) + (v37 & (v33 ^ v29) ^ v33 & v29) + v38;
      unint64_t v136 = bswap64(a2[8]);
      uint64_t v41 = v136
          + v28
          + (v32 & ~v39)
          + (v39 & v36)
          - 0x27F855675CFCFDBELL
          + (__ROR8__(v39, 14) ^ __ROR8__(v39, 18) ^ __ROR8__(v39, 41));
      uint64_t v42 = v41 + v29;
      uint64_t v43 = (__ROR8__(v40, 28) ^ __ROR8__(v40, 34) ^ __ROR8__(v40, 39)) + (v40 & (v37 ^ v33) ^ v37 & v33) + v41;
      unint64_t v135 = bswap64(a2[9]);
      uint64_t v44 = v135
          + v32
          + (v36 & ~v42)
          + (v42 & v39)
          + 0x12835B0145706FBELL
          + (__ROR8__(v42, 14) ^ __ROR8__(v42, 18) ^ __ROR8__(v42, 41));
      uint64_t v45 = v44 + v33;
      uint64_t v46 = (__ROR8__(v43, 28) ^ __ROR8__(v43, 34) ^ __ROR8__(v43, 39)) + (v43 & (v40 ^ v37) ^ v40 & v37) + v44;
      unint64_t v134 = bswap64(a2[10]);
      uint64_t v47 = v134
          + v36
          + (v39 & ~v45)
          + (v45 & v42)
          + 0x243185BE4EE4B28CLL
          + (__ROR8__(v45, 14) ^ __ROR8__(v45, 18) ^ __ROR8__(v45, 41));
      uint64_t v48 = v47 + v37;
      uint64_t v49 = (__ROR8__(v46, 28) ^ __ROR8__(v46, 34) ^ __ROR8__(v46, 39)) + (v46 & (v43 ^ v40) ^ v43 & v40) + v47;
      unint64_t v50 = bswap64(a2[11]);
      uint64_t v51 = v50
          + v39
          + (v42 & ~v48)
          + (v48 & v45)
          + 0x550C7DC3D5FFB4E2
          + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41));
      uint64_t v52 = v51 + v40;
      uint64_t v53 = (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + (v49 & (v46 ^ v43) ^ v46 & v43) + v51;
      unint64_t v54 = bswap64(a2[12]);
      uint64_t v55 = v54
          + v42
          + (v45 & ~v52)
          + (v52 & v48)
          + 0x72BE5D74F27B896FLL
          + (__ROR8__(v52, 14) ^ __ROR8__(v52, 18) ^ __ROR8__(v52, 41));
      uint64_t v56 = v55 + v43;
      uint64_t v57 = (__ROR8__(v53, 28) ^ __ROR8__(v53, 34) ^ __ROR8__(v53, 39)) + (v53 & (v49 ^ v46) ^ v49 & v46) + v55;
      unint64_t v58 = bswap64(a2[13]);
      uint64_t v59 = v58
          + v45
          + (v48 & ~v56)
          + (v56 & v52)
          - 0x7F214E01C4E9694FLL
          + (__ROR8__(v55 + v43, 14) ^ __ROR8__(v55 + v43, 18) ^ __ROR8__(v56, 41));
      uint64_t v60 = v59 + v46;
      uint64_t v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v53 ^ v49) ^ v53 & v49) + v59;
      unint64_t v62 = bswap64(a2[14]);
      uint64_t v63 = v62
          + v48
          + (v52 & ~v60)
          + (v60 & v56)
          - 0x6423F958DA38EDCBLL
          + (__ROR8__(v59 + v46, 14) ^ __ROR8__(v59 + v46, 18) ^ __ROR8__(v60, 41));
      uint64_t result = v63 + v49;
      uint64_t v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v53) ^ v57 & v53) + v63;
      unint64_t v65 = bswap64(a2[15]);
      uint64_t v66 = v65
          + v52
          + (v56 & ~result)
          + (result & v60)
          - 0x3E640E8B3096D96CLL
          + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
      unint64_t v67 = v139;
      uint64_t v68 = v66 + v53;
      uint64_t v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v66;
      int v70 = &qword_244EBA740;
      do
      {
        unint64_t v133 = v50;
        unint64_t v71 = (__ROR8__(v14, 1) ^ __ROR8__(v14, 8) ^ (v14 >> 7))
            + v67
            + v135
            + (__ROR8__(v62, 19) ^ __ROR8__(v62, 61) ^ (v62 >> 6));
        unint64_t v72 = (v68 & result)
            + v56
            + (v60 & ~v68)
            + (__ROR8__(v68, 14) ^ __ROR8__(v68, 18) ^ __ROR8__(v68, 41))
            + *(v70 - 15)
            + v71;
        unint64_t v73 = v72 + v57;
        unint64_t v74 = (__ROR8__(v69, 28) ^ __ROR8__(v69, 34) ^ __ROR8__(v69, 39)) + ((v64 ^ v61) & v69 ^ v64 & v61) + v72;
        unint64_t v75 = v54;
        unint64_t v76 = (__ROR8__(v18, 1) ^ __ROR8__(v18, 8) ^ (v18 >> 7))
            + v14
            + v134
            + (__ROR8__(v65, 19) ^ __ROR8__(v65, 61) ^ (v65 >> 6));
        unint64_t v77 = v76
            + v60
            + *(v70 - 14)
            + (result & ~v73)
            + (v73 & v68)
            + (__ROR8__(v73, 14) ^ __ROR8__(v73, 18) ^ __ROR8__(v73, 41));
        unint64_t v78 = v77 + v61;
        unint64_t v79 = (__ROR8__(v74, 28) ^ __ROR8__(v74, 34) ^ __ROR8__(v74, 39)) + (v74 & (v69 ^ v64) ^ v69 & v64) + v77;
        unint64_t v140 = v71;
        unint64_t v80 = (__ROR8__(v22, 1) ^ __ROR8__(v22, 8) ^ (v22 >> 7))
            + v18
            + v50
            + (__ROR8__(v71, 19) ^ __ROR8__(v71, 61) ^ (v71 >> 6));
        int v81 = (char *)(v80
                     + result
                     + *(v70 - 13)
                     + (v68 & ~v78)
                     + (v78 & v73)
                     + (__ROR8__(v77 + v61, 14) ^ __ROR8__(v77 + v61, 18) ^ __ROR8__(v78, 41)));
        unint64_t v82 = &v81[v64];
        int v83 = &v81[(__ROR8__(v79, 28) ^ __ROR8__(v79, 34) ^ __ROR8__(v79, 39)) + (v79 & (v74 ^ v69) ^ v74 & v69)];
        unint64_t v84 = (__ROR8__(v26, 1) ^ __ROR8__(v26, 8) ^ (v26 >> 7))
            + v22
            + v54
            + (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6));
        uint64_t v85 = v84
            + v68
            + *(v70 - 12)
            + (v73 & ~(unint64_t)v82)
            + ((unint64_t)v82 & v78)
            + (__ROR8__(&v81[v64], 14) ^ __ROR8__(&v81[v64], 18) ^ __ROR8__(&v81[v64], 41));
        uint64_t v86 = v85 + v69;
        uint64_t v87 = (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39))
            + ((unint64_t)v83 & (v79 ^ v74) ^ v79 & v74)
            + v85;
        v26 += (__ROR8__(v30, 1) ^ __ROR8__(v30, 8) ^ (v30 >> 7))
             + v58
             + (__ROR8__(v80, 19) ^ __ROR8__(v80, 61) ^ (v80 >> 6));
        unint64_t v88 = v73
            + *(v70 - 11)
            + v26
            + (v78 & ~v86)
            + (v86 & (unint64_t)v82)
            + (__ROR8__(v85 + v69, 14) ^ __ROR8__(v85 + v69, 18) ^ __ROR8__(v86, 41));
        unint64_t v89 = v88 + v74;
        unint64_t v90 = (__ROR8__(v87, 28) ^ __ROR8__(v87, 34) ^ __ROR8__(v87, 39))
            + (v87 & ((unint64_t)v83 ^ v79) ^ (unint64_t)v83 & v79)
            + v88;
        v30 += (__ROR8__(v34, 1) ^ __ROR8__(v34, 8) ^ (v34 >> 7))
             + v62
             + (__ROR8__(v84, 19) ^ __ROR8__(v84, 61) ^ (v84 >> 6));
        unint64_t v91 = *(v70 - 10)
            + v78
            + v30
            + ((unint64_t)v82 & ~v89)
            + (v89 & v86)
            + (__ROR8__(v89, 14) ^ __ROR8__(v89, 18) ^ __ROR8__(v89, 41));
        unint64_t v92 = v91 + v79;
        unint64_t v93 = (__ROR8__(v90, 28) ^ __ROR8__(v90, 34) ^ __ROR8__(v90, 39))
            + (v90 & (v87 ^ (unint64_t)v83) ^ v87 & (unint64_t)v83)
            + v91;
        v34 += (__ROR8__(v137, 1) ^ __ROR8__(v137, 8) ^ (v137 >> 7))
             + v65
             + (__ROR8__(v26, 19) ^ __ROR8__(v26, 61) ^ (v26 >> 6));
        unint64_t v94 = (unint64_t)&v82[*(v70 - 9)
                                   + v34
                                   + (v86 & ~v92)
                                   + (v92 & v89)
                                   + (__ROR8__(v92, 14) ^ __ROR8__(v92, 18) ^ __ROR8__(v92, 41))];
        int v95 = &v83[v94];
        unint64_t v96 = (__ROR8__(v93, 28) ^ __ROR8__(v93, 34) ^ __ROR8__(v93, 39)) + (v93 & (v90 ^ v87) ^ v90 & v87) + v94;
        unint64_t v97 = (__ROR8__(v136, 1) ^ __ROR8__(v136, 8) ^ (v136 >> 7))
            + v137
            + v140
            + (__ROR8__(v30, 19) ^ __ROR8__(v30, 61) ^ (v30 >> 6));
        uint64_t v98 = v97
            + *(v70 - 8)
            + v86
            + (v89 & ~(unint64_t)v95)
            + ((unint64_t)v95 & v92)
            + (__ROR8__(&v83[v94], 14) ^ __ROR8__(&v83[v94], 18) ^ __ROR8__(v95, 41));
        uint64_t v99 = v98 + v87;
        uint64_t v100 = (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + (v96 & (v93 ^ v90) ^ v93 & v90) + v98;
        unint64_t v101 = (__ROR8__(v135, 1) ^ __ROR8__(v135, 8) ^ (v135 >> 7))
             + v136
             + v76
             + (__ROR8__(v34, 19) ^ __ROR8__(v34, 61) ^ (v34 >> 6));
        uint64_t v102 = v101
             + *(v70 - 7)
             + v89
             + (v92 & ~v99)
             + (v99 & (unint64_t)v95)
             + (__ROR8__(v99, 14) ^ __ROR8__(v99, 18) ^ __ROR8__(v99, 41));
        unint64_t v103 = v102 + v90;
        uint64_t v104 = (__ROR8__(v100, 28) ^ __ROR8__(v100, 34) ^ __ROR8__(v100, 39)) + (v100 & (v96 ^ v93) ^ v96 & v93) + v102;
        unint64_t v105 = (__ROR8__(v134, 1) ^ __ROR8__(v134, 8) ^ (v134 >> 7))
             + v135
             + v80
             + (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6));
        uint64_t v106 = v105
             + *(v70 - 6)
             + v92
             + ((unint64_t)v95 & ~v103)
             + (v103 & v99)
             + (__ROR8__(v103, 14) ^ __ROR8__(v103, 18) ^ __ROR8__(v103, 41));
        unint64_t v107 = v106 + v93;
        uint64_t v108 = (__ROR8__(v104, 28) ^ __ROR8__(v104, 34) ^ __ROR8__(v104, 39))
             + (v104 & (v100 ^ v96) ^ v100 & v96)
             + v106;
        unint64_t v109 = (__ROR8__(v133, 1) ^ __ROR8__(v133, 8) ^ (v133 >> 7))
             + v134
             + v84
             + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6));
        uint64_t v110 = (uint64_t)&v95[v109
                           + *(v70 - 5)
                           + (v99 & ~v107)
                           + (v107 & v103)
                           + (__ROR8__(v107, 14) ^ __ROR8__(v107, 18) ^ __ROR8__(v107, 41))];
        unint64_t v111 = v110 + v96;
        uint64_t v112 = (__ROR8__(v108, 28) ^ __ROR8__(v108, 34) ^ __ROR8__(v108, 39))
             + (v108 & (v104 ^ v100) ^ v104 & v100)
             + v110;
        unint64_t v135 = v105;
        unint64_t v50 = (__ROR8__(v75, 1) ^ __ROR8__(v75, 8) ^ (v75 >> 7))
            + v133
            + v26
            + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6));
        unint64_t v113 = v50
             + *(v70 - 4)
             + v99
             + (v103 & ~v111)
             + (v111 & v107)
             + (__ROR8__(v110 + v96, 14) ^ __ROR8__(v110 + v96, 18) ^ __ROR8__(v111, 41));
        unint64_t v114 = v113 + v100;
        unint64_t v115 = (__ROR8__(v112, 28) ^ __ROR8__(v112, 34) ^ __ROR8__(v112, 39))
             + (v112 & (v108 ^ v104) ^ v108 & v104)
             + v113;
        unint64_t v134 = v109;
        unint64_t v54 = (__ROR8__(v58, 1) ^ __ROR8__(v58, 8) ^ (v58 >> 7))
            + v75
            + v30
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
        unint64_t v116 = v54
             + *(v70 - 3)
             + v103
             + (v107 & ~v114)
             + (v114 & v111)
             + (__ROR8__(v114, 14) ^ __ROR8__(v114, 18) ^ __ROR8__(v114, 41));
        uint64_t v56 = v116 + v104;
        uint64_t v57 = (__ROR8__(v115, 28) ^ __ROR8__(v115, 34) ^ __ROR8__(v115, 39))
            + (v115 & (v112 ^ v108) ^ v112 & v108)
            + v116;
        v58 += (__ROR8__(v62, 1) ^ __ROR8__(v62, 8) ^ (v62 >> 7))
             + v34
             + (__ROR8__(v50, 19) ^ __ROR8__(v50, 61) ^ (v50 >> 6));
        unint64_t v117 = v58
             + *(v70 - 2)
             + v107
             + (v111 & ~v56)
             + (v56 & v114)
             + (__ROR8__(v116 + v104, 14) ^ __ROR8__(v116 + v104, 18) ^ __ROR8__(v56, 41));
        uint64_t v60 = v117 + v108;
        uint64_t v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v115 ^ v112) ^ v115 & v112) + v117;
        unint64_t v137 = v97;
        unint64_t v118 = (__ROR8__(v65, 1) ^ __ROR8__(v65, 8) ^ (v65 >> 7)) + v62 + v97;
        unint64_t v18 = v80;
        unint64_t v62 = v118 + (__ROR8__(v54, 19) ^ __ROR8__(v54, 61) ^ (v54 >> 6));
        unint64_t v67 = v140;
        unint64_t v119 = v62
             + *(v70 - 1)
             + v111
             + (v114 & ~v60)
             + (v60 & v56)
             + (__ROR8__(v60, 14) ^ __ROR8__(v60, 18) ^ __ROR8__(v60, 41));
        uint64_t result = v119 + v112;
        uint64_t v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v115) ^ v57 & v115) + v119;
        unint64_t v136 = v101;
        unint64_t v120 = (__ROR8__(v140, 1) ^ __ROR8__(v140, 8) ^ (v140 >> 7)) + v65 + v101;
        unint64_t v22 = v84;
        unint64_t v65 = v120 + (__ROR8__(v58, 19) ^ __ROR8__(v58, 61) ^ (v58 >> 6));
        uint64_t v121 = *v70;
        v70 += 16;
        unint64_t v122 = v65
             + v121
             + v114
             + (v56 & ~result)
             + (result & v60)
             + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
        uint64_t v68 = v122 + v115;
        uint64_t v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v122;
        unint64_t v14 = v76;
        v138 += 16;
      }
      while (v138 < 0x40);
      uint64_t v4 = v69 + v131;
      uint64_t v3 = v64 + v130;
      *int v123 = v69 + v131;
      v123[1] = v64 + v130;
      uint64_t v6 = v61 + v129;
      uint64_t v5 = v57 + v128;
      v123[2] = v61 + v129;
      v123[3] = v57 + v128;
      uint64_t v8 = v68 + v127;
      unint64_t v7 = result + v126;
      v123[4] = v68 + v127;
      v123[5] = result + v126;
      uint64_t v10 = v60 + v125;
      uint64_t v9 = v56 + v124;
      a2 += 16;
      v123[6] = v60 + v125;
      v123[7] = v56 + v124;
      a3 = v132 - 1;
    }
    while (v132 != 1);
  }
  return result;
}

uint64_t sub_244D3A3A4(uint64_t *a1, unsigned char *a2, size_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (!a3) {
    return 1;
  }
  bzero(a2, a3);
  sub_244D4BDB4(&stru_268EBD830, (void (*)(void))sub_244D25EB0);
  if (a1 == &qword_268EBF710)
  {
    sub_244D4BDB4(&stru_268EBD7C0, (void (*)(void))sub_244D25AC0);
    uint64_t result = sub_244D3A52C(a2, a3, (uint64_t)&qword_268EBF5C0, a4, a5 - (a5 >> 1), a6, a7, a8, a9, a10, a11);
    if (!result) {
      return result;
    }
    a4 += a5 >> 1;
    sub_244D4BDB4(&stru_268EBD7D0, (void (*)(void))sub_244D25B50);
    a5 -= a5 >> 1;
    a1 = &qword_268EBF5F0;
  }

  return sub_244D3A52C(a2, a3, (uint64_t)a1, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t sub_244D3A52C(unsigned char *a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  memset(v33, 0, sizeof(v33));
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  unsigned int v28 = 0;
  unint64_t v26 = *(unsigned int *)(a3 + 4);
  sub_244D2EAD0((uint64_t)v33);
  sub_244D2EAD0((uint64_t)v31);
  sub_244D2EAD0((uint64_t)v29);
  if (sub_244D2EAF4((uint64_t)v29, a4, a5, a3))
  {
    if (sub_244D2EF14(v33, v29))
    {
      (*(void (**)(void *, uint64_t, uint64_t))(v33[1] + 24))(&v33[1], a6, a7);
      (*(void (**)(void *, uint64_t, uint64_t))(v33[1] + 24))(&v33[1], a8, a9);
      (*(void (**)(void *, uint64_t, uint64_t))(v33[1] + 24))(&v33[1], a10, a11);
      if (sub_244D2ECF4((uint64_t)v33, (uint64_t)v35, &v28))
      {
        while (1)
        {
          unsigned int v27 = 0;
          if (!sub_244D2EF14(v33, v29)) {
            break;
          }
          (*(void (**)(void *, unsigned char *, void))(v33[1] + 24))(&v33[1], v35, v28);
          if (a2 > v26 && !sub_244D2EF14(v31, v33)) {
            break;
          }
          (*(void (**)(void *, uint64_t, uint64_t))(v33[1] + 24))(&v33[1], a6, a7);
          (*(void (**)(void *, uint64_t, uint64_t))(v33[1] + 24))(&v33[1], a8, a9);
          (*(void (**)(void *, uint64_t, uint64_t))(v33[1] + 24))(&v33[1], a10, a11);
          if (!sub_244D2ECF4((uint64_t)v33, (uint64_t)v34, &v27)) {
            break;
          }
          if (a2 >= v27) {
            unint64_t v19 = v27;
          }
          else {
            unint64_t v19 = a2;
          }
          if (v19)
          {
            uint64_t v20 = v34;
            uint64_t v21 = a1;
            unint64_t v22 = v19;
            do
            {
              char v23 = *v20++;
              *v21++ ^= v23;
              --v22;
            }
            while (v22);
          }
          a2 -= v19;
          if (!a2)
          {
            uint64_t v24 = 1;
            goto LABEL_18;
          }
          if (!sub_244D2ECF4((uint64_t)v31, (uint64_t)v35, &v28)) {
            break;
          }
          a1 += v19;
        }
      }
    }
  }
  uint64_t v24 = 0;
LABEL_18:
  sub_244D4413C(v35, 0x40uLL);
  sub_244D2EDC0(v33);
  sub_244D2EDC0(v31);
  sub_244D2EDC0(v29);
  return v24;
}

uint64_t sub_244D3A7E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, const void *a6, size_t a7, const void *a8, size_t a9)
{
  memset(v22, 0, sizeof(v22));
  memset(v21, 0, sizeof(v21));
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_244CFB3CC(v22);
  if (sub_244CFB3DC((uint64_t)v22, a7 + a9 + 10)
    && sub_244CFBD5C((uint64_t)v22, (unsigned __int16)a2)
    && sub_244CFB788((uint64_t *)v22, (uint64_t)v21)
    && sub_244CFBA40((uint64_t)v21, "tls13 ", 6uLL)
    && sub_244CFBA40((uint64_t)v21, a6, a7)
    && sub_244CFB788((uint64_t *)v22, (uint64_t)v21)
    && sub_244CFBA40((uint64_t)v21, a8, a9)
    && sub_244CFB48C((uint64_t)v22, &v20, &v19))
  {
    uint64_t v17 = sub_244D2E7F8(a1, a2, a3, a4, a5, (uint64_t)v20, v19);
    sub_244D440EC(v20);
  }
  else
  {
    sub_244CFB470((uint64_t)v22);
    return 0;
  }
  return v17;
}

uint64_t *sub_244D3A938(void *a1, uint64_t *a2)
{
  long long v8 = 0u;
  uint64_t v10 = 0;
  long long v9 = 0u;
  long long v7 = 0u;
  uint64_t v3 = a2[1];
  uint64_t v6 = *a2;
  *((void *)&v8 + 1) = v3;
  sub_244D3A9A4(&v6);
  sub_244D3AA48(&v6);
  uint64_t result = sub_244D3A9A4(&v6);
  uint64_t v5 = *((void *)&v8 + 1);
  *a1 = v6;
  a1[1] = v5;
  return result;
}

uint64_t *sub_244D3A9A4(uint64_t *result)
{
  uint64_t v1 = result[1];
  uint64_t v2 = (v1 ^ ((unint64_t)*result >> 1)) & 0x5555555555555555;
  unint64_t v3 = *result ^ (2 * v2);
  unint64_t v4 = v2 ^ v1;
  unint64_t v5 = result[2];
  uint64_t v6 = result[3];
  uint64_t v7 = (v6 ^ (v5 >> 1)) & 0x5555555555555555;
  uint64_t v8 = v5 ^ (2 * v7);
  uint64_t v9 = v7 ^ v6;
  unint64_t v10 = result[4];
  uint64_t v11 = result[5];
  uint64_t v12 = (v11 ^ (v10 >> 1)) & 0x5555555555555555;
  unint64_t v13 = v10 ^ (2 * v12);
  unint64_t v14 = v12 ^ v11;
  unint64_t v15 = result[6];
  uint64_t v16 = result[7];
  uint64_t v17 = (v16 ^ (v15 >> 1)) & 0x5555555555555555;
  uint64_t v18 = v15 ^ (2 * v17);
  uint64_t v19 = v17 ^ v16;
  uint64_t v20 = (v8 ^ (v3 >> 2)) & 0x3333333333333333;
  uint64_t v21 = v3 ^ (4 * v20);
  uint64_t v22 = v20 ^ v8;
  uint64_t v23 = (v9 ^ (v4 >> 2)) & 0x3333333333333333;
  *uint64_t result = v21;
  result[1] = v4 ^ (4 * v23);
  result[2] = v22;
  result[3] = v23 ^ v9;
  uint64_t v24 = (v18 ^ (v13 >> 2)) & 0x3333333333333333;
  uint64_t v25 = (v19 ^ (v14 >> 2)) & 0x3333333333333333;
  result[4] = v13 ^ (4 * v24);
  result[5] = v14 ^ (4 * v25);
  result[6] = v24 ^ v18;
  result[7] = v25 ^ v19;
  return result;
}

uint64_t *sub_244D3AA48(uint64_t *result)
{
  uint64_t v1 = result[6];
  uint64_t v2 = result[7];
  uint64_t v3 = result[4];
  uint64_t v4 = result[2];
  uint64_t v5 = v4 ^ v3;
  uint64_t v6 = result[1];
  uint64_t v7 = v6 ^ v2;
  uint64_t v8 = v3 ^ v2;
  uint64_t v9 = v4 ^ v2;
  uint64_t v10 = result[5] ^ v1;
  uint64_t v11 = *result ^ v10;
  uint64_t v12 = v11 ^ v3;
  uint64_t v13 = v6 ^ v2 ^ v5;
  uint64_t v63 = v11 ^ v2;
  uint64_t v14 = v11 ^ v6;
  uint64_t v15 = v14 ^ v4 ^ v2;
  uint64_t v16 = v13 ^ result[3];
  uint64_t v17 = v16 ^ v4;
  uint64_t v18 = v16 ^ v1;
  uint64_t v19 = v17 ^ v10;
  uint64_t v20 = v18 ^ v8;
  uint64_t v21 = v18 ^ v8 ^ *result;
  uint64_t v22 = v18 ^ v8 ^ v17 ^ v10;
  uint64_t v23 = v18 ^ v8 ^ v10;
  uint64_t v24 = (v18 ^ v8) & v8;
  uint64_t v25 = v22 & v5 ^ v24;
  uint64_t v26 = v24 ^ v19 & v9;
  uint64_t v27 = v18 ^ v17 & v13 ^ (v17 ^ *result) & v15 ^ v25;
  uint64_t v28 = v12 & *result ^ v9 ^ v17 & v13 ^ v19 ^ v26;
  uint64_t v29 = v14 & v11 ^ v7 ^ v23 & v7 ^ v25;
  uint64_t v30 = v21 & (v11 ^ v2) ^ v2 ^ v23 & v7 ^ v26;
  uint64_t v31 = v30 ^ v23;
  uint64_t v32 = v28 ^ v27;
  uint64_t v33 = (v29 ^ v23) & v27;
  uint64_t v34 = v33 ^ v30 ^ v23;
  uint64_t v35 = v34 & v32 ^ v28;
  uint64_t v36 = (v33 ^ v28) & (v30 ^ v29);
  uint64_t v37 = v36 ^ v31;
  uint64_t v38 = (v36 ^ v33) & v31;
  uint64_t v39 = v38 ^ v29 ^ v23;
  uint64_t v40 = (v38 ^ v34) & v35 ^ v32;
  uint64_t v41 = v40 ^ v39 ^ v37;
  uint64_t v42 = v41 ^ v37 ^ v35;
  uint64_t v43 = (v39 ^ v37) & (v17 ^ *result);
  uint64_t v44 = v37 & *result;
  uint64_t v45 = (v40 ^ v35) & v23;
  uint64_t v46 = v40 & v11;
  uint64_t v47 = v35 & v21;
  uint64_t v48 = v42 & v22;
  uint64_t v49 = (v39 ^ v37) & v15;
  uint64_t v50 = (v40 ^ v35) & v7;
  uint64_t v51 = v42 & v5;
  uint64_t v52 = v51 ^ (v37 ^ v35) & v8;
  uint64_t v53 = v49 ^ v37 & v12;
  uint64_t v54 = v40 & v14 ^ v47;
  uint64_t v55 = v49 ^ v39 & v13;
  uint64_t v56 = v45 ^ v39 & v17;
  uint64_t v57 = v50 ^ v44 ^ v56;
  uint64_t v58 = v45 ^ (v37 ^ v35) & v20 ^ v48;
  uint64_t v59 = v48 ^ v41 & v19 ^ v52 ^ v46;
  uint64_t v60 = v55 ^ v52 ^ v46;
  uint64_t v61 = v58 ^ v46;
  uint64_t v62 = v57 ^ v35 & v63 ^ v59;
  *uint64_t result = v54 ^ v52 ^ ~v57;
  result[1] = v54 ^ v50 ^ ~v59;
  result[2] = v53 ^ v62;
  result[3] = v47 ^ v44 ^ v60 ^ v43;
  result[4] = v60 ^ v43 ^ v56;
  result[5] = v61 ^ v41 & v9 ^ v51 ^ ~v62;
  result[6] = v61 ^ ~(v60 ^ v43 ^ v56);
  result[7] = v60 ^ v58;
  return result;
}

int8x16_t sub_244D3AC78(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 8);
  unint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void *)(a1 + 56);
  unint64_t v4 = (*(void *)a1 >> 4) & 0xFFF0FFF0FFF0FFFLL | (*(void *)a1 << 12) & 0xF000F000F000F000;
  unint64_t v5 = v4 ^ *(void *)a1;
  unint64_t v6 = (v1 >> 4) & 0xFFF0FFF0FFF0FFFLL | (v1 << 12) & 0xF000F000F000F000;
  unint64_t v7 = v6 ^ v1;
  unint64_t v8 = (v2 >> 4) & 0xFFF0FFF0FFF0FFFLL | (v2 << 12) & 0xF000F000F000F000;
  unint64_t v9 = v8 ^ v2;
  unint64_t v10 = (v3 >> 4) & 0xFFF0FFF0FFF0FFFLL | (v3 << 12) & 0xF000F000F000F000;
  unint64_t v11 = v10 ^ v3;
  int64x2_t v12 = *(int64x2_t *)(a1 + 16);
  int64x2_t v13 = *(int64x2_t *)(a1 + 32);
  v14.i64[0] = 0xF000F000F000F000;
  v14.i64[1] = 0xF000F000F000F000;
  int64x2_t v15 = (int64x2_t)vbslq_s8(v14, (int8x16_t)vshrq_n_u64((uint64x2_t)v12, 4uLL), (int8x16_t)vshlq_n_s64(v12, 0xCuLL));
  int64x2_t v16 = (int64x2_t)veorq_s8((int8x16_t)v15, (int8x16_t)v12);
  int64x2_t v17 = vdupq_laneq_s64(v16, 1);
  int64x2_t v18 = (int64x2_t)vbslq_s8(v14, (int8x16_t)vshrq_n_u64((uint64x2_t)v13, 4uLL), (int8x16_t)vshlq_n_s64(v13, 0xCuLL));
  *(void *)a1 = __rev16(v5) ^ v4 ^ v11;
  *(void *)(a1 + 8) = v5 ^ v6 ^ __rev16(v7) ^ v11;
  int8x16_t v19 = veorq_s8(veorq_s8((int8x16_t)vzip1q_s64(vdupq_laneq_s64(v15, 1), v18), (int8x16_t)vdupq_n_s64(v11)), (int8x16_t)v16);
  *(void *)(a1 + 16) = __rev16(v16.u64[0]) ^ v15.i64[0] ^ v7;
  int64x2_t v20 = (int64x2_t)veorq_s8((int8x16_t)v18, (int8x16_t)v13);
  int64x2_t v21 = vzip1q_s64(v17, v20);
  v17.i64[0] = 0xFF00FF00FF00FFLL;
  v17.i64[1] = 0xFF00FF00FF00FFLL;
  *(int8x16_t *)(a1 + 24) = veorq_s8(vbslq_s8((int8x16_t)v17, (int8x16_t)vshrq_n_u64((uint64x2_t)v21, 8uLL), (int8x16_t)vshlq_n_s64(v21, 8uLL)), v19);
  v21.i64[0] = vdupq_laneq_s64(v20, 1).u64[0];
  v21.i64[1] = v9;
  v15.i64[0] = vdupq_laneq_s64(v18, 1).u64[0];
  v15.i64[1] = v8;
  int8x16_t result = veorq_s8(vbslq_s8((int8x16_t)v17, (int8x16_t)vshrq_n_u64((uint64x2_t)v21, 8uLL), (int8x16_t)vshlq_n_s64(v21, 8uLL)), veorq_s8((int8x16_t)v15, (int8x16_t)v20));
  *(int8x16_t *)(a1 + 40) = result;
  *(void *)(a1 + 56) = v9 ^ v10 ^ __rev16(v11);
  return result;
}

uint64_t *sub_244D3ADB0(uint64_t *result)
{
  uint64_t v1 = result[1];
  uint64_t v2 = result[2];
  uint64_t v3 = result[3];
  uint64_t v4 = result[4];
  uint64_t v5 = result[5];
  uint64_t v6 = result[6];
  uint64_t v7 = result[7];
  uint64_t v8 = v3 ^ *result;
  uint64_t v9 = v5 ^ v2 ^ *result;
  uint64_t v10 = v6 ^ v1 ^ v3;
  uint64_t v11 = v4 ^ v1;
  *int8x16_t result = v5 ^ v2 ^ ~v7;
  result[1] = v8 ^ v6;
  result[2] = v11 ^ ~v7;
  result[3] = v9;
  result[4] = v10;
  result[5] = v7 ^ v2 ^ v4;
  result[6] = v8 ^ v5;
  result[7] = v11 ^ v6;
  return result;
}

uint64_t sub_244D3AE08(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void **sub_244D3AE14(uint64_t a1, uint64_t *a2)
{
  int8x16_t result = sub_244D16764((void **)a1, (uint64_t)a2);
  if (result)
  {
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 48) = sub_244D168EC(a2);
    *(_DWORD *)(a1 + 52) = 0;
    return (void **)1;
  }
  return result;
}

uint64_t sub_244D3AE58(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_244D1756C((void *)a5);
  uint64_t result = (uint64_t)sub_244D17610(a5);
  if (!result) {
    goto LABEL_55;
  }
  if (!a3)
  {
    uint64_t v11 = a2;
    goto LABEL_8;
  }
  uint64_t v11 = result;
  if (a2 == a3)
  {
    uint64_t result = sub_244D18A38(result, a3, a5);
    if (!result) {
      goto LABEL_55;
    }
LABEL_8:
    sub_244D1756C((void *)a5);
    int64x2_t v12 = sub_244D17610(a5);
    int64x2_t v13 = sub_244D17610(a5);
    int8x16_t v14 = sub_244D17610(a5);
    if (!a1) {
      a1 = sub_244D17610(a5);
    }
    uint64_t result = 0;
    if (v12 && v13 && v14 && a1)
    {
      if ((sub_244D170B4(*(uint64_t **)v11, *(int *)(v11 + 8), *(uint64_t **)a4, *(int *)(a4 + 8)) & 0x80000000) != 0)
      {
        *((_DWORD *)v14 + 4) = 0;
        *((_DWORD *)v14 + 2) = 0;
        uint64_t result = (uint64_t)sub_244D16764((void **)a1, v11);
        if (result)
        {
          if (*(unsigned char *)(a5 + 40))
          {
            uint64_t result = 1;
            goto LABEL_55;
          }
          uint64_t v26 = *(void *)(a5 + 16) - 1;
          *(void *)(a5 + 16) = v26;
          uint64_t result = 1;
LABEL_54:
          *(void *)(a5 + 32) = *(void *)(*(void *)(a5 + 8) + 8 * v26);
          goto LABEL_55;
        }
      }
      else
      {
        int v15 = sub_244D168EC((uint64_t *)v11);
        if (2 * *(_DWORD *)(a4 + 48) <= v15) {
          unsigned int v16 = v15;
        }
        else {
          unsigned int v16 = 2 * *(_DWORD *)(a4 + 48);
        }
        if (v16 == *(_DWORD *)(a4 + 52))
        {
          int v17 = v16;
        }
        else
        {
          sub_244D1756C((void *)a5);
          int64x2_t v18 = sub_244D17610(a5);
          if (v18 && (uint64_t v19 = (uint64_t)v18, sub_244D1E2A0((uint64_t)v18, v16)))
          {
            if (sub_244D17728((unint64_t *)(a4 + 24), 0, v19, a4, a5)) {
              int v17 = v16;
            }
            else {
              int v17 = -1;
            }
          }
          else
          {
            int v17 = -1;
          }
          if (!*(unsigned char *)(a5 + 40))
          {
            uint64_t v20 = *(void *)(a5 + 8);
            uint64_t v21 = *(void *)(a5 + 16) - 1;
            *(void *)(a5 + 16) = v21;
            *(void *)(a5 + 32) = *(void *)(v20 + 8 * v21);
          }
          *(_DWORD *)(a4 + 52) = v17;
        }
        if (v17 == -1)
        {
LABEL_51:
          uint64_t result = 0;
        }
        else
        {
          uint64_t result = sub_244D17ED0((void **)v12, v11, *(_DWORD *)(a4 + 48));
          if (result)
          {
            uint64_t result = sub_244D18AA8((uint64_t)v13, (uint64_t)v12, a4 + 24, a5);
            if (result)
            {
              uint64_t result = sub_244D17ED0((void **)v14, (uint64_t)v13, v16 - *(_DWORD *)(a4 + 48));
              if (result)
              {
                *((_DWORD *)v14 + 4) = 0;
                uint64_t result = sub_244D18AA8((uint64_t)v13, a4, (uint64_t)v14, a5);
                if (result)
                {
                  uint64_t result = sub_244D15C60((uint64_t)a1, v11, (uint64_t)v13);
                  if (result)
                  {
                    *((_DWORD *)a1 + 4) = 0;
                    int v22 = 4;
                    while (1)
                    {
                      uint64_t v23 = (uint64_t *)*a1;
                      unint64_t v24 = *((int *)a1 + 2);
                      if ((sub_244D170B4((uint64_t *)*a1, v24, *(uint64_t **)a4, *(int *)(a4 + 8)) & 0x80000000) != 0) {
                        break;
                      }
                      if (!--v22)
                      {
                        sub_244D0B884(3, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/bn/exponentiation.c", 367);
                        goto LABEL_51;
                      }
                      uint64_t result = sub_244D15C60((uint64_t)a1, (uint64_t)a1, a4);
                      if (result)
                      {
                        int v25 = sub_244D15FB8((uint64_t)v14, 1uLL);
                        uint64_t result = 0;
                        if (v25) {
                          continue;
                        }
                      }
                      goto LABEL_52;
                    }
                    if (v24)
                    {
                      uint64_t v27 = 0;
                      do
                      {
                        uint64_t v28 = *v23++;
                        v27 |= v28;
                        --v24;
                      }
                      while (v24);
                      if (v27) {
                        LODWORD(v27) = *(_DWORD *)(v11 + 16);
                      }
                    }
                    else
                    {
                      LODWORD(v27) = 0;
                    }
                    *((_DWORD *)a1 + 4) = v27;
                    *((_DWORD *)v14 + 4) = *(_DWORD *)(a4 + 16) ^ *(_DWORD *)(v11 + 16);
                    uint64_t result = 1;
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_52:
    if (*(unsigned char *)(a5 + 40)) {
      goto LABEL_55;
    }
    uint64_t v26 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v26;
    goto LABEL_54;
  }
  uint64_t result = sub_244D18AA8(result, a2, a3, a5);
  if (result) {
    goto LABEL_8;
  }
LABEL_55:
  if (!*(unsigned char *)(a5 + 40))
  {
    uint64_t v29 = *(void *)(a5 + 8);
    uint64_t v30 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v30;
    *(void *)(a5 + 32) = *(void *)(v29 + 8 * v30);
  }
  return result;
}

unint64_t sub_244D3B1B0(unint64_t *a1, unint64_t *a2, unint64_t *a3, int a4, unsigned int a5)
{
  uint64_t v9 = a4;
  unint64_t result = sub_244D16544(a1, a2, a3, a4);
  if (a5)
  {
    uint64_t v11 = &a1[v9];
    if ((a5 & 0x80000000) != 0)
    {
      unsigned int v16 = &a3[v9];
      if ((signed int)-a5 > 1) {
        uint64_t v17 = -a5;
      }
      else {
        uint64_t v17 = 1;
      }
      do
      {
        uint64_t v18 = *v16++;
        BOOL v19 = v18 != 0;
        unint64_t v20 = -v18 - result;
        unint64_t result = -v18 < result || v19;
        *v11++ = v20;
        --v17;
      }
      while (v17);
    }
    else
    {
      int64x2_t v12 = &a2[v9];
      uint64_t v13 = a5;
      do
      {
        unint64_t v14 = *v12++;
        unint64_t v15 = v14 - result;
        unint64_t result = v14 < result;
        *v11++ = v15;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

void sub_244D3B25C(uint64_t *a1, unint64_t *a2, unint64_t *a3, unsigned int a4, int a5, int a6, unint64_t *a7)
{
  unint64_t v13 = 2 * (int)a4;
  if ((int)a4 > 7)
  {
    uint64_t v48 = (int)a4;
    unint64_t v15 = &a7[2 * (int)a4];
    uint64_t v46 = &a2[a4];
    uint64_t v47 = a4;
    uint64_t v16 = sub_244D1E978(a7, a2, v46, a5, a4 - a5, v15);
    uint64_t v17 = &a7[a4];
    uint64_t v18 = sub_244D1E978(v17, &a3[a4], a3, a6, a6 - a4, v15) ^ v16;
    if (a4 == 8)
    {
      sub_244D1CC3C(v15, a7, v17);
      BOOL v19 = a1;
      sub_244D1CC3C(a1, a2, a3);
      sub_244D1EC90(&a1[v13], v46, a5, a3 + 8, a6);
      int v20 = a6 + a5;
      int v21 = v13 - (a6 + a5);
      uint64_t v22 = v48;
      if (v13 != v20) {
        bzero(&a1[v20 + (int)v13], 8 * v21);
      }
    }
    else
    {
      uint64_t v45 = &a3[a4];
      sub_244D3B5D8((uint64_t *)v15, a7, &a7[a4], a4, 0, 0, &a7[4 * v48]);
      BOOL v19 = a1;
      uint64_t v23 = a3;
      unint64_t v24 = &a7[4 * v48];
      sub_244D3B5D8(a1, a2, v23, a4, 0, 0, v24);
      int v25 = &a1[v13];
      bzero(v25, 8 * v13);
      if (a5 > 15 || a6 >= 16)
      {
        if (a5 <= a6) {
          int v26 = a6;
        }
        else {
          int v26 = a5;
        }
        LODWORD(v27) = a4;
        while (1)
        {
          int v28 = (int)v27 >= 0 ? v27 : (int)v27 + 1;
          uint64_t v27 = (v28 >> 1);
          if ((int)v27 < v26) {
            break;
          }
          if (a5 == v27 || a6 == v27)
          {
            sub_244D3B5D8(v25, v46, v45, v27, (a5 - v27), (a6 - v27), v24);
            goto LABEL_27;
          }
        }
        sub_244D3B25C(v25, v46, v45, v27, (a5 - v27), (a6 - v27), v24);
LABEL_27:
        uint64_t v22 = v48;
      }
      else
      {
        sub_244D1EC90(v25, v46, a5, v45, a6);
        uint64_t v22 = v48;
      }
    }
    uint64_t v30 = sub_244D15EB4(a7, v19, &v19[v13], v13);
    uint64_t v31 = 4 * v22;
    uint64_t v32 = &a7[4 * v22];
    unint64_t v33 = sub_244D16544(v32, a7, v15, v13);
    uint64_t v34 = sub_244D15EB4(v15, (uint64_t *)a7, (uint64_t *)v15, v13);
    uint64_t v35 = ~v18;
    uint64_t v36 = v15;
    unint64_t v37 = v13;
    do
    {
      unint64_t v38 = *v32++;
      *uint64_t v36 = *v36 & v35 | v38 & v18;
      ++v36;
      --v37;
    }
    while (v37);
    uint64_t v39 = sub_244D15EB4(&a1[v47], &a1[v47], (uint64_t *)v15, v13);
    int v40 = 3 * a4;
    if ((int)(3 * a4) < (int)v31)
    {
      unint64_t v41 = (v18 & (v30 - v33) | (v34 + v30) & v35) + v39;
      uint64_t v42 = &a1[v40];
      uint64_t v43 = v31 - v40;
      do
      {
        unint64_t v44 = *v42 + v41;
        unint64_t v41 = __CFADD__(*v42, v41);
        *v42++ = v44;
        --v43;
      }
      while (v43);
    }
  }
  else
  {
    sub_244D1EC90(a1, a2, (int)(a5 + a4), a3, (int)(a6 + a4));
    if (v13 != a6 + a5)
    {
      bzero(&a1[(int)v13 + a5 + a6], (int)v13 - (a6 + a5));
    }
  }
}

void sub_244D3B5D8(uint64_t *a1, unint64_t *a2, unint64_t *a3, unsigned int a4, uint64_t a5, uint64_t a6, unint64_t *a7)
{
  int v14 = a6 | a5;
  if (a4 != 8 || v14)
  {
    if ((int)a4 > 15)
    {
      unsigned int v15 = a4 >> 1;
      int v41 = a6 + (a4 >> 1);
      uint64_t v36 = &a2[a4 >> 1];
      uint64_t v38 = sub_244D1E978(a7, a2, v36, a5 + (a4 >> 1), -(int)a5, &a7[a4]);
      uint64_t v34 = &a7[v15];
      uint64_t v35 = &a3[v15];
      unint64_t v37 = &a7[a4];
      uint64_t v16 = sub_244D1E978(v34, v35, a3, v41, a6, v37) ^ v38;
      uint64_t v40 = a4 >> 1;
      if (v15 != 8 || v14)
      {
        uint64_t v19 = 2 * a4;
        uint64_t v17 = &a7[a4];
        sub_244D3B5D8(v37, a7, v34, v40, 0, 0);
        sub_244D3B5D8(a1, a2, a3, v40, 0, 0);
        unint64_t v18 = a4;
        sub_244D3B5D8(&a1[a4], v36, v35, v40, a5, a6);
      }
      else
      {
        uint64_t v17 = &a7[a4];
        sub_244D1CC3C(v37, a7, v34);
        sub_244D1CC3C(a1, a2, a3);
        unint64_t v18 = a4;
        sub_244D1CC3C(&a1[a4], v36, v35);
        uint64_t v19 = 2 * a4;
      }
      uint64_t v20 = sub_244D15EB4(a7, a1, &a1[v18], v18);
      signed int v21 = v19;
      uint64_t v22 = &a7[v19];
      unint64_t v39 = sub_244D16544(v22, a7, v17, v18);
      uint64_t v23 = sub_244D15EB4(v17, (uint64_t *)a7, (uint64_t *)v17, v18);
      uint64_t v24 = ~v16;
      int v25 = v17;
      unint64_t v26 = v18;
      do
      {
        unint64_t v27 = *v22++;
        *int v25 = *v25 & v24 | v27 & v16;
        ++v25;
        --v26;
      }
      while (v26);
      uint64_t v28 = sub_244D15EB4(&a1[v40], &a1[v40], (uint64_t *)v17, v18);
      int v29 = v40 + a4;
      if ((int)(v40 + a4) < v21)
      {
        unint64_t v30 = (v16 & (v20 - v39) | (v23 + v20) & v24) + v28;
        uint64_t v31 = &a1[v29];
        uint64_t v32 = v21 - (uint64_t)v29;
        do
        {
          unint64_t v33 = *v31 + v30;
          unint64_t v30 = __CFADD__(*v31, v30);
          *v31++ = v33;
          --v32;
        }
        while (v32);
      }
    }
    else
    {
      sub_244D1EC90(a1, a2, (int)(a5 + a4), a3, (int)(a6 + a4));
      if ((int)a6 + (int)a5 < 0)
      {
        bzero(&a1[(int)(a5 + 2 * a4 + a6)], 8 * -(a6 + a5));
      }
    }
  }
  else
  {
    sub_244D1CC3C(a1, a2, a3);
  }
}

uint64_t sub_244D3B90C(uint64_t a1, _OWORD *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = *(_DWORD *)(*(void *)a1 + 20) & 0x3F;
  if (v5 == 5)
  {
    BOOL v6 = 0;
  }
  else
  {
    BOOL v6 = v5 == 2;
    if (!a4 && (v5 - 3) >= 0xFFFFFFFE)
    {
      sub_244D13B14(a2, 8 * *(_DWORD *)(a1 + 24), v4);
      uint64_t v7 = sub_244D13A2C;
      goto LABEL_7;
    }
  }
  sub_244D13B14(a2, 8 * *(_DWORD *)(a1 + 24), v4);
  uint64_t v7 = sub_244D13964;
LABEL_7:
  *(void *)(v4 + 248) = v7;
  if (v6) {
    uint64_t v8 = sub_244D14900;
  }
  else {
    uint64_t v8 = 0;
  }
  *(void *)(v4 + 256) = v8;
  return 1;
}

uint64_t sub_244D3B9C8(uint64_t a1, __n128 *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  BOOL v6 = *(void (**)(unint64_t, __n128 *, unint64_t))(v5 + 256);
  if (v6)
  {
    v6(a3, a2, a4);
  }
  else
  {
    uint64_t v7 = (__n128 *)(a1 + 52);
    uint64_t v8 = *(void (**)(__n128 *, __n128 *, uint64_t))(v5 + 248);
    if (*(_DWORD *)(a1 + 28)) {
      sub_244D15464(a3, a2, a4, v5, v7, v8);
    }
    else {
      sub_244D155C4(a3, (unint64_t)a2, a4, v5, (uint64_t)v7, (uint64_t (*)(void *, void *, uint64_t))v8);
    }
  }
  return 1;
}

uint64_t sub_244D3BA2C(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  BOOL v6 = *(uint64_t (**)(char *, unsigned char *, unint64_t, uint64_t, uint64_t))(v5 + 256);
  uint64_t v7 = a1 + 52;
  uint64_t v8 = (void *)(a1 + 68);
  uint64_t v9 = (unsigned int *)(a1 + 104);
  if (v6) {
    sub_244D1512C(a3, a2, a4, v5, v7, v8, v9, v6);
  }
  else {
    sub_244D152E8(a3, a2, a4, v5, v7, v8, v9, *(uint64_t (**)(uint64_t, void *, uint64_t))(v5 + 248));
  }
  return 1;
}

uint64_t sub_244D3BA80(uint64_t a1, void *a2, uint64_t a3, unint64_t a4)
{
  return 1;
}

uint64_t sub_244D3BAB8(uint64_t a1, unint64_t a2, void *__src)
{
  if (a2 | (unint64_t)__src)
  {
    uint64_t v3 = (uint64_t *)__src;
    uint64_t v4 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) & 8);
    if (a2)
    {
      *(_OWORD *)(v4 + 352) = 0u;
      *(_OWORD *)(v4 + 368) = 0u;
      *(_OWORD *)(v4 + 320) = 0u;
      *(_OWORD *)(v4 + 336) = 0u;
      *(_OWORD *)(v4 + 288) = 0u;
      *(_OWORD *)(v4 + 304) = 0u;
      *(_OWORD *)(v4 + 256) = 0u;
      *(_OWORD *)(v4 + 272) = 0u;
      *(_OWORD *)(v4 + 224) = 0u;
      *(_OWORD *)(v4 + 240) = 0u;
      *(_OWORD *)(v4 + 192) = 0u;
      *(_OWORD *)(v4 + 208) = 0u;
      *(_OWORD *)(v4 + 160) = 0u;
      *(_OWORD *)(v4 + 176) = 0u;
      *(_OWORD *)(v4 + 128) = 0u;
      *(_OWORD *)(v4 + 144) = 0u;
      *(_OWORD *)(v4 + 96) = 0u;
      *(_OWORD *)(v4 + 112) = 0u;
      *(_OWORD *)(v4 + 48) = 0u;
      *(_OWORD *)(v4 + 64) = 0u;
      *(_OWORD *)(v4 + 16) = 0u;
      *(_OWORD *)(v4 + 32) = 0u;
      *(_OWORD *)uint64_t v4 = 0u;
      *(_OWORD *)(v4 + 80) = 0u;
      sub_244D13B14((_OWORD *)a2, 8 * *(_DWORD *)(a1 + 24), v4 + 384);
      sub_244D23028(v4 + 80, v4 + 384, (uint64_t (*)(unint64_t *, unint64_t *, uint64_t))sub_244D13964);
      *(void *)(v4 + 664) = sub_244D14738;
      if (v3 || *(_DWORD *)(v4 + 636) && (uint64_t v3 = *(uint64_t **)(v4 + 640)) != 0)
      {
        sub_244D30918(v4, v4 + 384, v3, *(int *)(v4 + 648));
        *(_DWORD *)(v4 + 636) = 1;
      }
      *(_DWORD *)(v4 + 632) = 1;
    }
    else
    {
      if (*(_DWORD *)(v4 + 632))
      {
        sub_244D30918(v4, v4 + 384, (uint64_t *)__src, *(int *)(v4 + 648));
      }
      else
      {
        size_t v5 = *(int *)(v4 + 648);
        if (v5) {
          memcpy(*(void **)(v4 + 640), v3, v5);
        }
      }
      *(_DWORD *)(v4 + 636) = 1;
      *(_DWORD *)(v4 + 656) = 0;
    }
  }
  return 1;
}

uint64_t sub_244D3BC04(uint64_t a1, int8x16_t *a2, int8x16_t *a3, unint64_t a4, int8x16_t a5)
{
  uint64_t v5 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) & 8);
  if (!*(_DWORD *)(v5 + 632)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (!(a4 >> 31) && *(_DWORD *)(v5 + 636))
  {
    if (!a3)
    {
      if (*(_DWORD *)(a1 + 28))
      {
        sub_244D31454((int8x16_t *)v5, 0, 0);
        uint64_t result = 0;
        *(_OWORD *)(a1 + 68) = *(_OWORD *)(v5 + 64);
        *(_DWORD *)(v5 + 652) = 16;
      }
      else
      {
        unint64_t v12 = *(unsigned int *)(v5 + 652);
        if ((v12 & 0x80000000) != 0) {
          return result;
        }
        if (!sub_244D31454((int8x16_t *)v5, (char *)(a1 + 68), v12)) {
          return 0xFFFFFFFFLL;
        }
        uint64_t result = 0;
      }
      *(_DWORD *)(v5 + 636) = 0;
      return result;
    }
    if (a2)
    {
      uint64_t v10 = *(void (**)(char *, int8x16_t *, uint64_t, uint64_t, uint64_t, __n128))(v5 + 664);
      uint64_t v11 = v5 + 384;
      if (*(_DWORD *)(a1 + 28))
      {
        if (v10)
        {
          if (!sub_244D31044(v5, v11, a3->i8, a2, a4, v10, a5)) {
            return 0xFFFFFFFFLL;
          }
          return a4;
        }
        if (sub_244D30B68((int8x16_t *)v5, v11, a3->i8, a2, a4, a5)) {
          return a4;
        }
      }
      else
      {
        if (v10)
        {
          if (!sub_244D3124C(v5, v11, a3, a2, a4, (void (*)(int8x16_t *, unsigned char *, uint64_t, uint64_t, uint64_t, __n128))v10))return 0xFFFFFFFFLL; {
          return a4;
          }
        }
        if (sub_244D30DD8((int8x16_t *)v5, v11, a3, a2->i64, a4, a5)) {
          return a4;
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (!sub_244D30A58((int8x16_t *)v5, a3, a4)) {
      return 0xFFFFFFFFLL;
    }
    return a4;
  }
  return result;
}

void sub_244D3BD24(uint64_t a1)
{
  uint64_t v2 = (void *)(*(void *)(a1 + 16) + (*(void *)(a1 + 16) & 8));
  sub_244D4413C(v2, 0x180uLL);
  uint64_t v3 = (void *)v2[80];
  if (v3 != (void *)(a1 + 52))
  {
    sub_244D440EC(v3);
  }
}

uint64_t sub_244D3BD88(uint64_t a1, int a2, size_t __n, void *__src)
{
  uint64_t v5 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) & 8);
  uint64_t result = 0xFFFFFFFFLL;
  int v8 = __n;
  switch(a2)
  {
    case 8:
      uint64_t v9 = (void *)(__src[2] + (__src[2] & 8));
      memcpy(v9, (const void *)v5, 0x2A0uLL);
      uint64_t v10 = *(const void **)(v5 + 640);
      if (v10 == (const void *)(a1 + 52))
      {
        v9[80] = (char *)__src + 52;
        return 1;
      }
      uint64_t result = (uint64_t)sub_244D442F4(v10, *(int *)(v5 + 648));
      v9[80] = result;
      if (result) {
        return 1;
      }
      return result;
    case 9:
      if ((int)__n < 1) {
        return 0;
      }
      if (__n < 0x11 || *(_DWORD *)(v5 + 648) >= (int)__n) {
        goto LABEL_13;
      }
      uint64_t v11 = *(void **)(v5 + 640);
      if (v11 != (void *)(a1 + 52)) {
        sub_244D440EC(v11);
      }
      uint64_t result = (uint64_t)sub_244D43FF4(v8);
      *(void *)(v5 + 640) = result;
      if (result)
      {
LABEL_13:
        *(_DWORD *)(v5 + 648) = v8;
        return 1;
      }
      return result;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 22:
    case 23:
      return result;
    case 16:
      if ((__n - 17) < 0xFFFFFFF0 || !*(_DWORD *)(a1 + 28) || (*(_DWORD *)(v5 + 652) & 0x80000000) != 0) {
        return 0;
      }
      memcpy(__src, (const void *)(a1 + 68), __n);
      return 1;
    case 17:
      if ((__n - 17) < 0xFFFFFFF0 || *(_DWORD *)(a1 + 28)) {
        return 0;
      }
      memcpy((void *)(a1 + 68), __src, __n);
      *(_DWORD *)(v5 + 652) = v8;
      return 1;
    case 18:
      if (__n == -1)
      {
        size_t v14 = *(int *)(v5 + 648);
        if (v14) {
          memcpy(*(void **)(v5 + 640), __src, v14);
        }
      }
      else
      {
        if ((int)__n < 4 || *(_DWORD *)(v5 + 648) - (int)__n < 8) {
          return 0;
        }
        memcpy(*(void **)(v5 + 640), __src, __n);
        if (*(_DWORD *)(a1 + 28)) {
          sub_244D20BA4((char *)(*(void *)(v5 + 640) + v8), *(int *)(v5 + 648) - (uint64_t)v8, (uint64_t)&unk_244EB7218);
        }
      }
      uint64_t result = 1;
      *(_DWORD *)(v5 + 656) = 1;
      return result;
    case 19:
      if (!*(_DWORD *)(v5 + 656) || !*(_DWORD *)(v5 + 632)) {
        return 0;
      }
      sub_244D30918(v5, v5 + 384, *(uint64_t **)(v5 + 640), *(int *)(v5 + 648));
      int v12 = *(_DWORD *)(v5 + 648);
      if (v8 >= 1 && v12 >= v8 || (int v8 = *(_DWORD *)(v5 + 648), v12))
      {
        memcpy(__src, (const void *)(*(void *)(v5 + 640) + v12 - v8), v8);
        uint64_t v13 = *(int *)(v5 + 648);
      }
      else
      {
        uint64_t v13 = 0;
      }
      *(void *)(*(void *)(v5 + 640) + v13 - 8) = bswap64(bswap64(*(void *)(*(void *)(v5 + 640) + v13 - 8)) + 1);
      goto LABEL_48;
    case 24:
      if (!*(_DWORD *)(v5 + 656) || !*(_DWORD *)(v5 + 632) || *(_DWORD *)(a1 + 28)) {
        return 0;
      }
      if (__n) {
        memcpy((void *)(*(void *)(v5 + 640) + *(int *)(v5 + 648) - (int)__n), __src, (int)__n);
      }
      sub_244D30918(v5, v5 + 384, *(uint64_t **)(v5 + 640), *(int *)(v5 + 648));
LABEL_48:
      uint64_t result = 1;
      *(_DWORD *)(v5 + 636) = 1;
      return result;
    case 25:
      *(_DWORD *)__src = *(_DWORD *)(v5 + 648);
      return 1;
    default:
      if (a2) {
        return result;
      }
      *(void *)(v5 + 632) = 0;
      *(_DWORD *)(v5 + 648) = *(_DWORD *)(*(void *)a1 + 12);
      *(void *)(v5 + 640) = a1 + 52;
      *(void *)(v5 + 652) = 0xFFFFFFFFLL;
      return 1;
  }
}

double sub_244D3C0D4()
{
  *(_OWORD *)&dword_268EBF190 = 0u;
  *(_OWORD *)algn_268EBF1B0 = 0u;
  qword_268EBF188 = 0x10000001A2;
  dword_268EBF190 = 16;
  *(void *)&double result = 0x100000108;
  qword_268EBF198 = 0x100000108;
  qword_268EBF1A0 = (uint64_t)sub_244D3B90C;
  qword_268EBF1A8 = (uint64_t)sub_244D3C130;
  return result;
}

uint64_t sub_244D3C130(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(*a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v8 = 0;
    uint64_t v9 = a1[2];
    do
    {
      (*(void (**)(unint64_t, unint64_t, uint64_t))(v9 + 248))(a3 + v8, a2 + v8, v9);
      v8 += v4;
    }
    while (v8 <= v5);
  }
  return 1;
}

double sub_244D3C1A0()
{
  *(_OWORD *)&dword_268EBF1C8 = 0u;
  unk_268EBF1E8 = 0u;
  qword_268EBF1C0 = 0x10000001A6;
  dword_268EBF1C8 = 24;
  *(void *)&double result = 0x100000108;
  qword_268EBF1D0 = 0x100000108;
  qword_268EBF1D8 = (uint64_t)sub_244D3B90C;
  qword_268EBF1E0 = (uint64_t)sub_244D3C130;
  return result;
}

double sub_244D3C1FC()
{
  *(_OWORD *)&dword_268EBF200 = 0u;
  unk_268EBF220 = 0u;
  qword_268EBF1F8 = 0x10000001AALL;
  dword_268EBF200 = 32;
  *(void *)&double result = 0x100000108;
  qword_268EBF208 = 0x100000108;
  qword_268EBF210 = (uint64_t)sub_244D3B90C;
  qword_268EBF218 = (uint64_t)sub_244D3C130;
  return result;
}

uint64_t sub_244D3C258(uint64_t a1, _OWORD *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v6 = 0;
  uint64_t result = sub_244D3C31C(a1 + 8, &v6, a2, a3, a4);
  if (result)
  {
    *(unsigned char *)(a1 + 576) = v6;
    return 1;
  }
  return result;
}

uint64_t sub_244D3C2B0(uint64_t a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, unint64_t a5, uint64_t *a6, unint64_t a7, char *a8, unint64_t a9, char *a10, unint64_t a11, int8x16_t *a12, uint64_t a13)
{
  return sub_244D3C400(a1 + 8, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, *(unsigned __int8 *)(a1 + 576));
}

uint64_t sub_244D3C2E8(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4, int8x16_t *a5, unint64_t a6, char *a7, unint64_t a8, int8x16_t *a9, uint64_t a10)
{
  return sub_244D3C61C(a1 + 8, a2, a3, a4, a5, a6, a7, a8, a9, a10, *(unsigned __int8 *)(a1 + 576));
}

uint64_t sub_244D3C31C(uint64_t a1, unint64_t *a2, _OWORD *a3, uint64_t a4, unint64_t a5)
{
  if ((a4 & 0x1FFFFFFFFFFFFFF7) != 0x10 && (a4 & 0x1FFFFFFFFFFFFFFFLL) != 0x20)
  {
    int v7 = 102;
    __int16 v8 = 902;
LABEL_9:
    sub_244D0B884(30, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", v8);
    return 0;
  }
  if (a5) {
    unint64_t v9 = a5;
  }
  else {
    unint64_t v9 = 16;
  }
  if (v9 >= 0x11)
  {
    int v7 = 116;
    __int16 v8 = 911;
    goto LABEL_9;
  }
  sub_244D13B14(a3, 8 * a4, a1);
  sub_244D23028(a1 + 248, a1, (uint64_t (*)(unint64_t *, unint64_t *, uint64_t))sub_244D13964);
  *(void *)(a1 + 536) = sub_244D14738;
  *a2 = v9;
  return 1;
}

uint64_t sub_244D3C400(uint64_t a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, unint64_t a5, uint64_t *a6, unint64_t a7, char *a8, unint64_t a9, char *a10, unint64_t a11, int8x16_t *a12, uint64_t a13, unint64_t a14)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  unint64_t v14 = a14 + a11;
  if (__CFADD__(a14, a11))
  {
    int v15 = 117;
    __int16 v16 = 953;
LABEL_13:
    sub_244D0B884(30, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", v16);
    return 0;
  }
  if (v14 > a5)
  {
    int v15 = 103;
    __int16 v16 = 957;
    goto LABEL_13;
  }
  if (!a7)
  {
    int v15 = 111;
    __int16 v16 = 961;
    goto LABEL_13;
  }
  memset(v30, 0, sizeof(v30));
  memset(v29, 0, sizeof(v29));
  memcpy(v30, (const void *)(a1 + 248), 0x120uLL);
  sub_244D30918((uint64_t)v29, a1, a6, a7);
  if (!a13 || (uint64_t result = sub_244D30A58(v29, a12, a13), result))
  {
    unint64_t v26 = *(void (**)(char *, int8x16_t *, uint64_t, uint64_t, uint64_t, __n128))(a1 + 536);
    if (v26)
    {
      uint64_t result = sub_244D31044((uint64_t)v29, a1, a8, a2, a9, v26, v24);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t result = sub_244D30B68(v29, a1, a8, a2, a9, v24);
      if (!result) {
        return result;
      }
    }
    if (a11)
    {
      uint64_t v28 = *(void (**)(char *, int8x16_t *, uint64_t, uint64_t, uint64_t, __n128))(a1 + 536);
      if (v28)
      {
        uint64_t result = sub_244D31044((uint64_t)v29, a1, a10, a3, a11, v28, v27);
        if (!result) {
          return result;
        }
      }
      else
      {
        uint64_t result = sub_244D30B68(v29, a1, a10, a3, a11, v27);
        if (!result) {
          return result;
        }
      }
    }
    sub_244D314FC(v29, &a3->i8[a11], a14);
    *a4 = v14;
    return 1;
  }
  return result;
}

uint64_t sub_244D3C61C(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4, int8x16_t *a5, unint64_t a6, char *a7, unint64_t a8, int8x16_t *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (!a4)
  {
    int v22 = 111;
    __int16 v23 = 1032;
LABEL_9:
    sub_244D0B884(30, 0, v22, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", v23);
    return 0;
  }
  if (a8 != a11)
  {
    int v22 = 101;
    __int16 v23 = 1037;
    goto LABEL_9;
  }
  memset(v25, 0, sizeof(v25));
  memset(v24, 0, sizeof(v24));
  memcpy(v25, (const void *)(a1 + 248), 0x120uLL);
  sub_244D30918((uint64_t)v24, a1, a3, a4);
  uint64_t result = sub_244D30A58(v24, a9, a10);
  if (!result) {
    return result;
  }
  signed int v21 = *(void (**)(int8x16_t *, unsigned char *, uint64_t, uint64_t, uint64_t, __n128))(a1 + 536);
  if (v21)
  {
    uint64_t result = sub_244D3124C((uint64_t)v24, a1, a5, a2, a6, v21);
    if (!result) {
      return result;
    }
    goto LABEL_12;
  }
  uint64_t result = sub_244D30DD8(v24, a1, a5, a2, a6, v20);
  if (result)
  {
LABEL_12:
    sub_244D314FC(v24, v26, a8);
    if (!sub_244D441D4(v26, a7, a8)) {
      return 1;
    }
    int v22 = 101;
    __int16 v23 = 1065;
    goto LABEL_9;
  }
  return result;
}

uint64_t sub_244D3C7F8(uint64_t a1, _OWORD *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 <= 0xB)
    {
      sub_244D0B884(30, 0, 103, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", 1138);
      return 0;
    }
    unint64_t v6 = a4 - 12;
  }
  else
  {
    unint64_t v6 = 0;
  }
  unint64_t v7 = 0;
  uint64_t result = sub_244D3C31C(a1 + 8, &v7, a2, a3, v6);
  if (result)
  {
    *(unsigned char *)(a1 + 576) = v7 + 12;
    return 1;
  }
  return result;
}

uint64_t sub_244D3C88C(uint64_t a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, unint64_t a5, uint64_t a6, uint64_t a7, char *a8, unint64_t a9, char *a10, unint64_t a11, int8x16_t *a12, uint64_t a13)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (a7)
  {
    int v13 = 111;
    __int16 v14 = 1160;
LABEL_5:
    sub_244D0B884(30, 0, v13, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", v14);
    return 0;
  }
  if (a5 <= 0xB)
  {
    int v13 = 103;
    __int16 v14 = 1166;
    goto LABEL_5;
  }
  sub_244D20BA4((char *)&v23, 0xCuLL, (uint64_t)&unk_244EB7218);
  uint64_t result = sub_244D3C400(a1 + 8, a2, a3, a4, a5 - 12, &v23, 0xCuLL, a8, a9, a10, a11, a12, a13, *(unsigned __int8 *)(a1 + 576) - 12);
  if (result)
  {
    int v22 = &a3->i8[*a4];
    *(void *)int v22 = v23;
    *((_DWORD *)v22 + 2) = v24;
    *a4 += 12;
    return 1;
  }
  return result;
}

uint64_t sub_244D3C9EC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int8x16_t *a5, unint64_t a6, char *a7, unint64_t a8, int8x16_t *a9, uint64_t a10)
{
  if (a4)
  {
    int v10 = 111;
    __int16 v11 = 1201;
LABEL_5:
    sub_244D0B884(30, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", v11);
    return 0;
  }
  if (a8 <= 0xB)
  {
    int v10 = 101;
    __int16 v11 = 1206;
    goto LABEL_5;
  }
  return sub_244D3C61C(a1 + 8, a2, (uint64_t *)&a7[a8 - 12], 0xCuLL, a5, a6, a7, a8 - 12, a9, a10, *(unsigned __int8 *)(a1 + 576) - 12);
}

uint64_t sub_244D3CA80(uint64_t a1, _OWORD *a2, uint64_t a3, unint64_t a4)
{
  *(void *)(a1 + 552) = 0;
  unint64_t v6 = 0;
  uint64_t result = sub_244D3C31C(a1 + 8, &v6, a2, a3, a4);
  if (result)
  {
    *(unsigned char *)(a1 + 576) = v6;
    return 1;
  }
  return result;
}

uint64_t sub_244D3CAD8(uint64_t a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, unint64_t a5, uint64_t *a6, uint64_t a7, char *a8, unint64_t a9, char *a10, unint64_t a11, int8x16_t *a12, uint64_t a13)
{
  if (a7 == 12)
  {
    unint64_t v13 = *(uint64_t *)((char *)a6 + 4);
    if (v13 != -1)
    {
      unint64_t v14 = bswap64(v13);
      if (v14 >= *(void *)(a1 + 552))
      {
        *(void *)(a1 + 552) = v14 + 1;
        return sub_244D3C400(a1 + 8, a2, a3, a4, a5, a6, 0xCuLL, a8, a9, a10, a11, a12, a13, *(unsigned __int8 *)(a1 + 576));
      }
    }
    int v15 = 125;
    __int16 v16 = 1300;
  }
  else
  {
    int v15 = 121;
    __int16 v16 = 1292;
  }
  sub_244D0B884(30, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", v16);
  return 0;
}

uint64_t sub_244D3CB8C(uint64_t a1, _OWORD *a2, uint64_t a3, unint64_t a4)
{
  *(void *)(a1 + 552) = 0;
  *(unsigned char *)(a1 + 568) = 1;
  unint64_t v6 = 0;
  uint64_t result = sub_244D3C31C(a1 + 8, &v6, a2, a3, a4);
  if (result)
  {
    *(unsigned char *)(a1 + 576) = v6;
    return 1;
  }
  return result;
}

uint64_t sub_244D3CBEC(uint64_t a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, unint64_t a5, uint64_t a6, uint64_t a7, char *a8, unint64_t a9, char *a10, unint64_t a11, int8x16_t *a12, uint64_t a13)
{
  if (a7 == 12)
  {
    unint64_t v13 = bswap64(*(void *)(a6 + 4));
    if (*(unsigned char *)(a1 + 568))
    {
      *(void *)(a1 + 560) = v13;
      *(unsigned char *)(a1 + 568) = 0;
      unint64_t v14 = v13;
    }
    else
    {
      unint64_t v14 = *(void *)(a1 + 560);
    }
    unint64_t v17 = v14 ^ v13;
    if (v17 != -1 && v17 >= *(void *)(a1 + 552))
    {
      *(void *)(a1 + 552) = v17 + 1;
      return sub_244D3C400(a1 + 8, a2, a3, a4, a5, (uint64_t *)a6, 0xCuLL, a8, a9, a10, a11, a12, a13, *(unsigned __int8 *)(a1 + 576));
    }
    int v15 = 125;
    __int16 v16 = 1407;
  }
  else
  {
    int v15 = 121;
    __int16 v16 = 1387;
  }
  sub_244D0B884(30, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aes.c", v16);
  return 0;
}

uint64_t sub_244D3CCC0(unsigned __int8 **a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  return sub_244D3D05C(a1, a2, a3, a4, 4);
}

uint64_t sub_244D3CCCC(uint64_t a1, unsigned char *a2, void *a3, void *a4, size_t a5, void *__src, size_t __n, char *a8, unint64_t a9, uint64_t a10, uint64_t a11, char *a12, unint64_t a13)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  unsigned int v13 = *(_DWORD *)(a1 + 276);
  if (v13 > 7 || a9 >> (8 * v13) == 0)
  {
    size_t v16 = *(unsigned __int8 *)(a1 + 576);
    if (v16 <= a5)
    {
      if (*(unsigned __int8 *)(*(void *)a1 + 1) == __n)
      {
        memset(v24, 0, sizeof(v24));
        if (sub_244D3D14C(a1 + 256, (uint64_t)v24, a1 + 8, __src, __n, a12, a13, a9)
          && sub_244D3D3F8(a1 + 256, v24, a1 + 8, a3, v16, a8, a9))
        {
          sub_244D3D574(a1 + 256, (uint64_t)v24, a1 + 8, a2, (uint64_t)a8, a9);
          *a4 = *(unsigned __int8 *)(a1 + 576);
          return 1;
        }
        int v17 = 117;
        __int16 v18 = 341;
      }
      else
      {
        int v17 = 111;
        __int16 v18 = 334;
      }
    }
    else
    {
      int v17 = 103;
      __int16 v18 = 329;
    }
  }
  else
  {
    int v17 = 117;
    __int16 v18 = 324;
  }
  sub_244D0B884(30, 0, v17, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aesccm.c", v18);
  return 0;
}

uint64_t sub_244D3CE88(uint64_t a1, char *a2, void *__src, size_t __n, uint64_t a5, unint64_t a6, char *a7, size_t a8, char *a9, unint64_t a10)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  unsigned int v10 = *(_DWORD *)(a1 + 276);
  if (v10 > 7 || a6 >> (8 * v10) == 0)
  {
    if (*(unsigned __int8 *)(*(void *)a1 + 1) == __n)
    {
      if (*(unsigned __int8 *)(a1 + 576) == a8)
      {
        memset(v22, 0, sizeof(v22));
        if (sub_244D3D14C(a1 + 256, (uint64_t)v22, a1 + 8, __src, __n, a9, a10, a6)
          && (sub_244D3D574(a1 + 256, (uint64_t)v22, a1 + 8, a2, a5, a6),
              sub_244D3D3F8(a1 + 256, v22, a1 + 8, v21, a8, a2, a6)))
        {
          if (!sub_244D441D4(v21, a7, *(unsigned __int8 *)(a1 + 576))) {
            return 1;
          }
          int v18 = 101;
          __int16 v19 = 383;
        }
        else
        {
          int v18 = 117;
          __int16 v19 = 378;
        }
      }
      else
      {
        int v18 = 101;
        __int16 v19 = 369;
      }
    }
    else
    {
      int v18 = 111;
      __int16 v19 = 364;
    }
  }
  else
  {
    int v18 = 117;
    __int16 v19 = 359;
  }
  sub_244D0B884(30, 0, v18, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aesccm.c", v19);
  return 0;
}

uint64_t sub_244D3D05C(unsigned __int8 **a1, _OWORD *a2, uint64_t a3, uint64_t a4, int a5)
{
  if (**a1 == a3)
  {
    if (!a4 || a5 == a4)
    {
      sub_244D13B14(a2, 8 * a3, (uint64_t)(a1 + 1));
      *((unsigned char *)a1 + 576) = a5;
      if ((a5 & 1) == 0)
      {
        a1[32] = (unsigned __int8 *)sub_244D13964;
        a1[33] = (unsigned __int8 *)sub_244D14738;
        *((_DWORD *)a1 + 68) = a5;
        *((_DWORD *)a1 + 69) = 2;
        return 1;
      }
      int v7 = 68;
      __int16 v8 = 306;
    }
    else
    {
      int v7 = 116;
      __int16 v8 = 296;
    }
  }
  else
  {
    int v7 = 102;
    __int16 v8 = 287;
  }
  sub_244D0B884(30, 0, v7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/cipher/e_aesccm.c", v8);
  return 0;
}

uint64_t sub_244D3D14C(uint64_t a1, uint64_t a2, uint64_t a3, void *__src, size_t __n, char *a6, unint64_t a7, unint64_t a8)
{
  unint64_t v8 = *(unsigned int *)(a1 + 20);
  BOOL v10 = v8 > 7 || a8 >> (8 * v8) == 0;
  if (15 - v8 != __n || !v10) {
    return 0;
  }
  unint64_t v13 = a7;
  int v17 = *(void (**)(uint64_t, uint64_t, uint64_t, void *))a1;
  int v18 = *(_DWORD *)(a1 + 16);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  char v19 = (((4 * v18) & 0xF8) - 8) | (v8 - 1);
  if (a7) {
    v19 |= 0x40u;
  }
  *(unsigned char *)a2 = v19;
  if (__n) {
    memcpy((void *)(a2 + 1), __src, __n);
  }
  if (v8)
  {
    for (uint64_t i = 0; i != v8; ++i)
      *(unsigned char *)(a2 + (15 - i)) = a8 >> (8 * i);
  }
  v17(a2, a2 + 16, a3, __src);
  if (v13)
  {
    if (v13 >> 8 > 0xFE)
    {
      *(unsigned char *)(a2 + 16) = ~*(unsigned char *)(a2 + 16);
      char v24 = *(unsigned char *)(a2 + 17);
      if (HIDWORD(v13))
      {
        *(unsigned char *)(a2 + 17) = ~v24;
        uint64x2_t v25 = (uint64x2_t)vdupq_n_s64(v13);
        int32x4_t v26 = (int32x4_t)vshlq_u64(v25, (uint64x2_t)xmmword_244EB6F20);
        int16x8_t v27 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v25, (uint64x2_t)xmmword_244EB6F30), v26);
        v26.i32[0] = *(_DWORD *)(a2 + 18);
        *(int8x8_t *)v27.i8 = veor_s8((int8x8_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v26.i8), (int8x8_t)vmovn_s32((int32x4_t)v27));
        *(_DWORD *)(a2 + 18) = vmovn_s16(v27).u32[0];
        *(unsigned char *)(a2 + 22) ^= BYTE3(v13);
        *(unsigned char *)(a2 + 23) ^= BYTE2(v13);
        *(unsigned char *)(a2 + 24) ^= BYTE1(v13);
        signed int v21 = (unsigned char *)(a2 + 25);
        unint64_t v22 = 10;
      }
      else
      {
        *(unsigned char *)(a2 + 17) = v24 ^ 0xFE;
        *(unsigned char *)(a2 + 18) ^= BYTE3(v13);
        *(unsigned char *)(a2 + 19) ^= BYTE2(v13);
        *(unsigned char *)(a2 + 20) ^= BYTE1(v13);
        signed int v21 = (unsigned char *)(a2 + 21);
        unint64_t v22 = 6;
      }
    }
    else
    {
      *(unsigned char *)(a2 + 16) ^= BYTE1(v13);
      signed int v21 = (unsigned char *)(a2 + 17);
      unint64_t v22 = 2;
    }
    *v21 ^= v13;
    uint64_t v23 = 1;
    while (v13)
    {
      do
      {
        char v28 = *a6++;
        unint64_t v29 = v13;
        *(unsigned char *)(a2 + 16 + v22) ^= v28;
        --v13;
        if (v22 > 0xE) {
          break;
        }
        ++v22;
      }
      while (v29 != 1);
      ((void (*)(uint64_t, uint64_t, uint64_t))v17)(a2 + 16, a2 + 16, a3);
      unint64_t v22 = 0;
      ++v23;
      if (v29 == 1) {
        goto LABEL_32;
      }
    }
    ((void (*)(uint64_t, uint64_t, uint64_t))v17)(a2 + 16, a2 + 16, a3);
    ++v23;
  }
  else
  {
    uint64_t v23 = 1;
  }
LABEL_32:
  if (a8 > 0xFFFFFFFFFFFFFFF0) {
    return 0;
  }
  uint64_t result = 0;
  unint64_t v31 = ((a8 + 15) >> 3) | 1;
  BOOL v32 = __CFADD__(v23, v31);
  unint64_t v33 = v23 + v31;
  if (!v32 && v33 <= 0x2000000000000000)
  {
    *(unsigned char *)a2 &= 7u;
    return 1;
  }
  return result;
}

uint64_t sub_244D3D3F8(uint64_t a1, int8x16_t *a2, uint64_t a3, void *a4, size_t a5, char *a6, unint64_t a7)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 16) != a5) {
    return 0;
  }
  unint64_t v7 = a7;
  unint64_t v14 = *(void (**)(int8x16_t *, int8x16_t *, uint64_t))a1;
  if (a7 >= 0x10)
  {
    do
    {
      uint64_t v15 = a2[1].i64[1];
      a2[1].i64[0] ^= *(void *)a6;
      a2[1].i64[1] = *((void *)a6 + 1) ^ v15;
      v14(a2 + 1, a2 + 1, a3);
      a6 += 16;
      v7 -= 16;
    }
    while (v7 > 0xF);
  }
  if (v7)
  {
    size_t v16 = a2 + 1;
    do
    {
      char v17 = *a6++;
      v16->i8[0] ^= v17;
      size_t v16 = (int8x16_t *)((char *)v16 + 1);
      --v7;
    }
    while (v7);
    v14(a2 + 1, a2 + 1, a3);
  }
  if (*(_DWORD *)(a1 + 20))
  {
    unint64_t v18 = 0;
    uint64_t v19 = 15;
    do
    {
      a2->i8[v19] = 0;
      ++v18;
      --v19;
    }
    while (v18 < *(unsigned int *)(a1 + 20));
  }
  v14(a2, &v23, a3);
  int8x16_t v21 = a2[1];
  int8x16_t v20 = a2 + 1;
  *int8x16_t v20 = veorq_s8(v23, v21);
  if (a5) {
    memcpy(a4, v20, a5);
  }
  return 1;
}

uint64_t sub_244D3D574(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, unint64_t a6)
{
  _OWORD v11[2] = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 20))
  {
    unint64_t v6 = 0;
    uint64_t v7 = 15;
    do
    {
      *(unsigned char *)(a2 + v7) = 0;
      ++v6;
      --v7;
    }
    while (v6 < *(unsigned int *)(a1 + 20));
  }
  *(unsigned char *)(a2 + 15) = 1;
  unsigned int v10 = 0;
  unint64_t v8 = *(uint64_t (**)(char *, unsigned char *, unint64_t, uint64_t, uint64_t))(a1 + 8);
  if (v8) {
    return sub_244D1512C(a5, a4, a6, a3, a2, v11, &v10, v8);
  }
  else {
    return sub_244D152E8(a5, a4, a6, a3, a2, v11, &v10, *(uint64_t (**)(uint64_t, void *, uint64_t))a1);
  }
}

uint64_t sub_244D3D644(unsigned __int8 **a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  return sub_244D3D05C(a1, a2, a3, a4, 8);
}

uint64_t sub_244D3D64C(unsigned __int8 **a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  return sub_244D3D05C(a1, a2, a3, a4, 16);
}

double sub_244D3D654(uint64_t a1)
{
  uint64_t v1 = *(_OWORD **)(a1 + 8);
  double result = 0.0;
  *(_OWORD *)((char *)v1 + 76) = 0u;
  v1[3] = 0u;
  v1[4] = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  _OWORD *v1 = xmmword_244EB6ED0;
  return result;
}

uint64_t (*sub_244D3D678(uint64_t a1, char *__src, size_t __n))(uint64_t, char *, uint64_t)
{
  return sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D2F25C, *(void *)(a1 + 8), (char *)(*(void *)(a1 + 8) + 24), (_DWORD *)(*(void *)(a1 + 8) + 88), (_DWORD *)(*(void *)(a1 + 8) + 20), (_DWORD *)(*(void *)(a1 + 8) + 16), __src, __n);
}

uint64_t sub_244D3D6A8(uint64_t a1, _DWORD *a2)
{
  return sub_244D2F170(a2, *(void *)(a1 + 8));
}

double sub_244D3D6B8(uint64_t a1)
{
  uint64_t v1 = *(_OWORD **)(a1 + 8);
  double result = 0.0;
  *(_OWORD *)((char *)v1 + 76) = 0u;
  v1[3] = 0u;
  v1[4] = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  _OWORD *v1 = xmmword_244EB6ED0;
  return result;
}

uint64_t (*sub_244D3D6DC(uint64_t a1, char *__src, size_t __n))(uint64_t, char *, uint64_t)
{
  return sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D2FB3C, *(void *)(a1 + 8), (char *)(*(void *)(a1 + 8) + 24), (_DWORD *)(*(void *)(a1 + 8) + 88), (_DWORD *)(*(void *)(a1 + 8) + 20), (_DWORD *)(*(void *)(a1 + 8) + 16), __src, __n);
}

uint64_t sub_244D3D70C(uint64_t a1, _DWORD *a2)
{
  return sub_244D2FA50(a2, *(void *)(a1 + 8));
}

double sub_244D3D71C(uint64_t a1)
{
  uint64_t v1 = *(_OWORD **)(a1 + 8);
  double result = 0.0;
  v1[4] = 0u;
  v1[5] = 0u;
  v1[2] = 0u;
  v1[3] = 0u;
  _OWORD *v1 = xmmword_244EB6ED0;
  v1[1] = 0u;
  *((_DWORD *)v1 + 4) = -1009589776;
  return result;
}

uint64_t (*sub_244D3D748(uint64_t a1, char *__src, size_t __n))(uint64_t, char *, uint64_t)
{
  return sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D3708C, *(void *)(a1 + 8), (char *)(*(void *)(a1 + 8) + 28), (_DWORD *)(*(void *)(a1 + 8) + 92), (_DWORD *)(*(void *)(a1 + 8) + 24), (_DWORD *)(*(void *)(a1 + 8) + 20), __src, __n);
}

uint64_t sub_244D3D778(uint64_t a1, _DWORD *a2)
{
  return sub_244D36FAC(a2, *(void *)(a1 + 8));
}

double sub_244D3D788(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(_OWORD *)(v1 + 80) = 0u;
  *(_OWORD *)(v1 + 96) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)(v1 + 64) = 0u;
  double result = 3.15644116e-46;
  *(_OWORD *)uint64_t v1 = xmmword_244EB6E10;
  *(_OWORD *)(v1 + 16) = xmmword_244EB6E20;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_DWORD *)(v1 + 108) = 28;
  return result;
}

uint64_t (*sub_244D3D7BC(uint64_t a1, char *__src, size_t __n))(uint64_t, char *, uint64_t)
{
  return sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D384F4, *(void *)(a1 + 8), (char *)(*(void *)(a1 + 8) + 40), (_DWORD *)(*(void *)(a1 + 8) + 104), (_DWORD *)(*(void *)(a1 + 8) + 36), (_DWORD *)(*(void *)(a1 + 8) + 32), __src, __n);
}

uint64_t sub_244D3D7EC(uint64_t a1, _DWORD *a2)
{
  return sub_244D39114(a2, 0x1CuLL, *(void *)(a1 + 8));
}

double sub_244D3D7FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(_OWORD *)(v1 + 80) = 0u;
  *(_OWORD *)(v1 + 96) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)(v1 + 64) = 0u;
  double result = -1.56712499e-22;
  *(_OWORD *)uint64_t v1 = xmmword_244EB6E30;
  *(_OWORD *)(v1 + 16) = xmmword_244EB6E40;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_DWORD *)(v1 + 108) = 32;
  return result;
}

uint64_t (*sub_244D3D830(uint64_t a1, char *__src, size_t __n))(uint64_t, char *, uint64_t)
{
  return sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D384F4, *(void *)(a1 + 8), (char *)(*(void *)(a1 + 8) + 40), (_DWORD *)(*(void *)(a1 + 8) + 104), (_DWORD *)(*(void *)(a1 + 8) + 36), (_DWORD *)(*(void *)(a1 + 8) + 32), __src, __n);
}

uint64_t sub_244D3D860(uint64_t a1, _DWORD *a2)
{
  return sub_244D39114(a2, *(unsigned int *)(*(void *)(a1 + 8) + 108), *(void *)(a1 + 8));
}

double sub_244D3D874(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(_OWORD *)uint64_t v1 = xmmword_244EB6E50;
  *(_OWORD *)(v1 + 16) = xmmword_244EB6E60;
  *(_OWORD *)(v1 + 32) = xmmword_244EB6E70;
  *(_OWORD *)(v1 + 48) = xmmword_244EB6E80;
  *(void *)(v1 + 64) = 0;
  *(void *)(v1 + 72) = 0;
  *(void *)&double result = 0x3000000000;
  *(void *)(v1 + 208) = 0x3000000000;
  return result;
}

uint64_t sub_244D3D8B4(uint64_t a1, unint64_t *a2, size_t a3)
{
  return sub_244D277D8(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_244D3D8BC(uint64_t a1, void *a2)
{
  return sub_244D39398(a2, 0x30uLL, *(int8x16_t **)(a1 + 8));
}

double sub_244D3D8CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(_OWORD *)uint64_t v1 = xmmword_244EB6E90;
  *(_OWORD *)(v1 + 16) = xmmword_244EB6EA0;
  *(_OWORD *)(v1 + 32) = xmmword_244EB6EB0;
  *(_OWORD *)(v1 + 48) = xmmword_244EB6EC0;
  *(void *)(v1 + 64) = 0;
  *(void *)(v1 + 72) = 0;
  *(void *)&double result = 0x4000000000;
  *(void *)(v1 + 208) = 0x4000000000;
  return result;
}

uint64_t sub_244D3D90C(uint64_t a1, unint64_t *a2, size_t a3)
{
  return sub_244D277D8(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_244D3D914(uint64_t a1, void *a2)
{
  return sub_244D39398(a2, *(unsigned int *)(*(void *)(a1 + 8) + 212), *(int8x16_t **)(a1 + 8));
}

double sub_244D3D928(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(_OWORD *)uint64_t v1 = xmmword_244EB6EE0;
  *(_OWORD *)(v1 + 16) = xmmword_244EB6EF0;
  *(_OWORD *)(v1 + 32) = xmmword_244EB6F00;
  *(_OWORD *)(v1 + 48) = xmmword_244EB6F10;
  *(void *)(v1 + 64) = 0;
  *(void *)(v1 + 72) = 0;
  *(void *)&double result = 0x2000000000;
  *(void *)(v1 + 208) = 0x2000000000;
  return result;
}

uint64_t sub_244D3D968(uint64_t a1, unint64_t *a2, size_t a3)
{
  return sub_244D277D8(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_244D3D970(uint64_t a1, void *a2)
{
  return sub_244D39398(a2, 0x20uLL, *(int8x16_t **)(a1 + 8));
}

double sub_244D3D980(uint64_t a1)
{
  uint64_t v1 = *(_OWORD **)(a1 + 8);
  double result = 0.0;
  *(_OWORD *)((char *)v1 + 76) = 0u;
  v1[3] = 0u;
  v1[4] = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  _OWORD *v1 = xmmword_244EB6ED0;
  *(_OWORD *)((char *)v1 + 108) = 0u;
  *(_OWORD *)((char *)v1 + 124) = 0u;
  *(_OWORD *)((char *)v1 + 140) = 0u;
  *(_OWORD *)((char *)v1 + 156) = 0u;
  *(_OWORD *)((char *)v1 + 172) = 0u;
  *(_OWORD *)((char *)v1 + 92) = xmmword_244EB6ED0;
  *((_DWORD *)v1 + 27) = -1009589776;
  return result;
}

uint64_t (*sub_244D3D9C8(uint64_t a1, char *__src, size_t __n))(uint64_t, char *, uint64_t)
{
  uint64_t v5 = *(void *)(a1 + 8);
  sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D2FB3C, v5, (char *)(v5 + 24), (_DWORD *)(v5 + 88), (_DWORD *)(v5 + 20), (_DWORD *)(v5 + 16), __src, __n);

  return sub_244D2F804((uint64_t (*)(uint64_t, char *, uint64_t))sub_244D3708C, v5 + 92, (char *)(v5 + 120), (_DWORD *)(v5 + 184), (_DWORD *)(v5 + 116), (_DWORD *)(v5 + 112), __src, __n);
}

uint64_t sub_244D3DA64(uint64_t a1, _DWORD *a2)
{
  unint64_t v3 = *(void *)(a1 + 8);
  sub_244D2FA50(a2, v3);

  return sub_244D36FAC(a2 + 4, v3 + 92);
}

void sub_244D3DAAC()
{
  qword_268EBF740 = (uint64_t)sub_244D0D71C;
  qword_268EBF748 = (uint64_t)sub_244D0D780;
}

uint64_t sub_244D3DAD8(uint64_t a1)
{
  uint64_t v2 = (unint64_t *)(a1 + 160);
  *(_DWORD *)(a1 + 528) = 1;
  unint64_t v3 = (unint64_t *)(a1 + 360);
  sub_244D2C518(a1, (unint64_t *)(a1 + 360), (unint64_t *)(a1 + 160));
  uint64_t v9 = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  sub_244D1811C(v3, v3, v2, *(uint64_t **)(a1 + 320), (uint64_t *)&v5, *(int *)(a1 + 328));
  uint64_t v9 = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  return sub_244D1811C(v3, v3, v2, *(uint64_t **)(a1 + 320), (uint64_t *)&v5, *(int *)(a1 + 328));
}

uint64_t sub_244D3DB7C(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v8 = (uint64_t)(a2 + 18);
  int v9 = *(_DWORD *)(a1 + 328);
  if (v9 < 1)
  {
    BOOL v14 = 1;
  }
  else
  {
    uint64_t v10 = 0;
    __int16 v11 = (uint64_t *)v8;
    uint64_t v12 = *(unsigned int *)(a1 + 328);
    do
    {
      uint64_t v13 = *v11++;
      v10 |= v13;
      --v12;
    }
    while (v12);
    BOOL v14 = v10 == 0;
  }
  if (v14)
  {
    sub_244D0B884(15, 0, 119, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_montgomery.c", 150);
    return 0;
  }
  else
  {
    uint64_t v19 = 0;
    memset(v18, 0, sizeof(v18));
    uint64_t v17 = 0;
    memset(v16, 0, sizeof(v16));
    sub_244D1A824((unint64_t *)v16, v8, v9, a1 + 296);
    sub_244D1A72C((unint64_t *)v18, (unint64_t *)v16, (unint64_t *)v16, *(int *)(a1 + 328), a1 + 296);
    if (a3) {
      sub_244D1A72C(a3, a2, (unint64_t *)v18, *(int *)(a1 + 328), a1 + 296);
    }
    if (a4)
    {
      sub_244D1A72C((unint64_t *)v18, (unint64_t *)v18, (unint64_t *)v16, *(int *)(a1 + 328), a1 + 296);
      sub_244D1A72C(a4, a2 + 9, (unint64_t *)v18, *(int *)(a1 + 328), a1 + 296);
    }
    return 1;
  }
}

uint64_t sub_244D3DCC0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!a4) {
    return 1;
  }
  uint64_t v6 = a2;
  *(_OWORD *)a2 = *(_OWORD *)(a3 + 144);
  long long v8 = *(_OWORD *)(a3 + 160);
  long long v9 = *(_OWORD *)(a3 + 176);
  long long v10 = *(_OWORD *)(a3 + 192);
  *(void *)(a2 + 64) = *(void *)(a3 + 208);
  *(_OWORD *)(a2 + 32) = v9;
  *(_OWORD *)(a2 + 48) = v10;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v11 = a4 - 1;
  if (a4 != 1)
  {
    uint64_t v12 = (unint64_t *)(a3 + 360);
    unint64_t v13 = a4 - 1;
    do
    {
      uint64_t v14 = a2 + 144;
      sub_244D1A72C((unint64_t *)(a2 + 144), (unint64_t *)a2, v12, *(int *)(a1 + 328), a1 + 296);
      v12 += 27;
      a2 = v14;
      --v13;
    }
    while (v13);
  }
  int v15 = *(_DWORD *)(a1 + 328);
  if (v15 < 1) {
    goto LABEL_16;
  }
  uint64_t v16 = 0;
  uint64_t v17 = (uint64_t *)(v6 + 144 * v11);
  uint64_t v18 = *(unsigned int *)(a1 + 328);
  do
  {
    uint64_t v19 = *v17++;
    v16 |= v19;
    --v18;
  }
  while (v18);
  if (v16)
  {
    uint64_t v34 = 0;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    sub_244D1A824((unint64_t *)&v30, v6 + 144 * v11, v15, a1 + 296);
    int8x16_t v20 = (unint64_t *)(a3 + 216 * a4 - 216);
    int8x16_t v21 = (unint64_t *)(v6 + 144 * a4 - 144);
    do
    {
      uint64_t v29 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      uint64_t v24 = 0;
      memset(v23, 0, sizeof(v23));
      if (v11)
      {
        sub_244D1A72C((unint64_t *)&v25, (unint64_t *)&v30, v21 - 18, *(int *)(a1 + 328), a1 + 296);
        sub_244D1A72C((unint64_t *)&v30, (unint64_t *)&v30, v20 + 18, *(int *)(a1 + 328), a1 + 296);
      }
      else
      {
        long long v27 = v32;
        long long v28 = v33;
        uint64_t v29 = v34;
        long long v25 = v30;
        long long v26 = v31;
      }
      sub_244D1A72C((unint64_t *)v23, (unint64_t *)&v25, (unint64_t *)&v25, *(int *)(a1 + 328), a1 + 296);
      sub_244D1A72C(v21, v20, (unint64_t *)v23, *(int *)(a1 + 328), a1 + 296);
      sub_244D1A72C(v21 + 9, v20 + 9, (unint64_t *)v23, *(int *)(a1 + 328), a1 + 296);
      sub_244D1A72C(v21 + 9, v21 + 9, (unint64_t *)&v25, *(int *)(a1 + 328), a1 + 296);
      v20 -= 27;
      v21 -= 18;
      --v11;
    }
    while (v11 < a4);
    return 1;
  }
  else
  {
LABEL_16:
    sub_244D0B884(15, 0, 119, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/ec_montgomery.c", 189);
    return 0;
  }
}

uint64_t sub_244D3DF00(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 536) && (uint64_t v6 = *(unsigned int *)(a1 + 328), v6 == *(_DWORD *)(a1 + 264)))
  {
    if ((int)v6 < 1) {
      return 0;
    }
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    long long v9 = (unint64_t *)(a2 + 144);
    do
    {
      v8 |= *(void *)(a2 + v7 + 144);
      v7 += 8;
    }
    while (8 * v6 != v7);
    if (!v8) {
      return 0;
    }
    uint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    uint64_t v16 = 0;
    memset(v15, 0, sizeof(v15));
    uint64_t v14 = 0;
    memset(v13, 0, sizeof(v13));
    sub_244D1A72C((unint64_t *)v15, v9, (unint64_t *)(a2 + 144), (int)v6, a1 + 296);
    unint64_t v10 = *(int *)(a1 + 328);
    if (v10) {
      __memcpy_chk();
    }
    sub_244D1A72C((unint64_t *)v17, (unint64_t *)v17, (unint64_t *)v15, v10, a1 + 296);
    sub_244D1A64C((unint64_t *)v13, *(int *)(a1 + 328), a2, *(int *)(a1 + 328), a1 + 296);
    if (sub_244D441D4((char *)v17, (char *)v13, 8 * *(int *)(a1 + 328))
      && (sub_244D15EB4(v17, a3, *(uint64_t **)(a1 + 256), *(int *)(a1 + 328))
       || (unint64_t v11 = *(int *)(a1 + 328), (sub_244D170B4((uint64_t *)v17, v11, *(uint64_t **)(a1 + 320), v11) & 0x80000000) == 0)
       || (sub_244D1A72C((unint64_t *)v17, (unint64_t *)v17, (unint64_t *)v15, v11, a1 + 296),
           sub_244D441D4((char *)v17, (char *)v13, 8 * *(int *)(a1 + 328)))))
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return sub_244D2D49C(a1, a2, a3);
  }
}

uint64_t sub_244D3E0D4(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(unsigned int *)(a1 + 328);
  if ((int)v7 < 1)
  {
    BOOL v11 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    long long v9 = a2 + 18;
    do
    {
      uint64_t v10 = *v9++;
      v8 |= v10;
      --v7;
    }
    while (v7);
    BOOL v11 = v8 == 0;
  }
  if (v11)
  {
    sub_244D0B884(15, 0, 119, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/p224-64.c", 868);
    return 0;
  }
  else
  {
    uint64_t v13 = a2[19];
    *((void *)&v14 + 1) = v13;
    *(void *)&long long v14 = a2[18];
    v34.i64[0] = v14 & 0xFFFFFFFFFFFFFFLL;
    v34.i64[1] = (v14 >> 56) & 0xFFFFFFFFFFFFFFLL;
    *((void *)&v14 + 1) = a2[20];
    *(void *)&long long v14 = v13;
    uint64_t v15 = v14 >> 48;
    long long v16 = *((_OWORD *)a2 + 10);
    memset(v33, 0, sizeof(v33));
    memset(v32, 0, sizeof(v32));
    uint64_t v35 = v15 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v36 = (v16 >> 40) & 0xFFFFFFFFFFFFFFLL;
    int8x16_t v47 = 0u;
    long long v48 = 0u;
    memset(v46, 0, sizeof(v46));
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    sub_244D3F380((uint64_t)&v37, (unint64_t *)&v34);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)&v34, (unint64_t *)&v47);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)&v47);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)&v34, (unint64_t *)&v47);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)&v47);
    sub_244D3F438(v46, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)v46);
    sub_244D3F438(v46, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)v46);
    sub_244D3F438(v46, (unint64_t *)&v37);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)v46, (unint64_t *)&v47);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)&v47);
    sub_244D3F438(v46, (unint64_t *)&v37);
    uint64_t v17 = 5;
    do
    {
      sub_244D3F380((uint64_t)&v37, (unint64_t *)v46);
      sub_244D3F438(v46, (unint64_t *)&v37);
      --v17;
    }
    while (v17);
    memset(v45, 0, sizeof(v45));
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)v46, (unint64_t *)&v47);
    sub_244D3F438(v46, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)v46);
    sub_244D3F438(v45, (unint64_t *)&v37);
    uint64_t v18 = 11;
    do
    {
      sub_244D3F380((uint64_t)&v37, (unint64_t *)v45);
      sub_244D3F438(v45, (unint64_t *)&v37);
      --v18;
    }
    while (v18);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)v45, (unint64_t *)v46);
    sub_244D3F438(v46, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)v46);
    sub_244D3F438(v45, (unint64_t *)&v37);
    uint64_t v19 = 23;
    do
    {
      sub_244D3F380((uint64_t)&v37, (unint64_t *)v45);
      sub_244D3F438(v45, (unint64_t *)&v37);
      --v19;
    }
    while (v19);
    memset(v44, 0, sizeof(v44));
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)v45, (unint64_t *)v46);
    sub_244D3F438(v45, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)v45);
    sub_244D3F438(v44, (unint64_t *)&v37);
    uint64_t v20 = 47;
    do
    {
      sub_244D3F380((uint64_t)&v37, (unint64_t *)v44);
      sub_244D3F438(v44, (unint64_t *)&v37);
      --v20;
    }
    while (v20);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)v45, (unint64_t *)v44);
    sub_244D3F438(v45, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)v45);
    sub_244D3F438(v44, (unint64_t *)&v37);
    uint64_t v21 = 23;
    do
    {
      sub_244D3F380((uint64_t)&v37, (unint64_t *)v44);
      sub_244D3F438(v44, (unint64_t *)&v37);
      --v21;
    }
    while (v21);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)v46, (unint64_t *)v44);
    sub_244D3F438(v46, (unint64_t *)&v37);
    uint64_t v22 = 6;
    do
    {
      sub_244D3F380((uint64_t)&v37, (unint64_t *)v46);
      sub_244D3F438(v46, (unint64_t *)&v37);
      --v22;
    }
    while (v22);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)v46, (unint64_t *)&v47);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)&v37, (unint64_t *)&v47);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)&v47, (unint64_t *)&v34);
    sub_244D3F438(&v47, (unint64_t *)&v37);
    uint64_t v23 = 97;
    do
    {
      sub_244D3F380((uint64_t)&v37, (unint64_t *)&v47);
      sub_244D3F438(&v47, (unint64_t *)&v37);
      --v23;
    }
    while (v23);
    sub_244D3F56C((uint64_t)&v37, (unint64_t *)&v47, (unint64_t *)v45);
    sub_244D3F438(v33, (unint64_t *)&v37);
    sub_244D3F380((uint64_t)v32, (unint64_t *)v33);
    sub_244D3F438(&v34, (unint64_t *)v32);
    if (a3)
    {
      uint64_t v24 = a2[1];
      *((void *)&v25 + 1) = v24;
      *(void *)&long long v25 = *a2;
      *(void *)&long long v37 = *a2 & 0xFFFFFFFFFFFFFFLL;
      *((void *)&v37 + 1) = (v25 >> 56) & 0xFFFFFFFFFFFFFFLL;
      *((void *)&v25 + 1) = a2[2];
      *(void *)&long long v25 = v24;
      uint64_t v26 = v25 >> 48;
      long long v27 = *((_OWORD *)a2 + 1);
      int8x16_t v47 = 0u;
      long long v48 = 0u;
      *(void *)&long long v38 = v26 & 0xFFFFFFFFFFFFFFLL;
      *((void *)&v38 + 1) = (v27 >> 40) & 0xFFFFFFFFFFFFFFLL;
      sub_244D3F56C((uint64_t)v32, (unint64_t *)&v37, (unint64_t *)&v34);
      sub_244D3F438(&v47, (unint64_t *)v32);
      sub_244D3F6A4(a3, &v47);
    }
    if (a4)
    {
      int8x16_t v47 = 0u;
      long long v48 = 0u;
      uint64_t v28 = a2[10];
      *((void *)&v29 + 1) = v28;
      *(void *)&long long v29 = a2[9];
      *(void *)&long long v37 = v29 & 0xFFFFFFFFFFFFFFLL;
      *((void *)&v37 + 1) = (v29 >> 56) & 0xFFFFFFFFFFFFFFLL;
      *((void *)&v29 + 1) = a2[11];
      *(void *)&long long v29 = v28;
      uint64_t v30 = (v29 >> 48) & 0xFFFFFFFFFFFFFFLL;
      long long v31 = *(_OWORD *)(a2 + 11);
      *(void *)&long long v38 = v30;
      *((void *)&v38 + 1) = (v31 >> 40) & 0xFFFFFFFFFFFFFFLL;
      sub_244D3F56C((uint64_t)v32, (unint64_t *)&v34, (unint64_t *)v33);
      sub_244D3F438(&v34, (unint64_t *)v32);
      sub_244D3F56C((uint64_t)v32, (unint64_t *)&v37, (unint64_t *)&v34);
      sub_244D3F438(&v47, (unint64_t *)v32);
      sub_244D3F6A4(a4, &v47);
    }
    return 1;
  }
}

uint64_t *sub_244D3E638(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  v32[4] = *MEMORY[0x263EF8340];
  uint64_t v5 = a3[1];
  *((void *)&v6 + 1) = v5;
  *(void *)&long long v6 = *a3;
  v32[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v32[1] = (v6 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v6 + 1) = a3[2];
  *(void *)&long long v6 = v5;
  uint64_t v7 = (v6 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v8 = *((_OWORD *)a3 + 1);
  v32[2] = v7;
  v32[3] = (v8 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v9 = a3[10];
  *((void *)&v8 + 1) = v9;
  *(void *)&long long v8 = a3[9];
  v29.i64[0] = v8 & 0xFFFFFFFFFFFFFFLL;
  v29.i64[1] = (v8 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v8 + 1) = a3[11];
  *(void *)&long long v8 = v9;
  uint64_t v10 = (v8 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v11 = *(_OWORD *)(a3 + 11);
  uint64_t v30 = v10;
  uint64_t v31 = (v11 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v12 = a3[19];
  *((void *)&v11 + 1) = v12;
  *(void *)&long long v11 = a3[18];
  v28[0] = v11 & 0xFFFFFFFFFFFFFFLL;
  v28[1] = (v11 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v11 + 1) = a3[20];
  *(void *)&long long v11 = v12;
  uint64_t v13 = (v11 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v14 = *((_OWORD *)a3 + 10);
  v28[2] = v13;
  void v28[3] = (v14 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v15 = a4[1];
  *((void *)&v14 + 1) = v15;
  *(void *)&long long v14 = *a4;
  v27[0] = *a4 & 0xFFFFFFFFFFFFFFLL;
  v27[1] = (v14 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v14 + 1) = a4[2];
  *(void *)&long long v14 = v15;
  unint64_t v16 = (v14 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v17 = *((_OWORD *)a4 + 1);
  v27[2] = v16;
  v27[3] = (v17 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v18 = a4[10];
  *((void *)&v17 + 1) = v18;
  *(void *)&long long v17 = a4[9];
  v26[0] = v17 & 0xFFFFFFFFFFFFFFLL;
  v26[1] = (v17 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v17 + 1) = a4[11];
  *(void *)&long long v17 = v18;
  unint64_t v19 = (v17 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v20 = *(_OWORD *)(a4 + 11);
  v26[2] = v19;
  v26[3] = (v20 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v21 = a4[19];
  *((void *)&v20 + 1) = v21;
  *(void *)&long long v20 = a4[18];
  v25[0] = v20 & 0xFFFFFFFFFFFFFFLL;
  v25[1] = (v20 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v20 + 1) = a4[20];
  *(void *)&long long v20 = v21;
  unint64_t v22 = (v20 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v23 = *((_OWORD *)a4 + 10);
  v25[2] = v22;
  v25[3] = (v23 >> 40) & 0xFFFFFFFFFFFFFFLL;
  sub_244D3F73C((uint64_t)v32, (uint64_t)&v29, (uint64_t)v28, (uint64_t)v32, &v29, (uint64_t)v28, 0, v27, v26, v25);
  sub_244D3F6A4(a2, v32);
  sub_244D3F6A4(a2 + 9, &v29);
  return sub_244D3F6A4(a2 + 18, v28);
}

uint64_t *sub_244D3E7E8(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v4 = a3[1];
  *((void *)&v5 + 1) = v4;
  *(void *)&long long v5 = *a3;
  v21.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v21.i64[1] = (v5 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v5 + 1) = a3[2];
  *(void *)&long long v5 = v4;
  uint64_t v6 = (v5 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v7 = *((_OWORD *)a3 + 1);
  uint64_t v22 = v6;
  uint64_t v23 = (v7 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v8 = a3[10];
  *((void *)&v7 + 1) = v8;
  *(void *)&long long v7 = a3[9];
  v18.i64[0] = v7 & 0xFFFFFFFFFFFFFFLL;
  v18.i64[1] = (v7 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v7 + 1) = a3[11];
  *(void *)&long long v7 = v8;
  uint64_t v9 = (v7 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v10 = *(_OWORD *)(a3 + 11);
  uint64_t v19 = v9;
  uint64_t v20 = (v10 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v11 = a3[19];
  *((void *)&v10 + 1) = v11;
  *(void *)&long long v10 = a3[18];
  v15.i64[0] = v10 & 0xFFFFFFFFFFFFFFLL;
  v15.i64[1] = (v10 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v10 + 1) = a3[20];
  *(void *)&long long v10 = v11;
  uint64_t v12 = (v10 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v13 = *((_OWORD *)a3 + 10);
  uint64_t v16 = v12;
  uint64_t v17 = (v13 >> 40) & 0xFFFFFFFFFFFFFFLL;
  sub_244D3FEC0(&v21, (int8x16_t *)&v18, (int8x16_t *)&v15, (unint64_t *)&v21, &v18, &v15);
  sub_244D3F6A4(a2, &v21);
  sub_244D3F6A4(a2 + 9, &v18);
  return sub_244D3F6A4(a2 + 18, &v15);
}

uint64_t *sub_244D3E900(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  sub_244D402DC((uint64_t)v27, a3);
  int8x16_t v21 = 0u;
  long long v22 = 0u;
  int64x2_t v23 = 0u;
  long long v24 = 0u;
  int v5 = 1;
  int64x2_t v25 = 0u;
  long long v26 = 0u;
  unint64_t v6 = 220;
  do
  {
    if (!v5) {
      sub_244D3FEC0(&v21, (int8x16_t *)&v23, (int8x16_t *)&v25, (unint64_t *)&v21, &v23, &v25);
    }
    if (-858993459 * v6 < 0x33333334)
    {
      if (v6 <= 0xDB) {
        uint64_t v8 = (*(void *)(a4 + (((v6 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 + 4)) & 1;
      }
      else {
        uint64_t v8 = 0;
      }
      unint64_t v7 = v6 - 1;
      if (v6 - 1 <= 0xDF) {
        uint64_t v9 = (*(void *)(a4 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1;
      }
      else {
        uint64_t v9 = 0;
      }
      unint64_t v10 = (2 * ((*(void *)(a4 + ((v6 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v6) & 1)) | v9 | (4
                                                                                             * ((*(void *)(a4 + (((v6 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 + 1)) & 1)) & 0xFFFFFFFFFFFFFFF7 | (8 * ((*(void *)(a4 + (((v6 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 + 2)) & 1)) | (32 * v8) | (16 * ((*(void *)(a4 + (((v6 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 + 3)) & 1));
      uint64_t v11 = -v8;
      unint64_t v12 = (v10 ^ 0x3F) & -v8 | v10 & (v8 + 0x7FFFFFFFFFFFFFFFLL);
      sub_244D40458((v12 & 1) + (v12 >> 1), 17, (uint64_t)v27, v17);
      sub_244D404BC(v20, v18);
      for (uint64_t i = 0; i != 2; ++i)
      {
        long long v14 = &v20[i];
        if ((v11 & 1) == 0) {
          long long v14 = (int8x16_t *)&v17[i + 2];
        }
        v17[i + 2] = *v14;
      }
      if (v5)
      {
        int v5 = 0;
        int64x2_t v23 = (int64x2_t)v18[0];
        long long v24 = v18[1];
        int64x2_t v25 = (int64x2_t)v19[0];
        long long v26 = v19[1];
        int8x16_t v21 = (int8x16_t)v17[0];
        long long v22 = v17[1];
      }
      else
      {
        sub_244D3F73C((uint64_t)&v21, (uint64_t)&v23, (uint64_t)&v25, (uint64_t)&v21, &v23, (uint64_t)&v25, 0, (unint64_t *)v17, (unint64_t *)v18, (unint64_t *)v19);
      }
    }
    else
    {
      unint64_t v7 = v6 - 1;
    }
    unint64_t v6 = v7;
  }
  while (v7 < 0xDD);
  sub_244D3F6A4(a2, &v21);
  sub_244D3F6A4(a2 + 9, &v23);
  return sub_244D3F6A4(a2 + 18, &v25);
}

uint64_t *sub_244D3EBB0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  char v5 = 0;
  uint64_t v18 = *MEMORY[0x263EF8340];
  int8x16_t v12 = 0u;
  long long v13 = 0u;
  int64x2_t v14 = 0u;
  long long v15 = 0u;
  int64x2_t v16 = 0u;
  long long v17 = 0u;
  unint64_t v6 = 111;
  do
  {
    if (v5) {
      sub_244D3FEC0(&v12, (int8x16_t *)&v14, (int8x16_t *)&v16, (unint64_t *)&v12, &v14, &v16);
    }
    sub_244D40458((8 * ((*(void *)(a3 + (((v6 + 112) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 - 80)) & 1)) | (4 * ((*(void *)(a3 + (((v6 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 - 72)) & 1)) | (2 * ((*(void *)(a3 + ((v6 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v6) & 1)) | (*(void *)(a3 + (((v6 - 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 - 56)) & 1, 16, (uint64_t)&unk_244EB8898, v9);
    if (v5)
    {
      sub_244D3F73C((uint64_t)&v12, (uint64_t)&v14, (uint64_t)&v16, (uint64_t)&v12, &v14, (uint64_t)&v16, 1, (unint64_t *)v9, (unint64_t *)v10, (unint64_t *)v11);
    }
    else
    {
      int64x2_t v14 = (int64x2_t)v10[0];
      long long v15 = v10[1];
      int64x2_t v16 = (int64x2_t)v11[0];
      long long v17 = v11[1];
      int8x16_t v12 = (int8x16_t)v9[0];
      long long v13 = v9[1];
    }
    sub_244D40458((8 * ((*(void *)(a3 + (((v6 + 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 + 84)) & 1)) | (4 * ((*(void *)(a3 + (((v6 + 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 + 28)) & 1)) | (2 * ((*(void *)(a3 + (((v6 - 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 - 28)) & 1)) | (*(void *)(a3 + (((v6 - 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v6 - 84)) & 1, 16, (uint64_t)&unk_244EB8298, v9);
    char v5 = 1;
    sub_244D3F73C((uint64_t)&v12, (uint64_t)&v14, (uint64_t)&v16, (uint64_t)&v12, &v14, (uint64_t)&v16, 1, (unint64_t *)v9, (unint64_t *)v10, (unint64_t *)v11);
    unint64_t v7 = v6 - 85;
    --v6;
  }
  while (v7 < 0x1C);
  sub_244D3F6A4(a2, &v12);
  sub_244D3F6A4(a2 + 9, &v14);
  return sub_244D3F6A4(a2 + 18, &v16);
}

uint64_t *sub_244D3EE14(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  sub_244D402DC((uint64_t)v35, a4);
  int8x16_t v29 = 0u;
  int64x2_t v30 = 0u;
  int64x2_t v31 = 0u;
  int64x2_t v32 = 0u;
  int64x2_t v33 = 0u;
  int64x2_t v34 = 0u;
  int v7 = 1;
  unint64_t v8 = 220;
  do
  {
    if (!v7) {
      sub_244D3FEC0(&v29, (int8x16_t *)&v31, (int8x16_t *)&v33, (unint64_t *)&v29, &v31, &v33);
    }
    if (v8 <= 0x1B)
    {
      uint64_t v9 = (unint64_t *)((char *)&unk_244EB8298
                              + 96
                              * ((8
                                * ((*(void *)(a3 + (((v8 + 196) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 - 60)) & 1)) | (4 * ((*(void *)(a3 + (((v8 + 140) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 - 116)) & 1)) | (2 * ((*(void *)(a3 + (((v8 + 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 84)) & 1)) | (*(void *)(a3 + (((v8 + 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 28)) & 1));
      sub_244D3F73C((uint64_t)&v29, (uint64_t)&v31, (uint64_t)&v33, (uint64_t)&v29, &v31, (uint64_t)&v33, 1, v9 + 192, v9 + 196, v9 + 200);
      unint64_t v10 = (unint64_t *)((char *)&unk_244EB8298
                               + 96
                               * ((8
                                 * ((*(void *)(a3 + (((v8 + 168) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 - 88)) & 1)) | (4 * ((*(void *)(a3 + (((v8 + 112) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 112)) & 1)) | (2 * ((*(void *)(a3 + (((v8 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 56)) & 1)) | (*(void *)(a3 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v8) & 1));
      sub_244D3F73C((uint64_t)&v29, (uint64_t)&v31, (uint64_t)&v33, (uint64_t)&v29, &v31, (uint64_t)&v33, 1, v10, v10 + 4, v10 + 8);
    }
    if (-858993459 * v8 < 0x33333334)
    {
      if (v8 <= 0xDB) {
        uint64_t v12 = (*(void *)(a5 + (((v8 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 4)) & 1;
      }
      else {
        uint64_t v12 = 0;
      }
      unint64_t v11 = v8 - 1;
      if (v8 - 1 <= 0xDF) {
        uint64_t v13 = (*(void *)(a5 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v11) & 1;
      }
      else {
        uint64_t v13 = 0;
      }
      unint64_t v14 = (2 * ((*(void *)(a5 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v8) & 1)) | v13 | (4
                                                                                              * ((*(void *)(a5 + (((v8 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 1)) & 1)) & 0xFFFFFFFFFFFFFFF7 | (8 * ((*(void *)(a5 + (((v8 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 2)) & 1)) | (32 * v12) | (16 * ((*(void *)(a5 + (((v8 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v8 + 3)) & 1));
      uint64_t v15 = v12 + 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v16 = -v12;
      long long v17 = (int64x2_t *)&v35[6 * (((v14 ^ 0x3F) & v16 | v14 & v15) & 1) + 6 * (((v14 ^ 0x3F) & v16 | v14 & v15) >> 1)];
      int64x2_t v18 = v17[3];
      int64x2_t v25 = v17[2];
      int64x2_t v26 = v18;
      int64x2_t v19 = v17[5];
      int64x2_t v27 = v17[4];
      int64x2_t v28 = v19;
      int64x2_t v20 = v17[1];
      int8x16_t v23 = *(int8x16_t *)v17;
      int64x2_t v24 = v20;
      if (v16) {
        sub_244D404BC((int8x16_t *)&v25, &v25);
      }
      if (v7)
      {
        int v7 = 0;
        int64x2_t v31 = v25;
        int64x2_t v32 = v26;
        int64x2_t v33 = v27;
        int64x2_t v34 = v28;
        int8x16_t v29 = v23;
        int64x2_t v30 = v24;
      }
      else
      {
        sub_244D3F73C((uint64_t)&v29, (uint64_t)&v31, (uint64_t)&v33, (uint64_t)&v29, &v31, (uint64_t)&v33, 0, (unint64_t *)&v23, (unint64_t *)&v25, (unint64_t *)&v27);
      }
    }
    else
    {
      unint64_t v11 = v8 - 1;
    }
    unint64_t v8 = v11;
  }
  while (v11 < 0xDD);
  sub_244D3F6A4(a2, &v29);
  sub_244D3F6A4(a2 + 9, &v31);
  return sub_244D3F6A4(a2 + 18, &v33);
}

uint64_t *sub_244D3F1E0(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  memset(v13, 0, sizeof(v13));
  uint64_t v5 = a3[1];
  *((void *)&v6 + 1) = v5;
  *(void *)&long long v6 = *a3;
  v15.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v15.i64[1] = (v6 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v6 + 1) = a3[2];
  *(void *)&long long v6 = v5;
  uint64_t v7 = (v6 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v8 = *((_OWORD *)a3 + 1);
  uint64_t v16 = v7;
  uint64_t v17 = (v8 >> 40) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v9 = a4[1];
  *((void *)&v8 + 1) = v9;
  *(void *)&long long v8 = *a4;
  v14[0] = *a4 & 0xFFFFFFFFFFFFFFLL;
  v14[1] = (v8 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v8 + 1) = a4[2];
  *(void *)&long long v8 = v9;
  unint64_t v10 = (v8 >> 48) & 0xFFFFFFFFFFFFFFLL;
  long long v11 = *((_OWORD *)a4 + 1);
  v14[2] = v10;
  v14[3] = (v11 >> 40) & 0xFFFFFFFFFFFFFFLL;
  sub_244D3F56C((uint64_t)v13, (unint64_t *)&v15, v14);
  sub_244D3F438(&v15, (unint64_t *)v13);
  return sub_244D3F6A4(a2, &v15);
}

uint64_t *sub_244D3F2C8(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v4 = a3[1];
  *((void *)&v5 + 1) = v4;
  *(void *)&long long v5 = *a3;
  v10.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v10.i64[1] = (v5 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((void *)&v5 + 1) = a3[2];
  *(void *)&long long v5 = v4;
  uint64_t v6 = v5 >> 48;
  long long v7 = *((_OWORD *)a3 + 1);
  uint64_t v11 = v6 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v12 = (v7 >> 40) & 0xFFFFFFFFFFFFFFLL;
  memset(v9, 0, sizeof(v9));
  sub_244D3F380((uint64_t)v9, (unint64_t *)&v10);
  sub_244D3F438(&v10, (unint64_t *)v9);
  return sub_244D3F6A4(a2, &v10);
}

uint64_t sub_244D3F380(uint64_t result, unint64_t *a2)
{
  uint64_t v2 = 2 * *a2;
  uint64_t v3 = 2 * a2[1];
  uint64_t v4 = 2 * a2[2];
  *(_OWORD *)double result = *a2 * (unsigned __int128)*a2;
  uint64_t v5 = (*a2 * (unsigned __int128)(unint64_t)v3) >> 64;
  *(void *)(result + 16) = *a2 * v3;
  *(void *)(result + 24) = v5;
  *(_OWORD *)(result + 32) = a2[1] * (unsigned __int128)a2[1] + *a2 * (unsigned __int128)(unint64_t)v4;
  *(_OWORD *)(result + 48) = a2[1] * (unsigned __int128)(unint64_t)v4
                           + a2[3] * (unsigned __int128)(unint64_t)v2;
  *(_OWORD *)(result + 64) = a2[2] * (unsigned __int128)a2[2] + a2[3] * (unsigned __int128)(unint64_t)v3;
  *(_OWORD *)(result + 80) = a2[3] * (unsigned __int128)(unint64_t)v4;
  *(_OWORD *)(result + 96) = a2[3] * (unsigned __int128)a2[3];
  return result;
}

int8x16_t sub_244D3F438(int8x16_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v2 = a2[1];
  unint64_t v5 = a2[2];
  unint64_t v4 = a2[3];
  unint64_t v7 = a2[6];
  unint64_t v6 = a2[7];
  unsigned long long v8 = *((_OWORD *)a2 + 6);
  unsigned long long v9 = (v8 >> 16) + *((_OWORD *)a2 + 4);
  unint64_t v10 = (unint64_t)(unsigned __int16)v8 << 40;
  BOOL v11 = __CFADD__(v10, v7);
  unint64_t v12 = v10 + v7;
  if (v11) {
    ++v6;
  }
  unint64_t v13 = (*((_OWORD *)a2 + 2) - *((_OWORD *)a2 + 6)) >> 64;
  unint64_t v14 = a2[4] - a2[12];
  unint64_t v16 = a2[10];
  unint64_t v15 = a2[11];
  unint64_t v17 = (unint64_t)(unsigned __int16)v16 << 40;
  BOOL v11 = __CFADD__(v14, v17);
  unint64_t v18 = v14 + v17;
  if (v11) {
    ++v13;
  }
  *((void *)&v19 + 1) = v15;
  *(void *)&unsigned long long v19 = v16;
  unsigned long long v20 = __PAIR128__(v6, v12) + (v19 >> 16);
  unsigned long long v21 = __PAIR128__(v13, v18) + (v9 >> 16);
  unint64_t v23 = v5 - v16;
  uint64_t v22 = (__PAIR128__(v4, v5) - __PAIR128__(v15, v16)) >> 64;
  unint64_t v24 = (unint64_t)(unsigned __int16)v9 << 40;
  unint64_t v25 = v5 - v16 + v24;
  if (__CFADD__(v23, v24)) {
    ++v22;
  }
  *((void *)&v26 + 1) = *((void *)&v21 + 1) + 0x7FFFFFFFFFFFFF80;
  *(void *)&unsigned long long v26 = v21;
  long long v27 = v20 + (v26 >> 56);
  uint64_t v28 = (v27 >> 16) & 0xFFFF0000000000;
  BOOL v11 = __CFADD__(v25, v28);
  uint64_t v29 = v25 + v28;
  if (v11) {
    ++v22;
  }
  uint64_t v30 = (v21 & 0xFFFFFFFFFFFFFFLL) + (*((void *)&v27 + 1) >> 8);
  signed long long v31 = __PAIR128__(v2, v3) - (v9 + ((unsigned __int128)v27 >> 56)) + __PAIR128__(0x8000000000000000, 0x8000);
  signed long long v32 = __PAIR128__(HIBYTE(*((void *)&v31 + 1)) + (unint64_t)__CFADD__(v29, (unint64_t)(v31 >> 56)) + v22, v29 + (unint64_t)(v31 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
  unint64_t v33 = (unint64_t)((__PAIR128__(HIBYTE(*((void *)&v31 + 1))+ (unint64_t)__CFADD__(v29, (unint64_t)(v31 >> 56))+ v22, v29 + (unint64_t)(v31 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56;
  uint64_t v34 = v32 >> 56;
  BOOL v11 = __CFADD__(v30, v34);
  uint64_t v35 = v30 + v34;
  if (v11) {
    ++v33;
  }
  v36.i64[0] = v31;
  v36.i64[1] = v32;
  v37.i64[0] = 0xFFFFFFFFFFFFFFLL;
  v37.i64[1] = 0xFFFFFFFFFFFFFFLL;
  int8x16_t result = vandq_s8(v36, v37);
  *a1 = result;
  *((void *)&v39 + 1) = v33;
  *(void *)&long long v39 = v35;
  a1[1].i64[0] = v35 & 0xFFFFFFFFFFFFFFLL;
  a1[1].i64[1] = (v39 >> 56) + (v27 & 0xFFFFFFFFFFFFFFLL);
  return result;
}

uint64_t sub_244D3F56C(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  uint64_t v3 = (*a3 * (unsigned __int128)*a2) >> 64;
  *(void *)int8x16_t result = *a3 * *a2;
  *(void *)(result + 8) = v3;
  *(_OWORD *)(result + 16) = *a3 * (unsigned __int128)a2[1] + a3[1] * (unsigned __int128)*a2;
  *(_OWORD *)(result + 32) = a3[1] * (unsigned __int128)a2[1]
                           + a3[2] * (unsigned __int128)*a2
                           + *a3 * (unsigned __int128)a2[2];
  *(_OWORD *)(result + 48) = a3[2] * (unsigned __int128)a2[1]
                           + a3[3] * (unsigned __int128)*a2
                           + a3[1] * (unsigned __int128)a2[2]
                           + *a3 * (unsigned __int128)a2[3];
  *(_OWORD *)(result + 64) = a3[2] * (unsigned __int128)a2[2]
                           + a3[3] * (unsigned __int128)a2[1]
                           + a3[1] * (unsigned __int128)a2[3];
  *(_OWORD *)(result + 80) = a3[2] * (unsigned __int128)a2[3] + a3[3] * (unsigned __int128)a2[2];
  *(_OWORD *)(result + 96) = a3[3] * (unsigned __int128)a2[3];
  return result;
}

uint64_t *sub_244D3F6A4(uint64_t *result, void *a2)
{
  uint64_t v2 = a2[1];
  uint64_t v3 = a2[2];
  unint64_t v4 = a2[3];
  unint64_t v5 = *a2 - HIBYTE(v4);
  uint64_t v6 = v2 + (HIBYTE(v4) << 40);
  uint64_t v7 = (((v3 & v4 & (v2 | 0xFFFFFFFFFFLL)) + 1) | ((*a2 + (v2 & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  BOOL v8 = v7 != 0;
  uint64_t v9 = v7 - 1;
  uint64_t v10 = v8;
  uint64_t v11 = v10 << 63 >> 63;
  uint64_t v12 = v4 & v11;
  uint64_t v13 = v3 & v11;
  uint64_t v14 = 0xFFFFFFFFFFLL;
  if (v8) {
    uint64_t v14 = -1;
  }
  uint64_t v15 = v5 + (v9 >> 63);
  uint64_t v16 = v14 & v6;
  unint64_t v17 = v15 + ((unint64_t)v15 >> 63 << 56);
  uint64_t v18 = v16 + (v15 >> 63);
  uint64_t v19 = v13 + (v18 >> 56);
  *int8x16_t result = v17 | (v18 << 56);
  result[1] = ((unint64_t)v18 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v19 << 48);
  result[2] = ((unint64_t)v19 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)(v12
                                                                                 + (v19 >> 56)) << 40);
  result[3] = ((v12 & 0xFFFFFFFFFFFFFFuLL) + (v19 >> 56)) >> 24;
  return result;
}

double sub_244D3F73C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64x2_t *a5, uint64_t a6, int a7, unint64_t *a8, unint64_t *a9, unint64_t *a10)
{
  uint64_t v95 = *MEMORY[0x263EF8340];
  int8x16_t v91 = 0u;
  long long v92 = 0u;
  int8x16_t v88 = 0u;
  long long v89 = 0u;
  int8x16_t v82 = 0u;
  long long v83 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  unsigned long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  unsigned long long v66 = 0u;
  unsigned long long v67 = 0u;
  if (a7)
  {
    uint64_t v15 = a5->i64[0];
    uint64_t v14 = a5->i64[1];
    v88.i64[0] = a5->i64[0];
    v88.i64[1] = v14;
    uint64_t v17 = a5[1].i64[0];
    uint64_t v16 = a5[1].i64[1];
    *(void *)&long long v89 = v17;
    *((void *)&v89 + 1) = v16;
    int8x16_t v61 = *(int8x16_t *)a4;
    v91.i64[0] = *(void *)a4;
    v91.i64[1] = v61.i64[1];
    long long v63 = *(_OWORD *)(a4 + 16);
    long long v92 = v63;
  }
  else
  {
    sub_244D3F380((uint64_t)&v73, a10);
    sub_244D3F438(&v91, (unint64_t *)&v73);
    sub_244D3F56C((uint64_t)&v73, (unint64_t *)&v91, a10);
    sub_244D3F438(&v88, (unint64_t *)&v73);
    sub_244D3F56C((uint64_t)&v66, (unint64_t *)&v88, (unint64_t *)a5);
    sub_244D3F438(&v88, (unint64_t *)&v66);
    sub_244D3F56C((uint64_t)&v66, (unint64_t *)&v91, (unint64_t *)a4);
    sub_244D3F438(&v91, (unint64_t *)&v66);
    uint64_t v14 = v88.i64[1];
    uint64_t v15 = v88.i64[0];
    uint64_t v16 = *((void *)&v89 + 1);
    uint64_t v17 = v89;
    int8x16_t v61 = v91;
    long long v63 = v92;
  }
  int8x16_t v93 = 0u;
  long long v94 = 0u;
  memset(v90, 0, sizeof(v90));
  sub_244D3F380((uint64_t)&v73, (unint64_t *)a6);
  sub_244D3F438(&v93, (unint64_t *)&v73);
  sub_244D3F56C((uint64_t)&v73, (unint64_t *)&v93, (unint64_t *)a6);
  sub_244D3F438(v90, (unint64_t *)&v73);
  sub_244D3F56C((uint64_t)&v73, (unint64_t *)v90, a9);
  unsigned long long v73 = v73 - (unint64_t)v15 + __PAIR128__(1, 256);
  unint64_t v18 = (v74 - (unsigned __int128)(unint64_t)v14) >> 64;
  if ((unint64_t)(v74 - v14) >= 0x1000000000100) {
    ++v18;
  }
  *(void *)&long long v74 = v74 - v14 - 0x1000000000100;
  *((void *)&v74 + 1) = v18;
  unint64_t v19 = (v75 - (unsigned __int128)(unint64_t)v17) >> 64;
  if ((unint64_t)(v75 - v17) >= 0x100) {
    ++v19;
  }
  *(void *)&long long v75 = v75 - v17 - 256;
  *((void *)&v75 + 1) = v19;
  unint64_t v20 = (v76 - (unsigned __int128)(unint64_t)v16) >> 64;
  if ((unint64_t)(v76 - v16) >= 0x100) {
    ++v20;
  }
  *(void *)&long long v76 = v76 - v16 - 256;
  *((void *)&v76 + 1) = v20;
  sub_244D3F438(v90, (unint64_t *)&v73);
  sub_244D3F56C((uint64_t)&v73, (unint64_t *)&v93, a8);
  unsigned long long v73 = v73 - v61.u64[0] + __PAIR128__(1, 256);
  unint64_t v21 = (v74 - (unsigned __int128)v61.u64[1]) >> 64;
  if ((uint64_t)v74 - v61.i64[1] >= 0x1000000000100uLL) {
    ++v21;
  }
  *(void *)&long long v74 = v74 - v61.i64[1] - 0x1000000000100;
  *((void *)&v74 + 1) = v21;
  unint64_t v22 = (v75 - (unsigned __int128)(unint64_t)v63) >> 64;
  if ((void)v75 - (void)v63 >= 0x100uLL) {
    ++v22;
  }
  *(void *)&long long v75 = v75 - v63 - 256;
  *((void *)&v75 + 1) = v22;
  unint64_t v23 = (v76 - (unsigned __int128)*((unint64_t *)&v63 + 1)) >> 64;
  if ((void)v76 - *((void *)&v63 + 1) >= 0x100uLL) {
    ++v23;
  }
  *(void *)&long long v76 = v76 - *((void *)&v63 + 1) - 256;
  *((void *)&v76 + 1) = v23;
  sub_244D3F438(&v93, (unint64_t *)&v73);
  unint64_t v24 = sub_244D3FE5C(&v93);
  unint64_t v25 = sub_244D3FE5C(v90);
  unint64_t v26 = sub_244D3FE5C((void *)a6);
  unint64_t v27 = sub_244D3FE5C(a10);
  if ((v25 & v24 & ~v26 & (v27 ^ 1)) != 0)
  {
    return sub_244D3FEC0((int8x16_t *)a1, (int8x16_t *)a2, (int8x16_t *)a3, (unint64_t *)a4, a5, (int64x2_t *)a6);
  }
  else
  {
    int8x16_t v86 = 0u;
    long long v87 = 0u;
    unint64_t v64 = v26;
    unint64_t v65 = v27;
    if (a7)
    {
      long long v29 = *(_OWORD *)(a6 + 16);
      int8x16_t v86 = *(int8x16_t *)a6;
      long long v87 = v29;
    }
    else
    {
      sub_244D3F56C((uint64_t)&v73, (unint64_t *)a6, a10);
      sub_244D3F438(&v86, (unint64_t *)&v73);
    }
    int8x16_t v84 = 0u;
    long long v85 = 0u;
    int8x16_t v80 = 0u;
    long long v81 = 0u;
    sub_244D3F56C((uint64_t)&v73, (unint64_t *)&v93, (unint64_t *)&v86);
    sub_244D3F438(&v80, (unint64_t *)&v73);
    int8x16_t v86 = v93;
    long long v87 = v94;
    sub_244D3F380((uint64_t)&v73, (unint64_t *)&v93);
    sub_244D3F438(&v93, (unint64_t *)&v73);
    sub_244D3F56C((uint64_t)&v73, (unint64_t *)&v93, (unint64_t *)&v86);
    sub_244D3F438(&v86, (unint64_t *)&v73);
    sub_244D3F56C((uint64_t)&v73, (unint64_t *)&v91, (unint64_t *)&v93);
    sub_244D3F438(&v91, (unint64_t *)&v73);
    sub_244D3F56C((uint64_t)&v73, (unint64_t *)&v88, (unint64_t *)&v86);
    sub_244D3F380((uint64_t)&v66, (unint64_t *)v90);
    int8x16_t v30 = v91;
    uint64_t v31 = *((void *)&v92 + 1);
    uint64_t v62 = v92;
    BOOL v32 = __CFADD__(v86.i64[0], 2 * v91.i64[0]);
    unsigned long long v66 = v66 - __PAIR128__(v32, v86.i64[0] + 2 * v91.i64[0]) + __PAIR128__(2, 512);
    BOOL v33 = __CFADD__(v86.i64[1], 2 * v91.i64[1]);
    unsigned long long v67 = v67 - __PAIR128__(v33, v86.i64[1] + 2 * v91.i64[1]) + __PAIR128__(1, 0xFFFDFFFFFFFFFE00);
    BOOL v34 = __CFADD__((void)v87, 2 * v92);
    long long v35 = v68 - __PAIR128__(v34, (uint64_t)v87 + 2 * (uint64_t)v92);
    *(void *)&long long v68 = v68 - (v87 + 2 * v92) - 512;
    *((void *)&v68 + 1) = ((unint64_t)v35 >= 0x200) + *((void *)&v35 + 1) + 1;
    BOOL v36 = __CFADD__(*((void *)&v87 + 1), 2 * *((void *)&v92 + 1));
    unint64_t v38 = v69 - (*((void *)&v87 + 1) + 2 * *((void *)&v92 + 1));
    uint64_t v37 = (v69 - __PAIR128__(v36, *((void *)&v87 + 1) + 2 * *((void *)&v92 + 1))) >> 64;
    *(void *)&long long v69 = v38 - 512;
    *((void *)&v69 + 1) = (v38 >= 0x200) + v37 + 1;
    sub_244D3F438(&v84, (unint64_t *)&v66);
    v91.i64[0] = v30.i64[0] - v84.i64[0] + 0x400000000000004;
    v91.i64[1] = v30.i64[1] - v84.i64[1] + 0x3FFFBFFFFFFFFFCLL;
    *(void *)&long long v92 = v62 - v85 + 0x3FFFFFFFFFFFFFCLL;
    *((void *)&v92 + 1) = v31 - *((void *)&v85 + 1) + 0x3FFFFFFFFFFFFFCLL;
    sub_244D3F56C((uint64_t)&v66, (unint64_t *)v90, (unint64_t *)&v91);
    uint64_t v39 = ((v66 - v73) >> 64) + 0x100000000000000;
    *(void *)&unsigned long long v66 = v66 - v73;
    *((void *)&v66 + 1) = v39;
    uint64_t v40 = ((v67 - v74) >> 64) + 0xFFFFFFFFFFFFFFLL;
    *(void *)&unsigned long long v67 = v67 - v74;
    *((void *)&v67 + 1) = v40;
    uint64_t v41 = ((unsigned __int128)(v68 - v75) >> 64) + 0xFFFFFFFFFFFFFFLL;
    *(void *)&long long v68 = v68 - v75;
    *((void *)&v68 + 1) = v41;
    uint64_t v42 = ((unsigned __int128)(v69 - v76) >> 64) + 0x100000000000000;
    *(void *)&long long v69 = v69 - v76;
    *((void *)&v69 + 1) = v42;
    uint64_t v43 = ((unsigned __int128)(v70 - v77) >> 64) + 0xFFFEFFFFFFFFFFLL;
    *(void *)&long long v70 = v70 - v77;
    *((void *)&v70 + 1) = v43;
    uint64_t v44 = ((unsigned __int128)(v71 - v78) >> 64) + 0xFFFFFFFFFFFFFFLL;
    *(void *)&long long v71 = v71 - v78;
    *((void *)&v71 + 1) = v44;
    uint64_t v45 = ((unsigned __int128)(v72 - v79) >> 64) + 0xFFFFFFFFFFFFFFLL;
    *(void *)&long long v72 = v72 - v79;
    *((void *)&v72 + 1) = v45;
    sub_244D3F438(&v82, (unint64_t *)&v66);
    uint64_t v46 = 0;
    int8x16_t v47 = (int8x16_t)vdupq_n_s64(-(uint64_t)v64);
    do
    {
      *(int8x16_t *)((char *)&v84 + v46 * 8) = vbslq_s8(v47, *(int8x16_t *)&a8[v46], *(int8x16_t *)((char *)&v84 + v46 * 8));
      v46 += 2;
    }
    while (v46 != 4);
    uint64_t v48 = 0;
    int8x16_t v49 = (int8x16_t)vdupq_n_s64(-(uint64_t)v65);
    do
    {
      *(int8x16_t *)((char *)&v84 + v48) = vbslq_s8(v49, *(int8x16_t *)(a4 + v48), *(int8x16_t *)((char *)&v84 + v48));
      v48 += 16;
    }
    while (v48 != 32);
    for (uint64_t i = 0; i != 4; i += 2)
      *(int8x16_t *)((char *)&v82 + i * 8) = vbslq_s8(v47, *(int8x16_t *)&a9[i], *(int8x16_t *)((char *)&v82 + i * 8));
    for (uint64_t j = 0; j != 2; ++j)
      *(int8x16_t *)((char *)&v82 + j * 16) = vbslq_s8(v49, (int8x16_t)a5[j], *(int8x16_t *)((char *)&v82 + j * 16));
    for (uint64_t k = 0; k != 4; k += 2)
      *(int8x16_t *)((char *)&v80 + k * 8) = vbslq_s8(v47, *(int8x16_t *)&a10[k], *(int8x16_t *)((char *)&v80 + k * 8));
    for (uint64_t m = 0; m != 32; m += 16)
      *(int8x16_t *)((char *)&v80 + m) = vbslq_s8(v49, *(int8x16_t *)(a6 + m), *(int8x16_t *)((char *)&v80 + m));
    long long v54 = v85;
    *(int8x16_t *)a1 = v84;
    *(_OWORD *)(a1 + 16) = v54;
    long long v55 = v83;
    *(int8x16_t *)a2 = v82;
    *(_OWORD *)(a2 + 16) = v55;
    double result = *(double *)v80.i64;
    long long v56 = v81;
    *(int8x16_t *)a3 = v80;
    *(_OWORD *)(a3 + 16) = v56;
  }
  return result;
}

unint64_t sub_244D3FE5C(void *a1)
{
  uint64_t v1 = a1[1];
  return (((v1 ^ 0xFFFF0000000000 | *a1 ^ 1 | a1[3] ^ 0xFFFFFFFFFFFFFFLL | a1[2] ^ 0xFFFFFFFFFFFFFFLL) - 1) | ((v1 | *a1 | a1[2] | a1[3]) - 1) | ((v1 ^ 0xFFFE0000000000 | *a1 ^ 2 | a1[3] ^ 0x1FFFFFFFFFFFFFFLL | a1[2] ^ 0xFFFFFFFFFFFFFFuLL) - 1)) >> 63;
}

double sub_244D3FEC0(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, int64x2_t *a5, int64x2_t *a6)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  unsigned long long v67 = 0u;
  long long v68 = 0u;
  unsigned long long v65 = 0u;
  unsigned long long v66 = 0u;
  long long v63 = 0u;
  unsigned long long v64 = 0u;
  unsigned long long v62 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  int8x16_t v53 = 0u;
  long long v50 = 0u;
  int8x16_t v51 = 0u;
  int8x16_t v49 = 0u;
  memset(v48, 0, sizeof(v48));
  unint64_t v9 = *a4;
  unint64_t v10 = a4[1];
  unint64_t v12 = a4[2];
  unint64_t v11 = a4[3];
  sub_244D3F380((uint64_t)&v62, (unint64_t *)a6);
  sub_244D3F438(&v53, (unint64_t *)&v62);
  sub_244D3F380((uint64_t)&v62, (unint64_t *)a5);
  sub_244D3F438(&v51, (unint64_t *)&v62);
  sub_244D3F56C((uint64_t)&v62, a4, (unint64_t *)&v51);
  sub_244D3F438(&v49, (unint64_t *)&v62);
  int8x16_t v13 = v53;
  v46.i64[0] = v9 + 0x400000000000004 - v53.i64[0];
  v46.i64[1] = v10 + 0x3FFFBFFFFFFFFFCLL - v53.i64[1];
  long long v14 = v54;
  v47.i64[0] = v12 - v54 + 0x3FFFFFFFFFFFFFCLL;
  v47.i64[1] = v11 - *((void *)&v54 + 1) + 0x3FFFFFFFFFFFFFCLL;
  v45[0] = 3 * (v53.i64[0] + v9);
  v45[1] = 3 * (v53.i64[1] + v10);
  int8x16_t v45[2] = 3 * (v54 + v12);
  _OWORD v45[3] = 3 * (*((void *)&v54 + 1) + v11);
  sub_244D3F56C((uint64_t)&v62, (unint64_t *)&v46, v45);
  sub_244D3F438(v48, (unint64_t *)&v62);
  sub_244D3F380((uint64_t)&v62, (unint64_t *)v48);
  int8x16_t v15 = v49;
  long long v16 = v50;
  unsigned long long v62 = v62 - (unint64_t)(8 * v49.i64[0]) + __PAIR128__(1, 256);
  unint64_t v18 = (v63 - (unsigned __int128)(unint64_t)(8 * v49.i64[1])) >> 64;
  uint64_t v17 = v63 - 8 * v49.i64[1];
  BOOL v19 = __CFADD__(v17, 0xFFFEFFFFFFFFFF00);
  uint64_t v20 = v17 - 0x1000000000100;
  if (v19) {
    ++v18;
  }
  *(void *)&long long v63 = v20;
  *((void *)&v63 + 1) = v18;
  unint64_t v22 = (v64 - (unint64_t)(8 * v50)) >> 64;
  unint64_t v21 = v64 - 8 * v50;
  BOOL v19 = v21 >= 0x100;
  unint64_t v23 = v21 - 256;
  if (v19) {
    ++v22;
  }
  *(void *)&unsigned long long v64 = v23;
  *((void *)&v64 + 1) = v22;
  unint64_t v25 = (v65 - (unint64_t)(8 * *((void *)&v50 + 1))) >> 64;
  unint64_t v24 = v65 - 8 * *((void *)&v50 + 1);
  BOOL v19 = v24 >= 0x100;
  unint64_t v26 = v24 - 256;
  if (v19) {
    ++v25;
  }
  *(void *)&unsigned long long v65 = v26;
  *((void *)&v65 + 1) = v25;
  sub_244D3F438(a1, (unint64_t *)&v62);
  int64x2_t v27 = vaddq_s64(*a6, *a5);
  int64x2_t v28 = vaddq_s64(a6[1], a5[1]);
  uint64_t v29 = v51.i64[0] + v13.i64[0];
  uint64_t v30 = v51.i64[1] + v13.i64[1];
  unint64_t v31 = v52 + v14;
  unint64_t v32 = *((void *)&v52 + 1) + *((void *)&v14 + 1);
  int64x2_t v46 = v27;
  int64x2_t v47 = v28;
  sub_244D3F380((uint64_t)&v62, (unint64_t *)&v46);
  unsigned long long v62 = v62 - (unint64_t)v29 + __PAIR128__(1, 256);
  unint64_t v33 = (v63 - (unsigned __int128)(unint64_t)v30) >> 64;
  if ((unint64_t)(v63 - v30) >= 0x1000000000100) {
    ++v33;
  }
  *(void *)&long long v63 = v63 - v30 - 0x1000000000100;
  *((void *)&v63 + 1) = v33;
  uint64_t v34 = (v64 - v31) >> 64;
  if ((unint64_t)v64 - v31 >= 0x100) {
    ++v34;
  }
  *(void *)&unsigned long long v64 = v64 - v31 - 256;
  *((void *)&v64 + 1) = v34;
  uint64_t v35 = (v65 - v32) >> 64;
  if ((unint64_t)v65 - v32 >= 0x100) {
    ++v35;
  }
  *(void *)&unsigned long long v65 = v65 - v32 - 256;
  *((void *)&v65 + 1) = v35;
  sub_244D3F438(a3, (unint64_t *)&v62);
  uint64_t v36 = a1->i64[1];
  v49.i64[0] = 4 * v15.i64[0] + 0x400000000000004 - a1->i64[0];
  v49.i64[1] = 4 * v15.i64[1] + 0x3FFFBFFFFFFFFFCLL - v36;
  uint64_t v37 = 4 * *((void *)&v16 + 1) - a1[1].i64[1] + 0x3FFFFFFFFFFFFFCLL;
  *(void *)&long long v50 = 4 * v16 - a1[1].i64[0] + 0x3FFFFFFFFFFFFFCLL;
  *((void *)&v50 + 1) = v37;
  sub_244D3F56C((uint64_t)&v62, (unint64_t *)v48, (unint64_t *)&v49);
  sub_244D3F380((uint64_t)&v55, (unint64_t *)&v51);
  uint64_t v38 = ((v62 - v55 * 8) >> 64) + 0x100000000000000;
  *(void *)&unsigned long long v62 = v62 - 8 * v55;
  *((void *)&v62 + 1) = v38;
  long long v39 = v63 - v56 * 8;
  *(void *)&long long v63 = v63 - 8 * v56;
  *((void *)&v63 + 1) = *((void *)&v39 + 1) + 0xFFFFFFFFFFFFFFLL;
  unsigned long long v64 = v64 - v57 * 8 + __PAIR128__(0xFFFFFFFFFFFFFFLL, 0);
  unsigned long long v65 = v65 - v58 * 8 + __PAIR128__(0x100000000000000, 0);
  unsigned long long v66 = v66 - v59 * 8 + __PAIR128__(0xFFFEFFFFFFFFFFLL, 0);
  unsigned long long v67 = v67 - v60 * 8 + __PAIR128__(0xFFFFFFFFFFFFFFLL, 0);
  uint64_t v40 = ((unsigned __int128)(v68 - v61 * 8) >> 64) + 0xFFFFFFFFFFFFFFLL;
  *(void *)&long long v68 = v68 - 8 * v61;
  *((void *)&v68 + 1) = v40;
  *(void *)&double result = sub_244D3F438(a2, (unint64_t *)&v62).u64[0];
  return result;
}

void sub_244D402DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 96) = *(void *)a2 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v4 = a1 + 96;
  *(void *)(a1 + 104) = (*(long long *)a2 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 112) = (*(long long *)(a2 + 8) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 120) = (*(long long *)(a2 + 16) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 128) = *(void *)(a2 + 72) & 0xFFFFFFFFFFFFFFLL;
  unint64_t v5 = (int64x2_t *)(a1 + 128);
  *(void *)(a1 + 136) = (*(long long *)(a2 + 72) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 144) = (*(long long *)(a2 + 80) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 152) = (*(long long *)(a2 + 88) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 160) = *(void *)(a2 + 144) & 0xFFFFFFFFFFFFFFLL;
  uint64_t v6 = a1 + 160;
  *(void *)(a1 + 168) = (*(long long *)(a2 + 144) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 176) = (*(long long *)(a2 + 152) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 184) = (*(long long *)(a2 + 160) >> 40) & 0xFFFFFFFFFFFFFFLL;
  unint64_t v7 = 2;
  do
  {
    BOOL v8 = (int8x16_t *)(a1 + v3 + 192);
    unint64_t v9 = (int8x16_t *)(a1 + v3 + 224);
    unint64_t v10 = (int8x16_t *)(a1 + v3 + 256);
    if (v7) {
      sub_244D3F73C((uint64_t)v8, (uint64_t)v9, (uint64_t)v10, v4, v5, v6, 0, (unint64_t *)(a1 + v3 + 96), (unint64_t *)(a1 + v3 + 128), (unint64_t *)(a1 + v3 + 160));
    }
    else {
      sub_244D3FEC0(v8, v9, v10, (unint64_t *)(a1 + 96 * (v7 >> 1)), (int64x2_t *)(a1 + 96 * (v7 >> 1) + 32), (int64x2_t *)(a1 + 96 * (v7 >> 1) + 64));
    }
    ++v7;
    v3 += 96;
  }
  while (v3 != 1440);
}

uint64_t sub_244D40458(uint64_t result, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      for (uint64_t j = 0; j != 96; j += 8)
        *(void *)((char *)a4 + j) |= *(void *)(a3 + j) & ((((i ^ result) - 1) & ~result) >> 63);
      a3 += 96;
    }
  }
  return result;
}

double sub_244D404BC(int8x16_t *a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  unint64_t v3 = a2[1];
  BOOL v4 = *a2 <= 0x100uLL;
  v7[0] = 256 - *a2;
  v7[1] = v4;
  unsigned long long v8 = 0xFFFEFFFFFFFFFF00 - __PAIR128__(v4, v3);
  unint64_t v5 = a2[3];
  unsigned long long v9 = 0xFFFFFFFFFFFFFF00 - __PAIR128__(v2, a2[2]);
  unsigned long long v10 = 0xFFFFFFFFFFFFFF00 - __PAIR128__(v9, v5);
  *(void *)&double result = sub_244D3F438(a1, v7).u64[0];
  return result;
}

uint64_t sub_244D40564(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(unsigned int *)(a1 + 328);
  if ((int)v7 < 1)
  {
    BOOL v11 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    unsigned long long v9 = (uint64_t *)(a2 + 9);
    do
    {
      uint64_t v10 = *v9++;
      v8 |= v10;
      --v7;
    }
    while (v7);
    BOOL v11 = v8 == 0;
  }
  if (v11)
  {
    sub_244D0B884(15, 0, 119, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/ec/p256.c", 421);
    return 0;
  }
  else
  {
    memset(v26, 0, sizeof(v26));
    long long v13 = a2[10];
    v27[0] = a2[9];
    v27[1] = v13;
    long long v35 = 0u;
    long long v36 = 0u;
    memset(v34, 0, sizeof(v34));
    memset(v33, 0, sizeof(v33));
    sub_244D41BF4((uint64_t *)&v35, (unint64_t *)v27);
    sub_244D41858((uint64_t *)&v35, (unint64_t *)&v35, (unint64_t *)v27);
    sub_244D41BF4((uint64_t *)v34, (unint64_t *)&v35);
    sub_244D41858((uint64_t *)v34, (unint64_t *)v34, (unint64_t *)v27);
    sub_244D41BF4((uint64_t *)v33, (unint64_t *)v34);
    int v14 = 2;
    do
    {
      sub_244D41BF4((uint64_t *)v33, (unint64_t *)v33);
      --v14;
    }
    while (v14);
    memset(v32, 0, sizeof(v32));
    sub_244D41858((uint64_t *)v33, (unint64_t *)v33, (unint64_t *)v34);
    sub_244D41BF4((uint64_t *)v32, (unint64_t *)v33);
    int v15 = 5;
    do
    {
      sub_244D41BF4((uint64_t *)v32, (unint64_t *)v32);
      --v15;
    }
    while (v15);
    memset(v31, 0, sizeof(v31));
    sub_244D41858((uint64_t *)v32, (unint64_t *)v32, (unint64_t *)v33);
    sub_244D41BF4((uint64_t *)v31, (unint64_t *)v32);
    int v16 = 2;
    do
    {
      sub_244D41BF4((uint64_t *)v31, (unint64_t *)v31);
      --v16;
    }
    while (v16);
    memset(v30, 0, sizeof(v30));
    sub_244D41858((uint64_t *)v31, (unint64_t *)v31, (unint64_t *)v34);
    sub_244D41BF4((uint64_t *)v30, (unint64_t *)v31);
    int v17 = 14;
    do
    {
      sub_244D41BF4((uint64_t *)v30, (unint64_t *)v30);
      --v17;
    }
    while (v17);
    memset(v29, 0, sizeof(v29));
    sub_244D41858((uint64_t *)v30, (unint64_t *)v30, (unint64_t *)v31);
    sub_244D41BF4((uint64_t *)v29, (unint64_t *)v30);
    sub_244D41BF4((uint64_t *)v29, (unint64_t *)v29);
    sub_244D41858((uint64_t *)v29, (unint64_t *)v29, (unint64_t *)&v35);
    memset(v28, 0, sizeof(v28));
    sub_244D41BF4((uint64_t *)v28, (unint64_t *)v29);
    int v18 = 31;
    do
    {
      sub_244D41BF4((uint64_t *)v28, (unint64_t *)v28);
      --v18;
    }
    while (v18);
    sub_244D41858((uint64_t *)v28, (unint64_t *)v28, (unint64_t *)v27);
    int v19 = 128;
    do
    {
      sub_244D41BF4((uint64_t *)v28, (unint64_t *)v28);
      --v19;
    }
    while (v19);
    sub_244D41858((uint64_t *)v28, (unint64_t *)v28, (unint64_t *)v29);
    int v20 = 32;
    do
    {
      sub_244D41BF4((uint64_t *)v28, (unint64_t *)v28);
      --v20;
    }
    while (v20);
    sub_244D41858((uint64_t *)v28, (unint64_t *)v28, (unint64_t *)v29);
    int v21 = 30;
    do
    {
      sub_244D41BF4((uint64_t *)v28, (unint64_t *)v28);
      --v21;
    }
    while (v21);
    sub_244D41858((uint64_t *)v28, (unint64_t *)v28, (unint64_t *)v30);
    sub_244D41BF4((uint64_t *)v28, (unint64_t *)v28);
    sub_244D41BF4((uint64_t *)v26, (unint64_t *)v28);
    if (a3)
    {
      long long v22 = a2[1];
      long long v35 = *a2;
      long long v36 = v22;
      sub_244D41858((uint64_t *)&v35, (unint64_t *)&v35, (unint64_t *)v26);
      long long v23 = v36;
      *a3 = v35;
      a3[1] = v23;
    }
    if (a4)
    {
      long long v24 = *(_OWORD *)((char *)a2 + 88);
      long long v35 = *(_OWORD *)((char *)a2 + 72);
      long long v36 = v24;
      sub_244D41BF4((uint64_t *)v26, (unint64_t *)v26);
      sub_244D41858((uint64_t *)&v35, (unint64_t *)&v35, (unint64_t *)v27);
      sub_244D41858((uint64_t *)&v35, (unint64_t *)&v35, (unint64_t *)v26);
      long long v25 = v36;
      *a4 = v35;
      a4[1] = v25;
    }
    return 1;
  }
}

double sub_244D408D4(uint64_t a1, _OWORD *a2, long long *a3, _OWORD *a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  long long v5 = a3[1];
  long long v22 = *a3;
  long long v23 = v5;
  long long v6 = *(long long *)((char *)a3 + 88);
  long long v20 = *(long long *)((char *)a3 + 72);
  long long v21 = v6;
  long long v7 = a3[10];
  long long v18 = a3[9];
  long long v19 = v7;
  long long v8 = a4[1];
  v17[0] = *a4;
  v17[1] = v8;
  long long v9 = *(_OWORD *)((char *)a4 + 88);
  v16[0] = *(_OWORD *)((char *)a4 + 72);
  v16[1] = v9;
  long long v10 = a4[10];
  v15[0] = a4[9];
  v15[1] = v10;
  sub_244D41F50((uint64_t *)&v22, (uint64_t *)&v20, (uint64_t *)&v18, (uint64_t)&v22, (unint64_t *)&v20, (unint64_t *)&v18, 0, (unint64_t *)v17, (unint64_t *)v16, (unint64_t *)v15);
  long long v11 = v23;
  *a2 = v22;
  a2[1] = v11;
  long long v12 = v21;
  *(_OWORD *)((char *)a2 + 72) = v20;
  *(_OWORD *)((char *)a2 + 88) = v12;
  double result = *(double *)&v18;
  long long v14 = v19;
  a2[9] = v18;
  a2[10] = v14;
  return result;
}

double sub_244D409AC(uint64_t a1, _OWORD *a2, long long *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  long long v4 = a3[1];
  long long v15 = *a3;
  long long v16 = v4;
  long long v5 = *(long long *)((char *)a3 + 88);
  long long v13 = *(long long *)((char *)a3 + 72);
  long long v14 = v5;
  long long v6 = a3[10];
  long long v11 = a3[9];
  long long v12 = v6;
  sub_244D42A18((uint64_t *)&v15, (uint64_t *)&v13, (uint64_t *)&v11, (unint64_t *)&v15, (unint64_t *)&v13, (unint64_t *)&v11);
  long long v7 = v16;
  *a2 = v15;
  a2[1] = v7;
  long long v8 = v14;
  *(_OWORD *)((char *)a2 + 72) = v13;
  *(_OWORD *)((char *)a2 + 88) = v8;
  double result = *(double *)&v11;
  long long v10 = v12;
  a2[9] = v11;
  a2[10] = v10;
  return result;
}

double sub_244D40A54(uint64_t a1, _OWORD *a2, _OWORD *a3, uint64_t a4)
{
  v86[0] = *MEMORY[0x263EF8340];
  bzero(v81, 0x660uLL);
  long long v6 = a3[1];
  v83[0] = *a3;
  v83[1] = v6;
  long long v7 = *(_OWORD *)((char *)a3 + 88);
  v84[0] = *(_OWORD *)((char *)a3 + 72);
  v84[1] = v7;
  long long v8 = a3[9];
  long long v9 = a3[10];
  unint64_t v10 = -1440;
  unint64_t v11 = 2;
  v85[0] = v8;
  v85[1] = v9;
  do
  {
    long long v12 = &v86[v10 / 8];
    long long v13 = &v86[v10 / 8 + 4];
    long long v14 = &v86[v10 / 8 + 8];
    if (v11) {
      sub_244D41F50(v12, v13, v14, (uint64_t)v83, (unint64_t *)v84, (unint64_t *)v85, 0, (unint64_t *)&v85[v10 / 0x10 + 86], (unint64_t *)&v85[v10 / 0x10 + 88], (unint64_t *)&v85[v10 / 0x10 + 90]);
    }
    else {
      sub_244D42A18(v12, v13, v14, (unint64_t *)&v81[6 * (v11 >> 1)], (unint64_t *)&v81[6 * (v11 >> 1) + 2], (unint64_t *)&v82[96 * (v11 >> 1) + 16]);
    }
    ++v11;
    v10 += 96;
  }
  while (v10);
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  int v15 = 1;
  for (unint64_t i = 255; i < 0x100; --i)
  {
    if (!v15) {
      sub_244D42A18((uint64_t *)&v75, (uint64_t *)&v77, (uint64_t *)&v79, (unint64_t *)&v75, (unint64_t *)&v77, (unint64_t *)&v79);
    }
    if (-858993459 * i <= 0x33333333)
    {
      if (i <= 0xFB)
      {
        uint64_t v17 = 32 * ((*(void *)(a4 + 8 * ((i + 4) >> 6)) >> (i + 4)) & 1);
        unsigned int v18 = i + 3;
      }
      else
      {
        if (i != 252)
        {
          if (i > 0xFD)
          {
            unint64_t v21 = 0;
            if (i != 254)
            {
              uint64_t v23 = 0;
LABEL_17:
              if ((i - 1) <= 0xFF) {
                uint64_t v24 = (*(void *)(a4 + 8 * ((i - 1) >> 6)) >> (i - 1)) & 1;
              }
              else {
                uint64_t v24 = 0;
              }
              uint64_t v25 = 0;
              uint64_t v26 = 0;
              uint64_t v27 = 0;
              uint64_t v28 = 0;
              uint64_t v29 = 0;
              uint64_t v30 = 0;
              uint64_t v31 = 0;
              uint64_t v32 = 0;
              uint64_t v33 = 0;
              uint64_t v34 = 0;
              uint64_t v35 = 0;
              uint64_t v36 = 0;
              uint64_t v37 = 0;
              uint64_t v38 = (4 * v23) | (2 * ((*(void *)(a4 + ((i >> 3) & 0x1FFFFFFFFFFFFFF8)) >> i) & 1)) | v24 | v21;
              uint64_t v39 = (v21 >> 5) - 1;
              uint64_t v40 = -(uint64_t)(v21 >> 5);
              unint64_t v41 = (((v38 ^ 0x3F) & v40 | v38 & v39) & 1) + (((v38 ^ 0x3F) & v40 | v38 & (unint64_t)v39) >> 1);
              uint64_t v42 = v82;
              do
              {
                if (v41 == v37) {
                  uint64_t v43 = -1;
                }
                else {
                  uint64_t v43 = 0;
                }
                if (v41 == v37) {
                  uint64_t v44 = 0;
                }
                else {
                  uint64_t v44 = -1;
                }
                uint64_t v36 = v43 & *(v42 - 6) | v44 & v36;
                uint64_t v33 = v33 & v44 | *(v42 - 5) & v43;
                uint64_t v32 = v32 & v44 | *(v42 - 4) & v43;
                uint64_t v31 = v31 & v44 | *(v42 - 3) & v43;
                uint64_t v35 = v35 & v44 | *(v42 - 2) & v43;
                uint64_t v30 = v30 & v44 | *(v42 - 1) & v43;
                uint64_t v29 = v29 & v44 | *v42 & v43;
                uint64_t v28 = v28 & v44 | v42[1] & v43;
                uint64_t v34 = v34 & v44 | v42[2] & v43;
                uint64_t v27 = v27 & v44 | v42[3] & v43;
                uint64_t v26 = v26 & v44 | v42[4] & v43;
                uint64_t v25 = v25 & v44 | v42[5] & v43;
                ++v37;
                v42 += 12;
              }
              while (v37 != 17);
              *(void *)&long long v70 = v32;
              *((void *)&v70 + 1) = v31;
              *(void *)&long long v74 = v26;
              *((void *)&v74 + 1) = v25;
              *(void *)&long long v69 = v36;
              *((void *)&v69 + 1) = v33;
              *(void *)&long long v73 = v34;
              *((void *)&v73 + 1) = v27;
              BOOL v45 = __CFADD__(v30, -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v25, v35) >> 64));
              uint64_t v46 = v30 + -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v25, v35) >> 64);
              char v47 = v45;
              BOOL v45 = v46 == 0;
              uint64_t v48 = -v46;
              uint64_t v50 = (v47 + !v45);
              uint64_t v49 = v29 + v50;
              BOOL v51 = __CFADD__(v29, v50);
              BOOL v45 = v49 == 0;
              uint64_t v52 = -v49;
              uint64_t v54 = (v51 + !v45);
              uint64_t v53 = v28 + v54;
              BOOL v55 = __CFADD__(v28, v54);
              BOOL v45 = v53 == 0;
              uint64_t v56 = -v53;
              if (v55 + !v45) {
                uint64_t v57 = -1;
              }
              else {
                uint64_t v57 = 0;
              }
              uint64_t v58 = v57 - v35;
              BOOL v45 = __CFADD__(__CFADD__(-v35, v57), v48);
              uint64_t v59 = __CFADD__(-v35, v57) + v48;
              v45 |= __CFADD__(v57, v59);
              v59 += v57;
              unint64_t v60 = v56 + __CFADD__(v45, v52) + (v57 & 0xFFFFFFFF00000001);
              uint64_t v61 = v40;
              uint64_t v62 = v40 & v58;
              uint64_t v63 = ~v40;
              *(void *)&long long v71 = v63 & v35 | v62;
              *((void *)&v71 + 1) = v61 & v59 | v63 & v30;
              *(void *)&long long v72 = v61 & (v45 + v52) | v63 & v29;
              *((void *)&v72 + 1) = v60 & v61 | v63 & v28;
              if (v15)
              {
                int v15 = 0;
                long long v75 = v69;
                long long v76 = v70;
                long long v77 = v71;
                long long v78 = v72;
                long long v79 = v73;
                long long v80 = v74;
              }
              else
              {
                sub_244D41F50((uint64_t *)&v75, (uint64_t *)&v77, (uint64_t *)&v79, (uint64_t)&v75, (unint64_t *)&v77, (unint64_t *)&v79, 0, (unint64_t *)&v69, (unint64_t *)&v71, (unint64_t *)&v73);
              }
              continue;
            }
            unsigned int v22 = 255;
LABEL_16:
            uint64_t v23 = (*(void *)(a4 + 8 * (v22 >> 6)) >> v22) & 1;
            goto LABEL_17;
          }
          uint64_t v19 = 0;
          unsigned int v20 = 255;
LABEL_15:
          unint64_t v21 = (8 * ((*(void *)(a4 + 8 * (v20 >> 6)) >> v20) & 1)) | v19;
          unsigned int v22 = i + 1;
          goto LABEL_16;
        }
        uint64_t v17 = 0;
        unsigned int v18 = 255;
      }
      uint64_t v19 = (16 * ((*(void *)(a4 + 8 * (v18 >> 6)) >> v18) & 1)) | v17;
      unsigned int v20 = i + 2;
      goto LABEL_15;
    }
  }
  long long v64 = v76;
  *a2 = v75;
  a2[1] = v64;
  long long v65 = v78;
  *(_OWORD *)((char *)a2 + 72) = v77;
  *(_OWORD *)((char *)a2 + 88) = v65;
  double result = *(double *)&v79;
  long long v67 = v80;
  a2[9] = v79;
  a2[10] = v67;
  return result;
}

double sub_244D40F24(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  char v5 = 0;
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v6 = 223;
  do
  {
    if (v5) {
      sub_244D42A18((uint64_t *)&v15, (uint64_t *)&v17, (uint64_t *)&v19, (unint64_t *)&v15, (unint64_t *)&v17, (unint64_t *)&v19);
    }
    sub_244D43424((8 * ((*(void *)(a3 + 8 * ((v6 + 32) >> 6)) >> (v6 + 96)) & 1)) | (4 * ((*(void *)(a3 + 8 * ((v6 - 32) >> 6)) >> (v6 + 96)) & 1)) | (2 * ((*(void *)(a3 + 8 * ((v6 - 96) >> 6)) >> (v6 + 96)) & 1)) | (*(void *)(a3 + 8 * ((v6 - 160) >> 6)) >> (v6 + 96)) & 1, (uint64_t)&unk_244EB9258, v12);
    if (v5)
    {
      sub_244D41F50((uint64_t *)&v15, (uint64_t *)&v17, (uint64_t *)&v19, (uint64_t)&v15, (unint64_t *)&v17, (unint64_t *)&v19, 1, (unint64_t *)v12, (unint64_t *)v13, (unint64_t *)v14);
    }
    else
    {
      long long v15 = v12[0];
      long long v16 = v12[1];
      long long v17 = v13[0];
      long long v18 = v13[1];
      long long v19 = v14[0];
      long long v20 = v14[1];
    }
    sub_244D43424((8 * ((*(void *)(a3 + 8 * (v6 >> 6)) >> v6) & 1)) | (4* ((*(void *)(a3+ 8* ((v6 - 64) >> 6)) >> (v6 + 64)) & 1)) | (2 * ((*(void *)(a3 + 8 * ((v6 - 128) >> 6)) >> (v6 + 64)) & 1)) | (*(void *)(a3 + 8 * ((v6 - 192) >> 6)) >> (v6 + 64)) & 1, (uint64_t)&unk_244EB8E98, v12);
    char v5 = 1;
    sub_244D41F50((uint64_t *)&v15, (uint64_t *)&v17, (uint64_t *)&v19, (uint64_t)&v15, (unint64_t *)&v17, (unint64_t *)&v19, 1, (unint64_t *)v12, (unint64_t *)v13, (unint64_t *)v14);
    unint64_t v7 = v6 - 193;
    --v6;
  }
  while (v7 < 0x20);
  long long v8 = v16;
  *a2 = v15;
  a2[1] = v8;
  long long v9 = v18;
  *(_OWORD *)((char *)a2 + 72) = v17;
  *(_OWORD *)((char *)a2 + 88) = v9;
  double result = *(double *)&v19;
  long long v11 = v20;
  a2[9] = v19;
  a2[10] = v11;
  return result;
}

double sub_244D41150(uint64_t a1, _OWORD *a2, uint64_t a3, _OWORD *a4, _DWORD *a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  long long v8 = a4[1];
  v63[0] = *a4;
  v63[1] = v8;
  long long v9 = *(_OWORD *)((char *)a4 + 88);
  v64[0] = *(_OWORD *)((char *)a4 + 72);
  v64[1] = v9;
  long long v10 = a4[10];
  v65[0] = a4[9];
  v65[1] = v10;
  sub_244D42A18((uint64_t *)v60, v61, v62, (unint64_t *)v63, (unint64_t *)v64, (unint64_t *)v65);
  for (uint64_t i = 0; i != 42; i += 6)
    sub_244D41F50((uint64_t *)&v65[i + 2], (uint64_t *)&v65[i + 4], (uint64_t *)&v65[i + 6], (uint64_t)&v63[i], (unint64_t *)&v63[i + 2], (unint64_t *)&v65[i], 0, v60, (unint64_t *)v61, (unint64_t *)v62);
  unint64_t v12 = 256;
  sub_244D2E24C(a1, v59, a5, 0x100uLL, 4);
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  int v14 = 1;
  do
  {
    if (!v14) {
      sub_244D42A18((uint64_t *)&v53, (uint64_t *)&v55, (uint64_t *)&v57, (unint64_t *)&v53, (unint64_t *)&v55, (unint64_t *)&v57);
    }
    if (v12 <= 0x1F)
    {
      uint64_t v15 = (8 * ((*(void *)(a3 + 8 * ((v12 + 224) >> 6)) >> (v12 - 32)) & 1)) | (4 * ((*(void *)(a3 + 8 * ((v12 + 160) >> 6)) >> (v12 - 96)) & 1)) | (2 * ((*(void *)(a3 + 8 * ((v12 + 96) >> 6)) >> (v12 + 96)) & 1)) | (*(void *)(a3 + (((v12 + 32) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 + 32)) & 1;
      if (v15)
      {
        sub_244D41F50((uint64_t *)&v53, (uint64_t *)&v55, (uint64_t *)&v57, (uint64_t)&v53, (unint64_t *)&v55, (unint64_t *)&v57, 1, &qword_244EB8E98[8 * v15 + 112], &qword_244EB8E98[8 * v15 + 116], (unint64_t *)&xmmword_244EB7E88);
        int v14 = 0;
      }
      uint64_t v16 = (8 * ((*(void *)(a3 + (((v12 + 192) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12) & 1)) | (4
                                                                                                  * ((*(void *)(a3 + (((v12 + 128) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12) & 1)) | (2 * ((*(void *)(a3 + (((v12 + 64) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12) & 1)) | (*(void *)(a3 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12) & 1;
      if (v16)
      {
        sub_244D41F50((uint64_t *)&v53, (uint64_t *)&v55, (uint64_t *)&v57, (uint64_t)&v53, (unint64_t *)&v55, (unint64_t *)&v57, 1, &qword_244EB8E98[8 * v16 - 8], &qword_244EB8E98[8 * v16 - 4], (unint64_t *)&xmmword_244EB7E88);
        int v14 = 0;
      }
    }
    int v17 = (char)v59[v12];
    if (v59[v12])
    {
      if (v17 >= 0) {
        LOBYTE(v18) = v59[v12];
      }
      else {
        int v18 = -v17;
      }
      unsigned int v19 = v18 >> 1;
      long long v20 = &v63[6 * v19];
      uint64_t v21 = (unint64_t *)(v20 + 2);
      long long v51 = 0u;
      long long v52 = 0u;
      if (v17 < 0)
      {
        uint64_t v26 = *((void *)v20 + 5);
        uint64_t v27 = -(uint64_t)*v21;
        unsigned __int8 v28 = -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v13, *v21) >> 64);
        BOOL v29 = __CFADD__(v26, v28);
        uint64_t v30 = v26 + v28;
        char v31 = v29;
        BOOL v29 = v30 == 0;
        uint64_t v32 = -v30;
        uint64_t v34 = *((void *)v20 + 6);
        uint64_t v33 = *((void *)v20 + 7);
        uint64_t v36 = (v31 + !v29);
        uint64_t v35 = v34 + v36;
        BOOL v37 = __CFADD__(v34, v36);
        BOOL v29 = v35 == 0;
        uint64_t v38 = -v35;
        unsigned __int8 v39 = v37 + !v29;
        BOOL v29 = __CFADD__(v33, v39);
        uint64_t v40 = v33 + v39;
        char v41 = v29;
        BOOL v29 = v40 == 0;
        uint64_t v42 = -v40;
        if (v41 + !v29) {
          uint64_t v43 = -1;
        }
        else {
          uint64_t v43 = 0;
        }
        BOOL v29 = __CFADD__(__CFADD__(v27, v43), v32);
        uint64_t v44 = __CFADD__(v27, v43) + v32;
        uint64_t v45 = v29 | __CFADD__(v43, v44);
        BOOL v29 = __CFADD__(v45, v38);
        unint64_t v13 = v45 + v38;
        *(void *)&long long v51 = v27 + v43;
        *((void *)&v51 + 1) = v43 + v44;
        *(void *)&long long v52 = v13;
        *((void *)&v52 + 1) = v42 + v29 + (v43 & 0xFFFFFFFF00000001);
        uint64_t v21 = (unint64_t *)&v51;
        if (v14) {
          goto LABEL_17;
        }
      }
      else if (v14)
      {
LABEL_17:
        long long v22 = v20[1];
        long long v53 = *v20;
        long long v54 = v22;
        long long v23 = *((_OWORD *)v21 + 1);
        long long v55 = *(_OWORD *)v21;
        long long v56 = v23;
        uint64_t v24 = &v63[6 * v19];
        long long v25 = v24[5];
        long long v57 = v24[4];
        long long v58 = v25;
LABEL_32:
        int v14 = 0;
        goto LABEL_33;
      }
      sub_244D41F50((uint64_t *)&v53, (uint64_t *)&v55, (uint64_t *)&v57, (uint64_t)&v53, (unint64_t *)&v55, (unint64_t *)&v57, 0, (unint64_t *)v20, v21, (unint64_t *)&v65[6 * v19]);
      goto LABEL_32;
    }
LABEL_33:
    --v12;
  }
  while (v12 != -1);
  long long v46 = v54;
  *a2 = v53;
  a2[1] = v46;
  long long v47 = v56;
  *(_OWORD *)((char *)a2 + 72) = v55;
  *(_OWORD *)((char *)a2 + 88) = v47;
  double result = *(double *)&v57;
  long long v49 = v58;
  a2[9] = v57;
  a2[10] = v49;
  return result;
}

BOOL sub_244D41514(uint64_t a1, long long *a2, uint64_t *a3)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(unsigned int *)(a1 + 328);
  if ((int)v3 < 1) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  do
  {
    v8 |= *(void *)((char *)a2 + v7 + 144);
    v7 += 8;
  }
  while (8 * v3 != v7);
  if (!v8) {
    return 0;
  }
  long long v9 = a2[10];
  v90[0] = a2[9];
  v90[1] = v9;
  sub_244D41858((uint64_t *)v90, (unint64_t *)v90, (unint64_t *)v90);
  long long v10 = *((_OWORD *)a3 + 1);
  long long v88 = *(_OWORD *)a3;
  long long v89 = v10;
  sub_244D41858((uint64_t *)&v88, (unint64_t *)&v88, (unint64_t *)v90);
  long long v11 = a2[1];
  long long v86 = *a2;
  uint64_t v12 = ((unint64_t)v86 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v13 = ((unint64_t)v86 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v14 = 0xFFFFFFFFLL * v86 + __CFADD__(-(uint64_t)v86, (void)v86) + v13;
  uint64_t v15 = __CFADD__(__CFADD__(-(uint64_t)v86, (void)v86), v13) | __CFADD__(0xFFFFFFFFLL * v86, __CFADD__(-(uint64_t)v86, (void)v86)+ v13)? (((unint64_t)v86 * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1: ((unint64_t)v86 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v32 = __CFADD__(v14, *((void *)&v86 + 1));
  uint64_t v16 = v14 + *((void *)&v86 + 1);
  BOOL v17 = v32;
  unint64_t v18 = 0xFFFFFFFF00000001 * v16;
  uint64_t v19 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v16) >> 64;
  BOOL v20 = v17 + __CFADD__(-v16, v16) + v15;
  BOOL v32 = __CFADD__(v20, v19);
  uint64_t v21 = v20 + v19;
  uint64_t v22 = v32 - 0xFFFFFFFFLL * v86;
  BOOL v23 = __CFADD__(v32, 0xFFFFFFFF00000001 * v86);
  BOOL v32 = __CFADD__(v18, v12);
  uint64_t v24 = v18 + v12;
  BOOL v25 = v32;
  BOOL v32 = __CFADD__(((unint64_t)v16 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFFLL * v16);
  long long v87 = v11;
  unint64_t v26 = ((unint64_t)v16 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v27 = ((unint64_t)v16 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  uint64_t v29 = v32 + v22;
  BOOL v32 = __CFADD__(v32, v22) | __CFADD__(v27, v29);
  uint64_t v28 = v27 + v29;
  BOOL v30 = v23 + v32 + v24;
  uint64_t v31 = __CFADD__(v32, v24) | __CFADD__(v23, v32 + v24) ? v25 + 1 : v25;
  BOOL v32 = __CFADD__(v21, (void)v87);
  unint64_t v33 = v21 + v87;
  BOOL v34 = v32;
  uint64_t v35 = v32 + v28;
  unint64_t v36 = (v33 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  unsigned long long v37 = __PAIR128__(v31, __CFADD__(v32, v28)) + __PAIR128__(v26, v30);
  uint64_t v38 = 0xFFFFFFFF * v33;
  uint64_t v39 = (__PAIR128__(0xFFFFFFFFLL, -1) * v33) >> 64;
  BOOL v40 = v34 + __CFADD__(-(uint64_t)v33, v33) + v28;
  unint64_t v41 = (__CFADD__(__CFADD__(-(uint64_t)v33, v33), v35) | __CFADD__(v39, __CFADD__(-(uint64_t)v33, v33) + v35))+ (void)v37;
  BOOL v42 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v33, v33), v35) | __CFADD__(v39, __CFADD__(-(uint64_t)v33, v33) + v35), (void)v37);
  BOOL v43 = __CFADD__(0xFFFFFFFF00000001 * v33, *((void *)&v37 + 1));
  uint64_t v44 = 0xFFFFFFFF * v33;
  unint64_t v45 = (v33 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v46 = (v33 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  uint64_t v47 = v40 + v36 + v38;
  BOOL v32 = __CFADD__(__CFADD__(v36, v38), v41) | __CFADD__(v46, (__PAIR128__(v41, v36) + (unint64_t)v44) >> 64);
  uint64_t v48 = v46 + ((__PAIR128__(v41, v36) + (unint64_t)v44) >> 64);
  BOOL v49 = v42 + v32 + *((void *)&v37 + 1);
  uint64_t v50 = __CFADD__(v32, *((void *)&v37 + 1)) | __CFADD__(v42, v32 + *((void *)&v37 + 1))
      ? v43 + 1
      : v43;
  BOOL v51 = __CFADD__(v47, *((void *)&v87 + 1));
  unint64_t v52 = v47 + *((void *)&v87 + 1);
  BOOL v53 = v51;
  uint64_t v54 = v51 + v48;
  unint64_t v55 = (v52 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  unsigned long long v56 = __PAIR128__(v50, __CFADD__(v51, v48)) + __PAIR128__(v45, v49);
  unint64_t v57 = 0xFFFFFFFF00000001 * v52;
  uint64_t v58 = -(uint64_t)v52;
  unint64_t v59 = (__PAIR128__(0xFFFFFFFFLL, -1) * v52) >> 64;
  uint64_t v60 = __CFADD__((v52 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v52)
      ? ((v52 * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1
      : (v52 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v32 = __CFADD__(v58, v52);
  unint64_t v61 = v53 + __CFADD__(v58, v52) + v48 + v59;
  unint64_t v62 = v60 + (__CFADD__(v32, v54) | __CFADD__(v59, v32 + v54)) + (void)v56;
  uint64_t v64 = __CFADD__(__CFADD__(v32, v54) | __CFADD__(v59, v32 + v54), (void)v56) | __CFADD__(v60, (__CFADD__(v32, v54) | __CFADD__(v59, v32 + v54)) + (void)v56);
  unint64_t v63 = *((void *)&v56 + 1) + v64 + v57;
  uint64_t v65 = __CFADD__(v64, v57) | __CFADD__(*((void *)&v56 + 1), v64 + v57) ? v55 + 1 : v55;
  unint64_t v67 = v62 - (1 - __CFADD__(v61, 1));
  unint64_t v66 = (v62 - __PAIR128__(v55, (1 - __CFADD__(v61, 1)))) >> 64;
  unsigned long long v68 = (unint64_t)v65
      - __PAIR128__(v59, -(uint64_t)((v63- __PAIR128__(v66, (1 - (__CFADD__(v67, 0xFFFFFFFF00000001) + v66)))) >> 64));
  uint64_t v69 = __CFADD__((void)v68, 0xFFFFFFFFLL) + BYTE8(v68) == 1 ? -1 : 0;
  uint64_t v70 = v69 & (v61 + 1) | *((void *)&v68 + 1) & v61;
  uint64_t v71 = v69 & (v67 - 0xFFFFFFFF) | *((void *)&v68 + 1) & v62;
  uint64_t v72 = v69 & (v63 - (1 - (__CFADD__(v67, 0xFFFFFFFF00000001) + v66))) | *((void *)&v68 + 1) & v63;
  uint64_t v73 = v69 & (v68 + 0xFFFFFFFF) | v65 & *((void *)&v68 + 1);
  *(void *)&long long v86 = v70;
  *((void *)&v86 + 1) = v71;
  *(void *)&long long v87 = v72;
  *((void *)&v87 + 1) = v73;
  BOOL v74 = (void)v88 == v70 && *((void *)&v88 + 1) == v71;
  BOOL v75 = v74 && (void)v89 == v72;
  if (v75 && *((void *)&v89 + 1) == v73) {
    return 1;
  }
  uint64_t v85 = 0;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  if (sub_244D15EB4(&v81, a3, *(uint64_t **)(a1 + 256), (int)v3)
    || (sub_244D170B4((uint64_t *)&v81, *(int *)(a1 + 328), *(uint64_t **)(a1 + 320), *(int *)(a1 + 328)) & 0x80000000) == 0)
  {
    return 0;
  }
  long long v88 = v81;
  long long v89 = v82;
  sub_244D41858((uint64_t *)&v88, (unint64_t *)&v88, (unint64_t *)v90);
  BOOL v77 = (void)v88 == (void)v86 && *((void *)&v88 + 1) == *((void *)&v86 + 1);
  BOOL v78 = v77 && (void)v89 == (void)v87;
  return v78 && *((void *)&v89 + 1) == *((void *)&v87 + 1);
}

uint64_t *sub_244D41858(uint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4 = *a2;
  unint64_t v3 = a2[1];
  unint64_t v6 = a3[2];
  unint64_t v5 = a3[3];
  unint64_t v7 = v5 * *a2;
  unint64_t v8 = v6 * *a2;
  uint64_t v9 = (v6 * (unsigned __int128)*a2) >> 64;
  unint64_t v11 = *a3;
  unint64_t v10 = a3[1];
  uint64_t v12 = (v10 * (unsigned __int128)*a2) >> 64;
  unint64_t v13 = v10 * *a2;
  uint64_t v14 = (v11 * (unsigned __int128)*a2) >> 64;
  unint64_t v15 = v11 * *a2;
  uint64_t v16 = (v15 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  uint64_t v17 = (__PAIR128__(0xFFFFFFFFLL, -1) * v15) >> 64;
  if (__CFADD__((v15 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v15)) {
    ++v16;
  }
  uint64_t v18 = v14 + v13;
  BOOL v30 = __CFADD__(__CFADD__(v14, v13), v12) | __CFADD__(v8, __CFADD__(v14, v13) + v12);
  unint64_t v19 = v8 + __CFADD__(v14, v13) + v12;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v21 = v9 + v7 + v30 - 0xFFFFFFFF * v15;
  unint64_t v22 = v13 + __CFADD__(-(uint64_t)(v11 * v4), v15) + v14 + v17;
  uint64_t v23 = v16
      + (__CFADD__(__CFADD__(-(uint64_t)(v11 * v4), v15), v18) | __CFADD__(v17, __CFADD__(-(uint64_t)(v11 * v4), v15)+ v18))+ v19;
  unint64_t v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v26 = (v11 * (unsigned __int128)v3) >> 64;
  uint64_t v27 = v6 * v3 + __CFADD__(v26, v10 * v3) + ((v10 * (unsigned __int128)v3) >> 64);
  unint64_t v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unsigned long long v29 = __PAIR128__(v10 * v3, v22) + v11 * (unsigned __int128)v3;
  BOOL v30 = __CFADD__(__CFADD__(v22, v11 * v3), (__PAIR128__(v10, v11) * v3) >> 64) | __CFADD__(v23, __CFADD__(v22, v11 * v3)+ ((__PAIR128__(v10, v11) * v3) >> 64));
  unint64_t v31 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  if (v30) {
    uint64_t v32 = v27 + 1;
  }
  else {
    uint64_t v32 = v6 * v3 + __CFADD__(v26, v10 * v3) + ((v10 * (unsigned __int128)v3) >> 64);
  }
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v25);
  uint64_t v33 = v21
      + (__CFADD__(__CFADD__(v22, v11 * v3), (__PAIR128__(v10, v11) * v3) >> 64) | __CFADD__(v23, __CFADD__(v22, v11 * v3) + ((__PAIR128__(v10, v11) * v3) >> 64)))
      + v32;
  uint64_t v34 = (v5 * (unsigned __int128)v3) >> 64;
  unint64_t v35 = v5 * v3;
  uint64_t v36 = (v6 * (unsigned __int128)v3) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v28);
  BOOL v39 = v30;
  char v37 = __CFADD__(v30, v36) | __CFADD__(v35, v30 + v36);
  unint64_t v38 = v35 + v39 + v36;
  if (v37) {
    ++v34;
  }
  uint64_t v40 = (v5 * (unsigned __int128)v4) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  uint64_t v43 = v37;
  char v41 = __CFADD__(v37, v9) | __CFADD__(v7, v37 + v9);
  unint64_t v42 = v7 + v43 + v9;
  if (v41) {
    uint64_t v44 = v40 + 1;
  }
  else {
    uint64_t v44 = v40;
  }
  uint64_t v45 = (v15 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v24);
  if (v41) {
    uint64_t v46 = v21 + 1;
  }
  else {
    uint64_t v46 = v21;
  }
  uint64_t v48 = __CFADD__(v41, v42) | __CFADD__(0xFFFFFFFF00000001 * v15, v41 + v42);
  uint64_t v47 = v44 + v48 + v45;
  uint64_t v51 = __CFADD__(v48, v45) | __CFADD__(v44, v48 + v45);
  BOOL v49 = __CFADD__(v51, v34);
  uint64_t v50 = v51 + v34;
  BOOL v52 = __CFADD__(v51, v34);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v31);
  uint64_t v54 = __CFADD__(v49, v27) | __CFADD__(v46, v49 + v27);
  unint64_t v53 = v47 + v54 + v38;
  uint64_t v55 = (__CFADD__(v54, v38) | __CFADD__(v47, v54 + v38)) + v50;
  unint64_t v56 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v57 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v58 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v29) >> 64;
  uint64_t v59 = v23 + __CFADD__(-(uint64_t)v29, (void)v29) + *((void *)&v29 + 1);
  BOOL v30 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v29, (void)v29), *((void *)&v29 + 1) + v23) | __CFADD__(v58, __CFADD__(-(uint64_t)v29, (void)v29) + *((void *)&v29 + 1) + v23), v33);
  uint64_t v60 = (__CFADD__(__CFADD__(-(uint64_t)v29, (void)v29), *((void *)&v29 + 1) + v23) | __CFADD__(v58, __CFADD__(-(uint64_t)v29, (void)v29) + *((void *)&v29 + 1) + v23))
      + v33;
  uint64_t v61 = v30;
  unint64_t v62 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v63 = ((unint64_t)v29 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v30 = __CFADD__(__CFADD__(v57, 0xFFFFFFFF * v29), v60) | __CFADD__(v63, (__PAIR128__(v60, v57)+ (unint64_t)(0xFFFFFFFF * v29)) >> 64);
  uint64_t v64 = v63 + ((__PAIR128__(v60, v57) + (unint64_t)(0xFFFFFFFF * v29)) >> 64);
  unint64_t v65 = v61 + v30 - 0xFFFFFFFF * v29;
  if (__CFADD__(v30, 0xFFFFFFFF00000001 * v29) | __CFADD__(v61, v30 - 0xFFFFFFFF * v29)) {
    uint64_t v66 = 1;
  }
  else {
    uint64_t v66 = 0;
  }
  BOOL v30 = __CFADD__(v65, v53);
  uint64_t v69 = (__PAIR128__(v62, v65) + v53) >> 64;
  unint64_t v67 = v65 + v53;
  BOOL v30 = __CFADD__(v30, v62) | __CFADD__(v66, v69);
  uint64_t v68 = v66 + v69;
  uint64_t v70 = v30;
  BOOL v71 = __CFADD__(v68, v55);
  uint64_t v72 = v68 + v55;
  if (v71) {
    ++v70;
  }
  unint64_t v73 = v59 + ((__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v29) >> 64);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v56);
  uint64_t v74 = v52 + v71 + v70;
  unint64_t v76 = a2[2];
  unint64_t v75 = a2[3];
  uint64_t v77 = (v5 * (unsigned __int128)v76) >> 64;
  unint64_t v78 = v5 * v76;
  uint64_t v79 = (v6 * (unsigned __int128)v76) >> 64;
  unint64_t v80 = v6 * v76;
  uint64_t v81 = (v10 * (unsigned __int128)v76) >> 64;
  unint64_t v82 = v10 * v76;
  unint64_t v83 = v11 * v76;
  unint64_t v84 = (v11 * (unsigned __int128)v76) >> 64;
  unint64_t v85 = v84 + v82;
  BOOL v30 = __CFADD__(__CFADD__(v84, v82), v81) | __CFADD__(v80, __CFADD__(v84, v82) + v81);
  unint64_t v86 = v80 + __CFADD__(v84, v82) + v81;
  uint64_t v88 = v30 + v79;
  BOOL v30 = __CFADD__(v30, v79) | __CFADD__(v78, v88);
  uint64_t v87 = v78 + v88;
  if (v30) {
    ++v77;
  }
  unsigned long long v89 = __PAIR128__(v84, v73) + __PAIR128__(v82, v83);
  uint64_t v90 = ((__PAIR128__(v84, v73) + __PAIR128__(v82, v83)) >> 64) + v64;
  unint64_t v92 = (__CFADD__(__CFADD__(v73, v83), v85) | __CFADD__(v64, __CFADD__(v73, v83) + v85)) + v86;
  BOOL v30 = __CFADD__(__CFADD__(__CFADD__(v73, v83), v85) | __CFADD__(v64, __CFADD__(v73, v83) + v85), v86) | __CFADD__(v67, v92);
  unint64_t v91 = v67 + v92;
  uint64_t v94 = v30 + v87;
  BOOL v30 = __CFADD__(v30, v87) | __CFADD__(v72, v94);
  uint64_t v93 = v72 + v94;
  uint64_t v95 = v77 + v30 + v74;
  unint64_t v96 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v97 = 0xFFFFFFFF00000001 * (v73 + v83);
  uint64_t v98 = v64 + __CFADD__(-(uint64_t)v89, (void)v89) + *((void *)&v89 + 1);
  unint64_t v99 = (__CFADD__(__CFADD__(-(uint64_t)v89, (void)v89), v90) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (v73 + v83)) >> 64, __CFADD__(-(uint64_t)v89, (void)v89)+ v90))+ v91;
  BOOL v30 = __CFADD__(((v73 + v83) * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * (v73 + v83));
  uint64_t v100 = (__PAIR128__(0xFFFFFFFFLL, -1) * (v73 + v83)) >> 64;
  uint64_t v101 = ((v73 + v83) * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v102 = ((v73 + v83) * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v104 = v30;
  BOOL v30 = __CFADD__(v30, v99);
  unint64_t v103 = v104 + v99;
  v30 |= __CFADD__(v102, v103);
  v103 += v102;
  unint64_t v106 = v30 + v97;
  unint64_t v105 = *((void *)&v89 + 1) + v106;
  if (__CFADD__(v30, v97) | __CFADD__(*((void *)&v89 + 1), v106)) {
    uint64_t v107 = 1;
  }
  else {
    uint64_t v107 = 0;
  }
  BOOL v30 = __CFADD__(v105, v93);
  uint64_t v108 = v105 + v93;
  uint64_t v109 = v107 + v30 + v101;
  if (__CFADD__(v30, v101) | __CFADD__(v107, v30 + v101)) {
    uint64_t v110 = 1;
  }
  else {
    uint64_t v110 = 0;
  }
  BOOL v111 = __CFADD__(v109, v95);
  uint64_t v112 = v109 + v95;
  if (v111) {
    uint64_t v113 = v110 + 1;
  }
  else {
    uint64_t v113 = v110;
  }
  uint64_t v114 = v98 + v100;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v96);
  if (v111) {
    ++v113;
  }
  uint64_t v115 = (v5 * (unsigned __int128)v75) >> 64;
  unint64_t v116 = v5 * v75;
  uint64_t v117 = (v6 * (unsigned __int128)v75) >> 64;
  unint64_t v118 = v6 * v75;
  uint64_t v119 = (v10 * (unsigned __int128)v75) >> 64;
  unint64_t v120 = v10 * v75;
  unint64_t v121 = v11 * v75;
  uint64_t v122 = (v11 * (unsigned __int128)v75) >> 64;
  uint64_t v123 = v122 + v120;
  BOOL v30 = __CFADD__(__CFADD__(v122, v120), v119) | __CFADD__(v118, __CFADD__(v122, v120) + v119);
  unint64_t v124 = v118 + __CFADD__(v122, v120) + v119;
  uint64_t v126 = v30 + v117;
  BOOL v30 = __CFADD__(v30, v117) | __CFADD__(v116, v126);
  uint64_t v125 = v116 + v126;
  if (v30) {
    ++v115;
  }
  BOOL v30 = __CFADD__(v114, v121);
  unint64_t v127 = v114 + v121;
  unint64_t v128 = v120 + v30 + v122;
  unint64_t v129 = v128 + v103;
  uint64_t v131 = __CFADD__(v30, v123) | __CFADD__(v103, v30 + v123);
  BOOL v30 = __CFADD__(v131, v124);
  uint64_t v130 = v131 + v124;
  v30 |= __CFADD__(v108, v130);
  v130 += v108;
  BOOL v133 = v30;
  BOOL v30 = __CFADD__(v30, v125);
  uint64_t v132 = v133 + v125;
  v30 |= __CFADD__(v112, v132);
  v132 += v112;
  uint64_t v134 = (v127 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  unint64_t v135 = v115 + v30 + v113;
  unint64_t v136 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v137 = 0xFFFFFFFF00000001 * v127;
  uint64_t v138 = 0xFFFFFFFF * v127;
  uint64_t v139 = (__PAIR128__(0xFFFFFFFFLL, -1) * v127) >> 64;
  unint64_t v140 = v103 + __CFADD__(-(uint64_t)v127, v127) + v128;
  BOOL v30 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v127, v127), v129) | __CFADD__(v139, __CFADD__(-(uint64_t)v127, v127) + v129), v130);
  uint64_t v141 = (__CFADD__(__CFADD__(-(uint64_t)v127, v127), v129) | __CFADD__(v139, __CFADD__(-(uint64_t)v127, v127) + v129))+ v130;
  uint64_t v142 = v30;
  BOOL v30 = __CFADD__(v134, v138);
  uint64_t v143 = v134 + v138;
  uint64_t v144 = (v127 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v145 = (v127 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v147 = v30;
  BOOL v30 = __CFADD__(v30, v141);
  unint64_t v146 = v147 + v141;
  v30 |= __CFADD__(v145, v146);
  v146 += v145;
  unint64_t v149 = v30 + v137;
  BOOL v30 = __CFADD__(v30, v137) | __CFADD__(v142, v149);
  unint64_t v148 = v142 + v149;
  uint64_t v150 = v30;
  BOOL v30 = __CFADD__(v148, v132);
  unint64_t v151 = v148 + v132;
  uint64_t v152 = v150 + v30 + v144;
  if (__CFADD__(v30, v144) | __CFADD__(v150, v30 + v144)) {
    uint64_t v153 = 1;
  }
  else {
    uint64_t v153 = 0;
  }
  BOOL v154 = __CFADD__(v152, v135);
  unint64_t v155 = v152 + v135;
  if (v154) {
    ++v153;
  }
  uint64_t v156 = v140 + v143;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v136);
  if (v154) {
    unint64_t v157 = v153 + 1;
  }
  else {
    unint64_t v157 = v153;
  }
  unint64_t v159 = v146 - (1 - __CFADD__(v156, 1));
  unint64_t v158 = (v146 - __PAIR128__(v138, (1 - __CFADD__(v156, 1)))) >> 64;
  unsigned long long v160 = v155
       - __PAIR128__(v135, -(uint64_t)((v151- __PAIR128__(v158, (1 - (__CFADD__(v159, 0xFFFFFFFF00000001) + v158)))) >> 64));
  if (1
     - (__CFADD__((void)v160, 0xFFFFFFFFLL)
      + BYTE8(v160))
     + (v157 < (1 - (__CFADD__((void)v160, 0xFFFFFFFFLL) + BYTE8(v160)))))
  {
    uint64_t v161 = 0;
  }
  else
  {
    uint64_t v161 = -1;
  }
  if (1
     - (__CFADD__((void)v160, 0xFFFFFFFFLL)
      + BYTE8(v160))
     + (v157 < (1 - (__CFADD__((void)v160, 0xFFFFFFFFLL) + BYTE8(v160)))))
  {
    uint64_t v162 = -1;
  }
  else
  {
    uint64_t v162 = 0;
  }
  *double result = v161 & (v156 + 1) | v162 & v156;
  result[1] = v161 & (v159 - 0xFFFFFFFF) | v162 & v146;
  result[2] = v161 & (v151 - (1 - (__CFADD__(v159, 0xFFFFFFFF00000001) + v158))) | v162 & v151;
  result[3] = v161 & (v160 + 0xFFFFFFFF) | v162 & v155;
  return result;
}

uint64_t *sub_244D41BF4(uint64_t *result, unint64_t *a2)
{
  unint64_t v3 = a2[2];
  unint64_t v2 = a2[3];
  unint64_t v5 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v6 = (*a2 * (unsigned __int128)v2) >> 64;
  unint64_t v7 = *a2 * v2;
  unint64_t v8 = (*a2 * (unsigned __int128)v3) >> 64;
  unint64_t v9 = *a2 * v3;
  unint64_t v10 = (v5 * (unsigned __int128)v4) >> 64;
  unint64_t v11 = v5 * v4;
  uint64_t v12 = v5 * v5;
  uint64_t v13 = (v5 * (unsigned __int128)v5) >> 64;
  uint64_t v14 = (__PAIR128__(v4, v5) * v5) >> 64;
  unint64_t v15 = v10 + __CFADD__(v13, v5 * v4) + v9;
  unint64_t v16 = v8
      + (__CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9))
      + v7;
  if (__CFADD__(__CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9), v7) | __CFADD__(v8, (__CFADD__(__CFADD__(v13, v5 * v4), v9) | __CFADD__(v10, __CFADD__(v13, v5 * v4) + v9))+ v7))unint64_t v17 = v6 + 1; {
  else
  }
    unint64_t v17 = v6;
  uint64_t v18 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v19 = 0xFFFFFFFFLL * v12;
  uint64_t v20 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v21 = -(uint64_t)(v5 * v5);
  unint64_t v22 = v11 + __CFADD__(v21, v12) + v13;
  unint64_t v23 = (__CFADD__(__CFADD__(v21, v12), v14) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v12) >> 64, __CFADD__(v21, v12) + v14))+ v15;
  uint64_t v24 = __CFADD__(__CFADD__(__CFADD__(v21, v12), v14) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v12) >> 64, __CFADD__(v21, v12) + v14), v15);
  BOOL v72 = __CFADD__(v16, 0xFFFFFFFF00000001 * v12);
  unint64_t v25 = v16 - 0xFFFFFFFFLL * v12;
  uint64_t v26 = v72;
  BOOL v72 = __CFADD__(v18, v17);
  uint64_t v27 = v18 + v17;
  uint64_t v28 = v72;
  uint64_t v29 = (v2 * (unsigned __int128)v4) >> 64;
  unint64_t v30 = v2 * v4;
  uint64_t v31 = (v3 * (unsigned __int128)v4) >> 64;
  unint64_t v32 = v3 * v4;
  unint64_t v33 = v4 * v4;
  unsigned long long v34 = __PAIR128__(v3 * v4, v10) + v4 * (unsigned __int128)v4;
  uint64_t v36 = __CFADD__(__CFADD__(v10, v4 * v4), v3 * v4) | __CFADD__((v4 * (unsigned __int128)v4) >> 64, __CFADD__(v10, v4 * v4) + v3 * v4);
  uint64_t v35 = v31 + v36 + v2 * v4;
  if (__CFADD__(v36, v2 * v4) | __CFADD__(v31, v36 + v2 * v4)) {
    uint64_t v37 = v29 + 1;
  }
  else {
    uint64_t v37 = (v2 * (unsigned __int128)v4) >> 64;
  }
  BOOL v72 = __CFADD__(v20, v19);
  unint64_t v38 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v39 = 0xFFFFFFFFLL * v12;
  uint64_t v40 = ((unint64_t)v12 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  unint64_t v41 = v22 + v20 + v19;
  BOOL v72 = __CFADD__(v72, v23) | __CFADD__(v40, (__PAIR128__(v23, v38) + (unint64_t)v39) >> 64);
  uint64_t v42 = v40 + ((__PAIR128__(v23, v38) + (unint64_t)v39) >> 64);
  BOOL v44 = v72;
  BOOL v72 = __CFADD__(v72, v25);
  unint64_t v43 = v44 + v25;
  v72 |= __CFADD__(v24, v43);
  v43 += v24;
  BOOL v46 = v72;
  BOOL v72 = __CFADD__(v72, v27);
  uint64_t v45 = v46 + v27;
  v72 |= __CFADD__(v26, v45);
  v45 += v26;
  BOOL v48 = v72;
  BOOL v72 = __CFADD__(v72, v37);
  uint64_t v47 = v48 + v37;
  v72 |= __CFADD__(v28, v47);
  v47 += v28;
  uint64_t v49 = v72;
  unsigned long long v50 = __PAIR128__(v10, v41) + __PAIR128__(v33, v11);
  uint64_t v51 = ((__PAIR128__(v10, v41) + __PAIR128__(v33, v11)) >> 64) + v42;
  uint64_t v53 = (__CFADD__(__CFADD__(v41, v11), (void)v34) | __CFADD__(v42, __CFADD__(v41, v11) + (void)v34))+ *((void *)&v34 + 1);
  BOOL v72 = __CFADD__(__CFADD__(__CFADD__(v41, v11), (void)v34) | __CFADD__(v42, __CFADD__(v41, v11) + (void)v34), *((void *)&v34 + 1)) | __CFADD__(v43, v53);
  uint64_t v52 = v43 + v53;
  BOOL v55 = v72;
  BOOL v72 = __CFADD__(v72, v35);
  uint64_t v54 = v55 + v35;
  v72 |= __CFADD__(v45, v54);
  v54 += v45;
  uint64_t v56 = v72 + v47;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  unint64_t v58 = 0xFFFFFFFF00000001 * (v41 + v11);
  uint64_t v59 = (__PAIR128__(0xFFFFFFFFLL, -1) * (v41 + v11)) >> 64;
  uint64_t v60 = v42 + __CFADD__(-(uint64_t)v50, (void)v50) + *((void *)&v50 + 1);
  unint64_t v61 = (__CFADD__(__CFADD__(-(uint64_t)v50, (void)v50), v51) | __CFADD__(v59, __CFADD__(-(uint64_t)v50, (void)v50)+ v51))+ v52;
  BOOL v62 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v50, (void)v50), v51) | __CFADD__(v59, __CFADD__(-(uint64_t)v50, (void)v50)+ v51), v52);
  unint64_t v63 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v64 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v65 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v72 = __CFADD__(__CFADD__(v63, 0xFFFFFFFF * v50), v61) | __CFADD__(v65, (__PAIR128__(v61, v63)+ (unint64_t)(0xFFFFFFFF * v50)) >> 64);
  uint64_t v66 = v65 + ((__PAIR128__(v61, v63) + (unint64_t)(0xFFFFFFFF * v50)) >> 64);
  unint64_t v67 = v62 + v72 + v58;
  if (__CFADD__(v72, v58) | __CFADD__(v62, v72 + v58)) {
    uint64_t v68 = 1;
  }
  else {
    uint64_t v68 = 0;
  }
  BOOL v72 = __CFADD__(v67, v54);
  uint64_t v69 = v67 + v54;
  uint64_t v70 = v68 + v72 + v64;
  if (__CFADD__(v72, v64) | __CFADD__(v68, v72 + v64)) {
    uint64_t v71 = 1;
  }
  else {
    uint64_t v71 = 0;
  }
  BOOL v72 = __CFADD__(v70, v56);
  uint64_t v73 = v70 + v56;
  if (v72) {
    uint64_t v74 = v71 + 1;
  }
  else {
    uint64_t v74 = v71;
  }
  unint64_t v75 = v60 + v63 + 0xFFFFFFFF * v50;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  uint64_t v76 = v49 + v72 + v74;
  uint64_t v77 = (v2 * (unsigned __int128)v3) >> 64;
  unint64_t v78 = v2 * v3;
  uint64_t v79 = (v3 * (unsigned __int128)v3) >> 64;
  unint64_t v80 = v3 * v3;
  unint64_t v81 = v8 + v32;
  BOOL v72 = __CFADD__(__CFADD__(v8, v32), v80);
  unint64_t v82 = __CFADD__(v8, v32) + v80;
  v72 |= __CFADD__(v31, v82);
  v82 += v31;
  uint64_t v83 = v79 + v72 + v78;
  if (__CFADD__(v72, v78) | __CFADD__(v79, v72 + v78)) {
    uint64_t v84 = v77 + 1;
  }
  else {
    uint64_t v84 = v77;
  }
  unsigned long long v85 = __PAIR128__(v8, v75) + __PAIR128__(v32, v9);
  uint64_t v86 = ((__PAIR128__(v8, v75) + __PAIR128__(v32, v9)) >> 64) + v66;
  unint64_t v88 = (__CFADD__(__CFADD__(v75, v9), v81) | __CFADD__(v66, __CFADD__(v75, v9) + v81)) + v82;
  BOOL v72 = __CFADD__(__CFADD__(__CFADD__(v75, v9), v81) | __CFADD__(v66, __CFADD__(v75, v9) + v81), v82) | __CFADD__(v69, v88);
  uint64_t v87 = v69 + v88;
  uint64_t v90 = v72 + v83;
  BOOL v72 = __CFADD__(v72, v83) | __CFADD__(v73, v90);
  uint64_t v89 = v73 + v90;
  uint64_t v91 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  uint64_t v92 = v84 + v72 + v76;
  unint64_t v93 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v94 = 0xFFFFFFFF * v85;
  uint64_t v95 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v85) >> 64;
  BOOL v72 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v85, (void)v85), v86) | __CFADD__(v95, __CFADD__(-(uint64_t)v85, (void)v85)+ v86), v87);
  uint64_t v96 = (__CFADD__(__CFADD__(-(uint64_t)v85, (void)v85), v86) | __CFADD__(v95, __CFADD__(-(uint64_t)v85, (void)v85)+ v86))+ v87;
  uint64_t v97 = v72;
  BOOL v72 = __CFADD__(v91, v94);
  uint64_t v98 = v91 + v94;
  uint64_t v99 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v100 = ((unint64_t)v85 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v102 = v72;
  BOOL v72 = __CFADD__(v72, v96);
  uint64_t v101 = v102 + v96;
  v72 |= __CFADD__(v100, v101);
  v101 += v100;
  uint64_t v103 = v97 + v72 - 0xFFFFFFFF * v85;
  if (__CFADD__(v72, 0xFFFFFFFF00000001 * v85) | __CFADD__(v97, v72 - 0xFFFFFFFF * v85)) {
    uint64_t v104 = 1;
  }
  else {
    uint64_t v104 = 0;
  }
  BOOL v72 = __CFADD__(v103, v89);
  uint64_t v105 = v103 + v89;
  uint64_t v106 = v104 + v72 + v99;
  if (__CFADD__(v72, v99) | __CFADD__(v104, v72 + v99)) {
    uint64_t v107 = 1;
  }
  else {
    uint64_t v107 = 0;
  }
  BOOL v108 = __CFADD__(v106, v92);
  uint64_t v109 = v106 + v92;
  if (v108) {
    ++v107;
  }
  unint64_t v110 = v66 + __CFADD__(-(uint64_t)v85, (void)v85) + *((void *)&v85 + 1) + v98;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v93);
  if (v108) {
    uint64_t v111 = v107 + 1;
  }
  else {
    uint64_t v111 = v107;
  }
  uint64_t v112 = (v2 * (unsigned __int128)v2) >> 64;
  unint64_t v113 = v2 * v2;
  unint64_t v114 = v6 + v30;
  BOOL v72 = __CFADD__(__CFADD__(v6, v30), v78) | __CFADD__(v29, __CFADD__(v6, v30) + v78);
  uint64_t v115 = v29 + __CFADD__(v6, v30) + v78;
  BOOL v117 = v72;
  BOOL v72 = __CFADD__(v72, v113);
  unint64_t v116 = v117 + v113;
  v72 |= __CFADD__(v77, v116);
  v116 += v77;
  if (v72) {
    ++v112;
  }
  unsigned long long v118 = __PAIR128__(v6, v110) + __PAIR128__(v30, v7);
  uint64_t v119 = ((__PAIR128__(v6, v110) + __PAIR128__(v30, v7)) >> 64) + v101;
  uint64_t v121 = (__CFADD__(__CFADD__(v110, v7), v114) | __CFADD__(v101, __CFADD__(v110, v7) + v114)) + v115;
  BOOL v72 = __CFADD__(__CFADD__(__CFADD__(v110, v7), v114) | __CFADD__(v101, __CFADD__(v110, v7) + v114), v115) | __CFADD__(v105, v121);
  uint64_t v120 = v105 + v121;
  BOOL v123 = v72;
  BOOL v72 = __CFADD__(v72, v116);
  unint64_t v122 = v123 + v116;
  v72 |= __CFADD__(v109, v122);
  v122 += v109;
  unint64_t v124 = v112 + v72 + v111;
  unint64_t v125 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  uint64_t v126 = v101 + __CFADD__(-(uint64_t)v118, (void)v118) + *((void *)&v118 + 1);
  uint64_t v127 = (__CFADD__(__CFADD__(-(uint64_t)v118, (void)v118), v119) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v118) >> 64, __CFADD__(-(uint64_t)v118, (void)v118)+ v119))+ v120;
  unint64_t v128 = ((unint64_t)v118 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  uint64_t v129 = ((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  BOOL v72 = __CFADD__(__CFADD__(((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v118), v127);
  unint64_t v130 = __CFADD__(((unint64_t)v118 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v118) + v127;
  v72 |= __CFADD__(v129, v130);
  v130 += v129;
  uint64_t v132 = v72 - 0xFFFFFFFF * v118;
  unint64_t v131 = *((void *)&v118 + 1) + v132;
  if (__CFADD__(v72, 0xFFFFFFFF00000001 * v118) | __CFADD__(*((void *)&v118 + 1), v132)) {
    uint64_t v133 = 1;
  }
  else {
    uint64_t v133 = 0;
  }
  unint64_t v135 = v131 + v122;
  BOOL v72 = __CFADD__(__CFADD__(v131, v122), v128) | __CFADD__(v133, (__PAIR128__(v128, v131) + v122) >> 64);
  uint64_t v134 = v133 + ((__PAIR128__(v128, v131) + v122) >> 64);
  unint64_t v136 = v72;
  BOOL v137 = __CFADD__(v134, v124);
  unint64_t v138 = v134 + v124;
  if (v137) {
    ++v136;
  }
  uint64_t v139 = v126 + ((__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v118) >> 64);
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v125);
  if (v137) {
    ++v136;
  }
  unsigned long long v140 = v130 - __PAIR128__(0xFFFFFFFFLL * (uint64_t)v118, (1 - __CFADD__(v139, 1)));
  unint64_t v141 = v138
       - -(uint64_t)((v135
                                    - __PAIR128__(v124, (1- (__CFADD__((void)v140, 0xFFFFFFFF00000001)+ BYTE8(v140))))) >> 64);
  uint64_t v142 = -(uint64_t)(v136
                  + (v136 < (1
                                            - (__CFADD__(v141, 0xFFFFFFFFLL)
                                             + ((v138
                                               - __PAIR128__(v125, -(uint64_t)((v135- __PAIR128__(v124, (1- (__CFADD__((void)v140, 0xFFFFFFFF00000001)+ BYTE8(v140))))) >> 64))) >> 64)))));
  BOOL v143 = v142 == 0;
  if ((_BYTE)v142) {
    uint64_t v144 = 0;
  }
  else {
    uint64_t v144 = -1;
  }
  if (v143) {
    uint64_t v145 = 0;
  }
  else {
    uint64_t v145 = -1;
  }
  *double result = v144 & (v139 + 1) | v145 & v139;
  result[1] = v144 & (v140 - 0xFFFFFFFF) | v145 & v130;
  result[2] = v144 & (v135 - (1 - (__CFADD__((void)v140, 0xFFFFFFFF00000001) + BYTE8(v140)))) | v145 & v135;
  result[3] = v144 & (v141 + 0xFFFFFFFF) | v145 & v138;
  return result;
}

double sub_244D41F50(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, unint64_t *a5, unint64_t *a6, int a7, unint64_t *a8, unint64_t *a9, unint64_t *a10)
{
  uint64_t v227 = *MEMORY[0x263EF8340];
  long long v223 = 0u;
  unsigned long long v224 = 0u;
  unint64_t v12 = *a6;
  unint64_t v13 = a6[1];
  unint64_t v14 = a6[2];
  uint64_t v15 = a6[3];
  unint64_t v192 = v13 | *a6 | v14 | v15;
  unint64_t v16 = *a10;
  unint64_t v17 = a10[1];
  unint64_t v19 = a10[2];
  unint64_t v18 = a10[3];
  uint64_t v193 = v17 | *a10 | v19 | v18;
  long long v219 = 0u;
  long long v220 = 0u;
  sub_244D41BF4((uint64_t *)&v219, a6);
  long long v217 = 0u;
  long long v218 = 0u;
  long long v215 = 0u;
  long long v216 = 0u;
  long long v213 = 0u;
  unsigned long long v214 = 0u;
  if (a7)
  {
    long long v22 = *(_OWORD *)(a4 + 16);
    *((void *)&v24 + 1) = v13;
    *(void *)&long long v24 = v12;
    uint64_t v23 = v24 >> 63;
    long long v217 = *(_OWORD *)a4;
    long long v218 = v22;
    *((void *)&v24 + 1) = v14;
    *(void *)&long long v24 = v13;
    unint64_t v25 = v24 >> 63;
    *((void *)&v24 + 1) = v15;
    *(void *)&long long v24 = v14;
    unint64_t v26 = v24 >> 63;
    unsigned long long v27 = v26
        - __PAIR128__(v21, -(uint64_t)((v25- __PAIR128__(v20, (1 - __CFADD__(v23, 0xFFFFFFFF00000000)))) >> 64));
    if ((v15 < 0)
       + ((unint64_t)v15 >> 63 < (1 - (__CFADD__((void)v27, 0xFFFFFFFFLL) + BYTE8(v27)))))
    {
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v28 = -1;
    }
    if ((v15 < 0)
       + ((unint64_t)v15 >> 63 < (1 - (__CFADD__((void)v27, 0xFFFFFFFFLL) + BYTE8(v27)))))
    {
      uint64_t v29 = -1;
    }
    else
    {
      uint64_t v29 = 0;
    }
    *(void *)&long long v213 = v28 & ((2 * v12) | 1) | v29 & (2 * v12);
    *((void *)&v213 + 1) = v28 & (v23 - 0x100000000) | v29 & v23;
    *(void *)&unsigned long long v214 = v28 & (v25 - (1 - __CFADD__(v23, 0xFFFFFFFF00000000))) | v29 & v25;
    *((void *)&v214 + 1) = v28 & (v27 + 0xFFFFFFFF) | v29 & v26;
    uint64_t v31 = (int8x16_t *)a10;
    unint64_t v30 = a5;
    long long v32 = *((_OWORD *)a5 + 1);
    long long v215 = *(_OWORD *)a5;
    long long v216 = v32;
  }
  else
  {
    long long v225 = 0uLL;
    long long v226 = 0uLL;
    sub_244D41BF4((uint64_t *)&v225, a10);
    unint64_t v33 = sub_244D41858((uint64_t *)&v217, (unint64_t *)a4, (unint64_t *)&v225);
    unint64_t v35 = v16 + v12;
    unint64_t v36 = v13 + __CFADD__(v16, v12) + v17;
    unint64_t v37 = v14 + (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17)) + v19;
    uint64_t v38 = v15
        + (__CFADD__(__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17), v19) | __CFADD__(v14, (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12)+ v17))+ v19))+ v18;
    if (__CFADD__(__CFADD__(__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17), v19) | __CFADD__(v14, (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12)+ v17))+ v19), v18) | __CFADD__(v15, (__CFADD__(__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17), v19) | __CFADD__(v14, (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17))+ v19))+ v18))unint64_t v39 = 1; {
    else
    }
      unint64_t v39 = 0;
    unsigned long long v40 = v36 - __PAIR128__(v34, (1 - __CFADD__(v35, 1)));
    unsigned long long v41 = (unint64_t)v38
        - __PAIR128__((unint64_t)v33, -(uint64_t)((v37- __PAIR128__(0xFFFFFFFF00000001, (1- (__CFADD__((void)v40, 0xFFFFFFFF00000001)+ BYTE8(v40))))) >> 64));
    uint64_t v42 = -(uint64_t)(v39 + (v39 < (1 - (__CFADD__((void)v41, 0xFFFFFFFFLL) + BYTE8(v41)))));
    BOOL v43 = v42 == 0;
    if ((_BYTE)v42) {
      uint64_t v44 = 0;
    }
    else {
      uint64_t v44 = -1;
    }
    if (v43) {
      uint64_t v45 = 0;
    }
    else {
      uint64_t v45 = -1;
    }
    *(void *)&long long v213 = v44 & (v35 + 1) | v45 & v35;
    *((void *)&v213 + 1) = v44 & (v40 - 0xFFFFFFFF) | v45 & v36;
    *(void *)&unsigned long long v214 = v44 & (v37 - (1 - (__CFADD__((void)v40, 0xFFFFFFFF00000001) + BYTE8(v40)))) | v45 & v37;
    *((void *)&v214 + 1) = v44 & (v41 + 0xFFFFFFFF) | v45 & v38;
    sub_244D41BF4((uint64_t *)&v213, (unint64_t *)&v213);
    uint64_t v46 = v213 - v219;
    unint64_t v47 = *((void *)&v219 + 1) + -(uint64_t)(((unint64_t)v213 - __PAIR128__(v219, v219)) >> 64);
    unint64_t v48 = *((void *)&v213 + 1) - v47;
    BOOL v55 = __CFADD__((void)v220, -(uint64_t)((*((unint64_t *)&v213 + 1) - __PAIR128__(v47, v47)) >> 64));
    unint64_t v49 = v220 + -(uint64_t)((*((unint64_t *)&v213 + 1) - __PAIR128__(v47, v47)) >> 64);
    uint64_t v50 = v55;
    uint64_t v51 = v214 - v49;
    BOOL v55 = __CFADD__(*((void *)&v220 + 1), -(uint64_t)(((unint64_t)v214 - __PAIR128__(v50, v49)) >> 64));
    unint64_t v52 = *((void *)&v220 + 1) + -(uint64_t)(((unint64_t)v214 - __PAIR128__(v50, v49)) >> 64);
    uint64_t v53 = v55;
    unsigned long long v54 = *((unint64_t *)&v214 + 1) - __PAIR128__(v53, v52);
    BOOL v55 = __CFADD__(__CFADD__(v46, *((void *)&v54 + 1)), v48) | __CFADD__(DWORD2(v54), __CFADD__(v46, *((void *)&v54 + 1)) + v48);
    uint64_t v56 = DWORD2(v54) + __CFADD__(v46, *((void *)&v54 + 1)) + v48;
    unint64_t v57 = v54 + __CFADD__(v55, v51) + (*((void *)&v54 + 1) & 0xFFFFFFFF00000001);
    char v59 = ((unint64_t)(v46 + *((void *)&v54 + 1)) - __PAIR128__(v225, v225)) >> 64;
    uint64_t v58 = v46 + *((void *)&v54 + 1) - v225;
    unsigned long long v60 = (unint64_t)v56
        - __PAIR128__(*((void *)&v225 + 1) + (unint64_t)-v59, *((void *)&v225 + 1) + (unint64_t)-v59);
    char v61 = ((unint64_t)v55
         + v51
         - __PAIR128__((unint64_t)v226 + -BYTE8(v60), (unint64_t)v226 + -BYTE8(v60))) >> 64;
    if (((v57
                          - __PAIR128__(*((void *)&v226 + 1) + (unint64_t)-v61, *((void *)&v226 + 1) + (unint64_t)-v61)) >> 64))uint64_t v62 = -1;
    else {
      uint64_t v62 = 0;
    }
    uint64_t v63 = __CFADD__(v58, v62) + (void)v60;
    *(void *)&long long v213 = v58 + v62;
    *((void *)&v213 + 1) = v62 + v63;
    unsigned long long v214 = __PAIR128__(v62 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v58, v62), (void)v60) | __CFADD__(v62, v63))+ __PAIR128__(v57- (*((void *)&v226 + 1)+ -(uint64_t)(((unint64_t)v55+ v51- __PAIR128__((unint64_t)v226 + -BYTE8(v60), (unint64_t)v226 + -BYTE8(v60))) >> 64)), v55 + v51 - ((unint64_t)v226 + -BYTE8(v60)));
    sub_244D41858((uint64_t *)&v215, a10, (unint64_t *)&v225);
    unint64_t v30 = a5;
    sub_244D41858((uint64_t *)&v215, (unint64_t *)&v215, a5);
    uint64_t v31 = (int8x16_t *)a10;
  }
  uint64_t v64 = a4;
  int8x16_t v221 = 0u;
  int8x16_t v222 = 0u;
  long long v211 = 0u;
  long long v212 = 0u;
  sub_244D41858((uint64_t *)&v211, a8, (unint64_t *)&v219);
  uint64_t v65 = v211 - v217;
  unint64_t v66 = *((void *)&v217 + 1) + -(uint64_t)(((unint64_t)v211 - __PAIR128__(v217, v217)) >> 64);
  unint64_t v67 = *((void *)&v211 + 1) - v66;
  BOOL v55 = __CFADD__((void)v218, -(uint64_t)((*((unint64_t *)&v211 + 1) - __PAIR128__(v66, v66)) >> 64));
  unint64_t v68 = v218 + -(uint64_t)((*((unint64_t *)&v211 + 1) - __PAIR128__(v66, v66)) >> 64);
  uint64_t v69 = v55;
  unint64_t v71 = v212 - v68;
  char v70 = ((unint64_t)v212 - __PAIR128__(v69, v68)) >> 64;
  BOOL v55 = __CFADD__(*((void *)&v218 + 1), -v70);
  unint64_t v72 = *((void *)&v218 + 1) + -v70;
  uint64_t v73 = v55;
  unint64_t v74 = *((void *)&v212 + 1) - v72;
  if (((*((unint64_t *)&v212 + 1) - __PAIR128__(v73, v72)) >> 64)) {
    uint64_t v75 = -1;
  }
  else {
    uint64_t v75 = 0;
  }
  uint64_t v76 = v65 + v75;
  unint64_t v77 = v75 + __CFADD__(v65, v75) + v67;
  v209[0] = v65 + v75;
  v209[1] = v77;
  signed long long v78 = __PAIR128__(v75 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v65, v75), v67) | __CFADD__(v75, __CFADD__(v65, v75) + v67))+ __PAIR128__(v74, v71);
  unsigned long long v210 = __PAIR128__(v75 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v65, v75), v67) | __CFADD__(v75, __CFADD__(v65, v75) + v67))+ __PAIR128__(v74, v71);
  sub_244D41858(v221.i64, v209, (unint64_t *)&v213);
  memset(v208, 0, sizeof(v208));
  sub_244D41858((uint64_t *)v208, a6, (unint64_t *)&v219);
  long long v206 = 0u;
  long long v207 = 0u;
  uint64_t v79 = sub_244D41858((uint64_t *)&v206, a9, (unint64_t *)v208);
  uint64_t v81 = v206 - v215;
  unint64_t v82 = *((void *)&v215 + 1) + -(uint64_t)(((unint64_t)v206 - __PAIR128__(v215, v215)) >> 64);
  unint64_t v83 = *((void *)&v206 + 1) - v82;
  BOOL v55 = __CFADD__((void)v216, -(uint64_t)((*((unint64_t *)&v206 + 1) - __PAIR128__(v82, v82)) >> 64));
  unint64_t v84 = v216 + -(uint64_t)((*((unint64_t *)&v206 + 1) - __PAIR128__(v82, v82)) >> 64);
  uint64_t v85 = v55;
  unint64_t v86 = v207 - v84;
  BOOL v55 = __CFADD__(*((void *)&v216 + 1), -(uint64_t)(((unint64_t)v207 - __PAIR128__(v85, v84)) >> 64));
  unint64_t v87 = *((void *)&v216 + 1) + -(uint64_t)(((unint64_t)v207 - __PAIR128__(v85, v84)) >> 64);
  uint64_t v88 = v55;
  unint64_t v89 = *((void *)&v207 + 1) - v87;
  if (((*((unint64_t *)&v207 + 1) - __PAIR128__(v88, v87)) >> 64)) {
    uint64_t v90 = -1;
  }
  else {
    uint64_t v90 = 0;
  }
  BOOL v55 = __CFADD__(v81, v90);
  uint64_t v91 = v81 + v90;
  unint64_t v93 = __CFADD__(v81, v90) + v83;
  unint64_t v92 = v90 + v93;
  unint64_t v94 = __CFADD__(v55, v83) | __CFADD__(v90, v93);
  unint64_t v95 = v90 & 0xFFFFFFFF00000001;
  *((void *)&v97 + 1) = v92;
  *(void *)&long long v97 = v91;
  uint64_t v96 = v97 >> 63;
  *((void *)&v97 + 1) = v94 + v86;
  *(void *)&long long v97 = v92;
  unint64_t v98 = v97 >> 63;
  unint64_t v99 = (__int128)(__PAIR128__(v95, v94) + __PAIR128__(v89, v86)) >> 63;
  unint64_t v100 = v96 - 0x100000000;
  unint64_t v101 = v98 - (1 - __CFADD__(v96, 0xFFFFFFFF00000000));
  unsigned long long v102 = v99
       - __PAIR128__(v80, -(uint64_t)((v98- __PAIR128__((unint64_t)v79, (1 - __CFADD__(v96, 0xFFFFFFFF00000000)))) >> 64));
  if (((((__PAIR128__(v95, v94) + __PAIR128__(v89, v86)) >> 64) & 0x8000000000000000) != 0)
     + ((unint64_t)((__PAIR128__(v95, v94) + __PAIR128__(v89, v86)) >> 64) >> 63 < (1 - (__CFADD__((void)v102, 0xFFFFFFFFLL) + BYTE8(v102)))))
  {
    uint64_t v103 = 0;
  }
  else
  {
    uint64_t v103 = -1;
  }
  uint64_t v202 = v103 & ((2 * v91) | 1) | *((void *)&v102 + 1) & (2 * v91);
  uint64_t v203 = v103 & v100 | *((void *)&v102 + 1) & v96;
  uint64_t v204 = v103 & v101 | *((void *)&v102 + 1) & v98;
  uint64_t v205 = v103 & (v102 + 0xFFFFFFFF) | *((void *)&v102 + 1) & v99;
  unint64_t v104 = v77 | v76 | v78 | *((void *)&v78 + 1) | v203 | v202 | v204 | v205;
  uint64_t v105 = (uint64_t)((v104 - 1) & ~v104) >> 63;
  if ((((v193 - 1) & ~v193 | (v192 - 1) & ~v192) & 0x8000000000000000) != 0) {
    uint64_t v105 = 0;
  }
  if (v105)
  {
    sub_244D42A18(a1, a2, a3, (unint64_t *)a4, v30, a6);
  }
  else
  {
    *((void *)&v108 + 1) = v77;
    *(void *)&long long v108 = v76;
    uint64_t v107 = v108 >> 63;
    long long v225 = 0u;
    long long v226 = 0u;
    *((void *)&v108 + 1) = v78;
    *(void *)&long long v108 = v77;
    unint64_t v109 = v108 >> 63;
    unint64_t v110 = v78 >> 63;
    unsigned long long v111 = v110
         - __PAIR128__(v101, -(uint64_t)((v109- __PAIR128__(v100, (1 - __CFADD__(v107, 0xFFFFFFFF00000000)))) >> 64));
    if (1
       - (__CFADD__((void)v111, 0xFFFFFFFFLL)
        + BYTE8(v111))
       + (*((void *)&v78 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((void)v111, 0xFFFFFFFFLL)
                                                                           + BYTE8(v111)))))
    {
      uint64_t v112 = 0;
    }
    else
    {
      uint64_t v112 = -1;
    }
    if (1
       - (__CFADD__((void)v111, 0xFFFFFFFFLL)
        + BYTE8(v111))
       + (*((void *)&v78 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((void)v111, 0xFFFFFFFFLL)
                                                                           + BYTE8(v111)))))
    {
      uint64_t v113 = -1;
    }
    else
    {
      uint64_t v113 = 0;
    }
    v201[0] = v112 & ((2 * v76) | 1) | v113 & (2 * v76);
    v201[1] = v112 & (v107 - 0x100000000) | v113 & v107;
    v201[2] = v112 & (v109 - (1 - __CFADD__(v107, 0xFFFFFFFF00000000))) | v113 & v109;
    v201[3] = v112 & (v111 + 0xFFFFFFFF) | v113 & v110;
    sub_244D41BF4(v201, (unint64_t *)v201);
    long long v199 = 0u;
    long long v200 = 0u;
    sub_244D41858((uint64_t *)&v199, v209, (unint64_t *)v201);
    long long v197 = 0u;
    long long v198 = 0u;
    sub_244D41858((uint64_t *)&v197, (unint64_t *)&v217, (unint64_t *)v201);
    sub_244D41BF4((uint64_t *)&v225, (unint64_t *)&v202);
    uint64_t v114 = v225 - v199;
    unint64_t v115 = *((void *)&v199 + 1)
         + -(uint64_t)(((unint64_t)v225 - __PAIR128__(v199, v199)) >> 64);
    unint64_t v116 = *((void *)&v225 + 1) - v115;
    BOOL v55 = __CFADD__((void)v200, -(uint64_t)((*((unint64_t *)&v225 + 1) - __PAIR128__(v115, v115)) >> 64));
    unint64_t v117 = v200 + -(uint64_t)((*((unint64_t *)&v225 + 1) - __PAIR128__(v115, v115)) >> 64);
    uint64_t v118 = v55;
    unint64_t v120 = v226 - v117;
    char v119 = ((unint64_t)v226 - __PAIR128__(v118, v117)) >> 64;
    BOOL v55 = __CFADD__(*((void *)&v200 + 1), -v119);
    unint64_t v121 = *((void *)&v200 + 1) + -v119;
    uint64_t v122 = v55;
    if (((*((unint64_t *)&v226 + 1) - __PAIR128__(v122, v121)) >> 64)) {
      uint64_t v123 = -1;
    }
    else {
      uint64_t v123 = 0;
    }
    unint64_t v124 = v123 + __CFADD__(v114, v123) + v116;
    uint64_t v125 = v114 + v123 - v197;
    unsigned long long v126 = v124
         - __PAIR128__(v124, *((void *)&v197 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v114 + v123) - __PAIR128__(v120, v197)) >> 64));
    uint64_t v128 = ((__CFADD__(__CFADD__(v114, v123), v116) | __CFADD__(v123, __CFADD__(v114, v123) + v116))+ v120- __PAIR128__((unint64_t)v198 + -BYTE8(v126), (unint64_t)v198 + -BYTE8(v126))) >> 64;
    uint64_t v127 = (__CFADD__(__CFADD__(v114, v123), v116) | __CFADD__(v123, __CFADD__(v114, v123) + v116))+ v120- (v198+ -BYTE8(v126));
    unsigned long long v129 = ((__PAIR128__(v123 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v114, v123), v116) | __CFADD__(v123, __CFADD__(v114, v123) + v116))+ __PAIR128__(*((void *)&v226 + 1) - v121, v120)) >> 64)- __PAIR128__(*((void *)&v198 + 1) + (unint64_t)-(char)v128, *((void *)&v198 + 1) + (unint64_t)-(char)v128);
    unint64_t v130 = DWORD2(v129) + __CFADD__(v125, *((void *)&v129 + 1)) + (void)v126;
    unint64_t v131 = v129
         + __CFADD__(__CFADD__(__CFADD__(v125, *((void *)&v129 + 1)), (void)v126) | __CFADD__(DWORD2(v129), __CFADD__(v125, *((void *)&v129 + 1))+ (void)v126), v127)+ (*((void *)&v129 + 1) & 0xFFFFFFFF00000001);
    uint64_t v132 = v125 + *((void *)&v129 + 1) - v197;
    unsigned long long v133 = v130
         - __PAIR128__(v130, *((void *)&v197 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v125 + *((void *)&v129 + 1))- __PAIR128__(*((void *)&v129 + 1) & 0xFFFFFFFF00000001, v197)) >> 64));
    LOBYTE(v130) = ((unint64_t)(__CFADD__(__CFADD__(v125, *((void *)&v129 + 1)), (void)v126) | __CFADD__(DWORD2(v129), __CFADD__(v125, *((void *)&v129 + 1)) + (void)v126))
                  + v127
                  - __PAIR128__((unint64_t)v198 + -BYTE8(v133), (unint64_t)v198 + -BYTE8(v133))) >> 64;
    unint64_t v134 = (__CFADD__(__CFADD__(v125, *((void *)&v129 + 1)), (void)v126) | __CFADD__(DWORD2(v129), __CFADD__(v125, *((void *)&v129 + 1))+ (void)v126))+ v127- (v198+ -BYTE8(v133));
    unint64_t v135 = v131 - (*((void *)&v198 + 1) + -(char)v130);
    if (((v131
                          - __PAIR128__(*((void *)&v198 + 1) + (unint64_t)-(char)v130, *((void *)&v198 + 1) + (unint64_t)-(char)v130)) >> 64))uint64_t v136 = -1;
    else {
      uint64_t v136 = 0;
    }
    uint64_t v188 = v132 + v136;
    uint64_t v190 = v136 + __CFADD__(v132, v136) + (void)v133;
    unint64_t v184 = (__CFADD__(__CFADD__(v132, v136), (void)v133) | __CFADD__(v136, __CFADD__(v132, v136) + (void)v133))+ v134;
    unsigned long long v137 = __PAIR128__(v136 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v132, v136), (void)v133) | __CFADD__(v136, __CFADD__(v132, v136) + (void)v133))+ __PAIR128__(v135, v134);
    uint64_t v139 = v197 - (v132 + v136);
    char v138 = ((unint64_t)v197 - __PAIR128__(v135, v132 + v136)) >> 64;
    unsigned long long v140 = *((unint64_t *)&v197 + 1)
         - __PAIR128__(v190 + (unint64_t)-v138, v190 + (unint64_t)-v138);
    char v141 = ((unint64_t)v198
          - __PAIR128__((unint64_t)v137 + -BYTE8(v140), (unint64_t)v137 + -BYTE8(v140))) >> 64;
    if (((*((unint64_t *)&v198 + 1)
                          - __PAIR128__(*((void *)&v137 + 1) + (unint64_t)-v141, *((void *)&v137 + 1) + (unint64_t)-v141)) >> 64))uint64_t v142 = -1;
    else {
      uint64_t v142 = 0;
    }
    uint64_t v143 = __CFADD__(v139, v142) + (void)v140;
    *(void *)&long long v223 = v139 + v142;
    *((void *)&v223 + 1) = v142 + v143;
    unsigned long long v224 = __PAIR128__(v142 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v139, v142), (void)v140) | __CFADD__(v142, v143))+ __PAIR128__(*((void *)&v198 + 1)- (*((void *)&v137 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v198- __PAIR128__((unint64_t)v137 + -BYTE8(v140), (unint64_t)v137 + -BYTE8(v140))) >> 64)), v198 - (v137 + -BYTE8(v140)));
    sub_244D41858((uint64_t *)&v223, (unint64_t *)&v223, (unint64_t *)&v202);
    long long v195 = 0u;
    long long v196 = 0u;
    sub_244D41858((uint64_t *)&v195, (unint64_t *)&v215, (unint64_t *)&v199);
    uint64_t v145 = v223 - v195;
    uint64_t v146 = *((void *)&v223 + 1)
         - (*((void *)&v195 + 1)
          + -(uint64_t)(((unint64_t)v223 - __PAIR128__(v144, v195)) >> 64));
    BOOL v55 = __CFADD__((void)v196, -(uint64_t)((*((unint64_t *)&v223 + 1)- __PAIR128__(*((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v223- __PAIR128__(v144, v195)) >> 64), *((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v223- __PAIR128__(v144, v195)) >> 64))) >> 64));
    unint64_t v147 = v196
         + -(uint64_t)((*((unint64_t *)&v223 + 1)
                                      - __PAIR128__(*((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v223- __PAIR128__(v144, v195)) >> 64), *((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v223- __PAIR128__(v144, v195)) >> 64))) >> 64);
    uint64_t v148 = v55;
    uint64_t v149 = v224 - v147;
    BOOL v55 = __CFADD__(*((void *)&v196 + 1), -(uint64_t)(((unint64_t)v224 - __PAIR128__(v148, v147)) >> 64));
    unint64_t v150 = *((void *)&v196 + 1)
         + -(uint64_t)(((unint64_t)v224 - __PAIR128__(v148, v147)) >> 64);
    uint64_t v151 = v55;
    unsigned long long v152 = *((unint64_t *)&v224 + 1) - __PAIR128__(v151, v150);
    uint64_t v153 = __CFADD__(v145, *((void *)&v152 + 1)) + v146;
    uint64_t v155 = __CFADD__(__CFADD__(v145, *((void *)&v152 + 1)), v146) | __CFADD__(DWORD2(v152), v153);
    unint64_t v154 = v155 + v149;
    unint64_t v156 = v152 + __CFADD__(v155, v149) + (*((void *)&v152 + 1) & 0xFFFFFFFF00000001);
    uint64_t v157 = v145 + *((void *)&v152 + 1) - v195;
    uint64_t v158 = DWORD2(v152)
         + v153
         - (*((void *)&v195 + 1)
          + -(uint64_t)(((unint64_t)(v145 + *((void *)&v152 + 1)) - __PAIR128__(v195, v195)) >> 64));
    unint64_t v159 = v196
         + -(uint64_t)(((unint64_t)DWORD2(v152)
                                      + v153
                                      - __PAIR128__(*((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v145 + *((void *)&v152 + 1))- __PAIR128__(v195, v195)) >> 64), *((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v145 + *((void *)&v152 + 1))- __PAIR128__(v195, v195)) >> 64))) >> 64);
    BOOL v160 = __CFADD__((void)v196, -(uint64_t)(((unint64_t)DWORD2(v152)+ v153- __PAIR128__(*((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v145 + *((void *)&v152 + 1))- __PAIR128__(v195, v195)) >> 64), *((void *)&v195 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v145 + *((void *)&v152 + 1))- __PAIR128__(v195, v195)) >> 64))) >> 64));
    unint64_t v162 = v154 - v159;
    char v161 = (v154 - __PAIR128__(v160, v159)) >> 64;
    BOOL v55 = __CFADD__(*((void *)&v196 + 1), -v161);
    unint64_t v163 = *((void *)&v196 + 1) + -v161;
    uint64_t v164 = v55;
    if (((v156 - __PAIR128__(v164, v163)) >> 64)) {
      uint64_t v165 = -1;
    }
    else {
      uint64_t v165 = 0;
    }
    uint64_t v166 = (uint64_t)v30;
    uint64_t v167 = v157 + v165;
    uint64_t v168 = v64;
    uint64_t v169 = v165 + __CFADD__(v157, v165) + v158;
    unsigned long long v170 = __PAIR128__(v165 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v157, v165), v158) | __CFADD__(v165, __CFADD__(v157, v165) + v158))+ __PAIR128__(v156 - v163, v162);
    unint64_t v171 = v31;
    if (v192) {
      unint64_t v172 = 0;
    }
    else {
      unint64_t v172 = -1;
    }
    if (v192) {
      unint64_t v173 = -1;
    }
    else {
      unint64_t v173 = 0;
    }
    unint64_t v174 = a8[1] & v172 | v173 & v190;
    unint64_t v175 = a8[2] & v172 | v173 & v184;
    unint64_t v176 = a8[3] & v172;
    *(void *)&long long v225 = v172 & *a8 | v173 & v188;
    *((void *)&v225 + 1) = v174;
    *(void *)&long long v226 = v175;
    *((void *)&v226 + 1) = v176 | v173 & *((void *)&v137 + 1);
    sub_244D433C4((uint64_t)a1, v193, v168, (uint64_t)&v225);
    unint64_t v177 = a9[1] & v172 | v173 & v169;
    uint64_t v178 = a9[2] & v172 | v173 & v170;
    unint64_t v179 = a9[3] & v172;
    *(void *)&long long v223 = *a9 & v172 | v173 & v167;
    *((void *)&v223 + 1) = v177;
    *(void *)&unsigned long long v224 = v178;
    *((void *)&v224 + 1) = v179 | *((void *)&v170 + 1) & v173;
    sub_244D433C4((uint64_t)a2, v193, v166, (uint64_t)&v223);
    int8x16_t v180 = (int8x16_t)vdupq_n_s64(v173);
    int8x16_t v181 = (int8x16_t)vdupq_n_s64(v172);
    int8x16_t v182 = vorrq_s8(vandq_s8(v221, v180), vandq_s8(*v171, v181));
    int8x16_t v183 = vorrq_s8(vandq_s8(v222, v180), vandq_s8(v171[1], v181));
    int8x16_t v221 = v182;
    int8x16_t v222 = v183;
    *(void *)&double result = sub_244D433C4((uint64_t)a3, v193, (uint64_t)a6, (uint64_t)&v221).u64[0];
  }
  return result;
}

uint64_t *sub_244D42A18(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  uint64_t v252 = *MEMORY[0x263EF8340];
  long long v250 = 0u;
  long long v251 = 0u;
  memset(v249, 0, sizeof(v249));
  memset(v248, 0, sizeof(v248));
  memset(v242, 0, sizeof(v242));
  sub_244D41BF4((uint64_t *)&v250, a6);
  sub_244D41BF4((uint64_t *)v249, a5);
  sub_244D41858((uint64_t *)v248, a4, (unint64_t *)v249);
  unint64_t v12 = *a4;
  unint64_t v13 = a4[1];
  long long v14 = v250;
  uint64_t v16 = *a4 - v250;
  BOOL v17 = __CFADD__(*((void *)&v250 + 1), -(uint64_t)((*a4 - __PAIR128__(v15, v250)) >> 64));
  uint64_t v18 = *((void *)&v250 + 1) + -(uint64_t)((*a4 - __PAIR128__(v15, v250)) >> 64);
  uint64_t v19 = v17;
  uint64_t v20 = v13 - v18;
  long long v21 = v251;
  BOOL v17 = __CFADD__((void)v251, -(uint64_t)((v13 - __PAIR128__(v19, v18)) >> 64));
  uint64_t v22 = v251 + -(uint64_t)((v13 - __PAIR128__(v19, v18)) >> 64);
  uint64_t v23 = v17;
  unint64_t v24 = a4[2];
  unint64_t v25 = a4[3];
  uint64_t v26 = v24 - v22;
  BOOL v17 = __CFADD__(*((void *)&v251 + 1), -(uint64_t)((v24 - __PAIR128__(v23, v22)) >> 64));
  unint64_t v27 = *((void *)&v251 + 1) + -(uint64_t)((v24 - __PAIR128__(v23, v22)) >> 64);
  uint64_t v28 = v17;
  unsigned long long v29 = v25 - __PAIR128__(v28, v27);
  uint64_t v30 = __CFADD__(v16, *((void *)&v29 + 1)) + v20;
  uint64_t v31 = __CFADD__(__CFADD__(v16, *((void *)&v29 + 1)), v20) | __CFADD__(DWORD2(v29), v30);
  uint64_t v244 = v16 + *((void *)&v29 + 1);
  uint64_t v245 = DWORD2(v29) + v30;
  uint64_t v246 = v31 + v26;
  uint64_t v247 = v29 + __CFADD__(v31, v26) + (*((void *)&v29 + 1) & 0xFFFFFFFF00000001);
  BOOL v17 = __CFADD__((void)v250, v12);
  uint64_t v32 = v250 + v12;
  BOOL v34 = v17;
  BOOL v17 = __CFADD__(v17, v13);
  unint64_t v33 = v34 + v13;
  uint64_t v35 = v17;
  unint64_t v36 = v251 + v24;
  BOOL v37 = __CFADD__((void)v251, v24);
  unint64_t v38 = *((void *)&v251 + 1) + v25;
  BOOL v39 = __CFADD__(*((void *)&v251 + 1), v25);
  unint64_t v41 = v33 + *((void *)&v250 + 1);
  BOOL v17 = __CFADD__(__CFADD__(v33, *((void *)&v250 + 1)), v36) | __CFADD__(v35, (__PAIR128__(v36, v33)+ *((unint64_t *)&v250 + 1)) >> 64);
  unint64_t v40 = v35 + ((__PAIR128__(v36, v33) + *((unint64_t *)&v250 + 1)) >> 64);
  unint64_t v43 = v17 + v38;
  BOOL v17 = __CFADD__(v17, v38) | __CFADD__(v37, v43);
  unint64_t v42 = v37 + v43;
  if (v17) {
    unint64_t v44 = v39 + 1;
  }
  else {
    unint64_t v44 = v39;
  }
  unsigned long long v45 = v41 - __PAIR128__(v25, (1 - __CFADD__(v32, 1)));
  unint64_t v46 = v42
      - -(uint64_t)((v40
                                   - __PAIR128__(0xFFFFFFFF00000001, (1 - (__CFADD__((void)v45, 0xFFFFFFFF00000001) + BYTE8(v45))))) >> 64);
  uint64_t v47 = -(uint64_t)(v44
                 + (v44 < (1
                                          - (__CFADD__(v46, 0xFFFFFFFFLL)
                                           + ((v42
                                             - __PAIR128__(DWORD2(v29), -(uint64_t)((v40- __PAIR128__(0xFFFFFFFF00000001, (1- (__CFADD__((void)v45, 0xFFFFFFFF00000001)+ BYTE8(v45))))) >> 64))) >> 64)))));
  if ((_BYTE)v47) {
    uint64_t v48 = 0;
  }
  else {
    uint64_t v48 = -1;
  }
  if ((_BYTE)v47) {
    uint64_t v49 = -1;
  }
  else {
    uint64_t v49 = 0;
  }
  uint64_t v50 = v48 & (v32 + 1) | v49 & v32;
  uint64_t v51 = v48 & (v45 - 0xFFFFFFFF) | v49 & v41;
  uint64_t v52 = v48 & (v40 - (1 - (__CFADD__((void)v45, 0xFFFFFFFF00000001) + BYTE8(v45)))) | v49 & v40;
  uint64_t v53 = v48 & (v46 + 0xFFFFFFFF) | v49 & v42;
  *((void *)&v55 + 1) = v51;
  *(void *)&long long v55 = v50;
  uint64_t v54 = v55 >> 63;
  *((void *)&v55 + 1) = v52;
  *(void *)&long long v55 = v51;
  unint64_t v56 = v55 >> 63;
  *((void *)&v55 + 1) = v53;
  *(void *)&long long v55 = v52;
  unint64_t v57 = v55 >> 63;
  unint64_t v58 = v56 - (1 - __CFADD__(v54, 0xFFFFFFFF00000000));
  unint64_t v59 = v57
      - -(uint64_t)((v56 - __PAIR128__(v10, (1 - __CFADD__(v54, 0xFFFFFFFF00000000)))) >> 64);
  unsigned __int8 v60 = 1
      - (__CFADD__(v59, 0xFFFFFFFFLL)
       + ((v57
         - __PAIR128__(v11, -(uint64_t)((v56- __PAIR128__(v10, (1 - __CFADD__(v54, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v53 < 0) + ((unint64_t)v53 >> 63 < v60)) {
    uint64_t v61 = 0;
  }
  else {
    uint64_t v61 = -1;
  }
  if ((v53 < 0) + ((unint64_t)v53 >> 63 < v60)) {
    uint64_t v62 = -1;
  }
  else {
    uint64_t v62 = 0;
  }
  uint64_t v63 = v61 & ((2 * v50) | 1) | v62 & (2 * v50);
  uint64_t v64 = v61 & (v54 - 0x100000000) | v62 & v54;
  uint64_t v65 = v61 & v58;
  uint64_t v66 = v61 & v58 | v62 & v56;
  uint64_t v67 = v61 & (v59 + 0xFFFFFFFF) | v62 & v57;
  BOOL v17 = __CFADD__(v63, v50);
  uint64_t v68 = v63 + v50;
  BOOL v70 = v17;
  BOOL v17 = __CFADD__(v17, v51);
  uint64_t v69 = v70 + v51;
  uint64_t v71 = v17;
  BOOL v17 = __CFADD__(v69, v64);
  uint64_t v72 = v69 + v64;
  BOOL v74 = v17;
  BOOL v17 = __CFADD__(v17, v52);
  uint64_t v73 = v74 + v52;
  v17 |= __CFADD__(v71, v73);
  v73 += v71;
  uint64_t v75 = v17;
  BOOL v17 = __CFADD__(v73, v66);
  uint64_t v76 = v73 + v66;
  BOOL v78 = v17;
  BOOL v17 = __CFADD__(v17, v53);
  uint64_t v77 = v78 + v53;
  v17 |= __CFADD__(v75, v77);
  v77 += v75;
  unint64_t v79 = v17;
  BOOL v17 = __CFADD__(v77, v67);
  uint64_t v80 = v77 + v67;
  if (v17) {
    ++v79;
  }
  unsigned long long v81 = (unint64_t)v72 - __PAIR128__(v71, (1 - __CFADD__(v68, 1)));
  unsigned long long v82 = (unint64_t)v80
      - __PAIR128__(v65, -(uint64_t)(((unint64_t)v76- __PAIR128__(v63, (1- (__CFADD__((void)v81, 0xFFFFFFFF00000001)+ BYTE8(v81))))) >> 64));
  if ((_BYTE)v79 + (v79 < (1 - (__CFADD__((void)v82, 0xFFFFFFFFLL) + BYTE8(v82))))) {
    uint64_t v83 = 0;
  }
  else {
    uint64_t v83 = -1;
  }
  v243[0] = v83 & (v68 + 1) | v68 & *((void *)&v82 + 1);
  v243[1] = v83 & (v81 - 0xFFFFFFFF) | *((void *)&v82 + 1) & v72;
  v243[2] = v83 & (v76 - (1 - (__CFADD__((void)v81, 0xFFFFFFFF00000001) + BYTE8(v81)))) | *((void *)&v82 + 1) & v76;
  v243[3] = v83 & (v82 + 0xFFFFFFFF) | *((void *)&v82 + 1) & v80;
  sub_244D41858((uint64_t *)v242, (unint64_t *)&v244, v243);
  sub_244D41BF4(a1, (unint64_t *)v242);
  uint64_t v84 = v248[0] >> 63;
  unint64_t v85 = *(_OWORD *)((char *)v248 + 8) >> 63;
  unint64_t v86 = v248[1] >> 63;
  unint64_t v88 = v85 - (1 - __CFADD__(v84, 0xFFFFFFFF00000000));
  unint64_t v91 = v86
      - -(uint64_t)((v85 - __PAIR128__(v87, (1 - __CFADD__(v84, 0xFFFFFFFF00000000)))) >> 64);
  uint64_t v90 = (v86
       - __PAIR128__(v89, -(uint64_t)((v85- __PAIR128__(v87, (1 - __CFADD__(v84, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  unint64_t v92 = v91 + 0xFFFFFFFF;
  unsigned __int8 v93 = 1 - (__CFADD__(v91, 0xFFFFFFFFLL) + v90);
  if ((v248[1] < 0) + (*((void *)&v248[1] + 1) >> 63 < (unint64_t)v93)) {
    uint64_t v94 = 0;
  }
  else {
    uint64_t v94 = -1;
  }
  if ((v248[1] < 0) + (*((void *)&v248[1] + 1) >> 63 < (unint64_t)v93)) {
    uint64_t v95 = -1;
  }
  else {
    uint64_t v95 = 0;
  }
  uint64_t v96 = v94 & ((2 * *(void *)&v248[0]) | 1) | v95 & (2 * *(void *)&v248[0]);
  uint64_t v97 = v94 & (v84 - 0x100000000) | v95 & v84;
  uint64_t v98 = v94 & v88 | v95 & v85;
  uint64_t v99 = v94 & v92 | v95 & v86;
  *((void *)&v101 + 1) = v97;
  *(void *)&long long v101 = v96;
  uint64_t v100 = v101 >> 63;
  *((void *)&v101 + 1) = v98;
  *(void *)&long long v101 = v97;
  unint64_t v102 = v101 >> 63;
  *((void *)&v101 + 1) = v99;
  *(void *)&long long v101 = v98;
  unint64_t v103 = v101 >> 63;
  unint64_t v104 = v102 - (1 - __CFADD__(v100, 0xFFFFFFFF00000000));
  unsigned long long v105 = v103
       - __PAIR128__(v95, -(uint64_t)((v102- __PAIR128__(v92, (1 - __CFADD__(v100, 0xFFFFFFFF00000000)))) >> 64));
  unint64_t v106 = v105 + 0xFFFFFFFF;
  if ((v99 < 0)
     + ((unint64_t)v99 >> 63 < (1 - (__CFADD__((void)v105, 0xFFFFFFFFLL) + BYTE8(v105)))))
  {
    uint64_t v107 = 0;
  }
  else
  {
    uint64_t v107 = -1;
  }
  uint64_t v108 = ((2 * v96) | 1) & v107 | *((void *)&v105 + 1) & (2 * v96);
  *(void *)&v238[8] = v107 & v104 | *((void *)&v105 + 1) & v102;
  *(void *)&v238[16] = v107 & v106 | *((void *)&v105 + 1) & v103;
  *(void *)int v238 = v107 & (v100 - 0x100000000) | *((void *)&v105 + 1) & v100;
  *((void *)&v110 + 1) = *(void *)v238;
  *(void *)&long long v110 = v108;
  uint64_t v109 = v110 >> 63;
  unint64_t v111 = *(long long *)v238 >> 63;
  unint64_t v112 = *(long long *)&v238[8] >> 63;
  unint64_t v113 = v111 - (1 - __CFADD__(v109, 0xFFFFFFFF00000000));
  unint64_t v115 = v112
       - -(uint64_t)((v111
                                    - __PAIR128__(v104, (1 - __CFADD__(v109, 0xFFFFFFFF00000000)))) >> 64);
  uint64_t v114 = (v112
        - __PAIR128__(v106, -(uint64_t)((v111- __PAIR128__(v104, (1 - __CFADD__(v109, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  unint64_t v116 = v115 + 0xFFFFFFFF;
  unsigned __int8 v117 = 1 - (__CFADD__(v115, 0xFFFFFFFFLL) + v114);
  if ((*(uint64_t *)&v238[16] < 0) + (*(void *)&v238[16] >> 63 < (unint64_t)v117)) {
    uint64_t v118 = 0;
  }
  else {
    uint64_t v118 = -1;
  }
  if ((*(uint64_t *)&v238[16] < 0) + (*(void *)&v238[16] >> 63 < (unint64_t)v117)) {
    uint64_t v119 = -1;
  }
  else {
    uint64_t v119 = 0;
  }
  uint64_t v120 = v119 & (2 * v108);
  uint64_t v121 = v118 & (v109 - 0x100000000) | v119 & v109;
  uint64_t v122 = v118 & v113 | v119 & v111;
  uint64_t v123 = v118 & v116 | v119 & v112;
  uint64_t v125 = ((unint64_t)*a1
        - __PAIR128__(((2 * v108) | 1) & v118 | (unint64_t)v120, ((2 * v108) | 1) & v118 | (unint64_t)v120)) >> 64;
  uint64_t v124 = *a1 - (((2 * v108) | 1) & v118 | v120);
  LODWORD(v125) = -(int)v125;
  BOOL v17 = __CFADD__(v121, v125);
  uint64_t v126 = v121 + v125;
  uint64_t v127 = v17;
  uint64_t v128 = a1[1] - v126;
  int v129 = -(int)(((unint64_t)a1[1] - __PAIR128__(v127, v126)) >> 64);
  BOOL v17 = __CFADD__(v122, v129);
  uint64_t v130 = v122 + v129;
  uint64_t v131 = v17;
  uint64_t v132 = a1[2] - v130;
  int v133 = -(int)(((unint64_t)a1[2] - __PAIR128__(v131, v130)) >> 64);
  BOOL v17 = __CFADD__(v123, v133);
  uint64_t v134 = v123 + v133;
  uint64_t v135 = v17;
  unsigned long long v136 = (unint64_t)a1[3] - __PAIR128__(v135, v134);
  *a1 = v124 + *((void *)&v136 + 1);
  a1[1] = DWORD2(v136) + __CFADD__(v124, *((void *)&v136 + 1)) + v128;
  a1[2] = (__CFADD__(__CFADD__(v124, *((void *)&v136 + 1)), v128) | __CFADD__(DWORD2(v136), __CFADD__(v124, *((void *)&v136 + 1))+ v128))+ v132;
  a1[3] = v136
        + __CFADD__(__CFADD__(__CFADD__(v124, *((void *)&v136 + 1)), v128) | __CFADD__(DWORD2(v136), __CFADD__(v124, *((void *)&v136 + 1))+ v128), v132)+ (*((void *)&v136 + 1) & 0xFFFFFFFF00000001);
  long long v137 = v249[0];
  long long v138 = v249[0] + v14;
  long long v139 = v249[1];
  unint64_t v140 = v21
       + (__CFADD__(__CFADD__(*(void *)&v249[0], (void)v14), *((void *)&v249[0] + 1)) | __CFADD__(*((void *)&v14 + 1), __CFADD__(*(void *)&v249[0], (void)v14) + *((void *)&v249[0] + 1)))
       + *(void *)&v249[1];
  unint64_t v141 = *((void *)&v21 + 1)
       + (__CFADD__(__CFADD__(__CFADD__(*(void *)&v249[0], (void)v14), *((void *)&v249[0] + 1)) | __CFADD__(*((void *)&v14 + 1), __CFADD__(*(void *)&v249[0], (void)v14) + *((void *)&v249[0] + 1)), (void)v139) | __CFADD__((void)v21, (__CFADD__(__CFADD__(*(void *)&v249[0], (void)v14), *((void *)&v249[0] + 1)) | __CFADD__(*((void *)&v14 + 1), __CFADD__(*(void *)&v249[0], (void)v14)+ *((void *)&v249[0]+ 1)))+ (void)v139))+ *((void *)&v249[1] + 1);
  if (__CFADD__(__CFADD__(__CFADD__(__CFADD__(*(void *)&v249[0], (void)v14), *((void *)&v249[0] + 1)) | __CFADD__(*((void *)&v14 + 1), __CFADD__(*(void *)&v249[0], (void)v14) + *((void *)&v249[0] + 1)), *(void *)&v249[1]) | __CFADD__((void)v21, (__CFADD__(__CFADD__(*(void *)&v249[0], (void)v14), *((void *)&v249[0] + 1)) | __CFADD__(*((void *)&v14 + 1), __CFADD__(*(void *)&v249[0], (void)v14) + *((void *)&v249[0] + 1)))+ *(void *)&v249[1]), *((void *)&v249[1] + 1)) | __CFADD__(*((void *)&v21 + 1), (__CFADD__(__CFADD__(__CFADD__(*(void *)&v249[0], (void)v14), *((void *)&v249[0] + 1)) | __CFADD__(*((void *)&v14 + 1), __CFADD__(*(void *)&v249[0], (void)v14)+ *((void *)&v249[0] + 1)),
                                           *(void *)&v249[1]) | __CFADD__((void)v21, (__CFADD__(__CFADD__(*(void *)&v249[0], (void)v14), *((void *)&v249[0] + 1)) | __CFADD__(*((void *)&v14 + 1), __CFADD__(*(void *)&v249[0], (void)v14) + *((void *)&v249[0] + 1)))+ *(void *)&v249[1]))+ *((void *)&v249[1] + 1)))unint64_t v142 = 1;
  else {
    unint64_t v142 = 0;
  }
  unsigned long long v143 = *((unint64_t *)&v138 + 1) - __PAIR128__(v116, (1 - __CFADD__((void)v138, 1)));
  unint64_t v145 = v141
       - -(uint64_t)((v140
                                    - __PAIR128__(v119, (1- (__CFADD__((void)v143, 0xFFFFFFFF00000001)+ BYTE8(v143))))) >> 64);
  uint64_t v144 = (v141
        - __PAIR128__(v120, -(uint64_t)((v140- __PAIR128__(v119, (1- (__CFADD__((void)v143, 0xFFFFFFFF00000001)+ BYTE8(v143))))) >> 64))) >> 64;
  unint64_t v146 = v145 + 0xFFFFFFFF;
  uint64_t v147 = -(uint64_t)(v142 + (v142 < (1 - (__CFADD__(v145, 0xFFFFFFFFLL) + v144))));
  BOOL v148 = v147 == 0;
  if ((_BYTE)v147) {
    uint64_t v149 = 0;
  }
  else {
    uint64_t v149 = -1;
  }
  if (v148) {
    uint64_t v150 = 0;
  }
  else {
    uint64_t v150 = -1;
  }
  uint64_t v151 = v149 & (v138 + 1) | v150 & v138;
  uint64_t v152 = v149 & (v143 - 0xFFFFFFFF) | v150 & *((void *)&v138 + 1);
  uint64_t v153 = v149 & (v140 - (1 - (__CFADD__((void)v143, 0xFFFFFFFF00000001) + BYTE8(v143)))) | v150 & v140;
  uint64_t v237 = v149 & v146 | v150 & v141;
  unint64_t v154 = a6[1];
  unint64_t v156 = (*a6 + *(_OWORD *)a5) >> 64;
  unint64_t v155 = *a6 + *a5;
  BOOL v157 = __CFADD__(__CFADD__(*a6, *a5), a5[1]);
  unint64_t v158 = a5[2];
  unint64_t v159 = a5[3];
  unint64_t v160 = a6[2];
  unint64_t v161 = a6[3];
  BOOL v17 = __CFADD__(v160, v158);
  unint64_t v162 = v160 + v158;
  uint64_t v163 = v17;
  BOOL v17 = __CFADD__(v161, v159);
  unint64_t v164 = v161 + v159;
  uint64_t v165 = v17;
  unint64_t v167 = v156 + v154;
  BOOL v17 = __CFADD__(__CFADD__(v156, v154), v162) | __CFADD__(v157, (__PAIR128__(v162, v156) + v154) >> 64);
  unint64_t v166 = v157 + ((__PAIR128__(v162, v156) + v154) >> 64);
  uint64_t v168 = v163 + v17 + v164;
  if (__CFADD__(v17, v164) | __CFADD__(v163, v17 + v164)) {
    unint64_t v169 = v165 + 1;
  }
  else {
    unint64_t v169 = v165;
  }
  unsigned long long v170 = v167 - __PAIR128__(v165, (1 - __CFADD__(v155, 1)));
  unsigned long long v171 = (unint64_t)v168
       - __PAIR128__(v150, -(uint64_t)((v166- __PAIR128__(v146, (1- (__CFADD__((void)v170, 0xFFFFFFFF00000001)+ BYTE8(v170))))) >> 64));
  if ((_BYTE)v169 + (v169 < (1 - (__CFADD__((void)v171, 0xFFFFFFFFLL) + BYTE8(v171))))) {
    uint64_t v172 = 0;
  }
  else {
    uint64_t v172 = -1;
  }
  uint64_t v244 = v172 & (v155 + 1) | *((void *)&v171 + 1) & v155;
  uint64_t v245 = v172 & (v170 - 0xFFFFFFFF) | *((void *)&v171 + 1) & v167;
  uint64_t v246 = v172 & (v166 - (1 - (__CFADD__((void)v170, 0xFFFFFFFF00000001) + BYTE8(v170)))) | *((void *)&v171 + 1) & v166;
  uint64_t v247 = v172 & (v171 + 0xFFFFFFFF) | *((void *)&v171 + 1) & v168;
  sub_244D41BF4(a3, (unint64_t *)&v244);
  unint64_t v176 = *a3 - v151;
  unint64_t v177 = a3[1] - (v152 + -(uint64_t)(((unint64_t)*a3 - __PAIR128__(v175, v151)) >> 64));
  BOOL v17 = __CFADD__(v153, -(uint64_t)(((unint64_t)a3[1]- __PAIR128__(v152+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v175, v151)) >> 64), v152+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v175, v151)) >> 64))) >> 64));
  uint64_t v178 = v153
       + -(uint64_t)(((unint64_t)a3[1]
                                    - __PAIR128__(v152+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v175, v151)) >> 64), v152+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v175, v151)) >> 64))) >> 64);
  uint64_t v179 = v17;
  uint64_t v180 = a3[2] - v178;
  BOOL v17 = __CFADD__(v237, -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v179, v178)) >> 64));
  uint64_t v181 = v237 + -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v179, v178)) >> 64);
  uint64_t v182 = v17;
  unsigned long long v183 = (unint64_t)a3[3] - __PAIR128__(v182, v181);
  unint64_t v184 = __CFADD__(v176, *((void *)&v183 + 1)) + v177;
  uint64_t v185 = __CFADD__(__CFADD__(v176, *((void *)&v183 + 1)), v177) | __CFADD__(DWORD2(v183), v184);
  *a3 = v176 + *((void *)&v183 + 1);
  a3[1] = DWORD2(v183) + v184;
  a3[2] = v185 + v180;
  a3[3] = v183 + __CFADD__(v185, v180) + (*((void *)&v183 + 1) & 0xFFFFFFFF00000001);
  unint64_t v186 = a1[1];
  unint64_t v187 = v108 - *a1;
  BOOL v17 = __CFADD__(v186, -(uint64_t)(((unint64_t)v108 - __PAIR128__(v185 + v180, *a1)) >> 64));
  unint64_t v188 = v186 + -(uint64_t)(((unint64_t)v108 - __PAIR128__(v185 + v180, *a1)) >> 64);
  uint64_t v189 = v17;
  unint64_t v190 = *(void *)v238 - v188;
  unint64_t v191 = a1[2];
  unint64_t v192 = a1[3];
  BOOL v17 = __CFADD__(v191, -(uint64_t)((*(unint64_t *)v238 - __PAIR128__(v189, v188)) >> 64));
  unint64_t v193 = v191 + -(uint64_t)((*(unint64_t *)v238 - __PAIR128__(v189, v188)) >> 64);
  uint64_t v194 = v17;
  unint64_t v196 = *(void *)&v238[8] - v193;
  char v195 = (*(unint64_t *)&v238[8] - __PAIR128__(v194, v193)) >> 64;
  BOOL v17 = __CFADD__(v192, -v195);
  unint64_t v197 = v192 + -v195;
  uint64_t v198 = v17;
  unsigned long long v199 = *(unint64_t *)&v238[16] - __PAIR128__(v198, v197);
  unint64_t v200 = __CFADD__(v187, *((void *)&v199 + 1)) + v190;
  uint64_t v201 = __CFADD__(__CFADD__(v187, *((void *)&v199 + 1)), v190) | __CFADD__(DWORD2(v199), v200);
  *a2 = v187 + *((void *)&v199 + 1);
  a2[1] = DWORD2(v199) + v200;
  a2[2] = v201 + v196;
  a2[3] = v199 + __CFADD__(v201, v196) + (*((void *)&v199 + 1) & 0xFFFFFFFF00000001);
  uint64_t v202 = v137 >> 63;
  *((void *)&v204 + 1) = v139;
  *(void *)&long long v204 = *((void *)&v137 + 1);
  unint64_t v203 = v204 >> 63;
  unint64_t v205 = v139 >> 63;
  unint64_t v206 = v205
       - -(uint64_t)((v203
                                    - __PAIR128__(v173, (1 - __CFADD__(v202, 0xFFFFFFFF00000000)))) >> 64);
  unsigned __int8 v207 = 1
       - (__CFADD__(v206, 0xFFFFFFFFLL)
        + ((v205
          - __PAIR128__(v174, -(uint64_t)((v203- __PAIR128__(v173, (1 - __CFADD__(v202, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v139 < 0) + (*((void *)&v139 + 1) >> 63 < (unint64_t)v207)) {
    uint64_t v208 = 0;
  }
  else {
    uint64_t v208 = -1;
  }
  if ((v139 < 0) + (*((void *)&v139 + 1) >> 63 < (unint64_t)v207)) {
    uint64_t v209 = -1;
  }
  else {
    uint64_t v209 = 0;
  }
  *(void *)&v249[0] = v208 & ((2 * v137) | 1) | v209 & (2 * v137);
  *((void *)&v249[0] + 1) = v208 & (v202 - 0x100000000) | v209 & v202;
  *(void *)&v249[1] = v208 & (v203 - (1 - __CFADD__(v202, 0xFFFFFFFF00000000))) | v209 & v203;
  *((void *)&v249[1] + 1) = v208 & (v206 + 0xFFFFFFFF) | v209 & v205;
  sub_244D41BF4((uint64_t *)v249, (unint64_t *)v249);
  double result = sub_244D41858(a2, (unint64_t *)v242, (unint64_t *)a2);
  uint64_t v211 = v249[0] >> 63;
  unint64_t v212 = *(_OWORD *)((char *)v249 + 8) >> 63;
  unint64_t v213 = v249[1] >> 63;
  unint64_t v215 = v212 - (1 - __CFADD__(v211, 0xFFFFFFFF00000000));
  unint64_t v217 = v213
       - -(uint64_t)((v212
                                    - __PAIR128__(v214, (1 - __CFADD__(v211, 0xFFFFFFFF00000000)))) >> 64);
  unsigned __int8 v218 = 1
       - (__CFADD__(v217, 0xFFFFFFFFLL)
        + ((v213
          - __PAIR128__(v216, -(uint64_t)((v212- __PAIR128__(v214, (1 - __CFADD__(v211, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v249[1] < 0) + (*((void *)&v249[1] + 1) >> 63 < (unint64_t)v218)) {
    uint64_t v219 = 0;
  }
  else {
    uint64_t v219 = -1;
  }
  if ((v249[1] < 0) + (*((void *)&v249[1] + 1) >> 63 < (unint64_t)v218)) {
    uint64_t v220 = -1;
  }
  else {
    uint64_t v220 = 0;
  }
  uint64_t v221 = v219 & (v211 - 0x100000000) | v220 & v211;
  uint64_t v222 = v219 & v215 | v220 & v212;
  uint64_t v223 = v219 & (v217 + 0xFFFFFFFF) | v220 & v213;
  uint64_t v224 = *a2 - (v219 & ((2 * *(void *)&v249[0]) | 1) | v220 & (2 * *(void *)&v249[0]));
  int v225 = -(int)(((unint64_t)*a2
               - __PAIR128__(*a2, v219 & ((2 * *(void *)&v249[0]) | 1) | v220 & (unint64_t)(2 * *(void *)&v249[0]))) >> 64);
  BOOL v17 = __CFADD__(v221, v225);
  uint64_t v226 = v221 + v225;
  uint64_t v227 = v17;
  uint64_t v228 = a2[1] - v226;
  int v229 = -(int)(((unint64_t)a2[1] - __PAIR128__(v227, v226)) >> 64);
  BOOL v17 = __CFADD__(v222, v229);
  uint64_t v230 = v222 + v229;
  uint64_t v231 = v17;
  uint64_t v232 = a2[2] - v230;
  int v233 = -(int)(((unint64_t)a2[2] - __PAIR128__(v231, v230)) >> 64);
  BOOL v17 = __CFADD__(v223, v233);
  uint64_t v234 = v223 + v233;
  uint64_t v235 = v17;
  unsigned long long v236 = (unint64_t)a2[3] - __PAIR128__(v235, v234);
  *a2 = v224 + *((void *)&v236 + 1);
  a2[1] = DWORD2(v236) + __CFADD__(v224, *((void *)&v236 + 1)) + v228;
  a2[2] = (__CFADD__(__CFADD__(v224, *((void *)&v236 + 1)), v228) | __CFADD__(DWORD2(v236), __CFADD__(v224, *((void *)&v236 + 1))+ v228))+ v232;
  a2[3] = v236
        + __CFADD__(__CFADD__(__CFADD__(v224, *((void *)&v236 + 1)), v228) | __CFADD__(DWORD2(v236), __CFADD__(v224, *((void *)&v236 + 1))+ v228), v232)+ (*((void *)&v236 + 1) & 0xFFFFFFFF00000001);
  return result;
}

int8x16_t sub_244D433C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2) {
    unint64_t v4 = 0;
  }
  else {
    unint64_t v4 = -1;
  }
  if (a2) {
    unint64_t v5 = -1;
  }
  else {
    unint64_t v5 = 0;
  }
  unint64_t v6 = *(void *)(a4 + 24) & v5 | *(void *)(a3 + 24) & v4;
  int8x16_t v7 = vandq_s8(*(int8x16_t *)(a4 + 8), (int8x16_t)vdupq_n_s64(v5));
  int8x16_t v8 = vandq_s8(*(int8x16_t *)(a3 + 8), (int8x16_t)vdupq_n_s64(v4));
  *(void *)a1 = v4 & *(void *)a3 | v5 & *(void *)a4;
  int8x16_t result = vorrq_s8(v7, v8);
  *(int8x16_t *)(a1 + 8) = result;
  *(void *)(a1 + 24) = v6;
  return result;
}

double sub_244D43424(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v6 = 0;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  uint64_t v7 = (uint64_t)(a3 + 2);
  uint64_t v8 = a1 - 1;
  do
  {
    sub_244D433C4((uint64_t)a3, v6 ^ v8, a2, (uint64_t)a3);
    sub_244D433C4(v7, v6++ ^ v8, a2 + 32, v7);
    a2 += 64;
  }
  while (v6 != 15);

  *(void *)&double result = sub_244D433C4((uint64_t)(a3 + 4), a1, (uint64_t)(a3 + 4), (uint64_t)&xmmword_244EB7E88).u64[0];
  return result;
}

unint64_t *sub_244D434E4(unint64_t *result, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 & (a3 << 62 >> 63);
  unint64_t v5 = a4 & (a3 << 61 >> 63);
  unint64_t v6 = a4 & (a3 << 60 >> 63);
  *double result = ((((a4 & 0x1111111111111111) * (a3 & 0x1111111111111110)) ^ ((a4 & 0x8888888888888888)
                                                                           * (a3 & 0x2222222222222220)) ^ ((a4 & 0x4444444444444444) * (a3 & 0x4444444444444440)) ^ ((a4 & 0x2222222222222222) * (a3 & 0x8888888888888880))) & 0x1111111111111111 | (((a4 & 0x2222222222222222) * (a3 & 0x1111111111111110)) ^ ((a4 & 0x1111111111111111) * (a3 & 0x2222222222222220)) ^ ((a4 & 0x8888888888888888) * (a3 & 0x4444444444444440)) ^ ((a4 & 0x4444444444444444) * (a3 & 0x8888888888888880))) & 0x2222222222222222 | (((a4 & 0x4444444444444444) * (a3 & 0x1111111111111110)) ^ ((a4 & 0x2222222222222222) * (a3 & 0x2222222222222220)) ^ ((a4 & 0x1111111111111111) * (a3 & 0x4444444444444440)) ^ ((a4 & 0x8888888888888888) * (a3 & 0x8888888888888880))) & 0x4444444444444444 | (((a4 & 0x8888888888888888) * (a3 & 0x1111111111111110)) ^ ((a4 & 0x4444444444444444) * (a3 & 0x2222222222222220)) ^ ((a4 & 0x2222222222222222) * (a3 & 0x4444444444444440)) ^ ((a4 & 0x1111111111111111) * (a3 & 0x8888888888888880))) & 0x8888888888888888) ^ (a3 << 63 >> 63) & a4 ^ (2 * v4) ^ (4 * v5) ^ (8 * v6);
  *a2 = (((((a4 & 0x1111111111111111) * (unsigned __int128)(a3 & 0x1111111111111110)) >> 64) ^ (((a4 & 0x8888888888888888) * (unsigned __int128)(a3 & 0x2222222222222220)) >> 64) ^ (((a4 & 0x4444444444444444) * (unsigned __int128)(a3 & 0x4444444444444440)) >> 64) ^ (((a4 & 0x2222222222222222) * (unsigned __int128)(a3 & 0x8888888888888880)) >> 64)) & 0x1111111111111111 | ((((a4 & 0x2222222222222222) * (unsigned __int128)(a3 & 0x1111111111111110)) >> 64) ^ (((a4 & 0x1111111111111111) * (unsigned __int128)(a3 & 0x2222222222222220)) >> 64) ^ (((a4 & 0x8888888888888888) * (unsigned __int128)(a3 & 0x4444444444444440)) >> 64) ^ (((a4 & 0x4444444444444444) * (unsigned __int128)(a3 & 0x8888888888888880)) >> 64)) & 0x2222222222222222 | ((((a4 & 0x4444444444444444) * (unsigned __int128)(a3 & 0x1111111111111110)) >> 64) ^ (((a4 & 0x2222222222222222) * (unsigned __int128)(a3 & 0x2222222222222220)) >> 64) ^ (((a4 & 0x1111111111111111) * (unsigned __int128)(a3 & 0x4444444444444440)) >> 64) ^ (((a4 & 0x8888888888888888) * (unsigned __int128)(a3 & 0x8888888888888880)) >> 64)) & 0x4444444444444444 | ((((a4 & 0x8888888888888888) * (unsigned __int128)(a3 & 0x1111111111111110)) >> 64) ^ (((a4 & 0x4444444444444444) * (unsigned __int128)(a3 & 0x2222222222222220)) >> 64) ^ (((a4 & 0x2222222222222222) * (unsigned __int128)(a3 & 0x4444444444444440)) >> 64) ^ (((a4 & 0x1111111111111111) * (unsigned __int128)(a3 & 0x8888888888888880)) >> 64)) & 0x8888888888888888) ^ (v4 >> 63) ^ (v5 >> 62) ^ (v6 >> 61);
  return result;
}

void sub_244D43690()
{
  if ((unint64_t)(qword_268EC01B0 + 1) > 1) {
    uint64_t v0 = qword_268EC01B0 + 1;
  }
  else {
    uint64_t v0 = 1;
  }
  qword_268EC01B0 = v0;
}

double sub_244D436B0()
{
  qword_268EC01B8 = (uint64_t)&unk_244EB9618;
  *(void *)&double result = 0x1100000011;
  unk_268EC01C0 = xmmword_244EB6F40;
  return result;
}

uint64_t sub_244D436D4(void ***a1, uint64_t a2, int a3)
{
  if (*a1) {
    return 1;
  }
  unint64_t v5 = sub_244D16714(a2);
  unint64_t v6 = v5;
  if (v5 && sub_244D16BB4((uint64_t)v5, a3))
  {
    *a1 = v6;
    return 1;
  }
  sub_244D166B0((void **)v6);
  return 0;
}

uint64_t sub_244D43740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a4 + 16)) {
    goto LABEL_2;
  }
  uint64_t v9 = *(int *)(a3 + 32);
  uint64_t v10 = *(int *)(a4 + 8);
  if (v10 > v9)
  {
    uint64_t v11 = 0;
    uint64_t v12 = v10 - v9;
    unint64_t v13 = (uint64_t *)(*(void *)a4 + 8 * v9);
    do
    {
      uint64_t v14 = *v13++;
      v11 |= v14;
      --v12;
    }
    while (v12);
    if (v11)
    {
LABEL_2:
      sub_244D0B884(4, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", 740);
      return 0;
    }
  }
  if (!sub_244D1A1FC(a1, a2, a3, a5)) {
    return 0;
  }

  return sub_244D1A118(a1, a1, a3, a3, a5);
}

uint64_t sub_244D43814(unsigned int *a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x3F) != 0)
  {
    int v8 = 68;
    __int16 v9 = 931;
LABEL_5:
    sub_244D0B884(4, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", v9);
    return 0;
  }
  if (a2 >= 0x3FFFFFF)
  {
    int v8 = 128;
    __int16 v9 = 968;
    goto LABEL_5;
  }
  BOOL v19 = sub_244D17320(a3, 3);
  sub_244D1756C((void *)a7);
  uint64_t result = (uint64_t)sub_244D17610(a7);
  if (result)
  {
    uint64_t v20 = result;
    uint64_t v27 = (uint64_t)a3;
    int v28 = 0;
    uint64_t v21 = 0;
    int v22 = 5 * a2;
    if (v19) {
      int v22 = 8 * a2;
    }
    if (v22 <= 1) {
      int v22 = 1;
    }
    int v23 = v22 - 1;
    do
    {
      uint64_t result = sub_244D20780((uint64_t)a1, a2, 0, 1u);
      if (!result) {
        break;
      }
      while (1)
      {
        if (a8)
        {
          uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(a8 + 8))(0, v21, a8);
          if (!result) {
            goto LABEL_36;
          }
        }
        if (!a4) {
          goto LABEL_19;
        }
        uint64_t result = sub_244D1E89C(v20, (uint64_t)a1, a4, a7);
        if (!result) {
          goto LABEL_36;
        }
        if ((int)sub_244D17194(v20, a6) > 0)
        {
LABEL_19:
          if ((int)sub_244D17194((uint64_t)a1, a5) >= 1) {
            break;
          }
        }
        uint64_t result = sub_244D20780((uint64_t)a1, a2, 0, 1u);
        uint64_t v21 = (v21 + 1);
        if (!result) {
          goto LABEL_36;
        }
      }
      if (!sub_244D1F95C(a1))
      {
        BOOL v30 = 0;
        sub_244D4BDB4(&stru_268EBD5F0, (void (*)(void))sub_244D16850);
        if (!sub_244D163DC(v20, (uint64_t)a1, (uint64_t)&qword_268EBEE70)
          || !sub_244D1C69C(&v30, v20, v27, a7))
        {
          goto LABEL_35;
        }
        if (v30)
        {
          int v29 = 0;
          if (!sub_244D1FE18(&v29, (uint64_t)a1, 0, a7, 0, a8)) {
            goto LABEL_35;
          }
          if (v29)
          {
            uint64_t result = 1;
            break;
          }
        }
      }
      if (v28 == v23)
      {
        sub_244D0B884(4, 0, 141, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/fipsmodule/rsa/rsa_impl.c", 1042);
LABEL_35:
        uint64_t result = 0;
        break;
      }
      ++v28;
      if (a8) {
        int v24 = (*(uint64_t (**)(uint64_t))(a8 + 8))(2);
      }
      else {
        int v24 = 1;
      }
      uint64_t result = 0;
      uint64_t v21 = (v21 + 1);
    }
    while (v24);
  }
LABEL_36:
  if (!*(unsigned char *)(a7 + 40))
  {
    uint64_t v25 = *(void *)(a7 + 8);
    uint64_t v26 = *(void *)(a7 + 16) - 1;
    *(void *)(a7 + 16) = v26;
    *(void *)(a7 + 32) = *(void *)(v25 + 8 * v26);
  }
  return result;
}

void *sub_244D43AD0(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_244D44058(0x30uLL);
  unint64_t v5 = v4;
  if (v4)
  {
    _OWORD v4[2] = 16;
    unint64_t v6 = sub_244D44098(0x10uLL, 8uLL);
    v5[1] = v6;
    if (v6)
    {
      int8x16_t v5[4] = a2;
      v5[5] = a1;
    }
    else
    {
      sub_244D440EC(v5);
      return 0;
    }
  }
  return v5;
}

void sub_244D43B40(void *a1)
{
  if (a1)
  {
    unint64_t v2 = a1[2];
    if (v2)
    {
      for (unint64_t i = 0; i < v2; ++i)
      {
        unint64_t v4 = *(void **)(a1[1] + 8 * i);
        if (v4)
        {
          do
          {
            unint64_t v5 = (void *)v4[1];
            sub_244D440EC(v4);
            unint64_t v4 = v5;
          }
          while (v5);
          unint64_t v2 = a1[2];
        }
      }
    }
    sub_244D440EC((void *)a1[1]);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D43BC4(void *a1, uint64_t a2, uint64_t (*a3)(void, uint64_t), unsigned int (*a4)(void, void, uint64_t))
{
  unint64_t v4 = sub_244D43C00(a1, 0, a2, a3, a4);
  if (*v4) {
    return *(void *)*v4;
  }
  else {
    return 0;
  }
}

void *sub_244D43C00(void *a1, unsigned int *a2, uint64_t a3, uint64_t (*a4)(void, uint64_t), unsigned int (*a5)(void, void, uint64_t))
{
  unsigned int v9 = a4(a1[5], a3);
  if (a2) {
    *a2 = v9;
  }
  uint64_t v10 = (void *)(a1[1] + 8 * ((unint64_t)v9 % a1[2]));
  uint64_t v11 = (void *)*v10;
  if (*v10 && a5(a1[4], *v11, a3))
  {
    do
    {
      uint64_t v12 = v11;
      uint64_t v11 = (void *)v11[1];
    }
    while (v11 && a5(a1[4], *v11, a3));
    return v12 + 1;
  }
  return v10;
}

uint64_t sub_244D43CA8(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int (*a4)(uint64_t, void))
{
  unint64_t v4 = *(void *)(a1 + 8) + 8 * ((unint64_t)a3 % *(void *)(a1 + 16));
  unint64_t v5 = *(void **)v4;
  if (*(void *)v4)
  {
    if (a4(a2, *v5))
    {
      while (1)
      {
        int v8 = v5;
        unint64_t v5 = (void *)v5[1];
        if (!v5) {
          break;
        }
        if (!a4(a2, *v5))
        {
          unint64_t v4 = (unint64_t)(v8 + 1);
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      if (*(void *)v4) {
        return **(void **)v4;
      }
    }
  }
  return 0;
}

uint64_t sub_244D43D34(void *a1, void *a2, uint64_t a3, uint64_t (*a4)(void, uint64_t), unsigned int (*a5)(void, void, uint64_t))
{
  unsigned int v11 = 0;
  *a2 = 0;
  int v8 = sub_244D43C00(a1, &v11, a3, a4, a5);
  unsigned int v9 = v8;
  if (*v8)
  {
    *a2 = *(void *)*v8;
    *(void *)*int v8 = a3;
  }
  else
  {
    uint64_t result = (uint64_t)sub_244D43FF4(0x18uLL);
    if (!result) {
      return result;
    }
    *(_DWORD *)(result + 16) = v11;
    *(void *)uint64_t result = a3;
    *(void *)(result + 8) = 0;
    *unsigned int v9 = result;
    ++*a1;
    sub_244D43DD0((uint64_t)a1);
  }
  return 1;
}

void sub_244D43DD0(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v1 = *(void *)(a1 + 16);
    if (*(void *)a1 / v1 < 3)
    {
      if (v1 <= *(void *)a1 || v1 < 0x11) {
        return;
      }
      unint64_t v3 = v1 >> 1;
      if (v3 <= 0x10) {
        unint64_t v2 = 16;
      }
      else {
        unint64_t v2 = v3;
      }
    }
    else
    {
      if ((uint64_t)v1 < 1) {
        return;
      }
      unint64_t v2 = 2 * v1;
    }
    sub_244D43F54(a1, v2);
  }
}

uint64_t sub_244D43E24(void *a1, uint64_t a2, uint64_t (*a3)(void, uint64_t), unsigned int (*a4)(void, void, uint64_t))
{
  unint64_t v5 = (uint64_t **)sub_244D43C00(a1, 0, a2, a3, a4);
  unint64_t v6 = *v5;
  if (!*v5) {
    return 0;
  }
  *unint64_t v5 = (uint64_t *)v6[1];
  uint64_t v7 = *v6;
  sub_244D440EC(v6);
  --*a1;
  sub_244D43DD0((uint64_t)a1);
  return v7;
}

void sub_244D43E94(uint64_t a1, void (*a2)(void, uint64_t), uint64_t a3)
{
  if (a1)
  {
    int v6 = *(_DWORD *)(a1 + 24);
    if (v6 == -1)
    {
      int v7 = -1;
    }
    else
    {
      int v7 = v6 + 1;
      *(_DWORD *)(a1 + 24) = v6 + 1;
    }
    unint64_t v8 = *(void *)(a1 + 16);
    if (v8)
    {
      for (unint64_t i = 0; i < v8; ++i)
      {
        uint64_t v10 = *(void **)(*(void *)(a1 + 8) + 8 * i);
        if (v10)
        {
          do
          {
            unsigned int v11 = (void *)v10[1];
            a2(*v10, a3);
            uint64_t v10 = v11;
          }
          while (v11);
          unint64_t v8 = *(void *)(a1 + 16);
        }
      }
      int v7 = *(_DWORD *)(a1 + 24);
    }
    if (v7 != -1) {
      *(_DWORD *)(a1 + 24) = v7 - 1;
    }
    sub_244D43DD0(a1);
  }
}

void sub_244D43F54(uint64_t a1, unint64_t a2)
{
  if (!(a2 >> 61))
  {
    unint64_t v4 = sub_244D44058(8 * a2);
    if (v4)
    {
      unint64_t v5 = v4;
      unint64_t v6 = *(void *)(a1 + 16);
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 8 * i);
          if (v8)
          {
            do
            {
              unint64_t v9 = *(unsigned int *)(v8 + 16) % a2;
              uint64_t v10 = *(void *)(v8 + 8);
              *(void *)(v8 + 8) = v4[v9];
              v4[v9] = v8;
              uint64_t v8 = v10;
            }
            while (v10);
            unint64_t v6 = *(void *)(a1 + 16);
          }
        }
      }
      sub_244D440EC(*(void **)(a1 + 8));
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = a2;
    }
  }
}

void *sub_244D43FF4(unint64_t a1)
{
  if (a1 <= 0xFFFFFFFFFFFFFFF7 && (unint64_t v2 = malloc_type_malloc(a1 + 8, 0x30772F57uLL)) != 0)
  {
    void *v2 = a1;
    return v2 + 1;
  }
  else
  {
    sub_244D0B884(14, 0, 65, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/mem.c", 247);
    return 0;
  }
}

void *sub_244D44058(unint64_t a1)
{
  unint64_t v2 = sub_244D43FF4(a1);
  unint64_t v3 = v2;
  if (a1 && v2) {
    bzero(v2, a1);
  }
  return v3;
}

void *sub_244D44098(unint64_t a1, unint64_t a2)
{
  if (!a2 || is_mul_ok(a2, a1))
  {
    unint64_t v4 = a2 * a1;
    return sub_244D44058(v4);
  }
  else
  {
    sub_244D0B884(14, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/mem.c", 261);
    return 0;
  }
}

void sub_244D440EC(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (char *)(a1 - 1);
    uint64_t v1 = *(a1 - 1);
    if (v1 != -8) {
      bzero(a1 - 1, v1 + 8);
    }
    free(v2);
  }
}

void sub_244D4413C(void *a1, size_t a2)
{
  if (a2) {
    bzero(a1, a2);
  }
}

void *sub_244D44148(void *a1, unint64_t a2)
{
  if (a1)
  {
    size_t v4 = *(a1 - 1);
    unint64_t v5 = sub_244D43FF4(a2);
    unint64_t v6 = v5;
    if (v5)
    {
      if (v4 >= a2) {
        size_t v7 = a2;
      }
      else {
        size_t v7 = v4;
      }
      memcpy(v5, a1, v7);
      sub_244D440EC(a1);
    }
    return v6;
  }
  else
  {
    return sub_244D43FF4(a2);
  }
}

uint64_t sub_244D441D4(char *a1, char *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  unsigned __int8 v3 = 0;
  do
  {
    char v5 = *a1++;
    char v4 = v5;
    char v6 = *a2++;
    v3 |= v6 ^ v4;
    --a3;
  }
  while (a3);
  return v3;
}

uint64_t sub_244D44204(unsigned __int8 *a1, uint64_t a2)
{
  for (uint64_t result = 2166136261; a2; --a2)
  {
    int v4 = *a1++;
    uint64_t result = 16777619 * (result ^ v4);
  }
  return result;
}

uint64_t sub_244D44234(const char *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = 2166136261;
  for (size_t i = strlen(a1); i; --i)
  {
    int v4 = *(unsigned __int8 *)v1++;
    uint64_t v2 = 16777619 * (v2 ^ v4);
  }
  return v2;
}

unint64_t sub_244D44284(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0;
  if (a2)
  {
    while (*(unsigned char *)(a1 + v2))
    {
      if (a2 == ++v2)
      {
        unint64_t v2 = a2;
        break;
      }
    }
  }
  if (v2 >= a2) {
    return a2;
  }
  else {
    return v2;
  }
}

const char *sub_244D442B0(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    unint64_t v2 = strlen(result) + 1;
    return (const char *)sub_244D442F4(v1, v2);
  }
  return result;
}

void *sub_244D442F4(const void *a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int v4 = sub_244D43FF4(a2);
  char v5 = v4;
  if (v4) {
    memcpy(v4, a1, a2);
  }
  return v5;
}

BOOL sub_244D44350(int a1)
{
  return (a1 & 0xFFFFFFDF) - 65 < 0x1A;
}

BOOL sub_244D44364(int a1)
{
  return (a1 - 48) < 0xA;
}

BOOL sub_244D44374(int a1)
{
  return (a1 - 48) < 0xA || (a1 & 0xFFFFFFDF) - 65 < 6;
}

uint64_t sub_244D44390(unsigned char *a1, int a2)
{
  if ((a2 - 58) > 0xFFFFFFF5)
  {
    char v2 = -48;
    goto LABEL_7;
  }
  if ((a2 - 97) < 6)
  {
    char v2 = -87;
LABEL_7:
    *a1 = v2 + a2;
    return 1;
  }
  if ((a2 - 65) <= 5)
  {
    char v2 = -55;
    goto LABEL_7;
  }
  return 0;
}

BOOL sub_244D443E0(int a1)
{
  return (a1 - 48) < 0xA || (a1 & 0xFFFFFFDF) - 65 < 0x1A;
}

uint64_t sub_244D443FC(uint64_t result)
{
  if ((result - 65) >= 0x1A) {
    return result;
  }
  else {
    return (result + 32);
  }
}

BOOL sub_244D44410(int a1)
{
  return a1 == 32 || (a1 - 9) < 5;
}

uint64_t sub_244D44424(char *a1, char *a2)
{
  int v2 = *a1;
  if ((v2 - 65) < 0x1A) {
    v2 += 32;
  }
  int v3 = *a2;
  int v4 = v3 + 32;
  if ((v3 - 65) >= 0x1A) {
    int v4 = *a2;
  }
  if (v2 < v4) {
    return 0xFFFFFFFFLL;
  }
  char v5 = a1 + 1;
  char v6 = a2 + 1;
  while (1)
  {
    if (v2 > v4) {
      return 1;
    }
    if (!v2) {
      break;
    }
    int v7 = *v5++;
    int v2 = v7;
    int v8 = v7 + 32;
    BOOL v9 = (v7 - 65) >= 0x1A;
    int v10 = *v6++;
    int v4 = v10;
    if (!v9) {
      int v2 = v8;
    }
    if ((v4 - 65) < 0x1A) {
      v4 += 32;
    }
    if (v2 < v4) {
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t sub_244D444B0(char *a1, char *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  for (uint64_t i = a3 - 1; ; --i)
  {
    int v5 = *a1++;
    int v4 = v5;
    int v6 = v5 + 32;
    BOOL v7 = (v5 - 65) >= 0x1A;
    int v9 = *a2++;
    int v8 = v9;
    if (!v7) {
      int v4 = v6;
    }
    if ((v8 - 65) < 0x1A) {
      v8 += 32;
    }
    if (v4 < v8) {
      break;
    }
    if (v4 > v8) {
      return 1;
    }
    if (v4) {
      BOOL v10 = i == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10) {
      return 0;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D44514(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return vsnprintf(a1, a2, a3, &a9);
}

uint64_t sub_244D44544(char **a1, const char *a2, va_list a3, int a4)
{
  if (a4) {
    int v6 = (void *(*)(unint64_t))MEMORY[0x263EF8970];
  }
  else {
    int v6 = sub_244D43FF4;
  }
  if (a4) {
    BOOL v7 = (void (*)(char *))MEMORY[0x263EF88C0];
  }
  else {
    BOOL v7 = (void (*)(char *))sub_244D440EC;
  }
  if (a4) {
    int v8 = (void *(*)(char *, unint64_t))MEMORY[0x263EF8A48];
  }
  else {
    int v8 = (void *(*)(char *, unint64_t))sub_244D44148;
  }
  int v9 = (char *)v6(64uLL);
  BOOL v10 = v9;
  if (!v9) {
    goto LABEL_19;
  }
  uint64_t result = vsnprintf(v9, 0x40uLL, a2, a3);
  if ((result & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (result < 0x40)
  {
    size_t v12 = 64;
  }
  else
  {
    size_t v12 = result + 1;
    unint64_t v13 = (char *)v8(v10, v12);
    if (!v13) {
      goto LABEL_19;
    }
    uint64_t v14 = v13;
    uint64_t result = vsnprintf(v13, v12, a2, a3);
    BOOL v10 = v14;
    if ((result & 0x80000000) != 0) {
      goto LABEL_19;
    }
  }
  if (v12 > result)
  {
    *a1 = v10;
    return result;
  }
LABEL_19:
  v7(v10);
  *a1 = 0;
  *__error() = 12;
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D4468C(char **a1, const char *a2, va_list a3)
{
  return sub_244D44544(a1, a2, a3, 0);
}

uint64_t sub_244D44694(char **a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_244D44544(a1, a2, &a9, 0);
}

void *sub_244D446C4(unsigned char *a1, size_t a2)
{
  size_t v3 = 0;
  if (a2)
  {
    while (a1[v3])
    {
      if (a2 == ++v3)
      {
        size_t v3 = a2;
        break;
      }
    }
  }
  if (v3 >= a2) {
    size_t v4 = a2;
  }
  else {
    size_t v4 = v3;
  }
  if (v4 == -1)
  {
    sub_244D0B884(14, 0, 65, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/mem.c", 551);
    return 0;
  }
  else
  {
    int v5 = sub_244D43FF4(v4 + 1);
    int v6 = v5;
    if (v5)
    {
      if (v4) {
        memcpy(v5, a1, v4);
      }
      *((unsigned char *)v6 + v4) = 0;
    }
  }
  return v6;
}

size_t sub_244D4476C(unsigned char *a1, char *__s, unint64_t a3)
{
  if (a3 < 2)
  {
    unint64_t v4 = 0;
    if (!a3) {
      return strlen(__s) + v4;
    }
  }
  else
  {
    unint64_t v3 = 0;
    unint64_t v4 = a3 - 1;
    while (__s[v3])
    {
      a1[v3] = __s[v3];
      if (v4 == ++v3)
      {
        __s += v3;
        a1 += v3;
        goto LABEL_9;
      }
    }
    __s += v3;
    a1 += v3;
    unint64_t v4 = v3;
  }
LABEL_9:
  *a1 = 0;
  return strlen(__s) + v4;
}

size_t sub_244D447E4(unsigned char *a1, char *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  if (a3)
  {
    for (unint64_t i = 0; a1[i]; ++i)
    {
      if (!--a3)
      {
        a1 += v3;
        return sub_244D4476C(a1, a2, a3) + v3;
      }
    }
    a1 += i;
    unint64_t v3 = i;
  }
  return sub_244D4476C(a1, a2, a3) + v3;
}

const char **sub_244D44844(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    sub_244CF2A34();
    int v2 = v3;
    if (!v3)
    {
      sub_244D0B884(8, 0, 12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/obj/obj.c", 113);
      return v2;
    }
    *unint64_t v3 = 0;
    v3[1] = 0;
    unint64_t v4 = (const char *)sub_244D442F4(*(const void **)(a1 + 24), *(int *)(a1 + 20));
    v2[3] = v4;
    int v5 = *(_DWORD *)(a1 + 20);
    if (v5)
    {
      int v6 = 0;
      if (!v4) {
        goto LABEL_7;
      }
    }
    *((_DWORD *)v2 + 5) = v5;
    *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
    int v8 = *(const char **)(a1 + 8);
    if (v8)
    {
      int v6 = (char *)sub_244D442B0(v8);
      if (!v6)
      {
LABEL_7:
        sub_244D440EC(v6);
        sub_244D440EC(0);
        sub_244D440EC(0);
        sub_244D440EC(v2);
        return 0;
      }
    }
    else
    {
      int v6 = 0;
    }
    int v9 = *(const char **)a1;
    if (!*(void *)a1 || (int v9 = sub_244D442B0(v9)) != 0)
    {
      char *v2 = v9;
      v2[1] = v6;
      *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32) | 0xD;
      return v2;
    }
    goto LABEL_7;
  }
  return (const char **)a1;
}

uint64_t sub_244D44948(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(int *)(a1 + 20);
  int v3 = *(_DWORD *)(a2 + 20);
  if ((int)v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if ((int)v2 > v3) {
    return 1;
  }
  if (v2) {
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2);
  }
  return 0;
}

uint64_t sub_244D44988(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t sub_244D44994(uint64_t result)
{
  if (result) {
    return *(_DWORD *)(result + 20) & ~(*(int *)(result + 20) >> 31);
  }
  return result;
}

unsigned __int16 *sub_244D449A4(unsigned __int16 *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (unsigned __int16 *)*((unsigned int *)result + 4);
    if (!result)
    {
      sub_244D4BD50(&stru_268EBDAB0);
      if (qword_268EC0220
        && (uint64_t v2 = sub_244D43BC4((void *)qword_268EC0220, (uint64_t)v1, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530)) != 0)
      {
        uint64_t v3 = v2;
        sub_244D4BD90(&stru_268EBDAB0);
        unint64_t v4 = (char **)(v3 + 16);
      }
      else
      {
        sub_244D4BD90(&stru_268EBDAB0);
        uint64_t result = (unsigned __int16 *)bsearch(v1, &unk_244EBA8C8, 0x371uLL, 2uLL, (int (__cdecl *)(const void *, const void *))sub_244D44A90);
        if (!result) {
          return result;
        }
        unsigned int v5 = *result - 1;
        if (v5 >= 0x3C4) {
          abort();
        }
        unint64_t v4 = &off_26519DA38[5 * v5 + 2];
      }
      return (unsigned __int16 *)*(unsigned int *)v4;
    }
  }
  return result;
}

uint64_t sub_244D44A90(uint64_t a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a2 - 1;
  if (v2 >= 0x3C4) {
    abort();
  }

  return sub_244D44948(a1, (uint64_t)&off_26519DA38[5 * v2]);
}

unsigned __int16 *sub_244D44AD8(void *a1)
{
  unint64_t v1 = a1[1];
  if (v1 >> 31) {
    return 0;
  }
  long long v3 = 0u;
  long long v4 = 0u;
  *((void *)&v4 + 1) = *a1;
  uint64_t v5 = 0;
  DWORD1(v4) = v1;
  return sub_244D449A4((unsigned __int16 *)&v3);
}

unsigned __int16 *sub_244D44B24(const void *a1)
{
  sub_244D4BD50(&stru_268EBDAB0);
  if (qword_268EC0228
    && (long long v7 = 0u,
        long long v8 = 0u,
        int v6 = a1,
        (uint64_t v2 = sub_244D43BC4((void *)qword_268EC0228, (uint64_t)&v6, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530)) != 0))
  {
    uint64_t v3 = v2;
    sub_244D4BD90(&stru_268EBDAB0);
    return (unsigned __int16 *)*(unsigned int *)(v3 + 16);
  }
  else
  {
    sub_244D4BD90(&stru_268EBDAB0);
    uint64_t result = (unsigned __int16 *)bsearch(a1, &unk_244EBAFAA, 0x3B9uLL, 2uLL, (int (__cdecl *)(const void *, const void *))sub_244D44C14);
    if (result)
    {
      unsigned int v5 = *result - 1;
      if (v5 >= 0x3C4) {
        abort();
      }
      return (unsigned __int16 *)LODWORD(off_26519DA38[5 * v5 + 2]);
    }
  }
  return result;
}

uint64_t sub_244D44C14(const char *a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a2 - 1;
  if (v2 >= 0x3C4) {
    abort();
  }
  uint64_t v3 = off_26519DA38[5 * v2];

  return strcmp(a1, v3);
}

unsigned __int16 *sub_244D44C60(const void *a1)
{
  sub_244D4BD50(&stru_268EBDAB0);
  if (qword_268EC0230
    && (v6[0] = 0,
        long long v7 = 0u,
        uint64_t v8 = 0,
        v6[1] = a1,
        (uint64_t v2 = sub_244D43BC4((void *)qword_268EC0230, (uint64_t)v6, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530)) != 0))
  {
    uint64_t v3 = v2;
    sub_244D4BD90(&stru_268EBDAB0);
    return (unsigned __int16 *)*(unsigned int *)(v3 + 16);
  }
  else
  {
    sub_244D4BD90(&stru_268EBDAB0);
    uint64_t result = (unsigned __int16 *)bsearch(a1, &unk_244EBB71C, 0x3B9uLL, 2uLL, (int (__cdecl *)(const void *, const void *))sub_244D44D54);
    if (result)
    {
      unsigned int v5 = *result - 1;
      if (v5 >= 0x3C4) {
        abort();
      }
      return (unsigned __int16 *)LODWORD(off_26519DA38[5 * v5 + 2]);
    }
  }
  return result;
}

uint64_t sub_244D44D54(const char *a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a2 - 1;
  if (v2 >= 0x3C4) {
    abort();
  }
  uint64_t v3 = off_26519DA38[5 * v2 + 1];

  return strcmp(a1, v3);
}

unsigned __int16 *sub_244D44DA0(const char *a1)
{
  unint64_t v1 = (unsigned __int16 *)sub_244D44DDC(a1, 0);
  unsigned int v2 = sub_244D449A4(v1);
  sub_244CF29AC((void **)v1);
  return v2;
}

char **sub_244D44DDC(const char *a1, int a2)
{
  if (!a2 && ((unsigned int v4 = sub_244D44B24(a1)) != 0 || (unsigned int v4 = sub_244D44C60(a1)) != 0))
  {
    return sub_244D44ED0(v4);
  }
  else
  {
    return (char **)sub_244D45014(0, a1, 0, 0);
  }
}

uint64_t sub_244D44E54(uint64_t *a1, unsigned int a2)
{
  uint64_t result = (uint64_t)sub_244D44ED0(a2);
  if (result)
  {
    uint64_t v4 = result;
    memset(v5, 0, sizeof(v5));
    uint64_t result = sub_244CFB808(a1, (uint64_t)v5, 6u);
    if (result)
    {
      uint64_t result = sub_244CFBA40((uint64_t)v5, *(const void **)(v4 + 24), *(int *)(v4 + 20));
      if (result) {
        return sub_244CFB540(a1) != 0;
      }
    }
  }
  return result;
}

char **sub_244D44ED0(unsigned int a1)
{
  if (!a1) {
    return off_26519DA10;
  }
  if (a1 > 0x3C4)
  {
    sub_244D4BD50(&stru_268EBDAB0);
    if (!qword_268EC0238
      || (uint64_t v7 = 0,
          long long v5 = 0u,
          long long v6 = 0u,
          LODWORD(v6) = a1,
          (uint64_t v3 = sub_244D43BC4((void *)qword_268EC0238, (uint64_t)&v5, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530)) == 0))
    {
      sub_244D4BD90(&stru_268EBDAB0);
LABEL_10:
      sub_244D0B884(8, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/obj/obj.c", 373);
      return 0;
    }
    unsigned int v2 = (char **)v3;
    sub_244D4BD90(&stru_268EBDAB0);
  }
  else
  {
    unsigned int v2 = &off_26519DA38[5 * a1 - 5];
    if (!*((_DWORD *)v2 + 4)) {
      goto LABEL_10;
    }
  }
  return v2;
}

char **sub_244D44FC8()
{
  return off_26519DA10;
}

char **sub_244D44FD4(unsigned int a1)
{
  uint64_t result = sub_244D44ED0(a1);
  if (result) {
    return (char **)*result;
  }
  return result;
}

char **sub_244D44FF4(unsigned int a1)
{
  uint64_t result = sub_244D44ED0(a1);
  if (result) {
    return (char **)result[1];
  }
  return result;
}

const char **sub_244D45014(uint64_t (*a1)(void), const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = 0;
  unint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  if (sub_244CFB3DC((uint64_t)v12, 0x20uLL)
    && (size_t v8 = strlen(a2), sub_244CFC170((uint64_t *)v12, (uint64_t)a2, v8))
    && sub_244CFB48C((uint64_t)v12, &v14, &v13))
  {
    if (a1) {
      int v9 = a1();
    }
    else {
      int v9 = 0;
    }
    BOOL v10 = sub_244CF2948(v9, (uint64_t)v14, v13, a3, a4);
    sub_244D440EC(v14);
  }
  else
  {
    sub_244D0B884(8, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/obj/obj.c", 405);
    sub_244CFB470((uint64_t)v12);
    return 0;
  }
  return v10;
}

size_t sub_244D45104(unsigned char *a1, int a2, uint64_t a3, int a4)
{
  if (a3 && *(_DWORD *)(a3 + 20))
  {
    if (a4
      || (unsigned int v13 = sub_244D449A4((unsigned __int16 *)a3)) == 0
      || ((v14 = v13, (v15 = sub_244D44ED0(v13)) == 0) || (unsigned int v11 = v15[1]) == 0)
      && ((v16 = sub_244D44ED0(v14)) == 0 || (unsigned int v11 = *v16) == 0))
    {
      uint64_t v7 = (unsigned __int8 *)*(int *)(a3 + 20);
      v17[0] = *(unsigned __int8 **)(a3 + 24);
      v17[1] = v7;
      size_t v8 = (char *)sub_244CFD528(v17);
      if (v8)
      {
        int v9 = v8;
        size_t v10 = sub_244D45208(a1, v8, a2);
        sub_244D440EC(v9);
      }
      else
      {
        if (a2 >= 1) {
          *a1 = 0;
        }
        return 0xFFFFFFFFLL;
      }
      return v10;
    }
  }
  else
  {
    unsigned int v11 = "";
  }

  return sub_244D45208(a1, v11, a2);
}

size_t sub_244D45208(unsigned char *a1, char *a2, int a3)
{
  size_t result = sub_244D4476C(a1, a2, a3 & ~(a3 >> 31));
  if (result >> 31)
  {
    sub_244D0B884(8, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/obj/obj.c", 434);
    return 0xFFFFFFFFLL;
  }
  return result;
}

const char **sub_244D4524C(const char *a1, uint64_t a2, uint64_t a3)
{
  size_t result = sub_244D45014(sub_244D454DC, a1, a2, a3);
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    *((_DWORD *)result + 8) &= 0xFFFFFFF2;
    sub_244D4BD70(&stru_268EBDAB0);
    if (!qword_268EC0238) {
      qword_268EC0238 = (uint64_t)sub_244D43AD0((uint64_t)sub_244D45540, (uint64_t)sub_244D45548);
    }
    if (!qword_268EC0220) {
      qword_268EC0220 = (uint64_t)sub_244D43AD0((uint64_t)sub_244D45558, (uint64_t)sub_244D44948);
    }
    long long v5 = (void *)qword_268EC0228;
    if (!qword_268EC0228)
    {
      long long v5 = sub_244D43AD0((uint64_t)sub_244D45568, (uint64_t)sub_244D45570);
      qword_268EC0228 = (uint64_t)v5;
    }
    long long v6 = (void *)qword_268EC0230;
    if (!qword_268EC0230)
    {
      long long v6 = sub_244D43AD0((uint64_t)sub_244D4557C, (uint64_t)sub_244D45584);
      qword_268EC0230 = (uint64_t)v6;
      long long v5 = (void *)qword_268EC0228;
    }
    if (qword_268EC0238 && qword_268EC0220 && v5 && v6)
    {
      uint64_t v8 = 0;
      int v7 = sub_244D43D34((void *)qword_268EC0238, &v8, v4, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530);
      if (*(_DWORD *)(v4 + 20) && *(void *)(v4 + 24))
      {
        uint64_t v8 = 0;
        v7 &= sub_244D43D34((void *)qword_268EC0220, &v8, v4, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530);
      }
      if (*(void *)v4)
      {
        uint64_t v8 = 0;
        v7 &= sub_244D43D34((void *)qword_268EC0228, &v8, v4, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530);
      }
      if (*(void *)(v4 + 8))
      {
        uint64_t v8 = 0;
        v7 &= sub_244D43D34((void *)qword_268EC0230, &v8, v4, (uint64_t (*)(void, uint64_t))sub_244D45524, (unsigned int (*)(void, void, uint64_t))sub_244D45530);
      }
      sub_244D4BD90(&stru_268EBDAB0);
      if (v7) {
        return (const char **)*(unsigned int *)(v4 + 16);
      }
    }
    else
    {
      sub_244D4BD90(&stru_268EBDAB0);
    }
    return 0;
  }
  return result;
}

uint64_t sub_244D454DC()
{
  sub_244D4BD70(&stru_268EBDB78);
  uint64_t v0 = dword_268EBDC40++;
  sub_244D4BD90(&stru_268EBDB78);
  return v0;
}

uint64_t sub_244D45524(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D45530(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t sub_244D45540(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_244D45548(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16));
}

uint64_t sub_244D45558(uint64_t a1)
{
  return sub_244D44204(*(unsigned __int8 **)(a1 + 24), *(int *)(a1 + 20));
}

uint64_t sub_244D45568(const char **a1)
{
  return sub_244D44234(*a1);
}

uint64_t sub_244D45570(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t sub_244D4557C(uint64_t a1)
{
  return sub_244D44234(*(const char **)(a1 + 8));
}

uint64_t sub_244D45584(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8));
}

BOOL sub_244D45590(int a1, _DWORD *a2, _DWORD *a3)
{
  if (a1 == 396)
  {
    unint64_t v3 = 0;
    BOOL result = 1;
LABEL_7:
    if (a2) {
      *a2 = *((_DWORD *)&unk_244EBD6C4 + 3 * v3 + 1);
    }
    if (a3) {
      *a3 = *((_DWORD *)&unk_244EBD6C4 + 3 * v3 + 2);
    }
  }
  else
  {
    unint64_t v5 = -1;
    long long v6 = &dword_244EBD6D0;
    while (v5 != 16)
    {
      int v7 = *v6;
      v6 += 3;
      ++v5;
      if (v7 == a1)
      {
        BOOL result = v5 < 0x11;
        unint64_t v3 = v5 + 1;
        goto LABEL_7;
      }
    }
    return 0;
  }
  return result;
}

BOOL sub_244D45610(_DWORD *a1, int a2, int a3)
{
  unint64_t v3 = 0;
  BOOL v4 = 1;
  for (unint64_t i = &dword_244EBD6CC; *(i - 1) != a2 || *i != a3; i += 3)
  {
    BOOL v4 = v3 < 0x11;
    if (++v3 == 18) {
      return 0;
    }
  }
  if (a1) {
    *a1 = *(i - 2);
  }
  return v4;
}

uint64_t sub_244D45670(uint64_t *a1, uint64_t a2, unsigned int *a3, unsigned int a4, uint64_t a5, unint64_t a6, const void *a7, size_t a8)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  int v16 = sub_244CF48D8(a3);
  if (v16)
  {
    int v17 = v16;
    unsigned int v18 = sub_244CBEBF4((uint64_t)a3);
    uint64_t result = sub_244D20964(v33, v18);
    if (result)
    {
      memset(v32, 0, sizeof(v32));
      memset(v31, 0, sizeof(v31));
      memset(v30, 0, sizeof(v30));
      memset(v29, 0, sizeof(v29));
      memset(v28, 0, sizeof(v28));
      memset(v27, 0, sizeof(v27));
      memset(v26, 0, sizeof(v26));
      memset(v25, 0, sizeof(v25));
      memset(v24, 0, sizeof(v24));
      uint64_t result = sub_244CFB808(a1, (uint64_t)v32, 0x20000010u);
      if (result)
      {
        uint64_t result = sub_244CFB808((uint64_t *)v32, (uint64_t)v31, 6u);
        if (result)
        {
          uint64_t result = sub_244CFBA40((uint64_t)v31, &unk_244EBD79C, 9uLL);
          if (result)
          {
            uint64_t result = sub_244CFB808((uint64_t *)v32, (uint64_t)v30, 0x20000010u);
            if (result)
            {
              uint64_t result = sub_244CFB808((uint64_t *)v30, (uint64_t)v29, 0x20000010u);
              if (result)
              {
                uint64_t result = sub_244CFB808((uint64_t *)v29, (uint64_t)v28, 6u);
                if (result)
                {
                  uint64_t result = sub_244CFBA40((uint64_t)v28, asc_244EBD7A5, 9uLL);
                  if (result)
                  {
                    uint64_t result = sub_244CFB808((uint64_t *)v29, (uint64_t)v27, 0x20000010u);
                    if (result)
                    {
                      uint64_t result = sub_244CFB808((uint64_t *)v27, (uint64_t)v26, 4u);
                      if (result)
                      {
                        uint64_t result = sub_244CFBA40((uint64_t)v26, a7, a8);
                        if (result)
                        {
                          uint64_t result = sub_244CFBDDC((uint64_t)v27, a4);
                          if (result)
                          {
                            if (v17 != 37
                              || (unsigned int v20 = sub_244D22F44((uint64_t)a3),
                                  uint64_t result = sub_244CFBDDC((uint64_t)v27, v20),
                                  result))
                            {
                              uint64_t result = sub_244CFB808((uint64_t *)v30, (uint64_t)v25, 0x20000010u);
                              if (result)
                              {
                                uint64_t result = sub_244D45944((uint64_t *)v25, v17);
                                if (result)
                                {
                                  uint64_t result = sub_244CFB808((uint64_t *)v25, (uint64_t)v24, 4u);
                                  if (result)
                                  {
                                    unsigned int v21 = sub_244CBEBF4((uint64_t)a3);
                                    uint64_t result = sub_244CFBA40((uint64_t)v24, v33, v21);
                                    if (result)
                                    {
                                      uint64_t result = sub_244CFB540(a1);
                                      if (result)
                                      {
                                        int v22 = sub_244D25B18();
                                        unsigned int v23 = sub_244CBEBF4((uint64_t)a3);
                                        return sub_244D45A04(a2, (uint64_t)a3, (uint64_t)v22, a4, a5, a6, (uint64_t)a7, a8, v33, v23, 1);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    sub_244D0B884(19, 0, 102, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/p5_pbev2.c", 170);
    return 0;
  }
  return result;
}

uint64_t sub_244D45944(uint64_t *a1, int a2)
{
  uint64_t v3 = 0;
  while (*(_DWORD *)&byte_26F955250[v3 + 12] != a2)
  {
    v3 += 24;
    if (v3 == 120)
    {
      sub_244D0B884(19, 0, 127, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/p5_pbev2.c", 142);
      return 0;
    }
  }
  memset(v5, 0, sizeof(v5));
  uint64_t result = sub_244CFB808(a1, (uint64_t)v5, 6u);
  if (result)
  {
    uint64_t result = sub_244CFBA40((uint64_t)v5, &byte_26F955250[v3], byte_26F955250[v3 + 9]);
    if (result) {
      return sub_244CFB540(a1) != 0;
    }
  }
  return result;
}

BOOL sub_244D45A04(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, int a11)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (sub_244CBEBF4(a2) == a10)
  {
    unsigned int v19 = sub_244D22F44(a2);
    BOOL v20 = sub_244D127A0(a5, a6, a7, a8, a4, a3, v19, v22)
       && sub_244D224C4(a1, a2, 0, (uint64_t)v22, a9, a11) != 0;
    sub_244D4413C(v22, 0x40uLL);
  }
  else
  {
    sub_244D0B884(19, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/p5_pbev2.c", 152);
    return 0;
  }
  return v20;
}

BOOL sub_244D45B3C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  long long v30 = 0uLL;
  long long v29 = 0uLL;
  v28[0] = 0;
  v28[1] = 0;
  long long v27 = 0uLL;
  v26[0] = 0;
  v26[1] = 0;
  if (sub_244CFCD34((long long *)a5, &v30, 536870928)
    && !*(void *)(a5 + 8)
    && sub_244CFCD34(&v30, &v29, 536870928)
    && sub_244CFCD34(&v30, &v27, 536870928)
    && !*((void *)&v30 + 1)
    && sub_244CFCD34(&v29, v28, 6)
    && sub_244CFCD34(&v27, v26, 6))
  {
    if (sub_244CFC618((uint64_t)v28, asc_244EBD7A5, 9))
    {
      uint64_t v12 = sub_244D45F0C((uint64_t)v26);
      if (v12)
      {
        uint64_t v13 = v12;
        long long v25 = 0uLL;
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        uint64_t v22 = 0;
        if (sub_244CFCD34(&v29, &v25, 536870928)
          && !*((void *)&v29 + 1)
          && sub_244CFCD34(&v25, &v23, 4)
          && sub_244CFCEF4(&v25, (unint64_t *)&v22))
        {
          if (sub_244D46D98(v22))
          {
            if (sub_244CFCE04(&v25, 2))
            {
              *(void *)&long long v21 = 0;
              if (!sub_244CFCEF4(&v25, (unint64_t *)&v21))
              {
                int v9 = 104;
                __int16 v10 = 261;
                goto LABEL_4;
              }
              uint64_t v14 = v21;
              if (v14 != sub_244D22F44(v13))
              {
                int v9 = 125;
                __int16 v10 = 266;
                goto LABEL_4;
              }
            }
            unint64_t v15 = sub_244D25B18();
            if (*((void *)&v25 + 1))
            {
              long long v21 = 0uLL;
              v20[0] = 0;
              v20[1] = 0;
              if (!sub_244CFCD34(&v25, &v21, 536870928)
                || !sub_244CFCD34(&v21, v20, 6)
                || *((void *)&v25 + 1))
              {
                int v9 = 104;
                __int16 v10 = 277;
                goto LABEL_4;
              }
              if (sub_244CFC618((uint64_t)v20, asc_244EBD7AE, 8))
              {
                int v16 = sub_244D25B18();
              }
              else
              {
                if (!sub_244CFC618((uint64_t)v20, asc_244EBD7B6, 8))
                {
                  int v9 = 130;
                  __int16 v10 = 288;
                  goto LABEL_4;
                }
                int v16 = sub_244D25C38();
              }
              uint64_t v17 = (uint64_t)v16;
              uint64_t v18 = 0;
              uint64_t v19 = 0;
              if (!sub_244CFCD34(&v21, &v18, 5) || v19 || *((void *)&v21 + 1))
              {
                int v9 = 104;
                __int16 v10 = 297;
                goto LABEL_4;
              }
            }
            else
            {
              uint64_t v17 = (uint64_t)v15;
            }
            long long v21 = 0uLL;
            if (sub_244CFCD34(&v27, &v21, 4) && !*((void *)&v27 + 1)) {
              return sub_244D45A04(a2, v13, v17, v22, a3, a4, v23, v24, (const void *)v21, *((uint64_t *)&v21 + 1), 0);
            }
            int v9 = 130;
            __int16 v10 = 309;
          }
          else
          {
            int v9 = 129;
            __int16 v10 = 252;
          }
        }
        else
        {
          int v9 = 104;
          __int16 v10 = 247;
        }
      }
      else
      {
        int v9 = 127;
        __int16 v10 = 236;
      }
    }
    else
    {
      int v9 = 128;
      __int16 v10 = 229;
    }
  }
  else
  {
    int v9 = 104;
    __int16 v10 = 223;
  }
LABEL_4:
  sub_244D0B884(19, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/p5_pbev2.c", v10);
  return 0;
}

uint64_t sub_244D45F0C(uint64_t a1)
{
  uint64_t v2 = 0;
  while (!sub_244CFC618(a1, &byte_26F955250[v2], byte_26F955250[v2 + 9]))
  {
    v2 += 24;
    if (v2 == 120) {
      return 0;
    }
  }
  BOOL v4 = *(uint64_t (**)(void))&byte_26F955250[v2 + 16];

  return v4();
}

uint64_t sub_244D45F8C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unsigned int a6, unint64_t a7, char *a8, uint64_t a9)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if (a6)
  {
    memset(v45, 0, sizeof(v45));
    sub_244D25618(v45);
    unint64_t v43 = 0;
    unint64_t v44 = 0;
    if (a1)
    {
      memset(v47, 0, 48);
      if (!sub_244CFB3DC((uint64_t)v47, 2 * a2)) {
        goto LABEL_20;
      }
      uint64_t __src = a1;
      uint64_t v49 = a2;
      if (a2)
      {
        while (1)
        {
          unsigned int v46 = 0;
          if (!sub_244CFDB28(&__src, &v46) || !sub_244CFDF18((uint64_t)v47, v46)) {
            break;
          }
          if (!v49) {
            goto LABEL_8;
          }
        }
        sub_244D0B884(19, 0, 131, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", 90);
        goto LABEL_19;
      }
LABEL_8:
      if (!sub_244CFDF18((uint64_t)v47, 0) || !sub_244CFB48C((uint64_t)v47, &v44, &v43))
      {
LABEL_19:
        sub_244CFB470((uint64_t)v47);
        goto LABEL_20;
      }
    }
    unint64_t v16 = sub_244D25610(a9);
    if (v16) {
      __memset_chk();
    }
    unint64_t v17 = a4 + v16 - 1;
    if (v17 < a4 || (unint64_t v18 = v16 - 1 + v43, __CFADD__(v16 - 1, v43)))
    {
      __int16 v19 = 151;
    }
    else
    {
      unint64_t v41 = a8;
      unint64_t v23 = v17 / v16 * v16;
      unint64_t v24 = v18 / v16 * v16;
      if (!__CFADD__(v24, v23))
      {
        unint64_t v42 = v24 + v23;
        long long v25 = sub_244D43FF4(v24 + v23);
        if (v42) {
          BOOL v26 = v25 == 0;
        }
        else {
          BOOL v26 = 0;
        }
        if (!v26)
        {
          long long v21 = v25;
          if (v17 != v17 % v16)
          {
            unint64_t v27 = 0;
            if (v23 <= 1) {
              uint64_t v28 = 1;
            }
            else {
              uint64_t v28 = v17 / v16 * v16;
            }
            do
            {
              *((unsigned char *)v25 + v27) = *(unsigned char *)(a3 + v27 % a4);
              ++v27;
            }
            while (v28 != v27);
          }
          if (v18 != v18 % v16)
          {
            unint64_t v29 = 0;
            if (v24 <= 1) {
              uint64_t v30 = 1;
            }
            else {
              uint64_t v30 = v18 / v16 * v16;
            }
            do
            {
              *((unsigned char *)v25 + v29 + v23) = *((unsigned char *)v44 + v29 % v43);
              ++v29;
            }
            while (v30 != v29);
          }
          if (a7)
          {
            unsigned int v46 = 0;
            uint64_t v31 = v41;
            if (sub_244D258CC((uint64_t)v45, a9))
            {
              while (sub_244D2593C((uint64_t)v45)
                   && sub_244D2593C((uint64_t)v45)
                   && sub_244D25960((void **)v45, (uint64_t)&__src, &v46))
              {
                unsigned int v32 = a6 - 1;
                if (a6 >= 2)
                {
                  while (sub_244D258CC((uint64_t)v45, a9)
                       && sub_244D2593C((uint64_t)v45)
                       && sub_244D25960((void **)v45, (uint64_t)&__src, &v46))
                  {
                    if (!--v32) {
                      goto LABEL_50;
                    }
                  }
                  break;
                }
LABEL_50:
                unint64_t v33 = v46;
                if (a7 >= v46) {
                  size_t v34 = v46;
                }
                else {
                  size_t v34 = a7;
                }
                if (v34) {
                  memcpy(v31, &__src, v34);
                }
                a7 -= v34;
                if (!a7) {
                  goto LABEL_65;
                }
                unint64_t v35 = 0;
                do
                {
                  *((unsigned char *)v47 + v35) = *((unsigned char *)&__src + v35 % v33);
                  ++v35;
                }
                while (v16 != v35);
                if (v42)
                {
                  unint64_t v36 = 0;
                  BOOL v37 = v21;
                  do
                  {
                    int v38 = 1;
                    unint64_t v39 = v16 - 1;
                    do
                    {
                      unsigned int v40 = v38 + *((unsigned __int8 *)v37 + v39) + *((unsigned __int8 *)v47 + v39);
                      *((unsigned char *)v37 + v39) = v40;
                      int v38 = v40 >> 8;
                      --v39;
                    }
                    while (v39 < v16);
                    v36 += v16;
                    BOOL v37 = (void *)((char *)v37 + v16);
                  }
                  while (v36 < v42);
                }
                v31 += v34;
                unsigned int v46 = 0;
                if (!sub_244D258CC((uint64_t)v45, a9)) {
                  break;
                }
              }
            }
            uint64_t v20 = 0;
          }
          else
          {
LABEL_65:
            uint64_t v20 = 1;
          }
          goto LABEL_21;
        }
LABEL_20:
        uint64_t v20 = 0;
        long long v21 = 0;
LABEL_21:
        sub_244D440EC(v21);
        sub_244D440EC(v44);
        sub_244D25650((uint64_t)v45);
        return v20;
      }
      __int16 v19 = 158;
    }
    sub_244D0B884(19, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", v19);
    goto LABEL_20;
  }
  sub_244D0B884(19, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", 115);
  return 0;
}

uint64_t sub_244D463D0(uint64_t *a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8)
{
  uint64_t v15 = 0;
  while (v15 == 30 || dword_26F9552C8[v15] != a3)
  {
    v15 += 10;
    if (v15 == 40)
    {
      sub_244D0B884(19, 0, 119, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", 337);
      return 0;
    }
  }
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  memset(v17, 0, sizeof(v17));
  uint64_t result = sub_244CFB808(a1, (uint64_t)v20, 0x20000010u);
  if (result)
  {
    uint64_t result = sub_244CFB808((uint64_t *)v20, (uint64_t)v19, 6u);
    if (result)
    {
      uint64_t result = sub_244CFBA40((uint64_t)v19, &dword_26F9552C8[v15 + 1], BYTE2(dword_26F9552C8[v15 + 3]));
      if (result)
      {
        uint64_t result = sub_244CFB808((uint64_t *)v20, (uint64_t)v18, 0x20000010u);
        if (result)
        {
          uint64_t result = sub_244CFB808((uint64_t *)v18, (uint64_t)v17, 4u);
          if (result)
          {
            uint64_t result = sub_244CFBA40((uint64_t)v17, a7, a8);
            if (result)
            {
              uint64_t result = sub_244CFBDDC((uint64_t)v18, a4);
              if (result)
              {
                uint64_t result = sub_244CFB540(a1);
                if (result) {
                  return sub_244D46564((uint64_t)&dword_26F9552C8[v15], a2, a4, a5, a6, (uint64_t)a7, a8, 1);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_244D46564(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, int a8)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v16 = (*(uint64_t (**)(void))(a1 + 16))();
  uint64_t v17 = (*(uint64_t (**)(void))(a1 + 24))();
  unsigned int v18 = sub_244D22F44(v16);
  if (sub_244D45F8C(a4, a5, a6, a7, 1, a3, v18, v23, v17)
    && (unsigned int v19 = sub_244CBEBF4(v16), sub_244D45F8C(a4, a5, a6, a7, 2, a3, v19, v22, v17)))
  {
    uint64_t v20 = sub_244D224C4(a2, v16, 0, (uint64_t)v23, v22, a8);
    sub_244D4413C(v23, 0x40uLL);
    sub_244D4413C(v22, 0x10uLL);
  }
  else
  {
    sub_244D0B884(19, 0, 110, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", 245);
    return 0;
  }
  return v20;
}

uint64_t sub_244D466D4(void *a1, void *a2, long long *a3, uint64_t a4, uint64_t a5, char *a6, unint64_t a7)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v23 = 0;
  memset(v22, 0, sizeof(v22));
  sub_244D22284((uint64_t)v22);
  v21[0] = 0;
  v21[1] = 0;
  if (!sub_244CFCD34(a3, v21, 6))
  {
    int v15 = 104;
    __int16 v16 = 368;
LABEL_12:
    sub_244D0B884(19, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", v16);
    uint64_t v18 = 0;
    goto LABEL_13;
  }
  uint64_t v14 = 0;
  while (!sub_244CFC618((uint64_t)v21, (char *)&dword_26F9552C8[v14 + 1], BYTE2(dword_26F9552C8[v14 + 3])))
  {
    v14 += 10;
    if (v14 == 40)
    {
      int v15 = 119;
      __int16 v16 = 380;
      goto LABEL_12;
    }
  }
  if (!(*(unsigned int (**)(int *, _OWORD *, uint64_t, uint64_t, long long *))&dword_26F9552C8[v14 + 8])(&dword_26F9552C8[v14], v22, a4, a5, a3))
  {
    int v15 = 109;
    __int16 v16 = 385;
    goto LABEL_12;
  }
  uint64_t v17 = sub_244D43FF4(a7);
  if (!v17)
  {
LABEL_18:
    uint64_t v18 = 0;
    goto LABEL_14;
  }
  if (a7 >> 31)
  {
    sub_244D0B884(19, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", 395);
    goto LABEL_18;
  }
  uint64_t v20 = 0;
  if (!sub_244D22B38((int *)v22, v17, (int *)&v20 + 1, a6, a7)
    || !sub_244D22D00((uint64_t *)v22, (unsigned char *)v17 + SHIDWORD(v20), &v20))
  {
    goto LABEL_18;
  }
  *a1 = v17;
  *a2 = (int)v20 + (uint64_t)SHIDWORD(v20);
  uint64_t v18 = 1;
LABEL_13:
  uint64_t v17 = 0;
LABEL_14:
  sub_244D440EC(v17);
  sub_244D222E0((uint64_t)v22);
  return v18;
}

uint64_t sub_244D468F0(long long *a1, uint64_t a2, uint64_t a3)
{
  long long v14 = 0uLL;
  long long v13 = 0uLL;
  unsigned int v11 = 0;
  unint64_t v12 = 0;
  if (!sub_244CFCD34(a1, &v14, 536870928)
    || !sub_244CFCD34(&v14, &v13, 536870928)
    || !sub_244CFCD34(&v14, &v11, 4)
    || *((void *)&v14 + 1))
  {
    sub_244D0B884(19, 0, 104, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", 424);
    return 0;
  }
  uint64_t v9 = 0;
  __int16 v10 = 0;
  if (!sub_244D466D4(&v10, &v9, &v13, a2, a3, v11, v12)) {
    return 0;
  }
  unint64_t v5 = v10;
  *(void *)&long long v8 = v10;
  *((void *)&v8 + 1) = v9;
  uint64_t v6 = sub_244D0CB34(&v8);
  sub_244D440EC(v5);
  return v6;
}

BOOL sub_244D469D8(uint64_t *a1, int a2, unsigned int *a3, uint64_t a4, unint64_t a5, char *a6, unint64_t a7, signed int a8, uint64_t a9)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  unint64_t v28 = 0;
  unint64_t v29 = 0;
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  sub_244D22284((uint64_t)v30);
  if (a6)
  {
    uint64_t v17 = 0;
  }
  else
  {
    if (!a7) {
      a7 = 8;
    }
    uint64_t v20 = (char *)sub_244D43FF4(a7);
    uint64_t v17 = v20;
    if (!v20 || !sub_244D20964(v20, a7)) {
      goto LABEL_13;
    }
    a6 = v17;
  }
  memset(&v27[1], 0, 32);
  if (a8 < 1) {
    a8 = 2048;
  }
  v27[0] = 0uLL;
  if (sub_244CFB3DC((uint64_t)v27, 0x80uLL)
    && sub_244D0CC74((uint64_t)v27, a9)
    && sub_244CFB48C((uint64_t)v27, &v29, &v28))
  {
    memset(v26, 0, sizeof(v26));
    if (sub_244CFB808(a1, (uint64_t)v26, 0x20000010u))
    {
      if (a2 == -1)
      {
        if (!sub_244D45670((uint64_t *)v26, (uint64_t)v30, a3, a8, a4, a5, a6, a7)) {
          goto LABEL_13;
        }
      }
      else if (!sub_244D463D0((uint64_t *)v26, (uint64_t)v30, a2, a8, a4, a5, a6, a7))
      {
        goto LABEL_13;
      }
      unint64_t v21 = v28;
      unint64_t v22 = v21 + sub_244D22EA4((uint64_t)v30);
      if (v22 >= v28)
      {
        memset(v25, 0, sizeof(v25));
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        if (sub_244CFB808((uint64_t *)v26, (uint64_t)v25, 4u)
          && sub_244CFBB50((uint64_t)v25, &v24, v22)
          && sub_244D22E84((int *)v30, v24, (int *)&v23 + 1, (char *)v29, v28)
          && sub_244D22E94((uint64_t *)v30, v24 + SHIDWORD(v23), &v23)
          && sub_244CFBC74((uint64_t)v25, (int)v23 + (uint64_t)SHIDWORD(v23)))
        {
          BOOL v18 = sub_244CFB540(a1) != 0;
          goto LABEL_14;
        }
      }
      else
      {
        sub_244D0B884(19, 0, 118, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", 504);
      }
    }
  }
  else
  {
    sub_244CFB470((uint64_t)v27);
  }
LABEL_13:
  BOOL v18 = 0;
LABEL_14:
  sub_244D440EC(v29);
  sub_244D440EC(v17);
  sub_244D222E0((uint64_t)v30);
  return v18;
}

uint64_t sub_244D46C8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  long long v16 = 0uLL;
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  uint64_t v13 = 0;
  if (sub_244CFCD34((long long *)a5, &v16, 536870928)
    && sub_244CFCD34(&v16, &v14, 4)
    && sub_244CFCEF4(&v16, (unint64_t *)&v13)
    && !*((void *)&v16 + 1)
    && !*(void *)(a5 + 8))
  {
    if (sub_244D46D98(v13)) {
      return sub_244D46564(a1, a2, v13, a3, a4, v14, v15, 0);
    }
    int v10 = 129;
    __int16 v11 = 270;
  }
  else
  {
    int v10 = 104;
    __int16 v11 = 265;
  }
  sub_244D0B884(19, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8.c", v11);
  return 0;
}

BOOL sub_244D46D98(uint64_t a1)
{
  return (unint64_t)(a1 - 1) < 0x5F5E100;
}

uint64_t sub_244D46DB0(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A7180);
}

uint64_t sub_244D46DBC(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A7180);
}

uint64_t sub_244D46DC8()
{
  return sub_244CF7888((uint64_t)&unk_2651A7180);
}

void sub_244D46DD4(uint64_t a1)
{
}

uint64_t sub_244D46DE0(uint64_t a1)
{
  unint64_t v5 = 0;
  unsigned int v1 = sub_244CF6668(a1, &v5, (uint64_t)&unk_2651A7180);
  if ((v1 & 0x80000000) != 0) {
    return 0;
  }
  *(void *)&long long v4 = v5;
  *((void *)&v4 + 1) = v1;
  uint64_t v2 = sub_244D0CB34(&v4);
  if (!v2 || *((void *)&v4 + 1))
  {
    sub_244D0B884(19, 0, 104, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 115);
    sub_244D0BFD0(v2);
    uint64_t v2 = 0;
  }
  sub_244D440EC(v5);
  return v2;
}

uint64_t sub_244D46E7C(uint64_t a1)
{
  memset(v10, 0, sizeof(v10));
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (!sub_244CFB3DC((uint64_t)v10, 0)
    || !sub_244D0CC74((uint64_t)v10, a1)
    || !sub_244CFB48C((uint64_t)v10, &v9, &v8)
    || v8 < 0)
  {
    sub_244CFB470((uint64_t)v10);
    int v4 = 105;
    __int16 v5 = 134;
    goto LABEL_9;
  }
  int v7 = (char *)v9;
  uint64_t v2 = sub_244CF5200(0, (uint64_t *)&v7, v8, (uint64_t)&unk_2651A7180);
  if (!v2 || (uint64_t v3 = v9, v7 != (char *)v9 + v8))
  {
    sub_244CF746C(v2, (uint64_t)&unk_2651A7180);
    int v4 = 104;
    __int16 v5 = 142;
LABEL_9:
    sub_244D0B884(19, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", v5);
    uint64_t v2 = 0;
    uint64_t v3 = v9;
  }
  sub_244D440EC(v3);
  return v2;
}

uint64_t sub_244D46F88(uint64_t a1, char *__s, int a3)
{
  if (__s && a3 == -1) {
    size_t v5 = strlen(__s);
  }
  else {
    size_t v5 = a3;
  }
  unint64_t v12 = 0;
  unsigned int v6 = sub_244D62DA4(a1, &v12);
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
  }
  else
  {
    *(void *)&long long v11 = v12;
    *((void *)&v11 + 1) = v6;
    uint64_t v7 = sub_244D468F0(&v11, (uint64_t)__s, v5);
    uint64_t v8 = v7;
    if (v7 && !*((void *)&v11 + 1)) {
      uint64_t v9 = sub_244D46E7C(v7);
    }
    else {
      uint64_t v9 = 0;
    }
  }
  sub_244D440EC(v12);
  sub_244D0BFD0(v8);
  return v9;
}

uint64_t sub_244D47050(int a1, unsigned int *a2, char *__s, int a4, char *a5, unint64_t a6, signed int a7, uint64_t a8)
{
  if (__s && a4 == -1) {
    size_t v15 = strlen(__s);
  }
  else {
    size_t v15 = a4;
  }
  uint64_t v16 = sub_244D46DE0(a8);
  if (!v16) {
    return 0;
  }
  uint64_t v17 = v16;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  memset(v21, 0, sizeof(v21));
  if (sub_244CFB3DC((uint64_t)v21, 0x80uLL)
    && sub_244D469D8((uint64_t *)v21, a1, a2, (uint64_t)__s, v15, a5, a6, a7, v17)
    && sub_244CFB48C((uint64_t)v21, &v23, &v22))
  {
    uint64_t v20 = (char *)v23;
    uint64_t v18 = sub_244D62D98(0, (uint64_t *)&v20, v22);
    if (v18 && v20 == (char *)v23 + v22) {
      goto LABEL_14;
    }
    sub_244D0B884(19, 0, 68, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 221);
    sub_244D62DBC(v18);
  }
  else
  {
    sub_244CFB470((uint64_t)v21);
  }
  uint64_t v18 = 0;
LABEL_14:
  sub_244D440EC(v23);
  sub_244D0BFD0(v17);
  return v18;
}

uint64_t sub_244D471B8(uint64_t *a1, uint64_t *a2, uint64_t a3, const char *a4)
{
  size_t v34 = 0;
  long long v33 = 0uLL;
  long long v32 = 0uLL;
  long long v31 = 0uLL;
  long long v30 = 0uLL;
  v29[0] = 0;
  v29[1] = 0;
  long long v28 = 0uLL;
  v27[0] = 0;
  v27[1] = 0;
  unint64_t v26 = 0;
  unint64_t v8 = sub_244D259E0((uint64_t)a2);
  if (sub_244CFAEDC(a3, &v33, &v34))
  {
    *a1 = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    if (sub_244CFCD34(&v33, &v32, 536870928)
      && !*((void *)&v33 + 1)
      && sub_244CFCEF4(&v32, &v26))
    {
      if (v26 > 2)
      {
        if (sub_244CFCD34(&v32, &v30, 536870928))
        {
          if (*((void *)&v32 + 1))
          {
            if (sub_244CFCD34(&v32, &v31, 536870928))
            {
              if (sub_244CFCD34(&v30, v29, 6) && sub_244CFCD34(&v30, &v28, -1610612736))
              {
                if (sub_244CFC618((uint64_t)v29, asc_244EBD7BE, 9))
                {
                  if (sub_244CFCD34(&v28, v27, 4))
                  {
                    *(void *)&long long v24 = a1;
                    *((void *)&v24 + 1) = a2;
                    *(void *)&long long v25 = a4;
                    if (a4) {
                      size_t v13 = strlen(a4);
                    }
                    else {
                      size_t v13 = 0;
                    }
                    *((void *)&v25 + 1) = v13;
                    long long v23 = 0uLL;
                    v22[0] = 0;
                    v22[1] = 0;
                    v21[0] = 0;
                    v21[1] = 0;
                    if (!sub_244CFCD34(&v31, &v23, 536870928))
                    {
                      int v9 = 100;
                      __int16 v10 = 665;
                      goto LABEL_8;
                    }
                    uint64_t v14 = sub_244D07034(&v23);
                    if (!v14) {
                      goto LABEL_9;
                    }
                    uint64_t v15 = v14;
                    if (!sub_244CFCD34(&v23, v21, 4) || !sub_244CFCD34(&v31, v22, 4))
                    {
                      int v9 = 100;
                      __int16 v10 = 676;
                      goto LABEL_8;
                    }
                    if (*((void *)&v31 + 1))
                    {
                      unint64_t v20 = 0;
                      if (!sub_244CFCEF4(&v31, &v20)
                        || (unsigned int v16 = v20, v20 - 100000001 < 0xFFFFFFFFFA0A1F00))
                      {
                        int v9 = 100;
                        __int16 v10 = 686;
                        goto LABEL_8;
                      }
                    }
                    else
                    {
                      unsigned int v16 = 1;
                    }
                    LODWORD(v20) = 0;
                    if (!sub_244D47628(&v20, (uint64_t)a4, v13, v22, v16, v15, v27, (uint64_t)v21)) {
                      goto LABEL_9;
                    }
                    int v17 = v20;
                    if (!v20 && !v13)
                    {
                      if (a4) {
                        uint64_t v18 = 0;
                      }
                      else {
                        uint64_t v18 = "";
                      }
                      *(void *)&long long v25 = v18;
                      if (!sub_244D47628(&v20, (uint64_t)v18, 0, v22, v16, v15, v27, (uint64_t)v21)) {
                        goto LABEL_9;
                      }
                      int v17 = v20;
                    }
                    if (v17)
                    {
                      int v19 = sub_244D47748((uint64_t)v27, (uint64_t)&v24, (unsigned int (*)(void *, uint64_t))sub_244D4785C);
                      sub_244D440EC(v34);
                      if (v19) {
                        return 1;
                      }
                      goto LABEL_10;
                    }
                    int v9 = 108;
                    __int16 v10 = 710;
                    goto LABEL_8;
                  }
                  int v9 = 100;
                  __int16 v10 = 652;
                }
                else
                {
                  int v9 = 114;
                  __int16 v10 = 647;
                }
              }
              else
              {
                int v9 = 100;
                __int16 v10 = 640;
              }
            }
            else
            {
              int v9 = 100;
              __int16 v10 = 631;
            }
          }
          else
          {
            int v9 = 112;
            __int16 v10 = 626;
          }
        }
        else
        {
          int v9 = 100;
          __int16 v10 = 621;
        }
      }
      else
      {
        int v9 = 101;
        __int16 v10 = 616;
      }
    }
    else
    {
      int v9 = 100;
      __int16 v10 = 611;
    }
LABEL_8:
    sub_244D0B884(19, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", v10);
LABEL_9:
    sub_244D440EC(v34);
LABEL_10:
    sub_244D0BFD0(*a1);
    *a1 = 0;
    while (sub_244D259E0((uint64_t)a2) > v8)
    {
      uint64_t v11 = sub_244D4BA0C(a2);
      sub_244D62F44(v11);
    }
    return 0;
  }
  sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 599);
  return 0;
}

uint64_t sub_244D47628(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v15 = *a4;
  unint64_t v16 = a4[1];
  unint64_t v17 = sub_244CF48E0(a6);
  if (sub_244D45F8C(a2, a3, v15, v16, 3, a5, v17, v23, a6)
    && (v21 = 0, unint64_t v18 = sub_244CF48E0(a6), sub_244D2E9F4(a6, (uint64_t)v23, v18, *a7, a7[1], (uint64_t)v22, &v21)))
  {
    *a1 = sub_244CFC618(a8, v22, v21);
    uint64_t v19 = 1;
  }
  else
  {
    uint64_t v19 = 0;
  }
  sub_244D4413C(v23, 0x40uLL);
  return v19;
}

uint64_t sub_244D47748(uint64_t a1, uint64_t a2, unsigned int (*a3)(void *, uint64_t))
{
  uint64_t v11 = 0;
  long long v10 = 0uLL;
  if (sub_244CFAEDC(a1, &v10, &v11))
  {
    long long v9 = 0uLL;
    if (!sub_244CFCD34(&v10, &v9, 536870928) || *((void *)&v10 + 1))
    {
      __int16 v6 = 260;
    }
    else
    {
      while (1)
      {
        if (!*((void *)&v9 + 1))
        {
          uint64_t v5 = 1;
          goto LABEL_13;
        }
        v8[0] = 0;
        v8[1] = 0;
        if (!sub_244CFCD34(&v9, v8, 536870928)) {
          break;
        }
        if (!a3(v8, a2)) {
          goto LABEL_11;
        }
      }
      __int16 v6 = 267;
    }
    sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", v6);
LABEL_11:
    uint64_t v5 = 0;
LABEL_13:
    sub_244D440EC(v11);
  }
  else
  {
    sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 253);
    return 0;
  }
  return v5;
}

uint64_t sub_244D4785C(uint64_t a1, uint64_t a2)
{
  v21[0] = 0;
  v21[1] = 0;
  long long v20 = 0uLL;
  long long v19 = 0uLL;
  unint64_t v18 = 0;
  if (!sub_244CFCD34((long long *)a1, v21, 6)
    || !sub_244CFCD34((long long *)a1, &v20, -1610612736)
    || *(void *)(a1 + 8))
  {
    sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 490);
    int v4 = 0;
    uint64_t v5 = 0;
    goto LABEL_5;
  }
  if (sub_244CFC618((uint64_t)v21, asc_244EBD7DD, 9))
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    long long v15 = 0uLL;
    v14[0] = 0;
    v14[1] = 0;
    long long v13 = 0uLL;
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    uint64_t v9 = 0;
    long long v10 = 0;
    if (sub_244CFCD34(&v20, &v19, 536870928)
      && sub_244CFCD34(&v19, &v16, 2)
      && sub_244CFCD34(&v19, &v15, 536870928)
      && sub_244CFCD34(&v15, v14, 6)
      && sub_244CFCD34(&v15, &v13, 536870928)
      && sub_244CFB2A0((uint64_t)&v15, &v11, &v18, 0x80000000, 4))
    {
      if (sub_244CFC618((uint64_t)v14, asc_244EBD7BE, 9))
      {
        if (sub_244D466D4(&v10, &v9, &v13, *(void *)(a2 + 16), *(void *)(a2 + 24), v11, v12))
        {
          v8[0] = v10;
          v8[1] = v9;
          uint64_t v5 = sub_244D47748((uint64_t)v8, a2, (unsigned int (*)(void *, uint64_t))sub_244D48C5C);
          sub_244D440EC(v10);
LABEL_19:
          int v4 = v18;
          goto LABEL_5;
        }
LABEL_18:
        uint64_t v5 = 0;
        goto LABEL_19;
      }
      __int16 v7 = 522;
    }
    else
    {
      __int16 v7 = 517;
    }
    sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", v7);
    goto LABEL_18;
  }
  if (sub_244CFC618((uint64_t)v21, asc_244EBD7BE, 9))
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    if (sub_244CFCD34(&v20, &v16, 4))
    {
      uint64_t v5 = sub_244D47748((uint64_t)&v16, a2, (unsigned int (*)(void *, uint64_t))sub_244D48C5C);
    }
    else
    {
      sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 541);
      uint64_t v5 = 0;
    }
    int v4 = 0;
  }
  else
  {
    int v4 = 0;
    uint64_t v5 = 1;
  }
LABEL_5:
  sub_244D440EC(v4);
  return v5;
}

void *sub_244D47AE0(void **a1, const void **a2, unint64_t a3)
{
  __int16 v6 = sub_244D43FF4(0x10uLL);
  if (v6)
  {
    __int16 v7 = sub_244D442F4(*a2, a3);
    *__int16 v6 = v7;
    if (v7)
    {
      v6[1] = a3;
      *a2 = (char *)*a2 + a3;
      if (a1)
      {
        sub_244D47B68(*a1);
        *a1 = v6;
      }
    }
    else
    {
      sub_244D440EC(v6);
      return 0;
    }
  }
  return v6;
}

void sub_244D47B68(void *a1)
{
  if (a1)
  {
    sub_244D440EC((void *)*a1);
    sub_244D440EC(a1);
  }
}

void *sub_244D47BAC(uint64_t a1, void **a2)
{
  int v4 = sub_244CFAC60();
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (uint64_t)v4;
  if (!sub_244CFAD1C(v4, 0x2000uLL)
    || (*(void *)v5 >= 0x7FFFFFFFuLL ? (LODWORD(v6) = 0x7FFFFFFF) : (unint64_t v6 = *(void *)v5),
        unsigned int v7 = sub_244CF83D4(a1, *(void *)(v5 + 8), v6),
        (v7 & 0x80000000) != 0))
  {
LABEL_19:
    unint64_t v12 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    while (v7)
    {
      v8 += v7;
      unint64_t v9 = *(void *)v5;
      if (v8 >= *(void *)v5)
      {
        if (v9 > 0x40000 || !sub_244CFAD1C((unint64_t *)v5, 2 * v9)) {
          goto LABEL_19;
        }
        unint64_t v9 = *(void *)v5;
      }
      unint64_t v10 = v9 - v8;
      if (v10 >= 0x7FFFFFFF) {
        int v11 = 0x7FFFFFFF;
      }
      else {
        int v11 = v10;
      }
      unsigned int v7 = sub_244CF83D4(a1, *(void *)(v5 + 8) + v8, v11);
      if ((v7 & 0x80000000) != 0)
      {
        if (!v8) {
          goto LABEL_19;
        }
        break;
      }
    }
    uint64_t v14 = *(const void **)(v5 + 8);
    unint64_t v12 = sub_244D47AE0(a2, &v14, v8);
  }
  sub_244CF474C(v5);
  return v12;
}

void *sub_244D47CB0(uint64_t a1, void **a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D47BAC((uint64_t)result, a2);
    sub_244CF830C(v4);
    return v5;
  }
  return result;
}

uint64_t sub_244D47CF8(uint64_t a1, void **a2)
{
  size_t v2 = *(void *)(a1 + 8);
  if (!(v2 >> 31))
  {
    if (!a2) {
      return v2;
    }
    uint64_t v5 = (char *)*a2;
    if (*a2)
    {
      if (v2)
      {
        memcpy(v5, *(const void **)a1, v2);
        uint64_t v6 = *(void *)(a1 + 8);
        uint64_t v5 = (char *)*a2;
      }
      else
      {
        uint64_t v6 = 0;
      }
      *a2 = &v5[v6];
    }
    else
    {
      unsigned int v7 = sub_244D442F4(*(const void **)a1, v2);
      *a2 = v7;
      if (!v7) {
        return 0xFFFFFFFFLL;
      }
    }
    return *(unsigned int *)(a1 + 8);
  }
  sub_244D0B884(19, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 834);
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D47D9C(uint64_t a1, uint64_t a2)
{
  return sub_244CF85CC(a1, *(void *)a2, *(void *)(a2 + 8));
}

void *sub_244D47DA8(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244CF85CC((uint64_t)result, *(void *)a2, *(void *)(a2 + 8));
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D47DF0(void *a1, const char *a2, uint64_t *a3, unint64_t **a4, unint64_t **a5)
{
  if (a5 && (unint64_t v10 = *a5) != 0)
  {
    int v11 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_244D4B4C8();
    if (!result) {
      return result;
    }
    unint64_t v10 = (unint64_t *)result;
    int v11 = 1;
  }
  uint64_t v13 = a1[1];
  v18[0] = *a1;
  v18[1] = v13;
  if (sub_244D471B8(a3, (uint64_t *)v10, (uint64_t)v18, a2))
  {
    *a4 = 0;
    uint64_t v14 = sub_244D259E0((uint64_t)v10);
    if (*a3 && (unint64_t v15 = v14) != 0)
    {
      unint64_t v16 = v14 - 1;
      while (1)
      {
        uint64_t v17 = sub_244D4B518(v10, v16);
        if (sub_244D5A034((uint64_t)v17, *a3)) {
          break;
        }
        sub_244D0B1B0();
        if (--v16 >= v15) {
          goto LABEL_12;
        }
      }
      *a4 = v17;
      sub_244D4B714((uint64_t *)v10, v16);
      if (!a5) {
        goto LABEL_18;
      }
    }
    else
    {
LABEL_12:
      if (!a5)
      {
LABEL_18:
        sub_244D4B564(v10, (void (*)(uint64_t))sub_244D49164, (uint64_t)sub_244D62F44);
        return 1;
      }
    }
    *a5 = v10;
    return 1;
  }
  if (v11) {
    sub_244CF474C((uint64_t)v10);
  }
  return 0;
}

uint64_t sub_244D47F30(void *a1, char *__s, int a3)
{
  if (!__s)
  {
    if (a3) {
      return 0;
    }
LABEL_8:
    unsigned int v7 = 0;
    uint64_t v8 = 0;
    if (sub_244D47DF0(a1, __s, &v8, &v7, 0))
    {
      sub_244D0BFD0(v8);
      sub_244D62F44((uint64_t)v7);
      return 1;
    }
    sub_244D0B1B0();
    return 0;
  }
  if (a3 == -1) {
    goto LABEL_8;
  }
  if (__s[a3]) {
    return 0;
  }
  if (!a3) {
    goto LABEL_8;
  }
  uint64_t v5 = memchr(__s, 0, a3);
  uint64_t result = 0;
  if (!v5) {
    goto LABEL_8;
  }
  return result;
}

void *sub_244D47FD8(char *__s, const char *a2, uint64_t a3, uint64_t a4, unint64_t *a5, int a6, int a7, unsigned int a8, unsigned int a9, int a10)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  if (a6) {
    int v10 = a6;
  }
  else {
    int v10 = 146;
  }
  if (a7) {
    int v11 = a7;
  }
  else {
    int v11 = 149;
  }
  if (a8) {
    unsigned int v12 = a8;
  }
  else {
    unsigned int v12 = 2048;
  }
  if (a9 <= 1) {
    unint64_t v13 = 1;
  }
  else {
    unint64_t v13 = a9;
  }
  if (a10 || (v13 & 0x80000000) != 0 || !(a3 | a4) && !sub_244D259E0((uint64_t)a5))
  {
    sub_244D0B884(19, 0, 132, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 1143);
  }
  else
  {
    if (__s) {
      size_t v19 = strlen(__s);
    }
    else {
      size_t v19 = 0;
    }
    unsigned int v57 = 0;
    if (!a3
      || !a4
      || sub_244D5A034(a4, a3)
      && (unsigned int v21 = sub_244D25B18(), sub_244D60EB4((uint64_t *)a4, (uint64_t)v21, (uint64_t)v63, &v57)))
    {
      memset(v56, 0, sizeof(v56));
      memset(v55, 0, sizeof(v55));
      memset(v54, 0, sizeof(v54));
      memset(v53, 0, sizeof(v53));
      memset(v52, 0, sizeof(v52));
      memset(v51, 0, sizeof(v51));
      memset(v50, 0, sizeof(v50));
      if (!sub_244CFB3DC((uint64_t)v56, 0)
        || !sub_244CFB808((uint64_t *)v56, (uint64_t)v55, 0x20000010u)
        || !sub_244CFBDDC((uint64_t)v55, 3uLL)
        || !sub_244CFB808((uint64_t *)v55, (uint64_t)v54, 0x20000010u)
        || !sub_244CFB808((uint64_t *)v54, (uint64_t)v53, 6u)
        || !sub_244CFBA40((uint64_t)v53, asc_244EBD7BE, 9uLL)
        || !sub_244CFB808((uint64_t *)v54, (uint64_t)v52, 0xA0000000)
        || !sub_244CFB808((uint64_t *)v52, (uint64_t)v51, 4u)
        || !sub_244CFB808((uint64_t *)v51, (uint64_t)v50, 0x20000010u))
      {
        goto LABEL_87;
      }
      if (a4 || sub_244D259E0((uint64_t)a5))
      {
        if (v11 < 0)
        {
          long long v61 = 0uLL;
          long long v62 = 0uLL;
          long long v60 = 0uLL;
          long long v48 = 0uLL;
          long long v49 = 0uLL;
          long long v46 = 0uLL;
          long long v47 = 0uLL;
          long long v44 = 0uLL;
          long long v45 = 0uLL;
          long long v42 = 0uLL;
          long long v43 = 0uLL;
          long long v41 = 0uLL;
          if (!sub_244CFB808((uint64_t *)v50, (uint64_t)&v60, 0x20000010u)
            || !sub_244CFB808((uint64_t *)&v60, (uint64_t)&v47, 6u)
            || !sub_244CFBA40((uint64_t)&v47, asc_244EBD7BE, 9uLL)
            || !sub_244CFB808((uint64_t *)&v60, (uint64_t)&v44, 0xA0000000)
            || !sub_244CFB808((uint64_t *)&v44, (uint64_t)&v41, 4u)
            || !sub_244D486CC((uint64_t *)&v41, (uint64_t *)a4, a5, a2, v63, v57)
            || !sub_244CFB540((uint64_t *)v50))
          {
            goto LABEL_87;
          }
        }
        else
        {
          long long v61 = 0uLL;
          long long v62 = 0uLL;
          long long v60 = 0uLL;
          if (!sub_244CFB3DC((uint64_t)&v60, 0)
            || !sub_244D486CC((uint64_t *)&v60, (uint64_t *)a4, a5, a2, v63, v57))
          {
            sub_244CFB470((uint64_t)&v60);
            goto LABEL_87;
          }
          uint64_t v22 = (char *)sub_244CFB738((uint64_t)&v60);
          size_t v23 = sub_244CFB760((uint64_t)&v60);
          LODWORD(v22) = sub_244D487AC((uint64_t *)v50, v11, (uint64_t)__s, v19, v12, v22, v23);
          sub_244CFB470((uint64_t)&v60);
          if (!v22)
          {
LABEL_87:
            long long v20 = 0;
LABEL_88:
            sub_244D4413C(&v60, 0x40uLL);
            sub_244CFB470((uint64_t)v56);
            return v20;
          }
        }
      }
      if (a3)
      {
        long long v61 = 0u;
        long long v62 = 0u;
        long long v60 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v41 = 0u;
        memset(v40, 0, sizeof(v40));
        memset(v39, 0, sizeof(v39));
        memset(v38, 0, sizeof(v38));
        memset(v37, 0, sizeof(v37));
        if (!sub_244CFB808((uint64_t *)v50, (uint64_t)&v60, 0x20000010u)
          || !sub_244CFB808((uint64_t *)&v60, (uint64_t)&v47, 6u)
          || !sub_244CFBA40((uint64_t)&v47, asc_244EBD7BE, 9uLL)
          || !sub_244CFB808((uint64_t *)&v60, (uint64_t)&v44, 0xA0000000)
          || !sub_244CFB808((uint64_t *)&v44, (uint64_t)&v41, 4u)
          || !sub_244CFB808((uint64_t *)&v41, (uint64_t)v40, 0x20000010u)
          || !sub_244CFB808((uint64_t *)v40, (uint64_t)v39, 0x20000010u)
          || !sub_244CFB808((uint64_t *)v39, (uint64_t)v38, 6u))
        {
          goto LABEL_87;
        }
        if (v10 < 0)
        {
          if (!sub_244CFBA40((uint64_t)v38, asc_244EBD7C7, 0xBuLL)
            || !sub_244CFB808((uint64_t *)v39, (uint64_t)v37, 0xA0000000)
            || !sub_244D0CC74((uint64_t)v37, a3))
          {
            goto LABEL_87;
          }
        }
        else if (!sub_244CFBA40((uint64_t)v38, asc_244EBD7D2, 0xBuLL) {
               || !sub_244CFB808((uint64_t *)v39, (uint64_t)v37, 0xA0000000)
        }
               || !sub_244D469D8((uint64_t *)v37, v10, 0, (uint64_t)__s, v19, 0, 0, v12, a3))
        {
          goto LABEL_87;
        }
        if (a2) {
          size_t v24 = strlen(a2);
        }
        else {
          size_t v24 = 0;
        }
        if (!sub_244D48A50((uint64_t *)v39, (uint64_t)a2, v24, v63, v57)
          || !sub_244CFB540((uint64_t *)v50))
        {
          goto LABEL_87;
        }
      }
      long long v25 = sub_244D25B18();
      unsigned int v36 = 0;
      if (sub_244CFB540((uint64_t *)v51))
      {
        if (sub_244D20964(v59, 8uLL))
        {
          unint64_t v26 = sub_244CF48E0((uint64_t)v25);
          if (sub_244D45F8C((uint64_t)__s, v19, (uint64_t)v59, 8uLL, 3, v13, v26, (char *)&v60, (uint64_t)v25))
          {
            unint64_t v27 = sub_244CF48E0((uint64_t)v25);
            long long v28 = sub_244CFB738((uint64_t)v51);
            uint64_t v29 = sub_244CFB760((uint64_t)v51);
            if (sub_244D2E9F4((uint64_t)v25, (uint64_t)&v60, v27, (uint64_t)v28, v29, (uint64_t)v58, &v36))
            {
              memset(v35, 0, sizeof(v35));
              memset(v34, 0, sizeof(v34));
              memset(v33, 0, sizeof(v33));
              memset(v32, 0, sizeof(v32));
              if (sub_244CFB808((uint64_t *)v55, (uint64_t)v35, 0x20000010u))
              {
                if (sub_244CFB808((uint64_t *)v35, (uint64_t)v34, 0x20000010u)
                  && sub_244D07128((uint64_t *)v34, (unsigned int *)v25)
                  && sub_244CFB808((uint64_t *)v34, (uint64_t)v33, 4u)
                  && sub_244CFBA40((uint64_t)v33, v58, v36)
                  && sub_244CFB808((uint64_t *)v35, (uint64_t)v32, 4u)
                  && sub_244CFBA40((uint64_t)v32, v59, 8uLL)
                  && sub_244CFBDDC((uint64_t)v35, v13))
                {
                  long long v30 = sub_244D43FF4(0x10uLL);
                  long long v20 = v30;
                  if (v30 && sub_244CFB48C((uint64_t)v56, v30, v30 + 1)) {
                    goto LABEL_88;
                  }
                  sub_244D440EC(v20);
                }
              }
            }
          }
        }
      }
      goto LABEL_87;
    }
  }
  return 0;
}

uint64_t sub_244D486CC(uint64_t *a1, uint64_t *a2, unint64_t *a3, const char *a4, const void *a5, size_t a6)
{
  memset(v15, 0, sizeof(v15));
  uint64_t result = sub_244CFB808(a1, (uint64_t)v15, 0x20000010u);
  if (result)
  {
    if (!a2 || (uint64_t result = sub_244D49170((uint64_t *)v15, a2, a4, a5, a6), result))
    {
      if (sub_244D259E0((uint64_t)a3))
      {
        unint64_t v13 = 0;
        while (1)
        {
          uint64_t v14 = (uint64_t *)sub_244D4B518(a3, v13);
          uint64_t result = sub_244D49170((uint64_t *)v15, v14, 0, 0, 0);
          if (!result) {
            break;
          }
          if (++v13 >= sub_244D259E0((uint64_t)a3)) {
            return sub_244CFB540(a1);
          }
        }
      }
      else
      {
        return sub_244CFB540(a1);
      }
    }
  }
  return result;
}

BOOL sub_244D487AC(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, size_t a7)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (sub_244D20964(v29, 8uLL))
  {
    uint64_t v28 = 0;
    memset(v27, 0, sizeof(v27));
    sub_244D22284((uint64_t)v27);
    memset(v26, 0, sizeof(v26));
    memset(v25, 0, sizeof(v25));
    memset(v24, 0, sizeof(v24));
    memset(v23, 0, sizeof(v23));
    memset(v22, 0, sizeof(v22));
    memset(v21, 0, sizeof(v21));
    memset(v20, 0, sizeof(v20));
    if (sub_244CFB808(a1, (uint64_t)v26, 0x20000010u)
      && sub_244CFB808((uint64_t *)v26, (uint64_t)v25, 6u)
      && sub_244CFBA40((uint64_t)v25, asc_244EBD7DD, 9uLL)
      && sub_244CFB808((uint64_t *)v26, (uint64_t)v24, 0xA0000000)
      && sub_244CFB808((uint64_t *)v24, (uint64_t)v23, 0x20000010u)
      && sub_244CFBDDC((uint64_t)v23, 0)
      && sub_244CFB808((uint64_t *)v23, (uint64_t)v22, 0x20000010u)
      && sub_244CFB808((uint64_t *)v22, (uint64_t)v21, 6u)
      && sub_244CFBA40((uint64_t)v21, asc_244EBD7BE, 9uLL)
      && sub_244D463D0((uint64_t *)v22, (uint64_t)v27, a2, a5, a3, a4, v29, 8uLL)
      && sub_244CFB808((uint64_t *)v22, (uint64_t)v20, 0x80000000))
    {
      unsigned int v14 = sub_244D22EA4((uint64_t)v27);
      if (__CFADD__(a7, v14))
      {
        sub_244D0B884(19, 0, 118, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 1097);
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        int v16 = sub_244CFBB50((uint64_t)v20, &v19, a7 + v14);
        if (v16
          && sub_244D22E84((int *)v27, v19, (int *)&v18 + 1, a6, a7)
          && sub_244D22E94((uint64_t *)v27, v19 + SHIDWORD(v18), &v18)
          && sub_244CFBC74((uint64_t)v20, (int)v18 + (uint64_t)SHIDWORD(v18)))
        {
          BOOL v15 = sub_244CFB540(a1) != 0;
LABEL_23:
          sub_244D222E0((uint64_t)v27);
          return v15;
        }
      }
    }
    BOOL v15 = 0;
    goto LABEL_23;
  }
  return 0;
}

uint64_t sub_244D48A50(uint64_t *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  if (!a2 && !a5) {
    return 1;
  }
  memset(v18, 0, sizeof(v18));
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  uint64_t result = sub_244CFB808(a1, (uint64_t)v18, 0x20000011u);
  if (result)
  {
    if (a3)
    {
      uint64_t result = sub_244CFB808(v18, (uint64_t)v17, 0x20000010u);
      if (result)
      {
        uint64_t result = sub_244CFB808(v17, (uint64_t)v16, 6u);
        if (result)
        {
          uint64_t result = sub_244CFBA40((uint64_t)v16, asc_244EBD7FB, 9uLL);
          if (result)
          {
            uint64_t result = sub_244CFB808(v17, (uint64_t)v15, 0x20000011u);
            if (result)
            {
              uint64_t result = sub_244CFB808((uint64_t *)v15, (uint64_t)v14, 0x1Eu);
              if (result)
              {
                uint64_t v12 = a2;
                uint64_t v13 = a3;
                while (1)
                {
                  unsigned int v11 = 0;
                  if (!sub_244CFDB28(&v12, &v11) || !sub_244CFDF18((uint64_t)v14, v11)) {
                    break;
                  }
                  if (!v13) {
                    goto LABEL_15;
                  }
                }
                sub_244D0B884(19, 0, 131, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 973);
                return 0;
              }
            }
          }
        }
      }
    }
    else
    {
LABEL_15:
      if (!a5
        || (uint64_t result = sub_244CFB808(v18, (uint64_t)v17, 0x20000010u), result)
        && (uint64_t result = sub_244CFB808(v17, (uint64_t)v16, 6u), result)
        && (uint64_t result = sub_244CFBA40((uint64_t)v16, &unk_244EBD804, 9uLL), result)
        && (uint64_t result = sub_244CFB808(v17, (uint64_t)v15, 0x20000011u), result)
        && (uint64_t result = sub_244CFB808((uint64_t *)v15, (uint64_t)v14, 4u), result)
        && (uint64_t result = sub_244CFBA40((uint64_t)v14, a4, a5), result))
      {
        uint64_t result = sub_244CFC2C0((uint64_t)v18);
        if (result) {
          return sub_244CFB540(a1) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_244D48C5C(uint64_t a1, uint64_t a2)
{
  v24[0] = 0;
  v24[1] = 0;
  long long v23 = 0uLL;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (!sub_244CFCD34((long long *)a1, v24, 6)
    || !sub_244CFCD34((long long *)a1, &v23, -1610612736))
  {
    int v4 = 100;
    __int16 v5 = 373;
    goto LABEL_8;
  }
  if (*(void *)(a1 + 8))
  {
    if (!sub_244CFCD34((long long *)a1, &v21, 536870929) || *(void *)(a1 + 8))
    {
      int v4 = 100;
      __int16 v5 = 380;
LABEL_8:
      sub_244D0B884(19, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", v5);
      return 0;
    }
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v22 = 0;
  }
  BOOL v7 = sub_244CFC618((uint64_t)v24, asc_244EBD7C7, 11);
  if (!(v7 | sub_244CFC618((uint64_t)v24, asc_244EBD7D2, 11)))
  {
    if (!sub_244CFC618((uint64_t)v24, asc_244EBD7E6, 11)) {
      return 1;
    }
    long long v20 = 0uLL;
    v19[0] = 0;
    v19[1] = 0;
    long long v18 = 0uLL;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    if (!sub_244CFCD34(&v23, &v20, 536870928)
      || !sub_244CFCD34(&v20, v19, 6)
      || !sub_244CFCD34(&v20, &v18, -1610612736)
      || !sub_244CFCD34(&v18, &v16, 4))
    {
      int v4 = 100;
      __int16 v5 = 420;
      goto LABEL_8;
    }
    if (!sub_244CFC618((uint64_t)v19, asc_244EBD7F1, 10)) {
      return 1;
    }
    if (v17 < 0)
    {
      int v4 = 100;
      __int16 v5 = 431;
      goto LABEL_8;
    }
    uint64_t v15 = v16;
    uint64_t v8 = sub_244D63000(0, &v15, v17);
    if (!v8)
    {
      int v4 = 100;
      __int16 v5 = 438;
      goto LABEL_8;
    }
    uint64_t v9 = v8;
    if (v15 == v16 + v17)
    {
      size_t v13 = 0;
      unsigned int v14 = 0;
      if (sub_244D48F8C((uint64_t)&v21, (void **)&v14, &v13))
      {
        if (v13)
        {
          int v12 = sub_244D639D8(v9, (char *)v14, v13);
          sub_244D440EC(v14);
          if (!v12) {
            goto LABEL_24;
          }
        }
        else
        {
          sub_244D440EC(v14);
        }
        if (sub_244D4BA04(*(unint64_t **)(a2 + 8), v9)) {
          return 1;
        }
      }
    }
    else
    {
      sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 443);
    }
LABEL_24:
    sub_244D62F44(v9);
    return 0;
  }
  if (**(void **)a2)
  {
    int v4 = 113;
    __int16 v5 = 390;
    goto LABEL_8;
  }
  if (v7) {
    uint64_t v10 = sub_244D0CB34(&v23);
  }
  else {
    uint64_t v10 = sub_244D468F0(&v23, *(void *)(a2 + 16), *(void *)(a2 + 24));
  }
  uint64_t v11 = v10;
  if (!v10) {
    return 0;
  }
  if (*((void *)&v23 + 1))
  {
    sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 403);
    sub_244D0BFD0(v11);
    return 0;
  }
  **(void **)a2 = v10;
  return 1;
}

uint64_t sub_244D48F8C(uint64_t a1, void **a2, void *a3)
{
  *a2 = 0;
  *a3 = 0;
  if (!*(void *)(a1 + 8)) {
    return 1;
  }
  while (1)
  {
    long long v14 = 0uLL;
    v13[0] = 0;
    v13[1] = 0;
    long long v12 = 0uLL;
    if (!sub_244CFCD34((long long *)a1, &v14, 536870928)
      || !sub_244CFCD34(&v14, v13, 6)
      || !sub_244CFCD34(&v14, &v12, 536870929)
      || *((void *)&v14 + 1))
    {
      __int16 v7 = 323;
LABEL_23:
      sub_244D0B884(19, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", v7);
      goto LABEL_24;
    }
    if (sub_244CFC618((uint64_t)v13, asc_244EBD7FB, 9)) {
      break;
    }
LABEL_17:
    if (!*(void *)(a1 + 8)) {
      return 1;
    }
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  if (*a2 || !sub_244CFCD34(&v12, &v10, 30) || *((void *)&v12 + 1) || !v11)
  {
    __int16 v7 = 333;
    goto LABEL_23;
  }
  memset(v9, 0, sizeof(v9));
  if (sub_244CFB3DC((uint64_t)v9, v11))
  {
    while (v11)
    {
      unsigned int v8 = 0;
      if (!sub_244CFDC94(&v10, &v8) || !sub_244CFDD84((uint64_t)v9, v8))
      {
        sub_244D0B884(19, 0, 131, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 345);
        goto LABEL_20;
      }
    }
    if (sub_244CFB48C((uint64_t)v9, a2, a3)) {
      goto LABEL_17;
    }
LABEL_20:
    sub_244CFB470((uint64_t)v9);
  }
LABEL_24:
  sub_244D440EC(*a2);
  uint64_t result = 0;
  *a2 = 0;
  *a3 = 0;
  return result;
}

uint64_t sub_244D49164(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D49170(uint64_t *a1, uint64_t *a2, const char *a3, const void *a4, size_t a5)
{
  memset(v22, 0, sizeof(v22));
  memset(v21, 0, sizeof(v21));
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  uint64_t result = sub_244CFB808(a1, (uint64_t)v22, 0x20000010u);
  if (result)
  {
    uint64_t result = sub_244CFB808(v22, (uint64_t)v21, 6u);
    if (result)
    {
      uint64_t result = sub_244CFBA40((uint64_t)v21, asc_244EBD7E6, 0xBuLL);
      if (result)
      {
        uint64_t result = sub_244CFB808(v22, (uint64_t)v20, 0xA0000000);
        if (result)
        {
          uint64_t result = sub_244CFB808(v20, (uint64_t)v19, 0x20000010u);
          if (result)
          {
            uint64_t result = sub_244CFB808(v19, (uint64_t)v18, 6u);
            if (result)
            {
              uint64_t result = sub_244CFBA40((uint64_t)v18, asc_244EBD7F1, 0xAuLL);
              if (result)
              {
                uint64_t result = sub_244CFB808(v19, (uint64_t)v17, 0xA0000000);
                if (result)
                {
                  uint64_t result = sub_244CFB808((uint64_t *)v17, (uint64_t)v16, 4u);
                  if (result)
                  {
                    uint64_t v15 = 0;
                    unsigned int v11 = sub_244D63318(a2, 0);
                    int v14 = 0;
                    long long v12 = sub_244D63B58((uint64_t)a2, &v14);
                    size_t v13 = v14;
                    if (a3)
                    {
                      if (v14)
                      {
                        sub_244D0B884(19, 0, 133, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/pkcs8/pkcs8_x509.c", 1019);
                        return 0;
                      }
                      size_t v13 = strlen(a3);
                    }
                    else
                    {
                      a3 = (const char *)v12;
                    }
                    if ((v11 & 0x80000000) != 0) {
                      return 0;
                    }
                    uint64_t result = sub_244CFBA94((uint64_t)v16, &v15, v11);
                    if (!result) {
                      return result;
                    }
                    if ((sub_244D63318(a2, &v15) & 0x80000000) != 0) {
                      return 0;
                    }
                    uint64_t result = sub_244D48A50(v22, (uint64_t)a3, v13, a4, a5);
                    if (result) {
                      return sub_244CFB540(a1) != 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void *sub_244D49374()
{
  uint64_t v0 = sub_244D44058(0xE0uLL);
  if (v0)
  {
    unsigned int v1 = sub_244D43AD0((uint64_t)sub_244D493F4, (uint64_t)sub_244D4941C);
    void *v0 = v1;
    if (v1)
    {
      sub_244D4BD2C((pthread_rwlock_t *)(v0 + 1));
      sub_244D20964((char *)v0 + 208, 0x10uLL);
    }
    else
    {
      sub_244D440EC(v0);
      return 0;
    }
  }
  return v0;
}

uint64_t sub_244D493F4(uint64_t a1)
{
  return sub_244D4B220((void *)(*(void *)a1 + 208), *(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
}

uint64_t sub_244D4941C(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 1;
  }
  if (v2) {
    return memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v2);
  }
  return 0;
}

void sub_244D4944C(void *a1)
{
  if (a1)
  {
    size_t v2 = (pthread_rwlock_t *)(a1 + 1);
    sub_244D43B40((void *)*a1);
    j__pthread_rwlock_destroy(v2);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D4949C(const void *a1, unint64_t a2, void **a3)
{
  return sub_244D494A8(a1, a2, 0, a3);
}

uint64_t sub_244D494A8(const void *a1, unint64_t a2, int a3, void **a4)
{
  if (a4)
  {
    void v18[2] = a2;
    _OWORD v18[3] = 0;
    v18[0] = a4;
    v18[1] = a1;
    sub_244D4BD50((pthread_rwlock_t *)(a4 + 1));
    uint64_t v8 = sub_244D43BC4(*a4, (uint64_t)v18, (uint64_t (*)(void, uint64_t))sub_244D49884, (unsigned int (*)(void, void, uint64_t))sub_244D49890);
    uint64_t v9 = v8;
    if (a3 && v8)
    {
      if (*(_DWORD *)(v8 + 28))
      {
LABEL_5:
        sub_244D499E4((unsigned int *)(v8 + 24));
        sub_244D4BD90((pthread_rwlock_t *)(a4 + 1));
        return v9;
      }
    }
    else if (v8)
    {
      goto LABEL_5;
    }
    sub_244D4BD90((pthread_rwlock_t *)(a4 + 1));
  }
  uint64_t v10 = sub_244D44058(0x20uLL);
  uint64_t v9 = (uint64_t)v10;
  if (v10)
  {
    if (a3)
    {
      v10[1] = a1;
      *((_DWORD *)v10 + 7) = 1;
    }
    else
    {
      int v14 = sub_244D442F4(a1, a2);
      *(void *)(v9 + 8) = v14;
      if (a2 && !v14)
      {
        sub_244D440EC((void *)v9);
        return 0;
      }
    }
    *(void *)(v9 + 16) = a2;
    *(_DWORD *)(v9 + 24) = 1;
    if (a4)
    {
      *(void *)uint64_t v9 = a4;
      unsigned int v11 = (pthread_rwlock_t *)(a4 + 1);
      sub_244D4BD70((pthread_rwlock_t *)(a4 + 1));
      uint64_t v12 = sub_244D43BC4(*a4, v9, (uint64_t (*)(void, uint64_t))sub_244D49884, (unsigned int (*)(void, void, uint64_t))sub_244D49890);
      uint64_t v13 = v12;
      if (a3 && v12)
      {
        if (*(_DWORD *)(v12 + 28))
        {
LABEL_15:
          sub_244D499E4((unsigned int *)(v12 + 24));
          sub_244D4BD90((pthread_rwlock_t *)(a4 + 1));
LABEL_16:
          sub_244D49814((void **)v9);
          return v13;
        }
      }
      else if (v12)
      {
        goto LABEL_15;
      }
      uint64_t v15 = *a4;
      v18[0] = 0;
      int v16 = sub_244D43D34(v15, v18, v9, (uint64_t (*)(void, uint64_t))sub_244D49884, (unsigned int (*)(void, void, uint64_t))sub_244D49890);
      sub_244D4BD90(v11);
      if (v16) {
        return v9;
      }
      uint64_t v13 = 0;
      goto LABEL_16;
    }
  }
  return v9;
}

void *sub_244D49680(void *a1, unint64_t a2)
{
  int v4 = sub_244D44058(0x20uLL);
  if (v4)
  {
    __int16 v5 = sub_244D43FF4(a2);
    v4[1] = v5;
    if (!a2 || v5)
    {
      _OWORD v4[2] = a2;
      *((_DWORD *)v4 + 6) = 1;
      *a1 = v5;
    }
    else
    {
      sub_244D440EC(v4);
      return 0;
    }
  }
  return v4;
}

uint64_t sub_244D496F4(uint64_t a1, void **a2)
{
  return sub_244D494A8(*(const void **)a1, *(void *)(a1 + 8), 0, a2);
}

uint64_t sub_244D49708(const void *a1, unint64_t a2, void **a3)
{
  return sub_244D494A8(a1, a2, 1, a3);
}

void sub_244D49714(unsigned int *a1)
{
  if (!a1) {
    return;
  }
  size_t v2 = *(void ***)a1;
  if (!*(void *)a1)
  {
    if (!sub_244D49A14(a1 + 6)) {
      return;
    }
    goto LABEL_8;
  }
  sub_244D4BD70((pthread_rwlock_t *)(v2 + 1));
  if (sub_244D49A14(a1 + 6))
  {
    if ((unsigned int *)sub_244D43BC4(*v2, (uint64_t)a1, (uint64_t (*)(void, uint64_t))sub_244D49884, (unsigned int (*)(void, void, uint64_t))sub_244D49890) == a1)sub_244D43E24(*v2, (uint64_t)a1, (uint64_t (*)(void, uint64_t))sub_244D49884, (unsigned int (*)(void, void, uint64_t))sub_244D49890); {
    sub_244D4BD90((pthread_rwlock_t *)(*(void *)a1 + 8));
    }
LABEL_8:
    sub_244D49814((void **)a1);
    return;
  }
  uint64_t v3 = (pthread_rwlock_t *)(*(void *)a1 + 8);

  sub_244D4BD90(v3);
}

void sub_244D49814(void **a1)
{
  if (!*((_DWORD *)a1 + 7)) {
    sub_244D440EC(a1[1]);
  }

  sub_244D440EC(a1);
}

uint64_t sub_244D49858(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D49878(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  return result;
}

uint64_t sub_244D49884(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D49890(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t sub_244D498A0(uint64_t result)
{
  if (result != -1) {
    abort();
  }
  atomic_store(1u, (unsigned int *)&unk_268EC0240);
  return result;
}

void sub_244D498D0()
{
}

BOOL sub_244D498E0()
{
  unsigned int v0 = atomic_load((unsigned int *)&unk_268EC0240);
  return v0 != 0;
}

uint64_t sub_244D498F8(void *a1, size_t a2)
{
  uint64_t result = CCRandomGenerateBytes(a1, a2);
  if (result) {
    abort();
  }
  return result;
}

int *sub_244D49918(int *result, uint64_t a2, char *a3, unsigned char *a4)
{
  int v4 = *result;
  int v5 = result[1];
  if (a2)
  {
    uint64_t v6 = result + 2;
    do
    {
      int v4 = (v4 + 1);
      int v7 = v6[v4];
      int v5 = (v7 + v5);
      int v8 = v6[v5];
      v6[v4] = v8;
      v6[v5] = v7;
      char v9 = *a3++;
      *a4++ = v9 ^ v6[(v8 + v7)];
      --a2;
    }
    while (a2);
  }
  *uint64_t result = v4;
  result[1] = v5;
  return result;
}

void *sub_244D4996C(void *result, int a2, uint64_t a3)
{
  uint64_t v3 = 0;
  int v4 = result + 1;
  *uint64_t result = 0;
  int32x4_t v5 = (int32x4_t)xmmword_244EBD810;
  v6.i64[0] = 0x400000004;
  v6.i64[1] = 0x400000004;
  do
  {
    *(int32x4_t *)&v4[v3] = v5;
    int32x4_t v5 = vaddq_s32(v5, v6);
    v3 += 2;
  }
  while (v3 != 128);
  uint64_t v7 = 0;
  unsigned __int8 v8 = 0;
  unsigned int v9 = 0;
  do
  {
    int v10 = *(_DWORD *)((char *)v4 + v7);
    unsigned __int8 v11 = *(unsigned char *)(a3 + v9) + v10 + v8;
    unsigned __int8 v8 = v11;
    if (v9 + 1 == a2) {
      unsigned int v9 = 0;
    }
    else {
      ++v9;
    }
    *(_DWORD *)((char *)v4 + v7) = *((_DWORD *)v4 + v11);
    *((_DWORD *)v4 + v11) = v10;
    v7 += 4;
  }
  while (v7 != 1024);
  return result;
}

unsigned int *sub_244D499E4(unsigned int *result)
{
  unsigned int v1 = atomic_load(result);
  if (v1 != -1)
  {
    for (unsigned int i = v1; i != -1; v1 = i)
    {
      atomic_compare_exchange_strong((atomic_uint *volatile)result, &i, v1 + 1);
      if (i == v1) {
        break;
      }
    }
  }
  return result;
}

BOOL sub_244D49A14(unsigned int *a1)
{
  for (uint64_t i = atomic_load(a1); ; uint64_t i = v2)
  {
    if (i == -1) {
      return 0;
    }
    if (!i) {
      abort();
    }
    uint64_t v2 = i;
    atomic_compare_exchange_strong((atomic_uint *volatile)a1, (unsigned int *)&v2, i - 1);
    if (v2 == i) {
      break;
    }
  }
  return i == 1;
}

uint64_t *sub_244D49A68(long long *a1)
{
  uint64_t v2 = (uint64_t *)sub_244D32AE8();
  if (v2)
  {
    long long v8 = 0uLL;
    if (!sub_244CFCD34(a1, &v8, 536870928)
      || (uint64_t v3 = sub_244D16670(), (v2[1] = (uint64_t)v3) == 0)
      || !sub_244CFA034(&v8, v3)
      || (int v4 = sub_244D16670(), (v2[2] = (uint64_t)v4) == 0)
      || !sub_244CFA034(&v8, v4)
      || *((void *)&v8 + 1))
    {
      int v5 = 100;
      __int16 v6 = 100;
      goto LABEL_11;
    }
    if (!sub_244D32B54(v2))
    {
      int v5 = 104;
      __int16 v6 = 106;
LABEL_11:
      sub_244D0B884(4, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", v6);
      sub_244D3306C((uint64_t)v2);
      return 0;
    }
  }
  return v2;
}

uint64_t *sub_244D49B4C(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v4 = a1;
  *((void *)&v4 + 1) = a2;
  uint64_t v2 = sub_244D49A68(&v4);
  if (!v2 || *((void *)&v4 + 1))
  {
    sub_244D0B884(4, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", 119);
    sub_244D3306C((uint64_t)v2);
    return 0;
  }
  return v2;
}

uint64_t sub_244D49BB8(uint64_t *a1, uint64_t a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v5, 0x20000010u)
    && sub_244D49C58((uint64_t *)v5, *(uint64_t **)(a2 + 8))
    && sub_244D49C58((uint64_t *)v5, *(uint64_t **)(a2 + 16))
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(4, 0, 121, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", 132);
  return 0;
}

uint64_t sub_244D49C58(uint64_t *a1, uint64_t *a2)
{
  if (a2)
  {
    return sub_244CFA0E0(a1, a2);
  }
  else
  {
    sub_244D0B884(4, a2, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", 84);
    return 0;
  }
}

uint64_t sub_244D49C9C(void *a1, void *a2, uint64_t a3)
{
  memset(v7, 0, sizeof(v7));
  sub_244CFB3CC(v7);
  if (sub_244CFB3DC((uint64_t)v7, 0)
    && sub_244D49BB8((uint64_t *)v7, a3)
    && sub_244CFB48C((uint64_t)v7, a1, a2))
  {
    return 1;
  }
  sub_244D0B884(4, 0, 121, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", 145);
  sub_244CFB470((uint64_t)v7);
  return 0;
}

uint64_t *sub_244D49D4C(long long *a1)
{
  uint64_t v2 = (uint64_t *)sub_244D32AE8();
  if (v2)
  {
    long long v11 = 0uLL;
    unint64_t v10 = 0;
    if (sub_244CFCD34(a1, &v11, 536870928) && sub_244CFCEF4(&v11, &v10))
    {
      if (v10)
      {
        int v3 = 106;
        __int16 v4 = 171;
      }
      else
      {
        __int16 v6 = sub_244D16670();
        v2[1] = (uint64_t)v6;
        if (!v6) {
          goto LABEL_8;
        }
        if (!sub_244CFA034(&v11, v6)) {
          goto LABEL_8;
        }
        uint64_t v7 = sub_244D16670();
        _OWORD v2[2] = (uint64_t)v7;
        if (!v7) {
          goto LABEL_8;
        }
        if (!sub_244CFA034(&v11, v7)) {
          goto LABEL_8;
        }
        long long v8 = sub_244D16670();
        v2[3] = (uint64_t)v8;
        if (!v8) {
          goto LABEL_8;
        }
        if (!sub_244CFA034(&v11, v8)) {
          goto LABEL_8;
        }
        unsigned int v9 = sub_244D16670();
        v2[4] = (uint64_t)v9;
        if (!v9
          || !sub_244CFA034(&v11, v9)
          || !sub_244D08B80(&v11, v2 + 5)
          || !sub_244D08B80(&v11, v2 + 6)
          || !sub_244D08B80(&v11, v2 + 7)
          || !sub_244D08B80(&v11, v2 + 8))
        {
          goto LABEL_8;
        }
        if (*((void *)&v11 + 1))
        {
          int v3 = 100;
          __int16 v4 = 187;
        }
        else
        {
          if (sub_244D32B54(v2)) {
            return v2;
          }
          int v3 = 104;
          __int16 v4 = 192;
        }
      }
    }
    else
    {
      int v3 = 100;
      __int16 v4 = 166;
    }
    sub_244D0B884(4, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", v4);
LABEL_8:
    sub_244D3306C((uint64_t)v2);
    return 0;
  }
  return v2;
}

uint64_t *sub_244D49EFC(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v4 = a1;
  *((void *)&v4 + 1) = a2;
  uint64_t v2 = sub_244D49D4C(&v4);
  if (!v2 || *((void *)&v4 + 1))
  {
    sub_244D0B884(4, 0, 100, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", 208);
    sub_244D3306C((uint64_t)v2);
    return 0;
  }
  return v2;
}

uint64_t sub_244D49F68(uint64_t *a1, uint64_t **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB808(a1, (uint64_t)v5, 0x20000010u)
    && sub_244CFBDDC((uint64_t)v5, 0)
    && sub_244D49C58((uint64_t *)v5, a2[1])
    && sub_244D49C58((uint64_t *)v5, a2[2])
    && sub_244D49C58((uint64_t *)v5, a2[3])
    && sub_244D49C58((uint64_t *)v5, a2[4])
    && sub_244D49C58((uint64_t *)v5, a2[5])
    && sub_244D49C58((uint64_t *)v5, a2[6])
    && sub_244D49C58((uint64_t *)v5, a2[7])
    && sub_244D49C58((uint64_t *)v5, a2[8])
    && sub_244CFB540(a1))
  {
    return 1;
  }
  sub_244D0B884(4, 0, 121, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", 228);
  return 0;
}

uint64_t sub_244D4A078(void *a1, void *a2, uint64_t **a3)
{
  memset(v7, 0, sizeof(v7));
  sub_244CFB3CC(v7);
  if (sub_244CFB3DC((uint64_t)v7, 0)
    && sub_244D49F68((uint64_t *)v7, a3)
    && sub_244CFB48C((uint64_t)v7, a1, a2))
  {
    return 1;
  }
  sub_244D0B884(4, 0, 121, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_asn1.c", 241);
  sub_244CFB470((uint64_t)v7);
  return 0;
}

uint64_t *sub_244D4A128(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  int v5 = sub_244D49A68(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D3306C(*a1);
      *a1 = (uint64_t)v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D4A19C(uint64_t a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D49BB8((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t *sub_244D4A210(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0) {
    return 0;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  int v5 = sub_244D49D4C(&v7);
  if (v5)
  {
    if (a1)
    {
      sub_244D3306C(*a1);
      *a1 = (uint64_t)v5;
    }
    *a2 = v7;
  }
  return v5;
}

uint64_t sub_244D4A284(uint64_t **a1, void **a2)
{
  memset(v5, 0, sizeof(v5));
  if (sub_244CFB3DC((uint64_t)v5, 0) && sub_244D49F68((uint64_t *)v5, a1)) {
    return sub_244CFAE28((uint64_t)v5, a2);
  }
  sub_244CFB470((uint64_t)v5);
  return 0xFFFFFFFFLL;
}

uint64_t *sub_244D4A2F8(uint64_t a1)
{
  uint64_t v3 = 0;
  long long v4 = 0;
  if (!sub_244D49C9C(&v4, &v3, a1)) {
    return 0;
  }
  unsigned int v1 = sub_244D49B4C((uint64_t)v4, v3);
  sub_244D440EC(v4);
  return v1;
}

uint64_t *sub_244D4A354(uint64_t **a1)
{
  uint64_t v3 = 0;
  long long v4 = 0;
  if (!sub_244D4A078(&v4, &v3, a1)) {
    return 0;
  }
  unsigned int v1 = sub_244D49EFC((uint64_t)v4, v3);
  sub_244D440EC(v4);
  return v1;
}

uint64_t sub_244D4A3B0(unsigned char *a1, unint64_t a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8)
{
  unsigned int v9 = a7;
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (!a7) {
    unsigned int v9 = sub_244D25B18();
  }
  if (a8) {
    int v16 = a8;
  }
  else {
    int v16 = v9;
  }
  uint64_t v17 = sub_244CF48E0((uint64_t)v9);
  uint64_t v18 = 2 * v17;
  if (2 * v17 + 2 <= a2)
  {
    uint64_t v39 = (uint64_t)v16;
    unint64_t v21 = a2 - 1;
    uint64_t v22 = ~v18;
    if (a2 - 1 + ~v18 < a4)
    {
      int v19 = 114;
      __int16 v20 = 106;
      goto LABEL_12;
    }
    if (v21 < (v18 | 1uLL))
    {
      int v19 = 126;
      __int16 v20 = 111;
      goto LABEL_12;
    }
    size_t v25 = v17;
    unint64_t v26 = &a1[v17];
    *a1 = 0;
    unint64_t v27 = a1 + 1;
    int v38 = v26;
    uint64_t v28 = a5;
    uint64_t v29 = (uint64_t)(v26 + 1);
    if (!sub_244D25474(v28, a6, (uint64_t)(v26 + 1), 0, (uint64_t)v9)) {
      goto LABEL_33;
    }
    if (v21 - a4 + v22) {
      bzero((void *)(v29 + v25), v21 - a4 + v22);
    }
    *(unsigned char *)(v29 + v21 - a4 + ~v25) = 1;
    if (a4) {
      memcpy(&v38[a2 - a4 - v25], a3, a4);
    }
    if (sub_244D20964(v27, v25))
    {
      uint64_t v30 = (char *)sub_244D43FF4(v21 - v25);
      long long v31 = v30;
      if (v30 && sub_244D32260(v30, v21 - v25, (uint64_t)v27, v25, v39))
      {
        if (v21 != v25)
        {
          if (v21 - v25 <= 1) {
            uint64_t v32 = 1;
          }
          else {
            uint64_t v32 = v21 - v25;
          }
          long long v33 = v31;
          size_t v34 = (unsigned char *)v29;
          do
          {
            char v35 = *v33++;
            *v34++ ^= v35;
            --v32;
          }
          while (v32);
        }
        if (sub_244D32260(v40, v25, v29, v21 - v25, v39))
        {
          if (v25)
          {
            unsigned int v36 = v40;
            do
            {
              char v37 = *v36++;
              *v27++ ^= v37;
              --v25;
            }
            while (v25);
          }
          uint64_t v23 = 1;
          goto LABEL_35;
        }
      }
    }
    else
    {
LABEL_33:
      long long v31 = 0;
    }
    uint64_t v23 = 0;
LABEL_35:
    sub_244D440EC(v31);
    return v23;
  }
  int v19 = 126;
  __int16 v20 = 100;
LABEL_12:
  sub_244D0B884(4, 0, v19, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", v20);
  return 0;
}

uint64_t sub_244D4A634(void *a1, unint64_t *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t a9)
{
  unsigned int v9 = a8;
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (!a8) {
    unsigned int v9 = sub_244D25B18();
  }
  if (a9) {
    uint64_t v16 = a9;
  }
  else {
    uint64_t v16 = (uint64_t)v9;
  }
  uint64_t v17 = sub_244CF48E0((uint64_t)v9);
  if (2 * v17 + 2 > a5)
  {
    uint64_t v18 = 0;
LABEL_8:
    int v19 = 133;
    __int16 v20 = 253;
LABEL_9:
    sub_244D0B884(4, 0, v19, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", v20);
LABEL_27:
    sub_244D440EC(v18);
    return 0;
  }
  size_t v21 = v17;
  unint64_t v44 = a3;
  unint64_t v22 = ~v17 + a5;
  uint64_t v18 = (char *)sub_244D43FF4(v22);
  if (!v18) {
    goto LABEL_27;
  }
  long long v42 = a2;
  long long v43 = a1;
  uint64_t v23 = (char *)(a4 + 1);
  size_t v24 = &a4[v21 + 1];
  if (!sub_244D32260(v47, v21, (uint64_t)v24, v22, v16)) {
    goto LABEL_27;
  }
  if (v21)
  {
    size_t v25 = v47;
    size_t v26 = v21;
    do
    {
      char v27 = *v23++;
      *v25++ ^= v27;
      --v26;
    }
    while (v26);
  }
  if (!sub_244D32260(v18, v22, (uint64_t)v47, v21, v16)) {
    goto LABEL_27;
  }
  if (v22)
  {
    uint64_t v28 = v18;
    unint64_t v29 = v22;
    do
    {
      char v30 = *v24++;
      *v28++ ^= v30;
      --v29;
    }
    while (v29);
  }
  if (!sub_244D25474(a6, a7, (uint64_t)v46, 0, (uint64_t)v9)) {
    goto LABEL_27;
  }
  int v31 = sub_244D441D4(v18, v46, v21);
  uint64_t v32 = ~((v31 - 1) & ~(uint64_t)v31 & (*a4 - 1)) >> 63;
  uint64_t v33 = -1;
  if (v21 >= v22)
  {
    size_t v34 = 0;
    unsigned int v36 = v42;
  }
  else
  {
    size_t v34 = 0;
    size_t v35 = ~(2 * v21) + a5;
    unsigned int v36 = v42;
    do
    {
      uint64_t v37 = ((v18[v21] ^ 1) - 1) >> 63;
      size_t v34 = v33 & v37 & v21 | v34 & ~(v33 & v37);
      v33 &= ~v37;
      if (v18[v21]) {
        uint64_t v38 = v33;
      }
      else {
        uint64_t v38 = 0;
      }
      v32 |= v38;
      ++v21;
      --v35;
    }
    while (v35);
  }
  if (v33 | v32) {
    goto LABEL_8;
  }
  size_t v40 = v34 + 1;
  unint64_t v41 = v22 - (v34 + 1);
  if (v41 > v44)
  {
    int v19 = 113;
    __int16 v20 = 241;
    goto LABEL_9;
  }
  if (v22 != v40) {
    memcpy(v43, &v18[v40], v22 - (v34 + 1));
  }
  *unsigned int v36 = v41;
  sub_244D440EC(v18);
  return 1;
}

uint64_t sub_244D4A8EC(size_t a1, void *a2, char *a3, uint64_t **a4, int a5)
{
  unint64_t v12 = 0;
  unsigned int v10 = sub_244D32744(a4);
  if (sub_244D4A990((uint64_t)a4, &v12, a3, v10, a2, a1, a5))
  {
    uint64_t result = v12;
    if (!(v12 >> 31)) {
      return result;
    }
    sub_244D0B884(4, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", 358);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D4A990(uint64_t a1, unint64_t *a2, char *a3, unint64_t a4, void *a5, size_t a6, int a7)
{
  if (!*(void *)(a1 + 8) || !*(void *)(a1 + 16))
  {
    int v15 = 144;
    __int16 v16 = 382;
    goto LABEL_7;
  }
  if (sub_244D344BC(a1))
  {
    unint64_t v14 = sub_244D32744((uint64_t **)a1);
    if (v14 > a4)
    {
      int v15 = 135;
      __int16 v16 = 397;
LABEL_7:
      sub_244D0B884(4, 0, v15, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", v16);
      return 0;
    }
    sub_244D174D4();
    if (!v19)
    {
      uint64_t v17 = 0;
LABEL_29:
      sub_244D440EC(v19);
      return v17;
    }
    uint64_t v20 = (uint64_t)v19;
    sub_244D1756C(v19);
    size_t v21 = sub_244D17610(v20);
    char v27 = (unint64_t **)v20;
    unint64_t v22 = sub_244D17610(v20);
    uint64_t v23 = (unsigned __int8 *)sub_244D43FF4(v14);
    uint64_t v17 = 0;
    uint64_t v28 = v23;
    if (!v21 || !v22 || !v23)
    {
LABEL_28:
      sub_244D17704((uint64_t)v27);
      sub_244D17500(v27);
      int v19 = v28;
      goto LABEL_29;
    }
    switch(a7)
    {
      case 4:
        int v24 = sub_244D4A3B0(v23, v14, a5, a6, 0, 0, 0, 0);
        break;
      case 3:
        int v24 = sub_244D321EC(v23, v14, a5, a6);
        break;
      case 1:
        int v24 = sub_244D4ACBC((uint64_t)v23, v14, a5, a6);
        break;
      default:
        int v25 = 143;
        __int16 v26 = 427;
        goto LABEL_26;
    }
    if (v24 < 1 || !sub_244D16D20(v28, v14, v21)) {
      goto LABEL_27;
    }
    if ((sub_244D15C44((uint64_t)v21, *(void *)(a1 + 8)) & 0x80000000) != 0)
    {
      if (!sub_244D1E430((void *)(a1 + 288), (pthread_rwlock_t *)(a1 + 88), *(void *)(a1 + 8), (uint64_t)v27)|| !sub_244D19BB4((uint64_t)v22, (uint64_t)v21, *(void *)(a1 + 16), *(void *)(a1 + 288) + 24, (uint64_t)v27, *(void *)(a1 + 288)))
      {
        goto LABEL_27;
      }
      if (sub_244D16FA8(a3, v14, (uint64_t)v22))
      {
        *a2 = v14;
        uint64_t v17 = 1;
        goto LABEL_28;
      }
      int v25 = 68;
      __int16 v26 = 453;
    }
    else
    {
      int v25 = 115;
      __int16 v26 = 441;
    }
LABEL_26:
    sub_244D0B884(4, 0, v25, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", v26);
LABEL_27:
    uint64_t v17 = 0;
    goto LABEL_28;
  }
  return 0;
}

uint64_t sub_244D4AC18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = 0;
  sub_244D32744(a4);
  if (sub_244D33980(a4, &v7, a3))
  {
    uint64_t result = v7;
    if (!(v7 >> 31)) {
      return result;
    }
    sub_244D0B884(4, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", 373);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D4ACBC(uint64_t a1, unint64_t a2, const void *a3, size_t a4)
{
  if (a2 <= 0xA)
  {
    int v4 = 126;
    __int16 v5 = 263;
LABEL_5:
    sub_244D0B884(4, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", v5);
    return 0;
  }
  if (a2 - 11 < a4)
  {
    int v4 = 114;
    __int16 v5 = 268;
    goto LABEL_5;
  }
  *(_WORD *)a1 = 512;
  uint64_t v11 = a1 + 2;
  unint64_t v12 = a2 - 3;
  sub_244D20964((char *)(a1 + 2), a2 - 3 - a4);
  unint64_t v13 = v12 - a4;
  if (v12 != a4)
  {
    uint64_t v14 = 0;
    do
    {
      while (!*(unsigned char *)(v11 + v14))
        sub_244D20964((char *)(v11 + v14), 1uLL);
      ++v14;
    }
    while (v14 != v13);
  }
  *(unsigned char *)(v13 + a1 + 2) = 0;
  if (a4) {
    memcpy((void *)(a1 + a2 - a4), a3, a4);
  }
  return 1;
}

uint64_t sub_244D4ADDC(uint64_t **a1, unint64_t *a2, char *a3, unint64_t a4, unsigned __int8 *a5, unint64_t a6, int a7)
{
  uint64_t v14 = (uint64_t (*)(void))(*a1)[7];
  if (!v14)
  {
    unsigned int v16 = sub_244D32744(a1);
    uint64_t v17 = v16;
    if (v16 > a4)
    {
      sub_244D0B884(4, 0, 135, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", 478);
      return 0;
    }
    int v19 = a3;
    if (a7 == 3 || (int v19 = (char *)sub_244D43FF4(v16)) != 0)
    {
      if (v17 != a6)
      {
        int v22 = 112;
        __int16 v23 = 493;
LABEL_18:
        sub_244D0B884(4, 0, v22, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", v23);
        goto LABEL_19;
      }
      if (!sub_244D34A28((uint64_t)a1, v19, a5, a6))
      {
LABEL_19:
        uint64_t v18 = 0;
        goto LABEL_20;
      }
      switch(a7)
      {
        case 4:
          if (!sub_244D4A634(a3, a2, a6, (unsigned __int8 *)v19, a6, 0, 0, 0, 0))
          {
LABEL_39:
            int v22 = 136;
            __int16 v23 = 522;
            goto LABEL_18;
          }
          uint64_t v18 = 1;
LABEL_27:
          sub_244D440EC(v19);
          return v18;
        case 3:
          *a2 = a6;
          return 1;
        case 1:
          if (v17)
          {
            if (v17 > 0xA)
            {
              uint64_t v24 = 0;
              uint64_t v25 = -1;
              uint64_t v26 = 2;
              do
              {
                uint64_t v27 = (v19[v26] - 1) >> 63;
                uint64_t v28 = v24 & ~(v25 & v27);
                uint64_t v24 = v25 & v27 & v26 | v28;
                v25 &= ~v27;
                ++v26;
              }
              while (a6 != v26);
              if (((v24 - 10) & ~v28) < 0 != __OFSUB__(a6, v26)
                || (((v19[1] ^ 2) - 1) & (*v19 - 1) & 0x8000000000000000) == 0
                || v25 == -1)
              {
                int v20 = 137;
                __int16 v21 = 332;
              }
              else
              {
                unint64_t v29 = v24 + 1;
                BOOL v30 = a6 >= v29;
                size_t v31 = a6 - v29;
                if (v30)
                {
                  if (v31) {
                    memcpy(a3, &v19[v29], v31);
                  }
                  *a2 = v31;
                  uint64_t v18 = 1;
LABEL_20:
                  if (a7 == 3) {
                    return v18;
                  }
                  goto LABEL_27;
                }
                int v20 = 137;
                __int16 v21 = 340;
              }
            }
            else
            {
              int v20 = 126;
              __int16 v21 = 295;
            }
          }
          else
          {
            int v20 = 120;
            __int16 v21 = 286;
          }
          sub_244D0B884(4, 0, v20, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", v21);
          goto LABEL_39;
      }
      sub_244D0B884(4, 0, 143, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", 516);
    }
    uint64_t v18 = 0;
    goto LABEL_27;
  }

  return v14();
}

uint64_t sub_244D4B0D8(unint64_t a1, unsigned __int8 *a2, char *a3, uint64_t **a4, int a5)
{
  unint64_t v12 = 0;
  unsigned int v10 = sub_244D32744(a4);
  if (sub_244D4ADDC(a4, &v12, a3, v10, a2, a1, a5))
  {
    uint64_t result = v12;
    if (!(v12 >> 31)) {
      return result;
    }
    sub_244D0B884(4, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", 552);
  }
  return 0xFFFFFFFFLL;
}

size_t sub_244D4B17C(unint64_t a1, unsigned __int8 *a2, char *a3, uint64_t **a4, int a5)
{
  size_t v12 = 0;
  unsigned int v10 = sub_244D32744(a4);
  if (sub_244D344B8((uint64_t)a4, &v12, a3, v10, a2, a1, a5))
  {
    size_t result = v12;
    if (!(v12 >> 31)) {
      return result;
    }
    sub_244D0B884(4, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/rsa_extra/rsa_crypt.c", 566);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D4B220(void *a1, uint64_t *a2, unint64_t a3)
{
  char v3 = a3;
  uint64_t v4 = a1[1];
  uint64_t v5 = *a1 ^ 0x736F6D6570736575;
  uint64_t v6 = v4 ^ 0x646F72616E646F6DLL;
  uint64_t v7 = *a1 ^ 0x6C7967656E657261;
  uint64_t v8 = v4 ^ 0x7465646279746573;
  if (a3 >= 8)
  {
    do
    {
      uint64_t v9 = *a2++;
      uint64_t v10 = (v5 + v6) ^ __ROR8__(v6, 51);
      uint64_t v11 = (v9 ^ v8) + v7;
      uint64_t v12 = v11 ^ __ROR8__(v9 ^ v8, 48);
      uint64_t v13 = v11 + v10;
      uint64_t v14 = v12 + __ROR8__(v5 + v6, 32);
      uint64_t v15 = v13 ^ __ROR8__(v10, 47);
      uint64_t v16 = v14 ^ __ROR8__(v12, 43);
      uint64_t v17 = v14 + v15;
      uint64_t v18 = v16 + __ROR8__(v13, 32);
      uint64_t v19 = v17 ^ __ROR8__(v15, 51);
      uint64_t v20 = v18 ^ __ROR8__(v16, 48);
      uint64_t v21 = v18 + v19;
      uint64_t v22 = v20 + __ROR8__(v17, 32);
      uint64_t v6 = v21 ^ __ROR8__(v19, 47);
      uint64_t v8 = v22 ^ __ROR8__(v20, 43);
      uint64_t v7 = __ROR8__(v21, 32);
      uint64_t v5 = v22 ^ v9;
      a3 -= 8;
    }
    while (a3 > 7);
  }
  uint64_t v65 = 0;
  if (a3) {
    __memcpy_chk();
  }
  HIBYTE(v65) = v3;
  uint64_t v23 = (v65 ^ v8) + v7;
  uint64_t v24 = (v5 + v6) ^ __ROR8__(v6, 51);
  uint64_t v25 = v23 ^ __ROR8__(v65 ^ v8, 48);
  uint64_t v26 = v23 + v24;
  uint64_t v27 = v25 + __ROR8__(v5 + v6, 32);
  uint64_t v28 = v26 ^ __ROR8__(v24, 47);
  uint64_t v29 = v27 ^ __ROR8__(v25, 43);
  uint64_t v30 = v27 + v28;
  uint64_t v31 = v29 + __ROR8__(v26, 32);
  uint64_t v32 = v30 ^ __ROR8__(v28, 51);
  uint64_t v33 = v31 ^ __ROR8__(v29, 48);
  uint64_t v34 = v31 + v32;
  uint64_t v35 = v33 + __ROR8__(v30, 32);
  uint64_t v36 = v34 ^ __ROR8__(v32, 47);
  uint64_t v37 = v35 ^ __ROR8__(v33, 43);
  uint64_t v38 = (v35 ^ v65) + v36;
  uint64_t v39 = (__ROR8__(v34, 32) ^ 0xFFLL) + v37;
  uint64_t v40 = v38 ^ __ROR8__(v36, 51);
  uint64_t v41 = v39 ^ __ROR8__(v37, 48);
  uint64_t v42 = v40 + v39;
  uint64_t v43 = v41 + __ROR8__(v38, 32);
  uint64_t v44 = v42 ^ __ROR8__(v40, 47);
  uint64_t v45 = v43 ^ __ROR8__(v41, 43);
  uint64_t v46 = v44 + v43;
  uint64_t v47 = __ROR8__(v42, 32) + v45;
  uint64_t v48 = v46 ^ __ROR8__(v44, 51);
  uint64_t v49 = v47 ^ __ROR8__(v45, 48);
  uint64_t v50 = v48 + v47;
  uint64_t v51 = v49 + __ROR8__(v46, 32);
  uint64_t v52 = v50 ^ __ROR8__(v48, 47);
  uint64_t v53 = v51 ^ __ROR8__(v49, 43);
  uint64_t v54 = v52 + v51;
  uint64_t v55 = __ROR8__(v50, 32) + v53;
  uint64_t v56 = v54 ^ __ROR8__(v52, 51);
  uint64_t v57 = v55 ^ __ROR8__(v53, 48);
  uint64_t v58 = v56 + v55;
  uint64_t v59 = v57 + __ROR8__(v54, 32);
  uint64_t v60 = v58 ^ __ROR8__(v56, 47);
  uint64_t v61 = v59 ^ __ROR8__(v57, 43);
  uint64_t v62 = __ROR8__(v58, 32) + v61;
  uint64_t v63 = (v60 + v59) ^ __ROR8__(v60, 51);
  return __ROR8__(v62 ^ __ROR8__(v61, 48), 43) ^ __ROR8__(v63, 47) ^ __ROR8__(v63 + v62, 32) ^ (v63 + v62);
}

void *sub_244D4B468(uint64_t a1)
{
  uint64_t v2 = sub_244D44058(0x28uLL);
  if (v2)
  {
    char v3 = sub_244D44098(4uLL, 8uLL);
    v2[1] = v3;
    if (v3)
    {
      v2[3] = 4;
      v2[4] = a1;
    }
    else
    {
      sub_244D440EC(v2);
      return 0;
    }
  }
  return v2;
}

void *sub_244D4B4C8()
{
  return sub_244D4B468(0);
}

void sub_244D4B4D0(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      if (8 * v2) {
        bzero((void *)a1[1], 8 * v2);
      }
      *a1 = 0;
      *((_DWORD *)a1 + 4) = 0;
    }
  }
}

unint64_t *sub_244D4B518(unint64_t *result, unint64_t a2)
{
  if (result)
  {
    if (*result <= a2) {
      return 0;
    }
    else {
      return *(unint64_t **)(result[1] + 8 * a2);
    }
  }
  return result;
}

uint64_t sub_244D4B53C(unint64_t *a1, unint64_t a2, uint64_t a3)
{
  if (!a1 || *a1 <= a2) {
    return 0;
  }
  *(void *)(a1[1] + 8 * a2) = a3;
  return a3;
}

void sub_244D4B564(unint64_t *a1, void (*a2)(uint64_t), uint64_t a3)
{
  if (a1)
  {
    unint64_t v4 = *a1;
    if (*a1)
    {
      unint64_t v7 = 0;
      do
      {
        if (*(void *)(a1[1] + 8 * v7))
        {
          a2(a3);
          unint64_t v4 = *a1;
        }
        ++v7;
      }
      while (v7 < v4);
    }
    sub_244D440EC((void *)a1[1]);
    sub_244D440EC(a1);
  }
}

void sub_244D4B5E8(unint64_t *a1, uint64_t a2)
{
}

uint64_t sub_244D4B600(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

unint64_t *sub_244D4B60C(unint64_t *result, uint64_t a2, unint64_t a3)
{
  if (!result) {
    return result;
  }
  char v3 = result;
  unint64_t v4 = *result;
  if (*result >= 0x7FFFFFFF)
  {
    sub_244D0B884(14, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/stack/stack.c", 179);
    return 0;
  }
  uint64_t v7 = result[3];
  if (v7 > v4 + 1) {
    goto LABEL_19;
  }
  if (v7 < 0) {
    unint64_t v8 = v7 + 1;
  }
  else {
    unint64_t v8 = 2 * v7;
  }
  if (v7 >= 0) {
    unint64_t v9 = 16 * v7;
  }
  else {
    unint64_t v9 = 8 * (v7 + 1);
  }
  if (v8 < v7 || v9 >> 3 != v8) {
    return 0;
  }
  size_t result = sub_244D44148((void *)result[1], v9);
  if (result)
  {
    v3[1] = (unint64_t)result;
    v3[3] = v8;
    unint64_t v4 = *v3;
LABEL_19:
    unint64_t v11 = v4 - a3;
    if (v4 <= a3)
    {
      uint64_t v13 = (void *)(v3[1] + 8 * v4);
    }
    else
    {
      unint64_t v12 = v3[1];
      if (8 * v11)
      {
        memmove((void *)(v12 + 8 * a3 + 8), (const void *)(v12 + 8 * a3), 8 * v11);
        unint64_t v12 = v3[1];
      }
      uint64_t v13 = (void *)(v12 + 8 * a3);
    }
    *uint64_t v13 = a2;
    size_t result = (unint64_t *)(*v3 + 1);
    *char v3 = (unint64_t)result;
    *((_DWORD *)v3 + 4) = 0;
  }
  return result;
}

uint64_t sub_244D4B714(uint64_t *a1, unint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v3 = *a1;
  if (*a1 <= a2) {
    return 0;
  }
  unint64_t v4 = (uint64_t *)(a1[1] + 8 * a2);
  uint64_t v5 = *v4;
  uint64_t v6 = v3 - 1;
  size_t v7 = 8 * (v3 + ~a2);
  if (v3 - 1 != a2 && v7 != 0)
  {
    memmove(v4, v4 + 1, v7);
    uint64_t v6 = *a1 - 1;
  }
  *a1 = v6;
  return v5;
}

uint64_t sub_244D4B78C(uint64_t *a1, uint64_t a2)
{
  if (!a1 || !*a1) {
    return 0;
  }
  unint64_t v2 = 0;
  while (*(void *)(a1[1] + 8 * v2) != a2)
  {
    if (*a1 == ++v2) {
      return 0;
    }
  }
  return sub_244D4B714(a1, v2);
}

unint64_t *sub_244D4B7C8(unint64_t *result, uint64_t (*a2)(uint64_t, void, uint64_t), uint64_t a3, uint64_t a4)
{
  if (result)
  {
    unint64_t v4 = result;
    if (*result)
    {
      unint64_t v8 = 0;
      unint64_t v9 = 0;
      do
      {
        size_t result = (unint64_t *)a2(a3, *(void *)(v4[1] + 8 * v8), a4);
        if (!result) {
          *(void *)(v4[1] + 8 * v9++) = *(void *)(v4[1] + 8 * v8);
        }
        ++v8;
      }
      while (v8 < *v4);
    }
    else
    {
      unint64_t v9 = 0;
    }
    *unint64_t v4 = v9;
  }
  return result;
}

uint64_t sub_244D4B860(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t (*a4)(void, uint64_t, void))
{
  if (!result) {
    return result;
  }
  uint64_t v6 = (void *)result;
  if (!*(void *)(result + 32))
  {
    unint64_t v10 = *(void *)result;
    if (*(void *)result)
    {
      unint64_t v11 = *(void **)(result + 8);
      if (*v11 == a3)
      {
        unint64_t v9 = 0;
        goto LABEL_27;
      }
      unint64_t v9 = 0;
      unint64_t v12 = v11 + 1;
      while (v10 - 1 != v9)
      {
        uint64_t v13 = v12[v9++];
        if (v13 == a3)
        {
          size_t result = v9 < v10;
          goto LABEL_28;
        }
      }
    }
    return 0;
  }
  if (!a3) {
    return 0;
  }
  unint64_t v8 = *(void *)result;
  if (*(_DWORD *)(result + 16) || v8 < 2)
  {
    if (v8)
    {
      unint64_t v14 = 0;
      do
      {
        unint64_t v9 = v14 + ((v8 - v14 - 1) >> 1);
        int v15 = a4(v6[4], a3, *(void *)(v6[1] + 8 * v9));
        if (v15 < 1)
        {
          if (v15 < 0)
          {
            unint64_t v8 = v14 + ((v8 - v14 - 1) >> 1);
          }
          else
          {
            if (v8 - v14 == 1) {
              goto LABEL_27;
            }
            unint64_t v8 = v9 + 1;
          }
        }
        else
        {
          unint64_t v14 = v9 + 1;
        }
      }
      while (v14 < v8);
    }
    return 0;
  }
  unint64_t v9 = 0;
  while (a4(v6[4], a3, *(void *)(v6[1] + 8 * v9)))
  {
    if (++v9 >= *v6) {
      return 0;
    }
  }
LABEL_27:
  size_t result = 1;
LABEL_28:
  if (a2) {
    *a2 = v9;
  }
  return result;
}

BOOL sub_244D4B9B4(uint64_t a1)
{
  if (!a1 || *(_DWORD *)(a1 + 16)) {
    return 1;
  }
  if (*(void *)(a1 + 32)) {
    return *(void *)a1 < 2uLL;
  }
  return 0;
}

uint64_t sub_244D4B9E8(uint64_t *a1)
{
  if (a1 && *a1) {
    return sub_244D4B714(a1, 0);
  }
  else {
    return 0;
  }
}

unint64_t *sub_244D4BA04(unint64_t *a1, uint64_t a2)
{
  return sub_244D4B60C(a1, a2, *a1);
}

uint64_t sub_244D4BA0C(uint64_t *a1)
{
  if (a1 && *a1) {
    return sub_244D4B714(a1, *a1 - 1);
  }
  else {
    return 0;
  }
}

void *sub_244D4BA28(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v2 = sub_244D44058(0x28uLL);
  if (v2)
  {
    uint64_t v3 = sub_244D442F4(*(const void **)(a1 + 8), 8 * *(void *)(a1 + 24));
    v2[1] = v3;
    if (v3)
    {
      void *v2 = *(void *)a1;
      *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
      v2[3] = *(void *)(a1 + 24);
      v2[4] = *(void *)(a1 + 32);
      return v2;
    }
    sub_244D440EC(0);
    sub_244D440EC(v2);
    return 0;
  }
  return v2;
}

uint64_t sub_244D4BAAC(uint64_t result, uint64_t (*a2)(void, void, void))
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(void *)(result + 32))
    {
      if (!*(_DWORD *)(result + 16))
      {
        unint64_t v3 = *(void *)result;
        if (*(void *)result >= 2uLL)
        {
          for (unint64_t i = (unint64_t)(*(void *)result - 2) >> 1; i < v3; --i)
          {
            size_t result = sub_244D4BB68(v2, a2, i, v3);
            unint64_t v3 = *(void *)v2;
          }
          unint64_t v6 = v3 - 1;
          if (v3 != 1)
          {
            do
            {
              size_t v7 = *(uint64_t **)(v2 + 8);
              uint64_t v8 = *v7;
              *size_t v7 = v7[v6];
              *(void *)(*(void *)(v2 + 8) + 8 * v6) = v8;
              size_t result = sub_244D4BB68(v2, a2, 0, v6--);
            }
            while (v6);
          }
        }
        *(_DWORD *)(v2 + 16) = 1;
      }
    }
  }
  return result;
}

uint64_t sub_244D4BB68(uint64_t result, uint64_t (*a2)(void, void, void), unint64_t a3, unint64_t a4)
{
  unint64_t v4 = (2 * a3) | 1;
  if (v4 < a4)
  {
    unint64_t v6 = a3;
    uint64_t v8 = result;
    uint64_t v9 = 2 * a3;
    do
    {
      size_t result = a2(*(void *)(v8 + 32), *(void *)(*(void *)(v8 + 8) + 8 * v6), *(void *)(*(void *)(v8 + 8) + 8 * v4));
      if ((int)result >= 0) {
        unint64_t v10 = v6;
      }
      else {
        unint64_t v10 = v4;
      }
      if (v9 + 2 < a4)
      {
        size_t result = a2(*(void *)(v8 + 32), *(void *)(*(void *)(v8 + 8) + 8 * v10), *(void *)(*(void *)(v8 + 8) + 8 * (v9 + 2)));
        if ((int)result < 0) {
          unint64_t v10 = v9 + 2;
        }
      }
      if (v6 == v10) {
        break;
      }
      uint64_t v11 = *(void *)(v8 + 8);
      uint64_t v12 = *(void *)(v11 + 8 * v6);
      *(void *)(v11 + 8 * v6) = *(void *)(v11 + 8 * v10);
      *(void *)(*(void *)(v8 + 8) + 8 * v10) = v12;
      uint64_t v9 = 2 * v10;
      unint64_t v4 = (2 * v10) | 1;
      unint64_t v6 = v10;
    }
    while (v4 < a4);
  }
  return result;
}

uint64_t sub_244D4BC3C(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result != a2) {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(void *)(a1 + 32) = a2;
  return result;
}

unint64_t *sub_244D4BC58(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3, void (*a4)(uint64_t), uint64_t a5)
{
  uint64_t v9 = sub_244D4BA28(a1);
  unint64_t v10 = v9;
  if (!v9) {
    return v10;
  }
  unint64_t v11 = *v9;
  if (!*v9) {
    return v10;
  }
  uint64_t v12 = 0;
  uint64_t v13 = (void *)v9[1];
  while (!v13[v12])
  {
LABEL_7:
    if (++v12 >= v11) {
      return v10;
    }
  }
  *(void *)(v10[1] + 8 * v12) = a2(a3);
  uint64_t v13 = (void *)v10[1];
  if (v13[v12])
  {
    unint64_t v11 = *v10;
    goto LABEL_7;
  }
  if (v12)
  {
    for (uint64_t i = 0; i != v12; ++i)
    {
      if (*(void *)(v10[1] + 8 * i)) {
        a4(a5);
      }
    }
    uint64_t v13 = (void *)v10[1];
  }
  sub_244D440EC(v13);
  sub_244D440EC(v10);
  return 0;
}

uint64_t sub_244D4BD2C(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_init(a1, 0);
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_244D4BD50(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_rdlock(a1);
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_244D4BD70(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_wrlock(a1);
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_244D4BD90(pthread_rwlock_t *a1)
{
  uint64_t result = pthread_rwlock_unlock(a1);
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_244D4BDB4(pthread_once_t *a1, void (*a2)(void))
{
  uint64_t result = pthread_once(a1, a2);
  if (result) {
    abort();
  }
  return result;
}

void *sub_244D4BDD4(int a1)
{
  if (pthread_once(&stru_268EBDC48, (void (*)(void))sub_244D4BE40)) {
    abort();
  }
  if (!dword_268EC0248) {
    return 0;
  }
  uint64_t result = pthread_getspecific(qword_268EC0250);
  if (result) {
    return (void *)result[a1];
  }
  return result;
}

uint64_t sub_244D4BE40()
{
  uint64_t result = pthread_key_create((pthread_key_t *)&qword_268EC0250, (void (__cdecl *)(void *))sub_244D4BF80);
  dword_268EC0248 = result == 0;
  return result;
}

uint64_t sub_244D4BE80(unsigned int a1, uint64_t a2, void (*a3)(uint64_t))
{
  if (pthread_once(&stru_268EBDC48, (void (*)(void))sub_244D4BE40)) {
    abort();
  }
  if (!dword_268EC0248) {
    goto LABEL_9;
  }
  unint64_t v6 = pthread_getspecific(qword_268EC0250);
  if (!v6)
  {
    uint64_t v8 = malloc_type_malloc(0x28uLL, 0x80040B8603338uLL);
    if (!v8) {
      goto LABEL_9;
    }
    unint64_t v6 = v8;
    *((void *)v8 + 4) = 0;
    *uint64_t v8 = 0u;
    v8[1] = 0u;
    if (pthread_setspecific(qword_268EC0250, v8))
    {
      free(v6);
      goto LABEL_9;
    }
  }
  if (!pthread_mutex_lock(&stru_268EBDC58))
  {
    *((void *)&xmmword_268EC0258 + a1) = a3;
    pthread_mutex_unlock(&stru_268EBDC58);
    *((void *)v6 + a1) = a2;
    return 1;
  }
LABEL_9:
  a3(a2);
  return 0;
}

void sub_244D4BF80(char *a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (a1 && !pthread_mutex_lock(&stru_268EBDC58))
  {
    v4[0] = xmmword_268EC0258;
    v4[1] = unk_268EC0268;
    uint64_t v5 = qword_268EC0278;
    pthread_mutex_unlock(&stru_268EBDC58);
    for (uint64_t i = 0; i != 40; i += 8)
    {
      unint64_t v3 = *(void (**)(void))((char *)v4 + i);
      if (v3) {
        v3(*(void *)&a1[i]);
      }
    }
    free(a1);
  }
}

uint64_t sub_244D4C040(int (*a1)(uint64_t, void **), uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t v10 = a1(a3, 0);
  unint64_t v11 = sub_244D43FF4(v10);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = v11;
  int v15 = v11;
  a1(a3, &v15);
  uint64_t v13 = sub_244D25474((uint64_t)v12, v10, a4, a5, a2);
  sub_244D440EC(v12);
  return v13;
}

uint64_t sub_244D4C0F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t v11 = 0;
  int v8 = sub_244CF6668(a3, &v11, a1);
  if (!v11) {
    return 0;
  }
  uint64_t v9 = sub_244D25474((uint64_t)v11, v8, a4, a5, a2);
  sub_244D440EC(v11);
  return v9;
}

uint64_t sub_244D4C180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (*(_DWORD *)(a4 + 4) == 3)
  {
    memset(v15, 0, sizeof(v15));
    sub_244D25618(v15);
    if (sub_244D25F08((uint64_t)v15, 0, a7, 0, a6)) {
      return sub_244D4C25C(a1, a2, a3, a4, a5, (uint64_t *)v15);
    }
    sub_244D25650((uint64_t)v15);
  }
  else
  {
    sub_244D0B884(12, 0, 191, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/a_sign.c", 73);
  }
  return 0;
}

uint64_t sub_244D4C25C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v20 = 0;
  if (*(_DWORD *)(a4 + 4) != 3)
  {
    int v15 = 12;
    int v16 = 191;
    __int16 v17 = 91;
LABEL_12:
    sub_244D0B884(v15, 0, v16, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/a_sign.c", v17);
LABEL_13:
    uint64_t v13 = 0;
    goto LABEL_14;
  }
  if (a2 && !sub_244D4C53C((uint64_t)a6, a2)
    || a3 && !sub_244D4C53C((uint64_t)a6, a3)
    || (sub_244CF6668(a5, &v20, a1) & 0x80000000) != 0)
  {
    goto LABEL_13;
  }
  uint64_t v11 = sub_244D07414(a6[2]);
  unint64_t v12 = (int)sub_244D0C314(v11);
  unsigned int v19 = v12;
  if ((v12 & 0x80000000) != 0)
  {
    int v15 = 11;
    int v16 = 69;
    __int16 v17 = 111;
    goto LABEL_12;
  }
  uint64_t v13 = sub_244D43FF4(v12);
  if (!v13)
  {
LABEL_14:
    uint64_t v14 = 0;
    goto LABEL_15;
  }
  if (!sub_244D26360(a6, (uint64_t)v13))
  {
    sub_244D0B884(11, 0, 6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/a_sign.c", 121);
    goto LABEL_14;
  }
  sub_244CF4790(a4, (uint64_t)v13, v19);
  uint64_t v13 = 0;
  *(void *)(a4 + 16) = *(void *)(a4 + 16) & 0xFFFFFFFFFFFFFFF0 | 8;
  uint64_t v14 = v19;
LABEL_15:
  sub_244D25650((uint64_t)a6);
  sub_244D440EC(v20);
  sub_244D440EC(v13);
  return v14;
}

uint64_t sub_244D4C3DC(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  if (!a5)
  {
    int v10 = 67;
    __int16 v11 = 75;
    goto LABEL_6;
  }
  uint64_t v16 = 0;
  if (a3[1] != 3)
  {
    uint64_t v16 = (int)sub_244CF48D8(a3);
    goto LABEL_8;
  }
  if (sub_244CF0CC0(a3, &v16))
  {
LABEL_8:
    memset(v15, 0, sizeof(v15));
    uint64_t v14 = 0;
    sub_244D25618(v15);
    if (sub_244D4C6B0((uint64_t)v15, a2, a5))
    {
      sub_244CF6668(a4, &v14, a1);
      if (v14)
      {
        sub_244CF48E8((uint64_t)a3);
        if (sub_244D26434((uint64_t)v15))
        {
          uint64_t v12 = 1;
LABEL_14:
          sub_244D440EC(v14);
          sub_244D25650((uint64_t)v15);
          return v12;
        }
        sub_244D0B884(11, 0, 6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/a_verify.c", 106);
      }
    }
    uint64_t v12 = 0;
    goto LABEL_14;
  }
  int v10 = 109;
  __int16 v11 = 82;
LABEL_6:
  sub_244D0B884(11, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/a_verify.c", v11);
  return 0;
}

uint64_t sub_244D4C53C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_244D07414(*(void *)(a1 + 16));
  if (!v4)
  {
    int v10 = 108;
    __int16 v11 = 80;
LABEL_18:
    sub_244D0B884(12, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/algorithm.c", v11);
    return 0;
  }
  uint64_t v5 = v4;
  if (sub_244CF48E0(v4) != 6
    || (v17[1] = 0, uint64_t result = sub_244D117E0(*(uint64_t **)(a1 + 16)), result))
  {
    if (sub_244CF48E0(v5) == 949)
    {
      size_t v7 = sub_244D44ED0(0x3B5u);
      uint64_t v8 = a2;
      int v9 = -1;
      return sub_244D5FD7C(v8, (uint64_t)v7, v9, 0);
    }
    uint64_t v12 = (unsigned int *)sub_244D259E0(a1);
    if (v12)
    {
      int v13 = sub_244CF48D8(v12);
      v17[0] = 0;
      if (v13 != 4)
      {
        int v14 = v13;
        if (v13 != 257)
        {
          int v15 = sub_244CF48E0(v5);
          if (sub_244D45610(v17, v14, v15))
          {
            if (sub_244CF48E0(v5) == 6) {
              int v16 = 5;
            }
            else {
              int v16 = -1;
            }
            size_t v7 = sub_244D44ED0(v17[0]);
            uint64_t v8 = a2;
            int v9 = v16;
            return sub_244D5FD7C(v8, (uint64_t)v7, v9, 0);
          }
        }
      }
      int v10 = 111;
      __int16 v11 = 111;
    }
    else
    {
      int v10 = 108;
      __int16 v11 = 103;
    }
    goto LABEL_18;
  }
  return result;
}

uint64_t sub_244D4C6B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_244D449A4(*(unsigned __int16 **)a2);
  uint64_t v16 = 0;
  if (!sub_244D45590(v6, (_DWORD *)&v16 + 1, &v16))
  {
    int v8 = 12;
    int v9 = 184;
    __int16 v10 = 128;
    goto LABEL_9;
  }
  int v7 = v16;
  if (v7 != sub_244CF48E0(a3))
  {
    int v8 = 12;
    int v9 = 189;
    __int16 v10 = 134;
    goto LABEL_9;
  }
  if (HIDWORD(v16))
  {
    if (HIDWORD(v16) == 257 || HIDWORD(v16) == 4)
    {
      int v8 = 12;
      int v9 = 111;
      __int16 v10 = 140;
LABEL_9:
      sub_244D0B884(v8, 0, v9, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/algorithm.c", v10);
      return 0;
    }
    uint64_t v12 = *(_DWORD **)(a2 + 8);
    if (v12 && *v12 != 5)
    {
      int v8 = 11;
      int v9 = 136;
      __int16 v10 = 166;
      goto LABEL_9;
    }
    uint64_t v13 = sub_244D06E98(SHIDWORD(v16));
    if (!v13)
    {
      int v8 = 12;
      int v9 = 183;
      __int16 v10 = 173;
      goto LABEL_9;
    }
    uint64_t v14 = v13;
    uint64_t v15 = a1;
    return sub_244D26044(v15, 0, v14, 0, a3);
  }
  if (v6 == 949)
  {
    if (*(void *)(a2 + 8))
    {
      int v8 = 11;
      int v9 = 136;
      __int16 v10 = 151;
      goto LABEL_9;
    }
    uint64_t v15 = a1;
    uint64_t v14 = 0;
    return sub_244D26044(v15, 0, v14, 0, a3);
  }
  if (v6 != 912)
  {
    int v8 = 12;
    int v9 = 184;
    __int16 v10 = 156;
    goto LABEL_9;
  }
  return sub_244D4F04C(a1, a2, a3);
}

uint64_t sub_244D4C878(char *a1, uint64_t a2)
{
  memset(v8, 0, sizeof(v8));
  if (sub_244CFB3DC((uint64_t)v8, 0) && sub_244D4C94C((uint64_t *)v8, a1, a2, 1, 0))
  {
    if ((unint64_t)sub_244CFB760((uint64_t)v8) <= 0x10000)
    {
      int v7 = sub_244CFB738((uint64_t)v8);
      uint64_t v5 = sub_244CFB760((uint64_t)v8);
      uint64_t v4 = sub_244CF7E90(0, (uint64_t *)&v7, v5);
      sub_244CFB470((uint64_t)v8);
      return v4;
    }
    sub_244D0B884(12, 0, 177, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/asn1_gen.c", 115);
  }
  sub_244CFB470((uint64_t)v8);
  return 0;
}

uint64_t sub_244D4C94C(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a5 > 50)
  {
    int v5 = 131;
    __int16 v6 = 194;
LABEL_66:
    sub_244D0B884(12, 0, v5, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/asn1_gen.c", v6);
    return 0;
  }
  unsigned int v10 = 0;
  while (1)
  {
    while (1)
    {
      int v11 = *a2;
      if (*a2)
      {
        uint64_t v12 = a2;
        do
        {
          if (!sub_244D44410(v11)) {
            break;
          }
          int v13 = *++v12;
          int v11 = v13;
        }
        while (v13);
      }
      else
      {
        uint64_t v12 = a2;
      }
      uint64_t v14 = strchr(v12, 44);
      if (!v14) {
        goto LABEL_59;
      }
      uint64_t v15 = v14;
      *(void *)&v62[0] = v12;
      *((void *)&v62[0] + 1) = v14 - v12;
      LOBYTE(v61) = 0;
      long long v16 = v62[0];
      while (1)
      {
        long long v63 = v16;
        if (!sub_244CFC858(&v63, &v61) || !sub_244D44410(v61)) {
          break;
        }
        long long v16 = v63;
        v62[0] = v63;
        LOBYTE(v61) = 0;
      }
      long long v63 = 0uLL;
      if (sub_244CFC970((uint64_t)v62, &v63, 58))
      {
        sub_244CFC510(v62, 1uLL);
      }
      else
      {
        long long v63 = v62[0];
        v62[0] = 0uLL;
      }
      a2 = v15 + 1;
      if (!sub_244D4D3EC((uint64_t)&v63, "FORMAT") && !sub_244D4D3EC((uint64_t)&v63, "FORM")) {
        break;
      }
      if (sub_244D4D3EC((uint64_t)v62, "ASCII"))
      {
        a4 = 1;
      }
      else if (sub_244D4D3EC((uint64_t)v62, "UTF8"))
      {
        a4 = 2;
      }
      else if (sub_244D4D3EC((uint64_t)v62, "HEX"))
      {
        a4 = 3;
      }
      else
      {
        if (!sub_244D4D3EC((uint64_t)v62, "BITLIST"))
        {
          int v5 = 182;
          __int16 v6 = 250;
          goto LABEL_66;
        }
        a4 = 4;
      }
    }
    if (!sub_244D4D3EC((uint64_t)&v63, "IMP") && !sub_244D4D3EC((uint64_t)&v63, "IMPLICIT")) {
      break;
    }
    if (v10)
    {
      int v5 = 131;
      __int16 v6 = 256;
      goto LABEL_66;
    }
    unsigned int v10 = sub_244D4D458(v62);
    if (!v10) {
      return 0;
    }
  }
  if (sub_244D4D3EC((uint64_t)&v63, "EXP") || sub_244D4D3EC((uint64_t)&v63, "EXPLICIT"))
  {
    if (v10)
    {
      int v5 = 131;
      __int16 v6 = 268;
      goto LABEL_66;
    }
    int v17 = sub_244D4D458(v62);
    if (v17)
    {
      unsigned int v18 = v17 | 0x20000000;
LABEL_45:
      uint64_t v20 = a3;
      unsigned int v19 = a1;
      uint64_t v21 = (uint64_t)a2;
      int v22 = 0;
      return sub_244D4D5AC(v19, v21, v20, v18, v22, a4, a5);
    }
    return 0;
  }
  if (sub_244D4D3EC((uint64_t)&v63, "OCTWRAP"))
  {
    if (v10) {
      unsigned int v18 = v10;
    }
    else {
      unsigned int v18 = 4;
    }
    goto LABEL_45;
  }
  if (sub_244D4D3EC((uint64_t)&v63, "BITWRAP"))
  {
    if (v10) {
      unsigned int v18 = v10;
    }
    else {
      unsigned int v18 = 3;
    }
    uint64_t v20 = a3;
    unsigned int v19 = a1;
    uint64_t v21 = (uint64_t)a2;
    int v22 = 1;
    return sub_244D4D5AC(v19, v21, v20, v18, v22, a4, a5);
  }
  if (sub_244D4D3EC((uint64_t)&v63, "SEQWRAP"))
  {
    int v24 = v10 | 0x20000000;
    BOOL v25 = v10 == 0;
    int v26 = 536870928;
    goto LABEL_56;
  }
  if (sub_244D4D3EC((uint64_t)&v63, "SETWRAP"))
  {
    int v24 = v10 | 0x20000000;
    int v26 = 536870929;
    BOOL v25 = v10 == 0;
LABEL_56:
    if (v25) {
      unsigned int v18 = v26;
    }
    else {
      unsigned int v18 = v24;
    }
    goto LABEL_45;
  }
LABEL_59:
  uint64_t v27 = strchr(v12, 58);
  uint64_t v28 = v27;
  long long v63 = 0uLL;
  if (v27)
  {
    size_t v29 = v27 - v12;
    uint64_t v30 = v28 + 1;
  }
  else
  {
    size_t v29 = strlen(v12);
    uint64_t v30 = "";
  }
  *(void *)&long long v63 = v12;
  *((void *)&v63 + 1) = v29;
  unint64_t v31 = -9;
  uint64_t v32 = (unsigned int *)&dword_2651A71B8;
  while (!sub_244D4D3EC((uint64_t)&v63, *((char **)v32 - 1)))
  {
    ++v31;
    v32 += 4;
    if (v31 == 24)
    {
      int v5 = 185;
      __int16 v6 = 356;
      goto LABEL_66;
    }
  }
  unsigned int v35 = *v32;
  memset(&v62[1], 0, 32);
  if (v10) {
    unsigned int v36 = v35 & 0x20000000 | v10;
  }
  else {
    unsigned int v36 = v35;
  }
  v62[0] = 0uLL;
  if (!sub_244CFB808(a1, (uint64_t)v62, v36)) {
    return 0;
  }
  switch(v35)
  {
    case 1u:
      if (a4 != 1)
      {
        int v5 = 161;
        __int16 v6 = 377;
        goto LABEL_66;
      }
      LODWORD(v61) = 0;
      if (!sub_244D57860(v30, &v61))
      {
        int v5 = 125;
        __int16 v6 = 382;
        goto LABEL_66;
      }
      if (v61) {
        unsigned int v49 = 255;
      }
      else {
        unsigned int v49 = 0;
      }
      if (!sub_244CFB8C4((uint64_t)v62, v49)) {
        return 0;
      }
      return sub_244CFB540(a1) != 0;
    case 2u:
    case 0xAu:
      if (a4 != 1)
      {
        int v5 = 139;
        __int16 v6 = 391;
        goto LABEL_66;
      }
      uint64_t v42 = (void **)sub_244D5766C(0, v30);
      if (!v42)
      {
        int v5 = 130;
        __int16 v6 = 396;
        goto LABEL_66;
      }
      uint64_t v43 = v42;
      int v44 = sub_244CF1690(v42, 0);
      *(void *)&long long v61 = 0;
      if (v44 < 1
        || (int v45 = v44, !sub_244CFBA94((uint64_t)v62, &v61, v44))
        || sub_244CF1690(v43, (unsigned char **)&v61) != v45)
      {
        BOOL v33 = 0;
        goto LABEL_132;
      }
      goto LABEL_94;
    case 3u:
      if (a4 == 4)
      {
        uint64_t v50 = (void **)sub_244CF7D18();
        if (!v50) {
          return 0;
        }
        uint64_t v43 = v50;
        if (!sub_244CFF87C(v30, 44, 1, (uint64_t (*)(char *, uint64_t, uint64_t))sub_244D4D654, (uint64_t)v50))
        {
          sub_244D0B884(12, 0, 151, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/asn1_gen.c", 483);
          sub_244CF7CBC((uint64_t)v43);
          return 0;
        }
        int v51 = sub_244CF0D10((uint64_t)v43, 0);
        *(void *)&long long v61 = 0;
        if (v51 >= 1
          && (int v52 = v51, sub_244CFBA94((uint64_t)v62, &v61, v51))
          && sub_244CF0D10((uint64_t)v43, (unsigned char **)&v61) == v52)
        {
LABEL_94:
          BOOL v33 = sub_244CFB540(a1) != 0;
        }
        else
        {
          BOOL v33 = 0;
        }
LABEL_132:
        sub_244CF7CBC((uint64_t)v43);
      }
      else
      {
        if (!sub_244CFB8C4((uint64_t)v62, 0)) {
          return 0;
        }
LABEL_138:
        if (a4 != 3)
        {
          if (a4 == 1) {
            goto LABEL_140;
          }
          int v5 = 124;
          __int16 v6 = 521;
          goto LABEL_66;
        }
        *(void *)&long long v61 = 0;
        uint64_t v57 = sub_244D57EA0(v30, &v61);
        if (!v57)
        {
          int v5 = 128;
          __int16 v6 = 513;
          goto LABEL_66;
        }
        uint64_t v58 = v57;
        if (sub_244CFBA40((uint64_t)v62, v57, v61)) {
          BOOL v33 = sub_244CFB540(a1) != 0;
        }
        else {
          BOOL v33 = 0;
        }
        sub_244D440EC(v58);
      }
      return v33;
    case 4u:
      goto LABEL_138;
    case 5u:
      if (!*v30) {
        return sub_244CFB540(a1);
      }
      int v5 = 133;
      __int16 v6 = 370;
      goto LABEL_66;
    case 6u:
      if (a4 != 1)
      {
        int v5 = 165;
        __int16 v6 = 411;
        goto LABEL_66;
      }
      uint64_t v53 = sub_244D44DDC(v30, 0);
      if (!v53 || (uint64_t v54 = v53, v55 = *((int *)v53 + 5), !v55))
      {
        int v5 = 134;
        __int16 v6 = 416;
        goto LABEL_66;
      }
      if (sub_244CFBA40((uint64_t)v62, v53[3], v55)) {
        BOOL v33 = sub_244CFB540(a1) != 0;
      }
      else {
        BOOL v33 = 0;
      }
      sub_244CF29AC((void **)v54);
      return v33;
    case 7u:
    case 8u:
    case 9u:
    case 0xBu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x15u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Du:
      goto LABEL_103;
    case 0xCu:
    case 0x13u:
    case 0x14u:
    case 0x16u:
    case 0x1Cu:
    case 0x1Eu:
      if (a4 == 1)
      {
        int v37 = 4097;
      }
      else
      {
        if (a4 != 2)
        {
          int v5 = 127;
          __int16 v6 = 457;
          goto LABEL_66;
        }
        int v37 = 4096;
      }
      *(void *)&long long v61 = 0;
      unint64_t v48 = sub_244CF51E0(v35);
      if ((int)sub_244CF1FEC(&v61, v30, 0xFFFFFFFFFFFFFFFFLL, v37, v48, 0, 0x10000) < 1) {
        return 0;
      }
      if (sub_244CFBA40((uint64_t)v62, *(const void **)(v61 + 8), *(int *)v61)) {
        BOOL v33 = sub_244CFB540(a1) != 0;
      }
      else {
        BOOL v33 = 0;
      }
      sub_244CF474C(v61);
      return v33;
    case 0x17u:
    case 0x18u:
      if (a4 != 1)
      {
        int v5 = 176;
        __int16 v6 = 427;
        goto LABEL_66;
      }
      size_t v46 = strlen(v30);
      *(void *)&long long v61 = v30;
      *((void *)&v61 + 1) = v46;
      if (v31 > 1) {
        int v47 = sub_244CFD780(&v61, 0, 0);
      }
      else {
        int v47 = sub_244CFDA84(&v61, 0, 0);
      }
      if (!v47)
      {
        int v5 = 138;
        __int16 v6 = 438;
        goto LABEL_66;
      }
LABEL_140:
      size_t v56 = strlen(v30);
      if (sub_244CFBA40((uint64_t)v62, v30, v56)) {
        return sub_244CFB540(a1) != 0;
      }
      return 0;
    default:
      if (v35 - 536870928 >= 2)
      {
LABEL_103:
        int v5 = 68;
        __int16 v6 = 558;
        goto LABEL_66;
      }
      if (!v28) {
        goto LABEL_86;
      }
      if (!a3)
      {
        int v5 = 170;
        __int16 v6 = 528;
        goto LABEL_66;
      }
      uint64_t v38 = sub_244D520D8(a3, (uint64_t)v30);
      BOOL v33 = v38;
      if (!v38)
      {
        sub_244D0B884(12, 0, 170, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/asn1_gen.c", 533);
        return v33;
      }
      if (!sub_244D259E0(v38)) {
        goto LABEL_86;
      }
      unint64_t v39 = 0;
      uint64_t v40 = (a5 + 1);
      break;
  }
  do
  {
    uint64_t v41 = sub_244D4B518((unint64_t *)v33, v39);
    if (!sub_244D4C94C(v62, v41[2], a3, 1, v40)) {
      return 0;
    }
    if ((unint64_t)sub_244CFB760((uint64_t)v62) > 0x10000)
    {
      int v5 = 177;
      __int16 v6 = 546;
      goto LABEL_66;
    }
    ++v39;
  }
  while (v39 < sub_244D259E0(v33));
LABEL_86:
  if (v31 != 23) {
    return sub_244CFB540(a1);
  }
  if (!sub_244CFC2C0((uint64_t)v62)) {
    return 0;
  }
  return sub_244CFB540(a1) != 0;
}

BOOL sub_244D4D3EC(uint64_t a1, char *__s)
{
  size_t v4 = *(void *)(a1 + 8);
  if (v4 != strlen(__s)) {
    return 0;
  }
  if (v4) {
    return memcmp(*(const void **)a1, __s, v4) == 0;
  }
  return 1;
}

uint64_t sub_244D4D458(long long *a1)
{
  long long v9 = *a1;
  unint64_t v8 = 0;
  if (sub_244CFC9E0((unsigned __int8 **)&v9, &v8) && !(v8 >> 29))
  {
    unsigned __int8 v7 = 0;
    if (!sub_244CFC650(&v9, &v7))
    {
      unsigned int v2 = 0x80000000;
      int v5 = v8;
      return v2 | v5;
    }
    if (v7 > 0x4Fu)
    {
      if (v7 == 80)
      {
        int v1 = 0;
        unsigned int v2 = -1073741824;
        goto LABEL_15;
      }
      if (v7 == 85)
      {
        unsigned int v2 = 0;
        int v1 = 1;
        goto LABEL_15;
      }
    }
    else
    {
      if (v7 == 65)
      {
        int v1 = 0;
        unsigned int v2 = 0x40000000;
        goto LABEL_15;
      }
      if (v7 == 67)
      {
        int v1 = 0;
        unsigned int v2 = 0x80000000;
LABEL_15:
        if (*((void *)&v9 + 1))
        {
          int v3 = 144;
          __int16 v4 = 165;
          goto LABEL_23;
        }
        int v5 = v8;
        if (v8) {
          int v1 = 0;
        }
        if (v1 == 1)
        {
          int v3 = 145;
          __int16 v4 = 173;
          goto LABEL_23;
        }
        return v2 | v5;
      }
    }
    int v3 = 144;
    __int16 v4 = 160;
    goto LABEL_23;
  }
  int v3 = 145;
  __int16 v4 = 138;
LABEL_23:
  sub_244D0B884(12, 0, v3, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/asn1_gen.c", v4);
  return 0;
}

uint64_t sub_244D4D5AC(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, int a7)
{
  memset(v14, 0, sizeof(v14));
  uint64_t result = sub_244CFB808(a1, (uint64_t)v14, a4);
  if (result)
  {
    if (!a5 || (uint64_t result = sub_244CFB8C4((uint64_t)v14, 0), result))
    {
      uint64_t result = sub_244D4C94C(v14, a2, a3, a6, (a7 + 1));
      if (result) {
        return sub_244CFB540(a1) != 0;
      }
    }
  }
  return result;
}

BOOL sub_244D4D654(unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  __int16 v6 = a1;
  uint64_t v7 = a2;
  unint64_t v5 = 0;
  if (sub_244CFC9E0(&v6, &v5) && !v7 && v5 < 0x101) {
    return sub_244CF0F9C(a3, v5, 1) != 0;
  }
  sub_244D0B884(12, 0, 145, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/asn1_gen.c", 578);
  return 0;
}

uint64_t sub_244D4D6E0(uint64_t a1, void **a2)
{
  int v4 = sub_244CF48E0(a1);
  switch(v4)
  {
    case 408:
      uint64_t v7 = sub_244D0FDD8(a1);
      return sub_244D0A304(v7, a2);
    case 116:
      unint64_t v8 = (uint64_t **)sub_244D0F0B8(a1);
      return sub_244D094A0(v8, a2);
    case 6:
      unint64_t v5 = (uint64_t **)sub_244D11F18(a1);
      return sub_244D4A284(v5, a2);
    default:
      sub_244D0B884(12, 0, 187, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/i2d_pr.c", 76);
      return 0xFFFFFFFFLL;
  }
}

uint64_t sub_244D4D7B8(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  int v4 = a2;
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (a4)
  {
    int v6 = a4;
    uint64_t v7 = a3 & ~(a3 >> 31);
    if (!sub_244D4DBAC(a1, a3 & ~(a3 >> 31))) {
      return 0xFFFFFFFFLL;
    }
    int v8 = 3;
    int v9 = 1;
    int v10 = v7;
    unsigned int v35 = "\n";
    unsigned int v36 = " + ";
    switch(((*(void *)&v6 & 0xF0000uLL) - 0x10000) >> 16)
    {
      case 0uLL:
        int v10 = 0;
        unsigned int v36 = "+";
        int v8 = 1;
        int v11 = ",";
        goto LABEL_10;
      case 1uLL:
        int v10 = 0;
        int v9 = 2;
        unsigned int v36 = " + ";
        int v11 = ", ";
        goto LABEL_10;
      case 2uLL:
        int v10 = 0;
        int v9 = 2;
        unsigned int v36 = " + ";
        int v11 = "; ";
LABEL_10:
        unsigned int v35 = v11;
        break;
      case 3uLL:
        break;
      default:
        return 0xFFFFFFFFLL;
    }
    int v13 = " = ";
    if ((*(void *)&v6 & 0x800000) == 0) {
      int v13 = "=";
    }
    uint64_t v37 = (uint64_t)v13;
    if ((*(void *)&v6 & 0x800000) != 0) {
      int v14 = 3;
    }
    else {
      int v14 = 1;
    }
    int v39 = v14;
    int v15 = sub_244D5F544(v4);
    unsigned int v16 = v15 - 1;
    if (v15 >= 1)
    {
      int v33 = v8;
      int v34 = v10;
      unsigned int v17 = 0;
      int v31 = v9;
      int v32 = v9 + v10;
      int v18 = -1;
      uint64_t v38 = v4;
      do
      {
        if ((*(void *)&v6 & 0x100000) != 0) {
          unsigned int v19 = v16;
        }
        else {
          unsigned int v19 = v17;
        }
        uint64_t v20 = sub_244D5F4E0(v4, v19);
        uint64_t v21 = (uint64_t)v20;
        if (v18 != -1)
        {
          if (v18 == sub_244CF8FB4((uint64_t)v20))
          {
            if (a1 && sub_244CF8524(a1, (uint64_t)v36, v33) != v33) {
              return 0xFFFFFFFFLL;
            }
            LODWORD(v7) = v7 + v33;
          }
          else
          {
            if (a1 && sub_244CF8524(a1, (uint64_t)v35, v31) != v31 || !sub_244D4DBAC(a1, v34)) {
              return 0xFFFFFFFFLL;
            }
            LODWORD(v7) = v32 + v7;
          }
        }
        int v18 = sub_244CF8FB4(v21);
        int v22 = (unsigned __int16 *)sub_244D259E0(v21);
        uint64_t v23 = sub_244C9DDF8(v21);
        unsigned int v24 = sub_244D449A4(v22);
        unsigned int v25 = v24;
        if (v24)
        {
          int v26 = sub_244D44FD4(v24);
        }
        else
        {
          int v26 = (char **)v40;
          sub_244D45104(v40, 80, (uint64_t)v22, 1);
        }
        int v27 = strlen((const char *)v26);
        if (a1
          && (sub_244CF8524(a1, (uint64_t)v26, v27) != v27
           || sub_244CF8524(a1, v37, v39) != v39))
        {
          return 0xFFFFFFFFLL;
        }
        BOOL v28 = v25 || (v6 & 0x1000000) == 0;
        __int16 v29 = 128;
        if (v28) {
          __int16 v29 = 0;
        }
        int v30 = sub_244CF2A70(a1, v23, v29 | (unsigned __int16)v6);
        if (v30 < 0) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v7 = (v7 + v39 + v27 + v30);
        ++v17;
        --v16;
        int v4 = v38;
      }
      while (v16 != -1);
    }
    return v7;
  }
  else
  {
    return sub_244D4FCB0(a1, a2);
  }
}

uint64_t sub_244D4DB38(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v7 = sub_244CF90D4();
    if (!v7) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v9 = sub_244D4D7B8((uint64_t)v7, a2, a3, a4);
  sub_244CF830C((uint64_t)v7);
  return v9;
}

BOOL sub_244D4DBAC(uint64_t a1, int a2)
{
  if (a2 < 1)
  {
    return 1;
  }
  else
  {
    BOOL v4 = 0;
    for (i = 0; i != a2; BOOL v4 = i >= a2)
    {
      if (a1 && sub_244CF8524(a1, (uint64_t)" ", 1) != 1) {
        break;
      }
      ++i;
    }
  }
  return v4;
}

uint64_t sub_244D4DC34(unint64_t *a1, uint64_t a2, __int16 a3, unint64_t **a4)
{
  *a4 = 0;
  unint64_t v8 = sub_244D259E0((uint64_t)a1);
  unint64_t v9 = v8 - 2;
  if (v8 < 2) {
    return 0;
  }
  unint64_t v11 = v8;
  if ((a3 & 0x100) != 0) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = v8 + 1;
  }
  if ((a3 & 0x200) != 0) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = v8 + 1;
  }
  unint64_t v96 = v13;
  unint64_t v97 = v12;
  if ((a3 & 0x400) != 0) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = v8 + 1;
  }
  unint64_t v95 = v14;
  int v15 = sub_244D4B4C8();
  unsigned int v16 = v15;
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_139:
    uint64_t v68 = 0;
LABEL_140:
    uint64_t v10 = 17;
    goto LABEL_146;
  }
  uint64_t v90 = a2;
  unint64_t v91 = a4;
  uint64_t v17 = 0;
  unint64_t v92 = v15;
  do
  {
    int v18 = sub_244D4B518(a1, v9);
    if (!sub_244D5643C((uint64_t)v18)) {
      goto LABEL_139;
    }
    int v19 = *((_DWORD *)v18 + 12);
    if (!v17)
    {
      uint64_t v20 = sub_244D4E820();
      uint64_t v17 = (uint64_t)v20;
      if (!v20) {
        goto LABEL_139;
      }
      *((_DWORD *)v20 + 2) = 1;
    }
    if (v96)
    {
      BOOL v21 = 1;
    }
    else if (v9)
    {
      BOOL v21 = (v19 & 0x20) != 0;
    }
    else
    {
      BOOL v21 = 0;
    }
    int v98 = 0;
    uint64_t v22 = sub_244D5A248((uint64_t)v18, 89, &v98, 0);
    char v93 = v19;
    if (!v22)
    {
      if (v98 == -1)
      {
        *(_DWORD *)(v17 + 8) = 0;
        if (sub_244D259E0(*(void *)v17))
        {
          unint64_t v34 = 0;
          do
          {
            unsigned int v35 = sub_244D4B518(*(unint64_t **)v17, v34);
            sub_244D4EA68(v35);
            ++v34;
          }
          while (v34 < sub_244D259E0(*(void *)v17));
        }
        sub_244D4B4D0(*(uint64_t **)v17);
        goto LABEL_56;
      }
      goto LABEL_145;
    }
    uint64_t v23 = (unint64_t *)v22;
    if (!sub_244D259E0(v22))
    {
      sub_244D0B884(11, 0, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/policy.c", 245);
      int v30 = 0;
      goto LABEL_144;
    }
    sub_244D4BC3C((uint64_t)v23, (uint64_t)sub_244D4E920);
    sub_244D4BAAC((uint64_t)v23, (uint64_t (*)(void, void, void))sub_244D4EB6C);
    if (!sub_244D259E0((uint64_t)v23))
    {
      int v28 = *(_DWORD *)(v17 + 8);
LABEL_53:
      sub_244D4B7C8(*(unint64_t **)v17, (uint64_t (*)(uint64_t, void, uint64_t))sub_244D4EB9C, (uint64_t)sub_244D4E934, (uint64_t)v23);
      *(_DWORD *)(v17 + 8) = 0;
      if (!v28) {
        goto LABEL_54;
      }
LABEL_37:
      int v30 = sub_244D4B4C8();
      if (v30)
      {
        if (sub_244D259E0((uint64_t)v23))
        {
          unint64_t v31 = 0;
          while (1)
          {
            int v32 = (uint64_t *)sub_244D4B518(v23, v31);
            if (sub_244D449A4((unsigned __int16 *)*v32) != 746
              && !sub_244D4E99C((unint64_t **)v17, *v32))
            {
              int v33 = sub_244D4EA04(*v32);
              if (!v33 || !sub_244D4BA04(v30, (uint64_t)v33)) {
                break;
              }
            }
            if (++v31 >= sub_244D259E0((uint64_t)v23)) {
              goto LABEL_45;
            }
          }
          sub_244D4EA68(v33);
        }
        else
        {
LABEL_45:
          if (sub_244D4EAD4((unint64_t **)v17, v30)) {
            goto LABEL_55;
          }
        }
      }
      goto LABEL_144;
    }
    unint64_t v24 = 0;
    int v25 = 0;
    do
    {
      int v26 = sub_244D4B518(v23, v24);
      if (sub_244D449A4((unsigned __int16 *)*v26) == 746) {
        int v25 = 1;
      }
      if (v24)
      {
        int v27 = (uint64_t *)sub_244D4B518(v23, v24 - 1);
        if (!sub_244D44948(*v27, *v26))
        {
          sub_244D0B884(11, 0, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/policy.c", 260);
          int v30 = 0;
          unsigned int v16 = v92;
LABEL_144:
          sub_244D4B564(v30, (void (*)(uint64_t))sub_244D4EBE8, (uint64_t)sub_244D4EA68);
          sub_244D52C8C((uint64_t)v23);
          goto LABEL_145;
        }
      }
      ++v24;
    }
    while (v24 < sub_244D259E0((uint64_t)v23));
    int v28 = *(_DWORD *)(v17 + 8);
    if (v25) {
      BOOL v29 = v21;
    }
    else {
      BOOL v29 = 0;
    }
    unsigned int v16 = v92;
    if (!v29) {
      goto LABEL_53;
    }
    if (v28) {
      goto LABEL_37;
    }
LABEL_54:
    int v30 = 0;
LABEL_55:
    sub_244D4B564(v30, (void (*)(uint64_t))sub_244D4EBE8, (uint64_t)sub_244D4EA68);
    sub_244D52C8C((uint64_t)v23);
LABEL_56:
    if (!v97 && !*(_DWORD *)(v17 + 8) && !sub_244D259E0(*(void *)v17))
    {
      uint64_t v68 = 0;
      goto LABEL_157;
    }
    if (!sub_244D4BA04(v16, v17)) {
      goto LABEL_139;
    }
    if (!v9)
    {
      uint64_t v40 = 0;
      goto LABEL_118;
    }
    unint64_t v36 = v95;
    int v98 = 0;
    uint64_t v37 = sub_244D5A248((uint64_t)v18, 747, &v98, 0);
    uint64_t v38 = (unint64_t *)v37;
    if (!v37)
    {
      int v39 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      if (v98 != -1) {
        goto LABEL_115;
      }
    }
    if (!v37) {
      goto LABEL_89;
    }
    if (!sub_244D259E0(v37))
    {
      sub_244D0B884(11, 0, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/policy.c", 369);
      goto LABEL_86;
    }
    if (sub_244D259E0((uint64_t)v38))
    {
      unint64_t v42 = 0;
      while (1)
      {
        uint64_t v43 = (unsigned __int16 **)sub_244D4B518(v38, v42);
        if (sub_244D449A4(*v43) == 746 || sub_244D449A4(v43[1]) == 746) {
          break;
        }
        if (++v42 >= sub_244D259E0((uint64_t)v38)) {
          goto LABEL_70;
        }
      }
LABEL_86:
      int v39 = 0;
LABEL_87:
      uint64_t v40 = 0;
      uint64_t v41 = v38;
      goto LABEL_115;
    }
LABEL_70:
    sub_244D4BC3C((uint64_t)v38, (uint64_t)sub_244D4EBF4);
    sub_244D4BAAC((uint64_t)v38, (uint64_t (*)(void, void, void))sub_244D4EC7C);
    if (!v36)
    {
      sub_244D4B7C8(*(unint64_t **)v17, (uint64_t (*)(uint64_t, void, uint64_t))sub_244D4EB9C, (uint64_t)sub_244D4EC08, (uint64_t)v38);
      sub_244D4B564(v38, (void (*)(uint64_t))sub_244D4ECAC, (uint64_t)sub_244D55D44);
LABEL_89:
      uint64_t v38 = sub_244D4B4C8();
      int v39 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      if (!v38) {
        goto LABEL_115;
      }
      goto LABEL_90;
    }
    int v44 = sub_244D4B4C8();
    if (!v44) {
      goto LABEL_86;
    }
    unint64_t v88 = v44;
    if (sub_244D259E0((uint64_t)v38))
    {
      unint64_t v45 = 0;
      uint64_t v46 = 0;
      while (1)
      {
        int v47 = (uint64_t *)sub_244D4B518(v38, v45);
        unint64_t v48 = v47;
        if (v46 && !sub_244D44948(*v47, v46)) {
          goto LABEL_81;
        }
        uint64_t v46 = *v48;
        unsigned int v49 = sub_244D4E99C((unint64_t **)v17, *v48);
        if (v49) {
          goto LABEL_80;
        }
        if (*(_DWORD *)(v17 + 8)) {
          break;
        }
LABEL_81:
        if (++v45 >= sub_244D259E0((uint64_t)v38)) {
          goto LABEL_82;
        }
      }
      unsigned int v49 = sub_244D4EA04(*v48);
      int v39 = v88;
      if (!v49 || !sub_244D4BA04(v88, (uint64_t)v49))
      {
        sub_244D4EA68(v49);
        goto LABEL_87;
      }
LABEL_80:
      *((_DWORD *)v49 + 4) = 1;
      goto LABEL_81;
    }
LABEL_82:
    int v39 = v88;
    if (!sub_244D4EAD4((unint64_t **)v17, v88)) {
      goto LABEL_87;
    }
LABEL_90:
    unint64_t v89 = v39;
    if (sub_244D259E0(*(void *)v17))
    {
      unint64_t v50 = 0;
      do
      {
        int v51 = sub_244D4B518(*(unint64_t **)v17, v50);
        if (!*((_DWORD *)v51 + 4))
        {
          int v52 = (uint64_t *)v51;
          uint64_t v53 = (void *)sub_244D55D38();
          if (!v53) {
            goto LABEL_112;
          }
          uint64_t v54 = v53;
          *uint64_t v53 = sub_244D44844(*v52);
          size_t v55 = sub_244D44844(*v52);
          v54[1] = v55;
          if (!*v54 || !v55 || !sub_244D4BA04(v38, (uint64_t)v54))
          {
            sub_244D55D44((uint64_t)v54);
LABEL_112:
            uint64_t v40 = 0;
            goto LABEL_114;
          }
        }
        ++v50;
      }
      while (v50 < sub_244D259E0(*(void *)v17));
    }
    sub_244D4BC3C((uint64_t)v38, (uint64_t)sub_244D4EC68);
    sub_244D4BAAC((uint64_t)v38, (uint64_t (*)(void, void, void))sub_244D4EC7C);
    size_t v56 = sub_244D4E820();
    uint64_t v40 = v56;
    if (!v56) {
      goto LABEL_114;
    }
    *((_DWORD *)v56 + 2) = *(_DWORD *)(v17 + 8);
    if (!sub_244D259E0((uint64_t)v38))
    {
LABEL_110:
      sub_244D4BAAC(*v40, (uint64_t (*)(void, void, void))sub_244D4EBAC);
      int v39 = v89;
      goto LABEL_116;
    }
    unint64_t v57 = 0;
    uint64_t v58 = 0;
    while (2)
    {
      uint64_t v59 = (uint64_t *)sub_244D4B518(v38, v57);
      uint64_t v60 = v59;
      if (!*(_DWORD *)(v17 + 8) && !sub_244D4E99C((unint64_t **)v17, *v59))
      {
LABEL_109:
        if (++v57 >= sub_244D259E0((uint64_t)v38)) {
          goto LABEL_110;
        }
        continue;
      }
      break;
    }
    if (v58 && !sub_244D44948(*v58, v60[1])
      || (uint64_t v58 = sub_244D4EA04(v60[1])) != 0 && sub_244D4BA04((unint64_t *)*v40, (uint64_t)v58))
    {
      if (!sub_244D4BA04((unint64_t *)v58[1], *v60)) {
        goto LABEL_114;
      }
      uint64_t *v60 = 0;
      goto LABEL_109;
    }
    sub_244D4EA68(v58);
LABEL_114:
    uint64_t v41 = v38;
    int v39 = v89;
LABEL_115:
    sub_244D4E8A8((unint64_t **)v40);
    uint64_t v40 = 0;
    uint64_t v38 = v41;
LABEL_116:
    sub_244D4B564(v38, (void (*)(uint64_t))sub_244D4ECAC, (uint64_t)sub_244D55D44);
    sub_244D4B564(v39, (void (*)(uint64_t))sub_244D4EBE8, (uint64_t)sub_244D4EA68);
    if (!v40)
    {
      uint64_t v17 = 0;
      unsigned int v16 = v92;
      goto LABEL_145;
    }
    uint64_t v17 = (uint64_t)v40;
    unsigned int v16 = v92;
    if ((v93 & 0x20) == 0)
    {
LABEL_118:
      if (v97) {
        --v97;
      }
      if (v95) {
        --v95;
      }
      if (v96) {
        --v96;
      }
      uint64_t v17 = (uint64_t)v40;
    }
    int v98 = 0;
    long long v61 = (uint64_t *)sub_244D5A248((uint64_t)v18, 401, &v98, 0);
    uint64_t v62 = v61;
    if (!v61 && v98 != -1) {
      goto LABEL_145;
    }
    if (!v61) {
      goto LABEL_132;
    }
    uint64_t v63 = *v61;
    if (!*v62 && !v62[1])
    {
      sub_244D0B884(11, 0, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/policy.c", 548);
LABEL_155:
      sub_244D55ACC((uint64_t)v62);
LABEL_145:
      uint64_t v68 = 0;
      *unint64_t v91 = v18;
      uint64_t v10 = 42;
      goto LABEL_146;
    }
    if (!sub_244D4ECB8(v63, &v97)) {
      goto LABEL_155;
    }
    int v64 = sub_244D4ECB8(v62[1], &v95);
    sub_244D55ACC((uint64_t)v62);
    if (!v64) {
      goto LABEL_145;
    }
LABEL_132:
    uint64_t v65 = sub_244D5A248((uint64_t)v18, 748, &v98, 0);
    uint64_t v66 = v65;
    if (!v65 && v98 != -1) {
      goto LABEL_145;
    }
    int v67 = sub_244D4ECB8(v65, &v96);
    sub_244CF7CBC(v66);
    if (!v67) {
      goto LABEL_145;
    }
    --v9;
  }
  while (v9 < v11);
  if (v97)
  {
    uint64_t v10 = 0;
    uint64_t v68 = 0;
    goto LABEL_146;
  }
  if (!v90)
  {
    uint64_t v68 = 0;
    goto LABEL_159;
  }
  BOOL v70 = sub_244D4BA28(v90);
  uint64_t v68 = v70;
  if (!v70) {
    goto LABEL_140;
  }
  sub_244D4BC3C((uint64_t)v70, (uint64_t)sub_244D4E89C);
  sub_244D4BAAC((uint64_t)v68, (uint64_t (*)(void, void, void))sub_244D4ED4C);
LABEL_159:
  unint64_t v71 = sub_244D259E0((uint64_t)v16);
  unint64_t v72 = v71 - 1;
  uint64_t v73 = sub_244D4B518(v16, v71 - 1);
  BOOL v74 = v73;
  if (!*((_DWORD *)v73 + 2) && !sub_244D259E0(*v73)) {
    goto LABEL_157;
  }
  uint64_t v75 = sub_244D259E0((uint64_t)v68);
  if (sub_244D259E0((uint64_t)v68))
  {
    unint64_t v76 = 0;
    while (1)
    {
      uint64_t v77 = (unsigned __int16 *)sub_244D4B518(v68, v76);
      if (sub_244D449A4(v77) == 746) {
        break;
      }
      if (++v76 >= sub_244D259E0((uint64_t)v68)) {
        goto LABEL_165;
      }
    }
LABEL_167:
    uint64_t v10 = 0;
    goto LABEL_146;
  }
LABEL_165:
  if (!v75 || *((_DWORD *)v74 + 2)) {
    goto LABEL_167;
  }
  if (sub_244D259E0(*v74))
  {
    unint64_t v78 = 0;
    do
      *((_DWORD *)sub_244D4B518((unint64_t *)*v74, v78++) + 5) = 1;
    while (v78 < sub_244D259E0(*v74));
  }
  if (!v71)
  {
LABEL_157:
    uint64_t v10 = 43;
    goto LABEL_146;
  }
  unint64_t v94 = v71;
  do
  {
    unint64_t v79 = sub_244D4B518(v16, v72);
    if (sub_244D259E0(*v79))
    {
      unint64_t v80 = 0;
      unint64_t v81 = v72 - 1;
      while (1)
      {
        unsigned long long v82 = sub_244D4B518((unint64_t *)*v79, v80);
        if (*((_DWORD *)v82 + 5))
        {
          uint64_t v83 = v82;
          if (sub_244D259E0(v82[1]))
          {
            if (v72)
            {
              uint64_t v84 = sub_244D4B518(v92, v72 - 1);
              if (sub_244D259E0(v83[1]))
              {
                unint64_t v85 = 0;
                do
                {
                  unint64_t v86 = sub_244D4B518((unint64_t *)v83[1], v85);
                  unint64_t v87 = sub_244D4E99C((unint64_t **)v84, (uint64_t)v86);
                  if (v87) {
                    *((_DWORD *)v87 + 5) = 1;
                  }
                  ++v85;
                }
                while (v85 < sub_244D259E0(v83[1]));
              }
            }
          }
          else if (sub_244D4B860((uint64_t)v68, 0, *v83, (uint64_t (*)(void, uint64_t, void))sub_244D4ED4C))
          {
            uint64_t v10 = 0;
            unsigned int v16 = v92;
            goto LABEL_146;
          }
        }
        if (++v80 >= sub_244D259E0(*v79))
        {
          unsigned int v16 = v92;
          unint64_t v71 = v94;
          goto LABEL_188;
        }
      }
    }
    unint64_t v81 = v72 - 1;
LABEL_188:
    uint64_t v10 = 43;
    unint64_t v72 = v81;
  }
  while (v81 < v71);
LABEL_146:
  sub_244D4E8A8((unint64_t **)v17);
  sub_244CF474C((uint64_t)v68);
  sub_244D4B564(v16, (void (*)(uint64_t))sub_244D4ED7C, (uint64_t)sub_244D4E8A8);
  return v10;
}

void *sub_244D4E820()
{
  unsigned int v0 = sub_244D44058(0x10uLL);
  if (v0)
  {
    int v1 = sub_244D4B468((uint64_t)sub_244D4E90C);
    void *v0 = v1;
    if (!v1)
    {
      sub_244D4B564(0, (void (*)(uint64_t))sub_244D4EBE8, (uint64_t)sub_244D4EA68);
      sub_244D440EC(v0);
      return 0;
    }
  }
  return v0;
}

uint64_t sub_244D4E89C(uint64_t *a1, uint64_t *a2)
{
  return sub_244D44948(*a1, *a2);
}

void sub_244D4E8A8(unint64_t **a1)
{
  if (a1)
  {
    sub_244D4B564(*a1, (void (*)(uint64_t))sub_244D4EBE8, (uint64_t)sub_244D4EA68);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D4E90C(uint64_t **a1, uint64_t **a2)
{
  return sub_244D44948(**a1, **a2);
}

uint64_t sub_244D4E920(uint64_t **a1, uint64_t **a2)
{
  return sub_244D44948(**a1, **a2);
}

uint64_t sub_244D4E934(void *a1, uint64_t a2)
{
  v4[0] = *a1;
  v4[1] = 0;
  if (sub_244D4B860(a2, 0, (uint64_t)v4, (uint64_t (*)(void, uint64_t, void))sub_244D4EB6C)) {
    return 0;
  }
  sub_244D4EA68(a1);
  return 1;
}

unint64_t *sub_244D4E99C(unint64_t **a1, uint64_t a2)
{
  v5[1] = 0;
  _OWORD v5[2] = 0;
  unint64_t v4 = 0;
  v5[0] = a2;
  if (sub_244D4B860((uint64_t)*a1, &v4, (uint64_t)v5, (uint64_t (*)(void, uint64_t, void))sub_244D4EBAC))return sub_244D4B518(*a1, v4); {
  else
  }
    return 0;
}

void *sub_244D4EA04(uint64_t a1)
{
  unsigned int v2 = sub_244D44058(0x18uLL);
  if (v2)
  {
    void *v2 = sub_244D44844(a1);
    int v3 = sub_244D4B4C8();
    v2[1] = v3;
    if (*v2) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      sub_244D4EA68(v2);
      return 0;
    }
  }
  return v2;
}

void sub_244D4EA68(void *a1)
{
  if (a1)
  {
    sub_244CF29AC((void **)*a1);
    sub_244D4B564((unint64_t *)a1[1], (void (*)(uint64_t))sub_244D4EBDC, (uint64_t)sub_244CF29AC);
    sub_244D440EC(a1);
  }
}

unint64_t *sub_244D4EAD4(unint64_t **a1, unint64_t *a2)
{
  if (sub_244D259E0((uint64_t)a2))
  {
    unint64_t v4 = 0;
    while (1)
    {
      unint64_t v5 = sub_244D4B518(a2, v4);
      uint64_t result = sub_244D4BA04(*a1, (uint64_t)v5);
      if (!result) {
        break;
      }
      sub_244D4B53C(a2, v4++, 0);
      if (v4 >= sub_244D259E0((uint64_t)a2)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    sub_244D4BAAC((uint64_t)*a1, (uint64_t (*)(void, void, void))sub_244D4EBAC);
    return (unint64_t *)1;
  }
  return result;
}

uint64_t sub_244D4EB6C(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D4EB9C(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t sub_244D4EBAC(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D4EBDC(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D4EBE8(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D4EBF4(uint64_t **a1, uint64_t **a2)
{
  return sub_244D44948(**a1, **a2);
}

uint64_t sub_244D4EC08(void *a1, uint64_t a2)
{
  v4[0] = *a1;
  v4[1] = 0;
  uint64_t result = sub_244D4B860(a2, 0, (uint64_t)v4, (uint64_t (*)(void, uint64_t, void))sub_244D4EC7C);
  if (result)
  {
    sub_244D4EA68(a1);
    return 1;
  }
  return result;
}

uint64_t sub_244D4EC68(uint64_t a1, uint64_t a2)
{
  return sub_244D44948(*(void *)(*(void *)a1 + 8), *(void *)(*(void *)a2 + 8));
}

uint64_t sub_244D4EC7C(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D4ECAC(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D4ECB8(uint64_t a1, unint64_t *a2)
{
  if (!a1) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 5))
  {
    sub_244D0B884(11, 0, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/policy.c", 517);
    return 0;
  }
  else
  {
    unint64_t v4 = 0;
    if (sub_244CF1BEC(&v4, a1))
    {
      if (v4 < *a2) {
        *a2 = v4;
      }
    }
    sub_244D0B1B0();
    return 1;
  }
}

uint64_t sub_244D4ED4C(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D4ED7C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D4ED88(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A7440);
}

uint64_t sub_244D4ED94(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A7440);
}

uint64_t sub_244D4EDA0()
{
  return sub_244CF7888((uint64_t)&unk_2651A7440);
}

void sub_244D4EDAC(uint64_t a1)
{
}

uint64_t sub_244D4EDB8(uint64_t a1, uint64_t a2)
{
  unint64_t v12 = 0;
  unint64_t v13 = 0;
  int v11 = 0;
  if (!sub_244D0C818(*(uint64_t **)(a1 + 16))
    || !sub_244D118A0(*(uint64_t **)(a1 + 16))
    || !sub_244D11810(*(uint64_t **)(a1 + 16)))
  {
    return 0;
  }
  if (sub_244CF48D8(v13) - 672 >= 3)
  {
    __int16 v4 = 208;
    goto LABEL_8;
  }
  if (v11 != sub_244CF48E0((uint64_t)v13))
  {
    __int16 v4 = 215;
LABEL_8:
    sub_244D0B884(11, 0, 112, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/rsa_pss.c", v4);
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v7 = (uint64_t *)sub_244CF7888((uint64_t)&unk_2651A7440);
  if (v7
    && (unint64_t v8 = sub_244CF7CD8(), (v7[2] = (uint64_t)v8) != 0)
    && sub_244CF1A64((uint64_t)v8, v11)
    && sub_244D4EF4C(v7, v13)
    && sub_244D4EFA0(v7 + 1, v12)
    && sub_244CF4924((uint64_t)v7, (uint64_t)&unk_2651A7440, &v10)
    && (unint64_t v9 = sub_244D44ED0(0x390u), sub_244D5FD7C(a2, (uint64_t)v9, 16, v10)))
  {
    uint64_t v10 = 0;
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v5 = 0;
  }
  sub_244CF746C((uint64_t)v7, (uint64_t)&unk_2651A7440);
  sub_244CF474C(v10);
  return v5;
}

uint64_t sub_244D4EF4C(uint64_t *a1, unsigned int *a2)
{
  uint64_t result = sub_244D5FD54();
  *a1 = result;
  if (result)
  {
    if (sub_244D5FE78(result, a2))
    {
      return 1;
    }
    else
    {
      sub_244D5FD60(*a1);
      uint64_t result = 0;
      *a1 = 0;
    }
  }
  return result;
}

BOOL sub_244D4EFA0(uint64_t *a1, unsigned int *a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  int v3 = sub_244D4EF4C(&v10, a2);
  uint64_t v4 = v10;
  if (v3)
  {
    if (sub_244CF4924(v10, (uint64_t)&unk_2651A8520, &v9))
    {
      uint64_t v5 = sub_244D5FD54();
      *a1 = v5;
      if (v5)
      {
        uint64_t v6 = v5;
        uint64_t v7 = sub_244D44ED0(0x38Fu);
        if (sub_244D5FD7C(v6, (uint64_t)v7, 16, v9)) {
          uint64_t v9 = 0;
        }
      }
    }
  }
  sub_244CF474C(v9);
  sub_244D5FD60(v4);
  return *a1 != 0;
}

BOOL sub_244D4F04C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_244D4F238(a2);
  uint64_t v6 = v5;
  if (!v5)
  {
    __int16 v11 = 264;
LABEL_23:
    sub_244D0B884(11, 0, 112, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/rsa_pss.c", v11);
LABEL_24:
    BOOL v14 = 0;
    goto LABEL_25;
  }
  uint64_t v7 = *(void *)(v5 + 8);
  if (!v7)
  {
    __int16 v12 = 184;
LABEL_8:
    sub_244D0B884(11, 0, 112, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/rsa_pss.c", v12);
    uint64_t v10 = 0;
    goto LABEL_9;
  }
  unint64_t v8 = (uint64_t *)sub_244D4F5AC(v7);
  if (!v8)
  {
    __int16 v12 = 190;
    goto LABEL_8;
  }
  uint64_t v9 = (uint64_t)v8;
  uint64_t v10 = sub_244D4F294(v8);
  sub_244D5FD60(v9);
LABEL_9:
  unint64_t v13 = sub_244D4F294(*(uint64_t **)v6);
  BOOL v14 = 0;
  if (v10 && v13)
  {
    if (v10 != v13)
    {
      __int16 v11 = 276;
      goto LABEL_23;
    }
    uint64_t v20 = 0;
    uint64_t v15 = *(void *)(v6 + 16);
    if (!v15 || !sub_244CF1BEC(&v20, v15) || (uint64_t v16 = v20, v16 != sub_244CF48E0((uint64_t)v10)))
    {
      __int16 v11 = 286;
      goto LABEL_23;
    }
    uint64_t v17 = *(void *)(v6 + 24);
    if (v17 && sub_244CF1D00(v17) != 1)
    {
      __int16 v11 = 295;
      goto LABEL_23;
    }
    int v19 = 0;
    if (!sub_244D26044(a1, &v19, (uint64_t)v10, 0, a3)
      || !sub_244D117C8(v19)
      || !sub_244D117F8(v19))
    {
      goto LABEL_24;
    }
    BOOL v14 = sub_244D11888(v19) != 0;
  }
LABEL_25:
  sub_244CF746C(v6, (uint64_t)&unk_2651A7440);
  return v14;
}

uint64_t sub_244D4F238(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1 || *(_DWORD *)v1 != 16) {
    return 0;
  }
  unsigned int v2 = *(int **)(v1 + 8);
  uint64_t v4 = *((void *)v2 + 1);
  return sub_244CF5200(0, &v4, *v2, (uint64_t)&unk_2651A7440);
}

unsigned int *sub_244D4F294(uint64_t *a1)
{
  if (!a1)
  {
    __int16 v3 = 170;
    goto LABEL_6;
  }
  uint64_t v1 = (unsigned int *)sub_244D06ED4(*a1);
  if (!v1 || (unsigned int v2 = v1, sub_244CF48D8(v1) - 672 >= 3))
  {
    __int16 v3 = 175;
LABEL_6:
    sub_244D0B884(11, 0, 112, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/rsa_pss.c", v3);
    return 0;
  }
  return v2;
}

BOOL sub_244D4F300(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = sub_244D4F238(a2);
  if (v5)
  {
    if ((int)sub_244CF8634(a1, "\n") >= 1
      && sub_244CF8A00(a1, a3, 0x80u)
      && (int)sub_244CF8634(a1, "Hash Algorithm: ") >= 1)
    {
      int v6 = *(void *)v5 ? sub_244CF2628(a1, **(void **)v5) : sub_244CF8634(a1, "sha1 (default)");
      if (v6 >= 1
        && (int)sub_244CF8634(a1, "\n") >= 1
        && sub_244CF8A00(a1, a3, 0x80u)
        && (int)sub_244CF8634(a1, "Mask Algorithm: ") >= 1)
      {
        uint64_t v9 = *(void *)(v5 + 8);
        if (v9)
        {
          uint64_t v7 = (uint64_t *)sub_244D4F5AC(v9);
          if (v7)
          {
            if ((int)sub_244CF2628(a1, **(void **)(v5 + 8)) < 1 || (int)sub_244CF8634(a1, " with ") < 1) {
              goto LABEL_36;
            }
            int v10 = sub_244CF2628(a1, *v7);
          }
          else
          {
            int v10 = sub_244CF8634(a1, "INVALID");
          }
        }
        else
        {
          int v10 = sub_244CF8634(a1, "mgf1 with sha1 (default)");
          uint64_t v7 = 0;
        }
        if (v10 >= 1)
        {
          sub_244CF8634(a1, "\n");
          if (sub_244CF8A00(a1, a3, 0x80u))
          {
            if ((int)sub_244CF8634(a1, "Salt Length: 0x") >= 1)
            {
              __int16 v12 = *(int **)(v5 + 16);
              int v13 = v12 ? sub_244CF4A88(a1, v12) : sub_244CF8634(a1, "14 (default)");
              if (v13 >= 1)
              {
                sub_244CF8634(a1, "\n");
                if (sub_244CF8A00(a1, a3, 0x80u))
                {
                  if ((int)sub_244CF8634(a1, "Trailer Field: 0x") >= 1)
                  {
                    BOOL v14 = *(int **)(v5 + 24);
                    int v15 = v14 ? sub_244CF4A88(a1, v14) : sub_244CF8634(a1, "BC (default)");
                    if (v15 >= 1)
                    {
                      sub_244CF8634(a1, "\n");
                      BOOL v8 = 1;
                      goto LABEL_19;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_36:
        BOOL v8 = 0;
        goto LABEL_19;
      }
    }
    BOOL v8 = 0;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    BOOL v8 = (int)sub_244CF8634(a1, " (INVALID PSS PARAMETERS)\n") > 0;
  }
LABEL_19:
  sub_244CF746C(v5, (uint64_t)&unk_2651A7440);
  sub_244D5FD60((uint64_t)v7);
  return v8;
}

uint64_t sub_244D4F5AC(uint64_t a1)
{
  if (sub_244D449A4(*(unsigned __int16 **)a1) != 911) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2 || *(_DWORD *)v2 != 16) {
    return 0;
  }
  __int16 v3 = *(int **)(v2 + 8);
  uint64_t v5 = *((void *)v3 + 1);
  return sub_244D5FD3C(0, &v5, *v3);
}

uint64_t sub_244D4F61C(int a1, uint64_t a2)
{
  if (a1 == 2) {
    sub_244D5FD60(*(void *)(*(void *)a2 + 32));
  }
  return 1;
}

uint64_t sub_244D4F64C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = sub_244CF90D4();
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    uint64_t v9 = sub_244D4F6D0((uint64_t)v7, a2, a3, a4);
    sub_244CF830C(v8);
    return v9;
  }
  else
  {
    sub_244D0B884(11, 0, 7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/t_x509.c", 75);
    return 0;
  }
}

uint64_t sub_244D4F6D0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a3 & 0xF0000) == 0x40000) {
    int v8 = 12;
  }
  else {
    int v8 = 0;
  }
  if ((a3 & 0xF0000) == 0x40000) {
    uint64_t v9 = 10;
  }
  else {
    uint64_t v9 = 32;
  }
  if (a3) {
    int v10 = v8;
  }
  else {
    int v10 = 16;
  }
  __int16 v11 = *(uint64_t **)a2;
  if ((a4 & 1) == 0
    && ((int)sub_244CF8524(a1, (uint64_t)"Certificate:\n", 13) < 1
     || (int)sub_244CF8524(a1, (uint64_t)"    Data:\n", 10) < 1))
  {
    return 0;
  }
  if ((a4 & 2) == 0)
  {
    uint64_t v12 = sub_244D5BB04((uint64_t **)a2);
    if ((int)sub_244CF98F4(a1, "%8sVersion: %ld (0x%lx)\n", "", v12 + 1, v12) < 1) {
      return 0;
    }
  }
  if ((a4 & 4) == 0)
  {
    if ((int)sub_244CF8524(a1, (uint64_t)"        Serial Number:", 22) < 1) {
      return 0;
    }
    int v13 = (int *)sub_244D59E10(a2);
    uint64_t v24 = 0;
    if (sub_244CF1BEC(&v24, (uint64_t)v13))
    {
      if ((int)sub_244CF98F4(a1, " %llu (0x%llx)\n", v24, v24) < 1) {
        return 0;
      }
    }
    else
    {
      sub_244D0B1B0();
      if (v13[1] == 258) {
        uint64_t v20 = " (Negative)";
      }
      else {
        uint64_t v20 = "";
      }
      if ((int)sub_244CF98F4(a1, "\n%12s%s", "", v20) < 1) {
        return 0;
      }
      uint64_t v21 = 0;
      while (v21 < *v13)
      {
        int v22 = *(unsigned __int8 *)(*((void *)v13 + 1) + v21++);
        if (v21 == *v13) {
          uint64_t v23 = 10;
        }
        else {
          uint64_t v23 = 58;
        }
        if ((int)sub_244CF98F4(a1, "%02x%c", v22, v23) <= 0) {
          return 0;
        }
      }
    }
  }
  if ((a4 & 8) == 0 && sub_244D4FBE0(a1, (uint64_t *)v11[2], 0) < 1) {
    return 0;
  }
  if ((a4 & 0x10) == 0)
  {
    if ((int)sub_244CF98F4(a1, "        Issuer:%c", v9) < 1) {
      return 0;
    }
    BOOL v14 = (uint64_t *)sub_244D59CE8(a2);
    if ((sub_244D4D7B8(a1, v14, v10, a3) & 0x80000000) != 0 || (int)sub_244CF8524(a1, (uint64_t)"\n", 1) < 1) {
      return 0;
    }
  }
  if ((a4 & 0x20) == 0)
  {
    if ((int)sub_244CF8524(a1, (uint64_t)"        Validity\n", 17) < 1
      || (int)sub_244CF8524(a1, (uint64_t)"            Not Before: ", 24) < 1)
    {
      return 0;
    }
    int v15 = (int *)sub_244D5BD18(a2);
    uint64_t result = sub_244CF30C8(a1, v15);
    if (!result) {
      return result;
    }
    if ((int)sub_244CF8524(a1, (uint64_t)"\n            Not After : ", 25) < 1) {
      return 0;
    }
    uint64_t v17 = (int *)sub_244D5BDAC(a2);
    uint64_t result = sub_244CF30C8(a1, v17);
    if (!result) {
      return result;
    }
    if ((int)sub_244CF8524(a1, (uint64_t)"\n", 1) < 1) {
      return 0;
    }
  }
  if ((a4 & 0x40) == 0)
  {
    if ((int)sub_244CF98F4(a1, "        Subject:%c", v9) < 1) {
      return 0;
    }
    int v18 = (uint64_t *)sub_244D59E04(a2);
    if ((sub_244D4D7B8(a1, v18, v10, a3) & 0x80000000) != 0 || (int)sub_244CF8524(a1, (uint64_t)"\n", 1) < 1) {
      return 0;
    }
  }
  if ((a4 & 0x80) == 0)
  {
    if ((int)sub_244CF8524(a1, (uint64_t)"        Subject Public Key Info:\n", 33) < 1
      || (int)sub_244CF98F4(a1, "%12sPublic Key Algorithm: ", "") < 1
      || (int)sub_244CF2628(a1, **(void **)v11[6]) < 1
      || (int)sub_244CF8634(a1, "\n") < 1)
    {
      return 0;
    }
    uint64_t v19 = sub_244D59FF8(a2);
    if (v19)
    {
      sub_244D12A2C(a1, v19, 16);
    }
    else
    {
      sub_244CF98F4(a1, "%12sUnable to load Public Key\n", "");
      sub_244CF8A64(a1);
    }
  }
  if ((a4 & 0x1000) != 0) {
    goto LABEL_63;
  }
  if (v11[7])
  {
    if ((int)sub_244CF98F4(a1, "%8sIssuer Unique ID: ", "") < 1) {
      return 0;
    }
    uint64_t result = sub_244D59604(a1, (unsigned int *)v11[7], 0xCu);
    if (!result) {
      return result;
    }
  }
  if (!v11[8]) {
    goto LABEL_63;
  }
  if ((int)sub_244CF98F4(a1, "%8sSubject Unique ID: ", "") < 1) {
    return 0;
  }
  uint64_t result = sub_244D59604(a1, (unsigned int *)v11[8], 0xCu);
  if (!result) {
    return result;
  }
LABEL_63:
  if ((a4 & 0x100) == 0) {
    sub_244D5615C(a1, "X509v3 extensions", (unint64_t *)v11[9], a4, 8);
  }
  if ((a4 & 0x200) == 0 && sub_244D4FBE0(a1, *(uint64_t **)(a2 + 8), *(unsigned int **)(a2 + 16)) < 1) {
    return 0;
  }
  if ((a4 & 0x400) != 0) {
    return 1;
  }
  uint64_t result = sub_244D4FDE8(a1, *(void *)(a2 + 136), 0);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t sub_244D4FBC8(uint64_t a1, uint64_t a2)
{
  return sub_244D4F64C(a1, a2, 0, 0);
}

uint64_t sub_244D4FBD4(uint64_t a1, uint64_t a2)
{
  return sub_244D4F6D0(a1, a2, 0, 0);
}

BOOL sub_244D4FBE0(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  if ((int)sub_244CF8634(a1, "    Signature Algorithm: ") < 1 || (int)sub_244CF2628(a1, *a2) < 1) {
    return 0;
  }
  if (sub_244D449A4((unsigned __int16 *)*a2) != 912 || (BOOL result = sub_244D4F300(a1, (uint64_t)a2, 9u)))
  {
    if (a3)
    {
      return sub_244D59604(a1, a3, 9u);
    }
    else
    {
      return (int)sub_244CF8634(a1, "\n") > 0;
    }
  }
  return result;
}

uint64_t sub_244D4FCB0(uint64_t a1, uint64_t *a2)
{
  __int16 v3 = sub_244D5B0D4(a2, 0, 0);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  if (!*v3)
  {
LABEL_16:
    uint64_t v10 = 1;
    goto LABEL_19;
  }
  uint64_t v5 = (uint64_t)(v3 + 1);
  int v6 = v3 + 2;
  int v7 = v3 + 1;
  while (1)
  {
    int v8 = *(v6 - 1);
    if (!*(v6 - 1)) {
      break;
    }
    if (v8 == 47)
    {
      if (*v6 - 65 > 0x19 || (int v9 = v6[1], v9 != 61) && ((v9 - 65) > 0x19 || v6[2] != 61))
      {
        int v8 = 47;
        goto LABEL_15;
      }
      break;
    }
LABEL_15:
    ++v6;
    ++v7;
    if (!v8) {
      goto LABEL_16;
    }
  }
  if (v7 - v5 == sub_244CF8524(a1, v5, v7 - (int)v5))
  {
    if (!*(v6 - 1)) {
      goto LABEL_16;
    }
    if (sub_244CF8524(a1, (uint64_t)", ", 2) == 2)
    {
      int v8 = *(v6 - 1);
      uint64_t v5 = (uint64_t)v6;
      goto LABEL_15;
    }
  }
  sub_244D0B884(11, 0, 7, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/t_x509.c", 325);
  uint64_t v10 = 0;
LABEL_19:
  sub_244D440EC(v4);
  return v10;
}

uint64_t sub_244D4FDE8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a2)
  {
    if (*(void *)a2)
    {
      sub_244CF98F4(a1, "%*sTrusted Uses:\n%*s", a3, "", a3 + 2, "");
      if (sub_244D259E0(*(void *)a2))
      {
        unint64_t v6 = 0;
        char v7 = 0;
        do
        {
          if (v7) {
            sub_244CF8634(a1, ", ");
          }
          int v8 = sub_244D4B518(*(unint64_t **)a2, v6);
          sub_244D45104(__s, 80, (uint64_t)v8, 0);
          sub_244CF8634(a1, __s);
          ++v6;
          unint64_t v9 = sub_244D259E0(*(void *)a2);
          char v7 = 1;
        }
        while (v6 < v9);
      }
      sub_244CF8634(a1, "\n");
    }
    else
    {
      sub_244CF98F4(a1, "%*sNo Trusted Uses.\n", a3, "");
    }
    if (*(void *)(a2 + 8))
    {
      sub_244CF98F4(a1, "%*sRejected Uses:\n%*s", a3, "", a3 + 2, "");
      if (sub_244D259E0(*(void *)(a2 + 8)))
      {
        unint64_t v10 = 0;
        char v11 = 0;
        do
        {
          if (v11) {
            sub_244CF8634(a1, ", ");
          }
          uint64_t v12 = sub_244D4B518(*(unint64_t **)(a2 + 8), v10);
          sub_244D45104(__s, 80, (uint64_t)v12, 0);
          sub_244CF8634(a1, __s);
          ++v10;
          unint64_t v13 = sub_244D259E0(*(void *)(a2 + 8));
          char v11 = 1;
        }
        while (v10 < v13);
      }
      sub_244CF8634(a1, "\n");
    }
    else
    {
      sub_244CF98F4(a1, "%*sNo Rejected Uses.\n", a3, "");
    }
    uint64_t v14 = *(void *)(a2 + 16);
    if (v14) {
      sub_244CF98F4(a1, "%*sAlias: %.*s\n", a3, "", *(_DWORD *)v14, *(const char **)(v14 + 8));
    }
    if (*(void *)(a2 + 24))
    {
      sub_244CF98F4(a1, "%*sKey Id: ", a3, "");
      int v15 = *(int **)(a2 + 24);
      if (*v15 >= 1)
      {
        uint64_t v16 = 0;
        do
        {
          if (v16) {
            uint64_t v17 = ":";
          }
          else {
            uint64_t v17 = "";
          }
          sub_244CF98F4(a1, "%s%02X", v17, *(unsigned __int8 *)(*((void *)v15 + 1) + v16++));
          int v15 = *(int **)(a2 + 24);
        }
        while (v16 < *v15);
      }
      sub_244CF8524(a1, (uint64_t)"\n", 1);
    }
  }
  return 1;
}

unint64_t *sub_244D5009C(uint64_t a1, int **a2, unint64_t *a3)
{
  uint64_t v12 = a3;
  if (!*a2) {
    goto LABEL_4;
  }
  uint64_t v5 = (char *)sub_244D57DB0(*((void *)*a2 + 1), **a2);
  if (!v5)
  {
    sub_244D440EC(0);
    goto LABEL_11;
  }
  unint64_t v6 = v5;
  int v7 = sub_244D572A4("keyid", v5, &v12);
  sub_244D440EC(v6);
  if (v7)
  {
LABEL_4:
    int v8 = (unint64_t *)a2[1];
    if (v8)
    {
      unint64_t v9 = sub_244D50848(0, v8, v12);
      if (!v9) {
        goto LABEL_11;
      }
      uint64_t v12 = v9;
    }
    unint64_t v10 = (unsigned __int8 **)a2[2];
    if (!v10 || sub_244D577F0("serial", v10, &v12)) {
      return v12;
    }
  }
LABEL_11:
  if (!a3) {
    sub_244D4B564(v12, (void (*)(uint64_t))sub_244D5049C, (uint64_t)sub_244D57450);
  }
  return 0;
}

uint64_t sub_244D50188(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  if (sub_244D259E0((uint64_t)a3))
  {
    unint64_t v4 = 0;
    char v5 = 0;
    char v6 = 0;
    while (1)
    {
      int v7 = sub_244D4B518(a3, v4);
      int v8 = (const char *)v7[1];
      if (!strcmp(v8, "keyid"))
      {
        unint64_t v10 = (const char *)v7[2];
        if (v10)
        {
          if (!strcmp(v10, "always")) {
            char v6 = 2;
          }
          else {
            char v6 = 1;
          }
        }
        else
        {
          char v6 = 1;
        }
      }
      else
      {
        if (strcmp(v8, "issuer"))
        {
          sub_244D0B884(20, 0, 159, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_akey.c", 160);
          sub_244D0B930(2u, v15, v16, v17, v18, v19, v20, v21, (uint64_t)"name=");
          return 0;
        }
        unint64_t v9 = (const char *)v7[2];
        if (v9)
        {
          if (!strcmp(v9, "always")) {
            char v5 = 2;
          }
          else {
            char v5 = 1;
          }
        }
        else
        {
          char v5 = 1;
        }
      }
      if (++v4 >= sub_244D259E0((uint64_t)a3)) {
        goto LABEL_18;
      }
    }
  }
  char v6 = 0;
  char v5 = 0;
LABEL_18:
  if (!a2) {
    goto LABEL_29;
  }
  uint64_t v11 = *(void *)(a2 + 8);
  if (v11)
  {
    if (v6)
    {
      unsigned int v12 = sub_244D5A1E4(*(void *)(a2 + 8), 0x52u, -1);
      if ((v12 & 0x80000000) != 0 || (unint64_t v13 = sub_244D5A208(v11, v12)) == 0) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = sub_244D549EC((uint64_t)v13);
      }
      if (v6 == 2 && !v14)
      {
        int v23 = 155;
        __int16 v24 = 183;
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    BOOL v25 = v5 != 0;
    if (v14) {
      BOOL v25 = 0;
    }
    if (v5 == 2 || v25)
    {
      uint64_t v30 = sub_244D59CE8(v11);
      uint64_t v29 = sub_244D61FA4(v30);
      uint64_t v31 = sub_244D59E10(v11);
      uint64_t v32 = sub_244CF1628(v31);
      uint64_t v27 = v32;
      if (v29 && v32)
      {
        uint64_t v33 = sub_244D504C0();
        if (v33)
        {
          int v26 = (void *)v33;
          unint64_t v34 = sub_244D4B4C8();
          if (v34)
          {
            int v28 = v34;
            uint64_t v35 = sub_244D53F94();
            if (v35)
            {
              uint64_t v36 = v35;
              if (sub_244D4BA04(v28, v35))
              {
                *(_DWORD *)uint64_t v36 = 4;
                *(void *)(v36 + 8) = v29;
                goto LABEL_41;
              }
            }
          }
        }
      }
      else
      {
        sub_244D0B884(20, 0, 154, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_akey.c", 192);
      }
    }
    else
    {
      int v26 = (void *)sub_244D504C0();
      uint64_t v27 = 0;
      int v28 = 0;
      uint64_t v29 = 0;
      if (v26)
      {
LABEL_41:
        v26[1] = v28;
        void v26[2] = v27;
        *int v26 = v14;
        return (uint64_t)v26;
      }
    }
    sub_244D61F98(v29);
    sub_244CF7CBC(v27);
    sub_244CF7CBC(v14);
    return 0;
  }
  if (*(_DWORD *)a2 != 1)
  {
LABEL_29:
    int v23 = 140;
    __int16 v24 = 170;
LABEL_30:
    sub_244D0B884(20, 0, v23, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_akey.c", v24);
    return 0;
  }

  return sub_244D504C0();
}

uint64_t sub_244D5049C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D504A8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A74D0);
}

uint64_t sub_244D504B4(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A74D0);
}

uint64_t sub_244D504C0()
{
  return sub_244CF7888((uint64_t)&unk_2651A74D0);
}

void sub_244D504CC(uint64_t a1)
{
}

unint64_t *sub_244D504DC(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  char v5 = sub_244D4B4C8();
  if (!v5 || !sub_244D259E0((uint64_t)a3)) {
    return v5;
  }
  unint64_t v6 = 0;
  while (1)
  {
    int v7 = sub_244D4B518(a3, v6);
    if (sub_244D57FD4((const char *)v7[1], "email"))
    {
      int v8 = (const char *)v7[2];
      if (v8)
      {
        if (!strcmp(v8, "copy"))
        {
          uint64_t v12 = a2;
          unint64_t v13 = v5;
          int v14 = 0;
          goto LABEL_15;
        }
      }
    }
    if (!sub_244D57FD4((const char *)v7[1], "email")) {
      break;
    }
    unint64_t v10 = (const char *)v7[2];
    if (!v10 || strcmp(v10, "move")) {
      break;
    }
    uint64_t v12 = a2;
    unint64_t v13 = v5;
    int v14 = 1;
LABEL_15:
    if (!sub_244D51250(v12, v13, v14)) {
      goto LABEL_19;
    }
LABEL_16:
    if (++v6 >= sub_244D259E0((uint64_t)a3)) {
      return v5;
    }
  }
  uint64_t v11 = sub_244D50E48(0, v9, a2, (uint64_t)v7, 0);
  if (v11 && sub_244D4BA04(v5, v11)) {
    goto LABEL_16;
  }
  sub_244D53FA0(v11);
LABEL_19:
  sub_244D4B564(v5, (void (*)(uint64_t))sub_244D51388, (uint64_t)sub_244D53FA0);
  return 0;
}

unint64_t *sub_244D50648(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  char v5 = sub_244D4B4C8();
  if (!v5 || !sub_244D259E0((uint64_t)a3)) {
    return v5;
  }
  unint64_t v6 = 0;
  while (1)
  {
    int v7 = sub_244D4B518(a3, v6);
    if (!sub_244D57FD4((const char *)v7[1], "issuer") || (uint64_t v9 = (const char *)v7[2]) == 0 || strcmp(v9, "copy"))
    {
      uint64_t v10 = sub_244D50E48(0, v8, a2, (uint64_t)v7, 0);
      if (!v10 || !sub_244D4BA04(v5, v10))
      {
        sub_244D53FA0(v10);
        goto LABEL_26;
      }
      goto LABEL_9;
    }
    if (!a2) {
      goto LABEL_23;
    }
    if (*(_DWORD *)a2 != 1)
    {
      uint64_t v11 = *(void *)(a2 + 8);
      if (!v11)
      {
LABEL_23:
        sub_244D0B884(20, 0, 141, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", 305);
        goto LABEL_26;
      }
      unsigned int v12 = sub_244D5A1E4(v11, 0x55u, -1);
      if ((v12 & 0x80000000) == 0) {
        break;
      }
    }
LABEL_9:
    if (++v6 >= sub_244D259E0((uint64_t)a3)) {
      return v5;
    }
  }
  unint64_t v13 = sub_244D5A208(*(void *)(a2 + 8), v12);
  if (!v13 || (uint64_t v14 = sub_244D549EC((uint64_t)v13)) == 0)
  {
    sub_244D0B884(20, 0, 136, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", 318);
    uint64_t v15 = 0;
    goto LABEL_25;
  }
  uint64_t v15 = (unint64_t *)v14;
  if (!sub_244D259E0(v14))
  {
LABEL_21:
    sub_244D53FD0((uint64_t)v15);
    goto LABEL_9;
  }
  unint64_t v16 = 0;
  while (1)
  {
    uint64_t v17 = sub_244D4B518(v15, v16);
    if (!sub_244D4BA04(v5, (uint64_t)v17)) {
      break;
    }
    sub_244D4B53C(v15, v16++, 0);
    if (v16 >= sub_244D259E0((uint64_t)v15)) {
      goto LABEL_21;
    }
  }
LABEL_25:
  sub_244D53FD0((uint64_t)v15);
LABEL_26:
  sub_244D4B564(v5, (void (*)(uint64_t))sub_244D51388, (uint64_t)sub_244D53FA0);
  return 0;
}

unint64_t *sub_244D50848(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  if (sub_244D259E0((uint64_t)a2))
  {
    unint64_t v5 = 0;
    unint64_t v6 = a3;
    while (1)
    {
      int v7 = sub_244D4B518(a2, v5);
      uint64_t v8 = sub_244D50920((uint64_t)v7, (uint64_t)v7, v6);
      if (!((unint64_t)a3 | (unint64_t)v8)) {
        break;
      }
      unint64_t v6 = v8;
      if (v8)
      {
        if (++v5 < sub_244D259E0((uint64_t)a2)) {
          continue;
        }
      }
      return v6;
    }
    sub_244D4B564(v6, (void (*)(uint64_t))sub_244D51244, (uint64_t)sub_244D57450);
    return 0;
  }
  unint64_t v6 = a3;
  if (a3) {
    return v6;
  }

  return sub_244D4B4C8();
}

unint64_t *sub_244D50920(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v13 = a3;
  switch(*(_DWORD *)a2)
  {
    case 0:
      __int16 v3 = "othername";
      goto LABEL_9;
    case 1:
      unint64_t v4 = *(int **)(a2 + 8);
      unint64_t v5 = "email";
      goto LABEL_11;
    case 2:
      unint64_t v4 = *(int **)(a2 + 8);
      unint64_t v5 = "DNS";
      goto LABEL_11;
    case 3:
      __int16 v3 = "X400Name";
      goto LABEL_9;
    case 4:
      BOOL result = (unint64_t *)sub_244D5B0D4(*(uint64_t **)(a2 + 8), __str, 256);
      if (!result) {
        return result;
      }
      __int16 v3 = "DirName";
      goto LABEL_20;
    case 5:
      __int16 v3 = "EdiPartyName";
LABEL_9:
      int v7 = "<unsupported>";
      goto LABEL_21;
    case 6:
      unint64_t v4 = *(int **)(a2 + 8);
      unint64_t v5 = "URI";
LABEL_11:
      if (!sub_244D57438(v5, v4, &v13)) {
        return 0;
      }
      return v13;
    case 7:
      uint64_t v8 = *(int **)(a2 + 8);
      uint64_t v9 = (unsigned __int8 *)*((void *)v8 + 1);
      int v10 = *v8;
      if (v10 == 16)
      {
        __str[0] = 0;
        snprintf(v12, 5uLL, "%X", __rev16(*(unsigned __int16 *)v9));
        sub_244D447E4(__str, v12, 0x100uLL);
        uint64_t v11 = 0;
        do
        {
          sub_244D447E4(__str, ":", 0x100uLL);
          snprintf(v12, 5uLL, "%X", __rev16(*(unsigned __int16 *)&v9[v11 + 2]));
          sub_244D447E4(__str, v12, 0x100uLL);
          v11 += 2;
        }
        while (v11 != 14);
      }
      else
      {
        if (v10 != 4)
        {
          __int16 v3 = "IP Address";
          int v7 = "<invalid>";
          goto LABEL_21;
        }
        snprintf(__str, 0x100uLL, "%d.%d.%d.%d", *v9, v9[1], v9[2], v9[3]);
      }
      __int16 v3 = "IP Address";
LABEL_20:
      int v7 = __str;
LABEL_21:
      if (sub_244D572A4(v3, v7, &v13)) {
        return v13;
      }
      else {
        return 0;
      }
    case 8:
      sub_244CF2620(__str, 256, *(void *)(a2 + 8));
      __int16 v3 = "Registered ID";
      goto LABEL_20;
    default:
      return v13;
  }
}

uint64_t sub_244D50B88(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      sub_244CF98F4(a1, "othername:<unsupported>");
      return 1;
    case 1:
      sub_244CF98F4(a1, "email:");
      goto LABEL_9;
    case 2:
      sub_244CF98F4(a1, "DNS:");
      goto LABEL_9;
    case 3:
      sub_244CF98F4(a1, "X400Name:<unsupported>");
      return 1;
    case 4:
      sub_244CF98F4(a1, "DirName: ");
      sub_244D4D7B8(a1, *(uint64_t **)(a2 + 8), 0, 8520479);
      return 1;
    case 5:
      sub_244CF98F4(a1, "EdiPartyName:<unsupported>");
      return 1;
    case 6:
      sub_244CF98F4(a1, "URI:");
LABEL_9:
      sub_244CF2F9C(a1, *(void *)(a2 + 8));
      break;
    case 7:
      unint64_t v4 = *(int **)(a2 + 8);
      uint64_t v5 = *((void *)v4 + 1);
      int v6 = *v4;
      if (v6 == 16)
      {
        sub_244CF98F4(a1, "IP Address");
        uint64_t v7 = 0;
        do
        {
          sub_244CF98F4(a1, ":%X", __rev16(*(unsigned __int16 *)(v5 + v7)));
          v7 += 2;
        }
        while (v7 != 16);
        sub_244CF8634(a1, "\n");
      }
      else if (v6 == 4)
      {
        sub_244CF98F4(a1, "IP Address:%d.%d.%d.%d");
      }
      else
      {
        sub_244CF98F4(a1, "IP Address:<invalid>");
      }
      break;
    case 8:
      sub_244CF98F4(a1, "Registered ID");
      sub_244CF2628(a1, *(void *)(a2 + 8));
      break;
    default:
      return 1;
  }
  return 1;
}

unint64_t *sub_244D50D5C(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5 = sub_244D4B4C8();
  if (v5 && sub_244D259E0((uint64_t)a3))
  {
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = sub_244D4B518(a3, v6);
      uint64_t v9 = sub_244D50E48(0, v8, a2, (uint64_t)v7, 0);
      if (!v9 || !sub_244D4BA04(v5, v9)) {
        break;
      }
      if (++v6 >= sub_244D259E0((uint64_t)a3)) {
        return v5;
      }
    }
    sub_244D53FA0(v9);
    sub_244D4B564(v5, (void (*)(uint64_t))sub_244D51388, (uint64_t)sub_244D53FA0);
    return 0;
  }
  return v5;
}

uint64_t sub_244D50E34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_244D50E48(0, a2, a2, a3, 0);
}

uint64_t sub_244D50E48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = *(char **)(a4 + 16);
  if (!v5)
  {
    sub_244D0B884(20, 0, 137, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", 542);
    return 0;
  }
  uint64_t v9 = *(const char **)(a4 + 8);
  if (!sub_244D57FD4(v9, "email"))
  {
    if (sub_244D57FD4(v9, "URI"))
    {
      int v10 = 6;
      goto LABEL_17;
    }
    if (sub_244D57FD4(v9, "DNS"))
    {
      int v10 = 2;
      goto LABEL_17;
    }
    if (sub_244D57FD4(v9, "RID"))
    {
      int v10 = 8;
      goto LABEL_17;
    }
    if (sub_244D57FD4(v9, "IP"))
    {
      int v10 = 7;
      goto LABEL_17;
    }
    if (sub_244D57FD4(v9, "dirName"))
    {
      int v10 = 4;
      goto LABEL_17;
    }
    if (sub_244D57FD4(v9, "otherName"))
    {
      int v10 = 0;
      goto LABEL_17;
    }
    sub_244D0B884(20, 0, 160, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", 562);
    sub_244D0B930(2u, v43, v44, v45, v46, v47, v48, v49, (uint64_t)"name=");
    return 0;
  }
  int v10 = 1;
LABEL_17:
  uint64_t v11 = a1;
  if (a1 || (uint64_t v11 = sub_244D53F94()) != 0)
  {
    switch(v10)
    {
      case 0:
        uint64_t v14 = strchr(v5, 59);
        if (v14)
        {
          uint64_t v15 = v14;
          uint64_t v16 = sub_244D53F4C();
          if (v16)
          {
            uint64_t v17 = v16;
            uint64_t v18 = (char *)sub_244D446C4(v5, v15 - v5);
            if (v18)
            {
              uint64_t v19 = v18;
              sub_244CF29AC(*(void ***)v17);
              *(void *)uint64_t v17 = sub_244D44DDC(v19, 0);
              sub_244D440EC(v19);
              if (*(void *)v17)
              {
                sub_244CF7EB4(*(void *)(v17 + 8));
                uint64_t v20 = sub_244D4C878(v15 + 1, a3);
                *(void *)(v17 + 8) = v20;
                if (v20)
                {
                  *(_DWORD *)uint64_t v11 = 0;
                  goto LABEL_35;
                }
              }
            }
            sub_244D53F58(v17);
          }
        }
        int v21 = 148;
        __int16 v22 = 517;
        goto LABEL_49;
      case 1:
      case 2:
      case 6:
        unsigned int v12 = sub_244CF7D98();
        if (v12)
        {
          size_t v13 = strlen(v5);
          if (sub_244CF45A0((uint64_t)v12, v5, v13))
          {
            *(_DWORD *)uint64_t v11 = v10;
            *(void *)(v11 + 8) = v12;
            return v11;
          }
        }
        sub_244CF474C((uint64_t)v12);
        goto LABEL_50;
      case 4:
        uint64_t v17 = sub_244D61F8C();
        if (!v17) {
          goto LABEL_48;
        }
        int v23 = (unint64_t *)sub_244D520D8(a3, (uint64_t)v5);
        if (v23)
        {
          if (sub_244D58D0C(v17, v23, 4097))
          {
            *(_DWORD *)uint64_t v11 = 4;
LABEL_35:
            *(void *)(v11 + 8) = v17;
            return v11;
          }
        }
        else
        {
          sub_244D0B884(20, 0, 153, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", 617);
          sub_244D0B930(2u, v35, v36, v37, v38, v39, v40, v41, (uint64_t)"section=");
        }
LABEL_48:
        sub_244D61F98(v17);
        int v21 = 105;
        __int16 v22 = 510;
LABEL_49:
        sub_244D0B884(20, 0, v21, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", v22);
        goto LABEL_50;
      case 7:
        *(_DWORD *)uint64_t v11 = 7;
        if (a5) {
          uint64_t v24 = sub_244D58B34(v5);
        }
        else {
          uint64_t v24 = sub_244D58AA0(v5);
        }
        *(void *)(v11 + 8) = v24;
        if (v24) {
          return v11;
        }
        int v26 = 100;
        __int16 v27 = 502;
        goto LABEL_44;
      case 8:
        BOOL v25 = sub_244D44DDC(v5, 0);
        if (v25)
        {
          *(_DWORD *)uint64_t v11 = 8;
          *(void *)(v11 + 8) = v25;
          return v11;
        }
        int v26 = 101;
        __int16 v27 = 485;
LABEL_44:
        sub_244D0B884(20, 0, v26, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", v27);
        sub_244D0B930(2u, v28, v29, v30, v31, v32, v33, v34, (uint64_t)"value=");
LABEL_50:
        if (!a1) {
          sub_244D53FA0(v11);
        }
        break;
      default:
        int v21 = 161;
        __int16 v22 = 522;
        goto LABEL_49;
    }
    return 0;
  }
  return v11;
}

uint64_t sub_244D51244(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D51250(uint64_t a1, unint64_t *a2, int a3)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == 1) {
      return 1;
    }
    if (*(void *)(a1 + 16))
    {
      uint64_t v6 = sub_244D59E04(*(void *)(a1 + 16));
      goto LABEL_8;
    }
    uint64_t v7 = *(void *)(a1 + 24);
    if (v7)
    {
      uint64_t v6 = sub_244D5B484(v7);
LABEL_8:
      uint64_t v8 = (uint64_t *)v6;
      unsigned int v9 = -1;
      while (1)
      {
        unsigned int v10 = sub_244D5F568(v8, 0x30u, v9);
        if ((v10 & 0x80000000) != 0) {
          return 1;
        }
        unsigned int v9 = v10;
        uint64_t v11 = sub_244D5F4E0(v8, v10);
        unsigned int v12 = (int *)sub_244C9DDF8((uint64_t)v11);
        size_t v13 = sub_244CF4698(v12);
        if (a3)
        {
          sub_244D5F5C4((uint64_t)v8, v9);
          sub_244D61F58((uint64_t)v11);
          --v9;
        }
        if (!v13) {
          goto LABEL_17;
        }
        uint64_t v14 = sub_244D53F94();
        uint64_t v15 = v14;
        if (!v14) {
          goto LABEL_18;
        }
        *(void *)(v14 + 8) = v13;
        *(_DWORD *)uint64_t v14 = 1;
        if (!sub_244D4BA04(a2, v14))
        {
          size_t v13 = 0;
          goto LABEL_18;
        }
      }
    }
  }
  sub_244D0B884(20, 0, 145, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_alt.c", 383);
  size_t v13 = 0;
LABEL_17:
  uint64_t v15 = 0;
LABEL_18:
  sub_244D53FA0(v15);
  sub_244CF7CBC((uint64_t)v13);
  return 0;
}

uint64_t sub_244D51388(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

unint64_t *sub_244D51394(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5 = a3;
  sub_244D574A4("CA", *(_DWORD *)a2, &v5);
  sub_244D577F0("pathlen", *(unsigned __int8 ***)(a2 + 8), &v5);
  return v5;
}

uint64_t sub_244D513EC(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v4 = sub_244CF7888((uint64_t)&unk_2651A7500);
  if (!v4 || !sub_244D259E0((uint64_t)a3)) {
    return v4;
  }
  unint64_t v5 = 0;
  while (1)
  {
    uint64_t v6 = sub_244D4B518(a3, v5);
    uint64_t v7 = (const char *)v6[1];
    if (strcmp(v7, "CA")) {
      break;
    }
    if (!sub_244D579A8((uint64_t)v6, (_DWORD *)v4)) {
      goto LABEL_12;
    }
LABEL_9:
    if (++v5 >= sub_244D259E0((uint64_t)a3)) {
      return v4;
    }
  }
  if (!strcmp(v7, "pathlen"))
  {
    if (!sub_244D57A3C((uint64_t)v6, (uint64_t *)(v4 + 8))) {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
  sub_244D0B884(20, 0, 123, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_bcons.c", 126);
  sub_244D0B930(6u, v8, v9, v10, v11, v12, v13, v14, (uint64_t)"section:");
LABEL_12:
  sub_244CF746C(v4, (uint64_t)&unk_2651A7500);
  return 0;
}

uint64_t sub_244D5153C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A7500);
}

uint64_t sub_244D51548(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A7500);
}

uint64_t sub_244D51554()
{
  return sub_244CF7888((uint64_t)&unk_2651A7500);
}

void sub_244D51560(uint64_t a1)
{
}

unint64_t *sub_244D5156C(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v7 = a3;
  uint64_t v3 = *(void *)(a1 + 96);
  if (*(void *)(v3 + 8))
  {
    do
    {
      if (sub_244CF10B8(a2, *(_DWORD *)v3)) {
        sub_244D572A4(*(const char **)(v3 + 8), 0, &v7);
      }
      uint64_t v5 = *(void *)(v3 + 32);
      v3 += 24;
    }
    while (v5);
    return v7;
  }
  return a3;
}

void *sub_244D515D8(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5 = sub_244CF7D18();
  if (v5 && sub_244D259E0((uint64_t)a3))
  {
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = sub_244D4B518(a3, v6);
      uint64_t v8 = *(void *)(a1 + 96);
      uint64_t v9 = *(const char **)(v8 + 8);
      if (!v9) {
        break;
      }
      uint64_t v10 = (const char *)v7[1];
      uint64_t v11 = (const char **)(v8 + 16);
      while (strcmp(*v11, v10) && strcmp(v9, v10))
      {
        uint64_t v9 = v11[2];
        v11 += 3;
        if (!v9) {
          goto LABEL_14;
        }
      }
      if (!sub_244CF0F9C((uint64_t)v5, *((_DWORD *)v11 - 4), 1)) {
        goto LABEL_15;
      }
      if (!*(v11 - 1)) {
        break;
      }
      if (++v6 >= sub_244D259E0((uint64_t)a3)) {
        return v5;
      }
    }
LABEL_14:
    sub_244D0B884(20, 0, 156, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_bitst.c", 123);
    sub_244D0B930(6u, v12, v13, v14, v15, v16, v17, v18, (uint64_t)"section:");
LABEL_15:
    sub_244CF7CBC((uint64_t)v5);
    return 0;
  }
  return v5;
}

uint64_t sub_244D51720(uint64_t a1, long long *a2, const char *a3, const char *a4)
{
  uint64_t v5 = a2;
  int v21 = (char *)a4;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  if (!a2)
  {
    long long v18 = 0uLL;
    long long v19 = 0uLL;
    uint64_t v5 = &v18;
    *(void *)&long long v20 = 0;
    *((void *)&v20 + 1) = a1;
  }
  int v7 = sub_244D51838((const char **)&v21);
  int v8 = sub_244D518A4((const char **)&v21);
  if (v8) {
    return sub_244D51954(a3, v21, v7, v8, (uint64_t)v5);
  }
  unsigned int v10 = sub_244D44B24(a3);
  uint64_t result = sub_244D51B10(a1, (uint64_t)v5, v10, v7, v21);
  if (!result)
  {
    sub_244D0B884(20, 0, 110, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 102);
    sub_244D0B930(4u, v11, v12, v13, v14, v15, v16, v17, (uint64_t)"name=");
    return 0;
  }
  return result;
}

double sub_244D5181C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(_DWORD *)a1 = a6;
  return result;
}

uint64_t sub_244D51838(const char **a1)
{
  uint64_t v2 = *a1;
  if (strlen(*a1) < 9 || strncmp(v2, "critical,", 9uLL)) {
    return 0;
  }
  uint64_t v4 = v2 + 8;
  do
    int v5 = *(unsigned __int8 *)++v4;
  while (sub_244D44410(v5));
  *a1 = v4;
  return 1;
}

uint64_t sub_244D518A4(const char **a1)
{
  uint64_t v2 = *a1;
  size_t v3 = strlen(*a1);
  if (v3 < 4) {
    return 0;
  }
  unint64_t v4 = v3;
  uint64_t v5 = 4;
  if (!strncmp(v2, "DER:", 4uLL))
  {
    uint64_t v6 = 1;
  }
  else
  {
    if (v4 < 5) {
      return 0;
    }
    uint64_t v5 = 5;
    if (strncmp(v2, "ASN1:", 5uLL)) {
      return 0;
    }
    uint64_t v6 = 2;
  }
  uint64_t v7 = (uint64_t)&v2[v5 - 1];
  do
    int v8 = *(unsigned __int8 *)++v7;
  while (sub_244D44410(v8));
  *a1 = (const char *)v7;
  return v6;
}

uint64_t sub_244D51954(const char *a1, char *a2, int a3, int a4, uint64_t a5)
{
  unint64_t v26 = 0;
  uint64_t v9 = sub_244D44DDC(a1, 0);
  if (!v9)
  {
    sub_244D0B884(20, 0, 113, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 275);
    long long v18 = "name=";
LABEL_15:
    sub_244D0B930(2u, v11, v12, v13, v14, v15, v16, v17, (uint64_t)v18);
    unsigned int v10 = 0;
    goto LABEL_16;
  }
  if (a4 == 2)
  {
    uint64_t v19 = sub_244D4C878(a2, a5);
    if (!v19) {
      goto LABEL_14;
    }
    uint64_t v20 = v19;
    __int16 v27 = 0;
    unsigned int v21 = sub_244CF7E9C(v19, (void **)&v27);
    sub_244CF7EB4(v20);
    if ((v21 & 0x80000000) != 0) {
      goto LABEL_14;
    }
    unint64_t v26 = v21;
    unsigned int v10 = v27;
    if (!v27) {
      goto LABEL_14;
    }
  }
  else if (a4 != 1 || (unsigned int v10 = sub_244D57EA0(a2, &v26)) == 0)
  {
LABEL_14:
    sub_244D0B884(20, 0, 116, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 287);
    long long v18 = "value=";
    goto LABEL_15;
  }
  if (v26 >> 31)
  {
    sub_244D0B884(20, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 293);
LABEL_16:
    uint64_t v23 = 0;
    goto LABEL_17;
  }
  __int16 v22 = sub_244CF7CB4();
  uint64_t v23 = (uint64_t)v22;
  if (!v22)
  {
LABEL_17:
    uint64_t v24 = 0;
    goto LABEL_18;
  }
  sub_244CF4790((uint64_t)v22, (uint64_t)v10, v26);
  uint64_t v24 = sub_244D5C4A4(0, (uint64_t)v9, a3, v23);
  unsigned int v10 = 0;
LABEL_18:
  sub_244CF29AC((void **)v9);
  sub_244CF7CBC(v23);
  sub_244D440EC(v10);
  return v24;
}

uint64_t sub_244D51B10(uint64_t a1, uint64_t a2, unsigned int a3, int a4, const char *a5)
{
  if (!a3)
  {
    int v14 = 158;
    __int16 v15 = 137;
    goto LABEL_10;
  }
  unsigned int v10 = sub_244D547CC(a3);
  if (!v10)
  {
    int v14 = 157;
    __int16 v15 = 141;
    goto LABEL_10;
  }
  uint64_t v11 = (uint64_t)v10;
  if (v10[9])
  {
    if (*a5 != 64)
    {
      uint64_t v12 = (uint64_t)sub_244D57ACC(a5);
      uint64_t v13 = (unint64_t *)v12;
      if (!v12) {
        goto LABEL_19;
      }
      goto LABEL_16;
    }
    if (a1)
    {
      uint64_t v12 = sub_244CFECA0(a1, (uint64_t)(a5 + 1));
      uint64_t v13 = 0;
      if (!v12) {
        goto LABEL_19;
      }
LABEL_16:
      if (sub_244D259E0(v12))
      {
        uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11 + 72))(v11, a2, v12);
        sub_244D4B564(v13, (void (*)(uint64_t))sub_244D5212C, (uint64_t)sub_244D57450);
        if (v18) {
          goto LABEL_18;
        }
        return 0;
      }
LABEL_19:
      sub_244D0B884(20, 0, 121, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 160);
      sub_244D44FD4(a3);
      sub_244D0B930(4u, v20, v21, v22, v23, v24, v25, v26, (uint64_t)"name=");
      sub_244D4B564(v13, (void (*)(uint64_t))sub_244D5212C, (uint64_t)sub_244D57450);
      return 0;
    }
    int v14 = 139;
    __int16 v15 = 151;
LABEL_10:
    sub_244D0B884(20, 0, v14, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", v15);
    return 0;
  }
  uint64_t v17 = (uint64_t (*)(unint64_t *, uint64_t, const char *))v10[7];
  if (!v17)
  {
    uint64_t v17 = (uint64_t (*)(unint64_t *, uint64_t, const char *))v10[11];
    if (!v17)
    {
      sub_244D0B884(20, 0, 115, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 187);
      sub_244D44FD4(a3);
      sub_244D0B930(2u, v27, v28, v29, v30, v31, v32, v33, (uint64_t)"name=");
      return 0;
    }
    if (!*(void *)(a2 + 40))
    {
      int v14 = 139;
      __int16 v15 = 180;
      goto LABEL_10;
    }
  }
  uint64_t v18 = v17(v10, a2, a5);
  if (!v18) {
    return 0;
  }
LABEL_18:
  uint64_t v19 = sub_244D51EC4(v11, a3, a4, v18);
  sub_244CF746C(v18, *(void *)(v11 + 8));
  return v19;
}

uint64_t sub_244D51D8C(uint64_t a1, long long *a2, unsigned int a3, const char *a4)
{
  uint64_t v5 = a2;
  __int16 v15 = (char *)a4;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  if (!a2)
  {
    long long v12 = 0uLL;
    long long v13 = 0uLL;
    uint64_t v5 = &v12;
    *(void *)&long long v14 = 0;
    *((void *)&v14 + 1) = a1;
  }
  int v7 = sub_244D51838((const char **)&v15);
  int v8 = sub_244D518A4((const char **)&v15);
  if (!v8) {
    return sub_244D51B10(a1, (uint64_t)v5, a3, v7, v15);
  }
  int v9 = v8;
  unsigned int v10 = sub_244D44FD4(a3);
  return sub_244D51954((const char *)v10, v15, v7, v9, (uint64_t)v5);
}

uint64_t sub_244D51E40(unsigned int a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_244D547CC(a1);
  if (v6)
  {
    return sub_244D51EC4((uint64_t)v6, a1, a2, a3);
  }
  else
  {
    sub_244D0B884(20, 0, 157, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 224);
    return 0;
  }
}

uint64_t sub_244D51EC4(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  long long v12 = 0;
  int v6 = sub_244CF6668(a4, &v12, *(void *)(a1 + 8));
  if (v6 < 0) {
    return 0;
  }
  int v7 = v6;
  int v8 = sub_244CF7CB4();
  if (!v8)
  {
    sub_244D440EC(v12);
    return 0;
  }
  uint64_t v9 = (uint64_t)v8;
  sub_244CF4790((uint64_t)v8, (uint64_t)v12, v7);
  uint64_t v10 = sub_244D5C41C(0, a2, a3, v9);
  sub_244CF7CBC(v9);
  return v10;
}

uint64_t sub_244D51F60(uint64_t a1, long long *a2, uint64_t a3, unint64_t **a4)
{
  uint64_t result = sub_244CFECA0(a1, a3);
  if (result)
  {
    int v8 = (unint64_t *)result;
    if (sub_244D259E0(result))
    {
      unint64_t v9 = 0;
      while (1)
      {
        uint64_t v10 = sub_244D4B518(v8, v9);
        uint64_t v11 = sub_244D51720(a1, a2, (const char *)v10[1], (const char *)v10[2]);
        if (!v11) {
          break;
        }
        uint64_t v12 = v11;
        if (a4)
        {
          long long v13 = sub_244D5C338(a4, v11, -1);
          sub_244D61F18(v12);
          if (!v13) {
            return 0;
          }
        }
        else
        {
          sub_244D61F18(v11);
        }
        if (++v9 >= sub_244D259E0((uint64_t)v8)) {
          return 1;
        }
      }
      sub_244D61F18(0);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D52034(uint64_t a1, long long *a2, uint64_t a3, unint64_t **a4)
{
  if (a4) {
    a4 = (unint64_t **)(*a4 + 9);
  }
  return sub_244D51F60(a1, a2, a3, a4);
}

uint64_t sub_244D52044(uint64_t a1, long long *a2, uint64_t a3, unint64_t **a4)
{
  if (a4) {
    a4 = (unint64_t **)(*a4 + 6);
  }
  return sub_244D51F60(a1, a2, a3, a4);
}

uint64_t sub_244D52054(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v9 = 0;
  if (a4) {
    uint64_t v5 = &v9;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = sub_244D51F60(a1, a2, a3, v5);
  uint64_t v7 = v6;
  if (a4 && v6)
  {
    uint64_t v7 = sub_244D5B818(a4, (uint64_t)v9);
    sub_244D4B564(v9, (void (*)(uint64_t))sub_244D52138, (uint64_t)sub_244D61F18);
  }
  return v7;
}

uint64_t sub_244D520D8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    return sub_244CFECA0(v2, a2);
  }
  else
  {
    sub_244D0B884(20, 0, 147, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_conf.c", 398);
    return 0;
  }
}

uint64_t sub_244D5212C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D52138(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D52144(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = (unint64_t *)a2;
  if (sub_244D259E0(a2))
  {
    unint64_t v6 = 0;
    int v7 = a4 + 4;
    uint64_t v22 = (uint64_t)v5;
    do
    {
      unint64_t v24 = v6;
      int v8 = (uint64_t *)sub_244D4B518(v5, v6);
      sub_244CF98F4(a3, "%*sPolicy: ", a4, "");
      sub_244CF2628(a3, *v8);
      sub_244CF8634(a3, "\n");
      unint64_t v9 = (unint64_t *)v8[1];
      if (v9 && sub_244D259E0(v8[1]))
      {
        unint64_t v10 = 0;
        do
        {
          uint64_t v11 = sub_244D4B518(v9, v10);
          unsigned int v12 = sub_244D449A4((unsigned __int16 *)*v11);
          if (v12 == 165)
          {
            sub_244CF98F4(a3, "%*sUser Notice:\n", a4 + 2, "");
            long long v13 = (uint64_t *)v11[1];
            uint64_t v14 = *v13;
            if (*v13)
            {
              sub_244CF98F4(a3, "%*sOrganization: %.*s\n", v7, "", **(_DWORD **)v14, *(const char **)(*(void *)v14 + 8));
              unint64_t v15 = sub_244D259E0(*(void *)(v14 + 8));
              uint64_t v16 = "s";
              if (v15 <= 1) {
                uint64_t v16 = "";
              }
              sub_244CF98F4(a3, "%*sNumber%s: ", v7, "", v16);
              if (sub_244D259E0(*(void *)(v14 + 8)))
              {
                unint64_t v17 = 0;
                do
                {
                  uint64_t v18 = sub_244D4B518(*(unint64_t **)(v14 + 8), v17);
                  if (v17) {
                    sub_244CF8634(a3, ", ");
                  }
                  if (v18)
                  {
                    uint64_t v19 = (char *)sub_244D57610(0, (unsigned __int8 **)v18);
                    if (!v19) {
                      goto LABEL_26;
                    }
                    uint64_t v20 = v19;
                    sub_244CF8634(a3, v19);
                    sub_244D440EC(v20);
                  }
                  else
                  {
                    sub_244CF8634(a3, "(null)");
                  }
                  ++v17;
                }
                while (v17 < sub_244D259E0(*(void *)(v14 + 8)));
              }
              sub_244CF8634(a3, "\n");
            }
            if (v13[1]) {
              sub_244CF98F4(a3, "%*sExplicit Text: %.*s\n");
            }
          }
          else if (v12 == 164)
          {
            sub_244CF98F4(a3, "%*sCPS: %.*s\n");
          }
          else
          {
            sub_244CF98F4(a3, "%*sUnknown Qualifier: ", v7, "");
            sub_244CF2628(a3, *v11);
            sub_244CF8634(a3, "\n");
          }
LABEL_26:
          ++v10;
        }
        while (v10 < sub_244D259E0((uint64_t)v9));
      }
      unint64_t v6 = v24 + 1;
      uint64_t v5 = (unint64_t *)v22;
    }
    while (v24 + 1 < sub_244D259E0(v22));
  }
  return 1;
}

unint64_t *sub_244D52414(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v5 = sub_244D4B4C8();
  if (!v5) {
    return v5;
  }
  unint64_t v6 = sub_244D57ACC(a3);
  int v7 = v6;
  if (!v6)
  {
    sub_244D0B884(20, 0, 20, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", 165);
    goto LABEL_99;
  }
  if (!sub_244D259E0((uint64_t)v6))
  {
LABEL_75:
    sub_244D4B564(v7, (void (*)(uint64_t))sub_244D52CF8, (uint64_t)sub_244D57450);
    return v5;
  }
  unint64_t v8 = 0;
  int v9 = 0;
  while (1)
  {
    unint64_t v10 = sub_244D4B518(v7, v8);
    if (v10[2] || (uint64_t v11 = (const char *)v10[1]) == 0)
    {
      int v52 = 131;
      __int16 v53 = 172;
      goto LABEL_78;
    }
    if (strcmp((const char *)v10[1], "ia5org")) {
      break;
    }
    int v9 = 1;
LABEL_74:
    if (++v8 >= sub_244D259E0((uint64_t)v7)) {
      goto LABEL_75;
    }
  }
  if (*v11 != 64)
  {
    uint64_t v49 = sub_244D44DDC(v11, 0);
    if (v49)
    {
      unint64_t v50 = v49;
      int v51 = (void *)sub_244CF7888((uint64_t)&unk_2651A77C8);
      if (!v51)
      {
        sub_244CF29AC((void **)v50);
        goto LABEL_99;
      }
      uint64_t v14 = (uint64_t)v51;
      *int v51 = v50;
      goto LABEL_73;
    }
    int v52 = 129;
    __int16 v53 = 196;
LABEL_78:
    sub_244D0B884(20, 0, v52, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", v53);
    sub_244D0B930(6u, v54, v55, v56, v57, v58, v59, v60, (uint64_t)"section:");
    goto LABEL_99;
  }
  uint64_t v12 = sub_244D520D8(a2, (uint64_t)(v11 + 1));
  if (!v12)
  {
    int v52 = 134;
    __int16 v53 = 184;
    goto LABEL_78;
  }
  long long v13 = (unint64_t *)v12;
  int v94 = v9;
  uint64_t v14 = sub_244CF7888((uint64_t)&unk_2651A77C8);
  if (!v14) {
    goto LABEL_98;
  }
  if (!sub_244D259E0((uint64_t)v13))
  {
LABEL_71:
    if (!*(void *)v14)
    {
      int v61 = 142;
      __int16 v62 = 292;
LABEL_97:
      sub_244D0B884(20, 0, v61, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", v62);
      goto LABEL_98;
    }
    int v9 = v94;
LABEL_73:
    if (!sub_244D4BA04(v5, v14)) {
      goto LABEL_98;
    }
    goto LABEL_74;
  }
  unint64_t v15 = 0;
  if (v9) {
    int v16 = 22;
  }
  else {
    int v16 = 26;
  }
  int v91 = v16;
  while (1)
  {
    unint64_t v17 = sub_244D4B518(v13, v15);
    uint64_t v18 = (const char *)v17[1];
    if (!strcmp(v18, "policyIdentifier"))
    {
      uint64_t v25 = sub_244D44DDC((const char *)v17[2], 0);
      if (v25)
      {
        *(void *)uint64_t v14 = v25;
        goto LABEL_28;
      }
      int v63 = 129;
      __int16 v64 = 233;
      goto LABEL_93;
    }
    if (!sub_244D57FD4(v18, "CPS")) {
      break;
    }
    if (!*(void *)(v14 + 8)) {
      *(void *)(v14 + 8) = sub_244D4B4C8();
    }
    uint64_t v19 = sub_244CF7888((uint64_t)&unk_2651A7838);
    if (!v19) {
      goto LABEL_98;
    }
    uint64_t v20 = (void *)v19;
    if (!sub_244D4BA04(*(unint64_t **)(v14 + 8), v19)) {
      goto LABEL_98;
    }
    uint64_t v21 = sub_244D44ED0(0xA4u);
    *uint64_t v20 = v21;
    if (!v21)
    {
      int v61 = 68;
      __int16 v62 = 251;
      goto LABEL_97;
    }
    uint64_t v22 = sub_244CF7D98();
    v20[1] = v22;
    if (!v22) {
      goto LABEL_98;
    }
    uint64_t v23 = (uint64_t)v22;
    size_t v24 = strlen((const char *)v17[2]);
    if (!sub_244CF45A0(v23, (char *)v17[2], v24)) {
      goto LABEL_98;
    }
LABEL_28:
    if (++v15 >= sub_244D259E0((uint64_t)v13)) {
      goto LABEL_71;
    }
  }
  if (!sub_244D57FD4((const char *)v17[1], "userNotice"))
  {
    int v63 = 130;
    __int16 v64 = 285;
LABEL_93:
    sub_244D0B884(20, 0, v63, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", v64);
    sub_244D0B930(6u, v72, v73, v74, v75, v76, v77, v78, (uint64_t)"section:");
    goto LABEL_98;
  }
  uint64_t v26 = (unsigned char *)v17[2];
  if (*v26 != 64)
  {
    int v63 = 111;
    __int16 v64 = 263;
    goto LABEL_93;
  }
  uint64_t v27 = sub_244D520D8(a2, (uint64_t)(v26 + 1));
  if (!v27)
  {
    int v63 = 134;
    __int16 v64 = 270;
    goto LABEL_93;
  }
  uint64_t v92 = v27;
  uint64_t v90 = a2;
  char v93 = (void *)sub_244CF7888((uint64_t)&unk_2651A7838);
  if (!v93) {
    goto LABEL_83;
  }
  uint64_t v28 = sub_244D44ED0(0xA5u);
  *char v93 = v28;
  if (v28)
  {
    unint64_t v95 = (uint64_t *)sub_244CF7888((uint64_t)&unk_2651A78A8);
    if (!v95) {
      goto LABEL_83;
    }
    uint64_t v29 = (unint64_t *)v92;
    v93[1] = v95;
    if (sub_244D259E0(v92))
    {
      unint64_t v30 = 0;
      unint64_t v89 = v7;
      while (1)
      {
        uint64_t v31 = sub_244D4B518(v29, v30);
        uint64_t v32 = (const char *)v31[1];
        if (!strcmp(v32, "explicitText")) {
          break;
        }
        if (!strcmp(v32, "organization"))
        {
          uint64_t v44 = *v95;
          if (!*v95)
          {
            uint64_t v44 = sub_244CF7888((uint64_t)&unk_2651A7918);
            if (!v44) {
              goto LABEL_83;
            }
            *unint64_t v95 = v44;
          }
          *(_DWORD *)(*(void *)v44 + 4) = v91;
          uint64_t v43 = *(void *)v44;
LABEL_58:
          uint64_t v45 = (char *)v31[2];
          size_t v46 = strlen(v45);
          if (!sub_244CF45A0(v43, v45, v46)) {
            goto LABEL_83;
          }
          goto LABEL_59;
        }
        if (strcmp(v32, "noticeNumbers"))
        {
          sub_244D0B884(20, 0, 130, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", 373);
          sub_244D0B930(6u, v81, v82, v83, v84, v85, v86, v87, (uint64_t)"section:");
          goto LABEL_83;
        }
        uint64_t v33 = *v95;
        if (!*v95)
        {
          uint64_t v34 = sub_244CF7888((uint64_t)&unk_2651A7918);
          if (!v34) {
            goto LABEL_83;
          }
          uint64_t v33 = v34;
          *unint64_t v95 = v34;
        }
        uint64_t v35 = sub_244D57ACC((const char *)v31[2]);
        uint64_t v36 = v35;
        if (!v35 || !sub_244D259E0((uint64_t)v35))
        {
          sub_244D0B884(20, 0, 128, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", 362);
          sub_244D0B930(6u, v65, v66, v67, v68, v69, v70, v71, (uint64_t)"section:");
LABEL_82:
          sub_244D4B564(v36, (void (*)(uint64_t))sub_244D52CF8, (uint64_t)sub_244D57450);
          goto LABEL_83;
        }
        uint64_t v37 = *(unint64_t **)(v33 + 8);
        if (sub_244D259E0((uint64_t)v36))
        {
          unint64_t v38 = 0;
          while (1)
          {
            uint64_t v39 = sub_244D4B518(v36, v38);
            uint64_t v40 = sub_244D5766C(0, (void *)v39[1]);
            if (!v40)
            {
              sub_244D0B884(20, 0, 127, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", 398);
              goto LABEL_81;
            }
            uint64_t v41 = (uint64_t)v40;
            if (!sub_244D4BA04(v37, (uint64_t)v40)) {
              break;
            }
            if (++v38 >= sub_244D259E0((uint64_t)v36)) {
              goto LABEL_51;
            }
          }
          sub_244CF7CBC(v41);
LABEL_81:
          int v7 = v89;
          goto LABEL_82;
        }
LABEL_51:
        sub_244D4B564(v36, (void (*)(uint64_t))sub_244D52CF8, (uint64_t)sub_244D57450);
        int v7 = v89;
LABEL_59:
        ++v30;
        uint64_t v29 = (unint64_t *)v92;
        if (v30 >= sub_244D259E0(v92)) {
          goto LABEL_60;
        }
      }
      unint64_t v42 = sub_244CF7E18();
      v95[1] = (uint64_t)v42;
      if (!v42) {
        goto LABEL_83;
      }
      uint64_t v43 = (uint64_t)v42;
      goto LABEL_58;
    }
LABEL_60:
    uint64_t v47 = (void *)*v95;
    if (!*v95 || v47[1] && *v47)
    {
      uint64_t v48 = *(unint64_t **)(v14 + 8);
      if (!v48)
      {
        uint64_t v48 = sub_244D4B4C8();
        *(void *)(v14 + 8) = v48;
      }
      a2 = v90;
      if (!sub_244D4BA04(v48, (uint64_t)v93)) {
        goto LABEL_98;
      }
      goto LABEL_28;
    }
    int v79 = 138;
    __int16 v80 = 381;
  }
  else
  {
    int v79 = 68;
    __int16 v80 = 313;
  }
  sub_244D0B884(20, 0, v79, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_cpols.c", v80);
LABEL_83:
  sub_244CF746C((uint64_t)v93, (uint64_t)&unk_2651A7838);
LABEL_98:
  sub_244CF746C(v14, (uint64_t)&unk_2651A77C8);
LABEL_99:
  sub_244D4B564(v7, (void (*)(uint64_t))sub_244D52CF8, (uint64_t)sub_244D57450);
  sub_244D4B564(v5, (void (*)(uint64_t))sub_244D52D04, (uint64_t)sub_244D52CA4);
  return 0;
}

uint64_t sub_244D52C68(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A7738);
}

uint64_t sub_244D52C74(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A7738);
}

uint64_t sub_244D52C80()
{
  return sub_244CF7888((uint64_t)&unk_2651A7738);
}

void sub_244D52C8C(uint64_t a1)
{
}

uint64_t sub_244D52C98()
{
  return sub_244CF7888((uint64_t)&unk_2651A77C8);
}

void sub_244D52CA4(uint64_t a1)
{
}

uint64_t sub_244D52CB0()
{
  return sub_244CF7888((uint64_t)&unk_2651A7838);
}

void sub_244D52CBC(uint64_t a1)
{
}

uint64_t sub_244D52CC8()
{
  return sub_244CF7888((uint64_t)&unk_2651A78A8);
}

void sub_244D52CD4(uint64_t a1)
{
}

uint64_t sub_244D52CE0()
{
  return sub_244CF7888((uint64_t)&unk_2651A7918);
}

void sub_244D52CEC(uint64_t a1)
{
}

uint64_t sub_244D52CF8(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D52D04(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

unint64_t *sub_244D52D10(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v6 = sub_244D4B4C8();
  if (v6)
  {
    if (sub_244D259E0((uint64_t)a3))
    {
      unint64_t v7 = 0;
      unint64_t v8 = &unk_2651A7AF0;
      uint64_t v22 = a1;
      do
      {
        int v9 = sub_244D4B518(a3, v7);
        if (v9[2])
        {
          unint64_t v10 = (void *)sub_244D50E34(a1, a2, (uint64_t)v9);
          if (!v10)
          {
            uint64_t v12 = 0;
            goto LABEL_32;
          }
          uint64_t v11 = (unint64_t *)sub_244D53FC4();
          uint64_t v12 = v11;
          if (!v11) {
            goto LABEL_32;
          }
          if (!sub_244D4BA04(v11, (uint64_t)v10)) {
            goto LABEL_32;
          }
          unint64_t v10 = (void *)sub_244CF7888((uint64_t)v8);
          if (!v10) {
            goto LABEL_32;
          }
          if (!sub_244D4BA04(v6, (uint64_t)v10))
          {
            sub_244CF746C((uint64_t)v10, (uint64_t)&unk_2651A7AF0);
            goto LABEL_31;
          }
          uint64_t v13 = sub_244CF7888((uint64_t)&unk_2651A7A60);
          *unint64_t v10 = v13;
          if (!v13) {
            goto LABEL_31;
          }
          *(void *)(v13 + 8) = v12;
          *(_DWORD *)*unint64_t v10 = 0;
        }
        else
        {
          uint64_t v12 = (unint64_t *)sub_244D520D8(a2, v9[1]);
          if (!v12) {
            goto LABEL_31;
          }
          uint64_t v14 = v8;
          uint64_t v15 = sub_244CF7888((uint64_t)v8);
          if (!v15) {
            goto LABEL_29;
          }
          if (sub_244D259E0((uint64_t)v12))
          {
            unint64_t v16 = 0;
            do
            {
              unint64_t v17 = sub_244D4B518(v12, v16);
              int v18 = sub_244D53574(v15, a2, (uint64_t)v17);
              if (v18 <= 0)
              {
                if (v18 < 0) {
                  goto LABEL_29;
                }
                uint64_t v19 = (const char *)v17[1];
                if (!strcmp(v19, "reasons"))
                {
                  if (!sub_244D537A4((void *)(v15 + 8), (const char *)v17[2])) {
                    goto LABEL_29;
                  }
                }
                else if (!strcmp(v19, "CRLissuer"))
                {
                  sub_244D53FD0(*(void *)(v15 + 16));
                  uint64_t v20 = sub_244D538D4(a2, (const char *)v17[2]);
                  *(void *)(v15 + 16) = v20;
                  if (!v20) {
                    goto LABEL_29;
                  }
                }
              }
            }
            while (++v16 < sub_244D259E0((uint64_t)v12));
          }
          a1 = v22;
          unint64_t v8 = v14;
          if (!sub_244D4BA04(v6, v15))
          {
LABEL_29:
            sub_244CF746C(v15, (uint64_t)&unk_2651A7AF0);
            goto LABEL_30;
          }
        }
        ++v7;
      }
      while (v7 < sub_244D259E0((uint64_t)a3));
    }
  }
  else
  {
LABEL_30:
    uint64_t v12 = 0;
LABEL_31:
    unint64_t v10 = 0;
LABEL_32:
    sub_244D53FA0((uint64_t)v10);
    sub_244D53FD0((uint64_t)v12);
    sub_244D4B564(v6, (void (*)(uint64_t))sub_244D539B0, (uint64_t)sub_244D530D4);
    return 0;
  }
  return v6;
}

uint64_t sub_244D52FA8(uint64_t a1, unint64_t *a2, uint64_t a3, int a4)
{
  if (sub_244D259E0((uint64_t)a2))
  {
    unint64_t v7 = 0;
    do
    {
      sub_244CF8634(a3, "\n");
      unint64_t v8 = sub_244D4B518(a2, v7);
      if (*v8) {
        sub_244D539F8(a3, *v8, a4);
      }
      uint64_t v9 = v8[1];
      if (v9) {
        sub_244D53AE0(a3, "Reasons", v9, a4);
      }
      if (v8[2])
      {
        sub_244CF98F4(a3, "%*sCRL Issuer:\n", a4, "");
        sub_244D53BD8(a3, (unint64_t *)v8[2], a4);
      }
      ++v7;
    }
    while (v7 < sub_244D259E0((uint64_t)a2));
  }
  return 1;
}

uint64_t sub_244D530B0()
{
  return sub_244CF7888((uint64_t)&unk_2651A7A60);
}

void sub_244D530BC(uint64_t a1)
{
}

uint64_t sub_244D530C8()
{
  return sub_244CF7888((uint64_t)&unk_2651A7AF0);
}

void sub_244D530D4(uint64_t a1)
{
}

uint64_t sub_244D530E0(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A79F0);
}

uint64_t sub_244D530EC(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A79F0);
}

uint64_t sub_244D530F8()
{
  return sub_244CF7888((uint64_t)&unk_2651A79F0);
}

void sub_244D53104(uint64_t a1)
{
}

uint64_t sub_244D53110(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A7C00);
}

uint64_t sub_244D5311C(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A7C00);
}

uint64_t sub_244D53128()
{
  return sub_244CF7888((uint64_t)&unk_2651A7C00);
}

void sub_244D53134(uint64_t a1)
{
}

uint64_t sub_244D53140(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5 = sub_244CF7888((uint64_t)&unk_2651A7C00);
  if (v5)
  {
    if (sub_244D259E0((uint64_t)a3))
    {
      for (unint64_t i = 0; i < sub_244D259E0((uint64_t)a3); ++i)
      {
        unint64_t v7 = sub_244D4B518(a3, i);
        uint64_t v9 = (const char *)v7[1];
        unint64_t v8 = (const char *)v7[2];
        int v10 = sub_244D53574(v5, a2, (uint64_t)v7);
        if (v10 <= 0)
        {
          if (v10 < 0) {
            goto LABEL_21;
          }
          if (!strcmp(v9, "onlyuser"))
          {
            uint64_t v11 = (uint64_t)v7;
            uint64_t v12 = (_DWORD *)(v5 + 8);
            goto LABEL_17;
          }
          if (!strcmp(v9, "onlyCA"))
          {
            uint64_t v11 = (uint64_t)v7;
            uint64_t v12 = (_DWORD *)(v5 + 12);
            goto LABEL_17;
          }
          if (!strcmp(v9, "onlyAA"))
          {
            uint64_t v11 = (uint64_t)v7;
            uint64_t v12 = (_DWORD *)(v5 + 28);
            goto LABEL_17;
          }
          if (!strcmp(v9, "indirectCRL"))
          {
            uint64_t v11 = (uint64_t)v7;
            uint64_t v12 = (_DWORD *)(v5 + 24);
LABEL_17:
            if (!sub_244D579A8(v11, v12)) {
              goto LABEL_21;
            }
            continue;
          }
          if (strcmp(v9, "onlysomereasons"))
          {
            sub_244D0B884(20, 0, 123, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_crld.c", 483);
            sub_244D0B930(6u, v13, v14, v15, v16, v17, v18, v19, (uint64_t)"section:");
            goto LABEL_21;
          }
          if (!sub_244D537A4((void *)(v5 + 16), v8)) {
            goto LABEL_21;
          }
        }
      }
    }
  }
  else
  {
LABEL_21:
    sub_244CF746C(v5, (uint64_t)&unk_2651A7C00);
    return 0;
  }
  return v5;
}

uint64_t sub_244D53334(int a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = *(void *)a2;
  if (v7) {
    sub_244D539F8(a3, v7, a4);
  }
  if (*(int *)(a2 + 8) >= 1) {
    sub_244CF98F4(a3, "%*sOnly User Certificates\n", a4, "");
  }
  if (*(int *)(a2 + 12) >= 1) {
    sub_244CF98F4(a3, "%*sOnly CA Certificates\n", a4, "");
  }
  if (*(int *)(a2 + 24) >= 1) {
    sub_244CF98F4(a3, "%*sIndirect CRL\n", a4, "");
  }
  uint64_t v8 = *(void *)(a2 + 16);
  if (v8) {
    sub_244D53AE0(a3, "Only Some Reasons", v8, a4);
  }
  if (*(int *)(a2 + 28) >= 1) {
    sub_244CF98F4(a3, "%*sOnly Attribute Certificates\n", a4, "");
  }
  if (!*(void *)a2
    && *(int *)(a2 + 8) <= 0
    && *(int *)(a2 + 12) <= 0
    && *(int *)(a2 + 24) <= 0
    && !*(void *)(a2 + 16)
    && *(int *)(a2 + 28) <= 0)
  {
    sub_244CF98F4(a3, "%*s<EMPTY>\n", a4, "");
  }
  return 1;
}

uint64_t sub_244D534A8(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 1;
  }
  if (*(_DWORD *)a1 != 1) {
    return 1;
  }
  size_t v3 = *(unint64_t **)(a1 + 8);
  uint64_t result = sub_244D61FA4(a2);
  *(void *)(a1 + 16) = result;
  if (!result) {
    return result;
  }
  if (sub_244D259E0((uint64_t)v3))
  {
    unint64_t v5 = 0;
    do
    {
      unint64_t v6 = sub_244D4B518(v3, v5);
      if (!sub_244D5F7CC(*(void *)(a1 + 16), (uint64_t)v6, -1, v5 == 0)) {
        goto LABEL_11;
      }
    }
    while (++v5 < sub_244D259E0((uint64_t)v3));
  }
  if ((sub_244D61F80(*(void *)(a1 + 16), 0) & 0x80000000) == 0) {
    return 1;
  }
LABEL_11:
  sub_244D61F98(*(void *)(a1 + 16));
  uint64_t result = 0;
  *(void *)(a1 + 16) = 0;
  return result;
}

uint64_t sub_244D53574(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(const char **)(a3 + 8);
  if (!strncmp(v6, "fullname", 9uLL))
  {
    uint64_t v8 = *(const char **)(a3 + 16);
    if (v8)
    {
      uint64_t v9 = sub_244D538D4(a2, v8);
      int v10 = 0;
      uint64_t v11 = 0;
      if (v9) {
        goto LABEL_6;
      }
LABEL_17:
      sub_244D4B564(v11, (void (*)(uint64_t))sub_244D5398C, (uint64_t)sub_244D53FA0);
      sub_244D4B564(v10, (void (*)(uint64_t))sub_244D53998, (uint64_t)sub_244D61F58);
      return 0xFFFFFFFFLL;
    }
    int v19 = 137;
    __int16 v20 = 141;
LABEL_24:
    sub_244D0B884(20, 0, v19, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_crld.c", v20);
    return 0xFFFFFFFFLL;
  }
  if (strcmp(v6, "relativename")) {
    return 0;
  }
  uint64_t v12 = *(void *)(a3 + 16);
  if (!v12)
  {
    int v19 = 137;
    __int16 v20 = 152;
    goto LABEL_24;
  }
  uint64_t v13 = sub_244D520D8(a2, v12);
  if (!v13)
  {
    int v19 = 153;
    __int16 v20 = 157;
    goto LABEL_24;
  }
  uint64_t v14 = (unint64_t *)v13;
  uint64_t v15 = sub_244D61F8C();
  if (!v15) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v16 = (unint64_t **)v15;
  BOOL v17 = sub_244D58D0C(v15, v14, 4097);
  int v10 = *v16;
  *uint64_t v16 = 0;
  sub_244D61F98((uint64_t)v16);
  if (!v17) {
    goto LABEL_16;
  }
  uint64_t v11 = (unint64_t *)sub_244D259E0((uint64_t)v10);
  if (!v11) {
    goto LABEL_17;
  }
  uint64_t v18 = sub_244D259E0((uint64_t)v10);
  if (*((_DWORD *)sub_244D4B518(v10, v18 - 1) + 4))
  {
    sub_244D0B884(20, 0, 122, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_crld.c", 173);
LABEL_16:
    uint64_t v11 = 0;
    goto LABEL_17;
  }
  uint64_t v9 = 0;
LABEL_6:
  if (*(void *)a1)
  {
    sub_244D0B884(20, 0, 106, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_crld.c", 181);
LABEL_8:
    uint64_t v11 = v9;
    goto LABEL_17;
  }
  uint64_t v21 = (_DWORD *)sub_244CF7888((uint64_t)&unk_2651A7A60);
  *(void *)a1 = v21;
  if (!v21) {
    goto LABEL_8;
  }
  uint64_t v22 = v21;
  if (v9)
  {
    *uint64_t v21 = 0;
    *(void *)(*(void *)a1 + 8) = v9;
    return 1;
  }
  else
  {
    uint64_t result = 1;
    *uint64_t v22 = 1;
    *(void *)(*(void *)a1 + 8) = v10;
  }
  return result;
}

uint64_t sub_244D537A4(void *a1, const char *a2)
{
  if (*a1)
  {
    sub_244D0B884(20, 0, 163, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_crld.c", 220);
    return 0;
  }
  unint64_t v4 = sub_244D57ACC(a2);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = v4;
  if (sub_244D259E0((uint64_t)v4))
  {
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = (const char *)sub_244D4B518(v5, v6)[1];
      uint64_t v8 = (void *)*a1;
      if (!*a1)
      {
        uint64_t v8 = sub_244CF7D18();
        *a1 = v8;
        if (!v8) {
          break;
        }
      }
      uint64_t v9 = off_2651A7C50;
      while (strcmp(*(v9 - 2), v7))
      {
        int v10 = *v9;
        v9 += 3;
        if (!v10) {
          goto LABEL_16;
        }
      }
      if (!sub_244CF0F9C((uint64_t)v8, *((_DWORD *)v9 - 8), 1)) {
        break;
      }
      if (++v6 >= sub_244D259E0((uint64_t)v5)) {
        goto LABEL_15;
      }
    }
LABEL_16:
    uint64_t v2 = 0;
  }
  else
  {
LABEL_15:
    uint64_t v2 = 1;
  }
  sub_244D4B564(v5, (void (*)(uint64_t))sub_244D539A4, (uint64_t)sub_244D57450);
  return v2;
}

unint64_t *sub_244D538D4(uint64_t a1, const char *a2)
{
  if (*a2 == 64)
  {
    size_t v3 = (unint64_t *)sub_244D520D8(a1, (uint64_t)(a2 + 1));
    unint64_t v4 = 0;
    if (v3)
    {
LABEL_3:
      unint64_t v5 = sub_244D50D5C(0, a1, v3);
      sub_244D4B564(v4, (void (*)(uint64_t))sub_244D539A4, (uint64_t)sub_244D57450);
      return v5;
    }
  }
  else
  {
    size_t v3 = sub_244D57ACC(a2);
    unint64_t v4 = v3;
    if (v3) {
      goto LABEL_3;
    }
  }
  sub_244D0B884(20, 0, 153, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_crld.c", 121);
  return 0;
}

uint64_t sub_244D5398C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D53998(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D539A4(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D539B0(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D539BC(int a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (a1 == 3)
  {
    sub_244D61F98(*(void *)(v2 + 16));
  }
  else if (a1 == 1)
  {
    *(void *)(v2 + 16) = 0;
  }
  return 1;
}

unint64_t sub_244D539F8(uint64_t a1, uint64_t a2, int a3)
{
  if (*(_DWORD *)a2)
  {
    long long v9 = 0u;
    long long v10 = 0u;
    uint64_t v8 = *(void *)(a2 + 8);
    sub_244CF98F4(a1, "%*sRelative Name:\n%*s", a3, "", a3 + 2, "");
    sub_244D4D7B8(a1, &v8, 0, 8520479);
    return sub_244CF8634(a1, "\n");
  }
  else
  {
    sub_244CF98F4(a1, "%*sFull Name:\n", a3, "");
    uint64_t v7 = *(unint64_t **)(a2 + 8);
    return sub_244D53BD8(a1, v7, a3);
  }
}

uint64_t sub_244D53AE0(uint64_t a1, const char *a2, uint64_t a3, int a4)
{
  sub_244CF98F4(a1, "%*s%s:\n%*s", a4, "", a2, a4 + 2, "");
  char v6 = 0;
  uint64_t v7 = &dword_2651A7C30;
  uint64_t v8 = "Unused";
LABEL_2:
  for (int i = *v7; ; int i = v10)
  {
    if (sub_244CF10B8(a3, i))
    {
      if (v6) {
        sub_244CF8634(a1, ", ");
      }
      sub_244CF8634(a1, v8);
      uint64_t v8 = (char *)*((void *)v7 + 4);
      v7 += 6;
      char v6 = 1;
      if (!v8) {
        goto LABEL_11;
      }
      goto LABEL_2;
    }
    uint64_t v8 = (char *)*((void *)v7 + 4);
    if (!v8) {
      break;
    }
    int v10 = v7[6];
    v7 += 6;
  }
  if (v6)
  {
LABEL_11:
    uint64_t v11 = "\n";
    goto LABEL_13;
  }
  uint64_t v11 = "<EMPTY>\n";
LABEL_13:

  return sub_244CF8634(a1, v11);
}

unint64_t sub_244D53BD8(uint64_t a1, unint64_t *a2, int a3)
{
  unint64_t result = sub_244D259E0((uint64_t)a2);
  if (result)
  {
    for (unint64_t i = 0; i < result; ++i)
    {
      sub_244CF98F4(a1, "%*s", a3 + 2, "");
      uint64_t v8 = sub_244D4B518(a2, i);
      sub_244D50B88(a1, (uint64_t)v8);
      sub_244CF8634(a1, "\n");
      unint64_t result = sub_244D259E0((uint64_t)a2);
    }
  }
  return result;
}

const char *sub_244D53C94(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v4 = sub_244CF1D54((uint64_t)a2);
  uint64_t v5 = *(void *)(a1 + 96);
  char v6 = *(const char **)(v5 + 8);
  if (v6)
  {
    if (v4 == *(_DWORD *)v5)
    {
LABEL_6:
      return sub_244D442B0(v6);
    }
    uint64_t v7 = (const char **)(v5 + 32);
    while (1)
    {
      char v6 = *v7;
      if (!*v7) {
        break;
      }
      uint64_t v8 = *((int *)v7 - 2);
      v7 += 3;
      if (v4 == v8) {
        goto LABEL_6;
      }
    }
  }

  return (const char *)sub_244D574D4(a1, a2);
}

unint64_t *sub_244D53D2C(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  size_t v3 = a3;
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v8 = a3;
  if (sub_244D259E0((uint64_t)a2))
  {
    unint64_t v5 = 0;
    do
    {
      char v6 = sub_244D4B518(a2, v5);
      sub_244CF2620(__s, 80, (uint64_t)v6);
      sub_244D572A4(0, __s, &v8);
      ++v5;
    }
    while (v5 < sub_244D259E0((uint64_t)a2));
    return v8;
  }
  return v3;
}

unint64_t *sub_244D53DE0(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v4 = sub_244D4B4C8();
  if (v4 && sub_244D259E0((uint64_t)a3))
  {
    unint64_t v5 = 0;
    while (1)
    {
      char v6 = sub_244D4B518(a3, v5);
      uint64_t v7 = (const char *)v6[2];
      if (!v7) {
        uint64_t v7 = (const char *)v6[1];
      }
      uint64_t v8 = sub_244D44DDC(v7, 0);
      if (!v8 || !sub_244D4BA04(v4, (uint64_t)v8)) {
        break;
      }
      if (++v5 >= sub_244D259E0((uint64_t)a3)) {
        return v4;
      }
    }
    sub_244CF29AC((void **)v8);
    sub_244D4B564(v4, (void (*)(uint64_t))sub_244D53F40, (uint64_t)sub_244CF29AC);
    sub_244D0B884(20, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_extku.c", 147);
    sub_244D0B930(6u, v9, v10, v11, v12, v13, v14, v15, (uint64_t)"section:");
    return 0;
  }
  return v4;
}

uint64_t sub_244D53F10(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A7E28);
}

uint64_t sub_244D53F1C(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A7E28);
}

uint64_t sub_244D53F28()
{
  return sub_244CF7888((uint64_t)&unk_2651A7E28);
}

void sub_244D53F34(uint64_t a1)
{
}

uint64_t sub_244D53F40(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D53F4C()
{
  return sub_244CF7888((uint64_t)&unk_2651A7EB8);
}

void sub_244D53F58(uint64_t a1)
{
}

uint64_t sub_244D53F64()
{
  return sub_244CF7888((uint64_t)&unk_2651A7F28);
}

void sub_244D53F70(uint64_t a1)
{
}

uint64_t sub_244D53F7C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8078);
}

uint64_t sub_244D53F88(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8078);
}

uint64_t sub_244D53F94()
{
  return sub_244CF7888((uint64_t)&unk_2651A8078);
}

void sub_244D53FA0(uint64_t a1)
{
}

uint64_t sub_244D53FAC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A80C8);
}

uint64_t sub_244D53FB8(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A80C8);
}

uint64_t sub_244D53FC4()
{
  return sub_244CF7888((uint64_t)&unk_2651A80C8);
}

void sub_244D53FD0(uint64_t a1)
{
}

uint64_t sub_244D53FDC(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A8078, a1);
}

uint64_t sub_244D53FEC(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1 || !a2 || *(_DWORD *)a1 != *(_DWORD *)a2) {
    return result;
  }
  switch(*(_DWORD *)a1)
  {
    case 0:
      char v6 = *(uint64_t **)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(uint64_t **)(a2 + 8);
        if (v7)
        {
          uint64_t result = sub_244D44948(*v6, *v7);
          if (!result)
          {
            uint64_t v8 = (int *)v6[1];
            uint64_t v9 = v7[1];
            return sub_244CF3F58(v8, v9);
          }
        }
      }
      return result;
    case 1:
    case 2:
    case 3:
    case 6:
      uint64_t v4 = *(void *)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 8);
      goto LABEL_6;
    case 4:
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(void *)(a2 + 8);
      return sub_244D59BA0(v10, v11);
    case 5:
      uint64_t v12 = *(uint64_t **)(a1 + 8);
      uint64_t v13 = *(uint64_t **)(a2 + 8);
      uint64_t v14 = *v13;
      if (!*v12)
      {
        if (!v14) {
          goto LABEL_21;
        }
        return 0xFFFFFFFFLL;
      }
      if (!v14 || sub_244CF4804(*v12, v14)) {
        return 0xFFFFFFFFLL;
      }
LABEL_21:
      uint64_t v4 = v12[1];
      uint64_t v5 = v13[1];
LABEL_6:
      return sub_244CF4804(v4, v5);
    case 7:
      uint64_t v15 = *(void *)(a1 + 8);
      uint64_t v16 = *(void *)(a2 + 8);
      return sub_244CF2A64(v15, v16);
    case 8:
      uint64_t v17 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a2 + 8);
      return sub_244D44948(v17, v18);
    default:
      return result;
  }
}

uint64_t sub_244D5417C(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (a2 <= 8) {
    *(void *)(result + 8) = a3;
  }
  *(_DWORD *)uint64_t result = a2;
  return result;
}

uint64_t sub_244D54190(uint64_t a1, _DWORD *a2)
{
  if (a2) {
    *a2 = *(_DWORD *)a1;
  }
  if (*(_DWORD *)a1 > 8u) {
    return 0;
  }
  else {
    return *(void *)(a1 + 8);
  }
}

uint64_t sub_244D541B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_244CF7888((uint64_t)&unk_2651A7EB8);
  if (result)
  {
    uint64_t v7 = (void *)result;
    sub_244CF7EB4(*(void *)(result + 8));
    *uint64_t v7 = a2;
    v7[1] = a3;
    *(void *)(a1 + 8) = v7;
    uint64_t result = 1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

uint64_t sub_244D54214(uint64_t a1, void *a2, void *a3)
{
  if (*(_DWORD *)a1) {
    return 0;
  }
  if (a2) {
    *a2 = **(void **)(a1 + 8);
  }
  if (a3) {
    *a3 = *(void *)(*(void *)(a1 + 8) + 8);
  }
  return 1;
}

void *sub_244D5424C(uint64_t a1, const void **a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(int *)a2;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = sub_244D43FF4(v3 + 1);
  uint64_t v5 = v4;
  if (v4)
  {
    size_t v6 = *(int *)a2;
    if (v6)
    {
      memcpy(v4, a2[1], v6);
      uint64_t v7 = *(int *)a2;
    }
    else
    {
      uint64_t v7 = 0;
    }
    *((unsigned char *)v5 + v7) = 0;
  }
  return v5;
}

void *sub_244D542B8(uint64_t a1, uint64_t a2, char *a3)
{
  if (!a3)
  {
    sub_244D0B884(20, 0, 124, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_ia5.c", 90);
    return 0;
  }
  uint64_t v4 = sub_244CF7D98();
  if (v4)
  {
    size_t v5 = strlen(a3);
    if (!sub_244CF45A0((uint64_t)v4, a3, v5))
    {
      sub_244CF7CBC((uint64_t)v4);
      return 0;
    }
  }
  return v4;
}

unint64_t *sub_244D54334(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (sub_244D259E0((uint64_t)a2))
  {
    unint64_t v6 = 0;
    uint64_t v7 = a3;
    while (1)
    {
      uint64_t v8 = v7;
      uint64_t v9 = (uint64_t *)sub_244D4B518(a2, v6);
      uint64_t v10 = sub_244D50920(a1, v9[1], v7);
      if (!v10) {
        break;
      }
      uint64_t v7 = v10;
      uint64_t v11 = sub_244D4B518(v10, v6);
      sub_244CF2620(__s, 80, *v9);
      int v12 = strlen(__s);
      unint64_t v13 = (int)(strlen((const char *)v11[1]) + v12 + 5);
      uint64_t v14 = sub_244D43FF4(v13);
      if (!v14)
      {
        uint64_t v8 = v7;
        break;
      }
      uint64_t v15 = v14;
      sub_244D4476C(v14, __s, v13);
      sub_244D447E4(v15, " - ", v13);
      sub_244D447E4(v15, (char *)v11[1], v13);
      sub_244D440EC((void *)v11[1]);
      v11[1] = (unint64_t)v15;
      if (++v6 >= sub_244D259E0((uint64_t)a2)) {
        return v7;
      }
    }
    uint64_t v7 = 0;
    if (!a3)
    {
      if (v8)
      {
        sub_244D4B564(v8, (void (*)(uint64_t))sub_244D54720, (uint64_t)sub_244D57450);
        return 0;
      }
    }
    return v7;
  }
  uint64_t v7 = a3;
  if (a3) {
    return v7;
  }

  return sub_244D4B4C8();
}

unint64_t *sub_244D54524(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v6 = sub_244D4B4C8();
  if (v6 && sub_244D259E0((uint64_t)a3))
  {
    unint64_t v7 = 0;
    while (1)
    {
      uint64_t v8 = sub_244D4B518(a3, v7);
      uint64_t v9 = sub_244CF7888((uint64_t)&unk_2651A8168);
      if (!v9) {
        break;
      }
      uint64_t v10 = (void *)v9;
      if (!sub_244D4BA04(v6, v9)) {
        break;
      }
      uint64_t v11 = strchr((char *)v8[1], 59);
      if (!v11)
      {
        sub_244D0B884(20, 0, 135, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_info.c", 185);
        break;
      }
      int v12 = v11;
      v24[0] = 0;
      v24[1] = v11 + 1;
      unint64_t v25 = 0;
      unint64_t v25 = v8[2];
      if (!sub_244D50E48(v10[1], a1, a2, (uint64_t)v24, 0)) {
        break;
      }
      unint64_t v13 = (const char *)sub_244D446C4((unsigned char *)v8[1], (size_t)&v12[-v8[1]]);
      if (!v13) {
        break;
      }
      uint64_t v14 = (char *)v13;
      uint64_t v15 = sub_244D44DDC(v13, 0);
      *uint64_t v10 = v15;
      if (!v15)
      {
        sub_244D0B884(20, 0, 101, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_info.c", 200);
        sub_244D0B930(2u, v16, v17, v18, v19, v20, v21, v22, (uint64_t)"value=");
        sub_244D440EC(v14);
        break;
      }
      sub_244D440EC(v14);
      if (++v7 >= sub_244D259E0((uint64_t)a3)) {
        return v6;
      }
    }
    sub_244D4B564(v6, (void (*)(uint64_t))sub_244D5472C, (uint64_t)sub_244D546E4);
    return 0;
  }
  return v6;
}

uint64_t sub_244D546D8()
{
  return sub_244CF7888((uint64_t)&unk_2651A8168);
}

void sub_244D546E4(uint64_t a1)
{
}

uint64_t sub_244D546F0(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A80F8);
}

uint64_t sub_244D546FC(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A80F8);
}

uint64_t sub_244D54708()
{
  return sub_244CF7888((uint64_t)&unk_2651A80F8);
}

void sub_244D54714(uint64_t a1)
{
}

uint64_t sub_244D54720(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5472C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void *sub_244D5473C(uint64_t a1, uint64_t a2, void *a3)
{
  return sub_244D5766C(a1, a3);
}

uint64_t sub_244D54744(uint64_t a1)
{
  uint64_t result = qword_268EC0280;
  if (qword_268EC0280 || (uint64_t result = (uint64_t)sub_244D4B468((uint64_t)sub_244D547B4), (qword_268EC0280 = result) != 0))
  {
    uint64_t result = (uint64_t)sub_244D4BA04((unint64_t *)result, a1);
    if (result)
    {
      sub_244D4BAAC(qword_268EC0280, (uint64_t (*)(void, void, void))sub_244D54D5C);
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D547B4(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

unint64_t *sub_244D547CC(int a1)
{
  int __key = v5;
  if (a1 < 0) {
    return 0;
  }
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  unint64_t v3 = 0;
  LODWORD(v5[0]) = a1;
  uint64_t v1 = bsearch(&__key, &off_2651A81B8, 0x1FuLL, 8uLL, (int (__cdecl *)(const void *, const void *))sub_244D5488C);
  if (v1) {
    return *(unint64_t **)v1;
  }
  uint64_t result = (unint64_t *)qword_268EC0280;
  if (qword_268EC0280)
  {
    if (sub_244D4B860(qword_268EC0280, &v3, (uint64_t)v5, (uint64_t (*)(void, uint64_t, void))sub_244D54D5C))return sub_244D4B518((unint64_t *)qword_268EC0280, v3); {
    return 0;
    }
  }
  return result;
}

uint64_t sub_244D5488C(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

unint64_t *sub_244D548A4(unsigned __int16 **a1)
{
  int v1 = sub_244D449A4(*a1);
  if (!v1) {
    return 0;
  }

  return sub_244D547CC(v1);
}

uint64_t sub_244D548E0(int a1, uint64_t a2)
{
  unint64_t v3 = sub_244D547CC(a1);
  if (v3)
  {
    sub_244CF746C(a2, v3[1]);
    return 1;
  }
  else
  {
    sub_244D0B884(20, 0, 104, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_lib.c", 138);
    return 0;
  }
}

uint64_t sub_244D5493C(int a1, int a2)
{
  unint64_t v3 = sub_244D547CC(a2);
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t result = (uint64_t)sub_244D43FF4(0x68uLL);
    if (!result) {
      return result;
    }
    uint64_t v6 = (void *)result;
    long long v7 = *((_OWORD *)v4 + 2);
    long long v8 = *(_OWORD *)v4;
    *(_OWORD *)(result + 16) = *((_OWORD *)v4 + 1);
    *(_OWORD *)(result + 32) = v7;
    *(_OWORD *)uint64_t result = v8;
    long long v9 = *((_OWORD *)v4 + 3);
    long long v10 = *((_OWORD *)v4 + 4);
    long long v11 = *((_OWORD *)v4 + 5);
    *(void *)(result + 96) = v4[12];
    *(_OWORD *)(result + 64) = v10;
    *(_OWORD *)(result + 80) = v11;
    *(_OWORD *)(result + 48) = v9;
    *(_DWORD *)uint64_t result = a1;
    if (sub_244D54744(result)) {
      return 1;
    }
    sub_244D440EC(v6);
  }
  else
  {
    sub_244D0B884(20, 0, 114, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_lib.c", 152);
  }
  return 0;
}

uint64_t sub_244D549EC(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_244D548A4((unsigned __int16 **)a1);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(int **)(a1 + 16);
    uint64_t v5 = *((void *)v4 + 1);
    uint64_t result = sub_244CF5200(0, &v5, *v4, *(void *)(result + 8));
    if (result)
    {
      if (v5 != *(void *)(*(void *)(a1 + 16) + 8) + **(int **)(a1 + 16))
      {
        sub_244CF746C(result, *(void *)(v3 + 8));
        sub_244D0B884(20, 0, 164, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_lib.c", 192);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_244D54A88(unint64_t *a1, int a2, int *a3, _DWORD *a4)
{
  if (a1)
  {
    int v8 = a4 ? *a4 + 1 : 0;
    unint64_t v9 = v8 & ~(v8 >> 31);
    if (sub_244D259E0((uint64_t)a1) > v9)
    {
      long long v10 = 0;
      while (1)
      {
        long long v11 = sub_244D4B518(a1, v9);
        if (sub_244D449A4((unsigned __int16 *)*v11) == a2)
        {
          if (a4)
          {
            *a4 = v9;
LABEL_21:
            if (a3) {
              *a3 = sub_244D5C264((BOOL)v11);
            }
            return sub_244D549EC((uint64_t)v11);
          }
          if (v10)
          {
            if (!a3) {
              return 0;
            }
            int v12 = -2;
LABEL_18:
            *a3 = v12;
            return 0;
          }
        }
        else
        {
          long long v11 = v10;
        }
        ++v9;
        long long v10 = v11;
        if (v9 >= sub_244D259E0((uint64_t)a1))
        {
          if (!v11) {
            break;
          }
          goto LABEL_21;
        }
      }
    }
  }
  if (a4) {
    *a4 = -1;
  }
  if (a3)
  {
    int v12 = -1;
    goto LABEL_18;
  }
  return 0;
}

uint64_t sub_244D54BB0(unint64_t **a1, unsigned int a2, uint64_t a3, int a4, char a5)
{
  uint64_t v9 = a5 & 0xF;
  if (v9 == 1)
  {
LABEL_2:
    uint64_t v10 = sub_244D51E40(a2, a4, a3);
    if (v10)
    {
      long long v11 = *a1;
      if (*a1 || (long long v11 = sub_244D4B4C8()) != 0)
      {
        if (sub_244D4BA04(v11, v10))
        {
          *a1 = v11;
          return 1;
        }
      }
      if (v11 != *a1) {
        sub_244CF474C((uint64_t)v11);
      }
      sub_244D61F18(v10);
      return 0xFFFFFFFFLL;
    }
LABEL_28:
    int v17 = 109;
    __int16 v18 = 308;
    goto LABEL_29;
  }
  unsigned int v13 = sub_244D5C0C4(*a1, a2, -1);
  if ((v13 & 0x80000000) != 0)
  {
    int v17 = 114;
    if (v9 != 3 && v9 != 5) {
      goto LABEL_2;
    }
    if ((a5 & 0x10) != 0) {
      return 0;
    }
LABEL_23:
    __int16 v18 = 341;
LABEL_29:
    sub_244D0B884(20, 0, v17, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_lib.c", v18);
    return 0;
  }
  if (!v9)
  {
    int v17 = 112;
    if ((a5 & 0x10) != 0) {
      return 0;
    }
    goto LABEL_23;
  }
  if (v9 == 4) {
    return 1;
  }
  unsigned int v14 = v13;
  if (v9 == 5)
  {
    uint64_t v15 = sub_244D4B714((uint64_t *)*a1, v13);
    if (v15)
    {
      sub_244D61F18(v15);
      return 1;
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v19 = sub_244D51E40(a2, a4, a3);
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = v19;
  uint64_t v21 = sub_244D4B518(*a1, v14);
  sub_244D61F18((uint64_t)v21);
  if (sub_244D4B53C(*a1, v14, v20)) {
    return 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_244D54D5C(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D54D8C(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v6 = sub_244CF7888((uint64_t)&unk_2651A82B0);
  if (!v6) {
    goto LABEL_17;
  }
  if (sub_244D259E0((uint64_t)a3))
  {
    for (unint64_t i = 0; i < sub_244D259E0((uint64_t)a3); ++i)
    {
      int v8 = sub_244D4B518(a3, i);
      unint64_t v17 = 0;
      unint64_t v18 = 0;
      uint64_t v16 = 0;
      unint64_t v9 = v8[1];
      if (!strncmp((const char *)v9, "permitted", 9uLL) && *(unsigned char *)(v9 + 9))
      {
        uint64_t v10 = 10;
        long long v11 = (unint64_t **)v6;
      }
      else
      {
        if (strncmp((const char *)v9, "excluded", 8uLL) || !*(unsigned char *)(v9 + 8))
        {
          sub_244D0B884(20, 0, 135, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_ncons.c", 142);
LABEL_17:
          unsigned int v13 = 0;
LABEL_18:
          sub_244CF746C(v6, (uint64_t)&unk_2651A82B0);
          sub_244CF746C((uint64_t)v13, (uint64_t)&unk_2651A8340);
          return 0;
        }
        uint64_t v10 = 9;
        long long v11 = (unint64_t **)(v6 + 8);
      }
      unint64_t v12 = v8[2];
      unint64_t v17 = v9 + v10;
      unint64_t v18 = v12;
      unsigned int v13 = (uint64_t *)sub_244CF7888((uint64_t)&unk_2651A8340);
      if (!sub_244D50E48(*v13, a1, a2, (uint64_t)&v16, 1)) {
        goto LABEL_18;
      }
      unsigned int v14 = *v11;
      if (!*v11)
      {
        unsigned int v14 = sub_244D4B4C8();
        *long long v11 = v14;
        if (!v14) {
          goto LABEL_18;
        }
      }
      if (!sub_244D4BA04(v14, (uint64_t)v13)) {
        goto LABEL_18;
      }
    }
  }
  return v6;
}

uint64_t sub_244D54F30(uint64_t a1, unint64_t **a2, uint64_t a3, int a4)
{
  return 1;
}

uint64_t sub_244D54F94()
{
  return sub_244CF7888((uint64_t)&unk_2651A8340);
}

void sub_244D54FA0(uint64_t a1)
{
}

uint64_t sub_244D54FAC()
{
  return sub_244CF7888((uint64_t)&unk_2651A82B0);
}

void sub_244D54FB8(uint64_t a1)
{
}

uint64_t sub_244D54FC4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)sub_244D59E04(a1);
  signed int v5 = sub_244D5F544(v4);
  unint64_t v6 = sub_244D259E0(*(void *)(a1 + 88)) + v5;
  uint64_t v7 = sub_244D259E0(*a2);
  unint64_t v8 = sub_244D259E0(a2[1]) + v7;
  BOOL v9 = !is_mul_ok(v8, v6);
  if (v6 < (int)sub_244D5F544(v4) || v8 < sub_244D259E0(*a2)) {
    return 1;
  }
  if (v8)
  {
    char v10 = v8 * v6 > 0x100000 || v9;
    if (v10) {
      return 1;
    }
  }
  if ((int)sub_244D5F544(v4) >= 1)
  {
    uint64_t v19 = (uint64_t)v4;
    uint64_t v18 = 4;
    uint64_t result = sub_244D55154(&v18, (uint64_t)a2);
    if (result) {
      return result;
    }
    LODWORD(v18) = 1;
    int v12 = -1;
    while (1)
    {
      unsigned int v13 = sub_244D5F568(v4, 0x30u, v12);
      if (v13 == -1) {
        break;
      }
      int v12 = v13;
      unsigned int v14 = sub_244D5F4E0(v4, v13);
      uint64_t v19 = sub_244C9DDF8((uint64_t)v14);
      if (*(_DWORD *)(v19 + 4) != 22) {
        return 53;
      }
      uint64_t result = sub_244D55154(&v18, (uint64_t)a2);
      if (result) {
        return result;
      }
    }
  }
  uint64_t result = sub_244D259E0(*(void *)(a1 + 88));
  if (result)
  {
    unint64_t v15 = 0;
    do
    {
      uint64_t v16 = sub_244D4B518(*(unint64_t **)(a1 + 88), v15);
      uint64_t result = sub_244D55154(v16, (uint64_t)a2);
      if (result) {
        break;
      }
      ++v15;
      unint64_t v17 = sub_244D259E0(*(void *)(a1 + 88));
      uint64_t result = 0;
    }
    while (v15 < v17);
  }
  return result;
}

uint64_t sub_244D55154(_DWORD *a1, uint64_t a2)
{
  if (sub_244D259E0(*(void *)a2))
  {
    unint64_t v4 = 0;
    int v5 = 0;
    do
    {
      unint64_t v6 = (uint64_t *)sub_244D4B518(*(unint64_t **)a2, v4);
      if (*a1 == *(_DWORD *)*v6)
      {
        if (v6[1] || v6[2]) {
          return 49;
        }
        if (v5 != 2)
        {
          uint64_t result = sub_244D5546C((uint64_t)a1, *v6);
          if (result)
          {
            int v5 = 1;
            if (result != 47) {
              return result;
            }
          }
          else
          {
            int v5 = 2;
          }
        }
      }
      ++v4;
    }
    while (v4 < sub_244D259E0(*(void *)a2));
    if (v5 != 1) {
      goto LABEL_14;
    }
    return 47;
  }
  else
  {
LABEL_14:
    uint64_t result = sub_244D259E0(*(void *)(a2 + 8));
    if (result)
    {
      unint64_t v8 = 0;
      while (1)
      {
        BOOL v9 = (uint64_t *)sub_244D4B518(*(unint64_t **)(a2 + 8), v8);
        if (*a1 == *(_DWORD *)*v9)
        {
          if (v9[1] || v9[2]) {
            return 49;
          }
          uint64_t result = sub_244D5546C((uint64_t)a1, *v9);
          if (result != 47) {
            break;
          }
        }
        if (++v8 >= sub_244D259E0(*(void *)(a2 + 8))) {
          return 0;
        }
      }
      if (!result) {
        return 48;
      }
    }
  }
  return result;
}

unint64_t sub_244D55290(unint64_t *a1, uint64_t a2, int a3, const char *a4)
{
  if (sub_244D259E0((uint64_t)a1)) {
    sub_244CF98F4(a2, "%*s%s:\n", a3, "", a4);
  }
  unint64_t result = sub_244D259E0((uint64_t)a1);
  if (result)
  {
    unint64_t v9 = 0;
    int v10 = a3 + 2;
    do
    {
      long long v11 = sub_244D4B518(a1, v9);
      sub_244CF98F4(a2, "%*s", v10, "");
      int v12 = (_DWORD *)*v11;
      if (*(_DWORD *)*v11 == 7)
      {
        unsigned int v13 = (int *)*((void *)v12 + 1);
        unsigned int v14 = (unsigned __int8 *)*((void *)v13 + 1);
        int v15 = *v13;
        sub_244CF8634(a2, "IP:");
        if (v15 == 8)
        {
          sub_244CF98F4(a2, "%d.%d.%d.%d/%d.%d.%d.%d", *v14);
        }
        else
        {
          if (v15 == 32)
          {
            for (int i = 0; ; ++i)
            {
              sub_244CF98F4(a2, "%X", __rev16(*(unsigned __int16 *)v14));
              unint64_t v17 = "/";
              if (i != 7)
              {
                if (i == 15) {
                  goto LABEL_16;
                }
                unint64_t v17 = ":";
              }
              sub_244CF8634(a2, v17);
              v14 += 2;
            }
          }
          sub_244CF98F4(a2, "IP Address:<invalid>");
        }
      }
      else
      {
        sub_244D50B88(a2, (uint64_t)v12);
      }
LABEL_16:
      sub_244CF8634(a2, "\n");
      ++v9;
      unint64_t result = sub_244D259E0((uint64_t)a1);
    }
    while (v9 < result);
  }
  return result;
}

uint64_t sub_244D5546C(uint64_t a1, uint64_t a2)
{
  uint64_t result = 51;
  switch(*(_DWORD *)a2)
  {
    case 1:
      unint64_t v4 = *(int **)(a1 + 8);
      int v5 = *(int **)(a2 + 8);
      uint64_t v6 = *((void *)v4 + 1);
      uint64_t v7 = *v4;
      *(void *)&long long v37 = v6;
      *((void *)&v37 + 1) = v7;
      unint64_t v8 = (unsigned char *)*((void *)v5 + 1);
      uint64_t v9 = *v5;
      uint64_t v35 = v8;
      uint64_t v36 = v9;
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      long long v31 = 0uLL;
      if (!sub_244CFC970((uint64_t)&v37, &v33, 64)) {
        return 53;
      }
      if (sub_244CFC970((uint64_t)&v35, &v31, 64))
      {
        if (!*((void *)&v31 + 1) || sub_244CFC618((uint64_t)&v31, v33, v34))
        {
          sub_244CFC510(&v35, 1uLL);
LABEL_42:
          sub_244CFC510(&v37, 1uLL);
          uint64_t v29 = (uint64_t *)&v35;
          unint64_t v30 = (uint64_t *)&v37;
          goto LABEL_43;
        }
        return 47;
      }
      else
      {
        if (!v36 || *v35 != 46) {
          goto LABEL_42;
        }
LABEL_9:
        uint64_t v16 = &v37;
LABEL_10:
        BOOL v17 = sub_244D5578C(v16, (uint64_t *)&v35);
LABEL_44:
        if (v17) {
          return 0;
        }
        else {
          return 47;
        }
      }
    case 2:
      int v10 = *(int **)(a1 + 8);
      long long v11 = *(int **)(a2 + 8);
      uint64_t v12 = *((void *)v10 + 1);
      uint64_t v13 = *v10;
      *(void *)&long long v37 = v12;
      *((void *)&v37 + 1) = v13;
      unsigned int v14 = (unsigned char *)*((void *)v11 + 1);
      uint64_t v15 = *v11;
      uint64_t v35 = v14;
      uint64_t v36 = v15;
      if (!v15) {
        return 0;
      }
      if (*v14 == 46) {
        goto LABEL_9;
      }
      if (v13 > v15)
      {
        LOBYTE(v33) = 0;
        if (!sub_244CFC510(&v37, ~v15 + v13)
          || !sub_244CFC650(&v37, &v33)
          || v33 != 46)
        {
          return 47;
        }
      }
      uint64_t v29 = (uint64_t *)&v37;
      unint64_t v30 = (uint64_t *)&v35;
      goto LABEL_43;
    case 4:
      uint64_t v18 = *(void *)(a1 + 8);
      uint64_t v19 = *(void *)(a2 + 8);
      if (*(_DWORD *)(v18 + 8) && (sub_244D61F80(v18, 0) & 0x80000000) != 0
        || *(_DWORD *)(v19 + 8) && (sub_244D61F80(v19, 0) & 0x80000000) != 0)
      {
        return 17;
      }
      size_t v20 = *(int *)(v19 + 32);
      if ((int)v20 <= *(_DWORD *)(v18 + 32)
        && (!v20 || !memcmp(*(const void **)(v19 + 24), *(const void **)(v18 + 24), v20)))
      {
        return 0;
      }
      return 47;
    case 6:
      uint64_t v21 = *(int **)(a1 + 8);
      uint64_t v22 = *(int **)(a2 + 8);
      uint64_t v23 = *((void *)v21 + 1);
      uint64_t v24 = *v21;
      *(void *)&long long v37 = v23;
      *((void *)&v37 + 1) = v24;
      unint64_t v25 = (unsigned char *)*((void *)v22 + 1);
      uint64_t v26 = *v22;
      uint64_t v35 = v25;
      uint64_t v36 = v26;
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      char v32 = 0;
      if (!sub_244CFC970((uint64_t)&v37, &v33, 58) || !sub_244CFC510(&v37, 1uLL)) {
        return 53;
      }
      int v27 = sub_244CFC650(&v37, &v32);
      uint64_t result = 53;
      if (!v27) {
        return result;
      }
      if (v32 != 47) {
        return result;
      }
      int v28 = sub_244CFC650(&v37, &v32);
      uint64_t result = 53;
      if (!v28 || v32 != 47) {
        return result;
      }
      long long v31 = 0uLL;
      if (!sub_244CFC970((uint64_t)&v37, &v31, 58)
        && !sub_244CFC970((uint64_t)&v37, &v31, 47))
      {
        long long v31 = v37;
      }
      if (!*((void *)&v31 + 1)) {
        return 53;
      }
      if (v26 && *v25 == 46)
      {
        uint64_t v16 = &v31;
        goto LABEL_10;
      }
      uint64_t v29 = (uint64_t *)&v35;
      unint64_t v30 = (uint64_t *)&v31;
LABEL_43:
      BOOL v17 = sub_244D557E8(v29, v30);
      goto LABEL_44;
    default:
      return result;
  }
}

BOOL sub_244D5578C(long long *a1, uint64_t *a2)
{
  unint64_t v3 = *((void *)a1 + 1);
  unint64_t v4 = a2[1];
  if (v3 < v4) {
    return 0;
  }
  long long v6 = *a1;
  sub_244CFC510(&v6, v3 - v4);
  return sub_244D557E8((uint64_t *)&v6, a2);
}

BOOL sub_244D557E8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1];
  if (v2 != a2[1]) {
    return 0;
  }
  if (!v2) {
    return 1;
  }
  unint64_t v4 = 0;
  uint64_t v5 = *a1;
  uint64_t v6 = *a2;
  do
  {
    int v7 = sub_244D443FC(*(unsigned __int8 *)(v5 + v4));
    int v8 = sub_244D443FC(*(unsigned __int8 *)(v6 + v4));
    if (v7 != v8) {
      break;
    }
    ++v4;
  }
  while (v4 < a1[1]);
  return v7 == v8;
}

BOOL sub_244D5587C(int a1, int *a2, uint64_t a3, int a4)
{
  return (int)sub_244CF98F4(a3, "%*s", a4, "") >= 1 && sub_244CF31E4(a3, a2);
}

uint64_t sub_244D558EC()
{
  return 1;
}

unint64_t *sub_244D558F4(uint64_t a1, unsigned __int8 ***a2, unint64_t *a3)
{
  uint64_t v5 = a3;
  sub_244D577F0("Require Explicit Policy", *a2, &v5);
  sub_244D577F0("Inhibit Policy Mapping", a2[1], &v5);
  return v5;
}

uint64_t *sub_244D5594C(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v4 = (uint64_t *)sub_244CF7888((uint64_t)&unk_2651A83B0);
  if (!v4) {
    return v4;
  }
  if (sub_244D259E0((uint64_t)a3))
  {
    for (unint64_t i = 0; i < sub_244D259E0((uint64_t)a3); ++i)
    {
      uint64_t v6 = sub_244D4B518(a3, i);
      int v7 = (const char *)v6[1];
      if (!strcmp(v7, "requireExplicitPolicy"))
      {
        uint64_t v8 = (uint64_t)v6;
        uint64_t v9 = v4;
      }
      else
      {
        if (strcmp(v7, "inhibitPolicyMapping"))
        {
          sub_244D0B884(20, 0, 123, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_pcons.c", 128);
          sub_244D0B930(6u, v10, v11, v12, v13, v14, v15, v16, (uint64_t)"section:");
LABEL_14:
          sub_244CF746C((uint64_t)v4, (uint64_t)&unk_2651A83B0);
          return 0;
        }
        uint64_t v8 = (uint64_t)v6;
        uint64_t v9 = v4 + 1;
      }
      if (!sub_244D57A3C(v8, v9)) {
        goto LABEL_14;
      }
    }
  }
  if (!v4[1] && !*v4)
  {
    sub_244D0B884(20, 0, 117, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_pcons.c", 134);
    goto LABEL_14;
  }
  return v4;
}

uint64_t sub_244D55AC0()
{
  return sub_244CF7888((uint64_t)&unk_2651A83B0);
}

void sub_244D55ACC(uint64_t a1)
{
}

unint64_t *sub_244D55AD8(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = a3;
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v8 = a3;
  if (sub_244D259E0((uint64_t)a2))
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = (uint64_t *)sub_244D4B518(a2, v5);
      sub_244CF2620(v10, 80, *v6);
      sub_244CF2620(__s, 80, v6[1]);
      sub_244D572A4(v10, __s, &v8);
      ++v5;
    }
    while (v5 < sub_244D259E0((uint64_t)a2));
    return v8;
  }
  return v3;
}

unint64_t *sub_244D55BA8(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v4 = sub_244D4B4C8();
  if (v4 && sub_244D259E0((uint64_t)a3))
  {
    unint64_t v5 = 0;
    while (1)
    {
      uint64_t v6 = sub_244D4B518(a3, v5);
      int v7 = v6;
      if (!v6[2] || !v6[1])
      {
        __int16 v10 = 126;
        goto LABEL_15;
      }
      uint64_t v8 = (void *)sub_244CF7888((uint64_t)&unk_2651A8490);
      if (!v8 || !sub_244D4BA04(v4, (uint64_t)v8))
      {
        sub_244CF746C((uint64_t)v8, (uint64_t)&unk_2651A8490);
        goto LABEL_16;
      }
      *uint64_t v8 = sub_244D44DDC((const char *)v7[1], 0);
      uint64_t v9 = sub_244D44DDC((const char *)v7[2], 0);
      v8[1] = v9;
      if (!*v8 || !v9) {
        break;
      }
      if (++v5 >= sub_244D259E0((uint64_t)a3)) {
        return v4;
      }
    }
    __int16 v10 = 140;
LABEL_15:
    sub_244D0B884(20, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_pmaps.c", v10);
    sub_244D0B930(6u, v11, v12, v13, v14, v15, v16, v17, (uint64_t)"section:");
LABEL_16:
    sub_244D4B564(v4, (void (*)(uint64_t))sub_244D55D50, (uint64_t)sub_244D55D44);
    return 0;
  }
  return v4;
}

uint64_t sub_244D55D38()
{
  return sub_244CF7888((uint64_t)&unk_2651A8490);
}

void sub_244D55D44(uint64_t a1)
{
}

uint64_t sub_244D55D50(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

BOOL sub_244D55D5C(uint64_t a1, unsigned __int16 **a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_244D548A4(a2);
  if (v8)
  {
    uint64_t v9 = v8;
    __int16 v10 = (unsigned int *)sub_244D5C5B4((uint64_t)a2);
    uint64_t v29 = sub_244CF48E8((uint64_t)v10);
    int v11 = sub_244CF48D8(v10);
    uint64_t v12 = sub_244CF5200(0, &v29, v11, v9[1]);
    if (!v12) {
      return sub_244D56080(a1, (uint64_t)a2, a3, a4, 1);
    }
    uint64_t v13 = v12;
    uint64_t v14 = (uint64_t (*)(unint64_t *, uint64_t))v9[6];
    if (v14)
    {
      uint64_t v15 = (const char *)v14(v9, v12);
      uint64_t v16 = (char *)v15;
      if (v15)
      {
        sub_244CF98F4(a1, "%*s%s", a4, "", v15);
        uint64_t v17 = 0;
LABEL_35:
        uint64_t v19 = 1;
LABEL_40:
        sub_244D4B564(v17, (void (*)(uint64_t))sub_244D56358, (uint64_t)sub_244D57450);
        sub_244D440EC(v16);
        sub_244CF746C(v13, v9[1]);
        return v19;
      }
      goto LABEL_38;
    }
    size_t v20 = (uint64_t (*)(unint64_t *, uint64_t, void))v9[8];
    if (!v20)
    {
      int v28 = (unsigned int (*)(unint64_t *, uint64_t, uint64_t, uint64_t))v9[10];
      if (v28)
      {
        uint64_t v16 = 0;
        if (!v28(v9, v12, a1, a4))
        {
          uint64_t v19 = 0;
          uint64_t v17 = 0;
          goto LABEL_40;
        }
        uint64_t v17 = 0;
        goto LABEL_35;
      }
      sub_244D0B884(20, 0, 147, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_prn.c", 138);
      uint64_t v16 = 0;
LABEL_38:
      uint64_t v17 = 0;
      goto LABEL_39;
    }
    uint64_t v21 = v20(v9, v12, 0);
    uint64_t v17 = (unint64_t *)v21;
    if (!v21)
    {
      uint64_t v16 = 0;
LABEL_39:
      uint64_t v19 = 0;
      goto LABEL_40;
    }
    int v22 = *((_DWORD *)v9 + 1);
    if ((v22 & 4) == 0 || !sub_244D259E0(v21))
    {
      sub_244CF98F4(a1, "%*s", a4, "");
      if (!sub_244D259E0((uint64_t)v17)) {
        sub_244CF8634(a1, "<EMPTY>\n");
      }
    }
    if (!sub_244D259E0((uint64_t)v17))
    {
LABEL_31:
      uint64_t v16 = 0;
      goto LABEL_35;
    }
    unint64_t v23 = 0;
    while (1)
    {
      if ((v22 & 4) != 0)
      {
        sub_244CF98F4(a1, "%*s");
      }
      else if (v23)
      {
        sub_244CF98F4(a1, ", ");
      }
      uint64_t v24 = sub_244D4B518(v17, v23);
      unint64_t v25 = (char *)v24[1];
      uint64_t v26 = (const char *)v24[2];
      if (v25)
      {
        if (v26)
        {
          sub_244CF98F4(a1, "%s:%s", (const char *)v24[1], v26);
          if ((v22 & 4) == 0) {
            goto LABEL_30;
          }
LABEL_29:
          sub_244CF8634(a1, "\n");
          goto LABEL_30;
        }
        uint64_t v27 = a1;
      }
      else
      {
        uint64_t v27 = a1;
        unint64_t v25 = (char *)v26;
      }
      sub_244CF8634(v27, v25);
      if ((v22 & 4) != 0) {
        goto LABEL_29;
      }
LABEL_30:
      if (++v23 >= sub_244D259E0((uint64_t)v17)) {
        goto LABEL_31;
      }
    }
  }

  return sub_244D56080(a1, (uint64_t)a2, a3, a4, 0);
}

BOOL sub_244D56080(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int a4, int a5)
{
  uint64_t v7 = (a3 >> 16) & 0xF;
  if ((unint64_t)(v7 - 2) < 2)
  {
    uint64_t v8 = (unsigned int *)sub_244D5C5B4(a2);
    uint64_t v9 = sub_244CF48E8((uint64_t)v8);
    unint64_t v10 = (int)sub_244CF48D8(v8);
    return sub_244CF9634(a1, v9, v10, a4);
  }
  else if (v7)
  {
    if (v7 == 1)
    {
      if (a5) {
        sub_244CF98F4(a1, "%*s<Parse Error>");
      }
      else {
        sub_244CF98F4(a1, "%*s<Not Supported>");
      }
    }
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_244D5615C(uint64_t a1, const char *a2, unint64_t *a3, unint64_t a4, int a5)
{
  if (!sub_244D259E0((uint64_t)a3)) {
    return 1;
  }
  if (a2)
  {
    sub_244CF98F4(a1, "%*s%s:\n", a5, "", a2);
    a5 += 4;
  }
  if (!sub_244D259E0((uint64_t)a3)) {
    return 1;
  }
  unint64_t v10 = 0;
  while (1)
  {
    int v11 = sub_244D4B518(a3, v10);
    if (a5)
    {
      if ((int)sub_244CF98F4(a1, "%*s", a5, "") < 1) {
        break;
      }
    }
    uint64_t v12 = sub_244D259E0((uint64_t)v11);
    sub_244CF2628(a1, v12);
    BOOL v13 = sub_244D5C264((BOOL)v11);
    uint64_t v14 = "critical";
    if (!v13) {
      uint64_t v14 = "";
    }
    if ((int)sub_244CF98F4(a1, ": %s\n", v14) < 1) {
      break;
    }
    if (!sub_244D55D5C(a1, (unsigned __int16 **)v11, a4, (a5 + 4)))
    {
      sub_244CF98F4(a1, "%*s", a5 + 4, "");
      uint64_t v15 = sub_244D5C5B4((uint64_t)v11);
      sub_244CF2F9C(a1, v15);
    }
    if ((int)sub_244CF8524(a1, (uint64_t)"\n", 1) <= 0) {
      break;
    }
    if (++v10 >= sub_244D259E0((uint64_t)a3)) {
      return 1;
    }
  }
  return 0;
}

void *sub_244D562F8(uint64_t a1, unsigned __int16 **a2, int a3, uint64_t a4)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v8 = (uint64_t)result;
    BOOL v9 = sub_244D55D5C((uint64_t)result, a2, a3, a4);
    sub_244CF830C(v8);
    return (void *)v9;
  }
  return result;
}

uint64_t sub_244D56358(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D56364(uint64_t a1, int a2, int a3)
{
  uint64_t result = sub_244D5643C(a1);
  if (result)
  {
    if (a2 == -1)
    {
      return 1;
    }
    else
    {
      uint64_t v7 = 0;
      while (dword_26F9560A8[v7] != a2)
      {
        v7 += 6;
        if (v7 == 54) {
          return 0;
        }
      }
      if (a2 != 7 && a3)
      {
        int v8 = *(_DWORD *)(a1 + 48);
        if ((v8 & 2) != 0 && (*(unsigned char *)(a1 + 52) & 4) == 0) {
          return 0;
        }
        if ((~v8 & 0x2040) != 0 && (*(_DWORD *)(a1 + 48) & 0x11) != 0x11) {
          return 0;
        }
      }
      BOOL v9 = *(uint64_t (**)(void))&dword_26F9560A8[v7 + 2];
      return v9();
    }
  }
  return result;
}

BOOL sub_244D5643C(uint64_t a1)
{
  uint64_t v2 = (pthread_rwlock_t *)(a1 + 144);
  sub_244D4BD50((pthread_rwlock_t *)(a1 + 144));
  int v3 = *(_DWORD *)(a1 + 48);
  sub_244D4BD90(v2);
  if ((v3 & 0x100) == 0)
  {
    sub_244D4BD70(v2);
    if (*(unsigned char *)(a1 + 49))
    {
LABEL_89:
      sub_244D4BD90(v2);
      return ((*(_DWORD *)(a1 + 48) >> 7) & 1) == 0;
    }
    unint64_t v4 = sub_244D25C38();
    if (!sub_244D60EB4((uint64_t *)a1, (uint64_t)v4, a1 + 104, 0)) {
      *(_DWORD *)(a1 + 48) |= 0x80u;
    }
    if (!sub_244D5BB04((uint64_t **)a1)) {
      *(_DWORD *)(a1 + 48) |= 0x40u;
    }
    unsigned int v35 = 0;
    uint64_t v5 = sub_244D5A248(a1, 87, (int *)&v35, 0);
    if (v5)
    {
      uint64_t v6 = (_DWORD *)v5;
      if (*(_DWORD *)v5) {
        *(_DWORD *)(a1 + 48) |= 0x10u;
      }
      uint64_t v7 = *(void *)(v5 + 8);
      if (v7)
      {
        if (*(_DWORD *)(v7 + 4) == 258 || !*v6)
        {
          uint64_t v8 = 0;
          *(_DWORD *)(a1 + 48) |= 0x80u;
        }
        else
        {
          uint64_t v8 = sub_244CF1D00(v7);
        }
      }
      else
      {
        uint64_t v8 = -1;
      }
      *(void *)(a1 + 40) = v8;
      sub_244D51560((uint64_t)v6);
      int v9 = 1;
    }
    else
    {
      if (v35 == -1) {
        goto LABEL_20;
      }
      int v9 = 128;
    }
    *(_DWORD *)(a1 + 48) |= v9;
LABEL_20:
    uint64_t v10 = sub_244D5A248(a1, 83, (int *)&v35, 0);
    if (v10)
    {
      if (*(int *)v10 < 1)
      {
        *(_DWORD *)(a1 + 52) = 0;
      }
      else
      {
        int v11 = **(unsigned __int8 **)(v10 + 8);
        *(_DWORD *)(a1 + 52) = v11;
        if (*(int *)v10 >= 2) {
          *(_DWORD *)(a1 + 52) = v11 | (*(unsigned __int8 *)(*(void *)(v10 + 8) + 1) << 8);
        }
      }
      *(_DWORD *)(a1 + 48) |= 2u;
      sub_244CF7CBC(v10);
    }
    else if (v35 != -1)
    {
      *(_DWORD *)(a1 + 48) |= 0x80u;
    }
    *(_DWORD *)(a1 + 56) = 0;
    uint64_t v12 = sub_244D5A248(a1, 126, (int *)&v35, 0);
    if (v12)
    {
      BOOL v13 = (unint64_t *)v12;
      *(_DWORD *)(a1 + 48) |= 4u;
      if (sub_244D259E0(v12))
      {
        unint64_t v14 = 0;
        while (1)
        {
          uint64_t v15 = (unsigned __int16 *)sub_244D4B518(v13, v14);
          int v16 = sub_244D449A4(v15);
          if (v16 <= 179)
          {
            int v17 = 1;
            switch(v16)
            {
              case 129:
                goto LABEL_44;
              case 130:
                int v17 = 2;
                goto LABEL_44;
              case 131:
                int v17 = 8;
                goto LABEL_44;
              case 132:
                int v17 = 4;
                goto LABEL_44;
              case 133:
                int v17 = 64;
                goto LABEL_44;
              case 137:
              case 139:
                int v17 = 16;
                goto LABEL_44;
              default:
                goto LABEL_45;
            }
            goto LABEL_45;
          }
          if (v16 == 180) {
            break;
          }
          if (v16 == 297)
          {
            int v17 = 128;
            goto LABEL_44;
          }
          if (v16 == 910)
          {
            int v17 = 256;
LABEL_44:
            *(_DWORD *)(a1 + 56) |= v17;
          }
LABEL_45:
          if (++v14 >= sub_244D259E0((uint64_t)v13)) {
            goto LABEL_46;
          }
        }
        int v17 = 32;
        goto LABEL_44;
      }
LABEL_46:
      sub_244D4B564(v13, (void (*)(uint64_t))sub_244D57070, (uint64_t)sub_244CF29AC);
    }
    else if (v35 != -1)
    {
      *(_DWORD *)(a1 + 48) |= 0x80u;
    }
    uint64_t v18 = sub_244D5A248(a1, 82, (int *)&v35, 0);
    *(void *)(a1 + 64) = v18;
    if (!v18 && v35 != -1) {
      *(_DWORD *)(a1 + 48) |= 0x80u;
    }
    uint64_t v19 = sub_244D5A248(a1, 90, (int *)&v35, 0);
    *(void *)(a1 + 72) = v19;
    if (!v19 && v35 != -1) {
      *(_DWORD *)(a1 + 48) |= 0x80u;
    }
    uint64_t v20 = sub_244D59E04(a1);
    uint64_t v21 = sub_244D59CE8(a1);
    if (!sub_244D59BA0(v20, v21))
    {
      *(_DWORD *)(a1 + 48) |= 0x20u;
      if (!sub_244D56AF8(a1, *(uint64_t **)(a1 + 72)))
      {
        int v22 = *(_DWORD *)(a1 + 48);
        if ((v22 & 2) == 0 || (*(unsigned char *)(a1 + 52) & 4) != 0) {
          *(_DWORD *)(a1 + 48) = v22 | 0x2000;
        }
      }
    }
    uint64_t v23 = sub_244D5A248(a1, 85, (int *)&v35, 0);
    *(void *)(a1 + 88) = v23;
    if (!v23 && v35 != -1) {
      *(_DWORD *)(a1 + 48) |= 0x80u;
    }
    uint64_t v24 = sub_244D5A248(a1, 666, (int *)&v35, 0);
    *(void *)(a1 + 96) = v24;
    if (!v24 && v35 != -1) {
      *(_DWORD *)(a1 + 48) |= 0x80u;
    }
    int v36 = 0;
    uint64_t v25 = sub_244D5A248(a1, 103, &v36, 0);
    *(void *)(a1 + 80) = v25;
    if (v25 || v36 == -1)
    {
      if (!sub_244D259E0(v25)) {
        goto LABEL_82;
      }
      unint64_t v26 = 0;
      while (1)
      {
        uint64_t v27 = sub_244D4B518(*(unint64_t **)(a1 + 80), v26);
        if (*v27 && *(_DWORD *)*v27 == 1)
        {
          int v28 = v27;
          if (!sub_244D259E0(v27[2])) {
            goto LABEL_79;
          }
          unint64_t v29 = 0;
          while (1)
          {
            unint64_t v30 = sub_244D4B518((unint64_t *)v28[2], v29);
            if (*(_DWORD *)v30 == 4) {
              break;
            }
            if (++v29 >= sub_244D259E0(v28[2])) {
              goto LABEL_79;
            }
          }
          uint64_t v31 = v30[1];
          if (!v31) {
LABEL_79:
          }
            uint64_t v31 = sub_244D59CE8(a1);
          if (!sub_244D534A8(*v28, v31)) {
            break;
          }
        }
        if (++v26 >= sub_244D259E0(*(void *)(a1 + 80))) {
          goto LABEL_82;
        }
      }
    }
    *(_DWORD *)(a1 + 48) |= 0x80u;
LABEL_82:
    unsigned int v35 = 0;
    if ((int)sub_244D5A1D8(a1) >= 1)
    {
      while (1)
      {
        char v32 = sub_244D5A208(a1, v35);
        if (sub_244D5C264((BOOL)v32) && !sub_244D56A84((uint64_t)v32)) {
          break;
        }
        int v33 = ++v35;
        if (v33 >= (int)sub_244D5A1D8(a1)) {
          goto LABEL_88;
        }
      }
      *(_DWORD *)(a1 + 48) |= 0x200u;
    }
LABEL_88:
    *(_DWORD *)(a1 + 48) |= 0x100u;
    goto LABEL_89;
  }
  return ((*(_DWORD *)(a1 + 48) >> 7) & 1) == 0;
}

int *sub_244D569F0(int a1)
{
  uint64_t v1 = 0;
  while (dword_26F9560A8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 54) {
      return 0;
    }
  }
  return &dword_26F9560A8[v1];
}

uint64_t sub_244D56A24(char *__s2)
{
  uint64_t v2 = 0;
  while (strcmp(*(const char **)&dword_26F9560A8[v2 + 4], __s2))
  {
    v2 += 6;
    if (v2 == 54) {
      return 0xFFFFFFFFLL;
    }
  }
  return dword_26F9560A8[v2];
}

BOOL sub_244D56A84(uint64_t a1)
{
  uint64_t v1 = (unsigned __int16 *)sub_244D259E0(a1);
  int v2 = sub_244D449A4(v1);
  BOOL result = 1;
  if (v2 <= 400)
  {
    if ((v2 - 83) <= 0x2B && ((1 << (v2 - 83)) & 0x80000000055) != 0) {
      return result;
    }
    return v2 == 748;
  }
  if (v2 != 401 && v2 != 666 && v2 != 747) {
    return v2 == 748;
  }
  return result;
}

uint64_t sub_244D56AF8(uint64_t a1, uint64_t *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5)
    {
      if (sub_244CF2A64(v4, v5)) {
        return 30;
      }
    }
  }
  if (a2[2])
  {
    uint64_t v7 = sub_244D59E10(a1);
    if (sub_244CF162C(v7, a2[2])) {
      return 31;
    }
  }
  uint64_t v8 = (unint64_t *)a2[1];
  if (v8 && sub_244D259E0((uint64_t)v8))
  {
    unint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = sub_244D4B518(v8, v9);
      if (*(_DWORD *)v10 == 4) {
        break;
      }
      if (++v9 >= sub_244D259E0((uint64_t)v8)) {
        return 0;
      }
    }
    uint64_t v11 = v10[1];
    if (v11)
    {
      uint64_t v12 = sub_244D59CE8(a1);
      if (sub_244D59BA0(v11, v12)) {
        return 31;
      }
    }
  }
  return 0;
}

uint64_t sub_244D56BE4(uint64_t a1)
{
  uint64_t result = sub_244D5643C(a1);
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 2) == 0 || (*(unsigned char *)(a1 + 52) & 4) != 0)
    {
      BOOL v4 = (~v3 & 0x2040) == 0;
      unsigned int v5 = v3 & (v3 >> 4) & 1;
      if (v4) {
        return 1;
      }
      else {
        return v5;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D56C3C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_244D59E04(a1);
  uint64_t v5 = sub_244D59CE8(a2);
  if (sub_244D59BA0(v4, v5)) {
    return 29;
  }
  if (!sub_244D5643C(a1) || !sub_244D5643C(a2)) {
    return 1;
  }
  uint64_t v7 = *(uint64_t **)(a2 + 72);
  if (!v7 || (uint64_t result = sub_244D56AF8(a1, v7), !result))
  {
    if ((*(unsigned char *)(a1 + 48) & 2) == 0 || (*(unsigned char *)(a1 + 52) & 4) != 0) {
      return 0;
    }
    else {
      return 32;
    }
  }
  return result;
}

uint64_t sub_244D56CE0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_244D56D08(uint64_t a1)
{
  uint64_t result = sub_244D5643C(a1);
  if (result)
  {
    if ((*(unsigned char *)(a1 + 48) & 2) != 0) {
      return *(unsigned int *)(a1 + 52);
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_244D56D44(uint64_t a1)
{
  uint64_t result = sub_244D5643C(a1);
  if (result)
  {
    if ((*(unsigned char *)(a1 + 48) & 4) != 0) {
      return *(unsigned int *)(a1 + 56);
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_244D56D80(uint64_t a1)
{
  if (sub_244D5643C(a1)) {
    return *(void *)(a1 + 64);
  }
  else {
    return 0;
  }
}

uint64_t sub_244D56DB4(uint64_t a1)
{
  if (sub_244D5643C(a1) && (uint64_t v2 = *(void *)(a1 + 72)) != 0) {
    return *(void *)v2;
  }
  else {
    return 0;
  }
}

uint64_t sub_244D56DF0(uint64_t a1)
{
  if (sub_244D5643C(a1) && (uint64_t v2 = *(void *)(a1 + 72)) != 0) {
    return *(void *)(v2 + 8);
  }
  else {
    return 0;
  }
}

uint64_t sub_244D56E2C(uint64_t a1)
{
  if (sub_244D5643C(a1) && (uint64_t v2 = *(void *)(a1 + 72)) != 0) {
    return *(void *)(v2 + 16);
  }
  else {
    return 0;
  }
}

uint64_t sub_244D56E68(uint64_t a1)
{
  if (sub_244D5643C(a1) && (*(unsigned char *)(a1 + 48) & 1) != 0) {
    return *(void *)(a1 + 40);
  }
  else {
    return -1;
  }
}

BOOL sub_244D56EA4(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(unsigned char *)(a2 + 56) & 2) == 0) {
    return 0;
  }
  BOOL result = 1;
  if (!a3 && (v3 & 2) != 0) {
    return (*(unsigned char *)(a2 + 52) & 0x88) != 0;
  }
  return result;
}

BOOL sub_244D56EDC(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(unsigned char *)(a2 + 56) & 1) == 0) {
    return 0;
  }
  BOOL result = 1;
  if (!a3 && (v3 & 2) != 0) {
    return (*(unsigned char *)(a2 + 52) & 0xA8) != 0;
  }
  return result;
}

uint64_t sub_244D56F14(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(unsigned char *)(a2 + 56) & 1) == 0) {
    return 0;
  }
  uint64_t result = 1;
  if (!a3 && (v3 & 2) != 0) {
    return (*(_DWORD *)(a2 + 52) >> 5) & 1;
  }
  return result;
}

BOOL sub_244D56F44(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(unsigned char *)(a2 + 56) & 4) == 0) {
    return 0;
  }
  BOOL result = 1;
  if (!a3 && (v3 & 2) != 0) {
    return (*(unsigned char *)(a2 + 52) & 0xC0) != 0;
  }
  return result;
}

uint64_t sub_244D56F78(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(unsigned char *)(a2 + 56) & 4) == 0) {
    return 0;
  }
  uint64_t result = 1;
  if (!a3 && (v3 & 2) != 0) {
    return (*(_DWORD *)(a2 + 52) >> 5) & 1;
  }
  return result;
}

uint64_t sub_244D56FA8(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3 && (*(unsigned char *)(a2 + 48) & 2) != 0) {
    return (*(_DWORD *)(a2 + 52) >> 1) & 1;
  }
  else {
    return 1;
  }
}

uint64_t sub_244D56FC8()
{
  return 1;
}

BOOL sub_244D56FD0(uint64_t a1, _DWORD *a2, int a3)
{
  if (a3) {
    return 1;
  }
  int v5 = a2[12];
  if ((v5 & 2) != 0)
  {
    BOOL result = 0;
    if ((v5 & 4) == 0) {
      return result;
    }
    if ((a2[13] & 0xFFFFFF3F) != 0 || (a2[13] & 0xC0) == 0) {
      return result;
    }
  }
  else if ((v5 & 4) == 0)
  {
    return 0;
  }
  if (a2[14] != 64) {
    return 0;
  }
  unsigned int v7 = sub_244D5A1E4((uint64_t)a2, 0x7Eu, -1);
  if ((v7 & 0x80000000) != 0) {
    return 1;
  }
  uint64_t v8 = sub_244D5A208((uint64_t)a2, v7);
  BOOL result = sub_244D5C264((BOOL)v8);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t sub_244D57070(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5707C(uint64_t a1, int *a2)
{
  return sub_244D57DB0(*((void *)a2 + 1), *a2);
}

void *sub_244D57088(uint64_t a1, uint64_t a2, const char *a3)
{
  unint64_t v8 = 0;
  int v3 = sub_244D57EA0(a3, &v8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  if (v8 >> 31)
  {
    sub_244D0B884(20, 0, 69, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_skey.c", 84);
LABEL_6:
    sub_244D440EC(v4);
    return 0;
  }
  int v5 = sub_244CF7CB4();
  if (!v5) {
    goto LABEL_6;
  }
  uint64_t v6 = v5;
  sub_244CF4790((uint64_t)v5, (uint64_t)v4, v8);
  return v6;
}

uint64_t sub_244D5711C(uint64_t a1, int *a2)
{
  return sub_244D57DB0(*((void *)a2 + 1), *a2);
}

void *sub_244D57128(int a1, uint64_t a2, char *__s1)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v5 = strcmp(__s1, "hash");
  if (!v5)
  {
    unint64_t v8 = sub_244CF7CB4();
    if (v8)
    {
      int v17 = 0;
      if (!a2) {
        goto LABEL_16;
      }
      if (*(_DWORD *)a2 != 1)
      {
        unint64_t v9 = *(void **)(a2 + 24);
        if (v9)
        {
          uint64_t v10 = *v9 + 40;
LABEL_12:
          uint64_t v12 = *(int **)(*(void *)v10 + 8);
          if (v12)
          {
            uint64_t v13 = *((void *)v12 + 1);
            uint64_t v14 = *v12;
            uint64_t v15 = sub_244D25B18();
            if (sub_244D25474(v13, v14, (uint64_t)v18, &v17, (uint64_t)v15)
              && sub_244CF2A68((uint64_t)v8, v18, v17))
            {
              return v8;
            }
            goto LABEL_18;
          }
          __int16 v16 = 136;
LABEL_17:
          sub_244D0B884(20, 0, 144, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_skey.c", v16);
LABEL_18:
          sub_244CF7CBC((uint64_t)v8);
          return 0;
        }
        uint64_t v11 = *(void **)(a2 + 16);
        if (v11)
        {
          uint64_t v10 = *v11 + 48;
          goto LABEL_12;
        }
LABEL_16:
        __int16 v16 = 125;
        goto LABEL_17;
      }
    }
    return v8;
  }

  return sub_244D57088(v5, v6, __s1);
}

uint64_t sub_244D572A4(const char *a1, char *__s, unint64_t **a3)
{
  if (__s) {
    size_t v6 = strlen(__s);
  }
  else {
    size_t v6 = 0;
  }

  return sub_244D57310(a1, __s, v6, __s == 0, a3);
}

uint64_t sub_244D57310(const char *a1, unsigned char *a2, size_t a3, int a4, unint64_t **a5)
{
  unint64_t v9 = *a5;
  if (!a1)
  {
    uint64_t v10 = 0;
    if (a4) {
      goto LABEL_4;
    }
    goto LABEL_11;
  }
  uint64_t v10 = (char *)sub_244D442B0(a1);
  if (!v10) {
    goto LABEL_14;
  }
  if (!a4)
  {
LABEL_11:
    if (!a3 || !memchr(a2, 0, a3))
    {
      uint64_t v11 = sub_244D446C4(a2, a3);
      if (!v11)
      {
        uint64_t v12 = 0;
        if (v9) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }
      goto LABEL_5;
    }
    sub_244D0B884(20, 0, 163, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", 104);
LABEL_14:
    uint64_t v12 = 0;
    uint64_t v11 = 0;
    goto LABEL_15;
  }
LABEL_4:
  uint64_t v11 = 0;
LABEL_5:
  uint64_t v12 = sub_244CFAC60();
  if (v12)
  {
    if (*a5 || (uint64_t v13 = sub_244D4B4C8(), (*a5 = v13) != 0))
    {
      *uint64_t v12 = 0;
      v12[1] = v10;
      _OWORD v12[2] = v11;
      if (sub_244D4BA04(*a5, (uint64_t)v12)) {
        return 1;
      }
    }
  }
LABEL_15:
  if (!v9)
  {
LABEL_16:
    sub_244CF474C((uint64_t)*a5);
    *a5 = 0;
  }
LABEL_17:
  sub_244D440EC(v12);
  sub_244D440EC(v10);
  sub_244D440EC(v11);
  return 0;
}

uint64_t sub_244D57438(const char *a1, int *a2, unint64_t **a3)
{
  return sub_244D57310(a1, *((unsigned char **)a2 + 1), *a2, 0, a3);
}

void sub_244D57450(void *a1)
{
  if (a1)
  {
    sub_244D440EC((void *)a1[1]);
    sub_244D440EC((void *)a1[2]);
    sub_244D440EC((void *)*a1);
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D574A4(const char *a1, int a2, unint64_t **a3)
{
  if (a2)
  {
    uint64_t v4 = "TRUE";
    size_t v5 = 4;
  }
  else
  {
    uint64_t v4 = "FALSE";
    size_t v5 = 5;
  }
  return sub_244D57310(a1, v4, v5, 0, a3);
}

uint64_t sub_244D574D4(uint64_t a1, unsigned __int8 **a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = sub_244CF1EF4(a2, 0);
  int v3 = v2;
  if (v2) {
    uint64_t v4 = sub_244D57530(v2);
  }
  else {
    uint64_t v4 = 0;
  }
  sub_244D166B0((void **)v3);
  return v4;
}

uint64_t sub_244D57530(uint64_t *a1)
{
  if (sub_244D168EC(a1) > 0x1F)
  {
    int v3 = (const char *)sub_244CFA21C((uint64_t)a1);
    if (!v3) {
      return 0;
    }
    uint64_t v4 = (char *)v3;
    unint64_t v5 = strlen(v3) + 3;
    size_t v6 = sub_244D43FF4(v5);
    unsigned int v7 = v6;
    if (v6)
    {
      if (*v4 == 45)
      {
        sub_244D4476C(v6, "-0x", v5);
        unint64_t v8 = v4 + 1;
      }
      else
      {
        sub_244D4476C(v6, "0x", v5);
        unint64_t v8 = v4;
      }
      sub_244D447E4(v7, v8, v5);
    }
    sub_244D440EC(v4);
    return (uint64_t)v7;
  }
  else
  {
    return sub_244CFA530((uint64_t)a1);
  }
}

uint64_t sub_244D57610(uint64_t a1, unsigned __int8 **a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = sub_244CF1E44(a2, 0);
  int v3 = v2;
  if (v2) {
    uint64_t v4 = sub_244D57530(v2);
  }
  else {
    uint64_t v4 = 0;
  }
  sub_244D166B0((void **)v3);
  return v4;
}

void *sub_244D5766C(uint64_t a1, void *a2)
{
  uint64_t v2 = a2;
  if (!a2)
  {
    int v8 = 126;
    __int16 v9 = 237;
LABEL_11:
    sub_244D0B884(20, 0, v8, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", v9);
    return v2;
  }
  int v3 = sub_244D16670();
  uint64_t v12 = v3;
  int v4 = *(unsigned __int8 *)v2;
  if (v4 == 45) {
    uint64_t v2 = (void *)((char *)v2 + 1);
  }
  if (*(unsigned char *)v2 == 48 && (*((unsigned __int8 *)v2 + 1) | 0x20) == 0x78)
  {
    uint64_t v2 = (void *)((char *)v2 + 2);
    int v5 = sub_244CFA30C((uint64_t *)&v12, v2);
    if (!v5) {
      goto LABEL_14;
    }
  }
  else
  {
    if (strlen((const char *)v2) > 0x2000)
    {
      sub_244D166B0((void **)v3);
      int v6 = 127;
      __int16 v7 = 265;
LABEL_15:
      sub_244D0B884(20, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", v7);
      return 0;
    }
    int v5 = sub_244CFA714((uint64_t *)&v12, v2);
    if (!v5)
    {
LABEL_14:
      sub_244D166B0((void **)v12);
      int v6 = 102;
      __int16 v7 = 273;
      goto LABEL_15;
    }
  }
  if (*((unsigned char *)v2 + v5)) {
    goto LABEL_14;
  }
  BOOL v11 = v4 != 45 || sub_244D160FC((uint64_t)v12);
  uint64_t v2 = sub_244CF1D5C((uint64_t *)v12, 0);
  sub_244D166B0((void **)v12);
  if (!v2)
  {
    int v8 = 103;
    __int16 v9 = 284;
    goto LABEL_11;
  }
  if (!v11) {
    *((_DWORD *)v2 + 1) |= 0x100u;
  }
  return v2;
}

uint64_t sub_244D577F0(const char *a1, unsigned __int8 **a2, unint64_t **a3)
{
  if (!a2) {
    return 1;
  }
  uint64_t result = sub_244D57610((uint64_t)a1, a2);
  if (result)
  {
    int v6 = (unsigned char *)result;
    size_t v7 = strlen((const char *)result);
    uint64_t v8 = sub_244D57310(a1, v6, v7, 0, a3);
    sub_244D440EC(v6);
    return v8;
  }
  return result;
}

uint64_t sub_244D57860(const char *a1, _DWORD *a2)
{
  if (!strcmp(a1, "TRUE")
    || !strcmp(a1, "true")
    || !strcmp(a1, "Y")
    || !strcmp(a1, "y")
    || !strcmp(a1, "YES")
    || !strcmp(a1, "yes"))
  {
    *a2 = 255;
  }
  else
  {
    if (strcmp(a1, "FALSE")
      && strcmp(a1, "false")
      && strcmp(a1, "N")
      && strcmp(a1, "n")
      && strcmp(a1, "NO")
      && strcmp(a1, "no"))
    {
      sub_244D0B884(20, 0, 120, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", 319);
      return 0;
    }
    *a2 = 0;
  }
  return 1;
}

uint64_t sub_244D579A8(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(const char **)(a1 + 16);
  if (v2)
  {
    if (sub_244D57860(v2, a2)) {
      return 1;
    }
  }
  else
  {
    sub_244D0B884(20, 0, 120, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", 326);
  }
  sub_244D0B930(6u, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"section:");
  return 0;
}

uint64_t sub_244D57A3C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = sub_244D5766C(a1, *(void **)(a1 + 16));
  if (v3)
  {
    BOOL v11 = v3;
    sub_244CF7CBC(*a2);
    *a2 = (uint64_t)v11;
    return 1;
  }
  else
  {
    sub_244D0B930(6u, v4, v5, v6, v7, v8, v9, v10, (uint64_t)"section:");
    return 0;
  }
}

unint64_t *sub_244D57ACC(const char *a1)
{
  int v22 = 0;
  uint64_t v1 = sub_244D442B0(a1);
  uint64_t v2 = (char *)v1;
  if (!v1) {
    goto LABEL_33;
  }
  uint64_t v3 = 0;
  uint64_t v4 = v1 + 1;
  uint64_t v5 = v1;
  int v6 = 1;
  while (1)
  {
    unsigned int v7 = *((unsigned __int8 *)v4 - 1);
    if (v7 <= 0xD && ((1 << v7) & 0x2401) != 0)
    {
      uint64_t v14 = sub_244D57D28(v1);
      uint64_t v15 = v14;
      if (v6 == 2)
      {
        if (!v14)
        {
          int v20 = 126;
          __int16 v21 = 421;
          goto LABEL_32;
        }
        size_t v16 = strlen(v14);
        uint64_t v14 = v3;
        int v17 = (char *)v15;
        int v18 = 0;
      }
      else
      {
        if (!v14)
        {
          int v20 = 125;
          __int16 v21 = 431;
          goto LABEL_32;
        }
        int v17 = 0;
        size_t v16 = 0;
        int v18 = 1;
      }
      sub_244D57310(v14, v17, v16, v18, &v22);
      sub_244D440EC(v2);
      return v22;
    }
    if (v6 == 2)
    {
      if (v7 == 44)
      {
        *((unsigned char *)v4 - 1) = 0;
        uint64_t v10 = sub_244D57D28(v1);
        if (!v10)
        {
          int v20 = 126;
          __int16 v21 = 405;
          goto LABEL_32;
        }
        BOOL v11 = (char *)v10;
        size_t v12 = strlen(v10);
        sub_244D57310(v3, v11, v12, 0, &v22);
        uint64_t v3 = 0;
        uint64_t v1 = v5 + 1;
LABEL_16:
        int v6 = 1;
        goto LABEL_20;
      }
      goto LABEL_17;
    }
    if (v7 != 44)
    {
      if (v7 != 58) {
        goto LABEL_16;
      }
      *((unsigned char *)v4 - 1) = 0;
      uint64_t v9 = sub_244D57D28(v1);
      if (!v9)
      {
        int v20 = 125;
        __int16 v21 = 377;
        goto LABEL_32;
      }
      uint64_t v3 = v9;
      uint64_t v1 = v5 + 1;
LABEL_17:
      int v6 = 2;
      goto LABEL_20;
    }
    *((unsigned char *)v4 - 1) = 0;
    uint64_t v13 = sub_244D57D28(v1);
    if (!v13) {
      break;
    }
    uint64_t v3 = v13;
    int v6 = 1;
    sub_244D57310(v13, 0, 0, 1, &v22);
    uint64_t v1 = v4;
LABEL_20:
    ++v5;
    ++v4;
  }
  int v20 = 125;
  __int16 v21 = 389;
LABEL_32:
  sub_244D0B884(20, 0, v20, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", v21);
LABEL_33:
  sub_244D440EC(v2);
  sub_244D4B564(v22, (void (*)(uint64_t))sub_244D58E08, (uint64_t)sub_244D57450);
  return 0;
}

const char *sub_244D57D28(const char *a1)
{
  uint64_t v1 = a1;
  int v2 = *(unsigned __int8 *)a1;
  if (!v2) {
    return 0;
  }
  while (sub_244D44410(v2))
  {
    int v3 = *(unsigned __int8 *)++v1;
    int v2 = v3;
    if (!v3) {
      return 0;
    }
  }
  if (!*v1) {
    return 0;
  }
  size_t v4 = strlen(v1);
  while (1)
  {
    size_t v5 = v4 - 1;
    if (v4 == 1) {
      break;
    }
    BOOL v6 = sub_244D44410(v1[v4 - 1]);
    size_t v4 = v5;
    if (!v6)
    {
      v1[v5 + 1] = 0;
      break;
    }
  }
  if (*v1) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t sub_244D57DB0(uint64_t a1, uint64_t a2)
{
  memset(v8, 0, sizeof(v8));
  if (sub_244CFB3DC((uint64_t)v8, 3 * a2 + 1))
  {
    if (a2)
    {
      uint64_t v4 = 0;
      while ((!v4 || sub_244CFB8C4((uint64_t)v8, 0x3Au))
           && sub_244CFB8C4((uint64_t)v8, a0123456789abcd_3[(unint64_t)*(unsigned __int8 *)(a1 + v4) >> 4])&& sub_244CFB8C4((uint64_t)v8, a0123456789abcd_3[*(unsigned char *)(a1 + v4) & 0xF]))
      {
        if (a2 == ++v4) {
          goto LABEL_9;
        }
      }
    }
    else
    {
LABEL_9:
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      if (sub_244CFB8C4((uint64_t)v8, 0) && sub_244CFB48C((uint64_t)v8, &v7, &v6)) {
        return v7;
      }
    }
  }
  sub_244CFB470((uint64_t)v8);
  return 0;
}

void *sub_244D57EA0(const char *a1, void *a2)
{
  __int16 v13 = 0;
  if (a1)
  {
    int v3 = a1;
    size_t v4 = strlen(a1);
    size_t v5 = sub_244D43FF4(v4 >> 1);
    uint64_t v6 = v5;
    if (!v5)
    {
      sub_244D440EC(0);
      return v6;
    }
    uint64_t v7 = v5;
    while (2)
    {
      ++v3;
      do
      {
        int v8 = *((unsigned __int8 *)v3 - 1);
        if (!*(v3 - 1))
        {
          if (a2) {
            *a2 = v7 - (unsigned char *)v6;
          }
          return v6;
        }
        ++v3;
      }
      while (v8 == 58);
      int v9 = *((unsigned __int8 *)v3 - 1);
      if (!*(v3 - 1))
      {
        sub_244D0B884(20, 0, 146, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", 515);
        sub_244D440EC(v6);
        return 0;
      }
      if (sub_244D44390((unsigned char *)&v13 + 1, v8) && sub_244D44390(&v13, v9))
      {
        *v7++ = v13 | (16 * HIBYTE(v13));
        continue;
      }
      break;
    }
    sub_244D440EC(v6);
    int v10 = 118;
    __int16 v11 = 540;
  }
  else
  {
    int v10 = 124;
    __int16 v11 = 502;
  }
  sub_244D0B884(20, 0, v10, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/v3_utl.c", v11);
  return 0;
}

BOOL sub_244D57FD4(const char *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (strncmp(a1, __s, v4)) {
    return 0;
  }
  return !a1[v4] || a1[v4] == 46;
}

uint64_t sub_244D5803C(uint64_t a1)
{
  int v2 = (unint64_t *)sub_244D5A248(a1, 85, 0, 0);
  int v3 = (uint64_t *)sub_244D59E04(a1);
  uint64_t v4 = sub_244D580B0(v3, v2);
  sub_244D4B564(v2, (void (*)(uint64_t))sub_244D58E14, (uint64_t)sub_244D53FA0);
  return v4;
}

uint64_t sub_244D580B0(uint64_t *a1, unint64_t *a2)
{
  uint64_t v11 = 0;
  int v4 = -1;
  while (1)
  {
    unsigned int v5 = sub_244D5F568(a1, 0x30u, v4);
    if ((v5 & 0x80000000) != 0) {
      break;
    }
    int v4 = v5;
    uint64_t v6 = sub_244D5F4E0(a1, v5);
    uint64_t v7 = (int *)sub_244C9DDF8((uint64_t)v6);
    if (!sub_244D5823C(&v11, v7)) {
      return 0;
    }
  }
  if (sub_244D259E0((uint64_t)a2))
  {
    unint64_t v9 = 0;
    while (1)
    {
      int v10 = sub_244D4B518(a2, v9);
      if (*(_DWORD *)v10 == 1 && !sub_244D5823C(&v11, (int *)v10[1])) {
        break;
      }
      if (++v9 >= sub_244D259E0((uint64_t)a2)) {
        return v11;
      }
    }
    return 0;
  }
  return v11;
}

unint64_t sub_244D5817C(uint64_t a1)
{
  unint64_t v7 = 0;
  uint64_t v1 = sub_244D5A248(a1, 177, 0, 0);
  if (!v1) {
    return 0;
  }
  int v2 = (unint64_t *)v1;
  unint64_t v3 = 0;
  if (sub_244D259E0(v1))
  {
    do
    {
      int v4 = sub_244D4B518(v2, v3);
      if (sub_244D449A4((unsigned __int16 *)*v4) == 178)
      {
        unint64_t v5 = v4[1];
        if (*(_DWORD *)v5 == 6 && !sub_244D5823C((uint64_t *)&v7, *(int **)(v5 + 8))) {
          break;
        }
      }
      ++v3;
    }
    while (v3 < sub_244D259E0((uint64_t)v2));
    unint64_t v3 = v7;
  }
  sub_244D54714((uint64_t)v2);
  return v3;
}

uint64_t sub_244D5823C(uint64_t *a1, int *a2)
{
  if (a2[1] != 22) {
    return 1;
  }
  unint64_t v3 = (unsigned char *)*((void *)a2 + 1);
  if (!v3) {
    return 1;
  }
  size_t v4 = *a2;
  if (!v4 || memchr(*((void **)a2 + 1), 0, *a2)) {
    return 1;
  }
  if (!*a1)
  {
    unint64_t v7 = sub_244D4B468((uint64_t)sub_244D58E2C);
    *a1 = (uint64_t)v7;
    if (!v7)
    {
      int v8 = 0;
      goto LABEL_15;
    }
    unint64_t v3 = (unsigned char *)*((void *)a2 + 1);
    size_t v4 = *a2;
  }
  int v8 = sub_244D446C4(v3, v4);
  if (v8)
  {
    sub_244D4BAAC(*a1, (uint64_t (*)(void, void, void))sub_244D58E38);
    if (sub_244D4B860(*a1, 0, (uint64_t)v8, (uint64_t (*)(void, uint64_t, void))sub_244D58E38))
    {
      sub_244D440EC(v8);
      return 1;
    }
    if (sub_244D4BA04((unint64_t *)*a1, (uint64_t)v8)) {
      return 1;
    }
  }
LABEL_15:
  sub_244D440EC(v8);
  sub_244D4B564((unint64_t *)*a1, (void (*)(uint64_t))sub_244D58E68, (uint64_t)sub_244D58440);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t sub_244D58370(void *a1)
{
  int v2 = sub_244D5B5A8(a1);
  unint64_t v3 = (unint64_t *)sub_244D54A88(v2, 85, 0, 0);
  size_t v4 = (uint64_t *)sub_244D5B484((uint64_t)a1);
  uint64_t v5 = sub_244D580B0(v4, v3);
  sub_244D4B564(v3, (void (*)(uint64_t))sub_244D58E14, (uint64_t)sub_244D53FA0);
  sub_244D4B564(v2, (void (*)(uint64_t))sub_244D58E20, (uint64_t)sub_244D61F18);
  return v5;
}

void sub_244D5841C(unint64_t *a1)
{
}

BOOL sub_244D58444(unsigned char *a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int v2 = a1;
  if (a1[a2 - 1] == 46) {
    unint64_t v3 = a2 - 1;
  }
  else {
    unint64_t v3 = a2;
  }
  if (v3 >= 2)
  {
    if (*a1 != 42 || a1[1] != 46) {
      goto LABEL_10;
    }
    int v2 = a1 + 2;
    v3 -= 2;
  }
  if (v3)
  {
LABEL_10:
    BOOL v4 = 0;
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      int v7 = v2[v5];
      if (!sub_244D443E0(v7))
      {
        if (v7 > 57)
        {
          if (v7 != 58 && v7 != 95) {
            return v4;
          }
        }
        else if (v7 == 45)
        {
          if (v5 <= v6) {
            return v4;
          }
        }
        else
        {
          if (v7 != 46 || v5 <= v6 || v5 >= v3 - 1) {
            return v4;
          }
          unint64_t v6 = v5 + 1;
        }
      }
      BOOL v4 = ++v5 >= v3;
      if (v3 == v5) {
        return v4;
      }
    }
  }
  return 0;
}

uint64_t sub_244D58550(uint64_t a1, void *__s, size_t __n, uint64_t a4, void *a5)
{
  if (!__s || __n && memchr(__s, 0, __n)) {
    return 4294967294;
  }

  return sub_244D585EC(a1, __s, __n, a4, 2, a5);
}

uint64_t sub_244D585EC(uint64_t a1, void *a2, size_t a3, uint64_t a4, int a5, void *a6)
{
  if (a5 == 1)
  {
    uint64_t v11 = (uint64_t (*)(void))sub_244D58E74;
    unsigned int v12 = 48;
LABEL_8:
    int v13 = 1;
    int v14 = 22;
    goto LABEL_10;
  }
  if (a5 == 2)
  {
    if ((a4 & 2) != 0) {
      uint64_t v11 = (uint64_t (*)(void))sub_244D58F4C;
    }
    else {
      uint64_t v11 = (uint64_t (*)(void))sub_244D58FE4;
    }
    unsigned int v12 = 13;
    goto LABEL_8;
  }
  int v13 = 0;
  unsigned int v12 = 0;
  uint64_t v11 = (uint64_t (*)(void))sub_244D592A0;
  int v14 = 4;
LABEL_10:
  uint64_t v15 = sub_244D5A248(a1, 85, 0, 0);
  if (v15)
  {
    size_t v16 = (unint64_t *)v15;
    if (sub_244D259E0(v15))
    {
      unint64_t v17 = 0;
      while (1)
      {
        int v18 = sub_244D4B518(v16, v17);
        if (*(_DWORD *)v18 == a5)
        {
          uint64_t v19 = sub_244D592EC((int *)v18[1], v14, v11, a4, a5, a2, a3, a6);
          if (v19) {
            break;
          }
        }
        if (++v17 >= sub_244D259E0((uint64_t)v16)) {
          goto LABEL_16;
        }
      }
      uint64_t v20 = v19;
    }
    else
    {
LABEL_16:
      uint64_t v20 = 0;
    }
    sub_244D53FD0((uint64_t)v16);
  }
  else
  {
    if (((v13 ^ 1 | ((a4 & 0x20) >> 5)) & 1) == 0)
    {
      __int16 v21 = (uint64_t *)sub_244D59E04(a1);
      int v22 = -1;
      while (1)
      {
        unsigned int v23 = sub_244D5F568(v21, v12, v22);
        if ((v23 & 0x80000000) != 0) {
          break;
        }
        int v22 = v23;
        uint64_t v24 = sub_244D5F4E0(v21, v23);
        uint64_t v25 = (int *)sub_244C9DDF8((uint64_t)v24);
        uint64_t v26 = sub_244D592EC(v25, -1, v11, a4, a5, a2, a3, a6);
        if (v26) {
          return v26;
        }
      }
    }
    return 0;
  }
  return v20;
}

uint64_t sub_244D587D4(uint64_t a1, void *__s, size_t __n, uint64_t a4)
{
  if (!__s || __n && memchr(__s, 0, __n)) {
    return 4294967294;
  }

  return sub_244D585EC(a1, __s, __n, a4, 1, 0);
}

uint64_t sub_244D58860(uint64_t a1, void *a2, size_t a3, uint64_t a4)
{
  if (a2) {
    return sub_244D585EC(a1, a2, a3, a4, 7, 0);
  }
  else {
    return 4294967294;
  }
}

uint64_t sub_244D58878(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a2 && (unsigned int v5 = sub_244D58904(v7, a2)) != 0) {
    return sub_244D585EC(a1, v7, v5, a3, 7, 0);
  }
  else {
    return 4294967294;
  }
}

uint64_t sub_244D58904(unsigned char *a1, char *__s)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!strchr(__s, 58)) {
    return 4 * sub_244D58C44(a1, __s);
  }
  long long __src = 0uLL;
  int v10 = 0;
  uint64_t v11 = 0xFFFFFFFFLL;
  if (!sub_244CFF87C(__s, 58, 0, (uint64_t (*)(char *, uint64_t, uint64_t))sub_244D594F4, (uint64_t)&__src))return 0; {
  uint64_t v4 = v11;
  }
  uint64_t v5 = v10;
  if (v11 == -1)
  {
    if (v10 == 16) {
      goto LABEL_12;
    }
    return 0;
  }
  if (v10 > 15 || SHIDWORD(v11) > 3) {
    return 0;
  }
  if (HIDWORD(v11) == 2)
  {
    if (v11 && v10 != v11) {
      return 0;
    }
    goto LABEL_19;
  }
  if (HIDWORD(v11) != 3)
  {
    if (!v11 || v10 == v11) {
      return 0;
    }
LABEL_19:
    if ((v11 & 0x80000000) == 0)
    {
      if (v11)
      {
        memcpy(a1, &__src, v11);
        uint64_t v7 = v4;
      }
      else
      {
        uint64_t v7 = 0;
      }
      uint64_t v8 = &a1[v7];
      bzero(v8, (16 - v5));
      if (v5 != v4) {
        memcpy(&v8[-v5 + 16], (char *)&__src + v7, (int)v5 - (int)v4);
      }
      return 16;
    }
LABEL_12:
    *(_OWORD *)a1 = __src;
    return 16;
  }
  if (v10 <= 0) {
    goto LABEL_19;
  }
  return 0;
}

uint64_t sub_244D58AA0(char *__s)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v1 = sub_244D58904(v6, __s);
  if (!v1) {
    return 0;
  }
  int v2 = v1;
  unint64_t v3 = sub_244CF7CB4();
  uint64_t v4 = (uint64_t)v3;
  if (v3 && !sub_244CF2A68((uint64_t)v3, v6, v2))
  {
    sub_244CF7CBC(v4);
    return 0;
  }
  return v4;
}

uint64_t sub_244D58B34(char *a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  int v2 = strchr(a1, 47);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = v2;
  uint64_t v4 = (char *)sub_244D442B0(a1);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  unint64_t v6 = &v4[v3 - a1];
  *unint64_t v6 = 0;
  int v7 = sub_244D58904(v13, v4);
  if (!v7)
  {
    uint64_t v10 = 0;
    goto LABEL_10;
  }
  int v8 = v7;
  int v9 = sub_244D58904(&v13[v7], v6 + 1);
  sub_244D440EC(v5);
  uint64_t v10 = 0;
  uint64_t v5 = 0;
  if (!v9 || v8 != v9) {
    goto LABEL_10;
  }
  uint64_t v11 = sub_244CF7CB4();
  uint64_t v10 = (uint64_t)v11;
  if (!v11 || !sub_244CF2A68((uint64_t)v11, v13, 2 * v8))
  {
    uint64_t v5 = 0;
LABEL_10:
    sub_244D440EC(v5);
    sub_244CF7CBC(v10);
    return 0;
  }
  return v10;
}

BOOL sub_244D58C44(unsigned char *a1, unsigned char *a2)
{
  uint64_t v4 = a2;
  BOOL result = sub_244D59468(a1, &v4);
  if (result)
  {
    if (*v4 != 46) {
      return 0;
    }
    ++v4;
    BOOL result = sub_244D59468(a1 + 1, &v4);
    if (!result) {
      return result;
    }
    if (*v4 != 46) {
      return 0;
    }
    ++v4;
    BOOL result = sub_244D59468(a1 + 2, &v4);
    if (!result) {
      return result;
    }
    if (*v4 == 46)
    {
      ++v4;
      BOOL result = sub_244D59468(a1 + 3, &v4);
      if (result) {
        return *v4 == 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_244D58D0C(BOOL result, unint64_t *a2, int a3)
{
  if (result)
  {
    uint64_t v5 = result;
    if (sub_244D259E0((uint64_t)a2))
    {
      unint64_t v6 = 0;
      while (1)
      {
        int v7 = sub_244D4B518(a2, v6);
        int v8 = (unsigned __int8 *)v7[1];
        for (unint64_t i = v8 + 1; ; ++i)
        {
          unsigned int v10 = *(i - 1);
          if (v10 <= 0x2D) {
            break;
          }
          if (v10 == 58 || v10 == 46) {
            goto LABEL_12;
          }
LABEL_11:
          ;
        }
        if (!*(i - 1)) {
          goto LABEL_14;
        }
        if (v10 != 44) {
          goto LABEL_11;
        }
LABEL_12:
        if (*i) {
          int v8 = i;
        }
LABEL_14:
        int v11 = *v8;
        if (v11 == 43) {
          uint64_t v12 = (const char *)(v8 + 1);
        }
        else {
          uint64_t v12 = (const char *)v8;
        }
        if (v11 == 43) {
          int v13 = -1;
        }
        else {
          int v13 = 0;
        }
        unsigned int v14 = sub_244D5FA20(v5, v12, a3, (char *)v7[2], 0xFFFFFFFFFFFFFFFFLL, -1, v13);
        if (v14)
        {
          if (++v6 < sub_244D259E0((uint64_t)a2)) {
            continue;
          }
        }
        return v14 != 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D58E08(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D58E14(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D58E20(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D58E2C(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t sub_244D58E38(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D58E68(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D58E74(char *__s1, size_t __n, char *__s2, uint64_t a4)
{
  if (__n != a4) {
    return 0;
  }
  size_t v5 = __n;
  uint64_t v7 = 0;
  int v8 = __s2 - 1;
  int v9 = __s1 - 1;
  while (__n != v7)
  {
    uint64_t v10 = v7;
    int v11 = v8;
    uint64_t v12 = v9;
    if (v9[__n] != 64)
    {
      int v13 = v8[__n];
      ++v7;
      --v8;
      --v9;
      if (v13 != 64) {
        continue;
      }
    }
    uint64_t result = sub_244D58F4C(&v12[__n], v10 + 1, (unsigned __int8 *)&v11[__n], v10 + 1);
    if (!result) {
      return result;
    }
    if (v5 - 1 != v10)
    {
      v5 += ~v10;
      return memcmp(__s1, __s2, v5) == 0;
    }
    break;
  }
  if (!v5) {
    return 1;
  }
  return memcmp(__s1, __s2, v5) == 0;
}

uint64_t sub_244D58F4C(unsigned char *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a2 != a4) {
    return 0;
  }
  uint64_t v4 = a2;
  if (!a2) {
    return 1;
  }
  while (1)
  {
    uint64_t result = *a1;
    if (!*a1) {
      break;
    }
    uint64_t v8 = *a3;
    if (result != v8)
    {
      int v9 = sub_244D443FC(result);
      if (v9 != sub_244D443FC(v8)) {
        return 0;
      }
    }
    ++a1;
    ++a3;
    if (!--v4) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D58FE4(char *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  if (a4 < 2)
  {
    if (!a2) {
      goto LABEL_33;
    }
LABEL_6:
    int v8 = 0;
    int v9 = 0;
    int v10 = 1;
    unint64_t v11 = a2;
    uint64_t v12 = a1;
    do
    {
      int v13 = *v12;
      if (v13 == 42)
      {
        if (v11 == 1)
        {
          BOOL v14 = 1;
          if (v9) {
            goto LABEL_33;
          }
        }
        else
        {
          BOOL v14 = v12[1] == 46;
          if (v9) {
            goto LABEL_33;
          }
        }
        if ((((v10 & 8 | v8) == 0) & v10 & v14) != 1) {
          goto LABEL_33;
        }
        int v8 = 0;
        v10 &= ~1u;
        int v9 = (unsigned __int8 *)v12;
      }
      else if (sub_244D443E0(v13))
      {
        if ((v10 & 1) != 0 && v11 >= 4 && !sub_244D444B0(v12, "xn--", 4)) {
          int v10 = 8;
        }
        v10 &= 0xFFFFFFFA;
      }
      else
      {
        int v15 = *v12;
        if (v15 == 45)
        {
          if (v10) {
            goto LABEL_33;
          }
          v10 |= 4u;
        }
        else
        {
          if (v15 != 46 || (v10 & 5) != 0) {
            goto LABEL_33;
          }
          ++v8;
          int v10 = 1;
        }
      }
      ++v12;
      --v11;
    }
    while (v11);
    if ((v10 & 5) != 0 || v8 < 2 || !v9) {
      goto LABEL_33;
    }
    int64_t v16 = v9 - (unsigned __int8 *)a1;
    unint64_t v17 = &a1[a2 + ~(unint64_t)v9];
    if ((unint64_t)&v9[~(unint64_t)v9 + a2] <= a4)
    {
      uint64_t result = sub_244D58F4C(a1, v9 - (unsigned __int8 *)a1, a3, v9 - (unsigned __int8 *)a1);
      if (!result) {
        return result;
      }
      unint64_t v19 = a4 - (void)v17;
      uint64_t v20 = &a3[a4 - (void)v17];
      uint64_t result = sub_244D58F4C(v20, (uint64_t)&a1[a2 + ~(unint64_t)v9], v9 + 1, (uint64_t)&a1[a2 + ~(unint64_t)v9]);
      if (!result) {
        return result;
      }
      if (v9 == (unsigned __int8 *)a1 && v9[1] == 46)
      {
        if ((char *)a4 == v17) {
          return 0;
        }
      }
      else if (a4 >= 4)
      {
        uint64_t result = sub_244D444B0((char *)a3, "xn--", 4);
        if (!result) {
          return result;
        }
      }
      __int16 v21 = &a3[v16];
      if (v20 == v21 + 1)
      {
        uint64_t result = 1;
        if (v19 == v16 || *v21 == 42) {
          return result;
        }
      }
      else if (v19 == v16)
      {
        return 1;
      }
      uint64_t v22 = a4 - a2 + 1;
      while (sub_244D443E0(*v21) || *v21 == 45)
      {
        ++v21;
        if (!--v22) {
          return 1;
        }
      }
    }
    return 0;
  }
  if (a2 && *a3 != 46) {
    goto LABEL_6;
  }
LABEL_33:

  return sub_244D58F4C(a1, a2, a3, a4);
}

BOOL sub_244D592A0(const void *a1, size_t __n, void *__s2, uint64_t a4)
{
  if (__n != a4) {
    return 0;
  }
  if (__n) {
    return memcmp(a1, __s2, __n) == 0;
  }
  return 1;
}

uint64_t sub_244D592EC(int *a1, int a2, uint64_t (*a3)(void), uint64_t a4, int a5, void *__s2, size_t __n, void *a8)
{
  int v9 = (const void *)*((void *)a1 + 1);
  if (!v9 || !*a1) {
    return 0;
  }
  if (a2 < 1)
  {
    unsigned int v23 = 0;
    unsigned int v17 = sub_244CF2EF0(&v23, (char **)a1);
    if ((v17 & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    if (a5 == 2)
    {
      size_t v18 = v17;
      if (!sub_244D58444(v23, v17))
      {
        uint64_t v15 = 0;
LABEL_21:
        sub_244D440EC(v23);
        return v15;
      }
    }
    else
    {
      size_t v18 = v17;
    }
    uint64_t v20 = ((uint64_t (*)(void *, size_t, void *, size_t, uint64_t))a3)(v23, v18, __s2, __n, a4);
    uint64_t v15 = v20;
    if (a8)
    {
      if ((int)v20 >= 1)
      {
        __int16 v21 = sub_244D446C4(v23, v18);
        *a8 = v21;
        if (!v21) {
          return 0xFFFFFFFFLL;
        }
      }
    }
    goto LABEL_21;
  }
  if (a1[1] != a2) {
    return 0;
  }
  if (a2 != 22)
  {
    if (*a1 == __n && (!__n || !memcmp(v9, __s2, __n)))
    {
      uint64_t v15 = 1;
      if (!a8) {
        return v15;
      }
      goto LABEL_23;
    }
    return 0;
  }
  uint64_t v15 = a3();
  if (!a8) {
    return v15;
  }
LABEL_23:
  if ((int)v15 >= 1)
  {
    uint64_t v22 = sub_244D446C4(*((unsigned char **)a1 + 1), *a1);
    *a8 = v22;
    if (!v22) {
      return 0xFFFFFFFFLL;
    }
  }
  return v15;
}

BOOL sub_244D59468(unsigned char *a1, unsigned char **a2)
{
  unsigned int v4 = 0;
  LOBYTE(v5) = **a2;
  while (1)
  {
    BOOL result = sub_244D44364((char)v5);
    if (!result) {
      break;
    }
    uint64_t v7 = *a2;
    unsigned int v4 = (char)**a2 + 10 * v4 - 48;
    if (v4 > 0xFF) {
      return 0;
    }
    *a2 = v7 + 1;
    int v5 = v7[1];
    if (v5 == 46 || v5 == 0)
    {
      *a1 = v4;
      return 1;
    }
    if (!v4) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D594F4(char *a1, unint64_t a2, _DWORD *a3)
{
  int v3 = a3[4];
  if (v3 == 16) {
    return 0;
  }
  unint64_t v6 = a2;
  if (!a2)
  {
    int v9 = a3[5];
    if (v9 == -1)
    {
      a3[5] = v3;
    }
    else if (v9 != v3)
    {
      return 0;
    }
    int v13 = a3[6];
    if (v13 <= 2)
    {
      a3[6] = v13 + 1;
      return 1;
    }
    return 0;
  }
  uint64_t v7 = a1;
  if (a2 < 5)
  {
    unsigned int v10 = 0;
    unint64_t v11 = (_WORD *)((char *)a3 + v3);
    while (v6)
    {
      --v6;
      unsigned __int8 v14 = 0;
      int v12 = *v7++;
      uint64_t result = sub_244D44390(&v14, v12);
      unsigned int v10 = v14 | (16 * v10);
      if (!result) {
        return result;
      }
    }
    *unint64_t v11 = bswap32(v10) >> 16;
    int v8 = a3[4] + 2;
    goto LABEL_18;
  }
  if (v3 > 12 || a1[a2]) {
    return 0;
  }
  uint64_t result = sub_244D58C44((unsigned char *)a3 + v3, a1);
  if (result)
  {
    int v8 = a3[4] + 4;
LABEL_18:
    a3[4] = v8;
    return 1;
  }
  return result;
}

BOOL sub_244D59604(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  unsigned int v5 = 0;
  int v6 = 0;
  uint64_t v7 = *a2;
  int v8 = (unsigned __int8 *)*((void *)a2 + 1);
  uint64_t v9 = v7 & ~((int)v7 >> 31);
  uint64_t v10 = v7 - 1;
  while (v9)
  {
    if (v6 + 18 * (v5 / 0x12) || (int)sub_244CF8524(a1, (uint64_t)"\n", 1) >= 1 && (int)sub_244CF8A00(a1, a3, a3) >= 1)
    {
      int v12 = *v8++;
      int v11 = v12;
      int v13 = v10 ? ":" : "";
      --v9;
      --v6;
      ++v5;
      --v10;
      if ((int)sub_244CF98F4(a1, "%02x%s", v11, v13) >= 1) {
        continue;
      }
    }
    return 0;
  }
  return sub_244CF8524(a1, (uint64_t)"\n", 1) == 1;
}

const char ***sub_244D5972C(const char ****a1, unsigned int a2, int a3, char *a4, int a5)
{
  uint64_t v9 = sub_244D44ED0(a2);
  if (v9)
  {
    return sub_244D597BC(a1, (uint64_t)v9, a3, a4, a5);
  }
  else
  {
    sub_244D0B884(11, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_att.c", 73);
    return 0;
  }
}

const char ***sub_244D597BC(const char ****a1, uint64_t a2, int a3, char *a4, int a5)
{
  if (a1 && (uint64_t v10 = *a1) != 0 || (uint64_t v10 = (const char ***)sub_244D616B0()) != 0)
  {
    if (sub_244D59870(v10, a2) && sub_244D598BC((uint64_t)v10, a3, a4, a5))
    {
      if (a1 && !*a1) {
        *a1 = v10;
      }
    }
    else
    {
      if (!a1 || v10 != *a1) {
        sub_244D616BC((uint64_t)v10);
      }
      return 0;
    }
  }
  return v10;
}

BOOL sub_244D59870(const char ***a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1)
  {
    if (a2)
    {
      sub_244CF29AC((void **)*a1);
      unsigned int v5 = sub_244D44844(a2);
      *a1 = v5;
      return v5 != 0;
    }
  }
  return result;
}

uint64_t sub_244D598BC(uint64_t result, int a2, char *a3, int a4)
{
  if (result)
  {
    if (!a2) {
      return 1;
    }
    uint64_t v7 = result;
    BOOL result = sub_244CF7EA8();
    if (!result) {
      return result;
    }
    int v8 = (int *)result;
    if ((a2 & 0x1000) != 0)
    {
      int v11 = sub_244D449A4(*(unsigned __int16 **)v7);
      uint64_t v10 = sub_244CF3500(0, a3, a4, a2, v11);
      if (!v10)
      {
        sub_244D0B884(11, 0, 12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_att.c", 163);
        goto LABEL_15;
      }
    }
    else
    {
      if (a4 == -1)
      {
        if (!sub_244CF3EDC(result, a2, (int *)a3)) {
          goto LABEL_15;
        }
        goto LABEL_12;
      }
      uint64_t v9 = sub_244CF47D0(a2);
      uint64_t v10 = (uint64_t)v9;
      if (!v9 || !sub_244CF45A0((uint64_t)v9, a3, a4))
      {
        sub_244CF474C(v10);
LABEL_15:
        sub_244CF7EB4((uint64_t)v8);
        return 0;
      }
    }
    sub_244CF3DE8(v8, v10);
LABEL_12:
    if (!sub_244D4BA04(*(unint64_t **)(v7 + 8), (uint64_t)v8)) {
      goto LABEL_15;
    }
    return 1;
  }
  return result;
}

const char ***sub_244D599DC(const char ****a1, const char *a2, int a3, char *a4, int a5)
{
  uint64_t v9 = sub_244D44DDC(a2, 0);
  if (v9)
  {
    uint64_t v10 = v9;
    int v11 = sub_244D597BC(a1, (uint64_t)v9, a3, a4, a5);
    sub_244CF29AC((void **)v10);
    return v11;
  }
  else
  {
    sub_244D0B884(11, 0, 111, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_att.c", 120);
    sub_244D0B930(2u, v13, v14, v15, v16, v17, v18, v19, (uint64_t)"name=");
    return 0;
  }
}

uint64_t sub_244D59A98(uint64_t a1)
{
  return sub_244D259E0(*(void *)(a1 + 8));
}

uint64_t sub_244D59AB4(uint64_t a1, int a2, int a3)
{
  unsigned int v4 = sub_244D59B2C(a1, a2);
  if (!v4) {
    return 0;
  }
  unsigned int v5 = (int *)v4;
  if (sub_244CF3D80((unsigned int *)v4) != a3)
  {
    sub_244D0B884(11, 0, 134, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_att.c", 213);
    return 0;
  }

  return sub_244CF3DA8(v5);
}

unint64_t *sub_244D59B2C(uint64_t a1, int a2)
{
  if (!a1 || (int)sub_244D259E0(*(void *)(a1 + 8)) <= a2) {
    return 0;
  }
  unsigned int v4 = *(unint64_t **)(a1 + 8);

  return sub_244D4B518(v4, a2);
}

uint64_t sub_244D59B8C(uint64_t a1, uint64_t a2)
{
  return sub_244D59BA0(*(void *)(*(void *)a1 + 24), *(void *)(*(void *)a2 + 24));
}

uint64_t sub_244D59BA0(uint64_t a1, uint64_t a2)
{
  if ((!*(void *)(a1 + 24) || *(_DWORD *)(a1 + 8)) && (sub_244D61F80(a1, 0) & 0x80000000) != 0
    || (!*(void *)(a2 + 24) || *(_DWORD *)(a2 + 8)) && (sub_244D61F80(a2, 0) & 0x80000000) != 0)
  {
    return 4294967294;
  }
  size_t v4 = *(int *)(a1 + 32);
  int v5 = *(_DWORD *)(a2 + 32);
  uint64_t result = (v4 - v5);
  if (v4 == v5)
  {
    if (v4)
    {
      uint64_t v7 = *(const void **)(a2 + 24);
      int v8 = *(const void **)(a1 + 24);
      return memcmp(v8, v7, v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D59C48(uint64_t a1, uint64_t a2)
{
  return sub_244D59BA0(*(void *)(*(void *)a1 + 40), *(void *)(*(void *)a2 + 40));
}

uint64_t sub_244D59C5C(uint64_t a1, uint64_t a2)
{
  return sub_244D59BA0(*(void *)(*(void *)a1 + 16), *(void *)(*(void *)a2 + 16));
}

uint64_t sub_244D59C70(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = bswap64(*(void *)(a1 + 52));
  unint64_t v3 = bswap64(*(void *)(a2 + 52));
  if (v2 == v3)
  {
    unint64_t v2 = bswap64(*(void *)(a1 + 60));
    unint64_t v3 = bswap64(*(void *)(a2 + 60));
    if (v2 == v3)
    {
      unint64_t v2 = bswap64(*(void *)(a1 + 68));
      unint64_t v3 = bswap64(*(void *)(a2 + 68));
      if (v2 == v3)
      {
        unint64_t v2 = bswap64(*(void *)(a1 + 76));
        unint64_t v3 = bswap64(*(void *)(a2 + 76));
        if (v2 == v3) {
          return 0;
        }
      }
    }
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

uint64_t sub_244D59CE8(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 24);
}

uint64_t sub_244D59CF4(uint64_t a1)
{
  return sub_244D59D00(*(void *)(*(void *)a1 + 24));
}

uint64_t sub_244D59D00(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  if ((sub_244D61F80(a1, 0) & 0x80000000) != 0) {
    return 0;
  }
  sub_244D36E90(*(char **)(a1 + 24), *(int *)(a1 + 32), v3);
  return v3[0];
}

uint64_t sub_244D59D7C(uint64_t a1)
{
  return sub_244D59D88(*(void *)(*(void *)a1 + 24));
}

uint64_t sub_244D59D88(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  if ((sub_244D61F80(a1, 0) & 0x80000000) != 0) {
    return 0;
  }
  sub_244D2F954(*(char **)(*(void *)(a1 + 16) + 8), **(void **)(a1 + 16), v3);
  return v3[0];
}

uint64_t sub_244D59E04(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 40);
}

uint64_t sub_244D59E10(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 8);
}

uint64_t sub_244D59E1C(uint64_t a1)
{
  return sub_244D59D00(*(void *)(*(void *)a1 + 40));
}

uint64_t sub_244D59E28(uint64_t a1)
{
  return sub_244D59D88(*(void *)(*(void *)a1 + 40));
}

uint64_t sub_244D59E34(unint64_t *a1, unint64_t *a2)
{
  sub_244D5643C((uint64_t)a1);
  sub_244D5643C((uint64_t)a2);
  unint64_t v4 = bswap64(a1[13]);
  unint64_t v5 = bswap64(a2[13]);
  if (v4 == v5)
  {
    unint64_t v4 = bswap64(a1[14]);
    unint64_t v5 = bswap64(a2[14]);
    if (v4 == v5)
    {
      unint64_t v4 = bswap64(a1[15]);
      unint64_t v5 = bswap64(a2[15]);
      if (v4 == v5)
      {
        unint64_t v4 = bswap64(a1[16]);
        unint64_t v5 = bswap64(a2[16]);
        if (v4 == v5) {
          return 0;
        }
      }
    }
  }
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

unint64_t *sub_244D59ED8(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  if ((*(_DWORD *)(a3 + 4) | 0x100) != 0x102 || !sub_244D259E0((uint64_t)a1)) {
    return 0;
  }
  unint64_t v6 = 0;
  while (1)
  {
    uint64_t v7 = sub_244D4B518(a1, v6);
    if (!sub_244CF162C(*(void *)(*v7 + 8), a3)
      && !sub_244D59BA0(*(void *)(*v7 + 24), a2))
    {
      break;
    }
    if (++v6 >= sub_244D259E0((uint64_t)a1)) {
      return 0;
    }
  }
  return v7;
}

unint64_t *sub_244D59F80(unint64_t *a1, uint64_t a2)
{
  if (!sub_244D259E0((uint64_t)a1)) {
    return 0;
  }
  unint64_t v4 = 0;
  while (1)
  {
    unint64_t v5 = sub_244D4B518(a1, v4);
    if (!sub_244D59BA0(*(void *)(*v5 + 40), a2)) {
      break;
    }
    if (++v4 >= sub_244D259E0((uint64_t)a1)) {
      return 0;
    }
  }
  return v5;
}

uint64_t sub_244D59FF8(uint64_t result)
{
  if (result) {
    return sub_244D62A8C(*(void *)(*(void *)result + 48));
  }
  return result;
}

uint64_t sub_244D5A00C(uint64_t result)
{
  if (result) {
    return sub_244D62AD0(*(void *)(*(void *)result + 48));
  }
  return result;
}

uint64_t sub_244D5A020(uint64_t result)
{
  if (result) {
    return *(void *)(*(void *)(*(void *)result + 48) + 8);
  }
  return result;
}

uint64_t sub_244D5A034(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t result = sub_244D62A8C(*(void *)(*(void *)result + 48));
    if (result)
    {
      int v3 = sub_244D0C074(result, a2);
      if (v3 > 0) {
        return 1;
      }
      if (v3 == -2)
      {
        int v4 = 128;
        __int16 v5 = 261;
      }
      else if (v3 == -1)
      {
        int v4 = 115;
        __int16 v5 = 258;
      }
      else
      {
        if (v3) {
          return 0;
        }
        int v4 = 116;
        __int16 v5 = 255;
      }
      sub_244D0B884(11, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_cmp.c", v5);
      return 0;
    }
  }
  return result;
}

unint64_t *sub_244D5A0F0(uint64_t a1)
{
  int v1 = sub_244D4BA28(a1);
  unint64_t v2 = v1;
  if (v1 && sub_244D259E0((uint64_t)v1))
  {
    unint64_t v3 = 0;
    do
    {
      int v4 = sub_244D4B518(v2, v3);
      sub_244D49858((uint64_t)v4);
      ++v3;
    }
    while (v3 < sub_244D259E0((uint64_t)v2));
  }
  return v2;
}

uint64_t sub_244D5A150(uint64_t a1)
{
  return sub_244D5C0A4(*(void *)(*(void *)a1 + 48));
}

uint64_t sub_244D5A15C(uint64_t a1, unsigned int a2, int a3)
{
  return sub_244D5C0C4(*(unint64_t **)(*(void *)a1 + 48), a2, a3);
}

uint64_t sub_244D5A168(uint64_t a1, uint64_t a2, int a3)
{
  return sub_244D5C120(*(unint64_t **)(*(void *)a1 + 48), a2, a3);
}

uint64_t sub_244D5A174(uint64_t a1, int a2, int a3)
{
  return sub_244D5C1B8(*(unint64_t **)(*(void *)a1 + 48), a2, a3);
}

unint64_t *sub_244D5A180(uint64_t a1, unsigned int a2)
{
  return sub_244D5C278(*(unint64_t **)(*(void *)a1 + 48), a2);
}

uint64_t sub_244D5A18C(uint64_t a1, unsigned int a2)
{
  return sub_244D5C2D8(*(uint64_t **)(*(void *)a1 + 48), a2);
}

uint64_t sub_244D5A198(uint64_t a1, int a2, int *a3, _DWORD *a4)
{
  return sub_244D54A88(*(unint64_t **)(*(void *)a1 + 48), a2, a3, a4);
}

uint64_t sub_244D5A1A4(uint64_t a1, unsigned int a2, uint64_t a3, int a4, char a5)
{
  return sub_244D54BB0((unint64_t **)(*(void *)a1 + 48), a2, a3, a4, a5);
}

BOOL sub_244D5A1B0(uint64_t a1, uint64_t a2, int a3)
{
  return sub_244D5C338((unint64_t **)(*(void *)a1 + 48), a2, a3) != 0;
}

uint64_t sub_244D5A1D8(uint64_t a1)
{
  return sub_244D5C0A4(*(void *)(*(void *)a1 + 72));
}

uint64_t sub_244D5A1E4(uint64_t a1, unsigned int a2, int a3)
{
  return sub_244D5C0C4(*(unint64_t **)(*(void *)a1 + 72), a2, a3);
}

uint64_t sub_244D5A1F0(uint64_t a1, uint64_t a2, int a3)
{
  return sub_244D5C120(*(unint64_t **)(*(void *)a1 + 72), a2, a3);
}

uint64_t sub_244D5A1FC(uint64_t a1, int a2, int a3)
{
  return sub_244D5C1B8(*(unint64_t **)(*(void *)a1 + 72), a2, a3);
}

unint64_t *sub_244D5A208(uint64_t a1, unsigned int a2)
{
  return sub_244D5C278(*(unint64_t **)(*(void *)a1 + 72), a2);
}

uint64_t sub_244D5A214(uint64_t a1, unsigned int a2)
{
  return sub_244D5C2D8(*(uint64_t **)(*(void *)a1 + 72), a2);
}

BOOL sub_244D5A220(uint64_t a1, uint64_t a2, int a3)
{
  return sub_244D5C338((unint64_t **)(*(void *)a1 + 72), a2, a3) != 0;
}

uint64_t sub_244D5A248(uint64_t a1, int a2, int *a3, _DWORD *a4)
{
  return sub_244D54A88(*(unint64_t **)(*(void *)a1 + 72), a2, a3, a4);
}

uint64_t sub_244D5A254(uint64_t a1, unsigned int a2, uint64_t a3, int a4, char a5)
{
  return sub_244D54BB0((unint64_t **)(*(void *)a1 + 72), a2, a3, a4, a5);
}

uint64_t sub_244D5A260(uint64_t a1)
{
  return sub_244D5C0A4(*(void *)(a1 + 16));
}

uint64_t sub_244D5A268(uint64_t a1, unsigned int a2, int a3)
{
  return sub_244D5C0C4(*(unint64_t **)(a1 + 16), a2, a3);
}

uint64_t sub_244D5A270(uint64_t a1, uint64_t a2, int a3)
{
  return sub_244D5C120(*(unint64_t **)(a1 + 16), a2, a3);
}

uint64_t sub_244D5A278(uint64_t a1, int a2, int a3)
{
  return sub_244D5C1B8(*(unint64_t **)(a1 + 16), a2, a3);
}

unint64_t *sub_244D5A280(uint64_t a1, unsigned int a2)
{
  return sub_244D5C278(*(unint64_t **)(a1 + 16), a2);
}

uint64_t sub_244D5A288(uint64_t a1, unsigned int a2)
{
  return sub_244D5C2D8(*(uint64_t **)(a1 + 16), a2);
}

BOOL sub_244D5A290(uint64_t a1, uint64_t a2, int a3)
{
  return sub_244D5C338((unint64_t **)(a1 + 16), a2, a3) != 0;
}

uint64_t sub_244D5A2B4(uint64_t a1, int a2, int *a3, _DWORD *a4)
{
  return sub_244D54A88(*(unint64_t **)(a1 + 16), a2, a3, a4);
}

uint64_t sub_244D5A2BC(uint64_t a1, unsigned int a2, uint64_t a3, int a4, char a5)
{
  return sub_244D54BB0((unint64_t **)(a1 + 16), a2, a3, a4, a5);
}

void sub_244D5A2C4(void *a1)
{
  if (a1)
  {
    if (*a1)
    {
      unint64_t v2 = *(void (**)(void *))(*a1 + 8);
      if (v2) {
        v2(a1);
      }
    }
    sub_244D440EC(a1);
  }
}

uint64_t sub_244D5A318(uint64_t a1)
{
  if (!*(void *)a1) {
    return 0xFFFFFFFFLL;
  }
  int v1 = *(uint64_t (**)(void))(*(void *)a1 + 16);
  if (v1) {
    return v1();
  }
  else {
    return 1;
  }
}

void *sub_244D5A33C()
{
  unsigned int v0 = sub_244D44058(0xF0uLL);
  int v1 = v0;
  if (v0)
  {
    *((_DWORD *)v0 + 58) = 1;
    sub_244D4BD2C((pthread_rwlock_t *)(v0 + 1));
    void *v1 = sub_244D4B468((uint64_t)sub_244D5A3C4);
    v1[26] = sub_244D4B4C8();
    unint64_t v2 = sub_244D5E5B4();
    v1[27] = v2;
    if (!*v1 || !v1[26] || !v2)
    {
      sub_244D5A3D0((uint64_t)v1);
      return 0;
    }
  }
  return v1;
}

uint64_t sub_244D5A3C4(int **a1, uint64_t *a2)
{
  return sub_244D5B020(*a1, *a2);
}

void sub_244D5A3D0(uint64_t a1)
{
  if (a1 && sub_244D49A14((unsigned int *)(a1 + 232)))
  {
    j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 8));
    sub_244D4B564(*(unint64_t **)(a1 + 208), (void (*)(uint64_t))sub_244D5B068, (uint64_t)sub_244D5A2C4);
    sub_244D4B564(*(unint64_t **)a1, (void (*)(uint64_t))sub_244D5B074, (uint64_t)sub_244D5A4A0);
    sub_244D5E5DC(*(void *)(a1 + 216));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D5A480(uint64_t a1)
{
  return 1;
}

void sub_244D5A4A0(void *a1)
{
  if (a1)
  {
    sub_244D5A8AC((uint64_t)a1);
    sub_244D440EC(a1);
  }
}

unint64_t *sub_244D5A4E0(uint64_t a1, void *a2)
{
  int v4 = *(unint64_t **)(a1 + 208);
  if (!sub_244D259E0((uint64_t)v4))
  {
LABEL_5:
    uint64_t v7 = sub_244D44058(0x18uLL);
    int v8 = v7;
    if (v7)
    {
      *uint64_t v7 = a2;
      unint64_t v7[2] = a1;
      if (*a2 && !((unsigned int (*)(void *))*a2)(v7))
      {
        sub_244D440EC(v8);
        int v8 = 0;
      }
      else if (sub_244D4BA04(*(unint64_t **)(a1 + 208), (uint64_t)v8))
      {
        return v8;
      }
    }
    sub_244D5A2C4(v8);
    return 0;
  }
  unint64_t v5 = 0;
  while (1)
  {
    unint64_t v6 = sub_244D4B518(v4, v5);
    if ((void *)*v6 == a2) {
      return v6;
    }
    if (++v5 >= sub_244D259E0((uint64_t)v4)) {
      goto LABEL_5;
    }
  }
}

uint64_t sub_244D5A5B8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *a1;
  v15[0] = 0;
  v15[1] = 0;
  sub_244D4BD70((pthread_rwlock_t *)(v7 + 8));
  int v8 = *(unint64_t **)v7;
  int v9 = sub_244D5AB68(*(unint64_t **)v7, a2, a3, 0);
  if (v9 == -1) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = sub_244D4B518(v8, v9);
  }
  sub_244D4BD90((pthread_rwlock_t *)(v7 + 8));
  if (a2 == 2 || !v10)
  {
    if (sub_244D259E0(*(void *)(v7 + 208)))
    {
      unint64_t v11 = 0;
      while (1)
      {
        int v12 = sub_244D4B518(*(unint64_t **)(v7 + 208), v11);
        if (*v12)
        {
          uint64_t v13 = *(int (**)(unint64_t *, uint64_t))(*v12 + 24);
          if (v13)
          {
            if (v13(v12, a2) > 0) {
              break;
            }
          }
        }
        if (++v11 >= sub_244D259E0(*(void *)(v7 + 208))) {
          goto LABEL_12;
        }
      }
      uint64_t v10 = v15;
    }
    else
    {
LABEL_12:
      if (!v10) {
        return 0;
      }
    }
  }
  *(_DWORD *)a4 = *(_DWORD *)v10;
  *(void *)(a4 + 8) = v10[1];
  sub_244D5A6DC(a4);
  return 1;
}

uint64_t sub_244D5A6DC(uint64_t result)
{
  if (*(_DWORD *)result == 2 || *(_DWORD *)result == 1) {
    return sub_244D49858(*(void *)(result + 8));
  }
  return result;
}

uint64_t sub_244D5A704(uint64_t a1, uint64_t a2)
{
  return sub_244D5A70C(a1, a2, 0);
}

uint64_t sub_244D5A70C(uint64_t a1, uint64_t a2, int a3)
{
  if (a2)
  {
    unint64_t v6 = sub_244D44058(0x10uLL);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a3) {
        int v8 = 2;
      }
      else {
        int v8 = 1;
      }
      *(_DWORD *)unint64_t v6 = v8;
      v6[1] = a2;
      sub_244D5A6DC((uint64_t)v6);
      int v9 = (pthread_rwlock_t *)(a1 + 8);
      sub_244D4BD70((pthread_rwlock_t *)(a1 + 8));
      uint64_t v10 = *(unint64_t **)a1;
      sub_244D4BAAC(*(void *)a1, (uint64_t (*)(void, void, void))sub_244D5B080);
      unint64_t v15 = 0;
      if (sub_244D4B860((uint64_t)v10, &v15, (uint64_t)v7, (uint64_t (*)(void, uint64_t, void))sub_244D5B080))
      {
        unint64_t v11 = v15;
        if ((*(_DWORD *)v7 - 1) >= 2)
        {
          int v12 = sub_244D4B518(v10, v15);
LABEL_18:
          if (v12)
          {
LABEL_19:
            sub_244D4BD90((pthread_rwlock_t *)(a1 + 8));
            uint64_t v13 = 1;
            goto LABEL_22;
          }
        }
        else
        {
          while (v11 < sub_244D259E0((uint64_t)v10))
          {
            int v12 = sub_244D4B518(v10, v11);
            if (sub_244D5B020((int *)v12, (uint64_t)v7)) {
              break;
            }
            if (*(_DWORD *)v7 == 2)
            {
              if (!sub_244D59C70(v12[1], v7[1])) {
                goto LABEL_19;
              }
            }
            else
            {
              if (*(_DWORD *)v7 != 1) {
                goto LABEL_18;
              }
              if (!sub_244D59E34((unint64_t *)v12[1], (unint64_t *)v7[1])) {
                goto LABEL_19;
              }
            }
            ++v11;
          }
        }
      }
      uint64_t v13 = (uint64_t)sub_244D4BA04(*(unint64_t **)a1, (uint64_t)v7);
      sub_244D4BD90(v9);
      if (v13) {
        return 1;
      }
LABEL_22:
      sub_244D5A8AC((uint64_t)v7);
      sub_244D440EC(v7);
      return v13;
    }
  }
  return 0;
}

uint64_t sub_244D5A8A4(uint64_t a1, uint64_t a2)
{
  return sub_244D5A70C(a1, a2, 1);
}

void sub_244D5A8AC(uint64_t a1)
{
  if (*(_DWORD *)a1 == 2)
  {
    sub_244D61814(*(void *)(a1 + 8));
  }
  else if (*(_DWORD *)a1 == 1)
  {
    sub_244D62F44(*(void *)(a1 + 8));
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_244D5A8F8(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1) {
      return *(void *)(result + 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

unint64_t *sub_244D5A918(uint64_t a1)
{
  unint64_t v2 = (pthread_rwlock_t *)(a1 + 8);
  sub_244D4BD50((pthread_rwlock_t *)(a1 + 8));
  unint64_t v3 = sub_244D4BC58(*(void *)a1, (uint64_t (*)(uint64_t))sub_244D5B0B0, (uint64_t)sub_244D5A99C, (void (*)(uint64_t))sub_244D5B074, (uint64_t)sub_244D5A4A0);
  sub_244D4BD90(v2);
  return v3;
}

void *sub_244D5A99C(uint64_t a1)
{
  unint64_t v2 = sub_244D44058(0x10uLL);
  unint64_t v3 = v2;
  if (v2)
  {
    *(_DWORD *)unint64_t v2 = *(_DWORD *)a1;
    v2[1] = *(void *)(a1 + 8);
    sub_244D5A6DC((uint64_t)v2);
  }
  return v3;
}

unint64_t *sub_244D5A9E8(unint64_t ***a1, uint64_t a2)
{
  int v4 = sub_244D4B4C8();
  if (!v4) {
    return v4;
  }
  int v11 = 0;
  sub_244D4BD70((pthread_rwlock_t *)(*a1 + 1));
  unsigned int v5 = sub_244D5AB68(**a1, 1u, a2, &v11);
  if ((v5 & 0x80000000) != 0)
  {
    v10[0] = 0;
    v10[1] = 0;
    sub_244D4BD90((pthread_rwlock_t *)(*a1 + 1));
    if (sub_244D5A5B8((uint64_t *)a1, 1, a2, (uint64_t)v10))
    {
      sub_244D5A8AC((uint64_t)v10);
      sub_244D4BD70((pthread_rwlock_t *)(*a1 + 1));
      unsigned int v5 = sub_244D5AB68(**a1, 1u, a2, &v11);
      if ((v5 & 0x80000000) == 0) {
        goto LABEL_3;
      }
      sub_244D4BD90((pthread_rwlock_t *)(*a1 + 1));
    }
    sub_244CF474C((uint64_t)v4);
    return 0;
  }
LABEL_3:
  if (v11 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v5;
    while (1)
    {
      uint64_t v8 = sub_244D4B518(**a1, v7 + v6)[1];
      if (!sub_244D4BA04(v4, v8)) {
        break;
      }
      sub_244D49858(v8);
      if ((int)++v6 >= v11) {
        goto LABEL_7;
      }
    }
    sub_244D4BD90((pthread_rwlock_t *)(*a1 + 1));
    sub_244D4B564(v4, (void (*)(uint64_t))sub_244D5B0BC, (uint64_t)sub_244D62F44);
    return 0;
  }
LABEL_7:
  sub_244D4BD90((pthread_rwlock_t *)(*a1 + 1));
  return v4;
}

uint64_t sub_244D5AB68(unint64_t *a1, unsigned int a2, uint64_t a3, _DWORD *a4)
{
  v18[43] = *MEMORY[0x263EF8340];
  uint64_t v16 = 0;
  memset(v18, 0, 344);
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  memset(v17, 0, 88);
  long long v11 = 0u;
  memset(v12, 0, sizeof(v12));
  uint64_t v15 = a2;
  if (a2 == 2)
  {
    uint64_t v16 = v17;
    v17[0] = &v11;
    uint64_t v6 = v12;
  }
  else
  {
    if (a2 != 1) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v16 = v18;
    v18[0] = v13;
    uint64_t v6 = (void *)&v13[2] + 1;
  }
  *uint64_t v6 = a3;
  unint64_t v10 = 0;
  sub_244D4BAAC((uint64_t)a1, (uint64_t (*)(void, void, void))sub_244D5B080);
  if (!sub_244D4B860((uint64_t)a1, &v10, (uint64_t)&v15, (uint64_t (*)(void, uint64_t, void))sub_244D5B080))return 0xFFFFFFFFLL; {
  if (a4)
  }
  {
    *a4 = 1;
    for (unint64_t i = v10 + 1; i < sub_244D259E0((uint64_t)a1); ++i)
    {
      uint64_t v8 = (int *)sub_244D4B518(a1, i);
      if (sub_244D5B020(v8, (uint64_t)&v15)) {
        break;
      }
      ++*a4;
    }
  }
  return v10;
}

unint64_t *sub_244D5AD08(uint64_t *a1, uint64_t a2)
{
  int v4 = sub_244D4B4C8();
  if (!v4) {
    return v4;
  }
  int v11 = 0;
  v10[0] = 0;
  v10[1] = 0;
  if (!sub_244D5A5B8(a1, 2, a2, (uint64_t)v10))
  {
LABEL_10:
    sub_244CF474C((uint64_t)v4);
    return 0;
  }
  sub_244D5A8AC((uint64_t)v10);
  sub_244D4BD70((pthread_rwlock_t *)(*a1 + 8));
  unsigned int v5 = sub_244D5AB68(*(unint64_t **)*a1, 2u, a2, &v11);
  if ((v5 & 0x80000000) != 0)
  {
    sub_244D4BD90((pthread_rwlock_t *)(*a1 + 8));
    goto LABEL_10;
  }
  if (v11 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v5;
    while (1)
    {
      uint64_t v8 = sub_244D4B518(*(unint64_t **)*a1, v7 + v6)[1];
      sub_244D49858(v8);
      if (!sub_244D4BA04(v4, v8)) {
        break;
      }
      if ((int)++v6 >= v11) {
        goto LABEL_8;
      }
    }
    sub_244D4BD90((pthread_rwlock_t *)(*a1 + 8));
    sub_244D61814(v8);
    sub_244D4B564(v4, (void (*)(uint64_t))sub_244D5B0C8, (uint64_t)sub_244D61814);
    return 0;
  }
LABEL_8:
  sub_244D4BD90((pthread_rwlock_t *)(*a1 + 8));
  return v4;
}

uint64_t sub_244D5AE5C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v6 = sub_244D59CE8(a3);
  if (!sub_244D5A5B8(a2, 1, v6, (uint64_t)&v15)) {
    return 0;
  }
  uint64_t v7 = v16;
  if (sub_244D5CDB0((uint64_t)a2, a3, v16))
  {
    *a1 = v7;
    return 1;
  }
  else
  {
    sub_244D5A8AC((uint64_t)&v15);
    sub_244D4BD70((pthread_rwlock_t *)(*a2 + 8));
    int v9 = sub_244D5AB68(*(unint64_t **)*a2, 1u, v6, 0);
    if (v9 != -1)
    {
      LODWORD(i) = v9;
      if (sub_244D259E0(*(void *)*a2) > (unint64_t)v9)
      {
        for (unint64_t i = (int)i; i < sub_244D259E0(*(void *)*a2); ++i)
        {
          int v11 = sub_244D4B518(*(unint64_t **)*a2, i);
          if (*(_DWORD *)v11 != 1) {
            break;
          }
          uint64_t v12 = (uint64_t)v11;
          uint64_t v13 = sub_244D59E04(v11[1]);
          if (sub_244D59BA0(v6, v13)) {
            break;
          }
          if (sub_244D5CDB0((uint64_t)a2, a3, *(void *)(v12 + 8)))
          {
            *a1 = *(void *)(v12 + 8);
            sub_244D5A6DC(v12);
            uint64_t v8 = 1;
            goto LABEL_13;
          }
        }
      }
    }
    uint64_t v8 = 0;
LABEL_13:
    sub_244D4BD90((pthread_rwlock_t *)(*a2 + 8));
  }
  return v8;
}

uint64_t sub_244D5AFD0(uint64_t a1, uint64_t a2)
{
  return sub_244D5E89C(*(void *)(a1 + 216), a2);
}

uint64_t sub_244D5AFD8(uint64_t a1, int a2)
{
  return 1;
}

uint64_t sub_244D5AFF8(uint64_t a1, int a2)
{
  return sub_244D5E8C4(*(void *)(a1 + 216), a2);
}

uint64_t sub_244D5B000(uint64_t a1, int a2)
{
  return sub_244D5E920(*(void *)(a1 + 216), a2);
}

uint64_t sub_244D5B008(uint64_t a1, uint64_t a2)
{
  return sub_244D5E894(*(void *)(a1 + 216), a2);
}

uint64_t sub_244D5B010(uint64_t a1)
{
  return *(void *)(a1 + 216);
}

uint64_t sub_244D5B018(uint64_t result, uint64_t a2)
{
  *(void *)(result + 224) = a2;
  return result;
}

uint64_t sub_244D5B020(int *a1, uint64_t a2)
{
  int v2 = *a1;
  uint64_t v3 = (*a1 - *(_DWORD *)a2);
  if (*a1 != *(_DWORD *)a2) {
    return v3;
  }
  if (v2 == 2) {
    return sub_244D59C5C(*((void *)a1 + 1), *(void *)(a2 + 8));
  }
  if (v2 != 1) {
    return 0;
  }
  return sub_244D59C48(*((void *)a1 + 1), *(void *)(a2 + 8));
}

uint64_t sub_244D5B068(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5B074(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5B080(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D5B0B0(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5B0BC(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5B0C8(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

unsigned char *sub_244D5B0D4(uint64_t *a1, unsigned char *a2, int a3)
{
  uint64_t v3 = a2;
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v6 = sub_244CFAC60();
    if (!v6) {
      goto LABEL_66;
    }
    uint64_t v7 = v6;
    if (!sub_244CFAD1C(v6, 0xC8uLL))
    {
      uint64_t v6 = v7;
      goto LABEL_66;
    }
    *(unsigned char *)v7[1] = 0;
    if (a1)
    {
      int v36 = v7;
      unsigned int v5 = 200;
      goto LABEL_9;
    }
    uint64_t v3 = (unsigned char *)v7[1];
    sub_244D440EC(v7);
    unsigned int v5 = 200;
LABEL_62:
    sub_244D4476C(v3, "NO X509_NAME", v5);
    return v3;
  }
  unsigned int v5 = a3;
  if (a3 < 1) {
    return 0;
  }
  if (!a1) {
    goto LABEL_62;
  }
  int v36 = 0;
LABEL_9:
  if (!sub_244D259E0(*a1))
  {
    unint64_t v9 = 0;
LABEL_54:
    if (v36)
    {
      uint64_t v3 = (unsigned char *)v36[1];
      sub_244D440EC(v36);
      if (v9) {
        return v3;
      }
    }
    else
    {
LABEL_58:
      if (v9) {
        return v3;
      }
    }
    *uint64_t v3 = 0;
    return v3;
  }
  signed int v35 = v5;
  int v8 = 0;
  unint64_t v9 = 0;
  while (1)
  {
    unint64_t v10 = sub_244D4B518((unint64_t *)*a1, v9);
    unsigned int v11 = sub_244D449A4((unsigned __int16 *)*v10);
    if (!v11 || (uint64_t v12 = sub_244D44FD4(v11)) == 0)
    {
      uint64_t v12 = (char **)v37;
      sub_244CF2620(v37, 80, *v10);
    }
    unsigned int v13 = strlen((const char *)v12);
    uint64_t v14 = (unsigned int *)v10[1];
    uint64_t v15 = *v14;
    if ((int)v15 > 0x100000)
    {
      __int16 v33 = 121;
LABEL_64:
      sub_244D0B884(11, 0, 135, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_obj.c", v33);
      uint64_t v6 = v36;
      goto LABEL_66;
    }
    unsigned int v16 = v13;
    unsigned int v17 = v14[1];
    uint64_t v18 = *((void *)v14 + 1);
    if ((v15 & 3) != 0 || v17 != 27) {
      goto LABEL_26;
    }
    long long v38 = 0uLL;
    if ((int)v15 < 1) {
      goto LABEL_27;
    }
    for (uint64_t i = 0; i != v15; ++i)
    {
      if (*(unsigned char *)(v18 + i)) {
        *(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (i & 3))) = 1;
      }
    }
    if (!(DWORD1(v38) | v38 | DWORD2(v38)))
    {
LABEL_27:
      long long v21 = xmmword_244EBD820;
    }
    else
    {
LABEL_26:
      *(void *)&long long v21 = 0x100000001;
      *((void *)&v21 + 1) = 0x100000001;
    }
    long long v38 = v21;
    if ((int)v15 < 1)
    {
      int v23 = 0;
    }
    else
    {
      uint64_t v22 = 0;
      int v23 = 0;
      do
      {
        if (*(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (v22 & 3))))
        {
          if (*(unsigned __int8 *)(v18 + v22) - 127 >= 0xFFFFFFA1) {
            ++v23;
          }
          else {
            v23 += 4;
          }
        }
        ++v22;
      }
      while (v15 != v22);
    }
    int v24 = v8 + v13 + v23 + 2;
    if (v24 > 0x100000)
    {
      __int16 v33 = 157;
      goto LABEL_64;
    }
    if (!v36)
    {
      uint64_t v25 = v3;
      if (v24 >= v35) {
        goto LABEL_58;
      }
      goto LABEL_42;
    }
    if (!sub_244CFAD1C(v36, (int)(v8 + v13 + v23 + 3))) {
      break;
    }
    uint64_t v25 = (unsigned char *)v36[1];
LABEL_42:
    uint64_t v26 = &v25[v8];
    *uint64_t v26 = 47;
    uint64_t v27 = v26 + 1;
    if (v16) {
      memcpy(v27, v12, v16);
    }
    int v28 = &v27[v16];
    *int v28 = 61;
    unint64_t v29 = v28 + 1;
    if ((int)v15 >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = *(void *)(v10[1] + 8);
      do
      {
        if (*(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (v30 & 3))))
        {
          unint64_t v32 = *(unsigned __int8 *)(v31 + v30);
          if ((v32 - 127) > 0xFFFFFFA0)
          {
            *v29++ = v32;
          }
          else
          {
            *(_WORD *)unint64_t v29 = 30812;
            void v29[2] = a0123456789abcd_4[v32 >> 4];
            _OWORD v29[3] = a0123456789abcd_4[v32 & 0xF];
            v29 += 4;
          }
        }
        ++v30;
      }
      while (v15 != v30);
    }
    *unint64_t v29 = 0;
    ++v9;
    int v8 = v24;
    if (v9 >= sub_244D259E0(*a1)) {
      goto LABEL_54;
    }
  }
  uint64_t v6 = v36;
LABEL_66:
  sub_244CF474C((uint64_t)v6);
  return 0;
}

uint64_t sub_244D5B478(uint64_t a1)
{
  return sub_244CF1D00(*(void *)(*(void *)a1 + 24));
}

uint64_t sub_244D5B484(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 32);
}

uint64_t sub_244D5B490(uint64_t result)
{
  if (result) {
    return sub_244D62AD0(*(void *)(*(void *)result + 40));
  }
  return result;
}

uint64_t sub_244D5B4A4(uint64_t result)
{
  if (result) {
    return sub_244D62A8C(*(void *)(*(void *)result + 40));
  }
  return result;
}

uint64_t sub_244D5B4B8(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t result = sub_244D62A8C(*(void *)(*(void *)result + 40));
    if (result)
    {
      int v3 = sub_244D0C074(result, a2);
      if (v3 > 0) {
        return 1;
      }
      if (v3 == -2)
      {
        if (sub_244CF48E0(a2) == 408)
        {
          int v4 = 15;
          __int16 v5 = 113;
        }
        else
        {
          int v4 = 128;
          __int16 v5 = 115;
        }
      }
      else if (v3 == -1)
      {
        int v4 = 115;
        __int16 v5 = 109;
      }
      else
      {
        if (v3) {
          return 0;
        }
        int v4 = 116;
        __int16 v5 = 106;
      }
      sub_244D0B884(11, 0, v4, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_req.c", v5);
      return 0;
    }
  }
  return result;
}

BOOL sub_244D5B598(int a1)
{
  return (a1 - 171) < 2;
}

void *sub_244D5B5A8(void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if (!*result) {
      return 0;
    }
    int v2 = sub_244D44ED0(0xACu);
    if (!v2 || (unsigned int v3 = sub_244D5B840(v1, (uint64_t)v2, -1), v3 == -1))
    {
      uint64_t result = sub_244D44ED0(0xABu);
      if (!result) {
        return result;
      }
      unsigned int v3 = sub_244D5B840(v1, (uint64_t)result, -1);
      if (v3 == -1) {
        return 0;
      }
    }
    int v4 = sub_244D5B6D8(v1, v3);
    uint64_t result = sub_244D59B2C((uint64_t)v4, 0);
    if (!result) {
      return result;
    }
    if (*(_DWORD *)result == 16)
    {
      __int16 v5 = (int *)result[1];
      uint64_t v6 = *((void *)v5 + 1);
      return (void *)sub_244CF5200(0, &v6, *v5, (uint64_t)&unk_2651A88A0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D5B67C(uint64_t a1, unsigned int a2, int a3)
{
  __int16 v5 = sub_244D44ED0(a2);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }

  return sub_244D5B840(a1, (uint64_t)v5, a3);
}

unint64_t *sub_244D5B6D8(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(*(void *)a1 + 48);
  if (!v3 || sub_244D259E0(v3) <= (unint64_t)a2) {
    return 0;
  }
  __int16 v5 = *(unint64_t **)(*(void *)a1 + 48);

  return sub_244D4B518(v5, a2);
}

uint64_t sub_244D5B744(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v8 = 0;
  int v5 = sub_244CF6668(a2, &v8, (uint64_t)&unk_2651A88A0);
  if (v5 < 1) {
    return 0;
  }
  uint64_t v6 = sub_244D5B7C4(a1, a3, 16, (char *)v8, v5);
  sub_244D440EC(v8);
  return v6;
}

uint64_t sub_244D5B7C4(uint64_t a1, unsigned int a2, int a3, char *a4, int a5)
{
  uint64_t v6 = sub_244D5972C(0, a2, a3, a4, a5);
  if (v6 && sub_244D5B998(a1, (uint64_t)v6)) {
    return 1;
  }
  sub_244D616BC((uint64_t)v6);
  return 0;
}

uint64_t sub_244D5B818(uint64_t a1, uint64_t a2)
{
  return sub_244D5B744(a1, a2, 0xACu);
}

uint64_t sub_244D5B820(uint64_t a1)
{
  return sub_244D259E0(*(void *)(*(void *)a1 + 48));
}

uint64_t sub_244D5B840(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 48);
  if (v4)
  {
    int v7 = sub_244D259E0(v4);
    if (a3 < 0) {
      int v8 = -1;
    }
    else {
      int v8 = a3;
    }
    uint64_t v9 = v8;
    uint64_t v10 = v7;
    uint64_t v11 = 1;
    while (v9 + v11 < v10)
    {
      uint64_t v12 = (uint64_t *)sub_244D4B518(*(unint64_t **)(*(void *)a1 + 48), v9 + v11++);
      if (!sub_244D44948(*v12, a2)) {
        return (v9 + v11 - 1);
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D5B8D8(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(*(void *)a1 + 48);
  if (!v3 || sub_244D259E0(v3) <= (unint64_t)a2) {
    return 0;
  }
  int v5 = *(uint64_t **)(*(void *)a1 + 48);

  return sub_244D4B714(v5, a2);
}

uint64_t sub_244D5B944(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_244D616C8(a2);
  if (v3 && sub_244D5B998(a1, v3)) {
    return 1;
  }
  sub_244D616BC(v3);
  return 0;
}

unint64_t *sub_244D5B998(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(unint64_t **)(*(void *)a1 + 48);
  if (result) {
    return (unint64_t *)(sub_244D4BA04(result, a2) != 0);
  }
  *(void *)(*(void *)a1 + 48) = sub_244D4B4C8();
  uint64_t result = *(unint64_t **)(*(void *)a1 + 48);
  if (result) {
    return (unint64_t *)(sub_244D4BA04(result, a2) != 0);
  }
  return result;
}

uint64_t sub_244D5B9F0(uint64_t a1, uint64_t a2, int a3, char *a4, int a5)
{
  uint64_t v6 = sub_244D597BC(0, a2, a3, a4, a5);
  if (v6 && sub_244D5B998(a1, (uint64_t)v6)) {
    return 1;
  }
  sub_244D616BC((uint64_t)v6);
  return 0;
}

uint64_t sub_244D5BA44(uint64_t a1, const char *a2, int a3, char *a4, int a5)
{
  uint64_t v6 = sub_244D599DC(0, a2, a3, a4, a5);
  if (v6 && sub_244D5B998(a1, (uint64_t)v6)) {
    return 1;
  }
  sub_244D616BC((uint64_t)v6);
  return 0;
}

uint64_t sub_244D5BA98(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(result + 16);
  }
  if (a3) {
    *a3 = *(void *)(result + 8);
  }
  return result;
}

unsigned __int16 *sub_244D5BAB4(uint64_t a1)
{
  return sub_244D449A4(**(unsigned __int16 ***)(a1 + 8));
}

uint64_t sub_244D5BAC0(uint64_t *a1, void **a2)
{
  sub_244CF806C(*a1);
  uint64_t v4 = *a1;

  return sub_244D62CB8(v4, a2);
}

uint64_t sub_244D5BB04(uint64_t **a1)
{
  uint64_t result = **a1;
  if (result) {
    return sub_244CF1D00(result);
  }
  return result;
}

uint64_t sub_244D5BB18(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (a2 < 3)
    {
      uint64_t v3 = (uint64_t **)result;
      uint64_t result = **(void **)result;
      if (a2)
      {
        if (result || (**uint64_t v3 = (uint64_t)sub_244CF7CD8(), (result = **v3) != 0))
        {
          return sub_244CF1A64(result, a2);
        }
      }
      else
      {
        sub_244CF7CBC(result);
        **uint64_t v3 = 0;
        return 1;
      }
    }
    else
    {
      sub_244D0B884(11, 0, 140, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_set.c", 80);
      return 0;
    }
  }
  return result;
}

BOOL sub_244D5BBC4(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 4) | 0x100) != 0x102)
  {
    sub_244D0B884(12, 0, 191, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_set.c", 102);
    return 0;
  }
  if (!a1) {
    return 0;
  }
  uint64_t v3 = a2;
  if (*(void *)(*(void *)a1 + 8) != a2)
  {
    uint64_t v3 = sub_244CF1628(a2);
    if (v3)
    {
      sub_244CF7CBC(*(void *)(*(void *)a1 + 8));
      *(void *)(*(void *)a1 + 8) = v3;
    }
  }
  return v3 != 0;
}

uint64_t sub_244D5BC5C(uint64_t a1, uint64_t a2)
{
  if (a1 && *(void *)a1) {
    return sub_244D61FB4((uint64_t *)(*(void *)a1 + 24), a2);
  }
  else {
    return 0;
  }
}

uint64_t sub_244D5BC78(uint64_t a1, uint64_t a2)
{
  if (a1 && *(void *)a1) {
    return sub_244D61FB4((uint64_t *)(*(void *)a1 + 40), a2);
  }
  else {
    return 0;
  }
}

BOOL sub_244D5BC94(BOOL result, int *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(int ***)(*(void *)result + 32);
    if (v3)
    {
      uint64_t v4 = a2;
      if (*v3 != a2)
      {
        uint64_t v4 = sub_244CF4698(a2);
        if (v4)
        {
          sub_244CF3890(**(void **)(*(void *)v2 + 32));
          **(void **)(*(void *)v2 + 32) = v4;
        }
      }
      return v4 != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D5BD18(uint64_t a1)
{
  return **(void **)(*(void *)a1 + 32);
}

BOOL sub_244D5BD28(BOOL result, int *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(*(void *)result + 32);
    if (v3)
    {
      uint64_t v4 = a2;
      if (*(int **)(v3 + 8) != a2)
      {
        uint64_t v4 = sub_244CF4698(a2);
        if (v4)
        {
          sub_244CF3890(*(void *)(*(void *)(*(void *)v2 + 32) + 8));
          *(void *)(*(void *)(*(void *)v2 + 32) + 8) = v4;
        }
      }
      return v4 != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D5BDAC(uint64_t a1)
{
  return *(void *)(*(void *)(*(void *)a1 + 32) + 8);
}

uint64_t sub_244D5BDBC(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(*(void *)result + 56);
  }
  if (a3) {
    *a3 = *(void *)(*(void *)result + 64);
  }
  return result;
}

uint64_t sub_244D5BDE0(void *a1, uint64_t a2)
{
  if (a1 && *a1) {
    return sub_244D62950(*a1 + 48, a2);
  }
  else {
    return 0;
  }
}

uint64_t sub_244D5BDFC(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 72);
}

uint64_t sub_244D5BE08(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 16);
}

uint64_t sub_244D5BE14(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 48);
}

uint64_t sub_244D5BE20(uint64_t a1, int a2)
{
  if (a2 == -1) {
    return 1;
  }
  if (a2)
  {
    uint64_t v5 = 0;
    while (dword_26F9561E8[v5] != a2)
    {
      v5 += 6;
      if (v5 == 36)
      {
        return sub_244D5BEF8(a2, a1);
      }
    }
    uint64_t v6 = *(uint64_t (**)(void))&dword_26F9561E8[v5 + 2];
    return v6();
  }
  else
  {
    uint64_t result = sub_244D5BEF8(910, a1);
    if (result == 3)
    {
      BOOL v4 = sub_244D5643C(a1);
      uint64_t result = 3;
      if (v4)
      {
        if ((*(unsigned char *)(a1 + 49) & 0x20) != 0) {
          return 1;
        }
        else {
          return 3;
        }
      }
    }
  }
  return result;
}

uint64_t sub_244D5BEF8(int a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 136);
  if (!v2) {
    return 3;
  }
  if (!sub_244D259E0(*(void *)(v2 + 8)))
  {
LABEL_6:
    if (sub_244D259E0(*(void *)v2))
    {
      unint64_t v6 = 0;
      while (1)
      {
        int v7 = (unsigned __int16 *)sub_244D4B518(*(unint64_t **)v2, v6);
        if (sub_244D449A4(v7) == a1) {
          break;
        }
        if (++v6 >= sub_244D259E0(*(void *)v2)) {
          return 3;
        }
      }
      return 1;
    }
    return 3;
  }
  unint64_t v4 = 0;
  while (1)
  {
    uint64_t v5 = (unsigned __int16 *)sub_244D4B518(*(unint64_t **)(v2 + 8), v4);
    if (sub_244D449A4(v5) == a1) {
      return 2;
    }
    if (++v4 >= sub_244D259E0(*(void *)(v2 + 8))) {
      goto LABEL_6;
    }
  }
}

uint64_t sub_244D5BFB4(uint64_t a1, uint64_t a2)
{
  BOOL v3 = sub_244D5643C(a2);
  uint64_t result = 3;
  if (v3)
  {
    if ((*(unsigned char *)(a2 + 49) & 0x20) != 0) {
      return 1;
    }
    else {
      return 3;
    }
  }
  return result;
}

BOOL sub_244D5BFF4(int a1)
{
  uint64_t v1 = 0;
  do
  {
    int v2 = dword_26F9561E8[v1];
    if (v2 == a1) {
      break;
    }
    BOOL v3 = v1 == 30;
    v1 += 6;
  }
  while (!v3);
  return v2 == a1;
}

uint64_t sub_244D5C028(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(void **)(a2 + 136);
  if (v3 && (*v3 || v3[1]))
  {
    int v4 = *(_DWORD *)(a1 + 16);
    return sub_244D5BEF8(v4, a2);
  }
  else
  {
    BOOL v6 = sub_244D5643C(a2);
    uint64_t result = 3;
    if (v6)
    {
      if ((*(unsigned char *)(a2 + 49) & 0x20) != 0) {
        return 1;
      }
      else {
        return 3;
      }
    }
  }
  return result;
}

uint64_t sub_244D5C0A4(uint64_t result)
{
  if (result) {
    return sub_244D259E0(result);
  }
  return result;
}

uint64_t sub_244D5C0C4(unint64_t *a1, unsigned int a2, int a3)
{
  uint64_t v5 = sub_244D44ED0(a2);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }

  return sub_244D5C120(a1, (uint64_t)v5, a3);
}

uint64_t sub_244D5C120(unint64_t *a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v6 = sub_244D259E0((uint64_t)a1);
  if (a3 < 0) {
    int v7 = -1;
  }
  else {
    int v7 = a3;
  }
  uint64_t v8 = v7;
  uint64_t v9 = v6;
  uint64_t v10 = 1;
  while (v8 + v10 < v9)
  {
    uint64_t v11 = (uint64_t *)sub_244D4B518(a1, v8 + v10++);
    if (!sub_244D44948(*v11, a2)) {
      return (v8 + v10 - 1);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D5C1B8(unint64_t *a1, int a2, int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v5 = a2 != 0;
  int v6 = sub_244D259E0((uint64_t)a1);
  if (a3 < 0) {
    int v7 = -1;
  }
  else {
    int v7 = a3;
  }
  uint64_t v8 = v7;
  uint64_t v9 = v6;
  uint64_t v10 = 1;
  while (v8 + v10 < v9)
  {
    uint64_t v11 = sub_244D4B518(a1, v8 + v10);
    if (v11) {
      int v12 = *((_DWORD *)v11 + 2) > 0;
    }
    else {
      int v12 = 0;
    }
    ++v10;
    if (v12 == v5) {
      return (v8 + v10 - 1);
    }
  }
  return 0xFFFFFFFFLL;
}

BOOL sub_244D5C264(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 8) > 0;
  }
  return result;
}

unint64_t *sub_244D5C278(unint64_t *a1, unsigned int a2)
{
  if (!a1 || (a2 & 0x80000000) != 0 || sub_244D259E0((uint64_t)a1) <= (unint64_t)a2) {
    return 0;
  }

  return sub_244D4B518(a1, a2);
}

uint64_t sub_244D5C2D8(uint64_t *a1, unsigned int a2)
{
  if (!a1 || (a2 & 0x80000000) != 0 || sub_244D259E0((uint64_t)a1) <= (unint64_t)a2) {
    return 0;
  }

  return sub_244D4B714(a1, a2);
}

unint64_t *sub_244D5C338(unint64_t **a1, uint64_t a2, int a3)
{
  if (!a1)
  {
    sub_244D0B884(11, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_v3.c", 149);
LABEL_15:
    sub_244D61F18(0);
    return 0;
  }
  int v6 = *a1;
  int v7 = *a1;
  if (!*a1)
  {
    int v7 = sub_244D4B4C8();
    if (!v7) {
      goto LABEL_15;
    }
  }
  int v8 = sub_244D259E0((uint64_t)v7);
  uint64_t v9 = sub_244D61F3C(a2);
  if (!v9 || (v8 >= a3 ? (BOOL v10 = a3 < 0) : (BOOL v10 = 1), !v10 ? (v11 = a3) : (v11 = v8), !sub_244D4B60C(v7, v9, v11)))
  {
    sub_244D61F18(v9);
    if (!v6) {
      sub_244CF474C((uint64_t)v7);
    }
    return 0;
  }
  if (!*a1) {
    *a1 = v7;
  }
  return v7;
}

uint64_t sub_244D5C41C(uint64_t *a1, unsigned int a2, int a3, uint64_t a4)
{
  int v7 = sub_244D44ED0(a2);
  if (v7)
  {
    return sub_244D5C4A4(a1, (uint64_t)v7, a3, a4);
  }
  else
  {
    sub_244D0B884(11, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_v3.c", 196);
    return 0;
  }
}

uint64_t sub_244D5C4A4(uint64_t *a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a1 && (uint64_t v8 = *a1) != 0 || (uint64_t v8 = sub_244D61F0C()) != 0)
  {
    if (sub_244D59870((const char ***)v8, a2)
      && (!a3 ? (int v9 = -1) : (int v9 = 255),
          *(_DWORD *)(v8 + 8) = v9,
          sub_244CF2A68(*(void *)(v8 + 16), *(char **)(a4 + 8), *(_DWORD *)a4)))
    {
      if (a1 && !*a1) {
        *a1 = v8;
      }
    }
    else
    {
      if (!a1 || v8 != *a1) {
        sub_244D61F18(v8);
      }
      return 0;
    }
  }
  return v8;
}

uint64_t sub_244D5C560(uint64_t result, int a2)
{
  if (result)
  {
    if (a2) {
      int v2 = 255;
    }
    else {
      int v2 = -1;
    }
    *(_DWORD *)(result + 8) = v2;
    return 1;
  }
  return result;
}

BOOL sub_244D5C57C(BOOL result, uint64_t a2)
{
  if (result) {
    return sub_244CF2A68(*(void *)(result + 16), *(char **)(a2 + 8), *(_DWORD *)a2) != 0;
  }
  return result;
}

uint64_t sub_244D5C5B4(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t sub_244D5C5C0(uint64_t a1)
{
  if (!*(void *)(a1 + 8))
  {
    int v2 = 122;
    __int16 v3 = 184;
    goto LABEL_7;
  }
  if (*(void *)(a1 + 64))
  {
    int v2 = 66;
    __int16 v3 = 192;
LABEL_7:
    sub_244D0B884(11, 0, v2, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_vfy.c", v3);
    uint64_t v5 = 0;
    int v6 = 65;
LABEL_8:
    *(_DWORD *)(a1 + 76) = v6;
    return v5;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v4 + 9) & 0x30) != 0)
  {
    int v2 = 66;
    __int16 v3 = 202;
    goto LABEL_7;
  }
  uint64_t v8 = sub_244D4B4C8();
  *(void *)(a1 + 64) = v8;
  if (!v8 || !sub_244D4BA04(v8, *(void *)(a1 + 8)))
  {
    uint64_t v11 = 0;
    uint64_t v5 = 0;
    BOOL v10 = 0;
LABEL_16:
    int v12 = 17;
    goto LABEL_17;
  }
  sub_244D49858(*(void *)(a1 + 8));
  *(_DWORD *)(a1 + 56) = 1;
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    BOOL v10 = sub_244D4BA28(v9);
    if (!v10)
    {
LABEL_14:
      uint64_t v11 = 0;
LABEL_92:
      uint64_t v5 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v10 = 0;
  }
  int v14 = sub_244D259E0(*(void *)(a1 + 64));
  uint64_t v15 = sub_244D4B518(*(unint64_t **)(a1 + 64), v14 - 1);
  int v16 = *(_DWORD *)(v4 + 24);
  if (v16 <= 2147483644) {
    int v17 = v16 + 2;
  }
  else {
    int v17 = 0x7FFFFFFF;
  }
  if (v17 <= v14)
  {
LABEL_37:
    int v19 = v14;
    goto LABEL_38;
  }
  uint64_t v18 = (uint64_t)v15;
  int v19 = v14;
  while (sub_244D5643C(v18))
  {
    if ((*(unsigned char *)(v18 + 49) & 0x20) != 0) {
      goto LABEL_38;
    }
    if ((*(unsigned char *)(*(void *)(a1 + 32) + 9) & 0x80) != 0)
    {
      uint64_t v20 = sub_244D5CCB8((uint64_t *)a1, v18);
      if (v20)
      {
        sub_244D62F44(v20);
LABEL_38:
        int v49 = v17;
        uint64_t v11 = 0;
        int v13 = 0;
        int v22 = v19;
        while (2)
        {
          int v23 = sub_244D259E0(*(void *)(a1 + 64)) - 1;
          int v24 = sub_244D4B518(*(unint64_t **)(a1 + 64), v23);
          if (!sub_244D5643C((uint64_t)v24)) {
            goto LABEL_94;
          }
          if ((*((unsigned char *)v24 + 49) & 0x20) == 0)
          {
            uint64_t v25 = (uint64_t)v24;
            goto LABEL_49;
          }
          if (sub_244D259E0(*(void *)(a1 + 64)) == 1)
          {
            uint64_t v25 = sub_244D5CCB8((uint64_t *)a1, (uint64_t)v24);
            if (!v25 || sub_244D59E34(v24, (unint64_t *)v25))
            {
              sub_244D62F44(v25);
              *(void *)(a1 + 80) = v24;
              *(_DWORD *)(a1 + 72) = v23;
              *(_DWORD *)(a1 + 76) = 18;
              unsigned int v26 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
              if (v26 >= 2) {
                goto LABEL_112;
              }
              int v13 = 1;
              int v27 = v49;
              if (!v26) {
                goto LABEL_110;
              }
              uint64_t v25 = (uint64_t)v24;
              goto LABEL_50;
            }
            sub_244D62F44((uint64_t)v24);
            sub_244D4B53C(*(unint64_t **)(a1 + 64), v23, v25);
            *(_DWORD *)(a1 + 56) = 0;
          }
          else
          {
            uint64_t v11 = sub_244D4BA0C(*(uint64_t **)(a1 + 64));
            --*(_DWORD *)(a1 + 56);
            --v19;
            uint64_t v25 = (uint64_t)sub_244D4B518(*(unint64_t **)(a1 + 64), v22 - 2);
            --v22;
          }
LABEL_49:
          int v27 = v49;
LABEL_50:
          if (v22 >= v27) {
            goto LABEL_57;
          }
          do
          {
            if (!sub_244D5643C(v25)) {
              goto LABEL_94;
            }
            if ((*(unsigned char *)(v25 + 49) & 0x20) != 0) {
              goto LABEL_57;
            }
            uint64_t v28 = sub_244D5CCB8((uint64_t *)a1, v25);
            if (!v28) {
              goto LABEL_57;
            }
            uint64_t v29 = v28;
            if (!sub_244D4BA04(*(unint64_t **)(a1 + 64), v28))
            {
              sub_244D62F44(v29);
              goto LABEL_92;
            }
            ++v22;
            uint64_t v25 = v29;
          }
          while (v27 != v22);
          int v22 = v27;
          uint64_t v25 = v29;
LABEL_57:
          for (unint64_t i = *(int *)(a1 + 56); i < sub_244D259E0(*(void *)(a1 + 64)); ++i)
          {
            uint64_t v31 = sub_244D4B518(*(unint64_t **)(a1 + 64), i);
            int v32 = sub_244D5BE20((uint64_t)v31, *(_DWORD *)(*(void *)(a1 + 32) + 20));
            if (v32 == 2)
            {
              *(void *)(a1 + 80) = v31;
              *(_DWORD *)(a1 + 72) = i;
              *(_DWORD *)(a1 + 76) = 28;
              unsigned int v33 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
              if (v33 >= 2) {
                goto LABEL_112;
              }
              if (!v33) {
                goto LABEL_109;
              }
            }
            else if (v32 == 1)
            {
              goto LABEL_101;
            }
          }
          if ((*(unsigned char *)(*(void *)(a1 + 32) + 10) & 8) == 0) {
            goto LABEL_76;
          }
          int v34 = *(_DWORD *)(a1 + 56);
          if (v34 < (int)sub_244D259E0(*(void *)(a1 + 64)))
          {
LABEL_101:
            if (sub_244D5CE20(a1)
              && sub_244D5CFCC(a1)
              && sub_244D5D168(a1)
              && sub_244D5D51C(a1)
              && sub_244D5D7B0(a1)
              && (v13 || sub_244D5D9A8(a1)))
            {
              int v13 = 0;
              uint64_t v5 = 1;
              goto LABEL_19;
            }
LABEL_109:
            uint64_t v5 = 0;
            goto LABEL_18;
          }
          signed int v35 = sub_244D4B518(*(unint64_t **)(a1 + 64), 0);
          uint64_t v36 = sub_244D59E04((uint64_t)v35);
          long long v37 = sub_244D5A9E8((unint64_t ***)a1, v36);
          if (v37)
          {
            long long v38 = v37;
            uint64_t v48 = v11;
            unint64_t v39 = 0;
            if (sub_244D259E0((uint64_t)v37))
            {
              do
              {
                uint64_t v40 = sub_244D4B518(v38, v39);
                if (!sub_244D59E34(v40, v35)) {
                  break;
                }
                ++v39;
              }
              while (v39 < sub_244D259E0((uint64_t)v38));
            }
            else
            {
              uint64_t v40 = 0;
            }
            if (v39 >= sub_244D259E0((uint64_t)v38))
            {
              sub_244D4B564(v38, (void (*)(uint64_t))sub_244D5E5A8, (uint64_t)sub_244D62F44);
              uint64_t v11 = v48;
            }
            else
            {
              sub_244D49858((uint64_t)v40);
              sub_244D4B564(v38, (void (*)(uint64_t))sub_244D5E5A8, (uint64_t)sub_244D62F44);
              uint64_t v11 = v48;
              if (v40)
              {
                sub_244D4B53C(*(unint64_t **)(a1 + 64), 0, (uint64_t)v40);
                sub_244D62F44((uint64_t)v35);
                *(_DWORD *)(a1 + 56) = 0;
                goto LABEL_101;
              }
            }
          }
LABEL_76:
          if ((*(_DWORD *)(*(void *)(a1 + 32) + 8) & 0x108000) != 0)
          {
LABEL_86:
            if (v13) {
              goto LABEL_101;
            }
            if (v11 && sub_244D5CDB0(a1, v25, v11))
            {
              if (!sub_244D4BA04(*(unint64_t **)(a1 + 64), v11)) {
                goto LABEL_92;
              }
              *(_DWORD *)(a1 + 56) = ++v22;
              *(void *)(a1 + 80) = v11;
              *(_DWORD *)(a1 + 76) = 19;
              uint64_t v11 = 0;
            }
            else
            {
              if (*(_DWORD *)(a1 + 56) >= v22) {
                int v46 = 20;
              }
              else {
                int v46 = 2;
              }
              *(_DWORD *)(a1 + 76) = v46;
              *(void *)(a1 + 80) = v25;
            }
            *(_DWORD *)(a1 + 72) = v22 - 1;
            unsigned int v47 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
            if (v47 >= 2) {
LABEL_112:
            }
              abort();
            int v13 = 1;
            if (v47) {
              goto LABEL_101;
            }
LABEL_110:
            uint64_t v5 = 0;
            goto LABEL_19;
          }
          unsigned int v41 = v19 - 2;
          do
          {
            if (v19 < 2) {
              goto LABEL_86;
            }
            --v19;
            unint64_t v42 = sub_244D4B518(*(unint64_t **)(a1 + 64), v41);
            uint64_t v43 = sub_244D5CCB8((uint64_t *)a1, (uint64_t)v42);
            --v41;
          }
          while (!v43);
          sub_244D62F44(v43);
          if (v22 >= v19 + 1)
          {
            int v44 = v22 + 1;
            do
            {
              uint64_t v45 = sub_244D4BA0C(*(uint64_t **)(a1 + 64));
              sub_244D62F44(v45);
              --v44;
            }
            while (v44 > v19 + 1);
            int v22 = v19;
          }
          *(_DWORD *)(a1 + 56) = sub_244D259E0(*(void *)(a1 + 64));
          continue;
        }
      }
    }
    if (!v10) {
      goto LABEL_37;
    }
    long long v21 = sub_244D5CD28(a1, v10, v18);
    if (!v21) {
      goto LABEL_38;
    }
    uint64_t v18 = (uint64_t)v21;
    if (!sub_244D4BA04(*(unint64_t **)(a1 + 64), (uint64_t)v21)) {
      goto LABEL_14;
    }
    sub_244D49858(v18);
    sub_244D4B78C((uint64_t *)v10, v18);
    ++*(_DWORD *)(a1 + 56);
    if (v17 == ++v19)
    {
      int v19 = v17;
      goto LABEL_38;
    }
  }
  uint64_t v11 = 0;
LABEL_94:
  uint64_t v5 = 0;
  int v12 = 41;
LABEL_17:
  *(_DWORD *)(a1 + 76) = v12;
LABEL_18:
  int v13 = 1;
LABEL_19:
  sub_244CF474C((uint64_t)v10);
  sub_244D62F44(v11);
  if (v13 && !*(_DWORD *)(a1 + 76))
  {
    int v6 = 1;
    goto LABEL_8;
  }
  return v5;
}

uint64_t sub_244D5CCB8(uint64_t *a1, uint64_t a2)
{
  __int16 v3 = (unint64_t *)a1[5];
  if (v3)
  {
    uint64_t v4 = sub_244D5CD28((uint64_t)a1, v3, a2);
    uint64_t v5 = v4;
    if (v4) {
      sub_244D49858((uint64_t)v4);
    }
  }
  else
  {
    uint64_t v7 = 0;
    if (sub_244D5AE5C(&v7, a1, a2)) {
      return v7;
    }
    else {
      return 0;
    }
  }
  return (uint64_t)v5;
}

unint64_t *sub_244D5CD28(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  if (!sub_244D259E0((uint64_t)a2)) {
    return 0;
  }
  unint64_t v6 = 0;
  while (1)
  {
    uint64_t v7 = sub_244D4B518(a2, v6);
    if (sub_244D5CDB0(a1, a3, (uint64_t)v7)) {
      break;
    }
    if (++v6 >= sub_244D259E0((uint64_t)a2)) {
      return 0;
    }
  }
  return v7;
}

uint64_t sub_244D5CDB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = sub_244D56C3C(a3, a2);
  if (!v5) {
    return 1;
  }
  if ((*(unsigned char *)(*(void *)(a1 + 32) + 8) & 1) == 0) {
    return 0;
  }
  *(_DWORD *)(a1 + 76) = v5;
  *(void *)(a1 + 80) = a2;
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2) {
    abort();
  }
  return result;
}

uint64_t sub_244D5CE20(uint64_t a1)
{
  if (*(int *)(a1 + 56) < 1) {
    return 1;
  }
  unint64_t v2 = 0;
  uint64_t v3 = 0;
  int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 16);
  while (1)
  {
    int v5 = sub_244D4B518(*(unint64_t **)(a1 + 64), v2);
    uint64_t v6 = (uint64_t)v5;
    if ((*(unsigned char *)(*(void *)(a1 + 32) + 8) & 0x10) == 0 && (*((unsigned char *)v5 + 49) & 2) != 0)
    {
      *(_DWORD *)(a1 + 72) = v2;
      *(_DWORD *)(a1 + 76) = 34;
      *(void *)(a1 + 80) = v5;
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
      if (result >= 2) {
        goto LABEL_27;
      }
      if (!result) {
        return result;
      }
    }
    if (v2)
    {
      uint64_t v8 = sub_244D56BE4(v6);
      if (!v8)
      {
        *(_DWORD *)(a1 + 72) = v2;
        *(_DWORD *)(a1 + 76) = 24;
        *(void *)(a1 + 80) = v6;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(v8, a1);
        if (result >= 2) {
          goto LABEL_27;
        }
        if (!result) {
          return result;
        }
      }
    }
    if (*(int *)(*(void *)(a1 + 32) + 16) >= 1 && sub_244D56364(v6, v4, v2 != 0) != 1)
    {
      *(_DWORD *)(a1 + 72) = v2;
      *(_DWORD *)(a1 + 76) = 26;
      *(void *)(a1 + 80) = v6;
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
      if (result >= 2) {
        goto LABEL_27;
      }
      if (!result) {
        return result;
      }
    }
    if (v2 >= 2 && (*(unsigned char *)(v6 + 48) & 0x20) == 0)
    {
      uint64_t v9 = *(void *)(v6 + 40);
      if (v9 != -1 && v9 + 1 < v3)
      {
        *(_DWORD *)(a1 + 72) = v2;
        *(_DWORD *)(a1 + 76) = 25;
        *(void *)(a1 + 80) = v6;
        uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
        if (result >= 2) {
LABEL_27:
        }
          abort();
        if (!result) {
          return result;
        }
      }
    }
    v3 += (*(_DWORD *)(v6 + 48) & 0x20) == 0;
    if ((uint64_t)++v2 >= *(int *)(a1 + 56)) {
      return 1;
    }
  }
}

uint64_t sub_244D5CFCC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v2 + 88))
  {
    *(void *)(a1 + 80) = v3;
    *(void *)(a1 + 72) = 0x4100000000;
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2) {
      goto LABEL_21;
    }
    if (!result) {
      return result;
    }
  }
  uint64_t v5 = *(void *)(v2 + 40);
  if (v5)
  {
    uint64_t v6 = sub_244D259E0(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      for (unint64_t i = 0; i != v7; ++i)
      {
        uint64_t v9 = sub_244D4B518(*(unint64_t **)(v2 + 40), i);
        size_t v10 = strlen((const char *)v9);
        if ((int)sub_244D58550(v3, v9, v10, *(unsigned int *)(v2 + 48), 0) > 0) {
          goto LABEL_11;
        }
      }
      *(void *)(a1 + 80) = *(void *)(a1 + 8);
      *(void *)(a1 + 72) = 0x3E00000000;
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
      if (result >= 2) {
        goto LABEL_21;
      }
      if (!result) {
        return result;
      }
    }
  }
LABEL_11:
  uint64_t v11 = *(void **)(v2 + 56);
  if (v11 && (int)sub_244D587D4(v3, v11, *(void *)(v2 + 64), 0) <= 0)
  {
    *(void *)(a1 + 80) = *(void *)(a1 + 8);
    *(void *)(a1 + 72) = 0x3F00000000;
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2) {
      goto LABEL_21;
    }
    if (!result) {
      return result;
    }
  }
  int v12 = *(void **)(v2 + 72);
  if (v12 && (int)sub_244D58860(v3, v12, *(void *)(v2 + 80), 0) <= 0)
  {
    *(void *)(a1 + 80) = *(void *)(a1 + 8);
    *(void *)(a1 + 72) = 0x4000000000;
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
    if (result < 2)
    {
      if (!result) {
        return result;
      }
      return 1;
    }
LABEL_21:
    abort();
  }
  return 1;
}

uint64_t sub_244D5D168(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  if ((v1 & 4) == 0) {
    return 1;
  }
  if ((v1 & 8) == 0)
  {
    unsigned int v4 = 0;
LABEL_6:
    unint64_t v6 = 0;
    BOOL v7 = 0;
    uint64_t v8 = v4 + 1;
    unint64_t v9 = v4;
    while (1)
    {
      *(_DWORD *)(a1 + 72) = v6;
      size_t v10 = sub_244D4B518(*(unint64_t **)(a1 + 64), v6);
      *(void *)(a1 + 80) = v10;
      *(void *)(a1 + 96) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      signed int v35 = 0;
      int v34 = 0;
      uint64_t v33 = 0;
      if (!sub_244D5DFF0(a1, &v33, (unint64_t **)&v35, &v34, *(unint64_t **)(a1 + 24)))
      {
        uint64_t v11 = sub_244D59CE8((uint64_t)v10);
        int v12 = sub_244D5AD08((uint64_t *)a1, v11);
        uint64_t v13 = v33;
        if (v12) {
          BOOL v14 = 1;
        }
        else {
          BOOL v14 = v33 == 0;
        }
        if (!v14) {
          goto LABEL_15;
        }
        uint64_t v15 = v12;
        sub_244D5DFF0(a1, &v33, (unint64_t **)&v35, &v34, v12);
        sub_244D4B564(v15, (void (*)(uint64_t))sub_244D5E59C, (uint64_t)sub_244D61814);
      }
      uint64_t v13 = v33;
      if (!v33)
      {
        *(_DWORD *)(a1 + 76) = 3;
        unsigned int v22 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
        if (v22 >= 2) {
          goto LABEL_56;
        }
        unsigned int v23 = v22;
        sub_244D61814(0);
        *(void *)(a1 + 88) = 0;
        if (!v23) {
          return v7;
        }
        goto LABEL_51;
      }
LABEL_15:
      int v16 = v35;
      *(_DWORD *)(a1 + 104) = v34;
      *(void *)(a1 + 88) = v13;
      *(void *)(a1 + 96) = v16;
      uint64_t v17 = *(int *)(a1 + 72);
      int v18 = sub_244D259E0(*(void *)(a1 + 64));
      int v19 = *(unint64_t **)(a1 + 96);
      if (v19) {
        goto LABEL_59;
      }
      int v20 = v18 - 1;
      long long v21 = *(unint64_t **)(a1 + 64);
      if ((int)v17 >= v20)
      {
        int v19 = sub_244D4B518(v21, v20);
        uint64_t v24 = sub_244D5CDB0(a1, (uint64_t)v19, (uint64_t)v19);
        if (!v24)
        {
          *(_DWORD *)(a1 + 76) = 33;
          unsigned int v25 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(v24, a1);
          if (v25 >= 2) {
            goto LABEL_56;
          }
          if (!v25) {
            goto LABEL_53;
          }
        }
      }
      else
      {
        int v19 = sub_244D4B518(v21, v17 + 1);
      }
      if (v19)
      {
LABEL_59:
        if ((v19[6] & 2) != 0 && (*((unsigned char *)v19 + 52) & 2) == 0)
        {
          *(_DWORD *)(a1 + 76) = 35;
          unsigned int v26 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
          if (v26 >= 2) {
            goto LABEL_56;
          }
          if (!v26) {
            goto LABEL_53;
          }
        }
        if ((*(unsigned char *)(a1 + 104) & 0x80) == 0)
        {
          *(_DWORD *)(a1 + 76) = 44;
          unsigned int v27 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
          if (v27 >= 2) {
            goto LABEL_56;
          }
          if (!v27) {
            goto LABEL_53;
          }
        }
        if ((*(unsigned char *)(v13 + 48) & 2) != 0)
        {
          *(_DWORD *)(a1 + 76) = 41;
          unsigned int v28 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
          if (v28 >= 2) {
            goto LABEL_56;
          }
          if (!v28) {
            goto LABEL_53;
          }
        }
        if ((*(unsigned char *)(a1 + 104) & 0x40) == 0 && !sub_244D5E45C(a1, v13, 1)) {
          goto LABEL_53;
        }
        uint64_t v29 = sub_244D59FF8((uint64_t)v19);
        if (!v29)
        {
          *(_DWORD *)(a1 + 76) = 6;
          unsigned int v30 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
LABEL_41:
          if (v30 >= 2) {
            goto LABEL_56;
          }
          if (!v30) {
            goto LABEL_53;
          }
          goto LABEL_43;
        }
        if ((int)sub_244D618A4(v13, v29) <= 0)
        {
          *(_DWORD *)(a1 + 76) = 8;
          unsigned int v30 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
          goto LABEL_41;
        }
      }
LABEL_43:
      if ((*(unsigned char *)(*(void *)(a1 + 32) + 8) & 0x10) == 0 && (*(unsigned char *)(v13 + 29) & 2) != 0)
      {
        *(_DWORD *)(a1 + 76) = 36;
        unsigned int v31 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
        if (v31 >= 2) {
          goto LABEL_56;
        }
        if (!v31) {
          goto LABEL_53;
        }
      }
      signed int v35 = 0;
      if (sub_244D61AAC(v13, &v35, (uint64_t)v10))
      {
        *(_DWORD *)(a1 + 76) = 23;
        unsigned int v32 = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
        if (v32 >= 2) {
LABEL_56:
        }
          abort();
        if (!v32)
        {
LABEL_53:
          sub_244D61814(v13);
          *(void *)(a1 + 88) = 0;
          return v7;
        }
      }
      sub_244D61814(v13);
      *(void *)(a1 + 88) = 0;
LABEL_51:
      BOOL v7 = v6++ >= v9;
      if (v8 == v6) {
        return v7;
      }
    }
  }
  int v5 = sub_244D259E0(*(void *)(a1 + 64));
  unsigned int v4 = v5 - 1;
  if (v5 >= 1) {
    goto LABEL_6;
  }
  return 1;
}

uint64_t sub_244D5D51C(uint64_t a1)
{
  int v2 = sub_244D259E0(*(void *)(a1 + 64));
  LODWORD(v3) = v2 - 1;
  *(_DWORD *)(a1 + 72) = v2 - 1;
  unsigned int v4 = sub_244D4B518(*(unint64_t **)(a1 + 64), v2 - 1);
  if (sub_244D5CDB0(a1, (uint64_t)v4, (uint64_t)v4))
  {
    int v5 = v4;
    goto LABEL_9;
  }
  if ((*(unsigned char *)(*(void *)(a1 + 32) + 10) & 8) != 0) {
    goto LABEL_12;
  }
  if (v2 > 1)
  {
    LODWORD(v3) = v2 - 2;
    *(_DWORD *)(a1 + 72) = v2 - 2;
    int v5 = sub_244D4B518(*(unint64_t **)(a1 + 64), (v2 - 2));
    while (1)
    {
LABEL_9:
      if ((v3 & 0x80000000) != 0) {
        return 1;
      }
      *(_DWORD *)(a1 + 72) = v3;
      if (v5 == v4 && (*(unsigned char *)(*(void *)(a1 + 32) + 9) & 0x40) == 0)
      {
LABEL_12:
        int v5 = v4;
        goto LABEL_19;
      }
      uint64_t v7 = sub_244D59FF8((uint64_t)v4);
      if (v7)
      {
        if ((int)sub_244D5FF48((uint64_t)v5, v7) > 0) {
          goto LABEL_19;
        }
        *(_DWORD *)(a1 + 76) = 7;
        *(void *)(a1 + 80) = v5;
        uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 6;
        *(void *)(a1 + 80) = v4;
        uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
      }
      if (result >= 2) {
        goto LABEL_8;
      }
      if (!result) {
        return result;
      }
LABEL_19:
      uint64_t v8 = *(time_t **)(a1 + 32);
      time_t v9 = v8[1];
      if ((v9 & 0x200000) != 0) {
        goto LABEL_41;
      }
      if ((v9 & 2) != 0) {
        time_t v10 = *v8;
      }
      else {
        time_t v10 = time(0);
      }
      uint64_t v11 = (int *)sub_244D5BD18((uint64_t)v5);
      time_t v18 = 0;
      uint64_t v12 = sub_244CF3D28(v11, &v18);
      if (v12)
      {
        if (v18 <= v10) {
          goto LABEL_29;
        }
        *(_DWORD *)(a1 + 76) = 9;
        *(void *)(a1 + 80) = v5;
        uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 13;
        *(void *)(a1 + 80) = v5;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(v12, a1);
      }
      if (result >= 2) {
        goto LABEL_8;
      }
      if (!result) {
        return result;
      }
LABEL_29:
      uint64_t v13 = (int *)sub_244D5BDAC((uint64_t)v5);
      time_t v18 = 0;
      uint64_t v14 = sub_244CF3D28(v13, &v18);
      if (v14) {
        BOOL v15 = v18 <= v10;
      }
      else {
        BOOL v15 = 0;
      }
      int v16 = v15;
      if (!v14)
      {
        *(_DWORD *)(a1 + 76) = 14;
        *(void *)(a1 + 80) = v5;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(v14, a1);
        if (result >= 2) {
          goto LABEL_8;
        }
        if (!result) {
          return result;
        }
      }
      if (v16)
      {
        *(_DWORD *)(a1 + 76) = 10;
        *(void *)(a1 + 80) = v5;
        uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
        if (result >= 2) {
          goto LABEL_8;
        }
        if (!result) {
          return result;
        }
      }
LABEL_41:
      *(void *)(a1 + 80) = v5;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(1, a1);
      if (result >= 2) {
        goto LABEL_8;
      }
      if (!result) {
        return result;
      }
      BOOL v17 = __OFSUB__(v3, 1);
      unint64_t v3 = (v3 - 1);
      if (((v3 & 0x80000000) != 0) == v17)
      {
        unsigned int v4 = v5;
        int v5 = sub_244D4B518(*(unint64_t **)(a1 + 64), v3);
      }
    }
  }
  *(_DWORD *)(a1 + 76) = 21;
  *(void *)(a1 + 80) = v4;
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2) {
LABEL_8:
  }
    abort();
  return result;
}

uint64_t sub_244D5D7B0(uint64_t a1)
{
  int v2 = sub_244D259E0(*(void *)(a1 + 64));
  int v3 = v2;
  if (v2 <= 0)
  {
    sub_244D4B518(*(unint64_t **)(a1 + 64), 0);
    return 1;
  }
  int v4 = 0;
  int64_t v5 = (v2 - 1);
  do
  {
    int v6 = v3;
    int v3 = v5;
    uint64_t v7 = sub_244D4B518(*(unint64_t **)(a1 + 64), v5);
    uint64_t v8 = (uint64_t)v7;
    if (!v5 || (v7[6] & 0x20) == 0)
    {
      int v9 = sub_244D259E0(*(void *)(a1 + 64));
      if (v6 < v9)
      {
        LODWORD(v10) = v9;
        do
        {
          unint64_t v10 = (v10 - 1);
          uint64_t v11 = (uint64_t *)sub_244D4B518(*(unint64_t **)(a1 + 64), v10)[12];
          if (v11)
          {
            int v12 = sub_244D54FC4(v8, v11);
            if (v12)
            {
              if (v12 == 17)
              {
LABEL_26:
                uint64_t result = 0;
                *(_DWORD *)(a1 + 76) = 17;
                return result;
              }
              *(_DWORD *)(a1 + 72) = v5;
              *(_DWORD *)(a1 + 76) = v12;
              *(void *)(a1 + 80) = v8;
              uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
              if (result >= 2) {
                goto LABEL_31;
              }
              if (!result) {
                return result;
              }
            }
            int v4 = 1;
          }
        }
        while ((int)v10 > v6);
      }
    }
  }
  while (v5-- > 0);
  BOOL v15 = sub_244D4B518(*(unint64_t **)(a1 + 64), 0);
  if (!v4) {
    return 1;
  }
  int v16 = v15;
  if (v15[11]) {
    return 1;
  }
  BOOL v17 = (uint64_t *)sub_244D59E04((uint64_t)v15);
  unsigned int v18 = sub_244D5F568(v17, 0xDu, -1);
  if (v18 == -1) {
    return 1;
  }
  unsigned int v19 = v18;
  while (1)
  {
    int v20 = sub_244D5F4E0(v17, v19);
    long long v21 = (char **)sub_244C9DDF8((uint64_t)v20);
    uint64_t v24 = 0;
    unsigned int v22 = sub_244CF2EF0(&v24, v21);
    if ((v22 & 0x80000000) != 0) {
      goto LABEL_26;
    }
    BOOL v23 = sub_244D58444(v24, v22);
    sub_244D440EC(v24);
    if (v23) {
      break;
    }
    unsigned int v19 = sub_244D5F568(v17, 0xDu, v19);
    if (v19 == -1) {
      return 1;
    }
  }
  *(void *)(a1 + 72) = 0x43FFFFFFFFLL;
  *(void *)(a1 + 80) = v16;
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2) {
LABEL_31:
  }
    abort();
  if (result) {
    return 1;
  }
  return result;
}

uint64_t sub_244D5D9A8(uint64_t a1)
{
  int v4 = 0;
  int v2 = sub_244D4DC34(*(unint64_t **)(a1 + 64), *(void *)(*(void *)(a1 + 32) + 32), *(void *)(*(void *)(a1 + 32) + 8), &v4);
  if (!v2) {
    return 1;
  }
  *(void *)(a1 + 80) = v4;
  *(_DWORD *)(a1 + 76) = v2;
  if (v2 == 17) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2) {
    abort();
  }
  return result;
}

uint64_t sub_244D5DA30(int *a1)
{
  time_t v2 = time(0);
  time_t v6 = 0;
  int v3 = sub_244CF3D28(a1, &v6);
  if (v6 > v2) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = -1;
  }
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t sub_244D5DA8C(int *a1, uint64_t a2)
{
  uint64_t v6 = 0;
  int v3 = sub_244CF3D28(a1, &v6);
  if (v6 > a2) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = -1;
  }
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t sub_244D5DAD8(int *a1, time_t *a2)
{
  if (a2) {
    time_t v3 = *a2;
  }
  else {
    time_t v3 = time(0);
  }
  time_t v7 = 0;
  int v4 = sub_244CF3D28(a1, &v7);
  if (v7 > v3) {
    unsigned int v5 = 1;
  }
  else {
    unsigned int v5 = -1;
  }
  if (v4) {
    return v5;
  }
  else {
    return 0;
  }
}

void *sub_244D5DB40(void *a1, uint64_t a2)
{
  time_t v4 = time(0);

  return sub_244CF38A8(a1, v4, 0, a2);
}

void *sub_244D5DB8C(void *a1, uint64_t a2, time_t *a3)
{
  return sub_244D5DB9C(a1, 0, a2, a3);
}

void *sub_244D5DB9C(void *a1, int a2, uint64_t a3, time_t *a4)
{
  if (a4) {
    time_t v7 = *a4;
  }
  else {
    time_t v7 = time(0);
  }

  return sub_244CF38A8(a1, v7, a2, a3);
}

uint64_t sub_244D5DC00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D136D4((uint64_t)&unk_268EBDC98, a1, a2, a5);
}

uint64_t sub_244D5DC18(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_244D137A8((unint64_t **)(a1 + 112), a2, a3);
}

unint64_t *sub_244D5DC20(uint64_t a1, unsigned int a2)
{
  return sub_244D13838((uint64_t *)(a1 + 112), a2);
}

uint64_t sub_244D5DC28(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t sub_244D5DC30(uint64_t result, int a2)
{
  *(_DWORD *)(result + 76) = a2;
  return result;
}

uint64_t sub_244D5DC38(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t sub_244D5DC40(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

unint64_t *sub_244D5DC48(uint64_t a1)
{
  uint64_t result = *(unint64_t **)(a1 + 64);
  if (result) {
    return sub_244D5A0F0((uint64_t)result);
  }
  return result;
}

uint64_t sub_244D5DC58(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t sub_244D5DC60(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t sub_244D5DC68(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t sub_244D5DC70(uint64_t a1, int a2)
{
  if (!a2) {
    return 1;
  }
  time_t v4 = sub_244D569F0(a2);
  if (v4)
  {
    int v5 = sub_244CF48E0((uint64_t)v4);
    uint64_t result = sub_244D5DCFC(a1, v5);
    if (result)
    {
      uint64_t v7 = *(void *)(a1 + 32);
      if (!*(_DWORD *)(v7 + 16)) {
        *(_DWORD *)(v7 + 16) = a2;
      }
      return 1;
    }
  }
  else
  {
    sub_244D0B884(11, 0, 130, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_vfy.c", 1485);
    return 0;
  }
  return result;
}

uint64_t sub_244D5DCFC(uint64_t a1, int a2)
{
  if (!a2) {
    return 1;
  }
  if (sub_244D5BFF4(a2))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (!*(_DWORD *)(v4 + 20)) {
      *(_DWORD *)(v4 + 20) = a2;
    }
    return 1;
  }
  else
  {
    sub_244D0B884(11, 0, 131, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_vfy.c", 1507);
    return 0;
  }
}

void *sub_244D5DD74()
{
  return sub_244D44058(0x78uLL);
}

void sub_244D5DD7C(void *a1)
{
  if (a1)
  {
    sub_244D5DDBC((uint64_t)a1);
    sub_244D440EC(a1);
  }
}

double sub_244D5DDBC(uint64_t a1)
{
  sub_244D138A4((uint64_t)&unk_268EBDC98, a1, (uint64_t *)(a1 + 112));
  sub_244D5E5DC(*(void *)(a1 + 32));
  sub_244D4B564(*(unint64_t **)(a1 + 64), (void (*)(uint64_t))sub_244D5E5A8, (uint64_t)sub_244D62F44);
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

double sub_244D5DE38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_244D5DDBC(a1);
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  sub_244D1389C((void *)(a1 + 112));
  if (a2)
  {
    uint64_t v8 = sub_244D5E5B4();
    *(void *)(a1 + 32) = v8;
    if (v8)
    {
      *(void *)(a1 + 48) = *(void *)(a2 + 224);
      if (sub_244D5E67C((uint64_t)v8, *(void *)(a2 + 216)))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        unint64_t v10 = sub_244D5EDF4("default");
        if (sub_244D5E67C(v9, (uint64_t)v10))
        {
          int v12 = *(uint64_t (**)())(a2 + 224);
          if (!v12) {
            int v12 = nullsub_849;
          }
          *(void *)(a1 + 48) = v12;
          return result;
        }
      }
    }
  }
  else
  {
    sub_244D0B884(11, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_vfy.c", 1540);
  }
  sub_244D138A4((uint64_t)&unk_268EBDC98, a1, (uint64_t *)(a1 + 112));
  uint64_t v13 = *(void *)(a1 + 32);
  if (v13) {
    sub_244D5E5DC(v13);
  }
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t sub_244D5DF48(uint64_t a1, int a2)
{
  return sub_244D2A774(*(void *)(a1 + 32), a2);
}

uint64_t sub_244D5DF50(uint64_t a1, uint64_t a2)
{
  return sub_244D5E89C(*(void *)(a1 + 32), a2);
}

void *sub_244D5DF58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_244D5E97C(*(void **)(a1 + 32), a3);
}

uint64_t sub_244D5DF64(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = a2;
  return result;
}

void *sub_244D5DF6C(uint64_t a1, const char *a2)
{
  double result = sub_244D5EDF4(a2);
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = *(void *)(a1 + 32);
    return (void *)sub_244D5E67C(v5, v4);
  }
  return result;
}

void sub_244D5DFBC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    sub_244D5E5DC(v4);
  }
  *(void *)(a1 + 32) = a2;
}

BOOL sub_244D5DFF0(uint64_t a1, uint64_t *a2, unint64_t **a3, int *a4, unint64_t *a5)
{
  int v10 = *a4;
  uint64_t v53 = *(void *)(a1 + 80);
  if (!sub_244D259E0((uint64_t)a5)) {
    return v10 > 447;
  }
  int v44 = a2;
  uint64_t v45 = a3;
  int v46 = a4;
  unsigned int v47 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = v53;
  do
  {
    uint64_t v14 = sub_244D4B518(a5, v11);
    if ((v14[6] & 0x62) != 0) {
      goto LABEL_65;
    }
    uint64_t v15 = (uint64_t)v14;
    uint64_t v16 = sub_244D59CE8(v13);
    uint64_t v17 = sub_244D5BE08(v15);
    if (sub_244D59BA0(v16, v17)) {
      goto LABEL_65;
    }
    if ((*(_DWORD *)(v15 + 28) & 0x200) != 0) {
      int v18 = 32;
    }
    else {
      int v18 = 288;
    }
    if (sub_244D5E45C(a1, v15, 0)) {
      int v19 = v18 | 0x40;
    }
    else {
      int v19 = v18;
    }
    uint64_t v20 = sub_244D5BE08(v15);
    unint64_t v21 = *(int *)(a1 + 72);
    if (sub_244D259E0(*(void *)(a1 + 64)) - 1 != v21) {
      ++v21;
    }
    unsigned int v22 = sub_244D4B518(*(unint64_t **)(a1 + 64), v21);
    if (sub_244D56AF8((uint64_t)v22, *(uint64_t **)(v15 + 32)))
    {
      LODWORD(v21) = v21 + 1;
      if ((int)v21 >= (int)sub_244D259E0(*(void *)(a1 + 64))) {
        goto LABEL_64;
      }
      unint64_t v21 = (int)v21;
      while (1)
      {
        unsigned int v22 = sub_244D4B518(*(unint64_t **)(a1 + 64), v21);
        uint64_t v23 = sub_244D59E04((uint64_t)v22);
        if (!sub_244D59BA0(v23, v20)
          && !sub_244D56AF8((uint64_t)v22, *(uint64_t **)(v15 + 32)))
        {
          break;
        }
        if ((uint64_t)++v21 >= (int)sub_244D259E0(*(void *)(a1 + 64)))
        {
LABEL_64:
          uint64_t v13 = v53;
          goto LABEL_65;
        }
      }
      int v51 = v10;
      int v24 = 12;
    }
    else
    {
      int v51 = v10;
      int v24 = 28;
    }
    uint64_t v50 = v12;
    int v52 = v24 | v19;
    int v25 = *(_DWORD *)(v15 + 48);
    if ((v25 & 0x10) != 0) {
      goto LABEL_62;
    }
    uint64_t v26 = v53;
    if ((*(unsigned char *)(v53 + 48) & 0x10) != 0)
    {
      if ((v25 & 4) != 0) {
        goto LABEL_62;
      }
    }
    else if ((v25 & 8) != 0)
    {
      goto LABEL_62;
    }
    if (!sub_244D259E0(*(void *)(v53 + 80)))
    {
LABEL_59:
      uint64_t v40 = *(void **)(v15 + 40);
      if (!v40 || !*v40) {
        goto LABEL_61;
      }
      goto LABEL_62;
    }
    unint64_t v27 = 0;
    while (1)
    {
      unsigned int v28 = sub_244D4B518(*(unint64_t **)(v26 + 80), v27);
      if (!v28[1] || !v28[2]) {
        goto LABEL_58;
      }
      uint64_t v29 = *(unint64_t **)(v15 + 40);
      if (!v29) {
        goto LABEL_61;
      }
      unint64_t v30 = *v28;
      unint64_t v31 = *v29;
      if (!*v28 || v31 == 0) {
        goto LABEL_61;
      }
      if (*(_DWORD *)v30 != 1) {
        break;
      }
      uint64_t v48 = *(void *)(v30 + 16);
      if (!v48) {
        goto LABEL_58;
      }
      if (*(_DWORD *)v31 == 1)
      {
        uint64_t v33 = *(void *)(v31 + 16);
        if (v33 && !sub_244D59BA0(v48, v33)) {
          goto LABEL_61;
        }
        goto LABEL_58;
      }
      unint64_t v30 = *v29;
LABEL_53:
      long long v37 = *(unint64_t **)(v30 + 8);
      if (sub_244D259E0((uint64_t)v37))
      {
        unint64_t v38 = 0;
        do
        {
          unint64_t v39 = sub_244D4B518(v37, v38);
          if (*(_DWORD *)v39 == 4 && !sub_244D59BA0(v48, v39[1])) {
            goto LABEL_61;
          }
        }
        while (++v38 < sub_244D259E0((uint64_t)v37));
      }
LABEL_58:
      ++v27;
      uint64_t v26 = v53;
      if (v27 >= sub_244D259E0(*(void *)(v53 + 80))) {
        goto LABEL_59;
      }
    }
    if (*(_DWORD *)v31 == 1)
    {
      uint64_t v48 = *(void *)(v31 + 16);
      if (!v48) {
        goto LABEL_58;
      }
      goto LABEL_53;
    }
    if (!sub_244D259E0(*(void *)(v30 + 8))) {
      goto LABEL_58;
    }
    unint64_t v49 = 0;
    while (1)
    {
      int v34 = sub_244D4B518(*(unint64_t **)(v30 + 8), v49);
      if (sub_244D259E0(*(void *)(v31 + 8))) {
        break;
      }
LABEL_50:
      if (++v49 >= sub_244D259E0(*(void *)(v30 + 8))) {
        goto LABEL_58;
      }
    }
    unint64_t v35 = 0;
    while (1)
    {
      uint64_t v36 = sub_244D4B518(*(unint64_t **)(v31 + 8), v35);
      if (!sub_244D53FEC((uint64_t)v34, (uint64_t)v36)) {
        break;
      }
      if (++v35 >= sub_244D259E0(*(void *)(v31 + 8))) {
        goto LABEL_50;
      }
    }
LABEL_61:
    v52 |= 0x80u;
LABEL_62:
    int v10 = v51;
    if (v52 < v51)
    {
      uint64_t v12 = v50;
      goto LABEL_64;
    }
    uint64_t v12 = v50;
    if (v52 == v51 && v50)
    {
      uint64_t v54 = 0;
      unsigned int v41 = (int *)sub_244D59CE8(v50);
      unint64_t v42 = (int *)sub_244D59CE8(v15);
      uint64_t v13 = v53;
      if (sub_244CF3BA8((_DWORD *)&v54 + 1, &v54, v41, v42) && (SHIDWORD(v54) > 0 || (int)v54 >= 1))
      {
        int v10 = v52;
        uint64_t v12 = v15;
        unsigned int v47 = v22;
      }
    }
    else
    {
      int v10 = v52;
      uint64_t v12 = v15;
      unsigned int v47 = v22;
      uint64_t v13 = v53;
    }
LABEL_65:
    ++v11;
  }
  while (v11 < sub_244D259E0((uint64_t)a5));
  if (v12)
  {
    if (*v44) {
      sub_244D61814(*v44);
    }
    *int v44 = v12;
    *uint64_t v45 = v47;
    *int v46 = v10;
    sub_244D49858(v12);
  }
  return v10 > 447;
}

uint64_t sub_244D5E45C(uint64_t a1, uint64_t a2, int a3)
{
  time_t v3 = *(time_t **)(a1 + 32);
  time_t v4 = v3[1];
  if ((v4 & 0x200000) != 0) {
    return 1;
  }
  if (a3)
  {
    *(void *)(a1 + 88) = a2;
    time_t v4 = v3[1];
  }
  if ((v4 & 2) != 0) {
    time_t v8 = *v3;
  }
  else {
    time_t v8 = time(0);
  }
  uint64_t v9 = (int *)sub_244D59CE8(a2);
  time_t v14 = 0;
  if (sub_244CF3D28(v9, &v14))
  {
    if (v14 <= v8) {
      goto LABEL_15;
    }
    if (!a3) {
      return 0;
    }
    int v10 = 11;
  }
  else
  {
    if (!a3) {
      return 0;
    }
    int v10 = 15;
  }
  *(_DWORD *)(a1 + 76) = v10;
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2) {
    goto LABEL_30;
  }
  if (!result) {
    return result;
  }
LABEL_15:
  if (!sub_244D5B484(a2)) {
    goto LABEL_18;
  }
  uint64_t v12 = (int *)sub_244D5B484(a2);
  time_t v14 = 0;
  if (!sub_244CF3D28(v12, &v14))
  {
    if (a3)
    {
      int v13 = 16;
      goto LABEL_24;
    }
    return 0;
  }
  if (v14 > v8)
  {
LABEL_18:
    if (!a3) {
      return 1;
    }
    goto LABEL_26;
  }
  if (!a3) {
    return 0;
  }
  int v13 = 12;
LABEL_24:
  *(_DWORD *)(a1 + 76) = v13;
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2) {
LABEL_30:
  }
    abort();
  if (!result) {
    return result;
  }
LABEL_26:
  *(void *)(a1 + 88) = 0;
  return 1;
}

uint64_t sub_244D5E59C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5E5A8(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void *sub_244D5E5B4()
{
  uint64_t result = sub_244D44058(0x60uLL);
  if (result) {
    *((_DWORD *)result + 6) = -1;
  }
  return result;
}

void sub_244D5E5DC(uint64_t a1)
{
  if (a1)
  {
    sub_244D4B564(*(unint64_t **)(a1 + 32), (void (*)(uint64_t))sub_244D5EEA4, (uint64_t)sub_244CF29AC);
    sub_244D4B564(*(unint64_t **)(a1 + 40), (void (*)(uint64_t))sub_244D5EEB0, (uint64_t)sub_244D5E678);
    sub_244D440EC(*(void **)(a1 + 56));
    sub_244D440EC(*(void **)(a1 + 72));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D5E67C(uint64_t a1, uint64_t a2)
{
  return sub_244D5E684(a1, a2, 0);
}

uint64_t sub_244D5E684(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2) {
    return 1;
  }
  int v6 = *(_DWORD *)(a2 + 16);
  if (a3) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *(_DWORD *)(a1 + 16) == 0;
  }
  int v8 = v7;
  if (v6) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9) {
    *(_DWORD *)(a1 + 16) = v6;
  }
  int v10 = *(_DWORD *)(a2 + 20);
  if (a3) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = *(_DWORD *)(a1 + 20) == 0;
  }
  int v12 = v11;
  if (v10 && v12) {
    *(_DWORD *)(a1 + 20) = v10;
  }
  int v13 = *(_DWORD *)(a2 + 24);
  if (a3) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = *(_DWORD *)(a1 + 24) == -1;
  }
  int v15 = v14;
  if (v13 != -1 && v15) {
    *(_DWORD *)(a1 + 24) = v13;
  }
  uint64_t v16 = *(void *)(a1 + 8);
  if ((v16 & 2) == 0) {
    *(void *)a1 = *(void *)a2;
  }
  *(void *)(a1 + 8) = *(void *)(a2 + 8) | v16;
  uint64_t v17 = *(void *)(a2 + 32);
  if (a3) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = *(void *)(a1 + 32) == 0;
  }
  int v19 = v18;
  if (!v17 || !v19 || (uint64_t result = sub_244D5E9D4(a1, v17), result))
  {
    unint64_t v21 = *(unint64_t **)(a1 + 40);
    if (a3) {
      BOOL v22 = 1;
    }
    else {
      BOOL v22 = v21 == 0;
    }
    int v23 = v22;
    if (*(void *)(a2 + 40))
    {
      if (v23)
      {
        sub_244D4B564(v21, (void (*)(uint64_t))sub_244D5EEB0, (uint64_t)sub_244D5E678);
        *(void *)(a1 + 40) = 0;
        uint64_t v24 = *(void *)(a2 + 40);
        if (v24)
        {
          uint64_t result = (uint64_t)sub_244D4BC58(v24, (uint64_t (*)(uint64_t))sub_244D5EEBC, (uint64_t)sub_244D442B0, (void (*)(uint64_t))sub_244D5EEB0, (uint64_t)sub_244D5E678);
          *(void *)(a1 + 40) = result;
          if (!result) {
            return result;
          }
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
        }
      }
    }
    int v25 = *(void **)(a2 + 56);
    BOOL v26 = a3 || *(void *)(a1 + 56) == 0;
    BOOL v27 = v26;
    if (!v25 || !v27 || (uint64_t result = sub_244D5EC20(a1, v25, *(void *)(a2 + 64)), result))
    {
      unsigned int v28 = *(const void **)(a2 + 72);
      if (a3) {
        BOOL v29 = 1;
      }
      else {
        BOOL v29 = *(void *)(a1 + 72) == 0;
      }
      int v30 = v29;
      if (!v28 || !v30) {
        goto LABEL_73;
      }
      unint64_t v31 = *(void *)(a2 + 80);
      if (v31 == 16 || v31 == 4)
      {
        uint64_t result = sub_244D5EC94((void **)(a1 + 72), (unint64_t *)(a1 + 80), v28, v31);
        if (result)
        {
LABEL_73:
          char v32 = *(unsigned char *)(a2 + 88);
          uint64_t result = 1;
LABEL_77:
          *(unsigned char *)(a1 + 88) = v32;
          return result;
        }
      }
      else
      {
        uint64_t result = 0;
      }
      char v32 = 1;
      goto LABEL_77;
    }
  }
  return result;
}

uint64_t sub_244D5E894(uint64_t a1, uint64_t a2)
{
  return sub_244D5E684(a1, a2, 1);
}

uint64_t sub_244D5E89C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) |= a2;
  return 1;
}

uint64_t sub_244D5E8B0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) &= ~a2;
  return 1;
}

uint64_t sub_244D5E8C4(uint64_t a1, int a2)
{
  if (sub_244D569F0(a2))
  {
    *(_DWORD *)(a1 + 16) = a2;
    return 1;
  }
  else
  {
    sub_244D0B884(20, 0, 133, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_vpm.c", 273);
    return 0;
  }
}

uint64_t sub_244D5E920(uint64_t a1, int a2)
{
  if (sub_244D5BFF4(a2))
  {
    *(_DWORD *)(a1 + 20) = a2;
    return 1;
  }
  else
  {
    sub_244D0B884(11, 0, 131, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509_vpm.c", 282);
    return 0;
  }
}

void *sub_244D5E97C(void *result, uint64_t a2)
{
  uint64_t v2 = result[1] | 2;
  *uint64_t result = a2;
  result[1] = v2;
  return result;
}

unint64_t *sub_244D5E98C(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(unint64_t **)(a1 + 32);
  if (result) {
    return (unint64_t *)(sub_244D4BA04(result, a2) != 0);
  }
  uint64_t result = sub_244D4B4C8();
  *(void *)(a1 + 32) = result;
  if (result) {
    return (unint64_t *)(sub_244D4BA04(result, a2) != 0);
  }
  return result;
}

uint64_t sub_244D5E9D4(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    sub_244D4B564(*(unint64_t **)(result + 32), (void (*)(uint64_t))sub_244D5EEA4, (uint64_t)sub_244CF29AC);
    if (a2)
    {
      time_t v4 = sub_244D4BC58(a2, (uint64_t (*)(uint64_t))sub_244D5EEC8, (uint64_t)sub_244D44844, (void (*)(uint64_t))sub_244D5EEA4, (uint64_t)sub_244CF29AC);
      *(void *)(v3 + 32) = v4;
      return v4 != 0;
    }
    else
    {
      *(void *)(v3 + 32) = 0;
      return 1;
    }
  }
  return result;
}

uint64_t sub_244D5EA8C(uint64_t a1, unsigned char *__s, size_t __n)
{
  int v4 = sub_244D5EAD0(a1, 0, __s, __n);
  uint64_t result = 1;
  if (!v4)
  {
    *(unsigned char *)(a1 + 88) = 1;
    return 0;
  }
  return result;
}

uint64_t sub_244D5EAD0(uint64_t a1, int a2, unsigned char *__s, size_t __n)
{
  uint64_t result = 0;
  if (__s)
  {
    if (__n)
    {
      BOOL v9 = memchr(__s, 0, __n);
      uint64_t result = 0;
      if (!v9)
      {
        if (!a2)
        {
          int v10 = *(unint64_t **)(a1 + 40);
          if (v10)
          {
            sub_244D4B564(v10, (void (*)(uint64_t))sub_244D5EEB0, (uint64_t)sub_244D5E678);
            *(void *)(a1 + 40) = 0;
          }
        }
        uint64_t result = (uint64_t)sub_244D446C4(__s, __n);
        if (result)
        {
          BOOL v11 = (void *)result;
          int v12 = *(unint64_t **)(a1 + 40);
          if (v12 || (int v12 = sub_244D4B4C8(), (*(void *)(a1 + 40) = v12) != 0))
          {
            if (sub_244D4BA04(v12, (uint64_t)v11)) {
              return 1;
            }
            sub_244D440EC(v11);
            if (!sub_244D259E0(*(void *)(a1 + 40)))
            {
              sub_244CF474C(*(void *)(a1 + 40));
              uint64_t result = 0;
              *(void *)(a1 + 40) = 0;
              return result;
            }
          }
          else
          {
            sub_244D440EC(v11);
          }
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_244D5EBD4(uint64_t a1, unsigned char *__s, size_t __n)
{
  uint64_t v4 = 1;
  if (!sub_244D5EAD0(a1, 1, __s, __n))
  {
    *(unsigned char *)(a1 + 88) = 1;
    return 0;
  }
  return v4;
}

uint64_t sub_244D5EC18(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) = a2;
  return result;
}

uint64_t sub_244D5EC20(uint64_t a1, void *__s, size_t __n)
{
  if ((!__n || !memchr(__s, 0, __n))
    && sub_244D5EC94((void **)(a1 + 56), (unint64_t *)(a1 + 64), __s, __n))
  {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 88) = 1;
  return result;
}

uint64_t sub_244D5EC94(void **a1, unint64_t *a2, const void *a3, unint64_t a4)
{
  uint64_t result = 0;
  if (a3)
  {
    if (a4)
    {
      uint64_t result = (uint64_t)sub_244D442F4(a3, a4);
      if (result)
      {
        int v8 = (void *)result;
        if (*a1) {
          sub_244D440EC(*a1);
        }
        *a1 = v8;
        if (a2) {
          *a2 = a4;
        }
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_244D5ED00(uint64_t a1, const void *a2, unint64_t a3)
{
  if ((a3 == 16 || a3 == 4) && sub_244D5EC94((void **)(a1 + 72), (unint64_t *)(a1 + 80), a2, a3)) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 88) = 1;
  return result;
}

uint64_t sub_244D5ED5C(uint64_t a1, char *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t result = sub_244D58904(v5, a2);
  if (result)
  {
    BOOL v4 = (int)result == 16 || (int)result == 4;
    if (v4 && sub_244D5EC94((void **)(a1 + 72), (unint64_t *)(a1 + 80), v5, (int)result))
    {
      return 1;
    }
    else
    {
      uint64_t result = 0;
      *(unsigned char *)(a1 + 88) = 1;
    }
  }
  return result;
}

void *sub_244D5EDF4(const char *a1)
{
  if (!strcmp(a1, "default")) {
    return &unk_244EBD850;
  }
  if (!strcmp(a1, "pkcs7") || !strcmp(a1, "smime_sign")) {
    return &unk_244EBD8B0;
  }
  if (!strcmp(a1, "ssl_client")) {
    return &unk_244EBD910;
  }
  if (!strcmp(a1, "ssl_server")) {
    return &unk_244EBD970;
  }
  return 0;
}

uint64_t sub_244D5EEA4(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5EEB0(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5EEBC(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5EEC8(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D5EED4(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (a2 < 2)
    {
      uint64_t v2 = (uint64_t **)result;
      uint64_t result = **(void **)result;
      if (a2)
      {
        if (result || (*void *v2 = (uint64_t)sub_244CF7CD8(), (result = **v2) != 0))
        {
          return sub_244CF1A64(result, 1uLL);
        }
      }
      else
      {
        sub_244CF7CBC(result);
        *void *v2 = 0;
        return 1;
      }
    }
    else
    {
      sub_244D0B884(11, 0, 140, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509cset.c", 72);
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D5EF7C(uint64_t a1, uint64_t a2)
{
  if (a1 && *(void *)a1) {
    return sub_244D61FB4((uint64_t *)(*(void *)a1 + 16), a2);
  }
  else {
    return 0;
  }
}

BOOL sub_244D5EF98(BOOL result, int *a2)
{
  if (result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    if (*(int **)(*(void *)result + 24) != a2)
    {
      uint64_t v2 = sub_244CF4698(a2);
      if (v2)
      {
        sub_244CF3890(*(void *)(*(void *)v3 + 24));
        *(void *)(*(void *)v3 + 24) = v2;
      }
    }
    return v2 != 0;
  }
  return result;
}

BOOL sub_244D5F000(BOOL result, int *a2)
{
  if (result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    if (*(int **)(*(void *)result + 32) != a2)
    {
      uint64_t v2 = sub_244CF4698(a2);
      if (v2)
      {
        sub_244CF3890(*(void *)(*(void *)v3 + 32));
        *(void *)(*(void *)v3 + 32) = v2;
      }
    }
    return v2 != 0;
  }
  return result;
}

uint64_t sub_244D5F068(uint64_t a1)
{
  return 1;
}

uint64_t sub_244D5F0B4(uint64_t **a1)
{
  return sub_244CF1D00(**a1);
}

BOOL sub_244D5F0C0(BOOL result, int *a2)
{
  if (result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    if (*(int **)(result + 8) != a2)
    {
      uint64_t v2 = sub_244CF4698(a2);
      if (v2)
      {
        sub_244CF3890(*(void *)(v3 + 8));
        *(void *)(v3 + 8) = v2;
      }
    }
    return v2 != 0;
  }
  return result;
}

BOOL sub_244D5F11C(uint64_t *a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 4) | 0x100) != 0x102)
  {
    sub_244D0B884(12, 0, 191, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509cset.c", 221);
    return 0;
  }
  if (!a1) {
    return 0;
  }
  uint64_t v3 = a2;
  if (*a1 != a2)
  {
    uint64_t v3 = sub_244CF1628(a2);
    if (v3)
    {
      sub_244CF7CBC(*a1);
      *a1 = v3;
    }
  }
  return v3 != 0;
}

uint64_t sub_244D5F1A8(uint64_t *a1, void **a2)
{
  sub_244CF806C(*a1 + 56);
  uint64_t v4 = *a1;

  return sub_244D617CC(v4, a2);
}

uint64_t sub_244D5F1F0(uint64_t *a1, void **a2)
{
  return sub_244D617CC(*a1, a2);
}

uint64_t sub_244D5F1F8(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = sub_244D5FD6C(a2);
  uint64_t v5 = sub_244D5FD6C(a2);
  uint64_t v6 = v5;
  if (v4 && v5)
  {
    sub_244D5FD60(a1[1]);
    a1[1] = v4;
    sub_244D5FD60(*(void *)(*a1 + 8));
    *(void *)(*a1 + 8) = v6;
    return 1;
  }
  else
  {
    sub_244D5FD60(v4);
    sub_244D5FD60(v6);
    return 0;
  }
}

uint64_t sub_244D5F280(uint64_t a1, char *a2, size_t a3)
{
  uint64_t result = sub_244CF45A0(*(void *)(a1 + 16), a2, a3);
  if (result)
  {
    *(void *)(*(void *)(a1 + 16) + 16) &= 0xFFFFFFFFFFFFFFF0;
    *(void *)(*(void *)(a1 + 16) + 16) |= 8uLL;
    return 1;
  }
  return result;
}

uint64_t sub_244D5F2D0(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D5F300(uint64_t *a1, unsigned int a2, void *a3, int a4)
{
  BOOL v7 = sub_244D44ED0(a2);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }

  return sub_244D5F370(a1, (uint64_t)v7, a3, a4);
}

uint64_t sub_244D5F370(uint64_t *a1, uint64_t a2, void *a3, int a4)
{
  uint64_t v7 = 0xFFFFFFFFLL;
  unsigned int v8 = sub_244D5F444(a1, a2, -1);
  if ((v8 & 0x80000000) == 0)
  {
    BOOL v9 = sub_244D5F4E0(a1, v8);
    if (v9) {
      int v10 = (char **)v9[1];
    }
    else {
      int v10 = 0;
    }
    uint64_t v16 = 0;
    uint64_t v11 = sub_244CF2EF0(&v16, v10);
    if ((v11 & 0x80000000) != 0) {
      goto LABEL_13;
    }
    uint64_t v12 = v11;
    size_t v13 = v11;
    v15[0] = v16;
    v15[1] = v11;
    if (sub_244CFC5E0((uint64_t)v15)) {
      goto LABEL_13;
    }
    if (a3)
    {
      if (a4 < 1 || (int)v12 >= a4 || !sub_244CFC8B8((uint64_t)v15, a3, v13)) {
        goto LABEL_13;
      }
      *((unsigned char *)a3 + v13) = 0;
    }
    uint64_t v7 = v12;
LABEL_13:
    sub_244D440EC(v16);
  }
  return v7;
}

uint64_t sub_244D5F444(uint64_t *a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = (unint64_t *)*a1;
  int v6 = sub_244D259E0(*a1);
  if (a3 < 0) {
    int v7 = -1;
  }
  else {
    int v7 = a3;
  }
  uint64_t v8 = v7;
  uint64_t v9 = v6;
  uint64_t v10 = 1;
  while (v8 + v10 < v9)
  {
    uint64_t v11 = (uint64_t *)sub_244D4B518(v5, v8 + v10++);
    if (!sub_244D44948(*v11, a2)) {
      return (v8 + v10 - 1);
    }
  }
  return 0xFFFFFFFFLL;
}

unint64_t *sub_244D5F4E0(uint64_t *a1, unsigned int a2)
{
  if (!a1 || (a2 & 0x80000000) != 0 || sub_244D259E0(*a1) <= (unint64_t)a2) {
    return 0;
  }
  uint64_t v4 = (unint64_t *)*a1;

  return sub_244D4B518(v4, a2);
}

uint64_t *sub_244D5F544(uint64_t *result)
{
  if (result) {
    return (uint64_t *)sub_244D259E0(*result);
  }
  return result;
}

uint64_t sub_244D5F568(uint64_t *a1, unsigned int a2, int a3)
{
  uint64_t v5 = sub_244D44ED0(a2);
  if (!v5) {
    return 4294967294;
  }

  return sub_244D5F444(a1, (uint64_t)v5, a3);
}

uint64_t sub_244D5F5C4(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (sub_244D259E0(*(void *)a1) <= (unint64_t)a2)
    {
      return 0;
    }
    else
    {
      unint64_t v5 = a2;
      int v6 = *(uint64_t **)a1;
      uint64_t v2 = sub_244D4B714(*(uint64_t **)a1, a2);
      uint64_t v7 = sub_244D259E0((uint64_t)v6);
      *(_DWORD *)(a1 + 8) = 1;
      if (v7 != a2)
      {
        unint64_t v8 = v7;
        if (a2) {
          int v9 = *((_DWORD *)sub_244D4B518((unint64_t *)v6, a2 - 1) + 4) + 1;
        }
        else {
          int v9 = *(_DWORD *)(v2 + 16);
        }
        if (v9 < *((_DWORD *)sub_244D4B518((unint64_t *)v6, v5) + 4) && v8 > v5)
        {
          do
          {
            uint64_t v12 = sub_244D4B518((unint64_t *)v6, v5);
            --*((_DWORD *)v12 + 4);
            ++v5;
          }
          while (v8 != v5);
        }
      }
    }
  }
  return v2;
}

const char ***sub_244D5F6B4(uint64_t a1, uint64_t a2, int a3, char *a4, size_t a5, int a6, int a7)
{
  uint64_t result = sub_244D5F718(0, a2, a3, a4, a5);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    uint64_t v12 = sub_244D5F7CC(a1, (uint64_t)result, a6, a7);
    sub_244D61F58(v11);
    return (const char ***)v12;
  }
  return result;
}

const char ***sub_244D5F718(const char ****a1, uint64_t a2, int a3, char *a4, size_t a5)
{
  if (a1 && (uint64_t v10 = *a1) != 0 || (uint64_t v10 = (const char ***)sub_244D61F4C()) != 0)
  {
    if (sub_244D5FB40(v10, a2) && sub_244D5FBAC((uint64_t)v10, a3, a4, a5))
    {
      if (a1 && !*a1) {
        *a1 = v10;
      }
    }
    else
    {
      if (!a1 || v10 != *a1) {
        sub_244D61F58((uint64_t)v10);
      }
      return 0;
    }
  }
  return v10;
}

uint64_t sub_244D5F7CC(uint64_t result, uint64_t a2, int a3, int a4)
{
  if (!result) {
    return result;
  }
  uint64_t v7 = result;
  unint64_t v8 = *(unint64_t **)result;
  int v9 = sub_244D259E0(*(void *)result);
  if (v9 < a3 || a3 < 0) {
    a3 = v9;
  }
  BOOL v11 = a4 == 0;
  *(_DWORD *)(v7 + 8) = 1;
  if (a4 == -1)
  {
    if (a3)
    {
      uint64_t v12 = sub_244D4B518(v8, a3 - 1);
      BOOL v11 = 0;
      goto LABEL_12;
    }
    int v13 = 0;
    BOOL v11 = 1;
  }
  else
  {
    if (a3 < v9)
    {
      uint64_t v12 = sub_244D4B518(v8, a3);
LABEL_12:
      int v13 = *((_DWORD *)v12 + 4);
      goto LABEL_17;
    }
    if (a3) {
      int v13 = *((_DWORD *)sub_244D4B518(v8, a3 - 1) + 4) + 1;
    }
    else {
      int v13 = 0;
    }
  }
LABEL_17:
  uint64_t result = sub_244D61F64(a2);
  if (result)
  {
    uint64_t v14 = result;
    *(_DWORD *)(result + 16) = v13;
    if (sub_244D4B60C(v8, result, a3))
    {
      if (v11)
      {
        int v15 = sub_244D259E0((uint64_t)v8);
        if (a3 + 1 < v15)
        {
          unint64_t v16 = a3 + 1;
          int v17 = ~a3 + v15;
          do
          {
            BOOL v18 = sub_244D4B518(v8, v16);
            ++*((_DWORD *)v18 + 4);
            ++v16;
            --v17;
          }
          while (v17);
        }
      }
      return 1;
    }
    else
    {
      sub_244D61F58(v14);
      return 0;
    }
  }
  return result;
}

const char ***sub_244D5F92C(uint64_t a1, unsigned int a2, int a3, char *a4, size_t a5, int a6, int a7)
{
  uint64_t result = sub_244D5F990(0, a2, a3, a4, a5);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    uint64_t v12 = sub_244D5F7CC(a1, (uint64_t)result, a6, a7);
    sub_244D61F58(v11);
    return (const char ***)v12;
  }
  return result;
}

const char ***sub_244D5F990(const char ****a1, unsigned int a2, int a3, char *a4, size_t a5)
{
  int v9 = sub_244D44ED0(a2);
  if (v9)
  {
    return sub_244D5F718(a1, (uint64_t)v9, a3, a4, a5);
  }
  else
  {
    sub_244D0B884(11, 0, 129, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509name.c", 324);
    return 0;
  }
}

const char ***sub_244D5FA20(uint64_t a1, const char *a2, int a3, char *a4, size_t a5, int a6, int a7)
{
  uint64_t result = sub_244D5FA84(0, a2, a3, a4, a5);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    uint64_t v12 = sub_244D5F7CC(a1, (uint64_t)result, a6, a7);
    sub_244D61F58(v11);
    return (const char ***)v12;
  }
  return result;
}

const char ***sub_244D5FA84(const char ****a1, const char *a2, int a3, char *a4, size_t a5)
{
  int v9 = sub_244D44DDC(a2, 0);
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = sub_244D5F718(a1, (uint64_t)v9, a3, a4, a5);
    sub_244CF29AC((void **)v10);
    return v11;
  }
  else
  {
    sub_244D0B884(11, 0, 111, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509name.c", 309);
    sub_244D0B930(2u, v13, v14, v15, v16, v17, v18, v19, (uint64_t)"name=");
    return 0;
  }
}

BOOL sub_244D5FB40(const char ***a1, uint64_t a2)
{
  if (a1 && a2)
  {
    sub_244CF29AC((void **)*a1);
    uint64_t v4 = sub_244D44844(a2);
    *a1 = v4;
    return v4 != 0;
  }
  else
  {
    sub_244D0B884(11, 0, 67, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509name.c", 364);
    return 0;
  }
}

uint64_t sub_244D5FBAC(uint64_t result, int a2, char *__s, size_t __n)
{
  if (result)
  {
    size_t v4 = __n;
    uint64_t v7 = result;
    if (__s || !__n)
    {
      if (a2 >= 1 && (a2 & 0x1000) != 0)
      {
        int v8 = sub_244D449A4(*(unsigned __int16 **)result);
        return sub_244CF3500((uint64_t *)(v7 + 8), __s, v4, a2, v8) != 0;
      }
      else
      {
        if ((__n & 0x8000000000000000) != 0) {
          size_t v4 = strlen(__s);
        }
        uint64_t result = sub_244CF45A0(*(void *)(v7 + 8), __s, v4);
        if (result)
        {
          if (a2 != -1) {
            *(_DWORD *)(*(void *)(v7 + 8) + 4) = a2;
          }
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D5FC68(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  if (a2)
  {
    sub_244D0B884(11, 0, 140, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x509rset.c", 70);
    return 0;
  }
  uint64_t v3 = *(void *)(*(void *)a1 + 24);

  return sub_244CF1A64(v3, 0);
}

uint64_t sub_244D5FCC4(uint64_t a1, uint64_t a2)
{
  if (a1 && *(void *)a1) {
    return sub_244D61FB4((uint64_t *)(*(void *)a1 + 32), a2);
  }
  else {
    return 0;
  }
}

uint64_t sub_244D5FCE0(void *a1, uint64_t a2)
{
  if (a1 && *a1) {
    return sub_244D62950(*a1 + 40, a2);
  }
  else {
    return 0;
  }
}

uint64_t sub_244D5FCFC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244D5FD6C(a2);
  if (result)
  {
    uint64_t v4 = result;
    sub_244D5FD60(*(void *)(a1 + 8));
    *(void *)(a1 + 8) = v4;
    return 1;
  }
  return result;
}

uint64_t sub_244D5FD3C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8520);
}

uint64_t sub_244D5FD48(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8520);
}

uint64_t sub_244D5FD54()
{
  return sub_244CF7888((uint64_t)&unk_2651A8520);
}

void sub_244D5FD60(uint64_t a1)
{
}

uint64_t sub_244D5FD6C(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A8520, a1);
}

uint64_t sub_244D5FD7C(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v6 = result;
    if (a3 == -1)
    {
      sub_244CF29AC(*(void ***)result);
      *(void *)uint64_t v6 = a2;
      uint64_t v8 = *(void *)(v6 + 8);
      if (v8)
      {
        sub_244CF7EB4(v8);
        *(void *)(v6 + 8) = 0;
      }
      return 1;
    }
    if (*(void *)(result + 8) || (uint64_t result = sub_244CF7EA8(), (*(void *)(v6 + 8) = result) != 0))
    {
      sub_244CF29AC(*(void ***)v6);
      *(void *)uint64_t v6 = a2;
      if (a3) {
        sub_244CF3E0C(*(int **)(v6 + 8), a3, a4);
      }
      return 1;
    }
  }
  return result;
}

int *sub_244D5FE18(int *result, int *a2, int **a3, void *a4)
{
  if (result) {
    *(void *)uint64_t result = *a4;
  }
  if (a2)
  {
    uint64_t result = (int *)a4[1];
    if (result)
    {
      int v6 = *result;
      uint64_t result = (int *)sub_244CF3DA8(result);
    }
    else
    {
      int v6 = -1;
    }
    *a2 = v6;
    if (a3) {
      *a3 = result;
    }
  }
  return result;
}

uint64_t sub_244D5FE78(uint64_t a1, unsigned int *a2)
{
  if ((sub_244D22F44((uint64_t)a2) & 2) != 0) {
    int v4 = -1;
  }
  else {
    int v4 = 5;
  }
  unsigned int v5 = sub_244CF48D8(a2);
  int v6 = sub_244D44ED0(v5);

  return sub_244D5FD7C(a1, (uint64_t)v6, v4, 0);
}

uint64_t sub_244D5FEE4(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = sub_244D44948(*a1, *a2);
  if (!result)
  {
    unint64_t v5 = a1[1];
    uint64_t v6 = a2[1];
    if (v5 | v6)
    {
      return sub_244CF3F58((int *)v5, v6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D5FF48(uint64_t a1, uint64_t a2)
{
  if (sub_244D5FEE4(*(uint64_t **)(a1 + 8), *(uint64_t **)(*(void *)a1 + 16)))
  {
    sub_244D0B884(11, 0, 137, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_all.c", 75);
    return 0;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(unsigned int **)(a1 + 16);
    uint64_t v7 = *(void *)a1;
    return sub_244D4C3DC((uint64_t)&unk_2651A8EE0, v5, v6, v7, a2);
  }
}

uint64_t sub_244D5FFD0(uint64_t a1, uint64_t a2)
{
  return sub_244D4C3DC((uint64_t)&unk_2651A8B00, *(void *)(a1 + 8), *(unsigned int **)(a1 + 16), *(void *)a1, a2);
}

uint64_t sub_244D5FFEC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  sub_244CF806C(*a1 + 80);
  uint64_t v7 = *a1;
  uint64_t v6 = a1[1];
  uint64_t v8 = *(void *)(*a1 + 16);
  uint64_t v9 = a1[2];

  return sub_244D4C180((uint64_t)&unk_2651A8EE0, v8, v6, v9, v7, a2, a3);
}

uint64_t sub_244D60054(uint64_t *a1, uint64_t *a2)
{
  sub_244CF806C(*a1 + 80);
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = *(void *)(*a1 + 16);
  uint64_t v7 = a1[2];

  return sub_244D4C25C((uint64_t)&unk_2651A8EE0, v6, v4, v7, v5, a2);
}

uint64_t sub_244D600AC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  sub_244CF806C(*a1);
  uint64_t v6 = a1[1];
  uint64_t v7 = a1[2];
  uint64_t v8 = *a1;

  return sub_244D4C180((uint64_t)&unk_2651A8B00, v6, 0, v7, v8, a2, a3);
}

uint64_t sub_244D60110(uint64_t *a1, uint64_t *a2)
{
  sub_244CF806C(*a1);
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = *a1;

  return sub_244D4C25C((uint64_t)&unk_2651A8B00, v4, 0, v5, v6, a2);
}

uint64_t sub_244D60164(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  sub_244CF806C(*a1 + 56);
  uint64_t v7 = *a1;
  uint64_t v6 = a1[1];
  uint64_t v8 = *(void *)(*a1 + 8);
  uint64_t v9 = a1[2];

  return sub_244D4C180((uint64_t)&unk_2651A8730, v8, v6, v9, v7, a2, a3);
}

uint64_t sub_244D601CC(uint64_t *a1, uint64_t *a2)
{
  sub_244CF806C(*a1 + 56);
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = *(void *)(*a1 + 8);
  uint64_t v7 = a1[2];

  return sub_244D4C25C((uint64_t)&unk_2651A8730, v6, v4, v7, v5, a2);
}

uint64_t sub_244D60224(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return sub_244D4C180((uint64_t)&unk_2651A8C70, a1[1], 0, a1[2], *a1, a2, a3);
}

uint64_t sub_244D60244(uint64_t a1, uint64_t a2)
{
  return sub_244D4C3DC((uint64_t)&unk_2651A8C70, *(void *)(a1 + 8), *(unsigned int **)(a1 + 16), *(void *)a1, a2);
}

uint64_t sub_244D60260(uint64_t a1, uint64_t *a2)
{
  return sub_244CF11E0((uint64_t)&unk_2651A87C0, a1, a2);
}

uint64_t sub_244D60274(uint64_t a1, uint64_t a2)
{
  return sub_244CF1538((uint64_t)&unk_2651A87C0, a1, a2);
}

uint64_t sub_244D60288(uint64_t a1, uint64_t *a2)
{
  return sub_244CF1164((uint64_t)&unk_2651A87C0, a1, a2);
}

uint64_t sub_244D6029C(uint64_t a1, uint64_t a2)
{
  return sub_244CF15BC((uint64_t)&unk_2651A87C0, a1, a2);
}

uint64_t sub_244D602B0(uint64_t a1, uint64_t *a2)
{
  return sub_244CF11E0((uint64_t)&unk_2651A8B90, a1, a2);
}

uint64_t sub_244D602C4(uint64_t a1, uint64_t a2)
{
  return sub_244CF1538((uint64_t)&unk_2651A8B90, a1, a2);
}

uint64_t sub_244D602D8(uint64_t a1, uint64_t *a2)
{
  return sub_244CF1164((uint64_t)&unk_2651A8B90, a1, a2);
}

uint64_t sub_244D602EC(uint64_t a1, uint64_t a2)
{
  return sub_244CF15BC((uint64_t)&unk_2651A8B90, a1, a2);
}

void *sub_244D60300(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60348((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60348(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D63000(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D603B8(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60400((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60400(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D63318(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

uint64_t *sub_244D60468(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D604B0((uint64_t)result, a2);
    sub_244CF830C(v4);
    return v5;
  }
  return result;
}

uint64_t *sub_244D604B0(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  unsigned int v3 = sub_244D4A210(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D60520(uint64_t a1, uint64_t **a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60568((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60568(uint64_t a1, uint64_t **a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D4A284(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

uint64_t *sub_244D605D0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60618((uint64_t)result, a2);
    sub_244CF830C(v4);
    return v5;
  }
  return result;
}

uint64_t *sub_244D60618(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  unsigned int v3 = sub_244D4A128(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D60688(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D606D0((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D606D0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D4A19C(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

void *sub_244D60738(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60780((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60780(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D0D238(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D607F0(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60838((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60838(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D0D2C0(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

uint64_t *sub_244D608A0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D608E8((uint64_t)result, a2);
    sub_244CF830C(v4);
    return v5;
  }
  return result;
}

uint64_t *sub_244D608E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  unsigned int v3 = sub_244D0942C(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D60958(uint64_t a1, uint64_t **a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D609A0((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D609A0(uint64_t a1, uint64_t **a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D094A0(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

void *sub_244D60A08(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60A50((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60A50(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D0D338(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D60AC0(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60B08((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60B08(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D0D3C0(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

void *sub_244D60B70(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60BB8((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60BB8(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D0A254(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D60C28(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60C70((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60C70(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D0A304(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

void *sub_244D60CD8(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60D20((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60D20(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D0D438(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D60D90(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60DD8((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60DD8(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D0D4C0(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

int *sub_244D60E40(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = (int *)sub_244D5A020(a1);
  if (result)
  {
    uint64_t v8 = *result;
    uint64_t v9 = *((void *)result + 1);
    return (int *)sub_244D25474(v9, v8, a3, a4, a2);
  }
  return result;
}

uint64_t sub_244D60EB4(uint64_t *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v10 = 0;
  unsigned int v7 = sub_244D63318(a1, &v10);
  if ((v7 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v8 = sub_244D25474((uint64_t)v10, v7, a3, a4, a2);
  sub_244D440EC(v10);
  return v8;
}

uint64_t sub_244D60F34(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return sub_244D4C0F4((uint64_t)&unk_2651A87C0, a2, a1, a3, a4);
}

uint64_t sub_244D60F50(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return sub_244D4C0F4((uint64_t)&unk_2651A8B90, a2, a1, a3, a4);
}

uint64_t sub_244D60F6C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  return sub_244D4C0F4((uint64_t)&unk_2651A89E0, a2, a1, a3, a4);
}

void *sub_244D60F88(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D60FD0((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D60FD0(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D62D98(a2, (uint64_t *)&v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D61040(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D61088((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D61088(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D62DA4(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

void *sub_244D610F0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D61138((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D61138(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D46DB0(a2, (uint64_t *)&v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D611A8(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D611F0((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D611F0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D46DBC(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

uint64_t sub_244D61258(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244D46E7C(a2);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = sub_244D611A8(a1, result);
    sub_244D46DD4(v4);
    return (uint64_t)v5;
  }
  return result;
}

void *sub_244D612A4(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D612EC((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D612EC(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D0CE80(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D6135C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D613A4((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D613A4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D4D6E0(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

void *sub_244D6140C(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D61454((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D61454(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  uint64_t v3 = sub_244D0D148(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

void *sub_244D614C4(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244CF90D4();
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = sub_244D6150C((uint64_t)result, a2);
    sub_244CF830C(v4);
    return (void *)v5;
  }
  return result;
}

uint64_t sub_244D6150C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D0D1BC(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

uint64_t sub_244D61574(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_244D46E7C(a2);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = sub_244D611F0(a1, result);
    sub_244D46DD4(v4);
    return v5;
  }
  return result;
}

void *sub_244D615C0(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  unsigned int v7 = 0;
  if (!sub_244CF8AE4(a1, (uint64_t *)&v7, &v6, 0x19000uLL)) {
    return 0;
  }
  uint64_t v5 = v7;
  unsigned int v3 = sub_244D06DB0(a2, &v5, v6);
  sub_244D440EC(v7);
  return v3;
}

uint64_t sub_244D61630(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  unsigned int v3 = sub_244D06E24(a2, &v6);
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = sub_244CF85CC(a1, (uint64_t)v6, v3);
  sub_244D440EC(v6);
  return v4;
}

uint64_t sub_244D61698(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8590);
}

uint64_t sub_244D616A4(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8590);
}

uint64_t sub_244D616B0()
{
  return sub_244CF7888((uint64_t)&unk_2651A8590);
}

void sub_244D616BC(uint64_t a1)
{
}

uint64_t sub_244D616C8(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A8590, a1);
}

uint64_t sub_244D616D8(unsigned int a1, int a2, uint64_t a3)
{
  uint64_t v5 = sub_244D44ED0(a1);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = sub_244CF7888((uint64_t)&unk_2651A8590);
  uint64_t v8 = sub_244CF7EA8();
  uint64_t v9 = (int *)v8;
  if (!v7 || !v8 || (*(void *)uint64_t v7 = v6, !sub_244D4BA04(*(unint64_t **)(v7 + 8), v8)))
  {
    sub_244CF746C(v7, (uint64_t)&unk_2651A8590);
    sub_244CF7EB4((uint64_t)v9);
    return 0;
  }
  sub_244CF3E0C(v9, a2, a3);
  return v7;
}

uint64_t sub_244D61780(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8620);
}

uint64_t sub_244D6178C(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8620);
}

uint64_t sub_244D61798()
{
  return sub_244CF7888((uint64_t)&unk_2651A8620);
}

void sub_244D617A4(uint64_t a1)
{
}

uint64_t sub_244D617B0(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A8620, a1);
}

uint64_t sub_244D617C0(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8730);
}

uint64_t sub_244D617CC(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8730);
}

uint64_t sub_244D617D8()
{
  return sub_244CF7888((uint64_t)&unk_2651A8730);
}

void sub_244D617E4(uint64_t a1)
{
}

uint64_t sub_244D617F0(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A87C0);
}

uint64_t sub_244D617FC(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A87C0);
}

uint64_t sub_244D61808()
{
  return sub_244CF7888((uint64_t)&unk_2651A87C0);
}

void sub_244D61814(uint64_t a1)
{
}

uint64_t sub_244D61820(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A87C0, a1);
}

unint64_t *sub_244D61830(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t result = *(unint64_t **)(*a1 + 40);
  if (result || (uint64_t result = sub_244D4B468((uint64_t)sub_244D61890), (*(void *)(v3 + 40) = result) != 0))
  {
    uint64_t result = sub_244D4BA04(result, a2);
    if (result)
    {
      sub_244CF806C(v3 + 56);
      return (unint64_t *)1;
    }
  }
  return result;
}

uint64_t sub_244D61890(uint64_t **a1, uint64_t **a2)
{
  return sub_244CF4804(**a1, **a2);
}

uint64_t sub_244D618A4(uint64_t a1, uint64_t a2)
{
  if (sub_244D5FEE4(*(uint64_t **)(a1 + 8), *(uint64_t **)(*(void *)a1 + 8)))
  {
    sub_244D0B884(11, 0, 137, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_crl.c", 319);
    return 0;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(unsigned int **)(a1 + 16);
    uint64_t v7 = *(void *)a1;
    return sub_244D4C3DC((uint64_t)&unk_2651A8730, v5, v6, v7, a2);
  }
}

uint64_t sub_244D6192C(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  return sub_244D61934(a1, a2, a3, 0);
}

uint64_t sub_244D61934(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4)
{
  v14[0] = a3;
  sub_244D4BD50(&stru_268EBDD78);
  BOOL v8 = sub_244D4B9B4(*(void *)(*(void *)a1 + 40));
  sub_244D4BD90(&stru_268EBDD78);
  if (!v8)
  {
    sub_244D4BD70(&stru_268EBDD78);
    if (!sub_244D4B9B4(*(void *)(*(void *)a1 + 40))) {
      sub_244D4BAAC(*(void *)(*(void *)a1 + 40), (uint64_t (*)(void, void, void))sub_244D61EC4);
    }
    sub_244D4BD90(&stru_268EBDD78);
  }
  memset(&v14[1], 0, 24);
  unint64_t v13 = 0;
  uint64_t result = sub_244D4B860(*(void *)(*(void *)a1 + 40), &v13, (uint64_t)v14, (uint64_t (*)(void, uint64_t, void))sub_244D61EC4);
  if (result)
  {
    for (unint64_t i = v13; ; unint64_t i = ++v13)
    {
      if (i >= sub_244D259E0(*(void *)(*(void *)a1 + 40))) {
        return 0;
      }
      uint64_t v11 = (uint64_t *)sub_244D4B518(*(unint64_t **)(*(void *)a1 + 40), v13);
      if (sub_244CF162C(*v11, a3)) {
        return 0;
      }
      if (!a4) {
        break;
      }
      uint64_t v12 = sub_244D5BE08(a1);
      if (!sub_244D59BA0(a4, v12)) {
        break;
      }
    }
    if (a2) {
      *a2 = v11;
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D61AAC(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v6 = sub_244D59E10(a3);
  uint64_t v7 = sub_244D59CE8(a3);

  return sub_244D61934(a1, a2, v6, v7);
}

uint64_t sub_244D61B10(int a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    if (a1 == 5)
    {
      uint64_t v2 = *(void *)(*(void *)a2 + 40);
      if (v2) {
        sub_244D4BC3C(v2, (uint64_t)sub_244D61890);
      }
    }
  }
  return 1;
}

uint64_t sub_244D61B54(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (result != 5)
  {
    if (result == 3)
    {
      sub_244D504CC(*(void *)(v2 + 32));
      sub_244D53134(*(void *)(v2 + 40));
    }
    else if (result == 1)
    {
      *(void *)(v2 + 36) = 0;
      *(void *)(v2 + 28) = 0;
      *(void *)(v2 + 44) = 0;
      return result;
    }
    return 1;
  }
  uint64_t v3 = *(uint64_t **)v2;
  uint64_t v4 = **(void **)v2;
  if (!v4)
  {
LABEL_12:
    if (v3[6])
    {
      int v6 = 139;
      __int16 v7 = 183;
      goto LABEL_14;
    }
    goto LABEL_17;
  }
  unint64_t v5 = sub_244CF1D00(v4);
  if (v5 >= 2)
  {
    int v6 = 140;
    __int16 v7 = 176;
LABEL_14:
    sub_244D0B884(11, 0, v6, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_crl.c", v7);
    return 0;
  }
  if (!v5)
  {
    uint64_t v3 = *(uint64_t **)v2;
    goto LABEL_12;
  }
LABEL_17:
  BOOL v8 = sub_244D25C38();
  uint64_t result = sub_244D60F34(v2, (uint64_t)v8, v2 + 52, 0);
  if (result)
  {
    int v31 = 0;
    uint64_t v9 = sub_244D5A198(v2, 770, &v31, 0);
    *(void *)(v2 + 40) = v9;
    if (!v9)
    {
      if (v31 != -1) {
        return 0;
      }
LABEL_38:
      uint64_t v16 = sub_244D5A198(v2, 90, &v31, 0);
      *(void *)(v2 + 32) = v16;
      if (v16 || v31 == -1)
      {
        uint64_t v17 = *(unint64_t **)(*(void *)v2 + 48);
        if (sub_244D259E0((uint64_t)v17))
        {
          unint64_t v18 = 0;
          while (1)
          {
            uint64_t v19 = sub_244D4B518(v17, v18);
            uint64_t v20 = (unsigned __int16 *)sub_244D259E0((uint64_t)v19);
            unsigned int v21 = sub_244D449A4(v20);
            if (sub_244D5C264((BOOL)v19) && v21 != 90 && v21 != 770) {
              break;
            }
            if (++v18 >= sub_244D259E0((uint64_t)v17)) {
              goto LABEL_48;
            }
          }
          *(_DWORD *)(v2 + 28) |= 0x200u;
        }
LABEL_48:
        BOOL v22 = (unint64_t *)sub_244D59E04(v2);
        if (sub_244D259E0((uint64_t)v22))
        {
          unint64_t v23 = 0;
          while (1)
          {
            uint64_t v24 = sub_244D4B518(v22, v23);
            int v32 = 0;
            uint64_t v25 = sub_244D5A2B4((uint64_t)v24, 141, &v32, 0);
            uint64_t v26 = v25;
            if (!v25 && v32 != -1) {
              break;
            }
            if (v25)
            {
              *((_DWORD *)v24 + 6) = sub_244CF1D54(v25);
              sub_244CF7CBC(v26);
            }
            else
            {
              *((_DWORD *)v24 + 6) = -1;
            }
            BOOL v27 = (unint64_t *)v24[2];
            if (sub_244D259E0((uint64_t)v27))
            {
              unint64_t v28 = 0;
              while (1)
              {
                BOOL v29 = sub_244D4B518(v27, v28);
                if (sub_244D5C264((BOOL)v29)) {
                  break;
                }
                if (++v28 >= sub_244D259E0((uint64_t)v27)) {
                  goto LABEL_61;
                }
              }
              *(_DWORD *)(v2 + 28) |= 0x200u;
            }
LABEL_61:
            ++v23;
            unint64_t v30 = sub_244D259E0((uint64_t)v22);
            uint64_t result = 1;
            if (v23 >= v30) {
              return result;
            }
          }
          *(_DWORD *)(v2 + 28) |= 0x80u;
        }
        return 1;
      }
      return 0;
    }
    int v10 = *(_DWORD *)(v2 + 48);
    int v11 = v10 | 1;
    *(_DWORD *)(v2 + 48) = v10 | 1;
    if (*(int *)(v9 + 8) < 1)
    {
      unsigned int v12 = 0;
    }
    else
    {
      int v11 = v10 | 5;
      *(_DWORD *)(v2 + 48) = v10 | 5;
      unsigned int v12 = 1;
    }
    if (*(int *)(v9 + 12) >= 1)
    {
      ++v12;
      v11 |= 8u;
      *(_DWORD *)(v2 + 48) = v11;
    }
    int v13 = *(_DWORD *)(v9 + 28);
    if (v13 > 0)
    {
      v11 |= 0x10u;
      ++v12;
    }
    if (v12 > 1) {
      v11 |= 2u;
    }
    if (v13 > 0 || v12 >= 2) {
      *(_DWORD *)(v2 + 48) = v11;
    }
    if (*(int *)(v9 + 24) >= 1)
    {
      v11 |= 0x20u;
      *(_DWORD *)(v2 + 48) = v11;
    }
    if (*(void *)(v9 + 16)) {
      *(_DWORD *)(v2 + 48) = v11 | 0x40;
    }
    uint64_t v14 = *(void *)v9;
    uint64_t v15 = sub_244D5BE08(v2);
    uint64_t result = sub_244D534A8(v14, v15);
    if (result) {
      goto LABEL_38;
    }
  }
  return result;
}

uint64_t sub_244D61EC4(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sub_244D61EF4(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8850);
}

uint64_t sub_244D61F00(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8850);
}

uint64_t sub_244D61F0C()
{
  return sub_244CF7888((uint64_t)&unk_2651A8850);
}

void sub_244D61F18(uint64_t a1)
{
}

uint64_t sub_244D61F24(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A88A0);
}

uint64_t sub_244D61F30(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A88A0);
}

uint64_t sub_244D61F3C(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A8850, a1);
}

uint64_t sub_244D61F4C()
{
  return sub_244CF7888((uint64_t)&unk_2651A8910);
}

void sub_244D61F58(uint64_t a1)
{
}

uint64_t sub_244D61F64(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A8910, a1);
}

uint64_t sub_244D61F74(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A89E0);
}

uint64_t sub_244D61F80(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A89E0);
}

uint64_t sub_244D61F8C()
{
  return sub_244CF7888((uint64_t)&unk_2651A89E0);
}

void sub_244D61F98(uint64_t a1)
{
}

uint64_t sub_244D61FA4(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A89E0, a1);
}

uint64_t sub_244D61FB4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_244CF1264((uint64_t)&unk_2651A89E0, a2);
  if (result)
  {
    uint64_t v4 = result;
    sub_244CF746C(*a1, (uint64_t)&unk_2651A89E0);
    *a1 = v4;
    return 1;
  }
  return result;
}

uint64_t sub_244D62000(uint64_t a1, void *a2, void *a3)
{
  if ((int)sub_244CF6668(a1, 0, (uint64_t)&unk_2651A89E0) < 1) {
    return 0;
  }
  if (a2) {
    *a2 = *(void *)(*(void *)(a1 + 16) + 8);
  }
  if (a3) {
    *a3 = **(void **)(a1 + 16);
  }
  return 1;
}

uint64_t sub_244D62074(uint64_t *a1)
{
  uint64_t result = (uint64_t)sub_244D43FF4(0x28uLL);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = sub_244D4B4C8();
    *(void *)uint64_t v3 = v4;
    if (v4)
    {
      uint64_t v5 = sub_244CFAC60();
      *(void *)(v3 + 16) = v5;
      if (v5)
      {
        *(void *)(v3 + 24) = 0;
        *(_DWORD *)(v3 + 32) = 0;
        uint64_t result = 1;
        *(_DWORD *)(v3 + 8) = 1;
        *a1 = v3;
        return result;
      }
      if (*(void *)v3) {
        sub_244CF474C(*(void *)v3);
      }
    }
    sub_244D440EC((void *)v3);
    return 0;
  }
  return result;
}

void sub_244D620EC(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      sub_244CF474C(*(void *)(v2 + 16));
      sub_244D4B564(*(unint64_t **)v2, (void (*)(uint64_t))sub_244D62554, (uint64_t)sub_244D61F58);
      uint64_t v3 = *(void **)(v2 + 24);
      if (v3) {
        sub_244D440EC(v3);
      }
      sub_244D440EC((void *)v2);
      *a1 = 0;
    }
  }
}

uint64_t sub_244D62164(uint64_t *a1, const void **a2, uint64_t a3, uint64_t a4, char a5)
{
  __int16 v7 = *a2;
  uint64_t v16 = 0;
  uint64_t v17 = v7;
  if (a3 >= 0x100000) {
    a3 = 0x100000;
  }
  uint64_t result = sub_244CF5B2C((uint64_t)&v16, (uint64_t *)&v17, a3, (uint64_t)&unk_2651A89B0, -1, 0, a5, 0);
  if ((int)result >= 1)
  {
    uint64_t v9 = v16;
    if (*a1) {
      sub_244D620EC(a1);
    }
    uint64_t v15 = 0;
    if (sub_244D62074(&v15))
    {
      uint64_t v10 = v15;
      if (sub_244CFAD1C(*(unint64_t **)(v15 + 16), v17 - v7))
      {
        if (v17 != v7) {
          memcpy(*(void **)(*(void *)(v10 + 16) + 8), v7, v17 - v7);
        }
        if (sub_244D259E0((uint64_t)v9))
        {
          unint64_t v11 = 0;
          while (1)
          {
            unsigned int v12 = sub_244D4B518(v9, v11);
            if (sub_244D259E0((uint64_t)v12)) {
              break;
            }
LABEL_16:
            if (++v11 >= sub_244D259E0((uint64_t)v9)) {
              goto LABEL_17;
            }
          }
          unint64_t v13 = 0;
          while (1)
          {
            uint64_t v14 = sub_244D4B518(v12, v13);
            *((_DWORD *)v14 + 4) = v11;
            if (!sub_244D4BA04(*(unint64_t **)v10, (uint64_t)v14)) {
              break;
            }
            sub_244D4B53C(v12, v13++, 0);
            if (v13 >= sub_244D259E0((uint64_t)v12)) {
              goto LABEL_16;
            }
          }
        }
        else
        {
LABEL_17:
          if (sub_244D62560(v10))
          {
            sub_244D4B564(v9, (void (*)(uint64_t))sub_244D62914, (uint64_t)sub_244D6283C);
            *(_DWORD *)(v10 + 8) = 0;
            *a1 = v10;
            *a2 = v17;
            return 1;
          }
        }
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    sub_244CF746C(v10, (uint64_t)&unk_2651A89E0);
    sub_244D4B564(v9, (void (*)(uint64_t))sub_244D62914, (uint64_t)sub_244D62840);
    sub_244D0B884(11, 0, 12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_name.c", 252);
    return 0;
  }
  return result;
}

uint64_t sub_244D6236C(uint64_t *a1, void **a2)
{
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 8))
  {
    uint64_t v15 = 0;
    uint64_t v4 = sub_244D4B4C8();
    if (!v4) {
      goto LABEL_20;
    }
    if (sub_244D259E0(*(void *)v3))
    {
      unint64_t v5 = 0;
      int v6 = 0;
      int v7 = -1;
      do
      {
        BOOL v8 = sub_244D4B518(*(unint64_t **)v3, v5);
        if (*((_DWORD *)v8 + 4) != v7)
        {
          uint64_t v9 = sub_244D4B4C8();
          if (!v9) {
            goto LABEL_20;
          }
          int v6 = v9;
          if (!sub_244D4BA04(v4, (uint64_t)v9))
          {
            sub_244CF474C((uint64_t)v6);
            goto LABEL_20;
          }
          int v7 = *((_DWORD *)v8 + 4);
        }
        if (!sub_244D4BA04(v6, (uint64_t)v8)) {
          goto LABEL_20;
        }
        ++v5;
      }
      while (v5 < sub_244D259E0(*(void *)v3));
    }
    uint64_t v14 = v4;
    int v10 = sub_244CF6754(&v14, 0, (uint64_t)&unk_2651A89B0, 0xFFFFFFFFLL, 0);
    if (v10 >= 1
      && sub_244CFAD1C(*(unint64_t **)(v3 + 16), v10)
      && (uint64_t v15 = *(void **)(*(void *)(v3 + 16) + 8),
          (int)sub_244CF6754(&v14, &v15, (uint64_t)&unk_2651A89B0, 0xFFFFFFFFLL, 0) > 0))
    {
      sub_244D4B564(v4, (void (*)(uint64_t))sub_244D62914, (uint64_t)sub_244D6283C);
      *(_DWORD *)(v3 + 8) = 0;
      if (sub_244D62560(v3)) {
        goto LABEL_15;
      }
    }
    else
    {
LABEL_20:
      sub_244D4B564(v4, (void (*)(uint64_t))sub_244D62914, (uint64_t)sub_244D6283C);
    }
    return 0xFFFFFFFFLL;
  }
LABEL_15:
  unint64_t v11 = *(uint64_t **)(v3 + 16);
  uint64_t v12 = *v11;
  if (a2)
  {
    if (v12 << 32) {
      memcpy(*a2, (const void *)v11[1], (int)v12);
    }
    *a2 = (char *)*a2 + (int)v12;
  }
  return v12;
}

uint64_t sub_244D62554(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D62560(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    sub_244D440EC(v2);
    *(void *)(a1 + 24) = 0;
  }
  if (sub_244D259E0(*(void *)a1))
  {
    uint64_t v3 = sub_244D4B4C8();
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v36 = 0;
      if (sub_244D259E0(*(void *)a1))
      {
        unint64_t v5 = 0;
        int v6 = 0;
        int v7 = -1;
        uint64_t v33 = v4;
        do
        {
          BOOL v8 = sub_244D4B518(*(unint64_t **)a1, v5);
          if (*((_DWORD *)v8 + 4) != v7)
          {
            uint64_t v9 = sub_244D4B4C8();
            if (!v9) {
              goto LABEL_44;
            }
            int v6 = v9;
            if (!sub_244D4BA04(v4, (uint64_t)v9))
            {
              sub_244CF474C((uint64_t)v6);
              goto LABEL_44;
            }
            int v7 = *((_DWORD *)v8 + 4);
          }
          int v10 = (void *)sub_244CF7888((uint64_t)&unk_2651A8910);
          if (!v10) {
            goto LABEL_44;
          }
          uint64_t v11 = (uint64_t)v10;
          *int v10 = sub_244D44844(*v8);
          uint64_t v12 = *(void *)(v11 + 8);
          unint64_t v13 = v8[1];
          if ((sub_244CF51E0(*(_DWORD *)(v13 + 4)) & 0x2956) != 0)
          {
            *(_DWORD *)(v12 + 4) = 12;
            uint64_t v14 = (unsigned __int8 **)(v12 + 8);
            int v15 = sub_244CF2EF0((void *)(v12 + 8), (char **)v13);
            *(_DWORD *)uint64_t v12 = v15;
            if (v15 == -1) {
              goto LABEL_43;
            }
            int v34 = v7;
            unint64_t v35 = v6;
            if (v15 < 1)
            {
LABEL_25:
              uint64_t v24 = *v14;
              uint64_t v25 = *v14;
              int v6 = v35;
            }
            else
            {
              uint64_t v16 = *v14;
              uint64_t v17 = v15;
              int v18 = v15 + 1;
              int v19 = v15;
              uint64_t v20 = *v14;
              while (sub_244D44410(*v20))
              {
                ++v20;
                --v19;
                if (--v18 <= 1) {
                  goto LABEL_25;
                }
              }
              unsigned int v21 = &v16[v17 - 1];
              while (1)
              {
                int v22 = *v21--;
                if (!sub_244D44410(v22)) {
                  break;
                }
                BOOL v23 = __OFSUB__(v19--, 1);
                if ((v19 < 0) ^ v23 | (v19 == 0)) {
                  goto LABEL_25;
                }
              }
              int v26 = 0;
              uint64_t v25 = *v14;
              int v6 = v35;
              do
              {
                if (sub_244D44410(*v20))
                {
                  *uint64_t v25 = 32;
                  do
                  {
                    int v27 = *++v20;
                    ++v26;
                  }
                  while (sub_244D44410(v27));
                }
                else
                {
                  unsigned int v28 = *v20++;
                  *uint64_t v25 = sub_244D443FC(v28);
                  ++v26;
                }
                ++v25;
              }
              while (v26 < v19);
              uint64_t v24 = *v14;
            }
            *(_DWORD *)uint64_t v12 = v25 - v24;
            uint64_t v4 = v33;
            int v7 = v34;
          }
          else if (!sub_244CF4548(v12, (char **)v13))
          {
            goto LABEL_43;
          }
          if (!sub_244D4BA04(v6, v11))
          {
LABEL_43:
            sub_244CF746C(v11, (uint64_t)&unk_2651A8910);
            goto LABEL_44;
          }
          ++v5;
        }
        while (v5 < sub_244D259E0(*(void *)a1));
      }
      unsigned int v30 = sub_244D62864(v4, 0);
      if ((v30 & 0x80000000) != 0 || (*(_DWORD *)(a1 + 32) = v30, int v31 = sub_244D43FF4(v30), (v36 = v31) == 0))
      {
LABEL_44:
        uint64_t v29 = 0;
      }
      else
      {
        *(void *)(a1 + 24) = v31;
        sub_244D62864(v4, &v36);
        uint64_t v29 = 1;
      }
      sub_244D4B564(v4, (void (*)(uint64_t))sub_244D62914, (uint64_t)sub_244D62840);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 0;
    return 1;
  }
  return v29;
}

void sub_244D62840(unint64_t *a1)
{
}

uint64_t sub_244D62864(unint64_t *a1, void **a2)
{
  BOOL v8 = 0;
  if (!sub_244D259E0((uint64_t)a1)) {
    return 0;
  }
  unint64_t v4 = 0;
  LODWORD(v5) = 0;
  while (1)
  {
    BOOL v8 = sub_244D4B518(a1, v4);
    uint64_t v6 = sub_244CF6754(&v8, a2, (uint64_t)&unk_2651A8960, 0xFFFFFFFFLL, 0);
    if ((v6 & 0x80000000) != 0) {
      break;
    }
    uint64_t v5 = (v6 + v5);
    if (++v4 >= sub_244D259E0((uint64_t)a1)) {
      return v5;
    }
  }
  return v6;
}

uint64_t sub_244D62914(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D62920(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8A50);
}

uint64_t sub_244D6292C(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8A50);
}

uint64_t sub_244D62938()
{
  return sub_244CF7888((uint64_t)&unk_2651A8A50);
}

void sub_244D62944(uint64_t a1)
{
}

uint64_t sub_244D62950(uint64_t result, uint64_t a2)
{
  BOOL v8 = 0;
  if (result)
  {
    uint64_t v3 = (uint64_t *)result;
    uint64_t v7 = 0;
    memset(v6, 0, sizeof(v6));
    if (sub_244CFB3DC((uint64_t)v6, 0)
      && sub_244D0CAD8((uint64_t)v6, a2)
      && sub_244CFB48C((uint64_t)v6, &v8, &v7)
      && (v7 & 0x8000000000000000) == 0)
    {
      uint64_t v5 = v8;
      uint64_t v4 = sub_244CF5200(0, (uint64_t *)&v5, v7, (uint64_t)&unk_2651A8A50);
      if (v4 && v5 == (void *)((char *)v8 + v7))
      {
        sub_244D440EC(v8);
        sub_244CF746C(*v3, (uint64_t)&unk_2651A8A50);
        *uint64_t v3 = v4;
        return 1;
      }
      sub_244D0B884(11, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_pubkey.c", 141);
    }
    else
    {
      sub_244CFB470((uint64_t)v6);
      sub_244D0B884(11, 0, 126, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_pubkey.c", 134);
      uint64_t v4 = 0;
    }
    sub_244CF746C(v4, (uint64_t)&unk_2651A8A50);
    sub_244D440EC(v8);
    return 0;
  }
  return result;
}

uint64_t sub_244D62A8C(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (!result)
    {
      sub_244D0B884(11, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_pubkey.c", 162);
      return 0;
    }
  }
  return result;
}

uint64_t sub_244D62AD0(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    sub_244D0C03C(*(unsigned int **)(a1 + 16));
  }
  else {
    sub_244D0B884(11, 0, 125, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_pubkey.c", 162);
  }
  return v1;
}

uint64_t sub_244D62B2C(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t result = sub_244D5FD7C(*a1, a2, a3, a4);
  if (result)
  {
    sub_244CF4790(a1[1], a5, a6);
    *(void *)(a1[1] + 16) &= 0xFFFFFFFFFFFFFFF0;
    *(void *)(a1[1] + 16) |= 8uLL;
    sub_244D62BA4((uint64_t)a1);
    return 1;
  }
  return result;
}

void sub_244D62BA4(uint64_t a1)
{
  sub_244D0BFD0(*(void *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  uint64_t v5 = 0;
  unsigned int v2 = sub_244CF6668(a1, &v5, (uint64_t)&unk_2651A8A50);
  if ((v2 & 0x80000000) == 0)
  {
    *(void *)&long long v4 = v5;
    *((void *)&v4 + 1) = v2;
    uint64_t v3 = sub_244D0C8E0(&v4);
    if (!v3 || *((void *)&v4 + 1)) {
      sub_244D0BFD0(v3);
    }
    else {
      *(void *)(a1 + 16) = v3;
    }
  }
  sub_244D440EC(v5);
  sub_244D0B1B0();
}

uint64_t sub_244D62C2C(void *a1, void *a2, _DWORD *a3, void *a4, uint64_t a5)
{
  if (a1) {
    *a1 = **(void **)a5;
  }
  if (a2)
  {
    *a2 = *(void *)(*(void *)(a5 + 8) + 8);
    *a3 = **(_DWORD **)(a5 + 8);
  }
  if (a4) {
    *a4 = *(void *)a5;
  }
  return 1;
}

uint64_t sub_244D62C6C(int a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (a1 == 5)
  {
    sub_244D62BA4(v3);
  }
  else if (a1 == 3)
  {
    sub_244D0BFD0(*(void *)(v3 + 16));
  }
  return 1;
}

uint64_t sub_244D62CAC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8B00);
}

uint64_t sub_244D62CB8(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8B00);
}

uint64_t sub_244D62CC4()
{
  return sub_244CF7888((uint64_t)&unk_2651A8B00);
}

void sub_244D62CD0(uint64_t a1)
{
}

uint64_t sub_244D62CDC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8B90);
}

uint64_t sub_244D62CE8(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8B90);
}

uint64_t sub_244D62CF4()
{
  return sub_244CF7888((uint64_t)&unk_2651A8B90);
}

void sub_244D62D00(uint64_t a1)
{
}

uint64_t sub_244D62D0C(uint64_t a1)
{
  return sub_244CF1264((uint64_t)&unk_2651A8B90, a1);
}

BOOL sub_244D62D1C(int a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (a1 == 5)
  {
    if ((sub_244CF1D00(*(void *)(v2 + 24)) & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      sub_244D0B884(11, 0, 140, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_req.c", 90);
      return 0;
    }
  }
  else if (a1 == 1)
  {
    uint64_t v3 = sub_244D4B4C8();
    *(void *)(v2 + 48) = v3;
    return v3 != 0;
  }
  return 1;
}

uint64_t sub_244D62D98(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8C00);
}

uint64_t sub_244D62DA4(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8C00);
}

uint64_t sub_244D62DB0()
{
  return sub_244CF7888((uint64_t)&unk_2651A8C00);
}

void sub_244D62DBC(uint64_t a1)
{
}

uint64_t sub_244D62DC8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8C70);
}

uint64_t sub_244D62DD4(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8C70);
}

uint64_t sub_244D62DE0()
{
  return sub_244CF7888((uint64_t)&unk_2651A8C70);
}

void sub_244D62DEC(uint64_t a1)
{
}

uint64_t sub_244D62DF8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8D00);
}

uint64_t sub_244D62E04(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8D00);
}

uint64_t sub_244D62E10()
{
  return sub_244CF7888((uint64_t)&unk_2651A8D00);
}

void sub_244D62E1C(uint64_t a1)
{
}

uint64_t sub_244D62E28(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8D70);
}

uint64_t sub_244D62E34(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8D70);
}

uint64_t sub_244D62E40()
{
  return sub_244CF7888((uint64_t)&unk_2651A8D70);
}

void sub_244D62E4C(uint64_t a1)
{
}

uint64_t sub_244D62E58(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8EE0);
}

uint64_t sub_244D62E64(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8EE0);
}

uint64_t sub_244D62E70()
{
  return sub_244CF7888((uint64_t)&unk_2651A8EE0);
}

void sub_244D62E7C(uint64_t a1)
{
}

void *sub_244D62E88()
{
  unsigned int v0 = sub_244D62EF4();
  if (v0)
  {
    void *v0 = sub_244CF7888((uint64_t)&unk_2651A8EE0);
    v0[1] = sub_244D5FD54();
    uint64_t v1 = sub_244CF7D18();
    v0[2] = v1;
    if (!*v0 || !v0[1] || !v1)
    {
      sub_244D62F44((uint64_t)v0);
      return 0;
    }
  }
  return v0;
}

void *sub_244D62EF4()
{
  unsigned int v0 = sub_244D44058(0x158uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    *((_DWORD *)v0 + 6) = 1;
    v0[5] = -1;
    sub_244D1389C(v0 + 4);
    sub_244D4BD2C((pthread_rwlock_t *)(v1 + 18));
  }
  return v1;
}

void sub_244D62F44(uint64_t a1)
{
  if (a1 && sub_244D49A14((unsigned int *)(a1 + 24)))
  {
    sub_244D138A4((uint64_t)&unk_268EBDE40, a1, (uint64_t *)(a1 + 32));
    sub_244CF746C(*(void *)a1, (uint64_t)&unk_2651A8EE0);
    sub_244D5FD60(*(void *)(a1 + 8));
    sub_244CF7CBC(*(void *)(a1 + 16));
    sub_244CF7CBC(*(void *)(a1 + 64));
    sub_244D504CC(*(void *)(a1 + 72));
    sub_244D53104(*(void *)(a1 + 80));
    sub_244D53FD0(*(void *)(a1 + 88));
    sub_244D54FB8(*(void *)(a1 + 96));
    sub_244D639CC(*(void *)(a1 + 136));
    j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 144));
    sub_244D440EC((void *)a1);
  }
}

uint64_t sub_244D63000(uint64_t *a1, void *a2, uint64_t a3)
{
  if (a3 < 0)
  {
    sub_244D0B884(12, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_x509.c", 238);
    uint64_t v5 = 0;
    if (!a1) {
      return v5;
    }
    goto LABEL_5;
  }
  *(void *)&long long v7 = *a2;
  *((void *)&v7 + 1) = a3;
  uint64_t v5 = sub_244D63098(&v7, 0);
  if (v5) {
    *a2 = v7;
  }
  if (a1)
  {
LABEL_5:
    sub_244D62F44(*a1);
    *a1 = v5;
  }
  return v5;
}

uint64_t sub_244D63098(long long *a1, uint64_t a2)
{
  long long v24 = 0uLL;
  int v22 = 0;
  uint64_t v23 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  int v18 = 0;
  unint64_t v19 = 0;
  if (!sub_244CFCD34(a1, &v24, 536870928)
    || *((void *)&v24 + 1) >> 30
    || !sub_244CFCDFC(&v24, &v22, 536870928)
    || !sub_244CFCDFC(&v24, &v20, 536870928))
  {
    __int16 v5 = 153;
LABEL_15:
    sub_244D0B884(12, 0, 109, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_x509.c", v5);
    return 0;
  }
  int v17 = 0;
  unint64_t v16 = 0;
  int v15 = 0;
  if (!sub_244CFCD04(&v24, &v18, &v17, &v16, 0, &v15)
    || v17 != 3
    || v15
    || !sub_244CFC510(&v18, v16)
    || *((void *)&v24 + 1))
  {
    __int16 v5 = 171;
    goto LABEL_15;
  }
  uint64_t v3 = sub_244D62EF4();
  uint64_t v4 = (uint64_t)v3;
  if (v3)
  {
    uint64_t v14 = v22;
    if ((int)sub_244CF5B2C((uint64_t)v3, (uint64_t *)&v14, v23, (uint64_t)&unk_2651A8EE0, -1, 0, 0, a2) < 1) {
      goto LABEL_13;
    }
    if (v14 != &v22[v23]) {
      goto LABEL_13;
    }
    uint64_t v14 = v20;
    uint64_t v7 = sub_244D5FD3C(0, (uint64_t *)&v14, v21);
    *(void *)(v4 + 8) = v7;
    if (!v7) {
      goto LABEL_13;
    }
    if (v14 != &v20[v21]) {
      goto LABEL_13;
    }
    uint64_t v14 = v18;
    BOOL v8 = sub_244CF0DEC(0, &v14, v19);
    *(void *)(v4 + 16) = v8;
    if (!v8 || v14 != &v18[v19]) {
      goto LABEL_13;
    }
    uint64_t v9 = *(uint64_t **)v4;
    uint64_t v10 = **(void **)v4;
    if (v10)
    {
      unint64_t v11 = sub_244CF1D00(v10);
      if (v11 >= 3)
      {
        int v12 = 140;
        __int16 v13 = 210;
LABEL_35:
        sub_244D0B884(11, 0, v12, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_x509.c", v13);
LABEL_13:
        sub_244D62F44(v4);
        return 0;
      }
      if (v11)
      {
        if (v11 == 2) {
          return v4;
        }
        uint64_t v9 = *(uint64_t **)v4;
        goto LABEL_33;
      }
      uint64_t v9 = *(uint64_t **)v4;
    }
    if (v9[7] || v9[8])
    {
      int v12 = 139;
      __int16 v13 = 218;
      goto LABEL_35;
    }
LABEL_33:
    if (!v9[9]) {
      return v4;
    }
    int v12 = 139;
    __int16 v13 = 224;
    goto LABEL_35;
  }
  return v4;
}

uint64_t sub_244D63318(uint64_t *a1, void **a2)
{
  if (a1)
  {
    memset(v13, 0, sizeof(v13));
    memset(v12, 0, sizeof(v12));
    if (sub_244CFB3DC((uint64_t)v13, 0x40uLL))
    {
      if (sub_244CFB808((uint64_t *)v13, (uint64_t)v12, 0x20000010u))
      {
        unint64_t v11 = 0;
        unsigned int v4 = sub_244CF6668(*a1, 0, (uint64_t)&unk_2651A8EE0);
        if ((v4 & 0x80000000) == 0)
        {
          unsigned int v5 = v4;
          if (sub_244CFBA94((uint64_t)v12, &v11, v4))
          {
            if (sub_244CF6668(*a1, &v11, (uint64_t)&unk_2651A8EE0) == v5)
            {
              unsigned int v6 = sub_244D5FD48(a1[1], 0);
              if ((v6 & 0x80000000) == 0)
              {
                unsigned int v7 = v6;
                if (sub_244CFBA94((uint64_t)v12, &v11, v6))
                {
                  if (sub_244D5FD48(a1[1], &v11) == v7)
                  {
                    unsigned int v8 = sub_244CF7D0C(a1[2], 0);
                    if ((v8 & 0x80000000) == 0)
                    {
                      unsigned int v9 = v8;
                      if (sub_244CFBA94((uint64_t)v12, &v11, v8))
                      {
                        if (sub_244CF7D0C(a1[2], &v11) == v9) {
                          return sub_244CFAE28((uint64_t)v13, a2);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_244CFB470((uint64_t)v13);
  }
  else
  {
    sub_244D0B884(12, 0, 155, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_x509.c", 261);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_244D6348C(uint64_t *a1)
{
  unsigned int v5 = 0;
  unsigned int v1 = sub_244D63318(a1, &v5);
  if ((v1 & 0x80000000) != 0) {
    return 0;
  }
  unsigned int v4 = v5;
  uint64_t v2 = sub_244D63000(0, &v4, v1);
  sub_244D440EC(v5);
  return v2;
}

uint64_t sub_244D634F0(uint64_t a1)
{
  *(void *)&long long v3 = sub_244CF48E8(a1);
  *((void *)&v3 + 1) = sub_244D07414(a1);
  uint64_t result = sub_244D63098(&v3, a1);
  if (!result || *((void *)&v3 + 1))
  {
    sub_244D62F44(result);
    return 0;
  }
  return result;
}

uint64_t sub_244D6354C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_244D136D4((uint64_t)&unk_268EBDE40, a1, a2, a5);
}

uint64_t sub_244D63564(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_244D137A8((unint64_t **)(a1 + 32), a2, a3);
}

unint64_t *sub_244D6356C(uint64_t a1, unsigned int a2)
{
  return sub_244D13838((uint64_t *)(a1 + 32), a2);
}

uint64_t sub_244D63574(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v12 = *a2;
  BOOL v6 = a1 && *a1;
  uint64_t v7 = sub_244D63000(a1, &v12, a3);
  uint64_t v8 = v7;
  if (v7)
  {
    uint64_t v9 = v12;
    uint64_t v10 = *a2 - v12 + a3;
    if (v10 < 1)
    {
LABEL_9:
      *a2 = v9;
      return v8;
    }
    if (sub_244D639A8((uint64_t *)(v7 + 136), &v12, v10))
    {
      uint64_t v9 = v12;
      goto LABEL_9;
    }
    if (v6) {
      return 0;
    }
    sub_244D62F44(v8);
    if (!a1)
    {
      return 0;
    }
    else
    {
      uint64_t v8 = 0;
      *a1 = 0;
    }
  }
  return v8;
}

uint64_t sub_244D63644(uint64_t *a1, void **a2)
{
  if (a2 && !*a2)
  {
    uint64_t v5 = sub_244D6370C(a1, 0);
    uint64_t v6 = v5;
    if ((int)v5 >= 1)
    {
      uint64_t v7 = sub_244D43FF4(v5);
      uint64_t v8 = v7;
      *a2 = v7;
      if (v7)
      {
        uint64_t v6 = sub_244D6370C(a1, &v8);
        if ((int)v6 <= 0)
        {
          sub_244D440EC(*a2);
          *a2 = 0;
        }
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    return v6;
  }
  else
  {
    return sub_244D6370C(a1, a2);
  }
}

uint64_t sub_244D6370C(uint64_t *a1, void **a2)
{
  if (a2) {
    unsigned int v4 = *a2;
  }
  else {
    unsigned int v4 = 0;
  }
  uint64_t v5 = sub_244D63318(a1, a2);
  uint64_t v6 = v5;
  if (a1)
  {
    if ((int)v5 >= 1)
    {
      uint64_t v7 = a1[17];
      if (v7)
      {
        uint64_t v8 = sub_244D639B4(v7, a2);
        if ((v8 & 0x80000000) != 0)
        {
          if (v4) {
            *a2 = v4;
          }
          return v8;
        }
        else
        {
          return (v8 + v6);
        }
      }
    }
  }
  return v6;
}

uint64_t sub_244D63790(uint64_t *a1, void **a2)
{
  sub_244CF806C(*a1 + 80);
  uint64_t v4 = *a1;

  return sub_244CF6668(v4, a2, (uint64_t)&unk_2651A8EE0);
}

uint64_t sub_244D637E0(uint64_t *a1, void **a2)
{
  return sub_244CF6668(*a1, a2, (uint64_t)&unk_2651A8EE0);
}

uint64_t sub_244D637F0(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = sub_244D5FD6C(a2);
  uint64_t v5 = sub_244D5FD6C(a2);
  uint64_t v6 = v5;
  if (v4 && v5)
  {
    sub_244D5FD60(a1[1]);
    a1[1] = v4;
    sub_244D5FD60(*(void *)(*a1 + 16));
    *(void *)(*a1 + 16) = v6;
    return 1;
  }
  else
  {
    sub_244D5FD60(v4);
    sub_244D5FD60(v6);
    return 0;
  }
}

void *sub_244D63878(void *result, void *a2, uint64_t a3)
{
  if (result) {
    *uint64_t result = *(void *)(a3 + 16);
  }
  if (a2) {
    *a2 = *(void *)(a3 + 8);
  }
  return result;
}

BOOL sub_244D63894(void *a1)
{
  uint64_t v2 = sub_244D62E88();
  *a1 = v2;
  return v2 != 0;
}

void sub_244D638C4(uint64_t *a1)
{
  *a1 = 0;
}

uint64_t sub_244D638F0(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a3 < 0)
  {
    sub_244D0B884(12, 0, 107, (uint64_t)"../../../../../../../../Sources/CHIPFramework/connectedhomeip/third_party/boringssl/repo/src/crypto/x509/x_x509.c", 315);
    return 0;
  }
  else
  {
    *(void *)&long long v9 = *a2;
    *((void *)&v9 + 1) = a3;
    if (a5 && !sub_244CFCE04(&v9, 536870928))
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t result = sub_244D63098(&v9, 0);
      if (result)
      {
        uint64_t v8 = result;
        *a2 = v9;
        sub_244D62F44(*a1);
        *a1 = v8;
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_244D639A0(uint64_t **a1, void **a2)
{
  return sub_244D63318(*a1, a2);
}

uint64_t sub_244D639A8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return sub_244CF5200(a1, a2, a3, (uint64_t)&unk_2651A8FC0);
}

uint64_t sub_244D639B4(uint64_t a1, void **a2)
{
  return sub_244CF6668(a1, a2, (uint64_t)&unk_2651A8FC0);
}

uint64_t sub_244D639C0()
{
  return sub_244CF7888((uint64_t)&unk_2651A8FC0);
}

void sub_244D639CC(uint64_t a1)
{
}

uint64_t sub_244D639D8(uint64_t a1, char *__s, size_t __n)
{
  if (__s)
  {
    if (a1)
    {
      uint64_t v6 = *(void *)(a1 + 136);
      if (v6 || (result = sub_244CF7888((uint64_t)&unk_2651A8FC0), uint64_t v6 = result, (*(void *)(a1 + 136) = result) != 0))
      {
        uint64_t result = *(void *)(v6 + 16);
        if (result || (uint64_t result = (uint64_t)sub_244CF7D38(), (*(void *)(v6 + 16) = result) != 0))
        {
          return sub_244CF45A0(result, __s, __n);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (a1)
    {
      uint64_t v8 = *(void *)(a1 + 136);
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 16);
        if (v9)
        {
          sub_244CF7CBC(v9);
          *(void *)(*(void *)(a1 + 136) + 16) = 0;
        }
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_244D63A98(uint64_t a1, char *__s, size_t __n)
{
  if (__s)
  {
    if (a1)
    {
      uint64_t v6 = *(void *)(a1 + 136);
      if (v6 || (result = sub_244CF7888((uint64_t)&unk_2651A8FC0), uint64_t v6 = result, (*(void *)(a1 + 136) = result) != 0))
      {
        uint64_t result = *(void *)(v6 + 24);
        if (result || (uint64_t result = (uint64_t)sub_244CF7CB4(), (*(void *)(v6 + 24) = result) != 0))
        {
          return sub_244CF45A0(result, __s, __n);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (a1)
    {
      uint64_t v8 = *(void *)(a1 + 136);
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 24);
        if (v9)
        {
          sub_244CF7CBC(v9);
          *(void *)(*(void *)(a1 + 136) + 24) = 0;
        }
      }
    }
    return 1;
  }
  return result;
}

int *sub_244D63B58(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2)
  {
    uint64_t result = 0;
    if (!a2) {
      return result;
    }
LABEL_6:
    int v4 = 0;
    goto LABEL_7;
  }
  uint64_t result = *(int **)(v2 + 16);
  if (!a2) {
    goto LABEL_8;
  }
  if (!result) {
    goto LABEL_6;
  }
  int v4 = *result;
LABEL_7:
  *a2 = v4;
LABEL_8:
  if (result) {
    return (int *)*((void *)result + 1);
  }
  return result;
}

int *sub_244D63B90(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2)
  {
    uint64_t result = 0;
    if (!a2) {
      return result;
    }
LABEL_6:
    int v4 = 0;
    goto LABEL_7;
  }
  uint64_t result = *(int **)(v2 + 24);
  if (!a2) {
    goto LABEL_8;
  }
  if (!result) {
    goto LABEL_6;
  }
  int v4 = *result;
LABEL_7:
  *a2 = v4;
LABEL_8:
  if (result) {
    return (int *)*((void *)result + 1);
  }
  return result;
}

uint64_t sub_244D63BC8(uint64_t a1, uint64_t a2)
{
  long long v3 = sub_244D44844(a2);
  if (v3)
  {
    int v4 = *(unint64_t ***)(a1 + 136);
    if (!v4)
    {
      int v4 = (unint64_t **)sub_244CF7888((uint64_t)&unk_2651A8FC0);
      *(void *)(a1 + 136) = v4;
    }
    uint64_t v5 = *v4;
    if (*v4 || (v5 = sub_244D4B4C8(), (*int v4 = v5) != 0))
    {
      if (sub_244D4BA04(v5, (uint64_t)v3)) {
        return 1;
      }
    }
  }
  sub_244CF29AC((void **)v3);
  return 0;
}

uint64_t sub_244D63C50(uint64_t a1, uint64_t a2)
{
  long long v3 = sub_244D44844(a2);
  if (v3)
  {
    if (a1)
    {
      uint64_t v4 = *(void *)(a1 + 136);
      if (!v4)
      {
        uint64_t v4 = sub_244CF7888((uint64_t)&unk_2651A8FC0);
        *(void *)(a1 + 136) = v4;
      }
    }
    else
    {
      uint64_t v4 = 0;
    }
    uint64_t v5 = *(unint64_t **)(v4 + 8);
    if (v5 || (uint64_t v5 = sub_244D4B4C8(), (*(void *)(v4 + 8) = v5) != 0))
    {
      if (sub_244D4BA04(v5, (uint64_t)v3)) {
        return 1;
      }
    }
  }
  sub_244CF29AC((void **)v3);
  return 0;
}

void sub_244D63CE4(uint64_t a1)
{
  unsigned int v1 = *(unint64_t ***)(a1 + 136);
  if (v1)
  {
    if (*v1)
    {
      sub_244D4B564(*v1, (void (*)(uint64_t))sub_244D63D9C, (uint64_t)sub_244CF29AC);
      **(void **)(a1 + 136) = 0;
    }
  }
}

void sub_244D63D40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 136);
  if (v1)
  {
    long long v3 = *(unint64_t **)(v1 + 8);
    if (v3)
    {
      sub_244D4B564(v3, (void (*)(uint64_t))sub_244D63D9C, (uint64_t)sub_244CF29AC);
      *(void *)(*(void *)(a1 + 136) + 8) = 0;
    }
  }
}

uint64_t sub_244D63D9C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sub_244D63DA8(uint64_t result, __int16 a2, int a3, __int16 a4)
{
  *(_WORD *)uint64_t result = a2;
  *(_DWORD *)(result + 2) = a3;
  *(_WORD *)(result + 6) = a4;
  *(void *)(result + 8) = 0;
  return result;
}

uint64_t sub_244D63DBC(uint64_t result, __int16 a2, int a3, __int16 a4, void *a5)
{
  *(_WORD *)uint64_t result = a2;
  *(_DWORD *)(result + 2) = a3;
  *(_WORD *)(result + 6) = a4;
  *(void *)(result + 8) = *a5;
  *a5 = 0;
  return result;
}

void sub_244D63DD8(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v23 = 0;
  uint64_t v4 = *a2;
  if (!*a2)
  {
    *(_DWORD *)a3 = 47;
    *(void *)(a3 + 8) = "src/protocols/secure_channel/StatusReport.cpp";
    int v13 = 53;
LABEL_16:
    *(_DWORD *)(a3 + 16) = v13;
    return;
  }
  uint64_t v7 = *(void *)(v4 + 8);
  uint64_t v8 = *(void *)(v4 + 24);
  uint64_t v18 = v7;
  uint64_t v19 = v7;
  uint64_t v20 = v8;
  LODWORD(v21) = 0;
  *((void *)&v21 + 1) = "src/lib/support/BufferReader.h";
  LODWORD(v22) = 330;
  if (!v7) {
    uint64_t v20 = 0;
  }
  int v17 = 0;
  sub_244CC54EC((uint64_t)&v18, &v23);
  sub_244CC5558((uint64_t)&v18, &v17);
  sub_244CC54EC((uint64_t)&v18, (_WORD *)(a1 + 6));
  *(_OWORD *)a3 = v21;
  *(void *)(a3 + 16) = v22;
  if (!*(_DWORD *)a3)
  {
    HIDWORD(v9) = v17;
    LODWORD(v9) = v17;
    *(_DWORD *)(a1 + 2) = v9 >> 16;
    *(_WORD *)a1 = v23;
    unint64_t v10 = *(void *)(*a2 + 24);
    if (v10 <= v19 - v18)
    {
      int v15 = *(_WORD **)(a1 + 8);
      if (v15) {
        sub_244CC8A0C(v15);
      }
      *(void *)(a1 + 8) = 0;
    }
    else
    {
      sub_244CC91B0((const void *)(*(void *)(*a2 + 8) + v19 - v18), v10 - (v19 - v18), 0, 0, &v16);
      unint64_t v11 = *(_WORD **)(a1 + 8);
      if (v11) {
        sub_244CC8A0C(v11);
      }
      uint64_t v12 = v16;
      *(void *)(a1 + 8) = v16;
      if (!v12)
      {
        int v13 = 71;
        int v14 = 11;
LABEL_15:
        *(_DWORD *)a3 = v14;
        *(void *)(a3 + 8) = "src/protocols/secure_channel/StatusReport.cpp";
        goto LABEL_16;
      }
    }
    int v14 = 0;
    int v13 = 79;
    goto LABEL_15;
  }
}

void *sub_244D63F44(unsigned __int16 *a1, void *a2)
{
  uint64_t v4 = sub_244CC57A8(a2, *a1, 2);
  uint64_t v5 = sub_244CC57A8(v4, a1[2] | ((unint64_t)a1[1] << 16), 4);
  sub_244CC57A8(v5, a1[3], 2);
  uint64_t v6 = *((void *)a1 + 1);
  if (v6) {
    sub_244CC572C(a2, *(const void **)(v6 + 8), *(void *)(v6 + 24));
  }
  return a2;
}

uint64_t sub_244D63FB4(unsigned __int16 *a1)
{
  v2[0] = 0;
  v2[1] = 0;
  uint64_t v3 = 0;
  sub_244D63F44(a1, v2);
  return v3;
}

void sub_244D63FE4(unsigned __int16 a1@<W0>, uint64_t *a2@<X8>)
{
  sub_244CC8F5C(2uLL, 0, &v24);
  if (v24)
  {
    uint64_t v4 = *((void *)v24 + 1);
    *(void *)buf = v4 + *((void *)v24 + 3);
    uint64_t v21 = sub_244CC8B50((uint64_t)v24);
    uint64_t v22 = 0;
    if (!v4) {
      uint64_t v21 = 0;
    }
    __int16 v23 = v24;
    long long v24 = 0;
    sub_244CC57A8(buf, a1, 2);
    sub_244CC9354(buf, (uint64_t *)&v23, &v12);
    if (v24) {
      sub_244CC8A0C(v24);
    }
    uint64_t v5 = (_WORD *)v12;
    long long v24 = (_WORD *)v12;
    if (v12)
    {
      long long v24 = 0;
      unsigned __int16 v16 = 8;
      int v17 = 0;
      __int16 v18 = 4;
      uint64_t v19 = v12;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      sub_244D63F44(&v16, &v12);
      sub_244CC8F5C(v14, 0x26u, &v12);
      if (v24) {
        sub_244CC8A0C(v24);
      }
      long long v24 = (_WORD *)v12;
      if (v12)
      {
        uint64_t v6 = *(void *)(v12 + 8);
        uint64_t v7 = v6 + *(void *)(v12 + 24);
        uint64_t v8 = sub_244CC8B50(v12);
        uint64_t v12 = v7;
        uint64_t v13 = v8;
        unint64_t v14 = 0;
        if (!v6) {
          uint64_t v13 = 0;
        }
        int v15 = v24;
        long long v24 = 0;
        sub_244D63F44(&v16, &v12);
        sub_244CC9354(&v12, (uint64_t *)&v15, a2);
        if (v15) {
          sub_244CC8A0C(v15);
        }
      }
      else
      {
        unint64_t v11 = sub_244CC8484(0xBu, "SecureChannel");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v12) = 0;
          _os_log_impl(&dword_2446BD000, v11, OS_LOG_TYPE_ERROR, "Failed to allocate status report message", (uint8_t *)&v12, 2u);
        }
        if (sub_244CC4E58(1u)) {
          sub_244CC4DE0(0xBu, 1);
        }
        *a2 = (uint64_t)v24;
        long long v24 = 0;
      }
      sub_244CC8A0C(v5);
    }
    else
    {
      unint64_t v10 = sub_244CC8484(0xBu, "SecureChannel");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v12) = 0;
        _os_log_impl(&dword_2446BD000, v10, OS_LOG_TYPE_ERROR, "Failed to finalize protocol data for busy status report", (uint8_t *)&v12, 2u);
      }
      if (sub_244CC4E58(1u)) {
        sub_244CC4DE0(0xBu, 1);
      }
      *a2 = (uint64_t)v24;
      long long v24 = 0;
    }
    if (v23) {
      sub_244CC8A0C(v23);
    }
    if (v24) {
      sub_244CC8A0C(v24);
    }
  }
  else
  {
    unint64_t v9 = sub_244CC8484(0xBu, "SecureChannel");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2446BD000, v9, OS_LOG_TYPE_ERROR, "Failed to allocate protocol data for busy status report", buf, 2u);
    }
    if (sub_244CC4E58(1u)) {
      sub_244CC4DE0(0xBu, 1);
    }
    *a2 = (uint64_t)v24;
  }
}

uint64_t sub_244D642D4(uint64_t a1, int a2, unsigned int a3)
{
  unint64_t v3 = (0xFFE0FFFFFFFFuLL >> a3) & 1;
  if (a3 > 0x33) {
    LODWORD(v3) = 1;
  }
  if (a2) {
    return 1;
  }
  else {
    return v3;
  }
}

BOOL sub_244D642FC(_DWORD *a1)
{
  if (!*a1) {
    return 1;
  }
  sub_244CC8788(51, "src/messaging/ErrorCategory.cpp", 40, (uint64_t)v4);
  if (*a1 == v4[0]) {
    return 1;
  }
  sub_244CC8788(49, "src/messaging/ErrorCategory.cpp", 40, (uint64_t)v3);
  return *a1 == v3[0];
}

__n128 sub_244D64384@<Q0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2)
  {
    sub_244CC8788(51, "src/messaging/ErrorCategory.cpp", 60, (uint64_t)v7);
    if (*(_DWORD *)a1 == v7[0]
      || (sub_244CC8788(49, "src/messaging/ErrorCategory.cpp", 60, (uint64_t)v6), *(_DWORD *)a1 == v6[0]))
    {
      *(_DWORD *)a1 = 0;
      *(void *)(a1 + 8) = "src/messaging/ErrorCategory.cpp";
      *(_DWORD *)(a1 + 16) = 62;
    }
  }
  __n128 result = *(__n128 *)a1;
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(void *)(a3 + 16) = *(void *)(a1 + 16);
  return result;
}

BOOL sub_244D64430(unsigned int *a1)
{
  unsigned int v2 = *a1;
  BOOL result = 1;
  BOOL v4 = v2 > 0x2D || ((1 << v2) & 0x200000000810) == 0;
  if (v4 && v2 != 195)
  {
    sub_244CC8788(65, "src/messaging/ErrorCategory.cpp", 81, (uint64_t)v8);
    if (*a1 == v8[0]) {
      return 1;
    }
    sub_244CC8788(51, "src/messaging/ErrorCategory.cpp", 81, (uint64_t)v7);
    if (*a1 == v7[0]) {
      return 1;
    }
    sub_244CC8788(49, "src/messaging/ErrorCategory.cpp", 81, (uint64_t)v6);
    if (*a1 == v6[0])
    {
      return 1;
    }
    else
    {
      sub_244CC8788(32, "src/messaging/ErrorCategory.cpp", 81, (uint64_t)v5);
      return *a1 == v5[0];
    }
  }
  return result;
}

uint64_t sub_244D64530(uint64_t a1)
{
  return *(_WORD *)(a1 + 8) & 1;
}

uint64_t sub_244D6453C(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 8) >> 1) & 1;
}

uint64_t sub_244D64548(uint64_t result, int a2)
{
  if (a2) {
    __int16 v2 = 2048;
  }
  else {
    __int16 v2 = 0;
  }
  if (a2) {
    __int16 v3 = 2;
  }
  else {
    __int16 v3 = 0;
  }
  *(_WORD *)(result + 8) = *(_WORD *)(result + 8) & 0xF7FD | v3 | v2;
  return result;
}

uint64_t sub_244D64578(uint64_t a1, int a2)
{
  BOOL v4 = (uint64_t *)sub_2446F7170((unsigned char *)(a1 + 88));
  uint64_t result = sub_244D87C24(*v4, a2);
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

uint64_t sub_244D645B4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 32) = a2;
  return result;
}

void sub_244D645BC(uint64_t a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, uint64_t *a4@<X3>, _WORD *a5@<X4>, uint64_t a6@<X8>)
{
  sub_244D6A434("src/messaging/ExchangeContext.cpp", 93);
  unsigned int v12 = a2;
  BOOL v13 = a3 == 16 && a2 == 0;
  if (!*(void *)(a1 + 48))
  {
    *(_DWORD *)a6 = 172;
    *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
    int v16 = 98;
LABEL_28:
    *(_DWORD *)(a6 + 16) = v16;
    return;
  }
  if (!*(unsigned char *)(a1 + 88))
  {
    *(_DWORD *)a6 = 2;
    *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
    int v16 = 99;
    goto LABEL_28;
  }
  unint64_t v14 = (int *)(a1 + 28);
  if (!*(_DWORD *)(a1 + 28)) {
    sub_244E25C08();
  }
  sub_244CDBFD0((int *)(a1 + 28));
  sub_24479B4A8(a1, buf);
  int v15 = (*(unsigned int (**)(void))(**(void **)buf + 72))(*(void *)buf)
     && (*a5 & 2) == 0
     && !sub_244CA97BC(a1);
  (*(void (**)(void))(**(void **)buf + 32))(*(void *)buf);
  if ((*a5 & 1) == 0 || sub_244CA97BC(a1)) {
    goto LABEL_14;
  }
  __int16 v22 = *(_WORD *)(a1 + 8);
  if ((v22 & 2) != 0)
  {
    *(_DWORD *)a6 = 3;
    *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
    int v18 = 122;
LABEL_43:
    *(_DWORD *)(a6 + 16) = v18;
    goto LABEL_44;
  }
  *(_WORD *)(a1 + 8) = v22 | 0x802;
  if (!*(_DWORD *)(a1 + 32))
  {
LABEL_14:
    int v17 = 0;
LABEL_15:
    if (!sub_244CA97BC(a1) || (*(_WORD *)(a1 + 8) & 1) != 0)
    {
      if (*(unsigned char *)(a1 + 88))
      {
        sub_24479B4A8(a1, &v27);
        uint64_t v19 = (__int16 *)(a1 + 8);
        sub_244D65B04(*(void *)(a1 + 56), *(void *)(*(void *)(a1 + 48) + 88), &v27, *(unsigned __int16 *)(a1 + 112), *(_WORD *)(a1 + 8) & 1, a1 + 8, v15, v12, (uint64_t)buf, a3, a4);
        *(_OWORD *)a6 = *(_OWORD *)buf;
        *(void *)(a6 + 16) = v26;
        if (*(_DWORD *)a6)
        {
          if (v17)
          {
            uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 48) + 88) + 24);
            if (v20) {
              (*(void (**)(uint64_t, void (*)(uint64_t, uint64_t), uint64_t))(*(void *)v20 + 72))(v20, sub_244D6520C, a1);
            }
            *v19 &= 0xF7FDu;
          }
          if ((*(unsigned int (**)(uint64_t))(*(void *)v27 + 16))(v27) == 2
            && *(unsigned char *)(sub_244D879D8(v27) + 57) == 2)
          {
            uint64_t v21 = sub_244D879D8(v27);
            sub_244D85724(v21);
          }
        }
        else if (!v13)
        {
          __int16 v24 = *v19;
          *v19 &= ~0x40u;
          if ((v24 & 0x82) == 0) {
            sub_244D64B58(a1);
          }
        }
        (*(void (**)(uint64_t))(*(void *)v27 + 32))(v27);
        goto LABEL_44;
      }
      __int16 v23 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2446BD000, v23, OS_LOG_TYPE_ERROR, "WARNING: We shouldn't be sending a message on an exchange that has no attached session...", buf, 2u);
      }
      if (sub_244CC4E58(1u)) {
        sub_244CC4DE0(5u, 1);
      }
      *(_DWORD *)a6 = 119;
      *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
      int v18 = 158;
    }
    else
    {
      *(_DWORD *)a6 = 172;
      *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
      int v18 = 144;
    }
    goto LABEL_43;
  }
  *(void *)a6 = 0;
  *(void *)(a6 + 8) = 0;
  *(void *)(a6 + 16) = 0;
  sub_244D6499C(a1, a6);
  if (!*(_DWORD *)a6)
  {
    int v17 = 1;
    goto LABEL_15;
  }
  *(_WORD *)(a1 + 8) &= 0xF7FDu;
LABEL_44:
  sub_244CDBF88(v14);
}

uint64_t sub_244D6499C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 48) + 88) + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, void (*)(uint64_t, uint64_t)))(*(void *)result + 40))(result, *(unsigned int *)(a1 + 32), sub_244D6520C);
  }
  *(_DWORD *)a2 = 172;
  *(void *)(a2 + 8) = "src/messaging/ExchangeContext.cpp";
  *(_DWORD *)(a2 + 16) = 435;
  return result;
}

uint64_t sub_244D64A08(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 48) + 88) + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void (*)(uint64_t, uint64_t), uint64_t))(*(void *)result + 72))(result, sub_244D6520C, a1);
  }
  return result;
}

void sub_244D64A54(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 8) & 0xC2) == 0) {
    sub_244D64B58(a1);
  }
}

void sub_244D64A6C(uint64_t a1, int a2)
{
  __int16 v3 = (_WORD *)(a1 + 8);
  __int16 v2 = *(_WORD *)(a1 + 8);
  if ((v2 & 0x80) == 0)
  {
    *(_WORD *)(a1 + 8) = v2 | 0x80;
    uint64_t v6 = *(void *)(a1 + 40);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 32))(v6, a1);
    }
    *(void *)(a1 + 40) = 0;
    sub_244D67B88((uint64_t)v3, (uint64_t)v8);
    if (a2) {
      sub_244D6966C(*(void *)(a1 + 48) + 96, (uint64_t)v3);
    }
    if ((*v3 & 2) != 0)
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 48) + 88) + 24);
      if (v7) {
        (*(void (**)(uint64_t, void (*)(uint64_t, uint64_t), uint64_t))(*(void *)v7 + 72))(v7, sub_244D6520C, a1);
      }
    }
  }
}

void sub_244D64B58(uint64_t a1)
{
  if (!*(void *)(a1 + 48) || (uint64_t v1 = (int *)(a1 + 28), !*(_DWORD *)(a1 + 28))) {
    sub_244E25CA8();
  }
  sub_244D64A6C();

  sub_244CDBF88(v1);
}

void sub_244D64BA8(uint64_t a1)
{
  if (!*(void *)(a1 + 48) || (uint64_t v1 = (int *)(a1 + 28), !*(_DWORD *)(a1 + 28))) {
    sub_244E25D48();
  }
  sub_244D64A6C(a1, 1);

  sub_244CDBF88(v1);
}

void sub_244D64BF8(uint64_t a1)
{
}

uint64_t sub_244D64C08(uint64_t a1, uint64_t a2, __int16 a3, uint64_t *a4, int a5, uint64_t a6, int a7)
{
  unint64_t v14 = (_WORD *)(a1 + 8);
  sub_244D67B44(a1 + 8);
  *(void *)a1 = &unk_26F956398;
  *(void *)(a1 + 28) = 1;
  *(void *)(a1 + 40) = 0;
  int v15 = (uint64_t *)(a1 + 40);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = sub_244D64DB8(a7, a6);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  *(void *)(a1 + 104) = a1;
  *(void *)(a1 + 64) = &unk_26F956440;
  if (*(void *)(a1 + 48)) {
    sub_244E25DE8(a1);
  }
  *(void *)(a1 + 48) = a2;
  *(_WORD *)(a1 + 112) = a3;
  sub_244D88328((void *)(a1 + 64), a4);
  __int16 v16 = *(_WORD *)(a1 + 8);
  if (a5)
  {
    __int16 v17 = v16 | 1;
    if ((a7 & 1) == 0)
    {
      *int v15 = a6;
      __int16 v18 = v17 & 0xFEBF | 0x40;
      goto LABEL_10;
    }
  }
  else
  {
    if ((a7 & 1) == 0)
    {
      __int16 v18 = v16 & 0xFEFE;
      goto LABEL_9;
    }
    __int16 v17 = v16 & 0xFFFE;
  }
  __int16 v18 = v17 | 0x100;
LABEL_9:
  *int v15 = a6;
LABEL_10:
  *unint64_t v14 = v18 & 0xFFEF;
  if ((*(unsigned int (**)(void))(*(void *)*a4 + 72))()) {
    __int16 v19 = 4;
  }
  else {
    __int16 v19 = 0;
  }
  *unint64_t v14 = *v14 & 0xFFFB | v19;
  uint64_t v20 = sub_244CC9408();
  char v21 = *((unsigned char *)v20 + 4) + 1;
  *((unsigned char *)v20 + 4) = v21;
  if (*((char *)sub_244CC9414() + 4) < v21) {
    *((unsigned char *)sub_244CC9414() + 4) = v21;
  }
  return a1;
}

uint64_t *sub_244D64DB8(int a1, uint64_t a2)
{
  if (a1) {
    return sub_244D656DC();
  }
  if (a2) {
    return (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  }
  return sub_24479EC7C();
}

uint64_t sub_244D64DF4(uint64_t a1)
{
  *(void *)a1 = &unk_26F956398;
  if (!*(void *)(a1 + 48) || *(_DWORD *)(a1 + 28)) {
    sub_244E25E8C(a1);
  }
  if ((*(_WORD *)(a1 + 8) & 0x80) == 0) {
    sub_244E25F30(a1);
  }
  sub_244D64A6C(a1, 0);
  *(void *)(a1 + 48) = 0;
  __int16 v2 = sub_244CC9408();
  --*((unsigned char *)v2 + 4);
  sub_244D87E54(a1 + 64);
  return a1;
}

void sub_244D64E8C(uint64_t a1)
{
  sub_244D64DF4(a1);

  JUMPOUT(0x245695FA0);
}

uint64_t sub_244D64EC4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned __int16 *)(a1 + 112) != *(unsigned __int16 *)(a4 + 2)) {
    goto LABEL_4;
  }
  int v7 = *(unsigned __int8 *)(a1 + 88);
  uint64_t v5 = (unsigned char *)(a1 + 88);
  LOBYTE(v6) = v7;
  if (v7)
  {
    if (*(void *)sub_2446F7170(v5) != *a2)
    {
LABEL_4:
      LOBYTE(v6) = 0;
      return v6 & 1;
    }
    int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56));
    if (*(_WORD *)(a3 + 44))
    {
      if ((v11 & 1) == 0) {
        goto LABEL_4;
      }
    }
    else if ((v11 ^ (*(unsigned char *)(a3 + 46) != 0)))
    {
      goto LABEL_4;
    }
    __int16 v6 = *(unsigned __int8 *)(a4 + 8) ^ *(_WORD *)(a1 + 8);
  }
  return v6 & 1;
}

void sub_244D64F88(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  __int16 v2 = *(_WORD *)(a1 + 8);
  if ((v2 & 0x200) == 0)
  {
    if ((v2 & 0x80) != 0)
    {
      uint64_t v6 = *(void *)(a1 + 48) + 96;
      sub_244D6966C(v6, v1);
    }
    else
    {
      sub_244CDBFD0((int *)(a1 + 28));
      __int16 v4 = *(_WORD *)(a1 + 8);
      if ((v4 & 0x40) != 0)
      {
        sub_244D64A6C(a1, 1);
      }
      else
      {
        if ((v4 & 2) != 0)
        {
          uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 48) + 88) + 24);
          if (v5) {
            (*(void (**)(uint64_t, void (*)(uint64_t, uint64_t), uint64_t))(*(void *)v5 + 72))(v5, sub_244D6520C, a1);
          }
          sub_244D65080(a1, 0);
        }
        sub_244D64BA8(a1);
      }
      sub_244CDBF88((int *)(a1 + 28));
    }
  }
}

void sub_244D65080(uint64_t a1, int a2)
{
  int v4 = *(_WORD *)(a1 + 8) & 0x800;
  *(_WORD *)(a1 + 8) &= 0xF7FDu;
  uint64_t v5 = (int *)(a1 + 28);
  sub_244CDBFD0((int *)(a1 + 28));
  if (*(unsigned char *)(a1 + 88)) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    int v7 = sub_2446F7170((unsigned char *)(a1 + 88));
    if ((*(unsigned int (**)(void))(**(void **)v7 + 16))(*(void *)v7) == 2)
    {
      uint64_t v8 = (uint64_t *)sub_2446F7170((unsigned char *)(a1 + 88));
      if (*(unsigned char *)(sub_244D879D8(*v8) + 57) == 2)
      {
        unint64_t v9 = (uint64_t *)sub_2446F7170((unsigned char *)(a1 + 88));
        uint64_t v10 = sub_244D879D8(*v9);
        sub_244D85724(v10);
      }
    }
    int v11 = sub_2446F7170((unsigned char *)(a1 + 88));
    uint64_t v12 = *(void *)v11 + 8;
    uint64_t v13 = *(void *)(*(void *)v11 + 16);
    if (v13 != v12)
    {
      do
      {
        uint64_t v14 = *(void *)(v13 + 8);
        if (v13) {
          uint64_t v15 = v13 - 8;
        }
        else {
          uint64_t v15 = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v15 + 32))(v15);
        uint64_t v13 = v14;
      }
      while (v14 != v12);
    }
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 24))(v16, a1);
  }
  if (a2 && (*(_WORD *)(a1 + 8) & 0xC2) == 0) {
    sub_244D64B58(a1);
  }

  sub_244CDBF88(v5);
}

void sub_244D6520C(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_244D65080(a2, 1);
  }
}

void sub_244D65220(uint64_t a1@<X0>, int a2@<W1>, unsigned __int8 *a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v12 = (int *)(a1 + 28);
  sub_244CDBFD0((int *)(a1 + 28));
  if (*((unsigned __int16 *)a3 + 2) | *((unsigned __int16 *)a3 + 3)) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = *a3 == 16;
  }
  int v14 = a4 & 1;
  uint64_t v15 = sub_2446F7170((unsigned char *)(a1 + 88));
  if (!(*(unsigned int (**)(void))(**(void **)v15 + 72))(*(void *)v15)) {
    goto LABEL_16;
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56)))
  {
    if ((a4 & 1) == 0 && (a3[8] & 2) != 0 && a3[12])
    {
      uint64_t v16 = (int *)sub_2446F12CC(a3 + 12);
      sub_244D6804C(a1 + 8, *v16);
    }
    if ((a3[8] & 4) != 0) {
      sub_244D6819C(a1 + 8, a2, a4, &buf);
    }
  }
  if ((*(_WORD *)(a1 + 8) & 0x10) == 0
    || *(void *)(a1 + 40)
    || (*(void *)a6 = 0,
        *(void *)(a6 + 8) = 0,
        *(void *)(a6 + 16) = 0,
        sub_244D67B88(a1 + 8, a6),
        !*(_DWORD *)a6))
  {
    if (v13)
    {
      int v17 = 560;
LABEL_18:
      *(_DWORD *)a6 = 0;
      *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
      *(_DWORD *)(a6 + 16) = v17;
      goto LABEL_19;
    }
LABEL_16:
    if (a4)
    {
      int v17 = 567;
      goto LABEL_18;
    }
    __int16 v18 = sub_2446F7170((unsigned char *)(a1 + 88));
    int v19 = (*(uint64_t (**)(void))(**(void **)v18 + 72))(*(void *)v18);
    __int16 v20 = *(_WORD *)(a1 + 8);
    if (!v19) {
      goto LABEL_24;
    }
    if ((*(_WORD *)(a1 + 8) & 0x100) != 0)
    {
      *(_DWORD *)a6 = 0;
      *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
      int v29 = 575;
    }
    else
    {
      if ((v20 & 8) == 0)
      {
LABEL_24:
        *(_WORD *)(a1 + 8) = v20 | 0x400;
        if ((*(unsigned int (**)(void, void, void))(**(void **)(a1 + 56) + 24))(*(void *)(a1 + 56), *((unsigned int *)a3 + 1), *a3))
        {
          __int16 v21 = *(_WORD *)(a1 + 8);
          if ((v21 & 2) != 0)
          {
            uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 48) + 88) + 24);
            if (v22)
            {
              (*(void (**)(uint64_t, void (*)(uint64_t, uint64_t), uint64_t))(*(void *)v22 + 72))(v22, sub_244D6520C, a1);
              __int16 v21 = *(_WORD *)(a1 + 8);
            }
            *(_WORD *)(a1 + 8) = v21 & 0xF7FD;
          }
          uint64_t v23 = *(void *)(a1 + 40);
          if (v23)
          {
            (*(void (**)(uint64_t, uint64_t, unsigned __int8 *, uint64_t))(*(void *)v23 + 16))(v23, a1, a3, a5);
            goto LABEL_48;
          }
        }
        unsigned int v24 = *((_DWORD *)a3 + 1);
        int v25 = *a3;
        uint64_t v26 = sub_244CC8484(5u, "ExchangeManager");
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          int v27 = *(unsigned __int16 *)(a1 + 112);
          if (*(_WORD *)(a1 + 8)) {
            int v28 = 105;
          }
          else {
            int v28 = 114;
          }
          LODWORD(buf) = 67110400;
          HIDWORD(buf) = v25;
          __int16 v33 = 1024;
          int v34 = (unsigned __int16)v24;
          __int16 v35 = 1024;
          unsigned int v36 = HIWORD(v24);
          __int16 v37 = 1024;
          int v38 = a2;
          __int16 v39 = 1024;
          int v40 = v27;
          __int16 v41 = 1024;
          int v42 = v28;
          _os_log_impl(&dword_2446BD000, v26, OS_LOG_TYPE_ERROR, "Dropping unexpected message of type 0x%x with protocolId (%u, %u) and MessageCounter:%u on exchange %u%c", (uint8_t *)&buf, 0x26u);
        }
        if (sub_244CC4E58(1u)) {
          sub_244CC4DE0(5u, 1);
        }
        *(_DWORD *)a6 = 0;
        *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
        int v29 = 623;
        goto LABEL_47;
      }
      unsigned int v30 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_2446BD000, v30, OS_LOG_TYPE_ERROR, "Dropping message without piggyback ack when we are waiting for an ack.", (uint8_t *)&buf, 2u);
      }
      if (sub_244CC4E58(1u)) {
        sub_244CC4DE0(5u, 1);
      }
      *(_DWORD *)a6 = 3;
      *(void *)(a6 + 8) = "src/messaging/ExchangeContext.cpp";
      int v29 = 587;
    }
LABEL_47:
    *(_DWORD *)(a6 + 16) = v29;
  }
LABEL_48:
  if (v14) {
    char v31 = 1;
  }
  else {
    char v31 = v13;
  }
  if (v31)
  {
LABEL_19:
    if (*(void *)(a1 + 40)) {
      goto LABEL_54;
    }
  }
  if ((*(_WORD *)(a1 + 8) & 0xC2) == 0) {
    sub_244D64B58(a1);
  }
LABEL_54:
  sub_244CDBF88(v12);
}

uint64_t *sub_244D656DC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268EBDF28, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268EBDF28))
  {
    qword_268EBDF20 = (uint64_t)&unk_26F9564A8;
    __cxa_guard_release(&qword_268EBDF28);
  }
  return &qword_268EBDF20;
}

uint64_t sub_244D6574C(uint64_t a1)
{
  uint64_t v1 = (unsigned char *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88)
    && (__int16 v3 = sub_2446F7170((unsigned char *)(a1 + 88)),
        (*(unsigned int (**)(void))(**(void **)v3 + 16))(*(void *)v3) == 2))
  {
    sub_24479DD24((uint64_t)(v1 - 24), (uint64_t)v9);
    *(_WORD *)(a1 + 8) |= 0x200u;
    uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 88);
    uint64_t v5 = sub_2446F7170(v1);
    sub_244D89DEC(v4, *(unsigned __int8 *)(*(void *)v5 + 24));
    BOOL v6 = (uint64_t *)sub_24479DC08(v9);
    uint64_t result = (uint64_t)sub_244D658B8((uint64_t)(v1 - 24), v6);
    *(_WORD *)(a1 + 8) &= ~0x200u;
    if (v9[0]) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v10 + 32))(v10);
    }
  }
  else
  {
    uint64_t v8 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v9 = 0;
      _os_log_impl(&dword_2446BD000, v8, OS_LOG_TYPE_ERROR, "AbortAllOtherCommunicationOnFabric called when we don't have a PASE/CASE session", v9, 2u);
    }
    uint64_t result = sub_244CC4E58(1u);
    if (result) {
      return sub_244CC4DE0(5u, 1);
    }
  }
  return result;
}

void *sub_244D658B8(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(sub_244D879D8(*a2) + 56) != 4) {
    sub_244E25FD4();
  }

  return sub_244D882DC(a1, a2);
}

void sub_244D65910(uint64_t a1, void (***a2)(void))
{
  if (a2)
  {
    uint64_t v4 = sub_244CC6450((void *)(a1 + 16), (uint64_t)a2);
    if (!v4) {
      sub_244E26074();
    }
    uint64_t v5 = v4;
    *uint64_t v4 = 0;
    (**a2)(a2);
    j__free(a2);
    if (*(void *)(a1 + 40))
    {
      *(unsigned char *)(a1 + 48) = 1;
    }
    else
    {
      *(void *)(v5[1] + 16) = v5[2];
      *(void *)(v5[2] + 8) = v5[1];
      j__free(v5);
    }
    --*(void *)a1;
  }
}

void sub_244D659C0(uint64_t a1)
{
  sub_244D87E54(a1);

  JUMPOUT(0x245695FA0);
}

uint64_t sub_244D659F8(uint64_t a1)
{
  sub_244D87ED0((void *)a1);
  __int16 v2 = *(uint64_t (**)(void))(**(void **)(a1 + 40) + 24);

  return v2();
}

uint64_t sub_244D65A50(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40));
  if (!result)
  {
    sub_244D87ED0((void *)a1);
    return sub_244D88328((void *)a1, a2);
  }
  return result;
}

uint64_t sub_244D65ACC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 32))();
}

BOOL sub_244D65AF4(uint64_t a1, int a2, int a3)
{
  return !a2 && a3 == 16;
}

void sub_244D65B04(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, int a4@<W3>, int a5@<W4>, uint64_t a6@<X5>, int a7@<W6>, unsigned int a8@<W7>, uint64_t a9@<X8>, unsigned __int8 a10, uint64_t *a11)
{
  if (((*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 24))(a1, a8, a10) & 1) == 0)
  {
    *(_DWORD *)a9 = 47;
    *(void *)(a9 + 8) = "src/messaging/ExchangeMessageDispatch.cpp";
    int v22 = 41;
LABEL_11:
    *(_DWORD *)(a9 + 16) = v22;
    return;
  }
  char v38 = 0;
  __int16 v35 = a4;
  unsigned int v36 = a8;
  v34[0] = a10;
  char v20 = a5 | (16 * ((unsigned __int16)a8 != 0));
  char v37 = v20;
  if (!(*(unsigned int (**)(void))(*(void *)*a3 + 72))()) {
    goto LABEL_9;
  }
  if ((*(_WORD *)a6 & 0x20) != 0)
  {
    *(_WORD *)a6 &= ~0x10u;
    int v21 = *(_DWORD *)(a6 + 16);
    char v38 = 1;
    int v39 = v21;
    v20 |= 2u;
    char v37 = v20;
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 32))(a1)
    || (*(_WORD *)a6 & 4) == 0
    || !sub_244D67B5C(a6)
    || !a7)
  {
LABEL_9:
    *(void *)a9 = 0;
    *(void *)(a9 + 8) = 0;
    *(void *)(a9 + 16) = 0;
    sub_244D65DE8(a2, a3, v34, a11, (void *)a9);
    if (*(_DWORD *)a9) {
      return;
    }
    goto LABEL_10;
  }
  uint64_t v23 = (uint64_t *)sub_244D67B5C(a6);
  char v37 = v20 | 4;
  uint64_t v33 = 0;
  *(void *)(a9 + 8) = 0;
  *(void *)(a9 + 16) = 0;
  *(void *)a9 = 0;
  sub_244D688DC((uint64_t)v23, (_WORD *)a6, &v33, a9);
  if (!*(_DWORD *)a9)
  {
    uint64_t v24 = v33;
    *(void *)(a9 + 8) = 0;
    *(void *)(a9 + 16) = 0;
    *(void *)a9 = 0;
    sub_244D88A18(a2, a3, v34, a11, (_WORD **)(v24 + 8), a9);
    if (*(_DWORD *)a9) {
      goto LABEL_18;
    }
    long long v31 = 0uLL;
    uint64_t v32 = 0;
    sub_244D89520(a2, a3, (uint64_t *)(v24 + 8), (uint64_t)&v31);
    long long v27 = v31;
    uint64_t v28 = v32;
    sub_244D694C4((uint64_t)&v27, a4, a5, (uint64_t)&v29);
    uint64_t v25 = v30;
    uint64_t v32 = v30;
    long long v31 = v29;
    *(_OWORD *)a9 = v29;
    *(void *)(a9 + 16) = v25;
    if (*(_DWORD *)a9)
    {
LABEL_18:
      int v26 = 1;
      if (v24) {
        sub_244D69488(v23, (void *)v24);
      }
    }
    else
    {
      sub_244D68B10(v23, v24);
      int v26 = 0;
    }
    if (!v26)
    {
LABEL_10:
      *(_DWORD *)a9 = 0;
      *(void *)(a9 + 8) = "src/messaging/ExchangeMessageDispatch.cpp";
      int v22 = 87;
      goto LABEL_11;
    }
  }
}

void sub_244D65DE8(uint64_t a1@<X1>, uint64_t *a2@<X2>, unsigned __int8 *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  a3[8] &= ~4u;
  uint64_t v8 = 0;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  sub_244D88A18(a1, a2, a3, a4, &v8, (uint64_t)a5);
  if (!*(_DWORD *)a5)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
    sub_244D89520(a1, a2, (uint64_t *)&v8, (uint64_t)a5);
    if (!*(_DWORD *)a5)
    {
      *(_DWORD *)a5 = 0;
      a5[1] = "src/messaging/ExchangeMessageDispatch.cpp";
      *((_DWORD *)a5 + 4) = 99;
    }
  }
  if (v8) {
    sub_244CC8A0C(v8);
  }
}

uint64_t sub_244D65EA8(uint64_t a1)
{
  *(void *)a1 = &unk_26F9564F8;
  *(void *)(a1 + 8) = &unk_26F956528;
  *(unsigned char *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(unsigned char *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 56) = a1 + 48;
  *(void *)(a1 + 64) = a1 + 48;
  sub_244D68580(a1 + 96, a1 + 32);
  for (uint64_t i = 176; i != 304; i += 16)
    *(_DWORD *)(a1 + i) = -1;
  *(_DWORD *)(a1 + 20) = 0;
  return a1;
}

double sub_244D65F54@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)(a1 + 20))
  {
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 8) = "src/messaging/ExchangeMgr.cpp";
    *(_DWORD *)(a3 + 16) = 63;
  }
  else
  {
    *(void *)(a1 + 88) = a2;
    *(_WORD *)(a1 + 16) = sub_244CE993C();
    *(_WORD *)(a1 + 18) = 0;
    for (uint64_t i = 184; i != 312; i += 16)
      *(void *)(a1 + i) = 0;
    a2[29] = a1;
    a2[30] = a1 + 8;
    sub_244D22EC4(a1 + 96, a2[3]);
    *(_DWORD *)(a1 + 20) = 1;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = "src/messaging/ExchangeMgr.cpp";
    *(void *)&double result = 61;
    *(void *)(a3 + 16) = 61;
  }
  return result;
}

uint64_t sub_244D66004(uint64_t result)
{
  if (*(_DWORD *)(result + 20))
  {
    uint64_t v1 = result;
    double result = sub_244D685D4(result + 96);
    uint64_t v2 = *(void *)(v1 + 88);
    if (v2)
    {
      *(void *)(v2 + 232) = 0;
      *(void *)(v1 + 88) = 0;
    }
    *(_DWORD *)(v1 + 20) = 0;
  }
  return result;
}

void *sub_244D66048(uint64_t a1, void *a2, uint64_t a3, unsigned __int8 a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v15 = a3;
  unsigned __int8 v14 = a4;
  if ((*(uint64_t (**)(void))(*(void *)*a2 + 40))())
  {
    *(void *)uint64_t buf = a1;
    unsigned __int16 v6 = *(_WORD *)(a1 + 16);
    *(_WORD *)(a1 + 16) = v6 + 1;
    unsigned __int16 v13 = v6;
    return sub_244D66200((unint64_t *)(a1 + 32), buf, &v13, (uint64_t)a2, &v14, &v15);
  }
  else
  {
    uint64_t v8 = (*(uint64_t (**)(void))(*(void *)*a2 + 48))();
    unsigned __int8 v10 = v9;
    int v11 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = ((uint64_t (*)(void))loc_244D87D38)(*a2);
      *(_DWORD *)uint64_t buf = 67109888;
      *(_DWORD *)&buf[4] = v12;
      __int16 v17 = 1024;
      int v18 = HIDWORD(v8);
      __int16 v19 = 1024;
      int v20 = v8;
      __int16 v21 = 1024;
      int v22 = v10;
      _os_log_impl(&dword_2446BD000, v11, OS_LOG_TYPE_ERROR, "NewContext failed: session %u to <%08X%08X, %d> is inactive", buf, 0x1Au);
    }
    if (sub_244CC4E58(1u))
    {
      ((uint64_t (*)(void))loc_244D87D38)(*a2);
      sub_244CC4DE0(5u, 1);
    }
    return 0;
  }
}

void *sub_244D66200(unint64_t *a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, void *a6)
{
  int v12 = sub_244CC4D84(0x78uLL);
  unsigned __int16 v13 = v12;
  if (v12)
  {
    sub_244D64DF0(v12, *a2, *a3, a4, *a5, *a6, 0);
    unsigned __int8 v14 = sub_244CC4D84(0x18uLL);
    if (v14)
    {
      *unsigned __int8 v14 = v13;
      v14[1] = a1 + 2;
      void v14[2] = 0;
      void v14[2] = a1[4];
      *(void *)(a1[4] + 8) = v14;
      a1[4] = (unint64_t)v14;
      unint64_t v15 = a1[1];
      unint64_t v16 = *a1 + 1;
      *a1 = v16;
      if (v16 > v15) {
        a1[1] = v16;
      }
    }
    else
    {
      return 0;
    }
  }
  return v13;
}

int *sub_244D662CC@<X0>(int *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return sub_244D662DC(a1, a2, 0xFFFFu, a3, a4);
}

int *sub_244D662DC@<X0>(int *result@<X0>, int a2@<W1>, unsigned __int16 a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  do
  {
    if (*(void *)&result[v6 + 46])
    {
      if (LOWORD(result[v6 + 44]) == (unsigned __int16)a2
        && __PAIR64__(LOWORD(result[v6 + 45]), HIWORD(result[v6 + 44])) == __PAIR64__(a3, HIWORD(a2)))
      {
        int v10 = 0;
        *(void *)&result[v6 + 46] = a4;
        int v11 = 157;
        goto LABEL_15;
      }
    }
    else if (!v7)
    {
      uint64_t v7 = (uint64_t)&result[v6 + 44];
    }
    v6 += 4;
  }
  while (v6 != 32);
  if (v7)
  {
    *(void *)(v7 + 8) = a4;
    *(_DWORD *)uint64_t v7 = a2;
    *(_WORD *)(v7 + 4) = a3;
    uint64_t v8 = sub_244CC9408();
    char v9 = *((unsigned char *)v8 + 5) + 1;
    *((unsigned char *)v8 + 5) = v9;
    double result = sub_244CC9414();
    if (*((char *)result + 5) >= v9)
    {
      int v10 = 0;
    }
    else
    {
      double result = sub_244CC9414();
      int v10 = 0;
      *((unsigned char *)result + 5) = v9;
    }
    int v11 = 170;
  }
  else
  {
    int v11 = 162;
    int v10 = 6;
  }
LABEL_15:
  *(_DWORD *)a5 = v10;
  *(void *)(a5 + 8) = "src/messaging/ExchangeMgr.cpp";
  *(_DWORD *)(a5 + 16) = v11;
  return result;
}

int *sub_244D663E0@<X0>(int *a1@<X0>, int a2@<W1>, unsigned __int16 a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return sub_244D662DC(a1, a2, a3, a4, a5);
}

int *sub_244D663E8@<X0>(int *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  return sub_244D663F4(a1, a2, 0xFFFFu, a3);
}

int *sub_244D663F4@<X0>(int *result@<X0>, int a2@<W1>, unsigned __int16 a3@<W2>, uint64_t a4@<X8>)
{
  for (uint64_t i = 0; i != 32; i += 4)
  {
    if (*(void *)&result[i + 46]
      && LOWORD(result[i + 44]) == (unsigned __int16)a2
      && __PAIR64__(LOWORD(result[i + 45]), HIWORD(result[i + 44])) == __PAIR64__(a3, HIWORD(a2)))
    {
      *(void *)&result[i + 46] = 0;
      double result = sub_244CC9408();
      int v6 = 0;
      --*((unsigned char *)result + 5);
      int v7 = 181;
      goto LABEL_8;
    }
  }
  int v7 = 185;
  int v6 = 7;
LABEL_8:
  *(_DWORD *)a4 = v6;
  *(void *)(a4 + 8) = "src/messaging/ExchangeMgr.cpp";
  *(_DWORD *)(a4 + 16) = v7;
  return result;
}

int *sub_244D664A4@<X0>(int *a1@<X0>, int a2@<W1>, unsigned __int16 a3@<W2>, uint64_t a4@<X8>)
{
  return sub_244D663F4(a1, a2, a3, a4);
}

void sub_244D664AC(unint64_t *a1, int *a2, unsigned __int8 *a3, uint64_t *a4, int a5, uint64_t a6)
{
  uint64_t v100 = *MEMORY[0x263EF8340];
  uint64_t v77 = sub_244DD7C4C(*((unsigned int *)a3 + 1));
  uint64_t v76 = sub_244DD7C84(*((unsigned int *)a3 + 1), *a3);
  if (*((unsigned char *)a2 + 24))
  {
    int v10 = sub_2446F7170((unsigned char *)a2 + 24);
LABEL_5:
    uint64_t v11 = *(void *)v10;
    goto LABEL_6;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a4 + 16))() == 2)
  {
    int v10 = (unsigned char *)(sub_244D879D8(*a4) + 64);
    goto LABEL_5;
  }
  uint64_t v11 = 0;
LABEL_6:
  __str[0] = 0;
  if (a3[12])
  {
    int v12 = sub_2446F12CC(a3 + 12);
    snprintf(__str, 0x14uLL, " (Ack:%u)", *(_DWORD *)v12);
  }
  if ((*(unsigned int (**)(void))(*(void *)*a4 + 16))() == 2
    && (uint64_t v13 = *(void *)(a1[11] + 32)) != 0
    && (uint64_t v14 = sub_244D879D8(*a4), (v15 = sub_244D9EA90(v13, *(unsigned __int8 *)(v14 + 24))) != 0))
  {
    uint64_t v16 = *(void *)(v15 + 16);
  }
  else
  {
    LOWORD(v16) = 0;
  }
  snprintf(v98, 8uLL, "%04X:%02X", *((unsigned __int16 *)a3 + 3), *a3);
  int v17 = *(unsigned __int8 *)(*a4 + 24);
  unint64_t v18 = (unint64_t)(*(uint64_t (**)(void))(*(void *)*a4 + 48))() >> 32;
  int v19 = (*(uint64_t (**)(void))(*(void *)*a4 + 48))();
  snprintf(v97, 0x37uLL, "from %u:%08X%08X [%04X] to %08X%08X", v17, v18, v19, (unsigned __int16)v16, HIDWORD(v11), v11);
  int v20 = sub_244CC8484(5u, "ExchangeManager");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (a3[8]) {
      int v21 = 114;
    }
    else {
      int v21 = 105;
    }
    int v73 = v21;
    int v74 = *((unsigned __int16 *)a3 + 1);
    int v22 = ((uint64_t (*)(uint64_t))loc_244D87D38)(*a4);
    int v23 = *a2;
    uint64_t v72 = sub_244D87DEC(a4);
    int v24 = *(_DWORD *)(*(void *)a6 + 16);
    int v25 = sub_244DB5E1C(a2);
    int v26 = *((unsigned __int16 *)a2 + 22) | *((unsigned __int8 *)a2 + 46);
    *(_DWORD *)uint64_t buf = 67111682;
    *(_DWORD *)&buf[4] = v74;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v73;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)uint64_t v87 = v22;
    *(_WORD *)&_OWORD v87[4] = 1024;
    *(_DWORD *)&v87[6] = v23;
    *(_WORD *)&v87[10] = 2080;
    *(void *)&v87[12] = __str;
    *(_WORD *)&v87[20] = 2080;
    *(void *)&v87[22] = v72;
    *(_WORD *)&v87[30] = 2080;
    unint64_t v88 = v97;
    __int16 v89 = 2080;
    uint64_t v90 = v98;
    __int16 v91 = 2080;
    uint64_t v92 = v77;
    __int16 v93 = 2080;
    int v94 = v76;
    __int16 v95 = 1024;
    int v96 = v24 + v25 + sub_244DB5E54((uint64_t)a3) + 16 * (v26 != 0);
    _os_log_impl(&dword_2446BD000, v20, OS_LOG_TYPE_DEFAULT, ">>> [E:%u%c S:%u M:%u%s] (%s) Msg RX %s --- Type %s (%s:%s) (B:%u)", buf, 0x5Cu);
  }
  if (sub_244CC4E58(2u))
  {
    uint64_t v75 = *((unsigned __int16 *)a3 + 1);
    unsigned __int8 v27 = a3[8];
    unsigned int v28 = ((uint64_t (*)(uint64_t))loc_244D87D38)(*a4);
    sub_244D87DEC(a4);
    sub_244DB5E1C(a2);
    sub_244DB5E54((uint64_t)a3);
    uint64_t v71 = v28;
    if (v27) {
      uint64_t v29 = 114;
    }
    else {
      uint64_t v29 = 105;
    }
    uint64_t v69 = v75;
    uint64_t v70 = v29;
    sub_244CC4DE0(5u, 2);
  }
  BOOL v85 = a5 == 0;
  if (*((unsigned char *)a2 + 46) == 1)
  {
    uint64_t v30 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      int v31 = *(unsigned __int16 *)sub_2446D1880((unsigned char *)a2 + 40);
      int v32 = *(unsigned __int16 *)sub_2446D1880((unsigned char *)a2 + 40);
      *(_DWORD *)uint64_t buf = 67109376;
      *(_DWORD *)&buf[4] = v31;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v32;
      _os_log_impl(&dword_2446BD000, v30, OS_LOG_TYPE_DEFAULT, "Received Groupcast Message with GroupId 0x%04X (%d)", buf, 0xEu);
    }
    if (sub_244CC4E58(2u))
    {
      uint64_t v69 = *(unsigned __int16 *)sub_2446D1880((unsigned char *)a2 + 40);
      uint64_t v70 = *(unsigned __int16 *)sub_2446D1880((unsigned char *)a2 + 40);
      sub_244CC4DE0(5u, 2);
    }
  }
  else
  {
    LOBYTE(v82) = 0;
    *(void *)uint64_t buf = a4;
    *(void *)&uint8_t buf[8] = a2;
    *(void *)uint64_t v87 = a3;
    *(void *)&v87[8] = &v85;
    *(void *)&v87[16] = a6;
    *(void *)&v87[24] = &v82;
    sub_244CC6478(a1 + 6, (uint64_t)buf, (unsigned int (*)(uint64_t))sub_244D678D4);
    if ((_BYTE)v82) {
      return;
    }
  }
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)*a4 + 40))(*a4, v33, v34, v35, v36, v37, v38, v39, v69, v70, v71) & 1) == 0)
  {
    uint64_t v48 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl(&dword_2446BD000, v48, OS_LOG_TYPE_DEFAULT, "Dropping message on inactive session that does not match an existing exchange", buf, 2u);
    }
    if (sub_244CC4E58(2u))
    {
      uint64_t v49 = 2;
LABEL_49:
      sub_244CC4DE0(5u, v49);
      return;
    }
    return;
  }
  char v40 = v85;
  if (v85 || (a3[8] & 1) == 0)
  {
    if ((a3[8] & 4) != 0)
    {
LABEL_95:
      sub_244D670F0((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, v40, a6);
      return;
    }
    if (!*((_WORD *)a3 + 2) && !*((_WORD *)a3 + 3) && *a3 == 16) {
      return;
    }
    uint64_t v50 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 112;
      *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
      *(_DWORD *)uint64_t v87 = 336;
      int v51 = sub_244CB7B34((const char **)buf, 1);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&buf[4] = v51;
      _os_log_impl(&dword_2446BD000, v50, OS_LOG_TYPE_ERROR, "OnMessageReceived failed, err = %s", buf, 0xCu);
    }
    if (!sub_244CC4E58(1u)) {
      return;
    }
    *(_DWORD *)uint64_t buf = 112;
    *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
    int v52 = 336;
LABEL_86:
    *(_DWORD *)uint64_t v87 = v52;
    goto LABEL_87;
  }
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  do
  {
    uint64_t v43 = &a1[v41];
    if (a1[v41 + 23])
    {
      unsigned int v45 = *((_DWORD *)v43 + 44);
      uint64_t v44 = (uint64_t)(v43 + 22);
      unsigned int v46 = HIWORD(v45);
      if (*((unsigned __int16 *)a3 + 2) == (unsigned __int16)v45 && *((unsigned __int16 *)a3 + 3) == v46)
      {
        if (WORD2(a1[v41 + 22]) == *a3)
        {
          uint64_t v42 = (uint64_t)&a1[v41 + 22];
          goto LABEL_60;
        }
        if (WORD2(a1[v41 + 22]) == 0xFFFF) {
          uint64_t v42 = v44;
        }
      }
    }
    v41 += 2;
  }
  while (v41 != 16);
  if (!v42) {
    goto LABEL_95;
  }
LABEL_60:
  uint64_t v84 = 0;
  uint64_t v83 = 0;
  long long v82 = 0uLL;
  (*(void (**)(long long *__return_ptr))(**(void **)(v42 + 8) + 16))(&v82);
  if (v82)
  {
    uint64_t v53 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_OWORD *)uint64_t buf = v82;
      *(void *)uint64_t v87 = v83;
      uint64_t v54 = sub_244CB7B34((const char **)buf, 1);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&buf[4] = v54;
      _os_log_impl(&dword_2446BD000, v53, OS_LOG_TYPE_ERROR, "OnMessageReceived failed, err = %s", buf, 0xCu);
    }
    if (sub_244CC4E58(1u))
    {
      *(_OWORD *)uint64_t buf = v82;
      *(void *)uint64_t v87 = v83;
      sub_244CB7B34((const char **)buf, 1);
      sub_244CC4DE0(5u, 1);
    }
LABEL_94:
    char v40 = v85;
    goto LABEL_95;
  }
  *(void *)uint64_t buf = a1;
  unsigned __int16 v81 = *((_WORD *)a3 + 1);
  unsigned __int8 v80 = 0;
  uint64_t v55 = sub_244D66200(a1 + 4, buf, &v81, (uint64_t)a4, &v80, &v84);
  if (!v55)
  {
    if (v84) {
      (*(void (**)(void))(**(void **)(v42 + 8) + 32))(*(void *)(v42 + 8));
    }
    uint64_t v65 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 11;
      *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
      *(_DWORD *)uint64_t v87 = 366;
      uint64_t v66 = sub_244CB7B34((const char **)buf, 1);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&buf[4] = v66;
      _os_log_impl(&dword_2446BD000, v65, OS_LOG_TYPE_ERROR, "OnMessageReceived failed, err = %s", buf, 0xCu);
    }
    if (!sub_244CC4E58(1u)) {
      return;
    }
    *(_DWORD *)uint64_t buf = 11;
    *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
    int v52 = 366;
    goto LABEL_86;
  }
  uint64_t v56 = (uint64_t)v55;
  uint64_t v57 = sub_244CC8484(5u, "ExchangeManager");
  if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
  {
    int v58 = *(unsigned __int16 *)(v56 + 112);
    int v59 = sub_244D64530(v56);
    uint64_t v60 = *(void *)(v56 + 40);
    *(_DWORD *)uint64_t buf = 67109632;
    if (v59) {
      int v61 = 105;
    }
    else {
      int v61 = 114;
    }
    *(_DWORD *)&buf[4] = v58;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v61;
    *(_WORD *)&buf[14] = 2048;
    *(void *)uint64_t v87 = v60;
    _os_log_impl(&dword_2446BD000, v57, OS_LOG_TYPE_INFO, "Handling via exchange: %u%c, Delegate: %p", buf, 0x18u);
  }
  if (sub_244CC4E58(3u))
  {
    sub_244D64530(v56);
    sub_244CC4DE0(5u, 3);
  }
  int v62 = (*(uint64_t (**)(void))(**(void **)(v56 + 56) + 16))(*(void *)(v56 + 56));
  if (!*((_WORD *)a2 + 22))
  {
    if (v62 == (*((unsigned char *)a2 + 46) != 0)) {
      goto LABEL_75;
    }
LABEL_89:
    uint64_t v67 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 42;
      *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
      *(_DWORD *)uint64_t v87 = 377;
      uint64_t v68 = sub_244CB7B34((const char **)buf, 1);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&buf[4] = v68;
      _os_log_impl(&dword_2446BD000, v67, OS_LOG_TYPE_ERROR, "OnMessageReceived failed, err = %s", buf, 0xCu);
    }
    if (sub_244CC4E58(1u))
    {
      *(_DWORD *)uint64_t buf = 42;
      *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
      *(_DWORD *)uint64_t v87 = 377;
      sub_244CB7B34((const char **)buf, 1);
      sub_244CC4DE0(5u, 1);
    }
    sub_244D64B58(v56);
    goto LABEL_94;
  }
  if ((v62 & 1) == 0) {
    goto LABEL_89;
  }
LABEL_75:
  sub_244D65220(v56, *a2, a3, v85, a6, (uint64_t)buf);
  long long v82 = *(_OWORD *)buf;
  uint64_t v83 = *(void *)v87;
  if (*(_DWORD *)buf)
  {
    int v63 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      *(_OWORD *)uint64_t buf = v82;
      *(void *)uint64_t v87 = v83;
      __int16 v64 = sub_244CB7B34((const char **)buf, 1);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&buf[4] = v64;
      _os_log_impl(&dword_2446BD000, v63, OS_LOG_TYPE_ERROR, "OnMessageReceived failed, err = %s", buf, 0xCu);
    }
    if (sub_244CC4E58(1u))
    {
      *(_OWORD *)uint64_t buf = v82;
      *(void *)uint64_t v87 = v83;
LABEL_87:
      sub_244CB7B34((const char **)buf, 1);
      uint64_t v49 = 1;
      goto LABEL_49;
    }
  }
}

void sub_244D670F0(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if ((*(unsigned int (**)(void))(**(void **)a4 + 72))())
  {
    char v12 = *(unsigned char *)(a3 + 8);
    if ((v12 & 4) != 0)
    {
      *(void *)uint64_t buf = a1;
      unsigned __int16 v25 = *(_WORD *)(a3 + 2);
      BOOL v24 = (v12 & 1) == 0;
      *(void *)&long long v21 = 0;
      unsigned __int8 v23 = 1;
      uint64_t v13 = (unsigned __int16 *)sub_244D67410((unint64_t *)(a1 + 32), buf, &v25, a4, (unsigned __int8 *)&v24, (uint64_t)&v21, &v23);
      uint64_t v14 = sub_244CC8484(5u, "ExchangeManager");
      uint64_t v15 = v14;
      if (v13)
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          int v16 = v13[56];
          if (sub_244D64530((uint64_t)v13)) {
            int v17 = 105;
          }
          else {
            int v17 = 114;
          }
          *(_DWORD *)uint64_t buf = 67109376;
          *(_DWORD *)&buf[4] = v16;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v17;
          _os_log_impl(&dword_2446BD000, v15, OS_LOG_TYPE_INFO, "Generating StandaloneAck via exchange: %u%c", buf, 0xEu);
        }
        if (sub_244CC4E58(3u))
        {
          sub_244D64530((uint64_t)v13);
          sub_244CC4DE0(5u, 3);
        }
        long long v21 = 0uLL;
        uint64_t v22 = 0;
        sub_244D65220((uint64_t)v13, *a2, (unsigned __int8 *)a3, a5, a6, (uint64_t)&v21);
        if (v21)
        {
          unint64_t v18 = sub_244CC8484(5u, "ExchangeManager");
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_OWORD *)uint64_t buf = v21;
            uint64_t v27 = v22;
            int v19 = sub_244CB7B34((const char **)buf, 1);
            *(_DWORD *)uint64_t buf = 136315138;
            *(void *)&buf[4] = v19;
            _os_log_impl(&dword_2446BD000, v18, OS_LOG_TYPE_ERROR, "OnMessageReceived failed, err = %s", buf, 0xCu);
          }
          if (sub_244CC4E58(1u))
          {
            *(_OWORD *)uint64_t buf = v21;
            uint64_t v27 = v22;
LABEL_20:
            sub_244CB7B34((const char **)buf, 1);
            sub_244CC4DE0(5u, 1);
          }
        }
      }
      else
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t buf = 11;
          *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
          LODWORD(v27) = 414;
          int v20 = sub_244CB7B34((const char **)buf, 1);
          *(_DWORD *)uint64_t buf = 136315138;
          *(void *)&buf[4] = v20;
          _os_log_impl(&dword_2446BD000, v15, OS_LOG_TYPE_ERROR, "OnMessageReceived failed, err = %s", buf, 0xCu);
        }
        if (sub_244CC4E58(1u))
        {
          *(_DWORD *)uint64_t buf = 11;
          *(void *)&uint8_t buf[8] = "src/messaging/ExchangeMgr.cpp";
          LODWORD(v27) = 414;
          goto LABEL_20;
        }
      }
    }
  }
}

void *sub_244D67410(unint64_t *a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, unsigned __int8 *a7)
{
  uint64_t v13 = sub_244CC4D84(0x78uLL);
  uint64_t v14 = v13;
  if (v13)
  {
    sub_244D64DF0(v13, *a2, *a3, a4, *a5, 0, *a7);
    uint64_t v15 = sub_244CC4D84(0x18uLL);
    if (v15)
    {
      *uint64_t v15 = v14;
      v15[1] = a1 + 2;
      void v15[2] = 0;
      void v15[2] = a1[4];
      *(void *)(a1[4] + 8) = v15;
      a1[4] = (unint64_t)v15;
      unint64_t v16 = a1[1];
      unint64_t v17 = *a1 + 1;
      *a1 = v17;
      if (v17 > v16) {
        a1[1] = v17;
      }
    }
    else
    {
      return 0;
    }
  }
  return v14;
}

uint64_t sub_244D674DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = &v3;
  return sub_244CC6478((void *)(a1 + 48), (uint64_t)&v4, (unsigned int (*)(uint64_t))sub_244D67A44);
}

uint64_t sub_244D6751C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  return sub_244CC6478((void *)(a1 + 48), (uint64_t)v4, (unsigned int (*)(uint64_t))sub_244D67A7C);
}

uint64_t sub_244D67558(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  return sub_244CC6478((void *)(a1 + 40), (uint64_t)v4, (unsigned int (*)(uint64_t))sub_244D67A7C);
}

void *sub_244D67594(void *a1)
{
  *a1 = &unk_26F9564F8;
  a1[1] = &unk_26F956528;
  sub_244D685A8((uint64_t)(a1 + 12));
  sub_244D67794(a1 + 4);
  return a1;
}

void sub_244D67604(void *a1)
{
  *a1 = &unk_26F9564F8;
  a1[1] = &unk_26F956528;
  sub_244D685A8((uint64_t)(a1 + 12));
  sub_244D67794(a1 + 4);

  JUMPOUT(0x245695FA0);
}

uint64_t *sub_244D67694(void *a1)
{
  *(a1 - 1) = &unk_26F9564F8;
  *a1 = &unk_26F956528;
  sub_244D685A8((uint64_t)(a1 + 11));

  return sub_244D67794(a1 + 3);
}

void sub_244D67708(void *a1)
{
  *(a1 - 1) = &unk_26F9564F8;
  *a1 = &unk_26F956528;
  sub_244D685A8((uint64_t)(a1 + 11));
  sub_244D67794(a1 + 3);

  JUMPOUT(0x245695FA0);
}

uint64_t *sub_244D67794(uint64_t *result)
{
  if (!byte_268EC3510)
  {
    if (*result) {
      sub_244E26114(result);
    }
  }
  return result;
}

uint64_t sub_244D677C4(uint64_t *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = sub_244CC8484(0x1Bu, "Support");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    uint64_t v3 = *a1;
    *(_DWORD *)uint64_t buf = 134217984;
    uint64_t v6 = v3;
    _os_log_impl(&dword_2446BD000, v2, OS_LOG_TYPE_ERROR, "HeapObjectPool: %lu allocated", buf, 0xCu);
  }
  if (sub_244CC4E58(1u)) {
    sub_244CC4DE0(0x1Bu, 1);
  }
  return sub_244CC6478(a1 + 2, (uint64_t)buf, (unsigned int (*)(uint64_t))sub_244D678B4);
}

uint64_t sub_244D678B4(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t sub_244D678D4(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t result = sub_244D64EC4(a2, *(void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 16));
  if (result)
  {
    uint64_t v5 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      int v6 = *(unsigned __int16 *)(a2 + 112);
      int v7 = sub_244D64530(a2);
      uint64_t v8 = *(void *)(a2 + 40);
      *(_DWORD *)uint64_t buf = 67109632;
      if (v7) {
        int v9 = 105;
      }
      else {
        int v9 = 114;
      }
      int v11 = v6;
      __int16 v12 = 1024;
      int v13 = v9;
      __int16 v14 = 2048;
      uint64_t v15 = v8;
      _os_log_impl(&dword_2446BD000, v5, OS_LOG_TYPE_INFO, "Found matching exchange: %u%c, Delegate: %p", buf, 0x18u);
    }
    if (sub_244CC4E58(3u))
    {
      sub_244D64530(a2);
      sub_244CC4DE0(5u, 3);
    }
    sub_244D65220(a2, **(_DWORD **)(a1 + 8), *(unsigned __int8 **)(a1 + 16), **(_DWORD **)(a1 + 24), *(void *)(a1 + 32), (uint64_t)buf);
    uint64_t result = 1;
    **(unsigned char **)(a1 + 40) = 1;
  }
  return result;
}

uint64_t sub_244D67A44(void **a1, uint64_t a2)
{
  if (*(void *)(a2 + 40) == **a1)
  {
    *(void *)(a2 + 40) = 0;
    sub_244D64B58(a2);
  }
  return 0;
}

uint64_t sub_244D67A7C(uint64_t **a1, unsigned char *a2)
{
  if (a2[88])
  {
    sub_24479B4A8((uint64_t)a2, &v9);
    uint64_t v4 = v9;
    uint64_t v5 = **a1;
    (*(void (**)(void))(*(void *)v9 + 32))(v9);
    if (v4 == v5)
    {
      int v6 = a1[1];
      uint64_t v7 = v6[2];
      long long v9 = *(_OWORD *)v6;
      uint64_t v10 = v7;
      (*(void (**)(unsigned char *, long long *))(*(void *)a2 + 40))(a2, &v9);
    }
  }
  return 0;
}

uint64_t sub_244D67B44(uint64_t result)
{
  *(_WORD *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_244D67B54(uint64_t a1)
{
  return a1 - 8;
}

uint64_t sub_244D67B5C(uint64_t a1)
{
  return *(void *)(a1 + 40) + 96;
}

_WORD *sub_244D67B68(_WORD *result, int a2)
{
  if (a2) {
    __int16 v2 = 8;
  }
  else {
    __int16 v2 = 0;
  }
  *uint64_t result = *result & 0xFFF7 | v2;
  return result;
}

void sub_244D67B88(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  *(_OWORD *)a2 = xmmword_2651A8FF0;
  *(void *)(a2 + 16) = 63;
  if ((*(unsigned char *)a1 & 0x10) != 0)
  {
    sub_244D67CE8(a1, a2);
    if (!*(_DWORD *)a2)
    {
      uint64_t v4 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = *(_DWORD *)(a1 + 16);
        int v6 = *(unsigned __int16 *)(a1 + 104);
        *(_DWORD *)uint64_t buf = 67109632;
        int v9 = v5;
        if (sub_244D64530(a1 - 8)) {
          int v7 = 105;
        }
        else {
          int v7 = 114;
        }
        __int16 v10 = 1024;
        int v11 = v6;
        __int16 v12 = 1024;
        int v13 = v7;
        _os_log_impl(&dword_2446BD000, v4, OS_LOG_TYPE_INFO, "Flushed pending ack for MessageCounter:%u on exchange %u%c", buf, 0x14u);
      }
      if (sub_244CC4E58(3u))
      {
        sub_244D64530(a1 - 8);
        sub_244CC4DE0(5u, 3);
      }
    }
  }
}

void sub_244D67CE8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  sub_244CC8F5C(0x10uLL, 0x26u, &v19);
  if (v19)
  {
    long long v17 = 0uLL;
    uint64_t v18 = 0;
    *(_WORD *)uint64_t buf = 2;
    sub_244D645BC(a1 - 8, 0, 16, (uint64_t *)&v19, buf, (uint64_t)&v17);
    long long v15 = v17;
    uint64_t v16 = v18;
    if (sub_244D64430((unsigned int *)&v15))
    {
      uint64_t v4 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_OWORD *)uint64_t buf = v17;
        *(void *)&uint8_t buf[16] = v18;
        int v5 = sub_244CB7B34((const char **)buf, 1);
        int v6 = *(_DWORD *)(a1 + 16);
        int v7 = *(unsigned __int16 *)(a1 + 104);
        int v8 = sub_244D64530(a1 - 8);
        *(_DWORD *)uint64_t buf = 136315906;
        *(void *)&uint8_t buf[4] = v5;
        if (v8) {
          int v9 = 105;
        }
        else {
          int v9 = 114;
        }
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v7;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v9;
        _os_log_impl(&dword_2446BD000, v4, OS_LOG_TYPE_ERROR, "Non-crit err %s sending solitary ack for MessageCounter:%u on exchange %u%c", buf, 0x1Eu);
      }
      if (sub_244CC4E58(1u))
      {
        *(_OWORD *)uint64_t buf = v17;
        *(void *)&uint8_t buf[16] = v18;
        sub_244CB7B34((const char **)buf, 1);
        sub_244D64530(a1 - 8);
        sub_244CC4DE0(5u, 1);
      }
      *(_DWORD *)a2 = 0;
      *(void *)(a2 + 8) = "src/messaging/ReliableMessageContext.cpp";
      *(_DWORD *)(a2 + 16) = 193;
    }
    else
    {
      if (v17)
      {
        __int16 v10 = sub_244CC8484(5u, "ExchangeManager");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          int v11 = *(_DWORD *)(a1 + 16);
          int v12 = *(unsigned __int16 *)(a1 + 104);
          if (sub_244D64530(a1 - 8)) {
            int v13 = 105;
          }
          else {
            int v13 = 114;
          }
          *(_OWORD *)uint64_t buf = v17;
          *(void *)&uint8_t buf[16] = v18;
          uint64_t v14 = sub_244CB7B34((const char **)buf, 1);
          *(_DWORD *)uint64_t buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v11;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v12;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v13;
          *(_WORD *)&buf[20] = 2080;
          *(void *)&buf[22] = v14;
          _os_log_impl(&dword_2446BD000, v10, OS_LOG_TYPE_ERROR, "Failed to send Solitary ack for MessageCounter:%u on exchange %u%c:%s", buf, 0x1Eu);
        }
        if (sub_244CC4E58(1u))
        {
          sub_244D64530(a1 - 8);
          *(_OWORD *)uint64_t buf = v17;
          *(void *)&uint8_t buf[16] = v18;
          sub_244CB7B34((const char **)buf, 1);
          sub_244CC4DE0(5u, 1);
        }
      }
      *(_OWORD *)a2 = v17;
      *(void *)(a2 + 16) = v18;
    }
    if (v19) {
      sub_244CC8A0C(v19);
    }
  }
  else
  {
    *(_DWORD *)a2 = 11;
    *(void *)(a2 + 8) = "src/messaging/ReliableMessageContext.cpp";
    *(_DWORD *)(a2 + 16) = 182;
  }
}

uint64_t sub_244D6804C(uint64_t a1, int a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t result = sub_244D69040(*(void *)(a1 + 40) + 96, a1, a2);
  if (result)
  {
    *(_WORD *)a1 &= ~0x800u;
  }
  else
  {
    int v5 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      int v6 = *(unsigned __int16 *)(a1 + 104);
      *(_DWORD *)uint64_t buf = 67109632;
      int v9 = a2;
      if (sub_244D64530(a1 - 8)) {
        int v7 = 105;
      }
      else {
        int v7 = 114;
      }
      __int16 v10 = 1024;
      int v11 = v6;
      __int16 v12 = 1024;
      int v13 = v7;
      _os_log_impl(&dword_2446BD000, v5, OS_LOG_TYPE_INFO, "CHIP MessageCounter:%u not in RetransTable on exchange %u%c", buf, 0x14u);
    }
    uint64_t result = sub_244CC4E58(3u);
    if (result)
    {
      sub_244D64530(a1 - 8);
      return sub_244CC4DE0(5u, 3);
    }
  }
  return result;
}

void *sub_244D6819C@<X0>(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  sub_244D681E4(a1, a2, a3, a4);
  int v5 = (uint64_t *)(*(void *)(a1 + 40) + 96);

  return sub_244D68788(v5);
}

void sub_244D681E4(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, void *a4@<X8>)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (a3)
  {
    __int16 v12 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      int v13 = *(unsigned __int16 *)(a1 + 104);
      *(_DWORD *)uint64_t buf = 67109632;
      int v18 = a2;
      if (sub_244D64530(a1 - 8)) {
        int v14 = 105;
      }
      else {
        int v14 = 114;
      }
      __int16 v19 = 1024;
      int v20 = v13;
      __int16 v21 = 1024;
      int v22 = v14;
      _os_log_impl(&dword_2446BD000, v12, OS_LOG_TYPE_INFO, "Forcing tx of solitary ack for duplicate MessageCounter:%u on exchange %u%c", buf, 0x14u);
    }
    if (sub_244CC4E58(3u))
    {
      sub_244D64530(a1 - 8);
      sub_244CC4DE0(5u, 3);
    }
    __int16 v15 = *(_WORD *)a1;
    int v16 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = a2;
    *(_WORD *)a1 = v15 | 0x30;
    a4[1] = 0;
    a4[2] = 0;
    *a4 = 0;
    sub_244D67CE8(a1, (uint64_t)a4);
    if ((v15 & 0x10) == 0 || v16 == a2)
    {
      if ((v15 & 0x20) != 0) {
        *(_DWORD *)(a1 + 16) = v16;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 16) = v16;
      *(_WORD *)a1 |= 0x30u;
    }
  }
  else
  {
    __int16 v7 = *(_WORD *)a1;
    if ((*(_WORD *)a1 & 0x10) == 0)
    {
LABEL_12:
      *(_DWORD *)(a1 + 16) = a2;
      *(_WORD *)a1 = v7 | 0x30;
      *(void *)(a1 + 8) = (*((uint64_t (**)(_UNKNOWN **))*off_268EBD1B0 + 2))(off_268EBD1B0) + 200;
      *(_DWORD *)a4 = 0;
      a4[1] = "src/messaging/ReliableMessageContext.cpp";
      *((_DWORD *)a4 + 4) = 173;
      return;
    }
    int v8 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      int v9 = *(_DWORD *)(a1 + 16);
      int v10 = *(unsigned __int16 *)(a1 + 104);
      *(_DWORD *)uint64_t buf = 67109632;
      int v18 = v9;
      if (sub_244D64530(a1 - 8)) {
        int v11 = 105;
      }
      else {
        int v11 = 114;
      }
      __int16 v19 = 1024;
      int v20 = v10;
      __int16 v21 = 1024;
      int v22 = v11;
      _os_log_impl(&dword_2446BD000, v8, OS_LOG_TYPE_INFO, "Pending ack queue full; forcing tx of solitary ack for MessageCounter:%u on exchange %u%c",
        buf,
        0x14u);
    }
    if (sub_244CC4E58(3u))
    {
      sub_244D64530(a1 - 8);
      sub_244CC4DE0(5u, 3);
    }
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    sub_244D67CE8(a1, (uint64_t)a4);
    if (!*(_DWORD *)a4)
    {
      __int16 v7 = *(_WORD *)a1;
      goto LABEL_12;
    }
  }
}

uint64_t sub_244D684C4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  *(_WORD *)result |= 0x30u;
  return result;
}

uint64_t sub_244D684D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_244D67B54(a2);
  *(void *)a1 = v3;
  sub_244CDBFD0((int *)(v3 + 28));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  sub_244D67B68((_WORD *)(*(void *)a1 + 8), 1);
  return a1;
}

void *sub_244D6852C(void *a1)
{
  sub_244D67B68((_WORD *)(*a1 + 8), 0);
  __int16 v2 = (_WORD *)a1[1];
  if (v2) {
    sub_244CC8A0C(v2);
  }
  a1[1] = 0;
  sub_244CDBF88((int *)(*a1 + 28));
  return a1;
}

double sub_244D68580(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 49) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = a1 + 32;
  *(void *)(a1 + 48) = a1 + 32;
  *(void *)(a1 + 72) = 0;
  return result;
}

uint64_t sub_244D685A8(uint64_t a1)
{
  return a1;
}

uint64_t sub_244D685D4(uint64_t a1)
{
  (*(void (**)(void, uint64_t (*)(uint64_t, uint64_t *), uint64_t))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8), sub_244D68740, a1);
  uint64_t v3 = a1;
  uint64_t result = sub_244CC6478((void *)(a1 + 32), (uint64_t)&v3, (unsigned int (*)(uint64_t))sub_244D697A0);
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t sub_244D6865C(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t (*)(uint64_t, uint64_t *), uint64_t))(**(void **)(a1 + 8)
                                                                                                + 72))(*(void *)(a1 + 8), sub_244D68740, a1);
}

uint64_t sub_244D68698(uint64_t *a1)
{
  uint64_t v4 = (*((uint64_t (**)(_UNKNOWN **))*off_268EBD1B0 + 2))(off_268EBD1B0);
  int v5 = &v4;
  uint64_t v2 = *a1;
  v6[0] = &v5;
  sub_244CC6478((void *)(v2 + 16), (uint64_t)v6, (unsigned int (*)(uint64_t))sub_244D697C4);
  v6[0] = &v4;
  v6[1] = a1;
  return sub_244CC6478(a1 + 4, (uint64_t)v6, (unsigned int (*)(uint64_t))sub_244D69814);
}

uint64_t sub_244D68740(uint64_t a1, uint64_t *a2)
{
  if (!a1 || !a2) {
    sub_244E26268();
  }
  sub_244D68698(a2);

  return sub_244D68788(a2);
}

void *sub_244D68788(uint64_t *a1)
{
  uint64_t v5 = -1;
  int v6 = &v5;
  uint64_t v2 = *a1;
  v4[0] = &v6;
  sub_244CC6478((void *)(v2 + 16), (uint64_t)v4, (unsigned int (*)(uint64_t))sub_244D69F44);
  v4[0] = &v5;
  sub_244CC6478(a1 + 4, (uint64_t)v4, (unsigned int (*)(uint64_t))sub_244D69F70);
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t *), uint64_t *))(*(void *)a1[1] + 72))(a1[1], sub_244D68740, a1);
  if (v5 != -1)
  {
    (*((void (**)(_UNKNOWN **))*off_268EBD1B0 + 2))(off_268EBD1B0);
    uint64_t result = (*(void *(**)(void *__return_ptr))(*(void *)a1[1] + 40))(v4);
    if (LODWORD(v4[0])) {
      sub_244E26308();
    }
  }
  return result;
}

uint64_t sub_244D688DC@<X0>(uint64_t result@<X0>, _WORD *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v10 = a2;
  if ((*a2 & 8) != 0)
  {
    int v7 = 213;
    int v6 = 3;
  }
  else
  {
    uint64_t result = (uint64_t)sub_244D689C4((unint64_t *)(result + 16), (uint64_t *)&v10);
    *a3 = result;
    if (result)
    {
      int v6 = 0;
      int v7 = 222;
    }
    else
    {
      int v8 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v9 = 0;
        _os_log_impl(&dword_2446BD000, v8, OS_LOG_TYPE_ERROR, "mRetransTable Already Full", v9, 2u);
      }
      uint64_t result = sub_244CC4E58(1u);
      if (result) {
        uint64_t result = sub_244CC4DE0(5u, 1);
      }
      int v7 = 219;
      int v6 = 100;
    }
  }
  *(_DWORD *)a4 = v6;
  *(void *)(a4 + 8) = "src/messaging/ReliableMessageMgr.cpp";
  *(_DWORD *)(a4 + 16) = v7;
  return result;
}

void *sub_244D689C4(unint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = sub_244CC4D84(0x20uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    sub_244D684D8((uint64_t)v4, *a2);
    int v6 = sub_244CC4D84(0x18uLL);
    if (v6)
    {
      *int v6 = v5;
      v6[1] = a1 + 2;
      void v6[2] = 0;
      void v6[2] = a1[4];
      *(void *)(a1[4] + 8) = v6;
      a1[4] = (unint64_t)v6;
      unint64_t v7 = a1[1];
      unint64_t v8 = *a1 + 1;
      *a1 = v8;
      if (v8 > v7) {
        a1[1] = v8;
      }
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t sub_244D68A5C(unsigned int a1, int a2, char a3)
{
  if (a2 <= 1) {
    int v4 = 1;
  }
  else {
    int v4 = a2;
  }
  if (v4 >= 5) {
    int v4 = 5;
  }
  if (v4 >= 2)
  {
    int v5 = v4 - 1;
    LODWORD(v6) = 1;
    LODWORD(v7) = 1;
    do
    {
      uint64_t v6 = (16 * v6);
      unint64_t v7 = (10 * v7);
      --v5;
    }
    while (v5);
    if (a3) {
      goto LABEL_10;
    }
LABEL_12:
    uint64_t v8 = sub_244CE997C() | 0x400;
    return dword_268EC3520 + ((((1127 * (unint64_t)a1) >> 10) * v6 / v7 * v8) >> 10);
  }
  unint64_t v7 = 1;
  uint64_t v6 = 1;
  if ((a3 & 1) == 0) {
    goto LABEL_12;
  }
LABEL_10:
  uint64_t v8 = 1279;
  return dword_268EC3520 + ((((1127 * (unint64_t)a1) >> 10) * v6 / v7 * v8) >> 10);
}

void *sub_244D68B10(uint64_t *a1, uint64_t a2)
{
  sub_244D68B48((uint64_t)a1, a2);

  return sub_244D68788(a1);
}

uint64_t sub_244D68B48(uint64_t a1, uint64_t a2)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  sub_24479B4A8(*(void *)a2, &v35);
  uint64_t v3 = *(void *)v35;
  if ((*(_WORD *)(*(void *)a2 + 8) & 0x400) != 0) {
    unsigned int v4 = *(_DWORD *)((*(uint64_t (**)(void))(v3 + 88))() + 4);
  }
  else {
    unsigned int v4 = (*(uint64_t (**)(void))(v3 + 96))();
  }
  unsigned int v5 = sub_244D68A5C(v4, *(unsigned __int8 *)(a2 + 24), 0);
  *(void *)(a2 + 16) = (*((uint64_t (**)(_UNKNOWN **))*off_268EBD1B0 + 2))(off_268EBD1B0) + v5;
  uint64_t v6 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v35 + 88))(v35);
  int v7 = *(_DWORD *)v6;
  int v8 = *(_DWORD *)(v6 + 4);
  int v34 = *(unsigned __int16 *)(v6 + 8);
  int v9 = sub_244D884D4(a2 + 8);
  int v10 = v35[24];
  if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v35 + 16))(v35) == 2)
  {
    int v11 = (void *)sub_244D879D8((uint64_t)v35);
    unint64_t v12 = (*((uint64_t (**)(_UNKNOWN **))*off_268EBD1B0 + 2))(off_268EBD1B0) - v11[17];
    BOOL v33 = v12 < *(unsigned __int16 *)((*(uint64_t (**)(void *))(*v11 + 88))(v11) + 8);
    unint64_t v13 = *(void *)(sub_244D879D8((uint64_t)v35) + 72);
  }
  else if ((*(unsigned int (**)(unsigned __int8 *))(*(void *)v35 + 16))(v35) == 1)
  {
    int v14 = (void *)sub_244D87A80((uint64_t)v35);
    unint64_t v15 = (*((uint64_t (**)(_UNKNOWN **))*off_268EBD1B0 + 2))(off_268EBD1B0) - v14[13];
    BOOL v16 = v15 >= *(unsigned __int16 *)((*(uint64_t (**)(void *))(*v14 + 88))(v14) + 8);
    unint64_t v13 = 0;
    int v17 = !v16;
    BOOL v33 = v17;
  }
  else
  {
    unint64_t v13 = 0;
    BOOL v33 = 0;
  }
  int v18 = sub_244CC8484(5u, "ExchangeManager");
  unint64_t v32 = HIDWORD(v13);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = *(unsigned __int8 *)(a2 + 24) + 1;
    int v30 = v8;
    int v31 = v10;
    int v20 = *(unsigned __int16 *)(*(void *)a2 + 112);
    int v21 = v13;
    int v22 = v7;
    unsigned int v23 = v5;
    int v24 = v9;
    if (sub_244D64530(*(void *)a2)) {
      int v25 = 105;
    }
    else {
      int v25 = 114;
    }
    int v26 = ((uint64_t (*)(unsigned __int8 *))loc_244D87D38)(v35);
    uint64_t v27 = sub_244D87DEC(&v35);
    *(_DWORD *)uint64_t buf = 67112450;
    uint64_t v28 = "Idle";
    if (v33) {
      uint64_t v28 = "Active";
    }
    int v37 = v19;
    __int16 v38 = 1024;
    int v39 = v20;
    __int16 v40 = 1024;
    int v41 = v25;
    __int16 v42 = 1024;
    int v43 = v26;
    __int16 v44 = 1024;
    int v45 = v24;
    __int16 v46 = 2080;
    unsigned int v47 = v27;
    __int16 v48 = 1024;
    int v49 = v31;
    __int16 v50 = 1024;
    int v51 = v32;
    __int16 v52 = 1024;
    int v53 = v21;
    __int16 v54 = 1024;
    unsigned int v55 = v23;
    __int16 v56 = 2080;
    uint64_t v57 = v28;
    __int16 v58 = 1024;
    int v59 = v22;
    __int16 v60 = 1024;
    int v61 = v30;
    __int16 v62 = 1024;
    int v63 = v34;
    _os_log_impl(&dword_2446BD000, v18, OS_LOG_TYPE_DEFAULT, "??%d [E:%u%c S:%u M:%u] (%s) Msg Retransmission to %u:%08X%08X in %ums [State:%s II:%u AI:%u AT:%u]", buf, 0x5Eu);
  }
  if (sub_244CC4E58(2u))
  {
    sub_244D64530(*(void *)a2);
    ((void (*)(unsigned __int8 *))loc_244D87D38)(v35);
    sub_244D87DEC(&v35);
    sub_244CC4DE0(5u, 2);
  }
  return (*(uint64_t (**)(unsigned __int8 *))(*(void *)v35 + 32))(v35);
}

uint64_t sub_244D69040(uint64_t a1, uint64_t a2, int a3)
{
  int v5 = a3;
  unsigned __int8 v4 = 0;
  uint64_t v6 = a2;
  v7[0] = &v6;
  v7[1] = &v5;
  unint64_t v7[2] = a1;
  _OWORD v7[3] = &v4;
  sub_244CC6478((void *)(a1 + 32), (uint64_t)v7, (unsigned int (*)(uint64_t))sub_244D69D3C);
  return v4;
}

void sub_244D690A0(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v6 = *a2;
  if (*(unsigned char *)(*a2 + 88))
  {
    uint64_t v7 = *(void *)(*(void *)(v6 + 48) + 88);
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    sub_24479B4A8(v6, buf);
    sub_244D89520(v7, (uint64_t *)buf, a2 + 1, (uint64_t)a3);
    (*(void (**)(void))(**(void **)buf + 32))(*(void *)buf);
    long long v23 = *(_OWORD *)a3;
    uint64_t v24 = a3[2];
    LODWORD(v7) = *(unsigned __int16 *)(*a2 + 112);
    int v8 = sub_244D64530(*a2);
    sub_244D694C4((uint64_t)&v23, v7, v8, (uint64_t)buf);
    *(_OWORD *)a3 = *(_OWORD *)buf;
    a3[2] = *(void *)&buf[16];
    if (*(_DWORD *)a3)
    {
      int v9 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_OWORD *)uint64_t buf = *(_OWORD *)a3;
        *(void *)&uint8_t buf[16] = a3[2];
        int v10 = sub_244CB7B34((const char **)buf, 1);
        int v11 = sub_244D884D4((uint64_t)(a2 + 1));
        int v12 = *(unsigned __int16 *)(*a2 + 112);
        int v13 = sub_244D64530(*a2);
        int v14 = *((unsigned __int8 *)a2 + 24);
        *(_DWORD *)uint64_t buf = 136316162;
        if (v13) {
          int v15 = 105;
        }
        else {
          int v15 = 114;
        }
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v12;
        __int16 v26 = 1024;
        int v27 = v15;
        __int16 v28 = 1024;
        int v29 = v14;
        _os_log_impl(&dword_2446BD000, v9, OS_LOG_TYPE_ERROR, "Crit-err %s when sending CHIP MessageCounter:%u on exchange %u%c, send tries: %d", buf, 0x24u);
      }
      if (sub_244CC4E58(1u))
      {
        *(_OWORD *)uint64_t buf = *(_OWORD *)a3;
        *(void *)&uint8_t buf[16] = a3[2];
        sub_244CB7B34((const char **)buf, 1);
        sub_244D884D4((uint64_t)(a2 + 1));
        sub_244D64530(*a2);
        sub_244CC4DE0(5u, 1);
      }
      sub_244D696B0(a1 + 16, a2);
      sub_244D68788(a1);
    }
  }
  else
  {
    BOOL v16 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 3;
      *(void *)&uint8_t buf[8] = "src/messaging/ReliableMessageMgr.cpp";
      *(_DWORD *)&uint8_t buf[16] = 323;
      int v17 = sub_244CB7B34((const char **)buf, 1);
      int v18 = sub_244D884D4((uint64_t)(a2 + 1));
      int v19 = *(unsigned __int16 *)(*a2 + 112);
      int v20 = sub_244D64530(*a2);
      int v21 = *((unsigned __int8 *)a2 + 24);
      *(_DWORD *)uint64_t buf = 136316162;
      if (v20) {
        int v22 = 105;
      }
      else {
        int v22 = 114;
      }
      *(void *)&uint8_t buf[4] = v17;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v18;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v19;
      __int16 v26 = 1024;
      int v27 = v22;
      __int16 v28 = 1024;
      int v29 = v21;
      _os_log_impl(&dword_2446BD000, v16, OS_LOG_TYPE_ERROR, "Crit-err %s when sending CHIP MessageCounter:%u on exchange %u%c, send tries: %d", buf, 0x24u);
    }
    if (sub_244CC4E58(1u))
    {
      *(_DWORD *)uint64_t buf = 3;
      *(void *)&uint8_t buf[8] = "src/messaging/ReliableMessageMgr.cpp";
      *(_DWORD *)&uint8_t buf[16] = 323;
      sub_244CB7B34((const char **)buf, 1);
      sub_244D884D4((uint64_t)(a2 + 1));
      sub_244D64530(*a2);
      sub_244CC4DE0(5u, 1);
    }
    sub_244D696B0(a1 + 16, a2);
    sub_244D68788(a1);
    *(_DWORD *)a3 = 3;
    a3[1] = "src/messaging/ReliableMessageMgr.cpp";
    *((_DWORD *)a3 + 4) = 325;
  }
}

void *sub_244D69488(uint64_t *a1, void *a2)
{
  sub_244D696B0((uint64_t)(a1 + 2), a2);

  return sub_244D68788(a1);
}

__n128 sub_244D694C4@<Q0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  sub_244CC8788(55, "src/messaging/ReliableMessageMgr.cpp", 449, (uint64_t)buf);
  if (*(_DWORD *)a1 == *(_DWORD *)buf)
  {
    int v8 = sub_244CC8484(5u, "ExchangeManager");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_OWORD *)uint64_t buf = *(_OWORD *)a1;
      *(void *)&uint8_t buf[16] = *(void *)(a1 + 16);
      int v9 = sub_244CB7B34((const char **)buf, 1);
      *(_DWORD *)uint64_t buf = 136315650;
      *(void *)&uint8_t buf[4] = v9;
      if (a3) {
        int v10 = 105;
      }
      else {
        int v10 = 114;
      }
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v10;
      _os_log_impl(&dword_2446BD000, v8, OS_LOG_TYPE_ERROR, "Ignoring transient send error: %s on exchange %u%c", buf, 0x18u);
    }
    if (sub_244CC4E58(1u))
    {
      *(_OWORD *)uint64_t buf = *(_OWORD *)a1;
      *(void *)&uint8_t buf[16] = *(void *)(a1 + 16);
      sub_244CB7B34((const char **)buf, 1);
      sub_244CC4DE0(5u, 1);
    }
    *(_DWORD *)a1 = 0;
    *(void *)(a1 + 8) = "src/messaging/ReliableMessageMgr.cpp";
    *(_DWORD *)(a1 + 16) = 465;
  }
  __n128 result = *(__n128 *)a1;
  *(_OWORD *)a4 = *(_OWORD *)a1;
  *(void *)(a4 + 16) = *(void *)(a1 + 16);
  return result;
}

uint64_t sub_244D6966C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  v4[0] = &v3;
  v4[1] = a1;
  return sub_244CC6478((void *)(a1 + 32), (uint64_t)v4, (unsigned int (*)(uint64_t))sub_244D69EF0);
}

void sub_244D696B0(uint64_t a1, void *a2)
{
  if (a2)
  {
    unsigned __int8 v4 = sub_244CC6450((void *)(a1 + 16), (uint64_t)a2);
    if (!v4) {
      sub_244E26074();
    }
    int v5 = v4;
    *unsigned __int8 v4 = 0;
    uint64_t v6 = sub_244D6852C(a2);
    j__free(v6);
    if (*(void *)(a1 + 40))
    {
      *(unsigned char *)(a1 + 48) = 1;
    }
    else
    {
      *(void *)(v5[1] + 16) = v5[2];
      *(void *)(v5[2] + 8) = v5[1];
      j__free(v5);
    }
    --*(void *)a1;
  }
}

uint64_t sub_244D6973C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 72) = a2;
  return result;
}

unsigned __int8 *sub_244D69744(unsigned __int8 *result)
{
  int v1 = *result;
  if (*result)
  {
    __n128 result = sub_244CDC004(result);
    int v1 = *(_DWORD *)result;
  }
  dword_268EC3520 = v1;
  return result;
}

uint64_t *sub_244D69770(uint64_t *result)
{
  if (!byte_268EC3510)
  {
    if (*result) {
      sub_244E263A8(result);
    }
  }
  return result;
}

uint64_t sub_244D697A0(void *a1, void *a2)
{
  return 0;
}

uint64_t sub_244D697C4(void ***a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 8) & 0x10) != 0 && ***a1 >= *(void *)(a2 + 16)) {
    sub_244D67CE8(v3, a2 + 8);
  }
  return 0;
}

uint64_t sub_244D69814(uint64_t a1, uint64_t a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (**(void **)a1 >= *(void *)(a2 + 16))
  {
    uint64_t v3 = a2 + 8;
    if (!*(void *)(a2 + 8)) {
      sub_244E2644C();
    }
    uint64_t v4 = *(void *)(a1 + 8);
    sub_24479B4A8(*(void *)a2, &v37);
    int v5 = *(unsigned __int8 *)(a2 + 24);
    int v6 = sub_244D884D4(v3);
    int v7 = *(unsigned __int8 *)(v37 + 24);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v37 + 16))(v37) == 2) {
      uint64_t v8 = *(void *)(sub_244D879D8(v37) + 72);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v5 == 4)
    {
      uint64_t v9 = *(void *)a2;
      int v10 = (int *)(*(void *)a2 + 28);
      sub_244CDBFD0(v10);
      int v11 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v36 = *(unsigned __int16 *)(*(void *)a2 + 112);
        uint64_t v12 = v9;
        int v13 = v7;
        int v14 = v6;
        int v15 = v10;
        uint64_t v16 = v4;
        if (sub_244D64530(*(void *)a2)) {
          int v17 = 105;
        }
        else {
          int v17 = 114;
        }
        int v18 = ((uint64_t (*)(uint64_t))loc_244D87D38)(v37);
        int v19 = sub_244D87DEC(&v37);
        uint64_t buf = 0x504000A02;
        LOWORD(v39) = 1024;
        *(_DWORD *)((char *)&v39 + 2) = v36;
        HIWORD(v39) = 1024;
        int v40 = v17;
        uint64_t v4 = v16;
        int v10 = v15;
        int v20 = v14;
        int v21 = v13;
        uint64_t v9 = v12;
        __int16 v41 = 1024;
        int v42 = v18;
        __int16 v43 = 1024;
        int v44 = v20;
        __int16 v45 = 2080;
        __int16 v46 = v19;
        __int16 v47 = 1024;
        int v48 = v21;
        __int16 v49 = 1024;
        int v50 = HIDWORD(v8);
        __int16 v51 = 1024;
        int v52 = v8;
        __int16 v53 = 1024;
        int v54 = 4;
        _os_log_impl(&dword_2446BD000, v11, OS_LOG_TYPE_ERROR, "<<%d [E:%u%c S:%u M:%u] (%s) Msg Retransmission to %u:%08X%08X failure (max retries:%d)", (uint8_t *)&buf, 0x42u);
      }
      if (sub_244CC4E58(1u))
      {
        sub_244D64530(*(void *)a2);
        ((void (*)(uint64_t))loc_244D87D38)(v37);
        sub_244D87DEC(&v37);
        sub_244CC4DE0(5u, 1);
      }
      if ((sub_244D6453C(v9) & 1) == 0)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v37 + 16))(v37) == 2
          && *(unsigned char *)(sub_244D879D8(v37) + 57) == 2)
        {
          uint64_t v22 = sub_244D879D8(v37);
          sub_244D85724(v22);
        }
        uint64_t v23 = v37 + 8;
        uint64_t v24 = *(void *)(v37 + 16);
        if (v24 != v37 + 8)
        {
          do
          {
            uint64_t v25 = *(void *)(v24 + 8);
            if (v24) {
              uint64_t v26 = v24 - 8;
            }
            else {
              uint64_t v26 = 0;
            }
            (*(void (**)(uint64_t))(*(void *)v26 + 32))(v26);
            uint64_t v24 = v25;
          }
          while (v25 != v23);
        }
      }
      sub_244D696B0(v4 + 16, (void *)a2);
      sub_244CDBF88(v10);
    }
    else
    {
      ++*(unsigned char *)(a2 + 24);
      int v27 = sub_244CC8484(5u, "ExchangeManager");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        int v28 = *(unsigned __int8 *)(a2 + 24);
        int v29 = *(unsigned __int16 *)(*(void *)a2 + 112);
        if (sub_244D64530(*(void *)a2)) {
          int v30 = 105;
        }
        else {
          int v30 = 114;
        }
        int v31 = ((uint64_t (*)(uint64_t))loc_244D87D38)(v37);
        unint64_t v32 = sub_244D87DEC(&v37);
        LODWORD(buf) = 67111170;
        HIDWORD(buf) = v28;
        LOWORD(v39) = 1024;
        *(_DWORD *)((char *)&v39 + 2) = v29;
        HIWORD(v39) = 1024;
        int v40 = v30;
        __int16 v41 = 1024;
        int v42 = v31;
        __int16 v43 = 1024;
        int v44 = v6;
        __int16 v45 = 2080;
        __int16 v46 = v32;
        __int16 v47 = 1024;
        int v48 = v7;
        __int16 v49 = 1024;
        int v50 = HIDWORD(v8);
        __int16 v51 = 1024;
        int v52 = v8;
        _os_log_impl(&dword_2446BD000, v27, OS_LOG_TYPE_DEFAULT, "<<%d [E:%u%c S:%u M:%u] (%s) Msg Retransmission to %u:%08X%08X", (uint8_t *)&buf, 0x3Cu);
      }
      if (sub_244CC4E58(2u))
      {
        sub_244D64530(*(void *)a2);
        ((void (*)(uint64_t))loc_244D87D38)(v37);
        sub_244D87DEC(&v37);
        sub_244CC4DE0(5u, 2);
      }
      int v33 = *(unsigned __int8 *)(a2 + 24);
      LODWORD(buf) = 2;
      int v39 = "core_dev_rmp_retry_count";
      int v40 = v33;
      LOBYTE(v41) = 2;
      uint64_t v34 = sub_244D7E78C((uint64_t)&buf);
      sub_244D68B48(v34, a2);
      sub_244D690A0(v4, (uint64_t *)a2, &buf);
    }
    (*(void (**)(uint64_t))(*(void *)v37 + 32))(v37);
  }
  return 0;
}

uint64_t sub_244D69D3C(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (*a2 + 8 != **(void **)a1) {
    return 0;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 16);
  if (sub_244D884D4((uint64_t)(a2 + 1)) != **(_DWORD **)(a1 + 8)) {
    return 0;
  }
  sub_244D696B0((uint64_t)(v4 + 2), a2);
  sub_244D68788(v4);
  int v5 = sub_244CC8484(5u, "ExchangeManager");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    int v6 = **(_DWORD **)(a1 + 8);
    int v7 = *(unsigned __int16 *)(sub_244D67B54(**(void **)a1) + 112);
    uint64_t v8 = sub_244D67B54(**(void **)a1);
    *(_DWORD *)uint64_t buf = 67109632;
    int v13 = v6;
    if (sub_244D64530(v8)) {
      int v9 = 105;
    }
    else {
      int v9 = 114;
    }
    __int16 v14 = 1024;
    int v15 = v7;
    __int16 v16 = 1024;
    int v17 = v9;
    _os_log_impl(&dword_2446BD000, v5, OS_LOG_TYPE_INFO, "Rxd Ack; Removing MessageCounter:%u from Retrans Table on exchange %u%c",
      buf,
      0x14u);
  }
  if (sub_244CC4E58(3u))
  {
    sub_244D67B54(**(void **)a1);
    uint64_t v10 = sub_244D67B54(**(void **)a1);
    sub_244D64530(v10);
    sub_244CC4DE0(5u, 3);
  }
  uint64_t result = 1;
  **(unsigned char **)(a1 + 24) = 1;
  return result;
}

uint64_t sub_244D69EF0(void **a1, void *a2)
{
  if (*a2 + 8 != **a1) {
    return 0;
  }
  uint64_t v3 = a1[1];
  sub_244D696B0((uint64_t)(v3 + 2), a2);
  sub_244D68788(v3);
  return 1;
}

uint64_t sub_244D69F44(unint64_t ***a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 8) & 0x10) != 0)
  {
    uint64_t v2 = **a1;
    unint64_t v3 = *(void *)(a2 + 16);
    if (v3 < *v2) {
      unint64_t *v2 = v3;
    }
  }
  return 0;
}