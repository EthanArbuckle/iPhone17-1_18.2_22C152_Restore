uint64_t __IOHIDCFArrayFunctionApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

__n64 IOHIDEventGetFloatValue(void *a1, unsigned int a2)
{
  return IOHIDEventGetFloatValueWithOptions(a1, a2, 4026531840);
}

id IOHIDSessionFilterFilterEventToConnection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t SenderID = a3;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  v8 = *(void **)(a1 + 56);
  id v9 = (id)a4;
  if (v8)
  {
    v10 = *(const char **)(a1 + 120);
    id v9 = (id)a4;
    if (v10) {
      id v9 = objc_msgSend(v8, v10, a4, a2, a3);
    }
  }
  if (!v9)
  {
    if (*(unsigned char *)(a1 + 48))
    {
      v12 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        int Type = IOHIDEventGetType(a4);
        if (SenderID) {
          uint64_t SenderID = _IOHIDServiceGetSenderID(SenderID);
        }
        uint64_t UUID = IOHIDEventSystemConnectionGetUUID(a2);
        uint64_t v15 = *(void *)(a1 + 32);
        v16[0] = 67109890;
        v16[1] = Type;
        __int16 v17 = 2048;
        uint64_t v18 = SenderID;
        __int16 v19 = 2112;
        uint64_t v20 = UUID;
        __int16 v21 = 2112;
        uint64_t v22 = v15;
        _os_log_impl(&dword_18B46C000, v12, OS_LOG_TYPE_INFO, "Event filtered type:%d service:0x%llx connection:%@ session filter:%@", (uint8_t *)v16, 0x26u);
      }
    }
  }
  return v9;
}

IOReturn IODataQueueDequeue(IODataQueueMemory *dataQueue, void *data, uint32_t *dataSize)
{
  return __IODataQueueDequeue(dataQueue, 0, data, dataSize);
}

kern_return_t iokit_user_client_trap(void *a1, uint32_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(IOKIT_USER_CLIENT_TRAP, a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t _IOHIDObjectExtRetainCount(uint64_t a1, char *a2)
{
  return _IOHIDObjectRetainCount(a1, a2, 0);
}

uint64_t IOHIDEventGetAttributeDataLength(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t IOHIDEventGetChildren(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

kern_return_t IOConnectTrap3(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, (void *)p3, 0, 0, 0);
}

__n64 IOHIDEventGetDoubleValue(void *a1, unsigned int a2)
{
  return IOHIDEventGetDoubleValueWithOptions(a1, a2, 4026531840);
}

const void *_IOHIDObjectInternalRetainCallback(uint64_t a1, const void *a2)
{
  return _IOHIDObjectInternalRetain(a2);
}

uint64_t _IOHIDObjectInternalReleaseCallback(uint64_t a1, const void *a2)
{
  return _IOHIDObjectInternalRelease(a2);
}

id __FilterFunctionSetPropertyForClient(void *a1, uint64_t *a2)
{
  return IOHIDServiceFilterSetPropertyForClient(a1, *a2, a2[1], a2[2]);
}

id __FilterFunctionSetPropertyForClient_0(void *a1, uint64_t a2)
{
  return IOHIDSessionFilterSetPropertyForClient(a1, *(void *)(a2 + 8), *(void *)(a2 + 16));
}

kern_return_t IOConnectTrap1(io_connect_t connect, uint32_t index, uintptr_t p1)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, 0, 0, 0, 0, 0);
}

uint64_t IOHIDEventGetAttributeDataPtr(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t __IOHIDEventSystemFilterEventServiceUnregister(uint64_t a1, const void *a2)
{
  return _IOHIDServiceRemoveConnection(a1, a2, 1);
}

uint64_t __RemoveServiceConnectionPropertyFunction(uint64_t a1, uint64_t a2, const void *a3)
{
  return _IOHIDServiceRemovePropertiesForClient(a2, a3);
}

void *__FilterFunctionFilterEvent(void *result, void **a2)
{
  v3 = *a2;
  if (v3)
  {
    result = IOHIDServiceFilterFilterEvent((uint64_t)result, v3);
    *a2 = result;
  }
  return result;
}

void *__FilterFunctionFilterEvent_0(void *result, uint64_t a2)
{
  v2 = *(void **)(a2 + 16);
  if (v2)
  {
    result = IOHIDSessionFilterFilterEvent((uint64_t)result, *(void *)(a2 + 8), v2);
    *(void *)(a2 + 16) = result;
  }
  return result;
}

void *IOHIDSessionFilterFilterEvent(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6 && (v7 = *(uint64_t (**)(void))(*(void *)v6 + 32)) != 0
    || (uint64_t v8 = *(void *)(a1 + 24)) != 0 && (v7 = *(uint64_t (**)(void))(*(void *)v8 + 32)) != 0)
  {
    uint64_t v9 = v7();
    goto LABEL_6;
  }
  uint64_t v9 = (uint64_t)a3;
  if (!*(void *)(a1 + 56)
    || (v10 = objc_msgSend(*(id *)(a1 + 56), *(SEL *)(a1 + 80), a3, a2), uint64_t v9 = (uint64_t)a3, v10 == a3))
  {
LABEL_6:
    v10 = (void *)v9;
    if (v9) {
      return v10;
    }
    goto LABEL_7;
  }
  CFRelease(a3);
  if (v10)
  {
    CFRetain(v10);
    return v10;
  }
LABEL_7:
  if (*(unsigned char *)(a1 + 48))
  {
    v11 = _IOHIDEventDebugInfo(a3);
    v12 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      int Type = IOHIDEventGetType((uint64_t)a3);
      if (a2) {
        uint64_t SenderID = _IOHIDServiceGetSenderID(a2);
      }
      else {
        uint64_t SenderID = 0;
      }
      uint64_t v15 = *(void *)(a1 + 32);
      v17[0] = 67109890;
      v17[1] = Type;
      __int16 v18 = 2048;
      uint64_t v19 = SenderID;
      __int16 v20 = 2112;
      __int16 v21 = v11;
      __int16 v22 = 2112;
      uint64_t v23 = v15;
      _os_log_impl(&dword_18B46C000, v12, OS_LOG_TYPE_INFO, "Event filtered type:%d service:0x%llx eventInfo:(%@) session filter:%@", (uint8_t *)v17, 0x26u);
    }
    CFRelease(v11);
  }
  return 0;
}

id IOHIDServiceFilterFilterEvent(uint64_t a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 && (v5 = *(uint64_t (**)(void))(*(void *)v4 + 40)) != 0
    || (uint64_t v6 = *(void *)(a1 + 24)) != 0 && (v5 = *(uint64_t (**)(void))(*(void *)v6 + 40)) != 0)
  {
    id result = (id)v5();
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t v8 = *(void **)(a1 + 96);
    if (v8)
    {
      id result = objc_msgSend(v8, *(SEL *)(a1 + 120), a2);
      if (result) {
        return result;
      }
    }
  }
  uint64_t v9 = _IOHIDEventDebugInfo(a2);
  v10 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    int Type = IOHIDEventGetType((uint64_t)a2);
    uint64_t SenderID = _IOHIDServiceGetSenderID(*(void *)(a1 + 48));
    uint64_t v13 = *(void *)(a1 + 88);
    v14[0] = 67109890;
    v14[1] = Type;
    __int16 v15 = 2048;
    uint64_t v16 = SenderID;
    __int16 v17 = 2112;
    __int16 v18 = v9;
    __int16 v19 = 2112;
    uint64_t v20 = v13;
    _os_log_impl(&dword_18B46C000, v10, OS_LOG_TYPE_INFO, "Event filtered type:%d sender:0x%llx eventInfo:(%@) service filter:%@", (uint8_t *)v14, 0x26u);
  }
  CFRelease(v9);
  return 0;
}

uint64_t __IONotificationPortSetDispatchQueue_block_invoke(uint64_t a1)
{
  return MEMORY[0x1F40CBB78](*(void *)(a1 + 32), 8124, _IODispatchCalloutWithDispatch);
}

kern_return_t IOConnectTrap2(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, 0, 0, 0, 0);
}

id IOHIDServiceGetProperty(uint64_t a1, const void *a2)
{
  v2 = (void *)__IOHIDServiceCopyPropertyForClient(a1, a2, (const void *)*MEMORY[0x1E4F1D260], 0);

  return v2;
}

uint64_t IOCFSerializeBinaryCFArraySetFunction(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1] + 1;
  a2[1] = v4;
  *(unsigned char *)(v3 + 16) = v4 == a2[2];
  uint64_t result = DoCFSerializeBinary();
  *((unsigned char *)a2 + 24) &= result;
  return result;
}

void *__hid_dispatch_queue_did_execute(NSObject *a1)
{
  uint64_t result = dispatch_queue_get_specific(a1, &sHIDExecutionCallbacksKey);
  if (result)
  {
    uint64_t v3 = (uint64_t (*)(uint64_t, NSObject *))result[1];
    if (v3)
    {
      uint64_t v4 = result[2];
      return (void *)v3(v4, a1);
    }
  }
  return result;
}

uint64_t (**__hid_dispatch_queue_will_execute(NSObject *a1))(uint64_t, NSObject *)
{
  uint64_t result = (uint64_t (**)(uint64_t, NSObject *))dispatch_queue_get_specific(a1, &sHIDExecutionCallbacksKey);
  if (result)
  {
    uint64_t v3 = *result;
    if (*result)
    {
      uint64_t v4 = result[2];
      return (uint64_t (**)(uint64_t, NSObject *))v3((uint64_t)v4, a1);
    }
  }
  return result;
}

uint64_t __SetPropertyForObjectFunction(const void *a1, uint64_t a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  uint64_t result = IOHIDServiceGetTypeID();
  if (v4 == result)
  {
    uint64_t result = _IOHIDServiceSetPropertyForClient((uint64_t)a1, *(const void **)a2, *(const void **)(a2 + 8), *(CFTypeRef *)(a2 + 24));
    if (result) {
      *(unsigned char *)(a2 + 16) = 1;
    }
  }
  return result;
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  int v9 = 0;
  uint64_t v8 = 0;
  uint64_t v6 = (int *)&IOConnectCallMethod_zero;
  if (outputCnt) {
    uint64_t v6 = (int *)outputCnt;
  }
  return io_connect_method(connection, selector, (int)input, inputCnt, 0, 0, 0, 0, 0, &v9, output, v6, 0, &v8);
}

void __IOHIDEventSystemClientSetDispatchQueue_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 296));
    *(void *)(*(void *)(a1 + 32) + 296) = 0;
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(v6 + 304);
    if (v7)
    {
      (*(void (**)(void))(v7 + 16))();
      _Block_release(*(const void **)(*(void *)(a1 + 32) + 304));
      uint64_t v6 = *(void *)(a1 + 32);
      *(void *)(v6 + 304) = 0;
    }
    dispatch_release(*(dispatch_object_t *)(v6 + 400));
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 488));
    uint64_t v8 = *(const void **)(a1 + 32);
    _IOHIDObjectInternalRelease(v8);
  }
  else if (a2 == 2)
  {
    uint64_t msg = dispatch_mach_msg_get_msg();
    __IOHIDEventSystemClientQueueCallback(msg, v4, v5, *(void *)(a1 + 32));
  }
}

void __IOHIDEventSystemClientQueueCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v5 = *(const void **)(a4 + 272);
    if (v5)
    {
      CFRetain(*(CFTypeRef *)(a4 + 272));
      os_unfair_recursive_lock_unlock();
      os_unfair_recursive_lock_lock_with_options();
      if (*(void *)(a4 + 200) || *(void *)(a4 + 208))
      {
        uint64_t v6 = IOHIDEventQueueDequeueCopy((uint64_t)v5);
        if (v6)
        {
          uint64_t v7 = v6;
          int v8 = 0;
          uint64_t v9 = 0;
          unint64_t v10 = 0;
          do
          {
            uint64_t SenderID = IOHIDEventGetSenderID((uint64_t)v7);
            Service = __IOHIDEventSystemClientGetService(a4, SenderID);
            TimeStampOfuint64_t Type = IOHIDEventGetTimeStampOfType((uint64_t)v7, 2);
            uint64_t Type = IOHIDEventGetType((uint64_t)v7);
            TimeStampuint64_t Type = IOHIDEventGetTimeStampType((uint64_t)v7);
            _IOHIDDebugTrace(8224, 0, TimeStampOfType, Type, (uint64_t)Service, TimeStampType);
            unint64_t Latency = IOHIDEventGetLatency((uint64_t)v7, 1u);
            if (Latency > v10) {
              unint64_t v10 = Latency;
            }
            char v17 = IOHIDEventGetType((uint64_t)v7);
            uint64_t v18 = *(void *)(a4 + 208);
            if (v18) {
              (*(void (**)(uint64_t, void, void, const void *, unsigned int *))(v18 + 16))(v18, *(void *)(a4 + 216), *(void *)(a4 + 224), Service, v7);
            }
            else {
              (*(void (**)(void, void, const void *, unsigned int *))(a4 + 200))(*(void *)(a4 + 216), *(void *)(a4 + 224), Service, v7);
            }
            v9 |= 1 << v17;
            CFRelease(v7);
            uint64_t v7 = IOHIDEventQueueDequeueCopy((uint64_t)v5);
            ++v8;
          }
          while (v7);
        }
        else
        {
          unint64_t v10 = 0;
          uint64_t v9 = 0;
          int v8 = 0;
        }
        os_unfair_recursive_lock_unlock();
        CFRelease(v5);
        os_unfair_recursive_lock_lock_with_options();
        if (v10 > *(void *)(a4 + 480)) {
          *(void *)(a4 + 480) = v10;
        }
        gettimeofday((timeval *)(a4 + 464), 0);
        *(_DWORD *)(a4 + 148) += v8;
        *(void *)(a4 + 152) |= v9;
      }
    }
    os_unfair_recursive_lock_unlock();
  }
}

uint64_t IOHIDEventGetSenderID(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

unsigned int *IOHIDEventQueueDequeueCopy(uint64_t a1)
{
  uint64_t v16 = 0;
  os_unfair_recursive_lock_lock_with_options();
  if (!*(_DWORD *)(a1 + 144))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    int v3 = *(_DWORD *)(v2 + 4);
    int v4 = *(_DWORD *)(v2 + 8);
    if (v2)
    {
      if (v4 != *(_DWORD *)(a1 + 36)) {
        __IOHIDEventQueueUpdateUsageAnalytics(a1);
      }
      *(_DWORD *)(a1 + 32) = v3;
      *(_DWORD *)(a1 + 36) = v4;
    }
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = _IODataQueuePeek(*(unsigned int **)(a1 + 16), *(unsigned int *)(a1 + 56), &v16);
    if (v6)
    {
      CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v6 = (unsigned int *)IOHIDEventCreateWithBytesInternal(v7, v6 + 1, v16);
      if (!v6)
      {
        int v8 = _IOHIDLog();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          IOHIDEventQueueDequeueCopy_cold_1((uint64_t)&v16, v8, v9, v10, v11, v12, v13, v14);
        }
      }
      _IODataQueueDequeue(v5, *(_DWORD *)(a1 + 56), 0);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  os_unfair_recursive_lock_unlock();
  return v6;
}

uint64_t __IODataQueueDequeue(_DWORD *a1, uint64_t a2, void *__dst, _DWORD *a4)
{
  uint64_t result = 3758097090;
  if (a1 && (!__dst || a4))
  {
    uint64_t v7 = a1[1];
    unsigned int explicit = atomic_load_explicit(a1 + 2, memory_order_acquire);
    if (v7 == explicit) {
      return 3758097127;
    }
    if (!a2) {
      LODWORD(a2) = *a1;
    }
    if (v7 > a2) {
      return 3758097084;
    }
    uint64_t v9 = a1 + 3;
    if (v7 >= 0xFFFFFFFC)
    {
      unint64_t v10 = a2;
      goto LABEL_19;
    }
    unint64_t v10 = a2;
    if (v7 + 4 > (unint64_t)a2
      || ((uint64_t v11 = (unsigned int *)((char *)v9 + v7),
           uint64_t v12 = *(unsigned int *)((char *)v9 + v7),
           unint64_t v13 = (v12 + v7) + 4,
           v7 + 4 <= (unint64_t)~v12)
        ? (BOOL v14 = v13 > a2)
        : (BOOL v14 = 1),
          v14))
    {
LABEL_19:
      uint64_t v12 = *v9;
      if (v12 <= 0xFFFFFFFB)
      {
        LODWORD(v13) = v12 + 4;
        uint64_t result = 3758097084;
        if (v12 + 4 > v10) {
          return result;
        }
        if (!__dst) {
          goto LABEL_25;
        }
        goto LABEL_22;
      }
      return 3758097084;
    }
    if (v12 > 0xFFFFFFFB) {
      return 3758097084;
    }
    unint64_t v15 = ~v7;
    unint64_t v16 = v12 + 4 + v7;
    BOOL v17 = v12 + 4 > v15 || v16 > a2;
    uint64_t result = 3758097084;
    if (!v17)
    {
      uint64_t v9 = v11;
      if (!__dst)
      {
LABEL_25:
        atomic_store(v13, a1 + 1);
        uint64_t result = 0;
        if (explicit == v13) {
          __dmb(0xBu);
        }
        return result;
      }
LABEL_22:
      if (v12 > *a4) {
        return 3758097115;
      }
      memcpy(__dst, v9 + 1, v12);
      *a4 = v12;
      goto LABEL_25;
    }
  }
  return result;
}

IODataQueueEntry *__cdecl IODataQueuePeek(IODataQueueMemory *dataQueue)
{
  return (IODataQueueEntry *)__IODataQueuePeek(&dataQueue->queueSize, 0, &v2);
}

unsigned int *__IODataQueuePeek(unsigned int *result, uint64_t a2, void *a3)
{
  if (result)
  {
    uint64_t v3 = result[1];
    if (v3 == atomic_load_explicit((atomic_uint *volatile)result + 2, memory_order_acquire)) {
      return 0;
    }
    if (!a2) {
      LODWORD(a2) = *result;
    }
    if (v3 > a2) {
      return 0;
    }
    int v4 = result + 3;
    if (v3 < 0xFFFFFFFC)
    {
      uint64_t result = (unsigned int *)((char *)v4 + v3);
      uint64_t v6 = *(unsigned int *)((char *)v4 + v3);
      unint64_t v5 = a2;
      BOOL v7 = v3 + 4 > (unint64_t)a2 || v3 + 4 > (unint64_t)~v6;
      unint64_t v8 = (v6 + v3) + 4;
      if (!v7 && v8 <= a2)
      {
        if (!a3) {
          return result;
        }
        int v4 = result;
        goto LABEL_23;
      }
    }
    else
    {
      unint64_t v5 = a2;
    }
    uint64_t result = 0;
    uint64_t v6 = *v4;
    if (v6 > 0xFFFFFFFB) {
      return result;
    }
    if (v6 + 4 > v5) {
      return result;
    }
    uint64_t result = v4;
    if (!a3) {
      return result;
    }
LABEL_23:
    *a3 = v6;
    return v4;
  }
  return result;
}

const void *__IOHIDEventCreateWithBytesHelper(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a3 < 0x1C) {
    return 0;
  }
  unsigned int v4 = a3 - 28;
  if (!*(_DWORD *)(a2 + 24) || *(_DWORD *)(a2 + 20) >= v4) {
    return 0;
  }
  int v7 = 0;
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  v26 = (char *)(a2 + 28);
  int64_t v24 = *(unsigned int *)(a2 + 20);
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  while (1)
  {
    uint64_t v11 = v9;
    if (v4 - v10 < 0x10) {
      return v8;
    }
    uint64_t v12 = &v26[v10];
    size_t v13 = *(unsigned int *)v12;
    if (v13 <= 0xF)
    {
      uint64_t v20 = _IOHIDLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        __IOHIDEventCreateWithBytesHelper_cold_1(v7, v13, v20);
      }
      return v8;
    }
    if (v4 - v10 < v13)
    {
      uint64_t v21 = _IOHIDLog();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109632;
        int v28 = v7;
        __int16 v29 = 1024;
        unsigned int v30 = v4 - v10;
        __int16 v31 = 1024;
        int v32 = v13;
        _os_log_error_impl(&dword_18B46C000, v21, OS_LOG_TYPE_ERROR, "Failed to create event at index=%d , eventDataMaxSize: %u < eventDataSize: %u", buf, 0x14u);
      }
      return v8;
    }
    uint64_t v14 = *(void *)a2;
    uint64_t v15 = _IOHIDEventCreate(a1, *(unsigned int *)v12, *((unsigned int *)v12 + 1), *(void *)a2, *(unsigned int *)(a2 + 16));
    if (!v15) {
      break;
    }
    uint64_t v9 = v15;
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      uint64_t v14 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v14);
    }
    *(void *)(v9 + 8) = v14;
    memmove(*(void **)(v9 + 104), v12, v13);
    *(void *)(v9 + 16) = *(void *)(a2 + 8);
    if (v8)
    {
      if (v11)
      {
        unsigned int v16 = v12[12];
        if (v16 <= *(unsigned __int8 *)(*(void *)(v11 + 104) + 12))
        {
          while (1)
          {
            uint64_t v17 = *(void *)(v11 + 80);
            if (!v17) {
              break;
            }
            unsigned int v18 = *(unsigned __int8 *)(*(void *)(v11 + 104) + 12);
            uint64_t v11 = *(void *)(v11 + 80);
            if (v16 >= v18) {
              goto LABEL_23;
            }
          }
        }
        uint64_t v17 = v11;
LABEL_23:
        IOHIDEventAppendEvent(v17, (void *)v9);
        CFRelease((CFTypeRef)v9);
      }
    }
    else
    {
      IOHIDEventSetAttributeData(v9, v26, v24);
      unint64_t v8 = (const void *)v9;
    }
    v10 += v13;
    if (++v7 >= *(_DWORD *)(a2 + 24) || v10 >= v4) {
      return v8;
    }
  }
  __int16 v22 = _IOHIDLog();
  if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    if (!v8) {
      return v8;
    }
    goto LABEL_37;
  }
  unsigned int v23 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)buf = 67109888;
  int v28 = v7;
  __int16 v29 = 1024;
  unsigned int v30 = v23;
  __int16 v31 = 1024;
  int v32 = v10;
  __int16 v33 = 1024;
  unsigned int v34 = v4;
  _os_log_error_impl(&dword_18B46C000, v22, OS_LOG_TYPE_ERROR, "Failed to create event at index=%d eventCount=%d eventDataOffset=%d totalEventDataSize=%d", buf, 0x1Au);
  if (v8)
  {
LABEL_37:
    CFRelease(v8);
    return 0;
  }
  return v8;
}

uint64_t _IOHIDEventCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = +[HIDEvent allocWithZone:a1];

  return (uint64_t)[(HIDEvent *)v9 initWithSize:a2 type:a3 timestamp:a4 options:a5];
}

void IOHIDEventSetAttributeData(uint64_t a1, const void *a2, int64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 40);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 88) = 0;
  }
  if (a2 && a3)
  {
    if (a3 <= 0) {
      uint64_t v7 = -(-a3 & 3);
    }
    else {
      uint64_t v7 = a3 & 3;
    }
    size_t v8 = a3 - v7 + 4;
    uint64_t v9 = malloc_type_malloc(v8, 0x18D82F27uLL);
    *(void *)(a1 + 40) = v9;
    if (v9)
    {
      bzero(v9, v8);
      memmove(*(void **)(a1 + 40), a2, a3);
      *(void *)(a1 + 88) = v8;
    }
  }
}

void IOHIDEventAppendEvent(uint64_t a1, void *value)
{
  Mutable = *(__CFArray **)(a1 + 72);
  if (Mutable
    || (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]),
        (*(void *)(a1 + 72) = Mutable) != 0))
  {
    value[10] = a1;
    uint64_t v5 = value[13];
    int v6 = *(_DWORD *)(v5 + 4);
    uint64_t v7 = a1;
    do
    {
      *(void *)(v7 + 24) |= 1 << v6;
      uint64_t v7 = *(void *)(v7 + 80);
    }
    while (v7);
    if (v6 == 11)
    {
      uint64_t v8 = *(void *)(a1 + 104);
      if (*(_DWORD *)(v8 + 4) == 11) {
        *(_DWORD *)(v8 + 44) |= *(_DWORD *)(v5 + 40);
      }
    }
    CFArrayAppendValue(Mutable, value);
  }
}

const void *__IOHIDEventSystemClientGetService(uint64_t a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (!v3) {
    return 0;
  }
  CFNumberRef v4 = v3;
  os_unfair_recursive_lock_lock_with_options();
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), v4);
  os_unfair_recursive_lock_unlock();
  CFRelease(v4);
  return Value;
}

uint64_t _IOHIDServiceSetPropertyForClient(uint64_t a1, const void *a2, const void *a3, CFTypeRef cf)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == IOHIDEventSystemConnectionGetTypeID())
    {
      uint64_t UUID = IOHIDEventSystemConnectionGetUUID((uint64_t)cf);
      uint64_t v10 = mach_absolute_time();
      if (!IOHIDServiceCheckEntitlements(a1, (uint64_t)cf)) {
        return 0;
      }
      CFTypeRef v11 = cf;
    }
    else
    {
      uint64_t v10 = mach_absolute_time();
      CFTypeRef v11 = 0;
      uint64_t UUID = 0;
    }
    if (CFEqual(cf, (CFTypeRef)*MEMORY[0x1E4F1D260]))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
      CFDictionaryReplaceValue(*(CFMutableDictionaryRef *)(a1 + 312), a2, a3);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    }
  }
  else
  {
    uint64_t v10 = mach_absolute_time();
    CFTypeRef v11 = 0;
    uint64_t UUID = 0;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(context, buf);
  }
  ++**(_DWORD **)(a1 + 72);
  context[0] = a2;
  context[1] = a3;
  context[2] = v11;
  CFArrayRef v12 = *(const __CFArray **)(a1 + 256);
  v51.length = CFArrayGetCount(v12);
  v51.location = 0;
  CFArrayApplyFunction(v12, v51, (CFArrayApplierFunction)__FilterFunctionSetPropertyForClient, context);
  uint64_t v13 = *(void *)(a1 + 72);
  if (*(_DWORD *)v13)
  {
    --*(_DWORD *)v13;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v40, buf);
    }
  }
  uint64_t v14 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v30 = *(void *)(a1 + 400);
    *(_DWORD *)buf = 134218754;
    uint64_t v43 = v30;
    __int16 v44 = 2112;
    v45 = a2;
    __int16 v46 = 2112;
    uint64_t v47 = (uint64_t)a3;
    __int16 v48 = 2112;
    uint64_t v49 = UUID;
    _os_log_debug_impl(&dword_18B46C000, v14, OS_LOG_TYPE_DEBUG, "0x%llx: set property:%@ value:%@ client:%@", buf, 0x2Au);
  }
  if (CFEqual(a2, @"ReportInterval"))
  {
    _IOHIDServiceSetReportIntervalForClient(a1, cf, a3);
    uint64_t v15 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(a1 + 400);
      *(_DWORD *)buf = 134218498;
      uint64_t v43 = v16;
      __int16 v44 = 2112;
      v45 = a3;
      __int16 v46 = 2112;
      uint64_t v47 = UUID;
      _os_log_impl(&dword_18B46C000, v15, OS_LOG_TYPE_DEFAULT, "0x%llx: set report interval:%@ client:%@", buf, 0x20u);
    }
    if (a3)
    {
      uint64_t v17 = mach_absolute_time();
      int ReportIntervalForClient = _IOHIDServiceGetReportIntervalForClient(a1, cf, 0);
      _IOHIDServiceSetEventDeadlineForClient(a1, cf, v17, ReportIntervalForClient, 0);
    }
    goto LABEL_27;
  }
  if (CFEqual(a2, @"BatchInterval"))
  {
    _IOHIDServiceSetBatchIntervalForClient(a1, cf, a3);
    __int16 v19 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(a1 + 400);
      *(_DWORD *)buf = 134218498;
      uint64_t v43 = v20;
      __int16 v44 = 2112;
      v45 = a3;
      __int16 v46 = 2112;
      uint64_t v47 = UUID;
      _os_log_impl(&dword_18B46C000, v19, OS_LOG_TYPE_DEFAULT, "0x%llx: set batch interval:%@ client:%@", buf, 0x20u);
    }
    goto LABEL_27;
  }
  if (!CFEqual(a2, @"IOHIDEventSystemClientIsUnresponsive"))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v40, buf);
    }
    ++**(_DWORD **)(a1 + 72);
    uint64_t v31 = *(void *)(a1 + 32);
    if (v31)
    {
      int v32 = *(uint64_t (**)(void))(*(void *)v31 + 56);
      if (v32)
      {
        unsigned __int8 v33 = v32();
LABEL_47:
        unsigned __int8 updated = v33;
LABEL_49:
        uint64_t v39 = *(void *)(a1 + 72);
        if (*(_DWORD *)v39)
        {
          --*(_DWORD *)v39;
          if (pthread_mutex_unlock((pthread_mutex_t *)(v39 + 8))) {
            __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v40, buf);
          }
        }
        goto LABEL_28;
      }
    }
    uint64_t v34 = *(void *)(a1 + 24);
    if (v34 && (uint64_t v35 = *(void (**)(void))(*(void *)v34 + 56)) != 0)
    {
      v35();
    }
    else
    {
      uint64_t v36 = *(void *)(a1 + 360);
      if (v36)
      {
        v37 = *(uint64_t (**)(void, void, const void *, const void *))(v36 + 32);
        if (v37)
        {
          unsigned __int8 v33 = v37(*(void *)(a1 + 344), *(void *)(a1 + 352), a2, a3);
          goto LABEL_47;
        }
      }
      v38 = *(void **)(a1 + 480);
      if (v38)
      {
        unsigned __int8 v33 = objc_msgSend(v38, *(SEL *)(a1 + 504), a3, a2, cf);
        goto LABEL_47;
      }
    }
    unsigned __int8 updated = 1;
    goto LABEL_49;
  }
  uint64_t v21 = _IOHIDServiceCopyConnectionCache(a1, cf);
  if (!v21)
  {
    unsigned __int8 updated = 1;
    goto LABEL_28;
  }
  __int16 v22 = v21;
  unsigned int v23 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = *(void *)(a1 + 400);
    *(_DWORD *)buf = 134218498;
    uint64_t v43 = v24;
    __int16 v44 = 2112;
    v45 = a3;
    __int16 v46 = 2112;
    uint64_t v47 = UUID;
    _os_log_impl(&dword_18B46C000, v23, OS_LOG_TYPE_DEFAULT, "0x%llx: unresponsive:%@ client:%@", buf, 0x20u);
  }
  CFRelease(v22);
LABEL_27:
  unsigned __int8 updated = __IOHIDServiceUpdateIntervals(a1, (uint64_t)cf);
LABEL_28:
  uint64_t v26 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v26, v10, 0x3E8u);
  if (*(void *)(a1 + 464)) {
    IOHIDAnalyticsEventSetIntegerValueForField();
  }
  uint64_t v27 = mach_absolute_time();
  unint64_t v28 = _IOHIDGetTimestampDelta(v27, v10, 1u);
  if (v28 > *(void *)(a1 + 376)) {
    *(void *)(a1 + 376) = v28;
  }
  return updated;
}

uint64_t _IOHIDServiceCopyPropertyForClient(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = mach_absolute_time();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 312), a2);
  CFTypeID v8 = Value;
  if (Value)
  {
    CFRetain(Value);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    ++*(_DWORD *)(a1 + 320);
    if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1D260]))
    {
      CFRelease(v8);
      uint64_t v9 = 0;
      goto LABEL_21;
    }
    if (v8 != (const void *)defaultPropertyKeyValue)
    {
      uint64_t v9 = (uint64_t)v8;
      goto LABEL_21;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    ++*(_DWORD *)(a1 + 324);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v19, v20);
  }
  ++**(_DWORD **)(a1 + 72);
  context = a2;
  uint64_t v17 = 0;
  if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1D260])) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = a3;
  }
  unsigned int v18 = v10;
  CFArrayRef v11 = *(const __CFArray **)(a1 + 256);
  v22.length = CFArrayGetCount(v11);
  v22.location = 0;
  CFArrayApplyFunction(v11, v22, (CFArrayApplierFunction)__FilterFunctionCopyPropertyForClient, &context);
  uint64_t v12 = *(void *)(a1 + 72);
  if (*(_DWORD *)v12)
  {
    --*(_DWORD *)v12;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v19, v20);
    }
  }
  uint64_t v9 = v17;
  if (!v17) {
    uint64_t v9 = __IOHIDServiceCopyPropertyForClient(a1, a2, a3, 0);
  }
  if (v8 == (const void *)defaultPropertyKeyValue)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
    if (v9) {
      uint64_t v13 = (const void *)v9;
    }
    else {
      uint64_t v13 = (const void *)*MEMORY[0x1E4F1D260];
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 312), a2, v13);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
    CFRelease(v8);
  }
LABEL_21:
  uint64_t v14 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v14, v6, 0x3E8u);
  if (*(void *)(a1 + 464)) {
    IOHIDAnalyticsEventSetIntegerValueForField();
  }
  return v9;
}

unint64_t _IOHIDGetTimestampDelta(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v6 = dword_1EB219254;
  if (!dword_1EB219254)
  {
    mach_timebase_info((mach_timebase_info_t)&_IOHIDGetTimestampDelta_timebaseInfo);
    unsigned int v6 = dword_1EB219254;
  }
  return (a1 - a2) * (unint64_t)_IOHIDGetTimestampDelta_timebaseInfo / v6 / a3;
}

uint64_t IOHIDAnalyticsEventSetIntegerValueForField()
{
  if (setIntegerValueForFieldFuncPtr) {
    return setIntegerValueForFieldFuncPtr();
  }
  return result;
}

uint64_t IOCFSerializeBinaryCFDictionaryFunction(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  ++a3[1];
  *((unsigned char *)a3 + 24) &= DoCFSerializeBinary(v6, a1, 1);
  uint64_t v7 = *a3;
  *(unsigned char *)(v7 + 16) = a3[1] == a3[2];
  uint64_t result = DoCFSerializeBinary(v7, a2, 0);
  *((unsigned char *)a3 + 24) &= result;
  return result;
}

uint64_t DoCFSerializeBinary(uint64_t a1, const __CFString *a2, int a3)
{
  long long context = 0u;
  long long v39 = 0u;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  if (Value)
  {
    *(_DWORD *)bytes = Value & 0xFFFFFF | 0xC000000;
    if (*(unsigned char *)(a1 + 16))
    {
      *(unsigned char *)(a1 + 16) = 0;
      *(_DWORD *)bytes = Value & 0xFFFFFF | 0x8C000000;
    }
    CFDataAppendBytes(*(CFMutableDataRef *)a1, bytes, 4);
    return 1;
  }
  CFTypeID v8 = CFGetTypeID(a2);
  *(void *)&long long context = a1;
  if (v8 == CFDictionaryGetTypeID())
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
    IOCFSerializeBinaryAddObject(a1, a2, Count | 0x1000000, 0, 0, 0);
    BYTE8(v39) = 1;
    *((void *)&context + 1) = 0;
    *(void *)&long long v39 = Count;
    CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)IOCFSerializeBinaryCFDictionaryFunction, &context);
    return BYTE8(v39);
  }
  if (v8 == CFArrayGetTypeID())
  {
    CFIndex v10 = CFArrayGetCount((CFArrayRef)a2);
    IOCFSerializeBinaryAddObject(a1, a2, v10 | 0x2000000, 0, 0, 0);
    BYTE8(v39) = 1;
    *((void *)&context + 1) = 0;
    *(void *)&long long v39 = v10;
    v40.location = 0;
    v40.length = v10;
    CFArrayApplyFunction((CFArrayRef)a2, v40, (CFArrayApplierFunction)IOCFSerializeBinaryCFArraySetFunction, &context);
    return BYTE8(v39);
  }
  if (v8 == CFSetGetTypeID())
  {
    CFIndex v11 = CFArrayGetCount((CFArrayRef)a2);
    IOCFSerializeBinaryAddObject(a1, a2, v11 | 0x3000000, 0, 0, 0);
    BYTE8(v39) = 1;
    *((void *)&context + 1) = 0;
    *(void *)&long long v39 = v11;
    CFSetApplyFunction((CFSetRef)a2, (CFSetApplierFunction)IOCFSerializeBinaryCFArraySetFunction, &context);
    return BYTE8(v39);
  }
  if (v8 != CFNumberGetTypeID())
  {
    if (v8 == CFBooleanGetTypeID())
    {
      int v14 = (*MEMORY[0x1E4F1CFD0] == (void)a2) | 0xB000000;
      uint64_t v15 = a1;
      CFStringRef v16 = a2;
      BytePtr = 0;
      uint64_t v18 = 0;
      goto LABEL_30;
    }
    if (v8 != CFStringGetTypeID())
    {
      if (v8 != CFDataGetTypeID())
      {
        uint64_t result = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<string>typeID 0x%x not serializable</string>", v8);
        if (result)
        {
          uint64_t v31 = (const void *)result;
          uint64_t v32 = DoCFSerializeBinary(a1, result, 0);
          CFRelease(v31);
          return v32;
        }
        return result;
      }
      CFIndex Length = CFDataGetLength((CFDataRef)a2);
      BytePtr = CFDataGetBytePtr((CFDataRef)a2);
      uint64_t v15 = a1;
      CFStringRef v16 = a2;
      int v14 = Length | 0xA000000;
      uint64_t v18 = Length;
LABEL_30:
      IOCFSerializeBinaryAddObject(v15, v16, v14, BytePtr, v18, 0);
      return 1;
    }
    CStringPtr = CFStringGetCStringPtr(a2, 0x8000100u);
    if (CStringPtr)
    {
      uint64_t v21 = (const UInt8 *)CStringPtr;
      size_t v22 = CFStringGetLength(a2);
      CFDataRef v23 = 0;
      goto LABEL_26;
    }
    CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u, 0);
    CFDataRef v23 = ExternalRepresentation;
    if (ExternalRepresentation || (CFDataRef v23 = CFStringCreateExternalRepresentation(v33, a2, 0x8000100u, 0x3Fu)) != 0)
    {
      size_t v22 = CFDataGetLength(v23);
      uint64_t v21 = CFDataGetBytePtr(v23);
      if (ExternalRepresentation)
      {
LABEL_26:
        if (a3)
        {
          uint64_t v24 = v22 + 1;
          int v25 = (v22 + 1) | 0x8000000;
          uint64_t v26 = a1;
          CFStringRef v27 = a2;
          unint64_t v28 = v21;
          uint64_t v29 = 1;
        }
        else
        {
          int v25 = v22 | 0x9000000;
          uint64_t v26 = a1;
          CFStringRef v27 = a2;
          unint64_t v28 = v21;
          uint64_t v24 = v22;
          uint64_t v29 = 0;
        }
        IOCFSerializeBinaryAddObject(v26, v27, v25, v28, v24, v29);
        if (v23) {
          CFRelease(v23);
        }
        return 1;
      }
    }
    else
    {
      size_t v22 = 0;
      uint64_t v21 = (const UInt8 *)"";
    }
    if (v21)
    {
      uint64_t v35 = (char *)malloc_type_malloc(v22 + 1, 0x48D202D1uLL);
      if (v35)
      {
        uint64_t v36 = v35;
        memmove(v35, v21, v22);
        v36[v22] = 0;
        syslog(3, "FIXME: IOCFSerialize has detected a string that can not be converted to UTF-8, \"%s\"", v36);
        free(v36);
      }
    }
    goto LABEL_26;
  }
  *(void *)bytes = 0;
  unint64_t v12 = CFNumberGetType((CFNumberRef)a2) - 5;
  if (v12 > 0xB) {
    CFNumberType v13 = kCFNumberLongLongType;
  }
  else {
    CFNumberType v13 = qword_18B50B968[v12];
  }
  uint64_t result = CFNumberGetValue((CFNumberRef)a2, v13, bytes);
  if (result)
  {
    unint64_t v19 = CFNumberGetType((CFNumberRef)a2) - 1;
    if (v19 > 0xF) {
      int v14 = 67108928;
    }
    else {
      int v14 = dword_18B50B9C8[v19];
    }
    BytePtr = bytes;
    uint64_t v15 = a1;
    CFStringRef v16 = a2;
    uint64_t v18 = 8;
    goto LABEL_30;
  }
  return result;
}

void IOCFSerializeBinaryAddObject(uint64_t a1, const void *a2, int a3, const UInt8 *a4, uint64_t a5, uint64_t a6)
{
  *(_DWORD *)bytes = a3;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), a2, *(const void **)(a1 + 24));
  ++*(void *)(a1 + 24);
  if (*(unsigned char *)(a1 + 16))
  {
    *(unsigned char *)(a1 + 16) = 0;
    *(_DWORD *)bytes = a3 | 0x80000000;
  }
  CFDataAppendBytes(*(CFMutableDataRef *)a1, bytes, 4);
  CFDataAppendBytes(*(CFMutableDataRef *)a1, a4, a5 - a6);
  if (a6) {
    CFDataIncreaseLength(*(CFMutableDataRef *)a1, 1);
  }
  if ((a5 & 3) != 0) {
    CFDataIncreaseLength(*(CFMutableDataRef *)a1, 4 - (a5 & 3));
  }
}

const void *_IOHIDServiceCopyConnectionCache(uint64_t a1, const void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  }
  ++**(_DWORD **)(a1 + 72);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 240), a2);
  uint64_t v5 = Value;
  if (Value) {
    CFRetain(Value);
  }
  uint64_t v6 = *(void *)(a1 + 72);
  if (*(_DWORD *)v6)
  {
    --*(_DWORD *)v6;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
    }
  }
  return v5;
}

uint64_t io_connect_method(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__dst, int *a10, void *a11, int *a12, uint64_t a13, void *a14)
{
  unsigned int v14 = MEMORY[0x1F4188790]();
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  *(_OWORD *)__n = 0u;
  long long v52 = 0u;
  *(_OWORD *)reply_port = 0u;
  long long v50 = 0u;
  *((void *)&v50 + 1) = *MEMORY[0x1E4F14068];
  LODWORD(__n[0]) = v20;
  if (v15 <= 0x10)
  {
    uint64_t v21 = v19;
    uint64_t v22 = v18;
    unsigned int v23 = v17;
    uint64_t v24 = v16;
    unsigned int v25 = v15;
    unsigned int v26 = v14;
    uint64_t v27 = 2 * v15;
    __memcpy_chk();
    HIDWORD(__n[0]) = v25;
    if (v23 <= 0x1000)
    {
      uint64_t v30 = &reply_port[v27];
      uint64_t v31 = (v23 + 3) & 0xFFFFFFFC;
      uint64_t v32 = (char *)&reply_port[v27] + v31;
      int v33 = v27 * 4 + v31;
      memcpy(v30 + 11, v24, v23);
      v30[10] = v23;
      *(void *)(v32 + 44) = v22;
      *(void *)(v32 + 52) = v21;
      int v34 = *a10;
      if (*a10 >= 0x1000) {
        int v34 = 4096;
      }
      *((_DWORD *)v32 + 15) = v34;
      int v35 = *a12;
      if (*a12 >= 0x10) {
        int v35 = 16;
      }
      *((_DWORD *)v32 + 16) = v35;
      *(void *)(v32 + 68) = a13;
      *(void *)(v32 + 76) = *a14;
      mach_port_t v36 = mig_get_reply_port();
      reply_port[0] = 5395;
      reply_port[1] = v33 + 84;
      *(void *)&reply_port[2] = __PAIR64__(v36, v26);
      *(void *)&long long v50 = 0xB3100000000;
      uint64_t v37 = mach_msg2_internal();
      uint64_t v28 = v37;
      if ((v37 - 268435458) <= 0xE && ((1 << (v37 - 2)) & 0x4003) != 0)
      {
        mig_put_reply_port(reply_port[3]);
        return v28;
      }
      if (v37)
      {
        mig_dealloc_reply_port(reply_port[3]);
        return v28;
      }
      if (DWORD1(v50) == 71)
      {
        uint64_t v28 = 4294966988;
      }
      else if (DWORD1(v50) == 2965)
      {
        if ((reply_port[0] & 0x80000000) != 0) {
          goto LABEL_30;
        }
        if (reply_port[1] - 4277 <= 0xFFFFEF7E)
        {
          if (reply_port[2]) {
            BOOL v38 = 1;
          }
          else {
            BOOL v38 = LODWORD(__n[0]) == 0;
          }
          if (!v38 && reply_port[1] == 36) {
            uint64_t v28 = LODWORD(__n[0]);
          }
          else {
            uint64_t v28 = 4294966996;
          }
          goto LABEL_31;
        }
        if (reply_port[2]) {
          goto LABEL_30;
        }
        uint64_t v28 = LODWORD(__n[0]);
        if (LODWORD(__n[0])) {
          goto LABEL_31;
        }
        int v40 = HIDWORD(__n[0]);
        if (HIDWORD(__n[0]) > 0x1000)
        {
LABEL_30:
          uint64_t v28 = 4294966996;
        }
        else
        {
          uint64_t v28 = 4294966996;
          if (reply_port[1] - 52 >= HIDWORD(__n[0]))
          {
            unsigned int v41 = (HIDWORD(__n[0]) + 3) & 0xFFFFFFFC;
            if (reply_port[1] >= v41 + 52)
            {
              v42 = (char *)reply_port + v41;
              mach_port_t v43 = *((_DWORD *)v42 + 10);
              if (v43 <= 0x10 && v43 <= (reply_port[1] - v41 - 52) >> 3)
              {
                unsigned int v44 = 8 * v43;
                if (reply_port[1] - v41 == 8 * v43 + 52)
                {
                  size_t v45 = *a10;
                  if (HIDWORD(__n[0]) <= v45)
                  {
                    __int16 v46 = v42 - 4096;
                    memcpy(__dst, &__n[1], HIDWORD(__n[0]));
                    *a10 = v40;
                    unsigned int v47 = *((_DWORD *)v46 + 1034);
                    __int16 v48 = v46 + 4140;
                    if (v47 <= *a12)
                    {
                      memcpy(a11, v48, 8 * v47);
                      uint64_t v28 = 0;
                      *a12 = *((_DWORD *)v46 + 1034);
                      *a14 = *(void *)&v46[v44 + 4140];
                      return v28;
                    }
                    memcpy(a11, v48, (8 * *a12));
                    *a12 = *((_DWORD *)v46 + 1034);
                  }
                  else
                  {
                    memcpy(__dst, &__n[1], v45);
                    *a10 = v40;
                  }
                  return 4294966989;
                }
              }
            }
          }
        }
      }
      else
      {
        uint64_t v28 = 4294966995;
      }
LABEL_31:
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v28;
    }
  }
  return 4294966989;
}

uint64_t _IOHIDLogCategory(unsigned int a1)
{
  if (a1 >= 0xF) {
    _IOHIDLogCategory_cold_1();
  }
  if (_IOHIDLogCategory_onceToken != -1) {
    dispatch_once(&_IOHIDLogCategory_onceToken, &__block_literal_global_7);
  }
  return _IOHIDLogCategory_log[a1];
}

uint64_t IOHIDServiceCheckEntitlements(uint64_t a1, uint64_t a2)
{
  Entitlements = (unsigned char *)IOHIDEventSystemConnectionGetEntitlements(a2);
  uint64_t v5 = Entitlements;
  if (*(_DWORD *)(a1 + 304)) {
    return (*Entitlements & 0x11) != 0;
  }
  if (!*(void *)(a1 + 64)) {
    return 1;
  }
  uint64_t v9 = 0;
  if (os_variant_allows_internal_security_policies())
  {
    if ((*v5 & 0x40) != 0) {
      return 1;
    }
  }
  uint64_t v8 = a2;
  CFArrayRef v7 = *(const __CFArray **)(a1 + 64);
  v10.length = CFArrayGetCount(v7);
  v10.location = 0;
  CFArrayApplyFunction(v7, v10, (CFArrayApplierFunction)EntitlementCheckApplier, &v8);
  return v9;
}

uint64_t IOHIDEventSystemConnectionGetEntitlements(uint64_t a1)
{
  return *(void *)(a1 + 240);
}

void __IOHIDSessionDispatchEvent(uint64_t a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t context = 0;
  CFTypeRef v25 = 0;
  CFTypeRef cf = 0;
  if (!a1) {
    goto LABEL_28;
  }
  TimeStampOfuint64_t Type = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  TimeStampuint64_t Type = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8273, 0, TimeStampOfType, TimeStampType, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v23, v27);
  }
  ++**(_DWORD **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 8);
  CFArrayRef v7 = *(void (**)(uint64_t, uint64_t, CFTypeRef, CFTypeRef))(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  CFTypeRef v9 = _IOHIDEventCopyAttachment((uint64_t)a2, @"Sender");
  uint64_t context = a1;
  CFTypeRef v25 = v9;
  CFTypeRef cf = CFRetain(a2);
  uint64_t v10 = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  unsigned int v11 = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8274, 1, v10, v11, 0, 0);
  CFArrayRef v12 = *(const __CFArray **)(a1 + 144);
  v29.length = CFArrayGetCount(v12);
  v29.location = 0;
  CFArrayApplyFunction(v12, v29, (CFArrayApplierFunction)__FilterFunctionFilterEvent_0, &context);
  uint64_t v13 = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  unsigned int v14 = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8274, 2, v13, v14, 0, 0);
  CFTypeRef v15 = cf;
  if (v9 && cf)
  {
    if (_IOHIDServiceIsInactive((uint64_t)v9) && (IOHIDEventGetEventFlags((uint64_t)cf) & 0x800000) == 0)
    {
      CFTypeRef cf = 0;
LABEL_8:
      uint64_t v16 = *(void *)(a1 + 32);
      if (*(_DWORD *)v16)
      {
        --*(_DWORD *)v16;
        if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8))) {
          __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
        }
      }
      goto LABEL_28;
    }
    CFTypeRef v15 = cf;
  }
  if (!v15) {
    goto LABEL_8;
  }
  if (IOHIDEventGetPolicy((uint64_t)a2, 3) == 3)
  {
    *(void *)(a1 + 168) = mach_continuous_time();
    gettimeofday((timeval *)(a1 + 176), 0);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 192), (CFSetApplierFunction)__ActivityFunctionApplier, a2);
  }
  unsigned int v17 = *(int **)(a1 + 32);
  int v18 = *v17;
  if (v7)
  {
    if (v18)
    {
      int v19 = *v17;
      do
      {
        uint64_t v20 = *(void *)(a1 + 32);
        if (*(_DWORD *)v20)
        {
          --*(_DWORD *)v20;
          if (pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8))) {
            __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
          }
        }
        --v19;
      }
      while (v19);
    }
    v7(v6, v8, v25, cf);
    uint64_t v21 = *(void *)(a1 + 32);
    if (v18)
    {
      do
      {
        if (pthread_mutex_lock((pthread_mutex_t *)(v21 + 8))) {
          __IOHIDSessionCreate_block_invoke_cold_4(&v23, v27);
        }
        uint64_t v21 = *(void *)(a1 + 32);
        int v22 = *(_DWORD *)v21 + 1;
        *(_DWORD *)uint64_t v21 = v22;
        --v18;
      }
      while (v18);
      if (!v22) {
        goto LABEL_28;
      }
    }
    else
    {
      int v22 = *(_DWORD *)v21;
      if (!*(_DWORD *)v21) {
        goto LABEL_28;
      }
    }
    *(_DWORD *)uint64_t v21 = v22 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v21 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
    }
    goto LABEL_28;
  }
  if (v18)
  {
    *unsigned int v17 = v18 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v17 + 2))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v23, v27);
    }
  }
LABEL_28:
  if (cf) {
    CFRelease(cf);
  }
  if (v25) {
    CFRelease(v25);
  }
}

uint64_t IOHIDEventGetTimeStampOfType(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (a2 == 1)
    {
      if ((*(unsigned char *)(a1 + 32) & 0x80) == 0 && mach_get_times()) {
        uint64_t v2 = 0;
      }
      if (dynLinkrosetta_is_current_process_translated_0[0]
        && dynLinkrosetta_is_current_process_translated_0[0]()
        && dynLinkrosetta_convert_to_system_absolute_time_0[0])
      {
        return ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v2);
      }
    }
    else if (a2 == 2 && (*(unsigned char *)(a1 + 32) & 0x80) == 0)
    {
      goto LABEL_5;
    }
    return v2;
  }
LABEL_5:

  return IOHIDEventGetTimeStamp(a1);
}

void __IOHIDEventSystemEventCallback(uint64_t a1, uint64_t a2, const void *a3, void *a4)
{
  context[0] = a3;
  context[1] = a4;
  context[2] = a1;
  if (!a1) {
    return;
  }
  TimeStampOfuint64_t Type = IOHIDEventGetTimeStampOfType((uint64_t)a4, 2);
  if (a3 && (CFTypeID v8 = CFGetTypeID(a3), v8 == IOHIDServiceGetTypeID()))
  {
    CFSetRef Copy = (const __CFSet *)_IOHIDServiceCopyConnections((uint64_t)a3, 0);
    CFSetRef v10 = (const __CFSet *)_IOHIDServiceCopyConnections((uint64_t)a3, 2);
  }
  else
  {
    os_unfair_recursive_lock_lock_with_options();
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
    CFSetRef Copy = CFSetCreateCopy(v11, *(CFSetRef *)(a1 + 56));
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
    CFSetRef v10 = CFSetCreateCopy(v12, *(CFSetRef *)(a1 + 64));
    os_unfair_recursive_lock_unlock();
  }
  uint64_t v13 = mach_absolute_time();
  _IOHIDDebugEventAddPerfData(a4, 2, v13);
  TimeStampuint64_t Type = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8211, 1, TimeStampOfType, TimeStampType, 0, 0);
  if (Copy) {
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__EnqueueEventFunction, context);
  }
  unsigned int v15 = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8209, 0, TimeStampOfType, v15, 0, 0);
  if (!a3)
  {
    int v34 = 0;
    goto LABEL_15;
  }
  if (_IOHIDServiceHidden((uint64_t)a3))
  {
    int v16 = 0;
    goto LABEL_27;
  }
  int v34 = 0;
  CFTypeID v17 = CFGetTypeID(a3);
  if (v17 != IOHIDServiceGetTypeID())
  {
LABEL_15:
    CFArrayRef v19 = *(const __CFArray **)(a1 + 80);
    if (!v19) {
      goto LABEL_20;
    }
    if (!CFArrayGetCount(v19)) {
      goto LABEL_20;
    }
    os_unfair_recursive_lock_lock_with_options();
    CFAllocatorRef v20 = CFGetAllocator((CFTypeRef)a1);
    CFArrayRef v18 = CFArrayCreateCopy(v20, *(CFArrayRef *)(a1 + 80));
    os_unfair_recursive_lock_unlock();
    if (!v18) {
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  CFArrayRef v18 = (const __CFArray *)_IOHIDServiceCopyConnections((uint64_t)a3, 1);
  if (!v18)
  {
LABEL_20:
    uint64_t v21 = TimeStampOfType;
    CFSetRef v22 = Copy;
    CFSetRef v23 = v10;
    CFArrayRef cf = 0;
    char v24 = 1;
    goto LABEL_21;
  }
LABEL_18:
  v33[0] = a3;
  v33[1] = a4;
  v33[2] = &v34;
  v35.length = CFArrayGetCount(v18);
  CFArrayRef cf = v18;
  v35.location = 0;
  CFArrayApplyFunction(v18, v35, (CFArrayApplierFunction)__IOHIDEventSystemFilterEventFunction, v33);
  if (!v34)
  {
    uint64_t v21 = TimeStampOfType;
    CFSetRef v22 = Copy;
    CFSetRef v23 = v10;
    char v24 = 0;
LABEL_21:
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v26 = *(void *)(a1 + 104);
    CFTypeRef v25 = *(void (**)(uint64_t, uint64_t, const void *, void *))(a1 + 112);
    uint64_t v27 = *(void *)(a1 + 120);
    os_unfair_recursive_lock_unlock();
    if (__IOHIDEventSystemIsTimeToDispatchEvent((const void *)*MEMORY[0x1E4F1D260], (uint64_t)a3, a4)
      && v25)
    {
      v25(v26, v27, a3, a4);
    }
    CFSetRef v10 = v23;
    CFSetRef Copy = v22;
    TimeStampOfuint64_t Type = v21;
    if (v24) {
      goto LABEL_26;
    }
  }
  CFRelease(cf);
LABEL_26:
  int v16 = v34;
LABEL_27:
  unsigned int v28 = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8210, 0, TimeStampOfType, v16, v28, 0);
  uint64_t v29 = mach_absolute_time();
  _IOHIDDebugEventAddPerfData(a4, 3, v29);
  if (!v16 && v10) {
    CFSetApplyFunction(v10, (CFSetApplierFunction)__EnqueueEventFunction, context);
  }
  unsigned int v30 = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8211, 2, TimeStampOfType, v30, 0, 0);
  if (Copy) {
    CFRelease(Copy);
  }
  if (v10) {
    CFRelease(v10);
  }
}

void _IOHIDDebugTrace(__int16 a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (4 * (a1 & 0x3FFF)) | a2 | 0x5230000u;
  kdebug_trace();
  if ((gIOHIDDebugConfig & 2) != 0)
  {
    if (_IOHIDLogCategory_onceToken != -1) {
      dispatch_once(&_IOHIDLogCategory_onceToken, &__block_literal_global_7);
    }
    CFAllocatorRef v11 = qword_1EB2191B0;
    if (os_log_type_enabled((os_log_t)qword_1EB2191B0, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 134219008;
      uint64_t v13 = v10;
      __int16 v14 = 2048;
      uint64_t v15 = a3;
      __int16 v16 = 2048;
      uint64_t v17 = a4;
      __int16 v18 = 2048;
      uint64_t v19 = a5;
      __int16 v20 = 2048;
      uint64_t v21 = a6;
      _os_log_impl(&dword_18B46C000, v11, OS_LOG_TYPE_DEFAULT, "0x%-16llx 0x%-16llx 0x%-16llx 0x%-16llx 0x%-16llx", (uint8_t *)&v12, 0x34u);
    }
  }
}

uint64_t IOHIDEventGetTimeStampType(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 32) >> 7) & 1;
}

uint64_t IOHIDServiceGetTypeID()
{
  return MEMORY[0x1F41817D0](HIDEventService);
}

void *_IOHIDDebugEventAddPerfData(void *result, int a2, uint64_t a3)
{
  if ((gIOHIDDebugConfig & 0x10) != 0)
  {
    uint64_t v5 = result;
    if (!IOHIDEventConformsTo((uint64_t)result, 1)) {
      goto LABEL_10;
    }
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren((uint64_t)v5);
    if (!Children) {
      goto LABEL_10;
    }
    CFArrayRef v7 = Children;
    CFIndex Count = CFArrayGetCount(Children);
    if (Count < 1) {
      goto LABEL_10;
    }
    CFIndex v9 = Count;
    CFIndex v10 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v7, v10);
      if (IOHIDEventGetType((uint64_t)ValueAtIndex) == 1
        && IOHIDEventGetIntegerValue(ValueAtIndex, 0x10001u) == 38
        && IOHIDEventGetIntegerValue(ValueAtIndex, 0x10000u) == 65280)
      {
        break;
      }
      if (v9 == ++v10) {
        goto LABEL_10;
      }
    }
    if (!ValueAtIndex)
    {
LABEL_10:
      uint64_t v17 = 0;
      memset(v16, 0, sizeof(v16));
      CFAllocatorRef v12 = CFGetAllocator(v5);
      uint64_t v13 = mach_absolute_time();
      uint64_t result = (void *)IOHIDEventCreateVendorDefinedEvent((uint64_t)v12, v13, 65280, 38, 0, v16, 0x28uLL, 0);
      if (!result) {
        return result;
      }
      ValueAtIndex = result;
      IOHIDEventAppendEvent((uint64_t)v5, result);
      CFRelease(ValueAtIndex);
    }
    uint64_t v15 = 0;
    *(void *)&v16[0] = 0;
    uint64_t result = IOHIDEventGetVendorDefinedData(ValueAtIndex, (uint64_t *)v16, &v15);
    if (*(void *)&v16[0])
    {
      switch(a2)
      {
        case 1:
          __int16 v14 = (void *)(*(void *)&v16[0] + 8);
          goto LABEL_18;
        case 2:
          __int16 v14 = (void *)(*(void *)&v16[0] + 16);
          goto LABEL_18;
        case 3:
          __int16 v14 = (void *)(*(void *)&v16[0] + 24);
          goto LABEL_18;
        case 4:
          __int16 v14 = (void *)(*(void *)&v16[0] + 32);
LABEL_18:
          *__int16 v14 = a3;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

CFTypeRef _IOHIDServiceCopyConnections(uint64_t a1, int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a2 > 2) {
    return 0;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  }
  uint64_t v4 = *(void *)(a1 + 72);
  int v5 = *(_DWORD *)v4 + 1;
  *(_DWORD *)uint64_t v4 = v5;
  if (*(void *)(*(void *)(a1 + 368) + 8 * a2))
  {
    CFTypeRef v6 = CFRetain(*(CFTypeRef *)(*(void *)(a1 + 368) + 8 * a2));
    uint64_t v4 = *(void *)(a1 + 72);
    int v5 = *(_DWORD *)v4;
    if (!*(_DWORD *)v4) {
      return v6;
    }
  }
  else
  {
    CFTypeRef v6 = 0;
    if (!v5) {
      return v6;
    }
  }
  *(_DWORD *)uint64_t v4 = v5 - 1;
  if (pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
  }
  return v6;
}

uint64_t _IOHIDServiceHidden(uint64_t a1)
{
  return *(unsigned int *)(a1 + 300);
}

uint64_t IOHIDEventGetPolicy(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(*(void *)(a1 + 104) + 10) & 0x80) != 0) {
    return 0;
  }
  if (a2 != 3)
  {
    uint64_t v4 = _IOHIDLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      IOHIDEventGetPolicy_cold_1(a2, v4);
    }
    return 0;
  }
  if ((*(void *)(a1 + 24) & 0x819CF0DFCLL) != 0) {
    return 3;
  }
  else {
    return 0;
  }
}

void _IOHIDServiceSetEventDeadlineForClient(uint64_t a1, const void *a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v15);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t v10 = a5;
  if (a5 || (uint64_t v10 = __IOHIDServiceCreateAndCopyConnectionCache(a1, a2)) != 0)
  {
    if (_IOHIDServiceGetReportIntervalForClient(a1, a2, v10) == a4) {
      IOHIDServiceConnectionCacheSetReportDeadline((uint64_t)v10, a3);
    }
    char v11 = 1;
  }
  else
  {
    char v11 = 0;
  }
  uint64_t v12 = *(void *)(a1 + 72);
  if (*(_DWORD *)v12)
  {
    --*(_DWORD *)v12;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v15);
    }
  }
  char v13 = v11 ^ 1;
  if (v10 == a5) {
    char v13 = 1;
  }
  if ((v13 & 1) == 0)
  {
    CFRelease(v10);
  }
}

uint64_t IOHIDServiceConnectionCacheSetReportDeadline(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

CFTypeRef __IOHIDServiceCopyPropertyForClient(uint64_t a1, const void *a2, const void *a3, int a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = mach_absolute_time();
  if (a3 && (CFTypeID v9 = CFGetTypeID(a3), v9 == IOHIDEventSystemConnectionGetTypeID())) {
    int Type = IOHIDEventSystemConnectionGetType((uint64_t)a3);
  }
  else {
    int Type = 5;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v31, v32);
  }
  ++**(_DWORD **)(a1 + 72);
  if (!a4)
  {
    if (CFEqual(a2, @"ReportInterval") || CFEqual(a2, @"BatchInterval"))
    {
      if (Type >= 2 && Type != 5)
      {
        uint64_t v14 = _IOHIDServiceCopyConnectionCache(a1, a3);
        uint64_t v15 = v14;
        if (v14)
        {
          CFTypeRef v16 = IOHIDServiceConnectionCacheCopyValueForKey(v14, a2);
          CFRelease(v15);
LABEL_33:
          LOBYTE(v15) = 1;
          goto LABEL_34;
        }
        goto LABEL_52;
      }
      if (CFEqual(a2, @"ReportInterval"))
      {
        CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
        uint64_t v12 = (const void *)(a1 + 160);
      }
      else
      {
        if (!CFEqual(a2, @"BatchInterval"))
        {
          CFTypeRef v16 = 0;
          goto LABEL_33;
        }
        CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
        uint64_t v12 = (const void *)(a1 + 164);
      }
    }
    else
    {
      if (!CFEqual(a2, @"QueueSize") || Type != 2) {
        goto LABEL_7;
      }
      CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v12 = (const void *)(a1 + 216);
    }
    CFNumberType v13 = kCFNumberSInt32Type;
    goto LABEL_31;
  }
LABEL_7:
  if (CFEqual(a2, @"LastActivityTimestamp"))
  {
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v12 = (const void *)(a1 + 328);
    CFNumberType v13 = kCFNumberSInt64Type;
LABEL_31:
    CFNumberRef v17 = CFNumberCreate(v11, v13, v12);
    goto LABEL_32;
  }
  if (CFEqual(a2, @"ServiceRecord"))
  {
    CFNumberRef v17 = _IOHIDServiceCopyServiceRecordForClient((_DWORD *)a1, a3);
LABEL_32:
    CFTypeRef v16 = v17;
    goto LABEL_33;
  }
  uint64_t v18 = *(void *)(a1 + 32);
  if (v18)
  {
    uint64_t v19 = *(uint64_t (**)(void))(*(void *)v18 + 48);
    if (v19)
    {
      CFNumberRef v17 = (CFNumberRef)v19();
      goto LABEL_32;
    }
  }
  uint64_t v20 = *(void *)(a1 + 24);
  if (!v20 || (uint64_t v21 = *(uint64_t (**)(void))(*(void *)v20 + 48)) == 0)
  {
    uint64_t v27 = *(void *)(a1 + 360);
    if (v27)
    {
      unsigned int v28 = *(uint64_t (**)(void, void, const void *))(v27 + 24);
      if (v28)
      {
        CFNumberRef v17 = (CFNumberRef)v28(*(void *)(a1 + 344), *(void *)(a1 + 352), a2);
        goto LABEL_32;
      }
    }
    uint64_t v29 = *(void **)(a1 + 480);
    if (v29)
    {
      id v30 = objc_msgSend(v29, *(SEL *)(a1 + 496), a2, a3);
      CFTypeRef v16 = v30;
      if (v30) {
        CFRetain(v30);
      }
      goto LABEL_33;
    }
    LOBYTE(v15) = 0;
LABEL_52:
    CFTypeRef v16 = 0;
    goto LABEL_34;
  }
  CFTypeRef v16 = (CFTypeRef)v21();
  LOBYTE(v15) = 0;
LABEL_34:
  uint64_t v22 = *(void *)(a1 + 72);
  if (*(_DWORD *)v22)
  {
    --*(_DWORD *)v22;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v22 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v31, v32);
    }
  }
  if (v16) {
    char v23 = (char)v15;
  }
  else {
    char v23 = 1;
  }
  if ((v23 & 1) == 0) {
    CFRetain(v16);
  }
  uint64_t v24 = mach_absolute_time();
  unint64_t v25 = _IOHIDGetTimestampDelta(v24, v8, 1u);
  if (v25 > *(void *)(a1 + 384)) {
    *(void *)(a1 + 384) = v25;
  }
  return v16;
}

uint64_t __IOHIDServiceUpdateIntervals(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&context, buf);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t context = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 168);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__ConnectionFunctionPickReportInterval, &context);
  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 240)))
  {
    LODWORD(v5) = HIDWORD(context);
    double v6 = (double)v5;
    char v7 = (double)context * 1.25 < v6;
    if ((double)context * 1.75 <= v6) {
      char v7 = 0;
    }
    unsigned int v4 = context >> v7;
  }
  uint64_t v8 = *(void *)(a1 + 72);
  if (*(_DWORD *)v8)
  {
    --*(_DWORD *)v8;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v20, buf);
    }
  }
  int v9 = __IOHIDServicePickBatchInterval(a1);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&context, buf);
  }
  ++**(_DWORD **)(a1 + 72);
  if (v4 == *(_DWORD *)(a1 + 160))
  {
    uint64_t v10 = 1;
  }
  else
  {
    uint64_t v10 = __SetNumPropertyForService(a1, @"ReportInterval", v4, a2);
    CFMutableDictionaryRef v11 = _IOHIDServiceCopyEventCounts((void *)a1);
    uint64_t v12 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      uint64_t v13 = *(void *)(a1 + 400);
      int v14 = *(_DWORD *)(a1 + 160);
      *(_DWORD *)buf = 134219010;
      uint64_t v23 = v13;
      __int16 v24 = 1024;
      int v25 = v14;
      __int16 v26 = 1024;
      unsigned int v27 = v4;
      __int16 v28 = 1024;
      int v29 = v10;
      __int16 v30 = 2112;
      CFMutableDictionaryRef v31 = v11;
      _os_log_impl(&dword_18B46C000, v12, OS_LOG_TYPE_INFO, "0x%llx: Set report interval current:%d new:%d result:%d events:%@", buf, 0x28u);
    }
    if (v10) {
      *(_DWORD *)(a1 + 160) = v4;
    }
    if (v11) {
      CFRelease(v11);
    }
  }
  if (v9 != *(_DWORD *)(a1 + 164))
  {
    uint64_t v10 = __SetNumPropertyForService(a1, @"BatchInterval", v9, a2);
    uint64_t v15 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      uint64_t v16 = *(void *)(a1 + 400);
      int v17 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)buf = 134218752;
      uint64_t v23 = v16;
      __int16 v24 = 1024;
      int v25 = v17;
      __int16 v26 = 1024;
      unsigned int v27 = v9;
      __int16 v28 = 1024;
      int v29 = v10;
      _os_log_impl(&dword_18B46C000, v15, OS_LOG_TYPE_INFO, "0x%llx: Set batch interval current:%d new:%d result:%d", buf, 0x1Eu);
    }
    if (v10) {
      *(_DWORD *)(a1 + 164) = v9;
    }
  }
  uint64_t v18 = *(void *)(a1 + 72);
  if (*(_DWORD *)v18)
  {
    --*(_DWORD *)v18;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&context, buf);
    }
  }
  return v10;
}

uint64_t __IOHIDServicePickBatchInterval(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int context = -1;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v4, v6);
  }
  ++**(_DWORD **)(a1 + 72);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__ConnectionFunctionPickBatchInterval, &context);
  uint64_t v2 = *(void *)(a1 + 72);
  if (*(_DWORD *)v2)
  {
    --*(_DWORD *)v2;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v4, v6);
    }
  }
  uint64_t result = context;
  if (context == -1) {
    return *(unsigned int *)(a1 + 172);
  }
  return result;
}

CFPropertyListRef __IOHIDServiceVirtualCopyPropertyCallback(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t SenderID = _IOHIDServiceGetSenderID(a1);
  memset(length, 0, sizeof(length));
  if (!a3)
  {
    int v17 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      __IOHIDServiceVirtualCopyPropertyCallback_cold_1();
    }
    return 0;
  }
  CFDataRef v6 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a3);
  if (!v6) {
    return 0;
  }
  CFDataRef v7 = v6;
  if (*(_DWORD *)(a2 + 448))
  {
    CFPropertyListRef v14 = 0;
  }
  else
  {
    mach_port_t v8 = *(_DWORD *)(a2 + 40);
    BytePtr = CFDataGetBytePtr(v6);
    int v10 = CFDataGetLength(v7);
    int v11 = iohideventsystem_client_dispatch_virtual_service_copy_property(v8, SenderID, (uint64_t)BytePtr, v10, &length[1], length, 0x20u);
    if (v11)
    {
      int v12 = v11;
      uint64_t v13 = _IOHIDLogCategory(9u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = *(void *)(a2 + 168);
        *(_DWORD *)buf = 136315650;
        uint64_t v20 = v16;
        __int16 v21 = 2048;
        uint64_t v22 = SenderID;
        __int16 v23 = 1024;
        int v24 = v12;
        _os_log_error_impl(&dword_18B46C000, v13, OS_LOG_TYPE_ERROR, "%s: HIDVS ID:%llx iohideventsystem_client_dispatch_virtual_service_copy_property:%x", buf, 0x1Cu);
      }
      __IOHIDEventSystemConnectionCheckServerStatus(v12, a2);
    }
    CFPropertyListRef v14 = _IOHIDUnserializeAndVMDealloc(*(UInt8 **)&length[1], length[0]);
  }
  CFRelease(v7);
  return v14;
}

uint64_t _IOHIDServiceGetSenderID(uint64_t a1)
{
  uint64_t valuePtr = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, &valuePtr);
  return valuePtr;
}

uint64_t iohideventsystem_client_dispatch_virtual_service_copy_property(mach_port_t a1, uint64_t a2, uint64_t a3, int a4, void *a5, _DWORD *a6, mach_msg_timeout_t a7)
{
  int v17 = 1;
  uint64_t v18 = a3;
  int v19 = 16777472;
  int v20 = a4;
  uint64_t v21 = *MEMORY[0x1E4F14068];
  uint64_t v22 = a2;
  int v23 = a4;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&v16.msgh_bits = 2147489043;
  v16.msgh_remote_port = a1;
  v16.msgh_local_port = special_reply_port;
  *(void *)&v16.msgh_voucher_port = 0x124FE00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v16);
    mach_port_t special_reply_port = v16.msgh_local_port;
  }
  uint64_t v12 = mach_msg(&v16, 3162515, 0x40u, 0x40u, special_reply_port, a7, 0);
  uint64_t v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!v12)
    {
      if (v16.msgh_id == 71)
      {
        uint64_t v13 = 4294966988;
      }
      else if (v16.msgh_id == 75106)
      {
        if ((v16.msgh_bits & 0x80000000) == 0)
        {
          if (v16.msgh_size == 36)
          {
            uint64_t v13 = 4294966996;
            if (HIDWORD(v18))
            {
              if (v16.msgh_remote_port) {
                uint64_t v13 = 4294966996;
              }
              else {
                uint64_t v13 = HIDWORD(v18);
              }
            }
          }
          else
          {
            uint64_t v13 = 4294966996;
          }
          goto LABEL_26;
        }
        uint64_t v13 = 4294966996;
        if (v17 == 1 && *(void *)&v16.msgh_size == 56 && HIBYTE(v19) == 1)
        {
          int v14 = v20;
          if (v20 == v22)
          {
            uint64_t v13 = 0;
            *a5 = v18;
            *a6 = v14;
            return v13;
          }
        }
      }
      else
      {
        uint64_t v13 = 4294966995;
      }
LABEL_26:
      mach_msg_destroy(&v16);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v13 - 268435459) <= 1)
  {
    if ((v16.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v16.msgh_local_port);
    }
    goto LABEL_26;
  }
  return v13;
}

BOOL __IOHIDServiceVirtualSetPropertyCallback(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t SenderID = _IOHIDServiceGetSenderID(a1);
  int v20 = 0;
  *(_OWORD *)keys = xmmword_1E548AE68;
  values[0] = a3;
  values[1] = a4;
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a2);
  CFDictionaryRef v9 = CFDictionaryCreate(v8, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDataRef v10 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9);
  CFDataRef v11 = v10;
  if (v10)
  {
    if (!*(_DWORD *)(a2 + 448))
    {
      mach_port_t v12 = *(_DWORD *)(a2 + 40);
      BytePtr = CFDataGetBytePtr(v10);
      int Length = CFDataGetLength(v11);
      int v15 = iohideventsystem_client_dispatch_virtual_service_set_property(v12, SenderID, (uint64_t)BytePtr, Length, &v20, 0x20u);
      if (v15)
      {
        int v16 = v15;
        int v17 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          uint64_t v18 = *(void *)(a2 + 168);
          *(_DWORD *)buf = 136315650;
          uint64_t v22 = v18;
          __int16 v23 = 2048;
          uint64_t v24 = SenderID;
          __int16 v25 = 1024;
          int v26 = v16;
          _os_log_impl(&dword_18B46C000, v17, OS_LOG_TYPE_INFO, "%s: HIDVS ID:%llx: iohideventsystem_client_dispatch_virtual_service_set_property:%x", buf, 0x1Cu);
        }
        __IOHIDEventSystemConnectionCheckServerStatus(v16, a2);
      }
    }
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v20 != 0;
}

uint64_t iohideventsystem_client_dispatch_virtual_service_set_property(mach_port_t a1, uint64_t a2, uint64_t a3, int a4, int *a5, mach_msg_timeout_t a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v15 = 1;
  uint64_t v16 = a3;
  int v17 = 16777472;
  int v18 = a4;
  uint64_t v19 = *MEMORY[0x1E4F14068];
  uint64_t v20 = a2;
  int v21 = a4;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x124FF00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v10 = mach_msg(&msg, 3162515, 0x40u, 0x30u, special_reply_port, a6, 0);
  uint64_t v11 = v10;
  if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
  {
    if (!v10)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v11 = 4294966988;
      }
      else if (msg.msgh_id == 75107)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              uint64_t v11 = HIDWORD(v16);
              if (!HIDWORD(v16))
              {
                *a5 = v17;
                return v11;
              }
              goto LABEL_25;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port) {
              BOOL v12 = 1;
            }
            else {
              BOOL v12 = HIDWORD(v16) == 0;
            }
            if (v12) {
              uint64_t v11 = 4294966996;
            }
            else {
              uint64_t v11 = HIDWORD(v16);
            }
            goto LABEL_25;
          }
        }
        uint64_t v11 = 4294966996;
      }
      else
      {
        uint64_t v11 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&msg);
      return v11;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v11 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    goto LABEL_25;
  }
  return v11;
}

uint64_t __SetNumPropertyForService(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int valuePtr = a3;
  CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
  CFNumberRef v8 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
  if (v8)
  {
    CFNumberRef v9 = v8;
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10 && (uint64_t v11 = *(uint64_t (**)(void))(*(void *)v10 + 56)) != 0)
    {
      unsigned __int8 v12 = v11();
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 24);
      if (v13)
      {
        int v14 = *(void (**)(void))(*(void *)v13 + 56);
        if (v14)
        {
          v14();
          unsigned __int8 v15 = 1;
LABEL_15:
          CFRelease(v9);
          return v15;
        }
      }
      uint64_t v16 = *(void *)(a1 + 360);
      if (v16 && (int v17 = *(uint64_t (**)(void, void, uint64_t, CFNumberRef))(v16 + 32)) != 0)
      {
        unsigned __int8 v12 = v17(*(void *)(a1 + 344), *(void *)(a1 + 352), a2, v9);
      }
      else
      {
        int v18 = *(void **)(a1 + 480);
        if (!v18)
        {
          unsigned __int8 v15 = 0;
          goto LABEL_15;
        }
        unsigned __int8 v12 = objc_msgSend(v18, *(SEL *)(a1 + 504), v9, a2, a4);
      }
    }
    unsigned __int8 v15 = v12;
    goto LABEL_15;
  }
  return 0;
}

uint64_t (*initrosetta_is_current_process_translated())()
{
  v0 = (void *)RosettaLibrary_libLibrary;
  if (!RosettaLibrary_libLibrary)
  {
    v0 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary = (uint64_t)v0;
  }
  uint64_t result = (uint64_t (*)())dlsym(v0, "rosetta_is_current_process_translated");
  dynLinkrosetta_is_current_process_translated[0] = result;
  if (result)
  {
    return (uint64_t (*)())result();
  }
  return result;
}

uint64_t (*initrosetta_is_current_process_translated_0())()
{
  v0 = (void *)RosettaLibrary_libLibrary_0;
  if (!RosettaLibrary_libLibrary_0)
  {
    v0 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_0 = (uint64_t)v0;
  }
  uint64_t result = (uint64_t (*)())dlsym(v0, "rosetta_is_current_process_translated");
  dynLinkrosetta_is_current_process_translated_0[0] = result;
  if (result)
  {
    return (uint64_t (*)())result();
  }
  return result;
}

uint64_t (*initrosetta_is_current_process_translated_1())()
{
  v0 = (void *)RosettaLibrary_libLibrary_1;
  if (!RosettaLibrary_libLibrary_1)
  {
    v0 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_1 = (uint64_t)v0;
  }
  uint64_t result = (uint64_t (*)())dlsym(v0, "rosetta_is_current_process_translated");
  dynLinkrosetta_is_current_process_translated_1 = result;
  if (result)
  {
    return (uint64_t (*)())result();
  }
  return result;
}

void *IOHIDEventGetDataValue(void *a1, unsigned int a2)
{
  return IOHIDEventGetDataValueWithOptions(a1, a2, 0);
}

uint64_t __PropertyChangedFunction(uint64_t result, uint64_t a2)
{
  if (*(void *)(a2 + 16) != result) {
    return _IOHIDEventSystemConnectionPropertyChanged(result, *(void **)a2, *(const void **)(a2 + 8));
  }
  return result;
}

uint64_t __IOHIDCFDictionaryFunctionApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

Boolean IODataQueueDataAvailable(IODataQueueMemory *dataQueue)
{
  if (dataQueue) {
    LOBYTE(dataQueue) = dataQueue->head != dataQueue->tail;
  }
  return dataQueue;
}

id IOHIDServiceFilterClientNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id result = *(id *)(a1 + 96);
  if (result)
  {
    CFAllocatorRef v7 = *(const char **)(a1 + 176);
    if (v7) {
      return objc_msgSend(result, v7, a2, a3);
    }
  }
  return result;
}

id IOHIDServiceFilterSetPropertyForClient(id result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *((void *)result + 2);
  if (v4)
  {
    unint64_t v5 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 96);
    if (v5) {
      return (id)v5(*((void *)result + 2), a2, a3, a4);
    }
  }
  if (*((void *)result + 12)) {
    return objc_msgSend(*((id *)result + 12), *((SEL *)result + 14), a3, a2, a4);
  }
  return result;
}

uint64_t __IOHIDServiceEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  unsigned int context = a4;
  uint64_t result = mach_absolute_time();
  uint64_t v7 = result;
  if (!a1) {
    goto LABEL_82;
  }
  valuePtr[0].__darwin_time_t tv_sec = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, valuePtr);
  __darwin_time_t tv_sec = valuePtr[0].tv_sec;
  TimeStampOfuint64_t Type = IOHIDEventGetTimeStampOfType((uint64_t)a4, 2);
  uint64_t Type = IOHIDEventGetType((uint64_t)a4);
  TimeStampuint64_t Type = IOHIDEventGetTimeStampType((uint64_t)a4);
  _IOHIDDebugTrace(8256, 0, TimeStampOfType, tv_sec, Type, TimeStampType);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v54, valuePtr);
  }
  uint64_t result = *(void *)(a1 + 72);
  int v12 = *(_DWORD *)result + 1;
  *(_DWORD *)uint64_t result = v12;
  if (*(unsigned char *)(a1 + 224))
  {
LABEL_78:
    if (!v12) {
      goto LABEL_82;
    }
    goto LABEL_81;
  }
  uint64_t v13 = *(void *)(a1 + 128);
  uint64_t v52 = *(void *)(a1 + 136);
  int v14 = *(void (**)(void, void, void, void, void))(a1 + 144);
  if (v14)
  {
    uint64_t v15 = mach_absolute_time();
    _IOHIDDebugEventAddPerfData(a4, 1, v15);
    if (*(_DWORD *)(a1 + 284)) {
      IOHIDEventSetIntegerValue(a4, 4u, 1);
    }
    if (IOHIDEventGetType((uint64_t)a4) == 1)
    {
      unsigned __int16 IntegerValue = IOHIDEventGetIntegerValue(a4, 0x10001u);
      uint64_t v53 = IntegerValue | ((unsigned __int16)IOHIDEventGetIntegerValue(a4, 0x10000u) << 16);
    }
    else
    {
      uint64_t v53 = 0;
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 2) && IOHIDEventGetEvent(a4, 2))
    {
      if (!IOHIDEventGetIntegerValue(a4, 0x20001u))
      {
        int v17 = IOHIDEventGetIntegerValue(a4, 0x20000u);
        unsigned int v18 = *(_DWORD *)(a1 + 156) ^ v17;
        if (v18)
        {
          uint64_t v19 = 1;
          while (((v18 >> (v19 - 1)) & 1) == 0)
          {
            if (++v19 == 32) {
              goto LABEL_24;
            }
          }
          IOHIDEventSetIntegerValue(a4, 0x20001u, v19);
        }
LABEL_24:
        *(_DWORD *)(a1 + 156) = v17;
      }
    }
    else if (*(_DWORD *)(a1 + 280))
    {
      if (IOHIDEventConformsTo((uint64_t)a4, 11))
      {
        Event = (void *)IOHIDEventGetEvent(a4, 11);
        if (Event)
        {
          int v21 = Event;
          if (!IOHIDEventGetIntegerValue(Event, 0xB0019u)) {
            IOHIDEventSetIntegerValue(v21, 0xB0019u, 1);
          }
        }
      }
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 3))
    {
      int v22 = IOHIDEventGetIntegerValue(a4, 0x30000u);
      LODWORD(valuePtr[0].tv_sec) = IOHIDEventGetIntegerValue(a4, 0x30001u);
      BYTE4(valuePtr[0].tv_sec) = v22;
      BYTE5(valuePtr[0].tv_sec) = BYTE1(v22);
      BYTE6(valuePtr[0].tv_sec) = BYTE2(v22);
      HIBYTE(valuePtr[0].tv_sec) = HIBYTE(v22);
      CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
      CFNumberRef v24 = CFNumberCreate(v23, kCFNumberSInt64Type, valuePtr);
      if (v24)
      {
        CFNumberRef v25 = v24;
        uint64_t v26 = IOHIDEventGetIntegerValue(a4, 0x30002u);
        unsigned int v27 = *(__CFSet **)(a1 + 264);
        if (v26) {
          CFSetAddValue(v27, v25);
        }
        else {
          CFSetRemoveValue(v27, v25);
        }
        CFRelease(v25);
      }
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 35)) {
      *(void *)(a1 + 272) |= 0x800000000uLL;
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 17)) {
      *(void *)(a1 + 272) |= 0x20000uLL;
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 2)) {
      *(void *)(a1 + 272) |= 4uLL;
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 6))
    {
      if (IOHIDEventGetScrollMomentum((uint64_t)a4) == 2) {
        *(_DWORD *)(a1 + 288) = 1;
      }
      if (IOHIDEventGetScrollMomentum((uint64_t)a4) == 4) {
        *(_DWORD *)(a1 + 288) = 0;
      }
    }
    if (IOHIDEventConformsTo((uint64_t)a4, 11))
    {
      __int16 v28 = IOHIDEventGetIntegerValue(a4, 0xB0007u);
      if ((v28 & 0x100) != 0) {
        *(_DWORD *)(a1 + 292) = 1;
      }
      if ((v28 & 0x88) != 0) {
        *(_DWORD *)(a1 + 292) = 0;
      }
    }
    if (!IOHIDEventGetSenderID((uint64_t)a4)) {
      IOHIDEventSetSenderID((uint64_t)a4, tv_sec);
    }
    uint64_t v29 = IOHIDEventGetTimeStampOfType((uint64_t)a4, 2);
    unsigned __int8 v30 = IOHIDEventGetTimeStampType((uint64_t)a4);
    *(void *)(a1 + 328) = IOHIDEventGetTimeStamp((uint64_t)a4);
    memset(valuePtr, 0, 32);
    LODWORD(valuePtr[0].tv_sec) = IOHIDEventGetType((uint64_t)a4);
    gettimeofday((timeval *)&valuePtr[0].tv_usec, 0);
    unsigned int v31 = valuePtr[0].tv_sec;
    if (LODWORD(valuePtr[0].tv_sec) == 1)
    {
      int v37 = IOHIDEventGetIntegerValue(a4, 0x10000u);
      unsigned __int16 v38 = IOHIDEventGetIntegerValue(a4, 0x10001u);
      unint64_t v39 = (v37 << 16) & 0xFFFFFFFFFFFF0000 | v38 | (IOHIDEventGetIntegerValue(a4, 0x10003u) << 32);
    }
    else
    {
      if (LODWORD(valuePtr[0].tv_sec) != 3) {
        goto LABEL_61;
      }
      long long v50 = v14;
      uint64_t v51 = v7;
      unsigned __int16 v32 = IOHIDEventGetIntegerValue(a4, 0x30000u);
      int v49 = IOHIDEventGetIntegerValue(a4, 0x30002u);
      int v33 = IOHIDEventGetIntegerValue(a4, 0x30005u);
      unsigned __int8 v34 = IOHIDEventGetIntegerValue(a4, 0x30004u);
      unsigned int Phase = IOHIDEventGetPhase((uint64_t)a4);
      if (v32 == 7)
      {
        unint64_t v36 = 0;
      }
      else
      {
        unsigned __int16 v40 = IOHIDEventGetIntegerValue(a4, 0x30001u);
        BOOL v41 = v40 == 46 || v32 == 12;
        unint64_t v36 = (unint64_t)v40 << 26;
        if (!v41) {
          unint64_t v36 = 0;
        }
      }
      unint64_t v39 = v49 | ((unint64_t)v32 << 42) | (2 * v33) | (4 * v34) | ((unint64_t)Phase << 10) | v36;
      int v14 = v50;
      uint64_t v7 = v51;
    }
    *(void *)&valuePtr[1].tv_usec = v39;
LABEL_61:
    CFDataRef v42 = *(const __CFData **)(a1 + 408);
    if (v42
      || (CFAllocatorRef v43 = CFGetAllocator((CFTypeRef)a1),
          CFDataRef v42 = _IOHIDSimpleQueueCreate(v43, 32, 50),
          (*(void *)(a1 + 408) = v42) != 0))
    {
      _IOHIDSimpleQueueEnqueue(v42, valuePtr, 1);
      unsigned int v31 = valuePtr[0].tv_sec;
    }
    ++*(void *)(*(void *)(a1 + 416) + 8 * v31);
    ++*(_DWORD *)(a1 + 228);
    *(void *)(a1 + 232) |= 1 << IOHIDEventGetType((uint64_t)a4);
    _IOHIDDebugTrace(8259, 1, v29, a1, v30, v53);
    CFArrayRef v44 = *(const __CFArray **)(a1 + 248);
    if (v44)
    {
      v58.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 248));
      v58.location = 0;
      CFArrayApplyFunction(v44, v58, (CFArrayApplierFunction)__FilterFunctionFilterEvent, &context);
    }
    _IOHIDDebugTrace(8259, 2, v29, a1, v30, v53);
    int v12 = **(_DWORD **)(a1 + 72);
  }
  if (v12)
  {
    int v45 = v12;
    do
    {
      uint64_t v46 = *(void *)(a1 + 72);
      if (*(_DWORD *)v46)
      {
        --*(_DWORD *)v46;
        if (pthread_mutex_unlock((pthread_mutex_t *)(v46 + 8))) {
          __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v54, valuePtr);
        }
      }
      --v45;
    }
    while (v45);
  }
  if (v14) {
    v14(v13, v52, a1, context, 0);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (v12)
  {
    do
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(result + 8))) {
        __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v54, valuePtr);
      }
      uint64_t result = *(void *)(a1 + 72);
      int v47 = *(_DWORD *)result + 1;
      *(_DWORD *)uint64_t result = v47;
      --v12;
    }
    while (v12);
    int v12 = v47;
    goto LABEL_78;
  }
  int v12 = *(_DWORD *)result;
  if (!*(_DWORD *)result) {
    goto LABEL_82;
  }
LABEL_81:
  *(_DWORD *)uint64_t result = v12 - 1;
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
  if (result) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v54, valuePtr);
  }
LABEL_82:
  if (*(void *)(a1 + 472))
  {
    uint64_t v48 = mach_absolute_time();
    _IOHIDGetTimestampDelta(v48, v7, 0x3E8u);
    return IOHIDAnalyticsHistogramEventSetIntegerValue();
  }
  return result;
}

uint64_t IOHIDEventConformsTo(uint64_t a1, char a2)
{
  return (*(void *)(a1 + 24) >> a2) & 1;
}

void __IOHIDEventSystemCompareServiceFunction(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *(const void **)(a3 + 16);
  if (v5
    && (CFTypeID v6 = CFGetTypeID(v5), v6 == IOHIDEventSystemConnectionGetTypeID())
    && (uint64_t v7 = *(void *)(a3 + 16)) != 0
    && (uint64_t UUID = IOHIDEventSystemConnectionGetUUID(*(void *)(a3 + 16)), _IOHIDServiceIsProtected((uint64_t)a2))
    && !IOHIDServiceCheckEntitlements((uint64_t)a2, v7))
  {
    uint64_t v11 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412546;
      uint64_t v13 = UUID;
      __int16 v14 = 2112;
      uint64_t RegistryID = IOHIDServiceGetRegistryID((uint64_t)a2);
      _os_log_impl(&dword_18B46C000, v11, OS_LOG_TYPE_DEFAULT, "Connection: %@ not entitled to match protected service: %@", (uint8_t *)&v12, 0x16u);
    }
  }
  else if (!_IOHIDServiceIsInactive((uint64_t)a2))
  {
    if (IOHIDServiceMatchPropertyTable((uint64_t)a2, *(const __CFDictionary **)(a3 + 8)))
    {
      Mutable = *(__CFArray **)a3;
      if (*(void *)a3
        || (CFAllocatorRef v10 = CFGetAllocator(a2),
            Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E4F1D510]),
            (*(void *)a3 = Mutable) != 0))
      {
        CFArrayAppendValue(Mutable, a2);
      }
    }
  }
}

void __EnqueueEventFunction(const void *a1, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v7 = 0;
    CFNumberRef v8 = &v7;
    uint64_t v9 = 0x2000000000;
    uint64_t v4 = *a2;
    uint64_t v10 = a2[1];
    CFArrayRef Filters = *(const __CFArray **)(a2[2] + 128);
    if (Filters) {
      CFArrayRef Filters = (const __CFArray *)IOHIDSessionGetFilters((uint64_t)Filters);
    }
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = ____EnqueueEventFunction_block_invoke;
    v6[3] = &unk_1E548A1A0;
    v6[4] = &v7;
    _OWORD v6[5] = a1;
    v6[6] = v4;
    _IOHIDCFArrayApplyBlock(Filters, v6);
    if (v8[3] && __IOHIDEventSystemIsTimeToDispatchEvent(a1, *a2, (void *)a2[1])) {
      _IOHIDEventSystemConnectionDispatchEvent((uint64_t)a1, (void *)a2[1]);
    }
  }
  else
  {
    uint64_t v7 = 0;
    CFNumberRef v8 = &v7;
    uint64_t v9 = 0x2000000000;
    uint64_t v10 = 0;
  }
  _Block_object_dispose(&v7, 8);
}

void _IOHIDCFArrayApplyBlock(const __CFArray *a1, void *a2)
{
  v4.length = CFArrayGetCount(a1);
  v4.location = 0;

  CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)__IOHIDCFArrayFunctionApplier, a2);
}

uint64_t __IOHIDEventSystemIsTimeToDispatchEvent(const void *a1, uint64_t a2, void *a3)
{
  if (a2 && _IOHIDServiceContainsReportInterval(a2))
  {
    CFTypeID v6 = _IOHIDServiceCopyConnectionCache(a2, a1);
    if (!v6 || !_IOHIDServiceContainsReportIntervalForClient(a2, a1, v6))
    {
      CFTypeID v14 = CFGetTypeID(a1);
      if (v14 == IOHIDEventSystemConnectionGetTypeID())
      {
        BOOL v12 = (int)IOHIDEventSystemConnectionGetType((uint64_t)a1) < 2;
        if (!v6) {
          return v12;
        }
      }
      else
      {
        BOOL v12 = 1;
        if (!v6) {
          return v12;
        }
      }
      goto LABEL_24;
    }
    if (!_IOHIDServiceSupportReportLatency(a2))
    {
      int Type = IOHIDEventGetType((uint64_t)a3);
      if (Type != 10 && (Type != 13 || IOHIDEventGetIntegerValue(a3, 0xD0003u) != 1))
      {
        unsigned int ReportIntervalForClient = _IOHIDServiceGetReportIntervalForClient(a2, a1, v6);
        unint64_t EventDeadlineForClient = _IOHIDServiceGetEventDeadlineForClient(a2, a1, (uint64_t)v6);
        unsigned int ReportInterval = _IOHIDServiceGetReportInterval(a2);
        unint64_t TimeStamp = IOHIDEventGetTimeStamp((uint64_t)a3);
        BOOL v12 = 0;
        if (!ReportIntervalForClient || !ReportInterval) {
          goto LABEL_24;
        }
        if (EventDeadlineForClient <= TimeStamp)
        {
          double v13 = *(double *)&__absoluteTime_to_nanoseconds_factor;
        }
        else if ((uint64_t)(EventDeadlineForClient - TimeStamp) < 0 {
               || (double v13 = *(double *)&__absoluteTime_to_nanoseconds_factor,
        }
                   (double)(1000 * (unint64_t)ReportInterval) * 0.5 <= (double)(unint64_t)((double)(uint64_t)(EventDeadlineForClient - TimeStamp) / *(double *)&__absoluteTime_to_nanoseconds_factor)))
        {
          BOOL v12 = 0;
LABEL_24:
          CFRelease(v6);
          return v12;
        }
        _IOHIDServiceSetEventDeadlineForClient(a2, a1, TimeStamp + (unint64_t)(v13 * (double)(1000 * (unint64_t)ReportIntervalForClient)), ReportIntervalForClient, v6);
      }
    }
    BOOL v12 = 1;
    goto LABEL_24;
  }
  return 1;
}

uint64_t IOHIDEventSystemConnectionGetTypeID()
{
  return MEMORY[0x1F41817D0](HIDConnection);
}

uint64_t IOHIDEventGetIntegerValue(void *a1, unsigned int a2)
{
  return IOHIDEventGetIntegerValueWithOptions(a1, a2, 4026531840);
}

uint64_t _IOHIDServiceContainsReportInterval(uint64_t a1)
{
  return *(unsigned int *)(a1 + 220);
}

uint64_t IOHIDSessionGetFilters(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

__n64 IOHIDEventGetFloatValueWithOptions(void *EventWithOptions, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = HIWORD(a2);
  if (!EventWithOptions || a2 >= 0x10000)
  {
    EventWithOptions = (void *)IOHIDEventGetEventWithOptions(EventWithOptions, HIWORD(a2), a3);
    if (!EventWithOptions)
    {
      result.n64_f64[0] = 0.0;
      return result;
    }
  }
  result.n64_f64[0] = 0.0;
  uint64_t v6 = EventWithOptions[13];
  switch(v4)
  {
    case 0u:
      switch(a2)
      {
        case 0u:
          LOBYTE(v6) = *(unsigned char *)(v6 + 8);
          goto LABEL_195;
        case 1u:
          unsigned int v13 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_204;
        case 2u:
          goto LABEL_21;
        case 3u:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 3) & 1;
          goto LABEL_205;
        case 4u:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 4) & 1;
          goto LABEL_205;
        case 5u:
          unsigned int v14 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_171;
        case 6u:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 6) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 1u:
      switch(a2)
      {
        case 0x10000u:
          goto LABEL_111;
        case 0x10001u:
          goto LABEL_114;
        case 0x10002u:
          goto LABEL_150;
        case 0x10003u:
          goto LABEL_83;
        default:
          return result;
      }
      return result;
    case 2u:
      switch(a2)
      {
        case 0x20000u:
          goto LABEL_131;
        case 0x20001u:
          goto LABEL_122;
        case 0x20002u:
          goto LABEL_123;
        case 0x20003u:
          goto LABEL_144;
        case 0x20004u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 3u:
      switch(a2)
      {
        case 0x30000u:
          goto LABEL_111;
        case 0x30001u:
          goto LABEL_114;
        case 0x30002u:
          goto LABEL_150;
        case 0x30003u:
          goto LABEL_160;
        case 0x30004u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 28);
          goto LABEL_151;
        case 0x30005u:
          LODWORD(v6) = *(_DWORD *)(v6 + 24);
          goto LABEL_195;
        case 0x30006u:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 1) & 3;
          goto LABEL_205;
        case 0x30007u:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 3) & 3;
          goto LABEL_205;
        case 0x30008u:
          unsigned int v14 = *(_DWORD *)(v6 + 24);
LABEL_171:
          unsigned int v7 = (v14 >> 5) & 1;
          goto LABEL_205;
        case 0x30009u:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 6) & 7;
          goto LABEL_205;
        case 0x3000Au:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 9) & 3;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 4u:
      if (a2 == 262146) {
        goto LABEL_137;
      }
      if (a2 == 262145) {
        goto LABEL_144;
      }
      if (a2 != 0x40000) {
        return result;
      }
      goto LABEL_98;
    case 5u:
      if (a2 == 327682) {
        goto LABEL_137;
      }
      if (a2 == 327681) {
        goto LABEL_144;
      }
      if (a2 != 327680) {
        return result;
      }
      goto LABEL_98;
    case 6u:
      switch(a2)
      {
        case 0x60000u:
          goto LABEL_98;
        case 0x60001u:
          goto LABEL_144;
        case 0x60002u:
          goto LABEL_137;
        case 0x60003u:
LABEL_21:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 2) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 7u:
      if (a2 == 458754) {
        goto LABEL_137;
      }
      if (a2 == 458753) {
        goto LABEL_144;
      }
      if (a2 != 458752) {
        return result;
      }
      goto LABEL_98;
    case 9u:
      if (a2 == 589826)
      {
LABEL_137:
        int v11 = *(_DWORD *)(v6 + 24);
        goto LABEL_145;
      }
      if (a2 == 589825) {
        goto LABEL_144;
      }
      if (a2 != 589824) {
        return result;
      }
      goto LABEL_98;
    case 0xAu:
      if (a2 - 655360 > 0xB) {
        return result;
      }
      if (a2 == 655363)
      {
LABEL_113:
        result.n64_u32[0] = *(_DWORD *)(v6 + 32);
        goto LABEL_151;
      }
      switch(*(_DWORD *)(v6 + 32))
      {
        case 0:
          switch(a2)
          {
            case 0xA0002u:
              goto LABEL_137;
            case 0xA0001u:
              goto LABEL_144;
            case 0xA0000u:
              goto LABEL_98;
          }
          break;
        case 1:
          if (a2 == 655364) {
            goto LABEL_131;
          }
          break;
        case 2:
          switch(a2)
          {
            case 0xA0007u:
              goto LABEL_137;
            case 0xA0006u:
              goto LABEL_144;
            case 0xA0005u:
              goto LABEL_98;
          }
          break;
        case 3:
          switch(a2)
          {
            case 0xA0008u:
              goto LABEL_98;
            case 0xA0009u:
              goto LABEL_144;
            case 0xA000Au:
              goto LABEL_137;
            case 0xA000Bu:
              goto LABEL_138;
            default:
              return result;
          }
        default:
          return result;
      }
      return result;
    case 0xBu:
      switch(a2)
      {
        case 0xB0000u:
          goto LABEL_98;
        case 0xB0001u:
          goto LABEL_144;
        case 0xB0002u:
          goto LABEL_137;
        case 0xB0003u:
          goto LABEL_161;
        case 0xB0004u:
          goto LABEL_113;
        case 0xB0005u:
          goto LABEL_107;
        case 0xB0006u:
          goto LABEL_116;
        case 0xB0007u:
          goto LABEL_162;
        case 0xB0008u:
LABEL_160:
          unsigned int v7 = HIWORD(*(_DWORD *)(v6 + 8)) & 1;
          goto LABEL_205;
        case 0xB0009u:
          unsigned int v7 = (*(_DWORD *)(v6 + 8) >> 17) & 1;
          goto LABEL_205;
        case 0xB000Au:
          goto LABEL_186;
        case 0xB000Bu:
          goto LABEL_187;
        case 0xB000Cu:
          goto LABEL_207;
        case 0xB000Du:
        case 0xB000Eu:
        case 0xB000Fu:
        case 0xB0010u:
        case 0xB0011u:
        case 0xB0012u:
        case 0xB0013u:
        case 0xB0014u:
        case 0xB0015u:
        case 0xB001Au:
          int v8 = *(_DWORD *)(v6 + 64);
          if (v8)
          {
            if (v8 == 2)
            {
              switch(a2)
              {
                case 0xB0011u:
                  goto LABEL_178;
                case 0xB0012u:
                  goto LABEL_179;
                case 0xB0013u:
                  goto LABEL_188;
                case 0xB0014u:
                  goto LABEL_189;
                case 0xB0015u:
LABEL_213:
                  int v11 = *(_DWORD *)(v6 + 84);
                  goto LABEL_145;
                case 0xB001Au:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            else if (v8 == 1)
            {
              switch(a2)
              {
                case 0xB000Fu:
                  goto LABEL_178;
                case 0xB0010u:
                  goto LABEL_179;
                case 0xB0011u:
                  goto LABEL_188;
                case 0xB0012u:
                  goto LABEL_189;
                case 0xB0014u:
                  goto LABEL_213;
                case 0xB0015u:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            return result;
          }
          if (a2 == 720910) {
            goto LABEL_179;
          }
          if (a2 != 720909) {
            return result;
          }
          goto LABEL_178;
        case 0xB0016u:
          unsigned int v13 = *(_DWORD *)(v6 + 8);
          goto LABEL_204;
        case 0xB0017u:
          if (!*(_DWORD *)(v6 + 32)) {
            goto LABEL_207;
          }
          return result;
        case 0xB0018u:
          goto LABEL_159;
        case 0xB0019u:
          unsigned int v7 = (*(_DWORD *)(v6 + 8) >> 19) & 1;
          goto LABEL_205;
        case 0xB001Bu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 92);
          goto LABEL_151;
        case 0xB001Cu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 96);
          goto LABEL_151;
        case 0xB001Du:
          result.n64_u32[0] = *(_DWORD *)(v6 + 100);
          goto LABEL_151;
        case 0xB001Fu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 64);
          goto LABEL_151;
        default:
          return result;
      }
    case 0xCu:
      switch(a2)
      {
        case 0xC0000u:
          goto LABEL_131;
        case 0xC0001u:
          goto LABEL_150;
        case 0xC0002u:
          goto LABEL_83;
        case 0xC0003u:
          goto LABEL_107;
        case 0xC0004u:
          goto LABEL_113;
        case 0xC0005u:
          int v9 = *(unsigned __int8 *)(v6 + 36);
          goto LABEL_164;
        case 0xC0006u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 37);
          goto LABEL_151;
        case 0xC0007u:
          goto LABEL_126;
        case 0xC0008u:
          goto LABEL_119;
        case 0xC0009u:
          goto LABEL_120;
        case 0xC000Au:
          goto LABEL_139;
        case 0xC000Bu:
          goto LABEL_140;
        default:
          return result;
      }
      return result;
    case 0xDu:
      switch(a2)
      {
        case 0xD0000u:
          goto LABEL_98;
        case 0xD0001u:
          goto LABEL_144;
        case 0xD0002u:
          goto LABEL_137;
        case 0xD0003u:
          goto LABEL_107;
        case 0xD0004u:
          goto LABEL_113;
        case 0xD0005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0xEu:
      switch(a2)
      {
        case 0xE0000u:
          goto LABEL_111;
        case 0xE0001u:
        case 0xE0003u:
          if (*(_WORD *)(v6 + 18) == 1)
          {
            int v10 = 917507;
            goto LABEL_103;
          }
          if (a2 != 917505 || *(_WORD *)(v6 + 18)) {
            return result;
          }
          goto LABEL_150;
        case 0xE0002u:
          goto LABEL_114;
        default:
          return result;
      }
    case 0xFu:
      if (a2 != 983040) {
        return result;
      }
      goto LABEL_98;
    case 0x10u:
      switch(a2)
      {
        case 0x100000u:
          goto LABEL_107;
        case 0x100001u:
          goto LABEL_72;
        case 0x100002u:
          goto LABEL_112;
        case 0x100003u:
          goto LABEL_98;
        case 0x100004u:
          goto LABEL_144;
        case 0x100005u:
          goto LABEL_115;
        case 0x100006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x11u:
      switch(a2)
      {
        case 0x110000u:
          goto LABEL_98;
        case 0x110001u:
          goto LABEL_144;
        case 0x110002u:
          goto LABEL_137;
        case 0x110003u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x12u:
      if (a2 == 1179649) {
        goto LABEL_144;
      }
      if (a2 != 1179648) {
        return result;
      }
      goto LABEL_131;
    case 0x13u:
      switch(a2)
      {
        case 0x130000u:
          goto LABEL_98;
        case 0x130001u:
          goto LABEL_144;
        case 0x130002u:
          goto LABEL_137;
        case 0x130003u:
          goto LABEL_91;
        case 0x130004u:
          goto LABEL_112;
        case 0x130005u:
          goto LABEL_153;
        case 0x130006u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x14u:
      switch(a2)
      {
        case 0x140000u:
          goto LABEL_98;
        case 0x140001u:
          goto LABEL_144;
        case 0x140002u:
          goto LABEL_137;
        case 0x140003u:
          goto LABEL_107;
        case 0x140004u:
          goto LABEL_113;
        case 0x140005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x15u:
      switch(a2)
      {
        case 0x150000u:
          goto LABEL_98;
        case 0x150001u:
          goto LABEL_144;
        case 0x150002u:
          goto LABEL_137;
        case 0x150003u:
          goto LABEL_107;
        case 0x150004u:
          goto LABEL_113;
        case 0x150005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x17u:
      switch(a2)
      {
        case 0x170000u:
          goto LABEL_107;
        case 0x170001u:
          goto LABEL_72;
        case 0x170002u:
          goto LABEL_112;
        case 0x170003u:
          goto LABEL_98;
        case 0x170004u:
          goto LABEL_144;
        case 0x170005u:
          goto LABEL_115;
        case 0x170006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x18u:
      if (a2 == 1572864) {
        goto LABEL_131;
      }
      if (a2 == 1572865)
      {
        unsigned int v7 = *(unsigned __int16 *)(v6 + 8) >> 15;
LABEL_205:
        result.n64_f64[0] = (double)v7;
      }
      return result;
    case 0x19u:
      if (a2 == 1638402)
      {
LABEL_107:
        result.n64_u32[0] = *(_DWORD *)(v6 + 28);
        goto LABEL_151;
      }
      if (a2 == 1638401)
      {
LABEL_83:
        result.n64_u32[0] = *(_DWORD *)(v6 + 24);
        goto LABEL_151;
      }
      if (a2 != 1638400) {
        return result;
      }
      goto LABEL_98;
    case 0x1Au:
      switch(a2)
      {
        case 0x1A0002u:
          goto LABEL_83;
        case 0x1A0001u:
LABEL_109:
          result.n64_u8[0] = *(unsigned char *)(v6 + 20);
          goto LABEL_151;
        case 0x1A0000u:
          goto LABEL_131;
      }
      return result;
    case 0x1Bu:
      switch(a2)
      {
        case 0x1B0000u:
          goto LABEL_107;
        case 0x1B0001u:
          goto LABEL_72;
        case 0x1B0002u:
          goto LABEL_112;
        case 0x1B0003u:
          goto LABEL_98;
        case 0x1B0004u:
          goto LABEL_144;
        case 0x1B0005u:
          goto LABEL_115;
        default:
          return result;
      }
      return result;
    case 0x1Cu:
      switch(a2)
      {
        case 0x1C0000u:
          goto LABEL_107;
        case 0x1C0001u:
LABEL_72:
          result.n64_u16[0] = *(_WORD *)(v6 + 32);
          goto LABEL_151;
        case 0x1C0002u:
          goto LABEL_112;
        case 0x1C0003u:
          goto LABEL_98;
        case 0x1C0004u:
          goto LABEL_144;
        case 0x1C0005u:
LABEL_115:
          result.n64_u16[0] = *(_WORD *)(v6 + 34);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Du:
      switch(a2)
      {
        case 0x1D0000u:
          goto LABEL_131;
        case 0x1D0001u:
          goto LABEL_144;
        case 0x1D0002u:
          result.n64_u16[0] = *(_WORD *)(v6 + 24);
          goto LABEL_151;
        case 0x1D0003u:
          result.n64_u16[0] = *(_WORD *)(v6 + 26);
          goto LABEL_151;
        case 0x1D0004u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 32);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Eu:
      if (a2 == 1966082) {
        goto LABEL_83;
      }
      if (a2 == 1966081) {
        goto LABEL_144;
      }
      if (a2 != 1966080) {
        return result;
      }
      goto LABEL_131;
    case 0x1Fu:
      if (a2 == 2031617) {
        goto LABEL_150;
      }
      if (a2 != 2031616) {
        return result;
      }
      goto LABEL_98;
    case 0x20u:
      switch(a2)
      {
        case 0x200000u:
          goto LABEL_131;
        case 0x200001u:
          goto LABEL_144;
        case 0x200002u:
          goto LABEL_83;
        case 0x200003u:
          goto LABEL_138;
        default:
          return result;
      }
      return result;
    case 0x21u:
      if (a2 == 2162689) {
        goto LABEL_144;
      }
      if (a2 != 2162688) {
        return result;
      }
      goto LABEL_131;
    case 0x22u:
      if (a2 == 2228225) {
        goto LABEL_144;
      }
      if (a2 != 2228224) {
        return result;
      }
      goto LABEL_131;
    case 0x23u:
      switch(a2)
      {
        case 0x230000u:
          goto LABEL_131;
        case 0x230001u:
          goto LABEL_144;
        case 0x230002u:
          goto LABEL_137;
        case 0x230003u:
LABEL_138:
          int v11 = *(_DWORD *)(v6 + 28);
          goto LABEL_145;
        case 0x230004u:
LABEL_91:
          int v11 = *(_DWORD *)(v6 + 32);
          goto LABEL_145;
        case 0x230005u:
          int v11 = *(_DWORD *)(v6 + 44);
          goto LABEL_145;
        case 0x230006u:
          int v11 = *(_DWORD *)(v6 + 48);
          goto LABEL_145;
        case 0x230007u:
LABEL_112:
          int v11 = *(_DWORD *)(v6 + 36);
          goto LABEL_145;
        case 0x230008u:
LABEL_153:
          int v11 = *(_DWORD *)(v6 + 40);
          goto LABEL_145;
        case 0x230009u:
LABEL_178:
          int v11 = *(_DWORD *)(v6 + 68);
          goto LABEL_145;
        case 0x23000Au:
LABEL_188:
          int v11 = *(_DWORD *)(v6 + 76);
          goto LABEL_145;
        case 0x23000Bu:
LABEL_179:
          int v11 = *(_DWORD *)(v6 + 72);
          goto LABEL_145;
        case 0x23000Cu:
LABEL_189:
          int v11 = *(_DWORD *)(v6 + 80);
          goto LABEL_145;
        case 0x23000Du:
LABEL_186:
          int v11 = *(_DWORD *)(v6 + 52);
          goto LABEL_145;
        case 0x23000Eu:
LABEL_187:
          int v11 = *(_DWORD *)(v6 + 56);
          goto LABEL_145;
        case 0x23000Fu:
LABEL_207:
          int v11 = *(_DWORD *)(v6 + 60);
          goto LABEL_145;
        case 0x230010u:
          int v11 = *(_DWORD *)(v6 + 64);
          goto LABEL_145;
        case 0x230011u:
          LOBYTE(v6) = *(unsigned char *)(v6 + 84);
LABEL_195:
          unsigned int v7 = v6 & 1;
          goto LABEL_205;
        case 0x230012u:
          unsigned int v13 = *(unsigned __int8 *)(v6 + 84);
LABEL_204:
          unsigned int v7 = (v13 >> 1) & 1;
          goto LABEL_205;
        case 0x230013u:
LABEL_190:
          int v11 = *(_DWORD *)(v6 + 88);
          goto LABEL_145;
        case 0x230014u:
          int v11 = *(_DWORD *)(v6 + 92);
          goto LABEL_145;
        case 0x230015u:
          int v11 = *(_DWORD *)(v6 + 96);
          goto LABEL_145;
        case 0x230016u:
          int v11 = *(_DWORD *)(v6 + 100);
          goto LABEL_145;
        case 0x230017u:
          int v11 = *(_DWORD *)(v6 + 104);
          goto LABEL_145;
        case 0x230018u:
          int v11 = *(_DWORD *)(v6 + 108);
          goto LABEL_145;
        default:
          return result;
      }
      return result;
    case 0x24u:
      if (a2 == 2359297) {
        goto LABEL_150;
      }
      if (a2 != 2359296) {
        return result;
      }
      goto LABEL_98;
    case 0x26u:
      switch(a2)
      {
        case 0x260002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          goto LABEL_151;
        case 0x260001u:
          goto LABEL_144;
        case 0x260000u:
LABEL_98:
          int v11 = *(_DWORD *)(v6 + 16);
          goto LABEL_145;
      }
      return result;
    case 0x27u:
      if (a2 - 2555905 >= 2)
      {
        if (a2 != 2555904) {
          return result;
        }
LABEL_131:
        result.n64_u32[0] = *(_DWORD *)(v6 + 16);
        goto LABEL_151;
      }
      int v12 = *(_DWORD *)(v6 + 16);
      if (v12 != 1)
      {
        if (v12)
        {
          if (a2 != 2555905 || v12 != 2) {
            return result;
          }
        }
        else
        {
          int v10 = 2555905;
LABEL_103:
          if (a2 != v10) {
            return result;
          }
        }
LABEL_150:
        result.n64_u32[0] = *(_DWORD *)(v6 + 20);
LABEL_151:
        result.n64_f64[0] = (double)result.n64_u64[0];
        return result;
      }
      if (a2 == 2555906)
      {
LABEL_144:
        int v11 = *(_DWORD *)(v6 + 20);
LABEL_145:
        result.n64_f64[0] = (double)v11 * 0.0000152587891;
        if (v11 == 0x80000000) {
          result.n64_f64[0] = NAN;
        }
      }
      return result;
    case 0x28u:
      switch(a2)
      {
        case 0x280000u:
          result.n64_u16[0] = *(_WORD *)(v6 + 64);
          goto LABEL_151;
        case 0x280001u:
          result.n64_u16[0] = *(_WORD *)(v6 + 66);
          goto LABEL_151;
        case 0x280002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 16);
          break;
        case 0x280003u:
LABEL_122:
          result.n64_u8[0] = *(unsigned char *)(v6 + 24);
          goto LABEL_151;
        case 0x280004u:
LABEL_123:
          result.n64_u8[0] = *(unsigned char *)(v6 + 25);
          goto LABEL_151;
        case 0x280005u:
          goto LABEL_107;
        case 0x280006u:
          goto LABEL_113;
        case 0x280007u:
LABEL_116:
          result.n64_u32[0] = *(_DWORD *)(v6 + 36);
          goto LABEL_151;
        case 0x280008u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 44);
          goto LABEL_151;
        case 0x280009u:
LABEL_161:
          result.n64_u32[0] = *(_DWORD *)(v6 + 48);
          goto LABEL_151;
        case 0x28000Au:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          goto LABEL_151;
        case 0x28000Bu:
          result.n64_u8[0] = *(unsigned char *)(v6 + 26);
          goto LABEL_151;
        case 0x28000Cu:
LABEL_162:
          result.n64_u32[0] = *(_DWORD *)(v6 + 40);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x29u:
      switch(a2)
      {
        case 0x290000u:
          goto LABEL_131;
        case 0x290001u:
          goto LABEL_109;
        case 0x290002u:
          goto LABEL_124;
        case 0x290003u:
          goto LABEL_125;
        case 0x290004u:
LABEL_126:
          result.n64_u64[0] = *(unint64_t *)(v6 + 40);
          break;
        case 0x290005u:
          goto LABEL_119;
        case 0x290006u:
          goto LABEL_120;
        default:
          return result;
      }
      return result;
    case 0x2Au:
      switch(a2)
      {
        case 0x2A0000u:
LABEL_111:
          result.n64_u16[0] = *(_WORD *)(v6 + 16);
          goto LABEL_151;
        case 0x2A0001u:
LABEL_114:
          result.n64_u16[0] = *(_WORD *)(v6 + 18);
          goto LABEL_151;
        case 0x2A0002u:
LABEL_124:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          break;
        case 0x2A0003u:
LABEL_125:
          result.n64_u64[0] = *(unint64_t *)(v6 + 32);
          break;
        case 0x2A0004u:
          int v9 = *(unsigned __int8 *)(v6 + 40);
LABEL_164:
          if (v9) {
            result.n64_f64[0] = 1.0;
          }
          break;
        case 0x2A0005u:
LABEL_159:
          result.n64_u32[0] = *(_DWORD *)(v6 + 44);
          goto LABEL_151;
        case 0x2A0006u:
LABEL_119:
          result.n64_u64[0] = *(unint64_t *)(v6 + 48);
          break;
        case 0x2A0007u:
LABEL_120:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          break;
        case 0x2A0008u:
LABEL_139:
          result.n64_u64[0] = *(unint64_t *)(v6 + 64);
          break;
        case 0x2A0009u:
LABEL_140:
          result.n64_u64[0] = *(unint64_t *)(v6 + 72);
          break;
        default:
          return result;
      }
      return result;
    default:
      return result;
  }
}

uint64_t IOHIDEventGetIntegerValueWithOptions(void *a1, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = a1;
  unsigned int v5 = HIWORD(a2);
  if (a1 && a2 < 0x10000
    || (result = IOHIDEventGetEventWithOptions(a1, HIWORD(a2), a3), (unsigned int v4 = (void *)result) != 0))
  {
    uint64_t result = 0;
    uint64_t v7 = v4[13];
    switch(v5)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            LOBYTE(v7) = *(unsigned char *)(v7 + 8);
            goto LABEL_189;
          case 1u:
            unint64_t v13 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_198;
          case 2u:
            goto LABEL_20;
          case 3u:
            uint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 3) & 1;
            break;
          case 4u:
            uint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 4) & 1;
            break;
          case 5u:
            unint64_t v14 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_164;
          case 6u:
            uint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 6) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x10001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x10002u:
            return *(unsigned int *)(v7 + 20);
          case 0x10003u:
            return *(unsigned int *)(v7 + 24);
          case 0x10004u:
            goto LABEL_75;
          default:
            return 0;
        }
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            return *(unsigned int *)(v7 + 16);
          case 0x20001u:
            goto LABEL_120;
          case 0x20002u:
            goto LABEL_121;
          case 0x20003u:
            goto LABEL_142;
          case 0x20004u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x30001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x30002u:
            return *(unsigned int *)(v7 + 20);
          case 0x30003u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0x30004u:
            uint64_t result = *(unsigned __int8 *)(v7 + 28);
            break;
          case 0x30005u:
            LODWORD(v7) = *(_DWORD *)(v7 + 24);
            goto LABEL_189;
          case 0x30006u:
            uint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 1) & 3;
            break;
          case 0x30007u:
            uint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 3) & 3;
            break;
          case 0x30008u:
            unint64_t v14 = *(unsigned int *)(v7 + 24);
LABEL_164:
            uint64_t result = (v14 >> 5) & 1;
            break;
          case 0x30009u:
            uint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 6) & 7;
            break;
          case 0x3000Au:
            uint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 9) & 3;
            break;
          default:
            return 0;
        }
        return result;
      case 4u:
        if (a2 == 262146) {
          goto LABEL_135;
        }
        if (a2 == 262145) {
          goto LABEL_142;
        }
        if (a2 != 0x40000) {
          return 0;
        }
        goto LABEL_96;
      case 5u:
        if (a2 == 327682) {
          goto LABEL_135;
        }
        if (a2 == 327681) {
          goto LABEL_142;
        }
        if (a2 != 327680) {
          return 0;
        }
        goto LABEL_96;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_96;
          case 0x60001u:
            goto LABEL_142;
          case 0x60002u:
            goto LABEL_135;
          case 0x60003u:
LABEL_20:
            uint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 2) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 7u:
        if (a2 == 458754) {
          goto LABEL_135;
        }
        if (a2 == 458753) {
          goto LABEL_142;
        }
        if (a2 != 458752) {
          return 0;
        }
        goto LABEL_96;
      case 9u:
        if (a2 == 589826)
        {
LABEL_135:
          int v10 = *(_DWORD *)(v7 + 24);
          goto LABEL_143;
        }
        if (a2 == 589825) {
          goto LABEL_142;
        }
        if (a2 != 589824) {
          return 0;
        }
        goto LABEL_96;
      case 0xAu:
        if (a2 - 655360 > 0xB) {
          return 0;
        }
        if (a2 != 655363)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              if (a2 == 655362) {
                goto LABEL_135;
              }
              if (a2 == 655361) {
                goto LABEL_142;
              }
              if (a2 != 655360) {
                return 0;
              }
              goto LABEL_96;
            case 1:
              if (a2 == 655364) {
                return *(unsigned int *)(v7 + 16);
              }
              return 0;
            case 2:
              if (a2 == 655367) {
                goto LABEL_135;
              }
              if (a2 == 655366) {
                goto LABEL_142;
              }
              if (a2 != 655365) {
                return 0;
              }
              goto LABEL_96;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_96;
                case 0xA0009u:
                  goto LABEL_142;
                case 0xA000Au:
                  goto LABEL_135;
                case 0xA000Bu:
                  goto LABEL_136;
                default:
                  return 0;
              }
            default:
              return 0;
          }
        }
        return *(unsigned int *)(v7 + 32);
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_96;
          case 0xB0001u:
            goto LABEL_142;
          case 0xB0002u:
            goto LABEL_135;
          case 0xB0003u:
            goto LABEL_157;
          case 0xB0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xB0005u:
            return *(unsigned int *)(v7 + 28);
          case 0xB0006u:
            goto LABEL_114;
          case 0xB0007u:
            goto LABEL_158;
          case 0xB0008u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0xB0009u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 17) & 1;
          case 0xB000Au:
            goto LABEL_180;
          case 0xB000Bu:
            goto LABEL_181;
          case 0xB000Cu:
            goto LABEL_202;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            int v8 = *(_DWORD *)(v7 + 64);
            if (v8)
            {
              if (v8 == 2)
              {
                uint64_t result = 0;
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_171;
                  case 0xB0012u:
                    goto LABEL_172;
                  case 0xB0013u:
                    goto LABEL_182;
                  case 0xB0014u:
                    goto LABEL_183;
                  case 0xB0015u:
LABEL_209:
                    int v10 = *(_DWORD *)(v7 + 84);
                    goto LABEL_143;
                  case 0xB001Au:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              else
              {
                if (v8 != 1) {
                  return 0;
                }
                uint64_t result = 0;
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_171;
                  case 0xB0010u:
                    goto LABEL_172;
                  case 0xB0011u:
                    goto LABEL_182;
                  case 0xB0012u:
                    goto LABEL_183;
                  case 0xB0014u:
                    goto LABEL_209;
                  case 0xB0015u:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910) {
              goto LABEL_172;
            }
            if (a2 != 720909) {
              return 0;
            }
            goto LABEL_171;
          case 0xB0016u:
            unint64_t v13 = *(unsigned int *)(v7 + 8);
            goto LABEL_198;
          case 0xB0017u:
            if (*(_DWORD *)(v7 + 32)) {
              return 0;
            }
            goto LABEL_202;
          case 0xB0018u:
            return *(unsigned int *)(v7 + 44);
          case 0xB0019u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 19) & 1;
          case 0xB001Bu:
            return *(unsigned int *)(v7 + 92);
          case 0xB001Cu:
            return *(unsigned int *)(v7 + 96);
          case 0xB001Du:
            return *(unsigned int *)(v7 + 100);
          case 0xB001Eu:
            return (*(_DWORD *)(v7 + 40) >> 13) & 0x18000 | (*(_DWORD *)(v7 + 40) >> 20) & 0x400u | (*(_DWORD *)(v7 + 40) >> 31 << 23);
          case 0xB001Fu:
            return *(unsigned int *)(v7 + 64);
          default:
            return 0;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            return *(unsigned int *)(v7 + 16);
          case 0xC0001u:
            return *(unsigned int *)(v7 + 20);
          case 0xC0002u:
            return *(unsigned int *)(v7 + 24);
          case 0xC0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xC0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xC0005u:
            uint64_t result = *(unsigned __int8 *)(v7 + 36);
            break;
          case 0xC0006u:
            uint64_t result = *(unsigned __int8 *)(v7 + 37);
            break;
          case 0xC0007u:
            goto LABEL_124;
          case 0xC0008u:
            goto LABEL_117;
          case 0xC0009u:
            goto LABEL_118;
          case 0xC000Au:
            goto LABEL_137;
          case 0xC000Bu:
            goto LABEL_138;
          default:
            return 0;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_96;
          case 0xD0001u:
            goto LABEL_142;
          case 0xD0002u:
            goto LABEL_135;
          case 0xD0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xD0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xD0005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              int v9 = 917507;
              goto LABEL_101;
            }
            uint64_t result = 0;
            if (a2 != 917505 || *(_WORD *)(v7 + 18)) {
              return result;
            }
            return *(unsigned int *)(v7 + 20);
          case 0xE0002u:
            return *(unsigned __int16 *)(v7 + 18);
          default:
            return 0;
        }
      case 0xFu:
        if (a2 != 983040) {
          return 0;
        }
        goto LABEL_96;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            return *(unsigned int *)(v7 + 28);
          case 0x100001u:
            goto LABEL_71;
          case 0x100002u:
            goto LABEL_110;
          case 0x100003u:
            goto LABEL_96;
          case 0x100004u:
            goto LABEL_142;
          case 0x100005u:
            goto LABEL_113;
          case 0x100006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_96;
          case 0x110001u:
            goto LABEL_142;
          case 0x110002u:
            goto LABEL_135;
          case 0x110003u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x12u:
        if (a2 == 1179649) {
          goto LABEL_142;
        }
        if (a2 != 1179648) {
          return 0;
        }
        return *(unsigned int *)(v7 + 16);
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_96;
          case 0x130001u:
            goto LABEL_142;
          case 0x130002u:
            goto LABEL_135;
          case 0x130003u:
            goto LABEL_89;
          case 0x130004u:
            goto LABEL_110;
          case 0x130005u:
            goto LABEL_149;
          case 0x130006u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_96;
          case 0x140001u:
            goto LABEL_142;
          case 0x140002u:
            goto LABEL_135;
          case 0x140003u:
            return *(unsigned int *)(v7 + 28);
          case 0x140004u:
            return *(unsigned int *)(v7 + 32);
          case 0x140005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_96;
          case 0x150001u:
            goto LABEL_142;
          case 0x150002u:
            goto LABEL_135;
          case 0x150003u:
            return *(unsigned int *)(v7 + 28);
          case 0x150004u:
            return *(unsigned int *)(v7 + 32);
          case 0x150005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            return *(unsigned int *)(v7 + 28);
          case 0x170001u:
            goto LABEL_71;
          case 0x170002u:
            goto LABEL_110;
          case 0x170003u:
            goto LABEL_96;
          case 0x170004u:
            goto LABEL_142;
          case 0x170005u:
            goto LABEL_113;
          case 0x170006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x18u:
        if (a2 == 1572864) {
          return *(unsigned int *)(v7 + 16);
        }
        if (a2 != 1572865) {
          return 0;
        }
        return (unint64_t)*(unsigned __int16 *)(v7 + 8) >> 15;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
            return *(unsigned int *)(v7 + 28);
          case 0x190001u:
            return *(unsigned int *)(v7 + 24);
          case 0x190000u:
            goto LABEL_96;
        }
        return 0;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1A0001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x1A0000u:
            return *(unsigned int *)(v7 + 16);
        }
        return 0;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1B0001u:
            goto LABEL_71;
          case 0x1B0002u:
            goto LABEL_110;
          case 0x1B0003u:
            goto LABEL_96;
          case 0x1B0004u:
            goto LABEL_142;
          case 0x1B0005u:
            goto LABEL_113;
          default:
            return 0;
        }
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1C0001u:
LABEL_71:
            uint64_t result = *(unsigned __int16 *)(v7 + 32);
            break;
          case 0x1C0002u:
            goto LABEL_110;
          case 0x1C0003u:
            goto LABEL_96;
          case 0x1C0004u:
            goto LABEL_142;
          case 0x1C0005u:
LABEL_113:
            uint64_t result = *(unsigned __int16 *)(v7 + 34);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1D0001u:
            goto LABEL_142;
          case 0x1D0002u:
            uint64_t result = *(unsigned __int16 *)(v7 + 24);
            break;
          case 0x1D0003u:
            uint64_t result = *(unsigned __int16 *)(v7 + 26);
            break;
          case 0x1D0004u:
            uint64_t result = *(unsigned __int8 *)(v7 + 32);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1E0001u:
            goto LABEL_142;
          case 0x1E0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1E0003u:
LABEL_75:
            if (*(_DWORD *)(v7 + 24) < 8u) {
              return 0;
            }
            uint64_t result = *(void *)(v7 + 28);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617) {
          return *(unsigned int *)(v7 + 20);
        }
        if (a2 != 2031616) {
          return 0;
        }
        goto LABEL_96;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            return *(unsigned int *)(v7 + 16);
          case 0x200001u:
            goto LABEL_142;
          case 0x200002u:
            return *(unsigned int *)(v7 + 24);
          case 0x200003u:
            goto LABEL_136;
          default:
            return 0;
        }
      case 0x21u:
        if (a2 == 2162689) {
          goto LABEL_142;
        }
        if (a2 != 2162688) {
          return 0;
        }
        return *(unsigned int *)(v7 + 16);
      case 0x22u:
        if (a2 == 2228225) {
          goto LABEL_142;
        }
        if (a2 != 2228224) {
          return 0;
        }
        return *(unsigned int *)(v7 + 16);
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            return *(unsigned int *)(v7 + 16);
          case 0x230001u:
            goto LABEL_142;
          case 0x230002u:
            goto LABEL_135;
          case 0x230003u:
LABEL_136:
            int v10 = *(_DWORD *)(v7 + 28);
            goto LABEL_143;
          case 0x230004u:
LABEL_89:
            int v10 = *(_DWORD *)(v7 + 32);
            goto LABEL_143;
          case 0x230005u:
            int v10 = *(_DWORD *)(v7 + 44);
            goto LABEL_143;
          case 0x230006u:
            int v10 = *(_DWORD *)(v7 + 48);
            goto LABEL_143;
          case 0x230007u:
LABEL_110:
            int v10 = *(_DWORD *)(v7 + 36);
            goto LABEL_143;
          case 0x230008u:
LABEL_149:
            int v10 = *(_DWORD *)(v7 + 40);
            goto LABEL_143;
          case 0x230009u:
LABEL_171:
            int v10 = *(_DWORD *)(v7 + 68);
            goto LABEL_143;
          case 0x23000Au:
LABEL_182:
            int v10 = *(_DWORD *)(v7 + 76);
            goto LABEL_143;
          case 0x23000Bu:
LABEL_172:
            int v10 = *(_DWORD *)(v7 + 72);
            goto LABEL_143;
          case 0x23000Cu:
LABEL_183:
            int v10 = *(_DWORD *)(v7 + 80);
            goto LABEL_143;
          case 0x23000Du:
LABEL_180:
            int v10 = *(_DWORD *)(v7 + 52);
            goto LABEL_143;
          case 0x23000Eu:
LABEL_181:
            int v10 = *(_DWORD *)(v7 + 56);
            goto LABEL_143;
          case 0x23000Fu:
LABEL_202:
            int v10 = *(_DWORD *)(v7 + 60);
            goto LABEL_143;
          case 0x230010u:
            int v10 = *(_DWORD *)(v7 + 64);
            goto LABEL_143;
          case 0x230011u:
            LOBYTE(v7) = *(unsigned char *)(v7 + 84);
LABEL_189:
            uint64_t result = v7 & 1;
            break;
          case 0x230012u:
            unint64_t v13 = *(unsigned __int8 *)(v7 + 84);
LABEL_198:
            uint64_t result = (v13 >> 1) & 1;
            break;
          case 0x230013u:
LABEL_184:
            int v10 = *(_DWORD *)(v7 + 88);
            goto LABEL_143;
          case 0x230014u:
            int v10 = *(_DWORD *)(v7 + 92);
            goto LABEL_143;
          case 0x230015u:
            int v10 = *(_DWORD *)(v7 + 96);
            goto LABEL_143;
          case 0x230016u:
            int v10 = *(_DWORD *)(v7 + 100);
            goto LABEL_143;
          case 0x230017u:
            int v10 = *(_DWORD *)(v7 + 104);
            goto LABEL_143;
          case 0x230018u:
            int v10 = *(_DWORD *)(v7 + 108);
            goto LABEL_143;
          default:
            return 0;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297) {
          return *(unsigned int *)(v7 + 20);
        }
        if (a2 != 2359296) {
          return 0;
        }
        goto LABEL_96;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            return *(void *)(v7 + 24);
          case 0x260001u:
            goto LABEL_142;
          case 0x260000u:
LABEL_96:
            int v10 = *(_DWORD *)(v7 + 16);
            goto LABEL_143;
        }
        return 0;
      case 0x27u:
        if (a2 - 2555905 >= 2)
        {
          if (a2 == 2555904) {
            return *(unsigned int *)(v7 + 16);
          }
          return 0;
        }
        int v11 = *(_DWORD *)(v7 + 16);
        if (v11 == 1)
        {
          if (a2 != 2555906) {
            return 0;
          }
LABEL_142:
          int v10 = *(_DWORD *)(v7 + 20);
LABEL_143:
          if (v10 == 0x80000000) {
            uint64_t result = 0xFFFFFFFF80000000;
          }
          else {
            uint64_t result = (uint64_t)(v10 + (v10 < 0 ? 0xFFFF : 0)) >> 16;
          }
        }
        else
        {
          if (!v11)
          {
            int v9 = 2555905;
LABEL_101:
            if (a2 != v9) {
              return 0;
            }
            return *(unsigned int *)(v7 + 20);
          }
          uint64_t result = 0;
          if (a2 == 2555905 && v11 == 2) {
            return *(unsigned int *)(v7 + 20);
          }
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            uint64_t result = *(unsigned __int16 *)(v7 + 64);
            break;
          case 0x280001u:
            uint64_t result = *(unsigned __int16 *)(v7 + 66);
            break;
          case 0x280002u:
            double v12 = *(double *)(v7 + 16);
            goto LABEL_176;
          case 0x280003u:
LABEL_120:
            uint64_t result = *(unsigned __int8 *)(v7 + 24);
            break;
          case 0x280004u:
LABEL_121:
            uint64_t result = *(unsigned __int8 *)(v7 + 25);
            break;
          case 0x280005u:
            return *(unsigned int *)(v7 + 28);
          case 0x280006u:
            return *(unsigned int *)(v7 + 32);
          case 0x280007u:
LABEL_114:
            uint64_t result = *(unsigned int *)(v7 + 36);
            break;
          case 0x280008u:
            uint64_t result = *(unsigned __int8 *)(v7 + 44);
            break;
          case 0x280009u:
LABEL_157:
            uint64_t result = *(unsigned int *)(v7 + 48);
            break;
          case 0x28000Au:
            uint64_t result = *(void *)(v7 + 56);
            break;
          case 0x28000Bu:
            uint64_t result = *(unsigned __int8 *)(v7 + 26);
            break;
          case 0x28000Cu:
LABEL_158:
            uint64_t result = *(unsigned int *)(v7 + 40);
            break;
          default:
            return 0;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            return *(unsigned int *)(v7 + 16);
          case 0x290001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x290002u:
            goto LABEL_122;
          case 0x290003u:
            goto LABEL_123;
          case 0x290004u:
LABEL_124:
            double v12 = *(double *)(v7 + 40);
            goto LABEL_176;
          case 0x290005u:
            goto LABEL_117;
          case 0x290006u:
            goto LABEL_118;
          default:
            return 0;
        }
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x2A0001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x2A0002u:
LABEL_122:
            double v12 = *(double *)(v7 + 24);
            goto LABEL_176;
          case 0x2A0003u:
LABEL_123:
            double v12 = *(double *)(v7 + 32);
            goto LABEL_176;
          case 0x2A0004u:
            return *(unsigned __int8 *)(v7 + 40);
          case 0x2A0005u:
            return *(unsigned int *)(v7 + 44);
          case 0x2A0006u:
LABEL_117:
            double v12 = *(double *)(v7 + 48);
            goto LABEL_176;
          case 0x2A0007u:
LABEL_118:
            double v12 = *(double *)(v7 + 56);
            goto LABEL_176;
          case 0x2A0008u:
LABEL_137:
            double v12 = *(double *)(v7 + 64);
            goto LABEL_176;
          case 0x2A0009u:
LABEL_138:
            double v12 = *(double *)(v7 + 72);
LABEL_176:
            uint64_t result = (uint64_t)v12;
            break;
          default:
            return 0;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

uint64_t IOHIDEventGetEventWithOptions(void *a1, uint64_t a2, uint64_t a3)
{
  CFNumberRef v3 = a1;
  if (*(_DWORD *)(a1[13] + 4) != a2)
  {
    if (((a1[3] >> a2) & 1) != 0 && (CFArrayRef v5 = (const __CFArray *)a1[9]) != 0 && (Count = CFArrayGetCount(v5), Count >= 1))
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3[9], v9);
        uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(ValueAtIndex, a2, a3);
        if (EventWithOptions) {
          break;
        }
        if (v8 == ++v9) {
          return 0;
        }
      }
      return EventWithOptions;
    }
    else
    {
      return 0;
    }
  }
  return (uint64_t)v3;
}

uint64_t IOHIDEventSystemConnectionGetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 176);
}

uint64_t IOHIDEventSystemConnectionDispatchEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 3758097084;
  char Type = IOHIDEventGetType(a2);
  if (a1)
  {
    char v6 = Type;
    uint64_t v7 = _IOHIDEventSystemConnectionCopyQueue(a1);
    if (v7)
    {
      CFIndex v8 = v7;
      if (((*(void *)(a1 + 280) >> v6) & 1) == 0)
      {
        uint64_t v4 = 0;
        ++*(_DWORD *)(a1 + 288);
        goto LABEL_37;
      }
      uint64_t v9 = mach_absolute_time();
      _IOHIDDebugEventAddPerfData(v2, 4, v9);
      uint64_t v10 = *(void *)(a1 + 440);
      if (v10)
      {
        uint64_t v2 = IOHIDConnectionFilterFilterEvent(v10, (uint64_t)v2);
        if (!v2) {
          goto LABEL_37;
        }
      }
      if (IsNotificationEvent(v2))
      {
        IOHIDEventQueueNotify(*(void *)(a1 + 24));
LABEL_37:
        CFRelease(v8);
        return v4;
      }
      ++*(_DWORD *)(a1 + 312);
      *(void *)(a1 + 320) |= 1 << IOHIDEventGetType((uint64_t)v2);
      uint64_t v11 = IOHIDEventQueueEnqueue((uint64_t)v8, (uint64_t)v2);
      uint64_t v4 = v11;
      if (v11 == -536870168)
      {
        if (*MEMORY[0x1E4F1D260] == a1 || (*(unsigned char *)(a1 + 264) & 2) == 0)
        {
          CFRetain((CFTypeRef)a1);
          unsigned int v18 = *(NSObject **)(a1 + 96);
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 0x40000000;
          block[2] = __IOHIDEventSystemConnectionDispatchEvent_block_invoke;
          block[3] = &__block_descriptor_tmp_19_2;
          block[4] = a1;
          dispatch_async(v18, block);
        }
        goto LABEL_23;
      }
      if (v11)
      {
LABEL_23:
        TimeStampOfchar Type = IOHIDEventGetTimeStampOfType((uint64_t)v2, 2);
        TimeStampchar Type = IOHIDEventGetTimeStampType((uint64_t)v2);
        _IOHIDDebugTrace(8240, 0, TimeStampOfType, (int)v4, TimeStampType, 0);
        if (v4 != -536870195)
        {
          if (v4)
          {
            if (v4 != *(_DWORD *)(a1 + 368))
            {
              int v22 = _IOHIDLogCategory(9u);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                uint64_t v24 = *(void *)(a1 + 168);
                int v25 = IOHIDEventGetType((uint64_t)v2);
                uint64_t SenderID = IOHIDEventGetSenderID((uint64_t)v2);
                *(_DWORD *)buf = 136315906;
                uint64_t v29 = v24;
                __int16 v30 = 1024;
                *(_DWORD *)unsigned int v31 = v4;
                *(_WORD *)&v31[4] = 1024;
                *(_DWORD *)&v31[6] = v25;
                LOWORD(v32[0]) = 2048;
                *(void *)((char *)v32 + 2) = SenderID;
                _os_log_error_impl(&dword_18B46C000, v22, OS_LOG_TYPE_ERROR, "%s: Event enqueue error:0x%08x type:%d sender:0x%llx", buf, 0x22u);
              }
              *(_DWORD *)(a1 + 368) = v4;
            }
            *(int32x2_t *)(a1 + 296) = vadd_s32(*(int32x2_t *)(a1 + 296), (int32x2_t)0x100000001);
            *(void *)(a1 + 304) |= 1 << IOHIDEventGetType((uint64_t)v2);
            if (!*(void *)(a1 + 344)) {
              gettimeofday((timeval *)(a1 + 344), 0);
            }
            gettimeofday((timeval *)(a1 + 328), 0);
          }
          else if (*(_DWORD *)(a1 + 368))
          {
            int v21 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
              IOHIDEventSystemConnectionDispatchEvent_cold_1();
            }
            uint64_t v4 = 0;
            *(_DWORD *)(a1 + 368) = 0;
            *(_DWORD *)(a1 + 300) = 0;
          }
          else
          {
            uint64_t v4 = 0;
          }
        }
        goto LABEL_37;
      }
      unint64_t Latency = IOHIDEventGetLatency((uint64_t)v2, 1u);
      unint64_t v13 = Latency;
      if (Latency > *(void *)(a1 + 360)) {
        *(void *)(a1 + 360) = Latency;
      }
      CFTypeRef v14 = _IOHIDEventCopyAttachment((uint64_t)v2, @"Sender");
      uint64_t v15 = v14;
      if (v13 >= 0x2FAF081)
      {
        if (v14 && _IOHIDServiceCurrentBatchInterval((uint64_t)v14) > 1)
        {
LABEL_19:
          CFRelease(v15);
          goto LABEL_23;
        }
        uint64_t v16 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          uint64_t v17 = *(void *)(a1 + 168);
          *(_DWORD *)buf = 136315906;
          uint64_t v29 = v17;
          __int16 v30 = 2048;
          *(void *)unsigned int v31 = v13;
          *(_WORD *)&v31[8] = 1024;
          v32[0] = IOHIDEventGetType((uint64_t)v2);
          LOWORD(v32[1]) = 2048;
          *(void *)((char *)&v32[1] + 2) = IOHIDEventGetSenderID((uint64_t)v2);
          _os_log_impl(&dword_18B46C000, v16, OS_LOG_TYPE_INFO, "%s: Event latency:%lld type:%d sender:0x%llx", buf, 0x26u);
        }
      }
      if (!v15) {
        goto LABEL_23;
      }
      goto LABEL_19;
    }
  }
  return v4;
}

uint64_t IOHIDEventGetType(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 104) + 4);
}

const void *_IOHIDEventSystemConnectionCopyQueue(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRetain(v2);
  }
  os_unfair_recursive_lock_unlock();
  return v2;
}

uint64_t _IOHIDEventSystemConnectionDispatchEvent(uint64_t a1, void *a2)
{
  if (!a1) {
    return 3758097084;
  }
  if (*(_DWORD *)(a1 + 256)
    && (IOHIDEventConformsTo((uint64_t)a2, 17)
     || IOHIDEventConformsTo((uint64_t)a2, 11)
     || IOHIDEventConformsTo((uint64_t)a2, 3)
     && (Event = (void *)IOHIDEventGetEvent(a2, 3)) != 0
     && IOHIDEventGetIntegerValue(Event, 0x30000u) == 7))
  {
    uint64_t result = 0;
    ++*(_DWORD *)(a1 + 288);
  }
  else
  {
    return IOHIDEventSystemConnectionDispatchEvent(a1, (uint64_t)a2);
  }
  return result;
}

CFTypeRef _IOHIDEventCopyAttachment(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v2 = 0;
  if (!a1 || !cf1) {
    return v2;
  }
  if (!CFEqual(cf1, @"Sender"))
  {
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 56);
    if (v7)
    {
      Value = CFDictionaryGetValue(v7, cf1);
      uint64_t v2 = Value;
      if (Value) {
        CFRetain(Value);
      }
      return v2;
    }
    return 0;
  }
  CFArrayRef v5 = *(const void **)(a1 + 64);
  if (!v5) {
    return 0;
  }

  return CFRetain(v5);
}

uint64_t IOHIDEventSystemConnectionGetUUID(uint64_t a1)
{
  return *(void *)(a1 + 160);
}

uint64_t _IOHIDServiceIsInactive(uint64_t a1)
{
  return *(_DWORD *)(a1 + 224) & 1;
}

unint64_t IOHIDEventGetLatency(uint64_t a1, unsigned int a2)
{
  if (dynLinkrosetta_is_current_process_translated_0[0]
    && dynLinkrosetta_is_current_process_translated_0[0]())
  {
    uint64_t v4 = mach_absolute_time();
    unint64_t v5 = v4;
    if (!dynLinkrosetta_convert_to_system_absolute_time_0[0]) {
      goto LABEL_7;
    }
    uint64_t v6 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v4);
  }
  else
  {
    uint64_t v6 = mach_absolute_time();
  }
  unint64_t v5 = v6;
LABEL_7:
  unint64_t TimeStamp = IOHIDEventGetTimeStamp(a1);
  unint64_t result = _IOHIDGetTimestampDelta(v5, TimeStamp, a2);
  if (v5 < TimeStamp) {
    return 0;
  }
  return result;
}

uint64_t IOHIDEventGetTimeStamp(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = v1;
  if ((*(unsigned char *)(a1 + 32) & 0x80) != 0)
  {
    uint64_t v2 = 0;
    if (mach_get_times()) {
      return v2;
    }
    uint64_t v2 = v1;
  }
  if (v2
    && dynLinkrosetta_is_current_process_translated_0[0]
    && dynLinkrosetta_is_current_process_translated_0[0]()
    && dynLinkrosetta_convert_to_rosetta_absolute_time_0[0])
  {
    return ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_rosetta_absolute_time_0[0])(v2);
  }
  return v2;
}

uint64_t _IOHIDServiceGetReportIntervalForClient(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int valuePtr = 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v16);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t v6 = a3;
  if (a3 || (uint64_t v6 = _IOHIDServiceCopyConnectionCache(a1, a2)) != 0)
  {
    CFNumberRef v7 = (const __CFNumber *)IOHIDServiceConnectionCacheCopyValueForKey(v6, @"ReportInterval");
    if (v7)
    {
      CFNumberRef v8 = v7;
      CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr);
      CFRelease(v8);
      char v9 = 1;
      goto LABEL_12;
    }
    char v9 = 1;
  }
  else
  {
    char v9 = 0;
  }
  CFTypeID v10 = CFGetTypeID(a2);
  if (v10 == IOHIDEventSystemConnectionGetTypeID() && IOHIDEventSystemConnectionGetType((uint64_t)a2) == 3) {
    unsigned int valuePtr = 0;
  }
  else {
    unsigned int valuePtr = -1;
  }
LABEL_12:
  uint64_t v11 = *(void *)(a1 + 72);
  if (*(_DWORD *)v11)
  {
    --*(_DWORD *)v11;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v16);
    }
  }
  char v12 = v9 ^ 1;
  if (v6 == a3) {
    char v12 = 1;
  }
  if ((v12 & 1) == 0) {
    CFRelease(v6);
  }
  return valuePtr;
}

CFTypeRef IOHIDServiceConnectionCacheCopyValueForKey(void *a1, const void *a2)
{
  if (!CFEqual(@"ReportInterval", a2))
  {
    if (CFEqual(@"BatchInterval", a2))
    {
      uint64_t v4 = (const void *)a1[4];
      if (v4) {
        goto LABEL_6;
      }
    }
    else
    {
      CFDictionaryRef v6 = (const __CFDictionary *)a1[5];
      if (v6)
      {
        Value = CFDictionaryGetValue(v6, a2);
        CFNumberRef v8 = Value;
        if (Value) {
          CFRetain(Value);
        }
        return v8;
      }
    }
    return 0;
  }
  uint64_t v4 = (const void *)a1[3];
  if (!v4) {
    return 0;
  }
LABEL_6:

  return CFRetain(v4);
}

uint64_t _IOHIDServiceMatchPropertyTable(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  CFDictionaryRef v7 = theDict;
  uint64_t context = a1;
  uint64_t v6 = 1;
  if (*(unsigned char *)(a1 + 224)) {
    return 0;
  }
  if (!a3 && *(_DWORD *)(a1 + 300))
  {
    if (theDict)
    {
      uint64_t result = CFDictionaryContainsKey(theDict, @"Hidden");
      if (!result) {
        return result;
      }
      goto LABEL_4;
    }
    return 0;
  }
  if (!theDict) {
    return 1;
  }
LABEL_4:
  uint64_t result = CFDictionaryGetCount(theDict);
  if (result)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__IOHIDServiceComparePropertyFunction, &context);
    return v6;
  }
  return result;
}

uint64_t IOHIDServiceMatchPropertyTable(uint64_t a1, const __CFDictionary *a2)
{
  return _IOHIDServiceMatchPropertyTable(a1, a2, 0);
}

BOOL _IOHIDServiceIsProtected(uint64_t a1)
{
  return *(_DWORD *)(a1 + 304) || *(void *)(a1 + 64) != 0;
}

uint64_t IOHIDEventQueueEnqueue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 3758097101;
  uint64_t TimeStamp = IOHIDEventGetTimeStamp(a2);
  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 148) && !*(_DWORD *)(a1 + 152))
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6)
    {
      int v7 = *(_DWORD *)(v6 + 4);
      int v8 = *(_DWORD *)(v6 + 8);
      if (v7 != *(_DWORD *)(a1 + 32)) {
        __IOHIDEventQueueUpdateUsageAnalytics(a1);
      }
      *(_DWORD *)(a1 + 32) = v7;
      *(_DWORD *)(a1 + 36) = v8;
    }
    if ((IOHIDEventGetEventFlags(a2) & 0x2000) != 0)
    {
      *(_DWORD *)(a1 + 156) = 1;
      char v9 = 2;
    }
    else
    {
      char v9 = 0;
    }
    if ((IOHIDEventGetEventFlags(a2) & 0x1000) != 0)
    {
      v9 |= 1u;
      *(_DWORD *)(a1 + 156) = 0;
    }
    CFTypeID v10 = *(_DWORD **)(a1 + 16);
    uint64_t v11 = *(unsigned int *)(a1 + 56);
    Dataint Length = IOHIDEventGetDataLength(a2);
    uint64_t CallbackOptions = _IODataQueueEnqueueWithReadCallbackOptions(v10, v11, (mach_msg_header_t *)(a1 + 60), ((DataLength - 1) & 0xFFFFFFFC) + 4, (void (*)(uint64_t, char *, size_t))IOHIDEventReadBytesInternal, a2, v9);
    if (CallbackOptions)
    {
      uint64_t v4 = CallbackOptions;
      if (CallbackOptions != 268435460) {
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    if ((v9 & 2) != 0)
    {
LABEL_19:
      uint64_t v4 = 0;
      goto LABEL_20;
    }
    if (*(_DWORD *)(a1 + 156))
    {
      _IODataQueueSendDataAvailableNotification(*(unsigned int **)(a1 + 16), (mach_msg_header_t *)(a1 + 60));
      *(_DWORD *)(a1 + 156) = 0;
    }
    uint64_t v14 = mach_absolute_time();
    uint64_t v4 = 0;
    uint64_t v15 = *(void *)(a1 + 136) + 1;
    *(void *)(a1 + 128) = v14;
    *(void *)(a1 + 136) = v15;
    *(void *)(a1 + 120) = TimeStamp;
  }
LABEL_20:
  os_unfair_recursive_lock_unlock();
  return v4;
}

uint64_t IOHIDEventGetEventFlags(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 104) + 8);
}

uint64_t IOHIDAnalyticsHistogramEventSetIntegerValue()
{
  if (setHistogramIntegerValueFuncPtr) {
    return setHistogramIntegerValueFuncPtr();
  }
  return result;
}

BOOL IsNotificationEvent(void *a1)
{
  if (IOHIDEventGetType((uint64_t)a1) != 1) {
    return 0;
  }
  unsigned __int16 IntegerValue = IOHIDEventGetIntegerValue(a1, 0x10000u);
  uint64_t v3 = (unsigned __int16)IOHIDEventGetIntegerValue(a1, 0x10001u);
  return IntegerValue == 65308 && v3 == 48;
}

uint64_t _IOHIDServiceGetEventDeadlineForClient(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v10, v11);
  }
  ++**(_DWORD **)(a1 + 72);
  if (a3)
  {
    uint64_t ReportDeadline = IOHIDServiceConnectionCacheGetReportDeadline(a3);
    int v7 = (const void *)a3;
  }
  else
  {
    int v7 = _IOHIDServiceCopyConnectionCache(a1, a2);
    uint64_t ReportDeadline = 0;
  }
  uint64_t v8 = *(void *)(a1 + 72);
  if (*(_DWORD *)v8)
  {
    --*(_DWORD *)v8;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v10, v11);
    }
  }
  if (v7 != (const void *)a3 && v7) {
    CFRelease(v7);
  }
  return ReportDeadline;
}

CFDictionaryRef _IOHIDServiceContainsReportIntervalForClient(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v12, v13);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t v6 = a3;
  if (a3 || (uint64_t v6 = _IOHIDServiceCopyConnectionCache(a1, a2)) != 0)
  {
    CFDictionaryRef v7 = IOHIDServiceConnectionCacheContainsKey(v6, @"ReportInterval");
    char v8 = 1;
  }
  else
  {
    char v8 = 0;
    CFDictionaryRef v7 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 72);
  if (*(_DWORD *)v9)
  {
    --*(_DWORD *)v9;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v12, v13);
    }
  }
  char v10 = v8 ^ 1;
  if (v6 == a3) {
    char v10 = 1;
  }
  if ((v10 & 1) == 0) {
    CFRelease(v6);
  }
  return v7;
}

CFDictionaryRef IOHIDServiceConnectionCacheContainsKey(void *a1, const void *a2)
{
  if (CFEqual(@"ReportInterval", a2))
  {
    uint64_t v4 = a1[3];
    return v4;
  }
  if (CFEqual(@"BatchInterval", a2))
  {
    uint64_t v4 = a1[4];
    return v4;
  }
  CFDictionaryRef result = (const __CFDictionary *)a1[5];
  if (result) {
    return (const __CFDictionary *)CFDictionaryContainsKey(result, a2);
  }
  return result;
}

uint64_t _IOHIDServiceSupportReportLatency(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t _IOHIDServiceGetReportInterval(uint64_t a1)
{
  return *(unsigned int *)(a1 + 160);
}

uint64_t IOHIDServiceConnectionCacheGetReportDeadline(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t __IODataQueueEnqueue(_DWORD *a1, uint64_t a2, mach_msg_header_t *a3, size_t __n, void *__src, void (*a6)(uint64_t, char *, size_t), uint64_t a7, char a8)
{
  int v9 = __n;
  if (!a2) {
    LODWORD(a2) = *a1;
  }
  uint64_t v12 = 3758097128;
  uint64_t v13 = a1[2];
  unsigned int explicit = atomic_load_explicit(a1 + 1, memory_order_acquire);
  if (__n > 0xFFFFFFFB) {
    return v12;
  }
  unsigned int v15 = a2 - v13;
  if (a2 < v13 || explicit > a2) {
    return 3758097127;
  }
  unsigned int v17 = __n + 4;
  if (explicit > v13)
  {
    if (explicit - v13 > v17)
    {
      unsigned int v18 = (_DWORD *)((char *)a1 + v13 + 12);
      if (__src)
      {
        memcpy((char *)a1 + v13 + 16, __src, __n);
      }
      else if (a6)
      {
        a6(a7, (char *)a1 + v13 + 16, __n);
      }
      *unsigned int v18 = v9;
      v17 += v13;
      goto LABEL_32;
    }
    goto LABEL_19;
  }
  if (__CFADD__(v13, v17) || v13 + v17 > a2)
  {
    if (explicit <= v17)
    {
LABEL_19:
      _IODataQueueSendDataAvailableNotification(a1, a3);
      return v12;
    }
    uint64_t v19 = a1 + 3;
    if (__src)
    {
      memcpy(a1 + 4, __src, __n);
    }
    else if (a6)
    {
      a6(a7, (char *)a1 + 16, __n);
    }
    *uint64_t v19 = v9;
    if (v15 >= 4) {
      *(_DWORD *)((char *)v19 + v13) = v9;
    }
  }
  else
  {
    uint64_t v20 = (_DWORD *)((char *)a1 + v13 + 12);
    if (__src)
    {
      memcpy((char *)a1 + v13 + 16, __src, __n);
    }
    else if (a6)
    {
      a6(a7, (char *)a1 + v13 + 16, __n);
    }
    *uint64_t v20 = v9;
    v17 += v13;
  }
LABEL_32:
  atomic_store(v17, a1 + 2);
  int v21 = v13;
  if (explicit != v13)
  {
    __dmb(0xBu);
    int v21 = a1[1];
  }
  BOOL v23 = (a8 & 2) == 0 && v13 == v21;
  if ((a8 & 1) == 0 && !v23) {
    return 0;
  }

  return _IODataQueueSendDataAvailableNotification(a1, a3);
}

int64_t __IOHIDEventDataAppendEventData(uint64_t a1, char *a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  unint64_t v5 = *(unsigned int **)(a1 + 104);
  int64_t v6 = *v5;
  if (v6 > a3)
  {
    uint64_t v16 = _IOHIDLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      __IOHIDEventDataAppendEventData_cold_1(a3, v16);
    }
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 104);
    if (v9)
    {
      *((unsigned char *)v5 + 12) = *(unsigned char *)(v9 + 12) + 1;
    }
    else
    {
      char v10 = _IOHIDLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        __IOHIDEventDataAppendEventData_cold_2(v10);
      }
    }
  }
  else
  {
    *((unsigned char *)v5 + 12) = 0;
  }
  memmove(a2, *(const void **)(a1 + 104), v6);
  CFArrayRef v11 = *(const __CFArray **)(a1 + 72);
  if (v11)
  {
    uint64_t Count = CFArrayGetCount(v11);
    if (Count)
    {
      CFIndex v13 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v13);
        v6 += __IOHIDEventDataAppendEventData(ValueAtIndex, &a2[v6], a3 - v6);
        ++v13;
      }
      while (Count != v13);
    }
  }
  return v6;
}

int64_t __IOHIDEventReadBytesHelper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a1 + 32);
  if ((v6 & 0x80) != 0)
  {
    uint64_t TimeStamp = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t TimeStamp = IOHIDEventGetTimeStamp(a1);
    int v6 = *(_DWORD *)(a1 + 32);
  }
  uint64_t v8 = *(void *)(a1 + 16);
  *(void *)a2 = TimeStamp;
  *(void *)(a2 + 8) = v8;
  *(_DWORD *)(a2 + 16) = v6;
  int64x2_t v9 = *(int64x2_t *)(a1 + 88);
  *(int32x2_t *)(a2 + 20) = vmovn_s64(v9);
  char v10 = (char *)(a2 + 28);
  uint64_t v11 = a3 - 28;
  if (v9.i64[0])
  {
    uint64_t v12 = *(const void **)(a1 + 40);
    if (v12)
    {
      memmove(v10, v12, v9.u64[0]);
      uint64_t v13 = *(void *)(a1 + 88);
      v10 += v13;
      v11 -= v13;
    }
  }

  return __IOHIDEventDataAppendEventData(a1, v10, v11);
}

uint64_t _IODataQueueEnqueueWithReadCallbackOptions(_DWORD *a1, uint64_t a2, mach_msg_header_t *a3, size_t a4, void (*a5)(uint64_t, char *, size_t), uint64_t a6, char a7)
{
  return __IODataQueueEnqueue(a1, a2, a3, a4, 0, a5, a6, a7);
}

uint64_t IOHIDEventGetDataLength(uint64_t a1)
{
  uint64_t result = __IOHIDEventGetLengthAndCount(a1, (void *)(a1 + 96));
  if (result) {
    result += *(void *)(a1 + 88) + 28;
  }
  return result;
}

uint64_t __IOHIDEventGetLengthAndCount(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = **(unsigned int **)(a1 + 104);
  CFArrayRef v5 = *(const __CFArray **)(a1 + 72);
  if (v5)
  {
    uint64_t Count = CFArrayGetCount(v5);
    if (Count)
    {
      CFIndex v7 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v7);
        v4 += __IOHIDEventGetLengthAndCount(ValueAtIndex, a2);
        ++v7;
      }
      while (Count != v7);
    }
  }
  if (a2) {
    ++*a2;
  }
  return v4;
}

uint64_t _IODataQueueSendDataAvailableNotification(unsigned int *a1, mach_msg_header_t *a2)
{
  if (!a2)
  {
    uint64_t v2 = (char *)a1 + *a1;
    if (!*((_DWORD *)v2 + 6)) {
      return 0;
    }
    a2 = (mach_msg_header_t *)(v2 + 16);
  }
  mach_msg_header_t send_size = *a2;
  uint64_t v3 = mach_msg(&send_size, 17, send_size.msgh_size, 0, 0, 0, 0);
  if ((v3 - 268435459) <= 1)
  {
    if (send_size.msgh_local_port - 1 <= 0xFFFFFFFD && ((send_size.msgh_bits >> 8) & 0x1F) - 17 <= 1) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], send_size.msgh_local_port);
    }
    mach_msg_destroy(&send_size);
  }
  return v3;
}

uint64_t __IOHIDEventQueueUpdateUsageAnalytics(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 160);
  if (result) {
    return IOHIDAnalyticsHistogramEventSetIntegerValue();
  }
  return result;
}

void *IOHIDEventSetIntegerValueWithOptions(void *result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (uint64_t result = (void *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a4)) != 0)
  {
    uint64_t v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFE | (a3 != 0);
            goto LABEL_179;
          case 1u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFD | (2 * (a3 != 0));
            goto LABEL_179;
          case 2u:
            goto LABEL_21;
          case 3u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xF7 | (8 * (a3 != 0));
            goto LABEL_179;
          case 4u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xEF | (16 * (a3 != 0));
            goto LABEL_179;
          case 5u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xDF | (32 * (a3 != 0));
            goto LABEL_179;
          case 6u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xBF | ((a3 != 0) << 6);
            goto LABEL_179;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x10002u:
            goto LABEL_170;
          case 0x10004u:
            if (*(_DWORD *)(v7 + 24) >= 8u) {
              *(void *)(v7 + 28) = a3;
            }
            break;
          default:
            return result;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_145;
          case 0x20001u:
            goto LABEL_133;
          case 0x20002u:
            goto LABEL_134;
          case 0x20003u:
            goto LABEL_151;
          case 0x20004u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_118;
          case 0x30001u:
            goto LABEL_126;
          case 0x30002u:
            goto LABEL_170;
          case 0x30003u:
            goto LABEL_182;
          case 0x30004u:
            *(unsigned char *)(v7 + 28) = a3;
            break;
          case 0x30005u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a3 != 0);
            goto LABEL_156;
          case 0x30006u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a3 & 3));
            goto LABEL_156;
          case 0x30007u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a3 & 3));
            goto LABEL_156;
          case 0x30008u:
            *(_DWORD *)(v7 + 24) = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a3 != 0));
            break;
          case 0x30009u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a3 & 7) << 6);
            goto LABEL_156;
          case 0x3000Au:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a3 & 3) << 9);
            goto LABEL_156;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146) {
          goto LABEL_52;
        }
        if (a2 == 262145) {
          goto LABEL_165;
        }
        if (a2 != 0x40000) {
          return result;
        }
        goto LABEL_69;
      case 5u:
        if (a2 == 327682) {
          goto LABEL_154;
        }
        if (a2 == 327681) {
          goto LABEL_151;
        }
        if (a2 != 327680) {
          return result;
        }
        goto LABEL_105;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_105;
          case 0x60001u:
            goto LABEL_151;
          case 0x60002u:
            goto LABEL_154;
          case 0x60003u:
LABEL_21:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFB | (4 * (a3 != 0));
LABEL_179:
            *(unsigned char *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
LABEL_52:
            unsigned int v10 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v10 = 0x80000000;
            }
            goto LABEL_156;
          case 0x70001u:
            goto LABEL_165;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_154:
          unsigned int v10 = a3 << 16;
          if (a3 == 0x80000000) {
            unsigned int v10 = 0x80000000;
          }
LABEL_156:
          *(_DWORD *)(v7 + 24) = v10;
          return result;
        }
        if (a2 == 589825) {
          goto LABEL_151;
        }
        if (a2 != 589824) {
          return result;
        }
        goto LABEL_105;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_154;
                case 0xA0001u:
                  goto LABEL_151;
                case 0xA0000u:
                  goto LABEL_105;
              }
              break;
            case 1:
              if (a2 == 655364) {
                goto LABEL_145;
              }
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_154;
                case 0xA0006u:
                  goto LABEL_151;
                case 0xA0005u:
                  goto LABEL_105;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_105;
                case 0xA0009u:
                  goto LABEL_151;
                case 0xA000Au:
                  goto LABEL_154;
                case 0xA000Bu:
                  goto LABEL_157;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_165;
          case 0xB0002u:
            goto LABEL_52;
          case 0xB0003u:
            goto LABEL_183;
          case 0xB0004u:
            goto LABEL_127;
          case 0xB0005u:
            goto LABEL_119;
          case 0xB0006u:
            goto LABEL_132;
          case 0xB0007u:
            goto LABEL_184;
          case 0xB0008u:
LABEL_182:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a3 != 0) << 16);
            goto LABEL_257;
          case 0xB0009u:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a3 != 0) << 17);
            goto LABEL_257;
          case 0xB000Au:
            goto LABEL_208;
          case 0xB000Bu:
            goto LABEL_211;
          case 0xB000Cu:
            goto LABEL_253;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            int v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_199;
                  case 0xB0013u:
                    goto LABEL_214;
                  case 0xB0014u:
                    goto LABEL_217;
                  case 0xB0015u:
LABEL_262:
                    unsigned int v38 = a3 << 16;
                    if (a3 == 0x80000000) {
                      unsigned int v38 = 0x80000000;
                    }
                    *(_DWORD *)(v7 + 84) = v38;
                    break;
                  case 0xB001Au:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_196;
                  case 0xB0010u:
                    goto LABEL_199;
                  case 0xB0011u:
                    goto LABEL_214;
                  case 0xB0012u:
                    goto LABEL_217;
                  case 0xB0014u:
                    goto LABEL_262;
                  case 0xB0015u:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910) {
              goto LABEL_199;
            }
            if (a2 != 720909) {
              return result;
            }
            goto LABEL_196;
          case 0xB0016u:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a3 != 0));
            goto LABEL_257;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32)) {
              goto LABEL_253;
            }
            return result;
          case 0xB0018u:
            goto LABEL_181;
          case 0xB0019u:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a3 != 0) << 19);
LABEL_257:
            *(_DWORD *)(v7 + 8) = v20;
            return result;
          case 0xB001Bu:
            *(_DWORD *)(v7 + 92) = a3;
            return result;
          case 0xB001Cu:
            *(_DWORD *)(v7 + 96) = a3;
            return result;
          case 0xB001Du:
            *(_DWORD *)(v7 + 100) = a3;
            return result;
          case 0xB001Eu:
            *(_DWORD *)(v7 + 40) = (a3 << 13) & 0x30000000 | (((a3 >> 10) & 1) << 30) & 0x70000000 | ((a3 >> 23) << 31) | *(_DWORD *)(v7 + 40) & 0xFFFFFFF;
            return result;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_116;
          case 0xC0001u:
            goto LABEL_170;
          case 0xC0002u:
            goto LABEL_88;
          case 0xC0003u:
            goto LABEL_119;
          case 0xC0004u:
            goto LABEL_127;
          case 0xC0005u:
            *(unsigned char *)(v7 + 36) = a3 != 0;
            break;
          case 0xC0006u:
            *(unsigned char *)(v7 + 37) = a3;
            break;
          case 0xC0007u:
            goto LABEL_137;
          case 0xC0008u:
            goto LABEL_128;
          case 0xC0009u:
            goto LABEL_129;
          case 0xC000Au:
            goto LABEL_160;
          case 0xC000Bu:
            goto LABEL_161;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_165;
          case 0xD0002u:
            goto LABEL_52;
          case 0xD0003u:
            goto LABEL_119;
          case 0xD0004u:
            goto LABEL_127;
          case 0xD0005u:
            goto LABEL_132;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_118;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507) {
                goto LABEL_143;
              }
              return result;
            }
            if (a2 != 917505 || *(_WORD *)(v7 + 18)) {
              return result;
            }
            break;
          case 0xE0002u:
            goto LABEL_126;
          default:
            return result;
        }
        goto LABEL_143;
      case 0xFu:
        if (a2 != 983040) {
          return result;
        }
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_78;
          case 0x100001u:
            goto LABEL_123;
          case 0x100002u:
            goto LABEL_120;
          case 0x100003u:
            goto LABEL_105;
          case 0x100004u:
            goto LABEL_151;
          case 0x100005u:
            goto LABEL_124;
          case 0x100006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_165;
          case 0x110002u:
            goto LABEL_52;
          case 0x110003u:
            goto LABEL_119;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649) {
          goto LABEL_165;
        }
        if (a2 != 1179648) {
          return result;
        }
        goto LABEL_116;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_105;
          case 0x130001u:
            goto LABEL_151;
          case 0x130002u:
            goto LABEL_154;
          case 0x130003u:
            goto LABEL_96;
          case 0x130004u:
            goto LABEL_120;
          case 0x130005u:
            goto LABEL_171;
          case 0x130006u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_105;
          case 0x140001u:
            goto LABEL_151;
          case 0x140002u:
            goto LABEL_154;
          case 0x140003u:
            goto LABEL_78;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_130;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_105;
          case 0x150001u:
            goto LABEL_151;
          case 0x150002u:
            goto LABEL_154;
          case 0x150003u:
            goto LABEL_78;
          case 0x150004u:
LABEL_61:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x150005u:
LABEL_130:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_78;
          case 0x170001u:
            goto LABEL_123;
          case 0x170002u:
            goto LABEL_120;
          case 0x170003u:
            goto LABEL_105;
          case 0x170004u:
            goto LABEL_151;
          case 0x170005u:
            goto LABEL_124;
          case 0x170006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864) {
          goto LABEL_116;
        }
        if (a2 == 1572865) {
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a3 != 0) << 15);
        }
        return result;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
LABEL_119:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x190001u:
LABEL_88:
            *(_DWORD *)(v7 + 24) = a3;
            break;
          case 0x190000u:
LABEL_69:
            unsigned int v11 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v11 = 0x80000000;
            }
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            goto LABEL_88;
          case 0x1A0001u:
LABEL_125:
            *(unsigned char *)(v7 + 20) = a3;
            break;
          case 0x1A0000u:
LABEL_145:
            *(_DWORD *)(v7 + 16) = a3;
            break;
        }
        return result;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_78;
          case 0x1B0001u:
            goto LABEL_123;
          case 0x1B0002u:
            goto LABEL_120;
          case 0x1B0003u:
            goto LABEL_105;
          case 0x1B0004u:
            goto LABEL_151;
          case 0x1B0005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_78:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x1C0001u:
LABEL_123:
            *(_WORD *)(v7 + 32) = a3;
            break;
          case 0x1C0002u:
            goto LABEL_120;
          case 0x1C0003u:
            goto LABEL_105;
          case 0x1C0004u:
            goto LABEL_151;
          case 0x1C0005u:
LABEL_124:
            *(_WORD *)(v7 + 34) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_145;
          case 0x1D0001u:
            goto LABEL_151;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = a3;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = a3;
            break;
          case 0x1D0004u:
            *(unsigned char *)(v7 + 32) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            goto LABEL_145;
          case 0x1E0001u:
            goto LABEL_151;
          case 0x1E0002u:
            goto LABEL_88;
          case 0x1E0003u:
            if (*(_DWORD *)(v7 + 24) >= 8u) {
              *(void *)(v7 + 28) = a3;
            }
            break;
          default:
            return result;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617) {
          goto LABEL_143;
        }
        if (a2 != 2031616) {
          return result;
        }
        goto LABEL_105;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_116;
          case 0x200001u:
            goto LABEL_165;
          case 0x200002u:
            goto LABEL_88;
          case 0x200003u:
            goto LABEL_157;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689) {
          goto LABEL_151;
        }
        if (a2 != 2162688) {
          return result;
        }
        goto LABEL_145;
      case 0x22u:
        if (a2 == 2228225) {
          goto LABEL_165;
        }
        if (a2 != 2228224) {
          return result;
        }
LABEL_116:
        *(_DWORD *)(v7 + 16) = a3;
        return result;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_116;
          case 0x230001u:
            goto LABEL_165;
          case 0x230002u:
            goto LABEL_52;
          case 0x230003u:
LABEL_157:
            unsigned int v17 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v17 = 0x80000000;
            }
            *(_DWORD *)(v7 + 28) = v17;
            return result;
          case 0x230004u:
LABEL_96:
            unsigned int v12 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v12 = 0x80000000;
            }
            *(_DWORD *)(v7 + 32) = v12;
            return result;
          case 0x230005u:
            unsigned int v28 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v28 = 0x80000000;
            }
            *(_DWORD *)(v7 + 44) = v28;
            return result;
          case 0x230006u:
            unsigned int v29 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v29 = 0x80000000;
            }
            *(_DWORD *)(v7 + 48) = v29;
            return result;
          case 0x230007u:
LABEL_120:
            unsigned int v15 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v15 = 0x80000000;
            }
            *(_DWORD *)(v7 + 36) = v15;
            return result;
          case 0x230008u:
LABEL_171:
            unsigned int v19 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v19 = 0x80000000;
            }
            *(_DWORD *)(v7 + 40) = v19;
            return result;
          case 0x230009u:
LABEL_196:
            unsigned int v21 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v21 = 0x80000000;
            }
            *(_DWORD *)(v7 + 68) = v21;
            return result;
          case 0x23000Au:
LABEL_214:
            unsigned int v25 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v25 = 0x80000000;
            }
            *(_DWORD *)(v7 + 76) = v25;
            return result;
          case 0x23000Bu:
LABEL_199:
            unsigned int v22 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v22 = 0x80000000;
            }
            *(_DWORD *)(v7 + 72) = v22;
            return result;
          case 0x23000Cu:
LABEL_217:
            unsigned int v26 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v26 = 0x80000000;
            }
            *(_DWORD *)(v7 + 80) = v26;
            return result;
          case 0x23000Du:
LABEL_208:
            unsigned int v23 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v23 = 0x80000000;
            }
            *(_DWORD *)(v7 + 52) = v23;
            return result;
          case 0x23000Eu:
LABEL_211:
            unsigned int v24 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v24 = 0x80000000;
            }
            *(_DWORD *)(v7 + 56) = v24;
            return result;
          case 0x23000Fu:
LABEL_253:
            unsigned int v37 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v37 = 0x80000000;
            }
            *(_DWORD *)(v7 + 60) = v37;
            return result;
          case 0x230010u:
            unsigned int v30 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v30 = 0x80000000;
            }
            *(_DWORD *)(v7 + 64) = v30;
            return result;
          case 0x230011u:
            char v31 = *(unsigned char *)(v7 + 84) & 0xFE | (a3 != 0);
            goto LABEL_234;
          case 0x230012u:
            char v31 = *(unsigned char *)(v7 + 84) & 0xFD | (2 * (a3 != 0));
LABEL_234:
            *(unsigned char *)(v7 + 84) = v31;
            break;
          case 0x230013u:
LABEL_220:
            unsigned int v27 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v27 = 0x80000000;
            }
            *(_DWORD *)(v7 + 88) = v27;
            break;
          case 0x230014u:
            unsigned int v32 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v32 = 0x80000000;
            }
            *(_DWORD *)(v7 + 92) = v32;
            break;
          case 0x230015u:
            unsigned int v33 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v33 = 0x80000000;
            }
            *(_DWORD *)(v7 + 96) = v33;
            break;
          case 0x230016u:
            unsigned int v34 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v34 = 0x80000000;
            }
            *(_DWORD *)(v7 + 100) = v34;
            break;
          case 0x230017u:
            unsigned int v35 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v35 = 0x80000000;
            }
            *(_DWORD *)(v7 + 104) = v35;
            break;
          case 0x230018u:
            unsigned int v36 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v36 = 0x80000000;
            }
            *(_DWORD *)(v7 + 108) = v36;
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
        {
LABEL_143:
          *(_DWORD *)(v7 + 20) = a3;
        }
        else if (a2 == 2359296)
        {
          goto LABEL_105;
        }
        return result;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(void *)(v7 + 24) = a3;
            break;
          case 0x260001u:
LABEL_151:
            unsigned int v16 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v16 = 0x80000000;
            }
            *(_DWORD *)(v7 + 20) = v16;
            break;
          case 0x260000u:
LABEL_105:
            unsigned int v13 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v13 = 0x80000000;
            }
            *(_DWORD *)(v7 + 16) = v13;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1) {
          return result;
        }
        int v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 == 2555906)
          {
LABEL_165:
            unsigned int v18 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v18 = 0x80000000;
            }
            *(_DWORD *)(v7 + 20) = v18;
          }
        }
        else
        {
          if (!v14)
          {
            if (a2 != 2555905) {
              return result;
            }
            goto LABEL_170;
          }
          if (a2 == 2555905 && v14 == 2)
          {
LABEL_170:
            *(_DWORD *)(v7 + 20) = a3;
            return result;
          }
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = a3;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = a3;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = (double)a3;
            break;
          case 0x280003u:
LABEL_133:
            *(unsigned char *)(v7 + 24) = a3;
            break;
          case 0x280004u:
LABEL_134:
            *(unsigned char *)(v7 + 25) = a3;
            break;
          case 0x280005u:
            goto LABEL_119;
          case 0x280006u:
LABEL_127:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x280007u:
LABEL_132:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          case 0x280008u:
            *(unsigned char *)(v7 + 44) = a3;
            break;
          case 0x280009u:
LABEL_183:
            *(_DWORD *)(v7 + 48) = a3;
            break;
          case 0x28000Au:
            *(void *)(v7 + 56) = a3;
            break;
          case 0x28000Bu:
            *(unsigned char *)(v7 + 26) = a3;
            break;
          case 0x28000Cu:
LABEL_184:
            *(_DWORD *)(v7 + 40) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_116;
          case 0x290001u:
            goto LABEL_125;
          case 0x290002u:
            goto LABEL_135;
          case 0x290003u:
            goto LABEL_136;
          case 0x290004u:
LABEL_137:
            *(double *)(v7 + 40) = (double)a3;
            break;
          case 0x290005u:
            goto LABEL_128;
          case 0x290006u:
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_118:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x2A0001u:
LABEL_126:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x2A0002u:
LABEL_135:
            *(double *)(v7 + 24) = (double)a3;
            break;
          case 0x2A0003u:
LABEL_136:
            *(double *)(v7 + 32) = (double)a3;
            break;
          case 0x2A0004u:
            *(unsigned char *)(v7 + 40) = a3 != 0;
            break;
          case 0x2A0005u:
LABEL_181:
            *(_DWORD *)(v7 + 44) = a3;
            break;
          case 0x2A0006u:
LABEL_128:
            *(double *)(v7 + 48) = (double)a3;
            break;
          case 0x2A0007u:
LABEL_129:
            *(double *)(v7 + 56) = (double)a3;
            break;
          case 0x2A0008u:
LABEL_160:
            *(double *)(v7 + 64) = (double)a3;
            break;
          case 0x2A0009u:
LABEL_161:
            *(double *)(v7 + 72) = (double)a3;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

void *IOHIDEventSetIntegerValue(void *a1, unsigned int a2, uint64_t a3)
{
  return IOHIDEventSetIntegerValueWithOptions(a1, a2, a3, 4026531840);
}

uint64_t _IOHIDSimpleQueueEnqueue(const __CFData *a1, const void *a2, int a3)
{
  BytePtr = CFDataGetBytePtr(a1);
  unsigned int v6 = BytePtr;
  uint64_t v7 = *((void *)BytePtr + 3);
  unint64_t v8 = (unint64_t)(v7 + 1) % *(void *)BytePtr;
  if (v8 != *((void *)BytePtr + 2))
  {
LABEL_7:
    memcpy((void *)&BytePtr[*((void *)BytePtr + 1) * v7 + 32], a2, *((void *)BytePtr + 1));
    uint64_t result = 0;
    *((void *)v6 + 3) = v8;
    return result;
  }
  if (a3)
  {
    if (v8 + 1 == *(void *)BytePtr) {
      unint64_t v9 = 0;
    }
    else {
      unint64_t v9 = v8 + 1;
    }
    *((void *)BytePtr + 2) = v9;
    goto LABEL_7;
  }
  return 3758097115;
}

uint64_t IOHIDEventGetEvent(void *a1, uint64_t a2)
{
  return IOHIDEventGetEventWithOptions(a1, a2, 4026531840);
}

CFDataRef _IOHIDSimpleQueueCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3 + 1;
  CFIndex v5 = (a3 + 1) * a2 + 32;
  Mutable = CFDataCreateMutable(a1, v5);
  CFDataRef v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    BytePtr = (UInt8 *)CFDataGetBytePtr(v7);
    *(void *)BytePtr = v4;
    *((void *)BytePtr + 1) = a2;
    *((void *)BytePtr + 2) = 0;
    *((void *)BytePtr + 3) = 0;
  }
  return v7;
}

uint64_t _IOHIDServiceCurrentBatchInterval(uint64_t a1)
{
  return *(unsigned int *)(a1 + 164);
}

id __FilterFunctionUnregisterService(void *a1, uint64_t *a2)
{
  return IOHIDSessionFilterUnregisterService(a1, *a2);
}

id __FilterFunctionRegisterService(void *a1, uint64_t *a2)
{
  return IOHIDSessionFilterRegisterService(a1, *a2);
}

BOOL _IOHIDEventSystemConnectionContainsService(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v4 = CFSetContainsValue(*(CFSetRef *)(a1 + 80), a2) != 0;
  os_unfair_recursive_lock_unlock();
  return v4;
}

uint64_t _IOHIDServiceDispatchEvent(uint64_t result, void *a2, uint64_t a3)
{
  if (result)
  {
    if (a2) {
      return __IOHIDServiceEventCallback(result, (uint64_t)a2, a3, a2);
    }
  }
  return result;
}

void *IOHIDEventSetFloatValue(void *a1, unsigned int a2, double a3)
{
  return IOHIDEventSetFloatValueWithOptions(a1, a2, 4026531840, a3);
}

uint64_t __IOHIDServiceQueueDidExecute(uint64_t result)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceQueueDidExecute_cold_1(&v1, v2);
    }
  }
  return result;
}

uint64_t __IOHIDServiceQueueWillExecute(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (result) {
    __IOHIDServiceQueueWillExecute_cold_1(&v3, v4);
  }
  ++*(_DWORD *)a1;
  return result;
}

mach_port_t IONotificationPortGetMachPort(IONotificationPortRef notify)
{
  return *((_DWORD *)notify + 1);
}

uint64_t IOHIDEventGetPhase(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 104) + 11);
}

CFDictionaryRef __IOHIDEventSystemClientRefreshServiceCallback(void *key, CFDictionaryRef *a2, void *a3)
{
  CFDictionaryRef v5 = (const __CFDictionary *)a3[1];
  if (v5)
  {
    unsigned int v6 = (void *)*a3;
    if (!CFDictionaryContainsKey(v5, key))
    {
      os_unfair_recursive_lock_lock_with_options();
      uint64_t v7 = v6[22];
      if (v7)
      {
        (*(void (**)(uint64_t, void, void, CFDictionaryRef *))(v7 + 16))(v7, v6[23], v6[24], a2);
      }
      else
      {
        unint64_t v8 = (void (*)(void, void, CFDictionaryRef *))v6[21];
        if (v8) {
          v8(v6[23], v6[24], a2);
        }
      }
      os_unfair_recursive_lock_unlock();
    }
  }

  return _IOHIDServiceClientRefresh(a2);
}

void __IOHIDSessionServiceCallback(uint64_t a1, int a2, const void *a3, void *a4)
{
  if (a1 && a4)
  {
    _IOHIDEventSetAttachment(a4, @"Sender", a3);
    __IOHIDSessionDispatchEvent(a1, a4);
  }
}

BOOL _IOHIDEventSetAttachment(void *a1, CFTypeRef cf1, const void *a3)
{
  BOOL result = 0;
  if (a1 && cf1)
  {
    if (CFEqual(cf1, @"Sender"))
    {
      uint64_t v7 = (const void *)a1[8];
      if (v7) {
        CFRelease(v7);
      }
      if (a3) {
        CFTypeRef v8 = CFRetain(a3);
      }
      else {
        CFTypeRef v8 = 0;
      }
      a1[8] = v8;
      return 1;
    }
    Mutable = (__CFDictionary *)a1[7];
    if (Mutable
      || (CFAllocatorRef v10 = CFGetAllocator(a1),
          Mutable = CFDictionaryCreateMutable(v10, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
          (a1[7] = Mutable) != 0))
    {
      CFDictionarySetValue(Mutable, cf1, a3);
      return 1;
    }
    unsigned int v11 = _IOHIDLog();
    BOOL result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (result)
    {
      _IOHIDEventSetAttachment_cold_1(v11);
      return 0;
    }
  }
  return result;
}

uint64_t ServiceClientFunctionRemove(uint64_t a1, uint64_t a2)
{
  for (int i = 0; i != 3; ++i)
    uint64_t result = _IOHIDServiceRemoveConnection(a1, *(const void **)(a2 + 8), i);
  return result;
}

uint64_t ServiceDictClientFunctionRemove(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (int i = 0; i != 3; ++i)
    uint64_t result = _IOHIDServiceRemoveConnection(a2, *(const void **)(a3 + 8), i);
  return result;
}

uint64_t _IOHIDServiceRemoveConnection(uint64_t result, const void *a2, int a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a3 > 2) {
    return result;
  }
  uint64_t v5 = result;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(result + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v19, v20);
  }
  ++**(_DWORD **)(v5 + 72);
  if (*(void *)(*(void *)(v5 + 368) + 8 * a3))
  {
    uint64_t v6 = a3;
    CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)v5);
    CFSetRef v8 = *(const __CFSet **)(*(void *)(v5 + 368) + 8 * a3);
    if (a3 != 1)
    {
      MutableCFSetRef Copy = CFSetCreateMutableCopy(v7, 0, v8);
      CFSetRemoveValue(MutableCopy, a2);
LABEL_14:
      CFRelease(*(CFTypeRef *)(*(void *)(v5 + 368) + 8 * v6));
      *(void *)(*(void *)(v5 + 368) + 8 * v6) = MutableCopy;
      unsigned int v15 = *(void **)(v5 + 480);
      if (v15)
      {
        unsigned int v16 = *(const char **)(v5 + 560);
        if (v16) {
          objc_msgSend(v15, v16, a2, 0);
        }
      }
      CFArrayRef v17 = *(const __CFArray **)(v5 + 256);
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 0x40000000;
      v18[2] = ___IOHIDServiceRemoveConnection_block_invoke;
      v18[3] = &__block_descriptor_tmp_128;
      v18[4] = a2;
      _IOHIDCFArrayApplyBlock(v17, v18);
      goto LABEL_18;
    }
    CFArrayRef v9 = CFArrayCreateMutableCopy(v7, 0, v8);
    if (v9)
    {
      MutableCFSetRef Copy = v9;
      CFIndex Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        CFIndex v12 = Count;
        CFIndex v13 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, v13);
          if (ValueAtIndex)
          {
            if (ValueAtIndex == a2) {
              break;
            }
          }
          if (v12 == ++v13) {
            goto LABEL_14;
          }
        }
        CFArrayRemoveValueAtIndex(MutableCopy, v13);
      }
      goto LABEL_14;
    }
  }
LABEL_18:
  uint64_t result = *(void *)(v5 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v19, v20);
    }
  }
  return result;
}

uint64_t _IODispatchCalloutWithDispatch(mach_msg_header_t *a1, mach_msg_header_t *a2)
{
  mig_reply_setup(a1, a2);
  a2[1].msgh_remote_port = -305;
  IODispatchCalloutFromCFMessage(v4, a1);
  return 1;
}

void IODispatchCalloutFromCFMessage(uint64_t a1, _DWORD *a2)
{
  if (a2[5] == 53)
  {
    int v2 = (int)a2;
    if ((*a2 & 0x80000000) != 0)
    {
      int v6 = a2[6];
      if (v6) {
        uint64_t v3 = a2[7];
      }
      else {
        uint64_t v3 = 0;
      }
      uint64_t v5 = (uint64_t)&a2[3 * v6 + 7];
      uint64_t v4 = a2;
    }
    else
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
      uint64_t v5 = (uint64_t)(a2 + 6);
    }
    int v8 = a2[1];
    uint64_t v7 = a2[2];
    CFArrayRef v9 = (ipc_space_t *)MEMORY[0x1E4F14960];
    if (v7)
    {
      unsigned int v21 = 0;
      if (MEMORY[0x18C131220](*MEMORY[0x1E4F14960], v7, 0, &v21) || v21 < 2) {
        goto LABEL_31;
      }
    }
    int v11 = *(_DWORD *)(v5 + 4) & 0xFFF;
    if ((v11 - 100) >= 3)
    {
      CFIndex v12 = (unsigned int *)(v5 + 72);
      unsigned int v13 = v8 + v2 - (v5 + 72) - (*(_DWORD *)(v5 + 4) >> 30);
      if (v11 == 160)
      {
        CFArrayRef v17 = (void *)(v5 + 76);
        if (((v13 + 0x7FFFFFFFCLL) & 0x7FFFFFFF0) == 0) {
          CFArrayRef v17 = (void *)*v17;
        }
        if (!v3) {
          uint64_t v3 = *(unsigned int *)(v5 + 32);
        }
        (*(void (**)(void, uint64_t, void, void *))(v5 + 16))(*(void *)(v5 + 24), v3, *v12, v17);
      }
      else if (v11 == 150)
      {
        unint64_t v14 = ((unint64_t)v13 + 0x7FFFFFFFCLL) >> 3;
        unsigned int v16 = *(void (**)(void, void, void))(v5 + 16);
        uint64_t v15 = *(void *)(v5 + 24);
        if (v14 == 2)
        {
          ((void (*)(uint64_t, void, void, void))v16)(v15, *(unsigned int *)(v5 + 72), *(void *)(v5 + 76), *(void *)(v5 + 84));
        }
        else if (v14 == 1)
        {
          v16(v15, *(unsigned int *)(v5 + 72), *(void *)(v5 + 76));
        }
        else if (v14)
        {
          v16(v15, *(unsigned int *)(v5 + 72), v5 + 76);
        }
        else
        {
          ((void (*)(uint64_t, void))v16)(v15, *v12);
        }
      }
    }
    else
    {
      (*(void (**)(void, uint64_t))(v5 + 16))(*(void *)(v5 + 24), v7);
    }
    if (v7) {
LABEL_31:
    }
      mach_port_deallocate(*v9, v7);
    if (v4 && v4[6])
    {
      unint64_t v18 = 0;
      uint64_t v19 = v4 + 7;
      do
      {
        mach_port_name_t v20 = *v19;
        v19 += 3;
        mach_port_deallocate(*v9, v20);
        ++v18;
      }
      while (v18 < v4[6]);
    }
  }
}

id IOHIDSessionFilterSetPropertyForClient(id result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *((void *)result + 2);
  if (v3)
  {
    uint64_t v4 = *(uint64_t (**)(void, uint64_t))(*(void *)v3 + 128);
    if (v4) {
      return (id)v4(*((void *)result + 2), a2);
    }
  }
  if (*((void *)result + 7)) {
    return objc_msgSend(*((id *)result + 7), *((SEL *)result + 9), a3, a2);
  }
  return result;
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return _IOObjectConformsTo(object, className, 0);
}

BOOLean_t IOHIDServiceClientConformsTo(IOHIDServiceClientRef service, uint32_t usagePage, uint32_t usage)
{
  uint64_t v3 = *((void *)service + 17);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *((unsigned int *)service + 36);
  if (!v4) {
    return 0;
  }
  for (int i = (_DWORD *)(v3 + 4); *(i - 1) != usagePage || *i != usage; i += 2)
  {
    if (!--v4) {
      return 0;
    }
  }
  return 1;
}

uint64_t IOHIDServiceSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  return _IOHIDServiceSetPropertyForClient(a1, a2, a3, (CFTypeRef)*MEMORY[0x1E4F1D260]);
}

uint64_t _IOHIDServiceRemovePropertiesForClient(uint64_t a1, const void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v6, v7);
  }
  ++**(_DWORD **)(a1 + 72);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 240), a2);
  uint64_t v4 = *(void *)(a1 + 72);
  if (*(_DWORD *)v4)
  {
    --*(_DWORD *)v4;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v6, v7);
    }
  }

  return __IOHIDServiceUpdateIntervals(a1, (uint64_t)a2);
}

IOReturn IODataQueueWaitForAvailableData(IODataQueueMemory *dataQueue, mach_port_t notificationPort)
{
  IOReturn result = -536870206;
  if (dataQueue)
  {
    if (notificationPort)
    {
      memset(v4, 0, sizeof(v4));
      return mach_msg((mach_msg_header_t *)v4, 2, 0, 0x20u, notificationPort, 0, 0);
    }
  }
  return result;
}

void __IOHIDServiceComparePropertyFunction(const void *a1, const void *a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 8)) {
    return;
  }
  if (CFEqual(a1, @"DeviceUsagePairs"))
  {
    CFTypeID v6 = CFGetTypeID(a2);
    if (v6 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
      if (Count < 1)
      {
        int v10 = 0;
      }
      else
      {
        CFIndex v8 = Count;
        CFIndex v9 = 0;
        int v10 = 0;
        do
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a2, v9);
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (ValueAtIndex)
          {
            if (CFGetTypeID(ValueAtIndex) == TypeID) {
              CFDictionaryRef v13 = ValueAtIndex;
            }
            else {
              CFDictionaryRef v13 = 0;
            }
          }
          else
          {
            CFDictionaryRef v13 = 0;
          }
          v10 |= __IOHIDServiceCompareUsagePair(*(void *)a3, v13);
          ++v9;
        }
        while (v8 != v9);
      }
      *(_DWORD *)(a3 + 8) = v10;
      return;
    }
  }
  if (CFEqual(a1, @"DeviceUsagePage"))
  {
    *(_DWORD *)(a3 + 8) = __IOHIDServiceCompareUsagePair(*(void *)a3, *(CFDictionaryRef *)(a3 + 16));
    return;
  }
  if (!CFEqual(a1, @"DeviceUsage"))
  {
    if (CFEqual(a1, @"Built-In"))
    {
      if (*(_DWORD *)(*(void *)a3 + 284) == CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
        return;
      }
      goto LABEL_18;
    }
    if (CFEqual(a1, @"Hidden"))
    {
      if (!CFEqual(a2, @"*")) {
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(*(void *)a3 + 300) == CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      }
    }
    else
    {
      if (!a2) {
        return;
      }
      uint64_t v14 = _IOHIDServiceCopyPropertyForClient(*(void *)a3, a1, (const void *)*MEMORY[0x1E4F1D260]);
      if (!v14)
      {
LABEL_18:
        *(_DWORD *)(a3 + 8) = 0;
        return;
      }
      uint64_t v15 = (const void *)v14;
      if (!CFEqual(a2, @"*")) {
        *(_DWORD *)(a3 + 8) = CFEqual(a2, v15);
      }
      CFRelease(v15);
    }
  }
}

uint64_t __IOHIDServiceCompareUsagePair(uint64_t a1, CFDictionaryRef theDict)
{
  int v12 = -1;
  int valuePtr = -1;
  if (!theDict) {
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DeviceUsagePage");
  if (Value)
  {
    CFNumberRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFNumberGetTypeID()) {
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
    }
  }
  CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DeviceUsage");
  if (v7 && (v8 = v7, CFTypeID v9 = CFGetTypeID(v7), v9 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(v8, kCFNumberSInt32Type, &v12);
    int v10 = v12;
  }
  else
  {
    int v10 = -1;
  }
  return IOHIDServiceConformsTo(a1, valuePtr, v10);
}

uint64_t IOHIDServiceConformsTo(uint64_t a1, int a2, int a3)
{
  context[0] = 0;
  context[1] = a2;
  context[2] = a3;
  uint64_t v4 = (const void *)*MEMORY[0x1E4F1D260];
  CFArrayRef v5 = (const __CFArray *)_IOHIDServiceCopyPropertyForClient(a1, @"DeviceUsagePairs", (const void *)*MEMORY[0x1E4F1D260]);
  CFArrayRef v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 == CFArrayGetTypeID())
    {
      v17.length = CFArrayGetCount(v6);
      v17.location = 0;
      CFArrayApplyFunction(v6, v17, (CFArrayApplierFunction)__IOHIDServiceConformsToFunction, context);
LABEL_12:
      CFRelease(v6);
      return context[0];
    }
    CFNumberRef v8 = _IOHIDLogCategory(6u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      IOHIDServiceConformsTo_cold_1();
    }
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    int v10 = Mutable;
    int v11 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"PrimaryUsagePage", v4);
    if (v11)
    {
      int v12 = v11;
      CFDictionarySetValue(v10, @"DeviceUsagePage", v11);
      CFRelease(v12);
      CFDictionaryRef v13 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"PrimaryUsage", v4);
      if (v13)
      {
        uint64_t v14 = v13;
        CFDictionarySetValue(v10, @"DeviceUsage", v13);
        CFRelease(v14);
        __IOHIDServiceConformsToFunction(v10, context);
      }
    }
    CFRelease(v10);
  }
  if (v6) {
    goto LABEL_12;
  }
  return context[0];
}

uint64_t IOHIDEventSystemConnectionGetProcName(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

void *IOHIDVirtualServiceClientCreateWithCallbacks(uint64_t cf, const void *a2, long long *a3, uint64_t a4, uint64_t a5)
{
  int valuePtr = 0;
  if (*(void *)(cf + 384) || *(void *)(cf + 400))
  {
    CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)cf);
    CFDataRef v11 = (const __CFData *)_IOHIDCreateBinaryData(v10, a2);
    CFDataRef v12 = v11;
    if (v11)
    {
      BytePtr = CFDataGetBytePtr(v11);
      int Length = CFDataGetLength(v12);
    }
    else
    {
      BytePtr = 0;
      int Length = 0;
    }
    os_unfair_recursive_lock_lock_with_options();
    if (io_hideventsystem_create_virtual_service(*(_DWORD *)(cf + 32), (uint64_t)BytePtr, Length, &valuePtr)|| !valuePtr)
    {
      mach_port_name_t v20 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        IOHIDVirtualServiceClientCreateWithCallbacks_cold_2();
      }
      Virtual = 0;
      CFNumberRef v16 = 0;
    }
    else
    {
      CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)cf);
      CFNumberRef v16 = CFNumberCreate(v15, kCFNumberSInt64Type, &valuePtr);
      if (v16)
      {
        CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)cf);
        Virtual = _IOHIDServiceClientCreateVirtual(v17, cf, v16, a3, a4, a5);
        if (Virtual) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(cf + 104), valuePtr, Virtual);
        }
        else {
          io_hideventsystem_remove_virtual_service(*(_DWORD *)(cf + 32), (uint64_t)valuePtr);
        }
      }
      else
      {
        Virtual = 0;
      }
    }
    os_unfair_recursive_lock_unlock();
    if (v12) {
      CFRelease(v12);
    }
    if (v16) {
      CFRelease(v16);
    }
  }
  else
  {
    unsigned int v21 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      IOHIDVirtualServiceClientCreateWithCallbacks_cold_1();
    }
    return 0;
  }
  return Virtual;
}

uint64_t io_hideventsystem_create_virtual_service(mach_port_t a1, uint64_t a2, int a3, void *a4)
{
  int v12 = 1;
  uint64_t v13 = a2;
  LODWORD(v14) = 16777472;
  HIDWORD(v14) = a3;
  uint64_t v15 = *MEMORY[0x1E4F14068];
  int v16 = a3;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x1118A00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v7 = mach_msg(&msg, 3162115, 0x38u, 0x34u, special_reply_port, 0, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!v7)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v8 = 4294966988;
      }
      else if (msg.msgh_id == 70126)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 44)
          {
            if (!msg.msgh_remote_port)
            {
              uint64_t v8 = HIDWORD(v13);
              if (!HIDWORD(v13))
              {
                *a4 = v14;
                return v8;
              }
              goto LABEL_25;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port) {
              BOOL v9 = 1;
            }
            else {
              BOOL v9 = HIDWORD(v13) == 0;
            }
            if (v9) {
              uint64_t v8 = 4294966996;
            }
            else {
              uint64_t v8 = HIDWORD(v13);
            }
            goto LABEL_25;
          }
        }
        uint64_t v8 = 4294966996;
      }
      else
      {
        uint64_t v8 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&msg);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v8 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    goto LABEL_25;
  }
  return v8;
}

void *_IOHIDServiceClientCreateVirtual(const __CFAllocator *a1, uint64_t a2, const void *a3, long long *a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    return 0;
  }
  Private = (void *)_IOHIDServiceClientCreatePrivate();
  if (!Private) {
    return Private;
  }
  uint64_t v13 = (char *)malloc_type_calloc(1uLL, 0x38uLL, 0x10800405737D6B9uLL);
  Private[8] = v13;
  if (!v13)
  {
    CFRelease(Private);
    return 0;
  }
  long long v14 = *a4;
  long long v15 = a4[1];
  if (*(void *)a4 == 2)
  {
    long long v16 = a4[2];
    *((void *)v13 + 6) = *((void *)a4 + 6);
    *((_OWORD *)v13 + 1) = v15;
    *((_OWORD *)v13 + 2) = v16;
    *(_OWORD *)uint64_t v13 = v14;
  }
  else
  {
    *((void *)v13 + 5) = *((void *)a4 + 4);
    *(_OWORD *)(v13 + 24) = v15;
    *(_OWORD *)(v13 + 8) = v14;
  }
  Private[1] = a2;
  Private[9] = a5;
  Private[10] = a6;
  Private[2] = CFRetain(a3);
  Private[12] = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  Private[11] = 0;
  Private[3] = 0;
  return Private;
}

void *_IOHIDServiceClientCreate(const __CFAllocator *a1, const void *a2, const __CFDictionary *a3, uint64_t a4)
{
  if (_IOHIDServiceClientCreate_onceToken == -1)
  {
    if (a2) {
      goto LABEL_3;
    }
    return 0;
  }
  dispatch_once(&_IOHIDServiceClientCreate_onceToken, &__block_literal_global_13);
  if (!a2) {
    return 0;
  }
LABEL_3:
  uint64_t Private = _IOHIDServiceClientCreatePrivate();
  BOOL v9 = (void *)Private;
  if (Private)
  {
    *(void *)(Private + 8) = a4;
    *(void *)(Private + 16) = CFRetain(a2);
    v9[12] = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    v9[11] = 0;
    v9[3] = 0;
    _IOHIDServiceClientCacheProperties((uint64_t)v9, a3);
  }
  return v9;
}

void _IOHIDServiceClientCacheProperties(uint64_t a1, CFDictionaryRef theDict)
{
  if (theDict)
  {
    LODWORD(valuePtr) = 0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"PrimaryUsagePage");
    if (Value && (v5 = Value, CFTypeID v6 = CFGetTypeID(Value), v6 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
      int v7 = valuePtr;
    }
    else
    {
      int v7 = 0;
    }
    *(_DWORD *)(a1 + 128) = v7;
    LODWORD(valuePtr) = 0;
    CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"PrimaryUsage");
    if (v8 && (CFNumberRef v9 = v8, v10 = CFGetTypeID(v8), v10 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
      int v11 = valuePtr;
    }
    else
    {
      int v11 = 0;
    }
    *(_DWORD *)(a1 + 132) = v11;
    CFArrayRef v12 = (const __CFArray *)CFDictionaryGetValue(theDict, @"DeviceUsagePairs");
    if (v12)
    {
      CFArrayRef v13 = v12;
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 == CFArrayGetTypeID())
      {
        uint64_t valuePtr = 0;
        p_uint64_t valuePtr = &valuePtr;
        uint64_t v21 = 0x2000000000;
        int Count = 0;
        int Count = CFArrayGetCount(v13);
        uint64_t v15 = *((unsigned int *)p_valuePtr + 6);
        if (v15)
        {
          long long v16 = malloc_type_calloc(1uLL, 8 * v15, 0x100004000313F17uLL);
          *(void *)(a1 + 136) = v16;
          if (v16)
          {
            CFAllocatorRef v17 = p_valuePtr;
            *(_DWORD *)(a1 + 144) = *((_DWORD *)p_valuePtr + 6);
            *((_DWORD *)v17 + 6) = 0;
            v18[0] = MEMORY[0x1E4F143A8];
            v18[1] = 0x40000000;
            v18[2] = ___IOHIDServiceClientCacheProperties_block_invoke;
            v18[3] = &unk_1E548AB88;
            v18[4] = &valuePtr;
            void v18[5] = a1;
            _IOHIDCFArrayApplyBlock(v13, v18);
          }
        }
        _Block_object_dispose(&valuePtr, 8);
      }
    }
  }
}

uint64_t _IOHIDServiceClientCreatePrivate()
{
  return MEMORY[0x1F4181648](HIDServiceClient);
}

CFDictionaryRef IOHIDEventSystemConnectionGetAttribute(uint64_t a1, const void *a2)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 184);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

void *IOHIDEventGetDataValueWithOptions(void *result, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = HIWORD(a2);
  if (result && a2 < 0x10000 || (CFDictionaryRef result = (void *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a3)) != 0)
  {
    uint64_t v5 = result[13] + 28;
    if (a2 == 1966083) {
      uint64_t v6 = result[13] + 28;
    }
    else {
      uint64_t v6 = 0;
    }
    if (a2 != 65540) {
      uint64_t v5 = 0;
    }
    if (v4 != 1) {
      uint64_t v5 = 0;
    }
    if (v4 == 30) {
      return (void *)v6;
    }
    else {
      return (void *)v5;
    }
  }
  return result;
}

id IOHIDSessionFilterUnregisterService(id result, uint64_t a2)
{
  uint64_t v3 = *((void *)result + 2);
  if (v3)
  {
    unsigned int v4 = *(uint64_t (**)(void, uint64_t))(*(void *)v3 + 96);
    if (v4) {
      return (id)v4(*((void *)result + 2), a2);
    }
  }
  if (*((void *)result + 7))
  {
    uint64_t v5 = (const char *)*((void *)result + 13);
    if (v5) {
      return objc_msgSend(*((id *)result + 7), v5, a2, 0);
    }
  }
  return result;
}

id IOHIDSessionFilterRegisterService(id result, uint64_t a2)
{
  uint64_t v3 = *((void *)result + 2);
  if (v3)
  {
    unsigned int v4 = *(uint64_t (**)(void, uint64_t))(*(void *)v3 + 88);
    if (v4) {
      return (id)v4(*((void *)result + 2), a2);
    }
  }
  if (*((void *)result + 7))
  {
    uint64_t v5 = (const char *)*((void *)result + 13);
    if (v5) {
      return objc_msgSend(*((id *)result + 7), v5, a2, 1);
    }
  }
  return result;
}

__CFDictionary *__FilterFunctionCopyPropertyForClient(__CFDictionary *result, uint64_t a2)
{
  if (!*(void *)(a2 + 8))
  {
    CFDictionaryRef result = IOHIDServiceFilterCopyPropertyForClient((uint64_t)result, *(CFTypeRef *)a2, *(void *)(a2 + 16));
    *(void *)(a2 + 8) = result;
  }
  return result;
}

__CFDictionary *IOHIDServiceFilterCopyPropertyForClient(uint64_t a1, CFTypeRef cf1, uint64_t a3)
{
  if (!CFEqual(cf1, @"HIDObjectUUID"))
  {
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 && (CFNumberRef v9 = *(uint64_t (**)(void))(*(void *)v8 + 88)) != 0)
    {
      CFTypeID v10 = (__CFString *)v9();
    }
    else
    {
      CFArrayRef v12 = *(void **)(a1 + 96);
      if (v12)
      {
        CFArrayRef v13 = (__CFString *)objc_msgSend(v12, *(SEL *)(a1 + 104), cf1, a3);
        CFTypeID v10 = v13;
        if (v13) {
          CFRetain(v13);
        }
      }
      else
      {
        CFTypeID v10 = 0;
      }
    }
    if (!CFEqual(cf1, @"ServiceFilterDebug")) {
      return (__CFDictionary *)v10;
    }
    CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable) {
      return (__CFDictionary *)v10;
    }
    int v11 = Mutable;
    if (v10)
    {
      if (_IOHIDIsSerializable((uint64_t)v10))
      {
        long long v16 = v11;
        CFAllocatorRef v17 = v10;
      }
      else
      {
        unint64_t v18 = _IOHIDLog();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          IOHIDServiceFilterCopyPropertyForClient_cold_1(a1, (uint64_t)v10, v18);
        }
        CFAllocatorRef v17 = @"not serializable";
        long long v16 = v11;
      }
      CFDictionaryAddValue(v16, @"plugin", v17);
      CFRelease(v10);
    }
    CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)a1);
    CFStringRef v20 = CFUUIDCreateString(v19, *(CFUUIDRef *)(a1 + 88));
    if (v20)
    {
      CFStringRef v21 = v20;
      CFDictionaryAddValue(v11, @"uuid", v20);
      CFRelease(v21);
    }
    unsigned int v22 = *(const void **)(a1 + 80);
    if (v22) {
      CFDictionaryAddValue(v11, @"name", v22);
    }
    _IOHIDDictionaryAddSInt32(v11, @"score", *(_DWORD *)(a1 + 40));
    _IOHIDDictionaryAddSInt32(v11, @"type", *(void *)(a1 + 16) == 0);
    return v11;
  }
  uint64_t v6 = *(const void **)(a1 + 88);
  if (!v6) {
    return 0;
  }

  return (__CFDictionary *)CFRetain(v6);
}

void __IOMIGMachPortChannelCallback(void *cf, uint64_t a2)
{
  if (a2 == 8)
  {
    CFRelease(cf);
  }
  else if (a2 == 2)
  {
    mach_msg_header_t msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
    __IOMIGMachPortPortCallback((int)msg, msg, v4, (CFIndex *)cf);
  }
}

void __IOMIGMachPortPortCallback(int a1, mach_msg_header_t *a2, int a3, CFIndex *cf)
{
  if (!cf) {
    return;
  }
  CFRetain(cf);
  uint64_t v6 = (mach_msg_header_t *)CFAllocatorAllocate(0, cf[8], 0);
  if (v6)
  {
    int v7 = v6;
    mach_port_t msgh_remote_port = a2->msgh_remote_port;
    v6->msgh_bits = a2->msgh_bits & 0x1F;
    v6->msgh_size = 36;
    *(void *)&v6->mach_port_t msgh_remote_port = msgh_remote_port;
    v6->msgh_id = a2->msgh_id + 100;
    if (a2->msgh_id == 70)
    {
      v6->msgh_bits = 0;
      v6->mach_port_t msgh_remote_port = 0;
      v6[1].mach_port_t msgh_remote_port = 0;
      p_mach_port_t msgh_remote_port = &v6[1].msgh_remote_port;
      CFTypeID v10 = (void (*)(CFIndex *, CFIndex))cf[11];
      if (!v10) {
        goto LABEL_22;
      }
      v10(cf, cf[12]);
    }
    else
    {
      uint64_t v11 = *MEMORY[0x1E4F14068];
      v6[1].mach_port_t msgh_remote_port = -303;
      p_mach_port_t msgh_remote_port = &v6[1].msgh_remote_port;
      *(void *)&v6[1].msgh_bits = v11;
      CFArrayRef v12 = (void (*)(CFIndex *, mach_msg_header_t *, mach_msg_header_t *, CFIndex))cf[9];
      if (!v12) {
        goto LABEL_21;
      }
      v12(cf, a2, v6, cf[10]);
    }
    if ((v7->msgh_bits & 0x80000000) == 0 && *p_msgh_remote_port)
    {
      if (*p_msgh_remote_port == -305) {
        goto LABEL_22;
      }
      a2->mach_port_t msgh_remote_port = 0;
      mach_msg_destroy(a2);
    }
    if (v7->msgh_remote_port)
    {
      if ((v7->msgh_bits & 0x1F) == 0x12) {
        mach_msg_option_t v13 = 1;
      }
      else {
        mach_msg_option_t v13 = 17;
      }
      if ((mach_msg(v7, v13, v7->msgh_size, 0, 0, 0, 0) - 268435459) > 1) {
        goto LABEL_22;
      }
      mach_port_name_t msgh_local_port = v7->msgh_local_port;
      a2 = v7;
      if (msgh_local_port - 1 <= 0xFFFFFFFD)
      {
        a2 = v7;
        if (((v7->msgh_bits >> 8) & 0x1F) - 17 <= 1)
        {
          mach_port_deallocate(*MEMORY[0x1E4F14960], msgh_local_port);
          a2 = v7;
        }
      }
      goto LABEL_21;
    }
    a2 = v7;
    if ((v7->msgh_bits & 0x80000000) != 0) {
LABEL_21:
    }
      mach_msg_destroy(a2);
LABEL_22:
    CFAllocatorDeallocate(0, v7);
  }

  CFRelease(cf);
}

uint64_t __IOHIDEventSystemClientMIGDemuxCallback(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3 = a2[5];
  if (v3 >= dword_1ED86F218 && v3 < unk_1ED86F21C) {
    LOBYTE(result) = iohideventsystem_client_server(a2, a3);
  }
  else {
    LOBYTE(result) = 0;
  }
  return result;
}

uint64_t iohideventsystem_client_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 75013) >= 0xFFFFFFF3
    && (uint64_t v5 = (void (*)(void))*(&_iohideventsystem_client_subsystem + 5 * (v4 - 75000) + 5)) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t _Xiohideventsystem_client_dispatch_virtual_service_copy_property(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 60))
  {
    int v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = _iohideventsystem_client_dispatch_virtual_service_copy_property(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52));
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _iohideventsystem_client_dispatch_virtual_service_copy_property(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, vm_offset_t *a5, _DWORD *a6)
{
  mach_vm_size_t v11 = a4;
  CFTypeID TypeID = CFStringGetTypeID();
  mach_msg_option_t v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a3, v11, TypeID);
  if (v13)
  {
    CFAllocatorRef v14 = v13;
    uint64_t v15 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    long long v16 = v15;
    if (v15)
    {
      CFTypeID v17 = CFGetTypeID(v15);
      uint64_t v18 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        uint64_t v18 = __kIOHIDEventSystemClientTypeID;
      }
      if (v17 == v18)
      {
        os_unfair_recursive_lock_lock_with_options();
        CFNumberRef Value = CFDictionaryGetValue(v16[13], a2);
        if (Value)
        {
          CFStringRef v20 = Value;
          CFRetain(Value);
          os_unfair_recursive_lock_unlock();
          CFStringRef v21 = (const void *)_IOHIDVirtualServiceClientCopyProperty(v20, (uint64_t)v14);
          *a6 = _IOHIDSerialize(v21, a5);
          CFRelease(v20);
          if (v21) {
            CFRelease(v21);
          }
        }
        else
        {
          os_unfair_recursive_lock_unlock();
          unsigned int v22 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_3();
          }
        }
        CFRelease(v14);
LABEL_12:
        CFRelease(v16);
        return 0;
      }
    }
    unsigned int v24 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
    }
    CFRelease(v14);
    if (v16) {
      goto LABEL_12;
    }
  }
  else
  {
    unsigned int v25 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_1();
    }
  }
  return 0;
}

const void *IOMIGMachPortCacheCopy(unsigned int a1)
{
  pthread_mutex_lock(&__ioPortCacheLock);
  CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)__ioPortCache, (const void *)a1);
  int v3 = Value;
  if (Value) {
    CFRetain(Value);
  }
  pthread_mutex_unlock(&__ioPortCacheLock);
  return v3;
}

CFTypeRef _IOHIDSerialize(CFTypeRef result, vm_offset_t *a2)
{
  if (result)
  {
    uint64_t result = _IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], result);
    if (result)
    {
      CFDataRef v3 = (const __CFData *)result;
      mach_msg_type_number_t dataCnt = 0;
      vm_size_t Length = CFDataGetLength((CFDataRef)result);
      vm_map_read_t v5 = *MEMORY[0x1E4F14960];
      BytePtr = CFDataGetBytePtr(v3);
      LODWORD(Length) = vm_read(v5, (vm_address_t)BytePtr, Length, a2, &dataCnt);
      CFRelease(v3);
      if (Length)
      {
        uint64_t result = 0;
        *a2 = 0;
      }
      else
      {
        return (CFTypeRef)dataCnt;
      }
    }
  }
  return result;
}

uint64_t _IOHIDVirtualServiceClientCopyProperty(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[8];
  if (v2 && (CFDataRef v3 = *(uint64_t (**)(void, void, void *, uint64_t))(v2 + 24)) != 0) {
    return v3(a1[9], a1[10], a1, a2);
  }
  else {
    return 0;
  }
}

uint64_t __IOHIDEventSystemConnectionPortDemuxCallback(uint64_t (*a1)(CFTypeRef, uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t (**cf)(CFTypeRef, uint64_t, uint64_t, uint64_t))
{
  CFRetain(cf);
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v8 = cf[6];
  if (v8 && cf[4] == a1)
  {
    CFTypeID v10 = cf[7];
    os_unfair_recursive_lock_unlock();
    uint64_t v9 = v8(cf, a2, a3, (uint64_t)v10);
    os_unfair_recursive_lock_lock_with_options();
  }
  else
  {
    uint64_t v9 = 0;
  }
  os_unfair_recursive_lock_unlock();
  CFRelease(cf);
  return v9;
}

uint64_t __IOHIDEventSystemConnectionDemuxCallback(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3 = a2[5];
  if (v3 >= dword_1ED86F440 && v3 < unk_1ED86F444) {
    LOBYTE(result) = iohideventsystem_server(a2, a3);
  }
  else {
    LOBYTE(result) = 0;
  }
  return result;
}

uint64_t iohideventsystem_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 70029) >= 0xFFFFFFE3
    && (vm_map_read_t v5 = (void (*)(void))*(&_iohideventsystem_subsystem + 5 * (v4 - 70000) + 5)) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t _Xiohideventsystem_client_dispatch_service_removal(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v4 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v4;
    goto LABEL_9;
  }
  if (*(unsigned char *)(result + 39) != 1 || (CFIndex v3 = *(unsigned int *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    int v4 = -300;
    goto LABEL_8;
  }
  uint64_t result = _iohideventsystem_client_dispatch_service_removal(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3);
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _iohideventsystem_client_dispatch_service_removal(unsigned int a1, UInt8 *bytes, CFIndex length)
{
  CFPropertyListRef v4 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  if (v4)
  {
    vm_map_read_t v5 = v4;
    uint64_t v6 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    if (v6)
    {
      int v7 = v6;
      CFTypeID v8 = CFGetTypeID(v6);
      uint64_t v9 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        uint64_t v9 = __kIOHIDEventSystemClientTypeID;
      }
      if (v8 == v9)
      {
        os_unfair_recursive_lock_lock_with_options();
        CFNumberRef Value = CFDictionaryGetValue(v7[12], v5);
        os_unfair_recursive_lock_unlock();
        if (Value)
        {
          _IOHIDServiceClientDispatchServiceRemoval(Value);
          os_unfair_recursive_lock_lock_with_options();
          CFDictionaryRemoveValue(v7[12], v5);
          os_unfair_recursive_lock_unlock();
        }
      }
      CFRelease(v7);
    }
    CFRelease(v5);
  }
  return 0;
}

void _IOHIDServiceClientReleasePrivate(void *a1)
{
  IOHIDServiceClientFastPathInvalidate((uint64_t)a1);
  int v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  CFIndex v3 = (const void *)a1[12];
  if (v3)
  {
    CFRelease(v3);
    a1[12] = 0;
  }
  CFPropertyListRef v4 = (const void *)a1[5];
  if (v4) {
    _Block_release(v4);
  }
  vm_map_read_t v5 = (void *)a1[8];
  if (v5) {
    free(v5);
  }
  uint64_t v6 = (const void *)a1[15];
  if (v6) {
    _Block_release(v6);
  }
  int v7 = (void *)a1[17];
  if (v7)
  {
    free(v7);
  }
}

IOCFPlugInInterface **IOHIDServiceClientFastPathInvalidate(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 40))(v2, 0);
    (*(void (**)(void))(**(void **)(a1 + 104) + 24))(*(void *)(a1 + 104));
    *(void *)(a1 + 104) = 0;
  }
  uint64_t result = *(IOCFPlugInInterface ***)(a1 + 112);
  if (result)
  {
    uint64_t result = (IOCFPlugInInterface **)IODestroyPlugInInterface(result);
    *(void *)(a1 + 112) = 0;
  }
  return result;
}

uint64_t _io_hideventsystem_copy_property_for_service(unsigned int a1, UInt8 *bytes, CFIndex length, UInt8 *a4, unsigned int a5, vm_offset_t *a6, _DWORD *a7, _DWORD *a8)
{
  *a7 = 0;
  LODWORD(v14) = -536870206;
  CFPropertyListRef v15 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID v17 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  uint64_t v18 = v17;
  if (v17 && v15)
  {
    CFAllocatorRef v19 = IOMIGMachPortCacheCopy(a1);
    CFStringRef v20 = v19;
    if (v19)
    {
      CFTypeID v21 = CFGetTypeID(v19);
      uint64_t v22 = IOHIDEventSystemConnectionGetTypeID();
      if (a6)
      {
        if (v21 == v22)
        {
          uint64_t System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v20);
          if (System)
          {
            unsigned int v24 = IOHIDEventSystemCopyService(System, v15);
            if (v24)
            {
              unsigned int v25 = v24;
              if (IOHIDEventSystemConnectionGetType((uint64_t)v20) != 4
                || CFSetContainsValue((CFSetRef)__whiteListSet, v18))
              {
                CFAllocatorRef v14 = (const void *)_IOHIDServiceCopyPropertyForClient((uint64_t)v25, v18, v20);
                *a7 = _IOHIDSerialize(v14, a6);
                if (v14)
                {
                  CFRelease(v14);
                  LODWORD(v14) = 0;
                }
              }
              CFRelease(v18);
              CFRelease(v25);
              CFRelease(v15);
LABEL_13:
              CFRelease(v20);
              goto LABEL_14;
            }
            LODWORD(v14) = -536870160;
          }
          else
          {
            LODWORD(v14) = -536870185;
          }
        }
      }
    }
    CFRelease(v18);
    CFRelease(v15);
    if (!v20) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (v17) {
    CFRelease(v17);
  }
  CFStringRef v20 = v15;
  if (v15) {
    goto LABEL_13;
  }
LABEL_14:
  *a8 = v14;
  return 0;
}

const void *_IOHIDUnserializeAndVMDeallocWithTypeID(UInt8 *a1, mach_vm_size_t a2, uint64_t a3)
{
  CFPropertyListRef v4 = _IOHIDUnserializeAndVMDealloc(a1, a2);
  vm_map_read_t v5 = v4;
  if (v4 && CFGetTypeID(v4) != a3)
  {
    CFRelease(v5);
    return 0;
  }
  return v5;
}

CFPropertyListRef _IOHIDUnserializeAndVMDealloc(UInt8 *bytes, mach_vm_size_t length)
{
  CFPropertyListRef v2 = 0;
  if (bytes && length)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, length, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v6)
    {
      int v7 = v6;
      if (CFReadStreamOpen(v6))
      {
        CFPropertyListFormat format = kCFPropertyListBinaryFormat_v1_0;
        CFPropertyListRef v2 = CFPropertyListCreateFromStream(v5, v7, length, 2uLL, &format, 0);
        CFReadStreamClose(v7);
      }
      else
      {
        CFPropertyListRef v2 = 0;
      }
      CFRelease(v7);
    }
    else
    {
      CFPropertyListRef v2 = 0;
    }
    mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)bytes, length);
  }
  return v2;
}

uint64_t _IOHIDEventSystemConnectionGetSystem(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

const void *IOHIDEventSystemCopyService(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  CFAllocatorRef v5 = Value;
  if (Value)
  {
    CFRetain(Value);
    os_unfair_recursive_lock_unlock();
    if (_IOHIDServiceIsInactive((uint64_t)v5))
    {
      CFRelease(v5);
      return 0;
    }
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
  return v5;
}

uint64_t _Xio_hideventsystem_copy_property_for_service(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    int v3 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_12;
  }
  if (*(unsigned char *)(result + 39) != 1
    || *(unsigned char *)(result + 55) != 1
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 68)
    || *(_DWORD *)(result + 56) != *(_DWORD *)(result + 72))
  {
    int v3 = -300;
    goto LABEL_11;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = _io_hideventsystem_copy_property_for_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(unsigned int *)(result + 40), *(UInt8 **)(result + 44), *(_DWORD *)(result + 56), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52), (_DWORD *)(a2 + 56));
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_12:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void _IOHIDEventSystemConnectionAddServices(uint64_t a1, const __CFArray *a2, const void *a3)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(CFSetRef **)(a1 + 8);
  mach_port_t v7 = *(_DWORD *)(a1 + 40);
  int v8 = *(_DWORD *)(a1 + 176);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFArrayRef v10 = Mutable;
    mach_port_t v39 = v7;
    v41[0] = MEMORY[0x1E4F143A8];
    v41[1] = 0x40000000;
    v41[2] = ___IOHIDEventSystemConnectionAddServices_block_invoke;
    v41[3] = &__block_descriptor_tmp_28_0;
    v41[4] = a1;
    v41[5] = Mutable;
    _IOHIDCFArrayApplyBlock(a2, v41);
    if (!CFArrayGetCount(v10)) {
      goto LABEL_29;
    }
    unsigned __int16 v40 = a3;
    CFIndex Count = CFArrayGetCount(v10);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
        CFPropertyListRef v15 = ValueAtIndex;
        if (v8 == 2)
        {
          CFNumberRef v16 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient((uint64_t)ValueAtIndex, @"QueueSize", (const void *)a1);
          if (v16)
          {
            CFNumberRef v17 = v16;
            int valuePtr = 0;
            CFNumberGetValue(v16, kCFNumberSInt32Type, &valuePtr);
            CFRelease(v17);
            if (!valuePtr) {
              continue;
            }
          }
        }
        os_unfair_recursive_lock_lock_with_options();
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 80), v15);
        os_unfair_recursive_lock_unlock();
        _IOHIDEventSystemAddServiceForConnection(v6, (uint64_t)v15, (const void *)a1);
      }
    }
    if (!v40) {
      goto LABEL_29;
    }
    CFAllocatorRef v18 = CFGetAllocator((CFTypeRef)a1);
    CFTypeRef v19 = _IOHIDCreateBinaryData(v18, v40);
    if (!v19) {
      goto LABEL_29;
    }
    CFStringRef v20 = v19;
    CFArrayRef v21 = _IOHIDCopyServiceClientInfo(v10);
    if (!v21)
    {
LABEL_28:
      CFRelease(v20);
LABEL_29:
      CFRelease(v10);
      return;
    }
    CFArrayRef v22 = v21;
    CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
    CFDataRef v24 = (const __CFData *)_IOHIDCreateBinaryData(v23, v22);
    if (!v24)
    {
LABEL_27:
      CFRelease(v22);
      goto LABEL_28;
    }
    CFDataRef v25 = v24;
    if (!*(_DWORD *)(a1 + 448))
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)v20);
      int Length = CFDataGetLength((CFDataRef)v20);
      unsigned int v28 = CFDataGetBytePtr(v25);
      int v29 = CFDataGetLength(v25);
      int v30 = iohideventsystem_client_dispatch_notification_results(v39, (uint64_t)BytePtr, Length, (uint64_t)v28, v29, 0);
      int v31 = v30;
      if ((v30 - 268435459) < 2)
      {
        unsigned int v36 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v37 = *(void *)(a1 + 168);
          int valuePtr = 136315394;
          uint64_t v43 = v37;
          __int16 v44 = 1024;
          int v45 = v31;
          unsigned int v34 = v36;
          os_log_type_t v35 = OS_LOG_TYPE_DEFAULT;
          goto LABEL_22;
        }
LABEL_25:
        __IOHIDEventSystemConnectionCheckServerStatus(v31, a1);
        goto LABEL_26;
      }
      if (v30)
      {
        if (v30 != 268451843)
        {
          unsigned int v38 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
            _IOHIDEventSystemConnectionAddServices_cold_1();
          }
          goto LABEL_25;
        }
        unsigned int v32 = _IOHIDLogCategory(9u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          uint64_t v33 = *(void *)(a1 + 168);
          int valuePtr = 136315394;
          uint64_t v43 = v33;
          __int16 v44 = 1024;
          int v45 = 268451843;
          unsigned int v34 = v32;
          os_log_type_t v35 = OS_LOG_TYPE_INFO;
LABEL_22:
          _os_log_impl(&dword_18B46C000, v34, v35, "%s: iohideventsystem_client_dispatch_notification_results:0x%x", (uint8_t *)&valuePtr, 0x12u);
          goto LABEL_25;
        }
        goto LABEL_25;
      }
    }
LABEL_26:
    CFRelease(v25);
    goto LABEL_27;
  }
}

uint64_t _IOHIDEventSystemAddServiceForConnection(CFSetRef *a1, uint64_t a2, const void *a3)
{
  os_unfair_recursive_lock_lock_with_options();
  int v6 = CFSetContainsValue(a1[7], a3);
  int v7 = CFSetContainsValue(a1[8], a3);
  CFArrayRef v8 = a1[10];
  v12.length = CFArrayGetCount(v8);
  v12.location = 0;
  FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v8, v12, a3);
  uint64_t result = os_unfair_recursive_lock_unlock();
  if (v6) {
    uint64_t result = _IOHIDServiceAddConnection(a2, a3, 0);
  }
  if (v7) {
    uint64_t result = _IOHIDServiceAddConnection(a2, a3, 2);
  }
  if (FirstIndexOfValue != -1)
  {
    return _IOHIDServiceAddConnection(a2, a3, 1);
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionRemoveService(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  uint64_t RegistryID = (const void *)IOHIDServiceGetRegistryID((uint64_t)a2);
  CFDataRef v6 = (const __CFData *)_IOHIDCreateBinaryData(v4, RegistryID);
  if (v6)
  {
    CFDataRef v7 = v6;
    if (!*(_DWORD *)(a1 + 448))
    {
      mach_port_t v8 = *(_DWORD *)(a1 + 40);
      BytePtr = CFDataGetBytePtr(v6);
      int Length = CFDataGetLength(v7);
      int v11 = iohideventsystem_client_dispatch_service_removal(v8, (uint64_t)BytePtr, Length, 0);
      int v12 = v11;
      if ((v11 - 268435459) < 2)
      {
LABEL_8:
        __IOHIDEventSystemConnectionCheckServerStatus(v12, a1);
        goto LABEL_9;
      }
      if (v11)
      {
        if (v11 != 268451843)
        {
          mach_msg_option_t v13 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
            _IOHIDEventSystemConnectionRemoveService_cold_1();
          }
        }
        goto LABEL_8;
      }
    }
LABEL_9:
    CFRelease(v7);
  }
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 80), a2);
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDServiceCopyProperty(uint64_t a1, const void *a2)
{
  return _IOHIDServiceCopyPropertyForClient(a1, a2, (const void *)*MEMORY[0x1E4F1D260]);
}

uint64_t IOHIDServiceGetRegistryID(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

void __IOHIDEventSystemConnectionCheckServerStatus(int a1, uint64_t a2)
{
  if (a1 == -308)
  {
    int v3 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      __IOHIDEventSystemConnectionCheckServerStatus_cold_1();
    }
    *(_DWORD *)(a2 + 448) = 1;
  }
}

uint64_t iohideventsystem_client_dispatch_service_removal(mach_port_t a1, uint64_t a2, int a3, mach_msg_timeout_t a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v11 = 1;
  uint64_t v12 = a2;
  int v13 = 16777472;
  int v14 = a3;
  uint64_t v15 = *MEMORY[0x1E4F14068];
  int v16 = a3;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&v10.msgh_bits = 2147489043;
  v10.mach_port_t msgh_remote_port = a1;
  v10.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&v10.msgh_voucher_port = 0x124F900000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v10);
    mach_port_t special_reply_port = v10.msgh_local_port;
  }
  uint64_t v7 = mach_msg(&v10, 3162515, 0x38u, 0x2Cu, special_reply_port, a4, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0) {
    goto LABEL_13;
  }
  if (v7)
  {
    mig_dealloc_special_reply_port();
LABEL_13:
    if ((v8 - 268435459) > 1) {
      return v8;
    }
    if ((v10.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v10.msgh_local_port);
    }
LABEL_18:
    mach_msg_destroy(&v10);
    return v8;
  }
  if (v10.msgh_id == 71)
  {
    uint64_t v8 = 4294966988;
    goto LABEL_18;
  }
  if (v10.msgh_id != 75101)
  {
    uint64_t v8 = 4294966995;
    goto LABEL_18;
  }
  uint64_t v8 = 4294966996;
  if ((v10.msgh_bits & 0x80000000) != 0) {
    goto LABEL_18;
  }
  if (*(void *)&v10.msgh_size != 36) {
    goto LABEL_18;
  }
  uint64_t v8 = HIDWORD(v12);
  if (HIDWORD(v12)) {
    goto LABEL_18;
  }
  return v8;
}

CFDataRef _IOHIDEventSystemClientCopyPropertyForService(uint64_t a1, IOHIDServiceClientRef service, const void *a3)
{
  CFDataRef result = 0;
  CFIndex length = 0;
  bytes = 0;
  if (a1)
  {
    if (service)
    {
      if (a3)
      {
        CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFTypeRef RegistryID = IOHIDServiceClientGetRegistryID(service);
        CFDataRef result = (const __CFData *)_IOHIDCreateBinaryData(v6, RegistryID);
        if (result)
        {
          CFDataRef v8 = result;
          BytePtr = CFDataGetBytePtr(result);
          int v10 = CFDataGetLength(v8);
          CFDataRef v11 = (const __CFData *)_IOHIDCreateBinaryData(v6, a3);
          if (v11)
          {
            CFDataRef v12 = v11;
            int v13 = CFDataGetBytePtr(v11);
            int v14 = CFDataGetLength(v12);
            os_unfair_recursive_lock_lock_with_options();
            uint64_t v15 = io_hideventsystem_copy_property_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v10, (uint64_t)v13, v14, &bytes, (_DWORD *)&length + 1, &length);
            int v16 = v15;
            if (v15 == 268435459)
            {
              if (*(void *)(a1 + 384))
              {
                int v16 = 268435459;
              }
              else
              {
                int v16 = 268435459;
                if (!*(void *)(a1 + 400))
                {
                  __IOHIDEventSystemClientTerminationCallback(v15, a1, 0);
                  int v16 = io_hideventsystem_copy_property_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v10, (uint64_t)v13, v14, &bytes, (_DWORD *)&length + 1, &length);
                }
              }
            }
            os_unfair_recursive_lock_unlock();
            CFRelease(v12);
          }
          else
          {
            int v16 = 0;
          }
          CFRelease(v8);
          if (v16 | length) {
            return 0;
          }
          else {
            return (const __CFData *)_IOHIDUnserializeAndVMDealloc(bytes, HIDWORD(length));
          }
        }
      }
    }
  }
  return result;
}

CFTypeRef _IOHIDCreateBinaryData(CFAllocatorRef bufferAllocator, const void *a2)
{
  CFTypeRef v2 = a2;
  CFStringRef errorString = 0;
  if (a2)
  {
    int v3 = CFWriteStreamCreateWithAllocatedBuffers(bufferAllocator, bufferAllocator);
    if (v3)
    {
      CFAllocatorRef v4 = v3;
      if (CFWriteStreamOpen(v3))
      {
        CFPropertyListWriteToStream(v2, v4, kCFPropertyListBinaryFormat_v1_0, &errorString);
        CFWriteStreamClose(v4);
        CFTypeRef v2 = CFWriteStreamCopyProperty(v4, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
      }
      else
      {
        CFTypeRef v2 = 0;
      }
      CFRelease(v4);
      if (errorString)
      {
        CFAllocatorRef v5 = _IOHIDLog();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
          _IOHIDCreateBinaryData_cold_1((uint64_t *)&errorString, v5);
        }
        CFRelease(errorString);
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFTypeRef IOHIDServiceClientGetRegistryID(IOHIDServiceClientRef service)
{
  return (CFTypeRef)*((void *)service + 2);
}

uint64_t io_hideventsystem_copy_property_for_service(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, void *a6, _DWORD *a7, _DWORD *a8)
{
  int v18 = 2;
  uint64_t v19 = a2;
  int v20 = 16777472;
  int v21 = a3;
  uint64_t v22 = a4;
  int v23 = 16777472;
  int v24 = a5;
  uint64_t v25 = *MEMORY[0x1E4F14068];
  int v26 = a3;
  int v27 = a5;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&v17.msgh_bits = 2147489043;
  v17.mach_port_t msgh_remote_port = a1;
  v17.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&v17.msgh_voucher_port = 0x1117B00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v17);
    mach_port_t special_reply_port = v17.msgh_local_port;
  }
  uint64_t v13 = mach_msg(&v17, 3162115, 0x4Cu, 0x44u, special_reply_port, 0, 0);
  uint64_t v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!v13)
    {
      if (v17.msgh_id == 71)
      {
        uint64_t v14 = 4294966988;
      }
      else if (v17.msgh_id == 70111)
      {
        if ((v17.msgh_bits & 0x80000000) == 0)
        {
          if (v17.msgh_size == 36)
          {
            uint64_t v14 = 4294966996;
            if (HIDWORD(v19))
            {
              if (v17.msgh_remote_port) {
                uint64_t v14 = 4294966996;
              }
              else {
                uint64_t v14 = HIDWORD(v19);
              }
            }
          }
          else
          {
            uint64_t v14 = 4294966996;
          }
          goto LABEL_26;
        }
        uint64_t v14 = 4294966996;
        if (v18 == 1 && *(void *)&v17.msgh_size == 60 && HIBYTE(v20) == 1)
        {
          int v15 = v21;
          if (v21 == v23)
          {
            uint64_t v14 = 0;
            *a6 = v19;
            *a7 = v15;
            *a8 = v24;
            return v14;
          }
        }
      }
      else
      {
        uint64_t v14 = 4294966995;
      }
LABEL_26:
      mach_msg_destroy(&v17);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v14 - 268435459) <= 1)
  {
    if ((v17.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v17.msgh_local_port);
    }
    goto LABEL_26;
  }
  return v14;
}

CFArrayRef _IOHIDCopyServiceClientInfo(const __CFArray *cf)
{
  CFArrayRef v1 = cf;
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  if (cf)
  {
    CFAllocatorRef v2 = CFGetAllocator(cf);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
    v7[3] = (uint64_t)Mutable;
    if (Mutable)
    {
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 0x40000000;
      v5[2] = ___IOHIDCopyServiceClientInfo_block_invoke;
      v5[3] = &unk_1E548AB40;
      v5[4] = &v6;
      _IOHIDCFArrayApplyBlock(v1, v5);
      CFArrayRef v1 = (const __CFArray *)v7[3];
    }
    else
    {
      CFArrayRef v1 = 0;
    }
  }
  _Block_object_dispose(&v6, 8);
  return v1;
}

uint64_t iohideventsystem_client_dispatch_notification_results(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, mach_msg_timeout_t a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v13 = 2;
  uint64_t v14 = a2;
  int v15 = 16777472;
  int v16 = a3;
  uint64_t v17 = a4;
  int v18 = 16777472;
  int v19 = a5;
  uint64_t v20 = *MEMORY[0x1E4F14068];
  int v21 = a3;
  int v22 = a5;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x124F800000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v9 = mach_msg(&msg, 3162515, 0x4Cu, 0x2Cu, special_reply_port, a6, 0);
  uint64_t v10 = v9;
  if ((v9 - 268435458) <= 0xE && ((1 << (v9 - 2)) & 0x4003) != 0) {
    goto LABEL_14;
  }
  if (v9)
  {
    mig_dealloc_special_reply_port();
LABEL_14:
    if ((v10 - 268435459) > 1) {
      return v10;
    }
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
LABEL_19:
    mach_msg_destroy(&msg);
    return v10;
  }
  if (msg.msgh_id == 71)
  {
    uint64_t v10 = 4294966988;
    goto LABEL_19;
  }
  if (msg.msgh_id != 75100)
  {
    uint64_t v10 = 4294966995;
    goto LABEL_19;
  }
  uint64_t v10 = 4294966996;
  if ((msg.msgh_bits & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (msg.msgh_size != 36) {
    goto LABEL_19;
  }
  if (msg.msgh_remote_port) {
    goto LABEL_19;
  }
  uint64_t v10 = HIDWORD(v14);
  if (HIDWORD(v14)) {
    goto LABEL_19;
  }
  return v10;
}

uint64_t _IOHIDServiceAddConnection(uint64_t result, const void *a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a3 > 2) {
    return result;
  }
  uint64_t v5 = result;
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(result + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v21, v22);
  }
  ++**(_DWORD **)(v5 + 72);
  if ((*(unsigned char *)(v5 + 224) & 1) == 0)
  {
    uint64_t v6 = *(void *)(v5 + 368);
    if (a3 != 1)
    {
      uint64_t v12 = a3;
      uint64_t v13 = *(void *)(v6 + 8 * a3);
      CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)v5);
      CFAllocatorRef v15 = v14;
      if (v13)
      {
        CFIndex Count = CFSetGetCount(*(CFSetRef *)(*(void *)(v5 + 368) + 8 * v12));
        MutableCFSetRef Copy = CFSetCreateMutableCopy(v15, Count + 1, *(CFSetRef *)(*(void *)(v5 + 368) + 8 * v12));
        CFRelease(*(CFTypeRef *)(*(void *)(v5 + 368) + 8 * v12));
      }
      else
      {
        MutableCFSetRef Copy = CFSetCreateMutable(v14, 0, MEMORY[0x1E4F1D548]);
        if (!MutableCopy) {
          goto LABEL_17;
        }
      }
      CFSetAddValue(MutableCopy, a2);
LABEL_13:
      *(void *)(*(void *)(v5 + 368) + 8 * v12) = MutableCopy;
      uint64_t v17 = *(void **)(v5 + 480);
      if (v17)
      {
        int v18 = *(const char **)(v5 + 560);
        if (v18) {
          objc_msgSend(v17, v18, a2, 1);
        }
      }
      CFArrayRef v19 = *(const __CFArray **)(v5 + 256);
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 0x40000000;
      v20[2] = ___IOHIDServiceAddConnection_block_invoke;
      v20[3] = &__block_descriptor_tmp_129;
      v20[4] = a2;
      _IOHIDCFArrayApplyBlock(v19, v20);
      goto LABEL_17;
    }
    uint64_t v7 = *(void *)(v6 + 8);
    CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)v5);
    CFAllocatorRef v9 = v8;
    if (v7)
    {
      CFIndex v10 = CFArrayGetCount(*(CFArrayRef *)(*(void *)(v5 + 368) + 8));
      MutableCFSetRef Copy = CFArrayCreateMutableCopy(v9, v10 + 1, *(CFArrayRef *)(*(void *)(v5 + 368) + 8));
      CFRelease(*(CFTypeRef *)(*(void *)(v5 + 368) + 8));
LABEL_10:
      CFArrayAppendValue(MutableCopy, a2);
      v24.CFIndex length = CFArrayGetCount(MutableCopy);
      v24.location = 0;
      CFArraySortValues(MutableCopy, v24, (CFComparatorFunction)_IOHIDEventSystemConnectionEventFilterCompare, 0);
      uint64_t v12 = 1;
      goto LABEL_13;
    }
    MutableCFSetRef Copy = CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
    if (MutableCopy) {
      goto LABEL_10;
    }
  }
LABEL_17:
  CFDataRef result = *(void *)(v5 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    CFDataRef result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v21, v22);
    }
  }
  return result;
}

uint64_t _Xiohideventsystem_client_dispatch_notification_results(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    int v5 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v5;
    goto LABEL_11;
  }
  if (*(unsigned char *)(result + 39) != 1
    || *(unsigned char *)(result + 55) != 1
    || (CFIndex v3 = *(unsigned int *)(result + 40), v3 != *(_DWORD *)(result + 68))
    || (unsigned int v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 72)))
  {
    int v5 = -300;
    goto LABEL_10;
  }
  CFDataRef result = _iohideventsystem_client_dispatch_notification_results(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, *(UInt8 **)(result + 44), v4);
  *(_DWORD *)(a2 + 32) = result;
LABEL_11:
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _iohideventsystem_client_dispatch_notification_results(unsigned int a1, UInt8 *bytes, CFIndex length, UInt8 *a4, unsigned int a5)
{
  CFPropertyListRef v8 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  CFTypeID TypeID = CFArrayGetTypeID();
  CFArrayRef v10 = (const __CFArray *)_IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  CFArrayRef v11 = v10;
  if (v8 && v10)
  {
    uint64_t v12 = IOMIGMachPortCacheCopy(a1);
    if (v12)
    {
      uint64_t v13 = (uint64_t)v12;
      CFTypeID v14 = CFGetTypeID(v12);
      uint64_t v15 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        uint64_t v15 = __kIOHIDEventSystemClientTypeID;
      }
      if (v14 == v15)
      {
        os_unfair_recursive_lock_lock_with_options();
        CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v13 + 88), v8);
        os_unfair_recursive_lock_unlock();
        if (Value)
        {
          __IOHIDEventSystemClientCacheServices(v13, v11);
          os_unfair_recursive_lock_lock_with_options();
          if (*(void *)(v13 + 168) || *(void *)(v13 + 176))
          {
            v18[0] = MEMORY[0x1E4F143A8];
            v18[1] = 0x40000000;
            v18[2] = ___iohideventsystem_client_dispatch_notification_results_block_invoke;
            v18[3] = &__block_descriptor_tmp_34_0;
            v18[4] = v13;
            _IOHIDCFArrayApplyBlock(v11, v18);
          }
          os_unfair_recursive_lock_unlock();
        }
      }
      CFRelease((CFTypeRef)v13);
    }
    goto LABEL_13;
  }
  if (v8) {
LABEL_13:
  }
    CFRelease(v8);
  if (v11) {
    CFRelease(v11);
  }
  return 0;
}

void __IOHIDEventSystemClientCacheServices(uint64_t a1, const __CFArray *a2)
{
  if (a2)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 0x40000000;
    v2[2] = ____IOHIDEventSystemClientCacheServices_block_invoke;
    v2[3] = &__block_descriptor_tmp_124;
    v2[4] = a1;
    _IOHIDCFArrayApplyBlock(a2, v2);
  }
}

uint64_t _IOHIDServiceClientDispatchServiceRemoval(void *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = a1[5];
  if (v2)
  {
    (*(void (**)(uint64_t, void, void, void *))(v2 + 16))(v2, a1[6], a1[7], a1);
  }
  else
  {
    CFIndex v3 = (void (*)(void, void, void *))a1[4];
    if (v3) {
      v3(a1[6], a1[7], a1);
    }
  }

  return os_unfair_recursive_lock_unlock();
}

uint64_t _Xiohideventsystem_client_dispatch_virtual_service_set_property(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    int v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    uint64_t v4 = *MEMORY[0x1E4F14068];
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 60)))
  {
    int v5 = -300;
    goto LABEL_9;
  }
  CFDataRef result = _iohideventsystem_client_dispatch_virtual_service_set_property(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(UInt8 **)(result + 28), v3, (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  uint64_t v4 = *MEMORY[0x1E4F14068];
  if (!result)
  {
    *(void *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_10:
  *(void *)(a2 + 24) = v4;
  return result;
}

uint64_t _iohideventsystem_client_dispatch_virtual_service_set_property(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, _DWORD *a5)
{
  mach_vm_size_t v9 = a4;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFDictionaryRef v11 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a3, v9, TypeID);
  if (v11)
  {
    CFDictionaryRef v12 = v11;
    uint64_t v13 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    CFTypeID v14 = v13;
    if (v13)
    {
      CFTypeID v15 = CFGetTypeID(v13);
      uint64_t v16 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        uint64_t v16 = __kIOHIDEventSystemClientTypeID;
      }
      if (v15 == v16)
      {
        CFNumberRef Value = CFDictionaryGetValue(v12, @"Key");
        int v18 = CFDictionaryGetValue(v12, @"Value");
        if (Value)
        {
          uint64_t v19 = (uint64_t)v18;
          os_unfair_recursive_lock_lock_with_options();
          uint64_t v20 = CFDictionaryGetValue(v14[13], a2);
          if (v20)
          {
            uint64_t v21 = v20;
            CFRetain(v20);
            os_unfair_recursive_lock_unlock();
            *a5 = _IOHIDVirtualServiceClientSetProperty(v21, (uint64_t)Value, v19);
            CFRelease(v21);
          }
          else
          {
            os_unfair_recursive_lock_unlock();
            *a5 = -536870208;
            int v22 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
              _iohideventsystem_client_dispatch_virtual_service_set_property_cold_4();
            }
          }
        }
        else
        {
          *a5 = -536870212;
          int v26 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            _iohideventsystem_client_dispatch_virtual_service_set_property_cold_3();
          }
        }
        CFRelease(v12);
LABEL_12:
        CFRelease(v14);
        return 0;
      }
    }
    *a5 = -536870206;
    CFRange v24 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
    }
    CFRelease(v12);
    if (v14) {
      goto LABEL_12;
    }
  }
  else
  {
    *a5 = -536870206;
    uint64_t v25 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_1();
    }
  }
  return 0;
}

uint64_t _IOHIDVirtualServiceClientSetProperty(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[8];
  if (v3 && (uint64_t v4 = *(uint64_t (**)(void, void, void *, uint64_t, uint64_t))(v3 + 16)) != 0) {
    return v4(a1[9], a1[10], a1, a2, a3);
  }
  else {
    return 0;
  }
}

uint64_t _Xio_hideventsystem_set_properties_for_service(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    int v6 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v6;
    uint64_t v5 = *MEMORY[0x1E4F14068];
    goto LABEL_12;
  }
  if (*(unsigned char *)(result + 39) != 1
    || *(unsigned char *)(result + 55) != 1
    || (CFIndex v3 = *(unsigned int *)(result + 40), v3 != *(_DWORD *)(result + 68))
    || (unsigned int v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 72)))
  {
    int v6 = -300;
    goto LABEL_11;
  }
  CFDataRef result = _io_hideventsystem_set_properties_for_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, *(UInt8 **)(result + 44), v4, (int *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  uint64_t v5 = *MEMORY[0x1E4F14068];
  if (!result)
  {
    *(void *)(a2 + 24) = v5;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_12:
  *(void *)(a2 + 24) = v5;
  return result;
}

uint64_t _io_hideventsystem_set_properties_for_service(unsigned int a1, UInt8 *bytes, CFIndex length, UInt8 *a4, unsigned int a5, int *a6)
{
  int v10 = -536870206;
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2000000000;
  int v27 = -536870212;
  CFPropertyListRef v11 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  uint64_t v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  CFTypeID v14 = v13;
  if (v11 && v13)
  {
    CFTypeID v15 = IOMIGMachPortCacheCopy(a1);
    if (!v15)
    {
      *((_DWORD *)v25 + 6) = -536870185;
      *a6 = -536870185;
      uint64_t v16 = (uint64_t)v11;
      goto LABEL_11;
    }
    uint64_t v16 = (uint64_t)v15;
    CFTypeID v17 = CFGetTypeID(v15);
    if (v17 == IOHIDEventSystemConnectionGetTypeID())
    {
      uint64_t System = _IOHIDEventSystemConnectionGetSystem(v16);
      if (!System)
      {
LABEL_15:
        *((_DWORD *)v25 + 6) = v10;
        *a6 = v10;
        uint64_t v21 = v14;
LABEL_10:
        CFRelease(v21);
        CFTypeID v14 = v11;
LABEL_11:
        CFRelease(v14);
        CFPropertyListRef v11 = (CFPropertyListRef)v16;
LABEL_12:
        CFRelease(v11);
        goto LABEL_13;
      }
      uint64_t v19 = IOHIDEventSystemCopyService(System, v11);
      if (v19)
      {
        uint64_t v20 = v19;
        if (CFDictionaryGetCount((CFDictionaryRef)v14))
        {
          *((_DWORD *)v25 + 6) = 0;
          context[0] = MEMORY[0x1E4F143A8];
          context[1] = 0x40000000;
          context[2] = ___io_hideventsystem_set_properties_for_service_block_invoke;
          _DWORD context[3] = &unk_1E548B000;
          context[4] = &v24;
          context[5] = v16;
          context[6] = v20;
          _IOHIDCFDictionaryApplyBlock((const __CFDictionary *)v14, context);
          int v10 = *((_DWORD *)v25 + 6);
        }
        else
        {
          *((_DWORD *)v25 + 6) = -536870206;
        }
        *a6 = v10;
        CFRelease(v14);
        uint64_t v21 = v20;
        goto LABEL_10;
      }
    }
    int v10 = -536870185;
    goto LABEL_15;
  }
  *((_DWORD *)v25 + 6) = -536870206;
  *a6 = -536870206;
  if (v13) {
    CFRelease(v13);
  }
  if (v11) {
    goto LABEL_12;
  }
LABEL_13:
  _Block_object_dispose(&v24, 8);
  return 0;
}

void _IOHIDCFDictionaryApplyBlock(const __CFDictionary *a1, void *context)
{
}

uint64_t _Xio_hideventsystem_copy_matching_services(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    int v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = 16777473;
  CFDataRef result = _io_hideventsystem_copy_matching_services(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 68), (vm_offset_t *)(a2 + 44), (_DWORD *)(a2 + 72));
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  int v4 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 56) = v4;
  *(void *)(a2 + 60) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 76;
  *(_DWORD *)(a2 + 24) = 2;
  return result;
}

uint64_t _io_hideventsystem_copy_matching_services(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, _DWORD *a5, vm_offset_t *a6, _DWORD *a7)
{
  CFTypeRef cf = 0;
  *a5 = 0;
  *a7 = 0;
  mach_vm_size_t v13 = a3;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFDictionaryRef v15 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a2, v13, TypeID);
  uint64_t v16 = IOMIGMachPortCacheCopy(a1);
  CFTypeID v17 = v16;
  if (v16 && (CFTypeID v18 = CFGetTypeID(v16), v18 == IOHIDEventSystemConnectionGetTypeID()))
  {
    CFAllocatorRef v19 = CFGetAllocator(v17);
    CFNumberRef v20 = CFNumberCreate(v19, kCFNumberSInt64Type, &_io_hideventsystem_copy_matching_services_sNotificationID);
    ++_io_hideventsystem_copy_matching_services_sNotificationID;
    if (v20)
    {
      uint64_t System = (CFDictionaryRef *)_IOHIDEventSystemConnectionGetSystem((uint64_t)v17);
      if (System)
      {
        CFArrayRef v22 = (const __CFArray *)IOHIDEventSystemCopyMatchingServices(System, v15, (uint64_t)__io_hideventsystem_matching_services_callback, v17, (uint64_t)v20, &cf);
        if (cf)
        {
          _IOHIDEventSystemConnectionAddNotification((uint64_t)v17, v20, cf);
          *a5 = _IOHIDSerialize(v20, a4);
        }
        if (v22)
        {
          CFArrayRef v23 = _IOHIDCopyServiceClientInfo(v22);
          if (v23)
          {
            CFArrayRef v24 = v23;
            _IOHIDEventSystemConnectionAddServices((uint64_t)v17, v22, 0);
            *a7 = _IOHIDSerialize(v24, a6);
            CFRelease(v24);
          }
          CFRelease(v22);
        }
      }
    }
  }
  else
  {
    CFNumberRef v20 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v15) {
    CFRelease(v15);
  }
  return 0;
}

void _IOHIDEventSystemConnectionAddNotification(uint64_t a1, const void *a2, const void *a3)
{
  int v6 = (os_unfair_lock_s *)(a1 + 268);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 16), a2, a3);

  os_unfair_lock_unlock(v6);
}

uint64_t IOHIDEventSystemCopyMatchingServices(CFDictionaryRef *a1, const __CFDictionary *a2, uint64_t a3, const void *a4, uint64_t a5, void *a6)
{
  uint64_t v7 = 0;
  __IOHIDEventSystemCopyMatchingServices(a1, a2, a3, a4, a5, a6, &v7);
  return v7;
}

void __IOHIDEventSystemCopyMatchingServices(CFDictionaryRef *cf, const __CFDictionary *a2, uint64_t a3, CFTypeRef a4, uint64_t a5, void *a6, void *a7)
{
  MutableCFDictionaryRef Copy = a2;
  if (a2)
  {
    CFAllocatorRef v14 = CFGetAllocator(cf);
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v14, 0, MutableCopy);
  }
  if (a4)
  {
    CFTypeID v15 = CFGetTypeID(a4);
    if (v15 == IOHIDEventSystemConnectionGetTypeID()) {
      CFTypeRef v16 = a4;
    }
    else {
      CFTypeRef v16 = 0;
    }
  }
  else
  {
    CFTypeRef v16 = 0;
  }
  context[0] = 0;
  context[1] = MutableCopy;
  context[2] = v16;
  os_unfair_recursive_lock_lock_with_options();
  if (a3)
  {
    if (a6)
    {
      CFAllocatorRef v17 = CFGetAllocator(cf);
      CFTypeID v18 = IOHIDNotificationCreate((uint64_t)v17, (uint64_t)__IOHIDEventSystemMatchNotifyRelease, (uint64_t)cf, (uint64_t)MutableCopy, a3, (uint64_t)a4, a5);
      if (v18)
      {
        CFAllocatorRef v19 = v18;
        if (MutableCopy) {
          CFRetain(MutableCopy);
        }
        CFSetAddValue(cf[5], v19);
        *a6 = v19;
      }
    }
  }
  if (a7 && CFDictionaryGetCount(cf[2]))
  {
    CFAllocatorRef v20 = CFGetAllocator(cf);
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v20, cf[2]);
    os_unfair_recursive_lock_unlock();
    if (Copy)
    {
      CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__IOHIDEventSystemCompareServiceFunction, context);
      CFRelease(Copy);
      uint64_t v22 = context[0];
    }
    else
    {
      uint64_t v22 = 0;
    }
    *a7 = v22;
    os_unfair_recursive_lock_lock_with_options();
  }
  os_unfair_recursive_lock_unlock();
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

void *IOHIDNotificationCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = __kIOHIDNotificationTypeID;
  if (!__kIOHIDNotificationTypeID)
  {
    pthread_once(&__notificationTypeInit, (void (*)(void))__IOHIDNotificationRegister);
    uint64_t v14 = __kIOHIDNotificationTypeID;
  }
  CFDataRef result = (void *)_IOHIDObjectCreateInstance(a1, v14, 0x50uLL);
  if (result)
  {
    result[3] = a5;
    result[4] = a6;
    result[5] = a7;
    result[6] = a2;
    result[7] = a3;
    result[8] = a4;
    result[10] = 0;
    result[11] = 0;
  }
  return result;
}

uint64_t _IOHIDObjectCreateInstance(uint64_t a1, uint64_t a2, size_t a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), a3);
    *(_DWORD *)(v5 + 16) = 1;
    *(_DWORD *)(v5 + 20) = 1;
  }
  return v5;
}

_DWORD *_Xio_hideventsystem_clear_service_cache(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    CFDataRef result = (_DWORD *)_io_hideventsystem_clear_service_cache(result[3]);
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _io_hideventsystem_clear_service_cache(unsigned int a1)
{
  CFArrayRef v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == IOHIDEventSystemConnectionGetTypeID()) {
      _IOHIDEventSystemConnectionRemoveAllServices((uint64_t)v2);
    }
    CFRelease(v2);
  }
  return 0;
}

void _IOHIDEventSystemConnectionRemoveAllServices(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *(void *)(a1 + 8);
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)a1);
  CFSetRef Copy = CFSetCreateCopy(v3, *(CFSetRef *)(a1 + 80));
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 80));
  os_unfair_recursive_lock_unlock();
  if (v2 && Copy)
  {
    _IOHIDEventSystemRemoveServicesForConnection(v2, Copy, a1);
  }
  else if (!Copy)
  {
    return;
  }

  CFRelease(Copy);
}

void _IOHIDEventSystemRemoveServicesForConnection(uint64_t a1, const void *a2, uint64_t a3)
{
  v13[0] = a1;
  v13[1] = a3;
  os_unfair_recursive_lock_lock_with_options();
  CFTypeID v4 = CFGetTypeID(a2);
  if (v4 == CFArrayGetTypeID())
  {
    CFAllocatorRef v5 = CFGetAllocator(a2);
    CFArrayRef Copy = CFArrayCreateCopy(v5, (CFArrayRef)a2);
    os_unfair_recursive_lock_unlock();
    if (!Copy) {
      return;
    }
    v15.CFIndex length = CFArrayGetCount((CFArrayRef)a2);
    v15.location = 0;
    CFArrayApplyFunction(Copy, v15, (CFArrayApplierFunction)ServiceClientFunctionRemove, v13);
    CFArrayRef v7 = Copy;
    goto LABEL_11;
  }
  CFTypeID v8 = CFGetTypeID(a2);
  if (v8 == CFSetGetTypeID())
  {
    CFAllocatorRef v9 = CFGetAllocator(a2);
    CFSetRef v10 = CFSetCreateCopy(v9, (CFSetRef)a2);
    os_unfair_recursive_lock_unlock();
    if (!v10) {
      return;
    }
    CFSetApplyFunction(v10, (CFSetApplierFunction)ServiceClientFunctionRemove, v13);
LABEL_10:
    CFArrayRef v7 = v10;
LABEL_11:
    CFRelease(v7);
    return;
  }
  CFTypeID v11 = CFGetTypeID(a2);
  if (v11 == CFDictionaryGetTypeID())
  {
    CFAllocatorRef v12 = CFGetAllocator(a2);
    CFSetRef v10 = CFDictionaryCreateCopy(v12, (CFDictionaryRef)a2);
    os_unfair_recursive_lock_unlock();
    if (!v10) {
      return;
    }
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)ServiceDictClientFunctionRemove, v13);
    goto LABEL_10;
  }

  os_unfair_recursive_lock_unlock();
}

uint64_t _Xiohideventsystem_client_dispatch_virtual_service_notification(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 68)
  {
    if (*(unsigned char *)(result + 39) == 1)
    {
      unsigned int v3 = *(_DWORD *)(result + 40);
      if (v3 == *(_DWORD *)(result + 64))
      {
        CFDataRef result = _iohideventsystem_client_dispatch_virtual_service_notification(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(unsigned int *)(result + 60), *(UInt8 **)(result + 28), v3);
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
    }
    int v4 = -300;
  }
  else
  {
    int v4 = -304;
  }
  *(_DWORD *)(a2 + 32) = v4;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _iohideventsystem_client_dispatch_virtual_service_notification(unsigned int a1, const void *a2, uint64_t a3, UInt8 *a4, unsigned int a5)
{
  mach_vm_size_t v9 = a5;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFTypeID v11 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, v9, TypeID);
  CFAllocatorRef v12 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  mach_vm_size_t v13 = v12;
  if (v12)
  {
    CFTypeID v14 = CFGetTypeID(v12);
    uint64_t v15 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      uint64_t v15 = __kIOHIDEventSystemClientTypeID;
    }
    if (v14 == v15)
    {
      os_unfair_recursive_lock_lock_with_options();
      CFNumberRef Value = CFDictionaryGetValue(v13[13], a2);
      if (Value)
      {
        CFAllocatorRef v17 = Value;
        CFRetain(Value);
        os_unfair_recursive_lock_unlock();
        _IOHIDVirtualServiceClientNotification(v17, a3, (uint64_t)v11);
        CFRelease(v17);
      }
      else
      {
        os_unfair_recursive_lock_unlock();
        CFTypeID v18 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          _iohideventsystem_client_dispatch_virtual_service_set_property_cold_4();
        }
      }
LABEL_9:
      CFRelease(v13);
      goto LABEL_10;
    }
  }
  CFAllocatorRef v20 = _IOHIDLogCategory(0xDu);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
    _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
  }
  if (v13) {
    goto LABEL_9;
  }
LABEL_10:
  if (v11) {
    CFRelease(v11);
  }
  return 0;
}

void *_IOHIDVirtualServiceClientNotification(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[8];
  if (v3)
  {
    int v4 = *(uint64_t (**)(void, void, void *, uint64_t, uint64_t))(v3 + 8);
    if (v4) {
      return (void *)v4(result[9], result[10], result, a2, a3);
    }
  }
  return result;
}

uint64_t __IOHIDEventServerDemuxCallback(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3 = a2[5];
  if (v3 >= dword_1ED86F440 && v3 < unk_1ED86F444) {
    LOBYTE(result) = iohideventsystem_server(a2, a3);
  }
  else {
    LOBYTE(result) = 0;
  }
  return result;
}

uint64_t _Xio_hideventsystem_open(uint64_t result, _DWORD *a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 4 || *(_DWORD *)(result + 4) != 104)
  {
    int v3 = -304;
    goto LABEL_14;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112
    || *(unsigned char *)(result + 51) != 1
    || *(unsigned char *)(result + 67) != 1
    || *(unsigned __int16 *)(result + 82) << 16 != 1114112
    || *(_DWORD *)(result + 52) != *(_DWORD *)(result + 96)
    || *(_DWORD *)(result + 68) != *(_DWORD *)(result + 100))
  {
    int v3 = -300;
    goto LABEL_14;
  }
  if (*(_DWORD *)(result + 104) || *(_DWORD *)(result + 108) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_14:
    a2[8] = v3;
    goto LABEL_15;
  }
  *((void *)a2 + 4) = 0x11000000000000;
  unsigned int v4 = *(_DWORD *)(result + 12);
  mach_port_name_t v5 = *(_DWORD *)(result + 28);
  unsigned int v6 = *(_DWORD *)(result + 92);
  CFArrayRef v7 = *(UInt8 **)(result + 40);
  unsigned int v8 = *(_DWORD *)(result + 52);
  mach_vm_size_t v9 = *(UInt8 **)(result + 56);
  unsigned int v10 = *(_DWORD *)(result + 68);
  mach_port_name_t v11 = *(_DWORD *)(result + 72);
  long long v12 = *(_OWORD *)(result + 140);
  v13[0] = *(_OWORD *)(result + 124);
  v13[1] = v12;
  uint64_t result = _io_hideventsystem_open(v4, v5, v6, v7, v8, v9, v10, v11, a2 + 7, v13);
  if (!result)
  {
    *a2 |= 0x80000000;
    a2[1] = 40;
    a2[6] = 1;
    return result;
  }
  a2[8] = result;
LABEL_15:
  *((void *)a2 + 3) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _Xio_hideventsystem_copy_property(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    int v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = _io_hideventsystem_copy_property(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52), (int *)(a2 + 56));
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _io_hideventsystem_copy_property(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, _DWORD *a5, int *a6)
{
  *a5 = 0;
  mach_vm_size_t v11 = a3;
  CFTypeID TypeID = CFStringGetTypeID();
  mach_vm_size_t v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a2, v11, TypeID);
  if (v13)
  {
    CFTypeID v14 = v13;
    uint64_t v15 = IOMIGMachPortCacheCopy(a1);
    if (v15)
    {
      CFTypeRef v16 = v15;
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == IOHIDEventSystemConnectionGetTypeID()
        && (uint64_t System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v16), a4)
        && ((uint64_t v19 = System, IOHIDEventSystemConnectionGetType((uint64_t)v16) != 4)
         || CFSetContainsValue((CFSetRef)__whiteListSet, v14)))
      {
        CFAllocatorRef v20 = _IOHIDEventSystemCopyPropertyForConnection(v19, v14, v16);
        if (v20)
        {
          uint64_t v21 = v20;
          *a5 = _IOHIDSerialize(v20, a4);
          CFRelease(v21);
        }
        int v22 = 0;
      }
      else
      {
        int v22 = -536870206;
      }
      *a6 = v22;
      CFRelease(v14);
      CFArrayRef v23 = v16;
    }
    else
    {
      *a6 = -536870206;
      CFArrayRef v23 = v14;
    }
    CFRelease(v23);
  }
  else
  {
    *a6 = -536870206;
  }
  return 0;
}

uint64_t _Xio_hideventsystem_queue_create(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 52)
  {
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }
  *(void *)(a2 + 32) = 0x13000000000000;
  uint64_t result = _io_hideventsystem_queue_create(*(_DWORD *)(result + 12), *(_DWORD *)(result + 28), *(_DWORD *)(result + 48), (_DWORD *)(a2 + 28));
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _io_hideventsystem_queue_create(unsigned int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = 0;
  CFArrayRef v7 = IOMIGMachPortCacheCopy(a1);
  if (v7)
  {
    unsigned int v8 = v7;
    CFTypeID v9 = CFGetTypeID(v7);
    if (v9 == IOHIDEventSystemConnectionGetTypeID())
    {
      unsigned int v10 = _IOHIDEventSystemConnectionCopyQueue((uint64_t)v8);
      if (v10)
      {
        mach_vm_size_t v11 = v10;
        _IOHIDEventSystemConnectionSetQueue((uint64_t)v8, 0);
        CFRelease(v11);
      }
      CFAllocatorRef v12 = CFGetAllocator(v8);
      uint64_t v13 = IOHIDEventQueueCreate((uint64_t)v12, 1, a3);
      if (v13)
      {
        CFTypeID v14 = (const void *)v13;
        IOHIDEventQueueSetNotificationPort(v13, a2);
        *a4 = IOHIDEventQueueGetMemoryHandle((uint64_t)v14);
        _IOHIDEventSystemConnectionSetQueue((uint64_t)v8, (uint64_t)v14);
        CFRelease(v14);
      }
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t _IOHIDEventSystemConnectionSetQueue(uint64_t a1, uint64_t a2)
{
  kern_return_t v7;
  mach_error_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  const void *v18;
  void v20[5];
  void handler[5];

  os_unfair_recursive_lock_lock_with_options();
  unsigned int v4 = *(const void **)(a1 + 24);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 24) = a2;
  if (a2)
  {
    unsigned int v6 = (unsigned int *)(a1 + 104);
    unsigned int v5 = *(_DWORD *)(a1 + 104);
    if (v5) {
      goto LABEL_10;
    }
    CFArrayRef v7 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, (mach_port_name_t *)(a1 + 104));
    if (v7)
    {
      unsigned int v8 = v7;
      CFTypeID v9 = _IOHIDLogCategory(9u);
      unsigned int v10 = (int)v9;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        _IOHIDEventSystemConnectionReleasePrivate_cold_3(a1, v8, v10, v11, v12, v13, v14, v15);
      }
      __IOHIDEventSystemConnectionCheckServerStatus(v8, a1);
    }
    unsigned int v5 = *v6;
    if (*v6)
    {
LABEL_10:
      CFTypeRef v16 = dispatch_source_create(MEMORY[0x1E4F14458], v5, 0, *(dispatch_queue_t *)(a1 + 96));
      *(void *)(a1 + 112) = v16;
      if (!v16) {
        goto LABEL_12;
      }
    }
    else
    {
      CFTypeRef v16 = *(NSObject **)(a1 + 112);
      if (!v16)
      {
LABEL_12:
        *(_DWORD *)(a1 + 128) = 1;
        CFTypeID v18 = *(const void **)(a1 + 24);
        if (v18) {
          CFRetain(v18);
        }
        return os_unfair_recursive_lock_unlock();
      }
    }
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = ___IOHIDEventSystemConnectionSetQueue_block_invoke;
    handler[3] = &__block_descriptor_tmp_23_0;
    handler[4] = a1;
    dispatch_source_set_event_handler(v16, handler);
    CFRetain((CFTypeRef)a1);
    CFTypeID v17 = *(NSObject **)(a1 + 112);
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 0x40000000;
    v20[2] = ___IOHIDEventSystemConnectionSetQueue_block_invoke_24;
    v20[3] = &__block_descriptor_tmp_25_0;
    v20[4] = a1;
    dispatch_source_set_cancel_handler(v17, v20);
    dispatch_resume(*(dispatch_object_t *)(a1 + 112));
    goto LABEL_12;
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventQueueSetNotificationPort(uint64_t a1, int a2)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 144) == 1)
  {
    *(void *)(a1 + 60) = 0x1800000013;
    *(_DWORD *)(a1 + 68) = a2;
  }
  *(_DWORD *)(a1 + 96) = a2;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventQueueGetMemoryHandle(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *(unsigned int *)(a1 + 84);
  os_unfair_recursive_lock_unlock();
  return v2;
}

uint64_t _Xio_hideventsystem_release_notification(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 56)
  {
    if (*(unsigned char *)(result + 39) == 1)
    {
      CFIndex v3 = *(unsigned int *)(result + 40);
      if (v3 == *(_DWORD *)(result + 52))
      {
        uint64_t result = _io_hideventsystem_release_notification(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3);
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
    }
    int v4 = -300;
  }
  else
  {
    int v4 = -304;
  }
  *(_DWORD *)(a2 + 32) = v4;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _io_hideventsystem_release_notification(unsigned int a1, UInt8 *bytes, CFIndex length)
{
  CFPropertyListRef v4 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  if (v4)
  {
    unsigned int v5 = v4;
    unsigned int v6 = IOMIGMachPortCacheCopy(a1);
    if (v6)
    {
      CFArrayRef v7 = v6;
      CFTypeID v8 = CFGetTypeID(v6);
      if (v8 == IOHIDEventSystemConnectionGetTypeID())
      {
        uint64_t System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v7);
        if (System) {
          _IOHIDEventSystemRemoveNotificationForConnection(System, (uint64_t)v7, v5);
        }
      }
      CFRelease(v5);
    }
    else
    {
      CFArrayRef v7 = v5;
    }
    CFRelease(v7);
  }
  return 0;
}

uint64_t _IOHIDEventSystemRemoveNotificationForConnection(uint64_t a1, uint64_t a2, const void *a3)
{
  os_unfair_recursive_lock_lock_with_options();
  unsigned int v6 = _IOHIDEventSystemConnectionCopyNotification(a2, a3);
  _IOHIDEventSystemConnectionRemoveNotification(a2, a3);
  if (v6)
  {
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 40), v6);
    CFRelease(v6);
  }

  return os_unfair_recursive_lock_unlock();
}

void _IOHIDEventSystemConnectionRemoveNotification(uint64_t a1, const void *a2)
{
  CFPropertyListRef v4 = (os_unfair_lock_s *)(a1 + 268);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  os_unfair_lock_unlock(v4);
  if (Value)
  {
    CFRetain(Value);
    CFRetain(a2);
    CFRetain((CFTypeRef)a1);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = ___IOHIDEventSystemConnectionRemoveNotification_block_invoke;
    v6[3] = &__block_descriptor_tmp_26_0;
    v6[4] = a1;
    _OWORD v6[5] = a2;
    v6[6] = Value;
    IOHIDNotificationInvalidate((uint64_t)Value, v6);
  }
}

const void *_IOHIDEventSystemConnectionCopyNotification(uint64_t a1, const void *a2)
{
  CFPropertyListRef v4 = (os_unfair_lock_s *)(a1 + 268);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2);
  unsigned int v6 = Value;
  if (Value) {
    CFRetain(Value);
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

__CFArray *_IOHIDSessionCopyPropertyForClient(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v5 = a1;
  v67[2] = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(v67, valuePtr);
  }
  ++**(_DWORD **)(v5 + 32);
  if (CFEqual(a2, @"LastActivityTimestamp"))
  {
    CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)v5);
    CFNumberRef v7 = CFNumberCreate(v6, kCFNumberSInt64Type, (const void *)(v5 + 168));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 120), a2, v7);
    CFRelease(v7);
  }
  if (CFEqual(a2, @"LastActivityTime"))
  {
    *(void *)int valuePtr = *(void *)(v5 + 176) | ((unint64_t)*(unsigned int *)(v5 + 184) << 32);
    CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)v5);
    CFNumberRef v9 = CFNumberCreate(v8, kCFNumberSInt64Type, valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 120), a2, v9);
    CFRelease(v9);
  }
  if (CFEqual(a2, @"HIDIdleTimeMicroseconds"))
  {
    *(void *)int valuePtr = 0;
    uint64_t v10 = mach_continuous_time();
    *(void *)int valuePtr = _IOHIDGetTimestampDelta(v10, *(void *)(v5 + 168), 0x3E8u);
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)v5);
    CFNumberRef v12 = CFNumberCreate(v11, kCFNumberSInt64Type, valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 120), a2, v12);
    CFRelease(v12);
  }
  if (CFEqual(a2, @"ServiceRecords"))
  {
    if (a3)
    {
      uint64_t v13 = *(CFDictionaryRef **)(v5 + 8);
      if (v13)
      {
        CFArrayRef v14 = (const __CFArray *)IOHIDEventSystemCopyServices(v13, 0);
        if (v14)
        {
          CFArrayRef v15 = v14;
          uint64_t v59 = v5;
          CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFIndex Count = CFArrayGetCount(v14);
          CFMutableArrayRef Mutable = CFArrayCreateMutable(v16, Count, MEMORY[0x1E4F1D510]);
          if (Mutable)
          {
            CFIndex v19 = CFArrayGetCount(v15);
            if (v19 >= 1)
            {
              CFIndex v20 = v19;
              CFIndex v21 = 0;
              while (1)
              {
                CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v15, v21);
                if (!ValueAtIndex) {
                  goto LABEL_32;
                }
                uint64_t v23 = (uint64_t)ValueAtIndex;
                CFArrayRef v24 = _IOHIDServiceCopyServiceRecordForClient(ValueAtIndex, a3);
                if (v24) {
                  break;
                }
LABEL_28:
                if (v20 == ++v21) {
                  goto LABEL_32;
                }
              }
              uint64_t v25 = v24;
              uint64_t v26 = _IOHIDLog();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)int valuePtr = 138412290;
                *(void *)&valuePtr[4] = v23;
                _os_log_impl(&dword_18B46C000, v26, OS_LOG_TYPE_INFO, "Creating deep copy of record belonging to service: %@", valuePtr, 0xCu);
              }
              DeepCFArrayRef Copy = CFPropertyListCreateDeepCopy(v16, v25, 0);
              unsigned int v28 = DeepCopy;
              if (DeepCopy && (CFTypeID v29 = CFGetTypeID(DeepCopy), v29 == CFDictionaryGetTypeID()))
              {
                CFArrayAppendValue(Mutable, v28);
              }
              else
              {
                CFMutableDictionaryRef v30 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (v30)
                {
                  int v31 = v30;
                  CFTypeRef RegistryID = (const void *)IOHIDServiceGetRegistryID(v23);
                  CFDictionarySetValue(v31, @"ServiceID", RegistryID);
                  CFArrayAppendValue(Mutable, v31);
                  CFRelease(v31);
                }
                uint64_t v33 = _IOHIDLog();
                if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                {
                  _IOHIDSessionCopyPropertyForClient_cold_2((uint8_t *)v67, v23, (uint64_t *)((char *)v67 + 4), v33);
                  if (!v28) {
                    goto LABEL_27;
                  }
                }
                else if (!v28)
                {
LABEL_27:
                  CFRelease(v25);
                  goto LABEL_28;
                }
              }
              CFRelease(v28);
              goto LABEL_27;
            }
          }
LABEL_32:
          CFArrayRef v34 = v15;
LABEL_33:
          CFRelease(v34);
LABEL_34:
          uint64_t v5 = v59;
          goto LABEL_35;
        }
      }
    }
    goto LABEL_82;
  }
  if (CFEqual(a2, @"ClientRecords"))
  {
    if (a3)
    {
      long long v61 = *(CFSetRef **)(v5 + 8);
      if (v61)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (!Mutable) {
          goto LABEL_35;
        }
        uint64_t v59 = v5;
        CFTypeRef cf = 0;
        for (uint64_t i = 0; i != 5; ++i)
        {
          CFArrayRef v38 = IOHIDEventSystemCopyConnections(v61, i);
          BOOL v39 = v38 == 0;
          if (!v38) {
            break;
          }
          if (!i)
          {
            unsigned __int16 v40 = _IOHIDEventSystemCopyRecord((CFTypeRef *)v61);
            if (!v40) {
              goto LABEL_75;
            }
            CFTypeRef cf = v40;
            CFArrayAppendValue(Mutable, v40);
          }
          CFIndex v41 = CFArrayGetCount(v38);
          if (v41 >= 1)
          {
            CFIndex v42 = v41;
            CFIndex v43 = 0;
            while (1)
            {
              __int16 v44 = CFArrayGetValueAtIndex(v38, v43);
              if (!v44) {
                break;
              }
              int v45 = v44;
              if (v44 != a3)
              {
                CFMutableDictionaryRef v46 = _IOHIDEventSystemConnectionCopyRecord((uint64_t)v44);
                if (!v46) {
                  break;
                }
                CFMutableDictionaryRef v47 = v46;
                if (_IOHIDIsSerializable((uint64_t)v46))
                {
                  CFArrayAppendValue(Mutable, v47);
                }
                else
                {
                  uint64_t v48 = _IOHIDLog();
                  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)int valuePtr = 138412290;
                    *(void *)&valuePtr[4] = v45;
                    _os_log_error_impl(&dword_18B46C000, v48, OS_LOG_TYPE_ERROR, "Client record is not serializable for %@", valuePtr, 0xCu);
                  }
                }
                CFRelease(v47);
              }
              if (v42 == ++v43) {
                goto LABEL_58;
              }
            }
            BOOL v39 = 0;
            break;
          }
LABEL_58:
          CFRelease(v38);
        }
        if (cf) {
          CFRelease(cf);
        }
        if (!v39)
        {
LABEL_75:
          CFArrayRef v34 = v38;
          goto LABEL_33;
        }
        goto LABEL_34;
      }
    }
LABEL_82:
    CFMutableArrayRef Mutable = 0;
    goto LABEL_35;
  }
  if (CFEqual(a2, @"SessionFilterDebug"))
  {
    if (!a3) {
      goto LABEL_82;
    }
    CFAllocatorRef v49 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFIndex v50 = CFArrayGetCount(*(CFArrayRef *)(v5 + 152));
      if (v50 >= 1)
      {
        CFIndex v51 = v50;
        CFIndex v52 = 0;
        uint64_t v53 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
        uint64_t v54 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
        while (1)
        {
          long long v55 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 152), v52);
          PropertyForClient = IOHIDSessionFilterGetPropertyForClient((uint64_t)v55, @"SessionFilterDebug");
          if (PropertyForClient) {
            goto LABEL_68;
          }
          uint64_t v57 = CFDictionaryCreateMutable(v49, 0, v53, v54);
          if (v57) {
            break;
          }
LABEL_69:
          if (v51 == ++v52) {
            goto LABEL_35;
          }
        }
        PropertyForClient = v57;
        CFDictionaryAddValue(v57, @"Class", @"Unknown");
LABEL_68:
        CFArrayAppendValue(Mutable, PropertyForClient);
        CFRelease(PropertyForClient);
        goto LABEL_69;
      }
    }
  }
  else
  {
    context[0] = v5;
    context[1] = a2;
    CFTypeRef v64 = 0;
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1D260])) {
      a3 = 0;
    }
    long long v65 = a3;
    CFArrayRef v58 = *(const __CFArray **)(v5 + 152);
    v68.CFIndex length = CFArrayGetCount(v58);
    v68.location = 0;
    CFArrayApplyFunction(v58, v68, (CFArrayApplierFunction)__FilterFunctionGetPropertyForClient, context);
    CFMutableArrayRef Mutable = (__CFArray *)v64;
    if (v64 || (CFMutableArrayRef Mutable = (__CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 120), a2)) != 0) {
      CFRetain(Mutable);
    }
  }
LABEL_35:
  uint64_t v35 = *(void *)(v5 + 32);
  if (*(_DWORD *)v35)
  {
    --*(_DWORD *)v35;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v35 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v62, valuePtr);
    }
  }
  return Mutable;
}

__CFArray *_IOHIDEventSystemCopyPropertyForConnection(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 128);
  uint64_t result = _IOHIDEventSystemConnectionCopyProperty(a3, a2);
  if (!result)
  {
    return _IOHIDSessionCopyPropertyForClient(v5, a2, a3);
  }
  return result;
}

CFNumberRef _IOHIDEventSystemConnectionCopyProperty(void *a1, CFTypeRef cf2)
{
  if ((void *)*MEMORY[0x1E4F1D260] == a1) {
    return 0;
  }
  uint64_t v4 = a1[55];
  if (v4)
  {
    CFNumberRef result = (CFNumberRef)IOHIDConnectionFilterCopyProperty(v4, (uint64_t)cf2);
    if (result) {
      return result;
    }
  }
  if (!CFEqual(@"HIDActivityState", cf2))
  {
    if (CFEqual(cf2, @"IdleNotificationTime"))
    {
      CFAllocatorRef v6 = CFGetAllocator(a1);
      CFNumberRef v7 = a1 + 51;
      CFNumberType v8 = kCFNumberSInt64Type;
      goto LABEL_8;
    }
    return 0;
  }
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFNumberRef v7 = a1 + 50;
  CFNumberType v8 = kCFNumberSInt32Type;
LABEL_8:

  return CFNumberCreate(v6, v8, v7);
}

void __IOHIDEventSystemConnectionPortTerminateCallback(uint64_t a1, void (**cf)(CFTypeRef, uint64_t))
{
  CFRetain(cf);
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v4 = cf[8];
  if (v4 && cf[4] == (void (*)(CFTypeRef, uint64_t))a1)
  {
    uint64_t v5 = cf[9];
    if (a1) {
      IOMIGMachPortRegisterTerminationCallback(a1, 0, 0);
    }
    os_unfair_recursive_lock_unlock();
    v4(cf, (uint64_t)v5);
    os_unfair_recursive_lock_lock_with_options();
  }
  os_unfair_recursive_lock_unlock();

  CFRelease(cf);
}

void __IOHIDEventSystemConnectionDiedCallback(uint64_t *a1, uint64_t a2)
{
  if (a1) {
    __IOHIDEventServerKillClient(a2, a1);
  }
}

void __IOHIDEventServerKillClient(uint64_t a1, uint64_t *a2)
{
  _IOHIDEventSystemConnectionInvalidate((uint64_t)a2);
  _IOHIDEventSystemConnectionUnscheduleAsync(a2);
  unsigned int Port = _IOHIDEventSystemConnectionGetPort((uint64_t)a2);
  IOMIGMachPortCacheRemove(Port);
  uint64_t v5 = *(CFDictionaryRef **)(a1 + 16);

  _IOHIDEventSystemRemoveConnection(v5, a2);
}

void _IOHIDEventSystemConnectionInvalidate(uint64_t a1)
{
  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 272)) >= 1)
  {
    CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v2, *(CFDictionaryRef *)(a1 + 272));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 272));
    CFRetain((CFTypeRef)a1);
    EnumerationQueue = _IOHIDEventSystemGetEnumerationQueue(*(void *)(a1 + 8));
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___IOHIDEventSystemConnectionInvalidate_block_invoke;
    block[3] = &__block_descriptor_tmp_17_1;
    block[4] = Copy;
    void block[5] = a1;
    dispatch_async(EnumerationQueue, block);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 268));
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)__NotificationApplier, (void *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 268));
  uint64_t v5 = *(void *)(a1 + 424);
  if (v5) {
    IOHIDNotificationInvalidate(v5, 0);
  }
  CFRetain((CFTypeRef)a1);
  CFAllocatorRef v6 = *(NSObject **)(a1 + 96);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  v7[2] = ___IOHIDEventSystemConnectionInvalidate_block_invoke_2;
  v7[3] = &__block_descriptor_tmp_18_1;
  v7[4] = a1;
  dispatch_async(v6, v7);
  *(_DWORD *)(a1 + 264) |= 1u;
}

uint64_t _Xiohideventsystem_copy_event_from_virtual_service(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 72)
  {
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 64))
  {
    int v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  CFNumberRef result = _iohideventsystem_copy_event_from_virtual_service(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(unsigned int *)(result + 60), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), *(unsigned int *)(result + 68), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52));
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void __IOHIDServiceConformsToFunction(const void *a1, _DWORD *a2)
{
  if (a1 && !*a2)
  {
    int valuePtr = 0;
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      if (a2[1] == -1
        || (CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a1, @"DeviceUsagePage")) != 0
        && (CFNumberRef v6 = v5, v7 = CFGetTypeID(v5), v7 == CFNumberGetTypeID())
        && CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr)
        && valuePtr == a2[1])
      {
        if (a2[2] == -1
          || (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a1, @"DeviceUsage")) != 0
          && (CFNumberRef v9 = Value, v10 = CFGetTypeID(Value), v10 == CFNumberGetTypeID())
          && CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr)
          && valuePtr == a2[2])
        {
          *a2 = 1;
        }
      }
    }
    else
    {
      CFAllocatorRef v11 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        __IOHIDServiceConformsToFunction_cold_1((uint64_t)a1, v11);
      }
    }
  }
}

void __ConnectionFunctionPickReportInterval(uint64_t a1, void *a2, unsigned int *a3)
{
  unsigned int valuePtr = 0;
  if (_IOHIDEventSystemConnectionIsResponsive(a1))
  {
    CFNumberRef v5 = (const __CFNumber *)IOHIDServiceConnectionCacheCopyValueForKey(a2, @"ReportInterval");
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
      CFRelease(v6);
      unsigned int v7 = valuePtr;
      if (valuePtr)
      {
        unsigned int v8 = *a3;
        if (*a3)
        {
          if (valuePtr < v8)
          {
            a3[1] = v8;
LABEL_10:
            *a3 = v7;
            return;
          }
        }
        else
        {
          *a3 = valuePtr;
          a3[1] = v7;
          unsigned int v8 = v7;
        }
        unsigned int v10 = a3[1];
        ++a3;
        unsigned int v9 = v10;
        if (v8 == v10 || v7 < v9) {
          goto LABEL_10;
        }
      }
    }
  }
}

BOOL _IOHIDEventSystemConnectionIsResponsive(uint64_t a1)
{
  return *MEMORY[0x1E4F1D260] == a1 || (*(unsigned char *)(a1 + 264) & 2) == 0;
}

void __ConnectionFunctionPickBatchInterval(uint64_t a1, void *a2, unsigned int *a3)
{
  unsigned int valuePtr = 0;
  CFNumberRef v4 = (const __CFNumber *)IOHIDServiceConnectionCacheCopyValueForKey(a2, @"BatchInterval");
  if (v4)
  {
    CFNumberRef v5 = v4;
    CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr);
    CFRelease(v5);
    if (valuePtr < *a3) {
      *a3 = valuePtr;
    }
  }
}

const void **__ActivityFunctionApplier(const void **a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ____ActivityFunctionApplier_block_invoke;
  v3[3] = &__block_descriptor_tmp_51;
  v3[4] = a2;
  return IOHIDNotificationSignalWithBlock(a1, (uint64_t)v3);
}

const void **__IOHIDServiceNotificationSetApplier(const void **result, uint64_t a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 0x40000000;
    v2[2] = ____IOHIDServiceNotificationSetApplier_block_invoke;
    v2[3] = &__block_descriptor_tmp_274;
    v2[4] = a2;
    return IOHIDNotificationSignalWithBlock(result, (uint64_t)v2);
  }
  return result;
}

void __IOHIDEventSystemMatchNotifyFunction(const void **a1, uint64_t a2)
{
  uint64_t v9 = 0;
  unsigned int v10 = &v9;
  uint64_t v11 = 0x3000000000;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  if (a1)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    v8[2] = ____IOHIDEventSystemMatchNotifyFunction_block_invoke;
    v8[3] = &unk_1E548A1E8;
    v8[4] = &v9;
    IOHIDNotificationSignalWithBlock(a1, (uint64_t)v8);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 8), (CFDictionaryApplierFunction)__IOHIDEventSystemCompareServiceFunction, v10 + 3);
    CFNumberRef v4 = v10;
    CFArrayRef v5 = (const __CFArray *)v10[3];
    if (v5)
    {
      if (CFArrayGetCount(v5))
      {
        v7[0] = MEMORY[0x1E4F143A8];
        v7[1] = 0x40000000;
        v7[2] = ____IOHIDEventSystemMatchNotifyFunction_block_invoke_2;
        v7[3] = &unk_1E548A210;
        v7[4] = &v9;
        void v7[5] = a2;
        IOHIDNotificationSignalWithBlock(a1, (uint64_t)v7);
      }
      CFRelease((CFTypeRef)v10[3]);
      CFNumberRef v4 = v10;
    }
    CFNumberRef v6 = (const void *)v4[4];
    if (v6) {
      CFRelease(v6);
    }
  }
  _Block_object_dispose(&v9, 8);
}

const void **IOHIDNotificationSignalWithBlock(const void **result, uint64_t a2)
{
  CFAllocatorRef v2 = (OSQueueHead *)result;
  int v3 = (atomic_uint *)(result + 9);
  if ((atomic_fetch_add((atomic_uint *volatile)result + 18, 1u) & 0x80000000) == 0) {
    CFNumberRef result = (const void **)(*(uint64_t (**)(uint64_t, const void *, const void *, const void *, const void *, const void *))(a2 + 16))(a2, result[7], result[8], result[3], result[4], result[5]);
  }
  if (atomic_fetch_add(v3, 0xFFFFFFFF) == -2147483647)
  {
    return __IOHIDNotificationInvalidateCompletion(v2);
  }
  return result;
}

void __io_hideventsystem_matching_services_callback(uint64_t a1, const void *a2, uint64_t a3, const __CFArray *a4)
{
}

void __IOHIDEventSystemConnectionUpdateActivityState(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 400) != a2)
  {
    if (a3)
    {
      int Type = IOHIDEventGetType(a3);
      uint64_t SenderID = IOHIDEventGetSenderID(a3);
    }
    else
    {
      int Type = 0;
      uint64_t SenderID = 0;
    }
    unsigned int v8 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *(void *)(a1 + 168);
      int v10 = *(_DWORD *)(a1 + 400);
      *(_DWORD *)CFTypeID v18 = 136316162;
      *(void *)&v18[4] = v9;
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = v10;
      *(_WORD *)&v18[18] = 1024;
      *(_DWORD *)&v18[20] = a2;
      *(_WORD *)&v18[24] = 2048;
      *(void *)&v18[26] = SenderID;
      *(_WORD *)&v18[34] = 1024;
      *(_DWORD *)&v18[36] = Type;
      _os_log_impl(&dword_18B46C000, v8, OS_LOG_TYPE_INFO, "%s: HID activity: %d -> %d (service:0x%llx event:%d)", v18, 0x28u);
    }
    memset(v18, 0, sizeof(v18));
    *(_DWORD *)CFTypeID v18 = a2;
    if (a3)
    {
      uint64_t v11 = IOHIDEventGetSenderID(a3);
      int v12 = IOHIDEventGetType(a3);
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 0;
    }
    *(void *)&v18[24] = v11;
    *(_DWORD *)&v18[32] = v12;
    gettimeofday((timeval *)&v18[8], 0);
    ++*(_DWORD *)(a1 + 404);
    os_unfair_recursive_lock_lock_with_options();
    CFDataRef v13 = *(const __CFData **)(a1 + 432);
    if (v13
      || (CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1),
          CFDataRef v13 = _IOHIDSimpleQueueCreate(v14, 40, 50),
          (*(void *)(a1 + 432) = v13) != 0))
    {
      _IOHIDSimpleQueueEnqueue(v13, v18, 1);
    }
    os_unfair_recursive_lock_unlock();
    *(_DWORD *)(a1 + 400) = a2;
    CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
    CFNumberRef v16 = CFNumberCreate(v15, kCFNumberSInt32Type, (const void *)(a1 + 400));
    if (v16)
    {
      CFNumberRef v17 = v16;
      _IOHIDEventSystemConnectionPropertyChanged(a1, @"HIDActivityState", v16);
      CFRelease(v17);
    }
  }
}

void __IOHIDEventSystemConnectionActivityNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v5 = *(NSObject **)(a1 + 416);
  dispatch_time_t v6 = dispatch_time(0, 1000000000 * *(void *)(a1 + 408));
  dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0);

  __IOHIDEventSystemConnectionUpdateActivityState(a1, 1, a3);
}

void IOHIDEventSystemClientSetDispatchQueue(uint64_t a1, NSObject *a2)
{
  if (*(void *)(a1 + 400)) {
    IOHIDEventSystemClientSetDispatchQueue_cold_1();
  }
  __IOHIDEventSystemClientSetupAsyncSupport(a1);
  label = dispatch_queue_get_label(a2);
  if (!*label) {
    label = "IOHIDEventSystemClientDispatchQueue";
  }
  dispatch_queue_t v5 = dispatch_queue_create_with_target_V2(label, 0, a2);
  *(void *)(a1 + 400) = v5;
  if (v5)
  {
    _IOHIDObjectInternalRetain((const void *)a1);
    uint64_t v6 = dispatch_mach_create();
    *(void *)(a1 + 296) = v6;
    if (v6)
    {
      _IOHIDObjectInternalRetain((const void *)a1);
      uint64_t v7 = dispatch_mach_create();
      *(void *)(a1 + 72) = v7;
      if (!v7)
      {
        _IOHIDObjectInternalRelease((const void *)a1);
        dispatch_release(*(dispatch_object_t *)(a1 + 400));
      }
    }
    else
    {
      _IOHIDObjectInternalRelease((const void *)a1);
    }
  }
}

void __IOHIDNotificationExtFinalize(void *a1)
{
  CFAllocatorRef v2 = (void (*)(void, void, void *))a1[6];
  if (v2) {
    v2(a1[7], a1[8], a1);
  }
  _IOHIDObjectInternalRetain(a1);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ____IOHIDNotificationExtFinalize_block_invoke;
  v3[3] = &__block_descriptor_tmp_2;
  v3[4] = a1;
  IOHIDNotificationInvalidate((uint64_t)a1, v3);
}

void IOHIDNotificationInvalidate(uint64_t a1, const void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
    dispatch_queue_t v5 = CFAllocatorAllocate(v4, 16, 0);
    if (!v5) {
      IOHIDNotificationInvalidate_cold_2(&v10, v11);
    }
    uint64_t v6 = v5;
    *((void *)v5 + 1) = _Block_copy(a2);
    OSAtomicEnqueue((OSQueueHead *)(a1 + 80), v6, 0);
    if ((atomic_fetch_or((atomic_uint *volatile)(a1 + 72), 0x80000000) & 0x7FFFFFFF) == 0)
    {
      __IOHIDNotificationInvalidateCompletion((OSQueueHead *)a1);
    }
  }
  else
  {
    dispatch_semaphore_t v7 = dispatch_semaphore_create(0);
    if (!v7) {
      IOHIDNotificationInvalidate_cold_1(&v10, v11);
    }
    unsigned int v8 = v7;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    v9[2] = __IOHIDNotificationInvalidate_block_invoke;
    v9[3] = &__block_descriptor_tmp_13;
    v9[4] = v7;
    IOHIDNotificationInvalidate(a1, v9);
    dispatch_semaphore_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v8);
  }
}

const void **__IOHIDNotificationInvalidateCompletion(OSQueueHead *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  int v3 = a1 + 5;
  CFNumberRef result = (const void **)OSAtomicDequeue(v3, 0);
  if (result)
  {
    dispatch_queue_t v5 = result;
    do
    {
      (*((void (**)(void))v5[1] + 2))();
      _Block_release(v5[1]);
      CFAllocatorDeallocate(v2, v5);
      CFNumberRef result = (const void **)OSAtomicDequeue(v3, 0);
      dispatch_queue_t v5 = result;
    }
    while (result);
  }
  return result;
}

const void *_IOHIDObjectInternalRetain(const void *a1)
{
  CFGetTypeID(a1);
  ClassWithCFTypeID TypeID = _CFRuntimeGetClassWithTypeID();
  if (ClassWithTypeID) {
    (*(void (**)(uint64_t, const void *))(ClassWithTypeID + 96))(1, a1);
  }
  return a1;
}

uint64_t _IOHIDObjectRetainCount(uint64_t a1, char *cf, int a3)
{
  int v3 = cf;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 20;
  if (!a3) {
    uint64_t v4 = 16;
  }
  switch(a1)
  {
    case -1:
      unsigned int add = atomic_fetch_add((atomic_uint *volatile)&cf[v4], 0xFFFFFFFF);
      if (add == 1)
      {
        CFGetTypeID(cf);
        ClassWithCFTypeID TypeID = _CFRuntimeGetClassWithTypeID();
        uint64_t v10 = 104;
        if (!a3) {
          uint64_t v10 = 32;
        }
        uint64_t v11 = *(void (**)(char *))(ClassWithTypeID + v10);
        if (v11) {
          v11(v3);
        }
        if (a3)
        {
          CFAllocatorRef v12 = CFGetAllocator(v3);
          CFAllocatorRef v13 = v12;
          if ((CFAllocatorRef)*MEMORY[0x1E4F1CFB0] != v12)
          {
            if (v12 && (CFAllocatorRef)*MEMORY[0x1E4F1CF80] != v12
              || (CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0], v14 != CFAllocatorGetDefault()))
            {
              v3 -= 16;
            }
          }
          CFAllocatorDeallocate(v13, v3);
        }
        else
        {
          _IOHIDObjectInternalRelease(v3);
        }
      }
      else if (!add)
      {
        _IOHIDObjectRetainCount_cold_3(&v15, v16);
      }
      break;
    case 0:
      return atomic_load((unsigned int *)&cf[v4]);
    case 1:
      unsigned int v5 = atomic_fetch_add((atomic_uint *volatile)&cf[v4], 1u);
      if (v5 == -1) {
        _IOHIDObjectRetainCount_cold_1(&v15, v16);
      }
      if (!v5) {
        _IOHIDObjectRetainCount_cold_2(&v15, v16);
      }
      break;
  }
  return 0;
}

uint64_t _IOHIDObjectIntRetainCount(uint64_t a1, char *a2)
{
  return _IOHIDObjectRetainCount(a1, a2, 1);
}

uint64_t _IOHIDObjectInternalRelease(const void *a1)
{
  CFGetTypeID(a1);
  uint64_t result = _CFRuntimeGetClassWithTypeID();
  if (result)
  {
    int v3 = *(uint64_t (**)(uint64_t, const void *))(result + 96);
    return v3(-1, a1);
  }
  return result;
}

uint64_t __IOHIDServiceNotificationRelease(void *a1, uint64_t a2, const void *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  }
  ++*(_DWORD *)a1[9];
  unsigned int v5 = (__CFSet *)a1[14];
  if (v5) {
    CFSetRemoveValue(v5, a3);
  }
  uint64_t v6 = (__CFSet *)a1[13];
  if (v6) {
    CFSetRemoveValue(v6, a3);
  }
  uint64_t result = a1[9];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
    }
  }
  return result;
}

void __IOHIDServiceRequestTerminaitonNotificationRelease(uint64_t a1, uint64_t a2, const void *a3)
{
  unsigned int v5 = (os_unfair_lock_s *)(a1 + 456);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 120), a3);

  os_unfair_lock_unlock(v5);
}

void __IOHIDEventSystemMatchNotifyRelease(uint64_t a1, const void *a2, const void *a3)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v6 = *(__CFSet **)(a1 + 40);
  if (v6) {
    CFSetRemoveValue(v6, a3);
  }
  os_unfair_recursive_lock_unlock();
  if (a2)
  {
    CFRelease(a2);
  }
}

void __IOHIDEventSystemClientMatchNotifyRelease(uint64_t a1, const __CFDictionary *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(void *)(a1 + 88))
  {
    CFNumberRef Value = CFDictionaryGetValue(a2, @"id");
    if (Value)
    {
      unsigned int v5 = Value;
      CFDataRef v6 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Value);
      if (v6)
      {
        CFDataRef v7 = v6;
        int v8 = *(_DWORD *)(a1 + 32);
        BytePtr = CFDataGetBytePtr(v6);
        int Length = CFDataGetLength(v7);
        io_hideventsystem_release_notification(v8, (uint64_t)BytePtr, Length);
        CFRelease(v7);
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 88), v5);
    }
  }
  os_unfair_recursive_lock_unlock();
  if (a2)
  {
    CFRelease(a2);
  }
}

uint64_t io_hideventsystem_release_notification(int a1, uint64_t a2, int a3)
{
  uint64_t v6 = a2;
  int v7 = 16777472;
  int v8 = a3;
  uint64_t v9 = *MEMORY[0x1E4F14068];
  int v10 = a3;
  *(void *)mach_msg_header_t msg = 2147483667;
  *(_DWORD *)&msg[8] = a1;
  *(_OWORD *)&msg[12] = xmmword_18B50C680;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  }
  uint64_t v3 = mach_msg((mach_msg_header_t *)msg, 1, 0x38u, 0, 0, 0, 0);
  if ((v3 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], *(mach_port_name_t *)&msg[12]);
    }
    mach_msg_destroy((mach_msg_header_t *)msg);
  }
  return v3;
}

void __IOHIDEventSystemClientIntRelease(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 112);
  if (v2) {
    CFRelease(v2);
  }
  mach_port_name_t v3 = *(_DWORD *)(a1 + 32);
  uint64_t v4 = (ipc_space_t *)MEMORY[0x1E4F14960];
  if (v3) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v3);
  }
  unsigned int v5 = *(const void **)(a1 + 272);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(__CFMachPort **)(a1 + 280);
  if (v6)
  {
    ipc_space_t v7 = *v4;
    mach_port_name_t Port = CFMachPortGetPort(v6);
    mach_port_mod_refs(v7, Port, 1u, -1);
    CFRelease(*(CFTypeRef *)(a1 + 280));
  }
  uint64_t v9 = *(const void **)(a1 + 288);
  if (v9) {
    CFRelease(v9);
  }
  int v10 = *(const void **)(a1 + 64);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = *(const void **)(a1 + 56);
  if (v11) {
    CFRelease(v11);
  }
  int v12 = *(_DWORD *)(a1 + 48);
  if (v12) {
    notify_cancel(v12);
  }
  uint64_t v13 = *(void *)(a1 + 40);
  if (v13)
  {
    unsigned int v14 = IOMIGMachPortGetPort(v13);
    IOMIGMachPortCacheRemove(v14);
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  uint64_t v15 = *(const void **)(a1 + 80);
  if (v15) {
    CFRelease(v15);
  }
  CFNumberRef v16 = *(const void **)(a1 + 88);
  if (v16) {
    CFRelease(v16);
  }
  uint64_t v17 = *(const void **)(a1 + 96);
  if (v17) {
    CFRelease(v17);
  }
  CFTypeID v18 = *(const void **)(a1 + 104);
  if (v18) {
    CFRelease(v18);
  }
  uint64_t v19 = *(const void **)(a1 + 120);
  if (v19) {
    CFRelease(v19);
  }
  CFIndex v20 = *(const void **)(a1 + 128);
  if (v20) {
    CFRelease(v20);
  }
  CFIndex v21 = *(const void **)(a1 + 136);
  if (v21) {
    CFRelease(v21);
  }
  int v22 = *(const void **)(a1 + 416);
  if (v22) {
    CFRelease(v22);
  }
  uint64_t v23 = *(const void **)(a1 + 432);
  if (v23) {
    CFRelease(v23);
  }
  CFArrayRef v24 = *(const void **)(a1 + 440);
  if (v24) {
    CFRelease(v24);
  }
  uint64_t v25 = *(const void **)(a1 + 176);
  if (v25) {
    _Block_release(v25);
  }
  uint64_t v26 = *(const void **)(a1 + 208);
  if (v26)
  {
    _Block_release(v26);
  }
}

uint64_t IOMIGMachPortCacheRemove(unsigned int a1)
{
  pthread_mutex_lock(&__ioPortCacheLock);
  CFDictionaryRemoveValue((CFMutableDictionaryRef)__ioPortCache, (const void *)a1);

  return pthread_mutex_unlock(&__ioPortCacheLock);
}

void __IOHIDEventSystemClientExtRelease(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef v2 = __IOHIDEventSystemClientStateSerialize(a1);
  if (*(void *)(a1 + 400))
  {
    if (!*(unsigned char *)(a1 + 408))
    {
      unsigned int v3 = atomic_load((unsigned int *)(a1 + 312));
      if (v3 != 3) {
        __IOHIDManagerExtRelease_cold_1(&v9, buf, (unsigned int *)(a1 + 312));
      }
    }
  }
  uint64_t v4 = _IOHIDLogCategory(0xEu);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 440), 0x8000100u);
    *(_DWORD *)buf = 136315394;
    uint64_t v11 = CStringPtr;
    __int16 v12 = 2114;
    CFMutableDictionaryRef v13 = v2;
    _os_log_impl(&dword_18B46C000, v4, OS_LOG_TYPE_DEFAULT, "Released connection: %s\n%{public}@", buf, 0x16u);
  }
  CFRelease(v2);
  if (*(void *)(a1 + 456)) {
    os_state_remove_handler();
  }
  uint64_t v6 = *(__CFMachPort **)(a1 + 56);
  if (v6) {
    CFMachPortInvalidate(v6);
  }
  ipc_space_t v7 = *(__CFMachPort **)(a1 + 280);
  if (v7) {
    CFMachPortInvalidate(v7);
  }
  if (*(unsigned char *)(a1 + 408)) {
    IOHIDEventSystemClientCancel(a1);
  }
  int v8 = *(__CFRunLoop **)(a1 + 384);
  if (v8
    && (IOHIDEventSystemClientUnscheduleWithRunLoop(a1, v8, *(const __CFString **)(a1 + 392)), *(void *)(a1 + 384))
    || !*(void *)(a1 + 400))
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 488));
  }
}

CFMutableDictionaryRef __IOHIDEventSystemClientStateSerialize(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v4 = *(void *)(a1 + 480);
    if (v4)
    {
      _IOHIDDictionaryAddSInt64(Mutable, @"MaxEventLatency", v4);
      CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
      CFStringRef v6 = _IOHIDCreateTimeString(v5, (time_t *)(a1 + 464));
      if (v6)
      {
        CFStringRef v7 = v6;
        CFDictionarySetValue(Mutable, @"LastEventTime", v6);
        CFRelease(v7);
      }
    }
    uint64_t v8 = *(void *)(a1 + 512);
    if (v8)
    {
      _IOHIDDictionaryAddSInt64(Mutable, @"PropertyNotificationCount", v8);
      CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a1);
      CFStringRef v10 = _IOHIDCreateTimeString(v9, (time_t *)(a1 + 496));
      if (v10)
      {
        CFStringRef v11 = v10;
        CFDictionarySetValue(Mutable, @"LastPropertyNotificationTime", v10);
        CFRelease(v11);
      }
    }
    __int16 v12 = *(const void **)(a1 + 432);
    if (v12) {
      CFDictionarySetValue(Mutable, @"caller", v12);
    }
    CFMutableDictionaryRef v13 = *(const void **)(a1 + 440);
    if (v13) {
      CFDictionarySetValue(Mutable, @"UUID", v13);
    }
    _IOHIDDictionaryAddSInt32(Mutable, @"port", *(_DWORD *)(a1 + 32));
    _IOHIDDictionaryAddSInt32(Mutable, @"resetCount", *(_DWORD *)(a1 + 144));
    _IOHIDDictionaryAddSInt32(Mutable, @"eventCount", *(_DWORD *)(a1 + 148));
    _IOHIDDictionaryAddSInt64(Mutable, @"eventMask", *(void *)(a1 + 152));
    uint64_t v14 = (const void *)*MEMORY[0x1E4F1CFD0];
    uint64_t v15 = (const void *)*MEMORY[0x1E4F1CFC8];
    if (*(void *)(a1 + 400)) {
      CFNumberRef v16 = (const void *)*MEMORY[0x1E4F1CFD0];
    }
    else {
      CFNumberRef v16 = (const void *)*MEMORY[0x1E4F1CFC8];
    }
    CFDictionarySetValue(Mutable, @"dispatchQueue", v16);
    if (*(void *)(a1 + 392)) {
      uint64_t v17 = v14;
    }
    else {
      uint64_t v17 = v15;
    }
    CFDictionarySetValue(Mutable, @"runloop", v17);
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 96));
    CFMutableArrayRef v19 = CFArrayCreateMutable(v2, Count, MEMORY[0x1E4F1D510]);
    if (v19)
    {
      CFMutableArrayRef v20 = v19;
      CFDictionaryRef v21 = *(const __CFDictionary **)(a1 + 96);
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 0x40000000;
      void context[2] = ____IOHIDEventSystemClientStateSerialize_block_invoke;
      void context[3] = &__block_descriptor_tmp_103_0;
      context[4] = v20;
      _IOHIDCFDictionaryApplyBlock(v21, context);
      CFDictionarySetValue(Mutable, @"services", v20);
      CFRelease(v20);
    }
    CFIndex v22 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 104));
    CFMutableArrayRef v23 = CFArrayCreateMutable(v2, v22, MEMORY[0x1E4F1D510]);
    if (v23)
    {
      CFMutableArrayRef v24 = v23;
      CFDictionaryRef v25 = *(const __CFDictionary **)(a1 + 104);
      v30[0] = MEMORY[0x1E4F143A8];
      v30[1] = 0x40000000;
      v30[2] = ____IOHIDEventSystemClientStateSerialize_block_invoke_2;
      v30[3] = &__block_descriptor_tmp_107_0;
      v30[4] = v24;
      _IOHIDCFDictionaryApplyBlock(v25, v30);
      CFDictionarySetValue(Mutable, @"virtualServices", v24);
      CFRelease(v24);
    }
    uint64_t v26 = *(void *)(a1 + 272);
    if (v26)
    {
      CFMutableDictionaryRef v27 = _IOHIDEventQueueSerializeState(v26);
      if (v27)
      {
        CFMutableDictionaryRef v28 = v27;
        CFDictionarySetValue(Mutable, @"eventQueue", v27);
        CFRelease(v28);
      }
    }
    os_unfair_recursive_lock_unlock();
  }
  return Mutable;
}

CFMutableDictionaryRef _IOHIDEventQueueSerializeState(uint64_t a1)
{
  kern_return_t attributes;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  int *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  mach_msg_type_number_t port_info_outCnt;
  integer_t port_info_out[4];
  long long v15;
  uint64_t v16;

  CFNumberRef v16 = 0;
  *(_OWORD *)port_info_out = 0u;
  uint64_t v15 = 0u;
  port_info_outCnt = 10;
  ipc_space_read_t v2 = *MEMORY[0x1E4F14960];
  os_unfair_recursive_lock_lock_with_options();
  mach_port_name_t v3 = *(_DWORD *)(a1 + 96);
  os_unfair_recursive_lock_unlock();
  attributes = mach_port_get_attributes(v2, v3, 2, port_info_out, &port_info_outCnt);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v6 = Mutable;
  if (Mutable)
  {
    CFStringRef v7 = *(int **)(a1 + 16);
    if (v7)
    {
      _IOHIDDictionaryAddSInt32(Mutable, @"tail", v7[2]);
      _IOHIDDictionaryAddSInt32(v6, @"head", v7[1]);
      _IOHIDDictionaryAddSInt32(v6, @"size", *v7);
      _IOHIDDictionaryAddSInt32(v6, @"droppedEvents", *(_DWORD *)(a1 + 168));
      if (!attributes) {
        _IOHIDDictionaryAddSInt32(v6, @"msgCount", v15);
      }
      _IOHIDDictionaryAddSInt64(v6, @"lastNotifyTime", *(void *)(a1 + 128));
      _IOHIDDictionaryAddSInt64(v6, @"lastNotifyEventTimeStamp", *(void *)(a1 + 120));
      _IOHIDDictionaryAddSInt64(v6, @"notificationCount", *(void *)(a1 + 136));
      uint64_t v8 = (const void *)*MEMORY[0x1E4F1CFD0];
      CFAllocatorRef v9 = (const void *)*MEMORY[0x1E4F1CFC8];
      if (*(_DWORD *)(a1 + 148)) {
        CFStringRef v10 = (const void *)*MEMORY[0x1E4F1CFD0];
      }
      else {
        CFStringRef v10 = (const void *)*MEMORY[0x1E4F1CFC8];
      }
      CFDictionaryAddValue(v6, @"active", v10);
      if (*(_DWORD *)(a1 + 152)) {
        CFStringRef v11 = v8;
      }
      else {
        CFStringRef v11 = v9;
      }
      CFDictionaryAddValue(v6, @"suspended", v11);
    }
  }
  return v6;
}

void _IOHIDDictionaryAddSInt32(void *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFNumberRef v6 = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
  if (v6)
  {
    CFNumberRef v7 = v6;
    CFDictionaryAddValue((CFMutableDictionaryRef)a1, a2, v6);
    CFRelease(v7);
  }
}

CFMutableDictionaryRef _IOHIDServiceCopyEventCounts(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
  }
  ++*(_DWORD *)a1[9];
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    for (uint64_t i = 0; i != 43; ++i)
    {
      if (*(void *)(a1[52] + 8 * i))
      {
        Name = IOHIDEventTypeGetName(i);
        _IOHIDDictionaryAddSInt64(Mutable, Name, *(void *)(a1[52] + 8 * i));
      }
    }
    if (!CFDictionaryGetCount(Mutable))
    {
      CFRelease(Mutable);
      CFMutableDictionaryRef Mutable = 0;
    }
  }
  uint64_t v6 = a1[9];
  if (*(_DWORD *)v6)
  {
    --*(_DWORD *)v6;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
    }
  }
  return Mutable;
}

void _IOHIDDictionaryAddSInt64(void *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFNumberRef v6 = CFNumberCreate(v5, kCFNumberSInt64Type, &valuePtr);
  if (v6)
  {
    CFNumberRef v7 = v6;
    CFDictionaryAddValue((CFMutableDictionaryRef)a1, a2, v6);
    CFRelease(v7);
  }
}

__CFString *IOHIDEventTypeGetName(unsigned int a1)
{
  if (a1 > 0x2A) {
    return @"Unknown";
  }
  else {
    return (__CFString *)*((void *)&off_1E5489F88 + (int)a1);
  }
}

void __IOHIDEventSystemServiceRemoved(void *a1, int a2, CFTypeRef cf)
{
  CFRetain(cf);
  CFRetain(a1);
  CFAllocatorRef v5 = a1[18];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = ____IOHIDEventSystemServiceRemoved_block_invoke;
  v6[3] = &__block_descriptor_tmp_54;
  v6[4] = cf;
  _OWORD v6[5] = a1;
  dispatch_async(v5, v6);
}

CFStringRef _IOHIDCreateTimeString(const __CFAllocator *a1, time_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  memset(&v6, 0, sizeof(v6));
  *(_OWORD *)CFNumberRef v7 = 0u;
  long long v8 = 0u;
  uint64_t v4 = localtime_r(a2, &v6);
  if (v4 || (uint64_t v4 = gmtime_r(a2, &v6)) != 0) {
    strftime(v7, 0x20uLL, "%F %H:%M:%S", v4);
  }
  return CFStringCreateWithFormat(a1, 0, @"%s.%06d", v4, v7, *((unsigned int *)a2 + 2));
}

uint64_t _IOHIDEventSystemConnectionPropertyChanged(uint64_t a1, void *a2, const void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFMutableArrayRef v24 = a3;
  keys = a2;
  os_unfair_recursive_lock_lock_with_options();
  CFSetRef v5 = *(const __CFSet **)(a1 + 136);
  if (v5 && CFSetContainsValue(v5, a2))
  {
    uint64_t v6 = mach_absolute_time();
    CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
    CFDictionaryRef v8 = CFDictionaryCreate(v7, (const void **)&keys, &v24, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v8)
    {
      CFDictionaryRef v9 = v8;
      CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)a1);
      CFDataRef v11 = (const __CFData *)_IOHIDCreateBinaryData(v10, v9);
      if (v11)
      {
        CFDataRef v12 = v11;
        if (!*(_DWORD *)(a1 + 448))
        {
          mach_port_t v13 = *(_DWORD *)(a1 + 40);
          BytePtr = CFDataGetBytePtr(v11);
          int Length = CFDataGetLength(v12);
          int v16 = iohideventsystem_client_dispatch_properties_changed(v13, (uint64_t)BytePtr, Length, 0);
          if (v16)
          {
            int v17 = v16;
            if (v16 == 268451843)
            {
              CFTypeID v18 = _IOHIDLogCategory(9u);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
              {
                uint64_t v19 = *(void *)(a1 + 168);
                *(_DWORD *)buf = 136315394;
                uint64_t v27 = v19;
                __int16 v28 = 1024;
                int v29 = 268451843;
                _os_log_impl(&dword_18B46C000, v18, OS_LOG_TYPE_INFO, "%s: iohideventsystem_client_dispatch_properties_changed:0x%x", buf, 0x12u);
              }
            }
            else
            {
              CFMutableArrayRef v20 = _IOHIDLogCategory(9u);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                _IOHIDEventSystemConnectionPropertyChanged_cold_1();
              }
            }
            __IOHIDEventSystemConnectionCheckServerStatus(v17, a1);
          }
        }
        CFRelease(v12);
      }
      CFRelease(v9);
    }
    uint64_t v21 = mach_absolute_time();
    unint64_t v22 = _IOHIDGetTimestampDelta(v21, v6, 1u);
    if (v22 > *(void *)(a1 + 376)) {
      *(void *)(a1 + 376) = v22;
    }
  }
  return os_unfair_recursive_lock_unlock();
}

void *IOHIDEventGetVendorDefinedData(void *result, uint64_t *a2, void *a3)
{
  uint64_t v4 = result;
  if (a2)
  {
    uint64_t result = (void *)IOHIDEventGetEventWithOptions(result, 1, 0);
    if (result) {
      uint64_t v6 = result[13] + 28;
    }
    else {
      uint64_t v6 = 0;
    }
    *a2 = v6;
  }
  if (a3)
  {
    uint64_t result = (void *)IOHIDEventGetEventWithOptions(v4, 1, 4026531840);
    if (result) {
      uint64_t v7 = *(unsigned int *)(result[13] + 24);
    }
    else {
      uint64_t v7 = 0;
    }
    *a3 = v7;
  }
  return result;
}

IOReturn IODataQueueEnqueue(IODataQueueMemory *dataQueue, void *data, uint32_t dataSize)
{
  return __IODataQueueEnqueue(dataQueue, 0, 0, *(size_t *)&dataSize, data, 0, 0, 0);
}

uint64_t __FilterFunctionSetEventCallback(uint64_t a1)
{
  return IOHIDServiceFilterSetEventCallback(a1);
}

uint64_t IOPSRequestBatteryUpdate(int a1)
{
  io_connect_t connect = 0;
  uint64_t input = a1;
  CFDictionaryRef v1 = IOServiceMatching("AppleSmartBatteryManager");
  io_service_t MatchingService = IOServiceGetMatchingService(0, v1);
  if (!MatchingService) {
    return 3758097136;
  }
  io_object_t v3 = MatchingService;
  uint64_t v4 = IOServiceOpen(MatchingService, *MEMORY[0x1E4F14960], 0, &connect);
  if (!v4)
  {
    IOConnectCallMethod(connect, 4u, &input, 1u, 0, 0, 0, 0, 0, 0);
    IOServiceClose(connect);
  }
  IOObjectRelease(v3);
  return v4;
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return IOConnectCallMethod(connection, selector, 0, 0, inputStruct, inputStructCnt, 0, 0, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  kern_return_t result;
  size_t v19;
  void *v20;
  unsigned int v21;
  uint64_t v22;
  size_t v23;
  unsigned int v24;

  int v12 = inputStructCnt;
  int v13 = (int)inputStruct;
  CFMutableArrayRef v24 = 0;
  unint64_t v22 = 0;
  CFMutableArrayRef v23 = 0;
  uint64_t v21 = 0;
  BOOL v14 = inputStructCnt > 0x1000;
  if (inputStructCnt <= 0x1000)
  {
    int v15 = 0;
  }
  else
  {
    LODWORD(inputStruct) = 0;
    LODWORD(inputStructCnt) = 0;
    int v15 = v13;
  }
  if (v14) {
    int v16 = v12;
  }
  else {
    int v16 = 0;
  }
  if (!outputCnt) {
    outputCnt = (uint32_t *)&IOConnectCallMethod_zero;
  }
  if (!outputStructCnt) {
    return io_connect_method(connection, selector, (int)input, inputCnt, (int)inputStruct, inputStructCnt, v15, v16, 0, (int *)&v24, output, (int *)outputCnt, 0, &v23);
  }
  __dst = outputStruct;
  if (*outputStructCnt == -3)
  {
    uint64_t result = io_connect_method_var_output(connection, selector, (int)input, inputCnt, (int)inputStruct, inputStructCnt, v15, v16, 0, (int *)&v24, output, (int *)outputCnt, &v22, &v21);
    *(void *)outputStruct = v22;
    uint64_t v19 = v21;
  }
  else
  {
    if (*outputStructCnt > 0x1000)
    {
      CFMutableArrayRef v20 = outputStruct;
      CFMutableArrayRef v23 = *outputStructCnt;
      __dst = 0;
    }
    else
    {
      CFMutableArrayRef v20 = 0;
      CFMutableArrayRef v24 = *outputStructCnt;
    }
    uint64_t result = io_connect_method(connection, selector, (int)input, inputCnt, (int)inputStruct, inputStructCnt, v15, v16, __dst, (int *)&v24, output, (int *)outputCnt, (uint64_t)v20, &v23);
    if (*outputStructCnt > 0x1000) {
      uint64_t v19 = v23;
    }
    else {
      uint64_t v19 = v24;
    }
  }
  *outputStructCnt = v19;
  return result;
}

__CFDictionary *MakeOneStringProp(const void *a1, const char *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFStringRef v6 = CFStringCreateWithCString(v4, a2, 0);
    if (v6)
    {
      uint64_t v7 = v6;
      CFDictionarySetValue(Mutable, a1, v6);
    }
    else
    {
      uint64_t v7 = Mutable;
      CFMutableDictionaryRef Mutable = 0;
    }
    CFRelease(v7);
  }
  return Mutable;
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return MakeOneStringProp(@"IOProviderClass", name);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  kern_return_t v2;

  CFAllocatorRef v2 = io_service_close(connect);
  mach_port_deallocate(*MEMORY[0x1E4F14960], connect);
  return v2;
}

uint64_t io_service_close(unsigned int a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  *(void *)&v5.msgh_bits = 0x1800001513;
  *(void *)&v5.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v5.msgh_voucher_port = 0xB0000000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if (v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      uint64_t v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  kern_return_t v12;
  io_connect_t result;
  io_connect_t connect;

  io_connect_t connect = 0;
  *notifier = 0;
  int v8 = IONotificationPortCreate(0);
  io_registry_entry_t v9 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (v9)
  {
    io_object_t v10 = v9;
    if (IOServiceOpen(v9, *MEMORY[0x1E4F14960], 0, &connect)) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = connect == 0;
    }
    if (v11)
    {
      IOObjectRelease(v10);
    }
    else
    {
      int v12 = IOServiceAddInterestNotification(v8, v10, "IOAppPowerStateInterest", callback, refcon, notifier);
      IOObjectRelease(v10);
      if (!v12)
      {
        *thePortRef = v8;
        return connect;
      }
    }
  }
  if (v8) {
    IONotificationPortDestroy(v8);
  }
  if (connect) {
    IOServiceClose(connect);
  }
  uint64_t result = *notifier;
  if (*notifier)
  {
    IOObjectRelease(result);
    return 0;
  }
  return result;
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  v7[4] = *MEMORY[0x1E4F143B8];
  v7[0] = 0;
  v7[1] = callback;
  v7[2] = refCon;
  v7[3] = service;
  return io_service_add_interest_notification(service, interestType, *((_DWORD *)notifyPort + 1), v7, 4u, notification);
}

uint64_t io_service_add_interest_notification(unsigned int a1, const char *a2, int a3, const void *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  memset(v20, 0, 204);
  long long v19 = 0u;
  memset(&reply_port, 0, sizeof(reply_port));
  int v17 = 1;
  int v18 = a3;
  DWORD1(v19) = 1310720;
  *((void *)&v19 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v10 = mig_strncpy_zerofill((char *)v20 + 8, a2, 128);
  }
  else {
    int v10 = mig_strncpy((char *)v20 + 8, a2, 128);
  }
  LODWORD(v20[0]) = 0;
  DWORD1(v20[0]) = v10;
  if (a5 > 8) {
    return 4294966989;
  }
  uint64_t v12 = (v10 + 3) & 0xFFFFFFFC;
  memcpy((char *)v20 + v12 + 12, a4, 8 * a5);
  *(_DWORD *)((char *)v20 + v12 + 8) = a5;
  mach_port_t v13 = mig_get_reply_port();
  reply_port.msgh_bits = -2147478253;
  reply_port.msgh_size = v12 + 8 * a5 + 60;
  *(void *)&reply_port.mach_port_t msgh_remote_port = __PAIR64__(v13, a1);
  *(void *)&reply_port.msgh_voucher_port = 0xB3500000000;
  uint64_t v14 = mach_msg2_internal();
  uint64_t v11 = v14;
  if ((v14 - 268435458) <= 0xE && ((1 << (v14 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port.msgh_local_port);
  }
  else
  {
    if (!v14)
    {
      if (reply_port.msgh_id == 71)
      {
        uint64_t v11 = 4294966988;
      }
      else if (reply_port.msgh_id == 2969)
      {
        if ((reply_port.msgh_bits & 0x80000000) != 0)
        {
          uint64_t v11 = 4294966996;
          if (v17 == 1 && reply_port.msgh_size == 40 && !reply_port.msgh_remote_port && WORD3(v19) << 16 == 1114112)
          {
            uint64_t v11 = 0;
            *a6 = v18;
            return v11;
          }
        }
        else if (reply_port.msgh_size == 36)
        {
          uint64_t v11 = 4294966996;
          if (v19)
          {
            if (reply_port.msgh_remote_port) {
              uint64_t v11 = 4294966996;
            }
            else {
              uint64_t v11 = v19;
            }
          }
        }
        else
        {
          uint64_t v11 = 4294966996;
        }
      }
      else
      {
        uint64_t v11 = 4294966995;
      }
      mach_msg_destroy(&reply_port);
      return v11;
    }
    mig_dealloc_reply_port(reply_port.msgh_local_port);
  }
  return v11;
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  kern_return_t result;

  uint64_t result = io_service_open_extended(service, owningTask, type, *MEMORY[0x1E4F14068], 0, 0);
  if (!result) {
    return 0;
  }
  return result;
}

uint64_t io_service_open_extended(unsigned int a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  int v10 = 2;
  int v11 = a2;
  uint64_t v12 = 0x13000000000000;
  uint64_t v13 = a5;
  int v14 = 0x1000000;
  int v15 = a6;
  uint64_t v16 = *MEMORY[0x1E4F14068];
  int v17 = a3;
  uint64_t v18 = a4;
  int v19 = a6;
  *(void *)&v9.msgh_bits = 0x5080001513;
  *(void *)&v9.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v9.msgh_voucher_port = 0xB2E00000000;
  uint64_t v6 = mach_msg2_internal();
  uint64_t v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v9.msgh_local_port);
  }
  else if (v6)
  {
    mig_dealloc_reply_port(v9.msgh_local_port);
  }
  else
  {
    uint64_t v7 = 4294966995;
    mach_msg_destroy(&v9);
  }
  return v7;
}

uint64_t io_connect_method_var_output(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__dst, int *a10, void *a11, int *a12, void *a13, _DWORD *a14)
{
  unsigned int v14 = MEMORY[0x1F4188790]();
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  *(_OWORD *)&v48[16] = 0u;
  *(_OWORD *)__n = 0u;
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  *(_OWORD *)uint64_t v48 = 0u;
  *(void *)&v48[8] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&v48[16] = v20;
  if (v15 <= 0x10)
  {
    uint64_t v21 = v19;
    uint64_t v22 = v18;
    unsigned int v23 = v17;
    CFMutableArrayRef v24 = v16;
    unsigned int v25 = v15;
    unsigned int v26 = v14;
    uint64_t v27 = 2 * v15;
    __memcpy_chk();
    *(_DWORD *)&v48[20] = v25;
    if (v23 <= 0x1000)
    {
      uint64_t v30 = &reply_port[v27];
      uint64_t v31 = (v23 + 3) & 0xFFFFFFFC;
      unsigned int v32 = (char *)&reply_port[v27] + v31;
      int v33 = v27 * 4 + v31;
      memcpy(v30 + 11, v24, v23);
      v30[10] = v23;
      *(void *)(v32 + 44) = v22;
      *(void *)(v32 + 52) = v21;
      int v34 = *a10;
      if (*a10 >= 0x1000) {
        int v34 = 4096;
      }
      *((_DWORD *)v32 + 15) = v34;
      int v35 = *a12;
      if (*a12 >= 0x10) {
        int v35 = 16;
      }
      *((_DWORD *)v32 + 16) = v35;
      mach_port_t v36 = mig_get_reply_port();
      reply_port[0] = 5395;
      reply_port[1] = v33 + 68;
      *(void *)&reply_port[2] = __PAIR64__(v36, v26);
      *(void *)uint64_t v48 = 0xB3800000000;
      uint64_t v37 = mach_msg2_internal();
      uint64_t v28 = v37;
      if ((v37 - 268435458) <= 0xE && ((1 << (v37 - 2)) & 0x4003) != 0)
      {
        mig_put_reply_port(reply_port[3]);
        return v28;
      }
      if (v37)
      {
        mig_dealloc_reply_port(reply_port[3]);
        return v28;
      }
      if (*(_DWORD *)&v48[4] == 71)
      {
        uint64_t v28 = 4294966988;
      }
      else if (*(_DWORD *)&v48[4] == 2972)
      {
        if ((reply_port[0] & 0x80000000) != 0)
        {
          uint64_t v28 = 4294966996;
          if (*(_DWORD *)&v48[8] == 1
            && reply_port[1] >= 0x40
            && reply_port[1] <= 0x10C0
            && !reply_port[2]
            && v48[23] == 1)
          {
            int v38 = HIDWORD(__n[0]);
            if (HIDWORD(__n[0]) <= 0x1000 && reply_port[1] - 64 >= HIDWORD(__n[0]))
            {
              unsigned int v39 = (HIDWORD(__n[0]) + 3) & 0xFFFFFFFC;
              if (reply_port[1] >= v39 + 64)
              {
                unsigned __int16 v40 = (char *)reply_port + v39;
                mach_port_t v41 = *((_DWORD *)v40 + 14);
                if (v41 <= 0x10 && v41 <= (reply_port[1] - v39 - 64) >> 3 && reply_port[1] - v39 == 8 * v41 + 64)
                {
                  CFIndex v42 = v40 - 4096;
                  uint64_t v43 = (uint64_t)&v40[8 * v41 - 4096];
                  if (*(_DWORD *)&v48[24] == *(_DWORD *)(v43 + 4156))
                  {
                    size_t v44 = *a10;
                    if (HIDWORD(__n[0]) <= v44)
                    {
                      memcpy(__dst, &__n[1], HIDWORD(__n[0]));
                      *a10 = v38;
                      unsigned int v45 = *((_DWORD *)v42 + 1038);
                      CFMutableDictionaryRef v46 = v42 + 4156;
                      if (v45 <= *a12)
                      {
                        memcpy(a11, v46, 8 * v45);
                        uint64_t v28 = 0;
                        *a12 = *((_DWORD *)v42 + 1038);
                        *a13 = *(void *)&v48[12];
                        *a14 = *(_DWORD *)(v43 + 4156);
                        return v28;
                      }
                      memcpy(a11, v46, (8 * *a12));
                      *a12 = *((_DWORD *)v42 + 1038);
                    }
                    else
                    {
                      memcpy(__dst, &__n[1], v44);
                      *a10 = v38;
                    }
                    return 4294966989;
                  }
                }
              }
            }
          }
        }
        else if (reply_port[1] == 36)
        {
          uint64_t v28 = 4294966996;
          if (*(_DWORD *)&v48[16])
          {
            if (reply_port[2]) {
              uint64_t v28 = 4294966996;
            }
            else {
              uint64_t v28 = *(unsigned int *)&v48[16];
            }
          }
        }
        else
        {
          uint64_t v28 = 4294966996;
        }
      }
      else
      {
        uint64_t v28 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v28;
    }
  }
  return 4294966989;
}

uint64_t IOHIDServiceClientFastPathInit(uint64_t a1, uint64_t a2)
{
  io_iterator_t existing = 0;
  uint64_t v2 = (void *)(a1 + 104);
  if (*(void *)(a1 + 104)) {
    return 1;
  }
  SInt32 theScore = 0;
  uint64_t valuePtr = 0;
  CFNumberRef v5 = *(const __CFNumber **)(a1 + 16);
  if (!v5 || !CFNumberGetValue(v5, kCFNumberSInt64Type, &valuePtr)) {
    goto LABEL_24;
  }
  CFDictionaryRef v7 = IORegistryEntryIDMatching(valuePtr);
  if (!v7)
  {
    int v20 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      IOHIDServiceClientFastPathInit_cold_1(v20);
    }
    goto LABEL_24;
  }
  uint64_t MatchingServices = IOServiceGetMatchingServices(0, v7, &existing);
  if (MatchingServices)
  {
    uint64_t v21 = MatchingServices;
    uint64_t v22 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      IOHIDServiceClientFastPathInit_cold_5(v21, v22, v23, v24, v25, v26, v27, v28);
    }
    goto LABEL_24;
  }
  io_object_t v9 = IOIteratorNext(existing);
  if (!v9)
  {
    int v29 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      IOHIDServiceClientFastPathInit_cold_2(v29);
    }
LABEL_24:
    io_service_t v10 = 0;
LABEL_25:
    uint64_t v3 = 0;
    goto LABEL_11;
  }
  io_service_t v10 = v9;
  CFUUIDRef v11 = CFUUIDGetConstantUUIDWithBytes(0, 0xBu, 0x84u, 0x2Au, 0xDDu, 0xC3u, 0x95u, 0x43u, 0x52u, 0x95u, 0xF6u, 0x65u, 0x85u, 0xEBu, 0x51u, 0x56u, 0x23u);
  CFUUIDRef v12 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  uint64_t v13 = IOCreatePlugInInterfaceForService(v10, v11, v12, (IOCFPlugInInterface ***)(a1 + 112), &theScore);
  if (v13)
  {
    uint64_t v30 = v13;
    uint64_t v31 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      IOHIDServiceClientFastPathInit_cold_4(v30, v31, v32, v33, v34, v35, v36, v37);
    }
    goto LABEL_25;
  }
  uint64_t v14 = *(void *)(a1 + 112);
  unsigned int v15 = *(uint64_t (**)(uint64_t, void, void, void *))(*(void *)v14 + 8);
  CFUUIDRef v16 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], 0x27u, 0xBAu, 0xAEu, 0x90u, 0x2Fu, 0xE5u, 0x40u, 0x2Au, 0xBFu, 0x7Fu, 0x4Eu, 0xFAu, 0x27u, 0x7Du, 0x37u, 8u);
  CFUUIDBytes v17 = CFUUIDGetUUIDBytes(v16);
  uint64_t v18 = v15(v14, *(void *)&v17.byte0, *(void *)&v17.byte8, v2);
  if (v18)
  {
    uint64_t v38 = v18;
    unsigned int v39 = _IOHIDLogCategory(4u);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      IOHIDServiceClientFastPathInit_cold_3(v38, v39, v40, v41, v42, v43, v44, v45);
    }
    goto LABEL_25;
  }
  uint64_t v3 = (*(unsigned __int8 (**)(void, void, uint64_t))(*(void *)*v2 + 32))(*v2, 0, a2);
LABEL_11:
  if (existing) {
    IOObjectRelease(existing);
  }
  if (v10) {
    IOObjectRelease(v10);
  }
  if (!v3) {
    IOHIDServiceClientFastPathInvalidate(a1);
  }
  return v3;
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  kern_return_t v3;
  mach_port_t v6;
  CFDataRef v7;
  unint64_t Length;
  int v9;
  const char *BytePtr;
  kern_return_t matching_services_bin;
  const UInt8 *v12;
  kern_return_t matching_services_ool;
  mach_port_t mainPorta;

  uint64_t v3 = -536870206;
  if (!matching) {
    return v3;
  }
  uint64_t v6 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = mainPorta;
    }
  }
  CFDictionaryRef v7 = IOCFSerialize(matching, gIOKitLibSerializeOptions);
  CFRelease(matching);
  if (!v7) {
    return -536870201;
  }
  int Length = CFDataGetLength(v7);
  io_object_t v9 = Length;
  if (gIOKitLibSerializeOptions)
  {
    if (Length <= 0xFFF)
    {
      CFDataGetBytePtr(v7);
      matching_services_bin = io_service_get_matching_services_bin();
      goto LABEL_13;
    }
  }
  else if (Length <= 0x1FF)
  {
    BytePtr = (const char *)CFDataGetBytePtr(v7);
    matching_services_bin = io_service_get_matching_services(v6, BytePtr);
LABEL_13:
    uint64_t v3 = matching_services_bin;
    goto LABEL_17;
  }
  CFUUIDRef v12 = CFDataGetBytePtr(v7);
  matching_services_ool = io_service_get_matching_services_ool(v6, (uint64_t)v12, v9);
  if (matching_services_ool) {
    uint64_t v3 = matching_services_ool;
  }
  else {
    uint64_t v3 = 0;
  }
LABEL_17:
  CFRelease(v7);
  if (v6 && v6 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v6);
  }
  return v3;
}

uint64_t io_service_get_matching_services_bin()
{
  unsigned int v0 = MEMORY[0x1F4188790]();
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v8 = 0u;
  *((void *)&v8 + 1) = *MEMORY[0x1E4F14068];
  if (v1 > 0x1000) {
    return 4294966989;
  }
  unsigned int v3 = v1;
  unsigned int v4 = v0;
  __memcpy_chk();
  LODWORD(v9) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 36;
  *(void *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), v4);
  *(void *)&long long v8 = 0xB4100000000;
  uint64_t v5 = mach_msg2_internal();
  uint64_t v2 = v5;
  if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if (v5)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    uint64_t v2 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v2;
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  kern_return_t result;

  uint64_t result = io_registry_entry_get_parent_iterator(entry, plane);
  if (!result)
  {
    io_iterator_next(0);
    *parent = 0;
    mach_port_deallocate(*MEMORY[0x1E4F14960], 0);
    if (*parent) {
      return 0;
    }
    else {
      return -536870208;
    }
  }
  return result;
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  if (io_iterator_next(iterator)) {
    return 0;
  }
  else {
    return 0;
  }
}

uint64_t io_iterator_next(unsigned int a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  *(void *)&v5.msgh_bits = 0x1800001513;
  *(void *)&v5.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v5.msgh_voucher_port = 0xAF200000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if (v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      uint64_t v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t io_registry_entry_get_parent_iterator(unsigned int a1, const char *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v8 = 0u;
  *((void *)&v8 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  }
  else {
    int v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  }
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(void *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&long long v8 = 0xAFE00000000;
  uint64_t v4 = mach_msg2_internal();
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if (v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    uint64_t v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

CFMutableDictionaryRef IORegistryEntryIDMatching(uint64_t entryID)
{
  uint64_t valuePtr = entryID;
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFNumberRef v3 = CFNumberCreate(v1, kCFNumberSInt64Type, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      CFDictionarySetValue(Mutable, @"IORegistryEntryID", v3);
    }
    else
    {
      CFNumberRef v4 = Mutable;
      CFMutableDictionaryRef Mutable = 0;
    }
    CFRelease(v4);
  }
  return Mutable;
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  io_object_t v2 = *notifier;
  if (v2)
  {
    IOObjectRelease(v2);
    *notifier = 0;
  }
  return 0;
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return mach_port_deallocate(*MEMORY[0x1E4F14960], object);
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  kern_return_t v17;
  __CFArray *v18;
  CFMutableArrayRef v19;
  CFArrayRef v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex v23;
  CFUUIDRef v24;
  void *v25;
  void *v26;
  CFUUIDRef v27;
  void (*v28)(void *, void, void, void **);
  CFUUIDBytes v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex v32;
  int v33;
  CFIndex v34;
  CFIndex v35;
  int v36;
  CFIndex v37;
  void *v38;
  int v39;
  CFArrayRef SystemExtensionsFolderURLs;
  CFIndex Count;
  CFIndex v43;
  CFUUIDRef v44;
  CFIndex v45;
  CFURLRef ValueAtIndex;
  CFURLRef v47;
  CFURLRef v48;
  __CFBundle *Bundle;
  CFDictionaryRef InfoDictionary;
  CFDictionaryRef v51;
  kern_return_t matched;
  SInt32 *v53;
  SInt32 *v54;
  io_service_t v55;
  io_service_t v56;
  void *value;
  BOOLean_t matches[2];
  CFStringRef context;
  CFUUIDRef v62;

  value = 0;
  *(void *)matches = 0;
  uint64_t context = 0;
  long long v62 = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (!Mutable)
  {
    CFTypeRef CFProperty = 0;
    goto LABEL_11;
  }
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(service, @"IOCFPlugInTypes", v8, 0);
  if (!CFProperty) {
    goto LABEL_11;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(CFProperty)) {
    goto LABEL_11;
  }
  uint64_t context = 0;
  long long v62 = pluginType;
  CFDictionaryApplyFunction((CFDictionaryRef)CFProperty, (CFDictionaryApplierFunction)_IOGetWithUUIDKey, &context);
  CFStringRef v12 = context;
  if (!context) {
    goto LABEL_11;
  }
  if (CFStringGetCharacterAtIndex(context, 0) == 47)
  {
    CFStringAppend(Mutable, v12);
    CFURLRef v13 = CFURLCreateWithFileSystemPath(0, Mutable, kCFURLPOSIXPathStyle, 1u);
    if (v13)
    {
      CFURLRef v14 = v13;
      if (CFURLResourceIsReachable(v13, 0))
      {
        long long v15 = CFPlugInCreate(0, v14);
        CFRelease(v14);
        if (v15) {
          goto LABEL_65;
        }
      }
      else
      {
        CFRelease(v14);
      }
    }
  }
  SystemExtensionsFolderURLs = (const __CFArray *)OSKextGetSystemExtensionsFolderURLs();
  CFIndex Count = CFArrayGetCount(SystemExtensionsFolderURLs);
  if (Count < 1)
  {
LABEL_11:
    CFArrayRef FactoriesForPlugInTypeInPlugIn = 0;
    long long v17 = 0;
    matches[1] = 1;
    goto LABEL_12;
  }
  uint64_t v43 = Count;
  long long v56 = service;
  uint64_t v44 = pluginType;
  long long v54 = theScore;
  uint64_t v45 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(SystemExtensionsFolderURLs, v45);
    CFMutableDictionaryRef v47 = CFURLCreateCopyAppendingPathComponent(0, ValueAtIndex, v12, 1u);
    if (v47)
    {
      uint64_t v48 = v47;
      long long v15 = CFPlugInCreate(0, v47);
      CFRelease(v48);
      if (v15) {
        break;
      }
    }
    if (v43 == ++v45)
    {
      SInt32 theScore = v54;
      pluginint Type = v44;
      service = v56;
      goto LABEL_11;
    }
  }
  SInt32 theScore = v54;
  pluginint Type = v44;
  service = v56;
LABEL_65:
  Bundle = CFPlugInGetBundle(v15);
  if (Bundle
    && (InfoDictionary = CFBundleGetInfoDictionary(Bundle)) != 0
    && (long long v51 = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, @"Personality")) != 0)
  {
    matched = IOServiceMatchPropertyTable(service, v51, &matches[1]);
    if (matched)
    {
      long long v17 = matched;
      CFArrayRef FactoriesForPlugInTypeInPlugIn = 0;
      matches[1] = 0;
      goto LABEL_12;
    }
    if (!matches[1])
    {
      CFArrayRef FactoriesForPlugInTypeInPlugIn = 0;
      goto LABEL_72;
    }
  }
  else
  {
    matches[1] = 1;
  }
  CFArrayRef FactoriesForPlugInTypeInPlugIn = CFPlugInFindFactoriesForPlugInTypeInPlugIn(pluginType, v15);
LABEL_72:
  long long v17 = 0;
LABEL_12:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (CFProperty) {
    CFRelease(CFProperty);
  }
  if (!v17)
  {
    long long v17 = -536870201;
    if (!FactoriesForPlugInTypeInPlugIn) {
      return v17;
    }
    if (!CFArrayGetCount(FactoriesForPlugInTypeInPlugIn)) {
      goto LABEL_18;
    }
    long long v55 = service;
    long long v18 = CFArrayCreateMutable(v8, 0, 0);
    long long v19 = CFArrayCreateMutable(v8, 0, 0);
    long long v20 = v19;
    if (v18)
    {
      if (v19)
      {
        long long v21 = CFArrayGetCount(FactoriesForPlugInTypeInPlugIn);
        if (v21 >= 1)
        {
          long long v22 = v21;
          long long v23 = 0;
          long long v53 = theScore;
          do
          {
            long long v24 = (const __CFUUID *)CFArrayGetValueAtIndex(FactoriesForPlugInTypeInPlugIn, v23);
            long long v25 = CFPlugInInstanceCreate(0, v24, pluginType);
            if (v25)
            {
              long long v26 = v25;
              long long v27 = pluginType;
              long long v28 = *(void (**)(void *, void, void, void **))(*(void *)v25 + 8);
              long long v29 = CFUUIDGetUUIDBytes(interfaceType);
              v28(v26, *(void *)&v29.byte0, *(void *)&v29.byte8, &value);
              pluginint Type = v27;
              (*(void (**)(void *))(*(void *)v26 + 24))(v26);
              if (value)
              {
                matches[0] = 0;
                if ((*(unsigned int (**)(void *, void, void, BOOLean_t *))(*(void *)value + 40))(value, 0, v55, matches))
                {
                  (*(void (**)(void *))(*(void *)value + 24))(value);
                }
                else
                {
                  long long v30 = CFArrayGetCount(v20);
                  if (v30 < 1)
                  {
                    long long v32 = 0;
                  }
                  else
                  {
                    long long v31 = v30;
                    long long v32 = 0;
                    while (1)
                    {
                      long long v33 = matches[0];
                      if (v33 > (int)CFArrayGetValueAtIndex(v20, v32)) {
                        break;
                      }
                      if (v31 == ++v32)
                      {
                        long long v32 = v31;
                        break;
                      }
                    }
                    SInt32 theScore = v53;
                  }
                  pluginint Type = v27;
                  CFArrayInsertValueAtIndex(v18, v32, value);
                  CFArrayInsertValueAtIndex(v20, v32, (const void *)matches[0]);
                }
              }
            }
            ++v23;
          }
          while (v23 != v22);
        }
      }
    }
    long long v34 = CFArrayGetCount(v18);
    if (v34 < 1)
    {
      long long v36 = 0;
LABEL_49:
      CFRelease(FactoriesForPlugInTypeInPlugIn);
      if (v18) {
        CFRelease(v18);
      }
      if (v20) {
        CFRelease(v20);
      }
      if (v36) {
        return 0;
      }
      else {
        return -536870210;
      }
    }
    long long v35 = v34;
    long long v36 = 0;
    long long v37 = 0;
    while (1)
    {
      long long v38 = (void *)CFArrayGetValueAtIndex(v18, v37);
      value = v38;
      if (v36)
      {
        long long v36 = 1;
      }
      else
      {
        uint64_t v39 = (*(uint64_t (**)(void *, void, void))(*(void *)v38 + 48))(v38, 0, v55);
        long long v38 = value;
        if (!v39)
        {
          *theInterface = (IOCFPlugInInterface **)value;
          *SInt32 theScore = CFArrayGetValueAtIndex(v20, v37);
          long long v36 = 1;
          goto LABEL_45;
        }
        long long v36 = 0;
      }
      (*(void (**)(void *))(*(void *)v38 + 24))(v38);
LABEL_45:
      if (v35 == ++v37) {
        goto LABEL_49;
      }
    }
  }
  if (FactoriesForPlugInTypeInPlugIn) {
LABEL_18:
  }
    CFRelease(FactoriesForPlugInTypeInPlugIn);
  return v17;
}

uint64_t OSKextGetSystemExtensionsFolderURLs()
{
  return __sOSKextSystemExtensionsFolderURLs;
}

BOOL _IOObjectConformsTo(unsigned int a1, const char *a2, char a3)
{
  BOOL v13 = 0;
  if (io_object_conforms_to(a1, a2))
  {
    BOOL v13 = 0;
    if (a3) {
      return v13;
    }
  }
  else if (a3)
  {
    return v13;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v7 = (const __CFString *)IORegistryEntrySearchCFProperty(a1, 0, @"IOClassNameOverride", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (v7)
  {
    CFStringRef v8 = v7;
    CFTypeID v9 = CFGetTypeID(v7);
    if (v9 == CFStringGetTypeID())
    {
      CFStringRef v10 = CFStringCreateWithCStringNoCopy(v6, a2, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      if (v10)
      {
        CFStringRef v11 = v10;
        BOOL v13 = CFEqual(v8, v10);
        CFRelease(v11);
      }
    }
    CFRelease(v8);
  }
  return v13;
}

uint64_t io_object_conforms_to(unsigned int a1, const char *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v8 = 0u;
  *((void *)&v8 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  }
  else {
    int v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  }
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(void *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&long long v8 = 0xAF100000000;
  uint64_t v4 = mach_msg2_internal();
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if (v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    uint64_t v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  kern_return_t result;
  const char *v7;
  size_t v8;
  __CFDictionary *v9;
  const char *CStringPtr;
  size_t bufferSize;
  CFStringRef errorString;
  mach_vm_address_t address;
  unsigned int size;
  void size_4[257];

  size_4[256] = *MEMORY[0x1E4F143B8];
  size = 0;
  CFStringRef errorString = 0;
  address = 0;
  bufferSize = 2048;
  if (gIOKitLibSerializeOptions)
  {
    uint64_t result = io_registry_entry_get_properties_bin_buf(entry, (uint64_t)size_4, (uint64_t *)&bufferSize);
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t result = io_registry_entry_get_properties(entry);
    if (result) {
      return result;
    }
  }
  CFStringRef v7 = (const char *)address;
  if (address)
  {
    long long v8 = size;
  }
  else
  {
    long long v8 = bufferSize;
    CFStringRef v7 = (const char *)size_4;
  }
  CFTypeID v9 = (__CFDictionary *)IOCFUnserializeWithSize(v7, v8, allocator, 0, &errorString);
  *properties = v9;
  if (!v9 && errorString)
  {
    CStringPtr = CFStringGetCStringPtr(errorString, 0);
    if (CStringPtr) {
      puts(CStringPtr);
    }
    CFRelease(errorString);
  }
  if (address) {
    mach_vm_deallocate(*MEMORY[0x1E4F14960], address, size);
  }
  if (*properties) {
    return 0;
  }
  else {
    return -536870199;
  }
}

uint64_t io_registry_entry_get_properties_bin_buf(unsigned int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v7 = *MEMORY[0x1E4F14068];
  uint64_t v8 = a2;
  uint64_t v9 = *a3;
  uint64_t v10 = 0;
  *(void *)&v6.msgh_bits = 0x3000001513;
  *(void *)&v6.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v6.msgh_voucher_port = 0xB4800000000;
  uint64_t v3 = mach_msg2_internal();
  uint64_t v4 = v3;
  if ((v3 - 268435458) <= 0xE && ((1 << (v3 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v6.msgh_local_port);
  }
  else if (v3)
  {
    mig_dealloc_reply_port(v6.msgh_local_port);
  }
  else
  {
    uint64_t v4 = 4294966995;
    mach_msg_destroy(&v6);
  }
  return v4;
}

CFStringRef IOHIDServiceCopyDescription(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  memset(name, 0, 128);
  IORegistryEntryGetName(*(_DWORD *)(a1 + 16), name);
  if (!name[0]) {
    IOObjectGetClass(*(_DWORD *)(a1 + 16), name);
  }
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t valuePtr = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, &valuePtr);
  return CFStringCreateWithFormat(v2, 0, @"IOHIDService name:%s id:0x%llx primaryUsagePage:0x%x primaryUsage:0x%x transport:%s locationID:%@ reportInterval:%d batchInterval:%d events:%d mask:0x%llx", name, valuePtr, *(unsigned int *)(a1 + 176), *(unsigned int *)(a1 + 180), a1 + 184, *(void *)(a1 + 56), *(unsigned int *)(a1 + 160), *(unsigned int *)(a1 + 164), *(unsigned int *)(a1 + 228), *(void *)(a1 + 232));
}

uint64_t io_registry_entry_get_name(unsigned int a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(v13, 0, sizeof(v13));
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v7 = 0u;
  long long v6 = 0u;
  long long v5 = 0u;
  *(void *)&v4.msgh_bits = 0x1800001513;
  *(void *)&v4.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v4.msgh_voucher_port = 0xAFA00000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) <= 0xE && ((1 << (v1 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v4.msgh_local_port);
  }
  else if (v1)
  {
    mig_dealloc_reply_port(v4.msgh_local_port);
  }
  else
  {
    uint64_t v2 = 4294966995;
    mach_msg_destroy(&v4);
  }
  return v2;
}

uint64_t io_object_get_class(unsigned int a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(v13, 0, sizeof(v13));
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  long long v7 = 0u;
  long long v6 = 0u;
  long long v5 = 0u;
  *(void *)&v4.msgh_bits = 0x1800001513;
  *(void *)&v4.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v4.msgh_voucher_port = 0xAF000000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) <= 0xE && ((1 << (v1 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v4.msgh_local_port);
  }
  else if (v1)
  {
    mig_dealloc_reply_port(v4.msgh_local_port);
  }
  else
  {
    uint64_t v2 = 4294966995;
    mach_msg_destroy(&v4);
  }
  return v2;
}

uint64_t _IOObjectGetClass(io_registry_entry_t entry, char a2, char *a3)
{
  if ((a2 & 1) == 0)
  {
    CFStringRef v5 = (const __CFString *)IORegistryEntrySearchCFProperty(entry, 0, @"IOClassNameOverride", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (v5)
    {
      CFStringRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 == CFStringGetTypeID())
      {
        int CString = CFStringGetCString(v6, a3, 128, 0x8000100u);
        CFRelease(v6);
        if (CString) {
          return 0;
        }
      }
      else
      {
        CFRelease(v6);
      }
    }
  }

  return io_object_get_class(entry);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  size_4[256] = *MEMORY[0x1E4F143B8];
  unsigned int size = 0;
  CFStringRef errorString = 0;
  mach_vm_address_t address = 0;
  size_t bufferSize = 2048;
  CStringPtr = CFStringGetCStringPtr(key, 0);
  if (CStringPtr)
  {
    long long v11 = CStringPtr;
    long long v12 = 0;
  }
  else
  {
    CFIndex Length = CFStringGetLength(key);
    CFIndex v16 = CFStringGetMaximumSizeForEncoding(Length, 0) + 4;
    long long v17 = (char *)malloc_type_malloc(v16, 0x1CEEAEE5uLL);
    if (!v17) {
      return 0;
    }
    long long v12 = v17;
    if (!CFStringGetCString(key, v17, v16, 0))
    {
      int v18 = -536870212;
LABEL_15:
      free(v12);
      goto LABEL_16;
    }
    long long v11 = v12;
  }
  if (gIOKitLibSerializeOptions)
  {
    if (options) {
      uint64_t v14 = plane;
    }
    else {
      uint64_t v14 = (const char *)&unk_18B50BD40;
    }
    int property_bin_buf = io_registry_entry_get_property_bin_buf(entry, v14, v11, options, (uint64_t)size_4, &bufferSize, &address, &size);
  }
  else if (options)
  {
    int property_bin_buf = io_registry_entry_get_property_recursively(entry, plane, v11, options, &address, &size);
  }
  else
  {
    int property_bin_buf = io_registry_entry_get_property(entry, v11);
  }
  int v18 = property_bin_buf;
  if (v12) {
    goto LABEL_15;
  }
LABEL_16:
  if (v18) {
    return 0;
  }
  long long v20 = (const char *)address;
  if (address)
  {
    size_t v21 = size;
  }
  else
  {
    size_t v21 = bufferSize;
    long long v20 = (const char *)size_4;
  }
  CFTypeRef v19 = IOCFUnserializeWithSize(v20, v21, allocator, 0, &errorString);
  if (!v19 && errorString)
  {
    long long v22 = CFStringGetCStringPtr(errorString, 0);
    if (v22) {
      puts(v22);
    }
    CFRelease(errorString);
  }
  if (address) {
    mach_vm_deallocate(*MEMORY[0x1E4F14960], address, size);
  }
  return v19;
}

uint64_t io_registry_entry_get_property_bin_buf(unsigned int a1, const char *a2, const char *a3, int a4, uint64_t a5, void *a6, void *a7, _DWORD *a8)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v50 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  memset(v32, 0, sizeof(v32));
  *((void *)&v32[0] + 1) = *MEMORY[0x1E4F14068];
  uint64_t v15 = MEMORY[0x1E4F149B0];
  if (MEMORY[0x1E4F149B0]) {
    int v16 = mig_strncpy_zerofill((char *)&v32[1] + 8, a2, 128);
  }
  else {
    int v16 = mig_strncpy((char *)&v32[1] + 8, a2, 128);
  }
  LODWORD(v32[1]) = 0;
  DWORD1(v32[1]) = v16;
  uint64_t v17 = (v16 + 3) & 0xFFFFFFFC;
  int v18 = v17 + 68;
  CFTypeRef v19 = (char *)reply_port + v17;
  long long v20 = v19 - 128;
  size_t v21 = v19 + 48;
  if (v15) {
    int v22 = mig_strncpy_zerofill(v21, a3, 128);
  }
  else {
    int v22 = mig_strncpy(v21, a3, 128);
  }
  *((_DWORD *)v20 + 42) = 0;
  *((_DWORD *)v20 + 43) = v22;
  uint64_t v23 = (v22 + 3) & 0xFFFFFFFC;
  mach_port_t v24 = v18 + v23;
  long long v25 = &v20[v23];
  *((_DWORD *)v25 + 44) = a4;
  *(void *)(v25 + 180) = a5;
  *(void *)(v25 + 188) = *a6;
  mach_port_t v26 = mig_get_reply_port();
  reply_port[0] = 5395;
  reply_port[1] = v24;
  *(void *)&reply_port[2] = __PAIR64__(v26, a1);
  *(void *)&v32[0] = 0xB4900000000;
  uint64_t v27 = mach_msg2_internal();
  uint64_t v28 = v27;
  if ((v27 - 268435458) <= 0xE && ((1 << (v27 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else
  {
    if (!v27)
    {
      if (DWORD1(v32[0]) == 71)
      {
        uint64_t v28 = 4294966988;
      }
      else if (DWORD1(v32[0]) == 2989)
      {
        if ((reply_port[0] & 0x80000000) != 0)
        {
          uint64_t v28 = 4294966996;
          if (DWORD2(v32[0]) == 1 && reply_port[1] == 64 && !reply_port[2] && BYTE7(v32[1]) == 1)
          {
            int v29 = DWORD2(v32[1]);
            if (DWORD2(v32[1]) == HIDWORD(v33))
            {
              uint64_t v28 = 0;
              *a6 = *(void *)((char *)&v33 + 4);
              *a7 = *(void *)((char *)v32 + 12);
              *a8 = v29;
              return v28;
            }
          }
        }
        else if (reply_port[1] == 36)
        {
          uint64_t v28 = 4294966996;
          if (LODWORD(v32[1]))
          {
            if (reply_port[2]) {
              uint64_t v28 = 4294966996;
            }
            else {
              uint64_t v28 = LODWORD(v32[1]);
            }
          }
        }
        else
        {
          uint64_t v28 = 4294966996;
        }
      }
      else
      {
        uint64_t v28 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v28;
    }
    mig_dealloc_reply_port(reply_port[3]);
  }
  return v28;
}

CFTypeRef IOCFUnserializeBinary(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  size_t v5 = bufferSize;
  if (errorString) {
    *CFStringRef errorString = 0;
  }
  CFMutableDictionaryRef v7 = 0;
  if (bufferSize < 4 || (buffer & 3) != 0) {
    return v7;
  }
  if (*(unsigned __int8 *)buffer == 212)
  {
    size_t v54 = bufferSize >> 2;
    long long v8 = malloc_type_calloc(bufferSize >> 2, 8uLL, 0xC0040B8AA526DuLL);
  }
  else
  {
    if (strcmp(byte_18B50B938, buffer)) {
      return 0;
    }
    size_t v54 = 0;
    long long v8 = 0;
  }
  CFStringRef v74 = 0;
  CFMutableDictionaryRef v7 = 0;
  long long v9 = 0;
  long long v10 = 0;
  CFStringRef v11 = 0;
  CFStringRef v55 = 0;
  int v61 = 0;
  uint64_t v58 = 0;
  long long v59 = 0;
  unsigned int v75 = 0;
  uint64_t v72 = 0;
  __src = 0;
  long long v62 = buffer;
  long long v76 = buffer + 4;
  CFStringRef v57 = (const __CFString *)*MEMORY[0x1E4F1CFD0];
  CFStringRef v56 = (const __CFString *)*MEMORY[0x1E4F1CFC8];
  BOOL v60 = v8 != 0;
  uint64_t v12 = 4;
  long long v63 = v8;
  unint64_t v68 = v5;
LABEL_11:
  uint64_t v13 = v7;
  long long v70 = v10;
  long long v71 = v9;
  while (2)
  {
    CFStringRef v69 = v11;
    size_t v14 = v12 + 4;
    if (v12 + 4 > v5) {
      goto LABEL_102;
    }
    CFMutableDictionaryRef v7 = 0;
    uint64_t v15 = (double *)(v76 + 4);
    int v16 = *(_DWORD *)v76;
    int v17 = *(_DWORD *)v76 & 0x7F000000;
    CFIndex v18 = *(_DWORD *)v76 & 0xFFFFFFLL;
    uint64_t v19 = (v18 + 3) >> 2;
    long long v20 = v13;
    switch((v17 - 0x1000000) >> 24)
    {
      case 0u:
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, v18, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        long long v65 = 0;
        CFMutableDictionaryRef v7 = 0;
        BOOL v73 = v18 != 0;
        long long v66 = Mutable;
        goto LABEL_17;
      case 1u:
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(allocator, v18, MEMORY[0x1E4F1D510]);
        long long v66 = 0;
        CFMutableDictionaryRef v7 = 0;
        BOOL v73 = v18 != 0;
        long long v65 = Mutable;
        goto LABEL_17;
      case 2u:
        CFMutableDictionaryRef Mutable = CFSetCreateMutable(allocator, v18, MEMORY[0x1E4F1D548]);
        CFMutableDictionaryRef v7 = Mutable;
        long long v65 = 0;
        long long v66 = 0;
        BOOL v73 = v18 != 0;
LABEL_17:
        CFStringRef v11 = (const __CFString *)Mutable;
        BOOL v22 = v60;
        goto LABEL_36;
      case 3u:
        size_t v14 = v12 + 12;
        if (v12 + 12 > v5) {
          goto LABEL_102;
        }
        if (v18 == 63)
        {
          CFStringRef v11 = (const __CFString *)CFNumberCreate(allocator, kCFNumberFloat64Type, v15);
          uint64_t v23 = v72;
        }
        else
        {
          uint64_t v23 = v72;
          if (v18 == 31)
          {
            float v24 = *v15;
            float v77 = v24;
            long long v25 = &v77;
            CFAllocatorRef v26 = allocator;
            CFNumberType v27 = kCFNumberFloat32Type;
          }
          else
          {
            CFAllocatorRef v26 = allocator;
            CFNumberType v27 = v18 > 0x20 ? kCFNumberSInt64Type : kCFNumberSInt32Type;
            long long v25 = (float *)(v76 + 4);
          }
          CFStringRef v11 = (const __CFString *)CFNumberCreate(v26, v27, v25);
        }
        long long v65 = 0;
        long long v66 = 0;
        CFMutableDictionaryRef v7 = 0;
        BOOL v73 = 0;
        BOOL v22 = 0;
        uint64_t v15 = (double *)(v76 + 12);
        unsigned int v30 = v75;
        if (!v11) {
          goto LABEL_102;
        }
        goto LABEL_37;
      case 7u:
        if (!v18) {
          goto LABEL_102;
        }
        LODWORD(v18) = v18 - 1;
        goto LABEL_24;
      case 8u:
LABEL_24:
        v14 += 4 * v19;
        if (v14 > v5) {
          goto LABEL_102;
        }
        CFIndex v28 = v18;
        if (v17 == 0x8000000 && *((unsigned char *)v15 + v18)) {
          goto LABEL_114;
        }
        CFStringRef v11 = CFStringCreateWithBytes(allocator, (const UInt8 *)v15, v18, 0x8000100u, 0);
        if (!v11)
        {
          CFStringRef v11 = CFStringCreateWithBytes(allocator, (const UInt8 *)v15, v28, 0, 0);
          CStringPtr = CFStringGetCStringPtr(v11, 0);
          syslog(3, "FIXME: IOUnserialize has detected a string that is not valid UTF-8, \"%s\".", CStringPtr);
        }
        long long v65 = 0;
        long long v66 = 0;
        CFMutableDictionaryRef v7 = 0;
        BOOL v73 = 0;
        BOOL v22 = 0;
        uint64_t v15 = (double *)((char *)v15 + 4 * v19);
        long long v8 = v63;
LABEL_36:
        unsigned int v30 = v75;
        uint64_t v23 = v72;
        if (!v11) {
          goto LABEL_102;
        }
LABEL_37:
        if (v30 < v23)
        {
          long long v31 = __src;
          uint64_t v32 = v23;
LABEL_46:
          char v34 = 0;
          *(void *)&v31[8 * v30] = v11;
          BOOL v33 = 1;
          uint64_t v72 = v32;
          __src = v31;
          long long v8 = v63;
          if (!v63) {
            goto LABEL_48;
          }
LABEL_47:
          v8[(v76 - v62) >> 2] = v11;
          goto LABEL_48;
        }
        if (BYTE3(v23))
        {
          BOOL v33 = 0;
          char v34 = 1;
          if (!v8) {
            goto LABEL_48;
          }
          goto LABEL_47;
        }
        uint64_t v32 = (v23 + 64);
        long long v35 = (char *)malloc_type_malloc(8 * v32, 0xC0040B8AA526DuLL);
        if (v35)
        {
          long long v31 = v35;
          if (__src)
          {
            memmove(v35, __src, 8 * v72);
            free(__src);
          }
          unsigned int v30 = v75;
          goto LABEL_46;
        }
        BOOL v33 = 0;
        char v34 = 1;
        long long v8 = v63;
        unsigned int v30 = v75;
        if (v63) {
          goto LABEL_47;
        }
LABEL_48:
        if (v34) {
          goto LABEL_101;
        }
        unsigned int v36 = v30 + 1;
        if (v22)
        {
          uint64_t v12 = v14 + 4;
          if (v14 + 4 > v68)
          {
            unsigned int v75 = v36;
LABEL_101:
            CFRelease(v11);
LABEL_102:
            CFMutableDictionaryRef v7 = 0;
            goto LABEL_103;
          }
          long long v76 = (char *)v15 + 4;
          BOOL v33 = 1;
        }
        else
        {
LABEL_61:
          uint64_t v12 = v14;
          long long v76 = (const char *)v15;
        }
        CFStringRef v38 = v74;
        unsigned int v75 = v36;
        if (v70)
        {
          if (!v74)
          {
            CFTypeID TypeID = CFStringGetTypeID();
            BOOL v33 = TypeID == CFGetTypeID(v11);
            CFStringRef v38 = v11;
LABEL_67:
            size_t v5 = v68;
            goto LABEL_75;
          }
          size_t v5 = v68;
          if (v11 != (const __CFString *)v70) {
            CFDictionarySetValue(v70, v74, v11);
          }
          CFStringRef v38 = 0;
        }
        else
        {
          if (v71)
          {
            CFArrayAppendValue(v71, v11);
            goto LABEL_67;
          }
          size_t v5 = v68;
          if (v20)
          {
            CFSetAddValue(v20, v11);
          }
          else
          {
            if (v55) {
              goto LABEL_102;
            }
            CFStringRef v55 = v11;
            if (v69) {
              IOCFUnserializeBinary_cold_1();
            }
          }
        }
LABEL_75:
        if (!v33) {
          goto LABEL_102;
        }
        CFStringRef v74 = v38;
        if (!v73)
        {
          CFStringRef v11 = v69;
          uint64_t v13 = v20;
          if (v16 < 0)
          {
            int v40 = v61;
            if (!v61)
            {
              CFMutableDictionaryRef v7 = (CFMutableDictionaryRef)v55;
              goto LABEL_103;
            }
            CFStringRef v11 = (const __CFString *)v59[v61--];
            CFTypeID v41 = CFGetTypeID((CFTypeRef)v59[v40]);
            CFTypeID v42 = CFDictionaryGetTypeID();
            uint64_t v13 = 0;
            long long v70 = (__CFDictionary *)v11;
            long long v71 = 0;
            if (v41 != v42)
            {
              CFTypeID v43 = CFArrayGetTypeID();
              uint64_t v13 = 0;
              long long v70 = 0;
              long long v71 = (__CFArray *)v11;
              if (v41 != v43)
              {
                CFTypeID v44 = CFSetGetTypeID();
                long long v70 = 0;
                long long v71 = 0;
                CFMutableDictionaryRef v7 = 0;
                uint64_t v13 = (__CFSet *)v11;
                if (v41 != v44) {
                  goto LABEL_103;
                }
              }
            }
          }
          continue;
        }
        uint64_t v13 = v7;
        long long v9 = v65;
        long long v10 = v66;
        long long v70 = v66;
        long long v71 = v65;
        if (v16 < 0) {
          continue;
        }
        int v45 = v61 + 1;
        if (v61 + 1 < v58)
        {
          long long v46 = v59;
          uint64_t v47 = v58;
          goto LABEL_99;
        }
        if (WORD1(v58)) {
          goto LABEL_102;
        }
        uint64_t v47 = (v58 + 64);
        long long v48 = malloc_type_malloc(8 * v47, 0xC0040B8AA526DuLL);
        if (v48)
        {
          long long v46 = v48;
          if (v59)
          {
            memmove(v48, v59, 8 * v58);
            free(v59);
          }
LABEL_99:
          ++v61;
          v46[v45] = v69;
          uint64_t v58 = v47;
          long long v59 = v46;
          long long v8 = v63;
          goto LABEL_11;
        }
LABEL_114:
        CFMutableDictionaryRef v7 = 0;
        long long v8 = v63;
LABEL_103:
        if (v72)
        {
          unsigned int v49 = v7 != 0;
          int v50 = v75 - v49;
          if (v75 > v49)
          {
            uint64_t v51 = (const void **)&__src[8 * (v7 != 0)];
            do
            {
              long long v52 = *v51++;
              CFRelease(v52);
              --v50;
            }
            while (v50);
          }
          free(__src);
        }
        if (v58) {
          free(v59);
        }
        if (v8) {
          free(v8);
        }
        return v7;
      case 9u:
        v14 += 4 * v19;
        if (v14 > v5) {
          goto LABEL_102;
        }
        CFStringRef v11 = (const __CFString *)CFDataCreate(allocator, (const UInt8 *)v15, v18);
        long long v65 = 0;
        long long v66 = 0;
        CFMutableDictionaryRef v7 = 0;
        BOOL v73 = 0;
        BOOL v22 = 0;
        uint64_t v15 = (double *)((char *)v15 + 4 * v19);
        goto LABEL_36;
      case 0xAu:
        if (v18) {
          CFStringRef v11 = v57;
        }
        else {
          CFStringRef v11 = v56;
        }
        CFRetain(v11);
        long long v65 = 0;
        long long v66 = 0;
        CFMutableDictionaryRef v7 = 0;
        BOOL v73 = 0;
        BOOL v22 = 0;
        goto LABEL_36;
      case 0xBu:
        if (v8)
        {
          unsigned int v36 = v75;
          if (v54 <= v18) {
            goto LABEL_102;
          }
          long long v37 = (const __CFString **)&v8[v18];
        }
        else
        {
          unsigned int v36 = v75;
          if (v18 >= v75) {
            goto LABEL_102;
          }
          long long v37 = (const __CFString **)&__src[8 * v18];
        }
        CFMutableDictionaryRef v7 = 0;
        CFStringRef v11 = *v37;
        if (!*v37) {
          goto LABEL_103;
        }
        BOOL v73 = 0;
        BOOL v33 = 1;
        long long v65 = 0;
        long long v66 = 0;
        goto LABEL_61;
      default:
        goto LABEL_103;
    }
  }
}

CFTypeRef IOCFUnserializeWithSize(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  if (errorString) {
    *CFStringRef errorString = 0;
  }
  if (!buffer || bufferSize < 4) {
    return 0;
  }
  if ((options & 1) != 0 || !strcmp(byte_18B50B938, buffer) || *(unsigned __int8 *)buffer == 212)
  {
    return IOCFUnserializeBinary(buffer, bufferSize, allocator, options, errorString);
  }
  else
  {
    return IOCFUnserialize(buffer, allocator, options, errorString);
  }
}

kern_return_t IOObjectGetClass(io_object_t object, io_name_t className)
{
  return _IOObjectGetClass(object, 0, className);
}

void __IOHIDEventQueueRelease(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  mach_vm_address_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    if (*(_DWORD *)(a1 + 144) == 1)
    {
      uint64_t v3 = (ipc_space_t *)MEMORY[0x1E4F14960];
      mach_vm_deallocate(*MEMORY[0x1E4F14960], v2, *(void *)(a1 + 24));
      mach_port_name_t v4 = *(_DWORD *)(a1 + 84);
      if (v4) {
        mach_port_deallocate(*v3, v4);
      }
    }
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
  }
  os_unfair_recursive_lock_unlock();
  if (*(void *)(a1 + 160))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 160));
    *(void *)(a1 + 160) = 0;
  }
}

uint64_t _IOHIDServiceReleasePrivate(uint64_t a1)
{
  mach_vm_address_t v2 = *(const void **)(a1 + 336);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 336) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    *(void *)(a1 + 32) = 0;
  }
  CFStringRef v6 = *(IOCFPlugInInterface ***)(a1 + 40);
  if (v6)
  {
    IODestroyPlugInInterface(v6);
    *(void *)(a1 + 40) = 0;
  }
  CFMutableDictionaryRef v7 = *(const void **)(a1 + 480);
  if (v7) {
    CFRelease(v7);
  }
  long long v8 = *(const void **)(a1 + 8);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 8) = 0;
  }
  long long v9 = *(const void **)(a1 + 104);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 104) = 0;
  }
  long long v10 = *(const void **)(a1 + 112);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 112) = 0;
  }
  CFStringRef v11 = *(const void **)(a1 + 120);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 120) = 0;
  }
  io_object_t v12 = *(_DWORD *)(a1 + 96);
  if (v12)
  {
    IOObjectRelease(v12);
    *(_DWORD *)(a1 + 96) = 0;
  }
  uint64_t v13 = *(IONotificationPort **)(a1 + 88);
  if (v13)
  {
    IONotificationPortDestroy(v13);
    *(void *)(a1 + 88) = 0;
  }
  size_t v14 = *(const void **)(a1 + 240);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 240) = 0;
  }
  uint64_t v15 = *(const void **)(a1 + 248);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 248) = 0;
  }
  int v16 = *(const void **)(a1 + 256);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 256) = 0;
  }
  int v17 = *(const void **)(a1 + 312);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 312) = 0;
  }
  CFIndex v18 = *(const void **)(a1 + 264);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 264) = 0;
  }
  uint64_t v19 = *(const void **)(a1 + 408);
  if (v19) {
    CFRelease(v19);
  }
  for (uint64_t i = 0; i != 24; i += 8)
  {
    uint64_t v21 = *(void *)(a1 + 368);
    if (v21)
    {
      BOOL v22 = *(const void **)(v21 + i);
      if (v22)
      {
        CFRelease(v22);
        *(void *)(*(void *)(a1 + 368) + i) = 0;
      }
    }
  }
  uint64_t v23 = *(void **)(a1 + 368);
  if (v23) {
    free(v23);
  }
  float v24 = *(void **)(a1 + 416);
  if (v24) {
    free(v24);
  }
  long long v25 = *(NSObject **)(a1 + 80);
  if (v25)
  {
    hid_dispatch_queue_release(v25);
    *(void *)(a1 + 80) = 0;
  }
  CFAllocatorRef v26 = *(void **)(a1 + 360);
  if (v26) {
    free(v26);
  }
  CFNumberType v27 = *(const void **)(a1 + 424);
  if (v27) {
    _Block_release(v27);
  }
  CFIndex v28 = *(const void **)(a1 + 432);
  if (v28) {
    _Block_release(v28);
  }
  int v29 = *(NSObject **)(a1 + 448);
  if (v29) {
    dispatch_release(v29);
  }
  if (*(void *)(a1 + 464))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 464));
  }
  if (*(void *)(a1 + 472))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 472));
  }
  unsigned int v30 = *(const void **)(a1 + 56);
  if (v30) {
    CFRelease(v30);
  }
  long long v31 = *(const void **)(a1 + 64);
  if (v31) {
    CFRelease(v31);
  }
  uint64_t result = *(unsigned int *)(a1 + 16);
  if (result)
  {
    return IOObjectRelease(result);
  }
  return result;
}

void IONotificationPortRelease(uint64_t a1)
{
  if ((int)atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 32), 0xFFFFFFFF, memory_order_relaxed) <= 0)
  {
    mach_vm_address_t v2 = (ipc_space_t *)MEMORY[0x1E4F14960];
    mach_port_mod_refs(*MEMORY[0x1E4F14960], *(_DWORD *)(a1 + 4), 1u, -1);
    mach_port_deallocate(*v2, *(_DWORD *)a1);
    free((void *)a1);
  }
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  mach_vm_address_t v2 = (__CFMachPort *)*((void *)notify + 1);
  if (v2)
  {
    CFMachPortInvalidate(v2);
    CFRelease(*((CFTypeRef *)notify + 1));
  }
  uint64_t v3 = (const void *)*((void *)notify + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *((void *)notify + 3);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*((dispatch_object_t *)notify + 3));
  }

  IONotificationPortRelease((uint64_t)notify);
}

uint64_t IOHIDAnalyticsEventCancel()
{
  if (cancelEventFuncPtr) {
    return cancelEventFuncPtr();
  }
  return result;
}

void _IOHIDEventSystemConnectionReleasePrivate(uint64_t a1)
{
  kern_return_t v11;
  mach_error_t v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  kern_return_t v20;
  mach_error_t v21;
  NSObject *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  mach_port_name_t v29;
  kern_return_t v30;
  mach_error_t v31;
  NSObject *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  kern_return_t v39;
  mach_error_t v40;
  NSObject *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  mach_port_name_t v48;
  kern_return_t v49;
  mach_error_t v50;
  NSObject *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  mach_port_name_t v63;
  const void *v64;
  const void *v65;
  const void *v66;
  const void *v67;
  void *v68;
  void *v69;
  void *v70;
  const void *v71;
  mach_port_t previous;

  previous = 0;
  mach_vm_address_t v2 = *(const void **)(a1 + 272);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(NSObject **)(a1 + 96);
  if (v4)
  {
    dispatch_release(v4);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 80);
  if (v5) {
    CFRelease(v5);
  }
  CFStringRef v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
  CFMutableDictionaryRef v7 = *(NSObject **)(a1 + 416);
  if (v7) {
    dispatch_release(v7);
  }
  uint64_t v8 = *(void *)(a1 + 24);
  long long v9 = (ipc_space_t *)MEMORY[0x1E4F14960];
  if (v8)
  {
    Notificationmach_port_name_t Port = IOHIDEventQueueGetNotificationPort(v8);
    CFStringRef v11 = mach_port_request_notification(*v9, NotificationPort, 66, 1u, 0, 0x15u, &previous);
    if (v11
      && (v12 = v11, uint64_t v13 = _IOHIDLogCategory(9u),
                     size_t v14 = (int)v13,
                     os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)))
    {
      _IOHIDEventSystemConnectionReleasePrivate_cold_5(a1, v12, v14, v15, v16, v17, v18, v19);
      if (NotificationPort) {
        goto LABEL_17;
      }
    }
    else if (NotificationPort)
    {
LABEL_17:
      long long v20 = mach_port_deallocate(*v9, NotificationPort);
      if (v20)
      {
        uint64_t v21 = v20;
        BOOL v22 = _IOHIDLogCategory(9u);
        uint64_t v23 = (int)v22;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          _IOHIDEventSystemConnectionReleasePrivate_cold_4(a1, v21, v23, v24, v25, v26, v27, v28);
        }
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 24));
  }
  int v29 = *(_DWORD *)(a1 + 104);
  if (v29)
  {
    unsigned int v30 = mach_port_mod_refs(*v9, v29, 1u, -1);
    *(_DWORD *)(a1 + 104) = 0;
    if (v30)
    {
      long long v31 = v30;
      uint64_t v32 = _IOHIDLogCategory(9u);
      BOOL v33 = (int)v32;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        _IOHIDEventSystemConnectionReleasePrivate_cold_3(a1, v31, v33, v34, v35, v36, v37, v38);
      }
    }
  }
  if (previous)
  {
    long long v39 = mach_port_deallocate(*v9, previous);
    if (v39)
    {
      int v40 = v39;
      CFTypeID v41 = _IOHIDLogCategory(9u);
      CFTypeID v42 = (int)v41;
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        _IOHIDEventSystemConnectionReleasePrivate_cold_2(a1, v40, v42, v43, v44, v45, v46, v47);
      }
    }
  }
  long long v48 = *(_DWORD *)(a1 + 40);
  if (v48)
  {
    unsigned int v49 = mach_port_deallocate(*v9, v48);
    *(_DWORD *)(a1 + 40) = 0;
    if (v49)
    {
      int v50 = v49;
      uint64_t v51 = _IOHIDLogCategory(9u);
      long long v52 = (int)v51;
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
        _IOHIDEventSystemConnectionReleasePrivate_cold_1(a1, v50, v52, v53, v54, v55, v56, v57);
      }
    }
  }
  uint64_t v58 = *(const void **)(a1 + 136);
  if (v58) {
    CFRelease(v58);
  }
  long long v59 = *(const void **)(a1 + 184);
  if (v59) {
    CFRelease(v59);
  }
  BOOL v60 = *(const void **)(a1 + 144);
  if (v60) {
    CFRelease(v60);
  }
  int v61 = *(const void **)(a1 + 152);
  if (v61) {
    CFRelease(v61);
  }
  long long v62 = *(const void **)(a1 + 160);
  if (v62) {
    CFRelease(v62);
  }
  long long v63 = *(_DWORD *)(a1 + 192);
  if (v63) {
    mach_port_deallocate(*v9, v63);
  }
  long long v64 = *(const void **)(a1 + 384);
  if (v64) {
    CFRelease(v64);
  }
  long long v65 = *(const void **)(a1 + 424);
  if (v65) {
    CFRelease(v65);
  }
  long long v66 = *(const void **)(a1 + 432);
  if (v66) {
    CFRelease(v66);
  }
  long long v67 = *(const void **)(a1 + 440);
  if (v67) {
    CFRelease(v67);
  }
  unint64_t v68 = *(void **)(a1 + 392);
  if (v68) {
    free(v68);
  }
  CFStringRef v69 = *(void **)(a1 + 240);
  if (v69) {
    free(v69);
  }
  long long v70 = *(void **)(a1 + 248);
  if (v70) {
    xpc_release(v70);
  }
  long long v71 = *(const void **)(a1 + 8);
  if (v71) {
    CFRelease(v71);
  }
}

CFMutableDictionaryRef IOBSDNameMatching(mach_port_t mainPort, uint32_t options, const char *bsdName)
{
  if (bsdName) {
    return MakeOneStringProp(@"BSD Name", bsdName);
  }
  else {
    return 0;
  }
}

CFDictionaryRef _IOHIDServiceClientRefresh(CFDictionaryRef *a1)
{
  CFDictionaryRef result = (const __CFDictionary *)os_unfair_recursive_lock_lock_with_options();
  if (a1)
  {
    CFDictionaryRef result = a1[12];
    if (result)
    {
      CFNumberRef Value = CFDictionaryGetValue(result, @"ReportInterval");
      if (Value)
      {
        uint64_t v4 = Value;
        os_unfair_recursive_lock_unlock();
        IOHIDServiceClientSetProperty((IOHIDServiceClientRef)a1, @"ReportInterval", v4);
        os_unfair_recursive_lock_lock_with_options();
      }
      uint64_t v5 = CFDictionaryGetValue(a1[12], @"BatchInterval");
      CFDictionaryRef result = (const __CFDictionary *)os_unfair_recursive_lock_unlock();
      if (v5)
      {
        return (const __CFDictionary *)IOHIDServiceClientSetProperty((IOHIDServiceClientRef)a1, @"BatchInterval", v5);
      }
    }
  }
  return result;
}

Boolean IOHIDServiceClientSetProperty(IOHIDServiceClientRef service, CFStringRef key, CFTypeRef property)
{
  if (CFEqual(key, @"ReportInterval") || CFEqual(key, @"BatchInterval"))
  {
    os_unfair_recursive_lock_lock_with_options();
    CFStringRef v6 = (__CFDictionary *)*((void *)service + 12);
    if (!v6) {
      return v6;
    }
    CFDictionarySetValue(v6, key, property);
    os_unfair_recursive_lock_unlock();
  }
  uint64_t v7 = *((void *)service + 1);

  LOBYTE(v6) = _IOHIDEventSystemClientSetPropertyForService(v7, service, (void *)key, (void *)property);
  return v6;
}

uint64_t _IOHIDEventSystemClientSetPropertyForService(uint64_t a1, IOHIDServiceClientRef service, void *a3, void *a4)
{
  uint64_t v4 = 0;
  values = a4;
  keys = a3;
  if (a1 && service && a3 && a4)
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFTypeRef RegistryID = IOHIDServiceClientGetRegistryID(service);
    CFTypeRef v8 = _IOHIDCreateBinaryData(v6, RegistryID);
    if (v8)
    {
      long long v9 = v8;
      uint64_t v4 = 1;
      CFDictionaryRef v10 = CFDictionaryCreate(v6, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!v10)
      {
LABEL_25:
        CFRelease(v9);
        return v4;
      }
      CFDictionaryRef v11 = v10;
      CFDataRef v12 = (const __CFData *)_IOHIDCreateBinaryData(v6, v10);
      if (!v12)
      {
        uint64_t v4 = 1;
LABEL_24:
        CFRelease(v11);
        goto LABEL_25;
      }
      CFDataRef v13 = v12;
      int v28 = 0;
      if (CFSetContainsValue((CFSetRef)__restrictedRemapKeys, keys)
        && _IOHIDIsRestrictedRemappingProperty((const __CFString *)values)
        && IOHIDCheckAccess(kIOHIDRequestTypeListenEvent))
      {
        IOHIDRequestAccess(kIOHIDRequestTypeListenEvent);
      }
      os_unfair_recursive_lock_lock_with_options();
      mach_port_t v14 = *(_DWORD *)(a1 + 32);
      BytePtr = CFDataGetBytePtr((CFDataRef)v9);
      int Length = CFDataGetLength((CFDataRef)v9);
      int v17 = CFDataGetBytePtr(v13);
      int v18 = CFDataGetLength(v13);
      uint64_t v19 = io_hideventsystem_set_properties_for_service(v14, (uint64_t)BytePtr, Length, (uint64_t)v17, v18, &v28);
      int v20 = v19;
      if (v19 == 268435459)
      {
        if (*(void *)(a1 + 384) || *(void *)(a1 + 400))
        {
          os_unfair_recursive_lock_unlock();
          BOOL v21 = 0;
LABEL_20:
          if (v28) {
            uint64_t v4 = 0;
          }
          else {
            uint64_t v4 = v21;
          }
          CFRelease(v13);
          goto LABEL_24;
        }
        __IOHIDEventSystemClientTerminationCallback(v19, a1, 0);
        mach_port_t v22 = *(_DWORD *)(a1 + 32);
        uint64_t v23 = CFDataGetBytePtr((CFDataRef)v9);
        int v24 = CFDataGetLength((CFDataRef)v9);
        long long v25 = CFDataGetBytePtr(v13);
        int v26 = CFDataGetLength(v13);
        int v20 = io_hideventsystem_set_properties_for_service(v22, (uint64_t)v23, v24, (uint64_t)v25, v26, &v28);
      }
      os_unfair_recursive_lock_unlock();
      BOOL v21 = v20 == 0;
      goto LABEL_20;
    }
    return 1;
  }
  return v4;
}

uint64_t io_hideventsystem_set_properties_for_service(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int *a6)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v14 = 2;
  uint64_t v15 = a2;
  int v16 = 16777472;
  int v17 = a3;
  uint64_t v18 = a4;
  int v19 = 16777472;
  int v20 = a5;
  uint64_t v21 = *MEMORY[0x1E4F14068];
  int v22 = a3;
  int v23 = a5;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x1117A00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v9 = mach_msg(&msg, 3162115, 0x4Cu, 0x30u, special_reply_port, 0, 0);
  uint64_t v10 = v9;
  if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
  {
    if (!v9)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v10 = 4294966988;
      }
      else if (msg.msgh_id == 70110)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              uint64_t v10 = HIDWORD(v15);
              if (!HIDWORD(v15))
              {
                *a6 = v16;
                return v10;
              }
              goto LABEL_25;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port) {
              BOOL v11 = 1;
            }
            else {
              BOOL v11 = HIDWORD(v15) == 0;
            }
            if (v11) {
              uint64_t v10 = 4294966996;
            }
            else {
              uint64_t v10 = HIDWORD(v15);
            }
            goto LABEL_25;
          }
        }
        uint64_t v10 = 4294966996;
      }
      else
      {
        uint64_t v10 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&msg);
      return v10;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v10 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    goto LABEL_25;
  }
  return v10;
}

uint64_t IOHIDServiceFilterSetEventCallback(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    mach_vm_address_t v2 = *(uint64_t (**)(void))(*(void *)result + 112);
    if (v2) {
      return v2();
    }
  }
  return result;
}

__CFDictionary *__FilterFunctionGetPropertyForClient(__CFDictionary *result, uint64_t a2)
{
  if (!*(void *)(a2 + 16))
  {
    uint64_t result = IOHIDSessionFilterGetPropertyForClient((uint64_t)result, *(CFTypeRef *)(a2 + 8));
    *(void *)(a2 + 16) = result;
  }
  return result;
}

__CFDictionary *IOHIDSessionFilterGetPropertyForClient(uint64_t a1, CFTypeRef cf1)
{
  if (CFEqual(cf1, @"HIDObjectUUID")) {
    return *(__CFDictionary **)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5 && (CFAllocatorRef v6 = *(uint64_t (**)(void))(*(void *)v5 + 120)) != 0)
  {
    uint64_t v7 = (__CFString *)v6();
  }
  else
  {
    CFTypeRef v8 = *(void **)(a1 + 56);
    if (v8)
    {
      uint64_t v7 = (__CFString *)objc_msgSend(v8, *(SEL *)(a1 + 64), cf1);
      if (CFEqual(cf1, @"SessionFilterDebug") && v7) {
        CFRetain(v7);
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
  }
  if (!CFEqual(cf1, @"SessionFilterDebug")) {
    return (__CFDictionary *)v7;
  }
  CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return (__CFDictionary *)v7;
  }
  uint64_t v4 = Mutable;
  if (v7)
  {
    if (_IOHIDIsSerializable((uint64_t)v7))
    {
      BOOL v11 = v4;
      CFDataRef v12 = v7;
    }
    else
    {
      CFDataRef v13 = _IOHIDLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        IOHIDSessionFilterGetPropertyForClient_cold_1(a1, v13);
      }
      CFDataRef v12 = @"not serializable";
      BOOL v11 = v4;
    }
    CFDictionaryAddValue(v11, @"plugin", v12);
    CFRelease(v7);
  }
  CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
  CFStringRef v15 = CFUUIDCreateString(v14, *(CFUUIDRef *)(a1 + 32));
  if (v15)
  {
    CFStringRef v16 = v15;
    CFDictionaryAddValue(v4, @"uuid", v15);
    CFRelease(v16);
  }
  int v17 = *(const void **)(a1 + 40);
  if (v17) {
    CFDictionaryAddValue(v4, @"name", v17);
  }
  return v4;
}

CFDictionaryRef __ConnectionFunctionContainsReportInterval(uint64_t a1, void *a2, _DWORD *a3)
{
  CFDictionaryRef result = IOHIDServiceConnectionCacheContainsKey(a2, @"ReportInterval");
  *a3 |= result;
  return result;
}

void __IOHIDEventSystemClientServiceReplaceCallback(void *key, const void *a2, CFDictionaryRef theDict)
{
  if (CFDictionaryContainsKey(theDict, key))
  {
    CFDictionarySetValue(theDict, key, a2);
  }
}

CFTypeID EntitlementCheckApplier(CFTypeID result, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 8))
  {
    CFStringRef v3 = (const __CFString *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    CFDictionaryRef result = CFStringGetTypeID();
    if (v4 == result)
    {
      CFDictionaryRef result = IOHIDEventSystemConnectionHasEntitlement(*(void *)a2, v3);
      *(unsigned char *)(a2 + 8) = result != 0;
    }
  }
  return result;
}

BOOL IOHIDEventSystemConnectionHasEntitlement(uint64_t a1, CFStringRef theString)
{
  mach_vm_address_t v2 = *(void **)(a1 + 248);
  if (!v2) {
    return 0;
  }
  CStringPtr = CFStringGetCStringPtr(theString, 0);
  return xpc_dictionary_get_value(v2, CStringPtr) == (xpc_object_t)MEMORY[0x1E4F14518];
}

uint64_t IOHIDEventSystemConnectionGetTaskNamePort(uint64_t a1)
{
  return *(unsigned int *)(a1 + 192);
}

__CFString *IOHIDServiceClientCopyDescription(uint64_t a1)
{
  uint64_t valuePtr = 0;
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringRef v3 = Mutable;
  if (Mutable)
  {
    _IOHIDStringAppendIndendationAndFormat(Mutable, 0, @"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    CFTypeID v4 = *(const void **)(a1 + 16);
    if (v4 && (CFTypeID v5 = CFGetTypeID(v4), v5 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(*(CFNumberRef *)(a1 + 16), kCFNumberSInt64Type, &valuePtr);
    }
    else
    {
      CFAllocatorRef v6 = _IOHIDLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        IOHIDServiceClientCopyDescription_cold_5(a1 + 16, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s 0x%016llx\n", "SenderID:", valuePtr);
    if (*(void *)(a1 + 64))
    {
      _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s True\n", "Virtual:");
    }
    else
    {
      CFTypeRef v13 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"Built-In");
      if (v13)
      {
        CFAllocatorRef v14 = v13;
        int v15 = CFEqual(v13, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
        CFStringRef v16 = "True";
        if (!v15) {
          CFStringRef v16 = "False";
        }
        _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s %s\n", "BuiltIn:", v16);
        CFRelease(v14);
      }
      CFTypeRef v17 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"Manufacturer");
      if (v17)
      {
        uint64_t v18 = v17;
        _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s %@\n", "Manufacturer:", v17);
        CFRelease(v18);
      }
      CFTypeRef v19 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"Product");
      if (v19)
      {
        int v20 = v19;
        _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s %@\n", "Product:", v19);
        CFRelease(v20);
      }
      CFTypeRef v21 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"Transport");
      if (v21)
      {
        int v22 = v21;
        _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s %@\n", "Transport:", v21);
        CFRelease(v22);
      }
      CFTypeRef v23 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"LocationID");
      if (v23)
      {
        uint64_t v24 = v23;
        AppendUnsignedIntOrCFType(v3, v23, (uint64_t)"LocationID:");
        CFRelease(v24);
      }
      CFTypeRef v25 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"VendorID");
      if (v25)
      {
        int v26 = v25;
        AppendUnsignedIntOrCFType(v3, v25, (uint64_t)"VendorID:");
        CFRelease(v26);
      }
      CFTypeRef v27 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"ProductID");
      if (v27)
      {
        int v28 = v27;
        AppendUnsignedIntOrCFType(v3, v27, (uint64_t)"ProductID:");
        CFRelease(v28);
      }
      CFTypeRef v29 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"CountryCode");
      if (v29)
      {
        unsigned int v30 = v29;
        AppendUnsignedIntOrCFType(v3, v29, (uint64_t)"CountryCode:");
        CFRelease(v30);
      }
      CFTypeRef v31 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"StandardType");
      if (v31)
      {
        uint64_t v32 = v31;
        AppendUnsignedIntOrCFType(v3, v31, (uint64_t)"StandardType:");
        CFRelease(v32);
      }
      CFNumberRef v33 = (const __CFNumber *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"ReportInterval");
      if (v33)
      {
        CFNumberRef v34 = v33;
        CFTypeID v35 = CFGetTypeID(v33);
        if (v35 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v34, kCFNumberSInt64Type, &valuePtr);
          _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s %llu us\n", "ReportInterval:", valuePtr);
        }
        else
        {
          unsigned int v36 = _IOHIDLog();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
            IOHIDServiceClientCopyDescription_cold_4();
          }
          _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s ERROR\n", "ReportInterval:", v64);
        }
        CFRelease(v34);
      }
      CFNumberRef v37 = (const __CFNumber *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"SampleInterval");
      if (v37)
      {
        CFNumberRef v38 = v37;
        CFTypeID v39 = CFGetTypeID(v37);
        if (v39 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v38, kCFNumberSInt64Type, &valuePtr);
          _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s %llu us\n", "SampleInterval:", valuePtr);
        }
        else
        {
          int v40 = _IOHIDLog();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
            IOHIDServiceClientCopyDescription_cold_3();
          }
          _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s ERROR\n", "SampleInterval:", v64);
        }
        CFRelease(v38);
      }
      CFNumberRef v41 = (const __CFNumber *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"BatchInterval");
      if (v41)
      {
        CFNumberRef v42 = v41;
        CFTypeID v43 = CFGetTypeID(v41);
        if (v43 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v42, kCFNumberSInt64Type, &valuePtr);
          _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s %llu us\n", "BatchInterval:", valuePtr);
        }
        else
        {
          CFTypeID v44 = _IOHIDLog();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
            IOHIDServiceClientCopyDescription_cold_2();
          }
          _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s ERROR\n", "BatchInterval:", v64);
        }
        CFRelease(v42);
      }
      CFTypeRef v45 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"PrimaryUsagePage");
      if (v45)
      {
        long long v46 = v45;
        AppendUnsignedIntOrCFType(v3, v45, (uint64_t)"PrimaryUsagePage:");
        CFRelease(v46);
      }
      CFTypeRef v47 = IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"PrimaryUsage");
      if (v47)
      {
        long long v48 = v47;
        AppendUnsignedIntOrCFType(v3, v47, (uint64_t)"PrimaryUsage:");
        CFRelease(v48);
      }
      CFArrayRef v49 = (const __CFArray *)IOHIDServiceClientCopyProperty((IOHIDServiceClientRef)a1, @"DeviceUsagePairs");
      if (v49 && (CFTypeID TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(v49)))
      {
        _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s\n", "DeviceUsagePairs:");
        CFIndex Count = CFArrayGetCount(v49);
        if (Count >= 1)
        {
          CFIndex v52 = Count;
          for (CFIndex i = 0; i != v52; ++i)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v49, i);
            if (ValueAtIndex)
            {
              CFDictionaryRef v55 = ValueAtIndex;
              if (i) {
                _IOHIDStringAppendIndendationAndFormat(v3, 1, @"---------------------------\n");
              }
              CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v55, @"DeviceUsagePage");
              if (Value)
              {
                CFNumberRef v57 = Value;
                CFTypeID v58 = CFGetTypeID(Value);
                if (v58 == CFNumberGetTypeID())
                {
                  CFNumberGetValue(v57, kCFNumberSInt64Type, &valuePtr);
                  _IOHIDStringAppendIndendationAndFormat(v3, 1, @"%-20.20s %llu\n", "DeviceUsagePage:", valuePtr);
                }
              }
              CFNumberRef v59 = (const __CFNumber *)CFDictionaryGetValue(v55, @"DeviceUsage");
              if (v59)
              {
                CFNumberRef v60 = v59;
                CFTypeID v61 = CFGetTypeID(v59);
                if (v61 == CFNumberGetTypeID())
                {
                  CFNumberGetValue(v60, kCFNumberSInt64Type, &valuePtr);
                  _IOHIDStringAppendIndendationAndFormat(v3, 1, @"%-20.20s %llu\n", "DeviceUsage:", valuePtr);
                }
              }
            }
          }
        }
        CFRelease(v49);
      }
      else
      {
        long long v62 = _IOHIDLog();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          IOHIDServiceClientCopyDescription_cold_1();
        }
        _IOHIDStringAppendIndendationAndFormat(v3, 0, @"%-20.20s ERROR\n", "DeviceUsagePairs:");
      }
    }
    _IOHIDStringAppendIndendationAndFormat(v3, 0, @"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
  }
  return v3;
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  os_unfair_recursive_lock_lock_with_options();
  CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)service + 12), key);
  os_unfair_recursive_lock_unlock();
  if (!Value)
  {
    CFNumberRef v5 = _IOHIDServiceClientCopyUsageProp((uint64_t)service, key);
    if (v5)
    {
      CFNumberRef Value = v5;
      os_unfair_recursive_lock_lock_with_options();
      CFAllocatorRef v6 = (__CFDictionary *)*((void *)service + 12);
      CFStringRef v7 = key;
      uint64_t v8 = Value;
    }
    else
    {
      CFNumberRef Value = _IOHIDEventSystemClientCopyPropertyForService(*((void *)service + 1), service, key);
      if (!CFSetContainsValue((CFSetRef)__serviceKeysSet, key)) {
        return Value;
      }
      os_unfair_recursive_lock_lock_with_options();
      CFAllocatorRef v6 = (__CFDictionary *)*((void *)service + 12);
      if (Value) {
        uint64_t v8 = Value;
      }
      else {
        uint64_t v8 = (const void *)*MEMORY[0x1E4F1D260];
      }
      CFStringRef v7 = key;
    }
    CFDictionarySetValue(v6, v7, v8);
    os_unfair_recursive_lock_unlock();
    return Value;
  }
  if (CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F1D260])) {
    return 0;
  }
  CFRetain(Value);
  return Value;
}

CFNumberRef _IOHIDServiceClientCopyUsageProp(uint64_t a1, CFTypeRef cf1)
{
  if (CFEqual(cf1, @"PrimaryUsagePage"))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v5 = (const void *)(a1 + 128);
LABEL_5:
    return CFNumberCreate(v4, kCFNumberSInt32Type, v5);
  }
  if (CFEqual(cf1, @"PrimaryUsage"))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v5 = (const void *)(a1 + 132);
    goto LABEL_5;
  }
  if (!CFEqual(cf1, @"DeviceUsagePairs")) {
    return 0;
  }
  if (!*(void *)(a1 + 136)) {
    return 0;
  }
  CFIndex v7 = *(unsigned int *)(a1 + 144);
  if (!v7) {
    return 0;
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, MEMORY[0x1E4F1D510]);
  if (Mutable && *(_DWORD *)(a1 + 144))
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    uint64_t v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    CFTypeRef v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(v8, 2, v12, v13);
      if (!v14) {
        break;
      }
      int v15 = v14;
      CFNumberRef v16 = CFNumberCreate(v8, kCFNumberSInt32Type, (const void *)(*(void *)(a1 + 136) + v10));
      if (v16)
      {
        CFNumberRef v17 = v16;
        CFDictionarySetValue(v15, @"DeviceUsagePage", v16);
        CFRelease(v17);
      }
      CFNumberRef v18 = CFNumberCreate(v8, kCFNumberSInt32Type, (const void *)(*(void *)(a1 + 136) + v10 + 4));
      if (v18)
      {
        CFNumberRef v19 = v18;
        CFDictionarySetValue(v15, @"DeviceUsage", v18);
        CFRelease(v19);
      }
      CFArrayAppendValue(Mutable, v15);
      CFRelease(v15);
      ++v11;
      v10 += 8;
    }
    while (v11 < *(unsigned int *)(a1 + 144));
  }
  return Mutable;
}

void _IOHIDStringAppendIndendationAndFormat(CFMutableStringRef theString, int a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a2)
  {
    int v5 = a2;
    do
    {
      CFStringAppend(theString, @"    ");
      --v5;
    }
    while (v5);
  }
  CFStringAppendFormatAndArguments(theString, 0, format, va);
}

void AppendUnsignedIntOrCFType(__CFString *a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFNumberGetTypeID())
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
    _IOHIDStringAppendIndendationAndFormat(a1, 0, @"%-20.20s %llu\n", a3, valuePtr);
  }
  else
  {
    _IOHIDStringAppendIndendationAndFormat(a1, 0, @"%-20.20s %@\n", a3, cf);
  }
}

void __IOHIDConnectionFilterRelease(uint64_t a1)
{
  mach_vm_address_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

void __VirtualServicesApplier(uint64_t a1, void *a2)
{
}

void __FilterFunctionUnscheduleAsync_0(uint64_t a1, uint64_t a2)
{
}

id __FilterFunctionScheduleAsync_0(void *a1, uint64_t a2)
{
  return IOHIDSessionFilterScheduleWithDispatchQueue(a1, *(dispatch_object_t *)(a2 + 96));
}

uint64_t __FilterFunctionClose(uint64_t a1)
{
  return IOHIDServiceFilterClose(a1);
}

id __FilterFunctionClose_0(id result)
{
  return IOHIDSessionFilterClose(result);
}

uint64_t __SetPropertiesForObjectFunction(const void *a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  uint64_t result = IOHIDServiceGetTypeID();
  if (v6 == result)
  {
    return IOHIDServiceSetProperty((uint64_t)cf, a1, a2);
  }
  return result;
}

void __CheckForNewProperties(void *key, const void *a2, CFDictionaryRef *a3)
{
  CFNumberRef Value = CFDictionaryGetValue(*a3, key);
  if (!Value || !CFEqual(Value, a2))
  {
    CFIndex v7 = a3[1];
    CFDictionaryAddValue(v7, key, a2);
  }
}

CFStringRef IOHIDEventSystemConnectionCopyDescription(time_t *cf)
{
  if (*((_DWORD *)cf + 74))
  {
    CFAllocatorRef v2 = CFGetAllocator(cf);
    CFStringRef v3 = _IOHIDCreateTimeString(v2, cf + 41);
  }
  else
  {
    CFStringRef v3 = @"NONE";
  }
  CFAllocatorRef v4 = CFGetAllocator(cf);
  uint64_t v5 = *((int *)cf + 44);
  if (v5 > 4) {
    CFTypeID v6 = "Invalid";
  }
  else {
    CFTypeID v6 = off_1E548AE98[v5];
  }
  CFStringRef v7 = CFStringCreateWithFormat(v4, 0, @"IOHIDEventSystemConnection uuid:%@ pid:%d process:%@ type:%s entitlements:0x%x caller:%@ attributes:%@ state:0x%x events:%d mask:0x%llx dropped:%d dropStatus:%d droppedMask:0x%llx lastDroppedTime:%@", cf[20], *((unsigned int *)cf + 22), cf[19], v6, *(unsigned int *)cf[30], cf[18], cf[23], *((unsigned int *)cf + 66), *((unsigned int *)cf + 78), cf[40], *((unsigned int *)cf + 74), *((unsigned int *)cf + 92), cf[38], v3);
  if (v3) {
    CFRelease(v3);
  }
  return v7;
}

CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps)
{
  if (blob) {
    return (CFDictionaryRef)ps;
  }
  else {
    return 0;
  }
}

__n64 IOHIDEventGetDoubleValueWithOptions(void *EventWithOptions, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = HIWORD(a2);
  if (!EventWithOptions || a2 >= 0x10000)
  {
    uint64_t EventWithOptions = (void *)IOHIDEventGetEventWithOptions(EventWithOptions, HIWORD(a2), a3);
    if (!EventWithOptions)
    {
      result.n64_f64[0] = 0.0;
      return result;
    }
  }
  result.n64_f64[0] = 0.0;
  uint64_t v6 = EventWithOptions[13];
  switch(v4)
  {
    case 0u:
      switch(a2)
      {
        case 0u:
          LOBYTE(v6) = *(unsigned char *)(v6 + 8);
          goto LABEL_195;
        case 1u:
          unsigned int v13 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_204;
        case 2u:
          goto LABEL_21;
        case 3u:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 3) & 1;
          goto LABEL_205;
        case 4u:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 4) & 1;
          goto LABEL_205;
        case 5u:
          unsigned int v14 = *(unsigned __int8 *)(v6 + 8);
          goto LABEL_171;
        case 6u:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 6) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 1u:
      switch(a2)
      {
        case 0x10000u:
          goto LABEL_111;
        case 0x10001u:
          goto LABEL_114;
        case 0x10002u:
          goto LABEL_150;
        case 0x10003u:
          goto LABEL_83;
        default:
          return result;
      }
      return result;
    case 2u:
      switch(a2)
      {
        case 0x20000u:
          goto LABEL_131;
        case 0x20001u:
          goto LABEL_122;
        case 0x20002u:
          goto LABEL_123;
        case 0x20003u:
          goto LABEL_144;
        case 0x20004u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 3u:
      switch(a2)
      {
        case 0x30000u:
          goto LABEL_111;
        case 0x30001u:
          goto LABEL_114;
        case 0x30002u:
          goto LABEL_150;
        case 0x30003u:
          goto LABEL_160;
        case 0x30004u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 28);
          goto LABEL_151;
        case 0x30005u:
          LODWORD(v6) = *(_DWORD *)(v6 + 24);
          goto LABEL_195;
        case 0x30006u:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 1) & 3;
          goto LABEL_205;
        case 0x30007u:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 3) & 3;
          goto LABEL_205;
        case 0x30008u:
          unsigned int v14 = *(_DWORD *)(v6 + 24);
LABEL_171:
          unsigned int v7 = (v14 >> 5) & 1;
          goto LABEL_205;
        case 0x30009u:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 6) & 7;
          goto LABEL_205;
        case 0x3000Au:
          unsigned int v7 = (*(_DWORD *)(v6 + 24) >> 9) & 3;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 4u:
      if (a2 == 262146) {
        goto LABEL_137;
      }
      if (a2 == 262145) {
        goto LABEL_144;
      }
      if (a2 != 0x40000) {
        return result;
      }
      goto LABEL_98;
    case 5u:
      if (a2 == 327682) {
        goto LABEL_137;
      }
      if (a2 == 327681) {
        goto LABEL_144;
      }
      if (a2 != 327680) {
        return result;
      }
      goto LABEL_98;
    case 6u:
      switch(a2)
      {
        case 0x60000u:
          goto LABEL_98;
        case 0x60001u:
          goto LABEL_144;
        case 0x60002u:
          goto LABEL_137;
        case 0x60003u:
LABEL_21:
          unsigned int v7 = (*(unsigned __int8 *)(v6 + 8) >> 2) & 1;
          goto LABEL_205;
        default:
          return result;
      }
      return result;
    case 7u:
      if (a2 == 458754) {
        goto LABEL_137;
      }
      if (a2 == 458753) {
        goto LABEL_144;
      }
      if (a2 != 458752) {
        return result;
      }
      goto LABEL_98;
    case 9u:
      if (a2 == 589826)
      {
LABEL_137:
        int v11 = *(_DWORD *)(v6 + 24);
        goto LABEL_145;
      }
      if (a2 == 589825) {
        goto LABEL_144;
      }
      if (a2 != 589824) {
        return result;
      }
      goto LABEL_98;
    case 0xAu:
      if (a2 - 655360 > 0xB) {
        return result;
      }
      if (a2 == 655363)
      {
LABEL_113:
        result.n64_u32[0] = *(_DWORD *)(v6 + 32);
        goto LABEL_151;
      }
      switch(*(_DWORD *)(v6 + 32))
      {
        case 0:
          switch(a2)
          {
            case 0xA0002u:
              goto LABEL_137;
            case 0xA0001u:
              goto LABEL_144;
            case 0xA0000u:
              goto LABEL_98;
          }
          break;
        case 1:
          if (a2 == 655364) {
            goto LABEL_131;
          }
          break;
        case 2:
          switch(a2)
          {
            case 0xA0007u:
              goto LABEL_137;
            case 0xA0006u:
              goto LABEL_144;
            case 0xA0005u:
              goto LABEL_98;
          }
          break;
        case 3:
          switch(a2)
          {
            case 0xA0008u:
              goto LABEL_98;
            case 0xA0009u:
              goto LABEL_144;
            case 0xA000Au:
              goto LABEL_137;
            case 0xA000Bu:
              goto LABEL_138;
            default:
              return result;
          }
        default:
          return result;
      }
      return result;
    case 0xBu:
      switch(a2)
      {
        case 0xB0000u:
          goto LABEL_98;
        case 0xB0001u:
          goto LABEL_144;
        case 0xB0002u:
          goto LABEL_137;
        case 0xB0003u:
          goto LABEL_161;
        case 0xB0004u:
          goto LABEL_113;
        case 0xB0005u:
          goto LABEL_107;
        case 0xB0006u:
          goto LABEL_116;
        case 0xB0007u:
          goto LABEL_162;
        case 0xB0008u:
LABEL_160:
          unsigned int v7 = HIWORD(*(_DWORD *)(v6 + 8)) & 1;
          goto LABEL_205;
        case 0xB0009u:
          unsigned int v7 = (*(_DWORD *)(v6 + 8) >> 17) & 1;
          goto LABEL_205;
        case 0xB000Au:
          goto LABEL_186;
        case 0xB000Bu:
          goto LABEL_187;
        case 0xB000Cu:
          goto LABEL_207;
        case 0xB000Du:
        case 0xB000Eu:
        case 0xB000Fu:
        case 0xB0010u:
        case 0xB0011u:
        case 0xB0012u:
        case 0xB0013u:
        case 0xB0014u:
        case 0xB0015u:
        case 0xB001Au:
          int v8 = *(_DWORD *)(v6 + 64);
          if (v8)
          {
            if (v8 == 2)
            {
              switch(a2)
              {
                case 0xB0011u:
                  goto LABEL_178;
                case 0xB0012u:
                  goto LABEL_179;
                case 0xB0013u:
                  goto LABEL_188;
                case 0xB0014u:
                  goto LABEL_189;
                case 0xB0015u:
LABEL_213:
                  int v11 = *(_DWORD *)(v6 + 84);
                  goto LABEL_145;
                case 0xB001Au:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            else if (v8 == 1)
            {
              switch(a2)
              {
                case 0xB000Fu:
                  goto LABEL_178;
                case 0xB0010u:
                  goto LABEL_179;
                case 0xB0011u:
                  goto LABEL_188;
                case 0xB0012u:
                  goto LABEL_189;
                case 0xB0014u:
                  goto LABEL_213;
                case 0xB0015u:
                  goto LABEL_190;
                default:
                  return result;
              }
            }
            return result;
          }
          if (a2 == 720910) {
            goto LABEL_179;
          }
          if (a2 != 720909) {
            return result;
          }
          goto LABEL_178;
        case 0xB0016u:
          unsigned int v13 = *(_DWORD *)(v6 + 8);
          goto LABEL_204;
        case 0xB0017u:
          if (!*(_DWORD *)(v6 + 32)) {
            goto LABEL_207;
          }
          return result;
        case 0xB0018u:
          goto LABEL_159;
        case 0xB0019u:
          unsigned int v7 = (*(_DWORD *)(v6 + 8) >> 19) & 1;
          goto LABEL_205;
        case 0xB001Bu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 92);
          goto LABEL_151;
        case 0xB001Cu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 96);
          goto LABEL_151;
        case 0xB001Du:
          result.n64_u32[0] = *(_DWORD *)(v6 + 100);
          goto LABEL_151;
        case 0xB001Fu:
          result.n64_u32[0] = *(_DWORD *)(v6 + 64);
          goto LABEL_151;
        default:
          return result;
      }
    case 0xCu:
      switch(a2)
      {
        case 0xC0000u:
          goto LABEL_131;
        case 0xC0001u:
          goto LABEL_150;
        case 0xC0002u:
          goto LABEL_83;
        case 0xC0003u:
          goto LABEL_107;
        case 0xC0004u:
          goto LABEL_113;
        case 0xC0005u:
          int v9 = *(unsigned __int8 *)(v6 + 36);
          goto LABEL_164;
        case 0xC0006u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 37);
          goto LABEL_151;
        case 0xC0007u:
          goto LABEL_126;
        case 0xC0008u:
          goto LABEL_119;
        case 0xC0009u:
          goto LABEL_120;
        case 0xC000Au:
          goto LABEL_139;
        case 0xC000Bu:
          goto LABEL_140;
        default:
          return result;
      }
      return result;
    case 0xDu:
      switch(a2)
      {
        case 0xD0000u:
          goto LABEL_98;
        case 0xD0001u:
          goto LABEL_144;
        case 0xD0002u:
          goto LABEL_137;
        case 0xD0003u:
          goto LABEL_107;
        case 0xD0004u:
          goto LABEL_113;
        case 0xD0005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0xEu:
      switch(a2)
      {
        case 0xE0000u:
          goto LABEL_111;
        case 0xE0001u:
        case 0xE0003u:
          if (*(_WORD *)(v6 + 18) == 1)
          {
            int v10 = 917507;
            goto LABEL_103;
          }
          if (a2 != 917505 || *(_WORD *)(v6 + 18)) {
            return result;
          }
          goto LABEL_150;
        case 0xE0002u:
          goto LABEL_114;
        default:
          return result;
      }
    case 0xFu:
      if (a2 != 983040) {
        return result;
      }
      goto LABEL_98;
    case 0x10u:
      switch(a2)
      {
        case 0x100000u:
          goto LABEL_107;
        case 0x100001u:
          goto LABEL_72;
        case 0x100002u:
          goto LABEL_112;
        case 0x100003u:
          goto LABEL_98;
        case 0x100004u:
          goto LABEL_144;
        case 0x100005u:
          goto LABEL_115;
        case 0x100006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x11u:
      switch(a2)
      {
        case 0x110000u:
          goto LABEL_98;
        case 0x110001u:
          goto LABEL_144;
        case 0x110002u:
          goto LABEL_137;
        case 0x110003u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x12u:
      if (a2 == 1179649) {
        goto LABEL_144;
      }
      if (a2 != 1179648) {
        return result;
      }
      goto LABEL_131;
    case 0x13u:
      switch(a2)
      {
        case 0x130000u:
          goto LABEL_98;
        case 0x130001u:
          goto LABEL_144;
        case 0x130002u:
          goto LABEL_137;
        case 0x130003u:
          goto LABEL_91;
        case 0x130004u:
          goto LABEL_112;
        case 0x130005u:
          goto LABEL_153;
        case 0x130006u:
          goto LABEL_107;
        default:
          return result;
      }
      return result;
    case 0x14u:
      switch(a2)
      {
        case 0x140000u:
          goto LABEL_98;
        case 0x140001u:
          goto LABEL_144;
        case 0x140002u:
          goto LABEL_137;
        case 0x140003u:
          goto LABEL_107;
        case 0x140004u:
          goto LABEL_113;
        case 0x140005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x15u:
      switch(a2)
      {
        case 0x150000u:
          goto LABEL_98;
        case 0x150001u:
          goto LABEL_144;
        case 0x150002u:
          goto LABEL_137;
        case 0x150003u:
          goto LABEL_107;
        case 0x150004u:
          goto LABEL_113;
        case 0x150005u:
          goto LABEL_116;
        default:
          return result;
      }
      return result;
    case 0x17u:
      switch(a2)
      {
        case 0x170000u:
          goto LABEL_107;
        case 0x170001u:
          goto LABEL_72;
        case 0x170002u:
          goto LABEL_112;
        case 0x170003u:
          goto LABEL_98;
        case 0x170004u:
          goto LABEL_144;
        case 0x170005u:
          goto LABEL_115;
        case 0x170006u:
          goto LABEL_137;
        default:
          return result;
      }
      return result;
    case 0x18u:
      if (a2 == 1572864) {
        goto LABEL_131;
      }
      if (a2 == 1572865)
      {
        unsigned int v7 = *(unsigned __int16 *)(v6 + 8) >> 15;
LABEL_205:
        result.n64_f64[0] = (double)v7;
      }
      return result;
    case 0x19u:
      if (a2 == 1638402)
      {
LABEL_107:
        result.n64_u32[0] = *(_DWORD *)(v6 + 28);
        goto LABEL_151;
      }
      if (a2 == 1638401)
      {
LABEL_83:
        result.n64_u32[0] = *(_DWORD *)(v6 + 24);
        goto LABEL_151;
      }
      if (a2 != 1638400) {
        return result;
      }
      goto LABEL_98;
    case 0x1Au:
      switch(a2)
      {
        case 0x1A0002u:
          goto LABEL_83;
        case 0x1A0001u:
LABEL_109:
          result.n64_u8[0] = *(unsigned char *)(v6 + 20);
          goto LABEL_151;
        case 0x1A0000u:
          goto LABEL_131;
      }
      return result;
    case 0x1Bu:
      switch(a2)
      {
        case 0x1B0000u:
          goto LABEL_107;
        case 0x1B0001u:
          goto LABEL_72;
        case 0x1B0002u:
          goto LABEL_112;
        case 0x1B0003u:
          goto LABEL_98;
        case 0x1B0004u:
          goto LABEL_144;
        case 0x1B0005u:
          goto LABEL_115;
        default:
          return result;
      }
      return result;
    case 0x1Cu:
      switch(a2)
      {
        case 0x1C0000u:
          goto LABEL_107;
        case 0x1C0001u:
LABEL_72:
          result.n64_u16[0] = *(_WORD *)(v6 + 32);
          goto LABEL_151;
        case 0x1C0002u:
          goto LABEL_112;
        case 0x1C0003u:
          goto LABEL_98;
        case 0x1C0004u:
          goto LABEL_144;
        case 0x1C0005u:
LABEL_115:
          result.n64_u16[0] = *(_WORD *)(v6 + 34);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Du:
      switch(a2)
      {
        case 0x1D0000u:
          goto LABEL_131;
        case 0x1D0001u:
          goto LABEL_144;
        case 0x1D0002u:
          result.n64_u16[0] = *(_WORD *)(v6 + 24);
          goto LABEL_151;
        case 0x1D0003u:
          result.n64_u16[0] = *(_WORD *)(v6 + 26);
          goto LABEL_151;
        case 0x1D0004u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 32);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x1Eu:
      if (a2 == 1966082) {
        goto LABEL_83;
      }
      if (a2 == 1966081) {
        goto LABEL_144;
      }
      if (a2 != 1966080) {
        return result;
      }
      goto LABEL_131;
    case 0x1Fu:
      if (a2 == 2031617) {
        goto LABEL_150;
      }
      if (a2 != 2031616) {
        return result;
      }
      goto LABEL_98;
    case 0x20u:
      switch(a2)
      {
        case 0x200000u:
          goto LABEL_131;
        case 0x200001u:
          goto LABEL_144;
        case 0x200002u:
          goto LABEL_83;
        case 0x200003u:
          goto LABEL_138;
        default:
          return result;
      }
      return result;
    case 0x21u:
      if (a2 == 2162689) {
        goto LABEL_144;
      }
      if (a2 != 2162688) {
        return result;
      }
      goto LABEL_131;
    case 0x22u:
      if (a2 == 2228225) {
        goto LABEL_144;
      }
      if (a2 != 2228224) {
        return result;
      }
      goto LABEL_131;
    case 0x23u:
      switch(a2)
      {
        case 0x230000u:
          goto LABEL_131;
        case 0x230001u:
          goto LABEL_144;
        case 0x230002u:
          goto LABEL_137;
        case 0x230003u:
LABEL_138:
          int v11 = *(_DWORD *)(v6 + 28);
          goto LABEL_145;
        case 0x230004u:
LABEL_91:
          int v11 = *(_DWORD *)(v6 + 32);
          goto LABEL_145;
        case 0x230005u:
          int v11 = *(_DWORD *)(v6 + 44);
          goto LABEL_145;
        case 0x230006u:
          int v11 = *(_DWORD *)(v6 + 48);
          goto LABEL_145;
        case 0x230007u:
LABEL_112:
          int v11 = *(_DWORD *)(v6 + 36);
          goto LABEL_145;
        case 0x230008u:
LABEL_153:
          int v11 = *(_DWORD *)(v6 + 40);
          goto LABEL_145;
        case 0x230009u:
LABEL_178:
          int v11 = *(_DWORD *)(v6 + 68);
          goto LABEL_145;
        case 0x23000Au:
LABEL_188:
          int v11 = *(_DWORD *)(v6 + 76);
          goto LABEL_145;
        case 0x23000Bu:
LABEL_179:
          int v11 = *(_DWORD *)(v6 + 72);
          goto LABEL_145;
        case 0x23000Cu:
LABEL_189:
          int v11 = *(_DWORD *)(v6 + 80);
          goto LABEL_145;
        case 0x23000Du:
LABEL_186:
          int v11 = *(_DWORD *)(v6 + 52);
          goto LABEL_145;
        case 0x23000Eu:
LABEL_187:
          int v11 = *(_DWORD *)(v6 + 56);
          goto LABEL_145;
        case 0x23000Fu:
LABEL_207:
          int v11 = *(_DWORD *)(v6 + 60);
          goto LABEL_145;
        case 0x230010u:
          int v11 = *(_DWORD *)(v6 + 64);
          goto LABEL_145;
        case 0x230011u:
          LOBYTE(v6) = *(unsigned char *)(v6 + 84);
LABEL_195:
          unsigned int v7 = v6 & 1;
          goto LABEL_205;
        case 0x230012u:
          unsigned int v13 = *(unsigned __int8 *)(v6 + 84);
LABEL_204:
          unsigned int v7 = (v13 >> 1) & 1;
          goto LABEL_205;
        case 0x230013u:
LABEL_190:
          int v11 = *(_DWORD *)(v6 + 88);
          goto LABEL_145;
        case 0x230014u:
          int v11 = *(_DWORD *)(v6 + 92);
          goto LABEL_145;
        case 0x230015u:
          int v11 = *(_DWORD *)(v6 + 96);
          goto LABEL_145;
        case 0x230016u:
          int v11 = *(_DWORD *)(v6 + 100);
          goto LABEL_145;
        case 0x230017u:
          int v11 = *(_DWORD *)(v6 + 104);
          goto LABEL_145;
        case 0x230018u:
          int v11 = *(_DWORD *)(v6 + 108);
          goto LABEL_145;
        default:
          return result;
      }
      return result;
    case 0x24u:
      if (a2 == 2359297) {
        goto LABEL_150;
      }
      if (a2 != 2359296) {
        return result;
      }
      goto LABEL_98;
    case 0x26u:
      switch(a2)
      {
        case 0x260002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          goto LABEL_151;
        case 0x260001u:
          goto LABEL_144;
        case 0x260000u:
LABEL_98:
          int v11 = *(_DWORD *)(v6 + 16);
          goto LABEL_145;
      }
      return result;
    case 0x27u:
      if (a2 - 2555905 >= 2)
      {
        if (a2 != 2555904) {
          return result;
        }
LABEL_131:
        result.n64_u32[0] = *(_DWORD *)(v6 + 16);
        goto LABEL_151;
      }
      int v12 = *(_DWORD *)(v6 + 16);
      if (v12 != 1)
      {
        if (v12)
        {
          if (a2 != 2555905 || v12 != 2) {
            return result;
          }
        }
        else
        {
          int v10 = 2555905;
LABEL_103:
          if (a2 != v10) {
            return result;
          }
        }
LABEL_150:
        result.n64_u32[0] = *(_DWORD *)(v6 + 20);
LABEL_151:
        result.n64_f64[0] = (double)result.n64_u64[0];
        return result;
      }
      if (a2 == 2555906)
      {
LABEL_144:
        int v11 = *(_DWORD *)(v6 + 20);
LABEL_145:
        result.n64_f64[0] = (double)v11 * 0.0000152587891;
        if (v11 == 0x80000000) {
          result.n64_f64[0] = NAN;
        }
      }
      return result;
    case 0x28u:
      switch(a2)
      {
        case 0x280000u:
          result.n64_u16[0] = *(_WORD *)(v6 + 64);
          goto LABEL_151;
        case 0x280001u:
          result.n64_u16[0] = *(_WORD *)(v6 + 66);
          goto LABEL_151;
        case 0x280002u:
          result.n64_u64[0] = *(unint64_t *)(v6 + 16);
          break;
        case 0x280003u:
LABEL_122:
          result.n64_u8[0] = *(unsigned char *)(v6 + 24);
          goto LABEL_151;
        case 0x280004u:
LABEL_123:
          result.n64_u8[0] = *(unsigned char *)(v6 + 25);
          goto LABEL_151;
        case 0x280005u:
          goto LABEL_107;
        case 0x280006u:
          goto LABEL_113;
        case 0x280007u:
LABEL_116:
          result.n64_u32[0] = *(_DWORD *)(v6 + 36);
          goto LABEL_151;
        case 0x280008u:
          result.n64_u8[0] = *(unsigned char *)(v6 + 44);
          goto LABEL_151;
        case 0x280009u:
LABEL_161:
          result.n64_u32[0] = *(_DWORD *)(v6 + 48);
          goto LABEL_151;
        case 0x28000Au:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          goto LABEL_151;
        case 0x28000Bu:
          result.n64_u8[0] = *(unsigned char *)(v6 + 26);
          goto LABEL_151;
        case 0x28000Cu:
LABEL_162:
          result.n64_u32[0] = *(_DWORD *)(v6 + 40);
          goto LABEL_151;
        default:
          return result;
      }
      return result;
    case 0x29u:
      switch(a2)
      {
        case 0x290000u:
          goto LABEL_131;
        case 0x290001u:
          goto LABEL_109;
        case 0x290002u:
          goto LABEL_124;
        case 0x290003u:
          goto LABEL_125;
        case 0x290004u:
LABEL_126:
          result.n64_u64[0] = *(unint64_t *)(v6 + 40);
          break;
        case 0x290005u:
          goto LABEL_119;
        case 0x290006u:
          goto LABEL_120;
        default:
          return result;
      }
      return result;
    case 0x2Au:
      switch(a2)
      {
        case 0x2A0000u:
LABEL_111:
          result.n64_u16[0] = *(_WORD *)(v6 + 16);
          goto LABEL_151;
        case 0x2A0001u:
LABEL_114:
          result.n64_u16[0] = *(_WORD *)(v6 + 18);
          goto LABEL_151;
        case 0x2A0002u:
LABEL_124:
          result.n64_u64[0] = *(unint64_t *)(v6 + 24);
          break;
        case 0x2A0003u:
LABEL_125:
          result.n64_u64[0] = *(unint64_t *)(v6 + 32);
          break;
        case 0x2A0004u:
          int v9 = *(unsigned __int8 *)(v6 + 40);
LABEL_164:
          if (v9) {
            result.n64_f64[0] = 1.0;
          }
          break;
        case 0x2A0005u:
LABEL_159:
          result.n64_u32[0] = *(_DWORD *)(v6 + 44);
          goto LABEL_151;
        case 0x2A0006u:
LABEL_119:
          result.n64_u64[0] = *(unint64_t *)(v6 + 48);
          break;
        case 0x2A0007u:
LABEL_120:
          result.n64_u64[0] = *(unint64_t *)(v6 + 56);
          break;
        case 0x2A0008u:
LABEL_139:
          result.n64_u64[0] = *(unint64_t *)(v6 + 64);
          break;
        case 0x2A0009u:
LABEL_140:
          result.n64_u64[0] = *(unint64_t *)(v6 + 72);
          break;
        default:
          return result;
      }
      return result;
    default:
      return result;
  }
}

kern_return_t IORegistryCreateIterator(mach_port_t mainPort, const io_name_t plane, IOOptionBits options, io_iterator_t *iterator)
{
  kern_return_t v9;
  mach_port_t mainPorta;

  mach_port_t v8 = mainPort;
  if (!mainPort)
  {
    mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v8 = 0;
    }
    else {
      mach_port_t v8 = mainPorta;
    }
  }
  int v9 = io_registry_create_iterator(v8, plane, options, iterator);
  if (v8 && v8 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v8);
  }
  return v9;
}

uint64_t io_registry_create_iterator(unsigned int a1, const char *a2, int a3, _DWORD *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  memset(v16, 0, 140);
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v15 = 0u;
  *((void *)&v15 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v7 = mig_strncpy_zerofill((char *)v16 + 8, a2, 128);
  }
  else {
    int v7 = mig_strncpy((char *)v16 + 8, a2, 128);
  }
  LODWORD(v16[0]) = 0;
  DWORD1(v16[0]) = v7;
  uint64_t v8 = (v7 + 3) & 0xFFFFFFFC;
  mach_port_t v9 = v8 + 44;
  *(_DWORD *)((char *)v16 + v8 + 8) = a3;
  mach_port_t v10 = mig_get_reply_port();
  reply_port[0] = 5395;
  reply_port[1] = v9;
  *(void *)&reply_port[2] = __PAIR64__(v10, a1);
  *(void *)&long long v15 = 0xAF600000000;
  uint64_t v11 = mach_msg2_internal();
  uint64_t v12 = v11;
  if ((v11 - 268435458) <= 0xE && ((1 << (v11 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else
  {
    if (!v11)
    {
      if (DWORD1(v15) == 71)
      {
        uint64_t v12 = 4294966988;
      }
      else if (DWORD1(v15) == 2906)
      {
        if ((reply_port[0] & 0x80000000) != 0)
        {
          uint64_t v12 = 4294966996;
          if (DWORD2(v15) == 1 && reply_port[1] == 40 && !reply_port[2] && WORD3(v16[0]) << 16 == 1114112)
          {
            uint64_t v12 = 0;
            *a4 = HIDWORD(v15);
            return v12;
          }
        }
        else if (reply_port[1] == 36)
        {
          uint64_t v12 = 4294966996;
          if (LODWORD(v16[0]))
          {
            if (reply_port[2]) {
              uint64_t v12 = 4294966996;
            }
            else {
              uint64_t v12 = LODWORD(v16[0]);
            }
          }
        }
        else
        {
          uint64_t v12 = 4294966996;
        }
      }
      else
      {
        uint64_t v12 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)reply_port);
      return v12;
    }
    mig_dealloc_reply_port(reply_port[3]);
  }
  return v12;
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  v7[3] = *MEMORY[0x1E4F143B8];
  v7[0] = 0;
  v7[1] = callback;
  v7[2] = refCon;
  return InternalIOServiceAddNotification(*(_DWORD *)notifyPort, notificationType, matching, *((_DWORD *)notifyPort + 1), v7, 3u, notification);
}

uint64_t InternalIOServiceAddNotification(mach_port_t a1, const char *a2, CFTypeRef object, int a4, const void *a5, unsigned int a6, _DWORD *a7)
{
  uint64_t v7 = 3758097090;
  if (!object) {
    return v7;
  }
  mach_port_t v14 = a1;
  if (!a1)
  {
    mainmach_port_name_t Port = 0;
    if (IOMasterPort(0, &mainPort)) {
      mach_port_t v14 = 0;
    }
    else {
      mach_port_t v14 = mainPort;
    }
  }
  CFDataRef v15 = IOCFSerialize(object, gIOKitLibSerializeOptions);
  CFRelease(object);
  if (!v15) {
    return 3758097095;
  }
  unint64_t Length = CFDataGetLength(v15);
  int v17 = Length;
  if (gIOKitLibSerializeOptions)
  {
    if (Length <= 0xFFF)
    {
      CFDataGetBytePtr(v15);
      uint64_t v19 = io_service_add_notification_bin();
      goto LABEL_13;
    }
  }
  else if (Length <= 0x1FF)
  {
    BytePtr = (const char *)CFDataGetBytePtr(v15);
    uint64_t v19 = io_service_add_notification(v14, a2, BytePtr, a4, a5, a6, a7);
LABEL_13:
    uint64_t v7 = v19;
    goto LABEL_17;
  }
  unsigned int v24 = 0;
  int v20 = CFDataGetBytePtr(v15);
  unsigned int v21 = io_service_add_notification_ool(v14, a2, (uint64_t)v20, v17, a4, a5, a6, &v24, a7);
  if (v21) {
    uint64_t v7 = v21;
  }
  else {
    uint64_t v7 = v24;
  }
LABEL_17:
  CFRelease(v15);
  if (v14 && v14 != a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v14);
  }
  return v7;
}

uint64_t io_service_add_notification_bin()
{
  unsigned int v0 = MEMORY[0x1F4188790]();
  CFStringRef v3 = v2;
  unsigned int v5 = v4;
  uint64_t v7 = v6;
  unsigned int v9 = v8;
  uint64_t v11 = v10;
  unsigned int v12 = v0;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v25 = 0u;
  memset(v26, 0, 464);
  memset(&reply_port, 0, sizeof(reply_port));
  int v23 = 1;
  int v24 = v13;
  DWORD1(v25) = 1310720;
  *((void *)&v25 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v14 = mig_strncpy_zerofill((char *)v26 + 8, v1, 128);
  }
  else {
    int v14 = mig_strncpy((char *)v26 + 8, v1, 128);
  }
  LODWORD(v26[0]) = 0;
  DWORD1(v26[0]) = v14;
  if (v9 > 0x1000) {
    return 4294966989;
  }
  uint64_t v15 = (v14 + 3) & 0xFFFFFFFC;
  memcpy((char *)v26 + v15 + 12, v11, v9);
  *(_DWORD *)((char *)v26 + v15 + 8) = v9;
  if (v5 > 8) {
    return 4294966989;
  }
  uint64_t v18 = (v9 + 3) & 0xFFFFFFFC;
  uint64_t v19 = (char *)&reply_port + v15 + v18 - 128;
  memcpy(v19 + 192, v7, 8 * v5);
  *((_DWORD *)v19 + 47) = v5;
  mach_port_t v20 = mig_get_reply_port();
  reply_port.msgh_bits = -2147478253;
  reply_port.msgh_unsigned int size = v18 + 8 * v5 + v15 + 64;
  *(void *)&reply_port.mach_port_t msgh_remote_port = __PAIR64__(v20, v12);
  *(void *)&reply_port.msgh_voucher_port = 0xB4400000000;
  uint64_t v21 = mach_msg2_internal();
  uint64_t v16 = v21;
  if ((v21 - 268435458) <= 0xE && ((1 << (v21 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port.msgh_local_port);
  }
  else
  {
    if (!v21)
    {
      if (reply_port.msgh_id == 71)
      {
        uint64_t v16 = 4294966988;
      }
      else if (reply_port.msgh_id == 2984)
      {
        if ((reply_port.msgh_bits & 0x80000000) != 0)
        {
          uint64_t v16 = 4294966996;
          if (v23 == 1 && reply_port.msgh_size == 40 && !reply_port.msgh_remote_port && WORD3(v25) << 16 == 1114112)
          {
            uint64_t v16 = 0;
            _DWORD *v3 = v24;
            return v16;
          }
        }
        else if (reply_port.msgh_size == 36)
        {
          uint64_t v16 = 4294966996;
          if (v25)
          {
            if (reply_port.msgh_remote_port) {
              uint64_t v16 = 4294966996;
            }
            else {
              uint64_t v16 = v25;
            }
          }
        }
        else
        {
          uint64_t v16 = 4294966996;
        }
      }
      else
      {
        uint64_t v16 = 4294966995;
      }
      mach_msg_destroy(&reply_port);
      return v16;
    }
    mig_dealloc_reply_port(reply_port.msgh_local_port);
  }
  return v16;
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  kern_return_t v6;
  CFTypeRef v8;
  void *keys;

  unsigned int v8 = property;
  keys = (void *)propertyName;
  CFDictionaryRef v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, &v8, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v4) {
    return -536870211;
  }
  CFDictionaryRef v5 = v4;
  uint64_t v6 = IORegistryEntrySetCFProperties(entry, v4);
  CFRelease(v5);
  return v6;
}

kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties)
{
  kern_return_t v7;

  CFDataRef v3 = IOCFSerialize(properties, gIOKitLibSerializeOptions);
  if (!v3) {
    return -536870201;
  }
  CFDataRef v4 = v3;
  BytePtr = CFDataGetBytePtr(v3);
  int Length = CFDataGetLength(v4);
  uint64_t v7 = io_registry_entry_set_properties(entry, (uint64_t)BytePtr, Length);
  CFRelease(v4);
  if (v7) {
    return v7;
  }
  else {
    return 0;
  }
}

uint64_t io_registry_entry_set_properties(unsigned int a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v7 = 1;
  uint64_t v8 = a2;
  int v9 = 0x1000000;
  int v10 = a3;
  uint64_t v11 = *MEMORY[0x1E4F14068];
  int v12 = a3;
  *(void *)&v6.msgh_bits = 0x3880001513;
  *(void *)&v6.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v6.msgh_voucher_port = 0xB0C00000000;
  uint64_t v3 = mach_msg2_internal();
  uint64_t v4 = v3;
  if ((v3 - 268435458) <= 0xE && ((1 << (v3 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v6.msgh_local_port);
  }
  else if (v3)
  {
    mig_dealloc_reply_port(v6.msgh_local_port);
  }
  else
  {
    uint64_t v4 = 4294966995;
    mach_msg_destroy(&v6);
  }
  return v4;
}

kern_return_t IOConnectSetCFProperty(io_connect_t connect, CFStringRef propertyName, CFTypeRef property)
{
  kern_return_t v6;
  CFStringRef v8;
  void *values;

  uint64_t v8 = propertyName;
  values = (void *)property;
  CFDictionaryRef v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&v8, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v4) {
    return -536870211;
  }
  CFDictionaryRef v5 = v4;
  mach_msg_header_t v6 = IOConnectSetCFProperties(connect, v4);
  CFRelease(v5);
  return v6;
}

kern_return_t IOConnectSetCFProperties(io_connect_t connect, CFTypeRef properties)
{
  kern_return_t v7;

  CFDataRef v3 = IOCFSerialize(properties, gIOKitLibSerializeOptions);
  if (!v3) {
    return -536870201;
  }
  CFDataRef v4 = v3;
  BytePtr = CFDataGetBytePtr(v3);
  int Length = CFDataGetLength(v4);
  int v7 = io_connect_set_properties(connect, (uint64_t)BytePtr, Length);
  CFRelease(v4);
  if (v7) {
    return v7;
  }
  else {
    return 0;
  }
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  mach_port_t v4 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPorta;
    }
  }
  io_registry_entry_from_path(v4, path);
  if (v4 && v4 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
  }
  return 0;
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  if (mainPort)
  {
    mach_port_t v1 = mainPort;
    IOObjectRetain(mainPort);
  }
  else
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v1 = 0;
    }
    else {
      mach_port_t v1 = mainPorta;
    }
  }
  CFAllocatorRef v2 = (mach_port_name_t *)malloc_type_calloc(1uLL, 0x28uLL, 0x1020040E39C8550uLL);
  CFDataRef v3 = v2;
  if (v2)
  {
    mach_port_name_t *v2 = v1;
    if (mach_port_allocate(*MEMORY[0x1E4F14960], 1u, v2 + 1))
    {
      free(v3);
      return 0;
    }
  }
  return (IONotificationPortRef)v3;
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  if (!matching) {
    return 0;
  }
  mach_port_t v4 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPorta;
    }
  }
  CFDataRef v5 = IOCFSerialize(matching, gIOKitLibSerializeOptions);
  CFRelease(matching);
  if (!v5) {
    return 0;
  }
  unint64_t Length = CFDataGetLength(v5);
  int v7 = Length;
  if (gIOKitLibSerializeOptions)
  {
    if (Length <= 0xFFF)
    {
      CFDataGetBytePtr(v5);
      io_service_get_matching_service_bin();
      goto LABEL_14;
    }
LABEL_13:
    BytePtr = CFDataGetBytePtr(v5);
    io_service_get_matching_service_ool(v4, (uint64_t)BytePtr, v7);
    goto LABEL_14;
  }
  if (Length > 0x1FF) {
    goto LABEL_13;
  }
  uint64_t v8 = (const char *)CFDataGetBytePtr(v5);
  io_service_get_matching_service(v4, v8);
LABEL_14:
  CFRelease(v5);
  if (v4)
  {
    if (v4 != mainPort) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
    }
  }
  return 0;
}

CFDataRef IOCFSerialize(CFDataRef object, CFOptionFlags options)
{
  if (object)
  {
    CFStringRef v2 = (const __CFString *)object;
    uint64_t v11 = 0;
    if (options)
    {
      uint64_t v21 = 1;
      uint64_t v22 = 0;
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      *(void *)bytes = Mutable;
      if (!Mutable) {
        IOCFSerialize_cold_8();
      }
      CFDataRef v5 = Mutable;
      long long v6 = *(_OWORD *)(MEMORY[0x1E4F1D530] + 32);
      *(_OWORD *)&keyCallBacks.release = *(_OWORD *)(MEMORY[0x1E4F1D530] + 16);
      *(_OWORD *)&keyCallBacks.equal = v6;
      *(_OWORD *)&keyCallBacks.version = *MEMORY[0x1E4F1D530];
      keyCallBacks.equal = 0;
      CFMutableDictionaryRef v20 = CFDictionaryCreateMutable(v3, 0, &keyCallBacks, 0);
      if (!v20) {
        IOCFSerialize_cold_9();
      }
      CFDataAppendBytes(v5, (const UInt8 *)byte_18B50B938, 4);
      int v7 = DoCFSerializeBinary((uint64_t)bytes, v2, 0);
      object = *(CFDataRef *)bytes;
      if (!v7 && *(void *)bytes)
      {
        CFRelease(*(CFTypeRef *)bytes);
        object = 0;
        *(void *)bytes = 0;
      }
      if (v20)
      {
        CFRelease(v20);
        return *(CFDataRef *)bytes;
      }
    }
    else if (options)
    {
      return 0;
    }
    else
    {
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDataRef theData = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (!theData) {
        IOCFSerialize_cold_1();
      }
      LODWORD(v11) = 0;
      long long v9 = *(_OWORD *)(MEMORY[0x1E4F1D530] + 32);
      *(_OWORD *)&keyCallBacks.release = *(_OWORD *)(MEMORY[0x1E4F1D530] + 16);
      *(_OWORD *)&keyCallBacks.equal = v9;
      *(_OWORD *)&keyCallBacks.version = *MEMORY[0x1E4F1D530];
      keyCallBacks.equal = 0;
      CFTypeRef cf = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      if (!cf) {
        IOCFSerialize_cold_2();
      }
      CFTypeRef v13 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      if (!v13) {
        IOCFSerialize_cold_3();
      }
      CFTypeRef v14 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      if (!v14) {
        IOCFSerialize_cold_4();
      }
      CFTypeRef v15 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      if (!v15) {
        IOCFSerialize_cold_5();
      }
      CFTypeRef v16 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      if (!v16) {
        IOCFSerialize_cold_6();
      }
      CFTypeRef v17 = CFDictionaryCreateMutable(v8, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      if (!v17) {
        IOCFSerialize_cold_7();
      }
      if (DoIdrefScan(v2, (uint64_t)&theData) && DoCFSerialize(v2, &theData))
      {
        bytes[0] = 0;
        CFDataAppendBytes(theData, bytes, 1);
      }
      else if (theData)
      {
        CFRelease(theData);
        CFMutableDataRef theData = 0;
      }
      if (cf) {
        CFRelease(cf);
      }
      if (v13) {
        CFRelease(v13);
      }
      if (v14) {
        CFRelease(v14);
      }
      if (v15) {
        CFRelease(v15);
      }
      if (v16) {
        CFRelease(v16);
      }
      if (v17) {
        CFRelease(v17);
      }
      return theData;
    }
  }
  return object;
}

kern_return_t IOMasterPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  kern_return_t io_main;
  void block[5];

  host_t v3 = MEMORY[0x18C1311A0](*(void *)&bootstrapPort);
  io_main = host_get_io_main(v3, mainPort);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IOMasterPort_block_invoke;
  block[3] = &__block_descriptor_tmp_0;
  block[4] = mainPort;
  if (IOMasterPort_versionOnce != -1)
  {
    dispatch_once(&IOMasterPort_versionOnce, block);
    if (!v3) {
      return io_main;
    }
    goto LABEL_3;
  }
  if (v3) {
LABEL_3:
  }
    mach_port_deallocate(*MEMORY[0x1E4F14960], v3);
  return io_main;
}

uint64_t io_service_get_matching_service_bin()
{
  unsigned int v0 = MEMORY[0x1F4188790]();
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v8 = 0u;
  *((void *)&v8 + 1) = *MEMORY[0x1E4F14068];
  if (v1 > 0x1000) {
    return 4294966989;
  }
  unsigned int v3 = v1;
  unsigned int v4 = v0;
  __memcpy_chk();
  LODWORD(v9) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 36;
  *(void *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), v4);
  *(void *)&long long v8 = 0xB4000000000;
  uint64_t v5 = mach_msg2_internal();
  uint64_t v2 = v5;
  if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if (v5)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    uint64_t v2 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v2;
}

uint64_t io_registry_entry_from_path(unsigned int a1, const char *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(v9, 0, 480);
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v8 = 0u;
  *((void *)&v8 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 512);
  }
  else {
    int v3 = mig_strncpy((char *)v9 + 8, a2, 512);
  }
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(void *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&long long v8 = 0xAF900000000;
  uint64_t v4 = mach_msg2_internal();
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if (v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    uint64_t v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

uint64_t io_connect_set_properties(unsigned int a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v7 = 1;
  uint64_t v8 = a2;
  int v9 = 0x1000000;
  int v10 = a3;
  uint64_t v11 = *MEMORY[0x1E4F14068];
  int v12 = a3;
  *(void *)&v6.msgh_bits = 0x3880001513;
  *(void *)&v6.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v6.msgh_voucher_port = 0xB0500000000;
  uint64_t v3 = mach_msg2_internal();
  uint64_t v4 = v3;
  if ((v3 - 268435458) <= 0xE && ((1 << (v3 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v6.msgh_local_port);
  }
  else if (v3)
  {
    mig_dealloc_reply_port(v6.msgh_local_port);
  }
  else
  {
    uint64_t v4 = 4294966995;
    mach_msg_destroy(&v6);
  }
  return v4;
}

uint64_t DoIdrefScan(const void *a1, uint64_t a2)
{
  if (!a1) {
    DoIdrefScan_cold_1();
  }
  recordObjectInIDRefDictionary(a1, a2);
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
    if (Count)
    {
      uint64_t v6 = Count;
      size_t v7 = 8 * Count;
      uint64_t v8 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      int v9 = (const void **)malloc_type_malloc(v7, 0x80040B8603338uLL);
      if (!v8) {
        return 0;
      }
      int v10 = v9;
      if (!v9) {
        return 0;
      }
      CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v8, v9);
      if (v6 >= 1)
      {
        for (uint64_t i = 0; i < v6; ++i)
        {
          char v12 = DoIdrefScan(v10[i], a2);
          if ((v12 & 1) == 0) {
            break;
          }
        }
        free(v8);
        free(v10);
        return (v12 & 1) != 0;
      }
      free(v8);
LABEL_30:
      free(v10);
      return 1;
    }
    return 1;
  }
  if (v4 != CFArrayGetTypeID())
  {
    if (v4 != CFSetGetTypeID()) {
      return 1;
    }
    CFIndex v18 = CFSetGetCount((CFSetRef)a1);
    if (!v18) {
      return 1;
    }
    uint64_t v19 = v18;
    long long v20 = (const void **)malloc_type_malloc(8 * v18, 0x80040B8603338uLL);
    if (!v20) {
      return 0;
    }
    int v10 = v20;
    CFSetGetValues((CFSetRef)a1, v20);
    if (v19 >= 1)
    {
      uint64_t v21 = 0;
      do
      {
        int v22 = DoIdrefScan(v10[v21++], a2);
        if (v22) {
          BOOL v23 = v21 < v19;
        }
        else {
          BOOL v23 = 0;
        }
      }
      while (v23);
      int v24 = v22;
      free(v10);
      return v24 != 0;
    }
    goto LABEL_30;
  }
  CFIndex v13 = CFArrayGetCount((CFArrayRef)a1);
  if (v13 < 1) {
    return 1;
  }
  CFIndex v14 = v13;
  for (CFIndex j = 0; j != v14; ++j)
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, j);
    uint64_t result = DoIdrefScan(ValueAtIndex, a2);
    if (!result) {
      break;
    }
  }
  return result;
}

void recordObjectInIDRefDictionary(const void *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      CFDictionaryRef v3 = (const __CFDictionary *)idRefDictionaryForObject(a1, a2);
      if (v3)
      {
        CFTypeID v4 = v3;
        if (CFDictionaryGetValue(v3, a1))
        {
          uint64_t v5 = (const void *)*MEMORY[0x1E4F1CFD0];
          CFDictionarySetValue(v4, a1, v5);
        }
        else
        {
          uint64_t v6 = (const void *)*MEMORY[0x1E4F1CFC8];
          CFDictionaryAddValue(v4, a1, v6);
        }
      }
    }
  }
}

kern_return_t IOObjectRetain(io_object_t object)
{
  kern_return_t result;
  ipc_space_t v4;
  uint64_t vars8;

  uint64_t v2 = (ipc_space_t *)MEMORY[0x1E4F14960];
  uint64_t result = mach_port_mod_refs(*MEMORY[0x1E4F14960], object, 0, 1);
  if (result == 17)
  {
    CFTypeID v4 = *v2;
    return mach_port_mod_refs(v4, object, 4u, 1);
  }
  return result;
}

void DoCFSerializeString(const __CFString *a1, CFMutableDataRef *a2)
{
  if (!previouslySerialized(a1, a2))
  {
    addStartTag(a1, 0, (uint64_t)a2);
    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, 0x3Fu);
    if (ExternalRepresentation)
    {
      CFDataRef v5 = ExternalRepresentation;
      CFIndex Length = CFDataGetLength(ExternalRepresentation);
      BytePtr = CFDataGetBytePtr(v5);
      if (Length >= 1)
      {
        uint64_t v8 = BytePtr;
        do
        {
          int v10 = *(char *)v8++;
          int v9 = v10;
          if (v10 == 38)
          {
            uint64_t v11 = *a2;
            p_UInt8 bytes = "&amp;";
            CFIndex v13 = 5;
          }
          else
          {
            if (v9 == 62)
            {
              uint64_t v11 = *a2;
              p_UInt8 bytes = "&gt;";
            }
            else
            {
              if (v9 != 60)
              {
                UInt8 bytes = v9;
                uint64_t v11 = *a2;
                p_UInt8 bytes = (const char *)&bytes;
                CFIndex v13 = 1;
                goto LABEL_13;
              }
              uint64_t v11 = *a2;
              p_UInt8 bytes = "&lt;";
            }
            CFIndex v13 = 4;
          }
LABEL_13:
          CFDataAppendBytes(v11, (const UInt8 *)p_bytes, v13);
          --Length;
        }
        while (Length);
      }
      CFRelease(v5);
    }
    addEndTag(a1, a2);
  }
}

uint64_t DoCFSerialize(const __CFString *a1, CFMutableDataRef *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    DoCFSerialize_cold_1();
  }
  CFStringRef v3 = a1;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    if (previouslySerialized(v3, a2)) {
      return 1;
    }
    addStartTag(v3, 0, (uint64_t)a2);
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v3);
    if (Count)
    {
      uint64_t v6 = Count;
      uint64_t result = (uint64_t)malloc_type_malloc(16 * Count, 0x80040B8603338uLL);
      if (!result) {
        return result;
      }
      uint64_t v8 = (void *)result;
      CFStringRef v39 = v3;
      CFNumberRef v42 = (const void **)(result + 8 * v6);
      CFDictionaryGetKeysAndValues((CFDictionaryRef)v3, v42, (const void **)result);
      if (v6 >= 1)
      {
        BOOL v9 = 0;
        uint64_t v10 = 0;
        CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberRef v41 = v8;
        while (1)
        {
          CFStringRef v11 = (const __CFString *)v42[v10];
          CFDataAppendBytes(*a2, (const UInt8 *)"<key>", 5);
          CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(alloc, v11, 0x8000100u, 0x3Fu);
          CFDataRef v13 = ExternalRepresentation;
          if (ExternalRepresentation)
          {
            int64_t Length = CFDataGetLength(ExternalRepresentation);
            BytePtr = (const char *)CFDataGetBytePtr(v13);
          }
          else
          {
            int64_t Length = 0;
            BytePtr = "";
          }
          if (!strncmp(BytePtr, "AppleLSIFusionFC", Length))
          {
            BOOL v19 = 1;
          }
          else
          {
            unint64_t v16 = 0;
            do
            {
              unint64_t v17 = v16;
              if (v16 == 6) {
                break;
              }
              int v18 = strncmp(BytePtr, off_1E5489520[v16 + 1], Length);
              unint64_t v16 = v17 + 1;
            }
            while (v18);
            BOOL v19 = v17 < 6;
          }
          if (Length >= 1)
          {
            do
            {
              int v21 = *BytePtr++;
              int v20 = v21;
              if (v21 == 38)
              {
                int v22 = *a2;
                BOOL v23 = "&amp;";
                CFIndex v24 = 5;
              }
              else
              {
                if (v20 == 62)
                {
                  int v22 = *a2;
                  BOOL v23 = "&gt;";
                }
                else
                {
                  if (v20 != 60)
                  {
                    bytes[0] = v20;
                    int v22 = *a2;
                    BOOL v23 = (const char *)bytes;
                    CFIndex v24 = 1;
                    goto LABEL_26;
                  }
                  int v22 = *a2;
                  BOOL v23 = "&lt;";
                }
                CFIndex v24 = 4;
              }
LABEL_26:
              CFDataAppendBytes(v22, (const UInt8 *)v23, v24);
              --Length;
            }
            while (Length);
          }
          if (v13) {
            CFRelease(v13);
          }
          CFDataAppendBytes(*a2, (const UInt8 *)"</key>", 6);
          uint64_t v8 = v41;
          if (v19) {
            CFDataAppendBytes(*a2, (const UInt8 *)"<!--  -->", 13);
          }
          if (!DoCFSerialize(*((void *)v41 + v10), a2)) {
            break;
          }
          BOOL v9 = ++v10 >= v6;
          if (v10 == v6) {
            goto LABEL_69;
          }
        }
        free(v41);
        return v9;
      }
      BOOL v9 = 1;
LABEL_69:
      free(v8);
      CFStringRef v3 = v39;
    }
    else
    {
      BOOL v9 = 1;
    }
    addEndTag(v3, a2);
    return v9;
  }
  if (v4 == CFStringGetTypeID())
  {
    DoCFSerializeString(v3, a2);
    return 1;
  }
  if (v4 == CFArrayGetTypeID())
  {
    if (previouslySerialized(v3, a2)) {
      return 1;
    }
    addStartTag(v3, 0, (uint64_t)a2);
    CFIndex v25 = CFArrayGetCount((CFArrayRef)v3);
    if (v25 < 1) {
      goto LABEL_84;
    }
    CFIndex v26 = v25;
    for (CFIndex i = 0; i < v26; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, i);
      uint64_t result = DoCFSerialize(ValueAtIndex, a2);
      if (!result) {
        break;
      }
    }
    if (result) {
      goto LABEL_84;
    }
    return result;
  }
  if (v4 == CFNumberGetTypeID())
  {
    if (previouslySerialized(v3, a2)) {
      return 1;
    }
    uint64_t valuePtr = 0;
    uint64_t result = CFNumberGetValue((CFNumberRef)v3, kCFNumberLongLongType, &valuePtr);
    if (!result) {
      return result;
    }
    unint64_t v29 = CFNumberGetType((CFNumberRef)v3) - 1;
    if (v29 <= 8 && ((0x1C7u >> v29) & 1) != 0)
    {
      snprintf((char *)bytes, 0x20uLL, "size=\"%d\"", dword_18B50B940[v29]);
      addStartTag(v3, (uint64_t)bytes, (uint64_t)a2);
      snprintf((char *)bytes, 0x20uLL, "0x%lx");
    }
    else
    {
      snprintf((char *)bytes, 0x20uLL, "size=\"%d\"", 64);
      addStartTag(v3, (uint64_t)bytes, (uint64_t)a2);
      snprintf((char *)bytes, 0x20uLL, "0x%qx");
    }
    size_t v37 = strlen((const char *)bytes);
    long long v38 = *a2;
    goto LABEL_83;
  }
  if (v4 == CFDataGetTypeID())
  {
    if (previouslySerialized(v3, a2)) {
      return 1;
    }
    CFIndex v30 = CFDataGetLength((CFDataRef)v3);
    long long v31 = CFDataGetBytePtr((CFDataRef)v3);
    addStartTag(v3, 0, (uint64_t)a2);
    if (v30 < 1) {
      goto LABEL_84;
    }
    unint64_t v32 = 0;
    CFIndex v33 = v30;
    while (1)
    {
      unint64_t v34 = v32 % 3;
      if (v32 % 3 == 2) {
        break;
      }
      if (v34 == 1)
      {
        unint64_t v35 = ((unint64_t)(*v31 | (*(v31 - 1) << 8)) >> 4) & 0x3F;
        goto LABEL_61;
      }
      if (!v34)
      {
        unint64_t v35 = (unint64_t)*v31 >> 2;
LABEL_61:
        bytes[0] = __CFPLDataEncodeTable[v35];
        CFDataAppendBytes(*a2, bytes, 1);
      }
      ++v32;
      ++v31;
      if (!--v33)
      {
        if (v30 % 3uLL != 2)
        {
          if (v30 % 3uLL == 1)
          {
            bytes[0] = __CFPLDataEncodeTable[16 * (*(v31 - 1) & 3)];
            CFDataAppendBytes(*a2, bytes, 1);
            bytes[0] = 61;
            CFDataAppendBytes(*a2, bytes, 1);
            bytes[0] = 61;
            goto LABEL_82;
          }
LABEL_84:
          addEndTag(v3, a2);
          return 1;
        }
        bytes[0] = __CFPLDataEncodeTable[4 * (*(v31 - 1) & 0xF)];
        CFDataAppendBytes(*a2, bytes, 1);
        bytes[0] = 61;
LABEL_82:
        long long v38 = *a2;
        size_t v37 = 1;
LABEL_83:
        CFDataAppendBytes(v38, bytes, v37);
        goto LABEL_84;
      }
    }
    bytes[0] = __CFPLDataEncodeTable[((unint64_t)(*v31 | (*(v31 - 1) << 8)) >> 6) & 0x3F];
    CFDataAppendBytes(*a2, bytes, 1);
    unint64_t v35 = *v31 & 0x3F;
    goto LABEL_61;
  }
  if (v4 == CFBooleanGetTypeID())
  {
    DoCFSerializeBoolean((const __CFBoolean *)v3, a2);
    return 1;
  }
  if (v4 == CFSetGetTypeID())
  {
    return DoCFSerializeSet(v3, a2);
  }
  else
  {
    uint64_t result = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<string>typeID 0x%x not serializable</string>", v4);
    if (result)
    {
      long long v36 = (const void *)result;
      DoCFSerializeString((const __CFString *)result, a2);
      CFRelease(v36);
      return 1;
    }
  }
  return result;
}

void addStartTag(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Value = (const __CFDictionary *)idRefDictionaryForObject(a1, a3);
  size_t v7 = Value;
  if (Value) {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a1);
  }
  if (Value == (const __CFDictionary *)*MEMORY[0x1E4F1CFD0])
  {
    int v8 = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = v8 + 1;
    int valuePtr = v8;
    CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    if (!v9) {
      addStartTag_cold_1();
    }
    CFNumberRef v10 = v9;
    CFDictionarySetValue(v7, a1, v9);
    CFRelease(v10);
    getTagString(a1);
    if (a2) {
      snprintf(__str, 0x80uLL, "<%s ID=\"%d\" %s>");
    }
    else {
      snprintf(__str, 0x80uLL, "<%s ID=\"%d\">");
    }
  }
  else
  {
    getTagString(a1);
    if (a2) {
      snprintf(__str, 0x80uLL, "<%s %s>");
    }
    else {
      snprintf(__str, 0x80uLL, "<%s>");
    }
  }
  size_t v11 = strlen(__str);
  CFDataAppendBytes(*(CFMutableDataRef *)a3, (const UInt8 *)__str, v11);
}

const char *getTagString(const void *a1)
{
  if (!a1) {
    getTagString_cold_1();
  }
  CFTypeID v1 = CFGetTypeID(a1);
  if (v1 == CFStringGetTypeID()) {
    return "string";
  }
  if (v1 == CFNumberGetTypeID()) {
    return "integer";
  }
  if (v1 == CFDataGetTypeID()) {
    return "data";
  }
  if (v1 == CFDictionaryGetTypeID()) {
    return "dict";
  }
  if (v1 == CFArrayGetTypeID()) {
    return "array";
  }
  if (v1 == CFSetGetTypeID()) {
    return "set";
  }
  return "internal error";
}

uint64_t previouslySerialized(const void *a1, CFMutableDataRef *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFNullGetTypeID();
  uint64_t result = 0;
  int valuePtr = -1;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = idRefDictionaryForObject(a1, (uint64_t)a2);
      if (result)
      {
        uint64_t result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)result, a1);
        if (result)
        {
          CFNumberRef v5 = (const __CFNumber *)result;
          CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
          if (v6 == CFBooleanGetTypeID() || v6 != CFNumberGetTypeID())
          {
            return 0;
          }
          else
          {
            uint64_t result = CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
            if (result)
            {
              TagString = getTagString(a1);
              snprintf(__str, 0x40uLL, "<%s IDREF=\"%d\"/>", TagString, valuePtr);
              size_t v8 = strlen(__str);
              CFDataAppendBytes(*a2, (const UInt8 *)__str, v8);
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t idRefDictionaryForObject(const void *a1, uint64_t a2)
{
  CFNullGetTypeID();
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    uint64_t v5 = a2 + 40;
    return *(void *)v5;
  }
  if (v4 == CFStringGetTypeID())
  {
    uint64_t v5 = a2 + 16;
    return *(void *)v5;
  }
  if (v4 == CFArrayGetTypeID())
  {
    uint64_t v5 = a2 + 48;
    return *(void *)v5;
  }
  if (v4 == CFNumberGetTypeID())
  {
    uint64_t v5 = a2 + 24;
    return *(void *)v5;
  }
  if (v4 == CFDataGetTypeID())
  {
    uint64_t v5 = a2 + 32;
    return *(void *)v5;
  }
  if (v4 == CFSetGetTypeID())
  {
    uint64_t v5 = a2 + 56;
    return *(void *)v5;
  }
  return 0;
}

void addEndTag(const void *a1, CFMutableDataRef *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  TagString = getTagString(a1);
  snprintf(__str, 0x80uLL, "</%s>", TagString);
  size_t v4 = strlen(__str);
  CFDataAppendBytes(*a2, (const UInt8 *)__str, v4);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return MakeOneStringProp(@"IONameMatch", name);
}

kern_return_t IOConnectCallAsyncScalarMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return IOConnectCallAsyncMethod(connection, selector, wake_port, reference, referenceCnt, input, inputCnt, 0, 0, output, outputCnt, 0, 0);
}

kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  kern_return_t result;
  size_t v28;
  size_t v29;
  unsigned int v30;

  CFDataRef v13 = inputStruct;
  unint64_t v16 = (int *)outputCnt;
  size_t v17 = inputStructCnt;
  CFIndex v30 = 0;
  unint64_t v29 = 0;
  if (inputStructCnt <= 0x1000)
  {
    unsigned int v18 = inputStructCnt;
  }
  else
  {
    LODWORD(inputStruct) = 0;
    unsigned int v18 = 0;
  }
  if (inputStructCnt <= 0x1000) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = (uint64_t)v13;
  }
  if (inputStructCnt <= 0x1000) {
    size_t v17 = 0;
  }
  if (!outputCnt) {
    unint64_t v16 = (int *)&IOConnectCallAsyncMethod_zero;
  }
  if (outputStructCnt)
  {
    __dst = outputStruct;
    if (*outputStructCnt > 0x1000)
    {
      int v21 = outputStruct;
      unint64_t v29 = *outputStructCnt;
      __dst = 0;
    }
    else
    {
      int v21 = 0;
      CFIndex v30 = *outputStructCnt;
    }
  }
  else
  {
    __dst = 0;
    int v21 = 0;
  }
  BOOL v22 = reference == 0;
  BOOL v23 = referenceCnt == 0;
  BOOL v24 = !v22 || !v23;
  if (v22 && v23) {
    uint32_t v25 = 1;
  }
  else {
    uint32_t v25 = referenceCnt;
  }
  if (v24) {
    LODWORD(v26) = reference;
  }
  else {
    CFIndex v26 = &IOConnectCallAsyncMethod_temp_reference;
  }
  uint64_t result = io_connect_async_method(connection, wake_port, (int)v26, v25, selector, (int)input, inputCnt, (int)inputStruct, v18, v19, v17, __dst, (int *)&v30, output, v16, (uint64_t)v21, &v29);
  if (outputStructCnt)
  {
    if (*outputStructCnt > 0x1000) {
      long long v28 = v29;
    }
    else {
      long long v28 = v30;
    }
    *outputStructCnt = v28;
  }
  return result;
}

uint64_t io_connect_async_method(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned int a9, uint64_t a10, uint64_t a11, void *__dst, int *a13, void *a14, int *a15, uint64_t a16, void *a17)
{
  unsigned int v17 = MEMORY[0x1F4188790]();
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  *(_OWORD *)__n = 0u;
  long long v59 = 0u;
  memset(&reply_port, 0, sizeof(reply_port));
  int v56 = 1;
  int v57 = v23;
  HIDWORD(__n[0]) = 1310720;
  __n[1] = *MEMORY[0x1E4F14068];
  if (v18 <= 8)
  {
    BOOL v24 = v22;
    unsigned int v25 = v21;
    CFIndex v26 = v20;
    int v27 = v19;
    unsigned int v28 = v18;
    unsigned int v29 = v17;
    uint64_t v30 = 8 * v18;
    __memcpy_chk();
    LODWORD(v59) = v28;
    long long v31 = (char *)&reply_port + v30;
    *(_DWORD *)((char *)&reply_port + v30 + 52) = v27;
    if (v25 <= 0x10)
    {
      unint64_t v32 = v31 - 64;
      size_t v33 = 8 * v25;
      memcpy(v31 + 60, v26, v33);
      *((_DWORD *)v32 + 30) = v25;
      if (a9 <= 0x1000)
      {
        long long v36 = &v32[v33];
        uint64_t v37 = (a9 + 3) & 0xFFFFFFFC;
        long long v38 = &v36[v37];
        int v39 = v30 + v33 + v37;
        memcpy(v36 + 128, v24, a9);
        *((_DWORD *)v36 + 31) = a9;
        *((void *)v38 + 16) = a10;
        *((void *)v38 + 17) = a11;
        int v40 = *a13;
        if (*a13 >= 0x1000) {
          int v40 = 4096;
        }
        *((_DWORD *)v38 + 36) = v40;
        int v41 = *a15;
        if (*a15 >= 0x10) {
          int v41 = 16;
        }
        *((_DWORD *)v38 + 37) = v41;
        *((void *)v38 + 19) = a16;
        *((void *)v38 + 20) = *a17;
        mach_port_t v42 = mig_get_reply_port();
        reply_port.msgh_bits = -2147478253;
        reply_port.msgh_unsigned int size = v39 + 104;
        *(void *)&reply_port.mach_port_t msgh_remote_port = __PAIR64__(v42, v29);
        *(void *)&reply_port.msgh_voucher_port = 0xB3200000000;
        uint64_t v43 = mach_msg2_internal();
        uint64_t v34 = v43;
        if ((v43 - 268435458) <= 0xE && ((1 << (v43 - 2)) & 0x4003) != 0)
        {
          mig_put_reply_port(reply_port.msgh_local_port);
          return v34;
        }
        if (v43)
        {
          mig_dealloc_reply_port(reply_port.msgh_local_port);
          return v34;
        }
        if (reply_port.msgh_id == 71)
        {
          uint64_t v34 = 4294966988;
        }
        else if (reply_port.msgh_id == 2966)
        {
          if ((reply_port.msgh_bits & 0x80000000) != 0) {
            goto LABEL_31;
          }
          if (reply_port.msgh_size - 4277 <= 0xFFFFEF7E)
          {
            if (reply_port.msgh_remote_port) {
              BOOL v44 = 1;
            }
            else {
              BOOL v44 = LODWORD(__n[0]) == 0;
            }
            if (!v44 && reply_port.msgh_size == 36) {
              uint64_t v34 = LODWORD(__n[0]);
            }
            else {
              uint64_t v34 = 4294966996;
            }
            goto LABEL_32;
          }
          if (reply_port.msgh_remote_port) {
            goto LABEL_31;
          }
          uint64_t v34 = LODWORD(__n[0]);
          if (LODWORD(__n[0])) {
            goto LABEL_32;
          }
          int v46 = HIDWORD(__n[0]);
          if (HIDWORD(__n[0]) > 0x1000)
          {
LABEL_31:
            uint64_t v34 = 4294966996;
          }
          else
          {
            uint64_t v34 = 4294966996;
            if (reply_port.msgh_size - 52 >= HIDWORD(__n[0]))
            {
              unsigned int v47 = (HIDWORD(__n[0]) + 3) & 0xFFFFFFFC;
              if (reply_port.msgh_size >= v47 + 52)
              {
                long long v48 = (char *)&reply_port + v47;
                mach_msg_size_t v49 = *((_DWORD *)v48 + 10);
                if (v49 <= 0x10 && v49 <= (reply_port.msgh_size - v47 - 52) >> 3)
                {
                  unsigned int v50 = 8 * v49;
                  if (reply_port.msgh_size - v47 == 8 * v49 + 52)
                  {
                    size_t v51 = *a13;
                    if (HIDWORD(__n[0]) <= v51)
                    {
                      CFIndex v52 = v48 - 4096;
                      memcpy(__dst, &__n[1], HIDWORD(__n[0]));
                      *a13 = v46;
                      unsigned int v53 = *((_DWORD *)v52 + 1034);
                      size_t v54 = v52 + 4140;
                      if (v53 <= *a15)
                      {
                        memcpy(a14, v54, 8 * v53);
                        uint64_t v34 = 0;
                        *a15 = *((_DWORD *)v52 + 1034);
                        *a17 = *(void *)&v52[v50 + 4140];
                        return v34;
                      }
                      memcpy(a14, v54, (8 * *a15));
                      *a15 = *((_DWORD *)v52 + 1034);
                    }
                    else
                    {
                      memcpy(__dst, &__n[1], v51);
                      *a13 = v46;
                    }
                    return 4294966989;
                  }
                }
              }
            }
          }
        }
        else
        {
          uint64_t v34 = 4294966995;
        }
LABEL_32:
        mach_msg_destroy(&reply_port);
        return v34;
      }
    }
  }
  return 4294966989;
}

uint64_t IOHIDEventSetTimeStamp(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (dynLinkrosetta_is_current_process_translated_0[0])
  {
    uint64_t result = dynLinkrosetta_is_current_process_translated_0[0]();
    if (result)
    {
      if (dynLinkrosetta_convert_to_system_absolute_time_0[0])
      {
        uint64_t result = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(a2);
        a2 = result;
      }
    }
  }
  *(void *)(v3 + 8) = a2;
  *(_DWORD *)(v3 + 32) &= ~0x80u;
  return result;
}

uint64_t IOHIDServiceClientCopyEvent(uint64_t *a1, int a2, const __CFData *a3, int a4)
{
  return _IOHIDEventSystemClientCopyEventForService(a1[1], (IOHIDServiceClientRef)a1, a2, a3, a4);
}

uint64_t IOHIDServiceClientFastPathCopyEventWithStatus(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 104);
  if (v1 && (uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 64)) != 0) {
    return v2();
  }
  else {
    return 3758097095;
  }
}

uint64_t __IOHIDEventSystemClientSetDispatchQueue_block_invoke_2(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (a2 == 8)
  {
    dispatch_release(*(dispatch_object_t *)(*(void *)(result + 32) + 72));
    *(void *)(*(void *)(v2 + 32) + 72) = 0;
    size_t v4 = *(const void **)(v2 + 32);
    return _IOHIDObjectInternalRelease(v4);
  }
  else if (a2 == 2)
  {
    uint64_t msg = dispatch_mach_msg_get_msg();
    return __IOHIDEventSystemClientTerminationCallback(msg, *(void *)(v2 + 32), 0);
  }
  return result;
}

kern_return_t IOCreateReceivePort(uint32_t msgType, mach_port_t *recvPort)
{
  if (msgType == 57 || msgType == 53) {
    return mach_port_allocate(*MEMORY[0x1E4F14960], 1u, recvPort);
  }
  else {
    return -536870206;
  }
}

void *IOHIDServiceCreateRequestTerminationNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  CFNumberRef v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDServiceRequestTerminaitonNotificationRelease, a1, 0, a2, a3, a4);
  if (v9)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 120), v9);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
  }
  return v9;
}

void __IOHIDServiceFilterRelease(void *a1)
{
  uint64_t v2 = a1[3];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  size_t v4 = (const void *)a1[12];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = a1[4];
  if (v5) {
    dispatch_release(v5);
  }
  uint64_t v6 = (const void *)a1[11];
  if (v6) {
    CFRelease(v6);
  }
  size_t v7 = (const void *)a1[10];
  if (v7) {
    CFRelease(v7);
  }
  CFAllocatorRef v8 = (const void *)a1[8];
  if (v8)
  {
    _Block_release(v8);
  }
}

uint64_t IOHIDServiceFilterOpen(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 56);
    if (v2) {
      return v2();
    }
  }
  return result;
}

uint64_t IOHIDServiceFilterClose(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 64);
    if (v2) {
      return v2();
    }
  }
  return result;
}

void __initialSetup_block_invoke_33()
{
}

const void *___iohideventsystem_client_dispatch_notification_results_block_invoke(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t result = CFDictionaryGetValue(theDict, @"ServiceID");
  if (result)
  {
    size_t v4 = result;
    os_unfair_recursive_lock_lock_with_options();
    CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 96), v4);
    os_unfair_recursive_lock_unlock();
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v7 = v6[22];
    if (v7)
    {
      CFAllocatorRef v8 = *(uint64_t (**)(void))(v7 + 16);
      return (const void *)v8();
    }
    else
    {
      CFNumberRef v9 = (uint64_t (*)(uint64_t, uint64_t, const void *))v6[21];
      uint64_t v10 = v6[23];
      uint64_t v11 = v6[24];
      return (const void *)v9(v10, v11, Value);
    }
  }
  return result;
}

uint64_t _IOHIDServiceSetBatchIntervalForClient(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v9, v10);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t v6 = __IOHIDServiceCreateAndCopyConnectionCache(a1, a2);
  if (v6)
  {
    uint64_t v7 = v6;
    IOHIDServiceConnectionCacheSetValueForKey(v6, @"BatchInterval", a3);
    CFRelease(v7);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v9, v10);
    }
  }
  return result;
}

uint64_t _IOHIDServiceSetReportIntervalForClient(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v10, v12);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t v6 = __IOHIDServiceCreateAndCopyConnectionCache(a1, a2);
  if (v6)
  {
    uint64_t v7 = v6;
    IOHIDServiceConnectionCacheSetValueForKey(v6, @"ReportInterval", a3);
    int context = 0;
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v10, v12);
    }
    ++**(_DWORD **)(a1 + 72);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__ConnectionFunctionContainsReportInterval, &context);
    *(_DWORD *)(a1 + 220) = context;
    uint64_t v8 = *(void *)(a1 + 72);
    if (*(_DWORD *)v8)
    {
      --*(_DWORD *)v8;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8))) {
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v10, v12);
      }
    }
    CFRelease(v7);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v10, v12);
    }
  }
  return result;
}

const void *__IOHIDServiceCreateAndCopyConnectionCache(uint64_t a1, const void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v9, v10);
  }
  ++**(_DWORD **)(a1 + 72);
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 240), a2);
  if (Value)
  {
    uint64_t v5 = Value;
    CFRetain(Value);
  }
  else if (_IOHIDEventSystemConnectionIsValid((uint64_t)a2))
  {
    CFGetAllocator((CFTypeRef)a1);
    IOHIDServiceConnectionCacheCreate();
    uint64_t v5 = v6;
    if (v6) {
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 240), a2, v6);
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v7 = *(void *)(a1 + 72);
  if (*(_DWORD *)v7)
  {
    --*(_DWORD *)v7;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v9, v10);
    }
  }
  return v5;
}

void IOHIDServiceConnectionCacheSetValueForKey(void *a1, const void *a2, const void *a3)
{
  if (CFEqual(@"ReportInterval", a2))
  {
    uint64_t v6 = (const void *)a1[3];
    if (v6) {
      CFRelease(v6);
    }
    if (a3) {
      CFTypeRef v7 = CFRetain(a3);
    }
    else {
      CFTypeRef v7 = 0;
    }
    a1[3] = v7;
  }
  else if (CFEqual(@"BatchInterval", a2))
  {
    uint64_t v8 = (const void *)a1[4];
    if (v8) {
      CFRelease(v8);
    }
    if (a3) {
      CFTypeRef v9 = CFRetain(a3);
    }
    else {
      CFTypeRef v9 = 0;
    }
    a1[4] = v9;
  }
  else
  {
    CFMutableDataRef Mutable = (__CFDictionary *)a1[5];
    if (Mutable
      || (CFMutableDataRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]), (a1[5] = Mutable) != 0))
    {
      CFDictionarySetValue(Mutable, a2, a3);
    }
  }
}

BOOL _IOHIDEventSystemConnectionIsValid(uint64_t a1)
{
  return *MEMORY[0x1E4F1D260] == a1 || (*(unsigned char *)(a1 + 264) & 1) == 0;
}

double IOHIDServiceConnectionCacheCreate()
{
  IOHIDServiceConnectionCacheGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    double result = 0.0;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  return result;
}

uint64_t IOHIDServiceConnectionCacheGetTypeID()
{
  uint64_t result = __serviceConnectionCacheTypeID;
  if (!__serviceConnectionCacheTypeID)
  {
    if (__serviceConnectionCacheTypeInit != -1) {
      dispatch_once(&__serviceConnectionCacheTypeInit, &__block_literal_global_1);
    }
    return __serviceConnectionCacheTypeID;
  }
  return result;
}

uint64_t _IOHIDEventSystemClientCopyEventForService(uint64_t a1, IOHIDServiceClientRef service, int a3, const __CFData *a4, int a5)
{
  uint64_t v5 = 0;
  if (a1 && service)
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFTypeRef RegistryID = IOHIDServiceClientGetRegistryID(service);
    CFDataRef v12 = (const __CFData *)_IOHIDCreateBinaryData(v10, RegistryID);
    if (v12)
    {
      CFDataRef v13 = v12;
      unint64_t v32 = 0;
      unsigned int v31 = 0;
      BytePtr = CFDataGetBytePtr(v12);
      int Length = CFDataGetLength(v13);
      if (a4)
      {
        DataInternal = IOHIDEventCreateDataInternal(v10, (uint64_t)a4);
        if (DataInternal)
        {
          unint64_t v16 = DataInternal;
          CFDataRef v17 = (const __CFData *)_IOHIDCreateBinaryData(v10, DataInternal);
          a4 = v17;
          if (v17)
          {
            unsigned int v18 = CFDataGetBytePtr(v17);
            int v19 = CFDataGetLength(a4);
          }
          else
          {
            unsigned int v18 = 0;
            int v19 = 0;
          }
          CFRelease(v16);
LABEL_13:
          os_unfair_recursive_lock_lock_with_options();
          uint64_t v20 = io_hideventsystem_copy_event_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, a3, (uint64_t)v18, v19, a5, &v32, &v31);
          unsigned int v21 = BytePtr;
          int v22 = v20;
          if (v20 == 268435459)
          {
            if (*(void *)(a1 + 384) || *(void *)(a1 + 400))
            {
              os_unfair_recursive_lock_unlock();
              goto LABEL_19;
            }
            uint64_t v23 = (uint64_t)v21;
            __IOHIDEventSystemClientTerminationCallback(v20, a1, 0);
            int v22 = io_hideventsystem_copy_event_for_service(*(_DWORD *)(a1 + 32), v23, Length, a3, (uint64_t)v18, v19, a5, &v32, &v31);
          }
          os_unfair_recursive_lock_unlock();
          if (!v22)
          {
            unsigned int v25 = v32;
            mach_vm_size_t v26 = v31;
            CFTypeID TypeID = CFDataGetTypeID();
            unsigned int v28 = _IOHIDUnserializeAndVMDeallocWithTypeID(v25, v26, TypeID);
            if (v28)
            {
              unsigned int v29 = v28;
              uint64_t v5 = IOHIDEventCreateWithDataInternal(v10, v28);
              CFRelease(v29);
              if (!a4) {
                goto LABEL_21;
              }
              goto LABEL_20;
            }
          }
LABEL_19:
          uint64_t v5 = 0;
          if (!a4)
          {
LABEL_21:
            CFRelease(v13);
            return v5;
          }
LABEL_20:
          CFRelease(a4);
          goto LABEL_21;
        }
        a4 = 0;
      }
      unsigned int v18 = 0;
      int v19 = 0;
      goto LABEL_13;
    }
    return 0;
  }
  return v5;
}

uint64_t io_hideventsystem_copy_event_for_service(mach_port_t a1, uint64_t a2, int a3, int a4, uint64_t a5, int a6, int a7, void *a8, _DWORD *a9)
{
  int v17 = 2;
  uint64_t v18 = a2;
  int v19 = 16777472;
  int v20 = a3;
  uint64_t v21 = a5;
  int v22 = 16777472;
  int v23 = a6;
  uint64_t v24 = *MEMORY[0x1E4F14068];
  int v25 = a3;
  int v26 = a4;
  int v27 = a6;
  int v28 = a7;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x1117700000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v12 = mach_msg(&msg, 3162115, 0x54u, 0x40u, special_reply_port, 0, 0);
  uint64_t v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!v12)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v13 = 4294966988;
      }
      else if (msg.msgh_id == 70107)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            uint64_t v13 = 4294966996;
            if (HIDWORD(v18))
            {
              if (msg.msgh_remote_port) {
                uint64_t v13 = 4294966996;
              }
              else {
                uint64_t v13 = HIDWORD(v18);
              }
            }
          }
          else
          {
            uint64_t v13 = 4294966996;
          }
          goto LABEL_27;
        }
        uint64_t v13 = 4294966996;
        if (v17 == 1 && msg.msgh_size == 56 && !msg.msgh_remote_port && HIBYTE(v19) == 1)
        {
          int v14 = v20;
          if (v20 == v22)
          {
            uint64_t v13 = 0;
            *a8 = v18;
            *a9 = v14;
            return v13;
          }
        }
      }
      else
      {
        uint64_t v13 = 4294966995;
      }
LABEL_27:
      mach_msg_destroy(&msg);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v13 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    goto LABEL_27;
  }
  return v13;
}

uint64_t _Xio_hideventsystem_copy_event_for_service(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 84)
  {
    int v3 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_12;
  }
  if (*(unsigned char *)(result + 39) != 1
    || *(unsigned char *)(result + 55) != 1
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 68)
    || *(_DWORD *)(result + 56) != *(_DWORD *)(result + 76))
  {
    int v3 = -300;
    goto LABEL_11;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = _io_hideventsystem_copy_event_for_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(unsigned int *)(result + 40), *(unsigned int *)(result + 72), *(UInt8 **)(result + 44), *(_DWORD *)(result + 56), *(unsigned int *)(result + 80), (vm_offset_t *)(a2 + 28), (_DWORD *)(a2 + 52));
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_12:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t _io_hideventsystem_copy_event_for_service(unsigned int a1, UInt8 *bytes, CFIndex length, uint64_t a4, UInt8 *a5, unsigned int a6, uint64_t a7, vm_offset_t *a8, _DWORD *a9)
{
  *a9 = 0;
  CFPropertyListRef v15 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  CFTypeID TypeID = CFDataGetTypeID();
  int v17 = _IOHIDUnserializeAndVMDeallocWithTypeID(a5, a6, TypeID);
  if (v15)
  {
    uint64_t v18 = IOMIGMachPortCacheCopy(a1);
    int v19 = v18;
    if (v18 && (CFTypeID v20 = CFGetTypeID(v18), v20 == IOHIDEventSystemConnectionGetTypeID()))
    {
      if (v17)
      {
        CFAllocatorRef v21 = CFGetAllocator(v19);
        int v22 = (const void *)IOHIDEventCreateWithDataInternal(v21, v17);
      }
      else
      {
        int v22 = 0;
      }
      if (IOHIDEventSystemConnectionGetType((uint64_t)v19) == 2
        || IOHIDEventSystemConnectionGetType((uint64_t)v19) == 4
        || (uint64_t System = _IOHIDEventSystemConnectionGetSystem((uint64_t)v19)) == 0)
      {
        int v25 = 0;
        if (v22) {
LABEL_16:
        }
          CFRelease(v22);
      }
      else
      {
        uint64_t v24 = IOHIDEventSystemCopyService(System, v15);
        int v25 = v24;
        if (v24)
        {
          uint64_t v26 = IOHIDServiceCopyEvent((uint64_t)v24, a4, (uint64_t)v22, a7);
          if (v26)
          {
            int v27 = (const void *)v26;
            CFAllocatorRef v28 = CFGetAllocator(v19);
            DataInternal = IOHIDEventCreateDataInternal(v28, (uint64_t)v27);
            if (DataInternal)
            {
              uint64_t v30 = DataInternal;
              *a9 = _IOHIDSerialize(DataInternal, a8);
              CFRelease(v30);
            }
            CFRelease(v27);
          }
        }
        if (v22) {
          goto LABEL_16;
        }
      }
    }
    else
    {
      int v25 = 0;
    }
  }
  else
  {
    int v25 = 0;
    int v19 = 0;
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v19) {
    CFRelease(v19);
  }
  return 0;
}

uint64_t IOHIDServiceCopyEventForClient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2000000000;
  uint64_t v32 = 0;
  uint64_t v10 = mach_absolute_time();
  *(void *)&valuePtr[0] = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, valuePtr);
  _IOHIDDebugTrace(8263, 1, *(uint64_t *)&valuePtr[0], a2, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v28, valuePtr);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(uint64_t (**)(void))(*(void *)v11 + 88);
    if (v12)
    {
      id v13 = (id)v12();
LABEL_11:
      v30[3] = (uint64_t)v13;
      goto LABEL_12;
    }
  }
  uint64_t v14 = *(void *)(a1 + 360);
  if (v14)
  {
    CFPropertyListRef v15 = *(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(v14 + 64);
    if (v15)
    {
      id v13 = (id)v15(*(void *)(a1 + 344), *(void *)(a1 + 352), a2, a3, a4);
      goto LABEL_11;
    }
  }
  unint64_t v16 = *(void **)(a1 + 480);
  if (v16)
  {
    int v17 = *(const char **)(a1 + 568);
    if (v17)
    {
      id v13 = objc_msgSend(v16, v17, a2, a3, a4);
      goto LABEL_11;
    }
  }
LABEL_12:
  uint64_t v18 = *(void *)(a1 + 72);
  if (*(_DWORD *)v18)
  {
    --*(_DWORD *)v18;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v28, valuePtr);
    }
  }
  uint64_t v19 = v30[3];
  if (v19)
  {
    if (!IOHIDEventGetSenderID(v19))
    {
      CFNumberRef v20 = *(const __CFNumber **)(a1 + 48);
      *(void *)&valuePtr[0] = 0;
      if (v20)
      {
        CFNumberGetValue(v20, kCFNumberSInt64Type, valuePtr);
        uint64_t v21 = *(void *)&valuePtr[0];
      }
      else
      {
        uint64_t v21 = 0;
      }
      IOHIDEventSetSenderID(v30[3], v21);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v28, valuePtr);
    }
    ++**(_DWORD **)(a1 + 72);
    CFArrayRef v22 = *(const __CFArray **)(a1 + 248);
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 0x40000000;
    v27[2] = __IOHIDServiceCopyEventForClient_block_invoke;
    v27[3] = &unk_1E548A480;
    v27[4] = &v29;
    _OWORD v27[5] = a5;
    _IOHIDCFArrayApplyBlock(v22, v27);
    uint64_t v23 = *(void *)(a1 + 72);
    if (*(_DWORD *)v23)
    {
      --*(_DWORD *)v23;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8))) {
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v28, valuePtr);
      }
    }
  }
  *(void *)&valuePtr[0] = 0;
  CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, valuePtr);
  _IOHIDDebugTrace(8263, 2, *(uint64_t *)&valuePtr[0], a2, 0, 0);
  uint64_t v24 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v24, v10, 0x3E8u);
  if (*(void *)(a1 + 464)) {
    IOHIDAnalyticsEventSetIntegerValueForField();
  }
  uint64_t v25 = v30[3];
  _Block_object_dispose(&v29, 8);
  return v25;
}

uint64_t IOHIDServiceCopyEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return IOHIDServiceCopyEventForClient(a1, a2, a3, a4, 0);
}

uint64_t _iohideventsystem_copy_event_from_virtual_service(unsigned int a1, const void *a2, uint64_t a3, UInt8 *a4, unsigned int a5, uint64_t a6, vm_offset_t *a7, _DWORD *a8)
{
  mach_vm_size_t v15 = a5;
  CFTypeID TypeID = CFDataGetTypeID();
  int v17 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, v15, TypeID);
  if (v17) {
    uint64_t v18 = (const void *)IOHIDEventCreateWithDataInternal(*MEMORY[0x1E4F1CF80], v17);
  }
  else {
    uint64_t v18 = 0;
  }
  uint64_t v19 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  CFNumberRef v20 = v19;
  if (!v19) {
    goto LABEL_25;
  }
  CFTypeID v21 = CFGetTypeID(v19);
  uint64_t v22 = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    uint64_t v22 = __kIOHIDEventSystemClientTypeID;
  }
  if (v21 == v22)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFDictionaryRef Value = CFDictionaryGetValue(v20[13], a2);
    if (Value)
    {
      uint64_t v24 = Value;
      CFRetain(Value);
      os_unfair_recursive_lock_unlock();
      uint64_t v25 = (const void *)_IOHIDVirtualServiceClientCopyEvent(v24, a3, (uint64_t)v18, a6);
      if (v25)
      {
        CFAllocatorRef v26 = CFGetAllocator(v24);
        DataInternal = IOHIDEventCreateDataInternal(v26, (uint64_t)v25);
      }
      else
      {
        DataInternal = 0;
      }
      *a8 = _IOHIDSerialize(DataInternal, a7);
      CFRelease(v24);
      if (v25) {
        CFRelease(v25);
      }
      if (DataInternal) {
        CFRelease(DataInternal);
      }
    }
    else
    {
      os_unfair_recursive_lock_unlock();
      uint64_t v28 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        _iohideventsystem_output_event_to_virtual_service_cold_2();
      }
    }
  }
  else
  {
LABEL_25:
    uint64_t v30 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
    }
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v20) {
    CFRelease(v20);
  }
  return 0;
}

uint64_t IOHIDVirtualServiceClientDispatchEvent(__IOHIDServiceClient *a1, uint64_t a2)
{
  uint64_t valuePtr = 0;
  uint64_t EventSystemClient = _IOHIDVirtuaServiceClientGetEventSystemClient((uint64_t)a1);
  CFNumberRef RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(a1);
  CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
  IOHIDEventSetSenderID(a2, valuePtr);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  DataInternal = IOHIDEventCreateDataInternal((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  CFDataRef v8 = (const __CFData *)_IOHIDCreateBinaryData(v6, DataInternal);
  if (!v8)
  {
    int v17 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      IOHIDVirtualServiceClientDispatchEvent_cold_1();
    }
LABEL_5:
    uint64_t v15 = 0;
    if (!DataInternal) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  os_unfair_recursive_lock_lock_with_options();
  int v9 = *(_DWORD *)(EventSystemClient + 32);
  uint64_t v10 = valuePtr;
  BytePtr = CFDataGetBytePtr(v8);
  int Length = CFDataGetLength(v8);
  int v13 = io_hideventsystem_dispatch_event_for_virtual_service(v9, v10, (uint64_t)BytePtr, Length);
  os_unfair_recursive_lock_unlock();
  if (v13)
  {
    uint64_t v14 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      IOHIDVirtualServiceClientDispatchEvent_cold_2();
    }
    goto LABEL_5;
  }
  uint64_t v15 = 1;
  if (DataInternal) {
LABEL_6:
  }
    CFRelease(DataInternal);
LABEL_7:
  if (v8) {
    CFRelease(v8);
  }
  return v15;
}

uint64_t IOHIDEventSetSenderID(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t io_hideventsystem_dispatch_event_for_virtual_service(int a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v9 = a3;
  int v10 = 16777472;
  int v11 = a4;
  uint64_t v12 = *MEMORY[0x1E4F14068];
  uint64_t v13 = a2;
  int v14 = a4;
  uint64_t v6 = 2147483667;
  int v7 = a1;
  *(_OWORD *)name = xmmword_18B50C6C0;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set((mach_msg_header_t *)&v6);
  }
  uint64_t v4 = mach_msg((mach_msg_header_t *)&v6, 1, 0x40u, 0, 0, 0, 0);
  if ((v4 - 268435459) <= 1)
  {
    if ((v6 & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], name[0]);
    }
    mach_msg_destroy((mach_msg_header_t *)&v6);
  }
  return v4;
}

uint64_t _Xio_hideventsystem_dispatch_event_for_virtual_service(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 64)
  {
    if (*(unsigned char *)(result + 39) == 1)
    {
      unsigned int v3 = *(_DWORD *)(result + 40);
      if (v3 == *(_DWORD *)(result + 60))
      {
        uint64_t result = _io_hideventsystem_dispatch_event_for_virtual_service(*(_DWORD *)(result + 12), *(const void **)(result + 52), *(UInt8 **)(result + 28), v3);
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
    }
    int v4 = -300;
  }
  else
  {
    int v4 = -304;
  }
  *(_DWORD *)(a2 + 32) = v4;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _io_hideventsystem_dispatch_event_for_virtual_service(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4)
{
  mach_vm_size_t v7 = a4;
  CFTypeID TypeID = CFDataGetTypeID();
  uint64_t v9 = _IOHIDUnserializeAndVMDeallocWithTypeID(a3, v7, TypeID);
  if (v9)
  {
    int v10 = v9;
    int v11 = IOMIGMachPortCacheCopy(a1);
    if (v11)
    {
      uint64_t v12 = v11;
      CFTypeID v13 = CFGetTypeID(v11);
      if (v13 == IOHIDEventSystemConnectionGetTypeID())
      {
        CFAllocatorRef v14 = CFGetAllocator(v12);
        uint64_t v15 = (const void *)IOHIDEventCreateWithDataInternal(v14, v10);
        if (v15)
        {
          unint64_t v16 = v15;
          _IOHIDEventSystemConnectionDispatchEventForVirtualService((uint64_t)v12, a2, v15);
          CFRelease(v16);
        }
      }
      CFRelease(v12);
    }
    CFRelease(v10);
  }
  return 0;
}

__CFData *IOHIDEventCreateCopy(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t result = IOHIDEventCreateDataInternal(a1, a2);
  if (result)
  {
    int v4 = result;
    uint64_t v5 = __IOHIDEventCreateWithDataHelper((uint64_t)a1, result);
    CFRelease(v4);
    return (__CFData *)v5;
  }
  return result;
}

const void *__IOHIDEventCreateWithDataHelper(uint64_t a1, CFDataRef theData)
{
  if (!theData) {
    return 0;
  }
  BytePtr = CFDataGetBytePtr(theData);
  if (!BytePtr) {
    return 0;
  }
  uint64_t v5 = (uint64_t)BytePtr;
  CFIndex Length = CFDataGetLength(theData);
  if (Length < 28) {
    return 0;
  }

  return __IOHIDEventCreateWithBytesHelper(a1, v5, Length);
}

__CFData *IOHIDEventCreateDataInternal(const __CFAllocator *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  LengthAndCFIndex Count = __IOHIDEventGetLengthAndCount(a2, (void *)(a2 + 96));
  if (!LengthAndCount) {
    return 0;
  }
  CFIndex v5 = LengthAndCount + *(void *)(a2 + 88) + 28;
  CFMutableDataRef Mutable = CFDataCreateMutable(a1, v5);
  mach_vm_size_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    __IOHIDEventReadBytesHelper(a2, (uint64_t)MutableBytePtr, v5);
  }
  return v7;
}

uint64_t _IOHIDVirtuaServiceClientGetEventSystemClient(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void _IOHIDEventSystemConnectionDispatchEventForVirtualService(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 272), a2);
  if (Value)
  {
    CFIndex v5 = Value;
    uint64_t v6 = _IOHIDServiceCopyDispatchQueue((uint64_t)Value);
    if (v6)
    {
      mach_vm_size_t v7 = v6;
      CFRetain(v5);
      CFRetain(a3);
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 0x40000000;
      v8[2] = ___IOHIDEventSystemConnectionDispatchEventForVirtualService_block_invoke;
      v8[3] = &__block_descriptor_tmp_136;
      v8[4] = v5;
      void v8[5] = a3;
      dispatch_async(v7, v8);
      dispatch_release(v7);
    }
  }
}

uint64_t _IOHIDServiceCopyDispatchQueue(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 80));
  }
  return v1;
}

uint64_t __IOHIDServiceVirtualCopyEventCallback(uint64_t a1, uint64_t a2, int a3, __CFData *DataInternal, int a5)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t SenderID = _IOHIDServiceGetSenderID(a1);
  uint64_t v28 = 0;
  unsigned int v27 = 0;
  if (DataInternal
    && (CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)a2),
        (DataInternal = IOHIDEventCreateDataInternal(v10, (uint64_t)DataInternal)) != 0))
  {
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a2);
    CFDataRef v12 = (const __CFData *)_IOHIDCreateBinaryData(v11, DataInternal);
  }
  else
  {
    CFDataRef v12 = 0;
  }
  if (*(_DWORD *)(a2 + 448)) {
    goto LABEL_13;
  }
  mach_port_t v13 = *(_DWORD *)(a2 + 40);
  if (v12)
  {
    BytePtr = CFDataGetBytePtr(v12);
    int Length = CFDataGetLength(v12);
  }
  else
  {
    BytePtr = 0;
    int Length = 0;
  }
  int v16 = iohideventsystem_copy_event_from_virtual_service(v13, SenderID, a3, (uint64_t)BytePtr, Length, a5, &v28, &v27, 0x20u);
  if (v16)
  {
    int v17 = v16;
    uint64_t v18 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = *(void *)(a2 + 168);
      *(_DWORD *)buf = 136315650;
      uint64_t v30 = v19;
      __int16 v31 = 2048;
      uint64_t v32 = SenderID;
      __int16 v33 = 1024;
      int v34 = v17;
      _os_log_impl(&dword_18B46C000, v18, OS_LOG_TYPE_INFO, "%s: HIDVS ID:%llx _iohideventsystem_copy_event_from_virtual_service:%x", buf, 0x1Cu);
    }
    __IOHIDEventSystemConnectionCheckServerStatus(v17, a2);
LABEL_13:
    uint64_t v20 = 0;
    if (!DataInternal) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v22 = v28;
  mach_vm_size_t v23 = v27;
  CFTypeID TypeID = CFDataGetTypeID();
  uint64_t v25 = _IOHIDUnserializeAndVMDeallocWithTypeID(v22, v23, TypeID);
  if (!v25) {
    goto LABEL_13;
  }
  CFAllocatorRef v26 = v25;
  uint64_t v20 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E4F1CF80], v25);
  CFRelease(v26);
  if (DataInternal) {
LABEL_14:
  }
    CFRelease(DataInternal);
LABEL_15:
  if (v12) {
    CFRelease(v12);
  }
  return v20;
}

uint64_t iohideventsystem_copy_event_from_virtual_service(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, void *a7, _DWORD *a8, mach_msg_timeout_t a9)
{
  int v18 = 1;
  uint64_t v19 = a4;
  int v20 = 16777472;
  int v21 = a5;
  uint64_t v22 = *MEMORY[0x1E4F14068];
  uint64_t v23 = a2;
  int v24 = a3;
  int v25 = a5;
  int v26 = a6;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x1250100000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v13 = mach_msg(&msg, 3162515, 0x48u, 0x40u, special_reply_port, a9, 0);
  uint64_t v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!v13)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v14 = 4294966988;
      }
      else if (msg.msgh_id == 75109)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            uint64_t v14 = 4294966996;
            if (HIDWORD(v19))
            {
              if (msg.msgh_remote_port) {
                uint64_t v14 = 4294966996;
              }
              else {
                uint64_t v14 = HIDWORD(v19);
              }
            }
          }
          else
          {
            uint64_t v14 = 4294966996;
          }
          goto LABEL_27;
        }
        uint64_t v14 = 4294966996;
        if (v18 == 1 && msg.msgh_size == 56 && !msg.msgh_remote_port && HIBYTE(v20) == 1)
        {
          int v15 = v21;
          if (v21 == v23)
          {
            uint64_t v14 = 0;
            *a7 = v19;
            *a8 = v15;
            return v14;
          }
        }
      }
      else
      {
        uint64_t v14 = 4294966995;
      }
LABEL_27:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v14 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    goto LABEL_27;
  }
  return v14;
}

uint64_t _IOHIDVirtualServiceClientCopyEvent(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1[8];
  if (v4 && (CFIndex v5 = *(uint64_t (**)(void, void, void *, uint64_t, uint64_t, uint64_t))(v4 + 32)) != 0) {
    return v5(a1[9], a1[10], a1, a2, a3, a4);
  }
  else {
    return 0;
  }
}

void __IOMIGMachPortRelease(uint64_t a1)
{
  kern_return_t v5;
  mach_error_t v6;
  NSObject *v7;
  const void *v8;

  uint64_t v2 = *(__CFMachPort **)(a1 + 48);
  if (v2)
  {
    CFMachPortInvalidate(v2);
    ipc_space_t v3 = *MEMORY[0x1E4F14960];
    mach_port_name_t Port = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 48));
    CFIndex v5 = mach_port_mod_refs(v3, Port, 1u, -1);
    if (v5)
    {
      uint64_t v6 = v5;
      if (__IOMIGMachPortLog_onceToken != -1) {
        dispatch_once(&__IOMIGMachPortLog_onceToken, &__block_literal_global_12);
      }
      mach_vm_size_t v7 = __IOMIGMachPortLog_log;
      if (os_log_type_enabled((os_log_t)__IOMIGMachPortLog_log, OS_LOG_TYPE_ERROR)) {
        __IOMIGMachPortRelease_cold_1(v6, v7);
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 48));
  }
  CFDataRef v8 = *(const void **)(a1 + 56);
  if (v8) {
    CFRelease(v8);
  }
  if (*(void *)(a1 + 40))
  {
    dispatch_mach_cancel();
    dispatch_release(*(dispatch_object_t *)(a1 + 40));
    *(void *)(a1 + 40) = 0;
  }
}

uint64_t __IOHIDNotificationRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDNotificationCFTypeID TypeID = result;
  return result;
}

uint64_t __IOHIDEventQueueGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDEventQueueCFTypeID TypeID = result;
  return result;
}

uint64_t IOHIDEventCreateProximtyProbabilityEvent(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5)
{
  uint64_t result = IOHIDEventCreate(a1, 14, a2, a5 | 1u);
  if (result)
  {
    uint64_t v8 = *(void *)(result + 104);
    *(_WORD *)(v8 + 16) = a3;
    *(_WORD *)(v8 + 18) = 1;
    *(_DWORD *)(v8 + 20) = a4;
  }
  return result;
}

uint64_t IOHIDEventCreateProximtyEvent(uint64_t a1, uint64_t a2, __int16 a3, int a4)
{
  uint64_t result = IOHIDEventCreate(a1, 14, a2, a4 | 1u);
  if (result)
  {
    uint64_t v6 = *(void *)(result + 104);
    *(_WORD *)(v6 + 16) = a3;
    *(_WORD *)(v6 + 18) = 0;
  }
  return result;
}

uint64_t __IOHIDServiceNotification(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  uint64_t v4 = result;
  _IOHIDDebugTrace(8260, 0, result, a3, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(v4 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v16, v17);
  }
  ++**(_DWORD **)(v4 + 72);
  switch(a3)
  {
    case 0xE0000010:
      CFIndex Count = CFSetGetCount(*(CFSetRef *)(v4 + 104));
      __IOHIDServiceCompleteInProgressEvents((CFTypeRef *)v4);
      *(_DWORD *)(v4 + 224) |= 1u;
      if (Count)
      {
        CFAllocatorRef v11 = CFGetAllocator(*(CFTypeRef *)(v4 + 104));
        CFSetRef Copy = CFSetCreateCopy(v11, *(CFSetRef *)(v4 + 104));
        if (Copy)
        {
          CFSetRef v13 = Copy;
          CFRetain((CFTypeRef)v4);
          global_queue = dispatch_get_global_queue(0, 0);
          v14[0] = MEMORY[0x1E4F143A8];
          v14[1] = 0x40000000;
          _DWORD v14[2] = ____IOHIDServiceNotification_block_invoke_2;
          v14[3] = &__block_descriptor_tmp_272;
          v14[4] = v13;
          v14[5] = v4;
          uint64_t v9 = v14;
          goto LABEL_12;
        }
      }
      break;
    case 0xE0000100:
      __IOHIDServiceCompleteInProgressEvents((CFTypeRef *)v4);
      break;
    case 0xE0000130:
      if (CFSetGetCount(*(CFSetRef *)(v4 + 112)))
      {
        CFAllocatorRef v5 = CFGetAllocator(*(CFTypeRef *)(v4 + 112));
        CFSetRef v6 = CFSetCreateCopy(v5, *(CFSetRef *)(v4 + 112));
        if (v6)
        {
          CFSetRef v7 = v6;
          CFRetain((CFTypeRef)v4);
          global_queue = dispatch_get_global_queue(0, 0);
          v15[0] = MEMORY[0x1E4F143A8];
          v15[1] = 0x40000000;
          v15[2] = ____IOHIDServiceNotification_block_invoke;
          v15[3] = &__block_descriptor_tmp_271;
          v15[4] = v7;
          _OWORD v15[5] = v4;
          uint64_t v9 = v15;
LABEL_12:
          dispatch_async(global_queue, v9);
        }
      }
      break;
  }
  uint64_t result = *(void *)(v4 + 72);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v16, v17);
    }
  }
  return result;
}

void __IOHIDServiceCompleteInProgressEvents(CFTypeRef *cf)
{
  if (*((_DWORD *)cf + 72))
  {
    CFAllocatorRef v2 = CFGetAllocator(cf);
    uint64_t v3 = mach_absolute_time();
    uint64_t ScrollEvent = IOHIDEventCreateScrollEvent((uint64_t)v2, v3, 0x800000, 0.0, 0.0, 0.0);
    if (ScrollEvent)
    {
      CFAllocatorRef v5 = (void *)ScrollEvent;
      IOHIDEventSetScrollMomentum(ScrollEvent, 4);
      __IOHIDServiceEventCallback((uint64_t)cf, v6, v7, v5);
      CFRelease(v5);
    }
  }
  if (*((_DWORD *)cf + 73))
  {
    CFAllocatorRef v8 = CFGetAllocator(cf);
    uint64_t v9 = mach_absolute_time();
    DigitizerEvent = IOHIDEventCreateDigitizerEvent((uint64_t)v8, v9, 0, 0, 0, 8, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0x800000);
    if (DigitizerEvent)
    {
      CFSetRef v13 = DigitizerEvent;
      __IOHIDServiceEventCallback((uint64_t)cf, v11, v12, DigitizerEvent);
      CFRelease(v13);
    }
  }
  CFAllocatorRef v14 = CFGetAllocator(cf[33]);
  CFSetRef Copy = CFSetCreateCopy(v14, (CFSetRef)cf[33]);
  if (Copy)
  {
    CFSetRef v16 = Copy;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDServiceCompleteEventsInProgressApplier, cf);
    CFRelease(v16);
  }
  if (cf[34])
  {
    for (uint64_t i = 0; i != 64; ++i)
    {
      if (((unint64_t)cf[34] >> i))
      {
        CFAllocatorRef v18 = CFGetAllocator(cf);
        uint64_t v19 = mach_absolute_time();
        int v20 = (void *)IOHIDEventCreate((uint64_t)v18, i, v19, 0x800000);
        if (v20)
        {
          uint64_t v23 = v20;
          __IOHIDServiceEventCallback((uint64_t)cf, v21, v22, v20);
          CFRelease(v23);
        }
      }
    }
  }
  CFAllocatorRef v24 = CFGetAllocator(cf);
  uint64_t v25 = mach_absolute_time();
  int v26 = (void *)IOHIDEventCreate((uint64_t)v24, 0, v25, 0x800000);
  if (v26)
  {
    uint64_t v29 = v26;
    __IOHIDServiceEventCallback((uint64_t)cf, v27, v28, v26);
    CFRelease(v29);
  }
}

void *IOHIDEventCreateDigitizerFingerEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13)
{
  return IOHIDEventCreateDigitizerFingerEventWithQuality(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, 5.0, 5.0, 1.0, 1.0, 1.0);
}

void *IOHIDEventCreateDigitizerFingerEventWithQuality(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, double a17, double a18)
{
  DigitizerEvent = IOHIDEventCreateDigitizerEvent(a1, a2, 2, a3, a4, a5, 0, a6, a9, a10, a11, a12, a13, a7, a8);
  uint64_t v22 = DigitizerEvent;
  if (DigitizerEvent)
  {
    *(_DWORD *)(DigitizerEvent[13] + 64) = 2;
    IOHIDEventSetFloatValueWithOptions(DigitizerEvent, 0xB0011u, 4026531840, a16);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0012u, 4026531840, a17);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0013u, 4026531840, a18);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0014u, 4026531840, a15);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0015u, 4026531840, a14);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB001Au, 4026531840, 0.0);
  }
  return v22;
}

void *IOHIDEventSetFloatValueWithOptions(void *result, unsigned int a2, uint64_t a3, double a4)
{
  unsigned int v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (uint64_t result = (void *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a3)) != 0)
  {
    uint64_t v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFE | (a4 != 0.0);
            goto LABEL_168;
          case 1u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFD | (2 * (a4 != 0.0));
            goto LABEL_168;
          case 2u:
            goto LABEL_23;
          case 3u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xF7 | (8 * (a4 != 0.0));
            goto LABEL_168;
          case 4u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xEF | (16 * (a4 != 0.0));
            goto LABEL_168;
          case 5u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xDF | (32 * (a4 != 0.0));
            goto LABEL_168;
          case 6u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xBF | ((a4 != 0.0) << 6);
            goto LABEL_168;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10002u:
            unsigned int v16 = a4;
            goto LABEL_158;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x10000u:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_139;
          case 0x20001u:
            goto LABEL_130;
          case 0x20002u:
            goto LABEL_131;
          case 0x20003u:
            goto LABEL_154;
          case 0x20004u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_113;
          case 0x30001u:
            goto LABEL_120;
          case 0x30002u:
            goto LABEL_157;
          case 0x30003u:
            goto LABEL_170;
          case 0x30004u:
            *(unsigned char *)(v7 + 28) = (int)a4;
            return result;
          case 0x30005u:
            unsigned int v13 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a4 != 0.0);
            goto LABEL_148;
          case 0x30006u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a4 & 3));
            goto LABEL_181;
          case 0x30007u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a4 & 3));
            goto LABEL_181;
          case 0x30008u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a4 != 0.0));
            goto LABEL_181;
          case 0x30009u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a4 & 7) << 6);
            goto LABEL_181;
          case 0x3000Au:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a4 & 3) << 9);
LABEL_181:
            *(_DWORD *)(v7 + 24) = v21;
            break;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146) {
          goto LABEL_147;
        }
        if (a2 == 262145) {
          goto LABEL_154;
        }
        if (a2 != 0x40000) {
          return result;
        }
        goto LABEL_69;
      case 5u:
        if (a2 == 327682) {
          goto LABEL_147;
        }
        if (a2 == 327681) {
          goto LABEL_154;
        }
        if (a2 != 327680) {
          return result;
        }
        goto LABEL_69;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_69;
          case 0x60001u:
            goto LABEL_154;
          case 0x60002u:
            goto LABEL_147;
          case 0x60003u:
LABEL_23:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFB | (4 * (a4 != 0.0));
LABEL_168:
            *(unsigned char *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
            goto LABEL_147;
          case 0x70001u:
            goto LABEL_154;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_147:
          unsigned int v13 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_148;
        }
        if (a2 == 589825) {
          goto LABEL_154;
        }
        if (a2 != 589824) {
          return result;
        }
        goto LABEL_69;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_147;
                case 0xA0001u:
                  goto LABEL_154;
                case 0xA0000u:
                  goto LABEL_69;
              }
              break;
            case 1:
              if (a2 == 655364) {
                goto LABEL_139;
              }
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_147;
                case 0xA0006u:
                  goto LABEL_154;
                case 0xA0005u:
                  goto LABEL_69;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_69;
                case 0xA0009u:
                  goto LABEL_154;
                case 0xA000Au:
                  goto LABEL_147;
                case 0xA000Bu:
                  goto LABEL_95;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_154;
          case 0xB0002u:
            goto LABEL_147;
          case 0xB0003u:
            goto LABEL_171;
          case 0xB0004u:
            goto LABEL_121;
          case 0xB0005u:
            goto LABEL_114;
          case 0xB0006u:
            goto LABEL_128;
          case 0xB0007u:
            goto LABEL_172;
          case 0xB0008u:
LABEL_170:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a4 != 0.0) << 16);
            goto LABEL_217;
          case 0xB0009u:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a4 != 0.0) << 17);
            goto LABEL_217;
          case 0xB000Au:
            goto LABEL_189;
          case 0xB000Bu:
            goto LABEL_190;
          case 0xB000Cu:
            goto LABEL_215;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            int v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_186;
                  case 0xB0012u:
                    goto LABEL_187;
                  case 0xB0013u:
                    goto LABEL_196;
                  case 0xB0014u:
                    goto LABEL_197;
                  case 0xB0015u:
LABEL_224:
                    *(_DWORD *)(v7 + 84) = vcvtd_n_s64_f64(a4, 0x10uLL);
                    break;
                  case 0xB001Au:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_186;
                  case 0xB0010u:
                    goto LABEL_187;
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_197;
                  case 0xB0014u:
                    goto LABEL_224;
                  case 0xB0015u:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910) {
              goto LABEL_187;
            }
            if (a2 != 720909) {
              return result;
            }
            goto LABEL_186;
          case 0xB0016u:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a4 != 0.0));
            goto LABEL_217;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32)) {
              goto LABEL_215;
            }
            return result;
          case 0xB0018u:
            goto LABEL_169;
          case 0xB0019u:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a4 != 0.0) << 19);
LABEL_217:
            *(_DWORD *)(v7 + 8) = v19;
            return result;
          case 0xB001Bu:
            unsigned int v23 = a4;
            goto LABEL_219;
          case 0xB001Cu:
            unsigned int v24 = a4;
            goto LABEL_221;
          case 0xB001Du:
            unsigned int v25 = a4;
            goto LABEL_223;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_111;
          case 0xC0001u:
            goto LABEL_157;
          case 0xC0002u:
            goto LABEL_87;
          case 0xC0003u:
            goto LABEL_114;
          case 0xC0004u:
            goto LABEL_121;
          case 0xC0005u:
            *(unsigned char *)(v7 + 36) = a4 != 0.0;
            break;
          case 0xC0006u:
            *(unsigned char *)(v7 + 37) = (int)a4;
            break;
          case 0xC0007u:
            goto LABEL_134;
          case 0xC0008u:
            goto LABEL_122;
          case 0xC0009u:
            goto LABEL_123;
          case 0xC000Au:
            goto LABEL_149;
          case 0xC000Bu:
            goto LABEL_150;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_154;
          case 0xD0002u:
            goto LABEL_147;
          case 0xD0003u:
            goto LABEL_114;
          case 0xD0004u:
            goto LABEL_121;
          case 0xD0005u:
            goto LABEL_128;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_113;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507) {
                goto LABEL_157;
              }
            }
            else if (a2 == 917505 && !*(_WORD *)(v7 + 18))
            {
              goto LABEL_157;
            }
            break;
          case 0xE0002u:
            goto LABEL_120;
          default:
            return result;
        }
        return result;
      case 0xFu:
        if (a2 != 983040) {
          return result;
        }
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_76;
          case 0x100001u:
            goto LABEL_117;
          case 0x100002u:
            goto LABEL_116;
          case 0x100003u:
            goto LABEL_69;
          case 0x100004u:
            goto LABEL_154;
          case 0x100005u:
            goto LABEL_118;
          case 0x100006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_154;
          case 0x110002u:
            goto LABEL_147;
          case 0x110003u:
            goto LABEL_114;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649) {
          goto LABEL_154;
        }
        if (a2 != 1179648) {
          return result;
        }
        goto LABEL_111;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_69;
          case 0x130001u:
            goto LABEL_154;
          case 0x130002u:
            goto LABEL_147;
          case 0x130003u:
            goto LABEL_160;
          case 0x130004u:
            goto LABEL_116;
          case 0x130005u:
            goto LABEL_162;
          case 0x130006u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_69;
          case 0x140001u:
            goto LABEL_154;
          case 0x140002u:
            goto LABEL_147;
          case 0x140003u:
            goto LABEL_76;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_69;
          case 0x150001u:
            goto LABEL_154;
          case 0x150002u:
            goto LABEL_147;
          case 0x150003u:
            goto LABEL_76;
          case 0x150004u:
LABEL_61:
            unsigned int v10 = a4;
            goto LABEL_161;
          case 0x150005u:
LABEL_124:
            unsigned int v15 = a4;
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_76;
          case 0x170001u:
            goto LABEL_117;
          case 0x170002u:
            goto LABEL_116;
          case 0x170003u:
            goto LABEL_69;
          case 0x170004u:
            goto LABEL_154;
          case 0x170005u:
            goto LABEL_118;
          case 0x170006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864) {
          goto LABEL_111;
        }
        if (a2 == 1572865) {
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a4 != 0.0) << 15);
        }
        return result;
      case 0x19u:
        if (a2 == 1638402)
        {
LABEL_114:
          unsigned int v12 = a4;
LABEL_115:
          *(_DWORD *)(v7 + 28) = v12;
          return result;
        }
        if (a2 == 1638401)
        {
LABEL_87:
          unsigned int v13 = a4;
LABEL_148:
          *(_DWORD *)(v7 + 24) = v13;
          return result;
        }
        if (a2 != 1638400) {
          return result;
        }
        goto LABEL_69;
      case 0x1Au:
        if (a2 == 1703938) {
          goto LABEL_87;
        }
        if (a2 == 1703937)
        {
LABEL_119:
          *(unsigned char *)(v7 + 20) = (int)a4;
          return result;
        }
        if (a2 != 1703936) {
          return result;
        }
LABEL_139:
        unsigned int v11 = a4;
        goto LABEL_140;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_76;
          case 0x1B0001u:
            goto LABEL_117;
          case 0x1B0002u:
            goto LABEL_116;
          case 0x1B0003u:
            goto LABEL_69;
          case 0x1B0004u:
            goto LABEL_154;
          case 0x1B0005u:
            goto LABEL_118;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_76:
            unsigned int v12 = a4;
            goto LABEL_115;
          case 0x1C0001u:
LABEL_117:
            *(_WORD *)(v7 + 32) = (int)a4;
            break;
          case 0x1C0002u:
            goto LABEL_116;
          case 0x1C0003u:
            goto LABEL_69;
          case 0x1C0004u:
            goto LABEL_154;
          case 0x1C0005u:
LABEL_118:
            *(_WORD *)(v7 + 34) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_139;
          case 0x1D0001u:
            goto LABEL_154;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = (int)a4;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = (int)a4;
            break;
          case 0x1D0004u:
            *(unsigned char *)(v7 + 32) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        if (a2 == 1966082) {
          goto LABEL_87;
        }
        if (a2 == 1966081) {
          goto LABEL_154;
        }
        if (a2 != 1966080) {
          return result;
        }
        goto LABEL_139;
      case 0x1Fu:
        if (a2 == 2031617) {
          goto LABEL_157;
        }
        if (a2 != 2031616) {
          return result;
        }
        goto LABEL_69;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_111;
          case 0x200001u:
            goto LABEL_154;
          case 0x200002u:
            goto LABEL_87;
          case 0x200003u:
            goto LABEL_95;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689) {
          goto LABEL_154;
        }
        if (a2 != 2162688) {
          return result;
        }
        goto LABEL_139;
      case 0x22u:
        if (a2 == 2228225) {
          goto LABEL_154;
        }
        if (a2 != 2228224) {
          return result;
        }
LABEL_111:
        unsigned int v11 = a4;
        goto LABEL_140;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_111;
          case 0x230001u:
            goto LABEL_154;
          case 0x230002u:
            goto LABEL_147;
          case 0x230003u:
LABEL_95:
            unsigned int v12 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_115;
          case 0x230004u:
LABEL_160:
            unsigned int v10 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_161;
          case 0x230005u:
            unsigned int v18 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_200;
          case 0x230006u:
            unsigned int v20 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_202;
          case 0x230007u:
LABEL_116:
            unsigned int v15 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_129;
          case 0x230008u:
LABEL_162:
            unsigned int v17 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_173;
          case 0x230009u:
LABEL_186:
            *(_DWORD *)(v7 + 68) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Au:
LABEL_196:
            *(_DWORD *)(v7 + 76) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Bu:
LABEL_187:
            *(_DWORD *)(v7 + 72) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Cu:
LABEL_197:
            *(_DWORD *)(v7 + 80) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Du:
LABEL_189:
            *(_DWORD *)(v7 + 52) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Eu:
LABEL_190:
            *(_DWORD *)(v7 + 56) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Fu:
LABEL_215:
            *(_DWORD *)(v7 + 60) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230010u:
            *(_DWORD *)(v7 + 64) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230011u:
            char v22 = *(unsigned char *)(v7 + 84) & 0xFE | (a4 != 0.0);
            goto LABEL_206;
          case 0x230012u:
            char v22 = *(unsigned char *)(v7 + 84) & 0xFD | (2 * (a4 != 0.0));
LABEL_206:
            *(unsigned char *)(v7 + 84) = v22;
            break;
          case 0x230013u:
LABEL_198:
            *(_DWORD *)(v7 + 88) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230014u:
            unsigned int v23 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_219:
            *(_DWORD *)(v7 + 92) = v23;
            break;
          case 0x230015u:
            unsigned int v24 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_221:
            *(_DWORD *)(v7 + 96) = v24;
            break;
          case 0x230016u:
            unsigned int v25 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_223:
            *(_DWORD *)(v7 + 100) = v25;
            break;
          case 0x230017u:
            *(_DWORD *)(v7 + 104) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230018u:
            *(_DWORD *)(v7 + 108) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297) {
          goto LABEL_157;
        }
        if (a2 != 2359296) {
          return result;
        }
        goto LABEL_69;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(void *)(v7 + 24) = (unint64_t)a4;
            break;
          case 0x260001u:
            goto LABEL_154;
          case 0x260000u:
LABEL_69:
            unsigned int v11 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_140:
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1) {
          return result;
        }
        int v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 != 2555906) {
            return result;
          }
LABEL_154:
          unsigned int v16 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_158;
        }
        if (!v14)
        {
          if (a2 != 2555905) {
            return result;
          }
          goto LABEL_157;
        }
        if (a2 == 2555905 && v14 == 2)
        {
LABEL_157:
          unsigned int v16 = a4;
LABEL_158:
          *(_DWORD *)(v7 + 20) = v16;
          return result;
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = (int)a4;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = (int)a4;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = a4;
            break;
          case 0x280003u:
LABEL_130:
            *(unsigned char *)(v7 + 24) = (int)a4;
            break;
          case 0x280004u:
LABEL_131:
            *(unsigned char *)(v7 + 25) = (int)a4;
            break;
          case 0x280005u:
            goto LABEL_114;
          case 0x280006u:
LABEL_121:
            unsigned int v10 = a4;
LABEL_161:
            *(_DWORD *)(v7 + 32) = v10;
            break;
          case 0x280007u:
LABEL_128:
            unsigned int v15 = a4;
LABEL_129:
            *(_DWORD *)(v7 + 36) = v15;
            break;
          case 0x280008u:
            *(unsigned char *)(v7 + 44) = (int)a4;
            break;
          case 0x280009u:
LABEL_171:
            unsigned int v20 = a4;
LABEL_202:
            *(_DWORD *)(v7 + 48) = v20;
            break;
          case 0x28000Au:
            *(void *)(v7 + 56) = (unint64_t)a4;
            break;
          case 0x28000Bu:
            *(unsigned char *)(v7 + 26) = (int)a4;
            break;
          case 0x28000Cu:
LABEL_172:
            unsigned int v17 = a4;
LABEL_173:
            *(_DWORD *)(v7 + 40) = v17;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_111;
          case 0x290001u:
            goto LABEL_119;
          case 0x290002u:
            goto LABEL_132;
          case 0x290003u:
            goto LABEL_133;
          case 0x290004u:
LABEL_134:
            *(double *)(v7 + 40) = a4;
            break;
          case 0x290005u:
            goto LABEL_122;
          case 0x290006u:
            goto LABEL_123;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_113:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
          case 0x2A0001u:
LABEL_120:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x2A0002u:
LABEL_132:
            *(double *)(v7 + 24) = a4;
            break;
          case 0x2A0003u:
LABEL_133:
            *(double *)(v7 + 32) = a4;
            break;
          case 0x2A0004u:
            *(unsigned char *)(v7 + 40) = a4 != 0.0;
            break;
          case 0x2A0005u:
LABEL_169:
            unsigned int v18 = a4;
LABEL_200:
            *(_DWORD *)(v7 + 44) = v18;
            break;
          case 0x2A0006u:
LABEL_122:
            *(double *)(v7 + 48) = a4;
            break;
          case 0x2A0007u:
LABEL_123:
            *(double *)(v7 + 56) = a4;
            break;
          case 0x2A0008u:
LABEL_149:
            *(double *)(v7 + 64) = a4;
            break;
          case 0x2A0009u:
LABEL_150:
            *(double *)(v7 + 72) = a4;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

void *IOHIDEventCreateDigitizerEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, int a14, int a15)
{
  if (a8) {
    int v25 = 65537;
  }
  else {
    int v25 = 1;
  }
  unsigned int v26 = v25 | a15;
  unsigned int v27 = v25 | a15 | 0x20000;
  if (a7 & 1 | a14) {
    uint64_t v28 = v27;
  }
  else {
    uint64_t v28 = v26;
  }
  uint64_t v29 = (void *)IOHIDEventCreate(a1, 11, a2, v28);
  uint64_t v30 = v29;
  if (v29)
  {
    uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(v29, 11, 4026531840);
    if (EventWithOptions) {
      *(_DWORD *)(*(void *)(EventWithOptions + 104) + 40) = a6;
    }
    uint64_t v32 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v32) {
      *(_DWORD *)(*(void *)(v32 + 104) + 48) = a7;
    }
    uint64_t v33 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v33) {
      *(_DWORD *)(*(void *)(v33 + 104) + 28) = a4;
    }
    uint64_t v34 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v34) {
      *(_DWORD *)(*(void *)(v34 + 104) + 32) = a3;
    }
    uint64_t v35 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v35) {
      *(_DWORD *)(*(void *)(v35 + 104) + 36) = a5;
    }
    uint64_t v36 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v36) {
      *(_DWORD *)(*(void *)(v36 + 104) + 16) = vcvtd_n_s64_f64(a9, 0x10uLL);
    }
    uint64_t v37 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v37) {
      *(_DWORD *)(*(void *)(v37 + 104) + 20) = vcvtd_n_s64_f64(a10, 0x10uLL);
    }
    uint64_t v38 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v38) {
      *(_DWORD *)(*(void *)(v38 + 104) + 24) = vcvtd_n_s64_f64(a11, 0x10uLL);
    }
    uint64_t v39 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v39) {
      *(_DWORD *)(*(void *)(v39 + 104) + 52) = vcvtd_n_s64_f64(a12, 0x10uLL);
    }
    uint64_t v40 = IOHIDEventGetEventWithOptions(v30, 11, 4026531840);
    if (v40) {
      *(_DWORD *)(*(void *)(v40 + 104) + 60) = vcvtd_n_s64_f64(a13, 0x10uLL);
    }
  }
  else
  {
    int v41 = _IOHIDLog();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v43 = 0;
      _os_log_impl(&dword_18B46C000, v41, OS_LOG_TYPE_DEFAULT, "IOHIDEventCreateDigitizerEvent event is null", v43, 2u);
    }
  }
  return v30;
}

uint64_t IOHIDEventCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 > 0x2A) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = qword_18B50BE58[(int)a2];
  }
  uint64_t v7 = _IOHIDEventCreate(a1, v6, a2, a3, a4);
  if (v7)
  {
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      a3 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(a3);
    }
    *(void *)(v7 + 8) = a3;
  }
  return v7;
}

uint64_t IOPMAllowsBackgroundTask(unsigned int a1)
{
  return (a1 >> 6) & 1;
}

void IOHIDEventSystemClientSetMatching(uint64_t a1, void *a2)
{
  values = a2;
  if (a2)
  {
    CFArrayRef v3 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    IOHIDEventSystemClientSetMatchingMultiple(a1, v3);
    if (v3) {
      CFRelease(v3);
    }
  }
  else
  {
    IOHIDEventSystemClientSetMatchingMultiple(a1, 0);
  }
}

uint64_t _Xio_hideventsystem_create_virtual_service(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    uint64_t v4 = *MEMORY[0x1E4F14068];
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    int v5 = -300;
    goto LABEL_9;
  }
  uint64_t result = _io_hideventsystem_create_virtual_service(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, (const void **)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  uint64_t v4 = *MEMORY[0x1E4F14068];
  if (!result)
  {
    *(void *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 4) = 44;
    return result;
  }
LABEL_10:
  *(void *)(a2 + 24) = v4;
  return result;
}

uint64_t _io_hideventsystem_create_virtual_service(unsigned int a1, UInt8 *a2, unsigned int a3, const void **a4)
{
  *a4 = 0;
  mach_vm_size_t v7 = a3;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  int v9 = _IOHIDUnserializeAndVMDeallocWithTypeID(a2, v7, TypeID);
  unsigned int v10 = IOMIGMachPortCacheCopy(a1);
  if (v10)
  {
    unsigned int v11 = v10;
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 == IOHIDEventSystemConnectionGetTypeID())
    {
      if (IOHIDEventSystemConnectionGetType((uint64_t)v11)
        && (*(unsigned char *)IOHIDEventSystemConnectionGetEntitlements((uint64_t)v11) & 8) == 0)
      {
        int v14 = _IOHIDLogCategory(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          _io_hideventsystem_dispatch_event_cold_1((uint64_t)v11);
        }
      }
      else
      {
        *a4 = _IOHIDEventSystemConnectionCreateVirtualService((uint64_t)v11);
      }
    }
    CFRelease(v11);
  }
  if (v9) {
    CFRelease(v9);
  }
  return 0;
}

const void *_IOHIDEventSystemConnectionCreateVirtualService(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (const void *)(atomic_fetch_add(_virtualServiceID, 1u) | (unint64_t)(a1 << 16));
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)a1);
  VirtualForConnection = _IOHIDServiceCreateVirtualForConnection((uint64_t)v3, (uint64_t)v2, virtualServiceCallbacks, (const void *)a1);
  if (VirtualForConnection)
  {
    int v5 = VirtualForConnection;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 272), v2, VirtualForConnection);
    CFRetain((CFTypeRef)a1);
    EnumerationQueue = _IOHIDEventSystemGetEnumerationQueue(*(void *)(a1 + 8));
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___IOHIDEventSystemConnectionCreateVirtualService_block_invoke;
    block[3] = &__block_descriptor_tmp_134;
    block[4] = v5;
    void block[5] = a1;
    void block[6] = v2;
    dispatch_async(EnumerationQueue, block);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  mach_vm_size_t v7 = _IOHIDLogCategory(9u);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 168);
    *(_DWORD *)buf = 136315394;
    uint64_t v12 = v8;
    __int16 v13 = 2048;
    int v14 = v2;
    _os_log_impl(&dword_18B46C000, v7, OS_LOG_TYPE_DEFAULT, "%s: HIDVS ID:%llx create", buf, 0x16u);
  }
  return v2;
}

uint64_t _IOHIDEventSystemGetEnumerationQueue(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

void *_IOHIDServiceCreateVirtualForConnection(uint64_t a1, uint64_t a2, void *a3, const void *a4)
{
  VirtualNoInit = __IOHIDServiceCreateVirtualNoInit(a1, a2, a3, 0, (uint64_t)a4);
  uint64_t v6 = VirtualNoInit;
  if (VirtualNoInit)
  {
    VirtualNoInit[43] = VirtualNoInit;
    VirtualNoInit[42] = CFRetain(a4);
  }
  return v6;
}

void *__IOHIDServiceCreateVirtualNoInit(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t Private = (void *)_IOHIDServiceCreatePrivate(a1);
  if (Private)
  {
    unsigned int v10 = (char *)malloc_type_calloc(1uLL, 0x58uLL, 0x10800405B6EA996uLL);
    Private[45] = v10;
    if (v10)
    {
      if (*a3 == 2)
      {
        unsigned int v11 = a3;
        size_t v12 = 88;
      }
      else
      {
        v10 += 8;
        unsigned int v11 = a3;
        size_t v12 = 72;
      }
      memmove(v10, v11, v12);
      Private[43] = a4;
      Private[44] = a5;
      Private[50] = a2;
    }
    else
    {
      CFRelease(Private);
      return 0;
    }
  }
  return Private;
}

uint64_t IOHIDEventSystemClientActivate(uint64_t result)
{
  if (*(void *)(result + 400)) {
    BOOL v1 = *(void *)(result + 384) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    uint64_t result = _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = result;
  if ((atomic_fetch_or((atomic_uint *volatile)(result + 312), 1u) & 1) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3) {
      IOMIGMachPortScheduleWithDispatchQueue(v3, *(NSObject **)(v2 + 400));
    }
    CFMachPortGetPort(*(CFMachPortRef *)(v2 + 280));
    dispatch_mach_connect();
    uint64_t v4 = *(__CFMachPort **)(v2 + 56);
    if (v4)
    {
      CFMachPortGetPort(v4);
      dispatch_mach_connect();
    }
    os_unfair_recursive_lock_unlock();
    __IOHIDEventSystemClientStartQueue(v2);
    return __IOHIDEventSystemClientStartFilter(v2);
  }
  return result;
}

CFRunLoopSourceRef IOHIDEventSystemClientScheduleWithRunLoop(CFRunLoopSourceRef result, __CFRunLoop *a2, const __CFString *a3)
{
  *((void *)result + 48) = a2;
  *((void *)result + 49) = a3;
  if (!a2) {
    return result;
  }
  int v5 = result;
  __IOHIDEventSystemClientSetupAsyncSupport((uint64_t)result);
  os_unfair_recursive_lock_lock_with_options();
  RunLoopSource = (__CFRunLoopSource *)v5[36];
  if (RunLoopSource) {
    goto LABEL_3;
  }
  int v9 = (__CFMachPort *)v5[35];
  if (!v9)
  {
LABEL_4:
    mach_vm_size_t v7 = (__CFRunLoopSource *)v5[8];
    if (!v7)
    {
      unsigned int v10 = (__CFMachPort *)v5[7];
      if (!v10) {
        goto LABEL_6;
      }
      uint64_t result = CFMachPortCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10, 0);
      mach_vm_size_t v7 = result;
      v5[8] = result;
      if (!result) {
        return result;
      }
    }
    CFRunLoopAddSource(a2, v7, a3);
LABEL_6:
    uint64_t v8 = (const void *)v5[5];
    if (v8) {
      IOMIGMachPortScheduleWithRunLoop(v8, a2, a3);
    }
    os_unfair_recursive_lock_unlock();
    __IOHIDEventSystemClientStartQueue((uint64_t)v5);
    return (CFRunLoopSourceRef)__IOHIDEventSystemClientStartFilter((uint64_t)v5);
  }
  RunLoopSource = CFMachPortCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, 0);
  v5[36] = RunLoopSource;
  if (RunLoopSource)
  {
LABEL_3:
    CFRunLoopAddSource(a2, RunLoopSource, a3);
    goto LABEL_4;
  }

  return (CFRunLoopSourceRef)os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDEventSystemClientSetupAsyncSupport(uint64_t a1)
{
  v10.version = 0;
  memset(&v10.retain, 0, 24);
  v10.info = (void *)a1;
  os_unfair_recursive_lock_lock_with_options();
  if (*(void *)(a1 + 280)
    || (Notificationmach_port_t Port = IODataQueueAllocateNotificationPort()) != 0
    && (CFMachPortRef v3 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x1E4F1CF80], NotificationPort, (CFMachPortCallBack)__IOHIDEventSystemClientQueueCallback, &v10, 0), (*(void *)(a1 + 280) = v3) != 0))
  {
    if (!*(void *)(a1 + 56))
    {
      mach_port_t notify_port = 0;
      if (notify_register_mach_port("com.apple.iohideventsystem.available", &notify_port, 0, (int *)(a1 + 48)))
      {
        uint64_t v4 = _IOHIDLogCategory(0);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          __IOHIDEventSystemClientSetupAsyncSupport_cold_2();
        }
      }
      else
      {
        CFMachPortRef v5 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x1E4F1CF80], notify_port, (CFMachPortCallBack)__IOHIDEventSystemClientAvailabilityCallback, &v10, 0);
        *(void *)(a1 + 56) = v5;
        if (!v5) {
          return os_unfair_recursive_lock_unlock();
        }
        __IOHIDEventSystemClientRefresh(a1, 0);
      }
    }
    if (!*(void *)(a1 + 272))
    {
      if (*(unsigned char *)(a1 + 448))
      {
        uint64_t v6 = 0x20000;
      }
      else if (*(_DWORD *)(a1 + 424) == 2)
      {
        uint64_t v6 = 0x4000;
      }
      else
      {
        uint64_t v6 = 0x8000;
      }
      mach_port_t Port = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 280));
      mach_port_t notify_port = 0;
      if (io_hideventsystem_queue_create(*(_DWORD *)(a1 + 32), Port, v6, &notify_port))
      {
        uint64_t v8 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          __IOHIDEventSystemClientSetupAsyncSupport_cold_1();
        }
        *(void *)(a1 + 272) = 0;
      }
      else
      {
        *(void *)(a1 + 272) = IOHIDEventQueueCreateWithVM(*MEMORY[0x1E4F1CF80], notify_port, v6);
      }
    }
  }
  return os_unfair_recursive_lock_unlock();
}

mach_port_t IODataQueueAllocateNotificationPort(void)
{
  kern_return_t v1;
  mach_port_t result;
  mach_msg_type_number_t port_info_outCnt;
  mach_port_name_t name[2];

  *(void *)name = 0;
  unsigned int v0 = (ipc_space_t *)MEMORY[0x1E4F14960];
  BOOL v1 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name[1]);
  uint64_t result = 0;
  if (!v1)
  {
    port_info_outCnt = 1;
    if (mach_port_get_attributes(*v0, name[1], 1, (mach_port_info_t)name, &port_info_outCnt)
      || (name[0] = 1, MEMORY[0x18C131260](*v0, name[1], 1, name, 1)))
    {
      mach_port_mod_refs(*v0, name[1], 1u, -1);
      return 0;
    }
    else
    {
      return name[1];
    }
  }
  return result;
}

uint64_t io_hideventsystem_queue_create(int a1, int a2, int a3, _DWORD *a4)
{
  memset(&msg[4], 0, 32);
  *(_DWORD *)&msg[24] = 1;
  *(_DWORD *)&unsigned char msg[28] = a2;
  int v11 = 1310720;
  uint64_t v12 = *MEMORY[0x1E4F14068];
  int v13 = a3;
  mach_port_name_t special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)mach_msg_header_t msg = -2147478253;
  *(void *)&msg[16] = 0x1117F00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_name_t special_reply_port = *(_DWORD *)&msg[12];
  }
  uint64_t v7 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x34u, 0x30u, special_reply_port, 0, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!v7)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        uint64_t v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 70115)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            uint64_t v8 = 4294966996;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8]) {
                uint64_t v8 = 4294966996;
              }
              else {
                uint64_t v8 = *(unsigned int *)&msg[32];
              }
            }
          }
          else
          {
            uint64_t v8 = 4294966996;
          }
          goto LABEL_26;
        }
        uint64_t v8 = 4294966996;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 40 && !*(_DWORD *)&msg[8] && HIWORD(v11) << 16 == 1114112)
        {
          uint64_t v8 = 0;
          *a4 = *(_DWORD *)&msg[28];
          return v8;
        }
      }
      else
      {
        uint64_t v8 = 4294966995;
      }
LABEL_26:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v8 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], *(mach_port_name_t *)&msg[12]);
    }
    goto LABEL_26;
  }
  return v8;
}

_DWORD *IOHIDEventQueueCreateWithVM(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2 || !a3)
  {
    CFMachPortContext v10 = _IOHIDLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      IOHIDEventQueueCreateWithVM_cold_1(a2, a3, v10);
    }
    return 0;
  }
  uint64_t Private = __IOHIDEventQueueCreatePrivate();
  uint64_t v6 = (_DWORD *)Private;
  if (Private)
  {
    mach_vm_offset_t v7 = *MEMORY[0x1E4F14AF0];
    mach_vm_size_t v8 = ~*MEMORY[0x1E4F14AF0] & (unint64_t)(a3 + *MEMORY[0x1E4F14AF0] + 40);
    *(void *)(Private + 24) = v8;
    *(_DWORD *)(Private + 84) = a2;
    if (!mach_vm_map(*MEMORY[0x1E4F14960], (mach_vm_address_t *)(Private + 16), v8, v7, 1, a2, 0, 0, 3, 3, 2u))
    {
      v6[36] = 1;
      return v6;
    }
    int v11 = _IOHIDLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      IOHIDEventQueueCreate_cold_2();
    }
    CFRelease(v6);
    return 0;
  }
  return v6;
}

uint64_t IOHIDEventSystemClientCreateWithType(const __CFAllocator *a1, int a2, const __CFDictionary *a3)
{
  v27[3] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v6 = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    uint64_t v6 = __kIOHIDEventSystemClientTypeID;
  }
  uint64_t Instance = _IOHIDObjectCreateInstance((uint64_t)a1, v6, 0x1F8uLL);
  if (Instance)
  {
    CFUUIDRef v8 = CFUUIDCreate(a1);
    if (v8)
    {
      CFUUIDRef v9 = v8;
      *(void *)(Instance + 440) = CFUUIDCreateString(a1, v8);
      CFRelease(v9);
    }
    CFDictionaryValueCallBacks valueCallBacks = *(CFDictionaryValueCallBacks *)byte_1ED86F938;
    *(void *)(Instance + 24) = 0;
    *(void *)(Instance + 160) = 0;
    CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], &valueCallBacks);
    *(void *)(Instance + 88) = v10;
    if (!v10) {
      goto LABEL_37;
    }
    CFMutableSetRef Mutable = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
    *(void *)(Instance + 112) = Mutable;
    if (!Mutable) {
      goto LABEL_37;
    }
    CFMutableDictionaryRef v12 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(Instance + 96) = v12;
    if (!v12) {
      goto LABEL_37;
    }
    CFMutableDictionaryRef v13 = CFDictionaryCreateMutable(a1, 0, 0, MEMORY[0x1E4F1D540]);
    *(void *)(Instance + 104) = v13;
    if (!v13) {
      goto LABEL_37;
    }
    CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(a1, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(Instance + 128) = v14;
    if (!v14) {
      goto LABEL_37;
    }
    if (a3 != (const __CFDictionary *)1635017576 && a3)
    {
      CFDictionaryRef Copy = CFDictionaryCreateCopy(a1, a3);
      *(void *)(Instance + 416) = Copy;
      if (Copy) {
        *(unsigned char *)(Instance + 448) = CFDictionaryGetValue(Copy, @"HighFrequency") == (const void *)*MEMORY[0x1E4F1CFD0];
      }
    }
    else
    {
      *(void *)(Instance + 416) = 0;
    }
    *(_DWORD *)(Instance + 424) = a2;
    memset(v27, 0, 24);
    memset(&v25, 0, sizeof(v25));
    backtrace(v27, 3);
    if (a3 == (const __CFDictionary *)1635017576) {
      uint64_t v16 = 2;
    }
    else {
      uint64_t v16 = 1;
    }
    if (!dladdr(v27[v16], &v25))
    {
      if (*(void *)(Instance + 432)) {
        goto LABEL_33;
      }
LABEL_32:
      *(void *)(Instance + 432) = @"***UNKOWN***";
      CFRetain(@"***UNKOWN***");
LABEL_33:
      unsigned int v23 = dispatch_queue_create("hideventsystemclient.default.queue", 0);
      *(void *)(Instance + 488) = v23;
      if (v23)
      {
        dispatch_set_context(v23, (void *)Instance);
        dispatch_set_finalizer_f(*(dispatch_object_t *)(Instance + 488), (dispatch_function_t)__IOHIDEventSystemClientFinalizeStateHandler);
        _IOHIDObjectInternalRetain((const void *)Instance);
        *(void *)(Instance + 456) = os_state_add_handler();
        __IOHIDEventSystemClientRefresh(Instance, 0);
        return Instance;
      }
LABEL_37:
      CFRelease((CFTypeRef)Instance);
      return 0;
    }
    dli_fname = v25.dli_fname;
    if (v25.dli_fname)
    {
      unsigned int v18 = strrchr((char *)v25.dli_fname, 47);
      if (v18) {
        unsigned int v19 = v18 + 1;
      }
      else {
        unsigned int v19 = dli_fname;
      }
      dli_sname = v25.dli_sname;
      if (!v25.dli_sname)
      {
        unsigned int v21 = (void *)((unsigned char *)v27[v16] - (char *)v25.dli_fbase);
        dli_sname = v19;
        goto LABEL_31;
      }
    }
    else
    {
      dli_sname = v25.dli_sname;
      if (!v25.dli_sname)
      {
        unsigned int v21 = v27[v16];
        dli_sname = "0x0";
        unsigned int v19 = "???";
LABEL_31:
        CFStringRef v22 = CFStringCreateWithFormat(a1, 0, @"%s: %s + %lu", v19, dli_sname, v21);
        *(void *)(Instance + 432) = v22;
        if (v22) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
      unsigned int v19 = "???";
    }
    unsigned int v21 = (void *)((unsigned char *)v27[v16] - (char *)v25.dli_saddr);
    goto LABEL_31;
  }
  return Instance;
}

void __IOHIDEventSystemClientRefresh(uint64_t a1, char a2)
{
  kern_return_t v12;
  kern_return_t v13;
  mach_error_t v14;
  CFDataRef v15;
  CFDataRef v16;
  const UInt8 *BytePtr;
  int Length;
  CFDataRef v19;
  CFDataRef v20;
  CFStringRef v21;
  const UInt8 *v22;
  ipc_space_t *v23;
  mach_port_name_t v24;
  pid_t v25;
  int Port;
  int v27;
  mach_port_t v28;
  kern_return_t v29;
  mach_error_t v30;
  CFDataRef v31;
  CFArrayRef Copy;
  CFArrayRef v33;
  kern_return_t v34;
  NSObject *v35;
  CFDictionaryRef v36;
  CFDictionaryRef v37;
  __CFRunLoop *v38;
  CFStringRef v39;
  char v40;
  CFAllocatorRef v41;
  CFDictionaryRef v42;
  CFDictionaryRef v43;
  CFNumberRef v44;
  CFNumberRef v45;
  CFTypeID v46;
  NSObject *v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  char v51;
  __CFDictionary *v52;
  CFDataRef v53;
  CFDataRef cf;
  mach_port_name_t tn[2];
  _OWORD v56[2];
  mach_port_name_t v57;
  mach_port_t special_port[2];
  char buffer[1024];
  uint64_t v60;
  uint64_t vars8;

  long long v60 = *MEMORY[0x1E4F143B8];
  *(void *)special_port = 0;
  int v57 = 0;
  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 32))
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    memset(v56, 0, sizeof(v56));
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      pid_t v6 = getpid();
      if (proc_name(v6, buffer, 0x400u)) {
        CFStringRef v7 = CFStringCreateWithCString(v4, buffer, 0);
      }
      else {
        CFStringRef v7 = 0;
      }
      CFUUIDRef v8 = *(const void **)(a1 + 432);
      if (v8) {
        CFDictionarySetValue(Mutable, @"caller", v8);
      }
      if (v7) {
        CFDictionarySetValue(Mutable, @"procName", v7);
      }
      CFUUIDRef v9 = *(const void **)(a1 + 440);
      if (v9) {
        CFDictionarySetValue(Mutable, @"UUID", v9);
      }
    }
    else
    {
      CFStringRef v7 = 0;
    }
    __IOHIDEventSystemClientInitReplyPort((uint64_t *)a1);
    uint64_t v10 = *(void *)(a1 + 40);
    os_unfair_recursive_lock_unlock();
    if (v10)
    {
      int v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
      if (!task_get_special_port(*MEMORY[0x1E4F14960], 4, &special_port[1]))
      {
        if (xpc_user_sessions_enabled())
        {
          tn[1] = 0;
          xpc_user_sessions_get_foreground_uid();
          uint64_t v34 = bootstrap_look_up_per_user();
          if (v34)
          {
            uint64_t v35 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
              __IOHIDEventSystemClientRefresh_cold_6(v34, v35);
            }
          }
        }
        CFMutableDictionaryRef v12 = bootstrap_look_up2();
        CFMutableDictionaryRef v13 = mach_port_deallocate(*v11, special_port[1]);
        if (v12)
        {
          unsigned int v47 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
            __IOHIDEventSystemClientRefresh_cold_5(v12, v47);
          }
        }
        else
        {
          CFMutableDictionaryRef v14 = v13;
          if (v13)
          {
            long long v48 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
              __IOHIDEventSystemClientRefresh_cold_4(v14, v48);
            }
          }
          else
          {
            size_t v51 = a2;
            uint64_t v15 = (const __CFData *)_IOHIDCreateBinaryData(v4, Mutable);
            unsigned int v53 = v15;
            if (v15)
            {
              uint64_t v16 = v15;
              BytePtr = CFDataGetBytePtr(v15);
              int Length = CFDataGetLength(v16);
            }
            else
            {
              BytePtr = 0;
              int Length = 0;
            }
            CFIndex v52 = Mutable;
            unsigned int v19 = (const __CFData *)_IOHIDCreateBinaryData(v4, *(const void **)(a1 + 416));
            unsigned int v20 = v19;
            CFTypeRef cf = v19;
            unsigned int v21 = v7;
            if (v19)
            {
              CFStringRef v22 = CFDataGetBytePtr(v19);
              LODWORD(v20) = CFDataGetLength(v20);
            }
            else
            {
              CFStringRef v22 = 0;
            }
            tn[0] = 0;
            unsigned int v23 = (ipc_space_t *)MEMORY[0x1E4F14960];
            unsigned int v24 = *MEMORY[0x1E4F14960];
            Dl_info v25 = getpid();
            if (task_name_for_pid(v24, v25, tn)) {
              __IOHIDEventSystemClientRefresh_cold_3();
            }
            os_unfair_recursive_lock_lock_with_options();
            mach_port_t Port = IOMIGMachPortGetPort(*(void *)(a1 + 40));
            os_unfair_recursive_lock_unlock();
            unsigned int v27 = io_hideventsystem_open(v57, tn[0], *(_DWORD *)(a1 + 424), (uint64_t)BytePtr, Length, (uint64_t)v22, (int)v20, Port, special_port, v56);
            uint64_t v28 = special_port[0];
            uint64_t v29 = mach_port_deallocate(*v23, v57);
            if (v27 || !v28)
            {
              mach_msg_size_t v49 = _IOHIDLogCategory(0xDu);
              CFStringRef v7 = v21;
              CFMutableSetRef Mutable = v52;
              __int16 v31 = v53;
              if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
                __IOHIDEventSystemClientRefresh_cold_1();
              }
            }
            else
            {
              uint64_t v30 = v29;
              __int16 v31 = v53;
              if (v29)
              {
                unsigned int v50 = _IOHIDLogCategory(0xDu);
                CFStringRef v7 = v21;
                CFMutableSetRef Mutable = v52;
                if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                  __IOHIDEventSystemClientRefresh_cold_2(v30, v50);
                }
              }
              else
              {
                os_unfair_recursive_lock_lock_with_options();
                *(_DWORD *)(a1 + 32) = special_port[0];
                CFStringRef v7 = v21;
                if (v51)
                {
                  CFDictionaryRef Copy = 0;
                  CFMutableSetRef Mutable = v52;
                }
                else
                {
                  uint64_t v33 = *(const __CFArray **)(a1 + 80);
                  CFMutableSetRef Mutable = v52;
                  if (v33) {
                    CFDictionaryRef Copy = CFArrayCreateCopy(v4, v33);
                  }
                  else {
                    CFDictionaryRef Copy = 0;
                  }
                  IOHIDEventSystemClientSetMatchingMultiple(a1, Copy);
                }
                if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 104)))
                {
                  uint64_t v36 = CFDictionaryCreateCopy(v4, *(CFDictionaryRef *)(a1 + 104));
                  uint64_t v37 = v36;
                  if (v36) {
                    CFDictionaryApplyFunction(v36, (CFDictionaryApplierFunction)__VirtualServiceNotifier, (void *)a1);
                  }
                  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 104));
                }
                else
                {
                  uint64_t v37 = 0;
                }
                if ((*(void *)(a1 + 384) || *(void *)(a1 + 400))
                  && (__IOHIDEventSystemClientSetupAsyncSupport(a1), (uint64_t v38 = *(__CFRunLoop **)(a1 + 384)) != 0)
                  && (uint64_t v39 = *(const __CFString **)(a1 + 392)) != 0)
                {
                  IOHIDEventSystemClientScheduleWithRunLoop((CFRunLoopSourceRef)a1, v38, v39);
                }
                else if (*(void *)(a1 + 400))
                {
                  uint64_t v40 = atomic_load((unsigned int *)(a1 + 312));
                  if ((v40 & 2) == 0) {
                    IOMIGMachPortScheduleWithDispatchQueue(*(void *)(a1 + 40), *(NSObject **)(a1 + 400));
                  }
                }
                os_unfair_recursive_lock_unlock();
                __IOHIDEventSystemClientStartQueue(a1);
                __IOHIDEventSystemClientStartFilter(a1);
                os_unfair_recursive_lock_lock_with_options();
                if (*(void *)(a1 + 360) || *(void *)(a1 + 352)) {
                  io_hideventsystem_register_record_service_changed_notification(*(_DWORD *)(a1 + 32));
                }
                if (*(void *)(a1 + 328) || *(void *)(a1 + 320)) {
                  io_hideventsystem_register_record_client_changed_notification(*(_DWORD *)(a1 + 32));
                }
                os_unfair_recursive_lock_unlock();
                os_unfair_recursive_lock_lock_with_options();
                int v41 = CFGetAllocator((CFTypeRef)a1);
                mach_port_t v42 = CFDictionaryCreateCopy(v41, *(CFDictionaryRef *)(a1 + 128));
                os_unfair_recursive_lock_unlock();
                if (v42)
                {
                  CFDictionaryApplyFunction(v42, (CFDictionaryApplierFunction)__IOHIDEventSystemClientConnectionPropertyFunction, (void *)a1);
                  CFRelease(v42);
                }
                os_unfair_recursive_lock_lock_with_options();
                uint64_t v43 = *(const __CFDictionary **)(a1 + 120);
                if (v43) {
                  CFDictionaryApplyFunction(v43, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRegisterPropertyCallbackRegisterFunction, (void *)a1);
                }
                os_unfair_recursive_lock_unlock();
                BOOL v44 = (const __CFNumber *)IOHIDEventSystemClientCopyProperty((IOHIDEventSystemClientRef)a1, @"HIDDebug");
                if (v44)
                {
                  uint64_t v45 = v44;
                  int v46 = CFGetTypeID(v44);
                  if (v46 == CFNumberGetTypeID()) {
                    CFNumberGetValue(v45, kCFNumberSInt32Type, &gIOHIDDebugConfig);
                  }
                  CFRelease(v45);
                }
                if (v37) {
                  CFRelease(v37);
                }
                if (Copy) {
                  CFRelease(Copy);
                }
              }
            }
            if (v31) {
              CFRelease(v31);
            }
            if (cf) {
              CFRelease(cf);
            }
          }
        }
      }
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

uint64_t __IOHIDEventSystemClientStartQueue(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v2 = 0;
  if (!*(void *)(a1 + 200)) {
    BOOL v2 = *(void *)(a1 + 208) == 0;
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  mach_port_t v3 = *(_DWORD *)(a1 + 32);
  if (v3 && !v2 && (*(void *)(a1 + 384) || *(void *)(a1 + 400)))
  {
    if (io_hideventsystem_queue_start(v3))
    {
      CFAllocatorRef v4 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        __IOHIDEventSystemClientStartQueue_cold_1();
      }
    }
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDEventSystemClientStartFilter(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  mach_port_t v2 = *(_DWORD *)(a1 + 32);
  if (v2 && (*(void *)(a1 + 232) || *(void *)(a1 + 240)) && (*(void *)(a1 + 384) || *(void *)(a1 + 400))) {
    io_hideventsystem_register_event_filter(v2, *(_DWORD *)(a1 + 264));
  }

  return os_unfair_recursive_lock_unlock();
}

void IOHIDEventSystemClientSetMatchingMultiple(uint64_t a1, const __CFArray *a2)
{
  value[2] = *(void **)MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFDictionaryRef *)(a1 + 96));
  pid_t v6 = *(const void **)(a1 + 80);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 80) = 0;
  }
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 112));
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 96));
  uint64_t v7 = io_hideventsystem_clear_service_cache(*(_DWORD *)(a1 + 32));
  if (v7 == 268435459 && !*(void *)(a1 + 384) && !*(void *)(a1 + 400))
  {
    __IOHIDEventSystemClientTerminationCallback(v7, a1, 1);
    io_hideventsystem_clear_service_cache(*(_DWORD *)(a1 + 32));
  }
  os_unfair_recursive_lock_unlock();
  if (a2)
  {
    os_unfair_recursive_lock_lock_with_options();
    *(void *)(a1 + 80) = CFArrayCreateCopy(v4, a2);
    os_unfair_recursive_lock_unlock();
    CFIndex Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      CFIndex v9 = Count;
      for (CFIndex i = 0; i != v9; ++i)
      {
        value[0] = 0;
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        CFTypeID v12 = CFGetTypeID(ValueAtIndex);
        if (v12 == CFDictionaryGetTypeID())
        {
          __IOHIDEventSystemClientCacheMatchingServices(a1, ValueAtIndex, (const void **)value);
          if (value[0])
          {
            os_unfair_recursive_lock_lock_with_options();
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 112), value[0]);
            os_unfair_recursive_lock_unlock();
            CFRelease(value[0]);
          }
        }
      }
    }
  }
  else
  {
    value[0] = 0;
    __IOHIDEventSystemClientCacheMatchingServices(a1, 0, (const void **)value);
    if (value[0])
    {
      os_unfair_recursive_lock_lock_with_options();
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 112), value[0]);
      os_unfair_recursive_lock_unlock();
      CFRelease(value[0]);
    }
  }
  if (Copy)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__IOHIDEventSystemClientServiceReplaceCallback, *(void **)(a1 + 96));
    CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
    CFDictionaryRef v14 = CFDictionaryCreateCopy(v13, *(CFDictionaryRef *)(a1 + 96));
    os_unfair_recursive_lock_unlock();
    value[0] = (void *)a1;
    value[1] = Copy;
    CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRefreshServiceCallback, value);
    CFRelease(v14);
    CFRelease(Copy);
  }
}

void __IOHIDEventSystemClientCacheMatchingServices(uint64_t a1, const void *a2, const void **a3)
{
  memset(length, 0, sizeof(length));
  unsigned int v26 = 0;
  unsigned int v25 = 0;
  if (a3) {
    pid_t v6 = &length[1];
  }
  else {
    pid_t v6 = 0;
  }
  if (a3) {
    uint64_t v7 = length;
  }
  else {
    uint64_t v7 = 0;
  }
  if (a2)
  {
    CFDataRef v8 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    CFDataRef v9 = v8;
    if (v8)
    {
      BytePtr = CFDataGetBytePtr(v8);
      int v11 = CFDataGetLength(v9);
    }
    else
    {
      BytePtr = 0;
      int v11 = 0;
    }
  }
  else
  {
    BytePtr = 0;
    int v11 = 0;
    CFDataRef v9 = 0;
  }
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v12 = io_hideventsystem_copy_matching_services(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, v6, v7, &v26, &v25);
  int v13 = v12;
  if (v12 == 268435459)
  {
    if (*(void *)(a1 + 384))
    {
      os_unfair_recursive_lock_unlock();
LABEL_17:
      CFArrayRef v14 = 0;
      goto LABEL_18;
    }
    __IOHIDEventSystemClientTerminationCallback(v12, a1, 0);
    int v13 = io_hideventsystem_copy_matching_services(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, v6, v7, &v26, &v25);
  }
  os_unfair_recursive_lock_unlock();
  if (v13) {
    goto LABEL_17;
  }
  uint64_t v15 = v26;
  mach_vm_size_t v16 = v25;
  CFTypeID TypeID = CFArrayGetTypeID();
  CFArrayRef v14 = (const __CFArray *)_IOHIDUnserializeAndVMDeallocWithTypeID(v15, v16, TypeID);
  CFPropertyListRef v18 = _IOHIDUnserializeAndVMDealloc(*(UInt8 **)&length[1], length[0]);
  if (v18)
  {
    unsigned int v19 = v18;
    if (a3)
    {
      CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFStringRef v22 = Mutable;
        CFDictionarySetValue(Mutable, @"id", v19);
        if (a2)
        {
          CFDictionaryRef Copy = CFDictionaryCreateCopy(v20, (CFDictionaryRef)a2);
          CFDictionarySetValue(v22, @"matching", Copy);
          CFRelease(Copy);
        }
        unsigned int v24 = IOHIDNotificationCreate((uint64_t)v20, (uint64_t)__IOHIDEventSystemClientMatchNotifyRelease, a1, (uint64_t)v22, 0, 0, 0);
        *a3 = v24;
        if (v24)
        {
          os_unfair_recursive_lock_lock_with_options();
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 88), v19, *a3);
          os_unfair_recursive_lock_unlock();
        }
      }
    }
    CFRelease(v19);
  }
LABEL_18:
  if (v9) {
    CFRelease(v9);
  }
  if (v14)
  {
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 0x40000000;
    v28[2] = ____IOHIDEventSystemClientCacheServices_block_invoke;
    v28[3] = &__block_descriptor_tmp_124;
    v28[4] = a1;
    _IOHIDCFArrayApplyBlock(v14, v28);
    CFRelease(v14);
  }
}

uint64_t io_hideventsystem_copy_matching_services(mach_port_t a1, uint64_t a2, int a3, void *a4, _DWORD *a5, void *a6, _DWORD *a7)
{
  msg.msgh_id = 0;
  uint64_t v23 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  *(_OWORD *)&msg.msgh_unsigned int size = 0u;
  int v19 = 1;
  uint64_t v20 = a2;
  int v21 = 16777472;
  int v22 = a3;
  uint64_t v23 = *MEMORY[0x1E4F14068];
  LODWORD(v24) = a3;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(void *)&msg.msgh_voucher_port = 0x1117100000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v13 = mach_msg(&msg, 3162115, 0x38u, 0x54u, special_reply_port, 0, 0);
  uint64_t v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!v13)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v14 = 4294966988;
      }
      else if (msg.msgh_id == 70101)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            uint64_t v14 = 4294966996;
            if (HIDWORD(v20))
            {
              if (msg.msgh_remote_port) {
                uint64_t v14 = 4294966996;
              }
              else {
                uint64_t v14 = HIDWORD(v20);
              }
            }
          }
          else
          {
            uint64_t v14 = 4294966996;
          }
          goto LABEL_29;
        }
        uint64_t v14 = 4294966996;
        if (v19 == 2 && msg.msgh_size == 76 && !msg.msgh_remote_port && HIBYTE(v21) == 1 && BYTE3(v24) == 1)
        {
          int v15 = v22;
          if (v22 == v25)
          {
            int v16 = DWORD1(v24);
            if (DWORD1(v24) == DWORD1(v25))
            {
              uint64_t v14 = 0;
              *a4 = v20;
              *a5 = v15;
              *a6 = v23;
              *a7 = v16;
              return v14;
            }
          }
        }
      }
      else
      {
        uint64_t v14 = 4294966995;
      }
LABEL_29:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v14 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    goto LABEL_29;
  }
  return v14;
}

uint64_t io_hideventsystem_clear_service_cache(mach_port_t a1)
{
  msg.msgh_unsigned int size = 0;
  msg.msgh_bits = 19;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = 0;
  *(void *)&msg.msgh_voucher_port = 0x1117300000000;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set(&msg);
  }
  uint64_t v1 = mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0);
  if ((v1 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    mach_msg_destroy(&msg);
  }
  return v1;
}

uint64_t io_hideventsystem_open(int a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, int a8, _DWORD *a9, _OWORD *a10)
{
  *(_OWORD *)&msg[20] = 0u;
  *(void *)int v22 = 0x13000000000000;
  *(_OWORD *)&v22[8] = 0u;
  uint64_t v23 = 0;
  *(_OWORD *)&msg[4] = 0u;
  *(_DWORD *)&msg[24] = 4;
  *(_DWORD *)&unsigned char msg[28] = a2;
  int v17 = 1245184;
  uint64_t v18 = a4;
  int v19 = 16777472;
  int v20 = a5;
  *(void *)int v21 = a6;
  *(_DWORD *)&v21[8] = 16777472;
  *(_DWORD *)&v21[12] = a7;
  *(_DWORD *)&v21[16] = a8;
  *(void *)&v22[8] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&v22[16] = a3;
  *(_DWORD *)&v22[20] = a5;
  LODWORD(v23) = a7;
  mach_port_name_t special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)mach_msg_header_t msg = -2147478253;
  *(void *)&msg[16] = 0x1117000000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_name_t special_reply_port = *(_DWORD *)&msg[12];
  }
  uint64_t v12 = mach_msg((mach_msg_header_t *)msg, 53493763, 0x68u, 0x6Cu, special_reply_port, 0, 0);
  uint64_t v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!v12)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        uint64_t v13 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 70100)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            uint64_t v13 = 4294966996;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8]) {
                uint64_t v13 = 4294966996;
              }
              else {
                uint64_t v13 = *(unsigned int *)&msg[32];
              }
            }
          }
          else
          {
            uint64_t v13 = 4294966996;
          }
          goto LABEL_28;
        }
        uint64_t v13 = 4294966996;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 40 && !*(_DWORD *)&msg[8] && HIWORD(v17) << 16 == 1114112)
        {
          if (v18 || HIDWORD(v18) < 0x20) {
            return 4294966987;
          }
          uint64_t v13 = 0;
          *a9 = *(_DWORD *)&msg[28];
          long long v15 = *(_OWORD *)v22;
          *a10 = *(_OWORD *)&v21[4];
          a10[1] = v15;
          return v13;
        }
      }
      else
      {
        uint64_t v13 = 4294966995;
      }
LABEL_28:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v13 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], *(mach_port_name_t *)&msg[12]);
    }
    goto LABEL_28;
  }
  return v13;
}

uint64_t _IOHIDEventSystemConnectionCreate(const __CFAllocator *a1, uint64_t a2, unsigned int a3, const __CFDictionary *a4, const __CFDictionary *a5, uint64_t a6, mach_port_name_t a7, mach_port_name_t a8, _OWORD *a9)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  mach_port_name_t name = 0;
  mach_port_t previous = 0;
  uint64_t Private = _IOHIDEventSystemConnectionCreatePrivate((uint64_t)a1);
  uint64_t v18 = Private;
  int v19 = (ipc_space_t *)MEMORY[0x1E4F14960];
  if (a3 > 4 || !Private)
  {
    if (a3 >= 5 && (long long v70 = _IOHIDLog(), os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)))
    {
      _IOHIDEventSystemConnectionCreate_cold_1(a3, a6, v70);
      if (!a7)
      {
LABEL_88:
        if (a8) {
          mach_port_deallocate(*v19, a8);
        }
        CFStringRef v50 = 0;
        mach_port_name_t v71 = 0;
        if (!v18) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
    }
    else if (!a7)
    {
      goto LABEL_88;
    }
    mach_port_deallocate(*v19, a7);
    goto LABEL_88;
  }
  *(_DWORD *)(Private + 40) = a8;
  *(_DWORD *)(Private + 192) = a7;
  mach_port_allocate(*v19, 1u, &name);
  if (mach_port_request_notification(*v19, name, 70, 1u, name, 0x15u, &previous)
    || mach_port_insert_right(*v19, name, name, 0x14u))
  {
    CFStringRef v50 = 0;
    mach_port_name_t v71 = 0;
    goto LABEL_57;
  }
  mach_port_name_t v71 = name;
  int v20 = IOMIGMachPortCreate(a1, dword_1ED86F448, name);
  *(void *)(v18 + 32) = v20;
  if (!v20) {
    goto LABEL_83;
  }
  uint64_t v74 = a2;
  mach_port_name_t name = 0;
  *(_DWORD *)(v18 + 448) = 0;
  long long v21 = a9[1];
  *(_OWORD *)(v18 + 196) = *a9;
  *(_OWORD *)(v18 + 212) = v21;
  long long v22 = a9[1];
  long long v76 = *a9;
  long long v77 = v22;
  uint64_t v23 = (void *)xpc_copy_entitlement_for_token();
  xpc_object_t empty = xpc_dictionary_create_empty();
  long long v25 = empty;
  if (v23)
  {
    *(void *)applier = MEMORY[0x1E4F143A8];
    *(void *)&applier[8] = 0x40000000;
    *(void *)&applier[16] = ____IOHIDEventSystemConnectionCreateConnectionEntitlements_block_invoke;
    long long v81 = &__block_descriptor_tmp_150;
    xpc_object_t v82 = empty;
    xpc_dictionary_apply(v23, applier);
    xpc_release(v23);
  }
  *(void *)(v18 + 248) = v25;
  if (!v25)
  {
LABEL_83:
    CFStringRef v50 = 0;
    goto LABEL_57;
  }
  CFDictionaryRef v73 = a5;
  uint64_t v26 = *(void *)(v18 + 168);
  unsigned int v27 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  if (!v27)
  {
    CFStringRef v50 = 0;
    *(void *)(v18 + 240) = 0;
    goto LABEL_57;
  }
  uint64_t v28 = v27;
  uint64_t v72 = a6;
  *unsigned int v27 = 0;
  xpc_object_t value = xpc_dictionary_get_value(v25, "com.apple.private.hid.client.admin");
  xpc_object_t v30 = (xpc_object_t)MEMORY[0x1E4F14518];
  __int16 v31 = v19;
  if (value == (xpc_object_t)MEMORY[0x1E4F14518]) {
    char v32 = 1;
  }
  else {
    char v32 = __IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.admin.internal", v26);
  }
  *uint64_t v28 = *v28 & 0xFE | v32;
  char v33 = 2;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.event-monitor") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.event-monitor.internal", v26))char v33 = 2; {
    else
    }
      char v33 = 0;
  }
  *uint64_t v28 = *v28 & 0xFD | v33;
  char v34 = 4;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.event-filter") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.event-filter.internal", v26))char v34 = 4; {
    else
    }
      char v34 = 0;
  }
  *uint64_t v28 = *v28 & 0xFB | v34;
  char v35 = 8;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.event-dispatch") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.event-dispatch.internal", v26))char v35 = 8; {
    else
    }
      char v35 = 0;
  }
  *uint64_t v28 = *v28 & 0xF7 | v35;
  char v36 = 16;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.service-protected") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.service-protected.internal", v26))char v36 = 16; {
    else
    }
      char v36 = 0;
  }
  *uint64_t v28 = *v28 & 0xEF | v36;
  char v37 = 32;
  if (xpc_dictionary_get_value(v25, "com.apple.private.hid.client.motion-event-privileged") != v30)
  {
    if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.motion-event-privileged.internal", v26))char v37 = 32; {
    else
    }
      char v37 = 0;
  }
  *uint64_t v28 = *v28 & 0xDF | v37;
  if (__IOHIDValidateInternalBuildEntitlement(v25, "com.apple.private.hid.client.debug-tool.internal", v26))char v38 = 64; {
  else
  }
    char v38 = 0;
  *uint64_t v28 = *v28 & 0xBF | v38;
  *(void *)(v18 + 240) = v28;
  if (a4)
  {
    CFStringRef v39 = (const __CFString *)CFDictionaryGetValue(a4, @"caller");
    CFStringRef v40 = (const __CFString *)CFDictionaryGetValue(a4, @"procName");
    CFStringRef v41 = (const __CFString *)CFDictionaryGetValue(a4, @"UUID");
    int v19 = v31;
    if (v39) {
      CFStringRef Copy = CFStringCreateCopy(a1, v39);
    }
    else {
      CFStringRef Copy = 0;
    }
    uint64_t v43 = v72;
    *(void *)(v18 + 144) = Copy;
    uint64_t v45 = v74;
    if (v40) {
      CFStringRef v47 = CFStringCreateCopy(a1, v40);
    }
    else {
      CFStringRef v47 = 0;
    }
    CFDictionaryRef v44 = v73;
    *(void *)(v18 + 152) = v47;
    if (v41) {
      CFStringRef v41 = CFStringCreateCopy(a1, v41);
    }
    *(void *)(v18 + 160) = v41;
    if (v41) {
      goto LABEL_48;
    }
  }
  else
  {
    CFStringRef v41 = *(const __CFString **)(v18 + 160);
    int v19 = v31;
    uint64_t v43 = v72;
    CFDictionaryRef v44 = v73;
    uint64_t v45 = v74;
    if (v41)
    {
LABEL_48:
      CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
      CStringPtr = CFStringGetCStringPtr(v41, SystemEncoding);
      goto LABEL_49;
    }
  }
  CStringPtr = 0;
LABEL_49:
  *(void *)(v18 + 168) = CStringPtr;
  *(void *)(v18 + 8) = v45;
  *(_DWORD *)(v18 + 176) = a3;
  if (v44) {
    CFDictionaryRef v49 = CFDictionaryCreateCopy(a1, v44);
  }
  else {
    CFDictionaryRef v49 = 0;
  }
  *(void *)(v18 + 184) = v49;
  *(_DWORD *)(v18 + 88) = v43;
  *(void *)(v18 + 280) = -1;
  *(_DWORD *)(v18 + 228) = 0;
  *(_DWORD *)(v18 + 232) = 0;
  *(_DWORD *)(v18 + 268) = 0;
  *(_DWORD *)(v18 + 256) = (**(unsigned char **)(v18 + 240) & 0x13) == 0;
  CFStringRef v50 = CFStringCreateWithFormat(a1, 0, @"IOHIDConnection process:%@ pid:%d uuid:%@ caller:%@", *(void *)(v18 + 152), v43, *(void *)(v18 + 160), *(void *)(v18 + 144));
  if (!v50) {
    goto LABEL_57;
  }
  if (!a3 && (**(unsigned char **)(v18 + 240) & 1) == 0)
  {
    size_t v51 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemConnectionCreate_cold_2();
    }
    goto LABEL_57;
  }
  IOMIGMachPortRegisterTerminationCallback(*(void *)(v18 + 32), (uint64_t)__IOHIDEventSystemConnectionPortTerminateCallback, v18);
  IOMIGMachPortRegisterDemuxCallback(*(void *)(v18 + 32), (uint64_t)__IOHIDEventSystemConnectionPortDemuxCallback, v18);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(v18 + 16) = Mutable;
  if (!Mutable) {
    goto LABEL_57;
  }
  CFMutableSetRef v53 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(v18 + 80) = v53;
  if (!v53) {
    goto LABEL_57;
  }
  CFMutableDictionaryRef v54 = CFDictionaryCreateMutable(a1, 0, 0, MEMORY[0x1E4F1D540]);
  *(void *)(v18 + 272) = v54;
  if (!v54) {
    goto LABEL_57;
  }
  CFDictionaryRef v55 = malloc_type_calloc(0x2BuLL, 8uLL, 0x100004000313F17uLL);
  *(void *)(v18 + 392) = v55;
  if (!v55) {
    goto LABEL_57;
  }
  CFRetain(*(CFTypeRef *)(v18 + 8));
  int v56 = _os_feature_enabled_impl();
  CFStringEncoding v57 = CFStringGetSystemEncoding();
  CFTypeID v58 = CFStringGetCStringPtr(v50, v57);
  long long v59 = v56
      ? hid_workloop_create(v58, 63)
      : hid_dispatch_queue_create(v58, 0, kIOHIDServerConnectionRootQueue, 0, 0, 0);
  *(void *)(v18 + 96) = v59;
  if (!v59 || (*(_DWORD *)(v18 + 400) = 2, (CFArrayRef v60 = (const __CFArray *)_IOHIDLoadConnectionPluginBundles()) == 0))
  {
LABEL_57:
    CFRelease((CFTypeRef)v18);
LABEL_58:
    if (name) {
      mach_port_mod_refs(*v19, name, 1u, -1);
    }
    if (v71) {
      mach_port_deallocate(*v19, v71);
    }
    uint64_t v18 = 0;
    goto LABEL_79;
  }
  CFArrayRef v61 = v60;
  if (CFArrayGetCount(v60) < 1)
  {
LABEL_80:
    CFRelease(v50);
    return v18;
  }
  CFIndex v62 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v61, v62);
    CFAllocatorRef v64 = CFGetAllocator((CFTypeRef)v18);
    CFTypeRef v65 = IOHIDConnectionFilterCreate((uint64_t)v64, ValueAtIndex, v18);
    if (v65) {
      break;
    }
    if (++v62 >= CFArrayGetCount(v61)) {
      goto LABEL_79;
    }
  }
  uint64_t v66 = (uint64_t)v65;
  CFRetain((CFTypeRef)v18);
  v75[0] = MEMORY[0x1E4F143A8];
  v75[1] = 0x40000000;
  v75[2] = ___IOHIDEventSystemConnectionCreate_block_invoke;
  v75[3] = &__block_descriptor_tmp_23;
  v75[4] = v18;
  IOHIDConnectionFilterSetCancelHandler(v66, (uint64_t)v75);
  *(void *)(v18 + 440) = v66;
  long long v67 = _IOHIDLogCategory(9u);
  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v68 = *(void *)(v18 + 168);
    *(_DWORD *)applier = 136315394;
    *(void *)&applier[4] = v68;
    *(_WORD *)&applier[12] = 2112;
    *(void *)&applier[14] = v66;
    _os_log_impl(&dword_18B46C000, v67, OS_LOG_TYPE_DEFAULT, "%s: Connection filter added:%@", applier, 0x16u);
  }
LABEL_79:
  if (v50) {
    goto LABEL_80;
  }
  return v18;
}

uint64_t __IOHIDValidateInternalBuildEntitlement(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = os_variant_allows_internal_security_policies();
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  BOOL v8 = value == (xpc_object_t)MEMORY[0x1E4F14518];
  if (value == (xpc_object_t)MEMORY[0x1E4F14518]) {
    uint64_t result = v6;
  }
  else {
    uint64_t result = 0;
  }
  if (v8 && (v6 & 1) == 0)
  {
    uint64_t v10 = _IOHIDLogCategory(9u);
    BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v11)
    {
      int v12 = 136315394;
      uint64_t v13 = a3;
      __int16 v14 = 2080;
      long long v15 = a2;
      _os_log_impl(&dword_18B46C000, v10, OS_LOG_TYPE_DEFAULT, "[%s] Process has entitlement %s on Non-Internal build", (uint8_t *)&v12, 0x16u);
      return 0;
    }
  }
  return result;
}

NSObject *hid_workloop_create(const char *a1, int a2)
{
  inactive = dispatch_workloop_create_inactive(a1);
  if (a2) {
    dispatch_workloop_set_scheduler_priority();
  }
  dispatch_set_qos_class_fallback();
  dispatch_workloop_set_scheduler_priority();
  _dispatch_workloop_set_observer_hooks_4IOHID();
  dispatch_activate(inactive);
  return inactive;
}

uint64_t _io_hideventsystem_open(unsigned int a1, mach_port_name_t a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, mach_port_name_t a8, _DWORD *a9, _OWORD *a10)
{
  pid_t pidp = -1;
  long long v18 = a10[1];
  *(_OWORD *)atoken.val = *a10;
  *(_OWORD *)&atoken.val[4] = v18;
  audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFDictionaryRef v20 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
  CFTypeID v21 = CFDictionaryGetTypeID();
  CFDictionaryRef v22 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a6, a7, v21);
  uint64_t v23 = (CFMutableSetRef **)IOMIGMachPortCacheCopy(a1);
  long long v24 = v23;
  if (!v23) {
    goto LABEL_16;
  }
  CFTypeID v25 = CFGetTypeID(v23);
  uint64_t v26 = __kIOHIDEventServerTypeID;
  if (!__kIOHIDEventServerTypeID)
  {
    pthread_once(&__serviceTypeInit, (void (*)(void))__IOHIDEventServerRegister);
    uint64_t v26 = __kIOHIDEventServerTypeID;
  }
  if (v25 == v26)
  {
    CFAllocatorRef v27 = CFGetAllocator(v24);
    uint64_t v28 = (uint64_t)v24[2];
    long long v29 = a10[1];
    *(_OWORD *)atoken.val = *a10;
    *(_OWORD *)&atoken.val[4] = v29;
    xpc_object_t v30 = (const void *)_IOHIDEventSystemConnectionCreate(v27, v28, a3, v20, v22, pidp, a2, a8, &atoken);
    if (v30)
    {
      _IOHIDEventSystemAddConnection(v24[2], v30);
      unsigned int Port = _IOHIDEventSystemConnectionGetPort((uint64_t)v30);
      IOMIGMachPortCacheAdd(Port, v30);
      _IOHIDEventSystemConnectionRegisterTerminationCallback((uint64_t)v30, (uint64_t)__IOHIDEventSystemConnectionDiedCallback, (uint64_t)v24);
      _IOHIDEventSystemConnectionRegisterDemuxCallback((uint64_t)v30, (uint64_t)__IOHIDEventSystemConnectionDemuxCallback, (uint64_t)v24);
      _IOHIDEventSystemConnectionScheduleAsync((uint64_t)v30);
      int v32 = _IOHIDEventSystemConnectionGetPort((uint64_t)v30);
    }
    else
    {
      int v32 = 0;
    }
  }
  else
  {
LABEL_16:
    int v32 = 0;
    xpc_object_t v30 = 0;
  }
  if (v22) {
    CFRelease(v22);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v30) {
    CFRelease(v30);
  }
  if (v24) {
    CFRelease(v24);
  }
  *a9 = v32;
  return 0;
}

uint64_t _IOHIDEventSystemConnectionGetPort(uint64_t a1)
{
  return IOMIGMachPortGetPort(*(void *)(a1 + 32));
}

uint64_t __IOHIDEventSystemClientInitReplyPort(uint64_t *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = 1;
  if (!a1[5])
  {
    integer_t port_info_out = 0;
    mach_msg_type_number_t port_info_outCnt = 1;
    mach_port_t v3 = IOMIGMachPortCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], dword_1ED86F220, 0);
    a1[5] = (uint64_t)v3;
    if (v3)
    {
      CFAllocatorRef v4 = (unsigned int *)MEMORY[0x1E4F14960];
      ipc_space_read_t v5 = *MEMORY[0x1E4F14960];
      mach_port_name_t Port = IOMIGMachPortGetPort((uint64_t)v3);
      if (mach_port_get_attributes(v5, Port, 1, &port_info_out, &port_info_outCnt))
      {
        int v12 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          __IOHIDEventSystemClientInitReplyPort_cold_3();
        }
      }
      else
      {
        integer_t port_info_out = 64;
        uint64_t v7 = *v4;
        uint64_t v8 = IOMIGMachPortGetPort(a1[5]);
        if (!MEMORY[0x18C131260](v7, v8, 1, &port_info_out, port_info_outCnt))
        {
          IOMIGMachPortRegisterDemuxCallback(a1[5], (uint64_t)__IOHIDEventSystemClientMIGDemuxCallback, (uint64_t)a1);
          IOMIGMachPortRegisterTerminationCallback(a1[5], (uint64_t)__IOHIDEventSystemClientTerminationCallback, (uint64_t)a1);
          unsigned int v9 = IOMIGMachPortGetPort(a1[5]);
          IOMIGMachPortCacheAdd(v9, a1);
          uint64_t v2 = 1;
          goto LABEL_6;
        }
        uint64_t v13 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          __IOHIDEventSystemClientInitReplyPort_cold_2();
        }
      }
    }
    else
    {
      BOOL v11 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        __IOHIDEventSystemClientInitReplyPort_cold_1();
      }
    }
    __int16 v14 = (const void *)a1[5];
    if (v14)
    {
      CFRelease(v14);
      uint64_t v2 = 0;
      a1[5] = 0;
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
LABEL_6:
  os_unfair_recursive_lock_unlock();
  return v2;
}

uint64_t IOMIGMachPortGetPort(uint64_t a1)
{
  return CFMachPortGetPort(*(CFMachPortRef *)(a1 + 48));
}

uint64_t IOMIGMachPortRegisterTerminationCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 88) = a2;
  *(void *)(result + 96) = a3;
  return result;
}

uint64_t IOMIGMachPortRegisterDemuxCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 72) = a2;
  *(void *)(result + 80) = a3;
  return result;
}

void *IOMIGMachPortCreate(const __CFAllocator *a1, uint64_t a2, mach_port_t a3)
{
  if (a2 < 1) {
    return 0;
  }
  if (!__IOMIGMachPortTypeID) {
    pthread_once(&__IOMIGMachPortTypeInit, (void (*)(void))__IOMIGMachPortRegister);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v7 = (void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(void *)(Instance + 96) = 0;
    *(_OWORD *)(Instance + 80) = 0u;
    v10.version = 0;
    memset(&v10.retain, 0, 24);
    v10.info = (void *)Instance;
    if (a3) {
      CFMachPortRef v8 = CFMachPortCreateWithPort(a1, a3, (CFMachPortCallBack)__IOMIGMachPortPortCallback, &v10, 0);
    }
    else {
      CFMachPortRef v8 = CFMachPortCreate(a1, (CFMachPortCallBack)__IOMIGMachPortPortCallback, &v10, 0);
    }
    void v7[6] = v8;
    if (v8)
    {
      v7[8] = a2;
      return v7;
    }
    CFRelease(v7);
    return 0;
  }
  return v7;
}

uint64_t IOMIGMachPortCacheAdd(unsigned int a1, const void *a2)
{
  pthread_mutex_lock(&__ioPortCacheLock);
  CFDictionarySetValue((CFMutableDictionaryRef)__ioPortCache, (const void *)a1, a2);

  return pthread_mutex_unlock(&__ioPortCacheLock);
}

uint64_t _IOHIDLoadConnectionPluginBundles()
{
  if (_IOHIDLoadConnectionPluginBundles_onceToken != -1) {
    dispatch_once(&_IOHIDLoadConnectionPluginBundles_onceToken, &__block_literal_global_58);
  }
  return __hidConnectionPluginBundles;
}

uint64_t _IOHIDEventSystemConnectionRegisterTerminationCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 64) = a2;
  *(void *)(a1 + 72) = a3;

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemConnectionRegisterDemuxCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemConnectionCreatePrivate(uint64_t a1)
{
  uint64_t v1 = +[HIDConnection allocWithZone:a1];

  return (uint64_t)[(HIDConnection *)v1 init];
}

void _IOHIDEventSystemAddConnection(CFMutableSetRef *a1, const void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int Type = IOHIDEventSystemConnectionGetType((uint64_t)a2);
  ipc_space_read_t v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 138543362;
    __int16 v14 = a2;
    _os_log_impl(&dword_18B46C000, v5, OS_LOG_TYPE_DEFAULT, "Connection added: %{public}@", (uint8_t *)&v13, 0xCu);
  }
  os_unfair_recursive_lock_lock_with_options();
  unsigned int v6 = &a1[3 * Type];
  CFMutableSetRef v7 = v6[23];
  CFMachPortRef v8 = (void (*)(CFMutableSetRef, CFMutableSetRef, const void *))v6[24];
  CFMutableSetRef v9 = v6[25];
  CFSetAddValue(a1[6], a2);
  switch(Type)
  {
    case 0:
      CFMachPortContext v10 = a1 + 7;
      goto LABEL_7;
    case 1:
    case 3:
      CFMachPortContext v10 = a1 + 8;
      goto LABEL_7;
    case 2:
    case 4:
      CFMachPortContext v10 = a1 + 9;
LABEL_7:
      CFSetAddValue(*v10, a2);
      break;
    default:
      break;
  }
  CFAllocatorRef v11 = CFGetAllocator(a1);
  CFSetRef Copy = CFSetCreateCopy(v11, a1[53]);
  os_unfair_recursive_lock_unlock();
  if (Copy)
  {
    CFSetApplyFunction(Copy, (CFSetApplierFunction)_IOHIDEventSystemConnectionRecordClientChanged, 0);
    CFRelease(Copy);
  }
  if (v8) {
    v8(v7, v9, a2);
  }
}

CFTypeRef IOHIDEventSystemClientCopyProperty(IOHIDEventSystemClientRef client, CFStringRef key)
{
  CFTypeRef result = 0;
  CFIndex length = 0;
  UInt8 bytes = 0;
  if (client && key)
  {
    CFDataRef v4 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], key);
    if (v4)
    {
      CFDataRef v5 = v4;
      BytePtr = CFDataGetBytePtr(v4);
      int v7 = CFDataGetLength(v5);
      os_unfair_recursive_lock_lock_with_options();
      uint64_t v8 = io_hideventsystem_copy_property(*((_DWORD *)client + 8), (uint64_t)BytePtr, v7, &bytes, (_DWORD *)&length + 1, &length);
      int v9 = v8;
      if (v8 == 268435459)
      {
        if (*((void *)client + 48))
        {
          int v9 = 268435459;
        }
        else
        {
          int v9 = 268435459;
          if (!*((void *)client + 50))
          {
            __IOHIDEventSystemClientTerminationCallback(v8, client, 0);
            int v9 = io_hideventsystem_copy_property(*((_DWORD *)client + 8), (uint64_t)BytePtr, v7, &bytes, (_DWORD *)&length + 1, &length);
          }
        }
      }
      os_unfair_recursive_lock_unlock();
      CFRelease(v5);
      BOOL v10 = length != 0;
    }
    else
    {
      BOOL v10 = 0;
      int v9 = 0;
    }
    CFTypeRef result = 0;
    if (!v9 && !v10) {
      return _IOHIDUnserializeAndVMDealloc(bytes, HIDWORD(length));
    }
  }
  return result;
}

uint64_t io_hideventsystem_copy_property(mach_port_t a1, uint64_t a2, int a3, void *a4, _DWORD *a5, _DWORD *a6)
{
  msg.msgh_id = 0;
  uint64_t v20 = 0;
  long long v21 = 0u;
  *(_OWORD *)&msg.msgh_unsigned int size = 0u;
  int v16 = 1;
  uint64_t v17 = a2;
  int v18 = 16777472;
  int v19 = a3;
  uint64_t v20 = *MEMORY[0x1E4F14068];
  LODWORD(v21) = a3;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(void *)&msg.msgh_voucher_port = 0x1117E00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v11 = mach_msg(&msg, 3162115, 0x38u, 0x44u, special_reply_port, 0, 0);
  uint64_t v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!v11)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v12 = 4294966988;
      }
      else if (msg.msgh_id == 70114)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            uint64_t v12 = 4294966996;
            if (HIDWORD(v17))
            {
              if (msg.msgh_remote_port) {
                uint64_t v12 = 4294966996;
              }
              else {
                uint64_t v12 = HIDWORD(v17);
              }
            }
          }
          else
          {
            uint64_t v12 = 4294966996;
          }
          goto LABEL_27;
        }
        uint64_t v12 = 4294966996;
        if (v16 == 1 && msg.msgh_size == 60 && !msg.msgh_remote_port && HIBYTE(v18) == 1)
        {
          int v13 = v19;
          if (v19 == v21)
          {
            uint64_t v12 = 0;
            *a4 = v17;
            *a5 = v13;
            *a6 = DWORD1(v21);
            return v12;
          }
        }
      }
      else
      {
        uint64_t v12 = 4294966995;
      }
LABEL_27:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v12 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    goto LABEL_27;
  }
  return v12;
}

CFTypeRef IOHIDConnectionFilterCreate(uint64_t a1, __CFBundle *a2, uint64_t a3)
{
  if (!__kIOHIDConnectionFilterTypeID) {
    pthread_once(&__connectionFilterClientTypeInit, (void (*)(void))__IOHIDConnectionFilterRegister);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  if (!Instance) {
    return 0;
  }
  unsigned int v6 = Instance;
  Instance[1] = 0u;
  int v7 = Instance + 1;
  Instance[3] = 0u;
  Instance[4] = 0u;
  Instance[2] = 0u;
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(a2);
  if (!InfoDictionary
    || (uint64_t v9 = (uint64_t)InfoDictionary, (Value = CFDictionaryGetValue(InfoDictionary, @"NSPrincipalClass")) == 0)
    || (uint64_t v11 = Value, v12 = CFGetTypeID(Value), v12 != CFStringGetTypeID())
    || (CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"OBJC_CLASS_$_%@", v11)) == 0)
  {
    CFTypeRef v20 = 0;
    goto LABEL_16;
  }
  CFStringRef v14 = v13;
  DataPointerForName = CFBundleGetDataPointerForName(a2, v13);
  if (!DataPointerForName)
  {
    CFDictionaryRef v22 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      IOHIDConnectionFilterCreate_cold_1((uint64_t)v14, v9, v22);
    }
    goto LABEL_28;
  }
  int v16 = DataPointerForName;
  if (!objc_msgSend(DataPointerForName, sel_getUid("matchConnection:"), a3)
    || (id v17 = objc_msgSend(v16, sel_getUid("alloc"))) == 0)
  {
LABEL_28:
    CFTypeRef v20 = 0;
    goto LABEL_15;
  }
  id v18 = v17;
  if (!objc_msgSend(v17, sel_getUid("initWithConnection:"), a3))
  {
    uint64_t v23 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      IOHIDConnectionFilterCreate_cold_2(v23, v24, v25, v26, v27, v28, v29, v30);
    }
    goto LABEL_28;
  }
  *int v7 = v18;
  Protocol = objc_getProtocol("HIDConnectionPlugin");
  if (!Protocol)
  {
    __int16 v31 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      IOHIDConnectionFilterCreate_cold_3(v31, v32, v33, v34, v35, v36, v37, v38);
    }
    goto LABEL_28;
  }
  if (!class_conformsToProtocol((Class)v16, Protocol))
  {
    CFStringRef v39 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      IOHIDConnectionFilterCreate_cold_4(v39, v40, v41, v42, v43, v44, v45, v46);
    }
    goto LABEL_28;
  }
  v6[3] = sel_getUid("propertyForKey:");
  v6[4] = sel_getUid("setProperty:forKey:");
  v6[9] = sel_getUid("filterEvent:");
  _OWORD v6[5] = sel_getUid("setCancelHandler:");
  v6[8] = sel_getUid("setDispatchQueue:");
  void v6[6] = sel_getUid("activate");
  void v6[7] = sel_getUid("cancel");
  CFTypeRef v20 = CFRetain(v6);
LABEL_15:
  CFRelease(v14);
LABEL_16:
  CFRelease(v6);
  return v20;
}

id _IOHIDEventSystemConnectionScheduleAsync(uint64_t a1)
{
  dispatch_source_t v2 = dispatch_source_create(MEMORY[0x1E4F14460], *(unsigned int *)(a1 + 40), 8uLL, *(dispatch_queue_t *)(a1 + 96));
  *(void *)(a1 + 120) = v2;
  if (v2)
  {
    CFRetain((CFTypeRef)a1);
    dispatch_source_set_registration_handler(*(dispatch_source_t *)(a1 + 120), &__block_literal_global_14);
    mach_port_t v3 = *(NSObject **)(a1 + 120);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = ___IOHIDEventSystemConnectionScheduleAsync_block_invoke_2;
    handler[3] = &__block_descriptor_tmp_15_1;
    handler[4] = a1;
    dispatch_source_set_event_handler(v3, handler);
    CFDataRef v4 = *(NSObject **)(a1 + 120);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    v7[2] = ___IOHIDEventSystemConnectionScheduleAsync_block_invoke_3;
    v7[3] = &__block_descriptor_tmp_16;
    void v7[4] = a1;
    dispatch_source_set_cancel_handler(v4, v7);
    dispatch_resume(*(dispatch_object_t *)(a1 + 120));
  }
  else
  {
    CFDataRef v5 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemConnectionScheduleAsync_cold_1();
    }
  }
  IOMIGMachPortScheduleWithDispatchQueue(*(void *)(a1 + 32), *(NSObject **)(a1 + 96));
  id result = *(id *)(a1 + 440);
  if (result)
  {
    IOHIDConnectionFilterSetDispatchQueue((uint64_t)result, *(void *)(a1 + 96));
    return IOHIDConnectionFilterActivate(*(void *)(a1 + 440));
  }
  return result;
}

uint64_t IOMIGMachPortScheduleWithDispatchQueue(uint64_t a1, NSObject *a2)
{
  uint64_t result = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 48));
  *(void *)(a1 + 32) = a2;
  if (a2)
  {
    if (!*(void *)(a1 + 40))
    {
      dispatch_queue_get_label(a2);
      uint64_t result = dispatch_mach_create_f();
      if (result)
      {
        *(void *)(a1 + 40) = result;
        CFRetain((CFTypeRef)a1);
        return dispatch_mach_connect();
      }
    }
  }
  return result;
}

uint64_t io_hideventsystem_queue_start(mach_port_t a1)
{
  msg.msgh_unsigned int size = 0;
  msg.msgh_bits = 19;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = 0;
  *(void *)&msg.msgh_voucher_port = 0x1118000000000;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set(&msg);
  }
  uint64_t v1 = mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0);
  if ((v1 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    mach_msg_destroy(&msg);
  }
  return v1;
}

void IOMIGMachPortScheduleWithRunLoop(CFTypeRef cf, CFRunLoopRef rl, CFRunLoopMode mode)
{
  *((void *)cf + 2) = rl;
  *((void *)cf + 3) = mode;
  if (rl)
  {
    if (mode)
    {
      RunLoopSource = (__CFRunLoopSource *)*((void *)cf + 7);
      if (RunLoopSource
        || (CFAllocatorRef v7 = CFGetAllocator(cf),
            RunLoopSource = CFMachPortCreateRunLoopSource(v7, *((CFMachPortRef *)cf + 6), 1),
            (*((void *)cf + 7) = RunLoopSource) != 0))
      {
        CFRunLoopAddSource(rl, RunLoopSource, mode);
      }
    }
  }
}

uint64_t _IOHIDServiceCreatePrivate(uint64_t a1)
{
  uint64_t v1 = +[HIDEventService allocWithZone:a1];

  return (uint64_t)[(HIDEventService *)v1 init];
}

id IOHIDServiceFilterUnschedule(id result)
{
  uint64_t v1 = *((void *)result + 2);
  if (v1)
  {
    dispatch_source_t v2 = *(uint64_t (**)(void, void))(*(void *)v1 + 80);
    if (v2) {
      return (id)v2(*((void *)result + 2), *((void *)result + 4));
    }
  }
  if (*((void *)result + 12)) {
    return [*((id *)result + 12) *((SEL *)result + 19)];
  }
  return result;
}

void *IOHIDEventSystemClientSetCancelHandler(uint64_t a1, void *aBlock)
{
  CFDataRef v4 = *(const void **)(a1 + 304);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 304) = result;
  return result;
}

uint64_t ___io_hideventsystem_set_properties_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  int v6 = -536870212;
  if (IOHIDEventSystemConnectionGetType(*(void *)(a1 + 40)) == 4
    && (uint64_t result = CFSetContainsValue((CFSetRef)__whiteListSet, a2), !result))
  {
    int v6 = -536870206;
  }
  else
  {
    uint64_t result = _IOHIDEventSystemSetPropertyForConnection(*(void *)(a1 + 48), a2, a3, *(const void **)(a1 + 40));
    if (result) {
      return result;
    }
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v6;
  return result;
}

_DWORD *_Xio_hideventsystem_queue_stop(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    uint64_t result = (_DWORD *)_io_hideventsystem_queue_stop(result[3]);
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _io_hideventsystem_queue_stop(unsigned int a1)
{
  uint64_t v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    dispatch_source_t v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == IOHIDEventSystemConnectionGetTypeID())
    {
      CFDataRef v4 = _IOHIDEventSystemConnectionCopyQueue((uint64_t)v2);
      if (v4)
      {
        CFDataRef v5 = v4;
        _IOHIDEventSystemConnectionQueueStop((uint64_t)v2);
        IOHIDEventQueueStop((uint64_t)v5);
        CFRelease(v5);
      }
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t _IOHIDEventSystemConnectionQueueStop(uint64_t result)
{
  kern_return_t v7;
  mach_error_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  kern_return_t v18;
  mach_error_t v19;
  NSObject *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  mach_port_t previous;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  mach_port_t v31;
  uint64_t v32;

  uint64_t v1 = result;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*MEMORY[0x1E4F1D260] == result || (*(unsigned char *)(result + 264) & 1) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v2 = *(void *)(v1 + 8);
    uint64_t v3 = *(void *)(v1 + 24);
    if (v3 && *(_DWORD *)(v1 + 128))
    {
      if (*(_DWORD *)(v1 + 104))
      {
        mach_port_t previous = 0;
        CFDataRef v4 = (ipc_space_t *)MEMORY[0x1E4F14960];
        ipc_space_t v5 = *MEMORY[0x1E4F14960];
        Notificationmach_port_name_t Port = IOHIDEventQueueGetNotificationPort(v3);
        CFAllocatorRef v7 = mach_port_request_notification(v5, NotificationPort, 66, 1u, *(_DWORD *)(v1 + 104), 0x15u, &previous);
        if (v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = _IOHIDLogCategory(9u);
          BOOL v10 = (int)v9;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            _IOHIDEventSystemConnectionQueueStop_cold_2(v1, v8, v10, v11, v12, v13, v14, v15);
          }
          __IOHIDEventSystemConnectionCheckServerStatus(v8, v1);
        }
        else if (previous)
        {
          int v16 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            id v17 = *(void *)(v1 + 168);
            *(_DWORD *)buf = 136315394;
            uint64_t v29 = v17;
            uint64_t v30 = 1024;
            __int16 v31 = previous;
            _os_log_impl(&dword_18B46C000, v16, OS_LOG_TYPE_DEFAULT, "%s: mach_port_request_notification(notify) unexpected old notify port %#x", buf, 0x12u);
          }
          id v18 = mach_port_deallocate(*v4, previous);
          if (v18)
          {
            int v19 = v18;
            CFTypeRef v20 = _IOHIDLogCategory(9u);
            long long v21 = (int)v20;
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
              _IOHIDEventSystemConnectionQueueStop_cold_1(v1, v19, v21, v22, v23, v24, v25, v26);
            }
          }
        }
      }
      *(_DWORD *)(v1 + 128) = 0;
    }
    *(_DWORD *)(v1 + 264) |= 2u;
    os_unfair_recursive_lock_unlock();
    return _IOHIDEventSystemSetPropertyForConnection(v2, @"IOHIDEventSystemClientIsUnresponsive", (const void *)*MEMORY[0x1E4F1CFD0], (const void *)v1);
  }
  return result;
}

uint64_t IOHIDEventQueueGetNotificationPort(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *(unsigned int *)(a1 + 96);
  os_unfair_recursive_lock_unlock();
  return v2;
}

_DWORD *_Xio_hideventsystem_queue_start(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    uint64_t result = (_DWORD *)_io_hideventsystem_queue_start(result[3]);
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _io_hideventsystem_queue_start(unsigned int a1)
{
  uint64_t v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == IOHIDEventSystemConnectionGetTypeID())
    {
      CFDataRef v4 = _IOHIDEventSystemConnectionCopyQueue((uint64_t)v2);
      if (v4)
      {
        ipc_space_t v5 = v4;
        _IOHIDEventSystemConnectionQueueStart((uint64_t)v2);
        IOHIDEventQueueStart((uint64_t)v5);
        CFRelease(v5);
      }
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t _IOHIDEventSystemSetPropertyForConnection(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t v7 = *(void *)(a1 + 128);
  if (_IOHIDEventSystemConnectionSetProperty((uint64_t)a4, a2, (const __CFArray *)a3)) {
    return 1;
  }
  else {
    return _IOHIDSessionSetPropertyForClient(v7, a2, a3, a4);
  }
}

uint64_t ___io_hideventsystem_set_properties_for_service_block_invoke(void *a1, const void *a2, const __CFArray *a3)
{
  if (IOHIDEventSystemConnectionGetType(a1[5]) == 4)
  {
    uint64_t result = CFSetContainsValue((CFSetRef)__whiteListSet, a2);
    if (!result)
    {
      int v7 = -536870206;
      goto LABEL_7;
    }
  }
  uint64_t result = _IOHIDEventSystemConnectionSetProperty(a1[5], a2, a3);
  if (!result)
  {
    uint64_t result = _IOHIDServiceSetPropertyForClient(a1[6], a2, a3, (CFTypeRef)a1[5]);
    if (!result)
    {
      int v7 = -536870212;
LABEL_7:
      *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = v7;
    }
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionSetProperty(uint64_t a1, CFTypeRef cf1, const __CFArray *a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (*MEMORY[0x1E4F1D260] == a1) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 440);
  if (v6 && (IOHIDConnectionFilterSetProperty(v6, (uint64_t)cf1, (uint64_t)a3) & 1) != 0) {
    return 1;
  }
  if (CFEqual(cf1, @"ClientEventFilter"))
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (a3 && CFGetTypeID(a3) == TypeID && CFArrayGetCount(a3) >= 1)
    {
      CFIndex v8 = 0;
      uint64_t v9 = 0;
      do
      {
        CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a3, v8);
        CFTypeID v11 = CFNumberGetTypeID();
        if (ValueAtIndex)
        {
          if (CFGetTypeID(ValueAtIndex) == v11)
          {
            int valuePtr = 0;
            CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr);
            v9 |= 1 << valuePtr;
          }
        }
        ++v8;
      }
      while (v8 < CFArrayGetCount(a3));
    }
    else
    {
      uint64_t v9 = 0;
    }
    *(void *)(a1 + 280) = v9;
    return 1;
  }
  if (CFEqual(cf1, @"ClientSuspend"))
  {
    CFTypeID v13 = CFGetTypeID(a3);
    if (v13 == CFBooleanGetTypeID())
    {
      CFArrayRef v14 = (const __CFArray *)*MEMORY[0x1E4F1CFD0];
      os_unfair_recursive_lock_lock_with_options();
      uint64_t v15 = *(void *)(a1 + 24);
      if (v14 == a3)
      {
        if (v15) {
          IOHIDEventQueueSuspend(v15);
        }
      }
      else if (v15)
      {
        IOHIDEventQueueResume(v15);
      }
      os_unfair_recursive_lock_unlock();
      return 1;
    }
  }
  uint64_t result = CFEqual(cf1, @"IdleNotificationTime");
  if (result)
  {
    CFTypeID v16 = CFGetTypeID(a3);
    if (v16 == CFNumberGetTypeID())
    {
      uint64_t v31 = 0;
      CFNumberGetValue(a3, kCFNumberSInt64Type, &v31);
      uint64_t v17 = v31;
      if (*(void *)(a1 + 408) != v31)
      {
        *(void *)(a1 + 408) = v31;
        if (!*(void *)(a1 + 416))
        {
          id v18 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(a1 + 96));
          *(void *)(a1 + 416) = v18;
          if (!v18)
          {
            uint64_t v28 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              _IOHIDEventSystemConnectionSetProperty_cold_1();
            }
            return 1;
          }
          v30[0] = MEMORY[0x1E4F143A8];
          v30[1] = 0x40000000;
          v30[2] = ___IOHIDEventSystemConnectionSetProperty_block_invoke;
          v30[3] = &__block_descriptor_tmp_146;
          v30[4] = a1;
          dispatch_source_set_event_handler(v18, v30);
          dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 416), 0xFFFFFFFFFFFFFFFFLL, 0, 0);
          dispatch_activate(*(dispatch_object_t *)(a1 + 416));
          uint64_t v17 = *(void *)(a1 + 408);
        }
        if (v17)
        {
          uint64_t Session = _IOHIDEventSystemGetSession(*(void *)(a1 + 8));
          if (*(void *)(a1 + 424)
            || (ActivityNotification = _IOHIDSessionCreateActivityNotification(Session, (uint64_t)__IOHIDEventSystemConnectionActivityNotification, a1, 0), (*(void *)(a1 + 424) = ActivityNotification) != 0))
          {
            long long v21 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v23 = *(void *)(a1 + 168);
              uint64_t v24 = *(void *)(a1 + 408);
              int valuePtr = 136315394;
              uint64_t v33 = v23;
              __int16 v34 = 1024;
              int v35 = v24;
              _os_log_impl(&dword_18B46C000, v21, OS_LOG_TYPE_DEFAULT, "%s: HID activity: start reporting with interval: %ds", (uint8_t *)&valuePtr, 0x12u);
            }
            __IOHIDEventSystemConnectionActivityNotification(a1, v22, 0);
          }
          else
          {
            uint64_t v29 = _IOHIDLogCategory(9u);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
              _IOHIDEventSystemConnectionSetProperty_cold_2();
            }
          }
        }
        else
        {
          uint64_t v25 = *(void *)(a1 + 424);
          if (v25)
          {
            IOHIDNotificationInvalidate(v25, 0);
            CFRelease(*(CFTypeRef *)(a1 + 424));
            *(void *)(a1 + 424) = 0;
          }
          *(_DWORD *)(a1 + 400) = 2;
          uint64_t v26 = _IOHIDLogCategory(9u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = *(void *)(a1 + 168);
            int valuePtr = 136315138;
            uint64_t v33 = v27;
            _os_log_impl(&dword_18B46C000, v26, OS_LOG_TYPE_DEFAULT, "%s: HID activity: stop reporting", (uint8_t *)&valuePtr, 0xCu);
          }
          dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 416), 0xFFFFFFFFFFFFFFFFLL, 0, 0);
        }
      }
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t _IOHIDSessionSetPropertyForClient(uint64_t a1, CFTypeRef cf1, const void *a3, const void *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!cf1) {
    return 1;
  }
  if (CFEqual(cf1, @"HIDParameters"))
  {
    CFTypeID v8 = CFGetTypeID(a3);
    if (v8 == CFDictionaryGetTypeID())
    {
      *(void *)int context = a1;
      *(void *)&context[8] = a4;
      CFDictionaryApplyFunction((CFDictionaryRef)a3, (CFDictionaryApplierFunction)__FunctionApplierForParameters, context);
    }
    return 1;
  }
  if (CFEqual(cf1, @"LogLevel"))
  {
    CFTypeID v10 = CFGetTypeID(a3);
    if (v10 == CFNumberGetTypeID())
    {
      *(_DWORD *)int context = *(_DWORD *)(a1 + 128);
      CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, context);
      if (*(_DWORD *)(a1 + 128) != *(_DWORD *)context) {
        *(_DWORD *)(a1 + 128) = *(_DWORD *)context;
      }
    }
  }
  if (CFEqual(cf1, @"HIDDebug"))
  {
    CFTypeID v11 = CFGetTypeID(a3);
    if (v11 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, &gIOHIDDebugConfig);
    }
  }
  int v12 = CFEqual(cf1, @"CASecureLayerOnScreen");
  if (!v12
    || (*(unsigned char *)IOHIDEventSystemConnectionGetEntitlements((uint64_t)a4) & 2) != 0
    || (*(unsigned char *)IOHIDEventSystemConnectionGetEntitlements((uint64_t)a4) & 1) != 0)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(&v30, context);
    }
    ++**(_DWORD **)(a1 + 32);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), cf1, a3);
    v29[0] = a1;
    v29[1] = cf1;
    v29[2] = a3;
    if (a4 && CFEqual(a4, (CFTypeRef)*MEMORY[0x1E4F1D260])) {
      CFTypeID v13 = 0;
    }
    else {
      CFTypeID v13 = a4;
    }
    v29[3] = v13;
    CFArrayRef v14 = *(const __CFArray **)(a1 + 152);
    v34.CFIndex length = CFArrayGetCount(v14);
    v34.location = 0;
    CFArrayApplyFunction(v14, v34, (CFArrayApplierFunction)__FilterFunctionSetPropertyForClient_0, v29);
    CFSetRef v15 = 0;
    if (!v12) {
      CFSetRef v15 = (const __CFSet *)CFRetain(*(CFTypeRef *)(a1 + 136));
    }
    uint64_t v16 = *(void *)(a1 + 32);
    if (*(_DWORD *)v16)
    {
      --*(_DWORD *)v16;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_1(&v30, context);
      }
    }
    if (v12)
    {
      uint64_t v9 = 1;
    }
    else
    {
      *(void *)int context = cf1;
      *(void *)&context[8] = a3;
      *(void *)&context[16] = 0;
      uint64_t v32 = a4;
      CFSetApplyFunction(v15, (CFSetApplierFunction)__SetPropertyForObjectFunction, context);
      uint64_t v9 = context[16];
      CFRelease(v15);
    }
    uint64_t v17 = *(void *)(a1 + 8);
    id v18 = _IOHIDLogCategory(2u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int context = 138412802;
      *(void *)&context[4] = cf1;
      *(_WORD *)&context[12] = 2112;
      *(void *)&context[14] = a3;
      *(_WORD *)&context[22] = 2112;
      uint64_t v32 = a4;
      _os_log_debug_impl(&dword_18B46C000, v18, OS_LOG_TYPE_DEBUG, "SetProperty called %@=%@ caller=%@", context, 0x20u);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(&v30, context);
    }
    int v19 = *(int **)(a1 + 32);
    int v20 = *v19;
    int v21 = *v19 + 1;
    *int v19 = v21;
    if (v20 == -1)
    {
      _IOHIDEventSystemPropertyChanged(v17, (uint64_t)a4, cf1, (uint64_t)a3);
      uint64_t v22 = *(void *)(a1 + 32);
      goto LABEL_42;
    }
    int v23 = v20 + 1;
    do
    {
      uint64_t v24 = *(void *)(a1 + 32);
      if (*(_DWORD *)v24)
      {
        --*(_DWORD *)v24;
        if (pthread_mutex_unlock((pthread_mutex_t *)(v24 + 8))) {
          __IOHIDSessionCreate_block_invoke_cold_1(&v30, context);
        }
      }
      --v23;
    }
    while (v23);
    _IOHIDEventSystemPropertyChanged(v17, (uint64_t)a4, cf1, (uint64_t)a3);
    uint64_t v22 = *(void *)(a1 + 32);
    if (!v21)
    {
LABEL_42:
      int v25 = *(_DWORD *)v22;
      if (!*(_DWORD *)v22) {
        return v9;
      }
      goto LABEL_43;
    }
    do
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(v22 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_4(&v30, context);
      }
      uint64_t v22 = *(void *)(a1 + 32);
      int v25 = *(_DWORD *)v22 + 1;
      *(_DWORD *)uint64_t v22 = v25;
      --v21;
    }
    while (v21);
    if (v25)
    {
LABEL_43:
      *(_DWORD *)uint64_t v22 = v25 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v22 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_1(&v30, context);
      }
    }
  }
  else
  {
    uint64_t v27 = _IOHIDLogCategory(2u);
    uint64_t v9 = 0;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t UUID = IOHIDEventSystemConnectionGetUUID((uint64_t)a4);
      *(_DWORD *)int context = 138412290;
      *(void *)&context[4] = UUID;
      _os_log_impl(&dword_18B46C000, v27, OS_LOG_TYPE_DEFAULT, "Insufficient permissions to set kIOHIDSessionCASecureLayerOnScreenKey for UUID: %@", context, 0xCu);
      return 0;
    }
  }
  return v9;
}

void _IOHIDEventSystemPropertyChanged(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  CFSetRef Copy = CFSetCreateCopy(v8, *(CFSetRef *)(a1 + 48));
  os_unfair_recursive_lock_unlock();
  if (*(void *)(a1 + 88))
  {
    CFSetRef v10 = *(const __CFSet **)(a1 + 32);
    if (v10)
    {
      if (CFSetContainsValue(v10, a3)) {
        (*(void (**)(void))(*(void *)(a1 + 88) + 16))();
      }
    }
  }
  if (Copy)
  {
    context[0] = a3;
    context[1] = a4;
    void context[2] = a2;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__PropertyChangedFunction, context);
    CFRelease(Copy);
  }
}

uint64_t _IOHIDEventSystemConnectionQueueStart(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 24)) {
    *(_DWORD *)(a1 + 128) = 1;
  }
  *(_DWORD *)(a1 + 264) &= ~2u;
  os_unfair_recursive_lock_unlock();
  CFTypeID v3 = (const void *)*MEMORY[0x1E4F1CFC8];

  return _IOHIDEventSystemSetPropertyForConnection(v2, @"IOHIDEventSystemClientIsUnresponsive", v3, (const void *)a1);
}

uint64_t IOHIDEventQueueStart(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 148) = 1;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventQueueStop(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 148) = 0;
  while (!_IODataQueueDequeue(*(void *)(a1 + 16), *(_DWORD *)(a1 + 56), 0))
    ++*(void *)(a1 + 168);

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOPSCopyPowerSourcesByTypePrecise(int a1, uint64_t *a2)
{
  uint64_t uint64 = 3758097084;
  PMQueue = getPMQueue();
  if (a2)
  {
    uint64_t v6 = PMQueue;
    if (PMQueue)
    {
      mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
      if (mach_service)
      {
        CFAllocatorRef v8 = mach_service;
        xpc_connection_set_target_queue(mach_service, v6);
        xpc_connection_set_event_handler(v8, &__block_literal_global_95);
        xpc_connection_resume(v8);
        xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
        if (v9)
        {
          CFSetRef v10 = v9;
          xpc_dictionary_set_uint64(v9, "powerInfoPrecise", a1);
          xpc_object_t v11 = xpc_connection_send_message_with_reply_sync(v8, v10);
          if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590])
          {
            uint64_t uint64 = xpc_dictionary_get_uint64(v11, "returnCode");
            if (!uint64)
            {
              xpc_dictionary_get_value(v11, "powerInfoPrecise");
              *a2 = _CFXPCCreateCFObjectFromXPCObject();
            }
          }
          if (v11) {
            xpc_release(v11);
          }
          xpc_release(v10);
        }
        else
        {
          BOOL v20 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
          uint64_t uint64 = 3758097086;
          if (v20) {
            IOPSGaugingMitigationGetState_cold_2(v20, v21, v22, v23, v24, v25, v26, v27);
          }
        }
        xpc_release(v8);
      }
      else
      {
        BOOL v12 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        uint64_t uint64 = 3758097087;
        if (v12) {
          IOPSGaugingMitigationGetState_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
        }
      }
    }
  }
  return uint64;
}

IOReturn IOPMAssertionCreateWithName(CFStringRef AssertionType, IOPMAssertionLevel AssertionLevel, CFStringRef AssertionName, IOPMAssertionID *AssertionID)
{
  IOReturn v4 = -536870212;
  IOPMAssertionLevel valuePtr = AssertionLevel;
  if (AssertionType && AssertionName && AssertionID)
  {
    CFNumberRef v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    CFTypeID TypeID = CFNumberGetTypeID();
    if (v8)
    {
      if (CFGetTypeID(v8) == TypeID)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (Mutable)
        {
          xpc_object_t v11 = Mutable;
          CFDictionarySetValue(Mutable, @"AssertType", AssertionType);
          CFDictionarySetValue(v11, @"AssertName", AssertionName);
          CFDictionarySetValue(v11, @"AssertLevel", v8);
          CFRelease(v8);
          IOReturn v4 = IOPMAssertionCreateWithProperties(v11, AssertionID);
          CFRelease(v11);
        }
      }
    }
  }
  else
  {
    BOOL v12 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    IOReturn v4 = -536870206;
    if (v12) {
      IOPMAssertionCreateWithName_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  return v4;
}

CFArrayRef IOPSCopyPowerSourcesByType(int a1)
{
  int v9 = 0;
  if (_pm_connect(&v9)) {
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  mach_vm_size_t v7 = 0;
  CFNumberRef v8 = 0;
  int v6 = 0;
  io_ps_copy_powersources_info(v9, a1, &v8, &v7, &v6);
  CFDataRef v3 = CFDataCreate(0, v8, v7);
  if (v3)
  {
    CFDataRef v4 = v3;
    CFPropertyListRef v2 = CFPropertyListCreateWithData(0, v3, 0, 0, 0);
    CFRelease(v4);
  }
  else
  {
    CFPropertyListRef v2 = 0;
  }
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v8, v7);
  if (!v2) {
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  return (CFArrayRef)v2;
}

uint64_t io_ps_copy_powersources_info(int a1, int a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)&msg[20] = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  *(_OWORD *)&msg[4] = 0u;
  *(void *)&msg[24] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg[32] = a2;
  mach_port_name_t special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)mach_msg_header_t msg = 5395;
  *(void *)&msg[16] = 0x11D3E00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_name_t special_reply_port = *(_DWORD *)&msg[12];
  }
  uint64_t v10 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x24u, 0x44u, special_reply_port, 0, 0);
  uint64_t v11 = v10;
  if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
  {
    if (!v10)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        uint64_t v11 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 73122)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            uint64_t v11 = 4294966996;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8]) {
                uint64_t v11 = 4294966996;
              }
              else {
                uint64_t v11 = *(unsigned int *)&msg[32];
              }
            }
          }
          else
          {
            uint64_t v11 = 4294966996;
          }
          goto LABEL_24;
        }
        uint64_t v11 = 4294966996;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 60 && !*(_DWORD *)&msg[8] && BYTE3(v15) == 1)
        {
          int v12 = DWORD1(v15);
          if (DWORD1(v15) == v16)
          {
            uint64_t v11 = 0;
            *a3 = *(void *)&msg[28];
            *a4 = v12;
            *a5 = DWORD1(v16);
            return v11;
          }
        }
      }
      else
      {
        uint64_t v11 = 4294966995;
      }
LABEL_24:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v11;
    }
    mig_dealloc_special_reply_port();
  }
  return v11;
}

uint64_t releaseAsyncAssertion(int a1)
{
  uint64_t v7 = 0;
  CFNumberRef v8 = &v7;
  uint64_t v9 = 0x2000000000;
  int v10 = 0;
  PMQueue = getPMQueue();
  if (!PMQueue) {
    *((_DWORD *)v8 + 6) = -536870199;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __releaseAsyncAssertion_block_invoke;
  v5[3] = &unk_1E548B1B8;
  v5[4] = &v7;
  int v6 = a1;
  dispatch_sync(PMQueue, v5);
  uint64_t v3 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

IOReturn IOPMCancelScheduledPowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type)
{
  mach_port_t v14 = 0;
  CFTypeRef cf = 0;
  if ((inputsValid(time_to_wake, type) & 1) == 0)
  {
    CFDataRef v6 = 0;
    goto LABEL_6;
  }
  if (_pm_connect(&v14))
  {
    CFDataRef v6 = 0;
LABEL_4:
    IOReturn v7 = -536870199;
LABEL_7:
    IOReturn v15 = v7;
    goto LABEL_8;
  }
  IOReturn v15 = _IOPMCreatePowerOnDictionary(time_to_wake, (__CFString *)my_id, type, (__CFDictionary **)&cf);
  if (v15)
  {
    CFDataRef v6 = 0;
    goto LABEL_8;
  }
  CFDataRef Data = CFPropertyListCreateData(0, cf, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  CFDataRef v6 = Data;
  if (!Data)
  {
LABEL_6:
    IOReturn v7 = -536870206;
    goto LABEL_7;
  }
  mach_port_t v10 = v14;
  BytePtr = CFDataGetBytePtr(Data);
  int Length = CFDataGetLength(v6);
  if (io_pm_schedule_power_event(v10, (uint64_t)BytePtr, Length, 0, &v15)) {
    goto LABEL_4;
  }
LABEL_8:
  if (v14) {
    _pm_disconnect();
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v6) {
    CFRelease(v6);
  }
  return v15;
}

uint64_t inputsValid(const void *a1, const void *a2)
{
  CFTypeID TypeID = CFDateGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID
    || CFEqual(a2, @"WakeImmediate")
    || (uint64_t result = CFEqual(a2, @"PowerOnImmediate"), result))
  {
    CFTypeID v6 = CFStringGetTypeID();
    if (a2 && CFGetTypeID(a2) == v6)
    {
      if (CFEqual(a2, @"wake")) {
        return 1;
      }
      if (CFEqual(a2, @"poweron")) {
        return 1;
      }
      if (CFEqual(a2, @"wakepoweron")) {
        return 1;
      }
      if (CFEqual(a2, @"sleep")) {
        return 1;
      }
      if (CFEqual(a2, @"shutdown")) {
        return 1;
      }
      if (CFEqual(a2, @"restart")) {
        return 1;
      }
      if (CFEqual(a2, @"WakeImmediate")) {
        return 1;
      }
      if (CFEqual(a2, @"PowerOnImmediate")) {
        return 1;
      }
      if (CFEqual(a2, @"WakeRelativeToSleep")) {
        return 1;
      }
      if (CFEqual(a2, @"PowerRelativeToShutdown")) {
        return 1;
      }
      if (CFEqual(a2, @"MaintenanceImmediate")) {
        return 1;
      }
      uint64_t result = CFEqual(a2, @"SleepServiceImmediate");
      if (result) {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IOPMRequestSysWake(const void *a1)
{
  mach_port_t v20 = 0;
  CFTypeRef cf = 0;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!a1
    || CFGetTypeID(a1) != TypeID
    || (CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"time"),
        CFDataRef v4 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, @"scheduledby"),
        ipc_space_t v5 = CFDictionaryGetValue((CFDictionaryRef)a1, @"leeway"),
        CFTypeID v6 = CFDateGetTypeID(),
        !Value)
    || CFGetTypeID(Value) != v6
    || (CFTypeID v7 = CFStringGetTypeID(), !v4)
    || CFGetTypeID(v4) != v7
    || v5 && (CFTypeID v8 = CFNumberGetTypeID(), CFGetTypeID(v5) != v8))
  {
    CFDataRef v11 = 0;
    goto LABEL_16;
  }
  uint64_t v9 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (CFDictionaryGetValue((CFDictionaryRef)a1, @"UserVisible") == (const void *)*MEMORY[0x1E4F1CFD0]) {
    mach_port_t v10 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    mach_port_t v10 = v9;
  }
  if (_pm_connect(&v20))
  {
    CFDataRef v11 = 0;
LABEL_14:
    unsigned int v12 = -536870199;
LABEL_17:
    unsigned int v21 = v12;
    goto LABEL_18;
  }
  unsigned int v21 = _IOPMCreatePowerOnDictionary(Value, v4, @"wake", (__CFDictionary **)&cf);
  if (v21)
  {
    CFDataRef v11 = 0;
    goto LABEL_18;
  }
  mach_port_t v14 = (__CFDictionary *)cf;
  if (v5) {
    CFDictionaryAddValue((CFMutableDictionaryRef)cf, @"leeway", v5);
  }
  CFDictionaryAddValue(v14, @"UserVisible", v10);
  CFDataRef Data = CFPropertyListCreateData(0, v14, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  CFDataRef v11 = Data;
  if (!Data)
  {
LABEL_16:
    unsigned int v12 = -536870206;
    goto LABEL_17;
  }
  mach_port_t v16 = v20;
  BytePtr = CFDataGetBytePtr(Data);
  int Length = CFDataGetLength(v11);
  if (io_pm_schedule_power_event(v16, (uint64_t)BytePtr, Length, 1, (int *)&v21)) {
    goto LABEL_14;
  }
LABEL_18:
  if (v20) {
    _pm_disconnect();
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v21;
}

uint64_t io_pm_schedule_power_event(mach_port_t a1, uint64_t a2, int a3, int a4, int *a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v13 = 1;
  uint64_t v14 = a2;
  int v15 = 16777472;
  int v16 = a3;
  uint64_t v17 = *MEMORY[0x1E4F14068];
  int v18 = a3;
  int v19 = a4;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x11D2B00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v8 = mach_msg(&msg, 3162115, 0x3Cu, 0x30u, special_reply_port, 0, 0);
  uint64_t v9 = v8;
  if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
  {
    if (!v8)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v9 = 4294966988;
      }
      else if (msg.msgh_id == 73103)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              uint64_t v9 = HIDWORD(v14);
              if (!HIDWORD(v14))
              {
                *a5 = v15;
                return v9;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port) {
              BOOL v10 = 1;
            }
            else {
              BOOL v10 = HIDWORD(v14) == 0;
            }
            if (v10) {
              uint64_t v9 = 4294966996;
            }
            else {
              uint64_t v9 = HIDWORD(v14);
            }
            goto LABEL_22;
          }
        }
        uint64_t v9 = 4294966996;
      }
      else
      {
        uint64_t v9 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v9;
    }
    mig_dealloc_special_reply_port();
  }
  return v9;
}

uint64_t _IOPMCreatePowerOnDictionary(const void *a1, __CFString *a2, const void *a3, __CFDictionary **a4)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (a2)
  {
    if (CFGetTypeID(a2) == TypeID) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = 3758097085;
  if (v9) {
    CFDataRef v11 = v9;
  }
  else {
    CFDataRef v11 = &stru_1ED870660;
  }
  CFTypeID v12 = CFDateGetTypeID();
  if (a1 && CFGetTypeID(a1) == v12)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      uint64_t v14 = Mutable;
      CFDictionaryAddValue(Mutable, @"time", a1);
      CFDictionaryAddValue(v14, @"scheduledby", v11);
      CFDictionaryAddValue(v14, @"eventtype", a3);
      uint64_t v10 = 0;
      *a4 = v14;
    }
  }
  else
  {
    asl_log(0, 0, 3, "_IOPMCreatePowerOnDictionary received invalid date\n");
    return 3758097090;
  }
  return v10;
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  IOReturn v1 = -536870199;
  IOReturn v7 = -536870212;
  int v6 = 0;
  uint64_t v5 = 0;
  int v4 = 0;
  if (!AssertionID) {
    return -536870206;
  }
  if (AssertionID < 0x10000 || !gAssertionsDict)
  {
    if (!pm_connect_init(&v6))
    {
      if (io_pm_assertion_retain_release(v6, AssertionID, -1, &v4, (_DWORD *)&v5 + 1, &v5, &v7)) {
        IOReturn v7 = -536870199;
      }
      if (v4) {
        entr_act_modify();
      }
      else {
        entr_act_end();
      }
      _pm_disconnect();
      return v7;
    }
    return v1;
  }

  return releaseAsyncAssertion(AssertionID);
}

uint64_t IOPMAssertionDeclareSystemActivityWithProperties(const __CFDictionary *a1, int *a2, int *a3)
{
  mach_port_t v16 = 0;
  unsigned int v17 = -536870212;
  if (!a1 || !a2 || !a3) {
    goto LABEL_16;
  }
  if (pm_connect_init(&v16))
  {
    unsigned int v17 = -536870199;
    goto LABEL_17;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(a1, @"AssertName");
  CFTypeID TypeID = CFStringGetTypeID();
  if (!Value) {
    goto LABEL_16;
  }
  if (CFGetTypeID(Value) != TypeID) {
    goto LABEL_16;
  }
  uint64_t v8 = CFDictionaryGetValue(a1, @"AssertType");
  CFTypeID v9 = CFStringGetTypeID();
  if (v8)
  {
    if (CFGetTypeID(v8) == v9) {
      goto LABEL_16;
    }
  }
  if (collectBackTrace) {
    saveBackTrace(a1);
  }
  CFDataRef Data = CFPropertyListCreateData(0, a1, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (Data)
  {
    CFDataRef v11 = Data;
    mach_port_t v12 = v16;
    BytePtr = CFDataGetBytePtr(Data);
    int Length = CFDataGetLength(v11);
    if (io_pm_declare_system_active(v12, a3, (uint64_t)BytePtr, Length, a2, &v17)) {
      unsigned int v17 = -536870199;
    }
    CFRelease(v11);
  }
  else
  {
LABEL_16:
    unsigned int v17 = -536870206;
  }
LABEL_17:
  if (v16) {
    _pm_disconnect();
  }
  return v17;
}

IOReturn IOPMAssertionCreateWithProperties(CFDictionaryRef AssertionProperties, IOPMAssertionID *AssertionID)
{
  mach_port_t v58 = 0;
  IOReturn v59 = -536870212;
  int v56 = -1;
  int v57 = 0;
  if (!AssertionProperties || !AssertionID)
  {
    BOOL v17 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v17) {
      IOPMAssertionCreateWithProperties_cold_6(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    goto LABEL_15;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(AssertionProperties, @"AssertType");
  uint64_t v5 = CFDictionaryGetValue(AssertionProperties, @"AssertName");
  CFTypeID TypeID = CFStringGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID || (CFTypeID v7 = CFStringGetTypeID(), !v5) || CFGetTypeID(v5) != v7)
  {
    BOOL v25 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v25) {
      IOPMAssertionCreateWithProperties_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
    }
LABEL_15:
    mach_port_t v16 = 0;
LABEL_16:
    IOReturn v59 = -536870206;
    goto LABEL_17;
  }
  if (pm_connect_init(&v58))
  {
    BOOL v8 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v8) {
      IOPMAssertionCreateWithProperties_cold_5(v8, v9, v10, v11, v12, v13, v14, v15);
    }
LABEL_10:
    mach_port_t v16 = 0;
    IOReturn v59 = -536870199;
    goto LABEL_17;
  }
  CFTypeID v34 = CFStringGetTypeID();
  if (CFGetTypeID(Value) == v34
    && CFEqual(Value, @"EnableIdleSleep")
    && !IOPMAssertionCreateWithProperties_resyncToken)
  {
    IOPMAssertionCreateWithProperties_resyncCFSetRef Copy = (uint64_t)CFDictionaryCreateMutableCopy(0, 0, AssertionProperties);
    notify_register_dispatch("com.apple.system.powermanagement.assertionresync", &IOPMAssertionCreateWithProperties_resyncToken, MEMORY[0x1E4F14428], &__block_literal_global_178);
  }
  CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue(AssertionProperties, @"AssertLevel");
  CFTypeID v36 = CFNumberGetTypeID();
  if (v35 && CFGetTypeID(v35) == v36)
  {
    int valuePtr = 0;
    CFNumberGetValue(v35, kCFNumberIntType, &valuePtr);
    BOOL v37 = valuePtr != 0;
  }
  else
  {
    BOOL v37 = 1;
  }
  mach_port_t v16 = 0;
  if (collectBackTrace && v37)
  {
    MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(0, 0, AssertionProperties);
    if (!MutableCopy)
    {
      BOOL v47 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v47) {
        IOPMAssertionCreateWithProperties_cold_2(v47, v48, v49, v50, v51, v52, v53, v54);
      }
      goto LABEL_10;
    }
    mach_port_t v16 = MutableCopy;
    saveBackTrace(MutableCopy);
  }
  CFTypeID v39 = CFStringGetTypeID();
  if (CFGetTypeID(Value) == v39
    && (CFEqual(Value, @"PreventUserIdleSystemSleep")
     || CFEqual(Value, @"NoIdleSleepAssertion")
     || CFEqual(Value, @"SystemIsActive")))
  {
    if (!v16) {
      mach_port_t v16 = CFDictionaryCreateMutableCopy(0, 0, AssertionProperties);
    }
    if (!CFDictionaryContainsKey(v16, @"AllowsDeviceRestart")) {
      CFDictionarySetValue(v16, @"AllowsDeviceRestart", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
  }
  if (v16) {
    CFDictionaryRef v40 = v16;
  }
  else {
    CFDictionaryRef v40 = AssertionProperties;
  }
  CFDataRef Data = CFPropertyListCreateData(0, v40, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (!Data) {
    goto LABEL_16;
  }
  CFDataRef v42 = Data;
  if (createAsyncAssertion(v40, (uint64_t)AssertionID))
  {
    IOReturn v59 = 0;
    int v56 = 0x10000;
  }
  else
  {
    mach_port_t v44 = v58;
    BytePtr = CFDataGetBytePtr(v42);
    int Length = CFDataGetLength(v42);
    if (io_pm_assertion_create(v44, (uint64_t)BytePtr, Length, (int *)AssertionID, &v57, &v56, &v59))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        IOPMAssertionCreateWithProperties_cold_4();
      }
      IOReturn v59 = -536870199;
      goto LABEL_57;
    }
    if (v59 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      IOPMAssertionCreateWithProperties_cold_3();
    }
  }
  if (v56) {
    BOOL v43 = v37;
  }
  else {
    BOOL v43 = 0;
  }
  if (v43) {
    entr_act_begin();
  }
LABEL_57:
  CFRelease(v42);
LABEL_17:
  if (v58) {
    _pm_disconnect();
  }
  if (v16) {
    CFRelease(v16);
  }
  return v59;
}

IOReturn IOPMAssertionSetProperty(IOPMAssertionID theAssertion, CFStringRef theProperty, CFTypeRef theValue)
{
  mach_port_t v20 = 0;
  uint64_t v19 = 0;
  int v18 = -1;
  if (!theAssertion)
  {
    int v6 = -536870206;
    goto LABEL_6;
  }
  if (theAssertion >= 0x10000 && gAssertionsDict)
  {
    IOReturn v21 = setAsyncAssertionProperties((uint64_t)theProperty, (uint64_t)theValue, theAssertion);
    goto LABEL_8;
  }
  IOReturn v21 = pm_connect_init(&v20);
  if (!v21)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      uint64_t v9 = Mutable;
      CFDictionarySetValue(Mutable, theProperty, theValue);
      if (CFEqual(theProperty, @"AssertLevel")
        && (CFTypeID TypeID = CFNumberGetTypeID(), theValue)
        && CFGetTypeID(theValue) == TypeID)
      {
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)theValue, kCFNumberIntType, &valuePtr);
        BOOL v10 = valuePtr == 0;
        BOOL v11 = valuePtr == 255;
        if (valuePtr == 255 && collectBackTrace)
        {
          saveBackTrace(v9);
          BOOL v10 = 0;
          BOOL v11 = 1;
        }
      }
      else
      {
        BOOL v10 = 0;
        BOOL v11 = 0;
      }
      CFDataRef Data = CFPropertyListCreateData(0, v9, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      CFRelease(v9);
      mach_port_t v13 = v20;
      BytePtr = CFDataGetBytePtr(Data);
      int Length = CFDataGetLength(Data);
      if (io_pm_assertion_set_properties(v13, theAssertion, (uint64_t)BytePtr, Length, (int *)&v19 + 1, &v19, &v18, &v21))
      {
        IOReturn v21 = -536870199;
      }
      else if (v18)
      {
        if (v11)
        {
          entr_act_begin();
        }
        else if (v10)
        {
          entr_act_end();
        }
      }
      if (Data) {
        CFRelease(Data);
      }
      goto LABEL_8;
    }
    int v6 = -536870211;
LABEL_6:
    IOReturn v21 = v6;
  }
LABEL_8:
  if (v20) {
    _pm_disconnect();
  }
  return v21;
}

uint64_t _pm_connect(_DWORD *a1)
{
  uint64_t v1 = 3758097084;
  if (!a1) {
    return 3758097090;
  }
  if (powerd_connection)
  {
    uint64_t v1 = 0;
    *a1 = powerd_connection;
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)&lock);
    if (powerd_connection)
    {
      uint64_t v1 = 0;
      *a1 = powerd_connection;
    }
    else
    {
      int v3 = bootstrap_look_up2();
      if (v3)
      {
        powerd_connection = 0;
        *a1 = 0;
        asl_log(0, 0, 3, "bootstrap_look_up2 failed with 0x%x\n", v3);
      }
      else
      {
        *a1 = powerd_connection;
        uint64_t v1 = 0;
        if (pthread_atfork(0, 0, _reset_connection)) {
          powerd_connection = 0;
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&lock);
  }
  return v1;
}

uint64_t _pm_disconnect()
{
  return 0;
}

uint64_t pm_connect_init(_DWORD *a1)
{
  if (!pm_connect_init_collectBackTraceToken)
  {
    notify_register_dispatch("com.apple.powermanagement.collectbt", &pm_connect_init_collectBackTraceToken, MEMORY[0x1E4F14428], &__block_literal_global_224);
    notify_get_state(pm_connect_init_collectBackTraceToken, (uint64_t *)&collectBackTrace);
  }

  return _pm_connect(a1);
}

uint64_t io_pm_assertion_set_properties(mach_port_t a1, int a2, uint64_t a3, int a4, int *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  int v21 = 1;
  uint64_t v22 = a3;
  int v23 = 16777472;
  int v24 = a4;
  uint64_t v25 = *MEMORY[0x1E4F14068];
  int v26 = a2;
  int v27 = a4;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&v20.msgh_bits = 2147489043;
  v20.mach_port_t msgh_remote_port = a1;
  v20.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&v20.msgh_voucher_port = 0x11D3000000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v20);
    mach_port_t special_reply_port = v20.msgh_local_port;
  }
  uint64_t v14 = mach_msg(&v20, 3162115, 0x3Cu, 0x3Cu, special_reply_port, 0, 0);
  uint64_t v15 = v14;
  if ((v14 - 268435458) > 0xE || ((1 << (v14 - 2)) & 0x4003) == 0)
  {
    if (!v14)
    {
      if (v20.msgh_id == 71)
      {
        uint64_t v15 = 4294966988;
      }
      else if (v20.msgh_id == 73108)
      {
        if ((v20.msgh_bits & 0x80000000) == 0)
        {
          if (v20.msgh_size == 52)
          {
            if (!v20.msgh_remote_port)
            {
              uint64_t v15 = HIDWORD(v22);
              if (!HIDWORD(v22))
              {
                int v18 = v24;
                *a5 = v23;
                *a6 = v18;
                int v19 = HIDWORD(v25);
                *a7 = v25;
                *a8 = v19;
                return v15;
              }
              goto LABEL_22;
            }
          }
          else if (v20.msgh_size == 36)
          {
            if (v20.msgh_remote_port) {
              BOOL v16 = 1;
            }
            else {
              BOOL v16 = HIDWORD(v22) == 0;
            }
            if (v16) {
              uint64_t v15 = 4294966996;
            }
            else {
              uint64_t v15 = HIDWORD(v22);
            }
            goto LABEL_22;
          }
        }
        uint64_t v15 = 4294966996;
      }
      else
      {
        uint64_t v15 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&v20);
      return v15;
    }
    mig_dealloc_special_reply_port();
  }
  return v15;
}

BOOL createAsyncAssertion(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v18 = 0;
  int v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 1;
  if (gAsyncModeDisableOverride)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        createAsyncAssertion_cold_2();
      }
    }
    else
    {
      BOOL v8 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
      if (v8) {
        createAsyncAssertion_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
      }
    }
    goto LABEL_15;
  }
  if (!gAsyncMode)
  {
    if (checkFeatureEnabled_onceToken == -1)
    {
      BOOL v7 = 0;
      goto LABEL_16;
    }
    dispatch_once(&checkFeatureEnabled_onceToken, &__block_literal_global_15);
    goto LABEL_15;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(a1, @"AssertType");
  CFTypeID TypeID = CFStringGetTypeID();
  if (!Value
    || CFGetTypeID(Value) != TypeID
    || !CFEqual(Value, @"PreventUserIdleSystemSleep") && !CFEqual(Value, @"NoIdleSleepAssertion")
    || CFDictionaryContainsKey(a1, @"ResourcesUsed")
    || (PMQueue = getPMQueue()) == 0)
  {
LABEL_15:
    BOOL v7 = 0;
    goto LABEL_16;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __createAsyncAssertion_block_invoke;
  block[3] = &unk_1E548B190;
  block[4] = &v18;
  void block[5] = a1;
  void block[6] = a2;
  dispatch_sync(PMQueue, block);
  BOOL v7 = *((unsigned char *)v19 + 24) != 0;
LABEL_16:
  _Block_object_dispose(&v18, 8);
  return v7;
}

CFDictionaryRef IOPSCopyExternalPowerAdapterDetails(void)
{
  PMQueue = getPMQueue();
  if (PMQueue)
  {
    uint64_t v1 = PMQueue;
    mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      int v3 = mach_service;
      xpc_connection_set_target_queue(mach_service, v1);
      xpc_connection_set_event_handler(v3, &__block_literal_global_4);
      xpc_connection_resume(v3);
      xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
      if (!v4)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          IOPSCopyExternalPowerAdapterDetails_cold_2();
        }
        CFDictionaryRef v7 = 0;
        goto LABEL_14;
      }
      uint64_t v5 = v4;
      xpc_dictionary_set_string(v4, "adapterDetails", "true");
      xpc_object_t v6 = xpc_connection_send_message_with_reply_sync(v3, v5);
      if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590] && xpc_dictionary_get_value(v6, "adapterDetails"))
      {
        CFDictionaryRef v7 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
        if (!v6) {
          goto LABEL_7;
        }
      }
      else
      {
        CFDictionaryRef v7 = 0;
        if (!v6)
        {
LABEL_7:
          xpc_release(v5);
LABEL_14:
          xpc_release(v3);
          return v7;
        }
      }
      xpc_release(v6);
      goto LABEL_7;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      IOPSCopyExternalPowerAdapterDetails_cold_1();
    }
  }
  return 0;
}

uint64_t getPMQueue()
{
  uint64_t result = getPMQueue_pmQueue;
  if (!getPMQueue_pmQueue)
  {
    if (getPMQueue_pmQueue_pred != -1) {
      dispatch_once(&getPMQueue_pmQueue_pred, &__block_literal_global_6);
    }
    uint64_t result = getPMQueue_pmQueue;
    if (!getPMQueue_pmQueue)
    {
      BOOL v1 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v1) {
        getPMQueue_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
      }
      return 0;
    }
  }
  return result;
}

uint64_t io_pm_declare_system_active(mach_port_t a1, int *a2, uint64_t a3, int a4, int *a5, _DWORD *a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v17 = 1;
  uint64_t v18 = a3;
  int v19 = 16777472;
  int v20 = a4;
  uint64_t v21 = *MEMORY[0x1E4F14068];
  int v22 = *a2;
  int v23 = a4;
  int v24 = *a5;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&msg.msgh_bits = 2147489043;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&msg.msgh_voucher_port = 0x11D3300000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v11 = mach_msg(&msg, 3162115, 0x40u, 0x38u, special_reply_port, 0, 0);
  uint64_t v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!v11)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v12 = 4294966988;
      }
      else if (msg.msgh_id == 73111)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 48)
          {
            if (!msg.msgh_remote_port)
            {
              uint64_t v12 = HIDWORD(v18);
              if (!HIDWORD(v18))
              {
                int v15 = v20;
                *a2 = v19;
                *a5 = v15;
                *a6 = v21;
                return v12;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port) {
              BOOL v13 = 1;
            }
            else {
              BOOL v13 = HIDWORD(v18) == 0;
            }
            if (v13) {
              uint64_t v12 = 4294966996;
            }
            else {
              uint64_t v12 = HIDWORD(v18);
            }
            goto LABEL_22;
          }
        }
        uint64_t v12 = 4294966996;
      }
      else
      {
        uint64_t v12 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  return v12;
}

uint64_t io_pm_assertion_retain_release(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  *(_OWORD *)&msg[20] = 0u;
  long long v20 = 0u;
  uint64_t v21 = 0;
  *(_OWORD *)&msg[4] = 0u;
  *(void *)&msg[24] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg[32] = a2;
  LODWORD(v20) = a3;
  mach_port_name_t special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)mach_msg_header_t msg = 5395;
  *(void *)&msg[16] = 0x11D3100000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_name_t special_reply_port = *(_DWORD *)&msg[12];
  }
  uint64_t v13 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x28u, 0x3Cu, special_reply_port, 0, 0);
  uint64_t v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!v13)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        uint64_t v14 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 73109)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 52)
          {
            if (!*(_DWORD *)&msg[8])
            {
              uint64_t v14 = *(unsigned int *)&msg[32];
              if (!*(_DWORD *)&msg[32])
              {
                int v17 = DWORD1(v20);
                *a4 = v20;
                *a5 = v17;
                int v18 = HIDWORD(v20);
                *a6 = DWORD2(v20);
                *a7 = v18;
                return v14;
              }
              goto LABEL_22;
            }
          }
          else if (*(_DWORD *)&msg[4] == 36)
          {
            if (*(_DWORD *)&msg[8]) {
              BOOL v15 = 1;
            }
            else {
              BOOL v15 = *(_DWORD *)&msg[32] == 0;
            }
            if (v15) {
              uint64_t v14 = 4294966996;
            }
            else {
              uint64_t v14 = *(unsigned int *)&msg[32];
            }
            goto LABEL_22;
          }
        }
        uint64_t v14 = 4294966996;
      }
      else
      {
        uint64_t v14 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  return v14;
}

uint64_t io_pm_assertion_create(mach_port_t a1, uint64_t a2, int a3, int *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  msg.msgh_id = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  *(_OWORD *)&msg.msgh_unsigned int size = 0u;
  int v20 = 1;
  uint64_t v21 = a2;
  int v22 = 16777472;
  int v23 = a3;
  uint64_t v24 = *MEMORY[0x1E4F14068];
  LODWORD(v25) = a3;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(void *)&msg.msgh_voucher_port = 0x11D2F00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t special_reply_port = msg.msgh_local_port;
  }
  uint64_t v13 = mach_msg(&msg, 3162115, 0x38u, 0x3Cu, special_reply_port, 0, 0);
  uint64_t v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!v13)
    {
      if (msg.msgh_id == 71)
      {
        uint64_t v14 = 4294966988;
      }
      else if (msg.msgh_id == 73107)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 52)
          {
            if (!msg.msgh_remote_port)
            {
              uint64_t v14 = HIDWORD(v21);
              if (!HIDWORD(v21))
              {
                int v17 = v23;
                *a4 = v22;
                *a5 = v17;
                int v18 = HIDWORD(v24);
                *a6 = v24;
                *a7 = v18;
                return v14;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port) {
              BOOL v15 = 1;
            }
            else {
              BOOL v15 = HIDWORD(v21) == 0;
            }
            if (v15) {
              uint64_t v14 = 4294966996;
            }
            else {
              uint64_t v14 = HIDWORD(v21);
            }
            goto LABEL_22;
          }
        }
        uint64_t v14 = 4294966996;
      }
      else
      {
        uint64_t v14 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  return v14;
}

void __hid_dispatch_queue_context_destructor(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void (*)(void))a1[3];
    if (v2) {
      v2(a1[2]);
    }
    free(a1);
  }
}

void __IOHIDServiceQueueContextDestructor(uint64_t a1)
{
  if (a1)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
    free((void *)a1);
  }
}

void _IOGetWithUUIDKey(CFStringRef uuidStr, uint64_t a2, uint64_t a3)
{
  CFUUIDRef v5 = CFUUIDCreateFromString(0, uuidStr);
  if (v5)
  {
    CFUUIDRef v6 = v5;
    if (CFEqual(v5, *(CFTypeRef *)(a3 + 8))) {
      *(void *)a3 = a2;
    }
    CFRelease(v6);
  }
}

uint64_t __IOHIDServiceInit(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a2;
  long long v151 = 0u;
  long long v152 = 0u;
  long long v149 = 0u;
  long long v150 = 0u;
  long long v147 = 0u;
  long long v148 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  long long v143 = 0u;
  long long v144 = 0u;
  long long v141 = 0u;
  long long v142 = 0u;
  long long v139 = 0u;
  long long v140 = 0u;
  *(_OWORD *)v137 = 0u;
  long long v138 = 0u;
  memset(name, 0, sizeof(name));
  uint64_t v4 = mach_absolute_time();
  __sprintf_chk(v137, 0, 0x100uLL, "0x%llx", v2);
  *(void *)(a1 + 400) = v2;
  IORegistryEntryGetName(*(_DWORD *)(a1 + 16), name);
  if (!name[0])
  {
    IOObjectGetClass(*(_DWORD *)(a1 + 16), name);
    uint64_t v2 = valuePtr;
  }
  __sprintf_chk(v137, 0, 0x100uLL, "IOHIDService(%p) id:0x%llx name:%s", (const void *)a1, v2, name);
  CFUUIDRef v5 = malloc_type_calloc(1uLL, 0x48uLL, 0x10000400131AABDuLL);
  *(void *)(a1 + 72) = v5;
  if (v5)
  {
    *(_DWORD *)(a1 + 456) = 0;
    v135.__sig = 0;
    *(void *)v135.__opaque = 0;
    if (pthread_mutexattr_init(&v135)) {
      __IOHIDServiceInit_cold_4(&v133, buf);
    }
    pthread_mutexattr_settype(&v135, 2);
    if (pthread_mutex_init((pthread_mutex_t *)(*(void *)(a1 + 72) + 8), &v135)) {
      __IOHIDServiceInit_cold_3(&v133, buf);
    }
    pthread_mutexattr_destroy(&v135);
    CFUUIDRef v6 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    uint64_t v7 = hid_dispatch_queue_create_with_context_destructor(v137, v6, kIOHIDServiceInterruptWorkloop, (uint64_t)__IOHIDServiceQueueWillExecute, (uint64_t)__IOHIDServiceQueueDidExecute, *(void *)(a1 + 72), __IOHIDServiceQueueContextDestructor);
    *(void *)(a1 + 80) = v7;
    if (v7)
    {
      uint64_t v8 = IONotificationPortCreate(0);
      *(void *)(a1 + 88) = v8;
      if (v8)
      {
        v128 = (uint64_t *)(a1 + 400);
        io_service_t v9 = *(_DWORD *)(a1 + 16);
        if (v9
          && IOServiceAddInterestNotification(v8, v9, "IOGeneralInterest", (IOServiceInterestCallback)__IOHIDServiceNotification, (void *)a1, (io_object_t *)(a1 + 96)))
        {
          v124 = _IOHIDLogCategory(6u);
          if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR)) {
            __IOHIDServiceInit_cold_2();
          }
        }
        else
        {
          CFSetCallBacks callBacks = *(CFSetCallBacks *)byte_1ED86F960;
          CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)a1);
          CFMutableSetRef v11 = CFSetCreateMutable(v10, 0, &callBacks);
          *(void *)(a1 + 104) = v11;
          if (v11)
          {
            CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
            CFMutableSetRef v13 = CFSetCreateMutable(v12, 0, &callBacks);
            *(void *)(a1 + 112) = v13;
            if (v13)
            {
              CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
              CFMutableSetRef v15 = CFSetCreateMutable(v14, 0, &callBacks);
              *(void *)(a1 + 120) = v15;
              if (v15)
              {
                CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
                CFNumberRef v17 = CFNumberCreate(v16, kCFNumberSInt64Type, &valuePtr);
                *(void *)(a1 + 48) = v17;
                if (v17)
                {
                  CFAllocatorRef v18 = CFGetAllocator((CFTypeRef)a1);
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  *(void *)(a1 + 240) = Mutable;
                  if (Mutable)
                  {
                    CFAllocatorRef v20 = CFGetAllocator((CFTypeRef)a1);
                    CFMutableDictionaryRef v21 = CFDictionaryCreateMutable(v20, 15, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                    *(void *)(a1 + 312) = v21;
                    if (v21)
                    {
                      for (uint64_t i = 0; i != 15; ++i)
                        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 312), _servicePropertyCacheKeys[i], (const void *)defaultPropertyKeyValue);
                      CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
                      CFMutableArrayRef v24 = CFArrayCreateMutable(v23, 0, MEMORY[0x1E4F1D510]);
                      *(void *)(a1 + 248) = v24;
                      if (v24)
                      {
                        CFAllocatorRef v25 = CFGetAllocator((CFTypeRef)a1);
                        CFMutableSetRef v26 = CFSetCreateMutable(v25, 0, MEMORY[0x1E4F1D548]);
                        *(void *)(a1 + 264) = v26;
                        if (v26)
                        {
                          int v27 = malloc_type_malloc(0x18uLL, 0xC0040B8AA526DuLL);
                          *(void *)(a1 + 368) = v27;
                          if (v27)
                          {
                            *int v27 = 0;
                            v27[1] = 0;
                            v27[2] = 0;
                            uint64_t v28 = malloc_type_malloc(0x158uLL, 0x100004000313F17uLL);
                            *(void *)(a1 + 416) = v28;
                            if (v28)
                            {
                              v28[42] = 0;
                              *((_OWORD *)v28 + 19) = 0u;
                              *((_OWORD *)v28 + 20) = 0u;
                              *((_OWORD *)v28 + 17) = 0u;
                              *((_OWORD *)v28 + 18) = 0u;
                              *((_OWORD *)v28 + 15) = 0u;
                              *((_OWORD *)v28 + 16) = 0u;
                              *((_OWORD *)v28 + 13) = 0u;
                              *((_OWORD *)v28 + 14) = 0u;
                              *((_OWORD *)v28 + 11) = 0u;
                              *((_OWORD *)v28 + 12) = 0u;
                              *((_OWORD *)v28 + 9) = 0u;
                              *((_OWORD *)v28 + 10) = 0u;
                              *((_OWORD *)v28 + 7) = 0u;
                              *((_OWORD *)v28 + 8) = 0u;
                              *((_OWORD *)v28 + 5) = 0u;
                              *((_OWORD *)v28 + 6) = 0u;
                              *((_OWORD *)v28 + 3) = 0u;
                              *((_OWORD *)v28 + 4) = 0u;
                              *((_OWORD *)v28 + 1) = 0u;
                              *((_OWORD *)v28 + 2) = 0u;
                              *(_OWORD *)uint64_t v28 = 0u;
                              *(void *)(a1 + 272) = 0;
                              *(void *)(a1 + 288) = 0;
                              block[0] = MEMORY[0x1E4F143A8];
                              block[1] = 0x40000000;
                              block[2] = ____IOHIDServiceInit_block_invoke;
                              block[3] = &__block_descriptor_tmp_196;
                              block[4] = a1;
                              *(void *)(a1 + 424) = dispatch_block_create((dispatch_block_flags_t)0, block);
                              v129[0] = MEMORY[0x1E4F143A8];
                              v129[1] = 0x40000000;
                              v129[2] = ____IOHIDServiceInit_block_invoke_2;
                              v129[3] = &__block_descriptor_tmp_197;
                              v129[4] = a1;
                              *(void *)(a1 + 432) = dispatch_block_create((dispatch_block_flags_t)0, v129);
                              CFAllocatorRef v29 = CFGetAllocator((CFTypeRef)a1);
                              CFMutableArrayRef v30 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E4F1D510]);
                              *(void *)(a1 + 256) = v30;
                              if (v30)
                              {
                                *(_DWORD *)(a1 + 172) = 1;
                                uint64_t v31 = (const void *)*MEMORY[0x1E4F1D260];
                                uint64_t v32 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"Built-In", (const void *)*MEMORY[0x1E4F1D260]);
                                uint64_t v33 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
                                if (v32)
                                {
                                  CFTypeID v34 = v32;
                                  *(_DWORD *)(a1 + 284) = CFEqual(v32, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
                                  CFRelease(v34);
                                }
                                CFNumberRef v35 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"Hidden", v31);
                                if (v35)
                                {
                                  CFTypeID v36 = v35;
                                  *(_DWORD *)(a1 + 300) = CFEqual(v35, *v33);
                                  CFRelease(v36);
                                }
                                CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                                CFMutableDictionaryRef v37 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                                if (v37)
                                {
                                  uint64_t v38 = v37;
                                  CFTypeID v39 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"DeviceUsagePairs", v31);
                                  if (v39)
                                  {
                                    CFDictionaryRef v40 = v39;
                                    CFDictionaryAddValue(v38, @"DeviceUsagePairs", v39);
                                    CFRelease(v40);
                                  }
                                  uint64_t v41 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"Transport", v31);
                                  if (v41)
                                  {
                                    CFDataRef v42 = v41;
                                    CFDictionaryAddValue(v38, @"Transport", v41);
                                    CFRelease(v42);
                                  }
                                  BOOL v43 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"ProductID", v31);
                                  if (v43)
                                  {
                                    mach_port_t v44 = v43;
                                    CFDictionaryAddValue(v38, @"ProductID", v43);
                                    CFRelease(v44);
                                  }
                                  uint64_t v45 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"VendorID", v31);
                                  if (v45)
                                  {
                                    uint64_t v46 = v45;
                                    CFDictionaryAddValue(v38, @"VendorID", v45);
                                    CFRelease(v46);
                                  }
                                  uint64_t v47 = *(void *)(a1 + 464);
                                  if (!v47)
                                  {
                                    uint64_t v47 = IOHIDAnalyticsEventCreate(@"com.apple.hid.analytics.service", (uint64_t)v38);
                                    *(void *)(a1 + 464) = v47;
                                  }
                                  *(_OWORD *)buf = xmmword_18B50C020;
                                  uint64_t v48 = *(void *)(a1 + 472);
                                  if (!v48)
                                  {
                                    uint64_t v48 = IOHIDAnalyticsHistogramEventCreate(@"com.apple.hid.analytics.service.dispatchEvent", (uint64_t)v38, @"LatencyDispatchEvent", (uint64_t)buf, 1);
                                    *(void *)(a1 + 472) = v48;
                                    uint64_t v47 = *(void *)(a1 + 464);
                                  }
                                  if (v47)
                                  {
                                    IOHIDAnalyticsEventAddHistogramField(v47, @"LatencyServiceInit", (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(void *)(a1 + 464), @"LatencyServiceOpen", (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(void *)(a1 + 464), @"LatencyCopyProperty", (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(void *)(a1 + 464), @"LatencySetProperty", (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventAddHistogramField(*(void *)(a1 + 464), @"LatencyCopyEvent", (uint64_t)buf, 1u);
                                    IOHIDAnalyticsEventActivate();
                                    uint64_t v48 = *(void *)(a1 + 472);
                                  }
                                  if (v48) {
                                    IOHIDAnalyticsEventActivate();
                                  }
                                  CFRelease(v38);
                                }
                                v125 = v31;
                                uint64_t v126 = v4;
                                CFArrayRef v49 = (const __CFArray *)_IOHIDLoadBundles();
                                if (v49)
                                {
                                  CFArrayRef v50 = v49;
                                  if (CFArrayGetCount(v49) >= 1)
                                  {
                                    CFIndex v51 = 0;
                                    do
                                    {
                                      CFNumberRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v50, v51);
                                      CFArrayRef v53 = __IOHIDServicePassiveMatchToFilterPlugin(a1, ValueAtIndex);
                                      if (v53)
                                      {
                                        CFArrayRef v54 = v53;
                                        if (CFArrayGetCount(v53) >= 1)
                                        {
                                          CFIndex v55 = 0;
                                          do
                                          {
                                            CFUUIDRef v56 = (const __CFUUID *)CFArrayGetValueAtIndex(v54, v55);
                                            CFAllocatorRef v57 = CFGetAllocator((CFTypeRef)a1);
                                            CFTypeRef v58 = IOHIDServiceFilterCreate(v57, a1, ValueAtIndex, v56);
                                            if (v58)
                                            {
                                              IOReturn v59 = v58;
                                              CFArrayRef v60 = _IOHIDLogCategory(0);
                                              if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                                              {
                                                uint64_t v61 = *v128;
                                                *(_DWORD *)buf = 138412546;
                                                *(void *)&uint8_t buf[4] = v59;
                                                *(_WORD *)&buf[12] = 2048;
                                                *(void *)&buf[14] = v61;
                                                _os_log_impl(&dword_18B46C000, v60, OS_LOG_TYPE_DEFAULT, "Add filter:%@ for service:0x%llx", buf, 0x16u);
                                              }
                                              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 248), v59);
                                              if (!IOHIDServiceFilterGetType((uint64_t)v59)) {
                                                CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 256), v59);
                                              }
                                              CFRelease(v59);
                                            }
                                            ++v55;
                                          }
                                          while (v55 < CFArrayGetCount(v54));
                                        }
                                        CFRelease(v54);
                                      }
                                      ++v51;
                                    }
                                    while (v51 < CFArrayGetCount(v50));
                                  }
                                }
                                CFArrayRef v62 = (const __CFArray *)_IOHIDLoadServiceFilterBundles();
                                if (v62)
                                {
                                  CFArrayRef v63 = v62;
                                  if (CFArrayGetCount(v62) >= 1)
                                  {
                                    CFIndex v64 = 0;
                                    while (1)
                                    {
                                      uint64_t v133 = 0;
                                      CFTypeRef v65 = (__CFBundle *)CFArrayGetValueAtIndex(v63, v64);
                                      CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(v65);
                                      if (!InfoDictionary) {
                                        goto LABEL_80;
                                      }
                                      CFDictionaryRef v67 = InfoDictionary;
                                      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, @"Matching");
                                      if (Value)
                                      {
                                        CFDictionaryRef v69 = Value;
                                        CFTypeID v70 = CFGetTypeID(Value);
                                        if (v70 == CFDictionaryGetTypeID()
                                          && !_IOHIDServiceMatchPropertyTable(a1, v69, 1))
                                        {
                                          goto LABEL_80;
                                        }
                                      }
                                      mach_port_name_t v71 = CFDictionaryGetValue(v67, @"NSPrincipalClass");
                                      if (!v71) {
                                        goto LABEL_80;
                                      }
                                      uint64_t v72 = v71;
                                      CFTypeID v73 = CFGetTypeID(v71);
                                      if (v73 != CFStringGetTypeID()) {
                                        goto LABEL_80;
                                      }
                                      CFStringRef v74 = CFStringCreateWithFormat(alloc, 0, @"OBJC_CLASS_$_%@", v72);
                                      if (!v74) {
                                        goto LABEL_80;
                                      }
                                      CFStringRef v75 = v74;
                                      DataPointerForName = CFBundleGetDataPointerForName(v65, v74);
                                      if (!DataPointerForName) {
                                        break;
                                      }
                                      long long v77 = DataPointerForName;
                                      CFRelease(v75);
                                      if (objc_msgSend(v77, sel_getUid("matchService:options:score:"), a1, 0, &v133))
                                      {
                                        CFStringRef v78 = (const __CFString *)IOHIDServiceFilterCreateWithClass(alloc, v77, a1, v72, v133);
                                        long long v79 = _IOHIDLogCategory(0);
                                        long long v80 = v79;
                                        if (!v78)
                                        {
                                          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                                          {
                                            *(_DWORD *)buf = 138412290;
                                            *(void *)&uint8_t buf[4] = v67;
                                            _os_log_error_impl(&dword_18B46C000, v80, OS_LOG_TYPE_ERROR, "IOHIDServiceFilterCreateWithClass failed for bundle %@", buf, 0xCu);
                                          }
                                          goto LABEL_80;
                                        }
                                        if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                                        {
                                          uint64_t v81 = *v128;
                                          *(_DWORD *)buf = 138412546;
                                          *(void *)&uint8_t buf[4] = v78;
                                          *(_WORD *)&buf[12] = 2048;
                                          *(void *)&buf[14] = v81;
                                          _os_log_impl(&dword_18B46C000, v80, OS_LOG_TYPE_DEFAULT, "Add filter:%@ for service:0x%llx", buf, 0x16u);
                                        }
                                        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 248), v78);
                                        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 256), v78);
                                        CFStringRef v82 = v78;
                                        goto LABEL_79;
                                      }
LABEL_80:
                                      if (++v64 >= CFArrayGetCount(v63)) {
                                        goto LABEL_84;
                                      }
                                    }
                                    uint64_t v83 = _IOHIDLogCategory(0);
                                    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
                                    {
                                      *(_DWORD *)buf = 138412546;
                                      *(void *)&uint8_t buf[4] = v75;
                                      *(_WORD *)&buf[12] = 2112;
                                      *(void *)&buf[14] = v67;
                                      _os_log_error_impl(&dword_18B46C000, v83, OS_LOG_TYPE_ERROR, "__IOHIDServiceLoadServiceFilterBundles failed to find symbol %@ for bundle %@", buf, 0x16u);
                                    }
                                    CFStringRef v82 = v75;
LABEL_79:
                                    CFRelease(v82);
                                    goto LABEL_80;
                                  }
                                }
LABEL_84:
                                CFArrayRef v84 = *(const __CFArray **)(a1 + 248);
                                v154.CFIndex length = CFArrayGetCount(v84);
                                v154.location = 0;
                                CFArraySortValues(v84, v154, (CFComparatorFunction)IOHIDServiceFilterCompare, 0);
                                CFArrayRef v85 = *(const __CFArray **)(a1 + 256);
                                v155.CFIndex length = CFArrayGetCount(v85);
                                v155.location = 0;
                                CFArraySortValues(v85, v155, (CFComparatorFunction)IOHIDServiceFilterCompare, 0);
                                CFNumberRef v86 = (const __CFNumber *)__IOHIDServiceCopyPropertyForClient(a1, @"ReportInterval", 0, 1);
                                long long v87 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
                                if (v86)
                                {
                                  CFNumberRef v88 = v86;
                                  CFTypeID v89 = CFGetTypeID(v86);
                                  if (v89 == CFNumberGetTypeID())
                                  {
                                    CFNumberGetValue(v88, kCFNumberSInt32Type, (void *)(a1 + 168));
                                    *(_DWORD *)(a1 + 160) = *(_DWORD *)(a1 + 168);
                                  }
                                  CFRelease(v88);
                                }
                                CFNumberRef v90 = (const __CFNumber *)__IOHIDServiceCopyPropertyForClient(a1, @"BatchInterval", 0, 1);
                                uint64_t v4 = v126;
                                if (v90)
                                {
                                  CFNumberRef v91 = v90;
                                  CFTypeID v92 = CFGetTypeID(v90);
                                  if (v92 == CFNumberGetTypeID()) {
                                    CFNumberGetValue(v91, kCFNumberSInt32Type, (void *)(a1 + 172));
                                  }
                                  CFRelease(v91);
                                }
                                v93 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"DisplayIntegrated", v125);
                                if (v93)
                                {
                                  v94 = v93;
                                  *(_DWORD *)(a1 + 280) = CFEqual(v93, *v87);
                                  CFRelease(v94);
                                }
                                else if (IOHIDServiceConformsTo(a1, 13, 4))
                                {
                                  *(_DWORD *)(a1 + 280) = 1;
                                }
                                v95 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"ProtectedAccess", v125);
                                if (v95)
                                {
                                  v96 = v95;
                                  *(_DWORD *)(a1 + 304) = CFEqual(v95, *v87);
                                  CFRelease(v96);
                                }
                                CFNumberRef v97 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, @"QueueSize", v125);
                                if (v97)
                                {
                                  CFNumberRef v98 = v97;
                                  CFTypeID v99 = CFGetTypeID(v97);
                                  if (v99 == CFNumberGetTypeID()) {
                                    CFNumberGetValue(v98, kCFNumberSInt32Type, (void *)(a1 + 216));
                                  }
                                  CFRelease(v98);
                                }
                                CFNumberRef v100 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, @"SensorPropertySupported", v125);
                                if (v100)
                                {
                                  CFNumberRef v101 = v100;
                                  *(_DWORD *)buf = 0;
                                  CFTypeID v102 = CFGetTypeID(v100);
                                  CFTypeID TypeID = CFNumberGetTypeID();
                                  int v104 = 0;
                                  if (v102 == TypeID)
                                  {
                                    CFNumberGetValue(v101, kCFNumberSInt32Type, buf);
                                    int v104 = buf[0] & 2;
                                  }
                                  *(_DWORD *)(a1 + 296) = v104;
                                  CFRelease(v101);
                                }
                                CFNumberRef v105 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, @"PrimaryUsagePage", v125);
                                if (v105)
                                {
                                  CFNumberRef v106 = v105;
                                  CFTypeID v107 = CFGetTypeID(v105);
                                  if (v107 == CFNumberGetTypeID()) {
                                    CFNumberGetValue(v106, kCFNumberSInt32Type, (void *)(a1 + 176));
                                  }
                                  CFRelease(v106);
                                }
                                CFNumberRef v108 = (const __CFNumber *)_IOHIDServiceCopyPropertyForClient(a1, @"PrimaryUsage", v125);
                                if (v108)
                                {
                                  CFNumberRef v109 = v108;
                                  CFTypeID v110 = CFGetTypeID(v108);
                                  if (v110 == CFNumberGetTypeID()) {
                                    CFNumberGetValue(v109, kCFNumberSInt32Type, (void *)(a1 + 180));
                                  }
                                  CFRelease(v109);
                                }
                                CFStringRef v111 = (const __CFString *)_IOHIDServiceCopyPropertyForClient(a1, @"Transport", v125);
                                if (v111)
                                {
                                  CFStringRef v112 = v111;
                                  CFTypeID v113 = CFGetTypeID(v111);
                                  if (v113 == CFStringGetTypeID()) {
                                    CFStringGetCString(v112, (char *)(a1 + 184), 32, 0x8000100u);
                                  }
                                  CFRelease(v112);
                                }
                                *(void *)(a1 + 56) = _IOHIDServiceCopyPropertyForClient(a1, @"LocationID", v125);
                                v114 = (const void *)_IOHIDServiceCopyPropertyForClient(a1, @"HIDServiceAccessEntitlement", v125);
                                if (!v114) {
                                  goto LABEL_126;
                                }
                                v115 = v114;
                                CFTypeID v116 = CFGetTypeID(v114);
                                if (v116 == CFStringGetTypeID())
                                {
                                  CFAllocatorRef v117 = CFGetAllocator((CFTypeRef)a1);
                                  v118 = CFArrayCreateMutable(v117, 0, MEMORY[0x1E4F1D510]);
                                  CFArrayAppendValue(v118, v115);
                                  *(void *)(a1 + 64) = v118;
                                }
                                else
                                {
                                  CFTypeID v119 = CFGetTypeID(v115);
                                  if (v119 == CFArrayGetTypeID())
                                  {
                                    *(void *)(a1 + 64) = v115;
LABEL_126:
                                    uint64_t v121 = 1;
                                    goto LABEL_127;
                                  }
                                  v120 = _IOHIDLogCategory(0);
                                  if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR)) {
                                    __IOHIDServiceInit_cold_1((CFNumberRef *)(a1 + 48), v120);
                                  }
                                }
                                CFRelease(v115);
                                goto LABEL_126;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  uint64_t v121 = 0;
LABEL_127:
  uint64_t v122 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v122, v4, 0x3E8u);
  if (*(void *)(a1 + 464)) {
    IOHIDAnalyticsEventSetIntegerValueForField();
  }
  return v121;
}

CFArrayRef __IOHIDServicePassiveMatchToFilterPlugin(uint64_t a1, CFBundleRef bundle)
{
  CFPlugInRef PlugIn = CFBundleGetPlugIn(bundle);
  if (!PlugIn) {
    return 0;
  }
  uint64_t v4 = PlugIn;
  CFUUIDRef v5 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], 0x6Bu, 3u, 0x40u, 0xD3u, 0x57u, 0x98u, 0x40u, 0x64u, 0xAAu, 0x17u, 0x92u, 4u, 0xC7u, 0xB0u, 0x6Fu, 0xFDu);
  CFArrayRef FactoriesForPlugInTypeInPlugIn = CFPlugInFindFactoriesForPlugInTypeInPlugIn(v5, v4);
  if (FactoriesForPlugInTypeInPlugIn)
  {
    CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(v4);
    if (InfoDictionary)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, @"Matching");
      if (Value)
      {
        CFDictionaryRef v9 = Value;
        CFTypeID v10 = CFGetTypeID(Value);
        if (v10 == CFDictionaryGetTypeID() && !_IOHIDServiceMatchPropertyTable(a1, v9, 1))
        {
          CFRelease(FactoriesForPlugInTypeInPlugIn);
          return 0;
        }
      }
    }
  }
  return FactoriesForPlugInTypeInPlugIn;
}

uint64_t IOHIDAnalyticsEventAddHistogramField(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int8 a4)
{
  if (addHistogramFieldFuncPtr) {
    return addHistogramFieldFuncPtr(result, a2, a3, a4);
  }
  return result;
}

uint64_t IOHIDEventQueueCreate(uint64_t a1, int a2, uint64_t a3)
{
  size[2] = *MEMORY[0x1E4F143B8];
  if (a3 < 1) {
    return 0;
  }
  uint64_t Private = __IOHIDEventQueueCreatePrivate();
  uint64_t v6 = Private;
  if (!Private) {
    return v6;
  }
  *(_DWORD *)(Private + 144) = a2;
  if (a2 == 1)
  {
    size[0] = (a3 + *MEMORY[0x1E4F14B00] + 39) & -*MEMORY[0x1E4F14B00];
    uint64_t v7 = (vm_map_t *)MEMORY[0x1E4F14960];
    if (mach_make_memory_entry_64(*MEMORY[0x1E4F14960], size, 0, 393219, (mach_port_t *)(Private + 84), 0))
    {
      int v22 = _IOHIDLog();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        IOHIDEventQueueCreate_cold_3();
      }
      goto LABEL_29;
    }
    mach_vm_size_t v8 = size[0];
    *(void *)(v6 + 24) = size[0];
    if (mach_vm_map(*v7, (mach_vm_address_t *)(v6 + 16), v8, *MEMORY[0x1E4F14AF0], 1, *(_DWORD *)(v6 + 84), 0, 0, 3, 3, 2u))
    {
      CFAllocatorRef v23 = _IOHIDLog();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        IOHIDEventQueueCreate_cold_2();
      }
      goto LABEL_29;
    }
  }
  CFDictionaryRef v9 = *(_DWORD **)(v6 + 16);
  if (!v9) {
    goto LABEL_29;
  }
  *(_DWORD *)(v6 + 56) = a3;
  *CFDictionaryRef v9 = a3;
  v9[1] = 0;
  v9[2] = 0;
  long long v25 = xmmword_18B50C030;
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, (const void *)(v6 + 24));
  CFAllocatorRef v12 = *(_DWORD *)(v6 + 144) ? @"userEventQueue" : @"kernelEventQueue";
  size[0] = (memory_object_size_t)v11;
  size[1] = (memory_object_size_t)v12;
  CFDictionaryRef v13 = CFDictionaryCreate(v10, (const void **)__IOHIDEventQueueSetupAnalytics_keys, (const void **)size, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v13)
  {
    uint64_t v14 = IOHIDAnalyticsHistogramEventCreate(@"com.apple.hid.queueUsage", (uint64_t)v13, @"UsagePercent", (uint64_t)&v25, 1);
    *(void *)(v6 + 160) = v14;
    if (v14) {
      goto LABEL_15;
    }
    CFMutableSetRef v15 = _IOHIDLog();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18B46C000, v15, OS_LOG_TYPE_DEFAULT, "Unable to create queue analytics", buf, 2u);
    }
    if (*(void *)(v6 + 160)) {
LABEL_15:
    }
      IOHIDAnalyticsEventActivate();
    CFRelease(v13);
  }
  else
  {
    CFMutableDictionaryRef v21 = _IOHIDLog();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      IOHIDEventQueueCreate_cold_1(v21);
    }
  }
  uint64_t v16 = 0;
  char v17 = 1;
  do
  {
    char v18 = v17;
    int v19 = (const void *)size[v16];
    if (v19) {
      CFRelease(v19);
    }
    char v17 = 0;
    uint64_t v16 = 1;
  }
  while ((v18 & 1) != 0);
  if (!v13)
  {
LABEL_29:
    CFRelease((CFTypeRef)v6);
    return 0;
  }
  return v6;
}

uint64_t __IOHIDEventQueueCreatePrivate()
{
  IOHIDEventQueueGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v1 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(void *)(Instance + 40) = 0;
  }
  else
  {
    uint64_t v3 = _IOHIDLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      __IOHIDEventQueueCreatePrivate_cold_1(v3);
    }
  }
  return v1;
}

uint64_t IOHIDEventQueueGetTypeID()
{
  uint64_t result = __kIOHIDEventQueueTypeID;
  if (!__kIOHIDEventQueueTypeID)
  {
    if (__queueTypeInit_0 != -1) {
      dispatch_once(&__queueTypeInit_0, &__block_literal_global_11);
    }
    return __kIOHIDEventQueueTypeID;
  }
  return result;
}

uint64_t IOHIDAnalyticsEventActivate()
{
  if (activateEventFuncPtr) {
    return activateEventFuncPtr();
  }
  return result;
}

uint64_t IOHIDAnalyticsHistogramEventCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (__loadFramework_haOnce_0 != -1) {
    dispatch_once(&__loadFramework_haOnce_0, &__block_literal_global_18);
  }
  CFAllocatorRef v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))createHistogramEventFuncPtr;
  if (!createHistogramEventFuncPtr) {
    return 0;
  }

  return v10(a1, a2, a3, a4, a5);
}

CFTypeRef IOHIDServiceFilterCreate(const __CFAllocator *a1, uint64_t a2, __CFBundle *a3, const __CFUUID *a4)
{
  uint64_t Private = __IOHIDServiceFilterCreatePrivate(a1);
  if (!Private) {
    return 0;
  }
  uint64_t v9 = Private;
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
  CFUUIDRef v11 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], 0x6Bu, 3u, 0x40u, 0xD3u, 0x57u, 0x98u, 0x40u, 0x64u, 0xAAu, 0x17u, 0x92u, 4u, 0xC7u, 0xB0u, 0x6Fu, 0xFDu);
  CFAllocatorRef v12 = CFPlugInInstanceCreate(a1, a4, v11);
  if (!v12)
  {
    CFTypeRef v25 = 0;
    goto LABEL_17;
  }
  CFDictionaryRef v13 = v12;
  uint64_t v14 = *(unsigned int (**)(const void *, void, void, uint64_t))(*(void *)v12 + 8);
  CFUUIDRef v15 = CFUUIDGetConstantUUIDWithBytes(v10, 5u, 5u, 0xD7u, 0x8Du, 0x4Fu, 0x4Eu, 0x4Cu, 0x41u, 0xA3u, 0xA6u, 0xC7u, 0xA7u, 0x7Bu, 0x41u, 0xBDu, 0xACu);
  CFUUIDBytes v16 = CFUUIDGetUUIDBytes(v15);
  char v17 = (void *)(v9 + 24);
  if (v14(v13, *(void *)&v16.byte0, *(void *)&v16.byte8, v9 + 24)) {
    *char v17 = 0;
  }
  char v18 = *(unsigned int (**)(const void *, void, void, uint64_t))(*(void *)v13 + 8);
  CFUUIDRef v19 = CFUUIDGetConstantUUIDWithBytes(v10, 0xC7u, 0x10u, 0x95u, 0x1Du, 0x18u, 0x40u, 0x45u, 0x6Eu, 0x82u, 0xE7u, 0xFCu, 0xA1u, 0xA0u, 0xFAu, 0x7Fu, 0xE4u);
  CFUUIDBytes v20 = CFUUIDGetUUIDBytes(v19);
  CFMutableDictionaryRef v21 = (void *)(v9 + 16);
  if (v18(v13, *(void *)&v20.byte0, *(void *)&v20.byte8, v9 + 16))
  {
    *CFMutableDictionaryRef v21 = 0;
    goto LABEL_7;
  }
  if (!*v21)
  {
LABEL_7:
    if (!*v17) {
      goto LABEL_15;
    }
  }
  int v22 = IOHIDServiceFilterMatch(v9);
  if (v22)
  {
    int v23 = v22;
    *(void *)(v9 + 48) = a2;
    *(void *)(v9 + 32) = _IOHIDServiceCopyDispatchQueue(a2);
    *(_DWORD *)(v9 + 40) = v23;
    CFStringRef Identifier = CFBundleGetIdentifier(a3);
    *(void *)(v9 + 80) = Identifier;
    if (Identifier) {
      CFRetain(Identifier);
    }
    CFTypeRef v25 = CFRetain((CFTypeRef)v9);
    goto LABEL_16;
  }
  _IOHIDPlugInInstanceCacheAdd(a4, v13);
LABEL_15:
  CFTypeRef v25 = 0;
LABEL_16:
  (*(void (**)(const void *))(*(void *)v13 + 24))(v13);
LABEL_17:
  CFRelease((CFTypeRef)v9);
  return v25;
}

uint64_t __IOHIDServiceFilterCreatePrivate(const __CFAllocator *a1)
{
  if (!__kIOHIDServiceFilterTypeID) {
    pthread_once(&__systemFilterClientTypeInit_0, (void (*)(void))__IOHIDServiceFilterRegister);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v3 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 176) = 0;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(void *)(Instance + 88) = CFUUIDCreate(a1);
  }
  return v3;
}

uint64_t IOHIDServiceFilterMatch(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 32);
    if (v3) {
      return v3();
    }
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4 && (uint64_t v3 = *(uint64_t (**)(void))(*(void *)v4 + 32)) != 0) {
    return v3();
  }
  else {
    return 0;
  }
}

NSObject *hid_dispatch_queue_create_with_context_destructor(const char *a1, NSObject *a2, NSObject *a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(uint64_t))
{
  dispatch_queue_t v11 = dispatch_queue_create_with_target_V2(a1, a2, a3);
  if (v11)
  {
    CFAllocatorRef v12 = v11;
    if (!(a4 | a5)) {
      return v12;
    }
    CFDictionaryRef v13 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
    if (v13)
    {
      *CFDictionaryRef v13 = a4;
      v13[1] = a5;
      _OWORD v13[2] = a6;
      v13[3] = a7;
      dispatch_queue_set_specific(v12, &sHIDExecutionCallbacksKey, v13, (dispatch_function_t)__hid_dispatch_queue_context_destructor);
      return v12;
    }
    dispatch_release(v12);
  }
  if (a7) {
    a7(a6);
  }
  return 0;
}

uint64_t _IOHIDServiceInitVirtual(uint64_t a1)
{
  return __IOHIDServiceInit(a1, *(void *)(a1 + 400));
}

void _IOHIDPlugInInstanceCacheAdd(void *key, const void *a2)
{
  if (a2 && key && __hidPlugInInstanceCache && !CFDictionaryContainsKey((CFDictionaryRef)__hidPlugInInstanceCache, key))
  {
    uint64_t v4 = (__CFDictionary *)__hidPlugInInstanceCache;
    (*(void (**)(const void *))(*(void *)a2 + 16))(a2);
    CFDictionarySetValue(v4, key, a2);
  }
}

uint64_t _IOHIDLoadServiceFilterBundles()
{
  if (_IOHIDLoadServiceFilterBundles_onceToken != -1) {
    dispatch_once(&_IOHIDLoadServiceFilterBundles_onceToken, &__block_literal_global_29);
  }
  return __hidServiceFilterBundles;
}

uint64_t _IOHIDLoadBundles()
{
  if (_IOHIDLoadBundles_onceToken != -1) {
    dispatch_once(&_IOHIDLoadBundles_onceToken, &__block_literal_global_16);
  }
  return __hidPlugInBundles;
}

void _IOHIDEventSystemAddService(const void *a1, void *a2)
{
  values = a2;
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFArrayRef v4 = CFArrayCreate(v3, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  if (v4)
  {
    CFArrayRef v5 = v4;
    __IOHIDEventSystemAddServices((uint64_t)a1, v4);
    CFRelease(v5);
  }
}

uint64_t IOHIDSessionAddService(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v12, context);
  }
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  int v4 = *(_DWORD *)(a1 + 88);
  CFAllocatorRef v5 = CFGetAllocator(*(CFTypeRef *)(a1 + 120));
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v5, *(CFDictionaryRef *)(a1 + 120));
  uint64_t v7 = *(void *)(a1 + 32);
  if (*(_DWORD *)v7)
  {
    --*(_DWORD *)v7;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v12, context);
    }
  }
  if (v4) {
    __RegisterServiceFunction(a2, a1);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v12, context);
  }
  ++**(_DWORD **)(a1 + 32);
  if (v4)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)&context[0] = Copy;
    *((void *)&context[0] + 1) = Mutable;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 120), (CFDictionaryApplierFunction)__CheckForNewProperties, context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__SetPropertiesForObjectFunction, a2);
    CFRelease(Mutable);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  if (!v4 || _IOHIDServiceGetOwner((uint64_t)a2) == a1)
  {
    CFAllocatorRef v9 = CFGetAllocator(*(CFTypeRef *)(a1 + 136));
    MutableCFDictionaryRef Copy = CFSetCreateMutableCopy(v9, 0, *(CFSetRef *)(a1 + 136));
    CFRelease(*(CFTypeRef *)(a1 + 136));
    *(void *)(a1 + 136) = MutableCopy;
    CFSetAddValue(MutableCopy, a2);
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  uint64_t result = *(void *)(a1 + 32);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v12, context);
    }
  }
  return result;
}

uint64_t _IOHIDServiceGetOwner(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void __RegisterServiceFunction(void *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (_IOHIDServiceOpen(a1, (const void *)a2, 0))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a2 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(context, v8);
    }
    ++**(_DWORD **)(a2 + 32);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 120), (CFDictionaryApplierFunction)__SetPropertiesForObjectFunction, a1);
    context[0] = a1;
    context[1] = a2;
    CFArrayRef v4 = *(const __CFArray **)(a2 + 152);
    v10.CFIndex length = CFArrayGetCount(v4);
    v10.location = 0;
    CFArrayApplyFunction(v4, v10, (CFArrayApplierFunction)__FilterFunctionRegisterService, context);
    uint64_t v5 = *(void *)(a2 + 32);
    if (*(_DWORD *)v5)
    {
      --*(_DWORD *)v5;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_1(&v6, v8);
      }
    }
    _IOHIDServiceSetEventCallback(a1, (uint64_t)__IOHIDSessionServiceCallback, a2, 0);
  }
  _IOHIDServiceScheduleAsync((uint64_t)a1);
}

uint64_t _IOHIDServiceSetEventCallback(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  context[0] = __IOHIDServiceEventCallback;
  context[1] = a1;
  void context[2] = a4;
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v15, v17);
  }
  ++*(_DWORD *)a1[9];
  a1[17] = a4;
  a1[18] = a2;
  a1[16] = a3;
  uint64_t v8 = a1[4];
  if (v8 && (uint64_t v9 = *(void (**)(void))(*(void *)v8 + 64)) != 0
    || (v10 = a1[3]) != 0 && (uint64_t v9 = *(void (**)(void))(*(void *)v10 + 64)) != 0)
  {
    v9();
  }
  else
  {
    uint64_t v13 = a1[45];
    if (v13)
    {
      uint64_t v14 = *(void (**)(void, void, uint64_t (*)(uint64_t, uint64_t, uint64_t, void *), void *, void))(v13 + 40);
      if (v14) {
        v14(a1[43], a1[44], __IOHIDServiceEventCallback, a1, 0);
      }
    }
  }
  CFArrayRef v11 = (const __CFArray *)a1[32];
  v19.CFIndex length = CFArrayGetCount(v11);
  v19.location = 0;
  CFArrayApplyFunction(v11, v19, (CFArrayApplierFunction)__FilterFunctionSetEventCallback, context);
  uint64_t result = a1[9];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v15, v17);
    }
  }
  return result;
}

CFIndex __IOHIDEventSystemAddServices(uint64_t a1, const __CFArray *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v6 = *(void *)(a1 + 128);
  CFIndex Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    for (CFIndex i = 0; i != v8; ++i)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      CFArrayRef v11 = _IOHIDLog();
      if (os_signpost_enabled(v11))
      {
        if (ValueAtIndex) {
          uint64_t RegistryID = IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
        }
        else {
          uint64_t RegistryID = 0;
        }
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = RegistryID;
        _os_signpost_emit_with_name_impl(&dword_18B46C000, v11, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddService", "%@", (uint8_t *)&buf, 0xCu);
      }
      if (ValueAtIndex)
      {
        RemovalNotification = IOHIDServiceCreateRemovalNotification((uint64_t)ValueAtIndex, (uint64_t)__IOHIDEventSystemServiceRemoved, a1, 0);
        if (RemovalNotification)
        {
          os_unfair_recursive_lock_lock_with_options();
          uint64_t v14 = *(__CFDictionary **)(a1 + 16);
          uint64_t v15 = (const void *)IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
          CFDictionaryAddValue(v14, v15, ValueAtIndex);
          CFUUIDBytes v16 = *(__CFDictionary **)(a1 + 24);
          char v17 = (const void *)IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
          CFDictionarySetValue(v16, v17, RemovalNotification);
          os_unfair_recursive_lock_unlock();
          IOHIDSessionAddService(v6, ValueAtIndex);
          uint64_t v18 = _IOHIDLogCategory(0);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = ValueAtIndex;
            _os_log_impl(&dword_18B46C000, v18, OS_LOG_TYPE_DEFAULT, "Service added: %{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (Mutable)
          {
            CFRange v19 = (const void *)IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
            CFDictionaryAddValue(Mutable, v19, ValueAtIndex);
          }
        }
      }
      else
      {
        RemovalNotification = 0;
      }
      CFUUIDBytes v20 = _IOHIDLog();
      if (os_signpost_enabled(v20))
      {
        if (ValueAtIndex) {
          uint64_t v21 = IOHIDServiceGetRegistryID((uint64_t)ValueAtIndex);
        }
        else {
          uint64_t v21 = 0;
        }
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v21;
        _os_signpost_emit_with_name_impl(&dword_18B46C000, v20, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddService", "%@", (uint8_t *)&buf, 0xCu);
      }
      if (RemovalNotification) {
        CFRelease(RemovalNotification);
      }
    }
  }
  os_unfair_recursive_lock_lock_with_options();
  if (CFSetGetCount(*(CFSetRef *)(a1 + 40)))
  {
    CFAllocatorRef v22 = CFGetAllocator(*(CFTypeRef *)(a1 + 40));
    CFSetRef Copy = CFSetCreateCopy(v22, *(CFSetRef *)(a1 + 40));
  }
  else
  {
    CFSetRef Copy = 0;
  }
  CFAllocatorRef v24 = CFGetAllocator((CFTypeRef)a1);
  CFSetRef v25 = CFSetCreateCopy(v24, *(CFSetRef *)(a1 + 432));
  os_unfair_recursive_lock_unlock();
  if (Mutable)
  {
    if (Copy && CFDictionaryGetCount(Mutable))
    {
      *(void *)&long long buf = a1;
      *((void *)&buf + 1) = Mutable;
      CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDEventSystemMatchNotifyFunction, &buf);
    }
    CFRelease(Mutable);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  if (v25)
  {
    CFSetApplyFunction(v25, (CFSetApplierFunction)_IOHIDEventSystemConnectionRecordServiceChanged, 0);
    CFRelease(v25);
  }
  CFIndex result = CFArrayGetCount(a2);
  if (result >= 1)
  {
    CFIndex v27 = result;
    for (CFIndex j = 0; j != v27; ++j)
    {
      CFAllocatorRef v29 = CFArrayGetValueAtIndex(a2, j);
      CFIndex result = __IOHIDServiceOpenedByEventSystem((uint64_t)v29);
    }
  }
  return result;
}

uint64_t _IOHIDLog()
{
  if (_IOHIDLog_onceToken != -1) {
    dispatch_once(&_IOHIDLog_onceToken, &__block_literal_global_8);
  }
  return _IOHIDLog_log;
}

void *IOHIDServiceCreateRemovalNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v15);
  }
  ++**(_DWORD **)(a1 + 72);
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDServiceNotificationRelease, a1, 0, a2, a3, a4);
  if (v9)
  {
    if (*(unsigned char *)(a1 + 224))
    {
      CFRetain((CFTypeRef)a1);
      CFRetain(v9);
      global_queue = dispatch_get_global_queue(0, 0);
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 0x40000000;
      _OWORD v13[2] = __IOHIDServiceCreateRemovalNotification_block_invoke;
      v13[3] = &__block_descriptor_tmp_86;
      v13[4] = v9;
      _OWORD v13[5] = a1;
      dispatch_async(global_queue, v13);
    }
    else
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 104), v9);
    }
  }
  uint64_t v11 = *(void *)(a1 + 72);
  if (*(_DWORD *)v11)
  {
    --*(_DWORD *)v11;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v15);
    }
  }
  return v9;
}

uint64_t __IOHIDServiceOpenedByEventSystem(uint64_t a1)
{
  uint64_t result = _IOHIDServiceSetPropertyForClient(a1, @"DeviceOpenedByEventSystem", (const void *)*MEMORY[0x1E4F1CFD0], (CFTypeRef)*MEMORY[0x1E4F1D260]);
  if (*(void *)(a1 + 336))
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(*(CFNumberRef *)(a1 + 48), kCFNumberSInt64Type, &valuePtr);
    return _IOHIDEventSystemConnectionVirtualServiceNotify(*(void *)(a1 + 336), valuePtr, 4, 0);
  }
  return result;
}

void _IOHIDServiceScheduleAsync(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  _IOHIDDebugTrace(8262, 1, a1, 1, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v14, v15);
  }
  ++**(_DWORD **)(a1 + 72);
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 88), *(dispatch_queue_t *)(a1 + 80));
  if (*(void *)(a1 + 8))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2 && (CFAllocatorRef v3 = *(void (**)(void))(*(void *)v2 + 72)) != 0)
    {
      v3();
    }
    else
    {
      uint64_t v4 = *(void *)(a1 + 360);
      if (v4 && (uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 48)) != 0)
      {
        uint64_t v6 = *(void *)(a1 + 344);
        uint64_t v7 = *(void *)(a1 + 352);
        uint64_t v8 = *(void *)(a1 + 80);
      }
      else
      {
        uint64_t v6 = *(void *)(a1 + 24);
        if (!v6 || (uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 72)) == 0)
        {
          if (*(void *)(a1 + 480))
          {
            *(unsigned char *)(a1 + 440) = 1;
            CFRetain((CFTypeRef)a1);
            objc_msgSend(*(id *)(a1 + 480), *(SEL *)(a1 + 528), *(void *)(a1 + 424));
            objc_msgSend(*(id *)(a1 + 480), *(SEL *)(a1 + 520), a1);
            uint64_t v9 = *(const char **)(a1 + 552);
            if (v9) {
              objc_msgSend(*(id *)(a1 + 480), v9, *(void *)(a1 + 80));
            }
            [*(id *)(a1 + 480) *(SEL *)(a1 + 536)];
          }
          goto LABEL_17;
        }
        uint64_t v7 = qword_1E9133700;
        uint64_t v8 = *(void *)algn_1E9133708;
      }
      v5(v6, v7, v8);
    }
LABEL_17:
    CFArrayRef v10 = *(const __CFArray **)(a1 + 256);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    _OWORD v13[2] = ___IOHIDServiceScheduleAsync_block_invoke;
    v13[3] = &__block_descriptor_tmp_87_0;
    v13[4] = a1;
    _IOHIDCFArrayApplyBlock(v10, v13);
    CFArrayRef v11 = *(const __CFArray **)(a1 + 256);
    v17.CFIndex length = CFArrayGetCount(v11);
    v17.location = 0;
    CFArrayApplyFunction(v11, v17, (CFArrayApplierFunction)__FilterFunctionScheduleAsync, 0);
  }
  uint64_t v12 = *(void *)(a1 + 72);
  if (*(_DWORD *)v12)
  {
    --*(_DWORD *)v12;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v14, v15);
    }
  }
  _IOHIDDebugTrace(8262, 2, a1, 1, 0, 0);
}

uint64_t __IOHIDServiceVirtualScheduleWithDispatchQueueCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID = _IOHIDServiceGetSenderID(a1);

  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 2, 0);
}

void _IOHIDServiceUnscheduleAsync(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  _IOHIDDebugTrace(8262, 1, a1, 0, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v20, v21);
  }
  ++**(_DWORD **)(a1 + 72);
  if ((*(_DWORD *)(a1 + 444) || *(unsigned char *)(a1 + 440)) && !*(void *)(a1 + 448))
  {
    uint64_t v2 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(a1 + 80));
    *(void *)(a1 + 448) = v2;
    dispatch_time_t v3 = dispatch_time(0, 300000000000);
    dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 448), (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 448), (dispatch_function_t)__IOHIDServiceHandleCancelTimerTimeout);
    CFRetain((CFTypeRef)a1);
    uint64_t v4 = *(NSObject **)(a1 + 448);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = ___IOHIDServiceUnscheduleAsync_block_invoke;
    handler[3] = &__block_descriptor_tmp_89;
    handler[4] = a1;
    dispatch_source_set_cancel_handler(v4, handler);
    dispatch_activate(*(dispatch_object_t *)(a1 + 448));
  }
  if (*(void *)(a1 + 8))
  {
    CFArrayRef v5 = *(const __CFArray **)(a1 + 256);
    v23.CFIndex length = CFArrayGetCount(v5);
    v23.location = 0;
    CFArrayApplyFunction(v5, v23, (CFArrayApplierFunction)__FilterFunctionUnscheduleAsync, 0);
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      uint64_t v7 = *(void (**)(void))(*(void *)v6 + 80);
      if (v7)
      {
        v7();
        goto LABEL_19;
      }
    }
    uint64_t v8 = *(void *)(a1 + 24);
    if (v8)
    {
      uint64_t v9 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 80);
      if (v9)
      {
        uint64_t v10 = qword_1E9133700;
        uint64_t v11 = *(void *)algn_1E9133708;
LABEL_16:
        v9(v8, v10, v11);
        goto LABEL_19;
      }
    }
    uint64_t v12 = *(void *)(a1 + 360);
    if (v12)
    {
      uint64_t v9 = *(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 56);
      if (v9)
      {
        uint64_t v8 = *(void *)(a1 + 344);
        uint64_t v10 = *(void *)(a1 + 352);
        uint64_t v11 = *(void *)(a1 + 80);
        goto LABEL_16;
      }
    }
    uint64_t v13 = *(void **)(a1 + 480);
    if (v13) {
      [v13 *(SEL *)(a1 + 544)];
    }
  }
LABEL_19:
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 88), 0);
  uint64_t v14 = *(void *)(a1 + 72);
  if (*(_DWORD *)v14)
  {
    --*(_DWORD *)v14;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v20, v21);
    }
  }
  CFRetain((CFTypeRef)a1);
  uint64_t v15 = *(NSObject **)(a1 + 80);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___IOHIDServiceUnscheduleAsync_block_invoke_90;
  block[3] = &__block_descriptor_tmp_91;
  block[4] = a1;
  dispatch_async(v15, block);
  uint64_t v16 = *(void *)(a1 + 24);
  if (v16 && *(void *)(*(void *)v16 + 80))
  {
    CFRetain((CFTypeRef)a1);
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 0x40000000;
    _DWORD v17[2] = ___IOHIDServiceUnscheduleAsync_block_invoke_92;
    v17[3] = &__block_descriptor_tmp_93_1;
    v17[4] = a1;
    CFRunLoopPerformBlock((CFRunLoopRef)qword_1E9133700, *(CFTypeRef *)algn_1E9133708, v17);
    CFRunLoopWakeUp((CFRunLoopRef)qword_1E9133700);
  }
  _IOHIDDebugTrace(8262, 2, a1, 0, 0, 0);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  uint64_t v4 = *((void *)notify + 3);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*((dispatch_object_t *)notify + 3));
    *((void *)notify + 3) = 0;
  }
  if (queue)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)notify + 8, 1u, memory_order_relaxed);
    CFArrayRef v5 = dispatch_source_create(MEMORY[0x1E4F14458], *((unsigned int *)notify + 1), 0, queue);
    dispatch_set_context(v5, notify);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __IONotificationPortSetDispatchQueue_block_invoke;
    handler[3] = &__block_descriptor_tmp_6;
    handler[4] = v5;
    dispatch_source_set_event_handler(v5, handler);
    dispatch_source_set_cancel_handler_f(v5, (dispatch_function_t)IONotificationPortRelease);
    *((void *)notify + 3) = v5;
    dispatch_activate(v5);
  }
}

uint64_t _IOHIDEventSystemConnectionVirtualServiceNotify(uint64_t a1, uint64_t a2, int a3, const void *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  CFDataRef v7 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a4);
  CFDataRef v8 = v7;
  if (!*(_DWORD *)(a1 + 448))
  {
    int v9 = *(_DWORD *)(a1 + 40);
    if (v7)
    {
      BytePtr = CFDataGetBytePtr(v7);
      int Length = CFDataGetLength(v8);
    }
    else
    {
      BytePtr = 0;
      int Length = 0;
    }
    int v12 = iohideventsystem_client_dispatch_virtual_service_notification(v9, a2, a3, (uint64_t)BytePtr, Length);
    if (!v12)
    {
      uint64_t v15 = 1;
      if (!v8) {
        return v15;
      }
      goto LABEL_10;
    }
    int v13 = v12;
    uint64_t v14 = _IOHIDLogCategory(9u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = *(void *)(a1 + 168);
      int v18 = 136315650;
      uint64_t v19 = v17;
      __int16 v20 = 2048;
      uint64_t v21 = a2;
      __int16 v22 = 1024;
      int v23 = v13;
      _os_log_error_impl(&dword_18B46C000, v14, OS_LOG_TYPE_ERROR, "%s: HIDVS ID:%llx iohideventsystem_client_dispatch_virtual_service_notification:%x", (uint8_t *)&v18, 0x1Cu);
    }
    __IOHIDEventSystemConnectionCheckServerStatus(v13, a1);
  }
  uint64_t v15 = 0;
  if (v8) {
LABEL_10:
  }
    CFRelease(v8);
  return v15;
}

uint64_t iohideventsystem_client_dispatch_virtual_service_notification(int a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v8 = a4;
  int v9 = 16777472;
  int v10 = a5;
  uint64_t v11 = *MEMORY[0x1E4F14068];
  uint64_t v12 = a2;
  int v13 = a3;
  int v14 = a5;
  *(void *)mach_msg_header_t msg = 2147483667;
  *(_DWORD *)&msg[8] = a1;
  *(_OWORD *)&msg[12] = xmmword_18B50C740;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  }
  uint64_t v5 = mach_msg((mach_msg_header_t *)msg, 129, 0x44u, 0, 0, 0, 0);
  if ((v5 - 268435459) <= 1)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], *(mach_port_name_t *)&msg[12]);
    }
    mach_msg_destroy((mach_msg_header_t *)msg);
  }
  return v5;
}

uint64_t __IOHIDServiceVirtualUnscheduleFromDispatchQueueCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID = _IOHIDServiceGetSenderID(a1);

  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 3, 0);
}

uint64_t _IOHIDServiceOpen(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = mach_absolute_time();
  _IOHIDDebugTrace(8258, 1, (uint64_t)a1, (uint64_t)a2, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v19, &context);
  }
  ++*(_DWORD *)a1[9];
  if (a1[1]) {
    goto LABEL_3;
  }
  uint64_t v8 = a1[4];
  if (v8 && (int v9 = *(uint64_t (**)(void))(*(void *)v8 + 32)) != 0
    || (v10 = a1[3]) != 0 && (int v9 = *(uint64_t (**)(void))(*(void *)v10 + 32)) != 0)
  {
    unsigned __int8 v11 = v9();
  }
  else
  {
    uint64_t v13 = a1[45];
    if (!v13 || (int v14 = *(uint64_t (**)(void, void, uint64_t))(v13 + 8)) == 0)
    {
      unsigned __int8 v7 = 1;
      goto LABEL_16;
    }
    unsigned __int8 v11 = v14(a1[43], a1[44], a3);
  }
  unsigned __int8 v7 = v11;
  if (v11)
  {
LABEL_16:
    a1[1] = CFRetain(a2);
    *((void *)&context + 1) = a2;
    uint64_t v21 = 0;
    *(void *)&long long context = a1;
    CFArrayRef v15 = (const __CFArray *)a1[32];
    v23.CFIndex length = CFArrayGetCount(v15);
    v23.location = 0;
    CFArrayApplyFunction(v15, v23, (CFArrayApplierFunction)__FilterFunctionOpen, &context);
    goto LABEL_17;
  }
  uint64_t v12 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
    _IOHIDServiceOpen_cold_2();
  }
LABEL_3:
  unsigned __int8 v7 = 0;
LABEL_17:
  uint64_t v16 = a1[9];
  if (*(_DWORD *)v16)
  {
    --*(_DWORD *)v16;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v19, &context);
    }
  }
  _IOHIDDebugTrace(8258, 2, (uint64_t)a1, (uint64_t)a2, 0, 0);
  uint64_t v17 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v17, v6, 0x3E8u);
  if (a1[58]) {
    IOHIDAnalyticsEventSetIntegerValueForField();
  }
  return v7;
}

uint64_t __IOHIDServiceVirtualOpenCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID = _IOHIDServiceGetSenderID(a1);
  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 0, 0);
}

uint64_t IOHIDSessionRemoveService(uint64_t a1, const void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v9, v10);
  }
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 136), a2))
  {
    CFAllocatorRef v4 = CFGetAllocator(*(CFTypeRef *)(a1 + 136));
    MutableCFSetRef Copy = CFSetCreateMutableCopy(v4, 0, *(CFSetRef *)(a1 + 136));
    CFRelease(*(CFTypeRef *)(a1 + 136));
    *(void *)(a1 + 136) = MutableCopy;
    CFSetRemoveValue(MutableCopy, a2);
    int v6 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v6 = 0;
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (*(_DWORD *)v7)
  {
    --*(_DWORD *)v7;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v9, v10);
    }
  }
  if (v6) {
    __UnregisterServiceFunction(a2, a1);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v9, v10);
  }
  ++**(_DWORD **)(a1 + 32);
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  uint64_t result = *(void *)(a1 + 32);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v9, v10);
    }
  }
  return result;
}

uint64_t __IOHIDSessionSetStateBusy(uint64_t result, int a2)
{
  uint64_t v3 = result;
  if (a2)
  {
    if (*(_DWORD *)(result + 92))
    {
      uint64_t v4 = *(void *)(result + 32);
      int v5 = *(_DWORD *)v4 - 1;
      do
      {
        *(_DWORD *)uint64_t v4 = v5;
        uint64_t result = pthread_cond_wait((pthread_cond_t *)(v3 + 40), (pthread_mutex_t *)(v4 + 8));
        uint64_t v4 = *(void *)(v3 + 32);
        int v5 = (*(_DWORD *)v4)++;
      }
      while (*(_DWORD *)(v3 + 92));
    }
  }
  else
  {
    uint64_t result = pthread_cond_signal((pthread_cond_t *)(result + 40));
  }
  *(_DWORD *)(v3 + 92) = a2;
  return result;
}

void __UnregisterServiceFunction(const void *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFRetain(a1);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a2 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(context, v8);
  }
  ++**(_DWORD **)(a2 + 32);
  context[0] = a1;
  context[1] = a2;
  CFArrayRef v4 = *(const __CFArray **)(a2 + 152);
  v10.CFIndex length = CFArrayGetCount(v4);
  v10.location = 0;
  CFArrayApplyFunction(v4, v10, (CFArrayApplierFunction)__FilterFunctionUnregisterService, context);
  uint64_t v5 = *(void *)(a2 + 32);
  if (*(_DWORD *)v5)
  {
    --*(_DWORD *)v5;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v6, v8);
    }
  }
  _IOHIDServiceUnscheduleAsync((uint64_t)a1);
  _IOHIDServiceClose((uint64_t)a1, a2, 0);
  CFRelease(a1);
}

void _IOHIDServiceClose(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  _IOHIDDebugTrace(8261, 1, a1, a2, 0, 0);
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v18, &context);
  }
  uint64_t v6 = *(void *)(a1 + 72);
  int v7 = *(_DWORD *)v6 + 1;
  *(_DWORD *)uint64_t v6 = v7;
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8) {
    BOOL v9 = v8 == a2;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    *((void *)&context + 1) = a2;
    uint64_t v20 = 0;
    *(void *)&long long context = a1;
    CFArrayRef v10 = *(const __CFArray **)(a1 + 256);
    v22.CFIndex length = CFArrayGetCount(v10);
    v22.location = 0;
    CFArrayApplyFunction(v10, v22, (CFArrayApplierFunction)__FilterFunctionClose, &context);
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11 && (uint64_t v12 = *(void (**)(void))(*(void *)v11 + 40)) != 0
      || (uint64_t v13 = *(void *)(a1 + 24)) != 0 && (v12 = *(void (**)(void))(*(void *)v13 + 40)) != 0)
    {
      v12();
    }
    else
    {
      uint64_t v15 = *(void *)(a1 + 360);
      if (v15)
      {
        uint64_t v16 = *(void (**)(void, void, uint64_t))(v15 + 16);
        if (v16) {
          v16(*(void *)(a1 + 344), *(void *)(a1 + 352), a3);
        }
      }
    }
    _IOHIDServiceSetEventCallback((void *)a1, 0, 0, 0);
    CFRelease(*(CFTypeRef *)(a1 + 8));
    *(void *)(a1 + 8) = 0;
    uint64_t v6 = *(void *)(a1 + 72);
    int v7 = *(_DWORD *)v6;
  }
  if (v7)
  {
    *(_DWORD *)uint64_t v6 = v7 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v18, &context);
    }
  }
  CFRetain((CFTypeRef)a1);
  int v14 = *(NSObject **)(a1 + 80);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___IOHIDServiceClose_block_invoke;
  block[3] = &__block_descriptor_tmp_85;
  block[4] = a1;
  dispatch_async(v14, block);
  _IOHIDDebugTrace(8261, 2, a1, a2, 0, 0);
}

uint64_t __IOHIDServiceVirtualCloseCallback(uint64_t a1, uint64_t a2)
{
  uint64_t SenderID = _IOHIDServiceGetSenderID(a1);

  return _IOHIDEventSystemConnectionVirtualServiceNotify(a2, SenderID, 1, 0);
}

BOOL IOHIDServiceFilterGetType(uint64_t a1)
{
  return *(void *)(a1 + 16) == 0;
}

uint64_t IOHIDAnalyticsEventCreate(uint64_t a1, uint64_t a2)
{
  if (__loadFramework_haOnce_0 != -1) {
    dispatch_once(&__loadFramework_haOnce_0, &__block_literal_global_18);
  }
  CFArrayRef v4 = (uint64_t (*)(uint64_t, uint64_t))createEventFuncPtr;
  if (!createEventFuncPtr) {
    return 0;
  }

  return v4(a1, a2);
}

uint64_t __IOMIGMachPortRegister()
{
  __ioPortCache = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  uint64_t result = _CFRuntimeRegisterClass();
  __IOMIGMachPortCFTypeID TypeID = result;
  return result;
}

BOOL IOHIDServiceFilterSetCancelHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    CFRetain(*(CFTypeRef *)(a1 + 48));
    *(void *)(a1 + 56) = a2;
    objc_msgSend(*(id *)(a1 + 96), *(SEL *)(a1 + 136), *(void *)(a1 + 64));
  }
  return v2 != 0;
}

void __OSKextInitialize()
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)CFDataRef v42 = xmmword_1E548AAB8;
  *(_OWORD *)CFTypeID v39 = xmmword_1E548AAC8;
  long long v40 = *(_OWORD *)&off_1E548AAD8;
  long long v41 = xmmword_1E548AAE8;
  unsigned int v0 = (void *)*MEMORY[0x1E4F1D020];
  v38[0] = *(void **)MEMORY[0x1E4F1CFF8];
  v38[1] = v0;
  v38[2] = *(void **)MEMORY[0x1E4F1CC60];
  v38[3] = @"OSBundleCompatibleVersion";
  v38[4] = @"OSBundleIsInterface";
  v38[5] = @"OSKernelResource";
  v38[6] = @"OSBundleCPUType";
  v38[7] = @"OSBundleCPUSubtype";
  v38[8] = @"OSBundlePath";
  v38[9] = @"OSBundleUUID";
  v38[10] = @"OSBundleStarted";
  v38[11] = @"OSBundleLoadTag";
  v38[12] = @"OSBundleLoadAddress";
  v38[13] = @"OSBundleLoadSize";
  v38[14] = @"OSBundleWiredSize";
  v38[15] = @"OSBundlePrelinked";
  v38[16] = @"OSBundleDependencies";
  v38[17] = @"OSBundleRetainCount";
  *(_OWORD *)CFNumberRef v35 = xmmword_1E548AAF8;
  long long v36 = off_1E548AB08;
  CFMutableDictionaryRef v37 = @"OSBundleIsInterface";
  memset(&context, 0, sizeof(context));
  long long v33 = 0u;
  long long v34 = 0u;
  memset(&v30, 0, sizeof(v30));
  __sOSKextInitializing = 1;
  __kOSKextCFTypeID TypeID = _CFRuntimeRegisterClass();
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorGetContext((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
  context.retain = 0;
  context.release = 0;
  CFAllocatorRef v2 = CFAllocatorCreate(v1, &context);
  if (v2)
  {
    CFAllocatorRef v8 = v2;
    values[0] = CFURLCreateFromFileSystemRepresentation(v2, (const UInt8 *)"/System/Library/Extensions", 26, 1u);
    values[1] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/Library/Extensions", 19, 1u);
    if (stat("/System/Library/DriverExtensions", &v30))
    {
      unsigned int v9 = 2;
    }
    else
    {
      *(void *)&long long v33 = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/System/Library/DriverExtensions", 32, 1u);
      unsigned int v9 = 3;
    }
    if (!stat("/Library/DriverExtensions", &v30)) {
      values[v9++] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/Library/DriverExtensions", 25, 1u);
    }
    if (!stat("/Library/Apple/System/Library/Extensions", &v30)) {
      values[v9++] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/Library/Apple/System/Library/Extensions", 40, 1u);
    }
    if (!stat("/AppleInternal/Library/Extensions", &v30)) {
      values[v9++] = CFURLCreateFromFileSystemRepresentation(v8, (const UInt8 *)"/AppleInternal/Library/Extensions", 33, 1u);
    }
    uint64_t v15 = 0;
    do
    {
      if (!values[v15]) {
        goto LABEL_22;
      }
      ++v15;
    }
    while (v9 != v15);
    CFArrayRef v16 = CFArrayCreate(v8, (const void **)values, v9, MEMORY[0x1E4F1D510]);
    __sOSKextSystemExtensionsFolderURLs = (uint64_t)v16;
    if (v16)
    {
      uint64_t v17 = MEMORY[0x1E4F1D510];
      __sOSKextPackageTypeValues = (uint64_t)CFArrayCreate(v1, (const void **)v42, 2, MEMORY[0x1E4F1D510]);
      __sOSKextOSBundleRequiredValues = (uint64_t)CFArrayCreate(v1, (const void **)v39, 6, (const CFArrayCallBacks *)v17);
      __sOSKextInfoEssentialKeys = (uint64_t)CFArrayCreate(v1, (const void **)v38, 18, (const CFArrayCallBacks *)v17);
      __sOSKextInfoKextOnlyKeys = (uint64_t)CFArrayCreate(v1, (const void **)v35, 5, (const CFArrayCallBacks *)v17);
      if (__sOSAllKexts) {
        goto LABEL_20;
      }
      long long v18 = *(_OWORD *)(v17 + 16);
      *(_OWORD *)&v29.version = *(_OWORD *)v17;
      *(_OWORD *)&v29.release = v18;
      v29.equal = *(CFArrayEqualCallBack *)(v17 + 32);
      v29.retain = 0;
      v29.release = 0;
      CFArrayRef v16 = CFArrayCreateMutable(v1, 0, &v29);
      __sOSAllKexts = (uint64_t)v16;
      if (v16)
      {
LABEL_20:
        if (__sOSKextsByURL) {
          goto LABEL_21;
        }
        long long v19 = *(_OWORD *)(MEMORY[0x1E4F1D540] + 16);
        *(_OWORD *)&v29.version = *MEMORY[0x1E4F1D540];
        *(_OWORD *)&v29.release = v19;
        v29.equal = *(CFArrayEqualCallBack *)(MEMORY[0x1E4F1D540] + 32);
        v29.retain = 0;
        v29.release = 0;
        uint64_t v20 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
        __sOSKextsByURL = (uint64_t)CFDictionaryCreateMutable(v1, 0, MEMORY[0x1E4F1D530], (const CFDictionaryValueCallBacks *)&v29);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v1, 0, v20, (const CFDictionaryValueCallBacks *)&v29);
        __sOSKextsByCFStringRef Identifier = (uint64_t)Mutable;
        if (__sOSKextsByURL)
        {
          if (Mutable)
          {
LABEL_21:
            __sOSNewKmodInfoKernelVersion = OSKextParseVersionString("6.0");
            OSKextSetArchitecture(0, v22, v23, v24, v25, v26, v27, v28);
            goto LABEL_24;
          }
        }
LABEL_22:
        CFArrayRef v16 = 0;
      }
    }
    OSKextLog((uint64_t)v16, 17, "Memory allocation failure.", v10, v11, v12, v13, v14, v29.version);
LABEL_24:
    CFRelease(v8);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v29.version);
  }
  __sOSKextInitializing = 0;
}

uint64_t OSKextSetArchitecture(const NXArchInfo *RunningKernelArchitecture, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFAllocatorRef v8 = RunningKernelArchitecture;
  unsigned int v9 = (const char **)__sOSKextArchInfo;
  if ((__sOSKextInitializing & 1) == 0) {
    RunningKernelArchitecture = (const NXArchInfo *)pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  }
  if (v9) {
    BOOL v10 = v9 == (const char **)v8;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    RunningKernelArchitecture = (const NXArchInfo *)__sOSKextArchInfo;
    goto LABEL_14;
  }
  __sOSKextArchInfo = 0;
  if (v8)
  {
    RunningKernelArchitecture = NXGetArchInfoFromCpuType(v8->cputype, v8->cpusubtype);
    __sOSKextArchInfo = (char **)RunningKernelArchitecture;
    if (!RunningKernelArchitecture)
    {
      io_name_t name = v8->name;
      if (!v8->name || !*name)
      {
        cpu_type_t cputype = v8->cputype;
        OSKextGetRunningKernelArchitecture(0, v11, v12, a4, a5, a6, a7, a8);
        OSKextLog(0, 7, "Unknown CPU info given (type %d, subtype %d), using running kernel architecture %s.", v28, v29, v30, v31, v32, cputype);
LABEL_34:
        uint64_t v23 = 0;
        uint64_t v22 = 0;
        RunningKernelArchitecture = (const NXArchInfo *)__sOSKextArchInfo;
        if (__sOSKextArchInfo) {
          goto LABEL_19;
        }
        goto LABEL_16;
      }
      OSKextLog(0, 23, "Architecture %s not found by CPU info (type %d, subtype %d), trying by name.", a4, a5, a6, a7, a8, (char)name);
      RunningKernelArchitecture = NXGetArchInfoFromName(v8->name);
      __sOSKextArchInfo = (char **)RunningKernelArchitecture;
      if (!RunningKernelArchitecture)
      {
        CFArrayRef v16 = v8->name;
        OSKextGetRunningKernelArchitecture(0, v14, v15, a4, a5, a6, a7, a8);
        OSKextLog(0, 23, "Architecture %s not found by name, using running kernel architecture %s.", v17, v18, v19, v20, v21, (char)v16);
        goto LABEL_34;
      }
    }
LABEL_14:
    uint64_t v22 = 1;
    goto LABEL_19;
  }
  uint64_t v23 = 1;
LABEL_16:
  RunningKernelArchitecture = (const NXArchInfo *)OSKextGetRunningKernelArchitecture((uint64_t)RunningKernelArchitecture, a2, a3, a4, a5, a6, a7, a8);
  if (!RunningKernelArchitecture) {
    RunningKernelArchitecture = (const NXArchInfo *)&__sOSKextUnknownArchInfo;
  }
  __sOSKextArchInfo = (char **)RunningKernelArchitecture;
  uint64_t v22 = v23;
LABEL_19:
  if (v9 == (const char **)RunningKernelArchitecture)
  {
    uint64_t v25 = *v9;
    if (!*v9) {
      uint64_t v25 = "(unknown)";
    }
    OSKextLog(0, 23, "Kext library architecture is %s (unchanged).", a4, a5, a6, a7, a8, (char)v25);
  }
  else
  {
    if ((__sOSKextInitializing & 1) == 0 && __sOSAllKexts)
    {
      CFArrayGetCount((CFArrayRef)__sOSAllKexts);
      RunningKernelArchitecture = (const NXArchInfo *)__sOSKextArchInfo;
    }
    uint64_t v24 = RunningKernelArchitecture->name;
    if (!RunningKernelArchitecture->name) {
      uint64_t v24 = "(unknown)";
    }
    OSKextLog(0, 262166, "Kext library architecture set to %s%s.", a4, a5, a6, a7, a8, (char)v24);
    if ((__sOSKextInitializing & 1) == 0)
    {
      if (__sOSKextsByURL) {
        CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextReinitApplierFunction, 0);
      }
      OSKextFlushLoadInfo(0, 1);
    }
  }
  return v22;
}

uint64_t OSKextParseVersionString(char *a1)
{
  if (!a1) {
    return -1;
  }
  if (!*a1) {
    return -1;
  }
  uint64_t v1 = (*a1 - 48);
  if (v1 > 9) {
    return -1;
  }
  uint64_t v2 = 0;
  CFNumberRef v35 = (unsigned __int8 *)(a1 + 1);
  do
  {
    uint64_t v3 = &a1[v2];
    unsigned int v4 = a1[v2 + 1];
    if (v4 <= 0x20 && ((1 << v4) & 0x100002601) != 0)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      CFNumberRef v35 = (unsigned __int8 *)(v3 + 1);
LABEL_17:
      int v16 = 9;
      return v13 + 1000000000000 * v1 + 10000 * v14 + (1000 * v16) + 100000000 * v15;
    }
    if ((v4 - 58) < 0xF6u)
    {
      CFNumberRef v35 = (unsigned __int8 *)&a1[v2 + 1];
      uint64_t v12 = -1;
      if (v4 - 46 > 0x38) {
        return v12;
      }
      if (((1 << (v4 - 46)) & 0x158000000000000) == 0)
      {
        if (v4 != 46) {
          return v12;
        }
        uint64_t v7 = &a1[v2];
LABEL_30:
        unsigned int v9 = (unsigned __int8 *)(v7 + 2);
        CFNumberRef v35 = (unsigned __int8 *)(v7 + 2);
        goto LABEL_31;
      }
      uint64_t v15 = 0;
      uint64_t v14 = 0;
      unsigned int v17 = v4;
LABEL_22:
      if (v17 <= 0x20 && ((1 << v17) & 0x100002601) != 0)
      {
LABEL_24:
        uint64_t v13 = 0;
        goto LABEL_17;
      }
      int v16 = __OSKextVersionStageForString(&v35);
      if (v16)
      {
        uint64_t v25 = 0;
        uint64_t v13 = 0;
        uint64_t v26 = v35;
        do
        {
          unsigned int v27 = v26[v25];
          if (v27 <= 0x20 && ((1 << v27) & 0x100002601) != 0)
          {
            if (!v25) {
              return -1;
            }
            goto LABEL_61;
          }
          if ((v27 - 58) < 0xF6u) {
            return -1;
          }
          unsigned int v29 = v27 - 48;
          if (v29 > 9) {
            return -1;
          }
          uint64_t v13 = 10 * v13 + v29;
          CFNumberRef v35 = &v26[++v25];
        }
        while (v25 != 3);
        unsigned int v30 = v26[v25];
        if (v30 <= 0x20 && ((1 << v30) & 0x100002600) != 0)
        {
          if (v13 > 255) {
            return -1;
          }
        }
        else
        {
          uint64_t v12 = -1;
          if (v30 || v13 > 255) {
            return v12;
          }
        }
LABEL_61:
        if (v16 == 7 && !v13) {
          return -1;
        }
        return v13 + 1000000000000 * v1 + 10000 * v14 + (1000 * v16) + 100000000 * v15;
      }
      return -1;
    }
    unsigned int v6 = v4 - 48;
    if (v6 > 9)
    {
      CFNumberRef v35 = (unsigned __int8 *)&a1[v2 + 1];
      return -1;
    }
    uint64_t v1 = 10 * v1 + v6;
    ++v2;
  }
  while (v2 != 3);
  uint64_t v7 = &a1[v2];
  CFAllocatorRef v8 = &a1[v2];
  int v11 = v8[1];
  unsigned int v9 = (unsigned __int8 *)(v8 + 1);
  int v10 = v11;
  CFNumberRef v35 = v9;
  if (v11 == 46) {
    goto LABEL_30;
  }
  if ((v10 - 58) > 0xFFFFFFF5) {
    return -1;
  }
LABEL_31:
  uint64_t v19 = 0;
  uint64_t v15 = 0;
  while (1)
  {
    unsigned int v20 = v9[v19];
    if (v20 <= 0x20 && ((1 << v20) & 0x100002601) != 0)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      goto LABEL_17;
    }
    if ((v20 - 58) < 0xF6u) {
      break;
    }
    unsigned int v22 = v20 - 48;
    if (v22 > 9) {
      return -1;
    }
    uint64_t v15 = 10 * v15 + v22;
    CFNumberRef v35 = &v9[++v19];
    if (v19 == 4)
    {
      uint64_t v23 = &v9[v19];
      int v24 = v9[v19];
      if (v24 != 46)
      {
        if ((v24 - 58) > 0xFFFFFFF5) {
          return -1;
        }
        goto LABEL_67;
      }
LABEL_66:
      CFNumberRef v35 = ++v23;
LABEL_67:
      uint64_t v31 = 0;
      uint64_t v14 = 0;
      while (1)
      {
        unsigned int v17 = v23[v31];
        if (v17 <= 0x20 && ((1 << v17) & 0x100002601) != 0) {
          goto LABEL_24;
        }
        if ((v17 - 58) < 0xF6u)
        {
          if (v17 - 97 > 5 || ((1 << (v17 - 97)) & 0x2B) == 0) {
            return -1;
          }
          goto LABEL_22;
        }
        unsigned int v33 = v17 - 48;
        if (v33 > 9) {
          return -1;
        }
        uint64_t v14 = 10 * v14 + v33;
        CFNumberRef v35 = &v23[++v31];
        if (v31 == 4)
        {
          unsigned int v17 = v23[v31];
          if (v17 == 46)
          {
            CFNumberRef v35 = &v23[v31 + 1];
            unsigned int v17 = *v35;
            goto LABEL_22;
          }
          if ((v17 - 58) <= 0xF5u) {
            goto LABEL_22;
          }
          return -1;
        }
      }
    }
  }
  uint64_t v12 = -1;
  if (v20 - 46 > 0x38) {
    return v12;
  }
  if (((1 << (v20 - 46)) & 0x158000000000000) != 0)
  {
    uint64_t v14 = 0;
    unsigned int v17 = v9[v19];
    goto LABEL_22;
  }
  if (v20 == 46)
  {
    uint64_t v23 = &v9[v19];
    goto LABEL_66;
  }
  return v12;
}

char **OSKextGetRunningKernelArchitecture(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  cpu_subtype_t v13 = -1;
  cpu_type_t v14 = -1;
  uint64_t result = (char **)OSKextGetRunningKernelArchitecture_result;
  if ((char **)OSKextGetRunningKernelArchitecture_result != &__sOSKextUnknownArchInfo)
  {
    if (OSKextGetRunningKernelArchitecture_result) {
      return result;
    }
    goto LABEL_10;
  }
  io_registry_entry_t RootEntry = IORegistryGetRootEntry(0);
  if (!RootEntry
    || (io_registry_entry_t v10 = RootEntry,
        !__OSKextReadRegistryNumberProperty(RootEntry, @"OSKernelCPUType", kCFNumberSInt32Type, &v14))|| !__OSKextReadRegistryNumberProperty(v10, @"OSKernelCPUSubtype", kCFNumberSInt32Type, &v13))
  {
LABEL_9:
    uint64_t result = (char **)OSKextGetRunningKernelArchitecture_result;
    if (OSKextGetRunningKernelArchitecture_result) {
      return result;
    }
    goto LABEL_10;
  }
  int v11 = NXGetArchInfoFromCpuType(v14, v13);
  OSKextGetRunningKernelArchitecture_uint64_t result = (uint64_t)v11;
  if (v11)
  {
    OSKextLog(0, 262148, "Running kernel architecture is %s.", a4, a5, a6, a7, a8, (char)v11->name);
    goto LABEL_9;
  }
LABEL_10:
  OSKextLog(0, 81, "Can't read running kernel architecture.", a4, a5, a6, a7, a8, v12);
  OSKextGetRunningKernelArchitecture_uint64_t result = (uint64_t)&__sOSKextUnknownArchInfo;
  return &__sOSKextUnknownArchInfo;
}

uint64_t __OSKextReadRegistryNumberProperty(io_registry_entry_t a1, const __CFString *a2, CFNumberType a3, void *a4)
{
  CFNumberRef CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(a1, a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (CFProperty)
  {
    CFNumberRef v12 = CFProperty;
    CFTypeID v13 = CFGetTypeID(CFProperty);
    if (v13 == CFNumberGetTypeID())
    {
      uint64_t Value = CFNumberGetValue(v12, a3, a4);
    }
    else
    {
      OSKextLog(0, 81, "Can't read kernel CPU info from IORegistry (absent or wrong type).", v14, v15, v16, v17, v18, v21);
      uint64_t Value = 0;
    }
    CFRelease(v12);
  }
  else
  {
    OSKextLog(0, 81, "Can't read kernel CPU info from IORegistry (absent or wrong type).", v7, v8, v9, v10, v11, v21);
    return 0;
  }
  return Value;
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return IORegistryEntrySearchCFProperty(entry, 0, key, allocator, 0);
}

CFTypeRef OSKextCopyLoadedKextInfoByUUID(unint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef theDict = 0;
  CFTypeRef cf = 0;
  OSKextLog(0, 69, "Reading loaded kext info from kernel.", a4, a5, a6, a7, a8, v40);
  uint64_t v10 = __OSKextCreateKextRequest(@"Get Loaded Kext Info By UUID", a1, &theDict);
  if (!v10)
  {
    OSKextLog(0, 65, "Failed to create kext request.", v11, v12, v13, v14, v15, v41);
    return cf;
  }
  uint64_t v16 = v10;
  if (a2 && CFArrayGetCount((CFArrayRef)a2)) {
    CFDictionarySetValue(theDict, @"Kext Request Info Keys", a2);
  }
  mach_error_t v17 = __OSKextSendKextRequest(0, v16, &cf, 0, 0);
  if (v17)
  {
    uint64_t v23 = mach_error_string(v17);
    unsigned int v29 = "(unknown)";
    if (v23) {
      LOBYTE(v29) = (_BYTE)v23;
    }
    OSKextLog(0, 65, "Failed to read loaded kext info from kernel - %s.", v24, v25, v26, v27, v28, (char)v29);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
    goto LABEL_25;
  }
  if (!cf)
  {
    uint64_t v38 = "Kernel request call returned no data.";
LABEL_24:
    OSKextLog(0, 65, v38, v18, v19, v20, v21, v22, v41);
LABEL_25:
    CFRelease(v16);
    return cf;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(cf))
  {
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
    uint64_t v38 = "Loaded kext info from kernel is wrong type.";
    goto LABEL_24;
  }
  if ((~__sUserLogFilter & 7) != 0 || (__sUserLogFilter & 0x60) == 0) {
    goto LABEL_25;
  }
  CFStringForPlist_new = createCFStringForPlist_new(cf, 1);
  UTF8CStringForCFString = createUTF8CStringForCFString(CFStringForPlist_new);
  OSKextLog(0, 103, "Loaded kext info:\n%s", v33, v34, v35, v36, v37, (char)UTF8CStringForCFString);
  CFRelease(v16);
  if (CFStringForPlist_new) {
    CFRelease(CFStringForPlist_new);
  }
  if (UTF8CStringForCFString) {
    free(UTF8CStringForCFString);
  }
  return cf;
}

CFTypeRef OSKextCopyUUIDForAddress(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  uint64_t valuePtr = a1;
  CFMutableDictionaryRef theDict = 0;
  OSKextLog(0, 69, "Reading kext UUID for Address\n.", a4, a5, a6, a7, a8, v36);
  uint64_t v8 = __OSKextCreateKextRequest(@"Get Kext UUID by Address", 0, &theDict);
  if (!v8)
  {
    OSKextLog(0, 65, "Failed to create kext request.", v9, v10, v11, v12, v13, v37);
    return 0;
  }
  uint64_t v14 = v8;
  CFNumberRef v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (!v15)
  {
    OSKextLog(0, 65, "Failed to create lookup address object.", v16, v17, v18, v19, v20, v37);
    CFRelease(v14);
    return 0;
  }
  CFNumberRef v21 = v15;
  CFDictionarySetValue(theDict, @"Kext Request Lookup Address", v15);
  mach_error_t v22 = __OSKextSendKextRequest(0, v14, &cf, 0, 0);
  if (v22)
  {
    uint64_t v28 = mach_error_string(v22);
    uint64_t v34 = "(unknown)";
    if (v28) {
      LOBYTE(v34) = (_BYTE)v28;
    }
    OSKextLog(0, 65, "Failed to lookup uuid with address from kernel - %s.", v29, v30, v31, v32, v33, (char)v34);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
  }
  else if (!cf)
  {
    OSKextLog(0, 65, "Kernel request call returned no data.", v23, v24, v25, v26, v27, v37);
  }
  CFRelease(v14);
  CFRelease(v21);
  return cf;
}

void OSKextLog(uint64_t a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void OSKextVLog(uint64_t a1, int a2, const char *a3, va_list a4)
{
  va_list v8 = a4;
  v7[0] = 0;
  if (__sOSKextLogOutputFunction)
  {
    int v6 = a1;
    if (__OSKextShouldLog(a1, a2))
    {
      v7[1] = v8;
      vasprintf(v7, a3, v8);
      if (v7[0])
      {
        __sOSKextLogOutputFunction(v6, a2, "%s", v7[0]);
        if (v7[0]) {
          free(v7[0]);
        }
      }
    }
  }
}

BOOL __OSKextShouldLog(uint64_t a1, int a2)
{
  if (!a1 || (*(unsigned char *)(a1 + 92) & 0x10) != 0) {
    a2 |= 8u;
  }
  unsigned int v2 = a2 & 7;
  if ((a2 & 7) == 0) {
    return 1;
  }
  unsigned int v3 = __sUserLogFilter & 7;
  if (v2 <= 3 && v2 <= v3) {
    return 1;
  }
  if (((__sUserLogFilter | a2) & 8) == 0) {
    return 0;
  }
  return (a2 & __sUserLogFilter & 0xFFFFFF0) != 0 && v2 <= v3;
}

uint64_t __OSKextSendKextRequest(uint64_t a1, const void *a2, void *a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  kern_return_t v47;

  uint64_t v47 = -603979775;
  vm_offset_t response_data = 0;
  response_mach_msg_type_number_t dataCnt = 0;
  vm_offset_t log_data = 0;
  log_mach_msg_type_number_t dataCnt = 0;
  CFTypeRef cf = 0;
  host_priv_t v10 = MEMORY[0x18C1311A0]();
  CFDataRef v11 = IOCFSerialize(a2, 0);
  if (v11)
  {
    CFDataRef v17 = v11;
    if (__sOSKextLogOutputFunction) {
      uint32_t v18 = __sKernelLogFilter;
    }
    else {
      uint32_t v18 = 0;
    }
    BytePtr = CFDataGetBytePtr(v11);
    mach_msg_type_number_t Length = CFDataGetLength(v17);
    uint64_t v21 = kext_request(v10, v18, (vm_offset_t)BytePtr, Length, &response_data, &response_dataCnt, &log_data, &log_dataCnt, &v47);
    uint64_t v22 = __OSKextProcessKextRequestResults(a1, v21, v47, (char *)log_data, log_dataCnt);
    if (v22)
    {
      int v23 = 1;
    }
    else
    {
      int v23 = 1;
      if (response_data)
      {
        mach_msg_type_number_t v26 = response_dataCnt;
        if (response_dataCnt)
        {
          if (a3)
          {
            CFTypeRef v27 = IOCFUnserialize((const char *)response_data, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef *)&cf);
            *a3 = v27;
            if (v27)
            {
              uint64_t v22 = 0;
            }
            else
            {
              if (cf)
              {
                UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)cf);
                CFTypeID v39 = UTF8CStringForCFString;
                char v40 = "unknown error";
                if (UTF8CStringForCFString) {
                  LOBYTE(v40) = (_BYTE)UTF8CStringForCFString;
                }
                OSKextLog(a1, 65, "Can't unserialize kext request response: %s", v34, v35, v36, v37, v38, (char)v40);
                if (v39) {
                  free(v39);
                }
              }
              else
              {
                OSKextLog(a1, 65, "Can't unserialize kext request response: %s", v28, v29, v30, v31, v32, (char)"unknown error");
              }
              if (cf) {
                CFRelease(cf);
              }
              uint64_t v22 = 3691020296;
              CFTypeRef cf = 0;
            }
          }
          else
          {
            uint64_t v22 = 0;
            if (a4 && a5)
            {
              uint64_t v22 = 0;
              int v23 = 0;
              *a4 = response_data;
              *a5 = v26;
            }
          }
        }
      }
    }
    CFRelease(v17);
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    uint64_t v22 = 3691020296;
    OSKextLog(a1, 65, "Failed to serialize kext request.", v12, v13, v14, v15, v16, op_result);
    int v23 = 1;
  }
  uint64_t v24 = (vm_map_t *)MEMORY[0x1E4F14960];
  if (v23 && response_data && response_dataCnt) {
    mach_vm_deallocate(*MEMORY[0x1E4F14960], response_data, response_dataCnt);
  }
  if (log_data) {
    mach_vm_deallocate(*v24, log_data, log_dataCnt);
  }
  if (v10) {
    mach_port_deallocate(*v24, v10);
  }
  return v22;
}

CFTypeRef IOCFUnserialize(const char *buffer, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  if (errorString) {
    *CFStringRef errorString = 0;
  }
  uint64_t v7 = 0;
  if (buffer && !options)
  {
    va_list v8 = malloc_type_malloc(0x40uLL, 0x10F0040CDBDF800uLL);
    if (v8)
    {
      uint64_t v9 = v8;
      void *v8 = buffer;
      v8[1] = 0x100000000;
      v8[3] = 0;
      v8[4] = 0;
      v8[2] = allocator;
      _OWORD v8[5] = CFDictionaryCreateMutable(allocator, 0, 0, MEMORY[0x1E4F1D540]);
      v9[6] = errorString;
      v9[7] = 0;
      IOCFUnserializeparse();
      uint64_t v7 = (const void *)v9[7];
      host_priv_t v10 = (void *)v9[3];
      if (v10)
      {
        do
        {
          CFDataRef v11 = (const void *)v10[3];
          if (v11) {
            CFRelease(v11);
          }
          uint64_t v12 = (void *)v10[6];
          if (v12) {
            free(v12);
          }
          uint64_t v13 = (const void *)v10[4];
          if (v13) {
            CFRelease(v13);
          }
          uint64_t v14 = (void *)v10[7];
          if (v14) {
            free(v14);
          }
          uint64_t v15 = (void *)v10[1];
          free(v10);
          host_priv_t v10 = v15;
        }
        while (v15);
      }
      CFRelease((CFTypeRef)v9[5]);
      free(v9);
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t IOCFUnserializeparse()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v87 = 0;
  int v1 = 0u;
  v98[4] = *MEMORY[0x1E4F143B8];
  __src = v93;
  uint64_t v2 = 200;
  memset(v93, 0, 512);
  CFArrayRef v85 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFNumberRef v86 = (const void *)*MEMORY[0x1E4F1CFC8];
  unsigned int v3 = v94;
  unsigned int v4 = v94;
  uint64_t v5 = (uint64_t *)v93;
  int v6 = -2;
  while (1)
  {
    *(_WORD *)unsigned int v4 = v1;
    if (&v3[2 * v2 - 2] <= v4)
    {
      if ((unint64_t)v2 >> 4 > 0x270
        || ((unint64_t)(2 * v2) >= 0x2710 ? (uint64_t v2 = 10000) : (v2 *= 2),
            (uint64_t v7 = (char *)malloc_type_malloc(10 * v2 + 7, 0x5CF3AA9FuLL)) == 0))
      {
        IOCFUnserializeerror((CFStringRef)v0, (uint64_t)"memory exhausted");
        uint64_t v81 = 2;
        goto LABEL_205;
      }
      va_list v8 = v7;
      uint64_t v9 = v4 - v3;
      host_priv_t v10 = v3;
      uint64_t v11 = v9 >> 1;
      uint64_t v12 = (v9 >> 1) + 1;
      memcpy(v7, v10, 2 * v12);
      memcpy(&v8[(2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8], __src, 8 * v12);
      if (v10 != v94) {
        free(v10);
      }
      if (v2 <= v12)
      {
        uint64_t v81 = 1;
        unsigned int v3 = v8;
        goto LABEL_205;
      }
      unsigned int v4 = &v8[2 * v11];
      uint64_t v5 = (uint64_t *)&v8[8 * v12 - 8 + ((2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8)];
      unsigned int v3 = v8;
      __src = &v8[(2 * v2 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
    if (((0xFEB5FFC3FEuLL >> v1) & 1) == 0)
    {
      int v13 = yypact[v1];
      if (v6 != -2) {
        goto LABEL_44;
      }
      unsigned int v92 = 0;
      while (1)
      {
        do
        {
          while (1)
          {
            int v14 = *(_DWORD *)(v0 + 8);
            int v15 = *(unsigned __int8 *)(*(void *)v0 + v14);
            if (v15 == 32 || v15 == 9)
            {
              CFDataRef v17 = (unsigned __int8 *)(*(void *)v0 + v14 + 1);
              do
              {
                do
                {
                  *(_DWORD *)(v0 + 8) = ++v14;
                  int v18 = *v17++;
                  int v15 = v18;
                }
                while (v18 == 9);
              }
              while (v15 == 32);
              if (!v15)
              {
                int v6 = 0u;
                goto LABEL_44;
              }
            }
            if (v15 != 10) {
              break;
            }
            int v26 = *(_DWORD *)(v0 + 12) + 1;
            *(_DWORD *)(v0 + 8) = v14 + 1;
            *(_DWORD *)(v0 + 12) = v26;
          }
          int v6 = (char)v15;
          if (!(_BYTE)v15) {
            goto LABEL_44;
          }
          int Tag = getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str);
        }
        while (Tag == 4);
        int v20 = Tag;
        if (!Tag)
        {
LABEL_184:
          int v6 = 267;
          goto LABEL_44;
        }
        int v88 = v13;
        newObject(v0);
        uint64_t v87 = v21;
        *(_DWORD *)(v21 + 72) = -1;
        uint64_t v84 = v92;
        if ((int)v92 >= 1) {
          break;
        }
LABEL_35:
        if (SLOBYTE(v98[0]) != 112)
        {
          int v6 = 267;
          int v13 = v88;
          switch(LOBYTE(v98[0]))
          {
            case 'a':
              if (LODWORD(v98[0]) == 1634890337 && WORD2(v98[0]) == 121)
              {
                if (v20 != 3)
                {
                  BOOL v77 = v20 == 1;
                  int v78 = 40;
                  goto LABEL_191;
                }
                *(void *)(v87 + 16) = 0;
                int v6 = 0x102u;
              }
              break;
            case 'b':
            case 'c':
            case 'e':
            case 'g':
            case 'h':
            case 'j':
              goto LABEL_44;
            case 'd':
              if (LODWORD(v98[0]) ^ 0x74636964 | BYTE4(v98[0]))
              {
                if (!(LODWORD(v98[0]) ^ 0x61746164 | BYTE4(v98[0])))
                {
                  int v91 = 0;
                  if (v20 == 3)
                  {
                    *(void *)(v87 + 48) = 0;
                    *(_DWORD *)(v87 + 40) = 0;
                    int v6 = 0x104u;
                  }
                  else
                  {
                    *(void *)(v87 + 48) = getCFEncodedData((uint64_t *)v0, &v91);
                    *(_DWORD *)(v87 + 40) = v91;
                    if (getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) == 2)
                    {
                      if (LODWORD(v98[0]) ^ 0x61746164 | BYTE4(v98[0])) {
                        int v6 = 267;
                      }
                      else {
                        int v6 = 260;
                      }
                    }
                  }
                }
              }
              else if (v20 == 3)
              {
                *(void *)(v87 + 16) = 0;
                int v6 = 0x105u;
              }
              else if (v20 == 1)
              {
                int v6 = 123;
              }
              else
              {
                int v6 = 125;
              }
              break;
            case 'f':
              BOOL v69 = LODWORD(v98[0]) != 1936482662 || WORD2(v98[0]) != 101;
              if (v20 == 3 && !v69)
              {
                *(void *)(v87 + 64) = 0;
                goto LABEL_152;
              }
              break;
            case 'i':
              if (v98[0] == 0x72656765746E69)
              {
                *(_DWORD *)(v87 + 40) = 64;
                if ((int)v84 >= 1)
                {
                  CFTypeID v70 = __str;
                  mach_port_name_t v71 = __s1;
                  do
                  {
                    if (!strcmp(v71, "size")) {
                      *(_DWORD *)(v87 + 40) = strtoul(v70, 0, 0);
                    }
                    v70 += 32;
                    v71 += 32;
                    --v84;
                  }
                  while (v84);
                }
                if (v20 != 3)
                {
                  *(void *)(v87 + 64) = getNumber((uint64_t *)v0);
                  if (getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) != 2) {
                    goto LABEL_184;
                  }
                  BOOL v73 = v98[0] == 0x72656765746E69;
                  int v74 = 264;
                  goto LABEL_181;
                }
                *(void *)(v87 + 64) = 0;
                int v6 = 0x108u;
              }
              break;
            case 'k':
              if (v20 != 3 && LODWORD(v98[0]) == 7955819)
              {
                String = getString((uint64_t *)v0);
                *(void *)(v87 + 56) = String;
                if (String)
                {
                  if (getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) == 2)
                  {
                    BOOL v73 = LODWORD(v98[0]) == 7955819;
                    int v74 = 263;
LABEL_181:
                    if (v73) {
                      int v6 = v74;
                    }
                    else {
                      int v6 = 267;
                    }
                  }
                }
              }
              break;
            default:
              if (SLOBYTE(v98[0]) == 115)
              {
                if (LODWORD(v98[0]) == 1769108595 && *(_DWORD *)((char *)v98 + 3) == 6778473)
                {
                  if (v20 == 3)
                  {
                    long long v76 = malloc_type_malloc(1uLL, 0xC339ED7CuLL);
                    *(void *)(v87 + 56) = v76;
                    *long long v76 = 0;
                    int v6 = 0x10Au;
                  }
                  else
                  {
                    long long v79 = getString((uint64_t *)v0);
                    *(void *)(v87 + 56) = v79;
                    if (v79 && getTag(v0, (uint64_t)v98, (int *)&v92, (uint64_t)__s1, (uint64_t)__str) == 2)
                    {
                      BOOL v77 = (LODWORD(v98[0]) ^ 0x69727473 | *(_DWORD *)((char *)v98 + 3) ^ 0x676E69) == 0;
                      int v78 = 266;
LABEL_191:
                      if (v77) {
                        int v6 = v78;
                      }
                      else {
                        int v6 = v78 + 1;
                      }
                    }
                  }
                }
                else if (LODWORD(v98[0]) == 7628147)
                {
                  if (v20 == 1)
                  {
                    int v6 = 0x5Bu;
                  }
                  else if (v20 == 3)
                  {
                    *(void *)(v87 + 16) = 0;
                    int v6 = 0x109u;
                  }
                  else
                  {
                    int v6 = 0x5Du;
                  }
                }
              }
              else if (SLOBYTE(v98[0]) == 116 && v20 == 3 && !(LODWORD(v98[0]) ^ 0x65757274 | BYTE4(v98[0])))
              {
                *(void *)(v87 + 64) = 1;
LABEL_152:
                int v6 = 0x103u;
              }
              break;
          }
          goto LABEL_44;
        }
        BOOL v25 = LODWORD(v98[0]) == 1936288880 && WORD2(v98[0]) == 116;
        int v13 = v88;
        if (!v25) {
          goto LABEL_184;
        }
        *(void *)uint64_t v87 = *(void *)(v0 + 32);
        *(void *)(v0 + 32) = v87;
      }
      uint64_t v22 = __str;
      uint64_t v23 = v92;
      uint64_t v24 = v97;
      while (1)
      {
        if (*(v24 - 2) != 73 || *(v24 - 1) != 68) {
          goto LABEL_34;
        }
        if (*v24) {
          break;
        }
        *(_DWORD *)(v87 + 72) = strtol(v22, 0, 0);
LABEL_34:
        v22 += 32;
        v24 += 32;
        if (!--v23) {
          goto LABEL_35;
        }
      }
      if (*v24 == 82 && v24[1] == 69 && v24[2] == 70)
      {
        int v6 = 267;
        if (v20 == 3 && !v24[3])
        {
          *(_DWORD *)(v87 + 72) = strtol(v22, 0, 0);
          int v6 = 0x106u;
        }
      }
      else
      {
        int v6 = 0x10Bu;
      }
      int v13 = v88;
LABEL_44:
      if (v6 < 1)
      {
        int v27 = 0;
        int v6 = 0;
      }
      else
      {
        int v27 = v6 > 0x10B ? 2 : yytranslate[v6];
      }
      uint64_t v28 = (v27 + v13);
      if (v28 <= 0x6C && v27 == yycheck[v28]) {
        break;
      }
    }
    uint64_t v29 = v1;
    if ((0x14A003C00uLL >> v1)) {
      goto LABEL_201;
    }
    uint64_t v30 = yydefact[v1];
    uint64_t v31 = yyr2[yydefact[v29]];
    uint64_t v32 = v5[1 - v31];
    switch((int)v30)
    {
      case 2:
        long long v80 = "unexpected end of buffer";
        goto LABEL_202;
      case 3:
        uint64_t v81 = 0;
        *(void *)(v0 + 56) = *(void *)(*v5 + 24);
        *(void *)(*v5 + 24) = 0;
        uint64_t v83 = (void *)*v5;
        *uint64_t v83 = *(void *)(v0 + 32);
        *(void *)(v0 + 32) = v83;
        goto LABEL_205;
      case 4:
        goto LABEL_201;
      case 5:
        uint64_t v32 = *v5;
        uint64_t v33 = *(void **)(*v5 + 16);
        if (v33)
        {
          CFIndex v34 = 0;
          uint64_t v35 = 0;
          do
          {
            uint64_t v36 = v33;
            uint64_t v33 = (void *)*v33;
            *uint64_t v36 = v35;
            ++v34;
            uint64_t v35 = v36;
          }
          while (v33);
        }
        else
        {
          uint64_t v36 = 0;
          CFIndex v34 = 0;
        }
        CFTypeID v89 = v3;
        *(void *)(v32 + 16) = v36;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(v0 + 16), v34, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFIndex v55 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v55 & 0x80000000) == 0) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v55, Mutable);
        }
        CFUUIDRef v56 = *(uint64_t ***)(v32 + 16);
        if (v56)
        {
          do
          {
            CFDictionarySetValue(Mutable, v56[4], v56[3]);
            CFRelease(v56[4]);
            CFRelease(v56[3]);
            v56[3] = 0;
            v56[4] = 0;
            CFAllocatorRef v57 = *v56;
            *CFUUIDRef v56 = *(uint64_t **)(v0 + 32);
            *(void *)(v0 + 32) = v56;
            CFUUIDRef v56 = (uint64_t **)v57;
          }
          while (v57);
        }
        goto LABEL_112;
      case 6:
        uint64_t v32 = *v5;
        uint64_t v37 = *(void **)(*v5 + 16);
        if (v37)
        {
          CFIndex v38 = 0;
          CFTypeID v39 = 0;
          do
          {
            char v40 = v37;
            uint64_t v37 = (void *)*v37;
            *char v40 = v39;
            ++v38;
            CFTypeID v39 = v40;
          }
          while (v37);
        }
        else
        {
          char v40 = 0;
          CFIndex v38 = 0;
        }
        CFTypeID v89 = v3;
        *(void *)(v32 + 16) = v40;
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v0 + 16), v38, MEMORY[0x1E4F1D510]);
        CFTypeRef v58 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v58 & 0x80000000) == 0) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v58, Mutable);
        }
        IOReturn v59 = *(uint64_t ***)(v32 + 16);
        if (v59)
        {
          do
          {
            CFArrayAppendValue(Mutable, v59[3]);
            CFRelease(v59[3]);
            v59[3] = 0;
            CFArrayRef v60 = *v59;
            *IOReturn v59 = *(uint64_t **)(v0 + 32);
            *(void *)(v0 + 32) = v59;
            IOReturn v59 = (uint64_t **)v60;
          }
          while (v60);
        }
        goto LABEL_112;
      case 7:
        uint64_t v32 = *v5;
        char v41 = *(void **)(*v5 + 16);
        if (v41)
        {
          CFIndex v42 = 0;
          uint64_t v43 = 0;
          do
          {
            mach_port_t v44 = v41;
            char v41 = (void *)*v41;
            *mach_port_t v44 = v43;
            ++v42;
            uint64_t v43 = v44;
          }
          while (v41);
        }
        else
        {
          mach_port_t v44 = 0;
          CFIndex v42 = 0;
        }
        CFTypeID v89 = v3;
        *(void *)(v32 + 16) = v44;
        CFMutableDictionaryRef Mutable = CFSetCreateMutable(*(CFAllocatorRef *)(v0 + 16), v42, MEMORY[0x1E4F1D548]);
        uint64_t v61 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v61 & 0x80000000) == 0) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v61, Mutable);
        }
        CFArrayRef v62 = *(uint64_t ***)(v32 + 16);
        if (v62)
        {
          do
          {
            CFSetAddValue(Mutable, v62[3]);
            CFRelease(v62[3]);
            v62[3] = 0;
            CFArrayRef v63 = *v62;
            *CFArrayRef v62 = *(uint64_t **)(v0 + 32);
            *(void *)(v0 + 32) = v62;
            CFArrayRef v62 = (uint64_t **)v63;
          }
          while (v63);
        }
LABEL_112:
        *(void *)(v32 + 24) = Mutable;
        unsigned int v3 = v89;
        goto LABEL_113;
      case 8:
      case 19:
        uint64_t v32 = *v5;
        buildString(v0, *v5);
        goto LABEL_113;
      case 9:
        uint64_t v32 = *v5;
        CFDataRef v45 = CFDataCreate(*(CFAllocatorRef *)(v0 + 16), *(const UInt8 **)(*v5 + 48), *(int *)(*v5 + 40));
        uint64_t v46 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v46 & 0x80000000) == 0) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v46, v45);
        }
        if (*(_DWORD *)(v32 + 40)) {
          free(*(void **)(v32 + 48));
        }
        *(void *)(v32 + 48) = 0;
        goto LABEL_85;
      case 10:
        uint64_t v32 = *v5;
        if (*(int *)(*v5 + 40) < 33) {
          CFNumberType v47 = kCFNumberSInt32Type;
        }
        else {
          CFNumberType v47 = kCFNumberSInt64Type;
        }
        CFDataRef v45 = CFNumberCreate(*(CFAllocatorRef *)(v0 + 16), v47, (const void *)(*v5 + 64));
        uint64_t v48 = (const void *)*(unsigned int *)(v32 + 72);
        if ((v48 & 0x80000000) == 0) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v0 + 40), v48, v45);
        }
LABEL_85:
        *(void *)(v32 + 24) = v45;
        goto LABEL_113;
      case 11:
        uint64_t v32 = *v5;
        if (*(void *)(*v5 + 64)) {
          CFArrayRef v49 = v85;
        }
        else {
          CFArrayRef v49 = v86;
        }
        *(void *)(v32 + 24) = CFRetain(v49);
        goto LABEL_113;
      case 12:
        uint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v0 + 40), (const void *)*(int *)(*v5 + 72));
        if (!Value)
        {
          long long v80 = "forward reference detected";
          goto LABEL_202;
        }
        CFIndex v51 = Value;
        newObject(v0);
        uint64_t v32 = v52;
        *(void *)(v52 + 24) = v51;
        CFRetain(v51);
LABEL_93:
        CFArrayRef v53 = (void *)*v5;
        *CFArrayRef v53 = *(void *)(v0 + 32);
        *(void *)(v0 + 32) = v53;
LABEL_113:
        CFIndex v64 = &v5[-v31];
        v4 -= 2 * v31;
        v64[1] = v32;
        uint64_t v5 = v64 + 1;
        uint64_t v65 = yyr1[v30] - 19;
        uint64_t v66 = (*(__int16 *)v4 + yypgoto[v65]);
        if (v66 <= 0x6C && *(unsigned __int16 *)v4 == (unsigned __int16)yycheck[v66]) {
          int v1 = yytable[v66];
        }
        else {
          int v1 = yydefgoto[v65];
        }
LABEL_117:
        v4 += 2;
        break;
      case 13:
      case 20:
      case 23:
        uint64_t v32 = *(v5 - 1);
        *(void *)(v32 + 16) = 0;
        goto LABEL_113;
      case 14:
      case 21:
      case 24:
        uint64_t v32 = *(v5 - 2);
        *(void *)(v32 + 16) = *(v5 - 1);
        goto LABEL_113;
      case 17:
      case 27:
        uint64_t v32 = *v5;
        *(void *)*uint64_t v5 = *(v5 - 1);
        goto LABEL_113;
      case 18:
        uint64_t v32 = *(v5 - 1);
        *(void *)(v32 + 32) = *(void *)(v32 + 24);
        *(void *)(v32 + 24) = *(void *)(*v5 + 24);
        *(void *)uint64_t v32 = 0;
        *(void *)(*v5 + 24) = 0;
        goto LABEL_93;
      case 26:
        uint64_t v32 = *v5;
        *(void *)*uint64_t v5 = 0;
        goto LABEL_113;
      default:
        goto LABEL_113;
    }
  }
  int v1 = yytable[v28];
  if (!yytable[v28])
  {
LABEL_201:
    long long v80 = "syntax error";
LABEL_202:
    IOCFUnserializeerror((CFStringRef)v0, (uint64_t)v80);
    uint64_t v81 = 1;
    goto LABEL_205;
  }
  if (v28 != 10)
  {
    if (v6) {
      int v6 = -2;
    }
    else {
      int v6 = 0;
    }
    v5[1] = v87;
    ++v5;
    goto LABEL_117;
  }
  uint64_t v81 = 0;
LABEL_205:
  if (v3 != v94) {
    free(v3);
  }
  return v81;
}

uint64_t getTag(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  uint64_t v6 = *(void *)a1;
  int v7 = *(unsigned __int8 *)(*(void *)a1 + *(int *)(a1 + 8));
  *a3 = 0;
  if (v7 != 60) {
    return v5;
  }
  uint64_t v8 = *(int *)(a1 + 8);
  LODWORD(v9) = v8 + 1;
  *(_DWORD *)(a1 + 8) = v8 + 1;
  LODWORD(v10) = *(unsigned __int8 *)(v6 + v8 + 1);
  switch(v10)
  {
    case '!':
      *(_DWORD *)(a1 + 8) = v8 + 2;
      int v14 = *(char *)(v6 + v8 + 2);
      if (v14 == 45)
      {
        LODWORD(v15) = v8 + 3;
        *(_DWORD *)(a1 + 8) = v8 + 3;
        int v16 = *(char *)(v6 + v8 + 3);
        char v17 = v16 == 45;
        if (v16) {
          int v14 = v16;
        }
        else {
          int v14 = 0;
        }
        if (!v16) {
          char v17 = 0;
        }
      }
      else
      {
        LODWORD(v15) = v8 + 2;
        char v17 = 0;
      }
      uint64_t v5 = 0;
      char v23 = ((v14 - 91) < 0xFFFFFFE6) & ~v17;
      if ((v14 - 123) >= 0xFFFFFFE6) {
        char v23 = 0;
      }
      if ((v23 & 1) != 0 || !v14) {
        return v5;
      }
      while (1)
      {
        uint64_t v24 = (int)v15;
        uint64_t v15 = (int)v15 + 1;
        *(_DWORD *)(a1 + 8) = v15;
        uint64_t v5 = *(unsigned __int8 *)(v6 + v15);
        if (v5 == 10) {
          break;
        }
        if (!*(unsigned char *)(v6 + v15)) {
          return v5;
        }
        if (v17)
        {
          if (v5 != 45) {
            goto LABEL_45;
          }
          LODWORD(v15) = v24 + 2;
          *(_DWORD *)(a1 + 8) = v24 + 2;
          uint64_t v5 = *(char *)(v6 + v24 + 2);
          if (v5 == 45)
          {
            LODWORD(v15) = v24 + 3;
            *(_DWORD *)(a1 + 8) = v24 + 3;
            LODWORD(v5) = *(unsigned __int8 *)(v6 + v24 + 3);
            goto LABEL_42;
          }
LABEL_46:
          if (!v5) {
            return v5;
          }
        }
        else
        {
LABEL_42:
          if (v5 == 62)
          {
            int v13 = v15 + 1;
            goto LABEL_12;
          }
LABEL_49:
          if (v5) {
            char v25 = v17;
          }
          else {
            char v25 = 1;
          }
          if (v25) {
            return 0;
          }
        }
      }
      ++*(_DWORD *)(a1 + 12);
      if ((v17 & 1) == 0)
      {
        LODWORD(v5) = 10;
        goto LABEL_49;
      }
LABEL_45:
      uint64_t v5 = 1;
      goto LABEL_46;
    case '/':
      *(_DWORD *)(a1 + 8) = v8 + 2;
      LOBYTE(v10) = *(unsigned char *)(v6 + v8 + 2);
      uint64_t v18 = 2;
      break;
    case '?':
      do
      {
        while (1)
        {
          while (1)
          {
            uint64_t v11 = (int)v9;
            uint64_t v9 = (int)v9 + 1;
            *(_DWORD *)(a1 + 8) = v9;
            int v12 = *(unsigned __int8 *)(v6 + v9);
            if (v12 != 10) {
              break;
            }
            ++*(_DWORD *)(a1 + 12);
          }
          if (v12 == 63) {
            break;
          }
          if (!*(unsigned char *)(v6 + v9)) {
            return 0;
          }
        }
        LODWORD(v9) = v11 + 2;
        *(_DWORD *)(a1 + 8) = v11 + 2;
      }
      while (*(unsigned char *)(v6 + v11 + 2) != 62);
      int v13 = v11 + 3;
LABEL_12:
      uint64_t v5 = 4;
LABEL_13:
      *(_DWORD *)(a1 + 8) = v13;
      return v5;
    default:
      uint64_t v18 = 1;
      break;
  }
  if (((v10 & 0xDF) - 65) > 0x19u) {
    return 0;
  }
  uint64_t v19 = 0;
  while (((v10 & 0xDF) - 65) < 0x1Au
       || v10 == 45
       || (v10 - 48) <= 9u)
  {
    *(unsigned char *)(a2 + v19) = v10;
    uint64_t v20 = v19 + 1;
    uint64_t v21 = *(void *)a1;
    uint64_t v10 = *(int *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v10;
    LOBYTE(v10) = *(unsigned char *)(v21 + v10);
    uint64_t v19 = v20;
    if (v20 == 31) {
      return 0;
    }
  }
  *(unsigned char *)(a2 + v19) = 0;
  do
  {
    if (v10 == 47)
    {
      uint64_t v45 = *(void *)a1;
      uint64_t v46 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v46;
      if (*(unsigned char *)(v45 + v46) == 62)
      {
        uint64_t v18 = 3;
LABEL_87:
        int v13 = v46 + 1;
        uint64_t v5 = v18;
        goto LABEL_13;
      }
      return 0;
    }
    if (v10 == 62)
    {
      LODWORD(v46) = *(_DWORD *)(a1 + 8);
      goto LABEL_87;
    }
    while (1)
    {
      if (v10 != 9)
      {
        int v26 = (char)v10;
        if ((char)v10 != 32) {
          break;
        }
      }
      uint64_t v27 = *(void *)a1;
      uint64_t v10 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v10;
      LOBYTE(v10) = *(unsigned char *)(v27 + v10);
    }
    uint64_t v28 = 0;
    while (1)
    {
      if ((v26 & 0xFFFFFFDF) - 65 <= 0x19)
      {
        int v29 = *a3;
        goto LABEL_65;
      }
      int v29 = *a3;
      if (v26 != 45 && (v26 - 48) > 9) {
        break;
      }
LABEL_65:
      *(unsigned char *)(a4 + 32 * v29 + v28) = v26;
      if (v28 == 30) {
        return 0;
      }
      ++v28;
      uint64_t v30 = *(void *)a1;
      uint64_t v31 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v31;
      int v26 = *(char *)(v30 + v31);
    }
    *(unsigned char *)(a4 + 32 * v29 + v28) = 0;
    while (v26 == 9 || v26 == 32)
    {
      uint64_t v32 = *(void *)a1;
      uint64_t v33 = *(int *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v33;
      int v26 = *(char *)(v32 + v33);
    }
    if (v26 != 61) {
      return 0;
    }
    uint64_t v34 = *(void *)a1;
    uint64_t v35 = *(int *)(a1 + 8);
    int v36 = v35 + 2;
    uint64_t v37 = (unsigned __int8 *)(*(void *)a1 + v35 + 1);
    while (1)
    {
      *(_DWORD *)(a1 + 8) = v36 - 1;
      int v39 = *v37++;
      int v38 = v39;
      if (v39 != 9 && v38 != 32) {
        break;
      }
      ++v36;
    }
    if (v38 != 34) {
      return 0;
    }
    *(_DWORD *)(a1 + 8) = v36;
    int v40 = *(unsigned __int8 *)(v34 + v36);
    if (v40 != 34)
    {
      uint64_t v41 = 0;
      while (1)
      {
        *(unsigned char *)(a5 + 32 * *a3 + v41) = v40;
        if (v41 == 30) {
          return 0;
        }
        ++v41;
        uint64_t v42 = *(void *)a1;
        uint64_t v43 = *(int *)(a1 + 8) + 1;
        *(_DWORD *)(a1 + 8) = v43;
        int v40 = *(unsigned __int8 *)(v42 + v43);
        if (v40 == 34) {
          goto LABEL_82;
        }
      }
    }
    LODWORD(v41) = 0;
LABEL_82:
    uint64_t v5 = 0;
    *(unsigned char *)(a5 + 32 * *a3 + v41) = 0;
    uint64_t v10 = *(void *)a1;
    uint64_t v44 = *(int *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v44;
    LOBYTE(v10) = *(unsigned char *)(v10 + v44);
    LODWORD(v44) = (*a3)++;
  }
  while ((int)v44 <= 30);
  return v5;
}

double newObject(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 32) = *v2;
  }
  else
  {
    unsigned int v3 = malloc_type_malloc(0x50uLL, 0x10F00409B684ADEuLL);
    double result = 0.0;
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    _OWORD *v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 1) = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v3;
  }
  return result;
}

unsigned char *getString(uint64_t *a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = *((int *)a1 + 2);
  uint64_t v4 = *a1 + v3;
  while (1)
  {
    int v5 = *(unsigned __int8 *)(v4 + v2);
    if (v5 == 10)
    {
      ++*((_DWORD *)a1 + 3);
      goto LABEL_7;
    }
    if (!*(unsigned char *)(v4 + v2)) {
      return 0;
    }
    if (v5 == 60) {
      break;
    }
LABEL_7:
    *((_DWORD *)a1 + 2) = v3 + 1 + v2++;
  }
  double result = malloc_type_malloc((int)v2 + 1, 0xEA361A35uLL);
  if (!result)
  {
    puts("IOCFUnserialize: can't alloc temp memory");
    return 0;
  }
  if ((int)v2 < 1)
  {
    uint64_t v17 = 0;
LABEL_34:
    result[v17] = 0;
    return result;
  }
  uint64_t v7 = 0;
  LODWORD(v8) = 0;
  int v9 = v3 + 3;
  uint64_t v10 = result;
  while (2)
  {
    uint64_t v11 = *a1;
    uint64_t v12 = (int)v8;
    uint64_t v13 = (int)v8 + 1;
    int v14 = *(unsigned __int8 *)(*a1 + v3 + (int)v8);
    if (v14 != 38)
    {
      LODWORD(v8) = v8 + 1;
      goto LABEL_28;
    }
    uint64_t v8 = (int)v8 + 4;
    if ((int)v12 + 4 > (int)v2) {
      break;
    }
    uint64_t v15 = v12 + 2;
    int v16 = *(unsigned __int8 *)(v11 + v13 + v3);
    if (v16 != 103)
    {
      if (v16 == 108)
      {
        if (*(unsigned char *)(v11 + v15 + v3) != 116 || *(unsigned char *)(v11 + v9 + (int)v12) != 59) {
          break;
        }
        LOBYTE(v14) = 60;
      }
      else
      {
        if ((int)v12 + 5 > (int)v2
          || v16 != 97
          || *(unsigned char *)(v11 + v3 + (int)v15) != 109
          || *(unsigned char *)(v11 + v9 + (int)v12) != 112
          || *(unsigned char *)(v11 + v8 + v3) != 59)
        {
          break;
        }
        LOBYTE(v14) = 38;
        LODWORD(v8) = v12 + 5;
      }
      goto LABEL_28;
    }
    if (*(unsigned char *)(v11 + v3 + (int)v15) == 116 && *(unsigned char *)(v11 + v9 + (int)v12) == 59)
    {
      LOBYTE(v14) = 62;
LABEL_28:
      *v10++ = v14;
      v7 += 0x100000000;
      if ((int)v8 >= (int)v2)
      {
        uint64_t v17 = v7 >> 32;
        goto LABEL_34;
      }
      continue;
    }
    break;
  }
  free(result);
  return 0;
}

uint64_t buildString(uint64_t a1, uint64_t a2)
{
  CFStringRef v4 = CFStringCreateWithCString(*(CFAllocatorRef *)(a1 + 16), *(const char **)(a2 + 56), 0x8000100u);
  if (!v4)
  {
    syslog(3, "FIXME: IOUnserialize has detected a string that is not valid UTF-8, \"%s\".", *(const char **)(a2 + 56));
    CFStringRef v4 = CFStringCreateWithCString(*(CFAllocatorRef *)(a1 + 16), *(const char **)(a2 + 56), 0);
  }
  int v5 = (const void *)*(unsigned int *)(a2 + 72);
  if ((v5 & 0x80000000) == 0) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v5, v4);
  }
  free(*(void **)(a2 + 56));
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 24) = v4;
  return a2;
}

uint64_t getNumber(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v2 = *((_DWORD *)a1 + 2);
  int v3 = *(unsigned __int8 *)(*a1 + v2);
  if (v3 != 48)
  {
    LODWORD(v4) = *((_DWORD *)a1 + 2);
    goto LABEL_18;
  }
  uint64_t v4 = v2 + 1;
  *((_DWORD *)a1 + 2) = v4;
  int v3 = *(unsigned __int8 *)(v1 + v4);
  if (v3 != 120)
  {
LABEL_18:
    if (v3 == 45)
    {
      uint64_t v4 = (int)v4 + 1;
      *((_DWORD *)a1 + 2) = v4;
      char v16 = *(unsigned char *)(v1 + v4);
    }
    else
    {
      char v16 = v3;
    }
    unsigned int v17 = v16;
    if ((v16 - 48) > 9)
    {
      uint64_t v18 = 0;
    }
    else
    {
      uint64_t v18 = 0;
      uint64_t v19 = (char *)(v1 + (int)v4 + 1);
      int v20 = v4 + 1;
      do
      {
        uint64_t v18 = 10 * v18 + v17 - 48;
        *((_DWORD *)a1 + 2) = v20;
        unsigned int v21 = *v19++;
        unsigned int v17 = v21;
        ++v20;
      }
      while (v21 - 48 < 0xA);
    }
    if (v3 == 45) {
      return -v18;
    }
    else {
      return v18;
    }
  }
  uint64_t v5 = v2 + 2;
  *((_DWORD *)a1 + 2) = v2 + 2;
  unsigned int v6 = *(char *)(v1 + v5);
  BOOL v7 = v6 - 48 < 0xA;
  uint64_t v8 = 0;
  if (v6 - 48 < 0xA || v6 - 97 <= 5)
  {
    int v10 = v2 + 3;
    uint64_t v11 = (char *)(v5 + v1 + 1);
    do
    {
      if (v7) {
        uint64_t v12 = -48;
      }
      else {
        uint64_t v12 = -87;
      }
      uint64_t v8 = v12 + 16 * v8 + v6;
      *((_DWORD *)a1 + 2) = v10;
      unsigned int v13 = *v11++;
      unsigned int v6 = v13;
      unsigned int v14 = v13 - 97;
      BOOL v7 = v13 - 48 < 0xA;
      ++v10;
    }
    while (v13 - 48 < 0xA || v14 < 6);
  }
  return v8;
}

void *getCFEncodedData(uint64_t *a1, _DWORD *a2)
{
  double result = malloc_type_malloc(0x1000uLL, 0x1D99E107uLL);
  uint64_t v5 = *a1;
  int v6 = *(unsigned __int8 *)(*a1 + *((int *)a1 + 2));
  *a2 = 0;
  if (v6 == 60) {
    goto LABEL_22;
  }
  int v7 = 0;
  int v8 = 0;
  int v9 = 0;
  int v10 = 0;
  int v11 = 0;
  do
  {
    uint64_t v12 = v6 & 0x7F;
    switch(v12)
    {
      case 0xA:
        int v11 = 0;
        ++*((_DWORD *)a1 + 3);
        break;
      case 0x3D:
        ++v11;
        break;
      case 0:
        goto LABEL_22;
      default:
        int v11 = 0;
        break;
    }
    int v13 = __CFPLDataDecodeTable[v12];
    if ((v13 & 0x80000000) == 0)
    {
      ++v9;
      int v10 = v13 + (v10 << 6);
      if ((v9 & 3) == 0)
      {
        uint64_t v15 = v8 + 2;
        if (v7 <= (int)v15)
        {
          v7 += 4096;
          double result = malloc_type_realloc(result, v7, 0x4A6B3F2BuLL);
        }
        *((unsigned char *)result + v8) = BYTE2(v10);
        if (v11 > 1)
        {
          ++v8;
        }
        else
        {
          *((unsigned char *)result + v8 + 1) = BYTE1(v10);
          if (v11 == 1)
          {
            v8 += 2;
          }
          else
          {
            v8 += 3;
            *((unsigned char *)result + v15) = v10;
          }
        }
      }
      uint64_t v5 = *a1;
    }
    uint64_t v14 = *((int *)a1 + 2) + 1;
    *((_DWORD *)a1 + 2) = v14;
    int v6 = *(unsigned __int8 *)(v5 + v14);
  }
  while (v6 != 60);
  *a2 = v8;
  if (!v8)
  {
LABEL_22:
    free(result);
    return 0;
  }
  return result;
}

uint64_t __OSKextProcessKextRequestResults(uint64_t a1, uint64_t error_value, uint64_t a3, char *buffer, int a5)
{
  CFStringRef errorString = 0;
  if (error_value)
  {
    uint64_t v6 = error_value;
    int v7 = mach_error_string(error_value);
    int v13 = "(unknown)";
    if (v7) {
      LOBYTE(v13) = (_BYTE)v7;
    }
    OSKextLog(a1, 65, "Error communicating with kernel - %s.", v8, v9, v10, v11, v12, (char)v13);
    uint64_t v14 = 0;
    goto LABEL_16;
  }
  CFTypeRef v16 = 0;
  uint64_t v14 = 0;
  if (buffer && a5)
  {
    CFTypeRef v16 = IOCFUnserialize(buffer, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &errorString);
    if (!v16)
    {
      UTF8CStringForCFString = createUTF8CStringForCFString(errorString);
      uint64_t v14 = UTF8CStringForCFString;
      uint64_t v31 = "(unknown)";
      if (UTF8CStringForCFString) {
        LOBYTE(v31) = (_BYTE)UTF8CStringForCFString;
      }
      OSKextLog(a1, 65, "Failed to parse kernel log messages: %s.", v26, v27, v28, v29, v30, (char)v31);
      if (!a3) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
    __OSKextLogKernelMessages(a1, v16);
    uint64_t v14 = 0;
  }
  if (a3)
  {
LABEL_10:
    unsigned int v17 = mach_error_string(a3);
    char v23 = "(unknown)";
    if (v17) {
      LOBYTE(v23) = (_BYTE)v17;
    }
    OSKextLog(a1, 71, "Kernel error handling kext request - %s.", v18, v19, v20, v21, v22, (char)v23);
  }
LABEL_13:
  if (v16) {
    CFRelease(v16);
  }
  uint64_t v6 = a3;
LABEL_16:
  if (errorString) {
    CFRelease(errorString);
  }
  if (v14) {
    free(v14);
  }
  return v6;
}

void __OSKextLogKernelMessages(int a1, CFTypeRef cf)
{
  if (__sOSKextLogOutputFunction)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)cf) == 2)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, 0);
      uint64_t v6 = CFArrayGetValueAtIndex((CFArrayRef)cf, 1);
      CFTypeID v7 = CFGetTypeID(ValueAtIndex);
      if (v7 == CFArrayGetTypeID())
      {
        CFTypeID v8 = CFGetTypeID(v6);
        if (v8 == CFArrayGetTypeID())
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)ValueAtIndex);
          if (Count == CFArrayGetCount((CFArrayRef)v6))
          {
            CFIndex v10 = CFArrayGetCount((CFArrayRef)v6);
            if (v10 >= 1)
            {
              CFIndex v11 = v10;
              for (CFIndex i = 0; i != v11; ++i)
              {
                CFNumberRef v13 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, i);
                int valuePtr = 0;
                CFStringRef v14 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v6, i);
                if (CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr))
                {
                  UTF8CStringForCFString = (const char *)createUTF8CStringForCFString(v14);
                  if (UTF8CStringForCFString)
                  {
                    CFTypeRef v16 = (char *)UTF8CStringForCFString;
                    __sOSKextLogOutputFunction(a1, valuePtr, "(kernel) %s", UTF8CStringForCFString);
                    free(v16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

__CFDictionary *__OSKextCreateKextRequest(const void *a1, unint64_t a2, __CFDictionary **a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFNumberRef v13 = Mutable;
  if (Mutable)
  {
    CFDictionarySetValue(Mutable, @"Kext Request Predicate", a1);
    if (a2 | (unint64_t)a3)
    {
      CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v14)
      {
        uint64_t v20 = v14;
        CFDictionarySetValue(v13, @"Kext Request Arguments", v14);
        if (a3) {
          *a3 = v20;
        }
        if (a2) {
          CFDictionarySetValue(v20, @"CFBundleIdentifier", (const void *)a2);
        }
        CFRelease(v20);
      }
      else
      {
        OSKextLog(0, 17, "Memory allocation failure.", v15, v16, v17, v18, v19, v22);
        CFRelease(v13);
        return 0;
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v8, v9, v10, v11, v12, v22);
  }
  return v13;
}

io_registry_entry_t IORegistryGetRootEntry(mach_port_t mainPort)
{
  mach_port_t v2 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v2 = 0;
    }
    else {
      mach_port_t v2 = mainPorta;
    }
  }
  io_registry_get_root_entry(v2);
  if (v2 && v2 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v2);
  }
  return 0;
}

uint64_t io_registry_get_root_entry(unsigned int a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  *(void *)&v5.msgh_bits = 0x1800001513;
  *(void *)&v5.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v5.msgh_voucher_port = 0xB0B00000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if (v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      uint64_t v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

CFArrayRef IOPSCopyPowerSourcesList(CFTypeRef blob)
{
  CFTypeID TypeID = CFArrayGetTypeID();
  if (!blob || CFGetTypeID(blob) != TypeID) {
    return 0;
  }

  return CFArrayCreateCopy(0, (CFArrayRef)blob);
}

void _IOHIDArrayAppendSInt64(void *a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFNumberRef v4 = CFNumberCreate(v3, kCFNumberSInt64Type, &valuePtr);
  if (v4)
  {
    CFNumberRef v5 = v4;
    CFArrayAppendValue((CFMutableArrayRef)a1, v4);
    CFRelease(v5);
  }
}

uint64_t io_connect_set_notification_port(unsigned int a1, int a2, int a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v8 = 1;
  int v9 = a3;
  uint64_t v10 = 0x14000000000000;
  uint64_t v11 = *MEMORY[0x1E4F14068];
  int v12 = a2;
  uint64_t v13 = a4;
  *(void *)&v7.msgh_bits = 0x3C80001513;
  *(void *)&v7.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v7.msgh_voucher_port = 0xB3300000000;
  uint64_t v4 = mach_msg2_internal();
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v7.msgh_local_port);
  }
  else if (v4)
  {
    mig_dealloc_reply_port(v7.msgh_local_port);
  }
  else
  {
    uint64_t v5 = 4294966995;
    mach_msg_destroy(&v7);
  }
  return v5;
}

uint64_t IOHIDServiceClientRegisterRemovalCallback(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[4] = a2;
  a1[6] = a3;
  a1[7] = a4;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDServiceClientRegisterRemovalBlock(void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[5] = _Block_copy(a2);
  a1[6] = a3;
  a1[7] = a4;

  return os_unfair_recursive_lock_unlock();
}

CFTypeRef IOPSCopyPowerSourcesInfo(void)
{
  return IOPSCopyPowerSourcesByType(3);
}

void _IOHIDServiceTerminate(void *a1)
{
  CFRetain(a1);
  uint64_t v2 = a1[10];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___IOHIDServiceTerminate_block_invoke;
  block[3] = &__block_descriptor_tmp_14;
  block[4] = a1;
  dispatch_async(v2, block);
}

uint64_t __IOHIDEventSystemClientRegister()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v1 = (const CFSetCallBacks *)MEMORY[0x1E4F1D050];
  __propertyCache = (uint64_t)CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)propertyCacheList, 2, MEMORY[0x1E4F1D050]);
  __restrictedRemapKeys = (uint64_t)CFSetCreate(v0, (const void **)restrictedRemapKeyList, 3, v1);
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDEventSystemClientCFTypeID TypeID = result;
  return result;
}

CFStringRef __IOHIDServiceFilterCopyDebugDescription(void *a1)
{
  uint64_t v2 = (const void *)a1[12];
  if (v2) {
    CFStringRef v3 = CFCopyDescription(v2);
  }
  else {
    CFStringRef v3 = 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(a1);
  uint64_t v5 = &stru_1ED870660;
  if (v3) {
    uint64_t v5 = (__CFString *)v3;
  }
  CFStringRef v6 = CFStringCreateWithFormat(v4, 0, @"IOHIDServiceFilter uuid:%@ name:%@ %@", a1[11], a1[10], v5);
  if (v3) {
    CFRelease(v3);
  }
  return v6;
}

uint64_t IOHIDEventSystemClientCancel(uint64_t result)
{
  if (*(void *)(result + 400)) {
    BOOL v1 = *(void *)(result + 384) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    uint64_t result = _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = result;
  if ((atomic_fetch_or((atomic_uint *volatile)(result + 312), 2u) & 2) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    dispatch_mach_cancel();
    dispatch_mach_cancel();
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3) {
      IOMIGMachPortUnscheduleFromDispatchQueue(v3, *(void *)(v2 + 400));
    }
    mach_port_t v4 = *(_DWORD *)(v2 + 32);
    if (v4) {
      io_hideventsystem_queue_stop(v4);
    }
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

uint64_t _IOHIDEventSystemConnectionUnscheduleAsync(uint64_t *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = a1[14];
  if (v2) {
    dispatch_source_cancel(v2);
  }
  uint64_t v3 = a1[52];
  if (v3) {
    dispatch_source_cancel(v3);
  }
  mach_port_t v4 = a1[15];
  if (v4) {
    dispatch_source_cancel(v4);
  }
  IOMIGMachPortUnscheduleFromDispatchQueue(a1[4], a1[12]);
  uint64_t v5 = a1[55];
  if (v5) {
    IOHIDConnectionFilterCancel(v5);
  }

  return os_unfair_recursive_lock_unlock();
}

void IOMIGMachPortUnscheduleFromDispatchQueue(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3) {
      BOOL v4 = v3 == a2;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      *(void *)(a1 + 32) = 0;
      if (*(void *)(a1 + 40))
      {
        dispatch_mach_cancel();
        dispatch_release(*(dispatch_object_t *)(a1 + 40));
        *(void *)(a1 + 40) = 0;
      }
    }
  }
}

uint64_t io_hideventsystem_queue_stop(mach_port_t a1)
{
  msg.msgh_unsigned int size = 0;
  msg.msgh_bits = 19;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_name_t msgh_local_port = 0;
  *(void *)&msg.msgh_voucher_port = 0x1118100000000;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set(&msg);
  }
  uint64_t v1 = mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0);
  if ((v1 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    mach_msg_destroy(&msg);
  }
  return v1;
}

void _IOHIDEventSystemRemoveConnection(CFDictionaryRef *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int Type = IOHIDEventSystemConnectionGetType((uint64_t)a2);
  CFRetain(a2);
  uint64_t v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 138543362;
    uint64_t v15 = a2;
    _os_log_impl(&dword_18B46C000, v5, OS_LOG_TYPE_DEFAULT, "Connection removed: %{public}@", (uint8_t *)&v14, 0xCu);
  }
  _IOHIDEventSystemUnregisterEventFilter((uint64_t)a1, a2);
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v6, a1[2]);
  int v8 = &a1[3 * Type];
  CFDictionaryRef v9 = v8[38];
  uint64_t v10 = (void (*)(CFDictionaryRef, CFDictionaryRef, void *))v8[39];
  CFDictionaryRef v11 = v8[40];
  CFSetRemoveValue(a1[7], a2);
  CFSetRemoveValue(a1[8], a2);
  CFSetRemoveValue(a1[9], a2);
  CFSetRemoveValue(a1[6], a2);
  CFAllocatorRef v12 = CFGetAllocator(a1);
  CFSetRef v13 = CFSetCreateCopy(v12, a1[53]);
  os_unfair_recursive_lock_unlock();
  _IOHIDEventSystemRemoveServicesForConnection((uint64_t)a1, Copy, (uint64_t)a2);
  if (v13)
  {
    CFSetApplyFunction(v13, (CFSetApplierFunction)_IOHIDEventSystemConnectionRecordClientChanged, 0);
    CFRelease(v13);
  }
  if (Copy)
  {
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__RemoveServiceConnectionPropertyFunction, a2);
    CFRelease(Copy);
  }
  if (v10) {
    v10(v9, v11, a2);
  }
  CFRelease(a2);
}

void _IOHIDEventSystemUnregisterEventFilter(uint64_t a1, void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
  if (Count < 1)
  {
LABEL_8:
    CFDictionaryRef v9 = 0;
  }
  else
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    while (1)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v6);
      if (ValueAtIndex && ValueAtIndex == a2) {
        break;
      }
      if (v5 == ++v6) {
        goto LABEL_8;
      }
    }
    CFRetain(a2);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), v6);
    CFDictionaryRef v9 = a2;
  }
  os_unfair_recursive_lock_unlock();
  CFSetRef v10 = _IOHIDEventSystemConnectionCopyServices((CFSetRef *)a2);
  CFSetRef v11 = v10;
  if (v10) {
    CFSetApplyFunction(v10, (CFSetApplierFunction)__IOHIDEventSystemFilterEventServiceUnregister, a2);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v11)
  {
    CFRelease(v11);
  }
}

CFSetRef _IOHIDEventSystemConnectionCopyServices(CFSetRef *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFSetRef Copy = CFSetCreateCopy(v2, a1[10]);
  os_unfair_recursive_lock_unlock();
  return Copy;
}

uint64_t __FilterFunctionOpen(uint64_t a1)
{
  return IOHIDServiceFilterOpen(a1);
}

void __FilterFunctionOpen_0(const void *a1, uint64_t a2)
{
  if (IOHIDSessionFilterOpen((uint64_t)a1))
  {
    BOOL v4 = *(__CFArray ***)(a2 + 8);
    if (v4)
    {
      CFIndex v5 = *v4;
      if (*v4
        || (**(void **)(a2 + 8) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]),
            (CFIndex v5 = **(__CFArray ***)(a2 + 8)) != 0))
      {
        CFArrayAppendValue(v5, a1);
      }
    }
  }
}

uint64_t IOHIDEventSystemClientRegisterEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 200) = a2;
  *(void *)(a1 + 216) = a3;
  *(void *)(a1 + 224) = a4;
  os_unfair_recursive_lock_unlock();

  return __IOHIDEventSystemClientStartQueue(a1);
}

uint64_t __IOMasterPort_block_invoke(uint64_t a1)
{
  uint64_t result = io_server_version(**(_DWORD **)(a1 + 32));
  if (result)
  {
    gIOKitLibServerVersion = 0;
  }
  else if ((unint64_t)gIOKitLibServerVersion > 0x1335184)
  {
    return result;
  }
  gIOKitLibSerializeOptions &= ~1uLL;
  return result;
}

uint64_t io_server_version(unsigned int a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v9 = 0;
  uint64_t v8 = 0;
  *(void *)&v5.msgh_bits = 0x1800001513;
  *(void *)&v5.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v5.msgh_voucher_port = 0xB3D00000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if (v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      uint64_t v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

void __IOHIDEventSystemConnectionCheckServerStatus_cold_1()
{
  OUTLINED_FUNCTION_5_0(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1(&dword_18B46C000, v0, v1, "%s: Server died, preventing any future MIG calls", v2, v3, v4, v5, v6);
}

void OUTLINED_FUNCTION_5_0(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t OUTLINED_FUNCTION_1_0()
{
  return _os_log_send_and_compose_impl();
}

double OUTLINED_FUNCTION_1_1(void *a1, _OWORD *a2)
{
  *a1 = 0;
  double result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

void OUTLINED_FUNCTION_1_2(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

void OUTLINED_FUNCTION_1_3(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

id IOHIDServiceFilterSchedule(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 && (uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 72)) != 0)
  {
    return (id)v3();
  }
  else
  {
    id result = *(id *)(a1 + 96);
    if (result)
    {
      uint64_t v5 = *(const char **)(a1 + 168);
      if (v5)
      {
        objc_msgSend(result, v5, *(void *)(a1 + 48));
        id result = *(id *)(a1 + 96);
      }
      uint8_t v6 = *(const char **)(a1 + 160);
      if (v6)
      {
        objc_msgSend(result, v6, *(void *)(a1 + 32));
        id result = *(id *)(a1 + 96);
      }
      *(_DWORD *)(a1 + 72) |= 1u;
      uint64_t v7 = *(const char **)(a1 + 144);
      return [result v7];
    }
  }
  return result;
}

uint64_t IOHIDEventCreateVendorDefinedEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, const void *a6, size_t a7, int a8)
{
  uint64_t v13 = a2;
  uint64_t v14 = _IOHIDEventCreate(a1, a7 + 28, 1, a2, a8 | 1u);
  if (v14)
  {
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      uint64_t v13 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v13);
    }
    *(void *)(v14 + 8) = v13;
    uint64_t v15 = *(void *)(v14 + 104);
    *(_WORD *)(v15 + 16) = a3;
    *(_WORD *)(v15 + 18) = a4;
    *(_DWORD *)(v15 + 20) = a5;
    *(_DWORD *)(v15 + 24) = a7;
    memmove((void *)(v15 + 28), a6, a7);
  }
  return v14;
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  kern_return_t result;

  id result = io_registry_entry_get_registry_entry_id(entry);
  if (result) {
    *entryID = 0;
  }
  return result;
}

uint64_t io_registry_entry_get_registry_entry_id(unsigned int a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v9 = 0;
  uint64_t v8 = 0;
  *(void *)&v5.msgh_bits = 0x1800001513;
  *(void *)&v5.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v5.msgh_voucher_port = 0xB3700000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if (v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      uint64_t v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t IOHIDEventQueueIsActive(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *(unsigned int *)(a1 + 148);
  os_unfair_recursive_lock_unlock();
  return v2;
}

uint64_t __releaseAsyncAssertion_block_invoke(uint64_t a1)
{
  uint64_t result = _releaseAsycnAssertion(*(_DWORD *)(a1 + 40), 1, 1);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t _releaseAsycnAssertion(unsigned int a1, int a2, int a3)
{
  uint64_t v6 = (const void *)(HIWORD(a1) & 0x7FFF);
  xpc_object_t value = 0;
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)gAssertionsDict, v6, (const void **)&value))
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v8 = CFDateCreate(0, Current);
    if (v8)
    {
      CFDateRef v9 = v8;
      CFDictionarySetValue((CFMutableDictionaryRef)value, @"AssertReleaseWhen", v8);
      CFRelease(v9);
    }
    if (a3) {
      logAsyncAssertionActivity(1u, a1);
    }
    if (CFDictionaryContainsKey((CFDictionaryRef)gActiveAssertionsDict, v6))
    {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gActiveAssertionsDict, v6);
      if (CFArrayGetCount((CFArrayRef)gReleasedAssertionsList) <= 127) {
        CFArrayAppendValue((CFMutableArrayRef)gReleasedAssertionsList, value);
      }
    }
    else if (CFDictionaryContainsKey((CFDictionaryRef)gInactiveAssertionsDict, v6))
    {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gInactiveAssertionsDict, v6);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)gAssertionsDict, v6);
    if (a2) {
      removeFromTimedList(a1);
    }
    if ((int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) <= 0 && gCurrentAssertion)
    {
      sendAsyncReleaseMsg(gCurrentRemoteAssertion, 1, gCurrentRemoteAssertionIsCoalesced);
      gCurrentAssertion = 0;
      gCurrentRemoteAssertion = 0;
      gCurrentRemoteAssertionIsCoalesced = 0;
      uint64_t v10 = assertions_log;
      if (assertions_log)
      {
        uint64_t result = os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG);
        if (!result) {
          return result;
        }
        _releaseAsycnAssertion_cold_6(a1, v10);
      }
      else
      {
        uint64_t result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
        if (!result) {
          return result;
        }
        _releaseAsycnAssertion_cold_5(a1);
      }
    }
    else if (assertions_log)
    {
      uint64_t result = os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      _releaseAsycnAssertion_cold_4();
    }
    else
    {
      uint64_t result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      _releaseAsycnAssertion_cold_3();
    }
    return 0;
  }
  else
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        _releaseAsycnAssertion_cold_2();
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      _releaseAsycnAssertion_cold_1();
    }
    return 3758096385;
  }
}

void removeFromTimedList(int a1)
{
  if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) >= 1)
  {
    uint64_t v2 = 0;
    CFIndex v3 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, v3);
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"AsyncClientAssertionId");
      int valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr == a1) {
        break;
      }
      ++v3;
      v2 += 0x100000000;
      if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) <= v3) {
        return;
      }
    }
    if (v3 != -1)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
          removeFromTimedList_cold_2();
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
      {
        removeFromTimedList_cold_1();
      }
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)gTimedAssertionsList, v2 >> 32);
    }
  }
}

void sendAsyncReleaseMsg(unsigned int a1, int a2, BOOL a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  if (v6)
  {
    uint64_t v7 = v6;
    if (gAssertionConnection)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
          sendAsyncReleaseMsg_cold_8();
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
      {
        sendAsyncReleaseMsg_cold_7();
      }
      xpc_dictionary_set_uint64(v7, "assertionRelease", a1);
      xpc_dictionary_set_BOOL(v7, "assertionWasCoalesced", a3);
      CFDateRef v8 = 0;
      if (a2 && gAsyncAssertionActivityLog_2)
      {
        if (CFArrayGetCount((CFArrayRef)gAsyncAssertionActivityLog_1))
        {
          if (assertions_log)
          {
            if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
              sendAsyncReleaseMsg_cold_6();
            }
          }
          else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
          {
            sendAsyncReleaseMsg_cold_5();
          }
          CFDateRef v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
          xpc_dictionary_set_value(v7, "assertionActivityLog", v8);
        }
        else
        {
          CFDateRef v8 = 0;
        }
      }
      xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v7);
      if (a2)
      {
        CFArrayRemoveAllValues((CFMutableArrayRef)gReleasedAssertionsList);
        gAsyncAssertionActivityLog_2 = 0;
        gAsyncAssertionActivityLog_0 = 0;
        if (gAsyncAssertionActivityLog_1) {
          CFArrayRemoveAllValues((CFMutableArrayRef)gAsyncAssertionActivityLog_1);
        }
      }
      if (v8) {
        xpc_release(v8);
      }
    }
    else if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        sendAsyncReleaseMsg_cold_4();
      }
    }
    else
    {
      BOOL v17 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v17) {
        sendAsyncReleaseMsg_cold_3(v17, v18, v19, v20, v21, v22, v23, v24);
      }
    }
    xpc_release(v7);
  }
  else if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
      sendAsyncReleaseMsg_cold_2();
    }
  }
  else
  {
    BOOL v9 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v9) {
      sendAsyncReleaseMsg_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
    }
  }
}

void __createAsyncAssertion_block_invoke(uint64_t a1)
{
  uint64_t v27 = 0;
  initialSetup();
  if (gAsyncModeDisableOverride)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        createAsyncAssertion_cold_2();
      }
    }
    else
    {
      BOOL v4 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
      if (v4) {
        createAsyncAssertion_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    goto LABEL_21;
  }
  LODWORD(v2) = createAsyncAssertion_gNextAssertionIdx;
  while (1)
  {
    unint64_t v3 = v2;
    if (CFDictionaryContainsKey((CFDictionaryRef)gAssertionsDict, (const void *)v2) != 1) {
      break;
    }
    unint64_t v2 = ((_BYTE)v2 + 1) & 0x7F;
    if (v2 == createAsyncAssertion_gNextAssertionIdx)
    {
      unint64_t v3 = v2;
      break;
    }
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)gAssertionsDict, (const void *)v3) == 1)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        __createAsyncAssertion_block_invoke_cold_2();
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __createAsyncAssertion_block_invoke_cold_1();
    }
    return;
  }
  MutableCFSetRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFDictionaryRef *)(a1 + 40));
  if (!MutableCopy
    || (v13 = MutableCopy, Current = CFAbsoluteTimeGetCurrent(), (CFDateRef v15 = CFDateCreate(0, Current)) == 0))
  {
LABEL_21:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  CFDateRef v16 = v15;
  CFDictionarySetValue(v13, @"AssertStartWhen", v15);
  CFRelease(v16);
  CFDictionarySetValue((CFMutableDictionaryRef)gAssertionsDict, (const void *)v3, v13);
  createAsyncAssertion_gNextAssertionIdx = ((_BYTE)v2 + 1) & 0x7F;
  uint64_t v18 = *(unsigned int **)(a1 + 48);
  BOOL v17 = (unsigned int **)(a1 + 48);
  *uint64_t v18 = (v2 << 16) | 0x80000000;
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, v18);
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
    {
      __createAsyncAssertion_block_invoke_cold_8();
      if (!v19) {
        goto LABEL_28;
      }
LABEL_27:
      CFDictionarySetValue(v13, @"AsyncClientAssertionId", v19);
      CFRelease(v19);
      goto LABEL_28;
    }
LABEL_26:
    if (!v19) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG)) {
    goto LABEL_26;
  }
  __createAsyncAssertion_block_invoke_cold_7();
  if (v19) {
    goto LABEL_27;
  }
LABEL_28:
  int valuePtr = 255;
  CFNumberRef Value = CFDictionaryGetValue(v13, @"AssertLevel");
  CFTypeID TypeID = CFNumberGetTypeID();
  if (Value
    && CFGetTypeID(Value) == TypeID
    && (CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, &valuePtr), !valuePtr))
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        __createAsyncAssertion_block_invoke_cold_6();
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      __createAsyncAssertion_block_invoke_cold_5();
    }
    CFDictionarySetValue((CFMutableDictionaryRef)gInactiveAssertionsDict, (const void *)v3, v13);
    uint64_t MonotonicTime = getMonotonicTime();
    uint64_t v27 = (getpid() << 16) | (MonotonicTime << 32) | *((unsigned __int16 *)*v17 + 1);
    CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt64Type, &v27);
    if (v24)
    {
      CFNumberRef v25 = v24;
      CFDictionarySetValue(v13, @"GlobalUniqueID", v24);
      CFRelease(v25);
    }
  }
  else
  {
    activateAsyncAssertion(**v17, 0);
  }
  uint64_t v22 = assertions_log;
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
      __createAsyncAssertion_block_invoke_cold_4((int **)v17, (uint64_t)v13, v22);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    __createAsyncAssertion_block_invoke_cold_3((int **)v17, (uint64_t)v13);
  }
  CFRelease(v13);
}

void initialSetup()
{
  if (!gAsyncModeSetupDone)
  {
    if (setupLogging_onceToken != -1) {
      dispatch_once(&setupLogging_onceToken, &__block_literal_global_17);
    }
    uint64_t v45 = 0;
    uint64_t v46 = &v45;
    uint64_t v47 = 0x2000000000;
    uint64_t v48 = 0;
    PMQueue = getPMQueue();
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __initialSetup_block_invoke;
    handler[3] = &unk_1E548B0E8;
    handler[4] = &v45;
    if (notify_register_dispatch("com.apple.powerd.assertionoffloadtimer", &initialSetup_notify_token, PMQueue, handler))
    {
      uint64_t v1 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
          initialSetup_cold_8(v1, v2, v3, v4, v5, v6, v7, v8);
        }
      }
      else
      {
        BOOL v9 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        if (v9) {
          initialSetup_cold_7(v9, v10, v11, v12, v13, v14, v15, v16);
        }
      }
    }
    else
    {
      notify_get_state(initialSetup_notify_token, (uint64_t *)v46 + 3);
      handleAsyncAssertionDisableOverride(*((_DWORD *)v46 + 6));
    }
    BOOL v17 = getPMQueue();
    if (notify_register_dispatch("com.apple.system.powermanagement.assertionresync", &initialSetup_resync_token, v17, &__block_literal_global_27))
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
          initialSetup_cold_6();
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        initialSetup_cold_5();
      }
    }
    if (gAssertionsDict
      || (gAssertionsDict = (uint64_t)CFDictionaryCreateMutable(0, 128, 0, MEMORY[0x1E4F1D540])) != 0)
    {
      if (!gReleasedAssertionsList) {
        gReleasedAssertionsList = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      }
      if (!gTimedAssertionsList) {
        gTimedAssertionsList = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      }
      if (!gActiveAssertionsDict) {
        gActiveAssertionsDict = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 128, 0, MEMORY[0x1E4F1D540]);
      }
      if (!gInactiveAssertionsDict) {
        gInactiveAssertionsDict = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 128, 0, MEMORY[0x1E4F1D540]);
      }
      if (gAssertionConnection) {
        goto LABEL_28;
      }
      xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E4F14428], 0);
      gAssertionConnection = (uint64_t)mach_service;
      if (mach_service)
      {
        uint64_t v21 = mach_service;
        uint64_t v22 = getPMQueue();
        xpc_connection_set_target_queue(v21, v22);
        xpc_connection_set_event_handler((xpc_connection_t)gAssertionConnection, &__block_literal_global_31);
        xpc_connection_resume((xpc_connection_t)gAssertionConnection);
        xpc_object_t v23 = xpc_dictionary_create(0, 0, 0);
        if (v23)
        {
          CFNumberRef v24 = v23;
          xpc_dictionary_set_BOOL(v23, "assertionInitialConnection", 1);
          xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v24);
          uint64_t v25 = assertions_log;
          if (assertions_log)
          {
            if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v43 = 0;
              uint64_t v26 = v25;
LABEL_47:
              _os_log_impl(&dword_18B46C000, v26, OS_LOG_TYPE_DEFAULT, "Sending initial message to powerd for async assertions", v43, 2u);
            }
          }
          else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v43 = 0;
            uint64_t v26 = MEMORY[0x1E4F14500];
            goto LABEL_47;
          }
          xpc_release(v24);
LABEL_28:
          uint64_t v18 = gAssertionsOffloader;
          if (gAssertionsOffloader
            || (CFNumberRef v19 = getPMQueue(),
                uint64_t v18 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v19),
                (gAssertionsOffloader = (uint64_t)v18) != 0))
          {
            dispatch_source_set_event_handler(v18, &__block_literal_global_36);
            dispatch_source_set_cancel_handler((dispatch_source_t)gAssertionsOffloader, &__block_literal_global_39);
          }
          gAsyncModeSetupDone = 1;
LABEL_63:
          _Block_object_dispose(&v45, 8);
          return;
        }
      }
      else if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
          __checkFeatureEnabled_block_invoke_2_cold_2();
        }
      }
      else
      {
        BOOL v35 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        if (v35) {
          __checkFeatureEnabled_block_invoke_2_cold_1(v35, v36, v37, v38, v39, v40, v41, v42);
        }
      }
    }
    else if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        initialSetup_cold_2();
      }
    }
    else
    {
      BOOL v27 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v27) {
        initialSetup_cold_1(v27, v28, v29, v30, v31, v32, v33, v34);
      }
    }
    gAsyncModeSetupDone = 0;
    if (gAssertionsDict)
    {
      CFRelease((CFTypeRef)gAssertionsDict);
      gAssertionsDict = 0;
    }
    if (gReleasedAssertionsList)
    {
      CFRelease((CFTypeRef)gReleasedAssertionsList);
      gReleasedAssertionsList = 0;
    }
    if (gAssertionsOffloader)
    {
      dispatch_resume((dispatch_object_t)gAssertionsOffloader);
      dispatch_source_cancel((dispatch_source_t)gAssertionsOffloader);
    }
    if (gInactiveAssertionsDict)
    {
      CFRelease((CFTypeRef)gInactiveAssertionsDict);
      gInactiveAssertionsDict = 0;
    }
    if (gActiveAssertionsDict)
    {
      CFRelease((CFTypeRef)gActiveAssertionsDict);
      gActiveAssertionsDict = 0;
    }
    if (gAssertionConnection) {
      xpc_connection_cancel((xpc_connection_t)gAssertionConnection);
    }
    goto LABEL_63;
  }
}

void activateAsyncAssertion(unsigned int a1, unsigned int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  unint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v4 = (const void *)(HIWORD(a1) & 0x7FFF);
  CFNumberRef Value = (__CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)gAssertionsDict, v4);
  if (Value)
  {
    uint64_t v6 = Value;
    CFDictionarySetValue((CFMutableDictionaryRef)gActiveAssertionsDict, v4, Value);
    uint64_t MonotonicTime = getMonotonicTime();
    uint64_t valuePtr = HIWORD(a1) | (MonotonicTime << 32) | (getpid() << 16);
    CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
    if (v8)
    {
      CFNumberRef v9 = v8;
      CFDictionarySetValue(v6, @"GlobalUniqueID", v8);
      CFRelease(v9);
    }
    logAsyncAssertionActivity(a2, a1);
    if (gCurrentRemoteAssertion && !gCurrentRemoteAssertionIsCoalesced) {
      gCurrentRemoteAssertionIsCoalesced = (int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) >= 2;
    }
    uint64_t v10 = CFDictionaryGetValue(v6, @"TimeoutSeconds");
    CFTypeID TypeID = CFNumberGetTypeID();
    if (!v10) {
      goto LABEL_14;
    }
    if (CFGetTypeID(v10) != TypeID) {
      goto LABEL_14;
    }
    CFNumberGetValue((CFNumberRef)v10, kCFNumberSInt64Type, &v23);
    uint64_t v12 = v23;
    if (!v23) {
      goto LABEL_14;
    }
    unint64_t v22 = getMonotonicTime() + v12;
    CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt64Type, &v22);
    if (v13)
    {
      CFNumberRef v14 = v13;
      CFDictionarySetValue(v6, @"TimeoutTimeStamp", v13);
      CFRelease(v14);
    }
    insertIntoTimedList(v6);
    if (v23 == 1)
    {
      uint64_t v15 = 1;
    }
    else
    {
LABEL_14:
      uint64_t v23 = 1;
      uint64_t v16 = getMonotonicTime();
      uint64_t v15 = v23;
      unint64_t v22 = v23 + v16;
    }
    if (!gCurrentAssertion && (!nextOffload_ts || v22 && v22 < nextOffload_ts))
    {
      uint64_t v17 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134217984;
          uint64_t v25 = v15;
          uint64_t v18 = v17;
LABEL_29:
          _os_log_impl(&dword_18B46C000, v18, OS_LOG_TYPE_DEFAULT, "Setting gAssertionsOffloader timeout to %llu\n", buf, 0xCu);
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        uint64_t v25 = v15;
        uint64_t v18 = MEMORY[0x1E4F14500];
        goto LABEL_29;
      }
      CFNumberRef v19 = gAssertionsOffloader;
      dispatch_time_t v20 = dispatch_time(0, 1000000000 * v23);
      dispatch_source_set_timer(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0);
      if (!nextOffload_ts) {
        dispatch_resume((dispatch_object_t)gAssertionsOffloader);
      }
      nextOffload_ts = v23 + getMonotonicTime();
    }
  }
  else if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
      activateAsyncAssertion_cold_2();
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    activateAsyncAssertion_cold_1();
  }
}

uint64_t getMonotonicTime()
{
  if (!dword_1EB21913C) {
    mach_timebase_info((mach_timebase_info_t)&getMonotonicTime_timebaseInfo);
  }
  return mach_absolute_time()
       * getMonotonicTime_timebaseInfo
       / (1000000000
        * (unint64_t)dword_1EB21913C);
}

void logAsyncAssertionActivity(unsigned int a1, unsigned int a2)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)gAssertionsDict, (const void *)(HIWORD(a2) & 0x7FFF));
  if (!Value)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        logAsyncAssertionActivity_cold_2();
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      logAsyncAssertionActivity_cold_1();
    }
    return;
  }
  if (a1 > 5) {
    return;
  }
  CFDictionaryRef v4 = Value;
  uint64_t v5 = off_1E548B3A8[a1];
  if (!gAsyncAssertionActivityLog_1)
  {
    gAsyncAssertionActivityLog_1 = (uint64_t)CFArrayCreateMutable(0, 24, MEMORY[0x1E4F1D510]);
    if (!gAsyncAssertionActivityLog_1) {
      return;
    }
    gAsyncAssertionActivityLog_2 = 0;
    uint64_t v23 = assertions_log;
    if (assertions_log)
    {
      if (!os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_4;
      }
      __int16 v27 = 0;
      CFNumberRef v24 = (uint8_t *)&v27;
      uint64_t v25 = v23;
    }
    else
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_4;
      }
      __int16 v26 = 0;
      uint64_t v25 = MEMORY[0x1E4F14500];
      CFNumberRef v24 = (uint8_t *)&v26;
    }
    _os_log_impl(&dword_18B46C000, v25, OS_LOG_TYPE_DEFAULT, "Async sssertion bufffer initialized.", v24, 2u);
  }
LABEL_4:
  CFIndex Count = CFArrayGetCount((CFArrayRef)gAsyncAssertionActivityLog_1);
  CFIndex v7 = gAsyncAssertionActivityLog_0 % 0x18u;
  if (Count <= v7)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 16, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable) {
      return;
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = (void *)CFArrayGetValueAtIndex((CFArrayRef)gAsyncAssertionActivityLog_1, v7);
    CFRetain(Mutable);
    CFDictionaryRemoveAllValues((CFMutableDictionaryRef)Mutable);
    if (!Mutable) {
      return;
    }
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v10 = CFDateCreate(0, Current);
  if (v10)
  {
    CFDateRef v11 = v10;
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"ActivityTime", v10);
    CFRelease(v11);
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"Action", v5);
    uint64_t v12 = CFDictionaryGetValue(v4, @"AssertStartWhen");
    if (v12) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"AssertStartWhen", v12);
    }
    CFNumberRef v13 = CFDictionaryGetValue(v4, @"AssertType");
    if (v13) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"AssertType", v13);
    }
    CFNumberRef v14 = CFDictionaryGetValue(v4, @"AssertName");
    if (v14) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"AssertName", v14);
    }
    uint64_t v15 = CFDictionaryGetValue(v4, @"GlobalUniqueID");
    if (v15) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"GlobalUniqueID", v15);
    }
    uint64_t v16 = CFDictionaryGetValue(v4, @"AssertionOnBehalfOfPID");
    if (v16) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"AssertionOnBehalfOfPID", v16);
    }
    uint64_t v17 = CFDictionaryGetValue(v4, @"AssertionOnBehalfOfPIDReason");
    if (v17) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"AssertionOnBehalfOfPIDReason", v17);
    }
    uint64_t v18 = CFDictionaryGetValue(v4, @"AssertionOnBehalfOfBundleID");
    if (v18) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"AssertionOnBehalfOfBundleID", v18);
    }
    CFNumberRef v19 = CFDictionaryGetValue(v4, @"FrameworkBundleID");
    if (v19) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"FrameworkBundleID", v19);
    }
    dispatch_time_t v20 = CFDictionaryGetValue(v4, @"InstanceMetadata");
    if (v20) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"InstanceMetadata", v20);
    }
    uint64_t v21 = CFDictionaryGetValue(v4, @"Category");
    if (v21) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"Category", v21);
    }
    unint64_t v22 = CFDictionaryGetValue(v4, @"IsCoalesced");
    if (v22) {
      CFDictionarySetValue((CFMutableDictionaryRef)Mutable, @"IsCoalesced", v22);
    }
    CFArraySetValueAtIndex((CFMutableArrayRef)gAsyncAssertionActivityLog_1, gAsyncAssertionActivityLog_0 % 0x18u, Mutable);
    ++gAsyncAssertionActivityLog_0;
    if (gAsyncAssertionActivityLog_2 != -1) {
      ++gAsyncAssertionActivityLog_2;
    }
  }
  CFRelease(Mutable);
}

void insertIntoTimedList(void *value)
{
  CFArrayAppendValue((CFMutableArrayRef)gTimedAssertionsList, value);
  uint64_t v1 = (__CFArray *)gTimedAssertionsList;
  v24.CFIndex length = CFArrayGetCount((CFArrayRef)gTimedAssertionsList);
  v24.location = 0;
  CFArraySortValues(v1, v24, (CFComparatorFunction)compare_assertion, 0);
  if (gAssertionTimer)
  {
    if (!assertion_timer_suspended)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
          insertIntoTimedList_cold_4();
        }
      }
      else
      {
        BOOL v4 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
        if (v4) {
          insertIntoTimedList_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
        }
      }
      dispatch_suspend((dispatch_object_t)gAssertionTimer);
      assertion_timer_suspended = 1;
    }
  }
  else
  {
    PMQueue = getPMQueue();
    uint64_t v3 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, PMQueue);
    gAssertionTimer = (uint64_t)v3;
    if (v3)
    {
      dispatch_source_set_event_handler(v3, &__block_literal_global_111);
      dispatch_source_set_cancel_handler((dispatch_source_t)gAssertionTimer, &__block_literal_global_114);
    }
  }
  int MonotonicTime = getMonotonicTime();
  uint64_t valuePtr = 0;
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, 0);
  CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"TimeoutTimeStamp");
  CFNumberGetValue(v14, kCFNumberSInt64Type, &valuePtr);
  int v15 = valuePtr - MonotonicTime;
  if (v15 <= 0)
  {
    handleAssertionTimeout();
    return;
  }
  if (gAssertionTimer)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        insertIntoTimedList_cold_2();
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      insertIntoTimedList_cold_1();
    }
    uint64_t v16 = gAssertionTimer;
    dispatch_time_t v17 = dispatch_time(0, 1000000000 * v15);
    dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);
    if (assertion_timer_suspended)
    {
      uint64_t v18 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v22 = 0;
          CFNumberRef v19 = (uint8_t *)&v22;
          dispatch_time_t v20 = v18;
LABEL_25:
          _os_log_impl(&dword_18B46C000, v20, OS_LOG_TYPE_DEFAULT, "Resuming timer", v19, 2u);
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        __int16 v21 = 0;
        dispatch_time_t v20 = MEMORY[0x1E4F14500];
        CFNumberRef v19 = (uint8_t *)&v21;
        goto LABEL_25;
      }
      assertion_timer_suspended = 0;
      dispatch_resume((dispatch_object_t)gAssertionTimer);
    }
  }
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  CFIndex Count = CFDictionaryGetCount(*((CFDictionaryRef *)client + 12));
  if (Count)
  {
    CFIndex v4 = Count;
    size_t v5 = 8 * Count;
    MEMORY[0x1F4188790](Count, v3);
    if (v5 >= 0x200) {
      size_t v6 = 512;
    }
    else {
      size_t v6 = v5;
    }
    bzero((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v6);
    bzero((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
    CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)client + 12), 0, (const void **)((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0)));
    CFArrayRef v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0)), v4, MEMORY[0x1E4F1D510]);
  }
  else
  {
    CFArrayRef v7 = 0;
  }
  os_unfair_recursive_lock_unlock();
  return v7;
}

uint64_t IOPSRLSMachPortCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    if (*(void *)a4) {
      return (*(uint64_t (**)(void))a4)(*(void *)(a4 + 8));
    }
  }
  return result;
}

BOOL IOPSDrawingUnlimitedPower()
{
  int out_token = 0;
  uint64_t v1 = 0;
  if (notify_register_check("com.apple.system.powersources.percent", &out_token)) {
    return 1;
  }
  notify_get_state(out_token, &v1);
  notify_cancel(out_token);
  return (v1 & 0x90000) != 0x80000;
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  Boolean shouldFreeInfo = 0;
  CFRunLoopSourceRef result = (CFRunLoopSourceRef)*((void *)notify + 2);
  if (!result)
  {
    context.version = 1;
    context.info = notify;
    memset(&context.retain, 0, 24);
    CFRunLoopSourceRef result = CFMachPortCreateWithPort(0, *((_DWORD *)notify + 1), (CFMachPortCallBack)IODispatchCalloutFromCFMessage, &context, &shouldFreeInfo);
    *((void *)notify + 1) = result;
    if (result)
    {
      if (shouldFreeInfo)
      {
        CFStringRef v3 = CFCopyDescription(result);
        if (v3)
        {
          CFStringRef v4 = v3;
          size_t v5 = buffer;
          CFStringGetCString(v3, buffer, 255, 0x8000100u);
          CFRelease(v4);
        }
        else
        {
          size_t v5 = "No Description";
        }
        asl_log(0, 0, 3, "IOKit.framework:IONotificationPortGetRunLoopSource bad CFMachPort, %s\n", v5);
        CFRelease(*((CFTypeRef *)notify + 1));
        *((void *)notify + 1) = 0;
        return (CFRunLoopSourceRef)*((void *)notify + 2);
      }
      else
      {
        CFRunLoopSourceRef result = CFMachPortCreateRunLoopSource(0, result, 0);
        *((void *)notify + 2) = result;
      }
    }
  }
  return result;
}

void *__IOHIDEventSystemClientCreateWithType_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 16) != 3) {
    return 0;
  }
  CFMutableDictionaryRef v2 = __IOHIDEventSystemClientStateSerialize(*(void *)(a1 + 32));
  if (!v2) {
    return 0;
  }
  CFMutableDictionaryRef v3 = v2;
  CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (Data)
  {
    CFDataRef v5 = Data;
    unsigned int Length = CFDataGetLength(Data);
    CFArrayRef v7 = malloc_type_calloc(1uLL, Length + 200, 0xFE536EE8uLL);
    if (v7)
    {
      __strlcpy_chk();
      *(_DWORD *)CFArrayRef v7 = 1;
      *((_DWORD *)v7 + 1) = Length;
      v9.location = 0;
      v9.CFIndex length = Length;
      CFDataGetBytes(v5, v9, (UInt8 *)v7 + 200);
    }
    CFRelease(v3);
  }
  else
  {
    CFArrayRef v7 = 0;
    CFDataRef v5 = v3;
  }
  CFRelease(v5);
  return v7;
}

uint64_t IOPSGetPercentRemaining(int *a1, BOOL *a2, unsigned char *a3)
{
  uint64_t v6 = 3758097089;
  int out_token = 0;
  uint64_t v13 = 0;
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFStringRef Identifier = CFBundleGetIdentifier(MainBundle);
    if (Identifier)
    {
      if (!CFStringHasPrefix(Identifier, @"com.apple.")) {
        return v6;
      }
    }
  }
  if (!a1) {
    return 3758097090;
  }
  if (notify_register_check("com.apple.system.powersources.percent", &out_token))
  {
    uint64_t v6 = 3758097097;
    goto LABEL_10;
  }
  notify_get_state(out_token, &v13);
  notify_cancel(out_token);
  unsigned int v9 = v13;
  if ((v13 & 0x80000) == 0)
  {
    uint64_t v6 = 3758097112;
LABEL_10:
    *a1 = 100;
    if (a2) {
      *a2 = 0;
    }
    if (a3)
    {
      LOBYTE(v10) = 1;
LABEL_20:
      *a3 = v10;
      return v6;
    }
    return v6;
  }
  int v11 = v13;
  if (v13 >= 0x64uLL) {
    int v11 = 100;
  }
  *a1 = v11;
  if (a2) {
    *a2 = (v9 & 0x20000) != 0;
  }
  uint64_t v6 = 0;
  if (a3)
  {
    int v10 = (v9 >> 21) & 1;
    goto LABEL_20;
  }
  return v6;
}

uint64_t io_registry_entry_get_path(unsigned int a1, const char *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(v9, 0, 480);
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v8 = 0u;
  *((void *)&v8 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  }
  else {
    int v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  }
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(void *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&long long v8 = 0xB0A00000000;
  uint64_t v4 = mach_msg2_internal();
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if (v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    uint64_t v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

CFStringRef IOPSGetProvidingPowerSourceType(CFTypeRef snapshot)
{
  int v4 = 0;
  int v1 = IOPSGetSupportedPowerSources(&v4, 0, 0);
  CFStringRef result = @"AC Power";
  if (!v1)
  {
    CFStringRef v3 = @"Battery Power";
    if (v4 != 2) {
      CFStringRef v3 = @"AC Power";
    }
    if (v4 == 3) {
      return @"UPS Power";
    }
    else {
      return v3;
    }
  }
  return result;
}

uint64_t IOPSGetSupportedPowerSources(_DWORD *a1, BOOL *a2, BOOL *a3)
{
  int out_token = 0;
  uint64_t v7 = 0;
  if (notify_register_check("com.apple.system.powersources.timeremaining", &out_token)) {
    return 3758097084;
  }
  notify_get_state(out_token, &v7);
  notify_cancel(out_token);
  if (a2) {
    *a2 = (v7 & 0x400000) != 0;
  }
  if (a3) {
    *a3 = (v7 & 0x800000) != 0;
  }
  uint64_t result = 0;
  if (a1) {
    *a1 = HIBYTE(v7);
  }
  return result;
}

uint64_t io_connect_get_service(unsigned int a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  *(void *)&v5.msgh_bits = 0x1800001513;
  *(void *)&v5.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v5.msgh_voucher_port = 0xB0100000000;
  uint64_t v1 = mach_msg2_internal();
  uint64_t v2 = v1;
  if ((v1 - 268435458) > 0xE || ((1 << (v1 - 2)) & 0x4003) == 0)
  {
    if (v1)
    {
      mig_dealloc_reply_port(v5.msgh_local_port);
    }
    else
    {
      uint64_t v2 = 4294966995;
      mach_msg_destroy(&v5);
    }
  }
  else
  {
    mig_put_reply_port(v5.msgh_local_port);
  }
  return v2;
}

uint64_t IOHIDEventSystemClientRegisterDeviceMatchingCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 168) = a2;
  *(void *)(a1 + 184) = a3;
  *(void *)(a1 + 192) = a4;

  return os_unfair_recursive_lock_unlock();
}

uint64_t io_connect_map_memory_into_task(unsigned int a1, int a2, int a3, uint64_t *a4, uint64_t *a5, int a6)
{
  int v10 = 1;
  int v11 = a3;
  uint64_t v12 = 0x13000000000000;
  uint64_t v13 = *MEMORY[0x1E4F14068];
  int v14 = a2;
  uint64_t v15 = *a4;
  uint64_t v16 = *a5;
  int v17 = a6;
  *(void *)&v9.msgh_bits = 0x4880001513;
  *(void *)&v9.mach_port_t msgh_remote_port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&v9.msgh_voucher_port = 0xB2F00000000;
  uint64_t v6 = mach_msg2_internal();
  uint64_t v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v9.msgh_local_port);
  }
  else if (v6)
  {
    mig_dealloc_reply_port(v9.msgh_local_port);
  }
  else
  {
    uint64_t v7 = 4294966995;
    mach_msg_destroy(&v9);
  }
  return v7;
}

void offloadAssertions(char a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!gAsyncMode) {
    return;
  }
  uint64_t valuePtr = 0;
  int v39 = 0;
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
      offloadAssertions_cold_8();
    }
  }
  else
  {
    BOOL v2 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
    if (v2) {
      offloadAssertions_cold_7(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  if (!gCurrentAssertion
    && (int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) <= 0
    && gAsyncAssertionActivityLog_2 != 0)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        offloadAssertions_cold_6();
      }
    }
    else
    {
      BOOL v27 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
      if (v27) {
        offloadAssertions_cold_5(v27, v28, v29, v30, v31, v32, v33, v34);
      }
    }
    sendAsyncAssertionMsg(0, 0, &v39, 1);
    CFArrayRemoveAllValues((CFMutableArrayRef)gReleasedAssertionsList);
LABEL_60:
    if (a1) {
      return;
    }
    goto LABEL_61;
  }
  if (gCurrentRemoteAssertion)
  {
    if (assertions_log)
    {
      if (!os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_60;
      }
      offloadAssertions_cold_4();
      if (a1) {
        return;
      }
    }
    else
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_60;
      }
      offloadAssertions_cold_3();
      if (a1) {
        return;
      }
    }
LABEL_61:
    nextOffload_ts = 0;
    dispatch_suspend((dispatch_object_t)gAssertionsOffloader);
    return;
  }
  int v11 = 0;
  uint64_t v12 = MEMORY[0x1E4F14500];
  while (1)
  {
    xpc_object_t value = 0;
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)gActiveAssertionsDict, v11, (const void **)&value)) {
      goto LABEL_45;
    }
    uint64_t v13 = value;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (v13)
    {
      if (CFGetTypeID(v13) == TypeID) {
        break;
      }
    }
    uint64_t v18 = assertions_log;
    if (!assertions_log)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        offloadAssertions_cold_1(v45, (int)v11, v46);
      }
      goto LABEL_45;
    }
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v44[0]) = v11;
      CFNumberRef v19 = v18;
      dispatch_time_t v20 = "Not a dictinary for 0x%x";
      uint32_t v21 = 8;
LABEL_28:
      _os_log_error_impl(&dword_18B46C000, v19, OS_LOG_TYPE_ERROR, v20, buf, v21);
    }
LABEL_45:
    if (++v11 == (char *)128) {
      goto LABEL_60;
    }
  }
  int v39 = 0;
  CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)value, @"AsyncClientAssertionId");
  CFNumberGetValue(v15, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  uint64_t v16 = assertions_log;
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67109378;
      LODWORD(v44[0]) = HIDWORD(valuePtr);
      WORD2(v44[0]) = 2112;
      *(void *)((char *)v44 + 6) = value;
      int v17 = v16;
LABEL_48:
      _os_log_debug_impl(&dword_18B46C000, v17, OS_LOG_TYPE_DEBUG, "Sending assertion create msg for id 0x%x:%@\n", buf, 0x12u);
    }
  }
  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67109378;
    LODWORD(v44[0]) = HIDWORD(valuePtr);
    WORD2(v44[0]) = 2112;
    *(void *)((char *)v44 + 6) = value;
    int v17 = v12;
    goto LABEL_48;
  }
  LODWORD(valuePtr) = sendAsyncAssertionMsg(1, (uint64_t)value, &v39, 1);
  CFArrayRemoveAllValues((CFMutableArrayRef)gReleasedAssertionsList);
  int v22 = v39;
  if (v39 || !valuePtr)
  {
    uint64_t v25 = assertions_log;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109378;
        LODWORD(v44[0]) = v22;
        WORD2(v44[0]) = 2112;
        *(void *)((char *)v44 + 6) = value;
        __int16 v26 = v25;
        goto LABEL_50;
      }
    }
    else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109378;
      LODWORD(v44[0]) = v22;
      WORD2(v44[0]) = 2112;
      *(void *)((char *)v44 + 6) = value;
      __int16 v26 = v12;
LABEL_50:
      _os_log_error_impl(&dword_18B46C000, v26, OS_LOG_TYPE_ERROR, "powerd returned err 0x%x to create assertion %@. Dropping the assertion\n", buf, 0x12u);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)gActiveAssertionsDict, v11);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)gAssertionsDict, v11);
    goto LABEL_45;
  }
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  uint64_t v24 = assertions_log;
  if (!v23)
  {
    if (!assertions_log)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        offloadAssertions_cold_2(v41, (uint64_t *)&value, &v42);
      }
      goto LABEL_45;
    }
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      v44[0] = value;
      CFNumberRef v19 = v24;
      dispatch_time_t v20 = "Failed to create the remoteID to CF for id %@\n";
      uint32_t v21 = 12;
      goto LABEL_28;
    }
    goto LABEL_45;
  }
  CFNumberRef v35 = v23;
  if (assertions_log)
  {
    unint64_t v36 = 0x1E9133000;
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109376;
      LODWORD(v44[0]) = valuePtr;
      WORD2(v44[0]) = 1024;
      *(_DWORD *)((char *)v44 + 6) = HIDWORD(valuePtr);
      uint64_t v37 = v24;
      goto LABEL_68;
    }
  }
  else
  {
    unint64_t v36 = 0x1E9133000uLL;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109376;
      LODWORD(v44[0]) = valuePtr;
      WORD2(v44[0]) = 1024;
      *(_DWORD *)((char *)v44 + 6) = HIDWORD(valuePtr);
      uint64_t v37 = MEMORY[0x1E4F14500];
LABEL_68:
      _os_log_impl(&dword_18B46C000, v37, OS_LOG_TYPE_DEFAULT, "powerd returned assertion id 0x%x for async id 0x%x \n", buf, 0xEu);
    }
  }
  gCurrentAssertion = HIDWORD(valuePtr);
  *(_DWORD *)(v36 + 3952) = valuePtr;
  gCurrentRemoteAssertionIsCoalesced = (int)CFDictionaryGetCount((CFDictionaryRef)gActiveAssertionsDict) > 1;
  CFDictionarySetValue((CFMutableDictionaryRef)value, @"AsyncRemoteAssertionId", v35);
  CFRelease(v35);
  if ((a1 & 1) == 0) {
    goto LABEL_61;
  }
}

uint64_t sendAsyncAssertionMsg(int a1, uint64_t a2, _DWORD *a3, int a4)
{
  if (!gAssertionConnection) {
    initialSetup();
  }
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  if (!v8)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        sendAsyncReleaseMsg_cold_2();
      }
    }
    else
    {
      BOOL v12 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v12) {
        sendAsyncReleaseMsg_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
      }
    }
    return 0;
  }
  uint64_t v9 = v8;
  if (gAsyncAssertionActivityLog_2) {
    int v10 = a4;
  }
  else {
    int v10 = 0;
  }
  if (!a2 && (v10 & 1) == 0)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
        sendAsyncAssertionMsg_cold_12();
      }
    }
    else
    {
      BOOL v20 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v20) {
        sendAsyncAssertionMsg_cold_11(v20, v21, v22, v23, v24, v25, v26, v27);
      }
    }
    return 0;
  }
  if (a2)
  {
    int v11 = (void *)_CFXPCCreateXPCMessageWithCFObject();
    if (!v11)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
          sendAsyncAssertionMsg_cold_4();
        }
      }
      else
      {
        BOOL v32 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        if (v32) {
          sendAsyncAssertionMsg_cold_3(v32, v33, v34, v35, v36, v37, v38, v39);
        }
      }
      return 0;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (v10)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        sendAsyncReleaseMsg_cold_6();
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      sendAsyncReleaseMsg_cold_5();
    }
    uint64_t v29 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(v9, "assertionActivityLog", v29);
    if (a1) {
      goto LABEL_37;
    }
LABEL_31:
    if (a2) {
      xpc_dictionary_set_value(v9, "assertionProperties", v11);
    }
    xpc_connection_send_message((xpc_connection_t)gAssertionConnection, v9);
    xpc_object_t v30 = 0;
    goto LABEL_39;
  }
  uint64_t v29 = 0;
  if (!a1) {
    goto LABEL_31;
  }
LABEL_37:
  xpc_dictionary_set_value(v9, "assertionCreate", v11);
  xpc_object_t v30 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)gAssertionConnection, v9);
  if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590])
  {
    uint64_t uint64 = xpc_dictionary_get_uint64(v30, "assertionId");
    if (a3) {
      *a3 = xpc_dictionary_get_uint64(v30, "returnCode");
    }
    goto LABEL_40;
  }
  if (MEMORY[0x18C131C50](v30) == MEMORY[0x1E4F145A8])
  {
    if (v30 == (xpc_object_t)MEMORY[0x1E4F14520])
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
          sendAsyncAssertionMsg_cold_6();
        }
      }
      else
      {
        BOOL v40 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        if (v40) {
          sendAsyncAssertionMsg_cold_5(v40, v41, v42, v43, v44, v45, v46, v47);
        }
      }
      uint64_t uint64 = 0;
      xpc_object_t v30 = (xpc_object_t)MEMORY[0x1E4F14520];
      goto LABEL_40;
    }
    if (v30 == (xpc_object_t)MEMORY[0x1E4F14528])
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR)) {
          sendAsyncAssertionMsg_cold_8();
        }
      }
      else
      {
        BOOL v48 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        if (v48) {
          sendAsyncAssertionMsg_cold_7(v48, v49, v50, v51, v52, v53, v54, v55);
        }
      }
      uint64_t uint64 = 0;
      xpc_object_t v30 = (xpc_object_t)MEMORY[0x1E4F14528];
      goto LABEL_40;
    }
  }
LABEL_39:
  uint64_t uint64 = 0;
LABEL_40:
  if (v11) {
    xpc_release(v11);
  }
  if (v29) {
    xpc_release(v29);
  }
  if (v30) {
    xpc_release(v30);
  }
  if (v10)
  {
    gAsyncAssertionActivityLog_2 = 0;
    gAsyncAssertionActivityLog_0 = 0;
    if (gAsyncAssertionActivityLog_1) {
      CFArrayRemoveAllValues((CFMutableArrayRef)gAsyncAssertionActivityLog_1);
    }
  }
  xpc_release(v9);
  return uint64;
}

void IOHIDEventSystemClientRegisterResetCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)UInt8 bytes = a2;
  uint64_t v13 = a3;
  uint64_t v14 = a4;
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  if (a2)
  {
    os_unfair_recursive_lock_lock_with_options();
    if (*(void *)(a1 + 136)
      || (CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]), (*(void *)(a1 + 136) = Mutable) != 0))
    {
      if (__IOHIDEventSystemClientFindCallback(a1, a2, a3, a4) == -1)
      {
        CFDataRef v10 = CFDataCreate(0, bytes, 24);
        if (v10)
        {
          CFDataRef v11 = v10;
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 136), v10);
          os_unfair_recursive_lock_unlock();
          CFRelease(v11);
        }
        else
        {
          os_unfair_recursive_lock_unlock();
        }
      }
      else
      {
        os_unfair_recursive_lock_unlock();
      }
    }
  }
}

uint64_t __IOHIDEventSystemClientFindCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 160));
  CFIndex v8 = -1;
  if (a2)
  {
    CFArrayRef v9 = *(const __CFArray **)(a1 + 136);
    if (v9)
    {
      if (CFArrayGetCount(v9) >= 1)
      {
        CFIndex v8 = 0;
        while (1)
        {
          CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), v8);
          if (ValueAtIndex)
          {
            CFDataRef v11 = ValueAtIndex;
            CFTypeID TypeID = CFDataGetTypeID();
            if (TypeID == CFGetTypeID(v11))
            {
              BytePtr = CFDataGetBytePtr(v11);
              if (*(void *)BytePtr == a2 && *((void *)BytePtr + 1) == a3 && *((void *)BytePtr + 2) == a4) {
                break;
              }
            }
          }
          if (++v8 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 136))) {
            return -1;
          }
        }
      }
    }
  }
  return v8;
}

uint64_t _Xio_hideventsystem_set_properties(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    uint64_t v4 = *MEMORY[0x1E4F14068];
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    int v5 = -300;
    goto LABEL_9;
  }
  uint64_t result = _io_hideventsystem_set_properties(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  uint64_t v4 = *MEMORY[0x1E4F14068];
  if (!result)
  {
    *(void *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_10:
  *(void *)(a2 + 24) = v4;
  return result;
}

uint64_t _io_hideventsystem_set_properties(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  int v21 = -536870212;
  mach_vm_size_t v7 = a3;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFDictionaryRef v9 = (const __CFDictionary *)_IOHIDUnserializeAndVMDeallocWithTypeID(a2, v7, TypeID);
  if (v9)
  {
    CFDictionaryRef v10 = v9;
    CFDataRef v11 = IOMIGMachPortCacheCopy(a1);
    if (v11)
    {
      uint64_t v12 = (uint64_t)v11;
      CFTypeID v13 = CFGetTypeID(v11);
      if (v13 == IOHIDEventSystemConnectionGetTypeID())
      {
        uint64_t System = _IOHIDEventSystemConnectionGetSystem(v12);
        if (CFDictionaryGetCount(v10))
        {
          *((_DWORD *)v19 + 6) = 0;
          context[0] = MEMORY[0x1E4F143A8];
          context[1] = 0x40000000;
          void context[2] = ___io_hideventsystem_set_properties_block_invoke;
          void context[3] = &unk_1E548AFD8;
          context[4] = &v18;
          _OWORD context[5] = v12;
          context[6] = System;
          _IOHIDCFDictionaryApplyBlock(v10, context);
        }
        else
        {
          *((_DWORD *)v19 + 6) = -536870206;
        }
      }
      else
      {
        *((_DWORD *)v19 + 6) = -536870185;
      }
      CFRelease(v10);
      uint64_t v15 = (const void *)v12;
    }
    else
    {
      *((_DWORD *)v19 + 6) = -536870185;
      uint64_t v15 = v10;
    }
    CFRelease(v15);
  }
  else
  {
    *((_DWORD *)v19 + 6) = -536870206;
  }
  *a4 = *((_DWORD *)v19 + 6);
  _Block_object_dispose(&v18, 8);
  return 0;
}

Boolean IOHIDEventSystemClientSetProperty(IOHIDEventSystemClientRef client, CFStringRef key, CFTypeRef property)
{
  Boolean v3 = 0;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  values = (void *)property;
  keys = (void *)key;
  if (client && key && property)
  {
    if (CFSetContainsValue((CFSetRef)__propertyCache, key))
    {
      os_unfair_recursive_lock_lock_with_options();
      CFDictionarySetValue(*((CFMutableDictionaryRef *)client + 16), key, property);
      os_unfair_recursive_lock_unlock();
    }
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDictionaryRef v8 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v8)
    {
      CFDictionaryRef v9 = v8;
      CFDataRef v10 = (const __CFData *)_IOHIDCreateBinaryData(v7, v8);
      if (v10)
      {
        CFDataRef v11 = v10;
        if (CFSetContainsValue((CFSetRef)__restrictedRemapKeys, keys)
          && _IOHIDIsRestrictedRemappingProperty((const __CFString *)values)
          && IOHIDCheckAccess(kIOHIDRequestTypeListenEvent))
        {
          IOHIDRequestAccess(kIOHIDRequestTypeListenEvent);
        }
        int v22 = 0;
        os_unfair_recursive_lock_lock_with_options();
        mach_port_t v12 = *((_DWORD *)client + 8);
        BytePtr = CFDataGetBytePtr(v11);
        int Length = CFDataGetLength(v11);
        uint64_t v15 = io_hideventsystem_set_properties(v12, (uint64_t)BytePtr, Length, &v22);
        int v16 = v15;
        if (v15 == 268435459)
        {
          if (*((void *)client + 48))
          {
            int v16 = 268435459;
          }
          else
          {
            int v16 = 268435459;
            if (!*((void *)client + 50))
            {
              __IOHIDEventSystemClientTerminationCallback(v15, client, 0);
              mach_port_t v17 = *((_DWORD *)client + 8);
              uint64_t v18 = CFDataGetBytePtr(v11);
              int v19 = CFDataGetLength(v11);
              int v16 = io_hideventsystem_set_properties(v17, (uint64_t)v18, v19, &v22);
            }
          }
        }
        os_unfair_recursive_lock_unlock();
        if (v16 | v22)
        {
          uint64_t v20 = _IOHIDLogCategory(0xDu);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 67109376;
            int v26 = v16;
            __int16 v27 = 1024;
            int v28 = v22;
            _os_log_impl(&dword_18B46C000, v20, OS_LOG_TYPE_INFO, "io_hideventsystem_set_properties:0x%08x result:%d", buf, 0xEu);
          }
          Boolean v3 = 0;
        }
        else
        {
          Boolean v3 = 1;
        }
        CFRelease(v11);
      }
      else
      {
        Boolean v3 = 0;
      }
      CFRelease(v9);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t io_hideventsystem_set_properties(mach_port_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v12 = 1;
  uint64_t v13 = a2;
  int v14 = 16777472;
  int v15 = a3;
  uint64_t v16 = *MEMORY[0x1E4F14068];
  int v17 = a3;
  mach_port_t special_reply_port = mig_get_special_reply_port();
  *(void *)&v11.msgh_bits = 2147489043;
  v11.mach_port_t msgh_remote_port = a1;
  v11.mach_port_name_t msgh_local_port = special_reply_port;
  *(void *)&v11.msgh_voucher_port = 0x1117D00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v11);
    mach_port_t special_reply_port = v11.msgh_local_port;
  }
  uint64_t v7 = mach_msg(&v11, 3162115, 0x38u, 0x30u, special_reply_port, 0, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!v7)
    {
      if (v11.msgh_id == 71)
      {
        uint64_t v8 = 4294966988;
      }
      else if (v11.msgh_id == 70113)
      {
        if ((v11.msgh_bits & 0x80000000) == 0)
        {
          if (v11.msgh_size == 40)
          {
            if (!v11.msgh_remote_port)
            {
              uint64_t v8 = HIDWORD(v13);
              if (!HIDWORD(v13))
              {
                *a4 = v14;
                return v8;
              }
              goto LABEL_25;
            }
          }
          else if (v11.msgh_size == 36)
          {
            if (v11.msgh_remote_port) {
              BOOL v9 = 1;
            }
            else {
              BOOL v9 = HIDWORD(v13) == 0;
            }
            if (v9) {
              uint64_t v8 = 4294966996;
            }
            else {
              uint64_t v8 = HIDWORD(v13);
            }
            goto LABEL_25;
          }
        }
        uint64_t v8 = 4294966996;
      }
      else
      {
        uint64_t v8 = 4294966995;
      }
LABEL_25:
      mach_msg_destroy(&v11);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  if ((v8 - 268435459) <= 1)
  {
    if ((v11.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v11.msgh_local_port);
    }
    goto LABEL_25;
  }
  return v8;
}

uint64_t io_registry_entry_get_child_iterator(unsigned int a1, const char *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v8 = 0u;
  *((void *)&v8 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  }
  else {
    int v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  }
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port[0] = 5395;
  reply_port[1] = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(void *)&reply_port[2] = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&long long v8 = 0xAFD00000000;
  uint64_t v4 = mach_msg2_internal();
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
  }
  else if (v4)
  {
    mig_dealloc_reply_port(reply_port[3]);
  }
  else
  {
    uint64_t v5 = 4294966995;
    mach_msg_destroy((mach_msg_header_t *)reply_port);
  }
  return v5;
}

uint64_t io_registry_entry_get_property_bytes(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  unsigned int v8 = v2;
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)__n = 0u;
  long long v25 = 0u;
  *(_OWORD *)mach_msg_header_t reply_port = 0u;
  long long v23 = 0u;
  *((void *)&v23 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v9 = mig_strncpy_zerofill((char *)&__n[1], v3, 128);
  }
  else {
    int v9 = mig_strncpy((char *)&__n[1], v3, 128);
  }
  LODWORD(__n[0]) = 0;
  HIDWORD(__n[0]) = v9;
  uint64_t v10 = (v9 + 3) & 0xFFFFFFFC;
  mach_port_t v11 = v10 + 44;
  int v12 = (char *)reply_port + v10;
  int v13 = *v5;
  if (*v5 >= 0x1000) {
    int v13 = 4096;
  }
  *((_DWORD *)v12 + 10) = v13;
  mach_port_t v14 = mig_get_reply_port();
  reply_port[0] = 5395;
  reply_port[1] = v11;
  *(void *)&reply_port[2] = __PAIR64__(v14, v8);
  *(void *)&long long v23 = 0xAFC00000000;
  uint64_t v15 = mach_msg2_internal();
  uint64_t v16 = v15;
  if ((v15 - 268435458) <= 0xE && ((1 << (v15 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port[3]);
    return v16;
  }
  if (v15)
  {
    mig_dealloc_reply_port(reply_port[3]);
    return v16;
  }
  if (DWORD1(v23) == 71)
  {
    uint64_t v16 = 4294966988;
LABEL_28:
    mach_msg_destroy((mach_msg_header_t *)reply_port);
    return v16;
  }
  if (DWORD1(v23) != 2912)
  {
    uint64_t v16 = 4294966995;
    goto LABEL_28;
  }
  if ((reply_port[0] & 0x80000000) != 0) {
    goto LABEL_27;
  }
  if (reply_port[1] - 4137 <= 0xFFFFEFFE)
  {
    if (reply_port[2]) {
      BOOL v17 = 1;
    }
    else {
      BOOL v17 = LODWORD(__n[0]) == 0;
    }
    if (!v17 && reply_port[1] == 36) {
      uint64_t v16 = LODWORD(__n[0]);
    }
    else {
      uint64_t v16 = 4294966996;
    }
    goto LABEL_28;
  }
  if (reply_port[2])
  {
LABEL_27:
    uint64_t v16 = 4294966996;
    goto LABEL_28;
  }
  uint64_t v16 = LODWORD(__n[0]);
  if (LODWORD(__n[0])) {
    goto LABEL_28;
  }
  int v20 = HIDWORD(__n[0]);
  uint64_t v16 = 4294966996;
  if (HIDWORD(__n[0]) > 0x1000
    || reply_port[1] - 40 < HIDWORD(__n[0])
    || reply_port[1] != ((HIDWORD(__n[0]) + 3) & 0xFFFFFFFC) + 40)
  {
    goto LABEL_28;
  }
  size_t v21 = *v5;
  if (HIDWORD(__n[0]) <= v21)
  {
    memcpy(v7, &__n[1], HIDWORD(__n[0]));
    uint64_t v16 = 0;
    *uint64_t v5 = v20;
  }
  else
  {
    memcpy(v7, &__n[1], v21);
    *uint64_t v5 = v20;
    return 4294966989;
  }
  return v16;
}

void handleAssertionTimeout()
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t MonotonicTime = getMonotonicTime();
  if (assertions_log)
  {
    if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
      handleAssertionTimeout_cold_9();
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    handleAssertionTimeout_cold_8();
  }
  uint64_t valuePtr = 0;
  if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) >= 1)
  {
    CFIndex v1 = 0;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, v1);
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"TimeoutTimeStamp");
      CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
      CFNumberRef v4 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"AsyncClientAssertionId");
      unsigned int v38 = 0;
      CFNumberGetValue(v4, kCFNumberSInt32Type, &v38);
      if (valuePtr > MonotonicTime)
      {
LABEL_42:
        while (v1)
        {
          CFArrayRemoveValueAtIndex((CFMutableArrayRef)gTimedAssertionsList, 0);
          LODWORD(v1) = v1 - 1;
        }
        goto LABEL_44;
      }
      if (!CFDictionaryContainsKey(ValueAtIndex, @"AsyncRemoteAssertionId")) {
        break;
      }
      CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"AsyncRemoteAssertionId");
      unsigned int v37 = 0;
      CFNumberGetValue(v5, kCFNumberIntType, &v37);
      unsigned int v6 = v37;
      if (v37 != gCurrentRemoteAssertion) {
        break;
      }
      uint64_t v7 = assertions_log;
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          unsigned int v43 = v6;
          unsigned int v8 = v7;
LABEL_33:
          _os_log_impl(&dword_18B46C000, v8, OS_LOG_TYPE_DEFAULT, "Powerd knows about this assertion 0x%0x. let powerd time it out", buf, 8u);
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        unsigned int v43 = v6;
        unsigned int v8 = MEMORY[0x1E4F14500];
        goto LABEL_33;
      }
LABEL_36:
      if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList) <= ++v1) {
        goto LABEL_42;
      }
    }
    uint64_t v9 = assertions_log;
    if (assertions_log)
    {
      if (!os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 67109376;
      unsigned int v43 = v38;
      __int16 v44 = 2048;
      CFDictionaryRef v45 = (const __CFDictionary *)valuePtr;
      uint64_t v10 = v9;
    }
    else
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 67109376;
      unsigned int v43 = v38;
      __int16 v44 = 2048;
      CFDictionaryRef v45 = (const __CFDictionary *)valuePtr;
      uint64_t v10 = MEMORY[0x1E4F14500];
    }
    _os_log_debug_impl(&dword_18B46C000, v10, OS_LOG_TYPE_DEBUG, "Timeout: assertion id 0x%x with time %llu", buf, 0x12u);
LABEL_18:
    logAsyncAssertionActivity(2u, v38);
    if (CFDictionaryContainsValue(ValueAtIndex, @"TimeoutAction")) {
      CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"TimeoutAction");
    }
    else {
      CFStringRef v11 = @"TimeoutActionTurnOff";
    }
    if (CFEqual(v11, @"TimeoutActionRelease"))
    {
      if (_releaseAsycnAssertion(v38, 0, 0))
      {
        mach_port_t v14 = assertions_log;
        if (assertions_log)
        {
          if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            unsigned int v43 = v38;
            _os_log_error_impl(&dword_18B46C000, v14, OS_LOG_TYPE_ERROR, "Failed to release assertion 0x%x on timeout", buf, 8u);
          }
        }
        else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          handleAssertionTimeout_cold_7(v40, (int *)&v38, v41);
        }
      }
      goto LABEL_36;
    }
    uint64_t v12 = assertions_log;
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 67109378;
        unsigned int v43 = v38;
        __int16 v44 = 2112;
        CFDictionaryRef v45 = ValueAtIndex;
        int v13 = v12;
LABEL_41:
        _os_log_debug_impl(&dword_18B46C000, v13, OS_LOG_TYPE_DEBUG, "Turning off assertion 0x%x: %@", buf, 0x12u);
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67109378;
      unsigned int v43 = v38;
      __int16 v44 = 2112;
      CFDictionaryRef v45 = ValueAtIndex;
      int v13 = MEMORY[0x1E4F14500];
      goto LABEL_41;
    }
    *(_DWORD *)long long buf = 0;
    CFNumberRef v15 = CFNumberCreate(allocator, kCFNumberSInt32Type, buf);
    handleAssertionLevel(v15, v38, 1);
    CFRelease(v15);
    goto LABEL_36;
  }
LABEL_44:
  if (!assertion_timer_suspended)
  {
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        insertIntoTimedList_cold_4();
      }
    }
    else
    {
      BOOL v16 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
      if (v16) {
        insertIntoTimedList_cold_3(v16, v17, v18, v19, v20, v21, v22, v23);
      }
    }
    dispatch_suspend((dispatch_object_t)gAssertionTimer);
    assertion_timer_suspended = 1;
  }
  if (CFArrayGetCount((CFArrayRef)gTimedAssertionsList))
  {
    CFDictionaryRef v24 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)gTimedAssertionsList, 0);
    CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(v24, @"TimeoutTimeStamp");
    CFNumberGetValue(v25, kCFNumberSInt64Type, &valuePtr);
    long long v26 = gAssertionTimer;
    dispatch_time_t v27 = dispatch_time(0, 1000000000 * (valuePtr - MonotonicTime));
    dispatch_source_set_timer(v26, v27, 0xFFFFFFFFFFFFFFFFLL, 0);
    if (assertion_timer_suspended)
    {
      if (assertions_log)
      {
        if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
          handleAssertionTimeout_cold_4();
        }
      }
      else
      {
        BOOL v28 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
        if (v28) {
          handleAssertionTimeout_cold_3(v28, v29, v30, v31, v32, v33, v34, v35);
        }
      }
      dispatch_resume((dispatch_object_t)gAssertionTimer);
      assertion_timer_suspended = 0;
    }
    if (assertions_log)
    {
      if (os_log_type_enabled((os_log_t)assertions_log, OS_LOG_TYPE_DEBUG)) {
        handleAssertionTimeout_cold_2();
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      handleAssertionTimeout_cold_1();
    }
  }
}

__CFString *_IOHIDEventDebugInfo(void *a1)
{
  int v2 = *(_DWORD *)(a1[13] + 4);
  switch(v2)
  {
    case 3:
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(a1, 3, 4026531840);
      if (EventWithOptions) {
        uint64_t v8 = *(unsigned int *)(*(void *)(EventWithOptions + 104) + 20);
      }
      else {
        uint64_t v8 = 0;
      }
      return (__CFString *)CFStringCreateWithFormat(v6, 0, @"keyboardPress: %d", v8);
    case 2:
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v10 = IOHIDEventGetEventWithOptions(a1, 2, 4026531840);
      if (v10) {
        uint64_t v11 = *(unsigned int *)(*(void *)(v10 + 104) + 28);
      }
      else {
        uint64_t v11 = 0;
      }
      return (__CFString *)CFStringCreateWithFormat(v9, 0, @"buttonState: %d", v11);
    case 1:
      int v3 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
      uint64_t v4 = IOHIDEventGetEventWithOptions(a1, 1, 4026531840);
      if (v4) {
        uint64_t v5 = *(unsigned __int16 *)(*(void *)(v4 + 104) + 16);
      }
      else {
        uint64_t v5 = 0;
      }
      CFAllocatorRef v13 = *v3;
      uint64_t v14 = IOHIDEventGetEventWithOptions(a1, 1, 4026531840);
      if (v14) {
        uint64_t v15 = *(unsigned __int16 *)(*(void *)(v14 + 104) + 18);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v16 = IOHIDEventGetEventWithOptions(a1, 1, 4026531840);
      if (v16) {
        uint64_t v17 = *(unsigned int *)(*(void *)(v16 + 104) + 24);
      }
      else {
        uint64_t v17 = 0;
      }
      return (__CFString *)CFStringCreateWithFormat(v13, 0, @"vendorUsagePage: %d vendorUsage:%d dataLength:%d", v5, v15, v17);
    default:
      return &stru_1ED870660;
  }
}

BOOL __IOHIDEventHasLegacyEventData(int a1)
{
  return a1 == 11 || a1 == 17 || a1 == 4;
}

uint64_t __IOHIDEventDataAppendFromLegacyEvent()
{
  return 0;
}

void IOHIDPreferencesSet(const __CFString *a1, const void *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  uint64_t v10 = (void (*)(const __CFString *, const void *, const __CFString *, const __CFString *, const __CFString *))__setPtr;
  if (__setPtr)
  {
    v10(a1, a2, a3, a4, a5);
  }
  else
  {
    uint64_t v11 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      int v12 = 136315138;
      CFAllocatorRef v13 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v11, OS_LOG_TYPE_INFO, "Failed to find %s for set, switch to default CFPreferences", (uint8_t *)&v12, 0xCu);
    }
    CFPreferencesSetValue(a1, a2, a5, a3, a4);
  }
}

void IOHIDPreferencesSetMultiple(const __CFDictionary *a1, const __CFArray *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  uint64_t v10 = (void (*)(const __CFDictionary *, const __CFArray *, const __CFString *, const __CFString *, const __CFString *))__setMultiplePtr;
  if (__setMultiplePtr)
  {
    v10(a1, a2, a3, a4, a5);
  }
  else
  {
    uint64_t v11 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      int v12 = 136315138;
      CFAllocatorRef v13 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v11, OS_LOG_TYPE_INFO, "Failed to find %s for set multiple , switch to default CFPreferences", (uint8_t *)&v12, 0xCu);
    }
    CFPreferencesSetMultiple(a1, a2, a5, a3, a4);
  }
}

CFPropertyListRef IOHIDPreferencesCopy(const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  uint64_t v8 = (uint64_t (*)(const __CFString *, const __CFString *, const __CFString *, const __CFString *))__copyPtr;
  if (__copyPtr)
  {
    return (CFPropertyListRef)v8(a1, a2, a3, a4);
  }
  else
  {
    uint64_t v10 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = 136315138;
      int v12 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v10, OS_LOG_TYPE_INFO, "Failed to find %s for copy, switch to default CFPreferences", (uint8_t *)&v11, 0xCu);
    }
    return CFPreferencesCopyValue(a1, a4, a2, a3);
  }
}

CFDictionaryRef IOHIDPreferencesCopyMultiple(const __CFArray *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  uint64_t v8 = (uint64_t (*)(const __CFArray *, const __CFString *, const __CFString *, const __CFString *))__copyMultiplePtr;
  if (__copyMultiplePtr)
  {
    return (CFDictionaryRef)v8(a1, a2, a3, a4);
  }
  else
  {
    uint64_t v10 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = 136315138;
      int v12 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v10, OS_LOG_TYPE_INFO, "Failed to find %s for copy multiple, switch to default CFPreferences", (uint8_t *)&v11, 0xCu);
    }
    return CFPreferencesCopyMultiple(a1, a4, a2, a3);
  }
}

uint64_t IOHIDPreferencesSynchronize(const __CFString *a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  CFAllocatorRef v6 = (uint64_t (*)(const __CFString *, const __CFString *, const __CFString *))__synchronizePtr;
  if (__synchronizePtr)
  {
    return v6(a1, a2, a3);
  }
  else
  {
    uint64_t v8 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      int v9 = 136315138;
      uint64_t v10 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v8, OS_LOG_TYPE_INFO, "Failed to find %s for synchronize, switch to default CFPreferences", (uint8_t *)&v9, 0xCu);
    }
    return CFPreferencesSynchronize(a3, a1, a2);
  }
}

CFPropertyListRef IOHIDPreferencesCopyDomain(const __CFString *a1, const __CFString *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  uint64_t v4 = (uint64_t (*)(const __CFString *, const __CFString *))__copyDomainPtr;
  if (__copyDomainPtr)
  {
    return (CFPropertyListRef)v4(a1, a2);
  }
  else
  {
    CFAllocatorRef v6 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v7 = 136315138;
      uint64_t v8 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v6, OS_LOG_TYPE_INFO, "Failed to find %s for copy domain, switch to default CFPreferences", (uint8_t *)&v7, 0xCu);
    }
    return CFPreferencesCopyAppValue(a1, a2);
  }
}

void IOHIDPreferencesSetDomain(const __CFString *a1, const void *a2, const __CFString *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  CFAllocatorRef v6 = (void (*)(const __CFString *, const void *, const __CFString *))__setDomainPtr;
  if (__setDomainPtr)
  {
    v6(a1, a2, a3);
  }
  else
  {
    int v7 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      int v8 = 136315138;
      uint64_t v9 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v7, OS_LOG_TYPE_INFO, "Failed to find %s for set domain, switch to default CFPreferences", (uint8_t *)&v8, 0xCu);
    }
    CFPreferencesSetAppValue(a1, a2, a3);
  }
}

uint64_t IOHIDPreferencesCreateInstance(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  int v2 = (uint64_t (*)(uint64_t))__createPtr;
  if (__createPtr)
  {
    return v2(a1);
  }
  else
  {
    uint64_t v4 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      int v5 = 136315138;
      CFAllocatorRef v6 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v4, OS_LOG_TYPE_INFO, "Failed to find %s for create", (uint8_t *)&v5, 0xCu);
    }
    return 0;
  }
}

void IOHIDPreferencesSetForInstance(uint64_t a1, const __CFString *a2, const void *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  int v12 = (void (*)(uint64_t, const __CFString *, const void *, const __CFString *, const __CFString *, const __CFString *))__setForInstancePtr;
  if (__setForInstancePtr)
  {
    v12(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    uint64_t v13 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      int v14 = 136315138;
      uint64_t v15 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v13, OS_LOG_TYPE_INFO, "Failed to find %s for set, switch to default CFPreferences", (uint8_t *)&v14, 0xCu);
    }
    CFPreferencesSetValue(a2, a3, a6, a4, a5);
  }
}

void IOHIDPreferencesSetMultipleForInstance(uint64_t a1, const __CFDictionary *a2, const __CFArray *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  int v12 = (void (*)(uint64_t, const __CFDictionary *, const __CFArray *, const __CFString *, const __CFString *, const __CFString *))__setMultipleForInstancePtr;
  if (__setMultipleForInstancePtr)
  {
    v12(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    uint64_t v13 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      int v14 = 136315138;
      uint64_t v15 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v13, OS_LOG_TYPE_INFO, "Failed to find %s for set multiple , switch to default CFPreferences", (uint8_t *)&v14, 0xCu);
    }
    CFPreferencesSetMultiple(a2, a3, a6, a4, a5);
  }
}

CFPropertyListRef IOHIDPreferencesCopyForInstance(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  uint64_t v10 = (uint64_t (*)(uint64_t, const __CFString *, const __CFString *, const __CFString *, const __CFString *))__copyForInstancePtr;
  if (__copyForInstancePtr)
  {
    return (CFPropertyListRef)v10(a1, a2, a3, a4, a5);
  }
  else
  {
    int v12 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      int v13 = 136315138;
      int v14 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v12, OS_LOG_TYPE_INFO, "Failed to find %s for copy, switch to default CFPreferences", (uint8_t *)&v13, 0xCu);
    }
    return CFPreferencesCopyValue(a2, a5, a3, a4);
  }
}

CFDictionaryRef IOHIDPreferencesCopyMultipleForInstance(uint64_t a1, const __CFArray *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  uint64_t v10 = (uint64_t (*)(uint64_t, const __CFArray *, const __CFString *, const __CFString *, const __CFString *))__copyMultipleForInstancePtr;
  if (__copyMultipleForInstancePtr)
  {
    return (CFDictionaryRef)v10(a1, a2, a3, a4, a5);
  }
  else
  {
    int v12 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      int v13 = 136315138;
      int v14 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v12, OS_LOG_TYPE_INFO, "Failed to find %s for copy multiple, switch to default CFPreferences", (uint8_t *)&v13, 0xCu);
    }
    return CFPreferencesCopyMultiple(a2, a5, a3, a4);
  }
}

uint64_t IOHIDPreferencesSynchronizeForInstance(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  int v8 = (uint64_t (*)(uint64_t, const __CFString *, const __CFString *, const __CFString *))__synchronizeForInstancePtr;
  if (__synchronizeForInstancePtr)
  {
    return v8(a1, a2, a3, a4);
  }
  else
  {
    uint64_t v10 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = 136315138;
      int v12 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v10, OS_LOG_TYPE_INFO, "Failed to find %s for synchronize, switch to default CFPreferences", (uint8_t *)&v11, 0xCu);
    }
    return CFPreferencesSynchronize(a4, a2, a3);
  }
}

CFPropertyListRef IOHIDPreferencesCopyDomainForInstance(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  CFAllocatorRef v6 = (uint64_t (*)(uint64_t, const __CFString *, const __CFString *))__copyDomainForInstancePtr;
  if (__copyDomainForInstancePtr)
  {
    return (CFPropertyListRef)v6(a1, a2, a3);
  }
  else
  {
    int v8 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      int v9 = 136315138;
      uint64_t v10 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v8, OS_LOG_TYPE_INFO, "Failed to find %s for copy domain, switch to default CFPreferences", (uint8_t *)&v9, 0xCu);
    }
    return CFPreferencesCopyAppValue(a2, a3);
  }
}

void IOHIDPreferencesSetDomainForInstance(uint64_t a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (__loadFramework_haOnce != -1) {
    dispatch_once(&__loadFramework_haOnce, &__block_literal_global);
  }
  int v8 = (void (*)(uint64_t, const __CFString *, const void *, const __CFString *))__setDomainForInstancePtr;
  if (__setDomainForInstancePtr)
  {
    v8(a1, a2, a3, a4);
  }
  else
  {
    int v9 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      int v10 = 136315138;
      uint64_t v11 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
      _os_log_impl(&dword_18B46C000, v9, OS_LOG_TYPE_INFO, "Failed to find %s for set domain, switch to default CFPreferences", (uint8_t *)&v10, 0xCu);
    }
    CFPreferencesSetAppValue(a2, a3, a4);
  }
}

void ____loadFramework_block_invoke()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = dlopen("/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences", 1);
  __loadFramework_haHandle = (uint64_t)v0;
  if (v0)
  {
    __setPtr = dlsym(v0, "HIDPreferencesSet");
    if (__loadFramework_haHandle)
    {
      __setMultiplePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetMultiple");
      if (__loadFramework_haHandle)
      {
        __copyPtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopy");
        if (__loadFramework_haHandle)
        {
          __copyMultiplePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyMultiple");
          if (__loadFramework_haHandle)
          {
            __synchronizePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSynchronize");
            if (__loadFramework_haHandle)
            {
              __copyDomainPtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyDomain");
              if (__loadFramework_haHandle)
              {
                __setDomainPtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetDomain");
                if (__loadFramework_haHandle)
                {
                  __setForInstancePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetForInstance");
                  if (__loadFramework_haHandle)
                  {
                    __setMultipleForInstancePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetMultipleForInstance");
                    if (__loadFramework_haHandle)
                    {
                      __copyForInstancePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyForInstance");
                      if (__loadFramework_haHandle)
                      {
                        __copyMultipleForInstancePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyMultipleForInstance");
                        if (__loadFramework_haHandle)
                        {
                          __synchronizeForInstancePtr = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSynchronizeForInstance");
                          if (__loadFramework_haHandle)
                          {
                            CFIndex v1 = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCopyDomainForInstance");
                            int v2 = (void *)__loadFramework_haHandle;
                            __copyDomainForInstancePtr = v1;
                            if (__loadFramework_haHandle)
                            {
                              int v3 = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesSetDomainForInstance");
                              int v2 = (void *)__loadFramework_haHandle;
                              __setDomainForInstancePtr = v3;
                              if (__loadFramework_haHandle) {
                                int v2 = dlsym((void *)__loadFramework_haHandle, "HIDPreferencesCreateInstance");
                              }
                              goto LABEL_32;
                            }
LABEL_31:
                            __setDomainForInstancePtr = 0;
LABEL_32:
                            __createPtr = v2;
                            return;
                          }
LABEL_30:
                          int v2 = 0;
                          __copyDomainForInstancePtr = 0;
                          goto LABEL_31;
                        }
LABEL_29:
                        __synchronizeForInstancePtr = 0;
                        goto LABEL_30;
                      }
LABEL_28:
                      __copyMultipleForInstancePtr = 0;
                      goto LABEL_29;
                    }
LABEL_27:
                    __copyForInstancePtr = 0;
                    goto LABEL_28;
                  }
LABEL_26:
                  __setMultipleForInstancePtr = 0;
                  goto LABEL_27;
                }
LABEL_25:
                __setForInstancePtr = 0;
                goto LABEL_26;
              }
LABEL_24:
              __setDomainPtr = 0;
              goto LABEL_25;
            }
LABEL_23:
            __copyDomainPtr = 0;
            goto LABEL_24;
          }
LABEL_22:
          __synchronizePtr = 0;
          goto LABEL_23;
        }
LABEL_21:
        __copyMultiplePtr = 0;
        goto LABEL_22;
      }
    }
    else
    {
      __setMultiplePtr = 0;
    }
    __copyPtr = 0;
    goto LABEL_21;
  }
  uint64_t v4 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    CFAllocatorRef v6 = "/System/Library/PrivateFrameworks/HIDPreferences.framework/HIDPreferences";
    _os_log_impl(&dword_18B46C000, v4, OS_LOG_TYPE_DEFAULT, "Failed to load %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t __IOHIDEventRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDEventCFTypeID TypeID = result;
  return result;
}

uint64_t IOHIDEventGetTypeID()
{
  uint64_t result = __kIOHIDEventTypeID;
  if (!__kIOHIDEventTypeID)
  {
    pthread_once(&__eventTypeInit, (void (*)(void))__IOHIDEventRegister);
    return __kIOHIDEventTypeID;
  }
  return result;
}

uint64_t IOHIDSessionGetTypeID()
{
  return MEMORY[0x1F41817D0](HIDSession);
}

uint64_t _IOHIDSessionCreatePrivate(uint64_t a1)
{
  CFIndex v1 = +[HIDSession allocWithZone:a1];

  return (uint64_t)[(HIDSession *)v1 init];
}

CFTypeID IOHIDElementGetTypeID(void)
{
  return MEMORY[0x1F41817D0](HIDElement);
}

uint64_t _IOHIDElementCreatePrivate()
{
  return MEMORY[0x1F4181648](HIDElement);
}

CFTypeID IOHIDServiceClientGetTypeID(void)
{
  return MEMORY[0x1F41817D0](HIDServiceClient);
}

CFTypeID IOHIDDeviceGetTypeID(void)
{
  return MEMORY[0x1F41817D0](HIDDevice);
}

uint64_t _IOHIDDeviceCreatePrivate()
{
  return MEMORY[0x1F4181648](HIDDevice);
}

uint64_t isCrossLinking()
{
  return __sCrossLinkEnabled;
}

uint64_t setCrossLinkPageSize(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  if (v1.u32[0] != 1) {
    return 0;
  }
  __sCrossLinkPageSize = a1;
  uint64_t result = 1;
  __sCrossLinkEnabled = 1;
  return result;
}

uint64_t getEffectivePageSize()
{
  if (__sCrossLinkEnabled) {
    uint64_t v0 = &__sCrossLinkPageSize;
  }
  else {
    uint64_t v0 = (uint64_t *)MEMORY[0x1E4F14B00];
  }
  return *v0;
}

uint64_t roundPageCrossSafe(uint64_t a1)
{
  if (__sCrossLinkEnabled) {
    uint8x8_t v1 = &__sCrossLinkPageSize;
  }
  else {
    uint8x8_t v1 = (uint64_t *)MEMORY[0x1E4F14B00];
  }
  return (a1 + *v1 - 1) & -*v1;
}

uint64_t roundPageCrossSafeFixedWidth(uint64_t a1)
{
  if (__sCrossLinkEnabled == 1) {
    return (a1 + __sCrossLinkPageSize - 1) & -__sCrossLinkPageSize;
  }
  else {
    return ~*MEMORY[0x1E4F14AF0] & (unint64_t)(*MEMORY[0x1E4F14AF0] + a1);
  }
}

void DoCFSerializeBoolean(const __CFBoolean *a1, __CFData **a2)
{
  int Value = CFBooleanGetValue(a1);
  if (Value) {
    uint64_t v4 = "<true/>";
  }
  else {
    uint64_t v4 = "<false/>";
  }
  if (Value) {
    CFIndex v5 = 7;
  }
  else {
    CFIndex v5 = 8;
  }
  CFAllocatorRef v6 = *a2;

  CFDataAppendBytes(v6, (const UInt8 *)v4, v5);
}

uint64_t DoCFSerializeSet(const void *a1, CFMutableDataRef *a2)
{
  if (!previouslySerialized(a1, a2))
  {
    addStartTag(a1, 0, (uint64_t)a2);
    CFIndex Count = CFSetGetCount((CFSetRef)a1);
    if (Count)
    {
      uint64_t v5 = Count;
      uint64_t result = (uint64_t)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (!result) {
        return result;
      }
      uint64_t v7 = (void *)result;
      CFSetGetValues((CFSetRef)a1, (const void **)result);
      if (v5 < 1)
      {
        free(v7);
      }
      else
      {
        uint64_t v8 = 0;
        do
        {
          int v9 = DoCFSerialize(*((void *)v7 + v8++), a2);
          if (v9) {
            BOOL v10 = v8 < v5;
          }
          else {
            BOOL v10 = 0;
          }
        }
        while (v10);
        int v11 = v9;
        free(v7);
        if (!v11) {
          return 0;
        }
      }
    }
    addEndTag(a1, a2);
  }
  return 1;
}

CFStringRef IOCFUnserializeerror(CFStringRef result, uint64_t a2)
{
  if (result[1].data)
  {
    CFStringRef v2 = result;
    uint64_t result = CFStringCreateWithFormat((CFAllocatorRef)result->data, 0, @"IOCFUnserialize: %s near line %d", a2, HIDWORD(result->info));
    *(void *)v2[1].data = result;
  }
  return result;
}

CFStringRef IOObjectCopyClass(io_object_t object)
{
  return _IOObjectCopyClass(object, 0);
}

CFStringRef _IOObjectCopyClass(io_registry_entry_t a1, char a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  memset(v3, 0, sizeof(v3));
  _IOObjectGetClass(a1, a2, (char *)v3);
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v3, 0x8000100u);
}

CFStringRef IOObjectCopySuperclassForClass(CFStringRef classname)
{
  CFStringRef v1 = classname;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (classname)
  {
    memset(cStr, 0, sizeof(cStr));
    CFStringRef v2 = (char *)malloc_type_malloc(0x80uLL, 0x1000040AE2C30F4uLL);
    *(_OWORD *)CFStringRef v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    CFStringGetCString(v1, v2, 128, 0x8000100u);
    mach_port_t v3 = strncpy(__dst, v2, 0x80uLL);
    mainmach_port_name_t Port = 0;
    if (IOMasterPort(v3, &mainPort)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPort;
    }
    int superclass = io_object_get_superclass(v4, __dst);
    if (v4) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
    }
    if (superclass) {
      CFStringRef v1 = 0;
    }
    else {
      CFStringRef v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)cStr, 0x8000100u);
    }
    free(v2);
  }
  return v1;
}

CFStringRef IOObjectCopyBundleIdentifierForClass(CFStringRef classname)
{
  CFStringRef v1 = classname;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (classname)
  {
    memset(cStr, 0, sizeof(cStr));
    CFStringRef v2 = (char *)malloc_type_malloc(0x80uLL, 0x1000040AE2C30F4uLL);
    CFStringGetCString(v1, v2, 128, 0x8000100u);
    mach_port_t v3 = strncpy(__dst, v2, 0x80uLL);
    mainmach_port_name_t Port = 0;
    if (IOMasterPort(v3, &mainPort)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPort;
    }
    int bundle_identifier = io_object_get_bundle_identifier(v4, __dst);
    if (v4) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
    }
    if (bundle_identifier) {
      CFStringRef v1 = 0;
    }
    else {
      CFStringRef v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)cStr, 0x8000100u);
    }
    free(v2);
  }
  return v1;
}

BOOLean_t IOObjectIsEqualTo(io_object_t object, io_object_t anObject)
{
  return object == anObject;
}

uint32_t IOObjectGetKernelRetainCount(io_object_t object)
{
  if (io_object_get_retain_count(object)) {
    return 0;
  }
  else {
    return 0;
  }
}

uint32_t IOObjectGetRetainCount(io_object_t object)
{
  if (io_object_get_retain_count(object)) {
    return 0;
  }
  else {
    return 0;
  }
}

uint32_t IOObjectGetUserRetainCount(io_object_t object)
{
  uint32_t v2 = 0;
  if (MEMORY[0x18C131220](*MEMORY[0x1E4F14960], *(void *)&object, 0, &v2)) {
    return 0;
  }
  else {
    return v2;
  }
}

BOOLean_t IOIteratorIsValid(io_iterator_t iterator)
{
  if (io_iterator_is_valid(iterator)) {
    return 0;
  }
  else {
    return 0;
  }
}

kern_return_t IOServiceMatchPropertyTable(io_service_t service, CFDictionaryRef matching, BOOLean_t *matches)
{
  kern_return_t v3;
  CFDataRef v5;
  CFDataRef v6;
  unint64_t Length;
  int v8;
  const char *BytePtr;
  kern_return_t matched;
  const UInt8 *v11;
  kern_return_t v12;

  mach_port_t v3 = -536870206;
  if (matching)
  {
    uint64_t v5 = IOCFSerialize(matching, gIOKitLibSerializeOptions);
    if (v5)
    {
      CFAllocatorRef v6 = v5;
      int Length = CFDataGetLength(v5);
      uint64_t v8 = Length;
      if (gIOKitLibSerializeOptions)
      {
        if (Length <= 0xFFF)
        {
          CFDataGetBytePtr(v6);
          matched = io_service_match_property_table_bin();
          goto LABEL_9;
        }
      }
      else if (Length <= 0x1FF)
      {
        BytePtr = (const char *)CFDataGetBytePtr(v6);
        matched = io_service_match_property_table(service, BytePtr);
LABEL_9:
        mach_port_t v3 = matched;
LABEL_13:
        CFRelease(v6);
        return v3;
      }
      int v11 = CFDataGetBytePtr(v6);
      uint64_t v12 = io_service_match_property_table_ool(service, (uint64_t)v11, v8);
      if (v12) {
        mach_port_t v3 = v12;
      }
      else {
        mach_port_t v3 = 0;
      }
      goto LABEL_13;
    }
    return -536870201;
  }
  return v3;
}

kern_return_t IOServiceAddNotification(mach_port_t mainPort, const io_name_t notificationType, CFDictionaryRef matching, mach_port_t wakePort, uintptr_t reference, io_iterator_t *notification)
{
  uintptr_t v7 = reference;
  return InternalIOServiceAddNotification(mainPort, notificationType, matching, wakePort, &v7, 1u, notification);
}

kern_return_t IONotificationPortSetImportanceReceiver(IONotificationPortRef notify)
{
  kern_return_t result;

  uint64_t result = MEMORY[0x18C131260](*MEMORY[0x1E4F14960], *((unsigned int *)notify + 1), 5, 0, 0);
  if (result) {
    IONotificationPortSetImportanceReceiver_cold_1();
  }
  return result;
}

CFMutableDictionaryRef IOOpenFirmwarePathMatching(mach_port_t mainPort, uint32_t options, const char *path)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  memset(v5, 0, sizeof(v5));
  __strlcpy_chk();
  if ((int)strlen(path) > 498) {
    return 0;
  }
  __strlcpy_chk();
  return MakeOneStringProp(@"IOPathMatch", (const char *)v5);
}

kern_return_t OSGetNotificationFromMessage(mach_msg_header_t *msg, uint32_t index, uint32_t *type, uintptr_t *reference, void **content, vm_size_t *size)
{
  kern_return_t v6;
  mach_msg_header_t *v7;

  uint64_t v6 = -536870210;
  if (msg->msgh_id != 53) {
    return -536870202;
  }
  if (!index && msg->msgh_size >= 0x60)
  {
    if (type) {
      *type = msg[1].msgh_size & 0xFFF;
    }
    if (reference) {
      *reference = *(void *)&msg[1].msgh_remote_port;
    }
    if (size) {
      *unsigned int size = msg[1].msgh_bits;
    }
    uint64_t v6 = 0;
    if (content)
    {
      if (msg[1].msgh_bits) {
        uintptr_t v7 = msg + 4;
      }
      else {
        uintptr_t v7 = 0;
      }
      *content = v7;
    }
  }
  return v6;
}

uint64_t IOServiceGetBusyStateAndTime(unsigned int a1, void *a2, _DWORD *a3, void *a4)
{
  uint64_t result = io_service_get_state(a1);
  if (result)
  {
    *a2 = 0;
    *a3 = 0;
    *a4 = 0;
  }
  return result;
}

kern_return_t IOServiceGetBusyState(io_service_t service, uint32_t *busyState)
{
  kern_return_t result;

  uint64_t result = io_service_get_state(service);
  if (result) {
    *busyState = 0;
  }
  return result;
}

uint64_t IOServiceGetState(unsigned int a1, void *a2)
{
  uint64_t result = io_service_get_state(a1);
  if (result) {
    *a2 = 0;
  }
  return result;
}

kern_return_t IOKitGetBusyState(mach_port_t mainPort, uint32_t *busyState)
{
  kern_return_t v5;
  kern_return_t state;
  mach_port_t mainPorta[2];

  mach_port_t v4 = mainPort;
  if (!mainPort)
  {
    mainPorta[0] = 0;
    if (IOMasterPort(0, mainPorta)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPorta[0];
    }
  }
  uint64_t v5 = io_registry_entry_from_path(v4, "IOService:/");
  if (v5)
  {
    state = v5;
    *busyState = 0;
    if (!v4) {
      return state;
    }
    goto LABEL_11;
  }
  *(void *)mach_port_t mainPorta = 0;
  state = io_service_get_state(0);
  if (state) {
    *busyState = 0;
  }
  mach_port_deallocate(*MEMORY[0x1E4F14960], 0);
  if (v4)
  {
LABEL_11:
    if (v4 != mainPort) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
    }
  }
  return state;
}

kern_return_t IOServiceWaitQuiet(io_service_t service, mach_timespec_t *waitTime)
{
  uint32_t v2 = (uint64_t *)&unk_18B50BD30;
  if (waitTime) {
    uint32_t v2 = (uint64_t *)waitTime;
  }
  return io_service_wait_quiet(service, *v2);
}

kern_return_t IOKitWaitQuietWithOptions(mach_port_t mainPort, mach_timespec_t *waitTime, IOOptionBits options)
{
  kern_return_t v7;
  uint64_t *v8;
  mach_port_t mainPorta;

  mach_port_t v6 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v6 = 0;
    }
    else {
      mach_port_t v6 = mainPorta;
    }
  }
  uintptr_t v7 = io_registry_entry_from_path(v6, "IOService:/");
  if (!v7)
  {
    uint64_t v8 = (uint64_t *)&unk_18B50BD30;
    if (waitTime) {
      uint64_t v8 = (uint64_t *)waitTime;
    }
    uintptr_t v7 = io_service_wait_quiet_with_options(0, *v8, options);
    mach_port_deallocate(*MEMORY[0x1E4F14960], 0);
  }
  if (v6 && v6 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v6);
  }
  return v7;
}

kern_return_t IOKitWaitQuiet(mach_port_t mainPort, mach_timespec_t *waitTime)
{
  kern_return_t v5;
  uint64_t *v6;
  mach_port_t mainPorta;

  mach_port_t v4 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPorta;
    }
  }
  uint64_t v5 = io_registry_entry_from_path(v4, "IOService:/");
  if (!v5)
  {
    mach_port_t v6 = (uint64_t *)&unk_18B50BD30;
    if (waitTime) {
      mach_port_t v6 = (uint64_t *)waitTime;
    }
    uint64_t v5 = io_service_wait_quiet(0, *v6);
    mach_port_deallocate(*MEMORY[0x1E4F14960], 0);
  }
  if (v4 && v4 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
  }
  return v5;
}

kern_return_t IOServiceAuthorize(io_service_t service, uint32_t options)
{
  kern_return_t uint64;
  xpc_object_t v4;
  void *v5;
  _xpc_connection_s *v6;
  _xpc_connection_s *v7;
  xpc_object_t v8;
  void *v9;

  uint64_t uint64 = -536870211;
  if (io_registry_entry_get_registry_entry_id(service)) {
    return -536870206;
  }
  mach_port_t v4 = xpc_dictionary_create(0, 0, 0);
  if (v4)
  {
    uint64_t v5 = v4;
    xpc_dictionary_set_uint64(v4, "options", options);
    xpc_dictionary_set_uint64(v5, "service", 0);
    mach_port_t v6 = xpc_connection_create("com.apple.iokit.IOServiceAuthorizeAgent", 0);
    if (v6)
    {
      uintptr_t v7 = v6;
      xpc_connection_set_event_handler(v6, &__block_literal_global_0);
      xpc_connection_resume(v7);
      uint64_t v8 = xpc_connection_send_message_with_reply_sync(v7, v5);
      if (v8)
      {
        int v9 = v8;
        if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590]) {
          uint64_t uint64 = xpc_dictionary_get_uint64(v9, "status");
        }
        else {
          uint64_t uint64 = -536870202;
        }
        xpc_release(v9);
      }
      else
      {
        uint64_t uint64 = -536870207;
      }
      xpc_release(v7);
    }
    else
    {
      uint64_t uint64 = -536870201;
    }
    xpc_release(v5);
  }
  return uint64;
}

int IOServiceOpenAsFileDescriptor(io_service_t service, int oflag)
{
  if (io_registry_entry_get_registry_entry_id(service))
  {
    int v3 = -1;
    int uint64 = 49174;
    goto LABEL_3;
  }
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  if (v6)
  {
    uintptr_t v7 = v6;
    xpc_dictionary_set_int64(v6, "oflag", oflag);
    xpc_dictionary_set_uint64(v7, "service", 0);
    uint64_t v8 = xpc_connection_create("com.apple.iokit.ioserviceauthorized", 0);
    if (v8)
    {
      int v9 = v8;
      xpc_connection_set_event_handler(v8, &__block_literal_global_34);
      xpc_connection_resume(v9);
      xpc_object_t v10 = xpc_connection_send_message_with_reply_sync(v9, v7);
      if (!v10)
      {
        int uint64 = 49165;
        int v3 = -1;
        goto LABEL_17;
      }
      int v11 = v10;
      if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590])
      {
        int uint64 = xpc_dictionary_get_uint64(v11, "status");
        if (!uint64)
        {
          int v3 = xpc_dictionary_dup_fd(v11, "fd");
          goto LABEL_16;
        }
      }
      else
      {
        int uint64 = 49246;
      }
      int v3 = -1;
LABEL_16:
      xpc_release(v11);
LABEL_17:
      xpc_release(v9);
      xpc_release(v7);
      if (!uint64) {
        return v3;
      }
      goto LABEL_3;
    }
    xpc_release(v7);
    int v3 = -1;
    int uint64 = 49197;
  }
  else
  {
    int v3 = -1;
    int uint64 = 49164;
  }
LABEL_3:
  if ((uint64 & 0x3FFF | 0xC000) == uint64) {
    *__error() = uint64 & 0x3FFF;
  }
  return v3;
}

kern_return_t IOConnectAddRef(io_connect_t connect)
{
  return mach_port_mod_refs(*MEMORY[0x1E4F14960], connect, 0, 1);
}

kern_return_t IOConnectRelease(io_connect_t connect)
{
  return mach_port_mod_refs(*MEMORY[0x1E4F14960], connect, 0, -1);
}

kern_return_t IOConnectCallAsyncStructMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return IOConnectCallAsyncMethod(connection, selector, wake_port, reference, referenceCnt, 0, 0, inputStruct, inputStructCnt, 0, 0, outputStruct, outputStructCnt);
}

kern_return_t IOConnectTrap0(io_connect_t connect, uint32_t index)
{
  return iokit_user_client_trap(*(void **)&connect, index, 0, 0, 0, 0, 0, 0);
}

kern_return_t IOConnectTrap4(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, (void *)p3, (void *)p4, 0, 0);
}

kern_return_t IOConnectTrap5(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
{
  return iokit_user_client_trap(*(void **)&connect, index, (void *)p1, (void *)p2, (void *)p3, (void *)p4, (void *)p5, 0);
}

io_registry_entry_t IORegistryEntryCopyFromPath(mach_port_t mainPort, CFStringRef path)
{
  mach_port_name_t v4 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_name_t v4 = 0;
    }
    else {
      mach_port_name_t v4 = mainPorta;
    }
  }
  CStringPtr = CFStringGetCStringPtr(path, 0x8000100u);
  if (CStringPtr)
  {
    xpc_object_t v6 = CStringPtr;
    uintptr_t v7 = 0;
    goto LABEL_7;
  }
  CFIndex Length = CFStringGetLength(path);
  CFIndex v10 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 4;
  int v11 = (char *)malloc_type_malloc(v10, 0x6F47E89uLL);
  if (!v11)
  {
    uintptr_t v7 = 0;
    goto LABEL_18;
  }
  xpc_object_t v6 = v11;
  int CString = CFStringGetCString(path, v11, v10, 0x8000100u);
  uintptr_t v7 = (char *)v6;
  if (!CString)
  {
LABEL_18:
    if (!v7) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_7:
  strlen(v6);
  if (io_registry_entry_from_path_ool()) {
    goto LABEL_18;
  }
  if (v7) {
LABEL_9:
  }
    free(v7);
LABEL_10:
  if (v4 && v4 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
  }
  return 0;
}

CFStringRef IORegistryEntryCopyPath(io_registry_entry_t entry, const io_name_t plane)
{
  MEMORY[0x1F4188790](*(void *)&entry, plane);
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)cStr = 0u;
  long long v5 = 0u;
  CFStringRef v2 = 0;
  if (!io_registry_entry_get_path_ool()) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
  }
  return v2;
}

BOOLean_t IORegistryEntryInPlane(io_registry_entry_t entry, const io_name_t plane)
{
  if (io_registry_entry_in_plane(entry, plane)) {
    return 0;
  }
  else {
    return 0;
  }
}

kern_return_t IORegistryEntryGetNameInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t name)
{
  if (!plane) {
    plane = "";
  }
  return io_registry_entry_get_name_in_plane(entry, plane);
}

kern_return_t IORegistryEntryGetLocationInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t location)
{
  if (!plane) {
    plane = "";
  }
  return io_registry_entry_get_location_in_plane(entry, plane);
}

kern_return_t IORegistryEntryGetChildEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *child)
{
  kern_return_t result;

  uint64_t result = io_registry_entry_get_child_iterator(entry, plane);
  if (!result)
  {
    io_iterator_next(0);
    *child = 0;
    mach_port_deallocate(*MEMORY[0x1E4F14960], 0);
    if (*child) {
      return 0;
    }
    else {
      return -536870208;
    }
  }
  return result;
}

kern_return_t IOServiceOFPathToBSDName(mach_port_t mainPort, const io_name_t openFirmwarePath, io_name_t bsdName)
{
  kern_return_t MatchingServices;
  int v7;
  mach_port_name_t v8;
  BOOL v9;
  ipc_space_t *v10;
  kern_return_t property_bytes;
  io_iterator_t existing;
  mach_port_name_t v14;

  io_iterator_t existing = 0;
  *bsdName = 0;
  CFDictionaryRef v5 = IOOpenFirmwarePathMatching(mainPort, (uint32_t)openFirmwarePath, openFirmwarePath);
  uint64_t MatchingServices = IOServiceGetMatchingServices(mainPort, v5, &existing);
  if (!MatchingServices)
  {
    long long v14 = 0;
    long long v7 = io_iterator_next(existing);
    long long v8 = v14;
    if (v7) {
      long long v9 = 1;
    }
    else {
      long long v9 = v14 == 0;
    }
    long long v10 = (ipc_space_t *)MEMORY[0x1E4F14960];
    if (v9)
    {
      uint64_t MatchingServices = 5;
    }
    else
    {
      property_UInt8 bytes = io_registry_entry_get_property_bytes(v14, (uint64_t)"BSD Name");
      uint64_t MatchingServices = property_bytes;
      if (property_bytes) {
        *bsdName = 0;
      }
      mach_port_deallocate(*v10, v8);
    }
    mach_port_deallocate(*v10, existing);
  }
  return MatchingServices;
}

kern_return_t IOCatalogueSendData(mach_port_t mainPort, uint32_t flag, const char *buffer, uint32_t size)
{
  kern_return_t v9;
  mach_port_t mainPorta;

  mach_port_t v8 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v8 = 0;
    }
    else {
      mach_port_t v8 = mainPorta;
    }
  }
  long long v9 = io_catalog_send_data(v8, flag, (uint64_t)buffer, size);
  if (v8 && v8 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v8);
  }
  if (v9) {
    return v9;
  }
  else {
    return 0;
  }
}

kern_return_t IOCatalogueTerminate(mach_port_t mainPort, uint32_t flag, io_name_t description)
{
  kern_return_t v7;
  mach_port_t mainPorta;

  mach_port_t v6 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v6 = 0;
    }
    else {
      mach_port_t v6 = mainPorta;
    }
  }
  long long v7 = io_catalog_terminate(v6, flag, description);
  if (v6 && v6 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v6);
  }
  return v7;
}

kern_return_t IOCatalogueGetData(mach_port_t mainPort, uint32_t flag, char **buffer, uint32_t *size)
{
  kern_return_t data;
  mach_port_t mainPorta;

  mach_port_t v6 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v6 = 0;
    }
    else {
      mach_port_t v6 = mainPorta;
    }
  }
  data = io_catalog_get_data(v6, flag);
  if (v6 && v6 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v6);
  }
  return data;
}

uint64_t IOCatlogueGetGenCount(mach_port_t a1)
{
  mach_port_t v2 = a1;
  if (!a1)
  {
    mainmach_port_name_t Port = 0;
    if (IOMasterPort(0, &mainPort)) {
      mach_port_t v2 = 0;
    }
    else {
      mach_port_t v2 = mainPort;
    }
  }
  uint64_t gen_count = io_catalog_get_gen_count(v2);
  if (v2 && v2 != a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v2);
  }
  return gen_count;
}

kern_return_t IOCatalogueModuleLoaded(mach_port_t mainPort, io_name_t name)
{
  kern_return_t v5;
  mach_port_t mainPorta;

  mach_port_t v4 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPorta;
    }
  }
  CFDictionaryRef v5 = io_catalog_module_loaded(v4, name);
  if (v4 && v4 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
  }
  return v5;
}

kern_return_t IOCatalogueReset(mach_port_t mainPort, uint32_t flag)
{
  kern_return_t v5;
  mach_port_t mainPorta;

  mach_port_t v4 = mainPort;
  if (!mainPort)
  {
    mach_port_t mainPorta = 0;
    if (IOMasterPort(0, &mainPorta)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPorta;
    }
  }
  CFDictionaryRef v5 = io_catalog_reset(v4, flag);
  if (v4 && v4 != mainPort) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
  }
  return v5;
}

uint64_t IORegistryCreateEnumerator(mach_port_t a1, _DWORD *a2)
{
  mach_port_t v4 = a1;
  if (!a1)
  {
    mainmach_port_name_t Port = 0;
    if (IOMasterPort(0, &mainPort)) {
      mach_port_t v4 = 0;
    }
    else {
      mach_port_t v4 = mainPort;
    }
  }
  uint64_t iterator = io_registry_create_iterator(v4, "IOService", 1, a2);
  if (v4 && v4 != a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
  }
  return iterator;
}

uint64_t IORegistryEnumeratorNextConforming(unsigned int a1)
{
  lastRegIter = 0;
  return 3758097088;
}

uint64_t IOOpenConnection(uint64_t a1, int a2, int a3)
{
  unsigned int v3 = io_service_open_extended(lastRegIter, a2, a3, *MEMORY[0x1E4F14068], 0, 0);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  mach_port_deallocate(*MEMORY[0x1E4F14960], lastRegIter);
  return v4;
}

uint64_t IOSetNotificationPort(unsigned int a1, int a2, int a3)
{
  return io_connect_set_notification_port(a1, a2, a3, 0);
}

uint64_t IORegistryDisposeEnumerator(mach_port_name_t name)
{
  return mach_port_deallocate(*MEMORY[0x1E4F14960], name);
}

uint64_t IOCompatibiltyNumber(uint64_t a1, _DWORD *a2)
{
  *a2 = 1;
  return 0;
}

uint64_t readFile(const char *a1, void *a2, off_t *a3)
{
  memset(&v12, 0, sizeof(v12));
  *a2 = 0;
  *a3 = 0;
  int v5 = open(a1, 0, *(_OWORD *)&v12.st_dev, *(_OWORD *)&v12.st_uid, *(_OWORD *)&v12.st_atimespec, *(_OWORD *)&v12.st_mtimespec, *(_OWORD *)&v12.st_ctimespec, *(_OWORD *)&v12.st_birthtimespec);
  if (v5 != -1)
  {
    int v6 = v5;
    if (fstat(v5, &v12) != -1)
    {
      if (((__int16)v12.st_mode & 0x80000000) == 0)
      {
        *a2 = 0;
        *a3 = 0;
        uint64_t v7 = 3758097102;
LABEL_10:
        close(v6);
        return v7;
      }
      st_unsigned int size = v12.st_size;
      long long v9 = (void *)MEMORY[0x1E4F14B00];
      *a3 = v12.st_size;
      long long v10 = mmap(0, (st_size + *v9 - 1) & -*v9, 1, 2, v6, 0);
      *a2 = v10;
      if (v10)
      {
        uint64_t v7 = 0;
        goto LABEL_10;
      }
      *a3 = 0;
    }
    uint64_t v7 = *__error();
    goto LABEL_10;
  }
  return *__error();
}

CFPropertyListRef readPlist(const char *a1)
{
  mach_vm_size_t v8 = 0;
  long long v9 = 0;
  CFPropertyListRef v1 = 0;
  if (!readFile(a1, &v9, (off_t *)&v8))
  {
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    mach_vm_size_t v4 = v8;
    unsigned int v3 = v9;
    CFDataRef v5 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, v8, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v5)
    {
      CFDataRef v6 = v5;
      CFPropertyListRef v1 = CFPropertyListCreateFromXMLData(v2, v5, 1uLL, 0);
      CFRelease(v6);
    }
    else
    {
      CFPropertyListRef v1 = 0;
    }
    mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v3, v4);
  }
  return v1;
}

BOOL writePlist(const char *a1, const void *a2)
{
  XMLCFDataRef Data = CFPropertyListCreateXMLData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (!XMLData) {
    return 0;
  }
  CFDataRef v4 = XMLData;
  int v5 = open(a1, 1537, 420);
  if (v5 < 0)
  {
    BOOL v10 = 0;
  }
  else
  {
    int v6 = v5;
    CFIndex Length = CFDataGetLength(v4);
    if (Length)
    {
      size_t v8 = Length;
      BytePtr = CFDataGetBytePtr(v4);
      BOOL v10 = v8 == write(v6, BytePtr, v8);
    }
    else
    {
      BOOL v10 = 1;
    }
    close(v6);
  }
  CFRelease(v4);
  return v10;
}

uint64_t ev_try_lock()
{
  return _os_nospin_lock_trylock();
}

uint64_t ev_unlock()
{
  return MEMORY[0x1F40CA020]();
}

uint64_t IOServiceCopySystemStateNotificationService(mach_port_t a1, io_service_t *a2)
{
  OneStringProp = MakeOneStringProp(@"IOProviderClass", "IOSystemStateNotification");
  io_service_t MatchingService = IOServiceGetMatchingService(a1, OneStringProp);
  *a2 = MatchingService;
  if (MatchingService) {
    return 0;
  }
  else {
    return 3758097095;
  }
}

uint64_t IOServiceStateNotificationItemCreate(io_registry_entry_t a1, const void *a2, const __CFDictionary *a3)
{
  if (!a2 || !a3) {
    return 3758097090;
  }
  MutableCFSetRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3);
  CFDictionarySetValue(MutableCopy, @"com.apple.iokit.statenotification.name", a2);
  uint64_t v6 = IORegistryEntrySetCFProperty(a1, @"com.apple.iokit.statenotification.create", MutableCopy);
  CFRelease(MutableCopy);
  return v6;
}

uint64_t IOServiceStateNotificationItemSet(io_registry_entry_t a1, const void *a2, const __CFDictionary *a3)
{
  if (!a2 || !a3) {
    return 3758097090;
  }
  MutableCFSetRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3);
  CFDictionarySetValue(MutableCopy, @"com.apple.iokit.statenotification.name", a2);
  uint64_t v6 = IORegistryEntrySetCFProperty(a1, @"com.apple.iokit.statenotification.set", MutableCopy);
  CFRelease(MutableCopy);
  return v6;
}

uint64_t IOServiceStateNotificationItemCopy(io_registry_entry_t a1, const void *a2, void *a3, IOOptionBits a4)
{
  CFMutableDictionaryRef properties = 0;
  uint64_t result = IORegistryEntryCreateCFProperties(a1, &properties, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], a4);
  if (!result)
  {
    int Value = CFDictionaryGetValue(properties, a2);
    size_t v8 = Value;
    if (Value)
    {
      CFRetain(Value);
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = 3758097136;
    }
    *a3 = v8;
  }
  return result;
}

uint64_t _IOReadBytesFromFile(uint64_t result, char *a2, void **a3, off_t *a4, off_t st_size)
{
  if (result)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)result;
    *a3 = 0;
    int v9 = open(a2, 0, 438);
    if (v9 < 0) {
      return 0;
    }
    int v10 = v9;
    memset(&v16, 0, sizeof(v16));
    if (fstat(v9, &v16) < 0)
    {
      int v13 = *__error();
      close(v10);
      long long v14 = __error();
      uint64_t result = 0;
      *long long v14 = v13;
    }
    else if ((v16.st_mode & 0xF000) == 0x8000)
    {
      if (v16.st_size)
      {
        if (v16.st_size <= st_size || st_size == 0) {
          st_unsigned int size = v16.st_size;
        }
        stat v12 = CFAllocatorAllocate(v8, st_size, 0);
        *a3 = v12;
        if (read(v10, v12, st_size) < 0)
        {
          CFAllocatorDeallocate(v8, *a3);
          *a3 = 0;
          close(v10);
          return 0;
        }
      }
      else
      {
        st_unsigned int size = 0;
        *a3 = CFAllocatorAllocate(v8, 4, 0);
      }
      *a4 = st_size;
      close(v10);
      return 1;
    }
    else
    {
      close(v10);
      long long v15 = __error();
      uint64_t result = 0;
      *long long v15 = 13;
    }
  }
  return result;
}

uint64_t _IOWriteBytesToFile(const char *a1, const void *a2, size_t a3)
{
  memset(&v12, 0, sizeof(v12));
  mode_t v6 = umask(0);
  umask(v6);
  if (stat(a1, &v12) && *__error() != 2) {
    return 0;
  }
  int v7 = open(a1, 1537, 438);
  if (v7 < 0) {
    return 0;
  }
  int v8 = v7;
  if (a3 && write(v7, a2, a3) != a3)
  {
    int v10 = *__error();
    close(v8);
    long long v11 = __error();
    uint64_t result = 0;
    int *v11 = v10;
  }
  else
  {
    fsync(v8);
    close(v8);
    return 1;
  }
  return result;
}

uint64_t _IODataQueueEnqueueWithReadCallback(_DWORD *a1, uint64_t a2, mach_msg_header_t *a3, size_t a4, void (*a5)(uint64_t, char *, size_t), uint64_t a6)
{
  return __IODataQueueEnqueue(a1, a2, a3, a4, 0, a5, a6, 0);
}

IOReturn IODataQueueSetNotificationPort(IODataQueueMemory *dataQueue, mach_port_t notifyPort)
{
  if (!dataQueue) {
    return -536870206;
  }
  IOReturn result = 0;
  CFDataRef v4 = (char *)dataQueue + dataQueue->queueSize;
  *((void *)v4 + 2) = 0x1800000013;
  *((_DWORD *)v4 + 6) = notifyPort;
  *((_DWORD *)v4 + 7) = 0;
  *((_DWORD *)v4 + 9) = 0;
  return result;
}

kern_return_t IODestroyPlugInInterface(IOCFPlugInInterface **interface)
{
  kern_return_t v2;

  CFAllocatorRef v2 = ((uint64_t (*)(IOCFPlugInInterface **))(*interface)->Stop)(interface);
  ((void (*)(IOCFPlugInInterface **))(*interface)->Release)(interface);
  return v2;
}

uint64_t __IOHIDServiceConnectionCacheGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __serviceConnectionCacheCFTypeID TypeID = result;
  return result;
}

__CFDictionary *IOHIDServiceConnectionCacheCopyDebugInfo(uint64_t a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 40);
  if (v2 && CFDictionaryGetCount(v2)) {
    MutableCFSetRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFDictionaryRef *)(a1 + 40));
  }
  else {
    MutableCFSetRef Copy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFDataRef v4 = MutableCopy;
  if (MutableCopy)
  {
    int v5 = *(const void **)(a1 + 24);
    if (v5) {
      CFDictionarySetValue(MutableCopy, @"ReportInterval", v5);
    }
    if (!CFDictionaryGetCount(v4))
    {
      CFRelease(v4);
      return 0;
    }
  }
  return v4;
}

void __IOHIDServiceConnectionCacheFree(void *a1)
{
  CFDictionaryRef v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  unsigned int v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  CFDataRef v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
}

io_connect_t IOPMFindPowerManagement(mach_port_t master_device_port)
{
  kern_return_t v3;
  io_connect_t connect;

  io_connect_t result = IORegistryEntryFromPath(master_device_port, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (result)
  {
    io_object_t v2 = result;
    io_connect_t connect = 0;
    unsigned int v3 = IOServiceOpen(result, *MEMORY[0x1E4F14960], 0, &connect);
    IOObjectRelease(v2);
    if (v3) {
      return 0;
    }
    else {
      return connect;
    }
  }
  return result;
}

IOReturn IOPMGetAggressiveness(io_connect_t fb, unint64_t type, unint64_t *aggressiveness)
{
  kern_return_t v4;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input;

  output = 0;
  uint64_t input = type;
  outputCnt = 1;
  CFDataRef v4 = IOConnectCallScalarMethod(fb, 1u, &input, 1u, &output, &outputCnt);
  *aggressiveness = output;
  if (v4) {
    return -536870212;
  }
  else {
    return 0;
  }
}

IOReturn IOPMSetAggressiveness(io_connect_t fb, unint64_t type, unint64_t aggressiveness)
{
  input[2] = *MEMORY[0x1E4F143B8];
  input[0] = type;
  input[1] = aggressiveness;
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  if (IOConnectCallScalarMethod(fb, 0, input, 2u, &output, &outputCnt)) {
    return -536870212;
  }
  else {
    return output;
  }
}

IOReturn IOPMSleepSystem(io_connect_t fb)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  if (IOConnectCallScalarMethod(fb, 2u, 0, 0, &output, &outputCnt)) {
    return -536870212;
  }
  else {
    return output;
  }
}

uint64_t IOPMSleepSystemWithOptions(mach_port_t connection, CFTypeRef object)
{
  size_t v9 = 4;
  uint64_t outputStruct = 0;
  if (object)
  {
    CFDataRef v3 = IOCFSerialize(object, 0);
    if (v3)
    {
      CFDataRef v4 = v3;
      BytePtr = CFDataGetBytePtr(v3);
      size_t Length = CFDataGetLength(v4);
      uint64_t v7 = IOConnectCallStructMethod(connection, 7u, BytePtr, Length, &outputStruct, &v9);
      CFRelease(v4);
      if (!v7) {
        return outputStruct;
      }
    }
    else
    {
      return 3758097097;
    }
  }
  else
  {
    uint64_t output = 0;
    uint32_t outputCnt = 1;
    if (IOConnectCallScalarMethod(connection, 2u, 0, 0, &output, &outputCnt)) {
      return 3758097084;
    }
    else {
      return output;
    }
  }
  return v7;
}

IOReturn IOPMCopyBatteryInfo(mach_port_t masterPort, CFArrayRef *info)
{
  IOReturn v3 = -536870201;
  *info = 0;
  io_registry_entry_t v4 = IORegistryEntryFromPath(masterPort, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v4) {
    return -536870201;
  }
  io_object_t v5 = v4;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *info = (CFArrayRef)IORegistryEntryCreateCFProperty(v4, @"IOBatteryInfo", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  IOObjectRelease(v5);
  IOReturn result = 0;
  if (*info) {
    return result;
  }
  io_iterator_t existing = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v6, 1, MEMORY[0x1E4F1D510]);
  if (!Mutable) {
    return -536870211;
  }
  size_t v9 = Mutable;
  CFDictionaryRef v10 = IOServiceMatching("IOPMPowerSource");
  if (!IOServiceGetMatchingServices(0, v10, &existing))
  {
    io_object_t v11 = IOIteratorNext(existing);
    if (v11)
    {
      io_registry_entry_t v12 = v11;
      int v13 = 0;
      do
      {
        CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v12, @"LegacyBatteryInfo", v6, 0);
        if (CFProperty)
        {
          long long v15 = CFProperty;
          ++v13;
          CFArrayAppendValue(v9, CFProperty);
          CFRelease(v15);
          IOObjectRelease(v12);
        }
        io_registry_entry_t v12 = IOIteratorNext(existing);
      }
      while (v12);
      IOObjectRelease(existing);
      if (v13 >= 1)
      {
        IOReturn v3 = 0;
        *info = v9;
        return v3;
      }
    }
    else
    {
      IOObjectRelease(existing);
    }
    CFRelease(v9);
    return v3;
  }
  CFRelease(v9);
  return -536870212;
}

io_connect_t IORegisterApp(void *refcon, io_service_t theDriver, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  kern_return_t v10;
  io_connect_t result;
  BOOL v12;
  kern_return_t v13;
  io_connect_t connect;

  io_connect_t connect = 0;
  *notifier = 0;
  if (!theDriver) {
    return 0;
  }
  CFDictionaryRef v10 = IOServiceOpen(theDriver, *MEMORY[0x1E4F14960], 0, &connect);
  IOReturn result = connect;
  if (v10) {
    io_registry_entry_t v12 = 1;
  }
  else {
    io_registry_entry_t v12 = connect == 0;
  }
  if (v12
    || (v13 = IOServiceAddInterestNotification(*thePortRef, theDriver, "IOAppPowerStateInterest", callback, refcon, notifier), IOReturn result = connect, v13))
  {
    if (result) {
      IOServiceClose(result);
    }
    IOReturn result = *notifier;
    if (*notifier)
    {
      IOObjectRelease(result);
      return 0;
    }
  }
  return result;
}

IOReturn IODeregisterApp(io_object_t *notifier)
{
  io_object_t v2 = *notifier;
  if (v2)
  {
    IOObjectRelease(v2);
    *notifier = 0;
  }
  return 0;
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  uint64_t input = notificationID;
  if (IOConnectCallScalarMethod(kernelPort, 3u, &input, 1u, 0, 0)) {
    return -536870212;
  }
  else {
    return 0;
  }
}

IOReturn IOCancelPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  uint64_t input = notificationID;
  if (IOConnectCallScalarMethod(kernelPort, 4u, &input, 1u, 0, 0)) {
    return -536870212;
  }
  else {
    return 0;
  }
}

BOOLean_t IOPMSleepEnabled(void)
{
  io_registry_entry_t v0 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v0) {
    return 0;
  }
  io_object_t v1 = v0;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v0, @"IOSleepSupported", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (CFProperty)
  {
    CFRelease(CFProperty);
    BOOLean_t v3 = 1;
  }
  else
  {
    BOOLean_t v3 = 0;
  }
  IOObjectRelease(v1);
  return v3;
}

IOSystemLoadAdvisoryLevel IOGetSystemLoadAdvisory(void)
{
  int out_token = 0;
  uint64_t v1 = 0;
  if (notify_register_check("com.apple.system.powermanagement.SystemLoadAdvisory", &out_token)) {
    return 2;
  }
  notify_get_state(out_token, &v1);
  notify_cancel(out_token);
  return v1;
}

CFDictionaryRef IOCopySystemLoadAdvisoryDetailed(void)
{
  uint64_t v0 = *MEMORY[0x1E4F1CF80];
  CFStringRef v1 = _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"%@%@", @"State:", @"/IOKit/PowerManagement/SystemLoad/Detailed");
  io_object_t v2 = _io_SCDynamicStoreCreate(v0, @"IOKit IOGetSystemLoadAdvisoryDetailed", 0, 0);
  BOOLean_t v3 = v2;
  if (v2) {
    BOOL v4 = v1 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v7 = _io_SCDynamicStoreCopyValue((uint64_t)v2, (uint64_t)v1);
    io_object_t v5 = v7;
    if (v7)
    {
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v5) != TypeID)
      {
        CFRelease(v5);
        io_object_t v5 = 0;
      }
    }
LABEL_13:
    CFRelease(v1);
    if (!v3) {
      return (CFDictionaryRef)v5;
    }
    goto LABEL_8;
  }
  io_object_t v5 = 0;
  if (v1) {
    goto LABEL_13;
  }
  if (v2) {
LABEL_8:
  }
    CFRelease(v3);
  return (CFDictionaryRef)v5;
}

void *IOPMRegisterPrefsChangeNotification(NSObject *a1, void *a2)
{
  BOOL v4 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4 && notify_register_dispatch("com.apple.system.powermanagement.prefschange", (int *)v4, a1, a2))
  {
    free(v4);
    return 0;
  }
  return v4;
}

void IOPMUnregisterPrefsChangeNotification(int *a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      notify_cancel(v2);
    }
    *a1 = 0;
    free(a1);
  }
}

__CFString *getGenericPrefsPath()
{
  return @"com.apple.PowerManagement";
}

uint64_t getHostPrefsPath()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  timespec v5 = (timespec)xmmword_18B50BD60;
  uint64_t v0 = (const void *)getHostPrefsPath_uuidStr;
  CFTypeID TypeID = CFStringGetTypeID();
  if (!v0 || CFGetTypeID(v0) != TypeID)
  {
    memset(v8, 0, sizeof(v8));
    int v2 = gethostuuid(v8, &v5);
    if (v2)
    {
      int v3 = v2;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        int v7 = v3;
        _os_log_impl(&dword_18B46C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to get UUID. rc=%d\n", buf, 8u);
      }
    }
    else
    {
      snprintf((char *)buf, 0x64uLL, "%s.%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X", "com.apple.PowerManagement", v8[0], v8[1], v8[2], v8[3], v8[4], v8[5], v8[6], v8[7], v8[8], v8[9], v8[10], v8[11], v8[12], v8[13], v8[14],
        v8[15]);
      getHostPrefsPath_uuidStr = (uint64_t)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)buf, 0);
    }
  }
  return getHostPrefsPath_uuidStr;
}

CFSetRef isA_GenericPref(void *value)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[4] = xmmword_1E5489638;
  void v3[5] = *(_OWORD *)off_1E5489648;
  BOOL v4 = @"VAC-T";
  v3[0] = xmmword_1E54895F8;
  v3[1] = *(_OWORD *)&off_1E5489608;
  v3[2] = xmmword_1E5489618;
  v3[3] = *(_OWORD *)&off_1E5489628;
  CFSetRef result = (const __CFSet *)isA_GenericPref_genericSet;
  if (isA_GenericPref_genericSet) {
    return (const __CFSet *)(CFSetContainsValue(result, value) != 0);
  }
  CFSetRef result = CFSetCreate(0, (const void **)v3, 13, MEMORY[0x1E4F1D548]);
  isA_GenericPref_genericSet = (uint64_t)result;
  if (result) {
    return (const __CFSet *)(CFSetContainsValue(result, value) != 0);
  }
  return result;
}

__CFDictionary *copyPreferencesForSrc(__CFString *a1)
{
  HostPrefsPath = (__CFString *)getHostPrefsPath();
  CFDictionaryRef v3 = (const __CFDictionary *)IOPMCopyFromPrefs(@"com.apple.PowerManagement", a1);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (v3 && CFGetTypeID(v3) == TypeID) {
    MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(0, 0, v3);
  }
  else {
    MutableCFSetRef Copy = 0;
  }
  CFPropertyListRef v6 = IOPMCopyFromPrefs(HostPrefsPath, a1);
  CFTypeID v7 = CFDictionaryGetTypeID();
  if (!v6 || CFGetTypeID(v6) != v7)
  {
LABEL_9:
    if (!v3) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (MutableCopy)
  {
    mergeDictIntoMutable(MutableCopy, (CFDictionaryRef)v6, 0);
    goto LABEL_9;
  }
  MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v6);
  if (v3) {
LABEL_10:
  }
    CFRelease(v3);
LABEL_11:
  if (v6) {
    CFRelease(v6);
  }
  return MutableCopy;
}

CFPropertyListRef IOPMCopyFromPrefs(__CFString *a1, __CFString *value)
{
  HostPrefsPath = a1;
  if (a1) {
    goto LABEL_4;
  }
  if (isA_GenericPref(value))
  {
    HostPrefsPath = @"com.apple.PowerManagement";
LABEL_4:
    CFTypeID TypeID = CFStringGetTypeID();
    goto LABEL_5;
  }
  HostPrefsPath = (__CFString *)getHostPrefsPath();
  CFTypeID TypeID = CFStringGetTypeID();
  if (!HostPrefsPath) {
    return 0;
  }
LABEL_5:
  CFTypeID v5 = TypeID;
  CFTypeID v6 = CFGetTypeID(HostPrefsPath);
  if (!HostPrefsPath || v6 != v5) {
    return 0;
  }
  CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D3D0];
  CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1D3E0];

  return CFPreferencesCopyValue(value, HostPrefsPath, v7, v8);
}

void mergeDictIntoMutable(__CFDictionary *a1, CFDictionaryRef theDict, int a3)
{
  int Count = CFDictionaryGetCount(theDict);
  LODWORD(v7) = Count;
  if (!Count) {
    return;
  }
  CFStringRef v8 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  uint64_t v9 = (const void **)malloc_type_malloc(8 * (int)v7, 0xC0040B8AA526DuLL);
  CFDictionaryRef v10 = v9;
  if (v8 && v9)
  {
    CFDictionaryGetKeysAndValues(theDict, v8, v9);
    if ((int)v7 >= 1)
    {
      uint64_t v7 = v7;
      io_object_t v11 = v8;
      io_registry_entry_t v12 = v10;
      do
      {
        int v13 = *v11;
        long long v14 = *v12;
        if (a3) {
          CFDictionarySetValue(a1, v13, v14);
        }
        else {
          CFDictionaryAddValue(a1, v13, v14);
        }
        ++v12;
        ++v11;
        --v7;
      }
      while (v7);
    }
  }
  else if (!v8)
  {
    goto LABEL_13;
  }
  free(v8);
LABEL_13:
  if (v10)
  {
    free(v10);
  }
}

uint64_t setPreferencesForSrc(__CFString *a1, const __CFDictionary *a2, int a3)
{
  HostPrefsPath = (__CFString *)getHostPrefsPath();
  if (!a2)
  {
    CFPreferencesSetValue(a1, 0, @"com.apple.PowerManagement", (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    goto LABEL_26;
  }
  CFIndex Count = CFDictionaryGetCount(a2);
  if (!Count)
  {
LABEL_26:
    io_registry_entry_t v12 = 0;
    long long v15 = 0;
    io_object_t v11 = 0;
    uint64_t v9 = 0;
    goto LABEL_27;
  }
  uint64_t v7 = Count;
  size_t v8 = 8 * Count;
  uint64_t v9 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  CFDictionaryRef v10 = (const void **)malloc_type_malloc(v8, 0xC0040B8AA526DuLL);
  io_object_t v11 = v10;
  io_registry_entry_t v12 = 0;
  char v13 = 1;
  if (!v9 || !v10)
  {
    long long v15 = 0;
    goto LABEL_32;
  }
  CFDictionaryGetKeysAndValues(a2, v9, v10);
  if (v7 >= 1)
  {
    uint64_t v14 = 0;
    io_registry_entry_t v12 = 0;
    long long v15 = 0;
    while (1)
    {
      if (isA_GenericPref((void *)v9[v14]))
      {
        if (v15)
        {
          MutableCFSetRef Copy = v15;
        }
        else
        {
          CFDictionaryRef v17 = (const __CFDictionary *)IOPMCopyFromPrefs(@"com.apple.PowerManagement", a1);
          if (v17)
          {
            CFDictionaryRef v18 = v17;
            MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(0, 0, v17);
            CFRelease(v18);
            if (!MutableCopy) {
              goto LABEL_22;
            }
          }
          else
          {
            MutableCFSetRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (!MutableCopy)
            {
LABEL_22:
              long long v15 = 0;
              goto LABEL_19;
            }
          }
          long long v15 = MutableCopy;
        }
      }
      else if (v12)
      {
        MutableCFSetRef Copy = v12;
      }
      else
      {
        CFDictionaryRef v19 = (const __CFDictionary *)IOPMCopyFromPrefs(HostPrefsPath, a1);
        if (v19)
        {
          CFDictionaryRef v20 = v19;
          MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(0, 0, v19);
          CFRelease(v20);
          if (!MutableCopy) {
            goto LABEL_24;
          }
        }
        else
        {
          MutableCFSetRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (!MutableCopy)
          {
LABEL_24:
            io_registry_entry_t v12 = 0;
            goto LABEL_19;
          }
        }
        io_registry_entry_t v12 = MutableCopy;
      }
      CFDictionarySetValue(MutableCopy, v9[v14], v11[v14]);
LABEL_19:
      if (v7 == ++v14)
      {
        if (v15)
        {
          CFPreferencesSetValue(a1, v15, @"com.apple.PowerManagement", (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
          char v13 = 0;
          goto LABEL_32;
        }
LABEL_27:
        char v13 = 1;
        goto LABEL_32;
      }
    }
  }
  io_registry_entry_t v12 = 0;
  long long v15 = 0;
LABEL_32:
  if (a3)
  {
    uint64_t v21 = CFPreferencesSynchronize(@"com.apple.PowerManagement", (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3E0]) != 0;
    if (!HostPrefsPath) {
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v21 = 0;
    if (!HostPrefsPath) {
      goto LABEL_42;
    }
  }
  if (v12)
  {
    CFStringRef v22 = (const __CFString *)*MEMORY[0x1E4F1D3D0];
    CFStringRef v23 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
    CFStringRef v24 = a1;
    long long v25 = v12;
LABEL_38:
    CFPreferencesSetValue(v24, v25, HostPrefsPath, v22, v23);
    goto LABEL_40;
  }
  if (!a2)
  {
    CFStringRef v22 = (const __CFString *)*MEMORY[0x1E4F1D3D0];
    CFStringRef v23 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
    CFStringRef v24 = a1;
    long long v25 = 0;
    goto LABEL_38;
  }
LABEL_40:
  if (a3) {
    uint64_t v21 = (v21 & CFPreferencesSynchronize(HostPrefsPath, (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3E0]));
  }
LABEL_42:
  if (v9) {
    free(v9);
  }
  if (v11) {
    free(v11);
  }
  if ((v13 & 1) == 0) {
    CFRelease(v15);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v21;
}

__CFDictionary *IOPMCopyPreferencesOnFile()
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      int v2 = off_1E5489660[i];
      CFDictionaryRef v3 = copyPreferencesForSrc(v2);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (v3 && CFGetTypeID(v3) == TypeID)
      {
        CFDictionarySetValue(Mutable, v2, v3);
        CFRelease(v3);
      }
    }
  }
  return Mutable;
}

__CFDictionary *IOPMCopyPMPreferences()
{
  uint64_t v0 = copyPreferencesForSrc(@"AC Power");
  CFStringRef v1 = copyPreferencesForSrc(@"Battery Power");
  int v2 = copyPreferencesForSrc(@"UPS Power");
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    SystemProvidedPreferences = getSystemProvidedPreferences();
    if (SystemProvidedPreferences)
    {
      CFDictionaryRef v5 = SystemProvidedPreferences;
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(SystemProvidedPreferences, @"AC Power");
      if (Value)
      {
        CFDictionaryRef v7 = Value;
        CFDictionaryRef v8 = (const __CFDictionary *)CFDictionaryGetValue(v5, @"Battery Power");
        if (v8)
        {
          CFDictionaryRef v9 = v8;
          CFDictionaryRef v10 = (const __CFDictionary *)CFDictionaryGetValue(v5, @"Battery Power");
          if (v10)
          {
            CFDictionaryRef v11 = v10;
            if (v0)
            {
              CFIndex Count = CFDictionaryGetCount(v0);
              MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(0, Count, v0);
            }
            else
            {
              MutableCFSetRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            }
            uint64_t v14 = MutableCopy;
            if (MutableCopy)
            {
              mergeDictIntoMutable(MutableCopy, v7, 0);
              CFDictionarySetValue(Mutable, @"AC Power", v14);
              CFRelease(v14);
              if (v1)
              {
                CFIndex v15 = CFDictionaryGetCount(v1);
                stat v16 = CFDictionaryCreateMutableCopy(0, v15, v1);
              }
              else
              {
                stat v16 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              }
              CFDictionaryRef v17 = v16;
              if (v16)
              {
                mergeDictIntoMutable(v16, v9, 0);
                CFDictionarySetValue(Mutable, @"Battery Power", v17);
                CFRelease(v17);
                if (v2)
                {
                  CFIndex v18 = CFDictionaryGetCount(v2);
                  CFDictionaryRef v19 = CFDictionaryCreateMutableCopy(0, v18, v2);
                }
                else
                {
                  CFDictionaryRef v19 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                }
                CFDictionaryRef v20 = v19;
                if (v19)
                {
                  mergeDictIntoMutable(v19, v11, 0);
                  CFDictionarySetValue(Mutable, @"UPS Power", v20);
                  CFRelease(v20);
                  IOPMRemoveIrrelevantProperties(Mutable);
                }
              }
            }
          }
        }
      }
      CFRelease(v5);
    }
  }
  if (v0) {
    CFRelease(v0);
  }
  if (v1) {
    CFRelease(v1);
  }
  if (v2) {
    CFRelease(v2);
  }
  return Mutable;
}

__CFDictionary *getSystemProvidedPreferences()
{
  io_registry_entry_t v0 = getPMRootDomainRef_cached_root_domain;
  if (!getPMRootDomainRef_cached_root_domain)
  {
    io_registry_entry_t v0 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    getPMRootDomainRef_cached_root_domain = v0;
    if (!v0) {
      return 0;
    }
  }
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(v0, @"SystemPowerProfileOverrideDict", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (CFProperty && CFGetTypeID(CFProperty) == TypeID)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(CFProperty, @"AC Power");
    CFDictionaryRef v5 = (const __CFDictionary *)CFDictionaryGetValue(CFProperty, @"Battery Power");
    CFDictionaryRef v6 = (const __CFDictionary *)CFDictionaryGetValue(CFProperty, @"UPS Power");
    unint64_t v7 = (unint64_t)Value | (unint64_t)v5 | (unint64_t)v6;
    BOOL v8 = v7 != 0;
    if (v7)
    {
      if (Value) {
        BOOL v9 = v5 == 0;
      }
      else {
        BOOL v9 = 1;
      }
      BOOL v10 = v9 || v6 == 0;
      CFDictionaryRef theDict = v5;
      CFDictionaryRef cf = Value;
      CFDictionaryRef Copy = v6;
      if (v10)
      {
        int v11 = 0;
        io_registry_entry_t v12 = 0;
        char v13 = 0;
        CFDictionaryRef v14 = 0;
        MutableCFDictionaryRef Copy = 0;
        stat v16 = 0;
        goto LABEL_77;
      }
    }
    else
    {
      CFDictionaryRef cf = CFDictionaryCreateCopy(0, CFProperty);
      CFDictionaryRef theDict = CFDictionaryCreateCopy(0, CFProperty);
      CFDictionaryRef Copy = CFDictionaryCreateCopy(0, CFProperty);
    }
    char v40 = 0;
    int v11 = !v8;
    overridesSet = 1;
  }
  else
  {
    CFDictionaryRef theDict = 0;
    CFDictionaryRef cf = 0;
    CFDictionaryRef Copy = 0;
    int v11 = 0;
    char v40 = 1;
  }
  CFDictionaryRef v17 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFIndex v18 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef v20 = CFDictionaryCreateMutable(0, 0, v17, v18);
  uint64_t v21 = CFDictionaryCreateMutable(0, 0, v17, v18);
  for (uint64_t i = 0; i != 81; i += 3)
  {
    CFStringRef v23 = CFStringCreateWithCString(0, (&defaultSettings)[i], 0);
    if (Mutable)
    {
      CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&defaultSettings + 8 * i + 12);
      CFDictionarySetValue(Mutable, v23, v24);
      CFRelease(v24);
    }
    if (v20)
    {
      CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &(&defaultSettings)[i + 1]);
      CFDictionarySetValue(v20, v23, v25);
      CFRelease(v25);
    }
    if (v21)
    {
      CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &(&defaultSettings)[i + 2]);
      CFDictionarySetValue(v21, v23, v26);
      CFRelease(v26);
    }
    CFRelease(v23);
  }
  if (Mutable) {
    CFDictionarySetValue(Mutable, @"Hibernate File", @"/var/vm/sleepimage");
  }
  if (v20) {
    CFDictionarySetValue(v20, @"Hibernate File", @"/var/vm/sleepimage");
  }
  if (v21) {
    CFDictionarySetValue(v21, @"Hibernate File", @"/var/vm/sleepimage");
  }
  BOOL v46 = 0;
  if (!IOPSGetSupportedPowerSources(0, &v46, 0) && v46)
  {
    int valuePtr = 3;
    CFNumberRef v27 = CFNumberCreate(v1, kCFNumberSInt32Type, &valuePtr);
    if (Mutable) {
      CFDictionarySetValue(Mutable, @"Hibernate Mode", v27);
    }
    if (v20) {
      CFDictionarySetValue(v20, @"Hibernate Mode", v27);
    }
    if (v21) {
      CFDictionarySetValue(v21, @"Hibernate Mode", v27);
    }
    CFRelease(v27);
    int v44 = 1;
    CFNumberRef v28 = CFNumberCreate(v1, kCFNumberSInt32Type, &v44);
    if (v28)
    {
      CFNumberRef v29 = v28;
      if (Mutable) {
        CFDictionarySetValue(Mutable, @"Standby Enabled", v28);
      }
      if (v20) {
        CFDictionarySetValue(v20, @"Standby Enabled", v29);
      }
      if (v21) {
        CFDictionarySetValue(v21, @"Standby Enabled", v29);
      }
      CFRelease(v29);
    }
  }
  long long v30 = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  io_registry_entry_t v12 = v30;
  if (v30)
  {
    CFDictionaryAddValue(v30, @"AC Power", v20);
    CFDictionaryAddValue(v12, @"Battery Power", Mutable);
    CFDictionaryAddValue(v12, @"UPS Power", v21);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (!v12)
  {
    stat v16 = 0;
    MutableCFDictionaryRef Copy = 0;
LABEL_68:
    CFDictionaryRef v14 = 0;
    goto LABEL_69;
  }
  CFDictionaryRef v31 = (const __CFDictionary *)CFDictionaryGetValue(v12, @"AC Power");
  MutableCFDictionaryRef Copy = v31;
  if (v31)
  {
    CFIndex Count = CFDictionaryGetCount(v31);
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, Count, MutableCopy);
    if (!MutableCopy)
    {
      stat v16 = 0;
      goto LABEL_68;
    }
  }
  CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(v12, @"Battery Power");
  CFDictionaryRef v14 = v33;
  if (v33)
  {
    CFIndex v34 = CFDictionaryGetCount(v33);
    CFDictionaryRef v14 = CFDictionaryCreateMutableCopy(0, v34, v14);
    if (!v14)
    {
      stat v16 = 0;
LABEL_69:
      char v13 = 0;
      if (!CFProperty) {
        goto LABEL_78;
      }
      goto LABEL_77;
    }
  }
  CFDictionaryRef v35 = (const __CFDictionary *)CFDictionaryGetValue(v12, @"UPS Power");
  if (v35)
  {
    CFDictionaryRef v36 = v35;
    CFIndex v37 = CFDictionaryGetCount(v35);
    char v13 = CFDictionaryCreateMutableCopy(0, v37, v36);
    if (!v13)
    {
      stat v16 = 0;
      if (!CFProperty) {
        goto LABEL_78;
      }
      goto LABEL_77;
    }
  }
  else
  {
    char v13 = 0;
  }
  if ((v40 & 1) == 0)
  {
    mergeDictIntoMutable(MutableCopy, cf, 1);
    mergeDictIntoMutable(v14, theDict, 1);
    mergeDictIntoMutable(v13, Copy, 1);
  }
  unsigned int v38 = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  stat v16 = v38;
  if (v38)
  {
    CFDictionaryAddValue(v38, @"AC Power", MutableCopy);
    CFDictionaryAddValue(v16, @"Battery Power", v14);
    CFDictionaryAddValue(v16, @"UPS Power", v13);
  }
  if (!CFProperty) {
    goto LABEL_78;
  }
LABEL_77:
  CFRelease(CFProperty);
LABEL_78:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v12)
  {
    CFRelease(v12);
    if ((v11 & 1) == 0) {
      return v16;
    }
  }
  else if (!v11)
  {
    return v16;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  return v16;
}

uint64_t comparePrefsToDefaults(const __CFDictionary *a1, const void *a2)
{
  xpc_object_t value = 0;
  if (!a1) {
    return 1;
  }
  CFIndex Count = CFDictionaryGetCount(a1);
  if (!Count) {
    return 1;
  }
  uint64_t v5 = Count;
  SystemProvidedPreferences = getSystemProvidedPreferences();
  CFDictionaryRef v7 = (const __CFDictionary *)CFDictionaryGetValue(SystemProvidedPreferences, a2);
  if (v7)
  {
    CFDictionaryRef v8 = v7;
    if (CFDictionaryGetCount(v7))
    {
      BOOL v9 = (const void **)malloc_type_malloc(8 * v5, 0x6004044C4A2DFuLL);
      BOOL v10 = (const void **)malloc_type_malloc(8 * v5, 0xC0040B8AA526DuLL);
      int v11 = v10;
      if (v9 && v10)
      {
        CFDictionaryGetKeysAndValues(a1, v9, v10);
        if (v5 < 1)
        {
LABEL_12:
          uint64_t v14 = 1;
        }
        else
        {
          io_registry_entry_t v12 = v9;
          char v13 = v11;
          while (1)
          {
            xpc_object_t value = 0;
            if (!CFDictionaryGetValueIfPresent(v8, *v12, (const void **)&value) || !CFEqual(value, *v13)) {
              break;
            }
            ++v13;
            ++v12;
            if (!--v5) {
              goto LABEL_12;
            }
          }
          uint64_t v14 = 0;
        }
      }
      else
      {
        uint64_t v14 = 0;
        if (!v9)
        {
LABEL_19:
          if (v11) {
            free(v11);
          }
          goto LABEL_21;
        }
      }
      free(v9);
      goto LABEL_19;
    }
  }
  uint64_t v14 = 0;
LABEL_21:
  if (SystemProvidedPreferences) {
    CFRelease(SystemProvidedPreferences);
  }
  return v14;
}

uint64_t IOPMUsingDefaultPreferences(__CFString *a1)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
  {
    CFDictionaryRef v3 = copyPreferencesForSrc(a1);
    uint64_t v4 = comparePrefsToDefaults(v3, a1);
    goto LABEL_12;
  }
  uint64_t v5 = copyPreferencesForSrc(@"AC Power");
  CFDictionaryRef v6 = copyPreferencesForSrc(@"Battery Power");
  CFDictionaryRef v3 = copyPreferencesForSrc(@"UPS Power");
  if (!comparePrefsToDefaults(v5, @"AC Power")
    || !comparePrefsToDefaults(v6, @"Battery Power"))
  {
    uint64_t v4 = 0;
    if (!v5) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v4 = comparePrefsToDefaults(v3, @"UPS Power");
  if (v5) {
LABEL_9:
  }
    CFRelease(v5);
LABEL_10:
  if (v6) {
    CFRelease(v6);
  }
LABEL_12:
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

uint64_t IOPMRevertPMPreferences(const __CFArray *a1)
{
  int v2 = IOPMCopyPreferencesOnFile();
  if (!v2) {
    return 3758097097;
  }
  CFDictionaryRef v3 = v2;
  if (IOPMUsingDefaultPreferences(0))
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (a1 && (int Count = CFArrayGetCount(a1)) != 0)
    {
      if (Count >= 1)
      {
        CFIndex v6 = 0;
        uint64_t v7 = Count;
        do
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v6);
          CFTypeID TypeID = CFStringGetTypeID();
          if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == TypeID)
          {
            updatePrefsDict(v3, @"AC Power", ValueAtIndex, 0);
            updatePrefsDict(v3, @"Battery Power", ValueAtIndex, 0);
            updatePrefsDict(v3, @"UPS Power", ValueAtIndex, 0);
          }
          ++v6;
        }
        while (v7 != v6);
      }
      CFDictionaryRef v10 = v3;
    }
    else
    {
      CFDictionaryRef v10 = 0;
    }
    uint64_t v4 = IOPMSetPMPreferences(v10);
  }
  CFRelease(v3);
  return v4;
}

uint64_t IOPMSetPMPreferences(const __CFDictionary *a1)
{
  uint64_t v2 = 3758097084;
  if (getuid() && geteuid()) {
    return 3758097089;
  }
  if (!a1)
  {
    setPreferencesForSrc(@"AC Power", 0, 0);
    setPreferencesForSrc(@"Battery Power", 0, 0);
    if ((setPreferencesForSrc(@"UPS Power", 0, 1) & 1) == 0) {
      return v2;
    }
    goto LABEL_8;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"AC Power");
  CFDictionaryRef v4 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"Battery Power");
  CFDictionaryRef v5 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"UPS Power");
  char v6 = setPreferencesForSrc(@"AC Power", Value, ((unint64_t)v4 | (unint64_t)v5) == 0);
  char v7 = setPreferencesForSrc(@"Battery Power", v4, v5 == 0);
  int v8 = setPreferencesForSrc(@"UPS Power", v5, 1);
  if ((v6 & 1) != 0 || (v7 & 1) != 0 || v8)
  {
LABEL_8:
    notify_post("com.apple.system.powermanagement.prefschange");
    return 0;
  }
  return v2;
}

void updatePrefsDict(const __CFDictionary *a1, const void *a2, const void *a3, const void *a4)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFDictionaryRef v9 = Value;
    CFIndex Count = CFDictionaryGetCount(Value);
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, Count, v9);
    if (MutableCopy)
    {
      io_registry_entry_t v12 = MutableCopy;
      if (a4) {
        CFDictionarySetValue(MutableCopy, a3, a4);
      }
      else {
        CFDictionaryRemoveValue(MutableCopy, a3);
      }
      CFDictionarySetValue(a1, a2, v12);
      CFRelease(v12);
    }
  }
}

uint64_t IOPMSetPMPreference(const void *a1, const void *a2, __CFString *a3)
{
  uint64_t v6 = 3758097084;
  char v7 = IOPMCopyPreferencesOnFile();
  if (!v7) {
    return v6;
  }
  int v8 = v7;
  if (a3)
  {
    if (!CFDictionaryContainsKey(v7, a3))
    {
      uint64_t v6 = 3758097090;
      goto LABEL_11;
    }
    CFDictionaryRef v9 = v8;
    CFDictionaryRef v10 = a3;
    if (!a1)
    {
      CFDictionaryRemoveValue(v8, a3);
LABEL_9:
      uint64_t v6 = IOPMSetPMPreferences(v8);
LABEL_11:
      CFRelease(v8);
      return v6;
    }
LABEL_8:
    updatePrefsDict(v9, v10, a1, a2);
    goto LABEL_9;
  }
  if (a1)
  {
    updatePrefsDict(v7, @"AC Power", a1, a2);
    updatePrefsDict(v8, @"Battery Power", a1, a2);
    CFDictionaryRef v10 = @"UPS Power";
    CFDictionaryRef v9 = v8;
    goto LABEL_8;
  }
  CFRelease(v7);

  return IOPMSetPMPreferences(0);
}

uint64_t IOPMSetEnergyModePreference(const __CFString *a1, __CFString *cf1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 3758097084;
  if (!CFEqual(cf1, @"AC Power") && !CFEqual(cf1, @"Battery Power")
    || !CFEqual(a1, @"Automatic") && !CFEqual(a1, @"LowPowerMode") && !CFEqual(a1, @"HighPowerMode"))
  {
    return 3758097090;
  }
  if (CFEqual(a1, @"LowPowerMode"))
  {
    if ((IOPMFeatureIsAvailable(@"LowPowerMode", cf1) & 1) == 0) {
      return 3758097126;
    }
  }
  else if (CFEqual(a1, @"HighPowerMode") && !IOPMFeatureIsAvailable(@"HighPowerMode", cf1))
  {
    return 3758097126;
  }
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (mach_service)
  {
    char v7 = mach_service;
    xpc_connection_set_target_queue(mach_service, global_queue);
    xpc_connection_set_event_handler(v7, &__block_literal_global_2);
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    if (v8)
    {
      CFDictionaryRef v9 = v8;
      CFStringGetCString(a1, buffer, 32, 0x8000100u);
      xpc_dictionary_set_string(v9, "EnergyMode", buffer);
      CFStringGetCString(cf1, buffer, 32, 0x8000100u);
      xpc_dictionary_set_string(v9, "PowerSource", buffer);
      xpc_connection_resume(v7);
      xpc_connection_send_message(v7, v9);
      xpc_release(v9);
      uint64_t v4 = 0;
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      IOPMSetEnergyModePreference_cold_1();
    }
    xpc_release(v7);
  }
  return v4;
}

uint64_t IOPMFeatureIsAvailable(const void *a1, __CFString *a2)
{
  io_registry_entry_t v4 = getPMRootDomainRef_cached_root_domain;
  if (!getPMRootDomainRef_cached_root_domain)
  {
    io_registry_entry_t v4 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    getPMRootDomainRef_cached_root_domain = v4;
    if (!v4) {
      return 0;
    }
  }
  CFDictionaryRef CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(v4, @"Supported Features", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (!CFProperty) {
    return 0;
  }
  CFDictionaryRef v6 = CFProperty;
  if (CFEqual(a1, @"DarkWakeBackgroundTasks") || CFEqual(a1, @"SleepServices")) {
    uint64_t IsAvailableWithSupportedTable = 1;
  }
  else {
    uint64_t IsAvailableWithSupportedTable = IOPMFeatureIsAvailableWithSupportedTable(a1, a2, v6);
  }
  CFRelease(v6);
  return IsAvailableWithSupportedTable;
}

uint64_t IOPMWriteToPrefs(__CFString *a1, const void *a2, int a3, int a4)
{
  if (getuid() && geteuid()) {
    return 3758097089;
  }
  if (isA_GenericPref(a1)) {
    CFStringRef HostPrefsPath = @"com.apple.PowerManagement";
  }
  else {
    CFStringRef HostPrefsPath = (const __CFString *)getHostPrefsPath();
  }
  CFStringRef v10 = (const __CFString *)*MEMORY[0x1E4F1D3D0];
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
  CFPreferencesSetValue(a1, a2, HostPrefsPath, (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  if (a3)
  {
    int v12 = CFPreferencesSynchronize(HostPrefsPath, v10, v11);
    if (v12) {
      BOOL v13 = a4 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      if (!v12) {
        return 3758097084;
      }
    }
    else
    {
      notify_post("com.apple.system.powermanagement.prefschange");
    }
  }
  return 0;
}

uint64_t getPMRootDomainRef()
{
  uint64_t result = getPMRootDomainRef_cached_root_domain;
  if (!getPMRootDomainRef_cached_root_domain)
  {
    uint64_t result = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    getPMRootDomainRef_cached_root_domain = result;
  }
  return result;
}

uint64_t IOPMFeatureIsAvailableWithSupportedTable(const void *a1, __CFString *a2, const __CFDictionary *a3)
{
  if (a2) {
    CFDictionaryRef v3 = a2;
  }
  else {
    CFDictionaryRef v3 = @"AC Power";
  }
  if (!a3) {
    return 0;
  }
  if (CFEqual(a1, @"Display Sleep Timer")
    || CFEqual(a1, @"System Sleep Timer")
    || CFEqual(a1, @"Disk Sleep Timer")
    || CFEqual(a1, @"TTYSPreventSleep")
    || CFEqual(a1, @"SleepDisabled")
    || CFEqual(a1, @"DestroyFVKeyOnStandby")
    || CFEqual(a1, @"UnifiedSleepSliderPref")
    || CFEqual(a1, @"PowerNap")
    || CFEqual(a1, @"SleepServices")
    || CFEqual(a1, @"Standby Enabled"))
  {
    return 1;
  }
  if (CFEqual(a1, @"RestartAfterKernelPanic") || CFEqual(a1, @"Sleep On Power Button")) {
    return 0;
  }
  if (CFEqual(a1, @"ReduceBrightness"))
  {
    __int16 v8 = 0;
    IOPSGetSupportedPowerSources(0, (BOOL *)&v8 + 1, (BOOL *)&v8);
    return HIBYTE(v8) && !CFEqual(v3, @"AC Power")
        || (_BYTE)v8 && CFDictionaryGetValue(a3, @"DisplayDims") && !CFEqual(v3, @"AC Power");
  }
  if (CFEqual(a1, @"Carrier Mode")
    || CFEqual(a1, @"Carrier Mode Low Voltage")
    || CFEqual(a1, @"Carrier Mode High Voltage"))
  {
    return 1;
  }
  uint64_t result = (uint64_t)supportedNameForPMName(a1);
  if (result)
  {
    char v7 = (const void *)result;
    if (CFEqual((CFTypeRef)result, @"Hibernation") && overridesSet != 1) {
      return 0;
    }
    uint64_t result = (uint64_t)CFDictionaryGetValue(a3, v7);
    if (result)
    {
      return featureSupportsPowerSource((const __CFNumber *)result, v3);
    }
  }
  return result;
}

__CFString *supportedNameForPMName(const void *a1)
{
  if (CFEqual(a1, @"ReduceBrightness") || CFEqual(a1, @"Display Sleep Uses Dim")) {
    return @"DisplayDims";
  }
  if (CFEqual(a1, @"Wake On LAN") || CFEqual(a1, @"PrioritizeNetworkReachabilityOverSleep")) {
    return @"WakeOnMagicPacket";
  }
  if (CFEqual(a1, @"Mobile Motion Module")) {
    return @"MobileMotionModule";
  }
  if (CFEqual(a1, @"Hibernate Mode")
    || CFEqual(a1, @"Hibernate Free Ratio")
    || CFEqual(a1, @"Hibernate Free Time")
    || CFEqual(a1, @"Hibernate File"))
  {
    return @"Hibernation";
  }
  int v3 = CFEqual(a1, @"Hibernation");
  uint64_t result = @"Hibernation";
  if (!v3)
  {
    if (CFEqual(a1, @"Standby Enabled")
      || CFEqual(a1, @"Standby Delay")
      || CFEqual(a1, @"High Standby Delay")
      || CFEqual(a1, @"Standby Battery Threshold"))
    {
      return @"DeepSleep";
    }
    else if (CFEqual(a1, @"AutoPowerOff Enabled") || CFEqual(a1, @"AutoPowerOff Delay"))
    {
      return @"AutoPowerOff";
    }
    else if (CFEqual(a1, @"ProximityDarkWake"))
    {
      return @"ProximityWake";
    }
    else if (CFEqual(a1, @"Carrier Mode"))
    {
      return @"CarrierChargingMode";
    }
    else
    {
      int v4 = CFEqual(a1, @"Carrier Mode High Voltage");
      uint64_t result = @"CarrierChargingMode";
      if (!v4)
      {
        if (CFEqual(a1, @"Carrier Mode Low Voltage")) {
          return @"CarrierChargingMode";
        }
        else {
          return (__CFString *)a1;
        }
      }
    }
  }
  return result;
}

uint64_t featureSupportsPowerSource(const __CFNumber *a1, const void *a2)
{
  uint64_t valuePtr = 0;
  CFTypeID TypeID = CFNumberGetTypeID();
  if (a1)
  {
    if (CFGetTypeID(a1) == TypeID)
    {
      CFNumberGetValue(a1, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    }
    else
    {
      CFTypeID v5 = CFArrayGetTypeID();
      if (CFGetTypeID(a1) == v5)
      {
        uint64_t Count = CFArrayGetCount(a1);
        if (Count)
        {
          int v7 = 0;
          CFIndex v8 = 0;
          do
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, v8);
            CFTypeID v10 = CFNumberGetTypeID();
            if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == v10)
            {
              CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
              v7 |= valuePtr;
              HIDWORD(valuePtr) = v7;
            }
            ++v8;
          }
          while (Count != v8);
        }
      }
    }
  }
  else
  {
    CFArrayGetTypeID();
  }
  if (!a2) {
    return HIDWORD(valuePtr) != 0;
  }
  if (CFEqual(@"AC Power", a2)) {
    return BYTE4(valuePtr) & 1;
  }
  if (CFEqual(@"Battery Power", a2)) {
    return (BYTE4(valuePtr) >> 1) & 1;
  }
  uint64_t result = CFEqual(@"UPS Power", a2);
  if (result) {
    return (BYTE4(valuePtr) >> 2) & 1;
  }
  return result;
}

void IOPMRemoveIrrelevantProperties(const __CFDictionary *a1)
{
  io_registry_entry_t v2 = getPMRootDomainRef_cached_root_domain;
  if (getPMRootDomainRef_cached_root_domain
    || (io_registry_entry_t v2 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain"),
        (getPMRootDomainRef_cached_root_domain = v2) != 0))
  {
    CFDictionaryRef CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(v2, @"Supported Features", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  }
  else
  {
    CFDictionaryRef CFProperty = 0;
  }
  int Count = CFDictionaryGetCount(a1);
  CFTypeID v5 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  CFDictionaryRef v6 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  int v7 = v6;
  if (!v5 || !v6) {
    goto LABEL_40;
  }
  int v8 = checkPowerSourceSupported(@"Battery Power");
  char v9 = checkPowerSourceSupported(@"UPS Power");
  CFDictionaryGetKeysAndValues(a1, v5, v7);
  if (Count < 1)
  {
LABEL_41:
    free(v5);
    goto LABEL_42;
  }
  CFNumberRef v24 = v7;
  CFNumberRef v25 = 0;
  CFNumberRef v26 = v5;
  keys = 0;
  do
  {
    int v10 = Count--;
    CFStringRef v11 = &v5[v10 - 1];
    while (1)
    {
      if (CFEqual(*v11, @"Battery Power")) {
        int v12 = v8;
      }
      else {
        int v12 = 1;
      }
      if (v12 != 1 || (!CFEqual(*v11, @"UPS Power") ? (char v13 = 1) : (char v13 = v9), (v13 & 1) == 0))
      {
        CFDictionaryRemoveValue(a1, *v11);
LABEL_24:
        CFTypeID v5 = v26;
        goto LABEL_25;
      }
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, *v11);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == TypeID)
        {
          MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, Value);
          if (MutableCopy) {
            break;
          }
        }
      }
      --Count;
      --v11;
      BOOL v17 = __OFSUB__(v10--, 1);
      if ((v10 < 0) ^ v17 | (v10 == 0))
      {
        CFTypeID v5 = v26;
        goto LABEL_36;
      }
    }
    CFMutableDictionaryRef v18 = MutableCopy;
    CFDictionarySetValue(a1, *v11, MutableCopy);
    CFRelease(v18);
    int v22 = CFDictionaryGetCount(v18);
    keys = (void **)malloc_type_malloc(8 * v22, 0x6004044C4A2DFuLL);
    CFDictionaryRef v19 = (const void **)malloc_type_malloc(8 * v22, 0x6004044C4A2DFuLL);
    CFNumberRef v25 = v19;
    if (!keys || !v19) {
      goto LABEL_24;
    }
    CFDictionaryRef v23 = CFProperty;
    CFDictionaryGetKeysAndValues(v18, (const void **)keys, v19);
    if (v22 >= 1)
    {
      unint64_t v20 = v22 + 1;
      do
      {
        uint64_t v21 = (v20 - 2);
        if (!CFEqual(keys[v21], @"DarkWakeBackgroundTasks")
          && (IOPMFeatureIsAvailableWithSupportedTable(keys[v21], (__CFString *)*v11, v23) & 1) == 0)
        {
          CFDictionaryRemoveValue(v18, keys[v21]);
        }
        --v20;
      }
      while (v20 > 1);
    }
    free(keys);
    free(v25);
    keys = 0;
    CFNumberRef v25 = 0;
    CFDictionaryRef CFProperty = v23;
    CFTypeID v5 = v26;
LABEL_25:
    ;
  }
  while (v10 > 1);
LABEL_36:
  if (keys) {
    free(keys);
  }
  int v7 = v24;
  if (v25) {
    free(v25);
  }
LABEL_40:
  if (v5) {
    goto LABEL_41;
  }
LABEL_42:
  if (v7) {
    free(v7);
  }
  if (CFProperty)
  {
    CFRelease(CFProperty);
  }
}

uint64_t checkPowerSourceSupported(const void *a1)
{
  if (CFEqual(a1, @"AC Power")) {
    return 1;
  }
  __int16 v4 = 0;
  IOPSGetSupportedPowerSources(0, (BOOL *)&v4 + 1, (BOOL *)&v4);
  if (CFEqual(a1, @"Battery Power"))
  {
    int v3 = HIBYTE(v4);
  }
  else
  {
    uint64_t result = CFEqual(a1, @"UPS Power");
    if (!result) {
      return result;
    }
    int v3 = v4;
  }
  return v3 != 0;
}

uint64_t IOPMActivateSystemPowerSettings()
{
  return 3758097095;
}

CFPropertyListRef IOPMCopySystemPowerSettings()
{
  CFPropertyListRef v0 = CFPreferencesCopyValue(@"SystemPowerSettings", @"com.apple.PowerManagement", (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!v0) {
    return 0;
  }
  if (CFGetTypeID(v0) == TypeID) {
    return v0;
  }
  return 0;
}

uint64_t IOPMSetSystemPowerSetting()
{
  return 3758097084;
}

IOReturn IOPMSchedulePowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type)
{
  mach_port_t v20 = 0;
  IOReturn v21 = -536870212;
  CFTypeRef cf = 0;
  if (inputsValid(time_to_wake, type))
  {
    if (CFEqual(type, @"MaintenanceImmediate"))
    {
      CFDateRef v6 = time_to_wake;
      char v7 = 1;
LABEL_8:
      CFDataRef v8 = 0;
      IOReturn v21 = doAMaintenanceWake((uint64_t)v6, v7);
      goto LABEL_9;
    }
    if (CFEqual(type, @"SleepServiceImmediate"))
    {
      CFDateRef v6 = time_to_wake;
      char v7 = 2;
      goto LABEL_8;
    }
    if (CFEqual(type, @"WakeImmediate"))
    {
      int v10 = @"wake";
LABEL_20:
      tellClockController(v10, (uint64_t)time_to_wake);
      CFDataRef v8 = 0;
      IOReturn v21 = 0;
      goto LABEL_9;
    }
    if (CFEqual(type, @"PowerOnImmediate"))
    {
      int v10 = @"poweron";
      goto LABEL_20;
    }
    if (CFEqual(type, @"WakeRelativeToSleep") || CFEqual(type, @"PowerRelativeToShutdown"))
    {
      if (time_to_wake)
      {
        double Current = CFAbsoluteTimeGetCurrent();
        int valuePtr = (int)MEMORY[0x18C12FFE0](time_to_wake) - (int)Current;
        if (valuePtr < 1) {
          return -536870162;
        }
      }
      else
      {
        int valuePtr = 0;
      }
      CFNumberRef v12 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      if (v12)
      {
        CFNumberRef v13 = v12;
        IOReturn v21 = _setRootDomainProperty(type, v12);
        CFRelease(v13);
      }
LABEL_29:
      CFDataRef v8 = 0;
      goto LABEL_9;
    }
    if (_pm_connect(&v20))
    {
      CFDataRef v8 = 0;
      IOReturn v21 = -536870199;
      goto LABEL_9;
    }
    IOReturn v21 = _IOPMCreatePowerOnDictionary(time_to_wake, (__CFString *)my_id, type, (__CFDictionary **)&cf);
    if (v21) {
      goto LABEL_29;
    }
    CFDataRef Data = CFPropertyListCreateData(0, cf, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    CFDataRef v8 = Data;
    if (Data)
    {
      mach_port_t v15 = v20;
      BytePtr = CFDataGetBytePtr(Data);
      int Length = CFDataGetLength(v8);
      if (io_pm_schedule_power_event(v15, (uint64_t)BytePtr, Length, 1, &v21)) {
        IOReturn v21 = -536870199;
      }
      notify_post("com.apple.system.IOPMSchedulePowerEventNotification");
      goto LABEL_9;
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  IOReturn v21 = -536870206;
LABEL_9:
  if (v20) {
    _pm_disconnect();
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v21;
}

uint64_t doAMaintenanceWake(uint64_t a1, char a2)
{
  kern_return_t v11;
  BOOL v12;
  io_connect_t connect;
  size_t outputStructCnt;
  int outputStruct;
  SInt32 inputStruct;
  SInt8 month;
  SInt8 day;
  SInt8 hour;
  SInt8 minute;
  int second;

  uint64_t v4 = 3758097084;
  uint64_t outputStruct = 0;
  outputStructCnt = 4;
  io_connect_t connect = 0;
  CFTimeZoneRef v5 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
  if (v5)
  {
    CFTimeZoneRef v6 = v5;
    CFAbsoluteTime v7 = MEMORY[0x18C12FFE0](a1);
    CFGregorianDate GregorianDate = CFAbsoluteTimeGetGregorianDate(v7, v6);
    CFRelease(v6);
    inputStruct = GregorianDate.year;
    month = GregorianDate.month;
    day = GregorianDate.day;
    hour = GregorianDate.hour;
    minute = GregorianDate.minute;
    second = (int)GregorianDate.second;
    BYTE1(second) = a2;
    io_registry_entry_t v9 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
    if (v9)
    {
      io_object_t v10 = v9;
      CFStringRef v11 = IOServiceOpen(v9, *MEMORY[0x1E4F14960], 0, &connect);
      if (!v11)
      {
        CFStringRef v11 = IOConnectCallStructMethod(connect, 8u, &inputStruct, 0xCuLL, &outputStruct, &outputStructCnt);
        IOServiceClose(connect);
      }
      IOObjectRelease(v10);
      CFNumberRef v12 = outputStruct != 0;
    }
    else
    {
      CFNumberRef v12 = 0;
      CFStringRef v11 = -1;
    }
    if (v11) {
      CFNumberRef v12 = 1;
    }
    if (v12) {
      return 3758097084;
    }
    else {
      return 0;
    }
  }
  return v4;
}

void tellClockController(const void *a1, uint64_t a2)
{
  if (!a1) {
    return;
  }
  unint64_t valuePtr = 0;
  CFMutableArrayRef Mutable = CFDataCreateMutable(0, 12);
  CFDataSetLength(Mutable, 12);
  BytePtr = CFDataGetBytePtr(Mutable);
  *(void *)BytePtr = 0;
  *((_DWORD *)BytePtr + 2) = 0;
  if (a2)
  {
    CFTimeZoneRef v6 = (UInt8 *)BytePtr;
    CFAbsoluteTime v7 = MEMORY[0x18C12FFE0](a2);
    CFTimeZoneRef v8 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
    CFGregorianDate GregorianDate = CFAbsoluteTimeGetGregorianDate(v7, v8);
    CFRelease(v8);
    char v10 = llround(GregorianDate.second);
    if (v10 == 60) {
      char v10 = 59;
    }
    v6[8] = v10;
    void v6[7] = GregorianDate.minute;
    void v6[6] = GregorianDate.hour;
    _OWORD v6[5] = GregorianDate.day;
    v6[4] = GregorianDate.month;
    *(_DWORD *)CFTimeZoneRef v6 = GregorianDate.year;
  }
  if (CFEqual(a1, @"wake")) {
    CFStringRef v11 = @"WakeByCalendarDate";
  }
  else {
    CFStringRef v11 = @"PowerByCalendarDate";
  }
  if (_setRootDomainProperty(v11, Mutable)) {
    goto LABEL_10;
  }
  if (!a2)
  {
    unint64_t valuePtr = 0;
LABEL_20:
    CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
    if (v12)
    {
      if (CFEqual(a1, @"wake")) {
        CFStringRef v14 = @"wake";
      }
      else {
        CFStringRef v14 = @"poweron";
      }
      _setRootDomainProperty(v14, v12);
    }
    goto LABEL_11;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  unint64_t valuePtr = llround(MEMORY[0x18C12FFE0](a2) - Current);
  if ((valuePtr & 0x8000000000000000) == 0) {
    goto LABEL_20;
  }
LABEL_10:
  CFNumberRef v12 = 0;
LABEL_11:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v12) {
    CFRelease(v12);
  }
}

uint64_t _setRootDomainProperty(const __CFString *a1, const void *a2)
{
  io_registry_entry_t v4 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v4) {
    return 3758097084;
  }
  io_object_t v5 = v4;
  uint64_t v6 = IORegistryEntrySetCFProperty(v4, a1, a2);
  IOObjectRelease(v5);
  return v6;
}

uint64_t IOPMCancelAllScheduledPowerEvents()
{
  mach_port_t v1 = 0;
  unsigned int v2 = -536870199;
  if (_pm_connect(&v1)) {
    unsigned int v2 = -536870199;
  }
  else {
    io_pm_schedule_power_event(v1, 0, 0, 2, (int *)&v2);
  }
  if (v1) {
    _pm_disconnect();
  }
  return v2;
}

CFArrayRef IOPMCopyScheduledPowerEvents(void)
{
  CFArrayRef v1 = 0;
  _copyPMServerObject(4u, 0, 0, (CFPropertyListRef *)&v1);
  return v1;
}

CFTypeRef IOHIDSessionFilterCreate(const __CFAllocator *a1, CFBundleRef bundle, const __CFUUID *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CFStringRef Identifier = CFBundleGetIdentifier(bundle);
  CStringPtr = CFStringGetCStringPtr(Identifier, 0x8000100u);
  CFAbsoluteTime v7 = _IOHIDLog();
  if (os_signpost_enabled(v7))
  {
    *(_DWORD *)long long buf = 136315138;
    CFNumberRef v25 = CStringPtr;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v7, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilter", "%s", buf, 0xCu);
  }
  uint64_t Private = __IOHIDSessionFilterCreatePrivate(a1);
  if (!Private)
  {
    CFNumberRef v12 = 0;
    goto LABEL_23;
  }
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
  CFUUIDRef v10 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], 0x7Fu, 0x1Au, 0x3Au, 0xE6u, 0x3Eu, 0x3Du, 0x47u, 0xAu, 0xBDu, 0x15u, 0xA2u, 0xDDu, 0x7Eu, 0x1Bu, 0xB7u, 0x19u);
  CFStringRef v11 = CFPlugInInstanceCreate(a1, a3, v10);
  CFNumberRef v12 = v11;
  if (!v11)
  {
LABEL_23:
    CFTypeRef v21 = 0;
    goto LABEL_15;
  }
  CFNumberRef v13 = *(unsigned int (**)(void *, void, void, uint64_t))(*(void *)v11 + 8);
  CFUUIDRef v14 = CFUUIDGetConstantUUIDWithBytes(v9, 0x19u, 0xD7u, 0x74u, 0x41u, 0xBBu, 0xC4u, 0x45u, 0x11u, 0x91u, 0x49u, 0x60u, 0x57u, 0x2Au, 0xBu, 1u, 0x5Cu);
  CFUUIDBytes v15 = CFUUIDGetUUIDBytes(v14);
  stat v16 = (void *)(Private + 24);
  if (v13(v12, *(void *)&v15.byte0, *(void *)&v15.byte8, Private + 24)) {
    *stat v16 = 0;
  }
  BOOL v17 = *(unsigned int (**)(void *, void, void, uint64_t))(*(void *)v12 + 8);
  CFUUIDRef v18 = CFUUIDGetConstantUUIDWithBytes(v9, 0x3Du, 0xC3u, 0x5Au, 0xA6u, 0xD3u, 0x5Cu, 0x44u, 0x5Bu, 0x9Au, 0x59u, 0xCAu, 3u, 0xDAu, 0x40u, 0x8Bu, 0x97u);
  CFUUIDBytes v19 = CFUUIDGetUUIDBytes(v18);
  mach_port_t v20 = (void *)(Private + 16);
  if (v17(v12, *(void *)&v19.byte0, *(void *)&v19.byte8, Private + 16))
  {
    *mach_port_t v20 = 0;
  }
  else if (*v20)
  {
    goto LABEL_12;
  }
  if (!*v16) {
    goto LABEL_23;
  }
LABEL_12:
  *(void *)(Private + 40) = Identifier;
  if (Identifier) {
    CFRetain(Identifier);
  }
  *(unsigned char *)(Private + 48) = 1;
  CFTypeRef v21 = CFRetain((CFTypeRef)Private);
LABEL_15:
  int v22 = _IOHIDLog();
  if (os_signpost_enabled(v22))
  {
    *(_DWORD *)long long buf = 136315138;
    CFNumberRef v25 = CStringPtr;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v22, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilter", "%s", buf, 0xCu);
  }
  if (v12) {
    (*(void (**)(void *))(*(void *)v12 + 24))(v12);
  }
  if (Private) {
    CFRelease((CFTypeRef)Private);
  }
  return v21;
}

uint64_t __IOHIDSessionFilterCreatePrivate(const __CFAllocator *a1)
{
  if (!__kIOHIDSessionFilterTypeID) {
    pthread_once(&__systemFilterClientTypeInit, (void (*)(void))__IOHIDSessionFilterRegister);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v3 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 128) = 0;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(void *)(Instance + 32) = CFUUIDCreate(a1);
  }
  return v3;
}

uint64_t IOHIDSessionFilterCreateWithClass(const __CFAllocator *a1, objc_class *a2, uint64_t a3, char a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  CFTimeZoneRef v8 = _IOHIDLog();
  if (os_signpost_enabled(v8))
  {
    int v48 = 136315138;
    Name = class_getName(a2);
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v8, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilterClass", "%s", (uint8_t *)&v48, 0xCu);
  }
  id v9 = objc_msgSend(a2, sel_getUid("alloc"));
  if (!v9) {
    goto LABEL_31;
  }
  if (!objc_msgSend(v9, sel_getUid("initWithSession:"), a3))
  {
    CFNumberRef v24 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      IOHIDSessionFilterCreateWithClass_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
    }
    uint64_t v12 = 0;
    id v9 = 0;
    goto LABEL_32;
  }
  Protocol = objc_getProtocol("HIDSessionFilter");
  if (!Protocol)
  {
    long long v32 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      IOHIDSessionFilterCreateWithClass_cold_2(v32, v33, v34, v35, v36, v37, v38, v39);
    }
    goto LABEL_31;
  }
  if (!class_conformsToProtocol(a2, Protocol))
  {
    char v40 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      IOHIDSessionFilterCreateWithClass_cold_3(v40, v41, v42, v43, v44, v45, v46, v47);
    }
LABEL_31:
    uint64_t v12 = 0;
    goto LABEL_32;
  }
  uint64_t Private = __IOHIDSessionFilterCreatePrivate(a1);
  uint64_t v12 = Private;
  if (!Private)
  {
LABEL_32:
    char v19 = 1;
    goto LABEL_17;
  }
  *(void *)(Private + 56) = v9;
  *(void *)(Private + 64) = sel_getUid("propertyForKey:");
  *(void *)(v12 + 72) = sel_getUid("setProperty:forKey:");
  *(void *)(v12 + 80) = sel_getUid("filterEvent:forService:");
  *(void *)(v12 + 88) = sel_getUid("activate");
  CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)v12);
  ClassName = object_getClassName(*(id *)(v12 + 56));
  *(void *)(v12 + 40) = CFStringCreateWithCString(v13, ClassName, 0);
  Uid = sel_getUid("cancel");
  if (class_respondsToSelector(a2, Uid)) {
    *(void *)(v12 + 96) = sel_getUid("cancel");
  }
  stat v16 = sel_getUid("serviceNotification:added:");
  if (class_respondsToSelector(a2, v16)) {
    *(void *)(v12 + 104) = sel_getUid("serviceNotification:added:");
  }
  BOOL v17 = sel_getUid("setDispatchQueue:");
  if (class_respondsToSelector(a2, v17)) {
    *(void *)(v12 + 112) = sel_getUid("setDispatchQueue:");
  }
  CFUUIDRef v18 = sel_getUid("filterEvent:toConnection:fromService:");
  if (class_respondsToSelector(a2, v18)) {
    *(void *)(v12 + 120) = sel_getUid("filterEvent:toConnection:fromService:");
  }
  char v19 = 0;
  *(unsigned char *)(v12 + 48) = a4;
LABEL_17:
  mach_port_t v20 = _IOHIDLog();
  if (os_signpost_enabled(v20))
  {
    CFTypeRef v21 = class_getName(a2);
    int v48 = 136315138;
    Name = v21;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v20, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "CreateSessionFilterClass", "%s", (uint8_t *)&v48, 0xCu);
  }
  char v22 = v19 ^ 1;
  if (!v9) {
    char v22 = 1;
  }
  if ((v22 & 1) == 0) {
    CFRelease(v9);
  }
  return v12;
}

uint64_t IOHIDSessionFilterGetTypeID()
{
  uint64_t result = __kIOHIDSessionFilterTypeID;
  if (!__kIOHIDSessionFilterTypeID)
  {
    pthread_once(&__systemFilterClientTypeInit, (void (*)(void))__IOHIDSessionFilterRegister);
    return __kIOHIDSessionFilterTypeID;
  }
  return result;
}

uint64_t __IOHIDSessionFilterRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDSessionFilterCFTypeID TypeID = result;
  return result;
}

BOOL IOHIDSessionFilterGetType(uint64_t a1)
{
  return *(void *)(a1 + 16) == 0;
}

uint64_t IOHIDSessionFilterFilterCopyEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 16);
  if ((!v6 || (CFAbsoluteTime v7 = *(uint64_t (**)(void))(*(void *)v6 + 40)) == 0)
    && ((uint64_t v8 = *(void *)(a1 + 24)) == 0 || (v7 = *(uint64_t (**)(void))(*(void *)v8 + 40)) == 0)
    || (uint64_t result = v7()) == 0)
  {
    if (*(unsigned char *)(a1 + 48))
    {
      CFUUIDRef v10 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        int Type = IOHIDEventGetType(a3);
        if (a2) {
          uint64_t SenderID = _IOHIDServiceGetSenderID(a2);
        }
        else {
          uint64_t SenderID = 0;
        }
        uint64_t v13 = *(void *)(a1 + 32);
        v14[0] = 67109634;
        v14[1] = Type;
        __int16 v15 = 2048;
        uint64_t v16 = SenderID;
        __int16 v17 = 2112;
        uint64_t v18 = v13;
        _os_log_impl(&dword_18B46C000, v10, OS_LOG_TYPE_INFO, "Event filtered type:%d service:0x%llx session filter:%@", (uint8_t *)v14, 0x1Cu);
      }
    }
    return 0;
  }
  return result;
}

uint64_t IOHIDSessionFilterCopyEvent(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 48);
    if (v3) {
      return v3();
    }
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4 && (uint64_t v3 = *(uint64_t (**)(void))(*(void *)v4 + 48)) != 0) {
    return v3();
  }
  else {
    return 0;
  }
}

uint64_t IOHIDSessionFilterOpen(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 56)) != 0) {
    return v2();
  }
  else {
    return 1;
  }
}

id IOHIDSessionFilterClose(id result)
{
  uint64_t v1 = *((void *)result + 2);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 64);
    if (v2) {
      return (id)v2(*((void *)result + 2));
    }
  }
  if (*((void *)result + 7))
  {
    uint64_t v3 = (const char *)*((void *)result + 12);
    if (v3) {
      return [*((id *)result + 7) v3];
    }
  }
  return result;
}

id IOHIDSessionFilterScheduleWithDispatchQueue(void *a1, dispatch_object_t object)
{
  uint64_t v4 = a1[16];
  if (v4)
  {
    dispatch_release(v4);
    a1[16] = 0;
  }
  if (object)
  {
    a1[16] = object;
    dispatch_retain(object);
  }
  uint64_t v5 = a1[2];
  if (v5 && (uint64_t v6 = *(uint64_t (**)(void))(*(void *)v5 + 104)) != 0)
  {
    return (id)v6();
  }
  else
  {
    id result = (id)a1[7];
    if (result)
    {
      uint64_t v8 = (const char *)a1[14];
      if (v8)
      {
        objc_msgSend(result, v8, object);
        id result = (id)a1[7];
      }
      id v9 = (const char *)a1[11];
      return [result v9];
    }
  }
  return result;
}

void IOHIDSessionFilterUnscheduleFromDispatchQueue(uint64_t a1, dispatch_object_t object)
{
  if (*(dispatch_object_t *)(a1 + 128) == object)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      uint64_t v4 = *(void (**)(void))(*(void *)v3 + 112);
      if (v4)
      {
        v4();
        object = *(dispatch_object_t *)(a1 + 128);
      }
    }
    if (object)
    {
      dispatch_release(object);
      *(void *)(a1 + 128) = 0;
    }
  }
}

void __IOHIDSessionFilterRelease(void *a1)
{
  uint64_t v2 = a1[3];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[7];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = a1[16];
  if (v6) {
    dispatch_release(v6);
  }
  CFAbsoluteTime v7 = (const void *)a1[4];
  if (v7)
  {
    CFRelease(v7);
  }
}

CFStringRef __IOHIDSessionFilterCopyDebugDescription(void *a1)
{
  uint64_t v2 = (const void *)a1[7];
  if (v2) {
    CFStringRef v3 = CFCopyDescription(v2);
  }
  else {
    CFStringRef v3 = 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(a1);
  uint64_t v5 = &stru_1ED870660;
  if (v3) {
    uint64_t v5 = (__CFString *)v3;
  }
  CFStringRef v6 = CFStringCreateWithFormat(v4, 0, @"IOHIDSessionFilterRef uuid:%@ name:%@ %@", a1[4], a1[5], v5);
  if (v3) {
    CFRelease(v3);
  }
  return v6;
}

uint64_t IOPMScheduleRepeatingPowerEvent(const void *a1)
{
  uint64_t v2 = 3758097090;
  mach_port_t v10 = 0;
  unsigned int v11 = -536870212;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID) {
    return v2;
  }
  if (_pm_connect(&v10))
  {
    CFDataRef v4 = 0;
  }
  else
  {
    CFDataRef Data = CFPropertyListCreateData(0, a1, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    CFDataRef v4 = Data;
    if (!Data)
    {
      unsigned int v11 = -536870206;
      goto LABEL_6;
    }
    mach_port_t v7 = v10;
    BytePtr = CFDataGetBytePtr(Data);
    int Length = CFDataGetLength(v4);
    if (!io_pm_schedule_repeat_event(v7, (uint64_t)BytePtr, Length, 1, (int *)&v11)) {
      goto LABEL_6;
    }
  }
  unsigned int v11 = -536870199;
LABEL_6:
  if (v10) {
    _pm_disconnect();
  }
  if (v4) {
    CFRelease(v4);
  }
  return v11;
}

CFPropertyListRef IOPMCopyRepeatingPowerEvents()
{
  CFPropertyListRef v1 = 0;
  _copyPMServerObject(5u, 0, 0, &v1);
  return v1;
}

uint64_t IOPMCancelAllRepeatingPowerEvents()
{
  int v1 = 0;
  unsigned int v2 = -536870212;
  if (_pm_connect(&v1))
  {
    return -536870199;
  }
  else
  {
    if (io_pm_cancel_repeat_events(v1, &v2)) {
      unsigned int v2 = -536870199;
    }
    if (v1) {
      _pm_disconnect();
    }
  }
  return v2;
}

uint64_t IOPMSetUPSShutdownLevels(__CFString *a1, const void *a2)
{
  uint64_t v2 = 3758097090;
  BOOL v7 = 0;
  if (a2)
  {
    int valid = _validUPSShutdownSettings(a2);
    if (a1)
    {
      if (valid && _validUPSIdentifier(a1))
      {
        IOPSGetSupportedPowerSources(0, 0, &v7);
        if (v7) {
          return IOPMWriteToPrefs(a1, a2, 1, 1);
        }
        else {
          return 3758097088;
        }
      }
    }
  }
  return v2;
}

uint64_t _validUPSShutdownSettings(const void *a1)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!a1) {
    return 0;
  }
  if (CFGetTypeID(a1) != TypeID) {
    return 0;
  }
  CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"UPSShutdownAtLevel");
  if (Value)
  {
    CFDataRef v4 = Value;
    CFTypeID v5 = CFDictionaryGetTypeID();
    if (CFGetTypeID(v4) != v5) {
      return 0;
    }
    CFStringRef v6 = CFDictionaryGetValue((CFDictionaryRef)v4, @"Value");
    BOOL v7 = CFDictionaryGetValue((CFDictionaryRef)v4, @"Enabled");
    CFTypeID v8 = CFNumberGetTypeID();
    if (!v6) {
      return 0;
    }
    if (CFGetTypeID(v6) != v8) {
      return 0;
    }
    CFTypeID v9 = CFBooleanGetTypeID();
    if (!v7 || CFGetTypeID(v7) != v9) {
      return 0;
    }
  }
  mach_port_t v10 = CFDictionaryGetValue((CFDictionaryRef)a1, @"UPSShutdownAfterMinutes");
  if (v10)
  {
    unsigned int v11 = v10;
    CFTypeID v12 = CFDictionaryGetTypeID();
    if (CFGetTypeID(v11) != v12) {
      return 0;
    }
    uint64_t v13 = CFDictionaryGetValue((CFDictionaryRef)v11, @"Value");
    CFUUIDRef v14 = CFDictionaryGetValue((CFDictionaryRef)v11, @"Enabled");
    CFTypeID v15 = CFNumberGetTypeID();
    if (!v13) {
      return 0;
    }
    if (CFGetTypeID(v13) != v15) {
      return 0;
    }
    CFTypeID v16 = CFBooleanGetTypeID();
    if (!v14 || CFGetTypeID(v14) != v16) {
      return 0;
    }
  }
  __int16 v17 = CFDictionaryGetValue((CFDictionaryRef)a1, @"UPSShutdownAtMinutesLeft");
  if (!v17) {
    return 1;
  }
  uint64_t v18 = v17;
  CFTypeID v19 = CFDictionaryGetTypeID();
  if (CFGetTypeID(v18) == v19
    && (mach_port_t v20 = CFDictionaryGetValue((CFDictionaryRef)v18, @"Value"),
        CFTypeRef v21 = CFDictionaryGetValue((CFDictionaryRef)v18, @"Enabled"),
        CFTypeID v22 = CFNumberGetTypeID(),
        v20)
    && CFGetTypeID(v20) == v22
    && (CFTypeID v23 = CFBooleanGetTypeID(), v21)
    && CFGetTypeID(v21) == v23)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

BOOL _validUPSIdentifier(const void *a1)
{
  CFTypeID TypeID = CFStringGetTypeID();
  return a1 && CFGetTypeID(a1) == TypeID && CFEqual(a1, @"UPSDefaultThresholds") != 0;
}

__CFDictionary *IOPMCopyUPSShutdownLevels(__CFString *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  BOOL v17 = 0;
  if (!a1) {
    return 0;
  }
  if (!_validUPSIdentifier(a1)) {
    return 0;
  }
  IOPSGetSupportedPowerSources(0, 0, &v17);
  if (!v17) {
    return 0;
  }
  CFPropertyListRef v2 = IOPMCopyFromPrefs(0, a1);
  CFStringRef v3 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (!v2)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable) {
      goto LABEL_6;
    }
LABEL_18:
    CFTypeID v12 = 0;
    if (!v2) {
      return v12;
    }
LABEL_19:
    CFRelease(v2);
    return v12;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v2);
  if (!Mutable) {
    goto LABEL_18;
  }
LABEL_6:
  CFDictionaryRef theDict = Mutable;
  CFTypeRef cf = v2;
  uint64_t v5 = 0;
  xpc_object_t value = 0;
  mach_port_t v20 = 0;
  CFTypeRef v21 = 0;
  CFAllocatorRef v6 = *v3;
  BOOL v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFTypeID v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFTypeID v9 = (const void *)*MEMORY[0x1E4F1CFC8];
  do
  {
    int valuePtr = 0;
    mach_port_t v10 = CFDictionaryCreateMutable(v6, 0, v7, v8);
    CFNumberRef v11 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(v10, @"Value", v11);
    CFRelease(v11);
    CFDictionarySetValue(v10, @"Enabled", v9);
    *(void **)((char *)&value + v5) = v10;
    v5 += 8;
  }
  while (v5 != 24);
  CFTypeID v12 = theDict;
  CFDictionaryAddValue(theDict, @"UPSShutdownAtLevel", value);
  CFDictionaryAddValue(theDict, @"UPSShutdownAfterMinutes", v20);
  CFDictionaryAddValue(theDict, @"UPSShutdownAtMinutesLeft", v21);
  for (uint64_t i = 0; i != 24; i += 8)
    CFRelease(*(void **)((char *)&value + i));
  if (!CFDictionaryGetCount(theDict) || (_validUPSShutdownSettings(theDict) & 1) == 0)
  {
    CFRelease(theDict);
    CFTypeID v12 = 0;
  }
  CFPropertyListRef v2 = cf;
  if (cf) {
    goto LABEL_19;
  }
  return v12;
}

IOReturn IONetworkOpen(io_object_t obj, io_connect_t *con)
{
  return IOServiceOpen(obj, *MEMORY[0x1E4F14960], 0xFF000001, con);
}

IOReturn IONetworkWriteData(io_connect_t conObj, IONDHandle dataHandle, UInt8 *srcBuf, UInt32 inSize)
{
  IOReturn v4 = -536870206;
  if (srcBuf && inSize)
  {
    uint64_t input = dataHandle;
    return IOConnectCallMethod(conObj, 1u, &input, 1u, srcBuf, inSize, 0, 0, 0, 0);
  }
  return v4;
}

IOReturn IONetworkReadData(io_connect_t conObj, IONDHandle dataHandle, UInt8 *destBuf, UInt32 *inOutSizeP)
{
  kern_return_t v4;
  size_t v7;
  uint64_t input;

  IOReturn v4 = -536870206;
  if (destBuf && inOutSizeP)
  {
    BOOL v7 = *inOutSizeP;
    uint64_t input = dataHandle;
    IOReturn v4 = IOConnectCallMethod(conObj, 2u, &input, 1u, 0, 0, 0, 0, destBuf, &v7);
    *inOutSizeP = v7;
  }
  return v4;
}

IOReturn IONetworkResetData(io_connect_t conObject, IONDHandle dataHandle)
{
  uint64_t input = dataHandle;
  return IOConnectCallScalarMethod(conObject, 0, &input, 1u, 0, 0);
}

IOReturn IONetworkGetDataCapacity(io_connect_t conObject, IONDHandle dataHandle, UInt32 *capacityP)
{
  if (!capacityP) {
    return -536870206;
  }
  uint64_t output = *capacityP;
  uint64_t input = dataHandle;
  uint32_t outputCnt = 1;
  IOReturn result = IOConnectCallScalarMethod(conObject, 3u, &input, 1u, &output, &outputCnt);
  *capacityP = output;
  return result;
}

IOReturn IONetworkGetDataHandle(io_connect_t conObject, const char *dataName, IONDHandle *dataHandleP)
{
  IOReturn result = -536870206;
  if (dataName)
  {
    if (dataHandleP)
    {
      size_t outputStructCnt = 4;
      size_t v7 = strlen(dataName);
      return IOConnectCallStructMethod(conObject, 4u, dataName, v7 + 1, dataHandleP, &outputStructCnt);
    }
  }
  return result;
}

IOReturn IONetworkGetPacketFiltersMask(io_connect_t connect, const io_name_t filterGroup, UInt32 *filtersMask, IOOptionBits options)
{
  kern_return_t ParentEntry;
  io_registry_entry_t v8;
  CFAllocatorRef v9;
  IOReturn v10;
  CFArrayRef v11;
  CFStringRef v12;
  CFStringEncoding SystemEncoding;
  CFStringRef v15;
  __CFString *v16;
  CFTypeRef v17;
  CFTypeID TypeID;
  CFTypeRef cf;
  io_service_t service;
  io_registry_entry_t parent[2];
  void *values;
  CFStringRef v23;
  uint64_t v24;
  CFRange v25;

  char v4 = options;
  CFNumberRef v24 = *MEMORY[0x1E4F143B8];
  service = 0;
  CFTypeRef cf = 0;
  values = 0;
  CFTypeID v23 = 0;
  *filtersMask = 0;
  ParentEntry = IOConnectGetService(connect, &service);
  if (ParentEntry) {
    goto LABEL_6;
  }
  CFTypeID v8 = service;
  if (v4)
  {
    parent[0] = 0;
    ParentEntry = IORegistryEntryGetParentEntry(service, "IOService", parent);
    if (ParentEntry)
    {
LABEL_6:
      mach_port_t v10 = ParentEntry;
      CFNumberRef v11 = 0;
      CFTypeID v12 = 0;
      goto LABEL_7;
    }
    IOObjectRelease(service);
    CFTypeID v8 = parent[0];
    service = parent[0];
  }
  CFTypeID v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  ParentEntry = IORegistryEntryCreateCFProperties(v8, (CFMutableDictionaryRef *)&cf, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (ParentEntry) {
    goto LABEL_6;
  }
  mach_port_t v10 = -536870211;
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  CFTypeID v15 = CFStringCreateWithCString(v9, filterGroup, SystemEncoding);
  CFTypeID v12 = v15;
  if (v15)
  {
    CFTypeID v16 = @"IOPacketFilters";
    if ((v4 & 1) == 0) {
      CFTypeID v16 = @"IORequiredPacketFilters";
    }
    values = v16;
    CFTypeID v23 = v15;
    CFNumberRef v11 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
    if (v11)
    {
      BOOL v17 = cf;
      CFTypeID TypeID = CFNumberGetTypeID();
      *(void *)parent = v17;
      v25.CFIndex length = CFArrayGetCount(v11);
      v25.location = 0;
      CFArrayApplyFunction(v11, v25, (CFArrayApplierFunction)GetDictionaryValueUsingKeysApplier, parent);
      if (*(void *)parent && CFGetTypeID(*(CFTypeRef *)parent) == TypeID && *(void *)parent)
      {
        CFNumberGetValue(*(CFNumberRef *)parent, kCFNumberSInt32Type, filtersMask);
        mach_port_t v10 = 0;
      }
      else
      {
        mach_port_t v10 = -536870160;
      }
    }
  }
  else
  {
    CFNumberRef v11 = 0;
  }
LABEL_7:
  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (service) {
    IOObjectRelease(service);
  }
  return v10;
}

IOReturn IONetworkSetPacketFiltersMask(io_connect_t connect, const io_name_t filterGroup, UInt32 filtersMask, IOOptionBits options)
{
  kern_return_t v6;
  CFAllocatorRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFStringEncoding SystemEncoding;
  CFStringRef v11;
  CFStringRef v12;
  CFArrayRef v13;
  CFArrayRef v14;
  CFIndex Count;
  CFDictionaryRef v16;
  const CFDictionaryKeyCallBacks *v17;
  const CFDictionaryValueCallBacks *v18;
  void *ValueAtIndex;
  CFDictionaryRef v21;
  CFDictionaryRef v22;
  UInt32 valuePtr;
  void *values[3];
  void *v26;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = -536870211;
  int valuePtr = filtersMask;
  size_t v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFTypeID v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  if (v8)
  {
    CFTypeID v9 = v8;
    CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
    CFNumberRef v11 = CFStringCreateWithCString(v7, filterGroup, SystemEncoding);
    if (!v11)
    {
      CFTypeID v16 = v9;
LABEL_20:
      CFRelease(v16);
      return v6;
    }
    CFTypeID v12 = v11;
    values[0] = @"IONetworkInterfaceProperties";
    values[1] = @"IORequiredPacketFilters";
    values[2] = (void *)v11;
    uint64_t v13 = CFArrayCreate(0, (const void **)values, 3, MEMORY[0x1E4F1D510]);
    CFUUIDRef v14 = v13;
    if (v13)
    {
      uint64_t v26 = 0;
      keys[0] = 0;
      int Count = CFArrayGetCount(v13);
      CFTypeID v16 = 0;
      BOOL v17 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D048];
      uint64_t v18 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      while (Count-- >= 1)
      {
        CFNumberRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v14, Count);
        if (v16) {
          CFTypeRef v21 = v16;
        }
        else {
          CFTypeRef v21 = v9;
        }
        uint64_t v26 = v21;
        keys[0] = ValueAtIndex;
        uint64_t v22 = CFDictionaryCreate(0, (const void **)keys, (const void **)&v26, 1, v17, v18);
        if (v16) {
          CFRelease(v16);
        }
        CFTypeID v16 = v22;
        if (!v22) {
          goto LABEL_17;
        }
      }
      if (v16) {
        CFAllocatorRef v6 = IOConnectSetCFProperties(connect, v16);
      }
    }
    else
    {
      CFTypeID v16 = 0;
    }
LABEL_17:
    CFRelease(v9);
    CFRelease(v12);
    if (v14) {
      CFRelease(v14);
    }
    if (v16) {
      goto LABEL_20;
    }
  }
  return v6;
}

CFDictionaryRef GetDictionaryValueUsingKeysApplier(const void *a1, CFDictionaryRef *a2)
{
  CFDictionaryRef result = *a2;
  if (*a2)
  {
    CFTypeID v5 = CFGetTypeID(result);
    if (v5 == CFDictionaryGetTypeID()) {
      CFDictionaryRef result = (CFDictionaryRef)CFDictionaryGetValue(*a2, a1);
    }
    else {
      CFDictionaryRef result = 0;
    }
  }
  *a2 = result;
  return result;
}

NXEventHandle NXOpenEventStatus(void)
{
  kern_return_t v0;
  NXEventHandle result;
  io_object_t v2;
  mach_port_t mainPort[2];

  *(void *)mainmach_port_name_t Port = 0;
  CFPropertyListRef v0 = IOMasterPort(0, mainPort);
  CFDictionaryRef result = 0;
  if (!v0)
  {
    CFDictionaryRef result = IORegistryEntryFromPath(mainPort[0], "IOService:/IOResources/IOHIDSystem");
    if (result)
    {
      CFPropertyListRef v2 = result;
      IOServiceOpen(result, *MEMORY[0x1E4F14960], 1u, &mainPort[1]);
      IOObjectRelease(v2);
      return mainPort[1];
    }
  }
  return result;
}

NXEventSystemInfoType NXEventSystemInfo(NXEventHandle handle, char *flavor, int *evs_info, unsigned int *evs_info_cnt)
{
  unsigned int v6 = *evs_info_cnt;
  *(void *)service = 0;
  if (IOConnectGetService(handle, &service[1])) {
    return 0;
  }
  CFArrayRef CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(service[1], @"NXSystemInfo", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  IOObjectRelease(service[1]);
  if (CFProperty)
  {
    unsigned int v8 = v6 >> 2;
    signed int Count = CFArrayGetCount(CFProperty);
    if ((int)v8 >= Count) {
      uint64_t v10 = Count;
    }
    else {
      uint64_t v10 = v8;
    }
    if ((int)v10 >= 1)
    {
      CFIndex v11 = 0;
      CFTypeID v12 = evs_info + 2;
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(CFProperty, v11);
        if (ValueAtIndex)
        {
          CFDictionaryRef v14 = ValueAtIndex;
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"HIDKind");
          if (Value)
          {
            CFNumberGetValue(Value, kCFNumberSInt32Type, service);
            int *v12 = service[0];
            CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(v14, @"HIDInterfaceID");
            if (v16)
            {
              CFNumberGetValue(v16, kCFNumberSInt32Type, service);
              io_service_t v17 = service[0];
            }
            else
            {
              io_service_t v17 = 0;
              service[0] = 0;
            }
            *(v12 - 2) = v17;
            CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(v14, @"HIDSubinterfaceID");
            if (v18)
            {
              CFNumberGetValue(v18, kCFNumberSInt32Type, service);
              io_service_t v19 = service[0];
            }
            else
            {
              io_service_t v19 = 0;
              service[0] = 0;
            }
            v12[1] = v19;
            *(v12 - 1) = 0;
          }
        }
        ++v11;
        v12 += 4;
      }
      while (v10 != v11);
    }
    CFRelease(CFProperty);
    unsigned int v20 = 4 * v10;
  }
  else
  {
    unsigned int v20 = 0;
  }
  *evs_info_cnt = v20;
  return evs_info;
}

uint64_t IOHIDCopyHIDParameterFromEventSystem(io_connect_t a1, const __CFString *a2, void *a3)
{
  uint64_t v6 = IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 2, 0);
  if (v6)
  {
    size_t v7 = (__IOHIDEventSystemClient *)v6;
    io_service_t service = 0;
    if (!IOConnectGetService(a1, &service))
    {
      if (IOObjectConformsTo(service, "IOHIDSystem"))
      {
        CFTypeRef v11 = IOHIDEventSystemClientCopyProperty(v7, a2);
      }
      else
      {
        uint64_t v14 = 0;
        CFTypeRef v11 = 0;
        if (!IORegistryEntryGetRegistryEntryID(service, &v14))
        {
          CFTypeID v12 = (__IOHIDServiceClient *)IOHIDEventSystemClientCopyServiceForRegistryID((uint64_t)v7, v14);
          if (v12)
          {
            uint64_t v13 = v12;
            CFTypeRef v11 = IOHIDServiceClientCopyProperty(v12, a2);
            CFRelease(v13);
          }
          else
          {
            CFTypeRef v11 = 0;
          }
        }
      }
      IOObjectRelease(service);
      if (v11)
      {
        *a3 = v11;
        CFRelease(v7);
        return 0;
      }
    }
    CFRelease(v7);
  }
  uint64_t v8 = 3758097112;
  CFTypeID v9 = _IOHIDLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
    IOHIDCopyHIDParameterFromEventSystem_cold_1(v9);
  }
  return v8;
}

uint64_t IOHIDSetHIDParameterToEventSystem(io_connect_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v6 = 3758097095;
  uint64_t v7 = IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 2, 0);
  if (!v7)
  {
    uint64_t v6 = 3758097112;
LABEL_14:
    CFTypeRef v11 = _IOHIDLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      IOHIDSetHIDParameterToEventSystem_cold_1(v6, v11);
    }
    return v6;
  }
  uint64_t v8 = (void *)v7;
  io_service_t service = 0;
  if (IOConnectGetService(a1, &service))
  {
    CFRelease(v8);
    goto LABEL_14;
  }
  if (IOObjectConformsTo(service, "IOHIDSystem"))
  {
    IOHIDEventSystemClientSetProperty((IOHIDEventSystemClientRef)v8, a2, a3);
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    if (!IORegistryEntryGetRegistryEntryID(service, &v13))
    {
      CFTypeID v9 = (__IOHIDServiceClient *)IOHIDEventSystemClientCopyServiceForRegistryID((uint64_t)v8, v13);
      if (v9)
      {
        uint64_t v10 = v9;
        if (IOHIDServiceClientSetProperty(v9, a2, a3)) {
          uint64_t v6 = 0;
        }
        else {
          uint64_t v6 = 3758097097;
        }
        CFRelease(v10);
      }
    }
  }
  IOObjectRelease(service);
  CFRelease(v8);
  if (v6) {
    goto LABEL_14;
  }
  return v6;
}

kern_return_t IOHIDSetParameter(io_connect_t handle, CFStringRef key, const void *bytes, IOByteCount size)
{
  kern_return_t v4;
  CFNumberType v7;
  CFNumberRef v8;
  CFNumberRef v9;
  kern_return_t v10;

  char v4 = -536870212;
  if (!bytes || !size) {
    return v4;
  }
  if (size > 8) {
    uint64_t v7 = kCFNumberSInt32Type;
  }
  else {
    uint64_t v7 = qword_18B50BDB0[size - 1];
  }
  uint64_t v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, bytes);
  if (!v8) {
    return -536870211;
  }
  CFTypeID v9 = v8;
  if (!CFEqual(@"HIDWaitCursorFrameInterval", key)) {
    IOHIDSetHIDParameterToEventSystem(handle, key, v9);
  }
  uint64_t v10 = IOConnectSetCFProperty(handle, key, v9);
  CFRelease(v9);
  return v10;
}

kern_return_t IOHIDSetCFTypeParameter(io_connect_t handle, CFStringRef key, CFTypeRef parameter)
{
  if (!parameter) {
    return -536870206;
  }
  IOHIDSetHIDParameterToEventSystem(handle, key, parameter);

  return IOConnectSetCFProperty(handle, key, parameter);
}

kern_return_t IOHIDGetParameter(io_connect_t handle, CFStringRef key, IOByteCount maxSize, void *bytes, IOByteCount *actualSize)
{
  kern_return_t v5;
  IOByteCount v8;
  kern_return_t result;
  CFTypeRef v10;
  CFTypeID v11;
  CFTypeID TypeID;
  CFDataRef v13;
  IOByteCount Length;
  const UInt8 *BytePtr;
  CFTypeID v16;
  CFNumberRef v17;
  IOByteCount ByteSize;
  IOByteCount v19;
  unint64_t v20;
  CFNumberType v21;
  CFTypeRef parameter;

  parameter = 0;
  CFTypeID v5 = -536870206;
  if (maxSize && bytes)
  {
    uint64_t v8 = maxSize;
    CFDictionaryRef result = IOHIDCopyCFTypeParameter(handle, key, &parameter);
    if (result) {
      return result;
    }
    uint64_t v10 = parameter;
    if (parameter)
    {
      bzero(bytes, v8);
      CFTypeRef v11 = CFGetTypeID(v10);
      CFTypeID TypeID = CFDataGetTypeID();
      uint64_t v13 = (const __CFData *)parameter;
      if (v11 == TypeID)
      {
        int Length = CFDataGetLength((CFDataRef)parameter);
        *actualSize = Length;
        if (Length < v8) {
          uint64_t v8 = Length;
        }
        BytePtr = CFDataGetBytePtr(v13);
        memmove(bytes, BytePtr, v8);
      }
      else
      {
        CFNumberRef v16 = CFGetTypeID(parameter);
        if (v16 != CFNumberGetTypeID())
        {
LABEL_20:
          CFRelease(parameter);
          return v5;
        }
        io_service_t v17 = (const __CFNumber *)parameter;
        ByteSize = CFNumberGetByteSize((CFNumberRef)parameter);
        *actualSize = ByteSize;
        if (ByteSize >= v8) {
          io_service_t v19 = v8;
        }
        else {
          io_service_t v19 = ByteSize;
        }
        unsigned int v20 = v19 - 1;
        if (v20 > 7) {
          CFTypeRef v21 = kCFNumberSInt32Type;
        }
        else {
          CFTypeRef v21 = qword_18B50BDB0[v20];
        }
        CFNumberGetValue(v17, v21, bytes);
      }
      CFTypeID v5 = 0;
      goto LABEL_20;
    }
  }
  return -536870206;
}

kern_return_t IOHIDCopyCFTypeParameter(io_connect_t handle, CFStringRef key, CFTypeRef *parameter)
{
  kern_return_t v6;
  CFAllocatorRef v8;
  CFDictionaryRef CFProperty;
  CFDictionaryRef v10;
  const void *Value;
  const void *v12;
  CFTypeRef v13;
  io_service_t service;

  io_service_t service = 0;
  if (!parameter) {
    return -536870212;
  }
  if (IOConnectGetService(handle, &service)) {
    goto LABEL_3;
  }
  uint64_t v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(service, @"HIDParameters", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (CFProperty)
  {
    uint64_t v10 = CFProperty;
    CFNumberRef Value = CFDictionaryGetValue(CFProperty, key);
    if (Value)
    {
      CFTypeID v12 = Value;
      CFRetain(Value);
      CFRelease(v10);
      uint64_t v6 = 0;
      *parameter = v12;
      goto LABEL_4;
    }
    CFRelease(v10);
  }
  uint64_t v13 = IORegistryEntryCreateCFProperty(service, key, v8, 0);
  uint64_t v6 = 0;
  *parameter = v13;
  if (!v13) {
LABEL_3:
  }
    uint64_t v6 = IOHIDCopyHIDParameterFromEventSystem(handle, key, parameter);
LABEL_4:
  if (service) {
    IOObjectRelease(service);
  }
  return v6;
}

void NXResetKeyboard(NXEventHandle handle)
{
  CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
  if (v2)
  {
    CFNumberRef v3 = v2;
    IOHIDSetHIDParameterToEventSystem(handle, @"HIDResetKeyboard", v2);
    IOConnectSetCFProperty(handle, @"HIDResetKeyboard", v3);
    CFRelease(v3);
  }
}

void NXSetKeyRepeatInterval(NXEventHandle handle, double seconds)
{
  unint64_t bytes = (unint64_t)(seconds * 1000000000.0);
  IOHIDSetParameter(handle, @"HIDKeyRepeat", &bytes, 8uLL);
}

double NXKeyRepeatInterval(NXEventHandle handle)
{
  kern_return_t v1;
  double result;
  IOByteCount v3;
  unint64_t bytes;

  unint64_t bytes = 0;
  int v1 = IOHIDGetParameter(handle, @"HIDKeyRepeat", 8uLL, &bytes, &v3);
  CFDictionaryRef result = 0.0;
  if (!v1) {
    return (double)bytes / 1000.0 / 1000.0 / 1000.0;
  }
  return result;
}

void NXSetKeyRepeatThreshold(NXEventHandle handle, double threshold)
{
  unint64_t bytes = (unint64_t)(threshold * 1000000000.0);
  IOHIDSetParameter(handle, @"HIDInitialKeyRepeat", &bytes, 8uLL);
}

double NXKeyRepeatThreshold(NXEventHandle handle)
{
  kern_return_t v1;
  double result;
  IOByteCount v3;
  unint64_t bytes;

  unint64_t bytes = 0;
  int v1 = IOHIDGetParameter(handle, @"HIDInitialKeyRepeat", 8uLL, &bytes, &v3);
  CFDictionaryRef result = 0.0;
  if (!v1) {
    return (double)bytes / 1000.0 / 1000.0 / 1000.0;
  }
  return result;
}

CFDataRef NXSetKeyMapping(io_connect_t a1, const UInt8 **a2)
{
  kern_return_t v7;

  CFIndex v2 = *(int *)a2;
  if ((int)v2 > 4096) {
    return 0;
  }
  CFDataRef result = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2[1], v2);
  if (result)
  {
    CFDataRef v6 = result;
    IOHIDSetHIDParameterToEventSystem(a1, @"HIDKeyMapping", result);
    uint64_t v7 = IOConnectSetCFProperty(a1, @"HIDKeyMapping", v6);
    CFRelease(v6);
    if (v7) {
      return 0;
    }
    else {
      return (CFDataRef)a2;
    }
  }
  return result;
}

uint64_t NXKeyMappingLength()
{
  return 0;
}

IOByteCount *NXGetKeyMapping(io_connect_t a1, IOByteCount *actualSize)
{
  if (IOHIDGetParameter(a1, @"HIDKeyMapping", *(int *)actualSize, (void *)actualSize[1], actualSize)) {
    return 0;
  }
  else {
    return actualSize;
  }
}

void NXResetMouse(NXEventHandle handle)
{
  CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
  if (v2)
  {
    CFNumberRef v3 = v2;
    IOHIDSetHIDParameterToEventSystem(handle, @"HIDResetPointer", v2);
    IOConnectSetCFProperty(handle, @"HIDResetPointer", v3);
    CFRelease(v3);
  }
}

void NXSetClickTime(NXEventHandle handle, double seconds)
{
  unint64_t bytes = (unint64_t)(seconds * 1000000000.0);
  IOHIDSetParameter(handle, @"HIDClickTime", &bytes, 8uLL);
}

double NXClickTime(NXEventHandle handle)
{
  kern_return_t v1;
  double result;
  IOByteCount v3;
  unint64_t bytes;

  unint64_t bytes = 0;
  int v1 = IOHIDGetParameter(handle, @"HIDClickTime", 8uLL, &bytes, &v3);
  CFDataRef result = 0.0;
  if (!v1) {
    return (double)bytes / 1000.0 / 1000.0 / 1000.0;
  }
  return result;
}

void NXSetClickSpace(NXEventHandle handle, NXSize *area)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  v11[0] = vcvt_u32_f32((float32x2_t)*area);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFTypeID v5 = Mutable;
    CFIndex v6 = 0;
    char v7 = 1;
    do
    {
      char v8 = v7;
      CFNumberRef v9 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)v11 + 4 * v6);
      if (v9)
      {
        CFNumberRef v10 = v9;
        CFArraySetValueAtIndex(v5, v6, v9);
        CFRelease(v10);
      }
      char v7 = 0;
      CFIndex v6 = 1;
    }
    while ((v8 & 1) != 0);
    IOHIDSetHIDParameterToEventSystem(handle, @"HIDClickSpace", v5);
    IOConnectSetCFProperty(handle, @"HIDClickSpace", v5);
    CFRelease(v5);
  }
}

void NXGetClickSpace(NXEventHandle handle, NXSize *area)
{
  v12[1] = *(uint32x2_t *)MEMORY[0x1E4F143B8];
  CFTypeRef parameter = 0;
  NXSize v3 = 0;
  if (!IOHIDCopyCFTypeParameter(handle, @"HIDClickSpace", &parameter))
  {
    if (parameter)
    {
      CFTypeID v4 = CFGetTypeID(parameter);
      if (v4 == CFArrayGetTypeID())
      {
        CFArrayRef v5 = (const __CFArray *)parameter;
        unsigned int Count = CFArrayGetCount((CFArrayRef)parameter);
        if (Count >= 2) {
          uint64_t v7 = 2;
        }
        else {
          uint64_t v7 = Count;
        }
        if (v7)
        {
          CFIndex v8 = 0;
          CFNumberRef v9 = v12;
          do
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v5, v8);
            if (ValueAtIndex) {
              CFNumberGetValue(ValueAtIndex, kCFNumberIntType, v9);
            }
            ++v8;
            CFNumberRef v9 = (uint32x2_t *)((char *)v9 + 4);
          }
          while (v7 != v8);
        }
        CFRelease(v5);
        NXSize v3 = (NXSize)vcvt_f32_u32(v12[0]);
      }
    }
  }
  *area = v3;
}

kern_return_t IOHIDGetScrollAcceleration(io_connect_t handle, double *acceleration)
{
  kern_return_t result;
  unint64_t v4;
  IOByteCount v5;
  int bytes;

  unint64_t bytes = 0;
  CFDataRef result = IOHIDGetParameter(handle, @"HIDScrollAcceleration", 4uLL, &bytes, &v5);
  if (!result)
  {
    LODWORD(v4) = bytes;
    *acceleration = (double)v4 * 0.0000152587891;
  }
  return result;
}

kern_return_t IOHIDSetScrollAcceleration(io_connect_t handle, double acceleration)
{
  unsigned int bytes = vcvtd_n_u64_f64(acceleration, 0x10uLL);
  return IOHIDSetParameter(handle, @"HIDScrollAcceleration", &bytes, 4uLL);
}

kern_return_t IOHIDGetMouseButtonMode(io_connect_t handle, int *mode)
{
  return IOHIDGetParameter(handle, @"HIDPointerButtonMode", 4uLL, mode, &actualSize);
}

kern_return_t IOHIDSetMouseButtonMode(io_connect_t handle, int mode)
{
  int bytes = mode;
  return IOHIDSetParameter(handle, @"HIDPointerButtonMode", &bytes, 4uLL);
}

kern_return_t IOHIDGetMouseAcceleration(io_connect_t handle, double *acceleration)
{
  kern_return_t result;
  unint64_t v4;
  IOByteCount v5;
  int bytes;

  int bytes = 0;
  CFDataRef result = IOHIDGetParameter(handle, @"HIDPointerAcceleration", 4uLL, &bytes, &v5);
  if (!result)
  {
    LODWORD(v4) = bytes;
    *acceleration = (double)v4 * 0.0000152587891;
  }
  return result;
}

kern_return_t IOHIDSetMouseAcceleration(io_connect_t handle, double acceleration)
{
  unsigned int bytes = vcvtd_n_u64_f64(acceleration, 0x10uLL);
  return IOHIDSetParameter(handle, @"HIDPointerAcceleration", &bytes, 4uLL);
}

kern_return_t IOHIDGetAccelerationWithKey(io_connect_t handle, CFStringRef key, double *acceleration)
{
  kern_return_t result;
  unint64_t v5;
  IOByteCount v6;
  int bytes;

  unsigned int bytes = 0;
  CFDataRef result = IOHIDGetParameter(handle, key, 4uLL, &bytes, &v6);
  if (!result)
  {
    LODWORD(v5) = bytes;
    *acceleration = (double)v5 * 0.0000152587891;
  }
  return result;
}

kern_return_t IOHIDSetAccelerationWithKey(io_connect_t handle, CFStringRef key, double acceleration)
{
  unsigned int bytes = vcvtd_n_u64_f64(acceleration, 0x10uLL);
  return IOHIDSetParameter(handle, key, &bytes, 4uLL);
}

IOHIDAccessType IOHIDCheckAccess(IOHIDRequestType requestType)
{
  if (__loadTCCFramework_onceToken != -1) {
    dispatch_once(&__loadTCCFramework_onceToken, &__block_literal_global_20);
  }
  if (__loadTCCFramework_tccFramework) {
    BOOL v2 = _preflightFunc == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return 2;
  }
  if (requestType == kIOHIDRequestTypePostEvent)
  {
    NXSize v3 = @"kTCCServicePostEvent";
    goto LABEL_12;
  }
  if (requestType != kIOHIDRequestTypeListenEvent) {
    return 2;
  }
  NXSize v3 = @"kTCCServiceListenEvent";
LABEL_12:
  int v5 = _preflightFunc(v3, 0);
  if (v5 == 1) {
    IOHIDAccessType v6 = kIOHIDAccessTypeDenied;
  }
  else {
    IOHIDAccessType v6 = kIOHIDAccessTypeUnknown;
  }
  if (v5) {
    return v6;
  }
  else {
    return 0;
  }
}

BOOL IOHIDRequestAccess(IOHIDRequestType requestType)
{
  uint64_t v11 = 0;
  CFTypeID v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  uint64_t v7 = 0;
  CFIndex v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  if (__loadTCCFramework_onceToken != -1) {
    dispatch_once(&__loadTCCFramework_onceToken, &__block_literal_global_20);
  }
  if (__loadTCCFramework_tccFramework && _requestFunc)
  {
    if (requestType)
    {
      if (requestType != kIOHIDRequestTypeListenEvent) {
        goto LABEL_11;
      }
      BOOL v2 = @"kTCCServiceListenEvent";
    }
    else
    {
      BOOL v2 = @"kTCCServicePostEvent";
    }
    dispatch_semaphore_t v3 = dispatch_semaphore_create(0);
    v8[3] = (uint64_t)v3;
    if (v3)
    {
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 0x40000000;
      v6[2] = __IOHIDRequestAccess_block_invoke;
      v6[3] = &unk_1E54896A0;
      v6[4] = &v11;
      _OWORD v6[5] = &v7;
      _requestFunc(v2, 0, v6);
      dispatch_semaphore_wait((dispatch_semaphore_t)v8[3], 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release((dispatch_object_t)v8[3]);
    }
  }
LABEL_11:
  char v4 = *((unsigned char *)v12 + 24);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
  return v4;
}

intptr_t __IOHIDRequestAccess_block_invoke(uint64_t a1, int a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2 != 0;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
}

BOOL IOHIDAccessCheckAuditToken(int a1, _OWORD *a2)
{
  if (__loadTCCFramework_onceToken != -1) {
    dispatch_once(&__loadTCCFramework_onceToken, &__block_literal_global_20);
  }
  if (__loadTCCFramework_tccFramework) {
    BOOL v4 = _checkAuditTokenFunc == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 1;
  }
  if (!a1)
  {
    IOHIDAccessType v6 = @"kTCCServicePostEvent";
    goto LABEL_13;
  }
  if (a1 == 1)
  {
    IOHIDAccessType v6 = @"kTCCServiceListenEvent";
LABEL_13:
    long long v7 = a2[1];
    v8[0] = *a2;
    v8[1] = v7;
    return _checkAuditTokenFunc(v6, v8, 0) != 0;
  }
  return 0;
}

kern_return_t IOHIDCreateSharedMemory(io_connect_t connect, unsigned int version)
{
  uint64_t input = version;
  return IOConnectCallMethod(connect, 0, &input, 1u, 0, 0, 0, 0, 0, 0);
}

kern_return_t IOHIDSetEventsEnable(io_connect_t connect, BOOLean_t enable)
{
  uint64_t input = enable;
  return IOConnectCallMethod(connect, 1u, &input, 1u, 0, 0, 0, 0, 0, 0);
}

kern_return_t IOHIDSetCursorEnable(io_connect_t connect, BOOLean_t enable)
{
  kern_return_t v6;
  NSObject *v7;
  uint64_t input;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  CFTypeID v12 = *MEMORY[0x1E4F143B8];
  uint64_t input = enable;
  BOOL v4 = _IOHIDLogCategory(0xAu);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    int v5 = "YES";
    if (!enable) {
      int v5 = "NO";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = v5;
    _os_log_impl(&dword_18B46C000, v4, OS_LOG_TYPE_INFO, "Set cursor enable:%s", buf, 0xCu);
  }
  IOHIDAccessType v6 = IOConnectCallMethod(connect, 2u, &input, 1u, 0, 0, 0, 0, 0, 0);
  if (v6)
  {
    long long v7 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      IOHIDSetCursorEnable_cold_1();
    }
  }
  return v6;
}

kern_return_t IOHIDPostEvent(io_connect_t connect, UInt32 eventType, IOGPoint location, const NXEventData *eventData, UInt32 eventDataVersion, IOOptionBits eventFlags, IOOptionBits options)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  inputStruct[1] = eventType;
  inputStruct[2] = location;
  IOOptionBits v21 = options;
  IOOptionBits v22 = eventFlags;
  char v11 = options & 6;
  inputStruct[0] = options & 6;
  pid_t v23 = getpid();
  if (eventDataVersion > 1)
  {
    long long v13 = *(_OWORD *)&eventData->proximity.uniqueID;
    long long v18 = *(_OWORD *)&eventData->mouse.subx;
    long long v19 = v13;
    long long v20 = *(_OWORD *)eventData->proximity.reserved2;
    LOBYTE(eventDataVersion) = v11;
  }
  else
  {
    inputStruct[0] = eventDataVersion;
    long long v12 = *(_OWORD *)&eventData->proximity.uniqueID;
    long long v18 = *(_OWORD *)&eventData->mouse.subx;
    long long v19 = v12;
    long long v20 = 0uLL;
  }
  int v15 = 1;
  mach_port_name_t name = 0;
  if (!bootstrap_look_up2())
  {
    io_pm_hid_event_report_activity(name, eventType, &v15);
    mach_port_deallocate(*MEMORY[0x1E4F14960], name);
    if (!v15) {
      return 0;
    }
  }
  if (eventDataVersion & 2 | eventType)
  {
    if (IOHIDPostEvent_onceToken != -1) {
      dispatch_once(&IOHIDPostEvent_onceToken, &__block_literal_global_3);
    }
  }
  return IOConnectCallMethod(connect, 3u, 0, 0, inputStruct, 0x48uLL, 0, 0, 0, 0);
}

BOOL __IOHIDPostEvent_block_invoke()
{
  return IOHIDRequestAccess(kIOHIDRequestTypePostEvent);
}

uint64_t IOHIDSetCursorBounds(mach_port_t a1, __int16 *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 3758097090;
  }
  BOOL v4 = _IOHIDLogCategory(0xAu);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    int v5 = *a2;
    int v6 = a2[2];
    int v7 = a2[1];
    int v8 = a2[3];
    *(_DWORD *)long long buf = 67109888;
    int v13 = v5;
    __int16 v14 = 1024;
    int v15 = v6;
    __int16 v16 = 1024;
    int v17 = v7;
    __int16 v18 = 1024;
    int v19 = v8;
    _os_log_impl(&dword_18B46C000, v4, OS_LOG_TYPE_INFO, "Set cursor bounds minx:%d miny:%d maxx:%d maxy:%d", buf, 0x1Au);
  }
  uint64_t v9 = IOConnectCallMethod(a1, 6u, 0, 0, a2, 8uLL, 0, 0, 0, 0);
  if (v9)
  {
    uint64_t v10 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      IOHIDSetCursorBounds_cold_1();
    }
  }
  return v9;
}

uint64_t IOHIDSetOnScreenCursorBounds(mach_port_t a1, __int16 *a2, int16x4_t *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 3758097090;
  if (a2 && a3)
  {
    int v7 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      int v8 = *a2;
      int v9 = a2[1];
      int v10 = a3->i16[0];
      int v11 = a3->i16[2];
      int v12 = a3->i16[1];
      int v13 = a3->i16[3];
      *(_DWORD *)long long buf = 67110400;
      *(_DWORD *)int v17 = v8;
      *(_WORD *)&v17[4] = 1024;
      *(_DWORD *)&v17[6] = v9;
      __int16 v18 = 1024;
      int v19 = v10;
      __int16 v20 = 1024;
      int v21 = v11;
      __int16 v22 = 1024;
      int v23 = v12;
      __int16 v24 = 1024;
      int v25 = v13;
      _os_log_impl(&dword_18B46C000, v7, OS_LOG_TYPE_INFO, "Set on screen cursor bounds px:%d py:%d minx:%d miny:%d maxx:%d maxy:%d", buf, 0x26u);
    }
    *(_DWORD *)long long buf = *(_DWORD *)a2;
    *(int16x4_t *)int v17 = vuzp1_s16(*a3, vrev32_s16(*a3));
    uint64_t v3 = IOConnectCallMethod(a1, 0xCu, 0, 0, buf, 0xCuLL, 0, 0, 0, 0);
    if (v3)
    {
      __int16 v14 = _IOHIDLogCategory(0xAu);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        IOHIDSetOnScreenCursorBounds_cold_1();
      }
    }
  }
  return v3;
}

kern_return_t IOHIDSetMouseLocation(io_connect_t connect, int x, int y)
{
  memset(&v4, 0, sizeof(v4));
  v5.y = y;
  v5.x = x;
  return IOHIDPostEvent(connect, 0, v5, &v4, 2u, 0xFFFFFFFF, 2u);
}

uint64_t _IOHIDSetFixedMouseLocation(mach_port_t a1, void *inputStruct)
{
  uint64_t v2 = IOConnectCallMethod(a1, 4u, 0, 0, inputStruct, 0x1CuLL, 0, 0, 0, 0);
  if (v2)
  {
    uint64_t v3 = _IOHIDLogCategory(0xAu);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      _IOHIDSetFixedMouseLocation_cold_1();
    }
  }
  return v2;
}

uint64_t IOHIDSetFixedMouseLocation(mach_port_t a1, int a2, int a3)
{
  v7[0] = 0;
  v7[1] = mach_absolute_time();
  int v8 = a2;
  int v9 = a3;
  pid_t v10 = getpid();
  return _IOHIDSetFixedMouseLocation(a1, v7);
}

uint64_t IOHIDSetFixedMouseLocationWithTimeStamp(mach_port_t a1, int a2, int a3, uint64_t a4)
{
  v8[0] = a4;
  v8[1] = mach_absolute_time();
  int v9 = a2;
  int v10 = a3;
  pid_t v11 = getpid();
  return _IOHIDSetFixedMouseLocation(a1, v8);
}

kern_return_t IOHIDGetButtonEventNum(io_connect_t connect, NXMouseButton button, int *eventNum)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input;

  uint64_t input = button;
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  CFDataRef result = IOConnectCallMethod(connect, 5u, &input, 1u, 0, 0, &output, &outputCnt, 0, 0);
  *eventNum = output;
  return result;
}

kern_return_t IOHIDGetStateForSelector(io_connect_t handle, int selector, UInt32 *state)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  input[1] = *MEMORY[0x1E4F143B8];
  uint64_t output = 0;
  input[0] = selector;
  uint32_t outputCnt = 1;
  CFDataRef result = IOConnectCallMethod(handle, 5u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
  *state = output;
  return result;
}

kern_return_t IOHIDSetStateForSelector(io_connect_t handle, int selector, UInt32 state)
{
  kern_return_t v3;
  kern_return_t v4;
  NSObject *v5;
  CFNumberRef v7;
  NSObject *v8;
  io_service_t service;
  uint32_t outputCnt;
  UInt32 valuePtr;
  uint64_t input[3];

  input[2] = *MEMORY[0x1E4F143B8];
  uint32_t outputCnt = 0;
  int valuePtr = state;
  input[0] = selector;
  input[1] = state;
  if (selector != 3) {
    return IOConnectCallMethod(handle, 6u, input, 2u, 0, 0, 0, &outputCnt, 0, 0);
  }
  io_service_t service = 0;
  uint64_t v3 = IOConnectGetService(handle, &service);
  if (!v3)
  {
    int v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    NXEventData v4 = IORegistryEntrySetCFProperty(service, @"IOHIDActivityUserIdle", v7);
    if (v4 && (int v8 = _IOHIDLogCategory(0), os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)))
    {
      IOHIDSetStateForSelector_cold_1();
      if (!v7) {
        return v4;
      }
    }
    else if (!v7)
    {
      return v4;
    }
    CFRelease(v7);
    return v4;
  }
  NXEventData v4 = v3;
  IOGPoint v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    IOHIDSetStateForSelector_cold_2();
  }
  return v4;
}

kern_return_t IOHIDGetModifierLockState(io_connect_t handle, int selector, BOOL *state)
{
  kern_return_t result;
  UInt32 statea;

  statea = 0;
  CFDataRef result = IOHIDGetStateForSelector(handle, selector, &statea);
  *state = statea != 0;
  return result;
}

kern_return_t IOHIDSetModifierLockState(io_connect_t handle, int selector, BOOL state)
{
  kern_return_t v3;
  BOOL v4;
  __IOHIDEventSystemClient *v6;
  __IOHIDEventSystemClient *v7;
  CFArrayRef v8;
  CFArrayRef v9;
  CFIndex v10;
  CFStringRef v11;
  const void **v12;
  const void *v13;
  __IOHIDServiceClient *ValueAtIndex;
  __IOHIDServiceClient *v15;
  NSObject *v16;

  uint64_t v3 = -536870212;
  if ((selector - 3) < 0xFFFFFFFE) {
    return -536870206;
  }
  NXEventData v4 = state;
  int v6 = (__IOHIDEventSystemClient *)IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 2, 0);
  if (v6)
  {
    int v7 = v6;
    int v8 = IOHIDEventSystemClientCopyServices(v6);
    uint64_t v3 = -536870208;
    if (v8)
    {
      int v9 = v8;
      if (CFArrayGetCount(v8))
      {
        if (CFArrayGetCount(v9) >= 1)
        {
          int v10 = 0;
          if (selector == 1) {
            pid_t v11 = @"HIDCapsLockState";
          }
          else {
            pid_t v11 = @"HIDNumLockState";
          }
          int v12 = (const void **)MEMORY[0x1E4F1CFC8];
          if (v4) {
            int v12 = (const void **)MEMORY[0x1E4F1CFD0];
          }
          int v13 = *v12;
          do
          {
            CFNumberRef ValueAtIndex = (__IOHIDServiceClient *)CFArrayGetValueAtIndex(v9, v10);
            if (ValueAtIndex)
            {
              int v15 = ValueAtIndex;
              if (IOHIDServiceClientConformsTo(ValueAtIndex, 1u, 6u)) {
                IOHIDServiceClientSetProperty(v15, v11, v13);
              }
            }
            ++v10;
          }
          while (v10 < CFArrayGetCount(v9));
        }
        uint64_t v3 = 0;
      }
      CFRelease(v9);
    }
    CFRelease(v7);
  }
  else
  {
    __int16 v16 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      IOHIDSetModifierLockState_cold_1();
    }
  }
  return v3;
}

kern_return_t IOHIDRegisterVirtualDisplay(io_connect_t handle, UInt32 *display_token)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output[2];

  output[1] = *MEMORY[0x1E4F143B8];
  output[0] = 0;
  uint32_t outputCnt = 1;
  CFDataRef result = IOConnectCallMethod(handle, 7u, 0, 0, 0, 0, output, &outputCnt, 0, 0);
  *display_token = output[0];
  return result;
}

kern_return_t IOHIDUnregisterVirtualDisplay(io_connect_t handle, UInt32 display_token)
{
  input[1] = *MEMORY[0x1E4F143B8];
  input[0] = display_token;
  uint32_t outputCnt = 0;
  return IOConnectCallMethod(handle, 8u, input, 1u, 0, 0, 0, &outputCnt, 0, 0);
}

kern_return_t IOHIDSetVirtualDisplayBounds(io_connect_t handle, UInt32 display_token, const IOGBounds *bounds)
{
  input[5] = *MEMORY[0x1E4F143B8];
  uint64_t minx = bounds->minx;
  input[0] = display_token;
  input[1] = minx;
  uint64_t miny = bounds->miny;
  uint64_t input[2] = bounds->maxx;
  uint64_t input[3] = miny;
  input[4] = bounds->maxy;
  uint32_t outputCnt = 0;
  return IOConnectCallMethod(handle, 9u, input, 5u, 0, 0, 0, &outputCnt, 0, 0);
}

kern_return_t IOHIDGetActivityState(io_connect_t handle, BOOL *hidActivityIdle)
{
  kern_return_t result;
  uint32_t outputCnt;
  uint64_t output[2];

  output[1] = *MEMORY[0x1E4F143B8];
  output[0] = 0;
  uint32_t outputCnt = 1;
  if (!hidActivityIdle) {
    return -536870206;
  }
  CFDataRef result = IOConnectCallMethod(handle, 0xAu, 0, 0, 0, 0, output, &outputCnt, 0, 0);
  *hidActivityIdle = output[0] != 0;
  return result;
}

void ____loadTCCFramework_block_invoke()
{
  CFPropertyListRef v0 = dlopen("/System/Library/PrivateFrameworks/TCC.framework/TCC", 5);
  __loadTCCFramework_tccFramework = (uint64_t)v0;
  if (v0)
  {
    _preflightFunc = (uint64_t (*)(void, void))dlsym(v0, "TCCAccessPreflight");
    if (_preflightFunc)
    {
      _requestFunc = (uint64_t (*)(void, void, void))dlsym((void *)__loadTCCFramework_tccFramework, "TCCAccessRequest");
      if (_requestFunc)
      {
        _checkAuditTokenFunc = (uint64_t (*)(void, void, void))dlsym((void *)__loadTCCFramework_tccFramework, "TCCAccessCheckAuditToken");
        if (!_requestFunc)
        {
          int v1 = _IOHIDLogCategory(0);
          if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
            ____loadTCCFramework_block_invoke_cold_4();
          }
        }
      }
      else
      {
        NXEventData v4 = _IOHIDLogCategory(0);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          ____loadTCCFramework_block_invoke_cold_3();
        }
      }
    }
    else
    {
      uint64_t v3 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        ____loadTCCFramework_block_invoke_cold_2();
      }
    }
  }
  else
  {
    uint64_t v2 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      ____loadTCCFramework_block_invoke_cold_1();
    }
  }
}

uint64_t __OSKextVersionStageForString(unsigned __int8 **a1)
{
  if (!a1) {
    return 0;
  }
  int v1 = *a1;
  if (!*a1) {
    return 0;
  }
  unsigned int v2 = *v1;
  if (v2 > 0x20 || ((1 << v2) & 0x100002601) == 0)
  {
    uint64_t v4 = 0;
    switch((char)v2)
    {
      case 'a':
        int v6 = v1[1];
        IOGPoint v5 = v1 + 1;
        if ((v6 - 58) < 0xFFFFFFF6) {
          return 0;
        }
        uint64_t v4 = 3;
        goto LABEL_22;
      case 'b':
        int v7 = v1[1];
        IOGPoint v5 = v1 + 1;
        if ((v7 - 58) < 0xFFFFFFF6) {
          return 0;
        }
        uint64_t v4 = 5;
        goto LABEL_22;
      case 'd':
        int v8 = v1[1];
        IOGPoint v5 = v1 + 1;
        if ((v8 - 58) < 0xFFFFFFF6) {
          return 0;
        }
        uint64_t v4 = 1;
        goto LABEL_22;
      case 'f':
        int v9 = v1[1];
        if ((v9 - 58) > 0xFFFFFFF5)
        {
          uint64_t v4 = 7;
          IOGPoint v5 = v1 + 1;
        }
        else
        {
          if (v9 != 99) {
            return 0;
          }
          int v10 = v1[2];
          IOGPoint v5 = v1 + 2;
          if ((v10 - 58) < 0xFFFFFFF6) {
            return 0;
          }
          uint64_t v4 = 7;
        }
LABEL_22:
        *a1 = v5;
        return v4;
      default:
        return v4;
    }
  }
  return 9;
}

uint64_t OSKextVersionGetString(unint64_t a1, void *a2, unsigned int a3)
{
  uint64_t result = 0;
  if (a2 && a3 >= 0x14)
  {
    bzero(a2, a3);
    if ((a1 & 0x8000000000000000) == 0)
    {
      if (!a1)
      {
        __int16 v16 = "(missing)";
        goto LABEL_13;
      }
      if (a1 < 0x2386F26FC10000)
      {
        uint64_t v7 = (uint64_t)(a1 % 0xE8D4A51000) / 100000000;
        unint64_t v8 = 1000000000000 * (a1 / 0xE8D4A51000) + 100000000 * v7;
        unint64_t v9 = a1 - v8;
        uint64_t v10 = (uint64_t)(a1 - v8) / 10000;
        uint64_t v11 = a1 - (v8 + 10000 * v10);
        uint64_t v12 = v11 / 1000;
        if (v11 % 1000 < 256)
        {
          int v13 = snprintf((char *)a2, a3, "%u", a1 / 0xE8D4A51000);
          *((unsigned char *)a2 + v13) = 46;
          uint64_t v14 = snprintf((char *)a2 + v13 + 1, a3 - (v13 + 1), "%u", v7) + (uint64_t)(v13 + 1);
          if (v9 + 9999 >= 0x4E1F)
          {
            *((unsigned char *)a2 + v14) = 46;
            LODWORD(v14) = snprintf((char *)a2 + v14 + 1, a3 - (v14 + 1), "%u", v10) + v14 + 1;
          }
          int v15 = v12 - 1;
          if (v12 - 1) < 9 && ((0x155u >> v15))
          {
            int v17 = (&off_1E5489700)[v15];
            if (*v17)
            {
              strlcat((char *)a2, v17, a3);
              LODWORD(v14) = v14 + strlen(v17);
            }
            if (v11 <= 8999) {
              snprintf((char *)a2 + (int)v14, a3 - v14, "%u", v11 % 1000);
            }
            return 1;
          }
        }
      }
    }
    __int16 v16 = "(invalid)";
LABEL_13:
    strlcpy((char *)a2, v16, a3);
    return 1;
  }
  return result;
}

uint64_t OSKextParseVersionCFString(const __CFString *a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (CFStringGetCString(a1, buffer, 20, 0x600u)) {
    return OSKextParseVersionString(buffer);
  }
  else {
    return -1;
  }
}

void *createUTF8CStringForCFString(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 4;
  uint64_t v4 = malloc_type_malloc(v3, 0x100004077774924uLL);
  if (v4 && !CFStringGetCString(a1, (char *)v4, v3, 0x8000100u))
  {
    free(v4);
    return 0;
  }
  return v4;
}

__CFString *createCFStringForData(const __CFData *a1, CFIndex a2)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (Mutable)
  {
    CFIndex Length = CFDataGetLength(a1);
    CFStringAppend(Mutable, @"<");
    if (Length)
    {
      BytePtr = CFDataGetBytePtr(a1);
      if (Length >= a2) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = Length;
      }
      if (v7 >= 1)
      {
        unint64_t v8 = BytePtr;
        CFIndex v9 = 0;
        do
        {
          uint64_t v10 = v8[v9];
          CFIndex v11 = v9 + 1;
          if (((v9 + 1) & 3) == 0 && v11 < Length) {
            uint64_t v14 = " ";
          }
          else {
            uint64_t v14 = "";
          }
          if (v9) {
            int v15 = v14;
          }
          else {
            int v15 = "";
          }
          CFStringAppendFormat(Mutable, 0, @"%02x%s", v10, v15);
          CFIndex v9 = v11;
        }
        while (v7 != v11);
      }
      if (Length > a2) {
        CFStringAppendFormat(Mutable, 0, @"...(%u bytes total)", Length);
      }
    }
    CFStringAppend(Mutable, @">");
  }
  return Mutable;
}

void printPList_new(FILE *a1, const void *a2, uint64_t a3)
{
  CFStringForPlist_new = createCFStringForPlist_new(a2, a3);
  if (CFStringForPlist_new)
  {
    CFStringRef v5 = CFStringForPlist_new;
    CFIndex Length = CFStringGetLength(CFStringForPlist_new);
    CFIndex v7 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 4;
    unint64_t v8 = (char *)malloc_type_malloc(v7, 0x748A3EB9uLL);
    if (v8)
    {
      CFIndex v9 = v8;
      if (CFStringGetCString(v5, v8, v7, 0x8000100u)) {
        fputs(v9, a1);
      }
      CFRelease(v5);
      free(v9);
    }
    else
    {
      CFRelease(v5);
    }
  }
}

__CFString *createCFStringForPlist_new(const void *a1, uint64_t a2)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringRef v5 = Mutable;
  if (Mutable) {
    _appendPlist(Mutable, a1, a1, a2, 0);
  }
  return v5;
}

void showPList_new(const void *a1, uint64_t a2)
{
}

void _appendPlist(__CFString *a1, const void *a2, const void *a3, uint64_t a4, int a5)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  int v10 = 4 * (a2 != a3);
  CFTypeID v11 = CFGetTypeID(a2);
  if (v11 == CFDictionaryGetTypeID())
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
    BOOL v13 = Count < 0;
    uint64_t v53 = Count;
    if (Count >= 0) {
      unint64_t v14 = Count;
    }
    else {
      unint64_t v14 = -Count;
    }
    if (Count >= 0) {
      size_t v15 = 8 * v14;
    }
    else {
      size_t v15 = -8 * v14;
    }
    if (!(8 * v14)) {
      BOOL v13 = 0;
    }
    if (!(v14 >> 61) && !v13)
    {
      keys = (void **)malloc_type_malloc(v15, 0x10AB4EB7uLL);
      if (keys)
      {
        __int16 v16 = (const void **)malloc_type_malloc(v15, 0x1A7C8BD4uLL);
        if (v16)
        {
          int v17 = v16;
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a2, (const void **)keys, v16);
          if (a4 != 2 || a2 != a3)
          {
            if (a4 == 2) {
              __int16 v18 = "\n";
            }
            else {
              __int16 v18 = "{\n";
            }
            CFStringAppendCString(a1, v18, 0x8000100u);
          }
          if (v53 >= 1)
          {
            uint64_t v19 = 0;
            BOOL v51 = a2 != a3;
            uint64_t v20 = (v10 + a5);
            if (a4 == 2) {
              int v21 = "";
            }
            else {
              int v21 = "\"";
            }
            __int16 v22 = " = ";
            if (a4 == 2) {
              __int16 v22 = ": ";
            }
            cStr = (char *)v22;
            do
            {
              if (v20)
              {
                int v23 = v20;
                do
                {
                  CFStringAppendCString(a1, " ", 0x8000100u);
                  --v23;
                }
                while (v23);
              }
              CFStringAppendFormat(a1, 0, @"%s%@%s", v21, keys[v19], v21);
              CFTypeID TypeID = CFBooleanGetTypeID();
              CFTypeID v25 = CFGetTypeID(v17[v19]);
              if (a4 == 2 && TypeID == v25)
              {
                CFStringAppendFormat(a1, 0, @"\n");
                ++v19;
              }
              else
              {
                CFStringAppendCString(a1, cStr, 0x8000100u);
                CFTypeID v26 = CFGetTypeID(v17[v19]);
                if (v26 == CFStringGetTypeID())
                {
                  CFIndex Length = CFStringGetLength((CFStringRef)keys[v19]);
                  if (Length + v20 + CFStringGetLength((CFStringRef)v17[v19]) >= 73)
                  {
                    CFStringAppendCString(a1, "\n", 0x8000100u);
                    if (v20 != -4)
                    {
                      int v28 = v20 + 4;
                      do
                      {
                        CFStringAppendCString(a1, " ", 0x8000100u);
                        --v28;
                      }
                      while (v28);
                    }
                  }
                }
                _appendPlist(a1, v17[v19++], a3, a4, v20);
                BOOL v29 = a4 != 2;
                if (v19 >= v53) {
                  BOOL v29 = 1;
                }
                if (!v29 && !v51) {
                  CFStringAppendCString(a1, "\n", 0x8000100u);
                }
              }
            }
            while (v19 != v53);
          }
          if (a4 != 2)
          {
            for (; a5; --a5)
              CFStringAppendCString(a1, " ", 0x8000100u);
            CFStringAppendCString(a1, "}\n", 0x8000100u);
          }
          free(keys);
          uint64_t v30 = (void **)v17;
        }
        else
        {
          uint64_t v30 = keys;
        }
        free(v30);
      }
    }
    return;
  }
  if (v11 != CFArrayGetTypeID())
  {
    if (v11 == CFStringGetTypeID())
    {
      if (a5) {
        BOOL v39 = a4 == 2;
      }
      else {
        BOOL v39 = 1;
      }
      char v40 = "\"";
      if (v39) {
        char v40 = "";
      }
      CFStringAppendFormat(a1, 0, @"%s%@%s", v40, a2, v40);
      goto LABEL_73;
    }
    if (v11 == CFURLGetTypeID())
    {
      CFURLRef v41 = CFURLCopyAbsoluteURL((CFURLRef)a2);
      if (v41)
      {
        CFURLRef v42 = v41;
        CFStringRef v43 = CFURLCopyFileSystemPath((CFURLRef)a2, kCFURLPOSIXPathStyle);
        if (v43)
        {
          CFStringRef v44 = v43;
          CFURLGetFileSystemRepresentation((CFURLRef)a2, 1u, buffer, 1024);
          CFStringAppendCString(a1, (const char *)buffer, 0x8000100u);
          CFRelease(v42);
          uint64_t v45 = v44;
        }
        else
        {
          uint64_t v45 = v42;
        }
        CFRelease(v45);
      }
      CFStringAppendCString(a1, "\n", 0x8000100u);
      return;
    }
    if (v11 == CFDataGetTypeID())
    {
      CFStringForCFDataRef Data = createCFStringForData((const __CFData *)a2, 16);
      if (CFStringForData)
      {
        uint64_t v47 = CFStringForData;
        CFStringAppend(a1, CFStringForData);
        CFStringAppendCString(a1, "\n", 0x8000100u);
        CFRelease(v47);
        return;
      }
      uint64_t v38 = "(data object)\n";
    }
    else
    {
      if (v11 == CFNumberGetTypeID())
      {
        CFStringAppendFormat(a1, 0, @"%@", a2);
LABEL_73:
        uint64_t v38 = "\n";
        goto LABEL_74;
      }
      if (v11 == CFBooleanGetTypeID())
      {
        int Value = CFBooleanGetValue((CFBooleanRef)a2);
        long long v49 = "true";
        if (!Value) {
          long long v49 = "false";
        }
        CFStringAppendFormat(a1, 0, @"%s\n", v49);
        return;
      }
      if (v11 == CFDateGetTypeID()) {
        uint64_t v38 = "(date object)\n";
      }
      else {
        uint64_t v38 = "(unknown object)\n";
      }
    }
LABEL_74:
    CFStringAppendCString(a1, v38, 0x8000100u);
    return;
  }
  CFIndex v31 = CFArrayGetCount((CFArrayRef)a2);
  if (a4 != 2 || a2 == a3) {
    uint64_t v33 = "(\n";
  }
  else {
    uint64_t v33 = "\n";
  }
  CFStringAppendCString(a1, v33, 0x8000100u);
  if (v31 >= 1)
  {
    CFIndex v34 = 0;
    uint64_t v35 = (v10 + a5);
    do
    {
      if (v35)
      {
        int v36 = v35;
        do
        {
          CFStringAppendCString(a1, " ", 0x8000100u);
          --v36;
        }
        while (v36);
      }
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v34);
      _appendPlist(a1, ValueAtIndex, a3, a4, v35);
      ++v34;
    }
    while (v34 != v31);
  }
  if (a4 != 2)
  {
    for (; a5; --a5)
      CFStringAppendCString(a1, " ", 0x8000100u);
    uint64_t v38 = ")\n";
    goto LABEL_74;
  }
}

IOPSLowBatteryWarningLevel IOPSGetBatteryWarningLevel(void)
{
  IOPSLowBatteryWarningLevel v0 = kIOPSLowBatteryWarningNone;
  IOPSLowBatteryWarningLevel valuePtr = kIOPSLowBatteryWarningNone;
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unsigned int v2 = _io_SCDynamicStoreCreate(*MEMORY[0x1E4F1CF80], @"IOKit Power Source Copy", 0, 0);
  if (v2)
  {
    CFIndex v3 = v2;
    CFStringRef v4 = _io_SCDynamicStoreKeyCreate(v1, @"%@%@", @"State:", @"/IOKit/LowBatteryWarning");
    if (v4)
    {
      CFStringRef v5 = v4;
      int v6 = _io_SCDynamicStoreCopyValue((uint64_t)v3, (uint64_t)v4);
      if (v6)
      {
        CFNumberRef v7 = (const __CFNumber *)v6;
        CFTypeID TypeID = CFNumberGetTypeID();
        if (CFGetTypeID(v7) == TypeID) {
          CFNumberGetValue(v7, kCFNumberIntType, &valuePtr);
        }
        CFRelease(v7);
      }
      CFRelease(v3);
      CFRelease(v5);
      return valuePtr;
    }
    else
    {
      CFRelease(v3);
    }
  }
  return v0;
}

CFTimeInterval IOPSGetTimeRemainingEstimate(void)
{
  int out_token = 0;
  uint64_t v2 = 0;
  double v0 = -2.0;
  if (!notify_register_check("com.apple.system.powersources.timeremaining", &out_token))
  {
    notify_get_state(out_token, &v2);
    notify_cancel(out_token);
    if ((v2 & 0x90000) == 0x80000)
    {
      double v0 = -1.0;
      if ((v2 & 0x40000) == 0) {
        return (double)(unsigned __int16)v2 * 60.0;
      }
    }
  }
  return v0;
}

void __IOPSCopyExternalPowerAdapterDetails_block_invoke(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    __IOPSCopyExternalPowerAdapterDetails_block_invoke_cold_1(a2);
  }
}

CFRunLoopSourceRef IOPSNotificationCreateRunLoopSource(IOPowerSourceCallbackType callback, void *context)
{
  return doCreatePSRLS("com.apple.system.powersources.timeremaining", (uint64_t)callback, (uint64_t)context);
}

CFRunLoopSourceRef doCreatePSRLS(const char *a1, uint64_t a2, uint64_t a3)
{
  *(void *)int out_token = 0;
  Boolean shouldFreeInfo = 0;
  if (notify_register_mach_port(a1, (mach_port_t *)out_token, 0, &out_token[1])) {
    return 0;
  }
  int v6 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A0040E9DA1FB1uLL);
  *int v6 = a2;
  v6[1] = a3;
  *((_DWORD *)v6 + 4) = out_token[1];
  context.version = 0;
  context.retain = 0;
  context.info = v6;
  context.release = (void (__cdecl *)(const void *))IOPSRLSMachPortRelease;
  context.copyDescription = 0;
  unsigned int v7 = 5;
  do
  {
    unint64_t v8 = CFMachPortCreateWithPort(0, out_token[0], (CFMachPortCallBack)IOPSRLSMachPortCallback, &context, &shouldFreeInfo);
    if (v8) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = shouldFreeInfo == 0;
    }
  }
  while (!v9 && v7-- > 1);
  CFTypeID v11 = v8;
  if (!v8) {
    return 0;
  }
  if (shouldFreeInfo)
  {
    CFRunLoopSourceRef RunLoopSource = 0;
  }
  else
  {
    v6[3] = v8;
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(0, v8, 0);
  }
  CFRelease(v11);
  return RunLoopSource;
}

CFRunLoopSourceRef IOPSCreateLimitedPowerNotification(IOPowerSourceCallbackType callback, void *context)
{
  return doCreatePSRLS("com.apple.system.powersources.source", (uint64_t)callback, (uint64_t)context);
}

CFRunLoopSourceRef IOPSAccNotificationCreateRunLoopSource(uint64_t a1, uint64_t a2)
{
  return doCreatePSRLS("com.apple.system.accpowersources.timeremaining", a1, a2);
}

CFRunLoopSourceRef IOPSAccCreateLimitedPowerNotification(uint64_t a1, uint64_t a2)
{
  return doCreatePSRLS("com.apple.system.accpowersources.source", a1, a2);
}

CFRunLoopSourceRef IOPSAccCreateAttachNotification(uint64_t a1, uint64_t a2)
{
  return doCreatePSRLS("com.apple.system.accpowersources.attach", a1, a2);
}

void IOPSRLSMachPortRelease(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 4);
    if (v2) {
      notify_cancel(v2);
    }
    CFIndex v3 = (__CFMachPort *)*((void *)a1 + 3);
    if (v3)
    {
      CFMachPortInvalidate(v3);
      CFRelease(*((CFTypeRef *)a1 + 3));
    }
    free(a1);
  }
}

__CFArray *IOPSCopyInternalBatteriesArray(const void *a1)
{
  CFArrayRef v2 = IOPSCopyPowerSourcesList(a1);
  if (v2)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (CFGetTypeID(v2) != TypeID)
    {
      CFMutableArrayRef Mutable = 0;
      goto LABEL_18;
    }
  }
  int Count = CFArrayGetCount(v2);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (!Mutable) {
    goto LABEL_14;
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
      CFDictionaryRef v8 = IOPSGetPowerSourceDescription(a1, ValueAtIndex);
      CFTypeID v9 = CFDictionaryGetTypeID();
      if (v8)
      {
        if (CFGetTypeID(v8) == v9)
        {
          int Value = CFDictionaryGetValue(v8, @"Transport Type");
          CFTypeID v11 = CFStringGetTypeID();
          if (Value)
          {
            if (CFGetTypeID(Value) == v11 && CFEqual(Value, @"Internal")) {
              CFArrayAppendValue(Mutable, ValueAtIndex);
            }
          }
        }
      }
    }
  }
  if (CFArrayGetCount(Mutable))
  {
LABEL_14:
    if (!v2) {
      return Mutable;
    }
    goto LABEL_18;
  }
  CFRelease(Mutable);
  CFMutableArrayRef Mutable = 0;
  if (v2) {
LABEL_18:
  }
    CFRelease(v2);
  return Mutable;
}

__CFArray *IOPSCopyUPSArray(const void *a1)
{
  CFArrayRef v2 = IOPSCopyPowerSourcesList(a1);
  if (v2)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (CFGetTypeID(v2) != TypeID)
    {
      CFMutableArrayRef Mutable = 0;
      goto LABEL_20;
    }
  }
  int Count = CFArrayGetCount(v2);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (!Mutable) {
    goto LABEL_16;
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
      CFDictionaryRef v8 = IOPSGetPowerSourceDescription(a1, ValueAtIndex);
      CFTypeID v9 = CFDictionaryGetTypeID();
      if (v8)
      {
        if (CFGetTypeID(v8) == v9)
        {
          int Value = CFDictionaryGetValue(v8, @"Transport Type");
          CFTypeID v11 = CFStringGetTypeID();
          if (Value)
          {
            if (CFGetTypeID(Value) == v11
              && (CFEqual(Value, @"Serial") || CFEqual(Value, @"USB") || CFEqual(Value, @"Ethernet")))
            {
              CFArrayAppendValue(Mutable, ValueAtIndex);
            }
          }
        }
      }
    }
  }
  if (CFArrayGetCount(Mutable))
  {
LABEL_16:
    if (!v2) {
      return Mutable;
    }
    goto LABEL_20;
  }
  CFRelease(Mutable);
  CFMutableArrayRef Mutable = 0;
  if (v2) {
LABEL_20:
  }
    CFRelease(v2);
  return Mutable;
}

__CFArray *IOPSGetActiveUPS(const void *a1)
{
  uint64_t result = IOPSCopyUPSArray(a1);
  if (result)
  {
    CFArrayRef v2 = result;
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(result, 0);
    CFRelease(v2);
    return (__CFArray *)ValueAtIndex;
  }
  return result;
}

__CFArray *IOPSGetActiveBattery(const void *a1)
{
  uint64_t result = IOPSCopyInternalBatteriesArray(a1);
  if (result)
  {
    CFArrayRef v2 = result;
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(result, 0);
    CFRelease(v2);
    return (__CFArray *)ValueAtIndex;
  }
  return result;
}

uint64_t IOPSPowerSourceSupported(const void *a1, const void *a2)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID) {
    goto LABEL_17;
  }
  if (CFEqual(a2, @"AC Power")) {
    goto LABEL_4;
  }
  if (CFEqual(a2, @"Battery Power"))
  {
    io_registry_entry_t v6 = IORegistryEntryFromPath(0, "IODeviceTree:/product");
    if (v6)
    {
      io_object_t v7 = v6;
      CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v6, @"builtin-battery", 0, 0);
      IOObjectRelease(v7);
      if (CFProperty)
      {
        CFTypeID v9 = CFGetTypeID(CFProperty);
        if (v9 == CFDataGetTypeID())
        {
          CFDataGetBytePtr((CFDataRef)CFProperty);
          if ((unint64_t)CFDataGetLength((CFDataRef)CFProperty) <= 8) {
            CFDataGetLength((CFDataRef)CFProperty);
          }
          __memcpy_chk();
          CFRelease(CFProperty);
        }
      }
    }
  }
  if (a1
    && (CFEqual(a2, @"Battery Power") && IOPSGetActiveBattery(a1)
     || CFEqual(a2, @"UPS Power") && IOPSGetActiveUPS(a1)))
  {
LABEL_4:
    uint64_t v5 = MEMORY[0x1E4F1CFD0];
  }
  else
  {
LABEL_17:
    uint64_t v5 = MEMORY[0x1E4F1CFC8];
  }
  return *(void *)v5;
}

dispatch_queue_t _getPSDispatchQueue()
{
  dispatch_queue_t result = (dispatch_queue_t)_getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    dispatch_queue_t result = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)result;
  }
  return result;
}

uint64_t IOPSCreatePowerSource(uint64_t a1)
{
  uint64_t v6 = 0;
  io_object_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = 0;
  CFArrayRef v2 = _getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    CFArrayRef v2 = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)v2;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __IOPSCreatePowerSource_block_invoke;
  v5[3] = &unk_1E5489790;
  v5[4] = &v6;
  void v5[5] = a1;
  dispatch_sync(v2, v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __IOPSCreatePowerSource_block_invoke(uint64_t a1)
{
  if (!*(void *)(a1 + 40))
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    int v7 = -536870206;
LABEL_9:
    *(_DWORD *)(v6 + 24) = v7;
    return;
  }
  CFArrayRef v2 = (int *)malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
  if (!v2)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    int v7 = -536870200;
    goto LABEL_9;
  }
  uint64_t v3 = v2;
  int PowerSource = createPowerSource((uint64_t)v2);
  uint64_t v5 = *(int ***)(a1 + 40);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = PowerSource;
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    *uint64_t v5 = 0;
    free(v3);
  }
  else
  {
    *uint64_t v5 = v3;
    uint64_t v8 = _getPSDispatchQueue_psQ;
    if (!_getPSDispatchQueue_psQ)
    {
      uint64_t v8 = dispatch_queue_create("Power Management power source queue", 0);
      _getPSDispatchQueue_psQ = (uint64_t)v8;
    }
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __IOPSCreatePowerSource_block_invoke_2;
    handler[3] = &__block_descriptor_tmp_5;
    handler[4] = v3;
    notify_register_dispatch("com.apple.system.powermanagement.assertionresync", v3 + 3, v8, handler);
  }
}

uint64_t createPowerSource(uint64_t a1)
{
  int v5 = 0;
  unsigned int v4 = _pm_connect(&v5);
  if (v4)
  {
    int v2 = -536870195;
  }
  else
  {
    if (!io_ps_new_pspowersource(v5, (_DWORD *)(a1 + 8), &v4)) {
      goto LABEL_6;
    }
    int v2 = -536870163;
  }
  unsigned int v4 = v2;
LABEL_6:
  if (v5) {
    _pm_disconnect();
  }
  return v4;
}

uint64_t __IOPSCreatePowerSource_block_invoke_2(uint64_t a1)
{
  int PowerSource = createPowerSource(*(void *)(a1 + 32));
  if (PowerSource) {
    asl_log(0, 0, 3, "createPowerSource returned 0x%x\n", PowerSource);
  }
  uint64_t result = setPowerSourceDetails(*(void *)(a1 + 32), **(const void ***)(a1 + 32));
  if (result) {
    return asl_log(0, 0, 3, "setPowerSourceDetails returned 0x%x\n", result);
  }
  return result;
}

uint64_t setPowerSourceDetails(uint64_t a1, const void *a2)
{
  uint64_t v2 = 3758097090;
  mach_port_t v16 = 0;
  if (a1)
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (a2)
    {
      if (CFGetTypeID(a2) == TypeID)
      {
        if (*(_DWORD *)(a1 + 8))
        {
          CFDataRef v6 = IOCFSerialize(a2, 0);
          if (v6)
          {
            CFDataRef v7 = v6;
            unsigned int v17 = _pm_connect(&v16);
            if (v17)
            {
              unsigned int v17 = -536870195;
            }
            else
            {
              mach_port_t v8 = v16;
              int v9 = *(_DWORD *)(a1 + 8);
              BytePtr = CFDataGetBytePtr(v7);
              int Length = CFDataGetLength(v7);
              io_ps_update_pspowersource(v8, v9, (uint64_t)BytePtr, Length, (int *)&v17);
              if (!v17)
              {
                MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a2);
                CFTypeRef v13 = *(CFTypeRef *)a1;
                CFTypeID v14 = CFDictionaryGetTypeID();
                if (v13 && CFGetTypeID(v13) == v14) {
                  CFRelease(*(CFTypeRef *)a1);
                }
                *(void *)a1 = MutableCopy;
              }
              _pm_disconnect();
            }
            CFRelease(v7);
            return v17;
          }
        }
      }
    }
  }
  return v2;
}

uint64_t IOPSSetPowerSourceDetails(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  unsigned int v4 = _getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    unsigned int v4 = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)v4;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IOPSSetPowerSourceDetails_block_invoke;
  block[3] = &unk_1E54897B8;
  block[4] = &v8;
  void block[5] = a1;
  void block[6] = a2;
  dispatch_sync(v4, block);
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t __IOPSSetPowerSourceDetails_block_invoke(uint64_t a1)
{
  uint64_t result = setPowerSourceDetails(*(void *)(a1 + 40), *(const void **)(a1 + 48));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t IOPSReleasePowerSource(uint64_t a1)
{
  uint64_t v6 = 0;
  CFDataRef v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = 0;
  uint64_t v2 = _getPSDispatchQueue_psQ;
  if (!_getPSDispatchQueue_psQ)
  {
    uint64_t v2 = dispatch_queue_create("Power Management power source queue", 0);
    _getPSDispatchQueue_psQ = (uint64_t)v2;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = __IOPSReleasePowerSource_block_invoke;
  v5[3] = &unk_1E54897E0;
  v5[4] = &v6;
  void v5[5] = a1;
  dispatch_sync(v2, v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __IOPSReleasePowerSource_block_invoke(uint64_t a1)
{
  int v4 = 0;
  if (*(void *)(a1 + 40))
  {
    if (!_pm_connect(&v4))
    {
      io_ps_release_pspowersource(v4, *(_DWORD *)(*(void *)(a1 + 40) + 8));
      _pm_disconnect();
    }
    notify_cancel(*(_DWORD *)(*(void *)(a1 + 40) + 12));
    uint64_t v2 = **(const void ***)(a1 + 40);
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (v2)
    {
      if (CFGetTypeID(v2) == TypeID) {
        CFRelease(**(CFTypeRef **)(a1 + 40));
      }
    }
    **(void **)(a1 + 40) = 0;
    free(*(void **)(a1 + 40));
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -536870206;
  }
}

uint64_t IOPSGaugingMitigationGetState(uint64_t *a1)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t uint64 = 3758097085;
  PMQueue = getPMQueue();
  char valuePtr = 1;
  if (!a1) {
    return 3758097090;
  }
  int v4 = PMQueue;
  if (!PMQueue) {
    return 3758097089;
  }
  values = 0;
  keys[0] = 0;
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
  if (mach_service)
  {
    uint64_t v6 = mach_service;
    xpc_connection_set_target_queue(mach_service, v4);
    xpc_connection_set_event_handler(v6, &__block_literal_global_5);
    xpc_connection_resume(v6);
    xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
    if (v7)
    {
      uint64_t v8 = v7;
      keys[0] = @"batteryGaugingMitigationAction";
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, &valuePtr);
      CFDictionaryRef v10 = CFDictionaryCreate(v9, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v11 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      CFRelease(v10);
      CFRelease(values);
      values = 0;
      xpc_dictionary_set_value(v8, "batteryGaugingMitigation", v11);
      xpc_object_t v12 = xpc_connection_send_message_with_reply_sync(v6, v8);
      if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590])
      {
        uint64_t uint64 = xpc_dictionary_get_uint64(v12, "returnCode");
        if (!uint64)
        {
          xpc_dictionary_get_value(v12, "batteryGaugingMitigationState");
          *a1 = _CFXPCCreateCFObjectFromXPCObject();
        }
      }
      else
      {
        uint64_t uint64 = 3758097087;
      }
      if (v11) {
        xpc_release(v11);
      }
      if (v12) {
        xpc_release(v12);
      }
      xpc_release(v8);
    }
    else
    {
      BOOL v21 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v21) {
        IOPSGaugingMitigationGetState_cold_2(v21, v22, v23, v24, v25, v26, v27, v28);
      }
    }
    xpc_release(v6);
  }
  else
  {
    BOOL v13 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    uint64_t uint64 = 3758097088;
    if (v13) {
      IOPSGaugingMitigationGetState_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  return uint64;
}

void __IOPSGaugingMitigationGetState_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    __IOPSGaugingMitigationGetState_block_invoke_cold_1();
  }
}

uint64_t IOPSLimitBatteryLevelRegister(uint64_t *a1)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t uint64 = 3758097084;
  PMQueue = getPMQueue();
  char valuePtr = 1;
  if (!a1) {
    return 3758097090;
  }
  int v4 = PMQueue;
  if (PMQueue)
  {
    values = 0;
    keys[0] = 0;
    xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      uint64_t v6 = mach_service;
      xpc_connection_set_target_queue(mach_service, v4);
      xpc_connection_set_event_handler(v6, &__block_literal_global_49);
      xpc_connection_resume(v6);
      xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
      if (!v7)
      {
        BOOL v21 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        uint64_t uint64 = 3758097085;
        if (v21) {
          IOPSGaugingMitigationGetState_cold_2(v21, v22, v23, v24, v25, v26, v27, v28);
        }
        goto LABEL_18;
      }
      uint64_t v8 = v7;
      keys[0] = @"chargeSocLimitAction";
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, &valuePtr);
      CFDictionaryRef v10 = CFDictionaryCreate(v9, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v11 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      CFRelease(v10);
      CFRelease(values);
      xpc_dictionary_set_value(v8, "chargeSocLimit", v11);
      xpc_object_t v12 = xpc_connection_send_message_with_reply_sync(v6, v8);
      if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590])
      {
        uint64_t uint64 = xpc_dictionary_get_uint64(v12, "returnCode");
        if (uint64) {
          goto LABEL_13;
        }
        if (xpc_dictionary_get_value(v12, "chargeSocLimitToken"))
        {
          uint64_t v30 = _CFXPCCreateCFObjectFromXPCObject();
          uint64_t uint64 = 3758097084;
          if (v30)
          {
            uint64_t uint64 = 0;
            *a1 = v30;
          }
          goto LABEL_13;
        }
      }
      uint64_t uint64 = 3758097084;
LABEL_13:
      if (v11) {
        xpc_release(v11);
      }
      if (v12) {
        xpc_release(v12);
      }
      xpc_release(v8);
LABEL_18:
      xpc_release(v6);
      return uint64;
    }
    BOOL v13 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v13) {
      IOPSGaugingMitigationGetState_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
    }
  }
  return uint64;
}

void __IOPSLimitBatteryLevelRegister_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    __IOPSGaugingMitigationGetState_block_invoke_cold_1();
  }
}

uint64_t IOPSLimitBatteryLevelCancel(const void *a1)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t uint64 = 3758097084;
  PMQueue = getPMQueue();
  char valuePtr = 2;
  if (!a1) {
    return 3758097090;
  }
  int v4 = PMQueue;
  if (PMQueue)
  {
    xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      uint64_t v6 = mach_service;
      xpc_connection_set_target_queue(mach_service, v4);
      xpc_connection_set_event_handler(v6, &__block_literal_global_57);
      xpc_connection_resume(v6);
      xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
      if (v7)
      {
        uint64_t v8 = v7;
        keys[0] = @"chargeSocLimitAction";
        CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, &valuePtr);
        keys[1] = @"chargeSocLimitToken";
        values = v10;
        CFTypeRef cf = a1;
        CFRetain(a1);
        CFDictionaryRef v11 = CFDictionaryCreate(v9, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        xpc_object_t v12 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        CFRelease(v11);
        CFRelease(values);
        CFRelease(cf);
        xpc_dictionary_set_value(v8, "chargeSocLimit", v12);
        xpc_object_t v13 = xpc_connection_send_message_with_reply_sync(v6, v8);
        if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590]) {
          uint64_t uint64 = xpc_dictionary_get_uint64(v13, "returnCode");
        }
        if (v12) {
          xpc_release(v12);
        }
        if (v13) {
          xpc_release(v13);
        }
        xpc_release(v8);
        xpc_release(v6);
        if (!uint64) {
          CFRelease(a1);
        }
      }
      else
      {
        BOOL v22 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        if (v22) {
          IOPSGaugingMitigationGetState_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
        }
        xpc_release(v6);
        return 3758097085;
      }
    }
    else
    {
      BOOL v14 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v14) {
        IOPSGaugingMitigationGetState_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
      }
    }
  }
  return uint64;
}

void __IOPSLimitBatteryLevelCancel_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    __IOPSGaugingMitigationGetState_block_invoke_cold_1();
  }
}

uint64_t IOPSLimitBatteryLevel(void *a1, char a2, char a3, const __CFString *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t uint64 = 3758097084;
  char v39 = a2;
  PMQueue = getPMQueue();
  char v38 = a3 & 1;
  BOOL v37 = (a3 & 2) != 0;
  char valuePtr = 3;
  uint64_t result = 3758097090;
  if (!a1 || !a4) {
    return result;
  }
  if (!PMQueue) {
    return 3758097084;
  }
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  *(_OWORD *)keys = 0u;
  *(_OWORD *)values = 0u;
  long long v41 = 0u;
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
  if (!mach_service)
  {
    BOOL v20 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v20) {
      IOPSGaugingMitigationGetState_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
    }
    return 3758097084;
  }
  CFDictionaryRef v11 = mach_service;
  xpc_connection_set_target_queue(mach_service, PMQueue);
  xpc_connection_set_event_handler(v11, &__block_literal_global_63);
  xpc_connection_resume(v11);
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  if (v12)
  {
    xpc_object_t v13 = v12;
    keys[0] = @"chargeSocLimitAction";
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, &valuePtr);
    keys[1] = @"chargeSocLimitToken";
    values[0] = v15;
    values[1] = a1;
    CFRetain(a1);
    *(void *)&long long v44 = @"chargeSocLimitSoc";
    *(void *)&long long v41 = CFNumberCreate(v14, kCFNumberSInt8Type, &v39);
    *((void *)&v44 + 1) = @"chargeSocLimitDrain";
    *((void *)&v41 + 1) = CFNumberCreate(v14, kCFNumberSInt8Type, &v38);
    *(void *)&long long v45 = @"chargeSocLimitNoChargeToFull";
    *(void *)&long long v42 = CFNumberCreate(v14, kCFNumberSInt8Type, &v37);
    *((void *)&v45 + 1) = @"chargeSocLimitReason";
    *((void *)&v42 + 1) = CFStringCreateCopy(v14, a4);
    CFDictionaryRef v16 = CFDictionaryCreate(v14, (const void **)keys, (const void **)values, 6, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v17 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    CFRelease(v16);
    for (uint64_t i = 0; i != 6; ++i)
      CFRelease(values[i]);
    xpc_dictionary_set_value(v13, "chargeSocLimit", v17);
    xpc_object_t v19 = xpc_connection_send_message_with_reply_sync(v11, v13);
    if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590]) {
      uint64_t uint64 = xpc_dictionary_get_uint64(v19, "returnCode");
    }
    if (v17) {
      xpc_release(v17);
    }
    if (v19) {
      xpc_release(v19);
    }
    xpc_release(v13);
  }
  else
  {
    BOOL v28 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    uint64_t uint64 = 3758097085;
    if (v28) {
      IOPSGaugingMitigationGetState_cold_2(v28, v29, v30, v31, v32, v33, v34, v35);
    }
  }
  xpc_release(v11);
  return uint64;
}

void __IOPSLimitBatteryLevel_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    __IOPSGaugingMitigationGetState_block_invoke_cold_1();
  }
}

uint64_t IOPSCopyBatteryLevelLimits()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  PMQueue = getPMQueue();
  char valuePtr = 4;
  if (PMQueue)
  {
    CFAllocatorRef v1 = PMQueue;
    values = 0;
    keys[0] = 0;
    xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      uint64_t v3 = mach_service;
      xpc_connection_set_target_queue(mach_service, v1);
      xpc_connection_set_event_handler(v3, &__block_literal_global_78);
      xpc_connection_resume(v3);
      xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
      if (!v4)
      {
        BOOL v19 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        if (v19) {
          IOPSGaugingMitigationGetState_cold_2(v19, v20, v21, v22, v23, v24, v25, v26);
        }
        uint64_t v10 = 0;
        goto LABEL_17;
      }
      uint64_t v5 = v4;
      keys[0] = @"chargeSocLimitAction";
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, &valuePtr);
      CFDictionaryRef v7 = CFDictionaryCreate(v6, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      uint64_t v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      CFRelease(v7);
      CFRelease(values);
      xpc_dictionary_set_value(v5, "chargeSocLimit", v8);
      xpc_object_t v9 = xpc_connection_send_message_with_reply_sync(v3, v5);
      if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590]
        && !xpc_dictionary_get_uint64(v9, "returnCode")
        && xpc_dictionary_get_value(v9, "chargeSocLimit"))
      {
        uint64_t v10 = _CFXPCCreateCFObjectFromXPCObject();
        if (!v8) {
          goto LABEL_8;
        }
      }
      else
      {
        uint64_t v10 = 0;
        if (!v8)
        {
LABEL_8:
          if (v9) {
            xpc_release(v9);
          }
          xpc_release(v5);
LABEL_17:
          xpc_release(v3);
          return v10;
        }
      }
      xpc_release(v8);
      goto LABEL_8;
    }
    BOOL v11 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v11) {
      IOPSGaugingMitigationGetState_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return 0;
}

void __IOPSCopyBatteryLevelLimits_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    __IOPSGaugingMitigationGetState_block_invoke_cold_1();
  }
}

uint64_t IOPSSetBatteryDateOfFirstUse(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4)
{
  uint64_t uint64 = 3758097084;
  PMQueue = getPMQueue();
  if (!a1) {
    return 3758097090;
  }
  uint64_t v10 = PMQueue;
  if (PMQueue)
  {
    xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
    if (mach_service)
    {
      uint64_t v12 = mach_service;
      xpc_connection_set_target_queue(mach_service, v10);
      xpc_connection_set_event_handler(v12, &__block_literal_global_81);
      xpc_connection_resume(v12);
      xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
      if (v13)
      {
        uint64_t v14 = v13;
        uint64_t v15 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        if (v15)
        {
          uint64_t v16 = v15;
          xpc_dictionary_set_value(v14, "setBatteryDofu", v15);
          xpc_object_t v17 = xpc_connection_send_message_with_reply_sync(v12, v14);
          if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590]) {
            uint64_t uint64 = xpc_dictionary_get_uint64(v17, "returnCode");
          }
          else {
            uint64_t uint64 = 3758097097;
          }
          xpc_release(v16);
          if (v17) {
            xpc_release(v17);
          }
        }
        else
        {
          uint64_t uint64 = 3758097085;
        }
        xpc_release(v14);
      }
      else
      {
        BOOL v26 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
        uint64_t uint64 = 3758097085;
        if (v26) {
          IOPSGaugingMitigationGetState_cold_2(v26, v27, v28, v29, v30, v31, v32, v33);
        }
      }
      xpc_release(v12);
      if (a2 && a4 && !uint64)
      {
        v35[0] = MEMORY[0x1E4F143A8];
        v35[1] = 0x40000000;
        v35[2] = __IOPSSetBatteryDateOfFirstUse_block_invoke_83;
        v35[3] = &unk_1E54898C8;
        v35[4] = a4;
        v35[5] = a3;
        dispatch_async(a2, v35);
      }
    }
    else
    {
      BOOL v18 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v18) {
        IOPSGaugingMitigationGetState_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
      }
    }
  }
  return uint64;
}

void __IOPSSetBatteryDateOfFirstUse_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG)) {
    __IOPSSetBatteryDateOfFirstUse_block_invoke_cold_1();
  }
}

void __IOPSSetBatteryDateOfFirstUse_block_invoke_83(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40)) {
    unsigned int v2 = *(_DWORD *)(a1 + 40);
  }
  else {
    unsigned int v2 = 300;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  CFTypeRef cf = 0;
  if (!IOPSCopyPowerSourcesByTypePrecise(1, (uint64_t *)&cf))
  {
    double v5 = Current + (double)v2;
    while (cf)
    {
      CFArrayRef v6 = IOPSCopyPowerSourcesList(cf);
      CFArrayRef v4 = v6;
      if (!v6) {
        goto LABEL_6;
      }
      if (!CFArrayGetCount(v6)) {
        goto LABEL_6;
      }
      CFTypeRef v7 = cf;
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v4, 0);
      CFDictionaryRef v9 = IOPSGetPowerSourceDescription(v7, ValueAtIndex);
      if (!v9 || CFDictionaryGetValue(v9, @"Date of first use") || CFAbsoluteTimeGetCurrent() > v5) {
        goto LABEL_6;
      }
      CFRelease(v4);
      CFRelease(cf);
      CFTypeRef cf = 0;
      sleep(1u);
      if (IOPSCopyPowerSourcesByTypePrecise(1, (uint64_t *)&cf))
      {
        CFArrayRef v4 = 0;
        goto LABEL_6;
      }
    }
  }
  CFArrayRef v4 = 0;
LABEL_6:
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v4) {
    CFRelease(v4);
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t IOPSGetBatteryHealthState(uint64_t *a1)
{
  uint64_t uint64 = 3758097085;
  PMQueue = getPMQueue();
  if (!a1) {
    return 3758097090;
  }
  CFArrayRef v4 = PMQueue;
  if (!PMQueue) {
    return 3758097084;
  }
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", PMQueue, 0);
  if (mach_service)
  {
    CFArrayRef v6 = mach_service;
    xpc_connection_set_target_queue(mach_service, v4);
    xpc_connection_set_event_handler(v6, &__block_literal_global_90);
    xpc_connection_resume(v6);
    xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
    if (v7)
    {
      uint64_t v8 = v7;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFMutableDictionaryRef v10 = Mutable;
        BOOL v11 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        if (v11)
        {
          uint64_t v12 = v11;
          xpc_dictionary_set_value(v8, "getBatteryHealthState", v11);
          xpc_object_t v13 = xpc_connection_send_message_with_reply_sync(v6, v8);
          if (MEMORY[0x18C131C50]() == MEMORY[0x1E4F14590])
          {
            uint64_t uint64 = xpc_dictionary_get_uint64(v13, "returnCode");
            if (!uint64)
            {
              xpc_dictionary_get_value(v13, "IOPSPrivateBatteryHealthState");
              *a1 = _CFXPCCreateCFObjectFromXPCObject();
            }
          }
          else
          {
            uint64_t uint64 = 3758097105;
          }
          if (v13) {
            xpc_release(v13);
          }
          xpc_release(v12);
        }
        CFRelease(v10);
      }
      xpc_release(v8);
    }
    else
    {
      BOOL v22 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v22) {
        IOPSGaugingMitigationGetState_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
      }
      CFRelease((CFTypeRef)v22);
    }
    xpc_release(v6);
  }
  else
  {
    BOOL v14 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    uint64_t uint64 = 3758097088;
    if (v14) {
      IOPSGaugingMitigationGetState_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  return uint64;
}

void __IOPSGetBatteryHealthState_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG)) {
    __IOPSSetBatteryDateOfFirstUse_block_invoke_cold_1();
  }
}

void __IOPSCopyPowerSourcesByTypePrecise_block_invoke()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    __IOPSGaugingMitigationGetState_block_invoke_cold_1();
  }
}

uint64_t IOPSCopyPowerSourcesInfoPrecise(uint64_t *a1)
{
  return IOPSCopyPowerSourcesByTypePrecise(3, a1);
}

uint64_t IOPSGetYearAndWeekOfManufactureFromBatterySerial(const __CFString *a1, void *a2)
{
  if (CFStringGetLength(a1) != 17)
  {
    if (CFStringGetLength(a1) != 18) {
      return 0;
    }
    *(_DWORD *)__str = 0;
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    uint64_t v6 = 0;
    *(_WORD *)__str = *(_WORD *)(CStringPtr + 3);
    __str[2] = CStringPtr[5];
    while (1)
    {
      int v7 = __str[v6];
      if (v7 > 79) {
        break;
      }
      if (v7 >= 74)
      {
        char v8 = -1;
        goto LABEL_9;
      }
LABEL_10:
      if (++v6 == 3)
      {
        unint64_t v9 = strtoull(__str, 0, 34);
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDateRef v11 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (double)(86400 * v9) - *MEMORY[0x1E4F1CF78]);
        CFCalendarRef v12 = CFCalendarCreateWithIdentifier(v10, (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
        ISO8601Formatter = CFDateFormatterCreateISO8601Formatter(v10, 5uLL);
        CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v10, ISO8601Formatter, v11);
        CFIndex Length = CFStringGetLength(StringWithDate);
        MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(v10, Length, StringWithDate);
        v19.location = 0;
        v19.CFIndex length = 3;
        CFStringDelete(MutableCopy, v19);
        uint64_t v4 = 1;
        v20.location = 1;
        v20.CFIndex length = 1;
        CFStringDelete(MutableCopy, v20);
        *a2 = MutableCopy;
        CFRelease(v11);
        CFRelease(v12);
        CFRelease(ISO8601Formatter);
        CFRelease(StringWithDate);
        return v4;
      }
    }
    char v8 = -2;
LABEL_9:
    __str[v6] = v7 + v8;
    goto LABEL_10;
  }
  v21.location = 3;
  v21.CFIndex length = 3;
  *a2 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v21);
  return 1;
}

dispatch_queue_t __getPMQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("PM Notifications", 0);
  getPMQueue_pmQueue = (uint64_t)result;
  return result;
}

uint64_t getUserActiveValidDict()
{
  uint64_t result = getUserActiveValidDict__useractiveValid;
  if (!getUserActiveValidDict__useractiveValid)
  {
    if (getUserActiveValidDict__token != -1) {
      dispatch_once(&getUserActiveValidDict__token, &__block_literal_global_6);
    }
    uint64_t result = getUserActiveValidDict__useractiveValid;
    if (!getUserActiveValidDict__useractiveValid)
    {
      BOOL v1 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      if (v1) {
        getUserActiveValidDict_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
      }
      return 0;
    }
  }
  return result;
}

CFMutableDictionaryRef __getUserActiveValidDict_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  getUserActiveValidDict__useractiveValid = (uint64_t)result;
  return result;
}

uint64_t IOPMUserIsActive()
{
  return gIOPMUserIsActive;
}

uint64_t decodeIOPMUserIsActive(char a1)
{
  return a1 & 1;
}

void *IOPMScheduleUserActiveChangedNotification(NSObject *a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __IOPMScheduleUserActiveChangedNotification_block_invoke;
  v3[3] = &unk_1E5489970;
  v3[4] = a2;
  return IOPMScheduleUserActivityLevelNotificationWithTimeout(a1, -1, v3);
}

void *IOPMScheduleUserActivityLevelNotificationWithTimeout(NSObject *a1, int a2, const void *a3)
{
  uint64_t v6 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A00403A6C22E7uLL);
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  char v17 = 0;
  if (v6)
  {
    xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E4F14428], 0);
    if (!mach_service)
    {
      free(v6);
      goto LABEL_6;
    }
    uint64_t v8 = mach_service;
    PMQueue = getPMQueue();
    xpc_connection_set_target_queue(v8, PMQueue);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __IOPMScheduleUserActivityLevelNotificationWithTimeout_block_invoke;
    handler[3] = &__block_descriptor_tmp_18_0;
    handler[4] = v6;
    xpc_connection_set_event_handler(v8, handler);
    void v6[6] = v8;
    dispatch_retain(a1);
    *uint64_t v6 = a1;
    v6[4] = _Block_copy(a3);
    *((_DWORD *)v6 + 14) = a2;
    xpc_connection_resume(v8);
    CFAllocatorRef v10 = getPMQueue();
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __IOPMScheduleUserActivityLevelNotificationWithTimeout_block_invoke_2;
    block[3] = &unk_1E5489A20;
    block[4] = &v14;
    void block[5] = v6;
    dispatch_sync(v10, block);
    if (!*((unsigned char *)v15 + 24))
    {
      IOPMUnregisterNotification((uint64_t)v6);
LABEL_6:
      uint64_t v6 = 0;
    }
  }
  _Block_object_dispose(&v14, 8);
  return v6;
}

uint64_t __IOPMScheduleUserActiveChangedNotification_block_invoke(uint64_t result, char a2)
{
  int v2 = a2 & 1;
  if (gIOPMUserIsActive != v2)
  {
    gIOPMUserIsActive = v2;
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void IOPMUnregisterNotification(uint64_t a1)
{
  PMQueue = getPMQueue();
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IOPMUnregisterNotification_block_invoke;
  block[3] = &__block_descriptor_tmp_9;
  block[4] = a1;
  dispatch_sync(PMQueue, block);
}

void __IOPMUnregisterNotification_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  BOOL v1 = *(xpc_connection_t **)(a1 + 32);
  if (!v1 || !v1[6]) {
    return;
  }
  CFNumberRef v2 = CFNumberCreate(0, kCFNumberSInt64Type, v1);
  CFDictionaryRef UserActiveValidDict = (const __CFDictionary *)getUserActiveValidDict();
  if (!CFDictionaryGetValue(UserActiveValidDict, v2))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __IOPMUnregisterNotification_block_invoke_cold_1((uint64_t)v1, v4, v5, v6, v7, v8, v9, v10);
      if (!v2) {
        return;
      }
    }
    else if (!v2)
    {
      return;
    }
    goto LABEL_10;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    int v11 = 134217984;
    CFCalendarRef v12 = v1;
    _os_log_impl(&dword_18B46C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "IOPMUnregisterNotification: cancelling connection 0x%lx\n", (uint8_t *)&v11, 0xCu);
  }
  xpc_connection_cancel(v1[6]);
  if (v2) {
LABEL_10:
  }
    CFRelease(v2);
}

uint64_t IOPMGetUserActivityLevel(unint64_t *a1, unint64_t *a2)
{
  int out_token = 0;
  uint64_t v9 = 0;
  uint32_t v4 = notify_register_check("com.apple.system.powermanagement.useractivity2", &out_token);
  unint64_t v5 = 0;
  if (v4)
  {
    if (!a1) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  notify_get_state(out_token, &v9);
  notify_cancel(out_token);
  unint64_t v5 = v9;
  if (a1) {
LABEL_3:
  }
    *a1 = v5;
LABEL_4:
  if (a2)
  {
    unint64_t v6 = v5 & (1 << __clz(__rbit64(v5)));
    if (v5) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0;
    }
    *a2 = v7;
  }
  return 0;
}

BOOL sendUserActivityMsg(uint64_t a1, const char *a2)
{
  PMQueue = getPMQueue();
  dispatch_assert_queue_V2(PMQueue);
  if (!a1 || !*(void *)(a1 + 48))
  {
    BOOL result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sendUserActivityMsg_cold_1(result, v9, v10, v11, v12, v13, v14, v15);
    return 0;
  }
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  if (v5)
  {
    unint64_t v7 = v6;
    if (v6)
    {
      xpc_dictionary_set_uint64(v5, "ActivityTimeout", *(unsigned int *)(a1 + 56));
      xpc_dictionary_set_value(v7, a2, v5);
      xpc_connection_send_message(*(xpc_connection_t *)(a1 + 48), v7);
      xpc_release(v7);
      xpc_release(v5);
      return 1;
    }
  }
  BOOL result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
  if (result)
  {
    sendUserActivityMsg_cold_2(result, v16, v17, v18, v19, v20, v21, v22);
    return 0;
  }
  return result;
}

void processUserActivityMsg(uint64_t a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = MEMORY[0x18C131C50](a2);
  if (v4 == MEMORY[0x1E4F14590])
  {
    uint64_t uint64 = xpc_dictionary_get_uint64(a2, "UserActivityLevels");
    *(void *)(a1 + 64) = uint64;
    uint64_t v14 = 1 << __clz(__rbit64(uint64));
    if (uint64) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = _Block_copy(*(const void **)(a1 + 32));
    uint64_t v17 = *(void *)(a1 + 64);
    dispatch_object_t v18 = *(dispatch_object_t *)a1;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __processUserActivityMsg_block_invoke;
    block[3] = &unk_1E54899B8;
    block[4] = v16;
    void block[5] = v17;
    void block[6] = v15;
    uint64_t v19 = block;
    PMQueue = v18;
    goto LABEL_30;
  }
  if (v4 != MEMORY[0x1E4F145A8]) {
    return;
  }
  if (a2 == (void *)MEMORY[0x1E4F14520])
  {
    PMQueue = getPMQueue();
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 0x40000000;
    v35[2] = __processUserActivityMsg_block_invoke_2;
    v35[3] = &__block_descriptor_tmp_15;
    v35[4] = a1;
    uint64_t v19 = v35;
LABEL_30:
    dispatch_async(PMQueue, v19);
    return;
  }
  if (a2 == (void *)MEMORY[0x1E4F14550])
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      processUserActivityMsg_cold_1(a1, v21, v22, v23, v24, v25, v26, v27);
    }
  }
  else
  {
    if (a2 != (void *)MEMORY[0x1E4F14528]) {
      return;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v38 = a1;
      _os_log_error_impl(&dword_18B46C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Received connection invalid error for connection 0x%lx. UnregisterNotification", buf, 0xCu);
      if (!a1) {
        return;
      }
    }
    else if (!a1)
    {
      return;
    }
    CFDictionaryRef UserActiveValidDict = (__CFDictionary *)getUserActiveValidDict();
    CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt64Type, (const void *)a1);
    if (CFDictionaryGetValue(UserActiveValidDict, v6))
    {
      CFDictionaryRemoveValue(UserActiveValidDict, v6);
      if (v6) {
        CFRelease(v6);
      }
      unint64_t v7 = *(const void **)(a1 + 8);
      if (v7) {
        _Block_release(v7);
      }
      uint64_t v8 = *(const void **)(a1 + 32);
      if (v8) {
        _Block_release(v8);
      }
      uint64_t v9 = *(IONotificationPort **)(a1 + 16);
      if (v9) {
        IONotificationPortDestroy(v9);
      }
      io_object_t v10 = *(_DWORD *)(a1 + 24);
      if (v10) {
        IOObjectRelease(v10);
      }
      int v11 = *(_DWORD *)(a1 + 40);
      if (v11) {
        notify_cancel(v11);
      }
      uint64_t v12 = *(void **)(a1 + 48);
      if (v12) {
        xpc_release(v12);
      }
      if (*(void *)a1) {
        dispatch_release(*(dispatch_object_t *)a1);
      }
      *(void *)(a1 + 64) = 0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      free((void *)a1);
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      processUserActivityMsg_cold_2(a1, v28, v29, v30, v31, v32, v33, v34);
    }
  }
}

void __processUserActivityMsg_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  CFNumberRef v2 = *(const void **)(a1 + 32);

  _Block_release(v2);
}

BOOL __processUserActivityMsg_block_invoke_2(uint64_t a1)
{
  return sendUserActivityMsg(*(void *)(a1 + 32), "userActivityRegister");
}

void __IOPMScheduleUserActivityLevelNotificationWithTimeout_block_invoke(uint64_t a1, void *a2)
{
}

BOOL __IOPMScheduleUserActivityLevelNotificationWithTimeout_block_invoke_2(uint64_t a1)
{
  CFDictionaryRef UserActiveValidDict = (__CFDictionary *)getUserActiveValidDict();
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberSInt64Type, *(const void **)(a1 + 40));
  CFDictionarySetValue(UserActiveValidDict, v3, (const void *)*MEMORY[0x1E4F1CFD0]);
  if (v3) {
    CFRelease(v3);
  }
  BOOL result = sendUserActivityMsg(*(void *)(a1 + 40), "userActivityRegister");
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t IOPMSetUserActivityIdleTimeout(uint64_t a1, int a2)
{
  uint64_t v9 = 0;
  io_object_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = -536870199;
  PMQueue = getPMQueue();
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IOPMSetUserActivityIdleTimeout_block_invoke;
  block[3] = &unk_1E5489A48;
  block[4] = &v9;
  void block[5] = a1;
  int v8 = a2;
  dispatch_sync(PMQueue, block);
  uint64_t v5 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t __IOPMSetUserActivityIdleTimeout_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (result && *(void *)(result + 48))
  {
    *(_DWORD *)(result + 56) = *(_DWORD *)(a1 + 48);
    uint64_t result = sendUserActivityMsg(result, "userActivityTimeout");
    if (!result) {
      return result;
    }
    int v3 = 0;
  }
  else
  {
    int v3 = -536870206;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3;
  return result;
}

int *IOPMScheduleUserActivityLevelNotification(NSObject *a1, uint64_t a2)
{
  uint64_t v4 = (int *)malloc_type_calloc(1uLL, 0x48uLL, 0x10A00403A6C22E7uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    void v7[2] = __IOPMScheduleUserActivityLevelNotification_block_invoke;
    v7[3] = &unk_1E5489A70;
    void v7[4] = a2;
    void v7[5] = v4;
    if (notify_register_dispatch("com.apple.system.powermanagement.useractivity2", v4 + 10, a1, v7))
    {
      free(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t __IOPMScheduleUserActivityLevelNotification_block_invoke(uint64_t a1, int token)
{
  uint64_t state64 = 0;
  uint64_t result = notify_get_state(token, &state64);
  if (!result)
  {
    if (*(void *)(a1 + 40)) {
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    }
  }
  return result;
}

__CFString *IOPMCopyUserActivityLevelDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  int v3 = Mutable;
  if (!a1)
  {
    CFStringRef v4 = @"Inactive";
LABEL_22:
    CFStringAppend(v3, v4);
    return v3;
  }
  if (a1)
  {
    CFStringAppend(Mutable, @"PresentActive");
    if ((a1 & 2) == 0)
    {
      if ((a1 & 0x10) != 0)
      {
LABEL_16:
        CFStringAppend(v3, @" ");
LABEL_17:
        CFStringAppend(v3, @"RemoteActive");
        if ((a1 & 0x20) != 0) {
          goto LABEL_18;
        }
        goto LABEL_12;
      }
LABEL_11:
      if ((a1 & 0x20) != 0)
      {
LABEL_18:
        CFStringAppend(v3, @" ");
        goto LABEL_19;
      }
LABEL_12:
      if ((a1 & 0x40) == 0) {
        return v3;
      }
      goto LABEL_20;
    }
    CFStringAppend(v3, @" ");
LABEL_15:
    CFStringAppend(v3, @"PresentPassive");
    if ((a1 & 0x10) != 0) {
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  if ((a1 & 2) != 0) {
    goto LABEL_15;
  }
  if ((a1 & 0x10) != 0) {
    goto LABEL_17;
  }
  if ((a1 & 0x20) == 0)
  {
    if ((a1 & 0x40) == 0) {
      return v3;
    }
    goto LABEL_21;
  }
LABEL_19:
  CFStringAppend(v3, @"NotificationActive");
  if ((a1 & 0x40) != 0)
  {
LABEL_20:
    CFStringAppend(v3, @" ");
LABEL_21:
    CFStringRef v4 = @"AbsentWithDisplay";
    goto LABEL_22;
  }
  return v3;
}

uint64_t IOPMAllowRemotePowerChange(uint64_t a1, int a2)
{
  uint64_t v9 = 0;
  io_object_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = 0;
  if (a1)
  {
    PMQueue = getPMQueue();
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __IOPMAllowRemotePowerChange_block_invoke;
    block[3] = &unk_1E5489A98;
    int v8 = a2;
    block[4] = &v9;
    void block[5] = a1;
    dispatch_sync(PMQueue, block);
    uint64_t v5 = *((unsigned int *)v10 + 6);
  }
  else
  {
    uint64_t v5 = 3758097090;
  }
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t __IOPMAllowRemotePowerChange_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t input = *(void *)(v2 + 48);
  if (*(_DWORD *)(a1 + 48) == *(_DWORD *)(v2 + 40)) {
    uint64_t result = IOConnectCallScalarMethod(*(_DWORD *)(v2 + 24), 3u, &input, 1u, 0, 0);
  }
  else {
    uint64_t result = 3758097090;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void _systemPowerCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 40) = a3;
  *(void *)(a1 + 48) = a4;
  CFStringRef v4 = *(NSObject **)(a1 + 32);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___systemPowerCallback_block_invoke;
  v5[3] = &__block_descriptor_tmp_44;
  v5[4] = a1;
  int v6 = a3;
  dispatch_async(v4, v5);
}

uint64_t ___systemPowerCallback_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(a1 + 32) + 16))(**(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 0);
}

io_object_t *IOPMRegisterForRemoteSystemPower(NSObject *a1, const void *a2)
{
  kern_return_t v12;

  if (!a1) {
    return 0;
  }
  CFStringRef v4 = (io_object_t *)malloc_type_calloc(1uLL, 0x38uLL, 0x10A0040A50803A1uLL);
  if (v4)
  {
    dispatch_retain(a1);
    *((void *)v4 + 4) = a1;
    *(void *)CFStringRef v4 = _Block_copy(a2);
    IONotificationPortRef v5 = IONotificationPortCreate(0);
    *((void *)v4 + 2) = v5;
    if (v5)
    {
      int v6 = v5;
      PMQueue = getPMQueue();
      IONotificationPortSetDispatchQueue(v6, PMQueue);
    }
    CFDictionaryRef v8 = IOServiceMatching("AppleEmbeddedSleepWakeHandler");
    io_service_t MatchingService = IOServiceGetMatchingService(0, v8);
    if (MatchingService)
    {
      io_object_t v10 = MatchingService;
      if (IOServiceOpen(MatchingService, *MEMORY[0x1E4F14960], 0, v4 + 6) || !v4[6])
      {
        IOObjectRelease(v10);
      }
      else
      {
        int v12 = IOServiceAddInterestNotification(*((IONotificationPortRef *)v4 + 2), v10, "IOGeneralInterest", (IOServiceInterestCallback)_systemPowerCallback, v4, v4 + 2);
        IOObjectRelease(v10);
        if (!v12) {
          return v4;
        }
      }
    }
    IODeregisterForRemoteSystemPower((uint64_t)v4);
    return 0;
  }
  return v4;
}

void IODeregisterForRemoteSystemPower(uint64_t a1)
{
  if (a1)
  {
    PMQueue = getPMQueue();
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __IODeregisterForRemoteSystemPower_block_invoke;
    block[3] = &__block_descriptor_tmp_47_0;
    block[4] = a1;
    dispatch_sync(PMQueue, block);
  }
}

void __IODeregisterForRemoteSystemPower_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(NSObject **)(v2 + 32);
  if (v3)
  {
    dispatch_release(v3);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  if (*(void *)v2)
  {
    _Block_release(*(const void **)v2);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  CFStringRef v4 = *(IONotificationPort **)(v2 + 16);
  if (v4)
  {
    IONotificationPortDestroy(v4);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  io_object_t v5 = *(_DWORD *)(v2 + 8);
  if (v5)
  {
    IOObjectRelease(v5);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  io_connect_t v6 = *(_DWORD *)(v2 + 24);
  if (v6)
  {
    IOServiceClose(v6);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  *(void *)(v2 + 48) = 0;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  unint64_t v7 = *(void **)(a1 + 32);

  free(v7);
}

uint64_t IOPMCopyHIDPostEventHistory(CFPropertyListRef *a1)
{
  mach_vm_size_t v7 = 0;
  CFDictionaryRef v8 = 0;
  uint64_t v2 = 3758097084;
  uint64_t v6 = 0;
  if (!_pm_connect((_DWORD *)&v6 + 1)
    && !io_pm_hid_event_copy_history(SHIDWORD(v6), &v8, &v7, &v6))
  {
    CFDataRef v3 = CFDataCreate(0, v8, v7);
    if (v3)
    {
      CFDataRef v4 = v3;
      *a1 = CFPropertyListCreateWithData(0, v3, 0, 0, 0);
      CFRelease(v4);
    }
    if (*a1) {
      uint64_t v2 = 0;
    }
    else {
      uint64_t v2 = 3758097084;
    }
    mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v8, v7);
  }
  return v2;
}

uint64_t IOPMGetLastWakeTime(double *a1, void *a2)
{
  uint64_t v2 = 3758097090;
  size_t v6 = 16;
  if (a1)
  {
    if (a2)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      *a1 = 0.0;
      *a2 = 0;
      uint64_t v2 = 3758097112;
      if (!sysctlbyname("kern.waketime", &v7, &v6, 0, 0))
      {
        if (v7)
        {
          uint64_t v2 = 0;
          *a1 = (double)(int)v8 / 1000000.0 + (double)v7 - *MEMORY[0x1E4F1CF78];
          *a2 = 0;
        }
      }
    }
  }
  return v2;
}

uint64_t IOPMCopyPowerHistory(CFMutableArrayRef *a1)
{
  uint64_t v2 = 3758097084;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFDataRef v4 = opendir("/System/Library/PowerEvents");
  if (!v4) {
    return v2;
  }
  io_object_t v5 = v4;
  __stringp = 0;
  uint64_t v24 = 0;
  size_t v6 = readdir(v4);
  int v7 = 0;
  if (!v6) {
    goto LABEL_20;
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    while (1)
    {
      d_mach_port_name_t name = v6->d_name;
      if (strcmp(v6->d_name, "."))
      {
        if (strcmp(d_name, "..")) {
          break;
        }
      }
      size_t v6 = readdir(v5);
      if (!v6) {
        goto LABEL_20;
      }
    }
    theArray = Mutable;
    uint64_t v22 = a1;
    CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v20 = strdup(d_name);
    __stringp = v20;
    uint64_t v11 = strsep(&__stringp, "_");
    uint64_t v24 = v11;
    if (v11)
    {
      int v12 = v11;
      int v13 = 1;
      while (1)
      {
        if (v13 == 3)
        {
          uint64_t v24 = strsep(&v24, ".");
          CFStringRef v14 = CFStringCreateWithCString(v8, v24, 0x8000100u);
          uint64_t v15 = v10;
          uint64_t v16 = @"ClearTime";
          goto LABEL_16;
        }
        if (v13 == 2) {
          break;
        }
        if (v13 == 1)
        {
          CFStringRef v14 = CFStringCreateWithCString(v8, v12, 0x8000100u);
          uint64_t v15 = v10;
          uint64_t v16 = @"Timestamp";
LABEL_16:
          CFDictionarySetValue(v15, v16, v14);
          CFRelease(v14);
        }
        ++v13;
        int v12 = strsep(&__stringp, "_");
        uint64_t v24 = v12;
        if (!v12) {
          goto LABEL_18;
        }
      }
      CFStringRef v14 = CFStringCreateWithCString(v8, v12, 0x8000100u);
      uint64_t v15 = v10;
      uint64_t v16 = @"UUID";
      goto LABEL_16;
    }
LABEL_18:
    ++v7;
    CFArrayAppendValue(theArray, v10);
    CFMutableDictionaryRef v17 = v10;
    CFMutableArrayRef Mutable = theArray;
    CFRelease(v17);
    free(v20);
    size_t v6 = readdir(v5);
    a1 = v22;
  }
  while (v6);
  int v7 = 1;
LABEL_20:
  closedir(v5);
  if (v7) {
    CFMutableArrayRef v18 = Mutable;
  }
  else {
    CFMutableArrayRef v18 = 0;
  }
  if (v7) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = 3758097136;
  }
  *a1 = v18;
  return v2;
}

uint64_t IOPMCopyPowerHistoryDetailed(const __CFString *a1, CFPropertyListRef *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  resourceCFDataRef Data = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 255);
  CFStringAppend(Mutable, @"/System/Library/PowerEvents");
  CFStringAppend(Mutable, @"/");
  uint64_t v6 = 3758097090;
  if (!a1 || !a2) {
    goto LABEL_20;
  }
  *a2 = 0;
  if (!CFStringGetCString(a1, buffer, 128, 0))
  {
    uint64_t v6 = 3758097090;
    goto LABEL_20;
  }
  int v7 = opendir("/System/Library/PowerEvents");
  if (!v7)
  {
LABEL_19:
    uint64_t v6 = 3758097084;
    goto LABEL_20;
  }
  CFAllocatorRef v8 = v7;
  uint64_t v9 = readdir(v7);
  if (!v9)
  {
    closedir(v8);
    goto LABEL_19;
  }
  CFURLRef v10 = 0;
  do
  {
    d_mach_port_name_t name = v9->d_name;
    if (strstr(v9->d_name, buffer))
    {
      CFStringRef v12 = CFStringCreateWithCString(v4, d_name, 0x8000100u);
      CFStringAppend(Mutable, v12);
      if (v10) {
        CFRelease(v10);
      }
      CFURLRef v10 = CFURLCreateWithFileSystemPath(v4, Mutable, kCFURLPOSIXPathStyle, 0);
      CFRelease(v12);
    }
    uint64_t v9 = readdir(v8);
  }
  while (v9);
  closedir(v8);
  uint64_t v6 = 3758097084;
  if (v10)
  {
    SInt32 errorCode = 0;
    int v13 = CFURLCreateDataAndPropertiesFromResource(v4, v10, &resourceData, 0, 0, &errorCode);
    if (resourceData && v13)
    {
      *a2 = CFPropertyListCreateWithData(0, resourceData, 0, 0, 0);
      CFRelease(resourceData);
    }
    CFRelease(v10);
    uint64_t v6 = 0;
  }
LABEL_20:
  CFRelease(Mutable);
  return v6;
}

uint64_t IOPMSetSleepServicesWakeTimeCap(double a1)
{
  unsigned int v3 = -1;
  int v4 = 0;
  uint64_t result = _pm_connect(&v4);
  if (!result)
  {
    LODWORD(result) = io_pm_set_sleepservice_wake_time_cap(v4, (int)a1, &v3);
    if (v3) {
      return v3;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t IOPMSleepWakeSetUUID(const void *a1)
{
  uint64_t result = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (result)
  {
    io_object_t v3 = result;
    if (a1) {
      int v4 = a1;
    }
    else {
      int v4 = (const void *)*MEMORY[0x1E4F1CFC8];
    }
    uint64_t v5 = IORegistryEntrySetCFProperty(result, @"SleepWakeUUID", v4);
    IOObjectRelease(v3);
    return v5;
  }
  return result;
}

CFTypeRef IOPMSleepWakeCopyUUID()
{
  io_registry_entry_t v0 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v0) {
    return 0;
  }
  io_object_t v1 = v0;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v0, @"SleepWakeUUID", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  IOObjectRelease(v1);
  return CFProperty;
}

BOOL IOPMGetUUID(int a1, char *a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1 != 1001)
  {
    if (a1 == 1000)
    {
      CFStringRef v5 = (const __CFString *)IOPMSleepWakeCopyUUID();
      BOOL v6 = (BOOL)v5;
      if (v5)
      {
        int CString = CFStringGetCString(v5, a2, a3, 0x8000100u);
        CFRelease((CFTypeRef)v6);
        return CString != 0;
      }
      return v6;
    }
    return 0;
  }
  int v10 = -1;
  int v11 = 0;
  if (_pm_connect(&v11)) {
    return 0;
  }
  bzero(__src, 0x400uLL);
  int uuid = io_pm_get_uuid(v11, 1001, __src, &v10);
  BOOL v6 = (uuid | v10) == 0;
  if (!(uuid | v10))
  {
    bzero(a2, a3);
    strncpy(a2, __src, a3 - 1);
  }
  return v6;
}

uint64_t IOPMLogWakeProgress(int a1, int a2)
{
  int valuePtr = a2;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG)) {
    IOPMLogWakeProgress_cold_1();
  }
  uint64_t v3 = 3758097084;
  if ((a1 - 1) > 2) {
    return 3758097090;
  }
  CFStringRef v4 = off_1E5489D98[a1 - 1];
  io_registry_entry_t v5 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (v5)
  {
    io_registry_entry_t v6 = v5;
    CFNumberRef v7 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (v7)
    {
      CFNumberRef v8 = v7;
      uint64_t v3 = IORegistryEntrySetCFProperty(v6, v4, v7);
      CFRelease(v8);
    }
    IOObjectRelease(v6);
  }
  return v3;
}

uint64_t (*IOPMCopySleepWakeFailure())(uint64_t, uint64_t)
{
  io_registry_entry_t v0 = _io_SCDynamicStoreCreate(0, @"IOPMSleepFailure", 0, 0);
  if (!v0) {
    return 0;
  }
  io_object_t v1 = v0;
  CFStringRef v2 = _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"%@%@/%@", @"State:", @"PowerManagement", @"SleepFailure");
  if (v2)
  {
    CFStringRef v3 = v2;
    CFStringRef v4 = _io_SCDynamicStoreCopyValue((uint64_t)v1, (uint64_t)v2);
    if (v4)
    {
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v4) != TypeID)
      {
        CFRelease(v4);
        CFStringRef v4 = 0;
      }
    }
    CFRelease(v1);
  }
  else
  {
    CFStringRef v4 = 0;
    CFStringRef v3 = (CFStringRef)v1;
  }
  CFRelease(v3);
  return v4;
}

void IOPMClaimSystemWakeEvent(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (mach_service)
  {
    CFNumberRef v8 = mach_service;
    xpc_connection_set_target_queue(mach_service, global_queue);
    xpc_connection_set_event_handler(v8, &__block_literal_global_95_0);
    xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
    if (v9)
    {
      if (a1)
      {
        CFStringGetCString(a1, buffer, 255, 0x8000100u);
        xpc_dictionary_set_string(v9, "identity", buffer);
      }
      if (a2)
      {
        CFStringGetCString(a2, buffer, 255, 0x8000100u);
        xpc_dictionary_set_string(v9, "reason", buffer);
      }
      if (a3)
      {
        int v10 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        if (v10)
        {
          int v11 = v10;
          xpc_dictionary_set_value(v9, "description", v10);
          xpc_release(v11);
        }
      }
    }
    xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
    if (v12)
    {
      uint64_t v13 = v12;
      xpc_dictionary_set_value(v12, "claimSystemWakeEvent", v9);
      xpc_connection_resume(v8);
      xpc_connection_send_message(v8, v13);
      xpc_release(v13);
    }
    if (v9) {
      xpc_release(v9);
    }
    xpc_release(v8);
  }
}

uint64_t IOPMSetActivePushConnectionState(int a1)
{
  return IOPMSetValueInt(11, a1);
}

uint64_t IOPMSetValueInt(int a1, int a2)
{
  unsigned int v5 = -536870212;
  int v6 = 0;
  if (_pm_connect(&v6)) {
    return 3758097112;
  }
  io_pm_set_value_int(v6, a1, a2, &v5);
  return v5;
}

uint64_t IOPMGetActivePushConnectionState(BOOL *a1)
{
  if (!a1) {
    return 3758097090;
  }
  int v2 = IOPMGetValueInt(11);
  uint64_t result = 0;
  *a1 = v2 != 0;
  return result;
}

uint64_t IOPMGetValueInt(int a1)
{
  uint64_t v4 = 0;
  int v2 = _pm_connect((_DWORD *)&v4 + 1);
  uint64_t result = 0;
  if (!v2)
  {
    if (io_pm_get_value_int(SHIDWORD(v4), a1, &v4)) {
      return 0;
    }
    else {
      return v4;
    }
  }
  return result;
}

uint64_t IOPMConnectionSetNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 3758097090;
  if (a1)
  {
    if (a3)
    {
      uint64_t result = 0;
      *(void *)(a1 + 56) = a3;
      *(void *)(a1 + 64) = a2;
    }
  }
  return result;
}

uint64_t IOPMConnectionScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  int v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v13 = -536870212;
  uint64_t v3 = 3758097090;
  if (a1 && a2 && a3)
  {
    PMQueue = getPMQueue();
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    void v9[2] = __IOPMConnectionScheduleWithRunLoop_block_invoke;
    v9[3] = &unk_1E5489B20;
    v9[4] = &v10;
    _OWORD v9[5] = a1;
    v9[6] = a2;
    v9[7] = a3;
    dispatch_sync(PMQueue, v9);
    uint64_t v3 = *((unsigned int *)v11 + 6);
  }
  _Block_object_dispose(&v10, 8);
  return v3;
}

uint64_t __IOPMConnectionScheduleWithRunLoop_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  context.version = 1;
  context.info = (void *)v2;
  memset(&context.retain, 0, 24);
  if (!*(void *)(v2 + 40))
  {
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)(*(void *)(a1 + 40) + 40) = CFMachPortCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFMachPortCallBack)iopm_mach_port_callback, &context, 0);
    uint64_t v2 = *(void *)(a1 + 40);
    uint64_t v4 = *(__CFMachPort **)(v2 + 40);
    if (v4)
    {
      *(void *)(*(void *)(a1 + 40) + 48) = CFMachPortCreateRunLoopSource(v3, v4, 0);
      uint64_t v2 = *(void *)(a1 + 40);
    }
  }
  unsigned int v5 = *(__CFRunLoopSource **)(v2 + 48);
  if (v5)
  {
    ++*(_DWORD *)(v2 + 72);
    CFRunLoopAddSource(*(CFRunLoopRef *)(a1 + 48), v5, *(CFRunLoopMode *)(a1 + 56));
    uint64_t result = *(void *)(a1 + 40);
    if (*(_DWORD *)(result + 72) != 1) {
      return result;
    }
    if (*(void *)(result + 40))
    {
      mach_port_t Port = CFMachPortGetPort(*(CFMachPortRef *)(result + 40));
      uint64_t result = *(void *)(a1 + 40);
    }
    else
    {
      mach_port_t Port = 0;
    }
    uint64_t result = _conveyMachPortToPowerd((int *)result, Port, 1);
  }
  else
  {
    uint64_t result = 3758097097;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t iopm_mach_port_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = *(uint64_t (**)(void, uint64_t, void, void))(a4 + 56);
    if (v4) {
      return v4(*(void *)(a4 + 64), a4, *(unsigned int *)(a2 + 32), *(unsigned int *)(a2 + 28));
    }
  }
  return result;
}

uint64_t _conveyMachPortToPowerd(int *a1, int a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v6 = 0;
  if (!_pm_connect((_DWORD *)&v11 + 1))
  {
    int v7 = io_pm_connection_schedule_notification(SHIDWORD(v11), *a1, a2, a3 ^ 1u, (int *)&v11);
    if (v7)
    {
      int v8 = v7;
      uint64_t v6 = 3758097097;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        _conveyMachPortToPowerd_cold_1(a1, v8);
      }
    }
    else
    {
      uint64_t v6 = v11;
      if (v11 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v10 = *a1;
        *(_DWORD *)long long buf = 67109376;
        int v13 = v10;
        __int16 v14 = 1024;
        int v15 = v6;
        _os_log_error_impl(&dword_18B46C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to update machport for IOPMConnection id 0x%x. rc:0x%x\n", buf, 0xEu);
        return v11;
      }
    }
  }
  return v6;
}

uint64_t IOPMConnectionUnscheduleFromRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v13 = 0;
  uint64_t v3 = 3758097090;
  if (a1 && a2 && a3)
  {
    PMQueue = getPMQueue();
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    void v9[2] = __IOPMConnectionUnscheduleFromRunLoop_block_invoke;
    v9[3] = &unk_1E5489B48;
    v9[6] = a2;
    v9[7] = a3;
    v9[4] = &v10;
    _OWORD v9[5] = a1;
    dispatch_sync(PMQueue, v9);
    uint64_t v3 = *((unsigned int *)v11 + 6);
  }
  _Block_object_dispose(&v10, 8);
  return v3;
}

void __IOPMConnectionUnscheduleFromRunLoop_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 40))
  {
    CFRunLoopRemoveSource(*(CFRunLoopRef *)(a1 + 48), *(CFRunLoopSourceRef *)(v2 + 48), *(CFRunLoopMode *)(a1 + 56));
    uint64_t v2 = *(void *)(a1 + 40);
  }
  int v3 = *(_DWORD *)(v2 + 72) - 1;
  *(_DWORD *)(v2 + 72) = v3;
  if (!v3)
  {
    uint64_t v4 = *(const void **)(v2 + 48);
    if (v4)
    {
      CFRelease(v4);
      uint64_t v2 = *(void *)(a1 + 40);
    }
    unsigned int v5 = *(__CFMachPort **)(v2 + 40);
    if (v5)
    {
      mach_port_t Port = CFMachPortGetPort(v5);
      int v7 = _conveyMachPortToPowerd(*(int **)(a1 + 40), Port, 0);
      uint64_t v8 = *(void *)(a1 + 40);
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7;
      CFMachPortInvalidate(*(CFMachPortRef *)(v8 + 40));
      xpc_object_t v9 = *(const void **)(*(void *)(a1 + 40) + 40);
      CFRelease(v9);
    }
  }
}

void setDispatchQueue(uint64_t a1, NSObject *a2)
{
  if (a2)
  {
    uint64_t v4 = (ipc_space_t *)MEMORY[0x1E4F14960];
    unsigned int v5 = (mach_port_name_t *)(a1 + 24);
    if (!mach_port_allocate(*MEMORY[0x1E4F14960], 1u, (mach_port_name_t *)(a1 + 24)))
    {
      mach_port_insert_right(*v4, *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 24), 0x14u);
      uint64_t v6 = dispatch_source_create(MEMORY[0x1E4F14458], *(unsigned int *)(a1 + 24), 0, a2);
      *(void *)(a1 + 32) = v6;
      if (v6)
      {
        int v7 = *(_DWORD *)(a1 + 24);
        handler[0] = MEMORY[0x1E4F143A8];
        handler[1] = 0x40000000;
        handler[2] = __setDispatchQueue_block_invoke;
        handler[3] = &__block_descriptor_tmp_102;
        handler[4] = v6;
        int v11 = v7;
        dispatch_source_set_cancel_handler(v6, handler);
        uint64_t v8 = *(NSObject **)(a1 + 32);
        v9[0] = MEMORY[0x1E4F143A8];
        v9[1] = 0x40000000;
        void v9[2] = __setDispatchQueue_block_invoke_2;
        v9[3] = &__block_descriptor_tmp_103;
        v9[4] = a1;
        dispatch_source_set_event_handler(v8, v9);
        dispatch_resume(*(dispatch_object_t *)(a1 + 32));
        _conveyMachPortToPowerd((int *)a1, *(_DWORD *)(a1 + 24), 1);
      }
      else
      {
        mach_port_deallocate(*v4, *v5);
        mach_port_mod_refs(*v4, *v5, 1u, -1);
        *unsigned int v5 = 0;
      }
    }
  }
  else if (*(void *)(a1 + 32))
  {
    _conveyMachPortToPowerd((int *)a1, *(_DWORD *)(a1 + 24), 0);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
    *(void *)(a1 + 32) = 0;
  }
}

uint64_t __setDispatchQueue_block_invoke(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  uint64_t v2 = (ipc_space_t *)MEMORY[0x1E4F14960];
  mach_port_mod_refs(*MEMORY[0x1E4F14960], *(_DWORD *)(a1 + 40), 1u, -1);
  ipc_space_t v3 = *v2;
  mach_port_name_t v4 = *(_DWORD *)(a1 + 40);

  return mach_port_deallocate(v3, v4);
}

uint64_t __setDispatchQueue_block_invoke_2(uint64_t a1)
{
  memset(v6, 0, 44);
  uint64_t result = mach_msg(v6, 258, 0, 0x2Cu, *(_DWORD *)(*(void *)(a1 + 32) + 24), 0, 0);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    mach_port_name_t v4 = *(uint64_t (**)(void, uint64_t, void, void))(v3 + 56);
    if (v4) {
      BOOL v5 = result == 0;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5) {
      return v4(*(void *)(v3 + 64), v3, v6[1].msgh_remote_port, v6[1].msgh_size);
    }
  }
  return result;
}

void IOPMConnectionSetDispatchQueue(uint64_t a1, NSObject *a2)
{
  if (a1) {
    setDispatchQueue(a1, a2);
  }
}

uint64_t IOPMConnectionCreate(const __CFString *a1, int a2, uint64_t a3)
{
  uint64_t v3 = 3758097090;
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  int v14 = -536870212;
  if (a1 && a2 && a3 && CFStringGetLength(a1) <= 128)
  {
    PMQueue = getPMQueue();
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    void v9[2] = __IOPMConnectionCreate_block_invoke;
    v9[3] = &unk_1E5489BD0;
    v9[4] = &v11;
    void v9[5] = a3;
    v9[6] = a1;
    int v10 = a2;
    dispatch_sync(PMQueue, v9);
    uint64_t v3 = *((unsigned int *)v12 + 6);
  }
  _Block_object_dispose(&v11, 8);
  return v3;
}

void __IOPMConnectionCreate_block_invoke(uint64_t a1)
{
  **(void **)(a1 + 40) = 0;
  uint64_t v2 = malloc_type_calloc(1uLL, 0x50uLL, 0x10E0040A93DF132uLL);
  if (v2)
  {
    uint64_t v3 = (uint64_t)v2;
    void v2[5] = -1;
    mach_port_name_t v4 = v2 + 5;
    CFRetain(*(CFTypeRef *)(a1 + 48));
    *(void *)(v3 + 8) = *(void *)(a1 + 48);
    *(_DWORD *)(v3 + 16) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _connectionCreate(v3);
    if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      CFRelease(*(CFTypeRef *)(a1 + 48));
      free((void *)v3);
    }
    else
    {
      PMQueue = getPMQueue();
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 0x40000000;
      handler[2] = __IOPMConnectionCreate_block_invoke_2;
      handler[3] = &__block_descriptor_tmp_105;
      handler[4] = v3;
      if (notify_register_dispatch("com.apple.system.powermanagement.assertionresync", v4, PMQueue, handler)
        && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        __IOPMConnectionCreate_block_invoke_cold_1();
      }
      **(void **)(a1 + 40) = v3;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -536870199;
  }
}

uint64_t _connectionCreate(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  mach_port_name_t v6 = 0;
  int v4 = 0;
  unsigned int v5 = _pm_connect(&v6);
  if (!v5)
  {
    CFStringGetCString(*(CFStringRef *)(a1 + 8), buffer, 128, 0);
    if (io_pm_connection_create(v6, buffer, *(_DWORD *)(a1 + 16), &v4, &v5))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        _connectionCreate_cold_2();
      }
      return -536870199;
    }
    else if (v5)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        _connectionCreate_cold_1();
      }
    }
    else
    {
      int v2 = v4;
      *(_DWORD *)a1 = v4;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 67109120;
        int v8 = v2;
        _os_log_impl(&dword_18B46C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Created IOPMConnection with id 0x%x\n", buf, 8u);
      }
    }
  }
  return v5;
}

uint64_t __IOPMConnectionCreate_block_invoke_2(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    int v2 = *(_DWORD *)v1;
    v5[0] = 67109120;
    v5[1] = v2;
    _os_log_impl(&dword_18B46C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Recreating IOPMConnection id 0x%x\n", (uint8_t *)v5, 8u);
  }
  _connectionCreate(v1);
  int v3 = *(_DWORD *)(v1 + 24);
  if (v3) {
    return _conveyMachPortToPowerd((int *)v1, v3, 1);
  }
  uint64_t result = *(void *)(v1 + 40);
  if (result)
  {
    uint64_t result = CFMachPortGetPort((CFMachPortRef)result);
    int v3 = result;
    if (result) {
      return _conveyMachPortToPowerd((int *)v1, v3, 1);
    }
  }
  return result;
}

uint64_t IOPMConnectionRelease(uint64_t a1)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = -536870212;
  PMQueue = getPMQueue();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = __IOPMConnectionRelease_block_invoke;
  v5[3] = &unk_1E5489BF8;
  v5[4] = &v6;
  void v5[5] = a1;
  dispatch_sync(PMQueue, v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __IOPMConnectionRelease_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v5 = 0;
  if (notify_is_valid_token(*(_DWORD *)(v2 + 20))) {
    notify_cancel(*(_DWORD *)(v2 + 20));
  }
  uint64_t v3 = *(const void **)(v2 + 8);
  if (v3) {
    CFRelease(v3);
  }
  if (_pm_connect(&v5))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -536870199;
  }
  else
  {
    int v4 = io_pm_connection_release(v5, *(_DWORD *)v2, (_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    if (v4) {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
    }
    *(_OWORD *)(v2 + 48) = 0u;
    *(_OWORD *)(v2 + 64) = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    free((void *)v2);
  }
}

uint64_t IOPMConnectionAcknowledgeEvent()
{
  return 3758097095;
}

uint64_t IOPMConnectionAcknowledgeEventWithOptions()
{
  return 3758097095;
}

uint64_t IOPMCopyConnectionStatus(uint64_t a1, void *a2)
{
  int v4 = 0;
  uint64_t result = _pm_connect(&v4);
  if (result) {
    return 3758097097;
  }
  *a2 = 0;
  return result;
}

uint64_t IOPMConnectionGetSystemCapabilities()
{
  uint64_t v0 = 31;
  unsigned int v3 = 31;
  int v4 = 0;
  int v2 = _pm_connect(&v4);
  if (v4)
  {
    io_pm_get_capability_bits(v4, &v3, &v2);
    return v3;
  }
  return v0;
}

BOOL IOPMIsADarkWake(char a1)
{
  return (a1 & 3) == 1;
}

uint64_t IOPMAllowsPushServiceTask(unsigned int a1)
{
  return (a1 >> 5) & 1;
}

uint64_t IOPMIsASilentWake(unsigned int a1)
{
  return (a1 >> 7) & 1;
}

uint64_t IOPMIsAUserWake(unsigned int a1)
{
  return (a1 >> 1) & 1;
}

BOOL IOPMIsASleep(char a1)
{
  return (a1 & 1) == 0;
}

BOOL IOPMGetCapabilitiesDescription(char *a1, int a2, char a3)
{
  if (a3)
  {
    if ((a3 & 3) == 1)
    {
      unsigned int v3 = "DarkWake";
    }
    else
    {
      unsigned int v3 = "FullWake";
      if ((a3 & 2) == 0) {
        unsigned int v3 = "Unknown";
      }
    }
  }
  else
  {
    unsigned int v3 = "Sleep";
  }
  int v4 = "cpu ";
  if ((a3 & 1) == 0) {
    int v4 = "<off> ";
  }
  int v5 = "disk ";
  if ((a3 & 0x10) == 0) {
    int v5 = "";
  }
  uint64_t v6 = "net ";
  if ((a3 & 8) == 0) {
    uint64_t v6 = "";
  }
  int v7 = "aud ";
  if ((a3 & 4) == 0) {
    int v7 = "";
  }
  uint64_t v8 = "vid ";
  if ((a3 & 2) == 0) {
    uint64_t v8 = "";
  }
  int v9 = "push ";
  if ((a3 & 0x20) == 0) {
    int v9 = "";
  }
  if ((a3 & 0x40) != 0) {
    uint64_t v10 = "bg ";
  }
  else {
    uint64_t v10 = "";
  }
  return snprintf(a1, a2, "%s:%s%s%s%s%s%s%s", v3, v4, v5, v6, v7, v8, v9, v10) <= a2;
}

uint64_t IOPMGetSleepServicesActive()
{
  int out_token = 0;
  uint64_t v2 = 0;
  uint32_t v0 = notify_register_check("com.apple.powermanagement.sleepservices", &out_token);
  uint64_t result = 0;
  if (!v0)
  {
    notify_get_state(out_token, &v2);
    notify_cancel(out_token);
    return v2 & 1;
  }
  return result;
}

uint64_t IOPMGetDarkWakeThermalEmergencyCount()
{
  return IOPMGetValueInt(4);
}

uint64_t IOPMSetDebugFlags(int a1, _DWORD *a2)
{
  int v7 = 0;
  uint64_t v6 = _pm_connect(&v7);
  if (!v7) {
    return 3758097112;
  }
  int v4 = io_pm_set_debug_flags(v7, a1, 2, (_DWORD *)&v6 + 1, &v6);
  uint64_t result = v6;
  if (!(v4 | v6))
  {
    uint64_t result = 0;
    if (a2) {
      *a2 = HIDWORD(v6);
    }
  }
  return result;
}

uint64_t IOPMSetBTWakeInterval()
{
  return 0;
}

uint64_t IOPMSetDWLingerInterval()
{
  return 0;
}

uint64_t IOPMChangeSystemActivityAssertionBehavior(int a1, _DWORD *a2)
{
  int v7 = 0;
  uint64_t v6 = _pm_connect(&v7);
  if (!v7) {
    return 3758097112;
  }
  int v4 = io_pm_change_sa_assertion_behavior(v7, a1, (_DWORD *)&v6 + 1, &v6);
  uint64_t result = v6;
  if (!(v4 | v6))
  {
    uint64_t result = 0;
    if (HIDWORD(v6)) {
      *a2 = HIDWORD(v6);
    }
  }
  return result;
}

uint64_t IOPMCtlAssertionType(const char *a1, int a2)
{
  mach_port_name_t v7 = 0;
  unsigned int v6 = _pm_connect(&v7);
  if (!v7) {
    return 3758097112;
  }
  int v4 = io_pm_ctl_assertion_type(v7, a1, a2, &v6);
  if (v4 | v6) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t IOPMCopyPowerStateInfo(__int16 a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return -536870211;
  }
  unsigned int v3 = Mutable;
  int valuePtr = a1 & 0xF;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (v4)
  {
    CFNumberRef v5 = v4;
    CFDictionarySetValue(v3, @"CurrentState", v4);
    CFRelease(v5);
  }
  int valuePtr = a1 >> 4;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (v6)
  {
    CFNumberRef v7 = v6;
    CFDictionarySetValue(v3, @"MaxState", v6);
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*MEMORY[0x1E4F1CFC8];
  int v9 = (const void *)*MEMORY[0x1E4F1CFD0];
  if ((a1 & 0x100) != 0) {
    uint64_t v10 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    uint64_t v10 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(v3, @"IsPowerOn", v10);
  if ((a1 & 0x200) != 0) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = v8;
  }
  CFDictionarySetValue(v3, @"IsDeviceUsable", v11);
  if ((a1 & 0x400) != 0) {
    uint64_t v12 = v9;
  }
  else {
    uint64_t v12 = v8;
  }
  CFDictionarySetValue(v3, @"IsLowPower", v12);
  return (uint64_t)v3;
}

uint64_t IOPMAssertionNotify(const char *a1, int a2)
{
  mach_port_name_t v7 = 0;
  unsigned int v6 = _pm_connect(&v7);
  if (!v7) {
    return 3758097112;
  }
  int v4 = io_pm_assertion_notify(v7, a1, a2, &v6);
  if (v4 | v6) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t _copySleepPreventersList(const __CFString *a1, void *a2)
{
  io_registry_entry_t v4 = IORegistryEntryFromPath(0, "IOPower:/IOPowerConnection/IOPMrootDomain");
  if (!v4) {
    return 3758097097;
  }
  io_object_t v5 = v4;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v4, a1, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  IOObjectRelease(v5);
  uint64_t result = 0;
  *a2 = CFProperty;
  return result;
}

uint64_t IOPMCopySleepPreventersList(int a1, void *a2)
{
  if (a2)
  {
    if (!a1)
    {
      CFStringRef v2 = @"IdleSleepPreventers";
      return _copySleepPreventersList(v2, a2);
    }
    if (a1 == 1)
    {
      CFStringRef v2 = @"SystemSleepPreventers";
      return _copySleepPreventersList(v2, a2);
    }
  }
  return 3758097090;
}

uint64_t IOPMCopySleepPreventersListWithID(int a1, void *a2)
{
  if (a2)
  {
    if (!a1)
    {
      CFStringRef v2 = @"IdleSleepPreventersWithID";
      return _copySleepPreventersList(v2, a2);
    }
    if (a1 == 1)
    {
      CFStringRef v2 = @"SystemSleepPreventersWithID";
      return _copySleepPreventersList(v2, a2);
    }
  }
  return 3758097090;
}

uint64_t IOPMCopyBatteryHeatMap(int a1, uint64_t a2, uint64_t a3)
{
  return copyBatteryData("batteryHeatMapData", a1, a2, a3);
}

uint64_t copyBatteryData(const char *a1, int a2, uint64_t a3, uint64_t a4)
{
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E4F14428], 0);
  if (mach_service)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 3758097084;
    BOOL v10 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v10) {
      IOPSGaugingMitigationGetState_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }
  xpc_connection_set_target_queue(mach_service, MEMORY[0x1E4F14428]);
  xpc_connection_set_event_handler(mach_service, &__block_literal_global_188);
  xpc_connection_resume(mach_service);
  xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
  if (v18)
  {
    uint64_t v19 = v18;
    xpc_dictionary_set_uint64(v18, a1, a2);
    PMQueue = getPMQueue();
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 0x40000000;
    v30[2] = __copyBatteryData_block_invoke_189;
    v30[3] = &unk_1E5489D78;
    v30[4] = a4;
    void v30[5] = a3;
    v30[6] = a1;
    v30[7] = mach_service;
    xpc_connection_send_message_with_reply(mach_service, v19, PMQueue, v30);
    xpc_release(v19);
    if (!mach_service) {
      return v9;
    }
    goto LABEL_10;
  }
  uint64_t v9 = 3758097084;
  BOOL v21 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
  if (v21)
  {
    copyBatteryData_cold_1(v21, v22, v23, v24, v25, v26, v27, v28);
    if (!mach_service) {
      return v9;
    }
    goto LABEL_10;
  }
  if (mach_service) {
LABEL_10:
  }
    xpc_release(mach_service);
  return v9;
}

uint64_t IOPMCopyCycleCountData(uint64_t a1, uint64_t a2)
{
  return copyBatteryData("batteryCycleCountData", 0, a1, a2);
}

uint64_t IOPMCopyKioskModeData(uint64_t a1, uint64_t a2)
{
  return copyBatteryData("batteryKioskModeData", 0, a1, a2);
}

uint64_t IOPMCopyCurrentScheduledWake(uint64_t a1, uint64_t a2)
{
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", MEMORY[0x1E4F14428], 0);
  if (mach_service)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 3758097084;
    BOOL v6 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v6) {
      IOPSGaugingMitigationGetState_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  PMQueue = getPMQueue();
  xpc_connection_set_target_queue(mach_service, PMQueue);
  xpc_connection_set_event_handler(mach_service, &__block_literal_global_155);
  xpc_connection_resume(mach_service);
  xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
  if (v15)
  {
    uint64_t v16 = v15;
    xpc_dictionary_set_uint64(v15, "wakeData", 0);
    uint64_t v17 = getPMQueue();
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = __IOPMCopyCurrentScheduledWake_block_invoke_157;
    handler[3] = &unk_1E5489C68;
    handler[4] = a2;
    void handler[5] = a1;
    handler[6] = mach_service;
    xpc_connection_send_message_with_reply(mach_service, v16, v17, handler);
    xpc_release(v16);
    if (!mach_service) {
      return v5;
    }
    goto LABEL_10;
  }
  uint64_t v5 = 3758097084;
  BOOL v18 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
  if (v18)
  {
    copyBatteryData_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
    if (!mach_service) {
      return v5;
    }
    goto LABEL_10;
  }
  if (mach_service) {
LABEL_10:
  }
    xpc_release(mach_service);
  return v5;
}

void __IOPMCopyCurrentScheduledWake_block_invoke_157(uint64_t a1, uint64_t a2)
{
  if (MEMORY[0x18C131C50](a2) == MEMORY[0x1E4F14590])
  {
    uint64_t v11 = _CFXPCCreateCFObjectFromXPCObject();
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    _OWORD v13[2] = __IOPMCopyCurrentScheduledWake_block_invoke_2;
    v13[3] = &unk_1E5489C40;
    uint64_t v12 = *(NSObject **)(a1 + 40);
    v13[4] = *(void *)(a1 + 32);
    void v13[5] = v11;
    dispatch_async(v12, v13);
  }
  else
  {
    BOOL v3 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    if (v3) {
      __IOPMCopyCurrentScheduledWake_block_invoke_157_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
  xpc_connection_cancel(*(xpc_connection_t *)(a1 + 48));
}

uint64_t __IOPMCopyCurrentScheduledWake_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t IOPMSetDesktopMode(BOOL a1)
{
  return IOPMSetDesktopModeWithOptions(a1, 0);
}

uint64_t IOPMSetDesktopModeWithOptions(BOOL a1, const __CFDictionary *a2)
{
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service) {
    return 3758097084;
  }
  uint64_t v6 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v6, &__block_literal_global_162);
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  if (v7)
  {
    uint64_t v8 = v7;
    xpc_dictionary_set_BOOL(v7, "DesktopMode", a1);
    if (a2)
    {
      if (CFDictionaryContainsKey(a2, @"DesktopModeAppliesOnBatteryPower"))
      {
        BOOL v9 = CFDictionaryGetValue(a2, @"DesktopModeAppliesOnBatteryPower") != 0;
        xpc_dictionary_set_BOOL(v8, "DesktopModeAppliesOnBatteryPower", v9);
      }
    }
    xpc_connection_resume(v6);
    xpc_connection_send_message(v6, v8);
    xpc_release(v8);
  }
  xpc_release(v6);
  return 0;
}

uint64_t IOPMSkylightCheckInWithCapability(BOOL a1, uint64_t a2)
{
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service) {
    return 3758097084;
  }
  uint64_t v6 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v6, &__block_literal_global_170);
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  if (v7)
  {
    uint64_t v8 = v7;
    xpc_dictionary_set_BOOL(v7, "SLCheckIn", a1);
    xpc_dictionary_set_uint64(v8, "SLCheckInCapability", a2);
    xpc_connection_resume(v6);
    xpc_connection_send_message(v6, v8);
    xpc_release(v8);
  }
  xpc_release(v6);
  return 0;
}

uint64_t IOPMSkylightCheckIn(BOOL a1)
{
  return IOPMSkylightCheckInWithCapability(a1, 1uLL);
}

uint64_t IOPMSetSystemAssertionTimeout(unsigned int a1)
{
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service) {
    return 3758097084;
  }
  uint64_t v4 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v4, &__block_literal_global_175);
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  if (v5)
  {
    uint64_t v6 = v5;
    xpc_dictionary_set_uint64(v5, "systemAssertionTimeout", a1);
    xpc_connection_resume(v4);
    xpc_connection_send_message(v4, v6);
    xpc_release(v6);
  }
  xpc_release(v4);
  return 0;
}

uint64_t IOPMUpdateDominoState(BOOL a1, BOOL a2)
{
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service) {
    return 3758097084;
  }
  uint64_t v6 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v6, &__block_literal_global_179);
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  if (v7)
  {
    uint64_t v8 = v7;
    xpc_dictionary_set_BOOL(v7, "dominoState", a1);
    xpc_dictionary_set_BOOL(v8, "dominoMainDisplay", a2);
    xpc_connection_resume(v6);
    xpc_connection_send_message(v6, v8);
    xpc_release(v8);
  }
  xpc_release(v6);
  return 0;
}

uint64_t IOPMUpdateOnenessState(BOOL a1)
{
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.iokit.powerdxpc", global_queue, 0);
  if (!mach_service) {
    return 3758097084;
  }
  uint64_t v4 = mach_service;
  xpc_connection_set_target_queue(mach_service, global_queue);
  xpc_connection_set_event_handler(v4, &__block_literal_global_184);
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  if (v5)
  {
    uint64_t v6 = v5;
    xpc_dictionary_set_BOOL(v5, "onenessState", a1);
    xpc_connection_resume(v4);
    xpc_connection_send_message(v4, v6);
    xpc_release(v6);
  }
  xpc_release(v4);
  return 0;
}

void _reset_connection()
{
  powerd_connection = 0;
  lock = 0;
}

void __copyBatteryData_block_invoke_189(uint64_t a1, uint64_t a2)
{
  if (MEMORY[0x18C131C50](a2) == MEMORY[0x1E4F14590])
  {
    uint64_t v10 = _CFXPCCreateCFObjectFromXPCObject();
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    uint32x2_t v12[2] = __copyBatteryData_block_invoke_2;
    v12[3] = &unk_1E5489D50;
    uint64_t v11 = *(NSObject **)(a1 + 40);
    v12[4] = *(void *)(a1 + 32);
    _OWORD v12[5] = v10;
    dispatch_async(v11, v12);
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    __copyBatteryData_block_invoke_189_cold_1(a1, v3, v4, v5, v6, v7, v8, v9);
  }
  xpc_connection_cancel(*(xpc_connection_t *)(a1 + 56));
}

uint64_t __copyBatteryData_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t IOAVControlInterfaceGetTypeID()
{
  uint64_t result = __kIOAVControlInterfaceTypeID;
  if (!__kIOAVControlInterfaceTypeID)
  {
    pthread_once(&__interfaceTypeInit, (void (*)(void))__IOAVControlInterfaceRegister);
    return __kIOAVControlInterfaceTypeID;
  }
  return result;
}

uint64_t __IOAVControlInterfaceRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOAVControlInterfaceCFTypeID TypeID = result;
  return result;
}

uint64_t IOAVControlInterfaceCreate(uint64_t a1)
{
  if (*MEMORY[0x1E4F1CF80] == a1) {
    return __IOAVCopyFirstMatchingIOAVObjectOfType((uint64_t)"IOAVControlInterface", (uint64_t (*)(void, uint64_t))IOAVControlInterfaceCreateWithService, 0, 2u, -1);
  }
  else {
    return 0;
  }
}

io_connect_t *IOAVControlInterfaceCreateWithService(uint64_t a1, io_registry_entry_t a2)
{
  if (!a2 || !IOAVObjectConformsTo(a2, (uint64_t)"IOAVControlInterface")) {
    return 0;
  }
  if (!__kIOAVControlInterfaceTypeID) {
    pthread_once(&__interfaceTypeInit, (void (*)(void))__IOAVControlInterfaceRegister);
  }
  uint64_t Instance = (io_connect_t *)_CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  if (Instance)
  {
    *((void *)Instance + 2) = 0;
    *((void *)Instance + 3) = 0;
    uint64_t v5 = Instance + 4;
    *((void *)Instance + 4) = 0;
    Instance[4] = a2;
    IOObjectRetain(a2);
    if (IOServiceOpen(*v5, *MEMORY[0x1E4F14960], 0, v4 + 5))
    {
      uint64_t v7 = v4;
      uint64_t v4 = 0;
LABEL_10:
      CFRelease(v7);
      return v4;
    }
    CFTypeRef CFProperty = (io_connect_t *)IORegistryEntryCreateCFProperty(*v5, @"Location", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (CFProperty)
    {
      uint64_t v7 = CFProperty;
      if (CFEqual(CFProperty, @"Embedded")) {
        v4[6] = 1;
      }
      goto LABEL_10;
    }
  }
  return v4;
}

CFTypeRef IOAVControlInterfaceCopyProperty(uint64_t a1, const __CFString *a2)
{
  return IORegistryEntryCreateCFProperty(*(_DWORD *)(a1 + 16), a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
}

io_connect_t *IOAVControlInterfaceGetService(uint64_t a1)
{
  uint64_t result = *(io_connect_t **)(a1 + 32);
  if (!result)
  {
    io_registry_entry_t parent = 0;
    if (IORegistryEntryGetParentEntry(*(_DWORD *)(a1 + 16), "IOService", &parent))
    {
      uint64_t result = IOAVServiceCreateWithService(*MEMORY[0x1E4F1CF80], parent);
      *(void *)(a1 + 32) = result;
    }
    else
    {
      return *(io_connect_t **)(a1 + 32);
    }
  }
  return result;
}

uint64_t IOAVControlInterfaceSetLogLevel(uint64_t a1, unsigned int a2)
{
  input[1] = *MEMORY[0x1E4F143B8];
  mach_port_t v2 = *(_DWORD *)(a1 + 20);
  input[0] = a2;
  return IOConnectCallMethod(v2, 0, input, 1u, 0, 0, 0, 0, 0, 0);
}

uint64_t IOAVControlInterfaceSetLogLevelMask(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x1E4F143B8];
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallMethod(*(_DWORD *)(a1 + 20), 1u, input, 2u, 0, 0, 0, 0, 0, 0);
}

CFArrayRef IOAVControlInterfaceCopyProperties(uint64_t a1)
{
  CFMutableDictionaryRef properties = 0;
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (IORegistryEntryCreateCFProperties(*(_DWORD *)(a1 + 16), &properties, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0)) {
    return 0;
  }
  CFArrayRef v2 = IOAVPropertyListCreateWithCFProperties(v1, properties);
  CFRelease(properties);
  return v2;
}

uint64_t IOAVControlInterfaceSetProperty(uint64_t a1, const __CFString *a2, const void *a3)
{
  return IORegistryEntrySetCFProperty(*(_DWORD *)(a1 + 16), a2, a3);
}

uint64_t IOAVControlInterfaceGetLocation(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t IOAVControlInterfaceCopyDiagnosticsString()
{
  return 0;
}

void __IOAVControlInterfaceFree(uint64_t a1)
{
  io_connect_t v2 = *(_DWORD *)(a1 + 20);
  if (v2) {
    IOServiceClose(v2);
  }
  io_object_t v3 = *(_DWORD *)(a1 + 16);
  if (v3) {
    IOObjectRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t (*_io_SCDynamicStoreAddWatchedKey(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreAddWatchedKey_dyfunc;
  if (_io_SCDynamicStoreAddWatchedKey_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreAddWatchedKey"),
        uint64_t v6 = result,
        (_io_SCDynamicStoreAddWatchedKey_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

void *symAddrInSC(char *__symbol)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t result = (void *)symAddrInSC_handle;
  if (!symAddrInSC_handle)
  {
    memset(&v5, 0, sizeof(v5));
    io_object_t v3 = getenv("DYLD_IMAGE_SUFFIX");
    __strlcpy_chk();
    if (v3) {
      __strlcat_chk();
    }
    if (stat(v6, &v5) < 0) {
      uint64_t v4 = "/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration";
    }
    else {
      uint64_t v4 = v6;
    }
    uint64_t result = dlopen(v4, 1);
    if (result)
    {
      symAddrInSC_handle = (uint64_t)result;
    }
    else
    {
      uint64_t result = (void *)symAddrInSC_handle;
      if (!symAddrInSC_handle) {
        return result;
      }
    }
  }
  return dlsym(result, __symbol);
}

uint64_t _io_SCError()
{
  uint32_t v0 = _io_SCError_dyfunc;
  if (!_io_SCError_dyfunc)
  {
    uint32_t v0 = symAddrInSC("SCError");
    _io_SCError_dyfunc = v0;
    if (!v0) {
      return 1001;
    }
  }

  return ((uint64_t (*)(void))v0)();
}

uint64_t (*_io_SCDynamicStoreCopyMultiple(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreCopyMultiple_dyfunc;
  if (_io_SCDynamicStoreCopyMultiple_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCopyMultiple"),
        uint64_t v6 = result,
        (_io_SCDynamicStoreCopyMultiple_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

uint64_t (*_io_SCDynamicStoreCopyValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCDynamicStoreCopyValue_dyfunc;
  if (_io_SCDynamicStoreCopyValue_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCopyValue"),
        uint64_t v4 = result,
        (_io_SCDynamicStoreCopyValue_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  }
  return result;
}

uint64_t (*_io_SCDynamicStoreCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t, uint64_t, uint64_t, uint64_t)
{
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreCreate_dyfunc;
  if (_io_SCDynamicStoreCreate_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCreate"),
        uint64_t v8 = result,
        (_io_SCDynamicStoreCreate_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8(a1, a2, a3, a4);
  }
  return result;
}

uint64_t (*_io_SCDynamicStoreCreateRunLoopSource(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreCreateRunLoopSource_dyfunc;
  if (_io_SCDynamicStoreCreateRunLoopSource_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreCreateRunLoopSource"),
        uint64_t v6 = result,
        (_io_SCDynamicStoreCreateRunLoopSource_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

CFStringRef _io_SCDynamicStoreKeyCreate(const __CFAllocator *a1, CFStringRef format, ...)
{
  va_start(va, format);
  return CFStringCreateWithFormatAndArguments(a1, 0, format, va);
}

uint64_t (*_io_SCDynamicStoreKeyCreatePreferences(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreKeyCreatePreferences_dyfunc;
  if (_io_SCDynamicStoreKeyCreatePreferences_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreKeyCreatePreferences"),
        uint64_t v6 = result,
        (_io_SCDynamicStoreKeyCreatePreferences_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

uint64_t (*_io_SCDynamicStoreSetNotificationKeys(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreSetNotificationKeys_dyfunc;
  if (_io_SCDynamicStoreSetNotificationKeys_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreSetNotificationKeys"),
        uint64_t v6 = result,
        (_io_SCDynamicStoreSetNotificationKeys_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

uint64_t (*_io_SCDynamicStoreNotifyValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCDynamicStoreNotifyValue_dyfunc;
  if (_io_SCDynamicStoreNotifyValue_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCDynamicStoreNotifyValue"),
        uint64_t v4 = result,
        (_io_SCDynamicStoreNotifyValue_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  }
  return result;
}

uint64_t (*_io_SCDynamicStoreSetValue(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCDynamicStoreSetValue_dyfunc;
  if (_io_SCDynamicStoreSetValue_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCDynamicStoreSetValue"),
        uint64_t v6 = result,
        (_io_SCDynamicStoreSetValue_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

uint64_t (*_io_SCPreferencesApplyChanges(uint64_t a1))(uint64_t)
{
  io_connect_t v2 = (uint64_t (*)(uint64_t))_io_SCPreferencesApplyChanges_dyfunc;
  if (_io_SCPreferencesApplyChanges_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t))symAddrInSC("SCPreferencesApplyChanges"),
        io_connect_t v2 = result,
        (_io_SCPreferencesApplyChanges_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t))v2(a1);
  }
  return result;
}

uint64_t (*_io_SCPreferencesCommitChanges(uint64_t a1))(uint64_t)
{
  io_connect_t v2 = (uint64_t (*)(uint64_t))_io_SCPreferencesCommitChanges_dyfunc;
  if (_io_SCPreferencesCommitChanges_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t))symAddrInSC("SCPreferencesCommitChanges"),
        io_connect_t v2 = result,
        (_io_SCPreferencesCommitChanges_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t))v2(a1);
  }
  return result;
}

uint64_t (*_io_SCPreferencesCreate(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCPreferencesCreate_dyfunc;
  if (_io_SCPreferencesCreate_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCPreferencesCreate"),
        uint64_t v6 = result,
        (_io_SCPreferencesCreate_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

uint64_t (*_io_SCPreferencesCreateWithAuthorization(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t, uint64_t, uint64_t, uint64_t)
{
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))_io_SCPreferencesCreateWithAuthorization_dyfunc;
  if (_io_SCPreferencesCreateWithAuthorization_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))symAddrInSC("SCPreferencesCreateWithAuthorization"),
        uint64_t v8 = result,
        (_io_SCPreferencesCreateWithAuthorization_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8(a1, a2, a3, a4);
  }
  return result;
}

uint64_t (*_io_SCPreferencesGetValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCPreferencesGetValue_dyfunc;
  if (_io_SCPreferencesGetValue_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCPreferencesGetValue"),
        uint64_t v4 = result,
        (_io_SCPreferencesGetValue_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  }
  return result;
}

uint64_t (*_io_SCPreferencesLock(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCPreferencesLock_dyfunc;
  if (_io_SCPreferencesLock_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCPreferencesLock"),
        uint64_t v4 = result,
        (_io_SCPreferencesLock_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  }
  return result;
}

uint64_t (*_io_SCPreferencesRemoveValue(uint64_t a1, uint64_t a2))(uint64_t, uint64_t)
{
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))_io_SCPreferencesRemoveValue_dyfunc;
  if (_io_SCPreferencesRemoveValue_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t))symAddrInSC("SCPreferencesRemoveValue"),
        uint64_t v4 = result,
        (_io_SCPreferencesRemoveValue_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t))v4(a1, a2);
  }
  return result;
}

uint64_t (*_io_SCPreferencesSetValue(uint64_t a1, uint64_t a2, uint64_t a3))(uint64_t, uint64_t, uint64_t)
{
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))_io_SCPreferencesSetValue_dyfunc;
  if (_io_SCPreferencesSetValue_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t, uint64_t, uint64_t))symAddrInSC("SCPreferencesSetValue"),
        uint64_t v6 = result,
        (_io_SCPreferencesSetValue_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))v6(a1, a2, a3);
  }
  return result;
}

uint64_t (*_io_SCPreferencesUnlock(uint64_t a1))(uint64_t)
{
  io_connect_t v2 = (uint64_t (*)(uint64_t))_io_SCPreferencesUnlock_dyfunc;
  if (_io_SCPreferencesUnlock_dyfunc
    || (uint64_t result = (uint64_t (*)(uint64_t))symAddrInSC("SCPreferencesUnlock"),
        io_connect_t v2 = result,
        (_io_SCPreferencesUnlock_dyfunc = result) != 0))
  {
    return (uint64_t (*)(uint64_t))v2(a1);
  }
  return result;
}

uint64_t __IOHIDValueRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __valueCFTypeID TypeID = result;
  return result;
}

CFTypeID IOHIDValueGetTypeID(void)
{
  CFTypeID result = __valueTypeID;
  if (!__valueTypeID)
  {
    pthread_once(&__valueTypeInit, (void (*)(void))__IOHIDValueRegister);
    return __valueTypeID;
  }
  return result;
}

uint64_t _IOHIDValueCreateWithElementValuePtr(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t Private = 0;
  if (a2 && a3)
  {
    int64_t Length = _IOHIDElementGetLength((uint64_t)a2);
    int64_t v8 = ((unint64_t)*(unsigned int *)(a3 + 4) >> 8) - 20;
    if (Length < v8) {
      LODWORD(v8) = _IOHIDElementGetLength((uint64_t)a2);
    }
    uint64_t Private = __IOHIDValueCreatePrivate(a1, v8);
    if (Private)
    {
      *(void *)(Private + 16) = CFRetain(a2);
      *(void *)(Private + 32) = *(void *)(a3 + 8);
      *(unsigned char *)(Private + 44) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(Private + 40) = v8;
      uint64_t v9 = (void *)(a3 + 20);
      if (*(unsigned char *)(a3 + 4)) {
        uint64_t v9 = (void *)*v9;
      }
      memmove((void *)(Private + 56), v9, v8);
    }
  }
  return Private;
}

uint64_t __IOHIDValueCreatePrivate(uint64_t a1, int a2)
{
  unsigned int v2 = a2 + 40;
  if (!__valueTypeID) {
    pthread_once(&__valueTypeInit, (void (*)(void))__IOHIDValueRegister);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  if (Instance) {
    bzero((void *)(Instance + 16), v2);
  }
  return v4;
}

uint64_t _IOHIDValueCreateWithStruct(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t Private = 0;
  if (a2 && a3)
  {
    BOOL v7 = *(void *)(a3 + 24) && *(_DWORD *)(a3 + 20) != 0;
    unsigned int Length = _IOHIDElementGetLength((uint64_t)a2);
    uint64_t Private = __IOHIDValueCreatePrivate(a1, Length);
    if (Private)
    {
      *(void *)(Private + 16) = CFRetain(a2);
      uint64_t v9 = *(void *)(a3 + 12);
      *(void *)(Private + 32) = v9;
      if (dynLinkrosetta_is_current_process_translated[0])
      {
        int v10 = dynLinkrosetta_is_current_process_translated[0]();
        uint64_t v9 = *(void *)(Private + 32);
        if (v10)
        {
          if (dynLinkrosetta_convert_to_system_absolute_time[0]) {
            uint64_t v9 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(v9);
          }
        }
      }
      *(void *)(Private + 32) = v9;
      *(_DWORD *)(Private + 40) = Length;
      if (v7)
      {
        uint64_t v11 = (void *)(Private + 56);
        uint64_t v12 = *(const void **)(a3 + 24);
        size_t v13 = Length;
      }
      else
      {
        uint64_t v12 = (const void *)(a3 + 8);
        uint64_t v11 = (void *)(Private + 56);
        if (Length >= 4uLL) {
          size_t v13 = 4;
        }
        else {
          size_t v13 = Length;
        }
      }
      memmove(v11, v12, v13);
    }
  }
  return Private;
}

IOHIDValueRef IOHIDValueCreateWithIntegerValue(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, CFIndex value)
{
  if (!element) {
    return 0;
  }
  unsigned int Length = _IOHIDElementGetLength((uint64_t)element);
  uint64_t Private = __IOHIDValueCreatePrivate((uint64_t)allocator, Length);
  if (Private)
  {
    *(void *)(Private + 16) = CFRetain(element);
    *(void *)(Private + 32) = timeStamp;
    if (dynLinkrosetta_is_current_process_translated[0])
    {
      int v10 = dynLinkrosetta_is_current_process_translated[0]();
      timeStamp = *(void *)(Private + 32);
      if (v10)
      {
        if (dynLinkrosetta_convert_to_system_absolute_time[0]) {
          timeStamp = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(*(void *)(Private + 32));
        }
      }
    }
    *(void *)(Private + 32) = timeStamp;
    *(_DWORD *)(Private + 40) = Length;
    CFIndex __src = value;
    if (Length >= 8uLL) {
      size_t v11 = 8;
    }
    else {
      size_t v11 = Length;
    }
    memmove((void *)(Private + 56), &__src, v11);
  }
  return (IOHIDValueRef)Private;
}

IOHIDValueRef IOHIDValueCreateWithBytes(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, const uint8_t *bytes, CFIndex length)
{
  uint64_t Private = 0;
  if (element)
  {
    if (bytes)
    {
      if (length)
      {
        CFIndex v11 = _IOHIDElementGetLength((uint64_t)element);
        uint64_t Private = __IOHIDValueCreatePrivate((uint64_t)allocator, v11);
        if (Private)
        {
          *(void *)(Private + 16) = CFRetain(element);
          *(void *)(Private + 32) = timeStamp;
          if (dynLinkrosetta_is_current_process_translated[0])
          {
            int v12 = dynLinkrosetta_is_current_process_translated[0]();
            timeStamp = *(void *)(Private + 32);
            if (v12)
            {
              if (dynLinkrosetta_convert_to_system_absolute_time[0]) {
                timeStamp = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(*(void *)(Private + 32));
              }
            }
          }
          *(void *)(Private + 32) = timeStamp;
          *(_DWORD *)(Private + 40) = v11;
          if (v11 >= length) {
            size_t v13 = length;
          }
          else {
            size_t v13 = v11;
          }
          memmove((void *)(Private + 56), bytes, v13);
        }
      }
    }
  }
  return (IOHIDValueRef)Private;
}

IOHIDValueRef IOHIDValueCreateWithBytesNoCopy(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, const uint8_t *bytes, CFIndex length)
{
  uint64_t Private = 0;
  if (element)
  {
    if (bytes)
    {
      CFIndex v7 = length;
      if (length)
      {
        uint64_t Private = __IOHIDValueCreatePrivate((uint64_t)allocator, 0);
        if (Private)
        {
          *(void *)(Private + 16) = CFRetain(element);
          *(void *)(Private + 32) = timeStamp;
          if (dynLinkrosetta_is_current_process_translated[0])
          {
            int v10 = dynLinkrosetta_is_current_process_translated[0]();
            timeStamp = *(void *)(Private + 32);
            if (v10)
            {
              if (dynLinkrosetta_convert_to_system_absolute_time[0]) {
                timeStamp = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time[0])(*(void *)(Private + 32));
              }
            }
          }
          *(void *)(Private + 32) = timeStamp;
          if ((uint64_t)_IOHIDElementGetLength((uint64_t)element) <= v7) {
            LODWORD(v7) = _IOHIDElementGetLength((uint64_t)element);
          }
          *(_DWORD *)(Private + 40) = v7;
          *(void *)(Private + 48) = bytes;
        }
      }
    }
  }
  return (IOHIDValueRef)Private;
}

uint64_t _IOHIDValueCreateWithValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Private = __IOHIDValueCreatePrivate(a1, *(_DWORD *)(a2 + 40));
  uint64_t v6 = Private;
  if (Private)
  {
    *(void *)(Private + 16) = a3;
    *(unsigned char *)(Private + 24) = 1;
    *(void *)(Private + 32) = *(void *)(a2 + 32);
    *(_DWORD *)(Private + 40) = *(_DWORD *)(a2 + 40);
    memmove((void *)(Private + 56), (const void *)(a2 + 56), *(unsigned int *)(a2 + 40));
  }
  return v6;
}

IOHIDElementRef IOHIDValueGetElement(IOHIDValueRef value)
{
  return (IOHIDElementRef)*((void *)value + 2);
}

uint64_t IOHIDValueGetTimeStamp(IOHIDValueRef value)
{
  if (!dynLinkrosetta_is_current_process_translated[0]
    || !dynLinkrosetta_is_current_process_translated[0]())
  {
    return *((void *)value + 4);
  }
  uint64_t result = *((void *)value + 4);
  io_object_t v3 = (uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_rosetta_absolute_time[0];
  if (dynLinkrosetta_convert_to_rosetta_absolute_time[0])
  {
    return v3(result);
  }
  return result;
}

uint64_t _IOHIDValueGetFlags(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 44);
}

CFIndex IOHIDValueGetIntegerValue(IOHIDValueRef value)
{
  CFAllocatorRef v1 = (__IOHIDElement *)*((void *)value + 2);
  if (*((_DWORD *)value + 10) >= 8u) {
    int v2 = 8;
  }
  else {
    int v2 = *((_DWORD *)value + 10);
  }
  if (IOHIDElementGetLogicalMin(*((IOHIDElementRef *)value + 2)) < 0) {
    LOBYTE(v3) = 1;
  }
  else {
    unint64_t v3 = (unint64_t)IOHIDElementGetLogicalMax(v1) >> 63;
  }
  __memmove_chk();
  if (v2 && (v3 & 1) != 0) {
    return 0;
  }
  else {
    return 0;
  }
}

const uint8_t *__cdecl IOHIDValueGetBytePtr(IOHIDValueRef value)
{
  if (*((void *)value + 6)) {
    return (const uint8_t *)*((void *)value + 6);
  }
  else {
    return (const uint8_t *)value + 56;
  }
}

double_t IOHIDValueGetScaledValue(IOHIDValueRef value, IOHIDValueScaleType type)
{
  unint64_t v3 = (__IOHIDElement *)*((void *)value + 2);
  CFIndex IntegerValue = IOHIDValueGetIntegerValue(value);
  CFIndex LogicalMin = IOHIDElementGetLogicalMin(v3);
  CFIndex LogicalMax = IOHIDElementGetLogicalMax(v3);
  CFIndex PhysicalMin = IOHIDElementGetPhysicalMin(v3);
  CFIndex PhysicalMax = IOHIDElementGetPhysicalMax(v3);
  double v9 = 0.0;
  if (type == 2)
  {
    uint32_t v17 = IOHIDElementGetUnitExponent(v3) & 0xF;
    if (v17 > 7)
    {
      double v19 = __exp10((double)(int)(16 - v17));
      double v18 = 0.0;
      double v9 = 1.0 / v19;
      goto LABEL_25;
    }
    double v9 = __exp10((double)v17);
    goto LABEL_16;
  }
  if (type || (uint64_t CalibrationInfo = _IOHIDElementGetCalibrationInfo((uint64_t)v3)) == 0)
  {
LABEL_16:
    double v18 = 0.0;
    goto LABEL_25;
  }
  uint64_t v11 = *(void *)(CalibrationInfo + 32);
  uint64_t v12 = *(void *)(CalibrationInfo + 40);
  if (v11 == v12) {
    CFIndex PhysicalMin = -1;
  }
  else {
    CFIndex PhysicalMin = *(void *)(CalibrationInfo + 32);
  }
  if (v11 == v12) {
    CFIndex PhysicalMax = 1;
  }
  else {
    CFIndex PhysicalMax = *(void *)(CalibrationInfo + 40);
  }
  CFIndex v13 = *(void *)(CalibrationInfo + 8);
  if (*(void *)CalibrationInfo != v13)
  {
    if (IntegerValue <= *(void *)CalibrationInfo) {
      return (double)PhysicalMin;
    }
    if (IntegerValue >= v13) {
      return (double)PhysicalMax;
    }
    CFIndex LogicalMin = *(void *)CalibrationInfo;
    CFIndex LogicalMax = *(void *)(CalibrationInfo + 8);
  }
  CFIndex v15 = *(void *)(CalibrationInfo + 16);
  CFIndex v14 = *(void *)(CalibrationInfo + 24);
  if (v15 != v14)
  {
    double_t result = (double)(PhysicalMax - PhysicalMin) * 0.5 + (double)PhysicalMin;
    if (IntegerValue >= v15)
    {
      if (IntegerValue <= v14) {
        return result;
      }
      CFIndex PhysicalMin = (uint64_t)result;
      CFIndex LogicalMin = *(void *)(CalibrationInfo + 24);
    }
    else
    {
      CFIndex PhysicalMax = (uint64_t)result;
      CFIndex LogicalMax = *(void *)(CalibrationInfo + 16);
    }
  }
  double v18 = *(double *)(CalibrationInfo + 48);
LABEL_25:
  double v20 = 1.0;
  if (v9 != 0.0) {
    double v20 = v9;
  }
  double_t result = v20
         * ((double)(IntegerValue - LogicalMin)
          * (double)(PhysicalMax - PhysicalMin)
          / (double)(LogicalMax - LogicalMin)
          + (double)PhysicalMin);
  if (v18 != 0.0) {
    return v18 * (double)(uint64_t)llround(result / v18);
  }
  return result;
}

CFIndex IOHIDValueGetLength(IOHIDValueRef value)
{
  return *((unsigned int *)value + 10);
}

void *_IOHIDValueCopyToElementValuePtr(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(__IOHIDElement **)(a1 + 16);
  stat v5 = *(void **)(a1 + 48);
  size_t v6 = *(unsigned int *)(a1 + 40);
  if (IOHIDElementGetLogicalMin(v4) < 0) {
    LODWORD(v7) = 1;
  }
  else {
    unint64_t v7 = (unint64_t)IOHIDElementGetLogicalMax(v4) >> 63;
  }
  if (v5) {
    int64_t v8 = v5;
  }
  else {
    int64_t v8 = (void *)(a1 + 56);
  }

  return __IOHIDValueConvertByteToWord(v8, (void *)(a2 + 20), v6, v7);
}

void *__IOHIDValueConvertByteToWord(void *__src, void *__dst, size_t __len, int a4)
{
  unsigned int v5 = __len;
  double_t result = memmove(__dst, __src, __len);
  if (v5 && a4 && (v5 & 3) != 0)
  {
    char v8 = 8 * (v5 & 3);
    uint64_t v9 = v5 >> 2;
    unsigned int v10 = *((_DWORD *)__dst + v9);
    if ((v10 >> (v8 - 1))) {
      *((_DWORD *)__dst + v9) = v10 | (-1 << v8);
    }
  }
  return result;
}

void *_IOHIDValueCopyToElementValueHeader(uint64_t a1, IOHIDElementCookie *a2)
{
  uint64_t v4 = *(__IOHIDElement **)(a1 + 16);
  *a2 = IOHIDElementGetCookie(v4);
  a2[1] = *(_DWORD *)(a1 + 40);
  unsigned int v5 = *(void **)(a1 + 48);
  size_t v6 = *(unsigned int *)(a1 + 40);
  if (IOHIDElementGetLogicalMin(v4) < 0) {
    LODWORD(v7) = 1;
  }
  else {
    unint64_t v7 = (unint64_t)IOHIDElementGetLogicalMax(v4) >> 63;
  }
  if (v5) {
    char v8 = v5;
  }
  else {
    char v8 = (void *)(a1 + 56);
  }

  return __IOHIDValueConvertByteToWord(v8, a2 + 2, v6, v7);
}

void __IOHIDValueRelease(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    if (!*(unsigned char *)(a1 + 24)) {
      CFRelease(v2);
    }
  }
}

uint64_t initrosetta_convert_to_system_absolute_time(uint64_t a1)
{
  int v2 = (void *)RosettaLibrary_libLibrary;
  if (!RosettaLibrary_libLibrary)
  {
    int v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary = (uint64_t)v2;
  }
  unint64_t v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_system_absolute_time");
  dynLinkrosetta_convert_to_system_absolute_time[0] = v3;
  if (!v3) {
    return a1;
  }

  return ((uint64_t (*)(uint64_t))v3)(a1);
}

uint64_t initrosetta_convert_to_rosetta_absolute_time(uint64_t a1)
{
  int v2 = (void *)RosettaLibrary_libLibrary;
  if (!RosettaLibrary_libLibrary)
  {
    int v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary = (uint64_t)v2;
  }
  unint64_t v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_rosetta_absolute_time");
  dynLinkrosetta_convert_to_rosetta_absolute_time[0] = v3;
  if (!v3) {
    return a1;
  }

  return ((uint64_t (*)(uint64_t))v3)(a1);
}

void _IOHIDElementReleasePrivate(void *a1)
{
  int v2 = (const void *)a1[7];
  if (v2)
  {
    CFRelease(v2);
    a1[7] = 0;
  }
  unint64_t v3 = (const void *)a1[8];
  if (v3)
  {
    CFRelease(v3);
    a1[8] = 0;
  }
  uint64_t v4 = (const void *)a1[9];
  if (v4)
  {
    CFRelease(v4);
    a1[9] = 0;
  }
  unsigned int v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
  size_t v6 = (const void *)a1[10];
  if (v6)
  {
    CFRelease(v6);
    a1[10] = 0;
  }
  unint64_t v7 = (const void *)a1[12];
  if (v7)
  {
    CFRelease(v7);
    a1[12] = 0;
  }
  char v8 = (const void *)a1[13];
  if (v8)
  {
    CFRelease(v8);
    a1[13] = 0;
  }
  uint64_t v9 = (const void *)a1[3];
  if (v9)
  {
    CFRelease(v9);
    a1[3] = 0;
  }
  unsigned int v10 = (void *)a1[11];
  if (v10) {
    free(v10);
  }
  a1[11] = 0;
}

uint64_t _IOHIDElementCreateWithParentAndData(uint64_t a1, const void *a2, const void *a3, uint64_t a4, int a5)
{
  if (!a4) {
    return 0;
  }
  uint64_t Private = _IOHIDElementCreatePrivate();
  if (Private)
  {
    *(void *)(Private + 48) = CFRetain(a3);
    *(void *)(Private + 32) = a4;
    *(_DWORD *)(Private + 40) = a5;
    if (a2) {
      CFTypeRef v10 = CFRetain(a2);
    }
    else {
      CFTypeRef v10 = 0;
    }
    *(void *)(Private + 72) = v10;
  }
  return Private;
}

uint64_t _IOHIDElementCreateWithElement(const __CFAllocator *a1, uint64_t a2, int a3, int a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t Private = _IOHIDElementCreatePrivate();
  uint64_t v9 = Private;
  if (Private)
  {
    *(_DWORD *)(Private + 40) = 0;
    *(void *)(Private + 80) = CFRetain((CFTypeRef)a2);
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 96);
    *(void *)(v9 + 48) = Mutable;
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    *(void *)(v9 + 32) = MutableBytePtr;
    memmove(MutableBytePtr, *(const void **)(a2 + 32), 0x60uLL);
    int v12 = -*(_DWORD *)(a2 + 40) - **(_DWORD **)(a2 + 32);
    CFIndex v13 = *(int **)(v9 + 32);
    *CFIndex v13 = v12;
    v13[1] = v12;
    void v13[6] = a3;
    _DWORD v13[7] = a4;
    v13[8] = a4;
    v13[19] = 0;
    v13[20] = 0;
  }
  return v9;
}

IOHIDElementCookie IOHIDElementGetCookie(IOHIDElementRef element)
{
  return *((_DWORD *)element + 10) + **((_DWORD **)element + 4);
}

uint64_t _IOHIDElementSetDevice(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t _IOHIDElementSetDeviceInterface(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

unint64_t _IOHIDElementGetLength(uint64_t a1)
{
  CFAllocatorRef v1 = *(_DWORD **)(a1 + 32);
  unsigned int v2 = v1[13];
  if (v1[19] && *(_DWORD *)(a1 + 40)) {
    unsigned int v2 = v1[14];
  }
  return ((unint64_t)v2 + 7) >> 3;
}

IOHIDElementType IOHIDElementGetType(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 12);
}

IOHIDElementRef IOHIDElementCreateWithDictionary(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  if (!dictionary) {
    return 0;
  }
  uint64_t Private = _IOHIDElementCreatePrivate();
  uint64_t v4 = (__IOHIDElement *)Private;
  if (Private)
  {
    *(_DWORD *)(Private + 40) = 0;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(allocator, 96);
    *((void *)v4 + 6) = Mutable;
    if (Mutable)
    {
      *((void *)v4 + 4) = CFDataGetMutableBytePtr(Mutable);
      return v4;
    }
    CFRelease(v4);
    return 0;
  }
  return v4;
}

IOHIDElementCollectionType IOHIDElementGetCollectionType(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 16);
}

uint32_t IOHIDElementGetUsagePage(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 24);
}

uint32_t IOHIDElementGetUsage(IOHIDElementRef element)
{
  uint64_t v1 = *((void *)element + 4);
  int v2 = *(_DWORD *)(v1 + 28);
  if (v2 == *(_DWORD *)(v1 + 32)) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)element + 10);
  }
  return v3 + v2;
}

uint64_t _IOHIDElementGetFlags(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 32) + 20);
}

Boolean IOHIDElementIsVirtual(IOHIDElementRef element)
{
  return *((void *)element + 10) != 0;
}

Boolean IOHIDElementIsRelative(IOHIDElementRef element)
{
  return (*(unsigned __int8 *)(*((void *)element + 4) + 20) >> 2) & 1;
}

Boolean IOHIDElementIsWrapping(IOHIDElementRef element)
{
  return (*(unsigned __int8 *)(*((void *)element + 4) + 20) >> 3) & 1;
}

Boolean IOHIDElementIsArray(IOHIDElementRef element)
{
  return (*(unsigned char *)(*((void *)element + 4) + 20) & 2) == 0;
}

Boolean IOHIDElementIsNonLinear(IOHIDElementRef element)
{
  return (*(unsigned __int8 *)(*((void *)element + 4) + 20) >> 4) & 1;
}

Boolean IOHIDElementHasPreferredState(IOHIDElementRef element)
{
  return (*(unsigned char *)(*((void *)element + 4) + 20) & 0x20) == 0;
}

Boolean IOHIDElementHasNullState(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 20) & 0x40;
}

CFStringRef IOHIDElementGetName(IOHIDElementRef element)
{
  CFStringRef result = (CFStringRef)*((void *)element + 12);
  if (result)
  {
    CFStringRef result = (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, @"Name");
    if (result)
    {
      CFStringRef v2 = result;
      CFTypeID v3 = CFGetTypeID(result);
      if (v3 == CFStringGetTypeID()) {
        return v2;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

CFTypeRef IOHIDElementGetProperty(IOHIDElementRef element, CFStringRef key)
{
  CFTypeRef result = (CFTypeRef)*((void *)element + 12);
  if (result) {
    return CFDictionaryGetValue((CFDictionaryRef)result, key);
  }
  return result;
}

uint32_t IOHIDElementGetReportID(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 64);
}

uint32_t IOHIDElementGetReportSize(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 56);
}

uint32_t IOHIDElementGetReportCount(IOHIDElementRef element)
{
  uint64_t v2 = *((void *)element + 4);
  uint32_t result = *(_DWORD *)(v2 + 92);
  if (*(_DWORD *)(v2 + 76))
  {
    if (*((_DWORD *)element + 10)) {
      return 1;
    }
  }
  return result;
}

uint32_t IOHIDElementGetUnit(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 68);
}

uint32_t IOHIDElementGetUnitExponent(IOHIDElementRef element)
{
  return *(_DWORD *)(*((void *)element + 4) + 72);
}

CFIndex IOHIDElementGetLogicalMin(IOHIDElementRef element)
{
  return *(int *)(*((void *)element + 4) + 36);
}

CFIndex IOHIDElementGetLogicalMax(IOHIDElementRef element)
{
  return *(int *)(*((void *)element + 4) + 40);
}

CFIndex IOHIDElementGetPhysicalMin(IOHIDElementRef element)
{
  return *(int *)(*((void *)element + 4) + 44);
}

CFIndex IOHIDElementGetPhysicalMax(IOHIDElementRef element)
{
  return *(int *)(*((void *)element + 4) + 48);
}

uint64_t IOHIDElementGetDuplicateIndex(uint64_t a1)
{
  if (!*(_DWORD *)(*(void *)(a1 + 32) + 76)) {
    return 0;
  }
  int v1 = *(_DWORD *)(a1 + 40);
  BOOL v2 = v1 != 0;
  unsigned int v3 = v1 - 1;
  if (v2) {
    return v3;
  }
  else {
    return 0;
  }
}

IOHIDDeviceRef IOHIDElementGetDevice(IOHIDElementRef element)
{
  return (IOHIDDeviceRef)*((void *)element + 2);
}

IOHIDElementRef IOHIDElementGetParent(IOHIDElementRef element)
{
  IOHIDElementRef result = (IOHIDElementRef)*((void *)element + 9);
  if (!result)
  {
    if (*((void *)element + 1))
    {
      CFArrayRef theArray = 0;
      CFAllocatorRef v3 = CFGetAllocator(element);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        unsigned int v5 = Mutable;
        int valuePtr = *(_DWORD *)(*((void *)element + 4) + 8);
        CFAllocatorRef v6 = CFGetAllocator(element);
        CFNumberRef v7 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(v5, @"ElementCookie", v7);
        CFRelease(v7);
        (*(void (**)(void, __CFDictionary *, CFArrayRef *, void))(**((void **)element + 1) + 72))(*((void *)element + 1), v5, &theArray, 0);
        if (theArray)
        {
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
          *((void *)element + 9) = CFRetain(ValueAtIndex);
          CFRelease(theArray);
        }
        CFRelease(v5);
      }
      return (IOHIDElementRef)*((void *)element + 9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFArrayRef IOHIDElementGetChildren(IOHIDElementRef element)
{
  CFArrayRef v8 = 0;
  CFArrayRef result = (CFArrayRef)*((void *)element + 8);
  if (!result)
  {
    if (*((void *)element + 1))
    {
      CFAllocatorRef v3 = CFGetAllocator(element);
      CFArrayRef result = CFDictionaryCreateMutable(v3, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (result)
      {
        uint64_t v4 = result;
        int valuePtr = *((_DWORD *)element + 10) + **((_DWORD **)element + 4);
        CFAllocatorRef v5 = CFGetAllocator(element);
        CFNumberRef v6 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(v4, @"CollectionCookie", v6);
        CFRelease(v6);
        (*(void (**)(void, __CFDictionary *, const __CFArray **, void))(**((void **)element + 1) + 72))(*((void *)element + 1), v4, &v8, 0);
        if (v8) {
          *((void *)element + 8) = v8;
        }
        CFRelease(v4);
        return v8;
      }
    }
  }
  return result;
}

void IOHIDElementAttach(IOHIDElementRef element, IOHIDElementRef toAttach)
{
  char v3 = 0;
  uint64_t v4 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  do
  {
    char v5 = v3;
    CFNumberRef v6 = (CFMutableArrayRef *)element;
    CFArrayRef Mutable = (const __CFArray *)*((void *)element + 7);
    if (!Mutable)
    {
      CFAllocatorRef v8 = CFGetAllocator(element);
      CFArrayRef Mutable = CFArrayCreateMutable(v8, 0, v4);
      void v6[7] = Mutable;
      if (!Mutable) {
        break;
      }
    }
    v9.CFIndex length = CFArrayGetCount(Mutable);
    v9.location = 0;
    if (CFArrayGetFirstIndexOfValue(Mutable, v9, toAttach) != -1) {
      break;
    }
    CFArrayAppendValue(v6[7], toAttach);
    char v3 = 1;
    element = toAttach;
    toAttach = (IOHIDElementRef)v6;
  }
  while ((v5 & 1) == 0);
}

void IOHIDElementDetach(IOHIDElementRef element, IOHIDElementRef toDetach)
{
  char v3 = 0;
  do
  {
    CFArrayRef v4 = (const __CFArray *)*((void *)element + 7);
    if (!v4) {
      break;
    }
    char v5 = v3;
    CFNumberRef v6 = (CFMutableArrayRef *)element;
    v8.CFIndex length = CFArrayGetCount(*((CFArrayRef *)element + 7));
    v8.location = 0;
    FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v4, v8, toDetach);
    if (FirstIndexOfValue == -1) {
      break;
    }
    CFArrayRemoveValueAtIndex(v6[7], FirstIndexOfValue);
    char v3 = 1;
    element = toDetach;
    toDetach = (IOHIDElementRef)v6;
  }
  while ((v5 & 1) == 0);
}

CFArrayRef IOHIDElementCopyAttached(IOHIDElementRef element)
{
  if (!*((void *)element + 7)) {
    return 0;
  }
  CFAllocatorRef v2 = CFGetAllocator(element);
  CFArrayRef v3 = (const __CFArray *)*((void *)element + 7);

  return CFArrayCreateCopy(v2, v3);
}

uint64_t _IOHIDElementGetValue(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void _IOHIDElementSetValue(uint64_t a1, uint64_t a2)
{
  CFArrayRef v3 = *(const void **)(a1 + 24);
  if (v3 != (const void *)a2)
  {
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 24) = 0;
    }
    if (a2) {
      *(void *)(a1 + 24) = _IOHIDValueCreateWithValue(*MEMORY[0x1E4F1CF80], a2, a1);
    }
  }
}

uint64_t _IOHIDElementGetCalibrationInfo(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

Boolean IOHIDElementSetProperty(IOHIDElementRef element, CFStringRef key, CFTypeRef property)
{
  if (*((void *)element + 12)
    || (CFAllocatorRef v6 = CFGetAllocator(element),
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
        (*((void *)element + 12) = Mutable) != 0))
  {
    *((unsigned char *)element + 112) = 1;
    CFTypeID v8 = CFGetTypeID(property);
    if (v8 == CFNumberGetTypeID())
    {
      int v9 = CFEqual(key, @"CalibrationMin");
      if (v9)
      {
        int v10 = 0;
LABEL_8:
        int v12 = 0;
LABEL_9:
        int v13 = 0;
LABEL_10:
        int v14 = 0;
LABEL_11:
        int v15 = 0;
LABEL_12:
        int v16 = 0;
LABEL_13:
        if (*((void *)element + 11)
          || (uint32_t v17 = malloc_type_malloc(0x38uLL, 0x100004021716A34uLL),
              *((void *)element + 11) = v17,
              *uint32_t v17 = 0u,
              v17[1] = 0u,
              _DWORD v17[2] = 0u,
              *((void *)v17 + 6) = 0,
              *((void *)element + 11)))
        {
          uint64_t valuePtr = 0;
          CFNumberGetValue((CFNumberRef)property, kCFNumberCFIndexType, &valuePtr);
          if (v9)
          {
            *(void *)(*((void *)element + 11) + 32) = valuePtr;
          }
          else if (v10)
          {
            *(void *)(*((void *)element + 11) + 40) = valuePtr;
          }
          else if (v12)
          {
            **((void **)element + 11) = valuePtr;
          }
          else if (v13)
          {
            *(void *)(*((void *)element + 11) + 8) = valuePtr;
          }
          else if (v14)
          {
            *(void *)(*((void *)element + 11) + 16) = valuePtr;
          }
          else if (v15)
          {
            *(void *)(*((void *)element + 11) + 24) = valuePtr;
          }
          else if (v16)
          {
            CFNumberGetValue((CFNumberRef)property, kCFNumberFloat64Type, (void *)(*((void *)element + 11) + 48));
          }
        }
        goto LABEL_39;
      }
      int v11 = CFEqual(key, @"CalibrationMax");
      if (v11)
      {
        int v10 = v11;
        goto LABEL_8;
      }
      int v18 = CFEqual(key, @"CalibrationSaturationMin");
      if (v18)
      {
        int v12 = v18;
        int v10 = 0;
        goto LABEL_9;
      }
      int v19 = CFEqual(key, @"CalibrationSaturationMax");
      if (v19)
      {
        int v13 = v19;
        int v10 = 0;
        int v12 = 0;
        goto LABEL_10;
      }
      int v20 = CFEqual(key, @"CalibrationDeadZoneMin");
      if (v20)
      {
        int v14 = v20;
        int v10 = 0;
        int v12 = 0;
        int v13 = 0;
        goto LABEL_11;
      }
      int v21 = CFEqual(key, @"CalibrationDeadZoneMax");
      if (v21)
      {
        int v15 = v21;
        int v10 = 0;
        int v12 = 0;
        int v13 = 0;
        int v14 = 0;
        goto LABEL_12;
      }
      int v22 = CFEqual(key, @"CalibrationGranularity");
      if (v22)
      {
        int v16 = v22;
        int v10 = 0;
        int v12 = 0;
        int v13 = 0;
        int v14 = 0;
        int v15 = 0;
        goto LABEL_13;
      }
    }
LABEL_39:
    CFDictionarySetValue(*((CFMutableDictionaryRef *)element + 12), key, property);
    LOBYTE(Mutable) = 1;
  }
  return Mutable;
}

CFStringRef __IOHIDElementGetRootKey(uint64_t a1)
{
  CFStringRef result = *(CFStringRef *)(a1 + 104);
  if (!result)
  {
    CFStringRef UUIDKey = __IOHIDDeviceGetUUIDKey(*(__IOHIDDevice **)(a1 + 16));
    CFArrayRef v4 = *(_DWORD **)(a1 + 32);
    int v5 = v4[7];
    if (v5 == v4[8]) {
      int v6 = 0;
    }
    else {
      int v6 = *(_DWORD *)(a1 + 40);
    }
    CFStringRef result = CFStringCreateWithFormat(0, 0, @"%@#%04lx#%04lx#%016lx#%ld", UUIDKey, v4[6], (v6 + v5), (*(_DWORD *)(a1 + 40) + *v4), v4[3]);
    *(void *)(a1 + 104) = result;
  }
  return result;
}

void __IOHIDElementSaveProperties(uint64_t a1, CFStringRef *a2)
{
  if (*(unsigned char *)(a1 + 112))
  {
    CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 96);
    if (v3)
    {
      CFStringRef RootKey = __IOHIDElementGetRootKey(a1);
      __IOHIDPropertySaveToKeyWithSpecialKeys(v3, RootKey, __KIOHIDElementSpecialKeys, a2);
      *(unsigned char *)(a1 + 112) = 0;
    }
  }
}

CFTypeID __IOHIDElementLoadProperties(uint64_t a1)
{
  CFStringRef RootKey = __IOHIDElementGetRootKey(a1);
  CFTypeID result = (CFTypeID)__IOHIDPropertyLoadFromKeyWithSpecialKeys(RootKey, (uint64_t *)__KIOHIDElementSpecialKeys);
  if (result)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)result;
    int v5 = *(const void **)(a1 + 96);
    if (v5) {
      CFRelease(v5);
    }
    *(void *)(a1 + 96) = v4;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v4, @"CalibrationMin");
    if (Value)
    {
      CFNumberRef v7 = Value;
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 == CFNumberGetTypeID()) {
        CFNumberGetValue(v7, kCFNumberCFIndexType, (void *)(*(void *)(a1 + 88) + 32));
      }
    }
    CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), @"CalibrationMax");
    if (v9)
    {
      CFNumberRef v10 = v9;
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 == CFNumberGetTypeID()) {
        CFNumberGetValue(v10, kCFNumberCFIndexType, (void *)(*(void *)(a1 + 88) + 40));
      }
    }
    CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), @"CalibrationSaturationMin");
    if (v12)
    {
      CFNumberRef v13 = v12;
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 == CFNumberGetTypeID()) {
        CFNumberGetValue(v13, kCFNumberCFIndexType, *(void **)(a1 + 88));
      }
    }
    CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), @"CalibrationSaturationMax");
    if (v15)
    {
      CFNumberRef v16 = v15;
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFNumberGetTypeID()) {
        CFNumberGetValue(v16, kCFNumberCFIndexType, (void *)(*(void *)(a1 + 88) + 8));
      }
    }
    CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), @"CalibrationDeadZoneMin");
    if (v18)
    {
      CFNumberRef v19 = v18;
      CFTypeID v20 = CFGetTypeID(v18);
      if (v20 == CFNumberGetTypeID()) {
        CFNumberGetValue(v19, kCFNumberCFIndexType, (void *)(*(void *)(a1 + 88) + 16));
      }
    }
    CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), @"CalibrationDeadZoneMax");
    if (v21)
    {
      CFNumberRef v22 = v21;
      CFTypeID v23 = CFGetTypeID(v21);
      if (v23 == CFNumberGetTypeID()) {
        CFNumberGetValue(v22, kCFNumberCFIndexType, (void *)(*(void *)(a1 + 88) + 24));
      }
    }
    CFTypeID result = (CFTypeID)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), @"CalibrationGranularity");
    if (result)
    {
      CFNumberRef v24 = (const __CFNumber *)result;
      CFTypeID v25 = CFGetTypeID((CFTypeRef)result);
      CFTypeID result = CFNumberGetTypeID();
      if (v25 == result) {
        CFTypeID result = CFNumberGetValue(v24, kCFNumberFloat64Type, (void *)(*(void *)(a1 + 88) + 48));
      }
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
  return result;
}

void __IOHIDSaveElementSet(uint64_t a1, CFStringRef *a2)
{
  if (a1) {
    __IOHIDElementSaveProperties(a1, a2);
  }
}

uint64_t __IOHIDLoadElementSet(uint64_t a1)
{
  if (a1) {
    return __IOHIDElementLoadProperties(a1);
  }
  return a1;
}

_OWORD *fat_iterator_open(const char *a1, int a2)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  int v3 = open(a1, 0);
  if (v3 == -1) {
    return 0;
  }
  int v4 = v3;
  memset(&v11, 0, sizeof(v11));
  int v5 = 0;
  uint64_t v6 = -1;
  if (fstat(v3, &v11) != -1 && v11.st_size >= 28)
  {
    CFNumberRef v7 = (int *)mmap(0, v11.st_size, 1, 2, v4, 0);
    uint64_t v6 = (uint64_t)v7;
    if (v7 == (int *)-1
      || (BYTE8(v14) = 1,
          __fat_iterator_init((uint64_t)&v12, v7, (unint64_t)v7 + v11.st_size, a2) == -1))
    {
      int v5 = 0;
    }
    else
    {
      CFTypeID v8 = malloc_type_malloc(0x30uLL, 0x10A0040D39FF539uLL);
      int v5 = v8;
      if (v8)
      {
        long long v9 = v13;
        _OWORD *v8 = v12;
        v8[1] = v9;
        void v8[2] = v14;
      }
    }
  }
  close(v4);
  if (!v5 && v6 != -1)
  {
    munmap((void *)v6, v11.st_size);
    return 0;
  }
  return v5;
}

uint64_t __fat_iterator_init(uint64_t a1, int *a2, unint64_t a3, int a4)
{
  unint64_t v4 = a3 - (void)a2;
  if (a3 - (unint64_t)a2 < 4) {
    return 0xFFFFFFFFLL;
  }
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  int v5 = *a2;
  if (*a2 > -17958195)
  {
    if ((v5 + 17958194) >= 2) {
      goto LABEL_6;
    }
LABEL_9:
    if (v4 < 0x1C) {
      return 0xFFFFFFFFLL;
    }
    *(unsigned char *)(a1 + 40) |= 2u;
    *(void *)(a1 + 32) = 1;
    return 0;
  }
  if (v5 != -1095041334)
  {
    if (v5 != -822415874 && v5 != -805638658)
    {
LABEL_6:
      if (!a4) {
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_9;
  }
  if (v4 < 8) {
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a2 + 2;
  unsigned int v8 = bswap32(a2[1]);
  *(_DWORD *)(a1 + 32) = v8;
  uint64_t v6 = 0xFFFFFFFFLL;
  if (v8 <= 0x20 && (unint64_t)&a2[5 * v8 + 2] <= a3)
  {
    *(unsigned char *)(a1 + 40) |= 2u;
    return 0;
  }
  return v6;
}

_OWORD *fat_iterator_for_data(int *a1, unint64_t a2, int a3)
{
  long long v6 = 0u;
  long long v7 = 0u;
  long long v5 = 0u;
  if (__fat_iterator_init((uint64_t)&v5, a1, a2, a3) == -1) {
    return 0;
  }
  CFTypeID result = malloc_type_malloc(0x30uLL, 0x10A0040D39FF539uLL);
  if (result)
  {
    long long v4 = v6;
    *CFTypeID result = v5;
    result[1] = v4;
    result[2] = v7;
  }
  return result;
}

void fat_iterator_close(void **a1)
{
  if ((_BYTE)a1[5])
  {
    CFAllocatorRef v2 = *a1;
    if (*a1) {
      munmap(v2, (unsigned char *)a1[1] - (unsigned char *)v2);
    }
  }

  free(a1);
}

uint64_t fat_iterator_num_arches(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t fat_iterator_is_iterable(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 40) << 30 >> 31);
}

uint64_t fat_iterator_next_arch(uint64_t *a1, unint64_t *a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 9);
  if (a1[2])
  {
    unsigned int v3 = *((_DWORD *)a1 + 8);
    if (v2 < v3)
    {
      uint64_t v4 = a1[3] + 20 * v2;
      unsigned int v5 = *(_DWORD *)(v4 + 12);
      uint64_t v6 = *a1 + bswap32(*(_DWORD *)(v4 + 8));
      unint64_t v7 = v6 + bswap32(v5);
      if (v7 <= a1[1])
      {
        if (a2) {
          *a2 = v7;
        }
        unsigned int v3 = v2 + 1;
      }
      else
      {
        uint64_t v6 = 0;
      }
LABEL_13:
      *((_DWORD *)a1 + 9) = v3;
      return v6;
    }
  }
  else if (!v2)
  {
    uint64_t v6 = *a1;
    if (a2) {
      *a2 = a1[1];
    }
    unsigned int v3 = 1;
    goto LABEL_13;
  }
  return 0;
}

uint64_t fat_iterator_reset(uint64_t result)
{
  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t fat_iterator_find_fat_arch(int **a1, cpu_type_t a2, cpu_subtype_t a3, uint64_t a4)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  int v24 = 0;
  if (a1[2])
  {
    uint64_t v8 = *((unsigned int *)a1 + 8);
    long long v9 = (fat_arch *)malloc_type_malloc((20 * v8), 0x9AE2AB23uLL);
    if (!v9) {
      return 0;
    }
    CFNumberRef v10 = v9;
    memcpy(v9, a1[3], (20 * v8));
    if (v8)
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        long long v12 = (int8x16_t *)&v10[i];
        int8x16_t *v12 = vrev32q_s8(*(int8x16_t *)&v10[i].cputype);
        v12[1].i32[0] = bswap32(v10[i].align);
      }
    }
    long long v13 = v10;
  }
  else
  {
    long long v14 = *a1;
    int v16 = **a1;
    unsigned int v15 = (*a1)[1];
    LODWORD(v22) = 0;
    if ((v16 & 0xFEFFFFFF) == 0xCEFAEDFE)
    {
      LODWORD(v22) = bswap32(v15);
      unsigned int v17 = bswap32(v14[2]);
    }
    else
    {
      LODWORD(v22) = v15;
      unsigned int v17 = v14[2];
    }
    long long v13 = 0;
    HIDWORD(v22) = v17;
    LODWORD(v23) = 0;
    LODWORD(v8) = 1;
    HIDWORD(v23) = *((_DWORD *)a1 + 2) - v14;
    int v24 = 1;
    CFNumberRef v10 = (fat_arch *)&v22;
  }
  CFNumberRef v19 = NXFindBestFatArch(a2, a3, v10, v8);
  if (!v19)
  {
    uint64_t v18 = 0;
    if (!v13) {
      return v18;
    }
    goto LABEL_16;
  }
  if (a4)
  {
    long long v20 = *(_OWORD *)&v19->cputype;
    *(_DWORD *)(a4 + 16) = v19->align;
    *(_OWORD *)a4 = v20;
  }
  uint64_t v18 = 1;
  if (v13) {
LABEL_16:
  }
    free(v13);
  return v18;
}

char *fat_iterator_find_arch(int **a1, cpu_type_t a2, cpu_subtype_t a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  int v9 = 0;
  if (!fat_iterator_find_fat_arch(a1, a2, a3, (uint64_t)&v7)) {
    return 0;
  }
  CFTypeID result = (char *)*a1 + v8;
  if (a4) {
    *a4 = &result[HIDWORD(v8)];
  }
  return result;
}

char *fat_iterator_find_host_arch(int **a1, void *a2)
{
  CFTypeID result = (char *)NXGetLocalArchInfo();
  if (result)
  {
    cpu_type_t v5 = *((_DWORD *)result + 2);
    cpu_subtype_t v6 = *((_DWORD *)result + 3);
    return fat_iterator_find_arch(a1, v5, v6, a2);
  }
  return result;
}

uint64_t fat_iterator_file_start(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t fat_iterator_file_end(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t macho_find_symbol(int *a1, unint64_t a2, char *a3, unsigned char *a4, void *a5)
{
  if (a5) {
    *a5 = 0;
  }
  uint64_t v50 = 0;
  if (macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_symtab, (uint64_t)&v50))return 2; {
  int v11 = *a1;
  }
  int v12 = *a1 + 822415874;
  BOOL v14 = *a1 != -17958193 && v11 != -805638658;
  unsigned int v15 = v50[2];
  unsigned int v49 = v12 & 0xFEFFFFFF;
  if ((v12 & 0xFEFFFFFF) != 0)
  {
    unsigned int v16 = v50[3];
    unsigned int v17 = v50[4];
  }
  else
  {
    unsigned int v15 = bswap32(v15);
    unsigned int v17 = bswap32(v50[4]);
    unsigned int v16 = bswap32(v50[3]);
  }
  uint64_t v18 = (char *)a1 + v15;
  if (v14) {
    uint64_t v19 = 12 * v16;
  }
  else {
    uint64_t v19 = 16 * v16;
  }
  if ((unint64_t)&v18[v19] > a2 || (unint64_t)a1 + v17 > a2) {
    return 0xFFFFFFFFLL;
  }
  if (!v16) {
    return 2;
  }
  __s1 = a3;
  uint64_t v47 = (char *)a1 + v17;
  long long v44 = a5;
  long long v45 = a4;
  uint64_t v21 = 0;
  uint64_t v22 = v15;
  uint64_t v23 = v16;
  for (uint64_t i = v15; ; i += 12)
  {
    if (v11 == -17958193 || v11 == -805638658)
    {
      unsigned int v26 = *(int *)((char *)a1 + v22);
      if (v49)
      {
        uint64_t v27 = &v18[16 * v21];
        uint64_t v28 = (unsigned __int8 *)(v27 + 4);
        uint64_t v29 = v27 + 5;
        unint64_t v30 = *(void *)((char *)a1 + v22 + 8);
      }
      else
      {
        unsigned int v26 = bswap32(v26);
        uint64_t v31 = &v18[16 * v21];
        uint64_t v28 = (unsigned __int8 *)(v31 + 4);
        uint64_t v29 = v31 + 5;
        unint64_t v30 = bswap64(*(void *)((char *)a1 + v22 + 8));
      }
    }
    else
    {
      unsigned int v26 = *(int *)((char *)a1 + i);
      if (v49)
      {
        LODWORD(v30) = *(int *)((char *)a1 + i + 8);
      }
      else
      {
        unsigned int v26 = bswap32(v26);
        LODWORD(v30) = bswap32(*(int *)((char *)a1 + i + 8));
      }
      uint64_t v28 = (unsigned __int8 *)a1 + i + 4;
      uint64_t v29 = (char *)a1 + i + 5;
      unint64_t v30 = v30;
    }
    unint64_t v48 = v30;
    unsigned int v32 = *v28;
    if (v26) {
      BOOL v33 = v32 > 0x1F;
    }
    else {
      BOOL v33 = 1;
    }
    if (v33) {
      goto LABEL_49;
    }
    uint64_t v34 = &v47[v26];
    if ((unint64_t)v34 > a2) {
      return 0xFFFFFFFFLL;
    }
    char v35 = *v29;
    int v36 = v18;
    int v37 = strcmp(__s1, v34);
    uint64_t v18 = v36;
    if (v37) {
      goto LABEL_49;
    }
    if (v45) {
      unsigned char *v45 = v32;
    }
    unsigned int v38 = (v32 >> 1) & 7;
    if (v38 != 7) {
      break;
    }
    uint64_t section_numbered = macho_find_section_numbered(a1, a2, v35);
    if (v44 && section_numbered)
    {
      if (v11 == -17958193 || v11 == -805638658)
      {
        unint64_t v40 = *(void *)(section_numbered + 32);
        if (v49)
        {
          unsigned int v41 = *(_DWORD *)(section_numbered + 48);
        }
        else
        {
          unint64_t v40 = bswap64(v40);
          unsigned int v41 = bswap32(*(_DWORD *)(section_numbered + 48));
        }
        uint64_t result = 0;
        unint64_t v43 = v48 - v40;
      }
      else
      {
        unsigned int v42 = *(_DWORD *)(section_numbered + 32);
        if (v49)
        {
          unsigned int v41 = *(_DWORD *)(section_numbered + 40);
        }
        else
        {
          unsigned int v42 = bswap32(v42);
          unsigned int v41 = bswap32(*(_DWORD *)(section_numbered + 40));
        }
        uint64_t result = 0;
        unint64_t v43 = v48 - v42;
      }
      *long long v44 = (char *)a1 + v41 + v43;
      return result;
    }
    uint64_t v18 = v36;
    if (section_numbered) {
      return 0;
    }
LABEL_49:
    ++v21;
    v22 += 16;
    if (!--v23) {
      return 2;
    }
  }
  if (v38 <= 5 && ((1 << v38) & 0x23) != 0) {
    return 1;
  }
  return 2;
}

uint64_t macho_find_symtab(int *a1, unint64_t a2, void *a3)
{
  uint64_t v5 = 0;
  if (!a3) {
    return macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_symtab, (uint64_t)&v5);
  }
  *a3 = 0;
  uint64_t result = macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_symtab, (uint64_t)&v5);
  if (!result) {
    *a3 = v5;
  }
  return result;
}

uint64_t macho_find_section_numbered(int *a1, unint64_t a2, char a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  BYTE1(v5) = a3;
  if (*a1 == -17958193 || *a1 == -805638658) {
    LOBYTE(v5) = 1;
  }
  if (macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_sect_in_lc, (uint64_t)&v5))return 0; {
  else
  }
    return v6;
}

uint64_t macho_scan_load_commands(int *a1, unint64_t a2, uint64_t (*a3)(int *, unint64_t, uint64_t, uint64_t), uint64_t a4)
{
  int v7 = *a1;
  uint64_t v8 = 0xFFFFFFFFLL;
  if (*a1 <= -17958195)
  {
    if (v7 != -822415874)
    {
      if (v7 != -805638658) {
        return v8;
      }
      int v9 = 0;
      uint64_t v10 = 1;
      goto LABEL_7;
    }
    int v9 = 0;
    uint64_t v10 = 1;
LABEL_9:
    int v11 = 3;
    uint64_t v12 = 7;
    goto LABEL_10;
  }
  uint64_t v10 = 0;
  int v9 = 1;
  if (v7 == -17958194) {
    goto LABEL_9;
  }
  if (v7 != -17958193) {
    return v8;
  }
LABEL_7:
  int v11 = 7;
  uint64_t v12 = 8;
LABEL_10:
  if ((unint64_t)a1 < a2)
  {
    long long v13 = &a1[v12];
    if ((unint64_t)v13 <= a2)
    {
      unsigned int v14 = a1[4];
      if (v9)
      {
        unsigned int v15 = a1[5];
      }
      else
      {
        unsigned int v14 = bswap32(v14);
        unsigned int v15 = bswap32(a1[5]);
      }
      unsigned int v16 = (int *)((char *)v13 + v15);
      if ((unint64_t)v16 <= a2)
      {
        if (!v14) {
          return 2;
        }
        while (1)
        {
          LODWORD(v17) = v13[1];
          unsigned int v18 = bswap32(v17);
          uint64_t v17 = v9 ? v17 : v18;
          uint64_t v19 = (int *)((char *)v13 + v17);
          if ((v17 & v11) != 0 || v19 > v16) {
            break;
          }
          int v21 = a3(v13, a2, v10, a4);
          if (v21 != 2)
          {
            if (v21 == 3) {
              LODWORD(v8) = 2;
            }
            else {
              LODWORD(v8) = -1;
            }
            if (v21) {
              return v8;
            }
            else {
              return 0;
            }
          }
          uint64_t v8 = 2;
          long long v13 = v19;
          if (!--v14) {
            return v8;
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v8;
}

uint64_t __macho_lc_is_symtab(int *a1, unint64_t a2, int a3, int **a4)
{
  if ((unint64_t)(a1 + 16) > a2) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *a1;
  if (a3)
  {
    if (v5 == 0x2000000)
    {
      unsigned int v6 = bswap32(a1[1]);
      goto LABEL_8;
    }
    return 2;
  }
  if (v5 != 2) {
    return 2;
  }
  unsigned int v6 = a1[1];
LABEL_8:
  if (v6 == 24 && (unint64_t)(a1 + 48) <= a2)
  {
    uint64_t v4 = 0;
    *a4 = a1;
    return v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t macho_find_dysymtab(int *a1, unint64_t a2, void *a3)
{
  uint64_t v5 = 0;
  if (!a3) {
    return macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_dysymtab, (uint64_t)&v5);
  }
  *a3 = 0;
  uint64_t result = macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__macho_lc_is_dysymtab, (uint64_t)&v5);
  if (!result) {
    *a3 = v5;
  }
  return result;
}

uint64_t __macho_lc_is_dysymtab(int *a1, unint64_t a2, int a3, int **a4)
{
  if ((unint64_t)(a1 + 16) > a2) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *a1;
  if (a3)
  {
    if (v5 == 184549376)
    {
      unsigned int v6 = bswap32(a1[1]);
      goto LABEL_8;
    }
    return 2;
  }
  if (v5 != 11) {
    return 2;
  }
  unsigned int v6 = a1[1];
LABEL_8:
  if (v6 == 80 && (unint64_t)(a1 + 160) <= a2)
  {
    uint64_t v4 = 0;
    *a4 = a1;
    return v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t __uuid_callback(_DWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*a1 != 27) {
    return 2;
  }
  if ((unint64_t)a1 + a1[1] > a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(_DWORD *)a4 = 16;
  *(void *)(a4 + 8) = a1 + 2;
  return result;
}

uint64_t macho_find_uuid(int *a1, unint64_t a2, void *a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t result = macho_scan_load_commands(a1, a2, __uuid_callback, (uint64_t)&v5);
  if (a3)
  {
    if (!result) {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t __macho_sect_in_lc(unsigned int *a1, unint64_t a2, int a3, uint64_t a4)
{
  unsigned int v4 = *(unsigned __int8 *)(a4 + 2);
  unsigned int v5 = *(unsigned __int8 *)(a4 + 1);
  if (v4 > v5) {
    return 3;
  }
  int v7 = a1 + 16;
  if ((unint64_t)(a1 + 16) > a2) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = *a1;
  unsigned int v9 = bswap32(*a1);
  if (a3) {
    unsigned int v8 = v9;
  }
  if (v8 == 1)
  {
    unsigned int v12 = a1[1];
    if (a3)
    {
      unsigned int v12 = bswap32(v12);
      unsigned int v13 = bswap32(a1[12]);
    }
    else
    {
      unsigned int v13 = a1[12];
    }
    uint64_t v6 = 0xFFFFFFFFLL;
    if ((unint64_t)a1 + v12 <= a2 && 68 * v13 + 56 == v12)
    {
      if (v13)
      {
        unsigned int v14 = a1 + 14;
        while (1)
        {
          LOBYTE(v4) = v4 + 1;
          if (v5 == v4) {
            break;
          }
          v14 += 17;
          if (!--v13)
          {
LABEL_28:
            *(unsigned char *)(a4 + 2) = v4;
            return 2;
          }
        }
        goto LABEL_31;
      }
      return 2;
    }
  }
  else
  {
    if (v8 != 25) {
      return 2;
    }
    unsigned int v10 = a1[1];
    if (a3)
    {
      unsigned int v10 = bswap32(v10);
      unsigned int v11 = bswap32(*v7);
    }
    else
    {
      unsigned int v11 = *v7;
    }
    uint64_t v6 = 0xFFFFFFFFLL;
    if ((unint64_t)a1 + v10 <= a2 && 80 * v11 + 72 == v10)
    {
      if (v11)
      {
        unsigned int v14 = a1 + 18;
        while (1)
        {
          LOBYTE(v4) = v4 + 1;
          if (v5 == v4) {
            break;
          }
          v14 += 20;
          if (!--v11) {
            goto LABEL_28;
          }
        }
LABEL_31:
        uint64_t v6 = 0;
        *(unsigned char *)(a4 + 2) = v5;
        *(void *)(a4 + 8) = v14;
        return v6;
      }
      return 2;
    }
  }
  return v6;
}

uint64_t macho_find_source_version(int *a1, unint64_t a2, void *a3)
{
  *a3 = 0;
  return macho_scan_load_commands(a1, a2, (uint64_t (*)(int *, unint64_t, uint64_t, uint64_t))__source_version_callback, (uint64_t)a3);
}

uint64_t __source_version_callback(uint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  if (*(_DWORD *)a1 != 42) {
    return 2;
  }
  if (a1 + (unint64_t)*(unsigned int *)(a1 + 4) > a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a4 = *(void *)(a1 + 8);
  return result;
}

uint64_t macho_swap(mach_header_64 *mh)
{
  if (mh->magic == -805638658)
  {
    uint64_t v2 = 1;
    swap_mach_header_64(mh, NX_LittleEndian);
    if (mh->ncmds)
    {
      uint32_t v7 = 0;
      uint64_t v8 = 32;
      do
      {
        unsigned int v9 = (segment_command_64 *)((char *)mh + v8);
        unsigned int v10 = *(int32_t *)((char *)&mh->cputype + v8);
        if (*(uint32_t *)((char *)&mh->magic + v8) == 419430400) {
          swap_segment_command_64(v9, NX_LittleEndian);
        }
        else {
          swap_load_command((load_command *)v9, NX_LittleEndian);
        }
        v8 += bswap32(v10);
        ++v7;
      }
      while (v7 < mh->ncmds);
      return 1;
    }
  }
  else
  {
    if (mh->magic != -822415874) {
      return 0;
    }
    uint64_t v2 = 1;
    swap_mach_header((mach_header *)mh, NX_LittleEndian);
    if (mh->ncmds)
    {
      uint32_t v3 = 0;
      uint64_t v4 = 28;
      do
      {
        unsigned int v5 = (segment_command *)((char *)mh + v4);
        unsigned int v6 = *(int32_t *)((char *)&mh->cputype + v4);
        if (*(uint32_t *)((char *)&mh->magic + v4) == 0x1000000) {
          swap_segment_command(v5, NX_LittleEndian);
        }
        else {
          swap_load_command((load_command *)v5, NX_LittleEndian);
        }
        v4 += bswap32(v6);
        ++v3;
      }
      while (v3 < mh->ncmds);
      return 1;
    }
  }
  return v2;
}

uint64_t macho_unswap(mach_header_64 *mh)
{
  if (mh->magic == -17958193)
  {
    if (mh->ncmds)
    {
      uint32_t v6 = 0;
      uint64_t v7 = 32;
      do
      {
        uint64_t v8 = (segment_command_64 *)((char *)mh + v7);
        uint64_t v9 = *(unsigned int *)((char *)&mh->cputype + v7);
        if (*(uint32_t *)((char *)&mh->magic + v7) == 25) {
          swap_segment_command_64(v8, NX_BigEndian);
        }
        else {
          swap_load_command((load_command *)v8, NX_BigEndian);
        }
        v7 += v9;
        ++v6;
      }
      while (v6 < mh->ncmds);
    }
    swap_mach_header_64(mh, NX_BigEndian);
    return 1;
  }
  if (mh->magic == -17958194)
  {
    if (mh->ncmds)
    {
      uint32_t v2 = 0;
      uint64_t v3 = 28;
      do
      {
        uint64_t v4 = (segment_command *)((char *)mh + v3);
        uint64_t v5 = *(unsigned int *)((char *)&mh->cputype + v3);
        if (*(uint32_t *)((char *)&mh->magic + v3) == 1) {
          swap_segment_command(v4, NX_BigEndian);
        }
        else {
          swap_load_command((load_command *)v4, NX_BigEndian);
        }
        v3 += v5;
        ++v2;
      }
      while (v2 < mh->ncmds);
    }
    swap_mach_header((mach_header *)mh, NX_BigEndian);
    return 1;
  }
  return 0;
}

char *macho_get_segment_by_name(_DWORD *a1, char *__s2)
{
  if (*a1 != -17958194) {
    return 0;
  }
  int v3 = a1[4];
  if (!v3) {
    return 0;
  }
  uint64_t v5 = 28;
  while (1)
  {
    uint32_t v6 = (char *)a1 + v5;
    if (*(_DWORD *)((char *)a1 + v5) == 1 && !strncmp(v6 + 8, __s2, 0x10uLL)) {
      break;
    }
    v5 += *((unsigned int *)v6 + 1);
    if (!--v3) {
      return 0;
    }
  }
  return v6;
}

char *macho_get_segment_by_name_64(_DWORD *a1, char *__s2)
{
  if (*a1 != -17958193) {
    return 0;
  }
  int v3 = a1[4];
  if (!v3) {
    return 0;
  }
  uint64_t v5 = 32;
  while (1)
  {
    uint32_t v6 = (char *)a1 + v5;
    if (*(_DWORD *)((char *)a1 + v5) == 25 && !strncmp(v6 + 8, __s2, 0x10uLL)) {
      break;
    }
    v5 += *((unsigned int *)v6 + 1);
    if (!--v3) {
      return 0;
    }
  }
  return v6;
}

char *macho_get_section_by_name(_DWORD *a1, char *a2, const char *a3)
{
  if (*a1 != -17958194) {
    return 0;
  }
  uint64_t result = macho_get_segment_by_name(a1, a2);
  if (result)
  {
    uint64_t v5 = result + 56;
    int v6 = *((_DWORD *)result + 12);
    if (v6)
    {
      int v7 = 0;
      uint64_t v8 = (uint64_t)&result[68 * (v6 - 1) + 124];
      while (strncmp(v5, a3, 0x10uLL))
      {
        ++v7;
        v5 += 68;
        if (v6 == v7)
        {
          uint64_t v5 = (const char *)v8;
          int v7 = v6;
          break;
        }
      }
    }
    else
    {
      int v7 = 0;
    }
    if (v7 == v6) {
      return 0;
    }
    else {
      return (char *)v5;
    }
  }
  return result;
}

char *macho_get_section_by_name_64(_DWORD *a1, char *a2, const char *a3)
{
  if (*a1 != -17958193) {
    return 0;
  }
  uint64_t result = macho_get_segment_by_name_64(a1, a2);
  if (result)
  {
    uint64_t v5 = result + 72;
    int v6 = *((_DWORD *)result + 16);
    if (v6)
    {
      int v7 = 0;
      uint64_t v8 = (uint64_t)&result[80 * (v6 - 1) + 152];
      while (strncmp(v5, a3, 0x10uLL))
      {
        ++v7;
        v5 += 80;
        if (v6 == v7)
        {
          uint64_t v5 = (const char *)v8;
          int v7 = v6;
          break;
        }
      }
    }
    else
    {
      int v7 = 0;
    }
    if (v7 == v6) {
      return 0;
    }
    else {
      return (char *)v5;
    }
  }
  return result;
}

uint64_t macho_remove_linkedit(mach_header_64 *a1, void *a2)
{
  int v4 = macho_swap(a1);
  int v5 = v4;
  if (a1->magic == -17958193)
  {
    p_uint64_t reserved = a1 + 1;
  }
  else
  {
    if (a1->magic != -17958194)
    {
      uint64_t v13 = 0;
      if (!v4) {
        return v13;
      }
      goto LABEL_22;
    }
    p_uint64_t reserved = (mach_header_64 *)&a1->reserved;
  }
  uint32_t ncmds = a1->ncmds;
  if (ncmds)
  {
    uint64_t v8 = p_reserved;
    do
    {
      int magic = v8->magic;
      size_t cputype = v8->cputype;
      if ((int)v8->magic > 10)
      {
        if (magic == 11) {
          goto LABEL_19;
        }
        if (magic == 25 && !strncmp((const char *)&v8->cpusubtype, "__LINKEDIT", 0xAuLL))
        {
          uint64_t reserved = *(void *)&v8[1].magic;
LABEL_18:
          *a2 = reserved;
LABEL_19:
          uint32_t v12 = a1->sizeofcmds - cputype;
          --a1->ncmds;
          a1->sizeofcmds = v12;
          bzero(v8, cputype);
          goto LABEL_20;
        }
      }
      else if (magic == 1)
      {
        if (!strncmp((const char *)&v8->cpusubtype, "__LINKEDIT", 0xAuLL))
        {
          uint64_t reserved = v8->reserved;
          goto LABEL_18;
        }
      }
      else if (magic == 2)
      {
        goto LABEL_19;
      }
      memmove(p_reserved, v8, cputype);
      p_uint64_t reserved = (mach_header_64 *)((char *)p_reserved + cputype);
LABEL_20:
      uint64_t v8 = (mach_header_64 *)((char *)v8 + cputype);
      --ncmds;
    }
    while (ncmds);
  }
  uint64_t v13 = 1;
  if (v5) {
LABEL_22:
  }
    macho_unswap(a1);
  return v13;
}

uint64_t macho_trim_linkedit(mach_header_64 *a1, void *a2)
{
  *a2 = 0;
  int v4 = macho_swap(a1);
  if (a1->magic == -17958194)
  {
    p_unint64_t reserved = (mach_header_64 *)&a1->reserved;
  }
  else
  {
    if (a1->magic != -17958193) {
      goto LABEL_27;
    }
    p_unint64_t reserved = a1 + 1;
  }
  uint32_t ncmds = a1->ncmds;
  if (!ncmds)
  {
LABEL_27:
    uint64_t v17 = 0;
    if (!v4) {
      return v17;
    }
    goto LABEL_30;
  }
  uint32_t magic = a1->magic;
  int v31 = v4;
  uint64_t v29 = a2;
  int v7 = 0;
  p_uint32_t magic = 0;
  uint64_t v9 = 0;
  uint32_t v10 = a1->ncmds;
  unsigned int v11 = p_reserved;
  do
  {
    int v12 = v11->magic;
    uint64_t cputype = v11->cputype;
    if ((int)v11->magic > 10)
    {
      if (v12 == 11)
      {
        int v7 = v11;
        goto LABEL_18;
      }
      if (v12 != 25) {
        goto LABEL_18;
      }
    }
    else if (v12 != 1)
    {
      if (v12 == 2) {
        p_uint32_t magic = &v11->magic;
      }
      goto LABEL_18;
    }
    if (!strncmp((const char *)&v11->cpusubtype, "__LINKEDIT", 0xAuLL)) {
      uint64_t v9 = v11;
    }
LABEL_18:
    unsigned int v11 = (mach_header_64 *)((char *)v11 + cputype);
    --v10;
  }
  while (v10);
  if (!v9) {
    goto LABEL_29;
  }
  if (v7)
  {
    if (p_magic)
    {
      unsigned int v14 = 16;
      size_t v15 = 8 * v7[2].filetype;
      if (magic == -17958194) {
        unsigned int v14 = 12;
      }
      size_t v16 = (p_magic[5] + v14 * (unint64_t)p_magic[3] + 7) & 0x3FFFFFFFF8;
      if (magic == -17958194) {
        unint64_t reserved = v9->reserved;
      }
      else {
        unint64_t reserved = *(void *)&v9[1].magic;
      }
      unint64_t v20 = roundPageCrossSafe(8 * v7[2].filetype);
      uint64_t v21 = p_magic[2];
      uint64_t cpusubtype = v7[2].cpusubtype;
      uint64_t v23 = (char *)a1 + v21;
      if (v21 < cpusubtype)
      {
        memmove(v23, (char *)a1 + cpusubtype, v15);
        uint64_t v24 = p_magic[2];
        v7[2].uint64_t cpusubtype = v24;
        uint64_t v23 = (char *)a1 + v24 + v15;
      }
      bzero(v23, v16);
      if (v20 >= reserved) {
        unint64_t v25 = reserved;
      }
      else {
        unint64_t v25 = v20;
      }
      if (magic == -17958194)
      {
        v9[1].uint64_t cputype = v25;
        v9->unint64_t reserved = v25;
      }
      else
      {
        *(void *)&v9[1].uint32_t ncmds = v25;
        *(void *)&v9[1].uint32_t magic = v25;
      }
      *uint64_t v29 = reserved - v25;
      unsigned int v26 = &p_reserved->magic;
      do
      {
        size_t v27 = v26[1];
        if (*v26 == 2)
        {
          uint32_t v28 = a1->sizeofcmds - v27;
          --a1->ncmds;
          a1->sizeofcmds = v28;
          bzero(v26, v27);
        }
        else
        {
          if (p_reserved != (mach_header_64 *)v26) {
            memmove(p_reserved, v26, v26[1]);
          }
          p_unint64_t reserved = (mach_header_64 *)((char *)p_reserved + v27);
        }
        unsigned int v26 = (unsigned int *)((char *)v26 + v27);
        --ncmds;
      }
      while (ncmds);
      uint64_t v17 = 1;
      if (!v31) {
        return v17;
      }
LABEL_30:
      macho_unswap(a1);
      return v17;
    }
LABEL_29:
    uint64_t v17 = 0;
    if (!v31) {
      return v17;
    }
    goto LABEL_30;
  }
  if (v31) {
    macho_unswap(a1);
  }

  return macho_remove_linkedit(a1, v29);
}

__CFString *IOHIDDeviceCopyDescription(io_object_t *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  memset(name, 0, sizeof(name));
  io_registry_entry_t v2 = a1[2];
  if (v2)
  {
    if (IOObjectRetain(a1[2])) {
      io_registry_entry_t v3 = 0;
    }
    else {
      io_registry_entry_t v3 = v2;
    }
  }
  else
  {
    io_registry_entry_t v3 = 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v4, 0);
  if (Mutable)
  {
    IORegistryEntryGetName(v3, name);
    if (!name[0]) {
      IOObjectGetClass(v3, name);
    }
    io_registry_entry_t v19 = v3;
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFAllocatorRef v7 = CFGetAllocator(a1);
    CFStringRef v8 = CFStringCreateWithFormat(v6, 0, @"<IOHIDDevice %p [%p]  'ClassName=%s'", a1, v7, name);
    if (v8)
    {
      CFStringAppend(Mutable, v8);
      CFRelease(v8);
    }
    uint64_t v9 = 0;
    while (1)
    {
      CFStringRef v10 = __debugKeys[v9];
      CFNumberRef Property = (const __CFNumber *)IOHIDDeviceGetProperty((IOHIDDeviceRef)a1, v10);
      if (Property) {
        break;
      }
LABEL_20:
      if (++v9 == 12)
      {
        CFStringAppend(Mutable, @">");
        io_registry_entry_t v3 = v19;
        goto LABEL_22;
      }
    }
    CFNumberRef v12 = Property;
    CFTypeID v13 = CFGetTypeID(Property);
    if (v13 == CFNumberGetTypeID())
    {
      unsigned int valuePtr = 0;
      CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
      CFAllocatorRef v14 = CFGetAllocator(a1);
      CFStringRef v15 = CFStringCreateWithFormat(v14, 0, @" %@=%d", v10, valuePtr);
    }
    else
    {
      CFTypeID v16 = CFGetTypeID(v12);
      if (v16 != CFStringGetTypeID()) {
        goto LABEL_18;
      }
      CFAllocatorRef v17 = CFGetAllocator(a1);
      CFStringRef v15 = CFStringCreateWithFormat(v17, 0, @" %@=%@", v10, v12);
    }
    CFStringRef v8 = v15;
LABEL_18:
    if (v8)
    {
      CFStringAppend(Mutable, v8);
      CFRelease(v8);
    }
    goto LABEL_20;
  }
LABEL_22:
  if (v3) {
    IOObjectRelease(v3);
  }
  return Mutable;
}

CFTypeRef IOHIDDeviceGetProperty(IOHIDDeviceRef device, CFStringRef key)
{
  CFNumberRef Value = 0;
  os_unfair_recursive_lock_lock_with_options();
  if ((*(unsigned int (**)(void, CFStringRef, const void **))(**((void **)device + 3) + 48))(*((void *)device + 3), key, &Value))
  {
    BOOL v4 = 1;
  }
  else
  {
    BOOL v4 = Value == 0;
  }
  if (v4)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)device + 7);
    if (v5) {
      CFNumberRef Value = CFDictionaryGetValue(v5, key);
    }
    else {
      CFNumberRef Value = 0;
    }
  }
  os_unfair_recursive_lock_unlock();
  return Value;
}

void _IOHIDDeviceReleasePrivate(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 208))
  {
    unsigned int v2 = atomic_load((unsigned int *)(a1 + 224));
    if (v2 != 3) {
      _IOHIDDeviceReleasePrivate_cold_1(&v26, v27, (unsigned int *)(a1 + 224));
    }
  }
  io_registry_entry_t v3 = *(const void **)(a1 + 240);
  if (v3) {
    CFRelease(v3);
  }
  BOOL v4 = *(const void **)(a1 + 248);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 248) = 0;
  }
  CFDictionaryRef v5 = *(const void **)(a1 + 56);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 56) = 0;
  }
  CFAllocatorRef v6 = *(const void **)(a1 + 64);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 64) = 0;
  }
  CFAllocatorRef v7 = *(const void **)(a1 + 72);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 72) = 0;
  }
  CFStringRef v8 = *(const void **)(a1 + 296);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 296) = 0;
  }
  uint64_t v9 = *(const void **)(a1 + 312);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 312) = 0;
  }
  CFStringRef v10 = *(const void **)(a1 + 304);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 304) = 0;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v12 = *(void *)(a1 + 32);
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    *(void *)(a1 + 32) = 0;
  }
  io_object_t v13 = *(_DWORD *)(a1 + 8);
  if (v13)
  {
    IOObjectRelease(v13);
    *(_DWORD *)(a1 + 8) = 0;
  }
  io_object_t v14 = *(_DWORD *)(a1 + 96);
  if (v14)
  {
    IOObjectRelease(v14);
    *(_DWORD *)(a1 + 96) = 0;
  }
  CFStringRef v15 = *(IONotificationPort **)(a1 + 88);
  if (v15)
  {
    IONotificationPortDestroy(v15);
    *(void *)(a1 + 88) = 0;
  }
  CFTypeID v16 = *(IOCFPlugInInterface ***)(a1 + 40);
  if (v16)
  {
    IODestroyPlugInInterface(v16);
    *(void *)(a1 + 40) = 0;
  }
  if (atomic_load((unint64_t *)(a1 + 320)))
  {
    unsigned int v18 = (const void *)atomic_load((unint64_t *)(a1 + 320));
    _Block_release(v18);
  }
  if (atomic_load((unint64_t *)(a1 + 328)))
  {
    unint64_t v20 = (const void *)atomic_load((unint64_t *)(a1 + 328));
    _Block_release(v20);
  }
  if (atomic_load((unint64_t *)(a1 + 336)))
  {
    uint64_t v22 = (const void *)atomic_load((unint64_t *)(a1 + 336));
    _Block_release(v22);
  }
  uint64_t v23 = *(const void **)(a1 + 280);
  if (v23) {
    CFRelease(v23);
  }
  uint64_t v24 = *(const void **)(a1 + 264);
  if (v24) {
    CFRelease(v24);
  }
  unint64_t v25 = *(const void **)(a1 + 288);
  if (v25)
  {
    CFRelease(v25);
  }
}

uint64_t _IOHIDDeviceGetIOCFPlugInInterface(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

IOHIDDeviceRef IOHIDDeviceCreate(CFAllocatorRef allocator, io_service_t service)
{
  kern_return_t v3;
  CFUUIDRef v4;
  CFUUIDRef v5;
  kern_return_t v6;
  IOCFPlugInInterface **v7;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  CFUUIDRef v9;
  CFUUIDBytes v10;
  int v11;
  IOCFPlugInInterface **v12;
  HRESULT (__cdecl *v13)(void *, REFIID, LPVOID *);
  CFUUIDRef v14;
  CFUUIDBytes v15;
  uint64_t Private;
  __IOHIDDevice *v17;
  IOCFPlugInInterface **v18;
  uint64_t v19;
  int v21;
  NSObject *v22;
  int v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  uint64_t entryID;
  SInt32 theScore;
  uint64_t v29;
  uint64_t v30;
  IOCFPlugInInterface **theInterface;

  theInterface = 0;
  uint64_t v29 = 0;
  unint64_t v30 = 0;
  SInt32 theScore = 0;
  entryID = 0;
  if (__deviceInit != -1) {
    dispatch_once(&__deviceInit, &__block_literal_global_7);
  }
  io_registry_entry_t v3 = IOObjectRetain(service);
  if (v3)
  {
    uint64_t v21 = v3;
    uint64_t v22 = _IOHIDLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      IOHIDDeviceCreate_cold_3(v21, v22);
    }
    return 0;
  }
  IORegistryEntryGetRegistryEntryID(service, &entryID);
  BOOL v4 = CFUUIDGetConstantUUIDWithBytes(0, 0x7Du, 0xDEu, 0xECu, 0xA8u, 0xA7u, 0xB4u, 0x11u, 0xDAu, 0x8Au, 0xEu, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  CFDictionaryRef v5 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  CFAllocatorRef v6 = IOCreatePlugInInterfaceForService(service, v4, v5, &theInterface, &theScore);
  if (v6)
  {
    uint64_t v23 = v6;
    uint64_t v24 = _IOHIDLog();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      IOHIDDeviceCreate_cold_2((uint64_t *)&entryID, v23, v24);
    }
    goto LABEL_22;
  }
  CFAllocatorRef v7 = theInterface;
  QueryInterface = (*theInterface)->QueryInterface;
  uint64_t v9 = CFUUIDGetConstantUUIDWithBytes(0, 0x47u, 0x4Bu, 0xDCu, 0x8Eu, 0x9Fu, 0x4Au, 0x11u, 0xDAu, 0xB3u, 0x66u, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
  CFStringRef v10 = CFUUIDGetUUIDBytes(v9);
  uint64_t v11 = ((uint64_t (*)(IOCFPlugInInterface **, void, void, uint64_t *))QueryInterface)(v7, *(void *)&v10.byte0, *(void *)&v10.byte8, &v30);
  if (v11)
  {
    unint64_t v25 = v11;
    uint64_t v26 = _IOHIDLog();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      IOHIDDeviceCreate_cold_1(v25, v26);
    }
    goto LABEL_21;
  }
  uint64_t v12 = theInterface;
  io_object_t v13 = (*theInterface)->QueryInterface;
  io_object_t v14 = CFUUIDGetConstantUUIDWithBytes(0, 0xB4u, 0x73u, 0x25u, 0x6Cu, 0x6Au, 0x72u, 0x4Eu, 4u, 0xB6u, 0x94u, 0xC4u, 0, 0x1Du, 0x20u, 0x20u, 0x20u);
  CFStringRef v15 = CFUUIDGetUUIDBytes(v14);
  if (((unsigned int (*)(IOCFPlugInInterface **, void, void, uint64_t *))v13)(v12, *(void *)&v15.byte0, *(void *)&v15.byte8, &v29))
  {
    uint64_t v29 = 0;
  }
  uint64_t Private = _IOHIDDeviceCreatePrivate();
  if (!Private)
  {
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
    }
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 24))(v30);
    }
LABEL_21:
    IODestroyPlugInInterface(theInterface);
LABEL_22:
    IOObjectRelease(service);
    return 0;
  }
  CFAllocatorRef v17 = (__IOHIDDevice *)Private;
  unsigned int v18 = theInterface;
  io_registry_entry_t v19 = v29;
  *(void *)(Private + 24) = v30;
  *(void *)(Private + 32) = v19;
  *(void *)(Private + 40) = v18;
  *(_DWORD *)(Private + 8) = service;
  *(void *)(Private + 48) = 0;
  *(void *)(Private + 272) = 0;
  IORegistryEntryGetRegistryEntryID(service, (uint64_t *)(Private + 16));
  return v17;
}

BOOL __IOHIDDeviceCallbackBaseDataIsEqual(CFDataRef theData, const __CFData *a2)
{
  if (theData == a2) {
    return 1;
  }
  BOOL result = 0;
  if (theData)
  {
    if (a2)
    {
      BytePtr = CFDataGetBytePtr(theData);
      CFAllocatorRef v6 = CFDataGetBytePtr(a2);
      BOOL result = 0;
      if (BytePtr)
      {
        if (v6) {
          return *(void *)BytePtr == *(void *)v6;
        }
      }
    }
  }
  return result;
}

io_service_t IOHIDDeviceGetService(IOHIDDeviceRef device)
{
  return *((_DWORD *)device + 2);
}

IOReturn IOHIDDeviceOpen(IOHIDDeviceRef device, IOOptionBits options)
{
  uint64_t v2 = *(void *)&options;
  os_unfair_recursive_lock_lock_with_options();
  LODWORD(v2) = (*(uint64_t (**)(void, uint64_t))(**((void **)device + 3) + 32))(*((void *)device + 3), v2);
  os_unfair_recursive_lock_unlock();
  return v2;
}

IOReturn IOHIDDeviceClose(IOHIDDeviceRef device, IOOptionBits options)
{
  uint64_t v2 = *(void *)&options;
  os_unfair_recursive_lock_lock_with_options();
  LODWORD(v2) = (*(uint64_t (**)(void, uint64_t))(**((void **)device + 3) + 40))(*((void *)device + 3), v2);
  os_unfair_recursive_lock_unlock();
  return v2;
}

Boolean IOHIDDeviceConformsTo(IOHIDDeviceRef device, uint32_t usagePage, uint32_t usage)
{
  CFAllocatorRef v6 = CFGetAllocator(device);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFStringRef v8 = Mutable;
  uint32_t valuePtr = 513;
  CFAllocatorRef v9 = CFGetAllocator(device);
  CFNumberRef v10 = CFNumberCreate(v9, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v8, @"Type", v10);
  CFRelease(v10);
  uint32_t valuePtr = usagePage;
  CFAllocatorRef v11 = CFGetAllocator(device);
  CFNumberRef v12 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v8, @"UsagePage", v12);
  CFRelease(v12);
  uint32_t valuePtr = usage;
  CFAllocatorRef v13 = CFGetAllocator(device);
  CFNumberRef v14 = CFNumberCreate(v13, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v8, @"Usage", v14);
  CFRelease(v14);
  CFArrayRef v15 = IOHIDDeviceCopyMatchingElements(device, v8, 0);
  if (v15)
  {
    CFArrayRef v16 = v15;
    CFIndex Count = CFArrayGetCount(v15);
    if (Count < 1)
    {
LABEL_8:
      Boolean v21 = 0;
    }
    else
    {
      CFIndex v18 = Count;
      CFIndex v19 = 0;
      while (1)
      {
        CFNumberRef ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(v16, v19);
        if (IOHIDElementGetCollectionType(ValueAtIndex) == kIOHIDElementCollectionTypePhysical
          || IOHIDElementGetCollectionType(ValueAtIndex) == kIOHIDElementCollectionTypeApplication)
        {
          break;
        }
        if (v18 == ++v19) {
          goto LABEL_8;
        }
      }
      Boolean v21 = 1;
    }
    CFRelease(v16);
  }
  else
  {
    Boolean v21 = 0;
  }
  CFRelease(v8);
  return v21;
}

CFArrayRef IOHIDDeviceCopyMatchingElements(IOHIDDeviceRef device, CFDictionaryRef matching, IOOptionBits options)
{
  CFArrayRef theArray = 0;
  if ((*(unsigned int (**)(void, CFDictionaryRef, CFArrayRef *, void))(**((void **)device + 3) + 72))(*((void *)device + 3), matching, &theArray, *(void *)&options))
  {
    BOOL v4 = theArray == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  if (v4)
  {
    if (theArray)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        CFIndex v6 = Count;
        CFIndex v7 = 0;
        CFStringRef v8 = (const CFSetCallBacks *)MEMORY[0x1E4F1D548];
        do
        {
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
          _IOHIDElementSetDevice((uint64_t)ValueAtIndex, (uint64_t)device);
          os_unfair_recursive_lock_lock_with_options();
          CFSetRef Mutable = (const __CFSet *)*((void *)device + 8);
          if (Mutable
            || (CFAllocatorRef v11 = CFGetAllocator(device),
                CFSetRef Mutable = CFSetCreateMutable(v11, 0, v8),
                (*((void *)device + 8) = Mutable) != 0))
          {
            if (!CFSetContainsValue(Mutable, ValueAtIndex))
            {
              CFSetSetValue(*((CFMutableSetRef *)device + 8), ValueAtIndex);
              if (*((unsigned char *)device + 256)) {
                __IOHIDElementLoadProperties((uint64_t)ValueAtIndex);
              }
            }
          }
          os_unfair_recursive_lock_unlock();
          ++v7;
        }
        while (v6 != v7);
      }
    }
  }
  else
  {
    CFRelease(theArray);
    return 0;
  }
  return theArray;
}

Boolean IOHIDDeviceSetProperty(IOHIDDeviceRef device, CFStringRef key, CFTypeRef property)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetRef Mutable = (__CFDictionary *)*((void *)device + 7);
  if (Mutable
    || (CFAllocatorRef v7 = CFGetAllocator(device),
        CFSetRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
        (*((void *)device + 7) = Mutable) != 0))
  {
    *((unsigned char *)device + 257) = 1;
    CFDictionarySetValue(Mutable, key, property);
    if (CFEqual(key, @"IOHIDDeviceSuspend"))
    {
      CFTypeID v8 = CFGetTypeID(property);
      if (v8 == CFBooleanGetTypeID())
      {
        CFAllocatorRef v9 = (__IOHIDQueue *)*((void *)device + 30);
        if (v9)
        {
          if ((CFTypeRef)*MEMORY[0x1E4F1CFD0] == property) {
            IOHIDQueueStop(v9);
          }
          else {
            IOHIDQueueStart(v9);
          }
        }
      }
    }
    os_unfair_recursive_lock_unlock();
    return (*(unsigned int (**)(void, CFStringRef, CFTypeRef))(**((void **)device + 3) + 56))(*((void *)device + 3), key, property) == 0;
  }
  else
  {
    os_unfair_recursive_lock_unlock();
    return 0;
  }
}

void IOHIDDeviceScheduleWithRunLoop(IOHIDDeviceRef device, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*((void *)device + 24)) {
    IOHIDDeviceUnscheduleFromRunLoop(device, v6, v7);
  }
  __IOHIDDeviceSetupAsyncSupport((uint64_t)device);
  *((void *)device + 24) = runLoop;
  *((void *)device + 25) = runLoopMode;
  CFRunLoopAddSource(runLoop, *((CFRunLoopSourceRef *)device + 13), runLoopMode);
  CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(*((IONotificationPortRef *)device + 11));
  if (RunLoopSource) {
    CFRunLoopAddSource(*((CFRunLoopRef *)device + 24), RunLoopSource, *((CFRunLoopMode *)device + 25));
  }
  CFAllocatorRef v9 = (__IOHIDQueue *)*((void *)device + 30);
  os_unfair_recursive_lock_unlock();
  if (v9)
  {
    IOHIDQueueScheduleWithRunLoop(v9, runLoop, runLoopMode);
    IOHIDQueueStart(v9);
  }
}

void IOHIDDeviceUnscheduleFromRunLoop(IOHIDDeviceRef device, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v4 = (__CFRunLoop *)*((void *)device + 24);
  if (v4)
  {
    CFDictionaryRef v5 = (__IOHIDQueue *)*((void *)device + 30);
    CFStringRef v6 = (const __CFString *)*((void *)device + 25);
    os_unfair_recursive_lock_unlock();
    if (v5)
    {
      IOHIDQueueStop(v5);
      IOHIDQueueUnscheduleFromRunLoop(v5, v4, v6);
    }
    os_unfair_recursive_lock_lock_with_options();
    CFStringRef v7 = (IONotificationPort *)*((void *)device + 11);
    if (v7)
    {
      CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(v7);
      if (RunLoopSource) {
        CFRunLoopRemoveSource(*((CFRunLoopRef *)device + 24), RunLoopSource, *((CFRunLoopMode *)device + 25));
      }
    }
    CFAllocatorRef v9 = (__CFRunLoopSource *)*((void *)device + 13);
    if (v9) {
      CFRunLoopRemoveSource(*((CFRunLoopRef *)device + 24), v9, *((CFRunLoopMode *)device + 25));
    }
    *((void *)device + 24) = 0;
    *((void *)device + 25) = 0;
  }

  os_unfair_recursive_lock_unlock();
}

void __IOHIDDeviceSetupAsyncSupport(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  memset(&context.info, 0, 72);
  context.version = 1;
  if (*(void *)(a1 + 192) || *(void *)(a1 + 208)) {
    __IOHIDDeviceSetupAsyncSupport_cold_3();
  }
  if (!*(void *)(a1 + 104))
  {
    int v2 = (*(uint64_t (**)(void, void (__cdecl **)(void *)))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24), &context.perform);
    perform = context.perform;
    if (v2) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = context.perform == 0;
    }
    if (v4)
    {
      int v9 = v2;
      memset(v14, 0, sizeof(v14));
      os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      LODWORD(v11) = 67109376;
      HIDWORD(v11) = v9;
      __int16 v12 = 2048;
      CFAllocatorRef v13 = perform;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      *(void *)(a1 + 104) = context.perform;
      CFRunLoopSourceGetContext((CFRunLoopSourceRef)perform, &context);
      long long v5 = *(_OWORD *)&context.retain;
      *(_OWORD *)(a1 + 112) = *(_OWORD *)&context.version;
      *(_OWORD *)(a1 + 128) = v5;
      long long v6 = *(_OWORD *)&context.hash;
      *(_OWORD *)(a1 + 144) = *(_OWORD *)&context.copyDescription;
      *(_OWORD *)(a1 + 160) = v6;
      uint64_t v7 = *(void *)(a1 + 120);
      *(void *)(a1 + 176) = context.cancel;
      *(void *)(a1 + 184) = v7;
      if (v7)
      {
        if (!*(void *)(a1 + 88))
        {
          IONotificationPortRef v8 = IONotificationPortCreate(0);
          *(void *)(a1 + 88) = v8;
          if (!v8) {
            __IOHIDDeviceSetupAsyncSupport_cold_2(&v11, v14);
          }
        }
        return;
      }
    }
    __IOHIDDeviceSetupAsyncSupport_cold_1(&v11, v14);
  }
}

void IOHIDDeviceSetDispatchQueue(IOHIDDeviceRef device, dispatch_queue_t queue)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  __IOHIDDeviceSetupAsyncSupport((uint64_t)device);
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)__str = 0u;
  long long v12 = 0u;
  label = dispatch_queue_get_label(queue);
  long long v5 = "";
  if (label) {
    long long v5 = label;
  }
  snprintf(__str, 0x100uLL, "%s.IOHIDDeviceRef:0x%llx", v5, *((void *)device + 2));
  dispatch_queue_t v6 = dispatch_queue_create_with_target_V2(__str, 0, queue);
  *((void *)device + 26) = v6;
  if (v6)
  {
    CFRetain(device);
    void handler[5] = MEMORY[0x1E4F143A8];
    handler[6] = 0x40000000;
    void handler[7] = __IOHIDDeviceSetDispatchQueue_block_invoke;
    handler[8] = &__block_descriptor_tmp_26;
    handler[9] = device;
    uint64_t v7 = dispatch_mach_create();
    *((void *)device + 27) = v7;
    if (v7)
    {
      IONotificationPortRef v8 = (__IOHIDQueue *)*((void *)device + 30);
      if (v8)
      {
        IOHIDQueueSetDispatchQueue(v8, *((dispatch_queue_t *)device + 26));
        CFRetain(device);
        int v9 = (__IOHIDQueue *)*((void *)device + 30);
        handler[0] = MEMORY[0x1E4F143A8];
        handler[1] = 0x40000000;
        handler[2] = __IOHIDDeviceSetDispatchQueue_block_invoke_2;
        handler[3] = &__block_descriptor_tmp_27;
        handler[4] = device;
        IOHIDQueueSetCancelHandler(v9, handler);
      }
    }
    else
    {
      CFRelease(device);
    }
  }
  os_unfair_recursive_lock_unlock();
}

void __IOHIDDeviceSetDispatchQueue_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    os_unfair_recursive_lock_lock_with_options();
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 216));
    *(void *)(*(void *)(a1 + 32) + 216) = 0;
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 240);
    os_unfair_recursive_lock_unlock();
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 232);
    if (v5) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      (*(void (**)(void))(v5 + 16))();
      _Block_release(*(const void **)(*(void *)(a1 + 32) + 232));
      *(void *)(*(void *)(a1 + 32) + 232) = 0;
    }
    os_unfair_recursive_lock_unlock();
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 208));
    uint64_t v7 = *(const void **)(a1 + 32);
    CFRelease(v7);
  }
  else if (a2 == 2)
  {
    uint64_t msg = dispatch_mach_msg_get_msg();
    (*(void (**)(uint64_t, void, void, void))(*(void *)(a1 + 32) + 176))(msg, 0, 0, *(void *)(*(void *)(a1 + 32) + 184));
  }
}

void __IOHIDDeviceSetDispatchQueue_block_invoke_2(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFRelease(*(CFTypeRef *)(*(void *)(a1 + 32) + 240));
  *(void *)(*(void *)(a1 + 32) + 240) = 0;
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 216);
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 232);
  if (v3) {
    BOOL v4 = v2 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    (*(void (**)(void))(v3 + 16))();
    _Block_release(*(const void **)(*(void *)(a1 + 32) + 232));
    *(void *)(*(void *)(a1 + 32) + 232) = 0;
  }
  os_unfair_recursive_lock_unlock();
  uint64_t v5 = *(const void **)(a1 + 32);

  CFRelease(v5);
}

void IOHIDDeviceSetCancelHandler(IOHIDDeviceRef device, dispatch_block_t handler)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  if (!handler || *((void *)device + 29)) {
    IOHIDDeviceSetCancelHandler_cold_1(&v4, v5);
  }
  *((void *)device + 29) = _Block_copy(handler);

  os_unfair_recursive_lock_unlock();
}

void IOHIDDeviceActivate(IOHIDDeviceRef device)
{
  if (*((void *)device + 26)) {
    BOOL v1 = *((void *)device + 24) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    device = (IOHIDDeviceRef)_os_crash_msg();
    __break(1u);
  }
  IOHIDDeviceRef v2 = device;
  if ((atomic_fetch_or((atomic_uint *volatile)device + 56, 1u) & 1) == 0)
  {
    CFMachPortGetPort(*((CFMachPortRef *)device + 23));
    dispatch_mach_connect();
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)v2 + 11), *((dispatch_queue_t *)v2 + 26));
    uint64_t v3 = (__IOHIDQueue *)*((void *)v2 + 30);
    if (v3)
    {
      IOHIDQueueActivate(v3);
    }
  }
}

void IOHIDDeviceCancel(IOHIDDeviceRef device)
{
  if (*((void *)device + 26)) {
    BOOL v1 = *((void *)device + 24) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    device = (IOHIDDeviceRef)_os_crash_msg();
    __break(1u);
  }
  IOHIDDeviceRef v2 = device;
  if ((atomic_fetch_or((atomic_uint *volatile)device + 56, 2u) & 2) == 0)
  {
    dispatch_mach_cancel();
    uint64_t v3 = (IONotificationPort *)*((void *)v2 + 11);
    if (v3)
    {
      IONotificationPortDestroy(v3);
      *((void *)v2 + 11) = 0;
    }
    uint64_t v4 = (__IOHIDQueue *)*((void *)v2 + 30);
    if (v4)
    {
      IOHIDQueueCancel(v4);
    }
  }
}

void IOHIDDeviceRegisterRemovalCallback(IOHIDDeviceRef device, IOHIDCallback callback, void *context)
{
  v13[0] = context;
  v13[1] = callback;
  if (atomic_load((unsigned int *)device + 56)) {
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  if ((*((void *)device + 37)
     || (CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, (const CFSetCallBacks *)&__callbackBaseSetCallbacks),
         (*((void *)device + 37) = Mutable) != 0))
    && (v7 = CFGetAllocator(device), (CFDataRef v8 = CFDataCreate(v7, (const UInt8 *)v13, 16)) != 0))
  {
    CFDataRef v9 = v8;
    CFNumberRef v10 = (__CFSet *)*((void *)device + 37);
    if (callback)
    {
      CFSetAddValue(v10, v9);
      uint64_t v11 = (IONotificationPort *)*((void *)device + 11);
      if (v11
        || (uint64_t v11 = IONotificationPortCreate(0), (*((void *)device + 11) = v11) != 0) && *((_DWORD *)device + 2))
      {
        if (*((void *)device + 24))
        {
          CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(v11);
          if (RunLoopSource) {
            CFRunLoopAddSource(*((CFRunLoopRef *)device + 24), RunLoopSource, *((CFRunLoopMode *)device + 25));
          }
        }
        if (!*((_DWORD *)device + 24)) {
          IOServiceAddInterestNotification(*((IONotificationPortRef *)device + 11), *((_DWORD *)device + 2), "IOGeneralInterest", (IOServiceInterestCallback)__IOHIDDeviceNotification, device, (io_object_t *)device + 24);
        }
      }
    }
    else
    {
      CFSetRemoveValue(v10, v9);
    }
    os_unfair_recursive_lock_unlock();
    CFRelease(v9);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void __IOHIDDeviceNotification(CFSetRef *a1, uint64_t a2, int a3)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  if (a1 && a3 == -536870896)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFSetRef v4 = a1[37];
    if (v4 && (CFIndex Count = CFSetGetCount(v4)) != 0)
    {
      uint64_t v6 = Count;
      CFTypeRef v7 = CFRetain(a1);
      uint64_t v8 = 8 * v6;
      MEMORY[0x1F4188790](v7, v9);
      CFNumberRef v10 = (CFDataRef *)((char *)v14 - ((8 * v6 + 15) & 0xFFFFFFFFFFFFFFF0));
      if ((unint64_t)(8 * v6) >= 0x200) {
        size_t v11 = 512;
      }
      else {
        size_t v11 = 8 * v6;
      }
      bzero((char *)v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v11);
      bzero((char *)v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), 8 * v6);
      CFSetGetValues(a1[37], (const void **)((char *)v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0)));
      if (v6 >= 1)
      {
        do
        {
          if (*v10)
          {
            BytePtr = CFDataGetBytePtr(*v10);
            if (BytePtr)
            {
              long long v13 = (void (*)(void, void, CFSetRef *))*((void *)BytePtr + 1);
              if (v13) {
                v13(*(void *)BytePtr, 0, a1);
              }
            }
          }
          ++v10;
          --v6;
        }
        while (v6);
      }
      os_unfair_recursive_lock_unlock();
      CFRelease(a1);
    }
    else
    {
      os_unfair_recursive_lock_unlock();
    }
  }
}

void IOHIDDeviceRegisterInputValueCallback(IOHIDDeviceRef device, IOHIDValueCallback callback, void *context)
{
  *(void *)unsigned int bytes = context;
  IOHIDValueCallback v18 = callback;
  if (atomic_load((unsigned int *)device + 56)) {
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  }
  CFRetain(device);
  os_unfair_recursive_lock_lock_with_options();
  if (*((void *)device + 39))
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, (const CFSetCallBacks *)&__callbackBaseSetCallbacks);
    *((void *)device + 39) = Mutable;
    os_unfair_recursive_lock_unlock();
    if (!Mutable) {
      goto LABEL_18;
    }
  }
  CFAllocatorRef v7 = CFGetAllocator(device);
  CFDataRef v8 = CFDataCreate(v7, bytes, 16);
  if (v8)
  {
    CFDataRef v9 = v8;
    if (callback)
    {
      os_unfair_recursive_lock_lock_with_options();
      if (!*((void *)device + 30))
      {
        CFAllocatorRef v10 = CFGetAllocator(device);
        size_t v11 = IOHIDQueueCreate(v10, device, 20, 0);
        *((void *)device + 30) = v11;
        if (!v11)
        {
LABEL_17:
          os_unfair_recursive_lock_unlock();
          CFRelease(v9);
          goto LABEL_18;
        }
        __IOHIDDeviceRegisterMatchingInputElements(device, v11, *((const __CFArray **)device + 31));
        long long v12 = (__CFRunLoop *)*((void *)device + 24);
        if (v12)
        {
          IOHIDQueueScheduleWithRunLoop(*((IOHIDQueueRef *)device + 30), v12, *((CFStringRef *)device + 25));
          IOHIDQueueStart(*((IOHIDQueueRef *)device + 30));
        }
        long long v13 = *((void *)device + 26);
        if (v13)
        {
          IOHIDQueueSetDispatchQueue(*((IOHIDQueueRef *)device + 30), v13);
          CFRetain(device);
          long long v14 = (__IOHIDQueue *)*((void *)device + 30);
          handler[0] = MEMORY[0x1E4F143A8];
          handler[1] = 0x40000000;
          handler[2] = __IOHIDDeviceRegisterInputValueCallback_block_invoke;
          handler[3] = &__block_descriptor_tmp_30;
          handler[4] = device;
          IOHIDQueueSetCancelHandler(v14, handler);
        }
      }
      os_unfair_recursive_lock_unlock();
      os_unfair_recursive_lock_lock_with_options();
      CFSetAddValue(*((CFMutableSetRef *)device + 39), v9);
    }
    else
    {
      os_unfair_recursive_lock_lock_with_options();
      CFSetRemoveValue(*((CFMutableSetRef *)device + 39), v9);
    }
    os_unfair_recursive_lock_unlock();
    os_unfair_recursive_lock_lock_with_options();
    long long v15 = (__IOHIDQueue *)*((void *)device + 30);
    if (v15) {
      IOHIDQueueRegisterValueAvailableCallback(v15, (IOHIDCallback)__IOHIDDeviceInputElementValueCallback, device);
    }
    goto LABEL_17;
  }
LABEL_18:
  CFRelease(device);
}

void __IOHIDDeviceRegisterMatchingInputElements(void *a1, __IOHIDQueue *a2, const __CFArray *cf)
{
  CFSetRef v4 = __IOHIDDeviceCopyMatchingInputElements(a1, cf);
  if (v4)
  {
    CFArrayRef v5 = v4;
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
      {
        CFNumberRef ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(v5, i);
        if (ValueAtIndex) {
          IOHIDQueueAddElement(a2, ValueAtIndex);
        }
      }
    }
    CFRelease(v5);
  }
}

void __IOHIDDeviceRegisterInputValueCallback_block_invoke(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFRelease(*(CFTypeRef *)(*(void *)(a1 + 32) + 240));
  *(void *)(*(void *)(a1 + 32) + 240) = 0;
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 216);
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 232);
  if (v3) {
    BOOL v4 = v2 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    (*(void (**)(void))(v3 + 16))();
    _Block_release(*(const void **)(*(void *)(a1 + 32) + 232));
    *(void *)(*(void *)(a1 + 32) + 232) = 0;
  }
  os_unfair_recursive_lock_unlock();
  CFArrayRef v5 = *(const void **)(a1 + 32);

  CFRelease(v5);
}

void __IOHIDDeviceInputElementValueCallback(CFSetRef *cf, int a2, __IOHIDQueue *a3)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  if (!a2 && cf[30] == a3)
  {
    CFRetain(cf);
    os_unfair_recursive_lock_lock_with_options();
    CFIndex Count = CFSetGetCount(cf[39]);
    if (Count)
    {
      uint64_t v7 = Count;
      size_t v8 = 8 * Count;
      MEMORY[0x1F4188790](Count, v6);
      CFDataRef v9 = (CFDataRef *)((char *)v17 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
      size_t v10 = v8 >= 0x200 ? 512 : v8;
      bzero((char *)v17 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
      bzero((char *)v17 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v8);
      CFSetGetValues(cf[39], (const void **)((char *)v17 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0)));
      IOHIDValueRef Value = IOHIDQueueCopyNextValue(a3);
      if (Value)
      {
        IOHIDValueRef v12 = Value;
        do
        {
          if (v7 >= 1)
          {
            long long v13 = v9;
            uint64_t v14 = v7;
            do
            {
              if (*v13)
              {
                BytePtr = CFDataGetBytePtr(*v13);
                long long v16 = (void (*)(void, void, CFSetRef *, IOHIDValueRef))*((void *)BytePtr + 1);
                if (v16) {
                  v16(*(void *)BytePtr, 0, cf, v12);
                }
              }
              ++v13;
              --v14;
            }
            while (v14);
          }
          CFRelease(v12);
          IOHIDValueRef v12 = IOHIDQueueCopyNextValue(a3);
        }
        while (v12);
      }
    }
    os_unfair_recursive_lock_unlock();
    CFRelease(cf);
  }
}

void IOHIDDeviceSetInputValueMatching(IOHIDDeviceRef device, CFDictionaryRef matching)
{
  values = matching;
  if (matching)
  {
    CFAllocatorRef v3 = CFGetAllocator(device);
    CFArrayRef v4 = CFArrayCreate(v3, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    IOHIDDeviceSetInputValueMatchingMultiple(device, v4);
    CFRelease(v4);
  }
  else
  {
    IOHIDDeviceSetInputValueMatchingMultiple(device, 0);
  }
}

void IOHIDDeviceSetInputValueMatchingMultiple(IOHIDDeviceRef device, CFArrayRef multiple)
{
  os_unfair_recursive_lock_lock_with_options();
  CFArrayRef v4 = (__IOHIDQueue *)*((void *)device + 30);
  if (v4)
  {
    IOHIDQueueStop(v4);
    while (1)
    {
      IOHIDValueRef Value = IOHIDQueueCopyNextValue(*((IOHIDQueueRef *)device + 30));
      if (!Value) {
        break;
      }
      CFRelease(Value);
    }
    CFArrayRef v6 = _IOHIDQueueCopyElements(*((CFSetRef **)device + 30));
    if (v6)
    {
      CFArrayRef v7 = v6;
      CFIndex Count = CFArrayGetCount(v6);
      if (Count >= 1)
      {
        CFIndex v9 = Count;
        for (CFIndex i = 0; i != v9; ++i)
        {
          size_t v11 = (__IOHIDQueue *)*((void *)device + 30);
          CFNumberRef ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(v7, i);
          IOHIDQueueRemoveElement(v11, ValueAtIndex);
        }
      }
      CFRelease(v7);
    }
    __IOHIDDeviceRegisterMatchingInputElements(device, *((__IOHIDQueue **)device + 30), multiple);
    IOHIDQueueStart(*((IOHIDQueueRef *)device + 30));
  }
  long long v13 = (const void *)*((void *)device + 31);
  if (v13) {
    CFRelease(v13);
  }
  if (multiple) {
    CFTypeRef v14 = CFRetain(multiple);
  }
  else {
    CFTypeRef v14 = 0;
  }
  *((void *)device + 31) = v14;

  os_unfair_recursive_lock_unlock();
}

IOReturn IOHIDDeviceSetValue(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef value)
{
  return (*(uint64_t (**)(void, IOHIDElementRef, IOHIDValueRef, void, void, void, void))(**((void **)device + 3) + 80))(*((void *)device + 3), element, value, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceSetValueMultiple(IOHIDDeviceRef device, CFDictionaryRef multiple)
{
  return IOHIDDeviceSetValueMultipleWithCallback(device, multiple, 0.0, 0, 0);
}

IOReturn IOHIDDeviceSetValueMultipleWithCallback(IOHIDDeviceRef device, CFDictionaryRef multiple, CFTimeInterval timeout, IOHIDValueMultipleCallback callback, void *context)
{
  IOReturn v5 = -536870211;
  if (!multiple) {
    return -536870206;
  }
  CFIndex Count = CFDictionaryGetCount(multiple);
  if (!Count) {
    return -536870206;
  }
  CFIndex v12 = Count;
  CFAllocatorRef v13 = CFGetAllocator(device);
  IOHIDTransactionRef v14 = IOHIDTransactionCreate(v13, device, kIOHIDTransactionDirectionTypeOutput, 0);
  if (v14)
  {
    long long v15 = v14;
    long long v16 = (const void **)malloc_type_malloc(8 * v12, 0x2004093837F09uLL);
    if (v16)
    {
      long long v17 = v16;
      IOHIDValueCallback v18 = (const void **)malloc_type_malloc(8 * v12, 0x2004093837F09uLL);
      if (v18)
      {
        long long v19 = (__IOHIDValue **)v18;
        unsigned int v32 = v17;
        CFDictionaryGetKeysAndValues(multiple, v17, v18);
        if (v12 >= 1)
        {
          long long v20 = (IOHIDElementRef *)v17;
          long long v21 = v19;
          CFIndex v22 = v12;
          do
          {
            IOHIDTransactionAddElement(v15, *v20);
            IOHIDElementRef v24 = *v20++;
            long long v23 = v24;
            long long v25 = *v21++;
            IOHIDTransactionSetValue(v15, v23, v25, 0);
            --v22;
          }
          while (v22);
        }
        if (callback)
        {
          long long v26 = malloc_type_malloc(0x20uLL, 0xE0040BF2FBCEAuLL);
          uint64_t v27 = v32;
          if (v26)
          {
            uint64_t v28 = v26;
            v26[1] = callback;
            v26[2] = device;
            void *v26 = context;
            CFAllocatorRef v29 = CFGetAllocator(device);
            v28[3] = CFArrayCreate(v29, v32, v12, MEMORY[0x1E4F1D510]);
            IOReturn v5 = IOHIDTransactionCommitWithCallback(v15, timeout, (IOHIDCallback)__IOHIDDeviceTransactionCallback, v28);
            if (v5) {
              free(v28);
            }
            else {
              CFRetain(v15);
            }
          }
        }
        else
        {
          IOReturn v5 = IOHIDTransactionCommit(v15);
          uint64_t v27 = v32;
        }
        CFRelease(v15);
        free(v27);
        unint64_t v30 = (const void **)v19;
      }
      else
      {
        CFRelease(v15);
        unint64_t v30 = v17;
      }
      free(v30);
    }
    else
    {
      CFRelease(v15);
    }
  }
  return v5;
}

IOReturn IOHIDDeviceSetValueWithCallback(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef value, CFTimeInterval timeout, IOHIDValueCallback callback, void *context)
{
  CFIndex v12 = malloc_type_malloc(0x18uLL, 0xA0040114AFA65uLL);
  if (!v12) {
    return -536870211;
  }
  CFAllocatorRef v13 = v12;
  v12[1] = callback;
  uint32x2_t v12[2] = device;
  void *v12 = context;
  IOReturn v14 = (*(uint64_t (**)(void, IOHIDElementRef, IOHIDValueRef, void, void (*)(void *, uint64_t), void *, void))(**((void **)device + 3) + 80))(*((void *)device + 3), element, value, timeout, __IOHIDDeviceValueCallback, v12, 0);
  if (v14) {
    free(v13);
  }
  return v14;
}

void __IOHIDDeviceValueCallback(void *a1, uint64_t a2)
{
  CFAllocatorRef v3 = (void (*)(void, uint64_t, void))a1[1];
  if (v3) {
    v3(*a1, a2, a1[2]);
  }

  free(a1);
}

void __IOHIDDeviceTransactionCallback(void *a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    IOReturn v5 = (void (*)(uint64_t))a1[1];
    if (v5)
    {
      CFArrayRef v6 = (const void *)a1[2];
      if (a2)
      {
        uint64_t v7 = *a1;
LABEL_5:
        v5(v7);
        goto LABEL_6;
      }
      CFArrayRef v9 = (const __CFArray *)a1[3];
      if (v9)
      {
        CFIndex Count = CFArrayGetCount(v9);
        if (Count)
        {
          CFIndex v11 = Count;
          CFAllocatorRef v12 = CFGetAllocator(v6);
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v12, v11, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
          if (Mutable)
          {
            IOReturn v14 = Mutable;
            if (v11 >= 1)
            {
              for (CFIndex i = 0; i != v11; ++i)
              {
                CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1[3], i);
                if (ValueAtIndex)
                {
                  long long v17 = ValueAtIndex;
                  IOHIDValueRef Value = (const void *)_IOHIDElementGetValue((uint64_t)ValueAtIndex);
                  if (Value) {
                    CFDictionarySetValue(v14, v17, Value);
                  }
                }
              }
            }
            if (!CFDictionaryGetCount(v14))
            {
              CFRelease(v14);
              uint64_t v7 = *a1;
              goto LABEL_5;
            }
            ((void (*)(void, void, const void *, __CFDictionary *))v5)(*a1, 0, v6, v14);
            CFRelease(v14);
          }
        }
      }
    }
  }
LABEL_6:
  size_t v8 = (const void *)a1[3];
  if (v8) {
    CFRelease(v8);
  }
  if (cf) {
    CFRelease(cf);
  }

  free(a1);
}

IOReturn IOHIDDeviceGetValue(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef *pValue)
{
  return (*(uint64_t (**)(void, IOHIDElementRef, IOHIDValueRef *, void, void, void, void))(**((void **)device + 3) + 88))(*((void *)device + 3), element, pValue, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceGetValueWithOptions(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef *pValue, uint32_t options)
{
  return (*(uint64_t (**)(void, IOHIDElementRef, IOHIDValueRef *, void, void, void, void))(**((void **)device + 3) + 88))(*((void *)device + 3), element, pValue, 0, 0, 0, *(void *)&options);
}

IOReturn IOHIDDeviceCopyValueMultiple(IOHIDDeviceRef device, CFArrayRef elements, CFDictionaryRef *pMultiple)
{
  return IOHIDDeviceCopyValueMultipleWithCallback(device, elements, pMultiple, 0.0, 0, 0);
}

IOReturn IOHIDDeviceCopyValueMultipleWithCallback(IOHIDDeviceRef device, CFArrayRef elements, CFDictionaryRef *pMultiple, CFTimeInterval timeout, IOHIDValueMultipleCallback callback, void *context)
{
  IOReturn v6 = -536870206;
  if (elements && pMultiple)
  {
    CFIndex Count = CFArrayGetCount(elements);
    if (Count)
    {
      CFIndex v14 = Count;
      CFAllocatorRef v15 = CFGetAllocator(device);
      IOHIDTransactionRef v16 = IOHIDTransactionCreate(v15, device, kIOHIDTransactionDirectionTypeInput, 0);
      if (v16)
      {
        long long v17 = v16;
        if (v14 >= 1)
        {
          for (CFIndex i = 0; i != v14; ++i)
          {
            CFNumberRef ValueAtIndex = (__IOHIDElement *)CFArrayGetValueAtIndex(elements, i);
            IOHIDTransactionAddElement(v17, ValueAtIndex);
          }
        }
        if (callback)
        {
          long long v20 = malloc_type_malloc(0x20uLL, 0xE0040BF2FBCEAuLL);
          IOReturn v6 = -536870211;
          if (v20)
          {
            long long v21 = v20;
            v20[1] = callback;
            v20[2] = device;
            *long long v20 = context;
            CFAllocatorRef v22 = CFGetAllocator(device);
            v21[3] = CFArrayCreateCopy(v22, elements);
            IOReturn v6 = IOHIDTransactionCommitWithCallback(v17, timeout, (IOHIDCallback)__IOHIDDeviceTransactionCallback, v21);
            if (v6) {
              free(v21);
            }
            else {
              CFRetain(v17);
            }
          }
        }
        else
        {
          IOReturn v6 = IOHIDTransactionCommit(v17);
          if (!v6)
          {
            CFAllocatorRef v23 = CFGetAllocator(device);
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v23, v14, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
            IOReturn v6 = -536870211;
            if (Mutable)
            {
              long long v25 = Mutable;
              if (v14 >= 1)
              {
                for (CFIndex j = 0; j != v14; ++j)
                {
                  uint64_t v27 = CFArrayGetValueAtIndex(elements, j);
                  IOHIDValueRef Value = (const void *)_IOHIDElementGetValue((uint64_t)v27);
                  if (Value) {
                    CFDictionarySetValue(v25, v27, Value);
                  }
                }
              }
              if (!CFDictionaryGetCount(v25))
              {
                CFRelease(v25);
                long long v25 = 0;
              }
              IOReturn v6 = 0;
              *pMultiple = v25;
            }
          }
        }
        CFRelease(v17);
      }
      else
      {
        return -536870211;
      }
    }
    else
    {
      return -536870206;
    }
  }
  return v6;
}

IOReturn IOHIDDeviceGetValueWithCallback(IOHIDDeviceRef device, IOHIDElementRef element, IOHIDValueRef *pValue, CFTimeInterval timeout, IOHIDValueCallback callback, void *context)
{
  CFAllocatorRef v12 = malloc_type_malloc(0x18uLL, 0xA0040114AFA65uLL);
  if (!v12) {
    return -536870211;
  }
  CFAllocatorRef v13 = v12;
  v12[1] = callback;
  uint32x2_t v12[2] = device;
  void *v12 = context;
  IOReturn v14 = (*(uint64_t (**)(void, IOHIDElementRef, IOHIDValueRef *, void, void (*)(void *, uint64_t), void *, void))(**((void **)device + 3) + 88))(*((void *)device + 3), element, pValue, timeout, __IOHIDDeviceValueCallback, v12, 0);
  if (v14) {
    free(v13);
  }
  return v14;
}

void IOHIDDeviceRegisterInputReportCallback(IOHIDDeviceRef device, uint8_t *report, CFIndex reportLength, IOHIDReportCallback callback, void *context)
{
  if (atomic_load((unsigned int *)device + 56)) {
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  }

  __IOHIDDeviceRegisterInputReportCallback(device, (uint64_t)report, reportLength, (uint64_t)callback, 0, (uint64_t)context);
}

void __IOHIDDeviceRegisterInputReportCallback(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v16[0] = a6;
  v16[1] = a4;
  _OWORD v16[2] = a5;
  v16[3] = a1;
  CFRetain(a1);
  os_unfair_recursive_lock_lock_with_options();
  if (!a1[38]) {
    a1[38] = CFSetCreateMutable(0, 0, (const CFSetCallBacks *)&__callbackBaseSetCallbacks);
  }
  os_unfair_recursive_lock_unlock();
  if (a1[38])
  {
    CFAllocatorRef v11 = CFGetAllocator(a1);
    CFDataRef v12 = CFDataCreate(v11, (const UInt8 *)v16, 32);
    if (v12)
    {
      CFDataRef v13 = v12;
      os_unfair_recursive_lock_lock_with_options();
      IOReturn v14 = (__CFSet *)a1[38];
      if (a4 | a5)
      {
        CFSetAddValue(v14, v13);
        os_unfair_recursive_lock_unlock();
        uint64_t v15 = a1[4];
        if (v15) {
          (*(void (**)(void, uint64_t, uint64_t, uint64_t (*)(CFSetRef *, unsigned int, uint64_t, int, int, uint64_t, uint64_t, uint64_t), void *, void))(*(void *)v15 + 120))(a1[3], a2, a3, __IOHIDDeviceInputReportWithTimeStampCallback, a1, 0);
        }
        else {
          (*(void (**)(void, uint64_t, uint64_t, uint64_t (*)(CFSetRef *, unsigned int, uint64_t, int, int, uint64_t, uint64_t), void *, void))(*(void *)a1[3] + 96))(a1[3], a2, a3, __IOHIDDeviceInputReportCallback, a1, 0);
        }
      }
      else
      {
        CFSetRemoveValue(v14, v13);
        os_unfair_recursive_lock_unlock();
      }
      CFRelease(v13);
    }
  }
  CFRelease(a1);
}

void IOHIDDeviceRegisterInputReportWithTimeStampCallback(IOHIDDeviceRef device, uint8_t *report, CFIndex reportLength, IOHIDReportWithTimeStampCallback callback, void *context)
{
  if (atomic_load((unsigned int *)device + 56)) {
    IOHIDDeviceRegisterRemovalCallback_cold_1();
  }

  __IOHIDDeviceRegisterInputReportCallback(device, (uint64_t)report, reportLength, 0, (uint64_t)callback, (uint64_t)context);
}

IOReturn IOHIDDeviceSetReport(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, const uint8_t *report, CFIndex reportLength)
{
  return (*(uint64_t (**)(void, void, CFIndex, const uint8_t *, CFIndex, void, void, void, _DWORD))(**((void **)device + 3) + 104))(*((void *)device + 3), *(void *)&reportType, reportID, report, reportLength, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceSetReportWithCallback(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, const uint8_t *report, CFIndex reportLength, CFTimeInterval timeout, IOHIDReportCallback callback, void *context)
{
  uint64_t v14 = *(void *)&reportType;
  IOHIDTransactionRef v16 = malloc_type_malloc(0x20uLL, 0xA00400770BE9BuLL);
  if (!v16) {
    return -536870211;
  }
  long long v17 = v16;
  *IOHIDTransactionRef v16 = context;
  v16[1] = callback;
  v16[3] = device;
  IOReturn v18 = (*(uint64_t (**)(void, uint64_t, CFIndex, const uint8_t *, CFIndex, void, void (*)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), void *, _DWORD))(**((void **)device + 3) + 104))(*((void *)device + 3), v14, reportID, report, reportLength, timeout, __IOHIDDeviceReportCallbackOnce, v16, 0);
  if (v18) {
    free(v17);
  }
  return v18;
}

void __IOHIDDeviceReportCallbackOnce(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (void *)a1[3];
  CFRetain(v14);
  uint64_t v15 = (void (*)(void, uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t))a1[1];
  if (v15 && v14[3] == a3)
  {
    v15(*a1, a2, v14, a4, a5, a6, a7);
  }
  else
  {
    IOHIDTransactionRef v16 = (void (*)(void, uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, void))a1[2];
    if (v16 && v14[4] == a3) {
      v16(*a1, a2, v14, a4, a5, a6, a7, 0);
    }
  }
  free(a1);

  CFRelease(v14);
}

IOReturn IOHIDDeviceGetReport(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, uint8_t *report, CFIndex *pReportLength)
{
  return (*(uint64_t (**)(void, void, CFIndex, uint8_t *, CFIndex *, void, void, void, _DWORD))(**((void **)device + 3) + 112))(*((void *)device + 3), *(void *)&reportType, reportID, report, pReportLength, 0, 0, 0, 0);
}

IOReturn IOHIDDeviceGetReportWithCallback(IOHIDDeviceRef device, IOHIDReportType reportType, CFIndex reportID, uint8_t *report, CFIndex *pReportLength, CFTimeInterval timeout, IOHIDReportCallback callback, void *context)
{
  uint64_t v14 = *(void *)&reportType;
  IOHIDTransactionRef v16 = malloc_type_malloc(0x20uLL, 0xA00400770BE9BuLL);
  if (!v16) {
    return -536870211;
  }
  long long v17 = v16;
  *IOHIDTransactionRef v16 = context;
  v16[1] = callback;
  _OWORD v16[2] = 0;
  v16[3] = device;
  IOReturn v18 = (*(uint64_t (**)(void, uint64_t, CFIndex, uint8_t *, CFIndex *, void, void (*)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), void *, _DWORD))(**((void **)device + 3) + 112))(*((void *)device + 3), v14, reportID, report, pReportLength, timeout, __IOHIDDeviceReportCallbackOnce, v16, 0);
  if (v18) {
    free(v17);
  }
  return v18;
}

uint64_t IOHIDDeviceGetRegistryEntryID(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t __IOHIDDeviceGetRootKey(__IOHIDDevice *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*((void *)a1 + 9))
  {
    CFStringRef RootKey = __IOHIDManagerGetRootKey();
    CFNumberRef Property = (__CFString *)IOHIDDeviceGetProperty(a1, @"Transport");
    CFTypeRef v4 = IOHIDDeviceGetProperty(a1, @"VendorID");
    CFTypeRef v5 = IOHIDDeviceGetProperty(a1, @"ProductID");
    IOReturn v6 = (__CFString *)IOHIDDeviceGetProperty(a1, @"SerialNumber");
    if (!Property || (CFTypeID v7 = CFGetTypeID(Property), v7 != CFStringGetTypeID())) {
      CFNumberRef Property = @"unknown";
    }
    size_t v8 = (CFTypeRef *)MEMORY[0x1E4F1D398];
    if (!v4 || (CFTypeID v9 = CFGetTypeID(v4), v9 != CFNumberGetTypeID())) {
      CFTypeRef v4 = *v8;
    }
    if (!v5 || (CFTypeID v10 = CFGetTypeID(v5), v10 != CFNumberGetTypeID())) {
      CFTypeRef v5 = *v8;
    }
    if (!v6 || (CFTypeID v11 = CFGetTypeID(v6), v11 != CFStringGetTypeID())) {
      IOReturn v6 = @"none";
    }
    *((void *)a1 + 9) = CFStringCreateWithFormat(0, 0, @"%@#%@#%@#%@#%@", RootKey, Property, v4, v5, v6);
  }
  os_unfair_recursive_lock_unlock();
  return *((void *)a1 + 9);
}

CFStringRef __IOHIDDeviceGetUUIDString(__IOHIDDevice *a1)
{
  CFStringRef Property = (const __CFString *)IOHIDDeviceGetProperty(a1, @"com.apple.iohidmanager.uuid");
  if (!Property || (v3 = Property, CFTypeID v4 = CFGetTypeID(Property), v4 != CFStringGetTypeID()))
  {
    CFUUIDRef v5 = CFUUIDCreate(0);
    CFStringRef v3 = CFUUIDCreateString(0, v5);
    IOHIDDeviceSetProperty(a1, @"com.apple.iohidmanager.uuid", v3);
    CFRelease(v5);
    CFRelease(v3);
  }
  return v3;
}

CFStringRef __IOHIDDeviceGetUUIDKey(__IOHIDDevice *a1)
{
  CFStringRef result = (CFStringRef)*((void *)a1 + 10);
  if (!result)
  {
    CFStringRef RootKey = __IOHIDManagerGetRootKey();
    CFStringRef UUIDString = __IOHIDDeviceGetUUIDString(a1);
    CFStringRef result = CFStringCreateWithFormat(0, 0, @"%@#%@", RootKey, UUIDString);
    *((void *)a1 + 10) = result;
  }
  return result;
}

void __IOHIDDeviceSaveProperties(uint64_t a1, CFStringRef *context)
{
  if (!*(unsigned char *)(a1 + 257) || !*(void *)(a1 + 56)) {
    goto LABEL_17;
  }
  CFStringRef UUIDString = (__CFString *)__IOHIDDeviceGetUUIDString((__IOHIDDevice *)a1);
  values = UUIDString;
  CFStringRef RootKey = (const __CFString *)__IOHIDDeviceGetRootKey((__IOHIDDevice *)a1);
  CFArrayRef v6 = (const __CFArray *)IOHIDPreferencesCopyDomain(RootKey, (const __CFString *)*MEMORY[0x1E4F1D3D8]);
  CFArrayRef v7 = v6;
  if (!v6)
  {
    MutableCFDictionaryRef Copy = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    if (!MutableCopy) {
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  CFTypeID v8 = CFGetTypeID(v6);
  if (v8 == CFArrayGetTypeID())
  {
    v17.CFIndex length = CFArrayGetCount(v7);
    v17.location = 0;
    if (CFArrayContainsValue(v7, v17, UUIDString)) {
      goto LABEL_14;
    }
    CFIndex Count = CFArrayGetCount(v7);
    MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(0, Count + 1, v7);
    CFArrayAppendValue(MutableCopy, UUIDString);
    if (!MutableCopy) {
      goto LABEL_14;
    }
LABEL_11:
    CFStringRef v11 = (const __CFString *)__IOHIDDeviceGetRootKey((__IOHIDDevice *)a1);
    __IOHIDPropertySaveWithContext(v11, MutableCopy, context);
    if (v7) {
      CFRelease(v7);
    }
    CFDataRef v12 = MutableCopy;
    goto LABEL_15;
  }
  MutableCFDictionaryRef Copy = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  if (MutableCopy) {
    goto LABEL_11;
  }
LABEL_14:
  CFDataRef v12 = v7;
LABEL_15:
  CFRelease(v12);
LABEL_16:
  CFDictionaryRef v13 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef UUIDKey = __IOHIDDeviceGetUUIDKey((__IOHIDDevice *)a1);
  __IOHIDPropertySaveToKeyWithSpecialKeys(v13, UUIDKey, 0, context);
  *(unsigned char *)(a1 + 257) = 0;
LABEL_17:
  CFSetRef v15 = *(const __CFSet **)(a1 + 64);
  if (v15) {
    CFSetApplyFunction(v15, (CFSetApplierFunction)__IOHIDSaveElementSet, context);
  }
}

void __IOHIDDeviceLoadProperties(uint64_t a1)
{
  CFTypeRef Property = IOHIDDeviceGetProperty((IOHIDDeviceRef)a1, @"com.apple.iohidmanager.uuid");
  CFNumberRef ValueAtIndex = Property;
  *(unsigned char *)(a1 + 256) = 1;
  if (!*(void *)(a1 + 80))
  {
    if (!Property || (CFTypeID v4 = CFGetTypeID(Property), v4 != CFStringGetTypeID()))
    {
      CFStringRef RootKey = (const __CFString *)__IOHIDDeviceGetRootKey((__IOHIDDevice *)a1);
      CFArrayRef v6 = (const __CFArray *)IOHIDPreferencesCopyDomain(RootKey, (const __CFString *)*MEMORY[0x1E4F1D3D8]);
      if (v6)
      {
        CFArrayRef v7 = v6;
        CFTypeID v8 = CFGetTypeID(v6);
        if (v8 == CFArrayGetTypeID())
        {
          if (CFArrayGetCount(v7)) {
            CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v7, 0);
          }
        }
      }
      if (!ValueAtIndex) {
        goto LABEL_10;
      }
    }
    CFTypeID v9 = CFGetTypeID(ValueAtIndex);
    if (v9 != CFStringGetTypeID())
    {
LABEL_10:
      CFUUIDRef v10 = CFUUIDCreate(0);
      CFNumberRef ValueAtIndex = CFUUIDCreateString(0, v10);
      CFRelease(v10);
    }
    IOHIDDeviceSetProperty((IOHIDDeviceRef)a1, @"com.apple.iohidmanager.uuid", ValueAtIndex);
  }
  CFStringRef UUIDKey = __IOHIDDeviceGetUUIDKey((__IOHIDDevice *)a1);
  DictionaryFromKey = __IOHIDPropertyLoadDictionaryFromKey(UUIDKey);
  if (DictionaryFromKey)
  {
    CFDictionaryRef v13 = DictionaryFromKey;
    uint64_t v14 = *(const void **)(a1 + 56);
    if (v14) {
      CFRelease(v14);
    }
    *(void *)(a1 + 56) = v13;
    *(unsigned char *)(a1 + 257) = 0;
  }
  IOHIDDeviceSetProperty((IOHIDDeviceRef)a1, @"com.apple.iohidmanager.uuid", ValueAtIndex);
  CFSetRef v15 = *(const __CFSet **)(a1 + 64);
  if (v15)
  {
    CFSetApplyFunction(v15, (CFSetApplierFunction)__IOHIDLoadElementSet, 0);
  }
}

__IOHIDDevice *__IOHIDApplyPropertyToDeviceSet(__IOHIDDevice *result, uint64_t a2)
{
  if (result)
  {
    if (a2) {
      return (__IOHIDDevice *)IOHIDDeviceSetProperty(result, *(CFStringRef *)a2, *(CFTypeRef *)(a2 + 8));
    }
  }
  return result;
}

CFStringRef __IOHIDApplyPropertiesToDeviceFromDictionary(const __CFString *key, CFTypeRef property, IOHIDDeviceRef device)
{
  if (property && key)
  {
    if (device) {
      return (const __CFString *)IOHIDDeviceSetProperty(device, key, property);
    }
  }
  return key;
}

void __IOHIDSaveDeviceSet(uint64_t a1, CFStringRef *context)
{
  if (a1) {
    __IOHIDDeviceSaveProperties(a1, context);
  }
}

__CFArray *__IOHIDDeviceCopyMatchingInputElements(void *a1, const __CFArray *cf)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFArrayRef v3 = cf;
    CFRetain(cf);
  }
  else
  {
    long long v24 = xmmword_18B50BE30;
    MEMORY[0x1F4188790](a1, 0);
    uint64_t v4 = 0;
    memset(v21, 0, sizeof(v21));
    keys = @"Type";
    CFUUIDRef v5 = &v24;
    CFArrayRef v6 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D048];
    CFArrayRef v7 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      values = 0;
      CFAllocatorRef v8 = CFGetAllocator(a1);
      values = CFNumberCreate(v8, kCFNumberIntType, v5);
      CFAllocatorRef v9 = CFGetAllocator(a1);
      v21[v4] = CFDictionaryCreate(v9, (const void **)&keys, (const void **)&values, 1, v6, v7);
      CFRelease(values);
      ++v4;
      CFUUIDRef v5 = (long long *)((char *)v5 + 4);
    }
    while (v4 != 4);
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFArrayRef v3 = CFArrayCreate(v10, v21, 4, MEMORY[0x1E4F1D510]);
    for (uint64_t i = 0; i != 4; ++i)
      CFRelease(v21[i]);
    if (!v3) {
      return 0;
    }
  }
  CFIndex Count = CFArrayGetCount(v3);
  if (Count < 1)
  {
    MutableCFDictionaryRef Copy = 0;
  }
  else
  {
    CFIndex v13 = Count;
    MutableCFDictionaryRef Copy = 0;
    for (CFIndex j = 0; j != v13; ++j)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, j);
      CFArrayRef v17 = IOHIDDeviceCopyMatchingElements((IOHIDDeviceRef)a1, ValueAtIndex, 0);
      if (v17)
      {
        CFArrayRef v18 = v17;
        if (MutableCopy)
        {
          v26.CFIndex length = CFArrayGetCount(v17);
          v26.location = 0;
          CFArrayAppendArray(MutableCopy, v18, v26);
        }
        else
        {
          CFAllocatorRef v19 = CFGetAllocator(a1);
          MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(v19, 0, v18);
        }
        CFRelease(v18);
      }
    }
  }
  CFRelease(v3);
  return MutableCopy;
}

uint64_t __IOHIDDeviceInputReportWithTimeStampCallback(CFSetRef *a1, unsigned int a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  os_unfair_recursive_lock_lock_with_options();
  if (CFSetGetCount(a1[38]))
  {
    context[0] = a1;
    context[1] = a2;
    void context[2] = a1;
    int v17 = a4;
    int v18 = a5;
    uint64_t v19 = a6;
    uint64_t v20 = a7;
    uint64_t v21 = a8;
    CFRetain(a1);
    CFSetApplyFunction(a1[38], (CFSetApplierFunction)__IOHIDDeviceInputReportApplier, context);
    CFRelease(a1);
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDDeviceInputReportCallback(CFSetRef *a1, unsigned int a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  os_unfair_recursive_lock_lock_with_options();
  if (CFSetGetCount(a1[38]))
  {
    context[0] = a1;
    context[1] = a2;
    void context[2] = a1;
    int v15 = a4;
    int v16 = a5;
    uint64_t v17 = a6;
    uint64_t v18 = a7;
    uint64_t v19 = 0;
    CFRetain(a1);
    CFSetApplyFunction(a1[38], (CFSetApplierFunction)__IOHIDDeviceInputReportApplier, context);
    CFRelease(a1);
  }
  return os_unfair_recursive_lock_unlock();
}

const UInt8 *__IOHIDDeviceInputReportApplier(const UInt8 *result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      CFStringRef result = CFDataGetBytePtr((CFDataRef)result);
      if (result)
      {
        CFArrayRef v3 = result;
        uint64_t v4 = (uint64_t (*)(void, void, void, void, void, void, void))*((void *)result + 1);
        if (v4) {
          CFStringRef result = (const UInt8 *)v4(*(void *)result, *(unsigned int *)(a2 + 8), *(void *)(a2 + 16), *(unsigned int *)(a2 + 24), *(unsigned int *)(a2 + 28), *(void *)(a2 + 32), *(void *)(a2 + 40));
        }
        CFUUIDRef v5 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))*((void *)v3 + 2);
        if (v5)
        {
          uint64_t v6 = *(void *)v3;
          uint64_t v7 = *(unsigned int *)(a2 + 8);
          uint64_t v8 = *(void *)(a2 + 16);
          uint64_t v9 = *(unsigned int *)(a2 + 24);
          uint64_t v10 = *(unsigned int *)(a2 + 28);
          uint64_t v11 = *(void *)(a2 + 32);
          uint64_t v12 = *(void *)(a2 + 40);
          uint64_t v13 = *(void *)(a2 + 48);
          return (const UInt8 *)v5(v6, v7, v8, v9, v10, v11, v12, v13);
        }
      }
    }
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_0_1()
{
  return _os_log_send_and_compose_impl();
}

double OUTLINED_FUNCTION_2_2(void *a1, _OWORD *a2)
{
  *a1 = 0;
  double result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

uint64_t _IOObjectCFRelease(int a1, io_object_t object)
{
  return IOObjectRelease(object);
}

uint64_t _IOObjectCFRetain(int a1, uint64_t object)
{
  if (IOObjectRetain(object)) {
    return 0;
  }
  else {
    return object;
  }
}

uint64_t (*_IOHIDCallbackApplier(uint64_t (*result)(uint64_t, void, void), uint64_t a2, unsigned int *a3))(uint64_t, void, void)
{
  if (result)
  {
    if (a3) {
      return (uint64_t (*)(uint64_t, void, void))result(a2, *a3, *((void *)a3 + 1));
    }
  }
  return result;
}

uint64_t _IOHIDGetMonotonicTime()
{
  if (!dword_1E9134074) {
    mach_timebase_info((mach_timebase_info_t)&_IOHIDGetMonotonicTime_timebaseInfo);
  }
  return mach_absolute_time() * _IOHIDGetMonotonicTime_timebaseInfo / dword_1E9134074;
}

uint64_t _IOHIDSimpleQueuePeek(const __CFData *a1)
{
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t v2 = *((void *)BytePtr + 3);
  if (v2 == *((void *)BytePtr + 2)) {
    return 0;
  }
  else {
    return (uint64_t)&BytePtr[*((void *)BytePtr + 1) * v2 + 8];
  }
}

const UInt8 *_IOHIDSimpleQueueApplyBlock(const __CFData *a1, uint64_t a2, uint64_t a3)
{
  double result = CFDataGetBytePtr(a1);
  unint64_t v6 = *((void *)result + 2);
  if (*((void *)result + 3) != v6)
  {
    uint64_t v7 = result;
    uint64_t v8 = result + 32;
    do
    {
      double result = (const UInt8 *)(*(uint64_t (**)(uint64_t, const UInt8 *, uint64_t))(a2 + 16))(a2, &v8[*((void *)v7 + 1) * v6], a3);
      unint64_t v6 = (v6 + 1) % *(void *)v7;
    }
    while (*((void *)v7 + 3) != v6);
  }
  return result;
}

uint64_t _IOHIDSimpleQueueDequeue(const __CFData *a1, void *a2)
{
  BytePtr = CFDataGetBytePtr(a1);
  uint64_t v5 = *((void *)BytePtr + 3);
  if (v5 == *((void *)BytePtr + 2)) {
    return 0;
  }
  uint64_t v7 = BytePtr + 8;
  uint64_t v8 = *((void *)BytePtr + 1);
  uint64_t v9 = CFDataGetBytePtr(a1);
  uint64_t v10 = v9;
  if (a2) {
    memcpy(a2, &v7[v8 * v5], *((void *)v9 + 1));
  }
  *((void *)v10 + 2) = (unint64_t)(*((void *)v10 + 2) + 1) % *(void *)v10;
  return 1;
}

void _IOHIDDictionaryAddCStr(void *a1, const void *a2, const char *a3)
{
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFStringRef v7 = CFStringCreateWithCString(v6, a3, 0);
  if (v7)
  {
    CFStringRef v8 = v7;
    CFDictionaryAddValue((CFMutableDictionaryRef)a1, a2, v7);
    CFRelease(v8);
  }
}

void _IOHIDCFSetApplyBlock(const __CFSet *a1, void *context)
{
}

uint64_t __IOHIDCFSetFunctionApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t _IOHIDIsAlphaNumericKey(int a1, int a2)
{
  if (a2 != 7) {
    return 0;
  }
  unsigned int v3 = a1 - 45;
  uint64_t result = 1;
  if (v3 >= 0xC
    && (a1 - 4) >= 0x24
    && (a1 - 89) >= 0xC
    && a1 != 103
    && (a1 & 0xFFFFFFFC) != 0x54)
  {
    return 0;
  }
  return result;
}

uint64_t _IOHIDIsRestrictedRemappingProperty(const __CFString *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID())
  {
    CFTypeID v10 = CFGetTypeID(a1);
    if (v10 == CFStringGetTypeID() && a1)
    {
      uint64_t result = (uint64_t)CFStringGetCStringPtr(a1, 0);
      if (!result) {
        return result;
      }
      uint64_t v12 = strdup((const char *)result);
      uint32_t valuePtr = v12;
      uint64_t v13 = strsep(&valuePtr, ",");
      if (v13)
      {
        uint64_t v14 = v13;
        do
        {
          int v15 = strsep(&valuePtr, ",");
          if (!v15) {
            break;
          }
          if (strtoul(v15, 0, 0))
          {
            int v16 = strtoul(v14, 0, 0);
            __int16 v17 = v16;
            if ((v16 & 0xFFFF0000) == 0x70000)
            {
              int v18 = (unsigned __int16)v16;
              unsigned int v19 = (unsigned __int16)v16 - 45;
              uint64_t result = 1;
              if (v19 < 0xC
                || (v18 - 4) < 0x24
                || (v18 - 89) < 0xC
                || v18 == 103
                || (v17 & 0xFFFC) == 0x54)
              {
                return result;
              }
            }
          }
          uint64_t v14 = strsep(&valuePtr, ",");
        }
        while (v14);
      }
      if (v12) {
        free(v12);
      }
    }
    return 0;
  }
  if (CFArrayGetCount((CFArrayRef)a1) < 1) {
    return 0;
  }
  CFIndex v3 = 0;
  while (1)
  {
    uint32_t valuePtr = 0;
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, v3);
    if (ValueAtIndex)
    {
      CFDictionaryRef v5 = ValueAtIndex;
      CFTypeID v6 = CFGetTypeID(ValueAtIndex);
      if (v6 == CFDictionaryGetTypeID())
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v5, @"HIDKeyboardModifierMappingSrc");
        if (Value)
        {
          CFNumberRef v8 = Value;
          CFTypeID v9 = CFGetTypeID(Value);
          if (v9 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v8, kCFNumberSInt64Type, &valuePtr);
            if (HIDWORD(valuePtr) == 7
              && ((valuePtr - 45) < 0xC
               || (valuePtr - 4) < 0x24
               || (valuePtr - 89) < 0xC
               || valuePtr == 103
               || (valuePtr & 0xFFFFFFFC) == 0x54))
            {
              break;
            }
          }
        }
      }
    }
    if (++v3 >= CFArrayGetCount((CFArrayRef)a1)) {
      return 0;
    }
  }
  return 1;
}

uint64_t __IOHIDManagerRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDManagerCFTypeID TypeID = result;
  return result;
}

CFTypeID IOHIDManagerGetTypeID(void)
{
  CFTypeID result = __kIOHIDManagerTypeID;
  if (!__kIOHIDManagerTypeID)
  {
    pthread_once(&__sessionTypeInit, (void (*)(void))__IOHIDManagerRegister);
    return __kIOHIDManagerTypeID;
  }
  return result;
}

IOHIDManagerRef IOHIDManagerCreate(CFAllocatorRef allocator, IOOptionBits options)
{
  uint64_t v4 = __kIOHIDManagerTypeID;
  if (!__kIOHIDManagerTypeID)
  {
    pthread_once(&__sessionTypeInit, (void (*)(void))__IOHIDManagerRegister);
    uint64_t v4 = __kIOHIDManagerTypeID;
  }
  uint64_t Instance = _IOHIDObjectCreateInstance((uint64_t)allocator, v4, 0xF8uLL);
  CFTypeID v6 = (__IOHIDManager *)Instance;
  if (Instance)
  {
    *(void *)(Instance + 24) = 0;
    *(void *)(Instance + 160) = 0;
    *(_DWORD *)(Instance + 152) = options;
    if ((options & 3) == 1) {
      __IOHIDManagerLoadProperties(Instance);
    }
    dispatch_queue_t v7 = dispatch_queue_create("IOHIDManagerStateQueue", 0);
    *((void *)v6 + 32) = v7;
    if (v7) {
      *((void *)v6 + 31) = os_state_add_handler();
    }
  }
  return v6;
}

uint64_t __IOHIDManagerLoadProperties(uint64_t a1)
{
  DictionaryFromKey = __IOHIDPropertyLoadDictionaryFromKey(@"com.apple.iohidmanager");
  os_unfair_recursive_lock_lock_with_options();
  if (DictionaryFromKey)
  {
    CFIndex v3 = *(const void **)(a1 + 56);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 56) = DictionaryFromKey;
    *(unsigned char *)(a1 + 156) = 0;
  }

  return os_unfair_recursive_lock_unlock();
}

void *__IOHIDManagerCreate_block_invoke(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 16) & 0xFFFFFFFE) != 2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v5 = Mutable;
  os_unfair_recursive_lock_lock_with_options();
  CFTypeID v6 = (const void *)*MEMORY[0x1E4F1CFD0];
  dispatch_queue_t v7 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (*(void *)(v2 + 96)) {
    CFNumberRef v8 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    CFNumberRef v8 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(v5, @"DispatchQueue", v8);
  if (*(void *)(v2 + 80)) {
    CFTypeID v9 = v6;
  }
  else {
    CFTypeID v9 = v7;
  }
  CFDictionarySetValue(v5, @"RunLoop", v9);
  _IOHIDDictionaryAddSInt32(v5, @"openOptions", *(_DWORD *)(v2 + 148));
  _IOHIDDictionaryAddSInt32(v5, @"createOptions", *(_DWORD *)(v2 + 152));
  if (*(unsigned char *)(v2 + 144)) {
    CFTypeID v10 = v6;
  }
  else {
    CFTypeID v10 = v7;
  }
  CFDictionarySetValue(v5, @"isOpen", v10);
  uint64_t v11 = *(const void **)(v2 + 32);
  if (v11)
  {
    CFAllocatorRef v12 = CFGetAllocator(v11);
    CFSetRef Copy = CFSetCreateCopy(v12, *(CFSetRef *)(v2 + 32));
    if (Copy)
    {
      CFSetRef v14 = Copy;
      CFMutableArrayRef v15 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
      if (v15)
      {
        CFMutableArrayRef v16 = v15;
        context[0] = MEMORY[0x1E4F143A8];
        context[1] = 0x40000000;
        void context[2] = ____IOHIDManagerSerializeState_block_invoke;
        void context[3] = &__block_descriptor_tmp_39;
        context[4] = v15;
        _IOHIDCFSetApplyBlock(v14, context);
        CFDictionarySetValue(v5, @"devices", v16);
        CFRelease(v16);
      }
      CFRelease(v14);
    }
  }
  os_unfair_recursive_lock_unlock();
  CFDataRef Data = CFPropertyListCreateData(v3, v5, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (!Data)
  {
    CFRelease(v5);
    return 0;
  }
  CFDataRef v18 = Data;
  unsigned int Length = CFDataGetLength(Data);
  uint64_t v20 = malloc_type_calloc(1uLL, Length + 200, 0xDDD9AAE1uLL);
  if (v20)
  {
    __strlcpy_chk();
    *(_DWORD *)uint64_t v20 = 1;
    *((_DWORD *)v20 + 1) = Length;
    v23.location = 0;
    v23.CFIndex length = Length;
    CFDataGetBytes(v18, v23, (UInt8 *)v20 + 200);
  }
  CFRelease(v5);
  CFRelease(v18);
  return v20;
}

IOReturn IOHIDManagerOpen(IOHIDManagerRef manager, IOOptionBits options)
{
  if (*((unsigned char *)manager + 144)) {
    return 0;
  }
  *((unsigned char *)manager + 144) = 1;
  *((_DWORD *)manager + 37) = options;
  if (!*((void *)manager + 4)) {
    return 0;
  }
  if (*((void *)manager + 30)) {
    int v2 = 9;
  }
  else {
    int v2 = 1;
  }
  if (*((void *)manager + 22)) {
    v2 |= 0x10u;
  }
  if (*((void *)manager + 24)) {
    v2 |= 0x20u;
  }
  if (*((void *)manager + 25)) {
    int v3 = v2 | 0x1000;
  }
  else {
    int v3 = v2;
  }
  return __ApplyToDevices((CFSetRef *)manager, v3);
}

uint64_t __ApplyToDevices(CFSetRef *a1, int a2)
{
  dispatch_queue_t v7 = a1;
  uint64_t v3 = 3758097084;
  int v8 = a2;
  unsigned int v9 = 0;
  os_unfair_recursive_lock_lock_with_options();
  if (a1[4])
  {
    CFAllocatorRef v4 = CFGetAllocator(a1);
    CFSetRef Copy = CFSetCreateCopy(v4, a1[4]);
    os_unfair_recursive_lock_unlock();
    if (Copy)
    {
      CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDManagerDeviceApplier, &v7);
      uint64_t v3 = v9;
      CFRelease(Copy);
    }
  }
  else
  {
    os_unfair_recursive_lock_unlock();
    return 3758097088;
  }
  return v3;
}

IOReturn IOHIDManagerClose(IOHIDManagerRef manager, IOOptionBits options)
{
  CFAllocatorRef v4 = (__CFRunLoop *)*((void *)manager + 10);
  if (v4) {
    IOHIDManagerUnscheduleFromRunLoop(manager, v4, *((CFStringRef *)manager + 11));
  }
  if (*((unsigned char *)manager + 144))
  {
    *((unsigned char *)manager + 144) = 0;
    *((_DWORD *)manager + 37) = options;
    if (*((void *)manager + 4)) {
      IOReturn v5 = __ApplyToDevices((CFSetRef *)manager, 2);
    }
    else {
      IOReturn v5 = 0;
    }
  }
  else
  {
    IOReturn v5 = -536870195;
  }
  if ((*((_DWORD *)manager + 38) & 5) == 1) {
    __IOHIDManagerSaveProperties((uint64_t)manager, 0);
  }
  return v5;
}

void IOHIDManagerUnscheduleFromRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_recursive_lock_lock_with_options();
  CFTypeID v6 = (const void *)*((void *)manager + 10);
  if (v6 && CFEqual(v6, runLoop) && CFEqual(*((CFTypeRef *)manager + 11), runLoopMode))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 128);
    os_unfair_recursive_lock_lock_with_options();
    dispatch_queue_t v7 = (__CFSet *)*((void *)manager + 5);
    if (v7) {
      CFSetRemoveAllValues(v7);
    }
    int v8 = (__CFDictionary *)*((void *)manager + 6);
    if (v8) {
      CFDictionaryRemoveAllValues(v8);
    }
    *((void *)manager + 10) = 0;
    *((void *)manager + 11) = 0;
  }

  os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDManagerSaveProperties(uint64_t a1, CFStringRef *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(unsigned char *)(a1 + 156))
  {
    CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 56);
    if (v4)
    {
      __IOHIDPropertySaveToKeyWithSpecialKeys(v4, @"com.apple.iohidmanager", 0, a2);
      *(unsigned char *)(a1 + 156) = 0;
    }
  }
  if (*(void *)(a1 + 32))
  {
    CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
    CFSetRef Copy = CFSetCreateCopy(v5, *(CFSetRef *)(a1 + 32));
    if (Copy)
    {
      CFSetRef v7 = Copy;
      CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDSaveDeviceSet, a2);
      CFRelease(v7);
    }
  }

  return os_unfair_recursive_lock_unlock();
}

CFTypeRef IOHIDManagerGetProperty(IOHIDManagerRef manager, CFStringRef key)
{
  os_unfair_recursive_lock_lock_with_options();
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)manager + 7);
  if (v4) {
    CFNumberRef Value = CFDictionaryGetValue(v4, key);
  }
  else {
    CFNumberRef Value = 0;
  }
  os_unfair_recursive_lock_unlock();
  return Value;
}

Boolean IOHIDManagerSetProperty(IOHIDManagerRef manager, CFStringRef key, CFTypeRef value)
{
  v11[0] = key;
  v11[1] = value;
  os_unfair_recursive_lock_lock_with_options();
  CFMutableDictionaryRef Mutable = (__CFDictionary *)*((void *)manager + 7);
  if (!Mutable)
  {
    CFAllocatorRef v7 = CFGetAllocator(manager);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *((void *)manager + 7) = Mutable;
    if (!Mutable)
    {
      os_unfair_recursive_lock_unlock();
      return 0;
    }
  }
  *((unsigned char *)manager + 156) = 1;
  CFDictionarySetValue(Mutable, key, value);
  if (!*((void *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    return 1;
  }
  CFAllocatorRef v8 = CFGetAllocator(manager);
  CFSetRef Copy = CFSetCreateCopy(v8, *((CFSetRef *)manager + 4));
  os_unfair_recursive_lock_unlock();
  if (!Copy) {
    return 0;
  }
  CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDApplyPropertyToDeviceSet, v11);
  CFRelease(Copy);
  return 1;
}

void IOHIDManagerSetDeviceMatching(IOHIDManagerRef manager, CFDictionaryRef matching)
{
  values = matching;
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  if (values)
  {
    CFAllocatorRef v4 = CFGetAllocator(manager);
    CFArrayRef v5 = CFArrayCreate(v4, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    IOHIDManagerSetDeviceMatchingMultiple(manager, v5);
    if (v5) {
      CFRelease(v5);
    }
  }
  else
  {
    IOHIDManagerSetDeviceMatchingMultiple(manager, 0);
  }
}

void IOHIDManagerSetDeviceMatchingMultiple(IOHIDManagerRef manager, CFArrayRef multiple)
{
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  CFArrayRef v5 = (__CFSet *)*((void *)manager + 4);
  if (v5)
  {
    if ((*((_DWORD *)manager + 38) & 5) == 1)
    {
      __IOHIDManagerSaveProperties((uint64_t)manager, 0);
      CFArrayRef v5 = (__CFSet *)*((void *)manager + 4);
    }
    CFSetRemoveAllValues(v5);
  }
  CFTypeID v6 = (__CFDictionary *)*((void *)manager + 6);
  if (v6) {
    CFDictionaryRemoveAllValues(v6);
  }
  CFAllocatorRef v7 = (__CFSet *)*((void *)manager + 5);
  if (v7) {
    CFSetRemoveAllValues(v7);
  }
  CFAllocatorRef v8 = (__CFDictionary *)*((void *)manager + 8);
  if (v8) {
    CFDictionaryRemoveAllValues(v8);
  }
  unsigned int v9 = (const void *)*((void *)manager + 15);
  if (v9)
  {
    CFRelease(v9);
    *((void *)manager + 15) = 0;
  }
  if (multiple)
  {
    CFIndex Count = CFArrayGetCount(multiple);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0; i != v11; ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(multiple, i);
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(ValueAtIndex)) {
          __IOHIDManagerSetDeviceMatching((uint64_t)manager, ValueAtIndex);
        }
      }
    }
  }
  else
  {
    __IOHIDManagerSetDeviceMatching((uint64_t)manager, 0);
  }
  if (*((void *)manager + 4))
  {
    CFMutableArrayRef v15 = (const void *)*((void *)manager + 15);
    if (v15) {
      CFRelease(v15);
    }
    CFAllocatorRef v16 = CFGetAllocator(manager);
    *((void *)manager + 15) = CFSetCreateCopy(v16, *((CFSetRef *)manager + 4));
  }

  os_unfair_recursive_lock_unlock();
}

void __IOHIDManagerSetDeviceMatching(uint64_t a1, const __CFDictionary *a2)
{
  kern_return_t v6;
  int v7;
  NSObject *v8;
  IONotificationPort *v9;
  __CFRunLoopSource *RunLoopSource;
  __CFSet *v11;
  CFAllocatorRef v12;
  CFSetCallBacks v13;
  io_iterator_t notification;

  os_unfair_recursive_lock_lock_with_options();
  if (!*(void *)(a1 + 72))
  {
    unsigned int v9 = IONotificationPortCreate(0);
    *(void *)(a1 + 72) = v9;
    if (*(void *)(a1 + 80))
    {
      CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(v9);
      if (RunLoopSource) {
        CFRunLoopAddSource(*(CFRunLoopRef *)(a1 + 80), RunLoopSource, *(CFRunLoopMode *)(a1 + 88));
      }
    }
  }
  os_unfair_recursive_lock_unlock();
  CFAllocatorRef v4 = IOServiceMatching("IOHIDDevice");
  if (v4)
  {
    CFDictionaryRef v5 = v4;
    notification = 0;
    __IOHIDManagerMergeDictionaries(a2, v4);
    CFTypeID v6 = IOServiceAddMatchingNotification(*(IONotificationPortRef *)(a1 + 72), "IOServiceFirstMatch", v5, (IOServiceMatchingCallback)__IOHIDManagerDeviceAdded, (void *)a1, &notification);
    if (v6)
    {
      CFAllocatorRef v7 = v6;
      CFAllocatorRef v8 = _IOHIDLogCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        __IOHIDManagerSetDeviceMatching_cold_1(v7, v8);
      }
    }
    else
    {
      os_unfair_recursive_lock_lock_with_options();
      CFIndex v11 = *(__CFSet **)(a1 + 40);
      if (v11
        || (v13.version = 0,
            memset(&v13.copyDescription, 0, 24),
            v13.retain = (CFSetRetainCallBack)_IOObjectCFRetain,
            v13.release = (CFSetReleaseCallBack)_IOObjectCFRelease,
            CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1),
            CFIndex v11 = CFSetCreateMutable(v12, 0, &v13),
            (*(void *)(a1 + 40) = v11) != 0))
      {
        CFSetAddValue(v11, (const void *)notification);
        IOObjectRelease(notification);
        os_unfair_recursive_lock_unlock();
        __IOHIDManagerDeviceAdded(a1, notification);
      }
      else
      {
        os_unfair_recursive_lock_unlock();
      }
    }
  }
}

CFSetRef IOHIDManagerCopyDevices(IOHIDManagerRef manager)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*((void *)manager + 4))
  {
    CFAllocatorRef v2 = CFGetAllocator(manager);
    CFSetRef Copy = CFSetCreateCopy(v2, *((CFSetRef *)manager + 4));
  }
  else
  {
    CFSetRef Copy = 0;
  }
  os_unfair_recursive_lock_unlock();
  return Copy;
}

void IOHIDManagerRegisterDeviceMatchingCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  *((void *)manager + 26) = context;
  *((void *)manager + 27) = callback;

  os_unfair_recursive_lock_unlock();
}

void IOHIDManagerRegisterDeviceRemovalCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  *((void *)manager + 28) = context;
  *((void *)manager + 29) = callback;

  os_unfair_recursive_lock_unlock();
}

void IOHIDManagerRegisterInputReportCallback(IOHIDManagerRef manager, IOHIDReportCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  *((void *)manager + 23) = context;
  *((void *)manager + 24) = callback;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((unsigned char *)manager + 144) && *((void *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 32);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerRegisterInputReportWithTimeStampCallback(IOHIDManagerRef manager, IOHIDReportWithTimeStampCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  *((void *)manager + 25) = callback;
  *((void *)manager + 23) = context;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((unsigned char *)manager + 144) && *((void *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 4096);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerRegisterInputValueCallback(IOHIDManagerRef manager, IOHIDValueCallback callback, void *context)
{
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  *((void *)manager + 21) = context;
  *((void *)manager + 22) = callback;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((unsigned char *)manager + 144) && *((void *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 16);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerSetInputValueMatching(IOHIDManagerRef manager, CFDictionaryRef matching)
{
  values = matching;
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  if (values)
  {
    CFAllocatorRef v4 = CFGetAllocator(manager);
    CFArrayRef v5 = CFArrayCreate(v4, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    IOHIDManagerSetInputValueMatchingMultiple(manager, v5);
    CFRelease(v5);
  }
  else
  {
    IOHIDManagerSetInputValueMatchingMultiple(manager, 0);
  }
}

void IOHIDManagerSetInputValueMatchingMultiple(IOHIDManagerRef manager, CFArrayRef multiple)
{
  if (atomic_load((unsigned int *)manager + 29)) {
    IOHIDManagerSetDeviceMatching_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  CFArrayRef v5 = (const void *)*((void *)manager + 30);
  if (v5) {
    CFRelease(v5);
  }
  if (multiple) {
    CFRetain(multiple);
  }
  *((void *)manager + 30) = multiple;
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (*((unsigned char *)manager + 144) && *((void *)manager + 4))
  {
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 8);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerScheduleWithRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*((void *)manager + 10) | *((void *)manager + 12))
  {
    manager = (IOHIDManagerRef)MEMORY[0x1E4F14500];
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *((void *)manager + 10) = runLoop;
  *((void *)manager + 11) = runLoopMode;
  if (runLoop)
  {
    if (*((void *)manager + 15))
    {
      CFTypeID v6 = (__CFRunLoopSource *)*((void *)manager + 16);
      if (v6)
      {
        CFRunLoopAddSource(runLoop, v6, runLoopMode);
        CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)manager + 16));
        CFRunLoopWakeUp(*((CFRunLoopRef *)manager + 10));
      }
    }
    CFAllocatorRef v7 = (IONotificationPort *)*((void *)manager + 9);
    if (v7)
    {
      CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(v7);
      if (RunLoopSource) {
        CFRunLoopAddSource(*((CFRunLoopRef *)manager + 10), RunLoopSource, *((CFRunLoopMode *)manager + 11));
      }
    }
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)manager, 64);
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerSetDispatchQueue(IOHIDManagerRef manager, dispatch_queue_t queue)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  if (*((void *)manager + 10) || *((void *)manager + 12)) {
    IOHIDManagerSetDispatchQueue_cold_1(&v7, __str);
  }
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)__str = 0u;
  long long v9 = 0u;
  label = dispatch_queue_get_label(queue);
  CFArrayRef v5 = "";
  if (label) {
    CFArrayRef v5 = label;
  }
  snprintf(__str, 0x100uLL, "%s.IOHIDManagerRef", v5);
  dispatch_queue_t v6 = dispatch_queue_create_with_target_V2(__str, 0, queue);
  *((void *)manager + 12) = v6;
  os_unfair_recursive_lock_unlock();
  if (v6) {
    __ApplyToDevices((CFSetRef *)manager, 256);
  }
}

void IOHIDManagerSetCancelHandler(IOHIDManagerRef manager, dispatch_block_t handler)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  if (!handler || *((void *)manager + 13)) {
    IOHIDManagerSetCancelHandler_cold_1(&v4, v5);
  }
  _IOHIDObjectInternalRetain(manager);
  *((void *)manager + 13) = _Block_copy(handler);
  os_unfair_recursive_lock_unlock();

  __ApplyToDevices((CFSetRef *)manager, 512);
}

void IOHIDManagerActivate(IOHIDManagerRef manager)
{
  if (*((void *)manager + 12)) {
    BOOL v1 = *((void *)manager + 10) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    manager = (IOHIDManagerRef)_os_crash_msg();
    __break(1u);
  }
  IOHIDManagerRef v2 = manager;
  if ((atomic_fetch_or((atomic_uint *volatile)manager + 29, 1u) & 1) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    if (*((void *)v2 + 27)) {
      int v3 = 1028;
    }
    else {
      int v3 = 1024;
    }
    os_unfair_recursive_lock_unlock();
    __ApplyToDevices((CFSetRef *)v2, v3);
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v4 = (IONotificationPort *)*((void *)v2 + 9);
    if (v4) {
      IONotificationPortSetDispatchQueue(v4, *((dispatch_queue_t *)v2 + 12));
    }
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerCancel(IOHIDManagerRef manager)
{
  if (*((void *)manager + 12)) {
    BOOL v1 = *((void *)manager + 10) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    manager = (IOHIDManagerRef)_os_crash_msg();
    __break(1u);
  }
  IOHIDManagerRef v2 = manager;
  if ((atomic_fetch_or((atomic_uint *volatile)manager + 29, 2u) & 2) == 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    uint64_t v4 = (IONotificationPort *)*((void *)v2 + 9);
    if (v4)
    {
      IONotificationPortDestroy(v4);
      *((void *)v2 + 9) = 0;
    }
    CFArrayRef v5 = (__CFSet *)*((void *)v2 + 5);
    if (v5) {
      CFSetRemoveAllValues(v5);
    }
    uint64_t v6 = (__CFDictionary *)*((void *)v2 + 6);
    if (v6) {
      CFDictionaryRemoveAllValues(v6);
    }
    CFSetRef v7 = (const __CFSet *)*((void *)v2 + 4);
    if (v7 && CFSetGetCount(v7) && *((_DWORD *)v2 + 28))
    {
      __ApplyToDevices((CFSetRef *)v2, 2048);
    }
    else
    {
      uint64_t v8 = *((void *)v2 + 13);
      if (v8)
      {
        (*(void (**)(uint64_t, uint64_t))(v8 + 16))(v8, v3);
        _Block_release(*((const void **)v2 + 13));
        *((void *)v2 + 13) = 0;
        _IOHIDObjectInternalRelease(v2);
      }
    }
    os_unfair_recursive_lock_unlock();
  }
}

void IOHIDManagerSaveToPropertyDomain(IOHIDManagerRef manager, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName, IOOptionBits options)
{
  v5[0] = applicationID;
  v5[1] = userName;
  _DWORD v5[2] = hostName;
  v5[3] = (CFStringRef)options;
  if (manager && applicationID && userName)
  {
    if (hostName) {
      __IOHIDManagerSaveProperties((uint64_t)manager, v5);
    }
  }
}

__CFString *__IOHIDManagerGetRootKey()
{
  return @"com.apple.iohidmanager";
}

void __IOHIDPropertySaveToKeyWithSpecialKeys(CFDictionaryRef theDict, const __CFString *a2, void *a3, CFStringRef *a4)
{
  MutableCFSetRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  if (a3)
  {
    uint64_t v8 = (const void *)*a3;
    if (*a3)
    {
      do
      {
        CFNumberRef Value = CFDictionaryGetValue(MutableCopy, v8);
        if (Value)
        {
          long long v10 = Value;
          CFStringRef v11 = CFStringCreateWithFormat(0, 0, @"%@#%@", a2, *a3);
          __IOHIDPropertySaveWithContext(v11, v10, a4);
          CFDictionaryRemoveValue(MutableCopy, (const void *)*a3);
          CFRelease(v11);
        }
        long long v12 = (const void *)a3[1];
        ++a3;
        uint64_t v8 = v12;
      }
      while (v12);
    }
  }
  CFAbsoluteTime valuePtr = CFAbsoluteTimeGetCurrent();
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFDictionaryAddValue(MutableCopy, @"time of last save", v13);
  CFRelease(v13);
  __IOHIDPropertySaveWithContext(a2, MutableCopy, a4);
  CFRelease(MutableCopy);
}

__CFDictionary *__IOHIDPropertyLoadDictionaryFromKey(const __CFString *a1)
{
  CFStringRef v2 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
  CFDictionaryRef v3 = (const __CFDictionary *)CFPreferencesCopyAppValue(a1, (CFStringRef)*MEMORY[0x1E4F1D3D8]);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef v4 = v3;
  CFTypeID v5 = CFGetTypeID(v3);
  if (v5 == CFDictionaryGetTypeID())
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D3B8];
    CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1D3D0];
    CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1D3C8];
    CFDictionaryRef v10 = (const __CFDictionary *)CFPreferencesCopyValue(a1, (CFStringRef)*MEMORY[0x1E4F1D3B8], (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
    if (v10)
    {
      CFDictionaryRef v11 = v10;
      CFTypeID v12 = CFGetTypeID(v10);
      if (v12 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v11, Mutable);
      }
      CFRelease(v11);
    }
    CFStringRef hostName = (const __CFString *)*MEMORY[0x1E4F1D3E0];
    CFDictionaryRef v13 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v7, v8, (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    if (v13)
    {
      CFDictionaryRef v14 = v13;
      CFTypeID v15 = CFGetTypeID(v13);
      if (v15 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v14, Mutable);
      }
      CFRelease(v14);
    }
    CFStringRef v16 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
    CFStringRef v17 = v9;
    CFDictionaryRef v18 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v7, (CFStringRef)*MEMORY[0x1E4F1D3F0], v9);
    if (v18)
    {
      CFDictionaryRef v19 = v18;
      CFTypeID v20 = CFGetTypeID(v18);
      if (v20 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v19, Mutable);
      }
      CFRelease(v19);
    }
    CFDictionaryRef v21 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v7, v16, hostName);
    if (v21)
    {
      CFDictionaryRef v22 = v21;
      CFTypeID v23 = CFGetTypeID(v21);
      if (v23 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v22, Mutable);
      }
      CFRelease(v22);
    }
    CFDictionaryRef v24 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v8, v17);
    if (v24)
    {
      CFDictionaryRef v25 = v24;
      CFTypeID v26 = CFGetTypeID(v24);
      if (v26 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v25, Mutable);
      }
      CFRelease(v25);
    }
    CFDictionaryRef v27 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v8, hostName);
    if (v27)
    {
      CFDictionaryRef v28 = v27;
      CFTypeID v29 = CFGetTypeID(v27);
      if (v29 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v28, Mutable);
      }
      CFRelease(v28);
    }
    CFDictionaryRef v30 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v16, v17);
    if (v30)
    {
      CFDictionaryRef v31 = v30;
      CFTypeID v32 = CFGetTypeID(v30);
      if (v32 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v31, Mutable);
      }
      CFRelease(v31);
    }
    CFDictionaryRef v33 = (const __CFDictionary *)CFPreferencesCopyValue(a1, v2, v16, hostName);
    if (v33)
    {
      CFDictionaryRef v34 = v33;
      CFTypeID v35 = CFGetTypeID(v33);
      if (v35 == CFDictionaryGetTypeID()) {
        __IOHIDManagerMergeDictionaries(v34, Mutable);
      }
      CFRelease(v34);
    }
    __IOHIDManagerMergeDictionaries(v4, Mutable);
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  CFRelease(v4);
  return Mutable;
}

void __IOHIDPropertySaveWithContext(const __CFString *a1, const void *a2, CFStringRef *a3)
{
  if (a1 && a2)
  {
    if (a3 && *a3 && (v3 = a3[1]) != 0 && (CFStringRef v4 = a3[2]) != 0) {
      CFPreferencesSetValue(a1, a2, *a3, v3, v4);
    }
    else {
      CFPreferencesSetAppValue(a1, a2, (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    }
  }
}

void __IOHIDManagerMergeDictionaries(const __CFDictionary *a1, __CFDictionary *a2)
{
  if (!a1) {
    return;
  }
  if (!a2) {
    return;
  }
  unsigned int Count = CFDictionaryGetCount(a1);
  uint64_t v5 = Count;
  if (!Count) {
    return;
  }
  size_t v6 = 8 * Count;
  CFStringRef v7 = (const void **)malloc_type_malloc(v6, 0xC0040B8AA526DuLL);
  CFStringRef v8 = (const void **)malloc_type_malloc(v6, 0x6004044C4A2DFuLL);
  CFStringRef v9 = v8;
  if (v7 && v8)
  {
    CFDictionaryGetKeysAndValues(a1, v8, v7);
    CFDictionaryRef v10 = v7;
    CFDictionaryRef v11 = v9;
    do
    {
      CFDictionaryRef v13 = *v11++;
      CFTypeID v12 = v13;
      CFDictionaryRef v14 = *v10++;
      CFDictionarySetValue(a2, v12, v14);
      --v5;
    }
    while (v5);
  }
  else if (!v7)
  {
    goto LABEL_11;
  }
  free(v7);
LABEL_11:
  if (v9)
  {
    free(v9);
  }
}

__CFDictionary *__IOHIDPropertyLoadFromKeyWithSpecialKeys(const __CFString *a1, uint64_t *a2)
{
  DictionaryFromKey = __IOHIDPropertyLoadDictionaryFromKey(a1);
  if (!DictionaryFromKey) {
    DictionaryFromKey = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  }
  uint64_t v5 = *a2;
  if (*a2)
  {
    CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
    CFStringRef v7 = a2 + 1;
    do
    {
      CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"%@#%@", a1, v5);
      CFPropertyListRef v9 = CFPreferencesCopyAppValue(v8, v6);
      if (v9)
      {
        CFDictionaryRef v10 = v9;
        CFDictionarySetValue(DictionaryFromKey, (const void *)*(v7 - 1), v9);
        CFRelease(v10);
      }
      CFRelease(v8);
      uint64_t v11 = *v7++;
      uint64_t v5 = v11;
    }
    while (v11);
  }
  return DictionaryFromKey;
}

uint64_t __IOHIDManagerExtRelease(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  if (*(void *)(a1 + 96))
  {
    unsigned int v2 = atomic_load((unsigned int *)(a1 + 116));
    if (v2 != 3) {
      __IOHIDManagerExtRelease_cold_1(&v9, v10, (unsigned int *)(a1 + 116));
    }
  }
  if ((*(_DWORD *)(a1 + 152) & 5) == 1) {
    __IOHIDManagerSaveProperties(a1, 0);
  }
  if (*(unsigned char *)(a1 + 144)) {
    IOHIDManagerClose((IOHIDManagerRef)a1, *(_DWORD *)(a1 + 148));
  }
  CFStringRef v3 = *(__CFRunLoop **)(a1 + 80);
  if (v3) {
    IOHIDManagerUnscheduleFromRunLoop((IOHIDManagerRef)a1, v3, *(CFStringRef *)(a1 + 88));
  }
  CFStringRef v4 = *(IONotificationPort **)(a1 + 72);
  if (v4)
  {
    CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(v4);
    if (RunLoopSource) {
      CFRunLoopSourceInvalidate(RunLoopSource);
    }
  }
  CFStringRef v6 = *(__CFRunLoopSource **)(a1 + 128);
  if (v6) {
    CFRunLoopSourceInvalidate(v6);
  }
  if (*(void *)(a1 + 248)) {
    os_state_remove_handler();
  }
  CFStringRef v7 = *(NSObject **)(a1 + 256);
  if (v7)
  {
    dispatch_set_context(v7, (void *)a1);
    dispatch_set_finalizer_f(*(dispatch_object_t *)(a1 + 256), (dispatch_function_t)__IOHIDManagerFinalizeStateHandler);
    _IOHIDObjectInternalRetain((const void *)a1);
    dispatch_release(*(dispatch_object_t *)(a1 + 256));
  }

  return os_unfair_recursive_lock_unlock();
}

void __IOHIDManagerIntRelease(void *a1)
{
  unsigned int v2 = (IONotificationPort *)a1[9];
  if (v2)
  {
    IONotificationPortDestroy(v2);
    a1[9] = 0;
  }
  CFStringRef v3 = (const void *)a1[15];
  if (v3)
  {
    CFRelease(v3);
    a1[15] = 0;
  }
  CFStringRef v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  uint64_t v5 = (const void *)a1[8];
  if (v5)
  {
    CFRelease(v5);
    a1[8] = 0;
  }
  CFStringRef v6 = (const void *)a1[5];
  if (v6)
  {
    CFRelease(v6);
    a1[5] = 0;
  }
  CFStringRef v7 = (const void *)a1[7];
  if (v7)
  {
    CFRelease(v7);
    a1[7] = 0;
  }
  CFStringRef v8 = (const void *)a1[17];
  if (v8)
  {
    CFRelease(v8);
    a1[17] = 0;
  }
  uint64_t v9 = (const void *)a1[30];
  if (v9)
  {
    CFRelease(v9);
    a1[30] = 0;
  }
  CFDictionaryRef v10 = a1[12];
  if (v10) {
    dispatch_release(v10);
  }
  uint64_t v11 = (const void *)a1[6];
  if (v11) {
    CFRelease(v11);
  }
  CFTypeID v12 = (const void *)a1[16];
  if (v12)
  {
    CFRelease(v12);
    a1[16] = 0;
  }
}

void __IOHIDManagerDeviceApplier(__IOHIDDevice *key, unsigned char *a2)
{
  uint64_t v4 = *(void *)a2;
  if ((*(unsigned char *)(*(void *)a2 + 152) & 8) != 0)
  {
    uint64_t v5 = 0;
    goto LABEL_34;
  }
  if (a2[8])
  {
    uint64_t v5 = (const void *)IOHIDDeviceOpen(key, *(_DWORD *)(v4 + 148));
    CFStringRef v6 = *(__CFDictionary **)(*(void *)a2 + 136);
    if (v6) {
      CFDictionarySetValue(v6, key, v5);
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  int v7 = *((_DWORD *)a2 + 2);
  if ((v7 & 2) != 0)
  {
    uint64_t v5 = (const void *)IOHIDDeviceClose(key, *(_DWORD *)(*(void *)a2 + 148));
    int v7 = *((_DWORD *)a2 + 2);
    if ((v7 & 8) == 0)
    {
LABEL_8:
      if ((v7 & 0x10) == 0) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  else if ((v7 & 8) == 0)
  {
    goto LABEL_8;
  }
  IOHIDDeviceSetInputValueMatchingMultiple(key, *(CFArrayRef *)(*(void *)a2 + 240));
  int v7 = *((_DWORD *)a2 + 2);
  if ((v7 & 0x10) != 0)
  {
LABEL_9:
    IOHIDDeviceRegisterInputValueCallback(key, *(IOHIDValueCallback *)(*(void *)a2 + 176), *(void **)(*(void *)a2 + 168));
    int v7 = *((_DWORD *)a2 + 2);
  }
LABEL_10:
  if ((v7 & 0x1020) != 0)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFDictionaryRef Mutable = *(const __CFDictionary **)(*(void *)a2 + 64);
    if (!Mutable)
    {
      CFAllocatorRef v9 = CFGetAllocator(*(CFTypeRef *)a2);
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      *(void *)(*(void *)a2 + 64) = Mutable;
    }
    CFNumberRef Value = (void *)CFDictionaryGetValue(Mutable, key);
    if (!Value)
    {
      CFNumberRef Property = (const __CFNumber *)IOHIDDeviceGetProperty(key, @"MaxInputReportSize");
      CFIndex valuePtr = 64;
      if (Property) {
        CFNumberGetValue(Property, kCFNumberCFIndexType, &valuePtr);
      }
      CFAllocatorRef v12 = CFGetAllocator(*(CFTypeRef *)a2);
      CFDictionaryRef v13 = CFDataCreateMutable(v12, valuePtr);
      CFNumberRef Value = v13;
      if (v13)
      {
        CFDataSetLength(v13, valuePtr);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)a2 + 64), key, Value);
        CFRelease(Value);
      }
    }
    os_unfair_recursive_lock_unlock();
    int v14 = *((_DWORD *)a2 + 2);
    MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
    CFIndex Length = CFDataGetLength((CFDataRef)Value);
    CFTypeRef v17 = *(CFTypeRef *)a2;
    CFDictionaryRef v18 = *(void **)(*(void *)a2 + 184);
    if ((v14 & 0x20) != 0) {
      IOHIDDeviceRegisterInputReportCallback(key, MutableBytePtr, Length, *((IOHIDReportCallback *)v17 + 24), v18);
    }
    else {
      IOHIDDeviceRegisterInputReportWithTimeStampCallback(key, MutableBytePtr, Length, *((IOHIDReportWithTimeStampCallback *)v17 + 25), v18);
    }
  }
  int v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x40) != 0)
  {
    IOHIDDeviceScheduleWithRunLoop(key, *(CFRunLoopRef *)(*(void *)a2 + 80), *(CFStringRef *)(*(void *)a2 + 88));
    int v19 = *((_DWORD *)a2 + 2);
    if ((v19 & 0x80) == 0)
    {
LABEL_26:
      if ((v19 & 0x100) == 0) {
        goto LABEL_27;
      }
      goto LABEL_41;
    }
  }
  else if ((v19 & 0x80) == 0)
  {
    goto LABEL_26;
  }
  IOHIDDeviceUnscheduleFromRunLoop(key, *(CFRunLoopRef *)(*(void *)a2 + 80), *(CFStringRef *)(*(void *)a2 + 88));
  int v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x100) == 0)
  {
LABEL_27:
    if ((v19 & 0x200) == 0) {
      goto LABEL_28;
    }
    goto LABEL_42;
  }
LABEL_41:
  IOHIDDeviceSetDispatchQueue(key, *(dispatch_queue_t *)(v4 + 96));
  int v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x200) == 0)
  {
LABEL_28:
    if ((v19 & 0x400) == 0) {
      goto LABEL_29;
    }
LABEL_43:
    IOHIDDeviceActivate(key);
    if ((*((_DWORD *)a2 + 2) & 0x800) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
LABEL_42:
  ++*(_DWORD *)(v4 + 112);
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 0x40000000;
  v22[2] = ____IOHIDManagerDeviceApplier_block_invoke;
  v22[3] = &__block_descriptor_tmp_17;
  v22[4] = v4;
  IOHIDDeviceSetCancelHandler(key, v22);
  int v19 = *((_DWORD *)a2 + 2);
  if ((v19 & 0x400) != 0) {
    goto LABEL_43;
  }
LABEL_29:
  if ((v19 & 0x800) != 0) {
LABEL_30:
  }
    IOHIDDeviceCancel(key);
LABEL_31:
  if (!*((_DWORD *)a2 + 3) && v5) {
    *((_DWORD *)a2 + 3) = v5;
  }
LABEL_34:
  if ((a2[8] & 4) != 0)
  {
    CFTypeID v20 = *(void (***)(void, const void *, CFTypeRef, __IOHIDDevice *))a2;
    CFDictionaryRef v21 = *(const __CFDictionary **)(*(void *)a2 + 136);
    if (v21)
    {
      uint64_t v5 = CFDictionaryGetValue(v21, key);
      CFTypeID v20 = *(void (***)(void, const void *, CFTypeRef, __IOHIDDevice *))a2;
    }
    v20[27](v20[26], v5, v20, key);
  }
}

uint64_t __IOHIDManagerDeviceAdded(uint64_t a1, io_iterator_t iterator)
{
  kern_return_t v13;
  __CFDictionary *Mutable;
  NSObject *v15;
  long long v16;
  __CFSet *v17;
  int v18;
  int v19;
  unsigned int v20;
  char v21;
  CFDictionaryRef v22;
  CFAllocatorRef v23;
  CFAllocatorRef v24;
  __CFRunLoopSource *v25;
  __CFRunLoop *v26;
  CFStringRef v27;
  CFAllocatorRef allocator;
  uint64_t v29;
  uint64_t v30;
  io_object_t notification;
  CFRunLoopSourceContext valueCallBacks;
  uint64_t v33;

  CFDictionaryRef v33 = *MEMORY[0x1E4F143B8];
  notification = 0;
  uint64_t result = IOIteratorNext(iterator);
  if (!result) {
    return result;
  }
  io_service_t v5 = result;
  int v6 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v7 = MEMORY[0x1E4F1D540];
  do
  {
    CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
    IOHIDDeviceRef v9 = IOHIDDeviceCreate(v8, v5);
    if (!v9) {
      goto LABEL_45;
    }
    IOHIDDeviceRef v10 = v9;
    os_unfair_recursive_lock_lock_with_options();
    if (!*(void *)(a1 + 32))
    {
      CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
      *(void *)(a1 + 32) = CFSetCreateMutable(v11, 0, MEMORY[0x1E4F1D548]);
      if (*(unsigned char *)(a1 + 144))
      {
        CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
        *(void *)(a1 + 136) = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E4F1D530], 0);
      }
      int v6 = 1;
    }
    CFTypeID v29 = a1;
    CFDictionaryRef v30 = 0;
    CFDictionaryRef v13 = IOServiceAddInterestNotification(*(IONotificationPortRef *)(a1 + 72), v5, "IOGeneralInterest", (IOServiceInterestCallback)__IOHIDManagerDeviceRemoved, (void *)a1, &notification);
    CFDictionaryRef Mutable = *(__CFDictionary **)(a1 + 48);
    if (Mutable)
    {
      if (!v13) {
        goto LABEL_14;
      }
    }
    else
    {
      CFStringRef v16 = *(_OWORD *)(v7 + 16);
      *(_OWORD *)&valueCallBacks.version = *(_OWORD *)v7;
      *(_OWORD *)&valueCallBacks.retain = v16;
      valueCallBacks.copyDescription = *(CFStringRef (__cdecl **)(const void *))(v7 + 32);
      valueCallBacks.info = _IOObjectCFRetain;
      valueCallBacks.retain = (const void *(__cdecl *)(const void *))_IOObjectCFRelease;
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], (const CFDictionaryValueCallBacks *)&valueCallBacks);
      *(void *)(a1 + 48) = Mutable;
      if (!v13)
      {
LABEL_14:
        CFDictionarySetValue(Mutable, v10, (const void *)notification);
        IOObjectRelease(notification);
        CFTypeRef v17 = *(__CFSet **)(a1 + 32);
        if (v17) {
          CFSetAddValue(v17, v10);
        }
        os_unfair_recursive_lock_unlock();
        os_unfair_recursive_lock_lock_with_options();
        if (*(void *)(a1 + 240))
        {
          CFDictionaryRef v18 = 8;
          LODWORD(v30) = 8;
        }
        else
        {
          CFDictionaryRef v18 = 0;
        }
        if (*(void *)(a1 + 176))
        {
          v18 |= 0x10u;
          LODWORD(v30) = v18;
        }
        if (*(void *)(a1 + 192))
        {
          v18 |= 0x20u;
          LODWORD(v30) = v18;
        }
        if (*(void *)(a1 + 200))
        {
          v18 |= 0x1000u;
          LODWORD(v30) = v18;
        }
        if (*(void *)(a1 + 104))
        {
          v18 |= 0x200u;
          LODWORD(v30) = v18;
        }
        os_unfair_recursive_lock_unlock();
        os_unfair_recursive_lock_lock_with_options();
        if (*(unsigned char *)(a1 + 144))
        {
          v18 |= 1u;
          LODWORD(v30) = v18;
        }
        if (*(void *)(a1 + 80))
        {
          int v19 = v18 | 0x40;
          LODWORD(v30) = v18 | 0x40;
          if (!v6 && *(void *)(a1 + 216))
          {
            int v19 = v18 | 0x44;
            LODWORD(v30) = v18 | 0x44;
          }
        }
        else
        {
          int v19 = v18;
        }
        if (*(void *)(a1 + 96))
        {
          LODWORD(v30) = v19 | 0x100;
          if (*(void *)(a1 + 216))
          {
            CFTypeID v20 = atomic_load((unsigned int *)(a1 + 116));
            if (v20 == 1) {
              LODWORD(v30) = v30 | 4;
            }
          }
        }
        CFDictionaryRef v21 = atomic_load((unsigned int *)(a1 + 116));
        if (v21) {
          LODWORD(v30) = v30 | 0x400;
        }
        os_unfair_recursive_lock_unlock();
        __IOHIDManagerDeviceApplier(v10, &v29);
        if ((*(_DWORD *)(a1 + 152) & 3) == 1) {
          __IOHIDDeviceLoadProperties((uint64_t)v10);
        }
        os_unfair_recursive_lock_lock_with_options();
        CFDictionaryRef v22 = *(const __CFDictionary **)(a1 + 56);
        if (v22) {
          CFDictionaryApplyFunction(v22, (CFDictionaryApplierFunction)__IOHIDApplyPropertiesToDeviceFromDictionary, v10);
        }
        os_unfair_recursive_lock_unlock();
        CFRelease(v10);
LABEL_45:
        IOObjectRelease(v5);
        goto LABEL_46;
      }
    }
    CFTypeID v15 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(valueCallBacks.version) = 67109120;
      HIDWORD(valueCallBacks.version) = v13;
      _os_log_error_impl(&dword_18B46C000, v15, OS_LOG_TYPE_ERROR, "IOServiceAddInterestNotification: 0x%x", (uint8_t *)&valueCallBacks, 8u);
    }
    CFRelease(v10);
    IOObjectRelease(v5);
    os_unfair_recursive_lock_unlock();
LABEL_46:
    uint64_t result = IOIteratorNext(iterator);
    io_service_t v5 = result;
  }
  while (result);
  if (v6)
  {
    memset(&valueCallBacks, 0, 72);
    os_unfair_recursive_lock_lock_with_options();
    valueCallBacks.info = (void *)a1;
    valueCallBacks.perform = (void (__cdecl *)(void *))__IOHIDManagerInitialEnumCallback;
    CFTypeID v23 = CFGetAllocator((CFTypeRef)a1);
    *(void *)(a1 + 120) = CFSetCreateCopy(v23, *(CFSetRef *)(a1 + 32));
    CFDictionaryRef v24 = CFGetAllocator((CFTypeRef)a1);
    CFDictionaryRef v25 = CFRunLoopSourceCreate(v24, 0, &valueCallBacks);
    *(void *)(a1 + 128) = v25;
    CFTypeID v26 = *(__CFRunLoop **)(a1 + 80);
    if (v26)
    {
      CFDictionaryRef v27 = *(const __CFString **)(a1 + 88);
      if (v27)
      {
        CFRunLoopAddSource(v26, v25, v27);
        CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 128));
        CFRunLoopWakeUp(*(CFRunLoopRef *)(a1 + 80));
      }
    }
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

void __IOHIDManagerDeviceRemoved(uint64_t a1, io_registry_entry_t entry, int a3)
{
  uint64_t v14 = 0;
  CFTypeID v15 = &v14;
  uint64_t v16 = 0x2000000000;
  uint64_t v17 = 0;
  uint64_t entryID = 0;
  IORegistryEntryGetRegistryEntryID(entry, &entryID);
  if (a3 == -536870896)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFSetRef v5 = *(const __CFSet **)(a1 + 32);
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 0x40000000;
    void context[2] = ____IOHIDManagerDeviceRemoved_block_invoke;
    void context[3] = &unk_1E5489F28;
    context[4] = &v14;
    void context[5] = entryID;
    _IOHIDCFSetApplyBlock(v5, context);
    int v6 = (const void *)v15[3];
    if (!v6)
    {
LABEL_17:
      os_unfair_recursive_lock_unlock();
      goto LABEL_18;
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), v6);
    uint64_t v7 = *(__CFDictionary **)(a1 + 64);
    if (v7) {
      CFDictionaryRemoveValue(v7, (const void *)v15[3]);
    }
    if ((*(_DWORD *)(a1 + 152) & 5) == 1 && CFSetContainsValue(*(CFSetRef *)(a1 + 32), (const void *)v15[3])) {
      __IOHIDDeviceSaveProperties(v15[3], 0);
    }
    uint64_t v8 = *(void *)(a1 + 96);
    uint64_t v9 = *(void *)(a1 + 80);
    os_unfair_recursive_lock_unlock();
    if ((*(unsigned char *)(a1 + 152) & 8) == 0 && v8)
    {
      IOHIDDeviceCancel((IOHIDDeviceRef)v15[3]);
      IOHIDDeviceActivate((IOHIDDeviceRef)v15[3]);
    }
    os_unfair_recursive_lock_lock_with_options();
    IOHIDDeviceRef v10 = *(void (**)(void, void, uint64_t, uint64_t))(a1 + 232);
    if (v10)
    {
      if (v9)
      {
LABEL_15:
        v10(*(void *)(a1 + 224), 0, a1, v15[3]);
        goto LABEL_16;
      }
      char v11 = atomic_load((unsigned int *)(a1 + 116));
      if (v11)
      {
        IOHIDDeviceRef v10 = *(void (**)(void, void, uint64_t, uint64_t))(a1 + 232);
        goto LABEL_15;
      }
    }
LABEL_16:
    os_unfair_recursive_lock_unlock();
    os_unfair_recursive_lock_lock_with_options();
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 32), (const void *)v15[3]);
    goto LABEL_17;
  }
LABEL_18:
  _Block_object_dispose(&v14, 8);
}

uint64_t __IOHIDManagerInitialEnumCallback(uint64_t a1)
{
  v7[0] = a1;
  v7[1] = 4;
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v2 = *(void *)(a1 + 216);
  os_unfair_recursive_lock_unlock();
  if (v2)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFSetApplyFunction(*(CFSetRef *)(a1 + 120), (CFSetApplierFunction)__IOHIDManagerDeviceApplier, v7);
    os_unfair_recursive_lock_unlock();
  }
  os_unfair_recursive_lock_lock_with_options();
  CFStringRef v3 = *(__CFRunLoopSource **)(a1 + 128);
  if (v3)
  {
    CFRunLoopSourceInvalidate(v3);
    CFRelease(*(CFTypeRef *)(a1 + 128));
    *(void *)(a1 + 128) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 120);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 120) = 0;
  }
  CFSetRef v5 = *(const void **)(a1 + 136);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 136) = 0;
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDQueueRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDQueueCFTypeID TypeID = result;
  return result;
}

CFTypeID IOHIDQueueGetTypeID(void)
{
  CFTypeID result = __kIOHIDQueueTypeID;
  if (!__kIOHIDQueueTypeID)
  {
    pthread_once(&__queueTypeInit, (void (*)(void))__IOHIDQueueRegister);
    return __kIOHIDQueueTypeID;
  }
  return result;
}

IOHIDQueueRef IOHIDQueueCreate(CFAllocatorRef allocator, IOHIDDeviceRef device, CFIndex depth, IOOptionBits options)
{
  uint64_t v19 = 0;
  if (!device) {
    return 0;
  }
  uint64_t v4 = *(void *)&options;
  uint64_t IOCFPlugInInterface = _IOHIDDeviceGetIOCFPlugInInterface((uint64_t)device);
  if (!IOCFPlugInInterface) {
    return 0;
  }
  uint64_t v9 = IOCFPlugInInterface;
  IOHIDDeviceRef v10 = *(uint64_t (**)(uint64_t, void, void, uint64_t *))(*(void *)IOCFPlugInInterface + 8);
  CFUUIDRef v11 = CFUUIDGetConstantUUIDWithBytes(0, 0x2Eu, 0xC7u, 0x8Bu, 0xDBu, 0x9Fu, 0x4Eu, 0x11u, 0xDAu, 0xB6u, 0x5Cu, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
  CFUUIDBytes v12 = CFUUIDGetUUIDBytes(v11);
  int v13 = v10(v9, *(void *)&v12.byte0, *(void *)&v12.byte8, &v19);
  uint64_t Instance = 0;
  if (v13) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = v19 == 0;
  }
  if (!v15)
  {
    uint64_t v16 = __kIOHIDQueueTypeID;
    if (!__kIOHIDQueueTypeID)
    {
      pthread_once(&__queueTypeInit, (void (*)(void))__IOHIDQueueRegister);
      uint64_t v16 = __kIOHIDQueueTypeID;
    }
    uint64_t Instance = (__IOHIDQueue *)_IOHIDObjectCreateInstance((uint64_t)allocator, v16, 0xB8uLL);
    uint64_t v17 = v19;
    if (Instance)
    {
      *((void *)Instance + 22) = device;
      *((void *)Instance + 3) = v17;
      *((void *)Instance + 4) = v9;
      (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
      (*(void (**)(void, CFIndex, uint64_t))(**((void **)Instance + 3) + 40))(*((void *)Instance + 3), depth, v4);
    }
    else
    {
      (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
    }
  }
  return Instance;
}

IOHIDDeviceRef IOHIDQueueGetDevice(IOHIDQueueRef queue)
{
  return (IOHIDDeviceRef)*((void *)queue + 22);
}

CFIndex IOHIDQueueGetDepth(IOHIDQueueRef queue)
{
  unsigned int v2 = 0;
  (*(void (**)(void, unsigned int *))(**((void **)queue + 3) + 48))(*((void *)queue + 3), &v2);
  return v2;
}

void IOHIDQueueSetDepth(IOHIDQueueRef queue, CFIndex depth)
{
}

void IOHIDQueueAddElement(IOHIDQueueRef queue, IOHIDElementRef element)
{
  (*(void (**)(void, IOHIDElementRef, void))(**((void **)queue + 3) + 56))(*((void *)queue + 3), element, 0);
  CFDictionaryRef Mutable = (__CFSet *)*((void *)queue + 24);
  if (Mutable
    || (CFAllocatorRef v5 = CFGetAllocator(queue),
        CFDictionaryRef Mutable = CFSetCreateMutable(v5, 0, MEMORY[0x1E4F1D548]),
        (*((void *)queue + 24) = Mutable) != 0))
  {
    CFSetAddValue(Mutable, element);
  }
}

void IOHIDQueueRemoveElement(IOHIDQueueRef queue, IOHIDElementRef element)
{
  (*(void (**)(void, IOHIDElementRef, void))(**((void **)queue + 3) + 64))(*((void *)queue + 3), element, 0);
  uint64_t v4 = (__CFSet *)*((void *)queue + 24);
  if (v4)
  {
    CFSetRemoveValue(v4, element);
  }
}

Boolean IOHIDQueueContainsElement(IOHIDQueueRef queue, IOHIDElementRef element)
{
  Boolean v3 = 0;
  (*(void (**)(void, IOHIDElementRef, Boolean *, void))(**((void **)queue + 3) + 72))(*((void *)queue + 3), element, &v3, 0);
  return v3;
}

void IOHIDQueueStart(IOHIDQueueRef queue)
{
}

void IOHIDQueueStop(IOHIDQueueRef queue)
{
}

void IOHIDQueueScheduleWithRunLoop(IOHIDQueueRef queue, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!__IOHIDQueueSetupAsyncSupport((uint64_t)queue)) {
    IOHIDQueueScheduleWithRunLoop_cold_1(&v7, v8);
  }
  *((void *)queue + 16) = runLoop;
  *((void *)queue + 17) = runLoopMode;
  int v6 = (__CFRunLoopSource *)*((void *)queue + 5);

  CFRunLoopAddSource(runLoop, v6, runLoopMode);
}

BOOL __IOHIDQueueSetupAsyncSupport(uint64_t a1)
{
  memset(&v9.info, 0, 72);
  v9.version = 1;
  if (*(void *)(a1 + 128) || *(void *)(a1 + 144)) {
    __IOHIDQueueSetupAsyncSupport_cold_1();
  }
  if (*(void *)(a1 + 40)) {
    return 1;
  }
  int v2 = (*(uint64_t (**)(void, void (__cdecl **)(void *)))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24), &v9.perform);
  perform = v9.perform;
  if (v2) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v9.perform == 0;
  }
  if (v4) {
    return 0;
  }
  *(void *)(a1 + 4(*(void (**)(void, void))(**((void **)queue + 3) + 88))(*((void *)queue + 3), 0) = v9.perform;
  CFRunLoopSourceGetContext((CFRunLoopSourceRef)perform, &v9);
  long long v5 = *(_OWORD *)&v9.retain;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)&v9.version;
  *(_OWORD *)(a1 + 64) = v5;
  long long v6 = *(_OWORD *)&v9.hash;
  *(_OWORD *)(a1 + 8(*(void (**)(void, void))(**((void **)queue + 3) + 88))(*((void *)queue + 3), 0) = *(_OWORD *)&v9.copyDescription;
  *(_OWORD *)(a1 + 96) = v6;
  uint64_t v7 = *(void *)(a1 + 56);
  *(void *)(a1 + 112) = v9.cancel;
  *(void *)(a1 + 12(*(void (**)(void, void))(**((void **)queue + 3) + 88))(*((void *)queue + 3), 0) = v7;
  return v7 != 0;
}

void IOHIDQueueUnscheduleFromRunLoop(IOHIDQueueRef queue, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  long long v5 = (void *)((char *)queue + 128);
  BOOL v4 = (__CFRunLoop *)*((void *)queue + 16);
  if (v4)
  {
    CFRunLoopRemoveSource(v4, *((CFRunLoopSourceRef *)queue + 5), *((CFRunLoopMode *)queue + 17));
    *long long v5 = 0;
    v5[1] = 0;
  }
}

void IOHIDQueueSetDispatchQueue(IOHIDQueueRef queue, dispatch_queue_t dispatchQueue)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!__IOHIDQueueSetupAsyncSupport((uint64_t)queue)) {
    IOHIDQueueScheduleWithRunLoop_cold_1(&v8, __str);
  }
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)__str = 0u;
  long long v10 = 0u;
  label = dispatch_queue_get_label(dispatchQueue);
  long long v5 = "";
  if (label) {
    long long v5 = label;
  }
  snprintf(__str, 0x100uLL, "%s.IOHIDQueueRef", v5);
  dispatch_queue_t v6 = dispatch_queue_create_with_target_V2(__str, 0, dispatchQueue);
  *((void *)queue + 18) = v6;
  if (v6)
  {
    _IOHIDObjectInternalRetain(queue);
    uint64_t v7 = dispatch_mach_create();
    *((void *)queue + 19) = v7;
    if (!v7) {
      _IOHIDObjectInternalRelease(queue);
    }
  }
}

uint64_t __IOHIDQueueSetDispatchQueue_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (a2 == 8)
  {
    dispatch_release(*(dispatch_object_t *)(*(void *)(result + 32) + 152));
    *(void *)(*(void *)(v2 + 32) + 152) = 0;
    uint64_t v4 = *(void *)(v2 + 32);
    uint64_t v5 = *(void *)(v4 + 160);
    if (v5)
    {
      (*(void (**)(void))(v5 + 16))();
      _Block_release(*(const void **)(*(void *)(v2 + 32) + 160));
      uint64_t v4 = *(void *)(v2 + 32);
      *(void *)(v4 + 16(*(void (**)(void, void))(**((void **)queue + 3) + 88))(*((void *)queue + 3), 0) = 0;
    }
    dispatch_release(*(dispatch_object_t *)(v4 + 144));
    dispatch_queue_t v6 = *(const void **)(v2 + 32);
    return _IOHIDObjectInternalRelease(v6);
  }
  else if (a2 == 2)
  {
    uint64_t msg = dispatch_mach_msg_get_msg();
    return (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)(v2 + 32) + 112))(msg, 0, 0, *(void *)(*(void *)(v2 + 32) + 120));
  }
  return result;
}

void IOHIDQueueSetCancelHandler(IOHIDQueueRef queue, dispatch_block_t handler)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (!handler || *((void *)queue + 20)) {
    IOHIDQueueSetCancelHandler_cold_1(&v2, v3);
  }
  *((void *)queue + 2(*(void (**)(void, void))(**((void **)queue + 3) + 88))(*((void *)queue + 3), 0) = _Block_copy(handler);
}

void IOHIDQueueActivate(IOHIDQueueRef queue)
{
  if (*((void *)queue + 18)) {
    BOOL v1 = *((void *)queue + 16) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    queue = (IOHIDQueueRef)_os_crash_msg();
    __break(1u);
  }
  IOHIDQueueRef v2 = queue;
  if ((atomic_fetch_or((atomic_uint *volatile)queue + 42, 1u) & 1) == 0)
  {
    CFMachPortGetPort(*((CFMachPortRef *)queue + 15));
    dispatch_mach_connect();
    Boolean v3 = *(void (**)(void))(**((void **)v2 + 3) + 80);
    v3();
  }
}

void IOHIDQueueCancel(IOHIDQueueRef queue)
{
  if (*((void *)queue + 18)) {
    BOOL v1 = *((void *)queue + 16) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    queue = (IOHIDQueueRef)_os_crash_msg();
    __break(1u);
  }
  if ((atomic_fetch_or((atomic_uint *volatile)queue + 42, 2u) & 2) == 0)
  {
    (*(void (**)(void, void))(**((void **)queue + 3) + 88))(*((void *)queue + 3), 0);
    dispatch_mach_cancel();
  }
}

void IOHIDQueueRegisterValueAvailableCallback(IOHIDQueueRef queue, IOHIDCallback callback, void *context)
{
  if (atomic_load((unsigned int *)queue + 42)) {
    IOHIDQueueRegisterValueAvailableCallback_cold_3();
  }
  if (callback)
  {
    CFDictionaryRef Mutable = (__CFDictionary *)*((void *)queue + 23);
    if (Mutable
      || (CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, 0, 0), (*((void *)queue + 23) = Mutable) != 0))
    {
      CFDictionarySetValue(Mutable, callback, context);
      uint64_t v8 = *(void (**)(void))(**((void **)queue + 3) + 96);
      v8();
    }
    else
    {
      long long v10 = _IOHIDLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        IOHIDQueueRegisterValueAvailableCallback_cold_2(v10);
      }
    }
  }
  else
  {
    CFRunLoopSourceContext v9 = _IOHIDLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      IOHIDQueueRegisterValueAvailableCallback_cold_1(v9);
    }
  }
}

void __IOHIDQueueValueAvailableCallback(CFDictionaryRef *cf, unsigned int a2)
{
  if (cf)
  {
    if (cf[23])
    {
      v3[1] = cf;
      v3[0] = a2;
      CFRetain(cf);
      CFDictionaryApplyFunction(cf[23], (CFDictionaryApplierFunction)_IOHIDCallbackApplier, v3);
      CFRelease(cf);
    }
  }
}

IOHIDValueRef IOHIDQueueCopyNextValue(IOHIDQueueRef queue)
{
  IOHIDQueueRef v2 = 0;
  (*(void (**)(void, __IOHIDValue **, void, void))(**((void **)queue + 3) + 104))(*((void *)queue + 3), &v2, 0, 0);
  return v2;
}

IOHIDValueRef IOHIDQueueCopyNextValueWithTimeout(IOHIDQueueRef queue, CFTimeInterval timeout)
{
  Boolean v3 = 0;
  (*(void (**)(void, __IOHIDValue **, void, void))(**((void **)queue + 3) + 104))(*((void *)queue + 3), &v3, (timeout * 1000.0), 0);
  return v3;
}

CFArrayRef _IOHIDQueueCopyElements(CFSetRef *a1)
{
  CFSetRef v2 = a1[24];
  if (!v2) {
    return 0;
  }
  CFIndex Count = CFSetGetCount(v2);
  if (!Count) {
    return 0;
  }
  CFIndex v4 = Count;
  size_t v5 = 8 * Count;
  dispatch_queue_t v6 = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  bzero(v6, v5);
  CFSetGetValues(a1[24], (const void **)v6);
  CFAllocatorRef v7 = CFGetAllocator(a1);
  CFArrayRef v8 = CFArrayCreate(v7, (const void **)v6, v4, MEMORY[0x1E4F1D510]);
  free(v6);
  return v8;
}

void __IOHIDQueueExtRelease(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 144))
  {
    unsigned int v2 = atomic_load((unsigned int *)(a1 + 168));
    if (v2 != 3) {
      __IOHIDManagerExtRelease_cold_1(&v5, v6, (unsigned int *)(a1 + 168));
    }
  }
  Boolean v3 = *(const void **)(a1 + 192);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 192) = 0;
  }
  if (*(void *)(a1 + 176)) {
    *(void *)(a1 + 176) = 0;
  }
  CFIndex v4 = *(const void **)(a1 + 184);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 184) = 0;
  }
}

uint64_t __IOHIDQueueIntRelease(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t __IOHIDTransactionRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDTransactionCFTypeID TypeID = result;
  return result;
}

CFTypeID IOHIDTransactionGetTypeID(void)
{
  CFTypeID result = __kIOHIDTransactionTypeID;
  if (!__kIOHIDTransactionTypeID)
  {
    pthread_once(&__transactionTypeInit, (void (*)(void))__IOHIDTransactionRegister);
    return __kIOHIDTransactionTypeID;
  }
  return result;
}

IOHIDTransactionRef IOHIDTransactionCreate(CFAllocatorRef allocator, IOHIDDeviceRef device, IOHIDTransactionDirectionType direction, IOOptionBits options)
{
  uint64_t v18 = 0;
  if (!device) {
    return 0;
  }
  uint64_t v4 = *(void *)&options;
  uint64_t v5 = *(void *)&direction;
  dispatch_queue_t v6 = device;
  uint64_t IOCFPlugInInterface = _IOHIDDeviceGetIOCFPlugInInterface((uint64_t)device);
  uint64_t Instance = IOCFPlugInInterface;
  if (IOCFPlugInInterface)
  {
    long long v10 = *(uint64_t (**)(uint64_t, void, void, uint64_t *))(*(void *)IOCFPlugInInterface + 8);
    CFUUIDRef v11 = CFUUIDGetConstantUUIDWithBytes(0, 0x1Fu, 0x2Eu, 0x78u, 0xFAu, 0x9Fu, 0xFAu, 0x11u, 0xDAu, 0x90u, 0xB4u, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
    CFUUIDBytes v12 = CFUUIDGetUUIDBytes(v11);
    int v13 = v10(Instance, *(void *)&v12.byte0, *(void *)&v12.byte8, &v18);
    uint64_t Instance = 0;
    if (!v13 && v18 != 0)
    {
      uint64_t v15 = __kIOHIDTransactionTypeID;
      if (!__kIOHIDTransactionTypeID)
      {
        pthread_once(&__transactionTypeInit, (void (*)(void))__IOHIDTransactionRegister);
        uint64_t v15 = __kIOHIDTransactionTypeID;
      }
      uint64_t Instance = _IOHIDObjectCreateInstance((uint64_t)allocator, v15, 0x38uLL);
      uint64_t v16 = v18;
      if (Instance)
      {
        *(void *)(Instance + 24) = v18;
        *(_DWORD *)(Instance + 64) = v4;
        if ((v4 & 1) == 0)
        {
          dispatch_queue_t v6 = CFRetain(v6);
          uint64_t v16 = *(void *)(Instance + 24);
        }
        *(void *)(Instance + 56) = v6;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 40))(v16, v5, v4);
      }
      else
      {
        (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
      }
    }
  }
  return (IOHIDTransactionRef)Instance;
}

IOHIDDeviceRef IOHIDTransactionGetDevice(IOHIDTransactionRef transaction)
{
  return (IOHIDDeviceRef)*((void *)transaction + 7);
}

IOHIDTransactionDirectionType IOHIDTransactionGetDirection(IOHIDTransactionRef transaction)
{
  IOHIDTransactionDirectionType v2 = kIOHIDTransactionDirectionTypeInput;
  (*(void (**)(void, IOHIDTransactionDirectionType *))(**((void **)transaction + 3) + 48))(*((void *)transaction + 3), &v2);
  return v2;
}

void IOHIDTransactionSetDirection(IOHIDTransactionRef transaction, IOHIDTransactionDirectionType direction)
{
}

void IOHIDTransactionAddElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
}

void IOHIDTransactionRemoveElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
}

Boolean IOHIDTransactionContainsElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
  Boolean v3 = 0;
  (*(void (**)(void, IOHIDElementRef, Boolean *, void))(**((void **)transaction + 3) + 72))(*((void *)transaction + 3), element, &v3, 0);
  return v3;
}

void IOHIDTransactionScheduleWithRunLoop(IOHIDTransactionRef transaction, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v7 = (CFTypeRef *)((char *)transaction + 32);
  CFTypeRef v6 = (CFTypeRef)*((void *)transaction + 4);
  if (v6
    || !(*(unsigned int (**)(void, CFTypeRef *))(**((void **)transaction + 3) + 32))(*((void *)transaction + 3), v7)&& (CFTypeRef v6 = *v7) != 0)
  {
    *((void *)transaction + 5) = runLoop;
    *((void *)transaction + 6) = runLoopMode;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFRunLoopSourceGetTypeID())
    {
      long long v10 = (__CFRunLoopSource *)*((void *)transaction + 4);
      CFRunLoopSourceContext v9 = (__CFRunLoop *)*((void *)transaction + 5);
      CFStringRef v11 = (const __CFString *)*((void *)transaction + 6);
      CFRunLoopAddSource(v9, v10, v11);
    }
    else
    {
      CFTypeID v12 = CFGetTypeID(*v7);
      if (v12 == CFRunLoopTimerGetTypeID())
      {
        long long v14 = (__CFRunLoopTimer *)*((void *)transaction + 4);
        int v13 = (__CFRunLoop *)*((void *)transaction + 5);
        CFStringRef v15 = (const __CFString *)*((void *)transaction + 6);
        CFRunLoopAddTimer(v13, v14, v15);
      }
    }
  }
}

void IOHIDTransactionUnscheduleFromRunLoop(IOHIDTransactionRef transaction, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v4 = (const void *)*((void *)transaction + 4);
  if (v4)
  {
    CFTypeID v7 = CFGetTypeID(v4);
    if (v7 == CFRunLoopSourceGetTypeID())
    {
      CFRunLoopRemoveSource(runLoop, *((CFRunLoopSourceRef *)transaction + 4), runLoopMode);
    }
    else
    {
      CFTypeID v8 = CFGetTypeID(*((CFTypeRef *)transaction + 4));
      if (v8 == CFRunLoopTimerGetTypeID()) {
        CFRunLoopRemoveTimer(runLoop, *((CFRunLoopTimerRef *)transaction + 4), runLoopMode);
      }
    }
    *((void *)transaction + 5) = 0;
    *((void *)transaction + 6) = 0;
  }
}

void IOHIDTransactionSetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOHIDValueRef value, IOOptionBits options)
{
}

IOHIDValueRef IOHIDTransactionGetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOOptionBits options)
{
  uint64_t v4 = 0;
  if ((*(unsigned int (**)(void, IOHIDElementRef, __IOHIDValue **, void))(**((void **)transaction + 3)
                                                                                        + 88))(*((void *)transaction + 3), element, &v4, *(void *)&options))
  {
    return 0;
  }
  else
  {
    return v4;
  }
}

IOReturn IOHIDTransactionCommit(IOHIDTransactionRef transaction)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**((void **)transaction + 3) + 96))(*((void *)transaction + 3), 0, 0, 0, 0);
}

IOReturn IOHIDTransactionCommitWithCallback(IOHIDTransactionRef transaction, CFTimeInterval timeout, IOHIDCallback callback, void *context)
{
  CFTypeID v8 = malloc_type_malloc(0x18uLL, 0xA0040114AFA65uLL);
  if (!v8) {
    return -536870211;
  }
  CFRunLoopSourceContext v9 = v8;
  void *v8 = context;
  v8[1] = callback;
  void v8[2] = transaction;
  IOReturn v10 = (*(uint64_t (**)(void, void, void (*)(void *, uint64_t, uint64_t), void *, void))(**((void **)transaction + 3) + 96))(*((void *)transaction + 3), timeout, __IOHIDTransactionCommitCallback, v8, 0);
  if (v10) {
    free(v9);
  }
  return v10;
}

void __IOHIDTransactionCommitCallback(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (*(void *)(a1[2] + 24) == a3)
    {
      uint64_t v4 = (void (*)(void))a1[1];
      if (v4) {
        v4(*a1);
      }
    }
    free(a1);
  }
}

void IOHIDTransactionClear(IOHIDTransactionRef transaction)
{
}

void __IOHIDTransactionIntRelease(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *(void *)(a1 + 24) = 0;
  }
  if ((*(unsigned char *)(a1 + 64) & 1) == 0)
  {
    Boolean v3 = *(const void **)(a1 + 56);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 56) = 0;
    }
  }
}

BOOL _IOHIDEventEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
      && *(void *)(a1 + 24) == *(void *)(a2 + 24)
      && (v4 = *(unsigned int **)(a1 + 104), v5 = *v4, CFTypeRef v6 = *(_DWORD **)(a2 + 104), v5 == *v6))
    {
      return memcmp(v4, v6, v5) == 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFString *IOHIDEventCopyDescription(uint64_t a1)
{
  return __IOHIDEventEventCopyDebugDescWithIndentLevel(a1, 0);
}

__CFString *__IOHIDEventEventCopyDebugDescWithIndentLevel(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  uint64_t v3 = *(unsigned int *)(v2 + 4);
  if (v3 > 0x2A) {
    return 0;
  }
  Name = IOHIDEventTypeGetName(*(_DWORD *)(v2 + 4));
  CFTypeID v7 = (void (*)(uint64_t, __CFString *, uint64_t))__descriptorCallbacks[v3];
  unint64_t Latency = IOHIDEventGetLatency(a1, 0x3E8u);
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  IOReturn v10 = Mutable;
  if (Mutable)
  {
    if (a2)
    {
      CFStringRef v11 = @"-----------------------------------------------------------------------\n";
      _IOHIDStringAppendIndendationAndFormat(Mutable, a2, @"-----------------------------------------------------------------------\n");
    }
    else
    {
      CFStringRef v11 = @"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
      _IOHIDStringAppendIndendationAndFormat(Mutable, 0, @"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    }
    if (!a2)
    {
      unint64_t v20 = *(void *)(a1 + 16);
      uint64_t v21 = (*(unsigned char *)(a1 + 32) & 0x80) != 0 ? *(void *)(a1 + 8) : IOHIDEventGetTimeStamp(a1);
      _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s %llu\n", "Timestamp:", v21);
      long long v22 = (*(_DWORD *)(a1 + 32) & 0x80) != 0 ? "Continuous" : "Absolute";
      _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s %s\n", "Timestamp type:", v22);
      _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s %llu us\n", "Total Latency:", Latency);
      if (v20 >> 33)
      {
        _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%c[1m", 27);
        _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s 0x%016llX NON KERNEL SENDER\n", "SenderID:", v20);
        _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%c[0m", 27, v25);
      }
      else
      {
        _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s 0x%016llX\n", "SenderID:", v20);
      }
      _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s %ld\n", "BuiltIn:", ((unint64_t)*(unsigned __int8 *)(*(void *)(a1 + 104) + 8) >> 4) & 1);
      if (*(void *)(a1 + 40))
      {
        uint64_t v23 = *(void *)(a1 + 88);
        if (v23)
        {
          _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s %ld\n", "AttributeDataLength:", v23);
          _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%-20.20s ", "AttributeData:");
          if (*(uint64_t *)(a1 + 88) >= 1)
          {
            uint64_t v24 = 0;
            do
              _IOHIDStringAppendIndendationAndFormat(v10, 0, @"%02x ", *(unsigned __int8 *)(*(void *)(a1 + 40) + v24++));
            while (v24 < *(void *)(a1 + 88));
          }
          _IOHIDStringAppendIndendationAndFormat(v10, 0, @"\n");
        }
      }
    }
    if (*(_DWORD *)(*(void *)(a1 + 104) + 8)) {
      CFTypeID v12 = "Absolute";
    }
    else {
      CFTypeID v12 = "Relative";
    }
    _IOHIDStringAppendIndendationAndFormat(v10, a2, @"%-20.20s %s\n", "ValueType:", v12);
    _IOHIDStringAppendIndendationAndFormat(v10, a2, @"%-20.20s %@\n", "EventType:", Name);
    _IOHIDStringAppendIndendationAndFormat(v10, a2, @"%-20.20s 0x%x\n", "Flags:", *(unsigned int *)(*(void *)(a1 + 104) + 8));
    if (((0x12004400001uLL >> v3) & 1) == 0) {
      v7(a1, v10, a2);
    }
    if (*(void *)(a1 + 72))
    {
      _IOHIDStringAppendIndendationAndFormat(v10, a2, @"%-20.20s\n", "ChildEvents:");
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
      if (Count >= 1)
      {
        CFIndex v14 = Count;
        for (CFIndex i = 0; i != v14; ++i)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
          if (ValueAtIndex)
          {
            CFStringRef v17 = (const __CFString *)__IOHIDEventEventCopyDebugDescWithIndentLevel(ValueAtIndex, a2 + 1);
            if (v17)
            {
              CFStringRef v18 = v17;
              CFStringAppend(v10, v17);
              CFRelease(v18);
            }
          }
        }
      }
    }
    _IOHIDStringAppendIndendationAndFormat(v10, a2, v11);
  }
  return v10;
}

void _IOHIDEventRemoveAttachment(uint64_t a1, const void *a2)
{
  if (a1 && a2)
  {
    uint64_t v2 = *(__CFDictionary **)(a1 + 56);
    if (v2) {
      CFDictionaryRemoveValue(v2, a2);
    }
  }
}

uint64_t _IOHIDEventSetContext(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = a2;
  return result;
}

uint64_t _IOHIDEventGetContext(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t IOHIDEventSetTimeStampOfType(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v5 = result;
  if (dynLinkrosetta_is_current_process_translated_0[0])
  {
    BOOL result = dynLinkrosetta_is_current_process_translated_0[0]();
    if (result)
    {
      if (dynLinkrosetta_convert_to_system_absolute_time_0[0])
      {
        BOOL result = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(a2);
        a2 = result;
      }
    }
  }
  *(void *)(v5 + 8) = a2;
  if (a3 == 1)
  {
    unsigned int v6 = *(_DWORD *)(v5 + 32) | 0x80;
  }
  else
  {
    if (a3) {
      return result;
    }
    unsigned int v6 = *(_DWORD *)(v5 + 32) & 0xFFFFFF7F;
  }
  *(_DWORD *)(v5 + 32) = v6;
  return result;
}

uint64_t IOHIDEventCreateKeyboardEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, int a6)
{
  uint64_t result = IOHIDEventCreate(a1, 3, a2, a6 | 1u);
  if (result)
  {
    uint64_t v10 = *(void *)(result + 104);
    *(_WORD *)(v10 + 16) = a3;
    *(_WORD *)(v10 + 18) = a4;
    *(_DWORD *)(v10 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a5;
    *(unsigned char *)(v10 + 28) = 1;
  }
  return result;
}

uint64_t IOHIDEventCreateUnicodeEvent(uint64_t a1, uint64_t a2, const void *a3, size_t a4, int a5, int a6)
{
  return IOHIDEventCreateUnicodeEventWithQuality(a1, a2, a3, a4, a5, a6, 1.0);
}

uint64_t IOHIDEventCreateUnicodeEventWithQuality(uint64_t a1, uint64_t a2, const void *a3, size_t a4, int a5, int a6, double a7)
{
  uint64_t v11 = a2;
  uint64_t v12 = _IOHIDEventCreate(a1, a4 + 28, 30, a2, a6 | 1u);
  if (v12)
  {
    if (dynLinkrosetta_is_current_process_translated_0[0]
      && dynLinkrosetta_is_current_process_translated_0[0]()
      && dynLinkrosetta_convert_to_system_absolute_time_0[0])
    {
      uint64_t v11 = ((uint64_t (*)(uint64_t))dynLinkrosetta_convert_to_system_absolute_time_0[0])(v11);
    }
    *(void *)(v12 + 8) = v11;
    int v13 = *(_DWORD **)(v12 + 104);
    v13[4] = a5;
    void v13[5] = vcvtd_n_s64_f64(a7, 0x10uLL);
    void v13[6] = a4;
    memmove(v13 + 7, a3, a4);
  }
  return v12;
}

uint64_t IOHIDEventCreateButtonEvent(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result = IOHIDEventCreate(a1, 2, a2, a4 | 1u);
  if (result)
  {
    uint64_t v6 = *(void *)(result + 104);
    *(_WORD *)(v6 + 24) = 256;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 16) = a3;
    *(_DWORD *)(v6 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0x10000;
  }
  return result;
}

uint64_t __IOHIDEventCreateButtonEvent(uint64_t a1, uint64_t a2, int a3, char a4, int a5, int a6, double a7)
{
  uint64_t result = IOHIDEventCreate(a1, 2, a2, a6 | 1u);
  if (result)
  {
    uint64_t v12 = *(void *)(result + 104);
    *(unsigned char *)(v12 + 24) = a4;
    *(_DWORD *)(v12 + 28) = a5;
    *(_DWORD *)(v12 + 16) = a3;
    *(_DWORD *)(v12 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a7, 0x10uLL);
    *(unsigned char *)(v12 + 25) = 1;
  }
  return result;
}

uint64_t IOHIDEventCreateButtonEventWithPressure(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  return __IOHIDEventCreateButtonEvent(a1, a2, a3, 0, 0, a4, a5);
}

void *IOHIDEventCreateMouseEvent(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, double a5, double a6, double a7)
{
  return IOHIDEventCreateRelativePointerEvent(a1, a2, a3, a3, a4, a5, a6, a7);
}

void *IOHIDEventCreateRelativePointerEvent(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, double a6, double a7, double a8)
{
  CFStringRef v15 = (void *)IOHIDEventCreate(a1, 17, a2, a5);
  uint64_t v16 = v15;
  if (v15)
  {
    uint64_t v17 = v15[13];
    if (v17)
    {
      uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(v15, 17, 4026531840);
      if (EventWithOptions) {
        *(_DWORD *)(*(void *)(EventWithOptions + 104) + 16) = vcvtd_n_s64_f64(a6, 0x10uLL);
      }
      uint64_t v19 = IOHIDEventGetEventWithOptions(v16, 17, 4026531840);
      if (v19) {
        *(_DWORD *)(*(void *)(v19 + 104) + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a7, 0x10uLL);
      }
      uint64_t v20 = IOHIDEventGetEventWithOptions(v16, 17, 4026531840);
      if (v20) {
        *(_DWORD *)(*(void *)(v20 + 104) + 24) = vcvtd_n_s64_f64(a8, 0x10uLL);
      }
      *(_DWORD *)(v17 + 28) = a3;
      unsigned int v21 = a4 ^ a3;
      if (a4 != a3)
      {
        do
        {
          if (v21)
          {
            if (a3) {
              double v22 = 1.0;
            }
            else {
              double v22 = 0.0;
            }
            ButtonEvent = (void *)__IOHIDEventCreateButtonEvent(a1, a2, *(_DWORD *)(v17 + 28), 1, a3 & 1, 0, v22);
            if (ButtonEvent)
            {
              uint64_t v24 = ButtonEvent;
              IOHIDEventAppendEvent((uint64_t)v16, ButtonEvent);
              CFRelease(v24);
            }
          }
          a3 >>= 1;
          BOOL v25 = v21 >= 2;
          v21 >>= 1;
        }
        while (v25);
      }
    }
    else
    {
      CFRelease(v15);
      return 0;
    }
  }
  return v16;
}

void *IOHIDEventCreateTranslationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  CFRunLoopSourceContext v9 = (void *)IOHIDEventCreate(a1, 4, a2, a3);
  uint64_t v10 = v9;
  if (v9)
  {
    uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(v9, 4, 4026531840);
    if (EventWithOptions) {
      *(_DWORD *)(*(void *)(EventWithOptions + 104) + 16) = vcvtd_n_s64_f64(a4, 0x10uLL);
    }
    uint64_t v12 = IOHIDEventGetEventWithOptions(v10, 4, 4026531840);
    if (v12) {
      *(_DWORD *)(*(void *)(v12 + 104) + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a5, 0x10uLL);
    }
    uint64_t v13 = IOHIDEventGetEventWithOptions(v10, 4, 4026531840);
    if (v13) {
      *(_DWORD *)(*(void *)(v13 + 104) + 24) = vcvtd_n_s64_f64(a6, 0x10uLL);
    }
  }
  return v10;
}

uint64_t IOHIDEventCreateRotationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 5, a3, a4, a5, a6);
}

uint64_t __IOHIDEventCreateAxisEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, double a6, double a7)
{
  uint64_t result = IOHIDEventCreate(a1, a3, a2, a4);
  if (result)
  {
    uint64_t v11 = *(_DWORD **)(result + 104);
    v11[4] = vcvtd_n_s64_f64(a5, 0x10uLL);
    _OWORD v11[5] = vcvtd_n_s64_f64(a6, 0x10uLL);
    v11[6] = vcvtd_n_s64_f64(a7, 0x10uLL);
  }
  return result;
}

uint64_t IOHIDEventCreateScrollEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 6, a3, a4, a5, a6);
}

uint64_t IOHIDEventCreateScaleEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 7, a3, a4, a5, a6);
}

uint64_t IOHIDEventCreateVelocityEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateAxisEvent(a1, a2, 9, a3, a4, a5, a6);
}

uint64_t IOHIDEventCreateDeviceOrientationEventWithUsage(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result = IOHIDEventCreate(a1, 10, a2, a4);
  if (result)
  {
    uint64_t v6 = *(void *)(result + 104);
    *(_DWORD *)(v6 + 32) = 1;
    *(_DWORD *)(v6 + 16) = a3;
  }
  return result;
}

uint64_t IOHIDEventCreatePolarOrientationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  uint64_t result = IOHIDEventCreate(a1, 10, a2, a3);
  if (result)
  {
    uint64_t v10 = *(_DWORD **)(result + 104);
    v10[4] = vcvtd_n_s64_f64(a4, 0x10uLL);
    _OWORD v10[5] = vcvtd_n_s64_f64(a5, 0x10uLL);
    v10[6] = vcvtd_n_s64_f64(a6, 0x10uLL);
    v10[8] = 0;
  }
  return result;
}

uint64_t IOHIDEventCreateQuaternionOrientationEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  uint64_t result = IOHIDEventCreate(a1, 10, a2, a3);
  if (result)
  {
    uint64_t v12 = *(_DWORD **)(result + 104);
    v12[4] = vcvtd_n_s64_f64(a4, 0x10uLL);
    _OWORD v12[5] = vcvtd_n_s64_f64(a5, 0x10uLL);
    void v12[6] = vcvtd_n_s64_f64(a6, 0x10uLL);
    v12[7] = vcvtd_n_s64_f64(a7, 0x10uLL);
    v12[8] = 3;
  }
  return result;
}

uint64_t IOHIDEventCreateAccelerometerEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 13, 0, 0, 0, a3, a4, a5, a6);
}

uint64_t IOHIDEventCreateAccelerometerEventWithType(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, double a7, double a8, double a9)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 13, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t __IOHIDEventCreateMotionEvent(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7, double a8, double a9, double a10)
{
  uint64_t result = IOHIDEventCreate(a1, a3, a2, a7);
  if (result)
  {
    uint64_t v17 = *(_DWORD **)(result + 104);
    v17[4] = vcvtd_n_s64_f64(a8, 0x10uLL);
    void v17[5] = vcvtd_n_s64_f64(a9, 0x10uLL);
    v17[6] = vcvtd_n_s64_f64(a10, 0x10uLL);
    v17[7] = a4;
    v17[8] = a5;
    v17[9] = a6;
  }
  return result;
}

uint64_t IOHIDEventCreateGyroEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 20, 0, 0, 0, a3, a4, a5, a6);
}

uint64_t IOHIDEventCreateGyroEventWithType(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, double a7, double a8, double a9)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 20, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t IOHIDEventCreateCompassEvent(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 21, 0, 0, 0, a3, a4, a5, a6);
}

uint64_t IOHIDEventCreateCompassEventWithType(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, double a7, double a8, double a9)
{
  return __IOHIDEventCreateMotionEvent(a1, a2, 21, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t IOHIDEventCreateAmbientLightSensorEvent(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result = IOHIDEventCreate(a1, 12, a2, a4 | 1u);
  if (result) {
    *(_DWORD *)(*(void *)(result + 104) + 16) = a3;
  }
  return result;
}

uint64_t IOHIDEventCreateProximtyLevelEvent(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5)
{
  uint64_t result = IOHIDEventCreate(a1, 14, a2, a5 | 1u);
  if (result)
  {
    uint64_t v8 = *(void *)(result + 104);
    *(_WORD *)(v8 + 16) = a3;
    *(_WORD *)(v8 + 18) = 0;
    *(_DWORD *)(v8 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a4;
  }
  return result;
}

void *IOHIDEventCreateDigitizerStylusEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, int a17)
{
  int v20 = a17;
  if (a7) {
    int v20 = a17 | 0x10000;
  }
  if (a8) {
    v20 |= 0x40000u;
  }
  DigitizerEvent = IOHIDEventCreateDigitizerEvent(a1, a2, 0, a3, a4, a5, a6, a7, a9, a10, a11, a12, a14, 0, v20);
  double v22 = DigitizerEvent;
  if (DigitizerEvent)
  {
    *(_DWORD *)(DigitizerEvent[13] + 64) = 0;
    uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(DigitizerEvent, 11, 4026531840);
    if (EventWithOptions) {
      *(_DWORD *)(*(void *)(EventWithOptions + 104) + 56) = vcvtd_n_s64_f64(a13, 0x10uLL);
    }
    IOHIDEventSetFloatValueWithOptions(v22, 0xB000Du, 4026531840, a15);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB000Eu, 4026531840, a16);
  }
  return v22;
}

void *IOHIDEventCreateDigitizerStylusEventWithPolarOrientation(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, int a17)
{
  int v20 = a17;
  if (a7) {
    int v20 = a17 | 0x10000;
  }
  if (a8) {
    v20 |= 0x40000u;
  }
  DigitizerEvent = IOHIDEventCreateDigitizerEvent(a1, a2, 0, a3, a4, a5, a6, a7, a9, a10, a11, a12, a14, 0, v20);
  double v22 = DigitizerEvent;
  if (DigitizerEvent)
  {
    *(_DWORD *)(DigitizerEvent[13] + 64) = 1;
    uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(DigitizerEvent, 11, 4026531840);
    if (EventWithOptions) {
      *(_DWORD *)(*(void *)(EventWithOptions + 104) + 56) = vcvtd_n_s64_f64(a13, 0x10uLL);
    }
    IOHIDEventSetFloatValueWithOptions(v22, 0xB000Fu, 4026531840, a15);
    IOHIDEventSetFloatValueWithOptions(v22, 0xB0010u, 4026531840, a16);
  }
  return v22;
}

uint64_t IOHIDEventCreateTouchSensitiveButtonEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, uint64_t a6, double a7, double a8)
{
  uint64_t result = IOHIDEventCreate(a1, 42, a2, a6);
  if (result)
  {
    uint64_t v14 = *(void *)(result + 104);
    *(_WORD *)(v14 + 16) = a3;
    *(_WORD *)(v14 + 18) = a4;
    *(double *)(v14 + 24) = a7;
    *(double *)(v14 + 32) = a8;
    *(unsigned char *)(v14 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a5 != 0;
    int64x2_t v15 = vdupq_n_s64(0x7FF8000000000000uLL);
    *(int64x2_t *)(v14 + 48) = v15;
    *(int64x2_t *)(v14 + 64) = v15;
    *(_DWORD *)(v14 + 44) = 0;
  }
  return result;
}

uint64_t IOHIDEventCreateTouchSensitiveButtonEventWithRadius(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, int a5, int a6, uint64_t a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t result = IOHIDEventCreate(a1, 42, a2, a7);
  if (result)
  {
    uint64_t v24 = *(void *)(result + 104);
    *(double *)(v24 + 48) = a8;
    *(double *)(v24 + 56) = a9;
    *(double *)(v24 + 24) = a10;
    *(double *)(v24 + 32) = a11;
    *(double *)(v24 + 64) = a12;
    *(double *)(v24 + 72) = a13;
    *(_DWORD *)(v24 + 44) = a5;
    *(_WORD *)(v24 + 16) = a3;
    *(_WORD *)(v24 + 18) = a4;
    *(unsigned char *)(v24 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a6 != 0;
  }
  return result;
}

uint64_t IOHIDEventCreateSwipeEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result = IOHIDEventCreate(a1, 16, a2, a4);
  if (result)
  {
    uint64_t v6 = *(void *)(result + 104);
    *(_DWORD *)(v6 + 28) = a3;
    *(void *)(v6 + 16) = 0;
    *(void *)(v6 + 32) = 0;
  }
  return result;
}

uint64_t __IOHIDEventCreateSwipeEventOfTypeWithFlavor(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5, __int16 a6, uint64_t a7, double a8, double a9, double a10)
{
  uint64_t result = IOHIDEventCreate(a1, a3, a2, a7);
  if (result)
  {
    uint64_t v17 = *(void *)(result + 104);
    *(_DWORD *)(v17 + 28) = a4;
    *(_WORD *)(v17 + 32) = a5;
    *(_WORD *)(v17 + 34) = a6;
    *(_DWORD *)(v17 + 36) = vcvtd_n_s64_f64(a8, 0x10uLL);
    *(_DWORD *)(v17 + 16) = vcvtd_n_s64_f64(a9, 0x10uLL);
    *(_DWORD *)(v17 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a10, 0x10uLL);
  }
  return result;
}

uint64_t IOHIDEventCreateNavigationSwipeEvent(uint64_t a1, uint64_t a2, int a3, __int16 a4, uint64_t a5, double a6, double a7, double a8)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 16, a3, a4, 5, a5, a6, a7, a8);
}

uint64_t IOHIDEventCreateDockSwipeEvent(uint64_t a1, uint64_t a2, int a3, __int16 a4, uint64_t a5, double a6, double a7, double a8)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 23, a3, a4, 3, a5, a6, a7, a8);
}

uint64_t IOHIDEventCreateBoundaryScrollEvent(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, double a5, double a6, double a7)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 28, 0, a3, 0, a4, a5, a6, a7);
}

uint64_t IOHIDEventCreateFluidTouchGestureEvent(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5, double a6, double a7, double a8)
{
  return __IOHIDEventCreateSwipeEventOfTypeWithFlavor(a1, a2, 27, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t IOHIDEventCreateProgressEvent(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  uint64_t result = IOHIDEventCreate(a1, 18, a2, a4 | 1u);
  if (result)
  {
    uint64_t v8 = *(void *)(result + 104);
    *(_DWORD *)(v8 + 16) = a3;
    *(_DWORD *)(v8 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = (int)a5;
  }
  return result;
}

uint64_t IOHIDEventCreateBiometricEvent(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  uint64_t result = IOHIDEventCreate(a1, 29, a2, a4 | 1u);
  if (result)
  {
    uint64_t v8 = *(void *)(result + 104);
    *(_DWORD *)(v8 + 16) = a3;
    *(_DWORD *)(v8 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a5, 0x10uLL);
    *(_DWORD *)(v8 + 24) = 0;
    *(unsigned char *)(v8 + 32) = 0;
  }
  return result;
}

uint64_t IOHIDEventCreateAtmosphericPressureEvent(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  uint64_t result = IOHIDEventCreate(a1, 31, a2, a4 | 1u);
  if (result)
  {
    uint64_t v8 = *(void *)(result + 104);
    *(_DWORD *)(v8 + 16) = vcvtd_n_s64_f64(a5, 0x10uLL);
    *(_DWORD *)(v8 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
  }
  return result;
}

uint64_t IOHIDEventCreateZoomToggleEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return IOHIDEventCreate(a1, 22, a2, a4);
}

uint64_t IOHIDEventCreateSymbolicHotKeyEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  if (a4) {
    uint64_t v6 = a5 | 0x10001u;
  }
  else {
    uint64_t v6 = a5 & 0xFFFEFFFE | 1;
  }
  uint64_t result = IOHIDEventCreate(a1, 24, a2, v6);
  if (result) {
    *(_DWORD *)(*(void *)(result + 104) + 16) = a3;
  }
  return result;
}

uint64_t IOHIDEventCreateLEDEvent(uint64_t a1, uint64_t a2, int a3, char a4, int a5, int a6)
{
  uint64_t result = IOHIDEventCreate(a1, 26, a2, a6 | 1u);
  if (result)
  {
    if (a5) {
      BOOL v10 = a3 == 0;
    }
    else {
      BOOL v10 = 0;
    }
    int v11 = 1 << (a4 - 1);
    uint64_t v12 = *(void *)(result + 104);
    if (!v10) {
      int v11 = a3;
    }
    *(_DWORD *)(v12 + 16) = v11;
    *(unsigned char *)(v12 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a4;
    *(_DWORD *)(v12 + 24) = a5;
  }
  return result;
}

uint64_t IOHIDEventCreateForceEvent(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, double a6, double a7)
{
  uint64_t result = IOHIDEventCreate(a1, 32, a2, a5);
  if (result)
  {
    uint64_t v12 = *(_DWORD **)(result + 104);
    v12[4] = a3;
    _OWORD v12[5] = vcvtd_n_s64_f64(a6, 0x10uLL);
    void v12[6] = a4;
    v12[7] = vcvtd_n_s64_f64(a7, 0x10uLL);
  }
  return result;
}

uint64_t IOHIDEventCreateMotionActivtyEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5)
{
  uint64_t result = IOHIDEventCreate(a1, 33, a2, a4);
  if (result)
  {
    uint64_t v8 = *(void *)(result + 104);
    *(_DWORD *)(v8 + 16) = a3;
    *(_DWORD *)(v8 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a5, 0x10uLL);
  }
  return result;
}

uint64_t IOHIDEventCreateMotionGestureEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5)
{
  uint64_t result = IOHIDEventCreate(a1, 34, a2, a4);
  if (result)
  {
    uint64_t v8 = *(void *)(result + 104);
    *(_DWORD *)(v8 + 16) = a3;
    *(_DWORD *)(v8 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a5, 0x10uLL);
  }
  return result;
}

uint64_t IOHIDEventCreateCollectionEvent(uint64_t a1, uint64_t a2, int a3)
{
  return IOHIDEventCreate(a1, 37, a2, a3 | 2u);
}

uint64_t IOHIDEventCreateBrightnessEvent(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = IOHIDEventCreate(a1, 38, a2, a6);
  uint64_t v10 = *(void *)(result + 104);
  *(_DWORD *)(v10 + 16) = a3;
  *(_DWORD *)(v10 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a4;
  *(void *)(v10 + 24) = a5;
  return result;
}

uint64_t IOHIDEventCreateGameControllerEvent(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, unsigned int a20)
{
  uint64_t result = IOHIDEventCreate(a1, 35, a2, a20);
  if (result)
  {
    CFDictionaryRef v27 = *(_DWORD **)(result + 104);
    v27[4] = a3;
    _OWORD v27[5] = a4;
    void v27[6] = a5;
    v27[7] = a6;
    v27[8] = a7;
    v27[9] = a8;
    v27[10] = a9;
    v27[11] = a10;
    v27[12] = a11;
    v27[13] = a12;
    v27[14] = a13;
    v27[15] = a14;
    v27[16] = a15;
    v27[17] = a16;
    v27[18] = a17;
    v27[19] = a18;
    v27[20] = a19;
  }
  return result;
}

uint64_t IOHIDEventCreateGenericGestureEvent(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result = IOHIDEventCreate(a1, 39, a2, a4);
  if (result) {
    *(_DWORD *)(*(void *)(result + 104) + 16) = a3;
  }
  return result;
}

uint64_t IOHIDEventCreateForceStageEvent(uint64_t a1, uint64_t a2, int a3, char a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t result = IOHIDEventCreate(a1, 41, a2, a5);
  if (result)
  {
    uint64_t v18 = *(void *)(result + 104);
    *(_DWORD *)(v18 + 16) = a3;
    *(unsigned char *)(v18 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a4;
    *(double *)(v18 + 24) = a6;
    *(double *)(v18 + 32) = a7;
    *(double *)(v18 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a8;
    *(double *)(v18 + 48) = a9;
    *(double *)(v18 + 56) = a10;
  }
  return result;
}

BOOL IOHIDEventConformsToWithOptions(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[3] & (1 << a2);
  BOOL v4 = v3 != 0;
  if (!(a3 >> 28) && v3) {
    return IOHIDEventGetEventWithOptions(a1, a2, a3) != 0;
  }
  return v4;
}

uint64_t IOHIDEventSetPhase(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(result + 104) + 11) = a2;
  return result;
}

uint64_t IOHIDEventGetScrollMomentum(uint64_t a1)
{
  return (*(_DWORD *)(*(void *)(a1 + 104) + 8) >> 6) & 0x18 | (*(_DWORD *)(*(void *)(a1 + 104) + 8) >> 28) & 7u;
}

uint64_t IOHIDEventSetScrollMomentum(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 104) + 8) = ((a2 << 28) | (a2 << 6)) & 0x70000600 | *(_DWORD *)(*(void *)(result + 104) + 8) & 0x8FFFF9FF;
  return result;
}

uint64_t IOHIDEventSetEventFlags(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 104) + 8) = a2;
  return result;
}

uint64_t IOHIDEventIsAbsolute(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 104) + 8) & 1;
}

uint64_t IOHIDEventIsRepeat(uint64_t a1)
{
  return HIWORD(*(_DWORD *)(*(void *)(a1 + 104) + 8)) & 1;
}

uint64_t IOHIDEventSetRepeat(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 104) + 8) |= 0x10000u;
  return result;
}

double IOHIDEventGetPosition(void *a1)
{
  return IOHIDEventGetPositionWithOptions(a1, 4026531840);
}

double IOHIDEventGetPositionWithOptions(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[13];
  uint64_t v4 = *(unsigned int *)(v3 + 4);
  double v5 = 0.0;
  if (v4 <= 0xB && ((1 << v4) & 0xAF0) != 0)
  {
    if (a2)
    {
      uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(a1, v4, a2);
      if (!EventWithOptions) {
        return v5;
      }
      uint64_t v3 = *(void *)(EventWithOptions + 104);
    }
    int v8 = *(_DWORD *)(v3 + 16);
    if (v8 == 0x80000000) {
      return NAN;
    }
    else {
      return (double)v8 * 0.0000152587891;
    }
  }
  return v5;
}

void *IOHIDEventSetPosition(void *a1, double a2, double a3, double a4)
{
  return IOHIDEventSetPositionWithOptions(a1, 4026531840, a2, a3, a4);
}

void *IOHIDEventSetPositionWithOptions(void *result, uint64_t a2, double a3, double a4, double a5)
{
  uint64_t v6 = (unsigned int *)result[13];
  uint64_t v7 = v6[1];
  if (v7 <= 0xB && ((1 << v7) & 0xAF0) != 0)
  {
    if (a2)
    {
      uint64_t result = (void *)IOHIDEventGetEventWithOptions(result, v7, a2);
      if (!result) {
        return result;
      }
      uint64_t v6 = (unsigned int *)result[13];
    }
    v6[4] = vcvtd_n_s64_f64(a3, 0x10uLL);
    _OWORD v6[5] = vcvtd_n_s64_f64(a4, 0x10uLL);
    void v6[6] = vcvtd_n_s64_f64(a5, 0x10uLL);
  }
  return result;
}

unint64_t IOHIDEventGetUInt64Value(void *a1, unsigned int a2)
{
  return IOHIDEventGetUInt64ValueWithOptions(a1, a2, 4026531840);
}

unint64_t IOHIDEventGetUInt64ValueWithOptions(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = a1;
  unsigned int v5 = HIWORD(a2);
  if (a1 && a2 < 0x10000
    || (result = IOHIDEventGetEventWithOptions(a1, HIWORD(a2), a3), (uint64_t v4 = (void *)result) != 0))
  {
    unint64_t result = 0;
    uint64_t v7 = v4[13];
    switch(v5)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            LOBYTE(v7) = *(unsigned char *)(v7 + 8);
            goto LABEL_189;
          case 1u:
            unint64_t v13 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_198;
          case 2u:
            goto LABEL_20;
          case 3u:
            unint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 3) & 1;
            break;
          case 4u:
            unint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 4) & 1;
            break;
          case 5u:
            unint64_t v14 = *(unsigned __int8 *)(v7 + 8);
            goto LABEL_164;
          case 6u:
            unint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 6) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x10001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x10002u:
            return *(unsigned int *)(v7 + 20);
          case 0x10003u:
            return *(unsigned int *)(v7 + 24);
          case 0x10004u:
            goto LABEL_75;
          default:
            return 0;
        }
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            return *(unsigned int *)(v7 + 16);
          case 0x20001u:
            goto LABEL_120;
          case 0x20002u:
            goto LABEL_121;
          case 0x20003u:
            goto LABEL_142;
          case 0x20004u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x30001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x30002u:
            return *(unsigned int *)(v7 + 20);
          case 0x30003u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0x30004u:
            unint64_t result = *(unsigned __int8 *)(v7 + 28);
            break;
          case 0x30005u:
            LODWORD(v7) = *(_DWORD *)(v7 + 24);
            goto LABEL_189;
          case 0x30006u:
            unint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 1) & 3;
            break;
          case 0x30007u:
            unint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 3) & 3;
            break;
          case 0x30008u:
            unint64_t v14 = *(unsigned int *)(v7 + 24);
LABEL_164:
            unint64_t result = (v14 >> 5) & 1;
            break;
          case 0x30009u:
            unint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 6) & 7;
            break;
          case 0x3000Au:
            unint64_t result = ((unint64_t)*(unsigned int *)(v7 + 24) >> 9) & 3;
            break;
          default:
            return 0;
        }
        return result;
      case 4u:
        if (a2 == 262146) {
          goto LABEL_135;
        }
        if (a2 == 262145) {
          goto LABEL_142;
        }
        if (a2 != 0x40000) {
          return 0;
        }
        goto LABEL_96;
      case 5u:
        if (a2 == 327682) {
          goto LABEL_135;
        }
        if (a2 == 327681) {
          goto LABEL_142;
        }
        if (a2 != 327680) {
          return 0;
        }
        goto LABEL_96;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_96;
          case 0x60001u:
            goto LABEL_142;
          case 0x60002u:
            goto LABEL_135;
          case 0x60003u:
LABEL_20:
            unint64_t result = ((unint64_t)*(unsigned __int8 *)(v7 + 8) >> 2) & 1;
            break;
          default:
            return 0;
        }
        return result;
      case 7u:
        if (a2 == 458754) {
          goto LABEL_135;
        }
        if (a2 == 458753) {
          goto LABEL_142;
        }
        if (a2 != 458752) {
          return 0;
        }
        goto LABEL_96;
      case 9u:
        if (a2 == 589826)
        {
LABEL_135:
          int v10 = *(_DWORD *)(v7 + 24);
          goto LABEL_143;
        }
        if (a2 == 589825) {
          goto LABEL_142;
        }
        if (a2 != 589824) {
          return 0;
        }
        goto LABEL_96;
      case 0xAu:
        if (a2 - 655360 > 0xB) {
          return 0;
        }
        if (a2 != 655363)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              if (a2 == 655362) {
                goto LABEL_135;
              }
              if (a2 == 655361) {
                goto LABEL_142;
              }
              if (a2 != 655360) {
                return 0;
              }
              goto LABEL_96;
            case 1:
              if (a2 == 655364) {
                return *(unsigned int *)(v7 + 16);
              }
              return 0;
            case 2:
              if (a2 == 655367) {
                goto LABEL_135;
              }
              if (a2 == 655366) {
                goto LABEL_142;
              }
              if (a2 != 655365) {
                return 0;
              }
              goto LABEL_96;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_96;
                case 0xA0009u:
                  goto LABEL_142;
                case 0xA000Au:
                  goto LABEL_135;
                case 0xA000Bu:
                  goto LABEL_136;
                default:
                  return 0;
              }
            default:
              return 0;
          }
        }
        return *(unsigned int *)(v7 + 32);
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_96;
          case 0xB0001u:
            goto LABEL_142;
          case 0xB0002u:
            goto LABEL_135;
          case 0xB0003u:
            goto LABEL_157;
          case 0xB0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xB0005u:
            return *(unsigned int *)(v7 + 28);
          case 0xB0006u:
            goto LABEL_114;
          case 0xB0007u:
            goto LABEL_158;
          case 0xB0008u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 16) & 1;
          case 0xB0009u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 17) & 1;
          case 0xB000Au:
            goto LABEL_180;
          case 0xB000Bu:
            goto LABEL_181;
          case 0xB000Cu:
            goto LABEL_202;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            int v8 = *(_DWORD *)(v7 + 64);
            if (v8)
            {
              if (v8 == 2)
              {
                unint64_t result = 0;
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_171;
                  case 0xB0012u:
                    goto LABEL_172;
                  case 0xB0013u:
                    goto LABEL_182;
                  case 0xB0014u:
                    goto LABEL_183;
                  case 0xB0015u:
LABEL_209:
                    int v10 = *(_DWORD *)(v7 + 84);
                    goto LABEL_143;
                  case 0xB001Au:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              else
              {
                if (v8 != 1) {
                  return 0;
                }
                unint64_t result = 0;
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_171;
                  case 0xB0010u:
                    goto LABEL_172;
                  case 0xB0011u:
                    goto LABEL_182;
                  case 0xB0012u:
                    goto LABEL_183;
                  case 0xB0014u:
                    goto LABEL_209;
                  case 0xB0015u:
                    goto LABEL_184;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910) {
              goto LABEL_172;
            }
            if (a2 != 720909) {
              return 0;
            }
            goto LABEL_171;
          case 0xB0016u:
            unint64_t v13 = *(unsigned int *)(v7 + 8);
            goto LABEL_198;
          case 0xB0017u:
            if (*(_DWORD *)(v7 + 32)) {
              return 0;
            }
            goto LABEL_202;
          case 0xB0018u:
            return *(unsigned int *)(v7 + 44);
          case 0xB0019u:
            return ((unint64_t)*(unsigned int *)(v7 + 8) >> 19) & 1;
          case 0xB001Bu:
            return *(unsigned int *)(v7 + 92);
          case 0xB001Cu:
            return *(unsigned int *)(v7 + 96);
          case 0xB001Du:
            return *(unsigned int *)(v7 + 100);
          case 0xB001Eu:
            return (*(_DWORD *)(v7 + 40) >> 13) & 0x18000 | (*(_DWORD *)(v7 + 40) >> 20) & 0x400u | (*(_DWORD *)(v7 + 40) >> 31 << 23);
          case 0xB001Fu:
            return *(unsigned int *)(v7 + 64);
          default:
            return 0;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            return *(unsigned int *)(v7 + 16);
          case 0xC0001u:
            return *(unsigned int *)(v7 + 20);
          case 0xC0002u:
            return *(unsigned int *)(v7 + 24);
          case 0xC0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xC0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xC0005u:
            unint64_t result = *(unsigned __int8 *)(v7 + 36);
            break;
          case 0xC0006u:
            unint64_t result = *(unsigned __int8 *)(v7 + 37);
            break;
          case 0xC0007u:
            goto LABEL_124;
          case 0xC0008u:
            goto LABEL_117;
          case 0xC0009u:
            goto LABEL_118;
          case 0xC000Au:
            goto LABEL_137;
          case 0xC000Bu:
            goto LABEL_138;
          default:
            return 0;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_96;
          case 0xD0001u:
            goto LABEL_142;
          case 0xD0002u:
            goto LABEL_135;
          case 0xD0003u:
            return *(unsigned int *)(v7 + 28);
          case 0xD0004u:
            return *(unsigned int *)(v7 + 32);
          case 0xD0005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              int v9 = 917507;
              goto LABEL_101;
            }
            unint64_t result = 0;
            if (a2 != 917505 || *(_WORD *)(v7 + 18)) {
              return result;
            }
            return *(unsigned int *)(v7 + 20);
          case 0xE0002u:
            return *(unsigned __int16 *)(v7 + 18);
          default:
            return 0;
        }
      case 0xFu:
        if (a2 != 983040) {
          return 0;
        }
        goto LABEL_96;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            return *(unsigned int *)(v7 + 28);
          case 0x100001u:
            goto LABEL_71;
          case 0x100002u:
            goto LABEL_110;
          case 0x100003u:
            goto LABEL_96;
          case 0x100004u:
            goto LABEL_142;
          case 0x100005u:
            goto LABEL_113;
          case 0x100006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_96;
          case 0x110001u:
            goto LABEL_142;
          case 0x110002u:
            goto LABEL_135;
          case 0x110003u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x12u:
        if (a2 == 1179649) {
          goto LABEL_142;
        }
        if (a2 != 1179648) {
          return 0;
        }
        return *(unsigned int *)(v7 + 16);
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_96;
          case 0x130001u:
            goto LABEL_142;
          case 0x130002u:
            goto LABEL_135;
          case 0x130003u:
            goto LABEL_89;
          case 0x130004u:
            goto LABEL_110;
          case 0x130005u:
            goto LABEL_149;
          case 0x130006u:
            return *(unsigned int *)(v7 + 28);
          default:
            return 0;
        }
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_96;
          case 0x140001u:
            goto LABEL_142;
          case 0x140002u:
            goto LABEL_135;
          case 0x140003u:
            return *(unsigned int *)(v7 + 28);
          case 0x140004u:
            return *(unsigned int *)(v7 + 32);
          case 0x140005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_96;
          case 0x150001u:
            goto LABEL_142;
          case 0x150002u:
            goto LABEL_135;
          case 0x150003u:
            return *(unsigned int *)(v7 + 28);
          case 0x150004u:
            return *(unsigned int *)(v7 + 32);
          case 0x150005u:
            goto LABEL_114;
          default:
            return 0;
        }
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            return *(unsigned int *)(v7 + 28);
          case 0x170001u:
            goto LABEL_71;
          case 0x170002u:
            goto LABEL_110;
          case 0x170003u:
            goto LABEL_96;
          case 0x170004u:
            goto LABEL_142;
          case 0x170005u:
            goto LABEL_113;
          case 0x170006u:
            goto LABEL_135;
          default:
            return 0;
        }
      case 0x18u:
        if (a2 == 1572864) {
          return *(unsigned int *)(v7 + 16);
        }
        if (a2 != 1572865) {
          return 0;
        }
        return (unint64_t)*(unsigned __int16 *)(v7 + 8) >> 15;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
            return *(unsigned int *)(v7 + 28);
          case 0x190001u:
            return *(unsigned int *)(v7 + 24);
          case 0x190000u:
            goto LABEL_96;
        }
        return 0;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1A0001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x1A0000u:
            return *(unsigned int *)(v7 + 16);
        }
        return 0;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1B0001u:
            goto LABEL_71;
          case 0x1B0002u:
            goto LABEL_110;
          case 0x1B0003u:
            goto LABEL_96;
          case 0x1B0004u:
            goto LABEL_142;
          case 0x1B0005u:
            goto LABEL_113;
          default:
            return 0;
        }
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
            return *(unsigned int *)(v7 + 28);
          case 0x1C0001u:
LABEL_71:
            unint64_t result = *(unsigned __int16 *)(v7 + 32);
            break;
          case 0x1C0002u:
            goto LABEL_110;
          case 0x1C0003u:
            goto LABEL_96;
          case 0x1C0004u:
            goto LABEL_142;
          case 0x1C0005u:
LABEL_113:
            unint64_t result = *(unsigned __int16 *)(v7 + 34);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1D0001u:
            goto LABEL_142;
          case 0x1D0002u:
            unint64_t result = *(unsigned __int16 *)(v7 + 24);
            break;
          case 0x1D0003u:
            unint64_t result = *(unsigned __int16 *)(v7 + 26);
            break;
          case 0x1D0004u:
            unint64_t result = *(unsigned __int8 *)(v7 + 32);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            return *(unsigned int *)(v7 + 16);
          case 0x1E0001u:
            goto LABEL_142;
          case 0x1E0002u:
            return *(unsigned int *)(v7 + 24);
          case 0x1E0003u:
LABEL_75:
            if (*(_DWORD *)(v7 + 24) < 8u) {
              return 0;
            }
            unint64_t result = *(void *)(v7 + 28);
            break;
          default:
            return 0;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617) {
          return *(unsigned int *)(v7 + 20);
        }
        if (a2 != 2031616) {
          return 0;
        }
        goto LABEL_96;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            return *(unsigned int *)(v7 + 16);
          case 0x200001u:
            goto LABEL_142;
          case 0x200002u:
            return *(unsigned int *)(v7 + 24);
          case 0x200003u:
            goto LABEL_136;
          default:
            return 0;
        }
      case 0x21u:
        if (a2 == 2162689) {
          goto LABEL_142;
        }
        if (a2 != 2162688) {
          return 0;
        }
        return *(unsigned int *)(v7 + 16);
      case 0x22u:
        if (a2 == 2228225) {
          goto LABEL_142;
        }
        if (a2 != 2228224) {
          return 0;
        }
        return *(unsigned int *)(v7 + 16);
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            return *(unsigned int *)(v7 + 16);
          case 0x230001u:
            goto LABEL_142;
          case 0x230002u:
            goto LABEL_135;
          case 0x230003u:
LABEL_136:
            int v10 = *(_DWORD *)(v7 + 28);
            goto LABEL_143;
          case 0x230004u:
LABEL_89:
            int v10 = *(_DWORD *)(v7 + 32);
            goto LABEL_143;
          case 0x230005u:
            int v10 = *(_DWORD *)(v7 + 44);
            goto LABEL_143;
          case 0x230006u:
            int v10 = *(_DWORD *)(v7 + 48);
            goto LABEL_143;
          case 0x230007u:
LABEL_110:
            int v10 = *(_DWORD *)(v7 + 36);
            goto LABEL_143;
          case 0x230008u:
LABEL_149:
            int v10 = *(_DWORD *)(v7 + 40);
            goto LABEL_143;
          case 0x230009u:
LABEL_171:
            int v10 = *(_DWORD *)(v7 + 68);
            goto LABEL_143;
          case 0x23000Au:
LABEL_182:
            int v10 = *(_DWORD *)(v7 + 76);
            goto LABEL_143;
          case 0x23000Bu:
LABEL_172:
            int v10 = *(_DWORD *)(v7 + 72);
            goto LABEL_143;
          case 0x23000Cu:
LABEL_183:
            int v10 = *(_DWORD *)(v7 + 80);
            goto LABEL_143;
          case 0x23000Du:
LABEL_180:
            int v10 = *(_DWORD *)(v7 + 52);
            goto LABEL_143;
          case 0x23000Eu:
LABEL_181:
            int v10 = *(_DWORD *)(v7 + 56);
            goto LABEL_143;
          case 0x23000Fu:
LABEL_202:
            int v10 = *(_DWORD *)(v7 + 60);
            goto LABEL_143;
          case 0x230010u:
            int v10 = *(_DWORD *)(v7 + 64);
            goto LABEL_143;
          case 0x230011u:
            LOBYTE(v7) = *(unsigned char *)(v7 + 84);
LABEL_189:
            unint64_t result = v7 & 1;
            break;
          case 0x230012u:
            unint64_t v13 = *(unsigned __int8 *)(v7 + 84);
LABEL_198:
            unint64_t result = (v13 >> 1) & 1;
            break;
          case 0x230013u:
LABEL_184:
            int v10 = *(_DWORD *)(v7 + 88);
            goto LABEL_143;
          case 0x230014u:
            int v10 = *(_DWORD *)(v7 + 92);
            goto LABEL_143;
          case 0x230015u:
            int v10 = *(_DWORD *)(v7 + 96);
            goto LABEL_143;
          case 0x230016u:
            int v10 = *(_DWORD *)(v7 + 100);
            goto LABEL_143;
          case 0x230017u:
            int v10 = *(_DWORD *)(v7 + 104);
            goto LABEL_143;
          case 0x230018u:
            int v10 = *(_DWORD *)(v7 + 108);
            goto LABEL_143;
          default:
            return 0;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297) {
          return *(unsigned int *)(v7 + 20);
        }
        if (a2 != 2359296) {
          return 0;
        }
        goto LABEL_96;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            return *(void *)(v7 + 24);
          case 0x260001u:
            goto LABEL_142;
          case 0x260000u:
LABEL_96:
            int v10 = *(_DWORD *)(v7 + 16);
            goto LABEL_143;
        }
        return 0;
      case 0x27u:
        if (a2 - 2555905 >= 2)
        {
          if (a2 == 2555904) {
            return *(unsigned int *)(v7 + 16);
          }
          return 0;
        }
        int v11 = *(_DWORD *)(v7 + 16);
        if (v11 == 1)
        {
          if (a2 != 2555906) {
            return 0;
          }
LABEL_142:
          int v10 = *(_DWORD *)(v7 + 20);
LABEL_143:
          if (v10 == 0x80000000) {
            unint64_t result = 0xFFFFFFFF80000000;
          }
          else {
            unint64_t result = (uint64_t)(v10 + (v10 < 0 ? 0xFFFF : 0)) >> 16;
          }
        }
        else
        {
          if (!v11)
          {
            int v9 = 2555905;
LABEL_101:
            if (a2 != v9) {
              return 0;
            }
            return *(unsigned int *)(v7 + 20);
          }
          unint64_t result = 0;
          if (a2 == 2555905 && v11 == 2) {
            return *(unsigned int *)(v7 + 20);
          }
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            unint64_t result = *(unsigned __int16 *)(v7 + 64);
            break;
          case 0x280001u:
            unint64_t result = *(unsigned __int16 *)(v7 + 66);
            break;
          case 0x280002u:
            double v12 = *(double *)(v7 + 16);
            goto LABEL_176;
          case 0x280003u:
LABEL_120:
            unint64_t result = *(unsigned __int8 *)(v7 + 24);
            break;
          case 0x280004u:
LABEL_121:
            unint64_t result = *(unsigned __int8 *)(v7 + 25);
            break;
          case 0x280005u:
            return *(unsigned int *)(v7 + 28);
          case 0x280006u:
            return *(unsigned int *)(v7 + 32);
          case 0x280007u:
LABEL_114:
            unint64_t result = *(unsigned int *)(v7 + 36);
            break;
          case 0x280008u:
            unint64_t result = *(unsigned __int8 *)(v7 + 44);
            break;
          case 0x280009u:
LABEL_157:
            unint64_t result = *(unsigned int *)(v7 + 48);
            break;
          case 0x28000Au:
            unint64_t result = *(void *)(v7 + 56);
            break;
          case 0x28000Bu:
            unint64_t result = *(unsigned __int8 *)(v7 + 26);
            break;
          case 0x28000Cu:
LABEL_158:
            unint64_t result = *(unsigned int *)(v7 + 40);
            break;
          default:
            return 0;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            return *(unsigned int *)(v7 + 16);
          case 0x290001u:
            return *(unsigned __int8 *)(v7 + 20);
          case 0x290002u:
            goto LABEL_122;
          case 0x290003u:
            goto LABEL_123;
          case 0x290004u:
LABEL_124:
            double v12 = *(double *)(v7 + 40);
            goto LABEL_176;
          case 0x290005u:
            goto LABEL_117;
          case 0x290006u:
            goto LABEL_118;
          default:
            return 0;
        }
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
            return *(unsigned __int16 *)(v7 + 16);
          case 0x2A0001u:
            return *(unsigned __int16 *)(v7 + 18);
          case 0x2A0002u:
LABEL_122:
            double v12 = *(double *)(v7 + 24);
            goto LABEL_176;
          case 0x2A0003u:
LABEL_123:
            double v12 = *(double *)(v7 + 32);
            goto LABEL_176;
          case 0x2A0004u:
            return *(unsigned __int8 *)(v7 + 40);
          case 0x2A0005u:
            return *(unsigned int *)(v7 + 44);
          case 0x2A0006u:
LABEL_117:
            double v12 = *(double *)(v7 + 48);
            goto LABEL_176;
          case 0x2A0007u:
LABEL_118:
            double v12 = *(double *)(v7 + 56);
            goto LABEL_176;
          case 0x2A0008u:
LABEL_137:
            double v12 = *(double *)(v7 + 64);
            goto LABEL_176;
          case 0x2A0009u:
LABEL_138:
            double v12 = *(double *)(v7 + 72);
LABEL_176:
            unint64_t result = (unint64_t)v12;
            break;
          default:
            return 0;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

void *IOHIDEventSetDoubleValue(void *a1, unsigned int a2, double a3)
{
  return IOHIDEventSetDoubleValueWithOptions(a1, a2, 4026531840, a3);
}

void *IOHIDEventSetDoubleValueWithOptions(void *result, unsigned int a2, uint64_t a3, double a4)
{
  unsigned int v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (unint64_t result = (void *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a3)) != 0)
  {
    uint64_t v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFE | (a4 != 0.0);
            goto LABEL_168;
          case 1u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFD | (2 * (a4 != 0.0));
            goto LABEL_168;
          case 2u:
            goto LABEL_23;
          case 3u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xF7 | (8 * (a4 != 0.0));
            goto LABEL_168;
          case 4u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xEF | (16 * (a4 != 0.0));
            goto LABEL_168;
          case 5u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xDF | (32 * (a4 != 0.0));
            goto LABEL_168;
          case 6u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xBF | ((a4 != 0.0) << 6);
            goto LABEL_168;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10002u:
            unsigned int v16 = a4;
            goto LABEL_158;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x10000u:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_139;
          case 0x20001u:
            goto LABEL_130;
          case 0x20002u:
            goto LABEL_131;
          case 0x20003u:
            goto LABEL_154;
          case 0x20004u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_113;
          case 0x30001u:
            goto LABEL_120;
          case 0x30002u:
            goto LABEL_157;
          case 0x30003u:
            goto LABEL_170;
          case 0x30004u:
            *(unsigned char *)(v7 + 28) = (int)a4;
            return result;
          case 0x30005u:
            unsigned int v13 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a4 != 0.0);
            goto LABEL_148;
          case 0x30006u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a4 & 3));
            goto LABEL_181;
          case 0x30007u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a4 & 3));
            goto LABEL_181;
          case 0x30008u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a4 != 0.0));
            goto LABEL_181;
          case 0x30009u:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a4 & 7) << 6);
            goto LABEL_181;
          case 0x3000Au:
            unsigned int v21 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a4 & 3) << 9);
LABEL_181:
            *(_DWORD *)(v7 + 24) = v21;
            break;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146) {
          goto LABEL_147;
        }
        if (a2 == 262145) {
          goto LABEL_154;
        }
        if (a2 != 0x40000) {
          return result;
        }
        goto LABEL_69;
      case 5u:
        if (a2 == 327682) {
          goto LABEL_147;
        }
        if (a2 == 327681) {
          goto LABEL_154;
        }
        if (a2 != 327680) {
          return result;
        }
        goto LABEL_69;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_69;
          case 0x60001u:
            goto LABEL_154;
          case 0x60002u:
            goto LABEL_147;
          case 0x60003u:
LABEL_23:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFB | (4 * (a4 != 0.0));
LABEL_168:
            *(unsigned char *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
            goto LABEL_147;
          case 0x70001u:
            goto LABEL_154;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_147:
          unsigned int v13 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_148;
        }
        if (a2 == 589825) {
          goto LABEL_154;
        }
        if (a2 != 589824) {
          return result;
        }
        goto LABEL_69;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_147;
                case 0xA0001u:
                  goto LABEL_154;
                case 0xA0000u:
                  goto LABEL_69;
              }
              break;
            case 1:
              if (a2 == 655364) {
                goto LABEL_139;
              }
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_147;
                case 0xA0006u:
                  goto LABEL_154;
                case 0xA0005u:
                  goto LABEL_69;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_69;
                case 0xA0009u:
                  goto LABEL_154;
                case 0xA000Au:
                  goto LABEL_147;
                case 0xA000Bu:
                  goto LABEL_95;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_154;
          case 0xB0002u:
            goto LABEL_147;
          case 0xB0003u:
            goto LABEL_171;
          case 0xB0004u:
            goto LABEL_121;
          case 0xB0005u:
            goto LABEL_114;
          case 0xB0006u:
            goto LABEL_128;
          case 0xB0007u:
            goto LABEL_172;
          case 0xB0008u:
LABEL_170:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a4 != 0.0) << 16);
            goto LABEL_217;
          case 0xB0009u:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a4 != 0.0) << 17);
            goto LABEL_217;
          case 0xB000Au:
            goto LABEL_189;
          case 0xB000Bu:
            goto LABEL_190;
          case 0xB000Cu:
            goto LABEL_215;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            int v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_186;
                  case 0xB0012u:
                    goto LABEL_187;
                  case 0xB0013u:
                    goto LABEL_196;
                  case 0xB0014u:
                    goto LABEL_197;
                  case 0xB0015u:
LABEL_224:
                    *(_DWORD *)(v7 + 84) = vcvtd_n_s64_f64(a4, 0x10uLL);
                    break;
                  case 0xB001Au:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_186;
                  case 0xB0010u:
                    goto LABEL_187;
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_197;
                  case 0xB0014u:
                    goto LABEL_224;
                  case 0xB0015u:
                    goto LABEL_198;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910) {
              goto LABEL_187;
            }
            if (a2 != 720909) {
              return result;
            }
            goto LABEL_186;
          case 0xB0016u:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a4 != 0.0));
            goto LABEL_217;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32)) {
              goto LABEL_215;
            }
            return result;
          case 0xB0018u:
            goto LABEL_169;
          case 0xB0019u:
            unsigned int v19 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a4 != 0.0) << 19);
LABEL_217:
            *(_DWORD *)(v7 + 8) = v19;
            return result;
          case 0xB001Bu:
            unsigned int v23 = a4;
            goto LABEL_219;
          case 0xB001Cu:
            unsigned int v24 = a4;
            goto LABEL_221;
          case 0xB001Du:
            unsigned int v25 = a4;
            goto LABEL_223;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_111;
          case 0xC0001u:
            goto LABEL_157;
          case 0xC0002u:
            goto LABEL_87;
          case 0xC0003u:
            goto LABEL_114;
          case 0xC0004u:
            goto LABEL_121;
          case 0xC0005u:
            *(unsigned char *)(v7 + 36) = a4 != 0.0;
            break;
          case 0xC0006u:
            *(unsigned char *)(v7 + 37) = (int)a4;
            break;
          case 0xC0007u:
            goto LABEL_134;
          case 0xC0008u:
            goto LABEL_122;
          case 0xC0009u:
            goto LABEL_123;
          case 0xC000Au:
            goto LABEL_149;
          case 0xC000Bu:
            goto LABEL_150;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_154;
          case 0xD0002u:
            goto LABEL_147;
          case 0xD0003u:
            goto LABEL_114;
          case 0xD0004u:
            goto LABEL_121;
          case 0xD0005u:
            goto LABEL_128;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_113;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507) {
                goto LABEL_157;
              }
            }
            else if (a2 == 917505 && !*(_WORD *)(v7 + 18))
            {
              goto LABEL_157;
            }
            break;
          case 0xE0002u:
            goto LABEL_120;
          default:
            return result;
        }
        return result;
      case 0xFu:
        if (a2 != 983040) {
          return result;
        }
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_76;
          case 0x100001u:
            goto LABEL_117;
          case 0x100002u:
            goto LABEL_116;
          case 0x100003u:
            goto LABEL_69;
          case 0x100004u:
            goto LABEL_154;
          case 0x100005u:
            goto LABEL_118;
          case 0x100006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_154;
          case 0x110002u:
            goto LABEL_147;
          case 0x110003u:
            goto LABEL_114;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649) {
          goto LABEL_154;
        }
        if (a2 != 1179648) {
          return result;
        }
        goto LABEL_111;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_69;
          case 0x130001u:
            goto LABEL_154;
          case 0x130002u:
            goto LABEL_147;
          case 0x130003u:
            goto LABEL_160;
          case 0x130004u:
            goto LABEL_116;
          case 0x130005u:
            goto LABEL_162;
          case 0x130006u:
            goto LABEL_76;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_69;
          case 0x140001u:
            goto LABEL_154;
          case 0x140002u:
            goto LABEL_147;
          case 0x140003u:
            goto LABEL_76;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_69;
          case 0x150001u:
            goto LABEL_154;
          case 0x150002u:
            goto LABEL_147;
          case 0x150003u:
            goto LABEL_76;
          case 0x150004u:
LABEL_61:
            unsigned int v10 = a4;
            goto LABEL_161;
          case 0x150005u:
LABEL_124:
            unsigned int v15 = a4;
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_76;
          case 0x170001u:
            goto LABEL_117;
          case 0x170002u:
            goto LABEL_116;
          case 0x170003u:
            goto LABEL_69;
          case 0x170004u:
            goto LABEL_154;
          case 0x170005u:
            goto LABEL_118;
          case 0x170006u:
            goto LABEL_147;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864) {
          goto LABEL_111;
        }
        if (a2 == 1572865) {
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a4 != 0.0) << 15);
        }
        return result;
      case 0x19u:
        if (a2 == 1638402)
        {
LABEL_114:
          unsigned int v12 = a4;
LABEL_115:
          *(_DWORD *)(v7 + 28) = v12;
          return result;
        }
        if (a2 == 1638401)
        {
LABEL_87:
          unsigned int v13 = a4;
LABEL_148:
          *(_DWORD *)(v7 + 24) = v13;
          return result;
        }
        if (a2 != 1638400) {
          return result;
        }
        goto LABEL_69;
      case 0x1Au:
        if (a2 == 1703938) {
          goto LABEL_87;
        }
        if (a2 == 1703937)
        {
LABEL_119:
          *(unsigned char *)(v7 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = (int)a4;
          return result;
        }
        if (a2 != 1703936) {
          return result;
        }
LABEL_139:
        unsigned int v11 = a4;
        goto LABEL_140;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_76;
          case 0x1B0001u:
            goto LABEL_117;
          case 0x1B0002u:
            goto LABEL_116;
          case 0x1B0003u:
            goto LABEL_69;
          case 0x1B0004u:
            goto LABEL_154;
          case 0x1B0005u:
            goto LABEL_118;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_76:
            unsigned int v12 = a4;
            goto LABEL_115;
          case 0x1C0001u:
LABEL_117:
            *(_WORD *)(v7 + 32) = (int)a4;
            break;
          case 0x1C0002u:
            goto LABEL_116;
          case 0x1C0003u:
            goto LABEL_69;
          case 0x1C0004u:
            goto LABEL_154;
          case 0x1C0005u:
LABEL_118:
            *(_WORD *)(v7 + 34) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_139;
          case 0x1D0001u:
            goto LABEL_154;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = (int)a4;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = (int)a4;
            break;
          case 0x1D0004u:
            *(unsigned char *)(v7 + 32) = (int)a4;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        if (a2 == 1966082) {
          goto LABEL_87;
        }
        if (a2 == 1966081) {
          goto LABEL_154;
        }
        if (a2 != 1966080) {
          return result;
        }
        goto LABEL_139;
      case 0x1Fu:
        if (a2 == 2031617) {
          goto LABEL_157;
        }
        if (a2 != 2031616) {
          return result;
        }
        goto LABEL_69;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_111;
          case 0x200001u:
            goto LABEL_154;
          case 0x200002u:
            goto LABEL_87;
          case 0x200003u:
            goto LABEL_95;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689) {
          goto LABEL_154;
        }
        if (a2 != 2162688) {
          return result;
        }
        goto LABEL_139;
      case 0x22u:
        if (a2 == 2228225) {
          goto LABEL_154;
        }
        if (a2 != 2228224) {
          return result;
        }
LABEL_111:
        unsigned int v11 = a4;
        goto LABEL_140;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_111;
          case 0x230001u:
            goto LABEL_154;
          case 0x230002u:
            goto LABEL_147;
          case 0x230003u:
LABEL_95:
            unsigned int v12 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_115;
          case 0x230004u:
LABEL_160:
            unsigned int v10 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_161;
          case 0x230005u:
            unsigned int v18 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_200;
          case 0x230006u:
            unsigned int v20 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_202;
          case 0x230007u:
LABEL_116:
            unsigned int v15 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_129;
          case 0x230008u:
LABEL_162:
            unsigned int v17 = vcvtd_n_s64_f64(a4, 0x10uLL);
            goto LABEL_173;
          case 0x230009u:
LABEL_186:
            *(_DWORD *)(v7 + 68) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Au:
LABEL_196:
            *(_DWORD *)(v7 + 76) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Bu:
LABEL_187:
            *(_DWORD *)(v7 + 72) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Cu:
LABEL_197:
            *(_DWORD *)(v7 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Du:
LABEL_189:
            *(_DWORD *)(v7 + 52) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Eu:
LABEL_190:
            *(_DWORD *)(v7 + 56) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x23000Fu:
LABEL_215:
            *(_DWORD *)(v7 + 6(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230010u:
            *(_DWORD *)(v7 + 64) = vcvtd_n_s64_f64(a4, 0x10uLL);
            return result;
          case 0x230011u:
            char v22 = *(unsigned char *)(v7 + 84) & 0xFE | (a4 != 0.0);
            goto LABEL_206;
          case 0x230012u:
            char v22 = *(unsigned char *)(v7 + 84) & 0xFD | (2 * (a4 != 0.0));
LABEL_206:
            *(unsigned char *)(v7 + 84) = v22;
            break;
          case 0x230013u:
LABEL_198:
            *(_DWORD *)(v7 + 88) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230014u:
            unsigned int v23 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_219:
            *(_DWORD *)(v7 + 92) = v23;
            break;
          case 0x230015u:
            unsigned int v24 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_221:
            *(_DWORD *)(v7 + 96) = v24;
            break;
          case 0x230016u:
            unsigned int v25 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_223:
            *(_DWORD *)(v7 + 10(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v25;
            break;
          case 0x230017u:
            *(_DWORD *)(v7 + 104) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          case 0x230018u:
            *(_DWORD *)(v7 + 108) = vcvtd_n_s64_f64(a4, 0x10uLL);
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297) {
          goto LABEL_157;
        }
        if (a2 != 2359296) {
          return result;
        }
        goto LABEL_69;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(void *)(v7 + 24) = (unint64_t)a4;
            break;
          case 0x260001u:
            goto LABEL_154;
          case 0x260000u:
LABEL_69:
            unsigned int v11 = vcvtd_n_s64_f64(a4, 0x10uLL);
LABEL_140:
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1) {
          return result;
        }
        int v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 != 2555906) {
            return result;
          }
LABEL_154:
          unsigned int v16 = vcvtd_n_s64_f64(a4, 0x10uLL);
          goto LABEL_158;
        }
        if (!v14)
        {
          if (a2 != 2555905) {
            return result;
          }
          goto LABEL_157;
        }
        if (a2 == 2555905 && v14 == 2)
        {
LABEL_157:
          unsigned int v16 = a4;
LABEL_158:
          *(_DWORD *)(v7 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v16;
          return result;
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = (int)a4;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = (int)a4;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = a4;
            break;
          case 0x280003u:
LABEL_130:
            *(unsigned char *)(v7 + 24) = (int)a4;
            break;
          case 0x280004u:
LABEL_131:
            *(unsigned char *)(v7 + 25) = (int)a4;
            break;
          case 0x280005u:
            goto LABEL_114;
          case 0x280006u:
LABEL_121:
            unsigned int v10 = a4;
LABEL_161:
            *(_DWORD *)(v7 + 32) = v10;
            break;
          case 0x280007u:
LABEL_128:
            unsigned int v15 = a4;
LABEL_129:
            *(_DWORD *)(v7 + 36) = v15;
            break;
          case 0x280008u:
            *(unsigned char *)(v7 + 44) = (int)a4;
            break;
          case 0x280009u:
LABEL_171:
            unsigned int v20 = a4;
LABEL_202:
            *(_DWORD *)(v7 + 48) = v20;
            break;
          case 0x28000Au:
            *(void *)(v7 + 56) = (unint64_t)a4;
            break;
          case 0x28000Bu:
            *(unsigned char *)(v7 + 26) = (int)a4;
            break;
          case 0x28000Cu:
LABEL_172:
            unsigned int v17 = a4;
LABEL_173:
            *(_DWORD *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v17;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_111;
          case 0x290001u:
            goto LABEL_119;
          case 0x290002u:
            goto LABEL_132;
          case 0x290003u:
            goto LABEL_133;
          case 0x290004u:
LABEL_134:
            *(double *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a4;
            break;
          case 0x290005u:
            goto LABEL_122;
          case 0x290006u:
            goto LABEL_123;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_113:
            *(_WORD *)(v7 + 16) = (int)a4;
            break;
          case 0x2A0001u:
LABEL_120:
            *(_WORD *)(v7 + 18) = (int)a4;
            break;
          case 0x2A0002u:
LABEL_132:
            *(double *)(v7 + 24) = a4;
            break;
          case 0x2A0003u:
LABEL_133:
            *(double *)(v7 + 32) = a4;
            break;
          case 0x2A0004u:
            *(unsigned char *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a4 != 0.0;
            break;
          case 0x2A0005u:
LABEL_169:
            unsigned int v18 = a4;
LABEL_200:
            *(_DWORD *)(v7 + 44) = v18;
            break;
          case 0x2A0006u:
LABEL_122:
            *(double *)(v7 + 48) = a4;
            break;
          case 0x2A0007u:
LABEL_123:
            *(double *)(v7 + 56) = a4;
            break;
          case 0x2A0008u:
LABEL_149:
            *(double *)(v7 + 64) = a4;
            break;
          case 0x2A0009u:
LABEL_150:
            *(double *)(v7 + 72) = a4;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

void *IOHIDEventSetUInt64Value(void *a1, unsigned int a2, unint64_t a3)
{
  return IOHIDEventSetUInt64ValueWithOptions(a1, a2, a3, 4026531840);
}

void *IOHIDEventSetUInt64ValueWithOptions(void *result, unsigned int a2, unint64_t a3, uint64_t a4)
{
  unsigned int v6 = HIWORD(a2);
  if (result && a2 < 0x10000 || (unint64_t result = (void *)IOHIDEventGetEventWithOptions(result, HIWORD(a2), a4)) != 0)
  {
    uint64_t v7 = result[13];
    switch(v6)
    {
      case 0u:
        switch(a2)
        {
          case 0u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFE | (a3 != 0);
            goto LABEL_179;
          case 1u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFD | (2 * (a3 != 0));
            goto LABEL_179;
          case 2u:
            goto LABEL_21;
          case 3u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xF7 | (8 * (a3 != 0));
            goto LABEL_179;
          case 4u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xEF | (16 * (a3 != 0));
            goto LABEL_179;
          case 5u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xDF | (32 * (a3 != 0));
            goto LABEL_179;
          case 6u:
            char v8 = *(unsigned char *)(v7 + 8) & 0xBF | ((a3 != 0) << 6);
            goto LABEL_179;
          default:
            return result;
        }
        return result;
      case 1u:
        switch(a2)
        {
          case 0x10000u:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x10001u:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x10002u:
            goto LABEL_170;
          case 0x10004u:
            if (*(_DWORD *)(v7 + 24) >= 8u) {
              *(void *)(v7 + 28) = a3;
            }
            break;
          default:
            return result;
        }
        return result;
      case 2u:
        switch(a2)
        {
          case 0x20000u:
            goto LABEL_145;
          case 0x20001u:
            goto LABEL_133;
          case 0x20002u:
            goto LABEL_134;
          case 0x20003u:
            goto LABEL_151;
          case 0x20004u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 3u:
        switch(a2)
        {
          case 0x30000u:
            goto LABEL_118;
          case 0x30001u:
            goto LABEL_126;
          case 0x30002u:
            goto LABEL_170;
          case 0x30003u:
            goto LABEL_182;
          case 0x30004u:
            *(unsigned char *)(v7 + 28) = a3;
            break;
          case 0x30005u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFFE | (a3 != 0);
            goto LABEL_156;
          case 0x30006u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFF9 | (2 * (a3 & 3));
            goto LABEL_156;
          case 0x30007u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFFE7 | (8 * (a3 & 3));
            goto LABEL_156;
          case 0x30008u:
            *(_DWORD *)(v7 + 24) = *(_DWORD *)(v7 + 24) & 0xFFFFFFDF | (32 * (a3 != 0));
            break;
          case 0x30009u:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFFE3F | ((a3 & 7) << 6);
            goto LABEL_156;
          case 0x3000Au:
            unsigned int v10 = *(_DWORD *)(v7 + 24) & 0xFFFFF9FF | ((a3 & 3) << 9);
            goto LABEL_156;
          default:
            return result;
        }
        return result;
      case 4u:
        if (a2 == 262146) {
          goto LABEL_52;
        }
        if (a2 == 262145) {
          goto LABEL_165;
        }
        if (a2 != 0x40000) {
          return result;
        }
        goto LABEL_69;
      case 5u:
        if (a2 == 327682) {
          goto LABEL_154;
        }
        if (a2 == 327681) {
          goto LABEL_151;
        }
        if (a2 != 327680) {
          return result;
        }
        goto LABEL_105;
      case 6u:
        switch(a2)
        {
          case 0x60000u:
            goto LABEL_105;
          case 0x60001u:
            goto LABEL_151;
          case 0x60002u:
            goto LABEL_154;
          case 0x60003u:
LABEL_21:
            char v8 = *(unsigned char *)(v7 + 8) & 0xFB | (4 * (a3 != 0));
LABEL_179:
            *(unsigned char *)(v7 + 8) = v8;
            break;
          default:
            return result;
        }
        return result;
      case 7u:
        switch(a2)
        {
          case 0x70002u:
LABEL_52:
            unsigned int v10 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v10 = 0x80000000;
            }
            goto LABEL_156;
          case 0x70001u:
            goto LABEL_165;
          case 0x70000u:
            goto LABEL_69;
        }
        return result;
      case 9u:
        if (a2 == 589826)
        {
LABEL_154:
          unsigned int v10 = a3 << 16;
          if (a3 == 0x80000000) {
            unsigned int v10 = 0x80000000;
          }
LABEL_156:
          *(_DWORD *)(v7 + 24) = v10;
          return result;
        }
        if (a2 == 589825) {
          goto LABEL_151;
        }
        if (a2 != 589824) {
          return result;
        }
        goto LABEL_105;
      case 0xAu:
        if (a2 - 655364 < 8 || a2 - 655360 <= 2)
        {
          switch(*(_DWORD *)(v7 + 32))
          {
            case 0:
              switch(a2)
              {
                case 0xA0002u:
                  goto LABEL_154;
                case 0xA0001u:
                  goto LABEL_151;
                case 0xA0000u:
                  goto LABEL_105;
              }
              break;
            case 1:
              if (a2 == 655364) {
                goto LABEL_145;
              }
              break;
            case 2:
              switch(a2)
              {
                case 0xA0007u:
                  goto LABEL_154;
                case 0xA0006u:
                  goto LABEL_151;
                case 0xA0005u:
                  goto LABEL_105;
              }
              break;
            case 3:
              switch(a2)
              {
                case 0xA0008u:
                  goto LABEL_105;
                case 0xA0009u:
                  goto LABEL_151;
                case 0xA000Au:
                  goto LABEL_154;
                case 0xA000Bu:
                  goto LABEL_157;
                default:
                  return result;
              }
            default:
              return result;
          }
        }
        return result;
      case 0xBu:
        switch(a2)
        {
          case 0xB0000u:
            goto LABEL_69;
          case 0xB0001u:
            goto LABEL_165;
          case 0xB0002u:
            goto LABEL_52;
          case 0xB0003u:
            goto LABEL_183;
          case 0xB0004u:
            goto LABEL_127;
          case 0xB0005u:
            goto LABEL_119;
          case 0xB0006u:
            goto LABEL_132;
          case 0xB0007u:
            goto LABEL_184;
          case 0xB0008u:
LABEL_182:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFFEFFFF | ((a3 != 0) << 16);
            goto LABEL_257;
          case 0xB0009u:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFFDFFFF | ((a3 != 0) << 17);
            goto LABEL_257;
          case 0xB000Au:
            goto LABEL_208;
          case 0xB000Bu:
            goto LABEL_211;
          case 0xB000Cu:
            goto LABEL_253;
          case 0xB000Du:
          case 0xB000Eu:
          case 0xB000Fu:
          case 0xB0010u:
          case 0xB0011u:
          case 0xB0012u:
          case 0xB0013u:
          case 0xB0014u:
          case 0xB0015u:
          case 0xB001Au:
            int v9 = *(_DWORD *)(v7 + 64);
            if (v9)
            {
              if (v9 == 2)
              {
                switch(a2)
                {
                  case 0xB0011u:
                    goto LABEL_196;
                  case 0xB0012u:
                    goto LABEL_199;
                  case 0xB0013u:
                    goto LABEL_214;
                  case 0xB0014u:
                    goto LABEL_217;
                  case 0xB0015u:
LABEL_262:
                    unsigned int v38 = a3 << 16;
                    if (a3 == 0x80000000) {
                      unsigned int v38 = 0x80000000;
                    }
                    *(_DWORD *)(v7 + 84) = v38;
                    break;
                  case 0xB001Au:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              else
              {
                switch(a2)
                {
                  case 0xB000Fu:
                    goto LABEL_196;
                  case 0xB0010u:
                    goto LABEL_199;
                  case 0xB0011u:
                    goto LABEL_214;
                  case 0xB0012u:
                    goto LABEL_217;
                  case 0xB0014u:
                    goto LABEL_262;
                  case 0xB0015u:
                    goto LABEL_220;
                  default:
                    return result;
                }
              }
              return result;
            }
            if (a2 == 720910) {
              goto LABEL_199;
            }
            if (a2 != 720909) {
              return result;
            }
            goto LABEL_196;
          case 0xB0016u:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFFFFFFD | (2 * (a3 != 0));
            goto LABEL_257;
          case 0xB0017u:
            if (!*(_DWORD *)(v7 + 32)) {
              goto LABEL_253;
            }
            return result;
          case 0xB0018u:
            goto LABEL_181;
          case 0xB0019u:
            unsigned int v20 = *(_DWORD *)(v7 + 8) & 0xFFF7FFFF | ((a3 != 0) << 19);
LABEL_257:
            *(_DWORD *)(v7 + 8) = v20;
            return result;
          case 0xB001Bu:
            *(_DWORD *)(v7 + 92) = a3;
            return result;
          case 0xB001Cu:
            *(_DWORD *)(v7 + 96) = a3;
            return result;
          case 0xB001Du:
            *(_DWORD *)(v7 + 10(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
            return result;
          case 0xB001Eu:
            *(_DWORD *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = (a3 << 13) & 0x30000000 | (((a3 >> 10) & 1) << 30) & 0x70000000 | ((a3 >> 23) << 31) | *(_DWORD *)(v7 + 40) & 0xFFFFFFF;
            return result;
          default:
            return result;
        }
      case 0xCu:
        switch(a2)
        {
          case 0xC0000u:
            goto LABEL_116;
          case 0xC0001u:
            goto LABEL_170;
          case 0xC0002u:
            goto LABEL_88;
          case 0xC0003u:
            goto LABEL_119;
          case 0xC0004u:
            goto LABEL_127;
          case 0xC0005u:
            *(unsigned char *)(v7 + 36) = a3 != 0;
            break;
          case 0xC0006u:
            *(unsigned char *)(v7 + 37) = a3;
            break;
          case 0xC0007u:
            goto LABEL_137;
          case 0xC0008u:
            goto LABEL_128;
          case 0xC0009u:
            goto LABEL_129;
          case 0xC000Au:
            goto LABEL_160;
          case 0xC000Bu:
            goto LABEL_161;
          default:
            return result;
        }
        return result;
      case 0xDu:
        switch(a2)
        {
          case 0xD0000u:
            goto LABEL_69;
          case 0xD0001u:
            goto LABEL_165;
          case 0xD0002u:
            goto LABEL_52;
          case 0xD0003u:
            goto LABEL_119;
          case 0xD0004u:
            goto LABEL_127;
          case 0xD0005u:
            goto LABEL_132;
          default:
            return result;
        }
        return result;
      case 0xEu:
        switch(a2)
        {
          case 0xE0000u:
            goto LABEL_118;
          case 0xE0001u:
          case 0xE0003u:
            if (*(_WORD *)(v7 + 18) == 1)
            {
              if (a2 == 917507) {
                goto LABEL_143;
              }
              return result;
            }
            if (a2 != 917505 || *(_WORD *)(v7 + 18)) {
              return result;
            }
            break;
          case 0xE0002u:
            goto LABEL_126;
          default:
            return result;
        }
        goto LABEL_143;
      case 0xFu:
        if (a2 != 983040) {
          return result;
        }
        goto LABEL_69;
      case 0x10u:
        switch(a2)
        {
          case 0x100000u:
            goto LABEL_78;
          case 0x100001u:
            goto LABEL_123;
          case 0x100002u:
            goto LABEL_120;
          case 0x100003u:
            goto LABEL_105;
          case 0x100004u:
            goto LABEL_151;
          case 0x100005u:
            goto LABEL_124;
          case 0x100006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x11u:
        switch(a2)
        {
          case 0x110000u:
            goto LABEL_69;
          case 0x110001u:
            goto LABEL_165;
          case 0x110002u:
            goto LABEL_52;
          case 0x110003u:
            goto LABEL_119;
          default:
            return result;
        }
        return result;
      case 0x12u:
        if (a2 == 1179649) {
          goto LABEL_165;
        }
        if (a2 != 1179648) {
          return result;
        }
        goto LABEL_116;
      case 0x13u:
        switch(a2)
        {
          case 0x130000u:
            goto LABEL_105;
          case 0x130001u:
            goto LABEL_151;
          case 0x130002u:
            goto LABEL_154;
          case 0x130003u:
            goto LABEL_96;
          case 0x130004u:
            goto LABEL_120;
          case 0x130005u:
            goto LABEL_171;
          case 0x130006u:
            goto LABEL_78;
          default:
            return result;
        }
        return result;
      case 0x14u:
        switch(a2)
        {
          case 0x140000u:
            goto LABEL_105;
          case 0x140001u:
            goto LABEL_151;
          case 0x140002u:
            goto LABEL_154;
          case 0x140003u:
            goto LABEL_78;
          case 0x140004u:
            goto LABEL_61;
          case 0x140005u:
            goto LABEL_130;
          default:
            return result;
        }
        return result;
      case 0x15u:
        switch(a2)
        {
          case 0x150000u:
            goto LABEL_105;
          case 0x150001u:
            goto LABEL_151;
          case 0x150002u:
            goto LABEL_154;
          case 0x150003u:
            goto LABEL_78;
          case 0x150004u:
LABEL_61:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x150005u:
LABEL_130:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x17u:
        switch(a2)
        {
          case 0x170000u:
            goto LABEL_78;
          case 0x170001u:
            goto LABEL_123;
          case 0x170002u:
            goto LABEL_120;
          case 0x170003u:
            goto LABEL_105;
          case 0x170004u:
            goto LABEL_151;
          case 0x170005u:
            goto LABEL_124;
          case 0x170006u:
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x18u:
        if (a2 == 1572864) {
          goto LABEL_116;
        }
        if (a2 == 1572865) {
          *(_WORD *)(v7 + 8) = *(_WORD *)(v7 + 8) & 0x7FFF | ((a3 != 0) << 15);
        }
        return result;
      case 0x19u:
        switch(a2)
        {
          case 0x190002u:
LABEL_119:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x190001u:
LABEL_88:
            *(_DWORD *)(v7 + 24) = a3;
            break;
          case 0x190000u:
LABEL_69:
            unsigned int v11 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v11 = 0x80000000;
            }
            *(_DWORD *)(v7 + 16) = v11;
            break;
        }
        return result;
      case 0x1Au:
        switch(a2)
        {
          case 0x1A0002u:
            goto LABEL_88;
          case 0x1A0001u:
LABEL_125:
            *(unsigned char *)(v7 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
            break;
          case 0x1A0000u:
LABEL_145:
            *(_DWORD *)(v7 + 16) = a3;
            break;
        }
        return result;
      case 0x1Bu:
        switch(a2)
        {
          case 0x1B0000u:
            goto LABEL_78;
          case 0x1B0001u:
            goto LABEL_123;
          case 0x1B0002u:
            goto LABEL_120;
          case 0x1B0003u:
            goto LABEL_105;
          case 0x1B0004u:
            goto LABEL_151;
          case 0x1B0005u:
            goto LABEL_124;
          default:
            return result;
        }
        return result;
      case 0x1Cu:
        switch(a2)
        {
          case 0x1C0000u:
LABEL_78:
            *(_DWORD *)(v7 + 28) = a3;
            break;
          case 0x1C0001u:
LABEL_123:
            *(_WORD *)(v7 + 32) = a3;
            break;
          case 0x1C0002u:
            goto LABEL_120;
          case 0x1C0003u:
            goto LABEL_105;
          case 0x1C0004u:
            goto LABEL_151;
          case 0x1C0005u:
LABEL_124:
            *(_WORD *)(v7 + 34) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Du:
        switch(a2)
        {
          case 0x1D0000u:
            goto LABEL_145;
          case 0x1D0001u:
            goto LABEL_151;
          case 0x1D0002u:
            *(_WORD *)(v7 + 24) = a3;
            break;
          case 0x1D0003u:
            *(_WORD *)(v7 + 26) = a3;
            break;
          case 0x1D0004u:
            *(unsigned char *)(v7 + 32) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x1Eu:
        switch(a2)
        {
          case 0x1E0000u:
            goto LABEL_145;
          case 0x1E0001u:
            goto LABEL_151;
          case 0x1E0002u:
            goto LABEL_88;
          case 0x1E0003u:
            if (*(_DWORD *)(v7 + 24) >= 8u) {
              *(void *)(v7 + 28) = a3;
            }
            break;
          default:
            return result;
        }
        return result;
      case 0x1Fu:
        if (a2 == 2031617) {
          goto LABEL_143;
        }
        if (a2 != 2031616) {
          return result;
        }
        goto LABEL_105;
      case 0x20u:
        switch(a2)
        {
          case 0x200000u:
            goto LABEL_116;
          case 0x200001u:
            goto LABEL_165;
          case 0x200002u:
            goto LABEL_88;
          case 0x200003u:
            goto LABEL_157;
          default:
            return result;
        }
        return result;
      case 0x21u:
        if (a2 == 2162689) {
          goto LABEL_151;
        }
        if (a2 != 2162688) {
          return result;
        }
        goto LABEL_145;
      case 0x22u:
        if (a2 == 2228225) {
          goto LABEL_165;
        }
        if (a2 != 2228224) {
          return result;
        }
LABEL_116:
        *(_DWORD *)(v7 + 16) = a3;
        return result;
      case 0x23u:
        switch(a2)
        {
          case 0x230000u:
            goto LABEL_116;
          case 0x230001u:
            goto LABEL_165;
          case 0x230002u:
            goto LABEL_52;
          case 0x230003u:
LABEL_157:
            unsigned int v17 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v17 = 0x80000000;
            }
            *(_DWORD *)(v7 + 28) = v17;
            return result;
          case 0x230004u:
LABEL_96:
            unsigned int v12 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v12 = 0x80000000;
            }
            *(_DWORD *)(v7 + 32) = v12;
            return result;
          case 0x230005u:
            unsigned int v28 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v28 = 0x80000000;
            }
            *(_DWORD *)(v7 + 44) = v28;
            return result;
          case 0x230006u:
            unsigned int v29 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v29 = 0x80000000;
            }
            *(_DWORD *)(v7 + 48) = v29;
            return result;
          case 0x230007u:
LABEL_120:
            unsigned int v15 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v15 = 0x80000000;
            }
            *(_DWORD *)(v7 + 36) = v15;
            return result;
          case 0x230008u:
LABEL_171:
            unsigned int v19 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v19 = 0x80000000;
            }
            *(_DWORD *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v19;
            return result;
          case 0x230009u:
LABEL_196:
            unsigned int v21 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v21 = 0x80000000;
            }
            *(_DWORD *)(v7 + 68) = v21;
            return result;
          case 0x23000Au:
LABEL_214:
            unsigned int v25 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v25 = 0x80000000;
            }
            *(_DWORD *)(v7 + 76) = v25;
            return result;
          case 0x23000Bu:
LABEL_199:
            unsigned int v22 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v22 = 0x80000000;
            }
            *(_DWORD *)(v7 + 72) = v22;
            return result;
          case 0x23000Cu:
LABEL_217:
            unsigned int v26 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v26 = 0x80000000;
            }
            *(_DWORD *)(v7 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v26;
            return result;
          case 0x23000Du:
LABEL_208:
            unsigned int v23 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v23 = 0x80000000;
            }
            *(_DWORD *)(v7 + 52) = v23;
            return result;
          case 0x23000Eu:
LABEL_211:
            unsigned int v24 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v24 = 0x80000000;
            }
            *(_DWORD *)(v7 + 56) = v24;
            return result;
          case 0x23000Fu:
LABEL_253:
            unsigned int v37 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v37 = 0x80000000;
            }
            *(_DWORD *)(v7 + 6(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v37;
            return result;
          case 0x230010u:
            unsigned int v30 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v30 = 0x80000000;
            }
            *(_DWORD *)(v7 + 64) = v30;
            return result;
          case 0x230011u:
            char v31 = *(unsigned char *)(v7 + 84) & 0xFE | (a3 != 0);
            goto LABEL_234;
          case 0x230012u:
            char v31 = *(unsigned char *)(v7 + 84) & 0xFD | (2 * (a3 != 0));
LABEL_234:
            *(unsigned char *)(v7 + 84) = v31;
            break;
          case 0x230013u:
LABEL_220:
            unsigned int v27 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v27 = 0x80000000;
            }
            *(_DWORD *)(v7 + 88) = v27;
            break;
          case 0x230014u:
            unsigned int v32 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v32 = 0x80000000;
            }
            *(_DWORD *)(v7 + 92) = v32;
            break;
          case 0x230015u:
            unsigned int v33 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v33 = 0x80000000;
            }
            *(_DWORD *)(v7 + 96) = v33;
            break;
          case 0x230016u:
            unsigned int v34 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v34 = 0x80000000;
            }
            *(_DWORD *)(v7 + 10(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v34;
            break;
          case 0x230017u:
            unsigned int v35 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v35 = 0x80000000;
            }
            *(_DWORD *)(v7 + 104) = v35;
            break;
          case 0x230018u:
            unsigned int v36 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v36 = 0x80000000;
            }
            *(_DWORD *)(v7 + 108) = v36;
            break;
          default:
            return result;
        }
        return result;
      case 0x24u:
        if (a2 == 2359297)
        {
LABEL_143:
          *(_DWORD *)(v7 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
        }
        else if (a2 == 2359296)
        {
          goto LABEL_105;
        }
        return result;
      case 0x26u:
        switch(a2)
        {
          case 0x260002u:
            *(void *)(v7 + 24) = a3;
            break;
          case 0x260001u:
LABEL_151:
            unsigned int v16 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v16 = 0x80000000;
            }
            *(_DWORD *)(v7 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v16;
            break;
          case 0x260000u:
LABEL_105:
            unsigned int v13 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v13 = 0x80000000;
            }
            *(_DWORD *)(v7 + 16) = v13;
            break;
        }
        return result;
      case 0x27u:
        if (a2 - 2555905 > 1) {
          return result;
        }
        int v14 = *(_DWORD *)(v7 + 16);
        if (v14 == 1)
        {
          if (a2 == 2555906)
          {
LABEL_165:
            unsigned int v18 = a3 << 16;
            if (a3 == 0x80000000) {
              unsigned int v18 = 0x80000000;
            }
            *(_DWORD *)(v7 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v18;
          }
        }
        else
        {
          if (!v14)
          {
            if (a2 != 2555905) {
              return result;
            }
            goto LABEL_170;
          }
          if (a2 == 2555905 && v14 == 2)
          {
LABEL_170:
            *(_DWORD *)(v7 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
            return result;
          }
        }
        break;
      case 0x28u:
        switch(a2)
        {
          case 0x280000u:
            *(_WORD *)(v7 + 64) = a3;
            break;
          case 0x280001u:
            *(_WORD *)(v7 + 66) = a3;
            break;
          case 0x280002u:
            *(double *)(v7 + 16) = (double)a3;
            break;
          case 0x280003u:
LABEL_133:
            *(unsigned char *)(v7 + 24) = a3;
            break;
          case 0x280004u:
LABEL_134:
            *(unsigned char *)(v7 + 25) = a3;
            break;
          case 0x280005u:
            goto LABEL_119;
          case 0x280006u:
LABEL_127:
            *(_DWORD *)(v7 + 32) = a3;
            break;
          case 0x280007u:
LABEL_132:
            *(_DWORD *)(v7 + 36) = a3;
            break;
          case 0x280008u:
            *(unsigned char *)(v7 + 44) = a3;
            break;
          case 0x280009u:
LABEL_183:
            *(_DWORD *)(v7 + 48) = a3;
            break;
          case 0x28000Au:
            *(void *)(v7 + 56) = a3;
            break;
          case 0x28000Bu:
            *(unsigned char *)(v7 + 26) = a3;
            break;
          case 0x28000Cu:
LABEL_184:
            *(_DWORD *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
            break;
          default:
            return result;
        }
        return result;
      case 0x29u:
        switch(a2)
        {
          case 0x290000u:
            goto LABEL_116;
          case 0x290001u:
            goto LABEL_125;
          case 0x290002u:
            goto LABEL_135;
          case 0x290003u:
            goto LABEL_136;
          case 0x290004u:
LABEL_137:
            *(double *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = (double)a3;
            break;
          case 0x290005u:
            goto LABEL_128;
          case 0x290006u:
            goto LABEL_129;
          default:
            return result;
        }
        return result;
      case 0x2Au:
        switch(a2)
        {
          case 0x2A0000u:
LABEL_118:
            *(_WORD *)(v7 + 16) = a3;
            break;
          case 0x2A0001u:
LABEL_126:
            *(_WORD *)(v7 + 18) = a3;
            break;
          case 0x2A0002u:
LABEL_135:
            *(double *)(v7 + 24) = (double)a3;
            break;
          case 0x2A0003u:
LABEL_136:
            *(double *)(v7 + 32) = (double)a3;
            break;
          case 0x2A0004u:
            *(unsigned char *)(v7 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3 != 0;
            break;
          case 0x2A0005u:
LABEL_181:
            *(_DWORD *)(v7 + 44) = a3;
            break;
          case 0x2A0006u:
LABEL_128:
            *(double *)(v7 + 48) = (double)a3;
            break;
          case 0x2A0007u:
LABEL_129:
            *(double *)(v7 + 56) = (double)a3;
            break;
          case 0x2A0008u:
LABEL_160:
            *(double *)(v7 + 64) = (double)a3;
            break;
          case 0x2A0009u:
LABEL_161:
            *(double *)(v7 + 72) = (double)a3;
            break;
          default:
            return result;
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

uint64_t IOHIDEventGetIntegerMultiple(uint64_t result, unsigned int *a2, uint64_t *a3, uint64_t a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = a4;
    uint64_t v7 = (void *)result;
    do
    {
      unsigned int v8 = *a2++;
      unint64_t result = IOHIDEventGetIntegerValueWithOptions(v7, v8, 0);
      *a3++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t IOHIDEventGetIntegerMultipleWithOptions(uint64_t result, unsigned int *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= 1)
  {
    uint64_t v6 = a4;
    int v9 = (void *)result;
    do
    {
      unsigned int v10 = *a2++;
      unint64_t result = IOHIDEventGetIntegerValueWithOptions(v9, v10, a5);
      *a3++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

void IOHIDEventGetFloatMultiple(void *a1, unsigned int *a2, __n64 *a3, uint64_t a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = a4;
    do
    {
      unsigned int v8 = *a2++;
      a3->n64_u64[0] = IOHIDEventGetFloatValueWithOptions(a1, v8, 0).n64_u64[0];
      ++a3;
      --v4;
    }
    while (v4);
  }
}

void IOHIDEventGetFloatMultipleWithOptions(void *a1, unsigned int *a2, __n64 *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= 1)
  {
    uint64_t v6 = a4;
    do
    {
      unsigned int v10 = *a2++;
      a3->n64_u64[0] = IOHIDEventGetFloatValueWithOptions(a1, v10, a5).n64_u64[0];
      ++a3;
      --v6;
    }
    while (v6);
  }
}

unint64_t IOHIDEventGetUInt64Multiple(unint64_t result, unsigned int *a2, unint64_t *a3, uint64_t a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = a4;
    uint64_t v7 = (void *)result;
    do
    {
      unsigned int v8 = *a2++;
      unint64_t result = IOHIDEventGetUInt64ValueWithOptions(v7, v8, 0);
      *a3++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

unint64_t IOHIDEventGetUInt64MultipleWithOptions(unint64_t result, unsigned int *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= 1)
  {
    uint64_t v6 = a4;
    int v9 = (void *)result;
    do
    {
      unsigned int v10 = *a2++;
      unint64_t result = IOHIDEventGetUInt64ValueWithOptions(v9, v10, a5);
      *a3++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

void *IOHIDEventSetIntegerMultiple(void *result, unsigned int *a2, uint64_t *a3, uint64_t a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = a4;
    uint64_t v7 = result;
    do
    {
      unsigned int v9 = *a2++;
      unsigned int v8 = v9;
      uint64_t v10 = *a3++;
      unint64_t result = IOHIDEventSetIntegerValueWithOptions(v7, v8, v10, 0);
      --v4;
    }
    while (v4);
  }
  return result;
}

void *IOHIDEventSetIntegerMultipleWithOptions(void *result, unsigned int *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= 1)
  {
    uint64_t v6 = a4;
    unsigned int v9 = result;
    do
    {
      unsigned int v11 = *a2++;
      unsigned int v10 = v11;
      uint64_t v12 = *a3++;
      unint64_t result = IOHIDEventSetIntegerValueWithOptions(v9, v10, v12, a5);
      --v6;
    }
    while (v6);
  }
  return result;
}

void *IOHIDEventSetFloatMultiple(void *result, unsigned int *a2, double *a3, uint64_t a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = a4;
    uint64_t v7 = result;
    do
    {
      unsigned int v9 = *a2++;
      unsigned int v8 = v9;
      double v10 = *a3++;
      unint64_t result = IOHIDEventSetFloatValueWithOptions(v7, v8, 0, v10);
      --v4;
    }
    while (v4);
  }
  return result;
}

void *IOHIDEventSetFloatMultipleWithOptions(void *result, unsigned int *a2, double *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= 1)
  {
    uint64_t v6 = a4;
    unsigned int v9 = result;
    do
    {
      unsigned int v11 = *a2++;
      unsigned int v10 = v11;
      double v12 = *a3++;
      unint64_t result = IOHIDEventSetFloatValueWithOptions(v9, v10, a5, v12);
      --v6;
    }
    while (v6);
  }
  return result;
}

void *IOHIDEventSetDoubleMultiple(void *result, unsigned int *a2, double *a3, uint64_t a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = a4;
    uint64_t v7 = result;
    do
    {
      unsigned int v9 = *a2++;
      unsigned int v8 = v9;
      double v10 = *a3++;
      unint64_t result = IOHIDEventSetDoubleValueWithOptions(v7, v8, 0, v10);
      --v4;
    }
    while (v4);
  }
  return result;
}

void *IOHIDEventSetDoubleMultipleWithOptions(void *result, unsigned int *a2, double *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= 1)
  {
    uint64_t v6 = a4;
    unsigned int v9 = result;
    do
    {
      unsigned int v11 = *a2++;
      unsigned int v10 = v11;
      double v12 = *a3++;
      unint64_t result = IOHIDEventSetDoubleValueWithOptions(v9, v10, a5, v12);
      --v6;
    }
    while (v6);
  }
  return result;
}

void *IOHIDEventSetUInt64Multiple(void *result, unsigned int *a2, unint64_t *a3, uint64_t a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = a4;
    uint64_t v7 = result;
    do
    {
      unsigned int v9 = *a2++;
      unsigned int v8 = v9;
      unint64_t v10 = *a3++;
      unint64_t result = IOHIDEventSetUInt64ValueWithOptions(v7, v8, v10, 0);
      --v4;
    }
    while (v4);
  }
  return result;
}

void *IOHIDEventSetUInt64MultipleWithOptions(void *result, unsigned int *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (a4 >= 1)
  {
    uint64_t v6 = a4;
    unsigned int v9 = result;
    do
    {
      unsigned int v11 = *a2++;
      unsigned int v10 = v11;
      unint64_t v12 = *a3++;
      unint64_t result = IOHIDEventSetUInt64ValueWithOptions(v9, v10, v12, a5);
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t IOHIDEventGetParent(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t IOHIDEventRemoveEvent(uint64_t result, void *a2)
{
  if (a2)
  {
    if (*(void *)(result + 72))
    {
      uint64_t v3 = a2[10];
      if (v3)
      {
        uint64_t v4 = 0;
        unsigned int v5 = (void *)a2[10];
        do
        {
          uint64_t v6 = v5;
          if (v5 == (void *)result) {
            uint64_t v4 = v5;
          }
          unsigned int v5 = (void *)v5[10];
        }
        while (v5);
        if (v4)
        {
          CFArrayRef v7 = *(const __CFArray **)(v3 + 72);
          v9.CFIndex length = CFArrayGetCount(v7);
          v9.location = 0;
          unint64_t result = CFArrayGetFirstIndexOfValue(v7, v9, a2);
          if (result != -1)
          {
            a2[10] = 0;
            CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 72), result);
            return __IOHIDEventFixTypeEventMask(v6);
          }
        }
      }
    }
  }
  return result;
}

uint64_t __IOHIDEventFixTypeEventMask(void *a1)
{
  a1[3] = 1 << *(_DWORD *)(a1[13] + 4);
  uint64_t result = a1[9];
  if (result)
  {
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      uint64_t v3 = result;
      for (CFIndex i = 0; i != v3; ++i)
      {
        uint64_t result = (uint64_t)CFArrayGetValueAtIndex((CFArrayRef)a1[9], i);
        if (result)
        {
          uint64_t v5 = result;
          uint64_t result = __IOHIDEventFixTypeEventMask();
          a1[3] |= *(void *)(v5 + 24);
        }
      }
    }
  }
  return result;
}

__CFData *IOHIDEventCreateData(const __CFAllocator *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  LengthAndCFIndex Count = __IOHIDEventGetLengthAndCount(a2, (void *)(a2 + 96));
  if (!LengthAndCount) {
    return 0;
  }
  CFIndex v5 = LengthAndCount + *(void *)(a2 + 88) + 28;
  CFDictionaryRef Mutable = CFDataCreateMutable(a1, v5);
  CFArrayRef v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    __IOHIDEventReadBytesHelper(a2, (uint64_t)MutableBytePtr, v5);
  }
  return v7;
}

void *IOHIDEventGetAttributeData(uint64_t a1, void *__dst, int64_t a3)
{
  if (*(void *)(a1 + 88) < a3) {
    a3 = *(void *)(a1 + 88);
  }
  return memmove(__dst, *(const void **)(a1 + 40), a3);
}

const char *IOHIDEventGetTypeString(unsigned int a1)
{
  Name = IOHIDEventTypeGetName(a1);
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();

  return CFStringGetCStringPtr(Name, SystemEncoding);
}

void __IOHIDEventTypeDescriptorVendorDefined(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "UsagePage:", *(unsigned __int16 *)(v6 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Usage:", *(unsigned __int16 *)(v6 + 18));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Version:", *(unsigned int *)(v6 + 20));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "DataLength:", *(unsigned int *)(v6 + 24));
  if (__PAIR64__(*(unsigned __int16 *)(v6 + 18), *(__int16 *)(v6 + 16)) == 0x26FFFFFF00)
  {
    uint64_t TimeStamp = IOHIDEventGetTimeStamp(a1);
    uint64_t v8 = *(void *)(v6 + 28);
    if (v8) {
      unint64_t v9 = _IOHIDGetTimestampDelta(v8, TimeStamp, 0x3E8u);
    }
    else {
      unint64_t v9 = 0;
    }
    uint64_t v10 = *(void *)(v6 + 36);
    if (v10) {
      unint64_t v11 = _IOHIDGetTimestampDelta(v10, TimeStamp, 0x3E8u);
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t v12 = *(void *)(v6 + 44);
    if (v12) {
      unint64_t v13 = _IOHIDGetTimestampDelta(v12, TimeStamp, 0x3E8u);
    }
    else {
      unint64_t v13 = 0;
    }
    uint64_t v14 = *(void *)(v6 + 52);
    if (v14) {
      unint64_t v15 = _IOHIDGetTimestampDelta(v14, TimeStamp, 0x3E8u);
    }
    else {
      unint64_t v15 = 0;
    }
    unint64_t v16 = *(void *)(v6 + 60);
    if (v16) {
      unint64_t v16 = _IOHIDGetTimestampDelta(v16, TimeStamp, 0x3E8u);
    }
    _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %-8llu %-8llu %-8llu %-8llu %-8llu\n", "Dispatch Latency:", v9, v11, v13, v15, v16);
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s ", "Data:");
  if (*(_DWORD *)(v6 + 24))
  {
    unint64_t v17 = 0;
    do
      _IOHIDStringAppendIndendationAndFormat(theString, 0, @"%02x ", *(unsigned __int8 *)(v6 + 28 + v17++));
    while (v17 < *(unsigned int *)(v6 + 24));
  }

  _IOHIDStringAppendIndendationAndFormat(theString, 0, @"\n");
}

void __IOHIDEventTypeDescriptorButton(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s 0x%08x\n", "Mask:", *(unsigned int *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Number:", *(unsigned __int8 *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "State:", *(unsigned int *)(v5 + 28));
  int v6 = *(_DWORD *)(v5 + 20);
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Pressure:", *(void *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "ClickCount:", *(unsigned __int8 *)(v5 + 25));
}

void __IOHIDEventTypeDescriptorKeyboard(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  int v6 = *(_DWORD *)(v5 + 8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "UsagePage:", *(unsigned __int16 *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Usage:", *(unsigned __int16 *)(v5 + 18));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Down:", *(unsigned int *)(v5 + 20));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "PressCount:", *(unsigned __int8 *)(v5 + 28));
  if (*(_DWORD *)(v5 + 24)) {
    double v7 = "yes";
  }
  else {
    double v7 = "no";
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "LongPress:", v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "ClickSpeed:", (*(_DWORD *)(v5 + 24) >> 1) & 3);
  uint64_t v8 = "begin";
  unint64_t v9 = "";
  if ((v6 & 0x1000000) == 0) {
    uint64_t v8 = "";
  }
  if ((v6 & 0x4000000) != 0) {
    unint64_t v9 = "ended";
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s%s\n", "Phase:", v8, v9);
  unsigned int v10 = *(_DWORD *)(v5 + 24);
  uint64_t v11 = (v10 >> 9) & 3;
  if (v11)
  {
    uint64_t v12 = "Off";
    if (v11 == 1) {
      uint64_t v12 = "On";
    }
    _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s (%d)\n", "Sticky Key Toggle:", v12, v11);
    unsigned int v10 = *(_DWORD *)(v5 + 24);
  }
  uint64_t v13 = (v10 >> 6) & 7;
  if (v13)
  {
    uint64_t v14 = "Down";
    unint64_t v15 = "Locked";
    if (v13 == 3) {
      unint64_t v15 = "Up";
    }
    if (v13 != 1) {
      uint64_t v14 = v15;
    }
    _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s (%d)\n", "Sticky Key Phase:", v14, v13);
  }
}

void __IOHIDEventTypeDescriptorTranslation(void *a1, __CFString *a2, int a3)
{
  uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(a1, 4, 4026531840);
  double v7 = 0.0;
  double v8 = 0.0;
  if (EventWithOptions)
  {
    int v9 = *(_DWORD *)(*(void *)(EventWithOptions + 104) + 16);
    double v8 = (double)v9 * 0.0000152587891;
    if (v9 == 0x80000000) {
      double v8 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "X:", *(void *)&v8);
  uint64_t v10 = IOHIDEventGetEventWithOptions(a1, 4, 4026531840);
  if (v10)
  {
    int v11 = *(_DWORD *)(*(void *)(v10 + 104) + 20);
    if (v11 == 0x80000000) {
      double v7 = NAN;
    }
    else {
      double v7 = (double)v11 * 0.0000152587891;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "Y:", *(void *)&v7);
  uint64_t v12 = IOHIDEventGetEventWithOptions(a1, 4, 4026531840);
  if (v12)
  {
    int v13 = *(_DWORD *)(*(void *)(v12 + 104) + 24);
    double v14 = (double)v13 * 0.0000152587891;
    if (v13 == 0x80000000) {
      double v14 = NAN;
    }
  }
  else
  {
    double v14 = 0.0;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "Z:", *(void *)&v14);
}

void __IOHIDEventTypeDescriptorAxis(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(_DWORD **)(a1 + 104);
  int v6 = v5[4];
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "X:", *(void *)&v7);
  int v8 = v5[5];
  double v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000) {
    double v9 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Y:", *(void *)&v9);
  int v10 = v5[6];
  double v11 = (double)v10 * 0.0000152587891;
  if (v10 == 0x80000000) {
    double v11 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Z:", *(void *)&v11);
}

void __IOHIDEventTypeDescriptorScroll(uint64_t a1, __CFString *a2, int a3)
{
  __IOHIDEventTypeDescriptorAxis(a1, a2, a3);
  unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 104) + 8);
  uint64_t v7 = HIBYTE(v6);
  if (v7)
  {
    _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s 0x%x\n", "phase:", v7);
    unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 104) + 8);
  }
  uint64_t v8 = (v6 >> 6) & 0x18 | (v6 >> 28) & 7;
  if (v8) {
    _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s 0x%x\n", "momentum:", v8);
  }
}

void __IOHIDEventTypeDescriptorOrientation(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(_DWORD **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Orientation type:", v5[8]);
  switch(v5[8])
  {
    case 0:
    case 2:
      int v6 = v5[4];
      double v7 = (double)v6 * 0.0000152587891;
      if (v6 == 0x80000000) {
        double v7 = NAN;
      }
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "X:", *(void *)&v7);
      int v8 = v5[5];
      double v9 = (double)v8 * 0.0000152587891;
      if (v8 == 0x80000000) {
        double v9 = NAN;
      }
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Y:", *(void *)&v9);
      int v10 = v5[6];
      goto LABEL_15;
    case 1:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Orientation usage:", v5[4]);
      break;
    case 3:
      int v11 = v5[4];
      double v12 = (double)v11 * 0.0000152587891;
      if (v11 == 0x80000000) {
        double v12 = NAN;
      }
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "W:", *(void *)&v12);
      int v13 = v5[5];
      double v14 = (double)v13 * 0.0000152587891;
      if (v13 == 0x80000000) {
        double v14 = NAN;
      }
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "X:", *(void *)&v14);
      int v15 = v5[6];
      double v16 = (double)v15 * 0.0000152587891;
      if (v15 == 0x80000000) {
        double v16 = NAN;
      }
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Y:", *(void *)&v16);
      int v10 = v5[7];
LABEL_15:
      double v17 = (double)v10 * 0.0000152587891;
      if (v10 == 0x80000000) {
        double v17 = NAN;
      }
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Z:", *(void *)&v17);
      break;
    default:
      return;
  }
}

void __IOHIDEventTypeDescriptorDigitizer(void *a1, __CFString *a2, int a3)
{
  int v6 = (_DWORD *)a1[13];
  uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (EventWithOptions) {
    unint64_t v8 = ((unint64_t)*(unsigned int *)(*(void *)(EventWithOptions + 104) + 8) >> 1) & 1;
  }
  else {
    unint64_t v8 = 0;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "DisplayIntegrated:", (v6[2] >> 19) & 1);
  double v9 = "Stylus";
  switch(v6[8])
  {
    case 0:
      break;
    case 1:
      double v9 = "Puck";
      break;
    case 2:
      if (v8) {
        goto LABEL_8;
      }
      double v9 = "Finger";
      break;
    case 3:
LABEL_8:
      double v9 = "Hand";
      break;
    default:
      double v9 = "Unknown";
      break;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %s\n", "TransducerType:", v9);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "TransducerIndex:", v6[7]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "Identity:", v6[9]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "EventMask:", v6[10]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s ", "Events:");
  int v10 = v6[10];
  if (v10)
  {
    _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Range ");
    int v10 = v6[10];
    if ((v10 & 2) == 0)
    {
LABEL_12:
      if ((v10 & 4) == 0) {
        goto LABEL_13;
      }
      goto LABEL_63;
    }
  }
  else if ((v10 & 2) == 0)
  {
    goto LABEL_12;
  }
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Touch ");
  int v10 = v6[10];
  if ((v10 & 4) == 0)
  {
LABEL_13:
    if ((v10 & 8) == 0) {
      goto LABEL_14;
    }
    goto LABEL_64;
  }
LABEL_63:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Position ");
  int v10 = v6[10];
  if ((v10 & 8) == 0)
  {
LABEL_14:
    if ((v10 & 0x10) == 0) {
      goto LABEL_15;
    }
    goto LABEL_65;
  }
LABEL_64:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Stop ");
  int v10 = v6[10];
  if ((v10 & 0x10) == 0)
  {
LABEL_15:
    if ((v10 & 0x20) == 0) {
      goto LABEL_16;
    }
    goto LABEL_66;
  }
LABEL_65:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Peak ");
  int v10 = v6[10];
  if ((v10 & 0x20) == 0)
  {
LABEL_16:
    if ((v10 & 0x40) == 0) {
      goto LABEL_17;
    }
    goto LABEL_67;
  }
LABEL_66:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Identity ");
  int v10 = v6[10];
  if ((v10 & 0x40) == 0)
  {
LABEL_17:
    if ((v10 & 0x80) == 0) {
      goto LABEL_18;
    }
    goto LABEL_68;
  }
LABEL_67:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Attribute ");
  int v10 = v6[10];
  if ((v10 & 0x80) == 0)
  {
LABEL_18:
    if ((v10 & 0x100) == 0) {
      goto LABEL_19;
    }
    goto LABEL_69;
  }
LABEL_68:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Cancel ");
  int v10 = v6[10];
  if ((v10 & 0x100) == 0)
  {
LABEL_19:
    if ((v10 & 0x200) == 0) {
      goto LABEL_20;
    }
    goto LABEL_70;
  }
LABEL_69:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Start ");
  int v10 = v6[10];
  if ((v10 & 0x200) == 0)
  {
LABEL_20:
    if ((v10 & 0x400) == 0) {
      goto LABEL_21;
    }
    goto LABEL_71;
  }
LABEL_70:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Resting ");
  int v10 = v6[10];
  if ((v10 & 0x400) == 0)
  {
LABEL_21:
    if ((v10 & 0x800) == 0) {
      goto LABEL_22;
    }
    goto LABEL_72;
  }
LABEL_71:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"FromEdgeFlat ");
  int v10 = v6[10];
  if ((v10 & 0x800) == 0)
  {
LABEL_22:
    if ((v10 & 0x1000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_73;
  }
LABEL_72:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"FromEdgeTip ");
  int v10 = v6[10];
  if ((v10 & 0x1000) == 0)
  {
LABEL_23:
    if ((v10 & 0x2000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_74;
  }
LABEL_73:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"FromCorner ");
  int v10 = v6[10];
  if ((v10 & 0x2000) == 0)
  {
LABEL_24:
    if ((v10 & 0x4000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_75;
  }
LABEL_74:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"SwipePending ");
  int v10 = v6[10];
  if ((v10 & 0x4000) == 0)
  {
LABEL_25:
    if ((v10 & 0x8000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_76;
  }
LABEL_75:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"ForcePending ");
  int v10 = v6[10];
  if ((v10 & 0x8000) == 0)
  {
LABEL_26:
    if ((v10 & 0x20000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_77;
  }
LABEL_76:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"ForceActive ");
  int v10 = v6[10];
  if ((v10 & 0x20000) == 0)
  {
LABEL_27:
    if ((v10 & 0x40000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_78;
  }
LABEL_77:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"Tap ");
  int v10 = v6[10];
  if ((v10 & 0x40000) == 0)
  {
LABEL_28:
    if ((v10 & 0x1000000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_79;
  }
LABEL_78:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"SwipeLocked ");
  int v10 = v6[10];
  if ((v10 & 0x1000000) == 0)
  {
LABEL_29:
    if ((v10 & 0x2000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_80;
  }
LABEL_79:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"SwipeUp ");
  int v10 = v6[10];
  if ((v10 & 0x2000000) == 0)
  {
LABEL_30:
    if ((v10 & 0x4000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_81;
  }
LABEL_80:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"SwipeDown ");
  int v10 = v6[10];
  if ((v10 & 0x4000000) == 0)
  {
LABEL_31:
    if ((v10 & 0x8000000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_82;
  }
LABEL_81:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"SwipeLeft ");
  int v10 = v6[10];
  if ((v10 & 0x8000000) == 0)
  {
LABEL_32:
    if ((v10 & 0x10000000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_83;
  }
LABEL_82:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"SwipeRight ");
  int v10 = v6[10];
  if ((v10 & 0x10000000) == 0)
  {
LABEL_33:
    if ((v10 & 0x20000000) == 0) {
      goto LABEL_34;
    }
LABEL_84:
    _IOHIDStringAppendIndendationAndFormat(a2, 0, @"EstimatedAzimuth ");
    if ((v6[10] & 0x40000000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
LABEL_83:
  _IOHIDStringAppendIndendationAndFormat(a2, 0, @"EstimatedAltitude ");
  int v10 = v6[10];
  if ((v10 & 0x20000000) != 0) {
    goto LABEL_84;
  }
LABEL_34:
  if ((v10 & 0x40000000) != 0) {
LABEL_35:
  }
    _IOHIDStringAppendIndendationAndFormat(a2, 0, @"EstimatedPressure ");
LABEL_36:
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"\n");
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "ButtonMask:", v6[12]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "Range:", HIWORD(v6[2]) & 1);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "Touch:", (v6[2] >> 17) & 1);
  uint64_t v11 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  double v12 = 0.0;
  double v13 = 0.0;
  if (v11)
  {
    int v14 = *(_DWORD *)(*(void *)(v11 + 104) + 52);
    double v13 = (double)v14 * 0.0000152587891;
    if (v14 == 0x80000000) {
      double v13 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "Pressure:", *(void *)&v13);
  uint64_t v15 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (v15)
  {
    int v16 = *(_DWORD *)(*(void *)(v15 + 104) + 56);
    if (v16 == 0x80000000) {
      double v12 = NAN;
    }
    else {
      double v12 = (double)v16 * 0.0000152587891;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "AuxiliaryPressure:", *(void *)&v12);
  uint64_t v17 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  double v18 = 0.0;
  double v19 = 0.0;
  if (v17)
  {
    int v20 = *(_DWORD *)(*(void *)(v17 + 104) + 60);
    double v19 = (double)v20 * 0.0000152587891;
    if (v20 == 0x80000000) {
      double v19 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "Twist:", *(void *)&v19);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %d\n", "GenerationCount:", v6[23]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %08x\n", "WillUpdateMask:", v6[24]);
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %08x\n", "DidUpdateMask:", v6[25]);
  uint64_t v21 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (v21)
  {
    int v22 = *(_DWORD *)(*(void *)(v21 + 104) + 16);
    if (v22 == 0x80000000) {
      double v18 = NAN;
    }
    else {
      double v18 = (double)v22 * 0.0000152587891;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "X:", *(void *)&v18);
  uint64_t v23 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  double v24 = 0.0;
  double v25 = 0.0;
  if (v23)
  {
    int v26 = *(_DWORD *)(*(void *)(v23 + 104) + 20);
    double v25 = (double)v26 * 0.0000152587891;
    if (v26 == 0x80000000) {
      double v25 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "Y:", *(void *)&v25);
  uint64_t v27 = IOHIDEventGetEventWithOptions(a1, 11, 4026531840);
  if (v27)
  {
    int v28 = *(_DWORD *)(*(void *)(v27 + 104) + 24);
    if (v28 == 0x80000000) {
      double v24 = NAN;
    }
    else {
      double v24 = (double)v28 * 0.0000152587891;
    }
  }
  unsigned int v29 = 720913;
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", "Z:", *(void *)&v24);
  int v30 = v6[16];
  if (v30)
  {
    if (v30 == 1)
    {
      unsigned int v36 = 720911;
      unsigned int v31 = 720912;
      unsigned int v32 = 720916;
      unsigned int v47 = 720914;
      int v48 = 720917;
      unsigned int v49 = "MinorRadius:";
      unsigned int v33 = "MajorRadius:";
      uint64_t v46 = "Density:";
      unsigned int v34 = "Quality:";
      unsigned int v35 = "Azimuth:";
      unsigned int v37 = "Altitude:";
    }
    else
    {
      if (v30 != 2) {
        return;
      }
      unsigned int v31 = 720914;
      unsigned int v32 = 720917;
      unsigned int v47 = 720916;
      int v48 = 720922;
      unsigned int v29 = 720915;
      unsigned int v49 = "Accuracy:";
      unsigned int v33 = "MinorRadius:";
      uint64_t v46 = "MajorRadius:";
      unsigned int v34 = "Irregularity:";
      unsigned int v35 = "Density:";
      unsigned int v36 = 720913;
      unsigned int v37 = "Quality:";
    }
    v40.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v36, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", v37, v40.n64_u64[0]);
    v41.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v31, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", v35, v41.n64_u64[0]);
    v42.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v29, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", v34, v42.n64_u64[0]);
    v43.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v47, 4026531840).n64_u64[0];
    _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", v46, v43.n64_u64[0]);
    uint64_t v39 = v49;
    unsigned int v38 = v48;
  }
  else
  {
    unsigned int v32 = 720909;
    unsigned int v38 = 720910;
    uint64_t v39 = "TiltY:";
    unsigned int v33 = "TiltX:";
  }
  v44.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v32, 4026531840).n64_u64[0];
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", v33, v44.n64_u64[0]);
  v45.n64_u64[0] = IOHIDEventGetDoubleValueWithOptions(a1, v38, 4026531840).n64_u64[0];
  _IOHIDStringAppendIndendationAndFormat(a2, a3, @"%-20.20s %f\n", v39, v45.n64_u64[0]);
}

void __IOHIDEventTypeDescriptorAmbientLightSensor(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Level:", *(unsigned int *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "CH0:", *(unsigned int *)(v5 + 20));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "CH1:", *(unsigned int *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "CH2:", *(unsigned int *)(v5 + 28));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "CH3:", *(unsigned int *)(v5 + 32));
  if (*(unsigned char *)(v5 + 37) == 1) {
    int v6 = "XYZ";
  }
  else {
    int v6 = "Undefined";
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "ColorSpace:", v6);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "ColorComponent0:", *(void *)(v5 + 40));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "ColorComponent1:", *(void *)(v5 + 48));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "ColorComponent2:", *(void *)(v5 + 56));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "BrightnessChanged:", *(unsigned __int8 *)(v5 + 36));
}

void __IOHIDEventTypeDescriptorMotion(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6 = *(void *)(a1 + 104);
  uint64_t v7 = *(int *)(v6 + 28);
  if (v7 > 2) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = off_1E548A0E0[v7];
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "Type:", v8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Sequence:", *(unsigned int *)(v6 + 36));

  __IOHIDEventTypeDescriptorAxis(a1, theString, a3);
}

void __IOHIDEventTypeDescriptorProximity(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s 0x%08x\n", "Mask:", *(unsigned __int16 *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %u\n", "Type:", *(unsigned __int16 *)(v5 + 18));
  if (*(_WORD *)(v5 + 18))
  {
    if (*(_WORD *)(v5 + 18) != 1) {
      return;
    }
    uint64_t v6 = "Probability:";
  }
  else
  {
    uint64_t v6 = "Level:";
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", v6, *(unsigned int *)(v5 + 20));
}

void __IOHIDEventTypeDescriptorTemperature(uint64_t a1, CFMutableStringRef theString, int a3)
{
  int v3 = *(_DWORD *)(*(void *)(a1 + 104) + 16);
  double v4 = (double)v3 * 0.0000152587891;
  if (v3 == 0x80000000) {
    double v4 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Level:", *(void *)&v4);
}

void __IOHIDEventTypeDescriptorSwipe(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s 0x%08x\n", "Mask:", *(unsigned int *)(v6 + 28));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s 0x%08x\n", "Motion:", *(unsigned __int16 *)(v6 + 32));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s 0x%08x\n", "Flavor:", *(unsigned __int16 *)(v6 + 34));
  int v7 = *(_DWORD *)(v6 + 36);
  double v8 = (double)v7 * 0.0000152587891;
  if (v7 == 0x80000000) {
    double v8 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Progress:", *(void *)&v8);

  __IOHIDEventTypeDescriptorAxis(a1, theString, a3);
}

void __IOHIDEventTypeDescriptorPointer(void *a1, CFMutableStringRef theString, int a3)
{
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s 0x%08x\n", "Button Mask:", *(unsigned int *)(a1[13] + 28));
  uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(a1, 17, 4026531840);
  double v7 = 0.0;
  double v8 = 0.0;
  if (EventWithOptions)
  {
    int v9 = *(_DWORD *)(*(void *)(EventWithOptions + 104) + 16);
    double v8 = (double)v9 * 0.0000152587891;
    if (v9 == 0x80000000) {
      double v8 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "X:", *(void *)&v8);
  uint64_t v10 = IOHIDEventGetEventWithOptions(a1, 17, 4026531840);
  if (v10)
  {
    int v11 = *(_DWORD *)(*(void *)(v10 + 104) + 20);
    if (v11 == 0x80000000) {
      double v7 = NAN;
    }
    else {
      double v7 = (double)v11 * 0.0000152587891;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Y:", *(void *)&v7);
  uint64_t v12 = IOHIDEventGetEventWithOptions(a1, 17, 4026531840);
  if (v12)
  {
    int v13 = *(_DWORD *)(*(void *)(v12 + 104) + 24);
    double v14 = (double)v13 * 0.0000152587891;
    if (v13 == 0x80000000) {
      double v14 = NAN;
    }
  }
  else
  {
    double v14 = 0.0;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Z:", *(void *)&v14);
}

void __IOHIDEventTypeDescriptorProgress(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Type:", *(unsigned int *)(v5 + 16));
  int v6 = *(_DWORD *)(v5 + 20);
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Level:", *(void *)&v7);
}

void __IOHIDEventTypeDescriptorMultiAxisPointer(void *a1, CFMutableStringRef theString, int a3)
{
  uint64_t v6 = a1[13];
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s 0x%08x\n", "Button Mask:", *(unsigned int *)(v6 + 28));
  uint64_t EventWithOptions = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  double v8 = 0.0;
  double v9 = 0.0;
  if (EventWithOptions)
  {
    int v10 = *(_DWORD *)(*(void *)(EventWithOptions + 104) + 16);
    double v9 = (double)v10 * 0.0000152587891;
    if (v10 == 0x80000000) {
      double v9 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "X:", *(void *)&v9);
  uint64_t v11 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  if (v11)
  {
    int v12 = *(_DWORD *)(*(void *)(v11 + 104) + 20);
    if (v12 == 0x80000000) {
      double v8 = NAN;
    }
    else {
      double v8 = (double)v12 * 0.0000152587891;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Y:", *(void *)&v8);
  uint64_t v13 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  double v14 = 0.0;
  double v15 = 0.0;
  if (v13)
  {
    int v16 = *(_DWORD *)(*(void *)(v13 + 104) + 24);
    double v15 = (double)v16 * 0.0000152587891;
    if (v16 == 0x80000000) {
      double v15 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Z:", *(void *)&v15);
  uint64_t v17 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  if (v17)
  {
    int v18 = *(_DWORD *)(*(void *)(v17 + 104) + 32);
    if (v18 == 0x80000000) {
      double v14 = NAN;
    }
    else {
      double v14 = (double)v18 * 0.0000152587891;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Rx:", *(void *)&v14);
  uint64_t v19 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  double v20 = 0.0;
  double v21 = 0.0;
  if (v19)
  {
    int v22 = *(_DWORD *)(*(void *)(v19 + 104) + 36);
    double v21 = (double)v22 * 0.0000152587891;
    if (v22 == 0x80000000) {
      double v21 = NAN;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Ry:", *(void *)&v21);
  uint64_t v23 = IOHIDEventGetEventWithOptions(a1, 19, 4026531840);
  if (v23)
  {
    int v24 = *(_DWORD *)(*(void *)(v23 + 104) + 40);
    if (v24 == 0x80000000) {
      double v20 = NAN;
    }
    else {
      double v20 = (double)v24 * 0.0000152587891;
    }
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Rz:", *(void *)&v20);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Repeat:", HIWORD(*(_DWORD *)(v6 + 8)) & 1);
}

void __IOHIDEventTypeDescriptorSymbolicHotKey(uint64_t a1, CFMutableStringRef theString, int a3)
{
}

void __IOHIDEventTypeDescriptorPower(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(_DWORD **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Type:", v5[6]);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "SubType:", v5[7]);
  int v6 = v5[4];
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Level:", *(void *)&v7);
}

void __IOHIDEventTypeDescriptorBiometric(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  int v6 = *(_DWORD *)(v5 + 8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "EventType:", *(unsigned int *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "UsagePage:", *(unsigned __int16 *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Usage:", *(unsigned __int16 *)(v5 + 26));
  int v7 = *(_DWORD *)(v5 + 20);
  double v8 = (double)v7 * 0.0000152587891;
  if (v7 == 0x80000000) {
    double v8 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Level:", *(void *)&v8);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Tap Count:", *(unsigned __int8 *)(v5 + 32));
  double v9 = "begin";
  int v10 = "";
  if ((v6 & 0x1000000) == 0) {
    double v9 = "";
  }
  if ((v6 & 0x4000000) != 0) {
    int v10 = "ended";
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s%s\n", "Phase:", v9, v10);
}

void __IOHIDEventTypeDescriptorUnicode(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(_DWORD **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s ", "Encoding:");
  uint64_t v6 = (int)v5[4];
  if (v6 > 4) {
    int v7 = "UNKNOWN";
  }
  else {
    int v7 = off_1E548A0F8[v6];
  }
  _IOHIDStringAppendIndendationAndFormat(theString, 0, @"%s\n", v7);
  int v8 = v5[5];
  double v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000) {
    double v9 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Quality:", *(void *)&v9);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "DataLength:", v5[6]);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s ", "Data:");
  if (v5[6])
  {
    unint64_t v10 = 0;
    do
      _IOHIDStringAppendIndendationAndFormat(theString, 0, @"%02x ", *((unsigned __int8 *)v5 + v10++ + 28));
    while (v10 < v5[6]);
  }

  _IOHIDStringAppendIndendationAndFormat(theString, 0, @"\n");
}

void __IOHIDEventTypeDescriptorAtmosphericPressure(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  int v6 = *(_DWORD *)(v5 + 16);
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Level:", *(void *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Sequence:", *(unsigned int *)(v5 + 20));
}

void __IOHIDEventTypeDescriptorForceEvent(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(unsigned int **)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Behavior:", v5[4]);
  int v6 = v5[5];
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Progress:", *(void *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Stage:", v5[6]);
  int v8 = v5[7];
  double v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000) {
    double v9 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "StageProgress:", *(void *)&v9);
}

void __IOHIDEventTypeDescriptorMotionActivity(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Type:", *(unsigned int *)(v5 + 16));
  int v6 = *(_DWORD *)(v5 + 20);
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Confidence:", *(void *)&v7);
}

void __IOHIDEventTypeDescriptorMotionGesture(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Type:", *(unsigned int *)(v5 + 16));
  int v6 = *(_DWORD *)(v5 + 20);
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Progress:", *(void *)&v7);
}

void __IOHIDEventTypeDescriptorGameController(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  if (*(_DWORD *)(v5 + 16)) {
    int v6 = "Extended";
  }
  else {
    int v6 = "Standard";
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "Type:", v6);
  int v7 = *(_DWORD *)(v5 + 20);
  double v8 = (double)v7 * 0.0000152587891;
  if (v7 == 0x80000000) {
    double v8 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Direction Pad Up:", *(void *)&v8);
  int v9 = *(_DWORD *)(v5 + 24);
  double v10 = (double)v9 * 0.0000152587891;
  if (v9 == 0x80000000) {
    double v10 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Direction Pad Down:", *(void *)&v10);
  int v11 = *(_DWORD *)(v5 + 28);
  double v12 = (double)v11 * 0.0000152587891;
  if (v11 == 0x80000000) {
    double v12 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Direction Pad Left:", *(void *)&v12);
  int v13 = *(_DWORD *)(v5 + 32);
  double v14 = (double)v13 * 0.0000152587891;
  if (v13 == 0x80000000) {
    double v14 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Direction Pad Right:", *(void *)&v14);
  int v15 = *(_DWORD *)(v5 + 36);
  double v16 = (double)v15 * 0.0000152587891;
  if (v15 == 0x80000000) {
    double v16 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Face Button X:", *(void *)&v16);
  int v17 = *(_DWORD *)(v5 + 40);
  double v18 = (double)v17 * 0.0000152587891;
  if (v17 == 0x80000000) {
    double v18 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Face Button Y:", *(void *)&v18);
  int v19 = *(_DWORD *)(v5 + 44);
  double v20 = (double)v19 * 0.0000152587891;
  if (v19 == 0x80000000) {
    double v20 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Face Button A:", *(void *)&v20);
  int v21 = *(_DWORD *)(v5 + 48);
  double v22 = (double)v21 * 0.0000152587891;
  if (v21 == 0x80000000) {
    double v22 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Face Button B:", *(void *)&v22);
  int v23 = *(_DWORD *)(v5 + 68);
  double v24 = (double)v23 * 0.0000152587891;
  if (v23 == 0x80000000) {
    double v24 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Shoulder Button L1:", *(void *)&v24);
  int v25 = *(_DWORD *)(v5 + 76);
  double v26 = (double)v25 * 0.0000152587891;
  if (v25 == 0x80000000) {
    double v26 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Shoulder Button R1:", *(void *)&v26);
  int v27 = *(_DWORD *)(v5 + 72);
  double v28 = (double)v27 * 0.0000152587891;
  if (v27 == 0x80000000) {
    double v28 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Shoulder Button L2:", *(void *)&v28);
  int v29 = *(_DWORD *)(v5 + 80);
  double v30 = (double)v29 * 0.0000152587891;
  if (v29 == 0x80000000) {
    double v30 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Shoulder Button R2:", *(void *)&v30);
  int v31 = *(_DWORD *)(v5 + 52);
  double v32 = (double)v31 * 0.0000152587891;
  if (v31 == 0x80000000) {
    double v32 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Joystick Axis X:", *(void *)&v32);
  int v33 = *(_DWORD *)(v5 + 56);
  double v34 = (double)v33 * 0.0000152587891;
  if (v33 == 0x80000000) {
    double v34 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Joystick Axis Y:", *(void *)&v34);
  int v35 = *(_DWORD *)(v5 + 60);
  double v36 = (double)v35 * 0.0000152587891;
  if (v35 == 0x80000000) {
    double v36 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Joystick Axis Z:", *(void *)&v36);
  int v37 = *(_DWORD *)(v5 + 64);
  double v38 = (double)v37 * 0.0000152587891;
  if (v37 == 0x80000000) {
    double v38 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Joystick Axis Rz:", *(void *)&v38);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %d\n", "Thumbstick Button Left:", *(unsigned char *)(v5 + 84) & 1);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %d\n", "Thumbstick Button Right:", (*(unsigned __int8 *)(v5 + 84) >> 1) & 1);
  int v39 = *(_DWORD *)(v5 + 88);
  double v40 = (double)v39 * 0.0000152587891;
  if (v39 == 0x80000000) {
    double v40 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %f\n", "Extra Button L4:", *(void *)&v40);
  int v41 = *(_DWORD *)(v5 + 92);
  double v42 = (double)v41 * 0.0000152587891;
  if (v41 == 0x80000000) {
    double v42 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %f\n", "Extra Button R4:", *(void *)&v42);
  int v43 = *(_DWORD *)(v5 + 96);
  double v44 = (double)v43 * 0.0000152587891;
  if (v43 == 0x80000000) {
    double v44 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %f\n", "Bottom Button M1:", *(void *)&v44);
  int v45 = *(_DWORD *)(v5 + 100);
  double v46 = (double)v45 * 0.0000152587891;
  if (v45 == 0x80000000) {
    double v46 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %f\n", "Bottom Button M2:", *(void *)&v46);
  int v47 = *(_DWORD *)(v5 + 104);
  double v48 = (double)v47 * 0.0000152587891;
  if (v47 == 0x80000000) {
    double v48 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %f\n", "Bottom Button M3:", *(void *)&v48);
  int v49 = *(_DWORD *)(v5 + 108);
  double v50 = (double)v49 * 0.0000152587891;
  if (v49 == 0x80000000) {
    double v50 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-25.25s %f\n", "Bottom Button M4:", *(void *)&v50);
}

void __IOHIDEventTypeDescriptorHumidity(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  int v6 = *(_DWORD *)(v5 + 16);
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "rh:", *(void *)&v7);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Sequence:", *(unsigned int *)(v5 + 20));
}

void __IOHIDEventTypeDescriptorBrightness(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  int v6 = *(_DWORD *)(v5 + 16);
  double v7 = (double)v6 * 0.0000152587891;
  if (v6 == 0x80000000) {
    double v7 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "CurrentBrightness:", *(void *)&v7);
  int v8 = *(_DWORD *)(v5 + 20);
  double v9 = (double)v8 * 0.0000152587891;
  if (v8 == 0x80000000) {
    double v9 = NAN;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "TargetBrightness:", *(void *)&v9);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %qd\n", "TransitionTime,us:", *(void *)(v5 + 24));
}

void __IOHIDEventTypeDescriptorGenericGesture(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  switch(*(_DWORD *)(v5 + 16))
  {
    case 0:
      double v7 = "Tap";
      goto LABEL_7;
    case 1:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "GestureType:", "Swipe");
      int v8 = *(_DWORD *)(v5 + 20);
      double v9 = (double)v8 * 0.0000152587891;
      if (v8 == 0x80000000) {
        double v9 = NAN;
      }
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "Progress:", *(void *)&v9);
      return;
    case 2:
      double v7 = "HandTap";
LABEL_7:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "GestureType:", v7);
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Count:", *(unsigned int *)(v5 + 20));
      return;
    case 4:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "GestureType:", "HandTapHold");
      int v10 = *(_DWORD *)(*(void *)(a1 + 104) + 8);
      if ((v10 & 0x1000000) != 0) {
        goto LABEL_23;
      }
      if (v10 < 0) {
        goto LABEL_24;
      }
      if ((v10 & 0x2000000) != 0) {
        goto LABEL_25;
      }
      if ((v10 & 0x4000000) == 0) {
        goto LABEL_13;
      }
      goto LABEL_19;
    case 5:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", "GestureType:", "Squeeze");
      int v10 = *(_DWORD *)(*(void *)(a1 + 104) + 8);
      if ((v10 & 0x1000000) != 0)
      {
LABEL_23:
        int v11 = "Begin";
      }
      else if (v10 < 0)
      {
LABEL_24:
        int v11 = "MayBegin";
      }
      else if ((v10 & 0x2000000) != 0)
      {
LABEL_25:
        int v11 = "Changed";
      }
      else if ((v10 & 0x4000000) != 0)
      {
LABEL_19:
        int v11 = "Ended";
      }
      else
      {
LABEL_13:
        if ((v10 & 0x8000000) == 0) {
          return;
        }
        int v11 = "Cancelled";
      }
      double v12 = "Phase:";
LABEL_27:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s\n", v12, v11);
      return;
    case 6:
      int v11 = "LongSqueeze";
      goto LABEL_22;
    case 7:
      int v11 = "DoubleSqueeze";
LABEL_22:
      double v12 = "GestureType:";
      goto LABEL_27;
    default:
      _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %s (%d)\n", "GestureType:", "Unknown", *(unsigned int *)(v5 + 16));
      return;
  }
}

void __IOHIDEventTypeDescriptorForceStageEvent(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Stage:", *(unsigned int *)(v5 + 16));
  unint64_t v6 = *(char *)(v5 + 20);
  if (v6 <= 2) {
    _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s\n", off_1E548A120[v6]);
  }
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "NextThreshold:", *(void *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "PressedThreshold:", *(void *)(v5 + 32));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "ReleasedThreshold:", *(void *)(v5 + 40));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "NormalizedForce:", *(void *)(v5 + 48));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "NormalizedForceVelocity:", *(void *)(v5 + 56));
}

void __IOHIDEventTypeDescriptorTouchSensitiveButton(uint64_t a1, CFMutableStringRef theString, int a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %dx\n", "Usage:", *(unsigned __int16 *)(v5 + 16));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "UsagePage:", *(unsigned __int16 *)(v5 + 18));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "NormalizedPositionX:", *(void *)(v5 + 48));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "NormalizedPositionDeltaX:", *(void *)(v5 + 56));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "NormalizedPositionY:", *(void *)(v5 + 24));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %f\n", "NormalizedPositionDeltaY:", *(void *)(v5 + 32));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "Touch:", *(unsigned __int8 *)(v5 + 40));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s %d\n", "EventMask:", *(unsigned int *)(v5 + 44));
  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"%-20.20s ", "Events:");
  int v6 = *(_DWORD *)(v5 + 44);
  if (v6)
  {
    _IOHIDStringAppendIndendationAndFormat(theString, 0, @"FastSwipe ");
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  _IOHIDStringAppendIndendationAndFormat(theString, 0, @"LowSNRSwipe ");
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_11:
  _IOHIDStringAppendIndendationAndFormat(theString, 0, @"LiftOffPredicted ");
  if ((*(_DWORD *)(v5 + 44) & 8) != 0) {
LABEL_5:
  }
    _IOHIDStringAppendIndendationAndFormat(theString, 0, @"ClickDownPredicted ");
LABEL_6:

  _IOHIDStringAppendIndendationAndFormat(theString, a3, @"\n");
}

uint64_t initrosetta_convert_to_rosetta_absolute_time_0(uint64_t a1)
{
  uint64_t v2 = (void *)RosettaLibrary_libLibrary_0;
  if (!RosettaLibrary_libLibrary_0)
  {
    uint64_t v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_0 = (uint64_t)v2;
  }
  int v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_rosetta_absolute_time");
  dynLinkrosetta_convert_to_rosetta_absolute_time_0[0] = v3;
  if (!v3) {
    return a1;
  }

  return ((uint64_t (*)(uint64_t))v3)(a1);
}

uint64_t initrosetta_convert_to_system_absolute_time_0(uint64_t a1)
{
  uint64_t v2 = (void *)RosettaLibrary_libLibrary_0;
  if (!RosettaLibrary_libLibrary_0)
  {
    uint64_t v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_0 = (uint64_t)v2;
  }
  int v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_system_absolute_time");
  dynLinkrosetta_convert_to_system_absolute_time_0[0] = v3;
  if (!v3) {
    return a1;
  }

  return ((uint64_t (*)(uint64_t))v3)(a1);
}

uint64_t IOHIDConnectionFilterGetTypeID()
{
  uint64_t result = __kIOHIDConnectionFilterTypeID;
  if (!__kIOHIDConnectionFilterTypeID)
  {
    pthread_once(&__connectionFilterClientTypeInit, (void (*)(void))__IOHIDConnectionFilterRegister);
    return __kIOHIDConnectionFilterTypeID;
  }
  return result;
}

uint64_t __IOHIDConnectionFilterRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDConnectionFilterCFTypeID TypeID = result;
  return result;
}

id IOHIDConnectionFilterFilterEvent(uint64_t a1, uint64_t a2)
{
  int v3 = *(void **)(a1 + 16);
  if (v3 && (uint64_t v5 = *(const char **)(a1 + 72)) != 0) {
    return objc_msgSend(v3, v5, a2);
  }
  else {
    return 0;
  }
}

id IOHIDConnectionFilterCopyProperty(uint64_t a1, uint64_t a2)
{
  int v3 = *(void **)(a1 + 16);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = *(const char **)(a1 + 24);
  if (!v5) {
    return 0;
  }
  id v6 = objc_msgSend(v3, v5, a2);
  id v7 = v6;
  if (v6) {
    CFRetain(v6);
  }
  return v7;
}

id IOHIDConnectionFilterSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v4 = *(void **)(a1 + 16);
  if (v4 && (id v6 = *(const char **)(a1 + 32)) != 0) {
    return objc_msgSend(v4, v6, a3, a2);
  }
  else {
    return 0;
  }
}

id IOHIDConnectionFilterActivate(uint64_t a1)
{
  id result = *(id *)(a1 + 16);
  if (result)
  {
    int v3 = *(const char **)(a1 + 48);
    if (v3) {
      return [result v3];
    }
  }
  return result;
}

id IOHIDConnectionFilterCancel(uint64_t a1)
{
  id result = *(id *)(a1 + 16);
  if (result)
  {
    int v3 = *(const char **)(a1 + 56);
    if (v3) {
      return [result v3];
    }
  }
  return result;
}

id IOHIDConnectionFilterSetDispatchQueue(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a1 + 16);
  if (result)
  {
    uint64_t v5 = *(const char **)(a1 + 64);
    if (v5) {
      return objc_msgSend(result, v5, a2);
    }
  }
  return result;
}

id IOHIDConnectionFilterSetCancelHandler(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a1 + 16);
  if (result)
  {
    uint64_t v5 = *(const char **)(a1 + 40);
    if (v5) {
      return objc_msgSend(result, v5, a2);
    }
  }
  return result;
}

CFStringRef __IOHIDConnectionFilterCopyDebugDescription(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    CFStringRef v3 = CFCopyDescription(v2);
  }
  else {
    CFStringRef v3 = 0;
  }
  CFAllocatorRef v4 = CFGetAllocator(a1);
  uint64_t v5 = &stru_1ED870660;
  if (v3) {
    uint64_t v5 = (__CFString *)v3;
  }
  CFStringRef v6 = CFStringCreateWithFormat(v4, 0, @"<IOHIDConnectionFilterRef:%@>", v5);
  if (v3) {
    CFRelease(v3);
  }
  return v6;
}

__CFDictionary *__IOAVClassMatching(uint64_t a1, __CFString *a2, unsigned int a3, int a4)
{
  int valuePtr = a4;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  int v10 = Mutable;
  if (a3 <= 1)
  {
    int v11 = IOAVLocationString(a3);
    CFStringRef v12 = CFStringCreateWithCString(v8, v11, 0x8000100u);
    if (!v12) {
      goto LABEL_21;
    }
    CFStringRef v13 = v12;
    CFDictionarySetValue(v10, @"Location", v12);
    CFRelease(v13);
  }
  if (a4 != -1)
  {
    CFNumberRef v14 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
    if (!v14) {
      goto LABEL_21;
    }
    CFNumberRef v15 = v14;
    CFDictionarySetValue(v10, @"Unit", v14);
    CFRelease(v15);
  }
  if (!a2) {
    goto LABEL_15;
  }
  CFRange v16 = CFStringFind(a2, @":", 0);
  if (v16.location == -1 || v16.location + v16.length >= CFStringGetLength(a2))
  {
    a2 = (__CFString *)CFStringCreateWithFormat(v8, 0, @"%s:%@", "IODeviceTree", a2);
    if (a2) {
      goto LABEL_13;
    }
LABEL_21:
    double v22 = 0;
    goto LABEL_19;
  }
  CFRetain(a2);
LABEL_13:
  int v17 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v17)
  {
LABEL_22:
    int v21 = v10;
    int v10 = 0;
    goto LABEL_18;
  }
  double v18 = v17;
  CFDictionarySetValue(v17, @"IOPathMatch", a2);
  CFRelease(a2);
  CFDictionarySetValue(v10, @"IOParentMatch", v18);
  CFRelease(v18);
LABEL_15:
  CFMutableDictionaryRef v19 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v19) {
    goto LABEL_21;
  }
  a2 = (__CFString *)v19;
  CFStringRef v20 = CFStringCreateWithFormat(v8, 0, @"%s%s", a1, "UserInterfaceSupported");
  if (!v20) {
    goto LABEL_22;
  }
  int v21 = (__CFDictionary *)v20;
  CFDictionarySetValue((CFMutableDictionaryRef)a2, v20, (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionarySetValue(v10, @"IOPropertyMatch", a2);
LABEL_18:
  double v22 = v10;
  CFRelease(a2);
  int v10 = v21;
LABEL_19:
  CFRelease(v10);
  return v22;
}

uint64_t __IOAVCopyFirstMatchingIOAVObjectOfType(uint64_t a1, uint64_t (*a2)(void, uint64_t), __CFString *a3, unsigned int a4, int a5)
{
  CFStringRef v6 = __IOAVClassMatching(a1, a3, a4, a5);
  uint64_t MatchingService = IOServiceGetMatchingService(0, v6);
  if (!MatchingService) {
    return 0;
  }
  io_object_t v8 = MatchingService;
  uint64_t v9 = a2(*MEMORY[0x1E4F1CF80], MatchingService);
  IOObjectRelease(v8);
  return v9;
}

uint64_t IOHIDEventSystemGetTypeID()
{
  uint64_t result = __kIOHIDEventSystemTypeID;
  if (!__kIOHIDEventSystemTypeID)
  {
    pthread_once(&__systemTypeInit, (void (*)(void))__IOHIDEventSystemRegister);
    return __kIOHIDEventSystemTypeID;
  }
  return result;
}

uint64_t __IOHIDEventSystemRegister()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  kIOHIDServiceInterruptWorkloop = (uint64_t)hid_workloop_create("IOHIDEvent Interrupt - Root", 63);
  kIOHIDServiceEnumerationWorkloop = (uint64_t)hid_workloop_create("IOHIDService Enumeration - Root", 63);
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    memset(&v3, 0, sizeof(v3));
    if (hid_pthread_attr_init(&v3, 63, 2)) {
      __IOHIDEventSystemRegister_cold_2();
    }
    kIOHIDServerConnectionRootQueue = hid_dispatch_pthread_root_queue_create((uint64_t)"IOHIDEvent Server Connection - Root", (uint64_t)&v3, 0, 2u);
    if (!kIOHIDServerConnectionRootQueue) {
      __IOHIDEventSystemRegister_cold_1();
    }
    pthread_attr_destroy(&v3);
  }
  v3.__sig = 0;
  mach_timebase_info((mach_timebase_info_t)&v3);
  LODWORD(v1) = HIDWORD(v3.__sig);
  LODWORD(v(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v3.__sig;
  *(double *)&__absoluteTime_to_nanoseconds_factor = 1.0 / ((double)v0 / (double)v1);
  _IOHIDLoadBundles();
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDEventSystemCFTypeID TypeID = result;
  return result;
}

uint64_t IOHIDEventSystemCreate(const __CFAllocator *a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  keys = 0;
  uint64_t v2 = mach_absolute_time();
  _IOHIDDebugTrace(8275, 1, 0, 0, 0, 0);
  pthread_attr_t v3 = _IOHIDLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v3, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemCreate", (const char *)&unk_18B51B6F3, buf, 2u);
  }
  CFPropertyListRef v4 = IOHIDPreferencesCopyDomain(@"allocator", @"com.apple.iohid");
  if (v4)
  {
    uint64_t v5 = v4;
    if (CFEqual(v4, @"default")) {
      a1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    }
    CFRelease(v5);
  }
  mach_port_t v6 = *MEMORY[0x1E4F14638];
  *(_DWORD *)long long buf = 0;
  if (!bootstrap_look_up2())
  {
    int v33 = (ipc_space_t *)MEMORY[0x1E4F14960];
    mach_port_deallocate(*MEMORY[0x1E4F14960], *(mach_port_name_t *)buf);
    if (bootstrap_check_in(v6, "com.apple.iohideventsystem", (mach_port_t *)buf))
    {
      double v34 = _IOHIDLog();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v48) = 0;
        _os_log_impl(&dword_18B46C000, v34, OS_LOG_TYPE_DEFAULT, "__bootstrap_status:0x%x", buf, 8u);
      }
      uint64_t v8 = 0;
      goto LABEL_36;
    }
    mach_port_mod_refs(*v33, *(mach_port_name_t *)buf, 1u, -1);
  }
  if (!__kIOHIDEventSystemTypeID) {
    pthread_once(&__systemTypeInit, (void (*)(void))__IOHIDEventSystemRegister);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v8 = (uint64_t)Instance;
  if (!Instance) {
    goto LABEL_36;
  }
  Instance[1] = 0u;
  Instance[26] = 0u;
  Instance[27] = 0u;
  Instance[24] = 0u;
  Instance[25] = 0u;
  Instance[22] = 0u;
  Instance[23] = 0u;
  Instance[20] = 0u;
  Instance[21] = 0u;
  Instance[18] = 0u;
  Instance[19] = 0u;
  Instance[16] = 0u;
  Instance[17] = 0u;
  Instance[14] = 0u;
  Instance[15] = 0u;
  Instance[12] = 0u;
  Instance[13] = 0u;
  Instance[10] = 0u;
  Instance[11] = 0u;
  Instance[8] = 0u;
  Instance[9] = 0u;
  Instance[6] = 0u;
  Instance[7] = 0u;
  Instance[4] = 0u;
  Instance[5] = 0u;
  Instance[2] = 0u;
  Instance[3] = 0u;
  *((void *)Instance + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  uint64_t v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  int v10 = hid_dispatch_queue_create("HID - IOService Enumeration", v9, kIOHIDServiceEnumerationWorkloop, (uint64_t)__IOHIDSystemEnumerationQueueWillExecute, (uint64_t)__IOHIDSystemEnumerationQueueDidExecute, v8);
  *(void *)(v8 + 144) = v10;
  if (!v10) {
    goto LABEL_36;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(v8 + 16) = Mutable;
  if (!Mutable) {
    goto LABEL_36;
  }
  CFMutableDictionaryRef v12 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(v8 + 24) = v12;
  if (!v12) {
    goto LABEL_36;
  }
  CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)v8);
  CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(v8 + 176) = v14;
  if (!v14) {
    goto LABEL_36;
  }
  CFSetCallBacks v45 = *(CFSetCallBacks *)byte_1ED86F908;
  CFMutableSetRef v15 = CFSetCreateMutable(a1, 0, &v45);
  *(void *)(v8 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v15;
  if (!v15) {
    goto LABEL_36;
  }
  CFMutableSetRef v16 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(v8 + 48) = v16;
  if (!v16) {
    goto LABEL_36;
  }
  CFMutableSetRef v17 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(v8 + 56) = v17;
  if (!v17) {
    goto LABEL_36;
  }
  CFMutableSetRef v18 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(v8 + 64) = v18;
  if (!v18) {
    goto LABEL_36;
  }
  CFMutableSetRef v19 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(v8 + 72) = v19;
  if (!v19) {
    goto LABEL_36;
  }
  CFMutableArrayRef v20 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  *(void *)(v8 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v20;
  if (!v20) {
    goto LABEL_36;
  }
  CFMutableSetRef v21 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(v8 + 424) = v21;
  if (!v21) {
    goto LABEL_36;
  }
  CFMutableSetRef v22 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(v8 + 432) = v22;
  if (!v22) {
    goto LABEL_36;
  }
  uint64_t v23 = IOHIDSessionCreate(a1);
  *(void *)(v8 + 128) = v23;
  if (!v23)
  {
    double v42 = _IOHIDLog();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v43 = "IOHIDSessionCreate";
LABEL_60:
      _os_log_impl(&dword_18B46C000, v42, OS_LOG_TYPE_DEFAULT, v43, buf, 2u);
    }
LABEL_36:
    uint64_t v32 = 0;
    CFDictionaryRef v26 = 0;
    int v25 = 0;
    goto LABEL_37;
  }
  double v24 = IOHIDEventServerCreate((uint64_t)a1, v8);
  *(void *)(v8 + 152) = v24;
  if (!v24)
  {
    double v42 = _IOHIDLog();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v43 = "IOHIDEventServerCreate";
      goto LABEL_60;
    }
    goto LABEL_36;
  }
  __IOHIDEventSystem_debug = v8;
  int v25 = IOServiceMatching("IOService");
  if (!v25)
  {
    uint64_t v32 = 0;
    CFDictionaryRef v26 = 0;
    goto LABEL_37;
  }
  keys = @"HIDServiceSupport";
  CFDictionaryRef v26 = CFDictionaryCreate(a1, (const void **)&keys, MEMORY[0x1E4F1CFD0], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v26) {
    goto LABEL_65;
  }
  CFDictionarySetValue(v25, @"IOPropertyMatch", v26);
  int v27 = IONotificationPortCreate(0);
  if (!v27)
  {
LABEL_63:
    *(void *)(v8 + 96) = 0;
    double v44 = _IOHIDLog();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B46C000, v44, OS_LOG_TYPE_DEFAULT, "__IOHIDEventSystemCreateNotification", buf, 2u);
    }
LABEL_65:
    uint64_t v32 = 0;
    goto LABEL_37;
  }
  double v28 = v27;
  IONotificationPortSetDispatchQueue(v27, *(dispatch_queue_t *)(v8 + 144));
  CFRetain(v25);
  if (IOServiceAddMatchingNotification(v28, "IOServiceFirstMatch", v25, (IOServiceMatchingCallback)__IOHIDEventSystemServicePublished, (void *)v8, (io_iterator_t *)(v8 + 168)))
  {
    IONotificationPortDestroy(v28);
    goto LABEL_63;
  }
  __IOHIDEventSystemServicePublished((void *)v8, *(_DWORD *)(v8 + 168));
  *(void *)(v8 + 96) = v28;
  int v29 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v8 + 144));
  *(void *)(v8 + 44(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v29;
  if (v29)
  {
    dispatch_source_set_event_handler(v29, &__block_literal_global_9);
    double v30 = *(NSObject **)(v8 + 440);
    dispatch_time_t v31 = dispatch_time(0, 300000000000);
    dispatch_source_set_timer(v30, v31, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(*(dispatch_object_t *)(v8 + 440));
  }
  CFRetain((CFTypeRef)v8);
  uint64_t v32 = v8;
LABEL_37:
  int v35 = _IOHIDLog();
  if (os_signpost_enabled(v35))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v35, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemCreate", (const char *)&unk_18B51B6F3, buf, 2u);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v8) {
    CFRelease((CFTypeRef)v8);
  }
  _IOHIDDebugTrace(8275, 2, 0, 0, 0, 0);
  __eventSytemAnalyticsEvent = IOHIDAnalyticsEventCreate(@"com.apple.hid.analytics.event-system", 0);
  if (__eventSytemAnalyticsEvent)
  {
    IOHIDAnalyticsEventAddField();
    IOHIDAnalyticsEventAddField();
    IOHIDAnalyticsEventActivate();
  }
  double v36 = _IOHIDLog();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = mach_absolute_time();
    unint64_t v38 = _IOHIDGetTimestampDelta(v37, v2, 0x3E8u);
    *(_DWORD *)long long buf = 134217984;
    unint64_t v48 = v38;
    _os_log_impl(&dword_18B46C000, v36, OS_LOG_TYPE_DEFAULT, "IOHIDEventSystemCreate:%lldus", buf, 0xCu);
  }
  uint64_t v39 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v39, v2, 0x3E8u);
  if (__eventSytemAnalyticsEvent) {
    IOHIDAnalyticsEventSetIntegerValueForField();
  }
  if (!v32)
  {
    double v40 = _IOHIDLog();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
      IOHIDEventSystemCreate_cold_1(v40);
    }
  }
  return v32;
}

void __IOHIDEventSystemServicePublished(void *a1, io_iterator_t iterator)
{
  io_object_t v4 = IOIteratorNext(iterator);
  if (v4)
  {
    io_registry_entry_t v5 = v4;
    CFMutableDictionaryRef Mutable = 0;
    id v7 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    do
    {
      CFAllocatorRef v8 = CFGetAllocator(a1);
      uint64_t v9 = _IOHIDServiceCreate((uint64_t)v8, v5);
      if (v9)
      {
        int v10 = (const void *)v9;
        if (Mutable || (CFAllocatorRef v11 = CFGetAllocator(a1), (Mutable = CFArrayCreateMutable(v11, 0, v7)) != 0))
        {
          CFArrayAppendValue(Mutable, v10);
          if (a1[55])
          {
            if (!_IOHIDPlugInInstanceCacheIsEmpty())
            {
              CFMutableDictionaryRef v12 = a1[55];
              dispatch_time_t v13 = dispatch_time(0, 300000000000);
              dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0);
            }
          }
        }
        CFRelease(v10);
      }
      IOObjectRelease(v5);
      io_registry_entry_t v5 = IOIteratorNext(iterator);
    }
    while (v5);
    if (Mutable)
    {
      CFMutableDictionaryRef v14 = _IOHIDLog();
      if (os_signpost_enabled(v14))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl(&dword_18B46C000, v14, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddServices", (const char *)&unk_18B51B6F3, buf, 2u);
      }
      __IOHIDEventSystemAddServices((uint64_t)a1, Mutable);
      CFMutableSetRef v15 = _IOHIDLog();
      if (os_signpost_enabled(v15))
      {
        *(_WORD *)CFMutableSetRef v16 = 0;
        _os_signpost_emit_with_name_impl(&dword_18B46C000, v15, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemAddServices", (const char *)&unk_18B51B6F3, v16, 2u);
      }
      CFRelease(Mutable);
    }
  }
}

uint64_t IOHIDEventSystemOpen(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = mach_absolute_time();
  _IOHIDDebugTrace(8276, 1, 0, 0, 0, 0);
  uint64_t v9 = _IOHIDLog();
  if (os_signpost_enabled(v9))
  {
    LOWORD(v22) = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v9, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemOpen", (const char *)&unk_18B51B6F3, (uint8_t *)&v22, 2u);
  }
  uint64_t v10 = a1[19];
  uint64_t v11 = IOHIDSessionOpen(a1[16], a1, (uint64_t)__IOHIDEventSystemEventCallback, 0);
  if (v11)
  {
    CFMutableDictionaryRef v12 = a1[17];
    if (v12
      || (dispatch_time_t v13 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM),
          CFMutableDictionaryRef v12 = hid_dispatch_queue_create("IOHIDEventServer", v13, 0, 0, 0, 0),
          (a1[17] = v12) != 0))
    {
      IOHIDEventServerScheduleWithDispatchQueue(v10, v12);
    }
    else
    {
      CFMutableSetRef v21 = _IOHIDLog();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        IOHIDEventSystemOpen_cold_2(v21);
      }
    }
    os_unfair_recursive_lock_lock_with_options();
    a1[13] = a3;
    a1[14] = a2;
    a1[15] = a4;
    os_unfair_recursive_lock_unlock();
  }
  CFMutableDictionaryRef v14 = _IOHIDLog();
  if (os_signpost_enabled(v14))
  {
    LOWORD(v22) = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v14, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemOpen", (const char *)&unk_18B51B6F3, (uint8_t *)&v22, 2u);
  }
  _IOHIDDebugTrace(8276, 2, 0, 0, 0, 0);
  CFMutableSetRef v15 = _IOHIDLog();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = mach_absolute_time();
    unint64_t v17 = _IOHIDGetTimestampDelta(v16, v8, 0x3E8u);
    int v22 = 134217984;
    unint64_t v23 = v17;
    _os_log_impl(&dword_18B46C000, v15, OS_LOG_TYPE_DEFAULT, "IOHIDEventSystemOpen:%lldus", (uint8_t *)&v22, 0xCu);
  }
  uint64_t v18 = mach_absolute_time();
  _IOHIDGetTimestampDelta(v18, v8, 0x3E8u);
  if (__eventSytemAnalyticsEvent) {
    IOHIDAnalyticsEventSetIntegerValueForField();
  }
  if (!v11)
  {
    CFMutableSetRef v19 = _IOHIDLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      IOHIDEventSystemOpen_cold_1(v19);
    }
  }
  return v11;
}

uint64_t IOHIDEventSystemSetCallback(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[13] = a3;
  a1[14] = a2;
  a1[15] = a4;

  return os_unfair_recursive_lock_unlock();
}

void *IOHIDEventSystemRegisterPropertyChangedNotification(void *result, CFTypeRef cf, void *aBlock)
{
  io_object_t v4 = result;
  if (!result[4])
  {
    result[4] = cf;
    uint64_t result = CFRetain(cf);
  }
  if (!v4[11])
  {
    if (aBlock) {
      uint64_t result = _Block_copy(aBlock);
    }
    else {
      uint64_t result = 0;
    }
    v4[11] = result;
  }
  return result;
}

void IOHIDEventSystemUnregisterPropertyChangedNotification(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 32) = 0;
  }
  pthread_attr_t v3 = *(const void **)(a1 + 88);
  if (v3)
  {
    _Block_release(v3);
    *(void *)(a1 + 88) = 0;
  }
}

void IOHIDEventSystemClose(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 152);
  uint64_t v4 = *(void *)(a1 + 128);
  pthread_attr_t v3 = *(NSObject **)(a1 + 136);
  io_registry_entry_t v5 = _IOHIDLog();
  if (os_signpost_enabled(v5))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v5, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemClose", (const char *)&unk_18B51B6F3, buf, 2u);
  }
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 96), 0);
  IOHIDEventServerUnscheduleFromDispatchQueue(v2, (uint64_t)v3);
  IOHIDSessionClose(v4, (const void *)a1);
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  os_unfair_recursive_lock_unlock();
  mach_port_t v6 = _IOHIDLog();
  if (os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v6, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystem - service queue termination", (const char *)&unk_18B51B6F3, buf, 2u);
  }
  CFRetain((CFTypeRef)a1);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IOHIDEventSystemClose_block_invoke;
  block[3] = &__block_descriptor_tmp_19_0;
  block[4] = a1;
  dispatch_async(v3, block);
  id v7 = _IOHIDLog();
  if (os_signpost_enabled(v7))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v7, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystem - enumeration queue termination", (const char *)&unk_18B51B6F3, buf, 2u);
  }
  CFRetain((CFTypeRef)a1);
  uint64_t v8 = *(NSObject **)(a1 + 144);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  v10[2] = __IOHIDEventSystemClose_block_invoke_20;
  v10[3] = &__block_descriptor_tmp_21_0;
  v10[4] = a1;
  dispatch_async(v8, v10);
  uint64_t v9 = _IOHIDLog();
  if (os_signpost_enabled(v9))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v9, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemClose", (const char *)&unk_18B51B6F3, buf, 2u);
  }
}

void __IOHIDEventSystemClose_block_invoke(uint64_t a1)
{
  uint64_t v2 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B46C000, v2, OS_LOG_TYPE_DEFAULT, "All actions on server queue completed.", buf, 2u);
  }
  pthread_attr_t v3 = _IOHIDLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v3, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystem - service queue termination", (const char *)&unk_18B51B6F3, v4, 2u);
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void __IOHIDEventSystemClose_block_invoke_20(uint64_t a1)
{
  uint64_t v2 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B46C000, v2, OS_LOG_TYPE_DEFAULT, "All actions on enumeration queue completed.", buf, 2u);
  }
  pthread_attr_t v3 = _IOHIDLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v3, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystem - enumeration queue termination", (const char *)&unk_18B51B6F3, v4, 2u);
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t IOHIDEventSystemSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  return _IOHIDEventSystemSetPropertyForConnection(a1, a2, a3, (const void *)*MEMORY[0x1E4F1D260]);
}

__CFArray *IOHIDEventSystemGetProperty(uint64_t a1, const void *a2)
{
  uint64_t v2 = _IOHIDEventSystemCopyPropertyForConnection(a1, a2, (void *)*MEMORY[0x1E4F1D260]);

  return v2;
}

uint64_t IOHIDEventSystemCopyEvent(uint64_t a1, int a2, uint64_t a3, int a4)
{
  return IOHIDSessionCopyEvent(*(void *)(a1 + 128), a2, a3, a4);
}

CFArrayRef IOHIDEventSystemCopyConnections(CFSetRef *a1, int a2)
{
  os_unfair_recursive_lock_lock_with_options();
  if (a2 == 2)
  {
    uint64_t v4 = a1 + 9;
  }
  else if (a2 == 1)
  {
    uint64_t v4 = a1 + 8;
  }
  else
  {
    if (a2)
    {
LABEL_10:
      CFArrayRef v10 = 0;
      goto LABEL_11;
    }
    uint64_t v4 = a1 + 7;
  }
  CFSetRef v5 = *v4;
  if (!*v4) {
    goto LABEL_10;
  }
  CFIndex Count = CFSetGetCount(*v4);
  id v7 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = v7;
  bzero(v7, 8 * Count);
  CFSetGetValues(v5, v8);
  CFAllocatorRef v9 = CFGetAllocator(a1);
  CFArrayRef v10 = CFArrayCreate(v9, v8, Count, MEMORY[0x1E4F1D510]);
  free(v8);
LABEL_11:
  os_unfair_recursive_lock_unlock();
  return v10;
}

uint64_t IOHIDEventSystemRegisterConnectionAdditionCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  CFArrayRef v10 = (void *)(a1 + 24 * a2);
  v10[23] = a4;
  v10[24] = a3;
  v10[25] = a5;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemUnregisterConnectionAdditionCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  CFArrayRef v10 = (void *)(a1 + 184 + 24 * a2);
  if (v10[1] == a3 && *v10 == a4 && *(void *)(a1 + 184 + 24 * a2 + 16) == a5)
  {
    void *v10 = 0;
    v10[1] = 0;
    v10[2] = 0;
  }

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemRegisterConnectionRemovalCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  CFArrayRef v10 = (void *)(a1 + 24 * a2);
  v10[38] = a4;
  v10[39] = a3;
  v10[40] = a5;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemUnregisterConnectionRemovalCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v10 = a1 + 24 * a2;
  if (*(void *)(v10 + 312) == a3)
  {
    uint64_t v11 = (void *)(v10 + 304);
    if (*v11 == a4 && *(void *)(a1 + 24 * a2 + 320) == a5)
    {
      void *v11 = 0;
      v11[1] = 0;
      void v11[2] = 0;
    }
  }

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemCopyServices(CFDictionaryRef *a1, const __CFDictionary *a2)
{
  uint64_t v3 = 0;
  __IOHIDEventSystemCopyMatchingServices(a1, a2, 0, 0, 0, 0, &v3);
  return v3;
}

void IOHIDEventSystemRegisterServicesCallback(CFDictionaryRef *a1, const __CFDictionary *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  xpc_object_t value = 0;
  __IOHIDEventSystemCopyMatchingServices(a1, a2, a3, a4, a5, &value, 0);
  if (value)
  {
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFStringRef v11 = CFStringCreateWithFormat(v10, 0, @"%p%p%p%p", a2, a3, a4, a5);
    if (v11)
    {
      CFStringRef v12 = v11;
      os_unfair_recursive_lock_lock_with_options();
      CFDictionarySetValue(a1[22], v12, value);
      os_unfair_recursive_lock_unlock();
      CFRelease(v12);
    }
    CFRelease(value);
  }
}

void IOHIDEventSystemUnregisterServicesCallback(CFMutableDictionaryRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFAllocatorRef v10 = CFGetAllocator(a1);
  CFStringRef v11 = CFStringCreateWithFormat(v10, 0, @"%p%p%p%p", a2, a3, a4, a5);
  if (v11)
  {
    CFStringRef v12 = v11;
    os_unfair_recursive_lock_lock_with_options();
    CFDictionaryRemoveValue(a1[22], v12);
    os_unfair_recursive_lock_unlock();
    CFRelease(v12);
  }
}

void _IOHIDEventSystemRegisterEventFilter(uint64_t a1, void *a2)
{
  _IOHIDEventSystemUnregisterEventFilter(a1, a2);
  os_unfair_recursive_lock_lock_with_options();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), a2);
  CFArrayRef v4 = *(const __CFArray **)(a1 + 80);
  v8.CFIndex length = CFArrayGetCount(v4);
  v8.location = 0;
  CFArraySortValues(v4, v8, (CFComparatorFunction)_IOHIDEventSystemConnectionEventFilterCompare, 0);
  os_unfair_recursive_lock_unlock();
  CFSetRef v5 = _IOHIDEventSystemConnectionCopyServices((CFSetRef *)a2);
  if (v5)
  {
    CFSetRef v6 = v5;
    CFSetApplyFunction(v5, (CFSetApplierFunction)__IOHIDEventSystemFilterEventServiceRegister, a2);
    CFRelease(v6);
  }
}

uint64_t __IOHIDEventSystemFilterEventServiceRegister(uint64_t a1, const void *a2)
{
  return _IOHIDServiceAddConnection(a1, a2, 1);
}

void __CopyRecordForCientFunction(uint64_t a1, _DWORD *a2, __CFArray *a3)
{
  CFArrayRef v4 = _IOHIDServiceCopyServiceInfoForClient(a2, (const void *)*MEMORY[0x1E4F1D260]);
  if (v4)
  {
    CFSetRef v5 = v4;
    CFArrayAppendValue(a3, v4);
    CFRelease(v5);
  }
}

__CFDictionary *_IOHIDEventSystemCopyRecord(CFTypeRef *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    int valuePtr = 0;
    CFAllocatorRef v4 = CFGetAllocator(a1);
    CFNumberRef v5 = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionarySetValue(Mutable, @"Type", v5);
      CFRelease(v6);
      CFAllocatorRef v7 = CFGetAllocator(a1);
      CFMutableArrayRef v8 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
      if (v8)
      {
        CFMutableArrayRef v9 = v8;
        CFDictionarySetValue(Mutable, @"Services", v8);
        os_unfair_recursive_lock_lock_with_options();
        CFAllocatorRef v10 = CFGetAllocator(a1[2]);
        CFDictionaryRef Copy = CFDictionaryCreateCopy(v10, (CFDictionaryRef)a1[2]);
        os_unfair_recursive_lock_unlock();
        if (Copy)
        {
          CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)__CopyRecordForCientFunction, v9);
          CFRelease(Copy);
        }
        CFRelease(v9);
      }
    }
  }
  return Mutable;
}

void _IOHIDEventSystemDispatchEvent(uint64_t a1, const void *a2)
{
}

void _IOHIDEventSystemRemoveService(uint64_t a1, void *a2)
{
}

uint64_t _IOHIDEventSystemRegisterRecordClientChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 424), a2);

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemUnregisterRecordClientChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 424), a2);

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemRegisterRecordServiceChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 432), a2);

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemUnregisterRecordServiceChanged(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 432), a2);

  return os_unfair_recursive_lock_unlock();
}

void __GDBIOHIDEventSystemDump()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  CFStringRef v0 = CFCopyDescription((CFTypeRef)__IOHIDEventSystem_debug);
  unint64_t v1 = _IOHIDLog();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    int v2 = 136315138;
    CStringPtr = CFStringGetCStringPtr(v0, 0);
    _os_log_impl(&dword_18B46C000, v1, OS_LOG_TYPE_INFO, "event system =\n%s", (uint8_t *)&v2, 0xCu);
  }
  CFRelease(v0);
}

uint64_t _IOHIDEventSystemGetSession(uint64_t a1)
{
  return *(void *)(a1 + 128);
}

void __IOHIDEventSystemRelease(uint64_t a1)
{
  int v2 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B46C000, v2, OS_LOG_TYPE_DEFAULT, "__IOHIDEventSystemRelease", buf, 2u);
  }
  uint64_t v3 = _IOHIDLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)uint64_t v24 = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v3, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "IOHIDEventSystemRelease", (const char *)&unk_18B51B6F3, v24, 2u);
  }
  if (__IOHIDEventSystem_debug == a1) {
    __IOHIDEventSystem_debug = 0;
  }
  uint64_t v4 = *(NSObject **)(a1 + 440);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(a1 + 440));
  }
  CFNumberRef v5 = *(const void **)(a1 + 128);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 128) = 0;
  }
  CFNumberRef v6 = *(const void **)(a1 + 152);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 152) = 0;
  }
  CFAllocatorRef v7 = *(const void **)(a1 + 424);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 424) = 0;
  }
  CFMutableArrayRef v8 = *(const void **)(a1 + 432);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 432) = 0;
  }
  CFMutableArrayRef v9 = *(const void **)(a1 + 32);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 32) = 0;
  }
  CFAllocatorRef v10 = *(const void **)(a1 + 88);
  if (v10) {
    _Block_release(v10);
  }
  CFStringRef v11 = *(const void **)(a1 + 48);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 48) = 0;
  }
  CFStringRef v12 = *(const void **)(a1 + 56);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 56) = 0;
  }
  dispatch_time_t v13 = *(const void **)(a1 + 64);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 64) = 0;
  }
  CFMutableDictionaryRef v14 = *(const void **)(a1 + 72);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 72) = 0;
  }
  CFMutableSetRef v15 = *(const void **)(a1 + 24);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v16 = *(IONotificationPort **)(a1 + 96);
  if (v16) {
    IONotificationPortDestroy(v16);
  }
  io_object_t v17 = *(_DWORD *)(a1 + 168);
  if (v17) {
    IOObjectRelease(v17);
  }
  uint64_t v18 = *(const void **)(a1 + 80);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  CFMutableSetRef v19 = *(const void **)(a1 + 176);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 176) = 0;
  }
  CFMutableArrayRef v20 = *(NSObject **)(a1 + 136);
  if (v20) {
    hid_dispatch_queue_release(v20);
  }
  CFMutableSetRef v21 = *(NSObject **)(a1 + 144);
  if (v21) {
    hid_dispatch_queue_release(v21);
  }
  int v22 = *(const void **)(a1 + 40);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  if (__eventSytemAnalyticsEvent)
  {
    IOHIDAnalyticsEventCancel();
    CFRelease((CFTypeRef)__eventSytemAnalyticsEvent);
    __eventSytemAnalyticsEvent = 0;
  }
  unint64_t v23 = *(const void **)(a1 + 16);
  if (v23)
  {
    CFRelease(v23);
    *(void *)(a1 + 16) = 0;
  }
}

CFStringRef __IOHIDEventSystemCopyDebugDesc(void *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFStringRef v4 = CFStringCreateWithFormat(v2, 0, @"<IOHIDEventSystem %p [%p]>{\n\tserviceDict=%@ \n\tnotificationDict=%@ \n\tmatchNotifySet=%@ \n\tclientSet=%@}", a1, v3, a1[2], a1[3], a1[5], a1[6]);
  os_unfair_recursive_lock_unlock();
  return v4;
}

uint64_t __IOHIDEventSystemFilterEventFunction(mach_port_t *cf, uint64_t *a2)
{
  CFAllocatorRef v3 = (_DWORD *)a2[2];
  uint64_t result = *v3;
  if (!result)
  {
    uint64_t result = _IOHIDEventSystemConnectionFilterEvent(cf, *a2, a2[1]);
    CFAllocatorRef v3 = (_DWORD *)a2[2];
  }
  _DWORD *v3 = result;
  return result;
}

CFTypeID IOHIDEventSystemClientGetTypeID(void)
{
  CFTypeID result = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    return __kIOHIDEventSystemClientTypeID;
  }
  return result;
}

uint64_t __IOHIDEventSystemClientServiceRefreshRemovedServiceCallback(void *key, void *a2, CFDictionaryRef theDict)
{
  uint64_t result = CFDictionaryContainsKey(theDict, key);
  if (!result)
  {
    return _IOHIDServiceClientDispatchServiceRemoval(a2);
  }
  return result;
}

uint64_t __IOHIDEventSystemClientTerminationCallback(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFNumberRef v5 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    __IOHIDEventSystemClientTerminationCallback_cold_1();
  }
  os_unfair_recursive_lock_lock_with_options();
  mach_port_name_t v6 = *(_DWORD *)(a2 + 32);
  if (v6)
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v6);
    *(_DWORD *)(a2 + 32) = 0;
  }
  uint64_t v7 = *(void *)(a2 + 40);
  CFMutableArrayRef v8 = *(__CFRunLoop **)(a2 + 384);
  CFStringRef v9 = *(const __CFString **)(a2 + 392);
  uint64_t v10 = *(void *)(a2 + 400);
  os_unfair_recursive_lock_unlock();
  if (*(void *)(a2 + 384))
  {
    __IOHIDEventSystemClientUnscheduleWithRunLoop(a2, v8, v9);
  }
  else if (v10 && v7)
  {
    IOMIGMachPortUnscheduleFromDispatchQueue(v7, v10);
  }
  os_unfair_recursive_lock_lock_with_options();
  CFStringRef v11 = *(const void **)(a2 + 288);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a2 + 288) = 0;
  }
  CFStringRef v12 = *(const void **)(a2 + 272);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a2 + 272) = 0;
  }
  if (v7)
  {
    unsigned int Port = IOMIGMachPortGetPort(v7);
    IOMIGMachPortCacheRemove(Port);
    CFRelease(*(CFTypeRef *)(a2 + 40));
    *(void *)(a2 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  ++*(_DWORD *)(a2 + 144);
  os_unfair_recursive_lock_unlock();
  __IOHIDEventSystemClientRefresh(a2, a3);
  os_unfair_recursive_lock_lock_with_options();
  CFArrayRef v14 = *(const __CFArray **)(a2 + 136);
  if (v14 && CFArrayGetCount(v14) >= 1)
  {
    CFIndex v15 = 0;
    do
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 136), v15);
      if (ValueAtIndex)
      {
        CFDataRef v17 = ValueAtIndex;
        CFTypeID TypeID = CFDataGetTypeID();
        if (TypeID == CFGetTypeID(v17))
        {
          BytePtr = CFDataGetBytePtr(v17);
          if (*(void *)BytePtr)
          {
            CFMutableArrayRef v20 = BytePtr;
            CFMutableSetRef v21 = _IOHIDLogCategory(0xDu);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
            {
              int v22 = *(void (**)(void, void))v20;
              uint64_t v23 = *((void *)v20 + 1);
              uint64_t v24 = *((void *)v20 + 2);
              *(_DWORD *)long long buf = 134218496;
              int v27 = v22;
              __int16 v28 = 2048;
              uint64_t v29 = v23;
              __int16 v30 = 2048;
              uint64_t v31 = v24;
              _os_log_impl(&dword_18B46C000, v21, OS_LOG_TYPE_INFO, "posting reset to (%p)(%p, %p)", buf, 0x20u);
            }
            (*(void (**)(void, void))v20)(*((void *)v20 + 1), *((void *)v20 + 2));
          }
        }
      }
      ++v15;
    }
    while (CFArrayGetCount(*(CFArrayRef *)(a2 + 136)) > v15);
  }
  return os_unfair_recursive_lock_unlock();
}

void *__VirtualServiceNotifier(uint64_t a1, void *a2)
{
  return _IOHIDVirtualServiceClientNotification(a2, 5, 0);
}

uint64_t IOHIDEventSystemClient()
{
  CFStringRef v0 = _IOHIDLog();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR)) {
    IOHIDEventSystemClient_cold_1();
  }
  uint64_t result = IOHIDEventSystemClient___hidClient;
  if (!IOHIDEventSystemClient___hidClient)
  {
    uint64_t result = IOHIDEventSystemClientCreateWithType((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 1, (const __CFDictionary *)0x61746368);
    IOHIDEventSystemClient___hidClient = result;
  }
  return result;
}

uint64_t IOHIDEventSystemClientCreate(const __CFAllocator *a1)
{
  return IOHIDEventSystemClientCreateWithType(a1, 3, (const __CFDictionary *)0x61746368);
}

IOHIDEventSystemClientRef IOHIDEventSystemClientCreateSimpleClient(CFAllocatorRef allocator)
{
  return (IOHIDEventSystemClientRef)IOHIDEventSystemClientCreateWithType(allocator, 4, (const __CFDictionary *)0x61746368);
}

uint64_t IOHIDEventSystemClientUnscheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  __IOHIDEventSystemClientUnscheduleWithRunLoop(a1, a2, a3);
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;

  return os_unfair_recursive_lock_unlock();
}

uint64_t __IOHIDEventSystemClientUnscheduleWithRunLoop(uint64_t result, __CFRunLoop *a2, const __CFString *a3)
{
  if (a2 && a3)
  {
    uint64_t v5 = result;
    os_unfair_recursive_lock_lock_with_options();
    mach_port_name_t v6 = *(__CFRunLoopSource **)(v5 + 64);
    if (v6) {
      CFRunLoopRemoveSource(a2, v6, a3);
    }
    uint64_t v7 = *(void *)(v5 + 40);
    if (v7) {
      IOMIGMachPortUnscheduleFromRunLoop(v7, a2, a3);
    }
    mach_port_t v8 = *(_DWORD *)(v5 + 32);
    if (v8) {
      io_hideventsystem_queue_stop(v8);
    }
    CFStringRef v9 = *(__CFRunLoopSource **)(v5 + 288);
    if (v9) {
      CFRunLoopRemoveSource(a2, v9, a3);
    }
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

uint64_t IOHIDEventSystemClientScheduleWithDispatchQueue(uint64_t a1, NSObject *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  *(unsigned char *)(a1 + 408) = 1;
  os_unfair_recursive_lock_unlock();
  IOHIDEventSystemClientSetDispatchQueue(a1, a2);

  return IOHIDEventSystemClientActivate(a1);
}

uint64_t __IOHIDEventSystemClientAvailabilityCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __IOHIDEventSystemClientTerminationCallback(a1, a4, 0);
}

uint64_t IOHIDEventSystemClientRegisterEventBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (a2) {
    CFStringRef v9 = _Block_copy(a2);
  }
  else {
    CFStringRef v9 = 0;
  }
  *(void *)(a1 + 208) = v9;
  *(void *)(a1 + 216) = a3;
  *(void *)(a1 + 224) = a4;
  os_unfair_recursive_lock_unlock();

  return __IOHIDEventSystemClientStartQueue(a1);
}

uint64_t IOHIDEventSystemClientUnregisterEventCallback(void *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[25] = 0;
  a1[27] = 0;
  a1[28] = 0;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterEventBlock(void *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v2 = (const void *)a1[26];
  if (v2)
  {
    _Block_release(v2);
    a1[26] = 0;
  }
  a1[27] = 0;
  a1[28] = 0;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientRegisterEventFilterCallbackWithPriority(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 232) = a3;
  *(void *)(a1 + 248) = a4;
  *(void *)(a1 + 256) = a5;
  *(_DWORD *)(a1 + 264) = a2;
  os_unfair_recursive_lock_unlock();

  return __IOHIDEventSystemClientStartFilter(a1);
}

uint64_t IOHIDEventSystemClientRegisterEventFilterCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return IOHIDEventSystemClientRegisterEventFilterCallbackWithPriority(a1, -1, a2, a3, a4);
}

uint64_t IOHIDEventSystemClientRegisterEventFilterBlockWithPriority(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (a3) {
    CFStringRef v11 = _Block_copy(a3);
  }
  else {
    CFStringRef v11 = 0;
  }
  *(void *)(a1 + 24(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v11;
  *(void *)(a1 + 248) = a4;
  *(void *)(a1 + 256) = a5;
  *(_DWORD *)(a1 + 264) = a2;
  os_unfair_recursive_lock_unlock();

  return __IOHIDEventSystemClientStartFilter(a1);
}

uint64_t IOHIDEventSystemClientRegisterEventFilterBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return IOHIDEventSystemClientRegisterEventFilterBlockWithPriority(a1, -1, a2, a3, a4);
}

uint64_t IOHIDEventSystemClientUnregisterEventFilterCallback(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(void *)(a1 + 232))
  {
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
    io_hideventsystem_unregister_event_filter(*(_DWORD *)(a1 + 32));
  }

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterEventFilterBlock(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v2 = *(const void **)(a1 + 240);
  if (v2)
  {
    _Block_release(v2);
    *(void *)(a1 + 24(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
    *(void *)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
    io_hideventsystem_unregister_event_filter(*(_DWORD *)(a1 + 32));
  }

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientDispatchEventFilter(void *a1, uint64_t a2, uint64_t a3)
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v6 = a1[30];
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void, void, uint64_t, uint64_t))(v6 + 16))(v6, a1[31], a1[32], a2, a3);
  }
  else
  {
    mach_port_t v8 = (uint64_t (*)(void, void, uint64_t, uint64_t))a1[29];
    if (!v8)
    {
      uint64_t v9 = 0;
      goto LABEL_6;
    }
    uint64_t v7 = v8(a1[31], a1[32], a2, a3);
  }
  uint64_t v9 = v7;
LABEL_6:
  os_unfair_recursive_lock_unlock();
  return v9;
}

void IOHIDEventSystemClientDispatchEvent(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  DataInternal = IOHIDEventCreateDataInternal((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
  if (DataInternal)
  {
    uint64_t v5 = DataInternal;
    CFDataRef v6 = (const __CFData *)_IOHIDCreateBinaryData(v3, DataInternal);
    if (v6)
    {
      CFDataRef v7 = v6;
      BytePtr = CFDataGetBytePtr(v6);
      int Length = CFDataGetLength(v7);
      os_unfair_recursive_lock_lock_with_options();
      uint64_t v10 = io_hideventsystem_dispatch_event(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, 0);
      if (v10 == 268435459 && !*(void *)(a1 + 384) && !*(void *)(a1 + 400))
      {
        __IOHIDEventSystemClientTerminationCallback(v10, a1, 0);
        io_hideventsystem_dispatch_event(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, 0);
      }
      os_unfair_recursive_lock_unlock();
      CFRelease(v7);
    }
    CFRelease(v5);
  }
}

uint64_t _IOHIDEventSystemClientRegisterServiceRecordsChangedCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 352) = a2;
  *(void *)(a1 + 368) = a3;
  *(void *)(a1 + 376) = a4;
  io_hideventsystem_register_record_service_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientRegisterServiceRecordsChangedBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (a2) {
    mach_port_t v8 = _Block_copy(a2);
  }
  else {
    mach_port_t v8 = 0;
  }
  *(void *)(a1 + 36(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v8;
  *(void *)(a1 + 368) = a3;
  *(void *)(a1 + 376) = a4;
  io_hideventsystem_register_record_service_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterServiceRecordsChangedCallback(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  io_hideventsystem_unregister_record_service_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterServiceRecordsChangedBlock(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v2 = *(const void **)(a1 + 360);
  if (v2)
  {
    _Block_release(v2);
    *(void *)(a1 + 36(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  io_hideventsystem_unregister_record_service_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientRegisterClientRecordsChangedCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 32(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a2;
  *(void *)(a1 + 336) = a3;
  *(void *)(a1 + 344) = a4;
  io_hideventsystem_register_record_client_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientRegisterClientRecordsChangedBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (a2) {
    mach_port_t v8 = _Block_copy(a2);
  }
  else {
    mach_port_t v8 = 0;
  }
  *(void *)(a1 + 328) = v8;
  *(void *)(a1 + 336) = a3;
  *(void *)(a1 + 344) = a4;
  io_hideventsystem_register_record_client_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterClientRecordsChangedCallback(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(void *)(a1 + 32(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  io_hideventsystem_unregister_record_client_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t _IOHIDEventSystemClientUnregisterClientRecordsChangedBlock(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v2 = *(const void **)(a1 + 328);
  if (v2)
  {
    _Block_release(v2);
    *(void *)(a1 + 328) = 0;
  }
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  io_hideventsystem_unregister_record_client_changed_notification(*(_DWORD *)(a1 + 32));

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterDeviceMatchingCallback(void *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  a1[21] = 0;
  a1[23] = 0;
  a1[24] = 0;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientRegisterDeviceMatchingBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (a2) {
    uint64_t v9 = _Block_copy(a2);
  }
  else {
    uint64_t v9 = 0;
  }
  *(void *)(a1 + 176) = v9;
  *(void *)(a1 + 184) = a3;
  *(void *)(a1 + 192) = a4;

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventSystemClientUnregisterDeviceMatchingBlock(void *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  CFAllocatorRef v2 = (const void *)a1[22];
  if (v2)
  {
    _Block_release(v2);
    a1[22] = 0;
  }
  a1[23] = 0;
  a1[24] = 0;

  return os_unfair_recursive_lock_unlock();
}

const void *IOHIDEventSystemClientCopyServiceForRegistryID(uint64_t a1, uint64_t a2)
{
  Service = __IOHIDEventSystemClientGetService(a1, a2);
  CFAllocatorRef v3 = Service;
  if (Service) {
    CFRetain(Service);
  }
  return v3;
}

CFNumberRef _IOHIDEventSystemClientServiceConformsTo(uint64_t a1, IOHIDServiceClientRef service, int a3, int a4)
{
  CFNumberRef result = (const __CFNumber *)IOHIDServiceClientGetRegistryID(service);
  uint64_t valuePtr = 0;
  if (result)
  {
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return (const __CFNumber *)IOHIDEventSystemClientRegistryIDConformsTo(a1, valuePtr, a3, a4);
  }
  return result;
}

BOOL IOHIDEventSystemClientRegistryIDConformsTo(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t valuePtr = a2;
  int v22 = 0;
  if (!a1) {
    return 0;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (!v8) {
    return 0;
  }
  CFNumberRef v9 = v8;
  CFDataRef v10 = (const __CFData *)_IOHIDCreateBinaryData(v7, v8);
  if (!v10)
  {
    BOOL v17 = 0;
    goto LABEL_13;
  }
  CFDataRef v11 = v10;
  os_unfair_recursive_lock_lock_with_options();
  mach_port_t v12 = *(_DWORD *)(a1 + 32);
  BytePtr = CFDataGetBytePtr(v11);
  int Length = CFDataGetLength(v11);
  uint64_t v15 = io_hideventsystem_service_conforms_to(v12, (uint64_t)BytePtr, Length, a3, a4, &v22);
  int v16 = v15;
  if (v15 == 268435459)
  {
    if (*(void *)(a1 + 384) || *(void *)(a1 + 400))
    {
      os_unfair_recursive_lock_unlock();
      goto LABEL_8;
    }
    __IOHIDEventSystemClientTerminationCallback(v15, a1, 0);
    mach_port_t v18 = *(_DWORD *)(a1 + 32);
    CFMutableSetRef v19 = CFDataGetBytePtr(v11);
    int v20 = CFDataGetLength(v11);
    int v16 = io_hideventsystem_service_conforms_to(v18, (uint64_t)v19, v20, a3, a4, &v22);
  }
  os_unfair_recursive_lock_unlock();
  if (!v16)
  {
    BOOL v17 = v22 != 0;
    goto LABEL_12;
  }
LABEL_8:
  BOOL v17 = 0;
LABEL_12:
  CFRelease(v11);
LABEL_13:
  CFRelease(v9);
  return v17;
}

CFPropertyListRef _IOHIDEventSystemClientCopyPropertiesForService(uint64_t a1, IOHIDServiceClientRef service, const void *a3)
{
  CFPropertyListRef v3 = 0;
  CFIndex length = 0;
  unsigned int bytes = 0;
  if (!a1 || !service || !a3) {
    return v3;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFTypeRef RegistryID = IOHIDServiceClientGetRegistryID(service);
  CFDataRef v8 = (const __CFData *)_IOHIDCreateBinaryData(v6, RegistryID);
  if (!v8) {
    return 0;
  }
  CFDataRef v9 = v8;
  BytePtr = CFDataGetBytePtr(v8);
  int v11 = CFDataGetLength(v9);
  CFDataRef v12 = (const __CFData *)_IOHIDCreateBinaryData(v6, a3);
  if (!v12)
  {
    CFRelease(v9);
    return 0;
  }
  CFDataRef v13 = v12;
  CFArrayRef v14 = CFDataGetBytePtr(v12);
  int v15 = CFDataGetLength(v13);
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v16 = io_hideventsystem_copy_properties_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, (uint64_t)v14, v15, &bytes, (_DWORD *)&length + 1, &length);
  int v17 = v16;
  if (v16 == 268435459)
  {
    if (*(void *)(a1 + 384))
    {
      int v17 = 268435459;
    }
    else
    {
      int v17 = 268435459;
      if (!*(void *)(a1 + 400))
      {
        __IOHIDEventSystemClientTerminationCallback(v16, a1, 0);
        int v17 = io_hideventsystem_copy_properties_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, v11, (uint64_t)v14, v15, &bytes, (_DWORD *)&length + 1, &length);
      }
    }
  }
  os_unfair_recursive_lock_unlock();
  if (v17 | length) {
    CFPropertyListRef v3 = 0;
  }
  else {
    CFPropertyListRef v3 = _IOHIDUnserializeAndVMDealloc(bytes, HIDWORD(length));
  }
  CFRelease(v9);
  CFRelease(v13);
  return v3;
}

uint64_t _IOHIDEventSystemClientCopyMatchingEventForService(uint64_t a1, IOHIDServiceClientRef service, const UInt8 *BytePtr)
{
  uint64_t v39 = 0;
  unsigned int v38 = 0;
  uint64_t valuePtr = 0;
  if (!a1 || !service)
  {
    uint64_t v32 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_1();
    }
    return 0;
  }
  CFNumberRef RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(service);
  if (!RegistryID || (CFNumberRef v6 = RegistryID, v7 = CFGetTypeID(RegistryID), v7 != CFNumberGetTypeID()))
  {
    uint64_t v31 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_2();
    }
    return 0;
  }
  CFNumberGetValue(v6, kCFNumberSInt64Type, &valuePtr);
  if (!BytePtr)
  {
    CFDataRef v15 = 0;
    int Length = 0;
    mach_port_t v18 = 0;
    CFDataRef v9 = 0;
    goto LABEL_20;
  }
  CFNumberRef Value = (__CFData *)CFDictionaryGetValue((CFDictionaryRef)BytePtr, @"MatchingEvent");
  CFDataRef v9 = Value;
  if (!Value)
  {
    mach_port_t v18 = 0;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    goto LABEL_15;
  }
  CFTypeID v10 = CFGetTypeID(Value);
  uint64_t TypeID = IOHIDEventGetTypeID();
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v10 != TypeID)
  {
    mach_port_t v18 = 0;
    CFDataRef v9 = 0;
    goto LABEL_15;
  }
  DataInternal = IOHIDEventCreateDataInternal((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t)v9);
  if (!DataInternal)
  {
    double v34 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_4();
    }
    return 0;
  }
  CFDataRef v9 = DataInternal;
  CFDataRef v14 = (const __CFData *)_IOHIDCreateBinaryData(v12, DataInternal);
  if (!v14)
  {
    int v35 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_5();
    }
    mach_port_t v18 = 0;
    CFDataRef v15 = 0;
    goto LABEL_52;
  }
  CFDataRef v15 = v14;
  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)BytePtr);
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v12, Count, (CFDictionaryRef)BytePtr);
  if (!MutableCopy)
  {
    double v36 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_6();
    }
    mach_port_t v18 = 0;
LABEL_52:
    uint64_t v24 = 0;
    goto LABEL_28;
  }
  mach_port_t v18 = MutableCopy;
  CFDictionarySetValue(MutableCopy, @"MatchingEvent", v15);
  CFRelease(v15);
LABEL_15:
  if (v18) {
    int v20 = (const UInt8 *)v18;
  }
  else {
    int v20 = BytePtr;
  }
  CFDataRef v21 = (const __CFData *)_IOHIDCreateBinaryData(v12, v20);
  if (!v21)
  {
    int v33 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      _IOHIDEventSystemClientCopyMatchingEventForService_cold_3();
    }
    uint64_t v24 = 0;
    CFDataRef v15 = 0;
    goto LABEL_27;
  }
  CFDataRef v15 = v21;
  BytePtr = CFDataGetBytePtr(v21);
  int Length = CFDataGetLength(v15);
LABEL_20:
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v22 = io_hideventsystem_copy_matching_event_for_service(*(_DWORD *)(a1 + 32), valuePtr, (uint64_t)BytePtr, Length, &v39, &v38);
  int v23 = v22;
  if (v22 == 268435459)
  {
    if (*(void *)(a1 + 384) || *(void *)(a1 + 400))
    {
      os_unfair_recursive_lock_unlock();
LABEL_26:
      uint64_t v24 = 0;
      goto LABEL_27;
    }
    __IOHIDEventSystemClientTerminationCallback(v22, a1, 0);
    int v23 = io_hideventsystem_copy_matching_event_for_service(*(_DWORD *)(a1 + 32), valuePtr, (uint64_t)BytePtr, Length, &v39, &v38);
  }
  os_unfair_recursive_lock_unlock();
  if (v23) {
    goto LABEL_26;
  }
  CFDictionaryRef v26 = v39;
  mach_vm_size_t v27 = v38;
  CFTypeID v28 = CFDataGetTypeID();
  uint64_t v29 = _IOHIDUnserializeAndVMDeallocWithTypeID(v26, v27, v28);
  if (!v29) {
    goto LABEL_26;
  }
  __int16 v30 = v29;
  uint64_t v24 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E4F1CF80], v29);
  CFRelease(v30);
LABEL_27:
  if (v9) {
LABEL_28:
  }
    CFRelease(v9);
  if (v15) {
    CFRelease(v15);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v24;
}

uint64_t _IOHIDEventSystemClientSetElementValueForService(uint64_t a1, IOHIDServiceClientRef service, int a3, int a4, int a5)
{
  uint64_t v5 = 3758097090;
  unsigned int v18 = -536870206;
  if (a1)
  {
    if (service)
    {
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFTypeRef RegistryID = IOHIDServiceClientGetRegistryID(service);
      CFDataRef v12 = (const __CFData *)_IOHIDCreateBinaryData(v10, RegistryID);
      if (v12)
      {
        CFDataRef v13 = v12;
        BytePtr = CFDataGetBytePtr(v12);
        int Length = CFDataGetLength(v13);
        os_unfair_recursive_lock_lock_with_options();
        uint64_t v16 = io_hideventsystem_set_element_value_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, a3, a4, a5, (int *)&v18);
        if (v16 == 268435459 && !*(void *)(a1 + 384) && !*(void *)(a1 + 400))
        {
          __IOHIDEventSystemClientTerminationCallback(v16, a1, 0);
          io_hideventsystem_set_element_value_for_service(*(_DWORD *)(a1 + 32), (uint64_t)BytePtr, Length, a3, a4, a5, (int *)&v18);
        }
        os_unfair_recursive_lock_unlock();
        CFRelease(v13);
        return v18;
      }
    }
  }
  return v5;
}

void IOHIDEventSystemClientRegisterPropertyChangedCallback(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_unfair_recursive_lock_lock_with_options();
  if (!*(unsigned char *)(a1 + 408))
  {
    if (atomic_load((unsigned int *)(a1 + 312))) {
      IOHIDEventSystemClientRegisterEventCallback_cold_1();
    }
  }
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  if (!*(void *)(a1 + 120))
  {
    memset(&v14, 0, sizeof(v14));
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)a1);
    *(void *)(a1 + 12(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E4F1D530], &v14);
  }
  os_unfair_recursive_lock_unlock();
  CFDataRef v12 = malloc_type_malloc(0x20uLL, 0xE00408373F082uLL);
  void *v12 = a2;
  v12[1] = a3;
  uint32x2_t v12[2] = a4;
  v12[3] = a5;
  os_unfair_recursive_lock_lock_with_options();
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), a2, v12);
  os_unfair_recursive_lock_unlock();
  __IOHIDEventSystemClientRegisterPropertyCallbackRegisterFunction(a2, v13, a1);
}

void __IOHIDEventSystemClientRegisterPropertyCallbackRegisterFunction(const void *a1, uint64_t a2, uint64_t a3)
{
  CFDataRef v4 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
  if (v4)
  {
    CFDataRef v5 = v4;
    os_unfair_recursive_lock_lock_with_options();
    int v6 = *(_DWORD *)(a3 + 32);
    BytePtr = CFDataGetBytePtr(v5);
    int Length = CFDataGetLength(v5);
    io_hideventsystem_register_property_changed_notification(v6, (uint64_t)BytePtr, Length);
    os_unfair_recursive_lock_unlock();
    CFRelease(v5);
  }
}

void IOHIDEventSystemClientUnregisterPropertyChangedCallback(uint64_t a1, const void *a2)
{
  os_unfair_recursive_lock_lock_with_options();
  CFNumberRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 120), a2);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 120), a2);
  os_unfair_recursive_lock_unlock();
  if (Value) {
    free(Value);
  }
  CFDataRef v5 = (const __CFData *)_IOHIDCreateBinaryData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (v5)
  {
    CFDataRef v6 = v5;
    os_unfair_recursive_lock_lock_with_options();
    int v7 = *(_DWORD *)(a1 + 32);
    BytePtr = CFDataGetBytePtr(v6);
    int Length = CFDataGetLength(v6);
    io_hideventsystem_unregister_property_changed_notification(v7, (uint64_t)BytePtr, Length);
    os_unfair_recursive_lock_unlock();
    CFRelease(v6);
  }
}

uint64_t _IOHIDEventSystemClientDispatchPropertiesChanged(uint64_t a1, uint64_t a2)
{
  os_unfair_recursive_lock_lock_with_options();
  gettimeofday((timeval *)(a1 + 496), 0);
  ++*(void *)(a1 + 512);
  os_unfair_recursive_lock_unlock();
  os_unfair_recursive_lock_lock_with_options();
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 120);
  if (v4)
  {
    v6[0] = a1;
    v6[1] = a2;
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRegisterPropertyCallbackApplyFunction, v6);
  }
  return os_unfair_recursive_lock_unlock();
}

void __IOHIDEventSystemClientRegisterPropertyCallbackApplyFunction(uint64_t a1, uint64_t a2, void *a3)
{
  CFDictionaryRef v3 = (const __CFDictionary *)a3[1];
  v4[0] = *a3;
  v4[1] = a2;
  CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)_IOHIDEventSystemClientDispatchPropertiesChangedFunction, v4);
}

CFIndex IOHIDEventSystemClientUnregisterResetCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_recursive_lock_lock_with_options();
  CFIndex result = __IOHIDEventSystemClientFindCallback(a1, a2, a3, a4);
  if (result != -1)
  {
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 136), result);
    return os_unfair_recursive_lock_unlock();
  }
  return result;
}

const char *IOHIDEventSystemClientGetTypeString(unsigned int a1)
{
  if (a1 > 4) {
    return "Invalid";
  }
  else {
    return off_1E548A310[a1];
  }
}

uint64_t _iohideventsystem_client_dispatch_properties_changed(unsigned int a1, UInt8 *bytes, CFIndex length)
{
  CFPropertyListRef v4 = _IOHIDUnserializeAndVMDealloc(bytes, length);
  if (v4)
  {
    CFDataRef v5 = v4;
    CFDataRef v6 = IOMIGMachPortCacheCopy(a1);
    if (v6)
    {
      int v7 = v6;
      CFTypeID v8 = CFGetTypeID(v6);
      uint64_t v9 = __kIOHIDEventSystemClientTypeID;
      if (!__kIOHIDEventSystemClientTypeID)
      {
        pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
        uint64_t v9 = __kIOHIDEventSystemClientTypeID;
      }
      if (v8 == v9) {
        _IOHIDEventSystemClientDispatchPropertiesChanged((uint64_t)v7, (uint64_t)v5);
      }
      CFRelease(v7);
    }
    CFRelease(v5);
  }
  return 0;
}

uint64_t _iohideventsystem_client_dispatch_event_filter(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  CFAllocatorRef v11 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  if (v11)
  {
    CFDataRef v12 = v11;
    CFTypeID v13 = CFGetTypeID(v11);
    uint64_t v14 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      uint64_t v14 = __kIOHIDEventSystemClientTypeID;
    }
    if (v13 != v14) {
      goto LABEL_17;
    }
    CFPropertyListRef v15 = _IOHIDUnserializeAndVMDealloc(a2, a3);
    if (v15)
    {
      os_unfair_recursive_lock_lock_with_options();
      CFNumberRef Value = CFDictionaryGetValue(v12[12], v15);
      os_unfair_recursive_lock_unlock();
    }
    else
    {
      CFNumberRef Value = 0;
    }
    CFTypeID TypeID = CFDataGetTypeID();
    unsigned int v18 = _IOHIDUnserializeAndVMDeallocWithTypeID(a4, a5, TypeID);
    if (!v18)
    {
LABEL_15:
      if (v15) {
        CFRelease(v15);
      }
LABEL_17:
      CFRelease(v12);
      return 0;
    }
    CFMutableSetRef v19 = v18;
    uint64_t v20 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E4F1CF80], v18);
    CFDataRef v21 = (const void *)v20;
    if (a6 && v20)
    {
      *a6 = _IOHIDEventSystemClientDispatchEventFilter(v12, (uint64_t)Value, v20);
    }
    else if (!v20)
    {
LABEL_14:
      CFRelease(v19);
      goto LABEL_15;
    }
    CFRelease(v21);
    goto LABEL_14;
  }
  return 0;
}

uint64_t _iohideventsystem_client_dispatch_client_records_changed(unsigned int a1)
{
  unint64_t v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    CFAllocatorRef v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    uint64_t v4 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      uint64_t v4 = __kIOHIDEventSystemClientTypeID;
    }
    if (v3 == v4)
    {
      os_unfair_recursive_lock_lock_with_options();
      CFDataRef v5 = (void (*)(void, void *, void))v2[40];
      if (v5)
      {
        v5(v2[42], v2, v2[43]);
      }
      else
      {
        uint64_t v6 = v2[41];
        if (v6) {
          (*(void (**)(uint64_t, void, void *, void))(v6 + 16))(v6, v2[42], v2, v2[43]);
        }
      }
      os_unfair_recursive_lock_unlock();
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t _iohideventsystem_client_dispatch_service_records_changed(unsigned int a1)
{
  unint64_t v1 = IOMIGMachPortCacheCopy(a1);
  if (v1)
  {
    CFAllocatorRef v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    uint64_t v4 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      uint64_t v4 = __kIOHIDEventSystemClientTypeID;
    }
    if (v3 == v4)
    {
      os_unfair_recursive_lock_lock_with_options();
      CFDataRef v5 = (void (*)(void, void *, void))v2[44];
      if (v5)
      {
        v5(v2[46], v2, v2[47]);
      }
      else
      {
        uint64_t v6 = v2[45];
        if (v6) {
          (*(void (**)(uint64_t, void, void *, void))(v6 + 16))(v6, v2[46], v2, v2[47]);
        }
      }
      os_unfair_recursive_lock_unlock();
    }
    CFRelease(v2);
  }
  return 0;
}

uint64_t IOHIDVirtualServiceClientRemove(__IOHIDServiceClient *a1)
{
  uint64_t valuePtr = 0;
  uint64_t EventSystemClient = _IOHIDVirtuaServiceClientGetEventSystemClient((uint64_t)a1);
  CFNumberRef RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(a1);
  CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
  os_unfair_recursive_lock_lock_with_options();
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(EventSystemClient + 104), valuePtr))
  {
    if (io_hideventsystem_remove_virtual_service(*(_DWORD *)(EventSystemClient + 32), (uint64_t)valuePtr))
    {
      uint64_t v4 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        IOHIDVirtualServiceClientRemove_cold_1();
      }
    }
  }
  _IOHIDVirtualServiceClientNotification(a1, 3, 0);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(EventSystemClient + 104), valuePtr);
  return os_unfair_recursive_lock_unlock();
}

uint64_t _iohideventsystem_output_event_to_virtual_service(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, _DWORD *a5)
{
  mach_vm_size_t v9 = a4;
  CFTypeID TypeID = CFDataGetTypeID();
  CFAllocatorRef v11 = (CFDictionaryRef *)_IOHIDUnserializeAndVMDeallocWithTypeID(a3, v9, TypeID);
  if (v11)
  {
    CFDataRef v12 = v11;
    uint64_t v13 = IOHIDEventCreateWithDataInternal(*MEMORY[0x1E4F1CF80], v11);
    if (!v13)
    {
      *a5 = -536870211;
      uint64_t v22 = v12;
      goto LABEL_13;
    }
    uint64_t v14 = (const void *)v13;
    CFPropertyListRef v15 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
    uint64_t v16 = v15;
    if (!v15) {
      goto LABEL_15;
    }
    CFTypeID v17 = CFGetTypeID(v15);
    uint64_t v18 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      uint64_t v18 = __kIOHIDEventSystemClientTypeID;
    }
    if (v17 == v18)
    {
      os_unfair_recursive_lock_lock_with_options();
      CFNumberRef Value = CFDictionaryGetValue(v16[13], a2);
      if (Value)
      {
        uint64_t v20 = Value;
        CFRetain(Value);
        os_unfair_recursive_lock_unlock();
        *a5 = _IOHIDVirtualServiceClientSetOputputEvent(v20, (uint64_t)v14);
        CFRelease(v20);
        CFRelease(v12);
        CFRelease(v14);
LABEL_12:
        uint64_t v22 = v16;
LABEL_13:
        CFRelease(v22);
        return 0;
      }
      os_unfair_recursive_lock_unlock();
      *a5 = -536870208;
      CFDataRef v21 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        _iohideventsystem_output_event_to_virtual_service_cold_2();
      }
    }
    else
    {
LABEL_15:
      *a5 = -536870212;
    }
    CFRelease(v12);
    CFRelease(v14);
    if (v16) {
      goto LABEL_12;
    }
  }
  else
  {
    *a5 = -536870206;
    uint64_t v24 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      _iohideventsystem_output_event_to_virtual_service_cold_1();
    }
  }
  return 0;
}

uint64_t _iohideventsystem_copy_matching_event_from_virtual_service(unsigned int a1, const void *a2, UInt8 *a3, unsigned int a4, vm_offset_t *a5, _DWORD *a6)
{
  mach_vm_size_t v11 = a4;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  uint64_t v13 = _IOHIDUnserializeAndVMDeallocWithTypeID(a3, v11, TypeID);
  uint64_t v14 = (CFDictionaryRef *)IOMIGMachPortCacheCopy(a1);
  CFPropertyListRef v15 = v14;
  if (!v14) {
    goto LABEL_20;
  }
  CFTypeID v16 = CFGetTypeID(v14);
  uint64_t v17 = __kIOHIDEventSystemClientTypeID;
  if (!__kIOHIDEventSystemClientTypeID)
  {
    pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
    uint64_t v17 = __kIOHIDEventSystemClientTypeID;
  }
  if (v16 == v17)
  {
    os_unfair_recursive_lock_lock_with_options();
    CFNumberRef Value = CFDictionaryGetValue(v15[13], a2);
    if (Value)
    {
      CFMutableSetRef v19 = Value;
      CFRetain(Value);
      os_unfair_recursive_lock_unlock();
      uint64_t v20 = (const void *)_IOHIDVirtualServiceClientCopyMatchingEvent(v19, (uint64_t)v13);
      if (v20)
      {
        CFAllocatorRef v21 = CFGetAllocator(v19);
        DataInternal = IOHIDEventCreateDataInternal(v21, (uint64_t)v20);
      }
      else
      {
        DataInternal = 0;
      }
      *a6 = _IOHIDSerialize(DataInternal, a5);
      CFRelease(v19);
      if (v20) {
        CFRelease(v20);
      }
      if (DataInternal) {
        CFRelease(DataInternal);
      }
    }
    else
    {
      os_unfair_recursive_lock_unlock();
      int v23 = _IOHIDLogCategory(0xDu);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        _iohideventsystem_output_event_to_virtual_service_cold_2();
      }
    }
  }
  else
  {
LABEL_20:
    int v25 = _IOHIDLogCategory(0xDu);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      _iohideventsystem_client_dispatch_virtual_service_copy_property_cold_2();
    }
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v15) {
    CFRelease(v15);
  }
  return 0;
}

uint64_t _iohideventsystem_client_refresh(unsigned int a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = IOMIGMachPortCacheCopy(a1);
  uint64_t v22 = 0;
  unsigned int v21 = 0;
  if (v1)
  {
    CFAllocatorRef v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    uint64_t v4 = __kIOHIDEventSystemClientTypeID;
    if (!__kIOHIDEventSystemClientTypeID)
    {
      pthread_once(&__systemTypeInit_0, (void (*)(void))__IOHIDEventSystemClientRegister);
      uint64_t v4 = __kIOHIDEventSystemClientTypeID;
    }
    if (v3 == v4)
    {
      os_unfair_recursive_lock_lock_with_options();
      CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((CFDictionaryRef *)v2 + 12));
      if (Copy)
      {
        CFDictionaryRef v6 = Copy;
        int v7 = io_hideventsystem_do_client_refresh(*((_DWORD *)v2 + 8), &v22, &v21);
        CFTypeID v8 = _IOHIDLogCategory(0xDu);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v7;
          _os_log_impl(&dword_18B46C000, v8, OS_LOG_TYPE_INFO, "io_hideventsystem_do_client_refresh:0x%x", buf, 8u);
        }
        if (v7)
        {
          os_unfair_recursive_lock_unlock();
          CFDictionaryRef v9 = v6;
LABEL_21:
          CFRelease(v9);
          return 0;
        }
        CFAllocatorRef v10 = v22;
        mach_vm_size_t v11 = v21;
        CFTypeID TypeID = CFArrayGetTypeID();
        CFArrayRef v13 = (const __CFArray *)_IOHIDUnserializeAndVMDeallocWithTypeID(v10, v11, TypeID);
        CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)v2 + 12));
        uint64_t v14 = _IOHIDLogCategory(0xDu);
        BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
        if (v13)
        {
          if (v15)
          {
            CFIndex Count = CFArrayGetCount(v13);
            CFIndex v17 = CFDictionaryGetCount(v6);
            *(_DWORD *)long long buf = 134218240;
            *(void *)&uint8_t buf[4] = Count;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v17;
            _os_log_impl(&dword_18B46C000, v14, OS_LOG_TYPE_DEFAULT, "HID Event System Client refreshed with %ld services, cached matching had %ld services", buf, 0x16u);
          }
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = ____IOHIDEventSystemClientCacheServices_block_invoke;
          int v25 = &__block_descriptor_tmp_124;
          CFDictionaryRef v26 = v2;
          _IOHIDCFArrayApplyBlock(v13, buf);
        }
        else if (v15)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_18B46C000, v14, OS_LOG_TYPE_DEFAULT, "HID Event System Client refreshed but no services returned", buf, 2u);
        }
        CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)__IOHIDEventSystemClientServiceReplaceCallback, *((void **)v2 + 12));
        CFAllocatorRef v18 = CFGetAllocator(v2);
        CFDictionaryRef v19 = CFDictionaryCreateCopy(v18, *((CFDictionaryRef *)v2 + 12));
        os_unfair_recursive_lock_unlock();
        CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)__IOHIDEventSystemClientServiceRefreshRemovedServiceCallback, v19);
        context[0] = v2;
        context[1] = v6;
        CFDictionaryApplyFunction(v19, (CFDictionaryApplierFunction)__IOHIDEventSystemClientRefreshServiceCallback, context);
        CFRelease(v6);
        if (v13) {
          CFRelease(v13);
        }
        if (v19)
        {
          CFDictionaryRef v9 = v19;
          goto LABEL_21;
        }
      }
      else
      {
        os_unfair_recursive_lock_unlock();
      }
    }
  }
  return 0;
}

uint64_t __IOHIDEventSystemClientConnectionPropertyFunction(const __CFString *a1, const void *a2, __IOHIDEventSystemClient *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v6 = _IOHIDLogCategory(0xDu);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v8 = 138412546;
    CFStringRef v9 = a1;
    __int16 v10 = 2112;
    mach_vm_size_t v11 = a2;
    _os_log_impl(&dword_18B46C000, v6, OS_LOG_TYPE_INFO, "restore property %@ to %@", (uint8_t *)&v8, 0x16u);
  }
  return IOHIDEventSystemClientSetProperty(a3, a1, a2);
}

uint64_t _IOHIDEventSystemClientDispatchPropertiesChangedFunction(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = CFEqual(a1, **(CFTypeRef **)(a3 + 8));
  if (result)
  {
    int v7 = *(void **)(a3 + 8);
    CFStringRef v9 = (uint64_t (*)(uint64_t, uint64_t, const void *, uint64_t))v7[1];
    uint64_t v8 = v7[2];
    uint64_t v10 = v7[3];
    return v9(v8, v10, a1, a2);
  }
  return result;
}

void OUTLINED_FUNCTION_3_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

uint64_t IOHIDNotificationGetTypeID()
{
  uint64_t result = __kIOHIDNotificationTypeID;
  if (!__kIOHIDNotificationTypeID)
  {
    pthread_once(&__notificationTypeInit, (void (*)(void))__IOHIDNotificationRegister);
    return __kIOHIDNotificationTypeID;
  }
  return result;
}

uint64_t IOHIDNotificationGetClientCallback(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t IOHIDNotificationGetClientTarget(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t IOHIDNotificationGetClientRefcon(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t IOHIDNotificationGetOwnerCallback(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t IOHIDNotificationGetOwnerTarget(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t IOHIDNotificationGetOwnerRefcon(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

intptr_t __IOHIDNotificationInvalidate_block_invoke(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

CFStringRef __IOHIDNotificationCopyDebugDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, @"<IOHIDNotificationRef %p (ref:%d xref:%d), flags:%x  %p,%p,%p,%p,%p,%p>", a1, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 72), *(void *)(a1 + 24), *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64));
}

const void *_IOHIDServiceCreateVirtual(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  VirtualNoInit = __IOHIDServiceCreateVirtualNoInit(a1, a2, a3, a4, a5);
  int v7 = VirtualNoInit;
  if (VirtualNoInit && !__IOHIDServiceInit((uint64_t)VirtualNoInit, a2))
  {
    CFRelease(v7);
    return 0;
  }
  return v7;
}

uint64_t _IOHIDServiceCreate(uint64_t a1, io_registry_entry_t entry)
{
  kern_return_t v5;
  int v6;
  NSObject *v7;
  CFUUIDRef v9;
  CFUUIDRef v10;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v12;
  CFArrayRef v13;
  CFArrayRef v14;
  CFIndex v15;
  __CFBundle *ValueAtIndex;
  CFDictionaryRef InfoDictionary;
  CFDictionaryRef v18;
  CFDictionaryRef v19;
  CFDictionaryRef v20;
  CFTypeID v21;
  CFTypeID TypeID;
  NSObject *v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFTypeID v26;
  __CFDictionary *v27;
  CFDictionaryRef v28;
  CFIndex v29;
  void *v30;
  __CFBundle *v31;
  CFDictionaryRef v32;
  CFDictionaryRef v33;
  const void *v34;
  const void *v35;
  CFTypeID v36;
  CFStringRef v37;
  CFStringRef v38;
  void *DataPointerForName;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  id v44;
  const void *v45;
  Protocol *Protocol;
  const char *Uid;
  const char *v48;
  const char *v49;
  const char *v50;
  char v51;
  uint64_t v52;
  unsigned int (*v53)(uint64_t, void, void, uint64_t);
  CFAllocatorRef v54;
  CFUUIDRef v55;
  CFUUIDBytes v56;
  uint64_t v57;
  unsigned int (*v58)(uint64_t, void, void, uint64_t);
  CFUUIDRef v59;
  CFUUIDBytes v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  NSObject *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  NSObject *v85;
  kern_return_t v86;
  unsigned int v87;
  uint64_t v88;
  CFAllocatorRef allocator;
  io_service_t object;
  uint64_t entryID;
  SInt32 theScore;
  void *value;
  unsigned int valuePtr;
  unsigned char context[24];
  void *v96;
  unsigned char *v97;
  io_service_t v98;
  unsigned char buf[12];
  unsigned char v100[24];
  int v101;
  uint64_t v102;

  CFTypeID v102 = *MEMORY[0x1E4F143B8];
  SInt32 theScore = 0;
  uint64_t entryID = 0;
  IORegistryEntryGetRegistryEntryID(entry, &entryID);
  if (__serviceRunLoopInit != -1) {
    dispatch_once(&__serviceRunLoopInit, &__block_literal_global_10);
  }
  _IOHIDDebugTrace(8257, 1, entryID, 0, 0, 0);
  uint64_t Private = _IOHIDServiceCreatePrivate(a1);
  if (!Private) {
    goto LABEL_7;
  }
  uint64_t v5 = IOObjectRetain(entry);
  if (v5)
  {
    CFDictionaryRef v6 = v5;
    int v7 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      _IOHIDServiceCreate_cold_4(v6, v7);
    }
    goto LABEL_7;
  }
  *(_DWORD *)(Private + 16) = entry;
  CFStringRef v9 = CFUUIDGetConstantUUIDWithBytes(0, 5u, 0x16u, 0xB5u, 0x63u, 0xB1u, 0x5Bu, 0x11u, 0xDAu, 0x96u, 0xEBu, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  uint64_t v10 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  CFNumberRef v86 = IOCreatePlugInInterfaceForService(entry, v9, v10, (IOCFPlugInInterface ***)(Private + 40), &theScore);
  if (v86)
  {
    object = *(_DWORD *)(Private + 16);
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (!Mutable) {
      goto LABEL_78;
    }
    uint64_t v12 = Mutable;
    CFArrayRef v13 = (const __CFArray *)_IOHIDLoadServicePluginBundles();
    if (!v13) {
      goto LABEL_77;
    }
    uint64_t v14 = v13;
    if (CFArrayGetCount(v13) >= 1)
    {
      BOOL v15 = 0;
      uint64_t v87 = 0;
      do
      {
        *(void *)CFNumberRef v100 = 0;
        *(void *)&v100[8] = v100;
        *(void *)&v100[16] = 0x2000000000;
        CFNumberRef v101 = 0;
        uint64_t valuePtr = 0;
        xpc_object_t value = 0;
        CFDataRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v14, v15);
        CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(ValueAtIndex);
        if (InfoDictionary)
        {
          CFAllocatorRef v18 = InfoDictionary;
          CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, @"Matching");
          if (v19 && (uint64_t v20 = v19, v21 = CFGetTypeID(v19), v21 == CFDictionaryGetTypeID()))
          {
            if (CFDictionaryGetValueIfPresent(v20, @"IOKitPersonalities", (const void **)&value)
              && (CFTypeID TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(value)))
            {
              *(void *)CFRunLoopSourceContext context = MEMORY[0x1E4F143A8];
              *(void *)&context[8] = 0x40000000;
              *(void *)&context[16] = ____IOHIDServiceMatchObjcServicePlugin_block_invoke;
              v96 = &unk_1E548A6C8;
              CFNumberRef v98 = object;
              CFNumberRef v97 = v100;
              _IOHIDCFDictionaryApplyBlock((const __CFDictionary *)value, context);
            }
            else if (IOObjectConformsTo(object, "IOHIDDevice") || IOObjectConformsTo(object, "IOHIDEventService"))
            {
              IOServiceMatchPropertyTable(object, v20, (BOOLean_t *)(*(void *)&v100[8] + 24));
            }
            else
            {
              uint64_t v27 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              if (!v27)
              {
                _Block_object_dispose(v100, 8);
LABEL_77:
                CFRelease(v12);
LABEL_78:
                BOOL v51 = 0;
                goto LABEL_79;
              }
              CFTypeID v28 = v27;
              CFDictionarySetValue(v27, @"IOPropertyMatch", v20);
              IOServiceMatchPropertyTable(object, v28, (BOOLean_t *)(*(void *)&v100[8] + 24));
              CFRelease(v28);
            }
            if (*(_DWORD *)(*(void *)&v100[8] + 24))
            {
              uint64_t v24 = (const __CFNumber *)CFDictionaryGetValue(v18, @"ProbeScore");
              if (v24)
              {
                int v25 = v24;
                CFDictionaryRef v26 = CFGetTypeID(v20);
                if (v26 != CFNumberGetTypeID()) {
                  CFNumberGetValue(v25, kCFNumberSInt32Type, &valuePtr);
                }
              }
              if (valuePtr <= v87)
              {
                if (valuePtr == v87) {
                  CFArrayAppendValue(v12, ValueAtIndex);
                }
              }
              else
              {
                CFArrayRemoveAllValues(v12);
                CFArrayAppendValue(v12, ValueAtIndex);
                uint64_t v87 = valuePtr;
              }
            }
          }
          else
          {
            int v23 = _IOHIDLogCategory(0);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)&uint8_t buf[4] = v18;
              _os_log_error_impl(&dword_18B46C000, v23, OS_LOG_TYPE_ERROR, "__IOHIDServiceLoadObjcServicePlugin plugin did not provide passive matching dictionary %@", buf, 0xCu);
            }
          }
        }
        _Block_object_dispose(v100, 8);
        ++v15;
      }
      while (v15 < CFArrayGetCount(v14));
    }
    if (CFArrayGetCount(v12) < 1) {
      goto LABEL_77;
    }
    uint64_t v29 = 0;
    __int16 v30 = 0;
    int v88 = -1;
    do
    {
      *(void *)long long buf = 0;
      uint64_t v31 = (__CFBundle *)CFArrayGetValueAtIndex(v12, v29);
      uint64_t v32 = CFBundleGetInfoDictionary(v31);
      if (v32)
      {
        int v33 = v32;
        double v34 = CFDictionaryGetValue(v32, @"NSPrincipalClass");
        if (v34)
        {
          int v35 = v34;
          double v36 = CFGetTypeID(v34);
          if (v36 == CFStringGetTypeID())
          {
            uint64_t v37 = CFStringCreateWithFormat(allocator, 0, @"OBJC_CLASS_$_%@", v35);
            if (v37)
            {
              unsigned int v38 = v37;
              DataPointerForName = CFBundleGetDataPointerForName(v31, v37);
              if (DataPointerForName)
              {
                double v40 = DataPointerForName;
                CFRelease(v38);
                if (objc_msgSend(v40, sel_getUid("matchService:options:score:"), object, 0, buf))
                {
                  int v41 = *(void *)buf;
                  if (*(uint64_t *)buf > v88)
                  {
                    *(void *)(Private + 488) = v35;
                    int v88 = v41;
                    __int16 v30 = v40;
                  }
                }
              }
              else
              {
                double v42 = _IOHIDLogCategory(0);
                if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)CFNumberRef v100 = 138412546;
                  *(void *)&v100[4] = v38;
                  *(_WORD *)&v100[12] = 2112;
                  *(void *)&v100[14] = v33;
                  _os_log_error_impl(&dword_18B46C000, v42, OS_LOG_TYPE_ERROR, "__IOHIDServiceLoadObjcServicePlugin failed to find symbol %@ for bundle %@", v100, 0x16u);
                }
                CFRelease(v38);
              }
            }
          }
        }
      }
      ++v29;
    }
    while (v29 < CFArrayGetCount(v12));
    CFRelease(v12);
    if (v30)
    {
      int v43 = *(unsigned int *)(Private + 16);
      double v44 = objc_msgSend(v30, sel_getUid("alloc"));
      if (v44)
      {
        CFSetCallBacks v45 = v44;
        if (objc_msgSend(v44, sel_getUid("initWithService:"), v43))
        {
          Protocol = objc_getProtocol("HIDServicePlugin");
          if (Protocol)
          {
            if (class_conformsToProtocol((Class)v30, Protocol))
            {
              *(void *)(Private + 48(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v45;
              *(void *)(Private + 496) = sel_getUid("propertyForKey:client:");
              *(void *)(Private + 504) = sel_getUid("setProperty:forKey:client:");
              *(void *)(Private + 512) = sel_getUid("eventMatching:forClient:");
              *(void *)(Private + 52(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = sel_getUid("setEventDispatcher:");
              *(void *)(Private + 528) = sel_getUid("setCancelHandler:");
              *(void *)(Private + 536) = sel_getUid("activate");
              *(void *)(Private + 544) = sel_getUid("cancel");
              Uid = sel_getUid("setDispatchQueue:");
              if (class_respondsToSelector((Class)v30, Uid)) {
                *(void *)(Private + 552) = sel_getUid("setDispatchQueue:");
              }
              unint64_t v48 = sel_getUid("clientNotification:added:");
              if (class_respondsToSelector((Class)v30, v48)) {
                *(void *)(Private + 56(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = sel_getUid("clientNotification:added:");
              }
              uint64_t v49 = sel_getUid("copyEvent:matching:options:");
              if (class_respondsToSelector((Class)v30, v49)) {
                *(void *)(Private + 568) = sel_getUid("copyEvent:matching:options:");
              }
              double v50 = sel_getUid("setOutputEvent:");
              if (class_respondsToSelector((Class)v30, v50)) {
                *(void *)(Private + 576) = sel_getUid("setOutputEvent:");
              }
              BOOL v51 = 1;
              goto LABEL_80;
            }
            BOOL v77 = _IOHIDLogCategory(0);
            if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
              _IOHIDServiceCreate_cold_3(v77, v78, v79, v80, v81, v82, v83, v84);
            }
          }
          else
          {
            BOOL v69 = _IOHIDLogCategory(0);
            if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
              _IOHIDServiceCreate_cold_2(v69, v70, v71, v72, v73, v74, v75, v76);
            }
          }
          CFRelease(v45);
        }
        else
        {
          uint64_t v61 = _IOHIDLogCategory(0);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
            _IOHIDServiceCreate_cold_1(v61, v62, v63, v64, v65, v66, v67, v68);
          }
        }
      }
    }
    BOOL v51 = 0;
    goto LABEL_80;
  }
  long long v52 = *(void *)(Private + 40);
  uint64_t v53 = *(unsigned int (**)(uint64_t, void, void, uint64_t))(*(void *)v52 + 8);
  uint64_t v54 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
  uint64_t v55 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CFB0], 0x6Fu, 0xE2u, 0x2Au, 0xBFu, 0x68u, 0xB9u, 0x11u, 0xDBu, 0xA7u, 0x1Fu, 0, 0x16u, 0xCBu, 0xC1u, 0x10u, 0xF7u);
  CFUUIDRef v56 = CFUUIDGetUUIDBytes(v55);
  if (!v53(v52, *(void *)&v56.byte0, *(void *)&v56.byte8, Private + 32)) {
    goto LABEL_78;
  }
  *(void *)(Private + 32) = 0;
  CFAllocatorRef v57 = *(void *)(Private + 40);
  CFTypeRef v58 = *(unsigned int (**)(uint64_t, void, void, uint64_t))(*(void *)v57 + 8);
  IOReturn v59 = CFUUIDGetConstantUUIDWithBytes(v54, 0xD1u, 0x2Cu, 0x83u, 0x3Fu, 0xB1u, 0x5Bu, 0x11u, 0xDAu, 0x90u, 0x2Du, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  CFArrayRef v60 = CFUUIDGetUUIDBytes(v59);
  if (!v58(v57, *(void *)&v60.byte0, *(void *)&v60.byte8, Private + 24)) {
    goto LABEL_78;
  }
  BOOL v51 = 0;
  *(void *)(Private + 24) = 0;
LABEL_79:
  LODWORD(v88) = -1;
LABEL_80:
  if (*(void *)(Private + 32)) {
    goto LABEL_90;
  }
  if (*(void *)(Private + 24)) {
    BOOL v51 = 1;
  }
  if (v51)
  {
LABEL_90:
    if (__IOHIDServiceInit(Private, entryID))
    {
      _IOHIDDebugTrace(8257, 2, Private, entryID, 0, 0);
      return Private;
    }
  }
  else
  {
    CFArrayRef v85 = _IOHIDLogCategory(0);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CFRunLoopSourceContext context = 134218752;
      *(void *)&context[4] = entryID;
      *(_WORD *)&context[12] = 1024;
      *(_DWORD *)&context[14] = v86;
      *(_WORD *)&context[18] = 1024;
      *(_DWORD *)&context[20] = theScore;
      LOWORD(v96) = 1024;
      *(_DWORD *)((char *)&v96 + 2) = v88;
      _os_log_error_impl(&dword_18B46C000, v85, OS_LOG_TYPE_ERROR, "0x%llx _IOHIDServiceCreate failed to load service plugin ret: 0x%x score: %d objcScore: %d", context, 0x1Eu);
    }
  }
LABEL_7:
  CFRelease((CFTypeRef)Private);
  _IOHIDDebugTrace(8257, 2, entryID, 0, 0, 0);
  return 0;
}

uint64_t __IOHIDServiceRunLoopCompatibilityThread()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(&context, 0, sizeof(context));
  sched_param v8 = 0;
  int v7 = 0;
  pthread_setname_np("IOHIDService - RunLoopCompatibilityThread");
  CFStringRef v0 = pthread_self();
  if (!pthread_getschedparam(v0, &v7, &v8))
  {
    unint64_t v1 = _IOHIDLog();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109376;
      int sched_priority = v8.sched_priority;
      __int16 v12 = 1024;
      int v13 = v7;
      _os_log_impl(&dword_18B46C000, v1, OS_LOG_TYPE_DEFAULT, "IOHIDService compatibility thread running at priority %d and schedule %d.", buf, 0xEu);
    }
  }
  CFRunLoopSourceRef v2 = CFRunLoopSourceCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &context);
  if (v2)
  {
    CFTypeID v3 = v2;
    double Current = CFRunLoopGetCurrent();
    CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1D418];
    qword_1E9133700 = (uint64_t)Current;
    *(void *)algn_1E9133708 = v5;
    CFRunLoopAddSource(Current, v3, v5);
    pthread_mutex_lock(&stru_1E9133710);
    pthread_cond_signal(&stru_1E9133750);
    pthread_mutex_unlock(&stru_1E9133710);
    CFRunLoopRun();
    CFRunLoopRemoveSource((CFRunLoopRef)qword_1E9133700, v3, *(CFRunLoopMode *)algn_1E9133708);
    CFRelease(v3);
  }
  return 0;
}

CFMutableDictionaryRef _IOHIDServiceCopyPropertiesForClient(uint64_t a1, const __CFArray *a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef v7 = Mutable;
  if (Mutable)
  {
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    void v9[2] = ___IOHIDServiceCopyPropertiesForClient_block_invoke;
    v9[3] = &__block_descriptor_tmp_64;
    v9[4] = a1;
    void v9[5] = a3;
    v9[6] = Mutable;
    _IOHIDCFArrayApplyBlock(a2, v9);
    if (!CFDictionaryGetCount(v7))
    {
      CFRelease(v7);
      return 0;
    }
  }
  return v7;
}

__CFArray *_IOHIDServiceCopyFilterDebugInfoForClient(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v16, v17);
  }
  ++**(_DWORD **)(a1 + 72);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 256));
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      CFIndex v8 = 0;
      CFStringRef v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      uint64_t v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      while (1)
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), v8);
        __int16 v12 = IOHIDServiceFilterCopyPropertyForClient((uint64_t)ValueAtIndex, @"ServiceFilterDebug", a2);
        if (v12) {
          goto LABEL_8;
        }
        int v13 = CFDictionaryCreateMutable(v4, 0, v9, v10);
        if (v13) {
          break;
        }
LABEL_9:
        if (v7 == ++v8) {
          goto LABEL_10;
        }
      }
      __int16 v12 = v13;
      CFDictionaryAddValue(v13, @"Class", @"Unknown");
LABEL_8:
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      goto LABEL_9;
    }
  }
LABEL_10:
  uint64_t v14 = *(void *)(a1 + 72);
  if (*(_DWORD *)v14)
  {
    --*(_DWORD *)v14;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v16, v17);
    }
  }
  return Mutable;
}

uint64_t IOHIDServiceCopyMatchingEvent(uint64_t a1, CFDictionaryRef theDict, const void *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unsigned int valuePtr = 0;
  uint64_t v31 = 0;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x2000000000;
  uint64_t v34 = 0;
  if (!theDict || (uint64_t v6 = *(void *)(a1 + 32)) == 0 || !*(void *)(*(void *)v6 + 88))
  {
LABEL_9:
    int v14 = 0;
    CFNumberRef v8 = 0;
    goto LABEL_10;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"EventType");
  CFNumberRef v8 = Value;
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFNumberGetTypeID())
    {
      uint64_t v10 = CFDictionaryGetValue(theDict, @"MatchingEvent");
      if (v10)
      {
        mach_vm_size_t v11 = v10;
        CFTypeID v12 = CFGetTypeID(v10);
        if (v12 == CFDataGetTypeID())
        {
          CFNumberGetValue(v8, kCFNumberSInt32Type, &valuePtr);
          CFAllocatorRef v13 = CFGetAllocator(a3);
          CFNumberRef v8 = (const __CFNumber *)IOHIDEventCreateWithDataInternal(v13, v11);
          int v14 = 1;
          goto LABEL_10;
        }
      }
    }
    goto LABEL_9;
  }
  int v14 = 0;
LABEL_10:
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v30, v36);
  }
  ++**(_DWORD **)(a1 + 72);
  if (v14)
  {
    uint64_t v15 = (*(uint64_t (**)(void, void, const __CFNumber *, void))(**(void **)(a1 + 32) + 88))(*(void *)(a1 + 32), valuePtr, v8, 0);
LABEL_13:
    uint64_t v16 = (const void *)v15;
    goto LABEL_21;
  }
  CFIndex v17 = *(void **)(a1 + 480);
  if (!v17)
  {
    uint64_t v19 = *(void *)(a1 + 360);
    if (!v19 || (uint64_t v20 = *(uint64_t (**)(void, void, CFDictionaryRef))(v19 + 80)) == 0)
    {
      uint64_t v16 = 0;
      goto LABEL_21;
    }
    uint64_t v15 = v20(*(void *)(a1 + 344), *(void *)(a1 + 352), theDict);
    goto LABEL_13;
  }
  id v18 = objc_msgSend(v17, *(SEL *)(a1 + 512), theDict, a3);
  uint64_t v16 = v18;
  if (v18) {
    CFRetain(v18);
  }
LABEL_21:
  uint64_t v21 = *(void *)(a1 + 72);
  if (*(_DWORD *)v21)
  {
    --*(_DWORD *)v21;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v21 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v30, v36);
    }
  }
  if (v16)
  {
    v32[3] = (uint64_t)v16;
    if (!IOHIDEventGetSenderID((uint64_t)v16))
    {
      CFNumberRef v22 = *(const __CFNumber **)(a1 + 48);
      *(void *)&v36[0] = 0;
      if (v22)
      {
        CFNumberGetValue(v22, kCFNumberSInt64Type, v36);
        uint64_t v23 = *(void *)&v36[0];
      }
      else
      {
        uint64_t v23 = 0;
      }
      IOHIDEventSetSenderID((uint64_t)v16, v23);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v30, v36);
    }
    ++**(_DWORD **)(a1 + 72);
    CFArrayRef v24 = *(const __CFArray **)(a1 + 248);
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 0x40000000;
    v28[2] = __IOHIDServiceCopyMatchingEvent_block_invoke;
    v28[3] = &unk_1E548A458;
    char v29 = v14;
    v28[4] = &v31;
    void v28[5] = v16;
    v28[6] = a3;
    v28[7] = theDict;
    _IOHIDCFArrayApplyBlock(v24, v28);
    uint64_t v25 = *(void *)(a1 + 72);
    if (*(_DWORD *)v25)
    {
      --*(_DWORD *)v25;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v25 + 8))) {
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v30, v36);
      }
    }
    if (!v32[3]) {
      CFRelease(v16);
    }
  }
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v26 = v32[3];
  _Block_object_dispose(&v31, 8);
  return v26;
}

uint64_t __IOHIDServiceCopyMatchingEvent_block_invoke(uint64_t a1, void *a2)
{
  CFAllocatorRef v4 = *(void **)(a1 + 40);
  if (*(unsigned char *)(a1 + 64)) {
    uint64_t result = IOHIDServiceFilterFilterCopyEvent(a2, v4);
  }
  else {
    uint64_t result = (uint64_t)IOHIDServiceFilterFilterCopyMatchingEvent((uint64_t)a2, v4, *(void *)(a1 + 56), *(void *)(a1 + 48));
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __IOHIDServiceCopyEventForClient_block_invoke(uint64_t a1, void *a2)
{
  uint64_t result = IOHIDServiceFilterFilterCopyEvent(a2, *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t IOHIDServiceSetOutputEvent(void *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v15, v16);
  }
  ++*(_DWORD *)a1[9];
  CFArrayRef v4 = (const __CFArray *)a1[32];
  v18.CFIndex length = CFArrayGetCount(v4);
  v18.location = 0;
  CFArrayApplyFunction(v4, v18, (CFArrayApplierFunction)__FilterFunctionSetOutputEvent, a2);
  uint64_t v5 = a1[4];
  if (v5)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)v5 + 96);
    if (v6)
    {
      id v7 = (id)v6();
LABEL_11:
      uint64_t v10 = (uint64_t)v7;
      goto LABEL_12;
    }
  }
  uint64_t v8 = a1[45];
  if (v8)
  {
    CFTypeID v9 = *(uint64_t (**)(void, void, void *))(v8 + 72);
    if (v9)
    {
      id v7 = (id)v9(a1[43], a1[44], a2);
      goto LABEL_11;
    }
  }
  uint64_t v10 = 3758097095;
  mach_vm_size_t v11 = (void *)a1[60];
  if (v11)
  {
    CFTypeID v12 = (const char *)a1[72];
    if (v12)
    {
      id v7 = objc_msgSend(v11, v12, a2);
      goto LABEL_11;
    }
  }
LABEL_12:
  uint64_t v13 = a1[9];
  if (*(_DWORD *)v13)
  {
    --*(_DWORD *)v13;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v15, v16);
    }
  }
  return v10;
}

uint64_t IOHIDServiceSetElementValue(uint64_t a1, int a2, char a3, int a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 3758097095;
  uint64_t v9 = mach_absolute_time();
  if (a2 == 8)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v22, buf);
    }
    ++**(_DWORD **)(a1 + 72);
    int v10 = 1 << (a3 - 1);
    if (a4) {
      int v11 = *(_DWORD *)(a1 + 152) | v10;
    }
    else {
      int v11 = *(_DWORD *)(a1 + 152) & ~v10;
    }
    *(_DWORD *)(a1 + 152) = v11;
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v13 = mach_absolute_time();
    LEDEvent = (void *)IOHIDEventCreateLEDEvent((uint64_t)v12, v13, *(_DWORD *)(a1 + 152), a3, a4, 0);
    uint64_t v15 = *(void *)(a1 + 72);
    if (*(_DWORD *)v15)
    {
      --*(_DWORD *)v15;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8))) {
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v22, buf);
      }
    }
    if (LEDEvent)
    {
      uint64_t v8 = IOHIDServiceSetOutputEvent((void *)a1, LEDEvent);
      CFRelease(LEDEvent);
    }
  }
  uint64_t v16 = mach_absolute_time();
  unint64_t v17 = _IOHIDGetTimestampDelta(v16, v9, 1u);
  if (v17 > *(void *)(a1 + 392))
  {
    unint64_t v18 = v17;
    *(void *)(a1 + 392) = v17;
    if (v17 >= 0x2FAF081)
    {
      uint64_t v19 = _IOHIDLogCategory(6u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        uint64_t v20 = *(void *)(a1 + 400);
        *(_DWORD *)long long buf = 134218240;
        uint64_t v24 = v20;
        __int16 v25 = 2048;
        unint64_t v26 = v18;
        _os_log_impl(&dword_18B46C000, v19, OS_LOG_TYPE_INFO, "0x%llx: IOHIDServiceSetElementValue time:%lluns", buf, 0x16u);
      }
    }
  }
  return v8;
}

uint64_t __IOHIDServiceEventCompatibilityCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    if (a4) {
      return __IOHIDServiceEventCallback(a1, a2, a3, a4);
    }
  }
  return a1;
}

void __IOHIDServiceCreateRemovalNotification_block_invoke(uint64_t a1)
{
  __IOHIDServiceNotificationSetApplier(*(const void ***)(a1 + 32), *(void *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 32));
  CFRunLoopSourceRef v2 = *(const void **)(a1 + 40);

  CFRelease(v2);
}

void *IOHIDServiceCreatePropertyChangedNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 224)) {
    return 0;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v12, v13);
  }
  ++**(_DWORD **)(a1 + 72);
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDServiceNotificationRelease, a1, 0, a2, a3, a4);
  if (v9) {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 112), v9);
  }
  uint64_t v10 = *(void *)(a1 + 72);
  if (*(_DWORD *)v10)
  {
    --*(_DWORD *)v10;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v12, v13);
    }
  }
  return v9;
}

void __IOHIDServiceCompleteEventsInProgressApplier(const __CFNumber *a1, const void *a2)
{
  uint64_t valuePtr = 0;
  CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
  __int16 v4 = valuePtr;
  __int16 v3 = WORD2(valuePtr);
  CFAllocatorRef v5 = CFGetAllocator(a2);
  uint64_t v6 = mach_absolute_time();
  KeyboardEvent = (void *)IOHIDEventCreateKeyboardEvent((uint64_t)v5, v6, v3, v4, 0, 0x800000);
  if (KeyboardEvent)
  {
    uint64_t v10 = KeyboardEvent;
    __IOHIDServiceEventCallback((uint64_t)a2, v8, v9, KeyboardEvent);
    CFRelease(v10);
  }
}

void __IOHIDServiceHandleCancelTimerTimeout(uint64_t a1)
{
  CFRunLoopSourceRef v2 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
    __IOHIDServiceHandleCancelTimerTimeout_cold_2(a1, v2);
  }
  if (*(unsigned char *)(a1 + 440))
  {
    CFStringRef v3 = CFCopyDescription(*(CFTypeRef *)(a1 + 480));
    __int16 v4 = _IOHIDLogCategory(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      if (!v3) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
    __IOHIDServiceHandleCancelTimerTimeout_cold_1();
    if (v3) {
LABEL_6:
    }
      CFRelease(v3);
  }
LABEL_7:
  if (*(_DWORD *)(a1 + 444))
  {
    CFArrayRef v5 = *(const __CFArray **)(a1 + 256);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    void v6[2] = ____IOHIDServiceHandleCancelTimerTimeout_block_invoke;
    v6[3] = &__block_descriptor_tmp_88_0;
    v6[4] = a1;
    _IOHIDCFArrayApplyBlock(v5, v6);
  }
}

uint64_t IOHIDServiceGetService(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

__CFDictionary *_IOHIDServiceCopyServiceRecordForClient(_DWORD *a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == IOHIDEventSystemConnectionGetTypeID()
      && !IOHIDServiceCheckEntitlements((uint64_t)a1, (uint64_t)cf))
    {
      return 0;
    }
  }
  CFArrayRef v5 = _IOHIDServiceCopyServiceInfoForClient(a1, cf);
  if (v5)
  {
    uint64_t v6 = _IOHIDServiceCopyFilterDebugInfoForClient((uint64_t)a1, (uint64_t)cf);
    if (v6)
    {
      id v7 = v6;
      CFDictionaryAddValue(v5, @"ServiceFilterDebug", v6);
      CFRelease(v7);
    }
    CFMutableArrayRef v8 = _IOHIDServiceCopyEventLog(a1);
    if (v8)
    {
      CFMutableArrayRef v9 = v8;
      CFDictionaryAddValue(v5, @"EventLog", v8);
      CFRelease(v9);
    }
    CFMutableDictionaryRef v10 = _IOHIDServiceCopyEventCounts(a1);
    if (v10)
    {
      CFMutableDictionaryRef v11 = v10;
      CFDictionaryAddValue(v5, @"EventTypeCounts", v10);
      CFRelease(v11);
    }
    CFMutableDictionaryRef v12 = _IOHIDServiceCopyConnectionIntervals((uint64_t)a1);
    if (v12)
    {
      CFMutableDictionaryRef v13 = v12;
      CFDictionaryAddValue(v5, @"PropertyCache", v12);
      CFRelease(v13);
    }
    _IOHIDServiceSetMiscDebugDebugInfo((uint64_t)a1, v5, (uint64_t)cf);
  }
  return v5;
}

__CFDictionary *_IOHIDServiceCopyServiceInfoForClient(_DWORD *cf, const void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  memset(name, 0, 128);
  uint64_t valuePtr = 0;
  io_registry_entry_t v4 = cf[4];
  if (v4 && IOObjectRetain(cf[4])) {
    io_registry_entry_t v4 = 0;
  }
  CFAllocatorRef v5 = CFGetAllocator(cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    if (v4)
    {
      IORegistryEntryGetName(v4, name);
      if (!name[0]) {
        IOObjectGetClass(v4, name);
      }
      CFAllocatorRef v7 = CFGetAllocator(cf);
      CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
      CFStringRef v9 = CFStringCreateWithCString(v7, name, SystemEncoding);
      if (v9)
      {
        CFStringRef v10 = v9;
        CFDictionarySetValue(Mutable, @"IOClass", v9);
        CFRelease(v10);
      }
    }
    CFMutableDictionaryRef v11 = (const void *)*((void *)cf + 6);
    if (v11) {
      CFDictionarySetValue(Mutable, @"IORegistryEntryID", v11);
    }
    CFMutableDictionaryRef v12 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFMutableDictionaryRef v13 = (const void *)*MEMORY[0x1E4F1CFC8];
    if (cf[71]) {
      uint64_t v14 = (const void *)*MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v14 = (const void *)*MEMORY[0x1E4F1CFC8];
    }
    CFDictionarySetValue(Mutable, @"Built-In", v14);
    if (cf[76]) {
      uint64_t v15 = v12;
    }
    else {
      uint64_t v15 = v13;
    }
    CFDictionarySetValue(Mutable, @"ProtectedAccess", v15);
    for (uint64_t i = 0; i != 8; ++i)
    {
      unint64_t v17 = __debugKeys_0[i];
      unint64_t v18 = (const void *)_IOHIDServiceCopyPropertyForClient((uint64_t)cf, v17, a2);
      if (v18)
      {
        uint64_t v19 = v18;
        CFDictionarySetValue(Mutable, v17, v18);
        CFRelease(v19);
      }
    }
    uint64_t EventDeadlineForClient = _IOHIDServiceGetEventDeadlineForClient((uint64_t)cf, a2, 0);
    uint64_t valuePtr = EventDeadlineForClient;
    if (EventDeadlineForClient)
    {
      unint64_t v21 = EventDeadlineForClient;
      uint64_t v22 = mach_absolute_time();
      unint64_t v23 = v21 - v22;
      if (v21 < v22) {
        unint64_t v23 = 0;
      }
      if (v21 > v22) {
        v23 /= 0x3E8uLL;
      }
      uint64_t valuePtr = v23;
      CFAllocatorRef v24 = CFGetAllocator(cf);
      CFNumberRef v25 = CFNumberCreate(v24, kCFNumberSInt64Type, &valuePtr);
      if (v25)
      {
        CFNumberRef v26 = v25;
        CFDictionarySetValue(Mutable, @"NextEventTimeStampDelta", v25);
        CFRelease(v26);
      }
    }
    uint64_t v27 = (const void *)*((void *)cf + 8);
    if (v27) {
      CFDictionarySetValue(Mutable, @"ServiceEntitlements", v27);
    }
  }
  if (v4) {
    IOObjectRelease(v4);
  }
  return Mutable;
}

CFMutableArrayRef _IOHIDServiceCopyEventLog(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (!a1[51]) {
    return 0;
  }
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v2, 50, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(a1[9] + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v8, v9);
    }
    ++*(_DWORD *)a1[9];
    CFDataRef v4 = (const __CFData *)a1[51];
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    void v7[2] = ___IOHIDServiceCopyEventLog_block_invoke;
    v7[3] = &__block_descriptor_tmp_164;
    void v7[4] = a1;
    _IOHIDSimpleQueueApplyBlock(v4, (uint64_t)v7, (uint64_t)Mutable);
    uint64_t v5 = a1[9];
    if (*(_DWORD *)v5)
    {
      --*(_DWORD *)v5;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8))) {
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v8, v9);
      }
    }
  }
  return Mutable;
}

CFMutableDictionaryRef _IOHIDServiceCopyConnectionIntervals(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v5, v6);
    }
    ++**(_DWORD **)(a1 + 72);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 240), (CFDictionaryApplierFunction)__CopyConnectionCache, Mutable);
    uint64_t v3 = *(void *)(a1 + 72);
    if (*(_DWORD *)v3)
    {
      --*(_DWORD *)v3;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8))) {
        __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v5, v6);
      }
    }
    if (!CFDictionaryGetCount(Mutable))
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

void _IOHIDServiceSetMiscDebugDebugInfo(uint64_t a1, void *a2, uint64_t a3)
{
  _IOHIDDictionaryAddSInt64(a2, @"MaxPropertyGetTime", *(void *)(a1 + 376));
  _IOHIDDictionaryAddSInt64(a2, @"MaxPropertyGetTime", *(void *)(a1 + 384));
  _IOHIDDictionaryAddSInt32(a2, @"propertyCacheHit", *(_DWORD *)(a1 + 320));
  _IOHIDDictionaryAddSInt32(a2, @"propertyCacheMiss", *(_DWORD *)(a1 + 324));
  _IOHIDDictionaryAddSInt32(a2, @"elementSetTime", *(_DWORD *)(a1 + 392));
  uint64_t v6 = (const void *)_IOHIDServiceCopyProperyFromPlugin(a1, @"ServicePluginDebug", a3);
  if (v6)
  {
    uint64_t v7 = v6;
    CFDictionarySetValue((CFMutableDictionaryRef)a2, @"ServicePluginDebug", v6);
    CFRelease(v7);
  }
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFMutableArrayRef v10 = Mutable;
    CFSetRef v11 = (const __CFSet *)_IOHIDServiceCopyConnections(a1, 0);
    if (v11)
    {
      CFSetRef v12 = v11;
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 0x40000000;
      void context[2] = ___IOHIDServiceSetMiscDebugDebugInfo_block_invoke;
      void context[3] = &__block_descriptor_tmp_184;
      context[4] = v10;
      _IOHIDCFSetApplyBlock(v11, context);
      CFRelease(v12);
    }
    CFSetRef v13 = (const __CFSet *)_IOHIDServiceCopyConnections(a1, 2);
    if (v13)
    {
      CFSetRef v14 = v13;
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 0x40000000;
      v24[2] = ___IOHIDServiceSetMiscDebugDebugInfo_block_invoke_2;
      v24[3] = &__block_descriptor_tmp_185;
      v24[4] = v10;
      _IOHIDCFSetApplyBlock(v13, v24);
      CFRelease(v14);
    }
    CFDictionarySetValue((CFMutableDictionaryRef)a2, @"Connections", v10);
    CFRelease(v10);
  }
  CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef v16 = CFArrayCreateMutable(v15, 0, MEMORY[0x1E4F1D510]);
  if (v16)
  {
    unint64_t v17 = v16;
    CFArrayRef v18 = (const __CFArray *)_IOHIDServiceCopyConnections(a1, 1);
    if (v18)
    {
      CFArrayRef v19 = v18;
      if (CFArrayGetCount(v18) >= 1)
      {
        CFIndex v20 = 0;
        do
        {
          CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v19, v20);
          uint64_t UUID = IOHIDEventSystemConnectionGetUUID((uint64_t)ValueAtIndex);
          if (UUID) {
            unint64_t v23 = (__CFString *)UUID;
          }
          else {
            unint64_t v23 = @"unknown";
          }
          CFArrayAppendValue(v17, v23);
          ++v20;
        }
        while (v20 < CFArrayGetCount(v19));
      }
      CFRelease(v19);
    }
    CFDictionarySetValue((CFMutableDictionaryRef)a2, @"Filters", v17);
    CFRelease(v17);
  }
}

void __CopyConnectionCache(__CFString *cf, uint64_t a2, __CFDictionary *a3)
{
  uint64_t UUID = cf;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == IOHIDEventSystemConnectionGetTypeID()) {
      uint64_t UUID = (__CFString *)IOHIDEventSystemConnectionGetUUID((uint64_t)UUID);
    }
    else {
      uint64_t UUID = 0;
    }
  }
  uint64_t v7 = IOHIDServiceConnectionCacheCopyDebugInfo(a2);
  if (v7)
  {
    CFAllocatorRef v8 = v7;
    if (UUID) {
      CFStringRef v9 = UUID;
    }
    else {
      CFStringRef v9 = @"0";
    }
    CFDictionarySetValue(a3, v9, v7);
    CFRelease(v8);
  }
}

uint64_t _IOHIDServiceCopyProperyFromPlugin(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 72) + 8))) {
    __IOHIDServiceCreateAndCopyConnectionCache_cold_2(&v18, v19);
  }
  ++**(_DWORD **)(a1 + 72);
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6)
  {
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 48);
    if (v7)
    {
      uint64_t v8 = v7();
LABEL_11:
      uint64_t v14 = v8;
      goto LABEL_17;
    }
  }
  uint64_t v9 = *(void *)(a1 + 24);
  if (v9 && (CFMutableArrayRef v10 = *(uint64_t (**)(void))(*(void *)v9 + 48)) != 0)
  {
    id v11 = (id)v10();
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 360);
    if (v12)
    {
      CFSetRef v13 = *(uint64_t (**)(void, void, uint64_t))(v12 + 24);
      if (v13)
      {
        uint64_t v8 = v13(*(void *)(a1 + 344), *(void *)(a1 + 352), a2);
        goto LABEL_11;
      }
    }
    CFAllocatorRef v15 = *(void **)(a1 + 480);
    if (!v15)
    {
      uint64_t v14 = 0;
      goto LABEL_17;
    }
    id v11 = objc_msgSend(v15, *(SEL *)(a1 + 496), a2, a3);
  }
  uint64_t v14 = (uint64_t)v11;
  if (v11) {
    CFRetain(v11);
  }
LABEL_17:
  uint64_t v16 = *(void *)(a1 + 72);
  if (*(_DWORD *)v16)
  {
    --*(_DWORD *)v16;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8))) {
      __IOHIDServiceCreateAndCopyConnectionCache_cold_1(&v18, v19);
    }
  }
  return v14;
}

void IOHIDServiceRequestTerminate(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = _IOHIDLogCategory(6u);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 400);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v9 = v3;
    _os_log_impl(&dword_18B46C000, v2, OS_LOG_TYPE_DEFAULT, "0x%llx: IOHIDServiceRequestTerminate", buf, 0xCu);
  }
  *(_DWORD *)(a1 + 224) |= 1u;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 456));
  CFAllocatorRef v4 = CFGetAllocator(*(CFTypeRef *)(a1 + 120));
  CFSetRef Copy = CFSetCreateCopy(v4, *(CFSetRef *)(a1 + 120));
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 456));
  if (Copy)
  {
    CFSetApplyFunction(Copy, (CFSetApplierFunction)__IOHIDServiceNotificationSetApplier, (void *)a1);
    CFRelease(Copy);
  }
  CFRetain((CFTypeRef)a1);
  uint64_t v6 = *(NSObject **)(a1 + 80);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IOHIDServiceRequestTerminate_block_invoke;
  block[3] = &__block_descriptor_tmp_192;
  block[4] = a1;
  dispatch_async(v6, block);
  _IOHIDServiceTerminate((void *)a1);
}

void __IOHIDServiceRequestTerminate_block_invoke(uint64_t a1)
{
  _IOHIDServiceSetPropertyForClient(*(void *)(a1 + 32), @"RequestTerminate", (const void *)*MEMORY[0x1E4F1CFD0], (CFTypeRef)*MEMORY[0x1E4F1D260]);
  CFAllocatorRef v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

double OUTLINED_FUNCTION_0_2(void *a1, _OWORD *a2)
{
  *a1 = 0;
  double result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

uint64_t OUTLINED_FUNCTION_3_1()
{
  return _os_crash_msg();
}

BOOL OUTLINED_FUNCTION_4()
{
  return os_log_type_enabled(v0, OS_LOG_TYPE_ERROR);
}

void OUTLINED_FUNCTION_6(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_8(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

uint64_t IOHIDSessionCreate(const __CFAllocator *a1)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  v72.__sig = 0;
  *(void *)v72.__opaque = 0;
  uint64_t Private = _IOHIDSessionCreatePrivate((uint64_t)a1);
  uint64_t v3 = _IOHIDLog();
  os_signpost_id_t v4 = os_signpost_id_make_with_pointer(v3, (const void *)Private);
  uint64_t v5 = _IOHIDLog();
  unint64_t v6 = v4 - 1;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v7 = v5;
    if (os_signpost_enabled(v5))
    {
      LOWORD(buf.version) = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v7, OS_SIGNPOST_INTERVAL_BEGIN, v4, "IOHIDSessionCreate", (const char *)&unk_18B51B6F3, (uint8_t *)&buf, 2u);
    }
  }
  if (!Private) {
    goto LABEL_68;
  }
  uint64_t v8 = malloc_type_calloc(1uLL, 0x48uLL, 0x10000400131AABDuLL);
  *(void *)(Private + 32) = v8;
  if (!v8) {
    goto LABEL_68;
  }
  if (pthread_mutexattr_init(&v72)) {
    __IOHIDServiceInit_cold_4(v67, &buf);
  }
  pthread_mutexattr_settype(&v72, 2);
  if (pthread_mutex_init((pthread_mutex_t *)(*(void *)(Private + 32) + 8), &v72)) {
    IOHIDSessionCreate_cold_3(v67, &buf);
  }
  if (pthread_cond_init((pthread_cond_t *)(Private + 40), 0)) {
    IOHIDSessionCreate_cold_2(v67, &buf);
  }
  if (pthread_mutexattr_destroy(&v72)) {
    IOHIDSessionCreate_cold_1(v67, &buf);
  }
  uint64_t v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v10 = hid_dispatch_queue_create_with_context_destructor("IOHIDSession - SessionEventDispatch", v9, kIOHIDServiceInterruptWorkloop, (uint64_t)__IOHIDSessionQueueWillExecute, (uint64_t)__IOHIDSessionQueueDidExecute, *(void *)(Private + 32), __IOHIDSessionQueueContextDestructor);
  *(void *)(Private + 96) = v10;
  if (!v10) {
    goto LABEL_68;
  }
  id v11 = dispatch_source_create(MEMORY[0x1E4F14438], 0, 0, v10);
  *(void *)(Private + 104) = v11;
  if (!v11) {
    goto LABEL_68;
  }
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 0x40000000;
  handler[2] = __IOHIDSessionCreate_block_invoke;
  handler[3] = &__block_descriptor_tmp_15;
  handler[4] = Private;
  dispatch_source_set_event_handler(v11, handler);
  dispatch_resume(*(dispatch_object_t *)(Private + 104));
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  *(void *)(Private + 112) = Mutable;
  if (!Mutable) {
    goto LABEL_68;
  }
  CFMutableArrayRef v13 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  *(void *)(Private + 144) = v13;
  if (!v13) {
    goto LABEL_68;
  }
  CFMutableArrayRef v14 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  *(void *)(Private + 152) = v14;
  if (!v14) {
    goto LABEL_68;
  }
  CFMutableArrayRef v15 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  *(void *)(Private + 16(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v15;
  if (!v15) {
    goto LABEL_68;
  }
  CFMutableDictionaryRef v16 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(Private + 12(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v16;
  if (!v16) {
    goto LABEL_68;
  }
  CFMutableSetRef v17 = CFSetCreateMutable(a1, 0, MEMORY[0x1E4F1D548]);
  *(void *)(Private + 136) = v17;
  if (!v17) {
    goto LABEL_68;
  }
  *(_DWORD *)(Private + 128) = 6;
  CFNumberRef v18 = CFNumberCreate(a1, kCFNumberIntType, (const void *)(Private + 128));
  if (v18)
  {
    CFNumberRef v19 = v18;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(Private + 120), @"LogLevel", v18);
    CFRelease(v19);
  }
  CFSetCallBacks buf = *(CFSetCallBacks *)byte_1ED86F990;
  CFMutableSetRef v20 = CFSetCreateMutable(a1, 2, &buf);
  *(void *)(Private + 192) = v20;
  if (v20)
  {
    os_signpost_id_t spid = v4;
    unint64_t v21 = _IOHIDLog();
    if (os_signpost_enabled(v21))
    {
      *(_WORD *)CFDictionaryRef v67 = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v21, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionCreate - Load bundles", (const char *)&unk_18B51B6F3, v67, 2u);
    }
    CFArrayRef v22 = (const __CFArray *)_IOHIDLoadBundles();
    if (v22)
    {
      CFArrayRef v23 = v22;
      if (CFArrayGetCount(v22) >= 1)
      {
        CFIndex v24 = 0;
        CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
        do
        {
          CFDataRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v23, v24);
          CFPlugInRef PlugIn = CFBundleGetPlugIn(ValueAtIndex);
          if (PlugIn)
          {
            uint64_t v27 = PlugIn;
            CFUUIDRef v28 = CFUUIDGetConstantUUIDWithBytes(alloc, 0x7Fu, 0x1Au, 0x3Au, 0xE6u, 0x3Eu, 0x3Du, 0x47u, 0xAu, 0xBDu, 0x15u, 0xA2u, 0xDDu, 0x7Eu, 0x1Bu, 0xB7u, 0x19u);
            CFArrayRef FactoriesForPlugInTypeInPlugIn = CFPlugInFindFactoriesForPlugInTypeInPlugIn(v28, v27);
            if (FactoriesForPlugInTypeInPlugIn)
            {
              CFArrayRef v30 = FactoriesForPlugInTypeInPlugIn;
              if (CFArrayGetCount(FactoriesForPlugInTypeInPlugIn) >= 1)
              {
                CFIndex v31 = 0;
                do
                {
                  CFUUIDRef v32 = (const __CFUUID *)CFArrayGetValueAtIndex(v30, v31);
                  CFURLRef v33 = (const __CFURL *)IOHIDSessionFilterCreate(a1, ValueAtIndex, v32);
                  if (v33)
                  {
                    CFURLRef v34 = v33;
                    int v35 = _IOHIDLogCategory(0);
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)CFDictionaryRef v67 = 138412290;
                      CFURLRef v68 = v34;
                      _os_log_impl(&dword_18B46C000, v35, OS_LOG_TYPE_DEFAULT, "Add session filter:%@", v67, 0xCu);
                    }
                    CFArrayAppendValue(*(CFMutableArrayRef *)(Private + 144), v34);
                    if (!IOHIDSessionFilterGetType((uint64_t)v34)) {
                      CFArrayAppendValue(*(CFMutableArrayRef *)(Private + 160), v34);
                    }
                    CFRelease(v34);
                  }
                  ++v31;
                }
                while (v31 < CFArrayGetCount(v30));
              }
              CFRelease(v30);
            }
          }
          ++v24;
        }
        while (v24 < CFArrayGetCount(v23));
      }
    }
    CFArrayRef v36 = (const __CFArray *)_IOHIDLoadSessionFilterBundles();
    if (v36)
    {
      CFArrayRef v37 = v36;
      if (CFArrayGetCount(v36) >= 1)
      {
        CFIndex v38 = 0;
        uint64_t v65 = (const void *)*MEMORY[0x1E4F1CFD0];
        do
        {
          uint64_t v39 = (__CFBundle *)CFArrayGetValueAtIndex(v37, v38);
          CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(v39);
          if (InfoDictionary)
          {
            CFDictionaryRef v41 = InfoDictionary;
            CFNumberRef Value = CFDictionaryGetValue(InfoDictionary, @"NSPrincipalClass");
            if (Value)
            {
              int v43 = Value;
              CFTypeID v44 = CFGetTypeID(Value);
              if (v44 == CFStringGetTypeID())
              {
                CFStringRef v45 = CFStringCreateWithFormat(a1, 0, @"OBJC_CLASS_$_%@", v43);
                if (v45)
                {
                  double v46 = v45;
                  DataPointerForName = (objc_class *)CFBundleGetDataPointerForName(v39, v45);
                  if (DataPointerForName)
                  {
                    unint64_t v48 = DataPointerForName;
                    CFRelease(v46);
                    CFURLRef v49 = CFBundleCopyExecutableURL(v39);
                    double v50 = _IOHIDLogCategory(0);
                    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)CFDictionaryRef v67 = 138412290;
                      CFURLRef v68 = v49;
                      _os_log_impl(&dword_18B46C000, v50, OS_LOG_TYPE_DEFAULT, "Loading session filter:%@", v67, 0xCu);
                    }
                    if (v49) {
                      CFRelease(v49);
                    }
                    BOOL v51 = CFDictionaryGetValue(v41, @"LogIOHIDFilteredEvents");
                    if (v51) {
                      BOOL v52 = v51 == v65;
                    }
                    else {
                      BOOL v52 = 1;
                    }
                    char v53 = v52;
                    double v46 = (const void *)IOHIDSessionFilterCreateWithClass(a1, v48, Private, v53);
                    uint64_t v54 = _IOHIDLogCategory(0);
                    uint64_t v55 = v54;
                    if (!v46)
                    {
                      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)CFDictionaryRef v67 = 138412290;
                        CFURLRef v68 = v41;
                        _os_log_error_impl(&dword_18B46C000, v55, OS_LOG_TYPE_ERROR, "IOHIDSessionFilterCreateWithClass failed for bundle %@", v67, 0xCu);
                      }
                      goto LABEL_66;
                    }
                    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)CFDictionaryRef v67 = 138412290;
                      CFURLRef v68 = (CFURLRef)v46;
                      _os_log_impl(&dword_18B46C000, v55, OS_LOG_TYPE_DEFAULT, "Add session filter:%@", v67, 0xCu);
                    }
                    CFArrayAppendValue(*(CFMutableArrayRef *)(Private + 144), v46);
                    CFArrayAppendValue(*(CFMutableArrayRef *)(Private + 152), v46);
                  }
                  else
                  {
                    CFUUIDRef v56 = _IOHIDLogCategory(0);
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)CFDictionaryRef v67 = 138412546;
                      CFURLRef v68 = (CFURLRef)v46;
                      __int16 v69 = 2112;
                      CFDictionaryRef v70 = v41;
                      _os_log_error_impl(&dword_18B46C000, v56, OS_LOG_TYPE_ERROR, "IOHIDSessionCreate failed to find symbol %@ for bundle %@", v67, 0x16u);
                    }
                  }
                  CFRelease(v46);
                }
              }
            }
          }
LABEL_66:
          ++v38;
        }
        while (v38 < CFArrayGetCount(v37));
      }
      CFArrayRef v60 = _IOHIDLog();
      if (os_signpost_enabled(v60))
      {
        *(_WORD *)CFDictionaryRef v67 = 0;
        _os_signpost_emit_with_name_impl(&dword_18B46C000, v60, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionCreate - Load bundles", (const char *)&unk_18B51B6F3, v67, 2u);
      }
      uint64_t v61 = _IOHIDLog();
      if (v6 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        CFArrayRef v62 = v61;
        if (os_signpost_enabled(v61))
        {
          *(_WORD *)CFDictionaryRef v67 = 0;
          _os_signpost_emit_with_name_impl(&dword_18B46C000, v62, OS_SIGNPOST_INTERVAL_END, spid, "IOHIDSessionCreate", (const char *)&unk_18B51B6F3, v67, 2u);
        }
      }
    }
  }
  else
  {
LABEL_68:
    CFAllocatorRef v57 = _IOHIDLog();
    if (v6 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      CFTypeRef v58 = v57;
      if (os_signpost_enabled(v57))
      {
        LOWORD(buf.version) = 0;
        _os_signpost_emit_with_name_impl(&dword_18B46C000, v58, OS_SIGNPOST_INTERVAL_END, v4, "IOHIDSessionCreate", (const char *)&unk_18B51B6F3, (uint8_t *)&buf, 2u);
      }
    }
    if (Private)
    {
      CFRelease((CFTypeRef)Private);
      return 0;
    }
  }
  return Private;
}

uint64_t __IOHIDSessionQueueWillExecute(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (result) {
    __IOHIDServiceQueueWillExecute_cold_1(&v3, v4);
  }
  ++*(_DWORD *)a1;
  return result;
}

uint64_t __IOHIDSessionQueueDidExecute(uint64_t result)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDServiceQueueDidExecute_cold_1(&v1, v2);
    }
  }
  return result;
}

void __IOHIDSessionQueueContextDestructor(uint64_t a1)
{
  if (a1)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
    free((void *)a1);
  }
}

void __IOHIDSessionCreate_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(v1 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(&v11, v12);
    }
    ++**(_DWORD **)(v1 + 32);
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 112));
    if (Count)
    {
      uint64_t v3 = Count;
      CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFArrayRef *)(v1 + 112));
      if (Copy)
      {
        CFArrayRef v5 = Copy;
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v1 + 112));
        uint64_t v6 = *(void *)(v1 + 32);
        if (*(_DWORD *)v6)
        {
          --*(_DWORD *)v6;
          if (pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8))) {
            __IOHIDSessionCreate_block_invoke_cold_1(&v11, v12);
          }
        }
        if (v3 >= 1)
        {
          for (CFIndex i = 0; i != v3; ++i)
          {
            CFDataRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v5, i);
            if (ValueAtIndex) {
              __IOHIDSessionDispatchEvent(v1, ValueAtIndex);
            }
          }
        }
        CFRelease(v5);
      }
      else
      {
        uint64_t v10 = *(void *)(v1 + 32);
        if (*(_DWORD *)v10)
        {
          --*(_DWORD *)v10;
          if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8))) {
            __IOHIDSessionCreate_block_invoke_cold_1(&v11, v12);
          }
        }
      }
    }
    else
    {
      uint64_t v9 = *(void *)(v1 + 32);
      if (*(_DWORD *)v9)
      {
        --*(_DWORD *)v9;
        if (pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8))) {
          __IOHIDSessionCreate_block_invoke_cold_1(&v11, v12);
        }
      }
    }
  }
}

uint64_t _IOHIDSessionReleasePrivate(uint64_t a1)
{
  CFAllocatorRef v2 = _IOHIDLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)CFMutableArrayRef v15 = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionRelease", (const char *)&unk_18B51B6F3, v15, 2u);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    IOHIDSessionClose(a1, v3);
    os_signpost_id_t v4 = *(const void **)(a1 + 8);
    if (v4) {
      CFRelease(v4);
    }
  }
  CFArrayRef v5 = *(const void **)(a1 + 136);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 120);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)(a1 + 160);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(const void **)(a1 + 152);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(const void **)(a1 + 144);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = *(const void **)(a1 + 112);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = *(NSObject **)(a1 + 104);
  if (v11) {
    dispatch_release(v11);
  }
  uint64_t v12 = *(const void **)(a1 + 192);
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v13 = *(NSObject **)(a1 + 96);
  if (v13)
  {
    hid_dispatch_queue_release(v13);
    *(void *)(a1 + 96) = 0;
  }
  return pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
}

void IOHIDSessionClose(uint64_t a1, const void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v4 = _IOHIDLog();
  if (os_signpost_enabled(v4))
  {
    *(_WORD *)CFSetCallBacks buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v4, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionClose", (const char *)&unk_18B51B6F3, buf, 2u);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v18, buf);
  }
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  if (*(const void **)(a1 + 8) == a2)
  {
    CFArrayRef v5 = _IOHIDLog();
    if (os_signpost_enabled(v5))
    {
      *(_WORD *)CFSetCallBacks buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v5, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionFiltersClose", (const char *)&unk_18B51B6F3, buf, 2u);
    }
    CFArrayRef v6 = *(const __CFArray **)(a1 + 152);
    v21.CFIndex length = CFArrayGetCount(v6);
    v21.location = 0;
    CFArrayApplyFunction(v6, v21, (CFArrayApplierFunction)__FilterFunctionClose_0, (void *)a1);
    uint64_t v7 = _IOHIDLog();
    if (os_signpost_enabled(v7))
    {
      *(_WORD *)CFSetCallBacks buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v7, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionFiltersClose", (const char *)&unk_18B51B6F3, buf, 2u);
    }
    uint64_t v8 = _IOHIDLog();
    if (os_signpost_enabled(v8))
    {
      *(_WORD *)CFSetCallBacks buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v8, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnregisterServices", (const char *)&unk_18B51B6F3, buf, 2u);
    }
    CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)__UnregisterServiceFunction, (void *)a1);
    uint64_t v9 = _IOHIDLog();
    if (os_signpost_enabled(v9))
    {
      *(_WORD *)CFSetCallBacks buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v9, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnregisterServices", (const char *)&unk_18B51B6F3, buf, 2u);
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 152));
    uint64_t v10 = _IOHIDLog();
    if (os_signpost_enabled(v10))
    {
      *(_WORD *)CFSetCallBacks buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v10, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnschedule", (const char *)&unk_18B51B6F3, buf, 2u);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(&v18, buf);
    }
    ++**(_DWORD **)(a1 + 32);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 104));
    CFArrayRef v11 = *(const __CFArray **)(a1 + 152);
    v22.CFIndex length = CFArrayGetCount(v11);
    v22.location = 0;
    CFArrayApplyFunction(v11, v22, (CFArrayApplierFunction)__FilterFunctionUnscheduleAsync_0, (void *)a1);
    uint64_t v12 = *(void *)(a1 + 32);
    if (*(_DWORD *)v12)
    {
      --*(_DWORD *)v12;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_1(&v18, buf);
      }
    }
    uint64_t v13 = _IOHIDLog();
    if (os_signpost_enabled(v13))
    {
      *(_WORD *)CFSetCallBacks buf = 0;
      _os_signpost_emit_with_name_impl(&dword_18B46C000, v13, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionUnschedule", (const char *)&unk_18B51B6F3, buf, 2u);
    }
    *(_DWORD *)(a1 + 88) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 8) = 0;
    CFRelease(a2);
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  uint64_t v14 = *(void *)(a1 + 32);
  if (*(_DWORD *)v14)
  {
    --*(_DWORD *)v14;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v18, buf);
    }
  }
  CFRetain((CFTypeRef)a1);
  CFMutableArrayRef v15 = *(NSObject **)(a1 + 96);
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 0x40000000;
  void v17[2] = __IOHIDSessionClose_block_invoke;
  v17[3] = &__block_descriptor_tmp_12;
  v17[4] = a1;
  dispatch_async(v15, v17);
  CFMutableDictionaryRef v16 = _IOHIDLog();
  if (os_signpost_enabled(v16))
  {
    *(_WORD *)CFSetCallBacks buf = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v16, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionClose", (const char *)&unk_18B51B6F3, buf, 2u);
  }
}

void __RegisterServiceWithSessionFunction(void *a1, uint64_t a2)
{
  __RegisterServiceFunction(a1, a2);
  if (_IOHIDServiceGetOwner((uint64_t)a1) != a2)
  {
    CFAllocatorRef v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 136));
    MutableCFArrayRef Copy = CFSetCreateMutableCopy(v4, 0, *(CFSetRef *)(a2 + 136));
    CFRelease(*(CFTypeRef *)(a2 + 136));
    *(void *)(a2 + 136) = MutableCopy;
    CFSetRemoveValue(MutableCopy, a1);
  }
}

uint64_t IOHIDSessionOpen(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = _IOHIDLog();
  if (os_signpost_enabled(v8))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v8, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionOpen", (const char *)&unk_18B51B6F3, (uint8_t *)&buf, 2u);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v18, &buf);
  }
  ++**(_DWORD **)(a1 + 32);
  __IOHIDSessionSetStateBusy(a1, 1);
  if (*(_DWORD *)(a1 + 88))
  {
    uint64_t v9 = 0;
  }
  else
  {
    *(void *)(a1 + 8) = CFRetain(a2);
    *(void *)(a1 + 16) = a3;
    *(void *)(a1 + 24) = a4;
    uint64_t v10 = *(void *)(a1 + 32);
    if (*(_DWORD *)v10)
    {
      --*(_DWORD *)v10;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_1(&v18, &buf);
      }
    }
    dispatch_semaphore_t v11 = dispatch_semaphore_create(0);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(NSObject **)(a1 + 96);
      *(void *)&long long buf = MEMORY[0x1E4F143A8];
      *((void *)&buf + 1) = 0x40000000;
      uint64_t v20 = ____IOHIDSessionScheduleAsync_block_invoke;
      CFRange v21 = &__block_descriptor_tmp_40;
      uint64_t v22 = a1;
      CFArrayRef v23 = v12;
      dispatch_async(v13, &buf);
      dispatch_semaphore_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v12);
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(&v18, &buf);
    }
    ++**(_DWORD **)(a1 + 32);
    uint64_t v9 = 1;
    *(_DWORD *)(a1 + 88) = 1;
    uint64_t v14 = _IOHIDLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18B46C000, v14, OS_LOG_TYPE_INFO, "Successfully opened the IOHIDSession", (uint8_t *)&buf, 2u);
    }
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  *(_DWORD *)(a1 + 92) = 0;
  uint64_t v15 = *(void *)(a1 + 32);
  if (*(_DWORD *)v15)
  {
    --*(_DWORD *)v15;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v18, &buf);
    }
  }
  CFMutableDictionaryRef v16 = _IOHIDLog();
  if (os_signpost_enabled(v16))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl(&dword_18B46C000, v16, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "IOHIDSessionOpen", (const char *)&unk_18B51B6F3, (uint8_t *)&buf, 2u);
  }
  return v9;
}

void __IOHIDSessionClose_block_invoke(uint64_t a1)
{
  CFAllocatorRef v2 = _IOHIDLogCategory(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
    __IOHIDSessionClose_block_invoke_cold_1(v2);
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

__CFArray *IOHIDSessionGetProperty(uint64_t a1, const void *a2)
{
  CFAllocatorRef v2 = _IOHIDSessionCopyPropertyForClient(a1, a2, (const void *)*MEMORY[0x1E4F1D260]);

  return v2;
}

uint64_t IOHIDSessionSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  return _IOHIDSessionSetPropertyForClient(a1, a2, a3, (const void *)*MEMORY[0x1E4F1D260]);
}

uint64_t __FunctionApplierForParameters(CFTypeRef cf1, uint64_t a2, void *a3)
{
  return _IOHIDSessionSetPropertyForClient(*a3, cf1);
}

uint64_t IOHIDSessionCopyEvent(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(context, v17);
  }
  ++**(_DWORD **)(a1 + 32);
  context[0] = a1;
  context[1] = a3;
  uint64_t v13 = 0;
  int v14 = a2;
  int v15 = a4;
  CFArrayRef v16 = *(CFArrayRef *)(a1 + 152);
  v19.CFIndex length = CFArrayGetCount(v16);
  v19.location = 0;
  CFArrayApplyFunction(v16, v19, (CFArrayApplierFunction)__FilterFunctionCopyEvent, context);
  CFSetRef v8 = 0;
  if (!v13) {
    CFSetRef v8 = (const __CFSet *)CFRetain(*(CFTypeRef *)(a1 + 136));
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (*(_DWORD *)v9)
  {
    --*(_DWORD *)v9;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v11, v17);
    }
  }
  if (v8)
  {
    CFSetApplyFunction(v8, (CFSetApplierFunction)__CopyEventForObjectFunction, context);
    CFRelease(v8);
  }
  return v13;
}

uint64_t __FilterFunctionCopyEvent(uint64_t result, uint64_t a2)
{
  if (!*(void *)(a2 + 16))
  {
    uint64_t result = IOHIDSessionFilterCopyEvent(result);
    *(void *)(a2 + 16) = result;
  }
  return result;
}

uint64_t __CopyEventForObjectFunction(uint64_t result, uint64_t *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (!a2[2])
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = IOHIDServiceGetTypeID();
    if (v4 == result)
    {
      uint64_t result = IOHIDServiceCopyEvent(v3, *((unsigned int *)a2 + 6), a2[1], *((unsigned int *)a2 + 7));
      a2[2] = result;
      if (result)
      {
        uint64_t v5 = *a2;
        context[0] = v5;
        context[1] = v3;
        void context[2] = result;
        if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(v5 + 32) + 8))) {
          __IOHIDSessionCreate_block_invoke_cold_4(&v7, v9);
        }
        ++**(_DWORD **)(v5 + 32);
        CFArrayRef v6 = (const __CFArray *)a2[4];
        v11.CFIndex length = CFArrayGetCount(v6);
        v11.location = 0;
        CFArrayApplyFunction(v6, v11, (CFArrayApplierFunction)__FilterFunctionFilterCopyEvent, context);
        uint64_t result = *(void *)(v5 + 32);
        if (*(_DWORD *)result)
        {
          --*(_DWORD *)result;
          uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
          if (result) {
            __IOHIDSessionCreate_block_invoke_cold_1(&v7, v9);
          }
        }
      }
    }
  }
  return result;
}

void _IOHIDSessionDispatchEvent(uint64_t a1, const void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  TimeStampOfint Type = IOHIDEventGetTimeStampOfType((uint64_t)a2, 2);
  TimeStampint Type = IOHIDEventGetTimeStampType((uint64_t)a2);
  _IOHIDDebugTrace(8272, 0, TimeStampOfType, TimeStampType, 0, 0);
  if (a2)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(&v8, v9);
    }
    ++**(_DWORD **)(a1 + 32);
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 112));
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 112), a2);
    if (!Count) {
      dispatch_source_merge_data(*(dispatch_source_t *)(a1 + 104), 1uLL);
    }
    uint64_t v7 = *(void *)(a1 + 32);
    if (*(_DWORD *)v7)
    {
      --*(_DWORD *)v7;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_1(&v8, v9);
      }
    }
  }
}

uint64_t __IOHIDSessionActivityNotificationRelease(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
    __IOHIDSessionCreate_block_invoke_cold_4(&v6, v7);
  }
  ++**(_DWORD **)(a1 + 32);
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 192), a3);
  uint64_t result = *(void *)(a1 + 32);
  if (*(_DWORD *)result)
  {
    --*(_DWORD *)result;
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(result + 8));
    if (result) {
      __IOHIDSessionCreate_block_invoke_cold_1(&v6, v7);
    }
  }
  return result;
}

void *_IOHIDSessionCreateActivityNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = IOHIDNotificationCreate((uint64_t)v8, (uint64_t)__IOHIDSessionActivityNotificationRelease, a1, 0, a2, a3, a4);
  if (v9)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8))) {
      __IOHIDSessionCreate_block_invoke_cold_4(&v12, v13);
    }
    ++**(_DWORD **)(a1 + 32);
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 192), v9);
    uint64_t v10 = *(void *)(a1 + 32);
    if (*(_DWORD *)v10)
    {
      --*(_DWORD *)v10;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8))) {
        __IOHIDSessionCreate_block_invoke_cold_1(&v12, v13);
      }
    }
  }
  return v9;
}

uint64_t __FilterFunctionFilterCopyEvent(uint64_t a1, uint64_t a2)
{
  return IOHIDSessionFilterFilterCopyEvent(a1, *(void *)(a2 + 8), *(void *)(a2 + 16));
}

uint64_t IOHIDEventQueueSuspend(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 152) = 1;
  while (!_IODataQueueDequeue(*(void *)(a1 + 16), *(_DWORD *)(a1 + 56), 0))
    ++*(void *)(a1 + 168);

  return os_unfair_recursive_lock_unlock();
}

uint64_t IOHIDEventQueueResume(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  *(_DWORD *)(a1 + 152) = 0;

  return os_unfair_recursive_lock_unlock();
}

void IOHIDEventQueueNotify(uint64_t a1)
{
  os_unfair_recursive_lock_lock_with_options();
  if (*(_DWORD *)(a1 + 148) && !*(_DWORD *)(a1 + 152))
  {
    int v2 = _IODataQueueSendDataAvailableNotification(*(unsigned int **)(a1 + 16), (mach_msg_header_t *)(a1 + 60));
    os_unfair_recursive_lock_unlock();
    if (v2)
    {
      uint64_t v3 = _IOHIDLog();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        IOHIDEventQueueNotify_cold_1();
      }
    }
  }
  else
  {
    os_unfair_recursive_lock_unlock();
  }
}

IOReturn IOPMCopyCPUPowerStatus(CFDictionaryRef *cpuPowerStatus)
{
  IOReturn v1 = -536870160;
  if (!cpuPowerStatus) {
    return -536870206;
  }
  uint64_t v3 = _io_SCDynamicStoreCreate(*MEMORY[0x1E4F1CF80], @"IOKit Power", 0, 0);
  if (!v3) {
    return -536870212;
  }
  CFTypeID v4 = v3;
  CFStringRef SCKeyForIOKitString = createSCKeyForIOKitString(@"CPU_Power_Limits");
  if (SCKeyForIOKitString)
  {
    CFStringRef v6 = SCKeyForIOKitString;
    uint64_t v7 = _io_SCDynamicStoreCopyValue((uint64_t)v4, (uint64_t)SCKeyForIOKitString);
    *cpuPowerStatus = (CFDictionaryRef)v7;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (v7 && CFGetTypeID(v7) == TypeID)
    {
      IOReturn v1 = 0;
    }
    else if (*cpuPowerStatus)
    {
      CFRelease(*cpuPowerStatus);
      *cpuPowerStatus = 0;
    }
    CFRelease(v6);
  }
  else
  {
    IOReturn v1 = -536870199;
  }
  CFRelease(v4);
  return v1;
}

CFStringRef createSCKeyForIOKitString(const void *a1)
{
  if (CFEqual(a1, @"Thermal_Level_Warning"))
  {
    int v2 = @"ThermalWarning";
    return _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"%@%@/%@", @"State:", @"/IOKit/Power", v2);
  }
  if (CFEqual(a1, @"CPU_Power_Limits"))
  {
    int v2 = @"CPUPower";
    return _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"%@%@/%@", @"State:", @"/IOKit/Power", v2);
  }
  if (CFEqual(a1, @"Performance_Warning"))
  {
    int v2 = @"PerformanceWarning";
    return _io_SCDynamicStoreKeyCreate((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"%@%@/%@", @"State:", @"/IOKit/Power", v2);
  }
  return 0;
}

IOReturn IOPMGetThermalWarningLevel(uint32_t *thermalLevel)
{
  IOReturn v1 = -536870160;
  if (!thermalLevel) {
    return -536870206;
  }
  uint64_t v3 = _io_SCDynamicStoreCreate(*MEMORY[0x1E4F1CF80], @"IOKit Power", 0, 0);
  if (!v3) {
    return -536870212;
  }
  CFTypeID v4 = v3;
  CFStringRef SCKeyForIOKitString = createSCKeyForIOKitString(@"Thermal_Level_Warning");
  if (SCKeyForIOKitString)
  {
    CFStringRef v6 = SCKeyForIOKitString;
    uint64_t v7 = _io_SCDynamicStoreCopyValue((uint64_t)v4, (uint64_t)SCKeyForIOKitString);
    if (v7)
    {
      CFNumberRef v8 = (const __CFNumber *)v7;
      CFTypeID TypeID = CFNumberGetTypeID();
      if (CFGetTypeID(v8) == TypeID)
      {
        CFNumberGetValue(v8, kCFNumberIntType, thermalLevel);
        IOReturn v1 = 0;
      }
      CFRelease(v8);
    }
    CFRelease(v6);
  }
  else
  {
    IOReturn v1 = -536870199;
  }
  CFRelease(v4);
  return v1;
}

uint64_t IOPMGetPerformanceWarningLevel(void *a1)
{
  uint64_t v1 = 3758097136;
  if (!a1) {
    return 3758097090;
  }
  uint64_t v3 = _io_SCDynamicStoreCreate(*MEMORY[0x1E4F1CF80], @"IOKit Power", 0, 0);
  if (!v3) {
    return 3758097084;
  }
  CFTypeID v4 = v3;
  CFStringRef SCKeyForIOKitString = createSCKeyForIOKitString(@"Performance_Warning");
  if (SCKeyForIOKitString)
  {
    CFStringRef v6 = SCKeyForIOKitString;
    uint64_t v7 = _io_SCDynamicStoreCopyValue((uint64_t)v4, (uint64_t)SCKeyForIOKitString);
    if (v7)
    {
      CFNumberRef v8 = (const __CFNumber *)v7;
      CFTypeID TypeID = CFNumberGetTypeID();
      if (CFGetTypeID(v8) == TypeID)
      {
        CFNumberGetValue(v8, kCFNumberIntType, a1);
        uint64_t v1 = 0;
      }
      CFRelease(v8);
    }
    CFRelease(v6);
  }
  else
  {
    uint64_t v1 = 3758097097;
  }
  CFRelease(v4);
  return v1;
}

uint64_t IOUSBDeviceDataGetTypeID()
{
  uint64_t result = __kIOUSBDeviceDataTypeID;
  if (!__kIOUSBDeviceDataTypeID)
  {
    pthread_once(&__dataTypeInit, (void (*)(void))__IOUSBDeviceDataRegister);
    return __kIOUSBDeviceDataTypeID;
  }
  return result;
}

uint64_t __IOUSBDeviceDataRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOUSBDeviceDataCFTypeID TypeID = result;
  return result;
}

double IOUSBDeviceDataCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!__kIOUSBDeviceDataTypeID) {
    pthread_once(&__dataTypeInit, (void (*)(void))__IOUSBDeviceDataRegister);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    double result = 0.0;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(void *)(Instance + 16) = a3;
    *(void *)(Instance + 24) = a4;
    *(void *)(Instance + 32) = a2;
    *(void *)(Instance + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a5;
    *(void *)(Instance + 48) = a6;
  }
  return result;
}

uint64_t IOUSBDeviceDataGetCapacity(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t IOUSBDeviceDataGetBytePtr(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t IOUSBDeviceDataGetMapToken(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t __IOUSBDeviceDataRelease(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(a1 + 40))(*(void *)(a1 + 32), *(void *)(a1 + 48));
}

void IOUSBDeviceControllerRemoveArrivalCallback()
{
  if (_notifyPort)
  {
    IOObjectRelease(_notifyIterator);
    uint64_t v0 = (__CFRunLoop *)_runLoop;
    CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource((IONotificationPortRef)_notifyPort);
    CFRunLoopRemoveSource(v0, RunLoopSource, (CFRunLoopMode)_runLoopMode);
    IONotificationPortDestroy((IONotificationPortRef)_notifyPort);
    _notifyIterator = 0;
    _runLoop = 0;
    _runLoopMode = 0;
    _notifyunsigned int Port = 0;
  }
}

uint64_t IOUSBDeviceControllerRegisterArrivalCallback(uint64_t (*a1)(void), uint64_t a2, uint64_t a3, uint64_t a4)
{
  _runLoop = a3;
  _runLoopMode = a4;
  if (a3)
  {
    CFStringRef v6 = (__CFRunLoop *)a3;
    uint64_t v7 = (IONotificationPort *)_notifyPort;
    if (!_notifyPort)
    {
      uint64_t v7 = IONotificationPortCreate(0);
      _notifyunsigned int Port = (uint64_t)v7;
      CFStringRef v6 = (__CFRunLoop *)_runLoop;
    }
    CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(v7);
    CFRunLoopAddSource(v6, RunLoopSource, (CFRunLoopMode)_runLoopMode);
  }
  if (!_notifyPort) {
    return 3758097084;
  }
  _arrivalCallback = a1;
  _arrivalContext = a2;
  CFDictionaryRef v9 = IOServiceMatching("IOUSBDeviceController");
  uint64_t result = IOServiceAddMatchingNotification((IONotificationPortRef)_notifyPort, "IOServicePublish", v9, (IOServiceMatchingCallback)__IOUSBDeviceControllerPublished, 0, (io_iterator_t *)&_notifyIterator);
  if (!result)
  {
    __IOUSBDeviceControllerPublished(0, _notifyIterator);
    return 0;
  }
  return result;
}

uint64_t __IOUSBDeviceControllerPublished(int a1, io_iterator_t iterator)
{
  uint64_t result = IOIteratorNext(iterator);
  if (result)
  {
    io_object_t v4 = result;
    uint64_t v5 = *MEMORY[0x1E4F1CF80];
    do
    {
      CFTypeRef cf = 0;
      if (!IOUSBDeviceControllerCreateWithService(v5, v4, (uint64_t *)&cf))
      {
        if (cf)
        {
          _arrivalCallback(_arrivalContext);
          CFRelease(cf);
        }
      }
      uint64_t result = IOIteratorNext(iterator);
      io_object_t v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t IOHIDUserDeviceCopyService(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 32);
  if (v1) {
    IOObjectRetain(*(_DWORD *)(a1 + 32));
  }
  return v1;
}

CFTypeID IOHIDUserDeviceGetTypeID(void)
{
  CFTypeID result = __kIOHIDUserDeviceTypeID;
  if (!__kIOHIDUserDeviceTypeID)
  {
    pthread_once(&__deviceTypeInit, (void (*)(void))__IOHIDUserDeviceRegister);
    return __kIOHIDUserDeviceTypeID;
  }
  return result;
}

uint64_t __IOHIDUserDeviceRegister()
{
  IOMasterPort(*MEMORY[0x1E4F14638], (mach_port_t *)&__masterPort);
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOHIDUserDeviceCFTypeID TypeID = result;
  return result;
}

__CFDictionary *__IOHIDUserDeviceSerializeState(uint64_t a1)
{
  uint64_t entryID = 0;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    io_registry_entry_t v3 = *(_DWORD *)(a1 + 32);
    if (v3)
    {
      IOObjectRetain(*(_DWORD *)(a1 + 32));
      IORegistryEntryGetRegistryEntryID(v3, &entryID);
    }
    io_object_t v4 = (const void *)*MEMORY[0x1E4F1CFD0];
    uint64_t v5 = (const void *)*MEMORY[0x1E4F1CFC8];
    if (*(void *)(a1 + 120)) {
      CFStringRef v6 = (const void *)*MEMORY[0x1E4F1CFD0];
    }
    else {
      CFStringRef v6 = (const void *)*MEMORY[0x1E4F1CFC8];
    }
    CFDictionarySetValue(Mutable, @"DispatchQueue", v6);
    if (*(void *)(a1 + 96)) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = v5;
    }
    CFDictionarySetValue(Mutable, @"RunLoop", v7);
    if (*(void *)(a1 + 160)) {
      CFNumberRef v8 = v4;
    }
    else {
      CFNumberRef v8 = v5;
    }
    CFDictionarySetValue(Mutable, @"Queue", v8);
    if (*(void *)(a1 + 216)) {
      CFDictionaryRef v9 = v4;
    }
    else {
      CFDictionaryRef v9 = v5;
    }
    CFDictionarySetValue(Mutable, @"SetReportCallback", v9);
    if (!*(void *)(a1 + 232) && !*(void *)(a1 + 248)) {
      io_object_t v4 = v5;
    }
    CFDictionarySetValue(Mutable, @"GetReportCallback", v4);
    _IOHIDDictionaryAddSInt64(Mutable, @"RegistryID", entryID);
    _IOHIDDictionaryAddSInt64(Mutable, @"QueueCallbackTimestamp", *(void *)(a1 + 72));
    _IOHIDDictionaryAddSInt64(Mutable, @"DequeueTimestamp", *(void *)(a1 + 80));
    _IOHIDDictionaryAddSInt64(Mutable, @"SetReportCnt", *(unsigned int *)(a1 + 280));
    _IOHIDDictionaryAddSInt64(Mutable, @"GetReportCnt", *(unsigned int *)(a1 + 284));
    _IOHIDDictionaryAddSInt64(Mutable, @"HandleReportCnt", *(unsigned int *)(a1 + 288));
    if (v3) {
      IOObjectRelease(v3);
    }
  }
  return Mutable;
}

void *__IOHIDUserDeviceStateHandler(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 16) & 0xFFFFFFFE) != 2) {
    return 0;
  }
  int v2 = __IOHIDUserDeviceSerializeState(a1);
  if (!v2) {
    return 0;
  }
  io_registry_entry_t v3 = v2;
  CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (Data)
  {
    CFDataRef v5 = Data;
    unsigned int Length = CFDataGetLength(Data);
    uint64_t v7 = malloc_type_calloc(1uLL, Length + 200, 0xBEDA62D4uLL);
    if (v7)
    {
      __strlcpy_chk();
      *(_DWORD *)uint64_t v7 = 1;
      *((_DWORD *)v7 + 1) = Length;
      v9.location = 0;
      v9.CFIndex length = Length;
      CFDataGetBytes(v5, v9, (UInt8 *)v7 + 200);
    }
    CFRelease(v3);
  }
  else
  {
    uint64_t v7 = 0;
    CFDataRef v5 = v3;
  }
  CFRelease(v5);
  return v7;
}

CFDictionaryRef IOHIDUserDeviceCreate(const __CFAllocator *a1, const __CFDictionary *a2)
{
  return IOHIDUserDeviceCreateWithOptions(a1, a2, 0);
}

CFDictionaryRef IOHIDUserDeviceCreateWithOptions(const __CFAllocator *a1, const __CFDictionary *a2, int a3)
{
  kern_return_t Service;
  NSObject *v20;
  uint64_t v21;
  dispatch_queue_t v22;
  CFAllocatorRef v23;
  CFDictionaryRef v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  char v30;
  const void *v31;
  int v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t input[2];
  void buf[4];
  uint8_t v43[4];
  uint64_t v44;
  uint64_t v45;

  CFDictionaryRef v3 = a2;
  CFStringRef v45 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v6 = __kIOHIDUserDeviceTypeID;
    if (!__kIOHIDUserDeviceTypeID)
    {
      pthread_once(&__deviceTypeInit, (void (*)(void))__IOHIDUserDeviceRegister);
      uint64_t v6 = __kIOHIDUserDeviceTypeID;
    }
    uint64_t Instance = _IOHIDObjectCreateInstance((uint64_t)a1, v6, 0x118uLL);
    if (!Instance) {
      return 0;
    }
    uint64_t v8 = Instance;
    *(_DWORD *)(Instance + 48) = a3;
    _IOHIDDebugTrace(8193, 0, Instance, 0, 0, 0);
    CFDictionaryRef Copy = CFDictionaryCreateCopy(a1, v3);
    *(void *)(v8 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = Copy;
    if (!Copy) {
      goto LABEL_40;
    }
    mach_port_t v10 = __masterPort;
    CFDictionaryRef v11 = IOServiceMatching("IOHIDResource");
    io_service_t MatchingService = IOServiceGetMatchingService(v10, v11);
    *(_DWORD *)(v8 + 24) = MatchingService;
    if (!MatchingService)
    {
      CFURLRef v34 = _IOHIDLogCategory(5u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        IOHIDUserDeviceCreateWithOptions_cold_1();
      }
      goto LABEL_40;
    }
    if (IOServiceOpen(MatchingService, *MEMORY[0x1E4F14960], 0, (io_connect_t *)(v8 + 28)))
    {
      int v35 = _IOHIDLogCategory(5u);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        IOHIDUserDeviceCreateWithOptions_cold_4();
      }
      goto LABEL_40;
    }
    uint64_t v13 = *(unsigned int *)(v8 + 48);
    input[0] = v13;
    CFDataRef v14 = IOCFSerialize(*(CFTypeRef *)(v8 + 40), 0);
    if (v14)
    {
      CFDataRef v15 = v14;
      mach_port_t v16 = *(_DWORD *)(v8 + 28);
      BytePtr = CFDataGetBytePtr(v14);
      size_t Length = CFDataGetLength(v15);
      Service = IOConnectCallMethod(v16, 0, input, 1u, BytePtr, Length, 0, 0, 0, 0);
      if (!Service)
      {
        Service = IOConnectGetService(*(_DWORD *)(v8 + 28), (io_service_t *)(v8 + 32));
        if (!Service)
        {
          IORegistryEntryGetRegistryEntryID(*(_DWORD *)(v8 + 32), (uint64_t *)(v8 + 88));
          uint64_t v20 = _IOHIDLogCategory(5u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            CFRange v21 = *(void *)(v8 + 88);
            LODWORD(buf[0]) = 134218242;
            *(void *)((char *)buf + 4) = v21;
            WORD2(buf[1]) = 2112;
            *(void *)((char *)&buf[1] + 6) = v8;
            _os_log_impl(&dword_18B46C000, v20, OS_LOG_TYPE_DEFAULT, "0x%llx: Start: %@", (uint8_t *)buf, 0x16u);
          }
          _IOHIDDebugTrace(8195, 0, v8, v13, *(void *)(v8 + 88), 0);
          CFRelease(v15);
          uint64_t v22 = dispatch_queue_create("IOHIDUserDeviceStateQueue", 0);
          *(void *)(v8 + 64) = v22;
          if (v22)
          {
            *(void *)(v8 + 56) = os_state_add_handler();
            *(_OWORD *)uint64_t input = xmmword_18B50C030;
            CFArrayRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            buf[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, (const void *)(v8 + 168));
            buf[1] = @"userDeviceQueue";
            uint64_t v24 = CFDictionaryCreate(v23, (const void **)&__IOHIDUserDeviceSetupAnalytics_keys, (const void **)buf, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (v24)
            {
              CFNumberRef v25 = IOHIDAnalyticsHistogramEventCreate(@"com.apple.hid.queueUsage", (uint64_t)v24, @"UsagePercent", (uint64_t)input, 1);
              *(void *)(v8 + 184) = v25;
              if (!v25)
              {
                CFNumberRef v26 = _IOHIDLogCategory(5u);
                if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v27 = *(void *)(v8 + 88);
                  *(_DWORD *)int v43 = 134217984;
                  CFTypeID v44 = v27;
                  _os_log_impl(&dword_18B46C000, v26, OS_LOG_TYPE_DEFAULT, "0x%llx: Unable to create queue analytics", v43, 0xCu);
                }
                if (!*(void *)(v8 + 184)) {
                  IOHIDAnalyticsEventActivate();
                }
              }
              CFRelease(v24);
            }
            else
            {
              CFIndex v38 = _IOHIDLogCategory(5u);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
                IOHIDUserDeviceCreateWithOptions_cold_3((uint64_t *)(v8 + 88), v38);
              }
            }
            CFUUIDRef v28 = 0;
            char v29 = 1;
            do
            {
              CFArrayRef v30 = v29;
              CFIndex v31 = (const void *)buf[v28];
              if (v31) {
                CFRelease(v31);
              }
              char v29 = 0;
              CFUUIDRef v28 = 1;
            }
            while ((v30 & 1) != 0);
            if (v24)
            {
              CFRetain((CFTypeRef)v8);
              CFDictionaryRef v3 = (const __CFDictionary *)v8;
LABEL_27:
              CFRelease((CFTypeRef)v8);
              return v3;
            }
          }
LABEL_40:
          CFDictionaryRef v3 = 0;
          goto LABEL_27;
        }
      }
      CFURLRef v33 = Service;
      CFRelease(v15);
    }
    else
    {
      CFURLRef v33 = -536870211;
    }
    CFArrayRef v36 = _IOHIDLogCategory(5u);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      uint64_t v39 = *(void *)(v8 + 88);
      double v40 = *(void *)(v8 + 40);
      LODWORD(buf[0]) = 134218498;
      *(void *)((char *)buf + 4) = v39;
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = v33;
      WORD1(buf[2]) = 2112;
      *(void *)((char *)&buf[2] + 4) = v40;
      _os_log_error_impl(&dword_18B46C000, v36, OS_LOG_TYPE_ERROR, "0x%llx: IOHIDUserDevice start failed:0x%x properties:%@", (uint8_t *)buf, 0x1Cu);
    }
    CFArrayRef v37 = _IOHIDLogCategory(5u);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      IOHIDUserDeviceCreateWithOptions_cold_2();
    }
    goto LABEL_40;
  }
  return v3;
}

void *__IOHIDUserDeviceCreateWithOptions_block_invoke(uint64_t a1, uint64_t a2)
{
  return __IOHIDUserDeviceStateHandler(*(void *)(a1 + 32), a2);
}

void IOHIDUserDeviceScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!__IOHIDUserDeviceSetupAsyncSupport(a1)) {
    IOHIDUserDeviceScheduleWithRunLoop_cold_1(&v11, v12);
  }
  *(void *)(a1 + 96) = a2;
  *(void *)(a1 + 104) = a3;
  if (*(void *)(a1 + 152)
    || (CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1),
        CFRunLoopSourceRef v7 = CFMachPortCreateRunLoopSource(v6, *(CFMachPortRef *)(a1 + 144), 0),
        (*(void *)(a1 + 152) = v7) != 0))
  {
    CFRunLoopSourceRef RunLoopSource = *(__CFRunLoopSource **)(a1 + 200);
    if (RunLoopSource {
      || (CFRunLoopSourceRef RunLoopSource = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(a1 + 192)),
    }
          (*(void *)(a1 + 20(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = RunLoopSource) != 0))
    {
      CFRunLoopAddSource(a2, RunLoopSource, a3);
      CFRunLoopAddSource(a2, *(CFRunLoopSourceRef *)(a1 + 152), a3);
      if (*(void *)(a1 + 216) || *(void *)(a1 + 232) || *(void *)(a1 + 248))
      {
        io_connect_t v9 = *(_DWORD *)(a1 + 28);
        mach_port_t Port = CFMachPortGetPort(*(CFMachPortRef *)(a1 + 144));
        IOConnectSetNotificationPort(v9, 0, Port, 0);
      }
      if (*(unsigned char *)(a1 + 48)) {
        IOConnectCallMethod(*(_DWORD *)(a1 + 28), 4u, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
  }
}

BOOL __IOHIDUserDeviceSetupAsyncSupport(uint64_t a1)
{
  if (*(void *)(a1 + 96) || *(void *)(a1 + 120)) {
    __IOHIDDeviceSetupAsyncSupport_cold_3();
  }
  if (!*(void *)(a1 + 160))
  {
    v11.version = 0;
    mach_vm_size_t ofSize = 0;
    if (IOConnectMapMemory(*(_DWORD *)(a1 + 28), 0, *MEMORY[0x1E4F14960], (mach_vm_address_t *)&v11, &ofSize, 1u))
    {
      mach_port_t v10 = _IOHIDLogCategory(5u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        __IOHIDUserDeviceSetupAsyncSupport_cold_1();
      }
      goto LABEL_18;
    }
    mach_vm_size_t v2 = ofSize;
    *(void *)(a1 + 16(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v11.version;
    *(void *)(a1 + 168) = v2;
  }
  if (!*(void *)(a1 + 144))
  {
    Notificationmach_port_t Port = IODataQueueAllocateNotificationPort();
    if (NotificationPort)
    {
      mach_port_t v4 = NotificationPort;
      v11.version = 0;
      memset(&v11.retain, 0, 24);
      v11.info = (void *)a1;
      CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
      CFMachPortRef v6 = CFMachPortCreateWithPort(v5, v4, (CFMachPortCallBack)__IOHIDUserDeviceQueueCallback, &v11, 0);
      *(void *)(a1 + 144) = v6;
      if (!v6) {
        goto LABEL_18;
      }
    }
    else if (!*(void *)(a1 + 144))
    {
LABEL_18:
      BOOL v8 = 0;
      goto LABEL_14;
    }
  }
  IONotificationPortRef v7 = *(IONotificationPortRef *)(a1 + 192);
  if (!v7)
  {
    IONotificationPortRef v7 = IONotificationPortCreate(0);
    *(void *)(a1 + 192) = v7;
  }
  BOOL v8 = v7 != 0;
LABEL_14:
  _IOHIDDebugTrace(8196, 0, a1, v8, 0, 0);
  return v8;
}

void IOHIDUserDeviceUnscheduleFromRunLoop(uint64_t a1)
{
  uint64_t v1 = a1;
  _IOHIDDebugTrace(8197, 0, a1, 0, 0, 0);
  if (*(void *)(v1 + 96)) {
    BOOL v2 = *(void *)(v1 + 120) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    uint64_t v1 = MEMORY[0x1E4F14500];
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  IOConnectSetNotificationPort(*(_DWORD *)(v1 + 28), 0, 0, 0);
  CFRunLoopRemoveSource(*(CFRunLoopRef *)(v1 + 96), *(CFRunLoopSourceRef *)(v1 + 152), *(CFRunLoopMode *)(v1 + 104));
  CFDictionaryRef v3 = *(__CFRunLoopSource **)(v1 + 200);
  mach_port_t v4 = *(__CFRunLoop **)(v1 + 96);
  CFStringRef v5 = *(const __CFString **)(v1 + 104);

  CFRunLoopRemoveSource(v4, v3, v5);
}

void IOHIDUserDeviceScheduleWithDispatchQueue(__IOHIDUserDevice *a1, NSObject *a2)
{
  IOHIDUserDeviceSetDispatchQueue(a1, a2);

  IOHIDUserDeviceActivate(a1);
}

void IOHIDUserDeviceSetDispatchQueue(IOHIDUserDeviceRef device, dispatch_queue_t queue)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  _IOHIDDebugTrace(8198, 0, (uint64_t)device, 0, 0, 0);
  if (!__IOHIDUserDeviceSetupAsyncSupport((uint64_t)device)) {
    IOHIDUserDeviceScheduleWithRunLoop_cold_1(&v8, __str);
  }
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)__str = 0u;
  long long v10 = 0u;
  label = dispatch_queue_get_label(queue);
  CFStringRef v5 = "";
  if (label) {
    CFStringRef v5 = label;
  }
  snprintf(__str, 0x100uLL, "%s.IOHIDUserDeviceRef", v5);
  dispatch_queue_t v6 = dispatch_queue_create_with_target_V2(__str, 0, queue);
  *((void *)device + 15) = v6;
  if (v6)
  {
    _IOHIDObjectInternalRetain(device);
    uint64_t v7 = dispatch_mach_create();
    *((void *)device + 16) = v7;
    if (!v7) {
      _IOHIDObjectInternalRelease(device);
    }
  }
}

void IOHIDUserDeviceActivate(IOHIDUserDeviceRef device)
{
  if (*((void *)device + 15)) {
    BOOL v1 = *((void *)device + 12) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1)
  {
    os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    device = (IOHIDUserDeviceRef)_os_crash_msg();
    __break(1u);
  }
  IOHIDUserDeviceRef v2 = device;
  if ((atomic_fetch_or((atomic_uint *volatile)device + 28, 1u) & 1) == 0)
  {
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)device + 24), *((dispatch_queue_t *)device + 15));
    if (*((void *)v2 + 27)
      || *((void *)v2 + 29)
      || *((void *)v2 + 31)
      || *((void *)v2 + 33)
      || *((void *)v2 + 34))
    {
      io_connect_t v3 = *((_DWORD *)v2 + 7);
      mach_port_t Port = CFMachPortGetPort(*((CFMachPortRef *)v2 + 18));
      IOConnectSetNotificationPort(v3, 0, Port, 0);
    }
    CFMachPortGetPort(*((CFMachPortRef *)v2 + 18));
    dispatch_mach_connect();
    if (*((unsigned char *)v2 + 48)) {
      IOConnectCallMethod(*((_DWORD *)v2 + 7), 4u, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
}

void IOHIDUserDeviceCancel(IOHIDUserDeviceRef device)
{
  _IOHIDDebugTrace(8199, 0, (uint64_t)device, 0, 0, 0);
  if ((atomic_fetch_or((atomic_uint *volatile)device + 28, 2u) & 2) == 0)
  {
    if (*((void *)device + 15)) {
      BOOL v2 = *((void *)device + 12) == 0;
    }
    else {
      BOOL v2 = 0;
    }
    if (v2)
    {
      IOConnectSetNotificationPort(*((_DWORD *)device + 7), 0, 0, 0);
      dispatch_mach_cancel();
    }
    else
    {
      os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
}

uint64_t __IOHIDUserDeviceSetDispatchQueue_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (a2 == 8)
  {
    dispatch_release(*(dispatch_object_t *)(*(void *)(result + 32) + 128));
    *(void *)(*(void *)(v2 + 32) + 128) = 0;
    __IOHIDUserDeviceDestroyDevice(*(void *)(v2 + 32));
    uint64_t v6 = *(void *)(v2 + 32);
    uint64_t v7 = *(void *)(v6 + 136);
    if (v7)
    {
      (*(void (**)(void))(v7 + 16))();
      _Block_release(*(const void **)(*(void *)(v2 + 32) + 136));
      uint64_t v6 = *(void *)(v2 + 32);
      *(void *)(v6 + 136) = 0;
    }
    dispatch_release(*(dispatch_object_t *)(v6 + 120));
    uint64_t v8 = *(const void **)(v2 + 32);
    return _IOHIDObjectInternalRelease(v8);
  }
  else if (a2 == 2)
  {
    uint64_t msg = dispatch_mach_msg_get_msg();
    return __IOHIDUserDeviceQueueCallback(msg, v4, v5, *(void *)(v2 + 32));
  }
  return result;
}

uint64_t __IOHIDUserDeviceQueueCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  kern_return_t v23;
  kern_return_t v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  int v31;
  size_t inputStructCnt;
  uint32_t dataSize;
  unsigned char buf[12];
  __int16 v35;
  kern_return_t v36;
  __int16 v37;
  int v38;
  uint64_t input[3];

  uint64_t input[2] = *MEMORY[0x1E4F143B8];
  _IOHIDDebugTrace(8200, 0, a4, 0, 0, 0);
  uint64_t result = mach_continuous_time();
  *(void *)(a4 + 72) = result;
  uint64_t v6 = *(IODataQueueMemory **)(a4 + 160);
  if (v6)
  {
    if (*(void *)(a4 + 184))
    {
      UInt32 tail = v6->tail;
      if (tail != *(_DWORD *)(a4 + 176))
      {
        IOHIDAnalyticsHistogramEventSetIntegerValue();
        *(_DWORD *)(a4 + 176) = tail;
        uint64_t v6 = *(IODataQueueMemory **)(a4 + 160);
      }
    }
    dataSize = 0;
    uint64_t result = (uint64_t)IODataQueuePeek(v6);
    if (result)
    {
      uint64_t v8 = (unsigned int *)result;
      while (1)
      {
        uint64_t v9 = *(void *)(v8 + 5);
        input[0] = -536870201;
        input[1] = v9;
        inputStructCnt = 0;
        unsigned int v10 = v8[3];
        unsigned int v11 = v8[1];
        if (!v11) {
          break;
        }
        long long v12 = 0;
        if (v11 == 1)
        {
          if (v10)
          {
            if (*v8 > 0x23)
            {
              long long v14 = *(unsigned int **)(v8 + 7);
              uint64_t v13 = v8[9];
              goto LABEL_20;
            }
            char v29 = _IOHIDLogCategory(5u);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              CFArrayRef v30 = *(void *)(a4 + 88);
              CFIndex v31 = *v8;
              *(_DWORD *)long long buf = 134218496;
              *(void *)&uint8_t buf[4] = v30;
              int v35 = 1024;
              CFArrayRef v36 = v10;
              CFArrayRef v37 = 1024;
              CFIndex v38 = v31;
              _os_log_error_impl(&dword_18B46C000, v29, OS_LOG_TYPE_ERROR, "0x%llx: Packet size is to small for large report, but large report flag is set. reportFlags:%#x entrySize:%u", buf, 0x18u);
            }
          }
          else
          {
            if ((unint64_t)*v8 - 24 >= v8[4]) {
              uint64_t v13 = v8[4];
            }
            else {
              uint64_t v13 = *v8 - 24;
            }
            long long v14 = v8 + 7;
LABEL_20:
            ++*(_DWORD *)(a4 + 280);
            if (*(void *)(a4 + 216))
            {
              _IOHIDDebugTrace(8203, 0, a4, 0, 0, 0);
              int v18 = (*(uint64_t (**)(void, void, void, unsigned int *, uint64_t))(a4 + 216))(*(void *)(a4 + 224), v8[2], v10 >> 8, v14, v13);
              goto LABEL_31;
            }
            uint64_t v22 = *(void *)(a4 + 264);
            if (v22)
            {
              int v18 = (*(uint64_t (**)(uint64_t, void, void, unsigned int *, uint64_t))(v22 + 16))(v22, v8[2], v10 >> 8, v14, v13);
LABEL_31:
              input[0] = v18;
            }
            else
            {
              CFNumberRef v26 = _IOHIDLogCategory(5u);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
              {
                uint64_t v27 = *(void *)(a4 + 88);
                *(_DWORD *)long long buf = 134217984;
                *(void *)&uint8_t buf[4] = v27;
                _os_log_impl(&dword_18B46C000, v26, OS_LOG_TYPE_INFO, "0x%llx: set report not handled", buf, 0xCu);
              }
            }
            if (v10)
            {
              *(void *)long long buf = *(void *)(v8 + 7);
              IOConnectCallMethod(*(_DWORD *)(a4 + 28), 5u, (const uint64_t *)buf, 1u, 0, 0, 0, 0, 0, 0);
            }
          }
          long long v12 = 0;
        }
LABEL_35:
        long long v23 = IOConnectCallMethod(*(_DWORD *)(a4 + 28), 3u, input, 2u, v12, inputStructCnt, 0, 0, 0, 0);
        if (v23)
        {
          long long v24 = v23;
          uint64_t v25 = _IOHIDLogCategory(5u);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            CFUUIDRef v28 = *(void *)(a4 + 88);
            *(_DWORD *)long long buf = 134218240;
            *(void *)&uint8_t buf[4] = v28;
            int v35 = 1024;
            CFArrayRef v36 = v24;
            _os_log_error_impl(&dword_18B46C000, v25, OS_LOG_TYPE_ERROR, "0x%llx: kIOHIDResourceDeviceUserClientMethodPostReportResponse:%x", buf, 0x12u);
            if (!v12) {
              goto LABEL_39;
            }
LABEL_38:
            free(v12);
            goto LABEL_39;
          }
        }
        if (v12) {
          goto LABEL_38;
        }
LABEL_39:
        dataSize = 0;
        *(void *)(a4 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = mach_continuous_time();
        IODataQueueDequeue(*(IODataQueueMemory **)(a4 + 160), 0, &dataSize);
        uint64_t result = (uint64_t)IODataQueuePeek(*(IODataQueueMemory **)(a4 + 160));
        uint64_t v8 = (unsigned int *)result;
        if (!result) {
          return result;
        }
      }
      long long v12 = malloc_type_malloc(v8[4], 0x4076ABD7uLL);
      inputStructCnt = v8[4];
      ++*(_DWORD *)(a4 + 284);
      long long v15 = *(int (**)(void, void, void, void *))(a4 + 232);
      if (v15) {
        input[0] = v15(*(void *)(a4 + 240), v8[2], v10 >> 8, v12);
      }
      long long v16 = *(uint64_t (**)(void, void, void, void *, size_t *))(a4 + 248);
      if (v16)
      {
        int v17 = v16(*(void *)(a4 + 256), v8[2], v10 >> 8, v12, &inputStructCnt);
      }
      else
      {
        uint64_t v19 = *(void *)(a4 + 272);
        if (!v19)
        {
LABEL_25:
          if (!*(void *)(a4 + 232) && !*(void *)(a4 + 272))
          {
            long long v20 = _IOHIDLogCategory(5u);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
            {
              uint64_t v21 = *(void *)(a4 + 88);
              *(_DWORD *)long long buf = 134217984;
              *(void *)&uint8_t buf[4] = v21;
              _os_log_impl(&dword_18B46C000, v20, OS_LOG_TYPE_INFO, "0x%llx: get report not handled", buf, 0xCu);
            }
          }
          goto LABEL_35;
        }
        int v17 = (*(uint64_t (**)(uint64_t, void, void, void *, size_t *))(v19 + 16))(v19, v8[2], v10 >> 8, v12, &inputStructCnt);
      }
      input[0] = v17;
      if (*(void *)(a4 + 248)) {
        goto LABEL_35;
      }
      goto LABEL_25;
    }
  }
  return result;
}

uint64_t __IOHIDUserDeviceDestroyDevice(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = _IOHIDLogCategory(5u);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 88);
    int v8 = 134218242;
    uint64_t v9 = v3;
    __int16 v10 = 2112;
    uint64_t v11 = a1;
    _os_log_impl(&dword_18B46C000, v2, OS_LOG_TYPE_DEFAULT, "0x%llx: Destroy: %@", (uint8_t *)&v8, 0x16u);
  }
  uint64_t v4 = *(IONotificationPort **)(a1 + 192);
  if (v4)
  {
    IONotificationPortDestroy(v4);
    *(void *)(a1 + 192) = 0;
  }
  mach_vm_address_t v5 = *(void *)(a1 + 160);
  if (v5)
  {
    IOConnectUnmapMemory(*(_DWORD *)(a1 + 28), 0, *MEMORY[0x1E4F14960], v5);
    *(void *)(a1 + 16(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  io_connect_t v6 = *(_DWORD *)(a1 + 28);
  if (v6)
  {
    IOServiceClose(v6);
    *(_DWORD *)(a1 + 28) = 0;
  }
  uint64_t result = *(unsigned int *)(a1 + 24);
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    *(_DWORD *)(a1 + 24) = 0;
  }
  return result;
}

void IOHIDUserDeviceSetCancelHandler(IOHIDUserDeviceRef device, dispatch_block_t handler)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (!handler || *((void *)device + 17)) {
    IOHIDUserDeviceSetCancelHandler_cold_1(&v2, v3);
  }
  *((void *)device + 17) = _Block_copy(handler);
}

CFTypeRef IOHIDUserDeviceCopyProperty(IOHIDUserDeviceRef device, CFStringRef key)
{
  return IORegistryEntryCreateCFProperty(*((_DWORD *)device + 8), key, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
}

Boolean IOHIDUserDeviceSetProperty(IOHIDUserDeviceRef device, CFStringRef key, CFTypeRef property)
{
  return IOConnectSetCFProperty(*((_DWORD *)device + 7), key, property) == 0;
}

uint64_t IOHIDUserDeviceRegisterGetReportCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 232) = a2;
  *(void *)(result + 24(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
  if (a2 && *(void *)(result + 144))
  {
    io_connect_t v3 = *(_DWORD *)(result + 28);
    mach_port_t Port = CFMachPortGetPort(*(CFMachPortRef *)(result + 144));
    return IOConnectSetNotificationPort(v3, 0, Port, 0);
  }
  return result;
}

uint64_t IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 248) = a2;
  *(void *)(result + 256) = a3;
  if (a2 && *(void *)(result + 144))
  {
    io_connect_t v3 = *(_DWORD *)(result + 28);
    mach_port_t Port = CFMachPortGetPort(*(CFMachPortRef *)(result + 144));
    return IOConnectSetNotificationPort(v3, 0, Port, 0);
  }
  return result;
}

uint64_t IOHIDUserDeviceRegisterSetReportCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 216) = a2;
  *(void *)(result + 224) = a3;
  if (a2 && *(void *)(result + 144))
  {
    io_connect_t v3 = *(_DWORD *)(result + 28);
    mach_port_t Port = CFMachPortGetPort(*(CFMachPortRef *)(result + 144));
    return IOConnectSetNotificationPort(v3, 0, Port, 0);
  }
  return result;
}

void IOHIDUserDeviceRegisterGetReportBlock(IOHIDUserDeviceRef device, IOHIDUserDeviceGetReportBlock block)
{
  if (*((void *)device + 34)) {
    IOHIDUserDeviceRegisterGetReportBlock_cold_1();
  }
  *((void *)device + 34) = _Block_copy(block);
}

void IOHIDUserDeviceRegisterSetReportBlock(IOHIDUserDeviceRef device, IOHIDUserDeviceSetReportBlock block)
{
  if (*((void *)device + 33)) {
    IOHIDUserDeviceRegisterSetReportBlock_cold_1();
  }
  *((void *)device + 33) = _Block_copy(block);
}

uint64_t IOHIDUserDeviceHandleReportAsyncWithTimeStamp(uint64_t a1, uint64_t a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  reference[8] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  if (!v12) {
    return 3758097085;
  }
  uint64_t v13 = (uint64_t)v12;
  void *v12 = a5;
  v12[1] = a6;
  Machmach_port_t Port = IONotificationPortGetMachPort(*(IONotificationPortRef *)(a1 + 192));
  reference[1] = (uint64_t)__IOHIDUserDeviceHandleReportAsyncCallback;
  reference[2] = v13;
  if (dynLinkrosetta_is_current_process_translated_1 && dynLinkrosetta_is_current_process_translated_1())
  {
    if (dynLinkrosetta_convert_to_system_absolute_time_1) {
      a2 = dynLinkrosetta_convert_to_system_absolute_time_1(a2);
    }
  }
  uint64_t input = a2;
  return IOConnectCallAsyncMethod(*(_DWORD *)(a1 + 28), 2u, MachPort, reference, 8u, &input, 1u, a3, a4, 0, 0, 0, 0);
}

void __IOHIDUserDeviceHandleReportAsyncCallback(void *a1, uint64_t a2)
{
  _IOHIDDebugTrace(8202, 0, (uint64_t)a1, 0, 0, 0);
  if (*a1) {
    ((void (*)(void, uint64_t))*a1)(a1[1], a2);
  }

  free(a1);
}

IOReturn IOHIDUserDeviceHandleReportWithTimeStamp(IOHIDUserDeviceRef device, uint64_t timestamp, const uint8_t *report, CFIndex reportLength)
{
  kern_return_t v8;
  NSObject *v9;
  uint64_t input;

  if (dynLinkrosetta_is_current_process_translated_1
    && dynLinkrosetta_is_current_process_translated_1()
    && dynLinkrosetta_convert_to_system_absolute_time_1)
  {
    timestamp = dynLinkrosetta_convert_to_system_absolute_time_1(timestamp);
  }
  uint64_t input = timestamp;
  _IOHIDDebugTrace(8201, 0, timestamp, (uint64_t)device, reportLength, 0);
  ++*((_DWORD *)device + 72);
  int v8 = IOConnectCallMethod(*((_DWORD *)device + 7), 2u, &input, 1u, report, reportLength, 0, 0, 0, 0);
  if (v8)
  {
    uint64_t v9 = _IOHIDLogCategory(5u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      IOHIDUserDeviceHandleReportWithTimeStamp_cold_1();
    }
  }
  return v8;
}

uint64_t IOHIDUserDeviceHandleReport(__IOHIDUserDevice *a1, const uint8_t *a2, CFIndex a3)
{
  uint64_t v6 = mach_absolute_time();

  return IOHIDUserDeviceHandleReportWithTimeStamp(a1, v6, a2, a3);
}

uint64_t IOHIDUserDeviceHandleReportAsync(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = mach_absolute_time();

  return IOHIDUserDeviceHandleReportAsyncWithTimeStamp(a1, v10, a2, a3, a4, a5);
}

void __IOHIDUserDeviceExtRelease(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  _IOHIDDebugTrace(8194, 0, a1, 0, 0, 0);
  if (*(void *)(a1 + 120))
  {
    unsigned int v2 = atomic_load((unsigned int *)(a1 + 112));
    if (v2 != 3) {
      __IOHIDManagerExtRelease_cold_1(&v5, v6, (unsigned int *)(a1 + 112));
    }
  }
  if (*(void *)(a1 + 56)) {
    os_state_remove_handler();
  }
  io_connect_t v3 = *(NSObject **)(a1 + 64);
  if (v3)
  {
    dispatch_set_context(v3, (void *)a1);
    dispatch_set_finalizer_f(*(dispatch_object_t *)(a1 + 64), (dispatch_function_t)__IOHIDUserDeviceFinalizeStateHandler);
    _IOHIDObjectInternalRetain((const void *)a1);
    dispatch_release(*(dispatch_object_t *)(a1 + 64));
  }
  uint64_t v4 = *(__CFMachPort **)(a1 + 144);
  if (v4)
  {
    CFMachPortInvalidate(v4);
  }
}

CFStringRef __IOHIDUserDeviceCopyDebugDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, @"<IOHIDUserDeviceRef ref:%d/%d id:0x%llx stats:%d,%d,%d>", *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(void *)(a1 + 88), *(unsigned int *)(a1 + 280), *(unsigned int *)(a1 + 284), *(unsigned int *)(a1 + 288));
}

void __IOHIDUserDeviceIntRelease(uint64_t a1)
{
  _IOHIDDebugTrace(8194, 0, a1, 0, 0, 0);
  __IOHIDUserDeviceDestroyDevice(a1);
  CFAllocatorRef v2 = *(const void **)(a1 + 152);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 152) = 0;
  }
  io_connect_t v3 = *(__CFMachPort **)(a1 + 144);
  if (v3)
  {
    ipc_space_t v4 = *MEMORY[0x1E4F14960];
    mach_port_name_t Port = CFMachPortGetPort(v3);
    mach_port_mod_refs(v4, Port, 1u, -1);
    CFRelease(*(CFTypeRef *)(a1 + 144));
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 40);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  io_object_t v7 = *(_DWORD *)(a1 + 32);
  if (v7)
  {
    IOObjectRelease(v7);
    *(_DWORD *)(a1 + 32) = 0;
  }
  if (*(void *)(a1 + 184))
  {
    IOHIDAnalyticsEventCancel();
    CFRelease(*(CFTypeRef *)(a1 + 184));
    *(void *)(a1 + 184) = 0;
  }
  int v8 = *(const void **)(a1 + 264);
  if (v8) {
    _Block_release(v8);
  }
  uint64_t v9 = *(const void **)(a1 + 272);
  if (v9)
  {
    _Block_release(v9);
  }
}

uint64_t initrosetta_convert_to_system_absolute_time_1(uint64_t a1)
{
  CFAllocatorRef v2 = (void *)RosettaLibrary_libLibrary_1;
  if (!RosettaLibrary_libLibrary_1)
  {
    CFAllocatorRef v2 = dlopen("/usr/lib/libRosetta.dylib", 2);
    RosettaLibrary_libLibrary_1 = (uint64_t)v2;
  }
  io_connect_t v3 = (uint64_t (*)())dlsym(v2, "rosetta_convert_to_system_absolute_time");
  dynLinkrosetta_convert_to_system_absolute_time_1 = v3;
  if (!v3) {
    return a1;
  }

  return ((uint64_t (*)(uint64_t))v3)(a1);
}

void OUTLINED_FUNCTION_4_0(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

uint64_t IOEthernetControllerGetTypeID()
{
  uint64_t result = __kIOEthernetControllerTypeID;
  if (!__kIOEthernetControllerTypeID)
  {
    pthread_once(&__controllerTypeInit, (void (*)(void))__IOEthernetControllerRegister);
    return __kIOEthernetControllerTypeID;
  }
  return result;
}

uint64_t __IOEthernetControllerRegister()
{
  IOMasterPort(*MEMORY[0x1E4F14638], (mach_port_t *)&__masterPort_0);
  uint64_t result = _CFRuntimeRegisterClass();
  __kIOEthernetControllerCFTypeID TypeID = result;
  return result;
}

uint64_t IOEthernetControllerCreate(uint64_t a1, const void *a2)
{
  kern_return_t v14;
  unsigned int InterfaceWithID;
  int v16;
  uint32_t outputCnt;

  if (!a2) {
    return 0;
  }
  if (!__kIOEthernetControllerTypeID) {
    pthread_once(&__controllerTypeInit, (void (*)(void))__IOEthernetControllerRegister);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 16(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_DWORD *)(Instance + 88) = -1;
    mach_port_t v5 = __masterPort_0;
    CFDictionaryRef v6 = IOServiceMatching("IOUserEthernetResource");
    io_service_t MatchingService = IOServiceGetMatchingService(v5, v6);
    *(_DWORD *)(v4 + 16) = MatchingService;
    if (!MatchingService) {
      return 0;
    }
    if (IOServiceOpen(MatchingService, *MEMORY[0x1E4F14960], 0, (io_connect_t *)(v4 + 20))) {
      goto LABEL_9;
    }
    if (IOCreateReceivePort(0x35u, (mach_port_t *)(v4 + 56))) {
      goto LABEL_9;
    }
    if (IOConnectSetNotificationPort(*(_DWORD *)(v4 + 20), 0, *(_DWORD *)(v4 + 56), 0)) {
      goto LABEL_9;
    }
    CFDataRef v9 = IOCFSerialize(a2, 0);
    if (!v9) {
      goto LABEL_9;
    }
    CFDataRef v10 = v9;
    uint32_t outputCnt = 1;
    mach_port_t v11 = *(_DWORD *)(v4 + 20);
    BytePtr = CFDataGetBytePtr(v9);
    size_t Length = CFDataGetLength(v10);
    long long v14 = IOConnectCallMethod(v11, 0, 0, 0, BytePtr, Length, (uint64_t *)(v4 + 128), &outputCnt, 0, 0);
    CFRelease(v10);
    if (v14
      || (InterfaceWithID = __IOEthernetControllerGetInterfaceWithID(*(void *)(v4 + 128)),
          (*(_DWORD *)(v4 + 32) = InterfaceWithID) == 0)
      || (long long v16 = __connect_to_kernel((const void *)(v4 + 128)), *(_DWORD *)(v4 + 88) = v16, v16 == -1))
    {
LABEL_9:
      CFRelease((CFTypeRef)v4);
      return 0;
    }
  }
  return v4;
}

CFMutableDictionaryRef __IOEthernetControllerGetInterfaceWithID(uint64_t a1)
{
  uint64_t valuePtr = a1;
  CFMutableDictionaryRef result = IOServiceMatching("IONetworkInterface");
  if (result)
  {
    CFAllocatorRef v2 = result;
    CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      CFDictionarySetValue(v2, @"IORegistryEntryID", v3);
      CFRelease(v4);
      return (CFMutableDictionaryRef)IOServiceGetMatchingService(0, v2);
    }
    else
    {
      CFRelease(v2);
      return 0;
    }
  }
  return result;
}

uint64_t __connect_to_kernel(const void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v8 = 0x4000;
  int v9 = 0x10000;
  uint64_t v2 = socket(32, 2, 2);
  if (v2 != -1)
  {
    int v11 = 0;
    memset(v10, 0, sizeof(v10));
    __strlcpy_chk();
    if (ioctl(v2, 0xC0644E03uLL, v10) == -1
      || (uint64_t v6 = 0,
          *(void *)&v5[12] = 0,
          int v7 = 0,
          *(_DWORD *)mach_port_t v5 = 139296,
          *(_DWORD *)&CFStringRef v5[4] = v10[0],
          *(_DWORD *)&v5[8] = 0,
          connect(v2, (const sockaddr *)v5, 0x20u) == -1)
      || setsockopt(v2, 2, 12, a1, 8u) == -1
      || setsockopt(v2, 0xFFFF, 4098, &v9, 4u)
      || setsockopt(v2, 0xFFFF, 4097, &v8, 4u)
      || (int v4 = fcntl(v2, 3), fcntl(v2, 4, v4 | 4u) == -1))
    {
      close(v2);
      return 0xFFFFFFFFLL;
    }
  }
  return v2;
}

uint64_t IOEthernetControllerGetIONetworkInterfaceObject(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t IOEthernetControllerSetLinkStatus(uint64_t a1, unsigned int a2)
{
  uint64_t input = a2;
  return IOConnectCallScalarMethod(*(_DWORD *)(a1 + 20), 1u, &input, 1u, 0, 0);
}

uint64_t IOEthernetControllerSetPowerSavings(uint64_t a1, unsigned int a2)
{
  uint64_t input = a2;
  return IOConnectCallScalarMethod(*(_DWORD *)(a1 + 20), 4u, &input, 1u, 0, 0);
}

ssize_t IOEthernetControllerReadPacket(uint64_t a1, void *a2, size_t a3)
{
  return recv(*(_DWORD *)(a1 + 88), a2, a3, 0);
}

uint64_t IOEthernetControllerWritePacket(uint64_t a1, const void *a2, int64_t a3)
{
  uint64_t v3 = 3758097084;
  if (a3 >= 14)
  {
    if (send(*(_DWORD *)(a1 + 88), a2, a3, 0) <= 0) {
      return 3758097084;
    }
    else {
      return 0;
    }
  }
  return v3;
}

void IOEthernetControllerScheduleWithRunLoop(uint64_t a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  if (a1)
  {
    if (rl)
    {
      mach_port_t v5 = *(_DWORD *)(a1 + 56);
      if (v5 + 1 >= 2 && *(_DWORD *)(a1 + 88) != -1 && !*(void *)(a1 + 40) && !*(void *)(a1 + 48))
      {
        int v7 = *(__CFMachPort **)(a1 + 64);
        if (v7
          || (v11.version = 0,
              memset(&v11.retain, 0, 24),
              v11.info = (void *)a1,
              int v7 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, (CFMachPortCallBack)__IOEthernetControllerCFMachPortCallBack, &v11, 0), (*(void *)(a1 + 64) = v7) != 0))
        {
          if (*(void *)(a1 + 72)
            || (CFRunLoopSourceRef v8 = CFMachPortCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, 0),
                (*(void *)(a1 + 72) = v8) != 0))
          {
            int v9 = *(__CFSocket **)(a1 + 96);
            if (v9
              || (v11.version = 0,
                  memset(&v11.retain, 0, 24),
                  v11.info = (void *)a1,
                  int v9 = CFSocketCreateWithNative((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(_DWORD *)(a1 + 88), 1uLL, (CFSocketCallBack)__IOEthernetControllerCFSocketCallback, (const CFSocketContext *)&v11), (*(void *)(a1 + 96) = v9) != 0))
            {
              if (*(void *)(a1 + 104)
                || (CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, 0),
                    (*(void *)(a1 + 104) = RunLoopSource) != 0))
              {
                CFRunLoopAddSource(rl, *(CFRunLoopSourceRef *)(a1 + 72), mode);
                CFRunLoopAddSource(rl, *(CFRunLoopSourceRef *)(a1 + 104), mode);
                *(void *)(a1 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = rl;
                *(void *)(a1 + 48) = mode;
              }
            }
          }
        }
      }
    }
  }
}

uint64_t __IOEthernetControllerCFMachPortCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)(a4 + 121))
  {
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(*(_DWORD *)(a4 + 32), @"BSD Name", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (CFProperty)
    {
      *(unsigned char *)(a4 + 121) = 1;
      CFRelease(CFProperty);
      CFDataRef v10 = *(void (**)(uint64_t, void))(a4 + 184);
      if (v10) {
        v10(a4, *(void *)(a4 + 192));
      }
    }
  }
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = IOConnectCallScalarMethod(*(_DWORD *)(a4 + 20), 2u, 0, 0, &output, &outputCnt);
  uint64_t v6 = output;
  if (output != *(unsigned __int8 *)(a4 + 120))
  {
    *(unsigned char *)(a4 + 12(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = output;
    if (v6)
    {
      int v7 = *(uint64_t (**)(uint64_t, void))(a4 + 136);
      if (!v7) {
        return result;
      }
      CFRunLoopSourceRef v8 = (void *)(a4 + 144);
    }
    else
    {
      int v7 = *(uint64_t (**)(uint64_t, void))(a4 + 152);
      if (!v7) {
        return result;
      }
      CFRunLoopSourceRef v8 = (void *)(a4 + 160);
    }
    return v7(a4, *v8);
  }
  return result;
}

uint64_t __IOEthernetControllerCFSocketCallback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a5 && a2 == 1 && a5[12] == result)
  {
    mach_port_t v5 = (uint64_t (*)(void *, void))a5[21];
    if (v5) {
      return v5(a5, a5[22]);
    }
  }
  return result;
}

void IOEthernetControllerUnscheduleFromRunLoop(void *a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  if (a1 && rl)
  {
    uint64_t v6 = (__CFRunLoopSource *)a1[13];
    if (v6) {
      CFRunLoopRemoveSource(rl, v6, mode);
    }
    int v7 = (__CFRunLoopSource *)a1[9];
    if (v7) {
      CFRunLoopRemoveSource(rl, v7, mode);
    }
    a1[5] = 0;
    a1[6] = 0;
  }
}

void IOEthernetControllerSetDispatchQueue(uint64_t a1, dispatch_queue_t queue)
{
  if (a1)
  {
    uintptr_t v4 = *(unsigned int *)(a1 + 56);
    if ((v4 + 1) >= 2 && *(_DWORD *)(a1 + 88) != -1)
    {
      mach_port_t v5 = *(NSObject **)(a1 + 80);
      if (queue)
      {
        if (!v5)
        {
          uint64_t v6 = dispatch_source_create(MEMORY[0x1E4F14458], v4, 0, queue);
          *(void *)(a1 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v6;
          if (v6)
          {
            handler[0] = MEMORY[0x1E4F143A8];
            handler[1] = 0x40000000;
            handler[2] = __IOEthernetControllerSetDispatchQueue_block_invoke;
            handler[3] = &__block_descriptor_tmp_18;
            handler[4] = a1;
            dispatch_source_set_event_handler(v6, handler);
            dispatch_resume(*(dispatch_object_t *)(a1 + 80));
          }
        }
        if (!*(void *)(a1 + 112) && *(void *)(a1 + 168))
        {
          int v7 = dispatch_source_create(MEMORY[0x1E4F14478], *(int *)(a1 + 88), 0, queue);
          *(void *)(a1 + 112) = v7;
          if (v7)
          {
            v9[0] = MEMORY[0x1E4F143A8];
            v9[1] = 0x40000000;
            void v9[2] = __IOEthernetControllerSetDispatchQueue_block_invoke_2;
            v9[3] = &__block_descriptor_tmp_9_0;
            v9[4] = a1;
            dispatch_source_set_event_handler(v7, v9);
            dispatch_resume(*(dispatch_object_t *)(a1 + 112));
          }
        }
      }
      else
      {
        if (v5)
        {
          dispatch_release(v5);
          *(void *)(a1 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
        }
        CFRunLoopSourceRef v8 = *(NSObject **)(a1 + 112);
        if (v8)
        {
          dispatch_release(v8);
          *(void *)(a1 + 112) = 0;
        }
      }
    }
  }
}

uint64_t __IOEthernetControllerSetDispatchQueue_block_invoke(uint64_t a1)
{
  memset(v5, 0, sizeof(v5));
  uint64_t result = mach_msg((mach_msg_header_t *)v5, 258, 0, 0x20u, *(_DWORD *)(*(void *)(a1 + 32) + 56), 0, 0);
  if (!result) {
    return __IOEthernetControllerCFMachPortCallBack(result, v3, v4, *(void *)(a1 + 32));
  }
  return result;
}

uint64_t __IOEthernetControllerSetDispatchQueue_block_invoke_2(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  uint64_t v2 = *(uint64_t (**)(uint64_t, void))(result + 168);
  if (v2) {
    return v2(result, *(void *)(result + 176));
  }
  return result;
}

uint64_t IOEthernetControllerRegisterEnableCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 136) = a2;
  *(void *)(result + 144) = a3;
  return result;
}

uint64_t IOEthernetControllerRegisterDisableCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 152) = a2;
  *(void *)(result + 16(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = a3;
  return result;
}

uint64_t IOEthernetControllerRegisterPacketAvailableCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 168) = a2;
  *(void *)(result + 176) = a3;
  return result;
}

uint64_t IOEthernetControllerRegisterBSDAttachCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 184) = a2;
  *(void *)(result + 192) = a3;
  return result;
}

uint64_t IOEthernetControllerGetBSDSocket(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 88);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void __IOEthernetControllerRelease(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v3 = *(NSObject **)(a1 + 80);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(a1 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  uint64_t v4 = *(NSObject **)(a1 + 112);
  if (v4)
  {
    dispatch_release(v4);
    *(void *)(a1 + 112) = 0;
  }
  mach_port_t v5 = *(__CFSocket **)(a1 + 96);
  if (v5)
  {
    CFSocketInvalidate(v5);
    *(_DWORD *)(a1 + 88) = -1;
    CFRelease(*(CFTypeRef *)(a1 + 96));
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 104);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 104) = 0;
  }
  int v7 = *(_DWORD *)(a1 + 88);
  if (v7 != -1)
  {
    close(v7);
    *(_DWORD *)(a1 + 88) = -1;
  }
  io_connect_t v8 = *(_DWORD *)(a1 + 20);
  if (v8)
  {
    IOServiceClose(v8);
    *(_DWORD *)(a1 + 2(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  io_object_t v9 = *(_DWORD *)(a1 + 16);
  if (v9)
  {
    IOObjectRelease(v9);
    *(_DWORD *)(a1 + 16) = 0;
  }
  io_object_t v10 = *(_DWORD *)(a1 + 32);
  if (v10)
  {
    IOObjectRelease(v10);
    *(_DWORD *)(a1 + 32) = 0;
  }
  CFMachPortContext v11 = *(__CFMachPort **)(a1 + 64);
  if (v11)
  {
    CFMachPortInvalidate(v11);
    CFRelease(*(CFTypeRef *)(a1 + 64));
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v12 = *(const void **)(a1 + 72);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 72) = 0;
  }
  mach_port_name_t v13 = *(_DWORD *)(a1 + 56);
  if (v13)
  {
    mach_port_mod_refs(*MEMORY[0x1E4F14960], v13, 1u, -1);
    *(_DWORD *)(a1 + 56) = 0;
  }
}

uint64_t IOMIGMachPortGetTypeID()
{
  uint64_t result = __IOMIGMachPortTypeID;
  if (!__IOMIGMachPortTypeID)
  {
    pthread_once(&__IOMIGMachPortTypeInit, (void (*)(void))__IOMIGMachPortRegister);
    return __IOMIGMachPortTypeID;
  }
  return result;
}

void IOMIGMachPortUnscheduleFromRunLoop(uint64_t a1, __CFRunLoop *cf1, const __CFString *a3)
{
  if (cf1)
  {
    if (a3)
    {
      int v7 = (void *)(a1 + 16);
      uint64_t v6 = *(const void **)(a1 + 16);
      if (v6)
      {
        if (*(void *)(a1 + 24))
        {
          if (CFEqual(cf1, v6))
          {
            if (CFEqual(a3, *(CFTypeRef *)(a1 + 24)))
            {
              *int v7 = 0;
              v7[1] = 0;
              io_connect_t v8 = *(__CFRunLoopSource **)(a1 + 56);
              if (v8)
              {
                CFRunLoopRemoveSource(cf1, v8, a3);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t __sOSKextDefaultLogFunction(uint64_t a1, uint64_t a2, char *a3, ...)
{
  va_start(va, a3);
  uint64_t v3 = (FILE *)*MEMORY[0x1E4F143C8];
  vfprintf((FILE *)*MEMORY[0x1E4F143C8], a3, va);
  return fputc(10, v3);
}

uint64_t OSKextGetTypeID()
{
  return __kOSKextTypeID;
}

void __OSKextReinit(uint64_t a1)
{
  if (a1)
  {
    if ((*(unsigned char *)(a1 + 88) & 4) == 0)
    {
      uint64_t v2 = *(const void **)(a1 + 24);
      if (v2) {
        CFRelease(v2);
      }
      *(void *)(a1 + 24) = 0;
      OSKextFlushDiagnostics(a1, -1);
      *(_DWORD *)(a1 + 92) = 0;
      __OSKextProcessInfoDictionary(a1, 0, v3, v4, v5, v6, v7, v8);
    }
  }
  else
  {
    CFDictionaryRef v9 = (const __CFDictionary *)__sOSKextsByURL;
    if (__sOSKextsByURL)
    {
      CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)__OSKextReinitApplierFunction, 0);
    }
  }
}

void OSKextFlushLoadInfo(uint64_t a1, int a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  char context = a2;
  pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  if (a1)
  {
    if (*(void *)(a1 + 16)) {
      __OSKextGetFileSystemPath(a1, 0, 0, buffer, v5, v6, v7, v8);
    }
    CFDictionaryRef v9 = *(CFTypeRef **)(a1 + 72);
    if (v9)
    {
      if ((OSKextFlushLoadInfo_flushingAll & 1) == 0)
      {
        OSKextLog(a1, 262149, "Flushing load info for %s (%s dependencies)", v4, v5, v6, v7, v8, (char)buffer);
        CFDictionaryRef v9 = *(CFTypeRef **)(a1 + 72);
      }
      if (v9[1])
      {
        CFRelease(v9[1]);
        CFDictionaryRef v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[1] = 0;
      if (v9[16])
      {
        CFRelease(v9[16]);
        CFDictionaryRef v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[16] = 0;
      if (v9[17])
      {
        CFRelease(v9[17]);
        CFDictionaryRef v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[17] = 0;
      if (v9[18])
      {
        CFRelease(v9[18]);
        CFDictionaryRef v9 = *(CFTypeRef **)(a1 + 72);
      }
      v9[18] = 0;
      if (!a2 || (OSKextFlushDependencies((void *)a1), (CFDictionaryRef v9 = *(CFTypeRef **)(a1 + 72)) != 0)) {
        free(v9);
      }
      *(void *)(a1 + 72) = 0;
      int v10 = *(_DWORD *)(a1 + 92);
      if ((~v10 & 0x4900) != 0) {
        *(_DWORD *)(a1 + 92) = v10 & 0xFFFD81FF;
      }
    }
  }
  else if (__sOSKextsByURL)
  {
    OSKextFlushLoadInfo_flushingAll = 1;
    CFMachPortContext v11 = "with";
    if (!a2) {
      CFMachPortContext v11 = "keeping";
    }
    OSKextLog(0, 262149, "Flushing load info for all kexts (%s dependencies)", v4, v5, v6, v7, v8, (char)v11);
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushLoadInfoApplierFunction, &context);
    OSKextFlushLoadInfo_flushingAll = 0;
  }
}

char **OSKextGetArchitecture()
{
  return __sOSKextArchInfo;
}

uint64_t OSKextGetExecutableURL(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t result = a1[4];
  if (!result)
  {
    memset(&v45, 0, sizeof(v45));
    __OSKextGetFileSystemPath((uint64_t)a1, 0, 1u, v55, a5, a6, a7, a8);
    OSKextLog((uint64_t)a1, 131079, "Checking CFBundle of %s for executable URL.", v10, v11, v12, v13, v14, (char)v55);
    CFStringRef v15 = (const __CFString *)_CFBundleCopyExecutableURLInDirectory();
    if (v15)
    {
LABEL_3:
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      BOOL v16 = v15 != 0;
      *(_OWORD *)buffer = 0u;
      long long v47 = 0u;
      if (v15 && __sOSKextTargetString)
      {
        CFDictionaryRef ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, @"OSKextVariantOverride");
        if (ValueForInfoDictionaryKey
          && (CFDictionaryRef v22 = ValueForInfoDictionaryKey,
              CFDictionaryContainsKey(ValueForInfoDictionaryKey, (const void *)__sOSKextTargetString))
          && (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v22, (const void *)__sOSKextTargetString)) != 0
          && !CFStringGetCString(Value, buffer, 128, 0x8000100u))
        {
          *(void *)buffer = 0;
          BOOL v16 = 1;
        }
        else
        {
          int v24 = buffer[0];
          BOOL v16 = 1;
          if (buffer[0]) {
            goto LABEL_21;
          }
        }
      }
LABEL_20:
      __strlcpy_chk();
      int v24 = buffer[0];
      if (!v16)
      {
LABEL_27:
        if (v15) {
          goto LABEL_28;
        }
        return a1[4];
      }
LABEL_21:
      if (v24)
      {
        if (!__OSKextGetFileSystemPath(0, (CFURLRef)v15, 1u, __s, v18, v19, v20, v21))
        {
LABEL_29:
          CFRelease(v15);
          return a1[4];
        }
        size_t v33 = strlen((const char *)__s);
        strlcpy((char *)&__s[v33], buffer, 1024 - v33);
        OSKextLog((uint64_t)a1, 131079, "Statting %s for suffix.", v34, v35, v36, v37, v38, (char)__s);
        if (!stat((const char *)__s, &v45))
        {
          CFAllocatorRef v39 = CFGetAllocator(a1);
          CFStringRef v40 = CFStringCreateWithCString(v39, (const char *)__s, 0x8000100u);
          if (v40)
          {
            CFStringRef v41 = v40;
            CFAllocatorRef v42 = CFGetAllocator(a1);
            CFURLRef v43 = CFURLCreateWithFileSystemPath(v42, v41, kCFURLPOSIXPathStyle, 0);
            CFRelease(v41);
            if (v43)
            {
              CFRelease(v15);
              CFStringRef v15 = (const __CFString *)v43;
            }
          }
        }
LABEL_28:
        a1[4] = CFRetain(v15);
        goto LABEL_29;
      }
      goto LABEL_27;
    }
    CFStringRef v25 = (const __CFString *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, (const __CFString *)*MEMORY[0x1E4F1CFF0]);
    if (v25)
    {
      CFStringRef v29 = v25;
      CFArrayRef v30 = @"Kext has a CFBundleExecutable property but the executable can't be found";
      uint64_t v31 = (uint64_t)a1;
    }
    else
    {
      CFUUIDRef v32 = (__CFString *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, @"OSBundleSharedExecutableIdentifier");
      CFStringRef v15 = v32;
      if (!v32)
      {
        BOOL v16 = 0;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        *(_OWORD *)buffer = 0u;
        long long v47 = 0u;
        goto LABEL_20;
      }
      if (OSKextGetKextWithIdentifier(v32))
      {
        CFStringRef v15 = (const __CFString *)_CFBundleCopyExecutableURLInDirectory();
        goto LABEL_3;
      }
      CFArrayRef v30 = @"Kext claims a shared executable with named kext, but that kext can't be found";
      uint64_t v31 = (uint64_t)a1;
      CFStringRef v29 = v15;
    }
    __OSKextAddDiagnostic(v31, 1, v30, v29, 0, v26, v27, v28, v44);
    return a1[4];
  }
  return result;
}

uint64_t __OSKextGetFileSystemPath(uint64_t a1, CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    url = *(CFURLRef *)(a1 + 16);
  }
  if (!url || (uint64_t result = CFURLGetFileSystemRepresentation(url, resolveAgainstBase, buffer, 1024), !result))
  {
    OSKextLog(a1, 17, "String/URL conversion failure.", (uint64_t)buffer, a5, a6, a7, a8, v11);
    uint64_t result = 0;
    strcpy((char *)buffer, "(unknown)");
  }
  return result;
}

uint64_t OSKextGetURL(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

const void *OSKextGetValueForInfoDictionaryKey(uint64_t a1, const __CFString *a2)
{
  if (!__OSKextReadInfoDictionary(a1, 0)) {
    return 0;
  }
  if (CFStringHasPrefix(a2, @"OS") || CFStringHasPrefix(a2, @"IO"))
  {
    pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
    if (NXGetArchInfoFromCpuType(*((_DWORD *)__sOSKextArchInfo + 2), -1))
    {
      CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 56);
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@%s%s");
      if (v5)
      {
        CFStringRef v11 = v5;
        CFStringRef Value = CFDictionaryGetValue(v4, v5);
        if (Value)
        {
          uint64_t v13 = Value;
          CFRelease(v11);
          return v13;
        }
        uint64_t v13 = CFDictionaryGetValue(v4, a2);
        CFRelease(v11);
        if (v13) {
          return v13;
        }
      }
      else
      {
        OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, (char)a2);
      }
    }
  }
  CFDictionaryRef v15 = *(const __CFDictionary **)(a1 + 56);

  return CFDictionaryGetValue(v15, a2);
}

void __OSKextAddDiagnostic(uint64_t a1, int a2, const void *a3, const __CFString *a4, const __CFString *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!a4) {
    return;
  }
  if ((__sOSKextRecordsDiagnositcs & a2) == 0) {
    return;
  }
  CFStringRef v10 = a4;
  CFMutableDictionaryRef Diagnostics = __OSKextGetDiagnostics(a1, a2);
  if (!Diagnostics) {
    return;
  }
  CFDictionaryRef v14 = Diagnostics;
  CFTypeID v15 = CFGetTypeID(v10);
  if (v15 == CFURLGetTypeID())
  {
    CFStringRef v16 = CFURLCopyFileSystemPath((CFURLRef)v10, kCFURLPOSIXPathStyle);
    if (v16)
    {
      CFStringRef v22 = v16;
      CFStringRef v23 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    CFTypeID v24 = CFGetTypeID(v10);
    if (v24 != CFArrayGetTypeID())
    {
      CFStringRef v23 = 0;
      CFStringRef v22 = 0;
      if (!a5)
      {
LABEL_17:
        CFStringRef Value = (__CFString *)CFDictionaryGetValue(v14, a3);
        if (Value)
        {
          CFUUIDRef v32 = Value;
          CFTypeID TypeID = CFArrayGetTypeID();
          if (TypeID != CFGetTypeID(v32))
          {
            OSKextLog(a1, 262145, "Internal error in diagnositcs recording", v34, v35, v36, v37, v38, v40);
            if (!v23) {
              goto LABEL_30;
            }
            goto LABEL_29;
          }
          CFStringRef v39 = 0;
          goto LABEL_22;
        }
        CFStringRef Mutable = (const __CFString *)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          CFStringRef v39 = Mutable;
          CFDictionarySetValue(v14, a3, Mutable);
          CFUUIDRef v32 = (__CFString *)v39;
LABEL_22:
          v42.CFIndex length = CFArrayGetCount((CFArrayRef)v32);
          v42.location = 0;
          if (!CFArrayGetCountOfValue((CFArrayRef)v32, v42, v10)) {
            CFArrayAppendValue((CFMutableArrayRef)v32, v10);
          }
          if (v39)
          {
            CFRelease(v39);
            if (!v23) {
              goto LABEL_30;
            }
            goto LABEL_29;
          }
          goto LABEL_28;
        }
LABEL_27:
        OSKextLog((uint64_t)Mutable, 17, "Memory allocation failure.", v26, v27, v28, v29, v30, v40);
LABEL_28:
        if (!v23)
        {
LABEL_30:
          if (a5) {
            CFRelease(a5);
          }
          if (v22)
          {
            CFRelease(v22);
          }
          return;
        }
LABEL_29:
        CFRelease(v23);
        goto LABEL_30;
      }
LABEL_16:
      CFStringRef Mutable = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ - %@", v10, a5);
      a5 = Mutable;
      CFStringRef v10 = Mutable;
      if (!Mutable) {
        goto LABEL_27;
      }
      goto LABEL_17;
    }
    CFStringRef v16 = CFStringCreateByCombiningStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFArrayRef)v10, @".");
    if (v16)
    {
      CFStringRef v23 = v16;
      CFStringRef v22 = 0;
LABEL_10:
      CFStringRef v10 = v16;
      if (!a5) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
  }

  OSKextLog((uint64_t)v16, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, a9);
}

const void *OSKextGetKextWithIdentifier(void *a1)
{
  if (!__sOSKextsByIdentifier) {
    return 0;
  }
  __OSKextRealizeKextsWithIdentifier(a1);
  CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  uint64_t v3 = Value;
  if (!Value) {
    return v3;
  }
  uint64_t v4 = __kOSKextTypeID;
  if (v4 == CFGetTypeID(Value)) {
    return v3;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v3) || !CFArrayGetCount((CFArrayRef)v3)) {
    return 0;
  }

  return CFArrayGetValueAtIndex((CFArrayRef)v3, 0);
}

uint64_t OSKextGetKernelExecutableURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 92) & 8) != 0) {
    return 0;
  }
  else {
    return OSKextGetExecutableURL((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t OSKextDeclaresUserExecutable(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 3) & 1;
}

uint64_t OSKextGetUserExecutableURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 92) & 8) != 0) {
    return OSKextGetExecutableURL((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 0;
  }
}

void OSKextSetExecutableSuffix(uint64_t a1, char *__s1)
{
  if (a1)
  {
    __strlcpy_chk();
    return;
  }
  if (!__s1 || (uint64_t v2 = strndup(__s1, 0x400uLL)) == 0)
  {
LABEL_12:
    OSKextExecutableVariant = 0;
    return;
  }
  uint64_t v3 = v2;
  uint64_t v4 = basename(v2);
  if (!v4 || (CFStringRef v5 = strchr(v4, 46)) == 0)
  {
    free(v3);
    goto LABEL_12;
  }
  uint64_t v6 = v5 + 1;
  uint64_t v7 = strchr(v5 + 1, 46);
  if (v7) {
    size_t v8 = v7 - v6;
  }
  else {
    size_t v8 = strlen(v6);
  }
  if (v8 + 2 >= 0x80) {
    size_t v9 = 128;
  }
  else {
    size_t v9 = v8 + 2;
  }
  __snprintf_chk(&OSKextExecutableVariant, v9, 0, 0x80uLL, "_%s", v6);

  free(v3);
}

uint64_t OSKextSetTargetString(char *cStr)
{
  if (__sOSKextTargetString)
  {
    CFRelease((CFTypeRef)__sOSKextTargetString);
    __sOSKextTargetString = 0;
  }
  CFStringRef v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
  if (v2)
  {
    __sOSKextTargetString = (uint64_t)v2;
    return 1;
  }
  else
  {
    OSKextLog(0, 17, "%s %d - cannot allocate memory for target string", v3, v4, v5, v6, v7, (char)"OSKextSetTargetString");
    return 0;
  }
}

uint64_t OSKextGetTargetString()
{
  return __sOSKextTargetString;
}

void OSKextSetLogFilter(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2) {
    size_t v8 = &__sKernelLogFilter;
  }
  else {
    size_t v8 = &__sUserLogFilter;
  }
  int v9 = *v8;
  int *v8 = a1;
  if (v9 != a1)
  {
    CFStringRef v10 = "kernel";
    if (!a2) {
      CFStringRef v10 = "user";
    }
    OSKextLog(0, 23, "Kext %s-space log filter changed from 0x%x to 0x%x.", a4, a5, a6, a7, a8, (char)v10);
  }
}

uint64_t OSKextGetLogFilter(int a1)
{
  uint64_t v1 = &__sKernelLogFilter;
  if (!a1) {
    uint64_t v1 = &__sUserLogFilter;
  }
  return *v1;
}

uint64_t (*OSKextSetLogOutputFunction(uint64_t (*result)(int, int, char *)))(int, int, char *)
{
  __sOSKextLogOutputFunction = result;
  return result;
}

void OSKextSetSimulatedSafeBoot(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = __sOSKextSimulatedSafeBoot;
  CFStringRef v10 = "true";
  if (!a1) {
    CFStringRef v10 = "false";
  }
  OSKextLog(0, 262150, "Kext library setting simulated safe boot mode to %s.", a4, a5, a6, a7, a8, (char)v10);
  __sOSKextSimulatedSafeBoot = a1;
  if (v9 != a1)
  {
    CFDictionaryRef v11 = (const __CFDictionary *)__sOSKextsByURL;
    if (__sOSKextsByURL)
    {
      CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)__OSKextReinitApplierFunction, 0);
    }
  }
}

uint64_t OSKextGetSimulatedSafeBoot()
{
  return __sOSKextSimulatedSafeBoot;
}

uint64_t OSKextGetActualSafeBoot()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v9 = 0;
  *(void *)CFStringRef v10 = 0x4200000001;
  if ((OSKextGetActualSafeBoot_gotIt & 1) == 0)
  {
    size_t v8 = 4;
    if (sysctl(v10, 2u, &v9, &v8, 0, 0))
    {
      uint64_t v0 = __error();
      char v1 = strerror(*v0);
      OSKextLog(0, 81, "Can't determine actual safe boot mode - sysctl() failed for KERN_SAFEBOOT - %s.", v2, v3, v4, v5, v6, v1);
    }
    else
    {
      OSKextGetActualSafeBoot_uint64_t result = v9 != 0;
      OSKextGetActualSafeBoot_gotIt = 1;
    }
  }
  return OSKextGetActualSafeBoot_result;
}

void OSKextSetRecordsDiagnostics(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = " for:";
  if (!a1) {
    int v9 = " off";
  }
  OSKextLog(0, 3436582, "Kext library recording diagnostics%s%s%s%s%s.", a4, a5, a6, a7, a8, (char)v9);
  __sOSKextRecordsDiagnositcs = a1;
}

uint64_t OSKextGetRecordsDiagnostics()
{
  return __sOSKextRecordsDiagnositcs;
}

void OSKextSetUsesCaches(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a1;
  int v9 = "now";
  if (!a1) {
    int v9 = "not";
  }
  OSKextLog(0, 262150, "Kext library %s using caches.", a4, a5, a6, a7, a8, (char)v9);
  __sOSKextUsesCaches = v8;
}

uint64_t OSKextGetUsesCaches()
{
  return __sOSKextUsesCaches;
}

uint64_t _OSKextSetStrictRecordingByLastOpened(uint64_t result)
{
  __sOSKextStrictRecordingByLastOpened = result;
  return result;
}

uint64_t _OSKextSetStrictAuthentication(uint64_t result)
{
  __sOSKextStrictAuthentication = result;
  return result;
}

uint64_t (*_OSKextSetAuthenticationFunction(uint64_t (*result)(), uint64_t a2))()
{
  __sOSKextAuthenticationFunction[0] = result;
  __sOSKextAuthenticationContext = a2;
  return result;
}

void *_OSKextSetLoadAuditFunction(void *result)
{
  __sOSKextLoadAuditFunction = result;
  return result;
}

void *_OSKextSetPersonalityPatcherFunction(void *result)
{
  __sOSKextPersonalityPatcherFunction = result;
  return result;
}

void *OSKextCreate(uint64_t a1, const __CFURL *a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  CFStringRef v3 = CFURLCopyPathExtension(a2);
  if (v3)
  {
    CFStringRef v4 = v3;
    if ((CFEqual(v3, @"kext") || CFEqual(v4, @"dext"))
      && __OSKextGetFileSystemPath(0, a2, 1u, buffer, v5, v6, v7, v8))
    {
      if (realpath_DARWIN_EXTSN((const char *)buffer, __s))
      {
        size_t v14 = strlen(__s);
        CFURLRef v15 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)__s, v14, 1u);
        if (v15)
        {
          CFURLRef v21 = v15;
          KextWithURL = OSKextGetKextWithURL(v15);
          if (KextWithURL)
          {
            uint64_t v28 = KextWithURL;
            OSKextLog(0, 393223, "%s is already open; returning existing object.",
              v23,
              v24,
              v25,
              v26,
              v27,
              (char)buffer);
            CFRetain(v28);
LABEL_22:
            CFRelease(v21);
            goto LABEL_23;
          }
          OSKextLog(0, 393223, "Creating %s.", v23, v24, v25, v26, v27, (char)__s);
          uint64_t v28 = __OSKextAlloc();
          if (!v28)
          {
            OSKextLog(0, 17, "Memory allocation failure.", v29, v30, v31, v32, v33, v68);
            goto LABEL_22;
          }
          __OSKextGetFileSystemPath(0, v21, 1u, v71, v30, v31, v32, v33);
          OSKextLog((uint64_t)v28, 131079, "Opening CFBundle for %s.", v34, v35, v36, v37, v38, (char)v71);
          CFAllocatorRef v39 = CFGetAllocator(v28);
          CFBundleRef v40 = CFBundleCreate(v39, v21);
          if (v40)
          {
            CFBundleRef v46 = v40;
            v28[2] = CFRetain(v21);
            if (__OSKextReadInfoDictionary((uint64_t)v28, (uint64_t)v46))
            {
              __OSKextProcessInfoDictionary((uint64_t)v28, (uint64_t)v46, v47, v48, v49, v50, v51, v52);
              int v60 = __OSKextRecordKext((uint64_t)v28, v53, v54, v55, v56, v57, v58, v59);
              OSKextLog((uint64_t)v28, 131079, "Releasing CFBundle for %s", v61, v62, v63, v64, v65, (char)v71);
              CFRelease(v46);
              if (v60) {
                goto LABEL_22;
              }
            }
            else
            {
              OSKextLog((uint64_t)v28, 131079, "Releasing CFBundle for %s", v48, v49, v50, v51, v52, (char)v71);
              CFRelease(v46);
            }
          }
          else
          {
            OSKextLog(0, 131073, "Can't open CFBundle for %s.", v41, v42, v43, v44, v45, (char)v71);
          }
          CFRelease(v28);
          uint64_t v28 = 0;
          goto LABEL_22;
        }
        OSKextLog(0, 17, "Memory allocation failure.", v16, v17, v18, v19, v20, v67);
      }
      else
      {
        OSKextLog(0, 131073, "Unable to determine realpath for %s - failing.", v9, v10, v11, v12, v13, (char)buffer);
      }
    }
    uint64_t v28 = 0;
LABEL_23:
    CFRelease(v4);
    return v28;
  }
  return 0;
}

unsigned char *OSKextGetKextWithURL(const __CFURL *a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (!__OSKextGetFileSystemPath(0, a1, 0, buffer, v2, v3, v4, v5)
    || !__OSKextGetFileSystemPath(0, a1, 1u, v36, v6, v7, v8, v9))
  {
    return 0;
  }
  if (!realpath_DARWIN_EXTSN((const char *)v36, __s))
  {
    OSKextLog(0, 131073, "Unable to determine realpath for %s - failing.", v10, v11, v12, v13, v14, (char)v36);
    return 0;
  }
  CFAllocatorRef v15 = CFGetAllocator(a1);
  size_t v16 = strlen(__s);
  CFURLRef v17 = CFURLCreateFromFileSystemRepresentation(v15, (const UInt8 *)__s, v16, 1u);
  if (!v17)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v18, v19, v20, v21, v22, v34);
    return 0;
  }
  CFURLRef v23 = v17;
  if (__sOSKextsByURL)
  {
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByURL, v17);
    uint64_t v32 = Value;
    if (Value && (Value[88] & 4) != 0) {
      __OSKextRealize((uint64_t)Value, v25, v26, v27, v28, v29, v30, v31);
    }
  }
  else
  {
    uint64_t v32 = 0;
  }
  CFRelease(v23);
  return v32;
}

_OWORD *__OSKextAlloc()
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (Instance)
  {
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
    Instance[1] = 0u;
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v1, v2, v3, v4, v5, v8);
  }
  return v6;
}

CFArrayRef OSKextCreateKextsFromURL(const __CFAllocator *a1, const __CFURL *a2)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);

  return __OSKextCreateKextsFromURL(a1, a2, 0, 1);
}

CFArrayRef __OSKextCreateKextsFromURL(const __CFAllocator *a1, const __CFURL *a2, uint64_t a3, int a4)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  CFArrayRef v77 = 0;
  CFStringRef v8 = CFURLCopyPathExtension(a2);
  CFStringRef v9 = v8;
  if (v8 && (CFEqual(v8, @"kext") || CFEqual(v9, @"dext")))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
    CFArrayRef v77 = Mutable;
    if (Mutable)
    {
      size_t v16 = Mutable;
      CFURLRef v17 = OSKextCreate((uint64_t)a1, a2);
      if (v17)
      {
        uint64_t v18 = (uint64_t)v17;
        CFArrayAppendValue(v16, v17);
        if (a4)
        {
          uint64_t v26 = OSKextCopyPlugins(v18, v19, v20, v21, v22, v23, v24, v25);
          CFArrayRef v27 = v26;
          if (v26 && CFArrayGetCount(v26))
          {
            v81.CFIndex length = CFArrayGetCount(v27);
            v81.location = 0;
            CFArrayAppendArray(v16, v27, v81);
          }
        }
        else
        {
          CFArrayRef v27 = 0;
        }
        CFRelease(v9);
        uint64_t v73 = (const void *)v18;
        goto LABEL_53;
      }
    }
    else
    {
      OSKextLog(0, 17, "Memory allocation failure.", v11, v12, v13, v14, v15, (char)v75);
    }
    CFArrayRef v70 = (const __CFArray *)v9;
LABEL_56:
    CFRelease(v70);
    return v77;
  }
  SInt32 errorCode = 0;
  CFArrayRef v27 = CFURLCopyAbsoluteURL(a2);
  if (!v27)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v28, v29, v30, v31, v32, (char)v75);
    CFBooleanRef v39 = 0;
    goto LABEL_43;
  }
  __OSKextGetFileSystemPath(0, v27, 1u, buffer, v29, v30, v31, v32);
  CFBooleanRef v33 = (const __CFBoolean *)CFURLCreatePropertyFromResource(a1, a2, (CFStringRef)*MEMORY[0x1E4F1D5D0], &errorCode);
  CFBooleanRef v39 = v33;
  if (!v33)
  {
    CFStringRef v75 = buffer;
    mach_port_name_t v71 = "Failed to check path %s (CF error %ld).";
    CFMutableArrayRef v45 = (CFMutableArrayRef)a3;
    int v72 = 131073;
LABEL_38:
    OSKextLog((uint64_t)v45, v72, v71, v34, v35, v36, v37, v38, (char)v75);
    goto LABEL_43;
  }
  if (!CFBooleanGetValue(v33))
  {
    if (!a3) {
      OSKextLog(0, 131076, "%s: %s - no such file or directory.", v40, v41, v42, v43, v44, (char)"__OSKextCreateKextsFromURL");
    }
    goto LABEL_43;
  }
  if (_OSKextReadFromIdentifierCacheForFolder(v27, (CFTypeRef *)&v77))
  {
LABEL_43:
    CFArrayRef v52 = 0;
    goto LABEL_44;
  }
  CFMutableArrayRef v45 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v77 = v45;
  if (!v45)
  {
    mach_port_name_t v71 = "Memory allocation failure.";
    int v72 = 17;
    goto LABEL_38;
  }
  OSKextLog(a3, 65540, "Scanning %s for kexts.", v34, v35, v36, v37, v38, (char)buffer);
  CFArrayRef v46 = (const __CFArray *)CFURLCreatePropertyFromResource(a1, a2, (CFStringRef)*MEMORY[0x1E4F1D5C8], &errorCode);
  CFArrayRef v52 = v46;
  if (!v46 || errorCode)
  {
    CFArrayRef v56 = 0;
    if (errorCode == -12 || !errorCode) {
      goto LABEL_45;
    }
    OSKextLog(a3, 131073, "Failed to read contents of %s, CFURL error %d.", v47, v48, v49, v50, v51, (char)buffer);
LABEL_44:
    CFArrayRef v56 = 0;
    goto LABEL_45;
  }
  CFIndex Count = CFArrayGetCount(v46);
  if (Count < 1)
  {
    CFArrayRef v56 = 0;
  }
  else
  {
    CFIndex v54 = Count;
    CFIndex v55 = 0;
    CFArrayRef v56 = 0;
    do
    {
      CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v52, v55);
      if (v9) {
        CFRelease(v9);
      }
      if (v56) {
        CFRelease(v56);
      }
      CFStringRef v58 = CFURLCopyPathExtension(ValueAtIndex);
      CFStringRef v9 = v58;
      if (v58 && (CFEqual(v58, @"kext") || CFEqual(v9, @"dext")))
      {
        __OSKextGetFileSystemPath(0, ValueAtIndex, 0, v78, v59, v60, v61, v62);
        if (a3) {
          OSKextLog(a3, 65542, "Found plugin %s.", v63, v64, v65, v66, v67, (char)v78);
        }
        else {
          OSKextLog(0, 65542, "Found %s.", v63, v64, v65, v66, v67, (char)v78);
        }
        pthread_once(&__sOSKextInitialized, __OSKextInitialize);
        CFArrayRef KextsFromURL = (const __CFArray *)__OSKextCreateKextsFromURL(a1, ValueAtIndex, 0, 1);
        CFArrayRef v56 = KextsFromURL;
        if (KextsFromURL)
        {
          __int16 v69 = v77;
          v82.CFIndex length = CFArrayGetCount(KextsFromURL);
          v82.location = 0;
          CFArrayAppendArray(v69, v56, v82);
        }
      }
      else
      {
        CFArrayRef v56 = 0;
      }
      ++v55;
    }
    while (v54 != v55);
  }
  _OSKextWriteIdentifierCacheForKextsInDirectory(v77, v27, 0);
LABEL_45:
  if (v9) {
    CFRelease(v9);
  }
  if (v39) {
    CFRelease(v39);
  }
  if (v52) {
    CFRelease(v52);
  }
  if (v56)
  {
    uint64_t v73 = v56;
LABEL_53:
    CFRelease(v73);
  }
  if (v27)
  {
    CFArrayRef v70 = v27;
    goto LABEL_56;
  }
  return v77;
}

__CFArray *OSKextCreateKextsFromURLs(const __CFAllocator *a1, const __CFArray *a2)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFIndex Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      CFArrayRef v12 = 0;
      for (CFIndex i = 0; i != v11; ++i)
      {
        while (1)
        {
          CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(a2, i);
          if (v12) {
            CFRelease(v12);
          }
          CFArrayRef KextsFromURL = __OSKextCreateKextsFromURL(a1, ValueAtIndex, 0, 1);
          CFArrayRef v12 = KextsFromURL;
          if (KextsFromURL) {
            break;
          }
          if (++i == v11) {
            goto LABEL_12;
          }
        }
        v21.CFIndex length = CFArrayGetCount(KextsFromURL);
        v21.location = 0;
        CFArrayAppendArray(Mutable, v12, v21);
      }
      CFRelease(v12);
    }
LABEL_12:
    if (CFArrayGetCount(Mutable) && CFArrayGetCount(Mutable) >= 1)
    {
      CFIndex v16 = 0;
      do
      {
        CFURLRef v17 = CFArrayGetValueAtIndex(Mutable, v16++);
        if (v16 < CFArrayGetCount(Mutable))
        {
          CFIndex v18 = v16;
          do
          {
            if (v17 == CFArrayGetValueAtIndex(Mutable, v18)) {
              CFArrayRemoveValueAtIndex(Mutable, v18);
            }
            else {
              ++v18;
            }
          }
          while (v18 < CFArrayGetCount(Mutable));
        }
      }
      while (v16 < CFArrayGetCount(Mutable));
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v20);
  }
  return Mutable;
}

uint64_t _OSKextReadFromIdentifierCacheForFolder(const __CFURL *a1, CFTypeRef *a2)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  CFTypeRef cf = 0;
  int valuePtr = 0;
  if (!__sOSKextUsesCaches) {
    return 0;
  }
  if (!__OSKextGetFileSystemPath(0, a1, 1u, buffer, v4, v5, v6, v7))
  {
    uint64_t v44 = "String/URL conversion failure.";
LABEL_30:
    int v45 = 17;
LABEL_35:
    OSKextLog(0, v45, v44, v8, v9, v10, v11, v12, (char)v62);
LABEL_36:
    uint64_t v43 = 0;
    uint64_t v34 = 0;
    goto LABEL_37;
  }
  if (a2) {
    p_CFTypeRef cf = &cf;
  }
  else {
    p_CFTypeRef cf = 0;
  }
  if (!_OSKextReadCache(a1, @"KextIdentifiers", 0, 2, 1, p_cf)) {
    goto LABEL_36;
  }
  if (a2)
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(cf))
    {
      CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"OSKextIdentifierCacheVersion");
      if (Value
        && (CFRange v21 = Value, v22 = CFNumberGetTypeID(), v22 == CFGetTypeID(v21))
        && CFNumberGetValue((CFNumberRef)v21, kCFNumberSInt32Type, &valuePtr))
      {
        if (valuePtr == 2)
        {
          uint64_t v23 = CFDictionaryGetValue((CFDictionaryRef)cf, @"OSKextIdentifierCacheBasePath");
          if (v23 && (uint64_t v24 = v23, v25 = CFStringGetTypeID(), v25 == CFGetTypeID(v24)))
          {
            CFArrayRef v26 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, @"OSKextIdentifierCacheKextInfo");
            if (v26)
            {
              CFArrayRef v27 = v26;
              CFTypeID v28 = CFArrayGetTypeID();
              if (v28 == CFGetTypeID(v27))
              {
                OSKextLog(0, 262148, "Creating kexts from identifier->path cache for %s.", v8, v9, v10, v11, v12, (char)buffer);
                CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
                if (Mutable)
                {
                  CFArrayRef v30 = Mutable;
                  CFIndex Count = CFArrayGetCount(v27);
                  if (Count < 1)
                  {
                    uint64_t v34 = 0;
LABEL_47:
                    CFIndex v47 = CFArrayGetCount(v30);
                    if (v47 >= 1)
                    {
                      unint64_t v53 = v47 + 1;
                      do
                      {
                        CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v30, v53 - 2);
                        if (!__OSKextRecordKext((uint64_t)ValueAtIndex, v55, v56, v57, v58, v59, v60, v61)) {
                          CFArrayRemoveValueAtIndex(v30, v53 - 2);
                        }
                        --v53;
                      }
                      while (v53 > 1);
                    }
                    OSKextLog(0, 393220, "Finished reading identifier->path cache for %s.", v48, v49, v50, v51, v52, (char)buffer);
                    *a2 = CFRetain(v30);
                    uint64_t v43 = 1;
                  }
                  else
                  {
                    CFIndex v32 = Count;
                    CFIndex v33 = 0;
                    uint64_t v34 = 0;
                    while (1)
                    {
                      uint64_t v35 = CFArrayGetValueAtIndex(v27, v33);
                      CFTypeID v36 = CFDictionaryGetTypeID();
                      if (v36 != CFGetTypeID(v35)) {
                        break;
                      }
                      if (v34) {
                        CFRelease(v34);
                      }
                      CFAllocatorRef v42 = CFGetAllocator(0);
                      uint64_t v34 = __OSKextCreateFromIdentifierCacheDict(v42, (CFDictionaryRef)v35, (uint64_t)v24, v33);
                      if (!v34) {
                        goto LABEL_54;
                      }
                      v67.CFIndex length = CFArrayGetCount(v30);
                      v67.location = 0;
                      if (CFArrayGetFirstIndexOfValue(v30, v67, v34) == -1) {
                        CFArrayAppendValue(v30, v34);
                      }
                      if (v32 == ++v33) {
                        goto LABEL_47;
                      }
                    }
                    OSKextLog(0, 1, "Kext identifier->path cache for %s - kext entry not a dictionary.", v37, v38, v39, v40, v41, (char)buffer);
LABEL_54:
                    uint64_t v43 = 0;
                  }
                  CFRelease(v30);
                  goto LABEL_37;
                }
                uint64_t v44 = "Memory allocation failure.";
                goto LABEL_30;
              }
            }
            uint64_t v44 = "Kext identifier->path cache - kext info is not an array.";
          }
          else
          {
            uint64_t v62 = buffer;
            uint64_t v44 = "Kext identifier->path cache for %s - base path missing or invalid.";
          }
        }
        else
        {
          uint64_t v62 = buffer;
          uint64_t v44 = "Kext identifier->path cache for %s - version %d unsupported.";
        }
      }
      else
      {
        uint64_t v62 = buffer;
        uint64_t v44 = "Kext identifier->cache for %s - cache version missing/invalid.";
      }
    }
    else
    {
      uint64_t v62 = buffer;
      uint64_t v44 = "Kext identifier->path cache for %s - not a dictionary.";
    }
    int v45 = 262145;
    goto LABEL_35;
  }
  OSKextLog(0, 262151, "Kext identifier->path cache for %s is up to date.", v14, v15, v16, v17, v18, (char)buffer);
  uint64_t v34 = 0;
  uint64_t v43 = 1;
LABEL_37:
  if (cf) {
    CFRelease(cf);
  }
  if (v34) {
    CFRelease(v34);
  }
  return v43;
}

uint64_t _OSKextReadCache(const void *a1, uint64_t a2, const char **a3, int a4, int a5, CFTypeRef *a6)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  CFTypeRef cf = 0;
  SInt32 errorCode = 0;
  CFTypeRef v68 = 0;
  memset(&strm, 0, sizeof(strm));
  CFURLRef CacheFileURL = __OSKextCreateCacheFileURL(a1, a2, a3, a4);
  if (!CacheFileURL)
  {
    uint64_t v19 = 0;
    UTF8CStringForCFString = 0;
    CFDataRef v21 = 0;
    CFTypeID v22 = 0;
    char v18 = 1;
    goto LABEL_7;
  }
  char v18 = 1;
  if (!__OSKextGetFileSystemPath(0, CacheFileURL, 1u, buffer, v13, v14, v15, v16)
    || __OSKextCacheNeedsUpdate(CacheFileURL, a1))
  {
    goto LABEL_4;
  }
  if (!a6)
  {
    UTF8CStringForCFString = 0;
    CFDataRef v21 = 0;
    CFTypeID v22 = 0;
LABEL_32:
    uint64_t v19 = 1;
    goto LABEL_7;
  }
  OSKextLog(0, 393220, "Reading cache file %s.", v12, v13, v14, v15, v16, (char)buffer);
  CFAllocatorRef v24 = CFGetAllocator(CacheFileURL);
  if (!CFURLCreateDataAndPropertiesFromResource(v24, CacheFileURL, (CFDataRef *)&cf, 0, 0, &errorCode))
  {
    OSKextLog(0, 131073, "Can't open cache file %s, CF error %d.", v25, v26, v27, v28, v29, (char)buffer);
LABEL_4:
    uint64_t v19 = 0;
    UTF8CStringForCFString = 0;
    CFDataRef v21 = 0;
LABEL_5:
    CFTypeID v22 = 0;
    goto LABEL_7;
  }
  strm.next_in = (Bytef *)CFDataGetBytePtr((CFDataRef)cf);
  strm.avail_in = CFDataGetLength((CFDataRef)cf);
  size_t v30 = 5 * strm.avail_in;
  memset(&strm.zalloc, 0, 24);
  uint64_t v31 = (Bytef *)malloc_type_malloc(v30, 0x30CAEF9CuLL);
  CFTypeID v22 = v31;
  if (!v31)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v32, v33, v34, v35, v36, v66);
    uint64_t v19 = 0;
    UTF8CStringForCFString = 0;
    CFDataRef v21 = 0;
    goto LABEL_7;
  }
  strm.next_out = v31;
  strm.avail_out = v30;
  if (inflateInit2_(&strm, 47, "1.2.12", 112))
  {
    OSKextLog(0, 131073, "Error initializing zlib uncompression for %s.", v37, v38, v39, v40, v41, (char)buffer);
    goto LABEL_4;
  }
  int v42 = 16;
  while (1)
  {
    int v43 = inflate(&strm, 0);
    if (v43 != -5 && v43 != 0) {
      break;
    }
    v30 *= 2;
    uint64_t v50 = (char *)malloc_type_realloc(v22, v30, 0x74211840uLL);
    CFTypeID v22 = v50;
    if (!v50)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v44, v45, v46, v47, v48, v66);
      uint64_t v19 = 0;
      UTF8CStringForCFString = 0;
      CFDataRef v21 = 0;
      goto LABEL_52;
    }
    strm.next_out = (Bytef *)&v50[strm.total_out];
    strm.avail_out = v30 - LODWORD(strm.total_out);
    if (!--v42) {
      goto LABEL_49;
    }
  }
  if (v43 != 1)
  {
LABEL_49:
    OSKextLog(0, 131073, "Error uncompressing kext cache file %s - zlib returned %d - %s.", v44, v45, v46, v47, v48, (char)buffer);
    uint64_t v19 = 0;
    UTF8CStringForCFString = 0;
    CFDataRef v21 = 0;
LABEL_50:
    char v18 = 0;
    goto LABEL_5;
  }
  CFAllocatorRef v51 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v52 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v22, strm.total_out, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
  CFDataRef v21 = v52;
  if (!v52)
  {
    uint64_t v59 = "Memory allocation failure.";
    int v60 = 17;
LABEL_61:
    OSKextLog(0, v60, v59, v53, v54, v55, v56, v57, v66);
    uint64_t v19 = 0;
    UTF8CStringForCFString = 0;
    goto LABEL_50;
  }
  if (!a5)
  {
    CFTypeID v22 = (void *)CFRetain(v52);
LABEL_58:
    UTF8CStringForCFString = 0;
    char v18 = 0;
    goto LABEL_32;
  }
  if ((a4 - 1) <= 1)
  {
    CFPropertyListRef v58 = CFPropertyListCreateFromXMLData(v51, v52, 0, (CFStringRef *)&v68);
    goto LABEL_57;
  }
  if (a4 != 3)
  {
    int v60 = 393217;
    char v66 = a4;
    uint64_t v59 = "Invalid cache format %d specified.";
    goto LABEL_61;
  }
  CFPropertyListRef v58 = IOCFUnserialize((const char *)v22, v51, 0, (CFStringRef *)&v68);
LABEL_57:
  CFTypeID v22 = (void *)v58;
  if (v58) {
    goto LABEL_58;
  }
  UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)v68);
  OSKextLog(0, 393217, "Can't read plist from cache file %s - %s.", v61, v62, v63, v64, v65, (char)buffer);
  uint64_t v19 = 0;
LABEL_52:
  char v18 = 0;
LABEL_7:
  OSKextLog(0, 393220, "Finished reading cache file %s.", v12, v13, v14, v15, v16, (char)buffer);
  if (a6 && v19 && v22) {
    *a6 = CFRetain(v22);
  }
  if (CacheFileURL) {
    CFRelease(CacheFileURL);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v68) {
    CFRelease(v68);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (UTF8CStringForCFString) {
    free(UTF8CStringForCFString);
  }
  if ((v18 & 1) == 0) {
    inflateEnd(&strm);
  }
  return v19;
}

CFTypeRef *__OSKextCreateFromIdentifierCacheDict(const __CFAllocator *a1, CFDictionaryRef theDict, uint64_t a3, char a4)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"OSBundlePath");
  if (!Value || (v14 = Value, CFTypeID v15 = CFGetTypeID(Value), v15 != CFStringGetTypeID()))
  {
    char v63 = a4;
    char v20 = "Can't create kext: missing or non-string path in identifier cache entry %d.";
LABEL_10:
    int v21 = 262145;
LABEL_11:
    OSKextLog(0, v21, v20, v9, v10, v11, v12, v13, v63);
    return 0;
  }
  if (!CFStringHasSuffix(v14, @"kext") && !CFStringHasSuffix(v14, @"dext"))
  {
    char v63 = a4;
    char v20 = "Can't create kext: path in identifier cache entry %d doesn't name a kext.";
    goto LABEL_10;
  }
  CFBooleanRef v16 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"OSBundleUsesAbsolutePath");
  if (v16)
  {
    CFBooleanRef v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v17))
      {
        CFStringRef v19 = 0;
        goto LABEL_14;
      }
    }
  }
  CFStringRef v14 = CFStringCreateWithFormat(a1, 0, @"%@/%@", a3, v14);
  CFStringRef v19 = v14;
  if (!v14)
  {
    char v20 = "Memory allocation failure.";
    int v21 = 17;
    goto LABEL_11;
  }
LABEL_14:
  CFAllocatorRef v24 = CFURLCreateWithFileSystemPath(a1, v14, kCFURLPOSIXPathStyle, 1u);
  size_t v30 = v24;
  if (v24)
  {
    __OSKextGetFileSystemPath(0, (CFURLRef)v24, 1u, buffer, v26, v27, v28, v29);
    CFTypeID v22 = (CFTypeRef *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByURL, v30);
    uint64_t v31 = 0;
    uint64_t v32 = v22;
    if (v22)
    {
LABEL_18:
      uint64_t v33 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1CFF8]);
      if (v33 && (uint64_t v39 = v33, v40 = CFGetTypeID(v33), v40 == CFStringGetTypeID()))
      {
        if (v22)
        {
          if (!CFEqual(v39, v22[3]))
          {
            OSKextLog((uint64_t)v22, 262145, "Can't create kext from cache: %s is already open and has a different CFBundleIdentifier from identifier->path cache entry %d.", v41, v42, v43, v44, v45, (char)buffer);
LABEL_27:
            CFRetain(v22);
LABEL_28:
            if (v31) {
              CFRelease(v31);
            }
            goto LABEL_30;
          }
        }
        else
        {
          v31[3] = CFRetain(v39);
        }
        CFStringRef v47 = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1D020]);
        if (v47 && (CFStringRef v48 = v47, v49 = CFGetTypeID(v47), v49 == CFStringGetTypeID()))
        {
          uint64_t v50 = OSKextParseVersionCFString(v48);
          if (v50 < 0)
          {
            uint64_t v46 = "Can't create kext: invalid CFBundleVersion in identifier cache entry entry %d.";
          }
          else
          {
            if (v22)
            {
              if ((CFTypeRef)v50 != v22[5])
              {
                OSKextLog((uint64_t)v22, 262145, "Can't create kext from cache: %s is already open and has a different CFBundleVersion from identifier->path cache entry %d.", v34, v35, v36, v37, v38, (char)buffer);
                goto LABEL_27;
              }
            }
            else
            {
              v31[5] = (CFTypeRef)v50;
            }
            CFAllocatorRef v51 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1CC60]);
            if (v51 && (CFDataRef v52 = v51, v53 = CFGetTypeID(v51), v53 == CFStringGetTypeID()))
            {
              int v54 = CFEqual(v52, @"DEXT");
              if (v22)
              {
                if (((*((_DWORD *)v22 + 23) >> 3) & 1) != v54) {
                  OSKextLog((uint64_t)v22, 262145, "Can't create kext from cache: %s is already open and has a different CFBundlePackageType from identifier->path cache entry %d.", v55, v56, v57, v58, v59, (char)buffer);
                }
                if (!v31) {
                  goto LABEL_57;
                }
              }
              else
              {
                *((_DWORD *)v31 + 23) = *((_DWORD *)v31 + 23) & 0xFFFFFFF7 | (8 * (v54 != 0));
              }
              CFBooleanRef v60 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"OSBundleEnableKextLogging");
              if (!v60)
              {
LABEL_57:
                CFTypeID v22 = v32;
                goto LABEL_27;
              }
              CFBooleanRef v61 = v60;
              CFTypeID v62 = CFGetTypeID(v60);
              if (v62 == CFBooleanGetTypeID())
              {
                *((_DWORD *)v31 + 23) = *((_DWORD *)v31 + 23) & 0xFFFFFFDF | (32 * (CFBooleanGetValue(v61) != 0));
                *((_DWORD *)v31 + 23) = *((_DWORD *)v31 + 23) & 0xFFFFFFEF | (16 * (CFBooleanGetValue(v61) != 0));
                goto LABEL_57;
              }
              uint64_t v46 = "Can't create kext from cache: non-BOOLean OSKextEnableKextLogging in identifier cache entry %d.";
            }
            else
            {
              uint64_t v46 = "Can't create kext: missing or non-string bundle package type in identifier cache entry %d.";
            }
          }
        }
        else
        {
          uint64_t v46 = "Can't create kext: missing or non-string version in identifier cache entry %d.";
        }
      }
      else
      {
        uint64_t v46 = "Can't create kext: missing or non-string CFBundleIdentifier in identifier cache entry %d.";
      }
      OSKextLog((uint64_t)v22, 262145, v46, v34, v35, v36, v37, v38, a4);
      if (!v22) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    CFAllocatorRef v24 = __OSKextAlloc();
    if (v24)
    {
      uint64_t v32 = (CFTypeRef *)v24;
      *((unsigned char *)v24 + 88) |= 4u;
      *((void *)v24 + 2) = CFRetain(v30);
      uint64_t v31 = v32;
      goto LABEL_18;
    }
  }
  OSKextLog((uint64_t)v24, 17, "Memory allocation failure.", v25, v26, v27, v28, v29, v63);
  CFTypeID v22 = 0;
LABEL_30:
  if (v19) {
    CFRelease(v19);
  }
  if (v30) {
    CFRelease(v30);
  }
  return v22;
}

uint64_t __OSKextRecordKext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CFStringRef v9 = *(const __CFString **)(a1 + 24);
  if (v9) {
    UTF8CStringForCFString = createUTF8CStringForCFString(v9);
  }
  else {
    UTF8CStringForCFString = 0;
  }
  CFURLRef v11 = *(const __CFURL **)(a1 + 16);
  if (v11)
  {
    CFURLRef v13 = CFURLCopyAbsoluteURL(v11);
    if (!v13)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v12, a5, a6, a7, a8, v28);
      uint64_t v14 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    CFURLRef v13 = 0;
  }
  __OSKextGetFileSystemPath(0, v13, 1u, buffer, a5, a6, a7, a8);
  CFArrayRef v15 = (const __CFArray *)__sOSAllKexts;
  v32.CFIndex length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  v32.location = 0;
  if (CFArrayGetFirstIndexOfValue(v15, v32, (const void *)a1) == -1) {
    CFArrayAppendValue((CFMutableArrayRef)__sOSAllKexts, (const void *)a1);
  }
  if (v13 && (*(unsigned char *)(a1 + 88) & 8) == 0) {
    CFDictionarySetValue((CFMutableDictionaryRef)__sOSKextsByURL, v13, (const void *)a1);
  }
  uint64_t v14 = __OSKextRecordKextInIdentifierDict((CFMutableArrayRef)a1, (CFDictionaryRef)__sOSKextsByIdentifier, v16, v17, v18, v19, v20, v21);
  if (v14)
  {
    OSKextVersionGetString(*(void *)(a1 + 40), v30, 0x14u);
    OSKextLog(a1, 262149, "Recorded %s%s, id %s, version %s.", v22, v23, v24, v25, v26, (char)buffer);
  }
  if (v13) {
    CFRelease(v13);
  }
LABEL_17:
  if (UTF8CStringForCFString) {
    free(UTF8CStringForCFString);
  }
  return v14;
}

uint64_t OSKextGetIdentifier(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t OSKextGetVersion(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

void __OSKextRealize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 88) & 4) == 0)
  {
    *(unsigned char *)(a1 + 88) &= ~4u;
    return;
  }
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 262150, "Realizing %s from identifier cache object.", v9, v10, v11, v12, v13, (char)buffer);
  __OSKextRemoveKextFromIdentifierDict(a1, (const __CFDictionary *)__sOSKextsByIdentifier, v14, v15, v16, v17, v18, v19, v23);
  uint64_t v20 = *(const void **)(a1 + 24);
  uint64_t v21 = *(void *)(a1 + 40);
  *(void *)(a1 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = -1;
  *(void *)(a1 + 24) = @"__unknown__";
  __OSKextProcessInfoDictionary(a1, 0);
  if (v21 == *(void *)(a1 + 40) && (uint64_t v22 = *(__CFString **)(a1 + 24), CFEqual(v20, v22)))
  {
    *(unsigned char *)(a1 + 88) &= ~4u;
    if (v22 != @"__unknown__")
    {
      if (!v20) {
        return;
      }
      goto LABEL_7;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 88) &= ~4u;
  }
  __OSKextRemoveIdentifierCacheForKext(a1);
  if (!v20) {
    return;
  }
LABEL_7:
  CFRelease(v20);
}

void __OSKextRemoveKextFromIdentifierDict(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(const void **)(a1 + 24);
  if (v9)
  {
    UTF8CStringForCFString = createUTF8CStringForCFString(*(const __CFString **)(a1 + 24));
    if (UTF8CStringForCFString)
    {
      uint64_t v18 = UTF8CStringForCFString;
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a2, v9);
      if (Value)
      {
        CFArrayRef v20 = Value;
        if (Value == (const __CFArray *)a1)
        {
          CFDictionaryRemoveValue(a2, v9);
LABEL_19:
          OSKextVersionGetString(*(void *)(a1 + 40), v36, 0x14u);
          OSKextLog(a1, 262149, "%s, version %s removed from identifier lookup dictionary.", v26, v27, v28, v29, v30, (char)v18);
LABEL_21:
          free(v18);
          return;
        }
        CFTypeID TypeID = CFArrayGetTypeID();
        if (TypeID == CFGetTypeID(v20))
        {
          CFIndex Count = CFArrayGetCount(v20);
          if (Count < 1)
          {
LABEL_10:
            uint64_t v25 = 0;
          }
          else
          {
            CFIndex v23 = Count;
            CFIndex v24 = 0;
            while (CFArrayGetValueAtIndex(v20, v24) != (const void *)a1)
            {
              if (v23 == ++v24) {
                goto LABEL_10;
              }
            }
            CFArrayRemoveValueAtIndex(v20, v24);
            uint64_t v25 = a1;
          }
          if (!CFArrayGetCount(v20))
          {
            CFDictionaryRemoveValue(a2, v9);
            CFRelease(v20);
          }
          if (v25) {
            goto LABEL_19;
          }
        }
      }
      strncmp((const char *)v18, "__unknown__", 0xBuLL);
      OSKextLog(a1, 262151, "%s not found in identifier lookup dictionary%s.", v31, v32, v33, v34, v35, (char)v18);
      goto LABEL_21;
    }
    OSKextLog(0, 17, "Memory allocation failure.", v13, v14, v15, v16, v17, a9);
  }
}

uint64_t __OSKextProcessInfoDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v108 = 0;
  CFTypeRef cf = 0;
  CFBooleanRef BOOLean = 0;
  CFTypeRef cf1 = 0;
  CFDictionaryRef theDict = 0;
  __OSKextRemoveKextFromIdentifierDict(a1, (const __CFDictionary *)__sOSKextsByIdentifier, a3, a4, a5, a6, a7, a8, v98);
  if (!__OSKextReadInfoDictionary(a1, a2))
  {
LABEL_126:
    CFArrayRef v94 = 0;
    goto LABEL_127;
  }
  CFStringRef v16 = (const __CFString *)*MEMORY[0x1E4F1CC60];
  CFDictionaryRef v17 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef TypeID = (const __CFString *)CFStringGetTypeID();
  int v19 = __OSKextCheckProperty(a1, v17, v16, v16, TypeID, (const __CFArray *)__sOSKextPackageTypeValues, 1, 1, 1, (const __CFString **)&cf1, &v108);
  if (v19) {
    BOOL v20 = v108 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (v20)
  {
    int v21 = v19;
    goto LABEL_122;
  }
  CFStringRef v22 = (const __CFString *)*MEMORY[0x1E4F1CFF8];
  CFDictionaryRef v23 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v24 = (const __CFString *)CFStringGetTypeID();
  int v25 = __OSKextCheckProperty(a1, v23, v22, v22, v24, 0, 1, 1, 1, (const __CFString **)&cf, 0);
  int v26 = v25;
  if (v25)
  {
    CFStringRef v27 = (const __CFString *)cf;
    if (cf)
    {
      if (*(void *)(a1 + 24))
      {
        CFRelease(*(CFTypeRef *)(a1 + 24));
        CFStringRef v27 = (const __CFString *)cf;
        *(void *)(a1 + 24) = 0;
        if (!v27)
        {
LABEL_16:
          if (CFStringGetLength(v27) < 64)
          {
            int v26 = 1;
          }
          else
          {
            __OSKextSetDiagnostic(a1, 1, @"CFBundleIdentifier and CFBundleVersion must be < 64 characters.");
            int v26 = 0;
          }
          goto LABEL_19;
        }
      }
      else
      {
        *(void *)(a1 + 24) = 0;
      }
      *(void *)(a1 + 24) = CFRetain(v27);
      CFStringRef v27 = (const __CFString *)cf;
      goto LABEL_16;
    }
  }
  *(void *)(a1 + 24) = @"__unknown__";
LABEL_19:
  CFStringRef v28 = (const __CFString *)*MEMORY[0x1E4F1D020];
  CFDictionaryRef v29 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v30 = (const __CFString *)CFStringGetTypeID();
  int v31 = __OSKextCheckProperty(a1, v29, v28, v28, v30, 0, 1, 1, 0, (const __CFString **)&cf, 0);
  if (v26) {
    BOOL v32 = v31 == 0;
  }
  else {
    BOOL v32 = 1;
  }
  int v33 = !v32;
  uint64_t v34 = -1;
  if (v31 && cf)
  {
    if (CFStringGetLength((CFStringRef)cf) < 64)
    {
      uint64_t v34 = OSKextParseVersionCFString((const __CFString *)cf);
      if (v34 == -1)
      {
        __OSKextAddDiagnostic(a1, 1, @"Info dictionary property value is illegal", v28, 0, v35, v36, v37, v99);
        int v33 = 0;
      }
      *(void *)(a1 + 4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v34;
    }
    else
    {
      __OSKextSetDiagnostic(a1, 1, @"CFBundleIdentifier and CFBundleVersion must be < 64 characters.");
      int v33 = 0;
    }
  }
  CFDictionaryRef v38 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v39 = (const __CFString *)CFStringGetTypeID();
  int v40 = __OSKextCheckProperty(a1, v38, @"OSBundleCompatibleVersion", @"OSBundleCompatibleVersion", v39, 0, 0, 1, 0, (const __CFString **)&cf, 0);
  if (v33) {
    BOOL v41 = v40 == 0;
  }
  else {
    BOOL v41 = 1;
  }
  int v42 = !v41;
  if (v40 && cf)
  {
    uint64_t v43 = OSKextParseVersionCFString((const __CFString *)cf);
    if (v43 == -1) {
      int v42 = 0;
    }
    *(void *)(a1 + 48) = v43;
    if (v43 > v34)
    {
      __OSKextSetDiagnostic(a1, 1, @"Compatible version must be lower than current version.");
      int v42 = 0;
    }
  }
  CFDictionaryRef v44 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v45 = (const __CFString *)CFBooleanGetTypeID();
  int v46 = __OSKextCheckProperty(a1, v44, @"OSBundleIsInterface", @"OSBundleIsInterface", v45, 0, 0, 1, 0, (const __CFString **)&BOOLean, &v108);
  if (v42) {
    BOOL v47 = v46 == 0;
  }
  else {
    BOOL v47 = 1;
  }
  char v48 = !v47;
  if (v108) {
    *(_DWORD *)(a1 + 92) |= 2u;
  }
  if (BOOLean) {
    BOOL v49 = CFBooleanGetValue(BOOLean) == 0;
  }
  else {
    BOOL v49 = 0;
  }
  CFDictionaryRef v50 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v51 = (const __CFString *)CFBooleanGetTypeID();
  if (__OSKextCheckProperty(a1, v50, @"OSKernelResource", @"OSKernelResource", v51, 0, 0, 1, 0, 0, &v108))char v52 = v48; {
  else
  }
    char v52 = 0;
  int v53 = *(_DWORD *)(a1 + 92);
  if (v108)
  {
    v53 |= 1u;
    *(_DWORD *)(a1 + 92) = v53;
  }
  if (v53)
  {
    if (v49)
    {
      __OSKextSetDiagnostic(a1, 8, @"Kext is a kernel component but OSBundleIsInterface is set to false; overriding");
      int v53 = *(_DWORD *)(a1 + 92);
    }
    *(_DWORD *)(a1 + 92) = v53 | 2;
  }
  CFStringRef v54 = (const __CFString *)*MEMORY[0x1E4F1CFF0];
  CFDictionaryRef v55 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v56 = (const __CFString *)CFStringGetTypeID();
  if (__OSKextCheckProperty(a1, v55, v54, v54, v56, 0, 0, 1, 1, 0, &v108)) {
    char v57 = v52;
  }
  else {
    char v57 = 0;
  }
  if (v108)
  {
    if (CFEqual(cf1, @"KEXT"))
    {
      int v58 = 4;
LABEL_72:
      *(_DWORD *)(a1 + 92) |= v58;
      goto LABEL_73;
    }
    if (CFEqual(cf1, @"DEXT"))
    {
      int v58 = 8;
      goto LABEL_72;
    }
    char v57 = 0;
  }
LABEL_73:
  CFDictionaryRef v59 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v60 = (const __CFString *)CFStringGetTypeID();
  if (!__OSKextCheckProperty(a1, v59, @"OSBundleSharedExecutableIdentifier", @"OSBundleSharedExecutableIdentifier", v60, 0, 0, 1, 0, 0, &v108))char v57 = 0; {
  if (v108)
  }
  {
    int v61 = *(_DWORD *)(a1 + 92);
    if ((v61 & 4) != 0)
    {
      __OSKextSetDiagnostic(a1, 1, @"Kext declares both CFBundleExecutable and CFBundleSharedExecutableIdentifier; use only one.");
    }
    else if ((v61 & 8) != 0)
    {
      __OSKextSetDiagnostic(a1, 1, @"CFBundlePackageType is DEXT and bundle declares CFBundleExecutable; use only one.");
      char v57 = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = v61 | 4;
    }
  }
  CFDictionaryRef v62 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v63 = (const __CFString *)CFBooleanGetTypeID();
  if (!__OSKextCheckProperty(a1, v62, @"OSBundleEnableKextLogging", @"OSBundleEnableKextLogging", v63, 0, 0, 1, 0, (const __CFString **)&BOOLean, &v108))char v57 = 0; {
  if (v108)
  }
  {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFEF | (16 * (CFBooleanGetValue(BOOLean) != 0));
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFDF | (32 * (CFBooleanGetValue(BOOLean) != 0));
  }
  if (OSKextGetValueForInfoDictionaryKey(a1, @"OSBundleDebugLevel")) {
    __OSKextAddDiagnostic(a1, 8, @"Deprecated property (ignored)", @"OSBundleDebugLevel", 0, v64, v65, v66, v100);
  }
  CFDictionaryRef v67 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v68 = (const __CFString *)CFStringGetTypeID();
  if (__OSKextCheckProperty(a1, v67, @"OSBundleRequired", @"OSBundleRequired", v68, (const __CFArray *)__sOSKextOSBundleRequiredValues, 0, 1, 0, (const __CFString **)&cf, &v108))char v69 = v57; {
  else
  }
    char v69 = 0;
  if (v108)
  {
    if ((*(unsigned char *)(a1 + 92) & 8) != 0)
    {
      if (CFStringHasPrefix(*(CFStringRef *)(a1 + 24), @"com.apple."))
      {
        if (CFEqual(cf, @"DriverKit") || CFEqual(cf, @"Safe Boot")) {
          goto LABEL_102;
        }
        CFArrayRef v70 = @"Driver Extension lacks appropriate value for OSBundleRequired, and will not be launched without kextd present. Use one of 'DriverKit' or 'Safe Boot.'";
      }
      else
      {
        CFArrayRef v70 = @"Third-party Driver Extensions are ineligible to run in Safe Boot, or match on devices during early boot. Please remove the OSBundleRequired key from your Info.plist.";
      }
    }
    else
    {
      if (!CFEqual(cf, @"DriverKit"))
      {
LABEL_102:
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFF7F | ((v69 & 1) << 7);
        goto LABEL_103;
      }
      CFArrayRef v70 = @"Kexts may not use the DriverKit value for OSBundleRequired.";
    }
    __OSKextSetDiagnostic(a1, 16, v70);
    char v69 = 0;
    goto LABEL_102;
  }
  if (OSKextGetActualSafeBoot() | __sOSKextSimulatedSafeBoot) {
    __OSKextSetDiagnostic(a1, 16, @"Kext isn't loadable during safe boot.");
  }
LABEL_103:
  if ((*(unsigned char *)(a1 + 92) & 8) != 0)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)__sOSKextInfoKextOnlyKeys);
    if (Count >= 1)
    {
      CFIndex v72 = Count;
      CFIndex v73 = 0;
      CFAllocatorRef v74 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)__sOSKextInfoKextOnlyKeys, v73);
        if (OSKextGetValueForInfoDictionaryKey(a1, ValueAtIndex))
        {
          CFStringRef v76 = CFStringCreateWithFormat(v74, 0, @"Driver Extensions may not use the %@ key; please remove.");
          if (!v76)
          {
            OSKextLog(a1, 17, "String/URL conversion failure.", v77, v78, v79, v80, v81, (char)ValueAtIndex);
            goto LABEL_126;
          }
          CFStringRef v82 = v76;
          __OSKextSetDiagnostic(a1, 1, v76);
          CFRelease(v82);
          char v69 = 0;
        }
        ++v73;
      }
      while (v72 != v73);
    }
  }
  CFDictionaryRef v83 = *(const __CFDictionary **)(a1 + 56);
  CFStringRef v84 = (const __CFString *)CFDictionaryGetTypeID();
  int v85 = __OSKextCheckProperty(a1, v83, @"IOKitPersonalities", @"IOKitPersonalities", v84, 0, 0, 1, 0, (const __CFString **)&theDict, &v108);
  if (v69) {
    BOOL v86 = v85 == 0;
  }
  else {
    BOOL v86 = 1;
  }
  int v21 = !v86;
  if (!theDict)
  {
LABEL_122:
    CFArrayRef v94 = 0;
    if (v21) {
      goto LABEL_123;
    }
    goto LABEL_127;
  }
  uint64_t v103 = 0;
  CFAllocatorRef v87 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v87, 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v94 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, @"IOKitPersonalities");
    context[0] = a1;
    context[1] = theDict;
    void context[2] = v94;
    LOWORD(v103) = 257;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateIOKitPersonalityApplierFunction, context);
    if (!(_BYTE)v103) {
      int v21 = 0;
    }
    CFIndex v95 = CFArrayGetCount(v94);
    CFArrayRemoveValueAtIndex(v94, v95 - 1);
    if (!v21) {
      goto LABEL_127;
    }
LABEL_123:
    uint64_t v96 = 1;
    goto LABEL_128;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v89, v90, v91, v92, v93, v101);
LABEL_127:
  uint64_t v96 = 0;
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
LABEL_128:
  __OSKextRecordKextInIdentifierDict((CFMutableArrayRef)a1, (CFDictionaryRef)__sOSKextsByIdentifier, v10, v11, v12, v13, v14, v15);
  if (v94) {
    CFRelease(v94);
  }
  return v96;
}

void __OSKextRemoveIdentifierCacheForKext(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!geteuid())
  {
    if (__OSKextGetFileSystemPath(a1, 0, 1u, (UInt8 *)__s1, v2, v3, v4, v5))
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)__sOSKextSystemExtensionsFolderURLs);
      if (Count >= 1)
      {
        CFIndex v7 = Count;
        CFIndex v8 = 0;
        while (1)
        {
          CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex((CFArrayRef)__sOSKextSystemExtensionsFolderURLs, v8);
          CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, buffer, 1024);
          if (!strncmp(__s1, (const char *)buffer, 0x400uLL)) {
            break;
          }
          if (v7 == ++v8) {
            return;
          }
        }
        OSKextLog(0, 393220, "Removing identifier->path cache %s.", v10, v11, v12, v13, v14, (char)__s1);
        __s1[0] = 0;
        __strlcpy_chk();
        __strlcat_chk();
        __strlcat_chk();
        if (unlink(__s1) && *__error() != 2 && *__error() != 20)
        {
          uint64_t v15 = __error();
          strerror(*v15);
          OSKextLog(0, 131073, "Failed to remove identifier->path cache %s - %s.", v16, v17, v18, v19, v20, (char)__s1);
        }
      }
    }
  }
}

void __OSKextRealizeKextsWithIdentifier(void *key)
{
  if (__sOSKextsByIdentifier)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, key);
    if (Value)
    {
      CFArrayRef v2 = Value;
      CFRetain(Value);
      uint64_t v3 = __kOSKextTypeID;
      if (v3 == CFGetTypeID(v2))
      {
        __OSKextRealize((uint64_t)v2, v4, v5, v6, v7, v8, v9, v10);
      }
      else
      {
        CFTypeID TypeID = CFArrayGetTypeID();
        if (TypeID == CFGetTypeID(v2) && CFArrayGetCount(v2))
        {
          v13.CFIndex length = CFArrayGetCount(v2);
          v13.location = 0;
          CFArrayApplyFunction(v2, v13, (CFArrayApplierFunction)__OSKextRealize, 0);
        }
      }
      CFRelease(v2);
    }
  }
}

CFURLRef __OSKextCreateCacheFileURL(const void *a1, uint64_t a2, const char **a3, int a4)
{
  CFTypeID v8 = CFGetTypeID(a1);
  CFTypeID v9 = CFURLGetTypeID();
  if (v8 == v9)
  {
    CFURLRef v10 = _CFURLCopyAbsolutePath((const __CFURL *)a1);
    if (!v10)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v11, v12, v13, v14, v15, v36);
      return 0;
    }
    uint64_t v16 = (__CFString *)v10;
    if (!__OSKextURLIsSystemFolder((const __CFURL *)a1))
    {
      OSKextLogCFString(0, 262148, @"%@ is not a system extensions folder; not looking for a cache.",
        v17,
        v18,
        v19,
        v20,
        v21,
        (char)v16);
      CFStringRef v34 = 0;
      CFURLRef v23 = 0;
      goto LABEL_24;
    }
    CFStringRef v22 = v16;
  }
  else
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    uint64_t v16 = 0;
    if ((const void *)__sOSKextSystemExtensionsFolderURLs != a1) {
      return 0;
    }
    CFStringRef v22 = &stru_1ED870660;
  }
  CFStringRef v24 = "";
  int v25 = "";
  if ((a4 - 1) <= 2) {
    int v25 = off_1E548AB20[a4 - 1];
  }
  CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v27 = "Startup";
  if (v8 == v9) {
    CFStringRef v27 = "Directories";
  }
  CFStringRef v28 = "_";
  if (a3) {
    CFStringRef v24 = *a3;
  }
  else {
    CFStringRef v28 = "";
  }
  CFStringRef v34 = CFStringCreateWithFormat(v26, 0, @"%s/%s%@/%@%s%s%s", "/System/Library/Caches/com.apple.kext.caches", v27, v22, a2, v28, v24, v25);
  if (!v34 || (CFURLRef v23 = CFURLCreateWithFileSystemPath(v26, v34, kCFURLPOSIXPathStyle, 0)) == 0)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v29, v30, v31, v32, v33, v37);
    CFURLRef v23 = 0;
  }
  if (v16)
  {
LABEL_24:
    CFRelease(v16);
    if (!v34) {
      return v23;
    }
    goto LABEL_21;
  }
  if (v34) {
LABEL_21:
  }
    CFRelease(v34);
  return v23;
}

CFURLRef _CFURLCopyAbsolutePath(const __CFURL *a1)
{
  CFURLRef result = CFURLCopyAbsoluteURL(a1);
  if (result)
  {
    CFURLRef v2 = result;
    CFStringRef v3 = CFURLCopyFileSystemPath(result, kCFURLPOSIXPathStyle);
    CFRelease(v2);
    return (const __CFURL *)v3;
  }
  return result;
}

BOOL __OSKextURLIsSystemFolder(const __CFURL *a1)
{
  CFURLRef v1 = CFURLCopyAbsoluteURL(a1);
  if (v1)
  {
    CFURLRef v7 = v1;
    CFArrayRef v8 = (const __CFArray *)__sOSKextSystemExtensionsFolderURLs;
    v12.CFIndex length = CFArrayGetCount((CFArrayRef)__sOSKextSystemExtensionsFolderURLs);
    v12.location = 0;
    BOOL v9 = CFArrayGetFirstIndexOfValue(v8, v12, v7) != -1;
    CFRelease(v7);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v2, v3, v4, v5, v6, v11);
    return 0;
  }
  return v9;
}

void OSKextLogCFString(uint64_t a1, int a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t __OSKextCheckURL(const __CFURL *a1, int a2)
{
  *(void *)&v44[1023] = *MEMORY[0x1E4F143B8];
  bzero(&buffer, 0x400uLL);
  memset(&v41, 0, sizeof(v41));
  uint64_t result = __OSKextGetFileSystemPath(0, a1, 1u, &buffer, v4, v5, v6, v7);
  if (!result) {
    return result;
  }
  if (buffer != 47)
  {
    OSKextLog(0, 17, "Internal error, invalid argument to __OSKextCheckURL.", v9, v10, v11, v12, v13, v40);
    return 0;
  }
  if (a2)
  {
    memset(&v42, 0, 512);
    if (!statfs((const char *)&buffer, &v42) && (v42.f_flags & 1) != 0)
    {
      OSKextLogCFString(0, 131076, @"Not saving %s - read-only filesystem.", v14, v15, v16, v17, v18, (char)&buffer);
      return 0;
    }
  }
  for (CFIndex i = &buffer; ; CFIndex i = (UInt8 *)index(v27, 47))
  {
    if (i == &buffer)
    {
      p_UInt8 buffer = "/";
    }
    else
    {
      if (i) {
        *CFIndex i = 0;
      }
      p_UInt8 buffer = (const char *)&buffer;
    }
    if (stat(p_buffer, &v41))
    {
      if (*__error() != 2)
      {
        CFStringRef v28 = __error();
        strerror(*v28);
        OSKextLog(0, 131073, "Can't stat path %s - %s.", v29, v30, v31, v32, v33, (char)p_buffer);
        goto LABEL_34;
      }
      if (!a2) {
        goto LABEL_34;
      }
      if (mkdir((const char *)&buffer, 0x1EDu) && *__error() != 17) {
        break;
      }
    }
    if (v41.st_uid)
    {
      OSKextLog(0, 131073, "Can't create kext cache under %s - owner not root.", v21, v22, v23, v24, v25, (char)p_buffer);
      goto LABEL_34;
    }
    if ((v41.st_mode & 0xF000) != 0x4000 && v41.st_gid != 0)
    {
      OSKextLog(0, 131073, "Can't create kext cache under %s - group not wheel.", v21, v22, v23, v24, v25, (char)p_buffer);
      goto LABEL_34;
    }
    if (!i) {
      return 1;
    }
    CFStringRef v27 = v44;
    if (i != &buffer)
    {
      *CFIndex i = 47;
      CFStringRef v27 = (const char *)(i + 1);
    }
  }
  CFStringRef v34 = __error();
  strerror(*v34);
  OSKextLog(0, 131073, "Failed to create directory %s - %s.", v35, v36, v37, v38, v39, (char)p_buffer);
LABEL_34:
  uint64_t result = 0;
  if (i)
  {
    if (i != &buffer)
    {
      uint64_t result = 0;
      *CFIndex i = 47;
    }
  }
  return result;
}

uint64_t _OSKextCreateFolderForCacheURL(CFURLRef url)
{
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], url);
  if (PathComponent)
  {
    CFURLRef v7 = PathComponent;
    uint64_t v8 = __OSKextCheckURL(PathComponent, 1);
    CFRelease(v7);
    return v8;
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v2, v3, v4, v5, v6, v10);
    return 0;
  }
}

uint64_t __OSKextStatURL(CFURLRef url, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2) {
    *a2 = 0;
  }
  memset(&v22, 0, sizeof(v22));
  uint64_t result = __OSKextGetFileSystemPath(0, url, 1u, buffer, a5, a6, a7, a8);
  if (!result)
  {
LABEL_13:
    if (!a3) {
      return result;
    }
    goto LABEL_14;
  }
  if (!stat((const char *)buffer, &v22))
  {
    uint64_t result = 1;
    if (!a3) {
      return result;
    }
    goto LABEL_14;
  }
  if (*__error() == 2)
  {
    if (!a2) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  uint64_t v11 = __error();
  if (a2 && *v11 == 20)
  {
LABEL_12:
    uint64_t result = 0;
    *a2 = 1;
    goto LABEL_13;
  }
LABEL_16:
  uint64_t v16 = __error();
  strerror(*v16);
  OSKextLogCFString(0, 131073, @"Can't stat %s - %s.", v17, v18, v19, v20, v21, (char)buffer);
  uint64_t result = 0;
  if (!a3) {
    return result;
  }
LABEL_14:
  long long v12 = *(_OWORD *)&v22.st_blksize;
  *(_OWORD *)(a3 + 96) = *(_OWORD *)&v22.st_size;
  *(_OWORD *)(a3 + 112) = v12;
  *(_OWORD *)(a3 + 128) = *(_OWORD *)v22.st_qspare;
  timespec st_mtimespec = v22.st_mtimespec;
  *(timespec *)(a3 + 32) = v22.st_atimespec;
  *(timespec *)(a3 + 48) = st_mtimespec;
  timespec st_birthtimespec = v22.st_birthtimespec;
  *(timespec *)(a3 + 64) = v22.st_ctimespec;
  *(timespec *)(a3 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = st_birthtimespec;
  long long v15 = *(_OWORD *)&v22.st_uid;
  *(_OWORD *)a3 = *(_OWORD *)&v22.st_dev;
  *(_OWORD *)(a3 + 16) = v15;
  return result;
}

__n128 __OSKextStatURLsOrURL(const void *a1, unsigned char *a2, uint64_t a3)
{
  char v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  __n128 v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  __n128 v28 = 0u;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFURLGetTypeID())
  {
    __OSKextStatURL((CFURLRef)a1, a2, (uint64_t)&v27, v7, v8, v9, v10, v11);
    goto LABEL_19;
  }
  CFTypeID v13 = CFGetTypeID(a1);
  if (v13 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count < 1)
    {
      CFIndex v15 = 0;
      if (!a2) {
        goto LABEL_19;
      }
    }
    else
    {
      CFIndex v15 = 0;
      CFIndex v16 = 0;
      if (a2) {
        uint64_t v17 = &v45;
      }
      else {
        uint64_t v17 = 0;
      }
      do
      {
        CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex((CFArrayRef)a1, v16);
        if (__OSKextStatURL(ValueAtIndex, v17, (uint64_t)&v36, v19, v20, v21, v22, v23))
        {
          ++v15;
          if (!v16 || (uint64_t)v39 > (uint64_t)v30)
          {
            long long v33 = v42;
            long long v34 = v43;
            long long v35 = v44;
            long long v29 = v38;
            long long v30 = v39;
            long long v31 = v40;
            long long v32 = v41;
            result.n128_u64[0] = v37.n128_u64[0];
            long long v27 = v36;
            __n128 v28 = v37;
          }
        }
        ++v16;
      }
      while (Count != v16);
      if (!a2) {
        goto LABEL_19;
      }
    }
    if (v15 < Count) {
      *a2 = 1;
    }
  }
LABEL_19:
  if (a3)
  {
    long long v24 = v34;
    *(_OWORD *)(a3 + 96) = v33;
    *(_OWORD *)(a3 + 112) = v24;
    *(_OWORD *)(a3 + 128) = v35;
    long long v25 = v30;
    *(_OWORD *)(a3 + 32) = v29;
    *(_OWORD *)(a3 + 48) = v25;
    long long v26 = v32;
    *(_OWORD *)(a3 + 64) = v31;
    *(_OWORD *)(a3 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v26;
    __n128 result = v28;
    *(_OWORD *)a3 = v27;
    *(__n128 *)(a3 + 16) = result;
  }
  return result;
}

uint64_t _OSKextWriteCache(const void *a1, uint64_t a2, const char **a3, int a4, const void *a5)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  bzero(&__from, 0x400uLL);
  bzero(&__to, 0x400uLL);
  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  long long v131 = 0u;
  long long v132 = 0u;
  memset(v130, 0, sizeof(v130));
  CFTypeID v10 = CFGetTypeID(a1);
  if (v10 == CFURLGetTypeID())
  {
    CFURLRef v11 = CFURLCopyAbsoluteURL((CFURLRef)a1);
    if (!v11)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, (char)p_from);
      return 0;
    }
    CFURLRef v17 = v11;
    CFURLRef v23 = _CFURLCopyAbsolutePath((const __CFURL *)a1);
    if (!v23)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v18, v19, v20, v21, v22, (char)p_from);
      uint64_t v24 = 0;
      CFURLRef CacheFileURL = 0;
      long long v26 = 0;
      CFDataRef v27 = 0;
LABEL_16:
      CFRelease(v17);
      goto LABEL_17;
    }
  }
  else
  {
    CFURLRef v17 = 0;
    CFURLRef v23 = 0;
  }
  CFURLRef CacheFileURL = __OSKextCreateCacheFileURL(a1, a2, a3, a4);
  if (!CacheFileURL) {
    goto LABEL_14;
  }
  if (!__OSKextGetFileSystemPath(0, CacheFileURL, 1u, (UInt8 *)&__to, v28, v29, v30, v31))
  {
    __n128 v37 = "String/URL conversion failure.";
    goto LABEL_13;
  }
  OSKextLog(0, 393220, "Saving cache file %s.", v32, v33, v34, v35, v36, (char)&__to);
  if (!_OSKextCreateFolderForCacheURL(CacheFileURL))
  {
LABEL_14:
    CFDataRef v27 = 0;
    long long v26 = 0;
    goto LABEL_15;
  }
  __strlcpy_chk();
  if ((unint64_t)__strlcat_chk() >= 0x401)
  {
    p_from = &__from;
    __n128 v37 = "Temp cache file name too long: %s.";
LABEL_13:
    OSKextLog(0, 17, v37, v32, v33, v34, v35, v36, (char)p_from);
    goto LABEL_14;
  }
  int v39 = mkstemp((char *)&__from);
  if (v39 == -1)
  {
    CFStringRef v54 = __error();
    strerror(*v54);
    OSKextLog(0, 131073, "Can't create %s - %s.", v55, v56, v57, v58, v59, (char)&__from);
    goto LABEL_14;
  }
  int v40 = v39;
  mode_t v41 = umask(0);
  umask(v41);
  if (fchmod(v40, ~v41 & 0x1A4) == -1)
  {
    CFStringRef v60 = __error();
    strerror(*v60);
    OSKextLog(0, 131073, "Failed to set permissions for %s - %s.", v61, v62, v63, v64, v65, (char)&__from);
    long long v26 = 0;
LABEL_54:
    CFDataRef v27 = 0;
    goto LABEL_56;
  }
  if ((a4 - 1) > 1)
  {
    CFDataRef v27 = IOCFSerialize(a5, 0);
    long long v26 = 0;
    goto LABEL_37;
  }
  long long v42 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  long long v26 = v42;
  if (!v42)
  {
    OSKextLog(0, 262145, "Can't create CFWriteStream to save cache %s.", v43, v44, v45, v46, v47, (char)&__to);
    goto LABEL_54;
  }
  if (a4 == 1) {
    CFPropertyListFormat v48 = kCFPropertyListBinaryFormat_v1_0;
  }
  else {
    CFPropertyListFormat v48 = kCFPropertyListXMLFormat_v1_0;
  }
  CFWriteStreamOpen(v42);
  CFPropertyListWriteToStream(a5, v26, v48, 0);
  CFWriteStreamClose(v26);
  CFDataRef v27 = (const __CFData *)CFWriteStreamCopyProperty(v26, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
LABEL_37:
  if (!v27)
  {
    OSKextLog(0, 262145, "Failed to serialize data for cache %s.", v49, v50, v51, v52, v53, (char)&__to);
LABEL_56:
    close(v40);
LABEL_57:
    p_to = &__from;
    goto LABEL_58;
  }
  BytePtr = CFDataGetBytePtr(v27);
  CFIndex Length = CFDataGetLength(v27);
  if (!BytePtr)
  {
    OSKextLog(0, 17, "Unable to get data to create cache file %s.", v68, v69, v70, v71, v72, (char)&__to);
    goto LABEL_56;
  }
  uint64_t v73 = Length;
  *__error() = 0;
  gzFile v74 = gzdopen(v40, "w");
  if (!v74)
  {
    uint64_t v93 = __error();
    strerror(*v93);
    OSKextLog(0, 131073, "Failed to open compression stream for %s - %s.", v94, v95, v96, v97, v98, (char)&__to);
    goto LABEL_56;
  }
  CFStringRef v75 = v74;
  if (v73 >= 1)
  {
    uint64_t v76 = 0;
    while (1)
    {
      *__error() = 0;
      unsigned int v77 = gzwrite(v75, &BytePtr[v76], v73 - v76);
      if ((v77 & 0x80000000) != 0) {
        break;
      }
      v76 += v77;
      if (v76 >= v73) {
        goto LABEL_44;
      }
    }
    CFNumberRef v105 = __error();
    strerror(*v105);
    OSKextLog(0, 131073, "Compressed write error for cache file %s - %s.", v106, v107, v108, v109, v110, (char)&__to);
    p_to = &__from;
    if (gzclose(v75))
    {
      CFStringRef v111 = __error();
      strerror(*v111);
      OSKextLog(0, 131073, "Failed to close compression stream for %s - %s.", v112, v113, v114, v115, v116, (char)&__from);
    }
    goto LABEL_58;
  }
LABEL_44:
  *__error() = 0;
  if (gzclose(v75))
  {
    uint64_t v79 = __error();
    strerror(*v79);
    OSKextLog(0, 131073, "Failed to close compression stream for %s - %s.", v80, v81, v82, v83, v84, (char)&__from);
  }
  rename(&__from, &__to, v78);
  if (v85 == -1)
  {
    CFAllocatorRef v117 = __error();
    strerror(*v117);
    OSKextLog(0, 131073, "Can't rename temp cache file to %s - %s.", v118, v119, v120, v121, v122, (char)&__to);
    goto LABEL_57;
  }
  __OSKextStatURLsOrURL(a1, 0, (uint64_t)v130);
  if (!v86)
  {
    p_to = &__to;
LABEL_58:
    if (unlink((const char *)p_to) == -1)
    {
      char v99 = __error();
      strerror(*v99);
      OSKextLog(0, 131073, "Failed to remove temp cache file %s - %s.", v100, v101, v102, v103, v104, (char)p_to);
    }
    goto LABEL_15;
  }
  v137.__darwin_time_t tv_sec = v131 + 1;
  v137.tv_usec = 0;
  uint64_t v138 = v131 + 1;
  int v139 = 0;
  p_to = &__to;
  if (utimes((const char *)&__to, &v137) != -1)
  {
    OSKextLog(0, 393220, "Saved cache file %s.", v88, v89, v90, v91, v92, (char)&__to);
    uint64_t v24 = 1;
    if (!v17) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  v123 = __error();
  strerror(*v123);
  OSKextLog(0, 131073, "Can't update mod time of cache file %s - %s.", v124, v125, v126, v127, v128, (char)&__to);
  if (*__error() != 2) {
    goto LABEL_58;
  }
LABEL_15:
  uint64_t v24 = 0;
  if (v17) {
    goto LABEL_16;
  }
LABEL_17:
  if (v23) {
    CFRelease(v23);
  }
  if (CacheFileURL) {
    CFRelease(CacheFileURL);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v26) {
    CFRelease(v26);
  }
  return v24;
}

uint64_t __OSKextCacheNeedsUpdate(const __CFURL *a1, const void *a2)
{
  char v38 = 0;
  CFURLRef v4 = _CFURLCopyAbsolutePath(a1);
  if (v4)
  {
    CFURLRef v10 = v4;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    memset(v22, 0, sizeof(v22));
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    if (__OSKextStatURL(a1, &v38, (uint64_t)&v29, v5, v6, v7, v8, v9))
    {
      if ((SWORD2(v29) & 0x80000000) == 0)
      {
        OSKextLogCFString(0, 393220, @"Cache file %@ is not a regular file; ignoring.",
          v11,
          v12,
          v13,
          v14,
          v15,
          (char)v10);
LABEL_9:
        uint64_t v16 = 1;
LABEL_10:
        CFRelease(v10);
        return v16;
      }
      if (!__OSKextCheckURL(a1, 0)) {
        goto LABEL_9;
      }
      if (v30)
      {
        char v21 = (char)v10;
        CFStringRef v18 = @"Cache file %@ - owner not root; not using.";
      }
      else if (DWORD1(v30))
      {
        char v21 = (char)v10;
        CFStringRef v18 = @"Cache file %@ - group not wheel; not using.";
      }
      else if ((WORD2(v29) & 0x1FF) == 0x1A4)
      {
        __OSKextStatURLsOrURL(a2, &v38, (uint64_t)v22);
        if (v20)
        {
          if ((void)v32 == (void)v23 + 1)
          {
            uint64_t v16 = 0;
            goto LABEL_10;
          }
          char v21 = (char)v10;
          CFStringRef v18 = @"Cache file %@ is out of date; not using.";
        }
        else
        {
          char v21 = (char)v10;
          CFStringRef v18 = @"Can't stat source folders for cache file %@.";
        }
      }
      else
      {
        char v21 = (char)v10;
        CFStringRef v18 = @"Cache file %@ - wrong permissions (%#o, should be %#o); not using.";
      }
      int v17 = 393218;
    }
    else
    {
      if (!v38) {
        goto LABEL_9;
      }
      int v17 = 393223;
      char v21 = (char)v10;
      CFStringRef v18 = @"Cache file %@ does not exist.";
    }
    OSKextLogCFString(0, v17, v18, v11, v12, v13, v14, v15, v21);
    goto LABEL_9;
  }
  return 1;
}

uint64_t _OSKextWriteIdentifierCacheForKextsInDirectory(const __CFArray *a1, const void *a2, int a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  int valuePtr = 0;
  bzero(__s, 0x400uLL);
  if (!(__sOSKextUsesCaches | a3)) {
    return 0;
  }
  if (geteuid())
  {
    OSKextLog(0, 262148, "Not running as root; skipping save of identifier->path cache.", v6, v7, v8, v9, v10, v38);
    return 0;
  }
  CFURLRef CacheFileURL = __OSKextCreateCacheFileURL(a2, @"KextIdentifiers", 0, 2);
  if (!CacheFileURL) {
    return 0;
  }
  CFURLRef v14 = CacheFileURL;
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, v38);
    CFRelease(v14);
    return 0;
  }
  uint64_t v22 = Mutable;
  if (__OSKextGetFileSystemPath(0, (CFURLRef)a2, 1u, (UInt8 *)__s, v18, v19, v20, v21))
  {
    size_t v23 = strlen(__s);
    CFStringRef v29 = CFStringCreateWithBytes(v15, (const UInt8 *)__s, v23, 0x8000100u, 0);
    if (v29)
    {
      CFDictionarySetValue(v22, @"OSKextIdentifierCacheBasePath", v29);
      CFMutableArrayRef v30 = CFArrayCreateMutable(v15, 0, MEMORY[0x1E4F1D510]);
      if (v30)
      {
        long long v31 = v30;
        CFDictionarySetValue(v22, @"OSKextIdentifierCacheKextInfo", v30);
        int valuePtr = 2;
        CFNumberRef v32 = CFNumberCreate(v15, kCFNumberSInt32Type, &valuePtr);
        CFDictionarySetValue(v22, @"OSKextIdentifierCacheVersion", v32);
        CFIndex Count = CFArrayGetCount(a1);
        if (Count < 1)
        {
          CFURLRef IdentifierCacheDict = 0;
        }
        else
        {
          CFIndex v34 = Count;
          CFIndex v35 = 0;
          CFURLRef IdentifierCacheDict = 0;
          do
          {
            if (IdentifierCacheDict) {
              CFRelease(IdentifierCacheDict);
            }
            CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v35);
            CFURLRef IdentifierCacheDict = __OSKextCreateIdentifierCacheDict((uint64_t)ValueAtIndex, v29);
            if (IdentifierCacheDict) {
              CFArrayAppendValue(v31, IdentifierCacheDict);
            }
            ++v35;
          }
          while (v34 != v35);
        }
        uint64_t v11 = _OSKextWriteCache(a2, @"KextIdentifiers", 0, 2, v22);
        goto LABEL_25;
      }
    }
    OSKextLog(0, 17, "Memory allocation failure.", v24, v25, v26, v27, v28, v38);
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 0;
    CFStringRef v29 = 0;
  }
  CFNumberRef v32 = 0;
  long long v31 = 0;
  CFURLRef IdentifierCacheDict = 0;
LABEL_25:
  CFRelease(v14);
  CFRelease(v22);
  if (v31) {
    CFRelease(v31);
  }
  if (IdentifierCacheDict) {
    CFRelease(IdentifierCacheDict);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v29) {
    CFRelease(v29);
  }
  return v11;
}

CFURLRef __OSKextCreateIdentifierCacheDict(uint64_t a1, const __CFString *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v43);
    return 0;
  }
  uint64_t v11 = Mutable;
  CFURLRef v12 = CFURLCopyAbsoluteURL(*(CFURLRef *)(a1 + 16));
  CFURLRef v18 = v12;
  if (!v12)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v13, v14, v15, v16, v17, v43);
    long long v31 = v11;
LABEL_20:
    CFRelease(v31);
    return v18;
  }
  CFStringRef v19 = CFURLCopyFileSystemPath(v12, kCFURLPOSIXPathStyle);
  CFStringRef v25 = v19;
  if (!v19) {
    goto LABEL_6;
  }
  if (CFStringHasPrefix(v19, a2))
  {
    CFIndex Length = CFStringGetLength(v25);
    CFIndex v27 = CFStringGetLength(a2) + 1;
    CFAllocatorRef v28 = CFGetAllocator((CFTypeRef)a1);
    v47.CFIndex length = Length - v27;
    v47.location = v27;
    CFStringRef v29 = CFStringCreateWithSubstring(v28, v25, v47);
    CFStringRef v30 = v29;
    if (!v29)
    {
LABEL_6:
      OSKextLog(0, 17, "Memory allocation failure.", v20, v21, v22, v23, v24, v43);
      CFStringRef v29 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    CFStringGetCString(v25, buffer, 1024, 0x8000100u);
    CFStringGetCString(a2, v44, 1024, 0x8000100u);
    OSKextLog(a1, 262150, "%s not in base path %s for identifier->path cache - marking.", v32, v33, v34, v35, v36, (char)buffer);
    CFDictionarySetValue(v11, @"OSBundleUsesAbsolutePath", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFStringRef v29 = 0;
    CFStringRef v30 = v25;
  }
  CFDictionarySetValue(v11, @"OSBundlePath", v30);
  long long v37 = *(const void **)(a1 + 24);
  if (!v37
    || (CFDictionarySetValue(v11, (const void *)*MEMORY[0x1E4F1CFF8], v37),
        char v38 = (const void *)*MEMORY[0x1E4F1D020],
        (CFDictionaryRef ValueForInfoDictionaryKey = OSKextGetValueForInfoDictionaryKey(a1, (const __CFString *)*MEMORY[0x1E4F1D020])) == 0)
    || (CFDictionarySetValue(v11, v38, ValueForInfoDictionaryKey),
        int v40 = (const void *)*MEMORY[0x1E4F1CC60],
        (uint64_t v41 = OSKextGetValueForInfoDictionaryKey(a1, (const __CFString *)*MEMORY[0x1E4F1CC60])) == 0))
  {
LABEL_16:
    CFRelease(v11);
    CFRelease(v18);
    uint64_t v11 = 0;
    CFURLRef v18 = 0;
    if (!v25) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  CFDictionarySetValue(v11, v40, v41);
  if ((*(unsigned char *)(a1 + 92) & 0x10) != 0) {
    CFDictionarySetValue(v11, @"OSBundleEnableKextLogging", (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  CFRelease(v18);
LABEL_17:
  CFRelease(v25);
  CFURLRef v18 = v11;
LABEL_18:
  if (v29)
  {
    long long v31 = v29;
    goto LABEL_20;
  }
  return v18;
}

CFTypeRef OSKextCreateWithIdentifier(const __CFAllocator *a1, void *a2)
{
  values = a2;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef v4 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  if (!v4)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v42);
    return 0;
  }
  CFArrayRef v11 = v4;
  CFDictionaryRef v12 = (const __CFDictionary *)OSKextCopyLoadedKextInfo((unint64_t)v4, (const void *)__sOSKextInfoEssentialKeys, v5, v6, v7, v8, v9, v10);
  CFDictionaryRef v13 = v12;
  if (!v12 || (CFTypeID v14 = CFGetTypeID(v12), v14 != CFDictionaryGetTypeID()))
  {
    CFDictionaryRef v16 = 0;
LABEL_16:
    CFURLRef v36 = 0;
    CFStringRef v19 = 0;
    UTF8CStringForCFString = 0;
    uint64_t v24 = -1;
    goto LABEL_17;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v13, values);
  CFDictionaryRef v16 = Value;
  if (!Value) {
    goto LABEL_16;
  }
  CFTypeID v17 = CFGetTypeID(Value);
  if (v17 != CFDictionaryGetTypeID()) {
    goto LABEL_16;
  }
  CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(v16, @"OSBundlePath");
  if (!v18 || (CFStringRef v19 = v18, v20 = CFGetTypeID(v18), v20 != CFStringGetTypeID())) {
    CFStringRef v19 = 0;
  }
  CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x1E4F1D020]);
  if (!v21 || (CFStringRef v22 = v21, v23 = CFGetTypeID(v21), v23 != CFStringGetTypeID())) {
    CFStringRef v22 = 0;
  }
  uint64_t v24 = OSKextParseVersionCFString(v22);
  if (v19)
  {
    UTF8CStringForCFString = createUTF8CStringForCFString(v19);
    OSKextLog(0, 262151, "Creating kext with path %s.", v26, v27, v28, v29, v30, (char)UTF8CStringForCFString);
    CFURLRef v36 = CFURLCreateWithFileSystemPath(v3, v19, kCFURLPOSIXPathStyle, 1u);
    if (!v36)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v31, v32, v33, v34, v35, v43);
      CFTypeRef v40 = 0;
      CFStringRef v19 = 0;
      KextsFromURLs = 0;
      if (!UTF8CStringForCFString) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    CFStringRef v19 = (const __CFString *)OSKextCreate((uint64_t)a1, v36);
  }
  else
  {
    CFURLRef v36 = 0;
    UTF8CStringForCFString = 0;
  }
LABEL_17:
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  KextsFromURLs = OSKextCreateKextsFromURLs(a1, (const __CFArray *)__sOSKextSystemExtensionsFolderURLs);
  if (v24 != -1 && (KextWithIdentifierAndVersion = OSKextGetKextWithIdentifierAndVersion(values, v24)) != 0
    || (KextWithIdentifierAndVersion = OSKextGetKextWithIdentifier(values)) != 0)
  {
    CFTypeRef v39 = CFRetain(KextWithIdentifierAndVersion);
    CFTypeRef v40 = v39;
    if (v16 && v39)
    {
      __OSKextProcessLoadInfo((int)v39, v16);
      if (!UTF8CStringForCFString) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
  }
  else
  {
    CFTypeRef v40 = 0;
  }
  if (UTF8CStringForCFString) {
LABEL_27:
  }
    free(UTF8CStringForCFString);
LABEL_28:
  CFRelease(v11);
  if (v13) {
    CFRelease(v13);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (KextsFromURLs) {
    CFRelease(KextsFromURLs);
  }
  return v40;
}

CFTypeRef OSKextCopyLoadedKextInfo(unint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef theDict = 0;
  CFTypeRef cf = 0;
  OSKextLog(0, 69, "Reading loaded kext info from kernel.", a4, a5, a6, a7, a8, v34);
  uint64_t v10 = __OSKextCreateKextRequest(@"Get Loaded Kext Info", a1, &theDict);
  if (a2 && CFArrayGetCount((CFArrayRef)a2)) {
    CFDictionarySetValue(theDict, @"Kext Request Info Keys", a2);
  }
  mach_error_t v11 = __OSKextSendKextRequest(0, v10, &cf, 0, 0);
  if (v11)
  {
    CFTypeID v17 = mach_error_string(v11);
    CFTypeID v23 = "(unknown)";
    if (v17) {
      LOBYTE(v23) = (_BYTE)v17;
    }
    OSKextLog(0, 65, "Failed to read loaded kext info from kernel - %s.", v18, v19, v20, v21, v22, (char)v23);
    if (cf) {
      CFRelease(cf);
    }
    CFStringForPlist_new = 0;
    UTF8CStringForCFString = 0;
    CFTypeRef cf = 0;
    goto LABEL_20;
  }
  if (!cf)
  {
    uint64_t v32 = "Kernel request call returned no data.";
LABEL_19:
    OSKextLog(0, 65, v32, v12, v13, v14, v15, v16, v35);
    CFStringForPlist_new = 0;
    UTF8CStringForCFString = 0;
    goto LABEL_20;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(cf))
  {
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
    uint64_t v32 = "Loaded kext info from kernel is wrong type.";
    goto LABEL_19;
  }
  CFStringForPlist_new = 0;
  UTF8CStringForCFString = 0;
  if ((~__sUserLogFilter & 7) == 0 && (__sUserLogFilter & 0x60) != 0)
  {
    CFStringForPlist_new = createCFStringForPlist_new(cf, 1);
    UTF8CStringForCFString = createUTF8CStringForCFString(CFStringForPlist_new);
    OSKextLog(0, 103, "Loaded kext info:\n%s", v27, v28, v29, v30, v31, (char)UTF8CStringForCFString);
  }
LABEL_20:
  if (v10) {
    CFRelease(v10);
  }
  if (CFStringForPlist_new) {
    CFRelease(CFStringForPlist_new);
  }
  if (UTF8CStringForCFString) {
    free(UTF8CStringForCFString);
  }
  return cf;
}

void *OSKextGetKextWithIdentifierAndVersion(void *a1, uint64_t a2)
{
  if (!__sOSKextsByIdentifier) {
    return 0;
  }
  __OSKextRealizeKextsWithIdentifier(a1);
  __n128 result = CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  uint64_t v6 = __kOSKextTypeID;
  if (v6 == CFGetTypeID(result))
  {
    if (v5[5] == a2) {
      return v5;
    }
    else {
      return 0;
    }
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v5)) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)v5);
  if (Count < 1) {
    return 0;
  }
  CFIndex v9 = Count;
  for (CFIndex i = 0; i != v9; ++i)
  {
    __n128 result = CFArrayGetValueAtIndex((CFArrayRef)v5, i);
    if (result[5] == a2) {
      break;
    }
    __n128 result = 0;
  }
  return result;
}

void __OSKextProcessLoadInfo(int a1, CFDictionaryRef theDict)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  long long v32 = *(_OWORD *)"(unknown)";
  int v33 = 0;
  CFDictionaryRef Value = (__CFString *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1CFF8]);
  CFStringRef v4 = Value;
  if (!Value)
  {
    CFURLRef ValueAtIndex = 0;
    CFArrayRef v5 = 0;
LABEL_17:
    UTF8CStringForCFString = 0;
    goto LABEL_20;
  }
  CFArrayRef v5 = OSKextCopyKextsWithIdentifier(Value);
  if (!v5)
  {
    CFURLRef ValueAtIndex = 0;
    goto LABEL_17;
  }
  UTF8CStringForCFString = createUTF8CStringForCFString(v4);
  CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F1D020]);
  if (!v7)
  {
    OSKextLog(0, 97, "Kernel load info for %s lacks a CFBundleVersion.", v8, v9, v10, v11, v12, (char)UTF8CStringForCFString);
    goto LABEL_19;
  }
  unint64_t v13 = OSKextParseVersionCFString(v7);
  OSKextVersionGetString(v13, &v32, 0x14u);
  CFIndex Count = CFArrayGetCount(v5);
  if (Count < 1)
  {
LABEL_19:
    CFURLRef ValueAtIndex = 0;
    goto LABEL_20;
  }
  CFIndex v15 = Count;
  CFIndex v16 = 0;
  int v17 = 0;
  while (1)
  {
    CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v5, v16);
    if (!__OSKextCreateLoadInfo((uint64_t)ValueAtIndex)) {
      break;
    }
    __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 0, buffer, v20, v21, v22, v23);
    OSKextVersionGetString(ValueAtIndex[5], v34, 0x14u);
    uint64_t v24 = ValueAtIndex[9];
    if (v13 == ValueAtIndex[5])
    {
      CFStringRef v25 = *(const void **)(v24 + 8);
      if (v25)
      {
        CFRelease(v25);
        uint64_t v24 = ValueAtIndex[9];
      }
      *(void *)(v24 + 8) = 0;
      *(void *)(ValueAtIndex[9] + 8) = CFRetain(theDict);
      int v17 = 1;
    }
    else
    {
      *(_WORD *)(v24 + 168) |= 0x200u;
    }
    if (v15 == ++v16)
    {
      if (v17) {
        goto LABEL_22;
      }
      goto LABEL_20;
    }
  }
  OSKextLog(0, 17, "Memory allocation failure.", v19, v20, v21, v22, v23, v31);
  if (v17) {
    goto LABEL_22;
  }
LABEL_20:
  if (!CFEqual(v4, @"__kernel__")) {
    OSKextLog((uint64_t)ValueAtIndex, 102, "For loaded kext %s, v%s: no opened kext matches.", v26, v27, v28, v29, v30, (char)UTF8CStringForCFString);
  }
LABEL_22:
  if (UTF8CStringForCFString) {
    free(UTF8CStringForCFString);
  }
  if (v5) {
    CFRelease(v5);
  }
}

uint64_t OSKextGetAllKexts()
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  CFArrayRef v0 = (const __CFArray *)__sOSAllKexts;
  if (!__sOSAllKexts) {
    return 0;
  }
  v2.CFIndex length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  v2.location = 0;
  CFArrayApplyFunction(v0, v2, (CFArrayApplierFunction)__OSKextRealize, 0);
  return __sOSAllKexts;
}

unint64_t *OSKextGetLoadedKextWithIdentifier(void *a1)
{
  __OSKextRealizeKextsWithIdentifier(a1);
  CFDictionaryRef Value = (unint64_t *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!Value) {
    return 0;
  }
  CFAllocatorRef v3 = Value;
  uint64_t v4 = __kOSKextTypeID;
  if (v4 == CFGetTypeID(Value))
  {
    if (OSKextIsLoaded(v3, v5, v6, v7, v8, v9, v10, v11)) {
      return v3;
    }
    else {
      return 0;
    }
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v3)) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)v3);
  if (Count < 1) {
    return 0;
  }
  CFIndex v15 = Count;
  CFIndex v16 = 0;
  while (1)
  {
    CFURLRef ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex((CFArrayRef)v3, v16);
    if (OSKextIsLoaded(ValueAtIndex, v17, v18, v19, v20, v21, v22, v23)) {
      break;
    }
    if (v15 == ++v16) {
      return 0;
    }
  }
  return ValueAtIndex;
}

uint64_t OSKextIsLoaded(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[9];
  if (!v8) {
    return 0;
  }
  if (*(void *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    unint64_t v8 = a1[9];
  }
  return (*(unsigned __int16 *)(v8 + 168) >> 7) & 1;
}

CFArrayRef OSKextGetCompatibleKextWithIdentifier(void *a1, uint64_t a2)
{
  if (!__sOSKextsByIdentifier) {
    return 0;
  }
  __OSKextRealizeKextsWithIdentifier(a1);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!Value) {
    return 0;
  }
  CFArrayRef v5 = Value;
  uint64_t v6 = __kOSKextTypeID;
  if (v6 != CFGetTypeID(Value))
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      CFIndex Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        CFIndex v19 = Count;
        CFIndex v20 = 0;
        while (1)
        {
          CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v5, v20);
          uint64_t v22 = ValueAtIndex[6];
          if (v22 >= 1 && v22 <= a2)
          {
            uint64_t v16 = (uint64_t)ValueAtIndex;
            if (ValueAtIndex[5] >= a2)
            {
              if (!__sOSKextStrictAuthentication
                || OSKextIsValid((uint64_t)ValueAtIndex)
                && OSKextIsAuthentic(v16, v24, v25, v26, v27, v28, v29, v30))
              {
                return (const __CFArray *)v16;
              }
              OSKextLogCFString(0, 4097, @"Rejecting invalid/inauthentic kext for bundle id %@ at location %@.", v26, v27, v28, v29, v30, (char)a1);
            }
          }
          if (v19 == ++v20) {
            return 0;
          }
        }
      }
    }
    return 0;
  }
  uint64_t v7 = *((void *)v5 + 6);
  BOOL v8 = v7 >= 1 && v7 <= a2;
  if (!v8 || *((void *)v5 + 5) < a2) {
    return 0;
  }
  if (__sOSKextStrictAuthentication
    && (!OSKextIsValid((uint64_t)v5)
     || !OSKextIsAuthentic((uint64_t)v5, v9, v10, v11, v12, v13, v14, v15)))
  {
    OSKextLogCFString(0, 4097, @"Rejecting invalid/inauthentic kext for bundle id %@ at location %@.", v11, v12, v13, v14, v15, (char)a1);
    return 0;
  }
  return v5;
}

BOOL OSKextIsCompatibleWithVersion(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  return v2 >= 1 && v2 <= a2 && *(void *)(a1 + 40) >= a2;
}

uint64_t OSKextIsValid(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 92);
  if ((v1 & 0x400) != 0) {
    return 0;
  }
  if ((v1 & 0x200) == 0)
  {
    OSKextValidate(a1);
    unsigned int v1 = *(_DWORD *)(a1 + 92);
  }
  return (v1 >> 11) & 1;
}

uint64_t OSKextIsAuthentic(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 92);
  if ((v8 & 0x2000) != 0) {
    return 0;
  }
  if ((v8 & 0x1000) == 0)
  {
    OSKextAuthenticate(a1, a2, a3, a4, a5, a6, a7, a8);
    unsigned int v8 = *(_DWORD *)(a1 + 92);
  }
  return (v8 >> 14) & 1;
}

CFArrayRef OSKextCopyKextsWithIdentifier(void *a1)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  __OSKextRealizeKextsWithIdentifier(a1);
  if (!__sOSKextsByIdentifier) {
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  CFArrayRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByIdentifier, a1);
  if (!Value) {
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  CFAllocatorRef v3 = Value;
  uint64_t v4 = __kOSKextTypeID;
  if (v4 == CFGetTypeID(Value))
  {
    values = v3;
    CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    if (result) {
      return result;
    }
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v3)) {
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  CFArrayRef result = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFArrayRef)v3);
  if (!result) {
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
  return result;
}

CFComparisonResult __OSKextBundleIDCompare(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 0);
}

__CFArray *OSKextCopyAllRequestedIdentifiers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  OSKextLog(0, 71, "Reading list of all kexts requested by kernel since startup.", a4, a5, a6, a7, a8, v35);
  KextRequest = __OSKextCreateKextRequest(@"Get All Load Requests", 0, 0);
  mach_error_t v9 = __OSKextSendKextRequest(0, KextRequest, &cf, 0, 0);
  if (v9)
  {
    uint64_t v10 = mach_error_string(v9);
    uint64_t v16 = "(unknown)";
    if (v10) {
      LOBYTE(v16) = (_BYTE)v10;
    }
    OSKextLog(0, 65, "Failed to read kexts requested by kernel since startup - %s.", v11, v12, v13, v14, v15, (char)v16);
    goto LABEL_5;
  }
  if (!cf || (CFTypeID TypeID = CFSetGetTypeID(), TypeID != CFGetTypeID(cf)))
  {
LABEL_5:
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v18 = 0;
    goto LABEL_6;
  }
  CFIndex Count = CFSetGetCount((CFSetRef)cf);
  uint64_t v18 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  if (v18)
  {
    CFSetGetValues((CFSetRef)cf, v18);
    CFAllocatorRef v27 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v28 = CFSetGetCount((CFSetRef)cf);
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v27, v28, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      if (CFSetGetCount((CFSetRef)cf) >= 1)
      {
        CFIndex v34 = 0;
        do
          CFArrayAppendValue(Mutable, v18[v34++]);
        while (CFSetGetCount((CFSetRef)cf) > v34);
      }
      v38.CFIndex length = CFArrayGetCount(Mutable);
      v38.location = 0;
      CFArraySortValues(Mutable, v38, (CFComparatorFunction)__OSKextBundleIDCompare, 0);
    }
    else
    {
      OSKextLog(0, 17, "Memory allocation failure.", v29, v30, v31, v32, v33, v36);
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v22, v23, v24, v25, v26, v36);
    CFMutableDictionaryRef Mutable = 0;
  }
LABEL_6:
  if (KextRequest) {
    CFRelease(KextRequest);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v18) {
    free(v18);
  }
  return Mutable;
}

__CFArray *OSKextCopyKextsWithIdentifiers(const __CFArray *a1)
{
  int Count = CFArrayGetCount(a1);
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    if (Count >= 1)
    {
      CFIndex v9 = 0;
      UTF8CStringForCFString = 0;
      CFArrayRef v11 = 0;
      do
      {
        if (v11) {
          CFRelease(v11);
        }
        if (UTF8CStringForCFString) {
          free(UTF8CStringForCFString);
        }
        CFURLRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a1, v9);
        CFArrayRef v13 = OSKextCopyKextsWithIdentifier(ValueAtIndex);
        CFArrayRef v11 = v13;
        if (v13)
        {
          v21.CFIndex length = CFArrayGetCount(v13);
          v21.location = 0;
          CFArrayAppendArray(Mutable, v11, v21);
          UTF8CStringForCFString = 0;
        }
        else
        {
          UTF8CStringForCFString = createUTF8CStringForCFString(ValueAtIndex);
          OSKextLog(0, 262151, "Note: OSKextCopyKextsWithIdentifiers() - identifier %s not found.", v14, v15, v16, v17, v18, (char)UTF8CStringForCFString);
        }
        ++v9;
      }
      while (Count != v9);
      if (v11) {
        CFRelease(v11);
      }
      if (UTF8CStringForCFString) {
        free(UTF8CStringForCFString);
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v20);
  }
  return Mutable;
}

__CFArray *OSKextCopyLoadListForKexts(const __CFArray *a1, int a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v47);
    return 0;
  }
  CFArrayRef v11 = Mutable;
  uint64_t v17 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
  if (!v17)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, v47);
    goto LABEL_27;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1)
  {
LABEL_27:
    uint64_t v45 = v11;
LABEL_30:
    CFRelease(v45);
    return v17;
  }
  CFIndex v19 = Count;
  CFIndex v20 = 0;
  CFArrayRef v21 = 0;
  if (a2) {
    int v22 = 145;
  }
  else {
    int v22 = 146;
  }
  int v48 = v22;
  do
  {
    if (v21) {
      CFRelease(v21);
    }
    CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v20);
    if (CFSetGetValue(v11, ValueAtIndex))
    {
      CFArrayRef v21 = 0;
    }
    else if (__OSKextIsValid((uint64_t)ValueAtIndex, v24, v25, v26, v27, v28, v29, v30))
    {
      CFArrayRef v35 = __OSKextCopyDependenciesList(ValueAtIndex, a2, 0);
      if (!v35) {
        goto LABEL_23;
      }
      CFArrayRef v21 = v35;
      CFIndex v36 = CFArrayGetCount(v35);
      if (v36 >= 1)
      {
        CFIndex v37 = v36;
        for (CFIndex i = 0; i != v37; ++i)
        {
          CFTypeRef v39 = CFArrayGetValueAtIndex(v21, i);
          if (!CFSetGetValue(v11, v39))
          {
            CFArrayAppendValue(v17, v39);
            CFSetSetValue(v11, v39);
          }
        }
      }
    }
    else
    {
      __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 0, buffer, v31, v32, v33, v34);
      OSKextLog((uint64_t)ValueAtIndex, v48, "%s is not valid.", v40, v41, v42, v43, v44, (char)buffer);
      CFArrayRef v21 = 0;
      if (a2)
      {
LABEL_23:
        CFRelease(v11);
        CFRelease(v17);
        return 0;
      }
    }
    ++v20;
  }
  while (v20 != v19);
  CFRelease(v11);
  if (v21)
  {
    uint64_t v45 = v21;
    goto LABEL_30;
  }
  return v17;
}

uint64_t __OSKextIsValid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 92);
  if ((v8 & 0x400) != 0) {
    return 0;
  }
  if ((v8 & 0x200) == 0)
  {
    __OSKextValidate(a1, 0, a3, a4, a5, a6, a7, a8);
    unsigned int v8 = *(_DWORD *)(a1 + 92);
  }
  return (v8 >> 11) & 1;
}

CFMutableArrayRef OSKextCopyLoadList(const void *a1, int a2)
{
  return __OSKextCopyDependenciesList(a1, a2, 0);
}

BOOL _OSKextIdentifierHasApplePrefix(uint64_t a1)
{
  return CFStringHasPrefix(*(CFStringRef *)(a1 + 24), @"com.apple.") != 0;
}

CFStringRef __OSKextCreateCompositeKey(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@%s%s", a1, "_", a2);
}

uint64_t __OSKextReadInfoDictionary(uint64_t a1, uint64_t a2)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  memset(&v65, 0, sizeof(v65));
  CFTypeRef cf = 0;
  memcpy(__dst, "(unknown)", sizeof(__dst));
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, v4, v5, v6, v7);
  if (*(void *)(a1 + 56))
  {
    UTF8CStringForCFString = 0;
    int v14 = 0;
    uint64_t v15 = 1;
LABEL_7:
    int v22 = -1;
    goto LABEL_8;
  }
  if ((*(unsigned char *)(a1 + 88) & 8) != 0)
  {
    __OSKextGetFileSystemPath(0, **(CFURLRef **)(a1 + 80), 0, __dst, v9, v10, v11, v12);
    OSKextLog(a1, 129, "%s created from m%s is missing its info dictionary.", v17, v18, v19, v20, v21, (char)buffer);
    UTF8CStringForCFString = 0;
    uint64_t v15 = 0;
    int v14 = 1;
    goto LABEL_7;
  }
  if (a2)
  {
    CFBundleRef v16 = 0;
  }
  else
  {
    OSKextLog(a1, 131079, "Opening CFBundle for %s.", v8, v9, v10, v11, v12, (char)buffer);
    CFBundleRef v16 = CFBundleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 16));
    if (!v16)
    {
      OSKextLog(0, 131073, "Can't open CFBundle for %s.", v24, v25, v26, v27, v28, (char)buffer);
      int v14 = 1;
      __OSKextSetDiagnostic(a1, 1, @"Failed to open CFBundle (unknown error).");
      UTF8CStringForCFString = 0;
      uint64_t v15 = 0;
      goto LABEL_7;
    }
  }
  CFStringRef v34 = (const __CFString *)_CFBundleCopyInfoPlistURL();
  if (v34)
  {
    if (__OSKextGetFileSystemPath(0, (CFURLRef)v34, 1u, v66, v30, v31, v32, v33))
    {
      if (!stat((const char *)v66, &v65))
      {
        int v22 = open((const char *)v66, 0);
        if (v22 < 0)
        {
          int v14 = 1;
          __OSKextAddDiagnostic(a1, 1, @"File access failure; can't open, or I/O error",
            v34,
            0,
            v44,
            v45,
            v46,
            v63);
          uint64_t v15 = 0;
          uint64_t v52 = 0;
        }
        else
        {
          uint64_t v52 = (char *)malloc_type_malloc(v65.st_size + 1, 0xEAE9E46CuLL);
          if (!v52)
          {
            OSKextLog(0, 17, "Memory allocation failure.", v47, v48, v49, v50, v51, v63);
            uint64_t v15 = 0;
            UTF8CStringForCFString = 0;
            int v14 = 1;
            goto LABEL_36;
          }
          st_unsigned int size = v65.st_size;
          if (v65.st_size < 1)
          {
            off_t v54 = 0;
LABEL_45:
            v52[v54] = 0;
            CFTypeRef v56 = IOCFUnserialize(v52, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef *)&cf);
            *(void *)(a1 + 56) = v56;
            if (v56 && (CFTypeID TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(*(CFTypeRef *)(a1 + 56))))
            {
              int v14 = 0;
              UTF8CStringForCFString = 0;
              uint64_t v15 = 1;
            }
            else
            {
              __OSKextAddDiagnostic(a1, 1, @"Can't parse info dictionary XML", (const __CFString *)cf, 0, v41, v42, v43, v63);
              if (cf) {
                UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)cf);
              }
              else {
                UTF8CStringForCFString = 0;
              }
              int v14 = 1;
              OSKextLog(a1, 1, "Can't read info dictionary for %s: %s.", v58, v59, v60, v61, v62, (char)buffer);
              uint64_t v15 = 0;
            }
            goto LABEL_36;
          }
          off_t v54 = 0;
          while (1)
          {
            ssize_t v55 = read(v22, &v52[v54], st_size - v54);
            if (v55 < 0) {
              break;
            }
            v54 += v55;
            st_unsigned int size = v65.st_size;
            if (v54 >= v65.st_size) {
              goto LABEL_45;
            }
          }
          int v14 = 1;
          __OSKextSetDiagnostic(a1, 1, @"File access failure; can't open, or I/O error");
          uint64_t v15 = 0;
        }
        UTF8CStringForCFString = 0;
        goto LABEL_36;
      }
      if (*__error() == 2) {
        CFRange v38 = @"File not found";
      }
      else {
        CFRange v38 = @"Failed to get file info (stat failed)";
      }
    }
    else
    {
      CFRange v38 = @"Internal error converting URL";
    }
    int v14 = 1;
    __OSKextAddDiagnostic(a1, 1, v38, v34, 0, v35, v36, v37, v63);
  }
  else
  {
    OSKextLog(0, 131073, "%s has no Info.plist file.", v29, v30, v31, v32, v33, (char)buffer);
    int v14 = 1;
    __OSKextSetDiagnostic(a1, 1, @"Failed to open CFBundle (unknown error).");
  }
  uint64_t v15 = 0;
  uint64_t v52 = 0;
  UTF8CStringForCFString = 0;
  int v22 = -1;
LABEL_36:
  if (v16)
  {
    OSKextLog(a1, 131079, "Releasing CFBundle for %s.", v39, v40, v41, v42, v43, (char)buffer);
    CFRelease(v16);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v52) {
    free(v52);
  }
LABEL_8:
  if (cf) {
    CFRelease(cf);
  }
  if (UTF8CStringForCFString) {
    free(UTF8CStringForCFString);
  }
  if ((v22 & 0x80000000) == 0) {
    close(v22);
  }
  if (v14) {
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
  }
  return v15;
}

CFMutableDictionaryRef OSKextCopyInfoDictionary(void *cf)
{
  if (!cf[7] && !__OSKextReadInfoDictionary((uint64_t)cf, 0)) {
    return 0;
  }
  CFAllocatorRef v2 = CFGetAllocator(cf);
  CFDictionaryRef v3 = (const __CFDictionary *)cf[7];

  return CFDictionaryCreateMutableCopy(v2, 0, v3);
}

void OSKextFlushInfoDictionary(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (a1)
  {
    if ((OSKextFlushInfoDictionary_flushingAll & 1) == 0)
    {
      if (*(void *)(a1 + 16)) {
        __OSKextGetFileSystemPath(a1, 0, 0, buffer, v3, v4, v5, v6);
      }
      OSKextLog(0, 262150, "Flushing info dictionary for %s.", v2, v3, v4, v5, v6, (char)buffer);
    }
    if ((*(unsigned char *)(a1 + 88) & 8) == 0)
    {
      uint64_t v7 = *(const void **)(a1 + 56);
      if (v7) {
        CFRelease(v7);
      }
      *(void *)(a1 + 56) = 0;
      int v8 = *(_DWORD *)(a1 + 92);
      if ((~v8 & 0x4900) != 0) {
        *(_DWORD *)(a1 + 92) = v8 & 0xFFFD81FF;
      }
    }
  }
  else if (__sOSKextsByURL)
  {
    OSKextFlushInfoDictionary_flushingAll = 1;
    OSKextLog(0, 262150, "Flushing info dictionaries for all kexts.", v2, v3, v4, v5, v6, v9);
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushInfoDictionaryApplierFunction, 0);
    OSKextFlushInfoDictionary_flushingAll = 0;
  }
}

uint64_t OSKextIsFromMkext(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 88) >> 3) & 1;
}

uint64_t __OSKextFlushInfoDictionaryApplierFunction(uint64_t a1, uint64_t a2)
{
  return OSKextFlushInfoDictionary(a2);
}

uint64_t OSKextGetCompatibleVersion(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t __OSKextUUIDCallback(_DWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*a1 != 27) {
    return 2;
  }
  if ((unint64_t)a1 + a1[1] > a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(_DWORD *)a4 = 16;
  *(void *)(a4 + 8) = a1 + 2;
  return result;
}

CFDataRef OSKextCopyUUIDForArchitecture(const void *a1, char **a2)
{
  if (!a2)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    a2 = __sOSKextArchInfo;
  }
  CFDataRef v3 = OSKextCopyExecutableForArchitecture((uint64_t)a1, (uint64_t)a2);
  if (!v3) {
    return 0;
  }
  CFDataRef v4 = v3;
  uint64_t v14 = 0;
  unsigned int bytes = 0;
  BytePtr = (int *)CFDataGetBytePtr(v3);
  CFIndex Length = CFDataGetLength(v4);
  int v7 = *BytePtr;
  int commands = macho_scan_load_commands(BytePtr, (unint64_t)BytePtr + Length, __OSKextUUIDCallback, (uint64_t)&v14);
  if (commands)
  {
    CFDataRef v9 = 0;
    if (commands == -1)
    {
      __OSKextSetDiagnostic((uint64_t)a1, 1, @"Executable file doesn't contain kernel extension code (no kmod_info symbol or bad Mach-O layout).");
      CFDataRef v9 = 0;
    }
  }
  else
  {
    CFAllocatorRef v10 = CFGetAllocator(a1);
    unsigned int v11 = bswap32(v14);
    if (((v7 + 822415874) & 0xFEFFFFFF) != 0) {
      CFIndex v12 = v14;
    }
    else {
      CFIndex v12 = v11;
    }
    CFDataRef v9 = CFDataCreate(v10, bytes, v12);
  }
  CFRelease(v4);
  return v9;
}

CFDataRef OSKextCopyExecutableForArchitecture(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!__OSKextReadExecutable(a1)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 88) & 8) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 80);
    if (!v6) {
      return 0;
    }
    uint64_t v5 = *(const void **)(v6 + 16);
    if (!v5) {
      return 0;
    }
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 72);
    if (!v4) {
      return 0;
    }
    uint64_t v5 = *(const void **)(v4 + 128);
    if (!v5) {
      return 0;
    }
  }
  CFDataRef v7 = (const __CFData *)CFRetain(v5);
  if (!v7) {
    return 0;
  }
  CFDataRef v8 = v7;
  if (a2)
  {
    BytePtr = (int *)CFDataGetBytePtr(v7);
    uint64_t v33 = 0;
    CFIndex Length = CFDataGetLength(v8);
    unsigned int v11 = (int **)fat_iterator_for_data(BytePtr, (unint64_t)BytePtr + Length, 1);
    if (v11)
    {
      CFIndex v12 = v11;
      if ((*(unsigned char *)(a1 + 88) & 8) != 0) {
        goto LABEL_17;
      }
      *(void *)UInt8 buffer = 0;
      uint64_t v35 = 0;
      int v36 = 0;
      if (!fat_iterator_find_fat_arch(v11, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), (uint64_t)buffer)) {
        goto LABEL_26;
      }
      if (*MEMORY[0x1E4F14B00] != 1 << v36)
      {
LABEL_17:
        arch = fat_iterator_find_arch(v12, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), &v33);
        if (!arch) {
          goto LABEL_26;
        }
        uint64_t v20 = (const UInt8 *)arch;
        CFAllocatorRef v21 = CFGetAllocator((CFTypeRef)a1);
        CFDataRef v17 = CFDataCreate(v21, v20, v33 - (void)v20);
      }
      else
      {
        CFDataRef v17 = __OSKextMapExecutable(a1, v35, HIDWORD(v35));
      }
      CFDataRef v22 = v17;
      if (v17)
      {
LABEL_29:
        CFRelease(v8);
        fat_iterator_close((void **)v12);
        return v22;
      }
LABEL_26:
      __OSKextGetFileSystemPath(a1, 0, 0, buffer, v13, v14, v15, v16);
      CFAllocatorRef v27 = CFGetAllocator((CFTypeRef)a1);
      CFStringRef v28 = CFStringCreateWithCString(v27, *(const char **)a2, 0x8000100u);
      if (v28)
      {
        CFStringRef v32 = v28;
        __OSKextAddDiagnostic(a1, 8, @"Executable does not contain code for architecture", v28, 0, v29, v30, v31, v33);
        CFRelease(v32);
      }
      CFDataRef v22 = 0;
      goto LABEL_29;
    }
    __OSKextSetDiagnostic(a1, 1, @"Executable file doesn't contain kernel extension code (no kmod_info symbol or bad Mach-O layout).");
    CFRelease(v8);
    return 0;
  }
  if ((*(unsigned char *)(a1 + 88) & 8) != 0)
  {
    CFAllocatorRef v24 = CFGetAllocator(v7);
    uint64_t v25 = CFDataGetBytePtr(v8);
    CFIndex v26 = CFDataGetLength(v8);
    CFDataRef v18 = CFDataCreate(v24, v25, v26);
  }
  else
  {
    CFDataRef v18 = __OSKextMapExecutable(a1, 0, 0);
  }
  CFDataRef v22 = v18;
  CFRelease(v8);
  return v22;
}

void __OSKextSetDiagnostic(uint64_t a1, int a2, const void *a3)
{
  if ((__sOSKextRecordsDiagnositcs & a2) != 0)
  {
    CFMutableDictionaryRef Diagnostics = __OSKextGetDiagnostics(a1, a2);
    if (Diagnostics)
    {
      uint64_t v5 = (const void *)*MEMORY[0x1E4F1CFD0];
      CFDictionarySetValue(Diagnostics, a3, v5);
    }
  }
}

uint64_t OSKextIsKernelComponent(uint64_t a1)
{
  return *(_DWORD *)(a1 + 92) & 1;
}

uint64_t OSKextIsInterface(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 1) & 1;
}

BOOL OSKextIsLibrary(uint64_t a1)
{
  return *(void *)(a1 + 48) > 0;
}

uint64_t OSKextDeclaresExecutable(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 2) & 1;
}

BOOL OSKextHasLogOrDebugFlags(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 92) & 0x60) != 0;
}

uint64_t OSKextIsLoggingEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 92) >> 4) & 1;
}

void OSKextSetLoggingEnabled(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 92) = v8 & 0xFFFFFFEF | (16 * (a2 != 0));
  if (((v8 >> 4) & 1) != (a2 != 0))
  {
    __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
    if ((*(_DWORD *)(a1 + 92) & 0x10) != 0) {
      uint64_t v15 = "en";
    }
    else {
      uint64_t v15 = "dis";
    }
    OSKextLog(a1, 262151, "Kext logging %sabled for %s.", v10, v11, v12, v13, v14, (char)v15);
  }
}

uint64_t OSKextIsLoadableInSafeBoot(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 92) >> 7;
}

uint64_t OSKextDependenciesAreLoadableInSafeBoot(const void *a1)
{
  CFArrayRef v2 = __OSKextCopyDependenciesList(a1, 1, 1);
  if (v2)
  {
    CFArrayRef v3 = v2;
    CFIndex Count = CFArrayGetCount(v2);
    if (Count < 1)
    {
      unsigned __int8 v7 = 1;
    }
    else
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      unsigned __int8 v7 = 1;
      do
      {
        CFURLRef ValueAtIndex = (const __CFString **)CFArrayGetValueAtIndex(v3, v6);
        if (OSKextGetActualSafeBoot() | __sOSKextSimulatedSafeBoot
          && (*((unsigned char *)ValueAtIndex + 92) & 0x80) == 0)
        {
          __OSKextAddDiagnostic((uint64_t)a1, 16, @"Dependencies aren't loadable during safe boot", ValueAtIndex[3], 0, v9, v10, v11, v13);
          unsigned __int8 v7 = 0;
        }
        ++v6;
      }
      while (v5 != v6);
    }
    CFRelease(v3);
  }
  else
  {
    return 0;
  }
  return v7;
}

CFMutableArrayRef OSKextCopyAllDependencies(const void *a1, int a2)
{
  return __OSKextCopyDependenciesList(a1, a2, 1);
}

void *OSKextCopyArchitectures(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 92) & 4) == 0 || !__OSKextReadExecutable(a1)) {
    return 0;
  }
  BytePtr = (int *)CFDataGetBytePtr(*(CFDataRef *)(*(void *)(a1 + 72) + 128));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(*(void *)(a1 + 72) + 128));
  uint64_t v4 = (uint64_t *)fat_iterator_for_data(BytePtr, (unint64_t)BytePtr + Length, 1);
  if (!v4)
  {
    if ((*(unsigned char *)(a1 + 92) & 8) != 0) {
      CFURLRef ExecutableURL = 0;
    }
    else {
      CFURLRef ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((void *)a1, v5, v6, v7, v8, v9, v10, v11);
    }
    __OSKextGetFileSystemPath(a1, ExecutableURL, 0, buffer, v8, v9, v10, v11);
    OSKextLog(a1, 131073, "Can't read mach-o file %s.", v21, v22, v23, v24, v25, (char)buffer);
    return 0;
  }
  uint64_t v12 = v4;
  size_t v13 = (int)(8 * fat_iterator_num_arches((uint64_t)v4) + 8);
  uint64_t v14 = malloc_type_malloc(v13, 0x2818BDBDuLL);
  uint64_t v15 = v14;
  if (v14)
  {
    bzero(v14, v13);
    arch = (_DWORD *)fat_iterator_next_arch(v12, 0);
    if (arch)
    {
      int v17 = 0;
      do
      {
        if ((*arch | 0x1000000) == 0xCFFAEDFE) {
          cpu_type_t v18 = bswap32(arch[1]);
        }
        else {
          cpu_type_t v18 = arch[1];
        }
        if ((*arch | 0x1000000) == 0xCFFAEDFE) {
          cpu_subtype_t v19 = bswap32(arch[2]);
        }
        else {
          cpu_subtype_t v19 = arch[2];
        }
        v15[v17++] = NXGetArchInfoFromCpuType(v18, v19);
        arch = (_DWORD *)fat_iterator_next_arch(v12, 0);
      }
      while (arch);
    }
  }
  fat_iterator_close((void **)v12);
  return v15;
}

uint64_t __OSKextReadExecutable(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 92) & 4) == 0) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 88) & 8) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 80);
    if (v5 && *(void *)(v5 + 16)) {
      return 1;
    }
    uint64_t result = __OSKextCreateMkextInfo(a1);
    if (!result) {
      return result;
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), @"_MKEXTExecutable");
    if (!Value) {
      return 1;
    }
    CFNumberRef v7 = Value;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(a1 + 80) + 8));
    int valuePtr = 0;
    bzero(buffer, 0x400uLL);
    CFURLRef v14 = **(const __CFURL ***)(a1 + 80);
    if (v14) {
      __OSKextGetFileSystemPath(0, v14, 0, buffer, v10, v11, v12, v13);
    }
    OSKextLog(a1, 134, "Extracting %s%s from %s.", v9, v10, v11, v12, v13, (char)"executable");
    if (CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr))
    {
      cpu_type_t v18 = &BytePtr[valuePtr];
      CFIndex v19 = bswap32(*((_DWORD *)v18 + 1));
      if (!*(_DWORD *)v18)
      {
        CFAllocatorRef v28 = CFGetAllocator((CFTypeRef)a1);
        CFDataRef v29 = CFDataCreate(v28, v18 + 8, v19);
        *(void *)(*(void *)(a1 + 80) + 16) = v29;
        if (v29) {
          return 1;
        }
LABEL_23:
        __OSKextAddDiagnostic(a1, 1, @"Kext has a CFBundleExecutable property but the executable can't be found", @"(executable from mkext)", 0, v15, v16, v17, v30);
        uint64_t result = 0;
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
        return result;
      }
      uInt v20 = bswap32(*(_DWORD *)v18);
      CFAllocatorRef v21 = CFGetAllocator((CFTypeRef)a1);
      UncompressMkext2FileCFDataRef Data = __OSKextCreateUncompressMkext2FileData(v21, (Bytef *)v18 + 8, v20, v19);
      if (UncompressMkext2FileData)
      {
        *(void *)(*(void *)(a1 + 80) + 16) = UncompressMkext2FileData;
        return 1;
      }
      OSKextLog(a1, 129, "Failed to uncompress %s%s from %s.", v23, v24, v25, v26, v27, (char)"executable");
    }
    *(void *)(*(void *)(a1 + 80) + 16) = 0;
    goto LABEL_23;
  }
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3 && *(void *)(v3 + 128)) {
    return 1;
  }
  uint64_t result = __OSKextCreateLoadInfo(a1);
  if (result)
  {
    CFDataRef v4 = __OSKextMapExecutable(a1, 0, 0);
    *(void *)(*(void *)(a1 + 72) + 128) = v4;
    return v4 != 0;
  }
  return result;
}

uint64_t OSKextSupportsArchitecture(uint64_t a1, char **a2)
{
  if ((*(unsigned char *)(a1 + 92) & 4) == 0) {
    return 1;
  }
  uint64_t v3 = a2;
  if (!a2)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    uint64_t v3 = __sOSKextArchInfo;
  }
  if (!__OSKextReadExecutable(a1)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 88) & 8) != 0)
  {
    uint64_t v7 = *(void *)(a1 + 80);
    if (!v7) {
      return 0;
    }
    uint64_t v6 = *(const void **)(v7 + 16);
    if (!v6) {
      return 0;
    }
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 72);
    if (!v5) {
      return 0;
    }
    uint64_t v6 = *(const void **)(v5 + 128);
    if (!v6) {
      return 0;
    }
  }
  CFDataRef v8 = (const __CFData *)CFRetain(v6);
  if (!v8) {
    return 0;
  }
  CFDataRef v9 = v8;
  BytePtr = (int *)CFDataGetBytePtr(v8);
  CFIndex Length = CFDataGetLength(v9);
  uint64_t v12 = (int **)fat_iterator_for_data(BytePtr, (unint64_t)BytePtr + Length, 1);
  if (!v12)
  {
    CFRelease(v9);
    return 0;
  }
  uint64_t v13 = (void **)v12;
  uint64_t v17 = 0;
  arch = fat_iterator_find_arch(v12, *((_DWORD *)v3 + 2), *((_DWORD *)v3 + 3), &v17);
  if (arch) {
    BOOL v15 = arch == v17;
  }
  else {
    BOOL v15 = 1;
  }
  uint64_t v2 = !v15;
  CFRelease(v9);
  fat_iterator_close(v13);
  return v2;
}

__CFBundle *OSKextCopyPlugins(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (OSKextIsPlugin(a1, a2, a3, a4, a5, a6, a7, a8) || (*(unsigned char *)(a1 + 92) & 8) != 0)
  {
    CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v17 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    return CFArrayCreate(v16, 0, 0, v17);
  }
  else
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t result = CFBundleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 16));
    if (result)
    {
      uint64_t v11 = result;
      CFURLRef v12 = CFBundleCopyBuiltInPlugInsURL(result);
      if (v12)
      {
        CFURLRef v13 = v12;
        CFMutableArrayRef KextsFromURL = (CFMutableArrayRef)__OSKextCreateKextsFromURL(v9, v12, a1, 0);
        CFRelease(v11);
        CFURLRef v15 = v13;
      }
      else
      {
        CFMutableArrayRef KextsFromURL = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
        CFURLRef v15 = v11;
      }
      CFRelease(v15);
      return KextsFromURL;
    }
  }
  return result;
}

BOOL OSKextIsPlugin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(unsigned __int8 *)(a1 + 88);
  if (v8) {
    return (v8 >> 1) & 1;
  }
  CFURLRef v10 = *(const __CFURL **)(a1 + 16);
  if (!v10)
  {
    CFAllocatorRef v28 = "Bundle URL unexpectedly NULL!";
    CFURLRef v11 = (const __CFURL *)a1;
    int v29 = 262161;
LABEL_12:
    OSKextLog((uint64_t)v11, v29, v28, a4, a5, a6, a7, a8, v31);
    return 0;
  }
  CFURLRef v11 = CFURLCopyAbsoluteURL(v10);
  if (!v11)
  {
    CFAllocatorRef v28 = "Memory allocation failure.";
    int v29 = 17;
    goto LABEL_12;
  }
  CFURLRef v12 = v11;
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11);
  if (!PathComponent)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v14, v15, v16, v17, v18, v31);
    CFRelease(v12);
    return 0;
  }
  CFURLRef v19 = PathComponent;
  CFStringRef v25 = CFURLCopyFileSystemPath(PathComponent, kCFURLPOSIXPathStyle);
  if (!v25) {
    OSKextLog(0, 17, "Memory allocation failure.", v20, v21, v22, v23, v24, v31);
  }
  CFIndex location = CFStringFind(v25, @".kext/", 0).location;
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a1 + 88) & 0xFC | (2 * (location != -1)) | 1;
  BOOL v27 = location != -1;
  CFRelease(v12);
  CFRelease(v19);
  if (v25) {
    CFRelease(v25);
  }
  return v27;
}

CFTypeRef OSKextCopyContainerForPluginKext(uint64_t a1)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 88) & 3) == 1) {
    return 0;
  }
  CFURLRef v2 = CFURLCopyAbsoluteURL(*(CFURLRef *)(a1 + 16));
  if (!v2)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v67);
    return 0;
  }
  CFURLRef v8 = v2;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
  if (!PathComponent)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v11, v12, v13, v14, v15, v67);
    CFRelease(v8);
    return 0;
  }
  CFURLRef v16 = PathComponent;
  CFStringRef v17 = CFURLCopyFileSystemPath(PathComponent, kCFURLPOSIXPathStyle);
  CFStringRef v23 = v17;
  if (!v17) {
    goto LABEL_20;
  }
  CFRange v24 = CFStringFind(v17, @".kext/", 4uLL);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a1 + 88) & 0xFC | (2 * (v24.location != -1)) | 1;
  if (v24.location == -1)
  {
LABEL_21:
    CFStringRef cf = 0;
LABEL_22:
    CFURLRef v69 = 0;
    uint64_t v37 = 0;
    goto LABEL_23;
  }
  v75.CFIndex length = v24.location + v24.length;
  v75.CFIndex location = 0;
  CFStringRef v17 = CFStringCreateWithSubstring(v9, v23, v75);
  if (!v17)
  {
LABEL_20:
    OSKextLog((uint64_t)v17, 17, "Memory allocation failure.", v18, v19, v20, v21, v22, v67);
    goto LABEL_21;
  }
  CFStringRef cf = v17;
  if (!CFStringGetCString(v17, buffer, 1024, 0x8000100u))
  {
    uint64_t v66 = "String/URL conversion failure.";
    CFURLRef v31 = (const __CFURL *)a1;
LABEL_44:
    OSKextLog((uint64_t)v31, 17, v66, v25, v26, v27, v28, v29, v67);
    goto LABEL_22;
  }
  size_t v30 = strlen(buffer);
  CFURLRef v31 = CFURLCreateFromFileSystemRepresentation(v9, (const UInt8 *)buffer, v30, 1u);
  if (!v31)
  {
    uint64_t v66 = "Memory allocation failure.";
    goto LABEL_44;
  }
  CFURLRef v69 = v31;
  CFStringRef v32 = (CFURLRef *)OSKextCreate((uint64_t)v9, v31);
  uint64_t v37 = v32;
  if (!v32)
  {
LABEL_23:
    uint64_t v48 = 0;
LABEL_24:
    CFURLRef v50 = 0;
    CFURLRef v57 = 0;
    CFStringRef v49 = 0;
    goto LABEL_25;
  }
  __OSKextGetFileSystemPath((uint64_t)v32, 0, 0, v73, v33, v34, v35, v36);
  OSKextLog(a1, 131079, "Opening CFBundle for %s.", v38, v39, v40, v41, v42, (char)v73);
  uint64_t v48 = CFBundleCreate(v9, v37[2]);
  if (!v48)
  {
    OSKextLog(a1, 131073, "Failed to open CFBundle for %s.", v43, v44, v45, v46, v47, (char)v73);
    goto LABEL_24;
  }
  CFStringRef v49 = CFURLCopyLastPathComponent(*(CFURLRef *)(a1 + 16));
  CFURLRef v50 = CFBundleCopyBuiltInPlugInsURL(v48);
  CFURLRef v51 = CFURLCreateCopyAppendingPathComponent(v9, v50, v49, 1u);
  CFURLRef v57 = v51;
  if (!v51) {
    goto LABEL_46;
  }
  if (!__OSKextGetFileSystemPath(0, v51, 1u, (UInt8 *)__s, v53, v54, v55, v56))
  {
LABEL_25:
    CFTypeRef v59 = 0;
    goto LABEL_26;
  }
  CFRelease(v57);
  size_t v58 = strlen(__s);
  CFURLRef v51 = CFURLCreateFromFileSystemRepresentation(v9, (const UInt8 *)__s, v58, 1u);
  CFURLRef v57 = v51;
  if (!v51)
  {
LABEL_46:
    OSKextLog((uint64_t)v51, 17, "Memory allocation failure.", v52, v53, v54, v55, v56, v68);
    goto LABEL_25;
  }
  if (!CFEqual(v8, v51)) {
    goto LABEL_25;
  }
  CFTypeRef v59 = CFRetain(v37);
LABEL_26:
  CFRelease(v8);
  CFRelease(v16);
  if (v23) {
    CFRelease(v23);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v69) {
    CFRelease(v69);
  }
  if (v37) {
    CFRelease(v37);
  }
  if (v48)
  {
    OSKextLog(a1, 131079, "Releasing CFBundle for %s.", v61, v62, v63, v64, v65, (char)v73);
    CFRelease(v48);
  }
  if (v50) {
    CFRelease(v50);
  }
  if (v57) {
    CFRelease(v57);
  }
  if (v49) {
    CFRelease(v49);
  }
  return v59;
}

CFMutableArrayRef OSKextCopyPersonalitiesArray(CFURLRef *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v12 = "Memory allocation failure.";
    int v13 = 17;
LABEL_8:
    OSKextLog(0, v13, v12, v3, v4, v5, v6, v7, CStringPtr);
    return Mutable;
  }
  CFDictionaryRef ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, @"IOKitPersonalities");
  if (!ValueForInfoDictionaryKey) {
    return Mutable;
  }
  CFDictionaryRef v10 = ValueForInfoDictionaryKey;
  CFTypeID v11 = CFGetTypeID(ValueForInfoDictionaryKey);
  if (v11 != CFDictionaryGetTypeID())
  {
    CFStringRef v14 = CFURLGetString(a1[2]);
    char CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
    uint64_t v12 = "Kext personality for kext %s is not a dictionary";
    int v13 = 262145;
    goto LABEL_8;
  }
  if (CFDictionaryGetCount(v10))
  {
    context[0] = a1;
    context[1] = Mutable;
    void context[3] = 0;
    void context[2] = 0;
    context[4] = 1;
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)__OSKextPersonalityPatcherApplierFunction, context);
  }
  return Mutable;
}

void __OSKextPersonalityPatcherApplierFunction(const __CFString *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void **)a3;
  CFTypeID v11 = *(__CFArray **)(a3 + 8);
  int v13 = *(__CFDictionary **)(a3 + 16);
  CFStringRef v14 = *(const void **)(a3 + 24);
  int v15 = *(unsigned __int8 *)(a3 + 32);
  CFTypeID v16 = CFGetTypeID(cf);
  if (v16 != CFDictionaryGetTypeID())
  {
    char CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    OSKextLog(0, 262145, "Kext personality %s subentry is not a dictionary", v32, v33, v34, v35, v36, CStringPtr);
    return;
  }
  if (!v14
    || (CFTypeID v17 = CFGetTypeID(v14), v17 != CFArrayGetTypeID())
    || (v52.CFIndex length = CFArrayGetCount((CFArrayRef)v14), v52.location = 0,
                                                       CFArrayContainsValue((CFArrayRef)v14, v52, a1)))
  {
    CFStringRef v18 = (const __CFString *)v12[3];
    if (v18)
    {
      CFAllocatorRef v19 = CFGetAllocator(v12);
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v19, 0, (CFDictionaryRef)cf);
      if (MutableCopy)
      {
        uint64_t v26 = MutableCopy;
        if (!v15) {
          goto LABEL_21;
        }
        uint64_t v27 = (__CFString *)*MEMORY[0x1E4F1CFF8];
        CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)*MEMORY[0x1E4F1CFF8]);
        if (Value)
        {
          if (CFEqual(v18, Value)) {
            goto LABEL_17;
          }
          uint64_t v29 = @"IOPersonalityPublisher";
          size_t v30 = v26;
        }
        else
        {
          size_t v30 = v26;
          uint64_t v29 = v27;
        }
        CFDictionarySetValue(v30, v29, v18);
LABEL_17:
        if (__OSKextShouldLog((uint64_t)v12, 38))
        {
          __OSKextGetFileSystemPath((uint64_t)v12, 0, 0, buffer, v37, v38, v39, v40);
          UTF8CStringForCFString = createUTF8CStringForCFString(v18);
          uint64_t v47 = createUTF8CStringForCFString(a1);
          if (Value)
          {
            if (CFEqual(v18, Value)) {
              goto LABEL_24;
            }
            uint64_t v48 = "Adding IOBundlePublisher %s to %s personality %s.";
          }
          else
          {
            uint64_t v48 = "Adding CFBundleIdentifier %s to %s personality %s.";
          }
          OSKextLog((uint64_t)v12, 38, v48, v42, v43, v44, v45, v46, (char)UTF8CStringForCFString);
LABEL_24:
          if (!__sOSKextPersonalityPatcherFunction || __sOSKextPersonalityPatcherFunction(v12, v26))
          {
            if (v11) {
              CFArrayAppendValue(v11, v26);
            }
            if (v13) {
              CFDictionarySetValue(v13, a1, v26);
            }
          }
          if (UTF8CStringForCFString) {
            free(UTF8CStringForCFString);
          }
          if (v47) {
            free(v47);
          }
          CFRelease(v26);
          return;
        }
LABEL_21:
        UTF8CStringForCFString = 0;
        uint64_t v47 = 0;
        goto LABEL_24;
      }
      OSKextLog(0, 17, "Memory allocation failure.", v21, v22, v23, v24, v25, a9);
    }
  }
}

CFMutableArrayRef OSKextCopyPersonalitiesOfKexts(CFTypeRef cf)
{
  CFTypeRef AllKexts = cf;
  if (!cf)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    CFTypeRef AllKexts = (CFTypeRef)OSKextGetAllKexts();
  }
  CFAllocatorRef v2 = CFGetAllocator(AllKexts);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v9 = Mutable;
  if (Mutable)
  {
    char context = 0;
    long long v28 = 0u;
    uint64_t v29 = 0;
    CFMutableArrayRef context_8 = Mutable;
    CFIndex Count = CFArrayGetCount((CFArrayRef)AllKexts);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0; i != v11; ++i)
      {
        CFURLRef ValueAtIndex = (CFURLRef *)CFArrayGetValueAtIndex((CFArrayRef)AllKexts, i);
        CFDictionaryRef ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)ValueAtIndex, @"IOKitPersonalities");
        if (ValueForInfoDictionaryKey)
        {
          CFDictionaryRef v15 = ValueForInfoDictionaryKey;
          CFTypeID v16 = CFGetTypeID(ValueForInfoDictionaryKey);
          if (v16 == CFDictionaryGetTypeID())
          {
            if (CFDictionaryGetCount(v15))
            {
              char context = ValueAtIndex;
              CFMutableArrayRef context_8 = v9;
              long long v28 = 0uLL;
              LOBYTE(v29) = 1;
              CFDictionaryApplyFunction(v15, (CFDictionaryApplierFunction)__OSKextPersonalityPatcherApplierFunction, &context);
            }
          }
          else
          {
            CFStringRef v17 = CFURLGetString(ValueAtIndex[2]);
            char CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
            OSKextLog(0, 262145, "Kext personality for kext %s is not a dictionary", v19, v20, v21, v22, v23, CStringPtr);
          }
        }
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v25);
  }
  return v9;
}

void __OSKextDeallocateMmapBuffer(void *a1, size_t *a2)
{
  munmap(a1, *a2);

  free(a2);
}

CFDataRef __OSKextMapExecutable(uint64_t a1, off_t a2, off_t st_size)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  if (!__OSKextCreateLoadInfo(a1)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 92) & 8) != 0) {
    return 0;
  }
  CFURLRef ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((void *)a1, v6, v7, v8, v9, v10, v11, v12);
  if (!ExecutableURL) {
    return 0;
  }
  memset(&v92, 0, sizeof(v92));
  memset(&context, 0, sizeof(context));
  if (!__OSKextGetFileSystemPath(0, ExecutableURL, 1u, buffer, v14, v15, v16, v17)) {
    return 0;
  }
  OSKextLog(a1, 131079, "Statting %s for map.", v18, v19, v20, v21, v22, (char)buffer);
  if (stat((const char *)buffer, &v92) == -1)
  {
    int v31 = *__error();
    if (v31 == 2) {
      uint64_t v32 = @"File not found";
    }
    else {
      uint64_t v32 = @"Failed to get file info (stat failed)";
    }
    __OSKextAddDiagnostic(a1, 1, v32, *(const __CFString **)(a1 + 32), 0, v28, v29, v30, v88);
    strerror(v31);
    OSKextLog(a1, 131073, "Stat failed for %s - %s.", v33, v34, v35, v36, v37, (char)buffer);
    return 0;
  }
  if (st_size)
  {
    if (st_size + a2 > v92.st_size)
    {
      OSKextLog(a1, 131073, "Internal error; overrun mapping executable file %s.",
        v23,
        v24,
        v25,
        v26,
        v27,
        (char)buffer);
      return 0;
    }
  }
  else
  {
    st_unsigned int size = v92.st_size;
  }
  OSKextLog(a1, 131079, "Opening %s for map.", v23, v24, v25, v26, v27, (char)buffer);
  int v38 = open((const char *)buffer, 0);
  if (v38 == -1)
  {
    int v66 = *__error();
    if (v66 == 2) {
      char v67 = @"File not found";
    }
    else {
      char v67 = @"File access failure; can't open, or I/O error";
    }
    __OSKextAddDiagnostic(a1, 1, v67, *(const __CFString **)(a1 + 32), 0, v63, v64, v65, v89);
    strerror(v66);
    OSKextLog(a1, 131073, "Open failed for %s - %s.", v68, v69, v70, v71, v72, (char)buffer);
    return 0;
  }
  int v39 = v38;
  uint64_t v45 = mmap(0, st_size, 3, 2, v38, a2);
  if (v45 == (void *)-1)
  {
    int v77 = *__error();
    if (!st_size)
    {
      __OSKextAddDiagnostic(a1, 1, @"File access failure; can't open, or I/O error",
        *(const __CFString **)(a1 + 32),
        0,
        v74,
        v75,
        v76,
        v89);
      *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFF3FF | 0x400;
    }
    strerror(v77);
    OSKextLog(a1, 131073, "Failed to map executable file %s (offset %lu, %lu bytes) - %s.", v78, v79, v80, v81, v82, (char)buffer);
    goto LABEL_30;
  }
  OSKextLog(a1, 131078, "Mapped executable file %s (offset %lu, %lu bytes).", v40, v41, v42, v43, v44, (char)buffer);
  CFAllocatorRef v46 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorGetContext((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
  uint64_t v47 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (!v47)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v48, v49, v50, v51, v52, v90);
LABEL_30:
    close(v39);
    goto LABEL_33;
  }
  uint64_t v53 = v47;
  *uint64_t v47 = st_size;
  context.info = v47;
  context.deallocate = (CFAllocatorDeallocateCallBack)__OSKextDeallocateMmapBuffer;
  CFAllocatorRef v54 = CFAllocatorCreate(v46, &context);
  if (!v54)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v55, v56, v57, v58, v59, v90);
    close(v39);
LABEL_32:
    free(v53);
LABEL_33:
    if (v45)
    {
      OSKextLog(a1, 131073, "Error encountered, unmapping executable file %s (offset %lu, %lu bytes).", v83, v84, v85, v86, v87, (char)buffer);
      munmap(v45, st_size);
    }
    return 0;
  }
  CFAllocatorRef v60 = v54;
  CFAllocatorRef v61 = CFGetAllocator((CFTypeRef)a1);
  CFDataRef v62 = CFDataCreateWithBytesNoCopy(v61, (const UInt8 *)v45, st_size, v60);
  CFRelease(v60);
  close(v39);
  if (!v62) {
    goto LABEL_32;
  }
  return v62;
}

uint64_t __OSKextCreateLoadInfo(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    return 1;
  }
  uint64_t v3 = malloc_type_malloc(0xB0uLL, 0x107004062F0A6EBuLL);
  *(void *)(a1 + 72) = v3;
  if (v3)
  {
    v3[9] = 0u;
    v3[10] = 0u;
    v3[7] = 0u;
    _OWORD v3[8] = 0u;
    _OWORD v3[5] = 0u;
    _OWORD v3[6] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    v3[1] = 0u;
    void v3[2] = 0u;
    uint64_t v1 = 1;
    _OWORD *v3 = 0u;
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v10);
    return 0;
  }
  return v1;
}

CFDataRef OSKextCopyResource(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDataRef v8 = 0;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  resourceCFDataRef Data = 0;
  if ((*(unsigned char *)(a1 + 88) & 8) == 0)
  {
    SInt32 errorCode = 0;
    __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
    OSKextLog(a1, 131078, "Opening CFBundle for %s.", v12, v13, v14, v15, v16, (char)buffer);
    CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v18 = CFBundleCreate(v17, *(CFURLRef *)(a1 + 16));
    if (v18)
    {
      uint64_t v24 = v18;
      CFURLRef v25 = CFBundleCopyResourceURL(v18, a2, a3, 0);
      if (v25)
      {
        CFURLRef v30 = v25;
        __OSKextGetFileSystemPath(0, v25, 0, v57, v26, v27, v28, v29);
        OSKextLog(a1, 131078, "Reading resource %s.", v31, v32, v33, v34, v35, (char)v57);
        CFAllocatorRef v36 = CFGetAllocator((CFTypeRef)a1);
        if (CFURLCreateDataAndPropertiesFromResource(v36, v30, &resourceData, 0, 0, &errorCode))
        {
          CFDataRef v8 = resourceData;
        }
        else
        {
          OSKextLog(a1, 131076, "Couldn't read resource file %s.", v37, v38, v39, v40, v41, (char)v57);
          CFDataRef v8 = 0;
        }
        if (v8) {
          int v53 = 131079;
        }
        else {
          int v53 = 131076;
        }
        OSKextLog(a1, v53, "Reading resource file %s%s.", v37, v38, v39, v40, v41, (char)v57);
        CFRelease(v30);
      }
      else
      {
        UTF8CStringForCFString = createUTF8CStringForCFString(a2);
        OSKextLog(a1, 131076, "Couldn't read resource URL in %s for resource %s.", v43, v44, v45, v46, v47, (char)buffer);
        if (UTF8CStringForCFString) {
          free(UTF8CStringForCFString);
        }
        CFDataRef v8 = 0;
      }
      OSKextLog(a1, 131079, "Releasing CFBundle for %s.", v48, v49, v50, v51, v52, (char)buffer);
      CFRelease(v24);
    }
    else
    {
      OSKextLog(a1, 131076, "Couldn't open CFBundle for %s.", v19, v20, v21, v22, v23, (char)buffer);
      return 0;
    }
  }
  return v8;
}

uint64_t OSKextResolveDependencies(uint64_t a1)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFSetCreateMutable(v2, 0, MEMORY[0x1E4F1D548]);
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFArrayRef v5 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v11 = v5;
  if (Mutable) {
    BOOL v12 = v5 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a1)
    {
      if ((*(unsigned char *)(a1 + 92) & 1) != 0 || (uint64_t v16 = *(void *)(a1 + 72)) != 0 && (*(_WORD *)(v16 + 168) & 0x10) != 0)
      {
        __OSKextGetFileSystemPath(a1, 0, 0, context, v7, v8, v9, v10);
        OSKextLog(a1, 16391, "%s - dependencies already resolved.", v20, v21, v22, v23, v24, (char)context);
        CFArrayRef v13 = 0;
        unsigned __int8 v14 = 1;
        goto LABEL_29;
      }
      int v17 = __OSKextResolveDependencies(a1, a1, Mutable, v5, v7, v8, v9, v10);
      unsigned __int8 v14 = v17;
      if (v17)
      {
        CFArrayRef v13 = (const __CFArray *)__OSKextCopyDependenciesList(a1, 1, 0);
        if (!v13)
        {
          unsigned __int8 v14 = 0;
          goto LABEL_29;
        }
        CFDictionaryRef ValueForInfoDictionaryKey = OSKextGetValueForInfoDictionaryKey(a1, @"OSBundleRequired");
        if (ValueForInfoDictionaryKey)
        {
          uint64_t v19 = ValueForInfoDictionaryKey;
          if (!CFEqual(ValueForInfoDictionaryKey, @"Root")
            && !CFEqual(v19, @"Console")
            && !CFEqual(v19, @"DriverKit"))
          {
            if (CFEqual(v19, @"Local-Root"))
            {
              char v47 = 0;
              char v48 = 1;
              BOOL v46 = 1;
            }
            else
            {
              char v48 = 1;
              BOOL v46 = CFEqual(v19, @"Network-Root") == 0;
              char v47 = 1;
            }
LABEL_34:
            CFIndex Count = CFArrayGetCount(v13);
            if (Count >= 1)
            {
              CFIndex v26 = Count;
              CFIndex v27 = 0;
              while (1)
              {
                CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v13, v27);
                uint64_t v29 = (__CFString *)OSKextGetValueForInfoDictionaryKey((uint64_t)ValueAtIndex, @"OSBundleRequired");
                uint64_t v33 = v29;
                CFStringRef v34 = (const __CFString *)*((void *)ValueAtIndex + 3);
                if (v48) {
                  goto LABEL_42;
                }
                if (!v29) {
                  break;
                }
                int v35 = CFEqual(@"Safe Boot", v29);
                CFStringRef v36 = v33;
                if (v35) {
                  goto LABEL_41;
                }
LABEL_42:
                if (v47) {
                  goto LABEL_51;
                }
                if (!v33)
                {
                  CFStringRef v38 = @"OSBundleRequired not set";
LABEL_50:
                  __OSKextAddDiagnostic(a1, 8, @"Dependency lacks appropriate value for OSBundleRequired and may not be available during early boot", v34, v38, v30, v31, v32, v45);
                  goto LABEL_51;
                }
                if (!CFEqual(@"Root", v33) && !CFEqual(@"Local-Root", v33))
                {
                  int v37 = CFEqual(@"Console", v33);
                  CFStringRef v38 = v33;
                  if (!v37) {
                    goto LABEL_50;
                  }
                }
                int v39 = CFEqual(@"DriverKit", v33);
                CFStringRef v38 = v33;
                if (v39) {
                  goto LABEL_50;
                }
LABEL_51:
                if (!v46)
                {
                  if (v33)
                  {
                    if ((CFEqual(@"Root", v33)
                       || CFEqual(@"Network-Root", v33)
                       || CFEqual(@"Console", v33))
                      && !CFEqual(@"DriverKit", v33))
                    {
                      goto LABEL_60;
                    }
                  }
                  else
                  {
                    uint64_t v33 = @"OSBundleRequired not set";
                  }
                  __OSKextAddDiagnostic(a1, 8, @"Dependency lacks appropriate value for OSBundleRequired and may not be available during early boot", v34, v33, v30, v31, v32, v45);
                }
LABEL_60:
                if (++v27 < v26)
                {
                  CFIndex v40 = v27;
                  do
                  {
                    uint64_t v41 = (CFTypeRef *)CFArrayGetValueAtIndex(v13, v40);
                    if (CFEqual(v34, v41[3]))
                    {
                      __OSKextAddDiagnostic(a1, 4, @"Multiple kexts for these libraries occur in the dependency graph", v34, 0, v42, v43, v44, v45);
                      unsigned __int8 v14 = 0;
                    }
                    ++v40;
                  }
                  while (v26 != v40);
                }
                if (v27 == v26) {
                  goto LABEL_7;
                }
              }
              CFStringRef v36 = @"OSBundleRequired not set";
LABEL_41:
              __OSKextAddDiagnostic(a1, 8, @"Dependency lacks appropriate value for OSBundleRequired and may not be available during early boot", v34, v36, v30, v31, v32, v45);
              goto LABEL_42;
            }
            goto LABEL_29;
          }
          char v48 = 0;
        }
        else
        {
          char v48 = 1;
        }
        BOOL v46 = 1;
        char v47 = 1;
        goto LABEL_34;
      }
    }
    else
    {
      if (__sOSKextsByURL)
      {
        context[0] = 1;
        CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextResolveDependenciesApplierFunction, context);
      }
      unsigned __int8 v14 = 0;
    }
    CFArrayRef v13 = 0;
    goto LABEL_29;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v45);
  CFArrayRef v13 = 0;
  unsigned __int8 v14 = 0;
LABEL_7:
  if (!Mutable)
  {
    if (!v11) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_29:
  CFRelease(Mutable);
  if (v11) {
LABEL_9:
  }
    CFRelease(v11);
LABEL_10:
  if (v13) {
    CFRelease(v13);
  }
  return v14;
}

uint64_t __OSKextResolveDependencies(uint64_t a1, uint64_t a2, __CFSet *a3, const __CFArray *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v187 = *MEMORY[0x1E4F143B8];
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  if (!__OSKextReadInfoDictionary(a1, 0) || !*(void *)(a1 + 56))
  {
    OSKextLog(a1, 16385, "%s has no info dictionary; can't resolve dependencies.",
      v14,
      v15,
      v16,
      v17,
      v18,
      (char)buffer);
LABEL_10:
    CFSetAddValue(a3, (const void *)a1);
    return 0;
  }
  if (!__OSKextIsValid(a1, v12, v13, v14, v15, v16, v17, v18))
  {
    OSKextLog(a1, 16385, "%s is invalid; can't resolve dependencies.", v19, v20, v21, v22, v23, (char)buffer);
    goto LABEL_10;
  }
  int v29 = CFSetContainsValue(a3, (const void *)a1);
  if (v29)
  {
    OSKextLog(a1, 16391, "%s already has dependencies resolved.", v24, v25, v26, v27, v28, (char)buffer);
    uint64_t v30 = *(void *)(a1 + 72);
    if (!v30)
    {
      CFSetAddValue(a3, (const void *)a1);
      return 1;
    }
    BOOL v31 = 1;
    goto LABEL_7;
  }
  if ((*(unsigned char *)(a1 + 92) & 1) == 0) {
    OSKextLog(a1, 16389, "Resolving dependencies for %s.", v24, v25, v26, v27, v28, (char)buffer);
  }
  v188.CFIndex length = CFArrayGetCount(a4);
  v188.CFIndex location = 0;
  if (CFArrayGetCountOfValue(a4, v188, (const void *)a1))
  {
    __OSKextAddDiagnostic(a2, 4, @"Some dependencies are causing circular references", *(const __CFString **)(a1 + 24), 0, v33, v34, v35, v172);
    __OSKextAddDiagnostic(a1, 4, @"Some dependencies are causing circular references", *(const __CFString **)(a1 + 24), 0, v36, v37, v38, v173);
    goto LABEL_10;
  }
  CFArrayAppendValue(a4, (const void *)a1);
  OSKextFlushDependencies((void *)a1);
  if (!__OSKextCreateLoadInfo(a1)) {
    goto LABEL_68;
  }
  CFAllocatorRef v39 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v39, 0, MEMORY[0x1E4F1D510]);
  **(void **)(a1 + 72) = Mutable;
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v41, v42, v43, v44, v45, v172);
LABEL_68:
    BOOL v31 = 0;
LABEL_69:
    CFSetAddValue(a3, (const void *)a1);
LABEL_70:
    CFIndex Count = CFArrayGetCount(a4);
    CFArrayRemoveValueAtIndex(a4, Count - 1);
    return v31;
  }
  CFDictionaryRef ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey(a1, @"OSBundleLibraries");
  if (*(unsigned char *)(a1 + 92))
  {
    if (a1 == a2) {
      OSKextLog(a1, 0x4000, "%s is a kernel component with no dependencies.", v47, v48, v49, v50, v51, (char)buffer);
    }
    BOOL v31 = 1;
    goto LABEL_119;
  }
  CFDictionaryRef v52 = ValueForInfoDictionaryKey;
  if (ValueForInfoDictionaryKey)
  {
    CFIndex v53 = CFDictionaryGetCount(ValueForInfoDictionaryKey);
    if (v53)
    {
      uint64_t v54 = v53;
      size_t v55 = 8 * v53;
      uint64_t v56 = (const void **)malloc_type_malloc(8 * v53, 0x6004044C4A2DFuLL);
      uint64_t v57 = (const void **)malloc_type_malloc(v55, 0x6004044C4A2DFuLL);
      uint64_t v63 = v57;
      keys = (void **)v56;
      if (!v56 || !v57)
      {
        OSKextLog(0, 17, "Memory allocation failure.", v58, v59, v60, v61, v62, v172);
        BOOL v31 = 0;
        BOOL v170 = 1;
        goto LABEL_114;
      }
      CFDictionaryGetKeysAndValues(v52, v56, v57);
      if (v54 >= 1)
      {
        v181 = v63;
        int v177 = 0;
        uint64_t v64 = 0;
        CFDictionaryRef v52 = 0;
        CFTypeRef cf2 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
        uint64_t v65 = keys;
        uint64_t v178 = v54;
        while (1)
        {
          int v66 = (__CFString *)v65[v64];
          uint64_t v67 = OSKextParseVersionCFString((const __CFString *)v181[v64]);
          if (v52) {
            free(v52);
          }
          CFDictionaryRef UTF8CStringForCFString = (const __CFDictionary *)createUTF8CStringForCFString(v66);
          LoadedKextWithCFStringRef Identifier = OSKextGetLoadedKextWithIdentifier(v66);
          uint64_t v70 = LoadedKextWithIdentifier;
          if (LoadedKextWithIdentifier)
          {
            uint64_t v71 = LoadedKextWithIdentifier[6];
            BOOL v72 = v71 >= 1 && v71 <= v67;
            if (!v72 || (uint64_t)LoadedKextWithIdentifier[5] < v67)
            {
              OSKextVersionGetString(v67, v184, 0x14u);
              OSKextVersionGetString(v70[5], v183, 0x14u);
              if ((uint64_t)v70[6] < 1)
              {
                CFDictionaryRef v52 = UTF8CStringForCFString;
                OSKextLog(a1, 16385, "%s - loaded dependency %s lacks valid OSBundleCompatibleVersion.", v73, v74, v75, v76, v77, (char)buffer);
                uint64_t v81 = @"Kexts already loaded for these libraries have no OSBundleCompatibleVersion";
              }
              else
              {
                CFDictionaryRef v52 = UTF8CStringForCFString;
                OSKextLog(a1, 16385, "%s - loaded dependency %s, v%s is not compatible with requested version %s.", v73, v74, v75, v76, v77, (char)buffer);
                uint64_t v81 = @"Kexts already loaded for these libraries are not compatible with the requested version";
              }
              uint64_t v83 = a1;
              goto LABEL_41;
            }
            CompatibleKextWithCFStringRef Identifier = (const __CFArray *)LoadedKextWithIdentifier;
          }
          else
          {
            CompatibleKextWithCFStringRef Identifier = OSKextGetCompatibleKextWithIdentifier(v66, v67);
          }
          if (CFEqual(v66, @"com.apple.kernel"))
          {
            __int16 v84 = 1;
          }
          else if (CFStringHasPrefix(v66, @"com.apple.kernel."))
          {
            __int16 v84 = 2;
          }
          else
          {
            if (!CFStringHasPrefix(v66, @"com.apple.kpi.")) {
              goto LABEL_48;
            }
            *(_WORD *)(*(void *)(a1 + 72) + 168) |= 4u;
            if (!CFEqual(v66, @"com.apple.kpi.private")) {
              goto LABEL_48;
            }
            __int16 v84 = 8;
          }
          *(_WORD *)(*(void *)(a1 + 72) + 168) |= v84;
LABEL_48:
          if (CompatibleKextWithIdentifier)
          {
            uint64_t v85 = OSKextGetValueForInfoDictionaryKey((uint64_t)CompatibleKextWithIdentifier, @"OSBundleRequiredPromotion");
            if (v85)
            {
              int v90 = CFEqual(v85, cf2);
              __OSKextGetFileSystemPath((uint64_t)CompatibleKextWithIdentifier, 0, 0, v185, v91, v92, v93, v94);
              CFDictionaryRef v52 = UTF8CStringForCFString;
              OSKextLog(a1, 16390, "%s found %s%s%sdependency %s for %s%s.", v95, v96, v97, v98, v99, (char)buffer);
              CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), CompatibleKextWithIdentifier);
              if (v90)
              {
                CFStringRef v100 = (const __CFString *)OSKextGetValueForInfoDictionaryKey(a1, @"OSBundleRequired");
                uint64_t v101 = v178;
                uint64_t v65 = keys;
                if (!v100 || CFEqual(v100, @"Safe Boot")) {
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"OSBundleRequired", @"Console");
                }
                goto LABEL_64;
              }
            }
            else
            {
              __OSKextGetFileSystemPath((uint64_t)CompatibleKextWithIdentifier, 0, 0, v185, v86, v87, v88, v89);
              CFDictionaryRef v52 = UTF8CStringForCFString;
              OSKextLog(a1, 16390, "%s found %s%s%sdependency %s for %s%s.", v108, v109, v110, v111, v112, (char)buffer);
              CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), CompatibleKextWithIdentifier);
            }
            goto LABEL_62;
          }
          KextWithCFStringRef Identifier = (uint64_t *)OSKextGetKextWithIdentifier(v66);
          if (!KextWithIdentifier)
          {
            CFDictionaryRef v52 = UTF8CStringForCFString;
            OSKextLog(a1, 16385, "%s - dependency '%s' not found.", v103, v104, v105, v106, v107, (char)buffer);
            __OSKextAddDiagnostic(a1, 4, @"No kexts found for these libraries", v66, 0, v113, v114, v115, v175);
            int v177 = 1;
LABEL_62:
            uint64_t v65 = keys;
            goto LABEL_63;
          }
          uint64_t v65 = keys;
          CFDictionaryRef v52 = UTF8CStringForCFString;
          if (KextWithIdentifier[6] < 1)
          {
            OSKextLog(a1, 16385, "%s - dependency for %s lacks valid OSBundleCompatibleVersion.", v103, v104, v105, v106, v107, (char)buffer);
            uint64_t v83 = a1;
            uint64_t v81 = @"Kexts found for these libraries lack valid OSBundleCompatibleVersion";
          }
          else
          {
            OSKextLog(a1, 16385, "%s - no compatible dependency found for %s.", v103, v104, v105, v106, v107, (char)buffer);
            uint64_t v83 = a1;
            uint64_t v81 = @"Only incompatible kexts found for these libraries";
          }
LABEL_41:
          __OSKextAddDiagnostic(v83, 4, v81, v66, 0, v78, v79, v80, v174);
          int v177 = 1;
LABEL_63:
          uint64_t v101 = v178;
LABEL_64:
          if (v101 == ++v64)
          {
            uint64_t v63 = v181;
            int v171 = v177;
            goto LABEL_78;
          }
        }
      }
    }
    else
    {
      uint64_t v63 = 0;
      keys = 0;
    }
    CFDictionaryRef v52 = 0;
  }
  else
  {
    uint64_t v63 = 0;
    keys = 0;
  }
  int v171 = 0;
LABEL_78:
  if (*(_WORD *)(*(void *)(a1 + 72) + 168))
  {
    __OSKextSetDiagnostic(a1, 4, @"Kexts may not link against com.apple.kernel; use either com.apple.kpi.* libraries (recommended), or com.apple.kernel.* (for compatiblity with older releases).");
    int v171 = 1;
  }
  CFDictionaryRef v179 = v52;
  if ((*(unsigned char *)(a1 + 92) & 2) != 0 && CFArrayGetCount(**(CFArrayRef **)(a1 + 72)) != 1)
  {
    OSKextLog(a1, 16385, "%s - Interface kext must have exactly one dependency.", v117, v118, v119, v120, v121, (char)buffer);
    __OSKextSetDiagnostic(a1, 4, @"Interface kext must have exactly one dependency.");
    int v171 = 1;
  }
  v182 = v63;
  CFIndex v122 = CFArrayGetCount(**(CFArrayRef **)(a1 + 72));
  if (v122 >= 1)
  {
    CFIndex v130 = v122;
    for (CFIndex i = 0; i != v130; ++i)
    {
      CFStringRef v132 = (const __CFString *)*((void *)CFArrayGetValueAtIndex(**(CFArrayRef **)(a1 + 72), i) + 3);
      if (!__OSKextResolveDependencies())
      {
        CFIndex v133 = CFArrayGetCount(a4);
        if (v133 >= 1)
        {
          CFIndex v134 = v133;
          for (CFIndex j = 0; j != v134; ++j)
          {
            CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a4, j);
            __OSKextAddDiagnostic((uint64_t)ValueAtIndex, 4, @"Indirect dependencies can't be resolved", v132, 0, v137, v138, v139, v172);
          }
        }
        int v171 = 1;
      }
    }
  }
  int v140 = v171;
  int v29 = 0;
  uint64_t v63 = v182;
  if ((*(unsigned char *)(a1 + 92) & 4) != 0 && __OSKextHasSuffix(a1, v123, v124, v125, v126, v127, v128, v129))
  {
    long long v141 = OSKextGetKextWithIdentifier(@"com.apple.kpi.kasan");
    if (v141)
    {
      long long v147 = v141;
      OSKextLog(a1, 16390, "%s adding implicit KASan dependency", v142, v143, v144, v145, v146, (char)buffer);
      CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), v147);
    }
    long long v148 = OSKextGetKextWithIdentifier(@"com.apple.kpi.kcov");
    if (v148)
    {
      CFRange v154 = v148;
      OSKextLog(a1, 16390, "%s adding implicit Kcov dependency", v149, v150, v151, v152, v153, (char)buffer);
      CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), v154);
    }
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  int v160 = *(_DWORD *)(a1 + 92);
  if (*((unsigned char *)__sOSKextArchInfo + 11))
  {
    if ((v160 & 4) == 0) {
      goto LABEL_110;
    }
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    if (!OSKextSupportsArchitecture(a1, __sOSKextArchInfo)) {
      goto LABEL_110;
    }
    __int16 v169 = *(_WORD *)(*(void *)(a1 + 72) + 168);
    if ((v169 & 2) == 0)
    {
      if ((v169 & 4) != 0) {
        goto LABEL_110;
      }
      v168 = @"Kext declares no com.apple.kpi.* libraries; if it references any kernel symbols, it may fail to link.";
      goto LABEL_104;
    }
    __OSKextSetDiagnostic(a1, 4, @"64-bit kexts must use com.apple.kpi.* libraries, not com.apple.kernel* libraries.");
    BOOL v31 = 0;
    BOOL v170 = 1;
  }
  else
  {
    uint64_t v161 = *(void *)(a1 + 72);
    if ((v160 & 4) == 0 || (*(_WORD *)(v161 + 168) & 6) != 0) {
      goto LABEL_102;
    }
    OSKextLog(a1, 16386, "%s does not declare a kernel dependency; using %s.",
      v155,
      v156,
      v157,
      v158,
      v159,
      (char)buffer);
    v162 = OSKextGetKextWithIdentifier(@"com.apple.kernel.6.0");
    if (v162)
    {
      CFArrayAppendValue(**(CFMutableArrayRef **)(a1 + 72), v162);
      __OSKextSetDiagnostic(a1, 8, @"Kext declares no kernel/KPI libraries; if it references any kernel symbols, it may fail to link.");
      uint64_t v161 = *(void *)(a1 + 72);
LABEL_102:
      if ((~*(unsigned __int16 *)(v161 + 168) & 6) != 0)
      {
LABEL_110:
        BOOL v170 = v140 != 0;
        BOOL v31 = v140 == 0;
        goto LABEL_111;
      }
      v168 = @"Kexts should declare dependencies on either com.apple.kernel* or com.apple.kpi.* libraries, not both.";
LABEL_104:
      __OSKextSetDiagnostic(a1, 8, v168);
      goto LABEL_110;
    }
    OSKextLog(a1, 16385, "%s - dependency '%s' not found.", v163, v164, v165, v166, v167, (char)buffer);
    BOOL v31 = 0;
    BOOL v170 = 1;
  }
LABEL_111:
  if (v179) {
    free(v179);
  }
LABEL_114:
  if (keys) {
    free(keys);
  }
  if (v63) {
    free(v63);
  }
  if (v170) {
    goto LABEL_69;
  }
LABEL_119:
  uint64_t v30 = *(void *)(a1 + 72);
  if (!v30) {
    goto LABEL_69;
  }
LABEL_7:
  *(_WORD *)(v30 + 168) |= 0x10u;
  CFSetAddValue(a3, (const void *)a1);
  if (!v29) {
    goto LABEL_70;
  }
  return v31;
}

uint64_t __OSKextResolveDependenciesApplierFunction(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = OSKextResolveDependencies(a2);
  if (!result) {
    *a3 = 0;
  }
  return result;
}

uint64_t __OSKextClearHasAllDependenciesOnKext(const void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t result = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  if (result >= 1)
  {
    uint64_t v3 = result;
    for (CFIndex i = 0; i != v3; ++i)
    {
      uint64_t result = (uint64_t)CFArrayGetValueAtIndex((CFArrayRef)__sOSAllKexts, i);
      uint64_t v5 = *(void *)(result + 72);
      if (v5)
      {
        CFArrayRef v6 = *(const __CFArray **)v5;
        if (*(void *)v5)
        {
          uint64_t v7 = result;
          if ((*(unsigned char *)(result + 92) & 1) != 0 || (*(_WORD *)(v5 + 168) & 0x10) != 0)
          {
            v19.CFIndex length = CFArrayGetCount(v6);
            v19.CFIndex location = 0;
            uint64_t result = CFArrayContainsValue(v6, v19, a1);
            if (result)
            {
              __OSKextGetFileSystemPath(v7, 0, 0, buffer, v8, v9, v10, v11);
              OSKextLog((uint64_t)a1, 262151, "Clearing \"has all dependencies\" for %s.", v12, v13, v14, v15, v16, (char)buffer);
              *(_WORD *)(*(void *)(v7 + 72) + 168) &= ~0x10u;
              uint64_t result = __OSKextClearHasAllDependenciesOnKext(v7);
            }
          }
        }
      }
    }
  }
  return result;
}

void OSKextFlushDependencies(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  if (a1)
  {
    if ((OSKextFlushDependencies_flushingAll & 1) == 0)
    {
      if (a1[2]) {
        __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, v3, v4, v5, v6);
      }
      OSKextLog((uint64_t)a1, 262150, "Flushing dependencies for %s.", v2, v3, v4, v5, v6, (char)buffer);
    }
    uint64_t v7 = a1[9];
    if (v7)
    {
      *(_WORD *)(v7 + 168) &= ~1u;
      *(_WORD *)(a1[9] + 168) &= ~2u;
      *(_WORD *)(a1[9] + 168) &= ~4u;
      uint64_t v8 = *(const void **)a1[9];
      if (v8)
      {
        CFRelease(v8);
        uint64_t v9 = a1[9];
        *(void *)uint64_t v9 = 0;
        *(_WORD *)(v9 + 168) &= ~0x10u;
        *(_WORD *)(a1[9] + 168) &= ~0x20u;
        *(_WORD *)(a1[9] + 168) &= ~0x40u;
        __OSKextClearHasAllDependenciesOnKext(a1);
      }
      OSKextFlushDiagnostics((uint64_t)a1, 4);
    }
  }
  else if (__sOSKextsByURL)
  {
    OSKextFlushDependencies_flushingAll = 1;
    OSKextLog(0, 262150, "Flushing dependencies for all kexts.", v2, v3, v4, v5, v6, v10);
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushDependenciesApplierFunction, 0);
    OSKextFlushDependencies_flushingAll = 0;
  }
}

void OSKextFlushDiagnostics(uint64_t a1, int a2)
{
  pthread_once(&__sOSKextInitialized, (void (*)(void))__OSKextInitialize);
  if (a1)
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 64);
    if (!v4) {
      return;
    }
    if (a2)
    {
      if (*v4)
      {
        CFRelease(*v4);
        uint64_t v4 = *(CFTypeRef **)(a1 + 64);
      }
      *uint64_t v4 = 0;
      if ((a2 & 2) == 0)
      {
LABEL_5:
        if ((a2 & 4) == 0) {
          goto LABEL_6;
        }
        goto LABEL_17;
      }
    }
    else if ((a2 & 2) == 0)
    {
      goto LABEL_5;
    }
    if (v4[1])
    {
      CFRelease(v4[1]);
      uint64_t v4 = *(CFTypeRef **)(a1 + 64);
    }
    v4[1] = 0;
    if ((a2 & 4) == 0)
    {
LABEL_6:
      if ((a2 & 8) == 0) {
        goto LABEL_7;
      }
      goto LABEL_20;
    }
LABEL_17:
    if (v4[2])
    {
      CFRelease(v4[2]);
      uint64_t v4 = *(CFTypeRef **)(a1 + 64);
    }
    void v4[2] = 0;
    if ((a2 & 8) == 0)
    {
LABEL_7:
      if ((a2 & 0x10) == 0)
      {
LABEL_26:
        if ((~a2 & 0x1F) == 0)
        {
          free(v4);
          *(void *)(a1 + 64) = 0;
        }
        return;
      }
LABEL_23:
      if (v4[4])
      {
        CFRelease(v4[4]);
        uint64_t v4 = *(CFTypeRef **)(a1 + 64);
      }
      v4[4] = 0;
      goto LABEL_26;
    }
LABEL_20:
    if (v4[3])
    {
      CFRelease(v4[3]);
      uint64_t v4 = *(CFTypeRef **)(a1 + 64);
    }
    v4[3] = 0;
    if ((a2 & 0x10) == 0) {
      goto LABEL_26;
    }
    goto LABEL_23;
  }
  if (__sOSKextsByURL)
  {
    int context = a2;
    CFDictionaryApplyFunction((CFDictionaryRef)__sOSKextsByURL, (CFDictionaryApplierFunction)__OSKextFlushDiagnosticsApplierFunction, &context);
  }
}

uint64_t __OSKextFlushDependenciesApplierFunction(uint64_t a1, uint64_t a2)
{
  return OSKextFlushDependencies(a2);
}

uint64_t OSKextValidateDependencies(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2 && (*(_WORD *)(v2 + 168) & 0x20) != 0) {
    return 1;
  }
  CFArrayRef v3 = (const __CFArray *)__OSKextCopyDependenciesList(a1, 1, 1);
  if (!v3) {
    return 0;
  }
  CFArrayRef v4 = v3;
  CFIndex Count = CFArrayGetCount(v3);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    int v8 = 1;
    do
    {
      CFURLRef ValueAtIndex = (const __CFString **)CFArrayGetValueAtIndex(v4, v7);
      if (!__OSKextIsValid((uint64_t)ValueAtIndex, v10, v11, v12, v13, v14, v15, v16))
      {
        __OSKextAddDiagnostic(a1, 4, @"Dependencies have validation problems", ValueAtIndex[3], 0, v17, v18, v19, v22);
        int v8 = 0;
      }
      ++v7;
    }
    while (v6 != v7);
    if (!v8) {
      goto LABEL_14;
    }
  }
  if (__OSKextCreateLoadInfo(a1))
  {
    *(_WORD *)(*(void *)(a1 + 72) + 168) |= 0x20u;
    uint64_t v20 = 1;
  }
  else
  {
LABEL_14:
    uint64_t v20 = 0;
  }
  CFRelease(v4);
  return v20;
}

uint64_t OSKextAuthenticateDependencies(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2 && (*(_WORD *)(v2 + 168) & 0x40) != 0) {
    return 1;
  }
  CFArrayRef v3 = (const __CFArray *)__OSKextCopyDependenciesList(a1, 1, 1);
  if (!v3) {
    return 0;
  }
  CFArrayRef v4 = v3;
  CFIndex Count = CFArrayGetCount(v3);
  if (Count < 1) {
    goto LABEL_21;
  }
  CFIndex v6 = Count;
  CFIndex v7 = 0;
  int v8 = 1;
  do
  {
    CFURLRef ValueAtIndex = (const __CFString **)CFArrayGetValueAtIndex(v4, v7);
    if (!OSKextIsAuthentic((uint64_t)ValueAtIndex, v10, v11, v12, v13, v14, v15, v16))
    {
      __OSKextAddDiagnostic(a1, 4, @"Dependencies have incorrect owner/permissions", ValueAtIndex[3], 0, v17, v18, v19, v27);
      int v8 = 0;
    }
    ++v7;
  }
  while (v6 != v7);
  if (v8)
  {
LABEL_21:
    if (__OSKextCreateLoadInfo(a1)) {
      *(_WORD *)(*(void *)(a1 + 72) + 168) |= 0x40u;
    }
    else {
      OSKextLog(0, 17, "Memory allocation failure.", v20, v21, v22, v23, v24, v27);
    }
    uint64_t v25 = 1;
  }
  else
  {
    uint64_t v25 = 0;
  }
  CFRelease(v4);
  return v25;
}

CFArrayRef OSKextCopyDeclaredDependencies(void *a1, int a2)
{
  int v4 = OSKextResolveDependencies((uint64_t)a1);
  if (a2 && !v4) {
    return 0;
  }
  CFIndex v6 = (void *)a1[9];
  if (v6 && *v6)
  {
    CFAllocatorRef v7 = CFGetAllocator(a1);
    CFArrayRef v8 = *(const __CFArray **)a1[9];
    return CFArrayCreateCopy(v7, v8);
  }
  else
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    return CFArrayCreate(v9, 0, 0, v10);
  }
}

BOOL __OSKextGetBleedthroughFlag(uint64_t a1)
{
  return (*((unsigned char *)__sOSKextArchInfo + 11) & 1) == 0 && (*(_WORD *)(*(void *)(a1 + 72) + 168) & 4) == 0;
}

CFMutableArrayRef OSKextCopyLinkDependencies(const void *a1, uint64_t a2)
{
  int v4 = OSKextResolveDependencies((uint64_t)a1);
  if (a2 && !v4) {
    return 0;
  }
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v13);
    return Mutable;
  }
  if (!__OSKextAddLinkDependencies((uint64_t)a1, Mutable, a2, 0))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t __OSKextAddLinkDependencies(uint64_t a1, const __CFArray *a2, uint64_t a3, int a4)
{
  if ((*(unsigned char *)(a1 + 92) & 1) == 0)
  {
    uint64_t v6 = *(const __CFArray ***)(a1 + 72);
    if (!v6) {
      return a3 == 0;
    }
    CFArrayRef v7 = *v6;
    if (!*v6) {
      return a3 == 0;
    }
    if (a4)
    {
      BOOL BleedthroughFlag = 1;
    }
    else
    {
      BOOL BleedthroughFlag = __OSKextGetBleedthroughFlag(a1);
      CFArrayRef v7 = **(const __CFArray ***)(a1 + 72);
    }
    CFIndex Count = CFArrayGetCount(v7);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(**(CFArrayRef **)(a1 + 72), i);
        uint64_t v15 = ValueAtIndex;
        if (!BleedthroughFlag && (ValueAtIndex[92] & 4) != 0) {
          goto LABEL_14;
        }
        uint64_t result = __OSKextAddLinkDependencies(ValueAtIndex, a2, a3, BleedthroughFlag);
        if (!result) {
          return result;
        }
        if ((v15[92] & 4) != 0)
        {
LABEL_14:
          v16.CFIndex length = CFArrayGetCount(a2);
          v16.CFIndex location = 0;
          if (CFArrayGetFirstIndexOfValue(a2, v16, v15) == -1) {
            CFArrayAppendValue(a2, v15);
          }
        }
      }
    }
  }
  return 1;
}

__CFArray *OSKextCopySymbolReferences(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v10 = Mutable;
    if (__OSKextReadSymbolReferences((uint64_t)a1, Mutable, v4, v5, v6, v7, v8, v9))
    {
      CFAllocatorRef v11 = CFGetAllocator(v10);
      uint64_t v17 = CFArrayCreateMutable(v11, 0, MEMORY[0x1E4F1D510]);
      if (!v17)
      {
        OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, v29);
        goto LABEL_11;
      }
      CFIndex Count = CFDictionaryGetCount(v10);
      if (!Count)
      {
LABEL_11:
        CFRelease(v10);
        return v17;
      }
      CFIndex v19 = Count;
      size_t v20 = 8 * Count;
      uint64_t v21 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (v21)
      {
        char v27 = v21;
        bzero(v21, v20);
        CFDictionaryGetKeysAndValues(v10, v27, 0);
        v30.CFIndex location = 0;
        v30.CFIndex length = 0;
        CFArrayReplaceValues(v17, v30, v27, v19);
        free(v27);
        goto LABEL_11;
      }
      OSKextLog(0, 17, "Memory allocation failure.", v22, v23, v24, v25, v26, v29);
      CFRelease(v17);
    }
    uint64_t v17 = 0;
    goto LABEL_11;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v29);
  return 0;
}

uint64_t __OSKextReadSymbolReferences(uint64_t a1, __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v57 = 0;
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  if ((*(_DWORD *)(a1 + 92) & 5) != 4) {
    return 1;
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  CFDataRef v10 = OSKextCopyExecutableForArchitecture(a1, (uint64_t)__sOSKextArchInfo);
  if (!v10)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    OSKextLog(a1, 1048577, "%s has no executable for architecture %s.", v17, v18, v19, v20, v21, (char)buffer);
    return 0;
  }
  CFDataRef v11 = v10;
  BytePtr = (int *)CFDataGetBytePtr(v10);
  unint64_t v13 = (unint64_t)BytePtr + CFDataGetLength(v11);
  int v14 = *BytePtr;
  if (*BytePtr == -17958193 || v14 == -805638658)
  {
    char v23 = 0;
    int v22 = 16;
  }
  else
  {
    int v22 = 12;
    char v23 = 1;
  }
  if (macho_find_symtab(BytePtr, v13, &v57))
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    uint64_t v49 = buffer;
    char v29 = "%s has no symtab in its executable (%s)";
LABEL_18:
    CFStringRef v35 = (CFStringRef)a1;
    int v36 = 1048577;
    goto LABEL_19;
  }
  unsigned int v30 = v57[2];
  unsigned int v31 = (v14 + 822415874) & 0xFEFFFFFF;
  if (v31)
  {
    unsigned int v32 = v57[3];
    unsigned int v33 = v57[4];
  }
  else
  {
    unsigned int v30 = bswap32(v30);
    unsigned int v33 = bswap32(v57[4]);
    unsigned int v32 = bswap32(v57[3]);
  }
  uint64_t v34 = (unsigned int *)((char *)BytePtr + v30);
  if ((unint64_t)v34 + v32 * v22 > v13)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    uint64_t v49 = buffer;
    char v29 = "%s: internal overrun in executable file (%s).";
    goto LABEL_18;
  }
  if (!v32)
  {
LABEL_42:
    uint64_t v16 = 1;
    goto LABEL_20;
  }
  CFMutableDictionaryRef theDict = a2;
  uint64_t v38 = 0;
  size_t v55 = (char *)BytePtr + v33;
  unint64_t v56 = v13;
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  xpc_object_t value = (void *)*MEMORY[0x1E4F1CFD0];
  uint64_t v51 = (unsigned int *)((char *)BytePtr + v30);
  uint64_t v39 = v32;
  CFIndex v40 = v51 + 1;
  uint64_t v41 = v51;
  char v52 = v23;
  while (1)
  {
    if (v23)
    {
      unsigned int v42 = bswap32(*((_DWORD *)v40 - 1));
      if (v31) {
        unsigned int v43 = *((_DWORD *)v40 - 1);
      }
      else {
        unsigned int v43 = v42;
      }
      uint64_t v44 = v40;
      if (!v43) {
        goto LABEL_41;
      }
    }
    else
    {
      unsigned int v45 = bswap32(*v41);
      if (v31) {
        unsigned int v43 = *v41;
      }
      else {
        unsigned int v43 = v45;
      }
      uint64_t v44 = (char *)&v34[4 * v38 + 1];
      if (!v43) {
        goto LABEL_41;
      }
    }
    if ((*v44 & 0xEE) == 0) {
      break;
    }
LABEL_41:
    ++v38;
    v40 += 12;
    v41 += 4;
    if (!--v39) {
      goto LABEL_42;
    }
  }
  BOOL v46 = &v55[v43];
  if ((unint64_t)v46 >= v56) {
    size_t v47 = 0;
  }
  else {
    size_t v47 = strnlen(&v55[v43], v56 - (void)v46);
  }
  if ((unint64_t)&v46[v47] >= v56)
  {
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    uint64_t v49 = buffer;
    char v29 = "%s: internal overrun (%p, string_index: %d, file_end: %p) in executable file (%s).";
    goto LABEL_18;
  }
  CFStringRef v35 = CFStringCreateWithCString(alloc, v46, 0x600u);
  if (v35)
  {
    CFStringRef v48 = v35;
    CFDictionarySetValue(theDict, v35, value);
    CFRelease(v48);
    char v23 = v52;
    uint64_t v34 = v51;
    goto LABEL_41;
  }
  char v29 = "Memory allocation failure.";
  int v36 = 17;
LABEL_19:
  OSKextLog((uint64_t)v35, v36, v29, v24, v25, v26, v27, v28, (char)v49);
  uint64_t v16 = 0;
LABEL_20:
  CFRelease(v11);
  return v16;
}

CFTypeRef OSKextFindLinkDependencies(const void *a1, int a2, int a3, CFTypeRef *a4, CFTypeRef *a5, CFTypeRef *a6, CFTypeRef *a7)
{
  uint64_t v151 = *MEMORY[0x1E4F143B8];
  uint64_t AllKexts = OSKextGetAllKexts();
  if (!AllKexts) {
    return 0;
  }
  CFArrayRef v17 = (const __CFArray *)AllKexts;
  uint64_t v142 = a4;
  uint64_t v143 = a5;
  __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, v13, v14, v15, v16);
  OSKextLog((uint64_t)a1, 1064965, "Searching for link dependencies of %s.", v18, v19, v20, v21, v22, (char)buffer);
  CFAllocatorRef v23 = CFGetAllocator(a1);
  uint64_t v24 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef Mutable = CFArrayCreateMutable(v23, 0, MEMORY[0x1E4F1D510]);
  CFAllocatorRef v26 = CFGetAllocator(a1);
  uint64_t v27 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v28 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  char v29 = CFDictionaryCreateMutable(v26, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFAllocatorRef v30 = CFGetAllocator(a1);
  CFMutableDictionaryRef v31 = CFDictionaryCreateMutable(v30, 0, v27, v28);
  CFAllocatorRef v32 = CFGetAllocator(a1);
  CFMutableDictionaryRef v33 = CFDictionaryCreateMutable(v32, 0, v27, v28);
  CFAllocatorRef v34 = CFGetAllocator(a1);
  CFMutableArrayRef v35 = CFArrayCreateMutable(v34, 0, v24);
  CFArrayRef v42 = v35;
  if (!Mutable || !v29 || !v31 || !v33 || !v35)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v37, v38, v39, v40, v41, v124);
    CFTypeRef v112 = 0;
    goto LABEL_85;
  }
  if (!__OSKextReadSymbolReferences((uint64_t)a1, v29, v36, v37, v38, v39, v40, v41))
  {
    CFTypeRef v112 = 0;
    goto LABEL_109;
  }
  CFDictionaryRef theDict = v33;
  CFArrayRef v141 = v42;
  uint64_t v139 = v29;
  CFIndex Count = CFArrayGetCount(v17);
  CFDictionaryRef v144 = v31;
  if (Count < 1) {
    goto LABEL_95;
  }
  CFIndex v44 = Count;
  CFIndex v45 = 0;
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v17, v45);
    if (ValueAtIndex == a1) {
      goto LABEL_74;
    }
    size_t v47 = ValueAtIndex;
    if (*((uint64_t *)ValueAtIndex + 6) < 1) {
      goto LABEL_74;
    }
    if ((*((unsigned char *)ValueAtIndex + 92) & 4) == 0) {
      goto LABEL_74;
    }
    CFStringRef v48 = (const __CFString *)*((void *)ValueAtIndex + 3);
    if (!a3
      && (CFEqual(v48, @"com.apple.kernel.unsupported")
       || CFEqual(v48, @"com.apple.kpi.unsupported")
       || CFEqual(v48, @"com.apple.kpi.private")
       || CFEqual(v48, @"com.apple.kpi.dsep")))
    {
      goto LABEL_74;
    }
    CFStringRef v49 = a2 ? @"com.apple.kpi." : @"com.apple.kernel.";
    if (CFStringHasPrefix(v48, v49)) {
      goto LABEL_74;
    }
    long long v147 = 0;
    __OSKextGetFileSystemPath((uint64_t)v47, 0, 0, v150, v50, v51, v52, v53);
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    CFDataRef v54 = OSKextCopyExecutableForArchitecture((uint64_t)v47, (uint64_t)__sOSKextArchInfo);
    if (!v54) {
      goto LABEL_74;
    }
    CFDataRef v55 = v54;
    BytePtr = (int *)CFDataGetBytePtr(v54);
    CFDataRef cf = v55;
    CFIndex Length = CFDataGetLength(v55);
    int v58 = *BytePtr;
    CFArrayRef v137 = Mutable;
    uint64_t v138 = a6;
    if (*BytePtr == -17958193 || v58 == -805638658)
    {
      char v134 = 0;
      int v59 = 16;
    }
    else
    {
      int v59 = 12;
      char v134 = 1;
    }
    uint64_t v60 = (char *)BytePtr + Length;
    if (macho_find_symtab(BytePtr, (unint64_t)BytePtr + Length, &v147))
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      OSKextLog((uint64_t)v47, 1048577, "%s has no symtab in its executable (%s)", v61, v62, v63, v64, v65, (char)v150);
LABEL_30:
      CFArrayRef Mutable = v137;
      a6 = v138;
      CFMutableDictionaryRef v31 = v144;
      goto LABEL_73;
    }
    unsigned int v66 = v147[2];
    unsigned int v67 = (v58 + 822415874) & 0xFEFFFFFF;
    if (v67)
    {
      unsigned int v69 = v147[3];
      unsigned int v68 = v147[4];
    }
    else
    {
      unsigned int v66 = bswap32(v66);
      unsigned int v68 = bswap32(v147[4]);
      unsigned int v69 = bswap32(v147[3]);
    }
    uint64_t v70 = (unsigned int *)((char *)BytePtr + v66);
    CFMutableDictionaryRef v31 = v144;
    if ((char *)v70 + v69 * v59 > v60)
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      OSKextLog((uint64_t)v47, 1048577, "%s - internal overrun in executable file (%s).", v71, v72, v73, v74, v75, (char)v150);
      CFArrayRef Mutable = v137;
      a6 = v138;
LABEL_73:
      CFRelease(cf);
      goto LABEL_74;
    }
    CFArrayRef Mutable = v137;
    a6 = v138;
    if (!v69) {
      goto LABEL_73;
    }
    uint64_t v126 = a7;
    uint64_t v76 = 0;
    int theArray = 0;
    CFStringRef v77 = 0;
    int v127 = 0;
    CFIndex v130 = (char *)BytePtr + v68;
    uint64_t v78 = v69;
    uint64_t v79 = (uint64_t)BytePtr + v66 + 4;
    uint64_t v80 = v70;
    char v81 = v134;
    unsigned int v129 = v67;
    uint64_t v128 = v70;
    do
    {
      if (v81)
      {
        unsigned int v82 = bswap32(*(_DWORD *)(v79 - 4));
        if (v67) {
          unsigned int v83 = *(_DWORD *)(v79 - 4);
        }
        else {
          unsigned int v83 = v82;
        }
        __int16 v84 = (unsigned int *)v79;
        if (!v83) {
          goto LABEL_61;
        }
      }
      else
      {
        unsigned int v85 = bswap32(*v80);
        if (v67) {
          unsigned int v83 = *v80;
        }
        else {
          unsigned int v83 = v85;
        }
        __int16 v84 = &v70[4 * v76 + 1];
        if (!v83)
        {
LABEL_61:
          CFMutableDictionaryRef v31 = v144;
          goto LABEL_62;
        }
      }
      unsigned int v86 = *(unsigned __int8 *)v84;
      if (v86 > 0x1F) {
        goto LABEL_61;
      }
      int v87 = v86 & 0xE;
      if (!v87) {
        goto LABEL_52;
      }
      if (v87 != 14)
      {
        if (v87 != 10) {
          goto LABEL_61;
        }
LABEL_52:
        if ((v47[23] & 1) == 0) {
          goto LABEL_61;
        }
        goto LABEL_53;
      }
      if (v47[23]) {
        goto LABEL_61;
      }
LABEL_53:
      if (v77) {
        CFRelease(v77);
      }
      CFStringRef v88 = CFStringCreateWithCString(alloc, &v130[v83], 0x600u);
      if (!v88)
      {
        OSKextLog(0, 17, "Memory allocation failure.", v89, v90, v91, v92, v93, v124);
        a7 = v126;
        goto LABEL_30;
      }
      CFStringRef key = v88;
      uint64_t v94 = (__CFArray *)CFDictionaryGetValue(theDict, v88);
      if (v94)
      {
        CFArrayAppendValue(v94, v47);
        int theArray = 1;
      }
      else
      {
        CFMutableDictionaryRef v31 = v144;
        uint64_t v95 = (void *)CFDictionaryGetValue(v144, key);
        if (v95)
        {
          xpc_object_t value = v95;
          uint64_t v96 = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
          if (!v96)
          {
            OSKextLog(0, 17, "Memory allocation failure.", v97, v98, v99, v100, v101, v124);
            int v102 = 1;
            CFStringRef v77 = key;
            goto LABEL_77;
          }
          theArraya = v96;
          CFArrayAppendValue(v96, value);
          CFArrayAppendValue(theArraya, v47);
          CFDictionarySetValue(theDict, key, theArraya);
          CFRelease(theArraya);
          if (!v127)
          {
            v152.CFIndex length = CFArrayGetCount(v141);
            v152.CFIndex location = 0;
            if (CFArrayGetFirstIndexOfValue(v141, v152, v47) == -1) {
              CFArrayAppendValue(v141, v47);
            }
          }
          CFDictionaryRemoveValue(v144, key);
          CFStringRef v77 = key;
          int v127 = 1;
          int theArray = 1;
          char v81 = v134;
          unsigned int v67 = v129;
          goto LABEL_70;
        }
        if (CFDictionaryGetValue(v139, key))
        {
          CFDictionarySetValue(v144, key, v47);
          CFMutableDictionaryRef v31 = v144;
          CFDictionaryRemoveValue(v139, key);
          int theArray = 1;
          goto LABEL_59;
        }
      }
      CFMutableDictionaryRef v31 = v144;
LABEL_59:
      char v81 = v134;
      unsigned int v67 = v129;
      CFStringRef v77 = key;
LABEL_70:
      uint64_t v70 = v128;
LABEL_62:
      ++v76;
      v79 += 12;
      v80 += 4;
      --v78;
    }
    while (v78);
    int v102 = theArray;
    if (!v77) {
      goto LABEL_78;
    }
LABEL_77:
    CFRelease(v77);
LABEL_78:
    CFRelease(cf);
    a7 = v126;
    CFArrayRef Mutable = v137;
    a6 = v138;
    if (v102)
    {
      __OSKextGetFileSystemPath((uint64_t)v47, 0, 0, v148, v103, v104, v105, v106);
      OSKextLog((uint64_t)a1, 1064966, "%s found link dependency %s.", v107, v108, v109, v110, v111, (char)buffer);
      v153.CFIndex length = CFArrayGetCount(v137);
      v153.CFIndex location = 0;
      if (CFArrayGetFirstIndexOfValue(v137, v153, v47) == -1) {
        CFArrayAppendValue(v137, v47);
      }
    }
LABEL_74:
    ++v45;
  }
  while (v45 != v44);
LABEL_95:
  v154.CFIndex length = CFArrayGetCount(Mutable);
  v154.CFIndex location = 0;
  CFArraySortValues(Mutable, v154, (CFComparatorFunction)__OSKextCompareIdentifiers, 0);
  CFArrayRef v42 = v141;
  v155.CFIndex length = CFArrayGetCount(v141);
  v155.CFIndex location = 0;
  CFArraySortValues(v141, v155, (CFComparatorFunction)__OSKextCompareIdentifiers, 0);
  CFTypeRef v112 = CFRetain(Mutable);
  if (v112)
  {
    char v29 = v139;
    CFMutableDictionaryRef v33 = theDict;
    if (CFDictionaryGetCount(v139)) {
      OSKextLog((uint64_t)a1, 1064966, "%s has %d remaining undefined symbol%s", v114, v115, v116, v117, v118, (char)buffer);
    }
    if (CFDictionaryGetCount(theDict)) {
      OSKextLog((uint64_t)a1, 1064966, "%s has multiply defined %ld symbol%s", v119, v120, v121, v122, v123, (char)buffer);
    }
    if (v142) {
      *uint64_t v142 = CFRetain(v139);
    }
    CFMutableDictionaryRef v31 = v144;
    if (v143) {
      *uint64_t v143 = CFRetain(v144);
    }
    if (a6) {
      *a6 = CFRetain(theDict);
    }
    CFArrayRef v42 = v141;
    if (a7) {
      *a7 = CFRetain(v141);
    }
  }
  else
  {
    char v29 = v139;
    CFMutableDictionaryRef v33 = theDict;
  }
LABEL_85:
  if (!Mutable)
  {
    if (v29) {
      goto LABEL_87;
    }
    goto LABEL_88;
  }
LABEL_109:
  CFRelease(Mutable);
  if (v29) {
LABEL_87:
  }
    CFRelease(v29);
LABEL_88:
  if (v31) {
    CFRelease(v31);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v42) {
    CFRelease(v42);
  }
  return v112;
}

CFComparisonResult __OSKextCompareIdentifiers(uint64_t a1, uint64_t a2)
{
  return CFStringCompare(*(CFStringRef *)(a1 + 24), *(CFStringRef *)(a2 + 24), 0x201uLL);
}

CFMutableArrayRef __OSKextCopyDependenciesList(const void *a1, int a2, int a3)
{
  int v6 = OSKextResolveDependencies((uint64_t)a1);
  if (a2 && !v6) {
    return 0;
  }
  CFAllocatorRef v7 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v15 = Mutable;
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v10, v11, v12, v13, v14, v17);
    return v15;
  }
  CFMutableArrayRef v18 = Mutable;
  int v19 = a3;
  int v20 = 0;
  uint64_t v21 = 0;
  __OSKextAddDependenciesApplierFunction((uint64_t)a1, &v18, v9, v10, v11, v12, v13, v14);
  if ((_BYTE)v21)
  {
    CFRelease(v15);
    return 0;
  }
  return v15;
}

CFMutableArrayRef OSKextCopyIndirectDependencies(const void *a1, int a2)
{
  return __OSKextCopyDependenciesList(a1, a2, 2);
}

CFArrayRef OSKextDependsOnKext(uint64_t a1, const void *a2, int a3)
{
  OSKextResolveDependencies(a1);
  int v6 = *(const __CFArray ***)(a1 + 72);
  if (!v6) {
    return 0;
  }
  CFArrayRef result = *v6;
  if (!*v6) {
    return result;
  }
  CFIndex Count = CFArrayGetCount(result);
  if (Count < 1) {
    return 0;
  }
  CFIndex v9 = Count;
  CFIndex v10 = 0;
  while (CFArrayGetValueAtIndex(**(CFArrayRef **)(a1 + 72), v10) != a2 && (a3 || !OSKextDependsOnKext()))
  {
    if (v9 == ++v10) {
      return 0;
    }
  }
  return (const __CFArray *)1;
}

__CFArray *OSKextCopyDependents(const void *a1, int a2)
{
  uint64_t AllKexts = OSKextGetAllKexts();
  if (!AllKexts) {
    return 0;
  }
  CFArrayRef v5 = (const __CFArray *)AllKexts;
  OSKextResolveDependencies(0);
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFIndex Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      CFIndex v14 = Count;
      for (CFIndex i = 0; i != v14; ++i)
      {
        CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v5, i);
        if (OSKextDependsOnKext((uint64_t)ValueAtIndex, a1, a2)) {
          CFArrayAppendValue(Mutable, ValueAtIndex);
        }
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v7, v8, v9, v10, v11, v18);
  }
  return Mutable;
}

void __OSKextLogDependencyGraphApplierFunction(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  uint64_t context = *a2;
  if (!OSKextResolveDependencies(a1)) {
    return;
  }
  if (!v10)
  {
    char v17 = 0;
LABEL_6:
    if ((v10 & 0xFF00000000) != 0)
    {
      CFStringRef PathComponent = *(CFStringRef *)(a1 + 24);
      CFRetain(PathComponent);
    }
    else
    {
      CFStringRef PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a1 + 16));
    }
    CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString(PathComponent);
    if (UTF8CStringForCFString)
    {
      OSKextVersionGetString(*(void *)(a1 + 40), v30, 0x14u);
      uint64_t v25 = "";
      if (v17) {
        LOBYTE(v25) = (_BYTE)v17;
      }
      OSKextLog(0, 0x4000, "%s%s (%s)%s", v20, v21, v22, v23, v24, (char)v25);
      LODWORD(context) = v10 + 4;
      if ((v10 & 0xFF0000000000) != 0)
      {
        CFMutableArrayRef v26 = OSKextCopyLinkDependencies((const void *)a1, 0);
        CFArrayRef v27 = v26;
        if (!v26)
        {
LABEL_22:
          if (!v17)
          {
LABEL_24:
            if (UTF8CStringForCFString) {
              free(UTF8CStringForCFString);
            }
            if (PathComponent) {
              CFRelease(PathComponent);
            }
            if (v26) {
              CFRelease(v26);
            }
            return;
          }
LABEL_23:
          free(v17);
          goto LABEL_24;
        }
LABEL_21:
        v33.CFIndex length = CFArrayGetCount(v27);
        v33.CFIndex location = 0;
        CFArrayApplyFunction(v27, v33, (CFArrayApplierFunction)__OSKextLogDependencyGraphApplierFunction, &context);
        goto LABEL_22;
      }
      uint64_t v28 = *(const __CFArray ***)(a1 + 72);
      if (v28)
      {
        CFMutableArrayRef v26 = 0;
        CFArrayRef v27 = *v28;
        if (!*v28) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
    }
    CFMutableArrayRef v26 = 0;
    if (!v17) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  uint64_t v11 = malloc_type_malloc((v10 + 1), 0x100004077774924uLL);
  if (v11)
  {
    char v17 = v11;
    memset(v11, 32, v10);
    *((unsigned char *)v17 + v1(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
    goto LABEL_6;
  }

  OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, a9);
}

void OSKextLogDependencyGraph(uint64_t a1, char a2, char a3)
{
  uint64_t v11 = 0;
  BYTE4(v11) = a2;
  BYTE5(v11) = a3;
  OSKextResolveDependencies(a1);
  __OSKextLogDependencyGraphApplierFunction(a1, &v11, v4, v5, v6, v7, v8, v9, v10);
}

uint64_t OSKextLoad(uint64_t a1)
{
  return OSKextLoadWithOptions(a1, 0, 2, 0, 0);
}

uint64_t OSKextLoadWithOptions(uint64_t a1, char a2, char a3, const void *a4, int a5)
{
  kern_return_t v167;
  UInt8 buffer[1024];
  uint64_t v169;

  __int16 v169 = *MEMORY[0x1E4F143B8];
  char valuePtr = a2;
  char v162 = a3;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    uint64_t LoadedKextInfo = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v9, v10, v11, v12, v13, (char)op_result);
    return LoadedKextInfo;
  }
  uint64_t v14 = Mutable;
  CFDictionarySetValue(Mutable, @"CFBundleIdentifier", *(const void **)(a1 + 24));
  CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
  CFNumberRef v16 = CFNumberCreate(v15, kCFNumberSInt8Type, &valuePtr);
  if (!v16)
  {
    uint64_t LoadedKextInfo = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, (char)op_result);
    uint64_t v63 = v14;
LABEL_55:
    CFRelease(v63);
    return LoadedKextInfo;
  }
  CFNumberRef v22 = v16;
  CFDictionarySetValue(v14, @"Start Exclude Level", v16);
  CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
  CFNumberRef v24 = CFNumberCreate(v23, kCFNumberSInt8Type, &v162);
  CFNumberRef v30 = v24;
  if (!v24)
  {
    uint64_t LoadedKextInfo = 3690987521;
    uint64_t v64 = "Memory allocation failure.";
    int v65 = 17;
    goto LABEL_52;
  }
  CFDictionarySetValue(v14, @"Start Matching Exclude Level", v24);
  if (a4) {
    CFDictionarySetValue(v14, @"Personality Names", a4);
  }
  if (a5) {
    CFDictionarySetValue(v14, @"Delay Autounload", (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  uint64_t LoadedKextInfo = 3690987521;
  uint64_t v167 = -603979775;
  *(void *)&size[1] = 0;
  size[0] = 0;
  *(void *)&address[1] = 0;
  address[0] = 0;
  host_priv_t v32 = MEMORY[0x18C1311A0]();
  if (!v32)
  {
    OSKextLog(a1, 33, "Process must be running as root to load kexts.", v33, v34, v35, v36, v37, (char)op_result);
    uint64_t LoadedKextInfo = 3691020292;
    goto LABEL_45;
  }
  host_priv_t v38 = v32;
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, v34, v35, v36, v37);
  if (!__OSKextIsValid(a1, v39, v40, v41, v42, v43, v44, v45))
  {
    OSKextLog(a1, 33, "Can't load %s - validation problems.", v46, v47, v48, v49, v50, (char)buffer);
    uint64_t LoadedKextInfo = 3691020300;
    goto LABEL_45;
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (!OSKextSupportsArchitecture(a1, __sOSKextArchInfo))
  {
    OSKextLog(a1, 33, "Can't load %s - no code for running kernel's architecture.", v51, v52, v53, v54, v55, (char)buffer);
    uint64_t LoadedKextInfo = 3691020303;
    goto LABEL_45;
  }
  if (!(OSKextGetActualSafeBoot() | __sOSKextSimulatedSafeBoot)
    || (*(unsigned char *)(a1 + 92) & 0x80) != 0)
  {
    if (!OSKextIsAuthentic(a1, v56, v57, v58, v59, v60, v61, v62))
    {
      uint64_t LoadedKextInfo = 3691020301;
      OSKextLog(a1, 33, "Can't load %s - authentication problems.", v66, v67, v68, v69, v70, (char)buffer);
      goto LABEL_45;
    }
    if (!__sOSKextLoadAuditFunction)
    {
      OSKextLog(a1, 33, "No load audit function set, cannot load %s", v66, v67, v68, v69, v70, (char)buffer);
      goto LABEL_45;
    }
    OSKextFlushLoadInfo(0, 1);
    CFMutableArrayRef v71 = __OSKextCopyDependenciesList((const void *)a1, 1, 0);
    if (!v71)
    {
      OSKextLog(a1, 33, "Can't load %s - failed to resolve dependencies.", v72, v73, v74, v75, v76, (char)buffer);
      uint64_t LoadedKextInfo = 3691020302;
      goto LABEL_45;
    }
    CFArrayRef v77 = v71;
    if (OSKextAuthenticateDependencies(a1))
    {
      if (OSKextDependenciesAreLoadableInSafeBoot((const void *)a1))
      {
        uint64_t Count = CFArrayGetCount(v77);
        CFAllocatorRef v84 = CFGetAllocator((CFTypeRef)a1);
        CFMutableArrayRef v85 = CFArrayCreateMutable(v84, Count, MEMORY[0x1E4F1D510]);
        if (v85)
        {
          uint64_t v91 = v85;
          if (Count >= 1)
          {
            for (CFIndex i = 0; i != Count; ++i)
            {
              CFURLRef ValueAtIndex = (const void **)CFArrayGetValueAtIndex(v77, i);
              CFArrayAppendValue(v91, ValueAtIndex[3]);
            }
          }
          CFRelease(v77);
          uint64_t LoadedKextInfo = OSKextReadLoadedKextInfo(v91, 1);
          if (!LoadedKextInfo)
          {
            if (!OSKextIsLoaded((unint64_t *)a1, v94, v95, v96, v97, v98, v99, v100)
              && ((BOOL v164 = 0,
                   BOOL IsLoaded = OSKextOtherVersionIsLoaded((unint64_t *)a1, &v164, v114, v115, v116, v117, v118, v119), v164)|| IsLoaded))
            {
              OSKextLog(a1, 33, "Can't load %s - a different %s is already loaded.", v156, v157, v158, v159, v160, (char)buffer);
              uint64_t LoadedKextInfo = 3691020308;
            }
            else
            {
              CFMutableArrayRef v120 = __OSKextCopyDependenciesList((const void *)a1, 1, 0);
              if (v120)
              {
                CFArrayRef v126 = v120;
                if (OSKextAuthenticateDependencies(a1))
                {
                  CFAllocatorRef v132 = CFGetAllocator((CFTypeRef)a1);
                  CFDataRef Mkext = __OSKextCreateMkext(v132, v126, 0, 0, 0, 1, v14);
                  CFDataRef v139 = Mkext;
                  if (Mkext)
                  {
                    BytePtr = CFDataGetBytePtr(Mkext);
                    mach_msg_type_number_t Length = CFDataGetLength(v139);
                    OSKextLog(a1, 36, "Loading %s.", v142, v143, v144, v145, v146, (char)buffer);
                    if (__sOSKextLogOutputFunction) {
                      uint32_t v147 = __sKernelLogFilter;
                    }
                    else {
                      uint32_t v147 = 0;
                    }
                    uint64_t v148 = kext_request(v38, v147, (vm_offset_t)BytePtr, Length, (vm_offset_t *)&size[1], size, (vm_offset_t *)&address[1], address, &v167);
                    uint64_t v149 = __OSKextProcessKextRequestResults(a1, v148, v167, *(char **)&address[1], address[0]);
                    uint64_t LoadedKextInfo = v149;
                    if (v149)
                    {
                      mach_error_string(v149);
                      OSKextLog(a1, 33, "Failed to load %s - %s.", v150, v151, v152, v153, v154, (char)buffer);
                    }
                  }
                  else
                  {
                    OSKextLog(a1, 33, "Can't create kernel load request for %s.", v134, v135, v136, v137, v138, (char)buffer);
                    uint64_t LoadedKextInfo = 0;
                  }
                }
                else
                {
                  uint64_t LoadedKextInfo = 3691020301;
                  OSKextLog(a1, 33, "Can't load %s - dependency authentication problems.", v127, v128, v129, v130, v131, (char)buffer);
                  CFDataRef v139 = 0;
                }
                CFRelease(v91);
                CFRelease(v126);
                if (!v139) {
                  goto LABEL_45;
                }
                CFDataRef v101 = v139;
                goto LABEL_44;
              }
              OSKextLog(a1, 33, "Can't load %s - failed to resolve dependencies based on loaded kexts.", v121, v122, v123, v124, v125, (char)buffer);
              uint64_t LoadedKextInfo = 3691020302;
            }
          }
          CFDataRef v101 = v91;
LABEL_44:
          CFRelease(v101);
          goto LABEL_45;
        }
        OSKextLog(0, 17, "Memory allocation failure.", v86, v87, v88, v89, v90, (char)op_result);
      }
      else
      {
        CFDictionaryRef Diagnostics = __OSKextGetDiagnostics(a1, 16);
        if (Diagnostics
          && (CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(Diagnostics, @"Dependencies aren't loadable during safe boot")) != 0&& (v109 = Value, CFArrayGetCount(Value))&& (CFStringForPlist_new = createCFStringForPlist_new(v109, 2)) != 0)
        {
          uint64_t v111 = CFStringForPlist_new;
          OSKextLogCFString(a1, 33, @"Can't load %s - dependencies ineligible during safe boot:\n%@", v103, v104, v105, v106, v107, (char)buffer);
          CFRelease(v111);
        }
        else
        {
          OSKextLogCFString(a1, 33, @"Can't load %s - dependencies ineligible during safe boot.", v103, v104, v105, v106, v107, (char)buffer);
        }
        uint64_t LoadedKextInfo = 3691020306;
      }
    }
    else
    {
      uint64_t LoadedKextInfo = 3691020301;
      OSKextLog(a1, 33, "Can't load %s - dependency authentication problems.", v78, v79, v80, v81, v82, (char)buffer);
    }
    CFDataRef v101 = v77;
    goto LABEL_44;
  }
  OSKextLog(a1, 33, "Can't load %s - ineligible during safe boot.", v58, v59, v60, v61, v62, (char)buffer);
  uint64_t LoadedKextInfo = 3691020306;
LABEL_45:
  CFTypeRef v112 = (vm_map_t *)MEMORY[0x1E4F14960];
  if (*(void *)&size[1]) {
    mach_vm_deallocate(*MEMORY[0x1E4F14960], *(mach_vm_address_t *)&size[1], size[0]);
  }
  if (*(void *)&address[1]) {
    mach_vm_deallocate(*v112, *(mach_vm_address_t *)&address[1], address[0]);
  }
  if (LoadedKextInfo)
  {
    __OSKextRemovePersonalities((const void *)a1, *(void **)(a1 + 24));
    goto LABEL_53;
  }
  op_CFArrayRef result = buffer;
  uint64_t v64 = "Successfully loaded %s.";
  CFNumberRef v24 = (CFNumberRef)a1;
  int v65 = 36;
LABEL_52:
  OSKextLog((uint64_t)v24, v65, v64, v25, v26, v27, v28, v29, (char)op_result);
LABEL_53:
  CFRelease(v14);
  CFRelease(v22);
  if (v30)
  {
    uint64_t v63 = v30;
    goto LABEL_55;
  }
  return LoadedKextInfo;
}

uint64_t __OSKextUnload(uint64_t a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef theDict = 0;
  if (a1)
  {
    unint64_t v10 = *(void *)(a1 + 24);
    CFDictionaryRef UTF8CStringForCFString = buffer;
    __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
    uint64_t v17 = 0;
  }
  else
  {
    unint64_t v10 = (unint64_t)a2;
    CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString(a2);
    uint64_t v17 = UTF8CStringForCFString;
  }
  OSKextLog(a1, 100, "Requesting unload of %s%s.", v12, v13, v14, v15, v16, (char)UTF8CStringForCFString);
  uint64_t v18 = __OSKextCreateKextRequest(@"Unload", v10, &theDict);
  uint64_t v19 = 3690987521;
  if (v18 && theDict)
  {
    if (a3) {
      CFDictionarySetValue(theDict, @"Terminate IOServices", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    uint64_t v20 = __OSKextSendKextRequest(a1, v18, 0, 0, 0);
    uint64_t v19 = v20;
    if (v20)
    {
      mach_error_string(v20);
      OSKextLog(a1, 65, "Failed to unload %s - %s.", v26, v27, v28, v29, v30, (char)UTF8CStringForCFString);
    }
    else
    {
      OSKextLog(a1, 100, "Successfully unloaded %s.", v21, v22, v23, v24, v25, (char)UTF8CStringForCFString);
    }
  }
  if (v17) {
    free(v17);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v19;
}

uint64_t OSKextUnload(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __OSKextUnload(a1, 0, a2, a4, a5, a6, a7, a8);
}

uint64_t OSKextUnloadKextWithIdentifier(const __CFString *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __OSKextUnload(0, a1, a2, a4, a5, a6, a7, a8);
}

uint64_t OSKextIsStarted(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[9];
  if (!v8) {
    return 0;
  }
  if (*(void *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    unint64_t v8 = a1[9];
  }
  return *(unsigned char *)(v8 + 169) & 1;
}

void __OSKextCheckLoaded(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  memset(v43, 0, 37);
  memset(out, 0, 37);
  unint64_t v8 = a1[9];
  if (!v8) {
    return;
  }
  if (*(void *)(v8 + 8))
  {
    __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, a5, a6, a7, a8);
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), @"OSBundleUUID");
    RunningKernelArchitecture = OSKextGetRunningKernelArchitecture((uint64_t)Value, v11, v12, v13, v14, v15, v16, v17);
    CFDataRef v19 = OSKextCopyUUIDForArchitecture(a1, RunningKernelArchitecture);
    CFDataRef v20 = v19;
    if (Value)
    {
      BytePtr = CFDataGetBytePtr(Value);
      uuid_unparse(BytePtr, out);
      if (!v20)
      {
        OSKextVersionGetString(a1[5], v40, 0x14u);
LABEL_10:
        *(_WORD *)(a1[9] + 168) |= 0x400u;
        OSKextLog((uint64_t)a1, 103, "%s (version %s%s%s): same version, different UUID (%s) is loaded.", v22, v23, v24, v25, v26, (char)buffer);
        goto LABEL_11;
      }
    }
    else if (!v19)
    {
      OSKextVersionGetString(a1[5], v40, 0x14u);
      goto LABEL_19;
    }
    uint64_t v27 = CFDataGetBytePtr(v20);
    uuid_unparse(v27, v43);
    OSKextVersionGetString(a1[5], v40, 0x14u);
    if (!Value || !CFEqual(Value, v20)) {
      goto LABEL_10;
    }
LABEL_19:
    *(_WORD *)(a1[9] + 168) |= 0x80u;
    OSKextLog((uint64_t)a1, 103, "%s (version %s%s%s) is loaded.", v22, v23, v24, v25, v26, (char)buffer);
    CFBooleanRef v30 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), @"OSBundleStarted");
    if (v30 && CFBooleanGetValue(v30))
    {
      *(_WORD *)(a1[9] + 168) |= 0x100u;
      OSKextLog((uint64_t)a1, 103, "%s (version %s): is%s started.", v31, v32, v33, v34, v35, (char)buffer);
    }
    CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), @"OSBundleLoadTag");
    if (v36)
    {
      LODWORD(valuePtr) = 0;
      if (CFNumberGetValue(v36, kCFNumberSInt32Type, &valuePtr)) {
        *(_DWORD *)(a1[9] + 16) = valuePtr;
      }
    }
    CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), @"OSBundleLoadAddress");
    if (v37)
    {
      unint64_t valuePtr = 0;
      if (CFNumberGetValue(v37, kCFNumberSInt64Type, &valuePtr)) {
        __OSKextSetLoadAddress((uint64_t)a1, valuePtr);
      }
    }
    CFNumberRef v38 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1[9] + 8), @"OSBundleLoadSize");
    if (v38)
    {
      LODWORD(valuePtr) = 0;
      if (CFNumberGetValue(v38, kCFNumberSInt32Type, &valuePtr)) {
        *(void *)(a1[9] + 48) = valuePtr;
      }
    }
    goto LABEL_11;
  }
  CFDataRef v20 = 0;
LABEL_11:
  unint64_t v28 = a1[9];
  if (v28)
  {
    uint64_t v29 = *(const void **)(v28 + 8);
    if (v29)
    {
      CFRelease(v29);
      unint64_t v28 = a1[9];
    }
    *(void *)(v28 + 8) = 0;
  }
  if (v20) {
    CFRelease(v20);
  }
}

uint64_t OSKextStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 100, "Requesting start of %s.", v9, v10, v11, v12, v13, (char)buffer);
  uint64_t v14 = __OSKextSimpleKextRequest(a1, @"Start");
  uint64_t v20 = v14;
  if (v14)
  {
    mach_error_string(v14);
    OSKextLog(a1, 33, "Failed to start %s - %s.", v21, v22, v23, v24, v25, (char)buffer);
  }
  else
  {
    OSKextLog(a1, 100, "Started %s.", v15, v16, v17, v18, v19, (char)buffer);
  }
  return v20;
}

uint64_t __OSKextSimpleKextRequest(uint64_t a1, const void *a2)
{
  if (a1) {
    unint64_t v4 = *(void *)(a1 + 24);
  }
  else {
    unint64_t v4 = 0;
  }
  KextRequest = __OSKextCreateKextRequest(a2, v4, 0);
  if (!KextRequest) {
    return 3691020289;
  }
  uint64_t v6 = KextRequest;
  uint64_t v7 = __OSKextSendKextRequest(a1, KextRequest, 0, 0, 0);
  CFRelease(v6);
  return v7;
}

uint64_t OSKextStop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 100, "Requesting stop of %s.", v9, v10, v11, v12, v13, (char)buffer);
  uint64_t v14 = __OSKextSimpleKextRequest(a1, @"Stop");
  uint64_t v20 = v14;
  if (v14)
  {
    mach_error_string(v14);
    OSKextLog(a1, 33, "Failed to stop %s - %s.", v21, v22, v23, v24, v25, (char)buffer);
  }
  else
  {
    OSKextLog(a1, 100, "Successfully stopped %s.", v15, v16, v17, v18, v19, (char)buffer);
  }
  return v20;
}

uint64_t OSKextSendPersonalitiesToKernel(const __CFArray *a1, int a2)
{
  uint64_t v2 = 3691020293;
  if (a2) {
    uint32_t v3 = 9;
  }
  else {
    uint32_t v3 = 1;
  }
  if (a1)
  {
    if (CFArrayGetCount(a1))
    {
      char Count = CFArrayGetCount(a1);
      CFArrayGetCount(a1);
      OSKextLog(0, 101, "Sending %d personalit%s to the kernel.", v6, v7, v8, v9, v10, Count);
      CFDataRef v11 = IOCFSerialize(a1, 0);
      if (v11)
      {
        CFDataRef v17 = v11;
        BytePtr = (const char *)CFDataGetBytePtr(v11);
        uint32_t Length = CFDataGetLength(v17);
        uint64_t v2 = IOCatalogueSendData(0, v3, BytePtr, Length);
        if (v2) {
          OSKextLog(0, 97, "Failed to send personalities to the kernel.", v20, v21, v22, v23, v24, v26);
        }
        CFRelease(v17);
      }
      else
      {
        OSKextLog(0, 33, "Can't serialize personalities.", v12, v13, v14, v15, v16, v26);
        return 3691020296;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t OSKextSendKextPersonalitiesToKernel(CFURLRef *a1, const __CFArray *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, a5, a6, a7, a8);
  if (!a2 || !CFArrayGetCount(a2))
  {
    CFArrayRef v28 = OSKextCopyPersonalitiesArray(a1);
    CFArrayRef v27 = v28;
    if (v28 && CFArrayGetCount(v28))
    {
      OSKextLog((uint64_t)a1, 37, "Sending all personalties for %s to the kernel.", v29, v30, v31, v32, v33, (char)buffer);
      goto LABEL_16;
    }
    OSKextLog((uint64_t)a1, 37, "%s has no personalities to send to kernel.", v29, v30, v31, v32, v33, (char)buffer);
    if (v27) {
      goto LABEL_16;
    }
    return 0;
  }
  uint64_t v43 = 0;
  CFDictionaryRef ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)a1, @"IOKitPersonalities");
  if (!ValueForInfoDictionaryKey && !CFDictionaryGetCount(0))
  {
    CFNumberRef v38 = buffer;
    uint64_t v35 = "%s has no personalities to send to kernel.";
    CFMutableArrayRef Mutable = (CFMutableArrayRef)a1;
    int v36 = 37;
    goto LABEL_23;
  }
  if (CFArrayGetCount(a2) >= 1)
  {
    CFIndex v16 = 0;
    while (1)
    {
      CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a2, v16);
      char v18 = (char)ValueAtIndex;
      if (!CFDictionaryContainsKey(ValueForInfoDictionaryKey, ValueAtIndex)) {
        break;
      }
      if (++v16 >= CFArrayGetCount(a2)) {
        goto LABEL_9;
      }
    }
    OSKextLogCFString((uint64_t)a1, 33, @"Personality %@ not found in %s.", v19, v20, v21, v22, v23, v18);
    return 0;
  }
LABEL_9:
  CFAllocatorRef v24 = CFGetAllocator(a1);
  CFIndex Count = CFArrayGetCount(a2);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v24, Count, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    uint64_t v35 = "Memory allocation failure.";
    int v36 = 17;
LABEL_23:
    OSKextLog((uint64_t)Mutable, v36, v35, v11, v12, v13, v14, v15, (char)v38);
    return 0;
  }
  OSKextLog((uint64_t)a1, 102, "Sending named personalities of %s to the kernel:", v11, v12, v13, v14, v15, (char)buffer);
  uint64_t context = a1;
  CFArrayRef theArray = 0;
  uint64_t v41 = 0;
  CFArrayRef v42 = a2;
  LOBYTE(v43) = 0;
  CFDictionaryApplyFunction(ValueForInfoDictionaryKey, (CFDictionaryApplierFunction)__OSKextPersonalityPatcherApplierFunction, &context);
  CFArrayRef v27 = theArray;
  if (!theArray) {
    return 0;
  }
LABEL_16:
  if (CFArrayGetCount(v27)) {
    uint64_t v34 = OSKextSendPersonalitiesToKernel(v27, 0);
  }
  else {
    uint64_t v34 = 0;
  }
  CFRelease(v27);
  return v34;
}

uint64_t OSKextSendPersonalitiesOfKextsToKernel(const __CFArray *a1, int a2)
{
  if (!CFArrayGetCount(a1)) {
    return 0;
  }
  CFArrayRef v4 = OSKextCopyPersonalitiesOfKexts(a1);
  if (!v4) {
    return 0;
  }
  CFArrayRef v5 = v4;
  if (CFArrayGetCount(v4)) {
    uint64_t v6 = OSKextSendPersonalitiesToKernel(v5, a2);
  }
  else {
    uint64_t v6 = 0;
  }
  CFRelease(v5);
  return v6;
}

uint64_t __OSKextRemovePersonalities(const void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  values = a2;
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFDictionaryRef v4 = CFDictionaryCreate(v3, MEMORY[0x1E4F1CFF8], (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v4)
  {
    CFDictionaryRef v10 = v4;
    __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, buffer, v6, v7, v8, v9);
    CFDataRef v11 = IOCFSerialize(v10, 0);
    if (v11)
    {
      CFDataRef v17 = v11;
      BytePtr = (const char *)CFDataGetBytePtr(v11);
      uint32_t Length = CFDataGetLength(v17);
      mach_error_t v20 = IOCatalogueSendData(0, 3u, BytePtr, Length);
      if (v20)
      {
        uint64_t v21 = 3690987521;
        mach_error_string(v20);
        OSKextLog((uint64_t)a1, 65, "Failed to remove personalities of %s from IOCatalogue - %s.", v22, v23, v24, v25, v26, (char)buffer);
      }
      else
      {
        uint64_t v21 = 0;
      }
      CFRelease(v17);
    }
    else
    {
      uint64_t v21 = 3690987521;
      OSKextLog((uint64_t)a1, 65, "Can't serialize personalities for %s.", v12, v13, v14, v15, v16, (char)buffer);
    }
    CFRelease(v10);
  }
  else
  {
    uint64_t v21 = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v28);
  }
  return v21;
}

uint64_t OSKextRemoveKextPersonalitiesFromKernel(void **a1)
{
  return __OSKextRemovePersonalities(a1, a1[3]);
}

uint64_t OSKextRemovePersonalitiesForIdentifierFromKernel(void *a1)
{
  return __OSKextRemovePersonalities(0, a1);
}

uint64_t OSKextReadLoadedKextInfo(const __CFArray *a1, int a2)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  uint64_t v4 = pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  uint64_t v5 = __sOSKextArchInfo;
  if (v5 != OSKextGetRunningKernelArchitecture(v4, v6, v7, v8, v9, v10, v11, v12))
  {
    OSKextLog(0, 97, "Can't read loaded kext info - current architecture %s != kernel's architecture %s.", v13, v14, v15, v16, v17, (char)*v5);
    return 3691020303;
  }
  uint64_t v18 = 3690987521;
  if (!a1)
  {
    OSKextFlushLoadInfo(0, a2);
    CFArrayRef v20 = 0;
LABEL_11:
    OSKextLog(0, 100, "Reading load info for all kexts.", v25, v26, v27, v28, v29, v45);
    goto LABEL_12;
  }
  uint64_t v19 = OSKextCopyKextsWithIdentifiers(a1);
  if (!v19) {
    return v18;
  }
  CFArrayRef v20 = v19;
  CFIndex Count = CFArrayGetCount(v19);
  if (Count >= 1)
  {
    CFIndex v22 = Count;
    for (CFIndex i = 0; i != v22; ++i)
    {
      CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v20, i);
      OSKextFlushLoadInfo((uint64_t)ValueAtIndex, a2);
    }
  }
  if (!CFArrayGetCount(a1)) {
    goto LABEL_11;
  }
  char v30 = CFArrayGetCount(a1);
  OSKextLog(0, 100, "Reading load info for %u kext%s.", v31, v32, v33, v34, v35, v30);
LABEL_12:
  CFDictionaryRef v42 = (const __CFDictionary *)OSKextCopyLoadedKextInfo((unint64_t)a1, (const void *)__sOSKextInfoEssentialKeys, v36, v37, v38, v39, v40, v41);
  CFDictionaryRef v43 = v42;
  if (v42)
  {
    CFDictionaryApplyFunction(v42, (CFDictionaryApplierFunction)__OSKextProcessLoadInfo, 0);
    uint64_t v18 = 0;
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v43) {
    CFRelease(v43);
  }
  return v18;
}

uint64_t OSKextGetLoadAddress(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[9];
  if (!v8) {
    return 0;
  }
  if (*(void *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    unint64_t v8 = a1[9];
  }
  return *(void *)(v8 + 56);
}

uint64_t __OSKextSetLoadAddress(uint64_t a1, unint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t result = __OSKextCreateLoadInfo(a1);
  if (result)
  {
    __OSKextGetFileSystemPath(a1, 0, 1u, buffer, v5, v6, v7, v8);
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    if (!HIDWORD(a2) || (__sOSKextArchInfo[1] & 0x1000000) != 0)
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      if (*((unsigned char *)__sOSKextArchInfo + 11)) {
        OSKextLog(a1, 1048615, "setting load address of %s to 0x%0llx", v14, v15, v16, v17, v18, (char)buffer);
      }
      else {
        OSKextLog(a1, 1048615, "setting load address of %s to 0x%0x", v14, v15, v16, v17, v18, (char)buffer);
      }
      *(void *)(*(void *)(a1 + 72) + 56) = a2;
      return 1;
    }
    else
    {
      OSKextLog(a1, 33, "Attempt to set 64-bit load address - %s.", v9, v10, v11, v12, v13, (char)buffer);
      return 0;
    }
  }
  return result;
}

uint64_t OSKextSetLoadAddress(unint64_t *a1, unint64_t a2)
{
  uint64_t result = __OSKextCreateLoadInfo((uint64_t)a1);
  if (result)
  {
    if (*(void *)(a1[9] + 8)) {
      __OSKextCheckLoaded(a1, v5, v6, v7, v8, v9, v10, v11);
    }
    return __OSKextSetLoadAddress((uint64_t)a1, a2);
  }
  return result;
}

BOOL OSKextOtherVersionIsLoaded(unint64_t *a1, BOOL *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[9];
  if (!v8) {
    return 0;
  }
  if (*(void *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    unint64_t v8 = a1[9];
  }
  __int16 v11 = *(_WORD *)(v8 + 168);
  BOOL result = (v11 & 0x600) != 0;
  if (a2) {
    *a2 = (v11 & 0x400) != 0;
  }
  return result;
}

uint64_t OSKextGetLoadTag(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[9];
  if (!v8) {
    return 0;
  }
  if (*(void *)(v8 + 8))
  {
    __OSKextCheckLoaded(a1, a2, a3, a4, a5, a6, a7, a8);
    unint64_t v8 = a1[9];
  }
  return *(unsigned int *)(v8 + 16);
}

uint64_t __OSKextFlushLoadInfoApplierFunction(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  return OSKextFlushLoadInfo(a2, *a3);
}

CFTypeRef _OSKextCopyKernelRequests(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  OSKextLog(0, 71, "Reading requests from kernel.", a4, a5, a6, a7, a8, v24);
  KextRequest = __OSKextCreateKextRequest(@"Get Kernel Requests", 0, 0);
  mach_error_t v9 = __OSKextSendKextRequest(0, KextRequest, &cf, 0, 0);
  if (v9)
  {
    uint64_t v15 = mach_error_string(v9);
    uint64_t v21 = "(unknown)";
    if (v15) {
      LOBYTE(v21) = (_BYTE)v15;
    }
    OSKextLog(0, 65, "Failed to read requests from kernel - %s.", v16, v17, v18, v19, v20, (char)v21);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
  }
  else
  {
    if (cf)
    {
      CFTypeID TypeID = CFArrayGetTypeID();
      if (TypeID == CFGetTypeID(cf)) {
        goto LABEL_12;
      }
      if (cf) {
        CFRelease(cf);
      }
    }
    CFTypeRef cf = 0;
    OSKextLog(0, 65, "Requests from kernel missing or of wrong type.", v10, v11, v12, v13, v14, v25);
  }
LABEL_12:
  if (KextRequest) {
    CFRelease(KextRequest);
  }
  return cf;
}

uint64_t _OSKextSendResource(const __CFDictionary *a1, int a2, const void *a3)
{
  int valuePtr = a2;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"Kext Request Arguments");
  if (!Value) {
    return 3691020293;
  }
  CFDictionaryRef v6 = Value;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a1);
  if (MutableCopy)
  {
    uint64_t v14 = MutableCopy;
    CFMutableDictionaryRef v15 = CFDictionaryCreateMutableCopy(v7, 0, v6);
    if (v15)
    {
      CFMutableDictionaryRef v21 = v15;
      CFDictionarySetValue(v14, @"Kext Request Predicate", @"Send Resource");
      CFDictionarySetValue(v14, @"Kext Request Arguments", v21);
      if (a3) {
        CFDictionarySetValue(v21, @"Value", a3);
      }
      CFNumberRef v22 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
      if (v22)
      {
        CFNumberRef v23 = v22;
        CFDictionarySetValue(v21, @"Kext Request Result Code", v22);
        uint64_t v24 = __OSKextSendKextRequest(0, v14, 0, 0, 0);
        CFRelease(v23);
      }
      else
      {
        uint64_t v24 = __OSKextSendKextRequest(0, v14, 0, 0, 0);
      }
      CFRelease(v21);
    }
    else
    {
      uint64_t v24 = 3690987521;
      OSKextLog(0, 17, "Memory allocation failure.", v16, v17, v18, v19, v20, v26);
    }
    CFRelease(v14);
  }
  else
  {
    uint64_t v24 = 3690987521;
    OSKextLog(0, 17, "Memory allocation failure.", v9, v10, v11, v12, v13, v26);
  }
  return v24;
}

CFArrayRef OSKextCreateLoadedKextInfo(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v8 = (const __CFDictionary *)OSKextCopyLoadedKextInfo(a1, 0, a3, a4, a5, a6, a7, a8);
  if (v8)
  {
    CFDictionaryRef v9 = v8;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v9))
    {
      CFIndex Count = CFDictionaryGetCount(v9);
      uint64_t v12 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
      if (v12)
      {
        uint64_t v18 = v12;
        CFDictionaryGetKeysAndValues(v9, 0, v12);
        CFArrayRef v19 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v18, Count, MEMORY[0x1E4F1D510]);
LABEL_8:
        CFRelease(v9);
        return v19;
      }
      OSKextLog(0, 17, "Memory allocation failure.", v13, v14, v15, v16, v17, v21);
    }
    CFArrayRef v19 = 0;
    goto LABEL_8;
  }
  return 0;
}

uint64_t OSKextValidate(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    CFDictionaryRef v9 = Mutable;
    int v10 = __OSKextValidate(a1, Mutable, v3, v4, v5, v6, v7, v8);
    CFArrayAppendValue(v9, @"IOKitPersonalities");
    CFDictionaryRef v11 = *(const __CFDictionary **)(a1 + 56);
    CFStringRef TypeID = (const __CFString *)CFDictionaryGetTypeID();
    int v13 = __OSKextCheckProperty(a1, v11, @"IOKitPersonalities", (const __CFString *)v9, TypeID, 0, 0, 1, 0, (const __CFString **)&theDict, 0);
    if (v10) {
      BOOL v14 = v13 == 0;
    }
    else {
      BOOL v14 = 1;
    }
    uint64_t v15 = !v14;
    if (v13) {
      BOOL v16 = theDict == 0;
    }
    else {
      BOOL v16 = 1;
    }
    if (!v16)
    {
      context[0] = a1;
      context[1] = theDict;
      void context[2] = v9;
      uint64_t v21 = 1;
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateIOKitPersonalityTargetApplierFunction, context);
      if ((_BYTE)v21) {
        uint64_t v15 = v15;
      }
      else {
        uint64_t v15 = 0;
      }
    }
    CFIndex Count = CFArrayGetCount(v9);
    CFArrayRemoveValueAtIndex(v9, Count - 1);
    CFRelease(v9);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v19);
    return 1;
  }
  return v15;
}

uint64_t __OSKextValidate(uint64_t a1, __CFArray *Mutable, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef theDict = 0;
  char v72 = 0;
  __OSKextGetFileSystemPath(a1, 0, 0, buffer, a5, a6, a7, a8);
  OSKextLog(a1, 4101, "Validating %s.", v10, v11, v12, v13, v14, (char)buffer);
  uint64_t v21 = 0;
  *(_DWORD *)(a1 + 92) &= 0xFFFFF1FF;
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    uint64_t v21 = Mutable;
    if (!Mutable)
    {
      OSKextLog(0, 17, "Memory allocation failure.", v16, v17, v18, v19, v20, v65);
      int v50 = *(_DWORD *)(a1 + 92);
      goto LABEL_54;
    }
  }
  int v22 = __OSKextProcessInfoDictionary(a1, 0, v15, v16, v17, v18, v19, v20);
  BOOL v23 = v22 != 0;
  if (*(void *)(a1 + 56))
  {
    int v24 = v22;
    CFArrayAppendValue(Mutable, @"OSBundleAllowUserLoad");
    CFDictionaryRef v25 = *(const __CFDictionary **)(a1 + 56);
    CFStringRef TypeID = (const __CFString *)CFBooleanGetTypeID();
    int v27 = __OSKextCheckProperty(a1, v25, @"OSBundleAllowUserLoad", (const __CFString *)Mutable, TypeID, 0, 0, 1, 0, 0, 0);
    CFIndex Count = CFArrayGetCount(Mutable);
    CFArrayRemoveValueAtIndex(Mutable, Count - 1);
    CFArrayAppendValue(Mutable, @"OSBundleLibraries");
    CFDictionaryRef v29 = *(const __CFDictionary **)(a1 + 56);
    CFStringRef v30 = (const __CFString *)CFDictionaryGetTypeID();
    int v31 = __OSKextCheckProperty(a1, v29, @"OSBundleLibraries", (const __CFString *)Mutable, v30, 0, (*(unsigned __int8 *)(a1 + 92) >> 2) & ~*(unsigned __int8 *)(a1 + 92) & 1, 1, (*(unsigned char *)(a1 + 92) & 5) == 4, (const __CFString **)&theDict, 0);
    int v35 = v31;
    if (v24) {
      BOOL v36 = v27 == 0;
    }
    else {
      BOOL v36 = 1;
    }
    int v38 = !v36 && v31 != 0;
    if (theDict && CFDictionaryGetCount(theDict))
    {
      if (*(unsigned char *)(a1 + 92))
      {
        __OSKextAddDiagnostic(a1, 1, @"A system kext has a property set that it shouldn't", @"OSBundleLibraries", 0, v32, v33, v34, v66);
        int v38 = 0;
        if (!v35) {
          goto LABEL_29;
        }
        goto LABEL_23;
      }
      if ((*(unsigned char *)(a1 + 92) & 4) == 0 && *(uint64_t *)(a1 + 48) <= 0)
      {
        __OSKextSetDiagnostic(a1, 8, @"Kext has no executable or compatible version, so it should not declare any OSBundleLibraries.");
        if (!v35) {
          goto LABEL_29;
        }
        goto LABEL_23;
      }
    }
    else if ((*(_DWORD *)(a1 + 92) & 5) == 4)
    {
      __OSKextAddDiagnostic(a1, 1, @"Info dictionary missing required property/value", (const __CFString *)Mutable, 0, v32, v33, v34, v66);
    }
    if (!v35) {
      goto LABEL_29;
    }
LABEL_23:
    if (theDict)
    {
      uint64_t context = a1;
      CFDictionaryRef v69 = theDict;
      uint64_t v70 = Mutable;
      uint64_t v71 = 1;
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateOSBundleLibraryApplierFunction, &context);
      if (!(_BYTE)v71) {
        int v38 = 0;
      }
      if (BYTE1(v71) && BYTE2(v71)) {
        __OSKextSetDiagnostic(a1, 8, @"Kexts should declare dependencies on either com.apple.kernel* or com.apple.kpi.* libraries, not both.");
      }
    }
LABEL_29:
    CFDictionaryRef theDict = 0;
    CFIndex v39 = CFArrayGetCount(Mutable);
    CFArrayRemoveValueAtIndex(Mutable, v39 - 1);
    CFArrayAppendValue(Mutable, @"IOKitPersonalities");
    CFDictionaryRef v40 = *(const __CFDictionary **)(a1 + 56);
    CFStringRef v41 = (const __CFString *)CFDictionaryGetTypeID();
    int v42 = __OSKextCheckProperty(a1, v40, @"IOKitPersonalities", (const __CFString *)Mutable, v41, 0, 0, 1, 0, (const __CFString **)&theDict, &v72);
    if (v42) {
      int v43 = v38;
    }
    else {
      int v43 = 0;
    }
    if (v42)
    {
      if (theDict)
      {
        uint64_t context = a1;
        CFDictionaryRef v69 = theDict;
        uint64_t v70 = Mutable;
        uint64_t v71 = 1;
        CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__OSKextValidateIOKitPersonalityApplierFunction, &context);
        if (!(_BYTE)v71) {
          int v43 = 0;
        }
      }
    }
    CFIndex v44 = CFArrayGetCount(Mutable);
    CFArrayRemoveValueAtIndex(Mutable, v44 - 1);
    uint64_t context = 0;
    if ((*(_DWORD *)(a1 + 92) & 6) == 4)
    {
      if (!__OSKextReadExecutable(a1))
      {
        int v49 = 0;
LABEL_48:
        if (v49) {
          BOOL v23 = v43;
        }
        else {
          BOOL v23 = 0;
        }
        goto LABEL_51;
      }
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      CFDataRef v45 = OSKextCopyExecutableForArchitecture(a1, (uint64_t)__sOSKextArchInfo);
      if (v45)
      {
        CFDataRef v46 = v45;
        unsigned __int8 v74 = 0;
        BytePtr = (int *)CFDataGetBytePtr(v45);
        CFIndex Length = CFDataGetLength(v46);
        if (macho_find_symbol(BytePtr, (unint64_t)BytePtr + Length, "_kmod_info", &v74, &context)
          || (~v74 & 0xE) != 0
          || !context)
        {
          __OSKextSetDiagnostic(a1, 1, @"Executable file doesn't contain kernel extension code (no kmod_info symbol or bad Mach-O layout).");
        }
        else
        {
          if ((*(unsigned char *)(a1 + 94) & 1) == 0)
          {
            int v49 = 1;
            goto LABEL_42;
          }
          pthread_once(&__sOSKextInitialized, __OSKextInitialize);
          int v53 = *((_DWORD *)__sOSKextArchInfo + 2);
          if ((v53 & 0x1000000) != 0) {
            uint64_t v54 = (const char *)(context + 16);
          }
          else {
            uint64_t v54 = (const char *)(context + 12);
          }
          if ((v53 & 0x1000000) != 0) {
            uint64_t v55 = (char *)(context + 80);
          }
          else {
            uint64_t v55 = (char *)(context + 76);
          }
          uint64_t v56 = *(const void **)(a1 + 24);
          CFStringRef v57 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v54, 0x8000100u);
          if (v57)
          {
            CFDataRef v63 = (const __CFData *)v57;
            if (!CFEqual(v56, v57)) {
              __OSKextSetDiagnostic(a1, 8, @"Kexts with a kernel library < v6.0 must set MODULE_NAME the same as CFBundleIdentifier to load on kernel < v6.0.");
            }
            uint64_t v64 = OSKextParseVersionString(v55);
            if (v64 < 0 || *(void *)(a1 + 40) != v64) {
              __OSKextSetDiagnostic(a1, 8, @"Kexts with a kernel library < v6.0 must set MODULE_VERSION the same as CFBundleVersion to load on kernel < v6.0.");
            }
            CFRelease(v46);
            int v49 = 1;
            CFDataRef v46 = v63;
            goto LABEL_42;
          }
          OSKextLog(0, 17, "Memory allocation failure.", v58, v59, v60, v61, v62, v67);
        }
        int v49 = 0;
LABEL_42:
        CFRelease(v46);
        goto LABEL_48;
      }
    }
    int v49 = 1;
    goto LABEL_48;
  }
LABEL_51:
  if (v21) {
    CFRelease(v21);
  }
  int v50 = *(_DWORD *)(a1 + 92);
  if (!v23)
  {
    uint64_t result = 0;
    int v51 = v50 | 0x400;
    goto LABEL_56;
  }
LABEL_54:
  int v51 = v50 | 0xA00;
  uint64_t result = 1;
LABEL_56:
  *(_DWORD *)(a1 + 92) = v51;
  return result;
}

uint64_t __OSKextCheckProperty(uint64_t a1, CFDictionaryRef theDict, const __CFString *key, const __CFString *a4, const __CFString *a5, const __CFArray *a6, int a7, int a8, char a9, const __CFString **a10, unsigned char *a11)
{
  if (a11) {
    *a11 = 0;
  }
  if (a10) {
    *a10 = 0;
  }
  if (*(CFDictionaryRef *)(a1 + 56) == theDict) {
    CFStringRef ValueForInfoDictionaryKey = (const __CFString *)OSKextGetValueForInfoDictionaryKey(a1, key);
  }
  else {
    CFStringRef ValueForInfoDictionaryKey = (const __CFString *)CFDictionaryGetValue(theDict, key);
  }
  CFStringRef v21 = ValueForInfoDictionaryKey;
  if (!ValueForInfoDictionaryKey)
  {
    if (!a7) {
      return 1;
    }
    __OSKextAddDiagnostic(a1, 1, @"Info dictionary missing required property/value", a4, 0, v18, v19, v20, v53);
    return 0;
  }
  if (a10) {
    *a10 = ValueForInfoDictionaryKey;
  }
  CFTypeID TypeID = CFNumberGetTypeID();
  BOOL v23 = TypeID == CFGetTypeID(v21) && CFNumberIsFloatType((CFNumberRef)v21) != 0;
  if ((const __CFString *)CFGetTypeID(v21) != a5 || v23)
  {
    if ((const __CFString *)CFStringGetTypeID() == a5)
    {
      CFDictionaryRef v40 = "<string>";
    }
    else if ((const __CFString *)CFNumberGetTypeID() == a5 && v23)
    {
      CFDictionaryRef v40 = "<integer> (kexts may not use <real>)";
    }
    else if ((const __CFString *)CFNumberGetTypeID() == a5)
    {
      CFDictionaryRef v40 = "<integer>";
    }
    else if ((const __CFString *)CFDataGetTypeID() == a5)
    {
      CFDictionaryRef v40 = "<data>";
    }
    else if ((const __CFString *)CFBooleanGetTypeID() == a5)
    {
      CFDictionaryRef v40 = "BOOLean, <true/> or <false/>";
    }
    else if ((const __CFString *)CFArrayGetTypeID() == a5)
    {
      CFDictionaryRef v40 = "<array>";
    }
    else
    {
      CFTypeID v49 = CFDictionaryGetTypeID();
      CFDictionaryRef v40 = "<dict>";
      if ((const __CFString *)v49 != a5) {
        LOBYTE(v4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
      }
    }
    if (a5)
    {
      char v53 = (char)v40;
      a5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"should be %s");
    }
    if (a8) {
      int v50 = 1;
    }
    else {
      int v50 = 8;
    }
    if (a8) {
      int v51 = @"Info dictionary property value is of illegal type";
    }
    else {
      int v51 = @"Info dictionary property value is of incorrect type";
    }
    __OSKextAddDiagnostic(a1, v50, v51, a4, a5, v37, v38, v39, v53);
    if (a5) {
      CFRelease(a5);
    }
    return 0;
  }
  if (!a6) {
    goto LABEL_26;
  }
  CFIndex Count = CFArrayGetCount(a6);
  if (Count >= 1)
  {
    CFIndex v28 = Count;
    CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a6, 0);
    if (CFEqual(ValueAtIndex, v21)) {
      goto LABEL_26;
    }
    CFIndex v30 = 1;
    while (v28 != v30)
    {
      int v31 = CFArrayGetValueAtIndex(a6, v30++);
      if (CFEqual(v31, v21))
      {
        if (v30 - 1 < v28) {
          goto LABEL_26;
        }
        break;
      }
    }
  }
  __OSKextAddDiagnostic(a1, 1, @"Info dictionary property value is illegal", a4, 0, v25, v26, v27, v53);
LABEL_26:
  if ((const __CFString *)CFBooleanGetTypeID() != a5)
  {
    if ((const __CFString *)CFStringGetTypeID() == a5)
    {
      CFIndex Length = CFStringGetLength(v21);
    }
    else if ((const __CFString *)CFDataGetTypeID() == a5)
    {
      CFIndex Length = CFDataGetLength((CFDataRef)v21);
    }
    else if ((const __CFString *)CFArrayGetTypeID() == a5)
    {
      CFIndex Length = CFArrayGetCount((CFArrayRef)v21);
    }
    else
    {
      if ((const __CFString *)CFDictionaryGetTypeID() != a5)
      {
        if ((const __CFString *)CFNumberGetTypeID() != a5)
        {
          CFNumberRef v36 = 0;
          int Value = 0;
          goto LABEL_50;
        }
        int valuePtr = 0;
        CFNumberRef v36 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
        if (!v36) {
          OSKextLog(0, 17, "Memory allocation failure.", v44, v45, v46, v47, v48, v53);
        }
        CFIndex Length = CFNumberCompare((CFNumberRef)v21, v36, 0);
        goto LABEL_49;
      }
      CFIndex Length = CFDictionaryGetCount((CFDictionaryRef)v21);
    }
    CFNumberRef v36 = 0;
LABEL_49:
    int Value = Length != 0;
    goto LABEL_50;
  }
  int Value = CFBooleanGetValue((CFBooleanRef)v21);
  CFNumberRef v36 = 0;
LABEL_50:
  if (a11) {
    *a11 = Value;
  }
  uint64_t v43 = 1;
  if (a9 && !Value)
  {
    __OSKextAddDiagnostic(a1, 1, @"Info dictionary property value is illegal", a4, 0, v33, v34, v35, v53);
    uint64_t v43 = 0;
  }
  if (v36) {
    CFRelease(v36);
  }
  return v43;
}

void __OSKextValidateIOKitPersonalityTargetApplierFunction(const __CFString *value, const __CFDictionary *a2, uint64_t a3)
{
  char v35 = 0;
  uint64_t v34 = 0;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), value);
  uint64_t v6 = *(void *)a3;
  CFDictionaryRef v7 = *(const __CFDictionary **)(a3 + 8);
  CFStringRef v8 = *(const __CFString **)(a3 + 16);
  CFStringRef TypeID = (const __CFString *)CFDictionaryGetTypeID();
  if (__OSKextCheckProperty(v6, v7, value, v8, TypeID, 0, 0, 1, 0, 0, 0))
  {
    CFStringRef v10 = (const __CFString *)*MEMORY[0x1E4F1CFF8];
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), (const void *)*MEMORY[0x1E4F1CFF8]);
    uint64_t v11 = *(void *)a3;
    CFStringRef v12 = *(const __CFString **)(a3 + 16);
    CFStringRef v13 = (const __CFString *)CFStringGetTypeID();
    int v14 = __OSKextCheckProperty(v11, a2, v10, v12, v13, 0, 0, 1, 1, (const __CFString **)&v34, &v35);
    if (*(unsigned char *)(a3 + 24)) {
      BOOL v15 = v14 == 0;
    }
    else {
      BOOL v15 = 1;
    }
    char v16 = !v15;
    *(unsigned char *)(a3 + 24) = v16;
    if (v34)
    {
      KextWithCFStringRef Identifier = OSKextGetKextWithIdentifier(v34);
      if (KextWithIdentifier)
      {
        if (KextWithIdentifier != *(const void **)a3
          && !OSKextIsLoadable((uint64_t)KextWithIdentifier, v18, v19, v20, v21, v22, v23, v24))
        {
          char v33 = (char)v34;
          CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"'%@' -> '%@'");
          __OSKextAddDiagnostic(*(void *)a3, 8, @"Personality CFBundleIdentifier names a kext that is not loadable (run kextutil(8) on it with -nt for more information)", v25, 0, v26, v27, v28, v33);
          if (v25) {
            CFRelease(v25);
          }
        }
      }
    }
    CFArrayRef v29 = *(const __CFArray **)(a3 + 16);
    CFIndex Count = CFArrayGetCount(v29);
    CFArrayRemoveValueAtIndex(v29, Count - 1);
  }
  else
  {
    *(unsigned char *)(a3 + 24) = 0;
  }
  CFArrayRef v31 = *(const __CFArray **)(a3 + 16);
  CFIndex v32 = CFArrayGetCount(v31);
  CFArrayRemoveValueAtIndex(v31, v32 - 1);
}

uint64_t _OSKextBasicFilesystemAuthentication(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 88) & 8) == 0)
  {
    CFDictionaryRef v9 = CFBundleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 16));
    if (v9)
    {
      CFStringRef v10 = v9;
      CFURLRef v11 = CFBundleCopyBuiltInPlugInsURL(v9);
      CFURLRef v17 = v11;
      if (v11)
      {
        CFURLRef v18 = CFURLCopyAbsoluteURL(v11);
        if (!v18)
        {
          OSKextLog(0, 17, "Memory allocation failure.", v12, v13, v14, v15, v16, v22);
          CFRelease(v10);
          uint64_t v19 = 0;
LABEL_14:
          CFRelease(v17);
LABEL_15:
          if (v18) {
            CFRelease(v18);
          }
          return v19;
        }
      }
      else
      {
        CFURLRef v18 = 0;
      }
      uint64_t v19 = __OSKextBasicFilesystemAuthenticationRecursive((const void *)a1, *(const __CFURL **)(a1 + 16), v18, v12, v13, v14, v15, v16);
      CFRelease(v10);
      if (!v17) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    return 0;
  }
  CFURLRef v20 = **(const __CFURL ***)(a1 + 80);
  if (!v20)
  {
    __OSKextSetDiagnostic(a1, 2, @"Kext was not created from an URL and can't be authenticated");
    return 0;
  }

  return __OSKextBasicFilesystemAuthenticationRecursive((const void *)a1, v20, 0, a4, a5, a6, a7, a8);
}

uint64_t __OSKextBasicFilesystemAuthenticationRecursive(const void *a1, const __CFURL *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  memset(&v78, 0, sizeof(v78));
  memset(&v77, 0, sizeof(v77));
  SInt32 errorCode = 0;
  __OSKextGetFileSystemPath((uint64_t)a1, 0, 0, (UInt8 *)__s, a5, a6, a7, a8);
  CFStringRef PathComponent = CFURLCopyLastPathComponent(a2);
  CFStringRef v12 = PathComponent;
  if (!PathComponent || !CFEqual(PathComponent, @".DS_Store"))
  {
    CFURLRef v15 = CFURLCopyAbsoluteURL(a2);
    if (v15)
    {
      if (!__OSKextGetFileSystemPath(0, a2, 1u, buffer, v18, v19, v20, v21))
      {
        CFIndex v30 = @"Internal error converting URL";
        uint64_t v31 = (uint64_t)a1;
        int v32 = 1;
        goto LABEL_12;
      }
      OSKextLog((uint64_t)a1, 139269, "Authenticating %s file/directory %s.", v22, v23, v24, v25, v26, (char)__s);
      if (!stat((const char *)buffer, &v78) && !lstat((const char *)buffer, &v77))
      {
        if (*(void *)&v78.st_uid || (v78.st_mode & 0x12) != 0)
        {
          __OSKextAddDiagnostic((uint64_t)a1, 2, @"File owner/permissions are incorrect (must be root:wheel, nonwritable by group/other)", (const __CFString *)a2, 0, v27, v28, v29, (char)v74);
          uint64_t v16 = 0;
        }
        else
        {
          uint64_t v16 = 1;
        }
        if ((v77.st_mode & 0xF000) == 0xA000)
        {
          uint64_t v14 = realpath_DARWIN_EXTSN((const char *)buffer, 0);
          if (!v14)
          {
            uint64_t v64 = __error();
            char v65 = strerror(*v64);
            __OSKextAddDiagnostic((uint64_t)a1, 2, @"The kext contains a symlink which is either not readable or points outside of its bundle; please remove",
              (const __CFString *)a2,
              (const __CFString *)v65,
              v66,
              v67,
              v68,
              (char)v74);
            OSKextLog((uint64_t)a1, 131073, "Can't determine real path for %s (%s)", v69, v70, v71, v72, v73, (char)buffer);
            goto LABEL_16;
          }
          OSKextLog((uint64_t)a1, 131077, "Realpath for %s is %s", v37, v38, v39, v40, v41, (char)buffer);
          size_t v42 = strlen(__s);
          if (strncmp(__s, v14, v42))
          {
            __OSKextAddDiagnostic((uint64_t)a1, 2, @"The kext contains a symlink which is either not readable or points outside of its bundle; please remove",
              (const __CFString *)a2,
              (const __CFString *)"Symlink points outside of bundle.",
              v43,
              v44,
              v45,
              v75);
            OSKextLog((uint64_t)a1, 131073, "Kext contains symlink at %s which points outside of its bundle at %s; rejecting.",
              v46,
              v47,
              v48,
              v49,
              v50,
              (char)buffer);
            goto LABEL_16;
          }
          __OSKextAddDiagnostic((uint64_t)a1, 8, @"The booter does not recognize symbolic links; confirm these files/directories aren't needed for startup",
            (const __CFString *)a2,
            0,
            v43,
            v44,
            v45,
            v75);
        }
        else
        {
          uint64_t v14 = 0;
        }
        if (!CFURLHasDirectoryPath(a2) || a3 && CFEqual(v15, a3))
        {
          CFArrayRef v13 = 0;
        }
        else
        {
          CFAllocatorRef v51 = CFGetAllocator(a1);
          CFArrayRef v52 = (const __CFArray *)CFURLCreatePropertyFromResource(v51, a2, (CFStringRef)*MEMORY[0x1E4F1D5C8], &errorCode);
          CFArrayRef v13 = v52;
          if (!v52 || errorCode)
          {
            OSKextLog((uint64_t)a1, 139265, "Can't read file %s.", v53, v54, v55, v56, v57, (char)buffer);
          }
          else
          {
            CFIndex Count = CFArrayGetCount(v52);
            if (Count >= 1)
            {
              CFIndex v59 = Count;
              for (CFIndex i = 0; i != v59; ++i)
              {
                CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v13, i);
                int v62 = __OSKextBasicFilesystemAuthenticationRecursive(a1, ValueAtIndex, a3);
                if ((_BYTE)v16) {
                  BOOL v63 = v62 == 0;
                }
                else {
                  BOOL v63 = 1;
                }
                uint64_t v16 = !v63;
              }
            }
          }
        }
LABEL_17:
        if (!v12) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
      if (*__error() == 2)
      {
        CFIndex v30 = @"File not found";
        uint64_t v31 = (uint64_t)a1;
        int v32 = 2;
LABEL_12:
        __OSKextAddDiagnostic(v31, v32, v30, (const __CFString *)a2, 0, v24, v25, v26, (char)v74);
LABEL_15:
        uint64_t v14 = 0;
LABEL_16:
        CFArrayRef v13 = 0;
        uint64_t v16 = 0;
        goto LABEL_17;
      }
      char v35 = __error();
      unsigned __int8 v74 = buffer;
      strerror(*v35);
      char v33 = "Can't stat %s - %s.";
      int v34 = 131073;
    }
    else
    {
      char v33 = "Memory allocation failure.";
      int v34 = 17;
    }
    OSKextLog(0, v34, v33, v17, v18, v19, v20, v21, (char)v74);
    goto LABEL_15;
  }
  CFArrayRef v13 = 0;
  uint64_t v14 = 0;
  CFURLRef v15 = 0;
  uint64_t v16 = 1;
LABEL_18:
  CFRelease(v12);
LABEL_19:
  if (v15) {
    CFRelease(v15);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v14) {
    free(v14);
  }
  return v16;
}

uint64_t OSKextAuthenticate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 92) &= 0xFFFF8EFF;
  if (!__sOSKextAuthenticationFunction)
  {
    CFStringRef v12 = "Trying to authenticate kext with no authentication function, failing.";
    uint64_t v13 = 0;
    int v14 = 4097;
LABEL_9:
    OSKextLog(v13, v14, v12, a4, a5, a6, a7, a8, v15);
    int v10 = *(_DWORD *)(a1 + 92);
LABEL_10:
    uint64_t result = 0;
    int v11 = v10 | 0x3000;
    goto LABEL_11;
  }
  if (!__OSKextGetFileSystemPath(a1, 0, 1u, buffer, a5, a6, a7, a8))
  {
    CFStringRef v12 = "Could not get absolute path of kext!";
    uint64_t v13 = a1;
    int v14 = 262161;
    goto LABEL_9;
  }
  if (!rootless_check_trusted()) {
    *(_DWORD *)(a1 + 92) |= 0x100u;
  }
  uint64_t result = __sOSKextAuthenticationFunction(a1, __sOSKextAuthenticationContext);
  int v10 = *(_DWORD *)(a1 + 92);
  if (!result) {
    goto LABEL_10;
  }
  int v11 = v10 | 0x5000;
LABEL_11:
  *(_DWORD *)(a1 + 92) = v11;
  return result;
}

uint64_t OSKextIsLoadable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!__OSKextIsValid(a1, a2, a3, a4, a5, a6, a7, a8)
    || !OSKextIsAuthentic(a1, v9, v10, v11, v12, v13, v14, v15)
    || !OSKextResolveDependencies(a1)
    || !OSKextValidateDependencies(a1))
  {
    return 0;
  }

  return OSKextAuthenticateDependencies(a1);
}

CFDictionaryRef OSKextCopyDiagnostics(void *a1, char a2)
{
  uint64_t v4 = a1[8];
  CFAllocatorRef v5 = CFGetAllocator(a1);
  if (v4)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      if (a2)
      {
        CFDictionaryRef v12 = __OSKextCopyDiagnosticsDict(a1, 1);
        if (v12)
        {
          CFDictionaryRef v13 = v12;
          if (CFDictionaryGetCount(v12)) {
            CFDictionarySetValue(Mutable, @"Validation Failures", v13);
          }
          CFRelease(v13);
        }
      }
      if ((a2 & 2) != 0)
      {
        CFDictionaryRef v14 = __OSKextCopyDiagnosticsDict(a1, 2);
        if (v14)
        {
          CFDictionaryRef v15 = v14;
          if (CFDictionaryGetCount(v14)) {
            CFDictionarySetValue(Mutable, @"Authentication Failures", v15);
          }
          CFRelease(v15);
        }
      }
      if ((a2 & 4) != 0)
      {
        CFDictionaryRef v16 = __OSKextCopyDiagnosticsDict(a1, 4);
        if (v16)
        {
          CFDictionaryRef v17 = v16;
          if (CFDictionaryGetCount(v16)) {
            CFDictionarySetValue(Mutable, @"Dependency Resolution Failures", v17);
          }
          CFRelease(v17);
        }
      }
      if ((a2 & 8) != 0)
      {
        CFDictionaryRef v18 = __OSKextCopyDiagnosticsDict(a1, 8);
        if (v18)
        {
          CFDictionaryRef v19 = v18;
          if (CFDictionaryGetCount(v18)) {
            CFDictionarySetValue(Mutable, @"Warnings", v19);
          }
          CFRelease(v19);
        }
      }
      if ((a2 & 0x10) != 0)
      {
        CFDictionaryRef v20 = __OSKextCopyDiagnosticsDict(a1, 16);
        if (v20)
        {
          CFDictionaryRef v21 = v20;
          if (CFDictionaryGetCount(v20)) {
            CFDictionarySetValue(Mutable, @"Boot Level Restrictions", v21);
          }
          CFRelease(v21);
        }
      }
    }
    else
    {
      OSKextLog(0, 17, "Memory allocation failure.", v6, v7, v8, v9, v10, v25);
    }
    return Mutable;
  }
  else
  {
    uint64_t v22 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v23 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    return CFDictionaryCreate(v5, 0, 0, 0, v22, v23);
  }
}

CFDictionaryRef __OSKextCopyDiagnosticsDict(void *cf, int a2)
{
  uint64_t v3 = (const __CFDictionary **)cf[8];
  if (!v3) {
    goto LABEL_10;
  }
  switch(a2)
  {
    case 1:
      break;
    case 2:
      ++v3;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_10;
    case 4:
      v3 += 2;
      break;
    case 8:
      v3 += 3;
      break;
    default:
      if (a2 != 16) {
        goto LABEL_10;
      }
      v3 += 4;
      break;
  }
  CFDictionaryRef v4 = *v3;
  if (!*v3 || (v5 = CFGetAllocator(cf), (CFDictionaryRef result = CFDictionaryCreateCopy(v5, v4)) == 0))
  {
LABEL_10:
    CFAllocatorRef v7 = CFGetAllocator(cf);
    uint64_t v8 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v9 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    return CFDictionaryCreate(v7, 0, 0, 0, v8, v9);
  }
  return result;
}

void OSKextLogDiagnostics(void *a1, char a2)
{
  CFDictionaryRef v2 = OSKextCopyDiagnostics(a1, a2);
  if (!v2) {
    return;
  }
  CFDictionaryRef v3 = v2;
  if (CFDictionaryGetCount(v2) && (CFStringForPlist_new = createCFStringForPlist_new(v3, 2)) != 0)
  {
    CFAllocatorRef v5 = CFStringForPlist_new;
    CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString(CFStringForPlist_new);
    if (UTF8CStringForCFString)
    {
      CFDictionaryRef v12 = UTF8CStringForCFString;
      OSKextLog(0, 16, "%s", v7, v8, v9, v10, v11, (char)UTF8CStringForCFString);
      CFRelease(v3);
      CFRelease(v5);
      free(v12);
      return;
    }
    CFRelease(v3);
    CFDictionaryRef v13 = v5;
  }
  else
  {
    CFDictionaryRef v13 = v3;
  }

  CFRelease(v13);
}

uint64_t __OSKextFlushDiagnosticsApplierFunction(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return OSKextFlushDiagnostics(a2, *a3);
}

BOOL OSKextMatchesRequiredFlags(uint64_t a1, int a2)
{
  CFStringRef ValueForInfoDictionaryKey = OSKextGetValueForInfoDictionaryKey(a1, @"OSBundleRequired");
  CFDictionaryRef v4 = ValueForInfoDictionaryKey;
  return (a2 & 1) != 0 && ValueForInfoDictionaryKey && CFEqual(ValueForInfoDictionaryKey, @"Root")
      || (a2 & 2) != 0 && v4 && CFEqual(v4, @"Local-Root")
      || (a2 & 4) != 0 && v4 && CFEqual(v4, @"Network-Root")
      || (a2 & 0x10) != 0 && v4 && CFEqual(v4, @"Console")
      || (a2 & 0x20) != 0 && v4 && CFEqual(v4, @"DriverKit")
      || (a2 & 8) != 0 && v4 && CFEqual(v4, @"Safe Boot")
      || a2 == 0;
}

__CFArray *OSKextFilterRequiredKexts(const __CFArray *a1, int a2)
{
  CFArrayRef AllKexts = a1;
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    if (!AllKexts) {
      CFArrayRef AllKexts = (const __CFArray *)OSKextGetAllKexts();
    }
    CFIndex Count = CFArrayGetCount(AllKexts);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(AllKexts, i);
        if (OSKextMatchesRequiredFlags((uint64_t)ValueAtIndex, a2)) {
          CFArrayAppendValue(Mutable, ValueAtIndex);
        }
      }
    }
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v16);
  }
  return Mutable;
}

uint64_t mkext_adler32(unsigned __int8 *a1, int a2)
{
  if (a2 < 1) {
    return 1;
  }
  unsigned int v2 = 0;
  int v3 = 0;
  unsigned int v4 = 0;
  unsigned int v5 = 1;
  uint64_t v6 = a2;
  do
  {
    int v7 = v3 + 5000 * (v2 / 0x1388);
    BOOL v8 = v7 == 0;
    if (!v7) {
      v5 %= 0xFFF1u;
    }
    int v10 = *a1++;
    int v9 = v10;
    if (v8) {
      v4 %= 0xFFF1u;
    }
    v5 += v9;
    v4 += v5;
    --v3;
    ++v2;
    --v6;
  }
  while (v6);
  return (v5 % 0xFFF1) | ((v4 % 0xFFF1) << 16);
}

CFDataRef OSKextCreateMkext(const __CFAllocator *a1, const __CFArray *a2, const __CFURL *a3, int a4, int a5)
{
  return __OSKextCreateMkext(a1, a2, a3, a4, a5, 0, 0);
}

CFDataRef __OSKextCreateMkext(const __CFAllocator *a1, const __CFArray *AllKexts, const __CFURL *a3, int a4, int a5, int a6, const void *a7)
{
  uint64_t v184 = *MEMORY[0x1E4F143B8];
  char v175 = 0;
  bzero(buffer, 0x400uLL);
  if (!AllKexts) {
    CFArrayRef AllKexts = (const __CFArray *)OSKextGetAllKexts();
  }
  CFIndex Count = CFArrayGetCount(AllKexts);
  if (!Count) {
    return 0;
  }
  uint64_t v15 = Count;
  CFMutableDataRef Mutable = CFDataCreateMutable(a1, 0);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v17, v18, v19, v20, v21, v163);
    return 0;
  }
  CFMutableDataRef v22 = Mutable;
  *(_OWORD *)unsigned int bytes = 0u;
  memset(v177, 0, sizeof(v177));
  CFMutableDictionaryRef v23 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v23)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v24, v25, v26, v27, v28, v163);
    CFRelease(v22);
    return 0;
  }
  uint64_t v29 = v23;
  CFMutableArrayRef value = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  if (!value)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v30, v31, v32, v33, v34, v163);
    CFDataRef v139 = 0;
    CFDataRef v141 = 0;
    goto LABEL_100;
  }
  if (a3 && !CFURLGetFileSystemRepresentation(a3, 1u, buffer, 1024))
  {
    OSKextLog(0, 17, "String/URL conversion failure.", v35, v36, v37, v38, v39, v163);
    CFDataRef v141 = 0;
    goto LABEL_92;
  }
  CFDictionarySetValue(v29, @"_MKEXTInfoDictionaries", value);
  if (a7)
  {
    CFDictionarySetValue(v29, @"Kext Request Predicate", @"Load");
    CFDictionarySetValue(v29, @"Kext Request Arguments", a7);
  }
  int v171 = a5;
  object = v29;
  CFDataAppendBytes(v22, bytes, 44);
  if (v15 < 1)
  {
    LODWORD(v4(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
LABEL_77:
    uint64_t v29 = object;
    CFDataRef v141 = IOCFSerialize(object, 0);
    if (v141)
    {
      char v175 = 0;
      if (!v171) {
        goto LABEL_81;
      }
      if (__OSKextAddCompressedFileToMkext(0, v22, v141, 1, &v175))
      {
        if (v175)
        {
LABEL_82:
          MutableBytePtr = CFDataGetMutableBytePtr(v22);
          *(void *)MutableBytePtr = 0x58534F4D54584B4DLL;
          *((_DWORD *)MutableBytePtr + 2) = bswap32(CFDataGetLength(v22));
          CFDataRef v146 = v22;
          *((_DWORD *)MutableBytePtr + 4) = 18874370;
          uint32_t v147 = MutableBytePtr + 16;
          *((_DWORD *)MutableBytePtr + 5) = bswap32(v40);
          pthread_once(&__sOSKextInitialized, __OSKextInitialize);
          *((_DWORD *)MutableBytePtr + 6) = bswap32(*((_DWORD *)__sOSKextArchInfo + 2));
          pthread_once(&__sOSKextInitialized, __OSKextInitialize);
          *((_DWORD *)MutableBytePtr + 7) = bswap32(*((_DWORD *)__sOSKextArchInfo + 3));
          uint64_t v148 = CFDataGetLength(v146) - 16;
          if ((int)v148 < 1)
          {
            unsigned int v157 = 1;
          }
          else
          {
            unsigned int v149 = 0;
            int v150 = 0;
            unsigned int v151 = 0;
            unsigned int v152 = 1;
            do
            {
              int v153 = v150 + 5000 * (v149 / 0x1388);
              BOOL v154 = v153 == 0;
              if (!v153) {
                v152 %= 0xFFF1u;
              }
              int v156 = *v147++;
              int v155 = v156;
              if (v154) {
                v151 %= 0xFFF1u;
              }
              v152 += v155;
              v151 += v152;
              --v150;
              ++v149;
              --v148;
            }
            while (v148);
            unsigned int v157 = (v152 % 0xFFF1) | ((v151 % 0xFFF1) << 16);
          }
          *((_DWORD *)MutableBytePtr + 3) = bswap32(v157);
          CFMutableDataRef v22 = v146;
          CFRetain(v146);
          OSKextLog(0, 132, "Created mkext for architecture %s containing %u kexts.", v158, v159, v160, v161, v162, (char)*__sOSKextArchInfo);
          CFDataRef v139 = v146;
          goto LABEL_99;
        }
LABEL_81:
        uint64_t v142 = CFDataGetMutableBytePtr(v22);
        *((void *)v142 + 4) = bswap32(CFDataGetLength(v22));
        *((_DWORD *)v142 + 1(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = bswap32(CFDataGetLength(v141));
        BytePtr = CFDataGetBytePtr(v141);
        CFIndex Length = CFDataGetLength(v141);
        CFDataAppendBytes(v22, BytePtr, Length);
        goto LABEL_82;
      }
    }
LABEL_92:
    CFDataRef v139 = 0;
    goto LABEL_99;
  }
  int v174 = a4;
  uint64_t v40 = 0;
  CFIndex v41 = 0;
  uint64_t v167 = (void *)*MEMORY[0x1E4F1CFD0];
  int v170 = a6;
  while (1)
  {
    CFURLRef ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(AllKexts, v41);
    __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 0, v182, v43, v44, v45, v46);
    if (!__OSKextIsValid((uint64_t)ValueAtIndex, v47, v48, v49, v50, v51, v52, v53))
    {
      OSKextLog((uint64_t)ValueAtIndex, 133, "%s is not valid; omitting from mkext.",
        v56,
        v57,
        v58,
        v59,
        v60,
        (char)v182);
      goto LABEL_38;
    }
    if (a6 && OSKextIsLoaded(ValueAtIndex, v54, v55, v56, v57, v58, v59, v60))
    {
      OSKextLog((uint64_t)ValueAtIndex, 135, "Omitting loaded kext %s from mkext for kernel load.", v61, v62, v63, v64, v65, (char)v182);
      goto LABEL_38;
    }
    if (!OSKextMatchesRequiredFlags((uint64_t)ValueAtIndex, v174)) {
      goto LABEL_38;
    }
    if (!OSKextSupportsArchitecture((uint64_t)ValueAtIndex, 0))
    {
      pthread_once(&__sOSKextInitialized, __OSKextInitialize);
      OSKextLog((uint64_t)ValueAtIndex, 133, "%s does not contain code for architecture %s.", v106, v107, v108, v109, v110, (char)v182);
      goto LABEL_38;
    }
    CFIndex v66 = CFDataGetLength(v22);
    int valuePtr = 0;
    *(void *)CFDictionaryRef v179 = 0;
    char v178 = 0;
    __OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 1u, v183, v67, v68, v69, v70);
    if (!__sOSKextLoadAuditFunction(ValueAtIndex))
    {
      OSKextLog((uint64_t)ValueAtIndex, 33, "Load audit function returned false, bailing on adding %s to mkext.", v71, v72, v73, v74, v75, (char)v183);
      goto LABEL_97;
    }
    uint64_t v172 = v40;
    OSKextLog((uint64_t)ValueAtIndex, 133, "Adding %s to mkext.", v71, v72, v73, v74, v75, (char)v183);
    CFMutableDictionaryRef v76 = OSKextCopyInfoDictionary(ValueAtIndex);
    if (!v76) {
      break;
    }
    CFAllocatorRef v84 = v76;
    if ((*((unsigned char *)ValueAtIndex + 92) & 4) != 0
      && __OSKextHasSuffix((uint64_t)ValueAtIndex, v77, v78, v79, v80, v81, v82, v83)
      && (*((unsigned char *)ValueAtIndex + 92) & 1) == 0)
    {
      CFDictionaryRef ValueForInfoDictionaryKey = (const __CFDictionary *)OSKextGetValueForInfoDictionaryKey((uint64_t)ValueAtIndex, @"OSBundleLibraries");
      if (!ValueForInfoDictionaryKey)
      {
        OSKextLog((uint64_t)ValueAtIndex, 129, "Executable kext %s with no dependencies?!", v86, v87, v88, v89, v90, (char)v183);
LABEL_59:
        CFDataRef v96 = 0;
        CFNumberRef v104 = 0;
        goto LABEL_60;
      }
      uint64_t v91 = ValueForInfoDictionaryKey;
      if (!CFDictionaryGetValue(ValueForInfoDictionaryKey, @"com.apple.kpi.kasan")) {
        CFDictionarySetValue(v91, @"com.apple.kpi.kasan", @"8.0.0b1");
      }
      if (!CFDictionaryGetValue(v91, @"com.apple.kpi.kcov")) {
        CFDictionarySetValue(v91, @"com.apple.kpi.kcov", @"8.0.0b1");
      }
    }
    if ((*((unsigned char *)ValueAtIndex + 92) & 0x10) != 0) {
      CFDictionarySetValue(v84, @"OSBundleEnableKextLogging", v167);
    }
    pthread_once(&__sOSKextInitialized, __OSKextInitialize);
    CFDataRef v96 = OSKextCopyExecutableForArchitecture((uint64_t)ValueAtIndex, (uint64_t)__sOSKextArchInfo);
    if (v96)
    {
      int valuePtr = v66;
      CFAllocatorRef v97 = CFGetAllocator(ValueAtIndex);
      CFNumberRef v98 = CFNumberCreate(v97, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v104 = v98;
      if (!v98)
      {
        int v111 = 17;
        CFTypeRef v112 = "Memory allocation failure.";
        goto LABEL_55;
      }
      CFDictionarySetValue(v84, @"_MKEXTExecutable", v98);
      unsigned int v105 = CFDataGetLength(v96);
      *(_DWORD *)&v179[4] = bswap32(v105);
      if (!v171) {
        goto LABEL_44;
      }
      if (!__OSKextAddCompressedFileToMkext((uint64_t)ValueAtIndex, v22, v96, 0, &v178))
      {
        BOOL v164 = v183;
        CFNumberRef v98 = (CFNumberRef)ValueAtIndex;
        int v111 = 129;
        CFTypeRef v112 = "%s failed to compress executable.";
LABEL_55:
        OSKextLog((uint64_t)v98, v111, v112, v99, v100, v101, v102, v103, (char)v164);
LABEL_60:
        uint64_t v138 = 0;
        goto LABEL_61;
      }
      if (v178)
      {
        v168 = 0;
      }
      else
      {
LABEL_44:
        CFIndex v165 = v66;
        uint64_t v113 = CFDataGetBytePtr(v96);
        *(_DWORD *)CFDictionaryRef v179 = 0;
        CFDataAppendBytes(v22, v179, 8);
        v168 = v113;
        uint64_t v114 = v113;
        CFIndex v66 = v165;
        CFDataAppendBytes(v22, v114, v105);
      }
      OSKextLog((uint64_t)ValueAtIndex, 134, "%s added %u-byte %scompressed executable to mkext.", v99, v100, v101, v102, v103, (char)v183);
    }
    else
    {
      if ((*((unsigned char *)ValueAtIndex + 92) & 4) != 0)
      {
        pthread_once(&__sOSKextInitialized, __OSKextInitialize);
        OSKextLog((uint64_t)ValueAtIndex, 129, "Can't get executable for %s (architecture %s).", v133, v134, v135, v136, v137, (char)v183);
        goto LABEL_59;
      }
      CFNumberRef v104 = 0;
      v168 = 0;
    }
    if (__OSKextGetFileSystemPath((uint64_t)ValueAtIndex, 0, 1u, v183, v92, v93, v94, v95))
    {
      uint64_t v166 = v22;
      CFMutableArrayRef v120 = __absPathOnVolume((const char *)v183, (char *)buffer);
      CFAllocatorRef v121 = CFGetAllocator(ValueAtIndex);
      size_t v122 = strlen(v120);
      CFStringRef v123 = CFStringCreateWithBytes(v121, (const UInt8 *)v120, v122, 0x8000100u, 0);
      if (v123)
      {
        uint64_t v129 = (__CFString *)v123;
        CFDictionarySetValue(v84, @"_MKEXTBundlePath", v123);
        CFStringRef v130 = __OSKextCopyExecutableRelativePath((uint64_t)ValueAtIndex);
        CFMutableDataRef v22 = v166;
        if (v130)
        {
          uint64_t v131 = (__CFDictionary *)v130;
          CFDictionarySetValue(v84, @"_MKEXTExecutableRelativePath", v130);
          CFArrayAppendValue(value, v84);
          CFRelease(v84);
          CFRelease(v129);
          char v132 = 0;
          CFAllocatorRef v84 = v131;
        }
        else
        {
          CFArrayAppendValue(value, v84);
          CFRelease(v84);
          char v132 = 0;
          CFAllocatorRef v84 = (__CFDictionary *)v129;
        }
        uint64_t v138 = (UInt8 *)v168;
        goto LABEL_62;
      }
      OSKextLog(0, 17, "Memory allocation failure.", v124, v125, v126, v127, v128, (char)v164);
      CFMutableDataRef v22 = v166;
    }
    else
    {
      OSKextLog((uint64_t)ValueAtIndex, 17, "String/URL conversion failure.", v115, v116, v117, v118, v119, (char)v164);
    }
    uint64_t v138 = (UInt8 *)v168;
LABEL_61:
    CFDataSetLength(v22, v66);
    char v132 = 1;
LABEL_62:
    CFRelease(v84);
    if (v96) {
      CFRelease(v96);
    }
    if (v104) {
      CFRelease(v104);
    }
    if (v178 && v138) {
      free(v138);
    }
    a6 = v170;
    if (v132) {
      goto LABEL_98;
    }
    uint64_t v40 = v172 + 1;
LABEL_38:
    if (v15 == ++v41) {
      goto LABEL_77;
    }
  }
  OSKextLog((uint64_t)ValueAtIndex, 129, "Can't get info dictionary for %s.", v79, v80, v81, v82, v83, (char)v183);
LABEL_97:
  CFDataSetLength(v22, v66);
LABEL_98:
  CFDataRef v141 = 0;
  CFDataRef v139 = 0;
  uint64_t v29 = object;
LABEL_99:
  CFRelease(value);
LABEL_100:
  CFRelease(v29);
  CFRelease(v22);
  if (v141) {
    CFRelease(v141);
  }
  return v139;
}

CFMutableArrayRef OSKextCreateKextsFromMkextFile(const __CFAllocator *a1, const void *a2)
{
  resourceCFDataRef Data = 0;
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  if (CFURLCreateDataAndPropertiesFromResource(a1, (CFURLRef)a2, &resourceData, 0, 0, 0))
  {
    KextsFromCFDataRef Mkext = __OSKextCreateKextsFromMkext(a1, resourceData, a2);
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v4, v5, v6, v7, v8, v11);
    KextsFromCFDataRef Mkext = 0;
  }
  if (resourceData) {
    CFRelease(resourceData);
  }
  return KextsFromMkext;
}

CFMutableArrayRef __OSKextCreateKextsFromMkext(const __CFAllocator *a1, const __CFData *a2, const void *a3)
{
  CFTypeRef cf = 0;
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v7, v8, v9, v10, v11, v83);
    return 0;
  }
  CFMutableArrayRef v12 = Mutable;
  CFIndex v88 = 0;
  int v13 = *(_DWORD *)CFDataGetBytePtr(a2);
  BytePtr = CFDataGetBytePtr(a2);
  if (v13 != -1095041334)
  {
    CFMutableDataRef v22 = 0;
    CFIndex v88 = (CFIndex)BytePtr + CFDataGetLength(a2);
    goto LABEL_9;
  }
  uint64_t v15 = CFDataGetBytePtr(a2);
  CFIndex Length = CFDataGetLength(a2);
  CFMutableDataRef v22 = (int **)fat_iterator_for_data(BytePtr, (unint64_t)&v15[Length], 1);
  if (!v22)
  {
    uint64_t v46 = "Can't read mkext fat header.";
    goto LABEL_24;
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  cpu_type_t v23 = *((_DWORD *)__sOSKextArchInfo + 2);
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  BytePtr = fat_iterator_find_arch(v22, v23, *((_DWORD *)__sOSKextArchInfo + 3), &v88);
  if (BytePtr)
  {
LABEL_9:
    if (*BytePtr == 1415072589 && BytePtr[1] == 1481854797)
    {
      unsigned int v32 = bswap32(BytePtr[2]);
      if (v88 - (void)BytePtr == v32)
      {
        uint64_t v34 = (unsigned __int8 *)(BytePtr + 4);
        unsigned int v33 = BytePtr[4];
        if (v33 == 18874370)
        {
          CFIndex v35 = CFDataGetLength(a2);
          CFIndex v88 = (CFIndex)BytePtr + v35;
          uint64_t v36 = (v35 - 16);
          if ((int)v36 < 1)
          {
            unsigned int v45 = 1;
          }
          else
          {
            unsigned int v37 = 0;
            int v38 = 0;
            unsigned int v39 = 0;
            unsigned int v40 = 1;
            do
            {
              int v41 = v38 + 5000 * (v37 / 0x1388);
              BOOL v42 = v41 == 0;
              if (!v41) {
                v40 %= 0xFFF1u;
              }
              int v44 = *v34++;
              int v43 = v44;
              if (v42) {
                v39 %= 0xFFF1u;
              }
              v40 += v43;
              v39 += v40;
              --v38;
              ++v37;
              --v36;
            }
            while (v36);
            unsigned int v45 = (v40 % 0xFFF1) | ((v39 % 0xFFF1) << 16);
          }
          if (bswap32(BytePtr[3]) == v45)
          {
            unsigned int v48 = BytePtr[9];
            unsigned int v49 = bswap32(BytePtr[8]);
            unsigned int v50 = bswap32(v48);
            OSKextLog(0, 131079, "Mkext plist compressed size is %u.", v17, v18, v19, v20, v21, v50);
            size_t v51 = bswap32(BytePtr[10]);
            OSKextLog(0, 131079, "Mkext plist full size is %u.", v52, v53, v54, v55, v56, v51);
            if (!v48)
            {
              CFDataRef v29 = 0;
              uint64_t v59 = (char *)BytePtr + v49;
LABEL_47:
              uint64_t v60 = IOCFUnserialize(v59, a1, 0, (CFStringRef *)&cf);
              BytePtr = v60;
              if (!v60 || (CFTypeID v61 = CFGetTypeID(v60), v61 != CFDictionaryGetTypeID()))
              {
                CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString((const __CFString *)cf);
                uint64_t v30 = UTF8CStringForCFString;
                uint64_t v80 = "(unknown error)";
                if (UTF8CStringForCFString) {
                  LOBYTE(v8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = (_BYTE)UTF8CStringForCFString;
                }
                OSKextLog(0, 129, "Failed to read XML from mkext: %s.", v75, v76, v77, v78, v79, (char)v80);
                goto LABEL_26;
              }
              CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)BytePtr, @"_MKEXTInfoDictionaries");
              if (Value && (CFArrayRef v68 = Value, v69 = CFGetTypeID(Value), v69 == CFArrayGetTypeID()))
              {
                CFIndex Count = CFArrayGetCount(v68);
                if (Count < 1)
                {
LABEL_56:
                  CFRetain(v12);
                  uint64_t v30 = 0;
                  CFMutableArrayRef v31 = v12;
                  goto LABEL_27;
                }
                CFIndex v70 = 0;
                CFArrayRef v85 = v68;
                while (1)
                {
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v68, v70);
                  uint64_t v72 = __OSKextAlloc();
                  if (!v72)
                  {
                    uint64_t v81 = "Memory allocation failure.";
                    int v82 = 17;
                    goto LABEL_61;
                  }
                  uint64_t v73 = v72;
                  if (!__OSKextInitFromMkext((uint64_t)v72, ValueAtIndex, a3, a2)) {
                    break;
                  }
                  CFArrayAppendValue(v12, v73);
                  CFRelease(v73);
                  ++v70;
                  CFArrayRef v68 = v85;
                  if (Count == v70) {
                    goto LABEL_56;
                  }
                }
                CFRelease(v73);
              }
              else
              {
                uint64_t v81 = "Mkext plist has no kexts.";
                int v82 = 129;
LABEL_61:
                OSKextLog(0, v82, v81, v63, v64, v65, v66, v67, v84);
              }
              goto LABEL_6;
            }
            CFAllocatorRef v57 = CFGetAllocator(a2);
            UncompressMkext2FileCFDataRef Data = __OSKextCreateUncompressMkext2FileData(v57, (Bytef *)BytePtr + v49, v50, v51);
            CFDataRef v29 = UncompressMkext2FileData;
            if (UncompressMkext2FileData)
            {
              uint64_t v59 = (const char *)CFDataGetBytePtr(UncompressMkext2FileData);
              goto LABEL_47;
            }
LABEL_25:
            uint64_t v30 = 0;
            BytePtr = 0;
            goto LABEL_26;
          }
          uint64_t v46 = "Mkext checksum error.";
        }
        else
        {
          char v83 = bswap32(v33);
          uint64_t v46 = "Unsupported mkext version 0x%x.";
        }
      }
      else
      {
        char v83 = v32;
        uint64_t v46 = "Mkext length field %d does not match mkext actual size %d.";
      }
    }
    else
    {
      uint64_t v46 = "Bad mkext magic/signature.";
    }
LABEL_24:
    OSKextLog(0, 129, v46, v17, v18, v19, v20, v21, v83);
    CFDataRef v29 = 0;
    goto LABEL_25;
  }
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);
  OSKextLog(0, 129, "Architecture %s not found in mkext.", v24, v25, v26, v27, v28, (char)*__sOSKextArchInfo);
  CFDataRef v29 = 0;
LABEL_6:
  uint64_t v30 = 0;
LABEL_26:
  CFMutableArrayRef v31 = 0;
LABEL_27:
  CFRelease(v12);
  if (cf) {
    CFRelease(cf);
  }
  if (BytePtr) {
    CFRelease(BytePtr);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v30) {
    free(v30);
  }
  if (v22) {
    fat_iterator_close((void **)v22);
  }
  return v31;
}

CFMutableArrayRef OSKextCreateKextsFromMkextData(const __CFAllocator *a1, const __CFData *a2)
{
  pthread_once(&__sOSKextInitialized, __OSKextInitialize);

  return __OSKextCreateKextsFromMkext(a1, a2, 0);
}

const char *__absPathOnVolume(const char *a1, char *__s)
{
  if (__s && *__s)
  {
    size_t v4 = strlen(__s);
    size_t v5 = __s[v4 - 1] == 47 ? v4 - 1 : v4;
    if (v5)
    {
      if (!strncmp(a1, __s, v5)) {
        size_t v6 = v5;
      }
      else {
        size_t v6 = 0;
      }
      a1 += v6;
    }
  }
  return a1;
}

CFStringRef __OSKextCopyExecutableRelativePath(uint64_t a1)
{
  CFURLRef v2 = CFURLCopyAbsoluteURL(*(CFURLRef *)(a1 + 16));
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = (const __CFString *)v2;
  CFStringRef v4 = CFURLCopyFileSystemPath(v2, kCFURLPOSIXPathStyle);
  if (!v4)
  {
    CFStringRef v18 = 0;
    CFStringRef v16 = v3;
LABEL_16:
    CFRelease(v16);
    return v18;
  }
  CFStringRef v12 = v4;
  CFURLRef ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((void *)a1, v5, v6, v7, v8, v9, v10, v11);
  if (!ExecutableURL)
  {
    CFStringRef v18 = 0;
    CFURLRef v15 = 0;
LABEL_11:
    CFStringRef v16 = 0;
    goto LABEL_13;
  }
  CFURLRef v14 = CFURLCopyAbsoluteURL(ExecutableURL);
  CFURLRef v15 = v14;
  if (!v14)
  {
    CFStringRef v18 = 0;
    goto LABEL_11;
  }
  CFStringRef v16 = CFURLCopyFileSystemPath(v14, kCFURLPOSIXPathStyle);
  if (v16)
  {
    CFIndex v17 = CFStringGetLength(v12) + 1;
    v20.CFIndex length = CFStringGetLength(v16) - v17;
    v20.CFIndex location = v17;
    CFStringRef v18 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v16, v20);
  }
  else
  {
    CFStringRef v18 = 0;
  }
LABEL_13:
  CFRelease(v3);
  CFRelease(v12);
  if (v15) {
    CFRelease(v15);
  }
  if (v16) {
    goto LABEL_16;
  }
  return v18;
}

CFStringRef OSKextCopyExecutableName(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 92) & 8) != 0) {
    return 0;
  }
  CFURLRef ExecutableURL = (const __CFURL *)OSKextGetExecutableURL((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (!ExecutableURL) {
    return 0;
  }

  return CFURLCopyLastPathComponent(ExecutableURL);
}

void OSKextVLogCFString(uint64_t a1, int a2, const __CFString *a3, va_list a4)
{
  if (__sOSKextLogOutputFunction)
  {
    int v6 = a1;
    if (__OSKextShouldLog(a1, a2))
    {
      CFStringRef v7 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3, a4);
      if (v7)
      {
        CFStringRef v8 = v7;
        CFIndex Length = CFStringGetLength(v7);
        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        uint64_t v11 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0x46499120uLL);
        if (v11)
        {
          CFStringRef v12 = v11;
          if (CFStringGetCString(v8, v11, MaximumSizeForEncoding, 0x8000100u)) {
            __sOSKextLogOutputFunction(v6, a2, "%s", v12);
          }
          CFRelease(v8);
          free(v12);
        }
        else
        {
          CFRelease(v8);
        }
      }
    }
  }
}

const void *_isDictionary(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFDictionaryGetTypeID());
  }
  return result;
}

const void *_isArray(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFArrayGetTypeID());
  }
  return result;
}

const void *_isString(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFStringGetTypeID());
  }
  return result;
}

void __OSKextReleaseContents(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  memcpy(__dst, "(unknown)", sizeof(__dst));
  CFIndex Count = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
  if (Count >= 1)
  {
    unint64_t v9 = Count + 1;
    do
    {
      if (CFArrayGetValueAtIndex((CFArrayRef)__sOSAllKexts, v9 - 2) == (const void *)a1) {
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)__sOSAllKexts, v9 - 2);
      }
      --v9;
    }
    while (v9 > 1);
  }
  CFStringRef v10 = *(const __CFString **)(a1 + 24);
  if (v10) {
    CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString(v10);
  }
  else {
    CFDictionaryRef UTF8CStringForCFString = 0;
  }
  CFURLRef v12 = *(const __CFURL **)(a1 + 16);
  if (v12)
  {
    CFURLRef v13 = CFURLCopyAbsoluteURL(v12);
    if (v13)
    {
      __OSKextGetFileSystemPath(0, v13, 1u, __dst, v5, v6, v7, v8);
      if ((*(unsigned char *)(a1 + 88) & 8) == 0
        && CFDictionaryGetValue((CFDictionaryRef)__sOSKextsByURL, v13) == (const void *)a1)
      {
        CFDictionaryRemoveValue((CFMutableDictionaryRef)__sOSKextsByURL, v13);
      }
    }
  }
  else
  {
    CFURLRef v13 = 0;
  }
  __OSKextRemoveKextFromIdentifierDict(a1, (const __CFDictionary *)__sOSKextsByIdentifier, v3, v4, v5, v6, v7, v8, v24);
  OSKextVersionGetString(*(void *)(a1 + 40), v25, 0x14u);
  OSKextLog(a1, 262149, "Removed %s, id %s%s, version %s.", v14, v15, v16, v17, v18, (char)__dst);
  if (v13) {
    CFRelease(v13);
  }
  if (UTF8CStringForCFString) {
    free(UTF8CStringForCFString);
  }
  OSKextFlushDiagnostics(a1, -1);
  OSKextFlushLoadInfo(a1, 1);
  uint64_t v19 = *(CFTypeRef **)(a1 + 80);
  if (v19)
  {
    if (*v19)
    {
      CFRelease(*v19);
      uint64_t v19 = *(CFTypeRef **)(a1 + 80);
    }
    *uint64_t v19 = 0;
    if (v19[1])
    {
      CFRelease(v19[1]);
      uint64_t v19 = *(CFTypeRef **)(a1 + 80);
    }
    v19[1] = 0;
    if (v19[2])
    {
      CFRelease(v19[2]);
      uint64_t v19 = *(CFTypeRef **)(a1 + 80);
    }
    v19[2] = 0;
    if (v19[3])
    {
      CFRelease(v19[3]);
      uint64_t v19 = *(CFTypeRef **)(a1 + 80);
    }
    free(v19);
    *(void *)(a1 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = 0;
  }
  CFRange v20 = *(const void **)(a1 + 16);
  if (v20) {
    CFRelease(v20);
  }
  *(void *)(a1 + 16) = 0;
  uint64_t v21 = *(const void **)(a1 + 24);
  if (v21) {
    CFRelease(v21);
  }
  *(void *)(a1 + 24) = 0;
  CFMutableDataRef v22 = *(const void **)(a1 + 32);
  if (v22) {
    CFRelease(v22);
  }
  *(void *)(a1 + 32) = 0;
  cpu_type_t v23 = *(const void **)(a1 + 56);
  if (v23) {
    CFRelease(v23);
  }
  *(void *)(a1 + 56) = 0;
}

__CFString *__OSKextCopyDebugDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v3 = *(__CFString **)(a1 + 24);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringRef v10 = Mutable;
  if (Mutable)
  {
    CFStringAppendFormat(Mutable, 0, @"<OSKext %p [%p]> { ", a1, v2);
    if ((*(unsigned char *)(a1 + 88) & 8) != 0)
    {
      uint64_t v11 = **(__CFString ***)(a1 + 80);
      if (!v11) {
        uint64_t v11 = @"(unknown)";
      }
      CFStringAppendFormat(v10, 0, @"mkext URL = \"%@\", ", v11);
      if (*(void *)(a1 + 16)) {
        CFStringAppendFormat(v10, 0, @"original URL = \"%@\", ", *(void *)(a1 + 16));
      }
    }
    else if (*(void *)(a1 + 16))
    {
      CFStringAppendFormat(v10, 0, @"URL = \"%@\", ", *(void *)(a1 + 16));
    }
    if (v3) {
      CFURLRef v12 = v3;
    }
    else {
      CFURLRef v12 = @"(unknown)";
    }
    CFStringAppendFormat(v10, 0, @"ID = \"%@\"", v12);
    CFStringAppendFormat(v10, 0, @" }");
  }
  else
  {
    OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v14);
  }
  return v10;
}

void __OSKextReinitApplierFunction(uint64_t a1, uint64_t a2)
{
}

uint64_t __OSKextRecordKextInIdentifierDict(CFMutableArrayRef a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unint64_t *)a1;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  CFStringRef v9 = (const __CFString *)*((void *)a1 + 3);
  if (!v9)
  {
    uint64_t v17 = "Can't record kext in identifier lookup dictionary; no identifier.";
    int v18 = 262145;
    goto LABEL_12;
  }
  CFArrayRef Value = (unint64_t *)CFDictionaryGetValue(theDict, v9);
  CFURLRef v12 = Value;
  if (!Value)
  {
    CFDictionarySetValue(theDict, v9, v8);
    CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString(v9);
    if (UTF8CStringForCFString) {
      goto LABEL_30;
    }
    return 1;
  }
  if (Value == v8)
  {
    CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString(v9);
    CFURLRef v12 = v8;
    if (UTF8CStringForCFString) {
      goto LABEL_30;
    }
    return 1;
  }
  uint64_t v13 = __kOSKextTypeID;
  if (v13 == CFGetTypeID(Value))
  {
    long long v14 = *(_OWORD *)(MEMORY[0x1E4F1D510] + 16);
    *(_OWORD *)&callBacks.version = *MEMORY[0x1E4F1D510];
    *(_OWORD *)&callBacks.release = v14;
    callBacks.equal = *(CFArrayEqualCallBack *)(MEMORY[0x1E4F1D510] + 32);
    callBacks.retain = 0;
    callBacks.release = 0;
    a1 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callBacks);
    if (a1)
    {
      CFMutableArrayRef v15 = a1;
      CFArrayAppendValue(a1, v12);
      CFDictionarySetValue(theDict, v9, v15);
      CFURLRef v12 = (unint64_t *)v15;
      goto LABEL_7;
    }
    uint64_t v17 = "Memory allocation failure.";
    int v18 = 17;
LABEL_12:
    OSKextLog((uint64_t)a1, v18, v17, a4, a5, a6, a7, a8, v38);
    return 0;
  }
LABEL_7:
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(v12))
  {
    if (__sOSKextStrictRecordingByLastOpened)
    {
      v41.CFIndex length = CFArrayGetCount((CFArrayRef)v12);
      v41.CFIndex location = 0;
      if (CFArrayGetFirstIndexOfValue((CFArrayRef)v12, v41, v8) == -1) {
        CFArrayInsertValueAtIndex((CFMutableArrayRef)v12, 0, v8);
      }
      return 1;
    }
    int64_t v21 = v8[5];
    v42.CFIndex length = CFArrayGetCount((CFArrayRef)v12);
    v42.CFIndex location = 0;
    FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue((CFArrayRef)v12, v42, v8);
    if (FirstIndexOfValue != -1) {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)v12, FirstIndexOfValue);
    }
    CFArrayRef v23 = (const __CFArray *)__sOSAllKexts;
    v43.CFIndex length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
    v43.CFIndex location = 0;
    CFIndex v24 = CFArrayGetFirstIndexOfValue(v23, v43, v8);
    CFIndex Count = CFArrayGetCount((CFArrayRef)v12);
    if (Count < 1)
    {
      CFIndex v27 = 0;
    }
    else
    {
      CFIndex v26 = Count;
      CFIndex v27 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v12, v27);
        int64_t v29 = ValueAtIndex[5];
        CFArrayRef v30 = (const __CFArray *)__sOSAllKexts;
        v44.CFIndex length = CFArrayGetCount((CFArrayRef)__sOSAllKexts);
        v44.CFIndex location = 0;
        CFIndex v31 = CFArrayGetFirstIndexOfValue(v30, v44, ValueAtIndex);
        BOOL v32 = v21 == v29;
        if (v24 <= v31) {
          BOOL v32 = 0;
        }
        if (v21 > v29 || v32) {
          break;
        }
        if (v26 == ++v27)
        {
          CFIndex v27 = v26;
          break;
        }
      }
    }
    CFArrayInsertValueAtIndex((CFMutableArrayRef)v12, v27, v8);
    CFDictionaryRef UTF8CStringForCFString = createUTF8CStringForCFString(v9);
    if (!UTF8CStringForCFString) {
      return 1;
    }
LABEL_30:
    OSKextVersionGetString(v8[5], &callBacks, 0x14u);
    if (v12 == v8) {
      OSKextLog((uint64_t)v8, 262149, "%s, version %s is already in the identifier lookup dictionary at index %d.", v33, v34, v35, v36, v37, (char)UTF8CStringForCFString);
    }
    else {
      OSKextLog((uint64_t)v8, 262151, "%s, version %s recorded at index %d in the identifier lookup dictionary.", v33, v34, v35, v36, v37, (char)UTF8CStringForCFString);
    }
    free(UTF8CStringForCFString);
  }
  return 1;
}

uint64_t __OSKextCreateMkextInfo(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    return 1;
  }
  CFAllocatorRef v2 = malloc_type_malloc(0x20uLL, 0x60040FAD0F902uLL);
  *(void *)(a1 + 8(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = v2;
  if (v2)
  {
    _OWORD *v2 = 0u;
    v2[1] = 0u;
    return 1;
  }
  OSKextLog(0, 17, "Memory allocation failure.", v3, v4, v5, v6, v7, v9);
  return 0;
}

CFDataRef __OSKextCreateUncompressMkext2FileData(const __CFAllocator *a1, Bytef *a2, uInt a3, size_t size)
{
  uInt v4 = size;
  CFIndex v8 = size;
  char v9 = (Bytef *)malloc_type_malloc(size, 0x92272CC3uLL);
  if (!v9)
  {
    OSKextLog(0, 17, "Memory allocation failure.", v10, v11, v12, v13, v14, v33);
    return 0;
  }
  CFMutableArrayRef v15 = v9;
  memset(&strm.avail_out + 1, 0, 76);
  *(_OWORD *)&strm.avail_in = 0u;
  strm.next_in = a2;
  strm.next_out = v9;
  strm.avail_in = a3;
  strm.avail_out = v4;
  if (inflateInit_(&strm, "1.2.12", 112))
  {
    OSKextLog(0, 131073, "zlib inflateInit failed.", v16, v17, v18, v19, v20, v33);
LABEL_16:
    free(v15);
    return 0;
  }
  int v21 = inflate(&strm, 4);
  if (!v21) {
    goto LABEL_10;
  }
  if (v21 != 1)
  {
    LOBYTE(v3(*(void (**)(void, void))(**((void **)transaction + 3) + 104))(*((void *)transaction + 3), 0) = strm.msg;
    if (!strm.msg) {
      CFArrayRef v30 = "unknown";
    }
    char v33 = (char)v30;
    int64_t v29 = "zlib inflate failed: %s.";
    goto LABEL_14;
  }
  if (LODWORD(strm.total_out) != v4)
  {
LABEL_10:
    int64_t v29 = "zlib inflate discrepancy, uncompressed size != original size.";
LABEL_14:
    int v31 = 131073;
LABEL_15:
    OSKextLog(0, v31, v29, v22, v23, v24, v25, v26, v33);
    inflateEnd(&strm);
    goto LABEL_16;
  }
  CFDataRef v27 = CFDataCreateWithBytesNoCopy(a1, v15, v8, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
  if (!v27)
  {
    int64_t v29 = "Memory allocation failure.";
    int v31 = 17;
    goto LABEL_15;
  }
  CFDataRef v28 = v27;
  inflateEnd(&strm);
  return v28;
}

CFURLRef __OSKextHasSuffix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 92) & 8) != 0) {
    return 0;
  }
  CFURLRef result = (const __CFURL *)OSKextGetExecutableURL((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    CFURLRef result = (const __CFURL *)__OSKextGetFileSystemPath(0, result, 1u, __s, v9, v10, v11, v12);
    if (result)
    {
      size_t v13 = strlen((const char *)__s);
      return (const __CFURL *)(v13 >= 7 && !strncmp("_kasan", (const char *)&__s[v13 - 6], 6uLL));
    }
  }
  return result;
}

void __OSKextAddDependenciesApplierFunction(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 92) & 1) == 0)
  {
    uint64_t v10 = *(const __CFArray ***)(a1 + 72);
    if (v10 && (CFArrayRef v11 = *v10) != 0)
    {
      ++*((_DWORD *)a2 + 3);
      v20.CFIndex length = CFArrayGetCount(v11);
      v20.CFIndex location = 0;
      CFArrayApplyFunction(v11, v20, (CFArrayApplierFunction)__OSKextAddDependenciesApplierFunction, a2);
      --*((_DWORD *)a2 + 3);
    }
    else
    {
      __OSKextGetFileSystemPath(a1, 0, 1u, buffer, a5, a6, a7, a8);
      OSKextLog(a1, 16385, "%s - missing load info or dependencies array in applier function.", v12, v13, v14, v15, v16, (char)buffer);
      *((unsigned char *)a2 + 16) = 1;
    }
  }
  if (!*((unsigned char *)a2 + 16) && *((_DWORD *)a2 + 3) >= *((_DWORD *)a2 + 2))
  {
    CFArrayRef v17 = (const __CFArray *)*a2;
    v21.CFIndex length = CFArrayGetCount((CFArrayRef)*a2);
    v21.CFIndex location = 0;
    if (CFArrayGetFirstIndexOfValue(v17, v21, (const void *)a1) == -1) {
      CFArrayAppendValue((CFMutableArrayRef)*a2, (const void *)a1);
    }
  }
}

CFMutableDictionaryRef __OSKextGetDiagnostics(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 64))
  {
    uInt v4 = malloc_type_malloc(0x28uLL, 0x20040769AC3DAuLL);
    *(void *)(a1 + 64) = v4;
    if (!v4)
    {
LABEL_20:
      OSKextLog(0, 17, "Memory allocation failure.", v5, v6, v7, v8, v9, v11);
      return 0;
    }
    v4[4] = 0;
    *(_OWORD *)uInt v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
  }
  CFMutableDictionaryRef result = 0;
  switch(a2)
  {
    case 1:
      CFMutableDictionaryRef result = **(CFMutableDictionaryRef **)(a1 + 64);
      if (!result)
      {
        CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        **(void **)(a1 + 64) = result;
        if (!result) {
          goto LABEL_20;
        }
      }
      break;
    case 2:
      CFMutableDictionaryRef result = *(CFMutableDictionaryRef *)(*(void *)(a1 + 64) + 8);
      if (!result)
      {
        CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(void *)(*(void *)(a1 + 64) + 8) = result;
        if (!result) {
          goto LABEL_20;
        }
      }
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      return result;
    case 4:
      CFMutableDictionaryRef result = *(CFMutableDictionaryRef *)(*(void *)(a1 + 64) + 16);
      if (!result)
      {
        CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(void *)(*(void *)(a1 + 64) + 16) = result;
        if (!result) {
          goto LABEL_20;
        }
      }
      break;
    case 8:
      CFMutableDictionaryRef result = *(CFMutableDictionaryRef *)(*(void *)(a1 + 64) + 24);
      if (!result)
      {
        CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(void *)(*(void *)(a1 + 64) + 24) = result;
        if (!result) {
          goto LABEL_20;
        }
      }
      break;
    default:
      if (a2 == 16)
      {
        CFMutableDictionaryRef result = *(CFMutableDictionaryRef *)(*(void *)(a1 + 64) + 32);
        if (!result)
        {
          CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          *(void *)(*(void *)(a1 + 64) + 32) = result;
          if (!result) {
            goto LABEL_20;
          }
        }
      }
      break;
  }
  return result;
}

void __OSKextValidateOSBundleLibraryApplierFunction(const __CFString *value, const __CFString *a2, uint64_t a3)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), value);
  uint64_t v6 = *(void *)a3;
  CFDictionaryRef v7 = *(const __CFDictionary **)(a3 + 8);
  CFStringRef v8 = *(const __CFString **)(a3 + 16);
  CFStringRef TypeID = (const __CFString *)CFStringGetTypeID();
  if (!__OSKextCheckProperty(v6, v7, value, v8, TypeID, 0, 0, 1, 1, 0, 0))
  {
    *(unsigned char *)(a3 + 24) = 0;
    goto LABEL_11;
  }
  uint64_t v13 = OSKextParseVersionCFString(a2);
  if (v13 == -1)
  {
    __OSKextAddDiagnostic(*(void *)a3, 1, @"Info dictionary property value is illegal", *(const __CFString **)(a3 + 16), 0, v10, v11, v12, v16);
    *(unsigned char *)(a3 + 24) = 0;
  }
  if (CFStringHasPrefix(value, @"com.apple.kernel"))
  {
    *(unsigned char *)(a3 + 25) = 1;
  }
  else
  {
    if (!CFStringHasPrefix(value, @"com.apple.kpi.")) {
      goto LABEL_11;
    }
    *(unsigned char *)(a3 + 26) = 1;
  }
  if (v13 < __sOSNewKmodInfoKernelVersion) {
    *(_DWORD *)(*(void *)a3 + 92) |= 0x10000u;
  }
LABEL_11:
  CFArrayRef v14 = *(const __CFArray **)(a3 + 16);
  CFIndex v15 = CFArrayGetCount(v14) - 1;

  CFArrayRemoveValueAtIndex(v14, v15);
}

void __OSKextValidateIOKitPersonalityApplierFunction(const __CFString *value, const __CFDictionary *a2, uint64_t a3)
{
  char v87 = 0;
  CFTypeRef cf1 = 0;
  CFTypeRef v86 = 0;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), value);
  uint64_t v6 = *(void *)a3;
  CFDictionaryRef v7 = *(const __CFDictionary **)(a3 + 8);
  CFStringRef v8 = *(const __CFString **)(a3 + 16);
  CFStringRef TypeID = (const __CFString *)CFDictionaryGetTypeID();
  if (!__OSKextCheckProperty(v6, v7, value, v8, TypeID, 0, 0, 1, 0, 0, 0))
  {
    *(unsigned char *)(a3 + 24) = 0;
    goto LABEL_61;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), @"IOKitDebug");
  uint64_t v10 = *(void *)a3;
  CFStringRef v11 = *(const __CFString **)(a3 + 16);
  CFStringRef v12 = (const __CFString *)CFNumberGetTypeID();
  int v13 = __OSKextCheckProperty(v10, a2, @"IOKitDebug", v11, v12, 0, 0, 1, 0, 0, &v87);
  if (v13) {
    BOOL v14 = *(unsigned char *)(a3 + 24) == 0;
  }
  else {
    BOOL v14 = 1;
  }
  char v15 = !v14;
  *(unsigned char *)(a3 + 24) = v15;
  if (v13 && v87) {
    *(_DWORD *)(*(void *)a3 + 92) |= 0x40u;
  }
  CFArrayRef v16 = *(const __CFArray **)(a3 + 16);
  CFIndex Count = CFArrayGetCount(v16);
  CFArrayRemoveValueAtIndex(v16, Count - 1);
  if (!*(unsigned char *)(a3 + 25))
  {
    CFStringRef v18 = (const __CFString *)*MEMORY[0x1E4F1CFF8];
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), (const void *)*MEMORY[0x1E4F1CFF8]);
    uint64_t v19 = *(void *)a3;
    CFStringRef v20 = *(const __CFString **)(a3 + 16);
    CFStringRef v21 = (const __CFString *)CFStringGetTypeID();
    int v22 = __OSKextCheckProperty(v19, a2, v18, v20, v21, 0, 0, 1, 1, (const __CFString **)&cf1, &v87);
    if (*(unsigned char *)(a3 + 24)) {
      BOOL v26 = v22 == 0;
    }
    else {
      BOOL v26 = 1;
    }
    char v27 = !v26;
    *(unsigned char *)(a3 + 24) = v27;
    uint64_t v28 = *(void *)a3;
    if (cf1)
    {
      if (!CFEqual(cf1, *(CFTypeRef *)(v28 + 24)))
      {
        CFStringRef v29 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ -> %@ (kext is %@)");
        __OSKextAddDiagnostic(*(void *)a3, 8, @"Personality CFBundleIdentifier differs from containing kext's (not necessarily a mistake, but rarely done)", value, 0, v30, v31, v32, (char)value);
        if (v29) {
          CFRelease(v29);
        }
      }
    }
    else
    {
      __OSKextAddDiagnostic(v28, 8, @"Personality has no CFBundleIdentifier; the kext's identifier will be inserted when sending to the IOCatalogue",
        value,
        0,
        v23,
        v24,
        v25,
        v82);
    }
    if (cf1)
    {
      KextWithCFStringRef Identifier = OSKextGetKextWithIdentifier((void *)cf1);
      if (KextWithIdentifier)
      {
        if ((KextWithIdentifier[92] & 4) != 0) {
          goto LABEL_31;
        }
        char v83 = (char)value;
        CFStringRef v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"'%@' -> '%@'");
        uint64_t v38 = *(void *)a3;
        unsigned int v39 = @"Personality CFBundleIdentifier names a kext that doesn't declare an executable";
      }
      else
      {
        char v83 = (char)value;
        CFStringRef v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"'%@' -> '%@'");
        uint64_t v38 = *(void *)a3;
        unsigned int v39 = @"Personality CFBundleIdentifier names a kext that can't be found";
      }
      __OSKextAddDiagnostic(v38, 8, v39, v37, 0, v34, v35, v36, v83);
      if (v37) {
        CFRelease(v37);
      }
    }
LABEL_31:
    CFArrayRef v40 = *(const __CFArray **)(a3 + 16);
    CFIndex v41 = CFArrayGetCount(v40);
    CFArrayRemoveValueAtIndex(v40, v41 - 1);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), @"IOClass");
    uint64_t v42 = *(void *)a3;
    CFStringRef v43 = *(const __CFString **)(a3 + 16);
    CFStringRef v44 = (const __CFString *)CFStringGetTypeID();
    int v45 = __OSKextCheckProperty(v42, a2, @"IOClass", v43, v44, 0, 1, 1, 1, (const __CFString **)&v86, 0);
    if (*(unsigned char *)(a3 + 24)) {
      BOOL v46 = v45 == 0;
    }
    else {
      BOOL v46 = 1;
    }
    char v47 = !v46;
    *(unsigned char *)(a3 + 24) = v47;
    CFArrayRef v48 = *(const __CFArray **)(a3 + 16);
    CFIndex v49 = CFArrayGetCount(v48);
    CFArrayRemoveValueAtIndex(v48, v49 - 1);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), @"IOProviderClass");
    uint64_t v50 = *(void *)a3;
    CFStringRef v51 = *(const __CFString **)(a3 + 16);
    CFStringRef v52 = (const __CFString *)CFStringGetTypeID();
    int v53 = __OSKextCheckProperty(v50, a2, @"IOProviderClass", v51, v52, 0, 1, 1, 1, (const __CFString **)&cf1, 0);
    if (v53) {
      BOOL v54 = *(unsigned char *)(a3 + 24) == 0;
    }
    else {
      BOOL v54 = 1;
    }
    char v55 = !v54;
    *(unsigned char *)(a3 + 24) = v55;
    if (v53)
    {
      int v56 = CFEqual(cf1, @"IOResources");
      CFArrayRef v57 = *(const __CFArray **)(a3 + 16);
      CFIndex v58 = CFArrayGetCount(v57);
      CFArrayRemoveValueAtIndex(v57, v58 - 1);
      if (!v56) {
        goto LABEL_57;
      }
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), @"IOMatchCategory");
      uint64_t v59 = *(void *)a3;
      CFStringRef v60 = *(const __CFString **)(a3 + 16);
      CFStringRef v61 = (const __CFString *)CFStringGetTypeID();
      int v62 = __OSKextCheckProperty(v59, a2, @"IOMatchCategory", v60, v61, 0, 0, 1, 0, (const __CFString **)&cf1, 0);
      if (v62) {
        BOOL v63 = *(unsigned char *)(a3 + 24) == 0;
      }
      else {
        BOOL v63 = 1;
      }
      char v64 = !v63;
      *(unsigned char *)(a3 + 24) = v64;
      if (v62 && cf1 && v86 && !CFEqual(v86, cf1)) {
        __OSKextAddDiagnostic(*(void *)a3, 8, @"Personality matches on IOResources but IOMatchCategory is missing or not equal to its IOClass; driver may be blocked from matching or may block others",
      }
          value,
          0,
          v65,
          v66,
          v67,
          v84);
    }
    CFArrayRef v68 = *(const __CFArray **)(a3 + 16);
    CFIndex v69 = CFArrayGetCount(v68);
    CFArrayRemoveValueAtIndex(v68, v69 - 1);
LABEL_57:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), @"IOProbeScore");
    uint64_t v70 = *(void *)a3;
    CFStringRef v71 = *(const __CFString **)(a3 + 16);
    CFStringRef v72 = (const __CFString *)CFNumberGetTypeID();
    __OSKextCheckProperty(v70, a2, @"IOProbeScore", v71, v72, 0, 0, 0, 0, 0, 0);
    CFArrayRef v73 = *(const __CFArray **)(a3 + 16);
    CFIndex v74 = CFArrayGetCount(v73);
    CFArrayRemoveValueAtIndex(v73, v74 - 1);
    if ((*(unsigned char *)(*(void *)a3 + 92) & 8) != 0)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), @"CFBundleIdentifierKernel");
      uint64_t v75 = *(void *)a3;
      CFStringRef v76 = *(const __CFString **)(a3 + 16);
      CFStringRef v77 = (const __CFString *)CFStringGetTypeID();
      if (!__OSKextCheckProperty(v75, a2, @"CFBundleIdentifierKernel", v76, v77, 0, 1, 1, 1, (const __CFString **)&cf1, &v87))__OSKextSetDiagnostic(*(void *)a3, 1, @"The 'CFBundleIdentifierKernel' key is required in your personality to specify the base kext to load when your kext is instantiated."); {
      CFArrayRef v78 = *(const __CFArray **)(a3 + 16);
      }
      CFIndex v79 = CFArrayGetCount(v78);
      CFArrayRemoveValueAtIndex(v78, v79 - 1);
    }
  }
LABEL_61:
  CFArrayRef v80 = *(const __CFArray **)(a3 + 16);
  CFIndex v81 = CFArrayGetCount(v80);
  CFArrayRemoveValueAtIndex(v80, v81 - 1);
}