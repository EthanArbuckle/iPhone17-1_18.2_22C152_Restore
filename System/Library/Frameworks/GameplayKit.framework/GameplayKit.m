void sub_235EB1A1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_235EB1B3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EB1B50(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v2 + 24));
  MEMORY[0x237DF7CA0](v2, 0x10A0C40EBF3C9F8);

  _Unwind_Resume(a1);
}

void sub_235EB1C1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EB1D48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void std::vector<NSObject * {__strong}>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(char **)a1;
  if (a2 <= (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) {
    return;
  }
  if (a2 >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  v4 = *(char **)(a1 + 8);
  uint64_t v5 = 8 * a2;
  v6 = (char *)operator new(8 * a2);
  v7 = &v6[v5];
  uint64_t v8 = v4 - v2;
  unint64_t v9 = (unint64_t)&v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
  if (v4 != v2)
  {
    unint64_t v10 = v8 - 8;
    if ((unint64_t)(v8 - 8) >= 0x78)
    {
      BOOL v12 = (unint64_t)&v4[-(v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v9
         || &v6[(v8 & 0xFFFFFFFFFFFFFFF8) - (v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v4;
      v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
      if (v12)
      {
        uint64_t v13 = v8 >> 3;
        uint64_t v14 = (v10 >> 3) + 1;
        uint64_t v15 = 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
        v11 = (char *)(v9 - v15);
        v16 = &v4[-v15];
        v17 = v4 - 16;
        v18 = &v6[8 * v13 - 16];
        uint64_t v19 = v14 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v21 = *((_OWORD *)v17 - 1);
          long long v20 = *(_OWORD *)v17;
          *((_OWORD *)v17 - 1) = 0uLL;
          *(_OWORD *)v17 = 0uLL;
          *((_OWORD *)v18 - 1) = v21;
          *(_OWORD *)v18 = v20;
          v17 -= 32;
          v18 -= 32;
          v19 -= 4;
        }
        while (v19);
        v4 = v16;
        if (v14 == (v14 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_16:
          v23 = *(char **)a1;
          uint64_t v2 = *(char **)(a1 + 8);
          *(void *)a1 = v11;
          *(void *)(a1 + 8) = v9;
          *(void *)(a1 + 16) = v7;
          if (v2 != v23)
          {
            do
            {
              v24 = (void *)*((void *)v2 - 1);
              v2 -= 8;
            }
            while (v2 != v23);
            uint64_t v2 = v23;
          }
          goto LABEL_19;
        }
      }
    }
    else
    {
      v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      uint64_t v22 = *((void *)v4 - 1);
      v4 -= 8;
      *(void *)v4 = 0;
      *((void *)v11 - 1) = v22;
      v11 -= 8;
    }
    while (v4 != v2);
    goto LABEL_16;
  }
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v7;
LABEL_19:
  if (v2)
  {
    operator delete(v2);
  }
}

void **std::vector<NSObject * {__strong}>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 1);
        v3 -= 8;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void **_ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(void **a1)
{
  uint64_t v2 = (id *)*a1;
  if (*a1)
  {
    v3 = (id *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v3 - 4);
        v3 -= 7;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void _ZN12GKCRTreeNodeI8NSObjectDv2_fE12InsertObjectEPS0_S1_S1_21GKCRTreeSplitStrategy(float32x2_t *a1, void *a2, uint64_t a3, float32x2_t a4, float32x2_t a5)
{
  id v9 = a2;
  float32x2_t v20 = a5;
  float32x2_t v21 = a4;
  unint64_t v10 = (float32x2_t *)a1[3];
  float32x2_t v11 = a1[4];
  unint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v11 - (void)v10) >> 3);
  if (v12 >= a1->u32[0])
  {
    _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_((int *)a1, v9, &v21, &v20);
    switch((int)a3)
    {
      case 0:
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE10SplitHalveEPS0_RKS1_S5_(a1, v9);
        break;
      case 1:
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE11SplitLinearEPS0_RKS1_S5_(a1, v9);
        break;
      case 2:
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE14SplitQuadraticEPS0_RKS1_S5_(a1, v9);
        break;
      case 3:
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS0_RKS1_S5_(a1, v9);
        break;
      default:
        __assert_rtn("InsertObject", "GKCRTree.h", 217, "false");
    }
  }
  else if ((float32x2_t *)v11 == v10 || (float32x2_t v13 = v10[6], *(void *)&v13))
  {
    _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_((int *)a1, v9, &v21, &v20);
  }
  else
  {
    float32x2_t v14 = 0;
    if (v12 <= 1) {
      unint64_t v12 = 1;
    }
    uint64_t v15 = v10 + 2;
    float v16 = 3.4028e38;
    do
    {
      float32x2_t v17 = vsub_f32(vmaxnm_f32(*v15, a5), vminnm_f32(v15[-1], a4));
      v17.f32[0] = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v17), v17).f32[0];
      BOOL v18 = v17.f32[0] < v16;
      float v16 = fminf(v17.f32[0], v16);
      if (v18) {
        float32x2_t v13 = v14;
      }
      ++*(void *)&v14;
      v15 += 7;
    }
    while (v12 != *(void *)&v14);
    _ZN12GKCRTreeNodeI8NSObjectDv2_fE12InsertObjectEPS0_S1_S1_21GKCRTreeSplitStrategy(&v10[7 * *(void *)&v13], v9, a3, *(double *)&a4, *(double *)&a5);
    int8x8_t v19 = vbsl_s8((int8x8_t)vcgt_f32(a1[2], v20), (int8x8_t)a1[2], (int8x8_t)v20);
    a1[1] = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, a1[1]), (int8x8_t)a1[1], (int8x8_t)v21);
    a1[2] = (float32x2_t)v19;
  }
}

void sub_235EB21A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EB21B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(int *a1, void *a2, float32x2_t *a3, float32x2_t *a4)
{
  id v7 = a2;
  int v8 = *a1;
  float32x2_t v9 = *a3;
  float32x2_t v10 = *a4;
  id v11 = v7;
  LODWORD(v17) = v8;
  *((float32x2_t *)&v17 + 1) = v9;
  float32x2_t v18 = v10;
  memset(v19, 0, sizeof(v19));
  id v20 = v11;
  unint64_t v12 = *((void *)a1 + 4);
  if (v12 >= *((void *)a1 + 5))
  {
    uint64_t v15 = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE21__push_back_slow_pathIS4_EEPS4_OT_((uint64_t *)a1 + 3, (uint64_t)&v17);
    id v14 = v20;
  }
  else
  {
    long long v13 = v17;
    *(float32x2_t *)(v12 + 16) = v18;
    *(_OWORD *)unint64_t v12 = v13;
    *(void *)(v12 + 32) = 0;
    *(void *)(v12 + 40) = 0;
    *(void *)(v12 + 24) = 0;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m((void *)(v12 + 24), 0, 0, 0);
    id v14 = v20;
    *(void *)(v12 + 48) = v14;
    uint64_t v15 = v12 + 56;
    *((void *)a1 + 4) = v12 + 56;
  }
  *((void *)a1 + 4) = v15;

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v19);
  if (*((void *)a1 + 4) - *((void *)a1 + 3) == 56)
  {
    *((float32x2_t *)a1 + 1) = *a3;
    *((float32x2_t *)a1 + 2) = *a4;
  }
  else
  {
    int8x8_t v16 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a1 + 4), *a4), *(int8x8_t *)(a1 + 4), (int8x8_t)*a4);
    *((int8x8_t *)a1 + 1) = vbsl_s8((int8x8_t)vcgt_f32(*a3, *(float32x2_t *)(a1 + 2)), *(int8x8_t *)(a1 + 2), (int8x8_t)*a3);
    *((int8x8_t *)a1 + 2) = v16;
  }
}

void sub_235EB2308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v17);
  _Unwind_Resume(a1);
}

void _ZN12GKCRTreeNodeI8NSObjectDv2_fE10SplitHalveEPS0_RKS1_S5_(float32x2_t *a1, void *a2)
{
  id v3 = a2;
  uint64_t v5 = (int **)&a1[3];
  float32x2_t v4 = a1[3];
  float32x2_t v6 = *(float32x2_t *)(*(void *)&v4 + 16);
  long long v52 = *(_OWORD *)*(void *)&v4;
  float32x2_t v53 = v6;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v54, *(long long **)(*(void *)&v4 + 24), *(long long **)(*(void *)&v4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(*(void *)&v4 + 32) - *(void *)(*(void *)&v4 + 24)) >> 3));
  id v57 = *(id *)(*(void *)&v4 + 48);
  float32x2_t v7 = a1[3];
  long long v46 = *(_OWORD *)(*(void *)&v7 + 56);
  int v8 = *(long long **)(*(void *)&v7 + 80);
  float32x2_t v47 = *(float32x2_t *)(*(void *)&v7 + 72);
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v48, v8, *(long long **)(*(void *)&v7 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(*(void *)&v7 + 88) - (void)v8) >> 3));
  id v51 = *(id *)(*(void *)&v7 + 104);
  *(_DWORD *)v43 = a1->i32[0];
  *(_OWORD *)&v43[8] = 0u;
  long long v44 = 0u;
  *(_OWORD *)obj = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v44, (*(_DWORD *)v43 + 1));
  float32x2_t v9 = a1[3];
  long long v10 = *(_OWORD *)v43;
  *(void *)(*(void *)&v9 + 16) = 0;
  *(_OWORD *)*(void *)&float32x2_t v9 = v10;
  if (*(unsigned char **)&v9 != v43) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(*(void *)&v9 + 24), v44, *((uint64_t *)&v44 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v44 + 1) - v44) >> 3));
  }
  objc_storeStrong((id *)(*(void *)&v9 + 48), obj[1]);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v44);
  *(_DWORD *)v43 = a1->i32[0];
  *(_OWORD *)&v43[8] = 0u;
  long long v44 = 0u;
  *(_OWORD *)obj = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v44, (*(_DWORD *)v43 + 1));
  id v11 = *v5;
  *(_OWORD *)(v11 + 14) = *(_OWORD *)v43;
  *((void *)v11 + 9) = *(void *)&v43[16];
  if (v11 + 14 != (int *)v43) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v11 + 10, v44, *((uint64_t *)&v44 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v44 + 1) - v44) >> 3));
  }
  objc_storeStrong((id *)v11 + 13, obj[1]);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v44);
  _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v5, v57, (float32x2_t *)&v52 + 1, &v53);
  unint64_t v12 = *v5;
  if ((uint64_t *)(*((void *)*v5 + 4) - 32) != &v54)
  {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(*((void *)*v5 + 4) - 32), v54, v55, 0x6DB6DB6DB6DB6DB7 * ((v55 - v54) >> 3));
    unint64_t v12 = *v5;
  }
  _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v12, v51, (float32x2_t *)&v46 + 1, &v47);
  long long v13 = *v5;
  id v14 = (void **)(*((void *)*v5 + 4) - 32);
  if (v14 != (void **)&v48)
  {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v14, v48, v49, 0x6DB6DB6DB6DB6DB7 * ((v49 - v48) >> 3));
    long long v13 = *v5;
  }
  uint64_t v15 = (int *)a1[4];
  int64_t v16 = (char *)v15 - (char *)v13;
  unint64_t v17 = 0x6DB6DB6DB6DB6DB7 * (((char *)v15 - (char *)v13) >> 3);
  unint64_t v18 = v17 >> 1;
  if (v17 >= 6)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 3;
    if (v18 > 3) {
      uint64_t v20 = v17 >> 1;
    }
    uint64_t v21 = v20 - 2;
    do
    {
      _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v5, *(void **)&(*v5)[v19 + 40], (float32x2_t *)&(*v5)[v19 + 30], (float32x2_t *)&(*v5)[v19 + 32]);
      uint64_t v22 = &(*v5)[v19];
      v23 = (void **)(*((void *)*v5 + 4) - 32);
      if (v22 + 34 != (int *)v23) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v23, *((void *)v22 + 17), *((void *)v22 + 18), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v22 + 18) - *((void *)v22 + 17)) >> 3));
      }
      v19 += 14;
      --v21;
    }
    while (v21);
    long long v13 = (int *)a1[3];
    uint64_t v15 = (int *)a1[4];
    int64_t v16 = (char *)v15 - (char *)v13;
    unint64_t v17 = 0x6DB6DB6DB6DB6DB7 * (((char *)v15 - (char *)v13) >> 3);
  }
  if (v18 < v17)
  {
    uint64_t v24 = 14 * v18;
    do
    {
      _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v13 + 14, *(void **)&v13[v24 + 12], (float32x2_t *)&v13[v24 + 2], (float32x2_t *)&v13[v24 + 4]);
      long long v13 = *v5;
      v25 = &(*v5)[v24];
      uint64_t v26 = *((void *)*v5 + 11);
      if (v25 != (int *)(v26 - 56))
      {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v26 - 32), *((void *)v25 + 3), *((void *)v25 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v25 + 4) - *((void *)v25 + 3)) >> 3));
        long long v13 = *v5;
      }
      ++v18;
      uint64_t v15 = (int *)a1[4];
      int64_t v16 = (char *)v15 - (char *)v13;
      unint64_t v17 = 0x6DB6DB6DB6DB6DB7 * (((char *)v15 - (char *)v13) >> 3);
      v24 += 14;
    }
    while (v18 < v17);
  }
  if (v17 > 1)
  {
    if (v16 == 112)
    {
      i = v15;
    }
    else
    {
      for (i = v13 + 28; v15 != i; v15 -= 14)
      {

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)v15 - 4);
      }
      a1[4] = (float32x2_t)i;
    }
  }
  else
  {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE8__appendEm((uint64_t *)&a1[3], 2 - v17);
    i = (int *)a1[4];
  }
  v28 = (float32x2_t *)a1[3];
  float32x2_t v29 = v28[1];
  a1[1] = v29;
  float32x2_t v30 = v28[2];
  a1[2] = v30;
  unint64_t v31 = 0x6DB6DB6DB6DB6DB7 * (((char *)i - (char *)v28) >> 3);
  if (v31 >= 2)
  {
    float32x2_t v32 = (float32x2_t)vzip2_s32((int32x2_t)v30, (int32x2_t)v29);
    v33 = v28 + 9;
    unint64_t v34 = v31 - 1;
    do
    {
      float32x2_t v35 = v33[-1];
      float v36 = v29.f32[1];
      float32x2_t v37 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 1), (float32x2_t)vdup_lane_s32((int32x2_t)v32, 1)), 0), (int8x8_t)v32, (int8x8_t)v29);
      v29.i32[0] = vminnm_f32(v35, v29).u32[0];
      float32x2_t v38 = *v33;
      v33 += 7;
      int32x2_t v39 = (int32x2_t)vmaxnm_f32(v38, v30);
      int8x8_t v40 = (int8x8_t)vzip1_s32(v39, (int32x2_t)v32);
      v39.i32[1] = v30.i32[1];
      v29.i32[1] = v37.i32[1];
      v37.f32[0] = fminf(v32.f32[1], v36);
      int32x2_t v41 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v37, (float32x2_t)vdup_lane_s32((int32x2_t)v35, 1)), 0), (int8x8_t)v35, (int8x8_t)v29);
      v29.i32[1] = v41.i32[1];
      v37.i32[0] = v30.i32[1];
      float32x2_t v30 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v32, (float32x2_t)vdup_lane_s32((int32x2_t)v30, 1)), 0), v40, (int8x8_t)v39);
      v32.f32[0] = fmaxf(v32.f32[0], v37.f32[0]);
      int32x2_t v42 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v38, 1), v32), 0), (int8x8_t)v38, (int8x8_t)v30);
      v30.i32[1] = v42.i32[1];
      a1[1] = v29;
      a1[2] = v30;
      float32x2_t v32 = (float32x2_t)vzip2_s32(v42, v41);
      --v34;
    }
    while (v34);
  }

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v48);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v54);
}

void sub_235EB288C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v32);

  _Unwind_Resume(a1);
}

void _ZN12GKCRTreeNodeI8NSObjectDv2_fE11SplitLinearEPS0_RKS1_S5_(float32x2_t *a1, void *a2)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  id v3 = a2;
  uint64_t v60 = (uint64_t)&v60;
  uint64_t v4 = (a1->i32[0] + 1);
  MEMORY[0x270FA5388](v3);
  float32x2_t v6 = (char *)&v60 - v5;
  bzero((char *)&v60 - v5, v7);
  float32x2_t v8 = a1[3];
  float32x2_t v9 = (int **)&a1[3];
  unint64_t v10 = (*(void *)&a1[4] - *(void *)&v8) / 56;
  if (*(void *)&a1[4] == *(void *)&v8)
  {
    int32x2_t v14 = 0;
  }
  else
  {
    float32x2_t v11 = a1[1];
    float32x2_t v12 = a1[2];
    if (v10 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = (*(void *)&a1[4] - *(void *)&v8) / 56;
    }
    int32x2_t v14 = 0;
    uint64_t v15 = (float32x2_t *)(*(void *)&v8 + 16);
    int64_t v16 = v6;
    do
    {
      uint64_t v17 = *(void *)&vcagt_f32(vsub_f32(v12, *v15), vsub_f32(v11, v15[-1])) | 0x100000001;
      _DWORD *v16 = v17;
      v16[v4] = HIDWORD(v17);
      int32x2_t v14 = vadd_s32(v14, (int32x2_t)v17);
      v15 += 7;
      ++v16;
      --v13;
    }
    while (v13);
  }
  if (v14.i32[0] >= 0) {
    unint64_t v18 = v14.u32[0];
  }
  else {
    unint64_t v18 = -v14.i32[0];
  }
  if (v10 + 1 < v18) {
    unint64_t v19 = v10 + 1;
  }
  else {
    unint64_t v19 = v18;
  }
  if (v14.i32[1] >= 0) {
    unint64_t v20 = v14.u32[1];
  }
  else {
    unint64_t v20 = -v14.i32[1];
  }
  float32x2_t v21 = *(float32x2_t *)(*(void *)&v8 + 16);
  long long v72 = *(_OWORD *)*(void *)&v8;
  float32x2_t v73 = v21;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  uint64_t v22 = *(long long **)(*(void *)&v8 + 24);
  v23 = *(long long **)(*(void *)&v8 + 32);
  v62 = (void **)&v74;
  id v61 = v3;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v74, v22, v23, 0x6DB6DB6DB6DB6DB7 * (((char *)v23 - (char *)v22) >> 3));
  id v77 = *(id *)(*(void *)&v8 + 48);
  uint64_t v24 = *v9;
  long long v66 = *(_OWORD *)(*v9 + 14);
  v25 = (long long *)*((void *)v24 + 10);
  float32x2_t v67 = *(float32x2_t *)(v24 + 18);
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v68, v25, *((long long **)v24 + 11), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v24 + 11) - (void)v25) >> 3));
  id v71 = *((id *)v24 + 13);
  *(_DWORD *)v63 = a1->i32[0];
  *(_OWORD *)&v63[8] = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v64, (*(_DWORD *)v63 + 1));
  uint64_t v26 = *v9;
  long long v27 = *(_OWORD *)v63;
  *((void *)v26 + 2) = *(void *)&v63[16];
  *(_OWORD *)uint64_t v26 = v27;
  if (v26 != (int *)v63) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v26 + 3, v64, *((uint64_t *)&v64 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v64 + 1) - v64) >> 3));
  }
  objc_storeStrong((id *)v26 + 6, *((id *)&v65 + 1));

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v64);
  *(_DWORD *)v63 = a1->i32[0];
  *(_OWORD *)&v63[8] = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v64, (*(_DWORD *)v63 + 1));
  v28 = *v9;
  *(_OWORD *)(v28 + 14) = *(_OWORD *)v63;
  *((void *)v28 + 9) = *(void *)&v63[16];
  if (v28 + 14 != (int *)v63) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v28 + 10, v64, *((uint64_t *)&v64 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v64 + 1) - v64) >> 3));
  }
  objc_storeStrong((id *)v28 + 13, *((id *)&v65 + 1));

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v64);
  if (v19 <= v20) {
    uint64_t v29 = 0;
  }
  else {
    uint64_t v29 = v4;
  }
  float32x2_t v30 = &v6[4 * v29];
  unint64_t v31 = *v9;
  if (*(_DWORD *)v30 == -1)
  {
    _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v31, v77, (float32x2_t *)&v72 + 1, &v73);
    float32x2_t v32 = (void **)(*((void *)*v9 + 4) - 32);
    if (v32 == v62) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v31 + 14, v77, (float32x2_t *)&v72 + 1, &v73);
  float32x2_t v32 = (void **)(*((void *)*v9 + 11) - 32);
  if (v32 != v62) {
LABEL_29:
  }
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v32, v74, v75, 0x6DB6DB6DB6DB6DB7 * ((v75 - v74) >> 3));
LABEL_30:
  v33 = *v9;
  if (*((_DWORD *)v30 + 1) == -1)
  {
    _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v33, v71, (float32x2_t *)&v66 + 1, &v67);
    unint64_t v34 = (void **)(*((void *)*v9 + 4) - 32);
    if (v34 == (void **)&v68) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v33 + 14, v71, (float32x2_t *)&v66 + 1, &v67);
  unint64_t v34 = (void **)(*((void *)*v9 + 11) - 32);
  if (v34 != (void **)&v68) {
LABEL_34:
  }
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v34, v68, v69, 0x6DB6DB6DB6DB6DB7 * ((v69 - v68) >> 3));
LABEL_35:
  float32x2_t v35 = (int *)a1[3];
  float v36 = (int *)a1[4];
  int64_t v37 = (char *)v36 - (char *)v35;
  unint64_t v38 = 0x6DB6DB6DB6DB6DB7 * (((char *)v36 - (char *)v35) >> 3);
  if (v38 >= 3)
  {
    uint64_t v39 = 0;
    unint64_t v40 = 2;
    do
    {
      if (*(_DWORD *)&v30[4 * v40] == -1)
      {
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v35, *(void **)&v35[v39 + 40], (float32x2_t *)&v35[v39 + 30], (float32x2_t *)&v35[v39 + 32]);
        int32x2_t v41 = *v9;
        v43 = (void **)(*((void *)*v9 + 4) - 32);
        if (&(*v9)[v39 + 34] == (int *)v43) {
          goto LABEL_38;
        }
        int32x2_t v42 = (uint64_t *)&v41[14 * v40 + 6];
      }
      else
      {
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v35 + 14, *(void **)&v35[v39 + 40], (float32x2_t *)&v35[v39 + 30], (float32x2_t *)&v35[v39 + 32]);
        int32x2_t v41 = *v9;
        int32x2_t v42 = (uint64_t *)&(*v9)[v39 + 34];
        v43 = (void **)(*((void *)*v9 + 11) - 32);
        if (v42 == (uint64_t *)v43) {
          goto LABEL_38;
        }
      }
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v43, *v42, *(void *)&v41[v39 + 36], 0x6DB6DB6DB6DB6DB7 * ((*(void *)&v41[v39 + 36] - *v42) >> 3));
LABEL_38:
      ++v40;
      float32x2_t v35 = (int *)a1[3];
      float v36 = (int *)a1[4];
      int64_t v37 = (char *)v36 - (char *)v35;
      unint64_t v38 = 0x6DB6DB6DB6DB6DB7 * (((char *)v36 - (char *)v35) >> 3);
      v39 += 14;
    }
    while (v38 > v40);
  }
  if (v38 > 1)
  {
    if (v37 != 112)
    {
      for (i = v35 + 28; v36 != i; v36 -= 14)
      {

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)v36 - 4);
      }
      a1[4] = (float32x2_t)i;
      float v36 = i;
    }
  }
  else
  {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE8__appendEm((uint64_t *)&a1[3], 2 - v38);
    float v36 = (int *)a1[4];
  }
  v45 = (float32x2_t *)a1[3];
  float32x2_t v46 = v45[1];
  a1[1] = v46;
  float32x2_t v47 = v45[2];
  a1[2] = v47;
  unint64_t v48 = 0x6DB6DB6DB6DB6DB7 * (((char *)v36 - (char *)v45) >> 3);
  if (v48 >= 2)
  {
    float32x2_t v49 = (float32x2_t)vzip2_s32((int32x2_t)v47, (int32x2_t)v46);
    uint64_t v50 = v45 + 9;
    unint64_t v51 = v48 - 1;
    do
    {
      float32x2_t v52 = v50[-1];
      float v53 = v46.f32[1];
      float32x2_t v54 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v46, 1), (float32x2_t)vdup_lane_s32((int32x2_t)v49, 1)), 0), (int8x8_t)v49, (int8x8_t)v46);
      v46.i32[0] = vminnm_f32(v52, v46).u32[0];
      float32x2_t v55 = *v50;
      v50 += 7;
      int32x2_t v56 = (int32x2_t)vmaxnm_f32(v55, v47);
      int8x8_t v57 = (int8x8_t)vzip1_s32(v56, (int32x2_t)v49);
      v56.i32[1] = v47.i32[1];
      v46.i32[1] = v54.i32[1];
      v54.f32[0] = fminf(v49.f32[1], v53);
      int32x2_t v58 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v54, (float32x2_t)vdup_lane_s32((int32x2_t)v52, 1)), 0), (int8x8_t)v52, (int8x8_t)v46);
      v46.i32[1] = v58.i32[1];
      v54.i32[0] = v47.i32[1];
      float32x2_t v47 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v49, (float32x2_t)vdup_lane_s32((int32x2_t)v47, 1)), 0), v57, (int8x8_t)v56);
      v49.f32[0] = fmaxf(v49.f32[0], v54.f32[0]);
      int32x2_t v59 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v55, 1), v49), 0), (int8x8_t)v55, (int8x8_t)v47);
      v47.i32[1] = v59.i32[1];
      a1[1] = v46;
      a1[2] = v47;
      float32x2_t v49 = (float32x2_t)vzip2_s32(v59, v58);
      --v51;
    }
    while (v51);
  }

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v68);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v62);
}

void sub_235EB2FEC(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v2);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(*(void ***)(v3 - 288));
  _Unwind_Resume(a1);
}

void _ZN12GKCRTreeNodeI8NSObjectDv2_fE14SplitQuadraticEPS0_RKS1_S5_(float32x2_t *a1, void *a2)
{
  id v3 = a2;
  float32x2_t v4 = a1[3];
  uint64_t v5 = (int **)&a1[3];
  uint64_t v6 = *(void *)&a1[4] - *(void *)&v4;
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    unint64_t v10 = v6 / 56;
    if (v10 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = v10;
    }
    float32x2_t v12 = (float32x2_t *)(*(void *)&v4 + 72);
    float v13 = 0.0;
    uint64_t v14 = 1;
    do
    {
      uint64_t v16 = v7 + 1;
      if (v10 <= v7 + 1)
      {
        float v15 = v13;
      }
      else
      {
        uint64_t v17 = (float32x2_t *)(*(void *)&v4 + 56 * v7);
        float32x2_t v18 = v17[1];
        float32x2_t v19 = v17[2];
        unint64_t v20 = v12;
        uint64_t v21 = v14;
        do
        {
          float32x2_t v22 = vsub_f32(vmaxnm_f32(*v20, v19), vminnm_f32(v20[-1], v18));
          float v23 = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v22), v22).f32[0];
          float v15 = fmaxf(v23, v13);
          if (v23 > v13)
          {
            uint64_t v9 = v7;
            uint64_t v8 = v21;
          }
          ++v21;
          v20 += 7;
          float v13 = v15;
        }
        while (v10 != v21);
      }
      ++v14;
      v12 += 7;
      ++v7;
      float v13 = v15;
    }
    while (v16 != v11);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
  }
  float32x2_t v24 = *(float32x2_t *)(*(void *)&v4 + 16);
  long long v86 = *(_OWORD *)*(void *)&v4;
  float32x2_t v87 = v24;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v88, *(long long **)(*(void *)&v4 + 24), *(long long **)(*(void *)&v4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(*(void *)&v4 + 32) - *(void *)(*(void *)&v4 + 24)) >> 3));
  id v91 = *(id *)(*(void *)&v4 + 48);
  v25 = *v5;
  long long v80 = *(_OWORD *)(*v5 + 14);
  uint64_t v26 = (long long *)*((void *)v25 + 10);
  float32x2_t v81 = *(float32x2_t *)(v25 + 18);
  uint64_t v82 = 0;
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v82, v26, *((long long **)v25 + 11), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v25 + 11) - (void)v26) >> 3));
  id v85 = *((id *)v25 + 13);
  *(_DWORD *)id v77 = a1->i32[0];
  *(_OWORD *)&v77[8] = 0u;
  long long v78 = 0u;
  *(_OWORD *)obj = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v78, (*(_DWORD *)v77 + 1));
  long long v27 = *v5;
  long long v28 = *(_OWORD *)v77;
  *((void *)v27 + 2) = 0;
  *(_OWORD *)long long v27 = v28;
  if (v27 != (int *)v77) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v27 + 3, v78, *((uint64_t *)&v78 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v78 + 1) - v78) >> 3));
  }
  objc_storeStrong((id *)v27 + 6, obj[1]);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v78);
  *(_DWORD *)id v77 = a1->i32[0];
  *(_OWORD *)&v77[8] = 0u;
  long long v78 = 0u;
  *(_OWORD *)obj = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v78, (*(_DWORD *)v77 + 1));
  uint64_t v29 = *v5;
  *(_OWORD *)(v29 + 14) = *(_OWORD *)v77;
  *((void *)v29 + 9) = *(void *)&v77[16];
  if (v29 + 14 != (int *)v77) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v29 + 10, v78, *((uint64_t *)&v78 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v78 + 1) - v78) >> 3));
  }
  objc_storeStrong((id *)v29 + 13, obj[1]);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v78);
  float32x2_t v30 = *v5;
  uint64_t v31 = 14 * v9;
  uint64_t v32 = 14 * v8;
  int32x2_t v33 = vrev64_s32((int32x2_t)vsub_f32(vmaxnm_f32(*(float32x2_t *)&(*v5)[14 * v9 + 4], v87), vminnm_f32(*(float32x2_t *)&(*v5)[14 * v9 + 2], *(float32x2_t *)((char *)&v86 + 8))));
  float32x2_t v34 = (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(vmaxnm_f32(*(float32x2_t *)&(*v5)[v32 + 4], v87), vminnm_f32(*(float32x2_t *)&(*v5)[v32 + 2], *(float32x2_t *)((char *)&v86 + 8))));
  float32x2_t v35 = (float32x2_t)__PAIR64__(v34.u32[0], v33.u32[0]);
  v34.i32[0] = v33.i32[1];
  float32x2_t v36 = vmul_f32(v35, v34);
  if ((vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v36, 1), v36).u8[0] & 1) == 0)
  {
    _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v30 + 14, v91, (float32x2_t *)&v86 + 1, &v87);
    int64_t v37 = (void **)(*((void *)*v5 + 11) - 32);
    if (v37 == (void **)&v88) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v30, v91, (float32x2_t *)&v86 + 1, &v87);
  int64_t v37 = (void **)(*((void *)*v5 + 4) - 32);
  if (v37 != (void **)&v88) {
LABEL_23:
  }
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v37, v88, v89, 0x6DB6DB6DB6DB6DB7 * ((v89 - v88) >> 3));
LABEL_24:
  unint64_t v38 = *v5;
  int32x2_t v39 = vrev64_s32((int32x2_t)vsub_f32(vmaxnm_f32(*(float32x2_t *)&(*v5)[v31 + 4], v81), vminnm_f32(*(float32x2_t *)&(*v5)[v31 + 2], *(float32x2_t *)((char *)&v80 + 8))));
  float32x2_t v40 = (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(vmaxnm_f32(*(float32x2_t *)&(*v5)[v32 + 4], v81), vminnm_f32(*(float32x2_t *)&(*v5)[v32 + 2], *(float32x2_t *)((char *)&v80 + 8))));
  float32x2_t v41 = (float32x2_t)__PAIR64__(v40.u32[0], v39.u32[0]);
  v40.i32[0] = v39.i32[1];
  float32x2_t v42 = vmul_f32(v41, v40);
  if (vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v42, 1), v42).u8[0])
  {
    _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v38, v85, (float32x2_t *)&v80 + 1, &v81);
    v43 = (void **)(*((void *)*v5 + 4) - 32);
    if (v43 == (void **)&v82) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v38 + 14, v85, (float32x2_t *)&v80 + 1, &v81);
  v43 = (void **)(*((void *)*v5 + 11) - 32);
  if (v43 != (void **)&v82) {
LABEL_28:
  }
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v43, v82, v83, 0x6DB6DB6DB6DB6DB7 * ((v83 - v82) >> 3));
LABEL_29:
  long long v44 = (int *)a1[3];
  v45 = (int *)a1[4];
  int64_t v46 = (char *)v45 - (char *)v44;
  unint64_t v47 = 0x6DB6DB6DB6DB6DB7 * (((char *)v45 - (char *)v44) >> 3);
  if (v47 < 3) {
    goto LABEL_39;
  }
  id v76 = v3;
  uint64_t v48 = 0;
  unint64_t v49 = 2;
  do
  {
    uint64_t v50 = &v44[v48];
    unint64_t v51 = (float32x2_t *)&v44[v48 + 32];
    float32x2_t v52 = (float32x2_t *)&v44[v48 + 30];
    int32x2_t v53 = vrev64_s32((int32x2_t)vsub_f32(vmaxnm_f32(*(float32x2_t *)&v44[v31 + 4], *v51), vminnm_f32(*(float32x2_t *)&v44[v31 + 2], *v52)));
    float32x2_t v54 = (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(vmaxnm_f32(*(float32x2_t *)&v44[v32 + 4], *v51), vminnm_f32(*(float32x2_t *)&v44[v32 + 2], *v52)));
    float32x2_t v55 = (float32x2_t)__PAIR64__(v54.u32[0], v53.u32[0]);
    v54.i32[0] = v53.i32[1];
    float32x2_t v56 = vmul_f32(v55, v54);
    if (vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v56, 1), v56).u8[0])
    {
      _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v44, *((void **)v50 + 20), v52, v51);
      int8x8_t v57 = *v5;
      int32x2_t v58 = (void **)(*((void *)*v5 + 4) - 32);
      if (&(*v5)[v48 + 34] != (int *)v58)
      {
        int32x2_t v59 = (uint64_t *)&v57[14 * v49 + 6];
LABEL_31:
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v58, *v59, *(void *)&v57[v48 + 36], 0x6DB6DB6DB6DB6DB7 * ((*(void *)&v57[v48 + 36] - *v59) >> 3));
      }
    }
    else
    {
      _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(v44 + 14, *((void **)v50 + 20), v52, v51);
      int8x8_t v57 = *v5;
      int32x2_t v59 = (uint64_t *)&(*v5)[v48 + 34];
      int32x2_t v58 = (void **)(*((void *)*v5 + 11) - 32);
      if (v59 != (uint64_t *)v58) {
        goto LABEL_31;
      }
    }
    ++v49;
    long long v44 = (int *)a1[3];
    v45 = (int *)a1[4];
    int64_t v46 = (char *)v45 - (char *)v44;
    unint64_t v47 = 0x6DB6DB6DB6DB6DB7 * (((char *)v45 - (char *)v44) >> 3);
    v48 += 14;
  }
  while (v47 > v49);
  id v3 = v76;
LABEL_39:
  if (v47 > 1)
  {
    if (v46 == 112)
    {
      i = v45;
    }
    else
    {
      for (i = v44 + 28; v45 != i; v45 -= 14)
      {

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)v45 - 4);
      }
      a1[4] = (float32x2_t)i;
    }
  }
  else
  {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE8__appendEm((uint64_t *)&a1[3], 2 - v47);
    i = (int *)a1[4];
  }
  id v61 = (float32x2_t *)a1[3];
  float32x2_t v62 = v61[1];
  a1[1] = v62;
  float32x2_t v63 = v61[2];
  a1[2] = v63;
  unint64_t v64 = 0x6DB6DB6DB6DB6DB7 * (((char *)i - (char *)v61) >> 3);
  if (v64 >= 2)
  {
    float32x2_t v65 = (float32x2_t)vzip2_s32((int32x2_t)v63, (int32x2_t)v62);
    long long v66 = v61 + 9;
    unint64_t v67 = v64 - 1;
    do
    {
      float32x2_t v68 = v66[-1];
      float v69 = v62.f32[1];
      float32x2_t v70 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v62, 1), (float32x2_t)vdup_lane_s32((int32x2_t)v65, 1)), 0), (int8x8_t)v65, (int8x8_t)v62);
      v62.i32[0] = vminnm_f32(v68, v62).u32[0];
      float32x2_t v71 = *v66;
      v66 += 7;
      int32x2_t v72 = (int32x2_t)vmaxnm_f32(v71, v63);
      int8x8_t v73 = (int8x8_t)vzip1_s32(v72, (int32x2_t)v65);
      v72.i32[1] = v63.i32[1];
      v62.i32[1] = v70.i32[1];
      v70.f32[0] = fminf(v65.f32[1], v69);
      int32x2_t v74 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v70, (float32x2_t)vdup_lane_s32((int32x2_t)v68, 1)), 0), (int8x8_t)v68, (int8x8_t)v62);
      v62.i32[1] = v74.i32[1];
      v70.i32[0] = v63.i32[1];
      float32x2_t v63 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v65, (float32x2_t)vdup_lane_s32((int32x2_t)v63, 1)), 0), v73, (int8x8_t)v72);
      v65.f32[0] = fmaxf(v65.f32[0], v70.f32[0]);
      int32x2_t v75 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v71, 1), v65), 0), (int8x8_t)v71, (int8x8_t)v63);
      v63.i32[1] = v75.i32[1];
      a1[1] = v62;
      a1[2] = v63;
      float32x2_t v65 = (float32x2_t)vzip2_s32(v75, v74);
      --v67;
    }
    while (v67);
  }

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v82);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v88);
}

void sub_235EB3774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v32);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v31);
  _Unwind_Resume(a1);
}

void _ZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS0_RKS1_S5_(void *a1, void *a2)
{
  id v214 = a2;
  i = a1 + 3;
  int v3 = *(_DWORD *)a1;
  if (*(int *)a1 >= 0) {
    int v5 = *(_DWORD *)a1;
  }
  else {
    int v5 = v3 + 1;
  }
  int v6 = v5 >> 1;
  if (v3 < 6) {
    int v6 = 2;
  }
  uint64_t v7 = (v6 - 1);
  uint64_t v220 = (v3 - 2 * v6 + 2);
  v221 = a1;
  v222 = (int **)(a1 + 3);
  unsigned int v225 = v6 - 1;
  if ((int)v220 >= 1)
  {
    int v218 = 0;
    char v8 = 1;
    int v216 = -1;
    float v9 = 3.4028e38;
    uint64_t v217 = 56 * v7;
    while (1)
    {
      char v215 = v8;
      char v12 = 1;
      float v13 = 0.0;
      do
      {
        char v14 = v12;
        uint64_t v15 = a1[3];
        uint64_t v16 = (void **)a1[4];
        unint64_t v17 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (((uint64_t)v16 - v15) >> 3));
        if (v16 == (void **)v15) {
          uint64_t v18 = 0;
        }
        else {
          uint64_t v18 = v17;
        }
        char v219 = v14;
        LODWORD(v234) = v218;
        if (v14) {
          _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v15, v16, &v234, v18, 1);
        }
        else {
          _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v15, v16, &v234, v18, 1);
        }
        uint64_t v19 = 0;
        float v20 = 3.4028e38;
        uint64_t v21 = v217;
        do
        {
          uint64_t v26 = (int *)*i;
          uint64_t v27 = *i + 56 * v7;
          v235 = 0;
          uint64_t v28 = v27 + 56 * v19;
          long long v234 = 0uLL;
          int64_t v29 = v28 - (void)v26;
          if ((int *)v28 == v26)
          {
            float32x2_t v36 = 0;
          }
          else
          {
            unint64_t v30 = 0x6DB6DB6DB6DB6DB7 * (v29 >> 3);
            if (v30 > 0x492492492492492) {
              _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
            }
            uint64_t v31 = (char *)operator new(v29);
            uint64_t v32 = 0;
            *(void *)&long long v234 = v31;
            *((void *)&v234 + 1) = v31;
            v235 = &v31[56 * v30];
            do
            {
              int32x2_t v33 = &v31[v32 * 4];
              float32x2_t v34 = &v26[v32];
              long long v35 = *(_OWORD *)&v26[v32];
              *((void *)v33 + 2) = *(void *)&v26[v32 + 4];
              *(_OWORD *)int32x2_t v33 = v35;
              *(void *)&v31[v32 * 4 + 24] = 0;
              *((void *)v33 + 4) = 0;
              *((void *)v33 + 5) = 0;
              _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v31[v32 * 4 + 24], *(long long **)&v26[v32 + 6], *(long long **)&v26[v32 + 8], 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v26[v32 + 8] - *(void *)&v26[v32 + 6]) >> 3));
              *((void *)v33 + 6) = *(id *)&v26[v32 + 12];
              v32 += 14;
            }
            while (v34 + 14 != (int *)v28);
            float32x2_t v36 = &v31[v32 * 4];
            i = (uint64_t *)v222;
            uint64_t v26 = *v222;
            *((void *)&v234 + 1) = v36;
          }
          int64_t v37 = (char *)v221[4];
          v230 = 0;
          uint64_t v38 = (uint64_t)&v26[14 * v225 + 14 * v19];
          long long v229 = 0uLL;
          int64_t v39 = (int64_t)&v37[-v38];
          if (v37 == (char *)v38)
          {
            uint64_t v48 = 0;
            unint64_t v47 = 0;
          }
          else
          {
            unint64_t v40 = 0x6DB6DB6DB6DB6DB7 * (v39 >> 3);
            if (v40 > 0x492492492492492) {
              _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
            }
            float32x2_t v41 = (char *)operator new(v39);
            uint64_t v42 = 0;
            *(void *)&long long v229 = v41;
            *((void *)&v229 + 1) = v41;
            v230 = &v41[56 * v40];
            v43 = (char *)v26 + v21;
            do
            {
              long long v44 = &v41[v42];
              v45 = &v43[v42];
              long long v46 = *(_OWORD *)&v43[v42];
              *((void *)v44 + 2) = *(void *)&v43[v42 + 16];
              *(_OWORD *)long long v44 = v46;
              *(void *)&v41[v42 + 24] = 0;
              *((void *)v44 + 4) = 0;
              *((void *)v44 + 5) = 0;
              _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v41[v42 + 24], *(long long **)&v43[v42 + 24], *(long long **)&v43[v42 + 32], 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v43[v42 + 32] - *(void *)&v43[v42 + 24]) >> 3));
              *((void *)v44 + 6) = *(id *)&v43[v42 + 48];
              v42 += 56;
            }
            while (v45 + 56 != v37);
            unint64_t v47 = &v41[v42];
            uint64_t v48 = v229;
            float32x2_t v36 = (char *)*((void *)&v234 + 1);
            *((void *)&v229 + 1) = v47;
            i = (uint64_t *)v222;
          }
          unint64_t v49 = (char *)v234;
          if ((unint64_t)((uint64_t)&v36[-v234] / 56) <= 1) {
            unint64_t v50 = 1;
          }
          else {
            unint64_t v50 = (uint64_t)&v36[-v234] / 56;
          }
          if ((unint64_t)((uint64_t)&v47[-v48] / 56) <= 1) {
            unint64_t v51 = 1;
          }
          else {
            unint64_t v51 = (uint64_t)&v47[-v48] / 56;
          }
          if (v36 == (char *)v234)
          {
            float v54 = 1.1755e-38;
            float v53 = 3.4028e38;
            if (v47 == (char *)v48) {
              goto LABEL_49;
            }
          }
          else
          {
            float32x2_t v52 = (uint64_t *)(v234 + 16);
            float v53 = 3.4028e38;
            float v54 = 1.1755e-38;
            unint64_t v55 = v50;
            do
            {
              float v53 = fminf(COERCE_FLOAT(*(v52 - 1)), v53);
              uint64_t v56 = *v52;
              v52 += 7;
              float v54 = fmaxf(*(float *)&v56, v54);
              --v55;
            }
            while (v55);
            if (v47 == (char *)v48)
            {
LABEL_49:
              float v224 = -3.4028e38;
              if (v36 == (char *)v234) {
                goto LABEL_50;
              }
              goto LABEL_46;
            }
          }
          int8x8_t v57 = (uint64_t *)(v48 + 16);
          float v58 = 3.4028e38;
          float v59 = 1.1755e-38;
          unint64_t v60 = v51;
          do
          {
            float v58 = fminf(COERCE_FLOAT(*(v57 - 1)), v58);
            uint64_t v61 = *v57;
            v57 += 7;
            float v59 = fmaxf(*(float *)&v61, v59);
            --v60;
          }
          while (v60);
          float v224 = v59 - v58;
          if (v36 == (char *)v234)
          {
LABEL_50:
            float v64 = 1.1755e-38;
            float v63 = 3.4028e38;
            goto LABEL_56;
          }
LABEL_46:
          if (v50 < 2)
          {
            unint64_t v62 = 0;
            float v63 = 3.4028e38;
            float v64 = 1.1755e-38;
LABEL_54:
            int8x8_t v73 = (float *)(v234 + 56 * v62 + 20);
            unint64_t v74 = v50 - v62;
            do
            {
              float v63 = fminf(*(v73 - 2), v63);
              float v75 = *v73;
              v73 += 14;
              float v64 = fmaxf(v75, v64);
              --v74;
            }
            while (v74);
            goto LABEL_56;
          }
          unint64_t v62 = v50 & 0xFFFFFFFFFFFFFFFELL;
          float32x2_t v65 = (float *)(v234 + 76);
          float v66 = 3.4028e38;
          float v67 = 1.1755e-38;
          unint64_t v68 = v50 & 0xFFFFFFFFFFFFFFFELL;
          float v69 = 1.1755e-38;
          float v70 = 3.4028e38;
          do
          {
            float v66 = fminf(*(v65 - 16), v66);
            float v70 = fminf(*(v65 - 2), v70);
            float v71 = *(v65 - 14);
            float v72 = *v65;
            v65 += 28;
            float v67 = fmaxf(v71, v67);
            float v69 = fmaxf(v72, v69);
            v68 -= 2;
          }
          while (v68);
          float v63 = fminf(v66, v70);
          float v64 = fmaxf(v67, v69);
          if (v50 != v62) {
            goto LABEL_54;
          }
LABEL_56:
          if (v47 == (char *)v48)
          {
            float v223 = -3.4028e38;
            if (v36 == (char *)v234) {
              goto LABEL_69;
            }
            goto LABEL_67;
          }
          if (v51 < 2)
          {
            unint64_t v76 = 0;
            float v77 = 3.4028e38;
            float v78 = 1.1755e-38;
LABEL_64:
            float32x2_t v87 = (float *)(v48 + 56 * v76 + 20);
            unint64_t v88 = v51 - v76;
            do
            {
              float v77 = fminf(*(v87 - 2), v77);
              float v89 = *v87;
              v87 += 14;
              float v78 = fmaxf(v89, v78);
              --v88;
            }
            while (v88);
            goto LABEL_66;
          }
          unint64_t v76 = v51 & 0xFFFFFFFFFFFFFFFELL;
          v79 = (float *)(v48 + 76);
          float v80 = 3.4028e38;
          float v81 = 1.1755e-38;
          unint64_t v82 = v51 & 0xFFFFFFFFFFFFFFFELL;
          float v83 = 1.1755e-38;
          float v84 = 3.4028e38;
          do
          {
            float v80 = fminf(*(v79 - 16), v80);
            float v84 = fminf(*(v79 - 2), v84);
            float v85 = *(v79 - 14);
            float v86 = *v79;
            v79 += 28;
            float v81 = fmaxf(v85, v81);
            float v83 = fmaxf(v86, v83);
            v82 -= 2;
          }
          while (v82);
          float v77 = fminf(v80, v84);
          float v78 = fmaxf(v81, v83);
          if (v51 != v76) {
            goto LABEL_64;
          }
LABEL_66:
          float v223 = v78 - v77;
          if (v36 == (char *)v234) {
            goto LABEL_69;
          }
          do
          {
LABEL_67:

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)v36 - 4);
            v36 -= 56;
          }
          while (v36 != v49);
          unint64_t v47 = (char *)*((void *)&v229 + 1);
          uint64_t v48 = v229;
LABEL_69:
          for (*((void *)&v234 + 1) = v49; v47 != (char *)v48; v47 -= 56)
          {

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)v47 - 4);
          }
          v23.f32[0] = v223;
          v22.f32[0] = v224;
          v22.f32[1] = v54 - v53;
          float32x2_t v24 = vabs_f32(v22);
          v23.f32[1] = v64 - v63;
          float64x2_t v25 = vcvtq_f64_f32(vabs_f32(v23));
          float v20 = fminf(v20, vaddv_f32(vcvt_f32_f64(vaddq_f64(vaddq_f64(v25, v25), vcvtq_f64_f32(vadd_f32(v24, v24))))));
          *((void *)&v229 + 1) = v48;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v229);
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v234);
          ++v19;
          v21 += 56;
          LODWORD(v7) = v225;
        }
        while (v19 != v220);
        char v12 = 0;
        float v13 = v20 + v13;
        a1 = v221;
      }
      while ((v219 & 1) != 0);
      char v8 = 0;
      BOOL v10 = v9 <= v13;
      float v9 = fminf(v9, v13);
      int v11 = v216;
      if (!v10) {
        int v11 = v218;
      }
      int v216 = v11;
      int v218 = 1;
      if ((v215 & 1) == 0) {
        goto LABEL_85;
      }
    }
  }
  uint64_t v90 = a1[3];
  id v91 = (void **)a1[4];
  unint64_t v92 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (((uint64_t)v91 - v90) >> 3));
  LODWORD(v234) = 0;
  if (v91 == (void **)v90) {
    uint64_t v93 = 0;
  }
  else {
    uint64_t v93 = v92;
  }
  _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v90, v91, &v234, v93, 1);
  uint64_t v94 = a1[3];
  v95 = (void **)a1[4];
  unint64_t v96 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (((uint64_t)v95 - v94) >> 3));
  LODWORD(v234) = 0;
  if (v95 == (void **)v94) {
    uint64_t v97 = 0;
  }
  else {
    uint64_t v97 = v96;
  }
  _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v94, v95, &v234, v97, 1);
  uint64_t v98 = a1[3];
  v99 = (void **)a1[4];
  unint64_t v100 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (((uint64_t)v99 - v98) >> 3));
  LODWORD(v234) = 1;
  if (v99 == (void **)v98) {
    uint64_t v101 = 0;
  }
  else {
    uint64_t v101 = v100;
  }
  _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v98, v99, &v234, v101, 1);
  uint64_t v102 = a1[3];
  v103 = (void **)a1[4];
  unint64_t v104 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (((uint64_t)v103 - v102) >> 3));
  LODWORD(v234) = 1;
  if (v103 == (void **)v102) {
    uint64_t v105 = 0;
  }
  else {
    uint64_t v105 = v104;
  }
  _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v102, v103, &v234, v105, 1);
  int v216 = -1;
LABEL_85:
  uint64_t v106 = a1[3];
  v107 = (void **)a1[4];
  unint64_t v108 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * (((uint64_t)v107 - v106) >> 3));
  LODWORD(v234) = v216;
  if (v107 == (void **)v106) {
    uint64_t v109 = 0;
  }
  else {
    uint64_t v109 = v108;
  }
  _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v106, v107, &v234, v109, 1);
  if ((int)v220 >= 1)
  {
    uint64_t v110 = 0;
    int v111 = 0;
    float v112 = 3.4028e38;
    while (1)
    {
      uint64_t v113 = *i;
      uint64_t v114 = *i + 56 * v7 + 56 * v110;
      uint64_t v115 = (v114 - *i) >> 3;
      v235 = 0;
      long long v234 = 0uLL;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPS4_EESB_EEvT_T0_m(&v234, v113, v114, 0x6DB6DB6DB6DB6DB7 * v115);
      uint64_t v116 = a1[4];
      uint64_t v117 = a1[3] + 56 * v7 + 56 * v110;
      v230 = 0;
      long long v229 = 0uLL;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPS4_EESB_EEvT_T0_m(&v229, v117, v116, 0x6DB6DB6DB6DB6DB7 * ((v116 - v117) >> 3));
      uint64_t v118 = *((void *)&v234 + 1);
      uint64_t v119 = v234;
      uint64_t v121 = *((void *)&v229 + 1);
      uint64_t v120 = v229;
      if ((unint64_t)((*((void *)&v234 + 1) - (void)v234) / 56) <= 1) {
        unint64_t v122 = 1;
      }
      else {
        unint64_t v122 = (*((void *)&v234 + 1) - (void)v234) / 56;
      }
      if ((unint64_t)((*((void *)&v229 + 1) - (void)v229) / 56) <= 1) {
        unint64_t v123 = 1;
      }
      else {
        unint64_t v123 = (*((void *)&v229 + 1) - (void)v229) / 56;
      }
      if (*((void *)&v234 + 1) == (void)v234)
      {
        float v125 = 1.1755e-38;
        if (*((void *)&v229 + 1) != (void)v229) {
          goto LABEL_101;
        }
      }
      else
      {
        v124 = (uint64_t *)(v234 + 16);
        float v125 = 1.1755e-38;
        unint64_t v126 = v122;
        do
        {
          uint64_t v127 = *v124;
          v124 += 7;
          float v125 = fmaxf(*(float *)&v127, v125);
          --v126;
        }
        while (v126);
        if (*((void *)&v229 + 1) != (void)v229)
        {
LABEL_101:
          v128 = (uint64_t *)(v229 + 16);
          float v129 = 3.4028e38;
          float v130 = 1.1755e-38;
          unint64_t v131 = v123;
          do
          {
            float v129 = fminf(COERCE_FLOAT(*(v128 - 1)), v129);
            uint64_t v132 = *v128;
            v128 += 7;
            float v130 = fmaxf(*(float *)&v132, v130);
            --v131;
          }
          while (v131);
          goto LABEL_106;
        }
      }
      float v130 = 1.1755e-38;
      float v129 = 3.4028e38;
LABEL_106:
      BOOL v133 = v129 < v125;
      BOOL v10 = v130 < v125;
      BOOL v134 = v130 > v125;
      float v135 = v125 - v129;
      int v136 = v10;
      if (!v133 || !v134) {
        float v135 = 1.0;
      }
      float v137 = v130 - v129;
      if ((v133 & v136) == 0) {
        float v137 = 1.0;
      }
      if (*((void *)&v234 + 1) == (void)v234)
      {
        float v139 = 1.1755e-38;
        goto LABEL_122;
      }
      if (v122 < 8)
      {
        unint64_t v138 = 0;
        float v139 = 1.1755e-38;
LABEL_120:
        v146 = (float *)(v234 + 56 * v138 + 20);
        unint64_t v147 = v122 - v138;
        do
        {
          float v148 = *v146;
          v146 += 14;
          float v139 = fmaxf(v148, v139);
          --v147;
        }
        while (v147);
        goto LABEL_122;
      }
      unint64_t v138 = v122 & 0xFFFFFFFFFFFFFFF8;
      v140 = (__int32 *)(v234 + 244);
      v141.i64[0] = 0x80000000800000;
      v141.i64[1] = 0x80000000800000;
      unint64_t v142 = v122 & 0xFFFFFFFFFFFFFFF8;
      v143.i64[0] = 0x80000000800000;
      v143.i64[1] = 0x80000000800000;
      do
      {
        v144.i32[0] = *(v140 - 56);
        v144.i32[1] = *(v140 - 42);
        v144.i32[2] = *(v140 - 28);
        v144.i32[3] = *(v140 - 14);
        v145.i32[0] = *v140;
        v145.i32[1] = v140[14];
        v145.i32[2] = v140[28];
        v145.i32[3] = v140[42];
        float32x4_t v141 = vmaxnmq_f32(v144, v141);
        float32x4_t v143 = vmaxnmq_f32(v145, v143);
        v140 += 112;
        v142 -= 8;
      }
      while (v142);
      float v139 = vmaxnmvq_f32(vmaxnmq_f32(v141, v143));
      if (v122 != v138) {
        goto LABEL_120;
      }
LABEL_122:
      if (*((void *)&v229 + 1) == (void)v229)
      {
        float v151 = 1.1755e-38;
        float v150 = 3.4028e38;
      }
      else
      {
        if (v123 >= 2)
        {
          unint64_t v149 = v123 & 0xFFFFFFFFFFFFFFFELL;
          v152 = (float *)(v229 + 76);
          float v153 = 3.4028e38;
          float v154 = 1.1755e-38;
          unint64_t v155 = v123 & 0xFFFFFFFFFFFFFFFELL;
          float v156 = 1.1755e-38;
          float v157 = 3.4028e38;
          do
          {
            float v153 = fminf(*(v152 - 16), v153);
            float v157 = fminf(*(v152 - 2), v157);
            float v158 = *(v152 - 14);
            float v159 = *v152;
            v152 += 28;
            float v154 = fmaxf(v158, v154);
            float v156 = fmaxf(v159, v156);
            v155 -= 2;
          }
          while (v155);
          float v150 = fminf(v153, v157);
          float v151 = fmaxf(v154, v156);
          if (v123 == v149) {
            goto LABEL_131;
          }
        }
        else
        {
          unint64_t v149 = 0;
          float v150 = 3.4028e38;
          float v151 = 1.1755e-38;
        }
        v160 = (float *)(v229 + 56 * v149 + 20);
        unint64_t v161 = v123 - v149;
        do
        {
          float v150 = fminf(*(v160 - 2), v150);
          float v162 = *v160;
          v160 += 14;
          float v151 = fmaxf(v162, v151);
          --v161;
        }
        while (v161);
      }
LABEL_131:
      float v163 = v135 * v137;
      float v164 = v139 - v150;
      if (v150 >= v139 || v151 <= v139) {
        float v164 = 1.0;
      }
      float v165 = v164 * v163;
      float v166 = v151 - v150;
      if (v150 >= v139 || v151 >= v139) {
        float v166 = 1.0;
      }
      float v167 = v165 * v166;
      if (v112 > (float)(v165 * v166)) {
        int v111 = v110;
      }
      if (*((void *)&v234 + 1) != (void)v234)
      {
        do
        {

          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v118 - 32));
          v118 -= 56;
        }
        while (v118 != v119);
        uint64_t v121 = *((void *)&v229 + 1);
        uint64_t v120 = v229;
      }
      *((void *)&v234 + 1) = v119;
      for (i = (uint64_t *)v222; v121 != v120; v121 -= 56)
      {

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v121 - 32));
      }
      float v112 = fminf(v112, v167);
      *((void *)&v229 + 1) = v120;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v229);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v234);
      ++v110;
      a1 = v221;
      LODWORD(v7) = v225;
      if (v110 == v220) {
        goto LABEL_144;
      }
    }
  }
  int v111 = 0;
LABEL_144:
  uint64_t v168 = *i;
  uint64_t v169 = *i + 56 * v7 + 56 * v111;
  uint64_t v170 = (v169 - *i) >> 3;
  k = 0;
  uint64_t v244 = 0;
  v242 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPS4_EESB_EEvT_T0_m(&v242, v168, v169, 0x6DB6DB6DB6DB6DB7 * v170);
  uint64_t v171 = a1[4];
  uint64_t v172 = a1[3] + 56 * v7 + 56 * v111;
  v240 = 0;
  uint64_t v241 = 0;
  v239 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPS4_EESB_EEvT_T0_m(&v239, v172, v171, 0x6DB6DB6DB6DB6DB7 * ((v171 - v172) >> 3));
  uint64_t v173 = *i;
  float32x2_t v174 = *(float32x2_t *)(*i + 16);
  long long v234 = *(_OWORD *)*i;
  v235 = (char *)v174;
  uint64_t v236 = 0;
  v237[0] = 0;
  v237[1] = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v236, *(long long **)(v173 + 24), *(long long **)(v173 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v173 + 32) - *(void *)(v173 + 24)) >> 3));
  id v238 = *(id *)(v173 + 48);
  v175 = (_OWORD *)*i;
  long long v229 = *(_OWORD *)(*i + 56);
  v176 = (long long *)*((void *)v175 + 10);
  v230 = (char *)*((void *)v175 + 9);
  uint64_t v231 = 0;
  v232[0] = 0;
  v232[1] = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v231, v176, *((long long **)v175 + 11), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v175 + 11) - (void)v176) >> 3));
  id v233 = *((id *)v175 + 13);
  *(_DWORD *)v226 = *(_DWORD *)a1;
  *(_OWORD *)&v226[8] = 0u;
  long long v227 = 0u;
  *(_OWORD *)obuint64_t j = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v227, (*(_DWORD *)v226 + 1));
  v177 = (_OWORD *)*i;
  long long v178 = *(_OWORD *)v226;
  *((void *)v177 + 2) = 0;
  _OWORD *v177 = v178;
  if (v177 != (_OWORD *)v226) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v177 + 3, v227, *((uint64_t *)&v227 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v227 + 1) - v227) >> 3));
  }
  objc_storeStrong((id *)v177 + 6, obj[1]);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v227);
  *(_DWORD *)v226 = *(_DWORD *)a1;
  *(_OWORD *)&v226[8] = 0u;
  long long v227 = 0u;
  *(_OWORD *)obuint64_t j = 0u;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm((uint64_t *)&v227, (*(_DWORD *)v226 + 1));
  v179 = (_OWORD *)*i;
  *(_OWORD *)((char *)v179 + 56) = *(_OWORD *)v226;
  *((void *)v179 + 9) = *(void *)&v226[16];
  if ((char *)v179 + 56 != v226) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v179 + 10, v227, *((uint64_t *)&v227 + 1), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v227 + 1) - v227) >> 3));
  }
  objc_storeStrong((id *)v179 + 13, obj[1]);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v227);
  unint64_t v180 = 0;
  for (uint64_t j = 24; ; j += 56)
  {
    v182 = v242;
    v183 = k;
    unint64_t v184 = 0x6DB6DB6DB6DB6DB7 * ((k - v242) >> 3);
    v185 = v239;
    v186 = v240;
    if (v180 >= v184 + 0x6DB6DB6DB6DB6DB7 * ((v240 - v239) >> 3)) {
      break;
    }
    if (v180 >= v184)
    {
      if (v180 == 1)
      {
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v222 + 14, v233, (float32x2_t *)&v229 + 1, (float32x2_t *)&v230);
        v187 = (void **)(*((void *)*v222 + 11) - 32);
        if (v187 != (void **)&v231)
        {
          uint64_t v188 = v231;
          v189 = v232;
          goto LABEL_149;
        }
      }
      else if (v180)
      {
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v222 + 14, *(void **)&v239[j + 24 + -8 * ((k - v242) >> 3)], (float32x2_t *)&v239[j - 16 + -8 * ((k - v242) >> 3)], (float32x2_t *)&v239[j - 8 + -8 * ((k - v242) >> 3)]);
        v192 = (void **)&v239[j + -56 * v184];
        v187 = (void **)(*((void *)*v222 + 11) - 32);
        if (v192 != v187)
        {
          v193 = *v192;
          v189 = (uint64_t *)(v192 + 1);
          uint64_t v188 = (uint64_t)v193;
          goto LABEL_149;
        }
      }
      else
      {
        _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v222 + 14, v238, (float32x2_t *)&v234 + 1, (float32x2_t *)&v235);
        v187 = (void **)(*((void *)*v222 + 11) - 32);
        if (v187 != (void **)&v236)
        {
          uint64_t v188 = v236;
          v189 = v237;
          goto LABEL_149;
        }
      }
    }
    else if (v180 == 1)
    {
      _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v222, v233, (float32x2_t *)&v229 + 1, (float32x2_t *)&v230);
      v187 = (void **)(*((void *)*v222 + 4) - 32);
      if (v187 != (void **)&v231)
      {
        uint64_t v188 = v231;
        v189 = v232;
        goto LABEL_149;
      }
    }
    else if (v180)
    {
      _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v222, *(void **)&v242[j + 24], (float32x2_t *)&v242[j - 16], (float32x2_t *)&v242[j - 8]);
      v190 = &v242[j];
      v187 = (void **)(*((void *)*v222 + 4) - 32);
      if (&v242[j] != (char *)v187)
      {
        uint64_t v191 = *(void *)v190;
        v189 = (uint64_t *)(v190 + 8);
        uint64_t v188 = v191;
        goto LABEL_149;
      }
    }
    else
    {
      _ZN12GKCRTreeNodeI8NSObjectDv2_fE9AddObjectEPS0_RKS1_S5_(*v222, v238, (float32x2_t *)&v234 + 1, (float32x2_t *)&v235);
      v187 = (void **)(*((void *)*v222 + 4) - 32);
      if (v187 != (void **)&v236)
      {
        uint64_t v188 = v236;
        v189 = v237;
LABEL_149:
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v187, v188, *v189, 0x6DB6DB6DB6DB6DB7 * ((*v189 - v188) >> 3));
      }
    }
    ++v180;
  }
  if (k == v242)
  {
    v194 = v221;
    k = v242;
    if (v240 != v239) {
      goto LABEL_173;
    }
  }
  else
  {
    v194 = v221;
    do
    {

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)v183 - 4);
      v183 -= 56;
    }
    while (v183 != v182);
    v185 = v239;
    v186 = v240;
    for (k = v182; v186 != v185; v186 -= 56)
    {
LABEL_173:

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)v186 - 4);
    }
  }
  v240 = v185;
  uint64_t v195 = v194[3];
  uint64_t v196 = v194[4];
  unint64_t v197 = 0x6DB6DB6DB6DB6DB7 * ((v196 - v195) >> 3);
  if (v197 > 1)
  {
    if (v196 - v195 == 112)
    {
      uint64_t m = v194[4];
    }
    else
    {
      for (uint64_t m = v195 + 112; v196 != m; v196 -= 56)
      {

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v196 - 32));
      }
      v194[4] = m;
    }
  }
  else
  {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE8__appendEm((uint64_t *)v222, 2 - v197);
    uint64_t m = v194[4];
  }
  v199 = (float32x2_t *)v194[3];
  float32x2_t v200 = v199[1];
  v194[1] = v200;
  float32x2_t v201 = v199[2];
  v194[2] = v201;
  unint64_t v202 = 0x6DB6DB6DB6DB6DB7 * ((m - (uint64_t)v199) >> 3);
  if (v202 >= 2)
  {
    float32x2_t v203 = (float32x2_t)vzip2_s32((int32x2_t)v201, (int32x2_t)v200);
    v204 = v199 + 9;
    unint64_t v205 = v202 - 1;
    do
    {
      float32x2_t v206 = v204[-1];
      float v207 = v200.f32[1];
      float32x2_t v208 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v200, 1), (float32x2_t)vdup_lane_s32((int32x2_t)v203, 1)), 0), (int8x8_t)v203, (int8x8_t)v200);
      v200.i32[0] = vminnm_f32(v206, v200).u32[0];
      float32x2_t v209 = *v204;
      v204 += 7;
      int32x2_t v210 = (int32x2_t)vmaxnm_f32(v209, v201);
      int8x8_t v211 = (int8x8_t)vzip1_s32(v210, (int32x2_t)v203);
      v210.i32[1] = v201.i32[1];
      v200.i32[1] = v208.i32[1];
      v208.f32[0] = fminf(v203.f32[1], v207);
      int32x2_t v212 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v208, (float32x2_t)vdup_lane_s32((int32x2_t)v206, 1)), 0), (int8x8_t)v206, (int8x8_t)v200);
      v200.i32[1] = v212.i32[1];
      v208.i32[0] = v201.i32[1];
      float32x2_t v201 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v203, (float32x2_t)vdup_lane_s32((int32x2_t)v201, 1)), 0), v211, (int8x8_t)v210);
      v203.f32[0] = fmaxf(v203.f32[0], v208.f32[0]);
      int32x2_t v213 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v209, 1), v203), 0), (int8x8_t)v209, (int8x8_t)v201);
      v201.i32[1] = v213.i32[1];
      v194[1] = v200;
      v194[2] = v201;
      float32x2_t v203 = (float32x2_t)vzip2_s32(v213, v212);
      --v205;
    }
    while (v205);
  }

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v231);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v236);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v239);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v242);
}

void sub_235EB49DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19, uint64_t a20,void **a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a19);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a21);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v43 - 200));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v43 - 176));

  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE21__push_back_slow_pathIS4_EEPS4_OT_(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = a1[1] - *a1;
  unint64_t v4 = 0x6DB6DB6DB6DB6DB7 * (v3 >> 3) + 1;
  if (v4 > 0x492492492492492) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249) {
    unint64_t v6 = 0x492492492492492;
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v19 = a1 + 2;
  if (v6)
  {
    if (v6 > 0x492492492492492) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v7 = (char *)operator new(56 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  char v8 = &v7[8 * (v3 >> 3)];
  __p = v7;
  uint64_t v16 = v8;
  unint64_t v17 = v8;
  uint64_t v18 = &v7[56 * v6];
  *(_OWORD *)char v8 = *(_OWORD *)a2;
  float v9 = *(long long **)(a2 + 24);
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  BOOL v10 = &v7[v3];
  *((void *)v10 + 3) = 0;
  *((void *)v10 + 4) = 0;
  *((void *)v10 + 5) = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m((void *)v10 + 3, v9, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v9) >> 3));
  *((void *)v10 + 6) = *(id *)(a2 + 48);
  v17 += 56;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS4_RS6_EE(a1, &__p);
  uint64_t v11 = a1[1];
  char v12 = v16;
  for (i = v17; v17 != v12; i = v17)
  {
    unint64_t v17 = i - 56;

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)i - 4);
  }
  if (__p) {
    operator delete(__p);
  }
  return v11;
}

void sub_235EB4D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  _ZNSt3__114__split_bufferI12GKCRTreeNodeI8NSObjectDv2_fERNS_9allocatorIS4_EEED1Ev((uint64_t)va);
  _Unwind_Resume(a1);
}

void *_ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(void *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    int v5 = result;
    if (a4 >= 0x492492492492493) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    result = operator new(56 * a4);
    *int v5 = result;
    v5[1] = result;
    v5[2] = &result[7 * a4];
    BOOL v10 = result;
    if (a2 == a3)
    {
      char v8 = result;
    }
    else
    {
      char v8 = result;
      do
      {
        long long v9 = *a2;
        v8[2] = *((void *)a2 + 2);
        *(_OWORD *)char v8 = v9;
        v8[3] = 0;
        v8[4] = 0;
        v8[5] = 0;
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v8 + 3);
        result = *((id *)a2 + 6);
        v8[6] = result;
        char v8 = v10 + 7;
        v10 += 7;
        a2 = (long long *)((char *)a2 + 56);
      }
      while (a2 != a3);
    }
    v5[1] = v8;
  }
  return result;
}

void sub_235EB4ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_235EB4EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, char a11)
{
  _ZNSt3__128__exception_guard_exceptionsINS_29_AllocatorDestroyRangeReverseINS_9allocatorI12GKCRTreeNodeI8NSObjectDv2_fEEEPS6_EEED1B8ne180100Ev((uint64_t)&a11);
  *(void *)(v11 + 8) = v12;
  _ZNSt3__128__exception_guard_exceptionsINS_6vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS5_EEE16__destroy_vectorEED1B8ne180100Ev(&a9);
  _Unwind_Resume(a1);
}

void ***_ZNSt3__128__exception_guard_exceptionsINS_6vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS5_EEE16__destroy_vectorEED1B8ne180100Ev(void ***result)
{
  v1 = result;
  if (!*((unsigned char *)result + 8))
  {
    uint64_t v2 = *result;
    uint64_t v3 = (id *)**result;
    if (v3)
    {
      unint64_t v4 = (id *)v2[1];
      int v5 = **result;
      if (v4 != v3)
      {
        do
        {

          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v4 - 4);
          v4 -= 7;
        }
        while (v4 != v3);
        int v5 = **v1;
      }
      v2[1] = v3;
      operator delete(v5);
      return v1;
    }
  }
  return result;
}

void _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_264C93000, MEMORY[0x263F8C060]);
}

void sub_235EB5004(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x263F8C208], MEMORY[0x263F8C090]);
}

uint64_t _ZNSt3__128__exception_guard_exceptionsINS_29_AllocatorDestroyRangeReverseINS_9allocatorI12GKCRTreeNodeI8NSObjectDv2_fEEEPS6_EEED1B8ne180100Ev(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = *(uint64_t **)(a1 + 8);
    uint64_t v2 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = *v2;
    for (uint64_t i = *v3; v4 != i; v4 -= 56)
    {

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v4 - 32));
    }
  }
  return a1;
}

uint64_t *_ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS4_RS6_EE(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6 + v7;
      long long v9 = *(_OWORD *)(v4 + v7 - 56);
      *(void *)(v8 - 40) = *(void *)(v4 + v7 - 40);
      *(_OWORD *)(v8 - 56) = v9;
      *(void *)(v6 + v7 - 32) = 0;
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 16) = 0;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m((void *)(v6 + v7 - 32), *(long long **)(v4 + v7 - 32), *(long long **)(v4 + v7 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v4 + v7 - 24) - *(void *)(v4 + v7 - 32)) >> 3));
      result = (uint64_t *)*(id *)(v4 + v7 - 8);
      *(void *)(v8 - 8) = result;
      v7 -= 56;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v10 = *v3;
  uint64_t *v3 = v6;
  a2[1] = v10;
  uint64_t v11 = v3[1];
  v3[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = v3[2];
  v3[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t _ZNSt3__114__split_bufferI12GKCRTreeNodeI8NSObjectDv2_fERNS_9allocatorIS4_EEED1Ev(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE7reserveEm(uint64_t *a1, unint64_t a2)
{
  if (0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3) < a2)
  {
    if (a2 >= 0x492492492492493) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v3 = a1[1] - *a1;
    uint64_t v11 = a1 + 2;
    uint64_t v4 = 56 * a2;
    __p = operator new(56 * a2);
    uint64_t v8 = (char *)__p + v3;
    long long v9 = (char *)__p + v3;
    uint64_t v10 = (char *)__p + v4;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS4_RS6_EE(a1, &__p);
    uint64_t v5 = v8;
    for (uint64_t i = v9; v9 != v5; uint64_t i = v9)
    {
      long long v9 = i - 56;

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)i - 4);
    }
    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_235EB536C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  _ZNSt3__114__split_bufferI12GKCRTreeNodeI8NSObjectDv2_fERNS_9allocatorIS4_EEED1Ev((uint64_t)va);
  _Unwind_Resume(a1);
}

void _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(void **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)a1[2];
  long long v9 = (id *)*a1;
  if (0x6DB6DB6DB6DB6DB7 * ((v8 - (uint64_t)*a1) >> 3) >= a4)
  {
    uint64_t v21 = (id *)a1[1];
    if (0x6DB6DB6DB6DB6DB7 * (v21 - v9) >= a4)
    {
      if (a2 != a3)
      {
        uint64_t v27 = a2 + 32;
        do
        {
          uint64_t v28 = v27 - 32;
          long long v29 = *(_OWORD *)(v27 - 32);
          v9[2] = *(id *)(v27 - 16);
          *(_OWORD *)long long v9 = v29;
          if (v9 != (id *)(v27 - 32)) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v9 + 3);
          }
          objc_storeStrong(v9 + 6, *(id *)(v27 + 16));
          v9 += 7;
          v27 += 56;
        }
        while (v28 + 56 != a3);
        uint64_t v21 = (id *)a1[1];
      }
      for (; v21 != v9; v21 -= 7)
      {

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v21 - 4);
      }
      a1[1] = v9;
    }
    else
    {
      uint64_t v22 = a2 + 8 * (v21 - v9);
      if (v21 != v9)
      {
        float32x2_t v23 = (char *)(v9 + 3);
        uint64_t v24 = a2 + 32;
        do
        {
          uint64_t v25 = v24 - 32;
          long long v26 = *(_OWORD *)(v24 - 32);
          *((void *)v23 - 1) = *(void *)(v24 - 16);
          *(_OWORD *)(v23 - 24) = v26;
          if (v23 - 24 != (char *)(v24 - 32)) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v23);
          }
          objc_storeStrong((id *)v23 + 3, *(id *)(v24 + 16));
          v23 += 56;
          v24 += 56;
        }
        while (v25 + 56 != v22);
        long long v9 = (id *)a1[1];
      }
      unint64_t v30 = (char *)v9;
      if (v22 != a3)
      {
        unint64_t v31 = 0;
        do
        {
          uint64_t v32 = (char *)&v9[v31 / 8];
          uint64_t v33 = v22 + v31;
          long long v34 = *(_OWORD *)(v22 + v31);
          *((void *)v32 + 2) = *(void *)(v22 + v31 + 16);
          *(_OWORD *)uint64_t v32 = v34;
          v9[v31 / 8 + 3] = 0;
          *((void *)v32 + 4) = 0;
          *((void *)v32 + 5) = 0;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v9[v31 / 8 + 3], *(long long **)(v22 + v31 + 24), *(long long **)(v22 + v31 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v22 + v31 + 32) - *(void *)(v22 + v31 + 24)) >> 3));
          *((void *)v32 + 6) = *(id *)(v22 + v31 + 48);
          v31 += 56;
        }
        while (v33 + 56 != a3);
        unint64_t v30 = (char *)&v9[v31 / 8];
      }
      a1[1] = v30;
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v10 = (id *)a1[1];
      uint64_t v11 = *a1;
      if (v10 != v9)
      {
        do
        {

          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v10 - 4);
          v10 -= 7;
        }
        while (v10 != v9);
        uint64_t v11 = *a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x492492492492492) {
      goto LABEL_40;
    }
    unint64_t v12 = 0x6DB6DB6DB6DB6DB7 * (v8 >> 3);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= a4) {
      uint64_t v13 = a4;
    }
    unint64_t v14 = v12 >= 0x249249249249249 ? 0x492492492492492 : v13;
    if (v14 > 0x492492492492492) {
LABEL_40:
    }
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    uint64_t v15 = 56 * v14;
    uint64_t v16 = (char *)operator new(56 * v14);
    *a1 = v16;
    a1[1] = v16;
    a1[2] = &v16[v15];
    if (a2 != a3)
    {
      uint64_t v17 = 0;
      do
      {
        uint64_t v18 = &v16[v17];
        uint64_t v19 = a2 + v17;
        *(_OWORD *)uint64_t v18 = *(_OWORD *)(a2 + v17);
        float v20 = *(long long **)(a2 + v17 + 24);
        *((void *)v18 + 2) = *(void *)(a2 + v17 + 16);
        *((void *)v18 + 4) = 0;
        *((void *)v18 + 5) = 0;
        *(void *)&v16[v17 + 24] = 0;
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v16[v17 + 24], v20, *(long long **)(a2 + v17 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + v17 + 32) - (void)v20) >> 3));
        *((void *)v18 + 6) = *(id *)(a2 + v17 + 48);
        v17 += 56;
      }
      while (v19 + 56 != a3);
      v16 += v17;
    }
    a1[1] = v16;
  }
}

void _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE8__appendEm(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v11 = v5 + 56 * a2;
      do
      {
        *(_DWORD *)uint64_t v5 = 0;
        *(_OWORD *)(v5 + 8) = 0uLL;
        *(_OWORD *)(v5 + 24) = 0uLL;
        *(_OWORD *)(v5 + 40) = 0uLL;
        v5 += 56;
      }
      while (v5 != v11);
      uint64_t v5 = v11;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x492492492492492) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 3);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x249249249249249) {
      unint64_t v9 = 0x492492492492492;
    }
    else {
      unint64_t v9 = v7;
    }
    float v20 = a1 + 2;
    if (v9)
    {
      if (v9 > 0x492492492492492) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v10 = (char *)operator new(56 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    unint64_t v12 = &v10[56 * v6];
    __p = v10;
    uint64_t v17 = v12;
    uint64_t v19 = &v10[56 * v9];
    uint64_t v13 = &v12[56 * a2];
    do
    {
      *(_DWORD *)unint64_t v12 = 0;
      *(_OWORD *)(v12 + 8) = 0uLL;
      *(_OWORD *)(v12 + 24) = 0uLL;
      *(_OWORD *)(v12 + 40) = 0uLL;
      v12 += 56;
    }
    while (v12 != v13);
    uint64_t v18 = v13;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS4_RS6_EE(a1, &__p);
    unint64_t v14 = v17;
    for (uint64_t i = v18; v18 != v14; uint64_t i = v18)
    {
      uint64_t v18 = i - 56;

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)i - 4);
    }
    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_235EB595C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  _ZNSt3__114__split_bufferI12GKCRTreeNodeI8NSObjectDv2_fERNS_9allocatorIS4_EEED1Ev((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(uint64_t result, void **a2, _DWORD *a3, uint64_t a4, char a5)
{
  uint64_t v10 = result;
  while (2)
  {
    float32x2_t v36 = (long long *)(a2 - 7);
    uint64_t v11 = v10;
LABEL_3:
    uint64_t v12 = a4 - 1;
    while (1)
    {
      uint64_t v10 = v11;
      a4 = v12;
      uint64_t v13 = (uint64_t)a2 - v11;
      unint64_t v14 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)a2 - v11) >> 3);
      if (!(!v6 & v5))
      {
        switch(v14)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t v26 = (uint64_t)*(a2 - 5);
            long long v47 = *v36;
            uint64_t v48 = v26;
            memset(v49, 0, sizeof(v49));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v49, (long long *)*(a2 - 4), (long long *)*(a2 - 3), 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)*(a2 - 3) - (unsigned char *)*(a2 - 4)) >> 3));
            id v50 = *(a2 - 1);
            uint64_t v27 = *(void *)(v11 + 16);
            long long v44 = *(_OWORD *)v11;
            uint64_t v45 = v27;
            memset(v46, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, *(long long **)(v11 + 24), *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - *(void *)(v11 + 24)) >> 3));
            v46[3] = *(void **)(v11 + 48);
            float v28 = *(float *)(((unint64_t)&v47 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            float v29 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);

            result = (uint64_t)_ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v49);
            if (v28 < v29) {
              result = (uint64_t)_ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v11, v36);
            }
            break;
          case 3uLL:
            result = _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(v11, v11 + 56, (uint64_t)v36, a3);
            break;
          case 4uLL:
            result = (uint64_t)_ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_SC_SC_T0_(v11, v11 + 56, v11 + 112, (uint64_t)v36, a3);
            break;
          case 5uLL:
            result = (uint64_t)_ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_SC_SC_SC_T0_(v11, v11 + 56, v11 + 112, v11 + 168, (uint64_t)v36, a3);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v13 <= 1343)
      {
        if (a5) {
          return (uint64_t)_ZNSt3__116__insertion_sortB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_T0_((void **)v11, a2, a3);
        }
        else {
          return (uint64_t)_ZNSt3__126__insertion_sort_unguardedB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_T0_((void **)v11, a2, a3);
        }
      }
      if (v12 == -1)
      {
        if ((void **)v11 != a2)
        {
          unint64_t v30 = (v14 - 2) >> 1;
          unint64_t v31 = v30 + 1;
          uint64_t v32 = (char *)(v11 + 56 * v30);
          do
          {
            _ZNSt3__111__sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_OT0_NS_15iterator_traitsISC_E15difference_typeESC_((void **)v10, a3, v14, v32);
            v32 -= 56;
            --v31;
          }
          while (v31);
          unint64_t v33 = v13 / 0x38uLL;
          do
          {
            result = (uint64_t)_ZNSt3__110__pop_heapB8ne180100INS_17_ClassicAlgPolicyEZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SB_RT0_NS_15iterator_traitsISB_E15difference_typeE((void **)v10, (uint64_t)a2, a3, v33);
            a2 -= 7;
          }
          while (v33-- > 2);
        }
        return result;
      }
      unint64_t v15 = v14 >> 1;
      uint64_t v16 = (long long *)(v11 + 56 * v15);
      if ((unint64_t)v13 >= 0x1C01)
      {
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(v10, v10 + 56 * v15, (uint64_t)v36, a3);
        uint64_t v17 = v10 + 56 * v15;
        uint64_t v18 = v17 - 56;
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(v10 + 56, v17 - 56, (uint64_t)(a2 - 14), a3);
        v17 += 56;
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(v10 + 112, v17, (uint64_t)(a2 - 21), a3);
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(v18, (uint64_t)v16, v17, a3);
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v10, v16);
        if (a5) {
          goto LABEL_14;
        }
      }
      else
      {
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(v10 + 56 * v15, v10, (uint64_t)v36, a3);
        if (a5) {
          goto LABEL_14;
        }
      }
      long long v19 = *(_OWORD *)(v10 - 56);
      uint64_t v41 = *(void *)(v10 - 40);
      long long v40 = v19;
      memset(v42, 0, sizeof(v42));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v42, *(long long **)(v10 - 32), *(long long **)(v10 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v10 - 24) - *(void *)(v10 - 32)) >> 3));
      id v43 = *(id *)(v10 - 8);
      uint64_t v20 = *(void *)(v10 + 16);
      long long v37 = *(_OWORD *)v10;
      uint64_t v38 = v20;
      memset(v39, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, *(long long **)(v10 + 24), *(long long **)(v10 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v10 + 32) - *(void *)(v10 + 24)) >> 3));
      v39[3] = *(void **)(v10 + 48);
      float v21 = *(float *)(((unint64_t)&v40 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v22 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v42);
      if (v21 >= v22)
      {
        result = _ZNSt3__131__partition_with_equals_on_leftB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E_EET0_SC_SC_T1_((long long *)v10, (unint64_t)a2, a3);
        uint64_t v11 = result;
        a5 = 0;
        goto LABEL_3;
      }
LABEL_14:
      unint64_t v23 = _ZNSt3__132__partition_with_equals_on_rightB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E_EENS_4pairIT0_bEESD_SD_T1_((long long *)v10, (long long *)a2, a3);
      if ((v24 & 1) == 0) {
        goto LABEL_17;
      }
      BOOL v25 = _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEbT1_SC_T0_(v10, v23, a3);
      uint64_t v11 = v23 + 56;
      result = _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEbT1_SC_T0_(v23 + 56, (uint64_t)a2, a3);
      if (result) {
        break;
      }
      uint64_t v12 = a4 - 1;
      if (!v25)
      {
LABEL_17:
        result = _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v10, v23, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v11 = v23 + 56;
        goto LABEL_3;
      }
    }
    a2 = (void **)v23;
    if (!v25) {
      continue;
    }
    return result;
  }
}

void sub_235EB5E64(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void **_ZNSt3__116__insertion_sortB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_T0_(void **result, void **a2, _DWORD *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = result + 7;
    if (result + 7 != a2)
    {
      uint64_t v6 = 0;
      unint64_t v7 = result;
      do
      {
        unint64_t v8 = v4;
        long long v36 = *(_OWORD *)v4;
        long long v37 = v4[2];
        memset(v38, 0, sizeof(v38));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
        id v39 = v7[13];
        unint64_t v9 = v7[2];
        long long v33 = *(_OWORD *)v7;
        long long v34 = v9;
        memset(v35, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, (long long *)v7[3], (long long *)v7[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[4] - (unsigned char *)v7[3]) >> 3));
        v35[3] = v7[6];
        float v10 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v11 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

        result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
        if (v10 < v11)
        {
          long long v27 = *(_OWORD *)v8;
          float v28 = v8[2];
          unint64_t v30 = 0;
          uint64_t v31 = 0;
          float v29 = 0;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
          obuint64_t j = v7[13];
          uint64_t v12 = v6;
          while (1)
          {
            uint64_t v13 = (char *)v3 + v12;
            *(_OWORD *)(v13 + 56) = *(_OWORD *)((char *)v3 + v12);
            uint64_t v14 = *(uint64_t *)((char *)v3 + v12 + 24);
            *((void *)v13 + 9) = *(void **)((char *)v3 + v12 + 16);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)((char *)v3 + v12 + 80), v14, *(uint64_t *)((char *)v3 + v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((*(uint64_t *)((char *)v3 + v12 + 32) - v14) >> 3));
            objc_storeStrong((id *)v13 + 13, *((id *)v13 + 6));
            if (!v12) {
              break;
            }
            long long v23 = v27;
            char v24 = v28;
            memset(v25, 0, sizeof(v25));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
            id v26 = obj;
            long long v20 = *(_OWORD *)((char *)v3 + v12 - 56);
            unint64_t v15 = *(long long **)((char *)v3 + v12 - 32);
            uint64_t v21 = *(uint64_t *)((char *)v3 + v12 - 40);
            memset(v22, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v15, *(long long **)((char *)v3 + v12 - 24), 0x6DB6DB6DB6DB6DB7 * ((*(unsigned char **)((char *)v3 + v12 - 24) - (unsigned char *)v15) >> 3));
            v22[3] = *(void **)((char *)v3 + v12 - 8);
            float v16 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            float v17 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
            v12 -= 56;
            if (v16 >= v17)
            {
              uint64_t v18 = (uint64_t)v3 + v12 + 56;
              goto LABEL_12;
            }
          }
          uint64_t v18 = (uint64_t)v3;
LABEL_12:
          *(_OWORD *)uint64_t v18 = v27;
          *(void *)(v18 + 16) = v28;
          if ((long long *)v18 != &v27) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v18 + 24), (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
          }
          objc_storeStrong((id *)(v18 + 48), obj);

          result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
        }
        uint64_t v4 = v8 + 7;
        v6 += 56;
        unint64_t v7 = v8;
      }
      while (v8 + 7 != a2);
    }
  }
  return result;
}

void sub_235EB61D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

void **_ZNSt3__126__insertion_sort_unguardedB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_T0_(void **result, void **a2, _DWORD *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = result + 7;
    if (result + 7 != a2)
    {
      uint64_t v6 = result + 13;
      do
      {
        unint64_t v7 = v4;
        long long v36 = *(_OWORD *)v4;
        long long v37 = v4[2];
        memset(v38, 0, sizeof(v38));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, (long long *)v3[10], (long long *)v3[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[11] - (unsigned char *)v3[10]) >> 3));
        id v39 = v3[13];
        unint64_t v8 = v3[2];
        long long v33 = *(_OWORD *)v3;
        long long v34 = v8;
        memset(v35, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, (long long *)v3[3], (long long *)v3[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[4] - (unsigned char *)v3[3]) >> 3));
        v35[3] = v3[6];
        float v9 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v10 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

        result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
        if (v9 < v10)
        {
          long long v27 = *(_OWORD *)v7;
          float v28 = v7[2];
          unint64_t v30 = 0;
          uint64_t v31 = 0;
          float v29 = 0;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, (long long *)v3[10], (long long *)v3[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[11] - (unsigned char *)v3[10]) >> 3));
          obuint64_t j = v3[13];
          float v11 = v6;
          do
          {
            uint64_t v12 = v11;
            *((_OWORD *)v11 - 3) = *(_OWORD *)(v11 - 13);
            uint64_t v13 = (uint64_t)*(v11 - 10);
            uint64_t v14 = (uint64_t)*(v11 - 9);
            *(v11 - 4) = *(v11 - 11);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v11 - 3, v13, v14, 0x6DB6DB6DB6DB6DB7 * ((v14 - v13) >> 3));
            objc_storeStrong(v12, *(v12 - 7));
            long long v23 = v27;
            char v24 = v28;
            memset(v25, 0, sizeof(v25));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
            id v26 = obj;
            long long v20 = *((_OWORD *)v12 - 10);
            unint64_t v15 = (long long *)*(v12 - 17);
            uint64_t v21 = (uint64_t)*(v12 - 18);
            memset(v22, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v15, (long long *)*(v12 - 16), 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)*(v12 - 16) - (unsigned char *)v15) >> 3));
            v22[3] = *(v12 - 14);
            float v16 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            float v17 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
            float v11 = v12 - 7;
          }
          while (v16 < v17);
          *(_OWORD *)(v12 - 13) = v27;
          uint64_t v18 = v12 - 13;
          v18[2] = v28;
          if (v18 != (id *)&v27) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v18 + 3, (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
          }
          objc_storeStrong(v18 + 6, obj);

          result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
        }
        uint64_t v4 = v7 + 7;
        v6 += 7;
        uint64_t v3 = v7;
      }
      while (v7 + 7 != a2);
    }
  }
  return result;
}

void sub_235EB6534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  long long v63 = *(_OWORD *)a2;
  uint64_t v9 = *(void *)(a2 + 16);
  unint64_t v8 = *(long long **)(a2 + 24);
  uint64_t v64 = v9;
  memset(v65, 0, sizeof(v65));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v65, v8, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v8) >> 3));
  id v66 = *(id *)(a2 + 48);
  long long v60 = *(_OWORD *)a1;
  float v10 = *(long long **)(a1 + 24);
  uint64_t v61 = *(void *)(a1 + 16);
  memset(v62, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v62, v10, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v10) >> 3));
  v62[3] = *(void **)(a1 + 48);
  float v11 = *(float *)(((unint64_t)&v63 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  float v12 = *(float *)(((unint64_t)&v60 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v62);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v65);
  if (v11 < v12)
  {
    long long v42 = *(_OWORD *)a3;
    uint64_t v13 = *(long long **)(a3 + 24);
    uint64_t v43 = *(void *)(a3 + 16);
    memset(v44, 0, sizeof(v44));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v44, v13, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v13) >> 3));
    id v45 = *(id *)(a3 + 48);
    long long v39 = *(_OWORD *)a2;
    uint64_t v14 = *(long long **)(a2 + 24);
    uint64_t v40 = *(void *)(a2 + 16);
    memset(v41, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v14, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v14) >> 3));
    v41[3] = *(void **)(a2 + 48);
    float v15 = *(float *)(((unint64_t)&v42 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    float v16 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v44);
    if (v15 < v16)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a3);
      return 1;
    }
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
    long long v35 = *(_OWORD *)a3;
    long long v27 = *(long long **)(a3 + 24);
    uint64_t v36 = *(void *)(a3 + 16);
    memset(v37, 0, sizeof(v37));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v37, v27, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v27) >> 3));
    id v38 = *(id *)(a3 + 48);
    long long v32 = *(_OWORD *)a2;
    float v28 = *(long long **)(a2 + 24);
    uint64_t v33 = *(void *)(a2 + 16);
    memset(v34, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v28, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v28) >> 3));
    v34[3] = *(void **)(a2 + 48);
    float v29 = *(float *)(((unint64_t)&v35 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    float v30 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v37);
    if (v29 >= v30) {
      return 1;
    }
    BOOL v25 = (long long *)a2;
    id v26 = (long long *)a3;
LABEL_9:
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_(v25, v26);
    return 2;
  }
  long long v56 = *(_OWORD *)a3;
  float v17 = *(long long **)(a3 + 24);
  uint64_t v57 = *(void *)(a3 + 16);
  memset(v58, 0, sizeof(v58));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v58, v17, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v17) >> 3));
  id v59 = *(id *)(a3 + 48);
  long long v53 = *(_OWORD *)a2;
  uint64_t v18 = *(long long **)(a2 + 24);
  uint64_t v54 = *(void *)(a2 + 16);
  memset(v55, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v18, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v18) >> 3));
  v55[3] = *(void **)(a2 + 48);
  float v19 = *(float *)(((unint64_t)&v56 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  float v20 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v58);
  if (v19 < v20)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
    long long v49 = *(_OWORD *)a2;
    uint64_t v21 = *(long long **)(a2 + 24);
    uint64_t v50 = *(void *)(a2 + 16);
    memset(v51, 0, sizeof(v51));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v51, v21, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v21) >> 3));
    id v52 = *(id *)(a2 + 48);
    long long v46 = *(_OWORD *)a1;
    float v22 = *(long long **)(a1 + 24);
    uint64_t v47 = *(void *)(a1 + 16);
    memset(v48, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v22, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v22) >> 3));
    v48[3] = *(void **)(a1 + 48);
    float v23 = *(float *)(((unint64_t)&v49 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    float v24 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v51);
    if (v23 >= v24) {
      return 1;
    }
    BOOL v25 = (long long *)a1;
    id v26 = (long long *)a2;
    goto LABEL_9;
  }
  return 0;
}

void sub_235EB69FC(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

unint64_t _ZNSt3__131__partition_with_equals_on_leftB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E_EET0_SC_SC_T1_(long long *a1, unint64_t a2, _DWORD *a3)
{
  long long v76 = *a1;
  uint64_t v6 = (long long *)*((void *)a1 + 3);
  uint64_t v33 = (void **)a1 + 3;
  uint64_t v77 = *((void *)a1 + 2);
  float v78 = 0;
  v79 = 0;
  uint64_t v80 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v78, v6, *((long long **)a1 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a1 + 4) - (void)v6) >> 3));
  id v81 = *((id *)a1 + 6);
  long long v72 = v76;
  uint64_t v73 = v77;
  memset(v74, 0, sizeof(v74));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v74, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
  id v75 = v81;
  long long v69 = *(_OWORD *)(a2 - 56);
  unint64_t v7 = *(long long **)(a2 - 32);
  uint64_t v70 = *(void *)(a2 - 40);
  memset(v71, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v71, v7, *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - (void)v7) >> 3));
  v71[3] = *(void **)(a2 - 8);
  float v8 = *(float *)(((unint64_t)&v72 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
  float v9 = *(float *)(((unint64_t)&v69 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v71);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v74);
  if (v8 >= v9)
  {
    unint64_t v14 = (unint64_t)a1 + 56;
    do
    {
      unint64_t v11 = v14;
      if (v14 >= a2) {
        break;
      }
      long long v58 = v76;
      uint64_t v59 = v77;
      memset(v60, 0, sizeof(v60));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v60, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      id v61 = v81;
      long long v55 = *(_OWORD *)v11;
      float v15 = *(long long **)(v11 + 24);
      uint64_t v56 = *(void *)(v11 + 16);
      memset(v57, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v57, v15, *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - (void)v15) >> 3));
      v57[3] = *(void **)(v11 + 48);
      float v16 = *(float *)(((unint64_t)&v58 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v17 = *(float *)(((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v57);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v60);
      unint64_t v14 = v11 + 56;
    }
    while (v16 >= v17);
  }
  else
  {
    float v10 = a1;
    do
    {
      long long v65 = v76;
      uint64_t v66 = v77;
      memset(v67, 0, sizeof(v67));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v67, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      unint64_t v11 = (unint64_t)v10 + 56;
      id v68 = v81;
      long long v62 = *(long long *)((char *)v10 + 56);
      uint64_t v63 = *((void *)v10 + 9);
      memset(v64, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v64, *((long long **)v10 + 10), *((long long **)v10 + 11), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v10 + 11) - *((void *)v10 + 10)) >> 3));
      v64[3] = *((void **)v10 + 13);
      float v12 = *(float *)(((unint64_t)&v65 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v13 = *(float *)(((unint64_t)&v62 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v64);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v67);
      float v10 = (long long *)((char *)v10 + 56);
    }
    while (v12 >= v13);
  }
  if (v11 < a2)
  {
    do
    {
      long long v51 = v76;
      uint64_t v52 = v77;
      memset(v53, 0, sizeof(v53));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      uint64_t v18 = (long long *)(a2 - 56);
      id v54 = v81;
      long long v48 = *(_OWORD *)(a2 - 56);
      uint64_t v49 = *(void *)(a2 - 40);
      memset(v50, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v50, *(long long **)(a2 - 32), *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      v50[3] = *(void **)(a2 - 8);
      float v19 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v20 = *(float *)(((unint64_t)&v48 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v50);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);
      a2 -= 56;
    }
    while (v19 < v20);
    while (v11 < (unint64_t)v18)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v11, v18);
      unint64_t v21 = v11;
      do
      {
        long long v44 = v76;
        uint64_t v45 = v77;
        memset(v46, 0, sizeof(v46));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
        unint64_t v11 = v21 + 56;
        id v47 = v81;
        uint64_t v22 = *(void *)(v21 + 72);
        long long v41 = *(_OWORD *)(v21 + 56);
        uint64_t v42 = v22;
        memset(v43, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, *(long long **)(v21 + 80), *(long long **)(v21 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v21 + 88) - *(void *)(v21 + 80)) >> 3));
        v43[3] = *(void **)(v21 + 104);
        float v23 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v24 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);
        v21 += 56;
      }
      while (v23 >= v24);
      BOOL v25 = v18;
      do
      {
        long long v37 = v76;
        uint64_t v38 = v77;
        memset(v39, 0, sizeof(v39));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
        uint64_t v18 = (long long *)((char *)v25 - 56);
        id v40 = v81;
        uint64_t v26 = *((void *)v25 - 5);
        long long v34 = *(long long *)((char *)v25 - 56);
        uint64_t v35 = v26;
        memset(v36, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v36, *((long long **)v25 - 4), *((long long **)v25 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v25 - 3) - *((void *)v25 - 4)) >> 3));
        v36[3] = *((void **)v25 - 1);
        float v27 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v28 = *(float *)(((unint64_t)&v34 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v36);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);
        BOOL v25 = (long long *)((char *)v25 - 56);
      }
      while (v27 < v28);
    }
  }
  float v29 = (long long *)(v11 - 56);
  if ((long long *)(v11 - 56) != a1)
  {
    long long v30 = *v29;
    *((void *)a1 + 2) = *(void *)(v11 - 40);
    *a1 = v30;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v33, *(void *)(v11 - 32), *(void *)(v11 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 - 24) - *(void *)(v11 - 32)) >> 3));
    objc_storeStrong((id *)a1 + 6, *(id *)(v11 - 8));
  }
  long long v31 = v76;
  *(void *)(v11 - 40) = v77;
  *float v29 = v31;
  if (v29 != &v76) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v11 - 32), (uint64_t)v78, (uint64_t)v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
  }
  objc_storeStrong((id *)(v11 - 8), v81);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v78);
  return v11;
}

void sub_235EB70A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v12);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a12);
  _Unwind_Resume(a1);
}

unint64_t _ZNSt3__132__partition_with_equals_on_rightB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E_EENS_4pairIT0_bEESD_SD_T1_(long long *a1, long long *a2, _DWORD *a3)
{
  unint64_t v5 = (unint64_t)a1;
  long long v67 = *a1;
  uint64_t v6 = (long long *)*((void *)a1 + 3);
  long long v30 = (void **)a1 + 3;
  uint64_t v68 = *((void *)a1 + 2);
  long long v69 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v69, v6, *((long long **)a1 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a1 + 4) - (void)v6) >> 3));
  location = (id *)(v5 + 48);
  id v72 = *(id *)(v5 + 48);
  unint64_t v31 = v5;
  do
  {
    long long v63 = *(_OWORD *)(v5 + 56);
    unint64_t v7 = *(long long **)(v5 + 80);
    uint64_t v64 = *(void *)(v5 + 72);
    memset(v65, 0, sizeof(v65));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v65, v7, *(long long **)(v5 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v5 + 88) - (void)v7) >> 3));
    id v66 = *(id *)(v5 + 104);
    long long v60 = v67;
    uint64_t v61 = v68;
    memset(v62, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v62, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
    v5 += 56;
    v62[3] = v72;
    float v8 = *(float *)(((unint64_t)&v63 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    float v9 = *(float *)(((unint64_t)&v60 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v62);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v65);
  }
  while (v8 < v9);
  if (v5 - 56 == v31)
  {
    do
    {
      if (v5 >= (unint64_t)a2) {
        break;
      }
      long long v56 = *(long long *)((char *)a2 - 56);
      uint64_t v13 = (long long *)*((void *)a2 - 4);
      uint64_t v57 = *((void *)a2 - 5);
      memset(v58, 0, sizeof(v58));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v58, v13, *((long long **)a2 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 - 3) - (void)v13) >> 3));
      id v59 = *((id *)a2 - 1);
      long long v53 = v67;
      uint64_t v54 = v68;
      memset(v55, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
      a2 = (long long *)((char *)a2 - 56);
      v55[3] = v72;
      float v14 = *(float *)(((unint64_t)&v56 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v15 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v58);
    }
    while (v14 >= v15);
  }
  else
  {
    do
    {
      long long v49 = *(long long *)((char *)a2 - 56);
      float v10 = (long long *)*((void *)a2 - 4);
      uint64_t v50 = *((void *)a2 - 5);
      memset(v51, 0, sizeof(v51));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v51, v10, *((long long **)a2 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 - 3) - (void)v10) >> 3));
      id v52 = *((id *)a2 - 1);
      long long v46 = v67;
      uint64_t v47 = v68;
      memset(v48, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
      a2 = (long long *)((char *)a2 - 56);
      v48[3] = v72;
      float v11 = *(float *)(((unint64_t)&v49 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v12 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v51);
    }
    while (v11 >= v12);
  }
  if (v5 >= (unint64_t)a2)
  {
    unint64_t v16 = v5;
    unint64_t v24 = v5 - 56;
    unint64_t v25 = v31;
    if (v5 - 56 == v31) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v16 = v5;
    float v17 = a2;
    do
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v16, v17);
      do
      {
        long long v18 = *(_OWORD *)(v16 + 56);
        uint64_t v43 = *(void *)(v16 + 72);
        long long v42 = v18;
        memset(v44, 0, sizeof(v44));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v44, *(long long **)(v16 + 80), *(long long **)(v16 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v16 + 88) - *(void *)(v16 + 80)) >> 3));
        id v45 = *(id *)(v16 + 104);
        long long v39 = v67;
        uint64_t v40 = v68;
        memset(v41, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
        v16 += 56;
        v41[3] = v72;
        float v19 = *(float *)(((unint64_t)&v42 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v20 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v44);
      }
      while (v19 < v20);
      do
      {
        long long v21 = *(long long *)((char *)v17 - 56);
        uint64_t v36 = *((void *)v17 - 5);
        long long v35 = v21;
        memset(v37, 0, sizeof(v37));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v37, *((long long **)v17 - 4), *((long long **)v17 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v17 - 3) - *((void *)v17 - 4)) >> 3));
        id v38 = *((id *)v17 - 1);
        long long v32 = v67;
        uint64_t v33 = v68;
        memset(v34, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
        float v17 = (long long *)((char *)v17 - 56);
        v34[3] = v72;
        float v22 = *(float *)(((unint64_t)&v35 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v23 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v37);
      }
      while (v22 >= v23);
    }
    while (v16 < (unint64_t)v17);
    unint64_t v24 = v16 - 56;
    unint64_t v25 = v31;
    if (v16 - 56 == v31) {
      goto LABEL_18;
    }
  }
  long long v26 = *(_OWORD *)v24;
  *(void *)(v25 + 16) = *(void *)(v24 + 16);
  *(_OWORD *)unint64_t v25 = v26;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v30, *(void *)(v16 - 32), *(void *)(v16 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v16 - 24) - *(void *)(v16 - 32)) >> 3));
  objc_storeStrong(location, *(id *)(v16 - 8));
LABEL_18:
  long long v27 = v67;
  *(void *)(v24 + 16) = v68;
  *(_OWORD *)unint64_t v24 = v27;
  if ((long long *)v24 != &v67) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v16 - 32), (uint64_t)v69, (uint64_t)v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
  }
  objc_storeStrong((id *)(v16 - 8), v72);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v69);
  return v24;
}

void sub_235EB7744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a11);
  _Unwind_Resume(a1);
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEbT1_SC_T0_(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = a2;
  uint64_t v5 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v51 = *(_OWORD *)(a2 - 56);
      unint64_t v7 = *(long long **)(a2 - 32);
      uint64_t v52 = *(void *)(v3 - 40);
      memset(v53, 0, sizeof(v53));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v7, *(long long **)(v3 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v3 - 24) - (void)v7) >> 3));
      id v54 = *(id *)(v3 - 8);
      long long v48 = *(_OWORD *)a1;
      float v8 = *(long long **)(a1 + 24);
      uint64_t v49 = *(void *)(a1 + 16);
      memset(v50, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v50, v8, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v8) >> 3));
      v50[3] = *(void **)(a1 + 48);
      float v9 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v10 = *(float *)(((unint64_t)&v48 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v50);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);
      if (v9 < v10) {
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)(v3 - 56));
      }
      return 1;
    case 3:
      _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(a1, a1 + 56, a2 - 56, a3);
      return 1;
    case 4:
      _ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_SC_SC_T0_(a1, a1 + 56, a1 + 112, a2 - 56, a3);
      return 1;
    case 5:
      _ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_SC_SC_SC_T0_(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56, a3);
      return 1;
    default:
      uint64_t v11 = a1 + 112;
      _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(a1, a1 + 56, a1 + 112, a3);
      uint64_t v12 = a1 + 168;
      if (a1 + 168 == v3) {
        return 1;
      }
      uint64_t v13 = 0;
      int v26 = 0;
      uint64_t v25 = v3;
      break;
  }
  do
  {
    long long v44 = *(_OWORD *)v12;
    float v14 = *(long long **)(v12 + 24);
    uint64_t v45 = *(void *)(v12 + 16);
    memset(v46, 0, sizeof(v46));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, v14, *(long long **)(v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v12 + 32) - (void)v14) >> 3));
    id v47 = *(id *)(v12 + 48);
    uint64_t v15 = *(void *)(v11 + 16);
    long long v41 = *(_OWORD *)v11;
    uint64_t v42 = v15;
    memset(v43, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, *(long long **)(v11 + 24), *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - *(void *)(v11 + 24)) >> 3));
    v43[3] = *(void **)(v11 + 48);
    float v16 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    float v17 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);
    if (v16 < v17)
    {
      long long v35 = *(_OWORD *)v12;
      long long v18 = *(long long **)(v12 + 24);
      uint64_t v36 = *(void *)(v12 + 16);
      id v38 = 0;
      uint64_t v39 = 0;
      long long v37 = 0;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v37, v18, *(long long **)(v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v12 + 32) - (void)v18) >> 3));
      obuint64_t j = *(id *)(v12 + 48);
      uint64_t v19 = v13;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        *(_OWORD *)(v20 + 168) = *(_OWORD *)(a1 + v19 + 112);
        *(void *)(v20 + 184) = *(void *)(a1 + v19 + 128);
        if (a1 + v19 + 112 != a1 + v19 + 168) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v20 + 192), *(void *)(v20 + 136), *(void *)(v20 + 144), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v20 + 144) - *(void *)(v20 + 136)) >> 3));
        }
        objc_storeStrong((id *)(v20 + 216), *(id *)(v20 + 160));
        if (v19 == -112) {
          break;
        }
        long long v31 = v35;
        uint64_t v32 = v36;
        memset(v33, 0, sizeof(v33));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v33, v37, v38, 0x6DB6DB6DB6DB6DB7 * (((char *)v38 - (char *)v37) >> 3));
        id v34 = obj;
        long long v28 = *(_OWORD *)(a1 + v19 + 56);
        long long v21 = *(long long **)(a1 + v19 + 80);
        uint64_t v29 = *(void *)(a1 + v19 + 72);
        memset(v30, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v30, v21, *(long long **)(a1 + v19 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + v19 + 88) - (void)v21) >> 3));
        v30[3] = *(void **)(a1 + v19 + 104);
        float v22 = *(float *)(((unint64_t)&v31 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v23 = *(float *)(((unint64_t)&v28 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v30);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
        v19 -= 56;
        if (v22 >= v23)
        {
          uint64_t v24 = a1 + v19 + 168;
          goto LABEL_16;
        }
      }
      uint64_t v24 = a1;
LABEL_16:
      *(_OWORD *)uint64_t v24 = v35;
      *(void *)(v24 + 16) = v36;
      uint64_t v3 = v25;
      if ((long long *)v24 != &v35) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v24 + 24), (uint64_t)v37, (uint64_t)v38, 0x6DB6DB6DB6DB6DB7 * (((char *)v38 - (char *)v37) >> 3));
      }
      objc_storeStrong((id *)(v24 + 48), obj);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v37);
      if (++v26 == 8) {
        return v12 + 56 == v25;
      }
    }
    uint64_t v11 = v12;
    v13 += 56;
    v12 += 56;
  }
  while (v12 != v3);
  return 1;
}

void sub_235EB7CFC(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void sub_235EB7D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a12);
  _Unwind_Resume(a1);
}

void **_ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_(long long *a1, long long *a2)
{
  long long v8 = *a1;
  uint64_t v5 = (void **)a1 + 3;
  uint64_t v4 = (long long *)*((void *)a1 + 3);
  uint64_t v9 = *((void *)a1 + 2);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v10, v4, *((long long **)a1 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a1 + 4) - (void)v4) >> 3));
  obuint64_t j = *((id *)a1 + 6);
  uint64_t v6 = *((void *)a2 + 2);
  *a1 = *a2;
  *((void *)a1 + 2) = v6;
  if (a1 != a2) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v5, *((void *)a2 + 3), *((void *)a2 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 + 4) - *((void *)a2 + 3)) >> 3));
  }
  objc_storeStrong((id *)a1 + 6, *((id *)a2 + 6));
  *a2 = v8;
  *((void *)a2 + 2) = v9;
  if (&v8 != a2) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)a2 + 3, v10, v11, 0x6DB6DB6DB6DB6DB7 * ((v11 - v10) >> 3));
  }
  objc_storeStrong((id *)a2 + 6, obj);

  return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v10);
}

void sub_235EB7ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v15);
  _Unwind_Resume(a1);
}

void **_ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEjT1_SC_SC_T0_(a1, a2, a3, a5);
  long long v40 = *(_OWORD *)a4;
  uint64_t v9 = *(long long **)(a4 + 24);
  uint64_t v41 = *(void *)(a4 + 16);
  memset(v42, 0, sizeof(v42));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v42, v9, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v9) >> 3));
  id v43 = *(id *)(a4 + 48);
  long long v37 = *(_OWORD *)a3;
  uint64_t v10 = *(long long **)(a3 + 24);
  uint64_t v38 = *(void *)(a3 + 16);
  memset(v39, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, v10, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v10) >> 3));
  v39[3] = *(void **)(a3 + 48);
  float v11 = *(float *)(((unint64_t)&v40 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
  float v12 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);

  BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v42);
  if (v11 < v12)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a3, (long long *)a4);
    long long v33 = *(_OWORD *)a3;
    float v14 = *(long long **)(a3 + 24);
    uint64_t v34 = *(void *)(a3 + 16);
    memset(v35, 0, sizeof(v35));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, v14, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v14) >> 3));
    id v36 = *(id *)(a3 + 48);
    long long v30 = *(_OWORD *)a2;
    uint64_t v15 = *(long long **)(a2 + 24);
    uint64_t v31 = *(void *)(a2 + 16);
    memset(v32, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v32, v15, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v15) >> 3));
    v32[3] = *(void **)(a2 + 48);
    float v16 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
    float v17 = *(float *)(((unint64_t)&v30 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v32);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);
    if (v16 < v17)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
      long long v26 = *(_OWORD *)a2;
      long long v18 = *(long long **)(a2 + 24);
      uint64_t v27 = *(void *)(a2 + 16);
      memset(v28, 0, sizeof(v28));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v28, v18, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v18) >> 3));
      id v29 = *(id *)(a2 + 48);
      long long v23 = *(_OWORD *)a1;
      uint64_t v19 = *(long long **)(a1 + 24);
      uint64_t v24 = *(void *)(a1 + 16);
      memset(v25, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v19, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v19) >> 3));
      v25[3] = *(void **)(a1 + 48);
      float v20 = *(float *)(((unint64_t)&v26 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
      float v21 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v28);
      if (v20 < v21) {
        return _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
      }
    }
  }
  return result;
}

void sub_235EB81AC(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void **_ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_SC_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  _ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_SC_SC_T0_(a1, a2, a3, a4, a6);
  long long v53 = *(_OWORD *)a5;
  uint64_t v10 = *(long long **)(a5 + 24);
  uint64_t v54 = *(void *)(a5 + 16);
  memset(v55, 0, sizeof(v55));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v10, *(long long **)(a5 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a5 + 32) - (void)v10) >> 3));
  id v56 = *(id *)(a5 + 48);
  long long v50 = *(_OWORD *)a4;
  float v11 = *(long long **)(a4 + 24);
  uint64_t v51 = *(void *)(a4 + 16);
  memset(v52, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v52, v11, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v11) >> 3));
  v52[3] = *(void **)(a4 + 48);
  float v12 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
  float v13 = *(float *)(((unint64_t)&v50 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v52);

  BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);
  if (v12 < v13)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a4, (long long *)a5);
    long long v46 = *(_OWORD *)a4;
    uint64_t v15 = *(long long **)(a4 + 24);
    uint64_t v47 = *(void *)(a4 + 16);
    memset(v48, 0, sizeof(v48));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v15, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v15) >> 3));
    id v49 = *(id *)(a4 + 48);
    long long v43 = *(_OWORD *)a3;
    float v16 = *(long long **)(a3 + 24);
    uint64_t v44 = *(void *)(a3 + 16);
    memset(v45, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v45, v16, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v16) >> 3));
    v45[3] = *(void **)(a3 + 48);
    float v17 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
    float v18 = *(float *)(((unint64_t)&v43 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v45);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);
    if (v17 < v18)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a3, (long long *)a4);
      long long v39 = *(_OWORD *)a3;
      uint64_t v19 = *(long long **)(a3 + 24);
      uint64_t v40 = *(void *)(a3 + 16);
      memset(v41, 0, sizeof(v41));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v19, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v19) >> 3));
      id v42 = *(id *)(a3 + 48);
      long long v36 = *(_OWORD *)a2;
      float v20 = *(long long **)(a2 + 24);
      uint64_t v37 = *(void *)(a2 + 16);
      memset(v38, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, v20, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v20) >> 3));
      v38[3] = *(void **)(a2 + 48);
      float v21 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
      float v22 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);
      if (v21 < v22)
      {
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
        long long v32 = *(_OWORD *)a2;
        long long v23 = *(long long **)(a2 + 24);
        uint64_t v33 = *(void *)(a2 + 16);
        memset(v34, 0, sizeof(v34));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v23, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v23) >> 3));
        id v35 = *(id *)(a2 + 48);
        long long v29 = *(_OWORD *)a1;
        uint64_t v24 = *(long long **)(a1 + 24);
        uint64_t v30 = *(void *)(a1 + 16);
        memset(v31, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v31, v24, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v24) >> 3));
        v31[3] = *(void **)(a1 + 48);
        float v25 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
        float v26 = *(float *)(((unint64_t)&v29 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v31);

        BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);
        if (v25 < v26) {
          return _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
        }
      }
    }
  }
  return result;
}

void sub_235EB8570(_Unwind_Exception *a1)
{
  uint64_t v3 = v1;

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v2);
  _Unwind_Resume(a1);
}

void **_ZNSt3__111__sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_OT0_NS_15iterator_traitsISC_E15difference_typeESC_(void **result, _DWORD *a2, uint64_t a3, char *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v5 = (void **)a4;
    int64_t v28 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= 0x6DB6DB6DB6DB6DB7 * ((a4 - (char *)result) >> 3))
    {
      int64_t v6 = (0xDB6DB6DB6DB6DB6ELL * ((a4 - (char *)result) >> 3)) | 1;
      unint64_t v7 = &result[2 * ((a4 - (char *)result) >> 3)];
      long long v8 = v7 + 7;
      int64_t v9 = 0xDB6DB6DB6DB6DB6ELL * ((a4 - (char *)result) >> 3) + 2;
      uint64_t v27 = result;
      if (v9 < a3)
      {
        long long v61 = *(_OWORD *)v8;
        long long v62 = v7[9];
        memset(v63, 0, sizeof(v63));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v63, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
        id v64 = v7[13];
        long long v58 = *((_OWORD *)v7 + 7);
        id v59 = v7[16];
        memset(v60, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v60, (long long *)v7[17], (long long *)v7[18], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[18] - (unsigned char *)v7[17]) >> 3));
        v60[3] = v7[20];
        float v10 = *(float *)(((unint64_t)&v61 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
        float v11 = *(float *)(((unint64_t)&v58 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v60);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v63);
        if (v10 < v11)
        {
          long long v8 = v7 + 14;
          int64_t v6 = v9;
        }
      }
      long long v54 = *(_OWORD *)v8;
      float v12 = (long long *)v8[3];
      long long v55 = v8[2];
      memset(v56, 0, sizeof(v56));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v56, v12, (long long *)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v12) >> 3));
      id v57 = v8[6];
      long long v51 = *(_OWORD *)v5;
      float v13 = (long long *)v5[3];
      uint64_t v52 = v5[2];
      memset(v53, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v13, (long long *)v5[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v5[4] - (unsigned char *)v13) >> 3));
      v53[3] = v5[6];
      float v14 = *(float *)(((unint64_t)&v54 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      float v15 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v56);
      if (v14 >= v15)
      {
        long long v45 = *(_OWORD *)v5;
        float v16 = (long long *)v5[3];
        long long v46 = v5[2];
        uint64_t v47 = 0;
        long long v48 = 0;
        uint64_t v49 = 0;
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v47, v16, (long long *)v5[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v5[4] - (unsigned char *)v16) >> 3));
        obuint64_t j = v5[6];
        do
        {
          float v17 = v8;
          long long v18 = *(_OWORD *)v8;
          v5[2] = v8[2];
          *(_OWORD *)uint64_t v5 = v18;
          if (v5 != v8) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v5 + 3, (uint64_t)v8[3], (uint64_t)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v8[3]) >> 3));
          }
          objc_storeStrong(v5 + 6, v8[6]);
          if (v28 < v6) {
            break;
          }
          uint64_t v19 = (2 * v6) | 1;
          float v20 = &v27[14 * v6];
          long long v8 = v20 + 7;
          int64_t v6 = 2 * v6 + 2;
          if (v6 >= a3)
          {
            int64_t v6 = v19;
          }
          else
          {
            long long v41 = *(_OWORD *)v8;
            id v42 = v20[9];
            memset(v43, 0, sizeof(v43));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, (long long *)v20[10], (long long *)v20[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v20[11] - (unsigned char *)v20[10]) >> 3));
            id v44 = v20[13];
            long long v38 = *((_OWORD *)v20 + 7);
            long long v39 = v20[16];
            memset(v40, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v40, (long long *)v20[17], (long long *)v20[18], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v20[18] - (unsigned char *)v20[17]) >> 3));
            v40[3] = v20[20];
            float v21 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
            float v22 = *(float *)(((unint64_t)&v38 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v40);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);
            if (v21 >= v22) {
              int64_t v6 = v19;
            }
            else {
              long long v8 = v20 + 14;
            }
          }
          long long v34 = *(_OWORD *)v8;
          long long v23 = (long long *)v8[3];
          id v35 = v8[2];
          memset(v36, 0, sizeof(v36));
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v36, v23, (long long *)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v23) >> 3));
          id v37 = v8[6];
          long long v31 = v45;
          long long v32 = v46;
          memset(v33, 0, 24);
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v33, v47, v48, 0x6DB6DB6DB6DB6DB7 * (((char *)v48 - (char *)v47) >> 3));
          v33[3] = obj;
          float v24 = *(float *)(((unint64_t)&v34 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
          float v25 = *(float *)(((unint64_t)&v31 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);

          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v36);
          uint64_t v5 = v17;
        }
        while (v24 >= v25);
        long long v26 = v45;
        v17[2] = v46;
        *(_OWORD *)float v17 = v26;
        if (v17 != (void **)&v45) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v17 + 3, (uint64_t)v47, (uint64_t)v48, 0x6DB6DB6DB6DB6DB7 * (((char *)v48 - (char *)v47) >> 3));
        }
        objc_storeStrong(v17 + 6, obj);

        return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v47);
      }
    }
  }
  return result;
}

void sub_235EB8AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

void **_ZNSt3__110__pop_heapB8ne180100INS_17_ClassicAlgPolicyEZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SB_RT0_NS_15iterator_traitsISB_E15difference_typeE(void **result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v7 = result;
    long long v17 = *(_OWORD *)result;
    long long v8 = (long long *)result[3];
    long long v18 = result[2];
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v19, v8, (long long *)result[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)result[4] - (unsigned char *)v8) >> 3));
    obuint64_t j = v7[6];
    int64_t v9 = _ZNSt3__117__floyd_sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EET1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE((long long *)v7, a3, a4);
    float v10 = v9;
    uint64_t v11 = a2 - 56;
    if (v9 == (long long *)(a2 - 56))
    {
      long long v16 = v17;
      *((void *)v9 + 2) = v18;
      *int64_t v9 = v16;
      if (v9 != &v17) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v9 + 3, v19, v20, 0x6DB6DB6DB6DB6DB7 * ((v20 - v19) >> 3));
      }
      objc_storeStrong((id *)v10 + 6, obj);
    }
    else
    {
      long long v12 = *(_OWORD *)v11;
      *((void *)v9 + 2) = *(void *)(a2 - 40);
      *int64_t v9 = v12;
      float v13 = (void **)(a2 - 32);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v9 + 3, *(void *)(a2 - 32), *(void *)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      float v15 = *(void **)(a2 - 8);
      float v14 = (id *)(a2 - 8);
      objc_storeStrong((id *)v10 + 6, v15);
      *(_OWORD *)uint64_t v11 = v17;
      *(void *)(v11 + 16) = v18;
      if ((long long *)v11 != &v17) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v13, v19, v20, 0x6DB6DB6DB6DB6DB7 * ((v20 - v19) >> 3));
      }
      objc_storeStrong(v14, obj);
      _ZNSt3__19__sift_upB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(v7, (uint64_t)v10 + 56, a3, 0x6DB6DB6DB6DB6DB7 * (((char *)v10 + 56 - (char *)v7) >> 3));
    }

    return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v19);
  }
  return result;
}

void sub_235EB8D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v15);
  _Unwind_Resume(a1);
}

long long *_ZNSt3__117__floyd_sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EET1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(long long *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = a3 - 2;
  if (a3 < 2) {
    uint64_t v6 = a3 - 1;
  }
  uint64_t v7 = v6 >> 1;
  do
  {
    uint64_t v8 = (uint64_t)a1 + 56 * v5;
    int64_t v9 = (long long *)(v8 + 56);
    uint64_t v10 = 2 * v5;
    uint64_t v5 = (2 * v5) | 1;
    uint64_t v11 = v10 + 2;
    if (v10 + 2 < a3)
    {
      long long v12 = *v9;
      uint64_t v23 = *(void *)(v8 + 72);
      long long v22 = v12;
      memset(v24, 0, sizeof(v24));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v24, *(long long **)(v8 + 80), *(long long **)(v8 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v8 + 88) - *(void *)(v8 + 80)) >> 3));
      id v25 = *(id *)(v8 + 104);
      uint64_t v13 = *(void *)(v8 + 128);
      long long v19 = *(_OWORD *)(v8 + 112);
      uint64_t v20 = v13;
      memset(v21, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v21, *(long long **)(v8 + 136), *(long long **)(v8 + 144), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v8 + 144) - *(void *)(v8 + 136)) >> 3));
      v21[3] = *(void **)(v8 + 160);
      float v14 = *(float *)(((unint64_t)&v22 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      float v15 = *(float *)(((unint64_t)&v19 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v21);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v24);
      if (v14 < v15)
      {
        int64_t v9 = (long long *)(v8 + 112);
        uint64_t v5 = v11;
      }
    }
    long long v16 = *v9;
    *((void *)a1 + 2) = *((void *)v9 + 2);
    *a1 = v16;
    if (a1 != v9) {
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)a1 + 3, *((void *)v9 + 3), *((void *)v9 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v9 + 4) - *((void *)v9 + 3)) >> 3));
    }
    objc_storeStrong((id *)a1 + 6, *((id *)v9 + 6));
    a1 = v9;
  }
  while (v5 <= v7);
  return v9;
}

void sub_235EB8F0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
  _Unwind_Resume(a1);
}

void **_ZNSt3__19__sift_upB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E_PS5_EEvT1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(void **result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v7 = result;
    unint64_t v8 = v4 >> 1;
    int64_t v9 = &result[7 * (v4 >> 1)];
    long long v36 = *(_OWORD *)v9;
    uint64_t v10 = (long long *)v9[3];
    id v37 = v9[2];
    memset(v38, 0, sizeof(v38));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, v10, (long long *)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v10) >> 3));
    id v39 = v9[6];
    long long v33 = *(_OWORD *)(a2 - 56);
    uint64_t v11 = *(long long **)(a2 - 32);
    uint64_t v34 = *(void *)(a2 - 40);
    memset(v35, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, v11, *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - (void)v11) >> 3));
    v35[3] = *(void **)(a2 - 8);
    float v12 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    float v13 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
    if (v12 < v13)
    {
      float v14 = (void **)(a2 - 56);
      long long v27 = *(_OWORD *)(a2 - 56);
      int64_t v28 = *(void **)(a2 - 40);
      long long v29 = 0;
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, *(long long **)(a2 - 32), *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      obuint64_t j = *(id *)(a2 - 8);
      do
      {
        float v15 = v9;
        long long v16 = *(_OWORD *)v9;
        v14[2] = v9[2];
        *(_OWORD *)float v14 = v16;
        if (v14 != v9) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v14 + 3, (uint64_t)v9[3], (uint64_t)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v9[3]) >> 3));
        }
        objc_storeStrong(v14 + 6, v9[6]);
        if (!v8) {
          break;
        }
        unint64_t v8 = (v8 - 1) >> 1;
        int64_t v9 = &v7[7 * v8];
        long long v23 = *(_OWORD *)v9;
        long long v17 = (long long *)v9[3];
        float v24 = v9[2];
        memset(v25, 0, sizeof(v25));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v17, (long long *)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v17) >> 3));
        id v26 = v9[6];
        long long v20 = v27;
        uint64_t v21 = v28;
        memset(v22, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
        v22[3] = obj;
        float v18 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v19 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
        float v14 = v15;
      }
      while (v18 < v19);
      *(_OWORD *)float v15 = v27;
      v15[2] = v28;
      if (v15 != (void **)&v27) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v15 + 3, (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
      }
      objc_storeStrong(v15 + 6, obj);

      return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
    }
  }
  return result;
}

void sub_235EB9220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(uint64_t result, void **a2, _DWORD *a3, uint64_t a4, char a5)
{
  uint64_t v10 = result;
  while (2)
  {
    long long v36 = (long long *)(a2 - 7);
    uint64_t v11 = v10;
LABEL_3:
    uint64_t v12 = a4 - 1;
    while (1)
    {
      uint64_t v10 = v11;
      a4 = v12;
      uint64_t v13 = (uint64_t)a2 - v11;
      unint64_t v14 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)a2 - v11) >> 3);
      if (!(!v6 & v5))
      {
        switch(v14)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t v26 = (uint64_t)*(a2 - 5);
            long long v47 = *v36;
            uint64_t v48 = v26;
            memset(v49, 0, sizeof(v49));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v49, (long long *)*(a2 - 4), (long long *)*(a2 - 3), 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)*(a2 - 3) - (unsigned char *)*(a2 - 4)) >> 3));
            id v50 = *(a2 - 1);
            uint64_t v27 = *(void *)(v11 + 16);
            long long v44 = *(_OWORD *)v11;
            uint64_t v45 = v27;
            memset(v46, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, *(long long **)(v11 + 24), *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - *(void *)(v11 + 24)) >> 3));
            v46[3] = *(void **)(v11 + 48);
            float v28 = *(float *)(((unint64_t)&v47 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
            float v29 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);

            BOOL result = (uint64_t)_ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v49);
            if (v28 > v29) {
              BOOL result = (uint64_t)_ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v11, v36);
            }
            break;
          case 3uLL:
            BOOL result = _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(v11, v11 + 56, (uint64_t)v36, a3);
            break;
          case 4uLL:
            BOOL result = (uint64_t)_ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_SC_SC_T0_(v11, v11 + 56, v11 + 112, (uint64_t)v36, a3);
            break;
          case 5uLL:
            BOOL result = (uint64_t)_ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_SC_SC_SC_T0_(v11, v11 + 56, v11 + 112, v11 + 168, (uint64_t)v36, a3);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v13 <= 1343)
      {
        if (a5) {
          return (uint64_t)_ZNSt3__116__insertion_sortB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_T0_((void **)v11, a2, a3);
        }
        else {
          return (uint64_t)_ZNSt3__126__insertion_sort_unguardedB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_T0_((void **)v11, a2, a3);
        }
      }
      if (v12 == -1)
      {
        if ((void **)v11 != a2)
        {
          unint64_t v30 = (v14 - 2) >> 1;
          unint64_t v31 = v30 + 1;
          long long v32 = (char *)(v11 + 56 * v30);
          do
          {
            _ZNSt3__111__sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_OT0_NS_15iterator_traitsISC_E15difference_typeESC_((void **)v10, a3, v14, v32);
            v32 -= 56;
            --v31;
          }
          while (v31);
          unint64_t v33 = v13 / 0x38uLL;
          do
          {
            BOOL result = (uint64_t)_ZNSt3__110__pop_heapB8ne180100INS_17_ClassicAlgPolicyEZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SB_RT0_NS_15iterator_traitsISB_E15difference_typeE((void **)v10, (uint64_t)a2, a3, v33);
            a2 -= 7;
          }
          while (v33-- > 2);
        }
        return result;
      }
      unint64_t v15 = v14 >> 1;
      long long v16 = (long long *)(v11 + 56 * v15);
      if ((unint64_t)v13 >= 0x1C01)
      {
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(v10, v10 + 56 * v15, (uint64_t)v36, a3);
        uint64_t v17 = v10 + 56 * v15;
        uint64_t v18 = v17 - 56;
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(v10 + 56, v17 - 56, (uint64_t)(a2 - 14), a3);
        v17 += 56;
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(v10 + 112, v17, (uint64_t)(a2 - 21), a3);
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(v18, (uint64_t)v16, v17, a3);
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v10, v16);
        if (a5) {
          goto LABEL_14;
        }
      }
      else
      {
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(v10 + 56 * v15, v10, (uint64_t)v36, a3);
        if (a5) {
          goto LABEL_14;
        }
      }
      long long v19 = *(_OWORD *)(v10 - 56);
      uint64_t v41 = *(void *)(v10 - 40);
      long long v40 = v19;
      memset(v42, 0, sizeof(v42));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v42, *(long long **)(v10 - 32), *(long long **)(v10 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v10 - 24) - *(void *)(v10 - 32)) >> 3));
      id v43 = *(id *)(v10 - 8);
      uint64_t v20 = *(void *)(v10 + 16);
      long long v37 = *(_OWORD *)v10;
      uint64_t v38 = v20;
      memset(v39, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, *(long long **)(v10 + 24), *(long long **)(v10 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v10 + 32) - *(void *)(v10 + 24)) >> 3));
      v39[3] = *(void **)(v10 + 48);
      float v21 = *(float *)(((unint64_t)&v40 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      float v22 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v42);
      if (v21 <= v22)
      {
        BOOL result = _ZNSt3__131__partition_with_equals_on_leftB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E0_EET0_SC_SC_T1_((long long *)v10, (unint64_t)a2, a3);
        uint64_t v11 = result;
        a5 = 0;
        goto LABEL_3;
      }
LABEL_14:
      unint64_t v23 = _ZNSt3__132__partition_with_equals_on_rightB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E0_EENS_4pairIT0_bEESD_SD_T1_((long long *)v10, (long long *)a2, a3);
      if ((v24 & 1) == 0) {
        goto LABEL_17;
      }
      BOOL v25 = _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEbT1_SC_T0_(v10, v23, a3);
      uint64_t v11 = v23 + 56;
      BOOL result = _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEbT1_SC_T0_(v23 + 56, (uint64_t)a2, a3);
      if (result) {
        break;
      }
      uint64_t v12 = a4 - 1;
      if (!v25)
      {
LABEL_17:
        BOOL result = _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v10, v23, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v11 = v23 + 56;
        goto LABEL_3;
      }
    }
    a2 = (void **)v23;
    if (!v25) {
      continue;
    }
    return result;
  }
}

void sub_235EB977C(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void **_ZNSt3__116__insertion_sortB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_T0_(void **result, void **a2, _DWORD *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    unint64_t v4 = result + 7;
    if (result + 7 != a2)
    {
      uint64_t v6 = 0;
      uint64_t v7 = result;
      do
      {
        unint64_t v8 = v4;
        long long v36 = *(_OWORD *)v4;
        long long v37 = v4[2];
        memset(v38, 0, sizeof(v38));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
        id v39 = v7[13];
        int64_t v9 = v7[2];
        long long v33 = *(_OWORD *)v7;
        uint64_t v34 = v9;
        memset(v35, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, (long long *)v7[3], (long long *)v7[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[4] - (unsigned char *)v7[3]) >> 3));
        v35[3] = v7[6];
        float v10 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v11 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

        BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
        if (v10 > v11)
        {
          long long v27 = *(_OWORD *)v8;
          float v28 = v8[2];
          unint64_t v30 = 0;
          uint64_t v31 = 0;
          float v29 = 0;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
          obuint64_t j = v7[13];
          uint64_t v12 = v6;
          while (1)
          {
            uint64_t v13 = (char *)v3 + v12;
            *(_OWORD *)(v13 + 56) = *(_OWORD *)((char *)v3 + v12);
            uint64_t v14 = *(uint64_t *)((char *)v3 + v12 + 24);
            *((void *)v13 + 9) = *(void **)((char *)v3 + v12 + 16);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)((char *)v3 + v12 + 80), v14, *(uint64_t *)((char *)v3 + v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((*(uint64_t *)((char *)v3 + v12 + 32) - v14) >> 3));
            objc_storeStrong((id *)v13 + 13, *((id *)v13 + 6));
            if (!v12) {
              break;
            }
            long long v23 = v27;
            char v24 = v28;
            memset(v25, 0, sizeof(v25));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
            id v26 = obj;
            long long v20 = *(_OWORD *)((char *)v3 + v12 - 56);
            unint64_t v15 = *(long long **)((char *)v3 + v12 - 32);
            uint64_t v21 = *(uint64_t *)((char *)v3 + v12 - 40);
            memset(v22, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v15, *(long long **)((char *)v3 + v12 - 24), 0x6DB6DB6DB6DB6DB7 * ((*(unsigned char **)((char *)v3 + v12 - 24) - (unsigned char *)v15) >> 3));
            v22[3] = *(void **)((char *)v3 + v12 - 8);
            float v16 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
            float v17 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
            v12 -= 56;
            if (v16 <= v17)
            {
              uint64_t v18 = (uint64_t)v3 + v12 + 56;
              goto LABEL_12;
            }
          }
          uint64_t v18 = (uint64_t)v3;
LABEL_12:
          *(_OWORD *)uint64_t v18 = v27;
          *(void *)(v18 + 16) = v28;
          if ((long long *)v18 != &v27) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v18 + 24), (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
          }
          objc_storeStrong((id *)(v18 + 48), obj);

          BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
        }
        unint64_t v4 = v8 + 7;
        v6 += 56;
        uint64_t v7 = v8;
      }
      while (v8 + 7 != a2);
    }
  }
  return result;
}

void sub_235EB9AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

void **_ZNSt3__126__insertion_sort_unguardedB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_T0_(void **result, void **a2, _DWORD *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    unint64_t v4 = result + 7;
    if (result + 7 != a2)
    {
      uint64_t v6 = result + 13;
      do
      {
        uint64_t v7 = v4;
        long long v36 = *(_OWORD *)v4;
        long long v37 = v4[2];
        memset(v38, 0, sizeof(v38));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, (long long *)v3[10], (long long *)v3[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[11] - (unsigned char *)v3[10]) >> 3));
        id v39 = v3[13];
        unint64_t v8 = v3[2];
        long long v33 = *(_OWORD *)v3;
        uint64_t v34 = v8;
        memset(v35, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, (long long *)v3[3], (long long *)v3[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[4] - (unsigned char *)v3[3]) >> 3));
        v35[3] = v3[6];
        float v9 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v10 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

        BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
        if (v9 > v10)
        {
          long long v27 = *(_OWORD *)v7;
          float v28 = v7[2];
          unint64_t v30 = 0;
          uint64_t v31 = 0;
          float v29 = 0;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, (long long *)v3[10], (long long *)v3[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[11] - (unsigned char *)v3[10]) >> 3));
          obuint64_t j = v3[13];
          float v11 = v6;
          do
          {
            uint64_t v12 = v11;
            *((_OWORD *)v11 - 3) = *(_OWORD *)(v11 - 13);
            uint64_t v13 = (uint64_t)*(v11 - 10);
            uint64_t v14 = (uint64_t)*(v11 - 9);
            *(v11 - 4) = *(v11 - 11);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v11 - 3, v13, v14, 0x6DB6DB6DB6DB6DB7 * ((v14 - v13) >> 3));
            objc_storeStrong(v12, *(v12 - 7));
            long long v23 = v27;
            char v24 = v28;
            memset(v25, 0, sizeof(v25));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
            id v26 = obj;
            long long v20 = *((_OWORD *)v12 - 10);
            unint64_t v15 = (long long *)*(v12 - 17);
            uint64_t v21 = (uint64_t)*(v12 - 18);
            memset(v22, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v15, (long long *)*(v12 - 16), 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)*(v12 - 16) - (unsigned char *)v15) >> 3));
            v22[3] = *(v12 - 14);
            float v16 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
            float v17 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
            float v11 = v12 - 7;
          }
          while (v16 > v17);
          *(_OWORD *)(v12 - 13) = v27;
          uint64_t v18 = v12 - 13;
          v18[2] = v28;
          if (v18 != (id *)&v27) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v18 + 3, (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
          }
          objc_storeStrong(v18 + 6, obj);

          BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
        }
        unint64_t v4 = v7 + 7;
        v6 += 7;
        uint64_t v3 = v7;
      }
      while (v7 + 7 != a2);
    }
  }
  return result;
}

void sub_235EB9E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  long long v63 = *(_OWORD *)a2;
  uint64_t v9 = *(void *)(a2 + 16);
  unint64_t v8 = *(long long **)(a2 + 24);
  uint64_t v64 = v9;
  memset(v65, 0, sizeof(v65));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v65, v8, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v8) >> 3));
  id v66 = *(id *)(a2 + 48);
  long long v60 = *(_OWORD *)a1;
  float v10 = *(long long **)(a1 + 24);
  uint64_t v61 = *(void *)(a1 + 16);
  memset(v62, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v62, v10, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v10) >> 3));
  v62[3] = *(void **)(a1 + 48);
  float v11 = *(float *)(((unint64_t)&v63 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
  float v12 = *(float *)(((unint64_t)&v60 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v62);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v65);
  if (v11 > v12)
  {
    long long v42 = *(_OWORD *)a3;
    uint64_t v13 = *(long long **)(a3 + 24);
    uint64_t v43 = *(void *)(a3 + 16);
    memset(v44, 0, sizeof(v44));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v44, v13, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v13) >> 3));
    id v45 = *(id *)(a3 + 48);
    long long v39 = *(_OWORD *)a2;
    uint64_t v14 = *(long long **)(a2 + 24);
    uint64_t v40 = *(void *)(a2 + 16);
    memset(v41, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v14, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v14) >> 3));
    v41[3] = *(void **)(a2 + 48);
    float v15 = *(float *)(((unint64_t)&v42 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
    float v16 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v44);
    if (v15 > v16)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a3);
      return 1;
    }
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
    long long v35 = *(_OWORD *)a3;
    long long v27 = *(long long **)(a3 + 24);
    uint64_t v36 = *(void *)(a3 + 16);
    memset(v37, 0, sizeof(v37));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v37, v27, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v27) >> 3));
    id v38 = *(id *)(a3 + 48);
    long long v32 = *(_OWORD *)a2;
    float v28 = *(long long **)(a2 + 24);
    uint64_t v33 = *(void *)(a2 + 16);
    memset(v34, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v28, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v28) >> 3));
    v34[3] = *(void **)(a2 + 48);
    float v29 = *(float *)(((unint64_t)&v35 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
    float v30 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v37);
    if (v29 <= v30) {
      return 1;
    }
    BOOL v25 = (long long *)a2;
    id v26 = (long long *)a3;
LABEL_9:
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_(v25, v26);
    return 2;
  }
  long long v56 = *(_OWORD *)a3;
  float v17 = *(long long **)(a3 + 24);
  uint64_t v57 = *(void *)(a3 + 16);
  memset(v58, 0, sizeof(v58));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v58, v17, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v17) >> 3));
  id v59 = *(id *)(a3 + 48);
  long long v53 = *(_OWORD *)a2;
  uint64_t v18 = *(long long **)(a2 + 24);
  uint64_t v54 = *(void *)(a2 + 16);
  memset(v55, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v18, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v18) >> 3));
  v55[3] = *(void **)(a2 + 48);
  float v19 = *(float *)(((unint64_t)&v56 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
  float v20 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v58);
  if (v19 > v20)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
    long long v49 = *(_OWORD *)a2;
    uint64_t v21 = *(long long **)(a2 + 24);
    uint64_t v50 = *(void *)(a2 + 16);
    memset(v51, 0, sizeof(v51));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v51, v21, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v21) >> 3));
    id v52 = *(id *)(a2 + 48);
    long long v46 = *(_OWORD *)a1;
    float v22 = *(long long **)(a1 + 24);
    uint64_t v47 = *(void *)(a1 + 16);
    memset(v48, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v22, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v22) >> 3));
    v48[3] = *(void **)(a1 + 48);
    float v23 = *(float *)(((unint64_t)&v49 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
    float v24 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v51);
    if (v23 <= v24) {
      return 1;
    }
    BOOL v25 = (long long *)a1;
    id v26 = (long long *)a2;
    goto LABEL_9;
  }
  return 0;
}

void sub_235EBA314(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

unint64_t _ZNSt3__131__partition_with_equals_on_leftB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E0_EET0_SC_SC_T1_(long long *a1, unint64_t a2, _DWORD *a3)
{
  long long v76 = *a1;
  uint64_t v6 = (long long *)*((void *)a1 + 3);
  uint64_t v33 = (void **)a1 + 3;
  uint64_t v77 = *((void *)a1 + 2);
  float v78 = 0;
  v79 = 0;
  uint64_t v80 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v78, v6, *((long long **)a1 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a1 + 4) - (void)v6) >> 3));
  id v81 = *((id *)a1 + 6);
  long long v72 = v76;
  uint64_t v73 = v77;
  memset(v74, 0, sizeof(v74));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v74, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
  id v75 = v81;
  long long v69 = *(_OWORD *)(a2 - 56);
  uint64_t v7 = *(long long **)(a2 - 32);
  uint64_t v70 = *(void *)(a2 - 40);
  memset(v71, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v71, v7, *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - (void)v7) >> 3));
  v71[3] = *(void **)(a2 - 8);
  float v8 = *(float *)(((unint64_t)&v72 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
  float v9 = *(float *)(((unint64_t)&v69 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v71);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v74);
  if (v8 <= v9)
  {
    unint64_t v14 = (unint64_t)a1 + 56;
    do
    {
      unint64_t v11 = v14;
      if (v14 >= a2) {
        break;
      }
      long long v58 = v76;
      uint64_t v59 = v77;
      memset(v60, 0, sizeof(v60));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v60, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      id v61 = v81;
      long long v55 = *(_OWORD *)v11;
      float v15 = *(long long **)(v11 + 24);
      uint64_t v56 = *(void *)(v11 + 16);
      memset(v57, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v57, v15, *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - (void)v15) >> 3));
      v57[3] = *(void **)(v11 + 48);
      float v16 = *(float *)(((unint64_t)&v58 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      float v17 = *(float *)(((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v57);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v60);
      unint64_t v14 = v11 + 56;
    }
    while (v16 <= v17);
  }
  else
  {
    float v10 = a1;
    do
    {
      long long v65 = v76;
      uint64_t v66 = v77;
      memset(v67, 0, sizeof(v67));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v67, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      unint64_t v11 = (unint64_t)v10 + 56;
      id v68 = v81;
      long long v62 = *(long long *)((char *)v10 + 56);
      uint64_t v63 = *((void *)v10 + 9);
      memset(v64, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v64, *((long long **)v10 + 10), *((long long **)v10 + 11), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v10 + 11) - *((void *)v10 + 10)) >> 3));
      v64[3] = *((void **)v10 + 13);
      float v12 = *(float *)(((unint64_t)&v65 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      float v13 = *(float *)(((unint64_t)&v62 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v64);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v67);
      float v10 = (long long *)((char *)v10 + 56);
    }
    while (v12 <= v13);
  }
  if (v11 < a2)
  {
    do
    {
      long long v51 = v76;
      uint64_t v52 = v77;
      memset(v53, 0, sizeof(v53));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      uint64_t v18 = (long long *)(a2 - 56);
      id v54 = v81;
      long long v48 = *(_OWORD *)(a2 - 56);
      uint64_t v49 = *(void *)(a2 - 40);
      memset(v50, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v50, *(long long **)(a2 - 32), *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      v50[3] = *(void **)(a2 - 8);
      float v19 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      float v20 = *(float *)(((unint64_t)&v48 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v50);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);
      a2 -= 56;
    }
    while (v19 > v20);
    while (v11 < (unint64_t)v18)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v11, v18);
      unint64_t v21 = v11;
      do
      {
        long long v44 = v76;
        uint64_t v45 = v77;
        memset(v46, 0, sizeof(v46));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
        unint64_t v11 = v21 + 56;
        id v47 = v81;
        uint64_t v22 = *(void *)(v21 + 72);
        long long v41 = *(_OWORD *)(v21 + 56);
        uint64_t v42 = v22;
        memset(v43, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, *(long long **)(v21 + 80), *(long long **)(v21 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v21 + 88) - *(void *)(v21 + 80)) >> 3));
        v43[3] = *(void **)(v21 + 104);
        float v23 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v24 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);
        v21 += 56;
      }
      while (v23 <= v24);
      BOOL v25 = v18;
      do
      {
        long long v37 = v76;
        uint64_t v38 = v77;
        memset(v39, 0, sizeof(v39));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
        uint64_t v18 = (long long *)((char *)v25 - 56);
        id v40 = v81;
        uint64_t v26 = *((void *)v25 - 5);
        long long v34 = *(long long *)((char *)v25 - 56);
        uint64_t v35 = v26;
        memset(v36, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v36, *((long long **)v25 - 4), *((long long **)v25 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v25 - 3) - *((void *)v25 - 4)) >> 3));
        v36[3] = *((void **)v25 - 1);
        float v27 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v28 = *(float *)(((unint64_t)&v34 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v36);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);
        BOOL v25 = (long long *)((char *)v25 - 56);
      }
      while (v27 > v28);
    }
  }
  float v29 = (long long *)(v11 - 56);
  if ((long long *)(v11 - 56) != a1)
  {
    long long v30 = *v29;
    *((void *)a1 + 2) = *(void *)(v11 - 40);
    *a1 = v30;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v33, *(void *)(v11 - 32), *(void *)(v11 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 - 24) - *(void *)(v11 - 32)) >> 3));
    objc_storeStrong((id *)a1 + 6, *(id *)(v11 - 8));
  }
  long long v31 = v76;
  *(void *)(v11 - 40) = v77;
  *float v29 = v31;
  if (v29 != &v76) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v11 - 32), (uint64_t)v78, (uint64_t)v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
  }
  objc_storeStrong((id *)(v11 - 8), v81);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v78);
  return v11;
}

void sub_235EBA9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v12);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a12);
  _Unwind_Resume(a1);
}

unint64_t _ZNSt3__132__partition_with_equals_on_rightB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E0_EENS_4pairIT0_bEESD_SD_T1_(long long *a1, long long *a2, _DWORD *a3)
{
  unint64_t v5 = (unint64_t)a1;
  long long v67 = *a1;
  uint64_t v6 = (long long *)*((void *)a1 + 3);
  long long v30 = (void **)a1 + 3;
  uint64_t v68 = *((void *)a1 + 2);
  long long v69 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v69, v6, *((long long **)a1 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a1 + 4) - (void)v6) >> 3));
  location = (id *)(v5 + 48);
  id v72 = *(id *)(v5 + 48);
  unint64_t v31 = v5;
  do
  {
    long long v63 = *(_OWORD *)(v5 + 56);
    uint64_t v7 = *(long long **)(v5 + 80);
    uint64_t v64 = *(void *)(v5 + 72);
    memset(v65, 0, sizeof(v65));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v65, v7, *(long long **)(v5 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v5 + 88) - (void)v7) >> 3));
    id v66 = *(id *)(v5 + 104);
    long long v60 = v67;
    uint64_t v61 = v68;
    memset(v62, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v62, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
    v5 += 56;
    v62[3] = v72;
    float v8 = *(float *)(((unint64_t)&v63 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
    float v9 = *(float *)(((unint64_t)&v60 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v62);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v65);
  }
  while (v8 > v9);
  if (v5 - 56 == v31)
  {
    do
    {
      if (v5 >= (unint64_t)a2) {
        break;
      }
      long long v56 = *(long long *)((char *)a2 - 56);
      uint64_t v13 = (long long *)*((void *)a2 - 4);
      uint64_t v57 = *((void *)a2 - 5);
      memset(v58, 0, sizeof(v58));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v58, v13, *((long long **)a2 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 - 3) - (void)v13) >> 3));
      id v59 = *((id *)a2 - 1);
      long long v53 = v67;
      uint64_t v54 = v68;
      memset(v55, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
      a2 = (long long *)((char *)a2 - 56);
      v55[3] = v72;
      float v14 = *(float *)(((unint64_t)&v56 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      float v15 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v58);
    }
    while (v14 <= v15);
  }
  else
  {
    do
    {
      long long v49 = *(long long *)((char *)a2 - 56);
      float v10 = (long long *)*((void *)a2 - 4);
      uint64_t v50 = *((void *)a2 - 5);
      memset(v51, 0, sizeof(v51));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v51, v10, *((long long **)a2 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 - 3) - (void)v10) >> 3));
      id v52 = *((id *)a2 - 1);
      long long v46 = v67;
      uint64_t v47 = v68;
      memset(v48, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
      a2 = (long long *)((char *)a2 - 56);
      v48[3] = v72;
      float v11 = *(float *)(((unint64_t)&v49 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      float v12 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v51);
    }
    while (v11 <= v12);
  }
  if (v5 >= (unint64_t)a2)
  {
    unint64_t v16 = v5;
    unint64_t v24 = v5 - 56;
    unint64_t v25 = v31;
    if (v5 - 56 == v31) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v16 = v5;
    float v17 = a2;
    do
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v16, v17);
      do
      {
        long long v18 = *(_OWORD *)(v16 + 56);
        uint64_t v43 = *(void *)(v16 + 72);
        long long v42 = v18;
        memset(v44, 0, sizeof(v44));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v44, *(long long **)(v16 + 80), *(long long **)(v16 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v16 + 88) - *(void *)(v16 + 80)) >> 3));
        id v45 = *(id *)(v16 + 104);
        long long v39 = v67;
        uint64_t v40 = v68;
        memset(v41, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
        v16 += 56;
        v41[3] = v72;
        float v19 = *(float *)(((unint64_t)&v42 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v20 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v44);
      }
      while (v19 > v20);
      do
      {
        long long v21 = *(long long *)((char *)v17 - 56);
        uint64_t v36 = *((void *)v17 - 5);
        long long v35 = v21;
        memset(v37, 0, sizeof(v37));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v37, *((long long **)v17 - 4), *((long long **)v17 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v17 - 3) - *((void *)v17 - 4)) >> 3));
        id v38 = *((id *)v17 - 1);
        long long v32 = v67;
        uint64_t v33 = v68;
        memset(v34, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
        float v17 = (long long *)((char *)v17 - 56);
        v34[3] = v72;
        float v22 = *(float *)(((unint64_t)&v35 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v23 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v37);
      }
      while (v22 <= v23);
    }
    while (v16 < (unint64_t)v17);
    unint64_t v24 = v16 - 56;
    unint64_t v25 = v31;
    if (v16 - 56 == v31) {
      goto LABEL_18;
    }
  }
  long long v26 = *(_OWORD *)v24;
  *(void *)(v25 + 16) = *(void *)(v24 + 16);
  *(_OWORD *)unint64_t v25 = v26;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v30, *(void *)(v16 - 32), *(void *)(v16 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v16 - 24) - *(void *)(v16 - 32)) >> 3));
  objc_storeStrong(location, *(id *)(v16 - 8));
LABEL_18:
  long long v27 = v67;
  *(void *)(v24 + 16) = v68;
  *(_OWORD *)unint64_t v24 = v27;
  if ((long long *)v24 != &v67) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v16 - 32), (uint64_t)v69, (uint64_t)v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
  }
  objc_storeStrong((id *)(v16 - 8), v72);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v69);
  return v24;
}

void sub_235EBB05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a11);
  _Unwind_Resume(a1);
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEbT1_SC_T0_(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = a2;
  uint64_t v5 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v51 = *(_OWORD *)(a2 - 56);
      uint64_t v7 = *(long long **)(a2 - 32);
      uint64_t v52 = *(void *)(v3 - 40);
      memset(v53, 0, sizeof(v53));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v7, *(long long **)(v3 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v3 - 24) - (void)v7) >> 3));
      id v54 = *(id *)(v3 - 8);
      long long v48 = *(_OWORD *)a1;
      float v8 = *(long long **)(a1 + 24);
      uint64_t v49 = *(void *)(a1 + 16);
      memset(v50, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v50, v8, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v8) >> 3));
      v50[3] = *(void **)(a1 + 48);
      float v9 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      float v10 = *(float *)(((unint64_t)&v48 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v50);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);
      if (v9 > v10) {
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)(v3 - 56));
      }
      return 1;
    case 3:
      _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(a1, a1 + 56, a2 - 56, a3);
      return 1;
    case 4:
      _ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_SC_SC_T0_(a1, a1 + 56, a1 + 112, a2 - 56, a3);
      return 1;
    case 5:
      _ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_SC_SC_SC_T0_(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56, a3);
      return 1;
    default:
      uint64_t v11 = a1 + 112;
      _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(a1, a1 + 56, a1 + 112, a3);
      uint64_t v12 = a1 + 168;
      if (a1 + 168 == v3) {
        return 1;
      }
      uint64_t v13 = 0;
      int v26 = 0;
      uint64_t v25 = v3;
      break;
  }
  do
  {
    long long v44 = *(_OWORD *)v12;
    float v14 = *(long long **)(v12 + 24);
    uint64_t v45 = *(void *)(v12 + 16);
    memset(v46, 0, sizeof(v46));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, v14, *(long long **)(v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v12 + 32) - (void)v14) >> 3));
    id v47 = *(id *)(v12 + 48);
    uint64_t v15 = *(void *)(v11 + 16);
    long long v41 = *(_OWORD *)v11;
    uint64_t v42 = v15;
    memset(v43, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, *(long long **)(v11 + 24), *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - *(void *)(v11 + 24)) >> 3));
    v43[3] = *(void **)(v11 + 48);
    float v16 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
    float v17 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);
    if (v16 > v17)
    {
      long long v35 = *(_OWORD *)v12;
      long long v18 = *(long long **)(v12 + 24);
      uint64_t v36 = *(void *)(v12 + 16);
      id v38 = 0;
      uint64_t v39 = 0;
      long long v37 = 0;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v37, v18, *(long long **)(v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v12 + 32) - (void)v18) >> 3));
      obuint64_t j = *(id *)(v12 + 48);
      uint64_t v19 = v13;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        *(_OWORD *)(v20 + 168) = *(_OWORD *)(a1 + v19 + 112);
        *(void *)(v20 + 184) = *(void *)(a1 + v19 + 128);
        if (a1 + v19 + 112 != a1 + v19 + 168) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v20 + 192), *(void *)(v20 + 136), *(void *)(v20 + 144), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v20 + 144) - *(void *)(v20 + 136)) >> 3));
        }
        objc_storeStrong((id *)(v20 + 216), *(id *)(v20 + 160));
        if (v19 == -112) {
          break;
        }
        long long v31 = v35;
        uint64_t v32 = v36;
        memset(v33, 0, sizeof(v33));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v33, v37, v38, 0x6DB6DB6DB6DB6DB7 * (((char *)v38 - (char *)v37) >> 3));
        id v34 = obj;
        long long v28 = *(_OWORD *)(a1 + v19 + 56);
        long long v21 = *(long long **)(a1 + v19 + 80);
        uint64_t v29 = *(void *)(a1 + v19 + 72);
        memset(v30, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v30, v21, *(long long **)(a1 + v19 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + v19 + 88) - (void)v21) >> 3));
        v30[3] = *(void **)(a1 + v19 + 104);
        float v22 = *(float *)(((unint64_t)&v31 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v23 = *(float *)(((unint64_t)&v28 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v30);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
        v19 -= 56;
        if (v22 <= v23)
        {
          uint64_t v24 = a1 + v19 + 168;
          goto LABEL_16;
        }
      }
      uint64_t v24 = a1;
LABEL_16:
      *(_OWORD *)uint64_t v24 = v35;
      *(void *)(v24 + 16) = v36;
      uint64_t v3 = v25;
      if ((long long *)v24 != &v35) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v24 + 24), (uint64_t)v37, (uint64_t)v38, 0x6DB6DB6DB6DB6DB7 * (((char *)v38 - (char *)v37) >> 3));
      }
      objc_storeStrong((id *)(v24 + 48), obj);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v37);
      if (++v26 == 8) {
        return v12 + 56 == v25;
      }
    }
    uint64_t v11 = v12;
    v13 += 56;
    v12 += 56;
  }
  while (v12 != v3);
  return 1;
}

void sub_235EBB614(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void sub_235EBB630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a12);
  _Unwind_Resume(a1);
}

void **_ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEjT1_SC_SC_T0_(a1, a2, a3, a5);
  long long v40 = *(_OWORD *)a4;
  float v9 = *(long long **)(a4 + 24);
  uint64_t v41 = *(void *)(a4 + 16);
  memset(v42, 0, sizeof(v42));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v42, v9, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v9) >> 3));
  id v43 = *(id *)(a4 + 48);
  long long v37 = *(_OWORD *)a3;
  float v10 = *(long long **)(a3 + 24);
  uint64_t v38 = *(void *)(a3 + 16);
  memset(v39, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, v10, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v10) >> 3));
  v39[3] = *(void **)(a3 + 48);
  float v11 = *(float *)(((unint64_t)&v40 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 0x10);
  float v12 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 0x10);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);

  BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v42);
  if (v11 > v12)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a3, (long long *)a4);
    long long v33 = *(_OWORD *)a3;
    float v14 = *(long long **)(a3 + 24);
    uint64_t v34 = *(void *)(a3 + 16);
    memset(v35, 0, sizeof(v35));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, v14, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v14) >> 3));
    id v36 = *(id *)(a3 + 48);
    long long v30 = *(_OWORD *)a2;
    uint64_t v15 = *(long long **)(a2 + 24);
    uint64_t v31 = *(void *)(a2 + 16);
    memset(v32, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v32, v15, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v15) >> 3));
    v32[3] = *(void **)(a2 + 48);
    float v16 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 0x10);
    float v17 = *(float *)(((unint64_t)&v30 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v32);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);
    if (v16 > v17)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
      long long v26 = *(_OWORD *)a2;
      long long v18 = *(long long **)(a2 + 24);
      uint64_t v27 = *(void *)(a2 + 16);
      memset(v28, 0, sizeof(v28));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v28, v18, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v18) >> 3));
      id v29 = *(id *)(a2 + 48);
      long long v23 = *(_OWORD *)a1;
      uint64_t v19 = *(long long **)(a1 + 24);
      uint64_t v24 = *(void *)(a1 + 16);
      memset(v25, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v19, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v19) >> 3));
      v25[3] = *(void **)(a1 + 48);
      float v20 = *(float *)(((unint64_t)&v26 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 0x10);
      float v21 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v28);
      if (v20 > v21) {
        return _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
      }
    }
  }
  return result;
}

void sub_235EBB96C(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void **_ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_SC_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  _ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_SC_SC_T0_(a1, a2, a3, a4, a6);
  long long v53 = *(_OWORD *)a5;
  float v10 = *(long long **)(a5 + 24);
  uint64_t v54 = *(void *)(a5 + 16);
  memset(v55, 0, sizeof(v55));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v10, *(long long **)(a5 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a5 + 32) - (void)v10) >> 3));
  id v56 = *(id *)(a5 + 48);
  long long v50 = *(_OWORD *)a4;
  float v11 = *(long long **)(a4 + 24);
  uint64_t v51 = *(void *)(a4 + 16);
  memset(v52, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v52, v11, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v11) >> 3));
  v52[3] = *(void **)(a4 + 48);
  float v12 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
  float v13 = *(float *)(((unint64_t)&v50 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v52);

  BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);
  if (v12 > v13)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a4, (long long *)a5);
    long long v46 = *(_OWORD *)a4;
    uint64_t v15 = *(long long **)(a4 + 24);
    uint64_t v47 = *(void *)(a4 + 16);
    memset(v48, 0, sizeof(v48));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v15, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v15) >> 3));
    id v49 = *(id *)(a4 + 48);
    long long v43 = *(_OWORD *)a3;
    float v16 = *(long long **)(a3 + 24);
    uint64_t v44 = *(void *)(a3 + 16);
    memset(v45, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v45, v16, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v16) >> 3));
    v45[3] = *(void **)(a3 + 48);
    float v17 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
    float v18 = *(float *)(((unint64_t)&v43 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v45);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);
    if (v17 > v18)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a3, (long long *)a4);
      long long v39 = *(_OWORD *)a3;
      uint64_t v19 = *(long long **)(a3 + 24);
      uint64_t v40 = *(void *)(a3 + 16);
      memset(v41, 0, sizeof(v41));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v19, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v19) >> 3));
      id v42 = *(id *)(a3 + 48);
      long long v36 = *(_OWORD *)a2;
      float v20 = *(long long **)(a2 + 24);
      uint64_t v37 = *(void *)(a2 + 16);
      memset(v38, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, v20, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v20) >> 3));
      v38[3] = *(void **)(a2 + 48);
      float v21 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
      float v22 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);
      if (v21 > v22)
      {
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
        long long v32 = *(_OWORD *)a2;
        long long v23 = *(long long **)(a2 + 24);
        uint64_t v33 = *(void *)(a2 + 16);
        memset(v34, 0, sizeof(v34));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v23, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v23) >> 3));
        id v35 = *(id *)(a2 + 48);
        long long v29 = *(_OWORD *)a1;
        uint64_t v24 = *(long long **)(a1 + 24);
        uint64_t v30 = *(void *)(a1 + 16);
        memset(v31, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v31, v24, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v24) >> 3));
        v31[3] = *(void **)(a1 + 48);
        float v25 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
        float v26 = *(float *)(((unint64_t)&v29 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v31);

        BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);
        if (v25 > v26) {
          return _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
        }
      }
    }
  }
  return result;
}

void sub_235EBBD30(_Unwind_Exception *a1)
{
  uint64_t v3 = v1;

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v2);
  _Unwind_Resume(a1);
}

void **_ZNSt3__111__sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_OT0_NS_15iterator_traitsISC_E15difference_typeESC_(void **result, _DWORD *a2, uint64_t a3, char *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v5 = (void **)a4;
    int64_t v28 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= 0x6DB6DB6DB6DB6DB7 * ((a4 - (char *)result) >> 3))
    {
      int64_t v6 = (0xDB6DB6DB6DB6DB6ELL * ((a4 - (char *)result) >> 3)) | 1;
      uint64_t v7 = &result[2 * ((a4 - (char *)result) >> 3)];
      float v8 = v7 + 7;
      int64_t v9 = 0xDB6DB6DB6DB6DB6ELL * ((a4 - (char *)result) >> 3) + 2;
      uint64_t v27 = result;
      if (v9 < a3)
      {
        long long v61 = *(_OWORD *)v8;
        long long v62 = v7[9];
        memset(v63, 0, sizeof(v63));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v63, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
        id v64 = v7[13];
        long long v58 = *((_OWORD *)v7 + 7);
        id v59 = v7[16];
        memset(v60, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v60, (long long *)v7[17], (long long *)v7[18], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[18] - (unsigned char *)v7[17]) >> 3));
        v60[3] = v7[20];
        float v10 = *(float *)(((unint64_t)&v61 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
        float v11 = *(float *)(((unint64_t)&v58 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v60);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v63);
        if (v10 > v11)
        {
          float v8 = v7 + 14;
          int64_t v6 = v9;
        }
      }
      long long v54 = *(_OWORD *)v8;
      float v12 = (long long *)v8[3];
      long long v55 = v8[2];
      memset(v56, 0, sizeof(v56));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v56, v12, (long long *)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v12) >> 3));
      id v57 = v8[6];
      long long v51 = *(_OWORD *)v5;
      float v13 = (long long *)v5[3];
      uint64_t v52 = v5[2];
      memset(v53, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v13, (long long *)v5[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v5[4] - (unsigned char *)v13) >> 3));
      v53[3] = v5[6];
      float v14 = *(float *)(((unint64_t)&v54 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
      float v15 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v56);
      if (v14 <= v15)
      {
        long long v45 = *(_OWORD *)v5;
        float v16 = (long long *)v5[3];
        long long v46 = v5[2];
        uint64_t v47 = 0;
        long long v48 = 0;
        uint64_t v49 = 0;
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v47, v16, (long long *)v5[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v5[4] - (unsigned char *)v16) >> 3));
        obuint64_t j = v5[6];
        do
        {
          float v17 = v8;
          long long v18 = *(_OWORD *)v8;
          v5[2] = v8[2];
          *(_OWORD *)uint64_t v5 = v18;
          if (v5 != v8) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v5 + 3, (uint64_t)v8[3], (uint64_t)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v8[3]) >> 3));
          }
          objc_storeStrong(v5 + 6, v8[6]);
          if (v28 < v6) {
            break;
          }
          uint64_t v19 = (2 * v6) | 1;
          float v20 = &v27[14 * v6];
          float v8 = v20 + 7;
          int64_t v6 = 2 * v6 + 2;
          if (v6 >= a3)
          {
            int64_t v6 = v19;
          }
          else
          {
            long long v41 = *(_OWORD *)v8;
            id v42 = v20[9];
            memset(v43, 0, sizeof(v43));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, (long long *)v20[10], (long long *)v20[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v20[11] - (unsigned char *)v20[10]) >> 3));
            id v44 = v20[13];
            long long v38 = *((_OWORD *)v20 + 7);
            long long v39 = v20[16];
            memset(v40, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v40, (long long *)v20[17], (long long *)v20[18], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v20[18] - (unsigned char *)v20[17]) >> 3));
            v40[3] = v20[20];
            float v21 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
            float v22 = *(float *)(((unint64_t)&v38 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v40);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);
            if (v21 <= v22) {
              int64_t v6 = v19;
            }
            else {
              float v8 = v20 + 14;
            }
          }
          long long v34 = *(_OWORD *)v8;
          long long v23 = (long long *)v8[3];
          id v35 = v8[2];
          memset(v36, 0, sizeof(v36));
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v36, v23, (long long *)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v23) >> 3));
          id v37 = v8[6];
          long long v31 = v45;
          long long v32 = v46;
          memset(v33, 0, 24);
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v33, v47, v48, 0x6DB6DB6DB6DB6DB7 * (((char *)v48 - (char *)v47) >> 3));
          v33[3] = obj;
          float v24 = *(float *)(((unint64_t)&v34 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
          float v25 = *(float *)(((unint64_t)&v31 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);

          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v36);
          uint64_t v5 = v17;
        }
        while (v24 <= v25);
        long long v26 = v45;
        v17[2] = v46;
        *(_OWORD *)float v17 = v26;
        if (v17 != (void **)&v45) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v17 + 3, (uint64_t)v47, (uint64_t)v48, 0x6DB6DB6DB6DB6DB7 * (((char *)v48 - (char *)v47) >> 3));
        }
        objc_storeStrong(v17 + 6, obj);

        return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v47);
      }
    }
  }
  return result;
}

void sub_235EBC268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

void **_ZNSt3__110__pop_heapB8ne180100INS_17_ClassicAlgPolicyEZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SB_RT0_NS_15iterator_traitsISB_E15difference_typeE(void **result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    uint64_t v7 = result;
    long long v17 = *(_OWORD *)result;
    float v8 = (long long *)result[3];
    long long v18 = result[2];
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v19, v8, (long long *)result[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)result[4] - (unsigned char *)v8) >> 3));
    obuint64_t j = v7[6];
    int64_t v9 = _ZNSt3__117__floyd_sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EET1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE((long long *)v7, a3, a4);
    float v10 = v9;
    uint64_t v11 = a2 - 56;
    if (v9 == (long long *)(a2 - 56))
    {
      long long v16 = v17;
      *((void *)v9 + 2) = v18;
      *int64_t v9 = v16;
      if (v9 != &v17) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v9 + 3, v19, v20, 0x6DB6DB6DB6DB6DB7 * ((v20 - v19) >> 3));
      }
      objc_storeStrong((id *)v10 + 6, obj);
    }
    else
    {
      long long v12 = *(_OWORD *)v11;
      *((void *)v9 + 2) = *(void *)(a2 - 40);
      *int64_t v9 = v12;
      float v13 = (void **)(a2 - 32);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v9 + 3, *(void *)(a2 - 32), *(void *)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      float v15 = *(void **)(a2 - 8);
      float v14 = (id *)(a2 - 8);
      objc_storeStrong((id *)v10 + 6, v15);
      *(_OWORD *)uint64_t v11 = v17;
      *(void *)(v11 + 16) = v18;
      if ((long long *)v11 != &v17) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v13, v19, v20, 0x6DB6DB6DB6DB6DB7 * ((v20 - v19) >> 3));
      }
      objc_storeStrong(v14, obj);
      _ZNSt3__19__sift_upB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(v7, (uint64_t)v10 + 56, a3, 0x6DB6DB6DB6DB6DB7 * (((char *)v10 + 56 - (char *)v7) >> 3));
    }

    return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v19);
  }
  return result;
}

void sub_235EBC4EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v15);
  _Unwind_Resume(a1);
}

long long *_ZNSt3__117__floyd_sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EET1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(long long *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = a3 - 2;
  if (a3 < 2) {
    uint64_t v6 = a3 - 1;
  }
  uint64_t v7 = v6 >> 1;
  do
  {
    uint64_t v8 = (uint64_t)a1 + 56 * v5;
    int64_t v9 = (long long *)(v8 + 56);
    uint64_t v10 = 2 * v5;
    uint64_t v5 = (2 * v5) | 1;
    uint64_t v11 = v10 + 2;
    if (v10 + 2 < a3)
    {
      long long v12 = *v9;
      uint64_t v23 = *(void *)(v8 + 72);
      long long v22 = v12;
      memset(v24, 0, sizeof(v24));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v24, *(long long **)(v8 + 80), *(long long **)(v8 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v8 + 88) - *(void *)(v8 + 80)) >> 3));
      id v25 = *(id *)(v8 + 104);
      uint64_t v13 = *(void *)(v8 + 128);
      long long v19 = *(_OWORD *)(v8 + 112);
      uint64_t v20 = v13;
      memset(v21, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v21, *(long long **)(v8 + 136), *(long long **)(v8 + 144), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v8 + 144) - *(void *)(v8 + 136)) >> 3));
      v21[3] = *(void **)(v8 + 160);
      float v14 = *(float *)(((unint64_t)&v22 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
      float v15 = *(float *)(((unint64_t)&v19 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 0x10);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v21);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v24);
      if (v14 > v15)
      {
        int64_t v9 = (long long *)(v8 + 112);
        uint64_t v5 = v11;
      }
    }
    long long v16 = *v9;
    *((void *)a1 + 2) = *((void *)v9 + 2);
    *a1 = v16;
    if (a1 != v9) {
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)a1 + 3, *((void *)v9 + 3), *((void *)v9 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v9 + 4) - *((void *)v9 + 3)) >> 3));
    }
    objc_storeStrong((id *)a1 + 6, *((id *)v9 + 6));
    a1 = v9;
  }
  while (v5 <= v7);
  return v9;
}

void sub_235EBC6CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
  _Unwind_Resume(a1);
}

void **_ZNSt3__19__sift_upB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E0_PS5_EEvT1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(void **result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v7 = result;
    unint64_t v8 = v4 >> 1;
    int64_t v9 = &result[7 * (v4 >> 1)];
    long long v36 = *(_OWORD *)v9;
    uint64_t v10 = (long long *)v9[3];
    id v37 = v9[2];
    memset(v38, 0, sizeof(v38));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, v10, (long long *)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v10) >> 3));
    id v39 = v9[6];
    long long v33 = *(_OWORD *)(a2 - 56);
    uint64_t v11 = *(long long **)(a2 - 32);
    uint64_t v34 = *(void *)(a2 - 40);
    memset(v35, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, v11, *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - (void)v11) >> 3));
    v35[3] = *(void **)(a2 - 8);
    float v12 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
    float v13 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
    if (v12 > v13)
    {
      float v14 = (void **)(a2 - 56);
      long long v27 = *(_OWORD *)(a2 - 56);
      int64_t v28 = *(void **)(a2 - 40);
      long long v29 = 0;
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, *(long long **)(a2 - 32), *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      obuint64_t j = *(id *)(a2 - 8);
      do
      {
        float v15 = v9;
        long long v16 = *(_OWORD *)v9;
        v14[2] = v9[2];
        *(_OWORD *)float v14 = v16;
        if (v14 != v9) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v14 + 3, (uint64_t)v9[3], (uint64_t)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v9[3]) >> 3));
        }
        objc_storeStrong(v14 + 6, v9[6]);
        if (!v8) {
          break;
        }
        unint64_t v8 = (v8 - 1) >> 1;
        int64_t v9 = &v7[7 * v8];
        long long v23 = *(_OWORD *)v9;
        long long v17 = (long long *)v9[3];
        float v24 = v9[2];
        memset(v25, 0, sizeof(v25));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v17, (long long *)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v17) >> 3));
        id v26 = v9[6];
        long long v20 = v27;
        uint64_t v21 = v28;
        memset(v22, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
        v22[3] = obj;
        float v18 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        float v19 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 0x10);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
        float v14 = v15;
      }
      while (v18 > v19);
      *(_OWORD *)float v15 = v27;
      v15[2] = v28;
      if (v15 != (void **)&v27) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v15 + 3, (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
      }
      objc_storeStrong(v15 + 6, obj);

      return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
    }
  }
  return result;
}

void sub_235EBC9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

void *_ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPS4_EESB_EEvT_T0_m(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v5 = result;
    if (a4 >= 0x492492492492493) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    BOOL result = operator new(56 * a4);
    unint64_t v8 = result;
    *uint64_t v5 = result;
    v5[1] = result;
    v5[2] = &result[7 * a4];
    if (a2 != a3)
    {
      unint64_t v9 = 0;
      do
      {
        uint64_t v10 = &v8[v9 / 8];
        uint64_t v11 = a2 + v9;
        long long v12 = *(_OWORD *)(a2 + v9);
        v10[2] = *(void *)(a2 + v9 + 16);
        *(_OWORD *)uint64_t v10 = v12;
        v8[v9 / 8 + 3] = 0;
        v10[4] = 0;
        v10[5] = 0;
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v8[v9 / 8 + 3], *(long long **)(a2 + v9 + 24), *(long long **)(a2 + v9 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + v9 + 32) - *(void *)(a2 + v9 + 24)) >> 3));
        BOOL result = *(id *)(a2 + v9 + 48);
        v10[6] = result;
        v9 += 56;
      }
      while (v11 + 56 != a3);
      unint64_t v8 = (void *)((char *)v8 + v9);
    }
    v5[1] = v8;
  }
  return result;
}

void sub_235EBCB5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(uint64_t result, void **a2, _DWORD *a3, uint64_t a4, char a5)
{
  uint64_t v10 = result;
  while (2)
  {
    long long v36 = (long long *)(a2 - 7);
    uint64_t v11 = v10;
LABEL_3:
    uint64_t v12 = a4 - 1;
    while (1)
    {
      uint64_t v10 = v11;
      a4 = v12;
      uint64_t v13 = (uint64_t)a2 - v11;
      unint64_t v14 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)a2 - v11) >> 3);
      if (!(!v6 & v5))
      {
        switch(v14)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t v26 = (uint64_t)*(a2 - 5);
            long long v47 = *v36;
            uint64_t v48 = v26;
            memset(v49, 0, sizeof(v49));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v49, (long long *)*(a2 - 4), (long long *)*(a2 - 3), 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)*(a2 - 3) - (unsigned char *)*(a2 - 4)) >> 3));
            id v50 = *(a2 - 1);
            uint64_t v27 = *(void *)(v11 + 16);
            long long v44 = *(_OWORD *)v11;
            uint64_t v45 = v27;
            memset(v46, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, *(long long **)(v11 + 24), *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - *(void *)(v11 + 24)) >> 3));
            v46[3] = *(void **)(v11 + 48);
            float v28 = *(float *)(((unint64_t)&v47 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            float v29 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);

            BOOL result = (uint64_t)_ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v49);
            if (v28 < v29) {
              BOOL result = (uint64_t)_ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v11, v36);
            }
            break;
          case 3uLL:
            BOOL result = _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(v11, v11 + 56, (uint64_t)v36, a3);
            break;
          case 4uLL:
            BOOL result = (uint64_t)_ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_SC_SC_T0_(v11, v11 + 56, v11 + 112, (uint64_t)v36, a3);
            break;
          case 5uLL:
            BOOL result = (uint64_t)_ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_SC_SC_SC_T0_(v11, v11 + 56, v11 + 112, v11 + 168, (uint64_t)v36, a3);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v13 <= 1343)
      {
        if (a5) {
          return (uint64_t)_ZNSt3__116__insertion_sortB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_T0_((void **)v11, a2, a3);
        }
        else {
          return (uint64_t)_ZNSt3__126__insertion_sort_unguardedB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_T0_((void **)v11, a2, a3);
        }
      }
      if (v12 == -1)
      {
        if ((void **)v11 != a2)
        {
          unint64_t v30 = (v14 - 2) >> 1;
          unint64_t v31 = v30 + 1;
          long long v32 = (char *)(v11 + 56 * v30);
          do
          {
            _ZNSt3__111__sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_OT0_NS_15iterator_traitsISC_E15difference_typeESC_((void **)v10, a3, v14, v32);
            v32 -= 56;
            --v31;
          }
          while (v31);
          unint64_t v33 = v13 / 0x38uLL;
          do
          {
            BOOL result = (uint64_t)_ZNSt3__110__pop_heapB8ne180100INS_17_ClassicAlgPolicyEZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SB_RT0_NS_15iterator_traitsISB_E15difference_typeE((void **)v10, (uint64_t)a2, a3, v33);
            a2 -= 7;
          }
          while (v33-- > 2);
        }
        return result;
      }
      unint64_t v15 = v14 >> 1;
      long long v16 = (long long *)(v11 + 56 * v15);
      if ((unint64_t)v13 >= 0x1C01)
      {
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(v10, v10 + 56 * v15, (uint64_t)v36, a3);
        uint64_t v17 = v10 + 56 * v15;
        uint64_t v18 = v17 - 56;
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(v10 + 56, v17 - 56, (uint64_t)(a2 - 14), a3);
        v17 += 56;
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(v10 + 112, v17, (uint64_t)(a2 - 21), a3);
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(v18, (uint64_t)v16, v17, a3);
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v10, v16);
        if (a5) {
          goto LABEL_14;
        }
      }
      else
      {
        _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(v10 + 56 * v15, v10, (uint64_t)v36, a3);
        if (a5) {
          goto LABEL_14;
        }
      }
      long long v19 = *(_OWORD *)(v10 - 56);
      uint64_t v41 = *(void *)(v10 - 40);
      long long v40 = v19;
      memset(v42, 0, sizeof(v42));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v42, *(long long **)(v10 - 32), *(long long **)(v10 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v10 - 24) - *(void *)(v10 - 32)) >> 3));
      id v43 = *(id *)(v10 - 8);
      uint64_t v20 = *(void *)(v10 + 16);
      long long v37 = *(_OWORD *)v10;
      uint64_t v38 = v20;
      memset(v39, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, *(long long **)(v10 + 24), *(long long **)(v10 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v10 + 32) - *(void *)(v10 + 24)) >> 3));
      v39[3] = *(void **)(v10 + 48);
      float v21 = *(float *)(((unint64_t)&v40 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v22 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v42);
      if (v21 >= v22)
      {
        BOOL result = _ZNSt3__131__partition_with_equals_on_leftB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E1_EET0_SC_SC_T1_((long long *)v10, (unint64_t)a2, a3);
        uint64_t v11 = result;
        a5 = 0;
        goto LABEL_3;
      }
LABEL_14:
      unint64_t v23 = _ZNSt3__132__partition_with_equals_on_rightB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E1_EENS_4pairIT0_bEESD_SD_T1_((long long *)v10, (long long *)a2, a3);
      if ((v24 & 1) == 0) {
        goto LABEL_17;
      }
      BOOL v25 = _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEbT1_SC_T0_(v10, v23, a3);
      uint64_t v11 = v23 + 56;
      BOOL result = _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEbT1_SC_T0_(v23 + 56, (uint64_t)a2, a3);
      if (result) {
        break;
      }
      uint64_t v12 = a4 - 1;
      if (!v25)
      {
LABEL_17:
        BOOL result = _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_Lb0EEEvT1_SC_T0_NS_15iterator_traitsISC_E15difference_typeEb(v10, v23, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v11 = v23 + 56;
        goto LABEL_3;
      }
    }
    a2 = (void **)v23;
    if (!v25) {
      continue;
    }
    return result;
  }
}

void sub_235EBD0A0(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void **_ZNSt3__116__insertion_sortB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_T0_(void **result, void **a2, _DWORD *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    unint64_t v4 = result + 7;
    if (result + 7 != a2)
    {
      uint64_t v6 = 0;
      uint64_t v7 = result;
      do
      {
        unint64_t v8 = v4;
        long long v36 = *(_OWORD *)v4;
        long long v37 = v4[2];
        memset(v38, 0, sizeof(v38));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
        id v39 = v7[13];
        unint64_t v9 = v7[2];
        long long v33 = *(_OWORD *)v7;
        uint64_t v34 = v9;
        memset(v35, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, (long long *)v7[3], (long long *)v7[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[4] - (unsigned char *)v7[3]) >> 3));
        v35[3] = v7[6];
        float v10 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v11 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

        BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
        if (v10 < v11)
        {
          long long v27 = *(_OWORD *)v8;
          float v28 = v8[2];
          unint64_t v30 = 0;
          uint64_t v31 = 0;
          float v29 = 0;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
          obuint64_t j = v7[13];
          uint64_t v12 = v6;
          while (1)
          {
            uint64_t v13 = (char *)v3 + v12;
            *(_OWORD *)(v13 + 56) = *(_OWORD *)((char *)v3 + v12);
            uint64_t v14 = *(uint64_t *)((char *)v3 + v12 + 24);
            *((void *)v13 + 9) = *(void **)((char *)v3 + v12 + 16);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)((char *)v3 + v12 + 80), v14, *(uint64_t *)((char *)v3 + v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((*(uint64_t *)((char *)v3 + v12 + 32) - v14) >> 3));
            objc_storeStrong((id *)v13 + 13, *((id *)v13 + 6));
            if (!v12) {
              break;
            }
            long long v23 = v27;
            char v24 = v28;
            memset(v25, 0, sizeof(v25));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
            id v26 = obj;
            long long v20 = *(_OWORD *)((char *)v3 + v12 - 56);
            unint64_t v15 = *(long long **)((char *)v3 + v12 - 32);
            uint64_t v21 = *(uint64_t *)((char *)v3 + v12 - 40);
            memset(v22, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v15, *(long long **)((char *)v3 + v12 - 24), 0x6DB6DB6DB6DB6DB7 * ((*(unsigned char **)((char *)v3 + v12 - 24) - (unsigned char *)v15) >> 3));
            v22[3] = *(void **)((char *)v3 + v12 - 8);
            float v16 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            float v17 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
            v12 -= 56;
            if (v16 >= v17)
            {
              uint64_t v18 = (uint64_t)v3 + v12 + 56;
              goto LABEL_12;
            }
          }
          uint64_t v18 = (uint64_t)v3;
LABEL_12:
          *(_OWORD *)uint64_t v18 = v27;
          *(void *)(v18 + 16) = v28;
          if ((long long *)v18 != &v27) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v18 + 24), (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
          }
          objc_storeStrong((id *)(v18 + 48), obj);

          BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
        }
        unint64_t v4 = v8 + 7;
        v6 += 56;
        uint64_t v7 = v8;
      }
      while (v8 + 7 != a2);
    }
  }
  return result;
}

void sub_235EBD40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

void **_ZNSt3__126__insertion_sort_unguardedB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_T0_(void **result, void **a2, _DWORD *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    unint64_t v4 = result + 7;
    if (result + 7 != a2)
    {
      uint64_t v6 = result + 13;
      do
      {
        uint64_t v7 = v4;
        long long v36 = *(_OWORD *)v4;
        long long v37 = v4[2];
        memset(v38, 0, sizeof(v38));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, (long long *)v3[10], (long long *)v3[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[11] - (unsigned char *)v3[10]) >> 3));
        id v39 = v3[13];
        unint64_t v8 = v3[2];
        long long v33 = *(_OWORD *)v3;
        uint64_t v34 = v8;
        memset(v35, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, (long long *)v3[3], (long long *)v3[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[4] - (unsigned char *)v3[3]) >> 3));
        v35[3] = v3[6];
        float v9 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v10 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

        BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
        if (v9 < v10)
        {
          long long v27 = *(_OWORD *)v7;
          float v28 = v7[2];
          unint64_t v30 = 0;
          uint64_t v31 = 0;
          float v29 = 0;
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, (long long *)v3[10], (long long *)v3[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v3[11] - (unsigned char *)v3[10]) >> 3));
          obuint64_t j = v3[13];
          float v11 = v6;
          do
          {
            uint64_t v12 = v11;
            *((_OWORD *)v11 - 3) = *(_OWORD *)(v11 - 13);
            uint64_t v13 = (uint64_t)*(v11 - 10);
            uint64_t v14 = (uint64_t)*(v11 - 9);
            *(v11 - 4) = *(v11 - 11);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v11 - 3, v13, v14, 0x6DB6DB6DB6DB6DB7 * ((v14 - v13) >> 3));
            objc_storeStrong(v12, *(v12 - 7));
            long long v23 = v27;
            char v24 = v28;
            memset(v25, 0, sizeof(v25));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
            id v26 = obj;
            long long v20 = *((_OWORD *)v12 - 10);
            unint64_t v15 = (long long *)*(v12 - 17);
            uint64_t v21 = (uint64_t)*(v12 - 18);
            memset(v22, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v15, (long long *)*(v12 - 16), 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)*(v12 - 16) - (unsigned char *)v15) >> 3));
            v22[3] = *(v12 - 14);
            float v16 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            float v17 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
            float v11 = v12 - 7;
          }
          while (v16 < v17);
          *(_OWORD *)(v12 - 13) = v27;
          uint64_t v18 = v12 - 13;
          v18[2] = v28;
          if (v18 != (id *)&v27) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v18 + 3, (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
          }
          objc_storeStrong(v18 + 6, obj);

          BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
        }
        unint64_t v4 = v7 + 7;
        v6 += 7;
        uint64_t v3 = v7;
      }
      while (v7 + 7 != a2);
    }
  }
  return result;
}

void sub_235EBD770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  long long v63 = *(_OWORD *)a2;
  uint64_t v9 = *(void *)(a2 + 16);
  unint64_t v8 = *(long long **)(a2 + 24);
  uint64_t v64 = v9;
  memset(v65, 0, sizeof(v65));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v65, v8, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v8) >> 3));
  id v66 = *(id *)(a2 + 48);
  long long v60 = *(_OWORD *)a1;
  float v10 = *(long long **)(a1 + 24);
  uint64_t v61 = *(void *)(a1 + 16);
  memset(v62, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v62, v10, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v10) >> 3));
  v62[3] = *(void **)(a1 + 48);
  float v11 = *(float *)(((unint64_t)&v63 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  float v12 = *(float *)(((unint64_t)&v60 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v62);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v65);
  if (v11 < v12)
  {
    long long v42 = *(_OWORD *)a3;
    uint64_t v13 = *(long long **)(a3 + 24);
    uint64_t v43 = *(void *)(a3 + 16);
    memset(v44, 0, sizeof(v44));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v44, v13, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v13) >> 3));
    id v45 = *(id *)(a3 + 48);
    long long v39 = *(_OWORD *)a2;
    uint64_t v14 = *(long long **)(a2 + 24);
    uint64_t v40 = *(void *)(a2 + 16);
    memset(v41, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v14, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v14) >> 3));
    v41[3] = *(void **)(a2 + 48);
    float v15 = *(float *)(((unint64_t)&v42 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    float v16 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v44);
    if (v15 < v16)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a3);
      return 1;
    }
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
    long long v35 = *(_OWORD *)a3;
    long long v27 = *(long long **)(a3 + 24);
    uint64_t v36 = *(void *)(a3 + 16);
    memset(v37, 0, sizeof(v37));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v37, v27, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v27) >> 3));
    id v38 = *(id *)(a3 + 48);
    long long v32 = *(_OWORD *)a2;
    float v28 = *(long long **)(a2 + 24);
    uint64_t v33 = *(void *)(a2 + 16);
    memset(v34, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v28, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v28) >> 3));
    v34[3] = *(void **)(a2 + 48);
    float v29 = *(float *)(((unint64_t)&v35 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    float v30 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v37);
    if (v29 >= v30) {
      return 1;
    }
    BOOL v25 = (long long *)a2;
    id v26 = (long long *)a3;
LABEL_9:
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_(v25, v26);
    return 2;
  }
  long long v56 = *(_OWORD *)a3;
  float v17 = *(long long **)(a3 + 24);
  uint64_t v57 = *(void *)(a3 + 16);
  memset(v58, 0, sizeof(v58));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v58, v17, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v17) >> 3));
  id v59 = *(id *)(a3 + 48);
  long long v53 = *(_OWORD *)a2;
  uint64_t v18 = *(long long **)(a2 + 24);
  uint64_t v54 = *(void *)(a2 + 16);
  memset(v55, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v18, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v18) >> 3));
  v55[3] = *(void **)(a2 + 48);
  float v19 = *(float *)(((unint64_t)&v56 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  float v20 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v58);
  if (v19 < v20)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
    long long v49 = *(_OWORD *)a2;
    uint64_t v21 = *(long long **)(a2 + 24);
    uint64_t v50 = *(void *)(a2 + 16);
    memset(v51, 0, sizeof(v51));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v51, v21, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v21) >> 3));
    id v52 = *(id *)(a2 + 48);
    long long v46 = *(_OWORD *)a1;
    float v22 = *(long long **)(a1 + 24);
    uint64_t v47 = *(void *)(a1 + 16);
    memset(v48, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v22, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v22) >> 3));
    v48[3] = *(void **)(a1 + 48);
    float v23 = *(float *)(((unint64_t)&v49 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    float v24 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a4 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v51);
    if (v23 >= v24) {
      return 1;
    }
    BOOL v25 = (long long *)a1;
    id v26 = (long long *)a2;
    goto LABEL_9;
  }
  return 0;
}

void sub_235EBDC38(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

unint64_t _ZNSt3__131__partition_with_equals_on_leftB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E1_EET0_SC_SC_T1_(long long *a1, unint64_t a2, _DWORD *a3)
{
  long long v76 = *a1;
  uint64_t v6 = (long long *)*((void *)a1 + 3);
  uint64_t v33 = (void **)a1 + 3;
  uint64_t v77 = *((void *)a1 + 2);
  float v78 = 0;
  v79 = 0;
  uint64_t v80 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v78, v6, *((long long **)a1 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a1 + 4) - (void)v6) >> 3));
  id v81 = *((id *)a1 + 6);
  long long v72 = v76;
  uint64_t v73 = v77;
  memset(v74, 0, sizeof(v74));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v74, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
  id v75 = v81;
  long long v69 = *(_OWORD *)(a2 - 56);
  uint64_t v7 = *(long long **)(a2 - 32);
  uint64_t v70 = *(void *)(a2 - 40);
  memset(v71, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v71, v7, *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - (void)v7) >> 3));
  v71[3] = *(void **)(a2 - 8);
  float v8 = *(float *)(((unint64_t)&v72 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
  float v9 = *(float *)(((unint64_t)&v69 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v71);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v74);
  if (v8 >= v9)
  {
    unint64_t v14 = (unint64_t)a1 + 56;
    do
    {
      unint64_t v11 = v14;
      if (v14 >= a2) {
        break;
      }
      long long v58 = v76;
      uint64_t v59 = v77;
      memset(v60, 0, sizeof(v60));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v60, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      id v61 = v81;
      long long v55 = *(_OWORD *)v11;
      float v15 = *(long long **)(v11 + 24);
      uint64_t v56 = *(void *)(v11 + 16);
      memset(v57, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v57, v15, *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - (void)v15) >> 3));
      v57[3] = *(void **)(v11 + 48);
      float v16 = *(float *)(((unint64_t)&v58 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v17 = *(float *)(((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v57);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v60);
      unint64_t v14 = v11 + 56;
    }
    while (v16 >= v17);
  }
  else
  {
    float v10 = a1;
    do
    {
      long long v65 = v76;
      uint64_t v66 = v77;
      memset(v67, 0, sizeof(v67));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v67, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      unint64_t v11 = (unint64_t)v10 + 56;
      id v68 = v81;
      long long v62 = *(long long *)((char *)v10 + 56);
      uint64_t v63 = *((void *)v10 + 9);
      memset(v64, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v64, *((long long **)v10 + 10), *((long long **)v10 + 11), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v10 + 11) - *((void *)v10 + 10)) >> 3));
      v64[3] = *((void **)v10 + 13);
      float v12 = *(float *)(((unint64_t)&v65 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v13 = *(float *)(((unint64_t)&v62 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v64);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v67);
      float v10 = (long long *)((char *)v10 + 56);
    }
    while (v12 >= v13);
  }
  if (v11 < a2)
  {
    do
    {
      long long v51 = v76;
      uint64_t v52 = v77;
      memset(v53, 0, sizeof(v53));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
      uint64_t v18 = (long long *)(a2 - 56);
      id v54 = v81;
      long long v48 = *(_OWORD *)(a2 - 56);
      uint64_t v49 = *(void *)(a2 - 40);
      memset(v50, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v50, *(long long **)(a2 - 32), *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      v50[3] = *(void **)(a2 - 8);
      float v19 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v20 = *(float *)(((unint64_t)&v48 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v50);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);
      a2 -= 56;
    }
    while (v19 < v20);
    while (v11 < (unint64_t)v18)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v11, v18);
      unint64_t v21 = v11;
      do
      {
        long long v44 = v76;
        uint64_t v45 = v77;
        memset(v46, 0, sizeof(v46));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
        unint64_t v11 = v21 + 56;
        id v47 = v81;
        uint64_t v22 = *(void *)(v21 + 72);
        long long v41 = *(_OWORD *)(v21 + 56);
        uint64_t v42 = v22;
        memset(v43, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, *(long long **)(v21 + 80), *(long long **)(v21 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v21 + 88) - *(void *)(v21 + 80)) >> 3));
        v43[3] = *(void **)(v21 + 104);
        float v23 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v24 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);
        v21 += 56;
      }
      while (v23 >= v24);
      BOOL v25 = v18;
      do
      {
        long long v37 = v76;
        uint64_t v38 = v77;
        memset(v39, 0, sizeof(v39));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, v78, v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
        uint64_t v18 = (long long *)((char *)v25 - 56);
        id v40 = v81;
        uint64_t v26 = *((void *)v25 - 5);
        long long v34 = *(long long *)((char *)v25 - 56);
        uint64_t v35 = v26;
        memset(v36, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v36, *((long long **)v25 - 4), *((long long **)v25 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v25 - 3) - *((void *)v25 - 4)) >> 3));
        v36[3] = *((void **)v25 - 1);
        float v27 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v28 = *(float *)(((unint64_t)&v34 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v36);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);
        BOOL v25 = (long long *)((char *)v25 - 56);
      }
      while (v27 < v28);
    }
  }
  float v29 = (long long *)(v11 - 56);
  if ((long long *)(v11 - 56) != a1)
  {
    long long v30 = *v29;
    *((void *)a1 + 2) = *(void *)(v11 - 40);
    *a1 = v30;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v33, *(void *)(v11 - 32), *(void *)(v11 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 - 24) - *(void *)(v11 - 32)) >> 3));
    objc_storeStrong((id *)a1 + 6, *(id *)(v11 - 8));
  }
  long long v31 = v76;
  *(void *)(v11 - 40) = v77;
  *float v29 = v31;
  if (v29 != &v76) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v11 - 32), (uint64_t)v78, (uint64_t)v79, 0x6DB6DB6DB6DB6DB7 * (((char *)v79 - (char *)v78) >> 3));
  }
  objc_storeStrong((id *)(v11 - 8), v81);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v78);
  return v11;
}

void sub_235EBE2E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v12);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a12);
  _Unwind_Resume(a1);
}

unint64_t _ZNSt3__132__partition_with_equals_on_rightB8ne180100INS_17_ClassicAlgPolicyEP12GKCRTreeNodeI8NSObjectDv2_fERZNS5_18SplitReduceOverlapEPS3_RKS4_S9_EUlS5_S5_E1_EENS_4pairIT0_bEESD_SD_T1_(long long *a1, long long *a2, _DWORD *a3)
{
  unint64_t v5 = (unint64_t)a1;
  long long v67 = *a1;
  uint64_t v6 = (long long *)*((void *)a1 + 3);
  long long v30 = (void **)a1 + 3;
  uint64_t v68 = *((void *)a1 + 2);
  long long v69 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v69, v6, *((long long **)a1 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a1 + 4) - (void)v6) >> 3));
  location = (id *)(v5 + 48);
  id v72 = *(id *)(v5 + 48);
  unint64_t v31 = v5;
  do
  {
    long long v63 = *(_OWORD *)(v5 + 56);
    uint64_t v7 = *(long long **)(v5 + 80);
    uint64_t v64 = *(void *)(v5 + 72);
    memset(v65, 0, sizeof(v65));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v65, v7, *(long long **)(v5 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v5 + 88) - (void)v7) >> 3));
    id v66 = *(id *)(v5 + 104);
    long long v60 = v67;
    uint64_t v61 = v68;
    memset(v62, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v62, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
    v5 += 56;
    v62[3] = v72;
    float v8 = *(float *)(((unint64_t)&v63 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    float v9 = *(float *)(((unint64_t)&v60 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v62);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v65);
  }
  while (v8 < v9);
  if (v5 - 56 == v31)
  {
    do
    {
      if (v5 >= (unint64_t)a2) {
        break;
      }
      long long v56 = *(long long *)((char *)a2 - 56);
      uint64_t v13 = (long long *)*((void *)a2 - 4);
      uint64_t v57 = *((void *)a2 - 5);
      memset(v58, 0, sizeof(v58));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v58, v13, *((long long **)a2 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 - 3) - (void)v13) >> 3));
      id v59 = *((id *)a2 - 1);
      long long v53 = v67;
      uint64_t v54 = v68;
      memset(v55, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
      a2 = (long long *)((char *)a2 - 56);
      v55[3] = v72;
      float v14 = *(float *)(((unint64_t)&v56 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v15 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v58);
    }
    while (v14 >= v15);
  }
  else
  {
    do
    {
      long long v49 = *(long long *)((char *)a2 - 56);
      float v10 = (long long *)*((void *)a2 - 4);
      uint64_t v50 = *((void *)a2 - 5);
      memset(v51, 0, sizeof(v51));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v51, v10, *((long long **)a2 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)a2 - 3) - (void)v10) >> 3));
      id v52 = *((id *)a2 - 1);
      long long v46 = v67;
      uint64_t v47 = v68;
      memset(v48, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
      a2 = (long long *)((char *)a2 - 56);
      v48[3] = v72;
      float v11 = *(float *)(((unint64_t)&v49 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v12 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v51);
    }
    while (v11 >= v12);
  }
  if (v5 >= (unint64_t)a2)
  {
    unint64_t v16 = v5;
    unint64_t v24 = v5 - 56;
    unint64_t v25 = v31;
    if (v5 - 56 == v31) {
      goto LABEL_18;
    }
  }
  else
  {
    unint64_t v16 = v5;
    float v17 = a2;
    do
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v16, v17);
      do
      {
        long long v18 = *(_OWORD *)(v16 + 56);
        uint64_t v43 = *(void *)(v16 + 72);
        long long v42 = v18;
        memset(v44, 0, sizeof(v44));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v44, *(long long **)(v16 + 80), *(long long **)(v16 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v16 + 88) - *(void *)(v16 + 80)) >> 3));
        id v45 = *(id *)(v16 + 104);
        long long v39 = v67;
        uint64_t v40 = v68;
        memset(v41, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
        v16 += 56;
        v41[3] = v72;
        float v19 = *(float *)(((unint64_t)&v42 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v20 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v44);
      }
      while (v19 < v20);
      do
      {
        long long v21 = *(long long *)((char *)v17 - 56);
        uint64_t v36 = *((void *)v17 - 5);
        long long v35 = v21;
        memset(v37, 0, sizeof(v37));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v37, *((long long **)v17 - 4), *((long long **)v17 - 3), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v17 - 3) - *((void *)v17 - 4)) >> 3));
        id v38 = *((id *)v17 - 1);
        long long v32 = v67;
        uint64_t v33 = v68;
        memset(v34, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v69, v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
        float v17 = (long long *)((char *)v17 - 56);
        v34[3] = v72;
        float v22 = *(float *)(((unint64_t)&v35 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v23 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v37);
      }
      while (v22 >= v23);
    }
    while (v16 < (unint64_t)v17);
    unint64_t v24 = v16 - 56;
    unint64_t v25 = v31;
    if (v16 - 56 == v31) {
      goto LABEL_18;
    }
  }
  long long v26 = *(_OWORD *)v24;
  *(void *)(v25 + 16) = *(void *)(v24 + 16);
  *(_OWORD *)unint64_t v25 = v26;
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v30, *(void *)(v16 - 32), *(void *)(v16 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v16 - 24) - *(void *)(v16 - 32)) >> 3));
  objc_storeStrong(location, *(id *)(v16 - 8));
LABEL_18:
  long long v27 = v67;
  *(void *)(v24 + 16) = v68;
  *(_OWORD *)unint64_t v24 = v27;
  if ((long long *)v24 != &v67) {
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v16 - 32), (uint64_t)v69, (uint64_t)v70, 0x6DB6DB6DB6DB6DB7 * (((char *)v70 - (char *)v69) >> 3));
  }
  objc_storeStrong((id *)(v16 - 8), v72);

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v69);
  return v24;
}

void sub_235EBE980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a11);
  _Unwind_Resume(a1);
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEbT1_SC_T0_(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = a2;
  uint64_t v5 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v51 = *(_OWORD *)(a2 - 56);
      uint64_t v7 = *(long long **)(a2 - 32);
      uint64_t v52 = *(void *)(v3 - 40);
      memset(v53, 0, sizeof(v53));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v7, *(long long **)(v3 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v3 - 24) - (void)v7) >> 3));
      id v54 = *(id *)(v3 - 8);
      long long v48 = *(_OWORD *)a1;
      float v8 = *(long long **)(a1 + 24);
      uint64_t v49 = *(void *)(a1 + 16);
      memset(v50, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v50, v8, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v8) >> 3));
      v50[3] = *(void **)(a1 + 48);
      float v9 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      float v10 = *(float *)(((unint64_t)&v48 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v50);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);
      if (v9 < v10) {
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)(v3 - 56));
      }
      return 1;
    case 3:
      _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(a1, a1 + 56, a2 - 56, a3);
      return 1;
    case 4:
      _ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_SC_SC_T0_(a1, a1 + 56, a1 + 112, a2 - 56, a3);
      return 1;
    case 5:
      _ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_SC_SC_SC_T0_(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56, a3);
      return 1;
    default:
      uint64_t v11 = a1 + 112;
      _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(a1, a1 + 56, a1 + 112, a3);
      uint64_t v12 = a1 + 168;
      if (a1 + 168 == v3) {
        return 1;
      }
      uint64_t v13 = 0;
      int v26 = 0;
      uint64_t v25 = v3;
      break;
  }
  do
  {
    long long v44 = *(_OWORD *)v12;
    float v14 = *(long long **)(v12 + 24);
    uint64_t v45 = *(void *)(v12 + 16);
    memset(v46, 0, sizeof(v46));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v46, v14, *(long long **)(v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v12 + 32) - (void)v14) >> 3));
    id v47 = *(id *)(v12 + 48);
    uint64_t v15 = *(void *)(v11 + 16);
    long long v41 = *(_OWORD *)v11;
    uint64_t v42 = v15;
    memset(v43, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, *(long long **)(v11 + 24), *(long long **)(v11 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 32) - *(void *)(v11 + 24)) >> 3));
    v43[3] = *(void **)(v11 + 48);
    float v16 = *(float *)(((unint64_t)&v44 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    float v17 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);

    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v46);
    if (v16 < v17)
    {
      long long v35 = *(_OWORD *)v12;
      long long v18 = *(long long **)(v12 + 24);
      uint64_t v36 = *(void *)(v12 + 16);
      id v38 = 0;
      uint64_t v39 = 0;
      long long v37 = 0;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v37, v18, *(long long **)(v12 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v12 + 32) - (void)v18) >> 3));
      obuint64_t j = *(id *)(v12 + 48);
      uint64_t v19 = v13;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        *(_OWORD *)(v20 + 168) = *(_OWORD *)(a1 + v19 + 112);
        *(void *)(v20 + 184) = *(void *)(a1 + v19 + 128);
        if (a1 + v19 + 112 != a1 + v19 + 168) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v20 + 192), *(void *)(v20 + 136), *(void *)(v20 + 144), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v20 + 144) - *(void *)(v20 + 136)) >> 3));
        }
        objc_storeStrong((id *)(v20 + 216), *(id *)(v20 + 160));
        if (v19 == -112) {
          break;
        }
        long long v31 = v35;
        uint64_t v32 = v36;
        memset(v33, 0, sizeof(v33));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v33, v37, v38, 0x6DB6DB6DB6DB6DB7 * (((char *)v38 - (char *)v37) >> 3));
        id v34 = obj;
        long long v28 = *(_OWORD *)(a1 + v19 + 56);
        long long v21 = *(long long **)(a1 + v19 + 80);
        uint64_t v29 = *(void *)(a1 + v19 + 72);
        memset(v30, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v30, v21, *(long long **)(a1 + v19 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + v19 + 88) - (void)v21) >> 3));
        v30[3] = *(void **)(a1 + v19 + 104);
        float v22 = *(float *)(((unint64_t)&v31 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v23 = *(float *)(((unint64_t)&v28 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v30);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);
        v19 -= 56;
        if (v22 >= v23)
        {
          uint64_t v24 = a1 + v19 + 168;
          goto LABEL_16;
        }
      }
      uint64_t v24 = a1;
LABEL_16:
      *(_OWORD *)uint64_t v24 = v35;
      *(void *)(v24 + 16) = v36;
      uint64_t v3 = v25;
      if ((long long *)v24 != &v35) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)(v24 + 24), (uint64_t)v37, (uint64_t)v38, 0x6DB6DB6DB6DB6DB7 * (((char *)v38 - (char *)v37) >> 3));
      }
      objc_storeStrong((id *)(v24 + 48), obj);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v37);
      if (++v26 == 8) {
        return v12 + 56 == v25;
      }
    }
    uint64_t v11 = v12;
    v13 += 56;
    v12 += 56;
  }
  while (v12 != v3);
  return 1;
}

void sub_235EBEF38(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void sub_235EBEF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a12);
  _Unwind_Resume(a1);
}

void **_ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _ZNSt3__17__sort3B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEjT1_SC_SC_T0_(a1, a2, a3, a5);
  long long v40 = *(_OWORD *)a4;
  float v9 = *(long long **)(a4 + 24);
  uint64_t v41 = *(void *)(a4 + 16);
  memset(v42, 0, sizeof(v42));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v42, v9, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v9) >> 3));
  id v43 = *(id *)(a4 + 48);
  long long v37 = *(_OWORD *)a3;
  float v10 = *(long long **)(a3 + 24);
  uint64_t v38 = *(void *)(a3 + 16);
  memset(v39, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v39, v10, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v10) >> 3));
  v39[3] = *(void **)(a3 + 48);
  float v11 = *(float *)(((unint64_t)&v40 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
  float v12 = *(float *)(((unint64_t)&v37 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v39);

  BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v42);
  if (v11 < v12)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a3, (long long *)a4);
    long long v33 = *(_OWORD *)a3;
    float v14 = *(long long **)(a3 + 24);
    uint64_t v34 = *(void *)(a3 + 16);
    memset(v35, 0, sizeof(v35));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, v14, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v14) >> 3));
    id v36 = *(id *)(a3 + 48);
    long long v30 = *(_OWORD *)a2;
    uint64_t v15 = *(long long **)(a2 + 24);
    uint64_t v31 = *(void *)(a2 + 16);
    memset(v32, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v32, v15, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v15) >> 3));
    v32[3] = *(void **)(a2 + 48);
    float v16 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
    float v17 = *(float *)(((unint64_t)&v30 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v32);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);
    if (v16 < v17)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
      long long v26 = *(_OWORD *)a2;
      long long v18 = *(long long **)(a2 + 24);
      uint64_t v27 = *(void *)(a2 + 16);
      memset(v28, 0, sizeof(v28));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v28, v18, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v18) >> 3));
      id v29 = *(id *)(a2 + 48);
      long long v23 = *(_OWORD *)a1;
      uint64_t v19 = *(long long **)(a1 + 24);
      uint64_t v24 = *(void *)(a1 + 16);
      memset(v25, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v19, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v19) >> 3));
      v25[3] = *(void **)(a1 + 48);
      float v20 = *(float *)(((unint64_t)&v26 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
      float v21 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a5 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v28);
      if (v20 < v21) {
        return _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
      }
    }
  }
  return result;
}

void sub_235EBF290(_Unwind_Exception *a1)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v1);
  _Unwind_Resume(a1);
}

void **_ZNSt3__17__sort5B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_SC_SC_SC_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  _ZNSt3__17__sort4B8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_SC_SC_T0_(a1, a2, a3, a4, a6);
  long long v53 = *(_OWORD *)a5;
  float v10 = *(long long **)(a5 + 24);
  uint64_t v54 = *(void *)(a5 + 16);
  memset(v55, 0, sizeof(v55));
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v55, v10, *(long long **)(a5 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a5 + 32) - (void)v10) >> 3));
  id v56 = *(id *)(a5 + 48);
  long long v50 = *(_OWORD *)a4;
  float v11 = *(long long **)(a4 + 24);
  uint64_t v51 = *(void *)(a4 + 16);
  memset(v52, 0, 24);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v52, v11, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v11) >> 3));
  v52[3] = *(void **)(a4 + 48);
  float v12 = *(float *)(((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
  float v13 = *(float *)(((unint64_t)&v50 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v52);

  BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v55);
  if (v12 < v13)
  {
    _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a4, (long long *)a5);
    long long v46 = *(_OWORD *)a4;
    uint64_t v15 = *(long long **)(a4 + 24);
    uint64_t v47 = *(void *)(a4 + 16);
    memset(v48, 0, sizeof(v48));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v48, v15, *(long long **)(a4 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a4 + 32) - (void)v15) >> 3));
    id v49 = *(id *)(a4 + 48);
    long long v43 = *(_OWORD *)a3;
    float v16 = *(long long **)(a3 + 24);
    uint64_t v44 = *(void *)(a3 + 16);
    memset(v45, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v45, v16, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v16) >> 3));
    v45[3] = *(void **)(a3 + 48);
    float v17 = *(float *)(((unint64_t)&v46 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
    float v18 = *(float *)(((unint64_t)&v43 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v45);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v48);
    if (v17 < v18)
    {
      _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a3, (long long *)a4);
      long long v39 = *(_OWORD *)a3;
      uint64_t v19 = *(long long **)(a3 + 24);
      uint64_t v40 = *(void *)(a3 + 16);
      memset(v41, 0, sizeof(v41));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v41, v19, *(long long **)(a3 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 32) - (void)v19) >> 3));
      id v42 = *(id *)(a3 + 48);
      long long v36 = *(_OWORD *)a2;
      float v20 = *(long long **)(a2 + 24);
      uint64_t v37 = *(void *)(a2 + 16);
      memset(v38, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, v20, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v20) >> 3));
      v38[3] = *(void **)(a2 + 48);
      float v21 = *(float *)(((unint64_t)&v39 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
      float v22 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v41);
      if (v21 < v22)
      {
        _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a2, (long long *)a3);
        long long v32 = *(_OWORD *)a2;
        long long v23 = *(long long **)(a2 + 24);
        uint64_t v33 = *(void *)(a2 + 16);
        memset(v34, 0, sizeof(v34));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v34, v23, *(long long **)(a2 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 32) - (void)v23) >> 3));
        id v35 = *(id *)(a2 + 48);
        long long v29 = *(_OWORD *)a1;
        uint64_t v24 = *(long long **)(a1 + 24);
        uint64_t v30 = *(void *)(a1 + 16);
        memset(v31, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v31, v24, *(long long **)(a1 + 32), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 32) - (void)v24) >> 3));
        v31[3] = *(void **)(a1 + 48);
        float v25 = *(float *)(((unint64_t)&v32 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
        float v26 = *(float *)(((unint64_t)&v29 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a6 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v31);

        BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v34);
        if (v25 < v26) {
          return _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)a1, (long long *)a2);
        }
      }
    }
  }
  return result;
}

void sub_235EBF654(_Unwind_Exception *a1)
{
  uint64_t v3 = v1;

  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v2);
  _Unwind_Resume(a1);
}

void **_ZNSt3__111__sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_OT0_NS_15iterator_traitsISC_E15difference_typeESC_(void **result, _DWORD *a2, uint64_t a3, char *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v5 = (void **)a4;
    int64_t v28 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= 0x6DB6DB6DB6DB6DB7 * ((a4 - (char *)result) >> 3))
    {
      int64_t v6 = (0xDB6DB6DB6DB6DB6ELL * ((a4 - (char *)result) >> 3)) | 1;
      uint64_t v7 = &result[2 * ((a4 - (char *)result) >> 3)];
      float v8 = v7 + 7;
      int64_t v9 = 0xDB6DB6DB6DB6DB6ELL * ((a4 - (char *)result) >> 3) + 2;
      uint64_t v27 = result;
      if (v9 < a3)
      {
        long long v61 = *(_OWORD *)v8;
        long long v62 = v7[9];
        memset(v63, 0, sizeof(v63));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v63, (long long *)v7[10], (long long *)v7[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[11] - (unsigned char *)v7[10]) >> 3));
        id v64 = v7[13];
        long long v58 = *((_OWORD *)v7 + 7);
        id v59 = v7[16];
        memset(v60, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v60, (long long *)v7[17], (long long *)v7[18], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v7[18] - (unsigned char *)v7[17]) >> 3));
        v60[3] = v7[20];
        float v10 = *(float *)(((unint64_t)&v61 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
        float v11 = *(float *)(((unint64_t)&v58 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v60);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v63);
        if (v10 < v11)
        {
          float v8 = v7 + 14;
          int64_t v6 = v9;
        }
      }
      long long v54 = *(_OWORD *)v8;
      float v12 = (long long *)v8[3];
      long long v55 = v8[2];
      memset(v56, 0, sizeof(v56));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v56, v12, (long long *)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v12) >> 3));
      id v57 = v8[6];
      long long v51 = *(_OWORD *)v5;
      float v13 = (long long *)v5[3];
      uint64_t v52 = v5[2];
      memset(v53, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v53, v13, (long long *)v5[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v5[4] - (unsigned char *)v13) >> 3));
      v53[3] = v5[6];
      float v14 = *(float *)(((unint64_t)&v54 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      float v15 = *(float *)(((unint64_t)&v51 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v53);

      BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v56);
      if (v14 >= v15)
      {
        long long v45 = *(_OWORD *)v5;
        float v16 = (long long *)v5[3];
        long long v46 = v5[2];
        uint64_t v47 = 0;
        long long v48 = 0;
        uint64_t v49 = 0;
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v47, v16, (long long *)v5[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v5[4] - (unsigned char *)v16) >> 3));
        obuint64_t j = v5[6];
        do
        {
          float v17 = v8;
          long long v18 = *(_OWORD *)v8;
          v5[2] = v8[2];
          *(_OWORD *)uint64_t v5 = v18;
          if (v5 != v8) {
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v5 + 3, (uint64_t)v8[3], (uint64_t)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v8[3]) >> 3));
          }
          objc_storeStrong(v5 + 6, v8[6]);
          if (v28 < v6) {
            break;
          }
          uint64_t v19 = (2 * v6) | 1;
          float v20 = &v27[14 * v6];
          float v8 = v20 + 7;
          int64_t v6 = 2 * v6 + 2;
          if (v6 >= a3)
          {
            int64_t v6 = v19;
          }
          else
          {
            long long v41 = *(_OWORD *)v8;
            id v42 = v20[9];
            memset(v43, 0, sizeof(v43));
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v43, (long long *)v20[10], (long long *)v20[11], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v20[11] - (unsigned char *)v20[10]) >> 3));
            id v44 = v20[13];
            long long v38 = *((_OWORD *)v20 + 7);
            long long v39 = v20[16];
            memset(v40, 0, 24);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v40, (long long *)v20[17], (long long *)v20[18], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v20[18] - (unsigned char *)v20[17]) >> 3));
            v40[3] = v20[20];
            float v21 = *(float *)(((unint64_t)&v41 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
            float v22 = *(float *)(((unint64_t)&v38 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v40);

            _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v43);
            if (v21 >= v22) {
              int64_t v6 = v19;
            }
            else {
              float v8 = v20 + 14;
            }
          }
          long long v34 = *(_OWORD *)v8;
          long long v23 = (long long *)v8[3];
          id v35 = v8[2];
          memset(v36, 0, sizeof(v36));
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v36, v23, (long long *)v8[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v8[4] - (unsigned char *)v23) >> 3));
          id v37 = v8[6];
          long long v31 = v45;
          long long v32 = v46;
          memset(v33, 0, 24);
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v33, v47, v48, 0x6DB6DB6DB6DB6DB7 * (((char *)v48 - (char *)v47) >> 3));
          v33[3] = obj;
          float v24 = *(float *)(((unint64_t)&v34 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
          float v25 = *(float *)(((unint64_t)&v31 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v33);

          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v36);
          uint64_t v5 = v17;
        }
        while (v24 >= v25);
        long long v26 = v45;
        v17[2] = v46;
        *(_OWORD *)float v17 = v26;
        if (v17 != (void **)&v45) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v17 + 3, (uint64_t)v47, (uint64_t)v48, 0x6DB6DB6DB6DB6DB7 * (((char *)v48 - (char *)v47) >> 3));
        }
        objc_storeStrong(v17 + 6, obj);

        return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v47);
      }
    }
  }
  return result;
}

void sub_235EBFB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

void **_ZNSt3__110__pop_heapB8ne180100INS_17_ClassicAlgPolicyEZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SB_RT0_NS_15iterator_traitsISB_E15difference_typeE(void **result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    uint64_t v7 = result;
    long long v17 = *(_OWORD *)result;
    float v8 = (long long *)result[3];
    long long v18 = result[2];
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v19, v8, (long long *)result[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)result[4] - (unsigned char *)v8) >> 3));
    obuint64_t j = v7[6];
    int64_t v9 = _ZNSt3__117__floyd_sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EET1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE((long long *)v7, a3, a4);
    float v10 = v9;
    uint64_t v11 = a2 - 56;
    if (v9 == (long long *)(a2 - 56))
    {
      long long v16 = v17;
      *((void *)v9 + 2) = v18;
      *int64_t v9 = v16;
      if (v9 != &v17) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v9 + 3, v19, v20, 0x6DB6DB6DB6DB6DB7 * ((v20 - v19) >> 3));
      }
      objc_storeStrong((id *)v10 + 6, obj);
    }
    else
    {
      long long v12 = *(_OWORD *)v11;
      *((void *)v9 + 2) = *(void *)(a2 - 40);
      *int64_t v9 = v12;
      float v13 = (void **)(a2 - 32);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)v9 + 3, *(void *)(a2 - 32), *(void *)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      float v15 = *(void **)(a2 - 8);
      float v14 = (id *)(a2 - 8);
      objc_storeStrong((id *)v10 + 6, v15);
      *(_OWORD *)uint64_t v11 = v17;
      *(void *)(v11 + 16) = v18;
      if ((long long *)v11 != &v17) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v13, v19, v20, 0x6DB6DB6DB6DB6DB7 * ((v20 - v19) >> 3));
      }
      objc_storeStrong(v14, obj);
      _ZNSt3__19__sift_upB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(v7, (uint64_t)v10 + 56, a3, 0x6DB6DB6DB6DB6DB7 * (((char *)v10 + 56 - (char *)v7) >> 3));
    }

    return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v19);
  }
  return result;
}

void sub_235EBFE10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v15);
  _Unwind_Resume(a1);
}

long long *_ZNSt3__117__floyd_sift_downB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EET1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(long long *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = a3 - 2;
  if (a3 < 2) {
    uint64_t v6 = a3 - 1;
  }
  uint64_t v7 = v6 >> 1;
  do
  {
    uint64_t v8 = (uint64_t)a1 + 56 * v5;
    int64_t v9 = (long long *)(v8 + 56);
    uint64_t v10 = 2 * v5;
    uint64_t v5 = (2 * v5) | 1;
    uint64_t v11 = v10 + 2;
    if (v10 + 2 < a3)
    {
      long long v12 = *v9;
      uint64_t v23 = *(void *)(v8 + 72);
      long long v22 = v12;
      memset(v24, 0, sizeof(v24));
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v24, *(long long **)(v8 + 80), *(long long **)(v8 + 88), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v8 + 88) - *(void *)(v8 + 80)) >> 3));
      id v25 = *(id *)(v8 + 104);
      uint64_t v13 = *(void *)(v8 + 128);
      long long v19 = *(_OWORD *)(v8 + 112);
      uint64_t v20 = v13;
      memset(v21, 0, 24);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v21, *(long long **)(v8 + 136), *(long long **)(v8 + 144), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v8 + 144) - *(void *)(v8 + 136)) >> 3));
      v21[3] = *(void **)(v8 + 160);
      float v14 = *(float *)(((unint64_t)&v22 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      float v15 = *(float *)(((unint64_t)&v19 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1))) + 8);
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v21);

      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v24);
      if (v14 < v15)
      {
        int64_t v9 = (long long *)(v8 + 112);
        uint64_t v5 = v11;
      }
    }
    long long v16 = *v9;
    *((void *)a1 + 2) = *((void *)v9 + 2);
    *a1 = v16;
    if (a1 != v9) {
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l((void **)a1 + 3, *((void *)v9 + 3), *((void *)v9 + 4), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v9 + 4) - *((void *)v9 + 3)) >> 3));
    }
    objc_storeStrong((id *)a1 + 6, *((id *)v9 + 6));
    a1 = v9;
  }
  while (v5 <= v7);
  return v9;
}

void sub_235EBFFF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
  _Unwind_Resume(a1);
}

void **_ZNSt3__19__sift_upB8ne180100INS_17_ClassicAlgPolicyERZN12GKCRTreeNodeI8NSObjectDv2_fE18SplitReduceOverlapEPS3_RKS4_S8_EUlS5_S5_E1_PS5_EEvT1_SC_OT0_NS_15iterator_traitsISC_E15difference_typeE(void **result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v7 = result;
    unint64_t v8 = v4 >> 1;
    int64_t v9 = &result[7 * (v4 >> 1)];
    long long v36 = *(_OWORD *)v9;
    uint64_t v10 = (long long *)v9[3];
    id v37 = v9[2];
    memset(v38, 0, sizeof(v38));
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v38, v10, (long long *)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v10) >> 3));
    id v39 = v9[6];
    long long v33 = *(_OWORD *)(a2 - 56);
    uint64_t v11 = *(long long **)(a2 - 32);
    uint64_t v34 = *(void *)(a2 - 40);
    memset(v35, 0, 24);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v35, v11, *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - (void)v11) >> 3));
    v35[3] = *(void **)(a2 - 8);
    float v12 = *(float *)(((unint64_t)&v36 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    float v13 = *(float *)(((unint64_t)&v33 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
    _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v35);

    BOOL result = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v38);
    if (v12 < v13)
    {
      float v14 = (void **)(a2 - 56);
      long long v27 = *(_OWORD *)(a2 - 56);
      int64_t v28 = *(void **)(a2 - 40);
      long long v29 = 0;
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(&v29, *(long long **)(a2 - 32), *(long long **)(a2 - 24), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 - 24) - *(void *)(a2 - 32)) >> 3));
      obuint64_t j = *(id *)(a2 - 8);
      do
      {
        float v15 = v9;
        long long v16 = *(_OWORD *)v9;
        v14[2] = v9[2];
        *(_OWORD *)float v14 = v16;
        if (v14 != v9) {
          _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v14 + 3, (uint64_t)v9[3], (uint64_t)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v9[3]) >> 3));
        }
        objc_storeStrong(v14 + 6, v9[6]);
        if (!v8) {
          break;
        }
        unint64_t v8 = (v8 - 1) >> 1;
        int64_t v9 = &v7[7 * v8];
        long long v23 = *(_OWORD *)v9;
        long long v17 = (long long *)v9[3];
        float v24 = v9[2];
        memset(v25, 0, sizeof(v25));
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v25, v17, (long long *)v9[4], 0x6DB6DB6DB6DB6DB7 * (((unsigned char *)v9[4] - (unsigned char *)v17) >> 3));
        id v26 = v9[6];
        long long v20 = v27;
        uint64_t v21 = v28;
        memset(v22, 0, 24);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE16__init_with_sizeB8ne180100IPS4_S9_EEvT_T0_m(v22, v29, v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
        v22[3] = obj;
        float v18 = *(float *)(((unint64_t)&v23 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        float v19 = *(float *)(((unint64_t)&v20 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a3 & 1))) + 8);
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v22);

        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(v25);
        float v14 = v15;
      }
      while (v18 < v19);
      *(_OWORD *)float v15 = v27;
      v15[2] = v28;
      if (v15 != (void **)&v27) {
        _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE18__assign_with_sizeB8ne180100IPS4_S9_EEvT_T0_l(v15 + 3, (uint64_t)v29, (uint64_t)v30, 0x6DB6DB6DB6DB6DB7 * (((char *)v30 - (char *)v29) >> 3));
      }
      objc_storeStrong(v15 + 6, obj);

      return _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)&v29);
    }
  }
  return result;
}

void sub_235EC0304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev(a10);
  _Unwind_Resume(a1);
}

uint64_t _ZN12GKCRTreeNodeI8NSObjectDv2_fE12RemoveObjectEPS0_S1_S1_(void *a1, void *a2, double a3, double a4)
{
  uint64_t v7 = a2;
  unint64_t v8 = v7;
  int64_t v9 = (float32x2_t *)a1[3];
  uint64_t v10 = (float32x2_t *)a1[4];
  if (v10 == v9)
  {
    int64_t v9 = (float32x2_t *)a1[4];
  }
  else
  {
    long long v38 = v7;
    unint64_t v11 = 0;
    if (v9[6])
    {
      uint64_t v12 = 6;
      do
      {
        if ((void **)v9[v12] == v8)
        {
          _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)&v9[v12 - 6], (long long *)&v10[-7]);
          uint64_t v13 = a1[4];
          uint64_t v10 = (float32x2_t *)(v13 - 56);

          uint64_t v7 = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v13 - 32));
          a1[4] = v13 - 56;
          int64_t v9 = (float32x2_t *)a1[3];
          unint64_t v8 = v38;
        }
        ++v11;
        v12 += 7;
      }
      while (0x6DB6DB6DB6DB6DB7 * (v10 - v9) > v11);
    }
    else
    {
      unint64_t v28 = 0;
      do
      {
        uint64_t v7 = (void **)((char *)v9 + v11);
        float32x2_t v30 = *(float32x2_t *)((char *)v9 + v11 + 8);
        if ((vcgt_f32(v30, *(float32x2_t *)&a3).u8[0] & 1) == 0)
        {
          int32x2_t v31 = vcge_f32((float32x2_t)v7[2], *(float32x2_t *)&a4);
          if (v31.i8[0] & 1) != 0 && (vcge_f32(*(float32x2_t *)&a3, v30).i32[1] & 1) != 0 && (v31.i8[4])
          {
            _ZN12GKCRTreeNodeI8NSObjectDv2_fE12RemoveObjectEPS0_S1_S1_(a3, a4);
            int64_t v9 = (float32x2_t *)a1[3];
            uint64_t v10 = (float32x2_t *)a1[4];
            uint64_t v7 = (void **)((char *)v9 + v11);
            if (*(void *)((char *)&v9[4] + v11) == *(void *)((char *)&v9[3] + v11))
            {
              _ZNSt3__14swapB8ne180100I12GKCRTreeNodeI8NSObjectDv2_fEEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS6_EE5valueEvE4typeERS6_S9_((long long *)v7, (long long *)&v10[-7]);
              uint64_t v29 = a1[4];
              uint64_t v10 = (float32x2_t *)(v29 - 56);

              uint64_t v7 = _ZNSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEED1B8ne180100Ev((void **)(v29 - 32));
              a1[4] = v29 - 56;
              int64_t v9 = (float32x2_t *)a1[3];
            }
            unint64_t v8 = v38;
          }
        }
        ++v28;
        v11 += 56;
      }
      while (0x6DB6DB6DB6DB6DB7 * (v10 - v9) > v28);
    }
  }
  unint64_t v14 = ((char *)v10 - (char *)v9) / 56;
  float32x2_t v16 = (float32x2_t)a1[1];
  float32x2_t v15 = (float32x2_t)a1[2];
  if (v14 <= 1) {
    unint64_t v14 = 1;
  }
  __int32 v17 = HIDWORD(a1[2]);
  if ((vceq_f32(v16, *(float32x2_t *)&a3).u8[0] & 1) == 0) {
    goto LABEL_16;
  }
  float32x2_t v16 = (float32x2_t)__PAIR64__(v16.u32[1], v15.u32[0]);
  a1[1] = v16;
  if (v10 != v9)
  {
    float v18 = v9 + 1;
    unint64_t v19 = v14;
    do
    {
      float32x2_t v20 = *v18;
      v18 += 7;
      float v21 = v20.f32[0];
      if ((vcgt_f32(v16, v20).u32[0] & 1) == 0) {
        float v21 = v16.f32[0];
      }
      v16.f32[0] = v21;
      a1[1] = v16;
      --v19;
    }
    while (v19);
LABEL_16:
    if (vceq_f32(v15, *(float32x2_t *)&a4).u8[0])
    {
      float32x2_t v15 = (float32x2_t)__PAIR64__(v15.u32[1], v16.u32[0]);
      a1[2] = v15;
      if (v10 != v9)
      {
        long long v22 = v9 + 2;
        unint64_t v23 = v14;
        do
        {
          float32x2_t v24 = v15;
          float32x2_t v25 = *v22;
          v22 += 7;
          float v26 = v25.f32[0];
          if (vcgt_f32(v25, v24).u8[0]) {
            float v27 = v26;
          }
          else {
            float v27 = v24.f32[0];
          }
          float32x2_t v15 = (float32x2_t)__PAIR64__(v24.u32[1], LODWORD(v27));
          a1[2] = __PAIR64__(v24.u32[1], LODWORD(v27));
          --v23;
        }
        while (v23);
        __int32 v17 = v24.i32[1];
      }
    }
    goto LABEL_35;
  }
  if (vceq_f32(v15, *(float32x2_t *)&a4).u8[0]) {
    a1[2] = v15;
  }
LABEL_35:
  if ((vceq_f32(v16, *(float32x2_t *)&a3).i32[1] & 1) == 0) {
    goto LABEL_39;
  }
  v16.i32[1] = v17;
  a1[1] = v16;
  if (v10 != v9)
  {
    long long v32 = (float *)&v9[1] + 1;
    unint64_t v33 = v14;
    do
    {
      float v34 = *v32;
      v32 += 14;
      v16.i32[1] = fminf(v34, v16.f32[1]);
      a1[1] = v16;
      --v33;
    }
    while (v33);
LABEL_39:
    if (vceq_f32(v15, *(float32x2_t *)&a4).i32[1])
    {
      v15.i32[1] = v16.i32[1];
      a1[2] = v15;
      if (v10 != v9)
      {
        id v35 = (float *)&v9[2] + 1;
        do
        {
          float v36 = *v35;
          v35 += 14;
          v15.i32[1] = fmaxf(v15.f32[1], v36);
          a1[2] = v15;
          --v14;
        }
        while (v14);
      }
    }
    goto LABEL_46;
  }
  if (vceq_f32(v15, *(float32x2_t *)&a4).i32[1])
  {
    v15.i32[1] = v17;
    a1[2] = v15;
  }
LABEL_46:

  return MEMORY[0x270F9A758](v7, v8);
}

void sub_235EC06A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EC06B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

float32x2_t *_ZN12GKCRTreeNodeI8NSObjectDv2_fE5QueryES1_S1_RNSt3__16vectorIU8__strongPS0_NS3_9allocatorIS6_EEEE(float32x2_t *result, void *a2, float32x2_t a3, float32x2_t a4)
{
  uint64_t v7 = result;
  float32x2_t v8 = result[1];
  if ((vcgt_f32(a3, v8).u8[0] & 1) == 0
    && (float32x2_t v15 = result[2], (vcge_f32(a4, v15).u32[0] & 1) != 0)
    && (int32x2_t v16 = vcge_f32((float32x2_t)vzip2_s32((int32x2_t)a4, (int32x2_t)v8), (float32x2_t)vzip2_s32((int32x2_t)v15, (int32x2_t)a3)), (v16.i8[4] & 1) != 0)&& (v16.i8[0] & 1) != 0&& (v17 = (void *)result[6]) != 0)
  {
    float v18 = (float32x2_t **)a2[1];
    if ((unint64_t)v18 >= a2[2])
    {
      BOOL result = (float32x2_t *)std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(a2, (id *)&result[6]);
      a2[1] = result;
    }
    else
    {
      BOOL result = v17;
      float32x2_t *v18 = result;
      a2[1] = v18 + 1;
    }
  }
  else
  {
    float32x2_t v10 = result[3];
    float32x2_t v9 = result[4];
    if (*(void *)&v9 != *(void *)&v10)
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      do
      {
        BOOL result = (float32x2_t *)(*(void *)&v10 + v11);
        float32x2_t v13 = *(float32x2_t *)(*(void *)&v10 + v11 + 16);
        if ((vcgt_f32(a3, v13).u8[0] & 1) == 0)
        {
          int32x2_t v14 = vcge_f32(a4, result[1]);
          if (v14.i8[0] & 1) != 0 && (vcge_f32(v13, a3).i32[1] & 1) != 0 && (v14.i8[4])
          {
            BOOL result = (float32x2_t *)_ZN12GKCRTreeNodeI8NSObjectDv2_fE5QueryES1_S1_RNSt3__16vectorIU8__strongPS0_NS3_9allocatorIS6_EEEE(*(double *)&a3, *(double *)&a4);
            float32x2_t v10 = v7[3];
            float32x2_t v9 = v7[4];
          }
        }
        ++v12;
        v11 += 56;
      }
      while (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v9 - *(void *)&v10) >> 3) > v12);
    }
  }
  return result;
}

void *std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(void *a1, id *a2)
{
  uint64_t v3 = a1[1] - *a1;
  uint64_t v4 = v3 >> 3;
  unint64_t v5 = (v3 >> 3) + 1;
  if (v5 >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v5) {
    unint64_t v5 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float32x2_t v9 = (char *)operator new(8 * v8);
  }
  else
  {
    float32x2_t v9 = 0;
  }
  float32x2_t v10 = &v9[8 * v4];
  uint64_t v11 = &v9[8 * v8];
  *(void *)float32x2_t v10 = *a2;
  unint64_t v12 = v10 + 8;
  float32x2_t v13 = (char *)*a1;
  int32x2_t v14 = (char *)a1[1];
  if (v14 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v12;
    a1[2] = v11;
    if (!v14) {
      return v12;
    }
    goto LABEL_23;
  }
  unint64_t v15 = (unint64_t)&v14[-*a1 - 8];
  if (v15 < 0x78 || &v14[-(v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v3 - (v15 & 0xFFFFFFFFFFFFFFF8) - 8] < v14) {
    goto LABEL_31;
  }
  uint64_t v16 = (v15 >> 3) + 1;
  uint64_t v17 = 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
  v10 -= v17;
  float v18 = &v14[-v17];
  unint64_t v19 = v14 - 16;
  float32x2_t v20 = &v9[8 * v4 - 16];
  uint64_t v21 = v16 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v23 = *((_OWORD *)v19 - 1);
    long long v22 = *(_OWORD *)v19;
    *((_OWORD *)v19 - 1) = 0uLL;
    *(_OWORD *)unint64_t v19 = 0uLL;
    *((_OWORD *)v20 - 1) = v23;
    *(_OWORD *)float32x2_t v20 = v22;
    v19 -= 32;
    v20 -= 32;
    v21 -= 4;
  }
  while (v21);
  int32x2_t v14 = v18;
  if (v16 != (v16 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_31:
    do
    {
      uint64_t v24 = *((void *)v14 - 1);
      v14 -= 8;
      *(void *)int32x2_t v14 = 0;
      *((void *)v10 - 1) = v24;
      v10 -= 8;
    }
    while (v14 != v13);
  }
  float32x2_t v25 = (char *)*a1;
  int32x2_t v14 = (char *)a1[1];
  *a1 = v10;
  a1[1] = v12;
  a1[2] = v11;
  if (v14 != v25)
  {
    do
    {
      float v26 = (void *)*((void *)v14 - 1);
      v14 -= 8;
    }
    while (v14 != v25);
    int32x2_t v14 = v25;
  }
  if (v14) {
LABEL_23:
  }
    operator delete(v14);
  return v12;
}

float *lqCreateDatabase(int a1, int a2, int a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  float v18 = (float *)malloc_type_malloc(0x38uLL, 0x10A00406D72BAEFuLL);
  float *v18 = a4;
  v18[1] = a5;
  v18[2] = a6;
  v18[3] = a7;
  v18[4] = a8;
  v18[5] = a9;
  *((_DWORD *)v18 + 6) = a1;
  *((_DWORD *)v18 + 7) = a2;
  *((_DWORD *)v18 + 8) = a3;
  int v19 = a2 * a1 * a3;
  *((void *)v18 + 5) = malloc_type_malloc(8 * v19, 0xD436AE88uLL);
  if (v19 >= 1)
  {
    uint64_t v20 = 0;
    do
    {
      *(void *)(*((void *)v18 + 5) + v20) = 0;
      v20 += 8;
    }
    while (8 * v19 != v20);
  }
  *((void *)v18 + 6) = 0;
  return v18;
}

void *lqInitDatabase(uint64_t a1, int a2, int a3, int a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  *(float *)a1 = a5;
  *(float *)(a1 + 4) = a6;
  *(float *)(a1 + 8) = a7;
  *(float *)(a1 + 12) = a8;
  *(float *)(a1 + 16) = a9;
  *(float *)(a1 + 20) = a10;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 28) = a3;
  *(_DWORD *)(a1 + 32) = a4;
  int v11 = a3 * a2 * a4;
  BOOL result = malloc_type_malloc(8 * v11, 0xD436AE88uLL);
  *(void *)(a1 + 40) = result;
  if (v11 >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      *(void *)(*(void *)(a1 + 40) + v13) = 0;
      v13 += 8;
    }
    while (8 * v11 != v13);
  }
  *(void *)(a1 + 48) = 0;
  return result;
}

void lqDeleteDatabase(void **a1)
{
  free(a1[5]);

  free(a1);
}

uint64_t lqBinForLocation(uint64_t a1, float a2, float a3, float a4)
{
  float v4 = *(float *)a1;
  if (*(float *)a1 > a2) {
    return a1 + 48;
  }
  float v5 = *(float *)(a1 + 4);
  if (v5 > a3) {
    return a1 + 48;
  }
  float v6 = *(float *)(a1 + 8);
  if (v6 > a4) {
    return a1 + 48;
  }
  float v7 = *(float *)(a1 + 12);
  if ((float)(v7 + v4) <= a2) {
    return a1 + 48;
  }
  float v8 = *(float *)(a1 + 16);
  if ((float)(v8 + v5) <= a3) {
    return a1 + 48;
  }
  float v9 = *(float *)(a1 + 20);
  if ((float)(v9 + v6) <= a4) {
    return a1 + 48;
  }
  else {
    return *(void *)(a1 + 40)
  }
         + 8
         * ((int)(float)((float)((float)(a4 - v6) * (float)*(int *)(a1 + 32)) / v9)
          + ((int)(float)((float)((float)(a3 - v5) * (float)*(int *)(a1 + 28)) / v8)
           + *(_DWORD *)(a1 + 28) * (int)(float)((float)((float)(a2 - v4) * (float)*(int *)(a1 + 24)) / v7))
          * *(_DWORD *)(a1 + 32));
}

void *lqInitClientProxy(void *result, uint64_t a2)
{
  void *result = 0;
  result[1] = 0;
  result[2] = 0;
  result[3] = a2;
  return result;
}

void *lqAddToBin(void *result, void *a2)
{
  if (*a2)
  {
    void *result = 0;
    result[1] = *a2;
    *(void *)*a2 = result;
  }
  else
  {
    void *result = 0;
    result[1] = 0;
  }
  *a2 = result;
  result[2] = a2;
  return result;
}

uint64_t *lqRemoveFromBin(uint64_t *result)
{
  v1 = (uint64_t **)result[2];
  if (!v1) {
    goto LABEL_7;
  }
  if (*v1 != result)
  {
    uint64_t v2 = *result;
    if (!*result) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  id *v1 = (uint64_t *)result[1];
  uint64_t v2 = *result;
  if (*result) {
LABEL_4:
  }
    *(void *)(v2 + 8) = result[1];
LABEL_5:
  uint64_t v3 = (void *)result[1];
  if (v3) {
    void *v3 = v2;
  }
LABEL_7:
  void *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

uint64_t lqUpdateForNewLocation(uint64_t result, float *a2, float a3, float a4, float a5)
{
  float v5 = *(float *)result;
  if (*(float *)result > a3
    || (float v6 = *(float *)(result + 4), v6 > a4)
    || (float v7 = *(float *)(result + 8), v7 > a5)
    || (float v8 = *(float *)(result + 12), (float)(v8 + v5) <= a3)
    || (float v9 = *(float *)(result + 16), (float)(v9 + v6) <= a4)
    || (float v10 = *(float *)(result + 20), (float)(v10 + v7) <= a5))
  {
    int v11 = (uint64_t *)(result + 48);
  }
  else
  {
    int v11 = (uint64_t *)(*(void *)(result + 40)
                    + 8
                    * ((int)(float)((float)((float)(a5 - v7) * (float)*(int *)(result + 32)) / v10)
                     + ((int)(float)((float)((float)(a4 - v6) * (float)*(int *)(result + 28)) / v9)
                      + *(_DWORD *)(result + 28)
                      * (int)(float)((float)((float)(a3 - v5) * (float)*(int *)(result + 24)) / v8))
                     * *(_DWORD *)(result + 32)));
  }
  a2[8] = a3;
  a2[9] = a4;
  a2[10] = a5;
  unint64_t v12 = (uint64_t **)*((void *)a2 + 2);
  if (v11 != (uint64_t *)v12)
  {
    if (v12)
    {
      if (*v12 == (uint64_t *)a2) {
        *unint64_t v12 = (uint64_t *)*((void *)a2 + 1);
      }
      uint64_t v13 = *(void *)a2;
      if (*(void *)a2) {
        *(void *)(v13 + 8) = *((void *)a2 + 1);
      }
      int32x2_t v14 = (void *)*((void *)a2 + 1);
      if (v14) {
        *int32x2_t v14 = v13;
      }
    }
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    if (*v11)
    {
      *((void *)a2 + 1) = *v11;
      *(void *)uint64_t *v11 = a2;
    }
    else
    {
      *(void *)a2 = 0;
      *((void *)a2 + 1) = 0;
    }
    uint64_t *v11 = (uint64_t)a2;
    *((void *)a2 + 2) = v11;
  }
  return result;
}

uint64_t lqMapOverAllObjectsInLocalityClipped(uint64_t result, uint64_t (*a2)(void, uint64_t), uint64_t a3, int a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, float a12, int a13)
{
  if (a4 <= a7 && a5 <= a8 && a6 <= a13)
  {
    uint64_t v18 = result;
    int v19 = *(_DWORD *)(result + 32);
    int v20 = v19 * *(_DWORD *)(result + 28);
    uint64_t v35 = v19;
    uint64_t v34 = a6;
    float v21 = a12 * a12;
    uint64_t v22 = v20 * a4;
    uint64_t v29 = v20;
    uint64_t v30 = v19 * a5;
    do
    {
      int v33 = a4;
      uint64_t v23 = v30;
      int v24 = a5;
      do
      {
        uint64_t v26 = v34;
        do
        {
          for (uint64_t i = *(void *)(*(void *)(v18 + 40) + 8 * (v23 + v22 + v26)); i; uint64_t i = *(void *)(i + 8))
          {
            if ((float)((float)((float)((float)(a9 - *(float *)(i + 32)) * (float)(a9 - *(float *)(i + 32)))
                               + (float)((float)(a10 - *(float *)(i + 36)) * (float)(a10 - *(float *)(i + 36))))
                       + (float)((float)(a11 - *(float *)(i + 40)) * (float)(a11 - *(float *)(i + 40)))) < v21)
              BOOL result = a2(*(void *)(i + 24), a3);
          }
        }
        while ((int)v26++ < a13);
        v23 += v35;
      }
      while (v24++ != a8);
      v22 += v29;
      a4 = v33 + 1;
    }
    while (v33 != a7);
  }
  return result;
}

uint64_t lqMapOverAllOutsideObjects(uint64_t result, uint64_t (*a2)(void, uint64_t), uint64_t a3, float a4, float a5, float a6, float a7)
{
  uint64_t v7 = *(void *)(result + 48);
  if (v7)
  {
    float v13 = a7 * a7;
    do
    {
      if ((float)((float)((float)((float)(a4 - *(float *)(v7 + 32)) * (float)(a4 - *(float *)(v7 + 32)))
                         + (float)((float)(a5 - *(float *)(v7 + 36)) * (float)(a5 - *(float *)(v7 + 36))))
                 + (float)((float)(a6 - *(float *)(v7 + 40)) * (float)(a6 - *(float *)(v7 + 40)))) < v13)
        BOOL result = a2(*(void *)(v7 + 24), a3);
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7);
  }
  return result;
}

uint64_t lqMapOverAllObjectsInLocality(uint64_t result, uint64_t (*a2)(void, uint64_t), uint64_t a3, float a4, float a5, float a6, float a7)
{
  uint64_t v13 = result;
  float v14 = a7 + a4;
  float v15 = *(float *)result;
  if (v14 < *(float *)result
    || (float v16 = *(float *)(result + 4), (float)(a7 + a5) < v16)
    || (float v17 = a7 + a6, v18 = *(float *)(result + 8), (float)(a7 + a6) < v18)
    || (float v19 = *(float *)(result + 12), (float)(a4 - a7) >= (float)(v19 + v15))
    || (float v20 = *(float *)(result + 16), (float)(a5 - a7) >= (float)(v20 + v16))
    || (float v21 = *(float *)(result + 20), (float)(a6 - a7) >= (float)(v21 + v18)))
  {
    uint64_t v37 = *(void *)(result + 48);
    if (v37)
    {
      float v38 = a7 * a7;
      do
      {
        if ((float)((float)((float)((float)(a4 - *(float *)(v37 + 32)) * (float)(a4 - *(float *)(v37 + 32)))
                           + (float)((float)(a5 - *(float *)(v37 + 36)) * (float)(a5 - *(float *)(v37 + 36))))
                   + (float)((float)(a6 - *(float *)(v37 + 40)) * (float)(a6 - *(float *)(v37 + 40)))) < v38)
          BOOL result = a2(*(void *)(v37 + 24), a3);
        uint64_t v37 = *(void *)(v37 + 8);
      }
      while (v37);
    }
  }
  else
  {
    int v22 = *(_DWORD *)(result + 24);
    int v23 = *(_DWORD *)(result + 28);
    int v24 = (int)(float)((float)((float)(a4 - (float)(v15 + a7)) * (float)v22) / v19);
    int v25 = (int)(float)((float)((float)(a5 - (float)(v16 + a7)) * (float)v23) / v20);
    int v26 = *(_DWORD *)(result + 32);
    int v27 = (int)(float)((float)((float)(a6 - (float)(v18 + a7)) * (float)v26) / v21);
    int v28 = (int)(float)((float)((float)(v14 - v15) * (float)v22) / v19);
    int v29 = (int)(float)((float)((float)((float)(a7 + a5) - v16) * (float)v23) / v20);
    int v30 = (int)(float)((float)((float)(v17 - v18) * (float)v26) / v21);
    int v31 = v24 & ~(v24 >> 31);
    int v32 = v25 & ~(v25 >> 31);
    int v33 = v27 & ~(v27 >> 31);
    if (v22 <= v28) {
      int v34 = v22 - 1;
    }
    else {
      int v34 = (int)(float)((float)((float)(v14 - v15) * (float)v22) / v19);
    }
    if (v23 <= v29) {
      int v35 = v23 - 1;
    }
    else {
      int v35 = (int)(float)((float)((float)((float)(a7 + a5) - v16) * (float)v23) / v20);
    }
    if (v26 <= v30) {
      int v36 = v26 - 1;
    }
    else {
      int v36 = (int)(float)((float)((float)(v17 - v18) * (float)v26) / v21);
    }
    if (v26 <= v30 || v23 <= v29 || v22 <= v28 || v27 < 0 || v25 < 0 || v24 < 0) {
      lqMapOverAllOutsideObjects(result, a2, a3, a4, a5, a6, a7);
    }
    return lqMapOverAllObjectsInLocalityClipped(v13, a2, a3, v31, v32, v33, v34, v35, a4, a5, a6, a7, v36);
  }
  return result;
}

uint64_t lqFindNearestHelper(uint64_t result, uint64_t a2, float a3)
{
  if (*(void *)a2 != result && *(float *)(a2 + 16) > a3)
  {
    *(void *)(a2 + 8) = result;
    *(float *)(a2 + 16) = a3;
  }
  return result;
}

uint64_t lqFindNearestNeighborWithinRadius(uint64_t a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  uint64_t v8 = 0;
  uint64_t v7 = a2;
  uint64_t v9 = 2139095039;
  lqMapOverAllObjectsInLocality(a1, (uint64_t (*)(void, uint64_t))lqFindNearestHelper, (uint64_t)&v7, a3, a4, a5, a6);
  return v8;
}

uint64_t lqMapOverAllObjectsInBin(uint64_t result, uint64_t (*a2)(void, uint64_t, double), uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      BOOL result = a2(*(void *)(v5 + 24), a3, 0.0);
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5);
  }
  return result;
}

_DWORD *lqMapOverAllObjects(_DWORD *result, uint64_t (*a2)(void, uint64_t, double), uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = (result[7] * result[6] * result[8]);
  if ((int)v6 >= 1)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      for (uint64_t j = *(void *)(*((void *)v5 + 5) + 8 * i); j; uint64_t j = *(void *)(j + 8))
        BOOL result = (_DWORD *)a2(*(void *)(j + 24), a3, 0.0);
    }
  }
  for (uint64_t k = *((void *)v5 + 6); k; uint64_t k = *(void *)(k + 8))
    BOOL result = (_DWORD *)a2(*(void *)(k + 24), a3, 0.0);
  return result;
}

uint64_t lqRemoveAllObjects(uint64_t result)
{
  uint64_t v1 = (*(_DWORD *)(result + 28) * *(_DWORD *)(result + 24) * *(_DWORD *)(result + 32));
  if ((int)v1 >= 1)
  {
    uint64_t v2 = 0;
    while (1)
    {
      while (1)
      {
        uint64_t v3 = *(uint64_t **)(*(void *)(result + 40) + 8 * v2);
        if (v3) {
          break;
        }
        if (++v2 == v1) {
          goto LABEL_16;
        }
      }
      float v4 = (uint64_t **)v3[2];
      if (v4) {
        break;
      }
LABEL_3:
      uint64_t *v3 = 0;
      v3[1] = 0;
      v3[2] = 0;
    }
    if (*v4 == v3)
    {
      long long *v4 = (uint64_t *)v3[1];
      uint64_t v5 = *v3;
      if (!*v3)
      {
LABEL_11:
        uint64_t v6 = (void *)v3[1];
        if (v6) {
          void *v6 = v5;
        }
        goto LABEL_3;
      }
    }
    else
    {
      uint64_t v5 = *v3;
      if (!*v3) {
        goto LABEL_11;
      }
    }
    *(void *)(v5 + 8) = v3[1];
    goto LABEL_11;
  }
LABEL_16:
  while (1)
  {
    uint64_t v7 = *(uint64_t **)(result + 48);
    if (!v7) {
      return result;
    }
    uint64_t v8 = (uint64_t **)v7[2];
    if (!v8) {
      goto LABEL_15;
    }
    if (*v8 != v7)
    {
      uint64_t v9 = *v7;
      if (!*v7) {
        goto LABEL_21;
      }
LABEL_20:
      *(void *)(v9 + 8) = v7[1];
      goto LABEL_21;
    }
    *uint64_t v8 = (uint64_t *)v7[1];
    uint64_t v9 = *v7;
    if (*v7) {
      goto LABEL_20;
    }
LABEL_21:
    float v10 = (void *)v7[1];
    if (v10) {
      *float v10 = v9;
    }
LABEL_15:
    uint64_t *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
  }
}

void sub_235EC335C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC34A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC34BC(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_235EC34D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC353C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC35D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC3818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC3830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC3848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC385C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC3874(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC388C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC3E44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC400C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

OpenSteer::SimpleVehicle *OpenSteer::SimpleVehicle::SimpleVehicle(OpenSteer::SimpleVehicle *this)
{
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *(void *)this = &unk_26E942BE8;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 20) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_DWORD *)this + 38) = 0;
  *((_DWORD *)this + 10) = 1065353216;
  *(_OWORD *)((char *)this + 8) = xmmword_235F1EE70;
  *(_OWORD *)((char *)this + 24) = xmmword_235F1EE80;
  *((unsigned char *)this + 88) = 0;
  *(void *)((char *)this + 52) = 0;
  *(void *)((char *)this + 44) = 0;
  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 24) = 1065353216;
  OpenSteer::SimpleVehicle::setSpeed((uint64_t)this, 0.0);
  (*(void (**)(OpenSteer::SimpleVehicle *, float))(*(void *)this + 184))(this, 0.5);
  (*(void (**)(OpenSteer::SimpleVehicle *, float))(*(void *)this + 232))(this, 1.0);
  (*(void (**)(OpenSteer::SimpleVehicle *, float))(*(void *)this + 248))(this, 1.0);
  *((void *)this + 18) = _static_vec3_zero;
  *((_DWORD *)this + 38) = dword_26884D848;
  *((void *)this + 15) = _static_vec3_zero;
  *((_DWORD *)this + 32) = dword_26884D848;
  *(void *)((char *)this + 132) = _static_vec3_zero;
  *((_DWORD *)this + 35) = dword_26884D848;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 39) = 0;
  uint64_t v2 = _static_vec3_zero;
  *((_DWORD *)this + 42) = dword_26884D848;
  *((void *)this + 20) = v2;
  LODWORD(v2) = OpenSteer::SimpleVehicle::serialNumberCounter++;
  *((_DWORD *)this + 23) = v2;
  return this;
}

float OpenSteer::SimpleVehicle::SimpleVehicle(OpenSteer::SimpleVehicle *this)
{
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *(void *)this = &unk_26E942BE8;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *(_OWORD *)((char *)this + 8) = xmmword_235F1EE70;
  *(_OWORD *)((char *)this + 24) = xmmword_235F1EE80;
  *((unsigned char *)this + 88) = 0;
  *(void *)((char *)this + 52) = 0;
  *(void *)((char *)this + 44) = 0;
  *((_DWORD *)this + 15) = 0;
  *((_OWORD *)this + 6) = xmmword_235F1EE90;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 18) = _static_vec3_zero;
  *((_DWORD *)this + 38) = dword_26884D848;
  *((void *)this + 15) = _static_vec3_zero;
  *((_DWORD *)this + 32) = dword_26884D848;
  *(void *)((char *)this + 132) = _static_vec3_zero;
  *((_DWORD *)this + 35) = dword_26884D848;
  *((void *)this + 14) = 1065353216;
  uint64_t v1 = _static_vec3_zero;
  float result = *(float *)&dword_26884D848;
  *((_DWORD *)this + 42) = dword_26884D848;
  *((void *)this + 20) = v1;
  LODWORD(v1) = OpenSteer::SimpleVehicle::serialNumberCounter++;
  *((_DWORD *)this + 23) = v1;
  return result;
}

void OpenSteer::SimpleVehicle::adjustRawSteeringForce(OpenSteer::SimpleVehicle *this, const Vec3 *a2, float a3)
{
  float v5 = (*(float (**)(OpenSteer::SimpleVehicle *, float))(*(void *)this + 240))(this, a3) * 0.2;
  if ((*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 200))(this) <= v5
    && (a2->x != *(float *)&_static_vec3_zero
     || a2->y != *((float *)&_static_vec3_zero + 1)
     || a2->z != *(float *)&dword_26884D848))
  {
    float v6 = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 200))(this);
    double v7 = (float)(v6 / v5) * (float)(v6 / v5);
    *(float *)&double v7 = v7 * v7 * (v7 * v7 * (v7 * v7) * (v7 * v7 * (v7 * v7)));
    float v8 = 1.0 - (float)(*(float *)&v7 + *(float *)&v7);
    v12.x = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 32))(this);
    v12.y = v9;
    v12.z = v10;
    OpenSteer::vecLimitDeviationAngleUtility((OpenSteer *)1, &a2->x, &v12, v8, v11);
  }
}

uint64_t OpenSteer::SimpleVehicle::applyBrakingForce(OpenSteer::SimpleVehicle *this, float a2, float a3)
{
  float v5 = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 200))(this) * a2;
  if (v5 >= (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 224))(this)) {
    float v5 = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 224))(this);
  }
  v6.n128_f32[0] = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 200))(this)
                 - (float)(v5 * a3);
  double v7 = *(uint64_t (**)(OpenSteer::SimpleVehicle *, __n128))(*(void *)this + 208);

  return v7(this, v6);
}

float32x4_t OpenSteer::SimpleVehicle::applySteeringForce(float32x2_t *this, const Vec3 *a2, float a3)
{
  float v39 = COERCE_FLOAT(COERCE_UNSIGNED_INT64((*(double (**)(float32x2_t *, const Vec3 *))(*(void *)this
                                                                                                 + 296))(this, a2)));
  float v38 = v5;
  float v7 = v6;
  float v8 = (*(float (**)(float32x2_t *))(*(void *)this + 224))(this);
  float v9 = (float)((float)(v39 * v39) + (float)(v38 * v38)) + (float)(v7 * v7);
  BOOL v10 = v9 <= (float)(v8 * v8);
  float v11 = v8 / sqrtf(v9);
  double v12 = COERCE_DOUBLE(vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v38), LODWORD(v39)), v11));
  float v13 = v11 * v7;
  if (v10) {
    float v14 = v7;
  }
  else {
    float v14 = v13;
  }
  if (v10) {
    double v15 = COERCE_DOUBLE(__PAIR64__(LODWORD(v38), LODWORD(v39)));
  }
  else {
    double v15 = v12;
  }
  int32x2_t v40 = COERCE_INT32X2_T((*(double (**)(float32x2_t *))(*(void *)this + 160))(this));
  (*(void (**)(float32x2_t *))(*(void *)this + 192))(this);
  if (a3 <= 0.0)
  {
    v21.i32[0] = this[20].i32[0];
    float v22 = this[20].f32[1];
    float v20 = this[21].f32[0];
  }
  else
  {
    float v19 = fmaxf(fminf(fmaxf(fminf(a3 * 9.0, 0.4), 0.15), 1.0), 0.0);
    float v20 = this[21].f32[0] + (float)((float)((float)(v14 / *(float *)v40.i32) - this[21].f32[0]) * v19);
    float32x2_t v21 = vmla_n_f32(this[20], vsub_f32(vdiv_f32(*(float32x2_t *)&v15, (float32x2_t)vdup_lane_s32(v40, 0)), this[20]), v19);
    this[20] = v21;
    this[21].f32[0] = v20;
    float v22 = v21.f32[1];
  }
  float v23 = v16 + (float)(v21.f32[0] * a3);
  float v24 = v17 + (float)(v22 * a3);
  float v25 = v18 + (float)(v20 * a3);
  float v26 = (*(float (**)(float32x2_t *))(*(void *)this + 240))(this);
  float v27 = (float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25);
  if (v27 > (float)(v26 * v26))
  {
    float v28 = v26 / sqrtf(v27);
    float v23 = v28 * v23;
    float v24 = v28 * v24;
    float v25 = v28 * v25;
    float v27 = (float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25);
  }
  *(float *)long long v41 = v23;
  *(float *)&v41[1] = v24;
  *(float *)&v41[2] = v25;
  (*(void (**)(float32x2_t *, float))(*(void *)this + 208))(this, sqrtf(v27));
  double v29 = (*(double (**)(float32x2_t *))(*(void *)this + 48))(this);
  (*(void (**)(float32x2_t *, float, float, float))(*(void *)this + 56))(this, *(float *)&v29 + (float)(v23 * a3), v30 + (float)(v24 * a3), v31 + (float)(v25 * a3));
  (*(void (**)(float32x2_t *, _DWORD *, float))(*(void *)this + 288))(this, v41, a3);
  OpenSteer::SimpleVehicle::measurePathCurvature((OpenSteer::SimpleVehicle *)this, a3);
  float32x4_t v32 = (float32x4_t)((__n128 (*)(float32x2_t *))*(void *)(*(void *)this + 48))(this);
  v32.i32[1] = v33;
  *(float32x2_t *)v34.f32 = this[18];
  v34.i32[2] = this[19].i32[0];
  v32.i32[2] = v35;
  float32x4_t result = vsubq_f32(v32, v34);
  float32x4_t v37 = vmlaq_n_f32(v34, result, fmaxf(fminf(a3 * 0.06, 1.0), 0.0));
  this[19].i32[0] = v37.i32[2];
  this[18] = *(float32x2_t *)v37.f32;
  return result;
}

void OpenSteer::SimpleVehicle::measurePathCurvature(OpenSteer::SimpleVehicle *this, float a2)
{
  if (a2 > 0.0)
  {
    float v4 = *((float *)this + 33) - (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 48))(this);
    float v6 = *((float *)this + 34) - v5;
    float v8 = *((float *)this + 35) - v7;
    float v9 = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 32))(this);
    float v12 = 1.0 / sqrtf((float)((float)(v4 * v4) + (float)(v6 * v6)) + (float)(v8 * v8));
    float v13 = (float)(*((float *)this + 30) - v9) * v12;
    float v14 = (float)(*((float *)this + 31) - v10) * v12;
    float v15 = (float)(*((float *)this + 32) - v11) * v12;
    float v16 = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 32))(this);
    float v19 = (float)((float)(v16 * v13) + (float)(v17 * v14)) + (float)(v18 * v15);
    float v20 = v13 - (float)(v19 * v16);
    float v21 = v14 - (float)(v19 * v17);
    float v22 = v15 - (float)(v19 * v18);
    float v23 = (**(float (***)(OpenSteer::SimpleVehicle *))this)(this);
    float v26 = (float)((float)(v23 * v20) + (float)(v24 * v21)) + (float)(v25 * v22);
    float v27 = sqrtf((float)((float)(v20 * v20) + (float)(v21 * v21)) + (float)(v22 * v22));
    if (v26 >= 0.0) {
      float v28 = -v27;
    }
    else {
      float v28 = v27;
    }
    *((float *)this + 29) = v28;
    *((float *)this + 39) = *((float *)this + 39)
                          + (float)((float)(v28 - *((float *)this + 39)) * fmaxf(fminf(a2 * 4.0, 1.0), 0.0));
    *((float *)this + 30) = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 32))(this);
    *((_DWORD *)this + 31) = v29;
    *((_DWORD *)this + 32) = v30;
    *((float *)this + 33) = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 48))(this);
    *((_DWORD *)this + 34) = v31;
    *((_DWORD *)this + 35) = v32;
  }
}

void OpenSteer::SimpleVehicle::regenerateLocalSpace(OpenSteer::SimpleVehicle *this, const Vec3 *a2, float a3)
{
  if ((*(float (**)(OpenSteer::SimpleVehicle *, float))(*(void *)this + 200))(this, a3) > 0.0)
  {
    *(double *)&int32x2_t v5 = (*(double (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 200))(this);
    v6.i64[0] = *(void *)&a2->x;
    v6.i32[2] = LODWORD(a2->z);
    __asm { FMOV            V2.4S, #1.0 }
    float32x4_t v12 = vmulq_f32(v6, vdivq_f32(_Q2, (float32x4_t)vdupq_lane_s32(v5, 0)));
    __int32 v14 = v12.i32[2];
    uint64_t v13 = v12.i64[0];
    (*(void (**)(OpenSteer::SimpleVehicle *, uint64_t *))(*(void *)this + 120))(this, &v13);
  }
}

void OpenSteer::SimpleVehicle::regenerateLocalSpaceForBanking(OpenSteer::SimpleVehicle *this, const Vec3 *a2, float a3)
{
  float v5 = *((float *)this + 40);
  float v6 = *((float *)this + 42);
  float v7 = (float)(*((float *)this + 41) * 0.05) + 0.2;
  float v8 = a3 * 3.0;
  v10.n128_f32[0] = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 16))(this);
  float v9 = fmaxf(fminf(v8, 1.0), 0.0);
  v10.n128_f32[0] = v10.n128_f32[0] + (float)((float)-(float)(v10.n128_f32[0] - (float)(v5 * 0.05)) * v9);
  v11.n128_f32[0] = v11.n128_f32[0] + (float)((float)(v7 - v11.n128_f32[0]) * v9);
  v12.n128_f32[0] = v12.n128_f32[0] + (float)((float)-(float)(v12.n128_f32[0] - (float)(v6 * 0.05)) * v9);
  float v13 = sqrtf((float)((float)(v10.n128_f32[0] * v10.n128_f32[0]) + (float)(v11.n128_f32[0] * v11.n128_f32[0]))+ (float)(v12.n128_f32[0] * v12.n128_f32[0]));
  if (v13 > 0.0)
  {
    v10.n128_f32[0] = v10.n128_f32[0] * (float)(1.0 / v13);
    v11.n128_f32[0] = v11.n128_f32[0] * (float)(1.0 / v13);
    v12.n128_f32[0] = v12.n128_f32[0] * (float)(1.0 / v13);
  }
  (*(void (**)(OpenSteer::SimpleVehicle *, __n128, __n128, __n128))(*(void *)this + 24))(this, v10, v11, v12);
  if ((*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 200))(this) > 0.0)
  {
    *(double *)&int32x2_t v14 = (*(double (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 200))(this);
    v15.i64[0] = *(void *)&a2->x;
    v15.i32[2] = LODWORD(a2->z);
    __asm { FMOV            V2.4S, #1.0 }
    float32x4_t v21 = vmulq_f32(v15, vdivq_f32(_Q2, (float32x4_t)vdupq_lane_s32(v14, 0)));
    __int32 v23 = v21.i32[2];
    uint64_t v22 = v21.i64[0];
    (*(void (**)(OpenSteer::SimpleVehicle *, uint64_t *))(*(void *)this + 120))(this, &v22);
  }
}

float OpenSteer::SimpleVehicle::predictFuturePosition(OpenSteer::SimpleVehicle *this, float a2)
{
  float v4 = (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 48))(this);
  return v4 + (float)((*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 192))(this) * a2);
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::side(uint64_t a1)
{
  return *(float *)(a1 + 8);
}

float *OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::setSide(float *result, float a2, float a3, float a4)
{
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  return result;
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::up(uint64_t a1)
{
  return *(float *)(a1 + 20);
}

float *OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::setUp(float *result, float a2, float a3, float a4)
{
  result[5] = a2;
  result[6] = a3;
  result[7] = a4;
  return result;
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::forward(uint64_t a1)
{
  return *(float *)(a1 + 32);
}

float *OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::setForward(float *result, float a2, float a3, float a4)
{
  result[8] = a2;
  result[9] = a3;
  result[10] = a4;
  return result;
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::position(uint64_t a1)
{
  return *(float *)(a1 + 44);
}

float *OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::setPosition(float *result, float a2, float a3, float a4)
{
  result[11] = a2;
  result[12] = a3;
  result[13] = a4;
  return result;
}

uint64_t OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::rightHanded()
{
  return 1;
}

double OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::resetLocalSpace(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 1065353216;
  *(float *)(a1 + 8) = (*(float (**)(uint64_t, uint64_t))(*(void *)a1 + 144))(a1, a1 + 32);
  *(_DWORD *)(a1 + 12) = v2;
  *(_DWORD *)(a1 + 16) = v3;
  double result = 0.0078125;
  *(void *)(a1 + 20) = 0x3F80000000000000;
  *(_DWORD *)(a1 + 28) = 0;
  *(void *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  return result;
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::localizeDirection(float *a1, float *a2)
{
  return (float)((float)(a1[2] * *a2) + (float)(a1[3] * a2[1])) + (float)(a1[4] * a2[2]);
}

uint64_t OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::localizePosition(uint64_t a1, uint64_t a2, float32x4_t a3, float32x4_t a4)
{
  a3.i64[0] = *(void *)a2;
  a3.i32[2] = *(_DWORD *)(a2 + 8);
  a4.i64[0] = *(void *)(a1 + 44);
  a4.i32[2] = *(_DWORD *)(a1 + 52);
  float32x4_t v4 = vsubq_f32(a3, a4);
  __int32 v7 = v4.i32[2];
  uint64_t v6 = v4.i64[0];
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 80))(a1, &v6);
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::globalizePosition(float *a1)
{
  return (*(float (**)(float *))(*(void *)a1 + 104))(a1) + a1[11];
}

float32x2_t OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::globalizeDirection(uint64_t a1, float *a2)
{
  return vmla_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)(a1 + 8), *a2), *(float32x2_t *)(a1 + 20), a2[1]), *(float32x2_t *)(a1 + 32), a2[2]);
}

uint64_t OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::setUnitSideFromForwardAndUp(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  if (result)
  {
    int v3 = (__int32 *)(a1 + 32);
    float32x4_t v4 = (__int32 *)(a1 + 20);
    float v5 = (int32x2_t *)(a1 + 36);
    uint64_t v6 = (int32x2_t *)(a1 + 24);
  }
  else
  {
    int v3 = (__int32 *)(a1 + 20);
    float32x4_t v4 = (__int32 *)(a1 + 32);
    float v5 = (int32x2_t *)(a1 + 24);
    uint64_t v6 = (int32x2_t *)(a1 + 36);
  }
  v7.i32[0] = vdup_lane_s32(*v6, 1).u32[0];
  v7.i32[1] = *v4;
  v8.i32[0] = vdup_lane_s32(*v5, 1).u32[0];
  v8.i32[1] = *v3;
  float32x2_t v9 = vmls_f32(vmul_f32(v7, (float32x2_t)*v5), v8, (float32x2_t)*v6);
  float v10 = -(float)((float)(*(float *)v4 * COERCE_FLOAT(*v5)) - (float)(*(float *)v3 * COERCE_FLOAT(*v6)));
  float32x2_t v11 = vmul_f32(v9, v9);
  v11.f32[0] = sqrtf(vaddv_f32(v11) + (float)(v10 * v10));
  if (v11.f32[0] > 0.0)
  {
    float32x2_t v9 = vdiv_f32(v9, (float32x2_t)vdup_lane_s32((int32x2_t)v11, 0));
    float v10 = v10 / v11.f32[0];
  }
  *(float32x2_t *)(a1 + 8) = v9;
  *(float *)(a1 + 16) = v10;
  return result;
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::regenerateOrthonormalBasisUF(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(_DWORD *)(a1 + 40) = *((_DWORD *)a2 + 2);
  *(void *)(a1 + 32) = v3;
  (*(void (**)(uint64_t))(*(void *)a1 + 112))(a1);
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v5 = 8;
  if (v4) {
    uint64_t v6 = 32;
  }
  else {
    uint64_t v6 = 8;
  }
  if (!v4) {
    uint64_t v5 = 32;
  }
  uint64_t v7 = 36;
  if (v4) {
    uint64_t v8 = 12;
  }
  else {
    uint64_t v8 = 36;
  }
  if (!v4) {
    uint64_t v7 = 12;
  }
  float32x2_t v9 = *(float32x2_t *)(a1 + v8);
  float32x2_t v10 = *(float32x2_t *)(a1 + v7);
  v11.i32[0] = vdup_lane_s32((int32x2_t)v10, 1).u32[0];
  v11.i32[1] = *(_DWORD *)(a1 + v6);
  v12.i32[0] = vdup_lane_s32((int32x2_t)v9, 1).u32[0];
  v12.i32[1] = *(_DWORD *)(a1 + v5);
  float result = -(float)((float)(v11.f32[1] * v9.f32[0]) - (float)(v12.f32[1] * v10.f32[0]));
  *(float32x2_t *)(a1 + 20) = vmls_f32(vmul_f32(v11, v9), v12, v10);
  *(float *)(a1 + 28) = result;
  return result;
}

uint64_t OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::regenerateOrthonormalBasis(uint64_t a1, float *a2)
{
  float v2 = *a2;
  float v3 = a2[1];
  float v4 = a2[2];
  float v5 = sqrtf((float)((float)(v2 * v2) + (float)(v3 * v3)) + (float)(v4 * v4));
  if (v5 > 0.0)
  {
    float v6 = 1.0 / v5;
    float v2 = v2 * v6;
    float v3 = v3 * v6;
    float v4 = v4 * v6;
  }
  *(float *)uint64_t v8 = v2;
  *(float *)&v8[1] = v3;
  *(float *)&v8[2] = v4;
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)a1 + 120))(a1, v8);
}

uint64_t OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::regenerateOrthonormalBasis(uint64_t a1, float *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  *(_DWORD *)(a1 + 28) = *((_DWORD *)a3 + 2);
  *(void *)(a1 + 20) = v3;
  float v4 = *a2;
  float v5 = a2[1];
  float v6 = a2[2];
  float v7 = sqrtf((float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v6 * v6));
  if (v7 > 0.0)
  {
    float v8 = 1.0 / v7;
    float v4 = v4 * v8;
    float v5 = v5 * v8;
    float v6 = v6 * v8;
  }
  *(float *)float32x2_t v10 = v4;
  *(float *)&v10[1] = v5;
  *(float *)&v10[2] = v6;
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)a1 + 128))(a1, v10);
}

float OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::localRotateForwardToSide(uint64_t a1, uint64_t a2)
{
  int v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  float result = *(float *)(a2 + 8);
  if (v3) {
    return -result;
  }
  return result;
}

uint64_t OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>::globalRotateForwardToSide(uint64_t a1)
{
  v8[0] = (*(float (**)(uint64_t))(*(void *)a1 + 80))(a1);
  v8[1] = v2;
  v8[2] = v3;
  v7[0] = (*(float (**)(uint64_t, _DWORD *))(*(void *)a1 + 144))(a1, v8);
  v7[1] = v4;
  v7[2] = v5;
  return (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)a1 + 104))(a1, v7);
}

float OpenSteer::SimpleVehicle::mass(OpenSteer::SimpleVehicle *this)
{
  return *((float *)this + 24);
}

uint64_t OpenSteer::SimpleVehicle::setMass(uint64_t this, float a2)
{
  *(float *)(this + 96) = a2;
  return this;
}

float OpenSteer::SimpleVehicle::radius(OpenSteer::SimpleVehicle *this)
{
  return *((float *)this + 25);
}

uint64_t OpenSteer::SimpleVehicle::setRadius(uint64_t this, float a2)
{
  *(float *)(this + 100) = a2;
  return this;
}

float OpenSteer::SimpleVehicle::velocity(OpenSteer::SimpleVehicle *this)
{
  return (*(float (**)(OpenSteer::SimpleVehicle *))(*(void *)this + 32))(this) * *((float *)this + 26);
}

float OpenSteer::SimpleVehicle::speed(OpenSteer::SimpleVehicle *this)
{
  return *((float *)this + 26);
}

uint64_t OpenSteer::SimpleVehicle::setSpeed(uint64_t this, float a2)
{
  *(float *)(this + 104) = a2;
  return this;
}

float OpenSteer::SimpleVehicle::maxForce(OpenSteer::SimpleVehicle *this)
{
  return *((float *)this + 27);
}

uint64_t OpenSteer::SimpleVehicle::setMaxForce(uint64_t this, float a2)
{
  *(float *)(this + 108) = a2;
  return this;
}

float OpenSteer::SimpleVehicle::maxSpeed(OpenSteer::SimpleVehicle *this)
{
  return *((float *)this + 28);
}

uint64_t OpenSteer::SimpleVehicle::setMaxSpeed(uint64_t this, float a2)
{
  *(float *)(this + 112) = a2;
  return this;
}

void sub_235EC5824(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10B1C4021E32345);
  _Unwind_Resume(a1);
}

void sub_235EC5A8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC5B6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC5CC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC5E38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC5EBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EC6794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_235EC69E4(_Unwind_Exception *a1)
{
  int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_235EC6A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC6A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC6A20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 == result) {
    return result;
  }
  while (1)
  {
    uint64_t v2 = a2[2];
    if (*(unsigned char *)(v2 + 24)) {
      return result;
    }
    int v3 = *(uint64_t **)(v2 + 16);
    uint64_t v4 = *v3;
    if (*v3 != v2) {
      break;
    }
    uint64_t v7 = v3[1];
    if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), int v5 = (unsigned char *)(v7 + 24), v8))
    {
      if (*(uint64_t **)v2 == a2)
      {
        *(unsigned char *)(v2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v11 = *(void *)(v2 + 8);
        uint64_t *v3 = v11;
        if (v11) {
          goto LABEL_15;
        }
      }
      else
      {
        float32x2_t v9 = *(uint64_t **)(v2 + 8);
        uint64_t v10 = *v9;
        *(void *)(v2 + 8) = *v9;
        if (v10)
        {
          *(void *)(v10 + 16) = v2;
          int v3 = *(uint64_t **)(v2 + 16);
        }
        v9[2] = (uint64_t)v3;
        *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
        *float32x2_t v9 = v2;
        *(void *)(v2 + 16) = v9;
        int v3 = (uint64_t *)v9[2];
        uint64_t v2 = *v3;
        *((unsigned char *)v9 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v11 = *(void *)(v2 + 8);
        uint64_t *v3 = v11;
        if (v11) {
LABEL_15:
        }
          *(void *)(v11 + 16) = v3;
      }
      *(void *)(v2 + 16) = v3[2];
      *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
      *(void *)(v2 + 8) = v3;
      v3[2] = v2;
      return result;
    }
LABEL_3:
    *(unsigned char *)(v2 + 24) = 1;
    a2 = v3;
    *((unsigned char *)v3 + 24) = v3 == result;
    *int v5 = 1;
    if (v3 == result) {
      return result;
    }
  }
  if (v4)
  {
    int v6 = *(unsigned __int8 *)(v4 + 24);
    int v5 = (unsigned char *)(v4 + 24);
    if (!v6) {
      goto LABEL_3;
    }
  }
  if (*(uint64_t **)v2 == a2)
  {
    uint64_t v12 = a2[1];
    *(void *)uint64_t v2 = v12;
    if (v12)
    {
      *(void *)(v12 + 16) = v2;
      int v3 = *(uint64_t **)(v2 + 16);
    }
    a2[2] = (uint64_t)v3;
    *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
    a2[1] = v2;
    *(void *)(v2 + 16) = a2;
    int v3 = (uint64_t *)a2[2];
  }
  else
  {
    a2 = (uint64_t *)a2[2];
  }
  *((unsigned char *)a2 + 24) = 1;
  *((unsigned char *)v3 + 24) = 0;
  float v13 = (uint64_t *)v3[1];
  uint64_t v14 = *v13;
  v3[1] = *v13;
  if (v14) {
    *(void *)(v14 + 16) = v3;
  }
  v13[2] = v3[2];
  *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v13;
  *float v13 = (uint64_t)v3;
  v3[2] = (uint64_t)v13;
  return result;
}

void sub_235EC6E48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC6FBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC6FD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC6FE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC6FFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7028(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GKCMinmaxStrategist::findBestMoveForPlayer(uint64_t a1, void *a2, int a3)
{
  id v6 = a2;
  id v7 = 0;
  if (v6 && *(void *)(a1 + 72))
  {
    *(unsigned char *)(a1 + 184) = objc_opt_respondsToSelector() & 1;
    *(unsigned char *)(a1 + 185) = objc_opt_respondsToSelector() & 1;
    *(unsigned char *)(a1 + 186) = objc_opt_respondsToSelector() & 1;
    int v8 = objc_msgSend(*(id *)(a1 + 72), "players", GKCMinmaxStrategist::clearData((GKCMinmaxStrategist *)a1));

    if (v8)
    {
      float32x2_t v9 = [*(id *)(a1 + 72) players];
      *(void *)(a1 + 120) = [v9 count];

      objc_storeStrong((id *)(a1 + 80), a2);
      if (*(uint64_t *)(a1 + 120) < 1) {
        goto LABEL_12;
      }
    }
    else
    {
      *(void *)(a1 + 120) = 0;
      objc_storeStrong((id *)(a1 + 80), a2);
      if (*(uint64_t *)(a1 + 120) < 1) {
        goto LABEL_12;
      }
    }
    uint64_t v10 = [*(id *)(a1 + 72) players];
    char v11 = [v10 containsObject:v6];

    if (v11)
    {
      if (*(uint64_t *)(a1 + 104) <= 0)
      {
        *(void *)(a1 + 104) = 1;
        uint64_t v12 = *(void *)(a1 + 96);
        if (v12 > 0)
        {
LABEL_10:
          uint64_t v13 = *(void *)a1;
          uint64_t v14 = *(void *)(a1 + 8);
          if (v14 == *(void *)a1)
          {
LABEL_21:
            *(void *)(a1 + 8) = v13;
            unint64_t v21 = (v13 - v14) >> 3;
            BOOL v17 = v12 >= v21;
            unint64_t v18 = v12 - v21;
            if (v12 > v21)
            {
LABEL_22:
              std::vector<objc_object  {objcproto11GKGameModel}* {__strong}>::__append((void **)a1, v18);
              goto LABEL_23;
            }
LABEL_17:
            if (!v17)
            {
              uint64_t v19 = v14 + 8 * v12;
              while (v13 != v19)
              {
                float v20 = *(void **)(v13 - 8);
                v13 -= 8;
              }
              *(void *)(a1 + 8) = v19;
            }
LABEL_23:
            if (*(uint64_t *)(a1 + 96) >= 1)
            {
              uint64_t v22 = 0;
              do
              {
                uint64_t v23 = [*(id *)(a1 + 72) copyWithZone:0];
                float v24 = *(void **)(*(void *)a1 + 8 * v22);
                *(void *)(*(void *)a1 + 8 * v22) = v23;

                ++v22;
              }
              while (v22 < *(void *)(a1 + 96));
            }
            uint64_t v92 = 0;
            uint64_t v93 = 0;
            id v25 = *(id *)(a1 + 72);
            if (*(unsigned char *)(a1 + 186))
            {
              uint64_t v26 = [*(id *)(a1 + 72) copyWithZone:0];

              id v25 = (id)v26;
            }
            if (*(void *)(a1 + 120) == 2)
            {
              GKCMinmaxStrategist::findBestMove2Player(a1, v25, *(void *)(a1 + 96), 0x8000000000000000, 0x7FFFFFFFFFFFFFFFLL, &v93, &v92);
            }
            else
            {
              float v28 = (void *)(a1 + 48);
              uint64_t v27 = *(void *)(a1 + 48);
              uint64_t v29 = *(void *)(a1 + 96);
              uint64_t v30 = *(void *)(a1 + 56);
              unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((v30 - v27) >> 3);
              if (v29 + 1 <= v31)
              {
                if (v29 + 1 < v31)
                {
                  uint64_t v32 = v27 + 24 * v29 + 24;
                  if (v30 != v32)
                  {
                    uint64_t v33 = *(void *)(a1 + 56);
                    do
                    {
                      unsigned __int32 v35 = *(void **)(v33 - 24);
                      v33 -= 24;
                      float32x4_t v34 = v35;
                      if (v35)
                      {
                        *(void *)(v30 - 16) = v34;
                        operator delete(v34);
                      }
                      uint64_t v30 = v33;
                    }
                    while (v33 != v32);
                  }
                  *(void *)(a1 + 56) = v32;
                }
              }
              else
              {
                std::vector<std::vector<long>>::__append(a1 + 48, v29 + 1 - v31);
              }
              uint64_t v36 = *(void *)(a1 + 96);
              if ((v36 & 0x8000000000000000) == 0)
              {
                uint64_t v37 = 0;
                uint64_t v38 = *(void *)(a1 + 120);
                do
                {
                  float v39 = (void *)(*v28 + 24 * v37);
                  unint64_t v40 = (uint64_t)(v39[1] - *v39) >> 3;
                  if (v38 <= v40)
                  {
                    if (v38 < v40) {
                      v39[1] = *v39 + 8 * v38;
                    }
                  }
                  else
                  {
                    std::vector<long>::__append((uint64_t)v39, v38 - v40);
                    uint64_t v38 = *(void *)(a1 + 120);
                  }
                  if (v38 >= 1)
                  {
                    uint64_t v41 = 0;
                    uint64_t v42 = *(void *)(*v28 + 24 * v37);
                    do
                    {
                      *(void *)(v42 + 8 * v41++) = 0;
                      uint64_t v38 = *(void *)(a1 + 120);
                    }
                    while (v41 < v38);
                  }
                  uint64_t v36 = *(void *)(a1 + 96);
                  BOOL v77 = v37++ < v36;
                }
                while (v77);
              }
              GKCMinmaxStrategist::findBestMoveNPlayer(a1, v25, v36, &v93, &v92);
            }
            unint64_t v43 = *(void *)(a1 + 40);
            if (!v43) {
              goto LABEL_123;
            }
            id v44 = (char *)(a1 + 24);
            std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#1}>(*(uint64_t **)(a1 + 32), (uint64_t *)(a1 + 24), v43, (uint64_t)&__p);
            long long v45 = *(char **)(a1 + 32);
            uint64_t v46 = *((void *)v45 + 4);
            if (v46 == -1)
            {
              std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#3}>(*(uint64_t **)(a1 + 32), (uint64_t *)(a1 + 24), *(void *)(a1 + 40), (uint64_t)&__p);
              uint64_t v49 = *(char **)(a1 + 32);
              if (v49 != v44)
              {
                uint64_t v50 = *((void *)v49 + 5);
                while (*((void *)v49 + 5) >= v50)
                {
                  uint64_t v49 = (char *)*((void *)v49 + 1);
                  if (v49 == v44) {
                    goto LABEL_111;
                  }
                }
                if (v49 != v44)
                {
                  for (uint64_t i = *((void *)v49 + 1); (char *)i != v44; uint64_t i = *(void *)(i + 8))
                  {
                    if (*(void *)(i + 40) >= v50)
                    {
                      objc_storeStrong((id *)v49 + 2, *(id *)(i + 16));
                      long long v58 = *(_OWORD *)(i + 24);
                      *((void *)v49 + 5) = *(void *)(i + 40);
                      *(_OWORD *)(v49 + 24) = v58;
                      uint64_t v49 = (char *)*((void *)v49 + 1);
                    }
                  }
                  if (v49 != v44)
                  {
                    uint64_t v68 = *(void *)v44;
                    uint64_t v69 = *(void *)v49;
                    *(void *)(v69 + 8) = *(void *)(*(void *)v44 + 8);
                    **(void **)(v68 + 8) = v69;
                    do
                    {
                      uint64_t v70 = (char *)*((void *)v49 + 1);
                      --*(void *)(a1 + 40);

                      operator delete(v49);
                      uint64_t v49 = v70;
                    }
                    while (v70 != v44);
                  }
                }
              }
            }
            else if (v46 == 1)
            {
              if (v45 != v44)
              {
                while (*((uint64_t *)v45 + 4) >= 1)
                {
                  long long v45 = (char *)*((void *)v45 + 1);
                  if (v45 == v44) {
                    goto LABEL_58;
                  }
                }
                if (v45 != v44)
                {
                  for (uint64_t j = *((void *)v45 + 1); (char *)j != v44; uint64_t j = *(void *)(j + 8))
                  {
                    if (*(uint64_t *)(j + 32) >= 1)
                    {
                      objc_storeStrong((id *)v45 + 2, *(id *)(j + 16));
                      long long v52 = *(_OWORD *)(j + 24);
                      *((void *)v45 + 5) = *(void *)(j + 40);
                      *(_OWORD *)(v45 + 24) = v52;
                      long long v45 = (char *)*((void *)v45 + 1);
                    }
                  }
                  if (v45 != v44)
                  {
                    uint64_t v59 = *(void *)v44;
                    long long v60 = *(void **)v45;
                    v60[1] = *(void *)(*(void *)v44 + 8);
                    **(void **)(v59 + 8) = v60;
                    do
                    {
                      long long v61 = (char *)*((void *)v45 + 1);
                      --*(void *)(a1 + 40);

                      operator delete(v45);
                      long long v45 = v61;
                    }
                    while (v61 != v44);
                  }
                }
              }
LABEL_58:
              std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#2}>(*(uint64_t **)(a1 + 32), (uint64_t *)(a1 + 24), *(void *)(a1 + 40), (uint64_t)&__p);
              uint64_t v47 = *(char **)(a1 + 32);
              if (v47 != v44)
              {
                uint64_t v48 = *((void *)v47 + 5);
                while (*((void *)v47 + 5) <= v48)
                {
                  uint64_t v47 = (char *)*((void *)v47 + 1);
                  if (v47 == v44) {
                    goto LABEL_111;
                  }
                }
                if (v47 != v44)
                {
                  for (uint64_t k = *((void *)v47 + 1); (char *)k != v44; uint64_t k = *(void *)(k + 8))
                  {
                    if (*(void *)(k + 40) <= v48)
                    {
                      objc_storeStrong((id *)v47 + 2, *(id *)(k + 16));
                      long long v56 = *(_OWORD *)(k + 24);
                      *((void *)v47 + 5) = *(void *)(k + 40);
                      *(_OWORD *)(v47 + 24) = v56;
                      uint64_t v47 = (char *)*((void *)v47 + 1);
                    }
                  }
                  if (v47 != v44)
                  {
                    uint64_t v65 = *(void *)v44;
                    uint64_t v66 = *(void *)v47;
                    *(void *)(v66 + 8) = *(void *)(*(void *)v44 + 8);
                    **(void **)(v65 + 8) = v66;
                    do
                    {
                      long long v67 = (char *)*((void *)v47 + 1);
                      --*(void *)(a1 + 40);

                      operator delete(v47);
                      uint64_t v47 = v67;
                    }
                    while (v67 != v44);
                  }
                }
              }
            }
            else
            {
              while (v45 != v44)
              {
                if ((*((void *)v45 + 4) & 0x8000000000000000) != 0)
                {
                  if (v45 != v44)
                  {
                    for (uint64_t m = *((void *)v45 + 1); (char *)m != v44; uint64_t m = *(void *)(m + 8))
                    {
                      if ((*(void *)(m + 32) & 0x8000000000000000) == 0)
                      {
                        objc_storeStrong((id *)v45 + 2, *(id *)(m + 16));
                        long long v54 = *(_OWORD *)(m + 24);
                        *((void *)v45 + 5) = *(void *)(m + 40);
                        *(_OWORD *)(v45 + 24) = v54;
                        long long v45 = (char *)*((void *)v45 + 1);
                      }
                    }
                    if (v45 != v44)
                    {
                      uint64_t v62 = *(void *)v44;
                      long long v63 = *(void **)v45;
                      v63[1] = *(void *)(*(void *)v44 + 8);
                      **(void **)(v62 + 8) = v63;
                      do
                      {
                        id v64 = (char *)*((void *)v45 + 1);
                        --*(void *)(a1 + 40);

                        operator delete(v45);
                        long long v45 = v64;
                      }
                      while (v64 != v44);
                    }
                  }
                  break;
                }
                long long v45 = (char *)*((void *)v45 + 1);
              }
              std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#3}>(*(uint64_t **)(a1 + 32), (uint64_t *)(a1 + 24), *(void *)(a1 + 40), (uint64_t)&__p);
            }
LABEL_111:
            std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#5}>(*(uint64_t **)(a1 + 32), (uint64_t *)(a1 + 24), *(void *)(a1 + 40), (uint64_t)&__p);
            uint64_t v71 = *(void **)(a1 + 88);
            if (a3)
            {
              if (v71)
              {
                uint64_t v72 = *(void *)(a1 + 40);
                if (*(void *)(a1 + 104) < v72) {
                  uint64_t v72 = *(void *)(a1 + 104);
                }
                uint64_t v73 = [v71 nextIntWithUpperBound:(int)v72];
                unint64_t v74 = *(char **)(a1 + 32);
                BOOL v75 = v74 != v44;
                if (v74 != v44 && v73 >= 1)
                {
                  uint64_t v76 = 1;
                  do
                  {
                    unint64_t v74 = (char *)*((void *)v74 + 1);
                    BOOL v75 = v74 != v44;
                    BOOL v77 = v74 != v44 && v76++ < v73;
                  }
                  while (v77);
                }
                if (!v75)
                {
LABEL_123:
                  id v7 = 0;
LABEL_140:
                  GKCMinmaxStrategist::clearData((GKCMinmaxStrategist *)a1);

                  goto LABEL_141;
                }
LABEL_133:
                id v7 = *((id *)v74 + 2);
                goto LABEL_140;
              }
            }
            else if (v71)
            {
              uint64_t v78 = *(void *)(a1 + 32);
              uint64_t v79 = *(void *)(v78 + 24);
              __p = 0;
              uint64_t v90 = 0;
              unint64_t v91 = 0;
              if ((char *)v78 == v44)
              {
                unint64_t v82 = 0;
                uint64_t v80 = 0;
              }
              else
              {
                uint64_t v80 = 0;
                while (*(void *)(v78 + 24) >= v79)
                {
                  id v81 = (id *)(v78 + 16);
                  if ((unint64_t)v80 < v91)
                  {
                    *(void *)uint64_t v80 = *v81;
                    v80 += 8;
                    uint64_t v90 = v80;
                    uint64_t v78 = *(void *)(v78 + 8);
                    if ((char *)v78 == v44) {
                      break;
                    }
                  }
                  else
                  {
                    uint64_t v80 = (char *)std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(&__p, v81);
                    uint64_t v90 = v80;
                    uint64_t v78 = *(void *)(v78 + 8);
                    if ((char *)v78 == v44) {
                      break;
                    }
                  }
                }
                uint64_t v71 = *(void **)(a1 + 88);
                unint64_t v82 = __p;
              }
              uint64_t v83 = [v71 nextIntWithUpperBound:(int)((v80 - v82) >> 3)];
              float v84 = (char *)__p;
              id v7 = *((id *)__p + v83);
              if (v84)
              {
                float v85 = v90;
                float v86 = v84;
                if (v90 != v84)
                {
                  do
                  {
                    float32x2_t v87 = (void *)*((void *)v85 - 1);
                    v85 -= 8;
                  }
                  while (v85 != v84);
                  float v86 = __p;
                }
                uint64_t v90 = v84;
                operator delete(v86);
              }
              goto LABEL_140;
            }
            unint64_t v74 = *(char **)(a1 + 32);
            goto LABEL_133;
          }
          do
          {
LABEL_15:
            float32x4_t v15 = *(void **)(v14 - 8);
            v14 -= 8;
          }
          while (v14 != v13);
          uint64_t v12 = *(void *)(a1 + 96);
          uint64_t v14 = *(void *)a1;
          *(void *)(a1 + 8) = v13;
          unint64_t v16 = (v13 - v14) >> 3;
          BOOL v17 = v12 >= v16;
          unint64_t v18 = v12 - v16;
          if (v12 > v16) {
            goto LABEL_22;
          }
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v12 = *(void *)(a1 + 96);
        if (v12 > 0) {
          goto LABEL_10;
        }
      }
      uint64_t v12 = 1;
      *(void *)(a1 + 96) = 1;
      uint64_t v13 = *(void *)a1;
      uint64_t v14 = *(void *)(a1 + 8);
      if (v14 == *(void *)a1) {
        goto LABEL_21;
      }
      goto LABEL_15;
    }
LABEL_12:
    id v7 = 0;
  }
LABEL_141:

  return v7;
}

void sub_235EC78E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);

  _Unwind_Resume(a1);
}

void sub_235EC797C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC79A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC79B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC79CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC79DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7AA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7ABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7AD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7BB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC7BCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCMinmaxStrategist::~GKCMinmaxStrategist(id *this)
{
  uint64_t v2 = (char *)this[6];
  if (v2)
  {
    int v3 = (char *)this[7];
    id v4 = this[6];
    if (v3 != v2)
    {
      int v5 = (char *)this[7];
      do
      {
        id v7 = (void *)*((void *)v5 - 3);
        v5 -= 24;
        id v6 = v7;
        if (v7)
        {
          *((void *)v3 - 2) = v6;
          operator delete(v6);
        }
        int v3 = v5;
      }
      while (v5 != v2);
      id v4 = this[6];
    }
    this[7] = v2;
    operator delete(v4);
  }
  if (this[5])
  {
    int v8 = this[3];
    float32x2_t v9 = (GKCMinmaxStrategist *)this[4];
    uint64_t v10 = *(void *)v9;
    *(void *)(v10 + 8) = v8[1];
    *(void *)v8[1] = v10;
    this[5] = 0;
    if (v9 != (GKCMinmaxStrategist *)(this + 3))
    {
      do
      {
        char v11 = (GKCMinmaxStrategist *)*((void *)v9 + 1);

        operator delete(v9);
        float32x2_t v9 = v11;
      }
      while (v11 != (GKCMinmaxStrategist *)(this + 3));
    }
  }
  uint64_t v12 = (char *)*this;
  if (*this)
  {
    uint64_t v13 = (char *)this[1];
    id v14 = *this;
    if (v13 != v12)
    {
      do
      {
        float32x4_t v15 = (void *)*((void *)v13 - 1);
        v13 -= 8;
      }
      while (v13 != v12);
      id v14 = *this;
    }
    this[1] = v12;
    operator delete(v14);
  }
}

double GKCMinmaxStrategist::clearData(GKCMinmaxStrategist *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  if (v3 != *(void *)this)
  {
    do
    {
      id v4 = *(void **)(v3 - 8);
      v3 -= 8;
    }
    while (v3 != v2);
  }
  *((void *)this + 1) = v2;
  if (*((void *)this + 5))
  {
    uint64_t v5 = *((void *)this + 3);
    id v6 = (GKCMinmaxStrategist *)*((void *)this + 4);
    uint64_t v7 = *(void *)v6;
    *(void *)(v7 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v7;
    *((void *)this + 5) = 0;
    if (v6 != (GKCMinmaxStrategist *)((char *)this + 24))
    {
      do
      {
        int v8 = (GKCMinmaxStrategist *)*((void *)v6 + 1);

        operator delete(v6);
        id v6 = v8;
      }
      while (v8 != (GKCMinmaxStrategist *)((char *)this + 24));
    }
  }
  uint64_t v10 = *((void *)this + 6);
  uint64_t v9 = *((void *)this + 7);
  if (v9 != v10)
  {
    uint64_t v11 = *((void *)this + 7);
    do
    {
      uint64_t v13 = *(void **)(v11 - 24);
      v11 -= 24;
      uint64_t v12 = v13;
      if (v13)
      {
        *(void *)(v9 - 16) = v12;
        operator delete(v12);
      }
      uint64_t v9 = v11;
    }
    while (v11 != v10);
  }
  *((void *)this + 7) = v10;
  id v14 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;

  *((void *)this + 14) = 0;
  double result = 0.0;
  *((_OWORD *)this + 9) = xmmword_235F1EFB0;
  *((_OWORD *)this + 10) = xmmword_235F1EFC0;
  *((void *)this + 22) = -1;
  return result;
}

uint64_t GKCMinmaxStrategist::findBestMove2Player(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  id v13 = a2;
  id v14 = v13;
  ++*(void *)(a1 + 128);
  if (*(unsigned char *)(a1 + 184) && ([v13 isWinForPlayer:*(void *)(a1 + 80)] & 1) != 0)
  {
    uint64_t v15 = 1;
  }
  else if (*(unsigned char *)(a1 + 185) && ([v14 isLossForPlayer:*(void *)(a1 + 80)] & 1) != 0)
  {
    uint64_t v15 = -1;
  }
  else
  {
    uint64_t v15 = 0;
  }
  *a6 = v15;
  *a7 = *(void *)(a1 + 96) - a3;
  if (*a6 == 1)
  {
    uint64_t v16 = 0x1000000;
    goto LABEL_47;
  }
  if (*a6 != -1)
  {
    if (a3 <= 0)
    {
      uint64_t v16 = [v14 scoreForPlayer:*(void *)(a1 + 80)];
      goto LABEL_47;
    }
    BOOL v17 = [v14 activePlayer];
    uint64_t v32 = [v17 playerId];
    uint64_t v30 = [*(id *)(a1 + 80) playerId];
    if (v32 == v30) {
      uint64_t v16 = 0x8000000000000000;
    }
    else {
      uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
    }
    uint64_t v33 = [v14 gameModelUpdatesForPlayer:v17];
    uint64_t v18 = [v33 count];
    if (v18)
    {
      uint64_t v31 = v18;
      uint64_t v27 = v17;
      float v28 = v14;
      uint64_t v29 = a7;
      *a7 = *(void *)(a1 + 96) + 1;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      id v19 = *(id *)(*(void *)a1 + 8 * a3 - 8);
      if (*(unsigned char *)(a1 + 186))
      {
        id v20 = v14;

        id v19 = v20;
      }
      if (v31 >= 1)
      {
        for (uint64_t i = 0; v31 != i; ++i)
        {
          if (!*(unsigned char *)(a1 + 186)) {
            [v19 setGameModel:v28];
          }
          uint64_t v22 = objc_msgSend(v33, "objectAtIndexedSubscript:", i, v27);
          [v19 applyGameModelUpdate:v22];
          uint64_t BestMove2Player = GKCMinmaxStrategist::findBestMove2Player(a1, v19, a3 - 1, a4, a5, &v35, &v34);
          [v22 setValue:BestMove2Player];
          if (*(unsigned char *)(a1 + 186)) {
            [v19 unapplyGameModelUpdate:v22];
          }
          if (v32 == v30)
          {
            if (BestMove2Player > a4) {
              a4 = BestMove2Player;
            }
            BOOL v24 = BestMove2Player == v16;
            if (BestMove2Player > v16) {
              goto LABEL_29;
            }
          }
          else
          {
            if (BestMove2Player < a5) {
              a5 = BestMove2Player;
            }
            BOOL v24 = BestMove2Player == v16;
            if (BestMove2Player < v16)
            {
LABEL_29:
              uint64_t v25 = v34;
LABEL_30:
              *a6 = v35;
              *uint64_t v29 = v25;
              uint64_t v16 = BestMove2Player;
              goto LABEL_37;
            }
          }
          if (v24)
          {
            uint64_t v25 = v34;
            if (v34 < *v29) {
              goto LABEL_30;
            }
          }
LABEL_37:
          if (*(void *)(a1 + 96) == a3) {
            GKCMinmaxStrategist::addMoveToConsideredMoves((void *)a1, v22, BestMove2Player, v35, v34);
          }
          if (a5 <= a4)
          {
            *(void *)(a1 + 136) += v31 + ~i;

            break;
          }
        }
      }

      BOOL v17 = v27;
      id v14 = v28;
    }
    else
    {
      uint64_t v16 = [v14 scoreForPlayer:*(void *)(a1 + 80)];
    }

    goto LABEL_47;
  }
  uint64_t v16 = -16777216;
LABEL_47:

  return v16;
}

void sub_235EC8104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  id v19 = v17;

  _Unwind_Resume(a1);
}

void GKCMinmaxStrategist::findBestMoveNPlayer(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4, void *a5)
{
  id v8 = a2;
  uint64_t v9 = v8;
  ++*(void *)(a1 + 128);
  if (*(unsigned char *)(a1 + 184) && ([v8 isWinForPlayer:*(void *)(a1 + 80)] & 1) != 0)
  {
    uint64_t v10 = 1;
  }
  else if (*(unsigned char *)(a1 + 185) && ([v9 isLossForPlayer:*(void *)(a1 + 80)] & 1) != 0)
  {
    uint64_t v10 = -1;
  }
  else
  {
    uint64_t v10 = 0;
  }
  *a4 = v10;
  *a5 = *(void *)(a1 + 96) - a3;
  if (a3 < 1 || *a4)
  {
    GKCMinmaxStrategist::getScores(a1, v9, a3);
  }
  else
  {
    uint64_t v11 = [v9 activePlayer];
    uint64_t v12 = [v9 gameModelUpdatesForPlayer:v11];
    uint64_t v13 = [v12 count];
    if (v13)
    {
      uint64_t v34 = v12;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      id v14 = *(id *)(*(void *)a1 + 8 * a3 - 8);
      if (*(unsigned char *)(a1 + 186))
      {
        id v15 = v9;

        id v14 = v15;
      }
      uint64_t v16 = *(void *)(a1 + 48);
      uint64_t v32 = v9;
      BOOL v17 = objc_msgSend(*(id *)(a1 + 72), "players", v11);
      uint64_t v18 = [v17 indexOfObject:v11];
      uint64_t v33 = a4;
      id v19 = (uint64_t *)(v16 + 24 * a3);

      if (*(uint64_t *)(a1 + 120) >= 1)
      {
        uint64_t v20 = 0;
        uint64_t v21 = *v19;
        do
          *(void *)(v21 + 8 * v20++) = 0x8000000000000000;
        while (v20 < *(void *)(a1 + 120));
      }
      if (v13 >= 1)
      {
        uint64_t v22 = 0;
        uint64_t v23 = 8 * v18;
        do
        {
          if (!*(unsigned char *)(a1 + 186)) {
            [v14 setGameModel:v32];
          }
          BOOL v24 = [v34 objectAtIndexedSubscript:v22];
          [v14 applyGameModelUpdate:v24];
          GKCMinmaxStrategist::findBestMoveNPlayer(a1, v14, a3 - 1, &v37, &v36);
          uint64_t v25 = *(void *)(a1 + 48);
          if (*(unsigned char *)(a1 + 186)) {
            [v14 unapplyGameModelUpdate:v24];
          }
          uint64_t v26 = *(void *)(v25 + 24 * a3 - 24);
          uint64_t v27 = *(void *)(v26 + v23);
          uint64_t v28 = *v19;
          uint64_t v29 = *(void *)(*v19 + v23);
          if (v27 > v29 || v27 == v29 && v36 < *a5)
          {
            if (*(uint64_t *)(a1 + 120) >= 1)
            {
              uint64_t v30 = 0;
              do
              {
                *(void *)(v28 + 8 * v30) = *(void *)(v26 + 8 * v30);
                ++v30;
              }
              while (v30 < *(void *)(a1 + 120));
            }
            uint64_t *v33 = v37;
            *a5 = v36;
          }
          [v24 setValue:v27];
          if (*(void *)(a1 + 96) == a3) {
            GKCMinmaxStrategist::addMoveToConsideredMoves((void *)a1, v24, v27, v37, v36);
          }

          ++v22;
        }
        while (v22 != v13);
      }

      uint64_t v11 = v31;
      uint64_t v9 = v32;
      uint64_t v12 = v34;
    }
    else
    {
      GKCMinmaxStrategist::getScores(a1, v9, a3);
    }
  }
}

void sub_235EC84C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void std::vector<objc_object  {objcproto11GKGameModel}* {__strong}>::__append(void **a1, unint64_t a2)
{
  uint64_t v5 = (char *)a1[1];
  id v4 = a1[2];
  id v6 = v5;
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      id v6 = &v5[8 * a2];
    }
    a1[1] = v6;
  }
  else
  {
    uint64_t v7 = (char *)*a1;
    uint64_t v8 = v5 - (unsigned char *)*a1;
    uint64_t v9 = v8 >> 3;
    unint64_t v10 = (v8 >> 3) + a2;
    if (v10 >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v11 = v4 - v7;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    id v14 = &v13[8 * v9];
    size_t v15 = 8 * a2;
    uint64_t v16 = &v13[8 * v12];
    bzero(v14, v15);
    BOOL v17 = &v14[v15];
    if (v5 == v7)
    {
      *a1 = v14;
      a1[1] = v17;
      a1[2] = v16;
      if (!v5) {
        return;
      }
      goto LABEL_27;
    }
    unint64_t v18 = v5 - v7 - 8;
    if (v18 < 0x78 || &v5[-(v18 & 0xFFFFFFFFFFFFFFF8) - 8] < v14 && &v13[v8 - (v18 & 0xFFFFFFFFFFFFFFF8) - 8] < v5) {
      goto LABEL_36;
    }
    uint64_t v19 = (v18 >> 3) + 1;
    uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    v14 -= v20;
    id v6 = &v5[-v20];
    uint64_t v21 = v5 - 16;
    uint64_t v22 = &v13[8 * v9 - 16];
    uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v25 = *((_OWORD *)v21 - 1);
      long long v24 = *(_OWORD *)v21;
      *((_OWORD *)v21 - 1) = 0uLL;
      *(_OWORD *)uint64_t v21 = 0uLL;
      *((_OWORD *)v22 - 1) = v25;
      *(_OWORD *)uint64_t v22 = v24;
      v21 -= 32;
      v22 -= 32;
      v23 -= 4;
    }
    while (v23);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_36:
      do
      {
        uint64_t v26 = *((void *)v6 - 1);
        v6 -= 8;
        *(void *)id v6 = 0;
        *((void *)v14 - 1) = v26;
        v14 -= 8;
      }
      while (v6 != v7);
    }
    uint64_t v27 = (char *)*a1;
    id v6 = (char *)a1[1];
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v16;
    if (v6 != v27)
    {
      do
      {
        uint64_t v28 = (void *)*((void *)v6 - 1);
        v6 -= 8;
      }
      while (v6 != v27);
      id v6 = v27;
    }
    if (v6)
    {
LABEL_27:
      operator delete(v6);
    }
  }
}

void GKCMinmaxStrategist::addMoveToConsideredMoves(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v9 = a2;
  unint64_t v10 = operator new(0x30uLL);
  id v12 = v9;
  v10[2] = v12;
  _DWORD v10[3] = a3;
  v10[4] = a4;
  v10[5] = a5;
  uint64_t v11 = a1[3];
  a1 += 3;
  *unint64_t v10 = v11;
  v10[1] = a1;
  *(void *)(v11 + 8) = v10;
  *a1 = v10;
  ++a1[2];
}

void sub_235EC8804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<std::vector<long>>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = *(void **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v12 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(a1 + 8), v12);
      uint64_t v5 = (void *)((char *)v5 + v12);
    }
    *(void *)(a1 + 8) = v5;
  }
  else
  {
    id v6 = *(void **)a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *(void *)a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0xAAAAAAAAAAAAAAALL) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v11 = (char *)operator new(24 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v13 = &v11[24 * v7];
    id v14 = &v11[24 * v10];
    size_t v15 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v13, v15);
    uint64_t v16 = &v13[v15];
    if (v5 == v6)
    {
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (!v5) {
        return;
      }
      goto LABEL_24;
    }
    do
    {
      BOOL v17 = v13;
      *((void *)v13 - 2) = 0;
      *((void *)v13 - 1) = 0;
      long long v18 = *(_OWORD *)(v5 - 3);
      v5 -= 3;
      *(_OWORD *)(v13 - 24) = v18;
      v13 -= 24;
      *((void *)v17 - 1) = v5[2];
      *uint64_t v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
    }
    while (v5 != v6);
    uint64_t v19 = *(void **)a1;
    uint64_t v5 = *(void **)(a1 + 8);
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v16;
    *(void *)(a1 + 16) = v14;
    if (v5 != v19)
    {
      uint64_t v20 = v5;
      do
      {
        uint64_t v22 = (void *)*(v20 - 3);
        v20 -= 3;
        uint64_t v21 = v22;
        if (v22)
        {
          *(v5 - 2) = v21;
          operator delete(v21);
        }
        uint64_t v5 = v20;
      }
      while (v20 != v19);
      uint64_t v5 = v19;
    }
    if (v5)
    {
LABEL_24:
      operator delete(v5);
    }
  }
}

void std::vector<long>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  id v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      id v6 = &v5[8 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    unint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 3;
    unint64_t v10 = (v8 >> 3) + a2;
    if (v10 >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v13 = operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    id v14 = &v13[8 * v9];
    size_t v15 = 8 * a2;
    uint64_t v16 = &v13[8 * v12];
    bzero(v14, v15);
    BOOL v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 8;
      if (v18 < 0x58) {
        goto LABEL_31;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      id v6 = &v5[-v20];
      v14 -= v20;
      uint64_t v21 = &v13[8 * v9 - 16];
      uint64_t v22 = v5 - 16;
      uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *(_OWORD *)v22;
        *(v21 - 1) = *((_OWORD *)v22 - 1);
        *uint64_t v21 = v24;
        v21 -= 2;
        v22 -= 32;
        v23 -= 4;
      }
      while (v23);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_31:
        do
        {
          uint64_t v25 = *((void *)v6 - 1);
          v6 -= 8;
          *((void *)v14 - 1) = v25;
          v14 -= 8;
        }
        while (v6 != v7);
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void GKCMinmaxStrategist::getScores(uint64_t a1, void *a2, uint64_t a3)
{
  id v10 = a2;
  uint64_t v5 = *(void *)(a1 + 48);
  id v6 = [*(id *)(a1 + 72) players];
  unint64_t v7 = 0;
  uint64_t v8 = (void *)(v5 + 24 * a3);
  while (v7 < [v6 count])
  {
    uint64_t v9 = [v6 objectAtIndexedSubscript:v7];
    *(void *)(*v8 + 8 * v7) = [v10 scoreForPlayer:v9];

    ++v7;
  }
}

void sub_235EC8C88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EC8C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EC8CB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t *std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#1}>(uint64_t *result, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  if (a3 < 2) {
    return result;
  }
  if (a3 == 2)
  {
    uint64_t v5 = (uint64_t *)*a2;
    if (*(void *)(*a2 + 32) > result[4])
    {
      uint64_t v6 = *v5;
      *(void *)(v6 + 8) = v5[1];
      *(void *)v5[1] = v6;
      uint64_t v7 = *result;
      *(void *)(v7 + 8) = v5;
      *uint64_t v5 = v7;
      void *result = (uint64_t)v5;
      v5[1] = (uint64_t)result;
      return v5;
    }
    return result;
  }
  unint64_t v10 = a3 >> 1;
  unint64_t v11 = (a3 >> 1) + 1;
  unint64_t v12 = result;
  do
  {
    unint64_t v12 = (uint64_t *)v12[1];
    --v11;
  }
  while (v11 > 1);
  uint64_t v13 = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#1}>(result, v12, a3 >> 1, a4);
  double result = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#1}>(v12, a2, a3 - v10, a4);
  uint64_t v14 = v13[4];
  if (result[4] <= v14)
  {
    unint64_t v18 = (uint64_t *)v13[1];
    size_t v15 = result;
    double result = v13;
    if (v18 == v15) {
      return result;
    }
    goto LABEL_15;
  }
  size_t v15 = (uint64_t *)result[1];
  if (v15 == a2)
  {
LABEL_11:
    size_t v15 = a2;
  }
  else
  {
    while (v15[4] > v14)
    {
      size_t v15 = (uint64_t *)v15[1];
      if (v15 == a2) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v16 = *v15;
  uint64_t v17 = *result;
  *(void *)(v17 + 8) = *(void *)(*v15 + 8);
  **(void **)(v16 + 8) = v17;
  uint64_t v19 = *v13;
  unint64_t v18 = (uint64_t *)v13[1];
  *(void *)(v19 + 8) = result;
  void *result = v19;
  *uint64_t v13 = v16;
  *(void *)(v16 + 8) = v13;
  if (v18 != v15)
  {
LABEL_15:
    if (v15 != a2)
    {
      uint64_t v20 = v15;
      do
      {
        uint64_t v21 = v18[4];
        if (v15[4] <= v21)
        {
          unint64_t v18 = (uint64_t *)v18[1];
          if (v18 == v20) {
            return result;
          }
        }
        else
        {
          uint64_t v22 = (uint64_t *)v15[1];
          if (v22 == a2)
          {
LABEL_21:
            uint64_t v22 = a2;
          }
          else
          {
            while (v22[4] > v21)
            {
              uint64_t v22 = (uint64_t *)v22[1];
              if (v22 == a2) {
                goto LABEL_21;
              }
            }
          }
          uint64_t v23 = *v22;
          uint64_t v24 = *v15;
          *(void *)(v24 + 8) = *(void *)(*v22 + 8);
          **(void **)(v23 + 8) = v24;
          if (v20 == v15) {
            uint64_t v20 = v22;
          }
          uint64_t v26 = *v18;
          uint64_t v25 = (uint64_t *)v18[1];
          *(void *)(v26 + 8) = v15;
          *size_t v15 = v26;
          uint64_t *v18 = v23;
          *(void *)(v23 + 8) = v18;
          unint64_t v18 = v25;
          size_t v15 = v22;
          if (v25 == v20) {
            return result;
          }
        }
      }
      while (v15 != a2);
    }
  }
  return result;
}

uint64_t *std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#2}>(uint64_t *result, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  if (a3 < 2) {
    return result;
  }
  if (a3 == 2)
  {
    uint64_t v5 = (uint64_t *)*a2;
    if (*(void *)(*a2 + 40) < result[5])
    {
      uint64_t v6 = *v5;
      *(void *)(v6 + 8) = v5[1];
      *(void *)v5[1] = v6;
      uint64_t v7 = *result;
      *(void *)(v7 + 8) = v5;
      *uint64_t v5 = v7;
      void *result = (uint64_t)v5;
      v5[1] = (uint64_t)result;
      return v5;
    }
    return result;
  }
  unint64_t v10 = a3 >> 1;
  unint64_t v11 = (a3 >> 1) + 1;
  unint64_t v12 = result;
  do
  {
    unint64_t v12 = (uint64_t *)v12[1];
    --v11;
  }
  while (v11 > 1);
  uint64_t v13 = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#2}>(result, v12, a3 >> 1, a4);
  double result = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#2}>(v12, a2, a3 - v10, a4);
  uint64_t v14 = v13[5];
  if (result[5] >= v14)
  {
    unint64_t v18 = (uint64_t *)v13[1];
    size_t v15 = result;
    double result = v13;
    if (v18 == v15) {
      return result;
    }
    goto LABEL_15;
  }
  size_t v15 = (uint64_t *)result[1];
  if (v15 == a2)
  {
LABEL_11:
    size_t v15 = a2;
  }
  else
  {
    while (v15[5] < v14)
    {
      size_t v15 = (uint64_t *)v15[1];
      if (v15 == a2) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v16 = *v15;
  uint64_t v17 = *result;
  *(void *)(v17 + 8) = *(void *)(*v15 + 8);
  **(void **)(v16 + 8) = v17;
  uint64_t v19 = *v13;
  unint64_t v18 = (uint64_t *)v13[1];
  *(void *)(v19 + 8) = result;
  void *result = v19;
  *uint64_t v13 = v16;
  *(void *)(v16 + 8) = v13;
  if (v18 != v15)
  {
LABEL_15:
    if (v15 != a2)
    {
      uint64_t v20 = v15;
      do
      {
        uint64_t v21 = v18[5];
        if (v15[5] >= v21)
        {
          unint64_t v18 = (uint64_t *)v18[1];
          if (v18 == v20) {
            return result;
          }
        }
        else
        {
          uint64_t v22 = (uint64_t *)v15[1];
          if (v22 == a2)
          {
LABEL_21:
            uint64_t v22 = a2;
          }
          else
          {
            while (v22[5] < v21)
            {
              uint64_t v22 = (uint64_t *)v22[1];
              if (v22 == a2) {
                goto LABEL_21;
              }
            }
          }
          uint64_t v23 = *v22;
          uint64_t v24 = *v15;
          *(void *)(v24 + 8) = *(void *)(*v22 + 8);
          **(void **)(v23 + 8) = v24;
          if (v20 == v15) {
            uint64_t v20 = v22;
          }
          uint64_t v26 = *v18;
          uint64_t v25 = (uint64_t *)v18[1];
          *(void *)(v26 + 8) = v15;
          *size_t v15 = v26;
          uint64_t *v18 = v23;
          *(void *)(v23 + 8) = v18;
          unint64_t v18 = v25;
          size_t v15 = v22;
          if (v25 == v20) {
            return result;
          }
        }
      }
      while (v15 != a2);
    }
  }
  return result;
}

uint64_t *std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#3}>(uint64_t *result, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  if (a3 < 2) {
    return result;
  }
  if (a3 == 2)
  {
    uint64_t v5 = (uint64_t *)*a2;
    if (*(void *)(*a2 + 40) > result[5])
    {
      uint64_t v6 = *v5;
      *(void *)(v6 + 8) = v5[1];
      *(void *)v5[1] = v6;
      uint64_t v7 = *result;
      *(void *)(v7 + 8) = v5;
      *uint64_t v5 = v7;
      void *result = (uint64_t)v5;
      v5[1] = (uint64_t)result;
      return v5;
    }
    return result;
  }
  unint64_t v10 = a3 >> 1;
  unint64_t v11 = (a3 >> 1) + 1;
  unint64_t v12 = result;
  do
  {
    unint64_t v12 = (uint64_t *)v12[1];
    --v11;
  }
  while (v11 > 1);
  uint64_t v13 = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#3}>(result, v12, a3 >> 1, a4);
  double result = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#3}>(v12, a2, a3 - v10, a4);
  uint64_t v14 = v13[5];
  if (result[5] <= v14)
  {
    unint64_t v18 = (uint64_t *)v13[1];
    size_t v15 = result;
    double result = v13;
    if (v18 == v15) {
      return result;
    }
    goto LABEL_15;
  }
  size_t v15 = (uint64_t *)result[1];
  if (v15 == a2)
  {
LABEL_11:
    size_t v15 = a2;
  }
  else
  {
    while (v15[5] > v14)
    {
      size_t v15 = (uint64_t *)v15[1];
      if (v15 == a2) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v16 = *v15;
  uint64_t v17 = *result;
  *(void *)(v17 + 8) = *(void *)(*v15 + 8);
  **(void **)(v16 + 8) = v17;
  uint64_t v19 = *v13;
  unint64_t v18 = (uint64_t *)v13[1];
  *(void *)(v19 + 8) = result;
  void *result = v19;
  *uint64_t v13 = v16;
  *(void *)(v16 + 8) = v13;
  if (v18 != v15)
  {
LABEL_15:
    if (v15 != a2)
    {
      uint64_t v20 = v15;
      do
      {
        uint64_t v21 = v18[5];
        if (v15[5] <= v21)
        {
          unint64_t v18 = (uint64_t *)v18[1];
          if (v18 == v20) {
            return result;
          }
        }
        else
        {
          uint64_t v22 = (uint64_t *)v15[1];
          if (v22 == a2)
          {
LABEL_21:
            uint64_t v22 = a2;
          }
          else
          {
            while (v22[5] > v21)
            {
              uint64_t v22 = (uint64_t *)v22[1];
              if (v22 == a2) {
                goto LABEL_21;
              }
            }
          }
          uint64_t v23 = *v22;
          uint64_t v24 = *v15;
          *(void *)(v24 + 8) = *(void *)(*v22 + 8);
          **(void **)(v23 + 8) = v24;
          if (v20 == v15) {
            uint64_t v20 = v22;
          }
          uint64_t v26 = *v18;
          uint64_t v25 = (uint64_t *)v18[1];
          *(void *)(v26 + 8) = v15;
          *size_t v15 = v26;
          uint64_t *v18 = v23;
          *(void *)(v23 + 8) = v18;
          unint64_t v18 = v25;
          size_t v15 = v22;
          if (v25 == v20) {
            return result;
          }
        }
      }
      while (v15 != a2);
    }
  }
  return result;
}

uint64_t *std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#5}>(uint64_t *result, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  if (a3 < 2) {
    return result;
  }
  if (a3 == 2)
  {
    uint64_t v5 = (uint64_t *)*a2;
    if (*(void *)(*a2 + 24) > result[3])
    {
      uint64_t v6 = *v5;
      *(void *)(v6 + 8) = v5[1];
      *(void *)v5[1] = v6;
      uint64_t v7 = *result;
      *(void *)(v7 + 8) = v5;
      *uint64_t v5 = v7;
      void *result = (uint64_t)v5;
      v5[1] = (uint64_t)result;
      return v5;
    }
    return result;
  }
  unint64_t v10 = a3 >> 1;
  unint64_t v11 = (a3 >> 1) + 1;
  unint64_t v12 = result;
  do
  {
    unint64_t v12 = (uint64_t *)v12[1];
    --v11;
  }
  while (v11 > 1);
  uint64_t v13 = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#5}>(result, v12, a3 >> 1, a4);
  double result = (uint64_t *)std::list<GKCMoveData>::__sort<GKCMinmaxStrategist::findBestMoveForPlayer(objc_object  {objcproto17GKGameModelPlayer}*,BOOL)::{lambda(GKCMoveData const&,GKCMoveData const)#5}>(v12, a2, a3 - v10, a4);
  uint64_t v14 = v13[3];
  if (result[3] <= v14)
  {
    unint64_t v18 = (uint64_t *)v13[1];
    size_t v15 = result;
    double result = v13;
    if (v18 == v15) {
      return result;
    }
    goto LABEL_15;
  }
  size_t v15 = (uint64_t *)result[1];
  if (v15 == a2)
  {
LABEL_11:
    size_t v15 = a2;
  }
  else
  {
    while (v15[3] > v14)
    {
      size_t v15 = (uint64_t *)v15[1];
      if (v15 == a2) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v16 = *v15;
  uint64_t v17 = *result;
  *(void *)(v17 + 8) = *(void *)(*v15 + 8);
  **(void **)(v16 + 8) = v17;
  uint64_t v19 = *v13;
  unint64_t v18 = (uint64_t *)v13[1];
  *(void *)(v19 + 8) = result;
  void *result = v19;
  *uint64_t v13 = v16;
  *(void *)(v16 + 8) = v13;
  if (v18 != v15)
  {
LABEL_15:
    if (v15 != a2)
    {
      uint64_t v20 = v15;
      do
      {
        uint64_t v21 = v18[3];
        if (v15[3] <= v21)
        {
          unint64_t v18 = (uint64_t *)v18[1];
          if (v18 == v20) {
            return result;
          }
        }
        else
        {
          uint64_t v22 = (uint64_t *)v15[1];
          if (v22 == a2)
          {
LABEL_21:
            uint64_t v22 = a2;
          }
          else
          {
            while (v22[3] > v21)
            {
              uint64_t v22 = (uint64_t *)v22[1];
              if (v22 == a2) {
                goto LABEL_21;
              }
            }
          }
          uint64_t v23 = *v22;
          uint64_t v24 = *v15;
          *(void *)(v24 + 8) = *(void *)(*v22 + 8);
          **(void **)(v23 + 8) = v24;
          if (v20 == v15) {
            uint64_t v20 = v22;
          }
          uint64_t v26 = *v18;
          uint64_t v25 = (uint64_t *)v18[1];
          *(void *)(v26 + 8) = v15;
          *size_t v15 = v26;
          uint64_t *v18 = v23;
          *(void *)(v23 + 8) = v18;
          unint64_t v18 = v25;
          size_t v15 = v22;
          if (v25 == v20) {
            return result;
          }
        }
      }
      while (v15 != a2);
    }
  }
  return result;
}

void sub_235EC9518(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC9634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EC96B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t p2t::SweepContext::SweepContext(uint64_t a1, char **a2)
{
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 104) = a1 + 104;
  *(void *)(a1 + 112) = a1 + 104;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(unsigned char *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  if ((char **)(a1 + 128) == a2)
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    unint64_t v10 = 0;
  }
  else
  {
    std::vector<p2t::Point *>::__assign_with_size[abi:ne180100]<p2t::Point **,p2t::Point **>((void *)(a1 + 128), *a2, a2[1], (a2[1] - *a2) >> 3);
    uint64_t v4 = *(unsigned char **)(a1 + 128);
    uint64_t v3 = *(unsigned char **)(a1 + 136);
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    uint64_t v8 = 0;
    int64_t v5 = v3 - v4;
    if (v3 == v4)
    {
      uint64_t v6 = 0;
    }
    else
    {
      if (v5 < 0) {
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
      uint64_t v6 = (char *)operator new(v3 - v4);
      uint64_t v8 = v6;
      unint64_t v10 = &v6[8 * (v5 >> 3)];
      memcpy(v6, v4, v5);
      uint64_t v9 = v10;
    }
  }
  p2t::SweepContext::InitEdges(a1, &v8);
  if (v6)
  {
    uint64_t v9 = v6;
    operator delete(v6);
  }
  return a1;
}

void sub_235EC9964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v16 = *v13;
  if (*v13)
  {
    *(void *)(v11 + 136) = v16;
    operator delete(v16);
    std::list<p2t::Triangle *>::~list(v12);
    uint64_t v17 = *v14;
    if (!*v14)
    {
LABEL_3:
      unint64_t v18 = *(void **)v11;
      if (!*(void *)v11) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    std::list<p2t::Triangle *>::~list(v12);
    uint64_t v17 = *v14;
    if (!*v14) {
      goto LABEL_3;
    }
  }
  *(void *)(v11 + 88) = v17;
  operator delete(v17);
  unint64_t v18 = *(void **)v11;
  if (!*(void *)v11) {
LABEL_4:
  }
    _Unwind_Resume(a1);
LABEL_7:
  *(void *)(v11 + 8) = v18;
  operator delete(v18);
  _Unwind_Resume(a1);
}

void p2t::SweepContext::InitEdges(uint64_t a1, void *a2)
{
  if ((int)((a2[1] - *a2) >> 3) >= 1) {
    operator new();
  }
}

void sub_235EC9C38(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

uint64_t *std::list<p2t::Triangle *>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        int64_t v5 = (uint64_t *)v2[1];
        operator delete(v2);
        uint64_t v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void p2t::SweepContext::AddHole(void *a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  int64_t v5 = (const void *)*a2;
  uint64_t v4 = a2[1];
  int64_t v6 = v4 - *a2;
  if (v4 == *a2)
  {
    uint64_t v7 = 0;
  }
  else
  {
    if (v6 < 0) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v7 = (char *)operator new(v4 - *a2);
    uint64_t v33 = v7;
    uint64_t v35 = &v7[8 * (v6 >> 3)];
    memcpy(v7, v5, v6);
    uint64_t v34 = v35;
  }
  p2t::SweepContext::InitEdges((uint64_t)a1, &v33);
  if (v7)
  {
    uint64_t v34 = v7;
    operator delete(v7);
  }
  uint64_t v8 = *v2;
  if (v2[1] != *v2)
  {
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    uint64_t v31 = v2;
    uint64_t v32 = (char **)(a1 + 16);
    uint64_t v11 = (char *)a1[17];
    while (1)
    {
      unint64_t v13 = a1[18];
      if ((unint64_t)v11 >= v13) {
        break;
      }
      *(void *)uint64_t v11 = *(void *)(v8 + 8 * v9);
      uint64_t v12 = (uint64_t)(v11 + 8);
LABEL_10:
      a1[17] = v12;
      uint64_t v8 = *v2;
      uint64_t v11 = (char *)v12;
      uint64_t v9 = ++v10;
      if (v10 >= (unint64_t)((uint64_t)(v2[1] - *v2) >> 3)) {
        return;
      }
    }
    uint64_t v14 = *v32;
    uint64_t v15 = v11 - *v32;
    uint64_t v16 = v15 >> 3;
    unint64_t v17 = (v15 >> 3) + 1;
    if (v17 >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v18 = v13 - (void)v14;
    if (v18 >> 2 > v17) {
      unint64_t v17 = v18 >> 2;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      if (v19 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v20 = operator new(8 * v19);
      uint64_t v21 = &v20[8 * v16];
      *uint64_t v21 = *(void *)(v8 + 8 * v9);
      uint64_t v12 = (uint64_t)(v21 + 1);
      if (v11 == v14) {
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v20 = 0;
      uint64_t v21 = (void *)(8 * v16);
      *(void *)(8 * v16) = *(void *)(v8 + 8 * v9);
      uint64_t v12 = 8 * v16 + 8;
      if (v11 == v14)
      {
LABEL_27:
        a1[16] = v21;
        a1[17] = v12;
        a1[18] = &v20[8 * v19];
        if (v11) {
          operator delete(v11);
        }
        uint64_t v2 = v31;
        goto LABEL_10;
      }
    }
    unint64_t v22 = v11 - 8 - v14;
    if (v22 >= 0x168)
    {
      if (&v20[v15 - 8 - (v22 & 0xFFFFFFFFFFFFFFF8)] > &v20[v15 - 8])
      {
        uint64_t v23 = v11;
      }
      else if (&v11[-(v22 & 0xFFFFFFFFFFFFFFF8) - 8] > v11 - 8)
      {
        uint64_t v23 = v11;
      }
      else if ((unint64_t)(v11 - &v20[v15]) >= 0x20)
      {
        uint64_t v25 = (v22 >> 3) + 1;
        uint64_t v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v23 = &v11[-v26];
        uint64_t v21 = (void *)((char *)v21 - v26);
        uint64_t v27 = &v20[8 * v16 - 16];
        uint64_t v28 = (long long *)(v11 - 16);
        uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v30 = *v28;
          *(v27 - 1) = *(v28 - 1);
          *uint64_t v27 = v30;
          v27 -= 2;
          v28 -= 2;
          v29 -= 4;
        }
        while (v29);
        if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v23 = v11;
      }
    }
    else
    {
      uint64_t v23 = v11;
    }
    do
    {
      uint64_t v24 = *((void *)v23 - 1);
      v23 -= 8;
      *--uint64_t v21 = v24;
    }
    while (v23 != v14);
LABEL_26:
    uint64_t v11 = *v32;
    goto LABEL_27;
  }
}

void sub_235EC9F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (v13) {
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

void p2t::SweepContext::AddPoint(p2t::SweepContext *this, Point *a2)
{
  int64_t v5 = (char *)*((void *)this + 17);
  unint64_t v4 = *((void *)this + 18);
  int64_t v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *(void *)int64_t v5 = a2;
    uint64_t v7 = (uint64_t)(v5 + 8);
    goto LABEL_23;
  }
  uint64_t v8 = (void **)((char *)this + 128);
  uint64_t v9 = (char *)*((void *)this + 16);
  uint64_t v10 = (v5 - v9) >> 3;
  unint64_t v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v12 = v4 - (void)v9;
  if (v12 >> 2 > v11) {
    unint64_t v11 = v12 >> 2;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v14 = (char *)operator new(8 * v13);
    uint64_t v15 = &v14[8 * v10];
    uint64_t v16 = &v14[8 * v13];
    *(void *)uint64_t v15 = a2;
    uint64_t v7 = (uint64_t)(v15 + 8);
    unint64_t v17 = (char *)(v5 - v9);
    if (v5 == v9) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  uint64_t v14 = 0;
  uint64_t v15 = (char *)(8 * v10);
  uint64_t v16 = 0;
  *(void *)(8 * v10) = a2;
  uint64_t v7 = 8 * v10 + 8;
  unint64_t v17 = (char *)(v5 - v9);
  if (v5 != v9)
  {
LABEL_14:
    unint64_t v18 = (unint64_t)(v17 - 8);
    if (v18 < 0x58) {
      goto LABEL_28;
    }
    if ((unint64_t)(v9 - v14) < 0x20) {
      goto LABEL_28;
    }
    uint64_t v19 = (v18 >> 3) + 1;
    uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    int64_t v6 = &v5[-v20];
    v15 -= v20;
    uint64_t v21 = &v14[8 * v10 - 16];
    unint64_t v22 = (long long *)(v5 - 16);
    uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *v22;
      *((_OWORD *)v21 - 1) = *(v22 - 1);
      *(_OWORD *)uint64_t v21 = v24;
      v21 -= 32;
      v22 -= 2;
      v23 -= 4;
    }
    while (v23);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        uint64_t v25 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v15 - 1) = v25;
        v15 -= 8;
      }
      while (v6 != v9);
    }
    int64_t v6 = (char *)*v8;
  }
LABEL_21:
  *((void *)this + 16) = v15;
  *((void *)this + 17) = v7;
  *((void *)this + 18) = v16;
  if (v6) {
    operator delete(v6);
  }
LABEL_23:
  *((void *)this + 17) = v7;
}

void *p2t::SweepContext::GetTriangles@<X0>(void *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = (unsigned char *)this[10];
  uint64_t v3 = (unsigned char *)this[11];
  int64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v5 < 0) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    int64_t v6 = (char *)operator new(v3 - v4);
    *a2 = v6;
    uint64_t v7 = &v6[8 * (v5 >> 3)];
    a2[2] = v7;
    this = memcpy(v6, v4, v5);
    a2[1] = v7;
  }
  return this;
}

void sub_235ECA180(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *p2t::SweepContext::GetMap@<X0>(void *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this + 13;
  *a2 = a2;
  a2[1] = a2;
  a2[2] = 0;
  uint64_t v3 = (void *)this[14];
  if (v3 != this + 13)
  {
    uint64_t v5 = 0;
    int64_t v6 = a2;
    do
    {
      this = operator new(0x18uLL);
      uint64_t v7 = v3[2];
      this[1] = a2;
      this[2] = v7;
      *this = v6;
      v6[1] = this;
      *a2 = this;
      a2[2] = ++v5;
      uint64_t v3 = (void *)v3[1];
      int64_t v6 = this;
    }
    while (v3 != v2);
  }
  return this;
}

void sub_235ECA220(_Unwind_Exception *exception_object)
{
  if (v3) {
    p2t::SweepContext::GetMap((uint64_t **)(v1 + 8), v2, (void *)(v1 + 16), (uint64_t *)v1);
  }
  _Unwind_Resume(exception_object);
}

void p2t::SweepContext::InitTriangulation(p2t::SweepContext *this)
{
  uint64_t v1 = (double **)*((void *)this + 16);
  double v3 = **v1;
  double v2 = (*v1)[1];
  uint64_t v4 = *((void *)this + 17) - (void)v1;
  if (v4)
  {
    unint64_t v5 = v4 >> 3;
    if (v5 <= 1) {
      unint64_t v6 = 1;
    }
    else {
      unint64_t v6 = v5;
    }
    if (v6 < 2 || (v6 ? (BOOL v7 = (v6 - 1) >> 32 == 0) : (BOOL v7 = 0), !v7))
    {
      unint64_t v8 = 0;
      int v9 = 0;
      double v10 = **v1;
      double v11 = (*v1)[1];
LABEL_11:
      unsigned int v12 = v9 + 1;
      do
      {
        unint64_t v13 = v1[v8];
        double v14 = v13[1];
        double v3 = fmax(*v13, v3);
        double v10 = fmin(*v13, v10);
        double v2 = fmax(v14, v2);
        double v11 = fmin(v14, v11);
        unint64_t v8 = v12++;
      }
      while (v5 > v8);
      goto LABEL_18;
    }
    unint64_t v8 = v6 & 0xFFFFFFFFFFFFFFFELL;
    int v9 = v6 & 0xFFFFFFFE;
    uint64_t v15 = v1 + 1;
    unint64_t v16 = v6 & 0xFFFFFFFFFFFFFFFELL;
    double v17 = **v1;
    double v18 = v17;
    double v19 = v17;
    double v20 = (*v1)[1];
    double v21 = v20;
    double v22 = v20;
    do
    {
      uint64_t v23 = *(v15 - 1);
      double v24 = v23[1];
      double v3 = fmax(*v23, v3);
      double v18 = fmin(*v23, v18);
      double v25 = **v15;
      double v26 = (*v15)[1];
      double v17 = fmax(v25, v17);
      double v19 = fmin(v25, v19);
      double v2 = fmax(v24, v2);
      double v20 = fmax(v26, v20);
      double v21 = fmin(v24, v21);
      double v22 = fmin(v26, v22);
      v15 += 2;
      v16 -= 2;
    }
    while (v16);
    double v11 = fmin(v21, v22);
    double v2 = fmax(v2, v20);
    double v10 = fmin(v18, v19);
    double v3 = fmax(v3, v17);
    if (v6 != v8) {
      goto LABEL_11;
    }
  }
LABEL_18:
  operator new();
}

BOOL p2t::cmp(p2t *this, const Point *a2, const Point *a3)
{
  double v3 = *((double *)this + 1);
  double v4 = *(double *)&a2[2].v;
  if (v3 < v4) {
    return 1;
  }
  return v3 == v4 && *(double *)this < *(double *)&a2->v;
}

uint64_t p2t::SweepContext::GetPoint(p2t::SweepContext *this, const int *a2)
{
  return *(void *)(*((void *)this + 16) + 8 * *a2);
}

void *p2t::SweepContext::AddToMap(void *a1, uint64_t a2)
{
  double result = operator new(0x18uLL);
  uint64_t v5 = a1[13];
  a1 += 13;
  result[1] = a1;
  result[2] = a2;
  void *result = v5;
  *(void *)(v5 + 8) = result;
  *a1 = result;
  ++a1[2];
  return result;
}

uint64_t p2t::SweepContext::LocateNode(p2t::AdvancingFront **this, Point *a2)
{
  return p2t::AdvancingFront::LocateNode(this[19], (double *)&a2->v);
}

void p2t::SweepContext::CreateAdvancingFront()
{
}

void sub_235ECA628(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void sub_235ECA64C(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x1020C403BE5E226);
  _Unwind_Resume(a1);
}

void p2t::SweepContext::RemoveNode(uint64_t a1, uint64_t a2)
{
  if (a2) {
    JUMPOUT(0x237DF7CA0);
  }
}

uint64_t p2t::SweepContext::MapTriangleToNodes(uint64_t this, Point **a2)
{
  uint64_t v3 = this;
  if (!a2[4])
  {
    double v4 = *(p2t::AdvancingFront **)(this + 152);
    uint64_t v5 = p2t::Triangle::PointCW((p2t::Triangle *)a2, a2[1]);
    this = p2t::AdvancingFront::LocatePoint(v4, v5);
    if (this) {
      *(void *)(this + 8) = a2;
    }
  }
  if (!a2[5])
  {
    unint64_t v6 = *(p2t::AdvancingFront **)(v3 + 152);
    BOOL v7 = p2t::Triangle::PointCW((p2t::Triangle *)a2, a2[2]);
    this = p2t::AdvancingFront::LocatePoint(v6, v7);
    if (this) {
      *(void *)(this + 8) = a2;
    }
  }
  if (!a2[6])
  {
    unint64_t v8 = *(p2t::AdvancingFront **)(v3 + 152);
    int v9 = p2t::Triangle::PointCW((p2t::Triangle *)a2, a2[3]);
    this = p2t::AdvancingFront::LocatePoint(v8, v9);
    if (this) {
      *(void *)(this + 8) = a2;
    }
  }
  return this;
}

void *p2t::SweepContext::RemoveFromMap(p2t::SweepContext *this, p2t::Triangle *a2)
{
  uint64_t v3 = a2;
  return std::list<p2t::Triangle *>::remove((void *)this + 13, &v3);
}

void *std::list<p2t::Triangle *>::remove(void *result, void *a2)
{
  double v22 = &v22;
  uint64_t v23 = &v22;
  double v2 = (void *)result[1];
  if (v2 == result) {
    return result;
  }
  if (&v22 == result)
  {
    while (1)
    {
      unint64_t v13 = (void *)v2[1];
      uint64_t v14 = v2[2];
      if (v14 == *a2) {
        break;
      }
LABEL_21:
      double v2 = v13;
      if (v13 == result) {
        return result;
      }
    }
    if (v13 == result)
    {
      BOOL v15 = 1;
    }
    else
    {
      if (v13[2] != v14)
      {
LABEL_27:
        BOOL v15 = 0;
        if (v2 == v13)
        {
LABEL_32:
          if (!v15) {
            unint64_t v13 = (void *)v13[1];
          }
          goto LABEL_21;
        }
LABEL_31:
        uint64_t v16 = *v13;
        uint64_t v17 = *v2;
        *(void *)(v17 + 8) = *(void *)(*v13 + 8);
        **(void **)(v16 + 8) = v17;
        uint64_t v18 = *result;
        *(void *)(v18 + 8) = v2;
        *double v2 = v18;
        void *result = v16;
        *(void *)(v16 + 8) = result;
        goto LABEL_32;
      }
      while (1)
      {
        unint64_t v13 = (void *)v13[1];
        BOOL v15 = v13 == result;
        if (v13 == result) {
          break;
        }
        if (v13[2] != v14) {
          goto LABEL_27;
        }
      }
    }
    unint64_t v13 = result;
    if (v2 == result) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  uint64_t v3 = 0;
  do
  {
    double v4 = (void *)v2[1];
    uint64_t v5 = v2[2];
    if (v5 == *a2)
    {
      while (v4 != result)
      {
        BOOL v6 = v4[2] == v5;
        if (v4[2] != v5)
        {
          if (v2 != v4) {
            goto LABEL_11;
          }
LABEL_16:
          if (v6) {
            goto LABEL_4;
          }
          goto LABEL_20;
        }
        double v4 = (void *)v4[1];
      }
      BOOL v6 = 1;
      double v4 = result;
      if (v2 == result) {
        goto LABEL_16;
      }
LABEL_11:
      BOOL v7 = (void *)*v4;
      if ((void *)*v4 == v2)
      {
        uint64_t v10 = 1;
      }
      else
      {
        uint64_t v8 = -1;
        int v9 = v2;
        do
        {
          int v9 = (void *)v9[1];
          ++v8;
        }
        while (v9 != v7);
        uint64_t v10 = v8 + 2;
      }
      result[2] -= v10;
      v3 += v10;
      uint64_t v11 = *v2;
      *(void *)(v11 + 8) = v7[1];
      *(void *)v7[1] = v11;
      unsigned int v12 = v22;
      v22[1] = v2;
      *double v2 = v12;
      double v22 = v7;
      v7[1] = &v22;
      if (!v6) {
LABEL_20:
      }
        double v4 = (void *)v4[1];
    }
LABEL_4:
    double v2 = v4;
  }
  while (v4 != result);
  if (v3)
  {
    double v19 = v22;
    double result = v23;
    uint64_t v20 = *v23;
    *(void *)(v20 + 8) = v22[1];
    *(void *)v19[1] = v20;
    uint64_t v24 = 0;
    if (result != &v22)
    {
      do
      {
        double v21 = (void *)result[1];
        operator delete(result);
        double result = v21;
      }
      while (v21 != &v22);
    }
  }
  return result;
}

void p2t::SweepContext::MeshClean(p2t::SweepContext *this, p2t::Triangle *a2)
{
  double v4 = (char *)operator new(8uLL);
  *(void *)double v4 = a2;
  uint64_t v5 = v4 + 8;
  unint64_t v82 = v4 + 8;
  uint64_t v80 = v4;
  BOOL v6 = (char **)((char *)this + 80);
  do
  {
    uint64_t v9 = *((void *)v5 - 1);
    v5 -= 8;
    uint64_t v8 = v9;
    id v81 = v5;
    if (v9 && !*(unsigned char *)(v8 + 56))
    {
      *(unsigned char *)(v8 + 56) = 1;
      uint64_t v11 = (char *)*((void *)this + 11);
      unint64_t v10 = *((void *)this + 12);
      if ((unint64_t)v11 < v10)
      {
        *(void *)uint64_t v11 = v8;
        uint64_t v12 = (uint64_t)(v11 + 8);
        goto LABEL_21;
      }
      unint64_t v13 = *v6;
      uint64_t v14 = v11 - *v6;
      uint64_t v15 = v14 >> 3;
      unint64_t v16 = (v14 >> 3) + 1;
      if (v16 >> 61) {
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
      uint64_t v17 = v10 - (void)v13;
      if (v17 >> 2 > v16) {
        unint64_t v16 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        double v19 = operator new(8 * v18);
        uint64_t v20 = &v19[8 * v15];
        *uint64_t v20 = v8;
        uint64_t v12 = (uint64_t)(v20 + 1);
        if (v11 == v13)
        {
LABEL_19:
          *((void *)this + 10) = v20;
          *((void *)this + 11) = v12;
          *((void *)this + 12) = &v19[8 * v18];
          if (!v11) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }
      }
      else
      {
        double v19 = 0;
        uint64_t v20 = (void *)(8 * v15);
        *(void *)(8 * v15) = v8;
        uint64_t v12 = 8 * v15 + 8;
        if (v11 == v13) {
          goto LABEL_19;
        }
      }
      unint64_t v23 = v11 - 8 - v13;
      if (v23 < 0x58) {
        goto LABEL_116;
      }
      if ((unint64_t)(v11 - &v19[v14]) < 0x20) {
        goto LABEL_116;
      }
      uint64_t v24 = (v23 >> 3) + 1;
      uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      double v26 = &v11[-v25];
      uint64_t v20 = (void *)((char *)v20 - v25);
      uint64_t v27 = &v19[8 * v15 - 16];
      uint64_t v28 = v11 - 16;
      uint64_t v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v30 = *(_OWORD *)v28;
        *(v27 - 1) = *((_OWORD *)v28 - 1);
        *uint64_t v27 = v30;
        v27 -= 2;
        v28 -= 32;
        v29 -= 4;
      }
      while (v29);
      uint64_t v11 = v26;
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_116:
        do
        {
          uint64_t v31 = *((void *)v11 - 1);
          v11 -= 8;
          *--uint64_t v20 = v31;
        }
        while (v11 != v13);
      }
      uint64_t v11 = *v6;
      *((void *)this + 10) = v20;
      *((void *)this + 11) = v12;
      *((void *)this + 12) = &v19[8 * v18];
      if (!v11)
      {
LABEL_21:
        *((void *)this + 11) = v12;
        uint64_t v5 = v81;
        if (*(unsigned char *)v8)
        {
          if (*(unsigned char *)(v8 + 1)) {
            goto LABEL_23;
          }
          goto LABEL_48;
        }
        uint64_t v21 = *(void *)(v8 + 32);
        if (v81 < v82)
        {
          *(void *)id v81 = v21;
          uint64_t v22 = (uint64_t)(v81 + 8);
          goto LABEL_47;
        }
        uint64_t v32 = (v81 - v80) >> 3;
        unint64_t v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 61) {
          goto LABEL_110;
        }
        uint64_t v34 = v82 - v80;
        if ((v82 - v80) >> 2 > v33) {
          unint64_t v33 = v34 >> 2;
        }
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v35 = v33;
        }
        if (v35)
        {
          if (v35 >> 61) {
            goto LABEL_112;
          }
          uint64_t v36 = (char *)operator new(8 * v35);
          uint64_t v37 = &v36[8 * v32];
          *(void *)uint64_t v37 = v21;
          uint64_t v22 = (uint64_t)(v37 + 8);
          if (v81 == v80)
          {
LABEL_45:
            uint64_t v80 = v37;
            unint64_t v82 = &v36[8 * v35];
            if (!v81) {
              goto LABEL_47;
            }
            goto LABEL_46;
          }
        }
        else
        {
          uint64_t v36 = 0;
          uint64_t v37 = (char *)(8 * v32);
          *(void *)(8 * v32) = v21;
          uint64_t v22 = 8 * v32 + 8;
          if (v81 == v80) {
            goto LABEL_45;
          }
        }
        unint64_t v53 = v81 - 8 - v80;
        if (v53 < 0x58) {
          goto LABEL_117;
        }
        if ((unint64_t)(v80 - v36) < 0x20) {
          goto LABEL_117;
        }
        uint64_t v54 = (v53 >> 3) + 1;
        uint64_t v55 = 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
        long long v56 = &v81[-v55];
        v37 -= v55;
        id v57 = &v36[8 * v32 - 16];
        long long v58 = (long long *)(v81 - 16);
        uint64_t v59 = v54 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v60 = *v58;
          *((_OWORD *)v57 - 1) = *(v58 - 1);
          *(_OWORD *)id v57 = v60;
          v57 -= 32;
          v58 -= 2;
          v59 -= 4;
        }
        while (v59);
        uint64_t v5 = v56;
        if (v54 != (v54 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_117:
          do
          {
            uint64_t v61 = *((void *)v5 - 1);
            v5 -= 8;
            *((void *)v37 - 1) = v61;
            v37 -= 8;
          }
          while (v5 != v80);
        }
        uint64_t v5 = v80;
        uint64_t v80 = v37;
        unint64_t v82 = &v36[8 * v35];
        if (!v5)
        {
LABEL_47:
          uint64_t v5 = (char *)v22;
          if (*(unsigned char *)(v8 + 1))
          {
LABEL_23:
            if (*(unsigned char *)(v8 + 2)) {
              goto LABEL_4;
            }
LABEL_62:
            uint64_t v46 = *(void *)(v8 + 48);
            if (v5 < v82)
            {
              *(void *)uint64_t v5 = v46;
              uint64_t v7 = (uint64_t)(v5 + 8);
              goto LABEL_3;
            }
            uint64_t v47 = (v5 - v80) >> 3;
            unint64_t v48 = v47 + 1;
            if ((unint64_t)(v47 + 1) >> 61) {
LABEL_110:
            }
              _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
            uint64_t v49 = v82 - v80;
            if ((v82 - v80) >> 2 > v48) {
              unint64_t v48 = v49 >> 2;
            }
            if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v50 = v48;
            }
            if (v50)
            {
              if (v50 >> 61) {
LABEL_112:
              }
                std::__throw_bad_array_new_length[abi:ne180100]();
              long long v51 = (char *)operator new(8 * v50);
              long long v52 = &v51[8 * v47];
              *(void *)long long v52 = v46;
              uint64_t v7 = (uint64_t)(v52 + 8);
              if (v5 == v80)
              {
LABEL_72:
                uint64_t v80 = v52;
                unint64_t v82 = &v51[8 * v50];
                if (!v5) {
                  goto LABEL_3;
                }
                goto LABEL_104;
              }
            }
            else
            {
              long long v51 = 0;
              long long v52 = (char *)(8 * v47);
              *(void *)(8 * v47) = v46;
              uint64_t v7 = 8 * v47 + 8;
              if (v5 == v80) {
                goto LABEL_72;
              }
            }
            unint64_t v64 = v5 - 8 - v80;
            if (v64 >= 0x58)
            {
              if ((unint64_t)(v80 - v51) >= 0x20)
              {
                uint64_t v73 = (v64 >> 3) + 1;
                uint64_t v74 = 8 * (v73 & 0x3FFFFFFFFFFFFFFCLL);
                uint64_t v65 = &v5[-v74];
                v52 -= v74;
                BOOL v75 = &v51[8 * v47 - 16];
                uint64_t v76 = v5 - 16;
                uint64_t v77 = v73 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v78 = *(_OWORD *)v76;
                  *((_OWORD *)v75 - 1) = *((_OWORD *)v76 - 1);
                  *(_OWORD *)BOOL v75 = v78;
                  v75 -= 32;
                  v76 -= 32;
                  v77 -= 4;
                }
                while (v77);
                if (v73 == (v73 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_103:
                  uint64_t v5 = v80;
                  uint64_t v80 = v52;
                  unint64_t v82 = &v51[8 * v50];
                  if (v5) {
LABEL_104:
                  }
                    operator delete(v5);
LABEL_3:
                  uint64_t v5 = (char *)v7;
LABEL_4:
                  double v4 = v80;
                  continue;
                }
              }
              else
              {
                uint64_t v65 = v5;
              }
            }
            else
            {
              uint64_t v65 = v5;
            }
            do
            {
              uint64_t v79 = *((void *)v65 - 1);
              v65 -= 8;
              *((void *)v52 - 1) = v79;
              v52 -= 8;
            }
            while (v65 != v80);
            goto LABEL_103;
          }
LABEL_48:
          uint64_t v38 = *(void *)(v8 + 40);
          if (v5 < v82)
          {
            *(void *)uint64_t v5 = v38;
            uint64_t v39 = (uint64_t)(v5 + 8);
            goto LABEL_61;
          }
          uint64_t v40 = (v5 - v80) >> 3;
          unint64_t v41 = v40 + 1;
          if ((unint64_t)(v40 + 1) >> 61) {
            goto LABEL_110;
          }
          uint64_t v42 = v82 - v80;
          if ((v82 - v80) >> 2 > v41) {
            unint64_t v41 = v42 >> 2;
          }
          if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v43 = v41;
          }
          if (v43)
          {
            if (v43 >> 61) {
              goto LABEL_112;
            }
            id v44 = (char *)operator new(8 * v43);
            long long v45 = &v44[8 * v40];
            *(void *)long long v45 = v38;
            uint64_t v39 = (uint64_t)(v45 + 8);
            if (v5 == v80)
            {
LABEL_59:
              uint64_t v80 = v45;
              unint64_t v82 = &v44[8 * v43];
              if (!v5) {
                goto LABEL_61;
              }
              goto LABEL_60;
            }
          }
          else
          {
            id v44 = 0;
            long long v45 = (char *)(8 * v40);
            *(void *)(8 * v40) = v38;
            uint64_t v39 = 8 * v40 + 8;
            if (v5 == v80) {
              goto LABEL_59;
            }
          }
          unint64_t v62 = v5 - 8 - v80;
          if (v62 >= 0x58)
          {
            if ((unint64_t)(v80 - v44) >= 0x20)
            {
              uint64_t v66 = (v62 >> 3) + 1;
              uint64_t v67 = 8 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
              long long v63 = &v5[-v67];
              v45 -= v67;
              uint64_t v68 = &v44[8 * v40 - 16];
              uint64_t v69 = v5 - 16;
              uint64_t v70 = v66 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v71 = *(_OWORD *)v69;
                *((_OWORD *)v68 - 1) = *((_OWORD *)v69 - 1);
                *(_OWORD *)uint64_t v68 = v71;
                v68 -= 32;
                v69 -= 32;
                v70 -= 4;
              }
              while (v70);
              if (v66 == (v66 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_97:
                uint64_t v5 = v80;
                uint64_t v80 = v45;
                unint64_t v82 = &v44[8 * v43];
                if (!v5)
                {
LABEL_61:
                  uint64_t v5 = (char *)v39;
                  if (*(unsigned char *)(v8 + 2)) {
                    goto LABEL_4;
                  }
                  goto LABEL_62;
                }
LABEL_60:
                operator delete(v5);
                goto LABEL_61;
              }
            }
            else
            {
              long long v63 = v5;
            }
          }
          else
          {
            long long v63 = v5;
          }
          do
          {
            uint64_t v72 = *((void *)v63 - 1);
            v63 -= 8;
            *((void *)v45 - 1) = v72;
            v45 -= 8;
          }
          while (v63 != v80);
          goto LABEL_97;
        }
LABEL_46:
        operator delete(v5);
        goto LABEL_47;
      }
LABEL_20:
      operator delete(v11);
      goto LABEL_21;
    }
  }
  while (v4 != v5);
  if (v5)
  {
    operator delete(v5);
  }
}

void sub_235ECAFE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

void p2t::SweepContext::~SweepContext(p2t::SweepContext *this)
{
  uint64_t v2 = *((void *)this + 20);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 16);
    if (v3)
    {
      *(void *)(v2 + 24) = v3;
      operator delete(v3);
    }
    MEMORY[0x237DF7CA0](v2, 0x1080C40B69A5871);
  }
  uint64_t v4 = *((void *)this + 21);
  if (v4)
  {
    uint64_t v5 = *(void **)(v4 + 16);
    if (v5)
    {
      *(void *)(v4 + 24) = v5;
      operator delete(v5);
    }
    MEMORY[0x237DF7CA0](v4, 0x1080C40B69A5871);
  }
  BOOL v6 = (OpenSteer::SimpleVehicle *)*((void *)this + 19);
  if (v6)
  {
    OpenSteer::SimpleVehicle::~SimpleVehicle(v6);
    MEMORY[0x237DF7CA0]();
  }
  uint64_t v7 = *((void *)this + 22);
  if (v7) {
    MEMORY[0x237DF7CA0](v7, 0x1020C40DBF2485DLL);
  }
  uint64_t v8 = *((void *)this + 23);
  if (v8) {
    MEMORY[0x237DF7CA0](v8, 0x1020C40DBF2485DLL);
  }
  uint64_t v9 = *((void *)this + 24);
  if (v9) {
    MEMORY[0x237DF7CA0](v9, 0x1020C40DBF2485DLL);
  }
  unint64_t v10 = (char *)this + 104;
  for (uint64_t i = *((void *)this + 14); (char *)i != v10; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v12 = *(void *)(i + 16);
    if (v12) {
      MEMORY[0x237DF7CA0](v12, 0x1020C403BE5E226);
    }
  }
  uint64_t v14 = *(void *)this;
  uint64_t v13 = *((void *)this + 1);
  if (v13 != *(void *)this)
  {
    unint64_t v15 = 0;
    unsigned int v16 = 1;
    do
    {
      uint64_t v17 = *(void *)(v14 + 8 * v15);
      if (v17)
      {
        MEMORY[0x237DF7CA0](v17, 0x20C40A4A59CD2);
        uint64_t v14 = *(void *)this;
        uint64_t v13 = *((void *)this + 1);
      }
      unint64_t v15 = v16++;
    }
    while (v15 < (v13 - v14) >> 3);
  }
  unint64_t v18 = (void *)*((void *)this + 16);
  if (v18)
  {
    *((void *)this + 17) = v18;
    operator delete(v18);
  }
  if (*((void *)this + 15))
  {
    uint64_t v20 = *((void *)this + 13);
    double v19 = (char *)*((void *)this + 14);
    uint64_t v21 = *(void *)v19;
    *(void *)(v21 + 8) = *(void *)(v20 + 8);
    **(void **)(v20 + 8) = v21;
    *((void *)this + 15) = 0;
    if (v19 != v10)
    {
      do
      {
        uint64_t v22 = (char *)*((void *)v19 + 1);
        operator delete(v19);
        double v19 = v22;
      }
      while (v22 != v10);
    }
  }
  unint64_t v23 = (void *)*((void *)this + 10);
  if (v23)
  {
    *((void *)this + 11) = v23;
    operator delete(v23);
  }
  uint64_t v24 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v24;
    operator delete(v24);
  }
}

p2t::Edge *p2t::Edge::Edge(p2t::Edge *this, Point *a2, Point *a3)
{
  uint64_t v3 = a3;
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  double v5 = *(double *)&a2[2].v;
  double v6 = *(double *)&a3[2].v;
  if (v5 > v6) {
    goto LABEL_4;
  }
  if (v5 != v6) {
    goto LABEL_5;
  }
  if (*(double *)&a2->v <= *(double *)&a3->v)
  {
    if (*(double *)&a2->v == *(double *)&a3->v) {
      p2t::Edge::Edge();
    }
  }
  else
  {
LABEL_4:
    *(void *)this = a3;
    *((void *)this + 1) = a2;
    uint64_t v3 = a2;
  }
LABEL_5:
  uint64_t v8 = *(char **)&v3[6].v;
  unint64_t v7 = *(void *)&v3[8].v;
  if ((unint64_t)v8 < v7)
  {
    *(void *)uint64_t v8 = this;
    uint64_t v9 = (uint64_t)(v8 + 8);
    goto LABEL_27;
  }
  unint64_t v10 = *(char **)&v3[4].v;
  uint64_t v11 = (v8 - v10) >> 3;
  unint64_t v12 = v11 + 1;
  if ((unint64_t)(v11 + 1) >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v13 = v7 - (void)v10;
  if (v13 >> 2 > v12) {
    unint64_t v12 = v13 >> 2;
  }
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14)
  {
    if (v14 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v15 = (char *)operator new(8 * v14);
    unsigned int v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *(void *)unsigned int v16 = this;
    uint64_t v9 = (uint64_t)(v16 + 8);
    unint64_t v18 = (char *)(v8 - v10);
    if (v8 == v10) {
      goto LABEL_25;
    }
    goto LABEL_18;
  }
  unint64_t v15 = 0;
  unsigned int v16 = (char *)(8 * v11);
  uint64_t v17 = 0;
  *(void *)(8 * v11) = this;
  uint64_t v9 = 8 * v11 + 8;
  unint64_t v18 = (char *)(v8 - v10);
  if (v8 != v10)
  {
LABEL_18:
    unint64_t v19 = (unint64_t)(v18 - 8);
    if (v19 < 0x58) {
      goto LABEL_34;
    }
    if ((unint64_t)(v10 - v15) < 0x20) {
      goto LABEL_34;
    }
    uint64_t v20 = (v19 >> 3) + 1;
    uint64_t v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v8[-v21];
    v16 -= v21;
    unint64_t v23 = &v15[8 * v11 - 16];
    uint64_t v24 = v8 - 16;
    uint64_t v25 = v20 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v26 = *(_OWORD *)v24;
      *((_OWORD *)v23 - 1) = *((_OWORD *)v24 - 1);
      *(_OWORD *)unint64_t v23 = v26;
      v23 -= 32;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    uint64_t v8 = v22;
    if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_34:
      do
      {
        uint64_t v27 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v16 - 1) = v27;
        v16 -= 8;
      }
      while (v8 != v10);
    }
    uint64_t v8 = *(char **)&v3[4].v;
  }
LABEL_25:
  *(void *)&v3[4].v = v16;
  *(void *)&v3[6].v = v9;
  *(void *)&v3[8].v = v17;
  if (v8) {
    operator delete(v8);
  }
LABEL_27:
  *(void *)&v3[6].v = v9;
  return this;
}

void *std::vector<p2t::Point *>::__assign_with_size[abi:ne180100]<p2t::Point **,p2t::Point **>(void *result, char *__src, char *a3, size_t __sz)
{
  double v6 = __src;
  unint64_t v7 = result;
  uint64_t v8 = result[2];
  uint64_t v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 61) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 61) {
LABEL_22:
    }
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    uint64_t v13 = v12;
    double result = operator new(8 * v12);
    uint64_t v9 = (char *)result;
    void *v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      double result = memcpy(result, v6, v14);
    }
    unint64_t v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  unint64_t v15 = (void **)(result + 1);
  unsigned int v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 3;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    unint64_t v19 = (void *)*result;
LABEL_20:
    double result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  unint64_t v18 = &__src[8 * v17];
  if (v16 != v9)
  {
    double result = memmove((void *)*result, __src, v16 - v9);
    uint64_t v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    unint64_t v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *unint64_t v15 = &v9[v14];
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**,false>(uint64_t result, int8x16_t *a2, unsigned int (**a3)(uint64_t), uint64_t a4, char a5)
{
  uint64_t v9 = (int8x16_t *)result;
  while (2)
  {
    uint64_t v10 = a2;
    BOOL v11 = &a2[-1].i64[1];
    unint64_t v12 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v12;
          uint64_t v13 = (char *)v10 - (char *)v12;
          unint64_t v14 = ((char *)v10 - (char *)v12) >> 3;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v70 = v12->i64[0];
                v12->i64[0] = *v11;
                goto LABEL_143;
              case 3uLL:
                char v71 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
                double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[1]);
                if (v71)
                {
                  uint64_t v72 = v12->i64[0];
                  if (result)
                  {
                    v12->i64[0] = *v11;
                    uint64_t *v11 = v72;
                  }
                  else
                  {
                    v12->i64[0] = v12->i64[1];
                    v12->i64[1] = v72;
                    double result = ((uint64_t (*)(uint64_t))*a3)(*v11);
                    if (result)
                    {
                      uint64_t v70 = v12->i64[1];
                      v12->i64[1] = *v11;
LABEL_143:
                      uint64_t *v11 = v70;
                    }
                  }
                }
                else if (result)
                {
                  uint64_t v88 = v12->i64[1];
                  v12->i64[1] = *v11;
                  uint64_t *v11 = v88;
                  double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
LABEL_132:
                  if (result) {
                    *unint64_t v12 = vextq_s8(*v12, *v12, 8uLL);
                  }
                }
                break;
              case 4uLL:
                return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, v11, a3);
              case 5uLL:
                uint64_t v73 = v12 + 1;
                uint64_t v74 = &v12[1].i64[1];
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, &v12[1].i64[1], a3);
                double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12[1].i64[1]);
                if (!result) {
                  return result;
                }
                uint64_t v75 = *v74;
                *uint64_t v74 = *v11;
                uint64_t *v11 = v75;
                double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v74, v73->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v76 = v73->i64[0];
                v73->i64[0] = *v74;
                *uint64_t v74 = v76;
                double result = ((uint64_t (*)(void))*a3)();
                if (!result) {
                  return result;
                }
                uint64_t v78 = v12->i64[1];
                uint64_t v77 = v12[1].i64[0];
                uint64_t v79 = v12->i64[0];
                v12->i64[1] = v77;
                v12[1].i64[0] = v78;
                double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v77, v79);
                goto LABEL_132;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            uint64_t v80 = (int8x16_t *)&v12->u64[1];
            BOOL v82 = v12 == v10 || v80 == v10;
            if (a5)
            {
              if (!v82)
              {
                uint64_t v83 = 0;
                float v84 = (uint64_t *)v12;
                do
                {
                  double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v80->i64[0], *v84);
                  if (result)
                  {
                    unint64_t v86 = 0;
                    uint64_t v87 = v80->i64[0];
                    do
                    {
                      v84[v86 / 8 + 1] = v84[v86 / 8];
                      if (v83 == v86)
                      {
                        float v85 = (uint64_t *)v12;
                        goto LABEL_119;
                      }
                      double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v87, v84[v86 / 8 - 1]);
                      v86 -= 8;
                    }
                    while ((result & 1) != 0);
                    float v85 = &v80->i64[v86 / 8];
LABEL_119:
                    *float v85 = v87;
                  }
                  uint64_t v80 = (int8x16_t *)((char *)v80 + 8);
                  v83 -= 8;
                  ++v84;
                }
                while (v80 != a2);
              }
            }
            else if (!v82)
            {
              do
              {
                uint64_t v90 = v9->i64[0];
                uint64_t v89 = v9->i64[1];
                uint64_t v9 = v80;
                double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v89, v90);
                if (result)
                {
                  uint64_t v91 = v80->i64[0];
                  uint64_t v92 = (uint64_t *)v80;
                  do
                  {
                    uint64_t v93 = v92;
                    uint64_t v94 = *--v92;
                    *uint64_t v93 = v94;
                    double result = ((uint64_t (*)(uint64_t, void))*a3)(v91, *(v93 - 2));
                  }
                  while ((result & 1) != 0);
                  *uint64_t v92 = v91;
                }
                uint64_t v80 = (int8x16_t *)((char *)v80 + 8);
              }
              while (&v9->u64[1] != (unint64_t *)a2);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != v10)
            {
              return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**,p2t::Point**>(v12, a2, a2, (unsigned int (**)(void, uint64_t))a3);
            }
            return result;
          }
          unint64_t v15 = v14 >> 1;
          unsigned int v16 = *a3;
          if ((unint64_t)v13 >= 0x401) {
            break;
          }
          char v20 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v12->i64[0], v12->i64[v15]);
          int v21 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[0]);
          if (v20)
          {
            uint64_t v22 = v12->i64[v15];
            if (!v21)
            {
              v12->i64[v15] = v12->i64[0];
              v12->i64[0] = v22;
              if ((*a3)(*v11))
              {
                uint64_t v35 = v12->i64[0];
                v12->i64[0] = *v11;
                uint64_t *v11 = v35;
              }
LABEL_33:
              --a4;
              uint64_t v23 = v12->i64[0];
              if (a5) {
                goto LABEL_56;
              }
              goto LABEL_55;
            }
            v12->i64[v15] = *v11;
            uint64_t *v11 = v22;
            --a4;
            uint64_t v23 = v12->i64[0];
            if (a5) {
              goto LABEL_56;
            }
          }
          else
          {
            if (!v21) {
              goto LABEL_33;
            }
            uint64_t v26 = v12->i64[0];
            v12->i64[0] = *v11;
            uint64_t *v11 = v26;
            if (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v12->i64[0], v12->i64[v15])) {
              goto LABEL_33;
            }
            uint64_t v27 = v12->i64[v15];
            v12->i64[v15] = v12->i64[0];
            v12->i64[0] = v27;
            --a4;
            uint64_t v23 = v27;
            if (a5) {
              goto LABEL_56;
            }
          }
LABEL_55:
          char v51 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12[-1].i64[1], v23);
          uint64_t v23 = v12->i64[0];
          if (v51) {
            goto LABEL_56;
          }
          double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[0], *v11);
          if (result)
          {
            do
            {
              uint64_t v63 = v12->i64[1];
              unint64_t v12 = (int8x16_t *)((char *)v12 + 8);
              double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v63);
            }
            while ((result & 1) == 0);
          }
          else
          {
            unint64_t v64 = (int8x16_t *)&v12->u64[1];
            do
            {
              unint64_t v12 = v64;
              if (v64 >= v10) {
                break;
              }
              unint64_t v64 = (int8x16_t *)((char *)v64 + 8);
              double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v12->i64[0]);
            }
            while (!result);
          }
          if (v12 < v10)
          {
            uint64_t v10 = a2;
            do
            {
              uint64_t v65 = v10[-1].i64[1];
              uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
              double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v65);
            }
            while ((result & 1) != 0);
          }
          while (v12 < v10)
          {
            uint64_t v66 = v12->i64[0];
            v12->i64[0] = v10->i64[0];
            v10->i64[0] = v66;
            do
            {
              uint64_t v67 = v12->i64[1];
              unint64_t v12 = (int8x16_t *)((char *)v12 + 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v23, v67));
            do
            {
              uint64_t v68 = v10[-1].i64[1];
              uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
              double result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v68);
            }
            while ((result & 1) != 0);
          }
          uint64_t v69 = &v12[-1].i64[1];
          BOOL v5 = &v12[-1].u64[1] >= (unint64_t *)v9;
          BOOL v6 = &v12[-1].u64[1] == (unint64_t *)v9;
          if (&v12[-1].u64[1] != (unint64_t *)v9) {
            v9->i64[0] = *v69;
          }
          a5 = 0;
          *uint64_t v69 = v23;
          uint64_t v10 = a2;
        }
        char v17 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v12->i64[v15], v12->i64[0]);
        int v18 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[v15]);
        if (v17)
        {
          uint64_t v19 = v12->i64[0];
          if (v18)
          {
            v12->i64[0] = *v11;
            uint64_t *v11 = v19;
          }
          else
          {
            v12->i64[0] = v12->i64[v15];
            v12->i64[v15] = v19;
            if ((*a3)(*v11))
            {
              uint64_t v28 = v12->i64[v15];
              v12->i64[v15] = *v11;
              uint64_t *v11 = v28;
            }
          }
        }
        else if (v18)
        {
          uint64_t v24 = v12->i64[v15];
          v12->i64[v15] = *v11;
          uint64_t *v11 = v24;
          if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v12->i64[v15], v12->i64[0]))
          {
            uint64_t v25 = v12->i64[0];
            v12->i64[0] = v12->i64[v15];
            v12->i64[v15] = v25;
          }
        }
        uint64_t v29 = &v12->i8[8 * v15];
        char v30 = ((uint64_t (*)(void, uint64_t))*a3)(*((void *)v29 - 1), v12->i64[1]);
        int v31 = ((uint64_t (*)(uint64_t, void))*a3)(v10[-1].i64[0], *((void *)v29 - 1));
        if (v30)
        {
          uint64_t v32 = v12->i64[1];
          if (v31)
          {
            v12->i64[1] = v10[-1].i64[0];
            v10[-1].i64[0] = v32;
          }
          else
          {
            v12->i64[1] = *((void *)v29 - 1);
            *((void *)v29 - 1) = v32;
            if ((*a3)(v10[-1].i64[0]))
            {
              uint64_t v36 = *((void *)v29 - 1);
              *((void *)v29 - 1) = v10[-1].i64[0];
              v10[-1].i64[0] = v36;
            }
          }
        }
        else if (v31)
        {
          uint64_t v33 = *((void *)v29 - 1);
          *((void *)v29 - 1) = v10[-1].i64[0];
          v10[-1].i64[0] = v33;
          if (((unsigned int (*)(void, uint64_t))*a3)(*((void *)v29 - 1), v12->i64[1]))
          {
            uint64_t v34 = v12->i64[1];
            v12->i64[1] = *((void *)v29 - 1);
            *((void *)v29 - 1) = v34;
          }
        }
        char v37 = ((uint64_t (*)(void, uint64_t))*a3)(*((void *)v29 + 1), v12[1].i64[0]);
        int v38 = ((uint64_t (*)(uint64_t, void))*a3)(v10[-2].i64[1], *((void *)v29 + 1));
        if (v37)
        {
          uint64_t v39 = v12[1].i64[0];
          if (v38)
          {
            v12[1].i64[0] = v10[-2].i64[1];
            v10[-2].i64[1] = v39;
          }
          else
          {
            v12[1].i64[0] = *((void *)v29 + 1);
            *((void *)v29 + 1) = v39;
            if ((*a3)(v10[-2].i64[1]))
            {
              uint64_t v42 = *((void *)v29 + 1);
              *((void *)v29 + 1) = v10[-2].i64[1];
              v10[-2].i64[1] = v42;
            }
          }
        }
        else if (v38)
        {
          uint64_t v40 = *((void *)v29 + 1);
          *((void *)v29 + 1) = v10[-2].i64[1];
          v10[-2].i64[1] = v40;
          if (((unsigned int (*)(void, uint64_t))*a3)(*((void *)v29 + 1), v12[1].i64[0]))
          {
            uint64_t v41 = v12[1].i64[0];
            v12[1].i64[0] = *((void *)v29 + 1);
            *((void *)v29 + 1) = v41;
          }
        }
        char v43 = ((uint64_t (*)(uint64_t, void))*a3)(v12->i64[v15], *((void *)v29 - 1));
        int v44 = ((uint64_t (*)(void, uint64_t))*a3)(*((void *)v29 + 1), v12->i64[v15]);
        if (v43)
        {
          uint64_t v45 = *((void *)v29 - 1);
          if (v44)
          {
            *((void *)v29 - 1) = *((void *)v29 + 1);
            *((void *)v29 + 1) = v45;
            uint64_t v46 = v12->i64[v15];
            goto LABEL_54;
          }
          *((void *)v29 - 1) = v12->i64[v15];
          v12->i64[v15] = v45;
          unsigned int v49 = (*a3)(*((void *)v29 + 1));
          uint64_t v46 = v12->i64[v15];
          if (v49)
          {
            uint64_t v48 = *((void *)v29 + 1);
            v12->i64[v15] = v48;
            *((void *)v29 + 1) = v46;
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v46 = v12->i64[v15];
          if (v44)
          {
            v12->i64[v15] = *((void *)v29 + 1);
            *((void *)v29 + 1) = v46;
            int v47 = ((uint64_t (*)(void))*a3)();
            uint64_t v46 = v12->i64[v15];
            if (v47)
            {
              uint64_t v48 = *((void *)v29 - 1);
              *((void *)v29 - 1) = v46;
              v12->i64[v15] = v48;
LABEL_53:
              uint64_t v46 = v48;
            }
          }
        }
LABEL_54:
        uint64_t v50 = v12->i64[0];
        v12->i64[0] = v46;
        v12->i64[v15] = v50;
        --a4;
        uint64_t v23 = v12->i64[0];
        if ((a5 & 1) == 0) {
          goto LABEL_55;
        }
LABEL_56:
        long long v52 = v12;
        do
        {
          unint64_t v53 = v52;
          uint64_t v54 = v52->i64[1];
          long long v52 = (int8x16_t *)((char *)v52 + 8);
        }
        while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v23) & 1) != 0);
        if (v53 == v12)
        {
          uint64_t v10 = a2;
          do
          {
            if (v52 >= v10) {
              break;
            }
            uint64_t v56 = v10[-1].i64[1];
            uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
          }
          while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v56, v23) & 1) == 0);
        }
        else
        {
          do
          {
            uint64_t v55 = v10[-1].i64[1];
            uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
          }
          while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v55, v23));
        }
        if (v52 < v10)
        {
          id v57 = v52;
          long long v58 = v10;
          do
          {
            uint64_t v59 = v57->i64[0];
            v57->i64[0] = v58->i64[0];
            v58->i64[0] = v59;
            do
            {
              unint64_t v53 = v57;
              uint64_t v60 = v57->i64[1];
              id v57 = (int8x16_t *)((char *)v57 + 8);
            }
            while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v60, v23) & 1) != 0);
            do
            {
              uint64_t v61 = v58[-1].i64[1];
              long long v58 = (int8x16_t *)((char *)v58 - 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v61, v23));
          }
          while (v57 < v58);
        }
        if (v53 != v9) {
          v9->i64[0] = v53->i64[0];
        }
        v53->i64[0] = v23;
        BOOL v5 = v52 >= v10;
        uint64_t v10 = a2;
        if (v5) {
          break;
        }
LABEL_76:
        double result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**,false>(v9, v53, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v12 = (int8x16_t *)&v53->u64[1];
      }
      BOOL v62 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(v9, v53, a3);
      unint64_t v12 = (int8x16_t *)&v53->u64[1];
      double result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(&v53->i64[1], a2, a3);
      if (result) {
        break;
      }
      if (!v62) {
        goto LABEL_76;
      }
    }
    a2 = v53;
    if (!v62) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(void *a1, void *a2, unsigned int (**a3)(uint64_t))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      char v9 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v10 = ((uint64_t (*)(void, void))*a3)(*(a2 - 1), a1[1]);
      if (v9)
      {
        uint64_t v11 = *a1;
        if (v10)
        {
          *a1 = *(a2 - 1);
          *(a2 - 1) = v11;
        }
        else
        {
          *a1 = a1[1];
          a1[1] = v11;
          if ((*a3)(*(a2 - 1)))
          {
            uint64_t v26 = a1[1];
            a1[1] = *(a2 - 1);
            *(a2 - 1) = v26;
          }
        }
      }
      else if (v10)
      {
        uint64_t v24 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v24;
        int v19 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
LABEL_17:
        if (v19) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      unint64_t v12 = a1 + 2;
      uint64_t v13 = a1 + 3;
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      if (!((unsigned int (*)(void, void))*a3)(*(a2 - 1), a1[3])) {
        return 1;
      }
      uint64_t v14 = *v13;
      *uint64_t v13 = *(a2 - 1);
      *(a2 - 1) = v14;
      if (!((unsigned int (*)(void, void))*a3)(*v13, *v12)) {
        return 1;
      }
      uint64_t v15 = *v12;
      *unint64_t v12 = *v13;
      *uint64_t v13 = v15;
      if (!((unsigned int (*)(void))*a3)()) {
        return 1;
      }
      uint64_t v17 = a1[1];
      uint64_t v16 = a1[2];
      uint64_t v18 = *a1;
      a1[1] = v16;
      a1[2] = v17;
      int v19 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v16, v18);
      goto LABEL_17;
    default:
      char v20 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v21 = a1 + 2;
      int v22 = ((uint64_t (*)(void, void))*a3)(a1[2], a1[1]);
      if (v20)
      {
        uint64_t v23 = *a1;
        if (v22)
        {
          *a1 = a1[2];
          a1[2] = v23;
        }
        else
        {
          uint64_t v27 = a1[2];
          *a1 = a1[1];
          a1[1] = v23;
          if ((*a3)(v27)) {
            *(int8x16_t *)(a1 + 1) = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
          }
        }
      }
      else if (v22)
      {
        uint64_t v25 = a1[1];
        a1[1] = a1[2];
        a1[2] = v25;
        if (((unsigned int (*)(void))*a3)()) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      uint64_t v28 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v29 = 0;
      int v30 = 0;
      break;
  }
  while (!((unsigned int (*)(void, void))*a3)(*v28, *v21))
  {
LABEL_35:
    int v21 = v28;
    v29 += 8;
    if (++v28 == a2) {
      return 1;
    }
  }
  uint64_t v31 = *v28;
  uint64_t v32 = v29;
  do
  {
    uint64_t v33 = (char *)a1 + v32;
    *(void *)((char *)a1 + v32 + 24) = *(void *)((char *)a1 + v32 + 16);
    if (v32 == -16)
    {
      *a1 = v31;
      if (++v30 != 8) {
        goto LABEL_35;
      }
      return v28 + 1 == a2;
    }
    v32 -= 8;
  }
  while ((((uint64_t (*)(uint64_t, void))*a3)(v31, *((void *)v33 + 1)) & 1) != 0);
  *(void *)((char *)a1 + v32 + 24) = v31;
  if (++v30 != 8) {
    goto LABEL_35;
  }
  return v28 + 1 == a2;
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  char v10 = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
  int v11 = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
  if (v10)
  {
    uint64_t v12 = *a1;
    if (v11)
    {
      *a1 = *a3;
      *a3 = v12;
    }
    else
    {
      *a1 = *a2;
      *a2 = v12;
      if ((*a5)(*a3))
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
      }
    }
  }
  else if (v11)
  {
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    if (((unsigned int (*)(void, void))*a5)(*a2, *a1))
    {
      uint64_t v14 = *a1;
      *a1 = *a2;
      *a2 = v14;
    }
  }
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if (result)
  {
    uint64_t v17 = *a3;
    *a3 = *a4;
    *a4 = v17;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if (result)
    {
      uint64_t v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if (result)
      {
        uint64_t v19 = *a1;
        *a1 = *a2;
        *a2 = v19;
      }
    }
  }
  return result;
}

void *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**,p2t::Point**>(void *a1, void *a2, void *a3, unsigned int (**a4)(void, uint64_t))
{
  if (a1 != a2)
  {
    BOOL v5 = a2;
    uint64_t v52 = a2 - a1;
    int v47 = a3;
    uint64_t v48 = (char *)a2 - (char *)a1;
    unsigned int v49 = a2;
    if ((char *)a2 - (char *)a1 >= 9 && (unint64_t)v48 >= 0x10)
    {
      int64_t v38 = (unint64_t)(v52 - 2) >> 1;
      char v51 = a1 + 1;
      int64_t v39 = v38;
      do
      {
        if (v38 >= v39)
        {
          uint64_t v40 = (2 * v39) | 1;
          uint64_t v41 = &v51[2 * v39];
          if (2 * v39 + 2 < v52 && (*a4)(*v41, v41[1]))
          {
            ++v41;
            uint64_t v40 = 2 * v39 + 2;
          }
          uint64_t v42 = &a1[v39];
          if ((((uint64_t (*)(void, void))*a4)(*v41, *v42) & 1) == 0)
          {
            uint64_t v43 = *v42;
            do
            {
              int v44 = v41;
              *uint64_t v42 = *v41;
              if (v38 < v40) {
                break;
              }
              uint64_t v45 = (2 * v40) | 1;
              uint64_t v41 = &v51[2 * v40];
              uint64_t v46 = 2 * v40 + 2;
              if (v46 < v52 && (*a4)(*v41, v41[1]))
              {
                ++v41;
                uint64_t v45 = v46;
              }
              uint64_t v42 = v44;
              uint64_t v40 = v45;
            }
            while (!(*a4)(*v41, v43));
            *int v44 = v43;
            BOOL v5 = v49;
          }
        }
        BOOL v23 = v39-- <= 0;
      }
      while (!v23);
    }
    a3 = v5;
    unint64_t v7 = v47;
    uint64_t v8 = v48;
    if (v5 != v47)
    {
      if (v48 >= 16)
      {
        char v9 = v5;
        char v10 = a1 + 1;
        while (1)
        {
          if (((unsigned int (*)(void, void, void *))*a4)(*v9, *a1, a3))
          {
            uint64_t v12 = *v9;
            *char v9 = *a1;
            *a1 = v12;
            if (v8 == 16)
            {
              uint64_t v13 = a1 + 1;
              int64_t v14 = 1;
              if ((((uint64_t (*)(void))*a4)(*v10) & 1) == 0) {
                goto LABEL_23;
              }
            }
            else
            {
              unsigned int v15 = (*a4)(a1[1], a1[2]);
              if (v15) {
                uint64_t v13 = a1 + 2;
              }
              else {
                uint64_t v13 = a1 + 1;
              }
              if (v15) {
                int64_t v14 = 2;
              }
              else {
                int64_t v14 = 1;
              }
              if ((((uint64_t (*)(void, void))*a4)(*v13, *a1) & 1) == 0)
              {
LABEL_23:
                uint64_t v50 = v9;
                uint64_t v16 = *a1;
                uint64_t v17 = a1;
                do
                {
                  uint64_t v19 = v13;
                  void *v17 = *v13;
                  if ((uint64_t)((unint64_t)(v52 - 2) >> 1) < v14) {
                    break;
                  }
                  uint64_t v20 = (2 * v14) | 1;
                  uint64_t v13 = &v10[2 * v14];
                  uint64_t v21 = 2 * v14 + 2;
                  if (v21 < v52 && (*a4)(*v13, v13[1]))
                  {
                    ++v13;
                    uint64_t v20 = v21;
                  }
                  unsigned int v18 = (*a4)(*v13, v16);
                  uint64_t v17 = v19;
                  int64_t v14 = v20;
                }
                while (!v18);
                *uint64_t v19 = v16;
                unint64_t v7 = v47;
                uint64_t v8 = v48;
                char v9 = v50;
              }
            }
          }
          if (++v9 == v7) {
            goto LABEL_30;
          }
        }
      }
      do
      {
        if (((unsigned int (*)(void, void, void *))*a4)(*v5, *a1, a3))
        {
          uint64_t v11 = *v5;
          *BOOL v5 = *a1;
          *a1 = v11;
        }
        ++v5;
      }
      while (v5 != v47);
LABEL_30:
      a3 = v7;
    }
    if (v8 >= 9)
    {
      unint64_t v53 = a3;
      uint64_t v22 = (unint64_t)v8 >> 3;
      do
      {
        uint64_t v24 = 0;
        uint64_t v25 = *a1;
        uint64_t v26 = a1;
        do
        {
          uint64_t v27 = &v26[v24 + 1];
          uint64_t v28 = (2 * v24) | 1;
          uint64_t v29 = 2 * v24 + 2;
          if (v29 < v22 && (*a4)(v26[v24 + 1], v26[v24 + 2]))
          {
            ++v27;
            uint64_t v28 = v29;
          }
          *uint64_t v26 = *v27;
          uint64_t v26 = v27;
          uint64_t v24 = v28;
        }
        while (v28 <= (uint64_t)((unint64_t)(v22 - 2) >> 1));
        int v30 = v49 - 1;
        if (v27 == --v49)
        {
          *uint64_t v27 = v25;
        }
        else
        {
          *uint64_t v27 = *v30;
          *int v30 = v25;
          uint64_t v32 = (char *)v27 - (char *)a1 + 8;
          if (v32 >= 9)
          {
            unint64_t v33 = (((unint64_t)v32 >> 3) - 2) >> 1;
            uint64_t v34 = &a1[v33];
            if ((*a4)(*v34, *v27))
            {
              uint64_t v35 = *v27;
              do
              {
                uint64_t v36 = v34;
                *uint64_t v27 = *v34;
                if (!v33) {
                  break;
                }
                unint64_t v33 = (v33 - 1) >> 1;
                uint64_t v34 = &a1[v33];
                uint64_t v27 = v36;
              }
              while ((((uint64_t (*)(void, uint64_t))*a4)(*v34, v35) & 1) != 0);
              *uint64_t v36 = v35;
            }
          }
        }
        BOOL v23 = v22-- <= 2;
      }
      while (!v23);
      return v53;
    }
  }
  return a3;
}

float OpenSteer::RandomVectorInUnitRadiusSphere(OpenSteer *this)
{
  do
  {
    float v1 = (float)((float)rand() * 9.3132e-10) + -1.0;
    float v2 = (float)((float)rand() * 9.3132e-10) + -1.0;
    int v3 = rand();
  }
  while (sqrtf((float)((float)(v1 * v1) + (float)(v2 * v2))+ (float)((float)((float)((float)v3 * 9.3132e-10) + -1.0) * (float)((float)((float)v3 * 9.3132e-10) + -1.0))) >= 1.0);
  return v1;
}

float OpenSteer::randomVectorOnUnitRadiusXZDisk(OpenSteer *this)
{
  do
  {
    float v1 = (float)((float)rand() * 9.3132e-10) + -1.0;
    int v2 = rand();
  }
  while (sqrtf((float)(v1 * v1)+ (float)((float)((float)((float)v2 * 9.3132e-10) + -1.0) * (float)((float)((float)v2 * 9.3132e-10) + -1.0))) >= 1.0);
  return v1;
}

float OpenSteer::vecLimitDeviationAngleUtility(OpenSteer *this, float *a2, const Vec3 *a3, float a4, const Vec3 *a5)
{
  float v6 = *a2;
  float v5 = a2[1];
  float v7 = a2[2];
  float v8 = sqrtf((float)((float)(v6 * v6) + (float)(v5 * v5)) + (float)(v7 * v7));
  if (v8 == 0.0) {
    return *a2;
  }
  float x = a3->x;
  float y = a3->y;
  float z = a3->z;
  float v13 = (float)((float)(a3->x * v6) + (float)(y * v5)) + (float)(z * v7);
  if (this)
  {
    if ((float)(v13 / v8) < a4) {
      goto LABEL_7;
    }
    return *a2;
  }
  if ((float)(v13 / v8) <= a4) {
    return *a2;
  }
LABEL_7:
  float v14 = v6 - (float)(v13 * x);
  float v15 = sqrtf((float)((float)(v14 * v14) + (float)((float)(v5 - (float)(v13 * y)) * (float)(v5 - (float)(v13 * y))))+ (float)((float)(v7 - (float)(v13 * z)) * (float)(v7 - (float)(v13 * z))));
  if (v15 > 0.0) {
    float v14 = v14 * (float)(1.0 / v15);
  }
  return (float)((float)(x * a4) + (float)(v14 * sqrtf(1.0 - (float)(a4 * a4)))) * v8;
}

float OpenSteer::findPerpendicularIn3d(OpenSteer *this, const Vec3 *a2)
{
  float v2 = *(float *)this;
  float v3 = *((float *)this + 1);
  float v4 = *((float *)this + 2);
  if (*(float *)this <= v3 && v2 <= v4)
  {
    float v7 = 0.0;
    float v8 = 0.0;
  }
  else
  {
    BOOL v6 = v3 > v2;
    if (v3 > v4) {
      BOOL v6 = 1;
    }
    if (v6) {
      float v7 = 0.0;
    }
    else {
      float v7 = 1.0;
    }
    if (v6) {
      float v8 = 1.0;
    }
    else {
      float v8 = 0.0;
    }
  }
  return -(float)((float)(v7 * v4) - (float)(v8 * v3));
}

void sub_235ECCAAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235ECCC5C(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v2, 0x1080C4018622206);
  _Unwind_Resume(a1);
}

void sub_235ECCC8C(_Unwind_Exception *a1)
{
  float v2 = v1;

  _Unwind_Resume(a1);
}

void sub_235ECCE0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECCE20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECCE34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECCE44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECCF20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECCF30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCMonteCarloStrategist::bestMoveForActivePlayer(GKCMonteCarloStrategist *this)
{
}

void sub_235ECD140(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD15C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD190(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD1AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD1C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GKCMonteCarloStrategist::treePolicy(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  for (id i = a4; [i count]; id i = (id)v25)
  {
    uint64_t v10 = *(void *)(a2 + 16);
    uint64_t v9 = *(void *)(a2 + 24);
    if ([i count] > (unint64_t)((v9 - v10) >> 3)) {
      GKCMonteCarloStrategist::expand(a1, a2, i);
    }
    uint64_t v11 = *(uint64_t **)(a2 + 16);
    uint64_t v12 = *(void *)(a2 + 24) - (void)v11;
    if (v12)
    {
      unint64_t v13 = v12 >> 3;
      unint64_t v14 = *(void *)(a2 + 56);
      double v15 = (double)*(unint64_t *)(a1 + 24);
      if (v13 <= 1) {
        uint64_t v16 = 1;
      }
      else {
        uint64_t v16 = v13;
      }
      double v17 = 0.0;
      do
      {
        uint64_t v19 = *v11++;
        uint64_t v18 = v19;
        unint64_t v20 = *(void *)(v19 + 56);
        double v21 = *(double *)(v19 + 64) / (double)v20;
        long double v22 = log((double)(v14 / v20));
        double v23 = v21 + sqrt(v22 + v22) * v15;
        if (v23 >= v17) {
          a2 = v18;
        }
        double v17 = fmax(v23, v17);
        --v16;
      }
      while (v16);
    }
    uint64_t v24 = [*(id *)a2 activePlayer];

    uint64_t v25 = [*(id *)a2 gameModelUpdatesForPlayer:v24];

    id v7 = (id)v24;
  }

  return a2;
}

void sub_235ECD324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GKCMonteCarloStrategist::defaultPolicy(id *a1, void *a2)
{
  id v3 = a2;
  float v4 = [v3 activePlayer];
  float v5 = [v3 gameModelUpdatesForPlayer:v4];

  while ([v5 count])
  {
    BOOL v6 = objc_msgSend(v5, "objectAtIndexedSubscript:", objc_msgSend(a1[1], "nextIntWithUpperBound:", objc_msgSend(v5, "count")));
    [v3 applyGameModelUpdate:v6];
    id v7 = [v3 activePlayer];
    uint64_t v8 = [v3 gameModelUpdatesForPlayer:v7];

    float v5 = (void *)v8;
  }
  uint64_t v9 = [*a1 activePlayer];
  uint64_t v10 = [v3 isWinForPlayer:v9];

  return v10;
}

void sub_235ECD454(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD4DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GKCMonteCarloStrategist::deleteChildren(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    id v3 = *(uint64_t **)(a2 + 16);
    float v4 = *(uint64_t **)(a2 + 24);
    if (v3 != v4)
    {
      uint64_t v5 = result;
      do
      {
        if (*v3)
        {
          uint64_t result = GKCMonteCarloStrategist::deleteChildren(v5);
          uint64_t v6 = *v3;
          if (*v3)
          {
            id v7 = *(id *)v6;
            *(void *)uint64_t v6 = 0;

            uint64_t v8 = *(void **)(v6 + 8);
            *(void *)(v6 + 8) = 0;

            *(void *)(v6 + 40) = 0;
            uint64_t v9 = *(void **)(v6 + 16);
            if (v9)
            {
              *(void *)(v6 + 24) = v9;
              operator delete(v9);
            }

            uint64_t result = MEMORY[0x237DF7CA0](v6, 0x10A0C40AF943C6FLL);
          }
        }
        ++v3;
      }
      while (v3 != v4);
      id v3 = *(uint64_t **)(a2 + 16);
    }
    *(void *)(a2 + 24) = v3;
  }
  return result;
}

void GKCMonteCarloStrategist::expand(uint64_t a1, uint64_t a2, void *a3)
{
}

void sub_235ECD688(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v3, 0x10A0C40AF943C6FLL);

  _Unwind_Resume(a1);
}

void sub_235ECD6B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ECD6C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCTreeNode::addChild(void *a1, uint64_t a2)
{
  uint64_t v5 = (char *)a1[3];
  unint64_t v4 = a1[4];
  uint64_t v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *(void *)uint64_t v5 = a2;
    uint64_t v7 = (uint64_t)(v5 + 8);
    goto LABEL_23;
  }
  uint64_t v8 = (void **)(a1 + 2);
  uint64_t v9 = (char *)a1[2];
  uint64_t v10 = (v5 - v9) >> 3;
  unint64_t v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v12 = v4 - (void)v9;
  if (v12 >> 2 > v11) {
    unint64_t v11 = v12 >> 2;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v14 = (char *)operator new(8 * v13);
    double v15 = &v14[8 * v10];
    uint64_t v16 = &v14[8 * v13];
    *(void *)double v15 = a2;
    uint64_t v7 = (uint64_t)(v15 + 8);
    double v17 = (char *)(v5 - v9);
    if (v5 == v9) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  unint64_t v14 = 0;
  double v15 = (char *)(8 * v10);
  uint64_t v16 = 0;
  *(void *)(8 * v10) = a2;
  uint64_t v7 = 8 * v10 + 8;
  double v17 = (char *)(v5 - v9);
  if (v5 != v9)
  {
LABEL_14:
    unint64_t v18 = (unint64_t)(v17 - 8);
    if (v18 < 0x58) {
      goto LABEL_28;
    }
    if ((unint64_t)(v9 - v14) < 0x20) {
      goto LABEL_28;
    }
    uint64_t v19 = (v18 >> 3) + 1;
    uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v6 = &v5[-v20];
    v15 -= v20;
    double v21 = &v14[8 * v10 - 16];
    long double v22 = (long long *)(v5 - 16);
    uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *v22;
      *((_OWORD *)v21 - 1) = *(v22 - 1);
      *(_OWORD *)double v21 = v24;
      v21 -= 32;
      v22 -= 2;
      v23 -= 4;
    }
    while (v23);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        uint64_t v25 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v15 - 1) = v25;
        v15 -= 8;
      }
      while (v6 != v9);
    }
    uint64_t v6 = (char *)*v8;
  }
LABEL_21:
  a1[2] = v15;
  a1[3] = v7;
  a1[4] = v16;
  if (v6) {
    operator delete(v6);
  }
LABEL_23:
  a1[3] = v7;
}

void GKTriangleGraphNodes::GKTriangleGraphNodes(GKTriangleGraphNodes *this)
{
  *((void *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
}

void GKCMeshGraph::GKCMeshGraph(GKCMeshGraph *this)
{
  GKCGraph::GKCGraph(this);
  *float v2 = &unk_26E942D98;
  ClipperLib::Clipper::Clipper((ClipperLib::Clipper *)(v2 + 5), 0);
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((void *)this + 43) = 0;
  *((void *)this + 44) = (char *)this + 360;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((void *)this + 55) = 0;
  *((void *)this + 56) = (char *)this + 456;
  *((void *)this + 59) = (char *)this + 480;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_DWORD *)this + 132) = 1065353216;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *((_DWORD *)this + 142) = 1065353216;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_DWORD *)this + 152) = 1065353216;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *((_DWORD *)this + 162) = 1065353216;
  *((_WORD *)this + 328) = 1;
  *((unsigned char *)this + 658) = 0;
  *((void *)this + 83) = 0;
  *(_OWORD *)((char *)this + 680) = 0u;
}

{
  void *v2;

  GKCGraph::GKCGraph(this);
  *float v2 = &unk_26E942D98;
  ClipperLib::Clipper::Clipper((ClipperLib::Clipper *)(v2 + 5), 0);
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((void *)this + 43) = 0;
  *((void *)this + 44) = (char *)this + 360;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((void *)this + 55) = 0;
  *((void *)this + 56) = (char *)this + 456;
  *((void *)this + 59) = (char *)this + 480;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_DWORD *)this + 132) = 1065353216;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *((_DWORD *)this + 142) = 1065353216;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_DWORD *)this + 152) = 1065353216;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *((_DWORD *)this + 162) = 1065353216;
  *((_WORD *)this + 328) = 1;
  *((unsigned char *)this + 658) = 0;
  *((void *)this + 83) = 0;
  *(_OWORD *)((char *)this + 680) = 0u;
}

void sub_235ECD940(_Unwind_Exception *a1)
{
  GKCGraph::~GKCGraph(v1);
  _Unwind_Resume(a1);
}

void sub_235ECDA24(_Unwind_Exception *a1)
{
  GKCGraph::~GKCGraph(v1);
  _Unwind_Resume(a1);
}

void GKCMeshGraph::~GKCMeshGraph(id *this)
{
  *this = &unk_26E942D98;
  objc_destroyWeak(this + 83);
  float v2 = this[79];
  if (v2)
  {
    do
    {
      long long v24 = (void *)*v2;
      uint64_t v25 = (void *)v2[3];
      if (v25)
      {
        v2[4] = v25;
        operator delete(v25);
      }
      operator delete(v2);
      float v2 = v24;
    }
    while (v24);
  }
  id v3 = this[77];
  this[77] = 0;
  if (v3) {
    operator delete(v3);
  }
  unint64_t v4 = this[74];
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      operator delete(v4);
      unint64_t v4 = v5;
    }
    while (v5);
  }
  id v6 = this[72];
  this[72] = 0;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = this[69];
  if (v7)
  {
    do
    {
      uint64_t v8 = (void *)*v7;
      operator delete(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  id v9 = this[67];
  this[67] = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = this[64];
  if (v10)
  {
    do
    {
      unint64_t v11 = (void *)*v10;
      operator delete(v10);
      uint64_t v10 = v11;
    }
    while (v11);
  }
  id v12 = this[62];
  this[62] = 0;
  if (v12) {
    operator delete(v12);
  }
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)(this + 59), this[60]);
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)(this + 56), this[57]);
  unint64_t v13 = (char *)this[53];
  if (v13)
  {
    unint64_t v14 = (char *)this[54];
    id v15 = this[53];
    if (v14 != v13)
    {
      do
      {
        uint64_t v16 = (void *)*((void *)v14 - 1);
        v14 -= 8;
      }
      while (v14 != v13);
      id v15 = this[53];
    }
    this[54] = v13;
    operator delete(v15);
  }
  id v17 = this[50];
  if (v17)
  {
    this[51] = v17;
    operator delete(v17);
  }
  id v18 = this[47];
  if (v18)
  {
    this[48] = v18;
    operator delete(v18);
  }
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)(this + 44), this[45]);
  id v19 = this[40];
  if (v19)
  {
    this[41] = v19;
    operator delete(v19);
  }
  uint64_t v20 = (char *)this[37];
  if (v20)
  {
    double v21 = (char *)this[38];
    id v22 = this[37];
    if (v21 != v20)
    {
      uint64_t v23 = (char *)this[38];
      do
      {
        uint64_t v27 = (void *)*((void *)v23 - 3);
        v23 -= 24;
        uint64_t v26 = v27;
        if (v27)
        {
          *((void *)v21 - 2) = v26;
          operator delete(v26);
        }
        double v21 = v23;
      }
      while (v23 != v20);
      id v22 = this[37];
    }
    this[38] = v20;
    operator delete(v22);
  }
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)(this + 5));

  GKCGraph::~GKCGraph(this);
}

{
  uint64_t vars8;

  GKCMeshGraph::~GKCMeshGraph(this);

  JUMPOUT(0x237DF7CA0);
}

void **std::vector<std::vector<ClipperLib::IntPoint>>::~vector[abi:ne180100](void **a1)
{
  float v2 = (char *)*a1;
  if (*a1)
  {
    id v3 = (char *)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = (char *)a1[1];
      do
      {
        uint64_t v7 = (void *)*((void *)v5 - 3);
        v5 -= 24;
        id v6 = v7;
        if (v7)
        {
          *((void *)v3 - 2) = v6;
          operator delete(v6);
        }
        id v3 = v5;
      }
      while (v5 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void GKCMeshGraph::AddObstacle(GKCMeshGraph *this, id *a2)
{
  id v90 = 0;
  float v4 = *((float *)this + 168);
  if (v4 == 0.0)
  {
    id v5 = a2[8];
    id v90 = v5;
  }
  else
  {
    GKCPolygonObstacle::extrudeObstacle((GKCPolygonObstacle *)a2, (GKCPolygonObstacle *)a2, v4);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    id v6 = v90;
    id v90 = v5;
  }
  uint64_t v7 = [v5 cPolygonObstacle];
  uint64_t v8 = [v90 cPolygonObstacle];
  id v9 = (uint64_t *)*((void *)this + 57);
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v11 = (uint64_t **)v9;
        unint64_t v12 = v9[4];
        if (v12 <= (unint64_t)a2) {
          break;
        }
        id v9 = *v11;
        uint64_t v10 = v11;
        if (!*v11) {
          goto LABEL_11;
        }
      }
      if (v12 >= (unint64_t)a2) {
        break;
      }
      id v9 = v11[1];
      if (!v9)
      {
        uint64_t v10 = v11 + 1;
        goto LABEL_11;
      }
    }
    unint64_t v13 = (uint64_t *)v11;
  }
  else
  {
    uint64_t v10 = (uint64_t **)((char *)this + 456);
    unint64_t v11 = (uint64_t **)((char *)this + 456);
LABEL_11:
    unint64_t v13 = (uint64_t *)operator new(0x30uLL);
    v13[4] = (uint64_t)a2;
    v13[5] = 0;
    *unint64_t v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v11;
    *uint64_t v10 = v13;
    uint64_t v14 = **((void **)this + 56);
    id v15 = v13;
    if (v14)
    {
      *((void *)this + 56) = v14;
      id v15 = *v10;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 57), v15);
    ++*((void *)this + 58);
  }
  v13[5] = v8;
  unint64_t v16 = [v90 cPolygonObstacle];
  unint64_t v17 = v16;
  id v18 = (uint64_t *)*((void *)this + 60);
  if (!v18)
  {
    id v19 = (uint64_t **)((char *)this + 480);
    uint64_t v20 = (uint64_t **)((char *)this + 480);
LABEL_22:
    id v22 = (uint64_t *)operator new(0x30uLL);
    v22[4] = v17;
    v22[5] = 0;
    *id v22 = 0;
    v22[1] = 0;
    v22[2] = (uint64_t)v20;
    *id v19 = v22;
    uint64_t v23 = **((void **)this + 59);
    long long v24 = v22;
    if (v23)
    {
      *((void *)this + 59) = v23;
      long long v24 = *v19;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 60), v24);
    ++*((void *)this + 61);
    v22[5] = (uint64_t)a2;
    uint64_t v25 = (void *)*((void *)this + 54);
    if ((unint64_t)v25 < *((void *)this + 55)) {
      goto LABEL_25;
    }
LABEL_28:
    *((void *)this + 54) = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>((void *)this + 53, &v90);
    uint64_t v27 = (id **)*((void *)this + 48);
    unint64_t v26 = *((void *)this + 49);
    if ((unint64_t)v27 < v26) {
      goto LABEL_26;
    }
    goto LABEL_29;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v20 = (uint64_t **)v18;
      unint64_t v21 = v18[4];
      if (v16 >= v21) {
        break;
      }
      id v18 = *v20;
      id v19 = v20;
      if (!*v20) {
        goto LABEL_22;
      }
    }
    if (v21 >= v16) {
      break;
    }
    id v18 = v20[1];
    if (!v18)
    {
      id v19 = v20 + 1;
      goto LABEL_22;
    }
  }
  v20[5] = (uint64_t *)a2;
  uint64_t v25 = (void *)*((void *)this + 54);
  if ((unint64_t)v25 >= *((void *)this + 55)) {
    goto LABEL_28;
  }
LABEL_25:
  void *v25 = v90;
  *((void *)this + 54) = v25 + 1;
  uint64_t v27 = (id **)*((void *)this + 48);
  unint64_t v26 = *((void *)this + 49);
  if ((unint64_t)v27 < v26)
  {
LABEL_26:
    *uint64_t v27 = a2;
    uint64_t v28 = (uint64_t)(v27 + 1);
    goto LABEL_40;
  }
LABEL_29:
  uint64_t v29 = (char *)*((void *)this + 47);
  uint64_t v30 = ((char *)v27 - v29) >> 3;
  unint64_t v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v32 = v26 - (void)v29;
  if (v32 >> 2 > v31) {
    unint64_t v31 = v32 >> 2;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v33 = v31;
  }
  if (v33)
  {
    if (v33 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v34 = (char *)operator new(8 * v33);
    uint64_t v35 = (id **)&v34[8 * v30];
    uint64_t v36 = &v34[8 * v33];
    *uint64_t v35 = a2;
    uint64_t v28 = (uint64_t)(v35 + 1);
    char v37 = (char *)((char *)v27 - v29);
    if (v27 == (id **)v29)
    {
LABEL_38:
      *((void *)this + 47) = v35;
      *((void *)this + 48) = v28;
      *((void *)this + 49) = v36;
      if (!v27) {
        goto LABEL_40;
      }
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v34 = 0;
    uint64_t v35 = (id **)(8 * v30);
    uint64_t v36 = 0;
    *(void *)(8 * v30) = a2;
    uint64_t v28 = 8 * v30 + 8;
    char v37 = (char *)((char *)v27 - v29);
    if (v27 == (id **)v29) {
      goto LABEL_38;
    }
  }
  unint64_t v67 = (unint64_t)(v37 - 8);
  if (v67 < 0x58) {
    goto LABEL_102;
  }
  if ((unint64_t)(v29 - v34) < 0x20) {
    goto LABEL_102;
  }
  uint64_t v68 = (v67 >> 3) + 1;
  uint64_t v69 = 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v70 = &v27[v69 / 0xFFFFFFFFFFFFFFF8];
  uint64_t v35 = (id **)((char *)v35 - v69);
  char v71 = &v34[8 * v30 - 16];
  uint64_t v72 = v27 - 2;
  uint64_t v73 = v68 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v74 = *(_OWORD *)v72;
    *((_OWORD *)v71 - 1) = *((_OWORD *)v72 - 1);
    *(_OWORD *)char v71 = v74;
    v71 -= 32;
    v72 -= 4;
    v73 -= 4;
  }
  while (v73);
  uint64_t v27 = v70;
  if (v68 != (v68 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_102:
    do
    {
      uint64_t v75 = *--v27;
      *--uint64_t v35 = v75;
    }
    while (v27 != (id **)v29);
  }
  uint64_t v27 = (id **)*((void *)this + 47);
  *((void *)this + 47) = v35;
  *((void *)this + 48) = v28;
  *((void *)this + 49) = v36;
  if (v27) {
LABEL_39:
  }
    operator delete(v27);
LABEL_40:
  *((void *)this + 48) = v28;
  uint64_t v38 = [v90 cPolygonObstacle];
  uint64_t v39 = v38;
  uint64_t v41 = (uint64_t *)*((void *)this + 51);
  unint64_t v40 = *((void *)this + 52);
  if ((unint64_t)v41 < v40)
  {
    *uint64_t v41 = v38;
    uint64_t v42 = (uint64_t)(v41 + 1);
    goto LABEL_53;
  }
  uint64_t v43 = (char *)*((void *)this + 50);
  uint64_t v44 = ((char *)v41 - v43) >> 3;
  unint64_t v45 = v44 + 1;
  if ((unint64_t)(v44 + 1) >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v46 = v40 - (void)v43;
  if (v46 >> 2 > v45) {
    unint64_t v45 = v46 >> 2;
  }
  if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v47 = v45;
  }
  if (v47)
  {
    if (v47 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v48 = (char *)operator new(8 * v47);
    unsigned int v49 = (uint64_t *)&v48[8 * v44];
    uint64_t v50 = &v48[8 * v47];
    *unsigned int v49 = v39;
    uint64_t v42 = (uint64_t)(v49 + 1);
    char v51 = (char *)((char *)v41 - v43);
    if (v41 == (uint64_t *)v43)
    {
LABEL_51:
      *((void *)this + 50) = v49;
      *((void *)this + 51) = v42;
      *((void *)this + 52) = v50;
      if (!v41) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }
  }
  else
  {
    uint64_t v48 = 0;
    unsigned int v49 = (uint64_t *)(8 * v44);
    uint64_t v50 = 0;
    *(void *)(8 * v44) = v39;
    uint64_t v42 = 8 * v44 + 8;
    char v51 = (char *)((char *)v41 - v43);
    if (v41 == (uint64_t *)v43) {
      goto LABEL_51;
    }
  }
  unint64_t v76 = (unint64_t)(v51 - 8);
  if (v76 < 0x58) {
    goto LABEL_103;
  }
  if ((unint64_t)(v43 - v48) < 0x20) {
    goto LABEL_103;
  }
  uint64_t v77 = (v76 >> 3) + 1;
  uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v79 = &v41[v78 / 0xFFFFFFFFFFFFFFF8];
  unsigned int v49 = (uint64_t *)((char *)v49 - v78);
  uint64_t v80 = &v48[8 * v44 - 16];
  id v81 = v41 - 2;
  uint64_t v82 = v77 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v83 = *(_OWORD *)v81;
    *((_OWORD *)v80 - 1) = *((_OWORD *)v81 - 1);
    *(_OWORD *)uint64_t v80 = v83;
    v80 -= 32;
    v81 -= 4;
    v82 -= 4;
  }
  while (v82);
  uint64_t v41 = v79;
  if (v77 != (v77 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_103:
    do
    {
      uint64_t v84 = *--v41;
      *--unsigned int v49 = v84;
    }
    while (v41 != (uint64_t *)v43);
  }
  uint64_t v41 = (uint64_t *)*((void *)this + 50);
  *((void *)this + 50) = v49;
  *((void *)this + 51) = v42;
  *((void *)this + 52) = v50;
  if (v41) {
LABEL_52:
  }
    operator delete(v41);
LABEL_53:
  *((void *)this + 51) = v42;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  __p = 0;
  uint64_t v52 = *(void *)(v7 + 16) - *(void *)(v7 + 8);
  if (v52)
  {
    unint64_t v53 = 0;
    uint64_t v54 = 0;
    unsigned int v55 = 0;
    unint64_t v56 = v52 >> 3;
    float64x2_t v86 = (float64x2_t)vdupq_n_s64(0x40C3880000000000uLL);
    while (1)
    {
      int64x2_t v58 = vcvtq_s64_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(*(void *)(v7 + 8) + 8 * v54)), v86));
      if (v53 >= v89) {
        break;
      }
      *(int64x2_t *)unint64_t v53 = v58;
      id v57 = (int64x2_t *)(v53 + 16);
LABEL_56:
      uint64_t v88 = v57;
      unint64_t v53 = (char *)v57;
      uint64_t v54 = ++v55;
      if (v56 <= v55) {
        goto LABEL_73;
      }
    }
    uint64_t v59 = (char *)__p;
    uint64_t v60 = (v53 - (unsigned char *)__p) >> 4;
    unint64_t v61 = v60 + 1;
    if ((unint64_t)(v60 + 1) >> 60) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v62 = v89 - (unsigned char *)__p;
    if ((v89 - (unsigned char *)__p) >> 3 > v61) {
      unint64_t v61 = v62 >> 3;
    }
    if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v63 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v63 = v61;
    }
    if (v63)
    {
      int64x2_t v85 = v58;
      if (v63 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v64 = (char *)operator new(16 * v63);
      uint64_t v65 = (int64x2_t *)&v64[16 * v60];
      *uint64_t v65 = v85;
      id v57 = v65 + 1;
      if (v53 == v59) {
        goto LABEL_71;
      }
    }
    else
    {
      unint64_t v64 = 0;
      uint64_t v65 = (int64x2_t *)(16 * v60);
      uint64_t v66 = (int64x2_t *)(16 * v60);
      *uint64_t v66 = v58;
      id v57 = v66 + 1;
      if (v53 == v59) {
        goto LABEL_71;
      }
    }
    do
    {
      v65[-1] = *((int64x2_t *)v53 - 1);
      --v65;
      v53 -= 16;
    }
    while (v53 != v59);
    unint64_t v53 = (char *)__p;
LABEL_71:
    __p = v65;
    uint64_t v88 = v57;
    uint64_t v89 = &v64[16 * v63];
    if (v53) {
      operator delete(v53);
    }
    goto LABEL_56;
  }
LABEL_73:
  ClipperLib::ClipperBase::AddPath((uint64_t)this + *(void *)(*((void *)this + 5) - 24) + 40, (uint64_t)&__p, 0, 1);
  if (__p)
  {
    uint64_t v88 = __p;
    operator delete(__p);
  }
}

void sub_235ECE348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_235ECE35C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void GKCMeshGraph::RemoveObstacle(GKCMeshGraph *this, GKCPolygonObstacle *a2)
{
  float v4 = (uint64_t **)((char *)this + 456);
  id v5 = (uint64_t *)*((void *)this + 57);
  id v6 = (uint64_t **)((char *)this + 456);
  uint64_t v7 = (uint64_t **)((char *)this + 456);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= (unint64_t)a2) {
          break;
        }
        id v5 = *v7;
        id v6 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      if (v8 >= (unint64_t)a2) {
        break;
      }
      id v5 = v7[1];
      if (!v5)
      {
        id v6 = v7 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    id v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = (uint64_t *)a2;
    v7[5] = 0;
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    uint64_t v10 = **((void **)this + 56);
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *((void *)this + 56) = v10;
      unint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 57), v11);
    ++*((void *)this + 58);
  }
  unint64_t v12 = v7[5];
  unint64_t v56 = 0;
  id v57 = 0;
  __p = 0;
  unint64_t v13 = v12[2] - v12[1];
  if ((int)(v13 >> 3) >= 1)
  {
    uint64_t v14 = 0;
    id v15 = 0;
    unint64_t v16 = 0;
    uint64_t v17 = (v13 >> 3);
    float64x2_t v54 = (float64x2_t)vdupq_n_s64(0x40C3880000000000uLL);
    do
    {
      while (1)
      {
        int64x2_t v19 = vcvtq_s64_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(v12[1] + 8 * (v17 - 1))), v54));
        if (v15 >= v14) {
          break;
        }
        *v15++ = v19;
        unint64_t v56 = v15;
        BOOL v18 = v17-- <= 1;
        if (v18) {
          goto LABEL_34;
        }
      }
      uint64_t v20 = v15 - v16;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 60) {
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
      if (((char *)v14 - (char *)v16) >> 3 > v21) {
        unint64_t v21 = ((char *)v14 - (char *)v16) >> 3;
      }
      if ((unint64_t)((char *)v14 - (char *)v16) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v21;
      }
      if (v22)
      {
        int64x2_t v53 = v19;
        if (v22 >> 60) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v23 = (char *)operator new(16 * v22);
        long long v24 = (int64x2_t *)&v23[16 * v20];
        int64x2_t *v24 = v53;
        uint64_t v25 = v24 + 1;
        if (v15 == v16)
        {
LABEL_32:
          uint64_t v27 = v24;
          uint64_t v14 = (int64x2_t *)&v23[16 * v22];
          __p = v24;
          id v57 = v14;
          if (!v16) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v23 = 0;
        long long v24 = (int64x2_t *)(16 * v20);
        unint64_t v26 = (int64x2_t *)(16 * v20);
        *unint64_t v26 = v19;
        uint64_t v25 = v26 + 1;
        if (v15 == v16) {
          goto LABEL_32;
        }
      }
      do
      {
        uint64_t v27 = v24 - 1;
        v24[-1] = v15[-1];
        --v15;
        --v24;
      }
      while (v15 != v16);
      uint64_t v14 = (int64x2_t *)&v23[16 * v22];
      __p = v27;
      id v57 = v14;
      if (!v16) {
        goto LABEL_29;
      }
LABEL_28:
      operator delete(v16);
LABEL_29:
      unint64_t v16 = v27;
      unint64_t v56 = v25;
      id v15 = v25;
      BOOL v18 = v17-- <= 1;
    }
    while (!v18);
  }
LABEL_34:
  ClipperLib::ClipperBase::AddPath((uint64_t)this + *(void *)(*((void *)this + 5) - 24) + 40, (uint64_t)&__p, 0, 1);
  uint64_t v28 = *v4;
  uint64_t v29 = v4;
  if (*v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v29 = (uint64_t **)v28;
        unint64_t v30 = v28[4];
        if (v30 <= (unint64_t)a2) {
          break;
        }
        uint64_t v28 = *v29;
        float v4 = v29;
        if (!*v29) {
          goto LABEL_41;
        }
      }
      if (v30 >= (unint64_t)a2) {
        break;
      }
      uint64_t v28 = v29[1];
      if (!v28)
      {
        float v4 = v29 + 1;
        goto LABEL_41;
      }
    }
    v29[5] = 0;
    uint64_t v34 = (uint64_t *)*((void *)this + 60);
    if (v34) {
      goto LABEL_48;
    }
    goto LABEL_46;
  }
LABEL_41:
  unint64_t v31 = (uint64_t *)operator new(0x30uLL);
  v31[4] = (uint64_t)a2;
  v31[5] = 0;
  *unint64_t v31 = 0;
  v31[1] = 0;
  v31[2] = (uint64_t)v29;
  void *v4 = v31;
  uint64_t v32 = **((void **)this + 56);
  unint64_t v33 = v31;
  if (v32)
  {
    *((void *)this + 56) = v32;
    unint64_t v33 = *v4;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 57), v33);
  ++*((void *)this + 58);
  v31[5] = 0;
  uint64_t v34 = (uint64_t *)*((void *)this + 60);
  if (!v34)
  {
LABEL_46:
    uint64_t v35 = (uint64_t **)((char *)this + 480);
    uint64_t v36 = (uint64_t **)((char *)this + 480);
LABEL_52:
    uint64_t v38 = (uint64_t *)operator new(0x30uLL);
    v38[4] = (uint64_t)v12;
    v38[5] = 0;
    *uint64_t v38 = 0;
    v38[1] = 0;
    v38[2] = (uint64_t)v36;
    *uint64_t v35 = v38;
    uint64_t v39 = **((void **)this + 59);
    unint64_t v40 = v38;
    if (v39)
    {
      *((void *)this + 59) = v39;
      unint64_t v40 = *v35;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 60), v40);
    ++*((void *)this + 61);
    v38[5] = 0;
    uint64_t v42 = (GKCPolygonObstacle **)*((void *)this + 47);
    uint64_t v41 = (GKCPolygonObstacle **)*((void *)this + 48);
    if (v42 != v41)
    {
LABEL_57:
      while (*v42 != a2)
      {
        if (++v42 == v41)
        {
          uint64_t v42 = v41;
          goto LABEL_60;
        }
      }
    }
    goto LABEL_60;
  }
  while (1)
  {
LABEL_48:
    while (1)
    {
      uint64_t v36 = (uint64_t **)v34;
      unint64_t v37 = v34[4];
      if ((unint64_t)v12 >= v37) {
        break;
      }
      uint64_t v34 = *v36;
      uint64_t v35 = v36;
      if (!*v36) {
        goto LABEL_52;
      }
    }
    if (v37 >= (unint64_t)v12) {
      break;
    }
    uint64_t v34 = v36[1];
    if (!v34)
    {
      uint64_t v35 = v36 + 1;
      goto LABEL_52;
    }
  }
  v36[5] = 0;
  uint64_t v42 = (GKCPolygonObstacle **)*((void *)this + 47);
  uint64_t v41 = (GKCPolygonObstacle **)*((void *)this + 48);
  if (v42 != v41) {
    goto LABEL_57;
  }
LABEL_60:
  int64_t v43 = (char *)v41 - (char *)(v42 + 1);
  if (v41 != v42 + 1) {
    memmove(v42, v42 + 1, (char *)v41 - (char *)(v42 + 1));
  }
  *((void *)this + 48) = (char *)v42 + v43;
  unint64_t v45 = (void *)*((void *)this + 50);
  uint64_t v44 = (char *)*((void *)this + 51);
  if (v45 != (void *)v44)
  {
    while ((uint64_t *)*v45 != v12)
    {
      if (++v45 == (void *)v44)
      {
        unint64_t v45 = (void *)*((void *)this + 51);
        break;
      }
    }
  }
  int64_t v46 = v44 - (char *)(v45 + 1);
  if (v44 != (char *)(v45 + 1)) {
    memmove(v45, v45 + 1, v44 - (char *)(v45 + 1));
  }
  *((void *)this + 51) = (char *)v45 + v46;
  uint64_t v48 = (void *)*((void *)this + 53);
  unint64_t v47 = (void *)*((void *)this + 54);
  if (v48 != v47)
  {
    while (*v48 != v12[8])
    {
      if (++v48 == v47)
      {
        uint64_t v48 = (void *)*((void *)this + 54);
        break;
      }
    }
  }
  unsigned int v49 = v48 + 1;
  if (v48 + 1 != v47)
  {
    do
    {
      uint64_t v48 = v49;
      uint64_t v50 = (void *)*(v49 - 1);
      *(v49 - 1) = *v49;
      *unsigned int v49 = 0;

      unsigned int v49 = v48 + 1;
    }
    while (v48 + 1 != v47);
    unint64_t v47 = (void *)*((void *)this + 54);
  }
  while (v47 != v48)
  {
    char v51 = (void *)*--v47;
  }
  *((void *)this + 54) = v48;
  if (__p)
  {
    unint64_t v56 = __p;
    operator delete(__p);
  }
}

void sub_235ECE8AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void GKCMeshGraph::Triangulate(GKCMeshGraph *this)
{
  unint64_t v2 = *((void *)this + 2) - *((void *)this + 1);
  if ((int)(v2 >> 3) >= 1)
  {
    unint64_t v3 = (v2 >> 3) + 1;
    do
      (*(void (**)(GKCMeshGraph *, void))(*(void *)this + 16))(this, *(void *)(*((void *)this + 1) + 8 * (v3-- - 2)));
    while (v3 > 1);
  }
  float v4 = (p2t::SweepContext **)*((void *)this + 43);
  if (v4)
  {
    p2t::CDT::~CDT(v4);
    MEMORY[0x237DF7CA0]();
  }
  for (id i = (void *)*((void *)this + 79); i; id i = (void *)*i)
  {
    unint64_t v21 = i[4] - i[3];
    if ((int)(v21 >> 3) >= 1)
    {
      unint64_t v22 = (v21 >> 3) + 1;
      do
      {
        uint64_t v23 = (v22 - 2);
        uint64_t v24 = i[3];
        uint64_t v25 = *(void *)(v24 + 8 * v23);
        if (v25)
        {
          MEMORY[0x237DF7CA0](v25, 0x20C40A4A59CD2);
          uint64_t v24 = i[3];
        }
        *(void *)(v24 + 8 * v23) = 0;
        --v22;
      }
      while (v22 > 1);
    }
  }
  if (*((void *)this + 65))
  {
    id v6 = (void *)*((void *)this + 64);
    if (v6)
    {
      do
      {
        uint64_t v7 = (void *)*v6;
        operator delete(v6);
        id v6 = v7;
      }
      while (v7);
    }
    *((void *)this + 64) = 0;
    uint64_t v8 = *((void *)this + 63);
    if (v8)
    {
      for (uint64_t j = 0; j != v8; ++j)
        *(void *)(*((void *)this + 62) + 8 * j) = 0;
    }
    *((void *)this + 65) = 0;
  }
  if (*((void *)this + 70))
  {
    uint64_t v10 = (void *)*((void *)this + 69);
    if (v10)
    {
      do
      {
        unint64_t v11 = (void *)*v10;
        operator delete(v10);
        uint64_t v10 = v11;
      }
      while (v11);
    }
    *((void *)this + 69) = 0;
    uint64_t v12 = *((void *)this + 68);
    if (v12)
    {
      for (uint64_t k = 0; k != v12; ++k)
        *(void *)(*((void *)this + 67) + 8 * k) = 0;
    }
    *((void *)this + 70) = 0;
  }
  if (*((void *)this + 75))
  {
    uint64_t v14 = (void *)*((void *)this + 74);
    if (v14)
    {
      do
      {
        id v15 = (void *)*v14;
        operator delete(v14);
        uint64_t v14 = v15;
      }
      while (v15);
    }
    *((void *)this + 74) = 0;
    uint64_t v16 = *((void *)this + 73);
    if (v16)
    {
      for (uint64_t m = 0; m != v16; ++m)
        *(void *)(*((void *)this + 72) + 8 * m) = 0;
    }
    *((void *)this + 75) = 0;
  }
  if (*((void *)this + 80))
  {
    BOOL v18 = (void *)*((void *)this + 79);
    if (v18)
    {
      do
      {
        unint64_t v26 = (void *)*v18;
        uint64_t v27 = (void *)v18[3];
        if (v27)
        {
          v18[4] = v27;
          operator delete(v27);
        }
        operator delete(v18);
        BOOL v18 = v26;
      }
      while (v26);
    }
    *((void *)this + 79) = 0;
    uint64_t v19 = *((void *)this + 78);
    if (v19)
    {
      for (uint64_t n = 0; n != v19; ++n)
        *(void *)(*((void *)this + 77) + 8 * n) = 0;
    }
    *((void *)this + 80) = 0;
  }
  operator new();
}

void sub_235ECF59C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25)
{
  uint64_t v28 = *(void **)(v26 - 136);
  if (v28)
  {
    *(void *)(v26 - 128) = v28;
    operator delete(v28);
  }
  MEMORY[0x237DF7CA0](v25, 0x20C40A4A59CD2);
  uint64_t v29 = *(void **)(v26 - 112);
  if (v29)
  {
    *(void *)(v26 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(a1);
}

void sub_235ECF680(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a19)
  {
    operator delete(a19);
    if (!a22) {
      JUMPOUT(0x235ECF64CLL);
    }
    JUMPOUT(0x235ECF648);
  }
  JUMPOUT(0x235ECF640);
}

void sub_235ECF690(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19) {
    JUMPOUT(0x235ECF69CLL);
  }
  JUMPOUT(0x235ECF640);
}

void GKCMeshGraph::BuildGraphFromTriangles(GKCMeshGraph *this)
{
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)this + 352, *((void **)this + 45));
  *((void *)this + 45) = 0;
  *((void *)this + 46) = 0;
  *((void *)this + 44) = (char *)this + 360;
  unint64_t v2 = this;
  p2t::CDT::GetTriangles(*((p2t::CDT **)this + 43), &v216);
  *(_OWORD *)int32x2_t v213 = 0u;
  *(_OWORD *)id v214 = 0u;
  int v215 = 1065353216;
  unint64_t v205 = this;
  if (v216 != v217)
  {
    float32x2_t v201 = (char *)this + 496;
    float32x2_t v203 = (char *)this + 616;
    locatiouint64_t n = (id *)((char *)this + 664);
    float32x2_t v3 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
    float v4 = (void **)v216;
    while (1)
    {
      uint64_t v5 = 0;
      v199 = v4;
      v218[0] = *v4;
      do
      {
        int32x2_t v212 = 0;
        id v6 = (p2t::Triangle *)v218[0][v5 + 1];
        int8x8_t v211 = 0;
        int32x2_t v212 = v6;
        unsigned int v7 = v5++ + 2;
        uint64_t v8 = (int)v5;
        if (v5 == 3) {
          uint64_t v8 = 0;
        }
        id v9 = (Point *)v218[0][v8 + 1];
        unint64_t v210 = 0;
        int8x8_t v211 = v9;
        unint64_t v210 = v218[0][v7 % 3 + 1];
        if (v6 < (p2t::Triangle *)v9)
        {
          __p = &v212;
          uint64_t v10 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v213, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          __p = &v211;
          if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<p2t::Point *,BOOL>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,BOOL>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,BOOL>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,BOOL>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)(v10 + 24), (uint64_t *)&v211, (uint64_t)&std::piecewise_construct, (void **)&__p)+ 24))
          {
            __p = &v212;
            std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v203, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
            operator new();
          }
        }
        if ((unint64_t)v212 < v210)
        {
          __p = &v212;
          unint64_t v11 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v213, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          __p = &v210;
          if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<p2t::Point *,BOOL>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,BOOL>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,BOOL>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,BOOL>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)(v11 + 24), (uint64_t *)&v210, (uint64_t)&std::piecewise_construct, (void **)&__p)+ 24))
          {
            __p = &v212;
            std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v203, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
            operator new();
          }
        }
      }
      while (v5 != 3);
      unint64_t v2 = this;
      if (*((unsigned char *)this + 656))
      {
        int32x2_t v212 = (p2t::Triangle *)v218[0][1];
        __p = &v212;
        if (!std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v201, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p)[3])
        {
          id WeakRetained = objc_loadWeakRetained(location);
          id v13 = objc_alloc((Class)[WeakRetained nodeClass]);
          *(float *)&double v14 = *(double *)v212;
          float v15 = *((double *)v212 + 1);
          *((float *)&v14 + 1) = v15;
          uint64_t v16 = (void *)[v13 initWithPoint:v14];

          uint64_t v17 = [v16 cGraphNode2D];
          __p = &v212;
          std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v201, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p)[3] = v17;
          GKCGraph::addNode(this, (id *)[v16 cGraphNode2D]);
        }
        int32x2_t v212 = (p2t::Triangle *)v218[0][2];
        __p = &v212;
        if (!std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v201, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p)[3])
        {
          id v18 = objc_loadWeakRetained(location);
          id v19 = objc_alloc((Class)[v18 nodeClass]);
          *(float *)&double v20 = *(double *)v212;
          float v21 = *((double *)v212 + 1);
          *((float *)&v20 + 1) = v21;
          unint64_t v22 = (void *)[v19 initWithPoint:v20];

          uint64_t v23 = [v22 cGraphNode2D];
          __p = &v212;
          std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v201, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p)[3] = v23;
          GKCGraph::addNode(this, (id *)[v22 cGraphNode2D]);
        }
        int32x2_t v212 = (p2t::Triangle *)v218[0][3];
        __p = &v212;
        if (!std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v201, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p)[3])break; {
      }
        }
      if (*((unsigned char *)this + 657)) {
        goto LABEL_21;
      }
LABEL_3:
      float v4 = v199 + 1;
      if (v199 + 1 == (void **)v217) {
        goto LABEL_24;
      }
    }
    id v43 = objc_loadWeakRetained(location);
    id v44 = objc_alloc((Class)[v43 nodeClass]);
    *(float *)&double v45 = *(double *)v212;
    float v46 = *((double *)v212 + 1);
    *((float *)&v45 + 1) = v46;
    unint64_t v47 = (void *)[v44 initWithPoint:v45];

    uint64_t v48 = [v47 cGraphNode2D];
    __p = &v212;
    std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)v201, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p)[3] = v48;
    GKCGraph::addNode(this, (id *)[v47 cGraphNode2D]);

    if (!*((unsigned char *)this + 657)) {
      goto LABEL_3;
    }
LABEL_21:
    uint64_t v24 = (double *)v218[0][1];
    uint64_t v25 = (double *)v218[0][2];
    double v27 = *v24;
    double v26 = v24[1];
    double v28 = *v25;
    double v29 = v25[1];
    unint64_t v30 = (double *)v218[0][3];
    double v31 = *v30;
    double v32 = v30[1];
    id v33 = objc_loadWeakRetained(location);
    id v34 = objc_alloc((Class)[v33 nodeClass]);
    v35.f32[0] = v27;
    float32_t v36 = v26;
    v35.f32[1] = v36;
    v37.f32[0] = v28;
    float32_t v38 = v29;
    v37.f32[1] = v38;
    float32x2_t v39 = vadd_f32(v37, v35);
    v37.f32[0] = v31;
    float32_t v40 = v32;
    v37.f32[1] = v40;
    uint64_t v41 = objc_msgSend(v34, "initWithPoint:", COERCE_DOUBLE(vmul_f32(vadd_f32(v37, v39), v3)));

    uint64_t v42 = [v41 cGraphNode2D];
    __p = v218;
    std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>((uint64_t)this + 536, (uint64_t *)v218, (uint64_t)&std::piecewise_construct, (void **)&__p)[3] = v42;
    GKCGraph::addNode(this, (id *)[v41 cGraphNode2D]);

    goto LABEL_3;
  }
LABEL_24:
  if (*((unsigned char *)v2 + 658))
  {
    unsigned int v49 = (void *)*((void *)this + 79);
    if (v49)
    {
      uint64_t v50 = (id *)((char *)this + 664);
      id i = (void **)v49[3];
      if (i != (void **)v49[4]) {
        goto LABEL_29;
      }
      while (1)
      {
        unsigned int v49 = (void *)*v49;
        if (!v49) {
          break;
        }
        for (id i = (void **)v49[3]; i != (void **)v49[4]; ++i)
        {
LABEL_29:
          v218[0] = 0;
          v218[0] = *i;
          uint64_t v52 = (double *)v218[0][1];
          double v53 = **(double **)v218[0];
          double v54 = *(double *)(*v218[0] + 8);
          double v55 = *v52;
          double v56 = v52[1];
          id v57 = objc_loadWeakRetained(v50);
          id v58 = objc_alloc((Class)[v57 nodeClass]);
          v59.f32[0] = v53;
          float32_t v60 = v54;
          v59.f32[1] = v60;
          v61.f32[0] = v55;
          float32_t v62 = v56;
          v61.f32[1] = v62;
          unint64_t v63 = objc_msgSend(v58, "initWithPoint:", COERCE_DOUBLE(vmla_f32(v59, vsub_f32(v61, v59), (float32x2_t)0x3F0000003F000000)));

          uint64_t v64 = [v63 cGraphNode2D];
          __p = v218;
          std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>((uint64_t)v205 + 576, (uint64_t *)v218, (uint64_t)&std::piecewise_construct, (void **)&__p)[3] = v64;
          GKCGraph::addNode(v205, (id *)[v63 cGraphNode2D]);
        }
      }
    }
  }
  if (*((unsigned char *)v205 + 656))
  {
    if (*((unsigned char *)v205 + 658))
    {
      uint64_t v65 = (void *)*((void *)v205 + 74);
      if (v65)
      {
        uint64_t v66 = (uint64_t)v205 + 496;
        do
        {
          uint64_t v68 = v65[2];
          unint64_t v67 = (id *)v65[3];
          v218[0] = 0;
          v218[0] = *(void **)v68;
          __p = v218;
          uint64_t v69 = (id *)std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v66, (uint64_t *)v218, (uint64_t)&std::piecewise_construct, (void **)&__p)[3];
          int32x2_t v212 = *(p2t::Triangle **)(v68 + 8);
          __p = &v212;
          uint64_t v70 = (id *)std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v66, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p)[3];
          GKCGraphNode::addConnectionToNode(v67, v69, 1);
          GKCGraphNode::addConnectionToNode(v67, v70, 1);
          uint64_t v65 = (void *)*v65;
        }
        while (v65);
      }
    }
    else
    {
      char v71 = (void *)*((void *)v205 + 79);
      if (v71)
      {
        uint64_t v72 = (uint64_t)v205 + 496;
        for (uint64_t j = (uint64_t *)v71[3]; ; uint64_t j = (uint64_t *)v71[3])
        {
          while (j != (uint64_t *)v71[4])
          {
            uint64_t v74 = *j;
            v218[0] = 0;
            v218[0] = *(void **)v74;
            __p = v218;
            uint64_t v75 = (id *)std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v72, (uint64_t *)v218, (uint64_t)&std::piecewise_construct, (void **)&__p)[3];
            int32x2_t v212 = *(p2t::Triangle **)(v74 + 8);
            __p = &v212;
            unint64_t v76 = std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v72, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
            GKCGraphNode::addConnectionToNode(v75, (id *)v76[3], 1);
            ++j;
          }
          char v71 = (void *)*v71;
          if (!v71) {
            break;
          }
        }
      }
    }
  }
  uint64_t v77 = v205;
  int v78 = *((unsigned __int8 *)v205 + 658);
  if (!*((unsigned char *)v205 + 657)) {
    goto LABEL_75;
  }
  uint64_t v79 = (p2t::Triangle **)v216;
  if (!*((unsigned char *)v205 + 658))
  {
    if (v216 == v217) {
      goto LABEL_192;
    }
    do
    {
      v218[0] = 0;
      v218[0] = *v79;
      __p = v218;
      uint64_t v80 = (id *)std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>((uint64_t)v205 + 536, (uint64_t *)v218, (uint64_t)&std::piecewise_construct, (void **)&__p)[3];
      id v81 = v218[0];
      uint64_t v82 = (p2t::Triangle *)v218[0][4];
      int32x2_t v212 = v82;
      long long v83 = v217;
      if (v82)
      {
        uint64_t v84 = v217;
        if (v216 != v217)
        {
          uint64_t v84 = (p2t::Triangle **)v216;
          while (*v84 != v82)
          {
            if (++v84 == v217)
            {
              uint64_t v84 = v217;
              break;
            }
          }
        }
        if (v84 != v217)
        {
          __p = &v212;
          int64x2_t v85 = std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>((uint64_t)v205 + 536, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          GKCGraphNode::addConnectionToNode(v80, (id *)v85[3], 0);
          id v81 = v218[0];
          long long v83 = v217;
        }
      }
      float64x2_t v86 = (p2t::Triangle *)v81[5];
      int32x2_t v212 = v86;
      if (v86)
      {
        uint64_t v87 = v83;
        if (v216 != v83)
        {
          uint64_t v87 = (p2t::Triangle **)v216;
          while (*v87 != v86)
          {
            if (++v87 == v83)
            {
              uint64_t v87 = v83;
              break;
            }
          }
        }
        if (v87 != v83)
        {
          __p = &v212;
          uint64_t v88 = std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>((uint64_t)v205 + 536, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          GKCGraphNode::addConnectionToNode(v80, (id *)v88[3], 0);
          id v81 = v218[0];
          long long v83 = v217;
        }
      }
      uint64_t v89 = (p2t::Triangle *)v81[6];
      int32x2_t v212 = v89;
      if (v89)
      {
        id v90 = v83;
        if (v216 != v83)
        {
          id v90 = (p2t::Triangle **)v216;
          while (*v90 != v89)
          {
            if (++v90 == v83)
            {
              id v90 = v83;
              break;
            }
          }
        }
        if (v90 != v83)
        {
          __p = &v212;
          uint64_t v91 = std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>((uint64_t)v205 + 536, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          GKCGraphNode::addConnectionToNode(v80, (id *)v91[3], 0);
          long long v83 = v217;
        }
      }
      ++v79;
    }
    while (v79 != v83);
    uint64_t v77 = v205;
    int v78 = *((unsigned __int8 *)v205 + 658);
LABEL_75:
    if (!v78) {
      goto LABEL_192;
    }
    uint64_t v79 = (p2t::Triangle **)v216;
    if (v216 == v217) {
      goto LABEL_192;
    }
    goto LABEL_77;
  }
  if (v216 == v217) {
    goto LABEL_192;
  }
LABEL_77:
  uint64_t v204 = (uint64_t)v77 + 616;
  uint64_t v92 = (uint64_t)v77 + 576;
  uint64_t v200 = (uint64_t)v77 + 536;
  while (2)
  {
    int32x2_t v212 = 0;
    unint64_t v202 = v79;
    int32x2_t v212 = *v79;
    uint64_t v93 = v212;
    uint64_t v94 = (char *)operator new(0x18uLL);
    __p = v94;
    float32x2_t v208 = v94;
    float32x2_t v209 = v94 + 24;
    int8x8_t v211 = (Point *)*((void *)v93 + 1);
    v218[0] = &v211;
    v95 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v204, (uint64_t *)&v211, (uint64_t)&std::piecewise_construct, v218);
    uint64_t v96 = v92;
    for (uint64_t k = (Point ***)v95[3]; k != (Point ***)v95[4]; ++k)
    {
      v99 = *k;
      unint64_t v100 = **k;
      if (v100 != v211) {
LABEL_208:
      }
        __assert_rtn("BuildGraphFromTriangles", "GKCMeshGraph.mm", 384, "edge->p == point");
      uint64_t v101 = v99[1];
      if (v101 != p2t::Triangle::PointCW(v212, v100))
      {
        uint64_t v102 = v99[1];
        if (v102 != p2t::Triangle::PointCCW(v212, v211)) {
          continue;
        }
      }
      if (v94 < v209)
      {
        *(void *)uint64_t v94 = v99;
        uint64_t v98 = (uint64_t)(v94 + 8);
        goto LABEL_81;
      }
      v103 = (char *)__p;
      int64_t v104 = v94 - (unsigned char *)__p;
      uint64_t v105 = (v94 - (unsigned char *)__p) >> 3;
      unint64_t v106 = v105 + 1;
      if ((unint64_t)(v105 + 1) >> 61) {
LABEL_210:
      }
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      uint64_t v107 = v209 - (unsigned char *)__p;
      if ((v209 - (unsigned char *)__p) >> 2 > v106) {
        unint64_t v106 = v107 >> 2;
      }
      if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v108 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v108 = v106;
      }
      if (v108)
      {
        if (v108 >> 61) {
LABEL_211:
        }
          std::__throw_bad_array_new_length[abi:ne180100]();
        uint64_t v109 = operator new(8 * v108);
        uint64_t v110 = (Point ***)&v109[8 * v105];
        *uint64_t v110 = v99;
        uint64_t v98 = (uint64_t)(v110 + 1);
        if (v94 == v103)
        {
LABEL_97:
          __p = v110;
          float32x2_t v208 = (void *)v98;
          float32x2_t v209 = &v109[8 * v108];
          if (!v94) {
            goto LABEL_81;
          }
LABEL_104:
          operator delete(v94);
LABEL_81:
          float32x2_t v208 = (void *)v98;
          uint64_t v94 = (char *)v98;
          continue;
        }
      }
      else
      {
        uint64_t v109 = 0;
        uint64_t v110 = (Point ***)(8 * v105);
        *(void *)(8 * v105) = v99;
        uint64_t v98 = 8 * v105 + 8;
        if (v94 == v103) {
          goto LABEL_97;
        }
      }
      unint64_t v111 = v94 - 8 - v103;
      if (v111 < 0x168)
      {
        float v112 = v94;
        goto LABEL_102;
      }
      if (&v109[v104 - 8 - (v111 & 0xFFFFFFFFFFFFFFF8)] > &v109[v104 - 8])
      {
        float v112 = v94;
        goto LABEL_102;
      }
      if (&v94[-(v111 & 0xFFFFFFFFFFFFFFF8) - 8] > v94 - 8)
      {
        float v112 = v94;
        goto LABEL_102;
      }
      if ((unint64_t)(v94 - v109 - v104) < 0x20)
      {
        float v112 = v94;
        goto LABEL_102;
      }
      uint64_t v114 = (v111 >> 3) + 1;
      uint64_t v115 = 8 * (v114 & 0x3FFFFFFFFFFFFFFCLL);
      float v112 = &v94[-v115];
      uint64_t v110 = (Point ***)((char *)v110 - v115);
      uint64_t v116 = &v109[8 * v105 - 16];
      uint64_t v117 = v94 - 16;
      uint64_t v118 = v114 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v119 = *(_OWORD *)v117;
        *(v116 - 1) = *((_OWORD *)v117 - 1);
        *uint64_t v116 = v119;
        v116 -= 2;
        v117 -= 32;
        v118 -= 4;
      }
      while (v118);
      if (v114 != (v114 & 0x3FFFFFFFFFFFFFFCLL))
      {
        do
        {
LABEL_102:
          uint64_t v113 = (Point **)*((void *)v112 - 1);
          v112 -= 8;
          *--uint64_t v110 = v113;
        }
        while (v112 != v103);
      }
      uint64_t v94 = (char *)__p;
      __p = v110;
      float32x2_t v208 = (void *)v98;
      float32x2_t v209 = &v109[8 * v108];
      if (v94) {
        goto LABEL_104;
      }
      goto LABEL_81;
    }
    int8x8_t v211 = (Point *)*((void *)v212 + 2);
    v218[0] = &v211;
    uint64_t v120 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v204, (uint64_t *)&v211, (uint64_t)&std::piecewise_construct, v218);
    for (uint64_t m = (Point ***)v120[3]; m != (Point ***)v120[4]; ++m)
    {
      unint64_t v123 = *m;
      v124 = **m;
      if (v124 != v211) {
        goto LABEL_208;
      }
      float v125 = v123[1];
      if (v125 != p2t::Triangle::PointCW(v212, v124))
      {
        unint64_t v126 = v123[1];
        if (v126 != p2t::Triangle::PointCCW(v212, v211)) {
          continue;
        }
      }
      if (v94 < v209)
      {
        *(void *)uint64_t v94 = v123;
        uint64_t v122 = (uint64_t)(v94 + 8);
        goto LABEL_117;
      }
      uint64_t v127 = (char *)__p;
      int64_t v128 = v94 - (unsigned char *)__p;
      uint64_t v129 = (v94 - (unsigned char *)__p) >> 3;
      unint64_t v130 = v129 + 1;
      if ((unint64_t)(v129 + 1) >> 61) {
        goto LABEL_210;
      }
      uint64_t v131 = v209 - (unsigned char *)__p;
      if ((v209 - (unsigned char *)__p) >> 2 > v130) {
        unint64_t v130 = v131 >> 2;
      }
      if ((unint64_t)v131 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v132 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v132 = v130;
      }
      if (v132)
      {
        if (v132 >> 61) {
          goto LABEL_211;
        }
        BOOL v133 = operator new(8 * v132);
        BOOL v134 = (Point ***)&v133[8 * v129];
        *BOOL v134 = v123;
        uint64_t v122 = (uint64_t)(v134 + 1);
        if (v94 == v127)
        {
LABEL_133:
          __p = v134;
          float32x2_t v208 = (void *)v122;
          float32x2_t v209 = &v133[8 * v132];
          if (!v94) {
            goto LABEL_117;
          }
LABEL_140:
          operator delete(v94);
LABEL_117:
          float32x2_t v208 = (void *)v122;
          uint64_t v94 = (char *)v122;
          continue;
        }
      }
      else
      {
        BOOL v133 = 0;
        BOOL v134 = (Point ***)(8 * v129);
        *(void *)(8 * v129) = v123;
        uint64_t v122 = 8 * v129 + 8;
        if (v94 == v127) {
          goto LABEL_133;
        }
      }
      unint64_t v135 = v94 - 8 - v127;
      if (v135 < 0x168)
      {
        int v136 = v94;
        goto LABEL_138;
      }
      if (&v133[v128 - 8 - (v135 & 0xFFFFFFFFFFFFFFF8)] > &v133[v128 - 8])
      {
        int v136 = v94;
        goto LABEL_138;
      }
      if (&v94[-(v135 & 0xFFFFFFFFFFFFFFF8) - 8] > v94 - 8)
      {
        int v136 = v94;
        goto LABEL_138;
      }
      if ((unint64_t)(v94 - v133 - v128) < 0x20)
      {
        int v136 = v94;
        goto LABEL_138;
      }
      uint64_t v138 = (v135 >> 3) + 1;
      uint64_t v139 = 8 * (v138 & 0x3FFFFFFFFFFFFFFCLL);
      int v136 = &v94[-v139];
      BOOL v134 = (Point ***)((char *)v134 - v139);
      v140 = &v133[8 * v129 - 16];
      float32x4_t v141 = v94 - 16;
      uint64_t v142 = v138 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v143 = *(_OWORD *)v141;
        *(v140 - 1) = *((_OWORD *)v141 - 1);
        _OWORD *v140 = v143;
        v140 -= 2;
        v141 -= 32;
        v142 -= 4;
      }
      while (v142);
      if (v138 != (v138 & 0x3FFFFFFFFFFFFFFCLL))
      {
        do
        {
LABEL_138:
          float v137 = (Point **)*((void *)v136 - 1);
          v136 -= 8;
          *--BOOL v134 = v137;
        }
        while (v136 != v127);
      }
      uint64_t v94 = (char *)__p;
      __p = v134;
      float32x2_t v208 = (void *)v122;
      float32x2_t v209 = &v133[8 * v132];
      if (v94) {
        goto LABEL_140;
      }
      goto LABEL_117;
    }
    int8x8_t v211 = (Point *)*((void *)v212 + 3);
    v218[0] = &v211;
    float32x4_t v144 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v204, (uint64_t *)&v211, (uint64_t)&std::piecewise_construct, v218);
    float32x4_t v145 = (Point ***)v144[3];
    if (v145 != (Point ***)v144[4])
    {
      while (1)
      {
        while (1)
        {
          float v164 = *v145;
          float v165 = **v145;
          if (v165 != v211) {
            goto LABEL_208;
          }
          float v166 = v164[1];
          if (v166 == p2t::Triangle::PointCW(v212, v165)) {
            break;
          }
          float v167 = v164[1];
          if (v167 == p2t::Triangle::PointCCW(v212, v211)) {
            break;
          }
          uint64_t v92 = v96;
          if (++v145 == (Point ***)v144[4]) {
            goto LABEL_153;
          }
        }
        if (v94 < v209)
        {
          *(void *)uint64_t v94 = v164;
          uint64_t v163 = (uint64_t)(v94 + 8);
          uint64_t v92 = v96;
        }
        else
        {
          uint64_t v168 = (char *)__p;
          int64_t v169 = v94 - (unsigned char *)__p;
          uint64_t v170 = (v94 - (unsigned char *)__p) >> 3;
          unint64_t v171 = v170 + 1;
          if ((unint64_t)(v170 + 1) >> 61) {
            goto LABEL_210;
          }
          uint64_t v172 = v209 - (unsigned char *)__p;
          if ((v209 - (unsigned char *)__p) >> 2 > v171) {
            unint64_t v171 = v172 >> 2;
          }
          if ((unint64_t)v172 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v173 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v173 = v171;
          }
          if (v173)
          {
            if (v173 >> 61) {
              goto LABEL_211;
            }
            float32x2_t v174 = operator new(8 * v173);
            v175 = (Point ***)&v174[8 * v170];
            _OWORD *v175 = v164;
            uint64_t v163 = (uint64_t)(v175 + 1);
            if (v94 != v168)
            {
LABEL_177:
              unint64_t v176 = v94 - 8 - v168;
              if (v176 < 0x168
                || &v174[v169 - 8 - (v176 & 0xFFFFFFFFFFFFFFF8)] > &v174[v169 - 8]
                || &v94[-(v176 & 0xFFFFFFFFFFFFFFF8) - 8] > v94 - 8
                || (unint64_t)(v94 - v174 - v169) < 0x20)
              {
                v177 = v94;
                uint64_t v92 = v96;
              }
              else
              {
                uint64_t v179 = (v176 >> 3) + 1;
                uint64_t v180 = 8 * (v179 & 0x3FFFFFFFFFFFFFFCLL);
                v177 = &v94[-v180];
                v175 = (Point ***)((char *)v175 - v180);
                v181 = &v174[8 * v170 - 16];
                v182 = v94 - 16;
                uint64_t v183 = v179 & 0x3FFFFFFFFFFFFFFCLL;
                uint64_t v92 = v96;
                do
                {
                  long long v184 = *(_OWORD *)v182;
                  *(v181 - 1) = *((_OWORD *)v182 - 1);
                  _OWORD *v181 = v184;
                  v181 -= 2;
                  v182 -= 32;
                  v183 -= 4;
                }
                while (v183);
                if (v179 == (v179 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_180:
                  uint64_t v94 = (char *)__p;
                  __p = v175;
                  float32x2_t v208 = (void *)v163;
                  float32x2_t v209 = &v174[8 * v173];
                  if (!v94) {
                    goto LABEL_161;
                  }
LABEL_184:
                  operator delete(v94);
                  goto LABEL_161;
                }
              }
              do
              {
                long long v178 = (Point **)*((void *)v177 - 1);
                v177 -= 8;
                *--v175 = v178;
              }
              while (v177 != v168);
              goto LABEL_180;
            }
          }
          else
          {
            float32x2_t v174 = 0;
            v175 = (Point ***)(8 * v170);
            *(void *)(8 * v170) = v164;
            uint64_t v163 = 8 * v170 + 8;
            if (v94 != v168) {
              goto LABEL_177;
            }
          }
          uint64_t v92 = v96;
          __p = v175;
          float32x2_t v208 = (void *)v163;
          float32x2_t v209 = &v174[8 * v173];
          if (v94) {
            goto LABEL_184;
          }
        }
LABEL_161:
        float32x2_t v208 = (void *)v163;
        uint64_t v94 = (char *)v163;
        if (++v145 == (Point ***)v144[4]) {
          goto LABEL_153;
        }
      }
    }
    uint64_t v92 = v96;
LABEL_153:
    v146 = (uint64_t *)__p;
    if (v94 - (unsigned char *)__p != 24) {
      __assert_rtn("BuildGraphFromTriangles", "GKCMeshGraph.mm", 395, "edges.size() == 3");
    }
    int8x8_t v211 = 0;
    unint64_t v147 = *(Point **)__p;
    unint64_t v210 = *((void *)__p + 1);
    int8x8_t v211 = v147;
    unint64_t v206 = *((void *)__p + 2);
    v218[0] = &v211;
    uint64_t v77 = v205;
    float v148 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v211, (uint64_t)&std::piecewise_construct, v218)[3];
    v218[0] = &v210;
    unint64_t v149 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v210, (uint64_t)&std::piecewise_construct, v218)[3];
    v218[0] = &v206;
    float v150 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v206, (uint64_t)&std::piecewise_construct, v218)[3];
    GKCGraphNode::addConnectionToNode(v148, v149, 0);
    GKCGraphNode::addConnectionToNode(v148, v150, 0);
    if (*((unsigned char *)v205 + 657))
    {
      v218[0] = &v212;
      float v151 = std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>(v200, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, v218);
      GKCGraphNode::addConnectionToNode((id *)v151[3], v148, 1);
    }
    v152 = (Point *)v146[1];
    unint64_t v210 = v146[2];
    int8x8_t v211 = v152;
    unint64_t v206 = 0;
    unint64_t v206 = *v146;
    v218[0] = &v211;
    float v153 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v211, (uint64_t)&std::piecewise_construct, v218)[3];
    v218[0] = &v210;
    float v154 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v210, (uint64_t)&std::piecewise_construct, v218)[3];
    v218[0] = &v206;
    unint64_t v155 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v206, (uint64_t)&std::piecewise_construct, v218)[3];
    GKCGraphNode::addConnectionToNode(v153, v154, 0);
    GKCGraphNode::addConnectionToNode(v153, v155, 0);
    if (*((unsigned char *)v205 + 657))
    {
      v218[0] = &v212;
      float v156 = std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>(v200, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, v218);
      GKCGraphNode::addConnectionToNode((id *)v156[3], v153, 1);
    }
    unint64_t v158 = v146[1];
    float v157 = (Point *)v146[2];
    unint64_t v210 = 0;
    int8x8_t v211 = v157;
    unint64_t v210 = *v146;
    unint64_t v206 = v158;
    v218[0] = &v211;
    float v159 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v211, (uint64_t)&std::piecewise_construct, v218)[3];
    v218[0] = &v210;
    v160 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v210, (uint64_t)&std::piecewise_construct, v218)[3];
    v218[0] = &v206;
    unint64_t v161 = (id *)std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(v92, (uint64_t *)&v206, (uint64_t)&std::piecewise_construct, v218)[3];
    GKCGraphNode::addConnectionToNode(v159, v160, 0);
    GKCGraphNode::addConnectionToNode(v159, v161, 0);
    if (*((unsigned char *)v205 + 657))
    {
      v218[0] = &v212;
      float v162 = std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>(v200, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, v218);
      GKCGraphNode::addConnectionToNode((id *)v162[3], v159, 1);
    }
    operator delete(v146);
    uint64_t v79 = v202 + 1;
    if (v202 + 1 != v217) {
      continue;
    }
    break;
  }
LABEL_192:
  if (*((unsigned char *)v77 + 657))
  {
    if (*((unsigned char *)v77 + 656))
    {
      v185 = (p2t::Triangle **)v216;
      if (v216 != v217)
      {
        uint64_t v186 = (uint64_t)v77 + 536;
        uint64_t v187 = (uint64_t)v77 + 496;
        do
        {
          v218[0] = *v185;
          __p = v218;
          uint64_t v188 = (id *)std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>(v186, (uint64_t *)v218, (uint64_t)&std::piecewise_construct, (void **)&__p)[3];
          int32x2_t v212 = (p2t::Triangle *)v218[0][1];
          __p = &v212;
          v189 = std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v187, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          GKCGraphNode::addConnectionToNode((id *)v189[3], v188, 1);
          int32x2_t v212 = (p2t::Triangle *)v218[0][2];
          __p = &v212;
          v190 = std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v187, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          GKCGraphNode::addConnectionToNode((id *)v190[3], v188, 1);
          int32x2_t v212 = (p2t::Triangle *)v218[0][3];
          __p = &v212;
          uint64_t v191 = std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v187, (uint64_t *)&v212, (uint64_t)&std::piecewise_construct, (void **)&__p);
          GKCGraphNode::addConnectionToNode((id *)v191[3], v188, 1);
          ++v185;
        }
        while (v185 != v217);
      }
    }
  }
  v192 = v214[0];
  if (v214[0])
  {
    do
    {
      v194 = (void *)*v192;
      uint64_t v195 = (void *)v192[5];
      if (v195)
      {
        do
        {
          uint64_t v196 = (void *)*v195;
          operator delete(v195);
          uint64_t v195 = v196;
        }
        while (v196);
      }
      unint64_t v197 = (void *)v192[3];
      v192[3] = 0;
      if (v197) {
        operator delete(v197);
      }
      operator delete(v192);
      v192 = v194;
    }
    while (v194);
  }
  v193 = v213[0];
  v213[0] = 0;
  if (v193) {
    operator delete(v193);
  }
  if (v216)
  {
    uint64_t v217 = (p2t::Triangle **)v216;
    operator delete(v216);
  }
}

void sub_235ED0F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30)
{
  double v31 = __p;
  if (__p)
  {
    do
    {
      id v33 = (void *)*v31;
      id v34 = (void *)v31[5];
      if (v34)
      {
        do
        {
          float32x2_t v35 = (void *)*v34;
          operator delete(v34);
          id v34 = v35;
        }
        while (v35);
      }
      float32_t v36 = (void *)v31[3];
      v31[3] = 0;
      if (v36) {
        operator delete(v36);
      }
      operator delete(v31);
      double v31 = v33;
    }
    while (v33);
  }
  if (a23)
  {
    operator delete(a23);
    double v32 = a29;
    if (!a29) {
LABEL_4:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    double v32 = a29;
    if (!a29) {
      goto LABEL_4;
    }
  }
  operator delete(v32);
  _Unwind_Resume(exception_object);
}

void *GKCMeshGraph::GetTriangles@<X0>(p2t::CDT **this@<X0>, void *a2@<X8>)
{
  return p2t::CDT::GetTriangles(this[43], a2);
}

uint64_t GKCMeshGraph::TriangleAtIndex(p2t::CDT **this, int a2)
{
  p2t::CDT::GetTriangles(this[43], __p);
  uint64_t v3 = *((void *)__p[0] + a2);
  __p[1] = __p[0];
  operator delete(__p[0]);
  return v3;
}

unint64_t GKCMeshGraph::GetNumTriangles(p2t::CDT **this)
{
  p2t::CDT::GetTriangles(this[43], &v4);
  float v1 = v4;
  unint64_t v2 = v5;
  if (v4)
  {
    uint64_t v5 = v4;
    operator delete(v4);
  }
  return (unint64_t)(v2 - v1) >> 3;
}

void GKCMeshGraph::ConnectNodeUsingObstacles(p2t::CDT **this, float32x2_t *a2)
{
  uint64_t v3 = this;
  float v112 = 0;
  p2t::CDT::GetTriangles(this[43], &__p);
  float v4 = (p2t::Triangle **)__p;
  if (__p == v111) {
LABEL_128:
  }
    __assert_rtn("ConnectNodeUsingObstacles", "GKCMeshGraph.mm", 480, "triangleInside != nullptr");
  float32x2_t v5 = a2[8];
  while (1)
  {
    id v6 = (Point **)*v4;
    float32x2_t v7 = vsub_f32(vcvt_f32_f64(*(float64x2_t *)*((void *)*v4 + 1)), v5);
    float32x2_t v8 = vsub_f32(vcvt_f32_f64(*(float64x2_t *)*((void *)*v4 + 2)), v5);
    float32x2_t v9 = vsub_f32(vcvt_f32_f64(*(float64x2_t *)*((void *)*v4 + 3)), v5);
    int32x2_t v10 = (int32x2_t)vmul_f32(v7, v8);
    int32x2_t v11 = (int32x2_t)vmul_f32(v9, v7);
    int32x2_t v12 = (int32x2_t)vmul_f32(v9, v8);
    int32x2_t v13 = (int32x2_t)vmul_f32(v9, v9);
    float32x2_t v14 = vadd_f32((float32x2_t)vzip1_s32(v11, v10), (float32x2_t)vzip2_s32(v11, v10));
    float32x2_t v15 = vadd_f32((float32x2_t)vzip1_s32(v12, v13), (float32x2_t)vzip2_s32(v12, v13));
    float32x2_t v16 = vmul_f32(v15, v14);
    if (vsub_f32(v16, (float32x2_t)vdup_lane_s32((int32x2_t)v16, 1)).f32[0] >= 0.0)
    {
      float32x2_t v17 = vmul_f32(v8, v8);
      if (vmls_f32(vmul_lane_f32(v15, v14, 1), v14, vadd_f32(v17, (float32x2_t)vdup_lane_s32((int32x2_t)v17, 1))).f32[0] >= 0.0) {
        break;
      }
    }
    if (++v4 == v111) {
      goto LABEL_128;
    }
  }
  float v112 = *v4;
  if (*((unsigned char *)v3 + 656))
  {
    uint64_t v113 = (Point **)v6[1];
    uint64_t v107 = (Point **)&v113;
    id v18 = std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)(v3 + 62), (uint64_t *)&v113, (uint64_t)&std::piecewise_construct, &v107);
    GKCGraphNode::addConnectionToNode((id *)a2, (id *)v18[3], 1);
    uint64_t v113 = (Point **)v6[2];
    uint64_t v107 = (Point **)&v113;
    id v19 = std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)(v3 + 62), (uint64_t *)&v113, (uint64_t)&std::piecewise_construct, &v107);
    GKCGraphNode::addConnectionToNode((id *)a2, (id *)v19[3], 1);
    uint64_t v113 = (Point **)v6[3];
    uint64_t v107 = (Point **)&v113;
    double v20 = std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)(v3 + 62), (uint64_t *)&v113, (uint64_t)&std::piecewise_construct, &v107);
    GKCGraphNode::addConnectionToNode((id *)a2, (id *)v20[3], 1);
  }
  if (!*((unsigned char *)v3 + 658)) {
    goto LABEL_121;
  }
  int64_t v104 = v3;
  uint64_t v105 = (GKCGraphNode *)a2;
  uint64_t v107 = 0;
  unint64_t v108 = 0;
  uint64_t v109 = 0;
  float v21 = (Point **)operator new(0x18uLL);
  uint64_t v107 = v21;
  unint64_t v108 = v21;
  uint64_t v109 = v21 + 3;
  uint64_t v22 = (uint64_t)(v3 + 77);
  unint64_t v106 = v6[1];
  uint64_t v113 = &v106;
  uint64_t v23 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>((uint64_t)(v3 + 77), (uint64_t *)&v106, (uint64_t)&std::piecewise_construct, &v113);
  uint64_t v24 = (Point ***)v23[3];
  v103 = v3 + 77;
  if (v24 != (Point ***)v23[4])
  {
    while (1)
    {
      double v26 = *v24;
      double v27 = **v24;
      if (v27 != v106) {
LABEL_126:
      }
        __assert_rtn("ConnectNodeUsingObstacles", "GKCMeshGraph.mm", 512, "edge->p == point");
      double v28 = v26[1];
      double v29 = v112;
      if (v28 != p2t::Triangle::PointCW(v112, v27))
      {
        unint64_t v30 = v26[1];
        if (v30 != p2t::Triangle::PointCCW(v29, v106)) {
          goto LABEL_13;
        }
      }
      if (v21 < v109)
      {
        *float v21 = (Point *)v26;
        uint64_t v25 = (uint64_t)(v21 + 1);
        goto LABEL_12;
      }
      double v31 = v107;
      int64_t v32 = (char *)v21 - (char *)v107;
      uint64_t v33 = v21 - v107;
      unint64_t v34 = v33 + 1;
      if ((unint64_t)(v33 + 1) >> 61) {
LABEL_129:
      }
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      uint64_t v35 = (char *)v109 - (char *)v107;
      if (((char *)v109 - (char *)v107) >> 2 > v34) {
        unint64_t v34 = v35 >> 2;
      }
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v36 = v34;
      }
      if (v36)
      {
        if (v36 >> 61) {
LABEL_130:
        }
          std::__throw_bad_array_new_length[abi:ne180100]();
        float32x2_t v37 = operator new(8 * v36);
        float32_t v38 = (Point ***)&v37[8 * v33];
        *float32_t v38 = v26;
        uint64_t v25 = (uint64_t)(v38 + 1);
        if (v21 == v31)
        {
LABEL_27:
          uint64_t v107 = (Point **)v38;
          unint64_t v108 = (Point **)v25;
          uint64_t v109 = (Point **)&v37[8 * v36];
          if (!v21) {
            goto LABEL_12;
          }
LABEL_34:
          operator delete(v21);
          goto LABEL_12;
        }
      }
      else
      {
        float32x2_t v37 = 0;
        float32_t v38 = (Point ***)(8 * v33);
        *(void *)(8 * v33) = v26;
        uint64_t v25 = 8 * v33 + 8;
        if (v21 == v31) {
          goto LABEL_27;
        }
      }
      unint64_t v39 = (char *)(v21 - 1) - (char *)v31;
      if (v39 < 0x168)
      {
        float32_t v40 = v21;
        goto LABEL_32;
      }
      if (&v37[v32 - 8 - (v39 & 0xFFFFFFFFFFFFFFF8)] > &v37[v32 - 8]) {
        break;
      }
      if ((Point **)((char *)v21 - (v39 & 0xFFFFFFFFFFFFFFF8) - 8) > v21 - 1)
      {
        float32_t v40 = v21;
        goto LABEL_32;
      }
      if ((unint64_t)((char *)v21 - v37 - v32) < 0x20)
      {
        float32_t v40 = v21;
        goto LABEL_32;
      }
      uint64_t v42 = (v39 >> 3) + 1;
      uint64_t v43 = 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
      float32_t v40 = &v21[v43 / 0xFFFFFFFFFFFFFFF8];
      float32_t v38 = (Point ***)((char *)v38 - v43);
      id v44 = &v37[8 * v33 - 16];
      double v45 = v21 - 2;
      uint64_t v46 = v42 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v47 = *(_OWORD *)v45;
        *(v44 - 1) = *((_OWORD *)v45 - 1);
        *id v44 = v47;
        v44 -= 2;
        v45 -= 4;
        v46 -= 4;
      }
      while (v46);
      if (v42 != (v42 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_32;
      }
LABEL_33:
      float v21 = v107;
      uint64_t v107 = (Point **)v38;
      unint64_t v108 = (Point **)v25;
      uint64_t v109 = (Point **)&v37[8 * v36];
      if (v21) {
        goto LABEL_34;
      }
LABEL_12:
      unint64_t v108 = (Point **)v25;
      float v21 = (Point **)v25;
LABEL_13:
      if (++v24 == (Point ***)v23[4])
      {
        id v6 = (Point **)v112;
        uint64_t v22 = (uint64_t)v103;
        goto LABEL_46;
      }
    }
    float32_t v40 = v21;
    do
    {
LABEL_32:
      uint64_t v41 = (Point **)*--v40;
      *--float32_t v38 = v41;
    }
    while (v40 != v31);
    goto LABEL_33;
  }
LABEL_46:
  unint64_t v106 = v6[2];
  uint64_t v113 = &v106;
  uint64_t v48 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v22, (uint64_t *)&v106, (uint64_t)&std::piecewise_construct, &v113);
  unsigned int v49 = (Point ***)v48[3];
  if (v49 == (Point ***)v48[4]) {
    goto LABEL_83;
  }
  do
  {
    char v51 = *v49;
    uint64_t v52 = **v49;
    if (v52 != v106) {
      goto LABEL_126;
    }
    double v53 = v51[1];
    double v54 = v112;
    if (v53 == p2t::Triangle::PointCW(v112, v52) || (double v55 = v51[1], v55 == p2t::Triangle::PointCCW(v54, v106)))
    {
      if (v21 < v109)
      {
        *float v21 = (Point *)v51;
        uint64_t v50 = (uint64_t)(v21 + 1);
        goto LABEL_49;
      }
      double v56 = v107;
      int64_t v57 = (char *)v21 - (char *)v107;
      uint64_t v58 = v21 - v107;
      unint64_t v59 = v58 + 1;
      if ((unint64_t)(v58 + 1) >> 61) {
        goto LABEL_129;
      }
      uint64_t v60 = (char *)v109 - (char *)v107;
      if (((char *)v109 - (char *)v107) >> 2 > v59) {
        unint64_t v59 = v60 >> 2;
      }
      if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v61 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v61 = v59;
      }
      if (v61)
      {
        if (v61 >> 61) {
          goto LABEL_130;
        }
        float32_t v62 = operator new(8 * v61);
        unint64_t v63 = (Point ***)&v62[8 * v58];
        *unint64_t v63 = v51;
        uint64_t v50 = (uint64_t)(v63 + 1);
        if (v21 == v56)
        {
LABEL_64:
          uint64_t v107 = (Point **)v63;
          unint64_t v108 = (Point **)v50;
          uint64_t v109 = (Point **)&v62[8 * v61];
          if (!v21) {
            goto LABEL_49;
          }
          goto LABEL_71;
        }
      }
      else
      {
        float32_t v62 = 0;
        unint64_t v63 = (Point ***)(8 * v58);
        *(void *)(8 * v58) = v51;
        uint64_t v50 = 8 * v58 + 8;
        if (v21 == v56) {
          goto LABEL_64;
        }
      }
      unint64_t v64 = (char *)(v21 - 1) - (char *)v56;
      if (v64 >= 0x168)
      {
        if (&v62[v57 - 8 - (v64 & 0xFFFFFFFFFFFFFFF8)] > &v62[v57 - 8])
        {
          uint64_t v65 = v21;
        }
        else if ((Point **)((char *)v21 - (v64 & 0xFFFFFFFFFFFFFFF8) - 8) > v21 - 1)
        {
          uint64_t v65 = v21;
        }
        else if ((unint64_t)((char *)v21 - v62 - v57) >= 0x20)
        {
          uint64_t v67 = (v64 >> 3) + 1;
          uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v65 = &v21[v68 / 0xFFFFFFFFFFFFFFF8];
          unint64_t v63 = (Point ***)((char *)v63 - v68);
          uint64_t v69 = &v62[8 * v58 - 16];
          uint64_t v70 = v21 - 2;
          uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v72 = *(_OWORD *)v70;
            *(v69 - 1) = *((_OWORD *)v70 - 1);
            *uint64_t v69 = v72;
            v69 -= 2;
            v70 -= 4;
            v71 -= 4;
          }
          while (v71);
          if (v67 == (v67 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_70:
            float v21 = v107;
            uint64_t v107 = (Point **)v63;
            unint64_t v108 = (Point **)v50;
            uint64_t v109 = (Point **)&v62[8 * v61];
            if (v21) {
LABEL_71:
            }
              operator delete(v21);
LABEL_49:
            unint64_t v108 = (Point **)v50;
            float v21 = (Point **)v50;
            goto LABEL_50;
          }
        }
        else
        {
          uint64_t v65 = v21;
        }
      }
      else
      {
        uint64_t v65 = v21;
      }
      do
      {
        uint64_t v66 = (Point **)*--v65;
        *--unint64_t v63 = v66;
      }
      while (v65 != v56);
      goto LABEL_70;
    }
LABEL_50:
    ++v49;
  }
  while (v49 != (Point ***)v48[4]);
  id v6 = (Point **)v112;
  uint64_t v22 = (uint64_t)v103;
LABEL_83:
  unint64_t v106 = v6[3];
  uint64_t v113 = &v106;
  uint64_t v73 = std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(v22, (uint64_t *)&v106, (uint64_t)&std::piecewise_construct, &v113);
  uint64_t v74 = (Point ***)v73[3];
  if (v74 != (Point ***)v73[4])
  {
    while (2)
    {
      unint64_t v76 = *v74;
      uint64_t v77 = **v74;
      if (v77 != v106) {
        goto LABEL_126;
      }
      int v78 = v76[1];
      uint64_t v79 = v112;
      if (v78 != p2t::Triangle::PointCW(v112, v77))
      {
        uint64_t v80 = v76[1];
        if (v80 != p2t::Triangle::PointCCW(v79, v106)) {
          goto LABEL_87;
        }
      }
      if (v21 < v109)
      {
        *float v21 = (Point *)v76;
        uint64_t v75 = (uint64_t)(v21 + 1);
        goto LABEL_86;
      }
      id v81 = v107;
      int64_t v82 = (char *)v21 - (char *)v107;
      uint64_t v83 = v21 - v107;
      unint64_t v84 = v83 + 1;
      if ((unint64_t)(v83 + 1) >> 61) {
        goto LABEL_129;
      }
      uint64_t v85 = (char *)v109 - (char *)v107;
      if (((char *)v109 - (char *)v107) >> 2 > v84) {
        unint64_t v84 = v85 >> 2;
      }
      if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v86 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v86 = v84;
      }
      if (v86)
      {
        if (v86 >> 61) {
          goto LABEL_130;
        }
        uint64_t v87 = operator new(8 * v86);
        uint64_t v88 = (Point ***)&v87[8 * v83];
        *uint64_t v88 = v76;
        uint64_t v75 = (uint64_t)(v88 + 1);
        if (v21 == v81)
        {
LABEL_101:
          uint64_t v107 = (Point **)v88;
          unint64_t v108 = (Point **)v75;
          uint64_t v109 = (Point **)&v87[8 * v86];
          if (!v21)
          {
LABEL_86:
            unint64_t v108 = (Point **)v75;
            float v21 = (Point **)v75;
LABEL_87:
            if (++v74 == (Point ***)v73[4]) {
              goto LABEL_119;
            }
            continue;
          }
LABEL_108:
          operator delete(v21);
          goto LABEL_86;
        }
      }
      else
      {
        uint64_t v87 = 0;
        uint64_t v88 = (Point ***)(8 * v83);
        *(void *)(8 * v83) = v76;
        uint64_t v75 = 8 * v83 + 8;
        if (v21 == v81) {
          goto LABEL_101;
        }
      }
      break;
    }
    unint64_t v89 = (char *)(v21 - 1) - (char *)v81;
    if (v89 < 0x168)
    {
      id v90 = v21;
      goto LABEL_106;
    }
    if (&v87[v82 - 8 - (v89 & 0xFFFFFFFFFFFFFFF8)] > &v87[v82 - 8])
    {
      id v90 = v21;
      goto LABEL_106;
    }
    if ((Point **)((char *)v21 - (v89 & 0xFFFFFFFFFFFFFFF8) - 8) > v21 - 1)
    {
      id v90 = v21;
      goto LABEL_106;
    }
    if ((unint64_t)((char *)v21 - v87 - v82) < 0x20)
    {
      id v90 = v21;
      goto LABEL_106;
    }
    uint64_t v92 = (v89 >> 3) + 1;
    uint64_t v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
    id v90 = &v21[v93 / 0xFFFFFFFFFFFFFFF8];
    uint64_t v88 = (Point ***)((char *)v88 - v93);
    uint64_t v94 = &v87[8 * v83 - 16];
    v95 = v21 - 2;
    uint64_t v96 = v92 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v97 = *(_OWORD *)v95;
      *(v94 - 1) = *((_OWORD *)v95 - 1);
      *uint64_t v94 = v97;
      v94 -= 2;
      v95 -= 4;
      v96 -= 4;
    }
    while (v96);
    if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
    {
      do
      {
LABEL_106:
        uint64_t v91 = (Point **)*--v90;
        *--uint64_t v88 = v91;
      }
      while (v90 != v81);
    }
    float v21 = v107;
    uint64_t v107 = (Point **)v88;
    unint64_t v108 = (Point **)v75;
    uint64_t v109 = (Point **)&v87[8 * v86];
    if (!v21) {
      goto LABEL_86;
    }
    goto LABEL_108;
  }
LABEL_119:
  uint64_t v98 = v107;
  if ((char *)v21 - (char *)v107 != 24) {
    __assert_rtn("ConnectNodeUsingObstacles", "GKCMeshGraph.mm", 523, "edges.size() == 3");
  }
  unint64_t v106 = *v107;
  uint64_t v113 = &v106;
  v99 = std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>((uint64_t)(v104 + 72), (uint64_t *)&v106, (uint64_t)&std::piecewise_construct, &v113);
  GKCGraphNode::addConnectionToNode((id *)v105, (id *)v99[3], 1);
  unint64_t v106 = v98[1];
  uint64_t v113 = &v106;
  unint64_t v100 = std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>((uint64_t)(v104 + 72), (uint64_t *)&v106, (uint64_t)&std::piecewise_construct, &v113);
  GKCGraphNode::addConnectionToNode((id *)v105, (id *)v100[3], 1);
  unint64_t v106 = v98[2];
  uint64_t v113 = &v106;
  uint64_t v101 = std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>((uint64_t)(v104 + 72), (uint64_t *)&v106, (uint64_t)&std::piecewise_construct, &v113);
  GKCGraphNode::addConnectionToNode((id *)v105, (id *)v101[3], 1);
  operator delete(v98);
  uint64_t v3 = v104;
  a2 = (float32x2_t *)v105;
LABEL_121:
  if (*((unsigned char *)v3 + 657))
  {
    uint64_t v107 = (Point **)&v112;
    uint64_t v102 = std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>((uint64_t)(v3 + 67), (uint64_t *)&v112, (uint64_t)&std::piecewise_construct, &v107);
    GKCGraphNode::addConnectionToNode((id *)a2, (id *)v102[3], 1);
  }
  GKCGraph::addNode((GKCGraph *)v3, (id *)a2);
  if (__p)
  {
    unint64_t v111 = (p2t::Triangle **)__p;
    operator delete(__p);
  }
}

void sub_235ED1B28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (!__p) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

char *std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    int32x2_t v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      float32x2_t v14 = (char *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = *((void *)v14 + 1);
            if (v16 == v10)
            {
              if (*((void *)v14 + 2) == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            float32x2_t v14 = *(char **)v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v10)
          {
            if (*((void *)v14 + 2) == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          float32x2_t v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  float32x2_t v17 = (void *)(a1 + 16);
  float32x2_t v14 = (char *)operator new(0x40uLL);
  *(void *)float32x2_t v14 = 0;
  *((void *)v14 + 1) = v10;
  *((void *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (v11 && (float)(v19 * (float)v11) >= v18)
  {
    uint64_t v20 = *(void *)a1;
    float v21 = *(void **)(*(void *)a1 + 8 * v4);
    if (v21)
    {
LABEL_26:
      *(void *)float32x2_t v14 = *v21;
LABEL_61:
      *float v21 = v14;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v29 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v20 = *(void *)a1;
        float v21 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v21) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v20 = *(void *)a1;
        float v21 = *(void **)(*(void *)a1 + 8 * v10);
        if (v21) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v29 & v10;
      uint64_t v20 = *(void *)a1;
      float v21 = *(void **)(*(void *)a1 + 8 * (v29 & v10));
      if (v21) {
        goto LABEL_26;
      }
    }
  }
  *(void *)float32x2_t v14 = *v17;
  void *v17 = v14;
  *(void *)(v20 + 8 * v4) = v17;
  if (*(void *)v14)
  {
    unint64_t v30 = *(void *)(*(void *)v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v30 >= v11) {
        v30 %= v11;
      }
    }
    else
    {
      v30 &= v11 - 1;
    }
    float v21 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_235ED1F5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (void *)v2[5];
      if (v3)
      {
        do
        {
          unint64_t v4 = (void *)*v3;
          operator delete(v3);
          uint64_t v3 = v4;
        }
        while (v4);
      }
      float32x2_t v5 = (void *)v2[3];
      v2[3] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    unint64_t v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unint64_t v4 = operator new(8 * a2);
  float32x2_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        uint8x8_t v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          uint64_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          void *v7 = *v12;
          uint64_t v14 = 8 * v13;
          *uint8x8_t v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          uint64_t v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    uint64_t v16 = (void *)*v7;
    if (*v7)
    {
      while (1)
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 == v9) {
          goto LABEL_25;
        }
        if (*(void *)(*(void *)a1 + 8 * v18))
        {
          void *v7 = *v16;
          uint64_t v17 = 8 * v18;
          void *v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          uint64_t v16 = v7;
LABEL_25:
          uint64_t v7 = v16;
          uint64_t v16 = (void *)*v16;
          if (!v16) {
            return;
          }
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v18) = v7;
          uint64_t v7 = v16;
          uint64_t v16 = (void *)*v16;
          unint64_t v9 = v18;
          if (!v16) {
            return;
          }
        }
      }
    }
  }
}

void *std::__hash_table<std::__hash_value_type<p2t::Point *,BOOL>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,BOOL>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,BOOL>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,BOOL>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    uint64_t v13 = *(void **)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      uint64_t v14 = (void *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  unint64_t v18 = operator new(0x20uLL);
  void *v18 = 0;
  v18[1] = v10;
  v18[2] = **a4;
  *((unsigned char *)v18 + 24) = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v11 && (float)(v20 * (float)v11) >= v19)
  {
    uint64_t v21 = *(void *)a1;
    BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      void *v18 = *v22;
LABEL_61:
      *BOOL v22 = v18;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v23 = 1;
    if (v11 >= 3) {
      BOOL v23 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v11);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v30 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v22) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * v10);
        if (v22) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v30 & v10;
      uint64_t v21 = *(void *)a1;
      BOOL v22 = *(void **)(*(void *)a1 + 8 * (v30 & v10));
      if (v22) {
        goto LABEL_26;
      }
    }
  }
  void *v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*v18)
  {
    unint64_t v31 = *(void *)(*v18 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v31 >= v11) {
        v31 %= v11;
      }
    }
    else
    {
      v31 &= v11 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v18;
}

void sub_235ED24E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    uint64_t v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  uint64_t v17 = (void *)(a1 + 16);
  uint64_t v14 = operator new(0x30uLL);
  *uint64_t v14 = 0;
  v14[1] = v10;
  v14[2] = **a4;
  v14[3] = 0;
  v14[4] = 0;
  v14[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (v11 && (float)(v19 * (float)v11) >= v18)
  {
    uint64_t v20 = *(void *)a1;
    uint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
    if (v21)
    {
LABEL_26:
      *uint64_t v14 = *v21;
LABEL_61:
      *uint64_t v21 = v14;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v29 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v21) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v20 = *(void *)a1;
        uint64_t v21 = *(void **)(*(void *)a1 + 8 * v10);
        if (v21) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v29 & v10;
      uint64_t v20 = *(void *)a1;
      uint64_t v21 = *(void **)(*(void *)a1 + 8 * (v29 & v10));
      if (v21) {
        goto LABEL_26;
      }
    }
  }
  *uint64_t v14 = *v17;
  void *v17 = v14;
  *(void *)(v20 + 8 * v4) = v17;
  if (*v14)
  {
    unint64_t v30 = *(void *)(*v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v30 >= v11) {
        v30 %= v11;
      }
    }
    else
    {
      v30 &= v11 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_235ED284C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<p2t::Point *,std::vector<p2t::Edge *>>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (void *)v2[3];
      if (v3)
      {
        v2[4] = v3;
        operator delete(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Point *,std::piecewise_construct_t const&,std::tuple<p2t::Point * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    uint64_t v13 = *(void **)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      uint64_t v14 = (void *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  float v18 = operator new(0x20uLL);
  void *v18 = 0;
  v18[1] = v10;
  v18[2] = **a4;
  v18[3] = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v11 && (float)(v20 * (float)v11) >= v19)
  {
    uint64_t v21 = *(void *)a1;
    BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      void *v18 = *v22;
LABEL_61:
      *BOOL v22 = v18;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v23 = 1;
    if (v11 >= 3) {
      BOOL v23 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v11);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v30 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v22) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * v10);
        if (v22) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v30 & v10;
      uint64_t v21 = *(void *)a1;
      BOOL v22 = *(void **)(*(void *)a1 + 8 * (v30 & v10));
      if (v22) {
        goto LABEL_26;
      }
    }
  }
  void *v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*v18)
  {
    unint64_t v31 = *(void *)(*v18 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v31 >= v11) {
        v31 %= v11;
      }
    }
    else
    {
      v31 &= v11 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v18;
}

void sub_235ED2BFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::hash<p2t::Triangle *>,std::equal_to<p2t::Triangle *>,true>,std::__unordered_map_equal<p2t::Triangle *,std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>,std::equal_to<p2t::Triangle *>,std::hash<p2t::Triangle *>,true>,std::allocator<std::__hash_value_type<p2t::Triangle *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Triangle *,std::piecewise_construct_t const&,std::tuple<p2t::Triangle * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    uint64_t v13 = *(void **)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      uint64_t v14 = (void *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  float v18 = operator new(0x20uLL);
  void *v18 = 0;
  v18[1] = v10;
  v18[2] = **a4;
  v18[3] = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v11 && (float)(v20 * (float)v11) >= v19)
  {
    uint64_t v21 = *(void *)a1;
    BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      void *v18 = *v22;
LABEL_61:
      *BOOL v22 = v18;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v23 = 1;
    if (v11 >= 3) {
      BOOL v23 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v11);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v30 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v22) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * v10);
        if (v22) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v30 & v10;
      uint64_t v21 = *(void *)a1;
      BOOL v22 = *(void **)(*(void *)a1 + 8 * (v30 & v10));
      if (v22) {
        goto LABEL_26;
      }
    }
  }
  void *v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*v18)
  {
    unint64_t v31 = *(void *)(*v18 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v31 >= v11) {
        v31 %= v11;
      }
    }
    else
    {
      v31 &= v11 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v18;
}

void sub_235ED2F5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::__unordered_map_hasher<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::hash<p2t::Edge *>,std::equal_to<p2t::Edge *>,true>,std::__unordered_map_equal<p2t::Edge *,std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>,std::equal_to<p2t::Edge *>,std::hash<p2t::Edge *>,true>,std::allocator<std::__hash_value_type<p2t::Edge *,GKCGraphNode2D *>>>::__emplace_unique_key_args<p2t::Edge *,std::piecewise_construct_t const&,std::tuple<p2t::Edge * const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    uint64_t v13 = *(void **)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      uint64_t v14 = (void *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  float v18 = operator new(0x20uLL);
  void *v18 = 0;
  v18[1] = v10;
  v18[2] = **a4;
  v18[3] = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v11 && (float)(v20 * (float)v11) >= v19)
  {
    uint64_t v21 = *(void *)a1;
    BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      void *v18 = *v22;
LABEL_61:
      *BOOL v22 = v18;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v23 = 1;
    if (v11 >= 3) {
      BOOL v23 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v11);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::__unordered_map_hasher<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::hash<p2t::Point *>,std::equal_to<p2t::Point *>,true>,std::__unordered_map_equal<p2t::Point *,std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>,std::equal_to<p2t::Point *>,std::hash<p2t::Point *>,true>,std::allocator<std::__hash_value_type<p2t::Point *,std::unordered_map<p2t::Point *,BOOL>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v30 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v22) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v21 = *(void *)a1;
        BOOL v22 = *(void **)(*(void *)a1 + 8 * v10);
        if (v22) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v30 & v10;
      uint64_t v21 = *(void *)a1;
      BOOL v22 = *(void **)(*(void *)a1 + 8 * (v30 & v10));
      if (v22) {
        goto LABEL_26;
      }
    }
  }
  void *v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*v18)
  {
    unint64_t v31 = *(void *)(*v18 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v31 >= v11) {
        v31 %= v11;
      }
    }
    else
    {
      v31 &= v11 - 1;
    }
    BOOL v22 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v18;
}

void sub_235ED32BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_235ED3C3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED3D88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED3E58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED3FA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED40A0(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v2, 0xA1C407DA79AE9);

  _Unwind_Resume(a1);
}

void sub_235ED40C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED42E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED4314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED4328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED433C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED43D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235ED4438(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED4508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void OpenSteer::SphericalObstacle::steerToAvoid(uint64_t a1, uint64_t a2)
{
}

void GKCGraph::GKCGraph(GKCGraph *this)
{
  *(void *)this = &unk_26E942E38;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
}

void GKCGraph::~GKCGraph(id *this)
{
  *this = &unk_26E942E38;
  objc_destroyWeak(this + 4);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;

  *this = &unk_26E942E38;
  objc_destroyWeak(this + 4);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;
  uint64_t vars8;

  *this = &unk_26E942E38;
  objc_destroyWeak(this + 4);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x237DF7CA0);
}

uint64_t GKCGraph::connectNodeToLowestCostNode(GKCGraph *this, id *a2, char a3)
{
  float32x2_t v5 = (id **)*((void *)this + 1);
  if (v5 != *((id ***)this + 2))
  {
    uint64_t v7 = 0;
    float v8 = 3.4028e38;
    do
    {
      unint64_t v10 = *v5++;
      unint64_t v9 = v10;
      float v11 = (*((float (**)(id *, id *))*a2 + 3))(a2, v10);
      if (v11 < v8 || v7 == 0)
      {
        uint64_t v7 = v9;
        float v8 = v11;
      }
    }
    while (v5 != *((id ***)this + 2));
    if (v7) {
      GKCGraphNode::addConnectionToNode(v7, a2, a3);
    }
  }

  return GKCGraph::addNode(this, a2);
}

uint64_t GKCGraph::addNode(GKCGraph *this, id *a2)
{
  float32x2_t v5 = (id **)*((void *)this + 2);
  unint64_t v4 = *((void *)this + 3);
  uint64_t v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *float32x2_t v5 = a2;
    uint64_t v7 = (uint64_t)(v5 + 1);
    goto LABEL_23;
  }
  float v8 = (void **)((char *)this + 8);
  unint64_t v9 = (char *)*((void *)this + 1);
  uint64_t v10 = ((char *)v5 - v9) >> 3;
  unint64_t v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v12 = v4 - (void)v9;
  if (v12 >> 2 > v11) {
    unint64_t v11 = v12 >> 2;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v14 = (char *)operator new(8 * v13);
    unint64_t v15 = (id **)&v14[8 * v10];
    uint64_t v16 = &v14[8 * v13];
    *unint64_t v15 = a2;
    uint64_t v7 = (uint64_t)(v15 + 1);
    uint64_t v17 = (char *)((char *)v5 - v9);
    if (v5 == (id **)v9) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  uint64_t v14 = 0;
  unint64_t v15 = (id **)(8 * v10);
  uint64_t v16 = 0;
  *(void *)(8 * v10) = a2;
  uint64_t v7 = 8 * v10 + 8;
  uint64_t v17 = (char *)((char *)v5 - v9);
  if (v5 != (id **)v9)
  {
LABEL_14:
    unint64_t v18 = (unint64_t)(v17 - 8);
    if (v18 < 0x58) {
      goto LABEL_30;
    }
    if ((unint64_t)(v9 - v14) < 0x20) {
      goto LABEL_30;
    }
    uint64_t v19 = (v18 >> 3) + 1;
    uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v6 = &v5[v20 / 0xFFFFFFFFFFFFFFF8];
    unint64_t v15 = (id **)((char *)v15 - v20);
    uint64_t v21 = &v14[8 * v10 - 16];
    BOOL v22 = v5 - 2;
    uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *(_OWORD *)v22;
      *((_OWORD *)v21 - 1) = *((_OWORD *)v22 - 1);
      *(_OWORD *)uint64_t v21 = v24;
      v21 -= 32;
      v22 -= 4;
      v23 -= 4;
    }
    while (v23);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_30:
      do
      {
        unint64_t v25 = *--v6;
        *--unint64_t v15 = v25;
      }
      while (v6 != (id **)v9);
    }
    uint64_t v6 = (id **)*v8;
  }
LABEL_21:
  *((void *)this + 1) = v15;
  *((void *)this + 2) = v7;
  *((void *)this + 3) = v16;
  if (v6) {
    operator delete(v6);
  }
LABEL_23:
  *((void *)this + 2) = v7;
  id WeakRetained = objc_loadWeakRetained((id *)this + 4);
  id v27 = (id)[WeakRetained nodesMut];

  id v28 = objc_loadWeakRetained(a2 + 7);

  return [v27 addObject:v28];
}

void sub_235ED502C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCGraph::removeNode(GKCGraph *this, id *a2)
{
  unint64_t v4 = *((void *)this + 2) - *((void *)this + 1);
  if ((int)(v4 >> 3) >= 1)
  {
    unint64_t v5 = (v4 >> 3) + 1;
    do
    {
      uint64_t v6 = 8 * (v5 - 2);
      GKCGraphNode::removeConnectionToNode(*(id **)(*((void *)this + 1) + v6), a2, 1);
      uint64_t v7 = (GKCGraphNode **)(*((void *)this + 1) + v6);
      if (*v7 == (GKCGraphNode *)a2)
      {
        float v8 = (GKCGraphNode **)*((void *)this + 2);
        int64_t v9 = (char *)v8 - (char *)(v7 + 1);
        if (v8 != v7 + 1) {
          memmove(v7, v7 + 1, (char *)v8 - (char *)(v7 + 1));
        }
        *((void *)this + 2) = (char *)v7 + v9;
      }
      --v5;
    }
    while (v5 > 1);
  }
  id WeakRetained = objc_loadWeakRetained((id *)this + 4);
  uint64_t v10 = [WeakRetained nodesMut];
  id v11 = objc_loadWeakRetained(a2 + 7);
  [v10 removeObject:v11];
}

void sub_235ED5148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235ED5164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GKCGridGraph::GKCGridGraph(GKCGridGraph *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(void *)this = &unk_26E942E60;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 12) = 0;
}

void GKCGridGraph::initDontConstructNodes(void *a1, int a2, int a3, char a4, uint64_t a5, double a6)
{
  uint64_t v10 = a1[8];
  float v8 = a1 + 8;
  uint64_t v9 = v10;
  *((unsigned char *)v8 - 8) = a4;
  *((double *)v8 - 3) = a6;
  *((_DWORD *)v8 - 4) = a2;
  *((_DWORD *)v8 - 3) = a3;
  unint64_t v11 = (a3 * a2);
  unint64_t v12 = (v8[1] - v10) >> 3;
  if (v11 > v12)
  {
    std::vector<GKCGridGraphNode *>::__append((void **)v8, v11 - v12);
LABEL_3:
    a1[11] = a5;
    return;
  }
  if (v11 >= v12) {
    goto LABEL_3;
  }
  a1[9] = v9 + 8 * v11;
  a1[11] = a5;
}

void GKCGridGraph::init(uint64_t a1, int a2, unsigned int a3, char a4, void *a5, double a6)
{
  unint64_t v11 = (void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 64);
  *(unsigned char *)(a1 + 56) = a4;
  *(double *)(a1 + 40) = a6;
  *(_DWORD *)(a1 + 48) = a2;
  *(_DWORD *)(a1 + 52) = a3;
  unint64_t v12 = a3 * a2;
  unint64_t v13 = (*(void *)(a1 + 72) - v10) >> 3;
  if (v12 <= v13)
  {
    if (v12 < v13) {
      *(void *)(a1 + 72) = v10 + 8 * v12;
    }
  }
  else
  {
    double v28 = a6;
    std::vector<GKCGridGraphNode *>::__append((void **)(a1 + 64), v12 - v13);
    a6 = v28;
  }
  *(void *)(a1 + 88) = a5;
  if (a2 && a3)
  {
    unsigned int v14 = 0;
    int v15 = 0;
    int v27 = LODWORD(a6);
    int v25 = a2;
    unsigned int v26 = HIDWORD(a6);
    uint64_t v16 = a3;
    do
    {
      unsigned int v17 = v26;
      uint64_t v18 = v16;
      unsigned int v19 = v14;
      do
      {
        uint64_t v20 = objc_msgSend(a5, "nodeWithGridPosition:", COERCE_DOUBLE(__PAIR64__(v17, v15 + v27)));
        GKCGraph::addNode((GKCGraph *)a1, (id *)[v20 cGridGraphNode]);
        *(void *)(*v11 + 8 * v19) = [v20 cGridGraphNode];

        ++v19;
        ++v17;
        --v18;
      }
      while (v18);
      ++v15;
      v14 += a3;
      uint64_t v16 = a3;
    }
    while (v15 != v25);
    unsigned int v21 = 0;
    for (int i = 0; i != v25; ++i)
    {
      uint64_t v23 = a3;
      unsigned int v24 = v21;
      do
      {
        GKCGridGraph::connectNodeToAdjacentNodesNoAdd((id *)a1, *(int32x2_t **)(*(void *)(a1 + 64) + 8 * v24++), 0);
        --v23;
      }
      while (v23);
      v21 += a3;
    }
  }
}

void sub_235ED53A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *GKCGridGraph::connectNodeToAdjacentNodesNoAdd(id *this, int32x2_t *a2, char a3)
{
  unint64_t v5 = this;
  int32x2_t v6 = a2[8];
  int32x2_t v7 = (int32x2_t)this[5];
  int32x2_t v8 = vzip1_s32(v7, v6);
  if (v6.i32[0] < v7.i32[0]
    || ((int)*(void *)&a2[8] < (int)(*((_DWORD *)this + 12) + this[5])
      ? (BOOL v9 = v6.i32[1] < v7.i32[1])
      : (BOOL v9 = 1),
        v9
     || (int v11 = *((_DWORD *)this + 13), v6.i32[1] >= v11 + v7.i32[1])
     || !*((void *)this[8] + (v6.i32[1] - v7.i32[1] + v11 * (v6.i32[0] - v7.i32[0])))))
  {
    int32x2_t v10 = vsub_s32(v6, v7);
    int v11 = *((_DWORD *)this + 13);
    unint64_t v12 = (v10.i32[1] + v11 * v10.i32[0]);
    if ((v12 & 0x80000000) == 0)
    {
      unint64_t v13 = this[8];
      if (v12 < ((unsigned char *)this[9] - (unsigned char *)v13) >> 3)
      {
        v13[v12] = a2;
        int32x2_t v6 = a2[8];
        int32x2_t v7 = (int32x2_t)this[5];
        int32x2_t v8 = vzip1_s32(v7, v6);
      }
    }
  }
  if (v8.i32[1] > v8.i32[0])
  {
    BOOL v14 = v8.i32[1] > *((_DWORD *)this + 12) + v8.i32[0] || v6.i32[1] < v7.i32[1];
    if (!v14 && v6.i32[1] < v11 + v7.i32[1])
    {
      this = (id *)*((void *)this[8] + (v6.i32[1] - v7.i32[1] + v11 * (v8.i32[1] + ~v8.i32[0])));
      if (this)
      {
        this = GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
        int32x2_t v6 = a2[8];
        int32x2_t v7 = (int32x2_t)v5[5];
        int32x2_t v8 = vzip1_s32(v7, v6);
      }
    }
  }
  if (v8.i32[1] + 1 >= v8.i32[0] && v8.i32[1] + 1 < *((_DWORD *)v5 + 12) + v8.i32[0] && v6.i32[1] >= v7.i32[1])
  {
    int v32 = *((_DWORD *)v5 + 13);
    if (v6.i32[1] < v32 + v7.i32[1])
    {
      this = (id *)*((void *)v5[8] + (v6.i32[1] - v7.i32[1] + v32 * (v8.i32[1] + 1 - v8.i32[0])));
      if (this)
      {
        this = GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
        int32x2_t v6 = a2[8];
        int32x2_t v7 = (int32x2_t)v5[5];
        int32x2_t v8 = vzip1_s32(v7, v6);
      }
    }
  }
  __int32 v17 = v6.i32[1];
  if (v8.i32[1] >= v8.i32[0])
  {
    int v18 = v6.i32[1] + 1;
    if (v8.i32[1] < *((_DWORD *)v5 + 12) + v8.i32[0] && v18 >= v7.i32[1])
    {
      int v33 = *((_DWORD *)v5 + 13);
      if (v18 < v33 + v7.i32[1])
      {
        this = (id *)*((void *)v5[8] + (v18 - v7.i32[1] + v33 * (v8.i32[1] - v8.i32[0])));
        if (this)
        {
          this = GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
          int32x2_t v7 = (int32x2_t)v5[5];
          __int32 v17 = HIDWORD(*(void *)&a2[8]);
          int32x2_t v8 = vzip1_s32(v7, a2[8]);
        }
      }
    }
  }
  if (v8.i32[1] >= v8.i32[0] && v8.i32[1] < *((_DWORD *)v5 + 12) + v8.i32[0] && v17 > v7.i32[1])
  {
    int v34 = *((_DWORD *)v5 + 13);
    if (v17 <= v34 + v7.i32[1])
    {
      this = (id *)*((void *)v5[8] + (v17 + ~v7.i32[1] + v34 * (v8.i32[1] - v8.i32[0])));
      if (this) {
        this = GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
      }
    }
  }
  if (*((unsigned char *)v5 + 56))
  {
    int32x2_t v21 = a2[8];
    int8x8_t v22 = (int8x8_t)v5[5];
    int32x2_t v23 = (int32x2_t)__PAIR64__(v21.u32[1], v22.u32[0]);
    int v24 = v21.i32[0];
    int v25 = v21.i32[1] + 1;
    if (v21.i32[0] > v22.i32[0] && v21.i32[0] <= *((_DWORD *)v5 + 12) + v22.i32[0] && v25 >= v22.i32[1])
    {
      int v26 = *((_DWORD *)v5 + 13);
      if (v25 < v26 + v22.i32[1])
      {
        this = (id *)*((void *)v5[8] + (v25 - v22.i32[1] + v26 * (v21.i32[0] + ~v22.i32[0])));
        if (this)
        {
          this = GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
          int8x8_t v22 = (int8x8_t)v5[5];
          v23.i32[0] = v22.i32[0];
          v23.i32[1] = HIDWORD(*(void *)&a2[8]);
          int v24 = (int)a2[8];
          int v25 = v23.i32[1] + 1;
        }
      }
    }
    if (v24 + 1 >= v23.i32[0] && v24 + 1 < *((_DWORD *)v5 + 12) + v23.i32[0] && v25 >= v22.i32[1])
    {
      int v35 = *((_DWORD *)v5 + 13);
      if (v25 < v35 + v22.i32[1])
      {
        this = (id *)*((void *)v5[8] + (v25 - v22.i32[1] + v35 * (v24 + 1 - v23.i32[0])));
        if (this)
        {
          this = GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
          int8x8_t v22 = (int8x8_t)v5[5];
          v23.i32[0] = v22.i32[0];
          v23.i32[1] = HIDWORD(*(void *)&a2[8]);
          int v24 = (int)a2[8];
        }
      }
    }
    if (v24 > v23.i32[0] && v24 <= *((_DWORD *)v5 + 12) + v23.i32[0] && v23.i32[1] > v22.i32[1])
    {
      int v36 = *((_DWORD *)v5 + 13);
      if (v23.i32[1] <= v36 + v22.i32[1])
      {
        v37.i32[0] = vdup_lane_s32(v23, 1).u32[0];
        v37.i32[1] = v24;
        int32x2_t v38 = vadd_s32(v37, (int32x2_t)vmvn_s8(vext_s8(v22, (int8x8_t)v23, 4uLL)));
        this = (id *)*((void *)v5[8] + (v38.i32[0] + v36 * v38.i32[1]));
        if (this)
        {
          this = GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
          int8x8_t v22 = (int8x8_t)v5[5];
          v23.i32[0] = v22.i32[0];
          v23.i32[1] = HIDWORD(*(void *)&a2[8]);
          int v24 = (int)a2[8];
        }
      }
    }
    int v29 = v24 + 1;
    __int32 v30 = v24 + 1 - v23.i32[0];
    if (v29 >= v23.i32[0] && v29 < *((_DWORD *)v5 + 12) + v23.i32[0] && v23.i32[1] > v22.i32[1])
    {
      int v31 = *((_DWORD *)v5 + 13);
      if (v23.i32[1] <= v31 + v22.i32[1])
      {
        this = (id *)*((void *)v5[8] + (v23.i32[1] + ~v22.i32[1] + v31 * v30));
        if (this)
        {
          return GKCGraphNode::addConnectionToNode(this, (id *)a2, a3);
        }
      }
    }
  }
  return this;
}

void GKCGridGraph::~GKCGridGraph(GKCGridGraph *this)
{
  *(void *)this = &unk_26E942E60;
  id v2 = (id **)*((void *)this + 8);
  if (v2 == *((id ***)this + 9))
  {
    *((void *)this + 9) = v2;
    objc_destroyWeak((id *)this + 12);
    uint64_t v3 = (void *)*((void *)this + 8);
    if (!v3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  do
  {
    unint64_t v5 = *v2;
    if (*v2)
    {
      id WeakRetained = objc_loadWeakRetained(v5 + 7);

      if (WeakRetained)
      {
        id v7 = objc_loadWeakRetained(v5 + 7);
        [v7 deleteCGraphNode];
      }
      else
      {
        (*((void (**)(id *))*v5 + 1))(v5);
      }
    }
    ++v2;
  }
  while (v2 != *((id ***)this + 9));
  *((void *)this + 9) = *((void *)this + 8);
  objc_destroyWeak((id *)this + 12);
  uint64_t v3 = (void *)*((void *)this + 8);
  if (v3)
  {
LABEL_3:
    *((void *)this + 9) = v3;
    operator delete(v3);
  }
LABEL_4:
  *(void *)this = &unk_26E942E38;
  objc_destroyWeak((id *)this + 4);
  unint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
}

{
  uint64_t vars8;

  GKCGridGraph::~GKCGridGraph(this);

  JUMPOUT(0x237DF7CA0);
}

void __clang_call_terminate(void *a1)
{
}

uint64_t GKCGridGraph::nodeAtGridPosition(uint64_t a1, double a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (SLODWORD(a2) < (int)v2) {
    return 0;
  }
  if (SLODWORD(a2) >= *(_DWORD *)(a1 + 48) + (int)v2) {
    return 0;
  }
  if (SHIDWORD(a2) < SHIDWORD(v2)) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 52);
  if (SHIDWORD(a2) >= v3 + HIDWORD(v2)) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 64) + 8 * (HIDWORD(a2) - HIDWORD(v2) + v3 * (LODWORD(a2) - v2)));
  }
}

uint64_t GKCGridGraph::nodeAtGridPositionNoNullCheck(int32x2_t *a1, int32x2_t a2)
{
  int32x2_t v2 = vsub_s32(a2, a1[5]);
  return *(void *)(*(void *)&a1[8] + 8 * (v2.i32[1] + v2.i32[0] * a1[6].i32[1]));
}

uint64_t GKCGridGraph::addNodeToGridNodes(int32x2_t *a1, int32x2_t *a2)
{
  int32x2_t v2 = a2[8];
  int32x2_t v3 = a1[5];
  if (v2.i32[0] >= v3.i32[0] && v2.i32[0] < a1[6].i32[0] + v3.i32[0] && v2.i32[1] >= v3.i32[1])
  {
    __int32 v9 = a1[6].i32[1];
    if (v2.i32[1] < v9 + v3.i32[1])
    {
      if (*(void *)(*(void *)&a1[8] + 8 * (v2.i32[1] - v3.i32[1] + v9 * (v2.i32[0] - v3.i32[0])))) {
        return 0;
      }
    }
  }
  int32x2_t v5 = vsub_s32(v2, v3);
  unint64_t v6 = (v5.i32[1] + a1[6].i32[1] * v5.i32[0]);
  if ((v6 & 0x80000000) != 0) {
    return 0;
  }
  int32x2_t v7 = a1[8];
  if (v6 >= (uint64_t)(*(void *)&a1[9] - *(void *)&v7) >> 3) {
    return 0;
  }
  *(void *)(*(void *)&v7 + 8 * v6) = a2;
  return 1;
}

id *GKCGridGraph::connectNodeToAdjacentNodes(GKCGridGraph *this, int32x2_t *a2)
{
  GKCGraph::addNode(this, (id *)a2);

  return GKCGridGraph::connectNodeToAdjacentNodesNoAdd((id *)this, a2, 1);
}

void GKCGridGraph::removeNode(int32x2_t *this, GKCGraphNode *a2)
{
  if (a2)
  {
    if (v4)
    {
      int32x2_t v5 = vsub_s32(v4[8], this[5]);
      *(void *)(*(void *)&this[8] + 8 * (v5.i32[1] + v5.i32[0] * this[6].i32[1])) = 0;
    }
  }

  GKCGraph::removeNode((GKCGraph *)this, (id *)a2);
}

void GKCObstacleGraph::GKCObstacleGraph(GKCObstacleGraph *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(void *)this = &unk_26E942E88;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 19) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *((void *)this + 22) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = (char *)this + 152;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = (char *)this + 176;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
}

void GKCObstacleGraph::~GKCObstacleGraph(GKCObstacleGraph *this)
{
  *(void *)this = &unk_26E942E88;
  uint64_t v2 = *((void *)this + 11);
  for (uint64_t i = *((void *)this + 12); i != v2; i -= 8)
  {
    unint64_t v4 = *(void **)(i - 8);
  }
  *((void *)this + 12) = v2;
  objc_destroyWeak((id *)this + 24);
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)this + 168, *((void **)this + 22));
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)this + 144, *((void **)this + 19));
  int32x2_t v5 = (void *)*((void *)this + 15);
  if (v5)
  {
    *((void *)this + 16) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *((void *)this + 11);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 12);
    int32x2_t v8 = (void *)*((void *)this + 11);
    if (v7 != v6)
    {
      do
      {
        __int32 v9 = *(void **)(v7 - 8);
        v7 -= 8;
      }
      while (v7 != v6);
      int32x2_t v8 = (void *)*((void *)this + 11);
    }
    *((void *)this + 12) = v6;
    operator delete(v8);
  }
  int32x2_t v10 = (void *)*((void *)this + 8);
  if (v10)
  {
    *((void *)this + 9) = v10;
    operator delete(v10);
  }
  int v11 = (void *)*((void *)this + 5);
  if (v11)
  {
    *((void *)this + 6) = v11;
    operator delete(v11);
  }
  *(void *)this = &unk_26E942E38;
  objc_destroyWeak((id *)this + 4);
  unint64_t v12 = (void *)*((void *)this + 1);
  if (v12)
  {
    *((void *)this + 2) = v12;
    operator delete(v12);
  }
}

{
  uint64_t vars8;

  GKCObstacleGraph::~GKCObstacleGraph(this);

  JUMPOUT(0x237DF7CA0);
}

uint64_t GKCObstacleGraph::connectNodeUsingObstacles(GKCObstacleGraph *this, GKCGraphNode2D *a2)
{
  unint64_t v4 = (uint64_t *)*((void *)this + 1);
  if (v4 != *((uint64_t **)this + 2))
  {
    int32x2_t v5 = (void *)MEMORY[0x263EFFA68];
    do
    {
      uint64_t v6 = *v4++;
      GKCObstacleGraph::connectNodeToNodeUsingObstacles((id *)this, a2, v6, v5);
    }
    while (v4 != *((uint64_t **)this + 2));
  }

  return GKCGraph::addNode(this, (id *)a2);
}

uint64_t GKCObstacleGraph::connectNodeUsingObstaclesIgnoringObstacles(uint64_t a1, GKCGraphNode *a2, void *a3)
{
  for (uint64_t i = *(uint64_t **)(a1 + 8); i != *(uint64_t **)(a1 + 16); ++i)
  {
    uint64_t v7 = *i;
    GKCObstacleGraph::connectNodeToNodeUsingObstacles((id *)a1, a2, v7, a3);
  }

  return GKCGraph::addNode((GKCGraph *)a1, (id *)a2);
}

id *GKCObstacleGraph::connectNodeToNodeUsingObstacles(id *result, GKCGraphNode *a2, uint64_t a3, void *a4)
{
  int32x2_t v5 = a2;
  uint64_t v6 = result;
  uint64_t v40 = *MEMORY[0x263EF8340];
  int32x2_t v8 = *(GKCGraphNode ***)(a3 + 8);
  uint64_t v7 = *(GKCGraphNode ***)(a3 + 16);
  if (v8 != v7)
  {
    while (*v8 != a2)
    {
      if (++v8 == v7)
      {
        int32x2_t v8 = *(GKCGraphNode ***)(a3 + 16);
        break;
      }
    }
  }
  if (v8 == v7)
  {
    __int32 v9 = (uint64_t *)result[8];
    if (v9 != result[9])
    {
      int v36 = result + 19;
      int32x2_t v10 = (float32x2_t *)((char *)a2 + 64);
      int v11 = (float32x2_t *)(a3 + 64);
      int v34 = (float32x2_t *)(a3 + 64);
      do
      {
        uint64_t v12 = *v9;
        memset(v38, 0, sizeof(v38));
        id v13 = a4;
        if ([v13 countByEnumeratingWithState:v38 objects:v39 count:16])
        {
          BOOL v14 = v6;
          int v15 = v10;
          uint64_t v16 = a4;
          unint64_t v17 = [**((id **)&v38[0] + 1) cPolygonObstacle];
          unint64_t v18 = v17;
          unsigned int v19 = (uint64_t **)v36;
          while (1)
          {
            uint64_t v20 = *v19;
            int32x2_t v21 = v19;
            if (!*v19) {
              break;
            }
            while (1)
            {
              unsigned int v19 = (uint64_t **)v20;
              unint64_t v22 = v20[4];
              if (v17 < v22) {
                break;
              }
              if (v22 >= v17)
              {
                int32x2_t v23 = (uint64_t *)v19;
                a4 = v16;
                int32x2_t v10 = v15;
                uint64_t v6 = v14;
                goto LABEL_21;
              }
              uint64_t v20 = v19[1];
              if (!v20)
              {
                int32x2_t v21 = v19 + 1;
                goto LABEL_16;
              }
            }
          }
LABEL_16:
          int32x2_t v23 = (uint64_t *)operator new(0x30uLL);
          v23[4] = v18;
          v23[5] = 0;
          uint64_t *v23 = 0;
          v23[1] = 0;
          v23[2] = (uint64_t)v19;
          *int32x2_t v21 = v23;
          uint64_t v6 = v14;
          int v24 = *(void **)v14[18];
          int v25 = v23;
          if (v24)
          {
            v14[18] = v24;
            int v25 = *v21;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v14[19], v25);
          v14[20] = (char *)v14[20] + 1;
          a4 = v16;
          int32x2_t v10 = v15;
LABEL_21:
          int32x2_t v5 = a2;
          BOOL v26 = v12 == v23[5];

          int v11 = v34;
          if (v26) {
            goto LABEL_8;
          }
        }
        else
        {
        }
        if (v12 == *((void *)v5 + 5) && *((void *)v5 + 4) == *(void *)(a3 + 32))
        {
          int v27 = *((_DWORD *)v5 + 12);
          int v28 = *(_DWORD *)(a3 + 48);
          if (v27 - v28 >= 0) {
            int v29 = v27 - v28;
          }
          else {
            int v29 = v28 - v27;
          }
          BOOL v30 = v29 == 1;
          int v31 = ((*(void *)(v12 + 16) - *(void *)(v12 + 8)) >> 3) - 1;
          if (v27)
          {
            if (v27 != v31) {
              goto LABEL_45;
            }
          }
          else
          {
            BOOL v30 = v28 == v31 || v29 == 1;
            if (((*(void *)(v12 + 16) - *(void *)(v12 + 8)) >> 3) != 1)
            {
LABEL_45:
              if (v30) {
                goto LABEL_8;
              }
              goto LABEL_24;
            }
          }
          if (v28) {
            char v32 = v30;
          }
          else {
            char v32 = 1;
          }
          if (v32) {
            goto LABEL_8;
          }
        }
LABEL_24:
        uint64_t result = (id *)GKCPolygonObstacle::intersectsLineFrom(v12, v10, v11);
        if (result) {
          return result;
        }
        uint64_t result = (id *)GKCPolygonObstacle::intersectsPoint(v12, v10);
        if (result) {
          return result;
        }
        uint64_t result = (id *)GKCPolygonObstacle::intersectsPoint(v12, v11);
        if (result) {
          return result;
        }
LABEL_8:
        ++v9;
      }
      while (v9 != v6[9]);
    }
    return GKCGraphNode::addConnectionToNode((id *)a3, (id *)v5, 1);
  }
  return result;
}

void sub_235ED6138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GKCObstacleGraph::connectNodeUsingObstaclesIgnoringBufferRadiusOfObstacles(GKCGraph *a1, float32x2_t *a2, void *a3)
{
  for (uint64_t i = (uint64_t *)*((void *)a1 + 1); i != *((uint64_t **)a1 + 2); ++i)
  {
    uint64_t v7 = *i;
    GKCObstacleGraph::connectNodeToNodeUsingObstaclesIgnoreBufferRadius((uint64_t)a1, a2, v7, a3);
  }

  return GKCGraph::addNode(a1, (id *)a2);
}

uint64_t GKCObstacleGraph::connectNodeToNodeUsingObstaclesIgnoreBufferRadius(uint64_t result, float32x2_t *a2, uint64_t a3, void *a4)
{
  int v28 = (GKCGraphNode *)a3;
  uint64_t v5 = result;
  uint64_t v7 = *(GKCGraphNode ***)(a3 + 8);
  uint64_t v6 = *(GKCGraphNode ***)(a3 + 16);
  if (v7 != v6)
  {
    while (*v7 != (GKCGraphNode *)a2)
    {
      if (++v7 == v6)
      {
        uint64_t v7 = *(GKCGraphNode ***)(a3 + 16);
        break;
      }
    }
  }
  if (v7 == v6)
  {
    int32x2_t v8 = *(unint64_t **)(result + 64);
    if (v8 == *(unint64_t **)(result + 72))
    {
LABEL_48:
      return (uint64_t)GKCGraphNode::addConnectionToNode((id *)v28, (id *)a2, 1);
    }
    __int32 v9 = (uint64_t **)(result + 176);
    int32x2_t v10 = (float32x2_t *)(a3 + 64);
    while (1)
    {
      unint64_t v11 = *v8;
      uint64_t v12 = *v9;
      id v13 = (uint64_t **)(v5 + 176);
      BOOL v14 = (uint64_t **)(v5 + 176);
      if (*v9)
      {
        while (1)
        {
          while (1)
          {
            BOOL v14 = (uint64_t **)v12;
            unint64_t v15 = v12[4];
            if (v11 >= v15) {
              break;
            }
            uint64_t v12 = *v14;
            id v13 = v14;
            if (!*v14) {
              goto LABEL_16;
            }
          }
          if (v15 >= v11) {
            break;
          }
          uint64_t v12 = v14[1];
          if (!v12)
          {
            id v13 = v14 + 1;
            goto LABEL_16;
          }
        }
      }
      else
      {
LABEL_16:
        uint64_t v16 = (uint64_t *)v14;
        BOOL v14 = (uint64_t **)operator new(0x30uLL);
        v14[4] = (uint64_t *)v11;
        v14[5] = 0;
        *BOOL v14 = 0;
        v14[1] = 0;
        v14[2] = v16;
        *id v13 = (uint64_t *)v14;
        uint64_t v17 = **(void **)(v5 + 168);
        unint64_t v18 = (uint64_t *)v14;
        if (v17)
        {
          *(void *)(v5 + 168) = v17;
          unint64_t v18 = *v13;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 176), v18);
        ++*(void *)(v5 + 184);
      }
      uint64_t v19 = (uint64_t)v14[5];
      uint64_t result = objc_msgSend(a4, "containsObject:", *(void *)(v19 + 64), v28);
      if (result) {
        uint64_t v20 = v19;
      }
      else {
        uint64_t v20 = v11;
      }
      if (v20 == *(void *)&a2[5] && *(void *)&a2[4] == *((void *)v28 + 4))
      {
        __int32 v21 = a2[6].i32[0];
        int v22 = *((_DWORD *)v28 + 12);
        if (v21 - v22 >= 0) {
          int v23 = v21 - v22;
        }
        else {
          int v23 = v22 - v21;
        }
        BOOL v24 = v23 == 1;
        int v25 = ((*(void *)(v20 + 16) - *(void *)(v20 + 8)) >> 3) - 1;
        if (v21)
        {
          if (v21 != v25) {
            goto LABEL_46;
          }
        }
        else
        {
          BOOL v24 = v22 == v25 || v23 == 1;
          if (((*(void *)(v20 + 16) - *(void *)(v20 + 8)) >> 3) != 1)
          {
LABEL_46:
            if (!v24) {
              return result;
            }
            goto LABEL_27;
          }
        }
        if (v22) {
          char v26 = v24;
        }
        else {
          char v26 = 1;
        }
        if ((v26 & 1) == 0) {
          return result;
        }
      }
      else
      {
        uint64_t result = GKCPolygonObstacle::intersectsLineFrom(v20, a2 + 8, v10);
        if (result) {
          return result;
        }
        uint64_t result = GKCPolygonObstacle::intersectsPoint(v20, &a2[8]);
        if (result) {
          return result;
        }
        uint64_t result = GKCPolygonObstacle::intersectsPoint(v20, v10);
        if (result) {
          return result;
        }
      }
LABEL_27:
      if (++v8 == *(unint64_t **)(v5 + 72)) {
        goto LABEL_48;
      }
    }
  }
  return result;
}

void GKCObstacleGraph::addObstacle(GKCObstacleGraph *this, GKCPolygonObstacle *a2)
{
}

void GKCObstacleGraph::addObstacle(GKCObstacleGraph *this, GKCPolygonObstacle *a2, int a3)
{
  __p = 0;
  unint64_t v89 = 0;
  uint64_t v90 = 0;
  GKCObstacleGraph::extrudeObstacleAndGenerateGraphNodes((uint64_t)this, a2, &__p);
  uint64_t v87 = a2;
  uint64_t v6 = *(void *)([*(id *)__p cGraphNode2D] + 40);
  if (a3)
  {
    uint64_t v7 = *((void *)this + 1);
    uint64_t v8 = *((void *)this + 2);
    if (v8 != v7)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 1;
      do
      {
        unint64_t v11 = v9 + 1;
        unint64_t v12 = (v8 - v7) >> 3;
        if (v12 > v9 + 1)
        {
          unint64_t v13 = v10;
          do
          {
            BOOL v14 = *(float32x2_t **)(v7 + 8 * v9);
            unint64_t v15 = *(float32x2_t **)(v7 + 8 * v13);
            if (GKCPolygonObstacle::intersectsLineFrom(v6, v14 + 8, v15 + 8)
              || GKCPolygonObstacle::intersectsPoint(v6, &v14[8])
              || GKCPolygonObstacle::intersectsPoint(v6, &v15[8]))
            {
              uint64_t v16 = (char *)*((void *)this + 15);
              uint64_t v17 = (char *)*((void *)this + 16);
              if (v17 == v16) {
                goto LABEL_28;
              }
              unint64_t v18 = (v17 - v16) >> 4;
              uint64_t v19 = v18 <= 1 ? 1 : (v17 - v16) >> 4;
              if (*(float32x2_t **)v16 != v14 || *((void *)v16 + 1) != (void)v15)
              {
                __int32 v21 = (float32x2_t **)(v16 + 24);
                uint64_t v22 = 1;
                do
                {
                  unint64_t v23 = v22;
                  if (v19 == v22) {
                    break;
                  }
                  BOOL v24 = *(v21 - 1);
                  int v25 = *v21;
                  v21 += 2;
                  ++v22;
                }
                while (v24 != v14 || v25 != v15);
                if (v18 <= v23)
                {
LABEL_28:
                  GKCGraphNode::removeConnectionToNode((id *)v14, (id *)v15, 0);
                  uint64_t v16 = (char *)*((void *)this + 15);
                  uint64_t v17 = (char *)*((void *)this + 16);
                  unint64_t v18 = (v17 - v16) >> 4;
                }
              }
              if (v17 == v16) {
                goto LABEL_7;
              }
              uint64_t v27 = v18 <= 1 ? 1 : v18;
              if (*(float32x2_t **)v16 != v15 || *((void *)v16 + 1) != (void)v14)
              {
                int v29 = (float32x2_t **)(v16 + 24);
                uint64_t v30 = 1;
                do
                {
                  unint64_t v31 = v30;
                  if (v27 == v30) {
                    break;
                  }
                  char v32 = *(v29 - 1);
                  int v33 = *v29;
                  v29 += 2;
                  ++v30;
                }
                while (v32 != v15 || v33 != v14);
                if (v18 <= v31) {
LABEL_7:
                }
                  GKCGraphNode::removeConnectionToNode((id *)v15, (id *)v14, 0);
              }
            }
            ++v13;
            uint64_t v7 = *((void *)this + 1);
            uint64_t v8 = *((void *)this + 2);
            unint64_t v12 = (v8 - v7) >> 3;
          }
          while (v12 > v13);
        }
        ++v10;
        ++v9;
      }
      while (v12 > v11);
    }
  }
  int v36 = (uint64_t *)*((void *)this + 9);
  unint64_t v35 = *((void *)this + 10);
  if ((unint64_t)v36 < v35)
  {
    *int v36 = v6;
    uint64_t v37 = (uint64_t)(v36 + 1);
    int32x2_t v38 = v87;
    goto LABEL_59;
  }
  unint64_t v39 = (char *)*((void *)this + 8);
  uint64_t v40 = ((char *)v36 - v39) >> 3;
  unint64_t v41 = v40 + 1;
  int32x2_t v38 = v87;
  if ((unint64_t)(v40 + 1) >> 61) {
    goto LABEL_103;
  }
  uint64_t v42 = v35 - (void)v39;
  if (v42 >> 2 > v41) {
    unint64_t v41 = v42 >> 2;
  }
  if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v43 = v41;
  }
  if (v43)
  {
    if (v43 >> 61) {
      goto LABEL_104;
    }
    id v44 = (char *)operator new(8 * v43);
    double v45 = (uint64_t *)&v44[8 * v40];
    uint64_t v46 = &v44[8 * v43];
    uint64_t *v45 = v6;
    uint64_t v37 = (uint64_t)(v45 + 1);
    long long v47 = (char *)((char *)v36 - v39);
    if (v36 == (uint64_t *)v39)
    {
LABEL_57:
      *((void *)this + 8) = v45;
      *((void *)this + 9) = v37;
      *((void *)this + 10) = v46;
      if (!v36) {
        goto LABEL_59;
      }
      goto LABEL_58;
    }
  }
  else
  {
    id v44 = 0;
    double v45 = (uint64_t *)(8 * v40);
    uint64_t v46 = 0;
    *(void *)(8 * v40) = v6;
    uint64_t v37 = 8 * v40 + 8;
    long long v47 = (char *)((char *)v36 - v39);
    if (v36 == (uint64_t *)v39) {
      goto LABEL_57;
    }
  }
  unint64_t v69 = (unint64_t)(v47 - 8);
  if (v69 < 0x58) {
    goto LABEL_107;
  }
  if ((unint64_t)(v39 - v44) < 0x20) {
    goto LABEL_107;
  }
  uint64_t v70 = (v69 >> 3) + 1;
  uint64_t v71 = 8 * (v70 & 0x3FFFFFFFFFFFFFFCLL);
  long long v72 = &v36[v71 / 0xFFFFFFFFFFFFFFF8];
  double v45 = (uint64_t *)((char *)v45 - v71);
  uint64_t v73 = &v44[8 * v40 - 16];
  uint64_t v74 = v36 - 2;
  uint64_t v75 = v70 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v76 = *(_OWORD *)v74;
    *((_OWORD *)v73 - 1) = *((_OWORD *)v74 - 1);
    *(_OWORD *)uint64_t v73 = v76;
    v73 -= 32;
    v74 -= 4;
    v75 -= 4;
  }
  while (v75);
  int v36 = v72;
  if (v70 != (v70 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_107:
    do
    {
      uint64_t v77 = *--v36;
      *--double v45 = v77;
    }
    while (v36 != (uint64_t *)v39);
  }
  int v36 = (uint64_t *)*((void *)this + 8);
  *((void *)this + 8) = v45;
  *((void *)this + 9) = v37;
  *((void *)this + 10) = v46;
  if (v36) {
LABEL_58:
  }
    operator delete(v36);
LABEL_59:
  *((void *)this + 9) = v37;
  unsigned int v49 = (char *)*((void *)this + 6);
  unint64_t v48 = *((void *)this + 7);
  if ((unint64_t)v49 < v48)
  {
    *(void *)unsigned int v49 = v38;
    uint64_t v50 = (uint64_t)(v49 + 8);
    goto LABEL_72;
  }
  char v51 = (char *)*((void *)this + 5);
  uint64_t v52 = (v49 - v51) >> 3;
  unint64_t v53 = v52 + 1;
  if ((unint64_t)(v52 + 1) >> 61) {
LABEL_103:
  }
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  uint64_t v54 = v48 - (void)v51;
  if (v54 >> 2 > v53) {
    unint64_t v53 = v54 >> 2;
  }
  if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v55 = v53;
  }
  if (v55)
  {
    if (!(v55 >> 61))
    {
      double v56 = (char *)operator new(8 * v55);
      int64_t v57 = (GKCPolygonObstacle **)&v56[8 * v52];
      uint64_t v58 = &v56[8 * v55];
      *int64_t v57 = v38;
      uint64_t v50 = (uint64_t)(v57 + 1);
      unint64_t v59 = (char *)(v49 - v51);
      if (v49 == v51) {
        goto LABEL_70;
      }
      goto LABEL_95;
    }
LABEL_104:
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  double v56 = 0;
  int64_t v57 = (GKCPolygonObstacle **)(8 * v52);
  uint64_t v58 = 0;
  *(void *)(8 * v52) = v38;
  uint64_t v50 = 8 * v52 + 8;
  unint64_t v59 = (char *)(v49 - v51);
  if (v49 == v51)
  {
LABEL_70:
    *((void *)this + 5) = v57;
    *((void *)this + 6) = v50;
    *((void *)this + 7) = v58;
    if (!v49) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }
LABEL_95:
  unint64_t v78 = (unint64_t)(v59 - 8);
  if (v78 < 0x58) {
    goto LABEL_108;
  }
  if ((unint64_t)(v51 - v56) < 0x20) {
    goto LABEL_108;
  }
  uint64_t v79 = (v78 >> 3) + 1;
  uint64_t v80 = 8 * (v79 & 0x3FFFFFFFFFFFFFFCLL);
  id v81 = &v49[-v80];
  int64_t v57 = (GKCPolygonObstacle **)((char *)v57 - v80);
  int64_t v82 = &v56[8 * v52 - 16];
  uint64_t v83 = v49 - 16;
  uint64_t v84 = v79 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v85 = *(_OWORD *)v83;
    *((_OWORD *)v82 - 1) = *((_OWORD *)v83 - 1);
    *(_OWORD *)int64_t v82 = v85;
    v82 -= 32;
    v83 -= 32;
    v84 -= 4;
  }
  while (v84);
  unsigned int v49 = v81;
  if (v79 != (v79 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_108:
    do
    {
      unint64_t v86 = (GKCPolygonObstacle *)*((void *)v49 - 1);
      v49 -= 8;
      *--int64_t v57 = v86;
    }
    while (v49 != v51);
  }
  unsigned int v49 = (char *)*((void *)this + 5);
  *((void *)this + 5) = v57;
  *((void *)this + 6) = v50;
  *((void *)this + 7) = v58;
  if (v49) {
LABEL_71:
  }
    operator delete(v49);
LABEL_72:
  *((void *)this + 6) = v50;
  id WeakRetained = objc_loadWeakRetained((id *)this + 24);
  unint64_t v61 = [WeakRetained mutObstacles];
  [v61 addObject:*((void *)v38 + 8)];

  float32_t v62 = (id *)__p;
  if (__p == v89)
  {
    uint64_t v66 = (id *)__p;
    if (!__p) {
      return;
    }
    goto LABEL_80;
  }
  unint64_t v63 = (void *)MEMORY[0x263EFFA68];
  do
  {
    unint64_t v64 = (GKCGraphNode *)[*v62 cGraphNode2D];
    for (uint64_t i = (uint64_t *)*((void *)this + 1); i != *((uint64_t **)this + 2); ++i)
      GKCObstacleGraph::connectNodeToNodeUsingObstacles((id *)this, v64, *i, v63);
    GKCGraph::addNode(this, (id *)v64);
    ++v62;
  }
  while (v62 != v89);
  uint64_t v66 = (id *)__p;
  if (__p)
  {
LABEL_80:
    uint64_t v67 = v66;
    if (v62 != v66)
    {
      do
      {
        uint64_t v68 = *--v62;
      }
      while (v62 != v66);
      uint64_t v67 = __p;
    }
    unint64_t v89 = v66;
    operator delete(v67);
  }
}

void sub_235ED6984(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235ED69A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235ED69B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235ED69CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235ED69E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235ED69F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235ED6A08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235ED6A1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void GKCObstacleGraph::extrudeObstacleAndGenerateGraphNodes(uint64_t a1, GKCPolygonObstacle *a2, void *a3)
{
  std::vector<NSObject * {__strong}>::reserve((uint64_t)a3, (uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 3);
  uint64_t v6 = GKCObstacleGraph::extrudeObstacle((float32_t *)a1, a2);
  id v27 = v6;
  uint64_t v7 = *(void **)(a1 + 96);
  if ((unint64_t)v7 >= *(void *)(a1 + 104))
  {
    uint64_t v9 = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>((void *)(a1 + 88), &v27);
    id v8 = v27;
  }
  else
  {
    id v8 = v6;
    void *v7 = v8;
    uint64_t v9 = v7 + 1;
  }
  *(void *)(a1 + 96) = v9;
  uint64_t v10 = [v8 cPolygonObstacle];
  unint64_t v11 = *(void *)(v10 + 16) - *(void *)(v10 + 8);
  if ((int)(v11 >> 3) >= 1)
  {
    uint64_t v12 = 0;
    unint64_t v13 = (id *)(a1 + 192);
    uint64_t v14 = (v11 >> 3);
    do
    {
      while (1)
      {
        float32x2_t v15 = *(float32x2_t *)(*((void *)a2 + 1) + 8 * v12);
        float32x2_t v16 = *(float32x2_t *)(*(void *)(v10 + 8) + 8 * v12);
        id WeakRetained = objc_loadWeakRetained(v13);
        id v18 = objc_alloc((Class)[WeakRetained nodeClass]);
        float32x2_t v19 = vsub_f32(v16, v15);
        int32x2_t v20 = (int32x2_t)vmul_f32(v19, v19);
        v20.i32[0] = vadd_f32((float32x2_t)v20, (float32x2_t)vdup_lane_s32(v20, 1)).u32[0];
        float32x2_t v21 = vrsqrte_f32((float32x2_t)v20.u32[0]);
        float32x2_t v22 = vmul_f32(v21, v21);
        float32x2_t v23 = vrsqrts_f32((float32x2_t)v20.u32[0], v22);
        v22.i32[0] = 955908096;
        id v26 = (id)objc_msgSend(v18, "initWithPoint:", COERCE_DOUBLE(vmla_n_f32(v16, v19, vmul_f32(v23, vmul_f32(v21, v22)).f32[0])));

        uint64_t v24 = [v26 cGraphNode2D];
        *(void *)(v24 + 32) = a2;
        *(void *)(v24 + 40) = v10;
        *(_DWORD *)(v24 + 48) = v12;
        int v25 = (void *)a3[1];
        if ((unint64_t)v25 >= a3[2]) {
          break;
        }
        void *v25 = v26;
        a3[1] = v25 + 1;

        if (v14 == ++v12) {
          goto LABEL_9;
        }
      }
      a3[1] = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(a3, &v26);

      ++v12;
    }
    while (v14 != v12);
  }
LABEL_9:
}

void sub_235ED6BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_235ED6BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_235ED6C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_235ED6C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

BOOL GKCObstacleGraph::isConnectedLockedFromNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int32x2_t v3 = *(void **)(a1 + 120);
  uint64_t v4 = *(void *)(a1 + 128) - (void)v3;
  if (!v4) {
    return 0;
  }
  unint64_t v5 = v4 >> 4;
  if (v5 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = v5;
  }
  if (*v3 == a2 && v3[1] == a3) {
    return 1;
  }
  id v8 = v3 + 3;
  uint64_t v9 = 1;
  do
  {
    unint64_t v10 = v9;
    if (v6 == v9) {
      break;
    }
    uint64_t v11 = *(v8 - 1);
    uint64_t v12 = *v8;
    v8 += 2;
    ++v9;
  }
  while (v11 != a2 || v12 != a3);
  return v5 > v10;
}

void GKCObstacleGraph::removeObstacle(GKCObstacleGraph *this, GKCPolygonObstacle *a2)
{
  unint64_t v4 = *((void *)this + 2) - *((void *)this + 1);
  if ((int)(v4 >> 3) >= 1)
  {
    unint64_t v5 = (v4 >> 3) + 1;
    do
    {
      if (*(GKCPolygonObstacle **)(*(void *)(*((void *)this + 1) + 8 * (v5 - 2)) + 32) == a2) {
        (*(void (**)(GKCObstacleGraph *))(*(void *)this + 16))(this);
      }
      --v5;
    }
    while (v5 > 1);
  }
  uint64_t v7 = (uint64_t **)((char *)this + 152);
  uint64_t v6 = (uint64_t *)*((void *)this + 19);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        id v8 = (uint64_t **)v6;
        unint64_t v9 = v6[4];
        if (v9 <= (unint64_t)a2) {
          break;
        }
        uint64_t v6 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_13;
        }
      }
      if (v9 >= (unint64_t)a2) {
        break;
      }
      uint64_t v6 = v8[1];
      if (!v6)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    id v8 = (uint64_t **)((char *)this + 152);
LABEL_13:
    unint64_t v10 = (uint64_t *)v8;
    id v8 = (uint64_t **)operator new(0x30uLL);
    v8[4] = (uint64_t *)a2;
    v8[5] = 0;
    *id v8 = 0;
    v8[1] = 0;
    v8[2] = v10;
    void *v7 = (uint64_t *)v8;
    uint64_t v11 = **((void **)this + 18);
    uint64_t v12 = (uint64_t *)v8;
    if (v11)
    {
      *((void *)this + 18) = v11;
      uint64_t v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 19), v12);
    ++*((void *)this + 20);
  }
  uint64_t v14 = (GKCPolygonObstacle **)*((void *)this + 5);
  unint64_t v13 = (GKCPolygonObstacle **)*((void *)this + 6);
  if (v14 != v13)
  {
    while (*v14 != a2)
    {
      if (++v14 == v13)
      {
        uint64_t v14 = (GKCPolygonObstacle **)*((void *)this + 6);
        break;
      }
    }
  }
  float32x2_t v15 = v8[5];
  int64_t v16 = (char *)v13 - (char *)(v14 + 1);
  if (v13 != v14 + 1) {
    memmove(v14, v14 + 1, (char *)v13 - (char *)(v14 + 1));
  }
  *((void *)this + 6) = (char *)v14 + v16;
  id v18 = (char *)*((void *)this + 8);
  uint64_t v17 = (char *)*((void *)this + 9);
  if (v18 != v17)
  {
    while (*(uint64_t **)v18 != v15)
    {
      v18 += 8;
      if (v18 == v17)
      {
        id v18 = (char *)*((void *)this + 9);
        break;
      }
    }
  }
  int64_t v19 = v17 - (v18 + 8);
  if (v17 != v18 + 8) {
    memmove(v18, v18 + 8, v17 - (v18 + 8));
  }
  *((void *)this + 9) = &v18[v19];
  id WeakRetained = objc_loadWeakRetained((id *)this + 24);
  float32x2_t v21 = [WeakRetained mutObstacles];
  [v21 removeObject:*((void *)a2 + 8)];

  float32x2_t v22 = (void **)*((void *)this + 11);
  float32x2_t v23 = (void **)*((void *)this + 12);
  if (v22 != v23)
  {
    while (*v22 != (void *)v15[8])
    {
      if (++v22 == v23)
      {
        float32x2_t v22 = (void **)*((void *)this + 12);
        break;
      }
    }
  }
  if (v22 == v23) {
    GKCObstacleGraph::removeObstacle();
  }
  uint64_t v24 = *v22;
  *float32x2_t v22 = 0;
  int v25 = *(v23 - 1);
  *(v23 - 1) = 0;
  id v26 = *v22;
  *float32x2_t v22 = v25;

  id v27 = *(v23 - 1);
  *(v23 - 1) = v24;

  uint64_t v28 = *((void *)this + 12);
  *((void *)this + 12) = v28 - 8;
  uint64_t v29 = *((void *)this + 1);
  uint64_t v30 = *((void *)this + 2);
  if (v30 != v29)
  {
    uint64_t v31 = 0;
    uint64_t v32 = 1;
    int v33 = (void *)MEMORY[0x263EFFA68];
    do
    {
      unint64_t v34 = v31 + 1;
      unint64_t v35 = (v30 - v29) >> 3;
      if (v35 > v31 + 1)
      {
        unint64_t v36 = v32;
        do
        {
          GKCObstacleGraph::connectNodeToNodeUsingObstacles((id *)this, *(GKCGraphNode **)(v29 + 8 * v31), *(void *)(v29 + 8 * v36++), v33);
          uint64_t v29 = *((void *)this + 1);
          uint64_t v30 = *((void *)this + 2);
          unint64_t v35 = (v30 - v29) >> 3;
        }
        while (v35 > v36);
      }
      ++v32;
      ++v31;
    }
    while (v35 > v34);
  }
}

void sub_235ED6F80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED6F94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *GKCObstacleGraph::restoreObstacleNodeConnections(id *this)
{
  float v1 = this[1];
  uint64_t v2 = this[2];
  if (v2 != v1)
  {
    uint64_t v3 = (uint64_t)this;
    uint64_t v4 = 0;
    uint64_t v5 = 1;
    uint64_t v6 = (void *)MEMORY[0x263EFFA68];
    do
    {
      unint64_t v7 = v4 + 1;
      unint64_t v8 = (v2 - v1) >> 3;
      if (v8 > v4 + 1)
      {
        unint64_t v9 = v5;
        do
        {
          this = GKCObstacleGraph::connectNodeToNodeUsingObstacles((id *)v3, *(GKCGraphNode **)&v1[8 * v4], *(void *)&v1[8 * v9++], v6);
          float v1 = *(unsigned char **)(v3 + 8);
          uint64_t v2 = *(unsigned char **)(v3 + 16);
          unint64_t v8 = (v2 - v1) >> 3;
        }
        while (v8 > v9);
      }
      ++v5;
      ++v4;
    }
    while (v8 > v7);
  }
  return this;
}

void GKCObstacleGraph::removeAllObstacles(GKCObstacleGraph *this)
{
  unint64_t v1 = *((void *)this + 6) - *((void *)this + 5);
  if ((int)(v1 >> 3) >= 1)
  {
    unint64_t v3 = (v1 >> 3) + 1;
    do
      GKCObstacleGraph::removeObstacle(this, *(GKCPolygonObstacle **)(*((void *)this + 5) + 8 * (v3-- - 2)));
    while (v3 > 1);
  }
}

id GKCObstacleGraph::nodesForObstacle(GKCObstacleGraph *this, GKCPolygonObstacle *a2)
{
  uint64_t v4 = [MEMORY[0x263EFF980] array];
  uint64_t v6 = *((void *)this + 1);
  uint64_t v5 = *((void *)this + 2);
  while (v6 != v5)
  {
    if (*(GKCPolygonObstacle **)(*(void *)v6 + 32) == a2)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)v6 + 72));
      [v4 addObject:WeakRetained];

      uint64_t v5 = *((void *)this + 2);
    }
    v6 += 8;
  }

  return v4;
}

void sub_235ED714C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GKCObstacleGraph::extrudeObstacle(float32_t *this, GKCPolygonObstacle *a2)
{
  uint64_t v4 = GKCPolygonObstacle::extrudeObstacle(a2, a2, this[28]);
  uint64_t v5 = [v4 cPolygonObstacle];
  unint64_t v7 = (uint64_t **)(this + 38);
  uint64_t v6 = (uint64_t *)*((void *)this + 19);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v6;
        unint64_t v9 = v6[4];
        if (v9 <= (unint64_t)a2) {
          break;
        }
        uint64_t v6 = *v8;
        unint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= (unint64_t)a2) {
        break;
      }
      uint64_t v6 = v8[1];
      if (!v6)
      {
        unint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
    unint64_t v10 = (uint64_t *)v8;
  }
  else
  {
    unint64_t v8 = (uint64_t **)(this + 38);
LABEL_8:
    unint64_t v10 = (uint64_t *)operator new(0x30uLL);
    v10[4] = (uint64_t)a2;
    v10[5] = 0;
    *unint64_t v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t)v8;
    void *v7 = v10;
    uint64_t v11 = **((void **)this + 18);
    uint64_t v12 = v10;
    if (v11)
    {
      *((void *)this + 18) = v11;
      uint64_t v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 19), v12);
    ++*((void *)this + 20);
  }
  v10[5] = v5;
  unint64_t v13 = [v4 cPolygonObstacle];
  unint64_t v14 = v13;
  int64_t v16 = (uint64_t **)(this + 44);
  float32x2_t v15 = (uint64_t *)*((void *)this + 22);
  if (v15)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v17 = (uint64_t **)v15;
        unint64_t v18 = v15[4];
        if (v13 >= v18) {
          break;
        }
        float32x2_t v15 = *v17;
        int64_t v16 = v17;
        if (!*v17) {
          goto LABEL_19;
        }
      }
      if (v18 >= v13) {
        break;
      }
      float32x2_t v15 = v17[1];
      if (!v15)
      {
        int64_t v16 = v17 + 1;
        goto LABEL_19;
      }
    }
    int64_t v19 = (uint64_t *)v17;
  }
  else
  {
    uint64_t v17 = (uint64_t **)(this + 44);
LABEL_19:
    int64_t v19 = (uint64_t *)operator new(0x30uLL);
    v19[4] = v14;
    v19[5] = 0;
    *int64_t v19 = 0;
    v19[1] = 0;
    v19[2] = (uint64_t)v17;
    char *v16 = v19;
    uint64_t v20 = **((void **)this + 21);
    float32x2_t v21 = v19;
    if (v20)
    {
      *((void *)this + 21) = v20;
      float32x2_t v21 = *v16;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 22), v21);
    ++*((void *)this + 23);
  }
  v19[5] = (uint64_t)a2;

  return v4;
}

void sub_235ED7304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED7314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCObstacleGraph::lockConnectionFromNode(GKCObstacleGraph *this, GKCGraphNode2D *a2, GKCGraphNode2D *a3)
{
  unint64_t v8 = (char *)*((void *)this + 15);
  uint64_t v6 = (char *)*((void *)this + 16);
  unint64_t v7 = (char **)((char *)this + 120);
  unint64_t v9 = (v6 - v8) >> 4;
  if (v6 == v8)
  {
LABEL_11:
    unint64_t v13 = *((void *)this + 17);
    if ((unint64_t)v6 < v13)
    {
      *(void *)uint64_t v6 = a2;
      *((void *)v6 + 1) = a3;
      uint64_t v14 = (uint64_t)(v6 + 16);
LABEL_28:
      *((void *)this + 16) = v14;
      return;
    }
    unint64_t v15 = v9 + 1;
    if ((v9 + 1) >> 60) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v16 = v13 - (void)v8;
    if (v16 >> 3 > v15) {
      unint64_t v15 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17)
    {
      if (v17 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v18 = (char *)operator new(16 * v17);
      int64_t v19 = &v18[16 * v9];
      uint64_t v20 = &v18[16 * v17];
      *(void *)int64_t v19 = a2;
      *((void *)v19 + 1) = a3;
      uint64_t v14 = (uint64_t)(v19 + 16);
      if (v6 == v8) {
        goto LABEL_26;
      }
    }
    else
    {
      int64_t v19 = (char *)(16 * v9);
      uint64_t v20 = 0;
      *(void *)int64_t v19 = a2;
      *((void *)v19 + 1) = a3;
      uint64_t v14 = 16 * v9 + 16;
      if (v6 == v8)
      {
LABEL_26:
        *((void *)this + 15) = v19;
        *((void *)this + 16) = v14;
        *((void *)this + 17) = v20;
        if (v6) {
          operator delete(v6);
        }
        goto LABEL_28;
      }
    }
    do
    {
      *((_OWORD *)v19 - 1) = *((_OWORD *)v6 - 1);
      v19 -= 16;
      v6 -= 16;
    }
    while (v6 != v8);
    uint64_t v6 = *v7;
    goto LABEL_26;
  }
  if (v9 <= 1) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = (v6 - v8) >> 4;
  }
  uint64_t v11 = v8 + 8;
  while ((GKCGraphNode2D *)*(v11 - 1) != a2 || *v11 != (void)a3)
  {
    v11 += 2;
    if (!--v10) {
      goto LABEL_11;
    }
  }
}

uint64_t GKCObstacleGraph::unlockConnectionFromNode(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(result + 120);
  uint64_t v3 = *(void *)(result + 128);
  if (v3 != v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      if (*(void *)(v4 + v5) == a2 && *(void *)(v4 + v5 + 8) == a3)
      {
        *(_OWORD *)(v4 + v5) = *(_OWORD *)(v3 - 16);
        uint64_t v4 = *(void *)(result + 120);
        uint64_t v3 = *(void *)(result + 128) - 16;
        *(void *)(result + 128) = v3;
      }
      ++v6;
      v5 += 16;
    }
    while (v6 < (v3 - v4) >> 4);
  }
  return result;
}

void std::vector<GKCGridGraphNode *>::__append(void **a1, unint64_t a2)
{
  uint64_t v5 = (char *)a1[1];
  uint64_t v4 = a1[2];
  unint64_t v6 = v5;
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      unint64_t v6 = &v5[8 * a2];
    }
    a1[1] = v6;
  }
  else
  {
    unint64_t v7 = (char *)*a1;
    uint64_t v8 = v5 - (unsigned char *)*a1;
    uint64_t v9 = v8 >> 3;
    unint64_t v10 = (v8 >> 3) + a2;
    if (v10 >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v11 = v4 - v7;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v13 = operator new(8 * v12);
    }
    else
    {
      unint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    size_t v15 = 8 * a2;
    uint64_t v16 = &v13[8 * v12];
    bzero(v14, v15);
    unint64_t v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 8;
      if (v18 < 0x58) {
        goto LABEL_32;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_32;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v6 = &v5[-v20];
      v14 -= v20;
      float32x2_t v21 = &v13[8 * v9 - 16];
      float32x2_t v22 = v5 - 16;
      uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *(_OWORD *)v22;
        *(v21 - 1) = *((_OWORD *)v22 - 1);
        *float32x2_t v21 = v24;
        v21 -= 2;
        v22 -= 32;
        v23 -= 4;
      }
      while (v23);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_32:
        do
        {
          uint64_t v25 = *((void *)v6 - 1);
          v6 -= 8;
          *((void *)v14 - 1) = v25;
          v14 -= 8;
        }
        while (v6 != v7);
      }
      unint64_t v6 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v16;
    if (v6)
    {
      operator delete(v6);
    }
  }
}

void sub_235ED77D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED7A24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED7B44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8140(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8190(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED81A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8334(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED834C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED835C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8388(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8470(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8598(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v2, 0x20C40A4A59CD2);

  _Unwind_Resume(a1);
}

void sub_235ED85C0(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

void sub_235ED8674(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_235ED8690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED8A20(_Unwind_Exception *a1)
{
  uint64_t v8 = v6;

  _Unwind_Resume(a1);
}

void GKCDecisionTree::decode(GKCDecisionTree *this, NSArray *a2)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  int32x2_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v37 = &v38;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  obuint64_t j = a2;
  uint64_t v2 = [(NSArray *)obj countByEnumeratingWithState:&v33 objects:v40 count:16];
  if (v2)
  {
    uint64_t v31 = *(void *)v34;
    long long v28 = xmmword_235F1F020;
    do
    {
      uint64_t v32 = v2;
      for (uint64_t i = 0; i != v32; ++i)
      {
        if (*(void *)v34 != v31) {
          objc_enumerationMutation(obj);
        }
        uint64_t v4 = objc_msgSend(*(id *)(*((void *)&v33 + 1) + 8 * i), "objectForKeyedSubscript:", @"branch", v28);
        BOOL v5 = v4 == 0;

        if (!v5) {
          operator new();
        }
        unint64_t v6 = [(NSArray *)obj firstObject];
        uint64_t v7 = [v6 objectForKeyedSubscript:@"attribute"];
        uint64_t v8 = (void *)*((void *)this->var0 + 6);
        *((void *)this->var0 + 6) = v7;

        uint64_t v9 = [v6 objectForKeyedSubscript:@"randomDistribution"];
        BOOL v10 = v9 == 0;

        if (!v10)
        {
          uint64_t v11 = [v6 objectForKeyedSubscript:@"randomDistribution"];
          unint64_t v12 = [v11 objectAtIndexedSubscript:0];

          unint64_t v13 = [v6 objectForKeyedSubscript:@"randomDistribution"];
          uint64_t v14 = [v13 objectAtIndexedSubscript:1];

          size_t v15 = [v6 objectForKeyedSubscript:@"randomDistribution"];
          uint64_t v16 = [v15 objectAtIndexedSubscript:2];

          unint64_t v17 = -[GKRandomDistribution initWithRandomSource:lowestValue:highestValue:]([GKRandomDistribution alloc], "initWithRandomSource:lowestValue:highestValue:", v16, [v12 integerValue], objc_msgSend(v14, "integerValue"));
          unint64_t v18 = (void *)*((void *)this->var0 + 8);
          *((void *)this->var0 + 8) = v17;
        }
        uint64_t v19 = [v6 objectForKeyedSubscript:@"depth"];
        uint64_t v20 = [v19 integerValue];

        var0 = this->var0;
        float32x2_t v22 = v38;
        uint64_t v23 = &v38;
        long long v24 = &v38;
        if (v38)
        {
          while (1)
          {
            while (1)
            {
              long long v24 = (uint64_t **)v22;
              uint64_t v25 = v22[4];
              if (v20 >= v25) {
                break;
              }
              float32x2_t v22 = *v24;
              uint64_t v23 = v24;
              if (!*v24) {
                goto LABEL_18;
              }
            }
            if (v25 >= v20) {
              break;
            }
            float32x2_t v22 = v24[1];
            if (!v22)
            {
              uint64_t v23 = v24 + 1;
              goto LABEL_18;
            }
          }
          id v26 = (uint64_t *)v24;
        }
        else
        {
LABEL_18:
          id v26 = (uint64_t *)operator new(0x30uLL);
          v26[4] = v20;
          v26[5] = 0;
          *id v26 = 0;
          v26[1] = 0;
          v26[2] = (uint64_t)v24;
          uint64_t *v23 = v26;
          id v27 = v26;
          if (*v37)
          {
            uint64_t v37 = (uint64_t **)*v37;
            id v27 = *v23;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v38, v27);
          ++v39;
        }
        v26[5] = (uint64_t)var0;
      }
      uint64_t v2 = [(NSArray *)obj countByEnumeratingWithState:&v33 objects:v40 count:16];
    }
    while (v2);
  }

  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&v37, v38);
}

void sub_235ED9158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,void *a27)
{
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&a26, a27);
  _Unwind_Resume(a1);
}

NSArray *GKCDecisionTree::encodeWithCoder(GKCDecisionTree *this, GKCDecisionNode *a2, NSArray *a3, uint64_t a4, NSMutableDictionary *a5)
{
  v34[1] = *MEMORY[0x263EF8340];
  uint64_t v9 = a3;
  BOOL v10 = a5;
  uint64_t v11 = v10;
  if (v9)
  {
    long long v33 = v10;
    uint64_t v13 = *(void *)a2;
    uint64_t v12 = *((void *)a2 + 1);
    if (*(void *)a2 == v12) {
      goto LABEL_9;
    }
  }
  else
  {
    var0 = this->var0;
    size_t v15 = (void *)MEMORY[0x263EFF9A0];
    uint64_t v16 = GKCDecisionNode::nodeData(this->var0, 0);
    unint64_t v17 = [v15 dictionaryWithDictionary:v16];

    unint64_t v18 = [NSNumber numberWithInteger:a4];
    [(NSMutableDictionary *)v17 setObject:v18 forKeyedSubscript:@"depth"];

    id v19 = objc_alloc_init(MEMORY[0x263EFF980]);
    [(NSMutableDictionary *)v17 setObject:v19 forKeyedSubscript:@"children"];

    v34[0] = v17;
    uint64_t v9 = [MEMORY[0x263EFF8C0] arrayWithObjects:v34 count:1];
    long long v33 = v17;
    uint64_t v13 = *(void *)var0;
    uint64_t v12 = *((void *)var0 + 1);
    if (*(void *)var0 == v12) {
      goto LABEL_9;
    }
  }
  uint64_t v20 = a4 + 1;
  do
  {
    float32x2_t v21 = *(GKCDecisionNode **)(v13 + 8);
    if (v21)
    {
      float32x2_t v22 = (void *)MEMORY[0x263EFF9A0];
      uint64_t v23 = GKCDecisionNode::nodeData(v21, *(objc_object **)v13);
      long long v24 = [v22 dictionaryWithDictionary:v23];

      uint64_t v25 = [NSNumber numberWithInteger:v20];
      [(NSMutableDictionary *)v24 setObject:v25 forKeyedSubscript:@"depth"];

      id v26 = objc_alloc_init(MEMORY[0x263EFF980]);
      [(NSMutableDictionary *)v24 setObject:v26 forKeyedSubscript:@"children"];

      id v27 = [(NSMutableDictionary *)v33 objectForKeyedSubscript:@"children"];
      long long v28 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", -[NSArray count](v9, "count"));
      [v27 addObject:v28];

      uint64_t v29 = *(GKCDecisionNode **)(v13 + 8);
      uint64_t v30 = [(NSArray *)v9 arrayByAddingObject:v24];
      uint64_t v31 = GKCDecisionTree::encodeWithCoder(this, v29, v30, v20, v24);

      uint64_t v9 = (NSArray *)v31;
    }
    v13 += 16;
  }
  while (v13 != v12);
LABEL_9:

  return v9;
}

void sub_235ED9550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235ED96C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235ED96E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235ED978C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)GKDecisionTree;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_235ED9B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void GKCDecisionTree::cartTreeGrowth(GKCDecisionTree *this, NSArray *a2, NSArray *a3, GKCDecisionNode *a4, unint64_t a5, unint64_t a6)
{
  uint64_t v8 = a2;
  uint64_t v91 = a3;
  unint64_t v89 = v8;
  unint64_t v9 = [(NSArray *)v8 count];
  double v10 = GKCDecisionTree::giniImpurity(this, v8);
  double v11 = (double)v9;
  unint64_t v87 = (unint64_t)(double)v9;
  *((void *)a4 + 5) = v87;
  if (v10 < 0.0) {
    goto LABEL_146;
  }
  if (v10 != 0.0)
  {
    v111[0] = 0;
    v111[1] = 0;
    uint64_t v110 = (uint64_t *)v111;
    uint64_t v88 = GKCDecisionTree::getAttributeCounts((uint64_t)this, v91, v8);
    unint64_t v16 = 0;
    uint64_t v92 = this;
    obuint64_t j = 0;
    double v17 = 1.0;
    for (unint64_t i = [(NSArray *)v91 count]; ; unint64_t i = [(NSArray *)v91 count])
    {
      if (i <= v16)
      {
        if (v17 > 0.0 && [(NSArray *)v91 count] < 2
          || (*((void *)a4 + 4) <= a5 ? (BOOL v73 = v11 < (double)a6) : (BOOL v73 = 1), v73))
        {
          GKCDecisionTree::splitByAttribute(this, v89, [(NSArray *)v91 count], &v107);
          uint64_t v74 = v107;
          if (v107 != (uint64_t *)&v108)
          {
            unint64_t v75 = 0;
            do
            {
              if (v75 < [(id)v74[5] count])
              {
                objc_storeStrong((id *)a4 + 6, (id)v74[4]);
                unint64_t v75 = [(id)v74[5] count];
              }
              long long v76 = (id *)v74[1];
              if (v76)
              {
                do
                {
                  uint64_t v77 = v76;
                  long long v76 = (id *)*v76;
                }
                while (v76);
              }
              else
              {
                do
                {
                  uint64_t v77 = (id *)v74[2];
                  BOOL v31 = *v77 == v74;
                  uint64_t v74 = (uint64_t *)v77;
                }
                while (!v31);
              }
              uint64_t v74 = (uint64_t *)v77;
            }
            while (v77 != (id *)&v108);
          }
          unint64_t v78 = v108;
          uint64_t v79 = &v107;
        }
        else
        {
          objc_storeStrong((id *)a4 + 6, obj);
          v96[0] = 0;
          v96[1] = 0;
          v95 = v96;
          uint64_t v80 = v110;
          if (v110 != (uint64_t *)v111)
          {
            do
            {
              std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__emplace_hint_unique_key_args<objc_object * {__strong},std::pair<objc_object * const {__strong},NSMutableArray * {__strong}> const&>(&v95, v96, (unint64_t *)v80 + 4, (id *)v80 + 4);
              id v81 = (uint64_t *)v80[1];
              if (v81)
              {
                do
                {
                  int64_t v82 = v81;
                  id v81 = (uint64_t *)*v81;
                }
                while (v81);
              }
              else
              {
                do
                {
                  int64_t v82 = (uint64_t *)v80[2];
                  BOOL v31 = *v82 == (void)v80;
                  uint64_t v80 = v82;
                }
                while (!v31);
              }
              uint64_t v80 = v82;
            }
            while (v82 != (uint64_t *)v111);
          }
          GKCDecisionTree::splitOnIndex((uint64_t)this, (uint64_t)obj, v91, (uint64_t)&v95);
          unint64_t v78 = (uint64_t *)v96[0];
          uint64_t v79 = &v95;
        }
        std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)v79, v78);

        std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v110, v111[0]);
        goto LABEL_146;
      }
      id v19 = [v88 objectAtIndexedSubscript:v16];
      if ([v19 integerValue] <= 2)
      {
      }
      else
      {
        uint64_t v20 = [(NSArray *)v89 firstObject];
        float32x2_t v21 = [v20 objectAtIndexedSubscript:v16];
        objc_opt_class();
        char isKindOfClass = objc_opt_isKindOfClass();

        if (isKindOfClass)
        {
          GKCDecisionTree::multiwaySplitByAttributeValue(this, v89, v16, &v107);
          v104[0] = 0;
          v104[1] = 0;
          v103 = v104;
          uint64_t v23 = v107;
          if (v107 != (uint64_t *)&v108)
          {
            do
            {
              std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__emplace_hint_unique_key_args<objc_object * {__strong},std::pair<objc_object * const {__strong},NSMutableArray * {__strong}> const&>(&v103, v104, (unint64_t *)v23 + 4, (id *)v23 + 4);
              uint64_t v29 = (id *)v23[1];
              if (v29)
              {
                do
                {
                  uint64_t v30 = v29;
                  uint64_t v29 = (id *)*v29;
                }
                while (v29);
              }
              else
              {
                do
                {
                  uint64_t v30 = (id *)v23[2];
                  BOOL v31 = *v30 == v23;
                  uint64_t v23 = (uint64_t *)v30;
                }
                while (!v31);
              }
              uint64_t v23 = (uint64_t *)v30;
            }
            while (v30 != (id *)&v108);
          }
          GKCDecisionTree::continuousGiniSplit(this, &v103, (void **)&v105);
          std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v103, v104[0]);
          [v106 floatValue];
          float v25 = v24;
          GKCDecisionTree::splitOnValueOfAttribute(this, v89, v105, v16, &v100);
          std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v107, v108);
          uint64_t v107 = v100;
          unint64_t v108 = v101;
          uint64_t v109 = v102;
          if (v102)
          {
            v101[2] = (uint64_t)&v108;
            unint64_t v100 = v83;
            *uint64_t v83 = 0;
            v83[1] = 0;
            double v26 = v25;
            std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v100, 0);
            if (v17 > v26) {
              goto LABEL_16;
            }
LABEL_114:
            double v26 = v17;
            long long v28 = v107;
            if (v107 == (uint64_t *)&v108) {
              goto LABEL_115;
            }
          }
          else
          {
            uint64_t v107 = (uint64_t *)&v108;
            double v26 = v25;
            std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v100, v101);
            if (v17 <= v26) {
              goto LABEL_114;
            }
LABEL_16:
            uint64_t v27 = [(NSArray *)v91 objectAtIndexedSubscript:v16];

            obuint64_t j = (id)v27;
            std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__tree_node<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,void *> *,long>>(&v110, (id *)v107, (id *)&v108);
            long long v28 = v107;
            if (v107 == (uint64_t *)&v108)
            {
LABEL_115:
              uint64_t v68 = v105;
              uint64_t v105 = 0;

              id v69 = v106;
              id v106 = 0;

              std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v107, v108);
              double v17 = v26;
              ++v16;
              continue;
            }
          }
          do
          {
            uint64_t v70 = (uint64_t *)v28[1];
            uint64_t v71 = v28;
            if (v70)
            {
              do
              {
                long long v72 = v70;
                uint64_t v70 = (uint64_t *)*v70;
              }
              while (v70);
            }
            else
            {
              do
              {
                long long v72 = (uint64_t *)v71[2];
                BOOL v31 = *v72 == (void)v71;
                uint64_t v71 = v72;
              }
              while (!v31);
            }
            if (v107 == v28) {
              uint64_t v107 = v72;
            }
            --v109;
            std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v108, v28);

            operator delete(v28);
            long long v28 = v72;
          }
          while (v72 != (uint64_t *)&v108);
          goto LABEL_115;
        }
      }
      unint64_t v90 = v16;
      GKCDecisionTree::binarySplitByAttributeValue(this, v89, v16, (char **)&v107);
      uint64_t v32 = v107;
      long long v33 = v107;
      uint64_t v94 = v108;
      if (v107 == v108)
      {
        if (!v107) {
          goto LABEL_8;
        }
        goto LABEL_110;
      }
      while (2)
      {
        uint64_t v98 = 0;
        uint64_t v99 = 0;
        long long v97 = &v98;
        long long v34 = (id *)*v32;
        double v35 = 0.0;
        if ((uint64_t *)*v32 == v32 + 1) {
          goto LABEL_101;
        }
        uint64_t v36 = v99;
        do
        {
          uint64_t v37 = (void ***)&v98;
          if (v97 == &v98) {
            goto LABEL_40;
          }
          int32x2_t v38 = v98;
          uint64_t v39 = &v98;
          if (v98)
          {
            do
            {
              uint64_t v37 = (void ***)v38;
              int32x2_t v38 = (void *)v38[1];
            }
            while (v38);
          }
          else
          {
            do
            {
              uint64_t v37 = (void ***)v39[2];
              BOOL v31 = *v37 == v39;
              uint64_t v39 = v37;
            }
            while (v31);
          }
          uint64_t v40 = (void **)v34[4];
          if (v37[4] < v40)
          {
LABEL_40:
            if (v98) {
              uint64_t v41 = v37;
            }
            else {
              uint64_t v41 = &v98;
            }
            if (v98)
            {
              uint64_t v42 = v37 + 1;
            }
            else
            {
              uint64_t v37 = &v97;
              uint64_t v42 = &v98;
            }
            if (v37[1]) {
              goto LABEL_80;
            }
LABEL_55:
            double v45 = operator new(0x30uLL);
            v45[4] = v34[4];
            v45[5] = v34[5];
            void *v45 = 0;
            v45[1] = 0;
            v45[2] = v41;
            *uint64_t v42 = v45;
            if (*v97)
            {
              long long v97 = (void **)*v97;
              double v45 = (void *)*v42;
            }
            uint64_t v46 = v98;
            BOOL v31 = v45 == v98;
            *((unsigned char *)v45 + 24) = v45 == v98;
            if (!v31)
            {
              do
              {
                uint64_t v47 = v45[2];
                if (*(unsigned char *)(v47 + 24)) {
                  break;
                }
                unint64_t v48 = *(void **)(v47 + 16);
                uint64_t v49 = *v48;
                if (*v48 == v47)
                {
                  uint64_t v52 = v48[1];
                  if (!v52 || (v53 = *(unsigned __int8 *)(v52 + 24), uint64_t v50 = (unsigned char *)(v52 + 24), v53))
                  {
                    if (*(void **)v47 == v45)
                    {
                      *(unsigned char *)(v47 + 24) = 1;
                      *((unsigned char *)v48 + 24) = 0;
                      uint64_t v56 = *(void *)(v47 + 8);
                      *unint64_t v48 = v56;
                      if (v56) {
                        goto LABEL_72;
                      }
                    }
                    else
                    {
                      uint64_t v54 = *(uint64_t **)(v47 + 8);
                      uint64_t v55 = *v54;
                      *(void *)(v47 + 8) = *v54;
                      if (v55)
                      {
                        *(void *)(v55 + 16) = v47;
                        unint64_t v48 = *(void **)(v47 + 16);
                      }
                      v54[2] = (uint64_t)v48;
                      *(void *)(*(void *)(v47 + 16) + 8 * (**(void **)(v47 + 16) != v47)) = v54;
                      *uint64_t v54 = v47;
                      *(void *)(v47 + 16) = v54;
                      unint64_t v48 = (void *)v54[2];
                      uint64_t v47 = *v48;
                      *((unsigned char *)v54 + 24) = 1;
                      *((unsigned char *)v48 + 24) = 0;
                      uint64_t v56 = *(void *)(v47 + 8);
                      *unint64_t v48 = v56;
                      if (v56) {
LABEL_72:
                      }
                        *(void *)(v56 + 16) = v48;
                    }
                    *(void *)(v47 + 16) = v48[2];
                    *(void *)(v48[2] + 8 * (*(void *)v48[2] != (void)v48)) = v47;
                    *(void *)(v47 + 8) = v48;
LABEL_78:
                    v48[2] = v47;
                    break;
                  }
                }
                else if (!v49 || (v51 = *(unsigned __int8 *)(v49 + 24), uint64_t v50 = (unsigned char *)(v49 + 24), v51))
                {
                  if (*(void **)v47 == v45)
                  {
                    uint64_t v60 = v45[1];
                    *(void *)uint64_t v47 = v60;
                    if (v60)
                    {
                      *(void *)(v60 + 16) = v47;
                      unint64_t v48 = *(void **)(v47 + 16);
                    }
                    v45[2] = v48;
                    *(void *)(*(void *)(v47 + 16) + 8 * (**(void **)(v47 + 16) != v47)) = v45;
                    v45[1] = v47;
                    *(void *)(v47 + 16) = v45;
                    unint64_t v48 = (void *)v45[2];
                    *((unsigned char *)v45 + 24) = 1;
                    *((unsigned char *)v48 + 24) = 0;
                    uint64_t v47 = v48[1];
                    int64_t v57 = *(void **)v47;
                    v48[1] = *(void *)v47;
                    if (v57) {
LABEL_76:
                    }
                      v57[2] = v48;
                  }
                  else
                  {
                    *(unsigned char *)(v47 + 24) = 1;
                    *((unsigned char *)v48 + 24) = 0;
                    uint64_t v47 = v48[1];
                    int64_t v57 = *(void **)v47;
                    v48[1] = *(void *)v47;
                    if (v57) {
                      goto LABEL_76;
                    }
                  }
                  *(void *)(v47 + 16) = v48[2];
                  *(void *)(v48[2] + 8 * (*(void *)v48[2] != (void)v48)) = v47;
                  *(void *)uint64_t v47 = v48;
                  goto LABEL_78;
                }
                *(unsigned char *)(v47 + 24) = 1;
                double v45 = v48;
                *((unsigned char *)v48 + 24) = v48 == v46;
                *uint64_t v50 = 1;
              }
              while (v48 != v46);
            }
            uint64_t v99 = ++v36;
            goto LABEL_80;
          }
          uint64_t v42 = &v98;
          uint64_t v41 = &v98;
          if (!v98) {
            goto LABEL_55;
          }
          unint64_t v43 = v98;
          while (1)
          {
            while (1)
            {
              uint64_t v41 = (void **)v43;
              unint64_t v44 = v43[4];
              if ((unint64_t)v40 >= v44) {
                break;
              }
              unint64_t v43 = *v41;
              uint64_t v42 = v41;
              if (!*v41) {
                goto LABEL_55;
              }
            }
            if (v44 >= (unint64_t)v40) {
              break;
            }
            unint64_t v43 = v41[1];
            if (!v43)
            {
              uint64_t v42 = v41 + 1;
              goto LABEL_55;
            }
          }
LABEL_80:
          uint64_t v58 = (id *)v34[1];
          if (v58)
          {
            do
            {
              unint64_t v59 = (id **)v58;
              uint64_t v58 = (id *)*v58;
            }
            while (v58);
          }
          else
          {
            do
            {
              unint64_t v59 = (id **)v34[2];
              BOOL v31 = *v59 == v34;
              long long v34 = (id *)v59;
            }
            while (!v31);
          }
          long long v34 = (id *)v59;
        }
        while (v59 != (id **)(v32 + 1));
        unint64_t v61 = v97;
        this = v92;
        if (v97 != &v98)
        {
          double v35 = 0.0;
          do
          {
            unint64_t v62 = [v61[5] count];
            double v63 = GKCDecisionTree::giniImpurity(v92, (NSArray *)v61[5]);
            unint64_t v64 = v61[1];
            if (v64)
            {
              do
              {
                uint64_t v65 = (void **)v64;
                unint64_t v64 = (void *)*v64;
              }
              while (v64);
            }
            else
            {
              do
              {
                uint64_t v65 = (void **)v61[2];
                BOOL v31 = *v65 == v61;
                unint64_t v61 = v65;
              }
              while (!v31);
            }
            double v35 = v35 + v63 * (double)v62 * (1.0 / (double)v87);
            unint64_t v61 = v65;
          }
          while (v65 != &v98);
        }
LABEL_101:
        std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v97, v98);
        if (v35 < v17)
        {
          uint64_t v66 = [(NSArray *)v91 objectAtIndexedSubscript:v90];

          obuint64_t j = (id)v66;
          if (&v110 != (uint64_t **)v32) {
            std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__tree_node<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,void *> *,long>>(&v110, (id *)*v32, (id *)v32 + 1);
          }
          double v17 = v35;
        }
        v32 += 3;
        if (v32 != v94) {
          continue;
        }
        break;
      }
      uint64_t v67 = v107;
      uint64_t v32 = v108;
      if (v107 == v108)
      {
        long long v33 = v108;
        if (!v108) {
          goto LABEL_8;
        }
      }
      else
      {
        do
        {
          std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)(v32 - 3), (void *)*(v32 - 2));
          v32 -= 3;
        }
        while (v32 != v67);
        unint64_t v108 = v67;
        long long v33 = v107;
        uint64_t v32 = v67;
        if (!v107) {
          goto LABEL_8;
        }
      }
LABEL_110:
      if (v32 != v33)
      {
        do
        {
          std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)(v32 - 3), (void *)*(v32 - 2));
          v32 -= 3;
        }
        while (v32 != v33);
        uint64_t v32 = v107;
      }
      unint64_t v108 = v33;
      operator delete(v32);
LABEL_8:
      unint64_t v16 = v90 + 1;
    }
  }
  uint64_t v12 = [(NSArray *)v8 firstObject];
  uint64_t v13 = [v12 lastObject];

  if (v13)
  {
    uint64_t v14 = [v12 lastObject];
    size_t v15 = (void *)*((void *)a4 + 6);
    *((void *)a4 + 6) = v14;
  }
LABEL_146:
}

void sub_235EDA778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, void *a20,uint64_t a21,void *a22,uint64_t a23,char a24,void *a25)
{
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&a24, a25);

  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(v25 - 144, *(void **)(v25 - 136));
  _Unwind_Resume(a1);
}

void sub_235EDAA34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDAA4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDAB34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDAB4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDAB60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDAC00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDAC10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GKCDecisionTree::findActionForAnswers(uint64_t **a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *a1;
  BOOL v5 = *a1 + 1;
  if (*v5 == **a1) {
    goto LABEL_19;
  }
  while (2)
  {
    unint64_t v6 = (void *)v4[8];
    if (v6)
    {
      uint64_t v7 = [v6 nextInt];
    }
    else
    {
      if (!v3) {
        goto LABEL_19;
      }
      uint64_t v7 = 0;
      if (![v3 count]) {
        goto LABEL_19;
      }
    }
    uint64_t v8 = *v4;
    uint64_t v9 = *v5;
    if (*v4 == *v5)
    {
LABEL_19:
      id v17 = 0;
      goto LABEL_20;
    }
    while (1)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        [*(id *)v8 allowEvaluation];
        id v11 = *(id *)v8;
        uint64_t v12 = [v3 objectForKeyedSubscript:v4[6]];
        int v13 = [v11 evaluateWithObject:v12];
        goto LABEL_8;
      }
      id v14 = *(id *)v8;
      if (v4[8]) {
        break;
      }
      uint64_t v12 = [v3 objectForKeyedSubscript:v4[6]];
      int v13 = [v14 isEqual:v12];
LABEL_8:
      int v10 = v13;

      if (v10) {
        goto LABEL_17;
      }
LABEL_9:
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_19;
      }
    }
    uint64_t v15 = [*(id *)v8 integerValue];
    BOOL v16 = v7 <= v15;
    v7 -= v15;
    if (!v16) {
      goto LABEL_9;
    }
LABEL_17:
    uint64_t v4 = *(uint64_t **)(v8 + 8);
    if (v4[1] != *v4)
    {
      BOOL v5 = v4 + 1;
      continue;
    }
    break;
  }
  id v17 = (id)v4[6];
LABEL_20:

  return v17;
}

void sub_235EDADB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDADC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDADD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDADE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDADF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDB0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

__CFString *GKCDecisionTree::printTree(GKCDecisionTree *this, GKCDecisionNode *a2, NSString *a3, NSString *a4)
{
  uint64_t v7 = a3;
  p_isa = a4;
  if (a2)
  {
    if ([(NSString *)v7 isEqualToString:@"\t"])
    {
      uint64_t v9 = [NSString stringWithFormat:@"\n%@(depth:%lu, ex:%lu)\n", *((void *)a2 + 6), *((void *)a2 + 4), *((void *)a2 + 5)];

      p_isa = (NSString *)v9;
    }
    id v11 = *(void **)a2;
    int v10 = (void *)*((void *)a2 + 1);
    if (*(void **)a2 == v10)
    {
      uint64_t v12 = (__CFString *)p_isa;
    }
    else
    {
      do
      {
        int v13 = (GKCDecisionNode *)v11[1];
        id v14 = [NSString stringWithFormat:@"%@\t", v7];
        if (v13)
        {
          uint64_t v15 = [NSString stringWithFormat:@"%@%@%@, %@(depth:%lu, ex:%lu)\n", p_isa, v7, *v11, *(void *)(v11[1] + 48), *(void *)(v11[1] + 32), *(void *)(v11[1] + 40)];
          GKCDecisionTree::printTree(this, v13, v14, v15);
          uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          uint64_t v15 = [NSString stringWithFormat:@"%@%@%@\n", p_isa, v7, *v11];
          uint64_t v12 = &stru_26E943AF0;
        }

        v11 += 2;
        p_isa = &v12->isa;
      }
      while (v11 != v10);
    }
    p_isa = v12;
    BOOL v16 = (__CFString *)p_isa;
  }
  else
  {
    BOOL v16 = &stru_26E943AF0;
  }

  return v16;
}

void sub_235EDB380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDB394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDB3AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDB3C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDB3E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GKCDecisionNode::nodeData(GKCDecisionNode *this, objc_object *a2)
{
  v11[3] = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  [v4 setObject:*((void *)this + 6) forKeyedSubscript:@"attribute"];
  BOOL v5 = (void *)*((void *)this + 8);
  if (v5)
  {
    unint64_t v6 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v5, "lowestValue"));
    uint64_t v7 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*((id *)this + 8), "highestValue", v6));
    uint64_t v8 = *((void *)this + 9);
    v11[1] = v7;
    v11[2] = v8;
    uint64_t v9 = [MEMORY[0x263EFF8C0] arrayWithObjects:v11 count:3];
    [v4 setObject:v9 forKeyedSubscript:@"randomDistribution"];
  }
  [v4 setObject:v3 forKeyedSubscript:@"branch"];
  [v4 setObject:*((void *)this + 7) forKeyedSubscript:@"branchValue"];

  return v4;
}

void sub_235EDB5C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCDecisionNode::~GKCDecisionNode(GKCDecisionNode *this)
{
  uint64_t v2 = (void *)*((void *)this + 6);
  *((void *)this + 6) = 0;

  id v3 = (void *)*((void *)this + 8);
  *((void *)this + 8) = 0;

  id v4 = (void *)*((void *)this + 9);
  *((void *)this + 9) = 0;

  BOOL v5 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;

  *((void *)this + 3) = 0;
  unint64_t v6 = *(char **)this;
  uint64_t v7 = (char *)*((void *)this + 1);
  if (*(char **)this != v7)
  {
    do
    {
      uint64_t v8 = (GKCDecisionNode *)*((void *)v6 + 1);
      if (v8)
      {
        GKCDecisionNode::~GKCDecisionNode(v8);
        MEMORY[0x237DF7CA0]();
      }
      v6 += 16;
    }
    while (v6 != v7);
    uint64_t v9 = *(char **)this;
    int v10 = (char *)*((void *)this + 1);
    if (*(char **)this != v10)
    {
      while (v10 != v9)
      {
        id v11 = (void *)*((void *)v10 - 2);
        v10 -= 16;
      }
      *((void *)this + 1) = v9;
    }
  }

  uint64_t v12 = *(char **)this;
  if (*(void *)this)
  {
    int v13 = (char *)*((void *)this + 1);
    id v14 = *(char **)this;
    if (v13 != v12)
    {
      do
      {
        uint64_t v15 = (void *)*((void *)v13 - 2);
        v13 -= 16;
      }
      while (v13 != v12);
      id v14 = *(char **)this;
    }
    *((void *)this + 1) = v12;
    operator delete(v14);
  }
}

double GKCDecisionTree::giniImpurity(GKCDecisionTree *this, NSArray *a2)
{
  id v3 = a2;
  id v4 = [(NSArray *)v3 firstObject];
  GKCDecisionTree::splitByAttribute(this, v3, [v4 count] - 1, &v14);

  unint64_t v5 = [(NSArray *)v3 count];
  double v6 = 0.0;
  if (v5 && v15[1] != (void *)1)
  {
    uint64_t v7 = v14;
    if (v14 == v15)
    {
      double v6 = 1.0;
    }
    else
    {
      double v6 = 1.0;
      double v8 = 1.0 / (double)v5;
      do
      {
        unint64_t v9 = [(id)v7[5] count];
        int v10 = (void *)v7[1];
        if (v10)
        {
          do
          {
            id v11 = (void **)v10;
            int v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            id v11 = (void **)v7[2];
            BOOL v12 = *v11 == v7;
            uint64_t v7 = v11;
          }
          while (!v12);
        }
        double v6 = v6 - (double)v9 * v8 * ((double)v9 * v8);
        uint64_t v7 = v11;
      }
      while (v11 != v15);
    }
  }
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v14, v15[0]);

  return v6;
}

void sub_235EDB88C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&a10, a11);

  _Unwind_Resume(a1);
}

id GKCDecisionTree::getAttributeCounts(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  double v6 = objc_msgSend(objc_alloc(MEMORY[0x263EFF980]), "initWithCapacity:", objc_msgSend(v4, "count"));
  unint64_t v7 = 0;
  uint64_t v8 = MEMORY[0x263EFFA88];
  while ([v4 count] > v7)
  {
    unint64_t v9 = objc_msgSend(objc_alloc(MEMORY[0x263EFF9A0]), "initWithCapacity:", objc_msgSend(v5, "count"));
    for (unint64_t i = 0; [v5 count] > i; ++i)
    {
      id v11 = [v5 objectAtIndexedSubscript:i];
      BOOL v12 = [v11 objectAtIndexedSubscript:v7];

      int v13 = [v9 objectForKeyedSubscript:v12];

      if (!v13) {
        [v9 setObject:v8 forKeyedSubscript:v12];
      }
    }
    id v14 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v9, "count"));
    [v6 setObject:v14 atIndexedSubscript:v7];

    ++v7;
  }

  return v6;
}

void sub_235EDBA64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDBA78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDBA98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDBAB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EDBB0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCDecisionTree::multiwaySplitByAttributeValue(GKCDecisionTree *this@<X0>, NSArray *a2@<X1>, uint64_t a3@<X2>, uint64_t **a4@<X8>)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  double v6 = a2;
  a4[1] = 0;
  unint64_t v7 = a4 + 1;
  a4[2] = 0;
  *a4 = (uint64_t *)(a4 + 1);
  long long v28 = v6;
  uint64_t v29 = objc_opt_new();
  for (unint64_t i = 0; [(NSArray *)v6 count] > i; ++i)
  {
    unint64_t v9 = [(NSArray *)v6 objectAtIndexedSubscript:i];
    int v10 = [v9 objectAtIndexedSubscript:a3];

    id v11 = [v29 objectForKey:v10];

    if (v11)
    {
      BOOL v12 = [v29 objectForKey:v10];
      int v13 = [(NSArray *)v6 objectAtIndexedSubscript:i];
      [v12 addObject:v13];
    }
    else
    {
      id v14 = objc_alloc(MEMORY[0x263EFF980]);
      BOOL v12 = [(NSArray *)v6 objectAtIndexedSubscript:i];
      int v13 = objc_msgSend(v14, "initWithObjects:", v12, 0, v28);
      [v29 setObject:v13 forKey:v10];
    }
  }
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  id v15 = v29;
  uint64_t v16 = [v15 countByEnumeratingWithState:&v31 objects:v35 count:16];
  if (v16)
  {
    uint64_t v30 = *(void *)v32;
    do
    {
      for (uint64_t j = 0; j != v16; ++j)
      {
        if (*(void *)v32 != v30) {
          objc_enumerationMutation(v15);
        }
        unint64_t v18 = *(void **)(*((void *)&v31 + 1) + 8 * j);
        uint64_t v19 = [v15 objectForKey:v18];
        uint64_t v20 = *v7;
        float32x2_t v21 = a4 + 1;
        float32x2_t v22 = a4 + 1;
        if (*v7)
        {
          while (1)
          {
            while (1)
            {
              float32x2_t v22 = (uint64_t **)v20;
              unint64_t v23 = v20[4];
              if ((unint64_t)v18 >= v23) {
                break;
              }
              uint64_t v20 = *v22;
              float32x2_t v21 = v22;
              if (!*v22) {
                goto LABEL_19;
              }
            }
            if (v23 >= (unint64_t)v18) {
              break;
            }
            uint64_t v20 = v22[1];
            if (!v20)
            {
              float32x2_t v21 = v22 + 1;
              goto LABEL_19;
            }
          }
          float v24 = (uint64_t *)v22;
        }
        else
        {
LABEL_19:
          float v24 = (uint64_t *)operator new(0x30uLL);
          v24[4] = (uint64_t)v18;
          v24[5] = 0;
          uint64_t *v24 = 0;
          v24[1] = 0;
          v24[2] = (uint64_t)v22;
          *float32x2_t v21 = v24;
          uint64_t v25 = (uint64_t *)**a4;
          double v26 = v24;
          if (v25)
          {
            *a4 = v25;
            double v26 = *v21;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a4[1], v26);
          a4[2] = (uint64_t *)((char *)a4[2] + 1);
        }
        uint64_t v27 = (void *)v24[5];
        v24[5] = v19;
      }
      uint64_t v16 = [v15 countByEnumeratingWithState:&v31 objects:v35 count:16];
    }
    while (v16);
  }
}

void sub_235EDBE14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(v12, *(void **)(v12 + 8));
  _Unwind_Resume(a1);
}

void GKCDecisionTree::continuousGiniSplit(GKCDecisionTree *a1@<X0>, void *a2@<X1>, void **a3@<X8>)
{
  v441[0] = 0;
  v441[1] = 0;
  v440 = v441;
  id v4 = a2 + 1;
  id v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__emplace_hint_unique_key_args<objc_object * {__strong},std::pair<objc_object * const {__strong},NSMutableArray * {__strong}> const&>(&v440, v441, v5 + 4, (id *)v5 + 4);
      int v13 = (void *)v5[1];
      if (v13)
      {
        do
        {
          id v14 = v13;
          int v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          id v14 = (void *)v5[2];
          BOOL v15 = *v14 == (void)v5;
          id v5 = v14;
        }
        while (!v15);
      }
      id v5 = v14;
    }
    while (v14 != v4);
  }
  GKCDecisionTree::sortByAttributeWithAction((uint64_t)a1, &v440);
  double v6 = (NSArray *)objc_claimAutoreleasedReturnValue();
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v440, v441[0]);
  v438 = 0;
  uint64_t v439 = 0;
  v437 = &v438;
  v429 = v6;
  unint64_t v7 = [(NSArray *)v6 firstObject];
  GKCDecisionTree::splitByAttribute(a1, v6, [v7 count] - 1, &v434);

  id v8 = objc_alloc(MEMORY[0x263EFF980]);
  v430 = (void *)[v8 initWithCapacity:v436];
  v432 = 0;
  uint64_t v433 = 0;
  v431 = &v432;
  id v9 = objc_alloc(MEMORY[0x263EFF980]);
  uint64_t v10 = [v9 initWithCapacity:v436];
  id v11 = v432;
  uint64_t v12 = &v432;
LABEL_11:
  uint64_t v16 = v12;
  if (v11)
  {
    while (1)
    {
      uint64_t v12 = (uint64_t **)v11;
      unint64_t v17 = v11[4];
      if (v17 > (unint64_t)@"<=")
      {
        id v11 = *v12;
        goto LABEL_11;
      }
      if (v17 >= (unint64_t)@"<=") {
        break;
      }
      id v11 = v12[1];
      if (!v11)
      {
        uint64_t v16 = v12 + 1;
        goto LABEL_16;
      }
    }
    unint64_t v18 = (uint64_t *)v12;
  }
  else
  {
LABEL_16:
    unint64_t v18 = (uint64_t *)operator new(0x30uLL);
    v18[4] = @"<=";
    v18[5] = 0;
    uint64_t *v18 = 0;
    v18[1] = 0;
    v18[2] = (uint64_t)v12;
    __CFString *v16 = v18;
    uint64_t v19 = v18;
    if (*v431)
    {
      v431 = (uint64_t **)*v431;
      uint64_t v19 = *v16;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v432, v19);
    ++v433;
  }
  uint64_t v20 = (void *)v18[5];
  v18[5] = v10;

  id v21 = objc_alloc(MEMORY[0x263EFF980]);
  uint64_t v22 = [v21 initWithCapacity:v436];
  unint64_t v23 = v432;
  float v24 = &v432;
LABEL_22:
  uint64_t v25 = v24;
  if (v23)
  {
    while (1)
    {
      float v24 = (uint64_t **)v23;
      unint64_t v26 = v23[4];
      if (v26 > (unint64_t)@">")
      {
        unint64_t v23 = *v24;
        goto LABEL_22;
      }
      if (v26 >= (unint64_t)@">") {
        break;
      }
      unint64_t v23 = v24[1];
      if (!v23)
      {
        uint64_t v25 = v24 + 1;
        goto LABEL_27;
      }
    }
    uint64_t v27 = (uint64_t *)v24;
  }
  else
  {
LABEL_27:
    uint64_t v27 = (uint64_t *)operator new(0x30uLL);
    v27[4] = @">";
    v27[5] = 0;
    *uint64_t v27 = 0;
    v27[1] = 0;
    v27[2] = (uint64_t)v24;
    uint64_t *v25 = v27;
    long long v28 = v27;
    if (*v431)
    {
      v431 = (uint64_t **)*v431;
      long long v28 = *v25;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v432, v28);
    ++v433;
  }
  uint64_t v29 = (void *)v27[5];
  v27[5] = v22;

  for (unint64_t i = 0; [(NSArray *)v6 count] >= i; ++i)
  {
    if (i)
    {
      if ([(NSArray *)v6 count] == i)
      {
        long long v31 = [(NSArray *)v6 objectAtIndexedSubscript:i - 2];
        v426 = [v31 firstObject];

        long long v32 = [(NSArray *)v6 objectAtIndexedSubscript:i - 1];
        long long v33 = [v32 firstObject];

        v425 = v33;
        [v33 floatValue];
        float v35 = v34;
        [v426 floatValue];
        float v37 = v36;
        int32x2_t v38 = NSNumber;
        [v33 floatValue];
        *(float *)&double v40 = v39 + (float)((float)(v35 - v37) * 0.5);
        v428 = [v38 numberWithFloat:v40];
        uint64_t v41 = v434;
        if (v434 != &v435)
        {
          uint64_t v42 = 0;
          do
          {
            unint64_t v43 = (void *)v41[4];
            unint64_t v44 = [(NSArray *)v6 objectAtIndexedSubscript:i - 1];
            double v45 = [v44 lastObject];
            LODWORD(v43) = [v43 isEqual:v45];

            if (v43)
            {
              uint64_t v46 = NSNumber;
              uint64_t v47 = [v430 objectAtIndexedSubscript:v42];
              unint64_t v48 = objc_msgSend(v46, "numberWithInteger:", objc_msgSend(v47, "integerValue") + 1);
              [v430 setObject:v48 atIndexedSubscript:v42];
            }
            else
            {
              uint64_t v47 = [v430 objectAtIndexedSubscript:v42];
              [v430 setObject:v47 atIndexedSubscript:v42];
            }

            uint64_t v49 = [v430 objectAtIndexedSubscript:v42];
            uint64_t v50 = v432;
            int v51 = &v432;
LABEL_45:
            uint64_t v52 = v51;
            if (v50)
            {
              while (1)
              {
                int v51 = (uint64_t **)v50;
                unint64_t v53 = v50[4];
                if (v53 > (unint64_t)@"<=")
                {
                  uint64_t v50 = *v51;
                  goto LABEL_45;
                }
                if (v53 >= (unint64_t)@"<=") {
                  break;
                }
                uint64_t v50 = v51[1];
                if (!v50)
                {
                  uint64_t v52 = v51 + 1;
                  goto LABEL_50;
                }
              }
              uint64_t v54 = v51;
            }
            else
            {
LABEL_50:
              uint64_t v54 = operator new(0x30uLL);
              *((void *)v54 + 4) = @"<=";
              *((void *)v54 + 5) = 0;
              *(void *)uint64_t v54 = 0;
              *((void *)v54 + 1) = 0;
              *((void *)v54 + 2) = v51;
              *uint64_t v52 = (uint64_t *)v54;
              uint64_t v55 = (uint64_t *)v54;
              if (*v431)
              {
                v431 = (uint64_t **)*v431;
                uint64_t v55 = *v52;
              }
              uint64_t v56 = v432;
              BOOL v15 = v55 == v432;
              *((unsigned char *)v55 + 24) = v55 == v432;
              if (!v15)
              {
                do
                {
                  uint64_t v57 = v55[2];
                  if (*(unsigned char *)(v57 + 24)) {
                    break;
                  }
                  uint64_t v58 = *(uint64_t **)(v57 + 16);
                  uint64_t v59 = *v58;
                  if (*v58 == v57)
                  {
                    uint64_t v62 = v58[1];
                    if (!v62 || (v63 = *(unsigned __int8 *)(v62 + 24), uint64_t v60 = (unsigned char *)(v62 + 24), v63))
                    {
                      if (*(uint64_t **)v57 == v55)
                      {
                        *(unsigned char *)(v57 + 24) = 1;
                        *((unsigned char *)v58 + 24) = 0;
                        uint64_t v66 = *(void *)(v57 + 8);
                        *uint64_t v58 = v66;
                        if (v66) {
                          goto LABEL_67;
                        }
                      }
                      else
                      {
                        unint64_t v64 = *(uint64_t **)(v57 + 8);
                        uint64_t v65 = *v64;
                        *(void *)(v57 + 8) = *v64;
                        if (v65)
                        {
                          *(void *)(v65 + 16) = v57;
                          uint64_t v58 = *(uint64_t **)(v57 + 16);
                        }
                        v64[2] = (uint64_t)v58;
                        *(void *)(*(void *)(v57 + 16) + 8 * (**(void **)(v57 + 16) != v57)) = v64;
                        *unint64_t v64 = v57;
                        *(void *)(v57 + 16) = v64;
                        uint64_t v58 = (uint64_t *)v64[2];
                        uint64_t v57 = *v58;
                        *((unsigned char *)v64 + 24) = 1;
                        *((unsigned char *)v58 + 24) = 0;
                        uint64_t v66 = *(void *)(v57 + 8);
                        *uint64_t v58 = v66;
                        if (v66) {
LABEL_67:
                        }
                          *(void *)(v66 + 16) = v58;
                      }
                      *(void *)(v57 + 16) = v58[2];
                      *(void *)(v58[2] + 8 * (*(void *)v58[2] != (void)v58)) = v57;
                      *(void *)(v57 + 8) = v58;
LABEL_74:
                      v58[2] = v57;
                      break;
                    }
                  }
                  else if (!v59 || (v61 = *(unsigned __int8 *)(v59 + 24), uint64_t v60 = (unsigned char *)(v59 + 24), v61))
                  {
                    if (*(uint64_t **)v57 == v55)
                    {
                      uint64_t v92 = v55[1];
                      *(void *)uint64_t v57 = v92;
                      if (v92)
                      {
                        *(void *)(v92 + 16) = v57;
                        uint64_t v58 = *(uint64_t **)(v57 + 16);
                      }
                      v55[2] = (uint64_t)v58;
                      *(void *)(*(void *)(v57 + 16) + 8 * (**(void **)(v57 + 16) != v57)) = v55;
                      v55[1] = v57;
                      *(void *)(v57 + 16) = v55;
                      uint64_t v58 = (uint64_t *)v55[2];
                      *((unsigned char *)v55 + 24) = 1;
                      *((unsigned char *)v58 + 24) = 0;
                      uint64_t v57 = v58[1];
                      uint64_t v67 = *(uint64_t **)v57;
                      v58[1] = *(void *)v57;
                      if (v67) {
LABEL_72:
                      }
                        v67[2] = (uint64_t)v58;
                    }
                    else
                    {
                      *(unsigned char *)(v57 + 24) = 1;
                      *((unsigned char *)v58 + 24) = 0;
                      uint64_t v57 = v58[1];
                      uint64_t v67 = *(uint64_t **)v57;
                      v58[1] = *(void *)v57;
                      if (v67) {
                        goto LABEL_72;
                      }
                    }
                    *(void *)(v57 + 16) = v58[2];
                    *(void *)(v58[2] + 8 * (*(void *)v58[2] != (void)v58)) = v57;
                    *(void *)uint64_t v57 = v58;
                    goto LABEL_74;
                  }
                  *(unsigned char *)(v57 + 24) = 1;
                  uint64_t v55 = v58;
                  *((unsigned char *)v58 + 24) = v58 == v56;
                  *uint64_t v60 = 1;
                }
                while (v58 != v56);
              }
              ++v433;
            }
            [*((id *)v54 + 5) setObject:v49 atIndexedSubscript:v42];

            uint64_t v68 = NSNumber;
            uint64_t v69 = [(id)v41[5] count];
            uint64_t v70 = [v430 objectAtIndexedSubscript:v42];
            uint64_t v71 = objc_msgSend(v68, "numberWithUnsignedInteger:", v69 - objc_msgSend(v70, "integerValue"));
            long long v72 = v432;
            BOOL v73 = &v432;
LABEL_78:
            uint64_t v74 = v73;
            if (v72)
            {
              while (1)
              {
                BOOL v73 = (uint64_t **)v72;
                unint64_t v75 = v72[4];
                if (v75 > (unint64_t)@">")
                {
                  long long v72 = *v73;
                  goto LABEL_78;
                }
                if (v75 >= (unint64_t)@">") {
                  break;
                }
                long long v72 = v73[1];
                if (!v72)
                {
                  uint64_t v74 = v73 + 1;
                  goto LABEL_83;
                }
              }
              long long v76 = v73;
            }
            else
            {
LABEL_83:
              long long v76 = operator new(0x30uLL);
              *((void *)v76 + 4) = @">";
              *((void *)v76 + 5) = 0;
              *(void *)long long v76 = 0;
              *((void *)v76 + 1) = 0;
              *((void *)v76 + 2) = v73;
              *uint64_t v74 = (uint64_t *)v76;
              uint64_t v77 = (uint64_t *)v76;
              if (*v431)
              {
                v431 = (uint64_t **)*v431;
                uint64_t v77 = *v74;
              }
              unint64_t v78 = v432;
              BOOL v15 = v77 == v432;
              *((unsigned char *)v77 + 24) = v77 == v432;
              if (!v15)
              {
                do
                {
                  uint64_t v79 = v77[2];
                  if (*(unsigned char *)(v79 + 24)) {
                    break;
                  }
                  uint64_t v80 = *(uint64_t **)(v79 + 16);
                  uint64_t v81 = *v80;
                  if (*v80 == v79)
                  {
                    uint64_t v84 = v80[1];
                    if (!v84 || (v85 = *(unsigned __int8 *)(v84 + 24), int64_t v82 = (unsigned char *)(v84 + 24), v85))
                    {
                      if (*(uint64_t **)v79 == v77)
                      {
                        *(unsigned char *)(v79 + 24) = 1;
                        *((unsigned char *)v80 + 24) = 0;
                        uint64_t v88 = *(void *)(v79 + 8);
                        *uint64_t v80 = v88;
                        if (v88) {
                          goto LABEL_100;
                        }
                      }
                      else
                      {
                        unint64_t v86 = *(uint64_t **)(v79 + 8);
                        uint64_t v87 = *v86;
                        *(void *)(v79 + 8) = *v86;
                        if (v87)
                        {
                          *(void *)(v87 + 16) = v79;
                          uint64_t v80 = *(uint64_t **)(v79 + 16);
                        }
                        v86[2] = (uint64_t)v80;
                        *(void *)(*(void *)(v79 + 16) + 8 * (**(void **)(v79 + 16) != v79)) = v86;
                        *unint64_t v86 = v79;
                        *(void *)(v79 + 16) = v86;
                        uint64_t v80 = (uint64_t *)v86[2];
                        uint64_t v79 = *v80;
                        *((unsigned char *)v86 + 24) = 1;
                        *((unsigned char *)v80 + 24) = 0;
                        uint64_t v88 = *(void *)(v79 + 8);
                        *uint64_t v80 = v88;
                        if (v88) {
LABEL_100:
                        }
                          *(void *)(v88 + 16) = v80;
                      }
                      *(void *)(v79 + 16) = v80[2];
                      *(void *)(v80[2] + 8 * (*(void *)v80[2] != (void)v80)) = v79;
                      *(void *)(v79 + 8) = v80;
LABEL_107:
                      v80[2] = v79;
                      break;
                    }
                  }
                  else if (!v81 || (v83 = *(unsigned __int8 *)(v81 + 24), int64_t v82 = (unsigned char *)(v81 + 24), v83))
                  {
                    if (*(uint64_t **)v79 == v77)
                    {
                      uint64_t v93 = v77[1];
                      *(void *)uint64_t v79 = v93;
                      if (v93)
                      {
                        *(void *)(v93 + 16) = v79;
                        uint64_t v80 = *(uint64_t **)(v79 + 16);
                      }
                      v77[2] = (uint64_t)v80;
                      *(void *)(*(void *)(v79 + 16) + 8 * (**(void **)(v79 + 16) != v79)) = v77;
                      v77[1] = v79;
                      *(void *)(v79 + 16) = v77;
                      uint64_t v80 = (uint64_t *)v77[2];
                      *((unsigned char *)v77 + 24) = 1;
                      *((unsigned char *)v80 + 24) = 0;
                      uint64_t v79 = v80[1];
                      unint64_t v89 = *(uint64_t **)v79;
                      v80[1] = *(void *)v79;
                      if (v89) {
LABEL_105:
                      }
                        v89[2] = (uint64_t)v80;
                    }
                    else
                    {
                      *(unsigned char *)(v79 + 24) = 1;
                      *((unsigned char *)v80 + 24) = 0;
                      uint64_t v79 = v80[1];
                      unint64_t v89 = *(uint64_t **)v79;
                      v80[1] = *(void *)v79;
                      if (v89) {
                        goto LABEL_105;
                      }
                    }
                    *(void *)(v79 + 16) = v80[2];
                    *(void *)(v80[2] + 8 * (*(void *)v80[2] != (void)v80)) = v79;
                    *(void *)uint64_t v79 = v80;
                    goto LABEL_107;
                  }
                  *(unsigned char *)(v79 + 24) = 1;
                  uint64_t v77 = v80;
                  *((unsigned char *)v80 + 24) = v80 == v78;
                  *int64_t v82 = 1;
                }
                while (v80 != v78);
              }
              ++v433;
            }
            [*((id *)v76 + 5) setObject:v71 atIndexedSubscript:v42];

            unint64_t v90 = (void *)v41[1];
            if (v90)
            {
              do
              {
                uint64_t v91 = (void **)v90;
                unint64_t v90 = (void *)*v90;
              }
              while (v90);
            }
            else
            {
              do
              {
                uint64_t v91 = (void **)v41[2];
                BOOL v15 = *v91 == v41;
                uint64_t v41 = v91;
              }
              while (!v15);
            }
            ++v42;
            uint64_t v41 = v91;
          }
          while (v91 != &v435);
        }
      }
      else
      {
        float v151 = [(NSArray *)v6 objectAtIndexedSubscript:i - 1];
        v426 = [v151 firstObject];

        v152 = [(NSArray *)v6 objectAtIndexedSubscript:i];
        float v153 = [v152 firstObject];

        v425 = v153;
        [v153 floatValue];
        float v155 = v154;
        [v426 floatValue];
        float v157 = v156;
        unint64_t v158 = NSNumber;
        [v153 floatValue];
        *(float *)&double v160 = v159 + (float)((float)(v157 - v155) * 0.5);
        v428 = [v158 numberWithFloat:v160];
        unint64_t v161 = v434;
        if (v434 != &v435)
        {
          uint64_t v162 = 0;
          do
          {
            uint64_t v163 = (void *)v161[4];
            float v164 = [(NSArray *)v6 objectAtIndexedSubscript:i - 1];
            float v165 = [v164 lastObject];
            LODWORD(v163) = [v163 isEqual:v165];

            if (v163)
            {
              float v166 = NSNumber;
              float v167 = [v430 objectAtIndexedSubscript:v162];
              uint64_t v168 = objc_msgSend(v166, "numberWithInteger:", objc_msgSend(v167, "integerValue") + 1);
              [v430 setObject:v168 atIndexedSubscript:v162];
            }
            else
            {
              float v167 = [v430 objectAtIndexedSubscript:v162];
              [v430 setObject:v167 atIndexedSubscript:v162];
            }

            int64_t v169 = [v430 objectAtIndexedSubscript:v162];
            uint64_t v170 = v432;
            unint64_t v171 = &v432;
LABEL_222:
            uint64_t v172 = v171;
            if (v170)
            {
              while (1)
              {
                unint64_t v171 = (uint64_t **)v170;
                unint64_t v173 = v170[4];
                if (v173 > (unint64_t)@"<=")
                {
                  uint64_t v170 = *v171;
                  goto LABEL_222;
                }
                if (v173 >= (unint64_t)@"<=") {
                  break;
                }
                uint64_t v170 = v171[1];
                if (!v170)
                {
                  uint64_t v172 = v171 + 1;
                  goto LABEL_227;
                }
              }
              float32x2_t v174 = v171;
            }
            else
            {
LABEL_227:
              float32x2_t v174 = operator new(0x30uLL);
              *((void *)v174 + 4) = @"<=";
              *((void *)v174 + 5) = 0;
              *(void *)float32x2_t v174 = 0;
              *((void *)v174 + 1) = 0;
              *((void *)v174 + 2) = v171;
              *uint64_t v172 = (uint64_t *)v174;
              v175 = (uint64_t *)v174;
              if (*v431)
              {
                v431 = (uint64_t **)*v431;
                v175 = *v172;
              }
              unint64_t v176 = v432;
              BOOL v15 = v175 == v432;
              *((unsigned char *)v175 + 24) = v175 == v432;
              if (!v15)
              {
                do
                {
                  uint64_t v177 = v175[2];
                  if (*(unsigned char *)(v177 + 24)) {
                    break;
                  }
                  long long v178 = *(uint64_t **)(v177 + 16);
                  uint64_t v179 = *v178;
                  if (*v178 == v177)
                  {
                    uint64_t v182 = v178[1];
                    if (!v182 || (v183 = *(unsigned __int8 *)(v182 + 24), uint64_t v180 = (unsigned char *)(v182 + 24), v183))
                    {
                      if (*(uint64_t **)v177 == v175)
                      {
                        *(unsigned char *)(v177 + 24) = 1;
                        *((unsigned char *)v178 + 24) = 0;
                        uint64_t v186 = *(void *)(v177 + 8);
                        *long long v178 = v186;
                        if (v186) {
                          goto LABEL_244;
                        }
                      }
                      else
                      {
                        long long v184 = *(uint64_t **)(v177 + 8);
                        uint64_t v185 = *v184;
                        *(void *)(v177 + 8) = *v184;
                        if (v185)
                        {
                          *(void *)(v185 + 16) = v177;
                          long long v178 = *(uint64_t **)(v177 + 16);
                        }
                        v184[2] = (uint64_t)v178;
                        *(void *)(*(void *)(v177 + 16) + 8 * (**(void **)(v177 + 16) != v177)) = v184;
                        *long long v184 = v177;
                        *(void *)(v177 + 16) = v184;
                        long long v178 = (uint64_t *)v184[2];
                        uint64_t v177 = *v178;
                        *((unsigned char *)v184 + 24) = 1;
                        *((unsigned char *)v178 + 24) = 0;
                        uint64_t v186 = *(void *)(v177 + 8);
                        *long long v178 = v186;
                        if (v186) {
LABEL_244:
                        }
                          *(void *)(v186 + 16) = v178;
                      }
                      *(void *)(v177 + 16) = v178[2];
                      *(void *)(v178[2] + 8 * (*(void *)v178[2] != (void)v178)) = v177;
                      *(void *)(v177 + 8) = v178;
LABEL_251:
                      v178[2] = v177;
                      break;
                    }
                  }
                  else if (!v179 || (v181 = *(unsigned __int8 *)(v179 + 24), uint64_t v180 = (unsigned char *)(v179 + 24), v181))
                  {
                    if (*(uint64_t **)v177 == v175)
                    {
                      uint64_t v212 = v175[1];
                      *(void *)uint64_t v177 = v212;
                      if (v212)
                      {
                        *(void *)(v212 + 16) = v177;
                        long long v178 = *(uint64_t **)(v177 + 16);
                      }
                      v175[2] = (uint64_t)v178;
                      *(void *)(*(void *)(v177 + 16) + 8 * (**(void **)(v177 + 16) != v177)) = v175;
                      v175[1] = v177;
                      *(void *)(v177 + 16) = v175;
                      long long v178 = (uint64_t *)v175[2];
                      *((unsigned char *)v175 + 24) = 1;
                      *((unsigned char *)v178 + 24) = 0;
                      uint64_t v177 = v178[1];
                      uint64_t v187 = *(uint64_t **)v177;
                      v178[1] = *(void *)v177;
                      if (v187) {
LABEL_249:
                      }
                        v187[2] = (uint64_t)v178;
                    }
                    else
                    {
                      *(unsigned char *)(v177 + 24) = 1;
                      *((unsigned char *)v178 + 24) = 0;
                      uint64_t v177 = v178[1];
                      uint64_t v187 = *(uint64_t **)v177;
                      v178[1] = *(void *)v177;
                      if (v187) {
                        goto LABEL_249;
                      }
                    }
                    *(void *)(v177 + 16) = v178[2];
                    *(void *)(v178[2] + 8 * (*(void *)v178[2] != (void)v178)) = v177;
                    *(void *)uint64_t v177 = v178;
                    goto LABEL_251;
                  }
                  *(unsigned char *)(v177 + 24) = 1;
                  v175 = v178;
                  *((unsigned char *)v178 + 24) = v178 == v176;
                  *uint64_t v180 = 1;
                }
                while (v178 != v176);
              }
              ++v433;
            }
            [*((id *)v174 + 5) setObject:v169 atIndexedSubscript:v162];

            uint64_t v188 = NSNumber;
            uint64_t v189 = [(id)v161[5] count];
            v190 = [v430 objectAtIndexedSubscript:v162];
            uint64_t v191 = objc_msgSend(v188, "numberWithUnsignedInteger:", v189 - objc_msgSend(v190, "integerValue"));
            v192 = v432;
            v193 = &v432;
LABEL_255:
            v194 = v193;
            if (v192)
            {
              while (1)
              {
                v193 = (uint64_t **)v192;
                unint64_t v195 = v192[4];
                if (v195 > (unint64_t)@">")
                {
                  v192 = *v193;
                  goto LABEL_255;
                }
                if (v195 >= (unint64_t)@">") {
                  break;
                }
                v192 = v193[1];
                if (!v192)
                {
                  v194 = v193 + 1;
                  goto LABEL_260;
                }
              }
              uint64_t v196 = v193;
            }
            else
            {
LABEL_260:
              uint64_t v196 = operator new(0x30uLL);
              *((void *)v196 + 4) = @">";
              *((void *)v196 + 5) = 0;
              *(void *)uint64_t v196 = 0;
              *((void *)v196 + 1) = 0;
              *((void *)v196 + 2) = v193;
              void *v194 = (uint64_t *)v196;
              unint64_t v197 = (uint64_t *)v196;
              if (*v431)
              {
                v431 = (uint64_t **)*v431;
                unint64_t v197 = *v194;
              }
              v198 = v432;
              BOOL v15 = v197 == v432;
              *((unsigned char *)v197 + 24) = v197 == v432;
              if (!v15)
              {
                do
                {
                  uint64_t v199 = v197[2];
                  if (*(unsigned char *)(v199 + 24)) {
                    break;
                  }
                  uint64_t v200 = *(uint64_t **)(v199 + 16);
                  uint64_t v201 = *v200;
                  if (*v200 == v199)
                  {
                    uint64_t v204 = v200[1];
                    if (!v204 || (v205 = *(unsigned __int8 *)(v204 + 24), unint64_t v202 = (unsigned char *)(v204 + 24), v205))
                    {
                      if (*(uint64_t **)v199 == v197)
                      {
                        *(unsigned char *)(v199 + 24) = 1;
                        *((unsigned char *)v200 + 24) = 0;
                        uint64_t v208 = *(void *)(v199 + 8);
                        *uint64_t v200 = v208;
                        if (v208) {
                          goto LABEL_277;
                        }
                      }
                      else
                      {
                        unint64_t v206 = *(uint64_t **)(v199 + 8);
                        uint64_t v207 = *v206;
                        *(void *)(v199 + 8) = *v206;
                        if (v207)
                        {
                          *(void *)(v207 + 16) = v199;
                          uint64_t v200 = *(uint64_t **)(v199 + 16);
                        }
                        v206[2] = (uint64_t)v200;
                        *(void *)(*(void *)(v199 + 16) + 8 * (**(void **)(v199 + 16) != v199)) = v206;
                        *unint64_t v206 = v199;
                        *(void *)(v199 + 16) = v206;
                        uint64_t v200 = (uint64_t *)v206[2];
                        uint64_t v199 = *v200;
                        *((unsigned char *)v206 + 24) = 1;
                        *((unsigned char *)v200 + 24) = 0;
                        uint64_t v208 = *(void *)(v199 + 8);
                        *uint64_t v200 = v208;
                        if (v208) {
LABEL_277:
                        }
                          *(void *)(v208 + 16) = v200;
                      }
                      *(void *)(v199 + 16) = v200[2];
                      *(void *)(v200[2] + 8 * (*(void *)v200[2] != (void)v200)) = v199;
                      *(void *)(v199 + 8) = v200;
LABEL_284:
                      v200[2] = v199;
                      break;
                    }
                  }
                  else if (!v201 || (v203 = *(unsigned __int8 *)(v201 + 24), unint64_t v202 = (unsigned char *)(v201 + 24), v203))
                  {
                    if (*(uint64_t **)v199 == v197)
                    {
                      uint64_t v213 = v197[1];
                      *(void *)uint64_t v199 = v213;
                      if (v213)
                      {
                        *(void *)(v213 + 16) = v199;
                        uint64_t v200 = *(uint64_t **)(v199 + 16);
                      }
                      v197[2] = (uint64_t)v200;
                      *(void *)(*(void *)(v199 + 16) + 8 * (**(void **)(v199 + 16) != v199)) = v197;
                      v197[1] = v199;
                      *(void *)(v199 + 16) = v197;
                      uint64_t v200 = (uint64_t *)v197[2];
                      *((unsigned char *)v197 + 24) = 1;
                      *((unsigned char *)v200 + 24) = 0;
                      uint64_t v199 = v200[1];
                      float32x2_t v209 = *(uint64_t **)v199;
                      v200[1] = *(void *)v199;
                      if (v209) {
LABEL_282:
                      }
                        v209[2] = (uint64_t)v200;
                    }
                    else
                    {
                      *(unsigned char *)(v199 + 24) = 1;
                      *((unsigned char *)v200 + 24) = 0;
                      uint64_t v199 = v200[1];
                      float32x2_t v209 = *(uint64_t **)v199;
                      v200[1] = *(void *)v199;
                      if (v209) {
                        goto LABEL_282;
                      }
                    }
                    *(void *)(v199 + 16) = v200[2];
                    *(void *)(v200[2] + 8 * (*(void *)v200[2] != (void)v200)) = v199;
                    *(void *)uint64_t v199 = v200;
                    goto LABEL_284;
                  }
                  *(unsigned char *)(v199 + 24) = 1;
                  unint64_t v197 = v200;
                  *((unsigned char *)v200 + 24) = v200 == v198;
                  *unint64_t v202 = 1;
                }
                while (v200 != v198);
              }
              ++v433;
            }
            [*((id *)v196 + 5) setObject:v191 atIndexedSubscript:v162];

            unint64_t v210 = (void *)v161[1];
            if (v210)
            {
              do
              {
                int8x8_t v211 = (void **)v210;
                unint64_t v210 = (void *)*v210;
              }
              while (v210);
            }
            else
            {
              do
              {
                int8x8_t v211 = (void **)v161[2];
                BOOL v15 = *v211 == v161;
                unint64_t v161 = v211;
              }
              while (!v15);
            }
            ++v162;
            unint64_t v161 = v211;
          }
          while (v211 != &v435);
        }
      }
    }
    else
    {
      uint64_t v94 = [(NSArray *)v6 objectAtIndexedSubscript:0];
      v426 = [v94 firstObject];

      v95 = [(NSArray *)v6 objectAtIndexedSubscript:1];
      uint64_t v96 = [v95 firstObject];

      v425 = v96;
      [v96 floatValue];
      float v98 = v97;
      [v426 floatValue];
      float v100 = v99;
      uint64_t v101 = NSNumber;
      [v426 floatValue];
      *(float *)&double v103 = v102 + (float)((float)(v100 - v98) * 0.5);
      v428 = [v101 numberWithFloat:v103];
      int64_t v104 = v434;
      if (v434 != &v435)
      {
        uint64_t v105 = 0;
        do
        {
          [v430 setObject:&unk_26E94BA20 atIndexedSubscript:v105];
          id v106 = [v430 objectAtIndexedSubscript:v105];
          uint64_t v107 = v432;
          unint64_t v108 = &v432;
LABEL_132:
          uint64_t v109 = v108;
          if (v107)
          {
            while (1)
            {
              unint64_t v108 = (uint64_t **)v107;
              unint64_t v110 = v107[4];
              if (v110 > (unint64_t)@"<=")
              {
                uint64_t v107 = *v108;
                goto LABEL_132;
              }
              if (v110 >= (unint64_t)@"<=") {
                break;
              }
              uint64_t v107 = v108[1];
              if (!v107)
              {
                uint64_t v109 = v108 + 1;
                goto LABEL_137;
              }
            }
            unint64_t v111 = v108;
          }
          else
          {
LABEL_137:
            unint64_t v111 = operator new(0x30uLL);
            *((void *)v111 + 4) = @"<=";
            *((void *)v111 + 5) = 0;
            *(void *)unint64_t v111 = 0;
            *((void *)v111 + 1) = 0;
            *((void *)v111 + 2) = v108;
            *uint64_t v109 = (uint64_t *)v111;
            float v112 = (uint64_t *)v111;
            if (*v431)
            {
              v431 = (uint64_t **)*v431;
              float v112 = *v109;
            }
            uint64_t v113 = v432;
            BOOL v15 = v112 == v432;
            *((unsigned char *)v112 + 24) = v112 == v432;
            if (!v15)
            {
              do
              {
                uint64_t v114 = v112[2];
                if (*(unsigned char *)(v114 + 24)) {
                  break;
                }
                uint64_t v115 = *(uint64_t **)(v114 + 16);
                uint64_t v116 = *v115;
                if (*v115 == v114)
                {
                  uint64_t v119 = v115[1];
                  if (!v119 || (v120 = *(unsigned __int8 *)(v119 + 24), uint64_t v117 = (unsigned char *)(v119 + 24), v120))
                  {
                    if (*(uint64_t **)v114 == v112)
                    {
                      *(unsigned char *)(v114 + 24) = 1;
                      *((unsigned char *)v115 + 24) = 0;
                      uint64_t v123 = *(void *)(v114 + 8);
                      *uint64_t v115 = v123;
                      if (v123) {
                        goto LABEL_154;
                      }
                    }
                    else
                    {
                      uint64_t v121 = *(uint64_t **)(v114 + 8);
                      uint64_t v122 = *v121;
                      *(void *)(v114 + 8) = *v121;
                      if (v122)
                      {
                        *(void *)(v122 + 16) = v114;
                        uint64_t v115 = *(uint64_t **)(v114 + 16);
                      }
                      v121[2] = (uint64_t)v115;
                      *(void *)(*(void *)(v114 + 16) + 8 * (**(void **)(v114 + 16) != v114)) = v121;
                      *uint64_t v121 = v114;
                      *(void *)(v114 + 16) = v121;
                      uint64_t v115 = (uint64_t *)v121[2];
                      uint64_t v114 = *v115;
                      *((unsigned char *)v121 + 24) = 1;
                      *((unsigned char *)v115 + 24) = 0;
                      uint64_t v123 = *(void *)(v114 + 8);
                      *uint64_t v115 = v123;
                      if (v123) {
LABEL_154:
                      }
                        *(void *)(v123 + 16) = v115;
                    }
                    *(void *)(v114 + 16) = v115[2];
                    *(void *)(v115[2] + 8 * (*(void *)v115[2] != (void)v115)) = v114;
                    *(void *)(v114 + 8) = v115;
LABEL_161:
                    v115[2] = v114;
                    break;
                  }
                }
                else if (!v116 || (v118 = *(unsigned __int8 *)(v116 + 24), uint64_t v117 = (unsigned char *)(v116 + 24), v118))
                {
                  if (*(uint64_t **)v114 == v112)
                  {
                    uint64_t v149 = v112[1];
                    *(void *)uint64_t v114 = v149;
                    if (v149)
                    {
                      *(void *)(v149 + 16) = v114;
                      uint64_t v115 = *(uint64_t **)(v114 + 16);
                    }
                    v112[2] = (uint64_t)v115;
                    *(void *)(*(void *)(v114 + 16) + 8 * (**(void **)(v114 + 16) != v114)) = v112;
                    v112[1] = v114;
                    *(void *)(v114 + 16) = v112;
                    uint64_t v115 = (uint64_t *)v112[2];
                    *((unsigned char *)v112 + 24) = 1;
                    *((unsigned char *)v115 + 24) = 0;
                    uint64_t v114 = v115[1];
                    v124 = *(uint64_t **)v114;
                    v115[1] = *(void *)v114;
                    if (v124) {
LABEL_159:
                    }
                      v124[2] = (uint64_t)v115;
                  }
                  else
                  {
                    *(unsigned char *)(v114 + 24) = 1;
                    *((unsigned char *)v115 + 24) = 0;
                    uint64_t v114 = v115[1];
                    v124 = *(uint64_t **)v114;
                    v115[1] = *(void *)v114;
                    if (v124) {
                      goto LABEL_159;
                    }
                  }
                  *(void *)(v114 + 16) = v115[2];
                  *(void *)(v115[2] + 8 * (*(void *)v115[2] != (void)v115)) = v114;
                  *(void *)uint64_t v114 = v115;
                  goto LABEL_161;
                }
                *(unsigned char *)(v114 + 24) = 1;
                float v112 = v115;
                *((unsigned char *)v115 + 24) = v115 == v113;
                *uint64_t v117 = 1;
              }
              while (v115 != v113);
            }
            ++v433;
          }
          [*((id *)v111 + 5) setObject:v106 atIndexedSubscript:v105];

          float v125 = NSNumber;
          uint64_t v126 = [(id)v104[5] count];
          uint64_t v127 = [v430 objectAtIndexedSubscript:v105];
          int64_t v128 = objc_msgSend(v125, "numberWithUnsignedInteger:", v126 - objc_msgSend(v127, "integerValue"));
          uint64_t v129 = v432;
          unint64_t v130 = &v432;
LABEL_165:
          uint64_t v131 = v130;
          if (v129)
          {
            while (1)
            {
              unint64_t v130 = (uint64_t **)v129;
              unint64_t v132 = v129[4];
              if (v132 > (unint64_t)@">")
              {
                uint64_t v129 = *v130;
                goto LABEL_165;
              }
              if (v132 >= (unint64_t)@">") {
                break;
              }
              uint64_t v129 = v130[1];
              if (!v129)
              {
                uint64_t v131 = v130 + 1;
                goto LABEL_170;
              }
            }
            BOOL v133 = v130;
          }
          else
          {
LABEL_170:
            BOOL v133 = operator new(0x30uLL);
            *((void *)v133 + 4) = @">";
            *((void *)v133 + 5) = 0;
            *(void *)BOOL v133 = 0;
            *((void *)v133 + 1) = 0;
            *((void *)v133 + 2) = v130;
            *uint64_t v131 = (uint64_t *)v133;
            BOOL v134 = (uint64_t *)v133;
            if (*v431)
            {
              v431 = (uint64_t **)*v431;
              BOOL v134 = *v131;
            }
            unint64_t v135 = v432;
            BOOL v15 = v134 == v432;
            *((unsigned char *)v134 + 24) = v134 == v432;
            if (!v15)
            {
              do
              {
                uint64_t v136 = v134[2];
                if (*(unsigned char *)(v136 + 24)) {
                  break;
                }
                float v137 = *(uint64_t **)(v136 + 16);
                uint64_t v138 = *v137;
                if (*v137 == v136)
                {
                  uint64_t v141 = v137[1];
                  if (!v141 || (v142 = *(unsigned __int8 *)(v141 + 24), uint64_t v139 = (unsigned char *)(v141 + 24), v142))
                  {
                    if (*(uint64_t **)v136 == v134)
                    {
                      *(unsigned char *)(v136 + 24) = 1;
                      *((unsigned char *)v137 + 24) = 0;
                      uint64_t v145 = *(void *)(v136 + 8);
                      *float v137 = v145;
                      if (v145) {
                        goto LABEL_187;
                      }
                    }
                    else
                    {
                      long long v143 = *(uint64_t **)(v136 + 8);
                      uint64_t v144 = *v143;
                      *(void *)(v136 + 8) = *v143;
                      if (v144)
                      {
                        *(void *)(v144 + 16) = v136;
                        float v137 = *(uint64_t **)(v136 + 16);
                      }
                      v143[2] = (uint64_t)v137;
                      *(void *)(*(void *)(v136 + 16) + 8 * (**(void **)(v136 + 16) != v136)) = v143;
                      *long long v143 = v136;
                      *(void *)(v136 + 16) = v143;
                      float v137 = (uint64_t *)v143[2];
                      uint64_t v136 = *v137;
                      *((unsigned char *)v143 + 24) = 1;
                      *((unsigned char *)v137 + 24) = 0;
                      uint64_t v145 = *(void *)(v136 + 8);
                      *float v137 = v145;
                      if (v145) {
LABEL_187:
                      }
                        *(void *)(v145 + 16) = v137;
                    }
                    *(void *)(v136 + 16) = v137[2];
                    *(void *)(v137[2] + 8 * (*(void *)v137[2] != (void)v137)) = v136;
                    *(void *)(v136 + 8) = v137;
LABEL_194:
                    v137[2] = v136;
                    break;
                  }
                }
                else if (!v138 || (v140 = *(unsigned __int8 *)(v138 + 24), uint64_t v139 = (unsigned char *)(v138 + 24), v140))
                {
                  if (*(uint64_t **)v136 == v134)
                  {
                    uint64_t v150 = v134[1];
                    *(void *)uint64_t v136 = v150;
                    if (v150)
                    {
                      *(void *)(v150 + 16) = v136;
                      float v137 = *(uint64_t **)(v136 + 16);
                    }
                    v134[2] = (uint64_t)v137;
                    *(void *)(*(void *)(v136 + 16) + 8 * (**(void **)(v136 + 16) != v136)) = v134;
                    v134[1] = v136;
                    *(void *)(v136 + 16) = v134;
                    float v137 = (uint64_t *)v134[2];
                    *((unsigned char *)v134 + 24) = 1;
                    *((unsigned char *)v137 + 24) = 0;
                    uint64_t v136 = v137[1];
                    v146 = *(uint64_t **)v136;
                    v137[1] = *(void *)v136;
                    if (v146) {
LABEL_192:
                    }
                      v146[2] = (uint64_t)v137;
                  }
                  else
                  {
                    *(unsigned char *)(v136 + 24) = 1;
                    *((unsigned char *)v137 + 24) = 0;
                    uint64_t v136 = v137[1];
                    v146 = *(uint64_t **)v136;
                    v137[1] = *(void *)v136;
                    if (v146) {
                      goto LABEL_192;
                    }
                  }
                  *(void *)(v136 + 16) = v137[2];
                  *(void *)(v137[2] + 8 * (*(void *)v137[2] != (void)v137)) = v136;
                  *(void *)uint64_t v136 = v137;
                  goto LABEL_194;
                }
                *(unsigned char *)(v136 + 24) = 1;
                BOOL v134 = v137;
                *((unsigned char *)v137 + 24) = v137 == v135;
                *uint64_t v139 = 1;
              }
              while (v137 != v135);
            }
            ++v433;
          }
          [*((id *)v133 + 5) setObject:v128 atIndexedSubscript:v105];

          unint64_t v147 = (void *)v104[1];
          if (v147)
          {
            do
            {
              float v148 = (void **)v147;
              unint64_t v147 = (void *)*v147;
            }
            while (v147);
          }
          else
          {
            do
            {
              float v148 = (void **)v104[2];
              BOOL v15 = *v148 == v104;
              int64_t v104 = v148;
            }
            while (!v15);
          }
          ++v105;
          int64_t v104 = v148;
        }
        while (v148 != &v435);
      }
    }

    if (i)
    {
      if ([(NSArray *)v6 count] == i)
      {
        float v216 = 1.0;
        if (v436)
        {
          unint64_t v217 = 0;
          float v218 = 0.0;
          do
          {
            char v219 = v432;
            uint64_t v220 = &v432;
LABEL_310:
            v221 = v220;
            if (v219)
            {
              while (1)
              {
                uint64_t v220 = (uint64_t **)v219;
                unint64_t v222 = v219[4];
                if (v222 > (unint64_t)@"<=")
                {
                  char v219 = *v220;
                  goto LABEL_310;
                }
                if (v222 >= (unint64_t)@"<=") {
                  break;
                }
                char v219 = v220[1];
                if (!v219)
                {
                  v221 = v220 + 1;
                  goto LABEL_315;
                }
              }
              float v223 = v220;
            }
            else
            {
LABEL_315:
              float v223 = operator new(0x30uLL);
              *((void *)v223 + 4) = @"<=";
              *((void *)v223 + 5) = 0;
              *(void *)float v223 = 0;
              *((void *)v223 + 1) = 0;
              *((void *)v223 + 2) = v220;
              void *v221 = (uint64_t *)v223;
              float v224 = (uint64_t *)v223;
              if (*v431)
              {
                v431 = (uint64_t **)*v431;
                float v224 = *v221;
              }
              unsigned int v225 = v432;
              BOOL v15 = v224 == v432;
              *((unsigned char *)v224 + 24) = v224 == v432;
              if (!v15)
              {
                do
                {
                  uint64_t v226 = v224[2];
                  if (*(unsigned char *)(v226 + 24)) {
                    break;
                  }
                  long long v227 = *(uint64_t **)(v226 + 16);
                  uint64_t v228 = *v227;
                  if (*v227 == v226)
                  {
                    uint64_t v231 = v227[1];
                    if (!v231 || (v232 = *(unsigned __int8 *)(v231 + 24), long long v229 = (unsigned char *)(v231 + 24), v232))
                    {
                      if (*(uint64_t **)v226 == v224)
                      {
                        *(unsigned char *)(v226 + 24) = 1;
                        *((unsigned char *)v227 + 24) = 0;
                        uint64_t v235 = *(void *)(v226 + 8);
                        *long long v227 = v235;
                        if (v235) {
                          goto LABEL_332;
                        }
                      }
                      else
                      {
                        id v233 = *(uint64_t **)(v226 + 8);
                        uint64_t v234 = *v233;
                        *(void *)(v226 + 8) = *v233;
                        if (v234)
                        {
                          *(void *)(v234 + 16) = v226;
                          long long v227 = *(uint64_t **)(v226 + 16);
                        }
                        v233[2] = (uint64_t)v227;
                        *(void *)(*(void *)(v226 + 16) + 8 * (**(void **)(v226 + 16) != v226)) = v233;
                        *id v233 = v226;
                        *(void *)(v226 + 16) = v233;
                        long long v227 = (uint64_t *)v233[2];
                        uint64_t v226 = *v227;
                        *((unsigned char *)v233 + 24) = 1;
                        *((unsigned char *)v227 + 24) = 0;
                        uint64_t v235 = *(void *)(v226 + 8);
                        *long long v227 = v235;
                        if (v235) {
LABEL_332:
                        }
                          *(void *)(v235 + 16) = v227;
                      }
                      *(void *)(v226 + 16) = v227[2];
                      *(void *)(v227[2] + 8 * (*(void *)v227[2] != (void)v227)) = v226;
                      *(void *)(v226 + 8) = v227;
LABEL_339:
                      v227[2] = v226;
                      break;
                    }
                  }
                  else if (!v228 || (v230 = *(unsigned __int8 *)(v228 + 24), long long v229 = (unsigned char *)(v228 + 24), v230))
                  {
                    if (*(uint64_t **)v226 == v224)
                    {
                      uint64_t v239 = v224[1];
                      *(void *)uint64_t v226 = v239;
                      if (v239)
                      {
                        *(void *)(v239 + 16) = v226;
                        long long v227 = *(uint64_t **)(v226 + 16);
                      }
                      v224[2] = (uint64_t)v227;
                      *(void *)(*(void *)(v226 + 16) + 8 * (**(void **)(v226 + 16) != v226)) = v224;
                      v224[1] = v226;
                      *(void *)(v226 + 16) = v224;
                      long long v227 = (uint64_t *)v224[2];
                      *((unsigned char *)v224 + 24) = 1;
                      *((unsigned char *)v227 + 24) = 0;
                      uint64_t v226 = v227[1];
                      uint64_t v236 = *(uint64_t **)v226;
                      v227[1] = *(void *)v226;
                      if (v236) {
LABEL_337:
                      }
                        v236[2] = (uint64_t)v227;
                    }
                    else
                    {
                      *(unsigned char *)(v226 + 24) = 1;
                      *((unsigned char *)v227 + 24) = 0;
                      uint64_t v226 = v227[1];
                      uint64_t v236 = *(uint64_t **)v226;
                      v227[1] = *(void *)v226;
                      if (v236) {
                        goto LABEL_337;
                      }
                    }
                    *(void *)(v226 + 16) = v227[2];
                    *(void *)(v227[2] + 8 * (*(void *)v227[2] != (void)v227)) = v226;
                    *(void *)uint64_t v226 = v227;
                    goto LABEL_339;
                  }
                  *(unsigned char *)(v226 + 24) = 1;
                  float v224 = v227;
                  *((unsigned char *)v227 + 24) = v227 == v225;
                  *long long v229 = 1;
                }
                while (v227 != v225);
              }
              ++v433;
            }
            v237 = [*((id *)v223 + 5) objectAtIndexedSubscript:v217];
            [v237 floatValue];
            float v218 = v238 + v218;

            ++v217;
          }
          while (v436 > v217);
          if (v436)
          {
            unint64_t v339 = 0;
            float v216 = 1.0;
            float v340 = 1.0 / v218;
            do
            {
              v341 = v432;
              v342 = &v432;
LABEL_529:
              v343 = v342;
              if (v341)
              {
                while (1)
                {
                  v342 = (uint64_t **)v341;
                  unint64_t v344 = v341[4];
                  if (v344 > (unint64_t)@"<=")
                  {
                    v341 = *v342;
                    goto LABEL_529;
                  }
                  if (v344 >= (unint64_t)@"<=") {
                    break;
                  }
                  v341 = v342[1];
                  if (!v341)
                  {
                    v343 = v342 + 1;
                    goto LABEL_534;
                  }
                }
                v345 = v342;
              }
              else
              {
LABEL_534:
                v345 = operator new(0x30uLL);
                *((void *)v345 + 4) = @"<=";
                *((void *)v345 + 5) = 0;
                *(void *)v345 = 0;
                *((void *)v345 + 1) = 0;
                *((void *)v345 + 2) = v342;
                *v343 = (uint64_t *)v345;
                v346 = (uint64_t *)v345;
                if (*v431)
                {
                  v431 = (uint64_t **)*v431;
                  v346 = *v343;
                }
                v347 = v432;
                BOOL v15 = v346 == v432;
                *((unsigned char *)v346 + 24) = v346 == v432;
                if (!v15)
                {
                  do
                  {
                    uint64_t v348 = v346[2];
                    if (*(unsigned char *)(v348 + 24)) {
                      break;
                    }
                    v349 = *(uint64_t **)(v348 + 16);
                    uint64_t v350 = *v349;
                    if (*v349 == v348)
                    {
                      uint64_t v353 = v349[1];
                      if (!v353 || (int v354 = *(unsigned __int8 *)(v353 + 24), v351 = (unsigned char *)(v353 + 24), v354))
                      {
                        if (*(uint64_t **)v348 == v346)
                        {
                          *(unsigned char *)(v348 + 24) = 1;
                          *((unsigned char *)v349 + 24) = 0;
                          uint64_t v357 = *(void *)(v348 + 8);
                          uint64_t *v349 = v357;
                          if (v357) {
                            goto LABEL_551;
                          }
                        }
                        else
                        {
                          v355 = *(uint64_t **)(v348 + 8);
                          uint64_t v356 = *v355;
                          *(void *)(v348 + 8) = *v355;
                          if (v356)
                          {
                            *(void *)(v356 + 16) = v348;
                            v349 = *(uint64_t **)(v348 + 16);
                          }
                          v355[2] = (uint64_t)v349;
                          *(void *)(*(void *)(v348 + 16) + 8 * (**(void **)(v348 + 16) != v348)) = v355;
                          uint64_t *v355 = v348;
                          *(void *)(v348 + 16) = v355;
                          v349 = (uint64_t *)v355[2];
                          uint64_t v348 = *v349;
                          *((unsigned char *)v355 + 24) = 1;
                          *((unsigned char *)v349 + 24) = 0;
                          uint64_t v357 = *(void *)(v348 + 8);
                          uint64_t *v349 = v357;
                          if (v357) {
LABEL_551:
                          }
                            *(void *)(v357 + 16) = v349;
                        }
                        *(void *)(v348 + 16) = v349[2];
                        *(void *)(v349[2] + 8 * (*(void *)v349[2] != (void)v349)) = v348;
                        *(void *)(v348 + 8) = v349;
LABEL_558:
                        v349[2] = v348;
                        break;
                      }
                    }
                    else if (!v350 || (int v352 = *(unsigned __int8 *)(v350 + 24), v351 = (unsigned char *)(v350 + 24), v352))
                    {
                      if (*(uint64_t **)v348 == v346)
                      {
                        uint64_t v361 = v346[1];
                        *(void *)uint64_t v348 = v361;
                        if (v361)
                        {
                          *(void *)(v361 + 16) = v348;
                          v349 = *(uint64_t **)(v348 + 16);
                        }
                        v346[2] = (uint64_t)v349;
                        *(void *)(*(void *)(v348 + 16) + 8 * (**(void **)(v348 + 16) != v348)) = v346;
                        v346[1] = v348;
                        *(void *)(v348 + 16) = v346;
                        v349 = (uint64_t *)v346[2];
                        *((unsigned char *)v346 + 24) = 1;
                        *((unsigned char *)v349 + 24) = 0;
                        uint64_t v348 = v349[1];
                        v358 = *(uint64_t **)v348;
                        v349[1] = *(void *)v348;
                        if (v358) {
LABEL_556:
                        }
                          v358[2] = (uint64_t)v349;
                      }
                      else
                      {
                        *(unsigned char *)(v348 + 24) = 1;
                        *((unsigned char *)v349 + 24) = 0;
                        uint64_t v348 = v349[1];
                        v358 = *(uint64_t **)v348;
                        v349[1] = *(void *)v348;
                        if (v358) {
                          goto LABEL_556;
                        }
                      }
                      *(void *)(v348 + 16) = v349[2];
                      *(void *)(v349[2] + 8 * (*(void *)v349[2] != (void)v349)) = v348;
                      *(void *)uint64_t v348 = v349;
                      goto LABEL_558;
                    }
                    *(unsigned char *)(v348 + 24) = 1;
                    v346 = v349;
                    *((unsigned char *)v349 + 24) = v349 == v347;
                    unsigned char *v351 = 1;
                  }
                  while (v349 != v347);
                }
                ++v433;
              }
              v359 = [*((id *)v345 + 5) objectAtIndexedSubscript:v339];
              [v359 floatValue];
              float v216 = v216 - (float)((float)(v360 * v340) * (float)(v360 * v340));

              ++v339;
            }
            while (v436 > v339);
          }
        }
        *(float *)&double v215 = v216;
        uint64_t v334 = [NSNumber numberWithFloat:v215];
        v362 = v438;
        v336 = &v438;
LABEL_570:
        v337 = v336;
        if (v362)
        {
          do
          {
            v336 = (uint64_t **)v362;
            unint64_t v363 = v362[4];
            if ((unint64_t)v428 < v363)
            {
              v362 = *v336;
              goto LABEL_570;
            }
            if (v363 >= (unint64_t)v428) {
              goto LABEL_669;
            }
            v362 = v336[1];
          }
          while (v362);
          v337 = v336 + 1;
        }
LABEL_667:
        v412 = (uint64_t *)operator new(0x30uLL);
        v412[4] = (uint64_t)v428;
        v412[5] = 0;
        uint64_t *v412 = 0;
        v412[1] = 0;
        v412[2] = (uint64_t)v336;
        *v337 = v412;
        v413 = v412;
        if (*v437)
        {
          v437 = (uint64_t **)*v437;
          v413 = *v337;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v438, v413);
        ++v439;
        goto LABEL_33;
      }
      float v264 = 1.0;
      if (v436)
      {
        unint64_t v265 = 0;
        float v266 = 0.0;
        float v267 = 0.0;
        do
        {
          v268 = v432;
          v269 = &v432;
LABEL_396:
          v270 = v269;
          if (v268)
          {
            while (1)
            {
              v269 = (uint64_t **)v268;
              unint64_t v271 = v268[4];
              if (v271 > (unint64_t)@"<=")
              {
                v268 = *v269;
                goto LABEL_396;
              }
              if (v271 >= (unint64_t)@"<=") {
                break;
              }
              v268 = v269[1];
              if (!v268)
              {
                v270 = v269 + 1;
                goto LABEL_401;
              }
            }
            v272 = v269;
          }
          else
          {
LABEL_401:
            v272 = operator new(0x30uLL);
            *((void *)v272 + 4) = @"<=";
            *((void *)v272 + 5) = 0;
            *(void *)v272 = 0;
            *((void *)v272 + 1) = 0;
            *((void *)v272 + 2) = v269;
            *v270 = (uint64_t *)v272;
            v273 = (uint64_t *)v272;
            if (*v431)
            {
              v431 = (uint64_t **)*v431;
              v273 = *v270;
            }
            v274 = v432;
            BOOL v15 = v273 == v432;
            *((unsigned char *)v273 + 24) = v273 == v432;
            if (!v15)
            {
              do
              {
                uint64_t v275 = v273[2];
                if (*(unsigned char *)(v275 + 24)) {
                  break;
                }
                v276 = *(uint64_t **)(v275 + 16);
                uint64_t v277 = *v276;
                if (*v276 == v275)
                {
                  uint64_t v280 = v276[1];
                  if (!v280 || (int v281 = *(unsigned __int8 *)(v280 + 24), v278 = (unsigned char *)(v280 + 24), v281))
                  {
                    if (*(uint64_t **)v275 == v273)
                    {
                      *(unsigned char *)(v275 + 24) = 1;
                      *((unsigned char *)v276 + 24) = 0;
                      uint64_t v284 = *(void *)(v275 + 8);
                      uint64_t *v276 = v284;
                      if (v284) {
                        goto LABEL_418;
                      }
                    }
                    else
                    {
                      v282 = *(uint64_t **)(v275 + 8);
                      uint64_t v283 = *v282;
                      *(void *)(v275 + 8) = *v282;
                      if (v283)
                      {
                        *(void *)(v283 + 16) = v275;
                        v276 = *(uint64_t **)(v275 + 16);
                      }
                      v282[2] = (uint64_t)v276;
                      *(void *)(*(void *)(v275 + 16) + 8 * (**(void **)(v275 + 16) != v275)) = v282;
                      uint64_t *v282 = v275;
                      *(void *)(v275 + 16) = v282;
                      v276 = (uint64_t *)v282[2];
                      uint64_t v275 = *v276;
                      *((unsigned char *)v282 + 24) = 1;
                      *((unsigned char *)v276 + 24) = 0;
                      uint64_t v284 = *(void *)(v275 + 8);
                      uint64_t *v276 = v284;
                      if (v284) {
LABEL_418:
                      }
                        *(void *)(v284 + 16) = v276;
                    }
                    *(void *)(v275 + 16) = v276[2];
                    *(void *)(v276[2] + 8 * (*(void *)v276[2] != (void)v276)) = v275;
                    *(void *)(v275 + 8) = v276;
LABEL_425:
                    v276[2] = v275;
                    break;
                  }
                }
                else if (!v277 || (int v279 = *(unsigned __int8 *)(v277 + 24), v278 = (unsigned char *)(v277 + 24), v279))
                {
                  if (*(uint64_t **)v275 == v273)
                  {
                    uint64_t v309 = v273[1];
                    *(void *)uint64_t v275 = v309;
                    if (v309)
                    {
                      *(void *)(v309 + 16) = v275;
                      v276 = *(uint64_t **)(v275 + 16);
                    }
                    v273[2] = (uint64_t)v276;
                    *(void *)(*(void *)(v275 + 16) + 8 * (**(void **)(v275 + 16) != v275)) = v273;
                    v273[1] = v275;
                    *(void *)(v275 + 16) = v273;
                    v276 = (uint64_t *)v273[2];
                    *((unsigned char *)v273 + 24) = 1;
                    *((unsigned char *)v276 + 24) = 0;
                    uint64_t v275 = v276[1];
                    v285 = *(uint64_t **)v275;
                    v276[1] = *(void *)v275;
                    if (v285) {
LABEL_423:
                    }
                      v285[2] = (uint64_t)v276;
                  }
                  else
                  {
                    *(unsigned char *)(v275 + 24) = 1;
                    *((unsigned char *)v276 + 24) = 0;
                    uint64_t v275 = v276[1];
                    v285 = *(uint64_t **)v275;
                    v276[1] = *(void *)v275;
                    if (v285) {
                      goto LABEL_423;
                    }
                  }
                  *(void *)(v275 + 16) = v276[2];
                  *(void *)(v276[2] + 8 * (*(void *)v276[2] != (void)v276)) = v275;
                  *(void *)uint64_t v275 = v276;
                  goto LABEL_425;
                }
                *(unsigned char *)(v275 + 24) = 1;
                v273 = v276;
                *((unsigned char *)v276 + 24) = v276 == v274;
                unsigned char *v278 = 1;
              }
              while (v276 != v274);
            }
            ++v433;
          }
          v286 = [*((id *)v272 + 5) objectAtIndexedSubscript:v265];
          [v286 floatValue];
          float v288 = v287;

          v289 = v432;
          v290 = &v432;
LABEL_429:
          v291 = v290;
          if (v289)
          {
            while (1)
            {
              v290 = (uint64_t **)v289;
              unint64_t v292 = v289[4];
              if (v292 > (unint64_t)@">")
              {
                v289 = *v290;
                goto LABEL_429;
              }
              if (v292 >= (unint64_t)@">") {
                break;
              }
              v289 = v290[1];
              if (!v289)
              {
                v291 = v290 + 1;
                goto LABEL_434;
              }
            }
            v293 = v290;
          }
          else
          {
LABEL_434:
            v293 = operator new(0x30uLL);
            *((void *)v293 + 4) = @">";
            *((void *)v293 + 5) = 0;
            *(void *)v293 = 0;
            *((void *)v293 + 1) = 0;
            *((void *)v293 + 2) = v290;
            *v291 = (uint64_t *)v293;
            v294 = (uint64_t *)v293;
            if (*v431)
            {
              v431 = (uint64_t **)*v431;
              v294 = *v291;
            }
            v295 = v432;
            BOOL v15 = v294 == v432;
            *((unsigned char *)v294 + 24) = v294 == v432;
            if (!v15)
            {
              do
              {
                uint64_t v296 = v294[2];
                if (*(unsigned char *)(v296 + 24)) {
                  break;
                }
                v297 = *(uint64_t **)(v296 + 16);
                uint64_t v298 = *v297;
                if (*v297 == v296)
                {
                  uint64_t v301 = v297[1];
                  if (!v301 || (int v302 = *(unsigned __int8 *)(v301 + 24), v299 = (unsigned char *)(v301 + 24), v302))
                  {
                    if (*(uint64_t **)v296 == v294)
                    {
                      *(unsigned char *)(v296 + 24) = 1;
                      *((unsigned char *)v297 + 24) = 0;
                      uint64_t v305 = *(void *)(v296 + 8);
                      uint64_t *v297 = v305;
                      if (v305) {
                        goto LABEL_451;
                      }
                    }
                    else
                    {
                      v303 = *(uint64_t **)(v296 + 8);
                      uint64_t v304 = *v303;
                      *(void *)(v296 + 8) = *v303;
                      if (v304)
                      {
                        *(void *)(v304 + 16) = v296;
                        v297 = *(uint64_t **)(v296 + 16);
                      }
                      v303[2] = (uint64_t)v297;
                      *(void *)(*(void *)(v296 + 16) + 8 * (**(void **)(v296 + 16) != v296)) = v303;
                      uint64_t *v303 = v296;
                      *(void *)(v296 + 16) = v303;
                      v297 = (uint64_t *)v303[2];
                      uint64_t v296 = *v297;
                      *((unsigned char *)v303 + 24) = 1;
                      *((unsigned char *)v297 + 24) = 0;
                      uint64_t v305 = *(void *)(v296 + 8);
                      uint64_t *v297 = v305;
                      if (v305) {
LABEL_451:
                      }
                        *(void *)(v305 + 16) = v297;
                    }
                    *(void *)(v296 + 16) = v297[2];
                    *(void *)(v297[2] + 8 * (*(void *)v297[2] != (void)v297)) = v296;
                    *(void *)(v296 + 8) = v297;
LABEL_458:
                    v297[2] = v296;
                    break;
                  }
                }
                else if (!v298 || (int v300 = *(unsigned __int8 *)(v298 + 24), v299 = (unsigned char *)(v298 + 24), v300))
                {
                  if (*(uint64_t **)v296 == v294)
                  {
                    uint64_t v310 = v294[1];
                    *(void *)uint64_t v296 = v310;
                    if (v310)
                    {
                      *(void *)(v310 + 16) = v296;
                      v297 = *(uint64_t **)(v296 + 16);
                    }
                    v294[2] = (uint64_t)v297;
                    *(void *)(*(void *)(v296 + 16) + 8 * (**(void **)(v296 + 16) != v296)) = v294;
                    v294[1] = v296;
                    *(void *)(v296 + 16) = v294;
                    v297 = (uint64_t *)v294[2];
                    *((unsigned char *)v294 + 24) = 1;
                    *((unsigned char *)v297 + 24) = 0;
                    uint64_t v296 = v297[1];
                    v306 = *(uint64_t **)v296;
                    v297[1] = *(void *)v296;
                    if (v306) {
LABEL_456:
                    }
                      v306[2] = (uint64_t)v297;
                  }
                  else
                  {
                    *(unsigned char *)(v296 + 24) = 1;
                    *((unsigned char *)v297 + 24) = 0;
                    uint64_t v296 = v297[1];
                    v306 = *(uint64_t **)v296;
                    v297[1] = *(void *)v296;
                    if (v306) {
                      goto LABEL_456;
                    }
                  }
                  *(void *)(v296 + 16) = v297[2];
                  *(void *)(v297[2] + 8 * (*(void *)v297[2] != (void)v297)) = v296;
                  *(void *)uint64_t v296 = v297;
                  goto LABEL_458;
                }
                *(unsigned char *)(v296 + 24) = 1;
                v294 = v297;
                *((unsigned char *)v297 + 24) = v297 == v295;
                unsigned char *v299 = 1;
              }
              while (v297 != v295);
            }
            ++v433;
          }
          v307 = [*((id *)v293 + 5) objectAtIndexedSubscript:v265];
          [v307 floatValue];
          float v267 = v288 + v267;
          float v266 = v308 + v266;

          ++v265;
        }
        while (v436 > v265);
        if (v436)
        {
          unint64_t v364 = 0;
          float v365 = 1.0;
          float v264 = 1.0;
          do
          {
            v366 = v432;
            v367 = &v432;
LABEL_580:
            v368 = v367;
            if (v366)
            {
              while (1)
              {
                v367 = (uint64_t **)v366;
                unint64_t v369 = v366[4];
                if (v369 > (unint64_t)@"<=")
                {
                  v366 = *v367;
                  goto LABEL_580;
                }
                if (v369 >= (unint64_t)@"<=") {
                  break;
                }
                v366 = v367[1];
                if (!v366)
                {
                  v368 = v367 + 1;
                  goto LABEL_585;
                }
              }
              v370 = v367;
            }
            else
            {
LABEL_585:
              v370 = operator new(0x30uLL);
              *((void *)v370 + 4) = @"<=";
              *((void *)v370 + 5) = 0;
              *(void *)v370 = 0;
              *((void *)v370 + 1) = 0;
              *((void *)v370 + 2) = v367;
              *v368 = (uint64_t *)v370;
              v371 = (uint64_t *)v370;
              if (*v431)
              {
                v431 = (uint64_t **)*v431;
                v371 = *v368;
              }
              v372 = v432;
              BOOL v15 = v371 == v432;
              *((unsigned char *)v371 + 24) = v371 == v432;
              if (!v15)
              {
                do
                {
                  uint64_t v373 = v371[2];
                  if (*(unsigned char *)(v373 + 24)) {
                    break;
                  }
                  v374 = *(uint64_t **)(v373 + 16);
                  uint64_t v375 = *v374;
                  if (*v374 == v373)
                  {
                    uint64_t v378 = v374[1];
                    if (!v378 || (int v379 = *(unsigned __int8 *)(v378 + 24), v376 = (unsigned char *)(v378 + 24), v379))
                    {
                      if (*(uint64_t **)v373 == v371)
                      {
                        *(unsigned char *)(v373 + 24) = 1;
                        *((unsigned char *)v374 + 24) = 0;
                        uint64_t v382 = *(void *)(v373 + 8);
                        uint64_t *v374 = v382;
                        if (v382) {
                          goto LABEL_602;
                        }
                      }
                      else
                      {
                        v380 = *(uint64_t **)(v373 + 8);
                        uint64_t v381 = *v380;
                        *(void *)(v373 + 8) = *v380;
                        if (v381)
                        {
                          *(void *)(v381 + 16) = v373;
                          v374 = *(uint64_t **)(v373 + 16);
                        }
                        v380[2] = (uint64_t)v374;
                        *(void *)(*(void *)(v373 + 16) + 8 * (**(void **)(v373 + 16) != v373)) = v380;
                        uint64_t *v380 = v373;
                        *(void *)(v373 + 16) = v380;
                        v374 = (uint64_t *)v380[2];
                        uint64_t v373 = *v374;
                        *((unsigned char *)v380 + 24) = 1;
                        *((unsigned char *)v374 + 24) = 0;
                        uint64_t v382 = *(void *)(v373 + 8);
                        uint64_t *v374 = v382;
                        if (v382) {
LABEL_602:
                        }
                          *(void *)(v382 + 16) = v374;
                      }
                      *(void *)(v373 + 16) = v374[2];
                      *(void *)(v374[2] + 8 * (*(void *)v374[2] != (void)v374)) = v373;
                      *(void *)(v373 + 8) = v374;
LABEL_609:
                      v374[2] = v373;
                      break;
                    }
                  }
                  else if (!v375 || (int v377 = *(unsigned __int8 *)(v375 + 24), v376 = (unsigned char *)(v375 + 24), v377))
                  {
                    if (*(uint64_t **)v373 == v371)
                    {
                      uint64_t v407 = v371[1];
                      *(void *)uint64_t v373 = v407;
                      if (v407)
                      {
                        *(void *)(v407 + 16) = v373;
                        v374 = *(uint64_t **)(v373 + 16);
                      }
                      v371[2] = (uint64_t)v374;
                      *(void *)(*(void *)(v373 + 16) + 8 * (**(void **)(v373 + 16) != v373)) = v371;
                      v371[1] = v373;
                      *(void *)(v373 + 16) = v371;
                      v374 = (uint64_t *)v371[2];
                      *((unsigned char *)v371 + 24) = 1;
                      *((unsigned char *)v374 + 24) = 0;
                      uint64_t v373 = v374[1];
                      v383 = *(uint64_t **)v373;
                      v374[1] = *(void *)v373;
                      if (v383) {
LABEL_607:
                      }
                        v383[2] = (uint64_t)v374;
                    }
                    else
                    {
                      *(unsigned char *)(v373 + 24) = 1;
                      *((unsigned char *)v374 + 24) = 0;
                      uint64_t v373 = v374[1];
                      v383 = *(uint64_t **)v373;
                      v374[1] = *(void *)v373;
                      if (v383) {
                        goto LABEL_607;
                      }
                    }
                    *(void *)(v373 + 16) = v374[2];
                    *(void *)(v374[2] + 8 * (*(void *)v374[2] != (void)v374)) = v373;
                    *(void *)uint64_t v373 = v374;
                    goto LABEL_609;
                  }
                  *(unsigned char *)(v373 + 24) = 1;
                  v371 = v374;
                  *((unsigned char *)v374 + 24) = v374 == v372;
                  unsigned char *v376 = 1;
                }
                while (v374 != v372);
              }
              ++v433;
            }
            v384 = [*((id *)v370 + 5) objectAtIndexedSubscript:v364];
            [v384 floatValue];
            float v386 = v385;

            v387 = v432;
            v388 = &v432;
LABEL_613:
            v389 = v388;
            if (v387)
            {
              while (1)
              {
                v388 = (uint64_t **)v387;
                unint64_t v390 = v387[4];
                if (v390 > (unint64_t)@">")
                {
                  v387 = *v388;
                  goto LABEL_613;
                }
                if (v390 >= (unint64_t)@">") {
                  break;
                }
                v387 = v388[1];
                if (!v387)
                {
                  v389 = v388 + 1;
                  goto LABEL_618;
                }
              }
              v391 = v388;
            }
            else
            {
LABEL_618:
              v391 = operator new(0x30uLL);
              *((void *)v391 + 4) = @">";
              *((void *)v391 + 5) = 0;
              *(void *)v391 = 0;
              *((void *)v391 + 1) = 0;
              *((void *)v391 + 2) = v388;
              *v389 = (uint64_t *)v391;
              v392 = (uint64_t *)v391;
              if (*v431)
              {
                v431 = (uint64_t **)*v431;
                v392 = *v389;
              }
              v393 = v432;
              BOOL v15 = v392 == v432;
              *((unsigned char *)v392 + 24) = v392 == v432;
              if (!v15)
              {
                do
                {
                  uint64_t v394 = v392[2];
                  if (*(unsigned char *)(v394 + 24)) {
                    break;
                  }
                  v395 = *(uint64_t **)(v394 + 16);
                  uint64_t v396 = *v395;
                  if (*v395 == v394)
                  {
                    uint64_t v399 = v395[1];
                    if (!v399 || (int v400 = *(unsigned __int8 *)(v399 + 24), v397 = (unsigned char *)(v399 + 24), v400))
                    {
                      if (*(uint64_t **)v394 == v392)
                      {
                        *(unsigned char *)(v394 + 24) = 1;
                        *((unsigned char *)v395 + 24) = 0;
                        uint64_t v403 = *(void *)(v394 + 8);
                        uint64_t *v395 = v403;
                        if (v403) {
                          goto LABEL_635;
                        }
                      }
                      else
                      {
                        v401 = *(uint64_t **)(v394 + 8);
                        uint64_t v402 = *v401;
                        *(void *)(v394 + 8) = *v401;
                        if (v402)
                        {
                          *(void *)(v402 + 16) = v394;
                          v395 = *(uint64_t **)(v394 + 16);
                        }
                        v401[2] = (uint64_t)v395;
                        *(void *)(*(void *)(v394 + 16) + 8 * (**(void **)(v394 + 16) != v394)) = v401;
                        uint64_t *v401 = v394;
                        *(void *)(v394 + 16) = v401;
                        v395 = (uint64_t *)v401[2];
                        uint64_t v394 = *v395;
                        *((unsigned char *)v401 + 24) = 1;
                        *((unsigned char *)v395 + 24) = 0;
                        uint64_t v403 = *(void *)(v394 + 8);
                        uint64_t *v395 = v403;
                        if (v403) {
LABEL_635:
                        }
                          *(void *)(v403 + 16) = v395;
                      }
                      *(void *)(v394 + 16) = v395[2];
                      *(void *)(v395[2] + 8 * (*(void *)v395[2] != (void)v395)) = v394;
                      *(void *)(v394 + 8) = v395;
LABEL_642:
                      v395[2] = v394;
                      break;
                    }
                  }
                  else if (!v396 || (int v398 = *(unsigned __int8 *)(v396 + 24), v397 = (unsigned char *)(v396 + 24), v398))
                  {
                    if (*(uint64_t **)v394 == v392)
                    {
                      uint64_t v408 = v392[1];
                      *(void *)uint64_t v394 = v408;
                      if (v408)
                      {
                        *(void *)(v408 + 16) = v394;
                        v395 = *(uint64_t **)(v394 + 16);
                      }
                      v392[2] = (uint64_t)v395;
                      *(void *)(*(void *)(v394 + 16) + 8 * (**(void **)(v394 + 16) != v394)) = v392;
                      v392[1] = v394;
                      *(void *)(v394 + 16) = v392;
                      v395 = (uint64_t *)v392[2];
                      *((unsigned char *)v392 + 24) = 1;
                      *((unsigned char *)v395 + 24) = 0;
                      uint64_t v394 = v395[1];
                      v404 = *(uint64_t **)v394;
                      v395[1] = *(void *)v394;
                      if (v404) {
LABEL_640:
                      }
                        v404[2] = (uint64_t)v395;
                    }
                    else
                    {
                      *(unsigned char *)(v394 + 24) = 1;
                      *((unsigned char *)v395 + 24) = 0;
                      uint64_t v394 = v395[1];
                      v404 = *(uint64_t **)v394;
                      v395[1] = *(void *)v394;
                      if (v404) {
                        goto LABEL_640;
                      }
                    }
                    *(void *)(v394 + 16) = v395[2];
                    *(void *)(v395[2] + 8 * (*(void *)v395[2] != (void)v395)) = v394;
                    *(void *)uint64_t v394 = v395;
                    goto LABEL_642;
                  }
                  *(unsigned char *)(v394 + 24) = 1;
                  v392 = v395;
                  *((unsigned char *)v395 + 24) = v395 == v393;
                  unsigned char *v397 = 1;
                }
                while (v395 != v393);
              }
              ++v433;
            }
            v405 = [*((id *)v391 + 5) objectAtIndexedSubscript:v364];
            [v405 floatValue];
            float v264 = v264 - (float)((float)(v386 * (float)(1.0 / v267)) * (float)(v386 * (float)(1.0 / v267)));
            float v365 = v365 - (float)((float)(v406 * (float)(1.0 / v266)) * (float)(v406 * (float)(1.0 / v266)));

            ++v364;
          }
          while (v436 > v364);
          goto LABEL_660;
        }
      }
      else
      {
        float v266 = 0.0;
        float v267 = 0.0;
      }
      float v365 = 1.0;
LABEL_660:
      *(float *)&double v409 = (float)((float)(v264 * v267) + (float)(v365 * v266)) / (float)[(NSArray *)v6 count];
      uint64_t v334 = [NSNumber numberWithFloat:v409];
      v410 = v438;
      v336 = &v438;
LABEL_662:
      v337 = v336;
      if (v410)
      {
        do
        {
          v336 = (uint64_t **)v410;
          unint64_t v411 = v410[4];
          if ((unint64_t)v428 < v411)
          {
            v410 = *v336;
            goto LABEL_662;
          }
          if (v411 >= (unint64_t)v428) {
            goto LABEL_669;
          }
          v410 = v336[1];
        }
        while (v410);
        v337 = v336 + 1;
      }
      goto LABEL_667;
    }
    float v240 = 1.0;
    if (v436)
    {
      unint64_t v241 = 0;
      float v242 = 0.0;
      do
      {
        v243 = v432;
        uint64_t v244 = &v432;
LABEL_353:
        v245 = v244;
        if (v243)
        {
          while (1)
          {
            uint64_t v244 = (uint64_t **)v243;
            unint64_t v246 = v243[4];
            if (v246 > (unint64_t)@">")
            {
              v243 = *v244;
              goto LABEL_353;
            }
            if (v246 >= (unint64_t)@">") {
              break;
            }
            v243 = v244[1];
            if (!v243)
            {
              v245 = v244 + 1;
              goto LABEL_358;
            }
          }
          v247 = v244;
        }
        else
        {
LABEL_358:
          v247 = operator new(0x30uLL);
          *((void *)v247 + 4) = @">";
          *((void *)v247 + 5) = 0;
          *(void *)v247 = 0;
          *((void *)v247 + 1) = 0;
          *((void *)v247 + 2) = v244;
          *v245 = (uint64_t *)v247;
          v248 = (uint64_t *)v247;
          if (*v431)
          {
            v431 = (uint64_t **)*v431;
            v248 = *v245;
          }
          v249 = v432;
          BOOL v15 = v248 == v432;
          *((unsigned char *)v248 + 24) = v248 == v432;
          if (!v15)
          {
            do
            {
              uint64_t v250 = v248[2];
              if (*(unsigned char *)(v250 + 24)) {
                break;
              }
              v251 = *(uint64_t **)(v250 + 16);
              uint64_t v252 = *v251;
              if (*v251 == v250)
              {
                uint64_t v255 = v251[1];
                if (!v255 || (int v256 = *(unsigned __int8 *)(v255 + 24), v253 = (unsigned char *)(v255 + 24), v256))
                {
                  if (*(uint64_t **)v250 == v248)
                  {
                    *(unsigned char *)(v250 + 24) = 1;
                    *((unsigned char *)v251 + 24) = 0;
                    uint64_t v259 = *(void *)(v250 + 8);
                    uint64_t *v251 = v259;
                    if (v259) {
                      goto LABEL_375;
                    }
                  }
                  else
                  {
                    v257 = *(uint64_t **)(v250 + 8);
                    uint64_t v258 = *v257;
                    *(void *)(v250 + 8) = *v257;
                    if (v258)
                    {
                      *(void *)(v258 + 16) = v250;
                      v251 = *(uint64_t **)(v250 + 16);
                    }
                    v257[2] = (uint64_t)v251;
                    *(void *)(*(void *)(v250 + 16) + 8 * (**(void **)(v250 + 16) != v250)) = v257;
                    uint64_t *v257 = v250;
                    *(void *)(v250 + 16) = v257;
                    v251 = (uint64_t *)v257[2];
                    uint64_t v250 = *v251;
                    *((unsigned char *)v257 + 24) = 1;
                    *((unsigned char *)v251 + 24) = 0;
                    uint64_t v259 = *(void *)(v250 + 8);
                    uint64_t *v251 = v259;
                    if (v259) {
LABEL_375:
                    }
                      *(void *)(v259 + 16) = v251;
                  }
                  *(void *)(v250 + 16) = v251[2];
                  *(void *)(v251[2] + 8 * (*(void *)v251[2] != (void)v251)) = v250;
                  *(void *)(v250 + 8) = v251;
LABEL_382:
                  v251[2] = v250;
                  break;
                }
              }
              else if (!v252 || (int v254 = *(unsigned __int8 *)(v252 + 24), v253 = (unsigned char *)(v252 + 24), v254))
              {
                if (*(uint64_t **)v250 == v248)
                {
                  uint64_t v263 = v248[1];
                  *(void *)uint64_t v250 = v263;
                  if (v263)
                  {
                    *(void *)(v263 + 16) = v250;
                    v251 = *(uint64_t **)(v250 + 16);
                  }
                  v248[2] = (uint64_t)v251;
                  *(void *)(*(void *)(v250 + 16) + 8 * (**(void **)(v250 + 16) != v250)) = v248;
                  v248[1] = v250;
                  *(void *)(v250 + 16) = v248;
                  v251 = (uint64_t *)v248[2];
                  *((unsigned char *)v248 + 24) = 1;
                  *((unsigned char *)v251 + 24) = 0;
                  uint64_t v250 = v251[1];
                  v260 = *(uint64_t **)v250;
                  v251[1] = *(void *)v250;
                  if (v260) {
LABEL_380:
                  }
                    v260[2] = (uint64_t)v251;
                }
                else
                {
                  *(unsigned char *)(v250 + 24) = 1;
                  *((unsigned char *)v251 + 24) = 0;
                  uint64_t v250 = v251[1];
                  v260 = *(uint64_t **)v250;
                  v251[1] = *(void *)v250;
                  if (v260) {
                    goto LABEL_380;
                  }
                }
                *(void *)(v250 + 16) = v251[2];
                *(void *)(v251[2] + 8 * (*(void *)v251[2] != (void)v251)) = v250;
                *(void *)uint64_t v250 = v251;
                goto LABEL_382;
              }
              *(unsigned char *)(v250 + 24) = 1;
              v248 = v251;
              *((unsigned char *)v251 + 24) = v251 == v249;
              unsigned char *v253 = 1;
            }
            while (v251 != v249);
          }
          ++v433;
        }
        v261 = [*((id *)v247 + 5) objectAtIndexedSubscript:v241];
        [v261 floatValue];
        float v242 = v262 + v242;

        ++v241;
      }
      while (v436 > v241);
      if (v436)
      {
        unint64_t v311 = 0;
        float v240 = 1.0;
        float v312 = 1.0 / v242;
        do
        {
          v313 = v432;
          v314 = &v432;
LABEL_478:
          v315 = v314;
          if (v313)
          {
            while (1)
            {
              v314 = (uint64_t **)v313;
              unint64_t v316 = v313[4];
              if (v316 > (unint64_t)@">")
              {
                v313 = *v314;
                goto LABEL_478;
              }
              if (v316 >= (unint64_t)@">") {
                break;
              }
              v313 = v314[1];
              if (!v313)
              {
                v315 = v314 + 1;
                goto LABEL_483;
              }
            }
            v317 = v314;
          }
          else
          {
LABEL_483:
            v317 = operator new(0x30uLL);
            *((void *)v317 + 4) = @">";
            *((void *)v317 + 5) = 0;
            *(void *)v317 = 0;
            *((void *)v317 + 1) = 0;
            *((void *)v317 + 2) = v314;
            *v315 = (uint64_t *)v317;
            v318 = (uint64_t *)v317;
            if (*v431)
            {
              v431 = (uint64_t **)*v431;
              v318 = *v315;
            }
            v319 = v432;
            BOOL v15 = v318 == v432;
            *((unsigned char *)v318 + 24) = v318 == v432;
            if (!v15)
            {
              do
              {
                uint64_t v320 = v318[2];
                if (*(unsigned char *)(v320 + 24)) {
                  break;
                }
                v321 = *(uint64_t **)(v320 + 16);
                uint64_t v322 = *v321;
                if (*v321 == v320)
                {
                  uint64_t v325 = v321[1];
                  if (!v325 || (int v326 = *(unsigned __int8 *)(v325 + 24), v323 = (unsigned char *)(v325 + 24), v326))
                  {
                    if (*(uint64_t **)v320 == v318)
                    {
                      *(unsigned char *)(v320 + 24) = 1;
                      *((unsigned char *)v321 + 24) = 0;
                      uint64_t v329 = *(void *)(v320 + 8);
                      uint64_t *v321 = v329;
                      if (v329) {
                        goto LABEL_500;
                      }
                    }
                    else
                    {
                      v327 = *(uint64_t **)(v320 + 8);
                      uint64_t v328 = *v327;
                      *(void *)(v320 + 8) = *v327;
                      if (v328)
                      {
                        *(void *)(v328 + 16) = v320;
                        v321 = *(uint64_t **)(v320 + 16);
                      }
                      v327[2] = (uint64_t)v321;
                      *(void *)(*(void *)(v320 + 16) + 8 * (**(void **)(v320 + 16) != v320)) = v327;
                      uint64_t *v327 = v320;
                      *(void *)(v320 + 16) = v327;
                      v321 = (uint64_t *)v327[2];
                      uint64_t v320 = *v321;
                      *((unsigned char *)v327 + 24) = 1;
                      *((unsigned char *)v321 + 24) = 0;
                      uint64_t v329 = *(void *)(v320 + 8);
                      uint64_t *v321 = v329;
                      if (v329) {
LABEL_500:
                      }
                        *(void *)(v329 + 16) = v321;
                    }
                    *(void *)(v320 + 16) = v321[2];
                    *(void *)(v321[2] + 8 * (*(void *)v321[2] != (void)v321)) = v320;
                    *(void *)(v320 + 8) = v321;
LABEL_507:
                    v321[2] = v320;
                    break;
                  }
                }
                else if (!v322 || (int v324 = *(unsigned __int8 *)(v322 + 24), v323 = (unsigned char *)(v322 + 24), v324))
                {
                  if (*(uint64_t **)v320 == v318)
                  {
                    uint64_t v333 = v318[1];
                    *(void *)uint64_t v320 = v333;
                    if (v333)
                    {
                      *(void *)(v333 + 16) = v320;
                      v321 = *(uint64_t **)(v320 + 16);
                    }
                    v318[2] = (uint64_t)v321;
                    *(void *)(*(void *)(v320 + 16) + 8 * (**(void **)(v320 + 16) != v320)) = v318;
                    v318[1] = v320;
                    *(void *)(v320 + 16) = v318;
                    v321 = (uint64_t *)v318[2];
                    *((unsigned char *)v318 + 24) = 1;
                    *((unsigned char *)v321 + 24) = 0;
                    uint64_t v320 = v321[1];
                    v330 = *(uint64_t **)v320;
                    v321[1] = *(void *)v320;
                    if (v330) {
LABEL_505:
                    }
                      v330[2] = (uint64_t)v321;
                  }
                  else
                  {
                    *(unsigned char *)(v320 + 24) = 1;
                    *((unsigned char *)v321 + 24) = 0;
                    uint64_t v320 = v321[1];
                    v330 = *(uint64_t **)v320;
                    v321[1] = *(void *)v320;
                    if (v330) {
                      goto LABEL_505;
                    }
                  }
                  *(void *)(v320 + 16) = v321[2];
                  *(void *)(v321[2] + 8 * (*(void *)v321[2] != (void)v321)) = v320;
                  *(void *)uint64_t v320 = v321;
                  goto LABEL_507;
                }
                *(unsigned char *)(v320 + 24) = 1;
                v318 = v321;
                *((unsigned char *)v321 + 24) = v321 == v319;
                unsigned char *v323 = 1;
              }
              while (v321 != v319);
            }
            ++v433;
          }
          v331 = [*((id *)v317 + 5) objectAtIndexedSubscript:v311];
          [v331 floatValue];
          float v240 = v240 - (float)((float)(v332 * v312) * (float)(v332 * v312));

          ++v311;
        }
        while (v436 > v311);
      }
    }
    *(float *)&double v214 = v240;
    uint64_t v334 = [NSNumber numberWithFloat:v214];
    v335 = v438;
    v336 = &v438;
LABEL_519:
    v337 = v336;
    if (!v335) {
      goto LABEL_667;
    }
    while (1)
    {
      v336 = (uint64_t **)v335;
      unint64_t v338 = v335[4];
      if ((unint64_t)v428 < v338)
      {
        v335 = *v336;
        goto LABEL_519;
      }
      if (v338 >= (unint64_t)v428) {
        break;
      }
      v335 = v336[1];
      if (!v335)
      {
        v337 = v336 + 1;
        goto LABEL_667;
      }
    }
LABEL_669:
    v412 = (uint64_t *)v336;
LABEL_33:
    uint64_t v30 = (void *)v412[5];
    v412[5] = v334;
  }
  *a3 = &unk_26E94BA38;
  a3[1] = &unk_26E94BA38;
  v414 = v437;
  if (v437 != &v438)
  {
    v415 = (uint64_t *)&unk_26E94BA38;
    do
    {
      [v414[5] floatValue];
      float v417 = v416;
      [v415 floatValue];
      if (v417 < v418)
      {
        v419 = v414[4];
        v420 = v414[5];
        v421 = *a3;
        *a3 = v419;

        a3[1] = v420;
        v415 = v420;
      }
      v422 = v414[1];
      if (v422)
      {
        do
        {
          v423 = (uint64_t **)v422;
          v422 = (uint64_t *)*v422;
        }
        while (v422);
      }
      else
      {
        do
        {
          v423 = (uint64_t **)v414[2];
          BOOL v15 = *v423 == (uint64_t *)v414;
          v414 = v423;
        }
        while (!v15);
      }
      v414 = v423;
    }
    while (v423 != &v438);
  }
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v431, v432);

  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v434, v435);
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v437, v438);
}

void sub_235EDEB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, uint64_t a19, char a20,void *a21,uint64_t a22,char a23,void *a24,uint64_t a25,char a26,void *a27)
{
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&a23, a24);
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&a26, a27);

  _Unwind_Resume(a1);
}

void GKCDecisionTree::splitOnValueOfAttribute(GKCDecisionTree *this@<X0>, NSArray *a2@<X1>, NSNumber *a3@<X2>, uint64_t a4@<X3>, void **a5@<X8>)
{
  v62[2] = *MEMORY[0x263EF8340];
  unint64_t v7 = a2;
  id v8 = a3;
  a5[1] = 0;
  id v9 = a5 + 1;
  a5[2] = 0;
  *a5 = a5 + 1;
  v61[0] = @"predicate";
  unint64_t v53 = v7;
  uint64_t v57 = v8;
  uint64_t v10 = [MEMORY[0x263F08A98] predicateWithFormat:@"SELF <= %@", v8];
  v61[1] = @"value";
  v62[0] = v10;
  v62[1] = v8;
  uint64_t v55 = [NSDictionary dictionaryWithObjects:v62 forKeys:v61 count:2];

  v59[0] = @"predicate";
  id v11 = [MEMORY[0x263F08A98] predicateWithFormat:@"SELF > %@", v8];
  v59[1] = @"value";
  v60[0] = v11;
  v60[1] = v8;
  uint64_t v56 = [NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:2];

  unint64_t v12 = 0;
  int v13 = 0;
  while ([(NSArray *)v7 count] > v12)
  {
    id v14 = [(NSArray *)v7 objectAtIndexedSubscript:v12];
    uint64_t v58 = [v14 objectAtIndexedSubscript:a4];

    [v58 floatValue];
    float v16 = v15;
    [(NSNumber *)v57 floatValue];
    unint64_t v17 = v55;
    if (v16 > v18) {
      unint64_t v17 = v56;
    }
    id v19 = v17;

    id v20 = v19;
    int v13 = v20;
    id v21 = *v9;
    uint64_t v22 = a5 + 1;
    unint64_t v23 = a5 + 1;
    if (*v9)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v23 = (uint64_t **)v21;
          unint64_t v24 = v21[4];
          if ((unint64_t)v20 >= v24) {
            break;
          }
          id v21 = *v23;
          uint64_t v22 = v23;
          if (!*v23) {
            goto LABEL_12;
          }
        }
        if (v24 >= (unint64_t)v20) {
          break;
        }
        id v21 = v23[1];
        if (!v21)
        {
          uint64_t v22 = v23 + 1;
          goto LABEL_12;
        }
      }
      long long v28 = v20;
      uint64_t v25 = (uint64_t *)v23;
    }
    else
    {
LABEL_12:
      uint64_t v25 = (uint64_t *)operator new(0x30uLL);
      v25[4] = (uint64_t)v13;
      v25[5] = 0;
      uint64_t *v25 = 0;
      v25[1] = 0;
      v25[2] = (uint64_t)v23;
      *uint64_t v22 = v25;
      unint64_t v26 = (void *)**a5;
      uint64_t v27 = v25;
      if (v26)
      {
        *a5 = v26;
        uint64_t v27 = *v22;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a5[1], v27);
      long long v28 = 0;
      a5[2] = (void *)((char *)a5[2] + 1);
    }
    BOOL v29 = v25[5] == 0;

    if (v29)
    {
      id v40 = objc_alloc(MEMORY[0x263EFF980]);
      float v39 = [(NSArray *)v7 objectAtIndexedSubscript:v12];
      uint64_t v41 = objc_msgSend(v40, "initWithObjects:", v39, 0);
      id v42 = v13;
      unint64_t v43 = v42;
      unint64_t v44 = *v9;
      double v45 = a5 + 1;
      uint64_t v46 = a5 + 1;
      if (*v9)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v46 = (uint64_t **)v44;
            unint64_t v47 = v44[4];
            if ((unint64_t)v42 >= v47) {
              break;
            }
            unint64_t v44 = *v46;
            double v45 = v46;
            if (!*v46) {
              goto LABEL_34;
            }
          }
          if (v47 >= (unint64_t)v42) {
            break;
          }
          unint64_t v44 = v46[1];
          if (!v44)
          {
            double v45 = v46 + 1;
            goto LABEL_34;
          }
        }
        unint64_t v48 = (uint64_t *)v46;
      }
      else
      {
LABEL_34:
        unint64_t v48 = (uint64_t *)operator new(0x30uLL);
        v48[4] = (uint64_t)v43;
        v48[5] = 0;
        *unint64_t v48 = 0;
        v48[1] = 0;
        v48[2] = (uint64_t)v46;
        void *v45 = v48;
        uint64_t v49 = (void *)**a5;
        uint64_t v50 = v48;
        if (v49)
        {
          *a5 = v49;
          uint64_t v50 = *v45;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a5[1], v50);
        unint64_t v43 = 0;
        a5[2] = (void *)((char *)a5[2] + 1);
      }
      uint64_t v52 = (void *)v48[5];
      v48[5] = v41;

      unint64_t v7 = v53;
    }
    else
    {
      id v30 = v13;
      uint64_t v31 = (uint64_t)v30;
      long long v32 = *v9;
      long long v33 = a5 + 1;
      float v34 = a5 + 1;
      if (*v9)
      {
        while (1)
        {
          while (1)
          {
            float v34 = (uint64_t **)v32;
            unint64_t v35 = v32[4];
            if ((unint64_t)v30 >= v35) {
              break;
            }
            long long v32 = *v34;
            long long v33 = v34;
            if (!*v34) {
              goto LABEL_24;
            }
          }
          if (v35 >= (unint64_t)v30) {
            break;
          }
          long long v32 = v34[1];
          if (!v32)
          {
            long long v33 = v34 + 1;
            goto LABEL_24;
          }
        }
        float v39 = v30;
        float v36 = (uint64_t *)v34;
      }
      else
      {
LABEL_24:
        float v36 = (uint64_t *)operator new(0x30uLL);
        v36[4] = v31;
        v36[5] = 0;
        *float v36 = 0;
        v36[1] = 0;
        v36[2] = (uint64_t)v34;
        void *v33 = v36;
        float v37 = (void *)**a5;
        int32x2_t v38 = v36;
        if (v37)
        {
          *a5 = v37;
          int32x2_t v38 = *v33;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a5[1], v38);
        float v39 = 0;
        a5[2] = (void *)((char *)a5[2] + 1);
      }
      int v51 = (void *)v36[5];
      unint64_t v43 = [(NSArray *)v7 objectAtIndexedSubscript:v12];
      [v51 addObject:v43];
    }

    ++v12;
  }
}

void sub_235EDF210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, void *a14)
{
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(v15, *(void **)(v15 + 8));
  _Unwind_Resume(a1);
}

id *std::pair<NSNumber * {__strong},NSNumber * {__strong}>::~pair(id *a1)
{
  return a1;
}

void GKCDecisionTree::binarySplitByAttributeValue(GKCDecisionTree *this@<X0>, NSArray *a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  v70[2] = *MEMORY[0x263EF8340];
  unint64_t v7 = a2;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  uint64_t v60 = v7;
  GKCDecisionTree::multiwaySplitByAttributeValue(this, v7, a3, &v67);
  id v8 = v67;
  if (v67 != (uint64_t *)v68)
  {
    int v61 = a4;
    do
    {
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      unint64_t v64 = &v65;
      id v9 = (void *)v8[4];
      uint64_t v10 = (void *)v8[5];
      id v11 = operator new(0x30uLL);
      *((void *)v11 + 4) = v9;
      *((void *)v11 + 5) = 0;
      *(void *)id v11 = 0;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = &v65;
      uint64_t v65 = (uint64_t *)v11;
      if (*v64) {
        unint64_t v64 = (uint64_t **)*v64;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v11, (uint64_t *)v11);
      ++v66;
      objc_storeStrong((id *)v11 + 5, v10);
      unint64_t v12 = v61;
      id v13 = objc_alloc_init(MEMORY[0x263EFF980]);
      id v14 = v67;
      if (v67 != (uint64_t *)v68)
      {
        do
        {
          BOOL v22 = v14[4] == v8[4] && v14[5] == v8[5];
          if (!v22) {
            objc_msgSend(v13, "addObjectsFromArray:");
          }
          unint64_t v23 = (uint64_t *)v14[1];
          if (v23)
          {
            do
            {
              unint64_t v24 = v23;
              unint64_t v23 = (uint64_t *)*v23;
            }
            while (v23);
          }
          else
          {
            do
            {
              unint64_t v24 = (uint64_t *)v14[2];
              BOOL v22 = *v24 == (void)v14;
              id v14 = v24;
            }
            while (!v22);
          }
          id v14 = v24;
        }
        while (v24 != (uint64_t *)v68);
      }
      int v63 = v13;
      uint64_t v15 = [MEMORY[0x263F08A98] predicateWithFormat:@"SELF != %@", v8[4], v60];
      v69[0] = @"predicate";
      v69[1] = @"value";
      uint64_t v16 = v8[4];
      v70[0] = v15;
      v70[1] = v16;
      unint64_t v17 = [NSDictionary dictionaryWithObjects:v70 forKeys:v69 count:2];
      float v18 = (void *)v17;
      uint64_t v62 = (void *)v15;
      id v19 = v65;
      id v20 = &v65;
      id v21 = &v65;
      if (v65)
      {
        while (1)
        {
          while (1)
          {
            id v21 = (uint64_t **)v19;
            unint64_t v25 = v19[4];
            if (v17 >= v25) {
              break;
            }
            id v19 = *v21;
            id v20 = v21;
            if (!*v21) {
              goto LABEL_26;
            }
          }
          if (v25 >= v17) {
            break;
          }
          id v19 = v21[1];
          if (!v19)
          {
            id v20 = v21 + 1;
            goto LABEL_26;
          }
        }
        unint64_t v26 = v21;
      }
      else
      {
LABEL_26:
        unint64_t v26 = operator new(0x30uLL);
        *((void *)v26 + 4) = v18;
        *((void *)v26 + 5) = 0;
        *(void *)unint64_t v26 = 0;
        *((void *)v26 + 1) = 0;
        *((void *)v26 + 2) = v21;
        *id v20 = (uint64_t *)v26;
        uint64_t v27 = (uint64_t *)v26;
        if (*v64)
        {
          unint64_t v64 = (uint64_t **)*v64;
          uint64_t v27 = *v20;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v65, v27);
        float v18 = 0;
        ++v66;
      }
      long long v28 = v62;
      objc_storeStrong((id *)v26 + 5, v63);

      BOOL v29 = v61[1];
      if (v29 >= v61[2])
      {
        uint64_t v57 = std::vector<std::map<objc_object * {__strong},NSMutableArray * {__strong}>>::__push_back_slow_path<std::allocator<std::pair<objc_object * const {__strong},NSMutableArray * {__strong}>> const&>(v61, &v64);
      }
      else
      {
        *((void *)v29 + 1) = 0;
        id v30 = (void **)(v29 + 8);
        *((void *)v29 + 2) = 0;
        *(void *)BOOL v29 = v29 + 8;
        uint64_t v31 = v64;
        if (v64 != &v65)
        {
          long long v32 = 0;
          long long v33 = v29 + 8;
LABEL_45:
          if (v32) {
            int32x2_t v38 = v33;
          }
          else {
            int32x2_t v38 = v29 + 8;
          }
          if (v32) {
            float v37 = v33 + 1;
          }
          else {
            float v37 = v29 + 8;
          }
          if (!*v37)
          {
            do
            {
LABEL_54:
              uint64_t v41 = operator new(0x30uLL);
              v41[4] = v31[4];
              v41[5] = v31[5];
              *uint64_t v41 = 0;
              v41[1] = 0;
              v41[2] = v38;
              *float v37 = v41;
              uint64_t v42 = **(void **)v29;
              if (v42)
              {
                *(void *)BOOL v29 = v42;
                uint64_t v41 = (void *)*v37;
              }
              unint64_t v43 = *v30;
              BOOL v22 = v41 == *v30;
              *((unsigned char *)v41 + 24) = v22;
              if (!v22)
              {
                do
                {
                  uint64_t v44 = v41[2];
                  if (*(unsigned char *)(v44 + 24)) {
                    break;
                  }
                  double v45 = *(unsigned char **)(v44 + 16);
                  uint64_t v46 = *(void *)v45;
                  if (*(void *)v45 == v44)
                  {
                    uint64_t v49 = *((void *)v45 + 1);
                    if (!v49 || (v50 = *(unsigned __int8 *)(v49 + 24), unint64_t v47 = (unsigned char *)(v49 + 24), v50))
                    {
                      if (*(void **)v44 == v41)
                      {
                        *(unsigned char *)(v44 + 24) = 1;
                        v45[24] = 0;
                        uint64_t v53 = *(void *)(v44 + 8);
                        *(void *)double v45 = v53;
                        if (v53) {
                          goto LABEL_71;
                        }
                      }
                      else
                      {
                        int v51 = *(uint64_t **)(v44 + 8);
                        uint64_t v52 = *v51;
                        *(void *)(v44 + 8) = *v51;
                        if (v52)
                        {
                          *(void *)(v52 + 16) = v44;
                          double v45 = *(unsigned char **)(v44 + 16);
                        }
                        v51[2] = (uint64_t)v45;
                        *(void *)(*(void *)(v44 + 16) + 8 * (**(void **)(v44 + 16) != v44)) = v51;
                        *int v51 = v44;
                        *(void *)(v44 + 16) = v51;
                        double v45 = (unsigned char *)v51[2];
                        uint64_t v44 = *(void *)v45;
                        *((unsigned char *)v51 + 24) = 1;
                        v45[24] = 0;
                        uint64_t v53 = *(void *)(v44 + 8);
                        *(void *)double v45 = v53;
                        if (v53) {
LABEL_71:
                        }
                          *(void *)(v53 + 16) = v45;
                      }
                      *(void *)(v44 + 16) = *((void *)v45 + 2);
                      *(void *)(*((void *)v45 + 2) + 8 * (**((void **)v45 + 2) != (void)v45)) = v44;
                      *(void *)(v44 + 8) = v45;
LABEL_77:
                      *((void *)v45 + 2) = v44;
                      break;
                    }
                  }
                  else if (!v46 || (v48 = *(unsigned __int8 *)(v46 + 24), unint64_t v47 = (unsigned char *)(v46 + 24), v48))
                  {
                    if (*(void **)v44 == v41)
                    {
                      uint64_t v56 = v41[1];
                      *(void *)uint64_t v44 = v56;
                      if (v56)
                      {
                        *(void *)(v56 + 16) = v44;
                        double v45 = *(unsigned char **)(v44 + 16);
                      }
                      v41[2] = v45;
                      *(void *)(*(void *)(v44 + 16) + 8 * (**(void **)(v44 + 16) != v44)) = v41;
                      v41[1] = v44;
                      *(void *)(v44 + 16) = v41;
                      double v45 = (unsigned char *)v41[2];
                      *((unsigned char *)v41 + 24) = 1;
                      v45[24] = 0;
                      uint64_t v44 = *((void *)v45 + 1);
                      uint64_t v54 = *(void **)v44;
                      *((void *)v45 + 1) = *(void *)v44;
                      if (v54) {
LABEL_75:
                      }
                        v54[2] = v45;
                    }
                    else
                    {
                      *(unsigned char *)(v44 + 24) = 1;
                      v45[24] = 0;
                      uint64_t v44 = *((void *)v45 + 1);
                      uint64_t v54 = *(void **)v44;
                      *((void *)v45 + 1) = *(void *)v44;
                      if (v54) {
                        goto LABEL_75;
                      }
                    }
                    *(void *)(v44 + 16) = *((void *)v45 + 2);
                    *(void *)(*((void *)v45 + 2) + 8 * (**((void **)v45 + 2) != (void)v45)) = v44;
                    *(void *)uint64_t v44 = v45;
                    goto LABEL_77;
                  }
                  *(unsigned char *)(v44 + 24) = 1;
                  uint64_t v41 = v45;
                  v45[24] = v45 == (unsigned char *)v43;
                  *unint64_t v47 = 1;
                }
                while (v45 != (unsigned char *)v43);
              }
              ++*((void *)v29 + 2);
              id v40 = v31[1];
              if (!v40) {
                goto LABEL_81;
              }
              do
              {
LABEL_79:
                uint64_t v55 = (uint64_t **)v40;
                id v40 = (uint64_t *)*v40;
              }
              while (v40);
LABEL_83:
              if (v55 == &v65) {
                goto LABEL_93;
              }
              long long v32 = (void *)*((void *)v29 + 1);
              uint64_t v31 = v55;
              long long v33 = v29 + 8;
              if (*(void ***)v29 == v30) {
                goto LABEL_45;
              }
              float v34 = (void *)*((void *)v29 + 1);
              unint64_t v35 = v29 + 8;
              if (v32)
              {
                do
                {
                  long long v33 = v34;
                  float v34 = (void *)v34[1];
                }
                while (v34);
              }
              else
              {
                do
                {
                  long long v33 = (void *)v35[2];
                  BOOL v22 = *v33 == (void)v35;
                  unint64_t v35 = v33;
                }
                while (v22);
              }
              float v36 = v31[4];
              if (v33[4] < (unint64_t)v36) {
                goto LABEL_45;
              }
              float v37 = v29 + 8;
              int32x2_t v38 = v29 + 8;
            }
            while (!v32);
            while (1)
            {
              while (1)
              {
                int32x2_t v38 = v32;
                unint64_t v39 = v32[4];
                if ((unint64_t)v36 >= v39) {
                  break;
                }
                long long v32 = (void *)*v38;
                float v37 = v38;
                if (!*v38) {
                  goto LABEL_54;
                }
              }
              if (v39 >= (unint64_t)v36) {
                break;
              }
              long long v32 = (void *)v38[1];
              if (!v32)
              {
                float v37 = v38 + 1;
                goto LABEL_54;
              }
            }
          }
          id v40 = v31[1];
          if (v40) {
            goto LABEL_79;
          }
          do
          {
LABEL_81:
            uint64_t v55 = (uint64_t **)v31[2];
            BOOL v22 = *v55 == (uint64_t *)v31;
            uint64_t v31 = v55;
          }
          while (!v22);
          goto LABEL_83;
        }
LABEL_93:
        uint64_t v57 = v29 + 24;
        unint64_t v12 = v61;
        long long v28 = v62;
        v61[1] = v29 + 24;
      }
      v12[1] = v57;

      std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v64, v65);
      uint64_t v58 = (uint64_t *)v8[1];
      if (v58)
      {
        do
        {
          uint64_t v59 = v58;
          uint64_t v58 = (uint64_t *)*v58;
        }
        while (v58);
      }
      else
      {
        do
        {
          uint64_t v59 = (uint64_t *)v8[2];
          BOOL v22 = *v59 == (void)v8;
          id v8 = v59;
        }
        while (!v22);
      }
      id v8 = v59;
    }
    while (v59 != (uint64_t *)v68);
  }
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v67, v68[0]);
}

void sub_235EDF98C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  std::vector<std::map<objc_object * {__strong},NSMutableArray * {__strong}>>::~vector[abi:ne180100](v10);

  _Unwind_Resume(a1);
}

void **std::vector<std::map<objc_object * {__strong},NSMutableArray * {__strong}>>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    id v3 = (char *)a1[1];
    id v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        id v5 = v3 - 24;
        std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)(v3 - 24), *((void **)v3 - 2));
        id v3 = v5;
      }
      while (v5 != v2);
      id v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void GKCDecisionTree::splitByAttribute(GKCDecisionTree *this@<X0>, NSArray *a2@<X1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  float v37 = a2;
  unint64_t v6 = 0;
  a4[1] = 0;
  unint64_t v7 = a4 + 1;
  a4[2] = 0;
  *a4 = a4 + 1;
  for (unint64_t i = [(NSArray *)v37 count]; i > v6; unint64_t i = [(NSArray *)v37 count])
  {
    uint64_t v10 = [(NSArray *)v37 objectAtIndexedSubscript:v6];
    id v11 = [v10 objectAtIndexedSubscript:a3];

    unint64_t v12 = *v7;
    id v13 = a4 + 1;
    id v14 = a4 + 1;
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          id v14 = (uint64_t **)v12;
          unint64_t v15 = v12[4];
          if ((unint64_t)v11 >= v15) {
            break;
          }
          unint64_t v12 = *v14;
          id v13 = v14;
          if (!*v14) {
            goto LABEL_13;
          }
        }
        if (v15 >= (unint64_t)v11) {
          break;
        }
        unint64_t v12 = v14[1];
        if (!v12)
        {
          id v13 = v14 + 1;
          goto LABEL_13;
        }
      }
      if (v14[5])
      {
LABEL_16:
        id v19 = *v7;
        id v20 = a4 + 1;
        id v21 = a4 + 1;
        if (*v7)
        {
          while (1)
          {
            while (1)
            {
              id v21 = (uint64_t **)v19;
              unint64_t v22 = v19[4];
              if ((unint64_t)v11 >= v22) {
                break;
              }
              id v19 = *v21;
              id v20 = v21;
              if (!*v21) {
                goto LABEL_23;
              }
            }
            if (v22 >= (unint64_t)v11) {
              break;
            }
            id v19 = v21[1];
            if (!v19)
            {
              id v20 = v21 + 1;
              goto LABEL_23;
            }
          }
          unint64_t v23 = (uint64_t *)v21;
        }
        else
        {
LABEL_23:
          unint64_t v23 = (uint64_t *)operator new(0x30uLL);
          v23[4] = (uint64_t)v11;
          v23[5] = 0;
          uint64_t *v23 = 0;
          v23[1] = 0;
          v23[2] = (uint64_t)v21;
          *id v20 = v23;
          unint64_t v24 = (void *)**a4;
          unint64_t v25 = v23;
          if (v24)
          {
            *a4 = v24;
            unint64_t v25 = *v20;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a4[1], v25);
          a4[2] = (void *)((char *)a4[2] + 1);
        }
        float v36 = (void *)v23[5];
        uint64_t v27 = [(NSArray *)v37 objectAtIndexedSubscript:v6];
        [v36 addObject:v27];
        goto LABEL_4;
      }
    }
    else
    {
LABEL_13:
      uint64_t v16 = (uint64_t *)operator new(0x30uLL);
      v16[4] = (uint64_t)v11;
      v16[5] = 0;
      uint64_t *v16 = 0;
      v16[1] = 0;
      v16[2] = (uint64_t)v14;
      *id v13 = v16;
      unint64_t v17 = (void *)**a4;
      float v18 = v16;
      if (v17)
      {
        *a4 = v17;
        float v18 = *v13;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a4[1], v18);
      a4[2] = (void *)((char *)a4[2] + 1);
      if (v16[5]) {
        goto LABEL_16;
      }
    }
    id v26 = objc_alloc(MEMORY[0x263EFF980]);
    uint64_t v27 = [(NSArray *)v37 objectAtIndexedSubscript:v6];
    uint64_t v28 = objc_msgSend(v26, "initWithObjects:", v27, 0);
    BOOL v29 = *v7;
    id v30 = a4 + 1;
    uint64_t v31 = a4 + 1;
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v31 = (uint64_t **)v29;
          unint64_t v32 = v29[4];
          if ((unint64_t)v11 >= v32) {
            break;
          }
          BOOL v29 = *v31;
          id v30 = v31;
          if (!*v31) {
            goto LABEL_34;
          }
        }
        if (v32 >= (unint64_t)v11) {
          break;
        }
        BOOL v29 = v31[1];
        if (!v29)
        {
          id v30 = v31 + 1;
          goto LABEL_34;
        }
      }
      long long v33 = (uint64_t *)v31;
    }
    else
    {
LABEL_34:
      long long v33 = (uint64_t *)operator new(0x30uLL);
      v33[4] = (uint64_t)v11;
      v33[5] = 0;
      uint64_t *v33 = 0;
      v33[1] = 0;
      v33[2] = (uint64_t)v31;
      *id v30 = v33;
      float v34 = (void *)**a4;
      unint64_t v35 = v33;
      if (v34)
      {
        *a4 = v34;
        unint64_t v35 = *v30;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a4[1], v35);
      a4[2] = (void *)((char *)a4[2] + 1);
    }
    id v9 = (void *)v33[5];
    v33[5] = v28;

LABEL_4:
    ++v6;
  }
}

void sub_235EDFDA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(v10, *(void **)(v10 + 8));
  _Unwind_Resume(a1);
}

void GKCDecisionTree::splitOnIndex(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v5 = a3;
  if (*(void *)a4 != a4 + 8)
  {
    id v6 = *(id *)(*(void *)a4 + 32);
    operator new();
  }
}

void sub_235EDFFE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_235EE0000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GKCDecisionTree::sortByAttributeWithAction(uint64_t a1, void *a2)
{
  v17[2] = *MEMORY[0x263EF8340];
  id v3 = objc_alloc_init(MEMORY[0x263EFF980]);
  id v6 = (void *)*a2;
  id v4 = a2 + 1;
  id v5 = v6;
  if (v6 != v4)
  {
    do
    {
      for (unint64_t i = 0; [(id)v5[5] count] > i; ++i)
      {
        id v8 = (void *)v5[5];
        v17[0] = v5[4];
        id v9 = [v8 objectAtIndexedSubscript:i];
        uint64_t v10 = [v9 lastObject];
        v17[1] = v10;
        id v11 = [MEMORY[0x263EFF8C0] arrayWithObjects:v17 count:2];

        [v3 addObject:v11];
      }
      unint64_t v12 = (void *)v5[1];
      if (v12)
      {
        do
        {
          id v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          id v13 = (void *)v5[2];
          BOOL v14 = *v13 == (void)v5;
          id v5 = v13;
        }
        while (!v14);
      }
      id v5 = v13;
    }
    while (v13 != v4);
  }
  unint64_t v15 = [v3 sortedArrayUsingComparator:&__block_literal_global_1];

  return v15;
}

void sub_235EE0184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN15GKCDecisionTree25sortByAttributeWithActionENSt3__13mapIU8__strongP11objc_objectU8__strongP14NSMutableArrayNS0_4lessIS4_EENS0_9allocatorINS0_4pairIU8__strongKS3_S7_EEEEEE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  id v6 = [v4 firstObject];
  [v6 floatValue];
  float v8 = v7;
  id v9 = [v5 firstObject];
  [v9 floatValue];
  float v11 = v10;

  if (v8 <= v11)
  {
    id v13 = [v4 firstObject];
    [v13 floatValue];
    float v15 = v14;
    uint64_t v16 = [v5 firstObject];
    [v16 floatValue];
    float v18 = v17;

    if (v15 >= v18) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = -1;
    }
  }
  else
  {
    uint64_t v12 = 1;
  }

  return v12;
}

void sub_235EE029C(_Unwind_Exception *a1)
{
  id v5 = v4;

  _Unwind_Resume(a1);
}

void sub_235EE02D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE02EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__emplace_hint_unique_key_args<objc_object * {__strong},std::pair<objc_object * const {__strong},NSMutableArray * {__strong}> const&>(void **a1, void *a2, unint64_t *a3, id *a4)
{
  id v6 = (uint64_t **)std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__find_equal<objc_object * {__strong}>(a1, a2, &v14, &v13, a3);
  if (*v6) {
    return *v6;
  }
  float v8 = v6;
  id v9 = (uint64_t *)operator new(0x30uLL);
  v9[4] = (uint64_t)*a4;
  v9[5] = (uint64_t)a4[1];
  uint64_t v10 = v14;
  *id v9 = 0;
  v9[1] = 0;
  v9[2] = v10;
  *float v8 = v9;
  float v11 = (void *)**a1;
  uint64_t v12 = v9;
  if (v11)
  {
    *a1 = v11;
    uint64_t v12 = *v8;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v12);
  a1[2] = (void *)((char *)a1[2] + 1);
  return v9;
}

void *std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__find_equal<objc_object * {__strong}>(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  id v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unint64_t v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      id v9 = (void *)*a2;
      do
      {
        uint64_t v10 = v9;
        id v9 = (void *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v10 = (void *)v14[2];
        BOOL v15 = *v10 == (void)v14;
        uint64_t v14 = v10;
      }
      while (v15);
    }
    unint64_t v16 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    float v18 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          id v19 = v18;
          unint64_t v20 = v18[4];
          if (v16 >= v20) {
            break;
          }
          float v18 = (void *)*v19;
          id v5 = v19;
          if (!*v19) {
            goto LABEL_25;
          }
        }
        if (v20 >= v16) {
          break;
        }
        id v5 = v19 + 1;
        float v18 = (void *)v19[1];
      }
      while (v18);
LABEL_25:
      *a3 = v19;
      return v5;
    }
    else
    {
      *a3 = v5;
      return a1 + 1;
    }
  }
  else if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  else
  {
    uint64_t v11 = a2[1];
    if (v11)
    {
      uint64_t v12 = (void *)a2[1];
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      id v21 = a2;
      do
      {
        uint64_t v13 = (void *)v21[2];
        BOOL v15 = *v13 == (void)v21;
        id v21 = v13;
      }
      while (!v15);
    }
    if (v13 == v5 || v6 < v13[4])
    {
      if (v11)
      {
        *a3 = v13;
        return v13;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
    }
    else
    {
      unint64_t v22 = (void *)*v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            unint64_t v23 = v22;
            unint64_t v24 = v22[4];
            if (v6 >= v24) {
              break;
            }
            unint64_t v22 = (void *)*v23;
            id v5 = v23;
            if (!*v23) {
              goto LABEL_41;
            }
          }
          if (v24 >= v6) {
            break;
          }
          id v5 = v23 + 1;
          unint64_t v22 = (void *)v23[1];
        }
        while (v22);
LABEL_41:
        *a3 = v23;
        return v5;
      }
      else
      {
        *a3 = v5;
        return a1 + 1;
      }
    }
  }
}

void std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__tree_node<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,void *> *,long>>(uint64_t **a1, id *a2, id *a3)
{
  id v4 = a2;
  id v5 = a1;
  if (a1[2])
  {
    unint64_t v6 = *a1;
    uint64_t v8 = (id **)(a1 + 1);
    unint64_t v7 = a1[1];
    *a1 = (uint64_t *)(a1 + 1);
    v7[2] = 0;
    a1[2] = 0;
    a1[1] = 0;
    if (v6[1]) {
      id v9 = (uint64_t *)v6[1];
    }
    else {
      id v9 = v6;
    }
    if (!v9)
    {
      unint64_t v23 = 0;
LABEL_47:
      std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)a1, v23);
      goto LABEL_48;
    }
    uint64_t v10 = (uint64_t *)v9[2];
    if (v10)
    {
      uint64_t v11 = (uint64_t *)*v10;
      if ((uint64_t *)*v10 == v9)
      {
        *uint64_t v10 = 0;
        while (1)
        {
          id v26 = (uint64_t *)v10[1];
          if (!v26) {
            break;
          }
          do
          {
            uint64_t v10 = v26;
            id v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
      }
      else
      {
        for (v10[1] = 0; v11; uint64_t v11 = (uint64_t *)v10[1])
        {
          do
          {
            uint64_t v10 = v11;
            uint64_t v11 = (uint64_t *)*v11;
          }
          while (v11);
        }
      }
    }
    if (a2 != a3)
    {
      uint64_t v12 = (id *)v9;
      uint64_t v13 = a2;
      while (1)
      {
        id v9 = v10;
        objc_storeStrong(v12 + 4, v13[4]);
        objc_storeStrong(v12 + 5, v13[5]);
        uint64_t v14 = *v8;
        BOOL v15 = (id **)(v5 + 1);
        unint64_t v16 = (id **)(v5 + 1);
        if (*v8) {
          break;
        }
LABEL_18:
        *uint64_t v12 = 0;
        v12[1] = 0;
        v12[2] = v15;
        void *v16 = v12;
        float v17 = (uint64_t *)**v5;
        if (v17) {
          goto LABEL_19;
        }
LABEL_20:
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v5[1], (uint64_t *)v12);
        v5[2] = (uint64_t *)((char *)v5[2] + 1);
        if (v10)
        {
          uint64_t v10 = (uint64_t *)v10[2];
          if (v10)
          {
            unint64_t v20 = (uint64_t *)*v10;
            if ((uint64_t *)*v10 == v9)
            {
              *uint64_t v10 = 0;
              while (1)
              {
                id v21 = (uint64_t *)v10[1];
                if (!v21) {
                  break;
                }
                do
                {
                  uint64_t v10 = v21;
                  id v21 = (uint64_t *)*v21;
                }
                while (v21);
              }
            }
            else
            {
              for (v10[1] = 0; v20; unint64_t v20 = (uint64_t *)v10[1])
              {
                do
                {
                  uint64_t v10 = v20;
                  unint64_t v20 = (uint64_t *)*v20;
                }
                while (v20);
              }
            }
          }
        }
        else
        {
          uint64_t v10 = 0;
        }
        float v18 = (id *)v13[1];
        if (v18)
        {
          do
          {
            id v4 = v18;
            float v18 = (id *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            id v4 = (id *)v13[2];
            BOOL v19 = *v4 == v13;
            uint64_t v13 = v4;
          }
          while (!v19);
        }
        if (v9)
        {
          uint64_t v12 = (id *)v9;
          uint64_t v13 = v4;
          if (v4 != a3) {
            continue;
          }
        }
        goto LABEL_42;
      }
      do
      {
        while (1)
        {
          BOOL v15 = (id **)v14;
          if (v12[4] >= v14[4]) {
            break;
          }
          uint64_t v14 = (id *)*v14;
          unint64_t v16 = v15;
          if (!*v15) {
            goto LABEL_18;
          }
        }
        uint64_t v14 = (id *)v14[1];
      }
      while (v14);
      unint64_t v16 = v15 + 1;
      *uint64_t v12 = 0;
      v12[1] = 0;
      v12[2] = v15;
      v15[1] = v12;
      float v17 = (uint64_t *)**v5;
      if (!v17) {
        goto LABEL_20;
      }
LABEL_19:
      *id v5 = v17;
      uint64_t v12 = *v16;
      goto LABEL_20;
    }
LABEL_42:
    std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)v5, v9);
    if (v10)
    {
      for (unint64_t i = (uint64_t *)v10[2]; i; unint64_t i = (uint64_t *)i[2])
        uint64_t v10 = i;
      a1 = v5;
      unint64_t v23 = v10;
      goto LABEL_47;
    }
  }
LABEL_48:
  if (v4 != a3)
  {
    do
    {
      std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__emplace_multi<std::pair<objc_object * const {__strong},NSMutableArray * {__strong}> const&>(v5, v4 + 4);
      unint64_t v24 = (id *)v4[1];
      if (v24)
      {
        do
        {
          unint64_t v25 = v24;
          unint64_t v24 = (id *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          unint64_t v25 = (id *)v4[2];
          BOOL v19 = *v25 == v4;
          id v4 = v25;
        }
        while (!v19);
      }
      id v4 = v25;
    }
    while (v25 != a3);
  }
}

uint64_t *std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__emplace_multi<std::pair<objc_object * const {__strong},NSMutableArray * {__strong}> const&>(uint64_t **a1, id *a2)
{
  id v4 = (uint64_t *)operator new(0x30uLL);
  id v5 = *a2;
  v4[4] = (uint64_t)v5;
  id v6 = a2[1];
  unint64_t v7 = a1 + 1;
  uint64_t v8 = a1[1];
  v4[5] = (uint64_t)v6;
  if (v8)
  {
    do
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v8;
        if ((unint64_t)v5 >= v8[4]) {
          break;
        }
        uint64_t v8 = (uint64_t *)*v8;
        id v9 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      uint64_t v8 = (uint64_t *)v8[1];
    }
    while (v8);
    id v9 = v7 + 1;
  }
  else
  {
    id v9 = a1 + 1;
  }
LABEL_8:
  uint64_t *v4 = 0;
  v4[1] = 0;
  v4[2] = (uint64_t)v7;
  *id v9 = v4;
  uint64_t v10 = (uint64_t *)**a1;
  uint64_t v11 = v4;
  if (v10)
  {
    *a1 = v10;
    uint64_t v11 = *v9;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v4;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  id v3 = a2;
  if (*a2)
  {
    id v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      id v3 = a2;
      goto LABEL_10;
    }
    do
    {
      id v3 = v4;
      id v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (!v2)
  {
    int v5 = 1;
    id v6 = (uint64_t **)v3[2];
    unint64_t v7 = *v6;
    if (*v6 == v3) {
      goto LABEL_6;
    }
LABEL_11:
    v6[1] = (uint64_t *)v2;
    int v8 = *((unsigned __int8 *)v3 + 24);
    if (v3 == a2) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
LABEL_10:
  int v5 = 0;
  *(void *)(v2 + 16) = v3[2];
  id v6 = (uint64_t **)v3[2];
  unint64_t v7 = *v6;
  if (*v6 != v3) {
    goto LABEL_11;
  }
LABEL_6:
  uint64_t *v6 = (uint64_t *)v2;
  if (v3 != result)
  {
    unint64_t v7 = v6[1];
    int v8 = *((unsigned __int8 *)v3 + 24);
    if (v3 == a2) {
      goto LABEL_16;
    }
LABEL_12:
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
    goto LABEL_16;
  }
  unint64_t v7 = 0;
  uint64_t result = (uint64_t *)v2;
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2) {
    goto LABEL_12;
  }
LABEL_16:
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v14 = (uint64_t **)v7[2];
    if (*v14 == v7) {
      break;
    }
    if (*((unsigned char *)v7 + 24))
    {
      BOOL v15 = (void *)*v7;
      if (!*v7) {
        goto LABEL_38;
      }
    }
    else
    {
      *((unsigned char *)v7 + 24) = 1;
      *((unsigned char *)v14 + 24) = 0;
      float v17 = v14[1];
      float v18 = (uint64_t *)*v17;
      v14[1] = (uint64_t *)*v17;
      if (v18) {
        v18[2] = (uint64_t)v14;
      }
      v17[2] = (uint64_t)v14[2];
      v14[2][*v14[2] != (void)v14] = (uint64_t)v17;
      uint64_t *v17 = (uint64_t)v14;
      v14[2] = v17;
      if (result == (uint64_t *)*v7) {
        uint64_t result = v7;
      }
      unint64_t v7 = *(uint64_t **)(*v7 + 8);
      BOOL v15 = (void *)*v7;
      if (!*v7) {
        goto LABEL_38;
      }
    }
    if (!*((unsigned char *)v15 + 24))
    {
      BOOL v19 = (uint64_t *)v7[1];
      if (!v19) {
        goto LABEL_64;
      }
LABEL_63:
      if (*((unsigned char *)v19 + 24))
      {
LABEL_64:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v23 = v15[1];
        uint64_t *v7 = v23;
        if (v23) {
          *(void *)(v23 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        BOOL v19 = v7;
      }
      else
      {
        BOOL v15 = v7;
      }
      uint64_t v27 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v27 + 24);
      *(unsigned char *)(v27 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      uint64_t v28 = *(uint64_t **)(v27 + 8);
      uint64_t v29 = *v28;
      *(void *)(v27 + 8) = *v28;
      if (v29) {
        *(void *)(v29 + 16) = v27;
      }
      v28[2] = *(void *)(v27 + 16);
      *(void *)(*(void *)(v27 + 16) + 8 * (**(void **)(v27 + 16) != v27)) = v28;
      uint64_t *v28 = v27;
      *(void *)(v27 + 16) = v28;
      return result;
    }
LABEL_38:
    BOOL v19 = (uint64_t *)v7[1];
    if (v19 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_63;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v12 = (uint64_t *)v7[2];
    if (v12 == result)
    {
      uint64_t v12 = result;
LABEL_61:
      *((unsigned char *)v12 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v12 + 24)) {
      goto LABEL_61;
    }
LABEL_24:
    unint64_t v7 = *(uint64_t **)(v12[2] + 8 * (*(void *)v12[2] == (void)v12));
  }
  if (*((unsigned char *)v7 + 24))
  {
    unint64_t v16 = (void *)*v7;
    if (!*v7) {
      goto LABEL_49;
    }
LABEL_48:
    if (!*((unsigned char *)v16 + 24)) {
      goto LABEL_67;
    }
  }
  else
  {
    *((unsigned char *)v7 + 24) = 1;
    *((unsigned char *)v14 + 24) = 0;
    unint64_t v20 = (uint64_t *)v7[1];
    *uint64_t v14 = v20;
    if (v20) {
      v20[2] = (uint64_t)v14;
    }
    v7[2] = (uint64_t)v14[2];
    v14[2][*v14[2] != (void)v14] = (uint64_t)v7;
    v7[1] = (uint64_t)v14;
    v14[2] = v7;
    if (result == (uint64_t *)v14) {
      uint64_t result = v7;
    }
    unint64_t v7 = *v14;
    unint64_t v16 = (void *)**v14;
    if (v16) {
      goto LABEL_48;
    }
  }
LABEL_49:
  id v21 = (uint64_t *)v7[1];
  if (!v21 || *((unsigned char *)v21 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v12 = (uint64_t *)v7[2];
    if (*((unsigned char *)v12 + 24)) {
      BOOL v13 = v12 == result;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13) {
      goto LABEL_61;
    }
    goto LABEL_24;
  }
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_67:
    id v21 = v7;
  }
  else
  {
    *((unsigned char *)v21 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = *v21;
    v7[1] = *v21;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    v21[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v21;
    *id v21 = (uint64_t)v7;
    v7[2] = (uint64_t)v21;
    unint64_t v16 = v7;
  }
  unint64_t v24 = (uint64_t *)v21[2];
  *((unsigned char *)v21 + 24) = *((unsigned char *)v24 + 24);
  *((unsigned char *)v24 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  uint64_t v25 = *v24;
  uint64_t v26 = *(void *)(*v24 + 8);
  uint64_t *v24 = v26;
  if (v26) {
    *(void *)(v26 + 16) = v24;
  }
  *(void *)(v25 + 16) = v24[2];
  *(void *)(v24[2] + 8 * (*(void *)v24[2] != (void)v24)) = v25;
  *(void *)(v25 + 8) = v24;
  v24[2] = v25;
  return result;
}

char *std::vector<std::map<objc_object * {__strong},NSMutableArray * {__strong}>>::__push_back_slow_path<std::allocator<std::pair<objc_object * const {__strong},NSMutableArray * {__strong}>> const&>(char **a1, void *a2)
{
  id v3 = *a1;
  id v4 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  if (0x5555555555555556 * ((a1[2] - v3) >> 3) > v6) {
    unint64_t v6 = 0x5555555555555556 * ((a1[2] - v3) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = &v9[24 * v5];
  *((void *)v10 + 1) = 0;
  uint64_t v27 = &v9[24 * v8];
  *((void *)v10 + 2) = 0;
  *(void *)uint64_t v10 = v10 + 8;
  BOOL v13 = (void *)*a2;
  uint64_t v11 = a2 + 1;
  uint64_t v12 = v13;
  if (v13 == v11)
  {
    uint64_t v14 = v10 + 24;
    uint64_t v26 = v10 + 24;
    if (v4 == v3)
    {
LABEL_13:
      BOOL v15 = v3;
      goto LABEL_27;
    }
  }
  else
  {
    do
    {
      std::__tree<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<objc_object * {__strong},std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>,std::less<objc_object * {__strong}>,true>,std::allocator<std::__value_type<objc_object * {__strong},NSMutableArray * {__strong}>>>::__emplace_hint_unique_key_args<objc_object * {__strong},std::pair<objc_object * const {__strong},NSMutableArray * {__strong}> const&>((void **)v10, (void *)v10 + 1, v12 + 4, (id *)v12 + 4);
      unint64_t v16 = (void *)v12[1];
      if (v16)
      {
        do
        {
          float v17 = v16;
          unint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          float v17 = (void *)v12[2];
          BOOL v18 = *v17 == (void)v12;
          uint64_t v12 = v17;
        }
        while (!v18);
      }
      uint64_t v12 = v17;
    }
    while (v17 != v11);
    id v3 = *a1;
    id v4 = a1[1];
    uint64_t v14 = v10 + 24;
    uint64_t v26 = v10 + 24;
    if (v4 == *a1) {
      goto LABEL_13;
    }
  }
  uint64_t v19 = 0;
  do
  {
    while (1)
    {
      unint64_t v20 = &v10[v19];
      *((void *)v20 - 3) = *(void *)&v4[v19 - 24];
      id v21 = &v4[v19 - 16];
      uint64_t v22 = *(void *)v21;
      *(void *)&v10[v19 - 16] = *(void *)v21;
      uint64_t v23 = (uint64_t)&v10[v19 - 16];
      uint64_t v24 = *(void *)&v4[v19 - 8];
      *((void *)v20 - 1) = v24;
      if (!v24) {
        break;
      }
      *(void *)(v22 + 16) = v23;
      *(void *)&v4[v19 - 24] = v21;
      *(void *)id v21 = 0;
      *(void *)&v4[v19 - 8] = 0;
      v19 -= 24;
      if (&v4[v19] == v3) {
        goto LABEL_26;
      }
    }
    *((void *)v20 - 3) = v23;
    v19 -= 24;
  }
  while (&v4[v19] != v3);
LABEL_26:
  v10 += v19;
  BOOL v15 = *a1;
  id v3 = a1[1];
  uint64_t v14 = v26;
LABEL_27:
  *a1 = v10;
  a1[1] = v14;
  a1[2] = v27;
  if (v3 != v15)
  {
    do
    {
      std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)(v3 - 24), *((void **)v3 - 2));
      v3 -= 24;
    }
    while (v3 != v15);
    id v3 = v15;
  }
  if (v3) {
    operator delete(v3);
  }
  return v14;
}

void sub_235EE0F74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(v2, *(void **)(v2 + 8));
  std::__split_buffer<std::map<objc_object * {__strong},NSMutableArray * {__strong}>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::map<objc_object * {__strong},NSMutableArray * {__strong}>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy(i - 24, *(void **)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

_OWORD *std::vector<std::pair<objc_object * {__strong},GKCDecisionNode *>>::__push_back_slow_path<std::pair<objc_object * {__strong},GKCDecisionNode *>>(void **a1, long long *a2)
{
  id v4 = (char *)*a1;
  uint64_t v3 = (char *)a1[1];
  uint64_t v5 = v3 - (unsigned char *)*a1;
  unint64_t v6 = (v5 >> 4) + 1;
  if (v6 >> 60) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v7 = (unsigned char *)a1[2] - v4;
  if (v7 >> 3 > v6) {
    unint64_t v6 = v7 >> 3;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
  }
  if (v6 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v9 = 16 * v6;
  uint64_t v10 = (char *)operator new(16 * v6);
  uint64_t v11 = &v10[16 * (v5 >> 4)];
  uint64_t v12 = &v10[v9];
  long long v13 = *a2;
  *(void *)a2 = 0;
  *(_OWORD *)uint64_t v11 = v13;
  uint64_t v14 = v11 + 16;
  BOOL v15 = (char *)(v3 - v4);
  if (v3 == v4)
  {
    *a1 = v11;
    a1[1] = v14;
    a1[2] = v12;
    if (!v3) {
      return v14;
    }
    goto LABEL_32;
  }
  unint64_t v16 = v15 - 16;
  if ((unint64_t)(v15 - 16) < 0x110)
  {
    float v17 = v3;
LABEL_27:
    uint64_t v28 = v11;
    do
    {
      long long v32 = *((_OWORD *)v17 - 1);
      v17 -= 16;
      *(void *)float v17 = 0;
      *((_OWORD *)v28 - 1) = v32;
      v28 -= 16;
    }
    while (v17 != v4);
    goto LABEL_29;
  }
  BOOL v18 = &v3[-((unint64_t)v16 & 0xFFFFFFFFFFFFFFF0)];
  unint64_t v19 = (unint64_t)(v18 - 16);
  unint64_t v20 = &v10[v5 - ((unint64_t)v16 & 0xFFFFFFFFFFFFFFF0)];
  unint64_t v21 = (unint64_t)(v20 - 16);
  unint64_t v22 = (unint64_t)(v18 - 8);
  BOOL v24 = v20 - 8 < v3 && v22 < (unint64_t)v11;
  float v17 = v3;
  if (v21 < (unint64_t)(v3 - 8) && v19 < (unint64_t)&v10[v5 - 8]) {
    goto LABEL_27;
  }
  if (v24) {
    goto LABEL_27;
  }
  uint64_t v26 = ((unint64_t)v16 >> 4) + 1;
  uint64_t v27 = 16 * (v26 & 0x1FFFFFFFFFFFFFFELL);
  uint64_t v28 = &v11[-v27];
  float v17 = &v3[-v27];
  uint64_t v29 = (double *)(v11 - 32);
  id v30 = (const double *)(v3 - 32);
  uint64_t v31 = v26 & 0x1FFFFFFFFFFFFFFELL;
  do
  {
    float64x2x2_t v35 = vld2q_f64(v30);
    v30[2] = 0.0;
    *id v30 = 0.0;
    v30 -= 4;
    vst2q_f64(v29, v35);
    v29 -= 4;
    v31 -= 2;
  }
  while (v31);
  uint64_t v11 = v28;
  if (v26 != (v26 & 0x1FFFFFFFFFFFFFFELL)) {
    goto LABEL_27;
  }
LABEL_29:
  *a1 = v28;
  a1[1] = v14;
  a1[2] = v12;
  do
  {
    long long v33 = (void *)*((void *)v3 - 2);
    v3 -= 16;
  }
  while (v3 != v4);
  uint64_t v3 = v4;
  if (v4) {
LABEL_32:
  }
    operator delete(v3);
  return v14;
}

__n64 MakeVectorFloat2(float a1, float a2)
{
  result.n64_f32[1] = a2;
  return result;
}

__n64 MakeVectorFloat3(float a1, float a2, float a3)
{
  result.n64_f32[1] = a2;
  return result;
}

void sub_235EE1398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE16AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE16C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE17E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE2080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerToAvoidObstacles(uint64_t a1, const void ***a2, float a3)
{
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 200))(a1);
  int v29 = 0;
  unint64_t v8 = *a2;
  if (*a2 != a2[1])
  {
    int v9 = 0;
    float v27 = v7 * a3;
    float v28 = a3;
    do
    {
      uint64_t v10 = (char *)*v8;
      if (*v8)
      {
        uint64_t v11 = *(void *)v10;
        {
          int v29 = 0;
          float v34 = v10;
          float v12 = (*(float (**)(uint64_t, char *))(*(void *)a1 + 88))(a1, v10 + 12);
          float v14 = v13 * -2.0;
          float v16 = (float)((float)(v15 * v15) + (float)(v12 * v12)) + (float)(v13 * v13);
          float v17 = *((float *)v10 + 2);
          float v18 = (*(float (**)(uint64_t))(*(void *)a1 + 176))(a1);
          float v19 = (float)((float)-(float)(v16 - (float)((float)(v18 + v17) * (float)(v18 + v17))) * 4.0)
              + (float)(v14 * v14);
          if (v19 >= 0.0)
          {
            float v20 = sqrtf(v19);
            float v21 = (float)(v20 - v14) * 0.5;
            float v22 = (float)(v20 + v14) * -0.5;
            if (v21 >= 0.0 || v22 >= 0.0)
            {
              int v29 = 1;
              uint64_t v23 = *(void *)(v10 + 12);
              LODWORD(v32) = *((_DWORD *)v10 + 5);
              uint64_t v31 = v23;
              float v24 = fminf(v21, v22);
              if (v22 <= 0.0) {
                float v24 = v21;
              }
              if (v21 <= 0.0) {
                float v25 = v22;
              }
              else {
                float v25 = v24;
              }
              float v30 = v25;
            }
          }
        }
        {
          (*(void (**)(char *, uint64_t, int *, float))(v11 + 24))(v10, a1, &v29, v28);
        }
      }
      if (!v9 || (v29 ? (BOOL v26 = v30 < v3) : (BOOL v26 = 0), v26))
      {
        int v9 = v29;
        float v3 = v30;
      }
      ++v8;
    }
    while (v8 != a2[1]);
    if (v9)
    {
      if (v3 < v27)
      {
        (*(void (**)(uint64_t, float, double, double))(*(void *)a1 + 256))(a1, v27, 0.0, 0.0);
        (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
        (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
        (*(float (**)(uint64_t))(*(void *)a1 + 224))(a1);
      }
    }
  }
}

void sub_235EE27A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerToAvoidNeighbors(float *a1, uint64_t **a2, float a3)
{
  OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerToAvoidCloseNeighbors((uint64_t)a1, a2, 0.0);
  if (v7 == *(float *)&_static_vec3_zero
    && v5 == *((float *)&_static_vec3_zero + 1)
    && v6 == *(float *)&dword_26884D848)
  {
    unint64_t v8 = *a2;
    if (*a2 == a2[1])
    {
      uint64_t v9 = 0;
      float v82 = 0.0;
      float v83 = 0.0;
      float v81 = 0.0;
      float v84 = 0.0;
      float v85 = 0.0;
      float v86 = 0.0;
    }
    else
    {
      uint64_t v9 = 0;
      float v85 = 0.0;
      float v86 = 0.0;
      float v83 = 0.0;
      float v84 = 0.0;
      float v81 = 0.0;
      float v82 = 0.0;
      do
      {
        uint64_t v10 = *v8;
        if ((float *)*v8 != a1)
        {
          float v88 = (*(float (**)(float *))(*(void *)a1 + 176))(a1);
          float v11 = (*(float (**)(float *))(*(void *)a1 + 192))(a1);
          float v13 = v12;
          float v15 = v14;
          float v16 = (*(float (**)(uint64_t))(*(void *)v10 + 192))(v10) - v11;
          float v18 = v17 - v13;
          float v20 = v19 - v15;
          float v21 = (float)((float)(v16 * v16) + (float)(v18 * v18)) + (float)(v20 * v20);
          float v22 = 0.0;
          if (sqrtf(v21) != 0.0)
          {
            float v23 = (*(float (**)(float *))(*(void *)a1 + 48))(a1);
            float v25 = v24;
            float v27 = v26;
            float v28 = (*(float (**)(uint64_t))(*(void *)v10 + 48))(v10);
            float v22 = (float)((float)((float)((float)(v23 - v28) * v16) + (float)((float)(v25 - v29) * v18))
                        + (float)((float)(v27 - v30) * v20))
                / v21;
          }
          if (v22 >= 0.0 && v22 < a3)
          {
            float v31 = (*(float (**)(float *))(*(void *)a1 + 32))(a1);
            float v33 = v32;
            float v35 = v34;
            float v36 = (*(float (**)(float *))(*(void *)a1 + 200))(a1) * v22;
            float v87 = (*(float (**)(uint64_t))(*(void *)v10 + 32))(v10);
            float v38 = v37;
            float v40 = v39;
            float v41 = (*(float (**)(uint64_t))(*(void *)v10 + 200))(v10) * v22;
            float v42 = (*(float (**)(float *))(*(void *)a1 + 48))(a1) + (float)(v36 * v31);
            float v44 = v43 + (float)(v36 * v33);
            float v46 = v45 + (float)(v36 * v35);
            float v47 = (*(float (**)(uint64_t))(*(void *)v10 + 48))(v10) + (float)(v41 * v87);
            float v49 = v48 + (float)(v41 * v38);
            float v51 = v50 + (float)(v41 * v40);
            a1[20] = v44;
            a1[21] = v46;
            a1[16] = v47;
            a1[17] = v49;
            a1[18] = v51;
            a1[19] = v42;
            if (sqrtf((float)((float)((float)(v42 - v47) * (float)(v42 - v47))+ (float)((float)(v44 - v49) * (float)(v44 - v49)))+ (float)((float)(v46 - v51) * (float)(v46 - v51))) < (float)(v88 + v88))
            {
              float v82 = v44;
              float v83 = v46;
              float v81 = v42;
              float v84 = v49;
              float v85 = v51;
              float v86 = v47;
              a3 = v22;
              uint64_t v9 = v10;
            }
          }
        }
        ++v8;
      }
      while (v8 != a2[1]);
    }
    *(float *)uint64_t v91 = v86;
    *(float *)&v91[1] = v84;
    *(float *)&v91[2] = v85;
    *(float *)unint64_t v90 = v81;
    *(float *)&v90[1] = v82;
    *(float *)&v90[2] = v83;
    if (!v9) {
      goto LABEL_27;
    }
    float v52 = (*(float (**)(float *))(*(void *)a1 + 32))(a1);
    float v54 = v53;
    float v56 = v55;
    float v57 = (*(float (**)(uint64_t))(*(void *)v9 + 32))(v9);
    float v60 = (float)((float)(v57 * v52) + (float)(v58 * v54)) + (float)(v59 * v56);
    if (v60 >= -0.707)
    {
      uint64_t v69 = *(void *)v9;
      if (v60 <= 0.707)
      {
        float v77 = (*(float (**)(uint64_t))(v69 + 200))(v9);
        float v78 = 0.0;
        if (v77 > (*(float (**)(float *))(*(void *)a1 + 200))(a1))
        {
LABEL_26:
          (*(void (**)(float *, uint64_t, _DWORD *, _DWORD *, float))(*(void *)a1 + 280))(a1, v9, v90, v91, v78);
LABEL_27:
          (**(float (***)(float *))a1)(a1);
          return;
        }
        float v61 = (**(float (***)(float *))a1)(a1);
        float v63 = v79;
        float v65 = v80;
        float v66 = (*(float (**)(uint64_t))(*(void *)v9 + 192))(v9);
      }
      else
      {
        float v70 = (*(float (**)(uint64_t))(v69 + 48))(v9);
        float v72 = v71;
        float v74 = v73;
        float v61 = v70 - (*(float (**)(float *))(*(void *)a1 + 48))(a1);
        float v63 = v72 - v75;
        float v65 = v74 - v76;
        (**(void (***)(float *))a1)(a1);
      }
    }
    else
    {
      float v61 = v86 - (*(float (**)(float *))(*(void *)a1 + 48))(a1);
      float v63 = v84 - v62;
      float v65 = v85 - v64;
      (**(void (***)(float *))a1)(a1);
    }
    if ((float)((float)((float)(v66 * v61) + (float)(v67 * v63)) + (float)(v68 * v65)) <= 0.0) {
      float v78 = 1.0;
    }
    else {
      float v78 = -1.0;
    }
    goto LABEL_26;
  }
}

void sub_235EE31EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

float OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerForSeparation(uint64_t a1, uint64_t **a2, float a3, float a4)
{
  id v4 = *a2;
  if (*a2 == a2[1]) {
    return 0.0;
  }
  int v7 = 0;
  float v8 = a3 * a3;
  float v9 = 0.0;
  float v10 = 0.0;
  float v11 = 0.0;
  do
  {
    uint64_t v23 = *v4;
    (*(void (**)(uint64_t))(*(void *)a1 + 176))(a1);
    if (v23 != a1)
    {
      float v25 = v24 * 3.0;
      float v26 = (*(float (**)(uint64_t))(*(void *)v23 + 48))(v23);
      float v28 = v27;
      float v30 = v29;
      float v31 = v26 - (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
      float v33 = v28 - v32;
      float v35 = v30 - v34;
      float v36 = (float)((float)(v31 * v31) + (float)(v33 * v33)) + (float)(v35 * v35);
      if (v36 < (float)(v25 * v25)
        || v36 <= v8
        && (float v37 = sqrtf(v36),
            float v38 = (*(float (**)(uint64_t))(*(void *)a1 + 32))(a1),
            (float)((float)((float)((float)(v38 * v31) + (float)(v39 * v33)) + (float)(v40 * v35)) / v37) > a4))
      {
        float v12 = (*(float (**)(void))(*(void *)*v4 + 48))();
        float v14 = v13;
        float v16 = v15;
        float v17 = v12 - (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
        float v19 = v14 - v18;
        float v21 = v16 - v20;
        float v22 = 1.0 / (float)((float)((float)(v17 * v17) + (float)(v19 * v19)) + (float)(v21 * v21));
        float v11 = v11 - (float)(v17 * v22);
        float v10 = v10 - (float)(v19 * v22);
        float v9 = v9 - (float)(v21 * v22);
        ++v7;
      }
    }
    ++v4;
  }
  while (v4 != a2[1]);
  if (v7 > 0)
  {
    float v41 = 1.0 / (float)v7;
    float v11 = v11 * v41;
    float v42 = sqrtf((float)((float)(v11 * v11) + (float)((float)(v10 * v41) * (float)(v10 * v41)))+ (float)((float)(v9 * v41) * (float)(v9 * v41)));
    if (v42 > 0.0) {
      return v11 * (float)(1.0 / v42);
    }
  }
  return v11;
}

void sub_235EE37EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

float OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerForAlignment(uint64_t a1, uint64_t **a2, float a3, float a4)
{
  id v4 = *a2;
  if (*a2 == a2[1]) {
    return 0.0;
  }
  int v7 = 0;
  float v8 = a3 * a3;
  float v9 = 0.0;
  float v10 = 0.0;
  float v11 = 0.0;
  do
  {
    uint64_t v14 = *v4;
    (*(void (**)(uint64_t))(*(void *)a1 + 176))(a1);
    if (v14 != a1)
    {
      float v16 = v15 * 3.0;
      float v17 = (*(float (**)(uint64_t))(*(void *)v14 + 48))(v14);
      float v19 = v18;
      float v21 = v20;
      float v22 = v17 - (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
      float v24 = v19 - v23;
      float v26 = v21 - v25;
      float v27 = (float)((float)(v22 * v22) + (float)(v24 * v24)) + (float)(v26 * v26);
      if (v27 < (float)(v16 * v16)
        || v27 <= v8
        && (float v28 = sqrtf(v27),
            float v29 = (*(float (**)(uint64_t))(*(void *)a1 + 32))(a1),
            (float)((float)((float)((float)(v29 * v22) + (float)(v30 * v24)) + (float)(v31 * v26)) / v28) > a4))
      {
        float v11 = (*(float (**)(void))(*(void *)*v4 + 32))() + v11;
        float v10 = v12 + v10;
        float v9 = v13 + v9;
        ++v7;
      }
    }
    ++v4;
  }
  while (v4 != a2[1]);
  if (v7 > 0)
  {
    float v32 = 1.0 / (float)v7;
    float v11 = -(float)((*(float (**)(uint64_t))(*(void *)a1 + 32))(a1) - (float)(v11 * v32));
    float v35 = sqrtf((float)((float)(v11 * v11)+ (float)((float)-(float)(v33 - (float)(v10 * v32)) * (float)-(float)(v33 - (float)(v10 * v32))))+ (float)((float)-(float)(v34 - (float)(v9 * v32)) * (float)-(float)(v34 - (float)(v9 * v32))));
    if (v35 > 0.0) {
      return v11 * (float)(1.0 / v35);
    }
  }
  return v11;
}

void sub_235EE3DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

float OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerForCohesion(uint64_t a1, uint64_t **a2, float a3, float a4)
{
  id v4 = *a2;
  if (*a2 == a2[1]) {
    return 0.0;
  }
  int v7 = 0;
  float v8 = a3 * a3;
  float v9 = 0.0;
  float v10 = 0.0;
  float v11 = 0.0;
  do
  {
    uint64_t v14 = *v4;
    (*(void (**)(uint64_t))(*(void *)a1 + 176))(a1);
    if (v14 != a1)
    {
      float v16 = v15 * 3.0;
      float v17 = (*(float (**)(uint64_t))(*(void *)v14 + 48))(v14);
      float v19 = v18;
      float v21 = v20;
      float v22 = v17 - (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
      float v24 = v19 - v23;
      float v26 = v21 - v25;
      float v27 = (float)((float)(v22 * v22) + (float)(v24 * v24)) + (float)(v26 * v26);
      if (v27 < (float)(v16 * v16)
        || v27 <= v8
        && (float v28 = sqrtf(v27),
            float v29 = (*(float (**)(uint64_t))(*(void *)a1 + 32))(a1),
            (float)((float)((float)((float)(v29 * v22) + (float)(v30 * v24)) + (float)(v31 * v26)) / v28) > a4))
      {
        float v11 = (*(float (**)(void))(*(void *)*v4 + 48))() + v11;
        float v10 = v12 + v10;
        float v9 = v13 + v9;
        ++v7;
      }
    }
    ++v4;
  }
  while (v4 != a2[1]);
  if (v7 > 0)
  {
    float v32 = 1.0 / (float)v7;
    float v11 = -(float)((*(float (**)(uint64_t))(*(void *)a1 + 48))(a1) - (float)(v11 * v32));
    float v35 = sqrtf((float)((float)(v11 * v11)+ (float)((float)-(float)(v33 - (float)(v10 * v32)) * (float)-(float)(v33 - (float)(v10 * v32))))+ (float)((float)-(float)(v34 - (float)(v9 * v32)) * (float)-(float)(v34 - (float)(v9 * v32))));
    if (v35 > 0.0) {
      return v11 * (float)(1.0 / v35);
    }
  }
  return v11;
}

void sub_235EE42F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerForPursuit(uint64_t a1, uint64_t a2, float a3)
{
  float v6 = (*(float (**)(uint64_t))(*(void *)a2 + 48))(a2);
  float v8 = v7;
  float v10 = v9;
  float v11 = v6 - (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
  float v13 = v8 - v12;
  float v15 = v10 - v14;
  float v16 = sqrtf((float)((float)(v11 * v11) + (float)(v13 * v13)) + (float)(v15 * v15));
  float v17 = (*(float (**)(uint64_t))(*(void *)a1 + 32))(a1);
  float v19 = v18;
  float v21 = v20;
  float v22 = (*(float (**)(uint64_t))(*(void *)a2 + 32))(a2);
  float v25 = (float)((float)(v22 * v17) + (float)(v23 * v19)) + (float)(v24 * v21);
  float v26 = (*(float (**)(uint64_t))(*(void *)a1 + 32))(a1);
  float v29 = (float)((float)((float)(v26 * v11) + (float)(v27 * v13)) + (float)(v28 * v15)) / v16;
  (*(void (**)(uint64_t))(*(void *)a1 + 200))(a1);
  if (v29 < -0.707) {
    int v31 = -1;
  }
  else {
    int v31 = v29 > 0.707;
  }
  int v32 = v25 > 0.707;
  if (v25 < -0.707) {
    int v32 = -1;
  }
  float v33 = 0.0;
  if (v31 == -1)
  {
    unsigned int v34 = v32 + 1;
    if (v34 > 2) {
      goto LABEL_15;
    }
    float v35 = (float *)&unk_235F1F090;
  }
  else if (v31)
  {
    unsigned int v34 = v32 + 1;
    if (v34 >= 3) {
      goto LABEL_15;
    }
    float v35 = (float *)&unk_235F1F078;
  }
  else
  {
    unsigned int v34 = v32 + 1;
    if (v34 >= 3) {
      goto LABEL_15;
    }
    float v35 = (float *)&unk_235F1F084;
  }
  float v33 = v35[v34];
LABEL_15:
  float v36 = (*(float (**)(uint64_t, float))(*(void *)a2 + 216))(a2, fminf((float)(v33 * v16) / v30, a3));
  float v37 = v36 - (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (v37 == 0.0) {
    float v38 = 0.00000011921;
  }
  else {
    float v38 = v37;
  }
  return v38 - (*(float (**)(uint64_t))(*(void *)a1 + 192))(a1);
}

void sub_235EE4688(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerToFollowPath(uint64_t a1, int a2, uint64_t a3, float a4)
{
  float v7 = (float)a2 * (float)(a4 * (*(float (**)(uint64_t))(*(void *)a1 + 200))(a1));
  v25[0] = (*(float (**)(uint64_t, float))(*(void *)a1 + 216))(a1, a4);
  v25[1] = v8;
  v25[2] = v9;
  LODWORD(v23) = (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
  HIDWORD(v23) = v10;
  int v24 = v11;
  float v12 = (*(float (**)(uint64_t, uint64_t *))(*(void *)a3 + 16))(a3, &v23);
  float v13 = (*(float (**)(uint64_t, _DWORD *))(*(void *)a3 + 16))(a3, v25);
  if (v7 <= 0.0) {
    BOOL v14 = v12 <= v13;
  }
  else {
    BOOL v14 = v12 >= v13;
  }
  int v24 = 0;
  uint64_t v23 = 0;
  float v22 = 0.0;
  v21[0] = (**(float (***)(uint64_t, _DWORD *, uint64_t *, float *))a3)(a3, v25, &v23, &v22);
  v21[1] = v15;
  v21[2] = v16;
  if (v22 >= 0.0 || v14)
  {
    v20[0] = (*(float (**)(uint64_t, float))(*(void *)a3 + 8))(a3, v12 + v7);
    v20[1] = v17;
    v20[2] = v18;
    v19.n128_f32[0] = v22;
    (*(void (**)(uint64_t, _DWORD *, _DWORD *, _DWORD *, __n128))(*(void *)a1 + 264))(a1, v25, v21, v20, v19);
    (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
    (*(float (**)(uint64_t))(*(void *)a1 + 192))(a1);
  }
}

void sub_235EE49F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerToStayOnPath(uint64_t a1, float (***a2)(void, _DWORD *, uint64_t *, float *))
{
  v16[0] = (*(float (**)(uint64_t))(*(void *)a1 + 216))(a1);
  v16[1] = v4;
  v16[2] = v5;
  int v15 = 0;
  uint64_t v14 = 0;
  float v13 = 0.0;
  v12[0] = (**a2)(a2, v16, &v14, &v13);
  v12[1] = v6;
  v12[2] = v7;
  if (v13 < 0.0) {
    return *(float *)&_static_vec3_zero;
  }
  (*(void (**)(uint64_t, _DWORD *, float *, float *, float))(*(void *)a1 + 264))(a1, v16, v12, v12, v13);
  float v9 = (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
  float v10 = v12[0] - v9;
  if (v10 == 0.0) {
    float v11 = 0.00000011921;
  }
  else {
    float v11 = v10;
  }
  return v11 - (*(float (**)(uint64_t))(*(void *)a1 + 192))(a1);
}

void sub_235EE4DAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE4E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE5548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE555C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE558C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE55A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE55B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE55C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE55DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE55F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE5604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE5618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE562C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE5644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE565C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE5670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE58AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE58BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE5AAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE6318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE632C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE63AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE63C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE63D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE63E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE63FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_235EE6454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

BOOL GKSimpleVehicle::rightHanded(GKSimpleVehicle *this)
{
  return this->m_rightHanded;
}

void OpenSteer::SteerLibraryMixin<OpenSteer::LocalSpaceMixin<OpenSteer::AbstractVehicle>>::steerToAvoidCloseNeighbors(uint64_t a1, uint64_t **a2, float a3)
{
  int v4 = *a2;
  float v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      uint64_t v8 = *v4;
      if (*v4 != a1)
      {
        float v9 = (*(float (**)(uint64_t))(*(void *)a1 + 176))(a1);
        float v10 = (float)(v9 + a3) + (*(float (**)(uint64_t))(*(void *)v8 + 176))(v8);
        float v11 = (*(float (**)(uint64_t))(*(void *)v8 + 48))(v8);
        float v13 = v12;
        float v15 = v14;
        float v16 = v11 - (*(float (**)(uint64_t))(*(void *)a1 + 48))(a1);
        if (sqrtf((float)((float)(v16 * v16) + (float)((float)(v13 - v17) * (float)(v13 - v17)))+ (float)((float)(v15 - v18) * (float)(v15 - v18))) < v10)
        {
          (*(void (**)(uint64_t, uint64_t, float))(*(void *)a1 + 272))(a1, v8, a3);
          (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
          return;
        }
        float v3 = a2[1];
      }
      ++v4;
    }
    while (v4 != v3);
  }
}

void sub_235EE67BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE6974(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x237DF7CA0](v3, 0x10A0C40841CC34ELL);

  _Unwind_Resume(a1);
}

void sub_235EE69A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6B10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6B24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6B48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6C60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCHybridStrategist::bestMoveForActivePlayer(GKCHybridStrategist *this)
{
  *((unsigned char *)this + 104) = objc_opt_respondsToSelector() & 1;
  *((unsigned char *)this + 105) = objc_opt_respondsToSelector() & 1;
  uint64_t v2 = [*((id *)this + 7) players];
  *((void *)this + 12) = [v2 count];

  GKCHybridStrategist::setupMinmax(this);
  [*((id *)this + 7) copyWithZone:0];
  operator new();
}

void sub_235EE6F18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6F34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6F48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6F68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6F78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6F94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE6FAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCHybridStrategist::GKCHybridStrategist(GKCHybridStrategist *this)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 8) = objc_alloc_init(GKARC4RandomSource);
  *(_OWORD *)((char *)this + 72) = xmmword_235F1EFD0;
  *(_OWORD *)((char *)this + 88) = xmmword_235F1F020;
  *((_WORD *)this + 52) = 0;
  uint64_t v2 = objc_opt_new();
  uint64_t v3 = (void *)*((void *)this + 6);
  *((void *)this + 6) = v2;
}

void sub_235EE7040(_Unwind_Exception *a1)
{
  std::vector<std::vector<ClipperLib::IntPoint>>::~vector[abi:ne180100](v1 + 3);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void GKCHybridStrategist::~GKCHybridStrategist(id *this)
{
  uint64_t v2 = (char *)this[3];
  if (v2)
  {
    uint64_t v3 = (char *)this[4];
    id v4 = this[3];
    if (v3 != v2)
    {
      int v5 = (char *)this[4];
      do
      {
        float v7 = (void *)*((void *)v5 - 3);
        v5 -= 24;
        float v6 = v7;
        if (v7)
        {
          *((void *)v3 - 2) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      id v4 = this[3];
    }
    this[4] = v2;
    operator delete(v4);
  }
  uint64_t v8 = (char *)*this;
  if (*this)
  {
    float v9 = (char *)this[1];
    id v10 = *this;
    if (v9 != v8)
    {
      do
      {
        float v11 = (void *)*((void *)v9 - 1);
        v9 -= 8;
      }
      while (v9 != v8);
      id v10 = *this;
    }
    this[1] = v8;
    operator delete(v10);
  }
}

uint64_t GKCHybridStrategist::setupMinmax(GKCHybridStrategist *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  if (v3 != *(void *)this)
  {
    do
    {
      id v4 = *(void **)(v3 - 8);
      v3 -= 8;
    }
    while (v3 != v2);
    uint64_t v3 = *(void *)this;
  }
  *((void *)this + 1) = v2;
  unint64_t v5 = *((void *)this + 11);
  unint64_t v6 = (v2 - v3) >> 3;
  if (v5 <= v6)
  {
    if (v5 < v6)
    {
      uint64_t v7 = v3 + 8 * v5;
      while (v2 != v7)
      {
        uint64_t v8 = *(void **)(v2 - 8);
        v2 -= 8;
      }
      *((void *)this + 1) = v7;
    }
  }
  else
  {
    std::vector<objc_object  {objcproto11GKGameModel}* {__strong}>::__append((void **)this, v5 - v6);
  }
  if (*((void *)this + 11))
  {
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = [*((id *)this + 7) copyWithZone:0];
      float v11 = *(void **)(*(void *)this + 8 * v9);
      *(void *)(*(void *)this + 8 * v9) = v10;

      ++v9;
      unint64_t v12 = *((void *)this + 11);
    }
    while (v9 < v12);
    unint64_t v13 = v12 + 1;
  }
  else
  {
    unint64_t v13 = 1;
  }
  uint64_t v15 = *((void *)this + 3);
  uint64_t v14 = *((void *)this + 4);
  float v16 = (void *)((char *)this + 24);
  unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v15) >> 3);
  if (v13 <= v17)
  {
    if (v13 < v17)
    {
      uint64_t v18 = v15 + 24 * v13;
      if (v14 != v18)
      {
        uint64_t v19 = *((void *)this + 4);
        do
        {
          float v21 = *(void **)(v19 - 24);
          v19 -= 24;
          float v20 = v21;
          if (v21)
          {
            *(void *)(v14 - 16) = v20;
            operator delete(v20);
          }
          uint64_t v14 = v19;
        }
        while (v19 != v18);
      }
      *((void *)this + 4) = v18;
    }
  }
  else
  {
    std::vector<std::vector<long>>::__append((uint64_t)this + 24, v13 - v17);
  }
  unint64_t v22 = 0;
  unint64_t v23 = *((void *)this + 12);
  do
  {
    float v25 = (void *)(*v16 + 24 * v22);
    unint64_t v26 = (uint64_t)(v25[1] - *v25) >> 3;
    if (v23 <= v26)
    {
      if (v23 < v26) {
        v25[1] = *v25 + 8 * v23;
      }
    }
    else
    {
      std::vector<long>::__append((uint64_t)v25, v23 - v26);
      unint64_t v23 = *((void *)this + 12);
    }
    if (v23)
    {
      unint64_t v27 = 0;
      uint64_t v28 = *(void *)(*v16 + 24 * v22);
      do
      {
        *(void *)(v28 + 8 * v27++) = 0;
        unint64_t v23 = *((void *)this + 12);
      }
      while (v27 < v23);
    }
  }
  while (v22++ < *((void *)this + 11));
  float v29 = (void *)*((void *)this + 6);

  return objc_msgSend(v29, "setMaxLookAheadDepth:");
}

uint64_t GKCHybridStrategist::treePolicy(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  for (id i = a4; [i count]; id i = (id)v25)
  {
    uint64_t v10 = *(void *)(a2 + 16);
    uint64_t v9 = *(void *)(a2 + 24);
    if ([i count] > (unint64_t)((v9 - v10) >> 3)) {
      GKCHybridStrategist::expand(a1, a2, i);
    }
    float v11 = *(uint64_t **)(a2 + 16);
    uint64_t v12 = *(void *)(a2 + 24) - (void)v11;
    if (v12)
    {
      unint64_t v13 = v12 >> 3;
      unint64_t v14 = *(void *)(a2 + 56);
      double v15 = (double)*(unint64_t *)(a1 + 80);
      if (v13 <= 1) {
        uint64_t v16 = 1;
      }
      else {
        uint64_t v16 = v13;
      }
      double v17 = 0.0;
      do
      {
        uint64_t v19 = *v11++;
        uint64_t v18 = v19;
        unint64_t v20 = *(void *)(v19 + 56);
        double v21 = *(double *)(v19 + 64) / (double)v20;
        long double v22 = log((double)(v14 / v20));
        double v23 = v21 + sqrt(v22 + v22) * v15;
        if (v23 >= v17) {
          a2 = v18;
        }
        double v17 = fmax(v23, v17);
        --v16;
      }
      while (v16);
    }
    uint64_t v24 = [*(id *)a2 activePlayer];

    uint64_t v25 = [*(id *)a2 gameModelUpdatesForPlayer:v24];

    id v7 = (id)v24;
  }

  return a2;
}

void sub_235EE746C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE7480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GKCHybridStrategist::defaultPolicy(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 activePlayer];
  unint64_t v5 = [v3 gameModelUpdatesForPlayer:v4];

  char v6 = 1;
  while ([v5 count])
  {
    if ((v6 & 1) != 0
      && ([v3 activePlayer],
          id v7 = objc_claimAutoreleasedReturnValue(),
          [*(id *)(a1 + 56) activePlayer],
          uint64_t v8 = objc_claimAutoreleasedReturnValue(),
          v8,
          v7,
          v7 == v8))
    {
      uint64_t v12 = objc_msgSend(v3, "activePlayer", 0, 0);
      uint64_t v9 = GKCHybridStrategist::findBestMoveNPlayer(a1, v3, v12, *(void *)(a1 + 88), &v17, &v16);

      char v6 = 0;
    }
    else
    {
      uint64_t v9 = objc_msgSend(v5, "objectAtIndexedSubscript:", objc_msgSend(*(id *)(a1 + 64), "nextIntWithUpperBound:", objc_msgSend(v5, "count")));
    }
    [v3 applyGameModelUpdate:v9];
    uint64_t v10 = [v3 activePlayer];
    uint64_t v11 = [v3 gameModelUpdatesForPlayer:v10];

    unint64_t v5 = (void *)v11;
  }
  unint64_t v13 = [*(id *)(a1 + 56) activePlayer];
  uint64_t v14 = [v3 isWinForPlayer:v13];

  return v14;
}

void sub_235EE762C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE7644(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE7658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE766C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE767C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE76AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE76C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE76DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE76F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCHybridStrategist::expand(uint64_t a1, uint64_t a2, void *a3)
{
}

void sub_235EE77D0(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v3, 0x10A0C40AF943C6FLL);

  _Unwind_Resume(a1);
}

void sub_235EE77FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE780C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GKCHybridStrategist::findBestMoveNPlayer(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t *a5, void *a6)
{
  id v10 = a2;
  id v42 = a3;
  id v37 = v10;
  if (objc_msgSend(v10, "isWinForPlayer:"))
  {
    uint64_t v11 = 1;
  }
  else if (*(unsigned char *)(a1 + 105) && ([v10 isLossForPlayer:v42] & 1) != 0)
  {
    uint64_t v11 = -1;
  }
  else
  {
    uint64_t v11 = 0;
  }
  *a5 = v11;
  *a6 = *(void *)(a1 + 88) - a4;
  uint64_t v40 = a4 - 1;
  if (a4 < 1 || *a5)
  {
    GKCHybridStrategist::getScores(a1, v10, a4);
    double v23 = 0;
  }
  else
  {
    uint64_t v12 = [v10 activePlayer];
    float v35 = (void *)v12;
    unint64_t v13 = [v10 gameModelUpdatesForPlayer:v12];
    uint64_t v14 = [v13 count];
    if (v14)
    {
      float v39 = v13;
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      id v15 = *(id *)(*(void *)a1 + 8 * a4 - 8);
      uint64_t v16 = *(void *)(a1 + 24);
      uint64_t v17 = [*(id *)(a1 + 56) players];
      uint64_t v18 = [v17 indexOfObject:v12];
      float v38 = (uint64_t *)(v16 + 24 * a4);

      if (*(void *)(a1 + 96))
      {
        unint64_t v19 = 0;
        uint64_t v20 = *v38;
        do
          *(void *)(v20 + 8 * v19++) = 0x8000000000000000;
        while (v19 < *(void *)(a1 + 96));
      }
      if (v14 < 1)
      {
        double v23 = 0;
      }
      else
      {
        uint64_t v21 = v14;
        float v36 = a5;
        uint64_t v22 = 0;
        double v23 = 0;
        uint64_t v24 = 24 * a4;
        uint64_t v25 = 8 * v18;
        do
        {
          [v15 setGameModel:v10];
          unint64_t v26 = [v39 objectAtIndexedSubscript:v22];
          [v15 applyGameModelUpdate:v26];
          id v27 = (id)GKCHybridStrategist::findBestMoveNPlayer(a1, v15, v42, v40, &v44, &v43);
          uint64_t v28 = *(void *)(*(void *)(a1 + 24) + v24 - 24);
          uint64_t v29 = *(void *)(v28 + v25);
          uint64_t v30 = *v38;
          uint64_t v31 = *(void *)(*v38 + v25);
          if (v29 > v31 || v29 == v31 && v43 < *a6)
          {
            if (*(void *)(a1 + 96))
            {
              unint64_t v32 = 0;
              do
              {
                *(void *)(v30 + 8 * v32) = *(void *)(v28 + 8 * v32);
                ++v32;
              }
              while (v32 < *(void *)(a1 + 96));
            }
            *float v36 = v44;
            *a6 = v43;
            id v33 = v26;

            double v23 = v33;
            id v10 = v37;
          }
          [v26 setValue:v29];

          ++v22;
        }
        while (v22 != v21);
      }

      unint64_t v13 = v39;
    }
    else
    {
      GKCHybridStrategist::getScores(a1, v10, a4);
      double v23 = 0;
    }
  }

  return v23;
}

void sub_235EE7B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void GKCHybridStrategist::getScores(uint64_t a1, void *a2, uint64_t a3)
{
  id v10 = a2;
  uint64_t v5 = *(void *)(a1 + 24);
  char v6 = [*(id *)(a1 + 56) players];
  unint64_t v7 = 0;
  uint64_t v8 = (void *)(v5 + 24 * a3);
  while (v7 < [v6 count])
  {
    uint64_t v9 = [v6 objectAtIndexedSubscript:v7];
    *(void *)(*v8 + 8 * v7) = [v10 scoreForPlayer:v9];

    ++v7;
  }
}

void sub_235EE7C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE7C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE7CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE8DA8(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x81C402FCC0CB6);
  _Unwind_Resume(a1);
}

void sub_235EE8F10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE8F74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE90A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE9138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE9278(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE93A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE9724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_235EE9824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235EE98F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE9BB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EE9EE0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  MEMORY[0x237DF7CA0](v4, 0x10A1C4057B0C30BLL);
  MEMORY[0x237DF7CA0](v2, 0xA1C40BD48D6D6);

  _Unwind_Resume(a1);
}

void sub_235EE9F2C(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

void sub_235EEA17C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235EEA194(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235EEA1A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235EEA2B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235EEA2C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235EEA2DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235EEA368(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GKCQuadTree<NSObject>::removeDataWithNode(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = a2;
  uint64_t v5 = v4;
  char v6 = *(void **)(a3 + 88);
  unint64_t v7 = *(void **)(a3 + 96);
  if (v6 == v7)
  {
LABEL_4:
    uint64_t v8 = 0;
  }
  else
  {
    while ((id)*v6 != v4)
    {
      if (++v6 == v7) {
        goto LABEL_4;
      }
    }
    uint64_t v9 = v6 + 1;
    if (v6 + 1 != v7)
    {
      do
      {
        char v6 = v9;
        id v10 = (void *)*(v9 - 1);
        *(v9 - 1) = *v9;
        *uint64_t v9 = 0;

        uint64_t v9 = v6 + 1;
      }
      while (v6 + 1 != v7);
      unint64_t v7 = *(void **)(a3 + 96);
    }
    while (v7 != v6)
    {
      uint64_t v11 = (void *)*--v7;
    }
    *(void *)(a3 + 96) = v6;
    uint64_t v8 = 1;
  }

  return v8;
}

uint64_t GKCQuadTreeNode<NSObject>::GKCQuadTreeNode(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, float a5)
{
  *(void *)a1 = &unk_26E943098;
  *(double *)(a1 + 8) = *(double *)&a3;
  *(double *)(a1 + 16) = *(double *)&a4;
  float32x2_t v6 = vsub_f32(a4, a3);
  *(float32x2_t *)(a1 + 24) = v6;
  *(float32x2_t *)(a1 + 32) = vmla_f32(a3, v6, (float32x2_t)0x3F0000003F000000);
  *(float *)(a1 + 40) = a5;
  *(void *)(a1 + 48) = a2;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  unint64_t v7 = objc_alloc_init(GKQuadtreeNode);
  uint64_t v8 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = v7;

  [*(id *)(a1 + 112) setCQuadTreeNode:a1];
  return a1;
}

void sub_235EEA4C8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(char **)(v1 + 88);
  if (v3) {
    GKCQuadTreeNode<NSObject>::GKCQuadTreeNode(v1, v3, (void **)(v1 + 88));
  }
  _Unwind_Resume(a1);
}

void *GKCQuadTree<NSObject>::~GKCQuadTree(void *a1)
{
  *a1 = &unk_26E943068;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void GKCQuadTree<NSObject>::~GKCQuadTree(void *a1)
{
  *a1 = &unk_26E943068;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x237DF7CA0);
}

void GKCQuadTreeNode<NSObject>::~GKCQuadTreeNode(uint64_t a1)
{
  GKCQuadTreeNode<NSObject>::~GKCQuadTreeNode(a1);

  JUMPOUT(0x237DF7CA0);
}

uint64_t GKCQuadTreeNode<NSObject>::~GKCQuadTreeNode(uint64_t a1)
{
  *(void *)a1 = &unk_26E943098;
  uint64_t v3 = (_OWORD *)(a1 + 56);
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 80);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  _OWORD *v3 = 0u;
  v3[1] = 0u;
  uint64_t v7 = *(void *)(a1 + 88);
  for (uint64_t i = *(void *)(a1 + 96); i != v7; i -= 8)
  {
    uint64_t v9 = *(void **)(i - 8);
  }
  *(void *)(a1 + 96) = v7;

  uint64_t v10 = *(void *)(a1 + 88);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 96);
    uint64_t v12 = *(void **)(a1 + 88);
    if (v11 != v10)
    {
      do
      {
        unint64_t v13 = *(void **)(v11 - 8);
        v11 -= 8;
      }
      while (v11 != v10);
      uint64_t v12 = *(void **)(a1 + 88);
    }
    *(void *)(a1 + 96) = v10;
    operator delete(v12);
  }
  return a1;
}

float32x2_t *GKCQuadTreeNode<NSObject>::addPoint(float32x2_t *a1, void *a2, double a3)
{
  id v5 = a2;
  id v6 = v5;
  id v15 = v5;
  float32x2_t v7 = vmul_f32(a1[3], (float32x2_t)0x3F0000003F000000);
  float v8 = a1[5].f32[0];
  if (v7.f32[0] < v8 || v7.f32[1] < v8)
  {
    uint64_t v10 = (void *)a1[12];
    if ((unint64_t)v10 >= *(void *)&a1[13])
    {
      unint64_t v13 = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(&a1[11], &v15);
      id v6 = v15;
      a1[12] = (float32x2_t)v13;
    }
    else
    {
      id v6 = v5;
      *uint64_t v10 = v6;
      a1[12] = (float32x2_t)(v10 + 1);
    }
  }
  else
  {
    int32x2_t v11 = vcgt_f32(a1[4], *(float32x2_t *)&a3);
    if (v11.i8[0])
    {
      if (v11.i8[4])
      {
        float32x2_t v12 = a1[9];
        if (!*(void *)&v12) {
          operator new();
        }
      }
      else
      {
        float32x2_t v12 = a1[7];
        if (!*(void *)&v12) {
          operator new();
        }
      }
    }
    else if (v11.i8[4])
    {
      float32x2_t v12 = a1[10];
      if (!*(void *)&v12) {
        operator new();
      }
    }
    else
    {
      float32x2_t v12 = a1[8];
      if (!*(void *)&v12) {
        operator new();
      }
    }
    a1 = (float32x2_t *)GKCQuadTreeNode<NSObject>::addPoint(*(void *)&v12, v5, a3);
  }

  return a1;
}

void sub_235EEA9A4(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v2, 0x10A1C4057B0C30BLL);

  _Unwind_Resume(a1);
}

void sub_235EEA9D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

float32x2_t *GKCQuadTreeNode<NSObject>::addQuad(float32x2_t *a1, void *a2, __n128 a3, double a4)
{
  id v6 = a2;
  id v27 = v6;
  v9.n128_u64[0] = (unint64_t)vmul_f32(a1[3], (float32x2_t)0x3F0000003F000000);
  float v10 = a1[5].f32[0];
  float v11 = v9.n128_f32[1];
  if (v9.n128_f32[0] > v10 && v9.n128_f32[1] > v10)
  {
    v7.n128_u64[0] = (unint64_t)a1[4];
    unsigned __int8 v14 = vcgt_f32((float32x2_t)v7.n128_u64[0], (float32x2_t)a3.n128_u64[0]).u8[0];
    float32x2_t v15 = vadd_f32(*(float32x2_t *)&a4, (float32x2_t)a3.n128_u64[0]);
    __n128 v25 = v7;
    v7.n128_u64[0] = (unint64_t)vcgt_f32(v15, vadd_f32((float32x2_t)v7.n128_u64[0], (float32x2_t)v9.n128_u64[0]));
    char v16 = v14 | v7.n128_u8[0];
    if ((v16 & 1) == 0
      && ((v8.n128_u64[1] = v25.n128_u64[1], v7.n128_u32[0] = v15.u32[1], a3.n128_f32[1] >= v25.n128_f32[1])
        ? (BOOL v17 = v15.f32[1] <= (float)(v25.n128_f32[1] + v9.n128_f32[1]))
        : (BOOL v17 = 0),
          v17))
    {
      if (!*(void *)&a1[8]) {
        operator new();
      }
    }
    else
    {
      v8.n128_u64[0] = (unint64_t)a1[1];
      char v18 = vcgt_f32((float32x2_t)v8.n128_u64[0], (float32x2_t)a3.n128_u64[0]).u8[0] | vcgt_f32(v15, vadd_f32((float32x2_t)v8.n128_u64[0], (float32x2_t)v9.n128_u64[0])).u8[0];
      if ((v18 & 1) == 0
        && ((__n128 v7 = v25,
             __n128 v9 = a3,
             v9.n128_u32[0] = v15.u32[1],
             v7.n128_f32[0] = v25.n128_f32[1] + v11,
             a3.n128_f32[1] >= v25.n128_f32[1])
          ? (BOOL v19 = v15.f32[1] <= v7.n128_f32[0])
          : (BOOL v19 = 0),
            v19))
      {
        if (!*(void *)&a1[7]) {
          operator new();
        }
      }
      else if ((v16 & 1) == 0 {
             && ((__n128 v9 = a3,
      }
                  __n128 v7 = v8,
                  v9.n128_u32[0] = v15.u32[1],
                  v7.n128_f32[0] = v8.n128_f32[1] + v11,
                  a3.n128_f32[1] >= v8.n128_f32[1])
               ? (BOOL v20 = v15.f32[1] <= v7.n128_f32[0])
               : (BOOL v20 = 0),
                 v20))
      {
        if (!*(void *)&a1[10]) {
          operator new();
        }
      }
      else
      {
        if ((v18 & 1) != 0
          || ((__n128 v9 = a3,
               v9.n128_u32[0] = a3.n128_u32[1],
               __n128 v7 = v8,
               v7.n128_u32[0] = HIDWORD(*(void *)&a1[1]),
               float v21 = v8.n128_f32[1] + v11,
               a3.n128_f32[1] >= v8.n128_f32[1])
            ? (BOOL v22 = v15.f32[1] <= v21)
            : (BOOL v22 = 0),
              !v22))
        {
          unint64_t v13 = (void *)a1[12];
          if ((unint64_t)v13 < *(void *)&a1[13]) {
            goto LABEL_29;
          }
LABEL_30:
          double v23 = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(&a1[11], &v27);
          goto LABEL_31;
        }
        if (!*(void *)&a1[9]) {
          operator new();
        }
      }
    }
    a1 = (float32x2_t *)GKCQuadTreeNode<NSObject>::addQuad(a3, a4, v9, v7);
    goto LABEL_40;
  }
  unint64_t v13 = (void *)a1[12];
  if ((unint64_t)v13 >= *(void *)&a1[13]) {
    goto LABEL_30;
  }
LABEL_29:
  *unint64_t v13 = v6;
  double v23 = v13 + 1;
LABEL_31:
  a1[12] = (float32x2_t)v23;
LABEL_40:

  return a1;
}

void sub_235EEACD0(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C4057B0C30BLL);

  _Unwind_Resume(a1);
}

void sub_235EEAD08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *std::vector<NSObject * {__strong}>::__insert_with_size[abi:ne180100]<std::__wrap_iter<NSObject * const {__strong}*>,NSObject * const {__strong}*>(id **a1, uint64_t a2, void **a3, void **a4, uint64_t a5)
{
  id v5 = *a1;
  uint64_t v6 = a2 - (void)*a1;
  __n128 v7 = (id *)((char *)*a1 + (v6 & 0xFFFFFFFFFFFFFFF8));
  if (a5 < 1) {
    return v7;
  }
  __n128 v9 = a3;
  uint64_t v11 = v6 >> 3;
  unint64_t v13 = (unint64_t)a1[1];
  float32x2_t v12 = a1[2];
  uint64_t v92 = v6 >> 3;
  if (a5 <= (uint64_t)((uint64_t)v12 - v13) >> 3)
  {
    uint64_t v19 = v13 - (void)v7;
    uint64_t v20 = (uint64_t)(v13 - (void)v7) >> 3;
    if (v20 >= a5)
    {
      BOOL v22 = &a3[a5];
      uint64_t v24 = a1[1];
    }
    else
    {
      BOOL v22 = &a3[v20];
      if (v22 == a4)
      {
        uint64_t v24 = a1[1];
        a1[1] = (id *)v13;
        if (v19 < 1) {
          return v7;
        }
      }
      else
      {
        float v88 = *a1;
        uint64_t v91 = a2 - (void)*a1;
        double v23 = &a3[v20];
        uint64_t v24 = a1[1];
        do
        {
          __n128 v25 = *v23++;
          *v24++ = v25;
        }
        while (v23 != a4);
        id v5 = v88;
        uint64_t v6 = v91;
        a1[1] = v24;
        if (v19 < 1) {
          return v7;
        }
      }
    }
    unint64_t v26 = (char *)&v7[a5];
    uint64_t v27 = ((char *)v24 - v26) >> 3;
    uint64_t v28 = (uint64_t *)&v24[-a5];
    uint64_t v29 = v24;
    if ((unint64_t)v28 < v13)
    {
      unint64_t v30 = (v6 & 0xFFFFFFFFFFFFFFF8) + (char *)v24 - v26;
      unint64_t v31 = (unint64_t)v5 + v30 + 8;
      if (v13 > v31) {
        unint64_t v31 = v13;
      }
      unint64_t v32 = v31 + ~(unint64_t)v5 - v30;
      if (v32 >= 0xE8)
      {
        unint64_t v70 = (unint64_t)v5 + v30 + (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
        BOOL v71 = v28 >= (uint64_t *)((char *)v24 + (v32 & 0xFFFFFFFFFFFFFFF8) + 8) || (unint64_t)v24 >= v70;
        uint64_t v29 = v24;
        if (v71)
        {
          uint64_t v72 = (v32 >> 3) + 1;
          uint64_t v73 = v72 & 0x3FFFFFFFFFFFFFFCLL;
          uint64_t v28 = (uint64_t *)((char *)v28 + v73 * 8);
          uint64_t v29 = &v24[v73];
          float v74 = v24 + 2;
          float v75 = &v5[v92 + 2] + v27;
          uint64_t v76 = v72 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v77 = *((_OWORD *)v75 - 1);
            long long v78 = *(_OWORD *)v75;
            *((_OWORD *)v75 - 1) = 0uLL;
            *(_OWORD *)float v75 = 0uLL;
            *(v74 - 1) = v77;
            *float v74 = v78;
            v74 += 2;
            v75 += 4;
            v76 -= 4;
          }
          while (v76);
          if (v72 == (v72 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_63;
          }
        }
      }
      else
      {
        uint64_t v29 = v24;
      }
      do
      {
        float v79 = (void *)*v28;
        *v28++ = 0;
        *v29++ = v79;
      }
      while ((unint64_t)v28 < v13);
    }
LABEL_63:
    a1[1] = v29;
    if (v24 != (id *)v26)
    {
      float v80 = v24 - 1;
      uint64_t v81 = 8 * v27;
      uint64_t v82 = (uint64_t)&v5[v92 - 1];
      do
      {
        float v83 = *(void **)(v82 + v81);
        *(void *)(v82 + v81) = 0;
        float v84 = *v80;
        *v80-- = v83;

        v81 -= 8;
      }
      while (v81);
    }
    if (v22 != v9)
    {
      float v85 = v7;
      do
      {
        float v86 = *v9++;
        objc_storeStrong(v85++, v86);
      }
      while (v9 != v22);
    }
    return v7;
  }
  unint64_t v14 = a5 + ((uint64_t)(v13 - (void)v5) >> 3);
  if (v14 >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v15 = (char *)v12 - (char *)v5;
  if (v15 >> 2 > v14) {
    unint64_t v14 = v15 >> 2;
  }
  if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v16 = v14;
  }
  uint64_t v90 = a2 - (void)*a1;
  if (v16)
  {
    if (v16 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    BOOL v17 = *a1;
    char v18 = (char *)operator new(8 * v16);
  }
  else
  {
    BOOL v17 = *a1;
    char v18 = 0;
  }
  id v33 = &v18[8 * v11];
  unsigned int v34 = v18;
  unint64_t v89 = &v18[8 * v16];
  uint64_t v35 = 8 * a5;
  float v36 = (id *)&v33[8 * a5];
  id v37 = v33;
  do
  {
    float v38 = *v9++;
    *(void *)id v37 = v38;
    v37 += 8;
    v35 -= 8;
  }
  while (v35);
  float v39 = *a1;
  uint64_t v40 = v33;
  if (*a1 != v7)
  {
    unint64_t v41 = (char *)v17 + (v90 & 0xFFFFFFFFFFFFFFF8) - (char *)v39 - 8;
    uint64_t v40 = v33;
    id v42 = v7;
    if (v41 < 0x78) {
      goto LABEL_77;
    }
    unint64_t v43 = (v90 & 0xFFFFFFFFFFFFFFF8) - (v41 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v44 = (unint64_t)v17 + v43 - 8;
    unint64_t v45 = (unint64_t)&v34[v43 - 8];
    BOOL v46 = v44 >= (unint64_t)v33 || v45 >= (unint64_t)v7;
    uint64_t v40 = v33;
    id v42 = v7;
    if (!v46) {
      goto LABEL_77;
    }
    uint64_t v47 = (v41 >> 3) + 1;
    uint64_t v48 = 8 * (v47 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v40 = &v33[-v48];
    id v42 = &v7[v48 / 0xFFFFFFFFFFFFFFF8];
    uint64_t v49 = 8 * v92 - 16;
    float v50 = (long long *)((char *)v17 + v49);
    float v51 = &v34[v49];
    uint64_t v52 = v47 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v54 = *(v50 - 1);
      long long v53 = *v50;
      *(v50 - 1) = 0uLL;
      *float v50 = 0uLL;
      *((_OWORD *)v51 - 1) = v54;
      *(_OWORD *)float v51 = v53;
      v50 -= 2;
      v51 -= 32;
      v52 -= 4;
    }
    while (v52);
    if (v47 != (v47 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_77:
      do
      {
        uint64_t v55 = (uint64_t)*--v42;
        *id v42 = 0;
        *((void *)v40 - 1) = v55;
        v40 -= 8;
      }
      while (v42 != v39);
    }
  }
  float v56 = a1[1];
  if (v56 != v7)
  {
    unint64_t v57 = (char *)v56 - ((char *)v17 + (v90 & 0xFFFFFFFFFFFFFFF8)) - 8;
    if (v57 < 0xA8) {
      goto LABEL_78;
    }
    unint64_t v58 = (v90 & 0xFFFFFFFFFFFFFFF8) + (v57 & 0xFFFFFFFFFFFFFFF8);
    if (v7 < (id *)&v34[8 * a5 + 8 + v58] && v36 < (id *)((char *)v17 + v58 + 8)) {
      goto LABEL_78;
    }
    uint64_t v60 = (v57 >> 3) + 1;
    uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
    __n128 v7 = (id *)((char *)v7 + v61);
    float v36 = (id *)((char *)v36 + v61);
    float v62 = &v34[8 * v92 + 16 + 8 * a5];
    float v63 = &v17[v92 + 2];
    uint64_t v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v65 = *((_OWORD *)v63 - 1);
      long long v66 = *(_OWORD *)v63;
      *((_OWORD *)v63 - 1) = 0uLL;
      *(_OWORD *)float v63 = 0uLL;
      *((_OWORD *)v62 - 1) = v65;
      *(_OWORD *)float v62 = v66;
      v62 += 32;
      v63 += 4;
      v64 -= 4;
    }
    while (v64);
    if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_78:
      do
      {
        id v67 = *v7;
        *v7++ = 0;
        *v36++ = v67;
      }
      while (v7 != v56);
    }
    __n128 v7 = a1[1];
  }
  float v68 = *a1;
  *a1 = (id *)v40;
  a1[1] = v36;
  a1[2] = (id *)v89;
  while (v7 != v68)
  {
    uint64_t v69 = *--v7;
  }
  if (v68) {
    operator delete(v68);
  }
  return (id *)v33;
}

id *GKCQuadTreeNode<NSObject>::queryQuad(id *result, float32x2_t *a2, float32x2_t *a3, uint64_t a4)
{
  __n128 v7 = (float32x2_t *)result;
  while (1)
  {
    while (1)
    {
      __n128 v8 = (void **)v7[11];
      __n128 v9 = (void **)v7[12];
      if (v9 != v8) {
        __n64 result = std::vector<NSObject * {__strong}>::__insert_with_size[abi:ne180100]<std::__wrap_iter<NSObject * const {__strong}*>,NSObject * const {__strong}*>((id **)a4, *(void *)(a4 + 8), v8, v9, v9 - v8);
      }
      float32x2_t v10 = v7[4];
      float32x2_t v11 = vmul_f32(v7[3], (float32x2_t)0x3F0000003F000000);
      float32x2_t v12 = *a2;
      int32x2_t v13 = (int32x2_t)*a3;
      float32x2_t v14 = vadd_f32(*a3, *a2);
      if ((vcgt_f32(*a2, v10).u32[0] & 1) == 0) {
        break;
      }
      float32x2_t v15 = vadd_f32(v10, v11);
      if (vcgt_f32(v14, v10).u32[0] & 1) != 0 && (vcgt_f32(v15, v12).u8[0])
      {
        int32x2_t v16 = vcgt_f32(vadd_f32((float32x2_t)vzip2_s32(v13, (int32x2_t)v10), (float32x2_t)vzip2_s32((int32x2_t)v12, (int32x2_t)v11)), (float32x2_t)vzip2_s32((int32x2_t)v10, (int32x2_t)v12));
        if (v16.i32[1] & v16.i32[0])
        {
          __n64 result = (id *)v7[8];
          if (result)
          {
            __n64 result = (id *)GKCQuadTreeNode<NSObject>::queryQuad(result, a2, a3, a4);
            float32x2_t v10 = v7[4];
            float32x2_t v12 = *a2;
            int32x2_t v13 = (int32x2_t)*a3;
            v14.i32[0] = vadd_f32(*a3, *a2).u32[0];
            v15.i32[0] = vadd_f32(v10, v11).u32[0];
          }
        }
      }
      if (v10.f32[0] >= v14.f32[0] || v15.f32[0] <= v12.f32[0]) {
        return result;
      }
LABEL_50:
      v32.i32[0] = vdup_lane_s32((int32x2_t)v12, 1).u32[0];
      v32.i32[1] = v7[1].i32[1];
      v12.i32[0] = v32.i32[1];
      int32x2_t v33 = vcgt_f32(vadd_f32(v32, (float32x2_t)vzip2_s32(v13, (int32x2_t)v11)), v12);
      if (v33.i32[1] & v33.i32[0])
      {
        __n128 v7 = (float32x2_t *)v7[10];
        if (v7) {
          continue;
        }
      }
      return result;
    }
    float32x2_t v18 = v7[1];
    float32x2_t v19 = vadd_f32(v18, v11);
    char v20 = vcgt_f32(v14, v18).u8[0] & vcgt_f32(v19, v12).u8[0];
    if ((vcgt_f32(v10, v14).u32[0] & 1) == 0) {
      break;
    }
    if (v20)
    {
      int32x2_t v21 = vcgt_f32(vadd_f32((float32x2_t)vzip2_s32(v13, (int32x2_t)v10), (float32x2_t)vzip2_s32((int32x2_t)v12, (int32x2_t)v11)), (float32x2_t)vzip2_s32((int32x2_t)v10, (int32x2_t)v12));
      if (v21.i32[1] & v21.i32[0])
      {
        __n64 result = (id *)v7[7];
        if (result)
        {
          __n64 result = (id *)GKCQuadTreeNode<NSObject>::queryQuad(result, a2, a3, a4);
          float32x2_t v18 = v7[1];
          float32x2_t v12 = *a2;
          int32x2_t v13 = (int32x2_t)*a3;
          v14.i32[0] = vadd_f32(*a3, *a2).u32[0];
          v19.i32[0] = vadd_f32(v18, v11).u32[0];
        }
      }
    }
    if (v18.f32[0] < v14.f32[0] && v19.f32[0] > v12.f32[0])
    {
      int32x2_t v23 = vcgt_f32(vadd_f32((float32x2_t)vzip2_s32(v13, (int32x2_t)v18), (float32x2_t)vzip2_s32((int32x2_t)v12, (int32x2_t)v11)), (float32x2_t)vzip2_s32((int32x2_t)v18, (int32x2_t)v12));
      if (v23.i32[1] & v23.i32[0])
      {
        __n128 v7 = (float32x2_t *)v7[9];
        if (v7) {
          continue;
        }
      }
    }
    return result;
  }
  if (v20)
  {
    int32x2_t v24 = vcgt_f32(vadd_f32((float32x2_t)vzip2_s32(v13, (int32x2_t)v10), (float32x2_t)vzip2_s32((int32x2_t)v12, (int32x2_t)v11)), (float32x2_t)vzip2_s32((int32x2_t)v10, (int32x2_t)v12));
    if (v24.i32[1] & v24.i32[0])
    {
      __n64 result = (id *)v7[7];
      if (result)
      {
        __n64 result = (id *)GKCQuadTreeNode<NSObject>::queryQuad(result, a2, a3, a4);
        float32x2_t v18 = v7[1];
        float32x2_t v12 = *a2;
        int32x2_t v13 = (int32x2_t)*a3;
        v14.i32[0] = vadd_f32(*a3, *a2).u32[0];
        v19.i32[0] = vadd_f32(v18, v11).u32[0];
      }
    }
  }
  if (v18.f32[0] < v14.f32[0] && v19.f32[0] > v12.f32[0])
  {
    int32x2_t v26 = vcgt_f32(vadd_f32((float32x2_t)vzip2_s32(v13, (int32x2_t)v18), (float32x2_t)vzip2_s32((int32x2_t)v12, (int32x2_t)v11)), (float32x2_t)vzip2_s32((int32x2_t)v18, (int32x2_t)v12));
    if (v26.i32[1] & v26.i32[0])
    {
      __n64 result = (id *)v7[9];
      if (result)
      {
        __n64 result = (id *)GKCQuadTreeNode<NSObject>::queryQuad(result, a2, a3, a4);
        float32x2_t v12 = *a2;
        int32x2_t v13 = (int32x2_t)*a3;
        v14.i32[0] = vadd_f32(*a3, *a2).u32[0];
      }
    }
  }
  float32x2_t v27 = v7[4];
  LODWORD(v28) = vadd_f32(v27, v11).u32[0];
  if (v27.f32[0] < v14.f32[0] && v28 > v12.f32[0])
  {
    int32x2_t v30 = vcgt_f32(vadd_f32((float32x2_t)vzip2_s32(v13, (int32x2_t)v27), (float32x2_t)vzip2_s32((int32x2_t)v12, (int32x2_t)v11)), (float32x2_t)vzip2_s32((int32x2_t)v27, (int32x2_t)v12));
    if (v30.i32[1] & v30.i32[0])
    {
      __n64 result = (id *)v7[8];
      if (result)
      {
        __n64 result = (id *)GKCQuadTreeNode<NSObject>::queryQuad(result, a2, a3, a4);
        float32x2_t v27 = v7[4];
        float32x2_t v12 = *a2;
        int32x2_t v13 = (int32x2_t)*a3;
        v14.i32[0] = vadd_f32(*a3, *a2).u32[0];
        LODWORD(v28) = vadd_f32(v27, v11).u32[0];
      }
    }
  }
  if (v27.f32[0] < v14.f32[0] && v28 > v12.f32[0]) {
    goto LABEL_50;
  }
  return result;
}

uint64_t GKCQuadTreeNode<NSObject>::removeDataRecursive(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  id v5 = (void *)a1[11];
  uint64_t v6 = (void *)a1[12];
  if (v5 == v6)
  {
LABEL_4:

    uint64_t v7 = a1[7];
    if (!v7 || (GKCQuadTreeNode<NSObject>::removeDataRecursive(v7, v4) & 1) == 0)
    {
      uint64_t v8 = a1[8];
      if (!v8 || (GKCQuadTreeNode<NSObject>::removeDataRecursive(v8, v4) & 1) == 0)
      {
        uint64_t v9 = a1[9];
        if (!v9 || (GKCQuadTreeNode<NSObject>::removeDataRecursive(v9, v4) & 1) == 0)
        {
          uint64_t v10 = a1[10];
          if (!v10 || (GKCQuadTreeNode<NSObject>::removeDataRecursive(v10, v4) & 1) == 0)
          {

            return 0;
          }
        }
      }
    }
  }
  else
  {
    while ((id)*v5 != v3)
    {
      if (++v5 == v6) {
        goto LABEL_4;
      }
    }
    float32x2_t v12 = v5 + 1;
    if (v5 + 1 != v6)
    {
      do
      {
        id v5 = v12;
        int32x2_t v13 = (void *)*(v12 - 1);
        *(v12 - 1) = *v12;
        *float32x2_t v12 = 0;

        float32x2_t v12 = v5 + 1;
      }
      while (v5 + 1 != v6);
      uint64_t v6 = (void *)a1[12];
    }
    while (v6 != v5)
    {
      float32x2_t v14 = (void *)*--v6;
    }
    a1[12] = v5;
  }
  return 1;
}

void sub_235EEB5DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCGraphNode::GKCGraphNode(GKCGraphNode *this)
{
  *(void *)this = &unk_26E9430C8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = -1;
  *((void *)this + 7) = 0;
}

void GKCGraphNode::~GKCGraphNode(id *this)
{
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;

  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;
  uint64_t vars8;

  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x237DF7CA0);
}

id *GKCGraphNode::addConnectionToNode(id *this, id *a2, char a3)
{
  do
  {
    char v4 = a3;
    uint64_t v5 = (uint64_t)this;
    uint64_t v7 = (id **)this[2];
    uint64_t v6 = (id **)this[3];
    if (v7 < v6)
    {
      float32x2_t *v7 = a2;
      uint64_t v8 = (uint64_t)(v7 + 1);
      goto LABEL_23;
    }
    uint64_t v9 = (id ***)(this + 1);
    uint64_t v10 = (char *)this[1];
    uint64_t v11 = ((char *)v7 - v10) >> 3;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v13 = (char *)v6 - v10;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float32x2_t v15 = (char *)operator new(8 * v14);
      int32x2_t v16 = (id **)&v15[8 * v11];
      void *v16 = a2;
      uint64_t v8 = (uint64_t)(v16 + 1);
      if (v7 == (id **)v10) {
        goto LABEL_21;
      }
LABEL_14:
      unint64_t v17 = (char *)(v7 - 1) - v10;
      if (v17 < 0x58) {
        goto LABEL_29;
      }
      if ((unint64_t)(v10 - v15) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v18 = (v17 >> 3) + 1;
      uint64_t v19 = 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
      char v20 = &v7[v19 / 0xFFFFFFFFFFFFFFF8];
      int32x2_t v16 = (id **)((char *)v16 - v19);
      int32x2_t v21 = &v15[8 * v11 - 16];
      BOOL v22 = v7 - 2;
      uint64_t v23 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *(_OWORD *)v22;
        *((_OWORD *)v21 - 1) = *((_OWORD *)v22 - 1);
        *(_OWORD *)int32x2_t v21 = v24;
        v21 -= 32;
        v22 -= 4;
        v23 -= 4;
      }
      while (v23);
      uint64_t v7 = v20;
      if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_29:
        do
        {
          __n128 v25 = *--v7;
          *--int32x2_t v16 = v25;
        }
        while (v7 != (id **)v10);
      }
      uint64_t v7 = *v9;
      goto LABEL_21;
    }
    float32x2_t v15 = 0;
    int32x2_t v16 = (id **)(8 * v11);
    *(void *)(8 * v11) = a2;
    uint64_t v8 = 8 * v11 + 8;
    if (v7 != (id **)v10) {
      goto LABEL_14;
    }
LABEL_21:
    *(void *)(v5 + 8) = v16;
    *(void *)(v5 + 16) = v8;
    *(void *)(v5 + 24) = &v15[8 * v14];
    if (v7) {
      operator delete(v7);
    }
LABEL_23:
    *(void *)(v5 + 16) = v8;
    id WeakRetained = objc_loadWeakRetained((id *)(v5 + 56));
    float32x2_t v27 = [WeakRetained mutConnectedNodes];
    id v28 = objc_loadWeakRetained(a2 + 7);
    [v27 addObject:v28];

    a3 = 0;
    this = a2;
    a2 = (id *)v5;
  }
  while ((v4 & 1) != 0);
  return this;
}

void sub_235EEB91C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EEB934(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *GKCGraphNode::removeConnectionToNode(id *this, id *a2, char a3)
{
  do
  {
    char v4 = a3;
    uint64_t v5 = (uint64_t)this;
    uint64_t v6 = (GKCGraphNode **)this[2];
    unint64_t v7 = (char *)v6 - (unsigned char *)this[1];
    if ((int)(v7 >> 3) >= 1)
    {
      unint64_t v8 = (v7 >> 3) + 1;
      do
      {
        uint64_t v9 = (GKCGraphNode **)(*(void *)(v5 + 8) + 8 * (v8 - 2));
        if (*v9 == (GKCGraphNode *)a2)
        {
          int64_t v10 = (char *)v6 - (char *)(v9 + 1);
          if (v6 != v9 + 1) {
            memmove((void *)(*(void *)(v5 + 8) + 8 * (v8 - 2)), v9 + 1, (char *)v6 - (char *)(v9 + 1));
          }
          uint64_t v6 = (GKCGraphNode **)((char *)v9 + v10);
          *(void *)(v5 + 16) = (char *)v9 + v10;
        }
        --v8;
      }
      while (v8 > 1);
    }
    id WeakRetained = objc_loadWeakRetained((id *)(v5 + 56));
    unint64_t v12 = [WeakRetained mutConnectedNodes];
    id v13 = objc_loadWeakRetained(a2 + 7);
    [v12 removeObject:v13];

    a3 = 0;
    this = a2;
    a2 = (id *)v5;
  }
  while ((v4 & 1) != 0);
  return this;
}

void sub_235EEBA30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EEBA48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float GKCGraphNode::estimatedCostToNode(id *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  float v5 = 0.0;
  if (methodOverridden(a2, v4, (objc_selector *)sel_estimatedCostToNode_))
  {
    id WeakRetained = objc_loadWeakRetained(this + 7);
    id v7 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained estimatedCostToNode:v7];
    float v5 = v8;
  }
  return v5;
}

void sub_235EEBAE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL methodOverridden(id *a1, objc_class *a2, objc_selector *a3)
{
  float v5 = a1 + 7;
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  if (!WeakRetained) {
    return 0;
  }
  id v7 = WeakRetained;
  id v8 = objc_loadWeakRetained(v5);
  uint64_t v9 = (objc_class *)objc_opt_class();

  if (v9 == a2) {
    return 0;
  }
  id v10 = objc_loadWeakRetained(v5);
  uint64_t v11 = [v10 methodForSelector:a3];
  BOOL v12 = v11 != [(objc_class *)a2 instanceMethodForSelector:a3];

  return v12;
}

void sub_235EEBBB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EEBBCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float GKCGraphNode::costToNode(id *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  float v5 = 0.0;
  if (methodOverridden(a2, v4, (objc_selector *)sel_costToNode_))
  {
    id WeakRetained = objc_loadWeakRetained(this + 7);
    id v7 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained costToNode:v7];
    float v5 = v8;
  }
  return v5;
}

void sub_235EEBC6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCGridGraphNode::GKCGridGraphNode(GKCGridGraphNode *this)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = -1;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *(void *)this = &unk_26E9430F8;
  *((void *)this + 9) = 0;
}

uint64_t GKCGridGraphNode::GKCGridGraphNode(uint64_t result, double a2)
{
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = -1;
  *(void *)(result + 56) = 0;
  *(void *)__n64 result = &unk_26E9430F8;
  *(double *)(result + 64) = a2;
  *(void *)(result + 72) = 0;
  return result;
}

void GKCGridGraphNode::~GKCGridGraphNode(id *this)
{
  objc_destroyWeak(this + 9);
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;

  objc_destroyWeak(this + 9);
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;
  uint64_t vars8;

  objc_destroyWeak(this + 9);
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x237DF7CA0);
}

void GKCGridGraphNode::estimatedCostToNode(id *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  if (methodOverridden(a2, v4, (objc_selector *)sel_estimatedCostToNode_))
  {
    id WeakRetained = objc_loadWeakRetained(this + 7);
    id v6 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained estimatedCostToNode:v6];
  }
  else
  {
    id v7 = (void (*)(id *, id *))*((void *)*this + 3);
    v7(this, a2);
  }
}

void sub_235EEBF1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float GKCGridGraphNode::costToNode(int32x2_t *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  if (methodOverridden(a2, v4, (objc_selector *)sel_costToNode_))
  {
    id WeakRetained = objc_loadWeakRetained((id *)&this[7]);
    id v6 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained costToNode:v6];
    float v8 = v7;

    return v8;
  }
  else if (a2
  {
    float32x2_t v11 = vsub_f32(vcvt_f32_s32(v10[8]), vcvt_f32_s32(this[8]));
    return sqrtf(vaddv_f32(vmul_f32(v11, v11)));
  }
  else
  {
    return GKCGraphNode::estimatedCostToNode((id *)this, a2);
  }
}

void sub_235EEC06C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCGraphNode2D::GKCGraphNode2D(GKCGraphNode2D *this)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = -1;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *(void *)this = &unk_26E943150;
  *((void *)this + 9) = 0;
}

uint64_t GKCGraphNode2D::GKCGraphNode2D(uint64_t result, double a2)
{
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = -1;
  *(void *)(result + 56) = 0;
  *(void *)__n64 result = &unk_26E943150;
  *(double *)(result + 64) = a2;
  *(void *)(result + 72) = 0;
  return result;
}

void GKCGraphNode2D::estimatedCostToNode(id *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  if (methodOverridden(a2, v4, (objc_selector *)sel_estimatedCostToNode_))
  {
    id WeakRetained = objc_loadWeakRetained(this + 7);
    id v6 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained estimatedCostToNode:v6];
  }
  else
  {
    float v7 = (void (*)(id *, id *))*((void *)*this + 3);
    v7(this, a2);
  }
}

void sub_235EEC1DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float GKCGraphNode2D::costToNode(float32x2_t *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  if (methodOverridden(a2, v4, (objc_selector *)sel_costToNode_))
  {
    id WeakRetained = objc_loadWeakRetained((id *)&this[7]);
    id v6 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained costToNode:v6];
    float v8 = v7;

    return v8;
  }
  else if (a2
  {
    float32x2_t v11 = vsub_f32(v10[8], this[8]);
    return sqrtf(vaddv_f32(vmul_f32(v11, v11)));
  }
  else
  {
    return GKCGraphNode::estimatedCostToNode((id *)this, a2);
  }
}

void sub_235EEC324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCGraphNode3D::GKCGraphNode3D(GKCGraphNode3D *this)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = -1;
  *((void *)this + 7) = 0;
  *(void *)this = &unk_26E943198;
  *((_OWORD *)this + 4) = 0u;
  *((void *)this + 10) = 0;
}

uint64_t GKCGraphNode3D::GKCGraphNode3D(uint64_t result, __n128 a2)
{
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = -1;
  *(void *)(result + 56) = 0;
  *(void *)__n64 result = &unk_26E943198;
  *(__n128 *)(result + 64) = a2;
  *(void *)(result + 80) = 0;
  return result;
}

void GKCGraphNode3D::estimatedCostToNode(id *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  if (methodOverridden(a2, v4, (objc_selector *)sel_estimatedCostToNode_))
  {
    id WeakRetained = objc_loadWeakRetained(this + 7);
    id v6 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained estimatedCostToNode:v6];
  }
  else
  {
    float v7 = (void (*)(id *, id *))*((void *)*this + 3);
    v7(this, a2);
  }
}

void sub_235EEC498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float GKCGraphNode3D::costToNode(GKCGraphNode3D *this, id *a2)
{
  char v4 = (objc_class *)objc_opt_class();
  if (methodOverridden(a2, v4, (objc_selector *)sel_costToNode_))
  {
    id WeakRetained = objc_loadWeakRetained((id *)this + 7);
    id v6 = objc_loadWeakRetained(a2 + 7);
    [WeakRetained costToNode:v6];
    float v8 = v7;

    return v8;
  }
  else if (a2
  {
    float32x4_t v11 = vsubq_f32(v10[4], *((float32x4_t *)this + 4));
    float32x4_t v12 = vmulq_f32(v11, v11);
    return sqrtf(vaddq_f32(vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1)), (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2)).f32[0]);
  }
  else
  {
    return GKCGraphNode::estimatedCostToNode((id *)this, a2);
  }
}

void sub_235EEC5EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GKCGraphNode2D::~GKCGraphNode2D(id *this)
{
  objc_destroyWeak(this + 9);
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;
  uint64_t vars8;

  objc_destroyWeak(this + 9);
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x237DF7CA0);
}

void GKCGraphNode3D::~GKCGraphNode3D(id *this)
{
  objc_destroyWeak(this + 10);
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }
}

{
  id v2;
  uint64_t vars8;

  objc_destroyWeak(this + 10);
  *this = &unk_26E9430C8;
  objc_destroyWeak(this + 7);
  id v2 = this[1];
  if (v2)
  {
    this[2] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x237DF7CA0);
}

void sub_235EEC8E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __lcg(int a1)
{
  return (1103515245 * a1 + 12345);
}

uint64_t hash3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 16777619 * ((16777619 * ((16777619 * (a1 ^ 0x811C9DC5)) ^ a2)) ^ a3);
}

float __voronoiNoise(char a1, unsigned int a2, float32x4_t a3, float32x4_t a4, float a5)
{
  float32x4_t v10 = vmulq_n_f32(a3, a4.f32[0]);
  LODWORD(v5) = vcvtms_s32_f32(v10.f32[2]);
  *(float32x2_t *)a4.f32 = vrndm_f32(*(float32x2_t *)v10.f32);
  int32x2_t v11 = vcvt_s32_f32(*(float32x2_t *)a4.f32);
  a4.i32[2] = floorf(v10.f32[2]);
  uint64_t v12 = v11.u32[1];
  uint64_t v13 = v11.u32[0];
  uint64_t v14 = v5 - 1;
  int8x16_t v15 = 0uLL;
  uint64_t v16 = -1;
  v6.i32[0] = 2139095039;
  v17.i64[0] = 0xFFFFFFFFLL;
  v17.i64[1] = 0xFFFFFFFFLL;
  float32x2_t v18 = (float32x2_t)vdup_n_s32(0x2F800000u);
  do
  {
    for (uint64_t i = -1; i != 2; ++i)
    {
      uint64_t v20 = 16777619 * ((16777619 * ((v16 + v13) ^ 0x811C9DC5)) ^ (v12 + i));
      v21.i64[0] = 1103515245 * (a2 + 16777619 * (v20 ^ v14)) + 12345;
      v21.i64[1] = 1103515245 * (v21.i64[0] + a2) + 12345;
      float32x2_t v22 = vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)vandq_s8(v21, v17)));
      v7.f32[0] = (float)(int)v16;
      float32x4_t v23 = v7;
      v23.f32[1] = (float)(int)i;
      *(float32x2_t *)v8.f32 = vmla_f32(*(float32x2_t *)v23.f32, v22, v18);
      v8.f32[2] = (float)((float)(1103515245
                                * (1103515245 * (1103515245 * (a2 + 16777619 * (v20 ^ v14)) + 12345 + a2) + 12345 + a2)
                                + 12345)
                        * 2.3283e-10)
                + -1.0;
      float32x4_t v24 = vaddq_f32(v8, a4);
      float32x4_t v25 = vsubq_f32(v10, v24);
      float32x4_t v26 = vmulq_f32(v25, v25);
      v27.i64[0] = 1103515245 * (a2 + 16777619 * (v20 ^ v5)) + 12345;
      v27.i64[1] = 1103515245 * (v27.i64[0] + a2) + 12345;
      *(float32x2_t *)v9.f32 = vmla_f32(*(float32x2_t *)v23.f32, vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)vandq_s8(v27, v17))), v18);
      v9.f32[2] = (float)(1103515245
                        * (1103515245 * (1103515245 * (a2 + 16777619 * (v20 ^ v5)) + 12345 + a2) + 12345 + a2)
                        + 12345)
                * 2.3283e-10;
      float32x4_t v28 = vaddq_f32(vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1)), (float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2));
      float32x4_t v29 = vaddq_f32(v9, a4);
      float32x4_t v30 = vsubq_f32(v10, v29);
      float32x4_t v31 = vmulq_f32(v30, v30);
      int32x2_t v32 = (int32x2_t)vcgtq_f32(v6, v28).u64[0];
      float32x4_t v33 = vaddq_f32(vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1)), (float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2));
      v6.f32[0] = fminf(v28.f32[0], v6.f32[0]);
      v28.i64[0] = 1103515245 * (a2 + 16777619 * (v20 ^ (v5 + 1))) + 12345;
      int32x2_t v34 = (int32x2_t)vcgtq_f32(v6, v33).u64[0];
      v28.i64[1] = 1103515245 * (v28.i64[0] + a2) + 12345;
      v6.f32[0] = fminf(v33.f32[0], v6.f32[0]);
      float32x4_t v9 = (float32x4_t)vdupq_lane_s32(v32, 0);
      *(float32x2_t *)v23.f32 = vmla_f32(*(float32x2_t *)v23.f32, vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)vandq_s8((int8x16_t)v28, v17))), v18);
      v23.f32[2] = (float)((float)(1103515245 * (1103515245 * (v28.i32[0] + a2) + 12345 + a2) + 12345) * 2.3283e-10)
                 + 1.0;
      float32x4_t v35 = vaddq_f32(v23, a4);
      float32x4_t v36 = vsubq_f32(v10, v35);
      float32x4_t v37 = vmulq_f32(v36, v36);
      int8x16_t v38 = vbslq_s8((int8x16_t)v9, (int8x16_t)v24, v15);
      float32x4_t v8 = vaddq_f32(vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1)), (float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2));
      int8x16_t v15 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v6, v8), 0), (int8x16_t)v35, vbslq_s8((int8x16_t)vdupq_lane_s32(v34, 0), (int8x16_t)v29, v38));
      v6.f32[0] = fminf(v8.f32[0], v6.f32[0]);
    }
    ++v16;
  }
  while (v16 != 2);
  if (a1)
  {
    float v39 = -(a5 + sqrtf(v6.f32[0]) * -1.73205081 * a5);
    float v40 = fminf(v39, 1.0);
  }
  else
  {
    float v40 = fminf((float)(a5 * 2.3283e-10)* (float)(-131238505 * ((16777619 * ((16777619 * (v15.i32[0] ^ 0x811C9DC5)) ^ v15.i32[1])) ^ v15.i32[2])+ 12345), 1.0);
  }
  return fmaxf(v40, 0.0);
}

void sub_235EECE04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EECE18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EECEC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EECED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EECF9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EECFB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EECFC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EED074(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EED088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *ClipperLib::PolyTree::Clear(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[10];
  uint64_t v3 = this[11];
  if (v3 != v2)
  {
    unint64_t v4 = 0;
    do
    {
      this = *(void **)(v2 + 8 * v4);
      if (this)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v2 = v1[10];
        uint64_t v3 = v1[11];
      }
      ++v4;
    }
    while (v4 < (v3 - v2) >> 3);
    if (v3 != v2) {
      v1[11] = v2;
    }
  }
  uint64_t v5 = v1[4];
  if (v1[5] != v5) {
    v1[5] = v5;
  }
  return this;
}

uint64_t ClipperLib::PolyTree::GetFirst(ClipperLib::PolyTree *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1 == *((void *)this + 5)) {
    return 0;
  }
  else {
    return *(void *)v1;
  }
}

uint64_t ClipperLib::PolyTree::Total(ClipperLib::PolyTree *this)
{
  uint64_t v2 = (void *)*((void *)this + 10);
  uint64_t result = (*((void *)this + 11) - (void)v2) >> 3;
  if ((int)result >= 1) {
    return result - (**((void **)this + 4) != *v2);
  }
  return result;
}

double ClipperLib::PolyNode::PolyNode(ClipperLib::PolyNode *this)
{
  *(void *)this = &unk_26E9431E0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 53) = 0u;
  return result;
}

uint64_t ClipperLib::PolyNode::ChildCount(ClipperLib::PolyNode *this)
{
  return (*((void *)this + 5) - *((void *)this + 4)) >> 3;
}

void ClipperLib::PolyNode::AddChild(ClipperLib::PolyNode *this, ClipperLib::PolyNode *a2)
{
  uint64_t v5 = (char *)*((void *)this + 4);
  float32x4_t v6 = (char *)*((void *)this + 5);
  unint64_t v4 = (void **)((char *)this + 32);
  unint64_t v7 = *((void *)this + 6);
  float32x4_t v8 = v6;
  uint64_t v9 = v6 - v5;
  if ((unint64_t)v6 < v7)
  {
    *(void *)float32x4_t v6 = a2;
    uint64_t v10 = (uint64_t)(v6 + 8);
    goto LABEL_23;
  }
  uint64_t v11 = v9 >> 3;
  unint64_t v12 = (v9 >> 3) + 1;
  if (v12 >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v13 = v7 - (void)v5;
  if (v13 >> 2 > v12) {
    unint64_t v12 = v13 >> 2;
  }
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14)
  {
    if (v14 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x16_t v15 = operator new(8 * v14);
    uint64_t v16 = &v15[8 * v11];
    int8x16_t v17 = &v15[8 * v14];
    void *v16 = a2;
    uint64_t v10 = (uint64_t)(v16 + 1);
    float32x2_t v18 = (char *)(v6 - v5);
    if (v6 == v5) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  int8x16_t v15 = 0;
  uint64_t v16 = (void *)(8 * v11);
  int8x16_t v17 = 0;
  *(void *)(8 * v11) = a2;
  uint64_t v10 = 8 * v11 + 8;
  float32x2_t v18 = (char *)(v6 - v5);
  if (v6 != v5)
  {
LABEL_14:
    unint64_t v19 = (unint64_t)(v18 - 8);
    if (v19 < 0x58) {
      goto LABEL_28;
    }
    if ((unint64_t)(v6 - &v15[v9 & 0xFFFFFFFFFFFFFFF8]) < 0x20) {
      goto LABEL_28;
    }
    uint64_t v20 = (v19 >> 3) + 1;
    uint64_t v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
    float32x4_t v8 = &v6[-v21];
    uint64_t v16 = (void *)((char *)v16 - v21);
    float32x2_t v22 = &v15[8 * v11 - 16];
    float32x4_t v23 = v6 - 16;
    uint64_t v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v25 = *(_OWORD *)v23;
      *(v22 - 1) = *((_OWORD *)v23 - 1);
      *float32x2_t v22 = v25;
      v22 -= 2;
      v23 -= 32;
      v24 -= 4;
    }
    while (v24);
    if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        uint64_t v26 = *((void *)v8 - 1);
        v8 -= 8;
        *--uint64_t v16 = v26;
      }
      while (v8 != v5);
    }
    float32x4_t v8 = (char *)*v4;
  }
LABEL_21:
  *((void *)this + 4) = v16;
  *((void *)this + 5) = v10;
  *((void *)this + 6) = v17;
  if (v8) {
    operator delete(v8);
  }
LABEL_23:
  *((void *)this + 5) = v10;
  *((void *)a2 + 7) = this;
  *((_DWORD *)a2 + 16) = (unint64_t)v9 >> 3;
}

uint64_t ClipperLib::PolyNode::GetNext(ClipperLib::PolyNode *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1 != *((void *)this + 5)) {
    return *(void *)v1;
  }
  do
  {
    uint64_t v5 = *((void *)this + 7);
    if (!v5) {
      return 0;
    }
    uint64_t v3 = *((unsigned int *)this + 16);
    uint64_t v4 = *(void *)(v5 + 32);
    this = (ClipperLib::PolyNode *)*((void *)this + 7);
  }
  while (((*(void *)(v5 + 40) - v4) >> 3) - 1 == v3);
  return *(void *)(v4 + 8 * (v3 + 1));
}

uint64_t ClipperLib::PolyNode::GetNextSiblingUp(ClipperLib::PolyNode *this)
{
  while (1)
  {
    uint64_t v1 = *((void *)this + 7);
    if (!v1) {
      break;
    }
    uint64_t v2 = *((unsigned int *)this + 16);
    uint64_t v3 = *(void *)(v1 + 32);
    this = (ClipperLib::PolyNode *)*((void *)this + 7);
    if (((*(void *)(v1 + 40) - v3) >> 3) - 1 != v2) {
      return *(void *)(v3 + 8 * (v2 + 1));
    }
  }
  return 0;
}

uint64_t ClipperLib::PolyNode::IsHole(ClipperLib::PolyNode *this)
{
  int v1 = 1;
  do
  {
    char v2 = v1;
    this = (ClipperLib::PolyNode *)*((void *)this + 7);
    v1 ^= 1u;
  }
  while (this);
  return v2 & 1;
}

uint64_t ClipperLib::PolyNode::IsOpen(ClipperLib::PolyNode *this)
{
  return *((unsigned __int8 *)this + 68);
}

unint64_t ClipperLib::Int128Mul@<X0>(unint64_t this@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v3 = this >> 63;
  unint64_t v4 = (unint64_t)a2 >> 63;
  if ((this & 0x8000000000000000) == 0) {
    uint64_t v5 = this;
  }
  else {
    uint64_t v5 = -(uint64_t)this;
  }
  if (a2 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = -a2;
  }
  unint64_t v7 = v6 * (unint64_t)v5;
  unint64_t v8 = ((HIDWORD(v6) * (unint64_t)v5 + v6 * (unint64_t)HIDWORD(v5)) >> 32)
     + HIDWORD(v6) * (unint64_t)HIDWORD(v5);
  unint64_t v9 = v6 * v5;
  *a3 = v9;
  a3[1] = v8;
  if (v9 < v7)
  {
    a3[1] = ++v8;
    if (v3 == v4) {
      return this;
    }
  }
  else if (v3 == v4)
  {
    return this;
  }
  unint64_t v10 = -(uint64_t)v8;
  if (v9) {
    unint64_t v10 = ~v8;
  }
  *a3 = -(uint64_t)v9;
  a3[1] = v10;
  return this;
}

uint64_t *ClipperLib::Swap(uint64_t *this, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *this;
  *this = *a2;
  *a2 = v3;
  return this;
}

BOOL ClipperLib::Orientation(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = a1[1] - *a1;
  if ((int)(v2 >> 4) < 3) {
    return 1;
  }
  uint64_t v4 = 0;
  uint64_t v5 = (v2 >> 4) - 1;
  uint64_t v6 = (v2 >> 4);
  double v7 = 0.0;
  do
  {
    float64x2_t v8 = vcvtq_f64_s64(*(int64x2_t *)(v1 + 16 * (int)v5));
    float64x2_t v9 = vcvtq_f64_s64(*(int64x2_t *)(v1 + 16 * v4));
    double v7 = vmulq_laneq_f64(vaddq_f64(v8, v9), vsubq_f64(v8, v9), 1).f64[0] + v7;
    LODWORD(v5) = v4++;
  }
  while (v6 != v4);
  return v7 * -0.5 >= 0.0;
}

float64_t ClipperLib::Area(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = a1[1] - *a1;
  float64_t result = 0.0;
  if ((int)(v2 >> 4) >= 3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (v2 >> 4) - 1;
    uint64_t v6 = (v2 >> 4);
    do
    {
      float64x2_t v7 = vcvtq_f64_s64(*(int64x2_t *)(v1 + 16 * (int)v5));
      float64x2_t v8 = vcvtq_f64_s64(*(int64x2_t *)(v1 + 16 * v4));
      float64_t result = vmulq_laneq_f64(vaddq_f64(v7, v8), vsubq_f64(v7, v8), 1).f64[0] + result;
      LODWORD(v5) = v4++;
    }
    while (v6 != v4);
    return result * -0.5;
  }
  return result;
}

double ClipperLib::Area(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (!v1) {
    return 0.0;
  }
  double v2 = 0.0;
  uint64_t v3 = *(void **)(a1 + 24);
  do
  {
    double v2 = v2 + (double)(uint64_t)(*(void *)(v3[4] + 16) - v3[2]) * (double)(uint64_t)(v3[1] + *(void *)(v3[4] + 8));
    uint64_t v3 = (void *)v3[3];
  }
  while (v3 != v1);
  return v2 * 0.5;
}

uint64_t ClipperLib::PointIsVertex(uint64_t *a1, void *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = a2;
  do
  {
    BOOL v5 = v4[1] == v2 && v4[2] == v3;
    uint64_t result = v5;
    if (v5) {
      break;
    }
    uint64_t v4 = (void *)v4[3];
  }
  while (v4 != a2);
  return result;
}

uint64_t ClipperLib::PointInPolygon(void *a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)a2;
  uint64_t v3 = *(void *)(a2 + 8) - *(void *)a2;
  if ((unint64_t)v3 < 0x30) {
    return 0;
  }
  uint64_t result = 0;
  unint64_t v6 = v3 >> 4;
  uint64_t v8 = *v2;
  uint64_t v7 = v2[1];
  unint64_t v9 = 1;
  unint64_t v12 = a1;
  uint64_t v10 = *a1;
  uint64_t v11 = v12[1];
  while (1)
  {
    unint64_t v13 = v6 == v9 ? 0 : v9;
    unint64_t v14 = &v2[2 * v13];
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1];
    if (v16 == v11 && (v15 == v10 || v7 == v11 && v15 <= v10 != v8 < v10)) {
      return 0xFFFFFFFFLL;
    }
    if (v7 >= v11 != v16 < v11) {
      goto LABEL_5;
    }
    BOOL v18 = __OFSUB__(v8, v10);
    BOOL v17 = v8 - v10 < 0;
    uint64_t v19 = v8 - v10;
    if (v17 != v18)
    {
      uint64_t v20 = v15 - v10;
      if (v15 <= v10) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v20 = v15 - v10;
      if (v15 > v10)
      {
        uint64_t result = (1 - result);
        goto LABEL_5;
      }
    }
    double v21 = -((double)v20 * (double)(v7 - v11) - (double)v19 * (double)(v16 - v11));
    if (v21 == 0.0) {
      return 0xFFFFFFFFLL;
    }
    if (v16 > v7 != v21 <= 0.0) {
      uint64_t result = (1 - result);
    }
    else {
      uint64_t result = result;
    }
LABEL_5:
    ++v9;
    uint64_t v8 = v15;
    uint64_t v7 = v16;
    if (v9 > v6) {
      return result;
    }
  }
}

uint64_t ClipperLib::PointInPolygon(void *a1, void *a2)
{
  uint64_t result = 0;
  unint64_t v6 = a1;
  uint64_t v4 = *a1;
  uint64_t v5 = v6[1];
  uint64_t v7 = a2;
  while (1)
  {
    uint64_t v8 = v7;
    uint64_t v7 = (void *)v7[3];
    uint64_t v9 = v7[2];
    if (v9 != v5)
    {
      uint64_t v11 = v8[2];
LABEL_10:
      if (v9 < v5 != v11 >= v5) {
        goto LABEL_2;
      }
      goto LABEL_11;
    }
    uint64_t v10 = v7[1];
    if (v10 == v4) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v11 = v8[2];
    if (v11 != v5) {
      goto LABEL_10;
    }
    if (v10 <= v4 != v8[1] < v4) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v11 = v5;
    if (v9 >= v5) {
      goto LABEL_2;
    }
LABEL_11:
    uint64_t v12 = v8[1];
    uint64_t v13 = v7[1];
    BOOL v15 = __OFSUB__(v12, v4);
    BOOL v14 = v12 - v4 < 0;
    uint64_t v16 = v12 - v4;
    if (v14 == v15) {
      break;
    }
    BOOL v15 = __OFSUB__(v13, v4);
    BOOL v17 = v13 == v4;
    BOOL v14 = v13 - v4 < 0;
    uint64_t v18 = v13 - v4;
    if (!(v14 ^ v15 | v17)) {
      goto LABEL_17;
    }
LABEL_2:
    if (v7 == a2) {
      return result;
    }
  }
  BOOL v15 = __OFSUB__(v13, v4);
  BOOL v17 = v13 == v4;
  BOOL v14 = v13 - v4 < 0;
  uint64_t v18 = v13 - v4;
  if (!(v14 ^ v15 | v17))
  {
    uint64_t result = (1 - result);
    goto LABEL_2;
  }
LABEL_17:
  double v19 = -((double)v18 * (double)(v11 - v5) - (double)v16 * (double)(v9 - v5));
  if (v19 != 0.0)
  {
    if (v9 > v11 != v19 <= 0.0) {
      uint64_t result = (1 - result);
    }
    else {
      uint64_t result = result;
    }
    goto LABEL_2;
  }
  return 0xFFFFFFFFLL;
}

BOOL ClipperLib::Poly2ContainsPoly1(uint64_t a1, void *a2)
{
  uint64_t v4 = a1;
  while (1)
  {
    int v5 = ClipperLib::PointInPolygon((void *)(v4 + 8), a2);
    if ((v5 & 0x80000000) == 0) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 24);
    if (v4 == a1) {
      return 1;
    }
  }
  return v5 != 0;
}

BOOL ClipperLib::SlopesEqual(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(a2 + 48);
  if (a3)
  {
    unint64_t v5 = (unint64_t)v3 >> 63;
    unint64_t v6 = (unint64_t)v4 >> 63;
    if (v3 < 0) {
      uint64_t v3 = -v3;
    }
    if (v4 < 0) {
      uint64_t v4 = -v4;
    }
    unint64_t v7 = v4 * (unint64_t)v3;
    unint64_t v8 = ((HIDWORD(v4) * (unint64_t)v3 + v4 * (unint64_t)HIDWORD(v3)) >> 32)
       + HIDWORD(v4) * (unint64_t)HIDWORD(v3);
    unint64_t v9 = v4 * v3;
    if (v9 >= v7) {
      unint64_t v10 = v8;
    }
    else {
      unint64_t v10 = v8 + 1;
    }
    unint64_t v11 = -(uint64_t)v10;
    if (v9) {
      unint64_t v11 = ~v10;
    }
    BOOL v12 = v5 == v6;
    if (v5 == v6) {
      unint64_t v13 = v10;
    }
    else {
      unint64_t v13 = v11;
    }
    if (!v12) {
      unint64_t v9 = -(uint64_t)v9;
    }
    uint64_t v14 = *(void *)(a1 + 48);
    uint64_t v15 = *(void *)(a2 + 56);
    unint64_t v16 = (unint64_t)v14 >> 63;
    unint64_t v17 = (unint64_t)v15 >> 63;
    if (v14 < 0) {
      uint64_t v14 = -v14;
    }
    if (v15 < 0) {
      uint64_t v15 = -v15;
    }
    unint64_t v18 = v15 * (unint64_t)v14;
    unint64_t v19 = ((HIDWORD(v15) * (unint64_t)v14 + v15 * (unint64_t)HIDWORD(v14)) >> 32)
        + HIDWORD(v15) * (unint64_t)HIDWORD(v14);
    unint64_t v20 = v15 * v14;
    if (v20 >= v18) {
      unint64_t v21 = v19;
    }
    else {
      unint64_t v21 = v19 + 1;
    }
    uint64_t v22 = -(uint64_t)v21;
    if (v20) {
      uint64_t v22 = ~v21;
    }
    if (v16 != v17)
    {
      unint64_t v21 = v22;
      unint64_t v20 = -(uint64_t)v20;
    }
    if (v13 != v21) {
      return 0;
    }
  }
  else
  {
    unint64_t v9 = v4 * v3;
    unint64_t v20 = *(void *)(a2 + 56) * *(void *)(a1 + 48);
  }
  return v9 == v20;
}

BOOL ClipperLib::SlopesEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7 = a2 - a4;
  uint64_t v8 = a3 - a5;
  if (a7)
  {
    unint64_t v9 = (unint64_t)v7 >> 63;
    unint64_t v10 = (unint64_t)v8 >> 63;
    if (v7 < 0) {
      uint64_t v7 = a4 - a2;
    }
    if (v8 < 0) {
      uint64_t v8 = a5 - a3;
    }
    unint64_t v11 = v8 * (unint64_t)v7;
    unint64_t v12 = ((HIDWORD(v8) * (unint64_t)v7 + v8 * (unint64_t)HIDWORD(v7)) >> 32)
        + HIDWORD(v8) * (unint64_t)HIDWORD(v7);
    unint64_t v13 = v8 * v7;
    if (v13 >= v11) {
      unint64_t v14 = v12;
    }
    else {
      unint64_t v14 = v12 + 1;
    }
    unint64_t v15 = -(uint64_t)v14;
    if (v13) {
      unint64_t v15 = ~v14;
    }
    BOOL v16 = v9 == v10;
    if (v9 == v10) {
      unint64_t v17 = v14;
    }
    else {
      unint64_t v17 = v15;
    }
    if (!v16) {
      unint64_t v13 = -(uint64_t)v13;
    }
    uint64_t v18 = a1 - a3;
    uint64_t v19 = a4 - a6;
    unint64_t v20 = (unint64_t)(a1 - a3) >> 63;
    if (a1 - a3 < 0) {
      uint64_t v18 = a3 - a1;
    }
    if (v19 < 0) {
      uint64_t v19 = a6 - a4;
    }
    unint64_t v21 = v19 * (unint64_t)v18;
    unint64_t v22 = ((HIDWORD(v19) * (unint64_t)v18 + v19 * (unint64_t)HIDWORD(v18)) >> 32)
        + HIDWORD(v19) * (unint64_t)HIDWORD(v18);
    unint64_t v23 = v19 * v18;
    if (v23 >= v21) {
      unint64_t v24 = v22;
    }
    else {
      unint64_t v24 = v22 + 1;
    }
    uint64_t v25 = -(uint64_t)v24;
    if (v23) {
      uint64_t v25 = ~v24;
    }
    if (v20 != (unint64_t)(a4 - a6) >> 63)
    {
      unint64_t v24 = v25;
      unint64_t v23 = -(uint64_t)v23;
    }
    if (v17 != v24) {
      return 0;
    }
  }
  else
  {
    unint64_t v13 = v8 * v7;
    unint64_t v23 = (a4 - a6) * (a1 - a3);
  }
  return v13 == v23;
}

BOOL ClipperLib::SlopesEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = a2 - a4;
  uint64_t v10 = a5 - a7;
  if (a9)
  {
    unint64_t v11 = (unint64_t)v9 >> 63;
    unint64_t v12 = (unint64_t)v10 >> 63;
    if (v9 < 0) {
      uint64_t v9 = a4 - a2;
    }
    if (v10 < 0) {
      uint64_t v10 = a7 - a5;
    }
    unint64_t v13 = v10 * (unint64_t)v9;
    unint64_t v14 = ((HIDWORD(v10) * (unint64_t)v9 + v10 * (unint64_t)HIDWORD(v9)) >> 32)
        + HIDWORD(v10) * (unint64_t)HIDWORD(v9);
    unint64_t v15 = v10 * v9;
    if (v15 >= v13) {
      unint64_t v16 = v14;
    }
    else {
      unint64_t v16 = v14 + 1;
    }
    unint64_t v17 = -(uint64_t)v16;
    if (v15) {
      unint64_t v17 = ~v16;
    }
    BOOL v18 = v11 == v12;
    if (v11 == v12) {
      unint64_t v19 = v16;
    }
    else {
      unint64_t v19 = v17;
    }
    if (!v18) {
      unint64_t v15 = -(uint64_t)v15;
    }
    uint64_t v20 = a1 - a3;
    uint64_t v21 = a6 - a8;
    unint64_t v22 = (unint64_t)(a1 - a3) >> 63;
    if (a1 - a3 < 0) {
      uint64_t v20 = a3 - a1;
    }
    if (v21 < 0) {
      uint64_t v21 = a8 - a6;
    }
    unint64_t v23 = v21 * (unint64_t)v20;
    unint64_t v24 = ((HIDWORD(v21) * (unint64_t)v20 + v21 * (unint64_t)HIDWORD(v20)) >> 32)
        + HIDWORD(v21) * (unint64_t)HIDWORD(v20);
    unint64_t v25 = v21 * v20;
    if (v25 >= v23) {
      unint64_t v26 = v24;
    }
    else {
      unint64_t v26 = v24 + 1;
    }
    uint64_t v27 = -(uint64_t)v26;
    if (v25) {
      uint64_t v27 = ~v26;
    }
    if (v22 != (unint64_t)(a6 - a8) >> 63)
    {
      unint64_t v26 = v27;
      unint64_t v25 = -(uint64_t)v25;
    }
    if (v19 != v26) {
      return 0;
    }
  }
  else
  {
    unint64_t v15 = v10 * v9;
    unint64_t v25 = (a6 - a8) * (a1 - a3);
  }
  return v15 == v25;
}

double ClipperLib::IntersectPoint(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  double result = *(double *)(a1 + 64);
  double v4 = *(double *)(a2 + 64);
  if (result == v4)
  {
    uint64_t v5 = *(void *)(a1 + 24);
    a3[1] = v5;
    if (*(void *)(a1 + 40) == v5)
    {
      *a3 = *(void *)(a1 + 32);
    }
    else
    {
      double v20 = result * (double)(v5 - *(void *)(a1 + 8));
      double v21 = 0.5;
      if (v20 < 0.0) {
        double v21 = -0.5;
      }
      double result = v21 + v20;
      *a3 = *(void *)a1 + (uint64_t)result;
    }
    return result;
  }
  if (!*(void *)(a1 + 48))
  {
    uint64_t v22 = *(void *)a1;
    *a3 = *(void *)a1;
    uint64_t v9 = *(void *)(a2 + 8);
    if (!*(void *)(a2 + 56)) {
      goto LABEL_33;
    }
    double v23 = (double)v9 - (double)*(uint64_t *)a2 / v4;
    double v24 = (double)v22 / v4;
    goto LABEL_30;
  }
  if (!*(void *)(a2 + 48))
  {
    uint64_t v25 = *(void *)a2;
    *a3 = *(void *)a2;
    uint64_t v9 = *(void *)(a1 + 8);
    if (!*(void *)(a1 + 56)) {
      goto LABEL_33;
    }
    double v23 = (double)v9 - (double)*(uint64_t *)a1 / result;
    double v24 = (double)v25 / result;
LABEL_30:
    double v26 = v23 + v24;
    double v27 = 0.5;
    if (v26 < 0.0) {
      double v27 = -0.5;
    }
    uint64_t v9 = (uint64_t)(v27 + v26);
LABEL_33:
    a3[1] = v9;
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = *(void *)(a2 + 40);
    if (v9 >= v16 && v9 >= v17) {
      goto LABEL_21;
    }
LABEL_38:
    if (v16 <= v17) {
      uint64_t v29 = v17;
    }
    else {
      uint64_t v29 = v16;
    }
    a3[1] = v29;
    if (fabs(result) >= fabs(v4))
    {
      if (*(void *)(a2 + 40) == v29)
      {
        uint64_t v30 = *(void *)(a2 + 32);
        goto LABEL_51;
      }
      uint64_t v31 = *(void *)a2;
      double v32 = v4 * (double)(v29 - *(void *)(a2 + 8));
    }
    else
    {
      if (*(void *)(a1 + 40) == v29)
      {
        uint64_t v30 = *(void *)(a1 + 32);
        goto LABEL_51;
      }
      uint64_t v31 = *(void *)a1;
      double v32 = result * (double)(v29 - *(void *)(a1 + 8));
    }
    double v33 = 0.5;
    if (v32 < 0.0) {
      double v33 = -0.5;
    }
    uint64_t v30 = v31 + (uint64_t)(v33 + v32);
LABEL_51:
    *a3 = v30;
    uint64_t v19 = *(void *)(a1 + 24);
    if (v29 <= v19) {
      return result;
    }
    goto LABEL_52;
  }
  double v6 = (double)*(uint64_t *)a1 - result * (double)*(uint64_t *)(a1 + 8);
  double v7 = ((double)*(uint64_t *)a2 - v4 * (double)*(uint64_t *)(a2 + 8) - v6) / (result - v4);
  if (v7 >= 0.0) {
    double v8 = 0.5;
  }
  else {
    double v8 = -0.5;
  }
  uint64_t v9 = (uint64_t)(v8 + v7);
  double v10 = fabs(result);
  double v11 = fabs(v4);
  BOOL v12 = v10 < v11;
  if (v10 >= v11) {
    double v13 = *(double *)(a2 + 64);
  }
  else {
    double v13 = *(double *)(a1 + 64);
  }
  if (!v12) {
    double v6 = (double)*(uint64_t *)a2 - v4 * (double)*(uint64_t *)(a2 + 8);
  }
  double v14 = v6 + v7 * v13;
  if (v14 >= 0.0) {
    double v15 = 0.5;
  }
  else {
    double v15 = -0.5;
  }
  *a3 = (uint64_t)(v15 + v14);
  a3[1] = v9;
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v17 = *(void *)(a2 + 40);
  if (v9 < v16 || v9 < v17) {
    goto LABEL_38;
  }
LABEL_21:
  uint64_t v19 = *(void *)(a1 + 24);
  if (v9 <= v19) {
    return result;
  }
LABEL_52:
  a3[1] = v19;
  if (fabs(result) <= fabs(v4))
  {
    if (*(void *)(a1 + 40) == v19)
    {
      *a3 = *(void *)(a1 + 32);
      return result;
    }
    uint64_t v34 = *(void *)a1;
    double v35 = result * (double)(v19 - *(void *)(a1 + 8));
  }
  else
  {
    if (*(void *)(a2 + 40) == v19)
    {
      *a3 = *(void *)(a2 + 32);
      return result;
    }
    uint64_t v34 = *(void *)a2;
    double v35 = v4 * (double)(v19 - *(void *)(a2 + 8));
  }
  double v36 = 0.5;
  if (v35 < 0.0) {
    double v36 = -0.5;
  }
  double result = v36 + v35;
  *a3 = v34 + (uint64_t)result;
  return result;
}

int8x16_t ClipperLib::ReversePolyPtLinks(unint64_t a1)
{
  if (a1)
  {
    unint64_t v1 = a1;
    do
    {
      int8x16_t result = *(int8x16_t *)(v1 + 24);
      *(int8x16_t *)(v1 + 24) = vextq_s8(result, result, 8uLL);
      unint64_t v1 = result.i64[0];
    }
    while (result.i64[0] != a1);
  }
  return result;
}

void *ClipperLib::DisposeOutPts(void *result)
{
  if (*result)
  {
    unint64_t v1 = result;
    *(void *)(*(void *)(*result + 32) + 24) = 0;
    int8x16_t result = (void *)*result;
    if (result)
    {
      do
      {
        void *v1 = result[3];
        MEMORY[0x237DF7CA0]();
        int8x16_t result = (void *)*v1;
      }
      while (*v1);
    }
  }
  return result;
}

double ClipperLib::InitEdge2(uint64_t a1, int a2)
{
  uint64_t v2 = (_OWORD *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 96);
  if (*(void *)(a1 + 24) >= *(void *)(v3 + 24))
  {
    *(_OWORD *)a1 = *v2;
    *(_OWORD *)(a1 + 32) = *(_OWORD *)(v3 + 16);
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 32) - *(void *)a1;
    uint64_t v7 = v9 - v10;
    *(void *)(a1 + 48) = v6;
    *(void *)(a1 + 56) = v9 - v10;
    if (v9 != v10) {
      goto LABEL_3;
    }
  }
  else
  {
    *(_OWORD *)(a1 + 32) = *v2;
    *(_OWORD *)a1 = *(_OWORD *)(v3 + 16);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 32) - *(void *)a1;
    uint64_t v7 = v4 - v5;
    *(void *)(a1 + 48) = v6;
    *(void *)(a1 + 56) = v4 - v5;
    if (v4 != v5)
    {
LABEL_3:
      double result = (double)v6 / (double)v7;
      *(double *)(a1 + 64) = result;
      *(_DWORD *)(a1 + 72) = a2;
      return result;
    }
  }
  double result = -1.0e40;
  *(void *)(a1 + 64) = 0xC83D6329F1C35CA5;
  *(_DWORD *)(a1 + 72) = a2;
  return result;
}

uint64_t ClipperLib::RemoveEdge(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 104);
  *(void *)(v1 + 96) = *(void *)(a1 + 96);
  uint64_t v2 = *(void *)(a1 + 96);
  *(void *)(v2 + 104) = v1;
  *(void *)(a1 + 104) = 0;
  return v2;
}

__n128 ClipperLib::SwapPoints(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a1 = *a2;
  *a2 = result;
  return result;
}

BOOL ClipperLib::GetOverlapSegment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  unint64_t v10 = a1 - a3;
  if (a1 - a3 < 0) {
    unint64_t v10 = a3 - a1;
  }
  unint64_t v11 = a2 - a4;
  if (a2 - a4 < 0) {
    unint64_t v11 = a4 - a2;
  }
  if (v10 <= v11)
  {
    if (a2 < a4) {
      uint64_t v23 = a4;
    }
    else {
      uint64_t v23 = a2;
    }
    if (a2 < a4) {
      uint64_t v24 = a3;
    }
    else {
      uint64_t v24 = a1;
    }
    if (a2 < a4) {
      uint64_t v25 = a2;
    }
    else {
      uint64_t v25 = a4;
    }
    if (a2 < a4) {
      uint64_t v26 = a1;
    }
    else {
      uint64_t v26 = a3;
    }
    if (a6 < a8) {
      uint64_t v27 = a8;
    }
    else {
      uint64_t v27 = a6;
    }
    if (a6 < a8) {
      uint64_t v28 = a7;
    }
    else {
      uint64_t v28 = a5;
    }
    if (a6 < a8) {
      uint64_t v29 = a6;
    }
    else {
      uint64_t v29 = a8;
    }
    if (a6 < a8) {
      uint64_t v30 = a5;
    }
    else {
      uint64_t v30 = a7;
    }
    if (v23 >= v27)
    {
      uint64_t v24 = v28;
      uint64_t v23 = v27;
    }
    *a9 = v24;
    a9[1] = v23;
    if (v25 <= v29) {
      uint64_t v31 = v30;
    }
    else {
      uint64_t v31 = v26;
    }
    if (v25 <= v29) {
      uint64_t v32 = v29;
    }
    else {
      uint64_t v32 = v25;
    }
    *a10 = v31;
    a10[1] = v32;
    return a9[1] > v32;
  }
  else
  {
    if (a1 > a3) {
      uint64_t v12 = a4;
    }
    else {
      uint64_t v12 = a2;
    }
    if (a1 > a3) {
      uint64_t v13 = a3;
    }
    else {
      uint64_t v13 = a1;
    }
    if (a1 > a3) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = a4;
    }
    if (a1 > a3) {
      uint64_t v15 = a1;
    }
    else {
      uint64_t v15 = a3;
    }
    if (a5 > a7) {
      uint64_t v16 = a8;
    }
    else {
      uint64_t v16 = a6;
    }
    if (a5 > a7) {
      uint64_t v17 = a7;
    }
    else {
      uint64_t v17 = a5;
    }
    if (a5 > a7) {
      uint64_t v18 = a6;
    }
    else {
      uint64_t v18 = a8;
    }
    if (a5 > a7) {
      uint64_t v19 = a5;
    }
    else {
      uint64_t v19 = a7;
    }
    if (v13 <= v17)
    {
      uint64_t v13 = v17;
      uint64_t v12 = v16;
    }
    *a9 = v13;
    a9[1] = v12;
    if (v15 >= v19) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v15;
    }
    if (v15 >= v19) {
      uint64_t v21 = v18;
    }
    else {
      uint64_t v21 = v14;
    }
    *a10 = v20;
    a10[1] = v21;
    return *a9 < v20;
  }
}

BOOL ClipperLib::FirstIsBottomPt(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  uint64_t v4 = a1;
  do
  {
    uint64_t v4 = (void *)v4[4];
    uint64_t v5 = v4[1];
    uint64_t v6 = v4[2];
  }
  while (v4 != a1 && v5 == v2 && v6 == v3);
  uint64_t v9 = v6 - v3;
  if (v9) {
    double v10 = (double)(v5 - v2) / (double)v9;
  }
  else {
    double v10 = -1.0e40;
  }
  unint64_t v11 = a1;
  do
  {
    unint64_t v11 = (void *)v11[3];
    uint64_t v12 = v11[1];
    uint64_t v13 = v11[2];
  }
  while (v11 != a1 && v12 == v2 && v13 == v3);
  uint64_t v16 = v13 - v3;
  if (v16) {
    double v17 = (double)(v12 - v2) / (double)v16;
  }
  else {
    double v17 = -1.0e40;
  }
  double v18 = fabs(v10);
  uint64_t v19 = a2[1];
  uint64_t v20 = a2[2];
  uint64_t v21 = a2;
  do
  {
    uint64_t v21 = (void *)v21[4];
    uint64_t v22 = v21[1];
    uint64_t v23 = v21[2];
  }
  while (v21 != a2 && v22 == v19 && v23 == v20);
  if (v23 == v20) {
    double v26 = -1.0e40;
  }
  else {
    double v26 = (double)(v22 - v19) / (double)(v23 - v20);
  }
  double v27 = fabs(v17);
  uint64_t v28 = a2;
  do
  {
    uint64_t v28 = (void *)v28[3];
    uint64_t v29 = v28[1];
    uint64_t v30 = v28[2];
  }
  while (v28 != a2 && v29 == v19 && v30 == v20);
  double v33 = fabs(v26);
  uint64_t v34 = v30 - v20;
  if (v34)
  {
    double v35 = fabs((double)(v29 - v19) / (double)v34);
    if (v18 >= v33 && v18 >= v35) {
      return 1;
    }
  }
  else
  {
    double v35 = fabs(-1.0e40);
    if (v18 >= v33 && v18 >= v35) {
      return 1;
    }
  }
  return v27 >= v35 && v27 >= v33;
}

void *ClipperLib::GetBottomPt(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1) {
    return v1;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v4 = v2[2];
    uint64_t v5 = v1[2];
    if (v4 > v5)
    {
LABEL_3:
      uint64_t v3 = 0;
      uint64_t v1 = v2;
      goto LABEL_4;
    }
    if (v4 == v5)
    {
      uint64_t v6 = v2[1];
      uint64_t v7 = v1[1];
      if (v6 <= v7)
      {
        if (v6 < v7) {
          goto LABEL_3;
        }
        if ((void *)v2[3] != v1 && (void *)v2[4] != v1) {
          uint64_t v3 = v2;
        }
      }
    }
LABEL_4:
    uint64_t v2 = (void *)v2[3];
  }
  while (v2 != v1);
  if (!v3 || v3 == v1) {
    return v1;
  }
  double v8 = v1;
  do
  {
    if (!ClipperLib::FirstIsBottomPt(v1, v3)) {
      double v8 = v3;
    }
    do
      uint64_t v3 = (void *)v3[3];
    while (v3[1] != v8[1] || v3[2] != v8[2]);
  }
  while (v3 != v1);
  return v8;
}

uint64_t ClipperLib::Pt2IsBetweenPt1AndPt3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a1 == a5 && a2 == a6) {
    return 0;
  }
  if (a1 == a3 && a2 == a4) {
    return 0;
  }
  if (a5 == a3 && a6 == a4) {
    return 0;
  }
  if (a1 == a5) {
    return (a4 <= a2) ^ (a4 < a6);
  }
  return (a3 <= a1) ^ (a3 < a5);
}

BOOL ClipperLib::HorzSegmentsOverlap(ClipperLib *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((uint64_t)this >= a2) {
    uint64_t v4 = (ClipperLib *)a2;
  }
  else {
    uint64_t v4 = this;
  }
  if ((uint64_t)this <= a2) {
    uint64_t v5 = (ClipperLib *)a2;
  }
  else {
    uint64_t v5 = this;
  }
  if (a3 >= a4) {
    uint64_t v6 = a4;
  }
  else {
    uint64_t v6 = a3;
  }
  if (a3 <= a4) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = a3;
  }
  return (uint64_t)v4 < v7 && v6 < (uint64_t)v5;
}

double ClipperLib::ClipperBase::ClipperBase(ClipperLib::ClipperBase *this)
{
  *(void *)this = &unk_26E943200;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((unsigned char *)this + 40) = 0;
  return result;
}

void ClipperLib::ClipperBase::~ClipperBase(ClipperLib::ClipperBase *this)
{
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 3) = v2;
  *(void *)this = &unk_26E943200;
  *((void *)this + 1) = v2;
  uint64_t v5 = (char *)this + 48;
  uint64_t v3 = (void *)*((void *)this + 6);
  uint64_t v4 = (void *)*((void *)v5 + 1);
  if (v4 == v3)
  {
    uint64_t v3 = v4;
  }
  else
  {
    unint64_t v6 = 0;
    do
    {
      if (v3[v6])
      {
        MEMORY[0x237DF7C80](v3[v6], 0x1020C80AAFD436DLL);
        uint64_t v3 = (void *)*((void *)this + 6);
        uint64_t v4 = (void *)*((void *)this + 7);
      }
      ++v6;
    }
    while (v6 < v4 - v3);
  }
  *((void *)this + 7) = v3;
  *((unsigned char *)this + 40) = 0;
  *((unsigned char *)this + 73) = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v7 = (void *)*((void *)this + 2);
  if (v7)
  {
    *((void *)this + 3) = v7;
    operator delete(v7);
  }
}

{
  uint64_t v2;
  void *v3;
  void *v4;
  char *v5;
  unint64_t v6;
  void *v7;

  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 3) = v2;
  *(void *)this = &unk_26E943200;
  *((void *)this + 1) = v2;
  uint64_t v5 = (char *)this + 48;
  uint64_t v3 = (void *)*((void *)this + 6);
  uint64_t v4 = (void *)*((void *)v5 + 1);
  if (v4 == v3)
  {
    uint64_t v3 = v4;
  }
  else
  {
    unint64_t v6 = 0;
    do
    {
      if (v3[v6])
      {
        MEMORY[0x237DF7C80](v3[v6], 0x1020C80AAFD436DLL);
        uint64_t v3 = (void *)*((void *)this + 6);
        uint64_t v4 = (void *)*((void *)this + 7);
      }
      ++v6;
    }
    while (v6 < v4 - v3);
  }
  *((void *)this + 7) = v3;
  *((unsigned char *)this + 40) = 0;
  *((unsigned char *)this + 73) = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v7 = (void *)*((void *)this + 2);
  if (v7)
  {
    *((void *)this + 3) = v7;
    operator delete(v7);
  }
}

{
  uint64_t v2;
  void *v3;
  void *v4;
  char *v5;
  unint64_t v6;
  void *v7;
  uint64_t vars8;

  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 3) = v2;
  *(void *)this = &unk_26E943200;
  *((void *)this + 1) = v2;
  uint64_t v5 = (char *)this + 48;
  uint64_t v3 = (void *)*((void *)this + 6);
  uint64_t v4 = (void *)*((void *)v5 + 1);
  if (v4 == v3)
  {
    uint64_t v3 = v4;
  }
  else
  {
    unint64_t v6 = 0;
    do
    {
      if (v3[v6])
      {
        MEMORY[0x237DF7C80](v3[v6], 0x1020C80AAFD436DLL);
        uint64_t v3 = (void *)*((void *)this + 6);
        uint64_t v4 = (void *)*((void *)this + 7);
      }
      ++v6;
    }
    while (v6 < v4 - v3);
  }
  *((void *)this + 7) = v3;
  *((unsigned char *)this + 40) = 0;
  *((unsigned char *)this + 73) = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v7 = (void *)*((void *)this + 2);
  if (v7)
  {
    *((void *)this + 3) = v7;
    operator delete(v7);
  }

  JUMPOUT(0x237DF7CA0);
}

uint64_t *ClipperLib::RangeTest(uint64_t *result, unsigned char *a2)
{
  uint64_t v2 = *result;
  if (*a2)
  {
    if (v2 > 0x3FFFFFFFFFFFFFFFLL) {
      goto LABEL_11;
    }
  }
  else if (v2 < 0x40000000)
  {
    unint64_t v7 = result[1] - 0x40000000;
    if (v2 >= -1073741823)
    {
      BOOL v8 = v7 >= 0xFFFFFFFF80000000;
      BOOL v9 = v7 == 0xFFFFFFFF80000000;
    }
    else
    {
      BOOL v8 = 0;
      BOOL v9 = 0;
    }
    if (!v9 && v8) {
      return result;
    }
    *a2 = 1;
  }
  else
  {
    *a2 = 1;
    if (v2 > 0x3FFFFFFFFFFFFFFFLL) {
      goto LABEL_11;
    }
  }
  unint64_t v3 = result[1] - 0x4000000000000000;
  if (v2 >= (uint64_t)0xC000000000000001)
  {
    BOOL v4 = v3 >= 0x8000000000000000;
    BOOL v5 = v3 == 0x8000000000000000;
  }
  else
  {
    BOOL v4 = 0;
    BOOL v5 = 0;
  }
  if (v5 || !v4)
  {
LABEL_11:
    exceptiouint64_t n = __cxa_allocate_exception(8uLL);
    void *exception = "Coordinate outside allowed range";
    __cxa_throw(exception, MEMORY[0x263F8C1D8], 0);
  }
  return result;
}

void *ClipperLib::FindNextLocMin(void *result)
{
  while (1)
  {
    while (1)
    {
      uint64_t v1 = (void *)result[13];
      if (*result == *v1 && result[1] == v1[1] && (result[2] != result[4] || result[3] != result[5])) {
        break;
      }
      double result = (void *)result[12];
    }
    if (result[7] && v1[7]) {
      return result;
    }
    BOOL v4 = result;
    do
    {
      BOOL v5 = v4;
      BOOL v4 = (void *)v4[13];
    }
    while (!v4[7]);
    double result = v5;
    if (v5[7])
    {
      if (v5[5] != v4[1]) {
        goto LABEL_22;
      }
    }
    else
    {
      double result = v5;
      do
        double result = (void *)result[12];
      while (!result[7]);
      if (result[5] != *(void *)(result[13] + 8))
      {
LABEL_22:
        if (*v4 < *result) {
          return v5;
        }
        return result;
      }
    }
  }
}

uint64_t ClipperLib::ClipperBase::ProcessBound(void *a1, uint64_t *a2, int a3)
{
  if (*((_DWORD *)a2 + 23) != -2)
  {
    if (a2[7]) {
      goto LABEL_24;
    }
    uint64_t v8 = 12;
    if (a3) {
      uint64_t v8 = 13;
    }
    uint64_t v9 = a2[v8];
    if (*(_DWORD *)(v9 + 92) == -2) {
      goto LABEL_24;
    }
    uint64_t v10 = *a2;
    BOOL v11 = *(void *)v9 == *a2;
    if (!*(void *)(v9 + 56))
    {
      if (*(void *)v9 == *a2)
      {
LABEL_24:
        uint64_t v13 = a2;
        if (a3)
        {
          do
          {
            uint64_t v14 = v13;
            uint64_t v15 = v13[5];
            uint64_t v13 = (uint64_t *)v13[12];
          }
          while (v15 == v13[1] && *((_DWORD *)v13 + 23) != -2);
          if (!v14[7] && *((_DWORD *)v13 + 23) != -2)
          {
            uint64_t v16 = v14;
            do
              uint64_t v16 = (uint64_t *)v16[13];
            while (!v16[7]);
            uint64_t v17 = v16[4];
            uint64_t v18 = v13[4];
            if (v17 != v18 && v17 > v18) {
              uint64_t v14 = v16;
            }
          }
          if (v14 != a2)
          {
            uint64_t v19 = a2;
            do
            {
              uint64_t v20 = (uint64_t *)v19[12];
              v19[14] = (uint64_t)v20;
              if (v19 != a2 && !v19[7] && *v19 != *(void *)(v19[13] + 32))
              {
                uint64_t v21 = v19[4];
                v19[4] = *v19;
                *uint64_t v19 = v21;
              }
              uint64_t v19 = v20;
            }
            while (v20 != v14);
            if (!v14[7] && *v14 != *(void *)(v14[13] + 32))
            {
              uint64_t v36 = v14[4];
              v14[4] = *v14;
              *uint64_t v14 = v36;
            }
          }
          float32x4_t v37 = v14 + 12;
        }
        else
        {
          do
          {
            uint64_t v22 = v13;
            uint64_t v23 = v13[5];
            uint64_t v13 = (uint64_t *)v13[13];
          }
          while (v23 == v13[1] && *((_DWORD *)v13 + 23) != -2);
          if (!v22[7] && *((_DWORD *)v13 + 23) != -2)
          {
            uint64_t v24 = v22;
            do
              uint64_t v24 = (uint64_t *)v24[12];
            while (!v24[7]);
            uint64_t v25 = v24[4];
            uint64_t v26 = v13[4];
            if (v25 > v26) {
              uint64_t v22 = v24;
            }
            if (v25 == v26) {
              uint64_t v22 = v24;
            }
          }
          if (v22 != a2)
          {
            double v27 = a2;
            do
            {
              uint64_t v28 = (uint64_t *)v27[13];
              v27[14] = (uint64_t)v28;
              if (v27 != a2 && !v27[7] && *v27 != *(void *)(v27[12] + 32))
              {
                uint64_t v29 = v27[4];
                v27[4] = *v27;
                *double v27 = v29;
              }
              double v27 = v28;
            }
            while (v28 != v22);
            if (!v22[7] && *v22 != *(void *)(v22[12] + 32))
            {
              uint64_t v38 = v22[4];
              v22[4] = *v22;
              *uint64_t v22 = v38;
            }
          }
          float32x4_t v37 = v22 + 13;
        }
        return *v37;
      }
      BOOL v11 = *(void *)(v9 + 32) == v10;
    }
    if (!v11)
    {
      uint64_t v12 = a2[4];
      a2[4] = v10;
      *a2 = v12;
    }
    goto LABEL_24;
  }
  BOOL v4 = a2;
  if (a3)
  {
    do
    {
      BOOL v5 = v4;
      uint64_t v6 = v4[5];
      BOOL v4 = (uint64_t *)v4[12];
    }
    while (v6 == v4[1]);
    while (v5 != a2)
    {
      if (v5[7]) {
        goto LABEL_58;
      }
      BOOL v5 = (uint64_t *)v5[13];
    }
  }
  else
  {
    do
    {
      BOOL v5 = v4;
      uint64_t v7 = v4[5];
      BOOL v4 = (uint64_t *)v4[13];
    }
    while (v7 == v4[1]);
    while (v5 != a2)
    {
      if (v5[7])
      {
LABEL_58:
        if (v5 == a2) {
          break;
        }
        uint64_t v30 = 13;
        if (a3) {
          uint64_t v30 = 12;
        }
        uint64_t v31 = a2[v30];
        uint64_t v32 = *(void *)(v31 + 8);
        *(_DWORD *)(v31 + 80) = 0;
        uint64_t v33 = ClipperLib::ClipperBase::ProcessBound(a1, v31);
        double v35 = (void *)a1[3];
        unint64_t v34 = a1[4];
        if ((unint64_t)v35 >= v34)
        {
          float v40 = (void *)a1[2];
          unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * (v35 - v40) + 1;
          if (v41 > 0xAAAAAAAAAAAAAAALL) {
            _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
          }
          unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v34 - (void)v40) >> 3);
          if (2 * v42 > v41) {
            unint64_t v41 = 2 * v42;
          }
          if (v42 >= 0x555555555555555) {
            unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v43 = v41;
          }
          if (v43)
          {
            if (v43 > 0xAAAAAAAAAAAAAAALL) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            unint64_t v44 = (char *)operator new(24 * v43);
          }
          else
          {
            unint64_t v44 = 0;
          }
          unint64_t v45 = &v44[8 * (v35 - v40)];
          *(void *)unint64_t v45 = v32;
          *((void *)v45 + 1) = 0;
          *((void *)v45 + 2) = v31;
          BOOL v46 = v45 + 24;
          if (v35 != v40)
          {
            do
            {
              long long v47 = *(_OWORD *)(v35 - 3);
              *((void *)v45 - 1) = *(v35 - 1);
              *(_OWORD *)(v45 - 24) = v47;
              v45 -= 24;
              v35 -= 3;
            }
            while (v35 != v40);
            double v35 = (void *)a1[2];
          }
          a1[2] = v45;
          a1[3] = v46;
          a1[4] = &v44[24 * v43];
          if (v35) {
            operator delete(v35);
          }
          a1[3] = v46;
        }
        else
        {
          *double v35 = v32;
          v35[1] = 0;
          v35[2] = v31;
          a1[3] = v35 + 3;
        }
        return v33;
      }
      BOOL v5 = (uint64_t *)v5[12];
    }
  }
  if (a3) {
    return a2[12];
  }
  else {
    return a2[13];
  }
}

uint64_t ClipperLib::ClipperBase::AddPath(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if ((a4 & 1) == 0)
  {
    exceptiouint64_t n = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
    ClipperLib::clipperException::clipperException(exception, "AddPath: Open paths have been disabled.");
  }
  BOOL v4 = *(int64x2_t **)a2;
  uint64_t v5 = (*(void *)(a2 + 8) - *(void *)a2) >> 4;
  unsigned int v6 = v5 - 1;
  if ((int)v5 >= 2)
  {
    uint64_t v7 = &v4[v6];
    while (1)
    {
      int32x2_t v8 = vmovn_s64(vceqq_s64(*v7, *v4));
      if ((v8.i32[0] & v8.i32[1] & 1) == 0) {
        break;
      }
      LODWORD(v5) = v5 - 1;
      --v7;
      if (v5 <= 1)
      {
        unsigned int v6 = 0;
        goto LABEL_8;
      }
    }
    unsigned int v6 = v5 - 1;
  }
LABEL_8:
  uint64_t v9 = 152 * v6 + 304;
  uint64_t v10 = &v4[v6];
  int v11 = v6;
  while (1)
  {
    unsigned int v12 = v11;
    BOOL v13 = __OFSUB__(v11--, 1);
    if (v11 < 0 != v13) {
      break;
    }
    --v6;
    int64x2_t v14 = *v10--;
    int32x2_t v15 = vmovn_s64(vceqq_s64(v14, v4[v11]));
    v9 -= 152;
    if ((v15.i32[0] & v15.i32[1] & 1) == 0)
    {
      if (v12 >= 2) {
        operator new[]();
      }
      return 0;
    }
  }
  return 0;
}

void sub_235EEF6A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_235EEF6B8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_235EEF6E0(_Unwind_Exception *a1)
{
}

ClipperLib::clipperException *ClipperLib::clipperException::clipperException(ClipperLib::clipperException *this, const char *__s)
{
  *(void *)this = &unk_26E943320;
  BOOL v4 = (char *)this + 8;
  size_t v5 = strlen(__s);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    BOOL v4 = (char *)operator new(v7 + 1);
    *((void *)this + 2) = v6;
    *((void *)this + 3) = v8 | 0x8000000000000000;
    *((void *)this + 1) = v4;
  }
  else
  {
    *((unsigned char *)this + 31) = v5;
    if (!v5) {
      goto LABEL_9;
    }
  }
  memmove(v4, __s, v6);
LABEL_9:
  v4[v6] = 0;
  return this;
}

void sub_235EEF7C8(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void ClipperLib::clipperException::~clipperException(std::exception *this)
{
  uint64_t v1 = this;
  this->__vftable = (std::exception_vtbl *)&unk_26E943320;
  if (SHIBYTE(this[3].__vftable) < 0)
  {
    operator delete(this[1].__vftable);
    this = v1;
  }
  else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
  {
    __break(0xC471u);
  }
  std::exception::~exception(this);
}

{
  uint64_t vars8;

  this->__vftable = (std::exception_vtbl *)&unk_26E943320;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);

  JUMPOUT(0x237DF7CA0);
}

uint64_t ClipperLib::ClipperBase::AddPaths(uint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v4 = *a2;
  if (a2[1] == *a2)
  {
    LOBYTE(v11) = 0;
  }
  else
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    int v11 = 0;
    do
    {
      v11 |= ClipperLib::ClipperBase::AddPath(a1, v4 + v9, a3, a4);
      ++v10;
      uint64_t v4 = *a2;
      v9 += 24;
    }
    while (v10 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
  return v11 & 1;
}

void *ClipperLib::ClipperBase::Clear(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[2];
  this[3] = v2;
  this[1] = v2;
  uint64_t v4 = this[6];
  uint64_t v3 = this[7];
  if (v3 == v4)
  {
    uint64_t v4 = this[7];
  }
  else
  {
    unint64_t v5 = 0;
    do
    {
      this = *(void **)(v4 + 8 * v5);
      if (this)
      {
        this = (void *)MEMORY[0x237DF7C80](this, 0x1020C80AAFD436DLL);
        uint64_t v4 = v1[6];
        uint64_t v3 = v1[7];
      }
      ++v5;
    }
    while (v5 < (v3 - v4) >> 3);
  }
  v1[7] = v4;
  *((unsigned char *)v1 + 40) = 0;
  *((unsigned char *)v1 + 73) = 0;
  return this;
}

void *ClipperLib::ClipperBase::DisposeLocalMinimaList(void *this)
{
  uint64_t v1 = this[2];
  this[3] = v1;
  this[1] = v1;
  return this;
}

void ClipperLib::ClipperBase::Reset(ClipperLib::ClipperBase *this, __n128 a2)
{
  unint64_t v3 = *((void *)this + 2);
  uint64_t v4 = (long long *)*((void *)this + 3);
  *((void *)this + 1) = v3;
  if ((long long *)v3 != v4)
  {
    std::__introsort<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *,false>(v3, v4, (uint64_t)&v8, 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v4 - v3) >> 3)), 1, a2);
    for (uint64_t i = *((void *)this + 2); i != *((void *)this + 3); i += 24)
    {
      uint64_t v6 = *(void *)(i + 8);
      if (v6)
      {
        *(_OWORD *)(v6 + 16) = *(_OWORD *)v6;
        *(_DWORD *)(v6 + 76) = 1;
        *(_DWORD *)(v6 + 92) = -1;
      }
      uint64_t v7 = *(void *)(i + 16);
      if (v7)
      {
        *(_OWORD *)(v7 + 16) = *(_OWORD *)v7;
        *(_DWORD *)(v7 + 76) = 2;
        *(_DWORD *)(v7 + 92) = -1;
      }
    }
  }
}

uint64_t ClipperLib::ClipperBase::PopLocalMinima(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  if (v1 != *(void *)(this + 24)) {
    *(void *)(this + 8) = v1 + 24;
  }
  return this;
}

double ClipperLib::ClipperBase::GetBounds@<D0>(ClipperLib::ClipperBase *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 2);
  uint64_t v3 = *((void *)this + 3);
  if (v2 != v3)
  {
    uint64_t v4 = *(uint64_t **)(v2 + 8);
    uint64_t v6 = *v4;
    uint64_t v5 = v4[1];
    *a2 = v6;
    a2[1] = v5;
    a2[2] = v6;
    uint64_t v7 = v6;
    uint64_t v8 = v5;
    while (1)
    {
      uint64_t v9 = *(uint64_t **)(v2 + 8);
      unint64_t v10 = *(uint64_t **)(v2 + 16);
      if (v5 <= v9[1]) {
        uint64_t v5 = v9[1];
      }
      a2[3] = v5;
      int v11 = v9;
      do
      {
        int32x2_t v15 = (uint64_t *)v11[14];
        if (v15)
        {
          unsigned int v12 = v11;
          while (1)
          {
            uint64_t v16 = *v12;
            unsigned int v12 = v15;
            if (v16 < v6)
            {
              *a2 = v16;
              uint64_t v6 = v16;
              if (v16 > v7)
              {
LABEL_27:
                a2[2] = v16;
                uint64_t v7 = v16;
              }
            }
            else if (v16 > v7)
            {
              goto LABEL_27;
            }
            int32x2_t v15 = (uint64_t *)v15[14];
            if (!v15) {
              goto LABEL_8;
            }
          }
        }
        unsigned int v12 = v11;
LABEL_8:
        if (*v12 < v6) {
          uint64_t v6 = *v12;
        }
        *a2 = v6;
        if (v7 <= *v12) {
          uint64_t v7 = *v12;
        }
        a2[2] = v7;
        if (v12[4] < v6) {
          uint64_t v6 = v12[4];
        }
        *a2 = v6;
        if (v7 <= v12[4]) {
          uint64_t v7 = v12[4];
        }
        a2[2] = v7;
        uint64_t v13 = v12[5];
        if (v13 < v8) {
          uint64_t v8 = v13;
        }
        a2[1] = v8;
        BOOL v14 = v11 == v9;
        int v11 = v10;
      }
      while (v14);
      v2 += 24;
      if (v2 == v3) {
        return result;
      }
    }
  }
  double result = 0.0;
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  return result;
}

ClipperLib *ClipperLib::Clipper::Clipper(ClipperLib *this, uint64_t *a2, char a3)
{
  uint64_t v3 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v3 - 24)) = a2[1];
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((unsigned char *)this + 160) = 0;
  uint64_t v4 = *(void *)this;
  *((unsigned char *)this + *(void *)(*(void *)this - 24) + 40) = 0;
  *((unsigned char *)this + 172) = a3 & 1;
  *((unsigned char *)this + 174) = (a3 & 2) != 0;
  *((unsigned char *)this + *(void *)(v4 - 24) + 72) = (a3 & 4) != 0;
  *((unsigned char *)this + *(void *)(v4 - 24) + 73) = 0;
  return this;
}

double ClipperLib::Clipper::Clipper(ClipperLib::Clipper *this, char a2)
{
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(void *)this = &unk_26E943250;
  *((void *)this + 22) = &unk_26E943298;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 14) = 0;
  *((unsigned char *)this + 216) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((unsigned char *)this + 160) = 0;
  *((unsigned char *)this + 172) = a2 & 1;
  *((unsigned char *)this + 174) = (a2 & 2) != 0;
  *((unsigned char *)this + 248) = (a2 & 4) != 0;
  *((unsigned char *)this + 249) = 0;
  return result;
}

void ClipperLib::Clipper::~Clipper(ClipperLib::Clipper *this, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v3 - 24)) = a2[1];
  (*(void (**)(char *))(*(void *)((char *)this + *(void *)(*(void *)this - 24)) + 16))((char *)this + *(void *)(*(void *)this - 24));
  uint64_t v4 = (void *)*((void *)this + 14);
  if (v4)
  {
    *((void *)this + 15) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 10);
  if (v5)
  {
    *((void *)this + 11) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 7);
  if (v6)
  {
    *((void *)this + 8) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 4);
  if (v7)
  {
    *((void *)this + 5) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 1);
  if (v8)
  {
    *((void *)this + 2) = v8;
    operator delete(v8);
  }
}

void ClipperLib::Clipper::~Clipper(ClipperLib::Clipper *this)
{
  uint64_t v3 = v2[24];
  v2[25] = v3;
  v2[22] = &unk_26E943200;
  v2[23] = v3;
  uint64_t v6 = v2 + 28;
  uint64_t v4 = (void *)v2[28];
  uint64_t v5 = (void *)v6[1];
  if (v5 == v4)
  {
    uint64_t v4 = v5;
  }
  else
  {
    unint64_t v7 = 0;
    do
    {
      if (v4[v7])
      {
        MEMORY[0x237DF7C80](v4[v7], 0x1020C80AAFD436DLL);
        uint64_t v4 = (void *)*((void *)this + 28);
        uint64_t v5 = (void *)*((void *)this + 29);
      }
      ++v7;
    }
    while (v7 < v5 - v4);
  }
  *((void *)this + 29) = v4;
  *((unsigned char *)this + 216) = 0;
  *((unsigned char *)this + 249) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v8 = (void *)*((void *)this + 24);
  if (v8)
  {
    *((void *)this + 25) = v8;
    operator delete(v8);
  }
}

{
  uint64_t vars8;

  ClipperLib::Clipper::~Clipper(this);

  JUMPOUT(0x237DF7CA0);
}

void virtual thunk to'ClipperLib::Clipper::~Clipper(ClipperLib::Clipper *this)
{
}

{
  uint64_t vars8;

  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)((char *)this + *(void *)(*(void *)this - 24)));

  JUMPOUT(0x237DF7CA0);
}

void ClipperLib::Clipper::Reset(ClipperLib::Clipper *this, __n128 a2)
{
  uint64_t v3 = (void *)((char *)this + *(void *)(*(void *)this - 24));
  unint64_t v4 = v3[2];
  uint64_t v5 = (long long *)v3[3];
  v3[1] = v4;
  if ((long long *)v4 != v5)
  {
    std::__introsort<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *,false>(v4, v5, (uint64_t)&v13, 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v5 - v4) >> 3)), 1, a2);
    for (uint64_t i = v3[2]; i != v3[3]; i += 24)
    {
      uint64_t v7 = *(void *)(i + 8);
      if (v7)
      {
        *(_OWORD *)(v7 + 16) = *(_OWORD *)v7;
        *(_DWORD *)(v7 + 76) = 1;
        *(_DWORD *)(v7 + 92) = -1;
      }
      uint64_t v8 = *(void *)(i + 16);
      if (v8)
      {
        *(_OWORD *)(v8 + 16) = *(_OWORD *)v8;
        *(_DWORD *)(v8 + 76) = 2;
        *(_DWORD *)(v8 + 92) = -1;
      }
    }
  }
  uint64_t v9 = (void *)*((void *)this + 14);
  if (v9)
  {
    *((void *)this + 15) = v9;
    operator delete(v9);
  }
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  uint64_t v10 = *(void *)(*(void *)this - 24);
  int v11 = *(uint64_t **)((char *)this + v10 + 16);
  if (v11 != *(uint64_t **)((char *)this + v10 + 24))
  {
    do
    {
      uint64_t v12 = *v11;
      v11 += 3;
      uint64_t v14 = v12;
      std::priority_queue<long long>::push((uint64_t)this + 112, &v14);
    }
    while (v11 != *(uint64_t **)((char *)this + *(void *)(*(void *)this - 24) + 24));
  }
}

void ClipperLib::Clipper::InsertScanbeam(ClipperLib::Clipper *this, uint64_t a2)
{
  uint64_t v2 = a2;
  std::priority_queue<long long>::push((uint64_t)this + 112, &v2);
}

void virtual thunk to'ClipperLib::Clipper::Reset(ClipperLib::Clipper *this, __n128 a2)
{
}

uint64_t ClipperLib::Clipper::Execute(uint64_t a1, int a2, uint64_t *a3, int a4, int a5)
{
  if (*(unsigned char *)(a1 + 160)) {
    return 0;
  }
  uint64_t v7 = *(void *)a1;
  if (*(unsigned char *)(a1 + *(void *)(*(void *)a1 - 24) + 73))
  {
    exceptiouint64_t n = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
    ClipperLib::clipperException::clipperException(exception, "Error: PolyTree struct is need for open path clipping.");
  }
  *(unsigned char *)(a1 + 160) = 1;
  uint64_t v13 = *a3;
  uint64_t v12 = a3[1];
  if (v12 != *a3)
  {
    uint64_t v14 = a3[1];
    do
    {
      uint64_t v16 = *(void **)(v14 - 24);
      v14 -= 24;
      int32x2_t v15 = v16;
      if (v16)
      {
        *(void *)(v12 - 16) = v15;
        operator delete(v15);
      }
      uint64_t v12 = v14;
    }
    while (v14 != v13);
    a3[1] = v13;
    uint64_t v7 = *(void *)a1;
  }
  *(_DWORD *)(a1 + 164) = a5;
  *(_DWORD *)(a1 + 168) = a4;
  *(_DWORD *)(a1 + 104) = a2;
  *(unsigned char *)(a1 + 173) = 0;
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(v7 + 24))(a1);
  if (v5) {
    ClipperLib::Clipper::BuildResult(a1, (uint64_t)a3);
  }
  uint64_t v17 = *(void *)(a1 + 16);
  if (v17 != *(void *)(a1 + 8))
  {
    unint64_t v18 = 0;
    uint64_t v17 = *(void *)(a1 + 8);
    do
    {
      uint64_t v19 = *(void *)(v17 + 8 * v18);
      uint64_t v20 = *(void *)(v19 + 24);
      if (v20)
      {
        *(void *)(*(void *)(v20 + 32) + 24) = 0;
        for (uint64_t i = *(void *)(v19 + 24); i; uint64_t i = *(void *)(v19 + 24))
        {
          *(void *)(v19 + 24) = *(void *)(i + 24);
          MEMORY[0x237DF7CA0]();
        }
      }
      MEMORY[0x237DF7CA0](v19, 0x1020C401FC46325);
      *(void *)(*(void *)(a1 + 8) + 8 * v18++) = 0;
      uint64_t v17 = *(void *)(a1 + 8);
    }
    while (v18 < (*(void *)(a1 + 16) - v17) >> 3);
  }
  *(void *)(a1 + 16) = v17;
  *(unsigned char *)(a1 + 160) = 0;
  return v5;
}

void sub_235EF0380(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void ClipperLib::Clipper::BuildResult(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  std::vector<std::vector<ClipperLib::IntPoint>>::reserve(a2, (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 16);
  if (v5 == v4) {
    return;
  }
  uint64_t v6 = 0;
  uint64_t v29 = v3;
  uint64_t v30 = a2;
  while (2)
  {
    if (!*(void *)(*(void *)(v4 + 8 * v6) + 24)) {
      goto LABEL_4;
    }
    __p = 0;
    uint64_t v32 = 0;
    unint64_t v33 = 0;
    uint64_t v7 = *(void *)(*(void *)(v4 + 8 * v6) + 24);
    uint64_t v8 = *(void *)(v7 + 32);
    if (!v8) {
      goto LABEL_3;
    }
    unsigned int v9 = 0;
    uint64_t v10 = *(void *)(v7 + 32);
    do
    {
      unsigned int v11 = v9++;
      uint64_t v10 = *(void *)(v10 + 24);
    }
    while (v10 != v8);
    if (!v11) {
      goto LABEL_3;
    }
    uint64_t v12 = operator new(16 * v9);
    int v13 = 0;
    __p = v12;
    uint64_t v32 = v12;
    unint64_t v33 = (unint64_t)&v12[v11 + 1];
    do
    {
      int32x2_t v15 = (_OWORD *)(v8 + 8);
      if ((unint64_t)v12 < v33)
      {
        *uint64_t v12 = *v15;
        uint64_t v14 = v12 + 1;
        goto LABEL_12;
      }
      uint64_t v16 = __p;
      uint64_t v17 = ((char *)v12 - (unsigned char *)__p) >> 4;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 60) {
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
      uint64_t v19 = v33 - (void)__p;
      if ((uint64_t)(v33 - (void)__p) >> 3 > v18) {
        unint64_t v18 = v19 >> 3;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        if (v20 >> 60) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v21 = (char *)operator new(16 * v20);
      }
      else
      {
        uint64_t v21 = 0;
      }
      uint64_t v22 = &v21[16 * v17];
      *(_OWORD *)uint64_t v22 = *v15;
      uint64_t v14 = v22 + 16;
      if (v12 == v16)
      {
        __p = &v21[16 * v17];
        uint64_t v32 = v22 + 16;
        unint64_t v33 = (unint64_t)&v21[16 * v20];
LABEL_29:
        operator delete(v12);
        goto LABEL_12;
      }
      do
      {
        *((_OWORD *)v22 - 1) = *(v12 - 1);
        v22 -= 16;
        --v12;
      }
      while (v12 != v16);
      uint64_t v12 = __p;
      __p = v22;
      uint64_t v32 = v14;
      unint64_t v33 = (unint64_t)&v21[16 * v20];
      if (v12) {
        goto LABEL_29;
      }
LABEL_12:
      uint64_t v32 = v14;
      uint64_t v8 = *(void *)(v8 + 32);
      ++v13;
      uint64_t v12 = v14;
    }
    while (v13 != v9);
    uint64_t v23 = *(void **)(v30 + 8);
    if ((unint64_t)v23 >= *(void *)(v30 + 16))
    {
      uint64_t v28 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>((char **)v30, (uint64_t)&__p);
    }
    else
    {
      void *v23 = 0;
      v23[1] = 0;
      v23[2] = 0;
      uint64_t v24 = __p;
      int64_t v25 = v32 - (unsigned char *)__p;
      if (v32 != __p)
      {
        if (v25 < 0) {
          _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
        }
        uint64_t v26 = (char *)operator new(v32 - (unsigned char *)__p);
        void *v23 = v26;
        v23[1] = v26;
        double v27 = &v26[16 * (v25 >> 4)];
        v23[2] = v27;
        memcpy(v26, v24, v25);
        v23[1] = v27;
      }
      uint64_t v28 = (char *)(v23 + 3);
      *(void *)(v30 + 8) = v23 + 3;
    }
    *(void *)(v30 + 8) = v28;
    uint64_t v3 = v29;
    if (__p)
    {
      uint64_t v32 = __p;
      operator delete(__p);
    }
LABEL_3:
    uint64_t v4 = *(void *)(v3 + 8);
    uint64_t v5 = *(void *)(v3 + 16);
LABEL_4:
    if (++v6 < (unint64_t)((v5 - v4) >> 3)) {
      continue;
    }
    break;
  }
}

void sub_235EF0614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  int32x2_t v15 = *(void **)v13;
  if (*(void *)v13)
  {
    *(void *)(v13 + 8) = v15;
    operator delete(v15);
  }
  *(void *)(a11 + 8) = v13;
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ClipperLib::Clipper::DisposeAllOutRecs(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 16);
  if (v2 != *(void *)(this + 8))
  {
    unint64_t v3 = 0;
    uint64_t v2 = *(void *)(this + 8);
    do
    {
      uint64_t v4 = *(void *)(v2 + 8 * v3);
      uint64_t v5 = *(void *)(v4 + 24);
      if (v5)
      {
        *(void *)(*(void *)(v5 + 32) + 24) = 0;
        for (uint64_t i = *(void *)(v4 + 24); i; uint64_t i = *(void *)(v4 + 24))
        {
          *(void *)(v4 + 24) = *(void *)(i + 24);
          MEMORY[0x237DF7CA0]();
        }
      }
      this = MEMORY[0x237DF7CA0](v4, 0x1020C401FC46325);
      *(void *)(*(void *)(v1 + 8) + 8 * v3++) = 0;
      uint64_t v2 = *(void *)(v1 + 8);
    }
    while (v3 < (*(void *)(v1 + 16) - v2) >> 3);
  }
  *(void *)(v1 + 16) = v2;
  return this;
}

uint64_t ClipperLib::Clipper::Execute(uint64_t a1, int a2, ClipperLib::PolyTree *a3, int a4, int a5)
{
  if (*(unsigned char *)(a1 + 160)) {
    return 0;
  }
  *(unsigned char *)(a1 + 160) = 1;
  *(_DWORD *)(a1 + 164) = a5;
  *(_DWORD *)(a1 + 168) = a4;
  *(_DWORD *)(a1 + 104) = a2;
  *(unsigned char *)(a1 + 173) = 1;
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v8) {
    ClipperLib::Clipper::BuildResult2((ClipperLib::Clipper *)a1, a3);
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 != *(void *)(a1 + 8))
  {
    unint64_t v10 = 0;
    uint64_t v9 = *(void *)(a1 + 8);
    do
    {
      uint64_t v11 = *(void *)(v9 + 8 * v10);
      uint64_t v12 = *(void *)(v11 + 24);
      if (v12)
      {
        *(void *)(*(void *)(v12 + 32) + 24) = 0;
        for (uint64_t i = *(void *)(v11 + 24); i; uint64_t i = *(void *)(v11 + 24))
        {
          *(void *)(v11 + 24) = *(void *)(i + 24);
          MEMORY[0x237DF7CA0]();
        }
      }
      MEMORY[0x237DF7CA0](v11, 0x1020C401FC46325);
      *(void *)(*(void *)(a1 + 8) + 8 * v10++) = 0;
      uint64_t v9 = *(void *)(a1 + 8);
    }
    while (v10 < (*(void *)(a1 + 16) - v9) >> 3);
  }
  *(void *)(a1 + 16) = v9;
  *(unsigned char *)(a1 + 160) = 0;
  return v8;
}

void ClipperLib::Clipper::BuildResult2(ClipperLib::Clipper *this, ClipperLib::PolyTree *a2)
{
  uint64_t v4 = (void *)*((void *)a2 + 10);
  uint64_t v5 = (unsigned char *)*((void *)a2 + 11);
  if (v5 == (unsigned char *)v4)
  {
    uint64_t v4 = (void *)*((void *)a2 + 11);
    uint64_t v8 = *((void *)a2 + 4);
    if (*((void *)a2 + 5) != v8) {
LABEL_9:
    }
      *((void *)a2 + 5) = v8;
  }
  else
  {
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = v4[v6];
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        uint64_t v4 = (void *)*((void *)a2 + 10);
        uint64_t v5 = (unsigned char *)*((void *)a2 + 11);
      }
      ++v6;
    }
    while (v6 < (v5 - (unsigned char *)v4) >> 3);
    if (v5 != (unsigned char *)v4) {
      *((void *)a2 + 11) = v4;
    }
    uint64_t v8 = *((void *)a2 + 4);
    if (*((void *)a2 + 5) != v8) {
      goto LABEL_9;
    }
  }
  int64_t v9 = *((void *)this + 2) - *((void *)this + 1);
  uint64_t v10 = v9 >> 3;
  if (v9 >> 3 > (unint64_t)((uint64_t)(*((void *)a2 + 12) - (void)v4) >> 3))
  {
    if (v9 < 0) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v11 = (char *)operator new(v9);
    *((void *)a2 + 10) = v11;
    *((void *)a2 + 11) = v11;
    *((void *)a2 + 12) = &v11[8 * v10];
    if (v4) {
      operator delete(v4);
    }
  }
  uint64_t v12 = *((void *)this + 1);
  if (*((void *)this + 2) != v12)
  {
    unint64_t v44 = this;
    uint64_t v13 = 0;
    do
    {
      uint64_t v45 = v13;
      uint64_t v16 = *(void *)(v12 + 8 * v13);
      uint64_t v17 = *(void *)(v16 + 24);
      if (v17)
      {
        unsigned int v18 = -1;
        uint64_t v19 = *(void *)(v16 + 24);
        do
        {
          uint64_t v19 = *(void *)(v19 + 24);
          ++v18;
        }
        while (v19 != v17);
        unsigned int v20 = *(unsigned char *)(v16 + 5) ? 1 : 2;
        if (v18 >= v20)
        {
          uint64_t v21 = *(void *)(v16 + 8);
          if (v21)
          {
            int v22 = *(unsigned __int8 *)(v16 + 4);
            if (v22 == *(unsigned __int8 *)(v21 + 4) || !*(void *)(v21 + 24))
            {
              do
              {
                if (*(unsigned __int8 *)(v21 + 4) != v22 && *(void *)(v21 + 24)) {
                  break;
                }
                uint64_t v21 = *(void *)(v21 + 8);
              }
              while (v21);
              *(void *)(v16 + 8) = v21;
            }
          }
          operator new();
        }
      }
      this = v44;
      ++v13;
      uint64_t v12 = *((void *)v44 + 1);
      int64_t v14 = *((void *)v44 + 2) - v12;
      unint64_t v15 = v14 >> 3;
    }
    while (v45 + 1 < (unint64_t)(v14 >> 3));
    uint64_t v23 = (unsigned char *)*((void *)a2 + 4);
    if (v15 > (uint64_t)(*((void *)a2 + 6) - (void)v23) >> 3)
    {
      if (v14 < 0) {
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
      uint64_t v24 = (unsigned char *)*((void *)a2 + 5);
      uint64_t v25 = v24 - v23;
      uint64_t v26 = (char *)operator new(v14);
      double v27 = &v26[(v24 - v23) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v28 = v27;
      if (v24 == v23) {
        goto LABEL_47;
      }
      unint64_t v29 = v24 - v23 - 8;
      if (v29 >= 0x58)
      {
        uint64_t v28 = &v26[v25 & 0xFFFFFFFFFFFFFFF8];
        if ((unint64_t)(v24 - v28) >= 0x20)
        {
          uint64_t v30 = (v29 >> 3) + 1;
          uint64_t v31 = 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v32 = &v24[-v31];
          uint64_t v28 = &v27[-v31];
          unint64_t v33 = &v26[8 * (v25 >> 3) - 16];
          unint64_t v34 = (long long *)(v24 - 16);
          uint64_t v35 = v30 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v36 = *v34;
            *((_OWORD *)v33 - 1) = *(v34 - 1);
            *(_OWORD *)unint64_t v33 = v36;
            v33 -= 32;
            v34 -= 2;
            v35 -= 4;
          }
          while (v35);
          uint64_t v24 = v32;
          if (v30 == (v30 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_47:
            *((void *)a2 + 4) = v28;
            *((void *)a2 + 5) = v27;
            *((void *)a2 + 6) = &v26[8 * v15];
            if (v23) {
              operator delete(v23);
            }
            goto LABEL_49;
          }
        }
      }
      else
      {
        uint64_t v28 = &v26[v25 & 0xFFFFFFFFFFFFFFF8];
      }
      do
      {
        uint64_t v37 = *((void *)v24 - 1);
        v24 -= 8;
        *((void *)v28 - 1) = v37;
        v28 -= 8;
      }
      while (v24 != v23);
      goto LABEL_47;
    }
  }
LABEL_49:
  uint64_t v38 = *((void *)this + 1);
  if (*((void *)this + 2) != v38)
  {
    for (unint64_t i = 0; i < (*((void *)this + 2) - v38) >> 3; ++i)
    {
      uint64_t v41 = *(void *)(v38 + 8 * i);
      unint64_t v42 = *(ClipperLib::PolyNode **)(v41 + 16);
      if (!v42) {
        goto LABEL_54;
      }
      if (*(unsigned char *)(v41 + 5))
      {
        *((unsigned char *)v42 + 68) = 1;
      }
      else
      {
        uint64_t v43 = *(void *)(v41 + 8);
        if (v43)
        {
          float v40 = *(ClipperLib::PolyNode **)(v43 + 16);
          if (v40) {
            goto LABEL_53;
          }
        }
      }
      float v40 = a2;
LABEL_53:
      ClipperLib::PolyNode::AddChild(v40, v42);
LABEL_54:
      uint64_t v38 = *((void *)this + 1);
    }
  }
}

void ClipperLib::Clipper::FixHoleLinkage(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    int v3 = *(unsigned __int8 *)(a2 + 4);
    if (v3 == *(unsigned __int8 *)(v2 + 4) || !*(void *)(v2 + 24))
    {
      do
      {
        if (*(unsigned __int8 *)(v2 + 4) != v3 && *(void *)(v2 + 24)) {
          break;
        }
        uint64_t v2 = *(void *)(v2 + 8);
      }
      while (v2);
      *(void *)(a2 + 8) = v2;
    }
  }
}

uint64_t ClipperLib::Clipper::ExecuteInternal(ClipperLib::Clipper *this)
{
  (*(void (**)(ClipperLib::Clipper *))(*(void *)this + 16))(this);
  if (*(void *)((char *)this + *(void *)(*(void *)this - 24) + 8) == *(void *)((char *)this
                                                                                        + *(void *)(*(void *)this - 24)
                                                                                        + 24))
    return 1;
  uint64_t v2 = ClipperLib::Clipper::PopScanbeam(this);
  int v3 = (void **)((char *)this + 152);
  do
  {
    ClipperLib::Clipper::InsertLocalMinimaIntoAEL(this, v2);
    uint64_t v4 = *((void *)this + 7);
    uint64_t v5 = *((void *)this + 8);
    if (v5 != v4)
    {
      unint64_t v6 = 0;
      do
      {
        uint64_t v7 = *(void *)(v4 + 8 * v6);
        if (v7)
        {
          MEMORY[0x237DF7CA0](v7, 0x1020C406C4767B9);
          uint64_t v4 = *((void *)this + 7);
          uint64_t v5 = *((void *)this + 8);
        }
        ++v6;
      }
      while (v6 < (v5 - v4) >> 3);
      if (v5 != v4) {
        *((void *)this + 8) = v4;
      }
    }
    while (1)
    {
      uint64_t v8 = *v3;
      if (!*v3) {
        break;
      }
      uint64_t v9 = v8[17];
      uint64_t v10 = v8[18];
      if (*(_OWORD *)(v8 + 17) == 0)
      {
        void *v3 = 0;
      }
      else
      {
        uint64_t v11 = (void *)(v10 + 136);
        if (!v10) {
          uint64_t v11 = (void *)((char *)this + 152);
        }
        void *v11 = v9;
        if (v9) {
          *(void *)(v9 + 144) = v10;
        }
      }
      v8[17] = 0;
      v8[18] = 0;
      ClipperLib::Clipper::ProcessHorizontal(this, v8, 0);
    }
    if (*((void *)this + 14) == *((void *)this + 15)) {
      break;
    }
    uint64_t v2 = ClipperLib::Clipper::PopScanbeam(this);
    if (!ClipperLib::Clipper::ProcessIntersections(this, v2))
    {
      uint64_t v23 = 0;
      uint64_t v27 = *((void *)this + 4);
      uint64_t v28 = *((void *)this + 5);
      if (v28 == v27) {
        goto LABEL_56;
      }
      goto LABEL_50;
    }
    ClipperLib::Clipper::ProcessEdgesAtTopOfScanbeam(this, v2);
  }
  while (*((void *)this + 14) != *((void *)this + 15)
       || *(void *)((char *)this + *(void *)(*(void *)this - 24) + 8) != *(void *)((char *)this
                                                                                           + *(void *)(*(void *)this - 24)
                                                                                           + 24));
  uint64_t v13 = *((void *)this + 1);
  uint64_t v12 = *((void *)this + 2);
  if (v12 != v13)
  {
    uint64_t v14 = 0;
    unint64_t v15 = (v12 - v13) >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      uint64_t v16 = *(void *)(v13 + 8 * v14);
      uint64_t v17 = *(void **)(v16 + 24);
      if (v17)
      {
        if (!*(unsigned char *)(v16 + 5))
        {
          int v18 = *(unsigned __int8 *)(v16 + 4);
          double v19 = 0.0;
          unsigned int v20 = v17;
          do
          {
            double v19 = v19
                + (double)(uint64_t)(*(void *)(v20[4] + 16) - v20[2])
                * (double)(uint64_t)(v20[1] + *(void *)(v20[4] + 8));
            unsigned int v20 = (void *)v20[3];
          }
          while (v20 != v17);
          if ((*((unsigned __int8 *)this + 172) ^ v18) == v19 * 0.5 > 0.0)
          {
            uint64_t v21 = (uint64_t)v17;
            do
            {
              int8x16_t v22 = *(int8x16_t *)(v21 + 24);
              *(int8x16_t *)(v21 + 24) = vextq_s8(v22, v22, 8uLL);
              uint64_t v21 = v22.i64[0];
            }
            while ((void *)v22.i64[0] != v17);
          }
        }
      }
      ++v14;
    }
    while (v14 != v15);
  }
  if (*((void *)this + 4) != *((void *)this + 5))
  {
    ClipperLib::Clipper::JoinCommonEdges((uint64_t)this);
    uint64_t v13 = *((void *)this + 1);
    uint64_t v12 = *((void *)this + 2);
  }
  if (v12 != v13)
  {
    unint64_t v25 = 0;
    do
    {
      uint64_t v26 = *(void *)(v13 + 8 * v25);
      if (*(void *)(v26 + 24) && !*(unsigned char *)(v26 + 5))
      {
        ClipperLib::Clipper::FixupOutPolygon(this, v26);
        uint64_t v13 = *((void *)this + 1);
        uint64_t v12 = *((void *)this + 2);
      }
      ++v25;
    }
    while (v25 < (v12 - v13) >> 3);
  }
  if (*((unsigned char *)this + 174)) {
    ClipperLib::Clipper::DoSimplePolygons((uint64_t)this);
  }
  uint64_t v23 = 1;
  uint64_t v27 = *((void *)this + 4);
  uint64_t v28 = *((void *)this + 5);
  if (v28 != v27)
  {
LABEL_50:
    unint64_t v29 = 0;
    do
    {
      uint64_t v30 = *(void *)(v27 + 8 * v29);
      if (v30)
      {
        MEMORY[0x237DF7CA0](v30, 0x1020C406C4767B9);
        uint64_t v27 = *((void *)this + 4);
        uint64_t v28 = *((void *)this + 5);
      }
      ++v29;
    }
    while (v29 < (v28 - v27) >> 3);
    if (v28 != v27) {
      *((void *)this + 5) = v27;
    }
  }
LABEL_56:
  uint64_t v31 = *((void *)this + 7);
  uint64_t v32 = *((void *)this + 8);
  if (v32 == v31) {
    return v23;
  }
  unint64_t v33 = 0;
  do
  {
    uint64_t v34 = *(void *)(v31 + 8 * v33);
    if (v34)
    {
      MEMORY[0x237DF7CA0](v34, 0x1020C406C4767B9);
      uint64_t v31 = *((void *)this + 7);
      uint64_t v32 = *((void *)this + 8);
    }
    ++v33;
  }
  while (v33 < (v32 - v31) >> 3);
  if (v32 == v31) {
    return v23;
  }
  *((void *)this + 8) = v31;
  return v23;
}

uint64_t ClipperLib::Clipper::PopScanbeam(ClipperLib::Clipper *this)
{
  uint64_t v1 = (char *)*((void *)this + 14);
  uint64_t v2 = (char *)*((void *)this + 15);
  uint64_t v3 = *(void *)v1;
  uint64_t v4 = v2 - v1;
  if (v2 - v1 < 9) {
    goto LABEL_20;
  }
  uint64_t v5 = 0;
  uint64_t v6 = v4 >> 3;
  int64_t v7 = (unint64_t)((v4 >> 3) - 2) >> 1;
  uint64_t v8 = (char *)*((void *)this + 14);
  do
  {
    while (1)
    {
      uint64_t v11 = &v8[8 * v5 + 8];
      uint64_t v12 = (2 * v5) | 1;
      uint64_t v5 = 2 * v5 + 2;
      if (v5 < v6) {
        break;
      }
      uint64_t v5 = v12;
      *(void *)uint64_t v8 = *(void *)v11;
      uint64_t v8 = v11;
      if (v12 > v7) {
        goto LABEL_11;
      }
    }
    uint64_t v9 = *(void *)v11;
    uint64_t v10 = *((void *)v11 + 1);
    if (*(void *)v11 <= v10) {
      uint64_t v9 = *((void *)v11 + 1);
    }
    if (*(void *)v11 >= v10) {
      uint64_t v5 = v12;
    }
    else {
      v11 += 8;
    }
    *(void *)uint64_t v8 = v9;
    uint64_t v8 = v11;
  }
  while (v5 <= v7);
LABEL_11:
  uint64_t v13 = v2 - 8;
  if (v11 == v2 - 8)
  {
    *(void *)uint64_t v11 = v3;
    goto LABEL_20;
  }
  *(void *)uint64_t v11 = *(void *)v13;
  *(void *)uint64_t v13 = v3;
  uint64_t v14 = v11 - v1 + 8;
  if (v14 >= 9)
  {
    unint64_t v15 = (((unint64_t)v14 >> 3) - 2) >> 1;
    uint64_t v16 = &v1[8 * v15];
    uint64_t v17 = *(void *)v16;
    uint64_t v18 = *(void *)v11;
    if (*(void *)v16 < *(void *)v11)
    {
      do
      {
        *(void *)uint64_t v11 = v17;
        uint64_t v11 = v16;
        if (!v15) {
          break;
        }
        unint64_t v15 = (v15 - 1) >> 1;
        uint64_t v16 = &v1[8 * v15];
        uint64_t v17 = *(void *)v16;
      }
      while (*(void *)v16 < v18);
      goto LABEL_18;
    }
  }
  while (1)
  {
LABEL_20:
    if (v1 == v2 - 8) {
      goto LABEL_39;
    }
    double v19 = v2;
    v2 -= 8;
    if (v3 != *(void *)v1) {
      break;
    }
    uint64_t v20 = v2 - v1;
    if (v2 - v1 >= 9)
    {
      uint64_t v21 = 0;
      uint64_t v22 = v20 >> 3;
      int64_t v23 = (unint64_t)((v20 >> 3) - 2) >> 1;
      uint64_t v24 = v1;
      do
      {
        while (1)
        {
          uint64_t v11 = &v24[8 * v21 + 8];
          uint64_t v27 = (2 * v21) | 1;
          uint64_t v21 = 2 * v21 + 2;
          if (v21 < v22) {
            break;
          }
          uint64_t v21 = v27;
          *(void *)uint64_t v24 = *(void *)v11;
          uint64_t v24 = v11;
          if (v27 > v23) {
            goto LABEL_32;
          }
        }
        uint64_t v25 = *(void *)v11;
        uint64_t v26 = *((void *)v11 + 1);
        if (*(void *)v11 <= v26) {
          uint64_t v25 = *((void *)v11 + 1);
        }
        if (*(void *)v11 >= v26) {
          uint64_t v21 = v27;
        }
        else {
          v11 += 8;
        }
        *(void *)uint64_t v24 = v25;
        uint64_t v24 = v11;
      }
      while (v21 <= v23);
LABEL_32:
      uint64_t v28 = v19 - 16;
      if (v11 == v28)
      {
        *(void *)uint64_t v11 = v3;
      }
      else
      {
        *(void *)uint64_t v11 = *(void *)v28;
        *(void *)uint64_t v28 = v3;
        uint64_t v29 = v11 - v1 + 8;
        if (v29 >= 9)
        {
          unint64_t v30 = (((unint64_t)v29 >> 3) - 2) >> 1;
          uint64_t v31 = &v1[8 * v30];
          uint64_t v32 = *(void *)v31;
          uint64_t v18 = *(void *)v11;
          if (*(void *)v31 < *(void *)v11)
          {
            do
            {
              *(void *)uint64_t v11 = v32;
              uint64_t v11 = v31;
              if (!v30) {
                break;
              }
              unint64_t v30 = (v30 - 1) >> 1;
              uint64_t v31 = &v1[8 * v30];
              uint64_t v32 = *(void *)v31;
            }
            while (*(void *)v31 < v18);
LABEL_18:
            *(void *)uint64_t v11 = v18;
            continue;
          }
        }
      }
    }
  }
  uint64_t v1 = v2;
LABEL_39:
  *((void *)this + 15) = v1;
  return v3;
}

void ClipperLib::Clipper::InsertLocalMinimaIntoAEL(ClipperLib::Clipper *this, uint64_t a2)
{
  uint64_t v2 = (char *)this + 40;
  uint64_t v3 = (char *)this + *(void *)(*(void *)this - 24);
  uint64_t v6 = (void *)*((void *)v3 + 1);
  uint64_t v4 = v3 + 8;
  uint64_t v5 = v6;
  int64_t v7 = (void *)v4[2];
  if (v6 != v7)
  {
    uint64_t v10 = (char *)this + 112;
    do
    {
      if (*v5 != a2) {
        return;
      }
      uint64_t v13 = v5[1];
      uint64_t v14 = v5[2];
      if (v5 != v7) {
        void *v4 = v5 + 3;
      }
      if (v13)
      {
        ClipperLib::Clipper::InsertEdgeIntoAEL((uint64_t)this, v13, 0);
        if (!v14)
        {
          ClipperLib::Clipper::SetWindingCount((uint64_t)this, v13);
          if (ClipperLib::Clipper::IsContributing((uint64_t)this, (_DWORD *)v13)) {
            ClipperLib::Clipper::AddOutPt(this, v13, (void *)v13);
          }
          uint64_t v32 = *(void *)(v13 + 40);
          std::priority_queue<long long>::push((uint64_t)v10, &v32);
          goto LABEL_4;
        }
        ClipperLib::Clipper::InsertEdgeIntoAEL((uint64_t)this, v14, v13);
        ClipperLib::Clipper::SetWindingCount((uint64_t)this, v13);
        *(void *)(v14 + 84) = *(void *)(v13 + 84);
        if (ClipperLib::Clipper::IsContributing((uint64_t)this, (_DWORD *)v13)) {
          uint64_t v15 = ClipperLib::Clipper::AddLocalMinPoly(this, v13, v14, (void *)v13);
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v32 = *(void *)(v13 + 40);
        std::priority_queue<long long>::push((uint64_t)v10, &v32);
        if (!*(void *)(v14 + 56))
        {
LABEL_22:
          uint64_t v16 = *((void *)this + 19);
          *(void *)(v14 + 144) = 0;
          if (v16) {
            *(void *)(v16 + 144) = v14;
          }
          *((void *)this + 19) = v14;
          *(void *)(v14 + 136) = v16;
          if (!v13) {
            goto LABEL_4;
          }
LABEL_25:
          if (v15)
          {
            if (!*(void *)(v14 + 56))
            {
              uint64_t v22 = *((void *)this + 7);
              uint64_t v21 = *((void *)this + 8);
              if (v21 != v22)
              {
                if (*(_DWORD *)(v14 + 80))
                {
                  unint64_t v23 = 0;
                  do
                  {
                    uint64_t v24 = *(void **)(v22 + 8 * v23);
                    uint64_t v25 = *(void *)(*v24 + 8);
                    uint64_t v26 = v24[2];
                    uint64_t v27 = *(void *)v14;
                    uint64_t v28 = *(void *)(v14 + 32);
                    if (v25 >= v26) {
                      uint64_t v29 = v24[2];
                    }
                    else {
                      uint64_t v29 = *(void *)(*v24 + 8);
                    }
                    if (v25 <= v26) {
                      uint64_t v25 = v24[2];
                    }
                    if (v27 >= v28) {
                      uint64_t v30 = *(void *)(v14 + 32);
                    }
                    else {
                      uint64_t v30 = *(void *)v14;
                    }
                    if (v27 <= v28) {
                      uint64_t v27 = *(void *)(v14 + 32);
                    }
                    if (v29 < v27 && v30 < v25) {
                      ClipperLib::Clipper::AddJoin();
                    }
                    ++v23;
                  }
                  while (v23 < (v21 - v22) >> 3);
                }
              }
            }
          }
          if ((*(_DWORD *)(v13 + 92) & 0x80000000) == 0)
          {
            uint64_t v17 = *(void *)(v13 + 128);
            if (v17)
            {
              if (*(void *)(v17 + 16) == *(void *)v13
                && (*(_DWORD *)(v17 + 92) & 0x80000000) == 0
                && ClipperLib::SlopesEqual(*(void *)(v13 + 128), v13, v2[*(void *)(*(void *)this - 24)])&& *(_DWORD *)(v13 + 80)&& *(_DWORD *)(v17 + 80))
              {
                ClipperLib::Clipper::AddOutPt(this, v17, (void *)v13);
                ClipperLib::Clipper::AddJoin();
              }
            }
          }
          uint64_t v18 = *(void *)(v13 + 120);
          if (v18 != v14)
          {
            if ((*(_DWORD *)(v14 + 92) & 0x80000000) == 0)
            {
              uint64_t v19 = *(void *)(v14 + 128);
              if ((*(_DWORD *)(v19 + 92) & 0x80000000) == 0
                && ClipperLib::SlopesEqual(*(void *)(v14 + 128), v14, v2[*(void *)(*(void *)this - 24)])&& *(_DWORD *)(v14 + 80)&& *(_DWORD *)(v19 + 80))
              {
                ClipperLib::Clipper::AddOutPt(this, v19, (void *)v14);
                ClipperLib::Clipper::AddJoin();
              }
            }
            if (v18 && v18 != v14)
            {
              uint64_t v20 = (void *)(v13 + 16);
              do
              {
                ClipperLib::Clipper::IntersectEdges(this, (_DWORD *)v14, (_DWORD *)v18, v20);
                uint64_t v18 = *(void *)(v18 + 120);
              }
              while (v18 != v14);
            }
          }
          goto LABEL_4;
        }
      }
      else
      {
        ClipperLib::Clipper::InsertEdgeIntoAEL((uint64_t)this, v14, 0);
        ClipperLib::Clipper::SetWindingCount((uint64_t)this, v14);
        uint64_t v15 = 0;
        if (ClipperLib::Clipper::IsContributing((uint64_t)this, (_DWORD *)v14)) {
          uint64_t v15 = ClipperLib::Clipper::AddOutPt(this, v14, (void *)v14);
        }
        if (!v14) {
          goto LABEL_4;
        }
        if (!*(void *)(v14 + 56)) {
          goto LABEL_22;
        }
      }
      uint64_t v32 = *(void *)(v14 + 40);
      std::priority_queue<long long>::push((uint64_t)v10, &v32);
      if (v13) {
        goto LABEL_25;
      }
LABEL_4:
      uint64_t v11 = (char *)this + *(void *)(*(void *)this - 24);
      uint64_t v12 = (void *)*((void *)v11 + 1);
      uint64_t v4 = v11 + 8;
      uint64_t v5 = v12;
      int64_t v7 = (void *)v4[2];
    }
    while (v12 != v7);
  }
}

uint64_t ClipperLib::Clipper::ClearGhostJoins(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 56);
  uint64_t v2 = *(void *)(this + 64);
  if (v2 != v1)
  {
    uint64_t v3 = this;
    unint64_t v4 = 0;
    do
    {
      this = *(void *)(v1 + 8 * v4);
      if (this)
      {
        this = MEMORY[0x237DF7CA0](this, 0x1020C406C4767B9);
        uint64_t v1 = *(void *)(v3 + 56);
        uint64_t v2 = *(void *)(v3 + 64);
      }
      ++v4;
    }
    while (v4 < (v2 - v1) >> 3);
    if (v2 != v1) {
      *(void *)(v3 + 64) = v1;
    }
  }
  return this;
}

void ClipperLib::Clipper::ProcessHorizontals(ClipperLib::Clipper *this, int a2)
{
  unint64_t v4 = (void *)((char *)this + 152);
  for (unint64_t i = (void *)*((void *)this + 19); i; unint64_t i = (void *)*((void *)this + 19))
  {
    uint64_t v6 = i[17];
    uint64_t v7 = i[18];
    if (*(_OWORD *)(i + 17) == 0)
    {
      void *v4 = 0;
    }
    else
    {
      uint64_t v8 = (void *)(v7 + 136);
      if (!v7) {
        uint64_t v8 = v4;
      }
      *uint64_t v8 = v6;
      if (v6) {
        *(void *)(v6 + 144) = v7;
      }
    }
    i[17] = 0;
    i[18] = 0;
    ClipperLib::Clipper::ProcessHorizontal(this, i, a2);
  }
}

BOOL ClipperLib::Clipper::ProcessIntersections(ClipperLib::Clipper *this, uint64_t a2)
{
  if (!*((void *)this + 18)) {
    return 1;
  }
  ClipperLib::Clipper::BuildIntersectList((uint64_t)this, a2);
  uint64_t v3 = (uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3;
  if (!v3) {
    return 1;
  }
  if (v3 == 1 || (BOOL result = ClipperLib::Clipper::FixupIntersectionOrder(this)))
  {
    ClipperLib::Clipper::ProcessIntersectList((uint64_t)this);
    *((void *)this + 19) = 0;
    return 1;
  }
  return result;
}

void sub_235EF1A38(void *a1)
{
  __cxa_begin_catch(a1);
  *(void *)(v1 + 152) = 0;
  ClipperLib::Clipper::DisposeIntersectNodes(v1);
  exceptiouint64_t n = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
  ClipperLib::clipperException::clipperException(exception, "ProcessIntersections error");
}

void sub_235EF1A88(_Unwind_Exception *a1)
{
}

void ClipperLib::Clipper::ProcessEdgesAtTopOfScanbeam(ClipperLib::Clipper *this, uint64_t a2)
{
  uint64_t v5 = (char *)this + 144;
  unint64_t v4 = (void *)*((void *)this + 18);
  uint64_t v31 = v4;
  if (v4)
  {
    while (v4[5] == a2)
    {
      if (!v4[14]
        && (((uint64_t v10 = v4[12], v11 = v4[4], *(void *)(v10 + 32) == v11) ? (v12 = *(void *)(v10 + 40) == a2) : (v12 = 0),
             (!v12 || *(void *)(v10 + 112))
          && ((uint64_t v10 = v4[13], *(void *)(v10 + 32) == v11) ? (v13 = *(void *)(v10 + 40) == a2) : (v13 = 0),
              !v13 || *(void *)(v10 + 112)))
         || *(_DWORD *)(v10 + 92) == -2
         || *(void *)(v10 + 56)))
      {
        uint64_t v14 = v4[16];
        ClipperLib::Clipper::DoMaxima(this, (uint64_t)v4);
        uint64_t v15 = (void **)(v14 + 120);
        if (!v14) {
          uint64_t v15 = (void **)v5;
        }
        unint64_t v4 = *v15;
        uint64_t v31 = v4;
        if (!v4) {
          goto LABEL_45;
        }
      }
      else
      {
        uint64_t v6 = v4[14];
        if (v6 && !*(void *)(v6 + 56))
        {
          ClipperLib::Clipper::UpdateEdgeIntoAEL((uint64_t)this, (uint64_t *)&v31);
          unint64_t v4 = v31;
          if ((*((_DWORD *)v31 + 23) & 0x80000000) == 0) {
            ClipperLib::Clipper::AddOutPt(this, (uint64_t)v31, v31);
          }
          uint64_t v16 = *((void *)this + 19);
          v4[18] = 0;
          if (v16) {
            *(void *)(v16 + 144) = v4;
          }
          *((void *)this + 19) = v4;
          v4[17] = v16;
          if (!*((unsigned char *)this + 174)) {
            goto LABEL_3;
          }
LABEL_14:
          if ((*((_DWORD *)v4 + 23) & 0x80000000) == 0)
          {
            if (*((_DWORD *)v4 + 20))
            {
              uint64_t v9 = v4[16];
              if (v9)
              {
                if ((*(_DWORD *)(v9 + 92) & 0x80000000) == 0 && *(void *)(v9 + 16) == v4[2] && *(_DWORD *)(v9 + 80))
                {
                  long long v30 = *((_OWORD *)v4 + 1);
                  ClipperLib::Clipper::AddOutPt(this, v9, &v30);
                  ClipperLib::Clipper::AddOutPt(this, (uint64_t)v4, &v30);
                  ClipperLib::Clipper::AddJoin();
                }
              }
            }
          }
          goto LABEL_3;
        }
        v4[2] = v4[4];
        v4[3] = a2;
        if (*((unsigned char *)this + 174)) {
          goto LABEL_14;
        }
LABEL_3:
        unint64_t v4 = (void *)v4[15];
        uint64_t v31 = v4;
        if (!v4) {
          goto LABEL_45;
        }
      }
    }
    double v7 = *((double *)v4 + 8) * (double)(a2 - v4[1]);
    if (v7 >= 0.0) {
      double v8 = 0.5;
    }
    else {
      double v8 = -0.5;
    }
    v4[2] = *v4 + (uint64_t)(v8 + v7);
    v4[3] = a2;
    if (*((unsigned char *)this + 174)) {
      goto LABEL_14;
    }
    goto LABEL_3;
  }
LABEL_45:
  for (unint64_t i = (void *)*((void *)this + 19); i; unint64_t i = (void *)*((void *)this + 19))
  {
    uint64_t v20 = i[17];
    uint64_t v21 = i[18];
    if (*(_OWORD *)(i + 17) == 0)
    {
      *((void *)this + 19) = 0;
    }
    else
    {
      uint64_t v22 = (void *)(v21 + 136);
      if (!v21) {
        uint64_t v22 = (void *)((char *)this + 152);
      }
      *uint64_t v22 = v20;
      if (v20) {
        *(void *)(v20 + 144) = v21;
      }
    }
    i[17] = 0;
    i[18] = 0;
    ClipperLib::Clipper::ProcessHorizontal(this, i, 1);
  }
  uint64_t v18 = (void *)*((void *)this + 18);
  uint64_t v31 = v18;
  if (v18)
  {
    uint64_t v19 = (char *)this + 40;
    do
    {
      if (v18[5] != a2 || !v18[14]) {
        goto LABEL_56;
      }
      if ((*((_DWORD *)v18 + 23) & 0x80000000) != 0)
      {
        uint64_t v23 = 0;
        ClipperLib::Clipper::UpdateEdgeIntoAEL((uint64_t)this, (uint64_t *)&v31);
        uint64_t v18 = v31;
        uint64_t v24 = v31[15];
        uint64_t v25 = v31[16];
        if (v25)
        {
LABEL_63:
          if (*(void *)(v25 + 16) == *v18)
          {
            uint64_t v26 = *(void *)(v25 + 24);
            BOOL v27 = v26 != v18[1] || v23 == 0;
            if (!v27
              && (*(_DWORD *)(v25 + 92) & 0x80000000) == 0
              && v26 > *(void *)(v25 + 40)
              && ClipperLib::SlopesEqual((uint64_t)v18, v25, v19[*(void *)(*(void *)this - 24)])
              && *((_DWORD *)v18 + 20)
              && *(_DWORD *)(v25 + 80))
            {
LABEL_55:
              ClipperLib::Clipper::AddOutPt(this, v25, v18);
              ClipperLib::Clipper::AddJoin();
            }
          }
        }
      }
      else
      {
        uint64_t v23 = ClipperLib::Clipper::AddOutPt(this, (uint64_t)v18, v18 + 4);
        ClipperLib::Clipper::UpdateEdgeIntoAEL((uint64_t)this, (uint64_t *)&v31);
        uint64_t v18 = v31;
        uint64_t v24 = v31[15];
        uint64_t v25 = v31[16];
        if (v25) {
          goto LABEL_63;
        }
      }
      if (v24 && *(void *)(v24 + 16) == *v18)
      {
        uint64_t v28 = *(void *)(v24 + 24);
        if (v28 == v18[1]
          && v23 != 0
          && (*(_DWORD *)(v24 + 92) & 0x80000000) == 0
          && v28 > *(void *)(v24 + 40)
          && ClipperLib::SlopesEqual((uint64_t)v18, v24, v19[*(void *)(*(void *)this - 24)]))
        {
          if (*((_DWORD *)v18 + 20))
          {
            uint64_t v25 = v24;
            if (*(_DWORD *)(v24 + 80)) {
              goto LABEL_55;
            }
          }
        }
      }
LABEL_56:
      uint64_t v18 = (void *)v18[15];
      uint64_t v31 = v18;
    }
    while (v18);
  }
}

uint64_t ClipperLib::Clipper::JoinCommonEdges(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 32);
  if (*(void *)(this + 40) != v1)
  {
    uint64_t v2 = this;
    for (unint64_t i = 0; i < (*(void *)(v2 + 40) - v1) >> 3; ++i)
    {
      unint64_t v4 = *(int ***)(v1 + 8 * i);
      uint64_t v5 = *(void *)(v2 + 8);
      uint64_t v6 = *(int **)(v5 + 8 * **v4);
      do
      {
        uint64_t v7 = (uint64_t)v6;
        uint64_t v6 = *(int **)(v5 + 8 * *v6);
      }
      while ((int *)v7 != v6);
      double v8 = *(int **)(v5 + 8 * *v4[1]);
      do
      {
        uint64_t v9 = (uint64_t)v8;
        double v8 = *(int **)(v5 + 8 * *v8);
      }
      while ((int *)v9 != v8);
      if (*(void *)(v7 + 24) && *(void *)(v9 + 24))
      {
        if (v7 == v9)
        {
          this = ClipperLib::Clipper::JoinPoints((void *)v2, v4, v7, v7);
          if (this)
          {
            *(void *)(v7 + 24) = *v4;
            *(void *)(v7 + 32) = 0;
            ClipperLib::Clipper::CreateOutRec((ClipperLib::Clipper *)v2);
          }
          goto LABEL_3;
        }
        uint64_t v10 = v7;
        do
          uint64_t v10 = *(void *)(v10 + 8);
        while (v10 != v9 && v10 != 0);
        uint64_t LowermostRec = v9;
        if (v10 != v9)
        {
          uint64_t v13 = v9;
          do
            uint64_t v13 = *(void *)(v13 + 8);
          while (v13 != v7 && v13 != 0);
          uint64_t LowermostRec = v7;
          if (v13 != v7) {
            uint64_t LowermostRec = ClipperLib::GetLowermostRec(v7, v9);
          }
        }
        this = ClipperLib::Clipper::JoinPoints((void *)v2, v4, v7, v9);
        if (this)
        {
          *(void *)(v9 + 24) = 0;
          *(void *)(v9 + 32) = 0;
          *(_DWORD *)uint64_t v9 = *(_DWORD *)v7;
          *(unsigned char *)(v7 + 4) = *(unsigned char *)(LowermostRec + 4);
          if (LowermostRec == v9)
          {
            *(void *)(v7 + 8) = *(void *)(v9 + 8);
            *(void *)(v9 + 8) = v7;
            if (*(unsigned char *)(v2 + 173))
            {
LABEL_33:
              uint64_t v15 = *(void *)(v2 + 8);
              uint64_t v16 = *(void *)(v2 + 16) - v15;
              if (v16)
              {
                unint64_t v17 = v16 >> 3;
                if (v17 <= 1) {
                  unint64_t v17 = 1;
                }
                do
                {
                  if (*(void *)(*(void *)v15 + 8) == v9) {
                    *(void *)(*(void *)v15 + 8) = v7;
                  }
                  v15 += 8;
                  --v17;
                }
                while (v17);
              }
            }
          }
          else
          {
            *(void *)(v9 + 8) = v7;
            if (*(unsigned char *)(v2 + 173)) {
              goto LABEL_33;
            }
          }
        }
      }
LABEL_3:
      uint64_t v1 = *(void *)(v2 + 32);
    }
  }
  return this;
}

uint64_t ClipperLib::Clipper::FixupOutPolygon(void *a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  uint64_t v2 = *(void **)(a2 + 24);
  unint64_t v4 = v2 + 4;
  uint64_t v3 = (void *)v2[4];
  if (v3 == v2)
  {
    uint64_t v6 = *(void **)(a2 + 24);
    goto LABEL_30;
  }
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v6 = (void *)v2[3];
    if (v3 == v6) {
      break;
    }
    uint64_t v7 = v2[1];
    uint64_t v8 = v2[2];
    uint64_t v9 = v6[1];
    uint64_t v10 = v6[2];
    if (v7 == v9 && v8 == v10) {
      goto LABEL_3;
    }
    uint64_t v12 = v3[1];
    uint64_t v13 = v3[2];
    if (v7 == v12 && v8 == v13) {
      goto LABEL_3;
    }
    uint64_t v20 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v21 = v5;
    uint64_t result = ClipperLib::SlopesEqual(v12, v13, v7, v8, v9, v10, v20[40]);
    uint64_t v5 = v21;
    if (!result) {
      goto LABEL_23;
    }
    if (!v20[72]) {
      goto LABEL_3;
    }
    if (v12 == v9 && v13 == v10) {
      goto LABEL_3;
    }
    if (v12 == v9)
    {
      if (v8 <= v13 != v8 < v10) {
        goto LABEL_23;
      }
LABEL_3:
      v3[3] = v6;
      *(void *)(v2[3] + 32) = v3;
      uint64_t v6 = (void *)*v4;
      MEMORY[0x237DF7CA0](v2, 0x1020C409AE45206);
      uint64_t v5 = 0;
      unint64_t v4 = v6 + 4;
      uint64_t v3 = (void *)v6[4];
      uint64_t v2 = v6;
      if (v3 == v6) {
        goto LABEL_30;
      }
    }
    else
    {
      if (v7 < v9 == v7 <= v12) {
        goto LABEL_3;
      }
LABEL_23:
      if (v2 == v21) {
        goto LABEL_33;
      }
      if (!v21) {
        uint64_t v5 = v2;
      }
      unint64_t v4 = v6 + 4;
      uint64_t v3 = (void *)v6[4];
      uint64_t v2 = v6;
      if (v3 == v6) {
        goto LABEL_30;
      }
    }
  }
  uint64_t v6 = v2;
  uint64_t v2 = v3;
LABEL_30:
  v2[3] = 0;
  do
  {
    unint64_t v17 = (void *)v6[3];
    uint64_t result = MEMORY[0x237DF7CA0](v6, 0x1020C409AE45206);
    uint64_t v6 = v17;
  }
  while (v17);
  uint64_t v5 = 0;
LABEL_33:
  *(void *)(a2 + 24) = v5;
  return result;
}

uint64_t ClipperLib::Clipper::DoSimplePolygons(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  uint64_t v2 = *(void *)(this + 16);
  if (v2 != v1)
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(v1 + 8 * v3);
      uint64_t v5 = *(void **)(v4 + 24);
      if (v5 && !*(unsigned char *)(v4 + 5))
      {
        uint64_t v6 = *(void **)(v4 + 24);
        do
        {
          uint64_t v7 = (void *)v6[3];
          if (v7 == v5) {
            break;
          }
          do
          {
            BOOL v8 = v6[1] == v7[1] && v6[2] == v7[2];
            if (v8 && (void *)v7[3] != v6)
            {
              uint64_t v9 = (void *)v7[4];
              if (v9 != v6)
              {
                uint64_t v10 = v6[4];
                v6[4] = v9;
                v9[3] = v6;
                v7[4] = v10;
                *(void *)(v10 + 24) = v7;
                *(void *)(v4 + 24) = v6;
                operator new();
              }
            }
            uint64_t v7 = (void *)v7[3];
          }
          while (v7 != v5);
          uint64_t v6 = (void *)v6[3];
        }
        while (v6 != v5);
        uint64_t v1 = *(void *)(this + 8);
      }
      ++v3;
    }
    while (v3 < (v2 - v1) >> 3);
  }
  return this;
}

uint64_t ClipperLib::Clipper::ClearJoins(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 32);
  uint64_t v2 = *(void *)(this + 40);
  if (v2 != v1)
  {
    uint64_t v3 = this;
    unint64_t v4 = 0;
    do
    {
      this = *(void *)(v1 + 8 * v4);
      if (this)
      {
        this = MEMORY[0x237DF7CA0](this, 0x1020C406C4767B9);
        uint64_t v1 = *(void *)(v3 + 32);
        uint64_t v2 = *(void *)(v3 + 40);
      }
      ++v4;
    }
    while (v4 < (v2 - v1) >> 3);
    if (v2 != v1) {
      *(void *)(v3 + 40) = v1;
    }
  }
  return this;
}

void std::priority_queue<long long>::push(uint64_t a1, void *a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  uint64_t v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    BOOL v8 = *(char **)a1;
    uint64_t v9 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v10 = v9 >> 3;
    unint64_t v11 = (v9 >> 3) + 1;
    if (v11 >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v12 = v4 - (void)v8;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v14 = operator new(8 * v13);
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v10];
    *uint64_t v15 = *a2;
    uint64_t v7 = v15 + 1;
    if (v5 != v8)
    {
      unint64_t v16 = v5 - v8 - 8;
      if (v16 < 0x58) {
        goto LABEL_32;
      }
      if ((unint64_t)(v5 - v14 - v9) < 0x20) {
        goto LABEL_32;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v6 = &v5[-v18];
      uint64_t v15 = (void *)((char *)v15 - v18);
      uint64_t v19 = &v14[8 * v10 - 16];
      uint64_t v20 = v5 - 16;
      uint64_t v21 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *(_OWORD *)v20;
        *(v19 - 1) = *((_OWORD *)v20 - 1);
        *uint64_t v19 = v22;
        v19 -= 2;
        v20 -= 32;
        v21 -= 4;
      }
      while (v21);
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_32:
        do
        {
          uint64_t v23 = *((void *)v6 - 1);
          v6 -= 8;
          *--uint64_t v15 = v23;
        }
        while (v6 != v8);
      }
    }
    *(void *)a1 = v15;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v14[8 * v13];
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(void *)uint64_t v5 = *a2;
    uint64_t v7 = v5 + 8;
  }
  *(void *)(a1 + 8) = v7;
  uint64_t v24 = *(char **)a1;
  uint64_t v25 = (uint64_t)v7 - *(void *)a1;
  if (v25 >= 9)
  {
    unint64_t v26 = (((unint64_t)v25 >> 3) - 2) >> 1;
    BOOL v27 = &v24[8 * v26];
    uint64_t v30 = *(v7 - 1);
    uint64_t v29 = (char *)(v7 - 1);
    uint64_t v28 = v30;
    uint64_t v31 = *(void *)v27;
    if (*(void *)v27 < v30)
    {
      do
      {
        *(void *)uint64_t v29 = v31;
        uint64_t v29 = v27;
        if (!v26) {
          break;
        }
        unint64_t v26 = (v26 - 1) >> 1;
        BOOL v27 = &v24[8 * v26];
        uint64_t v31 = *(void *)v27;
      }
      while (*(void *)v27 < v28);
      *(void *)uint64_t v29 = v28;
    }
  }
}

uint64_t ClipperLib::Clipper::DisposeOutRec(ClipperLib::Clipper *this, uint64_t a2)
{
  uint64_t v4 = *(void *)(*((void *)this + 1) + 8 * a2);
  uint64_t v5 = *(void *)(v4 + 24);
  if (v5)
  {
    *(void *)(*(void *)(v5 + 32) + 24) = 0;
    for (uint64_t i = *(void *)(v4 + 24); i; uint64_t i = *(void *)(v4 + 24))
    {
      *(void *)(v4 + 24) = *(void *)(i + 24);
      MEMORY[0x237DF7CA0]();
    }
  }
  uint64_t result = MEMORY[0x237DF7CA0](v4, 0x1020C401FC46325);
  *(void *)(*((void *)this + 1) + 8 * a2) = 0;
  return result;
}

uint64_t ClipperLib::Clipper::SetWindingCount(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 128);
  int v3 = *(_DWORD *)(a2 + 72);
  if (v2)
  {
    while (1)
    {
      if (*(_DWORD *)(v2 + 72) == v3)
      {
        int v7 = *(_DWORD *)(v2 + 80);
        if (v7) {
          break;
        }
      }
      uint64_t v2 = *(void *)(v2 + 128);
      if (!v2) {
        goto LABEL_2;
      }
    }
    unsigned int v8 = *(_DWORD *)(a2 + 80);
    if (v8)
    {
      uint64_t v9 = 164;
      if (!v3) {
        uint64_t v9 = 168;
      }
      if (!*(_DWORD *)(result + v9)) {
        goto LABEL_38;
      }
      int v10 = *(_DWORD *)(v2 + 84);
      if (((v10 * v7) & 0x80000000) == 0)
      {
        if (((v8 * v7) & 0x80000000) == 0) {
          int v11 = *(_DWORD *)(a2 + 80);
        }
        else {
          int v11 = 0;
        }
        unsigned int v8 = v10 + v11;
        goto LABEL_38;
      }
LABEL_24:
      if (v10 >= 0) {
        unsigned int v13 = v10;
      }
      else {
        unsigned int v13 = -v10;
      }
      if (v8 <= 1) {
        int v14 = 1;
      }
      else {
        int v14 = *(_DWORD *)(a2 + 80);
      }
      if (((v8 * v7) & 0x80000000) == 0) {
        int v15 = *(_DWORD *)(a2 + 80);
      }
      else {
        int v15 = 0;
      }
      unsigned int v16 = v10 + v15;
      if (v13 >= 2) {
        unsigned int v8 = v16;
      }
      else {
        unsigned int v8 = v14;
      }
      goto LABEL_38;
    }
    if (*(_DWORD *)(result + 104) == 1)
    {
      uint64_t v12 = 164;
      if (!v3) {
        uint64_t v12 = 168;
      }
      if (!*(_DWORD *)(result + v12))
      {
        uint64_t v17 = *(void *)(v2 + 128);
        for (i = 1; v17; uint64_t v17 = *(void *)(v17 + 128))
        {
          if (*(_DWORD *)(v17 + 72) == v3) {
            i ^= *(_DWORD *)(v17 + 80) != 0;
          }
        }
        unsigned int v8 = (i & 1) == 0;
        goto LABEL_38;
      }
      int v10 = *(_DWORD *)(v2 + 84);
      if (v10 * v7 < 0) {
        goto LABEL_24;
      }
      unsigned int v8 = ((v10 >> 31) | 1) + v10;
    }
    else
    {
      unsigned int v8 = 1;
    }
LABEL_38:
    int v4 = *(_DWORD *)(v2 + 88);
    *(_DWORD *)(a2 + 84) = v8;
    *(_DWORD *)(a2 + 88) = v4;
    uint64_t v6 = (uint64_t *)(v2 + 120);
    goto LABEL_39;
  }
LABEL_2:
  int v4 = 0;
  unsigned int v5 = *(_DWORD *)(a2 + 80);
  if (v5 <= 1) {
    unsigned int v5 = 1;
  }
  *(_DWORD *)(a2 + 84) = v5;
  *(_DWORD *)(a2 + 88) = 0;
  uint64_t v6 = (uint64_t *)(result + 144);
LABEL_39:
  uint64_t v19 = *v6;
  BOOL v20 = v3 == 0;
  uint64_t v21 = 168;
  if (v20) {
    uint64_t v21 = 164;
  }
  if (*(_DWORD *)(result + v21))
  {
    if (v19 != a2)
    {
      do
      {
        v4 += *(_DWORD *)(v19 + 80);
        uint64_t v19 = *(void *)(v19 + 120);
      }
      while (v19 != a2);
      *(_DWORD *)(a2 + 88) = v4;
    }
  }
  else
  {
    while (v19 != a2)
    {
      if (*(_DWORD *)(v19 + 80))
      {
        int v4 = v4 == 0;
        *(_DWORD *)(a2 + 88) = v4;
      }
      uint64_t v19 = *(void *)(v19 + 120);
    }
  }
  return result;
}

BOOL ClipperLib::Clipper::IsEvenOddFillType(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 164;
  if (!*(_DWORD *)(a2 + 72)) {
    uint64_t v2 = 168;
  }
  return *(_DWORD *)(a1 + v2) == 0;
}

BOOL ClipperLib::Clipper::IsEvenOddAltFillType(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 168;
  if (!*(_DWORD *)(a2 + 72)) {
    uint64_t v2 = 164;
  }
  return *(_DWORD *)(a1 + v2) == 0;
}

uint64_t ClipperLib::Clipper::IsContributing(uint64_t a1, _DWORD *a2)
{
  int v2 = a2[18];
  uint64_t v3 = 164;
  if (v2) {
    uint64_t v4 = 164;
  }
  else {
    uint64_t v4 = 168;
  }
  if (v2) {
    uint64_t v3 = 168;
  }
  unsigned int v5 = *(_DWORD *)(a1 + v3);
  int v6 = *(_DWORD *)(a1 + v4);
  if (v6 != 2)
  {
    if (v6 == 1)
    {
      int v8 = a2[21];
      if (v8 < 0) {
        int v8 = -v8;
      }
      if (v8 != 1) {
        return 0;
      }
      goto LABEL_15;
    }
    if (v6)
    {
      if (a2[21] != -1) {
        return 0;
      }
      goto LABEL_15;
    }
    if (a2[20]) {
      goto LABEL_15;
    }
  }
  if (a2[21] != 1) {
    return 0;
  }
LABEL_15:
  switch(*(_DWORD *)(a1 + 104))
  {
    case 0:
      BOOL v9 = v5 == 2;
      if (v5 >= 2) {
        goto LABEL_22;
      }
      goto LABEL_17;
    case 1:
      goto LABEL_27;
    case 2:
      BOOL v9 = v5 == 2;
      if (v2)
      {
        if (v5 < 2)
        {
LABEL_17:
          uint64_t result = a2[22] != 0;
        }
        else
        {
LABEL_22:
          if (v9) {
            uint64_t result = a2[22] > 0;
          }
          else {
            uint64_t result = a2[22] >> 31;
          }
        }
      }
      else if (v5 < 2)
      {
LABEL_28:
        uint64_t result = a2[22] == 0;
      }
      else
      {
LABEL_30:
        if (v9) {
          uint64_t result = a2[22] < 1;
        }
        else {
          uint64_t result = a2[22] >= 0;
        }
      }
      break;
    case 3:
      if (a2[20]) {
        return 1;
      }
LABEL_27:
      BOOL v9 = v5 == 2;
      if (v5 < 2) {
        goto LABEL_28;
      }
      goto LABEL_30;
    default:
      return 1;
  }
  return result;
}

uint64_t ClipperLib::Clipper::AddLocalMinPoly(ClipperLib::Clipper *this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6 = a2;
  if (*(void *)(a3 + 56) && *(double *)(a2 + 64) <= *(double *)(a3 + 64))
  {
    uint64_t v8 = ClipperLib::Clipper::AddOutPt(this, a3, a4);
    *(_DWORD *)(v6 + 92) = *(_DWORD *)(a3 + 92);
    *(_DWORD *)(v6 + 76) = 2;
    *(_DWORD *)(a3 + 76) = 1;
    uint64_t v9 = *(void *)(a3 + 128);
    uint64_t v10 = v6;
    BOOL v16 = v9 == v6;
    uint64_t v6 = a3;
    if (!v16) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  uint64_t v8 = ClipperLib::Clipper::AddOutPt(this, a2, a4);
  *(_DWORD *)(a3 + 92) = *(_DWORD *)(v6 + 92);
  *(_DWORD *)(v6 + 76) = 1;
  *(_DWORD *)(a3 + 76) = 2;
  uint64_t v9 = *(void *)(v6 + 128);
  uint64_t v10 = a3;
  if (v9 == a3) {
LABEL_4:
  }
    uint64_t v9 = *(void *)(v10 + 128);
LABEL_5:
  if (!v9 || (*(_DWORD *)(v9 + 92) & 0x80000000) != 0) {
    return v8;
  }
  uint64_t v11 = a4[1];
  if (*(void *)(v9 + 40) == v11)
  {
    uint64_t v12 = *(void *)(v9 + 32);
    if (*(void *)(v6 + 40) != v11) {
      goto LABEL_9;
    }
LABEL_19:
    if (v12 != *(void *)(v6 + 32)) {
      return v8;
    }
    goto LABEL_20;
  }
  double v17 = *(double *)(v9 + 64) * (double)(v11 - *(void *)(v9 + 8));
  double v18 = 0.5;
  if (v17 < 0.0) {
    double v18 = -0.5;
  }
  uint64_t v12 = *(void *)v9 + (uint64_t)(v18 + v17);
  if (*(void *)(v6 + 40) == v11) {
    goto LABEL_19;
  }
LABEL_9:
  double v13 = *(double *)(v6 + 64) * (double)(v11 - *(void *)(v6 + 8));
  double v14 = 0.5;
  if (v13 < 0.0) {
    double v14 = -0.5;
  }
  if (v12 == *(void *)v6 + (uint64_t)(v14 + v13))
  {
LABEL_20:
    if (ClipperLib::SlopesEqual(v6, v9, *((unsigned __int8 *)this + *(void *)(*(void *)this - 24) + 40))
      && *(_DWORD *)(v6 + 80)
      && *(_DWORD *)(v9 + 80))
    {
      ClipperLib::Clipper::AddOutPt(this, v9, a4);
      ClipperLib::Clipper::AddJoin();
    }
  }
  return v8;
}

uint64_t ClipperLib::Clipper::AddOutPt(ClipperLib::Clipper *this, uint64_t a2, void *a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 92);
  if ((v3 & 0x80000000) != 0) {
    ClipperLib::Clipper::CreateOutRec(this);
  }
  uint64_t v4 = *(void *)(*((void *)this + 1) + 8 * v3);
  unsigned int v5 = *(void **)(v4 + 24);
  if (*(_DWORD *)(a2 + 76) == 1)
  {
    if (*a3 != v5[1] || a3[1] != v5[2]) {
      goto LABEL_15;
    }
    return *(void *)(v4 + 24);
  }
  else
  {
    uint64_t result = v5[4];
    if (*a3 != *(void *)(result + 8) || a3[1] != *(void *)(result + 16)) {
LABEL_15:
    }
      operator new();
  }
  return result;
}

void ClipperLib::Clipper::AddJoin()
{
}

uint64_t ClipperLib::Clipper::AddLocalMaxPoly(ClipperLib::Clipper *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t result = ClipperLib::Clipper::AddOutPt(a1, a2, a4);
  if (*(_DWORD *)(a3 + 80))
  {
    int v9 = *(_DWORD *)(a2 + 92);
    int v10 = *(_DWORD *)(a3 + 92);
    BOOL v11 = v9 < v10;
    if (v9 == v10)
    {
LABEL_3:
      *(_DWORD *)(a2 + 92) = -1;
      *(_DWORD *)(a3 + 92) = -1;
      return result;
    }
  }
  else
  {
    uint64_t result = ClipperLib::Clipper::AddOutPt(a1, a3, a4);
    int v12 = *(_DWORD *)(a2 + 92);
    int v13 = *(_DWORD *)(a3 + 92);
    BOOL v11 = v12 < v13;
    if (v12 == v13) {
      goto LABEL_3;
    }
  }
  if (v11)
  {
    uint64_t v14 = a2;
    uint64_t v15 = a3;
  }
  else
  {
    uint64_t v14 = a3;
    uint64_t v15 = a2;
  }
  return ClipperLib::Clipper::AppendPolygon((uint64_t)a1, v14, v15);
}

uint64_t ClipperLib::Clipper::AppendPolygon(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(v6 + 8 * *(int *)(a2 + 92));
  uint64_t v8 = *(void *)(v6 + 8 * *(int *)(a3 + 92));
  uint64_t v9 = v7;
  do
    uint64_t v9 = *(void *)(v9 + 8);
  while (v9 != v8 && v9 != 0);
  uint64_t result = *(void *)(v6 + 8 * *(int *)(a3 + 92));
  if (v9 != v8)
  {
    uint64_t v12 = *(void *)(v6 + 8 * *(int *)(a3 + 92));
    do
      uint64_t v12 = *(void *)(v12 + 8);
    while (v12 != v7 && v12 != 0);
    uint64_t result = *(void *)(v6 + 8 * *(int *)(a2 + 92));
    if (v12 != v7) {
      uint64_t result = ClipperLib::GetLowermostRec(*(void *)(v6 + 8 * *(int *)(a2 + 92)), *(void *)(v6 + 8 * *(int *)(a3 + 92)));
    }
  }
  uint64_t v14 = *(void *)(v7 + 24);
  uint64_t v15 = *(void *)(v14 + 32);
  uint64_t v16 = *(void *)(v8 + 24);
  uint64_t v17 = *(void *)(v16 + 32);
  int v18 = *(_DWORD *)(a3 + 76);
  if (*(_DWORD *)(a2 + 76) == 1)
  {
    if (v18 == 1)
    {
      uint64_t v19 = *(void *)(v8 + 24);
      do
      {
        int8x16_t v20 = *(int8x16_t *)(v19 + 24);
        *(int8x16_t *)(v19 + 24) = vextq_s8(v20, v20, 8uLL);
        uint64_t v19 = v20.i64[0];
      }
      while (v20.i64[0] != v16);
      *(void *)(v16 + 24) = v14;
      *(void *)(v14 + 32) = v16;
      *(void *)(v15 + 24) = v17;
      *(void *)(v17 + 32) = v15;
      *(void *)(v7 + 24) = v17;
      *(void *)(v7 + 32) = 0;
      int v21 = 1;
      if (result != v8) {
        goto LABEL_33;
      }
    }
    else
    {
      *(void *)(v17 + 24) = v14;
      *(void *)(v14 + 32) = v17;
      *(void *)(v16 + 32) = v15;
      *(void *)(v15 + 24) = v16;
      *(void *)(v7 + 24) = v16;
      *(void *)(v7 + 32) = 0;
      int v21 = 1;
      if (result != v8) {
        goto LABEL_33;
      }
    }
  }
  else if (v18 == 2)
  {
    uint64_t v22 = *(void *)(v8 + 24);
    do
    {
      int8x16_t v23 = *(int8x16_t *)(v22 + 24);
      *(int8x16_t *)(v22 + 24) = vextq_s8(v23, v23, 8uLL);
      uint64_t v22 = v23.i64[0];
    }
    while (v23.i64[0] != v16);
    *(void *)(v15 + 24) = v17;
    *(void *)(v17 + 32) = v15;
    *(void *)(v16 + 24) = v14;
    int v21 = 2;
    *(void *)(v14 + 32) = v16;
    *(void *)(v7 + 32) = 0;
    if (result != v8) {
      goto LABEL_33;
    }
  }
  else
  {
    *(void *)(v15 + 24) = v16;
    *(void *)(v16 + 32) = v15;
    *(void *)(v14 + 32) = v17;
    int v21 = 2;
    *(void *)(v17 + 24) = v14;
    *(void *)(v7 + 32) = 0;
    if (result != v8) {
      goto LABEL_33;
    }
  }
  uint64_t v24 = *(void *)(v8 + 8);
  if (v24 != v7) {
    *(void *)(v7 + 8) = v24;
  }
  *(unsigned char *)(v7 + 4) = *(unsigned char *)(v8 + 4);
LABEL_33:
  *(void *)(v8 + 24) = 0;
  *(void *)(v8 + 32) = 0;
  *(void *)(v8 + 8) = v7;
  int v25 = *(_DWORD *)(a2 + 92);
  int v26 = *(_DWORD *)(a3 + 92);
  *(_DWORD *)(a2 + 92) = -1;
  *(_DWORD *)(a3 + 92) = -1;
  uint64_t v27 = *(void *)(a1 + 144);
  if (v27)
  {
    while (*(_DWORD *)(v27 + 92) != v26)
    {
      uint64_t v27 = *(void *)(v27 + 120);
      if (!v27) {
        goto LABEL_38;
      }
    }
    *(_DWORD *)(v27 + 92) = v25;
    *(_DWORD *)(v27 + 76) = v21;
  }
LABEL_38:
  *(_DWORD *)uint64_t v8 = *(_DWORD *)v7;
  return result;
}

uint64_t ClipperLib::Clipper::AddEdgeToSEL(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 152);
  *(void *)(a2 + 144) = 0;
  if (v2) {
    *(void *)(v2 + 144) = a2;
  }
  *(void *)(result + 152) = a2;
  *(void *)(a2 + 136) = v2;
  return result;
}

__n128 ClipperLib::Clipper::CopyAELToSEL(ClipperLib::Clipper *this)
{
  unint64_t v1 = *((void *)this + 18);
  *((void *)this + 19) = v1;
  if (v1)
  {
    do
    {
      __n128 result = *(__n128 *)(v1 + 120);
      *(__n128 *)(v1 + 136) = result;
      unint64_t v1 = result.n128_u64[0];
    }
    while (result.n128_u64[0]);
  }
  return result;
}

void ClipperLib::Clipper::AddGhostJoin()
{
}

void *ClipperLib::Clipper::InsertEdgeIntoAEL(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 144);
  __n128 result = (void *)(a1 + 144);
  uint64_t v4 = v5;
  if (!v5)
  {
    *(void *)(a2 + 120) = 0;
    *(void *)(a2 + 128) = 0;
    void *result = a2;
    return result;
  }
  if (a3)
  {
    uint64_t v6 = *(void *)(a3 + 120);
    if (v6) {
      goto LABEL_4;
    }
    goto LABEL_31;
  }
  uint64_t v16 = *(void *)(a2 + 16);
  uint64_t v17 = *(void *)(v4 + 16);
  if (v16 != v17)
  {
    if (v16 >= v17) {
      goto LABEL_28;
    }
    goto LABEL_36;
  }
  uint64_t v18 = *(void *)(a2 + 40);
  uint64_t v19 = *(void *)(v4 + 40);
  BOOL v20 = v18 == v19;
  if (v18 > v19)
  {
    double v21 = *(double *)(v4 + 64) * (double)(v18 - *(void *)(v4 + 8));
    double v22 = 0.5;
    if (v21 < 0.0) {
      double v22 = -0.5;
    }
    if (*(void *)(a2 + 32) >= *(void *)v4 + (uint64_t)(v22 + v21)) {
      goto LABEL_28;
    }
LABEL_36:
    *(void *)(a2 + 120) = v4;
    *(void *)(a2 + 128) = 0;
    *(void *)(v4 + 128) = a2;
    void *result = a2;
    return result;
  }
  uint64_t v24 = *(void *)(v4 + 32);
  if (v20)
  {
    if (v24 <= *(void *)(a2 + 32)) {
      goto LABEL_28;
    }
    goto LABEL_36;
  }
  double v25 = *(double *)(a2 + 64) * (double)(v19 - *(void *)(a2 + 8));
  double v26 = 0.5;
  if (v25 < 0.0) {
    double v26 = -0.5;
  }
  if (v24 > *(void *)a2 + (uint64_t)(v26 + v25)) {
    goto LABEL_36;
  }
LABEL_28:
  a3 = v4;
  uint64_t v6 = *(void *)(v4 + 120);
  if (v6)
  {
LABEL_4:
    uint64_t v7 = *(void *)(a2 + 16);
    uint64_t v8 = a3;
    do
    {
      a3 = v8;
      uint64_t v8 = v6;
      uint64_t v9 = *(void *)(v6 + 16);
      if (v7 == v9)
      {
        uint64_t v10 = *(void *)(a2 + 40);
        uint64_t v11 = *(void *)(v8 + 40);
        if (v10 <= v11)
        {
          if (v10 == v11)
          {
            if (*(void *)(v8 + 32) > *(void *)(a2 + 32)) {
              goto LABEL_32;
            }
          }
          else
          {
            double v14 = *(double *)(a2 + 64) * (double)(v11 - *(void *)(a2 + 8));
            if (v14 >= 0.0) {
              double v15 = 0.5;
            }
            else {
              double v15 = -0.5;
            }
            if (*(void *)(v8 + 32) > *(void *)a2 + (uint64_t)(v15 + v14)) {
              goto LABEL_32;
            }
          }
        }
        else
        {
          double v12 = *(double *)(v8 + 64) * (double)(v10 - *(void *)(v8 + 8));
          if (v12 >= 0.0) {
            double v13 = 0.5;
          }
          else {
            double v13 = -0.5;
          }
          if (*(void *)(a2 + 32) < *(void *)v8 + (uint64_t)(v13 + v12)) {
            goto LABEL_32;
          }
        }
      }
      else if (v7 < v9)
      {
        goto LABEL_32;
      }
      uint64_t v6 = *(void *)(v8 + 120);
    }
    while (v6);
    a3 = v8;
  }
LABEL_31:
  uint64_t v8 = 0;
LABEL_32:
  *(void *)(a2 + 120) = v8;
  __n128 result = (void *)(a3 + 120);
  uint64_t v23 = *(void *)(a3 + 120);
  if (v23) {
    *(void *)(v23 + 128) = a2;
  }
  *(void *)(a2 + 128) = a3;
  void *result = a2;
  return result;
}

_DWORD *ClipperLib::Clipper::IntersectEdges(_DWORD *this, _DWORD *a2, _DWORD *a3, void *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = (ClipperLib::Clipper *)this;
  int v8 = a2[23];
  int v9 = a3[23];
  int v10 = a2[18];
  int v11 = a3[18];
  if (v10 != v11)
  {
    if (v11) {
      uint64_t v17 = this + 41;
    }
    else {
      uint64_t v17 = this + 42;
    }
    if (*v17)
    {
      a2[22] += a3[20];
      if (v10) {
        double v12 = this + 41;
      }
      else {
        double v12 = this + 42;
      }
      if (*v12)
      {
LABEL_19:
        int v18 = a3[22] - a2[20];
LABEL_26:
        a3[22] = v18;
        goto LABEL_28;
      }
    }
    else
    {
      a2[22] = a2[22] == 0;
      if (v10) {
        double v12 = this + 41;
      }
      else {
        double v12 = this + 42;
      }
      if (*v12) {
        goto LABEL_19;
      }
    }
    int v18 = a3[22] == 0;
    goto LABEL_26;
  }
  if (v10) {
    double v12 = this + 41;
  }
  else {
    double v12 = this + 42;
  }
  int v13 = a2[21];
  if (*v12)
  {
    if (a3[20] + v13) {
      int v14 = a3[20] + v13;
    }
    else {
      int v14 = -v13;
    }
    a2[21] = v14;
    int v15 = a3[21];
    int v16 = v15 - a2[20];
    if (v16) {
      a3[21] = v16;
    }
    else {
      a3[21] = -v15;
    }
  }
  else
  {
    a2[21] = a3[21];
    a3[21] = v13;
  }
LABEL_28:
  if (v10) {
    uint64_t v19 = this + 42;
  }
  else {
    uint64_t v19 = this + 41;
  }
  int v20 = *v12;
  if (v11) {
    double v21 = this + 41;
  }
  else {
    double v21 = this + 42;
  }
  if (v11) {
    double v22 = this + 42;
  }
  else {
    double v22 = this + 41;
  }
  int v23 = *v21;
  if (v20 == 3)
  {
    unint64_t v24 = -(uint64_t)(int)a2[21];
    if (v23 == 3) {
      goto LABEL_49;
    }
  }
  else if (v20 == 2)
  {
    unint64_t v24 = (int)a2[21];
    if (v23 == 3) {
      goto LABEL_49;
    }
  }
  else
  {
    LODWORD(v24) = a2[21];
    if ((v24 & 0x80000000) == 0) {
      unint64_t v24 = v24;
    }
    else {
      unint64_t v24 = -(int)v24;
    }
    if (v23 == 3)
    {
LABEL_49:
      unint64_t v25 = -(uint64_t)(int)a3[21];
      int v26 = *v19;
      int v27 = *v22;
      if (v8 < 0) {
        goto LABEL_61;
      }
LABEL_55:
      if (v9 < 0) {
        goto LABEL_61;
      }
      if (v24 <= 1 && v25 <= 1 && (v10 == v11 || this[26] == 3))
      {
        ClipperLib::Clipper::AddOutPt((ClipperLib::Clipper *)this, (uint64_t)a2, a4);
        goto LABEL_70;
      }
      this = (_DWORD *)ClipperLib::Clipper::AddOutPt((ClipperLib::Clipper *)this, (uint64_t)a2, a4);
      if (a3[20])
      {
        int v28 = v6[23];
        int v29 = a3[23];
        BOOL v30 = v28 < v29;
        if (v28 == v29)
        {
LABEL_66:
          v6[23] = -1;
          a3[23] = -1;
          return this;
        }
      }
      else
      {
        this = (_DWORD *)ClipperLib::Clipper::AddOutPt(v7, (uint64_t)a3, a4);
        int v33 = v6[23];
        int v34 = a3[23];
        BOOL v30 = v33 < v34;
        if (v33 == v34) {
          goto LABEL_66;
        }
      }
      if (v30)
      {
        uint64_t v35 = (uint64_t)v6;
        uint64_t v36 = (uint64_t)a3;
      }
      else
      {
        uint64_t v35 = (uint64_t)a3;
        uint64_t v36 = (uint64_t)v6;
      }
      return (_DWORD *)ClipperLib::Clipper::AppendPolygon((uint64_t)v7, v35, v36);
    }
  }
  if (v23 == 2)
  {
    unint64_t v25 = (int)a3[21];
    int v26 = *v19;
    int v27 = *v22;
    if (v8 < 0) {
      goto LABEL_61;
    }
    goto LABEL_55;
  }
  LODWORD(v25) = a3[21];
  if ((v25 & 0x80000000) == 0) {
    unint64_t v25 = v25;
  }
  else {
    unint64_t v25 = -(int)v25;
  }
  int v26 = *v19;
  int v27 = *v22;
  if ((v8 & 0x80000000) == 0) {
    goto LABEL_55;
  }
LABEL_61:
  if (v8 < 0)
  {
    if (v9 < 0)
    {
      if (v24 <= 1 && v25 <= 1)
      {
        if (v26 == 3)
        {
          uint64_t v37 = -(uint64_t)(int)a2[22];
        }
        else if (v26 == 2)
        {
          uint64_t v37 = (int)a2[22];
        }
        else
        {
          LODWORD(v37) = a2[22];
          if ((int)v37 >= 0) {
            uint64_t v37 = v37;
          }
          else {
            uint64_t v37 = -(int)v37;
          }
        }
        if (v27 == 3)
        {
          uint64_t v38 = -(uint64_t)(int)a3[22];
        }
        else if (v27 == 2)
        {
          uint64_t v38 = (int)a3[22];
        }
        else
        {
          LODWORD(v38) = a3[22];
          if ((int)v38 >= 0) {
            uint64_t v38 = v38;
          }
          else {
            uint64_t v38 = -(int)v38;
          }
        }
        if (v10 == v11)
        {
          if (v24 == 1 && v25 == 1)
          {
            switch(this[26])
            {
              case 0:
                if (v37 >= 1 && v38 >= 1) {
                  goto LABEL_111;
                }
                return this;
              case 1:
                goto LABEL_109;
              case 2:
                if (v10 == 1 && v37 >= 1 && v38 > 0) {
                  goto LABEL_111;
                }
                if (v10) {
                  return this;
                }
LABEL_109:
                if (v37 <= 0 && v38 <= 0) {
                  goto LABEL_111;
                }
                return this;
              case 3:
                goto LABEL_111;
              default:
                return this;
            }
          }
          int v39 = a2[19];
          a2[19] = a3[19];
          a3[19] = v39;
        }
        else
        {
LABEL_111:
          return (_DWORD *)ClipperLib::Clipper::AddLocalMinPoly((ClipperLib::Clipper *)this, (uint64_t)a2, (uint64_t)a3, a4);
        }
      }
      return this;
    }
    if (v24 > 1) {
      return this;
    }
LABEL_70:
    this = v7;
    a2 = a3;
LABEL_71:
    this = (_DWORD *)ClipperLib::Clipper::AddOutPt((ClipperLib::Clipper *)this, (uint64_t)a2, a4);
    int v31 = v6[19];
    v6[19] = a3[19];
    a3[19] = v31;
    int v32 = v6[23];
    v6[23] = a3[23];
    a3[23] = v32;
    return this;
  }
  if (v25 <= 1) {
    goto LABEL_71;
  }
  return this;
}

uint64_t ClipperLib::Clipper::DeleteFromAEL(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 120);
  uint64_t v3 = *(void *)(a2 + 128);
  if (*(_OWORD *)(a2 + 120) == 0)
  {
    if (*(void *)(result + 144) != a2) {
      return result;
    }
  }
  else if (v3)
  {
    *(void *)(v3 + 120) = v2;
    if (!v2) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  *(void *)(result + 144) = v2;
  if (v2) {
LABEL_7:
  }
    *(void *)(v2 + 128) = v3;
LABEL_8:
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  return result;
}

uint64_t ClipperLib::Clipper::DeleteFromSEL(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 136);
  uint64_t v3 = *(void *)(a2 + 144);
  if (*(_OWORD *)(a2 + 136) == 0)
  {
    if (*(void *)(result + 152) != a2) {
      return result;
    }
  }
  else if (v3)
  {
    *(void *)(v3 + 136) = v2;
    if (!v2) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  *(void *)(result + 152) = v2;
  if (v2) {
LABEL_7:
  }
    *(void *)(v2 + 144) = v3;
LABEL_8:
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  return result;
}

uint64_t ClipperLib::Clipper::SetHoleState(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 128);
  if (v3)
  {
    char v4 = 0;
    do
    {
      uint64_t v5 = *(unsigned int *)(v3 + 92);
      if ((v5 & 0x80000000) == 0)
      {
        if (*(_DWORD *)(v3 + 80))
        {
          v4 ^= 1u;
          if (!*(void *)(a3 + 8)) {
            *(void *)(a3 + 8) = *(void *)(*(void *)(result + 8) + 8 * v5);
          }
        }
      }
      uint64_t v3 = *(void *)(v3 + 128);
    }
    while (v3);
    if (v4) {
      *(unsigned char *)(a3 + 4) = 1;
    }
  }
  return result;
}

uint64_t ClipperLib::GetLowermostRec(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  char v4 = *(void **)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = *(void **)(a2 + 32);
    if (!v5) {
      goto LABEL_29;
    }
    goto LABEL_3;
  }
  int v9 = *(void **)(a1 + 24);
  int v10 = (void *)v9[3];
  if (v10 == v9)
  {
LABEL_41:
    char v4 = v9;
    *(void *)(a1 + 32) = v9;
    uint64_t v5 = *(void **)(a2 + 32);
    if (!v5) {
      goto LABEL_29;
    }
    goto LABEL_3;
  }
  int v11 = 0;
  do
  {
    uint64_t v12 = v10[2];
    uint64_t v13 = v9[2];
    if (v12 > v13)
    {
LABEL_7:
      int v11 = 0;
      int v9 = v10;
      goto LABEL_8;
    }
    if (v12 == v13)
    {
      uint64_t v14 = v10[1];
      uint64_t v15 = v9[1];
      if (v14 <= v15)
      {
        if (v14 < v15) {
          goto LABEL_7;
        }
        if ((void *)v10[3] != v9 && (void *)v10[4] != v9) {
          int v11 = v10;
        }
      }
    }
LABEL_8:
    int v10 = (void *)v10[3];
  }
  while (v10 != v9);
  if (!v11 || v11 == v9) {
    goto LABEL_41;
  }
  char v4 = v9;
  do
  {
    if (!ClipperLib::FirstIsBottomPt(v9, v11)) {
      char v4 = v11;
    }
    do
      int v11 = (void *)v11[3];
    while (v11[1] != v4[1] || v11[2] != v4[2]);
  }
  while (v11 != v9);
  *(void *)(v3 + 32) = v4;
  uint64_t v5 = *(void **)(a2 + 32);
  if (v5)
  {
LABEL_3:
    uint64_t v6 = v4[2];
    uint64_t v7 = v5[2];
    BOOL v8 = v6 < v7;
    if (v6 <= v7) {
      goto LABEL_57;
    }
    return v3;
  }
LABEL_29:
  uint64_t v17 = *(void **)(a2 + 24);
  int v18 = (void *)v17[3];
  if (v18 == v17)
  {
LABEL_56:
    uint64_t v5 = v17;
    *(void *)(a2 + 32) = v17;
    char v4 = *(void **)(v3 + 32);
    uint64_t v27 = v4[2];
    uint64_t v28 = v17[2];
    BOOL v8 = v27 < v28;
    if (v27 <= v28) {
      goto LABEL_57;
    }
    return v3;
  }
  uint64_t v19 = 0;
  while (2)
  {
    uint64_t v20 = v18[2];
    uint64_t v21 = v17[2];
    if (v20 > v21) {
      goto LABEL_31;
    }
    if (v20 != v21) {
      goto LABEL_32;
    }
    uint64_t v22 = v18[1];
    uint64_t v23 = v17[1];
    if (v22 > v23) {
      goto LABEL_32;
    }
    if (v22 < v23)
    {
LABEL_31:
      uint64_t v19 = 0;
      uint64_t v17 = v18;
      goto LABEL_32;
    }
    if ((void *)v18[3] != v17 && (void *)v18[4] != v17) {
      uint64_t v19 = v18;
    }
LABEL_32:
    int v18 = (void *)v18[3];
    if (v18 != v17) {
      continue;
    }
    break;
  }
  if (!v19 || v19 == v17) {
    goto LABEL_56;
  }
  uint64_t v5 = v17;
  do
  {
    if (!ClipperLib::FirstIsBottomPt(v17, v19)) {
      uint64_t v5 = v19;
    }
    do
      uint64_t v19 = (void *)v19[3];
    while (v19[1] != v5[1] || v19[2] != v5[2]);
  }
  while (v19 != v17);
  *(void *)(a2 + 32) = v5;
  char v4 = *(void **)(v3 + 32);
  uint64_t v25 = v4[2];
  uint64_t v26 = v5[2];
  BOOL v8 = v25 < v26;
  if (v25 > v26) {
    return v3;
  }
LABEL_57:
  if (!v8)
  {
    uint64_t v30 = v4[1];
    uint64_t v31 = v5[1];
    if (v30 < v31) {
      return v3;
    }
    if (v30 <= v31 && (void *)v4[3] != v4)
    {
      if ((void *)v5[3] != v5 && !ClipperLib::FirstIsBottomPt(v4, v5)) {
        return a2;
      }
      return v3;
    }
  }
  return a2;
}

BOOL ClipperLib::Param1RightOfParam2(uint64_t a1, uint64_t a2)
{
  do
    a1 = *(void *)(a1 + 8);
  while (a1 != a2 && a1 != 0);
  return a1 == a2;
}

int *ClipperLib::Clipper::GetOutRec(ClipperLib::Clipper *this, int a2)
{
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *(int **)(v2 + 8 * a2);
  do
  {
    __n128 result = v3;
    uint64_t v3 = *(int **)(v2 + 8 * *v3);
  }
  while (result != v3);
  return result;
}

void ClipperLib::Clipper::CreateOutRec(ClipperLib::Clipper *this)
{
}

void ClipperLib::Clipper::ProcessHorizontal(ClipperLib::Clipper *this, void *a2, int a3)
{
  uint64_t v3 = a2;
  uint64_t v5 = *a2;
  uint64_t v6 = a2[4];
  BOOL v7 = *a2 < v6;
  uint64_t v69 = a2;
  BOOL v8 = v7;
  if (v7) {
    uint64_t v9 = v5;
  }
  else {
    uint64_t v9 = v6;
  }
  if (v7) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = v5;
  }
  int v11 = a2;
  while (1)
  {
    uint64_t v12 = (uint64_t)v11;
    int v11 = (void *)v11[14];
    if (!v11) {
      break;
    }
    if (v11[7]) {
      goto LABEL_13;
    }
  }
  uint64_t v13 = *(void *)(v12 + 96);
  uint64_t v15 = *(void *)(v12 + 32);
  uint64_t v14 = *(void *)(v12 + 40);
  BOOL v16 = *(void *)(v13 + 32) == v15 && *(void *)(v13 + 40) == v14;
  if (v16 && !*(void *)(v13 + 112)
    || ((uint64_t v13 = *(void *)(v12 + 104), *(void *)(v13 + 32) == v15) ? (v17 = *(void *)(v13 + 40) == v14) : (v17 = 0),
        v17 && !*(void *)(v13 + 112)))
  {
    if (*(_DWORD *)(v13 + 92) == -2 || *(void *)(v13 + 120) == *(void *)(v13 + 128) && *(void *)(v13 + 56))
    {
LABEL_13:
      uint64_t v66 = 0;
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t v66 = v13;
LABEL_28:
  long long v65 = (void *)((char *)this + 144);
  while (1)
  {
    if (v8) {
      uint64_t v19 = 15;
    }
    else {
      uint64_t v19 = 16;
    }
    uint64_t v20 = v3[v19];
    while (v20)
    {
      uint64_t v22 = v20;
      uint64_t v23 = *(void *)(v20 + 16);
      if (v23 == v3[4])
      {
        uint64_t v24 = v3[14];
        if (v24)
        {
          if (*(double *)(v20 + 64) < *(double *)(v24 + 64)) {
            break;
          }
        }
      }
      if (v8) {
        uint64_t v25 = 120;
      }
      else {
        uint64_t v25 = 128;
      }
      uint64_t v20 = *(void *)(v20 + v25);
      if (v8)
      {
        if (v23 > v10) {
          break;
        }
        if (v3 == (void *)v12 && v22 == v66) {
          goto LABEL_87;
        }
        uint64_t v26 = v3[3];
        uint64_t v67 = v23;
        uint64_t v68 = v26;
        ClipperLib::Clipper::IntersectEdges(this, v3, (_DWORD *)v22, &v67);
        uint64_t v28 = (void *)v3[15];
        uint64_t v27 = (void *)v3[16];
        if (v28 != v27) {
          goto LABEL_61;
        }
      }
      else
      {
        if (v23 < v9) {
          break;
        }
        if (v3 == (void *)v12 && v22 == v66)
        {
LABEL_87:
          if ((*(_DWORD *)(v12 + 92) & 0x80000000) == 0)
          {
            ClipperLib::Clipper::AddOutPt(this, v12, (void *)(v12 + 32));
            int v33 = (uint64_t *)*((void *)this + 19);
            if (!v33) {
LABEL_120:
            }
              ClipperLib::Clipper::AddGhostJoin();
            while (1)
            {
              uint64_t v34 = *((unsigned int *)v33 + 23);
              if ((v34 & 0x80000000) == 0)
              {
                uint64_t v35 = *v69;
                uint64_t v36 = v69[4];
                uint64_t v37 = *v33;
                uint64_t v38 = v33[4];
                if (*v69 >= v36) {
                  uint64_t v39 = v69[4];
                }
                else {
                  uint64_t v39 = *v69;
                }
                if (*v69 <= v36) {
                  uint64_t v35 = v69[4];
                }
                if (v37 >= v38) {
                  uint64_t v40 = v33[4];
                }
                else {
                  uint64_t v40 = *v33;
                }
                if (v37 > v38) {
                  uint64_t v38 = *v33;
                }
                if (v39 < v38 && v40 < v35) {
                  break;
                }
              }
              int v33 = (uint64_t *)v33[17];
              if (!v33) {
                goto LABEL_120;
              }
            }
            unint64_t v42 = *(void **)(*(void *)(*((void *)this + 1) + 8 * v34) + 24);
            if (*((_DWORD *)v33 + 19) == 1)
            {
              if (v37 != v42[1] || v33[1] != v42[2]) {
                goto LABEL_118;
              }
            }
            else
            {
              uint64_t v44 = v42[4];
              if (v37 != *(void *)(v44 + 8) || v33[1] != *(void *)(v44 + 16)) {
LABEL_118:
              }
                operator new();
            }
            operator new();
          }
          uint64_t v51 = v3[15];
          uint64_t v52 = v3[16];
          float v50 = v3 + 15;
          if (*(_OWORD *)(v3 + 15) == 0)
          {
            if ((void *)*v65 == v3)
            {
              *long long v65 = v51;
              *float v50 = 0;
              v3[16] = 0;
              uint64_t v47 = *(void *)(v66 + 120);
              uint64_t v48 = *(void *)(v66 + 128);
              BOOL v46 = (void *)(v66 + 120);
              if (*(_OWORD *)(v66 + 120) == 0) {
                goto LABEL_133;
              }
            }
            else
            {
              uint64_t v47 = *(void *)(v66 + 120);
              uint64_t v48 = *(void *)(v66 + 128);
              BOOL v46 = (void *)(v66 + 120);
              if (*(_OWORD *)(v66 + 120) == 0) {
                goto LABEL_133;
              }
            }
          }
          else
          {
            long long v53 = (void *)(v52 + 120);
            if (!v52) {
              long long v53 = v65;
            }
            *long long v53 = v51;
            if (v51) {
              *(void *)(v51 + 128) = v52;
            }
            *float v50 = 0;
            v3[16] = 0;
            uint64_t v47 = *(void *)(v66 + 120);
            uint64_t v48 = *(void *)(v66 + 128);
            BOOL v46 = (void *)(v66 + 120);
            if (*(_OWORD *)(v66 + 120) == 0)
            {
LABEL_133:
              if (*v65 == v66)
              {
                *long long v65 = v47;
                goto LABEL_163;
              }
              return;
            }
          }
          uint64_t v49 = (void *)(v48 + 120);
          if (!v48) {
            uint64_t v49 = v65;
          }
          *uint64_t v49 = v47;
          if (v47) {
            *(void *)(v47 + 128) = v48;
          }
LABEL_163:
          *BOOL v46 = 0;
          v46[1] = 0;
          return;
        }
        uint64_t v29 = v3[3];
        uint64_t v67 = v23;
        uint64_t v68 = v29;
        ClipperLib::Clipper::IntersectEdges(this, (_DWORD *)v22, v3, &v67);
        uint64_t v28 = (void *)v3[15];
        uint64_t v27 = (void *)v3[16];
        if (v28 != v27)
        {
LABEL_61:
          uint64_t v31 = *(void **)(v22 + 120);
          uint64_t v30 = *(void **)(v22 + 128);
          if (v31 == v30) {
            continue;
          }
          if (v28 == (void *)v22)
          {
            if (v31)
            {
              v31[16] = v3;
              uint64_t v27 = (void *)v3[16];
            }
            if (v27) {
              v27[15] = v22;
            }
            *(void *)(v22 + 120) = v3;
            *(void *)(v22 + 128) = v27;
            v3[15] = v31;
            v3[16] = v22;
            int v32 = (void *)v22;
            if (*(void *)(v22 + 128)) {
              continue;
            }
            goto LABEL_43;
          }
          if (v31 == v3)
          {
            if (v28)
            {
              v28[16] = v22;
              uint64_t v30 = *(void **)(v22 + 128);
            }
            if (v30) {
              v30[15] = v3;
            }
            v3[15] = v22;
            v3[16] = v30;
            uint64_t v27 = v3;
            *(void *)(v22 + 120) = v28;
            *(void *)(v22 + 128) = v3;
            int v32 = v3;
            if (!v3[16]) {
              goto LABEL_43;
            }
          }
          else
          {
            v3[15] = v31;
            if (v31)
            {
              v31[16] = v3;
              uint64_t v30 = *(void **)(v22 + 128);
            }
            v3[16] = v30;
            if (v30) {
              v30[15] = v3;
            }
            *(void *)(v22 + 120) = v28;
            if (v28) {
              v28[16] = v22;
            }
            *(void *)(v22 + 128) = v27;
            if (v27) {
              v27[15] = v22;
            }
            int v32 = v3;
            if (!v3[16])
            {
LABEL_43:
              *long long v65 = v32;
              continue;
            }
          }
          int v32 = (void *)v22;
          if (v27) {
            continue;
          }
          goto LABEL_43;
        }
      }
    }
    uint64_t v21 = v3[14];
    if (!v21)
    {
      if ((*((_DWORD *)v3 + 23) & 0x80000000) == 0) {
        ClipperLib::Clipper::AddOutPt(this, (uint64_t)v3, v3 + 4);
      }
      uint64_t v54 = v3[15];
      uint64_t v55 = v3[16];
      if (*(_OWORD *)(v3 + 15) == 0)
      {
        if ((void *)*v65 != v3) {
          return;
        }
        *long long v65 = v54;
      }
      else
      {
        float v56 = (void *)(v55 + 120);
        if (!v55) {
          float v56 = v65;
        }
        *float v56 = v54;
        if (v54) {
          *(void *)(v54 + 128) = v55;
        }
      }
      BOOL v46 = v3 + 15;
      goto LABEL_163;
    }
    if (*(void *)(v21 + 56)) {
      break;
    }
    ClipperLib::Clipper::UpdateEdgeIntoAEL((uint64_t)this, (uint64_t *)&v69);
    uint64_t v3 = v69;
    if ((*((_DWORD *)v69 + 23) & 0x80000000) == 0) {
      ClipperLib::Clipper::AddOutPt(this, (uint64_t)v69, v69);
    }
    uint64_t v18 = v3[4];
    BOOL v8 = *v3 < v18;
    if (*v3 >= v18) {
      uint64_t v9 = v3[4];
    }
    else {
      uint64_t v9 = *v3;
    }
    if (*v3 <= v18) {
      uint64_t v10 = v3[4];
    }
    else {
      uint64_t v10 = *v3;
    }
  }
  if ((*((_DWORD *)v3 + 23) & 0x80000000) != 0)
  {
    ClipperLib::Clipper::UpdateEdgeIntoAEL((uint64_t)this, (uint64_t *)&v69);
    return;
  }
  ClipperLib::Clipper::AddOutPt(this, (uint64_t)v3, v3 + 4);
  if (a3) {
    ClipperLib::Clipper::AddGhostJoin();
  }
  ClipperLib::Clipper::UpdateEdgeIntoAEL((uint64_t)this, (uint64_t *)&v69);
  unint64_t v57 = v69;
  if (*((_DWORD *)v69 + 20))
  {
    uint64_t v58 = v69[15];
    uint64_t v59 = v69[16];
    if (v59
      && *(void *)(v59 + 16) == *v69
      && (uint64_t v60 = *(void *)(v59 + 24), v60 == v69[1])
      && *(_DWORD *)(v59 + 80)
      && (*(_DWORD *)(v59 + 92) & 0x80000000) == 0
      && v60 > *(void *)(v59 + 40)
      && ClipperLib::SlopesEqual((uint64_t)v69, v69[16], *((unsigned __int8 *)this + *(void *)(*(void *)this - 24) + 40)))
    {
      uint64_t v61 = this;
      uint64_t v62 = v59;
    }
    else
    {
      if (!v58) {
        return;
      }
      if (*(void *)(v58 + 16) != *v57) {
        return;
      }
      uint64_t v63 = *(void *)(v58 + 24);
      if (v63 != v57[1]
        || !*(_DWORD *)(v58 + 80)
        || (*(_DWORD *)(v58 + 92) & 0x80000000) != 0
        || v63 <= *(void *)(v58 + 40)
        || !ClipperLib::SlopesEqual((uint64_t)v57, v58, *((unsigned __int8 *)this + *(void *)(*(void *)this - 24) + 40)))
      {
        return;
      }
      uint64_t v61 = this;
      uint64_t v62 = v58;
    }
    ClipperLib::Clipper::AddOutPt(v61, v62, v57);
    ClipperLib::Clipper::AddJoin();
  }
}

uint64_t ClipperLib::GetMaximaPair(void *a1)
{
  uint64_t result = a1[12];
  uint64_t v4 = a1[4];
  uint64_t v3 = a1[5];
  BOOL v5 = *(void *)(result + 32) == v4 && *(void *)(result + 40) == v3;
  if (!v5 || *(void *)(result + 112))
  {
    uint64_t result = a1[13];
    BOOL v6 = *(void *)(result + 32) == v4 && *(void *)(result + 40) == v3;
    if (!v6 || *(void *)(result + 112)) {
      return 0;
    }
  }
  if (*(_DWORD *)(result + 92) == -2
    || *(void *)(result + 120) == *(void *)(result + 128) && *(void *)(result + 56))
  {
    return 0;
  }
  return result;
}

uint64_t ClipperLib::Clipper::SwapPositionsInAEL(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 120);
  uint64_t v3 = *(void *)(a2 + 128);
  if (v4 != v3)
  {
    uint64_t v6 = *(void *)(a3 + 120);
    uint64_t v5 = *(void *)(a3 + 128);
    if (v6 != v5)
    {
      if (v4 != a3)
      {
        if (v6 == a2)
        {
          if (v4)
          {
            *(void *)(v4 + 128) = a3;
            uint64_t v5 = *(void *)(a3 + 128);
          }
          if (v5) {
            *(void *)(v5 + 120) = a2;
          }
          *(void *)(a2 + 120) = a3;
          *(void *)(a2 + 128) = v5;
          uint64_t v3 = a2;
          *(void *)(a3 + 120) = v4;
          *(void *)(a3 + 128) = a2;
          if (!*(void *)(a2 + 128)) {
            goto LABEL_27;
          }
        }
        else
        {
          *(void *)(a2 + 120) = v6;
          if (v6)
          {
            *(void *)(v6 + 128) = a2;
            uint64_t v5 = *(void *)(a3 + 128);
          }
          *(void *)(a2 + 128) = v5;
          if (v5) {
            *(void *)(v5 + 120) = a2;
          }
          *(void *)(a3 + 120) = v4;
          if (v4) {
            *(void *)(v4 + 128) = a3;
          }
          *(void *)(a3 + 128) = v3;
          if (v3) {
            *(void *)(v3 + 120) = a3;
          }
          if (!*(void *)(a2 + 128)) {
            goto LABEL_27;
          }
        }
        a2 = a3;
        if (v3) {
          return result;
        }
LABEL_27:
        *(void *)(result + 144) = a2;
        return result;
      }
      if (v6)
      {
        *(void *)(v6 + 128) = a2;
        uint64_t v3 = *(void *)(a2 + 128);
      }
      if (v3) {
        *(void *)(v3 + 120) = a3;
      }
      *(void *)(a3 + 120) = a2;
      *(void *)(a3 + 128) = v3;
      *(void *)(a2 + 120) = v6;
      *(void *)(a2 + 128) = a3;
      a2 = a3;
      if (!*(void *)(a3 + 128)) {
        goto LABEL_27;
      }
    }
  }
  return result;
}

uint64_t ClipperLib::Clipper::SwapPositionsInSEL(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 136);
  if (v3 || *(void *)(a2 + 144))
  {
    uint64_t v4 = *(void *)(a3 + 136);
    if (v4)
    {
      if (v3 != a3)
      {
        if (v4 == a2)
        {
          if (v3) {
            *(void *)(v3 + 144) = a3;
          }
          uint64_t v9 = *(void *)(a3 + 144);
          if (v9) {
            *(void *)(v9 + 136) = a2;
          }
          *(void *)(a2 + 136) = a3;
          *(void *)(a2 + 144) = v9;
          *(void *)(a3 + 136) = v3;
          *(void *)(a3 + 144) = a2;
          if (!*(void *)(a2 + 144)) {
            goto LABEL_29;
          }
          goto LABEL_22;
        }
        uint64_t v5 = *(void *)(a2 + 144);
        *(void *)(v4 + 144) = a2;
        uint64_t v6 = (void *)(a3 + 144);
        uint64_t v7 = *(void *)(a3 + 144);
        *(void *)(a2 + 136) = v4;
        *(void *)(a2 + 144) = v7;
        if (!v7) {
          goto LABEL_12;
        }
        goto LABEL_11;
      }
      *(void *)(v4 + 144) = a2;
    }
    else
    {
      uint64_t v6 = (void *)(a3 + 144);
      uint64_t v7 = *(void *)(a3 + 144);
      if (!v7) {
        return result;
      }
      if (v3 != a3)
      {
        uint64_t v5 = *(void *)(a2 + 144);
        *(void *)(a2 + 136) = 0;
        *(void *)(a2 + 144) = v7;
LABEL_11:
        *(void *)(v7 + 136) = a2;
LABEL_12:
        *(void *)(a3 + 136) = v3;
        if (v3) {
          *(void *)(v3 + 144) = a3;
        }
        void *v6 = v5;
        if (v5)
        {
          *(void *)(v5 + 136) = a3;
          if (!*(void *)(a2 + 144)) {
            goto LABEL_29;
          }
LABEL_22:
          a2 = a3;
          if (*(void *)(a3 + 144)) {
            return result;
          }
LABEL_29:
          *(void *)(result + 152) = a2;
          return result;
        }
LABEL_21:
        if (!*(void *)(a2 + 144)) {
          goto LABEL_29;
        }
        goto LABEL_22;
      }
    }
    uint64_t v8 = *(void *)(a2 + 144);
    if (v8) {
      *(void *)(v8 + 136) = a3;
    }
    *(void *)(a3 + 136) = a2;
    *(void *)(a3 + 144) = v8;
    *(void *)(a2 + 136) = v4;
    *(void *)(a2 + 144) = a3;
    goto LABEL_21;
  }
  return result;
}

uint64_t ClipperLib::GetNextInAEL(uint64_t a1, int a2)
{
  uint64_t v2 = 128;
  if (a2 == 1) {
    uint64_t v2 = 120;
  }
  return *(void *)(a1 + v2);
}

uint64_t *ClipperLib::GetHorzDirection(uint64_t *result, int *a2, void *a3, void *a4)
{
  uint64_t v4 = *result;
  uint64_t v5 = result[4];
  BOOL v6 = *result < v5;
  if (*result >= v5) {
    uint64_t v4 = result[4];
  }
  *a3 = v4;
  if (v6) {
    uint64_t v7 = result + 4;
  }
  else {
    uint64_t v7 = result;
  }
  uint64_t v8 = *v7;
  int v9 = v6;
  *a4 = v8;
  *a2 = v9;
  return result;
}

void ClipperLib::Clipper::UpdateEdgeIntoAEL(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*a2 + 112);
  if (!v3)
  {
    exceptiouint64_t n = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
    ClipperLib::clipperException::clipperException(exception, "UpdateEdgeIntoAEL: invalid call");
  }
  *(_DWORD *)(v3 + 92) = *(_DWORD *)(v2 + 92);
  uint64_t v6 = v2 + 120;
  uint64_t v5 = *(void *)(v2 + 120);
  uint64_t v4 = *(void *)(v6 + 8);
  uint64_t v7 = (void *)(a1 + 144);
  if (v4) {
    uint64_t v7 = (void *)(v4 + 120);
  }
  void *v7 = v3;
  if (v5) {
    *(void *)(v5 + 128) = *(void *)(*a2 + 112);
  }
  uint64_t v8 = *(_OWORD **)(*a2 + 112);
  *(_OWORD *)((char *)v8 + 76) = *(_OWORD *)(*a2 + 76);
  *a2 = (uint64_t)v8;
  v8[1] = *v8;
  *(void *)(*a2 + 128) = v4;
  *(void *)(*a2 + 120) = v5;
  if (*(void *)(*a2 + 56))
  {
    uint64_t v10 = *(void *)(*a2 + 40);
    std::priority_queue<long long>::push(a1 + 112, &v10);
  }
}

void sub_235EF55BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t ClipperLib::Clipper::BuildIntersectList(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(void *)(this + 144);
  if (v2)
  {
    *(void *)(this + 152) = v2;
    do
    {
      while (1)
      {
        long long v5 = *(_OWORD *)(v2 + 120);
        *(_OWORD *)(v2 + 136) = v5;
        if (*(void *)(v2 + 40) != a2) {
          break;
        }
        *(void *)(v2 + 16) = *(void *)(v2 + 32);
        uint64_t v2 = v5;
        if (!(void)v5) {
          goto LABEL_9;
        }
      }
      double v3 = *(double *)(v2 + 64) * (double)(a2 - *(void *)(v2 + 8));
      if (v3 >= 0.0) {
        double v4 = 0.5;
      }
      else {
        double v4 = -0.5;
      }
      *(void *)(v2 + 16) = *(void *)v2 + (uint64_t)(v4 + v3);
      uint64_t v2 = v5;
    }
    while ((void)v5);
LABEL_9:
    uint64_t v6 = *(void **)(this + 152);
    uint64_t v7 = v6[17];
    if (v7)
    {
      do
      {
        long long v10 = 0uLL;
        if (v6[2] > *(void *)(v7 + 16))
        {
          ClipperLib::IntersectPoint((uint64_t)v6, v7, (uint64_t *)&v10);
          operator new();
        }
        uint64_t v6 = (void *)v7;
        uint64_t v7 = *(void *)(v7 + 136);
      }
      while (v7);
      uint64_t v8 = v6[18];
      if (v8) {
        *(void *)(v8 + 136) = 0;
      }
    }
    else
    {
      uint64_t v9 = v6[18];
      if (v9) {
        *(void *)(v9 + 136) = 0;
      }
    }
    *(void *)(this + 152) = 0;
  }
  return this;
}

BOOL ClipperLib::Clipper::FixupIntersectionOrder(ClipperLib::Clipper *this)
{
  uint64_t v2 = *((void *)this + 18);
  *((void *)this + 19) = v2;
  if (v2)
  {
    do
    {
      long long v3 = *(_OWORD *)(v2 + 120);
      *(_OWORD *)(v2 + 136) = v3;
      uint64_t v2 = v3;
    }
    while ((void)v3);
  }
  uint64_t v4 = *((void *)this + 10);
  long long v5 = (int8x16_t *)*((void *)this + 11);
  unint64_t v6 = 126 - 2 * __clz(((uint64_t)v5->i64 - v4) >> 3);
  uint64_t v27 = ClipperLib::IntersectListSort;
  if (v5 == (int8x16_t *)v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  BOOL v8 = 1;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(v4, v5, (unsigned int (**)(uint64_t))&v27, v7, 1);
  uint64_t v9 = *((void *)this + 11) - *((void *)this + 10);
  if (v9)
  {
    BOOL v8 = 0;
    unint64_t v10 = 0;
    unint64_t v11 = v9 >> 3;
    if ((unint64_t)(v9 >> 3) <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v9 >> 3;
    }
    unint64_t v13 = 1;
    do
    {
      if (v11 <= v13) {
        unint64_t v15 = v13;
      }
      else {
        unint64_t v15 = v11;
      }
      uint64_t v16 = *((void *)this + 10);
      BOOL v17 = *(uint64_t **)(v16 + 8 * v10);
      uint64_t v18 = *v17;
      uint64_t v19 = v17[1];
      uint64_t v14 = *(void *)(*v17 + 136);
      if (v14 != v19)
      {
        if (*(void *)(v18 + 144) == v19)
        {
          uint64_t v14 = v17[1];
        }
        else
        {
          unint64_t v20 = v13;
          unint64_t v21 = v10;
          while (1)
          {
            if (v20 >= v11)
            {
              unint64_t v21 = v15;
LABEL_24:
              if (v21 == v11) {
                return v8;
              }
              goto LABEL_27;
            }
            uint64_t v22 = *(uint64_t **)(v16 + 8 * v20);
            uint64_t v24 = *v22;
            uint64_t v23 = v22[1];
            if (*(void *)(v24 + 136) == v23) {
              break;
            }
            ++v20;
            ++v21;
            if (*(void *)(v24 + 144) == v23) {
              goto LABEL_24;
            }
          }
          unint64_t v21 = v20;
          if (v20 == v11) {
            return v8;
          }
LABEL_27:
          *(void *)(v16 + 8 * v10) = *(void *)(v16 + 8 * v21);
          *(void *)(v16 + 8 * v21) = v17;
          uint64_t v25 = *(uint64_t **)(*((void *)this + 10) + 8 * v10);
          uint64_t v18 = *v25;
          uint64_t v14 = v25[1];
        }
      }
      ClipperLib::Clipper::SwapPositionsInSEL((uint64_t)this, v18, v14);
      BOOL v8 = ++v10 >= v11;
      ++v13;
    }
    while (v10 != v12);
  }
  return v8;
}

uint64_t ClipperLib::Clipper::ProcessIntersectList(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 88);
  if (v2 != *(void *)(this + 80))
  {
    unint64_t v3 = 0;
    uint64_t v2 = *(void *)(this + 80);
    do
    {
      uint64_t v4 = *(void **)(v2 + 8 * v3);
      ClipperLib::Clipper::IntersectEdges((_DWORD *)v1, (_DWORD *)*v4, (_DWORD *)v4[1], v4 + 2);
      long long v5 = (_DWORD *)*v4;
      uint64_t v7 = *(void *)(*v4 + 120);
      unint64_t v6 = *(_DWORD **)(*v4 + 128);
      if ((_DWORD *)v7 == v6) {
        goto LABEL_4;
      }
      uint64_t v8 = v4[1];
      uint64_t v10 = *(void *)(v8 + 120);
      uint64_t v9 = *(void *)(v8 + 128);
      if (v10 == v9) {
        goto LABEL_4;
      }
      if (v7 == v8)
      {
        if (v10)
        {
          *(void *)(v10 + 128) = v5;
          unint64_t v6 = (_DWORD *)*((void *)v5 + 16);
        }
        if (v6) {
          *((void *)v6 + 15) = v8;
        }
        *(void *)(v8 + 120) = v5;
        *(void *)(v8 + 128) = v6;
        *((void *)v5 + 15) = v10;
        *((void *)v5 + 16) = v8;
        long long v5 = (_DWORD *)v8;
        if (*(void *)(v8 + 128)) {
          goto LABEL_4;
        }
      }
      else if ((_DWORD *)v10 == v5)
      {
        if (v7)
        {
          *(void *)(v7 + 128) = v8;
          uint64_t v9 = *(void *)(v8 + 128);
        }
        if (v9) {
          *(void *)(v9 + 120) = v5;
        }
        *((void *)v5 + 15) = v8;
        *((void *)v5 + 16) = v9;
        unint64_t v6 = v5;
        *(void *)(v8 + 120) = v7;
        *(void *)(v8 + 128) = v5;
        if (*((void *)v5 + 16))
        {
LABEL_18:
          long long v5 = (_DWORD *)v8;
          if (v6) {
            goto LABEL_4;
          }
        }
      }
      else
      {
        *((void *)v5 + 15) = v10;
        if (v10)
        {
          *(void *)(v10 + 128) = v5;
          uint64_t v9 = *(void *)(v8 + 128);
        }
        *((void *)v5 + 16) = v9;
        if (v9) {
          *(void *)(v9 + 120) = v5;
        }
        *(void *)(v8 + 120) = v7;
        if (v7) {
          *(void *)(v7 + 128) = v8;
        }
        *(void *)(v8 + 128) = v6;
        if (v6) {
          *((void *)v6 + 15) = v8;
        }
        if (*((void *)v5 + 16)) {
          goto LABEL_18;
        }
      }
      *(void *)(v1 + 144) = v5;
LABEL_4:
      this = MEMORY[0x237DF7CA0](v4, 0x1020C406C4767B9);
      ++v3;
      uint64_t v2 = *(void *)(v1 + 80);
    }
    while (v3 < (*(void *)(v1 + 88) - v2) >> 3);
  }
  *(void *)(v1 + 88) = v2;
  return this;
}

uint64_t ClipperLib::Clipper::DisposeIntersectNodes(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v3 = *(void *)(this + 80);
  uint64_t v2 = *(void *)(this + 88);
  if (v2 == v3)
  {
    uint64_t v3 = *(void *)(this + 88);
  }
  else
  {
    unint64_t v4 = 0;
    do
    {
      this = *(void *)(v3 + 8 * v4);
      if (this)
      {
        this = MEMORY[0x237DF7CA0](this, 0x1020C406C4767B9);
        uint64_t v3 = *(void *)(v1 + 80);
        uint64_t v2 = *(void *)(v1 + 88);
      }
      ++v4;
    }
    while (v4 < (v2 - v3) >> 3);
  }
  *(void *)(v1 + 88) = v3;
  return this;
}

BOOL ClipperLib::IntersectListSort(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24) < *(void *)(a1 + 24);
}

ClipperLib::Clipper *ClipperLib::Clipper::DoMaxima(ClipperLib::Clipper *this, uint64_t a2)
{
  uint64_t v3 = (uint64_t)this;
  long long v5 = (void *)(a2 + 32);
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v6 = *(void *)(a2 + 96);
  uint64_t v7 = *(void *)(a2 + 40);
  BOOL v8 = *(void *)(v6 + 32) == v4 && *(void *)(v6 + 40) == v7;
  if ((!v8 || *(void *)(v6 + 112))
    && ((v6 = *(void *)(a2 + 104), *(void *)(v6 + 32) == v4) ? (BOOL v9 = *(void *)(v6 + 40) == v7) : (BOOL v9 = 0),
        !v9 || *(void *)(v6 + 112))
    || *(_DWORD *)(v6 + 92) == -2
    || (uint64_t v12 = (void *)(v6 + 120), *(void *)(v6 + 120) == *(void *)(v6 + 128)) && *(void *)(v6 + 56))
  {
    if ((*(_DWORD *)(a2 + 92) & 0x80000000) == 0) {
      this = (ClipperLib::Clipper *)ClipperLib::Clipper::AddOutPt(this, a2, (void *)(a2 + 32));
    }
    uint64_t v11 = *(void *)(a2 + 120);
    uint64_t v10 = *(void *)(a2 + 128);
    uint64_t v12 = (void *)(a2 + 120);
    if (*(_OWORD *)(a2 + 120) == 0)
    {
      if (*(void *)(v3 + 144) == a2) {
        goto LABEL_93;
      }
      return this;
    }
    goto LABEL_17;
  }
  uint64_t v14 = (uint64_t *)(a2 + 120);
  uint64_t v13 = *(void *)(a2 + 120);
  BOOL v15 = v13 != 0;
  if (v13 && v13 != v6)
  {
    while (1)
    {
      this = (ClipperLib::Clipper *)ClipperLib::Clipper::IntersectEdges((_DWORD *)v3, (_DWORD *)a2, (_DWORD *)v13, v5);
      uint64_t v24 = *(void *)(a2 + 120);
      uint64_t v23 = *(void *)(a2 + 128);
      if (v24 != v23)
      {
        uint64_t v26 = *(void *)(v13 + 120);
        uint64_t v25 = *(void *)(v13 + 128);
        if (v26 != v25) {
          break;
        }
      }
LABEL_34:
      uint64_t v13 = *v14;
      BOOL v15 = *v14 != 0;
      if (*v14) {
        BOOL v22 = v13 == v6;
      }
      else {
        BOOL v22 = 1;
      }
      if (v22) {
        goto LABEL_25;
      }
    }
    if (v24 == v13)
    {
      if (v26)
      {
        *(void *)(v26 + 128) = a2;
        uint64_t v23 = *(void *)(a2 + 128);
      }
      if (v23) {
        *(void *)(v23 + 120) = v13;
      }
      *(void *)(v13 + 120) = a2;
      *(void *)(v13 + 128) = v23;
      *(void *)(a2 + 120) = v26;
      *(void *)(a2 + 128) = v13;
      uint64_t v27 = v13;
      if (*(void *)(v13 + 128)) {
        goto LABEL_34;
      }
      goto LABEL_33;
    }
    if (v26 == a2)
    {
      if (v24)
      {
        *(void *)(v24 + 128) = v13;
        uint64_t v25 = *(void *)(v13 + 128);
      }
      if (v25) {
        *(void *)(v25 + 120) = a2;
      }
      *(void *)(a2 + 120) = v13;
      *(void *)(a2 + 128) = v25;
      uint64_t v23 = a2;
      *(void *)(v13 + 120) = v24;
      *(void *)(v13 + 128) = a2;
      uint64_t v27 = a2;
      if (!*(void *)(a2 + 128)) {
        goto LABEL_33;
      }
    }
    else
    {
      *uint64_t v14 = v26;
      if (v26)
      {
        *(void *)(v26 + 128) = a2;
        uint64_t v25 = *(void *)(v13 + 128);
      }
      *(void *)(a2 + 128) = v25;
      if (v25) {
        *(void *)(v25 + 120) = a2;
      }
      *(void *)(v13 + 120) = v24;
      if (v24) {
        *(void *)(v24 + 128) = v13;
      }
      *(void *)(v13 + 128) = v23;
      if (v23) {
        *(void *)(v23 + 120) = v13;
      }
      uint64_t v27 = a2;
      if (!*(void *)(a2 + 128))
      {
LABEL_33:
        *(void *)(v3 + 144) = v27;
        goto LABEL_34;
      }
    }
    uint64_t v27 = v13;
    if (v23) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
LABEL_25:
  int v16 = *(_DWORD *)(a2 + 92);
  if (v16 == -1)
  {
    if (*(_DWORD *)(v6 + 92) != -1) {
      goto LABEL_96;
    }
    uint64_t v28 = *(void *)(a2 + 128);
    if (v28) {
      char v29 = 1;
    }
    else {
      char v29 = v15;
    }
    if (v29)
    {
      if (v28)
      {
        uint64_t v30 = (uint64_t *)(v28 + 120);
LABEL_80:
        *uint64_t v30 = v13;
        if (v15) {
          *(void *)(v13 + 128) = v28;
        }
        *uint64_t v14 = 0;
        *(void *)(a2 + 128) = 0;
LABEL_83:
        uint64_t v11 = *(void *)(v6 + 120);
        uint64_t v10 = *(void *)(v6 + 128);
        if (*(_OWORD *)(v6 + 120) == 0) {
          goto LABEL_92;
        }
LABEL_17:
        if (v10)
        {
          *(void *)(v10 + 120) = v11;
          if (!v11) {
            goto LABEL_95;
          }
          goto LABEL_94;
        }
LABEL_93:
        *(void *)(v3 + 144) = v11;
        if (!v11)
        {
LABEL_95:
          *uint64_t v12 = 0;
          v12[1] = 0;
          return this;
        }
LABEL_94:
        *(void *)(v11 + 128) = v10;
        goto LABEL_95;
      }
    }
    else if (*(void *)(v3 + 144) != a2)
    {
      goto LABEL_83;
    }
    uint64_t v30 = (uint64_t *)(v3 + 144);
    goto LABEL_80;
  }
  if (v16 < 0 || (*(_DWORD *)(v6 + 92) & 0x80000000) != 0)
  {
LABEL_96:
    exceptiouint64_t n = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
    ClipperLib::clipperException::clipperException(exception, "DoMaxima error");
  }
  this = (ClipperLib::Clipper *)ClipperLib::Clipper::AddOutPt((ClipperLib::Clipper *)v3, a2, v5);
  if (*(_DWORD *)(v6 + 80))
  {
    int v17 = *(_DWORD *)(a2 + 92);
    int v18 = *(_DWORD *)(v6 + 92);
    BOOL v19 = v17 < v18;
    if (v17 == v18) {
      goto LABEL_30;
    }
  }
  else
  {
    this = (ClipperLib::Clipper *)ClipperLib::Clipper::AddOutPt((ClipperLib::Clipper *)v3, v6, v5);
    int v31 = *(_DWORD *)(a2 + 92);
    int v32 = *(_DWORD *)(v6 + 92);
    BOOL v19 = v31 < v32;
    if (v31 == v32)
    {
LABEL_30:
      *(_DWORD *)(a2 + 92) = -1;
      *(_DWORD *)(v6 + 92) = -1;
      uint64_t v21 = *(void *)(a2 + 120);
      uint64_t v20 = *(void *)(a2 + 128);
      if (*(_OWORD *)(a2 + 120) == 0) {
        goto LABEL_31;
      }
      goto LABEL_86;
    }
  }
  if (v19)
  {
    uint64_t v33 = a2;
    uint64_t v34 = v6;
  }
  else
  {
    uint64_t v33 = v6;
    uint64_t v34 = a2;
  }
  this = (ClipperLib::Clipper *)ClipperLib::Clipper::AppendPolygon(v3, v33, v34);
  uint64_t v21 = *(void *)(a2 + 120);
  uint64_t v20 = *(void *)(a2 + 128);
  if (*(_OWORD *)(a2 + 120) == 0)
  {
LABEL_31:
    if (*(void *)(v3 + 144) == a2) {
      goto LABEL_88;
    }
    goto LABEL_83;
  }
LABEL_86:
  if (v20)
  {
    uint64_t v35 = (void *)(v20 + 120);
    goto LABEL_89;
  }
LABEL_88:
  uint64_t v35 = (void *)(v3 + 144);
LABEL_89:
  *uint64_t v35 = v21;
  if (v21) {
    *(void *)(v21 + 128) = v20;
  }
  *uint64_t v14 = 0;
  *(void *)(a2 + 128) = 0;
  uint64_t v11 = *(void *)(v6 + 120);
  uint64_t v10 = *(void *)(v6 + 128);
  if (*(_OWORD *)(v6 + 120) != 0) {
    goto LABEL_17;
  }
LABEL_92:
  if (*(void *)(v3 + 144) == v6) {
    goto LABEL_93;
  }
  return this;
}

void sub_235EF60B4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t ClipperLib::PointCount(uint64_t a1)
{
  uint64_t v1 = 0;
  if (a1)
  {
    uint64_t v2 = a1;
    do
    {
      uint64_t v1 = (v1 + 1);
      uint64_t v2 = *(void *)(v2 + 24);
    }
    while (v2 != a1);
  }
  return v1;
}

void std::vector<std::vector<ClipperLib::IntPoint>>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(char **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= a2) {
    return;
  }
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v4 = *(char **)(a1 + 8);
  uint64_t v5 = 24 * a2;
  uint64_t v6 = (char *)operator new(24 * a2);
  uint64_t v7 = &v6[v5];
  BOOL v8 = &v6[24 * ((v4 - v2) / 24)];
  if (v4 == v2)
  {
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = v7;
    if (!v2) {
      return;
    }
    goto LABEL_13;
  }
  BOOL v9 = &v6[24 * ((v4 - v2) / 24)];
  do
  {
    long long v10 = *(_OWORD *)(v4 - 24);
    v4 -= 24;
    *(_OWORD *)(v9 - 24) = v10;
    v9 -= 24;
    *((void *)v9 + 2) = *((void *)v4 + 2);
    *(void *)uint64_t v4 = 0;
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
  }
  while (v4 != v2);
  uint64_t v11 = *(char **)a1;
  uint64_t v2 = *(char **)(a1 + 8);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v8;
  *(void *)(a1 + 16) = v7;
  if (v2 != v11)
  {
    uint64_t v12 = v2;
    do
    {
      uint64_t v14 = (void *)*((void *)v12 - 3);
      v12 -= 24;
      uint64_t v13 = v14;
      if (v14)
      {
        *((void *)v2 - 2) = v13;
        operator delete(v13);
      }
      uint64_t v2 = v12;
    }
    while (v12 != v11);
    uint64_t v2 = v11;
  }
  if (v2)
  {
LABEL_13:
    operator delete(v2);
  }
}

__n128 ClipperLib::SwapIntersectNodes(long long *a1, uint64_t a2)
{
  long long v3 = *a1;
  long long v2 = a1[1];
  *a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  a1[1] = (__int128)result;
  *(_OWORD *)a2 = v3;
  *(_OWORD *)(a2 + 16) = v2;
  return result;
}

BOOL ClipperLib::GetOverlap(ClipperLib *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  if ((uint64_t)this >= a2)
  {
    if (a3 >= a4)
    {
      if (a2 <= a4) {
        uint64_t v14 = a4;
      }
      else {
        uint64_t v14 = a2;
      }
      *a5 = v14;
      if (a3 >= (uint64_t)this) {
        BOOL v15 = this;
      }
      else {
        BOOL v15 = (ClipperLib *)a3;
      }
      *a6 = (uint64_t)v15;
      return *a5 < (uint64_t)v15;
    }
    else
    {
      if (a2 <= a3) {
        uint64_t v10 = a3;
      }
      else {
        uint64_t v10 = a2;
      }
      *a5 = v10;
      if (a4 >= (uint64_t)this) {
        uint64_t v11 = this;
      }
      else {
        uint64_t v11 = (ClipperLib *)a4;
      }
      *a6 = (uint64_t)v11;
      return *a5 < (uint64_t)v11;
    }
  }
  else if (a3 >= a4)
  {
    if ((uint64_t)this <= a4) {
      uint64_t v12 = (ClipperLib *)a4;
    }
    else {
      uint64_t v12 = this;
    }
    *a5 = (uint64_t)v12;
    if (a3 >= a2) {
      uint64_t v13 = a2;
    }
    else {
      uint64_t v13 = a3;
    }
    *a6 = v13;
    return *a5 < v13;
  }
  else
  {
    if ((uint64_t)this <= a3) {
      uint64_t v7 = (ClipperLib *)a3;
    }
    else {
      uint64_t v7 = this;
    }
    *a5 = (uint64_t)v7;
    if (a4 >= a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = a4;
    }
    *a6 = v8;
    return *a5 < v8;
  }
}

void ClipperLib::DupOutPt()
{
}

uint64_t ClipperLib::JoinHorz(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = a1[1];
  uint64_t v7 = *(void *)(a2 + 8);
  int v8 = v6 <= v7;
  unsigned int v9 = *(void *)(a3 + 8) <= *(void *)(a4 + 8);
  if (v8 != v9)
  {
    if (v6 <= v7)
    {
      do
      {
        uint64_t v10 = a1;
        a1 = (void *)a1[3];
        uint64_t v11 = a1[1];
      }
      while (v11 <= a5 && v11 >= v10[1] && a1[2] == a6);
      operator new();
    }
    do
    {
      uint64_t v12 = a1;
      a1 = (void *)a1[3];
      uint64_t v13 = a1[1];
    }
    while (v13 >= a5 && v13 <= v12[1] && a1[2] == a6);
    operator new();
  }
  return v8 ^ v9;
}

uint64_t ClipperLib::Clipper::JoinPoints(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)*a2;
  uint64_t v6 = (void *)a2[1];
  uint64_t v7 = *(void *)(*a2 + 8);
  uint64_t v8 = *(void *)(*a2 + 16);
  uint64_t v9 = a2[3];
  if (v8 != v9)
  {
    unint64_t v42 = a1;
    uint64_t v43 = (uint64_t)(v5 + 3);
    do
    {
      uint64_t v44 = *(void **)v43;
      uint64_t v45 = *(void *)(*(void *)v43 + 8);
      uint64_t v46 = *(void *)(*(void *)v43 + 16);
      uint64_t v43 = *(void *)v43 + 24;
    }
    while (v44 != v5 && v45 == v7 && v46 == v8);
    if (v46 <= v8
      && (uint64_t v49 = *a1,
          uint64_t v88 = a2[2],
          uint64_t v51 = a2[3],
          v52 = ClipperLib::SlopesEqual(v7, v8, v45, v46, v88, v9, *((unsigned __int8 *)a1 + *(void *)(*a1 - 24) + 40)), uint64_t v9 = v51, v42 = a1, v52))
    {
      uint64_t v87 = v49;
      int v86 = 0;
    }
    else
    {
      uint64_t v44 = v5;
      do
      {
        uint64_t v44 = (void *)v44[4];
        uint64_t v53 = v44[1];
        uint64_t v54 = v44[2];
      }
      while (v44 != v5 && v53 == v7 && v54 == v8);
      if (v54 > v8) {
        return 0;
      }
      uint64_t v57 = a2[2];
      uint64_t v58 = *v42;
      uint64_t v59 = v9;
      uint64_t result = ClipperLib::SlopesEqual(v7, v8, v53, v54, v57, v9, *((unsigned __int8 *)v42 + *(void *)(*v42 - 24) + 40));
      if (!result) {
        return result;
      }
      uint64_t v87 = v58;
      uint64_t v88 = v57;
      int v86 = 1;
      uint64_t v9 = v59;
    }
    uint64_t v61 = v6[1];
    uint64_t v62 = (uint64_t)(v6 + 3);
    uint64_t v63 = v6[2];
    do
    {
      uint64_t v64 = *(void **)v62;
      uint64_t v65 = *(void *)(*(void *)v62 + 8);
      uint64_t v66 = *(void *)(*(void *)v62 + 16);
      uint64_t v62 = *(void *)v62 + 24;
    }
    while (v65 == v61 && v66 == v63 && v64 != v6);
    if (v66 <= v63
      && (int v69 = *((unsigned __int8 *)v42 + *(void *)(v87 - 24) + 40),
          unint64_t v70 = v42,
          uint64_t v71 = v9,
          BOOL v72 = ClipperLib::SlopesEqual(v61, v6[2], v65, v66, v88, v9, v69),
          uint64_t v9 = v71,
          unint64_t v42 = v70,
          v72))
    {
      int v73 = 0;
      uint64_t v74 = a3;
      uint64_t result = 0;
      if (v44 == v64) {
        return result;
      }
    }
    else
    {
      uint64_t v64 = v6;
      do
      {
        uint64_t v64 = (void *)v64[4];
        uint64_t v75 = v64[1];
        uint64_t v76 = v64[2];
      }
      while (v75 == v61 && v76 == v63 && v64 != v6);
      if (v76 > v63) {
        return 0;
      }
      uint64_t result = ClipperLib::SlopesEqual(v61, v63, v75, v76, v88, v9, *((unsigned __int8 *)v42 + *(void *)(v87 - 24) + 40));
      if (!result) {
        return result;
      }
      int v73 = 1;
      uint64_t v74 = a3;
      uint64_t result = 0;
      if (v44 == v64) {
        return result;
      }
    }
    if (v44 == v5 || v64 == v6) {
      return result;
    }
    if (v74 != a4 || v86 != v73) {
      operator new();
    }
    return 0;
  }
  uint64_t v10 = a2[2];
  uint64_t v11 = (void *)*a2;
  if (v10 == v7)
  {
    BOOL v12 = v10 == v6[1] && v8 == v6[2];
    uint64_t v11 = (void *)*a2;
    if (v12)
    {
      if (a3 == a4)
      {
        float v79 = (void *)*a2;
        while (1)
        {
          float v79 = (void *)v79[3];
          if (v79 == v5) {
            break;
          }
          uint64_t v80 = v79[2];
          if (v79[1] != v10 || v80 != v8) {
            goto LABEL_150;
          }
        }
        uint64_t v80 = *(void *)(*a2 + 16);
LABEL_150:
        uint64_t v82 = (void *)a2[1];
        do
        {
          uint64_t v82 = (void *)v82[3];
          if (v82 == v6)
          {
            if (v80 > v8) {
              goto LABEL_159;
            }
            return 0;
          }
          uint64_t v83 = v82[2];
        }
        while (v82[1] == v10 && v83 == v8);
        if (v80 > v8 == v83 <= v8) {
LABEL_159:
        }
          operator new();
      }
      return 0;
    }
  }
  do
  {
    uint64_t v13 = v11;
    uint64_t v11 = (void *)v11[4];
  }
  while (v11 != v5 && v11[2] == v8 && v11 != v6);
  int v16 = v13 + 2;
  do
  {
    uint64_t v17 = (uint64_t)v5;
    uint64_t v5 = (void *)v5[3];
  }
  while (v5 != v13 && v5[2] == v8 && v5 != v6);
  if (v5 == v13 || v5 == v6) {
    return 0;
  }
  uint64_t v21 = v6[2];
  BOOL v22 = v6;
  do
  {
    uint64_t v23 = (uint64_t)v22;
    BOOL v22 = (void *)v22[4];
  }
  while (v22 != (void *)v17 && v22[2] == v21 && v22 != v6);
  do
  {
    uint64_t v26 = (uint64_t)v6;
    uint64_t v6 = (void *)v6[3];
  }
  while (v6 != v13 && v6 != (void *)v23 && v6[2] == v21);
  if (v6 == (void *)v23 || v6 == v13) {
    return 0;
  }
  uint64_t v30 = v13[1];
  uint64_t v31 = *(void *)(v17 + 8);
  uint64_t v32 = *(void *)(v23 + 8);
  uint64_t v33 = *(void *)(v26 + 8);
  if (v31 <= v33) {
    uint64_t v34 = *(void *)(v26 + 8);
  }
  else {
    uint64_t v34 = *(void *)(v17 + 8);
  }
  if (v32 >= v30) {
    uint64_t v35 = v13[1];
  }
  else {
    uint64_t v35 = *(void *)(v23 + 8);
  }
  if (v31 <= v32) {
    uint64_t v36 = *(void *)(v23 + 8);
  }
  else {
    uint64_t v36 = *(void *)(v17 + 8);
  }
  if (v33 >= v30) {
    uint64_t v37 = v13[1];
  }
  else {
    uint64_t v37 = *(void *)(v26 + 8);
  }
  if (v32 < v33) {
    uint64_t v35 = v37;
  }
  else {
    uint64_t v36 = v34;
  }
  if (v30 <= v33) {
    uint64_t v38 = *(void *)(v26 + 8);
  }
  else {
    uint64_t v38 = v13[1];
  }
  if (v32 >= v31) {
    uint64_t v39 = *(void *)(v17 + 8);
  }
  else {
    uint64_t v39 = *(void *)(v23 + 8);
  }
  if (v30 <= v32) {
    uint64_t v40 = *(void *)(v23 + 8);
  }
  else {
    uint64_t v40 = v13[1];
  }
  if (v33 >= v31) {
    uint64_t v41 = *(void *)(v17 + 8);
  }
  else {
    uint64_t v41 = *(void *)(v26 + 8);
  }
  if (v32 < v33) {
    uint64_t v39 = v41;
  }
  else {
    uint64_t v40 = v38;
  }
  if (v30 < v31)
  {
    uint64_t v36 = v40;
    uint64_t v35 = v39;
  }
  if (v36 >= v35) {
    return 0;
  }
  if (v30 < v36 || v30 > v35)
  {
    if (v32 < v36 || v32 > v35)
    {
      if (v31 < v36 || v31 > v35)
      {
        int v16 = (uint64_t *)(v26 + 16);
      }
      else
      {
        int v16 = (uint64_t *)(v17 + 16);
        uint64_t v33 = *(void *)(v17 + 8);
      }
    }
    else
    {
      int v16 = (uint64_t *)(v23 + 16);
      uint64_t v33 = *(void *)(v23 + 8);
    }
  }
  else
  {
    uint64_t v33 = v13[1];
  }
  uint64_t v85 = *v16;
  *a2 = v13;
  a2[1] = v23;

  return ClipperLib::JoinHorz(v13, v17, v23, v26, v33, v85);
}

uint64_t ClipperLib::Clipper::FixupFirstLefts1(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v4 = *(void *)(result + 16);
  uint64_t v5 = v4 - v3;
  if (v4 == v3) {
    return result;
  }
  uint64_t v6 = 0;
  unint64_t v7 = v5 >> 3;
  if (v7 <= 1) {
    unint64_t v7 = 1;
  }
  while (2)
  {
    uint64_t v8 = *(void *)(v3 + 8 * v6);
    uint64_t v9 = *(void **)(v8 + 24);
    if (!v9) {
      goto LABEL_7;
    }
    uint64_t v10 = *(void *)(v8 + 8);
    if (!v10) {
      goto LABEL_7;
    }
    do
    {
      if (*(void *)(v10 + 24)) {
        break;
      }
      uint64_t v10 = *(void *)(v10 + 8);
    }
    while (v10);
    if (v10 != a2) {
      goto LABEL_7;
    }
    uint64_t v11 = *(void **)(v8 + 24);
    while (2)
    {
      int v12 = 0;
      uint64_t result = v11[1];
      uint64_t v13 = v11[2];
      uint64_t v14 = *(void **)(a3 + 24);
      while (1)
      {
        BOOL v15 = v14;
        uint64_t v14 = (void *)v14[3];
        uint64_t v16 = v14[2];
        if (v16 == v13)
        {
          uint64_t v17 = v14[1];
          if (v17 == result) {
            goto LABEL_33;
          }
          uint64_t v18 = v15[2];
          if (v18 == v13)
          {
            if (v17 <= result != v15[1] < result) {
              goto LABEL_33;
            }
            goto LABEL_16;
          }
          uint64_t v19 = v18 - v13;
          uint64_t v20 = v16 - v13;
          if (v16 < v13 != v18 >= v13) {
            goto LABEL_16;
          }
        }
        else
        {
          uint64_t v18 = v15[2];
          uint64_t v19 = v18 - v13;
          uint64_t v20 = v16 - v13;
          if (v16 < v13 != v18 >= v13) {
            goto LABEL_16;
          }
        }
        uint64_t v21 = v15[1];
        uint64_t v22 = v14[1];
        BOOL v23 = v21 < result;
        uint64_t v24 = v21 - result;
        if (!v23) {
          break;
        }
        BOOL v23 = v22 <= result;
        uint64_t v25 = v22 - result;
        if (!v23) {
          goto LABEL_29;
        }
LABEL_16:
        if (v14 == *(void **)(a3 + 24))
        {
          if (!v12) {
            goto LABEL_7;
          }
          goto LABEL_6;
        }
      }
      BOOL v23 = v22 <= result;
      uint64_t v25 = v22 - result;
      if (!v23)
      {
        int v12 = 1 - v12;
        goto LABEL_16;
      }
LABEL_29:
      double v26 = -((double)v25 * (double)v19 - (double)v24 * (double)v20);
      if (v26 != 0.0)
      {
        if (v16 > v18 != v26 <= 0.0) {
          int v12 = 1 - v12;
        }
        goto LABEL_16;
      }
LABEL_33:
      uint64_t v11 = (void *)v11[3];
      if (v11 != v9) {
        continue;
      }
      break;
    }
LABEL_6:
    *(void *)(v8 + 8) = a3;
LABEL_7:
    if (++v6 != v7) {
      continue;
    }
    return result;
  }
}

uint64_t ClipperLib::Clipper::FixupFirstLefts2(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v4 = *(void *)(result + 16) - v3;
  if (v4)
  {
    unint64_t v5 = v4 >> 3;
    if (v5 <= 1) {
      unint64_t v5 = 1;
    }
    do
    {
      if (*(void *)(*(void *)v3 + 8) == a2) {
        *(void *)(*(void *)v3 + 8) = a3;
      }
      v3 += 8;
      --v5;
    }
    while (v5);
  }
  return result;
}

double ClipperLib::GetUnitNormal(void *a1, void *a2)
{
  uint64_t v2 = a2[1];
  uint64_t v3 = a1[1];
  BOOL v4 = *a2 == *a1 && v2 == v3;
  double result = 0.0;
  if (!v4) {
    return 1.0
  }
         / sqrt((double)(uint64_t)(*a2 - *a1) * (double)(uint64_t)(*a2 - *a1) + (double)(v2 - v3) * (double)(v2 - v3))
         * (double)(v2 - v3);
  return result;
}

double ClipperLib::ClipperOffset::ClipperOffset(ClipperLib::ClipperOffset *this, double a2, double a3)
{
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 22) = &unk_26E9431E0;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 229) = 0u;
  *(double *)this = a2;
  *((double *)this + 1) = a3;
  double result = NAN;
  *((_OWORD *)this + 10) = xmmword_235F1F150;
  return result;
}

void ClipperLib::ClipperOffset::~ClipperOffset(ClipperLib::ClipperOffset *this)
{
  BOOL v4 = (char *)this + 208;
  uint64_t v2 = (void *)*((void *)this + 26);
  uint64_t v3 = *((void *)v4 + 1);
  if ((int)((unint64_t)(v3 - (void)v2) >> 3) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v2[v5];
      if (v6)
      {
        (*(void (**)(void))(*(void *)v6 + 8))(v2[v5]);
        uint64_t v2 = (void *)*((void *)this + 26);
        uint64_t v3 = *((void *)this + 27);
      }
      ++v5;
    }
    while (v5 < (int)((unint64_t)(v3 - (void)v2) >> 3));
  }
  *((void *)this + 27) = v2;
  *((void *)this + 20) = -1;
  *((void *)this + 22) = &unk_26E9431E0;
  if (v2) {
    operator delete(v2);
  }
  unint64_t v7 = (void *)*((void *)this + 23);
  if (v7)
  {
    *((void *)this + 24) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 11);
  if (v8)
  {
    *((void *)this + 12) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 8);
  if (v9)
  {
    *((void *)this + 9) = v9;
    operator delete(v9);
  }
  uint64_t v10 = (void *)*((void *)this + 5);
  if (v10)
  {
    *((void *)this + 6) = v10;
    operator delete(v10);
  }
  uint64_t v11 = *((void *)this + 2);
  if (v11)
  {
    uint64_t v12 = *((void *)this + 3);
    uint64_t v13 = (void *)*((void *)this + 2);
    if (v12 != v11)
    {
      uint64_t v14 = *((void *)this + 3);
      do
      {
        uint64_t v16 = *(void **)(v14 - 24);
        v14 -= 24;
        BOOL v15 = v16;
        if (v16)
        {
          *(void *)(v12 - 16) = v15;
          operator delete(v15);
        }
        uint64_t v12 = v14;
      }
      while (v14 != v11);
      uint64_t v13 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v11;
    operator delete(v13);
  }
}

void *ClipperLib::ClipperOffset::Clear(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[26];
  uint64_t v3 = this[27];
  if ((int)((unint64_t)(v3 - v2) >> 3) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      this = *(void **)(v2 + 8 * v4);
      if (this)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v2 = v1[26];
        uint64_t v3 = v1[27];
      }
      ++v4;
    }
    while (v4 < (int)((unint64_t)(v3 - v2) >> 3));
  }
  v1[27] = v2;
  v1[20] = -1;
  return this;
}

void ClipperLib::PolyNode::~PolyNode(ClipperLib::PolyNode *this)
{
  *(void *)this = &unk_26E9431E0;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26E9431E0;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }

  JUMPOUT(0x237DF7CA0);
}

void ClipperLib::ClipperOffset::AddPath(uint64_t a1, void *a2)
{
  if ((int)((a2[1] - *a2) >> 4) >= 1) {
    operator new();
  }
}

void ClipperLib::ClipperOffset::AddPaths(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      ClipperLib::ClipperOffset::AddPath(a1, (void *)(v2 + v5));
      ++v6;
      uint64_t v2 = *a2;
      v5 += 24;
    }
    while (v6 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
}

void *ClipperLib::ClipperOffset::FixOrientations(void *this)
{
  uint64_t v1 = this[20];
  if (v1 < 0)
  {
    uint64_t v2 = this[26];
    goto LABEL_26;
  }
  uint64_t v2 = this[26];
  uint64_t v4 = (uint64_t *)(*(void *)(v2 + 8 * (int)v1) + 8);
  uint64_t v3 = *v4;
  unint64_t v5 = v4[1] - *v4;
  if ((int)(v5 >> 4) < 3) {
    goto LABEL_26;
  }
  uint64_t v6 = 0;
  uint64_t v7 = (v5 >> 4) - 1;
  uint64_t v8 = (v5 >> 4);
  double v9 = 0.0;
  do
  {
    float64x2_t v10 = vcvtq_f64_s64(*(int64x2_t *)(v3 + 16 * (int)v7));
    float64x2_t v11 = vcvtq_f64_s64(*(int64x2_t *)(v3 + 16 * v6));
    double v9 = vmulq_laneq_f64(vaddq_f64(v10, v11), vsubq_f64(v10, v11), 1).f64[0] + v9;
    LODWORD(v7) = v6++;
  }
  while (v8 != v6);
  if (v9 * -0.5 >= 0.0)
  {
LABEL_26:
    uint64_t v28 = this[27];
    if ((int)((unint64_t)(v28 - v2) >> 3) >= 1)
    {
      uint64_t v29 = 0;
      do
      {
        uint64_t v30 = *(void *)(v2 + 8 * v29);
        if (*(_DWORD *)(v30 + 76) == 1)
        {
          uint64_t v33 = v30 + 8;
          unint64_t v31 = *(void *)(v30 + 8);
          uint64_t v32 = *(void *)(v33 + 8);
          unint64_t v34 = (v32 - v31) >> 4;
          if ((int)v34 >= 3)
          {
            uint64_t v35 = 0;
            int v36 = v34 - 1;
            double v37 = 0.0;
            do
            {
              float64x2_t v38 = vcvtq_f64_s64(*(int64x2_t *)(v31 + 16 * v36));
              float64x2_t v39 = vcvtq_f64_s64(*(int64x2_t *)(v31 + 16 * v35));
              double v37 = vmulq_laneq_f64(vaddq_f64(v38, v39), vsubq_f64(v38, v39), 1).f64[0] + v37;
              int v36 = v35++;
            }
            while (((v32 - v31) >> 4) != v35);
            if (v37 * -0.5 < 0.0 && v31 != v32)
            {
              uint64_t v40 = (_OWORD *)(v32 - 16);
              if ((unint64_t)v40 > v31)
              {
                unint64_t v41 = v31 + 16;
                do
                {
                  long long v42 = *(_OWORD *)(v41 - 16);
                  *(_OWORD *)(v41 - 16) = *v40;
                  *v40-- = v42;
                  BOOL v27 = v41 >= (unint64_t)v40;
                  v41 += 16;
                }
                while (!v27);
                uint64_t v2 = this[26];
                uint64_t v28 = this[27];
              }
            }
          }
        }
        ++v29;
      }
      while (v29 < (int)((unint64_t)(v28 - v2) >> 3));
    }
    return this;
  }
  uint64_t v12 = this[27];
  if ((int)((unint64_t)(v12 - v2) >> 3) >= 1)
  {
    for (uint64_t i = 0; i < (int)((unint64_t)(v12 - v2) >> 3); ++i)
    {
      uint64_t v14 = *(void *)(v2 + 8 * i);
      int v15 = *(_DWORD *)(v14 + 76);
      if (v15 == 1)
      {
        unint64_t v16 = *(void *)(v14 + 8);
        uint64_t v17 = *(void *)(v14 + 16);
        unint64_t v18 = (v17 - v16) >> 4;
        if ((int)v18 < 3) {
          goto LABEL_16;
        }
        uint64_t v19 = 0;
        int v20 = v18 - 1;
        double v21 = 0.0;
        do
        {
          float64x2_t v22 = vcvtq_f64_s64(*(int64x2_t *)(v16 + 16 * v20));
          float64x2_t v23 = vcvtq_f64_s64(*(int64x2_t *)(v16 + 16 * v19));
          double v21 = vmulq_laneq_f64(vaddq_f64(v22, v23), vsubq_f64(v22, v23), 1).f64[0] + v21;
          int v20 = v19++;
        }
        while (((v17 - v16) >> 4) != v19);
        if (v21 * -0.5 >= 0.0) {
          goto LABEL_16;
        }
      }
      else if (!v15)
      {
        unint64_t v16 = *(void *)(v14 + 8);
        uint64_t v17 = *(void *)(v14 + 16);
LABEL_16:
        uint64_t v24 = (_OWORD *)(v17 - 16);
        if (v16 != v17 && (unint64_t)v24 > v16)
        {
          unint64_t v26 = v16 + 16;
          do
          {
            long long v43 = *(_OWORD *)(v26 - 16);
            *(_OWORD *)(v26 - 16) = *v24;
            *v24-- = v43;
            BOOL v27 = v26 >= (unint64_t)v24;
            v26 += 16;
          }
          while (!v27);
          uint64_t v2 = this[26];
          uint64_t v12 = this[27];
        }
      }
    }
  }
  return this;
}

__n128 ClipperLib::ReversePath(unint64_t *a1)
{
  unint64_t v1 = *a1;
  unint64_t v2 = a1[1];
  uint64_t v3 = (_OWORD *)(v2 - 16);
  if (*a1 != v2 && (unint64_t)v3 > v1)
  {
    unint64_t v5 = v1 + 16;
    do
    {
      __n128 result = *(__n128 *)(v5 - 16);
      *(_OWORD *)(v5 - 16) = *v3;
      *v3-- = result;
      BOOL v7 = v5 >= (unint64_t)v3;
      v5 += 16;
    }
    while (!v7);
  }
  return result;
}

void ClipperLib::ClipperOffset::Execute(ClipperLib::ClipperOffset *this, uint64_t *a2, double a3)
{
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  if (v6 != *a2)
  {
    uint64_t v8 = a2[1];
    do
    {
      float64x2_t v10 = *(void **)(v8 - 24);
      v8 -= 24;
      double v9 = v10;
      if (v10)
      {
        *(void *)(v6 - 16) = v9;
        operator delete(v9);
      }
      uint64_t v6 = v8;
    }
    while (v8 != v7);
  }
  a2[1] = v7;
  ClipperLib::ClipperOffset::FixOrientations(this);
  ClipperLib::ClipperOffset::DoOffset(this, a3);
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  uint64_t v44 = &unk_26E943250;
  uint64_t v59 = &unk_26E943298;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  char v62 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v53 = 0;
  char v56 = 0;
  char v57 = 0;
  char v58 = 0;
  __int16 v66 = 0;
  uint64_t v11 = *((void *)this + 2);
  if (*((void *)this + 3) != v11)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      ClipperLib::ClipperBase::AddPath((uint64_t)&v59, v11 + v12, 0, 1);
      ++v13;
      uint64_t v11 = *((void *)this + 2);
      v12 += 24;
    }
    while (v13 < 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 3) - v11) >> 3));
  }
  if (a3 <= 0.0)
  {
    uint64_t v14 = (char *)&v44 + *(v44 - 3);
    uint64_t v15 = *((void *)v14 + 2);
    uint64_t v16 = *((void *)v14 + 3);
    if (v15 == v16)
    {
      uint64_t v33 = -10;
      uint64_t v31 = 10;
      uint64_t v32 = 10;
      uint64_t v30 = -10;
    }
    else
    {
      uint64_t v17 = *(uint64_t **)(v15 + 8);
      uint64_t v19 = *v17;
      uint64_t v18 = v17[1];
      uint64_t v20 = v19;
      uint64_t v21 = v18;
      do
      {
        float64x2_t v22 = *(uint64_t **)(v15 + 8);
        float64x2_t v23 = v22;
        do
        {
          uint64_t v28 = (uint64_t *)v23[14];
          if (v28)
          {
            uint64_t v29 = v23;
            do
            {
              uint64_t v24 = v28;
              if (*v29 < v19) {
                uint64_t v19 = *v29;
              }
              if (*v29 > v20) {
                uint64_t v20 = *v29;
              }
              uint64_t v28 = (uint64_t *)v28[14];
              uint64_t v29 = v24;
            }
            while (v28);
          }
          else
          {
            uint64_t v24 = v23;
          }
          if (*v24 < v19) {
            uint64_t v19 = *v24;
          }
          if (v20 <= *v24) {
            uint64_t v20 = *v24;
          }
          uint64_t v26 = v24[4];
          uint64_t v25 = v24[5];
          if (v26 < v19) {
            uint64_t v19 = v26;
          }
          if (v20 <= v26) {
            uint64_t v20 = v26;
          }
          if (v25 < v21) {
            uint64_t v21 = v25;
          }
          BOOL v27 = v23 == v22;
          float64x2_t v23 = *(uint64_t **)(v15 + 16);
        }
        while (v27);
        if (v18 <= v22[1]) {
          uint64_t v18 = v22[1];
        }
        v15 += 24;
      }
      while (v15 != v16);
      uint64_t v30 = v19 - 10;
      uint64_t v31 = v18 + 10;
      uint64_t v32 = v20 + 10;
      uint64_t v33 = v21 - 10;
    }
    unint64_t v34 = operator new(0x40uLL);
    v43[1] = v34 + 8;
    v43[2] = v34 + 8;
    v43[0] = v34;
    *unint64_t v34 = v30;
    v34[1] = v31;
    void v34[2] = v32;
    v34[3] = v31;
    v34[4] = v32;
    v34[5] = v33;
    v34[6] = v30;
    v34[7] = v33;
    ClipperLib::ClipperBase::AddPath((uint64_t)v14, (uint64_t)v43, 0, 1);
    char v57 = 1;
    ClipperLib::Clipper::Execute((uint64_t)&v44, 1, a2, 3, 3);
    uint64_t v35 = *a2;
    uint64_t v36 = a2[1];
    if (v36 == *a2) {
      goto LABEL_53;
    }
    if (v35 + 24 == v36)
    {
      if (v36 == v35)
      {
LABEL_52:
        a2[1] = v35;
LABEL_53:
        operator delete(v34);
        goto LABEL_54;
      }
    }
    else
    {
      do
      {
        float64x2_t v39 = *(void **)v35;
        if (*(void *)v35)
        {
          *(void *)(v35 + 8) = v39;
          operator delete(v39);
          *(void *)(v35 + 8) = 0;
          *(void *)(v35 + 16) = 0;
        }
        uint64_t v37 = v35 + 24;
        *(_OWORD *)uint64_t v35 = *(_OWORD *)(v35 + 24);
        *(void *)(v35 + 16) = *(void *)(v35 + 40);
        *(void *)(v35 + 32) = 0;
        *(void *)(v35 + 40) = 0;
        *(void *)(v35 + 24) = 0;
        uint64_t v38 = v35 + 48;
        v35 += 24;
      }
      while (v38 != v36);
      uint64_t v36 = a2[1];
      uint64_t v35 = v37;
      if (v36 == v37) {
        goto LABEL_52;
      }
    }
    uint64_t v40 = v36;
    do
    {
      long long v42 = *(void **)(v40 - 24);
      v40 -= 24;
      unint64_t v41 = v42;
      if (v42)
      {
        *(void *)(v36 - 16) = v41;
        operator delete(v41);
      }
      uint64_t v36 = v40;
    }
    while (v40 != v35);
    goto LABEL_52;
  }
  ClipperLib::Clipper::Execute((uint64_t)&v44, 1, a2, 2, 2);
LABEL_54:
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&v44);
}

void sub_235EF7FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)va);
  _Unwind_Resume(a1);
}

void sub_235EF7FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)va);
  _Unwind_Resume(a1);
}

void sub_235EF7FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  operator delete(v13);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&a13);
  _Unwind_Resume(a1);
}

void sub_235EF7FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)va);
  _Unwind_Resume(a1);
}

void ClipperLib::ClipperOffset::DoOffset(ClipperLib::ClipperOffset *this, double a2)
{
  uint64_t v3 = *((void *)this + 2);
  int v300 = (char **)((char *)this + 16);
  uint64_t v4 = *((void *)this + 3);
  double v316 = a2;
  if (v4 != v3)
  {
    uint64_t v5 = *((void *)this + 3);
    do
    {
      uint64_t v7 = *(void **)(v5 - 24);
      v5 -= 24;
      uint64_t v6 = v7;
      if (v7)
      {
        *(void *)(v4 - 16) = v6;
        operator delete(v6);
        a2 = v316;
      }
      uint64_t v4 = v5;
    }
    while (v5 != v3);
  }
  *((void *)this + 3) = v3;
  *((double *)this + 14) = a2;
  if (a2 > -1.0e-20 && a2 < 1.0e-20)
  {
    std::vector<std::vector<ClipperLib::IntPoint>>::reserve((uint64_t)v300, (int)((uint64_t)(*((void *)this + 27) - *((void *)this + 26)) >> 3));
    uint64_t v9 = *((void *)this + 26);
    uint64_t v8 = *((void *)this + 27);
    if ((int)((unint64_t)(v8 - v9) >> 3) >= 1)
    {
      uint64_t v10 = 0;
      do
      {
        uint64_t v12 = *(void *)(v9 + 8 * v10);
        if (!*(_DWORD *)(v12 + 76))
        {
          unint64_t v13 = (void *)*((void *)this + 3);
          if ((unint64_t)v13 >= *((void *)this + 4))
          {
            uint64_t v11 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>(v300, v12 + 8);
          }
          else
          {
            *unint64_t v13 = 0;
            v13[1] = 0;
            v13[2] = 0;
            uint64_t v15 = *(unsigned char **)(v12 + 8);
            uint64_t v14 = *(unsigned char **)(v12 + 16);
            int64_t v16 = v14 - v15;
            if (v14 != v15)
            {
              if (v16 < 0) {
                _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
              }
              uint64_t v17 = (char *)operator new(v14 - v15);
              *unint64_t v13 = v17;
              v13[1] = v17;
              uint64_t v18 = &v17[16 * (v16 >> 4)];
              v13[2] = v18;
              memcpy(v17, v15, v16);
              v13[1] = v18;
            }
            uint64_t v11 = (char *)(v13 + 3);
            *((void *)this + 3) = v13 + 3;
          }
          *((void *)this + 3) = v11;
          uint64_t v9 = *((void *)this + 26);
          uint64_t v8 = *((void *)this + 27);
        }
        ++v10;
      }
      while (v10 < (int)((unint64_t)(v8 - v9) >> 3));
    }
    return;
  }
  double v19 = *((double *)this + 1);
  double v20 = 2.0 / (*(double *)this * *(double *)this);
  if (*(double *)this <= 2.0) {
    double v20 = 0.5;
  }
  *((double *)this + 18) = v20;
  double v21 = fabs(a2);
  double v22 = 0.25;
  double v23 = fmin(v19, v21 * 0.25);
  if (v19 > 0.0) {
    double v22 = v23;
  }
  double v24 = fmin(3.14159265 / acos(1.0 - v22 / v21), v21 * 3.14159265);
  __double2 v25 = __sincos_stret(6.28318531 / v24);
  *((__double2 *)this + 8) = v25;
  *((double *)this + 19) = v24 * 0.159154943;
  if (v316 < 0.0) {
    *((double *)this + 16) = -v25.__sinval;
  }
  std::vector<std::vector<ClipperLib::IntPoint>>::reserve((uint64_t)v300, (int)((uint64_t)(*((void *)this + 27) - *((void *)this + 26)) >> 2) & 0xFFFFFFFFFFFFFFFELL);
  uint64_t v26 = *((void *)this + 26);
  if ((int)((unint64_t)(*((void *)this + 27) - v26) >> 3) >= 1)
  {
    uint64_t v27 = 0;
    uint64_t v28 = (void *)((char *)this + 40);
    v299 = (int64x2_t **)((char *)this + 64);
    float64x2_t v298 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v316, 0);
    v315 = (float64x2_t **)((char *)this + 88);
    __asm
    {
      FMOV            V1.2D, #0.5
      FMOV            V0.2D, #-0.5
    }
    int8x16_t v313 = _Q0;
    int8x16_t v314 = _Q1;
    while (1)
    {
      uint64_t v33 = *(void *)(v26 + 8 * v27);
      if (v28 != (void *)(v33 + 8)) {
        std::vector<ClipperLib::IntPoint>::__assign_with_size[abi:ne180100]<ClipperLib::IntPoint*,ClipperLib::IntPoint*>(v28, *(char **)(v33 + 8), *(char **)(v33 + 16), (uint64_t)(*(void *)(v33 + 16) - *(void *)(v33 + 8)) >> 4);
      }
      unint64_t v34 = (int64x2_t *)*((void *)this + 5);
      uint64_t v35 = *((void *)this + 6) - (void)v34;
      unint64_t v36 = (unint64_t)v35 >> 4;
      if (!((unint64_t)v35 >> 4)) {
        goto LABEL_28;
      }
      if (v316 <= 0.0) {
        break;
      }
      uint64_t v37 = (int64x2_t *)*((void *)this + 8);
      *((void *)this + 9) = v37;
      if (v36 != 1) {
        goto LABEL_58;
      }
      if (*(_DWORD *)(v33 + 72) != 1)
      {
        float64x2_t v102 = vsubq_f64(vcvtq_f64_s64(*v34), v298);
        int64x2_t v103 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v102), v313, v314), v102));
        int64_t v104 = (int64x2_t *)*((void *)this + 10);
        if (v37 >= v104)
        {
          int64x2_t v307 = v103;
          uint64_t v120 = (char *)v104 - (char *)v37;
          uint64_t v121 = v120 >> 3;
          if ((unint64_t)(v120 >> 3) <= 1) {
            uint64_t v121 = 1;
          }
          _CF = (unint64_t)v120 >= 0x7FFFFFFFFFFFFFF0;
          unint64_t v122 = 0xFFFFFFFFFFFFFFFLL;
          if (!_CF) {
            unint64_t v122 = v121;
          }
          if (v122 >> 60) {
LABEL_412:
          }
            std::__throw_bad_array_new_length[abi:ne180100]();
          uint64_t v123 = v122;
          v124 = (int64x2_t *)operator new(16 * v122);
          int64_t v104 = &v124[v123];
          int64x2_t *v124 = v307;
          uint64_t v105 = v124 + 1;
          *((void *)this + 8) = v124;
          *((void *)this + 9) = v124 + 1;
          *((void *)this + 10) = &v124[v123];
          if (v37)
          {
            operator delete(v37);
            unint64_t v34 = (int64x2_t *)*((void *)this + 5);
            int64_t v104 = (int64x2_t *)*((void *)this + 10);
          }
        }
        else
        {
          *uint64_t v37 = v103;
          uint64_t v105 = v37 + 1;
        }
        *((void *)this + 9) = v105;
        float64x2_t v125 = vcvtq_f64_s64(*v34);
        *(void *)&v126.f64[0] = *(_OWORD *)&vaddq_f64(v298, v125);
        v126.f64[1] = vsubq_f64(v125, v298).f64[1];
        int64x2_t v127 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v126), v313, v314), v126));
        if (v105 < v104)
        {
          *uint64_t v105 = v127;
          int64_t v128 = v105 + 1;
          uint64_t v38 = (int64x2_t **)((char *)this + 64);
          goto LABEL_248;
        }
        uint64_t v38 = (int64x2_t **)((char *)this + 64);
        uint64_t v129 = *v299;
        uint64_t v130 = v105 - *v299;
        unint64_t v131 = v130 + 1;
        if ((unint64_t)(v130 + 1) >> 60) {
          goto LABEL_413;
        }
        uint64_t v132 = (char *)v104 - (char *)v129;
        if (v132 >> 3 > v131) {
          unint64_t v131 = v132 >> 3;
        }
        if ((unint64_t)v132 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v133 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v133 = v131;
        }
        if (v133)
        {
          int64x2_t v308 = v127;
          if (v133 >> 60) {
            goto LABEL_412;
          }
          BOOL v134 = (char *)operator new(16 * v133);
          uint64_t v38 = (int64x2_t **)((char *)this + 64);
          unint64_t v135 = (int64x2_t *)&v134[16 * v130];
          int64_t v104 = (int64x2_t *)&v134[16 * v133];
          *unint64_t v135 = v308;
          int64_t v128 = v135 + 1;
          if (v105 == v129)
          {
LABEL_246:
            *((void *)this + 8) = v135;
            *((void *)this + 9) = v128;
            *((void *)this + 10) = v104;
            goto LABEL_247;
          }
        }
        else
        {
          unint64_t v135 = (int64x2_t *)(16 * v130);
          int64_t v104 = 0;
          *(int64x2_t *)(16 * v130) = v127;
          int64_t v128 = (int64x2_t *)(16 * v130 + 16);
          if (v105 == v129) {
            goto LABEL_246;
          }
        }
        do
        {
          v135[-1] = v105[-1];
          --v135;
          --v105;
        }
        while (v105 != v129);
        uint64_t v105 = (int64x2_t *)*((void *)this + 8);
        *((void *)this + 8) = v135;
        *((void *)this + 9) = v128;
        *((void *)this + 10) = v104;
        if (v105)
        {
LABEL_247:
          operator delete(v105);
          int64_t v104 = (int64x2_t *)*((void *)this + 10);
        }
LABEL_248:
        *((void *)this + 9) = v128;
        float64x2_t v198 = vaddq_f64(v298, vcvtq_f64_s64(*(int64x2_t *)*((void *)this + 5)));
        int64x2_t v199 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v198), v313, v314), v198));
        if (v128 < v104)
        {
          int64x2_t *v128 = v199;
          uint64_t v200 = v128 + 1;
          goto LABEL_266;
        }
        uint64_t v201 = *v38;
        uint64_t v202 = v128 - *v38;
        unint64_t v203 = v202 + 1;
        if ((unint64_t)(v202 + 1) >> 60) {
          goto LABEL_413;
        }
        uint64_t v204 = (char *)v104 - (char *)v201;
        if (v204 >> 3 > v203) {
          unint64_t v203 = v204 >> 3;
        }
        if ((unint64_t)v204 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v205 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v205 = v203;
        }
        if (v205)
        {
          int64x2_t v309 = v199;
          if (v205 >> 60) {
            goto LABEL_412;
          }
          unint64_t v206 = (char *)operator new(16 * v205);
          uint64_t v38 = (int64x2_t **)((char *)this + 64);
          uint64_t v207 = (int64x2_t *)&v206[16 * v202];
          int64_t v104 = (int64x2_t *)&v206[16 * v205];
          *uint64_t v207 = v309;
          uint64_t v200 = v207 + 1;
          if (v128 == v201)
          {
LABEL_264:
            *((void *)this + 8) = v207;
            *((void *)this + 9) = v200;
            *((void *)this + 10) = v104;
            goto LABEL_265;
          }
        }
        else
        {
          uint64_t v207 = (int64x2_t *)(16 * v202);
          int64_t v104 = 0;
          *(int64x2_t *)(16 * v202) = v199;
          uint64_t v200 = (int64x2_t *)(16 * v202 + 16);
          if (v128 == v201) {
            goto LABEL_264;
          }
        }
        do
        {
          v207[-1] = v128[-1];
          --v207;
          --v128;
        }
        while (v128 != v201);
        int64_t v128 = (int64x2_t *)*((void *)this + 8);
        *((void *)this + 8) = v207;
        *((void *)this + 9) = v200;
        *((void *)this + 10) = v104;
        if (v128)
        {
LABEL_265:
          operator delete(v128);
          int64_t v104 = (int64x2_t *)*((void *)this + 10);
        }
LABEL_266:
        *((void *)this + 9) = v200;
        float64x2_t v208 = vcvtq_f64_s64(*(int64x2_t *)*((void *)this + 5));
        *(void *)&v209.f64[0] = *(_OWORD *)&vsubq_f64(v208, v298);
        v209.f64[1] = vaddq_f64(v298, v208).f64[1];
        int64x2_t v210 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v209), v313, v314), v209));
        if (v200 < v104)
        {
          *uint64_t v200 = v210;
          int8x8_t v211 = v200 + 1;
LABEL_284:
          *((void *)this + 9) = v211;
          goto LABEL_285;
        }
        uint64_t v212 = *v38;
        uint64_t v213 = v200 - *v38;
        unint64_t v214 = v213 + 1;
        if ((unint64_t)(v213 + 1) >> 60) {
LABEL_413:
        }
          _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
        uint64_t v215 = (char *)v104 - (char *)v212;
        if (v215 >> 3 > v214) {
          unint64_t v214 = v215 >> 3;
        }
        if ((unint64_t)v215 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v216 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v216 = v214;
        }
        if (v216)
        {
          int64x2_t v310 = v210;
          if (v216 >> 60) {
            goto LABEL_412;
          }
          unint64_t v217 = (char *)operator new(16 * v216);
          uint64_t v38 = (int64x2_t **)((char *)this + 64);
          float v218 = (int64x2_t *)&v217[16 * v213];
          char v219 = &v217[16 * v216];
          *float v218 = v310;
          int8x8_t v211 = v218 + 1;
          if (v200 == v212)
          {
LABEL_282:
            *((void *)this + 8) = v218;
            *((void *)this + 9) = v211;
            *((void *)this + 10) = v219;
LABEL_283:
            operator delete(v200);
            goto LABEL_284;
          }
        }
        else
        {
          float v218 = (int64x2_t *)(16 * v213);
          char v219 = 0;
          uint64_t v220 = (int64x2_t *)(16 * v213);
          *uint64_t v220 = v210;
          int8x8_t v211 = v220 + 1;
          if (v200 == v212) {
            goto LABEL_282;
          }
        }
        do
        {
          v218[-1] = v200[-1];
          --v218;
          --v200;
        }
        while (v200 != v212);
        uint64_t v200 = (int64x2_t *)*((void *)this + 8);
        *((void *)this + 8) = v218;
        *((void *)this + 9) = v211;
        *((void *)this + 10) = v219;
        if (!v200) {
          goto LABEL_284;
        }
        goto LABEL_283;
      }
      uint64_t v38 = (int64x2_t **)((char *)this + 64);
      if (v24 >= 1.0)
      {
        uint64_t v39 = 1;
        float64x2_t v40 = (float64x2_t)xmmword_235F1F160;
        while (1)
        {
          float64x2_t v44 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)*((void *)this + 5)), v40, v316);
          int64x2_t v45 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v44), v313, v314), v44));
          unint64_t v46 = *((void *)this + 10);
          if ((unint64_t)v37 >= v46) {
            break;
          }
          *uint64_t v37 = v45;
          unint64_t v41 = v37 + 1;
LABEL_38:
          float64x2_t v42 = vmulq_n_f64((float64x2_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 8uLL), *((double *)this + 16));
          float64x2_t v43 = vmulq_n_f64(v40, *((double *)this + 17));
          *(void *)&v40.f64[0] = *(_OWORD *)&vsubq_f64(v43, v42);
          v40.f64[1] = vaddq_f64(v43, v42).f64[1];
          *((void *)this + 9) = v41;
          ++v39;
          uint64_t v37 = v41;
          if (v24 < (double)v39) {
            goto LABEL_285;
          }
        }
        long long v47 = *v299;
        uint64_t v48 = v37 - *v299;
        unint64_t v49 = v48 + 1;
        if ((unint64_t)(v48 + 1) >> 60) {
          goto LABEL_413;
        }
        uint64_t v50 = v46 - (void)v47;
        if (v50 >> 3 > v49) {
          unint64_t v49 = v50 >> 3;
        }
        if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v51 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v51 = v49;
        }
        float64x2_t v305 = v40;
        if (v51)
        {
          int64x2_t v301 = v45;
          if (v51 >> 60) {
            goto LABEL_412;
          }
          uint64_t v52 = (char *)operator new(16 * v51);
          float64x2_t v40 = v305;
          uint64_t v53 = (int64x2_t *)&v52[16 * v48];
          *uint64_t v53 = v301;
          unint64_t v41 = v53 + 1;
          if (v37 == v47) {
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v52 = 0;
          uint64_t v53 = (int64x2_t *)(16 * v48);
          uint64_t v54 = (int64x2_t *)(16 * v48);
          *uint64_t v54 = v45;
          unint64_t v41 = v54 + 1;
          if (v37 == v47) {
            goto LABEL_53;
          }
        }
        do
        {
          v53[-1] = v37[-1];
          --v53;
          --v37;
        }
        while (v37 != v47);
        uint64_t v37 = *v299;
LABEL_53:
        *((void *)this + 8) = v53;
        *((void *)this + 9) = v41;
        *((void *)this + 10) = &v52[16 * v51];
        if (v37)
        {
          operator delete(v37);
          float64x2_t v40 = v305;
        }
        goto LABEL_38;
      }
LABEL_285:
      int v142 = (char *)*((void *)this + 3);
      if ((unint64_t)v142 < *((void *)this + 4))
      {
        *(void *)int v142 = 0;
        *((void *)v142 + 1) = 0;
        *((void *)v142 + 2) = 0;
        uint64_t v144 = (unsigned char *)*((void *)this + 8);
        long long v143 = (unsigned char *)*((void *)this + 9);
        int64_t v145 = v143 - v144;
        uint64_t v28 = (void *)((char *)this + 40);
        if (v143 != v144)
        {
          if (v145 < 0) {
            _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
          }
          goto LABEL_288;
        }
LABEL_289:
        *((void *)this + 3) = v142 + 24;
        *((void *)this + 3) = v142 + 24;
        goto LABEL_28;
      }
      *((void *)this + 3) = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>(v300, (uint64_t)v38);
      uint64_t v28 = (void *)((char *)this + 40);
LABEL_28:
      ++v27;
      uint64_t v26 = *((void *)this + 26);
      if (v27 >= (int)((unint64_t)(*((void *)this + 27) - v26) >> 3)) {
        return;
      }
    }
    if ((int)v36 < 3 || *(_DWORD *)(v33 + 76)) {
      goto LABEL_28;
    }
    *((void *)this + 9) = *((void *)this + 8);
LABEL_58:
    uint64_t v55 = (void *)*((void *)this + 11);
    *((void *)this + 12) = v55;
    uint64_t v56 = v35 << 28;
    uint64_t v306 = v35;
    unint64_t v57 = (int)(v35 >> 4);
    if (v57 > (uint64_t)(*((void *)this + 13) - (void)v55) >> 4)
    {
      if (v56 < 0) {
        goto LABEL_411;
      }
      char v58 = (char *)operator new(v35 & 0xFFFFFFFFFLL);
      *((void *)this + 11) = v58;
      *((void *)this + 12) = v58;
      *((void *)this + 13) = &v58[16 * v57];
      if (v55) {
        operator delete(v55);
      }
    }
    uint64_t v302 = v56;
    uint64_t v59 = (v36 - 1);
    unsigned int v297 = v36 - 2;
    if ((int)v36 >= 2)
    {
      for (uint64_t i = 0; i != v59; ++i)
      {
        char v62 = (uint64_t *)(*v28 + 16 * i);
        uint64_t v64 = v62[2];
        uint64_t v63 = v62[3];
        uint64_t v66 = *v62;
        uint64_t v65 = v62[1];
        double v67 = 0.0;
        uint64_t v68 = v64 - v66;
        if (v68) {
          _ZF = 0;
        }
        else {
          _ZF = v63 == v65;
        }
        double v70 = 0.0;
        if (!_ZF)
        {
          double v71 = (double)(v63 - v65);
          double v72 = 1.0 / sqrt((double)v68 * (double)v68 + v71 * v71);
          double v70 = v72 * v71;
          double v67 = -((double)v68 * v72);
        }
        uint64_t v74 = (double *)*((void *)this + 12);
        unint64_t v73 = *((void *)this + 13);
        if ((unint64_t)v74 < v73)
        {
          *uint64_t v74 = v70;
          v74[1] = v67;
          long long v61 = v74 + 2;
        }
        else
        {
          uint64_t v75 = *v315;
          uint64_t v76 = ((char *)v74 - (char *)*v315) >> 4;
          unint64_t v77 = v76 + 1;
          if ((unint64_t)(v76 + 1) >> 60) {
            goto LABEL_411;
          }
          uint64_t v78 = v73 - (void)v75;
          if (v78 >> 3 > v77) {
            unint64_t v77 = v78 >> 3;
          }
          if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v79 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v79 = v77;
          }
          if (v79)
          {
            if (v79 >> 60) {
              goto LABEL_412;
            }
            uint64_t v80 = (char *)operator new(16 * v79);
            uint64_t v81 = (double *)&v80[16 * v76];
            *uint64_t v81 = v70;
            v81[1] = v67;
            uint64_t v82 = (uint64_t)v81;
            if (v74 != (double *)v75)
            {
LABEL_81:
              uint64_t v28 = (void *)((char *)this + 40);
              do
              {
                *(_OWORD *)(v82 - 16) = *((_OWORD *)v74 - 1);
                v82 -= 16;
                v74 -= 2;
              }
              while (v74 != (double *)v75);
              uint64_t v74 = (double *)*v315;
              uint64_t v83 = &v80[16 * v79];
              long long v61 = v81 + 2;
              *((void *)this + 11) = v82;
              *((void *)this + 12) = v81 + 2;
              *((void *)this + 13) = v83;
              if (!v74) {
                goto LABEL_65;
              }
LABEL_87:
              operator delete(v74);
              goto LABEL_65;
            }
          }
          else
          {
            uint64_t v80 = 0;
            uint64_t v81 = (double *)(16 * v76);
            *uint64_t v81 = v70;
            v81[1] = v67;
            uint64_t v82 = 16 * v76;
            if (v74 != (double *)v75) {
              goto LABEL_81;
            }
          }
          uint64_t v28 = (void *)((char *)this + 40);
          float v84 = &v80[16 * v79];
          long long v61 = v81 + 2;
          *((void *)this + 11) = v82;
          *((void *)this + 12) = v81 + 2;
          *((void *)this + 13) = v84;
          if (v74) {
            goto LABEL_87;
          }
        }
LABEL_65:
        *((void *)this + 12) = v61;
      }
    }
    if (*(_DWORD *)(v33 + 76) >= 2u)
    {
      float v97 = (float64x2_t *)*((void *)this + 11);
      float v99 = (char *)*((void *)this + 12);
      float v100 = (_OWORD *)((char *)v97->f64 + ((v302 - 0x200000000) >> 28));
      v317[0] = *v100;
      unint64_t v101 = *((void *)this + 13);
      uint64_t v93 = (int64x2_t **)((char *)this + 64);
      if ((unint64_t)v99 < v101)
      {
        *(_OWORD *)float v99 = *v100;
        float v98 = (float64x2_t *)(v99 + 16);
        goto LABEL_152;
      }
      uint64_t v115 = (v99 - (char *)v97) >> 4;
      unint64_t v116 = v115 + 1;
      if ((unint64_t)(v115 + 1) >> 60) {
LABEL_411:
      }
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      uint64_t v117 = v101 - (void)v97;
      if (v117 >> 3 > v116) {
        unint64_t v116 = v117 >> 3;
      }
      if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v118 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v118 = v116;
      }
      if (v118)
      {
        if (v118 >> 60) {
          goto LABEL_412;
        }
        uint64_t v119 = (char *)operator new(16 * v118);
      }
      else
      {
        uint64_t v119 = 0;
      }
      float v137 = (float64x2_t *)&v119[16 * v115];
      uint64_t v138 = &v119[16 * v118];
      *float v137 = (float64x2_t)v317[0];
      float v98 = v137 + 1;
      if (v99 == (char *)v97)
      {
        *((void *)this + 11) = v137;
        *((void *)this + 12) = v98;
        *((void *)this + 13) = v138;
        uint64_t v28 = (void *)((char *)this + 40);
      }
      else
      {
        uint64_t v28 = (void *)((char *)this + 40);
        do
        {
          v137[-1] = *((float64x2_t *)v99 - 1);
          --v137;
          v99 -= 16;
        }
        while (v99 != (char *)v97);
        float v97 = (float64x2_t *)*((void *)this + 11);
        *((void *)this + 11) = v137;
        *((void *)this + 12) = v98;
        *((void *)this + 13) = v138;
        if (!v97)
        {
LABEL_152:
          *((void *)this + 12) = v98;
          int v139 = *(_DWORD *)(v33 + 76);
          unint64_t v140 = v306;
          if (v139 != 1)
          {
            if (!v139)
            {
              LODWORD(v317[0]) = v36 - 1;
              if ((int)v36 >= 1)
              {
                int v141 = 0;
                do
                  ClipperLib::ClipperOffset::OffsetPoint(this, v141++, (int *)v317, *(_DWORD *)(v33 + 72));
                while (v36 != v141);
              }
              int v142 = (char *)*((void *)this + 3);
              if ((unint64_t)v142 >= *((void *)this + 4)) {
                goto LABEL_405;
              }
              *(void *)int v142 = 0;
              *((void *)v142 + 1) = 0;
              *((void *)v142 + 2) = 0;
              uint64_t v144 = (unsigned char *)*((void *)this + 8);
              long long v143 = (unsigned char *)*((void *)this + 9);
              int64_t v145 = v143 - v144;
              if (v143 == v144) {
                goto LABEL_289;
              }
              if (v145 < 0) {
                _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
              }
              goto LABEL_288;
            }
            LODWORD(v317[0]) = 0;
            if ((int)v36 >= 3)
            {
              int v153 = 2;
              do
                ClipperLib::ClipperOffset::OffsetPoint(this, v153++ - 1, (int *)v317, *(_DWORD *)(v33 + 72));
              while (v36 != v153);
              int v139 = *(_DWORD *)(v33 + 76);
              unint64_t v140 = v306;
            }
            if (v139 != 2)
            {
              *((void *)this + 15) = 0;
              *(float64x2_t *)(*((void *)this + 11) + 16 * (int)v59) = vnegq_f64(*(float64x2_t *)(*((void *)this + 11) + 16 * (int)v59));
              int v164 = v36 - 1;
              if (v139 == 3) {
                ClipperLib::ClipperOffset::DoSquare(this, v164, v297);
              }
              else {
                ClipperLib::ClipperOffset::DoRound(this, v164, v297);
              }
LABEL_315:
              if ((int)v36 < 2) {
                goto LABEL_319;
              }
              uint64_t v236 = *v315;
              unint64_t v237 = (v140 >> 4) - 1;
              if (v237 < 0x36) {
                goto LABEL_317;
              }
              unint64_t v246 = &v236->f64[1];
              uint64_t v247 = 16 * (v59 - 1);
              uint64_t v248 = v59;
              unint64_t v249 = (unint64_t)&v236[v59].f64[1];
              if (v249 - v247 > v249) {
                goto LABEL_317;
              }
              if (&v236[v248 + v247 / 0xFFFFFFFFFFFFFFF0] > &v236[v248]) {
                goto LABEL_317;
              }
              uint64_t v250 = 2 * (v36 - 2);
              if (&v236[(unint64_t)v250 / 2 + v247 / 0xFFFFFFFFFFFFFFF0] > &v236[(unint64_t)v250 / 2]
                || &v246[v250 + v247 / 0xFFFFFFFFFFFFFFF8] > &v246[v250])
              {
                goto LABEL_317;
              }
              uint64_t v251 = (v140 + 0xFFFFFFFE0) & 0xFFFFFFFF0;
              uint64_t v252 = v236 + 1;
              unint64_t v253 = (unint64_t)&v236[1] + v251 - v248 * 16;
              unint64_t v254 = (unint64_t)v246 + v251;
              unint64_t v255 = (unint64_t)&v236[1].f64[1];
              unint64_t v256 = (unint64_t)&v236[v248 + 1];
              unint64_t v257 = (unint64_t)v246 + v251 - v248 * 16 + 16;
              unint64_t v258 = (unint64_t)&v236[1] + v251;
              BOOL v259 = v253 >= v256 || v255 >= v254;
              BOOL v260 = !v259;
              BOOL v261 = v257 >= v249 || (unint64_t)v252 >= v258;
              BOOL v262 = !v261;
              BOOL v263 = v257 >= v256 || v255 >= v258;
              BOOL v264 = !v263;
              BOOL v265 = (unint64_t)v252 >= v256 || v255 >= v249;
              BOOL v266 = !v265;
              BOOL v267 = (unint64_t)v252 >= v254 || v253 >= v249;
              if (!v267 || v260 || v262 || v264 || v266)
              {
LABEL_317:
                unint64_t v238 = (v36 - 1);
              }
              else
              {
                unint64_t v238 = v59 - (v237 & 0xFFFFFFFFFFFFFFFELL);
                v268 = &v236[v248 - 1];
                uint64_t v269 = v59 + 0xFFFFFFFFLL;
                unint64_t v270 = v237 & 0xFFFFFFFFFFFFFFFELL;
                do
                {
                  f64 = v236[v269 - 1].f64;
                  float64x2x2_t v318 = vld2q_f64(f64);
                  float64x2_t *v268 = vnegq_f64((float64x2_t)vzip1q_s64((int64x2_t)v318.val[0], (int64x2_t)v318.val[1]));
                  v268[1] = vnegq_f64((float64x2_t)vzip2q_s64((int64x2_t)v318.val[0], (int64x2_t)v318.val[1]));
                  v268 -= 2;
                  v269 -= 2;
                  v270 -= 2;
                }
                while (v270);
                if (v237 == (v237 & 0xFFFFFFFFFFFFFFFELL))
                {
LABEL_319:
                  float64x2_t **v315 = vnegq_f64((*v315)[1]);
                  LODWORD(v317[0]) = v36 - 1;
                  if ((int)v36 > 2)
                  {
                    do
                    {
                      LODWORD(v59) = v59 - 1;
                      ClipperLib::ClipperOffset::OffsetPoint(this, v59, (int *)v317, *(_DWORD *)(v33 + 72));
                    }
                    while (v59 > 1);
                  }
                  int v239 = *(_DWORD *)(v33 + 76);
                  if (v239 != 2)
                  {
                    LODWORD(v317[0]) = 1;
                    *((void *)this + 15) = 0;
                    if (v239 == 3)
                    {
                      ClipperLib::ClipperOffset::DoSquare(this, 0, 1);
                      v245 = (void *)*((void *)this + 3);
                      if ((unint64_t)v245 >= *((void *)this + 4)) {
                        goto LABEL_405;
                      }
                    }
                    else
                    {
                      ClipperLib::ClipperOffset::DoRound(this, 0, 1);
                      v245 = (void *)*((void *)this + 3);
                      if ((unint64_t)v245 >= *((void *)this + 4)) {
                        goto LABEL_405;
                      }
                    }
LABEL_387:
                    void *v245 = 0;
                    v245[1] = 0;
                    v245[2] = 0;
                    v282 = (unsigned char *)*((void *)this + 8);
                    int v281 = (unsigned char *)*((void *)this + 9);
                    int64_t v283 = v281 - v282;
                    if (v281 != v282)
                    {
                      if (v283 < 0) {
                        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
                      }
                      uint64_t v284 = (char *)operator new(v281 - v282);
                      void *v245 = v284;
                      v245[1] = v284;
                      v285 = &v284[16 * (v283 >> 4)];
                      v245[2] = v285;
                      memcpy(v284, v282, v283);
                      v245[1] = v285;
                    }
                    v286 = (char *)(v245 + 3);
                    *((void *)this + 3) = v245 + 3;
                    goto LABEL_406;
                  }
                  float64x2_t v240 = vmlsq_lane_f64(vcvtq_f64_s64(*(int64x2_t *)*((void *)this + 5)), *(float64x2_t *)*((void *)this + 11), v316, 0);
                  int64x2_t v241 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v240), v313, v314), v240));
                  v243 = (int64x2_t *)*((void *)this + 9);
                  float v242 = (int64x2_t *)*((void *)this + 10);
                  if (v243 < v242)
                  {
                    int64x2_t *v243 = v241;
                    uint64_t v244 = v243 + 1;
                    goto LABEL_385;
                  }
                  v272 = *v93;
                  uint64_t v273 = v243 - *v93;
                  unint64_t v274 = v273 + 1;
                  if ((unint64_t)(v273 + 1) >> 60) {
                    goto LABEL_415;
                  }
                  uint64_t v275 = (char *)v242 - (char *)v272;
                  if (v275 >> 3 > v274) {
                    unint64_t v274 = v275 >> 3;
                  }
                  if ((unint64_t)v275 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v276 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v276 = v274;
                  }
                  if (v276)
                  {
                    int64x2_t v311 = v241;
                    if (v276 >> 60) {
                      goto LABEL_412;
                    }
                    uint64_t v277 = (char *)operator new(16 * v276);
                    v278 = (int64x2_t *)&v277[16 * v273];
                    int64x2_t *v278 = v311;
                    uint64_t v244 = v278 + 1;
                    if (v243 == v272) {
                      goto LABEL_383;
                    }
                  }
                  else
                  {
                    uint64_t v277 = 0;
                    v278 = (int64x2_t *)(16 * v273);
                    *(int64x2_t *)(16 * v273) = v241;
                    uint64_t v244 = (int64x2_t *)(16 * v273 + 16);
                    if (v243 == v272) {
                      goto LABEL_383;
                    }
                  }
                  do
                  {
                    v278[-1] = v243[-1];
                    --v278;
                    --v243;
                  }
                  while (v243 != v272);
                  v243 = *v93;
LABEL_383:
                  float v242 = (int64x2_t *)&v277[16 * v276];
                  *((void *)this + 8) = v278;
                  *((void *)this + 9) = v244;
                  *((void *)this + 10) = v242;
                  if (v243)
                  {
                    operator delete(v243);
                    float v242 = (int64x2_t *)*((void *)this + 10);
                  }
LABEL_385:
                  *((void *)this + 9) = v244;
                  float64x2_t v279 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)*((void *)this + 5)), *(float64x2_t *)*((void *)this + 11), v316);
                  int64x2_t v280 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v279), v313, v314), v279));
                  if (v244 < v242)
                  {
                    *uint64_t v244 = v280;
                    *((void *)this + 9) = v244 + 1;
                    v245 = (void *)*((void *)this + 3);
                    if ((unint64_t)v245 < *((void *)this + 4)) {
                      goto LABEL_387;
                    }
LABEL_405:
                    v286 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>(v300, (uint64_t)v93);
LABEL_406:
                    *((void *)this + 3) = v286;
                    goto LABEL_28;
                  }
                  float v287 = *v93;
                  uint64_t v288 = v244 - *v93;
                  unint64_t v289 = v288 + 1;
                  if ((unint64_t)(v288 + 1) >> 60) {
LABEL_415:
                  }
                    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
                  uint64_t v290 = (char *)v242 - (char *)v287;
                  if (v290 >> 3 > v289) {
                    unint64_t v289 = v290 >> 3;
                  }
                  if ((unint64_t)v290 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v291 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v291 = v289;
                  }
                  if (v291)
                  {
                    int64x2_t v312 = v280;
                    if (v291 >> 60) {
                      goto LABEL_412;
                    }
                    unint64_t v292 = (char *)operator new(16 * v291);
                    v293 = (int64x2_t *)&v292[16 * v288];
                    v294 = &v292[16 * v291];
                    int64x2_t *v293 = v312;
                    v295 = v293 + 1;
                    if (v244 == v287) {
                      goto LABEL_407;
                    }
                  }
                  else
                  {
                    v293 = (int64x2_t *)(16 * v288);
                    v294 = 0;
                    uint64_t v296 = (int64x2_t *)(16 * v288);
                    *uint64_t v296 = v280;
                    v295 = v296 + 1;
                    if (v244 == v287)
                    {
LABEL_407:
                      *((void *)this + 8) = v293;
                      *((void *)this + 9) = v295;
                      *((void *)this + 10) = v294;
                      goto LABEL_408;
                    }
                  }
                  do
                  {
                    v293[-1] = v244[-1];
                    --v293;
                    --v244;
                  }
                  while (v244 != v287);
                  uint64_t v244 = (int64x2_t *)*((void *)this + 8);
                  *((void *)this + 8) = v293;
                  *((void *)this + 9) = v295;
                  *((void *)this + 10) = v294;
                  if (!v244)
                  {
                    *((void *)this + 9) = v295;
                    v245 = (void *)*((void *)this + 3);
                    if ((unint64_t)v245 < *((void *)this + 4)) {
                      goto LABEL_387;
                    }
                    goto LABEL_405;
                  }
LABEL_408:
                  operator delete(v244);
                  *((void *)this + 9) = v295;
                  v245 = (void *)*((void *)this + 3);
                  if ((unint64_t)v245 < *((void *)this + 4)) {
                    goto LABEL_387;
                  }
                  goto LABEL_405;
                }
              }
              do
              {
                BOOL v163 = v238 > 1;
                v236[v238] = vnegq_f64(v236[(v238 - 1)]);
                --v238;
              }
              while (v163);
              goto LABEL_319;
            }
            float64x2_t v154 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * (int)v59)), *(float64x2_t *)(*((void *)this + 11) + 16 * (int)v59), v316);
            int64x2_t v155 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v154), v313, v314), v154));
            float v157 = (int64x2_t *)*((void *)this + 9);
            float v156 = (int64x2_t *)*((void *)this + 10);
            if (v157 < v156)
            {
              *float v157 = v155;
              unint64_t v158 = v157 + 1;
              goto LABEL_294;
            }
            float v165 = *v93;
            uint64_t v166 = v157 - v165;
            unint64_t v167 = v166 + 1;
            if ((unint64_t)(v166 + 1) >> 60) {
              _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
            }
            uint64_t v168 = (char *)v156 - (char *)v165;
            if (v168 >> 3 > v167) {
              unint64_t v167 = v168 >> 3;
            }
            if ((unint64_t)v168 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v169 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v169 = v167;
            }
            if (v169)
            {
              int64x2_t v303 = v155;
              if (v169 >> 60) {
                goto LABEL_412;
              }
              uint64_t v170 = (char *)operator new(16 * v169);
              unint64_t v171 = (int64x2_t *)&v170[16 * v166];
              *unint64_t v171 = v303;
              unint64_t v158 = v171 + 1;
              if (v157 == v165)
              {
LABEL_309:
                uint64_t v93 = (int64x2_t **)((char *)this + 64);
                float v156 = (int64x2_t *)&v170[16 * v169];
                *((void *)this + 8) = v171;
                *((void *)this + 9) = v158;
                *((void *)this + 10) = v156;
                if (!v157) {
                  goto LABEL_294;
                }
                goto LABEL_293;
              }
            }
            else
            {
              uint64_t v170 = 0;
              unint64_t v171 = (int64x2_t *)(16 * v166);
              float v223 = (int64x2_t *)(16 * v166);
              *float v223 = v155;
              unint64_t v158 = v223 + 1;
              if (v157 == v165) {
                goto LABEL_309;
              }
            }
            do
            {
              v171[-1] = v157[-1];
              --v171;
              --v157;
            }
            while (v157 != v165);
            uint64_t v93 = (int64x2_t **)((char *)this + 64);
            float v157 = *v299;
            float v156 = (int64x2_t *)&v170[16 * v169];
            *((void *)this + 8) = v171;
            *((void *)this + 9) = v158;
            *((void *)this + 10) = v156;
            if (!v157)
            {
LABEL_294:
              *((void *)this + 9) = v158;
              float64x2_t v224 = vmlsq_lane_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * (int)v59)), *(float64x2_t *)(*((void *)this + 11) + 16 * (int)v59), v316, 0);
              int64x2_t v225 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v224), v313, v314), v224));
              if (v158 < v156)
              {
                *unint64_t v158 = v225;
                uint64_t v226 = v158 + 1;
LABEL_314:
                *((void *)this + 9) = v226;
                unint64_t v140 = v306;
                goto LABEL_315;
              }
              long long v227 = *v93;
              uint64_t v228 = v158 - *v93;
              unint64_t v229 = v228 + 1;
              if ((unint64_t)(v228 + 1) >> 60) {
                goto LABEL_415;
              }
              uint64_t v230 = (char *)v156 - (char *)v227;
              if (v230 >> 3 > v229) {
                unint64_t v229 = v230 >> 3;
              }
              if ((unint64_t)v230 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v231 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v231 = v229;
              }
              if (v231)
              {
                int64x2_t v304 = v225;
                if (v231 >> 60) {
                  goto LABEL_412;
                }
                int v232 = (char *)operator new(16 * v231);
                id v233 = (int64x2_t *)&v232[16 * v228];
                uint64_t v234 = &v232[16 * v231];
                *id v233 = v304;
                uint64_t v226 = v233 + 1;
                if (v158 != v227)
                {
LABEL_305:
                  uint64_t v28 = (void *)((char *)this + 40);
                  do
                  {
                    v233[-1] = v158[-1];
                    --v233;
                    --v158;
                  }
                  while (v158 != v227);
                  unint64_t v158 = (int64x2_t *)*((void *)this + 8);
                  *((void *)this + 8) = v233;
                  *((void *)this + 9) = v226;
                  *((void *)this + 10) = v234;
                  if (!v158) {
                    goto LABEL_314;
                  }
                  goto LABEL_313;
                }
              }
              else
              {
                id v233 = (int64x2_t *)(16 * v228);
                uint64_t v234 = 0;
                uint64_t v235 = (int64x2_t *)(16 * v228);
                int64x2_t *v235 = v225;
                uint64_t v226 = v235 + 1;
                if (v158 != v227) {
                  goto LABEL_305;
                }
              }
              *((void *)this + 8) = v233;
              *((void *)this + 9) = v226;
              *((void *)this + 10) = v234;
              uint64_t v28 = (void *)((char *)this + 40);
LABEL_313:
              operator delete(v158);
              goto LABEL_314;
            }
LABEL_293:
            operator delete(v157);
            float v156 = (int64x2_t *)*((void *)this + 10);
            goto LABEL_294;
          }
          LODWORD(v317[0]) = v36 - 1;
          if ((int)v36 >= 1)
          {
            int v146 = 0;
            do
              ClipperLib::ClipperOffset::OffsetPoint(this, v146++, (int *)v317, *(_DWORD *)(v33 + 72));
            while (v36 != v146);
          }
          unint64_t v147 = (void *)*((void *)this + 3);
          if ((unint64_t)v147 >= *((void *)this + 4))
          {
            int v142 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>(v300, (uint64_t)v93);
          }
          else
          {
            *unint64_t v147 = 0;
            v147[1] = 0;
            v147[2] = 0;
            uint64_t v149 = (unsigned char *)*((void *)this + 8);
            float v148 = (unsigned char *)*((void *)this + 9);
            int64_t v150 = v148 - v149;
            if (v148 != v149)
            {
              if (v150 < 0) {
                _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
              }
              float v151 = (char *)operator new(v148 - v149);
              *unint64_t v147 = v151;
              v147[1] = v151;
              v152 = &v151[16 * (v150 >> 4)];
              v147[2] = v152;
              memcpy(v151, v149, v150);
              v147[1] = v152;
              unint64_t v140 = v306;
            }
            int v142 = (char *)(v147 + 3);
            *((void *)this + 3) = v142;
            uint64_t v93 = (int64x2_t **)((char *)this + 64);
          }
          *((void *)this + 3) = v142;
          *((void *)this + 9) = *((void *)this + 8);
          float v159 = (float64x2_t *)*((void *)this + 11);
          float64x2_t v160 = v159[(int)v59];
          if ((int)v36 > 1)
          {
            unint64_t v161 = (v140 >> 4) - 1;
            if (v161 < 0x36) {
              goto LABEL_179;
            }
            uint64_t v172 = &v159->f64[1];
            uint64_t v173 = 16 * (v59 - 1);
            uint64_t v174 = v59;
            unint64_t v175 = (unint64_t)&v159[v59].f64[1];
            if (v175 - v173 > v175) {
              goto LABEL_179;
            }
            if (&v159[v174 + v173 / 0xFFFFFFFFFFFFFFF0] > &v159[v174]) {
              goto LABEL_179;
            }
            uint64_t v176 = 2 * v297;
            if (&v159[(unint64_t)v176 / 2 + v173 / 0xFFFFFFFFFFFFFFF0] > &v159[(unint64_t)v176 / 2]
              || &v172[v176 + v173 / 0xFFFFFFFFFFFFFFF8] > &v172[v176])
            {
              goto LABEL_179;
            }
            uint64_t v177 = (v140 + 0xFFFFFFFE0) & 0xFFFFFFFF0;
            long long v178 = v159 + 1;
            unint64_t v179 = (unint64_t)&v159[1] + v177 - v174 * 16;
            uint64_t v180 = (float64x2_t *)((char *)v172 + v177);
            int v181 = (char *)&v159[1].f64[1];
            uint64_t v182 = &v159[v174 + 1];
            unint64_t v183 = (unint64_t)v172 + v177 - v174 * 16 + 16;
            long long v184 = (float64x2_t *)((char *)v159 + v177 + 16);
            _CF = v179 >= (unint64_t)v182 || v181 >= (char *)v180;
            BOOL v186 = !_CF;
            BOOL v187 = v183 >= v175 || v178 >= v184;
            BOOL v188 = !v187;
            BOOL v189 = v183 >= (unint64_t)v182 || v181 >= (char *)v184;
            BOOL v190 = !v189;
            BOOL v191 = v178 >= v182 || (unint64_t)v181 >= v175;
            BOOL v192 = !v191;
            BOOL v193 = v178 >= v180 || v179 >= v175;
            if (!v193 || v186 || v188 || v190 || v192)
            {
LABEL_179:
              unint64_t v162 = (v36 - 1);
            }
            else
            {
              unint64_t v162 = v59 - (v161 & 0xFFFFFFFFFFFFFFFELL);
              v194 = &v159[v174 - 1];
              uint64_t v195 = v59 + 0xFFFFFFFFLL;
              unint64_t v196 = v161 & 0xFFFFFFFFFFFFFFFELL;
              do
              {
                unint64_t v197 = v159[v195 - 1].f64;
                float64x2x2_t v319 = vld2q_f64(v197);
                float64x2_t *v194 = vnegq_f64((float64x2_t)vzip1q_s64((int64x2_t)v319.val[0], (int64x2_t)v319.val[1]));
                v194[1] = vnegq_f64((float64x2_t)vzip2q_s64((int64x2_t)v319.val[0], (int64x2_t)v319.val[1]));
                v194 -= 2;
                v195 -= 2;
                v196 -= 2;
              }
              while (v196);
              if (v161 == (v161 & 0xFFFFFFFFFFFFFFFELL)) {
                goto LABEL_181;
              }
            }
            do
            {
              BOOL v163 = v162 > 1;
              v159[v162] = vnegq_f64(v159[(v162 - 1)]);
              --v162;
            }
            while (v163);
          }
LABEL_181:
          *float v159 = vnegq_f64(v160);
          LODWORD(v317[0]) = 0;
          if ((int)v36 >= 1)
          {
            do
            {
              ClipperLib::ClipperOffset::OffsetPoint(this, v59, (int *)v317, *(_DWORD *)(v33 + 72));
              LODWORD(v59) = v59 - 1;
            }
            while (v59 != -1);
            int v142 = (char *)*((void *)this + 3);
          }
          if ((unint64_t)v142 >= *((void *)this + 4)) {
            goto LABEL_405;
          }
          *(void *)int v142 = 0;
          *((void *)v142 + 1) = 0;
          *((void *)v142 + 2) = 0;
          uint64_t v144 = (unsigned char *)*((void *)this + 8);
          long long v143 = (unsigned char *)*((void *)this + 9);
          int64_t v145 = v143 - v144;
          if (v143 == v144) {
            goto LABEL_289;
          }
          if (v145 < 0) {
            _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
          }
LABEL_288:
          v221 = (char *)operator new(v143 - v144);
          *(void *)int v142 = v221;
          *((void *)v142 + 1) = v221;
          unint64_t v222 = &v221[16 * (v145 >> 4)];
          *((void *)v142 + 2) = v222;
          memcpy(v221, v144, v145);
          *((void *)v142 + 1) = v222;
          goto LABEL_289;
        }
      }
LABEL_151:
      operator delete(v97);
      goto LABEL_152;
    }
    uint64_t v85 = (uint64_t *)(*v28 + 16 * (int)v59);
    uint64_t v86 = *(void *)(*v28 + 8);
    uint64_t v88 = *v85;
    uint64_t v87 = v85[1];
    double v89 = 0.0;
    uint64_t v90 = *(void *)*v28 - v88;
    if (v90) {
      BOOL v91 = 0;
    }
    else {
      BOOL v91 = v86 == v87;
    }
    double v92 = 0.0;
    uint64_t v93 = (int64x2_t **)((char *)this + 64);
    if (!v91)
    {
      double v94 = (double)(v86 - v87);
      double v95 = 1.0 / sqrt((double)v90 * (double)v90 + v94 * v94);
      double v92 = v95 * v94;
      double v89 = -((double)v90 * v95);
    }
    float v97 = (float64x2_t *)*((void *)this + 12);
    unint64_t v96 = *((void *)this + 13);
    if ((unint64_t)v97 < v96)
    {
      v97->f64[0] = v92;
      v97->f64[1] = v89;
      float v98 = v97 + 1;
      goto LABEL_152;
    }
    id v106 = *v315;
    uint64_t v107 = v97 - *v315;
    unint64_t v108 = v107 + 1;
    if ((unint64_t)(v107 + 1) >> 60) {
      goto LABEL_411;
    }
    uint64_t v109 = v96 - (void)v106;
    if (v109 >> 3 > v108) {
      unint64_t v108 = v109 >> 3;
    }
    if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v110 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v110 = v108;
    }
    if (v110)
    {
      if (v110 >> 60) {
        goto LABEL_412;
      }
      unint64_t v111 = (char *)operator new(16 * v110);
      float v112 = (double *)&v111[16 * v107];
      *float v112 = v92;
      v112[1] = v89;
      uint64_t v113 = (uint64_t)v112;
      if (v97 != v106)
      {
LABEL_109:
        uint64_t v28 = (void *)((char *)this + 40);
        do
        {
          *(float64x2_t *)(v113 - 16) = v97[-1];
          v113 -= 16;
          --v97;
        }
        while (v97 != v106);
        float v97 = *v315;
        uint64_t v114 = &v111[16 * v110];
        float v98 = (float64x2_t *)(v112 + 2);
        *((void *)this + 11) = v113;
        *((void *)this + 12) = v112 + 2;
        *((void *)this + 13) = v114;
        if (!v97) {
          goto LABEL_152;
        }
        goto LABEL_151;
      }
    }
    else
    {
      unint64_t v111 = 0;
      float v112 = (double *)(16 * v107);
      *float v112 = v92;
      v112[1] = v89;
      uint64_t v113 = 16 * v107;
      if (v97 != v106) {
        goto LABEL_109;
      }
    }
    uint64_t v28 = (void *)((char *)this + 40);
    uint64_t v136 = &v111[16 * v110];
    float v98 = (float64x2_t *)(v112 + 2);
    *((void *)this + 11) = v113;
    *((void *)this + 12) = v112 + 2;
    *((void *)this + 13) = v136;
    if (!v97) {
      goto LABEL_152;
    }
    goto LABEL_151;
  }
}

void sub_235EF9790(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v4;
    operator delete(v4);
  }
  *(void *)(v1 + 24) = v2;
  _Unwind_Resume(exception_object);
}

void ClipperLib::ClipperOffset::Execute(ClipperLib::ClipperOffset *this, ClipperLib::PolyTree *a2, double a3)
{
  uint64_t v6 = *((void *)a2 + 10);
  uint64_t v7 = *((void *)a2 + 11);
  if (v7 != v6)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(v6 + 8 * v8);
      if (v9)
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
        uint64_t v6 = *((void *)a2 + 10);
        uint64_t v7 = *((void *)a2 + 11);
      }
      ++v8;
    }
    while (v8 < (v7 - v6) >> 3);
    if (v7 != v6) {
      *((void *)a2 + 11) = v6;
    }
  }
  uint64_t v10 = *((void *)a2 + 4);
  if (*((void *)a2 + 5) != v10) {
    *((void *)a2 + 5) = v10;
  }
  ClipperLib::ClipperOffset::FixOrientations(this);
  ClipperLib::ClipperOffset::DoOffset(this, a3);
  uint64_t v80 = 0;
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v61 = &unk_26E943250;
  uint64_t v76 = &unk_26E943298;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  char v79 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  uint64_t v70 = 0;
  char v73 = 0;
  char v74 = 0;
  char v75 = 0;
  __int16 v83 = 0;
  uint64_t v11 = *((void *)this + 2);
  if (*((void *)this + 3) != v11)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      ClipperLib::ClipperBase::AddPath((uint64_t)&v76, v11 + v12, 0, 1);
      ++v13;
      uint64_t v11 = *((void *)this + 2);
      v12 += 24;
    }
    while (v13 < 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 3) - v11) >> 3));
  }
  if (a3 <= 0.0)
  {
    uint64_t v14 = v61;
    uint64_t v15 = (char *)&v61 + *(v61 - 3);
    uint64_t v16 = *((void *)v15 + 2);
    uint64_t v17 = *((void *)v15 + 3);
    if (v16 == v17)
    {
      uint64_t v19 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v18 = *(uint64_t **)(v16 + 8);
      uint64_t v20 = *v18;
      uint64_t v19 = v18[1];
      uint64_t v21 = *v18;
      uint64_t v22 = v19;
      do
      {
        double v23 = *(uint64_t **)(v16 + 8);
        double v24 = v23;
        do
        {
          uint64_t v31 = (uint64_t *)v24[14];
          if (v31)
          {
            uint64_t v32 = v24;
            do
            {
              __double2 v25 = v31;
              if (*v32 < v20) {
                uint64_t v20 = *v32;
              }
              if (*v32 > v21) {
                uint64_t v21 = *v32;
              }
              uint64_t v31 = (uint64_t *)v31[14];
              uint64_t v32 = v25;
            }
            while (v31);
          }
          else
          {
            __double2 v25 = v24;
          }
          uint64_t v26 = *v25;
          if (*v25 >= v20) {
            uint64_t v27 = v20;
          }
          else {
            uint64_t v27 = *v25;
          }
          if (v21 > v26) {
            uint64_t v26 = v21;
          }
          uint64_t v29 = v25[4];
          uint64_t v28 = v25[5];
          if (v29 >= v27) {
            uint64_t v20 = v27;
          }
          else {
            uint64_t v20 = v29;
          }
          if (v26 <= v29) {
            uint64_t v21 = v29;
          }
          else {
            uint64_t v21 = v26;
          }
          if (v28 < v22) {
            uint64_t v22 = v28;
          }
          BOOL v30 = v24 == v23;
          double v24 = *(uint64_t **)(v16 + 16);
        }
        while (v30);
        if (v19 <= v23[1]) {
          uint64_t v19 = v23[1];
        }
        v16 += 24;
      }
      while (v16 != v17);
    }
    uint64_t v33 = operator new(0x40uLL);
    v60[1] = v33 + 8;
    void v60[2] = v33 + 8;
    v60[0] = v33;
    void *v33 = v20 - 10;
    v33[1] = v19 + 10;
    v33[2] = v21 + 10;
    v33[3] = v19 + 10;
    v33[4] = v21 + 10;
    v33[5] = v22 - 10;
    v33[6] = v20 - 10;
    v33[7] = v22 - 10;
    ClipperLib::ClipperBase::AddPath((uint64_t)&v61 + *(v14 - 3), (uint64_t)v60, 0, 1);
    char v74 = 1;
    ClipperLib::Clipper::Execute((uint64_t)&v61, 1, a2, 3, 3);
    unint64_t v34 = (unsigned char *)*((void *)a2 + 4);
    uint64_t v35 = (unsigned char *)*((void *)a2 + 5);
    uint64_t v36 = v35 - v34;
    if (((v35 - v34) & 0x7FFFFFFF8) != 8
      || (uint64_t v37 = *(void **)v34,
          uint64_t v38 = *(void **)(*(void *)v34 + 32),
          unint64_t v39 = *(void *)(*(void *)v34 + 40) - (void)v38,
          (int)(v39 >> 3) < 1))
    {
      uint64_t v45 = *((void *)a2 + 10);
      uint64_t v46 = *((void *)a2 + 11);
      if (v46 != v45)
      {
        unint64_t v47 = 0;
        do
        {
          uint64_t v48 = *(void *)(v45 + 8 * v47);
          if (v48)
          {
            (*(void (**)(uint64_t))(*(void *)v48 + 8))(v48);
            uint64_t v45 = *((void *)a2 + 10);
            uint64_t v46 = *((void *)a2 + 11);
          }
          ++v47;
        }
        while (v47 < (v46 - v45) >> 3);
        if (v46 != v45) {
          *((void *)a2 + 11) = v45;
        }
      }
      uint64_t v49 = *((void *)a2 + 4);
      if (*((void *)a2 + 5) != v49) {
        *((void *)a2 + 5) = v49;
      }
      goto LABEL_70;
    }
    unint64_t v40 = (v39 >> 3);
    if (v40 <= (uint64_t)(*((void *)a2 + 6) - (void)v34) >> 3)
    {
LABEL_67:
      *(void *)unint64_t v34 = *v38;
      *(void *)(**((void **)a2 + 4) + 56) = v37[7];
      uint64_t v58 = v37[4];
      if ((int)((unint64_t)(v37[5] - v58) >> 3) >= 2)
      {
        uint64_t v59 = 1;
        do
        {
          ClipperLib::PolyNode::AddChild(a2, *(ClipperLib::PolyNode **)(v58 + 8 * v59++));
          uint64_t v58 = v37[4];
        }
        while (v59 < (int)((unint64_t)(v37[5] - v58) >> 3));
      }
LABEL_70:
      operator delete(v33);
      goto LABEL_71;
    }
    unint64_t v41 = (char *)operator new(8 * v40);
    float64x2_t v42 = &v41[v36 & 0xFFFFFFFFFFFFFFF8];
    float64x2_t v43 = v42;
    if (v35 != v34)
    {
      unint64_t v44 = v35 - v34 - 8;
      if (v44 >= 0x58)
      {
        float64x2_t v43 = &v41[v36 & 0xFFFFFFFFFFFFFFF8];
        if ((unint64_t)(&v35[-(v36 & 0xFFFFFFFFFFFFFFF8)] - v41) >= 0x20)
        {
          uint64_t v50 = (v44 >> 3) + 1;
          uint64_t v51 = 8 * (v50 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v52 = &v35[-v51];
          float64x2_t v43 = &v42[-v51];
          uint64_t v53 = &v41[8 * (v36 >> 3) - 16];
          uint64_t v54 = (long long *)(v35 - 16);
          uint64_t v55 = v50 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v56 = *v54;
            *((_OWORD *)v53 - 1) = *(v54 - 1);
            *(_OWORD *)uint64_t v53 = v56;
            v53 -= 32;
            v54 -= 2;
            v55 -= 4;
          }
          while (v55);
          uint64_t v35 = v52;
          if (v50 == (v50 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_66;
          }
        }
      }
      else
      {
        float64x2_t v43 = &v41[v36 & 0xFFFFFFFFFFFFFFF8];
      }
      do
      {
        uint64_t v57 = *((void *)v35 - 1);
        v35 -= 8;
        *((void *)v43 - 1) = v57;
        v43 -= 8;
      }
      while (v35 != v34);
    }
LABEL_66:
    *((void *)a2 + 4) = v43;
    *((void *)a2 + 5) = v42;
    *((void *)a2 + 6) = &v41[8 * v40];
    operator delete(v34);
    uint64_t v38 = (void *)v37[4];
    unint64_t v34 = (unsigned char *)*((void *)a2 + 4);
    goto LABEL_67;
  }
  ClipperLib::Clipper::Execute((uint64_t)&v61, 1, a2, 2, 2);
LABEL_71:
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&v61);
}

void sub_235EF9D1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  operator delete(v13);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&a13);
  _Unwind_Resume(a1);
}

void sub_235EF9D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)va);
  _Unwind_Resume(a1);
}

void ClipperLib::ClipperOffset::OffsetPoint(ClipperLib::ClipperOffset *this, int a2, int *a3, int a4)
{
  uint64_t v7 = *((void *)this + 11);
  float64x2_t v8 = *(float64x2_t *)(v7 + 16 * a2);
  float64x2_t v9 = *(float64x2_t *)(v7 + 16 * *a3);
  uint64_t v10 = a2;
  float64x2_t v11 = vmulq_f64(v9, (float64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL));
  double v12 = vsubq_f64(v11, (float64x2_t)vdupq_laneq_s64((int64x2_t)v11, 1)).f64[0];
  *((double *)this + 15) = v12;
  double v13 = *((double *)this + 14);
  double v14 = 1.0;
  if (fabs(v13 * v12) >= 1.0)
  {
    if (v12 > 1.0 || (double v14 = -1.0, v12 < -1.0))
    {
      *((double *)this + 15) = v14;
      double v12 = v14;
    }
LABEL_8:
    if (v13 * v12 >= 0.0)
    {
      if (a4)
      {
        if (a4 == 1)
        {
          ClipperLib::ClipperOffset::DoRound(this, a2, *a3);
        }
        else if (a4 == 2)
        {
          uint64_t v33 = *a3;
          float64x2_t v34 = vmulq_f64(*(float64x2_t *)(*((void *)this + 11) + 16 * v33), *(float64x2_t *)(*((void *)this + 11) + 16 * a2));
          double v35 = v34.f64[0] + 1.0 + v34.f64[1];
          if (v35 >= *((double *)this + 18)) {
            ClipperLib::ClipperOffset::DoMiter(this, a2, v33, v35);
          }
          else {
            ClipperLib::ClipperOffset::DoSquare(this, a2, v33);
          }
        }
      }
      else
      {
        ClipperLib::ClipperOffset::DoSquare(this, a2, *a3);
      }
      goto LABEL_81;
    }
    __double2 v25 = (int64x2_t **)((char *)this + 64);
    float64x2_t v26 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * a2)), *(float64x2_t *)(*((void *)this + 11) + 16 * *a3), v13);
    __asm
    {
      FMOV            V2.2D, #0.5
      FMOV            V3.2D, #-0.5
    }
    int8x16_t v78 = _Q3;
    int8x16_t v79 = _Q2;
    int64x2_t v29 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v26), _Q3, _Q2), v26));
    uint64_t v31 = (int64x2_t *)*((void *)this + 9);
    BOOL v30 = (int64x2_t *)*((void *)this + 10);
    if (v31 < v30)
    {
      *uint64_t v31 = v29;
      uint64_t v32 = v31 + 1;
      goto LABEL_43;
    }
    uint64_t v36 = *v25;
    uint64_t v37 = v31 - *v25;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 60) {
      goto LABEL_88;
    }
    uint64_t v39 = (char *)v30 - (char *)v36;
    if (v39 >> 3 > v38) {
      unint64_t v38 = v39 >> 3;
    }
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      int64x2_t v77 = v29;
      if (v40 >> 60) {
        goto LABEL_89;
      }
      unint64_t v41 = (char *)operator new(16 * v40);
      float64x2_t v42 = (int64x2_t *)&v41[16 * v37];
      BOOL v30 = (int64x2_t *)&v41[16 * v40];
      *float64x2_t v42 = v77;
      uint64_t v32 = v42 + 1;
      if (v31 == v36) {
        goto LABEL_41;
      }
    }
    else
    {
      float64x2_t v42 = (int64x2_t *)(16 * v37);
      BOOL v30 = 0;
      uint64_t v53 = (int64x2_t *)(16 * v37);
      *uint64_t v53 = v29;
      uint64_t v32 = v53 + 1;
      if (v31 == v36) {
        goto LABEL_41;
      }
    }
    do
    {
      v42[-1] = v31[-1];
      --v42;
      --v31;
    }
    while (v31 != v36);
    uint64_t v31 = *v25;
LABEL_41:
    *((void *)this + 8) = v42;
    *((void *)this + 9) = v32;
    *((void *)this + 10) = v30;
    if (v31)
    {
      operator delete(v31);
      BOOL v30 = (int64x2_t *)*((void *)this + 10);
    }
LABEL_43:
    *((void *)this + 9) = v32;
    uint64_t v54 = (int64x2_t *)(*((void *)this + 5) + 16 * v10);
    if (v32 < v30)
    {
      *uint64_t v32 = *v54;
      uint64_t v55 = v32 + 1;
      goto LABEL_61;
    }
    long long v56 = *v25;
    uint64_t v57 = v32 - *v25;
    unint64_t v58 = v57 + 1;
    if ((unint64_t)(v57 + 1) >> 60) {
      goto LABEL_88;
    }
    uint64_t v59 = (char *)v30 - (char *)v56;
    if (v59 >> 3 > v58) {
      unint64_t v58 = v59 >> 3;
    }
    if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v60 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v60 = v58;
    }
    if (v60)
    {
      if (v60 >> 60) {
        goto LABEL_89;
      }
      long long v61 = (char *)operator new(16 * v60);
    }
    else
    {
      long long v61 = 0;
    }
    long long v62 = (int64x2_t *)&v61[16 * v57];
    long long v63 = &v61[16 * v60];
    *long long v62 = *v54;
    uint64_t v55 = v62 + 1;
    if (v32 == v56)
    {
      *((void *)this + 8) = v62;
      *((void *)this + 9) = v55;
      *((void *)this + 10) = v63;
    }
    else
    {
      do
      {
        v62[-1] = v32[-1];
        --v62;
        --v32;
      }
      while (v32 != v56);
      uint64_t v32 = (int64x2_t *)*((void *)this + 8);
      *((void *)this + 8) = v62;
      *((void *)this + 9) = v55;
      *((void *)this + 10) = v63;
      if (!v32)
      {
LABEL_61:
        *((void *)this + 9) = v55;
        unint64_t v64 = *((void *)this + 10);
        float64x2_t v65 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * v10)), *(float64x2_t *)(*((void *)this + 11) + 16 * v10), *((double *)this + 14));
        int64x2_t v66 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v65), v78, v79), v65));
        if ((unint64_t)v55 < v64)
        {
          *uint64_t v55 = v66;
          *((void *)this + 9) = v55 + 1;
LABEL_81:
          *a3 = a2;
          return;
        }
        long long v67 = *v25;
        uint64_t v68 = v55 - *v25;
        unint64_t v69 = v68 + 1;
        if (!((unint64_t)(v68 + 1) >> 60))
        {
          uint64_t v70 = v64 - (void)v67;
          if (v70 >> 3 > v69) {
            unint64_t v69 = v70 >> 3;
          }
          if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v71 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v71 = v69;
          }
          if (v71)
          {
            int64x2_t v81 = v66;
            if (v71 >> 60) {
              goto LABEL_89;
            }
            uint64_t v72 = (char *)operator new(16 * v71);
            char v73 = (int64x2_t *)&v72[16 * v68];
            char v74 = &v72[16 * v71];
            *char v73 = v81;
            uint64_t i64 = (uint64_t)v73[1].i64;
            if (v55 == v67) {
              goto LABEL_77;
            }
          }
          else
          {
            char v73 = (int64x2_t *)(16 * v68);
            char v74 = 0;
            *(int64x2_t *)(16 * v68) = v66;
            uint64_t i64 = 16 * v68 + 16;
            if (v55 == v67)
            {
LABEL_77:
              *((void *)this + 8) = v73;
              *((void *)this + 9) = i64;
              *((void *)this + 10) = v74;
LABEL_78:
              operator delete(v55);
LABEL_79:
              *((void *)this + 9) = i64;
              goto LABEL_81;
            }
          }
          do
          {
            v73[-1] = v55[-1];
            --v73;
            --v55;
          }
          while (v55 != v67);
          uint64_t v55 = (int64x2_t *)*((void *)this + 8);
          *((void *)this + 8) = v73;
          *((void *)this + 9) = i64;
          *((void *)this + 10) = v74;
          if (!v55) {
            goto LABEL_79;
          }
          goto LABEL_78;
        }
LABEL_88:
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
    }
    operator delete(v32);
    goto LABEL_61;
  }
  if (vaddvq_f64(vmulq_f64(v9, v8)) <= 0.0) {
    goto LABEL_8;
  }
  float64x2_t v15 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * a2)), v9, v13);
  __asm
  {
    FMOV            V2.2D, #0.5
    FMOV            V3.2D, #-0.5
  }
  int64x2_t v22 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v15), _Q3, _Q2), v15));
  double v24 = (int64x2_t *)*((void *)this + 9);
  unint64_t v23 = *((void *)this + 10);
  if ((unint64_t)v24 < v23)
  {
    int64x2_t *v24 = v22;
    *((void *)this + 9) = v24 + 1;
    return;
  }
  float64x2_t v43 = (int64x2_t **)((char *)this + 64);
  unint64_t v44 = (int64x2_t *)*((void *)this + 8);
  uint64_t v45 = v24 - v44;
  unint64_t v46 = v45 + 1;
  if ((unint64_t)(v45 + 1) >> 60) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v47 = v23 - (void)v44;
  if (v47 >> 3 > v46) {
    unint64_t v46 = v47 >> 3;
  }
  if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v48 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v48 = v46;
  }
  if (v48)
  {
    int64x2_t v80 = v22;
    if (!(v48 >> 60))
    {
      uint64_t v49 = (char *)operator new(16 * v48);
      uint64_t v50 = (int64x2_t *)&v49[16 * v45];
      uint64_t v51 = &v49[16 * v48];
      *uint64_t v50 = v80;
      uint64_t v52 = v50 + 1;
      if (v24 == v44) {
        goto LABEL_85;
      }
      do
      {
LABEL_83:
        v50[-1] = v24[-1];
        --v50;
        --v24;
      }
      while (v24 != v44);
      double v24 = *v43;
      goto LABEL_85;
    }
LABEL_89:
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v50 = (int64x2_t *)(16 * v45);
  uint64_t v51 = 0;
  uint64_t v76 = (int64x2_t *)(16 * v45);
  *uint64_t v76 = v22;
  uint64_t v52 = v76 + 1;
  if (v24 != v44) {
    goto LABEL_83;
  }
LABEL_85:
  *((void *)this + 8) = v50;
  *((void *)this + 9) = v52;
  *((void *)this + 10) = v51;
  if (v24) {
    operator delete(v24);
  }
  *((void *)this + 9) = v52;
}

void ClipperLib::ClipperOffset::DoSquare(ClipperLib::ClipperOffset *this, int a2, int a3)
{
  uint64_t v5 = *((void *)this + 11);
  uint64_t v6 = 16 * a2;
  float64x2_t v52 = *(float64x2_t *)(v5 + 16 * a3);
  long double v7 = atan2(*((long double *)this + 15), vaddvq_f64(vmulq_f64(*(float64x2_t *)(v5 + v6), v52)));
  double v8 = tan(v7 * 0.25);
  int8x16_t v9 = (int8x16_t)vmulq_n_f64(v52, v8);
  float64x2_t v10 = (float64x2_t)vextq_s8(v9, v9, 8uLL);
  float64x2_t v11 = vaddq_f64(v52, v10);
  *(void *)&v10.f64[0] = *(_OWORD *)&vsubq_f64(v52, v10);
  v10.f64[1] = v11.f64[1];
  float64x2_t v12 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + v6)), v10, *((double *)this + 14));
  *(int32x2_t *)&v10.f64[0] = vmovn_s64(vcltzq_f64(v12));
  char v13 = BYTE4(v10.f64[0]);
  double v14 = (uint64_t **)((char *)this + 64);
  _ZF = (LOBYTE(v10.f64[0]) & 1) == 0;
  double v16 = -0.5;
  if (_ZF) {
    double v17 = 0.5;
  }
  else {
    double v17 = -0.5;
  }
  uint64_t v18 = (uint64_t)(v17 + v12.f64[0]);
  if ((v13 & 1) == 0) {
    double v16 = 0.5;
  }
  uint64_t v19 = (uint64_t)(v16 + v12.f64[1]);
  uint64_t v21 = (uint64_t *)*((void *)this + 9);
  uint64_t v20 = (int64x2_t *)*((void *)this + 10);
  if (v21 < (uint64_t *)v20)
  {
    *uint64_t v21 = v18;
    v21[1] = v19;
    int64x2_t v22 = (int64x2_t *)(v21 + 2);
    goto LABEL_23;
  }
  unint64_t v23 = *v14;
  uint64_t v24 = ((char *)v21 - (char *)*v14) >> 4;
  unint64_t v25 = v24 + 1;
  if ((unint64_t)(v24 + 1) >> 60) {
    goto LABEL_42;
  }
  uint64_t v26 = (char *)v20 - (char *)v23;
  if (v26 >> 3 > v25) {
    unint64_t v25 = v26 >> 3;
  }
  if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v27 = v25;
  }
  double v51 = v8;
  if (v27)
  {
    if (v27 >> 60) {
      goto LABEL_43;
    }
    uint64_t v28 = (char *)operator new(16 * v27);
    double v8 = v51;
    int64x2_t v29 = (uint64_t *)&v28[16 * v24];
    uint64_t v20 = (int64x2_t *)&v28[16 * v27];
    *int64x2_t v29 = v18;
    v29[1] = v19;
    int64x2_t v22 = (int64x2_t *)(v29 + 2);
    if (v21 == v23) {
      goto LABEL_21;
    }
  }
  else
  {
    int64x2_t v29 = (uint64_t *)(16 * v24);
    uint64_t v20 = 0;
    *int64x2_t v29 = v18;
    v29[1] = v19;
    int64x2_t v22 = (int64x2_t *)(16 * v24 + 16);
    if (v21 == v23) {
      goto LABEL_21;
    }
  }
  do
  {
    *((_OWORD *)v29 - 1) = *((_OWORD *)v21 - 1);
    v29 -= 2;
    v21 -= 2;
  }
  while (v21 != v23);
  uint64_t v21 = *v14;
LABEL_21:
  *((void *)this + 8) = v29;
  *((void *)this + 9) = v22;
  *((void *)this + 10) = v20;
  if (v21)
  {
    operator delete(v21);
    double v8 = v51;
    uint64_t v20 = (int64x2_t *)*((void *)this + 10);
  }
LABEL_23:
  *((void *)this + 9) = v22;
  uint64_t v30 = 16 * a2;
  float64x2_t v31 = *(float64x2_t *)(*((void *)this + 11) + v30);
  int8x16_t v32 = (int8x16_t)vmulq_n_f64(v31, v8);
  float64x2_t v33 = (float64x2_t)vextq_s8(v32, v32, 8uLL);
  *(void *)&v34.f64[0] = *(_OWORD *)&vaddq_f64(v31, v33);
  v34.f64[1] = vsubq_f64(v31, v33).f64[1];
  float64x2_t v35 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + v30)), v34, *((double *)this + 14));
  __asm
  {
    FMOV            V1.2D, #0.5
    FMOV            V3.2D, #-0.5
  }
  int64x2_t v41 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v35), _Q3, _Q1), v35));
  if (v22 < v20)
  {
    *int64x2_t v22 = v41;
    uint64_t i64 = (uint64_t)v22[1].i64;
    goto LABEL_41;
  }
  float64x2_t v43 = (int64x2_t *)*v14;
  uint64_t v44 = ((char *)v22 - (char *)*v14) >> 4;
  unint64_t v45 = v44 + 1;
  if ((unint64_t)(v44 + 1) >> 60) {
LABEL_42:
  }
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  uint64_t v46 = (char *)v20 - (char *)v43;
  if (v46 >> 3 > v45) {
    unint64_t v45 = v46 >> 3;
  }
  if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v47 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v47 = v45;
  }
  if (v47)
  {
    int64x2_t v53 = v41;
    if (!(v47 >> 60))
    {
      unint64_t v48 = (char *)operator new(16 * v47);
      uint64_t v49 = (int64x2_t *)&v48[16 * v44];
      uint64_t v50 = &v48[16 * v47];
      *uint64_t v49 = v53;
      uint64_t i64 = (uint64_t)v49[1].i64;
      if (v22 == v43) {
        goto LABEL_39;
      }
      goto LABEL_36;
    }
LABEL_43:
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v49 = (int64x2_t *)(16 * v44);
  uint64_t v50 = 0;
  *(int64x2_t *)(16 * v44) = v41;
  uint64_t i64 = 16 * v44 + 16;
  if (v22 == v43)
  {
LABEL_39:
    *((void *)this + 8) = v49;
    *((void *)this + 9) = i64;
    *((void *)this + 10) = v50;
LABEL_40:
    operator delete(v22);
    goto LABEL_41;
  }
  do
  {
LABEL_36:
    v49[-1] = v22[-1];
    --v49;
    --v22;
  }
  while (v22 != v43);
  int64x2_t v22 = (int64x2_t *)*((void *)this + 8);
  *((void *)this + 8) = v49;
  *((void *)this + 9) = i64;
  *((void *)this + 10) = v50;
  if (v22) {
    goto LABEL_40;
  }
LABEL_41:
  *((void *)this + 9) = i64;
}

void ClipperLib::ClipperOffset::DoRound(ClipperLib::ClipperOffset *this, int a2, int a3)
{
  uint64_t v4 = *((void *)this + 11);
  uint64_t v5 = a2;
  float64x2_t v49 = *(float64x2_t *)(v4 + 16 * a3);
  double v6 = atan2(*((long double *)this + 15), vaddvq_f64(vmulq_f64(*(float64x2_t *)(v4 + 16 * a2), v49)));
  float64x2_t v7 = v49;
  int v8 = 0;
  double v9 = *((double *)this + 19) * fabs(v6);
  double v10 = 0.5;
  if (v9 < 0.0) {
    double v10 = -0.5;
  }
  if ((int)(uint64_t)(v10 + v9) <= 1) {
    int v11 = 1;
  }
  else {
    int v11 = (uint64_t)(v10 + v9);
  }
  float64x2_t v12 = (int64x2_t **)((char *)this + 64);
  char v13 = (int64x2_t *)*((void *)this + 9);
  __asm
  {
    FMOV            V1.2D, #0.5
    FMOV            V0.2D, #-0.5
  }
  int8x16_t v47 = _Q0;
  int8x16_t v48 = _Q1;
  do
  {
    float64x2_t v22 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * v5)), v7, *((double *)this + 14));
    int64x2_t v23 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v22), v47, v48), v22));
    unint64_t v24 = *((void *)this + 10);
    if ((unint64_t)v13 < v24)
    {
      *v13++ = v23;
      goto LABEL_8;
    }
    unint64_t v25 = *v12;
    uint64_t v26 = v13 - *v12;
    unint64_t v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 60) {
      goto LABEL_45;
    }
    uint64_t v28 = v24 - (void)v25;
    if (v28 >> 3 > v27) {
      unint64_t v27 = v28 >> 3;
    }
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v29 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v29 = v27;
    }
    float64x2_t v50 = v7;
    if (v29)
    {
      int64x2_t v46 = v23;
      if (v29 >> 60) {
        goto LABEL_46;
      }
      uint64_t v30 = (char *)operator new(16 * v29);
      float64x2_t v7 = v50;
      float64x2_t v31 = (int64x2_t *)&v30[16 * v26];
      *float64x2_t v31 = v46;
      int8x16_t v32 = v31 + 1;
      if (v13 == v25) {
        goto LABEL_23;
      }
      do
      {
LABEL_21:
        v31[-1] = v13[-1];
        --v31;
        --v13;
      }
      while (v13 != v25);
      char v13 = *v12;
      goto LABEL_23;
    }
    uint64_t v30 = 0;
    float64x2_t v31 = (int64x2_t *)(16 * v26);
    float64x2_t v33 = (int64x2_t *)(16 * v26);
    int64x2_t *v33 = v23;
    int8x16_t v32 = v33 + 1;
    if (v13 != v25) {
      goto LABEL_21;
    }
LABEL_23:
    *((void *)this + 8) = v31;
    *((void *)this + 9) = v32;
    *((void *)this + 10) = &v30[16 * v29];
    if (v13)
    {
      operator delete(v13);
      float64x2_t v7 = v50;
    }
    char v13 = v32;
LABEL_8:
    *((void *)this + 9) = v13;
    float64x2_t v20 = vmulq_n_f64((float64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL), *((double *)this + 16));
    float64x2_t v21 = vmulq_n_f64(v7, *((double *)this + 17));
    *(void *)&v7.f64[0] = *(_OWORD *)&vsubq_f64(v21, v20);
    v7.f64[1] = vaddq_f64(v21, v20).f64[1];
    ++v8;
  }
  while (v8 != v11);
  unint64_t v34 = *((void *)this + 10);
  float64x2_t v35 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * v5)), *(float64x2_t *)(*((void *)this + 11) + 16 * v5), *((double *)this + 14));
  int64x2_t v36 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v35), v47, v48), v35));
  if ((unint64_t)v13 < v34)
  {
    *char v13 = v36;
    uint64_t i64 = (uint64_t)v13[1].i64;
    goto LABEL_44;
  }
  unint64_t v38 = *v12;
  uint64_t v39 = v13 - *v12;
  unint64_t v40 = v39 + 1;
  if ((unint64_t)(v39 + 1) >> 60) {
LABEL_45:
  }
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  uint64_t v41 = v34 - (void)v38;
  if (v41 >> 3 > v40) {
    unint64_t v40 = v41 >> 3;
  }
  if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v42 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v42 = v40;
  }
  if (v42)
  {
    int64x2_t v51 = v36;
    if (v42 >> 60) {
LABEL_46:
    }
      std::__throw_bad_array_new_length[abi:ne180100]();
    float64x2_t v43 = (char *)operator new(16 * v42);
    uint64_t v44 = (int64x2_t *)&v43[16 * v39];
    unint64_t v45 = &v43[16 * v42];
    *uint64_t v44 = v51;
    uint64_t i64 = (uint64_t)v44[1].i64;
    if (v13 == v38)
    {
LABEL_42:
      *((void *)this + 8) = v44;
      *((void *)this + 9) = i64;
      *((void *)this + 10) = v45;
LABEL_43:
      operator delete(v13);
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v44 = (int64x2_t *)(16 * v39);
    unint64_t v45 = 0;
    *(int64x2_t *)(16 * v39) = v36;
    uint64_t i64 = 16 * v39 + 16;
    if (v13 == v38) {
      goto LABEL_42;
    }
  }
  do
  {
    v44[-1] = v13[-1];
    --v44;
    --v13;
  }
  while (v13 != v38);
  char v13 = (int64x2_t *)*((void *)this + 8);
  *((void *)this + 8) = v44;
  *((void *)this + 9) = i64;
  *((void *)this + 10) = v45;
  if (v13) {
    goto LABEL_43;
  }
LABEL_44:
  *((void *)this + 9) = i64;
}

void ClipperLib::ClipperOffset::DoMiter(ClipperLib::ClipperOffset *this, int a2, int a3, double a4)
{
  float64x2_t v5 = vmlaq_n_f64(vcvtq_f64_s64(*(int64x2_t *)(*((void *)this + 5) + 16 * a2)), vaddq_f64(*(float64x2_t *)(*((void *)this + 11) + 16 * a2), *(float64x2_t *)(*((void *)this + 11) + 16 * a3)), *((double *)this + 14) / a4);
  __asm
  {
    FMOV            V2.2D, #0.5
    FMOV            V3.2D, #-0.5
  }
  int64x2_t v12 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v5), _Q3, _Q2), v5));
  double v14 = (int64x2_t *)*((void *)this + 9);
  unint64_t v13 = *((void *)this + 10);
  if ((unint64_t)v14 < v13)
  {
    *double v14 = v12;
    float64x2_t v15 = v14 + 1;
    goto LABEL_18;
  }
  double v16 = (int64x2_t **)((char *)this + 64);
  double v17 = (int64x2_t *)*((void *)this + 8);
  uint64_t v18 = v14 - v17;
  unint64_t v19 = v18 + 1;
  if ((unint64_t)(v18 + 1) >> 60) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v20 = v13 - (void)v17;
  if (v20 >> 3 > v19) {
    unint64_t v19 = v20 >> 3;
  }
  if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v21 = v19;
  }
  if (v21)
  {
    int64x2_t v26 = v12;
    if (v21 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float64x2_t v22 = (char *)operator new(16 * v21);
    int64x2_t v23 = (int64x2_t *)&v22[16 * v18];
    unint64_t v24 = &v22[16 * v21];
    int64x2_t *v23 = v26;
    float64x2_t v15 = v23 + 1;
    if (v14 == v17) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  int64x2_t v23 = (int64x2_t *)(16 * v18);
  unint64_t v24 = 0;
  unint64_t v25 = (int64x2_t *)(16 * v18);
  int64x2_t *v25 = v12;
  float64x2_t v15 = v25 + 1;
  if (v14 != v17)
  {
    do
    {
LABEL_14:
      v23[-1] = v14[-1];
      --v23;
      --v14;
    }
    while (v14 != v17);
    double v14 = *v16;
  }
LABEL_16:
  *((void *)this + 8) = v23;
  *((void *)this + 9) = v15;
  *((void *)this + 10) = v24;
  if (v14) {
    operator delete(v14);
  }
LABEL_18:
  *((void *)this + 9) = v15;
}

uint64_t *ClipperLib::ReversePaths(uint64_t *result)
{
  uint64_t v2 = *result;
  uint64_t v1 = result[1];
  if (v1 != *result)
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = (unint64_t *)(v2 + 24 * v3);
      unint64_t v5 = *v4;
      unint64_t v6 = v4[1];
      float64x2_t v7 = (_OWORD *)(v6 - 16);
      if (v5 != v6 && (unint64_t)v7 > v5)
      {
        unint64_t v9 = v5 + 16;
        do
        {
          long long v10 = *(_OWORD *)(v9 - 16);
          *(_OWORD *)(v9 - 16) = *v7;
          *v7-- = v10;
          BOOL v11 = v9 >= (unint64_t)v7;
          v9 += 16;
        }
        while (!v11);
        uint64_t v2 = *result;
        uint64_t v1 = result[1];
      }
      ++v3;
    }
    while (v3 < 0xAAAAAAAAAAAAAAABLL * ((v1 - v2) >> 3));
  }
  return result;
}

void ClipperLib::SimplifyPolygon(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  unint64_t v5 = &unk_26E943250;
  uint64_t v20 = &unk_26E943298;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  char v23 = 0;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  char v17 = 0;
  char v18 = 0;
  __int16 v27 = 0;
  char v19 = 1;
  ClipperLib::ClipperBase::AddPath((uint64_t)&v20, a1, 0, 1);
  ClipperLib::Clipper::Execute((uint64_t)&v5, 1, a2, a3, a3);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&v5);
}

void sub_235EFABF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ClipperLib::SimplifyPolygons(uint64_t *a1, uint64_t *a2, int a3)
{
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v9 = &unk_26E943250;
  uint64_t v24 = &unk_26E943298;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  char v27 = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  char v21 = 0;
  char v22 = 0;
  __int16 v31 = 0;
  char v23 = 1;
  uint64_t v5 = *a1;
  if (a1[1] != *a1)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      ClipperLib::ClipperBase::AddPath((uint64_t)&v24, v5 + v7, 0, 1);
      ++v8;
      uint64_t v5 = *a1;
      v7 += 24;
    }
    while (v8 < 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3));
  }
  ClipperLib::Clipper::Execute((uint64_t)&v9, 1, a2, a3, a3);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&v9);
}

void sub_235EFAD54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_235EFAD68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ClipperLib::SimplifyPolygons(uint64_t *a1, int a2)
{
}

double ClipperLib::DistanceFromLineSqrd(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v3 = a2[1];
  double v4 = (double)(v3 - a3[1]);
  double v5 = (double)(*a3 - *a2);
  double v6 = ((double)a1[1] - (double)v3) * v5 + ((double)*a1 - (double)*a2) * v4;
  return v6 * v6 / (v4 * v4 + v5 * v5);
}

BOOL ClipperLib::SlopesNearCollinear(uint64_t *a1, uint64_t *a2, uint64_t *a3, double a4)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  if (*a1 - *a2 >= 0) {
    unint64_t v8 = *a1 - *a2;
  }
  else {
    unint64_t v8 = *a2 - *a1;
  }
  uint64_t v9 = v4 - v6;
  if (v4 - v6 >= 0) {
    unint64_t v10 = v4 - v6;
  }
  else {
    unint64_t v10 = v6 - v4;
  }
  if (v8 <= v10)
  {
    uint64_t v18 = a3[1];
    if (v4 <= v6 == v4 < v18)
    {
      if (v4 >= v6 == v6 < v18)
      {
        double v12 = (double)v9;
        double v13 = (double)(v7 - v5);
        double v14 = (double)v5;
        double v15 = (double)v4;
        double v16 = (double)*a3;
        double v17 = (double)v18;
        goto LABEL_19;
      }
      double v19 = (double)(v4 - v18);
      double v20 = (double)(*a3 - v5);
      double v21 = (double)v5;
      double v22 = (double)v4;
      double v23 = (double)v7;
      double v24 = (double)v6;
    }
    else
    {
      double v19 = (double)(v6 - v18);
      double v20 = (double)(*a3 - v7);
      double v21 = (double)v7;
      double v22 = (double)v6;
      double v23 = (double)v5;
      double v24 = (double)v4;
    }
    return ((v23 - v21) * v19 + (v24 - v22) * v20) * ((v23 - v21) * v19 + (v24 - v22) * v20) / (v19 * v19 + v20 * v20) < a4;
  }
  uint64_t v11 = *a3;
  if (v7 >= v5 != *a3 > v5)
  {
    double v12 = (double)(v6 - a3[1]);
    double v13 = (double)(v11 - v7);
    double v14 = (double)v7;
    double v15 = (double)v6;
    double v16 = (double)v5;
    double v17 = (double)v4;
LABEL_19:
    double v27 = (v17 - v15) * v13 + (v16 - v14) * v12;
    return v27 * v27 / (v13 * v13 + v12 * v12) < a4;
  }
  uint64_t v25 = v7 - v5;
  if (v7 <= v5 != v11 > v7)
  {
    double v12 = (double)(v4 - a3[1]);
    double v13 = (double)(*a3 - v5);
    double v14 = (double)v5;
    double v15 = (double)v4;
    double v16 = (double)v7;
    double v17 = (double)v6;
    goto LABEL_19;
  }
  double v12 = (double)v9;
  double v13 = (double)v25;
  double v27 = ((double)v11 - (double)v5) * (double)v9 + ((double)a3[1] - (double)v4) * (double)v25;
  return v27 * v27 / (v13 * v13 + v12 * v12) < a4;
}

BOOL ClipperLib::PointsAreClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  return ((double)a2 - (double)a4) * ((double)a2 - (double)a4) + ((double)a1 - (double)a3) * ((double)a1 - (double)a3) <= a5;
}

uint64_t ClipperLib::ExcludeOp(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(void *)(v1 + 24) = *(void *)(a1 + 24);
  *(void *)(*(void *)(a1 + 24) + 32) = v1;
  *(_DWORD *)uint64_t v1 = 0;
  return v1;
}

void *ClipperLib::CleanPolygon(void *result, void *a2)
{
  uint64_t v2 = result[1] - *result;
  if (v2)
  {
    is_mul_ok(v2 >> 4, 0x28uLL);
    operator new[]();
  }
  a2[1] = *a2;
  return result;
}

void *ClipperLib::CleanPolygon(void *a1)
{
  return ClipperLib::CleanPolygon(a1, a1);
}

uint64_t *ClipperLib::CleanPolygons(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  if (result[1] != *result)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      __n128 result = ClipperLib::CleanPolygon((void *)(v2 + v5), (void *)(*a2 + v5));
      ++v6;
      uint64_t v2 = *v4;
      v5 += 24;
    }
    while (v6 < 0xAAAAAAAAAAAAAAABLL * ((v4[1] - *v4) >> 3));
  }
  return result;
}

uint64_t *ClipperLib::CleanPolygons(uint64_t *result)
{
  uint64_t v1 = *result;
  if (result[1] != *result)
  {
    uint64_t v2 = result;
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      __n128 result = ClipperLib::CleanPolygon((void *)(v1 + v3), (void *)(v1 + v3));
      ++v4;
      uint64_t v1 = *v2;
      v3 += 24;
    }
    while (v4 < 0xAAAAAAAAAAAAAAABLL * ((v2[1] - *v2) >> 3));
  }
  return result;
}

void ClipperLib::Minkowski(uint64_t *a1, uint64_t *a2, char **a3, char a4, unsigned int a5)
{
  uint64_t v97 = *a1;
  uint64_t v98 = a1[1];
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  unint64_t v10 = (v8 - *a2) >> 4;
  uint64_t v109 = 0;
  unint64_t v110 = 0;
  unint64_t v111 = 0;
  std::vector<std::vector<ClipperLib::IntPoint>>::reserve((uint64_t)&v109, v10);
  unsigned int v96 = a5;
  size_t v11 = v98 - v97;
  unint64_t v12 = (v98 - v97) >> 4;
  if ((a4 & 1) == 0)
  {
    if (v8 == v9) {
      goto LABEL_76;
    }
    uint64_t v34 = 0;
    if (v10 <= 1) {
      uint64_t v35 = 1;
    }
    else {
      uint64_t v35 = v10;
    }
    uint64_t v100 = v35;
    while (1)
    {
      int64x2_t v36 = 0;
      __p = 0;
      uint64_t v107 = 0;
      i8 = 0;
      if (v11 >= 0x10)
      {
        if ((v11 & 0x8000000000000000) != 0) {
          _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
        }
        int64x2_t v36 = (int64x2_t *)operator new(v11);
        __p = v36;
        uint64_t v107 = v36;
        i8 = v36[v12].i8;
      }
      uint64_t v37 = *a1;
      if (a1[1] != *a1) {
        break;
      }
LABEL_68:
      float64x2_t v49 = v110;
      if ((unint64_t)v110 >= v111)
      {
        uint64_t v54 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>((char **)&v109, (uint64_t)&__p);
        size_t v11 = v98 - v97;
      }
      else
      {
        *(void *)unint64_t v110 = 0;
        *((void *)v49 + 1) = 0;
        *((void *)v49 + 2) = 0;
        float64x2_t v50 = __p;
        int64_t v51 = (char *)v107 - (unsigned char *)__p;
        if (v107 != __p)
        {
          if (v51 < 0) {
            _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
          }
          float64x2_t v52 = (char *)operator new((char *)v107 - (unsigned char *)__p);
          *(void *)float64x2_t v49 = v52;
          *((void *)v49 + 1) = v52;
          int64x2_t v53 = &v52[16 * (v51 >> 4)];
          *((void *)v49 + 2) = v53;
          memcpy(v52, v50, v51);
          *((void *)v49 + 1) = v53;
        }
        uint64_t v54 = v49 + 24;
        size_t v11 = v98 - v97;
      }
      unint64_t v110 = v54;
      if (__p)
      {
        uint64_t v107 = (int64x2_t *)__p;
        operator delete(__p);
      }
      if (++v34 == v100) {
        goto LABEL_76;
      }
    }
    unint64_t v38 = 0;
    while (1)
    {
      int64x2_t v40 = vsubq_s64(*(int64x2_t *)(*a2 + 16 * v34), *(int64x2_t *)(v37 + 16 * v38));
      if (v36 >= (int64x2_t *)i8) {
        break;
      }
      *int64x2_t v36 = v40;
      uint64_t v39 = v36 + 1;
LABEL_51:
      uint64_t v107 = v39;
      ++v38;
      uint64_t v37 = *a1;
      int64x2_t v36 = v39;
      if (v38 >= (a1[1] - *a1) >> 4) {
        goto LABEL_68;
      }
    }
    uint64_t v41 = (int64x2_t *)__p;
    uint64_t v42 = ((char *)v36 - (unsigned char *)__p) >> 4;
    unint64_t v43 = v42 + 1;
    if ((unint64_t)(v42 + 1) >> 60) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v44 = i8 - (unsigned char *)__p;
    if ((i8 - (unsigned char *)__p) >> 3 > v43) {
      unint64_t v43 = v44 >> 3;
    }
    if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v45 = v43;
    }
    if (v45)
    {
      int64x2_t v102 = v40;
      if (v45 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int64x2_t v46 = (char *)operator new(16 * v45);
      int8x16_t v47 = (int64x2_t *)&v46[16 * v42];
      *int8x16_t v47 = v102;
      uint64_t v39 = v47 + 1;
      if (v36 == v41) {
        goto LABEL_66;
      }
    }
    else
    {
      int64x2_t v46 = 0;
      int8x16_t v47 = (int64x2_t *)(16 * v42);
      int8x16_t v48 = (int64x2_t *)(16 * v42);
      *int8x16_t v48 = v40;
      uint64_t v39 = v48 + 1;
      if (v36 == v41) {
        goto LABEL_66;
      }
    }
    do
    {
      v47[-1] = v36[-1];
      --v47;
      --v36;
    }
    while (v36 != v41);
    int64x2_t v36 = (int64x2_t *)__p;
LABEL_66:
    __p = v47;
    uint64_t v107 = v39;
    i8 = &v46[16 * v45];
    if (v36) {
      operator delete(v36);
    }
    goto LABEL_51;
  }
  if (v8 != v9)
  {
    uint64_t v13 = 0;
    if (v10 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v10;
    }
    uint64_t v99 = v14;
    while (1)
    {
      double v15 = 0;
      __p = 0;
      uint64_t v107 = 0;
      i8 = 0;
      if (v11 >= 0x10)
      {
        if ((v11 & 0x8000000000000000) != 0) {
          _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
        }
        double v15 = (int64x2_t *)operator new(v11);
        __p = v15;
        uint64_t v107 = v15;
        i8 = v15[v12].i8;
      }
      uint64_t v16 = *a1;
      if (a1[1] != *a1) {
        break;
      }
LABEL_31:
      uint64_t v28 = v110;
      if ((unint64_t)v110 >= v111)
      {
        float64x2_t v33 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>((char **)&v109, (uint64_t)&__p);
        size_t v11 = v98 - v97;
      }
      else
      {
        *(void *)unint64_t v110 = 0;
        *((void *)v28 + 1) = 0;
        *((void *)v28 + 2) = 0;
        uint64_t v29 = __p;
        int64_t v30 = (char *)v107 - (unsigned char *)__p;
        if (v107 != __p)
        {
          if (v30 < 0) {
            _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
          }
          __int16 v31 = (char *)operator new((char *)v107 - (unsigned char *)__p);
          *(void *)uint64_t v28 = v31;
          *((void *)v28 + 1) = v31;
          int8x16_t v32 = &v31[16 * (v30 >> 4)];
          *((void *)v28 + 2) = v32;
          memcpy(v31, v29, v30);
          *((void *)v28 + 1) = v32;
        }
        float64x2_t v33 = v28 + 24;
        size_t v11 = v98 - v97;
      }
      unint64_t v110 = v33;
      if (__p)
      {
        uint64_t v107 = (int64x2_t *)__p;
        operator delete(__p);
      }
      if (++v13 == v99) {
        goto LABEL_76;
      }
    }
    unint64_t v17 = 0;
    while (1)
    {
      int64x2_t v19 = vaddq_s64(*(int64x2_t *)(v16 + 16 * v17), *(int64x2_t *)(*a2 + 16 * v13));
      if (v15 >= (int64x2_t *)i8) {
        break;
      }
      *double v15 = v19;
      uint64_t v18 = v15 + 1;
LABEL_14:
      uint64_t v107 = v18;
      ++v17;
      uint64_t v16 = *a1;
      double v15 = v18;
      if (v17 >= (a1[1] - *a1) >> 4) {
        goto LABEL_31;
      }
    }
    double v20 = (int64x2_t *)__p;
    uint64_t v21 = ((char *)v15 - (unsigned char *)__p) >> 4;
    unint64_t v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 60) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v23 = i8 - (unsigned char *)__p;
    if ((i8 - (unsigned char *)__p) >> 3 > v22) {
      unint64_t v22 = v23 >> 3;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v22;
    }
    if (v24)
    {
      int64x2_t v101 = v19;
      if (v24 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v25 = (char *)operator new(16 * v24);
      long long v26 = (int64x2_t *)&v25[16 * v21];
      *long long v26 = v101;
      uint64_t v18 = v26 + 1;
      if (v15 == v20) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v25 = 0;
      long long v26 = (int64x2_t *)(16 * v21);
      double v27 = (int64x2_t *)(16 * v21);
      *double v27 = v19;
      uint64_t v18 = v27 + 1;
      if (v15 == v20) {
        goto LABEL_29;
      }
    }
    do
    {
      v26[-1] = v15[-1];
      --v26;
      --v15;
    }
    while (v15 != v20);
    double v15 = (int64x2_t *)__p;
LABEL_29:
    __p = v26;
    uint64_t v107 = v18;
    i8 = &v25[16 * v24];
    if (v15) {
      operator delete(v15);
    }
    goto LABEL_14;
  }
LABEL_76:
  long long v56 = *a3;
  uint64_t v55 = a3[1];
  if (v55 != *a3)
  {
    uint64_t v57 = a3[1];
    do
    {
      uint64_t v59 = (void *)*((void *)v57 - 3);
      v57 -= 24;
      unint64_t v58 = v59;
      if (v59)
      {
        *((void *)v55 - 2) = v58;
        operator delete(v58);
      }
      uint64_t v55 = v57;
    }
    while (v57 != v56);
  }
  a3[1] = v56;
  std::vector<std::vector<ClipperLib::IntPoint>>::reserve((uint64_t)a3, v10 + v96 + (v10 + v96) * v12);
  unint64_t v105 = v10 - (v96 ^ 1);
  unint64_t v60 = a3;
  if (v105 && v98 != v97)
  {
    unint64_t v61 = 0;
    if (v12 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = (v98 - v97) >> 4;
    }
    do
    {
      unint64_t v63 = 0;
      unint64_t v64 = v61 + 1;
      do
      {
        __p = 0;
        uint64_t v107 = 0;
        i8 = 0;
        float64x2_t v65 = (int64x2_t *)operator new(0x40uLL);
        __p = v65;
        uint64_t v107 = v65;
        i8 = v65[4].i8;
        uint64_t v66 = 24 * (v61 % v10);
        long long v67 = (char *)v109;
        uint64_t v68 = (char *)v109;
        uint64_t v69 = 16 * (v63 % v12);
        *float64x2_t v65 = *(int64x2_t *)(*(void *)((char *)v109 + v66) + v69);
        uint64_t v107 = v65 + 1;
        uint64_t v70 = 24 * (v64 % v10);
        v65[1] = *(int64x2_t *)(*(void *)&v67[v70] + v69);
        uint64_t v107 = v65 + 2;
        uint64_t v71 = 16 * (++v63 % v12);
        v65[2] = *(int64x2_t *)(*(void *)&v67[v70] + v71);
        uint64_t v107 = v65 + 3;
        v65[3] = *(int64x2_t *)(*(void *)&v68[v66] + v71);
        uint64_t v107 = v65 + 4;
        unint64_t v72 = (char *)&v65[4] - (unsigned char *)__p;
        if ((int)(v72 >> 4) >= 3)
        {
          uint64_t v73 = 0;
          uint64_t v74 = (v72 >> 4) - 1;
          uint64_t v75 = (v72 >> 4);
          double v76 = 0.0;
          do
          {
            float64x2_t v77 = vcvtq_f64_s64(*((int64x2_t *)__p + (int)v74));
            float64x2_t v78 = vcvtq_f64_s64(*((int64x2_t *)__p + v73));
            double v76 = vmulq_laneq_f64(vaddq_f64(v77, v78), vsubq_f64(v77, v78), 1).f64[0] + v76;
            LODWORD(v74) = v73++;
          }
          while (v75 != v73);
          if (v76 * -0.5 < 0.0 && __p != &v65[4])
          {
            int8x16_t v79 = v65[3].i8;
            if (&v65[3] > __p)
            {
              int64x2_t v80 = (char *)__p + 16;
              do
              {
                long long v81 = *((_OWORD *)v80 - 1);
                *((_OWORD *)v80 - 1) = *(_OWORD *)v79;
                *(_OWORD *)int8x16_t v79 = v81;
                v79 -= 16;
                BOOL v82 = v80 >= v79;
                v80 += 16;
              }
              while (!v82);
            }
          }
        }
        __int16 v83 = v60[1];
        if (v83 >= v60[2])
        {
          double v89 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>(v60, (uint64_t)&__p);
        }
        else
        {
          *(void *)__int16 v83 = 0;
          *((void *)v83 + 1) = 0;
          *((void *)v83 + 2) = 0;
          float v84 = __p;
          int64_t v85 = (char *)v107 - (unsigned char *)__p;
          if (v107 != __p)
          {
            if (v85 < 0) {
              _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
            }
            uint64_t v86 = v62;
            uint64_t v87 = (char *)operator new((char *)v107 - (unsigned char *)__p);
            *(void *)__int16 v83 = v87;
            *((void *)v83 + 1) = v87;
            uint64_t v88 = &v87[16 * (v85 >> 4)];
            *((void *)v83 + 2) = v88;
            memcpy(v87, v84, v85);
            *((void *)v83 + 1) = v88;
            uint64_t v62 = v86;
          }
          double v89 = v83 + 24;
          unint64_t v60 = a3;
          a3[1] = v83 + 24;
        }
        v60[1] = v89;
        if (__p)
        {
          uint64_t v107 = (int64x2_t *)__p;
          operator delete(__p);
        }
      }
      while (v63 != v62);
      ++v61;
    }
    while (v64 != v105);
  }
  uint64_t v90 = (char *)v109;
  if (v109)
  {
    BOOL v91 = v110;
    double v92 = v109;
    if (v110 != v109)
    {
      uint64_t v93 = v110;
      do
      {
        double v95 = (void *)*((void *)v93 - 3);
        v93 -= 24;
        double v94 = v95;
        if (v95)
        {
          *((void *)v91 - 2) = v94;
          operator delete(v94);
        }
        BOOL v91 = v93;
      }
      while (v93 != v90);
      double v92 = v109;
    }
    unint64_t v110 = v90;
    operator delete(v92);
  }
}

void sub_235EFBB2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  std::vector<std::vector<ClipperLib::IntPoint>>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235EFBB40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,void *a22,uint64_t a23)
{
  uint64_t v25 = *(void **)v23;
  if (*(void *)v23)
  {
    *(void *)(v23 + 8) = v25;
    operator delete(v25);
  }
  a23 = v23;
  if (__p) {
    operator delete(__p);
  }
  std::vector<std::vector<ClipperLib::IntPoint>>::~vector[abi:ne180100](&a22);
  _Unwind_Resume(a1);
}

void ClipperLib::MinkowskiSum(uint64_t *a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  ClipperLib::Minkowski(a1, a2, (char **)a3, 1, a4);
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v8 = &unk_26E943250;
  uint64_t v23 = &unk_26E943298;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  char v26 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  char v20 = 0;
  char v21 = 0;
  char v22 = 0;
  __int16 v30 = 0;
  uint64_t v5 = *(char **)a3;
  if (*(void *)(a3 + 8) != *(void *)a3)
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      ClipperLib::ClipperBase::AddPath((uint64_t)&v23, (uint64_t)&v5[v6], 0, 1);
      ++v7;
      uint64_t v5 = *(char **)a3;
      v6 += 24;
    }
    while (v7 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3));
  }
  ClipperLib::Clipper::Execute((uint64_t)&v8, 1, (uint64_t *)a3, 1, 1);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&v8);
}

void sub_235EFBD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_235EFBD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ClipperLib::TranslatePath(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = *a1;
  unint64_t v9 = (uint64_t)(a1[1] - *a1) >> 4;
  unint64_t v10 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4;
  if (v9 <= v10)
  {
    if (v9 < v10) {
      *(void *)(a2 + 8) = *(void *)a2 + 16 * v9;
    }
  }
  else
  {
    std::vector<ClipperLib::IntPoint>::__append((char **)a2, v9 - v10);
    unint64_t v8 = *a1;
  }
  unint64_t v11 = a1[1];
  if (v11 != v8)
  {
    unint64_t v12 = (uint64_t)(v11 - v8) >> 4;
    long long v13 = *(char **)a2;
    if (v12 <= 1) {
      unint64_t v12 = 1;
    }
    if (v12 < 0x10
      || ((uint64_t v14 = 16 * (v12 - 1), v15 = &v13[v14], v16 = (unint64_t)&v13[v14 + 8], v15 >= v13)
        ? (BOOL v17 = v16 >= (unint64_t)(v13 + 8))
        : (BOOL v17 = 0),
          v17 ? (BOOL v18 = (v12 - 1) >> 60 == 0) : (BOOL v18 = 0),
          !v18
       || ((unint64_t)v13 < v8 + 16 * v12 ? (BOOL v19 = v8 >= (unint64_t)&v13[16 * v12]) : (BOOL v19 = 1), !v19)))
    {
      unint64_t v20 = 0;
LABEL_27:
      v29.i64[0] = a3;
      v29.i64[1] = a4;
      unint64_t v30 = v12 - v20;
      uint64_t v31 = 16 * v20;
      int8x16_t v32 = (int64x2_t *)(v8 + v31);
      float64x2_t v33 = (int64x2_t *)&v13[v31];
      do
      {
        int64x2_t v34 = *v32++;
        *v33++ = vaddq_s64(v34, v29);
        --v30;
      }
      while (v30);
      return;
    }
    unint64_t v20 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    v21.i64[0] = a3;
    v21.i64[1] = a4;
    char v22 = (int64x2_t *)(v8 + 32);
    uint64_t v23 = (int64x2_t *)(v13 + 32);
    unint64_t v24 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      int64x2_t v25 = v22[-2];
      int64x2_t v26 = v22[-1];
      int64x2_t v27 = *v22;
      int64x2_t v28 = v22[1];
      v22 += 4;
      v23[-2] = vaddq_s64(v25, v21);
      v23[-1] = vaddq_s64(v26, v21);
      int64x2_t *v23 = vaddq_s64(v27, v21);
      v23[1] = vaddq_s64(v28, v21);
      v23 += 4;
      v24 -= 4;
    }
    while (v24);
    if (v12 != v20) {
      goto LABEL_27;
    }
  }
}

void ClipperLib::MinkowskiSum(uint64_t *a1, uint64_t *a2, uint64_t *a3, unsigned int a4)
{
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  long long v67 = 0u;
  long long v68 = 0u;
  int64_t v51 = &unk_26E943250;
  uint64_t v66 = &unk_26E943298;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  char v69 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v60 = 0;
  char v63 = 0;
  char v64 = 0;
  char v65 = 0;
  __int16 v73 = 0;
  uint64_t v4 = *a2;
  if (a2[1] != *a2)
  {
    for (unint64_t i = 0; i < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3); ++i)
    {
      __p = 0;
      float64x2_t v49 = 0;
      uint64_t v50 = 0;
      ClipperLib::Minkowski(a1, (uint64_t *)(v4 + 24 * i), (char **)&__p, 1, a4);
      unint64_t v10 = v49;
      if (v49 != __p)
      {
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        long long v13 = (char *)&v51 + *(v51 - 3);
        unint64_t v10 = (char *)__p;
        do
        {
          ClipperLib::ClipperBase::AddPath((uint64_t)v13, (uint64_t)&v10[v11], 0, 1);
          ++v12;
          unint64_t v10 = (char *)__p;
          v11 += 24;
        }
        while (v12 < 0xAAAAAAAAAAAAAAABLL * ((v49 - (unsigned char *)__p) >> 3));
      }
      if (!a4) {
        goto LABEL_39;
      }
      unint64_t v45 = 0;
      int64x2_t v46 = 0;
      uint64_t v47 = 0;
      uint64_t v14 = (unint64_t *)(*a2 + 24 * i);
      int64x2_t v15 = *(int64x2_t *)*a1;
      unint64_t v16 = *v14;
      unint64_t v17 = v14[1];
      if (v17 != *v14)
      {
        int64x2_t v44 = *(int64x2_t *)*a1;
        std::vector<ClipperLib::IntPoint>::__append((char **)&v45, (uint64_t)(v17 - *v14) >> 4);
        unint64_t v16 = *v14;
        unint64_t v17 = v14[1];
        int64x2_t v15 = v44;
      }
      if (v17 != v16)
      {
        unint64_t v18 = (uint64_t)(v17 - v16) >> 4;
        BOOL v19 = (char *)v45;
        if (v18 <= 1) {
          unint64_t v18 = 1;
        }
        if (v18 >= 0x10
          && ((uint64_t v20 = 16 * (v18 - 1), v21 = (char *)v45 + v20, v22 = (char *)v45 + v20 + 8, v21 >= v45)
            ? (BOOL v23 = v22 >= (char *)v45 + 8)
            : (BOOL v23 = 0),
              v23 ? (BOOL v24 = (v18 - 1) >> 60 == 0) : (BOOL v24 = 0),
              v24
           && ((unint64_t)v45 < v16 + 16 * v18 ? (BOOL v25 = v16 >= (unint64_t)v45 + 16 * v18) : (BOOL v25 = 1), v25)))
        {
          int64x2_t v26 = vdupq_lane_s64(v15.i64[0], 0);
          unint64_t v27 = v18 & 0xFFFFFFFFFFFFFFFCLL;
          int64x2_t v28 = vdupq_laneq_s64(v15, 1);
          int64x2_t v29 = (const double *)(v16 + 32);
          unint64_t v30 = (double *)((char *)v45 + 32);
          unint64_t v31 = v18 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            int8x16_t v32 = v29 - 4;
            float64x2x2_t v74 = vld2q_f64(v32);
            float64x2x2_t v75 = vld2q_f64(v29);
            v76.val[0] = (float64x2_t)vaddq_s64((int64x2_t)v74.val[0], v26);
            v76.val[1] = (float64x2_t)vaddq_s64((int64x2_t)v74.val[1], v28);
            float64x2_t v33 = v30 - 4;
            vst2q_f64(v33, v76);
            v74.val[0] = (float64x2_t)vaddq_s64((int64x2_t)v75.val[0], v26);
            v74.val[1] = (float64x2_t)vaddq_s64((int64x2_t)v75.val[1], v28);
            vst2q_f64(v30, v74);
            v30 += 8;
            v29 += 8;
            v31 -= 4;
          }
          while (v31);
          if (v18 == v27) {
            goto LABEL_36;
          }
        }
        else
        {
          unint64_t v27 = 0;
        }
        unint64_t v34 = v18 - v27;
        uint64_t v35 = 16 * v27;
        int64x2_t v36 = (int64x2_t *)&v19[v35];
        uint64_t v37 = (int64x2_t *)(v16 + v35);
        do
        {
          int64x2_t v38 = *v37++;
          *v36++ = vaddq_s64(v38, v15);
          --v34;
        }
        while (v34);
      }
LABEL_36:
      ClipperLib::ClipperBase::AddPath((uint64_t)&v51 + *(v51 - 3), (uint64_t)&v45, 1, 1);
      if (v45)
      {
        int64x2_t v46 = v45;
        operator delete(v45);
      }
      unint64_t v10 = (char *)__p;
LABEL_39:
      if (v10)
      {
        uint64_t v39 = v49;
        unint64_t v9 = v10;
        if (v49 != v10)
        {
          int64x2_t v40 = v49;
          do
          {
            uint64_t v42 = (void *)*((void *)v40 - 3);
            v40 -= 24;
            uint64_t v41 = v42;
            if (v42)
            {
              *(v39 - 2) = v41;
              operator delete(v41);
            }
            uint64_t v39 = v40;
          }
          while (v40 != v10);
          unint64_t v9 = __p;
        }
        float64x2_t v49 = v10;
        operator delete(v9);
      }
      uint64_t v4 = *a2;
    }
  }
  ClipperLib::Clipper::Execute((uint64_t)&v51, 1, a3, 1, 1);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&v51);
}

void sub_235EFC1F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)va);
  _Unwind_Resume(a1);
}

void sub_235EFC208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20)
{
  if (__p)
  {
    operator delete(__p);
    std::vector<std::vector<ClipperLib::IntPoint>>::~vector[abi:ne180100](&a17);
    ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&a20);
    _Unwind_Resume(a1);
  }
  std::vector<std::vector<ClipperLib::IntPoint>>::~vector[abi:ne180100](&a17);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&a20);
  _Unwind_Resume(a1);
}

void ClipperLib::MinkowskiDiff(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  ClipperLib::Minkowski(a1, a2, (char **)a3, 0, 1u);
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  unint64_t v7 = &unk_26E943250;
  char v22 = &unk_26E943298;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  char v25 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  char v19 = 0;
  char v20 = 0;
  char v21 = 0;
  __int16 v29 = 0;
  uint64_t v4 = *(char **)a3;
  if (*(void *)(a3 + 8) != *(void *)a3)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      ClipperLib::ClipperBase::AddPath((uint64_t)&v22, (uint64_t)&v4[v5], 0, 1);
      ++v6;
      uint64_t v4 = *(char **)a3;
      v5 += 24;
    }
    while (v6 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3));
  }
  ClipperLib::Clipper::Execute((uint64_t)&v7, 1, (uint64_t *)a3, 1, 1);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&v7);
}

void sub_235EFC394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_235EFC3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *ClipperLib::AddPolyNodeToPaths(char *result, uint64_t a2, uint64_t a3)
{
  if (a2 != 1)
  {
    uint64_t v5 = result;
    if ((a2 != 2 || !result[68]) && *((void *)result + 1) != *((void *)result + 2))
    {
      unint64_t v6 = *(void **)(a3 + 8);
      if ((unint64_t)v6 >= *(void *)(a3 + 16))
      {
        __n128 result = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>((char **)a3, (uint64_t)(result + 8));
      }
      else
      {
        void *v6 = 0;
        v6[1] = 0;
        v6[2] = 0;
        long long v8 = (unsigned char *)*((void *)result + 1);
        unint64_t v7 = (unsigned char *)*((void *)result + 2);
        int64_t v9 = v7 - v8;
        if (v7 != v8)
        {
          if (v9 < 0) {
            _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
          }
          long long v10 = (char *)operator new(v7 - v8);
          void *v6 = v10;
          v6[1] = v10;
          long long v11 = &v10[16 * (v9 >> 4)];
          v6[2] = v11;
          memcpy(v10, v8, v9);
          v6[1] = v11;
        }
        __n128 result = (char *)(v6 + 3);
        *(void *)(a3 + 8) = v6 + 3;
      }
      *(void *)(a3 + 8) = result;
    }
    uint64_t v12 = *((void *)v5 + 4);
    if ((int)((unint64_t)(*((void *)v5 + 5) - v12) >> 3) >= 1)
    {
      uint64_t v13 = 0;
      do
      {
        __n128 result = (char *)ClipperLib::AddPolyNodeToPaths(*(void *)(v12 + 8 * v13++), a2, a3);
        uint64_t v12 = *((void *)v5 + 4);
      }
      while (v13 < (int)((unint64_t)(*((void *)v5 + 5) - v12) >> 3));
    }
  }
  return result;
}

void sub_235EFC4E8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v4;
    operator delete(v4);
  }
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(exception_object);
}

char *ClipperLib::PolyTreeToPaths(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4 != *a2)
  {
    uint64_t v6 = a2[1];
    do
    {
      long long v8 = *(void **)(v6 - 24);
      v6 -= 24;
      unint64_t v7 = v8;
      if (v8)
      {
        *(void *)(v4 - 16) = v7;
        operator delete(v7);
      }
      uint64_t v4 = v6;
    }
    while (v6 != v5);
    a2[1] = v5;
  }
  int64_t v9 = *(void **)(a1 + 80);
  uint64_t v10 = (*(void *)(a1 + 88) - (void)v9) >> 3;
  if ((int)v10 >= 1) {
    LODWORD(v10) = v10 - (**(void **)(a1 + 32) != *v9);
  }
  std::vector<std::vector<ClipperLib::IntPoint>>::reserve((uint64_t)a2, (int)v10);

  return ClipperLib::AddPolyNodeToPaths((char *)a1, 0, (uint64_t)a2);
}

char *ClipperLib::ClosedPathsFromPolyTree(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4 != *a2)
  {
    uint64_t v6 = a2[1];
    do
    {
      long long v8 = *(void **)(v6 - 24);
      v6 -= 24;
      unint64_t v7 = v8;
      if (v8)
      {
        *(void *)(v4 - 16) = v7;
        operator delete(v7);
      }
      uint64_t v4 = v6;
    }
    while (v6 != v5);
    a2[1] = v5;
  }
  int64_t v9 = *(void **)(a1 + 80);
  uint64_t v10 = (*(void *)(a1 + 88) - (void)v9) >> 3;
  if ((int)v10 >= 1) {
    LODWORD(v10) = v10 - (**(void **)(a1 + 32) != *v9);
  }
  std::vector<std::vector<ClipperLib::IntPoint>>::reserve((uint64_t)a2, (int)v10);

  return ClipperLib::AddPolyNodeToPaths((char *)a1, 2, (uint64_t)a2);
}

void ClipperLib::OpenPathsFromPolyTree(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(char **)a2;
  uint64_t v4 = *(char **)(a2 + 8);
  if (v4 != *(char **)a2)
  {
    uint64_t v6 = *(char **)(a2 + 8);
    do
    {
      long long v8 = (void *)*((void *)v6 - 3);
      v6 -= 24;
      unint64_t v7 = v8;
      if (v8)
      {
        *((void *)v4 - 2) = v7;
        operator delete(v7);
      }
      uint64_t v4 = v6;
    }
    while (v6 != v5);
    *(void *)(a2 + 8) = v5;
  }
  int64_t v9 = *(void **)(a1 + 80);
  uint64_t v10 = (*(void *)(a1 + 88) - (void)v9) >> 3;
  if ((int)v10 >= 1) {
    LODWORD(v10) = v10 - (**(void **)(a1 + 32) != *v9);
  }
  std::vector<std::vector<ClipperLib::IntPoint>>::reserve(a2, (int)v10);
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  if ((int)((unint64_t)(v11 - v12) >> 3) >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v15 = *(void *)(v12 + 8 * v13);
      if (*(unsigned char *)(v15 + 68))
      {
        uint64_t v16 = *(void **)(a2 + 8);
        if ((unint64_t)v16 >= *(void *)(a2 + 16))
        {
          uint64_t v14 = std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>((char **)a2, v15 + 8);
        }
        else
        {
          void *v16 = 0;
          v16[1] = 0;
          v16[2] = 0;
          uint64_t v18 = *(unsigned char **)(v15 + 8);
          uint64_t v17 = *(unsigned char **)(v15 + 16);
          int64_t v19 = v17 - v18;
          if (v17 != v18)
          {
            if (v19 < 0) {
              _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
            }
            char v20 = (char *)operator new(v17 - v18);
            void *v16 = v20;
            v16[1] = v20;
            char v21 = &v20[16 * (v19 >> 4)];
            v16[2] = v21;
            memcpy(v20, v18, v19);
            v16[1] = v21;
          }
          uint64_t v14 = (char *)(v16 + 3);
          *(void *)(a2 + 8) = v16 + 3;
        }
        *(void *)(a2 + 8) = v14;
        uint64_t v12 = *(void *)(a1 + 32);
        uint64_t v11 = *(void *)(a1 + 40);
      }
      ++v13;
    }
    while (v13 < (int)((unint64_t)(v11 - v12) >> 3));
  }
}

void sub_235EFC7D8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v4;
    operator delete(v4);
  }
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(exception_object);
}

void *ClipperLib::operator<<(void *a1)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"(", 1);
  uint64_t v2 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)",", 1);
  uint64_t v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)")", 1);
  return a1;
}

void *ClipperLib::operator<<(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    uint64_t v4 = (v3 - *a2) >> 4;
    uint64_t v5 = v4 - 1;
    if (v4 != 1)
    {
      uint64_t v6 = 0;
      do
      {
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"(", 1);
        unint64_t v7 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)",", 1);
        long long v8 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"), ", 3);
        v6 += 16;
        --v5;
      }
      while (v5);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"(", 1);
    int64_t v9 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)",", 1);
    uint64_t v10 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)")\n", 2);
  }
  return a1;
}

void *ClipperLib::operator<<(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      ClipperLib::operator<<(a1, (void *)(v3 + v5));
      ++v6;
      uint64_t v3 = *a2;
      v5 += 24;
    }
    while (v6 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"\n", 1);
  return a1;
}

uint64_t ClipperLib::clipperException::what(ClipperLib::clipperException *this)
{
  uint64_t result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

char *std::vector<std::vector<ClipperLib::IntPoint>>::__push_back_slow_path<std::vector<ClipperLib::IntPoint> const&>(char **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v5 = v3 - *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 3) + 1;
  if (v6 > 0xAAAAAAAAAAAAAAALL) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  if (0x5555555555555556 * ((a1[2] - v4) >> 3) > v6) {
    unint64_t v6 = 0x5555555555555556 * ((a1[2] - v4) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int64_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    int64_t v9 = 0;
  }
  uint64_t v10 = &v9[8 * (v5 >> 3)];
  uint64_t v11 = &v9[24 * v8];
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  *(void *)uint64_t v10 = 0;
  uint64_t v12 = *(const void **)a2;
  int64_t v13 = *(void *)(a2 + 8) - *(void *)a2;
  if (v13)
  {
    uint64_t v14 = &v9[v5];
    if (v13 < 0) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v15 = (char *)operator new(v13);
    *(void *)uint64_t v10 = v15;
    uint64_t v16 = &v15[16 * (v13 >> 4)];
    *((void *)v14 + 1) = v15;
    *((void *)v14 + 2) = v16;
    memcpy(v15, v12, v13);
    *((void *)v14 + 1) = v16;
  }
  uint64_t v17 = v10 + 24;
  char v25 = v10 + 24;
  if (v3 == v4)
  {
    *a1 = v10;
    a1[1] = v17;
    a1[2] = v11;
  }
  else
  {
    do
    {
      uint64_t v18 = v10;
      *((void *)v10 - 2) = 0;
      *((void *)v10 - 1) = 0;
      long long v19 = *(_OWORD *)(v3 - 24);
      v3 -= 24;
      *(_OWORD *)(v10 - 24) = v19;
      v10 -= 24;
      *((void *)v18 - 1) = *((void *)v3 + 2);
      *(void *)uint64_t v3 = 0;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
    }
    while (v3 != v4);
    char v20 = *a1;
    uint64_t v3 = a1[1];
    uint64_t v17 = v25;
    *a1 = v10;
    a1[1] = v25;
    a1[2] = v11;
    if (v3 != v20)
    {
      char v21 = v3;
      do
      {
        long long v23 = (void *)*((void *)v21 - 3);
        v21 -= 24;
        char v22 = v23;
        if (v23)
        {
          *((void *)v3 - 2) = v22;
          operator delete(v22);
        }
        uint64_t v3 = v21;
      }
      while (v21 != v20);
      uint64_t v3 = v20;
    }
  }
  if (v3) {
    operator delete(v3);
  }
  return v17;
}

void sub_235EFCD1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v3 + 8) = v5;
    operator delete(v5);
  }
  std::__split_buffer<std::vector<ClipperLib::IntPoint>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::vector<ClipperLib::IntPoint>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = v2 - 24;
        uint64_t v4 = *(void **)(v2 - 24);
        *(void *)(a1 + 16) = v2 - 24;
        if (!v4) {
          break;
        }
        *(void *)(v2 - 16) = v4;
        operator delete(v4);
        uint64_t v2 = *(void *)(a1 + 16);
        if (v2 == v3) {
          goto LABEL_6;
        }
      }
      v2 -= 24;
    }
    while (v5 != v3);
  }
LABEL_6:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 std::__introsort<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *,false>(unint64_t a1, long long *a2, uint64_t a3, uint64_t a4, char a5, __n128 result)
{
  while (2)
  {
    uint64_t v12 = (int64_t *)a2 - 3;
    int64_t v13 = a2 - 3;
    uint64_t v14 = (uint64_t *)a2 - 9;
    unint64_t v15 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v15;
          uint64_t v16 = (uint64_t)a2 - v15;
          unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v15) >> 3);
          if (v7 || !v6)
          {
            switch(v17)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                if (*(void *)v15 >= *v12) {
                  return result;
                }
                goto LABEL_101;
              case 3uLL:
                unint64_t v91 = v15 + 24;
                uint64_t v92 = *(void *)(v15 + 24);
                uint64_t v93 = *v12;
                if (*(void *)v15 < v92)
                {
                  if (v92 >= v93)
                  {
                    uint64_t v170 = *(void *)(v15 + 16);
                    __n128 v146 = *(__n128 *)v15;
                    *(_OWORD *)unint64_t v15 = *(_OWORD *)v91;
                    *(void *)(v15 + 16) = *(void *)(v15 + 40);
                    uint64_t result = v146;
                    *(__n128 *)unint64_t v91 = v146;
                    *(void *)(v15 + 40) = v170;
                    if (*(void *)(v15 + 24) < *v12)
                    {
                      uint64_t result = *(__n128 *)v91;
                      uint64_t v115 = *(void *)(v15 + 40);
                      uint64_t v116 = *((void *)a2 - 1);
                      *(_OWORD *)unint64_t v91 = *(_OWORD *)v12;
                      *(void *)(v15 + 40) = v116;
                      *((void *)a2 - 1) = v115;
                      *(__n128 *)uint64_t v12 = result;
                    }
                  }
                  else
                  {
LABEL_101:
                    uint64_t v167 = *(void *)(v15 + 16);
                    __n128 v141 = *(__n128 *)v15;
                    long long v94 = *(_OWORD *)v12;
                    *(void *)(v15 + 16) = *((void *)a2 - 1);
                    *(_OWORD *)unint64_t v15 = v94;
                    uint64_t result = v141;
                    *((void *)a2 - 1) = v167;
                    *(__n128 *)uint64_t v12 = v141;
                  }
                  return result;
                }
                if (v92 >= v93) {
                  return result;
                }
                uint64_t result = *(__n128 *)v91;
                uint64_t v108 = *(void *)(v15 + 40);
                uint64_t v109 = *((void *)a2 - 1);
                *(_OWORD *)unint64_t v91 = *(_OWORD *)v12;
                *(void *)(v15 + 40) = v109;
                *((void *)a2 - 1) = v108;
                *(__n128 *)uint64_t v12 = result;
                goto LABEL_149;
              case 4uLL:
                unint64_t v91 = v15 + 24;
                uint64_t v95 = *(void *)(v15 + 24);
                unsigned int v96 = (__n128 *)(v15 + 48);
                uint64_t v97 = *(void *)(v15 + 48);
                if (*(void *)v15 >= v95)
                {
                  if (v95 < v97)
                  {
                    uint64_t v110 = *(void *)(v15 + 40);
                    uint64_t result = *(__n128 *)v91;
                    *(__n128 *)unint64_t v91 = *v96;
                    *(void *)(v15 + 40) = *(void *)(v15 + 64);
                    *unsigned int v96 = result;
                    *(void *)(v15 + 64) = v110;
                    if (*(void *)v15 < *(void *)(v15 + 24))
                    {
                      uint64_t v169 = *(void *)(v15 + 16);
                      __n128 v144 = *(__n128 *)v15;
                      *(_OWORD *)unint64_t v15 = *(_OWORD *)v91;
                      *(void *)(v15 + 16) = *(void *)(v15 + 40);
                      uint64_t result = v144;
                      *(__n128 *)unint64_t v91 = v144;
                      *(void *)(v15 + 40) = v169;
                    }
                  }
                }
                else
                {
                  if (v95 >= v97)
                  {
                    uint64_t v171 = *(void *)(v15 + 16);
                    __n128 v147 = *(__n128 *)v15;
                    *(_OWORD *)unint64_t v15 = *(_OWORD *)v91;
                    *(void *)(v15 + 16) = *(void *)(v15 + 40);
                    uint64_t result = v147;
                    *(__n128 *)unint64_t v91 = v147;
                    *(void *)(v15 + 40) = v171;
                    if (*(void *)(v15 + 24) >= v97) {
                      goto LABEL_146;
                    }
                    uint64_t v98 = *(void *)(v15 + 40);
                    uint64_t result = *(__n128 *)v91;
                    *(__n128 *)unint64_t v91 = *v96;
                    *(void *)(v15 + 40) = *(void *)(v15 + 64);
                    *unsigned int v96 = result;
                  }
                  else
                  {
                    uint64_t v168 = *(void *)(v15 + 16);
                    __n128 v142 = *(__n128 *)v15;
                    *(__n128 *)unint64_t v15 = *v96;
                    *(void *)(v15 + 16) = *(void *)(v15 + 64);
                    uint64_t result = v142;
                    *unsigned int v96 = v142;
                    uint64_t v98 = v168;
                  }
                  *(void *)(v15 + 64) = v98;
                }
LABEL_146:
                if ((int64_t)v96->n128_u64[0] < *v12)
                {
                  uint64_t result = *v96;
                  uint64_t v117 = *(void *)(v15 + 64);
                  uint64_t v118 = *((void *)a2 - 1);
                  *unsigned int v96 = *(__n128 *)v12;
                  *(void *)(v15 + 64) = v118;
                  *((void *)a2 - 1) = v117;
                  *(__n128 *)uint64_t v12 = result;
                  if (*(void *)v91 < (int64_t)v96->n128_u64[0])
                  {
                    uint64_t v119 = *(void *)(v15 + 40);
                    uint64_t result = *(__n128 *)v91;
                    *(__n128 *)unint64_t v91 = *v96;
                    *(void *)(v15 + 40) = *(void *)(v15 + 64);
                    *unsigned int v96 = result;
                    *(void *)(v15 + 64) = v119;
LABEL_149:
                    if (*(void *)v15 < *(void *)(v15 + 24))
                    {
                      uint64_t v172 = *(void *)(v15 + 16);
                      __n128 v148 = *(__n128 *)v15;
                      *(_OWORD *)unint64_t v15 = *(_OWORD *)v91;
                      *(void *)(v15 + 16) = *(void *)(v91 + 16);
                      uint64_t result = v148;
                      *(__n128 *)unint64_t v91 = v148;
                      *(void *)(v91 + 16) = v172;
                    }
                  }
                }
                break;
              case 5uLL:
                result.n128_u64[0] = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__n128 *)v15, (__n128 *)(v15 + 24), (uint64_t *)(v15 + 48), v15 + 72, (uint64_t)a2 - 24, result).n128_u64[0];
                return result;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v16 <= 575)
          {
            uint64_t v99 = (long long *)(v15 + 24);
            BOOL v101 = (long long *)v15 == a2 || v99 == a2;
            if (a5)
            {
              if (!v101)
              {
                uint64_t v102 = 0;
                int64x2_t v103 = (__n128 *)v15;
                do
                {
                  uint64_t v105 = *(void *)v99;
                  if ((int64_t)v103->n128_u64[0] < *(void *)v99)
                  {
                    unint64_t v106 = 0;
                    __n128 v143 = v103[2];
                    do
                    {
                      uint64_t v107 = (char *)v103 + v106;
                      *(__n128 *)(v107 + 24) = *(__n128 *)((char *)v103 + v106);
                      *((void *)v107 + 5) = v103[1].n128_u64[v106 / 8];
                      if (v102 == v106)
                      {
                        int64_t v104 = (void *)v15;
                        goto LABEL_117;
                      }
                      v106 -= 24;
                    }
                    while (*((void *)v107 - 3) < v105);
                    int64_t v104 = (void *)((char *)v99 + v106);
LABEL_117:
                    *int64_t v104 = v105;
                    uint64_t result = v143;
                    *(__n128 *)(v104 + 1) = v143;
                  }
                  uint64_t v99 = (long long *)((char *)v99 + 24);
                  int64x2_t v103 = (__n128 *)((char *)v103 + 24);
                  v102 -= 24;
                }
                while (v99 != a2);
              }
            }
            else if (!v101)
            {
              do
              {
                unint64_t v111 = v99;
                uint64_t v112 = *(void *)(a1 + 24);
                if (*(void *)a1 < v112)
                {
                  __n128 v145 = *(__n128 *)(a1 + 32);
                  uint64_t v113 = v111;
                  do
                  {
                    *uint64_t v113 = *(long long *)((char *)v113 - 24);
                    *((void *)v113 + 2) = *((void *)v113 - 1);
                    uint64_t v114 = *((void *)v113 - 6);
                    uint64_t v113 = (long long *)((char *)v113 - 24);
                  }
                  while (v114 < v112);
                  *(void *)uint64_t v113 = v112;
                  uint64_t result = v145;
                  *(long long *)((char *)v113 + 8) = (__int128)v145;
                }
                uint64_t v99 = (long long *)((char *)v111 + 24);
                a1 = (unint64_t)v111;
              }
              while ((long long *)((char *)v111 + 24) != a2);
            }
            return result;
          }
          if (!a4)
          {
            if ((long long *)v15 != a2)
            {
              std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *,ClipperLib::LocalMinimum *>(v15, a2, a2);
            }
            return result;
          }
          uint64_t v18 = (__n128 *)(v15 + 24 * (v17 >> 1));
          int64_t v19 = *v12;
          if ((unint64_t)v16 >= 0xC01) {
            break;
          }
          uint64_t v22 = *(void *)v15;
          if ((int64_t)v18->n128_u64[0] < *(void *)v15)
          {
            if (v22 >= v19)
            {
              unint64_t v157 = v18[1].n128_u64[0];
              __n128 v131 = *v18;
              __n128 v43 = *(__n128 *)v15;
              v18[1].n128_u64[0] = *(void *)(v15 + 16);
              __n128 *v18 = v43;
              *(void *)(v15 + 16) = v157;
              *(__n128 *)unint64_t v15 = v131;
              if (*(void *)v15 >= *v12) {
                goto LABEL_32;
              }
              unint64_t v150 = *(void *)(v15 + 16);
              __n128 v124 = *(__n128 *)v15;
              __n128 v44 = *(__n128 *)v12;
              *(void *)(v15 + 16) = *((void *)a2 - 1);
              *(__n128 *)unint64_t v15 = v44;
            }
            else
            {
              unint64_t v150 = v18[1].n128_u64[0];
              __n128 v124 = *v18;
              __n128 v23 = *(__n128 *)v12;
              v18[1].n128_u64[0] = *((void *)a2 - 1);
              __n128 *v18 = v23;
            }
            *((void *)a2 - 1) = v150;
            *(__n128 *)uint64_t v12 = v124;
LABEL_32:
            --a4;
            uint64_t v28 = *(void *)v15;
            if (a5) {
              goto LABEL_57;
            }
            goto LABEL_56;
          }
          if (v22 >= v19) {
            goto LABEL_32;
          }
          uint64_t v153 = *(void *)(v15 + 16);
          __n128 v127 = *(__n128 *)v15;
          __n128 v26 = *(__n128 *)v12;
          *(void *)(v15 + 16) = *((void *)a2 - 1);
          *(__n128 *)unint64_t v15 = v26;
          *((void *)a2 - 1) = v153;
          *(__n128 *)uint64_t v12 = v127;
          if ((int64_t)v18->n128_u64[0] >= *(void *)v15) {
            goto LABEL_32;
          }
          unint64_t v154 = v18[1].n128_u64[0];
          __n128 v128 = *v18;
          __n128 v27 = *(__n128 *)v15;
          v18[1].n128_u64[0] = *(void *)(v15 + 16);
          __n128 *v18 = v27;
          *(void *)(v15 + 16) = v154;
          *(__n128 *)unint64_t v15 = v128;
          --a4;
          uint64_t v28 = *(void *)v15;
          if (a5) {
            goto LABEL_57;
          }
LABEL_56:
          if (v28 < *(void *)(v15 - 24)) {
            goto LABEL_57;
          }
          __n128 v122 = *(__n128 *)(v15 + 8);
          if (*v12 < v28)
          {
            do
            {
              uint64_t v83 = *(void *)(v15 + 24);
              v15 += 24;
            }
            while (v83 >= v28);
          }
          else
          {
            unint64_t v84 = v15 + 24;
            do
            {
              unint64_t v15 = v84;
              if (v84 >= (unint64_t)a2) {
                break;
              }
              v84 += 24;
            }
            while (*(void *)v15 >= v28);
          }
          int64_t v85 = a2;
          if (v15 < (unint64_t)a2)
          {
            int64_t v85 = a2;
            do
            {
              uint64_t v86 = *((void *)v85 - 3);
              int64_t v85 = (long long *)((char *)v85 - 24);
            }
            while (v86 < v28);
          }
          while (v15 < (unint64_t)v85)
          {
            uint64_t v166 = *(void *)(v15 + 16);
            __n128 v140 = *(__n128 *)v15;
            __n128 v87 = (__n128)*v85;
            *(void *)(v15 + 16) = *((void *)v85 + 2);
            *(__n128 *)unint64_t v15 = v87;
            *((void *)v85 + 2) = v166;
            *int64_t v85 = (__int128)v140;
            do
            {
              uint64_t v88 = *(void *)(v15 + 24);
              v15 += 24;
            }
            while (v88 >= v28);
            do
            {
              uint64_t v89 = *((void *)v85 - 3);
              int64_t v85 = (long long *)((char *)v85 - 24);
            }
            while (v89 < v28);
          }
          BOOL v6 = v15 - 24 >= a1;
          BOOL v7 = v15 - 24 == a1;
          if (v15 - 24 != a1)
          {
            long long v90 = *(_OWORD *)(v15 - 24);
            *(void *)(a1 + 16) = *(void *)(v15 - 8);
            *(_OWORD *)a1 = v90;
          }
          a5 = 0;
          *(void *)(v15 - 24) = v28;
          uint64_t result = v122;
          *(__n128 *)(v15 - 16) = v122;
        }
        int64_t v20 = v18->n128_u64[0];
        if (*(void *)v15 >= (int64_t)v18->n128_u64[0])
        {
          if (v20 < v19)
          {
            unint64_t v151 = v18[1].n128_u64[0];
            __n128 v125 = *v18;
            __n128 v24 = *(__n128 *)v12;
            v18[1].n128_u64[0] = *((void *)a2 - 1);
            __n128 *v18 = v24;
            *((void *)a2 - 1) = v151;
            *(__n128 *)uint64_t v12 = v125;
            if (*(void *)v15 < (int64_t)v18->n128_u64[0])
            {
              unint64_t v152 = *(void *)(v15 + 16);
              __n128 v126 = *(__n128 *)v15;
              __n128 v25 = *v18;
              *(void *)(v15 + 16) = v18[1].n128_u64[0];
              *(__n128 *)unint64_t v15 = v25;
              v18[1].n128_u64[0] = v152;
              __n128 *v18 = v126;
            }
          }
        }
        else
        {
          if (v20 >= v19)
          {
            unint64_t v155 = *(void *)(v15 + 16);
            __n128 v129 = *(__n128 *)v15;
            __n128 v29 = *v18;
            *(void *)(v15 + 16) = v18[1].n128_u64[0];
            *(__n128 *)unint64_t v15 = v29;
            v18[1].n128_u64[0] = v155;
            __n128 *v18 = v129;
            if ((int64_t)v18->n128_u64[0] >= *v12) {
              goto LABEL_23;
            }
            unint64_t v149 = v18[1].n128_u64[0];
            __n128 v123 = *v18;
            __n128 v30 = *(__n128 *)v12;
            v18[1].n128_u64[0] = *((void *)a2 - 1);
            __n128 *v18 = v30;
          }
          else
          {
            unint64_t v149 = *(void *)(v15 + 16);
            __n128 v123 = *(__n128 *)v15;
            __n128 v21 = *(__n128 *)v12;
            *(void *)(v15 + 16) = *((void *)a2 - 1);
            *(__n128 *)unint64_t v15 = v21;
          }
          *((void *)a2 - 1) = v149;
          *(__n128 *)uint64_t v12 = v123;
        }
LABEL_23:
        unint64_t v31 = (long long *)(v15 + 24);
        unint64_t v32 = v15 + 24 * (v17 >> 1);
        float64x2_t v33 = (__n128 *)(v32 - 24);
        uint64_t v34 = *(void *)(v32 - 24);
        uint64_t v35 = *(void *)v13;
        if (*(void *)(v15 + 24) >= v34)
        {
          if (v34 < v35)
          {
            uint64_t v156 = *(void *)(v32 - 8);
            long long v130 = (__int128)*v33;
            long long v39 = *v13;
            *(void *)(v32 - 8) = *((void *)a2 - 4);
            __n128 *v33 = (__n128)v39;
            *((void *)a2 - 4) = v156;
            *int64_t v13 = v130;
            if (*(void *)v31 < (int64_t)v33->n128_u64[0])
            {
              long long v40 = *v31;
              uint64_t v41 = *(void *)(v15 + 40);
              uint64_t v42 = *(void *)(v32 - 8);
              *unint64_t v31 = (__int128)*v33;
              *(void *)(v15 + 40) = v42;
              *(void *)(v32 - 8) = v41;
              __n128 *v33 = (__n128)v40;
            }
          }
        }
        else
        {
          if (v34 >= v35)
          {
            long long v45 = *v31;
            uint64_t v46 = *(void *)(v15 + 40);
            uint64_t v47 = *(void *)(v32 - 8);
            *unint64_t v31 = (__int128)*v33;
            *(void *)(v15 + 40) = v47;
            *(void *)(v32 - 8) = v46;
            __n128 *v33 = (__n128)v45;
            if ((int64_t)v33->n128_u64[0] >= *(void *)v13) {
              goto LABEL_37;
            }
            uint64_t v158 = *(void *)(v32 - 8);
            long long v132 = (__int128)*v33;
            long long v48 = *v13;
            *(void *)(v32 - 8) = *((void *)a2 - 4);
            __n128 *v33 = (__n128)v48;
            long long v36 = v132;
            *((void *)a2 - 4) = v158;
          }
          else
          {
            long long v36 = *v31;
            uint64_t v37 = *(void *)(v15 + 40);
            uint64_t v38 = *((void *)a2 - 4);
            *unint64_t v31 = *v13;
            *(void *)(v15 + 40) = v38;
            *((void *)a2 - 4) = v37;
          }
          *int64_t v13 = v36;
        }
LABEL_37:
        float64x2_t v49 = (__n128 *)(v15 + 48);
        uint64_t v52 = *(void *)(v32 + 24);
        uint64_t v50 = (__n128 *)(v32 + 24);
        uint64_t v51 = v52;
        uint64_t v53 = *v14;
        if (*(void *)(v15 + 48) >= v52)
        {
          if (v51 < v53)
          {
            uint64_t v159 = v50[1].n128_i64[0];
            __n128 v133 = *v50;
            __n128 v57 = *(__n128 *)v14;
            v50[1].n128_u64[0] = *((void *)a2 - 7);
            *uint64_t v50 = v57;
            *((void *)a2 - 7) = v159;
            *(__n128 *)uint64_t v14 = v133;
            if ((int64_t)v49->n128_u64[0] < (int64_t)v50->n128_u64[0])
            {
              __n128 v58 = *v49;
              unint64_t v59 = *(void *)(v15 + 64);
              uint64_t v60 = v50[1].n128_i64[0];
              *float64x2_t v49 = *v50;
              *(void *)(v15 + 64) = v60;
              v50[1].n128_u64[0] = v59;
              *uint64_t v50 = v58;
            }
          }
        }
        else
        {
          if (v51 >= v53)
          {
            __n128 v61 = *v49;
            unint64_t v62 = *(void *)(v15 + 64);
            uint64_t v63 = v50[1].n128_i64[0];
            *float64x2_t v49 = *v50;
            *(void *)(v15 + 64) = v63;
            v50[1].n128_u64[0] = v62;
            *uint64_t v50 = v61;
            if ((int64_t)v50->n128_u64[0] >= *v14) {
              goto LABEL_46;
            }
            uint64_t v160 = v50[1].n128_i64[0];
            __n128 v134 = *v50;
            __n128 v64 = *(__n128 *)v14;
            v50[1].n128_u64[0] = *((void *)a2 - 7);
            *uint64_t v50 = v64;
            __n128 v54 = v134;
            *((void *)a2 - 7) = v160;
          }
          else
          {
            __n128 v54 = *v49;
            uint64_t v55 = *(void *)(v15 + 64);
            uint64_t v56 = *((void *)a2 - 7);
            *float64x2_t v49 = *(__n128 *)v14;
            *(void *)(v15 + 64) = v56;
            *((void *)a2 - 7) = v55;
          }
          *(__n128 *)uint64_t v14 = v54;
        }
LABEL_46:
        int64_t v65 = v18->n128_u64[0];
        int64_t v66 = v50->n128_u64[0];
        if ((int64_t)v33->n128_u64[0] >= (int64_t)v18->n128_u64[0])
        {
          if (v65 < v66)
          {
            unint64_t v162 = v18[1].n128_u64[0];
            __n128 v136 = *v18;
            __n128 *v18 = *v50;
            v18[1].n128_u64[0] = v50[1].n128_u64[0];
            v50[1].n128_u64[0] = v162;
            *uint64_t v50 = v136;
            if ((int64_t)v33->n128_u64[0] < (int64_t)v18->n128_u64[0])
            {
              unint64_t v163 = v33[1].n128_u64[0];
              __n128 v137 = *v33;
              __n128 *v33 = *v18;
              v33[1].n128_u64[0] = v18[1].n128_u64[0];
              v18[1].n128_u64[0] = v163;
              __n128 *v18 = v137;
            }
          }
        }
        else
        {
          if (v65 >= v66)
          {
            unint64_t v164 = v33[1].n128_u64[0];
            __n128 v138 = *v33;
            __n128 *v33 = *v18;
            v33[1].n128_u64[0] = v18[1].n128_u64[0];
            v18[1].n128_u64[0] = v164;
            __n128 *v18 = v138;
            if ((int64_t)v18->n128_u64[0] >= (int64_t)v50->n128_u64[0]) {
              goto LABEL_55;
            }
            unint64_t v161 = v18[1].n128_u64[0];
            __n128 v135 = *v18;
            __n128 *v18 = *v50;
            v18[1].n128_u64[0] = v50[1].n128_u64[0];
          }
          else
          {
            unint64_t v161 = v33[1].n128_u64[0];
            __n128 v135 = *v33;
            __n128 *v33 = *v50;
            v33[1].n128_u64[0] = v50[1].n128_u64[0];
          }
          v50[1].n128_u64[0] = v161;
          *uint64_t v50 = v135;
        }
LABEL_55:
        unint64_t v165 = *(void *)(v15 + 16);
        __n128 v139 = *(__n128 *)v15;
        __n128 v67 = *v18;
        *(void *)(v15 + 16) = v18[1].n128_u64[0];
        *(__n128 *)unint64_t v15 = v67;
        v18[1].n128_u64[0] = v165;
        __n128 *v18 = v139;
        --a4;
        uint64_t v28 = *(void *)v15;
        if ((a5 & 1) == 0) {
          goto LABEL_56;
        }
LABEL_57:
        __n128 v121 = *(__n128 *)(v15 + 8);
        unint64_t v68 = v15;
        do
        {
          unint64_t v69 = v68;
          uint64_t v70 = *(void *)(v68 + 24);
          v68 += 24;
        }
        while (v28 < v70);
        uint64_t v71 = a2;
        if (v69 == v15)
        {
          uint64_t v71 = a2;
          do
          {
            if (v68 >= (unint64_t)v71) {
              break;
            }
            uint64_t v73 = *((void *)v71 - 3);
            uint64_t v71 = (long long *)((char *)v71 - 24);
          }
          while (v28 >= v73);
        }
        else
        {
          do
          {
            uint64_t v72 = *((void *)v71 - 3);
            uint64_t v71 = (long long *)((char *)v71 - 24);
          }
          while (v28 >= v72);
        }
        unint64_t v15 = v68;
        if (v68 < (unint64_t)v71)
        {
          unint64_t v74 = (unint64_t)v71;
          do
          {
            __n128 v75 = *(__n128 *)v15;
            uint64_t v76 = *(void *)(v15 + 16);
            uint64_t v77 = *(void *)(v74 + 16);
            *(_OWORD *)unint64_t v15 = *(_OWORD *)v74;
            *(void *)(v15 + 16) = v77;
            *(void *)(v74 + 16) = v76;
            *(__n128 *)unint64_t v74 = v75;
            do
            {
              uint64_t v78 = *(void *)(v15 + 24);
              v15 += 24;
            }
            while (v28 < v78);
            do
            {
              uint64_t v79 = *(void *)(v74 - 24);
              v74 -= 24;
            }
            while (v28 >= v79);
          }
          while (v15 < v74);
        }
        if (v15 - 24 != a1)
        {
          long long v80 = *(_OWORD *)(v15 - 24);
          *(void *)(a1 + 16) = *(void *)(v15 - 8);
          *(_OWORD *)a1 = v80;
        }
        *(void *)(v15 - 24) = v28;
        *(__n128 *)(v15 - 16) = v121;
        if (v68 >= (unint64_t)v71) {
          break;
        }
LABEL_76:
        std::__introsort<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *,false>(a1, v15 - 24, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v81 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__n128 *)a1, (__int8 *)(v15 - 24), v121);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__n128 *)v15, (__int8 *)a2, v82))
      {
        break;
      }
      if (!v81) {
        goto LABEL_76;
      }
    }
    a2 = (long long *)(v15 - 24);
    if (!v81) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(__n128 *a1, __int8 *a2, __n128 a3)
{
  switch(0xAAAAAAAAAAAAAAABLL * ((a2 - (__int8 *)a1) >> 3))
  {
    case 0uLL:
    case 1uLL:
      return 1;
    case 2uLL:
      uint64_t v12 = *((void *)a2 - 3);
      uint64_t v11 = (__n128 *)(a2 - 24);
      if ((int64_t)a1->n128_u64[0] < v12) {
        goto LABEL_10;
      }
      return 1;
    case 3uLL:
      int64_t v13 = (__n128 *)((char *)a1 + 24);
      uint64_t v14 = a1[1].n128_i64[1];
      uint64_t v16 = *((void *)a2 - 3);
      uint64_t v11 = (__n128 *)(a2 - 24);
      uint64_t v15 = v16;
      if ((int64_t)a1->n128_u64[0] < v14)
      {
        if (v14 < v15)
        {
LABEL_10:
          uint64_t v17 = a1[1].n128_i64[0];
          __n128 v18 = *a1;
          unint64_t v19 = v11[1].n128_u64[0];
          *a1 = *v11;
          a1[1].n128_u64[0] = v19;
          __n128 *v11 = v18;
          v11[1].n128_u64[0] = v17;
          return 1;
        }
        uint64_t v50 = a1[1].n128_i64[0];
        __n128 v51 = *a1;
        *a1 = *v13;
        a1[1].n128_u64[0] = a1[2].n128_u64[1];
        *int64_t v13 = v51;
        a1[2].n128_u64[1] = v50;
        if ((int64_t)a1[1].n128_u64[1] < (int64_t)v11->n128_u64[0])
        {
          uint64_t v52 = a1[2].n128_i64[1];
          __n128 v53 = *v13;
          unint64_t v54 = v11[1].n128_u64[0];
          *int64_t v13 = *v11;
          a1[2].n128_u64[1] = v54;
          __n128 *v11 = v53;
          v11[1].n128_u64[0] = v52;
          return 1;
        }
        return 1;
      }
      if (v14 >= v15) {
        return 1;
      }
      uint64_t v31 = a1[2].n128_i64[1];
      __n128 v32 = *v13;
      unint64_t v33 = v11[1].n128_u64[0];
      *int64_t v13 = *v11;
      a1[2].n128_u64[1] = v33;
      __n128 *v11 = v32;
      v11[1].n128_u64[0] = v31;
      if ((int64_t)a1->n128_u64[0] >= (int64_t)a1[1].n128_u64[1]) {
        return 1;
      }
      goto LABEL_45;
    case 4uLL:
      int64_t v13 = (__n128 *)((char *)a1 + 24);
      uint64_t v20 = a1[1].n128_i64[1];
      __n128 v21 = a1 + 3;
      uint64_t v22 = a1[3].n128_i64[0];
      __n128 v23 = (__n128 *)(a2 - 24);
      uint64_t v24 = a1->n128_u64[0];
      if ((int64_t)a1->n128_u64[0] >= v20)
      {
        if (v20 < v22)
        {
          uint64_t v34 = a1[2].n128_i64[1];
          __n128 v35 = *v13;
          *int64_t v13 = *v21;
          a1[2].n128_u64[1] = a1[4].n128_u64[0];
          *__n128 v21 = v35;
          a1[4].n128_u64[0] = v34;
          if (v24 < (int64_t)v13->n128_u64[0])
          {
            uint64_t v36 = a1[1].n128_i64[0];
            __n128 v37 = *a1;
            *a1 = *v13;
            a1[1].n128_u64[0] = a1[2].n128_u64[1];
            *int64_t v13 = v37;
            a1[2].n128_u64[1] = v36;
          }
        }
      }
      else
      {
        if (v20 >= v22)
        {
          uint64_t v55 = a1[1].n128_i64[0];
          __n128 v56 = *a1;
          *a1 = *v13;
          a1[1].n128_u64[0] = a1[2].n128_u64[1];
          *int64_t v13 = v56;
          a1[2].n128_u64[1] = v55;
          if ((int64_t)a1[1].n128_u64[1] >= v22) {
            goto LABEL_42;
          }
          uint64_t v25 = a1[2].n128_i64[1];
          __n128 v26 = *v13;
          *int64_t v13 = *v21;
          a1[2].n128_u64[1] = a1[4].n128_u64[0];
        }
        else
        {
          uint64_t v25 = a1[1].n128_i64[0];
          __n128 v26 = *a1;
          *a1 = *v21;
          a1[1].n128_u64[0] = a1[4].n128_u64[0];
        }
        *__n128 v21 = v26;
        a1[4].n128_u64[0] = v25;
      }
LABEL_42:
      if ((int64_t)v21->n128_u64[0] >= (int64_t)v23->n128_u64[0]) {
        return 1;
      }
      uint64_t v57 = a1[4].n128_i64[0];
      __n128 v58 = *v21;
      unint64_t v59 = *((void *)a2 - 1);
      *__n128 v21 = *v23;
      a1[4].n128_u64[0] = v59;
      __n128 *v23 = v58;
      *((void *)a2 - 1) = v57;
      if ((int64_t)v13->n128_u64[0] >= (int64_t)v21->n128_u64[0]) {
        return 1;
      }
      uint64_t v60 = a1[2].n128_i64[1];
      __n128 v61 = *v13;
      *int64_t v13 = *v21;
      a1[2].n128_u64[1] = a1[4].n128_u64[0];
      *__n128 v21 = v61;
      a1[4].n128_u64[0] = v60;
      if ((int64_t)a1->n128_u64[0] >= (int64_t)a1[1].n128_u64[1]) {
        return 1;
      }
LABEL_45:
      uint64_t v62 = a1[1].n128_i64[0];
      __n128 v63 = *a1;
      *a1 = *v13;
      a1[1].n128_u64[0] = v13[1].n128_u64[0];
      *int64_t v13 = v63;
      v13[1].n128_u64[0] = v62;
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(a1, (__n128 *)((char *)a1 + 24), (uint64_t *)&a1[3], (uint64_t)&a1[4].n128_i64[1], (uint64_t)(a2 - 24), a3);
      return 1;
    default:
      uint64_t v4 = a1 + 3;
      uint64_t v5 = a1[3].n128_i64[0];
      BOOL v6 = (__n128 *)((char *)a1 + 24);
      uint64_t v7 = a1[1].n128_i64[1];
      int64_t v8 = a1->n128_u64[0];
      if ((int64_t)a1->n128_u64[0] >= v7)
      {
        if (v7 < v5)
        {
          uint64_t v27 = a1[2].n128_i64[1];
          __n128 v28 = *v6;
          __n128 *v6 = *v4;
          a1[2].n128_u64[1] = a1[4].n128_u64[0];
          __n128 *v4 = v28;
          a1[4].n128_u64[0] = v27;
          if (v8 < (int64_t)v6->n128_u64[0])
          {
            uint64_t v29 = a1[1].n128_i64[0];
            __n128 v30 = *a1;
            *a1 = *v6;
            a1[1].n128_u64[0] = a1[2].n128_u64[1];
            __n128 *v6 = v30;
            a1[2].n128_u64[1] = v29;
          }
        }
      }
      else if (v7 >= v5)
      {
        uint64_t v38 = a1[1].n128_i64[0];
        __n128 v39 = *a1;
        *a1 = *v6;
        a1[1].n128_u64[0] = a1[2].n128_u64[1];
        __n128 *v6 = v39;
        a1[2].n128_u64[1] = v38;
        if ((int64_t)a1[1].n128_u64[1] < v5)
        {
          uint64_t v40 = a1[2].n128_i64[1];
          __n128 v41 = *v6;
          __n128 *v6 = *v4;
          a1[2].n128_u64[1] = a1[4].n128_u64[0];
          __n128 *v4 = v41;
          a1[4].n128_u64[0] = v40;
        }
      }
      else
      {
        uint64_t v9 = a1[1].n128_i64[0];
        __n128 v10 = *a1;
        *a1 = *v4;
        a1[1].n128_u64[0] = a1[4].n128_u64[0];
        __n128 *v4 = v10;
        a1[4].n128_u64[0] = v9;
      }
      uint64_t v42 = &a1[4].n128_i8[8];
      if (&a1[4].n128_i8[8] == a2) {
        return 1;
      }
      uint64_t v43 = 0;
      int v44 = 0;
      break;
  }
  while (1)
  {
    int64_t v45 = v4->n128_u64[0];
    uint64_t v46 = *(void *)v42;
    if (v45 < *(void *)v42) {
      break;
    }
LABEL_35:
    uint64_t v4 = (__n128 *)v42;
    v43 += 24;
    v42 += 24;
    if (v42 == a2) {
      return 1;
    }
  }
  __n128 v64 = *(__n128 *)(v42 + 8);
  uint64_t v47 = v43;
  do
  {
    uint64_t v48 = (uint64_t)a1 + v47;
    *(__n128 *)(v48 + 72) = *(__n128 *)((char *)a1 + v47 + 48);
    *(void *)(v48 + 88) = *(unint64_t *)((char *)a1[4].n128_u64 + v47);
    if (v47 == -48)
    {
      a1->n128_u64[0] = v46;
      *(__n128 *)((char *)a1 + 8) = v64;
      if (++v44 != 8) {
        goto LABEL_35;
      }
      return v42 + 24 == a2;
    }
    v47 -= 24;
  }
  while (*(void *)(v48 + 24) < v46);
  float64x2_t v49 = (__n128 *)((char *)a1 + v47);
  v49[4].n128_u64[1] = v46;
  v49[5] = v64;
  if (++v44 != 8) {
    goto LABEL_35;
  }
  return v42 + 24 == a2;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(__n128 *a1, __n128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5, __n128 result)
{
  uint64_t v6 = a2->n128_u64[0];
  uint64_t v7 = *a3;
  if ((int64_t)a1->n128_u64[0] >= (int64_t)a2->n128_u64[0])
  {
    if (v6 < v7)
    {
      uint64_t v10 = a2[1].n128_i64[0];
      uint64_t result = *a2;
      unint64_t v11 = a3[2];
      *a2 = *(__n128 *)a3;
      a2[1].n128_u64[0] = v11;
      *(__n128 *)a3 = result;
      a3[2] = v10;
      if ((int64_t)a1->n128_u64[0] < (int64_t)a2->n128_u64[0])
      {
        unint64_t v12 = a1[1].n128_u64[0];
        uint64_t result = *a1;
        unint64_t v13 = a2[1].n128_u64[0];
        *a1 = *a2;
        a1[1].n128_u64[0] = v13;
        *a2 = result;
        a2[1].n128_u64[0] = v12;
      }
    }
  }
  else
  {
    if (v6 < v7)
    {
      unint64_t v8 = a1[1].n128_u64[0];
      uint64_t result = *a1;
      unint64_t v9 = a3[2];
      *a1 = *(__n128 *)a3;
      a1[1].n128_u64[0] = v9;
LABEL_9:
      *(__n128 *)a3 = result;
      a3[2] = v8;
      goto LABEL_10;
    }
    unint64_t v14 = a1[1].n128_u64[0];
    uint64_t result = *a1;
    unint64_t v15 = a2[1].n128_u64[0];
    *a1 = *a2;
    a1[1].n128_u64[0] = v15;
    *a2 = result;
    a2[1].n128_u64[0] = v14;
    if ((int64_t)a2->n128_u64[0] < *a3)
    {
      unint64_t v8 = a2[1].n128_u64[0];
      uint64_t result = *a2;
      unint64_t v16 = a3[2];
      *a2 = *(__n128 *)a3;
      a2[1].n128_u64[0] = v16;
      goto LABEL_9;
    }
  }
LABEL_10:
  if (*a3 < *(void *)a4)
  {
    uint64_t v17 = a3[2];
    uint64_t result = *(__n128 *)a3;
    uint64_t v18 = *(void *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v18;
    *(__n128 *)a4 = result;
    *(void *)(a4 + 16) = v17;
    if ((int64_t)a2->n128_u64[0] < *a3)
    {
      uint64_t v19 = a2[1].n128_i64[0];
      uint64_t result = *a2;
      unint64_t v20 = a3[2];
      *a2 = *(__n128 *)a3;
      a2[1].n128_u64[0] = v20;
      *(__n128 *)a3 = result;
      a3[2] = v19;
      if ((int64_t)a1->n128_u64[0] < (int64_t)a2->n128_u64[0])
      {
        unint64_t v21 = a1[1].n128_u64[0];
        uint64_t result = *a1;
        unint64_t v22 = a2[1].n128_u64[0];
        *a1 = *a2;
        a1[1].n128_u64[0] = v22;
        *a2 = result;
        a2[1].n128_u64[0] = v21;
      }
    }
  }
  if (*(void *)a4 < *(void *)a5)
  {
    uint64_t v23 = *(void *)(a4 + 16);
    uint64_t result = *(__n128 *)a4;
    uint64_t v24 = *(void *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(void *)(a4 + 16) = v24;
    *(__n128 *)a5 = result;
    *(void *)(a5 + 16) = v23;
    if (*a3 < *(void *)a4)
    {
      uint64_t v25 = a3[2];
      uint64_t result = *(__n128 *)a3;
      uint64_t v26 = *(void *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      a3[2] = v26;
      *(__n128 *)a4 = result;
      *(void *)(a4 + 16) = v25;
      if ((int64_t)a2->n128_u64[0] < *a3)
      {
        uint64_t v27 = a2[1].n128_i64[0];
        uint64_t result = *a2;
        unint64_t v28 = a3[2];
        *a2 = *(__n128 *)a3;
        a2[1].n128_u64[0] = v28;
        *(__n128 *)a3 = result;
        a3[2] = v27;
        if ((int64_t)a1->n128_u64[0] < (int64_t)a2->n128_u64[0])
        {
          unint64_t v29 = a1[1].n128_u64[0];
          uint64_t result = *a1;
          unint64_t v30 = a2[1].n128_u64[0];
          *a1 = *a2;
          a1[1].n128_u64[0] = v30;
          *a2 = result;
          a2[1].n128_u64[0] = v29;
        }
      }
    }
  }
  return result;
}

long long *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *,ClipperLib::LocalMinimum *>(uint64_t a1, long long *a2, long long *a3)
{
  if ((long long *)a1 == a2) {
    return a3;
  }
  uint64_t v3 = (uint64_t)a2 - a1;
  uint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - a1) >> 3);
  if ((uint64_t)a2 - a1 >= 25 && (unint64_t)v3 >= 0x30)
  {
    int64_t v41 = (unint64_t)(v4 - 2) >> 1;
    uint64_t v42 = a1 + 24;
    int64_t v43 = v41;
    do
    {
      if (v41 >= v43)
      {
        uint64_t v44 = (2 * v43) | 1;
        int64_t v45 = (void *)(v42 + 48 * v43);
        if (2 * v43 + 2 >= v4)
        {
          uint64_t v47 = (void *)(a1 + 24 * v43);
          uint64_t v48 = *v47;
          if (*v47 >= *v45) {
            goto LABEL_67;
          }
        }
        else
        {
          uint64_t v46 = v45[3];
          if (v46 < *v45)
          {
            v45 += 3;
            uint64_t v44 = 2 * v43 + 2;
          }
          else
          {
            uint64_t v46 = *v45;
          }
          uint64_t v47 = (void *)(a1 + 24 * v43);
          uint64_t v48 = *v47;
          if (*v47 >= v46)
          {
LABEL_67:
            long long v55 = *(_OWORD *)(v47 + 1);
            while (1)
            {
              uint64_t v50 = v47;
              uint64_t v47 = v45;
              long long v51 = *(_OWORD *)v45;
              v50[2] = v45[2];
              *(_OWORD *)uint64_t v50 = v51;
              if (v41 < v44) {
                break;
              }
              uint64_t v52 = (2 * v44) | 1;
              int64_t v45 = (void *)(v42 + 48 * v44);
              uint64_t v44 = 2 * v44 + 2;
              if (v44 < v4)
              {
                uint64_t v49 = v45[3];
                if (v49 < *v45)
                {
                  v45 += 3;
                }
                else
                {
                  uint64_t v49 = *v45;
                  uint64_t v44 = v52;
                }
                if (v48 < v49) {
                  break;
                }
              }
              else
              {
                uint64_t v44 = v52;
                if (v48 < *v45) {
                  break;
                }
              }
            }
            *uint64_t v47 = v48;
            *(_OWORD *)(v47 + 1) = v55;
          }
        }
      }
      BOOL v26 = v43-- <= 0;
    }
    while (!v26);
  }
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    if (v3 < 48)
    {
      uint64_t v6 = a2;
      do
      {
        if (*(void *)a1 < *(void *)v6)
        {
          uint64_t v7 = *((void *)v6 + 2);
          long long v8 = *v6;
          uint64_t v9 = *(void *)(a1 + 16);
          long long *v6 = *(_OWORD *)a1;
          *((void *)v6 + 2) = v9;
          *(_OWORD *)a1 = v8;
          *(void *)(a1 + 16) = v7;
        }
        uint64_t v6 = (long long *)((char *)v6 + 24);
      }
      while (v6 != a3);
LABEL_36:
      uint64_t v5 = a3;
      goto LABEL_37;
    }
    uint64_t v10 = (uint64_t *)(a1 + 24);
    unint64_t v11 = (uint64_t *)(a1 + 48);
    unint64_t v12 = a2;
    while (1)
    {
      if (*(void *)a1 < *(void *)v12)
      {
        uint64_t v13 = *((void *)v12 + 2);
        long long v14 = *v12;
        uint64_t v15 = *(void *)(a1 + 16);
        *unint64_t v12 = *(_OWORD *)a1;
        *((void *)v12 + 2) = v15;
        *(_OWORD *)a1 = v14;
        *(void *)(a1 + 16) = v13;
        if ((unint64_t)v4 <= 2)
        {
          uint64_t v17 = (uint64_t *)(a1 + 24);
          uint64_t v18 = 1;
          uint64_t v19 = *(void *)a1;
          if (*(void *)a1 >= *v10) {
            goto LABEL_27;
          }
        }
        else
        {
          if (*v11 >= *v10) {
            uint64_t v16 = *v10;
          }
          else {
            uint64_t v16 = *v11;
          }
          if (*v11 >= *v10) {
            uint64_t v17 = (uint64_t *)(a1 + 24);
          }
          else {
            uint64_t v17 = (uint64_t *)(a1 + 48);
          }
          if (*v11 >= *v10) {
            uint64_t v18 = 1;
          }
          else {
            uint64_t v18 = 2;
          }
          uint64_t v19 = *(void *)a1;
          if (*(void *)a1 >= v16)
          {
LABEL_27:
            long long v53 = *(_OWORD *)(a1 + 8);
            unint64_t v20 = (void *)a1;
            while (1)
            {
              unint64_t v22 = v20;
              unint64_t v20 = v17;
              long long v23 = *(_OWORD *)v17;
              v22[2] = v17[2];
              *(_OWORD *)unint64_t v22 = v23;
              if ((uint64_t)((unint64_t)(v4 - 2) >> 1) < v18) {
                break;
              }
              uint64_t v24 = (2 * v18) | 1;
              uint64_t v17 = &v10[6 * v18];
              uint64_t v18 = 2 * v18 + 2;
              if (v18 < v4)
              {
                uint64_t v21 = v17[3];
                if (v21 < *v17)
                {
                  v17 += 3;
                }
                else
                {
                  uint64_t v21 = *v17;
                  uint64_t v18 = v24;
                }
                if (v19 < v21) {
                  break;
                }
              }
              else
              {
                uint64_t v18 = v24;
                if (v19 < *v17) {
                  break;
                }
              }
            }
            *unint64_t v20 = v19;
            *(_OWORD *)(v20 + 1) = v53;
          }
        }
      }
      unint64_t v12 = (long long *)((char *)v12 + 24);
      if (v12 == a3) {
        goto LABEL_36;
      }
    }
  }
LABEL_37:
  if (v3 >= 25)
  {
    int64_t v25 = v3 / 0x18uLL;
    do
    {
      uint64_t v27 = 0;
      long long v54 = *(_OWORD *)a1;
      uint64_t v56 = *(void *)(a1 + 16);
      uint64_t v28 = a1;
      do
      {
        uint64_t v30 = v28 + 24 * v27 + 24;
        uint64_t v31 = (2 * v27) | 1;
        uint64_t v32 = 2 * v27 + 2;
        if (v32 < v25 && *(void *)(v30 + 24) < *(void *)v30)
        {
          v30 += 24;
          uint64_t v31 = v32;
        }
        long long v29 = *(_OWORD *)v30;
        *(void *)(v28 + 16) = *(void *)(v30 + 16);
        *(_OWORD *)uint64_t v28 = v29;
        uint64_t v28 = v30;
        uint64_t v27 = v31;
      }
      while (v31 <= (uint64_t)((unint64_t)(v25 - 2) >> 1));
      a2 = (long long *)((char *)a2 - 24);
      if ((long long *)v30 == a2)
      {
        *(void *)(v30 + 16) = v56;
        *(_OWORD *)uint64_t v30 = v54;
      }
      else
      {
        long long v33 = *a2;
        *(void *)(v30 + 16) = *((void *)a2 + 2);
        *(_OWORD *)uint64_t v30 = v33;
        *a2 = v54;
        *((void *)a2 + 2) = v56;
        uint64_t v34 = v30 - a1 + 24;
        if (v34 >= 25)
        {
          unint64_t v35 = (v34 / 0x18uLL - 2) >> 1;
          uint64_t v36 = a1 + 24 * v35;
          uint64_t v37 = *(void *)v30;
          if (*(void *)v30 < *(void *)v36)
          {
            long long v57 = *(_OWORD *)(v30 + 8);
            do
            {
              uint64_t v38 = v30;
              uint64_t v30 = v36;
              long long v39 = *(_OWORD *)v36;
              *(void *)(v38 + 16) = *(void *)(v36 + 16);
              *(_OWORD *)uint64_t v38 = v39;
              if (!v35) {
                break;
              }
              unint64_t v35 = (v35 - 1) >> 1;
              uint64_t v36 = a1 + 24 * v35;
            }
            while (v37 < *(void *)v36);
            *(void *)uint64_t v30 = v37;
            *(_OWORD *)(v30 + 8) = v57;
          }
        }
      }
      BOOL v26 = v25-- <= 2;
    }
    while (!v26);
  }
  return v5;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(uint64_t result, int8x16_t *a2, unsigned int (**a3)(uint64_t), uint64_t a4, char a5)
{
  uint64_t v9 = (int8x16_t *)result;
  while (2)
  {
    uint64_t v10 = a2;
    unint64_t v11 = &a2[-1].i64[1];
    unint64_t v12 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v12;
          uint64_t v13 = (char *)v10 - (char *)v12;
          unint64_t v14 = ((char *)v10 - (char *)v12) >> 3;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v70 = v12->i64[0];
                v12->i64[0] = *v11;
                goto LABEL_143;
              case 3uLL:
                char v71 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[1]);
                if (v71)
                {
                  uint64_t v72 = v12->i64[0];
                  if (result)
                  {
                    v12->i64[0] = *v11;
                    uint64_t *v11 = v72;
                  }
                  else
                  {
                    v12->i64[0] = v12->i64[1];
                    v12->i64[1] = v72;
                    uint64_t result = ((uint64_t (*)(uint64_t))*a3)(*v11);
                    if (result)
                    {
                      uint64_t v70 = v12->i64[1];
                      v12->i64[1] = *v11;
LABEL_143:
                      uint64_t *v11 = v70;
                    }
                  }
                }
                else if (result)
                {
                  uint64_t v88 = v12->i64[1];
                  v12->i64[1] = *v11;
                  uint64_t *v11 = v88;
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
LABEL_132:
                  if (result) {
                    *unint64_t v12 = vextq_s8(*v12, *v12, 8uLL);
                  }
                }
                break;
              case 4uLL:
                return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, v11, a3);
              case 5uLL:
                uint64_t v73 = v12 + 1;
                unint64_t v74 = &v12[1].i64[1];
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, &v12[1].i64[1], a3);
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12[1].i64[1]);
                if (!result) {
                  return result;
                }
                uint64_t v75 = *v74;
                *unint64_t v74 = *v11;
                uint64_t *v11 = v75;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v74, v73->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v76 = v73->i64[0];
                v73->i64[0] = *v74;
                *unint64_t v74 = v76;
                uint64_t result = ((uint64_t (*)(void))*a3)();
                if (!result) {
                  return result;
                }
                uint64_t v78 = v12->i64[1];
                uint64_t v77 = v12[1].i64[0];
                uint64_t v79 = v12->i64[0];
                v12->i64[1] = v77;
                v12[1].i64[0] = v78;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v77, v79);
                goto LABEL_132;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            long long v80 = (int8x16_t *)&v12->u64[1];
            BOOL v82 = v12 == v10 || v80 == v10;
            if (a5)
            {
              if (!v82)
              {
                uint64_t v83 = 0;
                unint64_t v84 = (uint64_t *)v12;
                do
                {
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v80->i64[0], *v84);
                  if (result)
                  {
                    unint64_t v86 = 0;
                    uint64_t v87 = v80->i64[0];
                    do
                    {
                      v84[v86 / 8 + 1] = v84[v86 / 8];
                      if (v83 == v86)
                      {
                        int64_t v85 = (uint64_t *)v12;
                        goto LABEL_119;
                      }
                      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v87, v84[v86 / 8 - 1]);
                      v86 -= 8;
                    }
                    while ((result & 1) != 0);
                    int64_t v85 = &v80->i64[v86 / 8];
LABEL_119:
                    *int64_t v85 = v87;
                  }
                  long long v80 = (int8x16_t *)((char *)v80 + 8);
                  v83 -= 8;
                  ++v84;
                }
                while (v80 != a2);
              }
            }
            else if (!v82)
            {
              do
              {
                uint64_t v90 = v9->i64[0];
                uint64_t v89 = v9->i64[1];
                uint64_t v9 = v80;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v89, v90);
                if (result)
                {
                  uint64_t v91 = v80->i64[0];
                  uint64_t v92 = (uint64_t *)v80;
                  do
                  {
                    uint64_t v93 = v92;
                    uint64_t v94 = *--v92;
                    *uint64_t v93 = v94;
                    uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v91, *(v93 - 2));
                  }
                  while ((result & 1) != 0);
                  *uint64_t v92 = v91;
                }
                long long v80 = (int8x16_t *)((char *)v80 + 8);
              }
              while (&v9->u64[1] != (unint64_t *)a2);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != v10)
            {
              return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**,p2t::Point**>(v12, a2, a2, (unsigned int (**)(void, uint64_t))a3);
            }
            return result;
          }
          unint64_t v15 = v14 >> 1;
          uint64_t v16 = *a3;
          if ((unint64_t)v13 >= 0x401) {
            break;
          }
          char v20 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v12->i64[0], v12->i64[v15]);
          int v21 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[0]);
          if (v20)
          {
            uint64_t v22 = v12->i64[v15];
            if (!v21)
            {
              v12->i64[v15] = v12->i64[0];
              v12->i64[0] = v22;
              if ((*a3)(*v11))
              {
                uint64_t v35 = v12->i64[0];
                v12->i64[0] = *v11;
                uint64_t *v11 = v35;
              }
LABEL_33:
              --a4;
              uint64_t v23 = v12->i64[0];
              if (a5) {
                goto LABEL_56;
              }
              goto LABEL_55;
            }
            v12->i64[v15] = *v11;
            uint64_t *v11 = v22;
            --a4;
            uint64_t v23 = v12->i64[0];
            if (a5) {
              goto LABEL_56;
            }
          }
          else
          {
            if (!v21) {
              goto LABEL_33;
            }
            uint64_t v26 = v12->i64[0];
            v12->i64[0] = *v11;
            uint64_t *v11 = v26;
            if (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v12->i64[0], v12->i64[v15])) {
              goto LABEL_33;
            }
            uint64_t v27 = v12->i64[v15];
            v12->i64[v15] = v12->i64[0];
            v12->i64[0] = v27;
            --a4;
            uint64_t v23 = v27;
            if (a5) {
              goto LABEL_56;
            }
          }
LABEL_55:
          char v51 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12[-1].i64[1], v23);
          uint64_t v23 = v12->i64[0];
          if (v51) {
            goto LABEL_56;
          }
          uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[0], *v11);
          if (result)
          {
            do
            {
              uint64_t v63 = v12->i64[1];
              unint64_t v12 = (int8x16_t *)((char *)v12 + 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v63);
            }
            while ((result & 1) == 0);
          }
          else
          {
            __n128 v64 = (int8x16_t *)&v12->u64[1];
            do
            {
              unint64_t v12 = v64;
              if (v64 >= v10) {
                break;
              }
              __n128 v64 = (int8x16_t *)((char *)v64 + 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v12->i64[0]);
            }
            while (!result);
          }
          if (v12 < v10)
          {
            uint64_t v10 = a2;
            do
            {
              uint64_t v65 = v10[-1].i64[1];
              uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v65);
            }
            while ((result & 1) != 0);
          }
          while (v12 < v10)
          {
            uint64_t v66 = v12->i64[0];
            v12->i64[0] = v10->i64[0];
            v10->i64[0] = v66;
            do
            {
              uint64_t v67 = v12->i64[1];
              unint64_t v12 = (int8x16_t *)((char *)v12 + 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v23, v67));
            do
            {
              uint64_t v68 = v10[-1].i64[1];
              uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v68);
            }
            while ((result & 1) != 0);
          }
          unint64_t v69 = &v12[-1].i64[1];
          BOOL v5 = &v12[-1].u64[1] >= (unint64_t *)v9;
          BOOL v6 = &v12[-1].u64[1] == (unint64_t *)v9;
          if (&v12[-1].u64[1] != (unint64_t *)v9) {
            v9->i64[0] = *v69;
          }
          a5 = 0;
          *unint64_t v69 = v23;
          uint64_t v10 = a2;
        }
        char v17 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v12->i64[v15], v12->i64[0]);
        int v18 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[v15]);
        if (v17)
        {
          uint64_t v19 = v12->i64[0];
          if (v18)
          {
            v12->i64[0] = *v11;
            uint64_t *v11 = v19;
          }
          else
          {
            v12->i64[0] = v12->i64[v15];
            v12->i64[v15] = v19;
            if ((*a3)(*v11))
            {
              uint64_t v28 = v12->i64[v15];
              v12->i64[v15] = *v11;
              uint64_t *v11 = v28;
            }
          }
        }
        else if (v18)
        {
          uint64_t v24 = v12->i64[v15];
          v12->i64[v15] = *v11;
          uint64_t *v11 = v24;
          if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v12->i64[v15], v12->i64[0]))
          {
            uint64_t v25 = v12->i64[0];
            v12->i64[0] = v12->i64[v15];
            v12->i64[v15] = v25;
          }
        }
        long long v29 = &v12->i8[8 * v15];
        char v30 = ((uint64_t (*)(void, uint64_t))*a3)(*((void *)v29 - 1), v12->i64[1]);
        int v31 = ((uint64_t (*)(uint64_t, void))*a3)(v10[-1].i64[0], *((void *)v29 - 1));
        if (v30)
        {
          uint64_t v32 = v12->i64[1];
          if (v31)
          {
            v12->i64[1] = v10[-1].i64[0];
            v10[-1].i64[0] = v32;
          }
          else
          {
            v12->i64[1] = *((void *)v29 - 1);
            *((void *)v29 - 1) = v32;
            if ((*a3)(v10[-1].i64[0]))
            {
              uint64_t v36 = *((void *)v29 - 1);
              *((void *)v29 - 1) = v10[-1].i64[0];
              v10[-1].i64[0] = v36;
            }
          }
        }
        else if (v31)
        {
          uint64_t v33 = *((void *)v29 - 1);
          *((void *)v29 - 1) = v10[-1].i64[0];
          v10[-1].i64[0] = v33;
          if (((unsigned int (*)(void, uint64_t))*a3)(*((void *)v29 - 1), v12->i64[1]))
          {
            uint64_t v34 = v12->i64[1];
            v12->i64[1] = *((void *)v29 - 1);
            *((void *)v29 - 1) = v34;
          }
        }
        char v37 = ((uint64_t (*)(void, uint64_t))*a3)(*((void *)v29 + 1), v12[1].i64[0]);
        int v38 = ((uint64_t (*)(uint64_t, void))*a3)(v10[-2].i64[1], *((void *)v29 + 1));
        if (v37)
        {
          uint64_t v39 = v12[1].i64[0];
          if (v38)
          {
            v12[1].i64[0] = v10[-2].i64[1];
            v10[-2].i64[1] = v39;
          }
          else
          {
            v12[1].i64[0] = *((void *)v29 + 1);
            *((void *)v29 + 1) = v39;
            if ((*a3)(v10[-2].i64[1]))
            {
              uint64_t v42 = *((void *)v29 + 1);
              *((void *)v29 + 1) = v10[-2].i64[1];
              v10[-2].i64[1] = v42;
            }
          }
        }
        else if (v38)
        {
          uint64_t v40 = *((void *)v29 + 1);
          *((void *)v29 + 1) = v10[-2].i64[1];
          v10[-2].i64[1] = v40;
          if (((unsigned int (*)(void, uint64_t))*a3)(*((void *)v29 + 1), v12[1].i64[0]))
          {
            uint64_t v41 = v12[1].i64[0];
            v12[1].i64[0] = *((void *)v29 + 1);
            *((void *)v29 + 1) = v41;
          }
        }
        char v43 = ((uint64_t (*)(uint64_t, void))*a3)(v12->i64[v15], *((void *)v29 - 1));
        int v44 = ((uint64_t (*)(void, uint64_t))*a3)(*((void *)v29 + 1), v12->i64[v15]);
        if (v43)
        {
          uint64_t v45 = *((void *)v29 - 1);
          if (v44)
          {
            *((void *)v29 - 1) = *((void *)v29 + 1);
            *((void *)v29 + 1) = v45;
            uint64_t v46 = v12->i64[v15];
            goto LABEL_54;
          }
          *((void *)v29 - 1) = v12->i64[v15];
          v12->i64[v15] = v45;
          unsigned int v49 = (*a3)(*((void *)v29 + 1));
          uint64_t v46 = v12->i64[v15];
          if (v49)
          {
            uint64_t v48 = *((void *)v29 + 1);
            v12->i64[v15] = v48;
            *((void *)v29 + 1) = v46;
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v46 = v12->i64[v15];
          if (v44)
          {
            v12->i64[v15] = *((void *)v29 + 1);
            *((void *)v29 + 1) = v46;
            int v47 = ((uint64_t (*)(void))*a3)();
            uint64_t v46 = v12->i64[v15];
            if (v47)
            {
              uint64_t v48 = *((void *)v29 - 1);
              *((void *)v29 - 1) = v46;
              v12->i64[v15] = v48;
LABEL_53:
              uint64_t v46 = v48;
            }
          }
        }
LABEL_54:
        uint64_t v50 = v12->i64[0];
        v12->i64[0] = v46;
        v12->i64[v15] = v50;
        --a4;
        uint64_t v23 = v12->i64[0];
        if ((a5 & 1) == 0) {
          goto LABEL_55;
        }
LABEL_56:
        uint64_t v52 = v12;
        do
        {
          long long v53 = v52;
          uint64_t v54 = v52->i64[1];
          uint64_t v52 = (int8x16_t *)((char *)v52 + 8);
        }
        while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v23) & 1) != 0);
        if (v53 == v12)
        {
          uint64_t v10 = a2;
          do
          {
            if (v52 >= v10) {
              break;
            }
            uint64_t v56 = v10[-1].i64[1];
            uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
          }
          while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v56, v23) & 1) == 0);
        }
        else
        {
          do
          {
            uint64_t v55 = v10[-1].i64[1];
            uint64_t v10 = (int8x16_t *)((char *)v10 - 8);
          }
          while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v55, v23));
        }
        if (v52 < v10)
        {
          long long v57 = v52;
          __n128 v58 = v10;
          do
          {
            uint64_t v59 = v57->i64[0];
            v57->i64[0] = v58->i64[0];
            v58->i64[0] = v59;
            do
            {
              long long v53 = v57;
              uint64_t v60 = v57->i64[1];
              long long v57 = (int8x16_t *)((char *)v57 + 8);
            }
            while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v60, v23) & 1) != 0);
            do
            {
              uint64_t v61 = v58[-1].i64[1];
              __n128 v58 = (int8x16_t *)((char *)v58 - 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v61, v23));
          }
          while (v57 < v58);
        }
        if (v53 != v9) {
          v9->i64[0] = v53->i64[0];
        }
        v53->i64[0] = v23;
        BOOL v5 = v52 >= v10;
        uint64_t v10 = a2;
        if (v5) {
          break;
        }
LABEL_76:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(v9, v53, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v12 = (int8x16_t *)&v53->u64[1];
      }
      BOOL v62 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v9, v53, a3);
      unint64_t v12 = (int8x16_t *)&v53->u64[1];
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(&v53->i64[1], a2, a3);
      if (result) {
        break;
      }
      if (!v62) {
        goto LABEL_76;
      }
    }
    a2 = v53;
    if (!v62) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(void *a1, void *a2, unsigned int (**a3)(uint64_t))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      char v9 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v10 = ((uint64_t (*)(void, void))*a3)(*(a2 - 1), a1[1]);
      if (v9)
      {
        uint64_t v11 = *a1;
        if (v10)
        {
          *a1 = *(a2 - 1);
          *(a2 - 1) = v11;
        }
        else
        {
          *a1 = a1[1];
          a1[1] = v11;
          if ((*a3)(*(a2 - 1)))
          {
            uint64_t v26 = a1[1];
            a1[1] = *(a2 - 1);
            *(a2 - 1) = v26;
          }
        }
      }
      else if (v10)
      {
        uint64_t v24 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v24;
        int v19 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
LABEL_17:
        if (v19) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      unint64_t v12 = a1 + 2;
      uint64_t v13 = a1 + 3;
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(p2t::Point const*,p2t::Point const*),p2t::Point**>(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      if (!((unsigned int (*)(void, void))*a3)(*(a2 - 1), a1[3])) {
        return 1;
      }
      uint64_t v14 = *v13;
      *uint64_t v13 = *(a2 - 1);
      *(a2 - 1) = v14;
      if (!((unsigned int (*)(void, void))*a3)(*v13, *v12)) {
        return 1;
      }
      uint64_t v15 = *v12;
      *unint64_t v12 = *v13;
      *uint64_t v13 = v15;
      if (!((unsigned int (*)(void))*a3)()) {
        return 1;
      }
      uint64_t v17 = a1[1];
      uint64_t v16 = a1[2];
      uint64_t v18 = *a1;
      a1[1] = v16;
      a1[2] = v17;
      int v19 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v16, v18);
      goto LABEL_17;
    default:
      char v20 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v21 = a1 + 2;
      int v22 = ((uint64_t (*)(void, void))*a3)(a1[2], a1[1]);
      if (v20)
      {
        uint64_t v23 = *a1;
        if (v22)
        {
          *a1 = a1[2];
          a1[2] = v23;
        }
        else
        {
          uint64_t v27 = a1[2];
          *a1 = a1[1];
          a1[1] = v23;
          if ((*a3)(v27)) {
            *(int8x16_t *)(a1 + 1) = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
          }
        }
      }
      else if (v22)
      {
        uint64_t v25 = a1[1];
        a1[1] = a1[2];
        a1[2] = v25;
        if (((unsigned int (*)(void))*a3)()) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      uint64_t v28 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v29 = 0;
      int v30 = 0;
      break;
  }
  while (!((unsigned int (*)(void, void))*a3)(*v28, *v21))
  {
LABEL_35:
    int v21 = v28;
    v29 += 8;
    if (++v28 == a2) {
      return 1;
    }
  }
  uint64_t v31 = *v28;
  uint64_t v32 = v29;
  do
  {
    uint64_t v33 = (char *)a1 + v32;
    *(void *)((char *)a1 + v32 + 24) = *(void *)((char *)a1 + v32 + 16);
    if (v32 == -16)
    {
      *a1 = v31;
      if (++v30 != 8) {
        goto LABEL_35;
      }
      return v28 + 1 == a2;
    }
    v32 -= 8;
  }
  while ((((uint64_t (*)(uint64_t, void))*a3)(v31, *((void *)v33 + 1)) & 1) != 0);
  *(void *)((char *)a1 + v32 + 24) = v31;
  if (++v30 != 8) {
    goto LABEL_35;
  }
  return v28 + 1 == a2;
}

void *std::vector<ClipperLib::IntPoint>::__assign_with_size[abi:ne180100]<ClipperLib::IntPoint*,ClipperLib::IntPoint*>(void *result, char *__src, char *a3, size_t __sz)
{
  uint64_t v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  char v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 60) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 60) {
LABEL_22:
    }
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    uint64_t v13 = 2 * v12;
    BOOL result = operator new(16 * v12);
    char v9 = (char *)result;
    void *v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      BOOL result = memcpy(result, v6, v14);
    }
    uint64_t v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  uint64_t v15 = (void **)(result + 1);
  uint64_t v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 4;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    int v19 = (void *)*result;
LABEL_20:
    BOOL result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  uint64_t v18 = &__src[16 * v17];
  if (v16 != v9)
  {
    BOOL result = memmove((void *)*result, __src, v16 - v9);
    char v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    int v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *uint64_t v15 = &v9[v14];
  return result;
}

void std::vector<ClipperLib::IntPoint>::__append(char **a1, unint64_t a2)
{
  BOOL v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      uint64_t v12 = 16 * a2;
      bzero(a1[1], 16 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 4;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 60) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      BOOL v11 = (char *)operator new(16 * v10);
    }
    else
    {
      BOOL v11 = 0;
    }
    uint64_t v13 = &v11[16 * v7];
    size_t v14 = 16 * a2;
    uint64_t v15 = &v11[16 * v10];
    bzero(v13, v14);
    uint64_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 16;
      }
      while (v5 != v6);
      BOOL v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x237DF7BF0](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      unint64_t v10 = std::locale::use_facet(&v14, MEMORY[0x263F8C108]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x237DF7C00](v13);
  return a1;
}

void sub_235EFF7C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x237DF7C00](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x235EFF7A4);
}

void sub_235EFF818(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      size_t v12 = 0;
    }
    else {
      size_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if ((uint64_t)v12 >= 1)
    {
      if (v12 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v12 >= 0x17)
      {
        uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v14 = v12 | 7;
        }
        uint64_t v15 = v14 + 1;
        uint64_t v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        int64_t v22 = v15 | 0x8000000000000000;
        __b[0] = v13;
      }
      else
      {
        HIBYTE(v22) = v12;
        uint64_t v13 = __b;
      }
      memset(v13, __c, v12);
      *((unsigned char *)v13 + v12) = 0;
      if (v22 >= 0) {
        uint64_t v16 = __b;
      }
      else {
        uint64_t v16 = (void **)__b[0];
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(void *)v6 + 96))(v6, v16, v12);
      uint64_t v18 = v17;
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__b[0]);
        if (v18 != v12) {
          return 0;
        }
      }
      else if (v17 != v12)
      {
        return 0;
      }
    }
    uint64_t v19 = a4 - a3;
    if (v19 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v19) == v19)
    {
      *(void *)(a5 + 24) = 0;
      return v6;
    }
    return 0;
  }
  return v6;
}

void sub_235EFFA00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_235EFFA6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFA80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFAE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFB6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFCC4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_26884D868);
  _Unwind_Resume(a1);
}

void sub_235EFFDCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFDE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFDF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFF6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFF98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235EFFFAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F00570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_235F00720()
{
}

void sub_235F00728()
{
}

void sub_235F00730()
{
}

void sub_235F007C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0086C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F008D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)GKNoise;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_235F0097C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F00994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F00A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F00C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F00F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F0113C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0114C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01160(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0117C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01374(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F014AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F015D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F016B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F017C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F017DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F018EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01A64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01B30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F01C60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01C78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01C8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01DCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01DE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01E8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01EA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01F64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F01F78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0203C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F02188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F022D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F023DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F02568(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F02714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F028A8(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

void sub_235F02984(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

void sub_235F02B84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F02F60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03074(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0309C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F030B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F031E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F034F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03500(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03A88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03BD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03BE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03CF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03D08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03E20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03E30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03F48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F03F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04210(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04220(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0440C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0441C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0442C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void OpenSteer::PolylinePathway::~PolylinePathway(OpenSteer::PolylinePathway *this)
{
  *(void *)this = &unk_26E943368;
  uint64_t v2 = *((void *)this + 10);
  if (v2) {
    MEMORY[0x237DF7C80](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    MEMORY[0x237DF7C80](v3, 0x1000C803E1C8BA9);
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4) {
    MEMORY[0x237DF7C80](v4, 0x1000C803E1C8BA9);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_26E943368;
  uint64_t v2 = *((void *)this + 10);
  if (v2) {
    MEMORY[0x237DF7C80](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    MEMORY[0x237DF7C80](v3, 0x1000C803E1C8BA9);
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4) {
    MEMORY[0x237DF7C80](v4, 0x1000C803E1C8BA9);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_26E943368;
  uint64_t v2 = *((void *)this + 10);
  if (v2) {
    MEMORY[0x237DF7C80](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    MEMORY[0x237DF7C80](v3, 0x1000C803E1C8BA9);
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4) {
    MEMORY[0x237DF7C80](v4, 0x1000C803E1C8BA9);
  }

  JUMPOUT(0x237DF7CA0);
}

void OpenSteer::PolylinePathway::PolylinePathway(OpenSteer::PolylinePathway *this, int a2, const Vec3 *a3, float a4, int a5)
{
  *(void *)this = &unk_26E943368;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  OpenSteer::PolylinePathway::initialize(this, a2, a3, a4, a5);
}

{
  *(void *)this = &unk_26E943368;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  OpenSteer::PolylinePathway::initialize(this, a2, a3, a4, a5);
}

void OpenSteer::PolylinePathway::initialize(OpenSteer::PolylinePathway *this, int a2, const Vec3 *a3, float a4, int a5)
{
  *((float *)this + 6) = a4;
  *((unsigned char *)this + 28) = a5;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 24) = 0;
  if (a5) {
    *((_DWORD *)this + 2) = a2 + 1;
  }
  operator new[]();
}

float OpenSteer::PolylinePathway::mapPointToPath(OpenSteer::PolylinePathway *this, const Vec3 *a2, Vec3 *a3, float *a4)
{
  float v7 = 0.0;
  float v8 = 0.0;
  float v9 = 0.0;
  if (*((int *)this + 2) >= 2)
  {
    float v11 = 3.4028e38;
    uint64_t v12 = 1;
    uint64_t v13 = 12;
    do
    {
      uint64_t v14 = *((void *)this + 11);
      *((_DWORD *)this + 8) = *(_DWORD *)(*((void *)this + 10) + 4 * v12);
      uint64_t v15 = v14 + v13;
      uint64_t v16 = *(void *)(v14 + v13);
      *((_DWORD *)this + 18) = *(_DWORD *)(v15 + 8);
      *((void *)this + 8) = v16;
      float v17 = OpenSteer::PolylinePathway::pointToSegmentDistance(this, a2, (const Vec3 *)(*((void *)this + 2) + v13 - 12), (const Vec3 *)(*((void *)this + 2) + v13));
      if (v17 < v11)
      {
        float v9 = *((float *)this + 13);
        float v8 = *((float *)this + 14);
        float v7 = *((float *)this + 15);
        uint64_t v18 = *((void *)this + 8);
        a3->float z = *((float *)this + 18);
        *(void *)&a3->float x = v18;
        float v11 = v17;
      }
      ++v12;
      v13 += 12;
    }
    while (v12 < *((int *)this + 2));
  }
  *a4 = sqrtf((float)((float)((float)(v9 - a2->x) * (float)(v9 - a2->x)) + (float)((float)(v8 - a2->y) * (float)(v8 - a2->y)))+ (float)((float)(v7 - a2->z) * (float)(v7 - a2->z)))- *((float *)this + 6);
  return v9;
}

float OpenSteer::PolylinePathway::pointToSegmentDistance(OpenSteer::PolylinePathway *this, const Vec3 *a2, const Vec3 *a3, const Vec3 *a4)
{
  float v4 = a2->z - a3->z;
  _D2 = vsub_f32(*(float32x2_t *)&a2->x, *(float32x2_t *)&a3->x);
  *((float32x2_t *)this + 5) = _D2;
  *((float *)this + 12) = v4;
  float v6 = *((float *)this + 16);
  _S1 = *((float *)this + 17);
  __asm { FMLA            S4, S1, V2.S[1] }
  float v13 = *((float *)this + 18);
  float v14 = _S4 + (float)(v13 * v4);
  *((float *)this + 9) = v14;
  if (v14 < 0.0)
  {
    uint64_t v15 = *(void *)&a3->x;
    *((_DWORD *)this + 15) = LODWORD(a3->z);
    *(void *)((char *)this + 52) = v15;
    *((_DWORD *)this + 9) = 0;
    float v16 = a2->x - a3->x;
    float32x2_t v17 = *(float32x2_t *)&a2->y;
    float32x2_t v18 = *(float32x2_t *)&a3->y;
LABEL_5:
    float32x2_t v21 = vsub_f32(v17, v18);
    float32x2_t v22 = vmul_f32(v21, v21);
    return sqrtf((float)(v22.f32[0] + (float)(v16 * v16)) + v22.f32[1]);
  }
  float v19 = *((float *)this + 8);
  if (v14 > v19)
  {
    uint64_t v20 = *(void *)&a4->x;
    *((_DWORD *)this + 15) = LODWORD(a4->z);
    *(void *)((char *)this + 52) = v20;
    *((float *)this + 9) = v19;
    float v16 = a2->x - a4->x;
    float32x2_t v17 = *(float32x2_t *)&a2->y;
    float32x2_t v18 = *(float32x2_t *)&a4->y;
    goto LABEL_5;
  }
  float v24 = v14 * v6;
  float v25 = v14 * _S1;
  float v26 = v14 * v13;
  *((float *)this + 13) = v24;
  *((float *)this + 14) = v25;
  *((float *)this + 15) = v26;
  float v27 = a3->x + v24;
  float v28 = a3->y + v25;
  float v29 = a3->z + v26;
  *((float *)this + 13) = v27;
  *((float *)this + 14) = v28;
  float y = a2->y;
  float v31 = a2->x - v27;
  *((float *)this + 15) = v29;
  return sqrtf((float)((float)(v31 * v31) + (float)((float)(y - v28) * (float)(y - v28)))+ (float)((float)(a2->z - v29) * (float)(a2->z - v29)));
}

float OpenSteer::PolylinePathway::mapPointToPathDistance(OpenSteer::PolylinePathway *this, const Vec3 *a2)
{
  float v2 = 0.0;
  if (*((int *)this + 2) >= 2)
  {
    float v5 = 0.0;
    float v6 = 3.4028e38;
    uint64_t v7 = 1;
    uint64_t v8 = 12;
    do
    {
      uint64_t v9 = *((void *)this + 11);
      *((_DWORD *)this + 8) = *(_DWORD *)(*((void *)this + 10) + 4 * v7);
      uint64_t v10 = v9 + v8;
      uint64_t v11 = *(void *)(v9 + v8);
      *((_DWORD *)this + 18) = *(_DWORD *)(v10 + 8);
      *((void *)this + 8) = v11;
      float v12 = OpenSteer::PolylinePathway::pointToSegmentDistance(this, a2, (const Vec3 *)(*((void *)this + 2) + v8 - 12), (const Vec3 *)(*((void *)this + 2) + v8));
      if (v12 < v6)
      {
        float v2 = *((float *)this + 9) + v5;
        float v6 = v12;
      }
      float v5 = *((float *)this + 8) + v5;
      ++v7;
      v8 += 12;
    }
    while (v7 < *((int *)this + 2));
  }
  return v2;
}

float32x2_t OpenSteer::PolylinePathway::mapPathDistanceToPoint(OpenSteer::PolylinePathway *this, float a2)
{
  float v2 = a2;
  if (*((unsigned char *)this + 28))
  {
    float v2 = fmodf(a2, *((float *)this + 24));
  }
  else
  {
    if (a2 < 0.0) {
      return **((float32x2_t **)this + 2);
    }
    if (*((float *)this + 24) <= a2) {
      return *(float32x2_t *)(*((void *)this + 2) + 12 * *((int *)this + 2) - 12);
    }
  }
  uint64_t v4 = *((unsigned int *)this + 2);
  float32x2_t result = 0;
  if ((int)v4 >= 2)
  {
    uint64_t v6 = *((void *)this + 10);
    uint64_t v7 = 1;
    while (1)
    {
      float v8 = *(float *)(v6 + 4 * v7);
      *((float *)this + 8) = v8;
      if (v8 >= v2) {
        break;
      }
      float v2 = v2 - v8;
      if (v4 == ++v7) {
        return result;
      }
    }
    return vmla_n_f32(*(float32x2_t *)(*((void *)this + 2) + 12 * ((int)v7 - 1)), vsub_f32(*(float32x2_t *)(*((void *)this + 2) + 12 * v7), *(float32x2_t *)(*((void *)this + 2) + 12 * ((int)v7 - 1))), v2 / v8);
  }
  return result;
}

void sub_235F04F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04FCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F04FE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t p2t::Triangle::Triangle(uint64_t this, Point *a2, Point *a3, Point *a4)
{
  *(void *)(this + 8) = a2;
  *(void *)(this + 16) = a3;
  *(_DWORD *)this = 0;
  *(_WORD *)(this + 4) = 0;
  *(void *)(this + 24) = a4;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(unsigned char *)(this + 56) = 0;
  return this;
}

void *p2t::Triangle::MarkNeighbor(void *this, Point *a2, Point *a3, p2t::Triangle *a4)
{
  uint64_t v4 = (Point *)this[2];
  float v5 = (Point *)this[3];
  BOOL v6 = v5 == a2 && v4 == a3;
  if (v6 || (v5 == a3 ? (BOOL v7 = v4 == a2) : (BOOL v7 = 0), v7))
  {
    this[4] = a4;
  }
  else
  {
    float v8 = (Point *)this[1];
    BOOL v10 = v5 == a2 && v8 == a3;
    if ((v8 != a2 || v5 != a3) && !v10)
    {
      BOOL v14 = v4 == a2 && v8 == a3;
      BOOL v15 = v8 == a2 && v4 == a3;
      if (!v15 && !v14) {
        p2t::Triangle::MarkNeighbor();
      }
      this[6] = a4;
    }
    else
    {
      this[5] = a4;
    }
  }
  return this;
}

void *p2t::Triangle::MarkNeighbor(void *this, p2t::Triangle *a2)
{
  unint64_t v2 = this[2];
  unint64_t v3 = this[3];
  uint64_t v4 = *((void *)a2 + 1);
  uint64_t v5 = *((void *)a2 + 2);
  BOOL v6 = v4 == v2 || v5 == v2;
  uint64_t v7 = *((void *)a2 + 3);
  BOOL v8 = v6 || v7 == v2;
  int v9 = v8;
  if (v8)
  {
    BOOL v10 = v4 == v3 || v5 == v3;
    if (v10 || v7 == v3)
    {
      this[4] = a2;
      uint64_t v12 = *((void *)a2 + 2);
      uint64_t v13 = *((void *)a2 + 3);
      BOOL v14 = v13 == v2 && v12 == v3;
      if (!v14 && (v13 != v3 || v12 != v2))
      {
        uint64_t v15 = *((void *)a2 + 1);
        BOOL v17 = v13 == v2 && v15 == v3;
        BOOL v18 = v15 == v2 && v13 == v3;
        if (!v18 && !v17)
        {
          BOOL v20 = v12 == v2 && v15 == v3;
          BOOL v21 = v15 == v2 && v12 == v3;
          if (!v21 && !v20) {
            p2t::Triangle::MarkNeighbor();
          }
          goto LABEL_120;
        }
        goto LABEL_121;
      }
      goto LABEL_95;
    }
  }
  unint64_t v22 = this[1];
  if (v4 == v22 || v5 == v22 || v7 == v22)
  {
    if (v4 != v3 && v5 != v3 && v7 != v3)
    {
      if (!v9) {
        return this;
      }
      this[6] = a2;
      unint64_t v36 = *((void *)a2 + 2);
      unint64_t v37 = *((void *)a2 + 3);
      if (__PAIR128__(v37, v36) == __PAIR128__(v22, v2) || v37 == v2 && v36 == v22) {
        goto LABEL_95;
      }
      uint64_t v39 = *((void *)a2 + 1);
      BOOL v41 = v37 == v22 && v39 == v2;
      BOOL v42 = v39 == v22 && v37 == v2;
      if (!v42 && !v41)
      {
        BOOL v44 = v36 == v22 && v39 == v2;
        BOOL v45 = v39 == v22 && v36 == v2;
        if (!v45 && !v44) {
          p2t::Triangle::MarkNeighbor();
        }
LABEL_120:
        int v38 = (char *)a2 + 48;
        goto LABEL_96;
      }
      goto LABEL_121;
    }
    this[5] = a2;
    unint64_t v27 = *((void *)a2 + 2);
    unint64_t v28 = *((void *)a2 + 3);
    if (__PAIR128__(v28, v27) != __PAIR128__(v22, v3) && (v28 != v3 || v27 != v22))
    {
      uint64_t v29 = *((void *)a2 + 1);
      BOOL v31 = v28 == v22 && v29 == v3;
      BOOL v32 = v29 == v22 && v28 == v3;
      if (!v32 && !v31)
      {
        BOOL v34 = v27 == v22 && v29 == v3;
        BOOL v35 = v29 == v22 && v27 == v3;
        if (!v35 && !v34) {
          p2t::Triangle::MarkNeighbor();
        }
        goto LABEL_120;
      }
LABEL_121:
      int v38 = (char *)a2 + 40;
      goto LABEL_96;
    }
LABEL_95:
    int v38 = (char *)a2 + 32;
LABEL_96:
    *(void *)int v38 = this;
  }
  return this;
}

double p2t::Triangle::Clear(p2t::Triangle *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1)
  {
    unint64_t v2 = (void *)(v1 + 32);
    if (*(p2t::Triangle **)(v1 + 32) != this)
    {
      uint64_t v4 = *(p2t::Triangle **)(v1 + 40);
      unint64_t v3 = (void *)(v1 + 40);
      if (v4 == this) {
        unint64_t v2 = v3;
      }
      else {
        unint64_t v2 = v3 + 1;
      }
    }
    *unint64_t v2 = 0;
  }
  uint64_t v5 = *((void *)this + 5);
  if (v5)
  {
    BOOL v6 = (void *)(v5 + 32);
    if (*(p2t::Triangle **)(v5 + 32) != this)
    {
      BOOL v8 = *(p2t::Triangle **)(v5 + 40);
      uint64_t v7 = (void *)(v5 + 40);
      if (v8 == this) {
        BOOL v6 = v7;
      }
      else {
        BOOL v6 = v7 + 1;
      }
    }
    void *v6 = 0;
  }
  uint64_t v9 = *((void *)this + 6);
  if (v9)
  {
    BOOL v10 = (void *)(v9 + 32);
    if (*(p2t::Triangle **)(v9 + 32) != this)
    {
      uint64_t v12 = *(p2t::Triangle **)(v9 + 40);
      uint64_t v11 = (void *)(v9 + 40);
      if (v12 == this) {
        BOOL v10 = v11;
      }
      else {
        BOOL v10 = v11 + 1;
      }
    }
    *BOOL v10 = 0;
  }
  double result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  return result;
}

uint64_t p2t::Triangle::ClearNeighbor(uint64_t this, p2t::Triangle *a2)
{
  unint64_t v2 = (void *)(this + 32);
  if (*(p2t::Triangle **)(this + 32) != a2)
  {
    unint64_t v3 = *(p2t::Triangle **)(this + 40);
    this += 40;
    if (v3 == a2) {
      unint64_t v2 = (void *)this;
    }
    else {
      unint64_t v2 = (void *)(this + 8);
    }
  }
  *unint64_t v2 = 0;
  return this;
}

void *p2t::Triangle::ClearNeighbors(void *this)
{
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  return this;
}

uint64_t p2t::Triangle::ClearDelunayEdges(uint64_t this)
{
  *(unsigned char *)(this + 5) = 0;
  *(_WORD *)(this + 3) = 0;
  return this;
}

Point *p2t::Triangle::OppositePoint(p2t::Triangle *this, p2t::Triangle *a2, Point *a3)
{
  unint64_t v3 = (Point *)*((void *)a2 + 1);
  if (v3 == a3)
  {
    uint64_t v4 = (Point *)*((void *)a2 + 3);
    goto LABEL_6;
  }
  uint64_t v4 = (Point *)*((void *)a2 + 2);
  if (v4 != a3)
  {
    if (*((Point **)a2 + 3) != a3) {
      p2t::Triangle::OppositePoint();
    }
LABEL_6:
    uint64_t v5 = (Point *)*((void *)this + 1);
    if (v5 != v4) {
      goto LABEL_7;
    }
    return (Point *)*((void *)this + 3);
  }
  uint64_t v4 = (Point *)*((void *)a2 + 1);
  uint64_t v5 = (Point *)*((void *)this + 1);
  if (v5 == v3) {
    return (Point *)*((void *)this + 3);
  }
LABEL_7:
  if (*((Point **)this + 2) == v4) {
    return v5;
  }
  if (*((Point **)this + 3) != v4) {
    p2t::Triangle::OppositePoint();
  }
  return (Point *)*((void *)this + 2);
}

Point *p2t::Triangle::PointCW(p2t::Triangle *this, Point *a2)
{
  unint64_t v3 = (Point *)*((void *)this + 1);
  if (v3 == a2) {
    return (Point *)*((void *)this + 3);
  }
  double result = (Point *)*((void *)this + 2);
  if (result == a2) {
    return v3;
  }
  if (*((Point **)this + 3) != a2) {
    p2t::Triangle::OppositePoint();
  }
  return result;
}

void *p2t::Triangle::Legalize(void *this, Point *a2)
{
  uint64_t v2 = this[1];
  this[1] = this[3];
  this[2] = v2;
  this[3] = a2;
  return this;
}

void *p2t::Triangle::Legalize(void *this, Point *a2, Point *a3)
{
  unint64_t v3 = this + 1;
  uint64_t v4 = (Point *)this[1];
  if (v4 == a2)
  {
    uint64_t v6 = this[3];
    this += 3;
    *(this - 2) = v6;
    *(this - 1) = a2;
    *this = a3;
  }
  else
  {
    uint64_t v5 = (Point *)this[2];
    if (v5 == a2)
    {
      this[2] = v4;
      this[3] = a2;
      void *v3 = a3;
    }
    else
    {
      if ((Point *)this[3] != a2) {
        p2t::Triangle::Legalize();
      }
      this[1] = a2;
      this[3] = v5;
      this += 2;
      v3[1] = a3;
    }
  }
  return this;
}

uint64_t p2t::Triangle::Index(const Point **this, const Point *a2)
{
  if (this[1] == a2) {
    return 0;
  }
  if (this[2] == a2) {
    return 1;
  }
  if (this[3] != a2) {
    p2t::Triangle::Index();
  }
  return 2;
}

uint64_t p2t::Triangle::EdgeIndex(p2t::Triangle *this, const Point *a2, const Point *a3)
{
  unint64_t v3 = (const Point *)*((void *)this + 1);
  uint64_t v4 = (const Point *)*((void *)this + 2);
  if (v3 == a2)
  {
    if (v4 != a3)
    {
      if (*((const Point **)this + 3) != a3) {
        return 0xFFFFFFFFLL;
      }
      return 1;
    }
    return 2;
  }
  uint64_t v5 = (const Point *)*((void *)this + 3);
  if (v4 != a2)
  {
    if (v5 != a2) {
      return 0xFFFFFFFFLL;
    }
    if (v3 != a3)
    {
      if (v4 == a3) {
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
    return 1;
  }
  if (v5 != a3)
  {
    if (v3 != a3) {
      return 0xFFFFFFFFLL;
    }
    return 2;
  }
  return 0;
}

uint64_t p2t::Triangle::MarkConstrainedEdge(uint64_t this, int a2)
{
  *(unsigned char *)(this + a2) = 1;
  return this;
}

uint64_t p2t::Triangle::MarkConstrainedEdge(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v5 = *(void *)(result + 8);
  uint64_t v4 = *(void *)(result + 16);
  if (v5 != v3)
  {
    BOOL v6 = v4 == v3;
    BOOL v8 = v5 == v2;
    BOOL v7 = v5 == v2;
    BOOL v8 = v8 && v4 == v3;
    if (!v8)
    {
      uint64_t v9 = *(void *)(result + 24);
      goto LABEL_7;
    }
LABEL_29:
    *(unsigned char *)(result + 2) = 1;
    return result;
  }
  if (v4 == v2) {
    goto LABEL_29;
  }
  BOOL v6 = v4 == v3;
  BOOL v7 = v3 == v2;
  if (v3 == v2 && v4 == v3) {
    goto LABEL_29;
  }
  uint64_t v9 = *(void *)(result + 24);
  if (v9 == v2)
  {
LABEL_28:
    *(unsigned char *)(result + 1) = 1;
    return result;
  }
LABEL_7:
  if (v7 && v9 == v3) {
    goto LABEL_28;
  }
  if (v9 != v2) {
    BOOL v6 = 0;
  }
  BOOL v12 = v4 == v2 && v9 == v3;
  if (v6 || v12) {
    *(unsigned char *)double result = 1;
  }
  return result;
}

uint64_t p2t::Triangle::MarkConstrainedEdge(uint64_t this, Point *a2, Point *a3)
{
  uint64_t v4 = *(Point **)(this + 8);
  uint64_t v3 = *(Point **)(this + 16);
  if (v4 != a3)
  {
    BOOL v5 = v3 == a3;
    BOOL v7 = v4 == a2;
    BOOL v6 = v4 == a2;
    BOOL v7 = v7 && v3 == a3;
    if (!v7)
    {
      BOOL v8 = *(Point **)(this + 24);
      goto LABEL_7;
    }
LABEL_29:
    *(unsigned char *)(this + 2) = 1;
    return this;
  }
  if (v3 == a2) {
    goto LABEL_29;
  }
  BOOL v5 = v3 == a3;
  BOOL v7 = v4 == a2;
  BOOL v6 = v4 == a2;
  if (v7 && v3 == a3) {
    goto LABEL_29;
  }
  BOOL v8 = *(Point **)(this + 24);
  if (v8 == a2)
  {
LABEL_28:
    *(unsigned char *)(this + 1) = 1;
    return this;
  }
LABEL_7:
  if (v6 && v8 == a3) {
    goto LABEL_28;
  }
  if (v8 != a2) {
    BOOL v5 = 0;
  }
  BOOL v11 = v3 == a2 && v8 == a3;
  if (v5 || v11) {
    *(unsigned char *)this = 1;
  }
  return this;
}

Point *p2t::Triangle::PointCCW(p2t::Triangle *this, Point *a2)
{
  double result = (Point *)*((void *)this + 1);
  uint64_t v4 = (Point *)*((void *)this + 2);
  if (result == a2) {
    return (Point *)*((void *)this + 2);
  }
  BOOL v5 = (Point *)*((void *)this + 3);
  if (v4 == a2) {
    return v5;
  }
  if (v5 != a2) {
    p2t::Triangle::PointCCW();
  }
  return result;
}

uint64_t p2t::Triangle::NeighborCW(p2t::Triangle *this, Point *a2)
{
  if (*((Point **)this + 1) == a2) {
    return *((void *)this + 5);
  }
  uint64_t v2 = (char *)this + 32;
  if (*((Point **)this + 2) == a2) {
    uint64_t v2 = (char *)this + 48;
  }
  return *(void *)v2;
}

uint64_t p2t::Triangle::NeighborCCW(p2t::Triangle *this, Point *a2)
{
  if (*((Point **)this + 1) == a2) {
    return *((void *)this + 6);
  }
  uint64_t v2 = (char *)this + 40;
  if (*((Point **)this + 2) == a2) {
    uint64_t v2 = (char *)this + 32;
  }
  return *(void *)v2;
}

uint64_t p2t::Triangle::GetConstrainedEdgeCCW(Point **this, Point *a2)
{
  if (this[1] == a2) {
    return *((unsigned __int8 *)this + 2);
  }
  if (this[2] == a2) {
    uint64_t v2 = this;
  }
  else {
    uint64_t v2 = (Point **)((char *)this + 1);
  }
  return *(unsigned __int8 *)v2;
}

uint64_t p2t::Triangle::GetConstrainedEdgeCW(Point **this, Point *a2)
{
  if (this[1] == a2) {
    return *((unsigned __int8 *)this + 1);
  }
  if (this[2] == a2) {
    uint64_t v2 = (Point **)((char *)this + 2);
  }
  else {
    uint64_t v2 = this;
  }
  return *(unsigned __int8 *)v2;
}

uint64_t p2t::Triangle::SetConstrainedEdgeCCW(uint64_t this, Point *a2, char a3)
{
  if (*(Point **)(this + 8) == a2)
  {
    *(unsigned char *)(this + 2) = a3;
  }
  else if (*(Point **)(this + 16) == a2)
  {
    *(unsigned char *)this = a3;
  }
  else
  {
    *(unsigned char *)(this + 1) = a3;
  }
  return this;
}

uint64_t p2t::Triangle::SetConstrainedEdgeCW(uint64_t this, Point *a2, char a3)
{
  if (*(Point **)(this + 8) == a2)
  {
    *(unsigned char *)(this + 1) = a3;
  }
  else if (*(Point **)(this + 16) == a2)
  {
    *(unsigned char *)(this + 2) = a3;
  }
  else
  {
    *(unsigned char *)this = a3;
  }
  return this;
}

uint64_t p2t::Triangle::GetDelunayEdgeCCW(Point **this, Point *a2)
{
  if (this[1] == a2) {
    return *((unsigned __int8 *)this + 5);
  }
  uint64_t v2 = (unsigned __int8 *)this + 4;
  if (this[2] == a2) {
    uint64_t v2 = (unsigned __int8 *)this + 3;
  }
  return *v2;
}

uint64_t p2t::Triangle::GetDelunayEdgeCW(Point **this, Point *a2)
{
  if (this[1] == a2) {
    return *((unsigned __int8 *)this + 4);
  }
  uint64_t v2 = (unsigned __int8 *)this + 3;
  if (this[2] == a2) {
    uint64_t v2 = (unsigned __int8 *)this + 5;
  }
  return *v2;
}

uint64_t p2t::Triangle::SetDelunayEdgeCCW(uint64_t this, Point *a2, char a3)
{
  if (*(Point **)(this + 8) == a2)
  {
    *(unsigned char *)(this + 5) = a3;
  }
  else
  {
    uint64_t v3 = (unsigned char *)(this + 4);
    if (*(Point **)(this + 16) == a2) {
      uint64_t v3 = (unsigned char *)(this + 3);
    }
    unsigned char *v3 = a3;
  }
  return this;
}

uint64_t p2t::Triangle::SetDelunayEdgeCW(uint64_t this, Point *a2, char a3)
{
  if (*(Point **)(this + 8) == a2)
  {
    *(unsigned char *)(this + 4) = a3;
  }
  else
  {
    uint64_t v3 = (unsigned char *)(this + 3);
    if (*(Point **)(this + 16) == a2) {
      uint64_t v3 = (unsigned char *)(this + 5);
    }
    unsigned char *v3 = a3;
  }
  return this;
}

uint64_t p2t::Triangle::NeighborAcross(p2t::Triangle *this, Point *a2)
{
  if (*((Point **)this + 1) == a2) {
    return *((void *)this + 4);
  }
  uint64_t v2 = (char *)this + 48;
  if (*((Point **)this + 2) == a2) {
    uint64_t v2 = (char *)this + 40;
  }
  return *(void *)v2;
}

uint64_t p2t::Triangle::DebugPrint(p2t::Triangle *this)
{
  uint64_t v1 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v1, (uint64_t)",", 1);
  uint64_t v2 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)" ", 1);
  uint64_t v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)",", 1);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)" ", 1);
  BOOL v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)",", 1);
  BOOL v6 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)));
  BOOL v7 = std::locale::use_facet(&v9, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
  std::locale::~locale(&v9);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_235F05B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *OpenSteer::PlugIn::PlugIn(void *this)
{
  *this = &unk_26E9433C8;
  uint64_t v1 = OpenSteer::PlugIn::itemsInRegistry++;
  OpenSteer::PlugIn::registry[v1] = (uint64_t)this;
  return this;
}

uint64_t OpenSteer::PlugIn::addToRegistry(uint64_t this)
{
  uint64_t v1 = OpenSteer::PlugIn::itemsInRegistry++;
  OpenSteer::PlugIn::registry[v1] = this;
  return this;
}

uint64_t OpenSteer::PlugIn::next(OpenSteer::PlugIn *this)
{
  if (OpenSteer::PlugIn::itemsInRegistry < 1) {
    return 0;
  }
  uint64_t v1 = 0;
  while ((OpenSteer::PlugIn *)OpenSteer::PlugIn::registry[v1] != this)
  {
    if (OpenSteer::PlugIn::itemsInRegistry == ++v1) {
      return 0;
    }
  }
  if (OpenSteer::PlugIn::itemsInRegistry - 1 == v1) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = (v1 + 1);
  }
  return OpenSteer::PlugIn::registry[v3];
}

uint64_t OpenSteer::PlugIn::findByName(OpenSteer::PlugIn *this, const char *a2)
{
  uint64_t v2 = 0;
  if (this && OpenSteer::PlugIn::itemsInRegistry >= 1)
  {
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v2 = OpenSteer::PlugIn::registry[v4];
      BOOL v5 = (const char *)(*(uint64_t (**)(uint64_t, const char *))(*(void *)v2 + 40))(v2, a2);
      if (v5)
      {
        if (!strcmp((const char *)this, v5)) {
          break;
        }
      }
      if (++v4 >= OpenSteer::PlugIn::itemsInRegistry) {
        return 0;
      }
    }
  }
  return v2;
}

uint64_t (*OpenSteer::PlugIn::applyToAll(uint64_t (*this)(uint64_t, void (*)(OpenSteer::PlugIn *)), void (*a2)(OpenSteer::PlugIn *)))(uint64_t, void (*)(OpenSteer::PlugIn *))
{
  if (OpenSteer::PlugIn::itemsInRegistry >= 1)
  {
    uint64_t v2 = this;
    uint64_t v3 = 0;
    do
      this = (uint64_t (*)(uint64_t, void (*)(OpenSteer::PlugIn *)))v2(OpenSteer::PlugIn::registry[v3++], a2);
    while (v3 < OpenSteer::PlugIn::itemsInRegistry);
  }
  return this;
}

void OpenSteer::PlugIn::sortBySelectionOrder(OpenSteer::PlugIn *this)
{
  int v1 = OpenSteer::PlugIn::itemsInRegistry;
  if (OpenSteer::PlugIn::itemsInRegistry >= 2)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 1;
    do
    {
      uint64_t v4 = v2 + 1;
      if (v2 + 1 < v1)
      {
        uint64_t v5 = v3;
        do
        {
          float v6 = (*(float (**)(uint64_t))(*(void *)OpenSteer::PlugIn::registry[v2] + 48))(OpenSteer::PlugIn::registry[v2]);
          if (v6 > (*(float (**)(uint64_t))(*(void *)OpenSteer::PlugIn::registry[v5] + 48))(OpenSteer::PlugIn::registry[v5]))
          {
            uint64_t v7 = OpenSteer::PlugIn::registry[v2];
            OpenSteer::PlugIn::registry[v2] = OpenSteer::PlugIn::registry[v5];
            OpenSteer::PlugIn::registry[v5] = v7;
          }
          ++v5;
          int v1 = OpenSteer::PlugIn::itemsInRegistry;
        }
        while (OpenSteer::PlugIn::itemsInRegistry > (int)v5);
      }
      ++v3;
      ++v2;
    }
    while (v4 < v1 - 1);
  }
}

uint64_t OpenSteer::PlugIn::findDefault(OpenSteer::PlugIn *this)
{
  if (!OpenSteer::PlugIn::itemsInRegistry) {
    return 0;
  }
  if (OpenSteer::PlugIn::itemsInRegistry < 1)
  {
    unint64_t i = OpenSteer::PlugIn::registry;
  }
  else
  {
    uint64_t v1 = 0;
    for (unint64_t i = OpenSteer::PlugIn::registry; !(*(unsigned int (**)(void))(*(void *)*i + 56))(); ++i)
    {
      if (++v1 >= OpenSteer::PlugIn::itemsInRegistry) {
        return OpenSteer::PlugIn::registry[0];
      }
    }
  }
  return *i;
}

uint64_t OpenSteer::PlugIn::reset(uint64_t (***this)(OpenSteer::PlugIn *))
{
  (*this)[3]((OpenSteer::PlugIn *)this);
  uint64_t v2 = **this;

  return v2((OpenSteer::PlugIn *)this);
}

float OpenSteer::PlugIn::selectionOrderSortKey(OpenSteer::PlugIn *this)
{
  return 1.0;
}

uint64_t OpenSteer::PlugIn::requestInitialSelection(OpenSteer::PlugIn *this)
{
  return 0;
}

void *OpenSteer::PolygonObstacle::PolygonObstacle(void *this)
{
  *this = &unk_26E943468;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = &unk_26E943468;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

void *OpenSteer::PolygonObstacle::PolygonObstacle(void *a1, void *a2)
{
  a1[1] = 0;
  uint64_t v4 = a1 + 1;
  *a1 = &unk_26E943468;
  a1[2] = 0;
  a1[3] = 0;
  uint64_t v5 = (_OWORD *)*a2;
  float v6 = (_OWORD *)a2[1];
  uint64_t v7 = (uint64_t)v6 - *a2;
  unint64_t v8 = v7 / 12;
  if ((unint64_t)(v7 + 11) >= 0x17)
  {
    std::vector<OpenSteer::Vec3>::__append((uint64_t)(a1 + 1), v8);
    uint64_t v5 = (_OWORD *)*a2;
    float v6 = (_OWORD *)a2[1];
    unint64_t v8 = ((uint64_t)v6 - *a2) / 12;
  }
  if (v6 != v5)
  {
    unint64_t v9 = *v4;
    if (v8 <= 1) {
      unint64_t v10 = 1;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10 < 0xC)
    {
      unint64_t v11 = 0;
LABEL_9:
      unint64_t v12 = v9 + 12 * v11;
      uint64_t v13 = (char *)v5 + 12 * v11;
      unint64_t v14 = v10 - v11;
      do
      {
        uint64_t v15 = *(void *)v13;
        *(_DWORD *)(v12 + 8) = *((_DWORD *)v13 + 2);
        *(void *)unint64_t v12 = v15;
        v12 += 12;
        v13 += 12;
        --v14;
      }
      while (v14);
      return a1;
    }
    unint64_t v11 = 0;
    unint64_t v17 = v9 + 12 * v10;
    unint64_t v18 = v17 - 8;
    unint64_t v19 = (unint64_t)v5 + 12 * v10;
    BOOL v21 = v9 + 4 < v19 - 4 && (unint64_t)v5 + 4 < v17 - 4;
    BOOL v23 = v9 + 8 < v19 && (unint64_t)v5 + 8 < v17;
    if ((unint64_t)v5 < v18 && v9 < v19 - 8) {
      goto LABEL_9;
    }
    if (v21) {
      goto LABEL_9;
    }
    if (v23) {
      goto LABEL_9;
    }
    unint64_t v11 = v10 & 0xFFFFFFFFFFFFFFF8;
    unint64_t v25 = v10 & 0xFFFFFFFFFFFFFFF8;
    float v26 = v5;
    unint64_t v27 = (_OWORD *)*v4;
    do
    {
      long long v28 = v26[1];
      long long v30 = v26[4];
      long long v29 = v26[5];
      long long v31 = v26[2];
      long long v32 = v26[3];
      *unint64_t v27 = *v26;
      v27[1] = v28;
      v27[2] = v31;
      v27[3] = v32;
      v27[4] = v30;
      v27[5] = v29;
      v27 += 6;
      v26 += 6;
      v25 -= 8;
    }
    while (v25);
    if (v10 != v11) {
      goto LABEL_9;
    }
  }
  return a1;
}

{
  unint64_t *v4;
  _OWORD *v5;
  _OWORD *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v22;
  BOOL v24;
  unint64_t v26;
  _OWORD *v27;
  _OWORD *v28;
  long long v29;
  long long v30;
  long long v31;
  long long v32;
  long long v33;

  a1[1] = 0;
  uint64_t v4 = a1 + 1;
  *a1 = &unk_26E943468;
  a1[2] = 0;
  a1[3] = 0;
  uint64_t v5 = (_OWORD *)*a2;
  float v6 = (_OWORD *)a2[1];
  uint64_t v7 = (uint64_t)v6 - *a2;
  unint64_t v8 = v7 / 12;
  if ((unint64_t)(v7 + 11) >= 0x17)
  {
    std::vector<OpenSteer::Vec3>::__append((uint64_t)(a1 + 1), v8);
    uint64_t v5 = (_OWORD *)*a2;
    float v6 = (_OWORD *)a2[1];
    unint64_t v8 = ((uint64_t)v6 - *a2) / 12;
  }
  if (v6 != v5)
  {
    unint64_t v9 = *v4;
    if (v8 <= 1) {
      unint64_t v10 = 1;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10 < 0xC)
    {
      unint64_t v11 = 0;
LABEL_9:
      unint64_t v12 = v10 - v11;
      uint64_t v13 = 12 * v11;
      unint64_t v14 = v9 + v13;
      uint64_t v15 = (char *)v5 + v13;
      do
      {
        float v16 = *(void *)v15;
        *(_DWORD *)(v14 + 8) = *((_DWORD *)v15 + 2);
        *(void *)unint64_t v14 = v16;
        v14 += 12;
        v15 += 12;
        --v12;
      }
      while (v12);
      return a1;
    }
    unint64_t v11 = 0;
    unint64_t v18 = v9 + 12 * v10;
    unint64_t v19 = v18 - 8;
    BOOL v20 = (unint64_t)v5 + 12 * v10;
    unint64_t v22 = v9 + 4 < v20 - 4 && (unint64_t)v5 + 4 < v18 - 4;
    float v24 = v9 + 8 < v20 && (unint64_t)v5 + 8 < v18;
    if ((unint64_t)v5 < v19 && v9 < v20 - 8) {
      goto LABEL_9;
    }
    if (v22) {
      goto LABEL_9;
    }
    if (v24) {
      goto LABEL_9;
    }
    unint64_t v11 = v10 & 0xFFFFFFFFFFFFFFF8;
    float v26 = v10 & 0xFFFFFFFFFFFFFFF8;
    unint64_t v27 = v5;
    long long v28 = (_OWORD *)*v4;
    do
    {
      long long v29 = v27[1];
      long long v31 = v27[4];
      long long v30 = v27[5];
      long long v32 = v27[2];
      uint64_t v33 = v27[3];
      void *v28 = *v27;
      v28[1] = v29;
      v28[2] = v32;
      v28[3] = v33;
      v28[4] = v31;
      v28[5] = v30;
      v28 += 6;
      v27 += 6;
      v26 -= 8;
    }
    while (v26);
    if (v10 != v11) {
      goto LABEL_9;
    }
  }
  return a1;
}

void sub_235F0615C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_235F06318(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

float OpenSteer::PolygonObstacle::steerToAvoid()
{
  return *(float *)&_static_vec3_zero;
}

void OpenSteer::PolygonObstacle::findIntersectionWithVehiclePath(uint64_t a1, uint64_t a2, uint64_t a3, __n128 a4)
{
  *(_DWORD *)a3 = 0;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2) >= 3)
  {
    unsigned int v36 = COERCE_UNSIGNED_INT64((*(double (**)(uint64_t))(*(void *)a2 + 48))(a2));
    (*(void (**)(uint64_t))(*(void *)a2 + 48))(a2);
    unsigned int v33 = v8;
    unsigned int v32 = COERCE_UNSIGNED_INT64((*(double (**)(uint64_t))(*(void *)a2 + 192))(a2));
    (*(void (**)(uint64_t))(*(void *)a2 + 192))(a2);
    __p = 0;
    BOOL v41 = 0;
    uint64_t v42 = 0;
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11 != v10)
    {
      unsigned int v31 = v9;
      _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE8__appendEm((char **)&__p, 0xAAAAAAAAAAAAAAABLL * ((v11 - v10) >> 2));
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(void *)(a1 + 16);
      unsigned int v9 = v31;
    }
    if (v11 != v10)
    {
      uint64_t v12 = 0;
      unint64_t v13 = 0;
      do
      {
        unint64_t v14 = (_DWORD *)(v10 + v12);
        LODWORD(v15) = *v14;
        HIDWORD(v15) = v14[2];
        *((void *)__p + v13++) = v15;
        uint64_t v10 = *(void *)(a1 + 8);
        v12 += 12;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v10) >> 2) > v13);
    }
    float v16 = (char *)__p;
    if (v41 == __p)
    {
      *(void *)&long long v35 = 0;
      v4.i32[0] = 2139095039;
      float v30 = 3.4028e38;
    }
    else
    {
      unint64_t v17 = 0;
      float32x2_t v37 = (float32x2_t)__PAIR64__(v33, v36);
      *((void *)&v18 + 1) = a4.n128_u64[1];
      float32x2_t v19 = vmla_n_f32(v37, (float32x2_t)__PAIR64__(v9, v32), a4.n128_f32[0]);
      unint64_t v20 = (v41 - (unsigned char *)__p) >> 3;
      float v21 = 3.4028e38;
      v4.i32[0] = 2139095039;
      *(void *)&long long v18 = 0;
      long long v35 = v18;
      do
      {
        unint64_t v25 = v17 + 1;
        float32x2_t v26 = *(float32x2_t *)&v16[8 * v17];
        if (v20 > v17 + 1) {
          unint64_t v27 = v17 + 1;
        }
        else {
          unint64_t v27 = 0;
        }
        float32x2_t v28 = *(float32x2_t *)&v16[8 * v27];
        float32x2_t v38 = 0;
        float32x2_t v39 = 0;
        GKClosestPointsBetweenLineSegments(&v39, (double *)&v38, v26, v28, v37, v19);
        float32x2_t v29 = vsub_f32(v38, v39);
        float v30 = vaddv_f32(vmul_f32(v29, v29));
        if (v30 < v21)
        {
          *((void *)&v22 + 1) = *((void *)&v35 + 1);
          float32x2_t v23 = vsub_f32(v39, v37);
          float32x2_t v24 = vmul_f32(v23, v23);
          *(int8x8_t *)&long long v22 = vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v4, vadd_f32(v24, (float32x2_t)vdup_lane_s32((int32x2_t)v24, 1))), 0), (int8x8_t)v39, *(int8x8_t *)&v35);
          long long v35 = v22;
          v4.f32[0] = fminf(vaddv_f32(v24), v4.f32[0]);
          float v21 = v30;
        }
        else
        {
          float v30 = v21;
        }
        float v16 = (char *)__p;
        unint64_t v20 = (v41 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v25;
      }
      while (v20 > v25);
    }
    if (v30 <= (*(float (**)(uint64_t))(*(void *)a2 + 176))(a2))
    {
      *(_DWORD *)a3 = 1;
      *(float *)(a3 + 4) = sqrtf(v4.f32[0]);
      *(void *)(a3 + 8) = v35;
      *(_DWORD *)(a3 + 16) = DWORD1(v35);
      *(void *)(a3 + 32) = a1;
    }
    if (__p)
    {
      BOOL v41 = __p;
      operator delete(__p);
    }
  }
}

void sub_235F06654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GKDoesLineSegmentIntersectPolygon(uint64_t a1, int a2, float32x2_t a3, float32x2_t a4)
{
  if (a2 >= 1)
  {
    uint64_t v4 = 0;
    int32x2_t v5 = (int32x2_t)vsub_f32(a4, a3);
    float32x2_t v6 = (float32x2_t)vrev64_s32(v5);
    char v7 = 1;
    while (1)
    {
      uint64_t v10 = v4 + 1;
      float32x2_t v11 = *(float32x2_t *)(a1 + 8 * v4);
      if (v4 + 1 < (unint64_t)a2) {
        uint64_t v12 = v4 + 1;
      }
      else {
        uint64_t v12 = 0;
      }
      float32x2_t v13 = *(float32x2_t *)(a1 + 8 * v12);
      BOOL v14 = v4 + 1 < (unint64_t)a2;
      float32x2_t v15 = vsub_f32(v13, v11);
      float32x2_t v16 = vsub_f32(v11, a3);
      float32x2_t v17 = vmul_f32(v15, v6);
      int32x2_t v18 = (int32x2_t)vsub_f32(v17, (float32x2_t)vdup_lane_s32((int32x2_t)v17, 1));
      float32x2_t v19 = vmls_lane_f32(vmul_lane_f32((float32x2_t)vzip1_s32(v5, (int32x2_t)v15), v16, 1), (float32x2_t)vzip2_s32(v5, (int32x2_t)v15), v16, 0);
      if (*(float *)v18.i32 == 0.0)
      {
        if (v19.f32[1] == 0.0 && v19.f32[0] == 0.0) {
          return v7 & 1;
        }
      }
      else
      {
        *(float32x2_t *)v8.f32 = vdiv_f32(v19, (float32x2_t)vdup_lane_s32(v18, 0));
        v8.i64[1] = v8.i64[0];
        v9.i32[0] = vmovn_s32(vcgeq_f32((float32x4_t)xmmword_235F1F2A0, v8)).u32[0];
        v9.i32[1] = vmovn_s32(vcgeq_f32(v8, (float32x4_t)xmmword_235F1F2A0)).i32[1];
        if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(v9, 0xFuLL)))) {
          return v7 & 1;
        }
      }
      ++v4;
      char v7 = v14;
      if (a2 == v10) {
        return v7 & 1;
      }
    }
  }
  return 0;
}

void GKGetLineSegmentPolygonIntersectionPoints(uint64_t a1@<X0>, int a2@<W1>, float32x2_t **a3@<X8>, float32x2_t a4@<D0>, float32x2_t a5@<D1>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2 >= 1)
  {
    int16x4_t v9 = 0;
    unint64_t v10 = 0;
    int32x2_t v11 = (int32x2_t)vsub_f32(a5, a4);
    float32x2_t v12 = (float32x2_t)vrev64_s32(v11);
    unint64_t v13 = a2;
    while (1)
    {
      int32x2_t v15 = *(int32x2_t *)(a1 + 8 * v10++);
      uint64_t v16 = v10;
      if (v10 >= v13) {
        uint64_t v16 = 0;
      }
      int32x2_t v17 = *(int32x2_t *)(a1 + 8 * v16);
      int32x2_t v18 = (int32x2_t)vsub_f32((float32x2_t)v17, (float32x2_t)v15);
      float32x2_t v19 = vsub_f32((float32x2_t)v15, a4);
      int32x2_t v20 = (int32x2_t)vmul_f32((float32x2_t)v18, v12);
      int32x2_t v21 = (int32x2_t)vsub_f32((float32x2_t)v20, (float32x2_t)vdup_lane_s32(v20, 1));
      float32x2_t v22 = vmls_lane_f32(vmul_lane_f32((float32x2_t)vzip1_s32(v11, v18), v19, 1), (float32x2_t)vzip2_s32(v11, v18), v19, 0);
      if (*(float *)v21.i32 == 0.0)
      {
        if (v22.f32[1] != 0.0 || v22.f32[0] != 0.0) {
          goto LABEL_5;
        }
      }
      else
      {
        *(float32x2_t *)v24.f32 = vdiv_f32(v22, (float32x2_t)vdup_lane_s32(v21, 0));
        v24.i64[1] = v24.i64[0];
        v25.i32[0] = vmovn_s32(vcgeq_f32((float32x4_t)xmmword_235F1F2A0, v24)).u32[0];
        v25.i32[1] = vmovn_s32(vcgeq_f32(v24, (float32x4_t)xmmword_235F1F2A0)).i32[1];
        if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(v25, 0xFuLL))) & 1) == 0) {
          goto LABEL_5;
        }
      }
      float32x2_t v26 = GKGetLineSegmentToLineSegmentIntersectionPoint(v15, v17, (int32x2_t)a4, (int32x2_t)a5);
      float32x2_t v27 = v26;
      unint64_t v28 = (unint64_t)a3[2];
      if ((unint64_t)v9 >= v28) {
        break;
      }
      *int16x4_t v9 = v26;
      BOOL v14 = v9 + 1;
LABEL_4:
      a3[1] = v14;
      int16x4_t v9 = v14;
LABEL_5:
      if (v10 == v13) {
        return;
      }
    }
    float32x2_t v29 = *a3;
    uint64_t v30 = v9 - *a3;
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v32 = v28 - (void)v29;
    if (v32 >> 2 > v31) {
      unint64_t v31 = v32 >> 2;
    }
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33)
    {
      if (v33 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      BOOL v34 = (char *)operator new(8 * v33);
      long long v35 = (float32x2_t *)&v34[8 * v30];
      *long long v35 = v27;
      BOOL v14 = v35 + 1;
      if (v9 == v29)
      {
LABEL_26:
        *a3 = v35;
        a3[1] = v14;
        a3[2] = (float32x2_t *)&v34[8 * v33];
        if (!v9) {
          goto LABEL_4;
        }
        goto LABEL_31;
      }
    }
    else
    {
      BOOL v34 = 0;
      long long v35 = (float32x2_t *)(8 * v30);
      unsigned int v36 = (float32x2_t *)(8 * v30);
      *unsigned int v36 = v26;
      BOOL v14 = v36 + 1;
      if (v9 == v29) {
        goto LABEL_26;
      }
    }
    do
    {
      float32x2_t v37 = v9[-1];
      --v9;
      v35[-1] = v37;
      --v35;
    }
    while (v9 != v29);
    int16x4_t v9 = *a3;
    *a3 = v35;
    a3[1] = v14;
    a3[2] = (float32x2_t *)&v34[8 * v33];
    if (!v9) {
      goto LABEL_4;
    }
LABEL_31:
    operator delete(v9);
    goto LABEL_4;
  }
}

void sub_235F06988(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void OpenSteer::PolygonObstacle::~PolygonObstacle(OpenSteer::PolygonObstacle *this)
{
  *(void *)this = &unk_26E943468;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E943468;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x237DF7CA0);
}

void std::vector<OpenSteer::Vec3>::__append(uint64_t a1, unint64_t a2)
{
  int32x2_t v5 = *(_DWORD **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v5) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v12 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(a1 + 8), v12);
      int32x2_t v5 = (_DWORD *)((char *)v5 + v12);
    }
    *(void *)(a1 + 8) = v5;
  }
  else
  {
    float32x2_t v6 = *(_DWORD **)a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *(void *)a1) >> 2);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x1555555555555555) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v6) >> 2);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x1555555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x1555555555555555) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int32x2_t v11 = (char *)operator new(12 * v10);
    }
    else
    {
      int32x2_t v11 = 0;
    }
    unint64_t v13 = &v11[12 * v7];
    BOOL v14 = &v11[12 * v10];
    size_t v15 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v13, v15);
    uint64_t v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        uint64_t v17 = *(void *)(v5 - 3);
        v5 -= 3;
        int v18 = v5[2];
        *(void *)(v13 - 12) = v17;
        v13 -= 12;
        *((_DWORD *)v13 + 2) = v18;
      }
      while (v5 != v6);
      int32x2_t v5 = *(_DWORD **)a1;
    }
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v16;
    *(void *)(a1 + 16) = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE8__appendEm(char **a1, unint64_t a2)
{
  int32x2_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      uint64_t v12 = 8 * a2;
      bzero(a1[1], 8 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    float32x2_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 3;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 61) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 2 > v8) {
      unint64_t v8 = v9 >> 2;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int32x2_t v11 = (char *)operator new(8 * v10);
    }
    else
    {
      int32x2_t v11 = 0;
    }
    unint64_t v13 = &v11[8 * v7];
    size_t v14 = 8 * a2;
    size_t v15 = &v11[8 * v10];
    bzero(v13, v14);
    uint64_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        uint64_t v17 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v13 - 1) = v17;
        v13 -= 8;
      }
      while (v5 != v6);
      int32x2_t v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_235F07B1C(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C40803BBFE3);
  _Unwind_Resume(a1);
}

void sub_235F07C58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F07CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)GKGraphNode;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_235F07D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F07E70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F07EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F07FAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F07FC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F07FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F080E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_235F08398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F084C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F08558(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C4073C85EA4);
  _Unwind_Resume(a1);
}

void sub_235F08670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F087C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F088E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F088F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F089A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08A24(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C40C1486C86);
  _Unwind_Resume(a1);
}

void sub_235F08B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08C08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08C90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08DC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08DE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08DF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F08F34(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C4073C85EA4);
  _Unwind_Resume(a1);
}

void sub_235F090D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0915C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F09214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0922C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F092C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F09514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double getGradientCoherentNoise(double *a1, __int16 a2)
{
  long long v2 = *(_OWORD *)a1;
  int v3 = (int)*a1 - (*a1 <= 0.0);
  int v4 = (int)a1[1] - (a1[1] <= 0.0);
  double v5 = a1[2];
  int v6 = (int)v5 - (v5 <= 0.0);
  int v7 = v4 + 1;
  int v8 = v6 + 1;
  double v9 = *a1 - (double)v3;
  double v10 = a1[1] - (double)v4;
  double v11 = v5 - (double)v6;
  __int16 v12 = 31337 * v4;
  LOWORD(v4) = 1619 * v3 + 31337 * v4;
  LOWORD(v6) = 1013 * a2 + 6971 * v6;
  unint64_t v13 = (double *)((char *)&g_randomVectors + 32 * ((v6 + v4) ^ ((unsigned __int16)(v6 + v4) >> 8)));
  double v14 = (v10 * v13[1] + v9 * *v13 + v11 * v13[2]) * 2.12;
  size_t v15 = (double *)((char *)&g_randomVectors
                 + 32
                 * ((v6 + 83 * v3 + 83 + v12) ^ ((unsigned __int16)(v6 + 1619 * v3 + 1619 + v12) >> 8)));
  *(double *)&long long v2 = *(double *)&v2 - (double)(v3 + 1);
  double v16 = v14 + -(v14 - (v10 * v15[1] + v15[2] * v11 + *(double *)&v2 * *v15) * 2.12) * v9;
  uint64_t v17 = (double *)((char *)&g_randomVectors
                 + 32
                 * ((v6 + v12 + 105 + 83 * v3) ^ ((unsigned __int16)(v6 + v12 + 31337 + 1619 * v3) >> 8)));
  double v18 = *((double *)&v2 + 1) - (double)v7;
  double v19 = (*v17 * v9 + v17[1] * v18 + v17[2] * v11) * 2.12;
  int32x2_t v20 = (double *)((char *)&g_randomVectors
                 + 32
                 * ((v6 + 83 * v3 + 83 + v12 + 105) ^ ((unsigned __int16)(v6
                                                                                         + 1619 * v3
                                                                                         + 1619
                                                                                         + v12
                                                                                         + 31337) >> 8)));
  double v21 = v16 + (v19 - v16 + -(v19 - (*v20 * *(double *)&v2 + v20[1] * v18 + v20[2] * v11) * 2.12) * v9) * v10;
  float32x2_t v22 = (double *)((char *)&g_randomVectors
                 + 32 * ((v6 + 59 + v4) ^ ((unsigned __int16)(v6 + 6971 + v4) >> 8)));
  double v23 = v5 - (double)v8;
  double v24 = (*v22 * v9 + v22[1] * v10 + v22[2] * v23) * 2.12;
  int16x4_t v25 = (double *)((char *)&g_randomVectors
                 + 32
                 * ((v6 + 59 + 83 * v3 + 83 + v12) ^ ((unsigned __int16)(v6
                                                                                        + 6971
                                                                                        + 1619 * v3
                                                                                        + 1619
                                                                                        + v12) >> 8)));
  double v26 = v24 + -(v24 - (*v25 * *(double *)&v2 + v25[1] * v10 + v25[2] * v23) * 2.12) * v9;
  float32x2_t v27 = (double *)((char *)&g_randomVectors
                 + 32
                 * ((v6 + 59 + v12 + 105 + 83 * v3) ^ ((unsigned __int16)(v6
                                                                                         + 6971
                                                                                         + v12
                                                                                         + 31337
                                                                                         + 1619 * v3) >> 8)));
  double v28 = (*v27 * v9 + v27[1] * v18 + v27[2] * v23) * 2.12;
  float32x2_t v29 = (double *)((char *)&g_randomVectors
                 + 32
                 * ((v6 + 59 + 83 * v3 + 83 + v12 + 105) ^ ((unsigned __int16)(v6
                                                                                              + 6971
                                                                                              + 1619 * v3
                                                                                              + 1619
                                                                                              + v12
                                                                                              + 31337) >> 8)));
  return v21
       + (v26 - v21 + (v28 - v26 + -(v28 - (*v29 * *(double *)&v2 + v29[1] * v18 + v29[2] * v23) * 2.12) * v9) * v10)
       * v11;
}

float64_t getCoherentNoise(int8x16_t *a1, __int32 a2, int8x16_t a3)
{
  int32x4_t v3 = (int32x4_t)vextq_s8(a3, a3, 4uLL);
  int32x4_t v4 = vzip1q_s32(v3, (int32x4_t)a3);
  int v5 = a3.i32[0];
  v4.i32[3] = a2;
  __int16 v6 = vaddvq_s32(vmulq_s32(v4, (int32x4_t)xmmword_235F1F2E0));
  int v7 = (char *)&g_randomVectors + 32 * (v6 ^ HIBYTE(v6));
  v8.i64[0] = v3.i32[0];
  v8.i64[1] = v3.i32[1];
  float64x2_t v9 = vmulq_f64(*(float64x2_t *)(v7 + 8), vsubq_f64((float64x2_t)vextq_s8(*a1, a1[1], 8uLL), vcvtq_f64_s64(v8)));
  return (v9.f64[0] + (*(double *)a1->i64 - (double)v5) * *(double *)v7 + v9.f64[1]) * 2.12;
}

double lerp(double a1, double a2, double a3)
{
  return a1 + (a2 - a1) * a3;
}

double curveMap(double a1)
{
  return a1 * a1 * (3.0 - (a1 + a1));
}

void sub_235F09A6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F09BC8(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v2, 0xA1C40BD48D6D6);

  _Unwind_Resume(a1);
}

void sub_235F09C2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F09DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F09E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F09E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F09F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F09F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F09F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F0A050(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GKCOctreeNode<NSObject>::GKCOctreeNode(uint64_t a1, uint64_t a2, float32x4_t a3, float32x4_t a4, float a5)
{
  *(void *)a1 = &unk_26E9434E0;
  *(float32x4_t *)(a1 + 16) = a3;
  *(float32x4_t *)(a1 + 32) = a4;
  float32x4_t v6 = vsubq_f32(a4, a3);
  v7.i64[0] = 0x3F0000003F000000;
  v7.i64[1] = 0x3F0000003F000000;
  float32x4_t v8 = vmulq_f32(v6, v7);
  *(float32x4_t *)(a1 + 64) = v6;
  *(float32x4_t *)(a1 + 80) = vaddq_f32(v8, a3);
  *(float *)(a1 + 96) = a5;
  *(void *)(a1 + 104) = a2;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(float32x4_t *)(a1 + 48) = v8;
  float64x2_t v9 = objc_alloc_init(GKOctreeNode);
  double v10 = *(void **)(a1 + 200);
  *(void *)(a1 + 200) = v9;

  [*(id *)(a1 + 200) setCOctreeNode:a1];
  return a1;
}

void sub_235F0A0FC(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 176);
  if (v3) {
    GKCOctreeNode<NSObject>::GKCOctreeNode(v1, v3);
  }
  _Unwind_Resume(a1);
}

void *GKCOctree<NSObject>::~GKCOctree(void *a1)
{
  *a1 = &unk_26E9434B0;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void GKCOctree<NSObject>::~GKCOctree(void *a1)
{
  *a1 = &unk_26E9434B0;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x237DF7CA0);
}

void GKCOctreeNode<NSObject>::~GKCOctreeNode(uint64_t a1)
{
  GKCOctreeNode<NSObject>::~GKCOctreeNode(a1);

  JUMPOUT(0x237DF7CA0);
}

uint64_t GKCOctreeNode<NSObject>::~GKCOctreeNode(uint64_t a1)
{
  *(void *)a1 = &unk_26E9434E0;
  uint64_t v3 = (_OWORD *)(a1 + 112);
  uint64_t v2 = *(void *)(a1 + 112);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v4 = *(void *)(a1 + 120);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 128);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 136);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 144);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 152);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 160);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 168);
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  v3[2] = 0u;
  v3[3] = 0u;
  _OWORD *v3 = 0u;
  v3[1] = 0u;
  uint64_t v11 = *(void *)(a1 + 176);
  for (uint64_t i = *(void *)(a1 + 184); i != v11; i -= 8)
  {
    unint64_t v13 = *(void **)(i - 8);
  }
  *(void *)(a1 + 184) = v11;

  uint64_t v14 = *(void *)(a1 + 176);
  if (v14)
  {
    uint64_t v15 = *(void *)(a1 + 184);
    double v16 = *(void **)(a1 + 176);
    if (v15 != v14)
    {
      do
      {
        uint64_t v17 = *(void **)(v15 - 8);
        v15 -= 8;
      }
      while (v15 != v14);
      double v16 = *(void **)(a1 + 176);
    }
    *(void *)(a1 + 184) = v14;
    operator delete(v16);
  }
  return a1;
}

uint64_t GKCOctreeNode<NSObject>::addPoint(uint64_t a1, void *a2, int8x16_t a3)
{
  id v4 = a2;
  id v5 = v4;
  id v21 = v4;
  float v6 = *(float *)(a1 + 96);
  if (*(float *)(a1 + 48) < v6 || *(float *)(a1 + 52) < v6 || *(float *)(a1 + 56) < v6)
  {
    uint64_t v9 = *(void **)(a1 + 184);
    if ((unint64_t)v9 >= *(void *)(a1 + 192))
    {
      double v18 = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>((void *)(a1 + 176), &v21);
      id v5 = v21;
      *(void *)(a1 + 184) = v18;
    }
    else
    {
      id v5 = v4;
      *uint64_t v9 = v5;
      *(void *)(a1 + 184) = v9 + 1;
    }
  }
  else
  {
    int8x16_t v10 = *(int8x16_t *)(a1 + 80);
    v11.i32[1] = v10.i32[1];
    v11.i32[0] = vextq_s8(v10, v10, 8uLL).u32[0];
    int32x2_t v12 = vcge_f32(vrnd_f32((float32x2_t)__PAIR64__(a3.u32[1], vextq_s8(a3, a3, 8uLL).u32[0])), v11);
    BOOL v13 = *(float *)v10.i32 <= truncf(*(float *)a3.i32);
    if (v12.i8[4]) {
      int v14 = 2;
    }
    else {
      int v14 = 0;
    }
    if (v12.i8[0]) {
      int v15 = 4;
    }
    else {
      int v15 = 0;
    }
    int v16 = v13 | v15;
    uint64_t v17 = *(void *)(a1 + 8 * (v14 | v16) + 112);
    if (!v17) {
      operator new();
    }
    a1 = GKCOctreeNode<NSObject>::addPoint(v17, v4, (__n128)a3);
  }

  return a1;
}

void sub_235F0A634(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v2, 0x10A1C40256F229BLL);

  _Unwind_Resume(a1);
}

void sub_235F0A65C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0A670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<NSObject * {__strong}>::push_back[abi:ne180100](void *a1, id *a2)
{
  uint64_t v3 = (void *)a1[1];
  if ((unint64_t)v3 >= a1[2])
  {
    double result = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(a1, a2);
    a1[1] = result;
  }
  else
  {
    double result = *a2;
    void *v3 = result;
    a1[1] = v3 + 1;
  }
  return result;
}

uint64_t GKCOctreeNode<NSObject>::createNodeForOctant(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 8 * a2;
  if (!*(void *)(v2 + 112))
  {
    switch(a2)
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        operator new();
      default:
        GKCOctreeNode<NSObject>::createNodeForOctant();
    }
  }
  return *(void *)(v2 + 112);
}

void sub_235F0A814(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C40256F229BLL);
  _Unwind_Resume(a1);
}

uint64_t GKCOctreeNode<NSObject>::addBox(uint64_t a1, void *a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v40 = a4;
  float32x4_t v41 = a3;
  id v5 = a2;
  id v39 = v5;
  float32x4_t v6 = *(float32x4_t *)(a1 + 48);
  LODWORD(v7) = HIDWORD(*(void *)(a1 + 48));
  float v8 = *(float *)(a1 + 96);
  if (v6.f32[0] <= v8 || v7 <= v8)
  {
    int8x16_t v10 = *(void **)(a1 + 184);
    if ((unint64_t)v10 >= *(void *)(a1 + 192))
    {
      *(void *)(a1 + 184) = std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>((void *)(a1 + 176), &v39);
    }
    else
    {
      *int8x16_t v10 = v5;
      *(void *)(a1 + 184) = v10 + 1;
    }
    goto LABEL_74;
  }
  float32x4_t v11 = *(float32x4_t *)(a1 + 16);
  float32x4_t v12 = *(float32x4_t *)(a1 + 80);
  float v13 = a3.f32[0];
  float32x4_t v14 = vaddq_f32(a4, a3);
  float32x4_t v15 = vaddq_f32(v11, v6);
  BOOL v16 = v14.f32[0] > v15.f32[0] || a3.f32[0] < v11.f32[0];
  if (!v16 && a3.f32[1] >= v12.f32[1])
  {
    BOOL v17 = v14.f32[1] > (float)(v12.f32[1] + v7);
    if (a3.f32[2] < v11.f32[2]) {
      BOOL v17 = 1;
    }
    if (!v17 && v14.f32[2] <= v15.f32[2])
    {
      if (!*(void *)(a1 + 136)) {
        operator new();
      }
      goto LABEL_72;
    }
    float v13 = a3.f32[0];
    if (!v17 && v14.f32[2] <= v15.f32[2])
    {
      if (!*(void *)(a1 + 128)) {
        operator new();
      }
      goto LABEL_72;
    }
  }
  BOOL v18 = v13 < v12.f32[0];
  float32x4_t v19 = vaddq_f32(v12, v6);
  if (v14.f32[0] > v19.f32[0]) {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    BOOL v20 = a3.f32[1] >= v11.f32[1] && v14.f32[1] <= (float)(v11.f32[1] + v7);
    BOOL v21 = !v20 || a3.f32[2] < v11.f32[2];
    if (!v21 && v14.f32[2] <= v15.f32[2])
    {
      if (!*(void *)(a1 + 120)) {
        operator new();
      }
      goto LABEL_72;
    }
  }
  if (!v16)
  {
    BOOL v23 = a3.f32[1] >= v11.f32[1] && v14.f32[1] <= (float)(v11.f32[1] + v7);
    BOOL v24 = !v23 || a3.f32[2] < v11.f32[2];
    if (!v24 && v14.f32[2] <= v15.f32[2])
    {
      if (!*(void *)(a1 + 112)) {
        operator new();
      }
LABEL_72:
      uint64_t v34 = GKCOctreeNode<NSObject>::addBox((__n128)a3, (__n128)a4);
      goto LABEL_73;
    }
  }
  if (!v18)
  {
    float v26 = v12.f32[1] + v7;
    BOOL v27 = a3.f32[1] >= v12.f32[1] && v14.f32[1] <= v26;
    BOOL v28 = !v27 || a3.f32[2] < v12.f32[2];
    if (!v28 && v14.f32[2] <= v19.f32[2])
    {
      GKCOctreeNode<NSObject>::createNodeForOctant(a1, 7);
      __n128 v33 = (__n128)a4;
      __n128 v32 = (__n128)a3;
      goto LABEL_62;
    }
  }
  v12.i32[2] = *(void *)(a1 + 24);
  float32x4_t v38 = v12;
  if (isBoxInsideBox(&v41, &v40, &v38, (float32x4_t *)(a1 + 48)))
  {
    GKCOctreeNode<NSObject>::createNodeForOctant(a1, 6);
LABEL_61:
    __n128 v33 = (__n128)v40;
    __n128 v32 = (__n128)v41;
LABEL_62:
    uint64_t v34 = GKCOctreeNode<NSObject>::addBox(v32, v33);
LABEL_73:
    a1 = v34;
    goto LABEL_74;
  }
  float32x4_t v30 = *(float32x4_t *)(a1 + 80);
  v30.i32[1] = *(_DWORD *)(a1 + 20);
  float32x4_t v38 = v30;
  if (isBoxInsideBox(&v41, &v40, &v38, (float32x4_t *)(a1 + 48)))
  {
    GKCOctreeNode<NSObject>::createNodeForOctant(a1, 5);
    goto LABEL_61;
  }
  float32x4_t v31 = *(float32x4_t *)(a1 + 16);
  v31.i32[2] = *(_DWORD *)(a1 + 88);
  float32x4_t v38 = v31;
  if (isBoxInsideBox(&v41, &v40, &v38, (float32x4_t *)(a1 + 48)))
  {
    GKCOctreeNode<NSObject>::createNodeForOctant(a1, 4);
    goto LABEL_61;
  }
  std::vector<NSObject * {__strong}>::push_back[abi:ne180100]((void *)(a1 + 176), &v39);
LABEL_74:

  return a1;
}

void sub_235F0AC60(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C40256F229BLL);

  _Unwind_Resume(a1);
}

void sub_235F0AC98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL isBoxInsideBox(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4)
{
  float32x4_t v4 = *a1;
  float32x4_t v5 = *a3;
  BOOL result = 0;
  if ((vmovn_s32(vcgtq_f32(*a3, *a1)).u8[0] & 1) == 0)
  {
    int16x4_t v6 = vmovn_s32(vcgtq_f32(vaddq_f32(*a2, v4), vaddq_f32(*a4, v5)));
    if ((v6.i8[0] & 1) == 0
      && v4.f32[1] >= v5.f32[1]
      && (v6.i8[2] & 1) == 0
      && v4.f32[2] >= v5.f32[2]
      && (v6.i8[4] & 1) == 0)
    {
      return 1;
    }
  }
  return result;
}

id *GKCOctreeNode<NSObject>::queryPoint(id *result, uint64_t a2, int8x16_t a3)
{
  float v3 = *((float *)result + 24);
  if (*((float *)result + 12) <= v3 || *((float *)result + 13) <= v3 || *((float *)result + 14) <= v3)
  {
LABEL_24:
    float32x4_t v15 = (void **)result[22];
    BOOL v16 = (void **)result[23];
    if (v16 != v15) {
      return std::vector<NSObject * {__strong}>::__insert_with_size[abi:ne180100]<std::__wrap_iter<NSObject * const {__strong}*>,NSObject * const {__strong}*>((id **)a2, *(void *)(a2 + 8), v15, v16, v16 - v15);
    }
  }
  else
  {
    int8x8_t v6 = (int8x8_t)vextq_s8(a3, a3, 8uLL).u64[0];
    while (1)
    {
      BOOL v7 = *((float *)result + 20) <= truncf(*(float *)a3.i32);
      int32x2_t v8 = vcge_f32(vrnd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, v6, 4uLL)), *(float32x2_t *)((char *)result + 84));
      uint64_t v9 = (v8.i8[0] & 1) != 0 ? 2 : 0;
      uint64_t v10 = v9 | v7;
      uint64_t v11 = (v8.i8[4] & 1) != 0 ? 4 : 0;
      BOOL result = (id *)result[(v10 | v11) + 14];
      if (!result) {
        break;
      }
      float v12 = *((float *)result + 24);
      if (*((float *)result + 12) <= v12 || *((float *)result + 13) <= v12 || *((float *)result + 14) <= v12) {
        goto LABEL_24;
      }
    }
  }
  return result;
}

id *GKCOctreeNode<NSObject>::queryBox(id *result, float32x4_t *a2, float32x4_t *a3, uint64_t a4)
{
  BOOL v7 = result;
  while (1)
  {
    while (1)
    {
      int32x2_t v8 = (void **)v7[22];
      uint64_t v9 = (void **)v7[23];
      if (v9 != v8) {
        BOOL result = std::vector<NSObject * {__strong}>::__insert_with_size[abi:ne180100]<std::__wrap_iter<NSObject * const {__strong}*>,NSObject * const {__strong}*>((id **)a4, *(void *)(a4 + 8), v8, v9, v9 - v8);
      }
      float32x4_t v10 = *a2;
      float v11 = COERCE_FLOAT(a2->i64[1]);
      float32x4_t v12 = *((float32x4_t *)v7 + 5);
      float v13 = COERCE_FLOAT(v7[11]);
      LODWORD(v14) = HIDWORD(a2->i64[0]);
      LODWORD(v15) = HIDWORD(v7[10]);
      if (v11 <= v13) {
        break;
      }
      if (v14 >= v15)
      {
        float32x4_t v34 = *a3;
        float32x4_t v35 = vaddq_f32(*a3, v10);
        int16x4_t v36 = vmovn_s32(vcgtq_f32(v35, v12));
        if ((v36.i8[2] & 1) == 0)
        {
          float32x4_t v51 = *((float32x4_t *)v7 + 1);
          if (v36.i8[0])
          {
            float32x4_t v52 = *((float32x4_t *)v7 + 3);
            int16x4_t v53 = vmovn_s32(vcgtq_f32(vaddq_f32(v52, v12), v10));
            if ((v53.i8[0] & 1) != 0
              && (vmovn_s32(vcgtq_f32(v35, v51)).i8[2] & 1) != 0
              && (vmovn_s32(vcgtq_f32(vaddq_f32(v52, v51), v10)).i8[2] & 1) != 0
              && (v36.i8[4] & 1) != 0
              && (v53.i8[4] & 1) != 0)
            {
              BOOL result = (id *)v7[19];
              if (result)
              {
                BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
                float32x4_t v51 = *((float32x4_t *)v7 + 1);
                float32x4_t v12 = *((float32x4_t *)v7 + 5);
                float32x4_t v10 = *a2;
                float32x4_t v34 = *a3;
                v35.i32[0] = vaddq_f32(*a3, *a2).u32[0];
              }
            }
          }
          if (v51.f32[0] < v35.f32[0])
          {
            float32x4_t v54 = *((float32x4_t *)v7 + 3);
            float32x4_t v55 = vaddq_f32(v54, v51);
            if (v55.f32[0] > v10.f32[0])
            {
              float32x4_t v56 = vaddq_f32(v34, v10);
              if ((vmovn_s32(vcgtq_f32(v56, v51)).i8[2] & 1) != 0
                && (vmovn_s32(vcgtq_f32(v55, v10)).i8[2] & 1) != 0
                && (vmovn_s32(vcgtq_f32(v56, v12)).i32[1] & 1) != 0
                && (vmovn_s32(vcgtq_f32(vaddq_f32(v54, v12), v10)).i32[1] & 1) != 0)
              {
                BOOL result = (id *)v7[18];
                if (result)
                {
                  BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
                  float32x4_t v12 = *((float32x4_t *)v7 + 5);
                  float32x4_t v10 = *a2;
                  float32x4_t v34 = *a3;
                  v35.i32[0] = vaddq_f32(*a3, *a2).u32[0];
                }
              }
            }
          }
          if (v12.f32[0] >= v35.f32[0]) {
            goto LABEL_92;
          }
          float32x4_t v57 = vaddq_f32(*((float32x4_t *)v7 + 3), v12);
          if (v57.f32[0] <= v10.f32[0]) {
            goto LABEL_92;
          }
          int16x4_t v58 = vmovn_s32(vcgtq_f32(vaddq_f32(v34, v10), v12));
          if ((v58.i8[2] & 1) == 0) {
            goto LABEL_92;
          }
          int16x4_t v59 = vmovn_s32(vcgtq_f32(v57, v10));
          if ((v59.i8[2] & 1) == 0 || (v58.i8[4] & 1) == 0 || (v59.i8[4] & 1) == 0) {
            goto LABEL_92;
          }
LABEL_47:
          BOOL result = (id *)v7[21];
          if (result)
          {
            BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
            float32x4_t v12 = *((float32x4_t *)v7 + 5);
            float32x4_t v10 = *a2;
            float32x4_t v34 = *a3;
            v35.i32[0] = vaddq_f32(*a3, *a2).u32[0];
          }
          goto LABEL_92;
        }
        if (v36.i8[0])
        {
          float v37 = *((float *)v7 + 13) + v15;
          BOOL v38 = (float)(*((float *)v7 + 12) + v12.f32[0]) <= v10.f32[0] || v37 <= v14;
          if (!v38 && (v36.i8[4] & 1) != 0 && (float)(*((float *)v7 + 14) + v13) > v11) {
            goto LABEL_47;
          }
        }
LABEL_92:
        if (v12.f32[0] >= v35.f32[0]) {
          return result;
        }
        float32x4_t v60 = *((float32x4_t *)v7 + 3);
        if ((float)(v60.f32[0] + v12.f32[0]) <= v10.f32[0]) {
          return result;
        }
        float32x4_t v61 = vaddq_f32(v34, v10);
        if ((vmovn_s32(vcgtq_f32(v61, v12)).i8[2] & 1) == 0) {
          return result;
        }
        if ((vmovn_s32(vcgtq_f32(vaddq_f32(v60, v12), v10)).i8[2] & 1) == 0) {
          return result;
        }
        float32x4_t v62 = *((float32x4_t *)v7 + 1);
        if ((vmovn_s32(vcgtq_f32(v61, v62)).i32[1] & 1) == 0) {
          return result;
        }
        if ((vmovn_s32(vcgtq_f32(vaddq_f32(v60, v62), v10)).i32[1] & 1) == 0) {
          return result;
        }
        BOOL v7 = (id *)v7[20];
        if (!v7) {
          return result;
        }
      }
      else
      {
        float32x4_t v16 = *((float32x4_t *)v7 + 1);
        float32x4_t v17 = *a3;
        float32x4_t v18 = vaddq_f32(*a3, v10);
        int16x4_t v19 = vmovn_s32(vcgtq_f32(v18, v12));
        if (v19.i8[0])
        {
          float32x4_t v20 = *((float32x4_t *)v7 + 3);
          int16x4_t v21 = vmovn_s32(vcgtq_f32(vaddq_f32(v20, v12), v10));
          if ((v21.i8[0] & 1) != 0
            && (vmovn_s32(vcgtq_f32(v18, v16)).i8[2] & 1) != 0
            && (vmovn_s32(vcgtq_f32(vaddq_f32(v20, v16), v10)).i8[2] & 1) != 0
            && (v19.i8[4] & 1) != 0
            && (v21.i8[4] & 1) != 0)
          {
            BOOL result = (id *)v7[19];
            if (result)
            {
              BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
              float32x4_t v16 = *((float32x4_t *)v7 + 1);
              float32x4_t v12 = *((float32x4_t *)v7 + 5);
              float32x4_t v10 = *a2;
              float32x4_t v17 = *a3;
              v18.i32[0] = vaddq_f32(*a3, *a2).u32[0];
            }
          }
        }
        if (v16.f32[0] >= v18.f32[0]) {
          return result;
        }
        float32x4_t v22 = *((float32x4_t *)v7 + 3);
        float32x4_t v23 = vaddq_f32(v22, v16);
        if (v23.f32[0] <= v10.f32[0]) {
          return result;
        }
        float32x4_t v24 = vaddq_f32(v17, v10);
        if ((vmovn_s32(vcgtq_f32(v24, v16)).i8[2] & 1) == 0
          || (vmovn_s32(vcgtq_f32(v23, v10)).i8[2] & 1) == 0
          || (vmovn_s32(vcgtq_f32(v24, v12)).i32[1] & 1) == 0
          || (vmovn_s32(vcgtq_f32(vaddq_f32(v22, v12), v10)).i32[1] & 1) == 0)
        {
          return result;
        }
LABEL_191:
        BOOL v7 = (id *)v7[18];
        if (!v7) {
          return result;
        }
      }
    }
    float32x4_t v25 = *a3;
    float32x4_t v26 = vaddq_f32(*a3, v10);
    if (v26.f32[2] >= v13) {
      break;
    }
    if (v14 >= v15)
    {
      int16x4_t v46 = vmovn_s32(vcgtq_f32(v26, v12));
      float32x4_t v47 = *((float32x4_t *)v7 + 1);
      if ((v46.i8[2] & 1) == 0)
      {
        if (v46.i8[0])
        {
          float32x4_t v73 = *((float32x4_t *)v7 + 3);
          if (vmovn_s32(vcgtq_f32(vaddq_f32(v73, v12), v10)).u8[0])
          {
            int16x4_t v74 = vmovn_s32(vcgtq_f32(v26, v47));
            if (v74.i8[2])
            {
              int16x4_t v75 = vmovn_s32(vcgtq_f32(vaddq_f32(v73, v47), v10));
              if (v75.i8[2] & 1) != 0 && (v74.i8[4] & 1) != 0 && (v75.i8[4])
              {
                BOOL result = (id *)v7[15];
                if (result)
                {
                  BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
                  float32x4_t v47 = *((float32x4_t *)v7 + 1);
                  float32x4_t v10 = *a2;
                  float32x4_t v25 = *a3;
                  v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
                }
              }
            }
          }
        }
        if (v47.f32[0] < v26.f32[0])
        {
          float32x4_t v76 = vaddq_f32(*((float32x4_t *)v7 + 3), v47);
          if (v76.f32[0] > v10.f32[0])
          {
            int16x4_t v77 = vmovn_s32(vcgtq_f32(vaddq_f32(v25, v10), v47));
            if (v77.i8[2])
            {
              int16x4_t v78 = vmovn_s32(vcgtq_f32(v76, v10));
              if (v78.i8[2] & 1) != 0 && (v77.i8[4] & 1) != 0 && (v78.i8[4])
              {
                BOOL result = (id *)v7[14];
                if (result)
                {
                  BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
                  float32x4_t v47 = *((float32x4_t *)v7 + 1);
                  float32x4_t v10 = *a2;
                  float32x4_t v25 = *a3;
                  v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
                }
              }
            }
          }
        }
        float32x4_t v12 = *((float32x4_t *)v7 + 5);
        if (v47.f32[0] >= v26.f32[0]) {
          goto LABEL_153;
        }
        float32x4_t v79 = *((float32x4_t *)v7 + 3);
        if ((float)(v79.f32[0] + v47.f32[0]) <= v10.f32[0]) {
          goto LABEL_153;
        }
        float32x4_t v80 = vaddq_f32(v25, v10);
        if ((vmovn_s32(vcgtq_f32(v80, v12)).i8[2] & 1) == 0
          || (vmovn_s32(vcgtq_f32(vaddq_f32(v79, v12), v10)).i8[2] & 1) == 0
          || (vmovn_s32(vcgtq_f32(v80, v47)).i32[1] & 1) == 0)
        {
          goto LABEL_153;
        }
        float32x4_t v71 = vaddq_f32(v79, v47);
LABEL_150:
        if (vmovn_s32(vcgtq_f32(v71, v10)).i32[1]) {
          goto LABEL_151;
        }
        goto LABEL_153;
      }
      int16x4_t v48 = vmovn_s32(vcgtq_f32(v26, v47));
      if (v48.i8[0])
      {
        float32x4_t v49 = *((float32x4_t *)v7 + 3);
        int16x4_t v50 = vmovn_s32(vcgtq_f32(vaddq_f32(v49, v47), v10));
        if ((v50.i8[0] & 1) != 0
          && (vmovn_s32(vcgtq_f32(vaddq_f32(v49, v12), v10)).i8[2] & 1) != 0
          && (v48.i8[4] & 1) != 0
          && (v50.i8[4] & 1) != 0)
        {
LABEL_151:
          BOOL result = (id *)v7[17];
          if (result)
          {
            BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
            float32x4_t v47 = *((float32x4_t *)v7 + 1);
            float32x4_t v12 = *((float32x4_t *)v7 + 5);
            float32x4_t v10 = *a2;
            float32x4_t v25 = *a3;
            v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
          }
        }
      }
LABEL_153:
      if (v47.f32[0] >= v26.f32[0]) {
        return result;
      }
      float32x4_t v81 = *((float32x4_t *)v7 + 3);
      if ((float)(v81.f32[0] + v47.f32[0]) <= v10.f32[0]) {
        return result;
      }
      float32x4_t v82 = vaddq_f32(v25, v10);
      if ((vmovn_s32(vcgtq_f32(v82, v12)).i8[2] & 1) == 0) {
        return result;
      }
      if ((vmovn_s32(vcgtq_f32(vaddq_f32(v81, v12), v10)).i8[2] & 1) == 0) {
        return result;
      }
      if ((vmovn_s32(vcgtq_f32(v82, v47)).i32[1] & 1) == 0) {
        return result;
      }
      if ((vmovn_s32(vcgtq_f32(vaddq_f32(v81, v47), v10)).i32[1] & 1) == 0) {
        return result;
      }
      BOOL v7 = (id *)v7[16];
      if (!v7) {
        return result;
      }
    }
    else
    {
      float32x4_t v27 = *((float32x4_t *)v7 + 1);
      if (vmovn_s32(vcgtq_f32(v26, v12)).u8[0])
      {
        float32x4_t v28 = *((float32x4_t *)v7 + 3);
        if (vmovn_s32(vcgtq_f32(vaddq_f32(v28, v12), v10)).u8[0])
        {
          int16x4_t v29 = vmovn_s32(vcgtq_f32(v26, v27));
          if (v29.i8[2])
          {
            int16x4_t v30 = vmovn_s32(vcgtq_f32(vaddq_f32(v28, v27), v10));
            if (v30.i8[2] & 1) != 0 && (v29.i8[4] & 1) != 0 && (v30.i8[4])
            {
              BOOL result = (id *)v7[15];
              if (result)
              {
                BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
                float32x4_t v27 = *((float32x4_t *)v7 + 1);
                float32x4_t v10 = *a2;
                float32x4_t v25 = *a3;
                v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
              }
            }
          }
        }
      }
      if (v27.f32[0] >= v26.f32[0]) {
        return result;
      }
      float32x4_t v31 = vaddq_f32(*((float32x4_t *)v7 + 3), v27);
      if (v31.f32[0] <= v10.f32[0]) {
        return result;
      }
      int16x4_t v32 = vmovn_s32(vcgtq_f32(vaddq_f32(v25, v10), v27));
      if ((v32.i8[2] & 1) == 0) {
        return result;
      }
      int16x4_t v33 = vmovn_s32(vcgtq_f32(v31, v10));
      if ((v33.i8[2] & 1) == 0) {
        return result;
      }
      if ((v32.i8[4] & 1) == 0) {
        return result;
      }
      if ((v33.i8[4] & 1) == 0) {
        return result;
      }
      BOOL v7 = (id *)v7[14];
      if (!v7) {
        return result;
      }
    }
  }
  if (v14 >= v15)
  {
    int16x4_t v63 = vmovn_s32(vcgtq_f32(v26, v12));
    if ((v63.i8[2] & 1) == 0)
    {
      float32x4_t v39 = *((float32x4_t *)v7 + 1);
      if (v63.i8[0])
      {
        float32x4_t v83 = *((float32x4_t *)v7 + 3);
        if (vmovn_s32(vcgtq_f32(vaddq_f32(v83, v12), v10)).u8[0])
        {
          int16x4_t v84 = vmovn_s32(vcgtq_f32(v26, v39));
          if (v84.i8[2])
          {
            int16x4_t v85 = vmovn_s32(vcgtq_f32(vaddq_f32(v83, v39), v10));
            if (v85.i8[2] & 1) != 0 && (v84.i8[4] & 1) != 0 && (v85.i8[4])
            {
              BOOL result = (id *)v7[15];
              if (result)
              {
                BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
                float32x4_t v39 = *((float32x4_t *)v7 + 1);
                float32x4_t v10 = *a2;
                float32x4_t v25 = *a3;
                v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
              }
            }
          }
        }
      }
      if (v39.f32[0] < v26.f32[0])
      {
        float32x4_t v86 = *((float32x4_t *)v7 + 3);
        if ((float)(v86.f32[0] + v39.f32[0]) > v10.f32[0])
        {
          int16x4_t v44 = vmovn_s32(vcgtq_f32(vaddq_f32(v25, v10), v39));
          if (v44.i8[2])
          {
            int16x4_t v45 = vmovn_s32(vcgtq_f32(vaddq_f32(v86, v39), v10));
            if (v45.i8[2]) {
              goto LABEL_173;
            }
          }
        }
      }
      goto LABEL_177;
    }
    if (v63.i8[0])
    {
      float v64 = *((float *)v7 + 13) + v15;
      BOOL v65 = (float)(*((float *)v7 + 12) + v12.f32[0]) <= v10.f32[0] || v64 <= v14;
      BOOL v66 = !v65 && v13 < v26.f32[2];
      if (v66 && (float)(*((float *)v7 + 14) + v13) > v11)
      {
        BOOL result = (id *)v7[21];
        if (result)
        {
          BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
          float32x4_t v12 = *((float32x4_t *)v7 + 5);
          float32x4_t v10 = *a2;
          float32x4_t v25 = *a3;
          v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
        }
      }
    }
    float32x4_t v47 = *((float32x4_t *)v7 + 1);
    if (v12.f32[0] < v26.f32[0])
    {
      float32x4_t v68 = *((float32x4_t *)v7 + 3);
      if ((float)(v68.f32[0] + v12.f32[0]) > v10.f32[0])
      {
        float32x4_t v69 = vaddq_f32(v25, v10);
        if ((vmovn_s32(vcgtq_f32(v69, v12)).i8[2] & 1) != 0
          && (vmovn_s32(vcgtq_f32(vaddq_f32(v68, v12), v10)).i8[2] & 1) != 0
          && (vmovn_s32(vcgtq_f32(v69, v47)).i32[1] & 1) != 0
          && (vmovn_s32(vcgtq_f32(vaddq_f32(v68, v47), v10)).i32[1] & 1) != 0)
        {
          BOOL result = (id *)v7[20];
          if (result)
          {
            BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
            float32x4_t v47 = *((float32x4_t *)v7 + 1);
            float32x4_t v12 = *((float32x4_t *)v7 + 5);
            float32x4_t v10 = *a2;
            float32x4_t v25 = *a3;
            v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
          }
        }
      }
    }
    if (v47.f32[0] >= v26.f32[0]) {
      goto LABEL_153;
    }
    float32x4_t v70 = *((float32x4_t *)v7 + 3);
    float32x4_t v71 = vaddq_f32(v70, v47);
    if (v71.f32[0] <= v10.f32[0]) {
      goto LABEL_153;
    }
    float32x4_t v72 = vaddq_f32(v25, v10);
    if ((vmovn_s32(vcgtq_f32(v72, v12)).i8[2] & 1) == 0
      || (vmovn_s32(vcgtq_f32(vaddq_f32(v70, v12), v10)).i8[2] & 1) == 0
      || (vmovn_s32(vcgtq_f32(v72, v47)).i32[1] & 1) == 0)
    {
      goto LABEL_153;
    }
    goto LABEL_150;
  }
  float32x4_t v39 = *((float32x4_t *)v7 + 1);
  if (vmovn_s32(vcgtq_f32(v26, v12)).u8[0])
  {
    float32x4_t v40 = *((float32x4_t *)v7 + 3);
    if (vmovn_s32(vcgtq_f32(vaddq_f32(v40, v12), v10)).u8[0])
    {
      int16x4_t v41 = vmovn_s32(vcgtq_f32(v26, v39));
      if (v41.i8[2])
      {
        int16x4_t v42 = vmovn_s32(vcgtq_f32(vaddq_f32(v40, v39), v10));
        if (v42.i8[2] & 1) != 0 && (v41.i8[4] & 1) != 0 && (v42.i8[4])
        {
          BOOL result = (id *)v7[15];
          if (result)
          {
            BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
            float32x4_t v39 = *((float32x4_t *)v7 + 1);
            float32x4_t v10 = *a2;
            float32x4_t v25 = *a3;
            v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
          }
        }
      }
    }
  }
  if (v39.f32[0] < v26.f32[0])
  {
    float32x4_t v43 = vaddq_f32(*((float32x4_t *)v7 + 3), v39);
    if (v43.f32[0] > v10.f32[0])
    {
      int16x4_t v44 = vmovn_s32(vcgtq_f32(vaddq_f32(v25, v10), v39));
      if (v44.i8[2])
      {
        int16x4_t v45 = vmovn_s32(vcgtq_f32(v43, v10));
        if (v45.i8[2])
        {
LABEL_173:
          if (v44.i8[4] & 1) != 0 && (v45.i8[4])
          {
            BOOL result = (id *)v7[14];
            if (result)
            {
              BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
              float32x4_t v39 = *((float32x4_t *)v7 + 1);
              float32x4_t v10 = *a2;
              float32x4_t v25 = *a3;
              v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
            }
          }
        }
      }
    }
  }
LABEL_177:
  float32x4_t v87 = *((float32x4_t *)v7 + 5);
  if (v87.f32[0] < v26.f32[0])
  {
    float32x4_t v88 = *((float32x4_t *)v7 + 3);
    float32x4_t v89 = vaddq_f32(v88, v87);
    if (v89.f32[0] > v10.f32[0])
    {
      float32x4_t v90 = vaddq_f32(v25, v10);
      if ((vmovn_s32(vcgtq_f32(v90, v39)).i8[2] & 1) != 0
        && (vmovn_s32(vcgtq_f32(vaddq_f32(v88, v39), v10)).i8[2] & 1) != 0
        && (vmovn_s32(vcgtq_f32(v90, v87)).i32[1] & 1) != 0
        && (vmovn_s32(vcgtq_f32(v89, v10)).i32[1] & 1) != 0)
      {
        BOOL result = (id *)v7[19];
        if (result)
        {
          BOOL result = (id *)GKCOctreeNode<NSObject>::queryBox(result, a2, a3, a4);
          float32x4_t v39 = *((float32x4_t *)v7 + 1);
          float32x4_t v87 = *((float32x4_t *)v7 + 5);
          float32x4_t v10 = *a2;
          float32x4_t v25 = *a3;
          v26.i32[0] = vaddq_f32(*a3, *a2).u32[0];
        }
      }
    }
  }
  if (v39.f32[0] < v26.f32[0])
  {
    float32x4_t v91 = *((float32x4_t *)v7 + 3);
    float32x4_t v92 = vaddq_f32(v91, v39);
    if (v92.f32[0] > v10.f32[0])
    {
      float32x4_t v93 = vaddq_f32(v25, v10);
      if ((vmovn_s32(vcgtq_f32(v93, v39)).i8[2] & 1) != 0
        && (vmovn_s32(vcgtq_f32(v92, v10)).i8[2] & 1) != 0
        && (vmovn_s32(vcgtq_f32(v93, v87)).i32[1] & 1) != 0
        && (vmovn_s32(vcgtq_f32(vaddq_f32(v91, v87), v10)).i32[1] & 1) != 0)
      {
        goto LABEL_191;
      }
    }
  }
  return result;
}

uint64_t GKCOctreeNode<NSObject>::removeDataRecursive(void *a1, void *a2)
{
  id v3 = a2;
  float32x4_t v4 = v3;
  float32x4_t v5 = (void *)a1[22];
  int8x8_t v6 = (void *)a1[23];
  if (v5 == v6)
  {
LABEL_4:

    uint64_t v7 = a1[14];
    if (!v7 || (GKCOctreeNode<NSObject>::removeDataRecursive(v7, v4) & 1) == 0)
    {
      uint64_t v8 = a1[15];
      if (!v8 || (GKCOctreeNode<NSObject>::removeDataRecursive(v8, v4) & 1) == 0)
      {
        uint64_t v9 = a1[16];
        if (!v9 || (GKCOctreeNode<NSObject>::removeDataRecursive(v9, v4) & 1) == 0)
        {
          uint64_t v10 = a1[17];
          if (!v10 || (GKCOctreeNode<NSObject>::removeDataRecursive(v10, v4) & 1) == 0)
          {

            return 0;
          }
        }
      }
    }
  }
  else
  {
    while ((id)*v5 != v3)
    {
      if (++v5 == v6) {
        goto LABEL_4;
      }
    }
    float32x4_t v12 = v5 + 1;
    if (v5 + 1 != v6)
    {
      do
      {
        float32x4_t v5 = v12;
        float v13 = (void *)*(v12 - 1);
        *(v12 - 1) = *v12;
        *float32x4_t v12 = 0;

        float32x4_t v12 = v5 + 1;
      }
      while (v5 + 1 != v6);
      int8x8_t v6 = (void *)a1[23];
    }
    while (v6 != v5)
    {
      float v14 = (void *)*--v6;
    }
    a1[23] = v5;
  }
  return 1;
}

void sub_235F0BA14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t OUTLINED_FUNCTION_0(uint64_t a1, uint64_t a2)
{
  return a2;
}

void *GKCPolygonObstacle::GKCPolygonObstacle(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_26E943510;
  a1[1] = 0;
  int8x8_t v6 = (char **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  OpenSteer::PolygonObstacle::PolygonObstacle(a1 + 4);
  a1[8] = 0;
  uint64_t v7 = a1[1];
  unint64_t v8 = (a1[2] - v7) >> 3;
  if (a3 <= v8)
  {
    if (a3 < v8) {
      a1[2] = v7 + 8 * a3;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE8__appendEm(v6, a3 - v8);
  }
  uint64_t v9 = a1[5];
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((a1[6] - v9) >> 2);
  if (a3 > v10)
  {
    std::vector<OpenSteer::Vec3>::__append((uint64_t)(a1 + 5), a3 - v10);
LABEL_10:
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    do
    {
      *(void *)&(*v6)[8 * v12] = *(void *)(a2 + 8 * v12);
      uint64_t v13 = *(void *)(a2 + 8 * v12);
      uint64_t v14 = a1[5] + v11;
      *(void *)uint64_t v14 = v13;
      *(_DWORD *)(v14 + 8) = HIDWORD(v13);
      ++v12;
      v11 += 12;
    }
    while (a3 != v12);
    return a1;
  }
  if (a3 < v10) {
    a1[6] = v9 + 12 * a3;
  }
  if (a3) {
    goto LABEL_10;
  }
  return a1;
}

void sub_235F0BB64(_Unwind_Exception *exception_object)
{
  v1[4] = &unk_26E943468;
  float32x4_t v4 = (void *)v1[5];
  if (v4)
  {
    v1[6] = v4;
    operator delete(v4);
    float32x4_t v5 = *v2;
    if (!*v2) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    float32x4_t v5 = *v2;
    if (!*v2) {
      goto LABEL_3;
    }
  }
  v1[2] = v5;
  operator delete(v5);
  _Unwind_Resume(exception_object);
}

void GKCPolygonObstacle::~GKCPolygonObstacle(GKCPolygonObstacle *this)
{
  *(void *)this = &unk_26E943510;
  *((void *)this + 4) = &unk_26E943468;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  id v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;

  *(void *)this = &unk_26E943510;
  *((void *)this + 4) = &unk_26E943468;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  id v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26E943510;
  *((void *)this + 4) = &unk_26E943468;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  id v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }

  JUMPOUT(0x237DF7CA0);
}

BOOL GKCPolygonObstacle::intersectsLineFrom(uint64_t a1, float32x2_t *a2, float32x2_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16) - v3;
  if ((v4 & 0x7FFFFFFF8) != 0)
  {
    unint64_t v5 = 0;
    unint64_t v6 = v4 >> 3;
    int32x2_t v7 = (int32x2_t)vsub_f32(*a3, *a2);
    float32x2_t v8 = (float32x2_t)vrev64_s32(v7);
    unint64_t v9 = ((unint64_t)v4 >> 3);
    BOOL v10 = 1;
    while (1)
    {
      float32x2_t v13 = *(float32x2_t *)(v3 + 8 * v5);
      unint64_t v14 = v5 + 1;
      if (v6 > v5 + 1) {
        unint64_t v15 = v5 + 1;
      }
      else {
        unint64_t v15 = 0;
      }
      float32x2_t v16 = vsub_f32(*(float32x2_t *)(v3 + 8 * v15), v13);
      float32x2_t v17 = vmul_f32(v8, v16);
      float32x2_t v18 = vsub_f32(v13, *a2);
      int32x2_t v19 = (int32x2_t)vsub_f32(v17, (float32x2_t)vdup_lane_s32((int32x2_t)v17, 1));
      float32x2_t v20 = vmul_f32((float32x2_t)__PAIR64__(v18.u32[1], v7.u32[0]), (float32x2_t)vext_s8((int8x8_t)v18, (int8x8_t)v16, 4uLL));
      float32x2_t v21 = (float32x2_t)vext_s8((int8x8_t)v7, (int8x8_t)v18, 4uLL);
      v18.i32[1] = v16.i32[1];
      float32x2_t v22 = vmls_f32(v20, v21, v18);
      if (*(float *)v19.i32 == 0.0)
      {
        if (v22.f32[1] == 0.0 && v22.f32[0] == 0.0) {
          return v10;
        }
      }
      else
      {
        *(float32x2_t *)v11.f32 = vdiv_f32(v22, (float32x2_t)vdup_lane_s32(v19, 0));
        v11.i64[1] = v11.i64[0];
        v12.i32[0] = vmovn_s32(vcgeq_f32((float32x4_t)xmmword_235F1F2A0, v11)).u32[0];
        v12.i32[1] = vmovn_s32(vcgeq_f32(v11, (float32x4_t)xmmword_235F1F2A0)).i32[1];
        if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(v12, 0xFuLL)))) {
          return v10;
        }
      }
      BOOL v10 = v14 < v9;
      unint64_t v5 = v14;
      if (v9 == v14) {
        return v10;
      }
    }
  }
  return 0;
}

BOOL GKCPolygonObstacle::intersectsPoint(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - v2;
  if ((int)(v3 >> 3) < 1)
  {
    return 0;
  }
  else
  {
    uint64_t v4 = 0;
    BOOL v5 = 0;
    uint64_t v6 = (v3 >> 3) - 1;
    LODWORD(v7) = HIDWORD(*a2);
    uint64_t v8 = (v3 >> 3);
    do
    {
      uint64_t v9 = 8 * (int)v6;
      uint64_t v6 = v4;
      float32x2_t v10 = *(float32x2_t *)(v2 + v9);
      LODWORD(v11) = HIDWORD(*(void *)(v2 + 8 * v4));
      if (v11 <= v7 == v10.f32[1] > v7
        && COERCE_FLOAT(*a2) < (float)((float)((float)((float)(v7 - v11)
                                                     * vsub_f32(v10, *(float32x2_t *)(v2 + 8 * v4)).f32[0])
                                             / (float)(v10.f32[1] - v11))
                                     + COERCE_FLOAT(*(void *)(v2 + 8 * v4))))
      {
        BOOL v5 = !v5;
      }
      ++v4;
    }
    while (v8 != v6 + 1);
  }
  return v5;
}

id GKCPolygonObstacle::extrudeObstacle(GKCPolygonObstacle *this, GKCPolygonObstacle *a2, float32_t a3)
{
  __p = 0;
  float32x4_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v3 = *((void *)this + 2) - *((void *)this + 1);
  if (!v3)
  {
    uint64_t v7 = 0;
    goto LABEL_11;
  }
  _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE8__appendEm((char **)&__p, v3 >> 3);
  uint64_t v6 = (float32x2_t *)*((void *)this + 1);
  uint64_t v7 = *((void *)this + 2) - (void)v6;
  v8.i32[0] = 955908096;
  if (a3 > 0.0) {
    v8.f32[0] = a3;
  }
  if ((int)((unint64_t)v7 >> 3) >= 1)
  {
    uint64_t v9 = ((unint64_t)v7 >> 3);
    float32x2_t v10 = v6[((v7 << 29) - 0x100000000) >> 32];
    float32x2_t v11 = v6[v7 << 29 > 0x1FFFFFFFFLL];
    float32x2_t v12 = vsub_f32(*v6, v10);
    float32x2_t v13 = vmul_f32(v12, v12);
    v13.i32[0] = vadd_f32(v13, (float32x2_t)vdup_lane_s32((int32x2_t)v13, 1)).u32[0];
    float32x2_t v14 = vrsqrte_f32((float32x2_t)v13.u32[0]);
    float32x2_t v15 = vmul_n_f32(v12, vmul_f32(vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v14, v14)), v14).f32[0]);
    float32x2_t v16 = vsub_f32(v11, *v6);
    float32x2_t v17 = vmul_f32(v16, v16);
    v17.i32[0] = vadd_f32(v17, (float32x2_t)vdup_lane_s32((int32x2_t)v17, 1)).u32[0];
    float32x2_t v18 = vrsqrte_f32((float32x2_t)v17.u32[0]);
    float32x2_t v19 = vmul_n_f32(v16, vmul_f32(vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v18, v18)), v18).f32[0]);
    float32x2_t v20 = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v19), v15);
    LODWORD(v21) = vsub_f32(v20, (float32x2_t)vdup_lane_s32((int32x2_t)v20, 1)).u32[0];
    if (fabsf(v21) == 0.00000011921)
    {
      float32x2_t v22 = vsub_f32(v11, v10);
      float32x2_t v23 = vmul_f32(v22, v22);
      v23.i32[0] = vadd_f32(v23, (float32x2_t)vdup_lane_s32((int32x2_t)v23, 1)).u32[0];
      float32x2_t v24 = vrsqrte_f32((float32x2_t)v23.u32[0]);
      int32x2_t v25 = (int32x2_t)vmul_f32(vrsqrts_f32((float32x2_t)v23.u32[0], vmul_f32(v24, v24)), v24);
      int32x2_t v26 = (int32x2_t)vmul_n_f32(v22, *(float *)v25.i32);
      *(float *)v25.i32 = -*(float *)&v26.i32[1];
      float32x2_t v27 = (float32x2_t)vzip1_s32(v25, v26);
      float32x2_t v28 = vmul_f32(v27, v27);
      v28.i32[0] = vadd_f32(v28, (float32x2_t)vdup_lane_s32((int32x2_t)v28, 1)).u32[0];
      float32x2_t v29 = vrsqrte_f32((float32x2_t)v28.u32[0]);
      *(float32x2_t *)__p = vmul_n_f32(v27, vmul_f32(vmul_f32(v29, v8), vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(v29, v29))).f32[0]);
      if (v9 != 1)
      {
LABEL_16:
        uint64_t v32 = 0;
        uint64_t v33 = (int)(v7 >> 3);
        uint64_t v34 = 1;
        do
        {
          uint64_t v36 = *((void *)this + 1);
          float32x2_t v37 = *(float32x2_t *)(v36 + 8 * v34);
          float32x2_t v38 = *(float32x2_t *)(v36 + (v32 >> 29));
          uint64_t v39 = v34 + 1;
          uint64_t v40 = (v34 + 1);
          if (v34 + 1 >= v33) {
            uint64_t v40 = 0;
          }
          float32x2_t v41 = *(float32x2_t *)(v36 + 8 * v40);
          float32x2_t v42 = vsub_f32(v37, v38);
          float32x2_t v43 = vmul_f32(v42, v42);
          v43.i32[0] = vadd_f32(v43, (float32x2_t)vdup_lane_s32((int32x2_t)v43, 1)).u32[0];
          float32x2_t v44 = vrsqrte_f32((float32x2_t)v43.u32[0]);
          float32x2_t v45 = vmul_n_f32(v42, vmul_f32(vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v44, v44)), v44).f32[0]);
          float32x2_t v46 = vsub_f32(v41, v37);
          float32x2_t v47 = vmul_f32(v46, v46);
          v47.i32[0] = vadd_f32(v47, (float32x2_t)vdup_lane_s32((int32x2_t)v47, 1)).u32[0];
          float32x2_t v48 = vrsqrte_f32((float32x2_t)v47.u32[0]);
          float32x2_t v49 = vmul_n_f32(v46, vmul_f32(vrsqrts_f32((float32x2_t)v47.u32[0], vmul_f32(v48, v48)), v48).f32[0]);
          float32x2_t v50 = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v49), v45);
          LODWORD(v51) = vsub_f32(v50, (float32x2_t)vdup_lane_s32((int32x2_t)v50, 1)).u32[0];
          if (fabsf(v51) == 0.00000011921)
          {
            float32x2_t v52 = vsub_f32(v41, v38);
            float32x2_t v53 = vmul_f32(v52, v52);
            v53.i32[0] = vadd_f32(v53, (float32x2_t)vdup_lane_s32((int32x2_t)v53, 1)).u32[0];
            float32x2_t v54 = vrsqrte_f32((float32x2_t)v53.u32[0]);
            int32x2_t v55 = (int32x2_t)vmul_f32(vrsqrts_f32((float32x2_t)v53.u32[0], vmul_f32(v54, v54)), v54);
            int32x2_t v56 = (int32x2_t)vmul_n_f32(v52, *(float *)v55.i32);
            *(float *)v55.i32 = -*(float *)&v56.i32[1];
            float32x2_t v57 = (float32x2_t)vzip1_s32(v55, v56);
            float32x2_t v58 = vmul_f32(v57, v57);
            v58.i32[0] = vadd_f32(v58, (float32x2_t)vdup_lane_s32((int32x2_t)v58, 1)).u32[0];
            float32x2_t v59 = vrsqrte_f32((float32x2_t)v58.u32[0]);
            float32x2_t v35 = vmul_n_f32(v57, vmul_f32(vmul_f32(v59, v8), vrsqrts_f32((float32x2_t)v58.u32[0], vmul_f32(v59, v59))).f32[0]);
          }
          else
          {
            float32x2_t v35 = vmla_n_f32(v37, vsub_f32(v45, v49), v8.f32[0] / v51);
          }
          *((float32x2_t *)__p + v34) = v35;
          v32 += 0x100000000;
          ++v34;
        }
        while (v9 != v39);
      }
    }
    else
    {
      *(float32x2_t *)__p = vmla_n_f32(*v6, vsub_f32(v15, v19), v8.f32[0] / v21);
      if (v9 != 1) {
        goto LABEL_16;
      }
    }
    uint64_t v7 = *((void *)this + 2) - *((void *)this + 1);
  }
LABEL_11:
  int16x4_t v30 = +[GKPolygonObstacle obstacleWithPoints:__p count:v7 >> 3];
  if (__p)
  {
    float32x4_t v61 = __p;
    operator delete(__p);
  }

  return v30;
}

void sub_235F0C228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_235F0DA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_235F0DAD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F0DD30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (!__p)
  {

    _Unwind_Resume(a1);
  }
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_235F0E08C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEm(char **a1, unint64_t a2)
{
  BOOL v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      uint64_t v12 = 16 * a2;
      bzero(a1[1], 16 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 4;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 60) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float32x2_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      float32x2_t v11 = 0;
    }
    float32x2_t v13 = &v11[16 * v7];
    size_t v14 = 16 * a2;
    float32x2_t v15 = &v11[16 * v10];
    bzero(v13, v14);
    float32x2_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        long long v17 = *((_OWORD *)v5 - 1);
        v5 -= 16;
        *((_OWORD *)v13 - 1) = v17;
        v13 -= 16;
      }
      while (v5 != v6);
      BOOL v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void *p2t::AdvancingFront::AdvancingFront(void *result, uint64_t a2, uint64_t a3)
{
  void *result = a2;
  result[1] = a3;
  result[2] = a2;
  return result;
}

uint64_t p2t::AdvancingFront::LocateNode(p2t::AdvancingFront *this, double *a2)
{
  uint64_t result = *((void *)this + 2);
  double v4 = *a2;
  if (*a2 >= *(double *)(result + 32))
  {
    while (1)
    {
      uint64_t result = *(void *)(result + 16);
      if (!result) {
        break;
      }
      if (v4 < *(double *)(result + 32))
      {
        uint64_t result = *(void *)(result + 24);
LABEL_8:
        *((void *)this + 2) = result;
        return result;
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t result = *(void *)(result + 24);
      if (!result) {
        break;
      }
      if (v4 >= *(double *)(result + 32)) {
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t p2t::AdvancingFront::FindSearchNode(p2t::AdvancingFront *this, const double *a2)
{
  return *((void *)this + 2);
}

uint64_t p2t::AdvancingFront::LocatePoint(p2t::AdvancingFront *this, const Point *a2)
{
  uint64_t result = *((void *)this + 2);
  double v4 = **(double **)result;
  if (*(double *)&a2->v == v4)
  {
    if (*(const Point **)result != a2)
    {
      if (**(const Point ***)(result + 24) == a2)
      {
        uint64_t result = *(void *)(result + 24);
      }
      else
      {
        uint64_t result = *(void *)(result + 16);
        if (*(const Point **)result != a2) {
          p2t::AdvancingFront::LocatePoint();
        }
      }
    }
LABEL_14:
    *((void *)this + 2) = result;
  }
  else if (*(double *)&a2->v >= v4)
  {
    while (1)
    {
      uint64_t result = *(void *)(result + 16);
      if (!result) {
        break;
      }
      if (*(const Point **)result == a2) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t result = *(void *)(result + 24);
      if (!result) {
        break;
      }
      if (*(const Point **)result == a2) {
        goto LABEL_14;
      }
    }
  }
  return result;
}

BOOL pointOnLine(double a1, double a2, double a3)
{
  float v3 = fmaxf(*(float *)&a2, *(float *)&a3);
  BOOL v4 = *(float *)&a1 >= fminf(*(float *)&a2, *(float *)&a3) && *(float *)&a1 <= v3;
  float v5 = fminf(*((float *)&a2 + 1), *((float *)&a3 + 1));
  float v6 = fmaxf(*((float *)&a2 + 1), *((float *)&a3 + 1));
  return v4 && *((float *)&a1 + 1) >= v5 && *((float *)&a1 + 1) <= v6;
}

uint64_t orientation(float32x2_t a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v3 = vmul_f32(vsub_f32(a3, a2), (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(a2, a1)));
  int v4 = (int)vsub_f32(v3, (float32x2_t)vdup_lane_s32((int32x2_t)v3, 1)).f32[0];
  if (v4 >= 1) {
    unsigned int v5 = 1;
  }
  else {
    unsigned int v5 = 2;
  }
  if (v4) {
    return v5;
  }
  else {
    return 0;
  }
}

float32x2_t GKGetClosestPointOnLineSegmentToPoint(float32x2_t a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v3 = vsub_f32(a3, a1);
  float32x2_t v4 = vsub_f32(a2, a1);
  float32x2_t v5 = (float32x2_t)vext_s8((int8x8_t)v3, (int8x8_t)v4, 4uLL);
  v3.i32[1] = v4.i32[1];
  float32x2_t v6 = vmla_f32(vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v4), v5), v4, v3);
  float v7 = vdiv_f32(v6, (float32x2_t)vdup_lane_s32((int32x2_t)v6, 1)).f32[0];
  float v8 = 0.0;
  if (v7 >= 0.0)
  {
    float v8 = v7;
    if (v7 > 1.0) {
      float v8 = 1.0;
    }
  }
  return vmla_n_f32(a1, v4, v8);
}

float32x2_t GKGetLineSegmentToLineSegmentIntersectionPoint(int32x2_t a1, int32x2_t a2, int32x2_t a3, int32x2_t a4)
{
  float32x2_t v4 = (float32x2_t)vzip2_s32(a3, a1);
  float32x2_t v5 = vsub_f32((float32x2_t)vzip2_s32(a4, a2), v4);
  float32x2_t v6 = (float32x2_t)vzip1_s32(a3, a1);
  float32x2_t v7 = vsub_f32(v6, (float32x2_t)vzip1_s32(a4, a2));
  float32x2_t v8 = (float32x2_t)vrev64_s32((int32x2_t)v5);
  float32x2_t v9 = vmul_f32(v8, v7);
  int32x2_t v10 = (int32x2_t)vsub_f32(v9, (float32x2_t)vdup_lane_s32((int32x2_t)v9, 1));
  float32x2_t result = 0;
  if (*(float *)v10.i32 != 0.0)
  {
    float32x2_t v12 = vadd_f32(vmul_f32(v5, v6), vmul_f32(v7, v4));
    unsigned __int32 v13 = vmul_lane_f32(v7, v12, 1).u32[0];
    v14.i32[0] = vmul_lane_f32(v12, v7, 1).u32[0];
    int32x2_t v15 = (int32x2_t)vmul_f32(v12, v8);
    float32x2_t v16 = (float32x2_t)vdup_lane_s32(v15, 0);
    v16.i32[0] = v13;
    v14.i32[1] = v15.i32[1];
    return vdiv_f32(vsub_f32(v16, v14), (float32x2_t)vdup_lane_s32(v10, 0));
  }
  return result;
}

uint64_t GKGetLineToLineIntersection(float32x2_t *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float32x2_t a5)
{
  float32x2_t v5 = vsub_f32(a3, a2);
  float32x2_t v6 = vsub_f32(a5, a4);
  float32x2_t v7 = vdiv_f32((float32x2_t)vzip2_s32((int32x2_t)v5, (int32x2_t)v6), (float32x2_t)vzip1_s32((int32x2_t)v5, (int32x2_t)v6));
  if ((vmvn_s8((int8x8_t)vceq_f32(v7, (float32x2_t)vdup_lane_s32((int32x2_t)v7, 1))).u8[0] & 1) == 0) {
    return 0;
  }
  float32x2_t v8 = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v6), v5);
  float32x2_t v9 = vsub_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1));
  if (v9.f32[0] == 0.0) {
    return 0;
  }
  float32x2_t v10 = vmul_f32(v6, (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(a2, a4)));
  *a1 = vmla_n_f32(a2, v5, vdiv_f32(vsub_f32(v10, (float32x2_t)vdup_lane_s32((int32x2_t)v10, 1)), v9).f32[0]);
  return 1;
}

BOOL GKDoesCircleIntersectLine(float32x2_t a1, float a2, float32x2_t a3, float32x2_t a4)
{
  float32x2_t v4 = vsub_f32(a4, a3);
  float32x2_t v5 = vmul_f32(v4, v4);
  float32x2_t v6 = vsub_f32(a1, a3);
  float32x2_t v7 = vmul_f32(v4, v6);
  float32x2_t v8 = vmul_f32(v6, v6);
  v8.f32[0] = (float)-(float)(v8.f32[1] - (float)(a2 * a2)) - v8.f32[0];
  float32x2_t v9 = vdiv_f32(vadd_f32(v7, (float32x2_t)vdup_lane_s32((int32x2_t)v7, 1)), vadd_f32(v5, (float32x2_t)vdup_lane_s32((int32x2_t)v5, 1)));
  return (float)(vmul_f32(v9, v9).f32[0] + (float)(v8.f32[0] / vaddv_f32(v5))) >= 0.0;
}

float GKGetCircleToLineIntersectionPoints(_DWORD *a1, float32x2_t *a2, float32x2_t *a3, float32x2_t a4, float a5, float32x2_t a6, float32x2_t a7)
{
  float32x2_t v7 = vsub_f32(a7, a6);
  float32x2_t v8 = vsub_f32(a4, a6);
  float32x2_t v9 = (float32x2_t)vext_s8((int8x8_t)v8, (int8x8_t)v7, 4uLL);
  float32x2_t v10 = (float32x2_t)__PAIR64__(v7.u32[1], v8.u32[0]);
  float32x2_t v11 = vmul_f32(v8, v8);
  float32x2_t v12 = (float32x2_t)vrev64_s32((int32x2_t)v7);
  float32x2_t v13 = vmla_f32(vmul_f32(v12, v9), v7, v10);
  float v14 = (float)-(float)(v11.f32[1] - (float)(a5 * a5)) - v11.f32[0];
  float result = v13.f32[0] / v13.f32[1];
  float v16 = (float)(v14 / v13.f32[1]) + (float)(result * result);
  if (v16 >= 0.0)
  {
    float v17 = sqrtf(v16);
    v12.f32[0] = v17 - result;
    float32x2_t v18 = vmls_lane_f32(a6, v7, v12, 0);
    if (v16 == 0.0)
    {
      *a1 = 1;
      *a2 = v18;
    }
    else
    {
      float result = v17 + result;
      *a1 = 2;
      *a2 = v18;
      *a3 = vmla_n_f32(a6, v7, result);
    }
  }
  else
  {
    *a1 = 0;
  }
  return result;
}

BOOL GKDoesCircleIntersectLineSegment(float32x2_t a1, float a2, double a3, double a4)
{
  int v7 = 0;
  GKGetCircleToLineSegmentIntersectionPoints(&v7, &v6, &v5, a1, a2, a3, a4);
  return v7 > 0;
}

_DWORD *GKGetCircleToLineSegmentIntersectionPoints(_DWORD *result, void *a2, void *a3, float32x2_t a4, float a5, double a6, double a7)
{
  void *result = 0;
  float32x2_t v7 = vsub_f32(*(float32x2_t *)&a7, *(float32x2_t *)&a6);
  _S7 = *((float *)&a7 + 1) - *((float *)&a6 + 1);
  float v9 = vmul_f32(v7, v7).f32[0] + (float)(_S7 * _S7);
  if (v9 == 0.0) {
    return result;
  }
  _D0 = vsub_f32(a4, *(float32x2_t *)&a6);
  __asm { FMLA            S16, S7, V0.S[1] }
  float v15 = _S16 / v9;
  float v16 = (float)((float)((float)-(float)((float)(_D0.f32[1] * _D0.f32[1]) - (float)(a5 * a5)) - vmul_f32(_D0, _D0).f32[0])
              / v9)
      + (float)(v15 * v15);
  if (v16 < 0.0) {
    return result;
  }
  float v17 = sqrtf(v16);
  float v18 = *(float *)&a6 - (float)((float)(v17 - v15) * v7.f32[0]);
  float v19 = *((float *)&a6 + 1) - (float)((float)(v17 - v15) * _S7);
  *(float *)&uint64_t v20 = v18;
  *((float *)&v20 + 1) = v19;
  if (v16 == 0.0)
  {
    float v21 = fminf(*(float *)&a6, *(float *)&a7);
    float v22 = fmaxf(*(float *)&a6, *(float *)&a7);
    BOOL v23 = v18 >= v21 && v18 <= v22;
    *(float *)&a6 = fminf(*((float *)&a6 + 1), *((float *)&a7 + 1));
    float v24 = fmaxf(*((float *)&a6 + 1), *((float *)&a7 + 1));
    if (!v23 || v19 < *(float *)&a6 || v19 > v24) {
      return result;
    }
LABEL_49:
    void *result = 1;
    *a2 = v20;
    return result;
  }
  float v27 = v17 + v15;
  float v28 = *(float *)&a6 + (float)((float)(v17 + v15) * v7.f32[0]);
  float v29 = *((float *)&a6 + 1) + (float)(v27 * _S7);
  float v30 = fminf(*(float *)&a6, *(float *)&a7);
  float v31 = fmaxf(*(float *)&a6, *(float *)&a7);
  BOOL v32 = v18 >= v30 && v18 <= v31;
  float v33 = fminf(*((float *)&a6 + 1), *((float *)&a7 + 1));
  float v34 = fmaxf(*((float *)&a6 + 1), *((float *)&a7 + 1));
  if (v32 && v19 >= v33 && v19 <= v34)
  {
    if (v28 >= v30 && v28 <= v31 && v29 >= v33 && v29 <= v34)
    {
      void *result = 2;
      *a2 = v20;
      *a3 = __PAIR64__(LODWORD(v29), LODWORD(v28));
      return result;
    }
    goto LABEL_49;
  }
  if (v28 >= v30 && v28 <= v31 && v29 >= v33 && v29 <= v34)
  {
    void *result = 1;
    *a2 = __PAIR64__(LODWORD(v29), LODWORD(v28));
  }
  return result;
}

BOOL GKDoesCircleIntersectPolygon(uint64_t a1, int a2, double a3, float a4)
{
  uint64_t v7 = 0;
  int v8 = a2 - 1;
  uint64_t v9 = a2 & ~(a2 >> 31);
  while (v9 != v7)
  {
    uint64_t v10 = v7 + 1;
    double v11 = *(double *)(a1 + 8 * (((int)v7 + 1) % v8));
    double v12 = *(double *)(a1 + 8 * v7);
    int v21 = 0;
    GKGetCircleToLineSegmentIntersectionPoints(&v21, &v20, &v19, *(float32x2_t *)&a3, a4, v12, v11);
    uint64_t v7 = v10;
    if (v21 > 0) {
      return 1;
    }
  }
  if (a2 < 1)
  {
    return 0;
  }
  else
  {
    uint64_t v14 = 0;
    BOOL v15 = 0;
    do
    {
      float32x2_t v16 = *(float32x2_t *)(a1 + 8 * v8);
      LODWORD(v17) = HIDWORD(*(void *)(a1 + 8 * v14));
      if (v17 <= *((float *)&a3 + 1) == v16.f32[1] > *((float *)&a3 + 1)
        && *(float *)&a3 < (float)((float)((float)((float)(*((float *)&a3 + 1) - v17)
                                                 * vsub_f32(v16, *(float32x2_t *)(a1 + 8 * v14)).f32[0])
                                         / (float)(v16.f32[1] - v17))
                                 + COERCE_FLOAT(*(void *)(a1 + 8 * v14))))
      {
        BOOL v15 = !v15;
      }
      int v8 = v14++;
    }
    while (a2 != v14);
  }
  return v15;
}

float Clamp(float a1, float a2, float a3)
{
  float v3 = fminf(a1, a3);
  if (a1 >= a2) {
    return v3;
  }
  else {
    return a2;
  }
}

float32x2_t GKClosestPointsBetweenLineSegments(float32x2_t *a1, double *a2, float32x2_t result, float32x2_t a4, float32x2_t a5, float32x2_t a6)
{
  float32x2_t v6 = vsub_f32(a4, result);
  float32x2_t v7 = vsub_f32(a6, a5);
  float32x2_t v8 = vmul_f32(v6, v6);
  float v9 = vaddv_f32(v8);
  float32x2_t v10 = vmul_f32(v7, v7);
  float v11 = vaddv_f32(v10);
  if (v9 <= 0.00000011921 && v11 <= 0.00000011921)
  {
    *a1 = result;
    *a2 = *(double *)&a5;
    return result;
  }
  float32x2_t v13 = vsub_f32(result, a5);
  float32x2_t v14 = vadd_f32(v10, (float32x2_t)vdup_lane_s32((int32x2_t)v10, 1));
  float32x2_t v15 = vmul_f32(v7, v13);
  float32x2_t v16 = vadd_f32(v15, (float32x2_t)vdup_lane_s32((int32x2_t)v15, 1));
  if (v9 <= 0.00000011921)
  {
    float v17 = fminf(vdiv_f32(v16, v14).f32[0], 1.0);
    float v18 = 0.0;
    float v19 = fmaxf(v17, 0.0);
LABEL_7:
    float result = vmla_n_f32(result, v6, v18);
    *a1 = result;
    *(float32x2_t *)a2 = vmla_n_f32(a5, v7, v19);
    return result;
  }
  float32x2_t v20 = vmul_f32(v13, v6);
  float v21 = vaddv_f32(v20);
  if (v11 <= 0.00000011921) {
    goto LABEL_12;
  }
  float32x2_t v22 = vadd_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1));
  float v23 = vaddv_f32(v15);
  float32x2_t v24 = vmul_f32(v7, v6);
  float32x2_t v25 = vadd_f32(v20, (float32x2_t)vdup_lane_s32((int32x2_t)v20, 1));
  float32x2_t v26 = vadd_f32(v24, (float32x2_t)vdup_lane_s32((int32x2_t)v24, 1));
  float v27 = vaddv_f32(v24);
  float32x2_t v28 = vmls_f32(vmul_f32(v14, v22), v26, v26);
  if (v28.f32[0] == 0.0)
  {
    float v18 = 0.0;
    float v19 = (float)(v23 + (float)(0.0 * v27)) / v11;
    if (v19 < 0.0) {
      goto LABEL_12;
    }
  }
  else
  {
    float v18 = fmaxf(fminf(vdiv_f32(vmls_f32(vmul_f32(v26, v16), v14, v25), v28).f32[0], 1.0), 0.0);
    float v19 = (float)(v23 + (float)(v18 * v27)) / v11;
    if (v19 < 0.0)
    {
LABEL_12:
      float result = vmla_n_f32(result, v6, fmaxf(fminf((float)-v21 / v9, 1.0), 0.0));
      *a1 = result;
      *(float32x2_t *)a2 = vmla_n_f32(a5, v7, 0.0);
      return result;
    }
  }
  if (v19 <= 1.0) {
    goto LABEL_7;
  }
  float result = vmla_n_f32(result, v6, fmaxf(fminf(vdiv_f32(vsub_f32(v26, v25), v22).f32[0], 1.0), 0.0));
  *a1 = result;
  *(float32x2_t *)a2 = vmla_n_f32(a5, v7, 1.0);
  return result;
}

uint64_t p2t::Orient2d(float64x2_t *this, Point *a2, Point *a3, Point *a4)
{
  int8x16_t v4 = (int8x16_t)vsubq_f64(*(float64x2_t *)&a2->v, *(float64x2_t *)&a3->v);
  float64x2_t v5 = vmulq_f64((float64x2_t)vextq_s8(v4, v4, 8uLL), vsubq_f64(*this, *(float64x2_t *)&a3->v));
  double v6 = vsubq_f64(v5, (float64x2_t)vdupq_laneq_s64((int64x2_t)v5, 1)).f64[0];
  if (v6 >= 1.0e-12 || v6 <= -1.0e-12) {
    return v6 > 0.0;
  }
  else {
    return 2;
  }
}

BOOL p2t::InScanArea(p2t *this, Point *a2, Point *a3, Point *a4, Point *a5)
{
  double v5 = *((double *)this + 1);
  double v6 = *(double *)&a4[2].v;
  return (*(double *)&a2[2].v - v5) * (*(double *)&a4->v - *(double *)&a2->v)
       + (v6 - *(double *)&a2[2].v) * (*(double *)this - *(double *)&a2->v) < -1.0e-12
      && (*(double *)&a3[2].v - v5) * (*(double *)&a4->v - *(double *)&a3->v)
       + (v6 - *(double *)&a3[2].v) * (*(double *)this - *(double *)&a3->v) > 1.0e-12;
}

void p2t::Sweep::Triangulate(p2t::Sweep *this, p2t::SweepContext *a2)
{
}

void sub_235F0FC38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void p2t::Sweep::SweepPoints(p2t::Sweep *this, p2t::SweepContext *a2)
{
  int v4 = 1;
  if ((int)((*((void *)a2 + 17) - *((void *)a2 + 16)) >> 3) >= 2)
  {
    Point = (Point *)p2t::SweepContext::GetPoint(a2, &v4);
    p2t::SweepContext::LocateNode((p2t::AdvancingFront **)a2, Point);
    p2t::Sweep::NewFrontTriangle();
  }
}

void sub_235F10564(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x1020C403BE5E226);
  _Unwind_Resume(a1);
}

void p2t::Sweep::FinalizationPolygon(p2t::Sweep *this, p2t::SweepContext *a2)
{
  uint64_t v3 = *(void *)(**((void **)a2 + 19) + 16);
  double v5 = *(Point **)v3;
  int v4 = *(p2t::Triangle **)(v3 + 8);
  if ((p2t::Triangle::GetConstrainedEdgeCW((Point **)v4, *(Point **)v3) & 1) == 0)
  {
    do
      int v4 = (p2t::Triangle *)p2t::Triangle::NeighborCCW(v4, v5);
    while (!p2t::Triangle::GetConstrainedEdgeCW((Point **)v4, v5));
  }

  p2t::SweepContext::MeshClean(a2, v4);
}

void p2t::Sweep::PointEvent(p2t::Sweep *this, p2t::AdvancingFront **a2, Point *a3)
{
}

uint64_t p2t::Sweep::EdgeEvent(p2t::Sweep *a1, uint64_t a2, Point **a3, uint64_t a4)
{
  *(void *)(a2 + 64) = a3;
  float32x2_t v8 = *a3;
  float v9 = a3[1];
  *(unsigned char *)(a2 + 72) = *(double *)&(*a3)->v > *(double *)&v9->v;
  float32x2_t v10 = *(p2t::Triangle **)(a4 + 8);
  int v11 = p2t::Triangle::EdgeIndex(v10, v8, v9);
  if (v11 == -1)
  {
    p2t::Sweep::FillEdgeEvent((uint64_t)a1, a2, (uint64_t)a3, a4);
    float32x2_t v14 = *a3;
    float32x2_t v15 = (float64x2_t *)a3[1];
    float32x2_t v16 = *(p2t::Triangle **)(a4 + 8);
    return p2t::Sweep::EdgeEvent(a1, (p2t::SweepContext *)a2, v14, v15, v16, (Point *)v15);
  }
  else
  {
    int v12 = v11;
    p2t::Triangle::MarkConstrainedEdge((uint64_t)v10, v11);
    uint64_t result = *((void *)v10 + v12 + 4);
    if (result)
    {
      return p2t::Triangle::MarkConstrainedEdge(result, v8, v9);
    }
  }
  return result;
}

void p2t::Sweep::NewFrontTriangle()
{
}

void sub_235F109FC(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x1020C403BE5E226);
  _Unwind_Resume(a1);
}

void p2t::Sweep::Fill()
{
}

void sub_235F10AF4(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x1020C403BE5E226);
  _Unwind_Resume(a1);
}

void p2t::Sweep::FillAdvancingFront(BOOL a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = a1;
  if (*(void *)(a3[2] + 16))
  {
    a1 = p2t::Sweep::LargeHole_DontFill(a1, a3[2]);
    if (!a1) {
      p2t::Sweep::Fill();
    }
  }
  if (*(void *)(a3[3] + 24) && !p2t::Sweep::LargeHole_DontFill(a1, a3[3])) {
    p2t::Sweep::Fill();
  }
  uint64_t v6 = a3[2];
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 16);
    if (v7)
    {
      if (atan2(*(double *)(*a3 + 8) - *(double *)(*(void *)v7 + 8), *(double *)*a3 - **(double **)v7) < 2.35619449)
      {
        p2t::Sweep::FillBasin(v5, a2, (uint64_t)a3);
      }
    }
  }
}

BOOL p2t::Sweep::IsEdgeSideOfTriangle(p2t::Sweep *this, p2t::Triangle *a2, Point *a3, Point *a4)
{
  int v7 = p2t::Triangle::EdgeIndex(a2, a3, a4);
  if (v7 != -1)
  {
    p2t::Triangle::MarkConstrainedEdge((uint64_t)a2, v7);
    uint64_t v8 = *((void *)a2 + v7 + 4);
    if (v8) {
      p2t::Triangle::MarkConstrainedEdge(v8, a3, a4);
    }
  }
  return v7 != -1;
}

void p2t::Sweep::FillEdgeEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v8 = *(double **)a3;
  double v9 = **(double **)a3;
  if (*(unsigned char *)(a2 + 72))
  {
    uint64_t v10 = *(void *)(a4 + 16);
    int v11 = *(double **)v10;
    for (double i = **(double **)v10; i < v9; double i = **(double **)v10)
    {
      double v13 = (v8[1] - *(double *)(*(void *)(a3 + 8) + 8)) * (i - v9)
          + (v11[1] - v8[1]) * (**(double **)(a3 + 8) - v9);
      if ((v13 >= 1.0e-12 || v13 <= -1.0e-12) && v13 > 0.0)
      {
        p2t::Sweep::FillRightBelowEdgeEvent(a1, a2, (double **)a3, v4);
        uint64_t v8 = *(double **)a3;
        double v9 = **(double **)a3;
        uint64_t v10 = v4;
      }
      uint64_t v4 = v10;
      uint64_t v10 = *(void *)(v10 + 16);
      int v11 = *(double **)v10;
    }
  }
  else
  {
    uint64_t v15 = *(void *)(a4 + 24);
    float32x2_t v16 = *(double **)v15;
    for (double j = **(double **)v15; j > v9; double j = **(double **)v15)
    {
      double v18 = (v8[1] - *(double *)(*(void *)(a3 + 8) + 8)) * (j - v9)
          + (v16[1] - v8[1]) * (**(double **)(a3 + 8) - v9);
      BOOL v19 = v18 >= 1.0e-12 || v18 <= -1.0e-12;
      if (v19 && v18 <= 0.0)
      {
        p2t::Sweep::FillLeftBelowEdgeEvent(a1, a2, (double **)a3, v4);
        uint64_t v8 = *(double **)a3;
        double v9 = **(double **)a3;
        uint64_t v15 = v4;
      }
      uint64_t v4 = v15;
      uint64_t v15 = *(void *)(v15 + 24);
      float32x2_t v16 = *(double **)v15;
    }
  }
}

uint64_t p2t::Sweep::EdgeEvent(p2t::Sweep *this, p2t::SweepContext *a2, Point *a3, float64x2_t *a4, p2t::Triangle *a5, Point *a6)
{
  int v7 = a5;
  uint64_t v8 = a4;
  int v12 = p2t::Triangle::EdgeIndex(a5, a3, (const Point *)a4);
  if (v12 == -1)
  {
    while (1)
    {
      float32x2_t v16 = p2t::Triangle::PointCCW(v7, a6);
      int8x16_t v17 = (int8x16_t)vsubq_f64(*(float64x2_t *)&v16->v, *(float64x2_t *)&a3->v);
      float64x2_t v18 = vmulq_f64((float64x2_t)vextq_s8(v17, v17, 8uLL), vsubq_f64(*v8, *(float64x2_t *)&a3->v));
      double v19 = vsubq_f64(v18, (float64x2_t)vdupq_laneq_s64((int64x2_t)v18, 1)).f64[0];
      if (v19 > -1.0e-12 && v19 < 1.0e-12) {
        break;
      }
      double v26 = v19;
      float32x2_t v20 = p2t::Triangle::PointCW(v7, a6);
      int8x16_t v21 = (int8x16_t)vsubq_f64(*(float64x2_t *)&v20->v, *(float64x2_t *)&a3->v);
      float64x2_t v22 = vmulq_f64((float64x2_t)vextq_s8(v21, v21, 8uLL), vsubq_f64(*v8, *(float64x2_t *)&a3->v));
      double v23 = vsubq_f64(v22, (float64x2_t)vdupq_laneq_s64((int64x2_t)v22, 1)).f64[0];
      if (v23 > -1.0e-12 && v23 < 1.0e-12)
      {
        float32x2_t v14 = v20;
        float32x2_t v25 = (float64x2_t *)*((void *)v7 + 1);
        if (v25 != v8 && *((float64x2_t **)v7 + 2) != v8 && *((float64x2_t **)v7 + 3) != v8
          || v25 != (float64x2_t *)v20 && *((Point **)v7 + 2) != v20 && *((Point **)v7 + 3) != v20)
        {
          p2t::Sweep::EdgeEvent((uint64_t)v27);
        }
LABEL_30:
        p2t::Triangle::MarkConstrainedEdge((uint64_t)v7, (Point *)v8, v14);
        *(void *)(*((void *)a2 + 8) + 8) = v14;
        int v7 = (p2t::Triangle *)p2t::Triangle::NeighborAcross(v7, a6);
        int v13 = p2t::Triangle::EdgeIndex(v7, a3, v14);
        a6 = v14;
        uint64_t v8 = (float64x2_t *)v14;
        if (v13 != -1) {
          goto LABEL_3;
        }
      }
      else
      {
        if (v26 > 0.0 == v23 <= 0.0)
        {
          return p2t::Sweep::FlipEdgeEvent(this, a2, a3, (Point *)v8, v7, a6);
        }
        if (v26 > 0.0)
        {
          int v7 = (p2t::Triangle *)p2t::Triangle::NeighborCW(v7, a6);
          int v12 = p2t::Triangle::EdgeIndex(v7, a3, (const Point *)v8);
          if (v12 != -1) {
            goto LABEL_2;
          }
        }
        else
        {
          int v7 = (p2t::Triangle *)p2t::Triangle::NeighborCCW(v7, a6);
          int v12 = p2t::Triangle::EdgeIndex(v7, a3, (const Point *)v8);
          if (v12 != -1) {
            goto LABEL_2;
          }
        }
      }
    }
    float32x2_t v14 = v16;
    float32x2_t v24 = (float64x2_t *)*((void *)v7 + 1);
    if (v24 != v8 && *((float64x2_t **)v7 + 2) != v8 && *((float64x2_t **)v7 + 3) != v8
      || v24 != (float64x2_t *)v16 && *((Point **)v7 + 2) != v16 && *((Point **)v7 + 3) != v16)
    {
      p2t::Sweep::EdgeEvent((uint64_t)v28);
    }
    goto LABEL_30;
  }
LABEL_2:
  int v13 = v12;
  float32x2_t v14 = (Point *)v8;
LABEL_3:
  p2t::Triangle::MarkConstrainedEdge((uint64_t)v7, v13);
  uint64_t result = *((void *)v7 + v13 + 4);
  if (result)
  {
    return p2t::Triangle::MarkConstrainedEdge(result, a3, v14);
  }
  return result;
}

uint64_t p2t::Sweep::FlipEdgeEvent(p2t::Sweep *this, p2t::SweepContext *a2, Point *a3, Point *a4, p2t::Triangle *a5, Point *a6)
{
  int v7 = a5;
  int v12 = (p2t::Triangle *)p2t::Triangle::NeighborAcross(a5, a6);
  int v13 = p2t::Triangle::OppositePoint(v12, v7, a6);
  if (!v13) {
LABEL_42:
  }
    p2t::Sweep::FlipEdgeEvent();
  float32x2_t v14 = v13;
  while (1)
  {
    double v19 = (double *)p2t::Triangle::PointCCW(v7, a6);
    float32x2_t v20 = (double *)p2t::Triangle::PointCW(v7, a6);
    double v21 = *(double *)&a6[2].v;
    double v22 = *(double *)&v14->v;
    double v23 = *(double *)&v14[2].v;
    if ((v19[1] - v21) * (*(double *)&v14->v - *v19) + (v23 - v19[1]) * (*(double *)&a6->v - *v19) >= -1.0e-12
      || (v20[1] - v21) * (v22 - *v20) + (v23 - v20[1]) * (*(double *)&a6->v - *v20) <= 1.0e-12)
    {
      break;
    }
    p2t::Sweep::RotateTrianglePair((p2t::Sweep *)v20, v7, a6, v12, v14);
    p2t::SweepContext::MapTriangleToNodes((uint64_t)a2, (Point **)v7);
    uint64_t result = p2t::SweepContext::MapTriangleToNodes((uint64_t)a2, (Point **)v12);
    double v26 = *(double *)&a4->v;
    double v25 = *(double *)&a4[2].v;
    double v27 = *(double *)&a3->v;
    double v28 = *(double *)&a3[2].v;
    double v29 = *(double *)&v14->v;
    double v30 = *(double *)&v14[2].v;
    if (*(double *)&a6->v == *(double *)&a4->v && *(double *)&a6[2].v == v25 && v29 == v27 && v30 == v28)
    {
      float v31 = (double **)*((void *)a2 + 8);
      BOOL v32 = v31[1];
      if (v26 == *v32 && v25 == v32[1])
      {
        float v34 = *v31;
        if (v27 == *v34 && v28 == v34[1])
        {
          p2t::Triangle::MarkConstrainedEdge((uint64_t)v7, a3, a4);
          p2t::Triangle::MarkConstrainedEdge((uint64_t)v12, a3, a4);
          p2t::Sweep::Legalize(this, a2, v7);
          return p2t::Sweep::Legalize(this, a2, v12);
        }
      }
      return result;
    }
    double v15 = (v27 - v29) * (v25 - v28) + (v30 - v28) * (v26 - v27);
    BOOL v16 = v15 <= -1.0e-12;
    if (v15 >= 1.0e-12) {
      BOOL v16 = 1;
    }
    BOOL v17 = v15 > 0.0;
    if (v16 && v17) {
      float64x2_t v18 = v12;
    }
    else {
      float64x2_t v18 = v7;
    }
    if (!v16 || !v17) {
      int v7 = v12;
    }
    *((unsigned char *)v18 + (int)p2t::Triangle::EdgeIndex(v18, a6, v14) + 3) = 1;
    p2t::Sweep::Legalize(this, a2, v18);
    p2t::Triangle::ClearDelunayEdges((uint64_t)v18);
    int v12 = (p2t::Triangle *)p2t::Triangle::NeighborAcross(v7, a6);
    float32x2_t v14 = p2t::Triangle::OppositePoint(v12, v7, a6);
    if (!v14) {
      goto LABEL_42;
    }
  }
  double v36 = (*(double *)&a3[2].v - *(double *)&a4[2].v) * (v22 - *(double *)&a3->v)
      + (v23 - *(double *)&a3[2].v) * (*(double *)&a4->v - *(double *)&a3->v);
  int v37 = v36 > 0.0;
  if (v36 < 1.0e-12 && v36 > -1.0e-12) {
    int v37 = 2;
  }
  if (v37 == 1)
  {
    uint64_t v39 = p2t::Triangle::PointCW(v12, v14);
  }
  else
  {
    if (v37) {
      p2t::Sweep::FlipEdgeEvent();
    }
    uint64_t v39 = p2t::Triangle::PointCCW(v12, v14);
  }
  p2t::Sweep::FlipScanEdgeEvent(this, a2, a3, a4, v7, v12, v39);

  return p2t::Sweep::EdgeEvent(this, a2, a3, a4, v7, a6);
}

uint64_t p2t::Sweep::Legalize(p2t::Sweep *this, p2t::SweepContext *a2, p2t::Triangle *a3)
{
  uint64_t v6 = (char *)a3 + 3;
  if (!*((unsigned char *)a3 + 3))
  {
    int v7 = (const Point **)*((void *)a3 + 4);
    if (v7)
    {
      uint64_t v8 = *((void *)a3 + 1);
      double v9 = p2t::Triangle::OppositePoint(*((p2t::Triangle **)a3 + 4), a3, (Point *)v8);
      int v10 = p2t::Triangle::Index(v7, v9);
      if (*((unsigned char *)v7 + v10) || (int v11 = (char *)v7 + v10 + 3, *v11))
      {
        *(unsigned char *)a3 = *((unsigned char *)v7 + v10);
      }
      else
      {
        BOOL v16 = (double *)p2t::Triangle::PointCCW(a3, (Point *)v8);
        BOOL v17 = (double *)p2t::Triangle::PointCW(a3, (Point *)v8);
        double v18 = *(double *)&v9[2].v;
        double v19 = *(double *)v8 - *(double *)&v9->v;
        double v20 = *(double *)(v8 + 8) - v18;
        double v21 = *v16 - *(double *)&v9->v;
        double v22 = v16[1] - v18;
        double v23 = -(v21 * v20 - v22 * v19);
        if (v23 > 0.0)
        {
          double v24 = *v17 - *(double *)&v9->v;
          double v25 = v17[1] - v18;
          double v26 = -(v25 * v19 - v24 * v20);
          if (v26 > 0.0
            && v26 * (v21 * v21 + v22 * v22)
             + -(v24 * v22 - v25 * v21) * (v19 * v19 + v20 * v20)
             + (v24 * v24 + v25 * v25) * v23 > 0.0)
          {
            goto LABEL_28;
          }
        }
      }
    }
  }
  uint64_t v6 = (char *)a3 + 4;
  if (!*((unsigned char *)a3 + 4))
  {
    int v7 = (const Point **)*((void *)a3 + 5);
    if (v7)
    {
      uint64_t v8 = *((void *)a3 + 2);
      double v9 = p2t::Triangle::OppositePoint(*((p2t::Triangle **)a3 + 5), a3, (Point *)v8);
      int v12 = p2t::Triangle::Index(v7, v9);
      if (*((unsigned char *)v7 + v12) || (int v11 = (char *)v7 + v12 + 3, *v11))
      {
        *((unsigned char *)a3 + 1) = *((unsigned char *)v7 + v12);
      }
      else
      {
        double v27 = (double *)p2t::Triangle::PointCCW(a3, (Point *)v8);
        BOOL v17 = (double *)p2t::Triangle::PointCW(a3, (Point *)v8);
        double v28 = *(double *)&v9[2].v;
        double v29 = *(double *)v8 - *(double *)&v9->v;
        double v30 = *(double *)(v8 + 8) - v28;
        double v31 = *v27 - *(double *)&v9->v;
        double v32 = v27[1] - v28;
        double v33 = -(v31 * v30 - v32 * v29);
        if (v33 > 0.0)
        {
          double v34 = *v17 - *(double *)&v9->v;
          double v35 = v17[1] - v28;
          double v36 = -(v35 * v29 - v34 * v30);
          if (v36 > 0.0
            && v36 * (v31 * v31 + v32 * v32)
             + -(v34 * v32 - v35 * v31) * (v29 * v29 + v30 * v30)
             + (v34 * v34 + v35 * v35) * v33 > 0.0)
          {
            goto LABEL_28;
          }
        }
      }
    }
  }
  uint64_t v6 = (char *)a3 + 5;
  if (*((unsigned char *)a3 + 5)) {
    return 0;
  }
  int v7 = (const Point **)*((void *)a3 + 6);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = *((void *)a3 + 3);
  double v9 = p2t::Triangle::OppositePoint(*((p2t::Triangle **)a3 + 6), a3, (Point *)v8);
  int v14 = p2t::Triangle::Index(v7, v9);
  char v15 = *((unsigned char *)v7 + v14);
  if (v15 || (int v11 = (char *)v7 + v14 + 3, *v11))
  {
    uint64_t result = 0;
    *((unsigned char *)a3 + 2) = v15;
    return result;
  }
  int v37 = (double *)p2t::Triangle::PointCCW(a3, (Point *)v8);
  BOOL v17 = (double *)p2t::Triangle::PointCW(a3, (Point *)v8);
  double v38 = *(double *)&v9[2].v;
  double v39 = *(double *)v8 - *(double *)&v9->v;
  double v40 = *(double *)(v8 + 8) - v38;
  double v41 = *v37 - *(double *)&v9->v;
  double v42 = v37[1] - v38;
  double v43 = -(v41 * v40 - v42 * v39);
  if (v43 <= 0.0) {
    return 0;
  }
  double v44 = *v17 - *(double *)&v9->v;
  double v45 = v17[1] - v38;
  double v46 = -(v45 * v39 - v44 * v40);
  if (v46 <= 0.0
    || v46 * (v41 * v41 + v42 * v42)
     + -(v44 * v42 - v45 * v41) * (v39 * v39 + v40 * v40)
     + (v44 * v44 + v45 * v45) * v43 <= 0.0)
  {
    return 0;
  }
LABEL_28:
  unsigned char *v6 = 1;
  unsigned char *v11 = 1;
  p2t::Sweep::RotateTrianglePair((p2t::Sweep *)v17, a3, (Point *)v8, (p2t::Triangle *)v7, v9);
  if ((p2t::Sweep::Legalize(this, a2, a3) & 1) == 0) {
    p2t::SweepContext::MapTriangleToNodes((uint64_t)a2, (Point **)a3);
  }
  if ((p2t::Sweep::Legalize(this, a2, (p2t::Triangle *)v7) & 1) == 0) {
    p2t::SweepContext::MapTriangleToNodes((uint64_t)a2, (Point **)v7);
  }
  unsigned char *v6 = 0;
  unsigned char *v11 = 0;
  return 1;
}

BOOL p2t::Sweep::LargeHole_DontFill(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 16);
  uint64_t v2 = *(void **)(a2 + 24);
  double v4 = **(double **)a2;
  double v5 = *(double *)(*(void *)a2 + 8);
  double v6 = *(double *)*v3 - v4;
  double v7 = *(double *)(*v3 + 8) - v5;
  double v8 = *(double *)*v2 - v4;
  double v9 = *(double *)(*v2 + 8) - v5;
  double v10 = atan2(-(v8 * v7 - v9 * v6), v8 * v6 + v9 * v7);
  BOOL result = 0;
  if (v10 > 1.57079633 || v10 < -1.57079633)
  {
    uint64_t v11 = v3[2];
    if (!v11
      || (double v12 = atan2(-((*(double *)(*(void *)v11 + 8) - v5) * v8 - (**(double **)v11 - v4) * v9), (**(double **)v11 - v4) * v8 + (*(double *)(*(void *)v11 + 8) - v5) * v9), v12 > 1.57079633)|| v12 < 0.0)
    {
      uint64_t v13 = v2[3];
      if (!v13) {
        return 1;
      }
      double v14 = atan2(-((**(double **)v13 - v4) * v7 - (*(double *)(*(void *)v13 + 8) - v5) * v6), (**(double **)v13 - v4) * v6 + (*(double *)(*(void *)v13 + 8) - v5) * v7);
      if (v14 > 1.57079633 || v14 < 0.0) {
        return 1;
      }
    }
  }
  return result;
}

double p2t::Sweep::BasinAngle(uint64_t a1, void *a2)
{
  uint64_t v2 = **(double ***)(a2[2] + 16);
  return atan2(*(double *)(*a2 + 8) - v2[1], *(double *)*a2 - *v2);
}

void p2t::Sweep::FillBasin(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 16);
  float64x2_t v4 = *(float64x2_t *)**(void **)(v3 + 16);
  float64x2_t v5 = vsubq_f64(*(float64x2_t *)*(void *)a3, v4);
  int8x16_t v6 = (int8x16_t)vsubq_f64(*(float64x2_t *)*(void *)v3, v4);
  float64x2_t v7 = vmulq_f64((float64x2_t)vextq_s8(v6, v6, 8uLL), v5);
  double v8 = vsubq_f64(v7, (float64x2_t)vdupq_laneq_s64((int64x2_t)v7, 1)).f64[0];
  if (v8 < 1.0e-12 && v8 > -1.0e-12 || v8 <= 0.0) {
    uint64_t v11 = *(double ***)(a3 + 16);
  }
  else {
    uint64_t v11 = *(double ***)(v3 + 16);
  }
  *(void *)(a2 + 24) = v11;
  double v12 = v11;
  do
  {
    uint64_t v13 = (uint64_t)v12;
    double v12 = (double **)v12[2];
  }
  while (v12 && *(double *)(*(void *)v13 + 8) >= (*v12)[1]);
  *(void *)(a2 + 32) = v13;
  if ((double **)v13 != v11)
  {
    double v14 = (double **)v13;
    do
    {
      char v15 = v14;
      double v14 = (double **)v14[2];
    }
    while (v14 && (*v15)[1] < (*v14)[1]);
    *(void *)(a2 + 40) = v15;
    if (v15 != (double **)v13)
    {
      BOOL v16 = *v15;
      BOOL v17 = *v11;
      double v18 = v17[1];
      double v19 = v16[1];
      *(double *)(a2 + 48) = *v16 - *v17;
      *(unsigned char *)(a2 + 56) = v18 > v19;
      p2t::Sweep::FillBasinReq(a1, a2, v13);
    }
  }
}

BOOL p2t::Sweep::AngleExceeds90Degrees(p2t::Sweep *this, Point *a2, Point *a3, Point *a4)
{
  double v4 = *(double *)&a2[2].v;
  double v5 = atan2(-((*(double *)&a4->v - *(double *)&a2->v) * (*(double *)&a3[2].v - v4)- (*(double *)&a4[2].v - v4) * (*(double *)&a3->v - *(double *)&a2->v)), (*(double *)&a4->v - *(double *)&a2->v) * (*(double *)&a3->v - *(double *)&a2->v)+ (*(double *)&a4[2].v - v4) * (*(double *)&a3[2].v - v4));
  return v5 < -1.57079633 || v5 > 1.57079633;
}

BOOL p2t::Sweep::AngleExceedsPlus90DegreesOrIsNegative(p2t::Sweep *this, Point *a2, Point *a3, Point *a4)
{
  double v4 = *(double *)&a2[2].v;
  double v5 = atan2(-((*(double *)&a4->v - *(double *)&a2->v) * (*(double *)&a3[2].v - v4)- (*(double *)&a4[2].v - v4) * (*(double *)&a3->v - *(double *)&a2->v)), (*(double *)&a4->v - *(double *)&a2->v) * (*(double *)&a3->v - *(double *)&a2->v)+ (*(double *)&a4[2].v - v4) * (*(double *)&a3[2].v - v4));
  return v5 < 0.0 || v5 > 1.57079633;
}

long double p2t::Sweep::Angle(p2t::Sweep *this, Point *a2, Point *a3, Point *a4)
{
  double v4 = *(double *)&a2[2].v;
  return atan2(-((*(double *)&a4->v - *(double *)&a2->v) * (*(double *)&a3[2].v - v4)- (*(double *)&a4[2].v - v4) * (*(double *)&a3->v - *(double *)&a2->v)), (*(double *)&a4->v - *(double *)&a2->v) * (*(double *)&a3->v - *(double *)&a2->v)+ (*(double *)&a4[2].v - v4) * (*(double *)&a3[2].v - v4));
}

double p2t::Sweep::HoleAngle(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  uint64_t v3 = **(double ***)(a2 + 16);
  double v4 = **(double **)a2;
  double v5 = *(double *)(*(void *)a2 + 8);
  return atan2(-((**(double **)v2 - v4) * (v3[1] - v5) - (*(double *)(*(void *)v2 + 8) - v5) * (*v3 - v4)), (**(double **)v2 - v4) * (*v3 - v4) + (*(double *)(*(void *)v2 + 8) - v5) * (v3[1] - v5));
}

BOOL p2t::Sweep::Incircle(p2t::Sweep *this, Point *a2, Point *a3, Point *a4, Point *a5)
{
  double v5 = *(double *)&a5[2].v;
  double v6 = *(double *)&a2->v - *(double *)&a5->v;
  double v7 = *(double *)&a2[2].v - v5;
  double v8 = *(double *)&a3->v - *(double *)&a5->v;
  double v9 = *(double *)&a3[2].v - v5;
  double v10 = -(v8 * v7 - v9 * v6);
  if (v10 <= 0.0) {
    return 0;
  }
  double v11 = *(double *)&a4->v - *(double *)&a5->v;
  double v12 = *(double *)&a4[2].v - v5;
  double v13 = -(v12 * v6 - v11 * v7);
  return v13 > 0.0
      && v13 * (v8 * v8 + v9 * v9) + -(v11 * v9 - v12 * v8) * (v6 * v6 + v7 * v7) + (v11 * v11 + v12 * v12) * v10 > 0.0;
}

void *p2t::Sweep::RotateTrianglePair(p2t::Sweep *this, p2t::Triangle *a2, Point *a3, p2t::Triangle *a4, Point *a5)
{
  double v18 = (p2t::Triangle *)p2t::Triangle::NeighborCCW(a2, a3);
  double v19 = (p2t::Triangle *)p2t::Triangle::NeighborCW(a2, a3);
  double v20 = (p2t::Triangle *)p2t::Triangle::NeighborCCW(a4, a5);
  double v21 = (p2t::Triangle *)p2t::Triangle::NeighborCW(a4, a5);
  char ConstrainedEdgeCCW = p2t::Triangle::GetConstrainedEdgeCCW((Point **)a2, a3);
  char ConstrainedEdgeCW = p2t::Triangle::GetConstrainedEdgeCW((Point **)a2, a3);
  char v17 = p2t::Triangle::GetConstrainedEdgeCCW((Point **)a4, a5);
  char v16 = p2t::Triangle::GetConstrainedEdgeCW((Point **)a4, a5);
  char DelunayEdgeCCW = p2t::Triangle::GetDelunayEdgeCCW((Point **)a2, a3);
  char DelunayEdgeCW = p2t::Triangle::GetDelunayEdgeCW((Point **)a2, a3);
  char v13 = p2t::Triangle::GetDelunayEdgeCCW((Point **)a4, a5);
  char v14 = p2t::Triangle::GetDelunayEdgeCW((Point **)a4, a5);
  p2t::Triangle::Legalize(a2, a3, a5);
  p2t::Triangle::Legalize(a4, a5, a3);
  p2t::Triangle::SetDelunayEdgeCCW((uint64_t)a4, a3, DelunayEdgeCCW);
  p2t::Triangle::SetDelunayEdgeCW((uint64_t)a2, a3, DelunayEdgeCW);
  p2t::Triangle::SetDelunayEdgeCCW((uint64_t)a2, a5, v13);
  p2t::Triangle::SetDelunayEdgeCW((uint64_t)a4, a5, v14);
  p2t::Triangle::SetConstrainedEdgeCCW((uint64_t)a4, a3, ConstrainedEdgeCCW);
  p2t::Triangle::SetConstrainedEdgeCW((uint64_t)a2, a3, ConstrainedEdgeCW);
  p2t::Triangle::SetConstrainedEdgeCCW((uint64_t)a2, a5, v17);
  p2t::Triangle::SetConstrainedEdgeCW((uint64_t)a4, a5, v16);
  p2t::Triangle::ClearNeighbors(a2);
  p2t::Triangle::ClearNeighbors(a4);
  if (v18) {
    p2t::Triangle::MarkNeighbor(a4, v18);
  }
  if (v19) {
    p2t::Triangle::MarkNeighbor(a2, v19);
  }
  if (v20) {
    p2t::Triangle::MarkNeighbor(a2, v20);
  }
  if (v21) {
    p2t::Triangle::MarkNeighbor(a4, v21);
  }

  return p2t::Triangle::MarkNeighbor(a2, a4);
}

void p2t::Sweep::FillBasinReq(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2 + 24;
  if (!*(unsigned char *)(a2 + 56)) {
    uint64_t v3 = a2 + 40;
  }
  if (*(double *)(a2 + 48) <= *(double *)(**(void **)v3 + 8) - *(double *)(*(void *)a3 + 8)) {
    p2t::Sweep::Fill();
  }
}

BOOL p2t::Sweep::IsShallow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2 + 24;
  if (!*(unsigned char *)(a2 + 56)) {
    uint64_t v3 = a2 + 40;
  }
  return *(double *)(a2 + 48) > *(double *)(**(void **)v3 + 8) - *(double *)(*(void *)a3 + 8);
}

void p2t::Sweep::FillRightAboveEdgeEvent(uint64_t a1, uint64_t a2, double **a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 16);
  double v5 = *(double **)v4;
  double v6 = **(double **)v4;
  double v7 = *a3;
  double v8 = **a3;
  if (v6 < v8)
  {
    uint64_t v9 = a4;
    do
    {
      double v13 = (v7[1] - a3[1][1]) * (v6 - v8) + (v5[1] - v7[1]) * (*a3[1] - v8);
      if ((v13 >= 1.0e-12 || v13 <= -1.0e-12) && v13 > 0.0)
      {
        p2t::Sweep::FillRightBelowEdgeEvent(a1, a2, a3, v9);
        double v7 = *a3;
        double v8 = **a3;
        uint64_t v4 = v9;
      }
      uint64_t v9 = v4;
      uint64_t v4 = *(void *)(v4 + 16);
      double v5 = *(double **)v4;
      double v6 = **(double **)v4;
    }
    while (v6 < v8);
  }
}

void p2t::Sweep::FillLeftAboveEdgeEvent(uint64_t a1, uint64_t a2, double **a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 24);
  double v5 = *(double **)v4;
  double v6 = **(double **)v4;
  double v7 = *a3;
  double v8 = **a3;
  if (v6 > v8)
  {
    uint64_t v9 = a4;
    do
    {
      double v13 = (v7[1] - a3[1][1]) * (v6 - v8) + (v5[1] - v7[1]) * (*a3[1] - v8);
      if ((v13 >= 1.0e-12 || v13 <= -1.0e-12) && v13 <= 0.0)
      {
        p2t::Sweep::FillLeftBelowEdgeEvent(a1, a2, a3, v9);
        double v7 = *a3;
        double v8 = **a3;
        uint64_t v4 = v9;
      }
      uint64_t v9 = v4;
      uint64_t v4 = *(void *)(v4 + 24);
      double v5 = *(double **)v4;
      double v6 = **(double **)v4;
    }
    while (v6 > v8);
  }
}

void p2t::Sweep::FillRightBelowEdgeEvent(uint64_t a1, uint64_t a2, double **a3, uint64_t a4)
{
  uint64_t v4 = *(double **)a4;
  for (double i = **(double **)a4; i < **a3; double i = **(double **)a4)
  {
    double v10 = *(double ****)(a4 + 16);
    double v11 = (**v10[2] - *(double *)*v10) * (v4[1] - (*v10[2])[1])
        + (*((double *)*v10 + 1) - (*v10[2])[1]) * (i - **v10[2]);
    if ((v11 >= 1.0e-12 || v11 <= -1.0e-12) && v11 > 0.0) {
      p2t::Sweep::Fill();
    }
    p2t::Sweep::FillRightConvexEdgeEvent(a1, a2, a3, a4);
    uint64_t v4 = *(double **)a4;
  }
}

void p2t::Sweep::FillRightConcaveEdgeEvent()
{
}

void p2t::Sweep::FillRightConvexEdgeEvent(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 16);
  double v5 = *(double **)v4;
  uint64_t v6 = *(void *)(v4 + 16);
  double v7 = *(double **)v6;
  double v8 = **(double **)v4;
  double v9 = **(double **)v6;
  double v10 = *(double *)(*(void *)v6 + 8);
  do
  {
    double v11 = v5[1];
    double v5 = v7;
    double v12 = v8;
    double v8 = v9;
    uint64_t v6 = *(void *)(v6 + 16);
    double v7 = *(double **)v6;
    double v9 = **(double **)v6;
    double v13 = (v9 - v8) * (v11 - *(double *)(*(void *)v6 + 8)) + (v10 - *(double *)(*(void *)v6 + 8)) * (v12 - v9);
    BOOL v14 = v13 >= 1.0e-12 || v13 <= -1.0e-12;
    if (v14 && v13 > 0.0) {
      p2t::Sweep::Fill();
    }
    double v15 = (*(double *)(*a3 + 8) - *(double *)(a3[1] + 8)) * (v8 - *(double *)*a3)
        + (v10 - *(double *)(*a3 + 8)) * (*(double *)a3[1] - *(double *)*a3);
    if (v15 < 1.0e-12 && v15 > -1.0e-12) {
      break;
    }
    BOOL v14 = v15 <= 0.0;
    double v10 = *(double *)(*(void *)v6 + 8);
  }
  while (!v14);
}

void p2t::Sweep::FillLeftBelowEdgeEvent(uint64_t a1, uint64_t a2, double **a3, uint64_t a4)
{
  uint64_t v4 = *(double **)a4;
  for (double i = **(double **)a4; i > **a3; double i = **(double **)a4)
  {
    double v10 = *(double ****)(a4 + 24);
    double v11 = (**v10[3] - *(double *)*v10) * (v4[1] - (*v10[3])[1])
        + (*((double *)*v10 + 1) - (*v10[3])[1]) * (i - **v10[3]);
    if ((v11 >= 1.0e-12 || v11 <= -1.0e-12) && v11 <= 0.0) {
      p2t::Sweep::Fill();
    }
    p2t::Sweep::FillLeftConvexEdgeEvent(a1, a2, a3, a4);
    uint64_t v4 = *(double **)a4;
  }
}

void p2t::Sweep::FillLeftConcaveEdgeEvent()
{
}

void p2t::Sweep::FillLeftConvexEdgeEvent(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 24);
  double v5 = *(double **)v4;
  uint64_t v6 = *(void *)(v4 + 24);
  double v7 = *(double **)v6;
  double v8 = **(double **)v4;
  double v9 = **(double **)v6;
  double v10 = *(double *)(*(void *)v6 + 8);
  do
  {
    double v11 = v5[1];
    double v5 = v7;
    double v12 = v8;
    double v8 = v9;
    uint64_t v6 = *(void *)(v6 + 24);
    double v7 = *(double **)v6;
    double v9 = **(double **)v6;
    double v13 = (v9 - v8) * (v11 - *(double *)(*(void *)v6 + 8)) + (v10 - *(double *)(*(void *)v6 + 8)) * (v12 - v9);
    BOOL v14 = v13 >= 1.0e-12 || v13 <= -1.0e-12;
    if (v14 && v13 <= 0.0) {
      p2t::Sweep::Fill();
    }
    double v15 = (*(double *)(*a3 + 8) - *(double *)(a3[1] + 8)) * (v8 - *(double *)*a3)
        + (v10 - *(double *)(*a3 + 8)) * (*(double *)a3[1] - *(double *)*a3);
    if (v15 < 1.0e-12 && v15 > -1.0e-12) {
      break;
    }
    BOOL v14 = v15 <= 0.0;
    double v10 = *(double *)(*(void *)v6 + 8);
  }
  while (v14);
}

p2t::Triangle *p2t::Sweep::NextFlipTriangle(p2t::Sweep *this, p2t::SweepContext *a2, int a3, p2t::Triangle *a4, p2t::Triangle *a5, Point *a6, Point *a7)
{
  if (a3 == 1) {
    double v9 = a5;
  }
  else {
    double v9 = a4;
  }
  if (a3 == 1) {
    double v10 = a4;
  }
  else {
    double v10 = a5;
  }
  *((unsigned char *)v9 + (int)p2t::Triangle::EdgeIndex(v9, a6, a7) + 3) = 1;
  p2t::Sweep::Legalize(this, a2, v9);
  p2t::Triangle::ClearDelunayEdges((uint64_t)v9);
  return v10;
}

Point *p2t::Sweep::NextFlipPoint(p2t::Sweep *this, Point *a2, Point *a3, p2t::Triangle *a4, Point *a5)
{
  int8x16_t v5 = (int8x16_t)vsubq_f64(*(float64x2_t *)&a5->v, *(float64x2_t *)&a2->v);
  float64x2_t v6 = vmulq_f64((float64x2_t)vextq_s8(v5, v5, 8uLL), vsubq_f64(*(float64x2_t *)&a3->v, *(float64x2_t *)&a2->v));
  double v7 = vsubq_f64(v6, (float64x2_t)vdupq_laneq_s64((int64x2_t)v6, 1)).f64[0];
  int v8 = v7 > 0.0;
  if (v7 < 1.0e-12 && v7 > -1.0e-12) {
    int v8 = 2;
  }
  if (v8 == 1)
  {
    return p2t::Triangle::PointCW(a4, a5);
  }
  else
  {
    if (v8) {
      p2t::Sweep::FlipEdgeEvent();
    }
    return p2t::Triangle::PointCCW(a4, a5);
  }
}

uint64_t p2t::Sweep::FlipScanEdgeEvent(p2t::Sweep *this, p2t::SweepContext *a2, Point *a3, Point *a4, p2t::Triangle *a5, p2t::Triangle *a6, Point *a7)
{
  while (1)
  {
    BOOL v14 = a6;
    a6 = (p2t::Triangle *)p2t::Triangle::NeighborAcross(a6, a7);
    double v15 = p2t::Triangle::OppositePoint(a6, v14, a7);
    char v16 = (double *)p2t::Triangle::PointCCW(a5, a4);
    char v17 = (double *)p2t::Triangle::PointCW(a5, a4);
    double v18 = *(double *)&a4->v;
    double v19 = *(double *)&a4[2].v;
    double v20 = *(double *)&v15->v;
    double v21 = *(double *)&v15[2].v;
    if ((v16[1] - v19) * (*(double *)&v15->v - *v16) + (v21 - v16[1]) * (*(double *)&a4->v - *v16) < -1.0e-12
      && (v17[1] - v19) * (v20 - *v17) + (v21 - v17[1]) * (v18 - *v17) > 1.0e-12)
    {
      break;
    }
    double v22 = (*(double *)&a3[2].v - v19) * (v20 - *(double *)&a3->v)
        + (v21 - *(double *)&a3[2].v) * (v18 - *(double *)&a3->v);
    int v23 = v22 > 0.0;
    if (v22 < 1.0e-12 && v22 > -1.0e-12) {
      int v23 = 2;
    }
    if (v23 == 1)
    {
      a7 = p2t::Triangle::PointCW(a6, v15);
    }
    else
    {
      if (v23) {
        p2t::Sweep::FlipEdgeEvent();
      }
      a7 = p2t::Triangle::PointCCW(a6, v15);
    }
  }

  return p2t::Sweep::FlipEdgeEvent(this, a2, a4, v15, a6, v15);
}

void p2t::Sweep::~Sweep(p2t::Sweep *this)
{
  uint64_t v2 = *(void **)this;
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3 == v2)
  {
    uint64_t v2 = v3;
  }
  else
  {
    unint64_t v5 = 0;
    do
    {
      if (v2[v5])
      {
        MEMORY[0x237DF7CA0](v2[v5], 0x1020C40DBF2485DLL);
        uint64_t v2 = *(void **)this;
        uint64_t v3 = (void *)*((void *)this + 1);
      }
      ++v5;
    }
    while (v5 < v3 - v2);
  }
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

void p2t::CDT::CDT()
{
}

void sub_235F12DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  MEMORY[0x237DF7CA0](v11, 0x10A0C408F860618);
  _Unwind_Resume(a1);
}

void p2t::CDT::AddHole(void **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  double v9 = 0;
  double v10 = 0;
  __p = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    if (v5 < 0) {
      _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
    }
    float64x2_t v6 = (char *)operator new(v3 - *(void *)a2);
    double v7 = &v6[8 * (v5 >> 3)];
    __p = v6;
    double v10 = v7;
    memcpy(v6, v4, v5);
    double v9 = v7;
  }
  p2t::SweepContext::AddHole(v2, &__p);
  if (__p)
  {
    double v9 = __p;
    operator delete(__p);
  }
}

void sub_235F12EB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void p2t::CDT::AddPoint(p2t::SweepContext **this, Point *a2)
{
}

void p2t::CDT::Triangulate(p2t::Sweep **this)
{
}

void *p2t::CDT::GetTriangles@<X0>(p2t::CDT *this@<X0>, void *a2@<X8>)
{
  return p2t::SweepContext::GetTriangles(*(void **)this, a2);
}

void *p2t::CDT::GetMap@<X0>(p2t::CDT *this@<X0>, void *a2@<X8>)
{
  return p2t::SweepContext::GetMap(*(void **)this, a2);
}

void p2t::CDT::~CDT(p2t::SweepContext **this)
{
  uint64_t v2 = *this;
  if (v2)
  {
    p2t::SweepContext::~SweepContext(v2);
    MEMORY[0x237DF7CA0]();
  }
  uint64_t v3 = this[1];
  if (v3)
  {
    p2t::Sweep::~Sweep(v3);
    MEMORY[0x237DF7CA0]();
  }
}

void sub_235F13184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F133AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F1360C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  std::vector<NSObject * {__strong}>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_235F13C60(_Unwind_Exception *a1)
{
  if (v2)
  {
    uint64_t v7 = 8 * *(void *)(v5 - 168);
    do
    {

      v7 -= 8;
    }
    while (v7 != -8);
  }

  _Unwind_Resume(a1);
}

void sub_235F13DC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F13DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void makeHeap(id **a1, uint64_t **a2)
{
  if (a1 && a1[1] != *a1)
  {
    id v32 = **a1;
    uint64_t v5 = *a1;
    uint64_t v4 = a1[1];
    if (v4 != *a1)
    {
      unint64_t v6 = 0;
      int v7 = 0;
      int v8 = a2 + 1;
      while (1)
      {
        id v9 = v5[v6];
        double v10 = v9;
        uint64_t v11 = *v8;
        double v12 = a2 + 1;
        double v13 = (uint64_t *)(a2 + 1);
        if (*v8) {
          break;
        }
LABEL_13:
        char v16 = operator new(0x30uLL);
        *((void *)v16 + 4) = v10;
        *((_DWORD *)v16 + 10) = 0;
        *(void *)char v16 = 0;
        *((void *)v16 + 1) = 0;
        *((void *)v16 + 2) = v13;
        *double v12 = (uint64_t *)v16;
        char v17 = (uint64_t *)**a2;
        double v18 = (uint64_t *)v16;
        if (v17)
        {
          *a2 = v17;
          double v18 = *v12;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a2[1], v18);
        uint64_t v11 = a2[1];
        a2[2] = (uint64_t *)((char *)a2[2] + 1);
        float v19 = *((float *)v16 + 10);
        double v20 = a2 + 1;
        double v21 = (uint64_t *)(a2 + 1);
        if (!v11) {
          goto LABEL_24;
        }
        while (1)
        {
LABEL_20:
          while (1)
          {
            double v21 = v11;
            unint64_t v22 = v11[4];
            if ((unint64_t)v32 >= v22) {
              break;
            }
            uint64_t v11 = (uint64_t *)*v21;
            double v20 = (uint64_t **)v21;
            if (!*v21) {
              goto LABEL_24;
            }
          }
          if (v22 >= (unint64_t)v32) {
            break;
          }
          uint64_t v11 = (uint64_t *)v21[1];
          if (!v11)
          {
            double v20 = (uint64_t **)(v21 + 1);
            goto LABEL_24;
          }
        }
        if (v19 >= *((float *)v21 + 10)) {
          goto LABEL_5;
        }
LABEL_29:
        id v26 = v10;

        id v32 = v26;
        int v7 = v6;
LABEL_5:

        ++v6;
        uint64_t v5 = *a1;
        uint64_t v4 = a1[1];
        if (v6 >= v4 - *a1) {
          goto LABEL_32;
        }
      }
      BOOL v14 = *v8;
      while (1)
      {
        while (1)
        {
          double v13 = v14;
          unint64_t v15 = v14[4];
          if ((unint64_t)v9 >= v15) {
            break;
          }
          BOOL v14 = (uint64_t *)*v13;
          double v12 = (uint64_t **)v13;
          if (!*v13) {
            goto LABEL_13;
          }
        }
        if (v15 >= (unint64_t)v9) {
          break;
        }
        BOOL v14 = (uint64_t *)v13[1];
        if (!v14)
        {
          double v12 = (uint64_t **)(v13 + 1);
          goto LABEL_13;
        }
      }
      float v19 = *((float *)v13 + 10);
      double v20 = a2 + 1;
      double v21 = (uint64_t *)(a2 + 1);
      if (v11) {
        goto LABEL_20;
      }
LABEL_24:
      int v23 = operator new(0x30uLL);
      v23[4] = v32;
      *((_DWORD *)v23 + 10) = 0;
      void *v23 = 0;
      v23[1] = 0;
      v23[2] = v21;
      *double v20 = v23;
      double v24 = (uint64_t *)**a2;
      double v25 = v23;
      if (v24)
      {
        *a2 = v24;
        double v25 = *v20;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a2[1], v25);
      a2[2] = (uint64_t *)((char *)a2[2] + 1);
      if (v19 >= *((float *)v23 + 10)) {
        goto LABEL_5;
      }
      goto LABEL_29;
    }
    int v7 = 0;
    uint64_t v5 = a1[1];
LABEL_32:
    uint64_t v27 = v7;
    double v28 = *(v4 - 1);
    *(v4 - 1) = 0;
    id v29 = v5[v27];
    v5[v27] = 0;
    double v30 = *(v4 - 1);
    *(v4 - 1) = v29;

    id v31 = v5[v27];
    v5[v27] = v28;
  }
}

void sub_235F14090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t *makeHeap(uint64_t *result, uint64_t **a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = (uint64_t **)*result;
    if (result[1] != *result)
    {
      unint64_t v5 = 0;
      int v6 = 0;
      int v7 = *v3;
      int v8 = a2 + 1;
      do
      {
        double v10 = v3[v5];
        uint64_t v11 = *v8;
        double v12 = v8;
        double v13 = (char *)v8;
        if (*v8)
        {
          BOOL v14 = *v8;
          while (1)
          {
            while (1)
            {
              double v13 = (char *)v14;
              unint64_t v15 = v14[4];
              if ((unint64_t)v10 >= v15) {
                break;
              }
              BOOL v14 = *(uint64_t **)v13;
              double v12 = (uint64_t **)v13;
              if (!*(void *)v13) {
                goto LABEL_15;
              }
            }
            if (v15 >= (unint64_t)v10) {
              break;
            }
            BOOL v14 = (uint64_t *)*((void *)v13 + 1);
            if (!v14)
            {
              double v12 = (uint64_t **)(v13 + 8);
              goto LABEL_15;
            }
          }
        }
        else
        {
LABEL_15:
          char v16 = v13;
          double v13 = (char *)operator new(0x30uLL);
          *((void *)v13 + 4) = v10;
          *((_DWORD *)v13 + 10) = 0;
          *(void *)double v13 = 0;
          *((void *)v13 + 1) = 0;
          *((void *)v13 + 2) = v16;
          *double v12 = (uint64_t *)v13;
          char v17 = (uint64_t *)**a2;
          double v18 = (uint64_t *)v13;
          if (v17)
          {
            *a2 = v17;
            double v18 = *v12;
          }
          BOOL result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a2[1], v18);
          uint64_t v11 = a2[1];
          a2[2] = (uint64_t *)((char *)a2[2] + 1);
        }
        float v19 = *((float *)v13 + 10);
        double v20 = v8;
        double v21 = v8;
        if (v11)
        {
          while (1)
          {
            while (1)
            {
              double v21 = (uint64_t **)v11;
              unint64_t v22 = v11[4];
              if ((unint64_t)v7 >= v22) {
                break;
              }
              uint64_t v11 = *v21;
              double v20 = v21;
              if (!*v21) {
                goto LABEL_25;
              }
            }
            if (v22 >= (unint64_t)v7) {
              break;
            }
            uint64_t v11 = v21[1];
            if (!v11)
            {
              double v20 = v21 + 1;
              goto LABEL_25;
            }
          }
        }
        else
        {
LABEL_25:
          int v23 = (uint64_t *)v21;
          double v21 = (uint64_t **)operator new(0x30uLL);
          v21[4] = v7;
          *((_DWORD *)v21 + 10) = 0;
          *double v21 = 0;
          v21[1] = 0;
          v21[2] = v23;
          *double v20 = (uint64_t *)v21;
          double v24 = (uint64_t *)**a2;
          double v25 = (uint64_t *)v21;
          if (v24)
          {
            *a2 = v24;
            double v25 = *v20;
          }
          BOOL result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a2[1], v25);
          a2[2] = (uint64_t *)((char *)a2[2] + 1);
        }
        if (v19 < *((float *)v21 + 10))
        {
          int v7 = v10;
          int v6 = v5;
        }
        ++v5;
        uint64_t v3 = (uint64_t **)*v2;
        uint64_t v9 = v2[1];
      }
      while (v5 < (v9 - *v2) >> 3);
      uint64_t v26 = v6;
      uint64_t v27 = *(uint64_t **)(v9 - 8);
      *(void *)(v9 - 8) = v3[v26];
      v3[v26] = v27;
    }
  }
  return result;
}

void GKFindPath(unint64_t a1, uint64_t *a2, char **a3)
{
  uint64_t v228 = 0;
  unint64_t v229 = 0;
  uint64_t v230 = 0;
  __p = 0;
  uint64_t v226 = 0;
  long long v227 = 0;
  float v223 = 0;
  uint64_t v224 = 0;
  uint64_t v221 = 0;
  unint64_t v222 = &v223;
  char v219 = &v220;
  uint64_t v220 = 0;
  unint64_t v217 = 0;
  uint64_t v218 = 0;
  unint64_t v216 = &v217;
  unint64_t v5 = operator new(0x30uLL);
  v5[4] = a1;
  *((_DWORD *)v5 + 10) = 0;
  *unint64_t v5 = 0;
  v5[1] = 0;
  v5[2] = &v220;
  char v219 = (uint64_t **)v5;
  uint64_t v220 = v5;
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v5, v5);
  ++v221;
  *((_DWORD *)v5 + 10) = 0;
  int v6 = v223;
  int v7 = &v223;
LABEL_3:
  int v8 = v7;
  if (v6)
  {
    while (1)
    {
      int v7 = (uint64_t **)v6;
      unint64_t v9 = v6[4];
      if (v9 > a1)
      {
        int v6 = *v7;
        goto LABEL_3;
      }
      if (v9 >= a1) {
        break;
      }
      int v6 = v7[1];
      if (!v6)
      {
        int v8 = v7 + 1;
        goto LABEL_8;
      }
    }
    *((_DWORD *)v7 + 10) = 0;
    double v12 = v217;
    double v13 = &v217;
    BOOL v14 = &v217;
    if (v217) {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_8:
    double v10 = operator new(0x30uLL);
    v10[4] = a1;
    *((_DWORD *)v10 + 10) = 0;
    *double v10 = 0;
    v10[1] = 0;
    v10[2] = v7;
    *int v8 = v10;
    uint64_t v11 = v10;
    if (*v222)
    {
      unint64_t v222 = (uint64_t **)*v222;
      uint64_t v11 = *v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v223, v11);
    ++v224;
    *((_DWORD *)v10 + 10) = 0;
    double v12 = v217;
    double v13 = &v217;
    BOOL v14 = &v217;
    if (v217)
    {
LABEL_13:
      unint64_t v15 = v12;
      while (1)
      {
        while (1)
        {
          double v13 = (uint64_t **)v15;
          unint64_t v16 = v15[4];
          if (v16 <= a1) {
            break;
          }
          unint64_t v15 = *v13;
          BOOL v14 = v13;
          if (!*v13) {
            goto LABEL_19;
          }
        }
        if (v16 >= a1) {
          break;
        }
        unint64_t v15 = v13[1];
        if (!v15)
        {
          BOOL v14 = v13 + 1;
          goto LABEL_19;
        }
      }
      v13[5] = 0;
      float v19 = &v217;
      double v20 = &v217;
      unint64_t v21 = (unint64_t)a2;
      if (v12) {
        goto LABEL_26;
      }
      goto LABEL_30;
    }
  }
LABEL_19:
  char v17 = (uint64_t *)operator new(0x30uLL);
  v17[4] = a1;
  v17[5] = 0;
  uint64_t *v17 = 0;
  v17[1] = 0;
  v17[2] = (uint64_t)v13;
  *BOOL v14 = v17;
  double v18 = v17;
  if (*v216)
  {
    unint64_t v216 = (uint64_t **)*v216;
    double v18 = *v14;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v217, v18);
  double v12 = v217;
  ++v218;
  v17[5] = 0;
  float v19 = &v217;
  double v20 = &v217;
  unint64_t v21 = (unint64_t)a2;
  if (v12)
  {
    while (1)
    {
LABEL_26:
      while (1)
      {
        float v19 = (uint64_t **)v12;
        unint64_t v22 = v12[4];
        if (v22 <= v21) {
          break;
        }
        double v12 = *v19;
        double v20 = v19;
        if (!*v19) {
          goto LABEL_30;
        }
      }
      if (v22 >= v21) {
        break;
      }
      double v12 = v19[1];
      if (!v12)
      {
        double v20 = v19 + 1;
        goto LABEL_30;
      }
    }
    v19[5] = 0;
    uint64_t v26 = v226;
    double v25 = v227;
    if (v226 < v227) {
      goto LABEL_33;
    }
    goto LABEL_35;
  }
LABEL_30:
  int v23 = (uint64_t *)operator new(0x30uLL);
  v23[4] = (uint64_t)a2;
  v23[5] = 0;
  uint64_t *v23 = 0;
  v23[1] = 0;
  v23[2] = (uint64_t)v19;
  *double v20 = v23;
  double v24 = v23;
  if (*v216)
  {
    unint64_t v216 = (uint64_t **)*v216;
    double v24 = *v20;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v217, v24);
  ++v218;
  v23[5] = 0;
  uint64_t v26 = v226;
  double v25 = v227;
  if (v226 < v227)
  {
LABEL_33:
    *(void *)uint64_t v26 = a1;
    uint64_t v27 = (uint64_t)(v26 + 8);
    goto LABEL_55;
  }
LABEL_35:
  double v28 = (char *)__p;
  int64_t v29 = v26 - (unsigned char *)__p;
  uint64_t v30 = (v26 - (unsigned char *)__p) >> 3;
  unint64_t v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 61) {
    _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
  }
  uint64_t v32 = v25 - (unsigned char *)__p;
  if (v32 >> 2 > v31) {
    unint64_t v31 = v32 >> 2;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v33 = v31;
  }
  if (!v33)
  {
    double v34 = 0;
    double v35 = (unint64_t *)(8 * v30);
    double v36 = 0;
    *(void *)(8 * v30) = a1;
    uint64_t v27 = 8 * v30 + 8;
    int64_t v37 = v26 - v28;
    if (v26 != v28) {
      goto LABEL_44;
    }
LABEL_53:
    __p = v35;
    uint64_t v226 = (char *)v27;
    long long v227 = v36;
    if (!v26) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  if (v33 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  double v34 = operator new(8 * v33);
  double v35 = (unint64_t *)&v34[8 * v30];
  double v36 = &v34[8 * v33];
  *double v35 = a1;
  uint64_t v27 = (uint64_t)(v35 + 1);
  int64_t v37 = v26 - v28;
  if (v26 == v28) {
    goto LABEL_53;
  }
LABEL_44:
  unint64_t v38 = v37 - 8;
  if (v38 < 0x58) {
    goto LABEL_354;
  }
  if ((unint64_t)(v26 - v34 - v29) < 0x20) {
    goto LABEL_354;
  }
  uint64_t v39 = (v38 >> 3) + 1;
  uint64_t v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
  double v41 = &v26[-v40];
  double v35 = (unint64_t *)((char *)v35 - v40);
  double v42 = &v34[8 * v30 - 16];
  double v43 = v26 - 16;
  uint64_t v44 = v39 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v45 = *(_OWORD *)v43;
    *(v42 - 1) = *((_OWORD *)v43 - 1);
    *double v42 = v45;
    v42 -= 2;
    v43 -= 32;
    v44 -= 4;
  }
  while (v44);
  uint64_t v26 = v41;
  if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_354:
    do
    {
      unint64_t v46 = *((void *)v26 - 1);
      v26 -= 8;
      *--double v35 = v46;
    }
    while (v26 != v28);
  }
  uint64_t v26 = (char *)__p;
  __p = v35;
  uint64_t v226 = (char *)v27;
  long long v227 = v36;
  if (v26) {
LABEL_54:
  }
    operator delete(v26);
LABEL_55:
  uint64_t v226 = (char *)v27;
  makeHeap((uint64_t *)&__p, (uint64_t **)&v222);
  unint64_t v214 = a3;
  float32x2_t v47 = v226;
  float32x2_t v48 = a2;
  if (__p == v226) {
    goto LABEL_339;
  }
  while (2)
  {
    float v51 = (uint64_t *)*((void *)v47 - 1);
    float32x2_t v49 = v47 - 8;
    float32x2_t v50 = v51;
    if (v51 == v48)
    {
      if (!v48) {
        goto LABEL_331;
      }
LABEL_299:
      int v181 = (uint64_t **)v214[1];
      unint64_t v180 = (unint64_t)v214[2];
      if ((unint64_t)v181 < v180)
      {
        uint64_t v182 = v48;
        char *v181 = v48;
        uint64_t v183 = (uint64_t)(v181 + 1);
LABEL_321:
        v214[1] = (char *)v183;
        uint64_t v201 = v217;
        for (i = &v217; ; uint64_t v201 = *i)
        {
          unint64_t v203 = i;
          if (!v201) {
            goto LABEL_328;
          }
          while (1)
          {
            double i = (uint64_t **)v201;
            unint64_t v204 = v201[4];
            if ((unint64_t)v182 < v204) {
              break;
            }
            if (v204 >= (unint64_t)v182)
            {
              float32x2_t v48 = i[5];
              if (v48) {
                goto LABEL_299;
              }
LABEL_331:
              uint64_t v207 = *v214;
              float64x2_t v208 = v214[1];
              float64x2_t v209 = v208 - 8;
              if (*v214 != v208 && v209 > v207)
              {
                unint64_t v211 = (unint64_t)(v207 + 8);
                do
                {
                  uint64_t v212 = *(void *)(v211 - 8);
                  *(void *)(v211 - 8) = *(void *)v209;
                  *(void *)float64x2_t v209 = v212;
                  v209 -= 8;
                  BOOL v213 = v211 >= (unint64_t)v209;
                  v211 += 8;
                }
                while (!v213);
              }
              goto LABEL_339;
            }
            uint64_t v201 = i[1];
            if (!v201)
            {
              unint64_t v203 = i + 1;
LABEL_328:
              unint64_t v205 = (uint64_t *)operator new(0x30uLL);
              v205[4] = (uint64_t)v182;
              v205[5] = 0;
              *unint64_t v205 = 0;
              v205[1] = 0;
              v205[2] = (uint64_t)i;
              *unint64_t v203 = v205;
              unint64_t v206 = v205;
              if (*v216)
              {
                unint64_t v216 = (uint64_t **)*v216;
                unint64_t v206 = *v203;
              }
              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v217, v206);
              ++v218;
              float32x2_t v48 = (uint64_t *)v205[5];
              if (!v48) {
                goto LABEL_331;
              }
              goto LABEL_299;
            }
          }
        }
      }
      long long v184 = *v214;
      uint64_t v185 = (char *)v181 - *v214;
      uint64_t v186 = v185 >> 3;
      unint64_t v187 = (v185 >> 3) + 1;
      if (v187 >> 61) {
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
      uint64_t v188 = v180 - (void)v184;
      if (v188 >> 2 > v187) {
        unint64_t v187 = v188 >> 2;
      }
      if ((unint64_t)v188 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v189 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v189 = v187;
      }
      if (v189)
      {
        if (v189 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        BOOL v190 = operator new(8 * v189);
        uint64_t v182 = v48;
        BOOL v191 = (uint64_t **)&v190[8 * v186];
        *BOOL v191 = v48;
        uint64_t v183 = (uint64_t)(v191 + 1);
        if (v181 == (uint64_t **)v184) {
          goto LABEL_319;
        }
      }
      else
      {
        uint64_t v182 = v48;
        BOOL v190 = 0;
        BOOL v191 = (uint64_t **)(8 * v186);
        *(void *)(8 * v186) = v48;
        uint64_t v183 = 8 * v186 + 8;
        if (v181 == (uint64_t **)v184)
        {
LABEL_319:
          *unint64_t v214 = (char *)v191;
          v214[1] = (char *)v183;
          v214[2] = &v190[8 * v189];
          if (v181) {
            operator delete(v181);
          }
          goto LABEL_321;
        }
      }
      unint64_t v192 = (char *)(v181 - 1) - v184;
      if (v192 < 0x58) {
        goto LABEL_355;
      }
      if ((unint64_t)((char *)v181 - &v190[v185]) < 0x20) {
        goto LABEL_355;
      }
      uint64_t v193 = (v192 >> 3) + 1;
      uint64_t v194 = 8 * (v193 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v195 = &v181[v194 / 0xFFFFFFFFFFFFFFF8];
      BOOL v191 = (uint64_t **)((char *)v191 - v194);
      unint64_t v196 = &v190[8 * v186 - 16];
      unint64_t v197 = v181 - 2;
      uint64_t v198 = v193 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v199 = *(_OWORD *)v197;
        *(v196 - 1) = *((_OWORD *)v197 - 1);
        *unint64_t v196 = v199;
        v196 -= 2;
        v197 -= 4;
        v198 -= 4;
      }
      while (v198);
      int v181 = v195;
      if (v193 != (v193 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_355:
        do
        {
          uint64_t v200 = *--v181;
          *--BOOL v191 = v200;
        }
        while (v181 != (uint64_t **)v184);
      }
      int v181 = (uint64_t **)*v214;
      goto LABEL_319;
    }
    uint64_t v226 = v49;
    makeHeap((uint64_t *)&__p, (uint64_t **)&v222);
    float32x2_t v52 = v228;
    float32x2_t v53 = v229;
    float32x2_t v54 = v228;
    if (v228 != v229)
    {
      while (*(uint64_t **)v54 != v50)
      {
        v54 += 8;
        if (v54 == v229)
        {
          float32x2_t v54 = v229;
          break;
        }
      }
    }
    if (v54 != v229) {
      goto LABEL_87;
    }
    if (v229 >= v230)
    {
      uint64_t v56 = (v229 - v228) >> 3;
      unint64_t v57 = v56 + 1;
      if ((unint64_t)(v56 + 1) >> 61) {
        _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
      }
      uint64_t v58 = v230 - v228;
      if ((v230 - v228) >> 2 > v57) {
        unint64_t v57 = v58 >> 2;
      }
      if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v59 = v57;
      }
      if (v59)
      {
        if (v59 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        float32x4_t v60 = operator new(8 * v59);
        float32x4_t v61 = &v60[8 * v56];
        *(void *)float32x4_t v61 = v50;
        uint64_t v55 = (uint64_t)(v61 + 8);
        if (v52 != v53)
        {
LABEL_75:
          unint64_t v62 = v53 - 8 - v52;
          if (v62 < 0x58) {
            goto LABEL_356;
          }
          if ((unint64_t)(v52 - v60) < 0x20) {
            goto LABEL_356;
          }
          uint64_t v63 = (v62 >> 3) + 1;
          uint64_t v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
          BOOL v65 = &v53[-v64];
          v61 -= v64;
          BOOL v66 = &v60[8 * v56 - 16];
          uint64_t v67 = (long long *)(v53 - 16);
          uint64_t v68 = v63 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v69 = *v67;
            *(v66 - 1) = *(v67 - 1);
            *BOOL v66 = v69;
            v66 -= 2;
            v67 -= 2;
            v68 -= 4;
          }
          while (v68);
          float32x2_t v53 = v65;
          if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_356:
            do
            {
              uint64_t v70 = *((void *)v53 - 1);
              v53 -= 8;
              *((void *)v61 - 1) = v70;
              v61 -= 8;
            }
            while (v53 != v52);
          }
          float32x2_t v52 = v228;
          uint64_t v228 = v61;
          uint64_t v230 = &v60[8 * v59];
          if (!v52) {
            goto LABEL_86;
          }
          goto LABEL_85;
        }
      }
      else
      {
        float32x4_t v60 = 0;
        float32x4_t v61 = (char *)(8 * v56);
        *(void *)(8 * v56) = v50;
        uint64_t v55 = 8 * v56 + 8;
        if (v52 != v53) {
          goto LABEL_75;
        }
      }
      uint64_t v228 = v61;
      uint64_t v230 = &v60[8 * v59];
      if (!v52) {
        goto LABEL_86;
      }
LABEL_85:
      operator delete(v52);
      goto LABEL_86;
    }
    *(void *)unint64_t v229 = v50;
    uint64_t v55 = (uint64_t)(v53 + 8);
LABEL_86:
    unint64_t v229 = (char *)v55;
    float32x2_t v48 = a2;
LABEL_87:
    for (double j = (unint64_t *)v50[1]; j != (unint64_t *)v50[2]; ++j)
    {
      unint64_t v72 = *j;
      float32x4_t v73 = v228;
      if (v228 != v229)
      {
        while (*(void *)v73 != v72)
        {
          v73 += 8;
          if (v73 == v229)
          {
            float32x4_t v73 = v229;
            break;
          }
        }
      }
      if (v73 == v229)
      {
        int16x4_t v74 = v220;
        int16x4_t v75 = &v220;
LABEL_97:
        float32x4_t v76 = v75;
        if (v74)
        {
          while (1)
          {
            int16x4_t v75 = (uint64_t **)v74;
            unint64_t v77 = v74[4];
            if ((unint64_t)v50 < v77)
            {
              int16x4_t v74 = *v75;
              goto LABEL_97;
            }
            if (v77 >= (unint64_t)v50) {
              break;
            }
            int16x4_t v74 = v75[1];
            if (!v74)
            {
              float32x4_t v76 = v75 + 1;
              goto LABEL_102;
            }
          }
          float v91 = *((float *)v75 + 10);
        }
        else
        {
LABEL_102:
          int16x4_t v78 = (uint64_t *)operator new(0x30uLL);
          v78[4] = (uint64_t)v50;
          *((_DWORD *)v78 + 10) = 0;
          *int16x4_t v78 = 0;
          v78[1] = 0;
          v78[2] = (uint64_t)v75;
          *float32x4_t v76 = v78;
          if (*v219)
          {
            char v219 = (uint64_t **)*v219;
            int16x4_t v78 = *v76;
          }
          float32x4_t v79 = v220;
          BOOL v80 = v78 == v220;
          *((unsigned char *)v78 + 24) = v78 == v220;
          if (!v80)
          {
            do
            {
              uint64_t v81 = v78[2];
              if (*(unsigned char *)(v81 + 24)) {
                break;
              }
              float32x4_t v82 = *(uint64_t **)(v81 + 16);
              uint64_t v83 = *v82;
              if (*v82 == v81)
              {
                uint64_t v86 = v82[1];
                if (!v86 || (v87 = *(unsigned __int8 *)(v86 + 24), int16x4_t v84 = (unsigned char *)(v86 + 24), v87))
                {
                  if (*(uint64_t **)v81 == v78)
                  {
                    *(unsigned char *)(v81 + 24) = 1;
                    *((unsigned char *)v82 + 24) = 0;
                    uint64_t v90 = *(void *)(v81 + 8);
                    *float32x4_t v82 = v90;
                    if (v90) {
                      goto LABEL_119;
                    }
                  }
                  else
                  {
                    float32x4_t v88 = *(uint64_t **)(v81 + 8);
                    uint64_t v89 = *v88;
                    *(void *)(v81 + 8) = *v88;
                    if (v89)
                    {
                      *(void *)(v89 + 16) = v81;
                      float32x4_t v82 = *(uint64_t **)(v81 + 16);
                    }
                    v88[2] = (uint64_t)v82;
                    *(void *)(*(void *)(v81 + 16) + 8 * (**(void **)(v81 + 16) != v81)) = v88;
                    *float32x4_t v88 = v81;
                    *(void *)(v81 + 16) = v88;
                    float32x4_t v82 = (uint64_t *)v88[2];
                    uint64_t v81 = *v82;
                    *((unsigned char *)v88 + 24) = 1;
                    *((unsigned char *)v82 + 24) = 0;
                    uint64_t v90 = *(void *)(v81 + 8);
                    *float32x4_t v82 = v90;
                    if (v90) {
LABEL_119:
                    }
                      *(void *)(v90 + 16) = v82;
                  }
                  *(void *)(v81 + 16) = v82[2];
                  *(void *)(v82[2] + 8 * (*(void *)v82[2] != (void)v82)) = v81;
                  *(void *)(v81 + 8) = v82;
LABEL_126:
                  v82[2] = v81;
                  break;
                }
              }
              else if (!v83 || (v85 = *(unsigned __int8 *)(v83 + 24), int16x4_t v84 = (unsigned char *)(v83 + 24), v85))
              {
                if (*(uint64_t **)v81 == v78)
                {
                  uint64_t v176 = v78[1];
                  *(void *)uint64_t v81 = v176;
                  if (v176)
                  {
                    *(void *)(v176 + 16) = v81;
                    float32x4_t v82 = *(uint64_t **)(v81 + 16);
                  }
                  v78[2] = (uint64_t)v82;
                  *(void *)(*(void *)(v81 + 16) + 8 * (**(void **)(v81 + 16) != v81)) = v78;
                  v78[1] = v81;
                  *(void *)(v81 + 16) = v78;
                  float32x4_t v82 = (uint64_t *)v78[2];
                  *((unsigned char *)v78 + 24) = 1;
                  *((unsigned char *)v82 + 24) = 0;
                  uint64_t v81 = v82[1];
                  float32x4_t v92 = *(uint64_t **)v81;
                  v82[1] = *(void *)v81;
                  if (v92) {
LABEL_124:
                  }
                    v92[2] = (uint64_t)v82;
                }
                else
                {
                  *(unsigned char *)(v81 + 24) = 1;
                  *((unsigned char *)v82 + 24) = 0;
                  uint64_t v81 = v82[1];
                  float32x4_t v92 = *(uint64_t **)v81;
                  v82[1] = *(void *)v81;
                  if (v92) {
                    goto LABEL_124;
                  }
                }
                *(void *)(v81 + 16) = v82[2];
                *(void *)(v82[2] + 8 * (*(void *)v82[2] != (void)v82)) = v81;
                *(void *)uint64_t v81 = v82;
                goto LABEL_126;
              }
              *(unsigned char *)(v81 + 24) = 1;
              int16x4_t v78 = v82;
              *((unsigned char *)v82 + 24) = v82 == v79;
              *int16x4_t v84 = 1;
            }
            while (v82 != v79);
          }
          ++v221;
          float v91 = 0.0;
        }
        (*(void (**)(uint64_t *, unint64_t))(*v50 + 24))(v50, v72);
        uint64_t v94 = (char *)__p;
        if (__p != v226)
        {
          while (*(void *)v94 != v72)
          {
            v94 += 8;
            if (v94 == v226)
            {
              uint64_t v94 = v226;
              break;
            }
          }
        }
        float v95 = v93 + v91;
        if (v94 != v226)
        {
          unsigned int v96 = v220;
          uint64_t v97 = &v220;
LABEL_135:
          uint64_t v98 = v97;
          if (v96)
          {
            while (1)
            {
              uint64_t v97 = (uint64_t **)v96;
              unint64_t v99 = v96[4];
              if (v72 < v99)
              {
                unsigned int v96 = *v97;
                goto LABEL_135;
              }
              if (v99 >= v72) {
                break;
              }
              unsigned int v96 = v97[1];
              if (!v96)
              {
                uint64_t v98 = v97 + 1;
                goto LABEL_140;
              }
            }
            if (v95 >= *((float *)v97 + 10)) {
              continue;
            }
          }
          else
          {
LABEL_140:
            uint64_t v100 = operator new(0x30uLL);
            v100[4] = v72;
            *((_DWORD *)v100 + 10) = 0;
            *uint64_t v100 = 0;
            v100[1] = 0;
            v100[2] = v97;
            *uint64_t v98 = v100;
            BOOL v101 = v100;
            if (*v219)
            {
              char v219 = (uint64_t **)*v219;
              BOOL v101 = *v98;
            }
            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v220, v101);
            ++v221;
            if (v95 >= *((float *)v100 + 10)) {
              continue;
            }
          }
        }
        uint64_t v102 = v217;
        int64x2_t v103 = &v217;
LABEL_147:
        int64_t v104 = v103;
        if (v102)
        {
          while (1)
          {
            int64x2_t v103 = (uint64_t **)v102;
            unint64_t v105 = v102[4];
            if (v72 < v105)
            {
              uint64_t v102 = *v103;
              goto LABEL_147;
            }
            if (v105 >= v72) {
              break;
            }
            uint64_t v102 = v103[1];
            if (!v102)
            {
              int64_t v104 = v103 + 1;
              goto LABEL_152;
            }
          }
          unint64_t v106 = (uint64_t *)v103;
        }
        else
        {
LABEL_152:
          unint64_t v106 = (uint64_t *)operator new(0x30uLL);
          v106[4] = v72;
          v106[5] = 0;
          *unint64_t v106 = 0;
          v106[1] = 0;
          v106[2] = (uint64_t)v103;
          *int64_t v104 = v106;
          uint64_t v107 = v106;
          if (*v216)
          {
            unint64_t v216 = (uint64_t **)*v216;
            uint64_t v107 = *v104;
          }
          uint64_t v108 = v217;
          BOOL v80 = v107 == v217;
          *((unsigned char *)v107 + 24) = v107 == v217;
          if (!v80)
          {
            do
            {
              uint64_t v109 = v107[2];
              if (*(unsigned char *)(v109 + 24)) {
                break;
              }
              uint64_t v110 = *(uint64_t **)(v109 + 16);
              uint64_t v111 = *v110;
              if (*v110 == v109)
              {
                uint64_t v114 = v110[1];
                if (!v114 || (v115 = *(unsigned __int8 *)(v114 + 24), uint64_t v112 = (unsigned char *)(v114 + 24), v115))
                {
                  if (*(uint64_t **)v109 == v107)
                  {
                    *(unsigned char *)(v109 + 24) = 1;
                    *((unsigned char *)v110 + 24) = 0;
                    uint64_t v118 = *(void *)(v109 + 8);
                    *uint64_t v110 = v118;
                    if (v118) {
                      goto LABEL_169;
                    }
                  }
                  else
                  {
                    uint64_t v116 = *(uint64_t **)(v109 + 8);
                    uint64_t v117 = *v116;
                    *(void *)(v109 + 8) = *v116;
                    if (v117)
                    {
                      *(void *)(v117 + 16) = v109;
                      uint64_t v110 = *(uint64_t **)(v109 + 16);
                    }
                    v116[2] = (uint64_t)v110;
                    *(void *)(*(void *)(v109 + 16) + 8 * (**(void **)(v109 + 16) != v109)) = v116;
                    *uint64_t v116 = v109;
                    *(void *)(v109 + 16) = v116;
                    uint64_t v110 = (uint64_t *)v116[2];
                    uint64_t v109 = *v110;
                    *((unsigned char *)v116 + 24) = 1;
                    *((unsigned char *)v110 + 24) = 0;
                    uint64_t v118 = *(void *)(v109 + 8);
                    *uint64_t v110 = v118;
                    if (v118) {
LABEL_169:
                    }
                      *(void *)(v118 + 16) = v110;
                  }
                  *(void *)(v109 + 16) = v110[2];
                  *(void *)(v110[2] + 8 * (*(void *)v110[2] != (void)v110)) = v109;
                  *(void *)(v109 + 8) = v110;
LABEL_176:
                  v110[2] = v109;
                  break;
                }
              }
              else if (!v111 || (v113 = *(unsigned __int8 *)(v111 + 24), uint64_t v112 = (unsigned char *)(v111 + 24), v113))
              {
                if (*(uint64_t **)v109 == v107)
                {
                  uint64_t v177 = v107[1];
                  *(void *)uint64_t v109 = v177;
                  if (v177)
                  {
                    *(void *)(v177 + 16) = v109;
                    uint64_t v110 = *(uint64_t **)(v109 + 16);
                  }
                  v107[2] = (uint64_t)v110;
                  *(void *)(*(void *)(v109 + 16) + 8 * (**(void **)(v109 + 16) != v109)) = v107;
                  v107[1] = v109;
                  *(void *)(v109 + 16) = v107;
                  uint64_t v110 = (uint64_t *)v107[2];
                  *((unsigned char *)v107 + 24) = 1;
                  *((unsigned char *)v110 + 24) = 0;
                  uint64_t v109 = v110[1];
                  uint64_t v119 = *(uint64_t **)v109;
                  v110[1] = *(void *)v109;
                  if (v119) {
LABEL_174:
                  }
                    v119[2] = (uint64_t)v110;
                }
                else
                {
                  *(unsigned char *)(v109 + 24) = 1;
                  *((unsigned char *)v110 + 24) = 0;
                  uint64_t v109 = v110[1];
                  uint64_t v119 = *(uint64_t **)v109;
                  v110[1] = *(void *)v109;
                  if (v119) {
                    goto LABEL_174;
                  }
                }
                *(void *)(v109 + 16) = v110[2];
                *(void *)(v110[2] + 8 * (*(void *)v110[2] != (void)v110)) = v109;
                *(void *)uint64_t v109 = v110;
                goto LABEL_176;
              }
              *(unsigned char *)(v109 + 24) = 1;
              uint64_t v107 = v110;
              *((unsigned char *)v110 + 24) = v110 == v108;
              *uint64_t v112 = 1;
            }
            while (v110 != v108);
          }
          ++v218;
        }
        v106[5] = (uint64_t)v50;
        uint64_t v120 = v220;
        __n128 v121 = &v220;
LABEL_180:
        __n128 v122 = v121;
        if (v120)
        {
          while (1)
          {
            __n128 v121 = (uint64_t **)v120;
            unint64_t v123 = v120[4];
            if (v72 < v123)
            {
              uint64_t v120 = *v121;
              goto LABEL_180;
            }
            if (v123 >= v72) {
              break;
            }
            uint64_t v120 = v121[1];
            if (!v120)
            {
              __n128 v122 = v121 + 1;
              goto LABEL_185;
            }
          }
          __n128 v124 = v121;
        }
        else
        {
LABEL_185:
          __n128 v124 = operator new(0x30uLL);
          v124[4] = v72;
          *((_DWORD *)v124 + 10) = 0;
          void *v124 = 0;
          v124[1] = 0;
          v124[2] = v121;
          *__n128 v122 = v124;
          __n128 v125 = v124;
          if (*v219)
          {
            char v219 = (uint64_t **)*v219;
            __n128 v125 = *v122;
          }
          __n128 v126 = v220;
          BOOL v80 = v125 == v220;
          *((unsigned char *)v125 + 24) = v125 == v220;
          if (!v80)
          {
            do
            {
              uint64_t v127 = v125[2];
              if (*(unsigned char *)(v127 + 24)) {
                break;
              }
              __n128 v128 = *(uint64_t **)(v127 + 16);
              uint64_t v129 = *v128;
              if (*v128 == v127)
              {
                uint64_t v132 = v128[1];
                if (!v132 || (v133 = *(unsigned __int8 *)(v132 + 24), long long v130 = (unsigned char *)(v132 + 24), v133))
                {
                  if (*(uint64_t **)v127 == v125)
                  {
                    *(unsigned char *)(v127 + 24) = 1;
                    *((unsigned char *)v128 + 24) = 0;
                    uint64_t v136 = *(void *)(v127 + 8);
                    uint64_t *v128 = v136;
                    if (v136) {
                      goto LABEL_202;
                    }
                  }
                  else
                  {
                    __n128 v134 = *(uint64_t **)(v127 + 8);
                    uint64_t v135 = *v134;
                    *(void *)(v127 + 8) = *v134;
                    if (v135)
                    {
                      *(void *)(v135 + 16) = v127;
                      __n128 v128 = *(uint64_t **)(v127 + 16);
                    }
                    v134[2] = (uint64_t)v128;
                    *(void *)(*(void *)(v127 + 16) + 8 * (**(void **)(v127 + 16) != v127)) = v134;
                    *__n128 v134 = v127;
                    *(void *)(v127 + 16) = v134;
                    __n128 v128 = (uint64_t *)v134[2];
                    uint64_t v127 = *v128;
                    *((unsigned char *)v134 + 24) = 1;
                    *((unsigned char *)v128 + 24) = 0;
                    uint64_t v136 = *(void *)(v127 + 8);
                    uint64_t *v128 = v136;
                    if (v136) {
LABEL_202:
                    }
                      *(void *)(v136 + 16) = v128;
                  }
                  *(void *)(v127 + 16) = v128[2];
                  *(void *)(v128[2] + 8 * (*(void *)v128[2] != (void)v128)) = v127;
                  *(void *)(v127 + 8) = v128;
LABEL_209:
                  v128[2] = v127;
                  break;
                }
              }
              else if (!v129 || (v131 = *(unsigned __int8 *)(v129 + 24), long long v130 = (unsigned char *)(v129 + 24), v131))
              {
                if (*(uint64_t **)v127 == v125)
                {
                  uint64_t v178 = v125[1];
                  *(void *)uint64_t v127 = v178;
                  if (v178)
                  {
                    *(void *)(v178 + 16) = v127;
                    __n128 v128 = *(uint64_t **)(v127 + 16);
                  }
                  v125[2] = (uint64_t)v128;
                  *(void *)(*(void *)(v127 + 16) + 8 * (**(void **)(v127 + 16) != v127)) = v125;
                  v125[1] = v127;
                  *(void *)(v127 + 16) = v125;
                  __n128 v128 = (uint64_t *)v125[2];
                  *((unsigned char *)v125 + 24) = 1;
                  *((unsigned char *)v128 + 24) = 0;
                  uint64_t v127 = v128[1];
                  __n128 v137 = *(uint64_t **)v127;
                  v128[1] = *(void *)v127;
                  if (v137) {
LABEL_207:
                  }
                    v137[2] = (uint64_t)v128;
                }
                else
                {
                  *(unsigned char *)(v127 + 24) = 1;
                  *((unsigned char *)v128 + 24) = 0;
                  uint64_t v127 = v128[1];
                  __n128 v137 = *(uint64_t **)v127;
                  v128[1] = *(void *)v127;
                  if (v137) {
                    goto LABEL_207;
                  }
                }
                *(void *)(v127 + 16) = v128[2];
                *(void *)(v128[2] + 8 * (*(void *)v128[2] != (void)v128)) = v127;
                *(void *)uint64_t v127 = v128;
                goto LABEL_209;
              }
              *(unsigned char *)(v127 + 24) = 1;
              __n128 v125 = v128;
              *((unsigned char *)v128 + 24) = v128 == v126;
              *long long v130 = 1;
            }
            while (v128 != v126);
          }
          ++v221;
        }
        *((float *)v124 + 10) = v95;
        float v138 = (*(float (**)(unint64_t, uint64_t *))(*(void *)v72 + 16))(v72, v48);
        __n128 v139 = v223;
        __n128 v140 = &v223;
LABEL_213:
        __n128 v141 = v140;
        if (v139)
        {
          while (1)
          {
            __n128 v140 = (uint64_t **)v139;
            unint64_t v142 = v139[4];
            if (v72 < v142)
            {
              __n128 v139 = *v140;
              goto LABEL_213;
            }
            if (v142 >= v72) {
              break;
            }
            __n128 v139 = v140[1];
            if (!v139)
            {
              __n128 v141 = v140 + 1;
              goto LABEL_218;
            }
          }
          *((float *)v140 + 10) = v138 + v95;
          unint64_t v157 = (char *)__p;
          uint64_t v156 = v226;
          uint64_t v158 = (char *)__p;
          if (__p != v226) {
            goto LABEL_245;
          }
        }
        else
        {
LABEL_218:
          __n128 v143 = operator new(0x30uLL);
          v143[4] = v72;
          *((_DWORD *)v143 + 10) = 0;
          *__n128 v143 = 0;
          v143[1] = 0;
          v143[2] = v140;
          *__n128 v141 = v143;
          __n128 v144 = v143;
          if (*v222)
          {
            unint64_t v222 = (uint64_t **)*v222;
            __n128 v144 = *v141;
          }
          __n128 v145 = v223;
          BOOL v80 = v144 == v223;
          *((unsigned char *)v144 + 24) = v144 == v223;
          if (!v80)
          {
            do
            {
              uint64_t v146 = v144[2];
              if (*(unsigned char *)(v146 + 24)) {
                break;
              }
              __n128 v147 = *(uint64_t **)(v146 + 16);
              uint64_t v148 = *v147;
              if (*v147 == v146)
              {
                uint64_t v151 = v147[1];
                if (!v151 || (v152 = *(unsigned __int8 *)(v151 + 24), unint64_t v149 = (unsigned char *)(v151 + 24), v152))
                {
                  if (*(uint64_t **)v146 == v144)
                  {
                    *(unsigned char *)(v146 + 24) = 1;
                    *((unsigned char *)v147 + 24) = 0;
                    uint64_t v155 = *(void *)(v146 + 8);
                    *__n128 v147 = v155;
                    if (v155) {
                      goto LABEL_235;
                    }
                  }
                  else
                  {
                    uint64_t v153 = *(uint64_t **)(v146 + 8);
                    uint64_t v154 = *v153;
                    *(void *)(v146 + 8) = *v153;
                    if (v154)
                    {
                      *(void *)(v154 + 16) = v146;
                      __n128 v147 = *(uint64_t **)(v146 + 16);
                    }
                    v153[2] = (uint64_t)v147;
                    *(void *)(*(void *)(v146 + 16) + 8 * (**(void **)(v146 + 16) != v146)) = v153;
                    *uint64_t v153 = v146;
                    *(void *)(v146 + 16) = v153;
                    __n128 v147 = (uint64_t *)v153[2];
                    uint64_t v146 = *v147;
                    *((unsigned char *)v153 + 24) = 1;
                    *((unsigned char *)v147 + 24) = 0;
                    uint64_t v155 = *(void *)(v146 + 8);
                    *__n128 v147 = v155;
                    if (v155) {
LABEL_235:
                    }
                      *(void *)(v155 + 16) = v147;
                  }
                  *(void *)(v146 + 16) = v147[2];
                  *(void *)(v147[2] + 8 * (*(void *)v147[2] != (void)v147)) = v146;
                  *(void *)(v146 + 8) = v147;
LABEL_243:
                  v147[2] = v146;
                  break;
                }
              }
              else if (!v148 || (v150 = *(unsigned __int8 *)(v148 + 24), unint64_t v149 = (unsigned char *)(v148 + 24), v150))
              {
                if (*(uint64_t **)v146 == v144)
                {
                  uint64_t v179 = v144[1];
                  *(void *)uint64_t v146 = v179;
                  if (v179)
                  {
                    *(void *)(v179 + 16) = v146;
                    __n128 v147 = *(uint64_t **)(v146 + 16);
                  }
                  v144[2] = (uint64_t)v147;
                  *(void *)(*(void *)(v146 + 16) + 8 * (**(void **)(v146 + 16) != v146)) = v144;
                  v144[1] = v146;
                  *(void *)(v146 + 16) = v144;
                  __n128 v147 = (uint64_t *)v144[2];
                  *((unsigned char *)v144 + 24) = 1;
                  *((unsigned char *)v147 + 24) = 0;
                  uint64_t v146 = v147[1];
                  uint64_t v159 = *(uint64_t **)v146;
                  v147[1] = *(void *)v146;
                  if (v159) {
LABEL_241:
                  }
                    v159[2] = (uint64_t)v147;
                }
                else
                {
                  *(unsigned char *)(v146 + 24) = 1;
                  *((unsigned char *)v147 + 24) = 0;
                  uint64_t v146 = v147[1];
                  uint64_t v159 = *(uint64_t **)v146;
                  v147[1] = *(void *)v146;
                  if (v159) {
                    goto LABEL_241;
                  }
                }
                *(void *)(v146 + 16) = v147[2];
                *(void *)(v147[2] + 8 * (*(void *)v147[2] != (void)v147)) = v146;
                *(void *)uint64_t v146 = v147;
                goto LABEL_243;
              }
              *(unsigned char *)(v146 + 24) = 1;
              __n128 v144 = v147;
              *((unsigned char *)v147 + 24) = v147 == v145;
              *unint64_t v149 = 1;
            }
            while (v147 != v145);
          }
          ++v224;
          *((float *)v143 + 10) = v138 + v95;
          unint64_t v157 = (char *)__p;
          uint64_t v156 = v226;
          uint64_t v158 = (char *)__p;
          if (__p != v226)
          {
LABEL_245:
            while (*(void *)v158 != v72)
            {
              v158 += 8;
              if (v158 == v156)
              {
                uint64_t v158 = v156;
                break;
              }
            }
          }
        }
        if (v158 == v156)
        {
          if (v156 < v227)
          {
            *(void *)uint64_t v156 = v72;
            uint64_t v160 = (uint64_t)(v156 + 8);
LABEL_275:
            uint64_t v226 = (char *)v160;
            makeHeap((uint64_t *)&__p, (uint64_t **)&v222);
            float32x2_t v48 = a2;
            continue;
          }
          uint64_t v161 = (v156 - v157) >> 3;
          unint64_t v162 = v161 + 1;
          if ((unint64_t)(v161 + 1) >> 61) {
            _ZNKSt3__16vectorI12GKCRTreeNodeI8NSObjectDv2_fENS_9allocatorIS4_EEE20__throw_length_errorB8ne180100Ev();
          }
          uint64_t v163 = v227 - v157;
          if ((v227 - v157) >> 2 > v162) {
            unint64_t v162 = v163 >> 2;
          }
          if ((unint64_t)v163 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v164 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v164 = v162;
          }
          if (v164)
          {
            if (v164 >> 61) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            unint64_t v165 = operator new(8 * v164);
            uint64_t v166 = (unint64_t *)&v165[8 * v161];
            *uint64_t v166 = v72;
            uint64_t v160 = (uint64_t)(v166 + 1);
            if (v157 != v156) {
              goto LABEL_260;
            }
LABEL_273:
            __p = v166;
            uint64_t v226 = (char *)v160;
            long long v227 = &v165[8 * v164];
            if (!v157) {
              goto LABEL_275;
            }
          }
          else
          {
            unint64_t v165 = 0;
            uint64_t v166 = (unint64_t *)(8 * v161);
            *(void *)(8 * v161) = v72;
            uint64_t v160 = 8 * v161 + 8;
            if (v157 == v156) {
              goto LABEL_273;
            }
LABEL_260:
            unint64_t v167 = v156 - 8 - v157;
            if (v167 < 0x58) {
              goto LABEL_357;
            }
            if ((unint64_t)(v157 - v165) < 0x20) {
              goto LABEL_357;
            }
            uint64_t v168 = (v167 >> 3) + 1;
            uint64_t v169 = 8 * (v168 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v170 = &v156[-v169];
            uint64_t v166 = (unint64_t *)((char *)v166 - v169);
            uint64_t v171 = &v165[8 * v161 - 16];
            uint64_t v172 = v156 - 16;
            uint64_t v173 = v168 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v174 = *(_OWORD *)v172;
              *(v171 - 1) = *((_OWORD *)v172 - 1);
              *uint64_t v171 = v174;
              v171 -= 2;
              v172 -= 32;
              v173 -= 4;
            }
            while (v173);
            uint64_t v156 = v170;
            if (v168 != (v168 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_357:
              do
              {
                unint64_t v175 = *((void *)v156 - 1);
                v156 -= 8;
                *--uint64_t v166 = v175;
              }
              while (v156 != v157);
            }
            unint64_t v157 = (char *)__p;
            __p = v166;
            uint64_t v226 = (char *)v160;
            long long v227 = &v165[8 * v164];
            if (!v157) {
              goto LABEL_275;
            }
          }
          operator delete(v157);
          goto LABEL_275;
        }
      }
    }
    float32x2_t v47 = v226;
    if (__p != v226) {
      continue;
    }
    break;
  }
LABEL_339:
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&v216, v217);
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&v219, v220);
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&v222, v223);
  if (__p)
  {
    uint64_t v226 = (char *)__p;
    operator delete(__p);
  }
  if (v228) {
    operator delete(v228);
  }
}

void sub_235F1572C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, void *a16, uint64_t a17, char a18, void *a19, uint64_t a20,char a21,void *a22,uint64_t a23,void *__p,uint64_t a25)
{
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&a15, a16);
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&a18, a19);
  std::__tree<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::__map_value_compare<p2t::Triangle *,std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>,std::less<p2t::Triangle *>,true>,std::allocator<std::__value_type<p2t::Triangle *,GKTriangleGraphNodes>>>::destroy((uint64_t)&a21, a22);
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
    uint64_t v27 = *(void **)(v25 - 128);
    if (!v27) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    uint64_t v27 = *(void **)(v25 - 128);
    if (!v27) {
      goto LABEL_3;
    }
  }
  *(void *)(v25 - 120) = v27;
  operator delete(v27);
  _Unwind_Resume(a1);
}

id GKFindPath(GKGraphNode *a1, GKGraphNode *a2)
{
  uint64_t v3 = a1;
  uint64_t v177 = v3;
  long long v174 = 0;
  unint64_t v175 = 0;
  unint64_t v176 = 0;
  __p = 0;
  uint64_t v172 = 0;
  unint64_t v173 = 0;
  uint64_t v169 = 0;
  uint64_t v170 = 0;
  uint64_t v159 = a2;
  uint64_t v167 = 0;
  uint64_t v168 = &v169;
  unint64_t v165 = &v166;
  uint64_t v166 = 0;
  uint64_t v163 = 0;
  uint64_t v164 = 0;
  unint64_t v162 = &v163;
  uint64_t v4 = operator new(0x30uLL);
  v4[4] = v3;
  *((_DWORD *)v4 + 10) = 0;
  void *v4 = 0;
  v4[1] = 0;
  v4[2] = &v166;
  uint64_t v166 = v4;
  if (*v165) {
    unint64_t v165 = (uint64_t **)*v165;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v4, v4);
  ++v167;
  *((_DWORD *)v4 + 10) = 0;
  unint64_t v5 = v169;
  int v6 = v177;
  int v7 = &v169;
LABEL_5:
  int v8 = v7;
  if (v5)
  {
    while (1)
    {
      int v7 = (uint64_t **)v5;
      unint64_t v9 = v5[4];
      if ((unint64_t)v177 < v9)
      {
        unint64_t v5 = *v7;
        goto LABEL_5;
      }
      if (v9 >= (unint64_t)v177) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        int v8 = v7 + 1;
        goto LABEL_10;
      }
    }
    *((_DWORD *)v7 + 10) = 0;
    double v12 = v163;
    double v13 = &v163;
    BOOL v14 = &v163;
    if (v163) {
      goto LABEL_17;
    }
    goto LABEL_21;
  }
LABEL_10:
  double v10 = operator new(0x30uLL);
  v10[4] = v6;
  *((_DWORD *)v10 + 10) = 0;
  *double v10 = 0;
  v10[1] = 0;
  v10[2] = v7;
  *int v8 = v10;
  uint64_t v11 = v10;
  if (*v168)
  {
    uint64_t v168 = (uint64_t **)*v168;
    uint64_t v11 = *v8;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v169, v11);
  ++v170;
  int v6 = v177;
  *((_DWORD *)v10 + 10) = 0;
  double v12 = v163;
  double v13 = &v163;
  BOOL v14 = &v163;
  if (!v163)
  {
LABEL_21:
    unint64_t v16 = (uint64_t *)operator new(0x30uLL);
    v16[4] = (uint64_t)v6;
    v16[5] = 0;
    uint64_t *v16 = 0;
    v16[1] = 0;
    v16[2] = (uint64_t)v14;
    *double v13 = v16;
    char v17 = v16;
    if (*v162)
    {
      unint64_t v162 = (uint64_t **)*v162;
      char v17 = *v13;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v163, v17);
    ++v164;
    goto LABEL_25;
  }
  while (1)
  {
LABEL_17:
    while (1)
    {
      BOOL v14 = (uint64_t **)v12;
      unint64_t v15 = v12[4];
      if ((unint64_t)v6 >= v15) {
        break;
      }
      double v12 = *v14;
      double v13 = v14;
      if (!*v14) {
        goto LABEL_21;
      }
    }
    if (v15 >= (unint64_t)v6) {
      break;
    }
    double v12 = v14[1];
    if (!v12)
    {
      double v13 = v14 + 1;
      goto LABEL_21;
    }
  }
  unint64_t v16 = (uint64_t *)v14;
LABEL_25:
  double v18 = (void *)v16[5];
  v16[5] = 0;

  float v19 = v163;
  double v20 = &v163;
  unint64_t v21 = &v163;
  if (v163)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v21 = (uint64_t **)v19;
        unint64_t v22 = v19[4];
        if (v22 <= (unint64_t)v159) {
          break;
        }
        float v19 = *v21;
        double v20 = v21;
        if (!*v21) {
          goto LABEL_32;
        }
      }
      if (v22 >= (unint64_t)v159) {
        break;
      }
      float v19 = v21[1];
      if (!v19)
      {
        double v20 = v21 + 1;
        goto LABEL_32;
      }
    }
    double v28 = v21[5];
    v21[5] = 0;

    uint64_t v26 = v172;
    if ((unint64_t)v172 >= v173) {
      goto LABEL_37;
    }
LABEL_35:
    *uint64_t v26 = v177;
    uint64_t v27 = v26 + 1;
    goto LABEL_38;
  }
LABEL_32:
  int v23 = (uint64_t *)operator new(0x30uLL);
  v23[4] = (uint64_t)v159;
  v23[5] = 0;
  uint64_t *v23 = 0;
  v23[1] = 0;
  v23[2] = (uint64_t)v21;
  *double v20 = v23;
  double v24 = v23;
  if (*v162)
  {
    unint64_t v162 = (uint64_t **)*v162;
    double v24 = *v20;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v163, v24);
  ++v164;
  uint64_t v25 = (void *)v23[5];
  v23[5] = 0;

  uint64_t v26 = v172;
  if ((unint64_t)v172 < v173) {
    goto LABEL_35;
  }
LABEL_37:
  uint64_t v27 = (id *)std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(&__p, (id *)&v177);
LABEL_38:
  uint64_t v172 = v27;
  makeHeap((id **)&__p, (uint64_t **)&v168);
  int64_t v29 = v172;
  if (__p == v172)
  {
LABEL_242:
    uint64_t v136 = [MEMORY[0x263EFF8C0] array];
  }
  else
  {
    while (1)
    {
      obdouble j = *(v29 - 1);
      if (obj == v159) {
        break;
      }
      uint64_t v30 = v172 - 1;

      uint64_t v172 = v30;
      makeHeap((id **)&__p, (uint64_t **)&v168);
      unint64_t v31 = (id *)v174;
      uint64_t v32 = v175;
      if (v174 != v175)
      {
        while (*v31 != obj)
        {
          if (++v31 == v175)
          {
            unint64_t v31 = v175;
            break;
          }
        }
      }
      if (v31 == v175)
      {
        if ((unint64_t)v175 >= v176)
        {
          unint64_t v33 = (id *)std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(&v174, &obj);
        }
        else
        {
          *uint64_t v32 = obj;
          unint64_t v33 = v32 + 1;
        }
        unint64_t v175 = v33;
      }
      double v34 = [obj connectedNodes];
      unsigned int v35 = [v34 count];

      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = 0;
        while (1)
        {
          unint64_t v38 = [obj connectedNodes];
          id v160 = [v38 objectAtIndexedSubscript:v37];

          uint64_t v39 = (id *)v174;
          if (v174 != v175)
          {
            while (*v39 != v160)
            {
              if (++v39 == v175)
              {
                uint64_t v39 = v175;
                break;
              }
            }
          }
          if (v39 != v175) {
            goto LABEL_54;
          }
          uint64_t v40 = v166;
          id v41 = obj;
          double v42 = &v166;
          double v43 = &v166;
          if (v166)
          {
            while (1)
            {
              while (1)
              {
                double v43 = (uint64_t **)v40;
                unint64_t v44 = v40[4];
                if ((unint64_t)obj >= v44) {
                  break;
                }
                uint64_t v40 = *v43;
                double v42 = v43;
                if (!*v43) {
                  goto LABEL_66;
                }
              }
              if (v44 >= (unint64_t)obj) {
                break;
              }
              uint64_t v40 = v43[1];
              if (!v40)
              {
                double v42 = v43 + 1;
                goto LABEL_66;
              }
            }
            float v58 = *((float *)v43 + 10);
          }
          else
          {
LABEL_66:
            long long v45 = (uint64_t *)operator new(0x30uLL);
            v45[4] = (uint64_t)v41;
            *((_DWORD *)v45 + 10) = 0;
            uint64_t *v45 = 0;
            v45[1] = 0;
            v45[2] = (uint64_t)v43;
            *double v42 = v45;
            if (*v165)
            {
              unint64_t v165 = (uint64_t **)*v165;
              long long v45 = *v42;
            }
            unint64_t v46 = v166;
            BOOL v47 = v45 == v166;
            *((unsigned char *)v45 + 24) = v45 == v166;
            if (!v47)
            {
              do
              {
                uint64_t v48 = v45[2];
                if (*(unsigned char *)(v48 + 24)) {
                  break;
                }
                float32x2_t v49 = *(uint64_t **)(v48 + 16);
                uint64_t v50 = *v49;
                if (*v49 == v48)
                {
                  uint64_t v53 = v49[1];
                  if (!v53 || (v54 = *(unsigned __int8 *)(v53 + 24), float v51 = (unsigned char *)(v53 + 24), v54))
                  {
                    if (*(uint64_t **)v48 == v45)
                    {
                      *(unsigned char *)(v48 + 24) = 1;
                      *((unsigned char *)v49 + 24) = 0;
                      uint64_t v57 = *(void *)(v48 + 8);
                      *float32x2_t v49 = v57;
                      if (v57) {
                        goto LABEL_83;
                      }
                    }
                    else
                    {
                      uint64_t v55 = *(uint64_t **)(v48 + 8);
                      uint64_t v56 = *v55;
                      *(void *)(v48 + 8) = *v55;
                      if (v56)
                      {
                        *(void *)(v56 + 16) = v48;
                        float32x2_t v49 = *(uint64_t **)(v48 + 16);
                      }
                      v55[2] = (uint64_t)v49;
                      *(void *)(*(void *)(v48 + 16) + 8 * (**(void **)(v48 + 16) != v48)) = v55;
                      *uint64_t v55 = v48;
                      *(void *)(v48 + 16) = v55;
                      float32x2_t v49 = (uint64_t *)v55[2];
                      uint64_t v48 = *v49;
                      *((unsigned char *)v55 + 24) = 1;
                      *((unsigned char *)v49 + 24) = 0;
                      uint64_t v57 = *(void *)(v48 + 8);
                      *float32x2_t v49 = v57;
                      if (v57) {
LABEL_83:
                      }
                        *(void *)(v57 + 16) = v49;
                    }
                    *(void *)(v48 + 16) = v49[2];
                    *(void *)(v49[2] + 8 * (*(void *)v49[2] != (void)v49)) = v48;
                    *(void *)(v48 + 8) = v49;
LABEL_90:
                    v49[2] = v48;
                    break;
                  }
                }
                else if (!v50 || (v52 = *(unsigned __int8 *)(v50 + 24), float v51 = (unsigned char *)(v50 + 24), v52))
                {
                  if (*(uint64_t **)v48 == v45)
                  {
                    uint64_t v132 = v45[1];
                    *(void *)uint64_t v48 = v132;
                    if (v132)
                    {
                      *(void *)(v132 + 16) = v48;
                      float32x2_t v49 = *(uint64_t **)(v48 + 16);
                    }
                    v45[2] = (uint64_t)v49;
                    *(void *)(*(void *)(v48 + 16) + 8 * (**(void **)(v48 + 16) != v48)) = v45;
                    v45[1] = v48;
                    *(void *)(v48 + 16) = v45;
                    float32x2_t v49 = (uint64_t *)v45[2];
                    *((unsigned char *)v45 + 24) = 1;
                    *((unsigned char *)v49 + 24) = 0;
                    uint64_t v48 = v49[1];
                    unint64_t v59 = *(uint64_t **)v48;
                    v49[1] = *(void *)v48;
                    if (v59) {
LABEL_88:
                    }
                      void v59[2] = (uint64_t)v49;
                  }
                  else
                  {
                    *(unsigned char *)(v48 + 24) = 1;
                    *((unsigned char *)v49 + 24) = 0;
                    uint64_t v48 = v49[1];
                    unint64_t v59 = *(uint64_t **)v48;
                    v49[1] = *(void *)v48;
                    if (v59) {
                      goto LABEL_88;
                    }
                  }
                  *(void *)(v48 + 16) = v49[2];
                  *(void *)(v49[2] + 8 * (*(void *)v49[2] != (void)v49)) = v48;
                  *(void *)uint64_t v48 = v49;
                  goto LABEL_90;
                }
                *(unsigned char *)(v48 + 24) = 1;
                long long v45 = v49;
                *((unsigned char *)v49 + 24) = v49 == v46;
                *float v51 = 1;
              }
              while (v49 != v46);
            }
            ++v167;
            float v58 = 0.0;
            id v41 = obj;
          }
          [v41 costToNode:v160];
          float32x4_t v61 = (id *)__p;
          id v62 = v160;
          if (__p != v172)
          {
            while (*v61 != v160)
            {
              if (++v61 == v172)
              {
                float32x4_t v61 = v172;
                break;
              }
            }
          }
          float v63 = v60 + v58;
          if (v61 == v172) {
            goto LABEL_110;
          }
          uint64_t v64 = v166;
          BOOL v65 = &v166;
          BOOL v66 = &v166;
          if (v166) {
            break;
          }
LABEL_104:
          uint64_t v68 = operator new(0x30uLL);
          v68[4] = v62;
          *((_DWORD *)v68 + 10) = 0;
          *uint64_t v68 = 0;
          v68[1] = 0;
          v68[2] = v66;
          *BOOL v65 = v68;
          long long v69 = v68;
          if (*v165)
          {
            unint64_t v165 = (uint64_t **)*v165;
            long long v69 = *v65;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v166, v69);
          ++v167;
          if (v63 < *((float *)v68 + 10)) {
            goto LABEL_109;
          }
LABEL_54:

          if (++v37 == v36) {
            goto LABEL_40;
          }
        }
        while (1)
        {
          while (1)
          {
            BOOL v66 = (uint64_t **)v64;
            unint64_t v67 = v64[4];
            if ((unint64_t)v160 >= v67) {
              break;
            }
            uint64_t v64 = *v66;
            BOOL v65 = v66;
            if (!*v66) {
              goto LABEL_104;
            }
          }
          if (v67 >= (unint64_t)v160) {
            break;
          }
          uint64_t v64 = v66[1];
          if (!v64)
          {
            BOOL v65 = v66 + 1;
            goto LABEL_104;
          }
        }
        if (v63 >= *((float *)v66 + 10)) {
          goto LABEL_54;
        }
LABEL_109:
        id v62 = v160;
LABEL_110:
        id v70 = obj;
        float32x4_t v71 = v163;
        unint64_t v72 = &v163;
        float32x4_t v73 = &v163;
        if (v163)
        {
          while (1)
          {
            while (1)
            {
              float32x4_t v73 = (uint64_t **)v71;
              unint64_t v74 = v71[4];
              if ((unint64_t)v62 >= v74) {
                break;
              }
              float32x4_t v71 = *v73;
              unint64_t v72 = v73;
              if (!*v73) {
                goto LABEL_117;
              }
            }
            if (v74 >= (unint64_t)v62) {
              break;
            }
            float32x4_t v71 = v73[1];
            if (!v71)
            {
              unint64_t v72 = v73 + 1;
              goto LABEL_117;
            }
          }
          int16x4_t v75 = v73;
        }
        else
        {
LABEL_117:
          int16x4_t v75 = operator new(0x30uLL);
          *((void *)v75 + 4) = v62;
          *((void *)v75 + 5) = 0;
          *(void *)int16x4_t v75 = 0;
          *((void *)v75 + 1) = 0;
          *((void *)v75 + 2) = v73;
          *unint64_t v72 = (uint64_t *)v75;
          float32x4_t v76 = (uint64_t *)v75;
          if (*v162)
          {
            unint64_t v162 = (uint64_t **)*v162;
            float32x4_t v76 = *v72;
          }
          unint64_t v77 = v163;
          BOOL v47 = v76 == v163;
          *((unsigned char *)v76 + 24) = v76 == v163;
          if (!v47)
          {
            do
            {
              uint64_t v78 = v76[2];
              if (*(unsigned char *)(v78 + 24)) {
                break;
              }
              float32x4_t v79 = *(uint64_t **)(v78 + 16);
              uint64_t v80 = *v79;
              if (*v79 == v78)
              {
                uint64_t v83 = v79[1];
                if (!v83 || (v84 = *(unsigned __int8 *)(v83 + 24), uint64_t v81 = (unsigned char *)(v83 + 24), v84))
                {
                  if (*(uint64_t **)v78 == v76)
                  {
                    *(unsigned char *)(v78 + 24) = 1;
                    *((unsigned char *)v79 + 24) = 0;
                    uint64_t v87 = *(void *)(v78 + 8);
                    uint64_t *v79 = v87;
                    if (v87) {
                      goto LABEL_134;
                    }
                  }
                  else
                  {
                    int v85 = *(uint64_t **)(v78 + 8);
                    uint64_t v86 = *v85;
                    *(void *)(v78 + 8) = *v85;
                    if (v86)
                    {
                      *(void *)(v86 + 16) = v78;
                      float32x4_t v79 = *(uint64_t **)(v78 + 16);
                    }
                    v85[2] = (uint64_t)v79;
                    *(void *)(*(void *)(v78 + 16) + 8 * (**(void **)(v78 + 16) != v78)) = v85;
                    *int v85 = v78;
                    *(void *)(v78 + 16) = v85;
                    float32x4_t v79 = (uint64_t *)v85[2];
                    uint64_t v78 = *v79;
                    *((unsigned char *)v85 + 24) = 1;
                    *((unsigned char *)v79 + 24) = 0;
                    uint64_t v87 = *(void *)(v78 + 8);
                    uint64_t *v79 = v87;
                    if (v87) {
LABEL_134:
                    }
                      *(void *)(v87 + 16) = v79;
                  }
                  *(void *)(v78 + 16) = v79[2];
                  *(void *)(v79[2] + 8 * (*(void *)v79[2] != (void)v79)) = v78;
                  *(void *)(v78 + 8) = v79;
LABEL_141:
                  v79[2] = v78;
                  break;
                }
              }
              else if (!v80 || (v82 = *(unsigned __int8 *)(v80 + 24), uint64_t v81 = (unsigned char *)(v80 + 24), v82))
              {
                if (*(uint64_t **)v78 == v76)
                {
                  uint64_t v133 = v76[1];
                  *(void *)uint64_t v78 = v133;
                  if (v133)
                  {
                    *(void *)(v133 + 16) = v78;
                    float32x4_t v79 = *(uint64_t **)(v78 + 16);
                  }
                  v76[2] = (uint64_t)v79;
                  *(void *)(*(void *)(v78 + 16) + 8 * (**(void **)(v78 + 16) != v78)) = v76;
                  v76[1] = v78;
                  *(void *)(v78 + 16) = v76;
                  float32x4_t v79 = (uint64_t *)v76[2];
                  *((unsigned char *)v76 + 24) = 1;
                  *((unsigned char *)v79 + 24) = 0;
                  uint64_t v78 = v79[1];
                  float32x4_t v88 = *(uint64_t **)v78;
                  v79[1] = *(void *)v78;
                  if (v88) {
LABEL_139:
                  }
                    v88[2] = (uint64_t)v79;
                }
                else
                {
                  *(unsigned char *)(v78 + 24) = 1;
                  *((unsigned char *)v79 + 24) = 0;
                  uint64_t v78 = v79[1];
                  float32x4_t v88 = *(uint64_t **)v78;
                  v79[1] = *(void *)v78;
                  if (v88) {
                    goto LABEL_139;
                  }
                }
                *(void *)(v78 + 16) = v79[2];
                *(void *)(v79[2] + 8 * (*(void *)v79[2] != (void)v79)) = v78;
                *(void *)uint64_t v78 = v79;
                goto LABEL_141;
              }
              *(unsigned char *)(v78 + 24) = 1;
              float32x4_t v76 = v79;
              *((unsigned char *)v79 + 24) = v79 == v77;
              *uint64_t v81 = 1;
            }
            while (v79 != v77);
          }
          ++v164;
        }
        objc_storeStrong((id *)v75 + 5, v70);
        uint64_t v89 = v166;
        id v90 = v160;
        float v91 = &v166;
        float32x4_t v92 = &v166;
        if (v166)
        {
          while (1)
          {
            while (1)
            {
              float32x4_t v92 = (uint64_t **)v89;
              unint64_t v93 = v89[4];
              if ((unint64_t)v160 >= v93) {
                break;
              }
              uint64_t v89 = *v92;
              float v91 = v92;
              if (!*v92) {
                goto LABEL_150;
              }
            }
            if (v93 >= (unint64_t)v160) {
              break;
            }
            uint64_t v89 = v92[1];
            if (!v89)
            {
              float v91 = v92 + 1;
              goto LABEL_150;
            }
          }
          uint64_t v94 = v92;
        }
        else
        {
LABEL_150:
          uint64_t v94 = operator new(0x30uLL);
          v94[4] = v90;
          *((_DWORD *)v94 + 10) = 0;
          *uint64_t v94 = 0;
          v94[1] = 0;
          v94[2] = v92;
          *float v91 = v94;
          float v95 = v94;
          if (*v165)
          {
            unint64_t v165 = (uint64_t **)*v165;
            float v95 = *v91;
          }
          unsigned int v96 = v166;
          BOOL v47 = v95 == v166;
          *((unsigned char *)v95 + 24) = v95 == v166;
          if (!v47)
          {
            do
            {
              uint64_t v97 = v95[2];
              if (*(unsigned char *)(v97 + 24)) {
                break;
              }
              uint64_t v98 = *(uint64_t **)(v97 + 16);
              uint64_t v99 = *v98;
              if (*v98 == v97)
              {
                uint64_t v102 = v98[1];
                if (!v102 || (v103 = *(unsigned __int8 *)(v102 + 24), uint64_t v100 = (unsigned char *)(v102 + 24), v103))
                {
                  if (*(uint64_t **)v97 == v95)
                  {
                    *(unsigned char *)(v97 + 24) = 1;
                    *((unsigned char *)v98 + 24) = 0;
                    uint64_t v106 = *(void *)(v97 + 8);
                    *uint64_t v98 = v106;
                    if (v106) {
                      goto LABEL_167;
                    }
                  }
                  else
                  {
                    int64_t v104 = *(uint64_t **)(v97 + 8);
                    uint64_t v105 = *v104;
                    *(void *)(v97 + 8) = *v104;
                    if (v105)
                    {
                      *(void *)(v105 + 16) = v97;
                      uint64_t v98 = *(uint64_t **)(v97 + 16);
                    }
                    v104[2] = (uint64_t)v98;
                    *(void *)(*(void *)(v97 + 16) + 8 * (**(void **)(v97 + 16) != v97)) = v104;
                    *int64_t v104 = v97;
                    *(void *)(v97 + 16) = v104;
                    uint64_t v98 = (uint64_t *)v104[2];
                    uint64_t v97 = *v98;
                    *((unsigned char *)v104 + 24) = 1;
                    *((unsigned char *)v98 + 24) = 0;
                    uint64_t v106 = *(void *)(v97 + 8);
                    *uint64_t v98 = v106;
                    if (v106) {
LABEL_167:
                    }
                      *(void *)(v106 + 16) = v98;
                  }
                  *(void *)(v97 + 16) = v98[2];
                  *(void *)(v98[2] + 8 * (*(void *)v98[2] != (void)v98)) = v97;
                  *(void *)(v97 + 8) = v98;
LABEL_174:
                  v98[2] = v97;
                  break;
                }
              }
              else if (!v99 || (v101 = *(unsigned __int8 *)(v99 + 24), uint64_t v100 = (unsigned char *)(v99 + 24), v101))
              {
                if (*(uint64_t **)v97 == v95)
                {
                  uint64_t v134 = v95[1];
                  *(void *)uint64_t v97 = v134;
                  if (v134)
                  {
                    *(void *)(v134 + 16) = v97;
                    uint64_t v98 = *(uint64_t **)(v97 + 16);
                  }
                  v95[2] = (uint64_t)v98;
                  *(void *)(*(void *)(v97 + 16) + 8 * (**(void **)(v97 + 16) != v97)) = v95;
                  v95[1] = v97;
                  *(void *)(v97 + 16) = v95;
                  uint64_t v98 = (uint64_t *)v95[2];
                  *((unsigned char *)v95 + 24) = 1;
                  *((unsigned char *)v98 + 24) = 0;
                  uint64_t v97 = v98[1];
                  uint64_t v107 = *(uint64_t **)v97;
                  v98[1] = *(void *)v97;
                  if (v107) {
LABEL_172:
                  }
                    v107[2] = (uint64_t)v98;
                }
                else
                {
                  *(unsigned char *)(v97 + 24) = 1;
                  *((unsigned char *)v98 + 24) = 0;
                  uint64_t v97 = v98[1];
                  uint64_t v107 = *(uint64_t **)v97;
                  v98[1] = *(void *)v97;
                  if (v107) {
                    goto LABEL_172;
                  }
                }
                *(void *)(v97 + 16) = v98[2];
                *(void *)(v98[2] + 8 * (*(void *)v98[2] != (void)v98)) = v97;
                *(void *)uint64_t v97 = v98;
                goto LABEL_174;
              }
              *(unsigned char *)(v97 + 24) = 1;
              float v95 = v98;
              *((unsigned char *)v98 + 24) = v98 == v96;
              *uint64_t v100 = 1;
            }
            while (v98 != v96);
          }
          ++v167;
          id v90 = v160;
        }
        *((float *)v94 + 10) = v63;
        [v90 estimatedCostToNode:v159];
        float v109 = v108;
        uint64_t v110 = v169;
        id v111 = v160;
        uint64_t v112 = &v169;
LABEL_178:
        int v113 = v112;
        if (v110)
        {
          while (1)
          {
            uint64_t v112 = (uint64_t **)v110;
            unint64_t v114 = v110[4];
            if ((unint64_t)v160 < v114)
            {
              uint64_t v110 = *v112;
              goto LABEL_178;
            }
            if (v114 >= (unint64_t)v160) {
              break;
            }
            uint64_t v110 = v112[1];
            if (!v110)
            {
              int v113 = v112 + 1;
              goto LABEL_183;
            }
          }
          *((float *)v112 + 10) = v108 + v63;
          __n128 v128 = (id *)__p;
          uint64_t v129 = v172;
          if (__p != v172) {
            goto LABEL_210;
          }
        }
        else
        {
LABEL_183:
          int v115 = operator new(0x30uLL);
          v115[4] = v111;
          *((_DWORD *)v115 + 10) = 0;
          *int v115 = 0;
          v115[1] = 0;
          v115[2] = v112;
          *int v113 = v115;
          uint64_t v116 = v115;
          if (*v168)
          {
            uint64_t v168 = (uint64_t **)*v168;
            uint64_t v116 = *v113;
          }
          uint64_t v117 = v169;
          BOOL v47 = v116 == v169;
          *((unsigned char *)v116 + 24) = v116 == v169;
          if (!v47)
          {
            do
            {
              uint64_t v118 = v116[2];
              if (*(unsigned char *)(v118 + 24)) {
                break;
              }
              uint64_t v119 = *(uint64_t **)(v118 + 16);
              uint64_t v120 = *v119;
              if (*v119 == v118)
              {
                uint64_t v123 = v119[1];
                if (!v123 || (v124 = *(unsigned __int8 *)(v123 + 24), __n128 v121 = (unsigned char *)(v123 + 24), v124))
                {
                  if (*(uint64_t **)v118 == v116)
                  {
                    *(unsigned char *)(v118 + 24) = 1;
                    *((unsigned char *)v119 + 24) = 0;
                    uint64_t v127 = *(void *)(v118 + 8);
                    *uint64_t v119 = v127;
                    if (v127) {
                      goto LABEL_200;
                    }
                  }
                  else
                  {
                    __n128 v125 = *(uint64_t **)(v118 + 8);
                    uint64_t v126 = *v125;
                    *(void *)(v118 + 8) = *v125;
                    if (v126)
                    {
                      *(void *)(v126 + 16) = v118;
                      uint64_t v119 = *(uint64_t **)(v118 + 16);
                    }
                    v125[2] = (uint64_t)v119;
                    *(void *)(*(void *)(v118 + 16) + 8 * (**(void **)(v118 + 16) != v118)) = v125;
                    *__n128 v125 = v118;
                    *(void *)(v118 + 16) = v125;
                    uint64_t v119 = (uint64_t *)v125[2];
                    uint64_t v118 = *v119;
                    *((unsigned char *)v125 + 24) = 1;
                    *((unsigned char *)v119 + 24) = 0;
                    uint64_t v127 = *(void *)(v118 + 8);
                    *uint64_t v119 = v127;
                    if (v127) {
LABEL_200:
                    }
                      *(void *)(v127 + 16) = v119;
                  }
                  *(void *)(v118 + 16) = v119[2];
                  *(void *)(v119[2] + 8 * (*(void *)v119[2] != (void)v119)) = v118;
                  *(void *)(v118 + 8) = v119;
LABEL_208:
                  v119[2] = v118;
                  break;
                }
              }
              else if (!v120 || (v122 = *(unsigned __int8 *)(v120 + 24), __n128 v121 = (unsigned char *)(v120 + 24), v122))
              {
                if (*(uint64_t **)v118 == v116)
                {
                  uint64_t v135 = v116[1];
                  *(void *)uint64_t v118 = v135;
                  if (v135)
                  {
                    *(void *)(v135 + 16) = v118;
                    uint64_t v119 = *(uint64_t **)(v118 + 16);
                  }
                  v116[2] = (uint64_t)v119;
                  *(void *)(*(void *)(v118 + 16) + 8 * (**(void **)(v118 + 16) != v118)) = v116;
                  v116[1] = v118;
                  *(void *)(v118 + 16) = v116;
                  uint64_t v119 = (uint64_t *)v116[2];
                  *((unsigned char *)v116 + 24) = 1;
                  *((unsigned char *)v119 + 24) = 0;
                  uint64_t v118 = v119[1];
                  long long v130 = *(uint64_t **)v118;
                  v119[1] = *(void *)v118;
                  if (v130) {
LABEL_206:
                  }
                    v130[2] = (uint64_t)v119;
                }
                else
                {
                  *(unsigned char *)(v118 + 24) = 1;
                  *((unsigned char *)v119 + 24) = 0;
                  uint64_t v118 = v119[1];
                  long long v130 = *(uint64_t **)v118;
                  v119[1] = *(void *)v118;
                  if (v130) {
                    goto LABEL_206;
                  }
                }
                *(void *)(v118 + 16) = v119[2];
                *(void *)(v119[2] + 8 * (*(void *)v119[2] != (void)v119)) = v118;
                *(void *)uint64_t v118 = v119;
                goto LABEL_208;
              }
              *(unsigned char *)(v118 + 24) = 1;
              uint64_t v116 = v119;
              *((unsigned char *)v119 + 24) = v119 == v117;
              *__n128 v121 = 1;
            }
            while (v119 != v117);
          }
          ++v170;
          *((float *)v115 + 10) = v109 + v63;
          __n128 v128 = (id *)__p;
          uint64_t v129 = v172;
          if (__p != v172)
          {
LABEL_210:
            while (*v128 != v160)
            {
              if (++v128 == v129)
              {
                __n128 v128 = v129;
                break;
              }
            }
          }
        }
        if (v128 == v129)
        {
          if ((unint64_t)v129 >= v173)
          {
            int v131 = (id *)std::vector<NSObject * {__strong}>::__push_back_slow_path<NSObject * const {__strong}&>(&__p, &v160);
          }
          else
          {
            *uint64_t v129 = v160;
            int v131 = v129 + 1;
          }
          uint64_t v172 = v131;
          makeHeap((id **)&__p, (uint64_t **)&v168);
        }
        goto LABEL_54;
      }
LABEL_40:

      int64_t v29 = v172;
      if (__p == v172) {
        goto LABEL_242;
      }
    }

    __n128 v137 = [MEMORY[0x263EFF980] array];
    float v138 = v159;
    if (v138)
    {
      __n128 v139 = v138;
      do
      {
        while (1)
        {
          [v137 addObject:v139];
          __n128 v141 = v163;
          unint64_t v142 = &v163;
          __n128 v143 = &v163;
          if (v163) {
            break;
          }
LABEL_253:
          __n128 v145 = operator new(0x30uLL);
          *((void *)v145 + 4) = v139;
          *((void *)v145 + 5) = 0;
          *(void *)__n128 v145 = 0;
          *((void *)v145 + 1) = 0;
          *((void *)v145 + 2) = v143;
          *unint64_t v142 = (uint64_t *)v145;
          uint64_t v146 = (uint64_t *)v145;
          if (*v162)
          {
            unint64_t v162 = (uint64_t **)*v162;
            uint64_t v146 = *v142;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v163, v146);
          ++v164;
          id v140 = *((id *)v145 + 5);

          __n128 v139 = v140;
          if (!v140) {
            goto LABEL_256;
          }
        }
        while (1)
        {
          while (1)
          {
            __n128 v143 = (uint64_t **)v141;
            unint64_t v144 = v141[4];
            if ((unint64_t)v139 >= v144) {
              break;
            }
            __n128 v141 = *v143;
            unint64_t v142 = v143;
            if (!*v143) {
              goto LABEL_253;
            }
          }
          if (v144 >= (unint64_t)v139) {
            break;
          }
          __n128 v141 = v143[1];
          if (!v141)
          {
            unint64_t v142 = v143 + 1;
            goto LABEL_253;
          }
        }
        __n128 v147 = v143[5];

        __n128 v139 = v147;
      }
      while (v147);
    }
LABEL_256:
    uint64_t v148 = [v137 reverseObjectEnumerator];
    uint64_t v136 = [v148 allObjects];
  }
  id v149 = v136;

  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&v162, v163);
  std::__tree<std::__value_type<GKGraphNode * {__strong},float>,std::__map_value_compare<GKGraphNode * {__strong},std::__value_type<GKGraphNode * {__strong},float>,std::less<GKGraphNode * {__strong}>,true>,std::allocator<std::__value_type<GKGraphNode * {__strong},float>>>::destroy((uint64_t)&v165, v166);
  std::__tree<std::__value_type<GKGraphNode * {__strong},float>,std::__map_value_compare<GKGraphNode * {__strong},std::__value_type<GKGraphNode * {__strong},float>,std::less<GKGraphNode * {__strong}>,true>,std::allocator<std::__value_type<GKGraphNode * {__strong},float>>>::destroy((uint64_t)&v168, v169);
  int v150 = (id *)__p;
  if (__p)
  {
    uint64_t v151 = v172;
    int v152 = __p;
    if (v172 != __p)
    {
      do
      {
        uint64_t v153 = *--v151;
      }
      while (v151 != v150);
      int v152 = __p;
    }
    uint64_t v172 = v150;
    operator delete(v152);
  }
  uint64_t v154 = (id *)v174;
  if (v174)
  {
    uint64_t v155 = v175;
    uint64_t v156 = v174;
    if (v175 != v174)
    {
      do
      {
        unint64_t v157 = *--v155;
      }
      while (v155 != v154);
      uint64_t v156 = v174;
    }
    unint64_t v175 = v154;
    operator delete(v156);
  }

  return v149;
}

void sub_235F16920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, char a17, void *a18, uint64_t a19, char a20,void *a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26)
{
  std::__tree<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::__map_value_compare<NSString * {__strong},std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>,std::less<NSString * {__strong}>,true>,std::allocator<std::__value_type<NSString * {__strong},NSMutableArray * {__strong}>>>::destroy((uint64_t)&a14, a15);
  std::__tree<std::__value_type<GKGraphNode * {__strong},float>,std::__map_value_compare<GKGraphNode * {__strong},std::__value_type<GKGraphNode * {__strong},float>,std::less<GKGraphNode * {__strong}>,true>,std::allocator<std::__value_type<GKGraphNode * {__strong},float>>>::destroy((uint64_t)&a17, a18);
  std::__tree<std::__value_type<GKGraphNode * {__strong},float>,std::__map_value_compare<GKGraphNode * {__strong},std::__value_type<GKGraphNode * {__strong},float>,std::less<GKGraphNode * {__strong}>,true>,std::allocator<std::__value_type<GKGraphNode * {__strong},float>>>::destroy((uint64_t)&a20, a21);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100](&a23);
  std::vector<NSObject * {__strong}>::~vector[abi:ne180100](&a26);

  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<GKGraphNode * {__strong},float>,std::__map_value_compare<GKGraphNode * {__strong},std::__value_type<GKGraphNode * {__strong},float>,std::less<GKGraphNode * {__strong}>,true>,std::allocator<std::__value_type<GKGraphNode * {__strong},float>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<GKGraphNode * {__strong},float>,std::__map_value_compare<GKGraphNode * {__strong},std::__value_type<GKGraphNode * {__strong},float>,std::less<GKGraphNode * {__strong}>,true>,std::allocator<std::__value_type<GKGraphNode * {__strong},float>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<GKGraphNode * {__strong},float>,std::__map_value_compare<GKGraphNode * {__strong},std::__value_type<GKGraphNode * {__strong},float>,std::less<GKGraphNode * {__strong}>,true>,std::allocator<std::__value_type<GKGraphNode * {__strong},float>>>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

void sub_235F16AF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F17A20(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x10A1C40E6F5D9E2);
  _Unwind_Resume(a1);
}

void sub_235F17AEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F17B68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F17BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F17DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F17E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F17EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F17F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F180B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F181FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F18284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F18320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F183C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F18458(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F18C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_235F18DC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F18DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F18DE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RepairGKSceneNodeReferencesRelativeToScene(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v3 = a2;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  obuint64_t j = [a1 entities];
  uint64_t v17 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v17)
  {
    uint64_t v16 = *(void *)v23;
    do
    {
      for (uint64_t i = 0; i != v17; ++i)
      {
        if (*(void *)v23 != v16) {
          objc_enumerationMutation(obj);
        }
        unint64_t v5 = *(void **)(*((void *)&v22 + 1) + 8 * i);
        long long v18 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        int v6 = [v5 components];
        uint64_t v7 = [v6 countByEnumeratingWithState:&v18 objects:v26 count:16];
        if (v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = *(void *)v19;
          do
          {
            for (uint64_t j = 0; j != v8; ++j)
            {
              if (*(void *)v19 == v9)
              {
                uint64_t v11 = *(void **)(*((void *)&v18 + 1) + 8 * j);
                if (![v11 conformsToProtocol:&unk_26E94CAA0]) {
                  continue;
                }
              }
              else
              {
                objc_enumerationMutation(v6);
                uint64_t v11 = *(void **)(*((void *)&v18 + 1) + 8 * j);
                if (![v11 conformsToProtocol:&unk_26E94CAA0]) {
                  continue;
                }
              }
              id v12 = v11;
              double v13 = [v12 serializableNodeIndexPath];
              BOOL v14 = [v3 _subnodeFromIndexPath:v13];
              [v12 setNode:v14];

              [v12 setSerializableNodeIndexPath:0];
            }
            uint64_t v8 = [v6 countByEnumeratingWithState:&v18 objects:v26 count:16];
          }
          while (v8);
        }
      }
      uint64_t v17 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
    }
    while (v17);
  }
}

void sub_235F1A4A0(_Unwind_Exception *a1)
{
  MEMORY[0x237DF7CA0](v1, 0x1081C40AB1E6056);
  _Unwind_Resume(a1);
}

void sub_235F1A5E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F1A750(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F1A83C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_235F1A984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F1AC04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F1AD70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_235F1AE2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *p2t::SweepContext::GetMap(uint64_t **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  BOOL result = *a1;
  uint64_t v5 = *result;
  *(void *)(v5 + 8) = *(void *)(a2 + 8);
  **(void **)(a2 + 8) = v5;
  *a3 = 0;
  if (result != a4)
  {
    do
    {
      uint64_t v7 = (uint64_t *)result[1];
      operator delete(result);
      BOOL result = v7;
    }
    while (v7 != a4);
  }
  return result;
}

void p2t::Edge::Edge()
{
}

void GKCObstacleGraph::removeObstacle()
{
  __assert_rtn("removeObstacle", "GKCGraph.mm", 493, "findIt != _extrudedObjCObstacles.end()");
}

void GKCQuadTreeNode<NSObject>::GKCQuadTreeNode(uint64_t a1, char *a2, void **a3)
{
  uint64_t v5 = *(char **)(a1 + 96);
  int v6 = a2;
  if (v5 != a2)
  {
    do
    {
      uint64_t v8 = (void *)*((void *)v5 - 1);
      v5 -= 8;
    }
    while (v5 != a2);
    int v6 = *a3;
  }
  *(void *)(a1 + 96) = a2;

  operator delete(v6);
}

void p2t::Triangle::MarkNeighbor()
{
}

void p2t::Triangle::OppositePoint()
{
}

void p2t::Triangle::Legalize()
{
}

void p2t::Triangle::Index()
{
}

void p2t::Triangle::PointCCW()
{
}

void GKCOctreeNode<NSObject>::GKCOctreeNode(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = (void *)OUTLINED_FUNCTION_0(a1, a2);
  if (!v7)
  {
    uint64_t v8 = v6;
    do
    {
      uint64_t v9 = *(void **)(v4 - 8);
      v4 -= 8;
    }
    while (v4 != v2);
    uint64_t v5 = *v8;
  }
  *(void *)(v3 + 184) = v2;

  operator delete(v5);
}

void GKCOctreeNode<NSObject>::createNodeForOctant()
{
}

void p2t::AdvancingFront::LocatePoint()
{
}

void p2t::Sweep::EdgeEvent(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x237DF7B90](a1, "EdgeEvent - collinear points not supported");
  MEMORY[0x237DF7BA0](v1);
  __assert_rtn("EdgeEvent", "sweep.cc", 125, "0");
}

{
  uint64_t v1;

  uint64_t v1 = MEMORY[0x237DF7B90](a1, "EdgeEvent - collinear points not supported");
  MEMORY[0x237DF7BA0](v1);
  __assert_rtn("EdgeEvent", "sweep.cc", 142, "0");
}

void p2t::Sweep::FlipEdgeEvent()
{
}

{
  __assert_rtn("NextFlipPoint", "sweep.cc", 771, "0");
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x270EF2A50](aClassName);
}

NSZone *NSDefaultMallocZone(void)
{
  return (NSZone *)MEMORY[0x270EF2A70]();
}

void NSLog(NSString *format, ...)
{
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x270EF2BE8](aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x270EF2C08](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x270EF2C38](aSelector);
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return MEMORY[0x270EFDC20](rnd, count, bytes);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983B0](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

uint64_t std::ostream::put()
{
  return MEMORY[0x270F98740]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x270F98748]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F98790]();
}

{
  return MEMORY[0x270F987D8]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x270F98F30](lpsrc, lpstype, lpdtype, s2d);
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x270ED7E88](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x270ED7E90](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

uint64_t _dyld_get_prog_image_header()
{
  return MEMORY[0x270ED7F80]();
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

long double acos(long double __x)
{
  MEMORY[0x270ED8588](__x);
  return result;
}

uint32_t arc4random(void)
{
  return MEMORY[0x270ED85E0]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x270ED85F8](*(void *)&__upper_bound);
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x270ED86A8](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x270ED86B8](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

uint64_t dyld_image_path_containing_address()
{
  return MEMORY[0x270ED96D8]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x270ED9718]();
}

float fmodf(float a1, float a2)
{
  MEMORY[0x270ED99D8](a1, a2);
  return result;
}

void free(void *a1)
{
}

long double log(long double __x)
{
  MEMORY[0x270EDA0A8](__x);
  return result;
}

float logf(float a1)
{
  MEMORY[0x270EDA0F8](a1);
  return result;
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

uint64_t objc_copyClassesForImage()
{
  return MEMORY[0x270F9A5C8]();
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x270F9A6B0](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x270F9A728]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x270F9A898](a1);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x270F9A9F8](location, obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9AA38](a1);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x270EDACF8](__x, __y);
  return result;
}

int rand(void)
{
  return MEMORY[0x270EDB0D8]();
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

long double tan(long double __x)
{
  MEMORY[0x270EDB810](__x);
  return result;
}